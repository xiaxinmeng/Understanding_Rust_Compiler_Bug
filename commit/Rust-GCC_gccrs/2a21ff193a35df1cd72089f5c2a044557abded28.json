{"sha": "2a21ff193a35df1cd72089f5c2a044557abded28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmEyMWZmMTkzYTM1ZGYxY2Q3MjA4OWY1YzJhMDQ0NTU3YWJkZWQyOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2015-08-24T17:10:06Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-08-24T17:10:06Z"}, "message": "libgomp.map: Add 4.0.2 version.\n\n\tlibgomp/\n\t* libgomp.map: Add 4.0.2 version.\n\t* target.c (offload_image_descr): Add version field.\n\t(gomp_load_image_to_device): Add version argument.  Adjust plugin\n\tcall.  Improve load mismatch diagnostic.\n\t(gomp_unload_image_from_device): Add version argument.  Adjust plugin\n\tcall.\n\t(GOMP_offload_regster): Make stub function, move bulk to ...\n\t(GOMP_offload_register_ver): ... here.  Process version argument.\n\t(GOMP_offload_unregister): Make stub function, move bulk to ...\n\t(GOMP_offload_unregister_ver): ... here.  Process version argument.\n\t(gomp_init_device): Process version field.\n\t(gomp_unload_device): Process version field.\n\t(gomp_load_plugin_for_device): Reimplement DLSYM & DLSYM_OPT\n\tmacros.  Check plugin version.\n\t* libgomp.h (gomp_device_descr): Add version function field.  Adjust\n\tloader and unloader types.\n\t* oacc-host.c: Include gomp-constants.h.\n\t(host_version): New.\n\t(host_load_image, host_unload_image): Adjust.\n\t(host_dispatch): Add host_version.\n\t* plugin/plugin-nvptx.c: Include gomp-constants.h.\n\t(GOMP_OFFLOAD_version): New.\n\t(GOMP_OFFLOAD_load_image): Add version arg and check it.\n\t(GOMP_OFFLOAD_unload_image): Likewise.\n\t* plugin/plugin-host.c: Include gomp-constants.h.\n\t(GOMP_OFFLOAD_version): New.\n\t(GOMP_OFFLOAD_load_image): Add version arg.\n\t(GOMP_OFFLOAD_unload_image): Likewise.\n\n\tliboffloadmic/\n\t* plugin/libgomp-plugin-intelmic.cpp (GOMP_OFFLOAD_version): New.\n\t(GOMP_OFFLOAD_load_image): Add version arg and check it.\n\t(GOMP_OFFLOAD_unload_image): Likewise.\n\n\tinclude/\n\t* gomp-constants.h (GOMP_VERSION, GOMP_VERSION_NVIDIA_PTX,\n\tGOMP_VERSION_INTEL_MIC): New.\n\t(GOMP_VERSION_PACK, GOMP_VERSION_LIB, GOMP_VERSION_DEV): New.\n\n\tgcc/\n\t* config/nvptx/mkoffload.c (process): Replace\n\tGOMP_offload_{,un}register with GOMP_offload_{,un}register_ver.\n\nFrom-SVN: r227137", "tree": {"sha": "139836bcec017a86c8257b2582f253251c7abb45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/139836bcec017a86c8257b2582f253251c7abb45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a21ff193a35df1cd72089f5c2a044557abded28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a21ff193a35df1cd72089f5c2a044557abded28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a21ff193a35df1cd72089f5c2a044557abded28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a21ff193a35df1cd72089f5c2a044557abded28/comments", "author": null, "committer": null, "parents": [{"sha": "5cdf54b7654d7245f3f683d352184e6bd353063a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cdf54b7654d7245f3f683d352184e6bd353063a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cdf54b7654d7245f3f683d352184e6bd353063a"}], "stats": {"total": 337, "additions": 236, "deletions": 101}, "files": [{"sha": "6ed8deacea28c2a6aa5303748a91d380021ff85c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a21ff193a35df1cd72089f5c2a044557abded28/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a21ff193a35df1cd72089f5c2a044557abded28/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a21ff193a35df1cd72089f5c2a044557abded28", "patch": "@@ -1,3 +1,8 @@\n+2015-08-24  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/nvptx/mkoffload.c (process): Replace\n+\tGOMP_offload_{,un}register with GOMP_offload_{,un}register_ver.\n+\n 2015-08-24  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/67329"}, {"sha": "ba0454e537a51eaa7a271c3a537ec1e70eb05658", "filename": "gcc/config/nvptx/mkoffload.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a21ff193a35df1cd72089f5c2a044557abded28/gcc%2Fconfig%2Fnvptx%2Fmkoffload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a21ff193a35df1cd72089f5c2a044557abded28/gcc%2Fconfig%2Fnvptx%2Fmkoffload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fmkoffload.c?ref=2a21ff193a35df1cd72089f5c2a044557abded28", "patch": "@@ -881,10 +881,10 @@ process (FILE *in, FILE *out)\n \t   \"extern \\\"C\\\" {\\n\"\n \t   \"#endif\\n\");\n \n-  fprintf (out, \"extern void GOMP_offload_register\"\n-\t   \" (const void *, int, const void *);\\n\");\n-  fprintf (out, \"extern void GOMP_offload_unregister\"\n-\t   \" (const void *, int, const void *);\\n\");\n+  fprintf (out, \"extern void GOMP_offload_register_ver\"\n+\t   \" (unsigned, const void *, int, const void *);\\n\");\n+  fprintf (out, \"extern void GOMP_offload_unregister_ver\"\n+\t   \" (unsigned, const void *, int, const void *);\\n\");\n \n   fprintf (out, \"#ifdef __cplusplus\\n\"\n \t   \"}\\n\"\n@@ -894,15 +894,19 @@ process (FILE *in, FILE *out)\n \n   fprintf (out, \"static __attribute__((constructor)) void init (void)\\n\"\n \t   \"{\\n\"\n-\t   \"  GOMP_offload_register (__OFFLOAD_TABLE__, %d/*NVIDIA_PTX*/,\\n\"\n-\t   \"                         &target_data);\\n\"\n-\t   \"};\\n\", GOMP_DEVICE_NVIDIA_PTX);\n+\t   \"  GOMP_offload_register_ver (%#x, __OFFLOAD_TABLE__,\"\n+\t   \"%d/*NVIDIA_PTX*/, &target_data);\\n\"\n+\t   \"};\\n\",\n+\t   GOMP_VERSION_PACK (GOMP_VERSION, GOMP_VERSION_NVIDIA_PTX),\n+\t   GOMP_DEVICE_NVIDIA_PTX);\n \n   fprintf (out, \"static __attribute__((destructor)) void fini (void)\\n\"\n \t   \"{\\n\"\n-\t   \"  GOMP_offload_unregister (__OFFLOAD_TABLE__, %d/*NVIDIA_PTX*/,\\n\"\n-\t   \"                           &target_data);\\n\"\n-\t   \"};\\n\", GOMP_DEVICE_NVIDIA_PTX);\n+\t   \"  GOMP_offload_unregister_ver (%#x, __OFFLOAD_TABLE__,\"\n+\t   \"%d/*NVIDIA_PTX*/, &target_data);\\n\"\n+\t   \"};\\n\",\n+\t   GOMP_VERSION_PACK (GOMP_VERSION, GOMP_VERSION_NVIDIA_PTX),\n+\t   GOMP_DEVICE_NVIDIA_PTX);\n }\n \n static void"}, {"sha": "c5dd5381a838442fc73176c11248cb28fb0deb45", "filename": "include/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a21ff193a35df1cd72089f5c2a044557abded28/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a21ff193a35df1cd72089f5c2a044557abded28/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=2a21ff193a35df1cd72089f5c2a044557abded28", "patch": "@@ -1,3 +1,9 @@\n+2015-08-24  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* gomp-constants.h (GOMP_VERSION, GOMP_VERSION_NVIDIA_PTX,\n+\tGOMP_VERSION_INTEL_MIC): New.\n+\t(GOMP_VERSION_PACK, GOMP_VERSION_LIB, GOMP_VERSION_DEV): New.\n+\n 2015-08-14  Pierre-Marie de Rodat  <derodat@adacore.com>\n \n \t* dwarf2.def (DW_AT_GNU_bias): New attribute."}, {"sha": "6e6a8b127a53b190e2fd7d9e2164f1851f619366", "filename": "include/gomp-constants.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a21ff193a35df1cd72089f5c2a044557abded28/include%2Fgomp-constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a21ff193a35df1cd72089f5c2a044557abded28/include%2Fgomp-constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgomp-constants.h?ref=2a21ff193a35df1cd72089f5c2a044557abded28", "patch": "@@ -113,4 +113,13 @@ enum gomp_map_kind\n #define GOMP_DEVICE_ICV\t\t\t-1\n #define GOMP_DEVICE_HOST_FALLBACK\t-2\n \n+/* Versions of libgomp and device-specific plugins.  */\n+#define GOMP_VERSION\t0\n+#define GOMP_VERSION_NVIDIA_PTX 0\n+#define GOMP_VERSION_INTEL_MIC 0\n+\n+#define GOMP_VERSION_PACK(LIB, DEV) (((LIB) << 16) | (DEV))\n+#define GOMP_VERSION_LIB(PACK) (((PACK) >> 16) & 0xffff)\n+#define GOMP_VERSION_DEV(PACK) ((PACK) & 0xffff)\n+\n #endif"}, {"sha": "39c67aff4238515a68e2b06710162ec73e9d7cf4", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a21ff193a35df1cd72089f5c2a044557abded28/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a21ff193a35df1cd72089f5c2a044557abded28/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=2a21ff193a35df1cd72089f5c2a044557abded28", "patch": "@@ -1,3 +1,35 @@\n+2015-08-24  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tlibgomp/\n+\t* libgomp.map: Add 4.0.2 version.\n+\t* target.c (offload_image_descr): Add version field.\n+\t(gomp_load_image_to_device): Add version argument.  Adjust plugin\n+\tcall.  Improve load mismatch diagnostic.\n+\t(gomp_unload_image_from_device): Add version argument.  Adjust plugin\n+\tcall.\n+\t(GOMP_offload_regster): Make stub function, move bulk to ...\n+\t(GOMP_offload_register_ver): ... here.  Process version argument.\n+\t(GOMP_offload_unregister): Make stub function, move bulk to ...\n+\t(GOMP_offload_unregister_ver): ... here.  Process version argument.\n+\t(gomp_init_device): Process version field.\n+\t(gomp_unload_device): Process version field.\n+\t(gomp_load_plugin_for_device): Reimplement DLSYM & DLSYM_OPT\n+\tmacros.  Check plugin version.\n+\t* libgomp.h (gomp_device_descr): Add version function field.  Adjust\n+\tloader and unloader types.\n+\t* oacc-host.c: Include gomp-constants.h.\n+\t(host_version): New.\n+\t(host_load_image, host_unload_image): Adjust.\n+\t(host_dispatch): Add host_version.\n+\t* plugin/plugin-nvptx.c: Include gomp-constants.h.\n+\t(GOMP_OFFLOAD_version): New.\n+\t(GOMP_OFFLOAD_load_image): Add version arg and check it.\n+\t(GOMP_OFFLOAD_unload_image): Likewise.\n+\t* plugin/plugin-host.c: Include gomp-constants.h.\n+\t(GOMP_OFFLOAD_version): New.\n+\t(GOMP_OFFLOAD_load_image): Add version arg.\n+\t(GOMP_OFFLOAD_unload_image): Likewise.\n+\n 2015-08-24  Tom de Vries  <tom@codesourcery.com>\n \n \tPR tree-optimization/65468"}, {"sha": "62454b8527af9fce45936e8d4fe106e6fae1f9fb", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a21ff193a35df1cd72089f5c2a044557abded28/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a21ff193a35df1cd72089f5c2a044557abded28/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=2a21ff193a35df1cd72089f5c2a044557abded28", "patch": "@@ -748,8 +748,9 @@ struct gomp_device_descr\n   int (*get_num_devices_func) (void);\n   void (*init_device_func) (int);\n   void (*fini_device_func) (int);\n-  int (*load_image_func) (int, const void *, struct addr_pair **);\n-  void (*unload_image_func) (int, const void *);\n+  unsigned (*version_func) (void);\n+  int (*load_image_func) (int, unsigned, const void *, struct addr_pair **);\n+  void (*unload_image_func) (int, unsigned, const void *);\n   void *(*alloc_func) (int, size_t);\n   void (*free_func) (int, void *);\n   void *(*dev2host_func) (int, void *, const void *, size_t);"}, {"sha": "ec3c3c1c63797dc8d2a830df0b87fe2bae974c89", "filename": "libgomp/libgomp.map", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a21ff193a35df1cd72089f5c2a044557abded28/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a21ff193a35df1cd72089f5c2a044557abded28/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=2a21ff193a35df1cd72089f5c2a044557abded28", "patch": "@@ -234,6 +234,12 @@ GOMP_4.0.1 {\n \tGOMP_offload_unregister;\n } GOMP_4.0;\n \n+GOMP_4.0.2 {\n+  global:\n+\tGOMP_offload_register_ver;\n+\tGOMP_offload_unregister_ver;\n+} GOMP_4.0.1;\n+\n OACC_2.0 {\n   global:\n \tacc_get_num_devices;"}, {"sha": "55bb16b278a5a53b2554f513216eaee39398144d", "filename": "libgomp/oacc-host.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a21ff193a35df1cd72089f5c2a044557abded28/libgomp%2Foacc-host.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a21ff193a35df1cd72089f5c2a044557abded28/libgomp%2Foacc-host.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-host.c?ref=2a21ff193a35df1cd72089f5c2a044557abded28", "patch": "@@ -28,6 +28,7 @@\n \n #include \"libgomp.h\"\n #include \"oacc-int.h\"\n+#include \"gomp-constants.h\"\n \n #include <stdbool.h>\n #include <stddef.h>\n@@ -69,8 +70,15 @@ host_fini_device (int n __attribute__ ((unused)))\n {\n }\n \n+static unsigned\n+host_version (void)\n+{\n+  return GOMP_VERSION;\n+}\n+\n static int\n host_load_image (int n __attribute__ ((unused)),\n+\t\t unsigned v __attribute__ ((unused)),\n \t\t const void *t __attribute__ ((unused)),\n \t\t struct addr_pair **r __attribute__ ((unused)))\n {\n@@ -79,6 +87,7 @@ host_load_image (int n __attribute__ ((unused)),\n \n static void\n host_unload_image (int n __attribute__ ((unused)),\n+\t\t   unsigned v __attribute__ ((unused)),\n \t\t   const void *t __attribute__ ((unused)))\n {\n }\n@@ -206,6 +215,7 @@ static struct gomp_device_descr host_dispatch =\n     .get_num_devices_func = host_get_num_devices,\n     .init_device_func = host_init_device,\n     .fini_device_func = host_fini_device,\n+    .version_func = host_version,\n     .load_image_func = host_load_image,\n     .unload_image_func = host_unload_image,\n     .alloc_func = host_alloc,"}, {"sha": "a2f950db580a2f5b454c3b603e3c4cc6d5ef4d68", "filename": "libgomp/plugin/plugin-nvptx.c", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a21ff193a35df1cd72089f5c2a044557abded28/libgomp%2Fplugin%2Fplugin-nvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a21ff193a35df1cd72089f5c2a044557abded28/libgomp%2Fplugin%2Fplugin-nvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-nvptx.c?ref=2a21ff193a35df1cd72089f5c2a044557abded28", "patch": "@@ -36,6 +36,7 @@\n #include \"libgomp-plugin.h\"\n #include \"oacc-ptx.h\"\n #include \"oacc-plugin.h\"\n+#include \"gomp-constants.h\"\n \n #include <pthread.h>\n #include <cuda.h>\n@@ -1570,11 +1571,20 @@ typedef struct nvptx_tdata\n   size_t fn_num;\n } nvptx_tdata_t;\n \n+/* Return the libgomp version number we're compatible with.  There is\n+   no requirement for cross-version compatibility.  */\n+\n+unsigned\n+GOMP_OFFLOAD_version (void)\n+{\n+  return GOMP_VERSION;\n+}\n+\n /* Load the (partial) program described by TARGET_DATA to device\n    number ORD.  Allocate and return TARGET_TABLE.  */\n \n int\n-GOMP_OFFLOAD_load_image (int ord, const void *target_data,\n+GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n \t\t\t struct addr_pair **target_table)\n {\n   CUmodule module;\n@@ -1587,6 +1597,11 @@ GOMP_OFFLOAD_load_image (int ord, const void *target_data,\n   struct ptx_image_data *new_image;\n   struct ptx_device *dev;\n \n+  if (GOMP_VERSION_DEV (version) > GOMP_VERSION_NVIDIA_PTX)\n+    GOMP_PLUGIN_fatal (\"Offload data incompatible with PTX plugin\"\n+\t\t       \" (expected %u, received %u)\",\n+\t\t       GOMP_VERSION_NVIDIA_PTX, GOMP_VERSION_DEV (version));\n+  \n   GOMP_OFFLOAD_init_device (ord);\n \n   dev = ptx_devices[ord];\n@@ -1656,11 +1671,14 @@ GOMP_OFFLOAD_load_image (int ord, const void *target_data,\n    function descriptors allocated by G_O_load_image.  */\n \n void\n-GOMP_OFFLOAD_unload_image (int ord, const void *target_data)\n+GOMP_OFFLOAD_unload_image (int ord, unsigned version, const void *target_data)\n {\n   struct ptx_image_data *image, **prev_p;\n   struct ptx_device *dev = ptx_devices[ord];\n \n+  if (GOMP_VERSION_DEV (version) > GOMP_VERSION_NVIDIA_PTX)\n+    return;\n+  \n   pthread_mutex_lock (&dev->image_lock);\n   for (prev_p = &dev->images; (image = *prev_p) != 0; prev_p = &image->next)\n     if (image->target_data == target_data)"}, {"sha": "758ece5d78c0e476a10cdd31cf65919899a621aa", "filename": "libgomp/target.c", "status": "modified", "additions": 104, "deletions": 84, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a21ff193a35df1cd72089f5c2a044557abded28/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a21ff193a35df1cd72089f5c2a044557abded28/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=2a21ff193a35df1cd72089f5c2a044557abded28", "patch": "@@ -56,6 +56,7 @@ static gomp_mutex_t register_lock;\n    It contains type of the target device, pointer to host table descriptor, and\n    pointer to target data.  */\n struct offload_image_descr {\n+  unsigned version;\n   enum offload_target_type type;\n   const void *host_table;\n   const void *target_data;\n@@ -642,7 +643,7 @@ gomp_update (struct gomp_device_descr *devicep, size_t mapnum, void **hostaddrs,\n    emitting variable and functions in the same order.  */\n \n static void\n-gomp_load_image_to_device (struct gomp_device_descr *devicep,\n+gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,\n \t\t\t   const void *host_table, const void *target_data,\n \t\t\t   bool is_register_lock)\n {\n@@ -658,16 +659,20 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep,\n \n   /* Load image to device and get target addresses for the image.  */\n   struct addr_pair *target_table = NULL;\n-  int i, num_target_entries\n-    = devicep->load_image_func (devicep->target_id, target_data,\n-\t\t\t\t&target_table);\n+  int i, num_target_entries;\n+\n+  num_target_entries\n+    = devicep->load_image_func (devicep->target_id, version,\n+\t\t\t\ttarget_data, &target_table);\n \n   if (num_target_entries != num_funcs + num_vars)\n     {\n       gomp_mutex_unlock (&devicep->lock);\n       if (is_register_lock)\n \tgomp_mutex_unlock (&register_lock);\n-      gomp_fatal (\"Can't map target functions or variables\");\n+      gomp_fatal (\"Cannot map target functions or variables\"\n+\t\t  \" (expected %u, have %u)\", num_funcs + num_vars,\n+\t\t  num_target_entries);\n     }\n \n   /* Insert host-target address mapping into splay tree.  */\n@@ -732,6 +737,7 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep,\n \n static void\n gomp_unload_image_from_device (struct gomp_device_descr *devicep,\n+\t\t\t       unsigned version,\n \t\t\t       const void *host_table, const void *target_data)\n {\n   void **host_func_table = ((void ***) host_table)[0];\n@@ -756,8 +762,8 @@ gomp_unload_image_from_device (struct gomp_device_descr *devicep,\n       k.host_end = k.host_start + 1;\n       node = splay_tree_lookup (&devicep->mem_map, &k);\n     }\n-  \n-  devicep->unload_image_func (devicep->target_id, target_data);\n+\n+  devicep->unload_image_func (devicep->target_id, version, target_data);\n \n   /* Remove mappings from splay tree.  */\n   for (j = 0; j < num_funcs; j++)\n@@ -786,10 +792,15 @@ gomp_unload_image_from_device (struct gomp_device_descr *devicep,\n    the target, and TARGET_DATA needed by target plugin.  */\n \n void\n-GOMP_offload_register (const void *host_table, int target_type,\n-\t\t       const void *target_data)\n+GOMP_offload_register_ver (unsigned version, const void *host_table,\n+\t\t\t   int target_type, const void *target_data)\n {\n   int i;\n+\n+  if (GOMP_VERSION_LIB (version) > GOMP_VERSION)\n+    gomp_fatal (\"Library too old for offload (version %u < %u)\",\n+\t\tGOMP_VERSION, GOMP_VERSION_LIB (version));\n+  \n   gomp_mutex_lock (&register_lock);\n \n   /* Load image to all initialized devices.  */\n@@ -798,7 +809,8 @@ GOMP_offload_register (const void *host_table, int target_type,\n       struct gomp_device_descr *devicep = &devices[i];\n       gomp_mutex_lock (&devicep->lock);\n       if (devicep->type == target_type && devicep->is_initialized)\n-\tgomp_load_image_to_device (devicep, host_table, target_data, true);\n+\tgomp_load_image_to_device (devicep, version,\n+\t\t\t\t   host_table, target_data, true);\n       gomp_mutex_unlock (&devicep->lock);\n     }\n \n@@ -807,6 +819,7 @@ GOMP_offload_register (const void *host_table, int target_type,\n     = gomp_realloc_unlock (offload_images,\n \t\t\t   (num_offload_images + 1)\n \t\t\t   * sizeof (struct offload_image_descr));\n+  offload_images[num_offload_images].version = version;\n   offload_images[num_offload_images].type = target_type;\n   offload_images[num_offload_images].host_table = host_table;\n   offload_images[num_offload_images].target_data = target_data;\n@@ -815,13 +828,20 @@ GOMP_offload_register (const void *host_table, int target_type,\n   gomp_mutex_unlock (&register_lock);\n }\n \n+void\n+GOMP_offload_register (const void *host_table, int target_type,\n+\t\t       const void *target_data)\n+{\n+  GOMP_offload_register_ver (0, host_table, target_type, target_data);\n+}\n+\n /* This function should be called from every offload image while unloading.\n    It gets the descriptor of the host func and var tables HOST_TABLE, TYPE of\n    the target, and TARGET_DATA needed by target plugin.  */\n \n void\n-GOMP_offload_unregister (const void *host_table, int target_type,\n-\t\t\t const void *target_data)\n+GOMP_offload_unregister_ver (unsigned version, const void *host_table,\n+\t\t\t     int target_type, const void *target_data)\n {\n   int i;\n \n@@ -833,7 +853,8 @@ GOMP_offload_unregister (const void *host_table, int target_type,\n       struct gomp_device_descr *devicep = &devices[i];\n       gomp_mutex_lock (&devicep->lock);\n       if (devicep->type == target_type && devicep->is_initialized)\n-\tgomp_unload_image_from_device (devicep, host_table, target_data);\n+\tgomp_unload_image_from_device (devicep, version,\n+\t\t\t\t       host_table, target_data);\n       gomp_mutex_unlock (&devicep->lock);\n     }\n \n@@ -848,6 +869,13 @@ GOMP_offload_unregister (const void *host_table, int target_type,\n   gomp_mutex_unlock (&register_lock);\n }\n \n+void\n+GOMP_offload_unregister (const void *host_table, int target_type,\n+\t\t\t const void *target_data)\n+{\n+  GOMP_offload_unregister_ver (0, host_table, target_type, target_data);\n+}\n+\n /* This function initializes the target device, specified by DEVICEP.  DEVICEP\n    must be locked on entry, and remains locked on return.  */\n \n@@ -862,8 +890,9 @@ gomp_init_device (struct gomp_device_descr *devicep)\n     {\n       struct offload_image_descr *image = &offload_images[i];\n       if (image->type == devicep->type)\n-\tgomp_load_image_to_device (devicep, image->host_table,\n-\t\t\t\t   image->target_data, false);\n+\tgomp_load_image_to_device (devicep, image->version,\n+\t\t\t\t   image->host_table, image->target_data,\n+\t\t\t\t   false);\n     }\n \n   devicep->is_initialized = true;\n@@ -881,7 +910,8 @@ gomp_unload_device (struct gomp_device_descr *devicep)\n \t{\n \t  struct offload_image_descr *image = &offload_images[i];\n \t  if (image->type == devicep->type)\n-\t    gomp_unload_image_from_device (devicep, image->host_table,\n+\t    gomp_unload_image_from_device (devicep, image->version,\n+\t\t\t\t\t   image->host_table,\n \t\t\t\t\t   image->target_data);\n \t}\n     }\n@@ -1085,43 +1115,29 @@ gomp_load_plugin_for_device (struct gomp_device_descr *device,\n \t\t\t     const char *plugin_name)\n {\n   const char *err = NULL, *last_missing = NULL;\n-  int optional_present, optional_total;\n-\n-  /* Clear any existing error.  */\n-  dlerror ();\n \n   void *plugin_handle = dlopen (plugin_name, RTLD_LAZY);\n   if (!plugin_handle)\n-    {\n-      err = dlerror ();\n-      goto out;\n-    }\n+    goto dl_fail;\n \n   /* Check if all required functions are available in the plugin and store\n-     their handlers.  */\n+     their handlers.  None of the symbols can legitimately be NULL,\n+     so we don't need to check dlerror all the time.  */\n #define DLSYM(f)\t\t\t\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      device->f##_func = dlsym (plugin_handle, \"GOMP_OFFLOAD_\" #f);\t\\\n-      err = dlerror ();\t\t\t\t\t\t\t\\\n-      if (err != NULL)\t\t\t\t\t\t\t\\\n-\tgoto out;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n-  /* Similar, but missing functions are not an error.  */\n-#define DLSYM_OPT(f, n)\t\t\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      const char *tmp_err;\t\t\t\t\t\t\t\\\n-      device->f##_func = dlsym (plugin_handle, \"GOMP_OFFLOAD_\" #n);\t\\\n-      tmp_err = dlerror ();\t\t\t\t\t\t\\\n-      if (tmp_err == NULL)\t\t\t\t\t\t\\\n-        optional_present++;\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-        last_missing = #n;\t\t\t\t\t\t\\\n-      optional_total++;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n+  if (!(device->f##_func = dlsym (plugin_handle, \"GOMP_OFFLOAD_\" #f)))\t\\\n+    goto dl_fail\n+  /* Similar, but missing functions are not an error.  Return false if\n+     failed, true otherwise.  */\n+#define DLSYM_OPT(f, n)\t\t\t\t\t\t\t\\\n+  ((device->f##_func = dlsym (plugin_handle, \"GOMP_OFFLOAD_\" #n))\t\\\n+   || (last_missing = #n, 0))\n+\n+  DLSYM (version);\n+  if (device->version_func () != GOMP_VERSION)\n+    {\n+      err = \"plugin version mismatch\";\n+      goto fail;\n+    }\n \n   DLSYM (get_name);\n   DLSYM (get_caps);\n@@ -1140,53 +1156,57 @@ gomp_load_plugin_for_device (struct gomp_device_descr *device,\n     DLSYM (run);\n   if (device->capabilities & GOMP_OFFLOAD_CAP_OPENACC_200)\n     {\n-      optional_present = optional_total = 0;\n-      DLSYM_OPT (openacc.exec, openacc_parallel);\n-      DLSYM_OPT (openacc.register_async_cleanup,\n-\t\t openacc_register_async_cleanup);\n-      DLSYM_OPT (openacc.async_test, openacc_async_test);\n-      DLSYM_OPT (openacc.async_test_all, openacc_async_test_all);\n-      DLSYM_OPT (openacc.async_wait, openacc_async_wait);\n-      DLSYM_OPT (openacc.async_wait_async, openacc_async_wait_async);\n-      DLSYM_OPT (openacc.async_wait_all, openacc_async_wait_all);\n-      DLSYM_OPT (openacc.async_wait_all_async, openacc_async_wait_all_async);\n-      DLSYM_OPT (openacc.async_set_async, openacc_async_set_async);\n-      DLSYM_OPT (openacc.create_thread_data, openacc_create_thread_data);\n-      DLSYM_OPT (openacc.destroy_thread_data, openacc_destroy_thread_data);\n-      /* Require all the OpenACC handlers if we have\n-\t GOMP_OFFLOAD_CAP_OPENACC_200.  */\n-      if (optional_present != optional_total)\n+      if (!DLSYM_OPT (openacc.exec, openacc_parallel)\n+\t  || !DLSYM_OPT (openacc.register_async_cleanup,\n+\t\t\t openacc_register_async_cleanup)\n+\t  || !DLSYM_OPT (openacc.async_test, openacc_async_test)\n+\t  || !DLSYM_OPT (openacc.async_test_all, openacc_async_test_all)\n+\t  || !DLSYM_OPT (openacc.async_wait, openacc_async_wait)\n+\t  || !DLSYM_OPT (openacc.async_wait_async, openacc_async_wait_async)\n+\t  || !DLSYM_OPT (openacc.async_wait_all, openacc_async_wait_all)\n+\t  || !DLSYM_OPT (openacc.async_wait_all_async,\n+\t\t\t openacc_async_wait_all_async)\n+\t  || !DLSYM_OPT (openacc.async_set_async, openacc_async_set_async)\n+\t  || !DLSYM_OPT (openacc.create_thread_data,\n+\t\t\t openacc_create_thread_data)\n+\t  || !DLSYM_OPT (openacc.destroy_thread_data,\n+\t\t\t openacc_destroy_thread_data))\n \t{\n+\t  /* Require all the OpenACC handlers if we have\n+\t     GOMP_OFFLOAD_CAP_OPENACC_200.  */\n \t  err = \"plugin missing OpenACC handler function\";\n-\t  goto out;\n+\t  goto fail;\n \t}\n-      optional_present = optional_total = 0;\n-      DLSYM_OPT (openacc.cuda.get_current_device,\n-\t\t openacc_get_current_cuda_device);\n-      DLSYM_OPT (openacc.cuda.get_current_context,\n-\t\t openacc_get_current_cuda_context);\n-      DLSYM_OPT (openacc.cuda.get_stream, openacc_get_cuda_stream);\n-      DLSYM_OPT (openacc.cuda.set_stream, openacc_set_cuda_stream);\n-      /* Make sure all the CUDA functions are there if any of them are.  */\n-      if (optional_present && optional_present != optional_total)\n+\n+      unsigned cuda = 0;\n+      cuda += DLSYM_OPT (openacc.cuda.get_current_device,\n+\t\t\t openacc_get_current_cuda_device);\n+      cuda += DLSYM_OPT (openacc.cuda.get_current_context,\n+\t\t\t openacc_get_current_cuda_context);\n+      cuda += DLSYM_OPT (openacc.cuda.get_stream, openacc_get_cuda_stream);\n+      cuda += DLSYM_OPT (openacc.cuda.set_stream, openacc_set_cuda_stream);\n+      if (cuda && cuda != 4)\n \t{\n+\t  /* Make sure all the CUDA functions are there if any of them are.  */\n \t  err = \"plugin missing OpenACC CUDA handler function\";\n-\t  goto out;\n+\t  goto fail;\n \t}\n     }\n #undef DLSYM\n #undef DLSYM_OPT\n \n- out:\n-  if (err != NULL)\n-    {\n-      gomp_error (\"while loading %s: %s\", plugin_name, err);\n-      if (last_missing)\n-        gomp_error (\"missing function was %s\", last_missing);\n-      if (plugin_handle)\n-\tdlclose (plugin_handle);\n-    }\n-  return err == NULL;\n+  return 1;\n+\n+ dl_fail:\n+  err = dlerror ();\n+ fail:\n+  gomp_error (\"while loading %s: %s\", plugin_name, err);\n+  if (last_missing)\n+    gomp_error (\"missing function was %s\", last_missing);\n+  if (plugin_handle)\n+    dlclose (plugin_handle);\n+\n+  return 0;\n }\n \n /* This function initializes the runtime needed for offloading."}, {"sha": "67a3f6aee5d27029a937600fc99262b50afe8ada", "filename": "liboffloadmic/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a21ff193a35df1cd72089f5c2a044557abded28/liboffloadmic%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a21ff193a35df1cd72089f5c2a044557abded28/liboffloadmic%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FChangeLog?ref=2a21ff193a35df1cd72089f5c2a044557abded28", "patch": "@@ -1,3 +1,9 @@\n+2015-08-24  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* plugin/libgomp-plugin-intelmic.cpp (GOMP_OFFLOAD_version): New.\n+\t(GOMP_OFFLOAD_load_image): Add version arg and check it.\n+\t(GOMP_OFFLOAD_unload_image): Likewise.\n+\n 2015-08-24  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* plugin/Makefile.am (include_src_dir): Set."}, {"sha": "fde7d9e382067dde7618ed3727115e6ef55620c7", "filename": "liboffloadmic/plugin/libgomp-plugin-intelmic.cpp", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a21ff193a35df1cd72089f5c2a044557abded28/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a21ff193a35df1cd72089f5c2a044557abded28/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp?ref=2a21ff193a35df1cd72089f5c2a044557abded28", "patch": "@@ -328,12 +328,26 @@ offload_image (const void *target_image)\n   free (image);\n }\n \n+/* Return the libgomp version number we're compatible with.  There is\n+   no requirement for cross-version compatibility.  */\n+\n+extern \"C\" unsigned\n+GOMP_OFFLOAD_version (void)\n+{\n+  return GOMP_VERSION;\n+}\n+\n extern \"C\" int\n-GOMP_OFFLOAD_load_image (int device, const void *target_image,\n-\t\t\t addr_pair **result)\n+GOMP_OFFLOAD_load_image (int device, const unsigned version,\n+\t\t\t void *target_image, addr_pair **result)\n {\n   TRACE (\"(device = %d, target_image = %p)\", device, target_image);\n \n+  if (GOMP_VERSION_DEV (version) > GOMP_VERSION_INTEL_MIC)\n+    GOMP_PLUGIN_fatal (\"Offload data incompatible with intelmic plugin\"\n+\t\t       \" (expected %u, received %u)\",\n+\t\t       GOMP_VERSION_INTEL_MIC, GOMP_VERSION_DEV (version));\n+\n   /* If target_image is already present in address_table, then there is no need\n      to offload it.  */\n   if (address_table->count (target_image) == 0)\n@@ -354,8 +368,12 @@ GOMP_OFFLOAD_load_image (int device, const void *target_image,\n }\n \n extern \"C\" void\n-GOMP_OFFLOAD_unload_image (int device, const void *target_image)\n+GOMP_OFFLOAD_unload_image (int device, unsigned version,\n+\t\t\t   const void *target_image)\n {\n+  if (GOMP_VERSION_DEV (version) > GOMP_VERSION_INTEL_MIC)\n+    return;\n+\n   TRACE (\"(device = %d, target_image = %p)\", device, target_image);\n \n   /* TODO: Currently liboffloadmic doesn't support __offload_unregister_image"}]}