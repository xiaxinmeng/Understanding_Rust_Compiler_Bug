{"sha": "ca3df643698b0f67b6376a88aa9b4f586d4b9a00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2EzZGY2NDM2OThiMGY2N2I2Mzc2YTg4YWE5YjRmNTg2ZDRiOWEwMA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2004-05-02T02:53:05Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2004-05-02T02:53:05Z"}, "message": "builtins.c (fold_fixed_mathfn): New function.\n\n\t* builtins.c (fold_fixed_mathfn): New function.\n\t(fold_builtin_lround, fold_builtin): Use it.\n\ntestsuite:\n\t* gcc.dg/torture/builtin-integral-1.c: Reorg and add more cases.\n\t* gcc.dg/torture/builtin-convert-3.c: New test.\n\nFrom-SVN: r81403", "tree": {"sha": "a34c7202f1576f9f79461bbdb36fc625107a225c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a34c7202f1576f9f79461bbdb36fc625107a225c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca3df643698b0f67b6376a88aa9b4f586d4b9a00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca3df643698b0f67b6376a88aa9b4f586d4b9a00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca3df643698b0f67b6376a88aa9b4f586d4b9a00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca3df643698b0f67b6376a88aa9b4f586d4b9a00/comments", "author": null, "committer": null, "parents": [{"sha": "3c2d6797727df4540c7b5b3f5ca826d14370b17c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c2d6797727df4540c7b5b3f5ca826d14370b17c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c2d6797727df4540c7b5b3f5ca826d14370b17c"}], "stats": {"total": 168, "additions": 153, "deletions": 15}, "files": [{"sha": "9fa56520148d2f7277fccf71a6975e9385ca6bad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3df643698b0f67b6376a88aa9b4f586d4b9a00/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3df643698b0f67b6376a88aa9b4f586d4b9a00/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca3df643698b0f67b6376a88aa9b4f586d4b9a00", "patch": "@@ -1,3 +1,8 @@\n+2004-05-01  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* builtins.c (fold_fixed_mathfn): New function.\n+\t(fold_builtin_lround, fold_builtin): Use it.\n+\n 2004-05-01  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/sparc/linux64.h (TARGET_DEFAULT): Make 64-bit by default"}, {"sha": "96d365ababb305cff1783837da9d182fce798a2d", "filename": "gcc/builtins.c", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3df643698b0f67b6376a88aa9b4f586d4b9a00/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3df643698b0f67b6376a88aa9b4f586d4b9a00/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ca3df643698b0f67b6376a88aa9b4f586d4b9a00", "patch": "@@ -6075,6 +6075,45 @@ fold_trunc_transparent_mathfn (tree exp)\n   return 0;\n }\n \n+/* EXP is assumed to be builtin call which can narrow the FP type of\n+   the argument, for instance lround((double)f) -> lroundf (f).  */\n+\n+static tree\n+fold_fixed_mathfn (tree exp)\n+{\n+  tree fndecl = get_callee_fndecl (exp);\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n+  tree arg;\n+\n+  if (! validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  arg = TREE_VALUE (arglist);\n+\n+  /* If argument is already integer valued, and we don't need to worry\n+     about setting errno, there's no need to perform rounding.  */\n+  if (! flag_errno_math && integer_valued_real_p (arg))\n+    return fold (build1 (FIX_TRUNC_EXPR, TREE_TYPE (exp), arg));\n+\n+  if (optimize)\n+    {\n+      tree ftype = TREE_TYPE (arg);\n+      tree arg0 = strip_float_extensions (arg);\n+      tree newtype = TREE_TYPE (arg0);\n+      tree decl;\n+\n+      if (TYPE_PRECISION (newtype) < TYPE_PRECISION (ftype)\n+\t  && (decl = mathfn_built_in (newtype, fcode)))\n+\t{\n+\t  arglist =\n+\t    build_tree_list (NULL_TREE, fold_convert (newtype, arg0));\n+\t  return build_function_call_expr (decl, arglist);\n+\t}\n+    }\n+  return 0;\n+}\n+\n /* Fold function call to builtin cabs, cabsf or cabsl.  ARGLIST\n    is the argument list and TYPE is the return type.  Return\n    NULL_TREE if no if no simplification can be made.  */\n@@ -6307,7 +6346,7 @@ fold_builtin_lround (tree exp)\n \t}\n     }\n \n-  return 0;\n+  return fold_fixed_mathfn (exp);\n }\n \n /* Fold function call to builtin ffs, clz, ctz, popcount and parity\n@@ -7420,6 +7459,14 @@ fold_builtin (tree exp)\n     case BUILT_IN_LLROUNDL:\n       return fold_builtin_lround (exp);\n \n+    case BUILT_IN_LRINT:\n+    case BUILT_IN_LRINTF:\n+    case BUILT_IN_LRINTL:\n+    case BUILT_IN_LLRINT:\n+    case BUILT_IN_LLRINTF:\n+    case BUILT_IN_LLRINTL:\n+      return fold_fixed_mathfn (exp);\n+\n     case BUILT_IN_FFS:\n     case BUILT_IN_FFSL:\n     case BUILT_IN_FFSLL:"}, {"sha": "822cb30f7c0ed4d1d34bd7b8a31886c16eb7a643", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3df643698b0f67b6376a88aa9b4f586d4b9a00/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3df643698b0f67b6376a88aa9b4f586d4b9a00/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ca3df643698b0f67b6376a88aa9b4f586d4b9a00", "patch": "@@ -1,3 +1,8 @@\n+2004-05-01  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gcc.dg/torture/builtin-integral-1.c: Reorg and add more cases.\n+\t* gcc.dg/torture/builtin-convert-3.c: New test.\n+\n 2004-05-01  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \tPR middle-end/15054"}, {"sha": "9901ceccf819eebb8723a456371ee1b910a7bebb", "filename": "gcc/testsuite/gcc.dg/torture/builtin-convert-3.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3df643698b0f67b6376a88aa9b4f586d4b9a00/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-convert-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3df643698b0f67b6376a88aa9b4f586d4b9a00/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-convert-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-convert-3.c?ref=ca3df643698b0f67b6376a88aa9b4f586d4b9a00", "patch": "@@ -0,0 +1,56 @@\n+/* Copyright (C) 2004  Free Software Foundation.\n+\n+   Verify that builtin math functions (with fixed point return types)\n+   are converted to smaller FP types correctly by the compiler.\n+\n+   Written by Kaveh Ghazi, 2004-05-01.  */\n+\n+/* { dg-do link } */\n+/* { dg-options \"-ffast-math\" } */\n+\n+#include \"../builtins-config.h\"\n+\n+#define PROTOTYPE1_RET(FN, RET) \\\n+  extern RET FN(double); \\\n+  extern RET FN##f(float); \\\n+  extern RET FN##l(long double);\n+\n+/* Test converting math builtins to narrower FP types based on if the\n+   argument is a narrower type (perhaps implicitly) cast to a wider\n+   one.  */\n+#define INNER_CAST1(MATHFN, RET) \\\n+ PROTOTYPE1_RET (MATHFN, RET); \\\n+ extern void link_failure_inner_##MATHFN##l_##MATHFN(void); \\\n+ extern void link_failure_inner_##MATHFN##l_##MATHFN##f(void); \\\n+ extern void link_failure_inner_##MATHFN##_##MATHFN##f(void); \\\n+ if (sizeof (long double) > sizeof (double) \\\n+     && MATHFN##l(d1) != MATHFN(d1)) \\\n+    link_failure_inner_##MATHFN##l_##MATHFN(); \\\n+ if (sizeof (long double) > sizeof (float) \\\n+     && MATHFN##l(f1) != MATHFN##f(f1)) \\\n+    link_failure_inner_##MATHFN##l_##MATHFN##f(); \\\n+ if (sizeof (long double) > sizeof (float) \\\n+     && MATHFN##l((double)f1) != MATHFN##f(f1)) \\\n+    link_failure_inner_##MATHFN##l_##MATHFN##f(); \\\n+ if (sizeof (double) > sizeof (float) \\\n+     && MATHFN(f1) != MATHFN##f(f1)) \\\n+    link_failure_inner_##MATHFN##_##MATHFN##f()\n+\n+void __attribute__ ((__noinline__)) test (double d1, float f1)\n+{\n+#ifdef __OPTIMIZE__\n+#ifdef HAVE_C99_RUNTIME\n+  /* We're converting to implicitly generated C99 functions.  */\n+  INNER_CAST1 (lround, long);\n+  INNER_CAST1 (llround, long long);\n+  INNER_CAST1 (lrint, long);\n+  INNER_CAST1 (llrint, long long);\n+#endif /* HAVE_C99_RUNTIME */\n+#endif /* __OPTIMIZE__ */\n+}\n+\n+int main (void)\n+{\n+  test (1, 2);\n+  return 0;\n+}"}, {"sha": "0aeb7ff7bdb4b007a7ea21577de7f0548bfbffa6", "filename": "gcc/testsuite/gcc.dg/torture/builtin-integral-1.c", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3df643698b0f67b6376a88aa9b4f586d4b9a00/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-integral-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3df643698b0f67b6376a88aa9b4f586d4b9a00/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-integral-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-integral-1.c?ref=ca3df643698b0f67b6376a88aa9b4f586d4b9a00", "patch": "@@ -9,33 +9,57 @@\n \n #define PROTOTYPE1(FN) extern double FN(double); extern float FN##f(float); \\\n   extern long double FN##l(long double);\n+#define PROTOTYPE1_RET(FN, RET) extern RET FN(double); extern RET FN##f(float); \\\n+  extern RET FN##l(long double);\n+#define PROTOTYPE_LINK_FAILURE(FN) extern void link_failure_##FN(void); \\\n+ extern void link_failure_##FN##f(void); \\\n+ extern void link_failure_##FN##l(void); \\\n \n PROTOTYPE1(fabs)\n+PROTOTYPE1(ceil)\n+PROTOTYPE1(floor)\n+PROTOTYPE1(nearbyint)\n+PROTOTYPE1(rint)\n+PROTOTYPE1(round)\n+PROTOTYPE1(trunc)\n+PROTOTYPE1_RET(lround, long)\n+PROTOTYPE1_RET(llround, long long)\n+PROTOTYPE1_RET(lrint, long)\n+PROTOTYPE1_RET(llrint, long long)\n \n-void test(int i1, int i2)\n-{\n-  /* Test that the various FP truncation builtins detect integral\n-     arguments.  */\n+/* Test that the various FP truncation builtins detect integral\n+   arguments.  */\n #define CHECK_FN(MATHFN) \\\n- PROTOTYPE1 (MATHFN) \\\n- extern void link_failure_##MATHFN(void); \\\n- extern void link_failure_##MATHFN##f(void); \\\n- extern void link_failure_##MATHFN##l(void); \\\n+ PROTOTYPE_LINK_FAILURE(MATHFN); \\\n  if (MATHFN(i1) != i1) link_failure_##MATHFN(); \\\n  if (MATHFN##f(i1) != i1) link_failure_##MATHFN##f(); \\\n- if (MATHFN##l(i1) != i1) link_failure_##MATHFN##l(); \\\n+ if (MATHFN##l(i1) != i1) link_failure_##MATHFN##l();\n+\n+#define CHECK_FN_RET(MATHFN, RET) \\\n+ PROTOTYPE_LINK_FAILURE(MATHFN); \\\n+ if (MATHFN(i1) != (RET)(double)i1) link_failure_##MATHFN(); \\\n+ if (MATHFN##f(i1) != (RET)(float)i1) link_failure_##MATHFN##f(); \\\n+ if (MATHFN##l(i1) != (RET)(long double)i1) link_failure_##MATHFN##l();\n+\n+  /* Check that various other integral expressions are detected.  */\n+#define CHECK_EXPR(EXPR,NAME) \\\n+ extern void link_failure_FP_##NAME(void); \\\n+ extern void link_failure_fixed_##NAME(void); \\\n+ if (ceill(EXPR) != (EXPR)) link_failure_FP_##NAME(); \\\n+ if (lroundl(EXPR) != (long)(long double)(EXPR)) link_failure_fixed_##NAME();\n \n+void __attribute__ ((__noinline__)) test (int i1, int i2)\n+{\n   CHECK_FN(ceil);\n   CHECK_FN(floor);\n   CHECK_FN(nearbyint);\n   CHECK_FN(rint);\n   CHECK_FN(round);\n   CHECK_FN(trunc);\n-\n-  /* Check that various other integral expressions are detected.  */\n-#define CHECK_EXPR(EXPR,NAME) \\\n- extern void link_failure_##NAME(void); \\\n- if (ceill(EXPR) != (EXPR)) link_failure_##NAME(); \\\n+  CHECK_FN_RET(lround, long);\n+  CHECK_FN_RET(llround, long long);\n+  CHECK_FN_RET(lrint, long);\n+  CHECK_FN_RET(llrint, long long);\n \n   CHECK_EXPR (5.0, REAL_CST);\n   CHECK_EXPR (5.0F, REAL_CSTf);\n@@ -54,5 +78,6 @@ void test(int i1, int i2)\n \n int main (void)\n {\n+  test (1, 2);\n   return 0;\n }"}]}