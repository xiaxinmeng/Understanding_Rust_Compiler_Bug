{"sha": "79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a", "node_id": "C_kwDOANBUbNoAKDc5YWFiYTBhNzFmMzRhYzFhYzJjNGNlYzkwN2ZmNzQ3NDBhNmNmMWE", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-03-15T22:16:17Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-03-15T22:16:17Z"}, "message": "diagnostics: attempt to capture crash info in SARIF output [PR109097]\n\nAs noted in PR analyzer/109097, if an internal compiler error occurs\nwhen -fdiagnostics-format=sarif-file is specified, we currently fail\nto write out a .sarif file, and the output to stderr doesn't contain\n\"internal compiler error\" or \"Internal compiler error\"; just the\nbacktrace if we're lucky, and the \"Please submit a full bug report\"\nmessages.\n\nThis is a nuisance e.g. for my integration testing of -fanalyzer, where\nI'm gathering the results of builds via the .sarif output: if it crashes\non a particular source file, then no output is generated, and it's\neffectively silent about the crash.\n\nThis patch fixes things by adding a callback to diagnostic_context so\nthat the SARIF output code can make one final attempt to write its\noutput if an ICE occurs.  It also special-cases the output, so that an\nICE is treated as an \"error\"-level \"notification\" relating to the\noperation of the tool (SARIF v2.1.0 section 3.58), rather than a\n\"result\" about the code being analyzed by the tool.\n\nThe patch adds test coverage for this via a plugin that can inject:\n* calls to internal_compiler_error, and\n* writes through a NULL pointer\nand verifying that a  .sarif file is written out capturing the crash\n(and also that an ICE occurs via dg-ice, which seems to treat the ICE as\nan XFAIL, which is reasonable).\n\nI've added support for this to my integration-testing scripts: testing\nshows that with this patch we capture analyzer crashes in .sarif files\n(specifically, the analyzer crash on qemu: PR analyzer/109094), and I've\nupdated my scripts to work with and report such output.\n\nI manually verified that the resulting .sarif files validate against the\nschema.\n\ngcc/ChangeLog:\n\tPR analyzer/109097\n\t* diagnostic-format-sarif.cc (class sarif_invocation): New.\n\t(class sarif_ice_notification): New.\n\t(sarif_builder::m_invocation_obj): New field.\n\t(sarif_invocation::add_notification_for_ice): New.\n\t(sarif_invocation::prepare_to_flush): New.\n\t(sarif_ice_notification::sarif_ice_notification): New.\n\t(sarif_builder::sarif_builder): Add m_invocation_obj.\n\t(sarif_builder::end_diagnostic): Special-case DK_ICE and\n\tDK_ICE_NOBT.\n\t(sarif_builder::flush_to_file): Call prepare_to_flush on\n\tm_invocation_obj.  Pass the latter to make_top_level_object.\n\t(sarif_builder::make_result_object): Move creation of \"locations\"\n\tarray to...\n\t(sarif_builder::make_locations_arr): ...this new function.\n\t(sarif_builder::make_top_level_object): Add \"invocation_obj\" param\n\tand pass it to make_run_object.\n\t(sarif_builder::make_run_object): Add \"invocation_obj\" param and\n\tuse it.\n\t(sarif_ice_handler): New callback.\n\t(diagnostic_output_format_init_sarif): Wire up sarif_ice_handler.\n\t* diagnostic.cc (diagnostic_initialize): Initialize new field\n\t\"ice_handler_cb\".\n\t(diagnostic_action_after_output): If it is set, make one attempt\n\tto call ice_handler_cb.\n\t* diagnostic.h (diagnostic_context::ice_handler_cb): New field.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/109097\n\t* c-c++-common/diagnostic-format-sarif-file-1.c: Verify that we\n\thave an invocation object marked as succeeding, with no\n\tnotifications.\n\t* gcc.dg/plugin/crash-test-ice-sarif.c: New test.\n\t* gcc.dg/plugin/crash-test-ice-stderr.c: New test.\n\t* gcc.dg/plugin/crash-test-write-though-null-sarif.c: New test.\n\t* gcc.dg/plugin/crash-test-write-though-null-stderr.c: New test.\n\t* gcc.dg/plugin/crash_test_plugin.c: New plugin.\n\t* gcc.dg/plugin/plugin.exp (plugin_test_list): Add the new plugin\n\tand test cases.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "ad711922dc84fab4a2730846463d8eb2cf6521d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad711922dc84fab4a2730846463d8eb2cf6521d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f1711ef3486b0727ccf6b5aabddda5c7d986457", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f1711ef3486b0727ccf6b5aabddda5c7d986457", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f1711ef3486b0727ccf6b5aabddda5c7d986457"}], "stats": {"total": 476, "additions": 458, "deletions": 18}, "files": [{"sha": "2c48cbd46e23d62c8e688ec533308232026500a6", "filename": "gcc/diagnostic-format-sarif.cc", "status": "modified", "additions": 155, "deletions": 18, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a/gcc%2Fdiagnostic-format-sarif.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a/gcc%2Fdiagnostic-format-sarif.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-format-sarif.cc?ref=79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a", "patch": "@@ -32,8 +32,29 @@ along with GCC; see the file COPYING3.  If not see\n \n class sarif_builder;\n \n+/* Subclass of json::object for SARIF invocation objects\n+   (SARIF v2.1.0 section 3.20).  */\n+\n+class sarif_invocation : public json::object\n+{\n+public:\n+  sarif_invocation ()\n+  : m_notifications_arr (new json::array ()),\n+    m_success (true)\n+  {}\n+\n+  void add_notification_for_ice (diagnostic_context *context,\n+\t\t\t\t diagnostic_info *diagnostic,\n+\t\t\t\t sarif_builder *builder);\n+  void prepare_to_flush ();\n+\n+private:\n+  json::array *m_notifications_arr;\n+  bool m_success;\n+};\n+\n /* Subclass of json::object for SARIF result objects\n-   (SARIF v2.1.0 section 3.27.  */\n+   (SARIF v2.1.0 section 3.27).  */\n \n class sarif_result : public json::object\n {\n@@ -50,6 +71,20 @@ class sarif_result : public json::object\n   json::array *m_related_locations_arr;\n };\n \n+/* Subclass of json::object for SARIF notification objects\n+   (SARIF v2.1.0 section 3.58).\n+\n+   This subclass is specifically for notifying when an\n+   internal compiler error occurs.  */\n+\n+class sarif_ice_notification : public json::object\n+{\n+public:\n+  sarif_ice_notification (diagnostic_context *context,\n+\t\t\t  diagnostic_info *diagnostic,\n+\t\t\t  sarif_builder *builder);\n+};\n+\n /* A class for managing SARIF output (for -fdiagnostics-format=sarif-stderr\n    and -fdiagnostics-format=sarif-file).\n \n@@ -105,6 +140,7 @@ class sarif_builder\n \n   void flush_to_file (FILE *outf);\n \n+  json::array *make_locations_arr (diagnostic_info *diagnostic);\n   json::object *make_location_object (const rich_location &rich_loc,\n \t\t\t\t      const logical_location *logical_loc);\n   json::object *make_message_object (const char *msg) const;\n@@ -131,8 +167,10 @@ class sarif_builder\n   json::object *maybe_make_region_object_for_context (location_t loc) const;\n   json::object *make_region_object_for_hint (const fixit_hint &hint) const;\n   json::object *make_multiformat_message_string (const char *msg) const;\n-  json::object *make_top_level_object (json::array *results);\n-  json::object *make_run_object (json::array *results);\n+  json::object *make_top_level_object (sarif_invocation *invocation_obj,\n+\t\t\t\t       json::array *results);\n+  json::object *make_run_object (sarif_invocation *invocation_obj,\n+\t\t\t\t json::array *results);\n   json::object *make_tool_object () const;\n   json::object *make_driver_tool_component_object () const;\n   json::array *maybe_make_taxonomies_array () const;\n@@ -159,6 +197,9 @@ class sarif_builder\n \n   diagnostic_context *m_context;\n \n+  /* The JSON object for the invocation object.  */\n+  sarif_invocation *m_invocation_obj;\n+\n   /* The JSON array of pending diagnostics.  */\n   json::array *m_results_array;\n \n@@ -179,6 +220,33 @@ class sarif_builder\n \n static sarif_builder *the_builder;\n \n+/* class sarif_invocation : public json::object.  */\n+\n+/* Handle an internal compiler error DIAGNOSTIC occurring on CONTEXT.\n+   Add an object representing the ICE to the notifications array.  */\n+\n+void\n+sarif_invocation::add_notification_for_ice (diagnostic_context *context,\n+\t\t\t\t\t    diagnostic_info *diagnostic,\n+\t\t\t\t\t    sarif_builder *builder)\n+{\n+  m_success = false;\n+\n+  sarif_ice_notification *notification_obj\n+    = new sarif_ice_notification (context, diagnostic, builder);\n+  m_notifications_arr->append (notification_obj);\n+}\n+\n+void\n+sarif_invocation::prepare_to_flush ()\n+{\n+  /* \"executionSuccessful\" property (SARIF v2.1.0 section 3.20.14).  */\n+  set (\"executionSuccessful\", new json::literal (m_success));\n+\n+  /* \"toolExecutionNotifications\" property (SARIF v2.1.0 section 3.20.21).  */\n+  set (\"toolExecutionNotifications\", m_notifications_arr);\n+}\n+\n /* class sarif_result : public json::object.  */\n \n /* Handle secondary diagnostics that occur within a diagnostic group.\n@@ -212,12 +280,36 @@ sarif_result::on_nested_diagnostic (diagnostic_context *context,\n   m_related_locations_arr->append (location_obj);\n }\n \n+/* class sarif_ice_notification : public json::object.  */\n+\n+/* sarif_ice_notification's ctor.\n+   DIAGNOSTIC is an internal compiler error.  */\n+\n+sarif_ice_notification::sarif_ice_notification (diagnostic_context *context,\n+\t\t\t\t\t\tdiagnostic_info *diagnostic,\n+\t\t\t\t\t\tsarif_builder *builder)\n+{\n+  /* \"locations\" property (SARIF v2.1.0 section 3.58.4).  */\n+  json::array *locations_arr = builder->make_locations_arr (diagnostic);\n+  set (\"locations\", locations_arr);\n+\n+  /* \"message\" property (SARIF v2.1.0 section 3.85.5).  */\n+  json::object *message_obj\n+    = builder->make_message_object (pp_formatted_text (context->printer));\n+  pp_clear_output_area (context->printer);\n+  set (\"message\", message_obj);\n+\n+  /* \"level\" property (SARIF v2.1.0 section 3.58.6).  */\n+  set (\"level\", new json::string (\"error\"));\n+}\n+\n /* class sarif_builder.  */\n \n /* sarif_builder's ctor.  */\n \n sarif_builder::sarif_builder (diagnostic_context *context)\n : m_context (context),\n+  m_invocation_obj (new sarif_invocation ()),\n   m_results_array (new json::array ()),\n   m_cur_group_result (NULL),\n   m_seen_any_relative_paths (false),\n@@ -234,6 +326,11 @@ sarif_builder::end_diagnostic (diagnostic_context *context,\n \t\t\t       diagnostic_info *diagnostic,\n \t\t\t       diagnostic_t orig_diag_kind)\n {\n+  if (diagnostic->kind == DK_ICE || diagnostic->kind == DK_ICE_NOBT)\n+    {\n+      m_invocation_obj->add_notification_for_ice (context, diagnostic, this);\n+      return;\n+    }\n \n   if (m_cur_group_result)\n     /* Nested diagnostic.  */\n@@ -267,8 +364,10 @@ sarif_builder::end_group ()\n void\n sarif_builder::flush_to_file (FILE *outf)\n {\n-  json::object *top = make_top_level_object (m_results_array);\n+  m_invocation_obj->prepare_to_flush ();\n+  json::object *top = make_top_level_object (m_invocation_obj, m_results_array);\n   top->dump (outf);\n+  m_invocation_obj = NULL;\n   m_results_array = NULL;\n   fprintf (outf, \"\\n\");\n   delete top;\n@@ -387,15 +486,7 @@ sarif_builder::make_result_object (diagnostic_context *context,\n   result_obj->set (\"message\", message_obj);\n \n   /* \"locations\" property (SARIF v2.1.0 section 3.27.12).  */\n-  json::array *locations_arr = new json::array ();\n-  const logical_location *logical_loc = NULL;\n-  if (m_context->m_client_data_hooks)\n-    logical_loc\n-      = m_context->m_client_data_hooks->get_current_logical_location ();\n-\n-  json::object *location_obj\n-    = make_location_object (*diagnostic->richloc, logical_loc);\n-  locations_arr->append (location_obj);\n+  json::array *locations_arr = make_locations_arr (diagnostic);\n   result_obj->set (\"locations\", locations_arr);\n \n   /* \"codeFlows\" property (SARIF v2.1.0 section 3.27.18).  */\n@@ -525,6 +616,25 @@ make_tool_component_reference_object_for_cwe () const\n   return comp_ref_obj;\n }\n \n+/* Make an array suitable for use as the \"locations\" property of:\n+   - a \"result\" object (SARIF v2.1.0 section 3.27.12), or\n+   - a \"notification\" object (SARIF v2.1.0 section 3.58.4).  */\n+\n+json::array *\n+sarif_builder::make_locations_arr (diagnostic_info *diagnostic)\n+{\n+  json::array *locations_arr = new json::array ();\n+  const logical_location *logical_loc = NULL;\n+  if (m_context->m_client_data_hooks)\n+    logical_loc\n+      = m_context->m_client_data_hooks->get_current_logical_location ();\n+\n+  json::object *location_obj\n+    = make_location_object (*diagnostic->richloc, logical_loc);\n+  locations_arr->append (location_obj);\n+  return locations_arr;\n+}\n+\n /* If LOGICAL_LOC is non-NULL, use it to create a \"logicalLocations\" property\n    within LOCATION_OBJ (SARIF v2.1.0 section 3.28.4).  */\n \n@@ -1023,10 +1133,11 @@ sarif_builder::make_multiformat_message_string (const char *msg) const\n #define SARIF_VERSION \"2.1.0\"\n \n /* Make a top-level sarifLog object (SARIF v2.1.0 section 3.13).\n-   Take ownership of RESULTS.  */\n+   Take ownership of INVOCATION_OBJ and RESULTS.  */\n \n json::object *\n-sarif_builder::make_top_level_object (json::array *results)\n+sarif_builder::make_top_level_object (sarif_invocation *invocation_obj,\n+\t\t\t\t      json::array *results)\n {\n   json::object *log_obj = new json::object ();\n \n@@ -1038,18 +1149,19 @@ sarif_builder::make_top_level_object (json::array *results)\n \n   /* \"runs\" property (SARIF v2.1.0 section 3.13.4).  */\n   json::array *run_arr = new json::array ();\n-  json::object *run_obj = make_run_object (results);\n+  json::object *run_obj = make_run_object (invocation_obj, results);\n   run_arr->append (run_obj);\n   log_obj->set (\"runs\", run_arr);\n \n   return log_obj;\n }\n \n /* Make a run object (SARIF v2.1.0 section 3.14).\n-   Take ownership of RESULTS.  */\n+   Take ownership of INVOCATION_OBJ and RESULTS.  */\n \n json::object *\n-sarif_builder::make_run_object (json::array *results)\n+sarif_builder::make_run_object (sarif_invocation *invocation_obj,\n+\t\t\t\tjson::array *results)\n {\n   json::object *run_obj = new json::object ();\n \n@@ -1061,6 +1173,13 @@ sarif_builder::make_run_object (json::array *results)\n   if (json::array *taxonomies_arr = maybe_make_taxonomies_array ())\n     run_obj->set (\"taxonomies\", taxonomies_arr);\n \n+  /* \"invocations\" property (SARIF v2.1.0 section 3.14.11).  */\n+  {\n+    json::array *invocations_arr = new json::array ();\n+    invocations_arr->append (invocation_obj);\n+    run_obj->set (\"invocations\", invocations_arr);\n+  }\n+\n   /* \"originalUriBaseIds (SARIF v2.1.0 section 3.14.14).  */\n   if (m_seen_any_relative_paths)\n     {\n@@ -1538,6 +1657,23 @@ sarif_file_final_cb (diagnostic_context *)\n   free (filename);\n }\n \n+/* Callback for diagnostic_context::ice_handler_cb for when an ICE\n+   occurs.  */\n+\n+static void\n+sarif_ice_handler (diagnostic_context *context)\n+{\n+  /* Attempt to ensure that a .sarif file is written out.  */\n+  diagnostic_finish (context);\n+\n+  /* Print a header for the remaining output to stderr, and\n+     return, attempting to print the usual ICE messages to\n+     stderr.  Hopefully this will be helpful to the user in\n+     indicating what's gone wrong (also for DejaGnu, for pruning\n+     those messages).   */\n+  fnotice (stderr, \"Internal compiler error:\\n\");\n+}\n+\n /* Populate CONTEXT in preparation for SARIF output (either to stderr, or\n    to a file).  */\n \n@@ -1552,6 +1688,7 @@ diagnostic_output_format_init_sarif (diagnostic_context *context)\n   context->begin_group_cb = sarif_begin_group;\n   context->end_group_cb =  sarif_end_group;\n   context->print_path = NULL; /* handled in sarif_end_diagnostic.  */\n+  context->ice_handler_cb = sarif_ice_handler;\n \n   /* The metadata is handled in SARIF format, rather than as text.  */\n   context->show_cwe = false;"}, {"sha": "0f093081161a713a6c5a7f7594b638c597e5038a", "filename": "gcc/diagnostic.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a/gcc%2Fdiagnostic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a/gcc%2Fdiagnostic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.cc?ref=79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a", "patch": "@@ -241,6 +241,7 @@ diagnostic_initialize (diagnostic_context *context, int n_opts)\n   context->begin_group_cb = NULL;\n   context->end_group_cb = NULL;\n   context->final_cb = default_diagnostic_final_cb;\n+  context->ice_handler_cb = NULL;\n   context->includes_seen = NULL;\n   context->m_client_data_hooks = NULL;\n }\n@@ -665,6 +666,18 @@ diagnostic_action_after_output (diagnostic_context *context,\n     case DK_ICE:\n     case DK_ICE_NOBT:\n       {\n+\t/* Optional callback for attempting to handle ICEs gracefully.  */\n+\tif (void (*ice_handler_cb) (diagnostic_context *)\n+\t      = context->ice_handler_cb)\n+\t  {\n+\t    /* Clear the callback, to avoid potentially re-entering\n+\t       the routine if there's a crash within the handler.  */\n+\t    context->ice_handler_cb = NULL;\n+\t    ice_handler_cb (context);\n+\t  }\n+\t/* The context might have had diagnostic_finish called on\n+\t   it at this point.  */\n+\n \tstruct backtrace_state *state = NULL;\n \tif (diag_kind == DK_ICE)\n \t  state = backtrace_create_state (NULL, 0, bt_err_callback, NULL);"}, {"sha": "9a51097f1465a739d368060b84a4d410f4aace98", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a", "patch": "@@ -405,6 +405,9 @@ struct diagnostic_context\n      of a diagnostic's location.  */\n   void (*set_locations_cb)(diagnostic_context *, diagnostic_info *);\n \n+  /* Optional callback for attempting to handle ICEs gracefully.  */\n+  void (*ice_handler_cb) (diagnostic_context *context);\n+\n   /* Include files that diagnostic_report_current_module has already listed the\n      include path for.  */\n   hash_set<location_t, false, location_hash> *includes_seen;"}, {"sha": "cad530954784dc0ef97f98b86996475ed916b1d9", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-sarif-file-1.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-1.c?ref=79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a", "patch": "@@ -24,6 +24,11 @@\n          { dg-final { scan-sarif-file \"\\\"name\\\": \\\"GNU C\" } }\n          { dg-final { scan-sarif-file \"\\\"fullName\\\": \\\"GNU C\" } }\n          { dg-final { scan-sarif-file \"\\\"informationUri\\\": \\\"\" } }\n+\n+     { dg-final { scan-sarif-file \"\\\"invocations\\\": \\\\\\[\" } }\n+       { dg-final { scan-sarif-file \"\\\"toolExecutionNotifications\\\": \\\\\\[\\\\\\]\" } }\n+       { dg-final { scan-sarif-file \"\\\"executionSuccessful\\\": true\" } }\n+\n      { dg-final { scan-sarif-file \"\\\"results\\\": \\\\\\[\" } }\n        { dg-final { scan-sarif-file \"\\\"level\\\": \\\"warning\\\"\" } }\n        { dg-final { scan-sarif-file \"\\\"ruleId\\\": \\\"-Wcpp\\\"\" } }"}, {"sha": "9186a3262ca451e92653163740d21f02a55c382b", "filename": "gcc/testsuite/gcc.dg/plugin/crash-test-ice-sarif.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcrash-test-ice-sarif.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcrash-test-ice-sarif.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcrash-test-ice-sarif.c?ref=79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-format=sarif-file\" } */\n+\n+extern void inject_ice (void);\n+\n+void test_inject_ice (void)\n+{\n+  inject_ice (); /* { dg-ice \"\" } */\n+  /* { dg-regexp \"during GIMPLE pass: crash_test\" } */\n+}\n+\n+/* Verify that some JSON was written to a file with the expected name.  */\n+\n+/* We expect various properties.\n+   The indentation here reflects the expected hierarchy, though these tests\n+   don't check for that, merely the string fragments we expect.\n+\n+   { dg-final { scan-sarif-file \"\\\"version\\\": \\\"2.1.0\\\"\" } }\n+   { dg-final { scan-sarif-file \"\\\"runs\\\": \\\\\\[\" } }\n+     { dg-final { scan-sarif-file \"\\\"artifacts\\\": \\\\\\[\" } } \n+       { dg-final { scan-sarif-file \"\\\"location\\\": \" } }\n+         { dg-final { scan-sarif-file \"\\\"uri\\\": \" } }\n+\n+       { dg-final { scan-sarif-file \"\\\"sourceLanguage\\\": \\\"c\\\"\" { target c } } }\n+       { dg-final { scan-sarif-file \"\\\"sourceLanguage\\\": \\\"cplusplus\\\"\" { target c++ } } }\n+\n+       { dg-final { scan-sarif-file \"\\\"contents\\\": \" } }\n+         { dg-final { scan-sarif-file \"\\\"text\\\": \" } }\n+     { dg-final { scan-sarif-file \"\\\"tool\\\": \" } }\n+       { dg-final { scan-sarif-file \"\\\"driver\\\": \" } }\n+         { dg-final { scan-sarif-file \"\\\"name\\\": \\\"GNU C\" } }\n+         { dg-final { scan-sarif-file \"\\\"fullName\\\": \\\"GNU C\" } }\n+         { dg-final { scan-sarif-file \"\\\"informationUri\\\": \\\"\" } }\n+       { dg-final { scan-sarif-file \"\\\"extensions\\\": \\\\\\[\" } }\n+         { dg-final { scan-sarif-file \"\\\"name\\\": \\\"crash_test_plugin\\\"\" } }\n+\n+     We expect no results:\n+     { dg-final { scan-sarif-file \"\\\"results\\\": \\\\\\[\\\\\\]\" } }\n+\n+     but instead should have an invocations array...\n+\n+     { dg-final { scan-sarif-file \"\\\"invocations\\\": \\\\\\[\" } }\n+\n+     ...containing this:\n+       { dg-final { scan-sarif-file \"\\\"executionSuccessful\\\": false\" } }\n+       { dg-final { scan-sarif-file \"\\\"toolExecutionNotifications\\\": \\\\\\[\" } }\n+\n+       ...containing this notification:\n+         { dg-final { scan-sarif-file \"\\\"level\\\": \\\"error\\\"\" } }\n+         { dg-final { scan-sarif-file \"\\\"locations\\\": \\\\\\[\" } }\n+           { dg-final { scan-sarif-file \"\\\"logicalLocations\\\": \\\\\\[\" } }\n+             { dg-final { scan-sarif-file \"\\\"kind\\\": \\\"function\\\"\" } }\n+             { dg-final { scan-sarif-file \"\\\"name\\\": \\\"test_inject_ice\\\"\" } }\n+           { dg-final { scan-sarif-file \"\\\"physicalLocation\\\": \" } }\n+             { dg-final { scan-sarif-file \"\\\"contextRegion\\\": \" } }\n+             { dg-final { scan-sarif-file \"\\\"artifactLocation\\\": \" } }\n+             { dg-final { scan-sarif-file \"\\\"region\\\": \" } }\n+               { dg-final { scan-sarif-file \"\\\"startLine\\\": 8\" } }\n+               { dg-final { scan-sarif-file \"\\\"startColumn\\\": 3\" } }\n+               { dg-final { scan-sarif-file \"\\\"endColumn\\\": 16\" } }\n+         { dg-final { scan-sarif-file \"\\\"message\\\": \" } }\n+           { dg-final { scan-sarif-file \"\\\"text\\\": \\\"I'm sorry Dave, I'm afraid I can't do that\\\"\" } } */"}, {"sha": "cee701b135c18dc795f106fcf421c06d06c6c281", "filename": "gcc/testsuite/gcc.dg/plugin/crash-test-ice-stderr.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcrash-test-ice-stderr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcrash-test-ice-stderr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcrash-test-ice-stderr.c?ref=79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+\n+extern void inject_ice (void);\n+\n+void test_1 (void)\n+{\n+  inject_ice (); /* { dg-ice \"I'm sorry Dave, I'm afraid I can't do that\" } */\n+  /* { dg-regexp \"during GIMPLE pass: crash_test\" } */\n+}"}, {"sha": "99de3f888d435a0170d6ae636a00fad09205a027", "filename": "gcc/testsuite/gcc.dg/plugin/crash-test-write-though-null-sarif.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcrash-test-write-though-null-sarif.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcrash-test-write-though-null-sarif.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcrash-test-write-though-null-sarif.c?ref=79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-format=sarif-file\" } */\n+\n+extern void inject_write_through_null (void);\n+\n+void test_inject_write_through_null (void)\n+{\n+  inject_write_through_null (); /* { dg-ice \"\" } */\n+  /* { dg-regexp \"during GIMPLE pass: crash_test\" } */\n+}\n+\n+/* Verify that some JSON was written to a file with the expected name.  */\n+\n+/* We expect various properties.\n+   The indentation here reflects the expected hierarchy, though these tests\n+   don't check for that, merely the string fragments we expect.\n+\n+   { dg-final { scan-sarif-file \"\\\"version\\\": \\\"2.1.0\\\"\" } }\n+   { dg-final { scan-sarif-file \"\\\"runs\\\": \\\\\\[\" } }\n+     { dg-final { scan-sarif-file \"\\\"artifacts\\\": \\\\\\[\" } } \n+       { dg-final { scan-sarif-file \"\\\"location\\\": \" } }\n+         { dg-final { scan-sarif-file \"\\\"uri\\\": \" } }\n+\n+       { dg-final { scan-sarif-file \"\\\"sourceLanguage\\\": \\\"c\\\"\" { target c } } }\n+       { dg-final { scan-sarif-file \"\\\"sourceLanguage\\\": \\\"cplusplus\\\"\" { target c++ } } }\n+\n+       { dg-final { scan-sarif-file \"\\\"contents\\\": \" } }\n+         { dg-final { scan-sarif-file \"\\\"text\\\": \" } }\n+     { dg-final { scan-sarif-file \"\\\"tool\\\": \" } }\n+       { dg-final { scan-sarif-file \"\\\"driver\\\": \" } }\n+         { dg-final { scan-sarif-file \"\\\"name\\\": \\\"GNU C\" } }\n+         { dg-final { scan-sarif-file \"\\\"fullName\\\": \\\"GNU C\" } }\n+         { dg-final { scan-sarif-file \"\\\"informationUri\\\": \\\"\" } }\n+       { dg-final { scan-sarif-file \"\\\"extensions\\\": \\\\\\[\" } }\n+         { dg-final { scan-sarif-file \"\\\"name\\\": \\\"crash_test_plugin\\\"\" } }\n+\n+     We expect no results:\n+     { dg-final { scan-sarif-file \"\\\"results\\\": \\\\\\[\\\\\\]\" } }\n+\n+     but instead should have an invocations array...\n+\n+     { dg-final { scan-sarif-file \"\\\"invocations\\\": \\\\\\[\" } }\n+\n+     ...containing this:\n+       { dg-final { scan-sarif-file \"\\\"executionSuccessful\\\": false\" } }\n+       { dg-final { scan-sarif-file \"\\\"toolExecutionNotifications\\\": \\\\\\[\" } }\n+\n+       ...containing this notification:\n+         { dg-final { scan-sarif-file \"\\\"level\\\": \\\"error\\\"\" } }\n+         { dg-final { scan-sarif-file \"\\\"locations\\\": \\\\\\[\" } }\n+           { dg-final { scan-sarif-file \"\\\"logicalLocations\\\": \\\\\\[\" } }\n+             { dg-final { scan-sarif-file \"\\\"kind\\\": \\\"function\\\"\" } }\n+             { dg-final { scan-sarif-file \"\\\"name\\\": \\\"test_inject_write_through_null\\\"\" } }\n+           { dg-final { scan-sarif-file \"\\\"physicalLocation\\\": \" } }\n+             { dg-final { scan-sarif-file \"\\\"contextRegion\\\": \" } }\n+             { dg-final { scan-sarif-file \"\\\"artifactLocation\\\": \" } }\n+             { dg-final { scan-sarif-file \"\\\"region\\\": \" } }\n+               { dg-final { scan-sarif-file \"\\\"startLine\\\": 8\" } }\n+               { dg-final { scan-sarif-file \"\\\"startColumn\\\": 3\" } }\n+               { dg-final { scan-sarif-file \"\\\"endColumn\\\": 31\" } }\n+         { dg-final { scan-sarif-file \"\\\"message\\\": \" } }\n+           { dg-final { scan-sarif-file \"\\\"text\\\": \\\"Segmentation fault\\\"\" } } */"}, {"sha": "7b43e4236336b6a0247ae1728050cec672a23d49", "filename": "gcc/testsuite/gcc.dg/plugin/crash-test-write-though-null-stderr.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcrash-test-write-though-null-stderr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcrash-test-write-though-null-stderr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcrash-test-write-though-null-stderr.c?ref=79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+\n+extern void inject_write_through_null (void);\n+\n+void test_inject_write_through_null (void)\n+{\n+  inject_write_through_null (); /* { dg-ice \"Segmentation fault\" } */ \n+  /* { dg-regexp \"during GIMPLE pass: crash_test\" } */\n+}"}, {"sha": "03ad096964b3d7eadc5534b34cef0b56f750d259", "filename": "gcc/testsuite/gcc.dg/plugin/crash_test_plugin.c", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcrash_test_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcrash_test_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcrash_test_plugin.c?ref=79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a", "patch": "@@ -0,0 +1,135 @@\n+/* { dg-options \"-O\" } */\n+\n+#include \"gcc-plugin.h\"\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"toplev.h\"\n+#include \"basic-block.h\"\n+#include \"hash-table.h\"\n+#include \"vec.h\"\n+#include \"ggc.h\"\n+#include \"basic-block.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"internal-fn.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimple-fold.h\"\n+#include \"tree-eh.h\"\n+#include \"gimple-expr.h\"\n+#include \"is-a.h\"\n+#include \"tree.h\"\n+#include \"tree-pass.h\"\n+#include \"intl.h\"\n+#include \"plugin-version.h\"\n+#include \"c-family/c-common.h\"\n+#include \"diagnostic.h\"\n+#include \"context.h\"\n+\n+int plugin_is_GPL_compatible;\n+\n+/* A custom pass for injecting a crash in the middle-end when compiling\n+   certain functions.  */\n+\n+const pass_data pass_data_crash_test =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"crash_test\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_crash_test : public gimple_opt_pass\n+{\n+public:\n+  pass_crash_test(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_crash_test, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate (function *) final override { return true; }\n+  unsigned int execute (function *) final override;\n+\n+}; // class pass_test_groups\n+\n+/* Determine if STMT is a call to a function named FUNCNAME.\n+   If so, return STMT as a gcall *.  Otherwise return NULL.  */\n+\n+static gcall *\n+check_for_named_call (gimple *stmt, const char *funcname)\n+{\n+  gcc_assert (funcname);\n+\n+  gcall *call = dyn_cast <gcall *> (stmt);\n+  if (!call)\n+    return NULL;\n+\n+  tree fndecl = gimple_call_fndecl (call);\n+  if (!fndecl)\n+    return NULL;\n+\n+  if (strcmp (IDENTIFIER_POINTER (DECL_NAME (fndecl)), funcname))\n+    return NULL;\n+\n+  return call;\n+}\n+\n+unsigned int\n+pass_crash_test::execute (function *fun)\n+{\n+  gimple_stmt_iterator gsi;\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, fun)\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      {\n+\tgimple *stmt = gsi_stmt (gsi);\n+\tif (gcall *call = check_for_named_call (stmt, \"inject_ice\"))\n+\t  {\n+\t    input_location = stmt->location;\n+\t    internal_error (\"I'm sorry Dave, I'm afraid I can't do that\");\n+\t  }\n+\tif (gcall *call = check_for_named_call (stmt,\n+\t\t\t\t\t\t\"inject_write_through_null\"))\n+\t  {\n+\t    input_location = stmt->location;\n+\t    int *p = NULL;\n+\t    *p = 42;\n+\t  }\n+      }\n+\n+  return 0;\n+}\n+\n+/* Entrypoint for the plugin.\n+   Create and register the custom pass.  */\n+\n+int\n+plugin_init (struct plugin_name_args *plugin_info,\n+\t     struct plugin_gcc_version *version)\n+{\n+  struct register_pass_info pass_info;\n+  const char *plugin_name = plugin_info->base_name;\n+  int argc = plugin_info->argc;\n+  struct plugin_argument *argv = plugin_info->argv;\n+\n+  if (!plugin_default_version_check (version, &gcc_version))\n+    return 1;\n+\n+  pass_info.pass = new pass_crash_test (g);\n+  pass_info.reference_pass_name = \"*warn_function_noreturn\";\n+  pass_info.ref_pass_instance_number = 1;\n+  pass_info.pos_op = PASS_POS_INSERT_AFTER;\n+  register_callback (plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL,\n+\t\t     &pass_info);\n+\n+  return 0;\n+}"}, {"sha": "4d6304cd1007c8dd321d173179133968079a1c81", "filename": "gcc/testsuite/gcc.dg/plugin/plugin.exp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp?ref=79aaba0a71f34ac1ac2c4cec907ff74740a6cf1a", "patch": "@@ -69,6 +69,11 @@ set plugin_test_list [list \\\n     { poly-int-05_plugin.c poly-int-test-1.c } \\\n     { poly-int-06_plugin.c poly-int-test-1.c } \\\n     { poly-int-07_plugin.c poly-int-test-1.c } \\\n+    { crash_test_plugin.c \\\n+\t  crash-test-ice-stderr.c \\\n+\t  crash-test-write-though-null-stderr.c \\\n+\t  crash-test-ice-sarif.c \\\n+\t  crash-test-write-though-null-sarif.c } \\\n     { diagnostic_group_plugin.c \\\n \t  diagnostic-group-test-1.c } \\\n     { diagnostic_plugin_test_show_locus.c \\"}]}