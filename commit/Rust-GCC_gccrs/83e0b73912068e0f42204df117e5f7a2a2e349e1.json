{"sha": "83e0b73912068e0f42204df117e5f7a2a2e349e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNlMGI3MzkxMjA2OGUwZjQyMjA0ZGYxMTdlNWY3YTJhMmUzNDllMQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2016-05-30T16:04:50Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2016-05-30T16:04:50Z"}, "message": "Add profiling support for IVOPTS\n\n\t* tree-ssa-loop-ivopts.c (get_computation_cost_at): Scale\n\tcomputed costs by frequency of BB they belong to.\n\t(get_scaled_computation_cost_at): New function.\n\nFrom-SVN: r236888", "tree": {"sha": "6795d9c7bacefdf7c963d579f4481b62ee4f3400", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6795d9c7bacefdf7c963d579f4481b62ee4f3400"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83e0b73912068e0f42204df117e5f7a2a2e349e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83e0b73912068e0f42204df117e5f7a2a2e349e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83e0b73912068e0f42204df117e5f7a2a2e349e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83e0b73912068e0f42204df117e5f7a2a2e349e1/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "69be8c912404dce760ac048066a79a4026273439", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69be8c912404dce760ac048066a79a4026273439", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69be8c912404dce760ac048066a79a4026273439"}], "stats": {"total": 68, "additions": 52, "deletions": 16}, "files": [{"sha": "bc283630d136e60ff5f5202187f8a9c215ae9b20", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e0b73912068e0f42204df117e5f7a2a2e349e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e0b73912068e0f42204df117e5f7a2a2e349e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=83e0b73912068e0f42204df117e5f7a2a2e349e1", "patch": "@@ -1,3 +1,9 @@\n+2016-05-30  Martin Liska  <mliska@suse.cz>\n+\n+\t* tree-ssa-loop-ivopts.c (get_computation_cost_at): Scale\n+\tcomputed costs by frequency of BB they belong to.\n+\t(get_scaled_computation_cost_at): New function.\n+\n 2016-05-30  Alexander Monakov  <amonakov@ispras.ru>\n \t    Marc Glisse  <marc.glisse@inria.fr>\n "}, {"sha": "1e8d6377360c07ecb2fec78bf232d7ddeb54e454", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 46, "deletions": 16, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e0b73912068e0f42204df117e5f7a2a2e349e1/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e0b73912068e0f42204df117e5f7a2a2e349e1/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=83e0b73912068e0f42204df117e5f7a2a2e349e1", "patch": "@@ -4794,7 +4794,33 @@ get_loop_invariant_expr (struct ivopts_data *data, tree ubase,\n   return record_inv_expr (data, expr);\n }\n \n+/* Scale (multiply) the computed COST (except scratch part that should be\n+   hoisted out a loop) by header->frequency / AT->frequency,\n+   which makes expected cost more accurate.  */\n \n+static comp_cost\n+get_scaled_computation_cost_at (ivopts_data *data, gimple *at, iv_cand *cand,\n+\t\t\t\tcomp_cost cost)\n+{\n+   int loop_freq = data->current_loop->header->frequency;\n+   int bb_freq = at->bb->frequency;\n+   if (loop_freq != 0)\n+     {\n+       gcc_assert (cost.scratch <= cost.cost);\n+       int scaled_cost\n+\t = cost.scratch + (cost.cost - cost.scratch) * bb_freq / loop_freq;\n+\n+       if (dump_file && (dump_flags & TDF_DETAILS))\n+\t fprintf (dump_file, \"Scaling iv_use based on cand %d \"\n+\t\t  \"by %2.2f: %d (scratch: %d) -> %d (%d/%d)\\n\",\n+\t\t  cand->id, 1.0f * bb_freq / loop_freq, cost.cost,\n+\t\t  cost.scratch, scaled_cost, bb_freq, loop_freq);\n+\n+       cost.cost = scaled_cost;\n+     }\n+\n+  return cost;\n+}\n \n /* Determines the cost of the computation by that USE is expressed\n    from induction variable CAND.  If ADDRESS_P is true, we just need\n@@ -4982,18 +5008,21 @@ get_computation_cost_at (struct ivopts_data *data,\n      (symbol/var1/const parts may be omitted).  If we are looking for an\n      address, find the cost of addressing this.  */\n   if (address_p)\n-    return cost + get_address_cost (symbol_present, var_present,\n-\t\t\t\t    offset, ratio, cstepi,\n-\t\t\t\t    mem_mode,\n-\t\t\t\t    TYPE_ADDR_SPACE (TREE_TYPE (utype)),\n-\t\t\t\t    speed, stmt_is_after_inc, can_autoinc);\n+    {\n+      cost += get_address_cost (symbol_present, var_present,\n+\t\t\t\toffset, ratio, cstepi,\n+\t\t\t\tmem_mode,\n+\t\t\t\tTYPE_ADDR_SPACE (TREE_TYPE (utype)),\n+\t\t\t\tspeed, stmt_is_after_inc, can_autoinc);\n+      return get_scaled_computation_cost_at (data, at, cand, cost);\n+    }\n \n   /* Otherwise estimate the costs for computing the expression.  */\n   if (!symbol_present && !var_present && !offset)\n     {\n       if (ratio != 1)\n \tcost += mult_by_coeff_cost (ratio, TYPE_MODE (ctype), speed);\n-      return cost;\n+      return get_scaled_computation_cost_at (data, at, cand, cost);\n     }\n \n   /* Symbol + offset should be compile-time computable so consider that they\n@@ -5012,24 +5041,25 @@ get_computation_cost_at (struct ivopts_data *data,\n   aratio = ratio > 0 ? ratio : -ratio;\n   if (aratio != 1)\n     cost += mult_by_coeff_cost (aratio, TYPE_MODE (ctype), speed);\n-  return cost;\n+\n+  return get_scaled_computation_cost_at (data, at, cand, cost);\n \n fallback:\n   if (can_autoinc)\n     *can_autoinc = false;\n \n-  {\n-    /* Just get the expression, expand it and measure the cost.  */\n-    tree comp = get_computation_at (data->current_loop, use, cand, at);\n+  /* Just get the expression, expand it and measure the cost.  */\n+  tree comp = get_computation_at (data->current_loop, use, cand, at);\n \n-    if (!comp)\n-      return infinite_cost;\n+  if (!comp)\n+    return infinite_cost;\n+\n+  if (address_p)\n+    comp = build_simple_mem_ref (comp);\n \n-    if (address_p)\n-      comp = build_simple_mem_ref (comp);\n+  cost = comp_cost (computation_cost (comp, speed), 0);\n \n-    return comp_cost (computation_cost (comp, speed), 0);\n-  }\n+  return get_scaled_computation_cost_at (data, at, cand, cost);\n }\n \n /* Determines the cost of the computation by that USE is expressed"}]}