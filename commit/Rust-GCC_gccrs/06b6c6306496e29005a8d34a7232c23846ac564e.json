{"sha": "06b6c6306496e29005a8d34a7232c23846ac564e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZiNmM2MzA2NDk2ZTI5MDA1YThkMzRhNzIzMmMyMzg0NmFjNTY0ZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-17T21:24:41Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-17T21:24:41Z"}, "message": "compiler: enable escape analysis for runtime\n    \n    The runtime package was hard-coded non-escape, and the escape\n    analysis was not run for the runtime package. This CL removes\n    the hard-code, and lets the escape analysis decide. It is not\n    allowed for local variables and closures in the runtime to be\n    heap allocated. This CL adds the check that make sure that they\n    indeed do not escape.\n    \n    The escape analysis is always run when compiling the runtime\n    now.\n    \n    Fixes golang/go#17431\n    \n    Reviewed-on: https://go-review.googlesource.com/86246\n\nFrom-SVN: r256820", "tree": {"sha": "dac729920f45521246291f4094a2a88eb51f2f2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dac729920f45521246291f4094a2a88eb51f2f2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06b6c6306496e29005a8d34a7232c23846ac564e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06b6c6306496e29005a8d34a7232c23846ac564e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06b6c6306496e29005a8d34a7232c23846ac564e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06b6c6306496e29005a8d34a7232c23846ac564e/comments", "author": null, "committer": null, "parents": [{"sha": "78a5fce0915a9077f814d05b05277c926032cffa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78a5fce0915a9077f814d05b05277c926032cffa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78a5fce0915a9077f814d05b05277c926032cffa"}], "stats": {"total": 202, "additions": 114, "deletions": 88}, "files": [{"sha": "e7b959f850e5375b24cf4b48840d1d0aae8621b9", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b6c6306496e29005a8d34a7232c23846ac564e/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b6c6306496e29005a8d34a7232c23846ac564e/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=06b6c6306496e29005a8d34a7232c23846ac564e", "patch": "@@ -1,4 +1,4 @@\n-3ea7fc3b918210e7248dbc51d90af20639dc4167\n+1072286ca9249bd6f75628aead325a66286bcf5b\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "7bab3cbdd4a82bb0a81fa51f9e197f26da26518d", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 48, "deletions": 31, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b6c6306496e29005a8d34a7232c23846ac564e/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b6c6306496e29005a8d34a7232c23846ac564e/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=06b6c6306496e29005a8d34a7232c23846ac564e", "patch": "@@ -873,13 +873,12 @@ escape_hash_match(std::string suffix, std::string name)\n void\n Gogo::analyze_escape()\n {\n-  if (!optimize_allocation_flag.is_enabled() || saw_errors())\n+  if (saw_errors())\n     return;\n \n-  // Currently runtime is hard-coded to non-escape in various places.\n-  // Don't run escape analysis for runtime.\n-  // TODO: remove this once it works for runtime.\n-  if (this->compiling_runtime() && this->package_name() == \"runtime\")\n+  if (!optimize_allocation_flag.is_enabled()\n+      && !this->compiling_runtime())\n+    // We always run escape analysis when compiling runtime.\n     return;\n \n   // Discover strongly connected groups of functions to analyze for escape\n@@ -1473,6 +1472,35 @@ Escape_analysis_assign::statement(Block*, size_t*, Statement* s)\n   return TRAVERSE_SKIP_COMPONENTS;\n }\n \n+// Helper function to emit moved-to-heap diagnostics.\n+\n+static void\n+move_to_heap(Gogo* gogo, Expression *expr)\n+{\n+  Named_object* no;\n+  if (expr->var_expression() != NULL)\n+    no = expr->var_expression()->named_object();\n+  else if (expr->enclosed_var_expression() != NULL)\n+    no = expr->enclosed_var_expression()->variable();\n+  else\n+    return;\n+\n+  if ((no->is_variable()\n+       && !no->var_value()->is_global())\n+      || no->is_result_variable())\n+    {\n+      Node* n = Node::make_node(expr);\n+      if (gogo->debug_escape_level() != 0)\n+        go_inform(n->definition_location(),\n+                  \"moved to heap: %s\",\n+                  n->ast_format(gogo).c_str());\n+      if (gogo->compiling_runtime() && gogo->package_name() == \"runtime\")\n+        go_error_at(expr->location(),\n+                    \"%s escapes to heap, not allowed in runtime\",\n+                    n->ast_format(gogo).c_str());\n+    }\n+}\n+\n // Model expressions within a function as assignments and flows between nodes.\n \n int\n@@ -1489,13 +1517,7 @@ Escape_analysis_assign::expression(Expression** pexpr)\n       if (debug_level > 1)\n \tgo_inform((*pexpr)->location(), \"%s too large for stack\",\n                   n->ast_format(gogo).c_str());\n-      if (debug_level != 0\n-          && ((*pexpr)->var_expression() != NULL\n-              || (*pexpr)->enclosed_var_expression() != NULL))\n-        go_inform(n->definition_location(),\n-                  \"moved to heap: %s\",\n-                  n->ast_format(gogo).c_str());\n-\n+      move_to_heap(gogo, *pexpr);\n       n->set_encoding(Node::ESCAPE_HEAP);\n       (*pexpr)->address_taken(true);\n       this->assign(this->context_->sink(), n);\n@@ -2968,25 +2990,20 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t  if (src_leaks)\n \t    {\n \t      src->set_encoding(Node::ESCAPE_HEAP);\n-\t      if (debug_level != 0 && osrcesc != src->encoding())\n-\t\t{\n-                  if (underlying->var_expression() != NULL\n-                      || underlying->enclosed_var_expression() != NULL)\n-                    go_inform(underlying_node->definition_location(),\n-                              \"moved to heap: %s\",\n-                              underlying_node->ast_format(gogo).c_str());\n-\n-\t\t  if (debug_level > 1)\n-\t\t    go_inform(src->location(),\n-\t\t\t      \"%s escapes to heap, level={%d %d}, \"\n-\t\t\t      \"dst.eld=%d, src.eld=%d\",\n-\t\t\t      src->ast_format(gogo).c_str(), level.value(),\n-\t\t\t      level.suffix_value(), dst_state->loop_depth,\n-\t\t\t      mod_loop_depth);\n-\t\t  else\n-\t\t    go_inform(src->location(), \"%s escapes to heap\",\n-\t\t\t      src->ast_format(gogo).c_str());\n-\t\t}\n+              if (osrcesc != src->encoding())\n+                {\n+                  move_to_heap(gogo, underlying);\n+                  if (debug_level > 1)\n+                    go_inform(src->location(),\n+                              \"%s escapes to heap, level={%d %d}, \"\n+                              \"dst.eld=%d, src.eld=%d\",\n+                              src->ast_format(gogo).c_str(), level.value(),\n+                              level.suffix_value(), dst_state->loop_depth,\n+                              mod_loop_depth);\n+                  else if (debug_level > 0)\n+                    go_inform(src->location(), \"%s escapes to heap\",\n+                              src->ast_format(gogo).c_str());\n+                }\n \n \t      this->flood(level.decrease(), dst,\n \t\t\t  underlying_node, mod_loop_depth);"}, {"sha": "99fb1b59adee06df9207b5dd402be778c693a6ca", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 8, "deletions": 33, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b6c6306496e29005a8d34a7232c23846ac564e/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b6c6306496e29005a8d34a7232c23846ac564e/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=06b6c6306496e29005a8d34a7232c23846ac564e", "patch": "@@ -3700,7 +3700,7 @@ Expression::make_unsafe_cast(Type* type, Expression* expr,\n // called after escape analysis but before inserting write barriers.\n \n void\n-Unary_expression::check_operand_address_taken(Gogo* gogo)\n+Unary_expression::check_operand_address_taken(Gogo*)\n {\n   if (this->op_ != OPERATOR_AND)\n     return;\n@@ -3714,13 +3714,6 @@ Unary_expression::check_operand_address_taken(Gogo* gogo)\n   if ((n->encoding() & ESCAPE_MASK) == int(Node::ESCAPE_NONE))\n     this->escapes_ = false;\n \n-  // When compiling the runtime, the address operator does not cause\n-  // local variables to escape.  When escape analysis becomes the\n-  // default, this should be changed to make it an error if we have an\n-  // address operator that escapes.\n-  if (gogo->compiling_runtime() && gogo->package_name() == \"runtime\")\n-    this->escapes_ = false;\n-\n   Named_object* var = NULL;\n   if (this->expr_->var_expression() != NULL)\n     var = this->expr_->var_expression()->named_object();\n@@ -7028,26 +7021,14 @@ Bound_method_expression::do_flatten(Gogo* gogo, Named_object*,\n   vals->push_back(val);\n \n   Expression* ret = Expression::make_struct_composite_literal(st, vals, loc);\n+  ret = Expression::make_heap_expression(ret, loc);\n \n-  if (!gogo->compiling_runtime() || gogo->package_name() != \"runtime\")\n-    {\n-      ret = Expression::make_heap_expression(ret, loc);\n-      Node* n = Node::make_node(this);\n-      if ((n->encoding() & ESCAPE_MASK) == Node::ESCAPE_NONE)\n-        ret->heap_expression()->set_allocate_on_stack();\n-    }\n-  else\n-    {\n-      // When compiling the runtime, method closures do not escape.\n-      // When escape analysis becomes the default, and applies to\n-      // method closures, this should be changed to make it an error\n-      // if a method closure escapes.\n-      Temporary_statement* ctemp = Statement::make_temporary(st, ret, loc);\n-      inserter->insert(ctemp);\n-      ret = Expression::make_temporary_reference(ctemp, loc);\n-      ret = Expression::make_unary(OPERATOR_AND, ret, loc);\n-      ret->unary_expression()->set_does_not_escape();\n-    }\n+  Node* n = Node::make_node(this);\n+  if ((n->encoding() & ESCAPE_MASK) == Node::ESCAPE_NONE)\n+    ret->heap_expression()->set_allocate_on_stack();\n+  else if (gogo->compiling_runtime() && gogo->package_name() == \"runtime\")\n+    go_error_at(loc, \"%s escapes to heap, not allowed in runtime\",\n+                n->ast_format(gogo).c_str());\n \n   // If necessary, check whether the expression or any embedded\n   // pointers are nil.\n@@ -9577,12 +9558,6 @@ Call_expression::lower_varargs(Gogo* gogo, Named_object* function,\n \t\t\t       Type* varargs_type, size_t param_count,\n                                Slice_storage_escape_disp escape_disp)\n {\n-  // When compiling the runtime, varargs slices do not escape.  When\n-  // escape analysis becomes the default, this should be changed to\n-  // make it an error if we have a varargs slice that escapes.\n-  if (gogo->compiling_runtime() && gogo->package_name() == \"runtime\")\n-    escape_disp = SLICE_STORAGE_DOES_NOT_ESCAPE;\n-\n   if (this->varargs_are_lowered_)\n     return;\n "}, {"sha": "8162abf342b13a7914907cc05610e035a41cacd7", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b6c6306496e29005a8d34a7232c23846ac564e/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b6c6306496e29005a8d34a7232c23846ac564e/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=06b6c6306496e29005a8d34a7232c23846ac564e", "patch": "@@ -3059,21 +3059,6 @@ Parse::create_closure(Named_object* function, Enclosing_vars* enclosing_vars,\n   Struct_type* st = closure_var->var_value()->type()->deref()->struct_type();\n   Expression* cv = Expression::make_struct_composite_literal(st, initializer,\n \t\t\t\t\t\t\t     location);\n-\n-  // When compiling the runtime, closures do not escape.  When escape\n-  // analysis becomes the default, and applies to closures, this\n-  // should be changed to make it an error if a closure escapes.\n-  if (this->gogo_->compiling_runtime()\n-      && this->gogo_->package_name() == \"runtime\")\n-    {\n-      Temporary_statement* ctemp = Statement::make_temporary(st, cv, location);\n-      this->gogo_->add_statement(ctemp);\n-      Expression* ref = Expression::make_temporary_reference(ctemp, location);\n-      Expression* addr = Expression::make_unary(OPERATOR_AND, ref, location);\n-      addr->unary_expression()->set_does_not_escape();\n-      return addr;\n-    }\n-\n   return Expression::make_heap_expression(cv, location);\n }\n "}, {"sha": "fb3ef4d59020270c1556ffb92b46e3e00bb63bd0", "filename": "gcc/go/gofrontend/wb.cc", "status": "modified", "additions": 57, "deletions": 8, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b6c6306496e29005a8d34a7232c23846ac564e/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b6c6306496e29005a8d34a7232c23846ac564e/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fwb.cc?ref=06b6c6306496e29005a8d34a7232c23846ac564e", "patch": "@@ -54,14 +54,10 @@ Mark_address_taken::expression(Expression** pexpr)\n       // Slice of an array. The escape analysis models this with\n       // a child Node representing the address of the array.\n       bool escapes = false;\n-      if (!this->gogo_->compiling_runtime()\n-          || this->gogo_->package_name() != \"runtime\")\n-        {\n-          Node* n = Node::make_node(expr);\n-          if (n->child() == NULL\n-              || (n->child()->encoding() & ESCAPE_MASK) != Node::ESCAPE_NONE)\n-            escapes = true;\n-        }\n+      Node* n = Node::make_node(expr);\n+      if (n->child() == NULL\n+          || (n->child()->encoding() & ESCAPE_MASK) != Node::ESCAPE_NONE)\n+        escapes = true;\n       aie->array()->address_taken(escapes);\n     }\n \n@@ -127,6 +123,53 @@ Mark_address_taken::expression(Expression** pexpr)\n   return TRAVERSE_CONTINUE;\n }\n \n+// Check variables and closures do not escape when compiling runtime.\n+\n+class Check_escape : public Traverse\n+{\n+ public:\n+  Check_escape(Gogo* gogo)\n+    : Traverse(traverse_expressions | traverse_variables),\n+      gogo_(gogo)\n+  { }\n+\n+  int\n+  expression(Expression**);\n+\n+  int\n+  variable(Named_object*);\n+\n+ private:\n+  Gogo* gogo_;\n+};\n+\n+int\n+Check_escape::variable(Named_object* no)\n+{\n+  if ((no->is_variable() && no->var_value()->is_in_heap())\n+      || (no->is_result_variable()\n+          && no->result_var_value()->is_in_heap()))\n+    go_error_at(no->location(),\n+                \"%s escapes to heap, not allowed in runtime\",\n+                no->name().c_str());\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+int\n+Check_escape::expression(Expression** pexpr)\n+{\n+  Expression* expr = *pexpr;\n+  Func_expression* fe = expr->func_expression();\n+  if (fe != NULL && fe->closure() != NULL)\n+    {\n+      Node* n = Node::make_node(expr);\n+      if (n->encoding() == Node::ESCAPE_HEAP)\n+        go_error_at(expr->location(),\n+                    \"heap-allocated closure, not allowed in runtime\");\n+    }\n+  return TRAVERSE_CONTINUE;\n+}\n+\n // Add write barriers to the IR.  This are required by the concurrent\n // garbage collector.  A write barrier is needed for any write of a\n // pointer into memory controlled by the garbage collector.  Write\n@@ -370,6 +413,12 @@ Gogo::add_write_barriers()\n   Mark_address_taken mat(this);\n   this->traverse(&mat);\n \n+  if (this->compiling_runtime() && this->package_name() == \"runtime\")\n+    {\n+      Check_escape chk(this);\n+      this->traverse(&chk);\n+    }\n+\n   Write_barriers wb(this);\n   this->traverse(&wb);\n }"}]}