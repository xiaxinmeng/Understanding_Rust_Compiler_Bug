{"sha": "3b6d16993b9d6812f6212bce4f35547fd9e40457", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I2ZDE2OTkzYjlkNjgxMmY2MjEyYmNlNGYzNTU0N2ZkOWU0MDQ1Nw==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2013-10-30T14:27:25Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-10-30T14:27:25Z"}, "message": "regmove.c: Remove.\n\n2013-10-30  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* regmove.c: Remove.\n\t* tree-pass.h (make_pass_regmove): Remove.\n\t* timevar.def (TV_REGMOVE): Remove.\n\t* passes.def (pass_regmove): Remove.\n\t* opts.c (default_options_table): Remove entry for regmove.\n\t* doc/passes.texi: Remove regmove pass description.\n\t* doc/invoke.texi (-foptimize-register-move, -fregmove): Remove\n\toptions.\n\t(-fdump-rtl-regmove): Ditto.\n\t* common.opt (foptimize-register-move, fregmove): Ignore.\n\t* Makefile.in (OBJS): Remove regmove.o.\n\t* regmove.c: Remove.\n\t* ira-int.h (struct ira_allocno_pref, ira_pref_t): New structure\n\tand type.\n\t(struct ira_allocno) New member allocno_prefs.\n\t(ALLOCNO_PREFS): New macro.\n\t(ira_prefs, ira_prefs_num): New external vars.\n\t(ira_setup_alts, ira_get_dup_out_num, ira_debug_pref): New\n\tprototypes.\n\t(ira_debug_prefs, ira_debug_allocno_prefs, ira_create_pref):\n\tDitto.\n\t(ira_add_allocno_pref, ira_remove_pref, ira_remove_allocno_prefs):\n\tDitto.\n\t(ira_add_allocno_copy_to_list): Remove prototype.\n\t(ira_swap_allocno_copy_ends_if_necessary): Ditto.\n\t(ira_pref_iterator): New type.\n\t(ira_pref_iter_init, ira_pref_iter_cond): New functions.\n\t(FOR_EACH_PREF): New macro.\n\t* ira.c (commutative_constraint_p): Move from ira-conflicts.c.\n\t(ira_get_dup_out_num): Ditto. Rename from get_dup_num.  Modify the\n\tcode.\n\t(ira_setup_alts): New function.\n\t(decrease_live_ranges_number): New function.\n\t(ira): Call the above function.\n\t* ira-build.c (ira_prefs, ira_prefs_num): New global vars.\n\t(ira_create_allocno): Initialize allocno prefs.\n\t(pref_pool, pref_vec): New static vars.\n\t(initiate_prefs, find_allocno_pref, ira_create_pref): New\n\tfunctions.\n\t(add_allocno_pref_to_list, ira_add_allocno_pref, print_pref): Ditto.\n\t(ira_debug_pref, print_prefs, ira_debug_prefs): Ditto.\n\t(print_allocno_prefs, ira_debug_allocno_prefs, finish_pref): Ditto.\n\t(ira_remove_pref, ira_remove_allocno_prefs, finish_prefs): Ditto.\n\t(ira_add_allocno_copy_to_list): Make static.  Rename to\n\tadd_allocno_copy_to_list.\n\t(ira_swap_allocno_copy_ends_if_necessary): Make static.  Rename to\n\tswap_allocno_copy_ends_if_necessary.\n\t(remove_unnecessary_allocnos, remove_low_level_allocnos): Call\n\tira_remove_allocno_prefs.\n\t(ira_flattening): Ditto.\n\t(ira_build): Call initiate_prefs, print_prefs.\n\t(ira_destroy): Call finish_prefs.\n\t* ira-color.c (struct update_cost_record): New.\n\t(struct allocno_color_data): Add new member update_cost_records.\n\t(update_cost_record_pool): New static var.\n\t(init_update_cost_records, get_update_cost_record): New functions.\n\t(free_update_cost_record_list, finish_update_cost_records): Ditto.\n\t(struct update_cost_queue_elem): Add member from.\n\t(initiate_cost_update): Call init_update_cost_records.\n\t(finish_cost_update): Call finish_update_cost_records.\n\t(queue_update_cost, get_next_update_cost): Add new param from.\n\t(Update_allocno_cost, update_costs_from_allocno): New functions.\n\t(update_costs_from_prefs): Ditto.\n\t(update_copy_costs): Rename to update_costs_from_copies.\n\t(restore_costs_from_copies): New function.\n\t(update_conflict_hard_regno_costs): Don't go back.\n\t(assign_hard_reg): Call restore_costs_from_copies.  Add printing\n\tmore debug info.\n\t(pop_allocnos): Add priniting more debug info.\n\t(color_allocnos): Remove prefs for conflicting hard regs.\n\tCall update_costs_from_prefs.\n\t* ira-conflicts.c (commutative_constraint_p): Move to ira.c\n\t(get_dup_num): Rename, modify, and move to ira.c\n\t(process_regs_for_copy): Add prefs.\n\t(add_insn_allocno_copies): Put src as first arg of\n\tprocess_regs_for_copy.  Remove dead code.  Call ira_setup_alts.\n\t* ira-costs.c (record_reg_classes): Modify and move code into\n\trecord_operands_costs.\n\t(find_costs_and_classes): Create prefs for the hard reg of small\n\treg class.\n\t(process_bb_node_for_hard_reg_moves): Add prefs.\n\n2013-10-30  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* gcc.target/i386/fma_double_3.c: Use pattern for\n\tscan-assembler-times instead of just one insn name.\n\t* gcc.target/i386/fma_double_5.c: Ditto.\n\t* gcc.target/i386/fma_float_3.c: Ditto.\n\t* gcc.target/i386/fma_float_5.c: Ditto.\n\t* gcc.target/i386/l_fma_double_1.c: Ditto.\n\t* gcc.target/i386/l_fma_double_2.c: Ditto.\n\t* gcc.target/i386/l_fma_double_3.c: Ditto.\n\t* gcc.target/i386/l_fma_double_4.c: Ditto.\n\t* gcc.target/i386/l_fma_double_5.c: Ditto.\n\t* gcc.target/i386/l_fma_double_6.c: Ditto.\n\t* gcc.target/i386/l_fma_float_1.c: Ditto.\n\t* gcc.target/i386/l_fma_float_2.c: Ditto.\n\t* gcc.target/i386/l_fma_float_3.c: Ditto.\n\t* gcc.target/i386/l_fma_float_4.c: Ditto.\n\t* gcc.target/i386/l_fma_float_5.c: Ditto.\n\t* gcc.target/i386/l_fma_float_6.c: Ditto.\n\nFrom-SVN: r204212", "tree": {"sha": "27225af1bc13234694bb062d327dd794b7bbb8cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27225af1bc13234694bb062d327dd794b7bbb8cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b6d16993b9d6812f6212bce4f35547fd9e40457", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b6d16993b9d6812f6212bce4f35547fd9e40457", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b6d16993b9d6812f6212bce4f35547fd9e40457", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b6d16993b9d6812f6212bce4f35547fd9e40457/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1bef9b2340e56beffd12c4fe84761487ca5f0ce9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bef9b2340e56beffd12c4fe84761487ca5f0ce9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bef9b2340e56beffd12c4fe84761487ca5f0ce9"}], "stats": {"total": 3203, "additions": 1361, "deletions": 1842}, "files": [{"sha": "d002ded4e8e295f85a256d4f2b1b909b23a0e723", "filename": "gcc/ChangeLog", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -1,3 +1,87 @@\n+2013-10-30  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* regmove.c: Remove.\n+\t* tree-pass.h (make_pass_regmove): Remove.\n+\t* timevar.def (TV_REGMOVE): Remove.\n+\t* passes.def (pass_regmove): Remove.\n+\t* opts.c (default_options_table): Remove entry for regmove.\n+\t* doc/passes.texi: Remove regmove pass description.\n+\t* doc/invoke.texi (-foptimize-register-move, -fregmove): Remove\n+\toptions.\n+\t(-fdump-rtl-regmove): Ditto.\n+\t* common.opt (foptimize-register-move, fregmove): Ignore.\n+\t* Makefile.in (OBJS): Remove regmove.o.\n+\t* regmove.c: Remove.\n+\t* ira-int.h (struct ira_allocno_pref, ira_pref_t): New structure\n+\tand type.\n+\t(struct ira_allocno) New member allocno_prefs.\n+\t(ALLOCNO_PREFS): New macro.\n+\t(ira_prefs, ira_prefs_num): New external vars.\n+\t(ira_setup_alts, ira_get_dup_out_num, ira_debug_pref): New\n+\tprototypes.\n+\t(ira_debug_prefs, ira_debug_allocno_prefs, ira_create_pref):\n+\tDitto.\n+\t(ira_add_allocno_pref, ira_remove_pref, ira_remove_allocno_prefs):\n+\tDitto.\n+\t(ira_add_allocno_copy_to_list): Remove prototype.\n+\t(ira_swap_allocno_copy_ends_if_necessary): Ditto.\n+\t(ira_pref_iterator): New type.\n+\t(ira_pref_iter_init, ira_pref_iter_cond): New functions.\n+\t(FOR_EACH_PREF): New macro.\n+\t* ira.c (commutative_constraint_p): Move from ira-conflicts.c.\n+\t(ira_get_dup_out_num): Ditto. Rename from get_dup_num.  Modify the\n+\tcode.\n+\t(ira_setup_alts): New function.\n+\t(decrease_live_ranges_number): New function.\n+\t(ira): Call the above function.\n+\t* ira-build.c (ira_prefs, ira_prefs_num): New global vars.\n+\t(ira_create_allocno): Initialize allocno prefs.\n+\t(pref_pool, pref_vec): New static vars.\n+\t(initiate_prefs, find_allocno_pref, ira_create_pref): New\n+\tfunctions.\n+\t(add_allocno_pref_to_list, ira_add_allocno_pref, print_pref): Ditto.\n+\t(ira_debug_pref, print_prefs, ira_debug_prefs): Ditto.\n+\t(print_allocno_prefs, ira_debug_allocno_prefs, finish_pref): Ditto.\n+\t(ira_remove_pref, ira_remove_allocno_prefs, finish_prefs): Ditto.\n+\t(ira_add_allocno_copy_to_list): Make static.  Rename to\n+\tadd_allocno_copy_to_list.\n+\t(ira_swap_allocno_copy_ends_if_necessary): Make static.  Rename to\n+\tswap_allocno_copy_ends_if_necessary.\n+\t(remove_unnecessary_allocnos, remove_low_level_allocnos): Call\n+\tira_remove_allocno_prefs.\n+\t(ira_flattening): Ditto.\n+\t(ira_build): Call initiate_prefs, print_prefs.\n+\t(ira_destroy): Call finish_prefs.\n+\t* ira-color.c (struct update_cost_record): New.\n+\t(struct allocno_color_data): Add new member update_cost_records.\n+\t(update_cost_record_pool): New static var.\n+\t(init_update_cost_records, get_update_cost_record): New functions.\n+\t(free_update_cost_record_list, finish_update_cost_records): Ditto.\n+\t(struct update_cost_queue_elem): Add member from.\n+\t(initiate_cost_update): Call init_update_cost_records.\n+\t(finish_cost_update): Call finish_update_cost_records.\n+\t(queue_update_cost, get_next_update_cost): Add new param from.\n+\t(Update_allocno_cost, update_costs_from_allocno): New functions.\n+\t(update_costs_from_prefs): Ditto.\n+\t(update_copy_costs): Rename to update_costs_from_copies.\n+\t(restore_costs_from_copies): New function.\n+\t(update_conflict_hard_regno_costs): Don't go back.\n+\t(assign_hard_reg): Call restore_costs_from_copies.  Add printing\n+\tmore debug info.\n+\t(pop_allocnos): Add priniting more debug info.\n+\t(color_allocnos): Remove prefs for conflicting hard regs.\n+\tCall update_costs_from_prefs.\n+\t* ira-conflicts.c (commutative_constraint_p): Move to ira.c\n+\t(get_dup_num): Rename, modify, and move to ira.c\n+\t(process_regs_for_copy): Add prefs.\n+\t(add_insn_allocno_copies): Put src as first arg of\n+\tprocess_regs_for_copy.  Remove dead code.  Call ira_setup_alts.\n+\t* ira-costs.c (record_reg_classes): Modify and move code into\n+\trecord_operands_costs.\n+\t(find_costs_and_classes): Create prefs for the hard reg of small\n+\treg class.\n+\t(process_bb_node_for_hard_reg_moves): Add prefs.\n+\n 2013-10-30  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/57100"}, {"sha": "cc88fb8347c0e088103d3fcf1c78a0d49373899a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -1328,7 +1328,6 @@ OBJS = \\\n \treg-stack.o \\\n \tregcprop.o \\\n \treginfo.o \\\n-\tregmove.o \\\n \tregrename.o \\\n \tregstat.o \\\n \treload.o \\"}, {"sha": "398b57d7743b3039c6eaa651d4e9f3d5de4c63e0", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -1597,8 +1597,8 @@ Common Joined RejectNegative Var(common_deferred_options) Defer\n -fopt-info[-<type>=filename]\tDump compiler optimization details\n \n foptimize-register-move\n-Common Report Var(flag_regmove) Optimization\n-Do the full register move optimization pass\n+Common Ignore\n+Does nothing. Preserved for backward compatibility.\n \n foptimize-sibling-calls\n Common Report Var(flag_optimize_sibling_calls) Optimization\n@@ -1735,8 +1735,8 @@ Common Report Var(flag_pcc_struct_return,0) Optimization\n Return small aggregates in registers\n \n fregmove\n-Common Report Var(flag_regmove) Optimization\n-Enables a register move optimization\n+Common Ignore\n+Does nothing. Preserved for backward compatibility.\n \n frename-registers\n Common Report Var(flag_rename_registers) Init(2) Optimization"}, {"sha": "233338b919e46627dd5bbb2dc69ae4b495495b88", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -388,13 +388,13 @@ Objective-C and Objective-C++ Dialects}.\n -fno-inline -fno-math-errno -fno-peephole -fno-peephole2 @gol\n -fno-sched-interblock -fno-sched-spec -fno-signed-zeros @gol\n -fno-toplevel-reorder -fno-trapping-math -fno-zero-initialized-in-bss @gol\n--fomit-frame-pointer -foptimize-register-move -foptimize-sibling-calls @gol\n+-fomit-frame-pointer -foptimize-sibling-calls @gol\n -fpartial-inlining -fpeel-loops -fpredictive-commoning @gol\n -fprefetch-loop-arrays -fprofile-report @gol\n -fprofile-correction -fprofile-dir=@var{path} -fprofile-generate @gol\n -fprofile-generate=@var{path} @gol\n -fprofile-use -fprofile-use=@var{path} -fprofile-values @gol\n--freciprocal-math -free -fregmove -frename-registers -freorder-blocks @gol\n+-freciprocal-math -free -frename-registers -freorder-blocks @gol\n -freorder-blocks-and-partition -freorder-functions @gol\n -frerun-cse-after-loop -freschedule-modulo-scheduled-loops @gol\n -frounding-math -fsched2-use-superblocks -fsched-pressure @gol\n@@ -5822,10 +5822,6 @@ Dump after post-reload optimizations.\n @opindex fdump-rtl-pro_and_epilogue\n Dump after generating the function prologues and epilogues.\n \n-@item -fdump-rtl-regmove\n-@opindex fdump-rtl-regmove\n-Dump after the register move pass.\n-\n @item -fdump-rtl-sched1\n @itemx -fdump-rtl-sched2\n @opindex fdump-rtl-sched1\n@@ -6738,7 +6734,6 @@ also turns on the following optimization flags:\n -foptimize-sibling-calls @gol\n -fpartial-inlining @gol\n -fpeephole2 @gol\n--fregmove @gol\n -freorder-blocks  -freorder-functions @gol\n -frerun-cse-after-loop  @gol\n -fsched-interblock  -fsched-spec @gol\n@@ -7262,20 +7257,6 @@ registers after writing to their lower 32-bit half.\n \n Enabled for x86 at levels @option{-O2}, @option{-O3}.\n \n-@item -foptimize-register-move\n-@itemx -fregmove\n-@opindex foptimize-register-move\n-@opindex fregmove\n-Attempt to reassign register numbers in move instructions and as\n-operands of other simple instructions in order to maximize the amount of\n-register tying.  This is especially helpful on machines with two-operand\n-instructions.\n-\n-Note @option{-fregmove} and @option{-foptimize-register-move} are the same\n-optimization.\n-\n-Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n-\n @item -fira-algorithm=@var{algorithm}\n Use the specified coloring algorithm for the integrated register\n allocator.  The @var{algorithm} argument can be @samp{priority}, which"}, {"sha": "3ed9a4fc20462a8cc5276c6fe3e4b2137eb9367b", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -823,14 +823,6 @@ RTL expressions for the instructions by substitution, simplifies the\n result using algebra, and then attempts to match the result against\n the machine description.  The code is located in @file{combine.c}.\n \n-@item Register movement\n-\n-This pass looks for cases where matching constraints would force an\n-instruction to need a reload, and this reload would be a\n-register-to-register move.  It then attempts to change the registers\n-used by the instruction to avoid the move instruction.  The code is\n-located in @file{regmove.c}.\n-\n @item Mode switching optimization\n \n This pass looks for instructions that require the processor to be in a\n@@ -868,11 +860,6 @@ them by an equivalent expression (e.g.@: a constant) or by placing\n them on the stack.  This is done in several subpasses:\n \n @itemize @bullet\n-@item\n-Register move optimizations.  This pass makes some simple RTL code\n-transformations which improve the subsequent register allocation.  The\n-source file is @file{regmove.c}.\n-\n @item\n The integrated register allocator (@acronym{IRA}).  It is called\n integrated because coalescing, register live range splitting, and hard"}, {"sha": "ed513767f3c7c4d7c5f996650f2473f5b2488c97", "filename": "gcc/ira-build.c", "status": "modified", "additions": 215, "deletions": 9, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -79,6 +79,13 @@ int ira_objects_num;\n /* Map a conflict id to its conflict record.  */\n ira_object_t *ira_object_id_map;\n \n+/* Array of references to all allocno preferences.  The order number\n+   of the preference corresponds to the index in the array.  */\n+ira_pref_t *ira_prefs;\n+\n+/* Size of the previous array.  */\n+int ira_prefs_num;\n+\n /* Array of references to all copies.  The order number of the copy\n    corresponds to the index in the array.  Removed copies have NULL\n    element value.  */\n@@ -515,6 +522,7 @@ ira_create_allocno (int regno, bool cap_p,\n   ALLOCNO_BAD_SPILL_P (a) = false;\n   ALLOCNO_ASSIGNED_P (a) = false;\n   ALLOCNO_MODE (a) = (regno < 0 ? VOIDmode : PSEUDO_REGNO_MODE (regno));\n+  ALLOCNO_PREFS (a) = NULL;\n   ALLOCNO_COPIES (a) = NULL;\n   ALLOCNO_HARD_REG_COSTS (a) = NULL;\n   ALLOCNO_CONFLICT_HARD_REG_COSTS (a) = NULL;\n@@ -1163,6 +1171,195 @@ finish_allocnos (void)\n \n \f\n \n+/* Pools for allocno preferences.  */\n+static alloc_pool pref_pool;\n+\n+/* Vec containing references to all created preferences.  It is a\n+   container of array ira_prefs.  */\n+static vec<ira_pref_t> pref_vec;\n+\n+/* The function initializes data concerning allocno prefs.  */\n+static void\n+initiate_prefs (void)\n+{\n+  pref_pool\n+    = create_alloc_pool (\"prefs\", sizeof (struct ira_allocno_pref), 100);\n+  pref_vec.create (get_max_uid ());\n+  ira_prefs = NULL;\n+  ira_prefs_num = 0;\n+}\n+\n+/* Return pref for A and HARD_REGNO if any.  */\n+static ira_pref_t\n+find_allocno_pref (ira_allocno_t a, int hard_regno)\n+{\n+  ira_pref_t pref;\n+\n+  for (pref = ALLOCNO_PREFS (a); pref != NULL; pref = pref->next_pref)\n+    if (pref->allocno == a && pref->hard_regno == hard_regno)\n+      return pref;\n+  return NULL;\n+}\n+\n+/* Create and return pref with given attributes A, HARD_REGNO, and FREQ.  */\n+ira_pref_t\n+ira_create_pref (ira_allocno_t a, int hard_regno, int freq)\n+{\n+  ira_pref_t pref;\n+\n+  pref = (ira_pref_t) pool_alloc (pref_pool);\n+  pref->num = ira_prefs_num;\n+  pref->allocno = a;\n+  pref->hard_regno = hard_regno;\n+  pref->freq = freq;\n+  pref_vec.safe_push (pref);\n+  ira_prefs = pref_vec.address ();\n+  ira_prefs_num = pref_vec.length ();\n+  return pref;\n+}\n+\n+/* Attach a pref PREF to the cooresponding allocno.  */\n+static void\n+add_allocno_pref_to_list (ira_pref_t pref)\n+{\n+  ira_allocno_t a = pref->allocno;\n+\n+  pref->next_pref = ALLOCNO_PREFS (a);\n+  ALLOCNO_PREFS (a) = pref;\n+}\n+\n+/* Create (or update frequency if the pref already exists) the pref of\n+   allocnos A preferring HARD_REGNO with frequency FREQ.  */\n+void\n+ira_add_allocno_pref (ira_allocno_t a, int hard_regno, int freq)\n+{\n+  ira_pref_t pref;\n+\n+  if (freq <= 0)\n+    return;\n+  if ((pref = find_allocno_pref (a, hard_regno)) != NULL)\n+    {\n+      pref->freq += freq;\n+      return;\n+    }\n+  pref = ira_create_pref (a, hard_regno, freq);\n+  ira_assert (a != NULL);\n+  add_allocno_pref_to_list (pref);\n+}\n+\n+/* Print info about PREF into file F.  */\n+static void\n+print_pref (FILE *f, ira_pref_t pref)\n+{\n+  fprintf (f, \"  pref%d:a%d(r%d)<-hr%d@%d\\n\", pref->num,\n+\t   ALLOCNO_NUM (pref->allocno), ALLOCNO_REGNO (pref->allocno),\n+\t   pref->hard_regno, pref->freq);\n+}\n+\n+/* Print info about PREF into stderr.  */\n+void\n+ira_debug_pref (ira_pref_t pref)\n+{\n+  print_pref (stderr, pref);\n+}\n+\n+/* Print info about all prefs into file F.  */\n+static void\n+print_prefs (FILE *f)\n+{\n+  ira_pref_t pref;\n+  ira_pref_iterator pi;\n+\n+  FOR_EACH_PREF (pref, pi)\n+    print_pref (f, pref);\n+}\n+\n+/* Print info about all prefs into stderr.  */\n+void\n+ira_debug_prefs (void)\n+{\n+  print_prefs (stderr);\n+}\n+\n+/* Print info about prefs involving allocno A into file F.  */\n+static void\n+print_allocno_prefs (FILE *f, ira_allocno_t a)\n+{\n+  ira_pref_t pref;\n+\n+  fprintf (f, \" a%d(r%d):\", ALLOCNO_NUM (a), ALLOCNO_REGNO (a));\n+  for (pref = ALLOCNO_PREFS (a); pref != NULL; pref = pref->next_pref)\n+    fprintf (f, \" pref%d:hr%d@%d\", pref->num, pref->hard_regno, pref->freq);\n+  fprintf (f, \"\\n\");\n+}\n+\n+/* Print info about prefs involving allocno A into stderr.  */\n+void\n+ira_debug_allocno_prefs (ira_allocno_t a)\n+{\n+  print_allocno_prefs (stderr, a);\n+}\n+\n+/* The function frees memory allocated for PREF.  */\n+static void\n+finish_pref (ira_pref_t pref)\n+{\n+  ira_prefs[pref->num] = NULL;\n+  pool_free (pref_pool, pref);\n+}\n+\n+/* Remove PREF from the list of allocno prefs and free memory for\n+   it.  */\n+void\n+ira_remove_pref (ira_pref_t pref)\n+{\n+  ira_pref_t cpref, prev;\n+\n+  if (internal_flag_ira_verbose > 1 && ira_dump_file != NULL)\n+    fprintf (ira_dump_file, \" Removing pref%d:hr%d@%d\\n\",\n+\t     pref->num, pref->hard_regno, pref->freq);\n+  for (prev = NULL, cpref = ALLOCNO_PREFS (pref->allocno);\n+       cpref != NULL;\n+       prev = cpref, cpref = cpref->next_pref)\n+    if (cpref == pref)\n+      break;\n+  ira_assert (cpref != NULL);\n+  if (prev == NULL)\n+    ALLOCNO_PREFS (pref->allocno) = pref->next_pref;\n+  else\n+    prev->next_pref = pref->next_pref;\n+  finish_pref (pref);\n+}\n+\n+/* Remove all prefs of allocno A.  */\n+void\n+ira_remove_allocno_prefs (ira_allocno_t a)\n+{\n+  ira_pref_t pref, next_pref;\n+\n+  for (pref = ALLOCNO_PREFS (a); pref != NULL; pref = next_pref)\n+    {\n+      next_pref = pref->next_pref;\n+      finish_pref (pref);\n+    }\n+  ALLOCNO_PREFS (a) = NULL;\n+}\n+\n+/* Free memory allocated for all prefs.  */\n+static void\n+finish_prefs (void)\n+{\n+  ira_pref_t pref;\n+  ira_pref_iterator pi;\n+\n+  FOR_EACH_PREF (pref, pi)\n+    finish_pref (pref);\n+  pref_vec.release ();\n+  free_alloc_pool (pref_pool);\n+}\n+\n+\f\n+\n /* Pools for copies.  */\n static alloc_pool copy_pool;\n \n@@ -1235,8 +1432,8 @@ ira_create_copy (ira_allocno_t first, ira_allocno_t second, int freq,\n }\n \n /* Attach a copy CP to allocnos involved into the copy.  */\n-void\n-ira_add_allocno_copy_to_list (ira_copy_t cp)\n+static void\n+add_allocno_copy_to_list (ira_copy_t cp)\n {\n   ira_allocno_t first = cp->first, second = cp->second;\n \n@@ -1264,8 +1461,8 @@ ira_add_allocno_copy_to_list (ira_copy_t cp)\n \n /* Make a copy CP a canonical copy where number of the\n    first allocno is less than the second one.  */\n-void\n-ira_swap_allocno_copy_ends_if_necessary (ira_copy_t cp)\n+static void\n+swap_allocno_copy_ends_if_necessary (ira_copy_t cp)\n {\n   ira_allocno_t temp;\n   ira_copy_t temp_cp;\n@@ -1305,8 +1502,8 @@ ira_add_allocno_copy (ira_allocno_t first, ira_allocno_t second, int freq,\n   cp = ira_create_copy (first, second, freq, constraint_p, insn,\n \t\t\tloop_tree_node);\n   ira_assert (first != NULL && second != NULL);\n-  ira_add_allocno_copy_to_list (cp);\n-  ira_swap_allocno_copy_ends_if_necessary (cp);\n+  add_allocno_copy_to_list (cp);\n+  swap_allocno_copy_ends_if_necessary (cp);\n   return cp;\n }\n \n@@ -2305,6 +2502,7 @@ remove_unnecessary_allocnos (void)\n \t\t     map to avoid info propagation of subsequent\n \t\t     allocno into this already removed allocno.  */\n \t\t  a_node->regno_allocno_map[regno] = NULL;\n+\t\t  ira_remove_allocno_prefs (a);\n \t\t  finish_allocno (a);\n \t\t}\n \t    }\n@@ -2388,7 +2586,10 @@ remove_low_level_allocnos (void)\n #endif\n \t}\n       else\n-\tfinish_allocno (a);\n+\t{\n+\t  ira_remove_allocno_prefs (a);\n+\t  finish_allocno (a);\n+\t}\n     }\n   if (merged_p)\n     ira_rebuild_start_finish_chains ();\n@@ -3105,6 +3306,7 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t  if (internal_flag_ira_verbose > 4 && ira_dump_file != NULL)\n \t    fprintf (ira_dump_file, \"      Remove a%dr%d\\n\",\n \t\t     ALLOCNO_NUM (a), REGNO (allocno_emit_reg (a)));\n+\t  ira_remove_allocno_prefs (a);\n \t  finish_allocno (a);\n \t  continue;\n \t}\n@@ -3131,8 +3333,8 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n       ira_assert\n \t(ALLOCNO_LOOP_TREE_NODE (cp->first) == ira_loop_tree_root\n \t && ALLOCNO_LOOP_TREE_NODE (cp->second) == ira_loop_tree_root);\n-      ira_add_allocno_copy_to_list (cp);\n-      ira_swap_allocno_copy_ends_if_necessary (cp);\n+      add_allocno_copy_to_list (cp);\n+      swap_allocno_copy_ends_if_necessary (cp);\n     }\n   rebuild_regno_allocno_maps ();\n   if (ira_max_point != ira_max_point_before_emit)\n@@ -3220,6 +3422,7 @@ ira_build (void)\n   df_analyze ();\n   initiate_cost_vectors ();\n   initiate_allocnos ();\n+  initiate_prefs ();\n   initiate_copies ();\n   create_loop_tree_nodes ();\n   form_loop_tree ();\n@@ -3265,6 +3468,8 @@ ira_build (void)\n     }\n   if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n     print_copies (ira_dump_file);\n+  if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n+    print_prefs (ira_dump_file);\n   if (internal_flag_ira_verbose > 0 && ira_dump_file != NULL)\n     {\n       int n, nr, nr_big;\n@@ -3304,6 +3509,7 @@ void\n ira_destroy (void)\n {\n   finish_loop_tree_nodes ();\n+  finish_prefs ();\n   finish_copies ();\n   finish_allocnos ();\n   finish_cost_vectors ();"}, {"sha": "a0a62a2c9ad52148b44ff052e1b83b9d2c3157f3", "filename": "gcc/ira-color.c", "status": "modified", "additions": 223, "deletions": 53, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -88,6 +88,17 @@ struct allocno_hard_regs_node\n   allocno_hard_regs_node_t parent, first, prev, next;\n };\n \n+/* Info about changing hard reg costs of an allocno.  */\n+struct update_cost_record\n+{\n+  /* Hard regno for which we changed the cost.  */\n+  int hard_regno;\n+  /* Divisor used when we changed the cost of HARD_REGNO.  */\n+  int divisor;\n+  /* Next record for given allocno.  */\n+  struct update_cost_record *next;\n+};\n+\n /* To decrease footprint of ira_allocno structure we store all data\n    needed only for coloring in the following structure.  */\n struct allocno_color_data\n@@ -126,6 +137,11 @@ struct allocno_color_data\n   int hard_regs_subnodes_start;\n   /* The length of the previous array. */\n   int hard_regs_subnodes_num;\n+  /* Records about updating allocno hard reg costs from copies.  If\n+     the allocno did not get expected hard register, these records are\n+     used to restore original hard reg costs of allocnos connected to\n+     this allocno by copies.  */\n+  struct update_cost_record *update_cost_records;\n };\n \n /* See above.  */\n@@ -1113,6 +1129,53 @@ setup_profitable_hard_regs (void)\n /* This page contains functions used to choose hard registers for\n    allocnos.  */\n \n+/* Pool for update cost records.  */\n+static alloc_pool update_cost_record_pool;\n+\n+/* Initiate update cost records.  */\n+static void\n+init_update_cost_records (void)\n+{\n+  update_cost_record_pool\n+    = create_alloc_pool (\"update cost records\",\n+\t\t\t sizeof (struct update_cost_record), 100);\n+}\n+\n+/* Return new update cost record with given params.  */\n+static struct update_cost_record *\n+get_update_cost_record (int hard_regno, int divisor,\n+\t\t\tstruct update_cost_record *next)\n+{\n+  struct update_cost_record *record;\n+\n+  record = (struct update_cost_record *) pool_alloc (update_cost_record_pool);\n+  record->hard_regno = hard_regno;\n+  record->divisor = divisor;\n+  record->next = next;\n+  return record;\n+}\n+\n+/* Free memory for all records in LIST.  */\n+static void\n+free_update_cost_record_list (struct update_cost_record *list)\n+{\n+  struct update_cost_record *next;\n+\n+  while (list != NULL)\n+    {\n+      next = list->next;\n+      pool_free (update_cost_record_pool, list);\n+      list = next;\n+    }\n+}\n+\n+/* Free memory allocated for all update cost records.  */\n+static void\n+finish_update_cost_records (void)\n+{\n+  free_alloc_pool (update_cost_record_pool);\n+}\n+\n /* Array whose element value is TRUE if the corresponding hard\n    register was already allocated for an allocno.  */\n static bool allocated_hardreg_p[FIRST_PSEUDO_REGISTER];\n@@ -1129,6 +1192,11 @@ struct update_cost_queue_elem\n      connecting this allocno to the one being allocated.  */\n   int divisor;\n \n+  /* Allocno from which we are chaning costs of connected allocnos.\n+     It is used not go back in graph of allocnos connected by\n+     copies.  */\n+  ira_allocno_t from;\n+\n   /* The next allocno in the queue, or null if this is the last element.  */\n   ira_allocno_t next;\n };\n@@ -1145,11 +1213,11 @@ static struct update_cost_queue_elem *update_cost_queue_tail;\n    Elements are indexed by ALLOCNO_NUM.  */\n static struct update_cost_queue_elem *update_cost_queue_elems;\n \n-/* The current value of update_copy_cost call count.  */\n+/* The current value of update_costs_from_copies call count.  */\n static int update_cost_check;\n \n /* Allocate and initialize data necessary for function\n-   update_copy_costs.  */\n+   update_costs_from_copiess.  */\n static void\n initiate_cost_update (void)\n {\n@@ -1160,13 +1228,15 @@ initiate_cost_update (void)\n     = (struct update_cost_queue_elem *) ira_allocate (size);\n   memset (update_cost_queue_elems, 0, size);\n   update_cost_check = 0;\n+  init_update_cost_records ();\n }\n \n-/* Deallocate data used by function update_copy_costs.  */\n+/* Deallocate data used by function update_costs_from_copies.  */\n static void\n finish_cost_update (void)\n {\n   ira_free (update_cost_queue_elems);\n+  finish_update_cost_records ();\n }\n \n /* When we traverse allocnos to update hard register costs, the cost\n@@ -1182,10 +1252,10 @@ start_update_cost (void)\n   update_cost_queue = NULL;\n }\n \n-/* Add (ALLOCNO, DIVISOR) to the end of update_cost_queue, unless\n+/* Add (ALLOCNO, FROM, DIVISOR) to the end of update_cost_queue, unless\n    ALLOCNO is already in the queue, or has NO_REGS class.  */\n static inline void\n-queue_update_cost (ira_allocno_t allocno, int divisor)\n+queue_update_cost (ira_allocno_t allocno, ira_allocno_t from, int divisor)\n {\n   struct update_cost_queue_elem *elem;\n \n@@ -1194,6 +1264,7 @@ queue_update_cost (ira_allocno_t allocno, int divisor)\n       && ALLOCNO_CLASS (allocno) != NO_REGS)\n     {\n       elem->check = update_cost_check;\n+      elem->from = from;\n       elem->divisor = divisor;\n       elem->next = NULL;\n       if (update_cost_queue == NULL)\n@@ -1204,11 +1275,11 @@ queue_update_cost (ira_allocno_t allocno, int divisor)\n     }\n }\n \n-/* Try to remove the first element from update_cost_queue.  Return false\n-   if the queue was empty, otherwise make (*ALLOCNO, *DIVISOR) describe\n-   the removed element.  */\n+/* Try to remove the first element from update_cost_queue.  Return\n+   false if the queue was empty, otherwise make (*ALLOCNO, *FROM,\n+   *DIVISOR) describe the removed element.  */\n static inline bool\n-get_next_update_cost (ira_allocno_t *allocno, int *divisor)\n+get_next_update_cost (ira_allocno_t *allocno, ira_allocno_t *from, int *divisor)\n {\n   struct update_cost_queue_elem *elem;\n \n@@ -1217,34 +1288,50 @@ get_next_update_cost (ira_allocno_t *allocno, int *divisor)\n \n   *allocno = update_cost_queue;\n   elem = &update_cost_queue_elems[ALLOCNO_NUM (*allocno)];\n+  *from = elem->from;\n   *divisor = elem->divisor;\n   update_cost_queue = elem->next;\n   return true;\n }\n \n-/* Update the cost of allocnos to increase chances to remove some\n-   copies as the result of subsequent assignment.  */\n+/* Increase costs of HARD_REGNO by UPDATE_COST for ALLOCNO.  Return\n+   true if we really modified the cost.  */\n+static bool\n+update_allocno_cost (ira_allocno_t allocno, int hard_regno, int update_cost)\n+{\n+  int i;\n+  enum reg_class aclass = ALLOCNO_CLASS (allocno);\n+\n+  i = ira_class_hard_reg_index[aclass][hard_regno];\n+  if (i < 0)\n+    return false;\n+  ira_allocate_and_set_or_copy_costs\n+    (&ALLOCNO_UPDATED_HARD_REG_COSTS (allocno), aclass,\n+     ALLOCNO_UPDATED_CLASS_COST (allocno),\n+     ALLOCNO_HARD_REG_COSTS (allocno));\n+  ira_allocate_and_set_or_copy_costs\n+    (&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (allocno),\n+     aclass, 0, ALLOCNO_CONFLICT_HARD_REG_COSTS (allocno));\n+  ALLOCNO_UPDATED_HARD_REG_COSTS (allocno)[i] += update_cost;\n+  ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (allocno)[i] += update_cost;\n+  return true;\n+}\n+\n+/* Update (decrease if DECR_P) HARD_REGNO cost of allocnos connected\n+   by copies to ALLOCNO to increase chances to remove some copies as\n+   the result of subsequent assignment.  Record cost updates if\n+   RECORD_P is true.  */\n static void\n-update_copy_costs (ira_allocno_t allocno, bool decr_p)\n+update_costs_from_allocno (ira_allocno_t allocno, int hard_regno,\n+\t\t\t   int divisor, bool decr_p, bool record_p)\n {\n-  int i, cost, update_cost, hard_regno, divisor;\n+  int cost, update_cost;\n   enum machine_mode mode;\n   enum reg_class rclass, aclass;\n-  ira_allocno_t another_allocno;\n+  ira_allocno_t another_allocno, from = NULL;\n   ira_copy_t cp, next_cp;\n \n-  hard_regno = ALLOCNO_HARD_REGNO (allocno);\n-  ira_assert (hard_regno >= 0);\n-\n-  aclass = ALLOCNO_CLASS (allocno);\n-  if (aclass == NO_REGS)\n-    return;\n-  i = ira_class_hard_reg_index[aclass][hard_regno];\n-  ira_assert (i >= 0);\n   rclass = REGNO_REG_CLASS (hard_regno);\n-\n-  start_update_cost ();\n-  divisor = 1;\n   do\n     {\n       mode = ALLOCNO_MODE (allocno);\n@@ -1264,6 +1351,9 @@ update_copy_costs (ira_allocno_t allocno, bool decr_p)\n \t  else\n \t    gcc_unreachable ();\n \n+\t  if (another_allocno == from)\n+\t    continue;\n+\n \t  aclass = ALLOCNO_CLASS (another_allocno);\n \t  if (! TEST_HARD_REG_BIT (reg_class_contents[aclass],\n \t\t\t\t   hard_regno)\n@@ -1280,24 +1370,67 @@ update_copy_costs (ira_allocno_t allocno, bool decr_p)\n \t  if (update_cost == 0)\n \t    continue;\n \n-\t  ira_allocate_and_set_or_copy_costs\n-\t    (&ALLOCNO_UPDATED_HARD_REG_COSTS (another_allocno), aclass,\n-\t     ALLOCNO_UPDATED_CLASS_COST (another_allocno),\n-\t     ALLOCNO_HARD_REG_COSTS (another_allocno));\n-\t  ira_allocate_and_set_or_copy_costs\n-\t    (&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (another_allocno),\n-\t     aclass, 0, ALLOCNO_CONFLICT_HARD_REG_COSTS (another_allocno));\n-\t  i = ira_class_hard_reg_index[aclass][hard_regno];\n-\t  if (i < 0)\n+\t  if (! update_allocno_cost (another_allocno, hard_regno, update_cost))\n \t    continue;\n-\t  ALLOCNO_UPDATED_HARD_REG_COSTS (another_allocno)[i] += update_cost;\n-\t  ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (another_allocno)[i]\n-\t    += update_cost;\n-\n-\t  queue_update_cost (another_allocno, divisor * COST_HOP_DIVISOR);\n+\t  queue_update_cost (another_allocno, allocno, divisor * COST_HOP_DIVISOR);\n+\t  if (record_p && ALLOCNO_COLOR_DATA (another_allocno) != NULL)\n+\t    ALLOCNO_COLOR_DATA (another_allocno)->update_cost_records\n+\t      = get_update_cost_record (hard_regno, divisor,\n+\t\t\t\t\tALLOCNO_COLOR_DATA (another_allocno)\n+\t\t\t\t\t->update_cost_records);\n \t}\n     }\n-  while (get_next_update_cost (&allocno, &divisor));\n+  while (get_next_update_cost (&allocno, &from, &divisor));\n+}\n+\n+/* Decrease preferred ALLOCNO hard register costs and costs of\n+   allocnos connected to ALLOCNO through copy.  */\n+static void\n+update_costs_from_prefs (ira_allocno_t allocno)\n+{\n+  ira_pref_t pref;\n+\n+  start_update_cost ();\n+  for (pref = ALLOCNO_PREFS (allocno); pref != NULL; pref = pref->next_pref)\n+    update_costs_from_allocno (allocno, pref->hard_regno,\n+\t\t\t       COST_HOP_DIVISOR, true, true);\n+}\n+\n+/* Update (decrease if DECR_P) the cost of allocnos connected to\n+   ALLOCNO through copies to increase chances to remove some copies as\n+   the result of subsequent assignment.  ALLOCNO was just assigned to\n+   a hard register.  */\n+static void\n+update_costs_from_copies (ira_allocno_t allocno, bool decr_p)\n+{\n+  int hard_regno;\n+\n+  hard_regno = ALLOCNO_HARD_REGNO (allocno);\n+  ira_assert (hard_regno >= 0 && ALLOCNO_CLASS (allocno) != NO_REGS);\n+  start_update_cost ();\n+  update_costs_from_allocno (allocno, hard_regno, 1, decr_p, true);\n+}\n+\n+/* Restore costs of allocnos connected to ALLOCNO by copies as it was\n+   before updating costs of these allocnos from given allocno.  This\n+   is a wise thing to do as if given allocno did not get an expected\n+   hard reg, using smaller cost of the hard reg for allocnos connected\n+   by copies to given allocno becomes actually misleading.  Free all\n+   update cost records for ALLOCNO as we don't need them anymore.  */\n+static void\n+restore_costs_from_copies (ira_allocno_t allocno)\n+{\n+  struct update_cost_record *records, *curr;\n+\n+  if (ALLOCNO_COLOR_DATA (allocno) == NULL)\n+    return;\n+  records = ALLOCNO_COLOR_DATA (allocno)->update_cost_records;\n+  start_update_cost ();\n+  for (curr = records; curr != NULL; curr = curr->next)\n+    update_costs_from_allocno (allocno, curr->hard_regno,\n+\t\t\t       curr->divisor, true, false);\n+  free_update_cost_record_list (records);\n+  ALLOCNO_COLOR_DATA (allocno)->update_cost_records = NULL;\n }\n \n /* This function updates COSTS (decrease if DECR_P) for hard_registers\n@@ -1313,10 +1446,10 @@ update_conflict_hard_regno_costs (int *costs, enum reg_class aclass,\n   int *conflict_costs;\n   bool cont_p;\n   enum reg_class another_aclass;\n-  ira_allocno_t allocno, another_allocno;\n+  ira_allocno_t allocno, another_allocno, from;\n   ira_copy_t cp, next_cp;\n \n-  while (get_next_update_cost (&allocno, &divisor))\n+  while (get_next_update_cost (&allocno, &from, &divisor))\n     for (cp = ALLOCNO_COPIES (allocno); cp != NULL; cp = next_cp)\n       {\n \tif (cp->first == allocno)\n@@ -1331,6 +1464,10 @@ update_conflict_hard_regno_costs (int *costs, enum reg_class aclass,\n \t  }\n \telse\n \t  gcc_unreachable ();\n+\n+\tif (another_allocno == from)\n+\t  continue;\n+\n  \tanother_aclass = ALLOCNO_CLASS (another_allocno);\n  \tif (! ira_reg_classes_intersect_p[aclass][another_aclass]\n \t    || ALLOCNO_ASSIGNED_P (another_allocno)\n@@ -1374,7 +1511,7 @@ update_conflict_hard_regno_costs (int *costs, enum reg_class aclass,\n \t\t\t   * COST_HOP_DIVISOR\n \t\t\t   * COST_HOP_DIVISOR\n \t\t\t   * COST_HOP_DIVISOR))\n-\t  queue_update_cost (another_allocno, divisor * COST_HOP_DIVISOR);\n+\t  queue_update_cost (another_allocno, allocno, divisor * COST_HOP_DIVISOR);\n       }\n }\n \n@@ -1640,7 +1777,8 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)\n \t\t      continue;\n \t\t    full_costs[j] -= conflict_costs[k];\n \t\t  }\n-\t      queue_update_cost (conflict_a, COST_HOP_DIVISOR);\n+\t      queue_update_cost (conflict_a, NULL, COST_HOP_DIVISOR);\n+\n \t    }\n \t}\n     }\n@@ -1654,7 +1792,7 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)\n   if (! retry_p)\n     {\n       start_update_cost ();\n-      queue_update_cost (a, COST_HOP_DIVISOR);\n+      queue_update_cost (a, NULL,  COST_HOP_DIVISOR);\n       update_conflict_hard_regno_costs (full_costs, aclass, false);\n     }\n   min_cost = min_full_cost = INT_MAX;\n@@ -1711,10 +1849,11 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)\n       for (i = hard_regno_nregs[best_hard_regno][mode] - 1; i >= 0; i--)\n \tallocated_hardreg_p[best_hard_regno + i] = true;\n     }\n+  restore_costs_from_copies (a);\n   ALLOCNO_HARD_REGNO (a) = best_hard_regno;\n   ALLOCNO_ASSIGNED_P (a) = true;\n   if (best_hard_regno >= 0)\n-    update_copy_costs (a, true);\n+    update_costs_from_copies (a, true);\n   ira_assert (ALLOCNO_CLASS (a) == aclass);\n   /* We don't need updated costs anymore: */\n   ira_free_allocno_updated_costs (a);\n@@ -2164,7 +2303,9 @@ pop_allocnos_from_stack (void)\n       else if (ALLOCNO_ASSIGNED_P (allocno))\n \t{\n \t  if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n-\t    fprintf (ira_dump_file, \"spill\\n\");\n+\t    fprintf (ira_dump_file, \"spill%s\\n\",\n+\t\t     ALLOCNO_COLOR_DATA (allocno)->may_be_spilled_p\n+\t\t     ? \"\" : \"!\");\n \t}\n       ALLOCNO_COLOR_DATA (allocno)->in_graph_p = true;\n     }\n@@ -2546,6 +2687,32 @@ color_allocnos (void)\n   ira_allocno_t a;\n \n   setup_profitable_hard_regs ();\n+  EXECUTE_IF_SET_IN_BITMAP (coloring_allocno_bitmap, 0, i, bi)\n+    {\n+      int l, nr;\n+      HARD_REG_SET conflict_hard_regs;\n+      allocno_color_data_t data;\n+      ira_pref_t pref, next_pref;\n+\n+      a = ira_allocnos[i];\n+      nr = ALLOCNO_NUM_OBJECTS (a);\n+      CLEAR_HARD_REG_SET (conflict_hard_regs);\n+      for (l = 0; l < nr; l++)\n+\t{\n+\t  ira_object_t obj = ALLOCNO_OBJECT (a, l);\n+\t  IOR_HARD_REG_SET (conflict_hard_regs,\n+\t\t\t    OBJECT_CONFLICT_HARD_REGS (obj));\n+\t}\n+      data = ALLOCNO_COLOR_DATA (a);\n+      for (pref = ALLOCNO_PREFS (a); pref != NULL; pref = next_pref)\n+\t{\n+\t  next_pref = pref->next_pref;\n+\t  if (! ira_hard_reg_in_set_p (pref->hard_regno,\n+\t\t\t\t       ALLOCNO_MODE (a),\n+\t\t\t\t       data->profitable_hard_regs))\n+\t    ira_remove_pref (pref);\n+\t}\n+    }\n   if (flag_ira_algorithm == IRA_ALGORITHM_PRIORITY)\n     {\n       n = 0;\n@@ -2605,7 +2772,10 @@ color_allocnos (void)\n \t{\n \t  a = ira_allocnos[i];\n \t  if (ALLOCNO_CLASS (a) != NO_REGS && ! empty_profitable_hard_regs (a))\n-\t    ALLOCNO_COLOR_DATA (a)->in_graph_p = true;\n+\t    {\n+\t      ALLOCNO_COLOR_DATA (a)->in_graph_p = true;\n+\t      update_costs_from_prefs (a);\n+\t    }\n \t  else\n \t    {\n \t      ALLOCNO_HARD_REGNO (a) = -1;\n@@ -2772,7 +2942,7 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t    ALLOCNO_HARD_REGNO (subloop_allocno) = hard_regno;\n \t    ALLOCNO_ASSIGNED_P (subloop_allocno) = true;\n \t    if (hard_regno >= 0)\n-\t      update_copy_costs (subloop_allocno, true);\n+\t      update_costs_from_copies (subloop_allocno, true);\n \t    /* We don't need updated costs anymore: */\n \t    ira_free_allocno_updated_costs (subloop_allocno);\n \t  }\n@@ -2816,7 +2986,7 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t\t  ALLOCNO_HARD_REGNO (subloop_allocno) = hard_regno;\n \t\t  ALLOCNO_ASSIGNED_P (subloop_allocno) = true;\n \t\t  if (hard_regno >= 0)\n-\t\t    update_copy_costs (subloop_allocno, true);\n+\t\t    update_costs_from_copies (subloop_allocno, true);\n \t\t  /* We don't need updated costs anymore: */\n \t\t  ira_free_allocno_updated_costs (subloop_allocno);\n \t\t}\n@@ -2832,7 +3002,7 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t\t  ALLOCNO_HARD_REGNO (subloop_allocno) = hard_regno;\n \t\t  ALLOCNO_ASSIGNED_P (subloop_allocno) = true;\n \t\t  if (hard_regno >= 0)\n-\t\t    update_copy_costs (subloop_allocno, true);\n+\t\t    update_costs_from_copies (subloop_allocno, true);\n \t\t  /* We don't need updated costs anymore: */\n \t\t  ira_free_allocno_updated_costs (subloop_allocno);\n \t\t}\n@@ -3813,7 +3983,7 @@ ira_mark_allocation_change (int regno)\n \t       ? ALLOCNO_CLASS_COST (a)\n \t       : ALLOCNO_HARD_REG_COSTS (a)\n \t         [ira_class_hard_reg_index[aclass][old_hard_regno]]);\n-      update_copy_costs (a, false);\n+      update_costs_from_copies (a, false);\n     }\n   ira_overall_cost -= cost;\n   ALLOCNO_HARD_REGNO (a) = hard_regno;\n@@ -3828,7 +3998,7 @@ ira_mark_allocation_change (int regno)\n \t       ? ALLOCNO_CLASS_COST (a)\n \t       : ALLOCNO_HARD_REG_COSTS (a)\n \t         [ira_class_hard_reg_index[aclass][hard_regno]]);\n-      update_copy_costs (a, true);\n+      update_costs_from_copies (a, true);\n     }\n   else\n     /* Reload changed class of the allocno.  */"}, {"sha": "ba0e4e5fad3745911cc10eeed0b25179a255eb99", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 18, "deletions": 163, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -208,149 +208,6 @@ allocnos_conflict_for_copy_p (ira_allocno_t a1, ira_allocno_t a2)\n   return OBJECTS_CONFLICT_P (obj1, obj2);\n }\n \n-/* Return TRUE if the operand constraint STR is commutative.  */\n-static bool\n-commutative_constraint_p (const char *str)\n-{\n-  int curr_alt, c;\n-  bool ignore_p;\n-\n-  for (ignore_p = false, curr_alt = 0;;)\n-    {\n-      c = *str;\n-      if (c == '\\0')\n-\tbreak;\n-      str += CONSTRAINT_LEN (c, str);\n-      if (c == '#' || !recog_data.alternative_enabled_p[curr_alt])\n-\tignore_p = true;\n-      else if (c == ',')\n-\t{\n-\t  curr_alt++;\n-\t  ignore_p = false;\n-\t}\n-      else if (! ignore_p)\n-\t{\n-\t  /* Usually `%' is the first constraint character but the\n-\t     documentation does not require this.  */\n-\t  if (c == '%')\n-\t    return true;\n-\t}\n-    }\n-  return false;\n-}\n-\n-/* Return the number of the operand which should be the same in any\n-   case as operand with number OP_NUM (or negative value if there is\n-   no such operand).  If USE_COMMUT_OP_P is TRUE, the function makes\n-   temporarily commutative operand exchange before this.  The function\n-   takes only really possible alternatives into consideration.  */\n-static int\n-get_dup_num (int op_num, bool use_commut_op_p)\n-{\n-  int curr_alt, c, original, dup;\n-  bool ignore_p, commut_op_used_p;\n-  const char *str;\n-  rtx op;\n-\n-  if (op_num < 0 || recog_data.n_alternatives == 0)\n-    return -1;\n-  op = recog_data.operand[op_num];\n-  commut_op_used_p = true;\n-  if (use_commut_op_p)\n-    {\n-      if (commutative_constraint_p (recog_data.constraints[op_num]))\n-\top_num++;\n-      else if (op_num > 0 && commutative_constraint_p (recog_data.constraints\n-\t\t\t\t\t\t       [op_num - 1]))\n-\top_num--;\n-      else\n-\tcommut_op_used_p = false;\n-    }\n-  str = recog_data.constraints[op_num];\n-  for (ignore_p = false, original = -1, curr_alt = 0;;)\n-    {\n-      c = *str;\n-      if (c == '\\0')\n-\tbreak;\n-      if (c == '#' || !recog_data.alternative_enabled_p[curr_alt])\n-\tignore_p = true;\n-      else if (c == ',')\n-\t{\n-\t  curr_alt++;\n-\t  ignore_p = false;\n-\t}\n-      else if (! ignore_p)\n-\tswitch (c)\n-\t  {\n-\t  case 'X':\n-\t    return -1;\n-\n-\t  case 'm':\n-\t  case 'o':\n-\t    /* Accept a register which might be placed in memory.  */\n-\t    return -1;\n-\t    break;\n-\n-\t  case 'V':\n-\t  case '<':\n-\t  case '>':\n-\t    break;\n-\n-\t  case 'p':\n-\t    if (address_operand (op, VOIDmode))\n-\t      return -1;\n-\t    break;\n-\n-\t  case 'g':\n-\t    return -1;\n-\n-\t  case 'r':\n-\t  case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n-\t  case 'h': case 'j': case 'k': case 'l':\n-\t  case 'q': case 't': case 'u':\n-\t  case 'v': case 'w': case 'x': case 'y': case 'z':\n-\t  case 'A': case 'B': case 'C': case 'D':\n-\t  case 'Q': case 'R': case 'S': case 'T': case 'U':\n-\t  case 'W': case 'Y': case 'Z':\n-\t    {\n-\t      enum reg_class cl;\n-\n-\t      cl = (c == 'r'\n-\t\t    ? GENERAL_REGS : REG_CLASS_FROM_CONSTRAINT (c, str));\n-\t      if (cl != NO_REGS)\n-\t\treturn -1;\n-#ifdef EXTRA_CONSTRAINT_STR\n-\t      else if (EXTRA_CONSTRAINT_STR (op, c, str))\n-\t\treturn -1;\n-#endif\n-\t      break;\n-\t    }\n-\n-\t  case '0': case '1': case '2': case '3': case '4':\n-\t  case '5': case '6': case '7': case '8': case '9':\n-\t    if (original != -1 && original != c)\n-\t      return -1;\n-\t    original = c;\n-\t    break;\n-\t  }\n-      str += CONSTRAINT_LEN (c, str);\n-    }\n-  if (original == -1)\n-    return -1;\n-  dup = original - '0';\n-  if (use_commut_op_p)\n-    {\n-      if (commutative_constraint_p (recog_data.constraints[dup]))\n-\tdup++;\n-      else if (dup > 0\n-\t       && commutative_constraint_p (recog_data.constraints[dup -1]))\n-\tdup--;\n-      else if (! commut_op_used_p)\n-\treturn -1;\n-    }\n-  return dup;\n-}\n-\n /* Check that X is REG or SUBREG of REG.  */\n #define REG_SUBREG_P(x)\t\t\t\t\t\t\t\\\n    (REG_P (x) || (GET_CODE (x) == SUBREG && REG_P (SUBREG_REG (x))))\n@@ -461,6 +318,7 @@ process_regs_for_copy (rtx reg1, rtx reg2, bool constraint_p,\n       ALLOCNO_CONFLICT_HARD_REG_COSTS (a)[index] -= cost;\n       if (ALLOCNO_HARD_REG_COSTS (a)[index] < ALLOCNO_CLASS_COST (a))\n \tALLOCNO_CLASS_COST (a) = ALLOCNO_HARD_REG_COSTS (a)[index];\n+      ira_add_allocno_pref (a, allocno_preferenced_hard_regno, freq);\n       a = ira_parent_or_cap_allocno (a);\n     }\n   while (a != NULL);\n@@ -498,9 +356,9 @@ static void\n add_insn_allocno_copies (rtx insn)\n {\n   rtx set, operand, dup;\n-  const char *str;\n-  bool commut_p, bound_p[MAX_RECOG_OPERANDS];\n-  int i, j, n, freq;\n+  bool bound_p[MAX_RECOG_OPERANDS];\n+  int i, n, freq;\n+  HARD_REG_SET alts;\n \n   freq = REG_FREQ_FROM_BB (BLOCK_FOR_INSN (insn));\n   if (freq == 0)\n@@ -513,37 +371,34 @@ add_insn_allocno_copies (rtx insn)\n \t\t\t? SET_SRC (set)\n \t\t\t: SUBREG_REG (SET_SRC (set))) != NULL_RTX)\n     {\n-      process_regs_for_copy (SET_DEST (set), SET_SRC (set),\n+      process_regs_for_copy (SET_SRC (set), SET_DEST (set),\n \t\t\t     false, insn, freq);\n       return;\n     }\n   /* Fast check of possibility of constraint or shuffle copies.  If\n      there are no dead registers, there will be no such copies.  */\n   if (! find_reg_note (insn, REG_DEAD, NULL_RTX))\n     return;\n-  extract_insn (insn);\n+  ira_setup_alts (insn, alts);\n   for (i = 0; i < recog_data.n_operands; i++)\n     bound_p[i] = false;\n   for (i = 0; i < recog_data.n_operands; i++)\n     {\n       operand = recog_data.operand[i];\n       if (! REG_SUBREG_P (operand))\n \tcontinue;\n-      str = recog_data.constraints[i];\n-      while (*str == ' ' || *str == '\\t')\n-\tstr++;\n-      for (j = 0, commut_p = false; j < 2; j++, commut_p = true)\n-\tif ((n = get_dup_num (i, commut_p)) >= 0)\n-\t  {\n-\t    bound_p[n] = true;\n-\t    dup = recog_data.operand[n];\n-\t    if (REG_SUBREG_P (dup)\n-\t\t&& find_reg_note (insn, REG_DEAD,\n-\t\t\t\t  REG_P (operand)\n-\t\t\t\t  ? operand\n-\t\t\t\t  : SUBREG_REG (operand)) != NULL_RTX)\n-\t      process_regs_for_copy (operand, dup, true, NULL_RTX, freq);\n-\t  }\n+      if ((n = ira_get_dup_out_num (i, alts)) >= 0)\n+\t{\n+\t  bound_p[n] = true;\n+\t  dup = recog_data.operand[n];\n+\t  if (REG_SUBREG_P (dup)\n+\t      && find_reg_note (insn, REG_DEAD,\n+\t\t\t\tREG_P (operand)\n+\t\t\t\t? operand\n+\t\t\t\t: SUBREG_REG (operand)) != NULL_RTX)\n+\t    process_regs_for_copy (operand, dup, true, NULL_RTX,\n+\t\t\t\t   freq);\n+\t}\n     }\n   for (i = 0; i < recog_data.n_operands; i++)\n     {"}, {"sha": "424b99c2c53784a4c04e3de63fcbda1d5a48971e", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 129, "deletions": 82, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -405,7 +405,6 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n {\n   int alt;\n   int i, j, k;\n-  rtx set;\n   int insn_allows_mem[MAX_RECOG_OPERANDS];\n \n   for (i = 0; i < n_ops; i++)\n@@ -914,60 +913,6 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t  ALLOCNO_BAD_SPILL_P (a) = true;\n       }\n \n-  /* If this insn is a single set copying operand 1 to operand 0 and\n-     one operand is an allocno with the other a hard reg or an allocno\n-     that prefers a hard register that is in its own register class\n-     then we may want to adjust the cost of that register class to -1.\n-\n-     Avoid the adjustment if the source does not die to avoid\n-     stressing of register allocator by preferrencing two colliding\n-     registers into single class.\n-\n-     Also avoid the adjustment if a copy between hard registers of the\n-     class is expensive (ten times the cost of a default copy is\n-     considered arbitrarily expensive).  This avoids losing when the\n-     preferred class is very expensive as the source of a copy\n-     instruction.  */\n-  if ((set = single_set (insn)) != 0\n-      && ops[0] == SET_DEST (set) && ops[1] == SET_SRC (set)\n-      && REG_P (ops[0]) && REG_P (ops[1])\n-      && find_regno_note (insn, REG_DEAD, REGNO (ops[1])))\n-    for (i = 0; i <= 1; i++)\n-      if (REGNO (ops[i]) >= FIRST_PSEUDO_REGISTER\n-\t  && REGNO (ops[!i]) < FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  unsigned int regno = REGNO (ops[i]);\n-\t  unsigned int other_regno = REGNO (ops[!i]);\n-\t  enum machine_mode mode = GET_MODE (ops[!i]);\n-\t  cost_classes_t cost_classes_ptr = regno_cost_classes[regno];\n-\t  enum reg_class *cost_classes = cost_classes_ptr->classes;\n-\t  reg_class_t rclass;\n-\t  int nr;\n-\n-\t  for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n-\t    {\n-\t      rclass = cost_classes[k];\n-\t      if (TEST_HARD_REG_BIT (reg_class_contents[rclass], other_regno)\n-\t\t  && (reg_class_size[(int) rclass]\n-\t\t      == ira_reg_class_max_nregs [(int) rclass][(int) mode]))\n-\t\t{\n-\t\t  if (reg_class_size[rclass] == 1)\n-\t\t    op_costs[i]->cost[k] = -frequency;\n-\t\t  else\n-\t\t    {\n-\t\t      for (nr = 0;\n-\t\t\t   nr < hard_regno_nregs[other_regno][mode];\n-\t\t\t   nr++)\n-\t\t\tif (! TEST_HARD_REG_BIT (reg_class_contents[rclass],\n-\t\t\t\t\t\t other_regno + nr))\n-\t\t\t  break;\n-\t\t      \n-\t\t      if (nr == hard_regno_nregs[other_regno][mode])\n-\t\t\top_costs[i]->cost[k] = -frequency;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n }\n \n \f\n@@ -1204,6 +1149,8 @@ record_operand_costs (rtx insn, enum reg_class *pref)\n {\n   const char *constraints[MAX_RECOG_OPERANDS];\n   enum machine_mode modes[MAX_RECOG_OPERANDS];\n+  rtx ops[MAX_RECOG_OPERANDS];\n+  rtx set;\n   int i;\n \n   for (i = 0; i < recog_data.n_operands; i++)\n@@ -1221,6 +1168,7 @@ record_operand_costs (rtx insn, enum reg_class *pref)\n     {\n       memcpy (op_costs[i], init_cost, struct_costs_size);\n \n+      ops[i] = recog_data.operand[i];\n       if (GET_CODE (recog_data.operand[i]) == SUBREG)\n \trecog_data.operand[i] = SUBREG_REG (recog_data.operand[i]);\n \n@@ -1260,6 +1208,77 @@ record_operand_costs (rtx insn, enum reg_class *pref)\n   record_reg_classes (recog_data.n_alternatives, recog_data.n_operands,\n \t\t      recog_data.operand, modes,\n \t\t      constraints, insn, pref);\n+\n+  /* If this insn is a single set copying operand 1 to operand 0 and\n+     one operand is an allocno with the other a hard reg or an allocno\n+     that prefers a hard register that is in its own register class\n+     then we may want to adjust the cost of that register class to -1.\n+\n+     Avoid the adjustment if the source does not die to avoid\n+     stressing of register allocator by preferrencing two colliding\n+     registers into single class.\n+\n+     Also avoid the adjustment if a copy between hard registers of the\n+     class is expensive (ten times the cost of a default copy is\n+     considered arbitrarily expensive).  This avoids losing when the\n+     preferred class is very expensive as the source of a copy\n+     instruction.  */\n+  if ((set = single_set (insn)) != NULL_RTX\n+      && ops[0] == SET_DEST (set) && ops[1] == SET_SRC (set))\n+    {\n+      int regno, other_regno;\n+      rtx dest = SET_DEST (set);\n+      rtx src = SET_SRC (set);\n+\n+      dest = SET_DEST (set);\n+      src = SET_SRC (set);\n+      if (GET_CODE (dest) == SUBREG\n+\t  && (GET_MODE_SIZE (GET_MODE (dest))\n+\t      == GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest)))))\n+\tdest = SUBREG_REG (dest);\n+      if (GET_CODE (src) == SUBREG\n+\t  && (GET_MODE_SIZE (GET_MODE (src))\n+\t      == GET_MODE_SIZE (GET_MODE (SUBREG_REG (src)))))\n+\tsrc = SUBREG_REG (src);\n+      if (REG_P (src) && REG_P (dest)\n+\t  && find_regno_note (insn, REG_DEAD, REGNO (src))\n+\t  && (((regno = REGNO (src)) >= FIRST_PSEUDO_REGISTER\n+\t       && (other_regno = REGNO (dest)) < FIRST_PSEUDO_REGISTER)\n+\t      || ((regno = REGNO (dest)) >= FIRST_PSEUDO_REGISTER\n+\t\t  && (other_regno = REGNO (src)) < FIRST_PSEUDO_REGISTER)))\n+\t{\n+\t  enum machine_mode mode = GET_MODE (src);\n+\t  cost_classes_t cost_classes_ptr = regno_cost_classes[regno];\n+\t  enum reg_class *cost_classes = cost_classes_ptr->classes;\n+\t  reg_class_t rclass;\n+\t  int k, nr;\n+\n+\t  i = regno == (int) REGNO (src) ? 1 : 0;\n+\t  for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n+\t    {\n+\t      rclass = cost_classes[k];\n+\t      if (TEST_HARD_REG_BIT (reg_class_contents[rclass], other_regno)\n+\t\t  && (reg_class_size[(int) rclass]\n+\t\t      == ira_reg_class_max_nregs [(int) rclass][(int) mode]))\n+\t\t{\n+\t\t  if (reg_class_size[rclass] == 1)\n+\t\t    op_costs[i]->cost[k] = -frequency;\n+\t\t  else\n+\t\t    {\n+\t\t      for (nr = 0;\n+\t\t\t   nr < hard_regno_nregs[other_regno][mode];\n+\t\t\t   nr++)\n+\t\t\tif (! TEST_HARD_REG_BIT (reg_class_contents[rclass],\n+\t\t\t\t\t\t other_regno + nr))\n+\t\t\t  break;\n+\t\t      \n+\t\t      if (nr == hard_regno_nregs[other_regno][mode])\n+\t\t\top_costs[i]->cost[k] = -frequency;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n }\n \n \f\n@@ -1741,14 +1760,15 @@ find_costs_and_classes (FILE *dump_file)\n \t       a != NULL;\n \t       a = ALLOCNO_NEXT_REGNO_ALLOCNO (a))\n \t    {\n-\t      a_num = ALLOCNO_NUM (a);\n-\t      if (regno_aclass[i] == NO_REGS)\n+\t      enum reg_class aclass = regno_aclass[i];\n+\t      int a_num = ALLOCNO_NUM (a);\n+\t      int *total_a_costs = COSTS (total_allocno_costs, a_num)->cost;\n+\t      int *a_costs = COSTS (costs, a_num)->cost;\n+\t\n+\t      if (aclass == NO_REGS)\n \t\tbest = NO_REGS;\n \t      else\n \t\t{\n-\t\t  int *total_a_costs = COSTS (total_allocno_costs, a_num)->cost;\n-\t\t  int *a_costs = COSTS (costs, a_num)->cost;\n-\t\t  \n \t\t  /* Finding best class which is subset of the common\n \t\t     class.  */\n \t\t  best_cost = (1 << (HOST_BITS_PER_INT - 2)) - 1;\n@@ -1757,7 +1777,7 @@ find_costs_and_classes (FILE *dump_file)\n \t\t  for (k = 0; k < cost_classes_ptr->num; k++)\n \t\t    {\n \t\t      rclass = cost_classes[k];\n-\t\t      if (! ira_class_subset_p[rclass][regno_aclass[i]])\n+\t\t      if (! ira_class_subset_p[rclass][aclass])\n \t\t\tcontinue;\n \t\t      /* Ignore classes that are too small or invalid\n \t\t\t for this operand.  */\n@@ -1792,9 +1812,25 @@ find_costs_and_classes (FILE *dump_file)\n \t\t\t     ALLOCNO_LOOP_TREE_NODE (a)->loop_num);\n \t\t  fprintf (dump_file, \") best %s, allocno %s\\n\",\n \t\t\t   reg_class_names[best],\n-\t\t\t   reg_class_names[regno_aclass[i]]);\n+\t\t\t   reg_class_names[aclass]);\n \t\t}\n \t      pref[a_num] = best;\n+\t      if (pass == flag_expensive_optimizations && best != aclass\n+\t\t  && ira_class_hard_regs_num[best] > 0\n+\t\t  && (ira_reg_class_max_nregs[best][ALLOCNO_MODE (a)]\n+\t\t      >= ira_class_hard_regs_num[best]))\n+\t\t{\n+\t\t  int ind = cost_classes_ptr->index[aclass];\n+\n+\t\t  ira_assert (ind >= 0);\n+\t\t  ira_add_allocno_pref (a, ira_class_hard_regs[best][0],\n+\t\t\t\t\t(a_costs[ind] - ALLOCNO_CLASS_COST (a))\n+\t\t\t\t\t/ (ira_register_move_cost\n+\t\t\t\t\t   [ALLOCNO_MODE (a)][best][aclass]));\n+\t\t  for (k = 0; k < cost_classes_ptr->num; k++)\n+\t\t    if (ira_class_subset_p[cost_classes[k]][best])\n+\t\t      a_costs[k] = a_costs[ind];\n+\t\t}\n \t    }\n \t}\n       \n@@ -1820,11 +1856,11 @@ find_costs_and_classes (FILE *dump_file)\n static void\n process_bb_node_for_hard_reg_moves (ira_loop_tree_node_t loop_tree_node)\n {\n-  int i, freq, cost, src_regno, dst_regno, hard_regno;\n+  int i, freq, src_regno, dst_regno, hard_regno, a_regno;\n   bool to_p;\n-  ira_allocno_t a;\n-  enum reg_class rclass, hard_reg_class;\n-  enum machine_mode mode;\n+  ira_allocno_t a, curr_a;\n+  ira_loop_tree_node_t curr_loop_tree_node;\n+  enum reg_class rclass;\n   basic_block bb;\n   rtx insn, set, src, dst;\n \n@@ -1851,15 +1887,15 @@ process_bb_node_for_hard_reg_moves (ira_loop_tree_node_t loop_tree_node)\n \t  && src_regno < FIRST_PSEUDO_REGISTER)\n \t{\n \t  hard_regno = src_regno;\n-\t  to_p = true;\n \t  a = ira_curr_regno_allocno_map[dst_regno];\n+\t  to_p = true;\n \t}\n       else if (src_regno >= FIRST_PSEUDO_REGISTER\n \t       && dst_regno < FIRST_PSEUDO_REGISTER)\n \t{\n \t  hard_regno = dst_regno;\n-\t  to_p = false;\n \t  a = ira_curr_regno_allocno_map[src_regno];\n+\t  to_p = false;\n \t}\n       else\n \tcontinue;\n@@ -1869,20 +1905,31 @@ process_bb_node_for_hard_reg_moves (ira_loop_tree_node_t loop_tree_node)\n       i = ira_class_hard_reg_index[rclass][hard_regno];\n       if (i < 0)\n \tcontinue;\n-      mode = ALLOCNO_MODE (a);\n-      hard_reg_class = REGNO_REG_CLASS (hard_regno);\n-      ira_init_register_move_cost_if_necessary (mode);\n-      cost\n-\t= (to_p ? ira_register_move_cost[mode][hard_reg_class][rclass]\n-\t   : ira_register_move_cost[mode][rclass][hard_reg_class]) * freq;\n-      ira_allocate_and_set_costs (&ALLOCNO_HARD_REG_COSTS (a), rclass,\n-\t\t\t\t  ALLOCNO_CLASS_COST (a));\n-      ira_allocate_and_set_costs (&ALLOCNO_CONFLICT_HARD_REG_COSTS (a),\n-\t\t\t\t  rclass, 0);\n-      ALLOCNO_HARD_REG_COSTS (a)[i] -= cost;\n-      ALLOCNO_CONFLICT_HARD_REG_COSTS (a)[i] -= cost;\n-      ALLOCNO_CLASS_COST (a) = MIN (ALLOCNO_CLASS_COST (a),\n-\t\t\t\t    ALLOCNO_HARD_REG_COSTS (a)[i]);\n+      a_regno = ALLOCNO_REGNO (a);\n+      for (curr_loop_tree_node = ALLOCNO_LOOP_TREE_NODE (a);\n+\t   curr_loop_tree_node != NULL;\n+\t   curr_loop_tree_node = curr_loop_tree_node->parent)\n+\tif ((curr_a = curr_loop_tree_node->regno_allocno_map[a_regno]) != NULL)\n+\t  ira_add_allocno_pref (curr_a, hard_regno, freq);\n+      {\n+\tint cost;\n+\tenum reg_class hard_reg_class;\n+\tenum machine_mode mode;\n+\t\n+\tmode = ALLOCNO_MODE (a);\n+\thard_reg_class = REGNO_REG_CLASS (hard_regno);\n+\tira_init_register_move_cost_if_necessary (mode);\n+\tcost = (to_p ? ira_register_move_cost[mode][hard_reg_class][rclass]\n+\t\t: ira_register_move_cost[mode][rclass][hard_reg_class]) * freq;\n+\tira_allocate_and_set_costs (&ALLOCNO_HARD_REG_COSTS (a), rclass,\n+\t\t\t\t    ALLOCNO_CLASS_COST (a));\n+\tira_allocate_and_set_costs (&ALLOCNO_CONFLICT_HARD_REG_COSTS (a),\n+\t\t\t\t    rclass, 0);\n+\tALLOCNO_HARD_REG_COSTS (a)[i] -= cost;\n+\tALLOCNO_CONFLICT_HARD_REG_COSTS (a)[i] -= cost;\n+\tALLOCNO_CLASS_COST (a) = MIN (ALLOCNO_CLASS_COST (a),\n+\t\t\t\t      ALLOCNO_HARD_REG_COSTS (a)[i]);\n+      }\n     }\n }\n "}, {"sha": "b9b21ba27af32d9fce8b0e0b42917abc50c8a81e", "filename": "gcc/ira-int.h", "status": "modified", "additions": 79, "deletions": 2, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -57,6 +57,7 @@ extern FILE *ira_dump_file;\n    allocnos.  */\n typedef struct live_range *live_range_t;\n typedef struct ira_allocno *ira_allocno_t;\n+typedef struct ira_allocno_pref *ira_pref_t;\n typedef struct ira_allocno_copy *ira_copy_t;\n typedef struct ira_object *ira_object_t;\n \n@@ -346,6 +347,8 @@ struct ira_allocno\n      register class living at the point than number of hard-registers\n      of the class available for the allocation.  */\n   int excess_pressure_points_num;\n+  /* Allocno hard reg preferences.  */\n+  ira_pref_t allocno_prefs;\n   /* Copies to other non-conflicting allocnos.  The copies can\n      represent move insn or potential move insn usually because of two\n      operand insn constraints.  */\n@@ -426,6 +429,7 @@ struct ira_allocno\n #define ALLOCNO_BAD_SPILL_P(A) ((A)->bad_spill_p)\n #define ALLOCNO_ASSIGNED_P(A) ((A)->assigned_p)\n #define ALLOCNO_MODE(A) ((A)->mode)\n+#define ALLOCNO_PREFS(A) ((A)->allocno_prefs)\n #define ALLOCNO_COPIES(A) ((A)->allocno_copies)\n #define ALLOCNO_HARD_REG_COSTS(A) ((A)->hard_reg_costs)\n #define ALLOCNO_UPDATED_HARD_REG_COSTS(A) ((A)->updated_hard_reg_costs)\n@@ -516,6 +520,33 @@ extern ira_object_t *ira_object_id_map;\n /* The size of the previous array.  */\n extern int ira_objects_num;\n \n+/* The following structure represents a hard register prefererence of\n+   allocno.  The preference represent move insns or potential move\n+   insns usually because of two operand insn constraints.  One move\n+   operand is a hard register.  */\n+struct ira_allocno_pref\n+{\n+  /* The unique order number of the preference node starting with 0.  */\n+  int num;\n+  /* Preferred hard register.  */\n+  int hard_regno;\n+  /* Accumulated execution frequency of insns from which the\n+     preference created.  */\n+  int freq;\n+  /* Given allocno.  */\n+  ira_allocno_t allocno;\n+  /* All prefernces with the same allocno are linked by the following\n+     member.  */\n+  ira_pref_t next_pref;\n+};\n+\n+/* Array of references to all allocno preferences.  The order number\n+   of the preference corresponds to the index in the array.  */\n+extern ira_pref_t *ira_prefs;\n+\n+/* Size of the previous array.  */\n+extern int ira_prefs_num;\n+\n /* The following structure represents a copy of two allocnos.  The\n    copies represent move insns or potential move insns usually because\n    of two operand insn constraints.  To remove register shuffle, we\n@@ -925,13 +956,19 @@ extern void ira_print_disposition (FILE *);\n extern void ira_debug_disposition (void);\n extern void ira_debug_allocno_classes (void);\n extern void ira_init_register_move_cost (enum machine_mode);\n+extern void ira_setup_alts (rtx insn, HARD_REG_SET &alts);\n+extern int ira_get_dup_out_num (int op_num, HARD_REG_SET &alts);\n \n /* ira-build.c */\n \n /* The current loop tree node and its regno allocno map.  */\n extern ira_loop_tree_node_t ira_curr_loop_tree_node;\n extern ira_allocno_t *ira_curr_regno_allocno_map;\n \n+extern void ira_debug_pref (ira_pref_t);\n+extern void ira_debug_prefs (void);\n+extern void ira_debug_allocno_prefs (ira_allocno_t);\n+\n extern void ira_debug_copy (ira_copy_t);\n extern void debug (ira_allocno_copy &ref);\n extern void debug (ira_allocno_copy *ptr);\n@@ -963,10 +1000,12 @@ extern bool ira_live_ranges_intersect_p (live_range_t, live_range_t);\n extern void ira_finish_live_range (live_range_t);\n extern void ira_finish_live_range_list (live_range_t);\n extern void ira_free_allocno_updated_costs (ira_allocno_t);\n+extern ira_pref_t ira_create_pref (ira_allocno_t, int, int);\n+extern void ira_add_allocno_pref (ira_allocno_t, int, int);\n+extern void ira_remove_pref (ira_pref_t);\n+extern void ira_remove_allocno_prefs (ira_allocno_t);\n extern ira_copy_t ira_create_copy (ira_allocno_t, ira_allocno_t,\n \t\t\t\t   int, bool, rtx, ira_loop_tree_node_t);\n-extern void ira_add_allocno_copy_to_list (ira_copy_t);\n-extern void ira_swap_allocno_copy_ends_if_necessary (ira_copy_t);\n extern ira_copy_t ira_add_allocno_copy (ira_allocno_t, ira_allocno_t, int,\n \t\t\t\t\tbool, rtx, ira_loop_tree_node_t);\n \n@@ -1151,6 +1190,44 @@ ira_allocno_object_iter_cond (ira_allocno_object_iterator *i, ira_allocno_t a,\n        ira_allocno_object_iter_cond (&(ITER), (A), &(O));)\n \f\n \n+/* The iterator for prefs.  */\n+typedef struct {\n+  /* The number of the current element in IRA_PREFS.  */\n+  int n;\n+} ira_pref_iterator;\n+\n+/* Initialize the iterator I.  */\n+static inline void\n+ira_pref_iter_init (ira_pref_iterator *i)\n+{\n+  i->n = 0;\n+}\n+\n+/* Return TRUE if we have more prefs to visit, in which case *PREF is\n+   set to the pref to be visited.  Otherwise, return FALSE.  */\n+static inline bool\n+ira_pref_iter_cond (ira_pref_iterator *i, ira_pref_t *pref)\n+{\n+  int n;\n+\n+  for (n = i->n; n < ira_prefs_num; n++)\n+    if (ira_prefs[n] != NULL)\n+      {\n+\t*pref = ira_prefs[n];\n+\ti->n = n + 1;\n+\treturn true;\n+      }\n+  return false;\n+}\n+\n+/* Loop over all prefs.  In each iteration, P is set to the next\n+   pref.  ITER is an instance of ira_pref_iterator used to iterate\n+   the prefs.  */\n+#define FOR_EACH_PREF(P, ITER)\t\t\t\t\\\n+  for (ira_pref_iter_init (&(ITER));\t\t\t\\\n+       ira_pref_iter_cond (&(ITER), &(P));)\n+\f\n+\n /* The iterator for copies.  */\n typedef struct {\n   /* The number of the current element in IRA_COPIES.  */"}, {"sha": "830ead1d89c86de8d33f59d55f6ed07d589fdde6", "filename": "gcc/ira.c", "status": "modified", "additions": 523, "deletions": 1, "changes": 524, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -1761,6 +1761,527 @@ setup_prohibited_mode_move_regs (void)\n \n \f\n \n+/* Return TRUE if the operand constraint STR is commutative.  */\n+static bool\n+commutative_constraint_p (const char *str)\n+{\n+  int curr_alt, c;\n+  bool ignore_p;\n+\n+  for (ignore_p = false, curr_alt = 0;;)\n+    {\n+      c = *str;\n+      if (c == '\\0')\n+\tbreak;\n+      str += CONSTRAINT_LEN (c, str);\n+      if (c == '#' || !recog_data.alternative_enabled_p[curr_alt])\n+\tignore_p = true;\n+      else if (c == ',')\n+\t{\n+\t  curr_alt++;\n+\t  ignore_p = false;\n+\t}\n+      else if (! ignore_p)\n+\t{\n+\t  /* Usually `%' is the first constraint character but the\n+\t     documentation does not require this.  */\n+\t  if (c == '%')\n+\t    return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Setup possible alternatives in ALTS for INSN.  */\n+void\n+ira_setup_alts (rtx insn, HARD_REG_SET &alts)\n+{\n+  /* MAP nalt * nop -> start of constraints for given operand and\n+     alternative */\n+  static vec<const char *> insn_constraints;\n+  int nop, nalt;\n+  bool curr_swapped;\n+  const char *p;\n+  rtx op;\n+  int commutative = -1;\n+\n+  extract_insn (insn);\n+  CLEAR_HARD_REG_SET (alts);\n+  insn_constraints.release ();\n+  insn_constraints.safe_grow_cleared (recog_data.n_operands\n+\t\t\t\t      * recog_data.n_alternatives + 1);\n+  /* Check that the hard reg set is enough for holding all\n+     alternatives.  It is hard to imagine the situation when the\n+     assertion is wrong.  */\n+  ira_assert (recog_data.n_alternatives\n+\t      <= (int) MAX (sizeof (HARD_REG_ELT_TYPE) * CHAR_BIT,\n+\t\t\t    FIRST_PSEUDO_REGISTER));\n+  for (curr_swapped = false;; curr_swapped = true)\n+    {\n+      /* Calculate some data common for all alternatives to speed up the\n+\t function.  */\n+      for (nop = 0; nop < recog_data.n_operands; nop++)\n+\t{\n+\t  for (nalt = 0, p = recog_data.constraints[nop];\n+\t       nalt < recog_data.n_alternatives;\n+\t       nalt++)\n+\t    {\n+\t      insn_constraints[nop * recog_data.n_alternatives + nalt] = p;\n+\t      while (*p && *p != ',')\n+\t\tp++;\n+\t      if (*p)\n+\t\tp++;\n+\t    }\n+\t}\n+      for (nalt = 0; nalt < recog_data.n_alternatives; nalt++)\n+\t{\n+\t  if (! recog_data.alternative_enabled_p[nalt] || TEST_HARD_REG_BIT (alts, nalt))\n+\t    continue;\n+\n+\t  for (nop = 0; nop < recog_data.n_operands; nop++)\n+\t    {\n+\t      int c, len;\n+\n+\t      op = recog_data.operand[nop];\n+\t      p = insn_constraints[nop * recog_data.n_alternatives + nalt];\n+\t      if (*p == 0 || *p == ',')\n+\t\tcontinue;\n+\t      \n+\t      do\n+\t\tswitch (c = *p, len = CONSTRAINT_LEN (c, p), c)\n+\t\t  {\n+\t\t  case '#':\n+\t\t  case ',':\n+\t\t    c = '\\0';\n+\t\t  case '\\0':\n+\t\t    len = 0;\n+\t\t    break;\n+\t\t  \n+\t\t  case '?':  case '!': case '*':  case '=':  case '+':\n+\t\t    break;\n+\t\t    \n+\t\t  case '%':\n+\t\t    /* We only support one commutative marker, the\n+\t\t       first one.  We already set commutative\n+\t\t       above.  */\n+\t\t    if (commutative < 0)\n+\t\t      commutative = nop;\n+\t\t    break;\n+\n+\t\t  case '&':\n+\t\t    break;\n+\t\t    \n+\t\t  case '0':  case '1':  case '2':  case '3':  case '4':\n+\t\t  case '5':  case '6':  case '7':  case '8':  case '9':\n+\t\t    goto op_success;\n+\t\t    break;\n+\t\t    \n+\t\t  case 'p':\n+\t\t  case 'g':\n+\t\t  case 'X':\n+\t\t  case TARGET_MEM_CONSTRAINT:\n+\t\t    goto op_success;\n+\t\t    break;\n+\t\t    \n+\t\t  case '<':\n+\t\t    if (MEM_P (op)\n+\t\t\t&& (GET_CODE (XEXP (op, 0)) == PRE_DEC\n+\t\t\t    || GET_CODE (XEXP (op, 0)) == POST_DEC))\n+\t\t    goto op_success;\n+\t\t    break;\n+\t\t    \n+\t\t  case '>':\n+\t\t    if (MEM_P (op)\n+\t\t      && (GET_CODE (XEXP (op, 0)) == PRE_INC\n+\t\t\t  || GET_CODE (XEXP (op, 0)) == POST_INC))\n+\t\t      goto op_success;\n+\t\t    break;\n+\t\t    \n+\t\t  case 'E':\n+\t\t  case 'F':\n+\t\t    if (CONST_DOUBLE_AS_FLOAT_P (op)\n+\t\t\t|| (GET_CODE (op) == CONST_VECTOR\n+\t\t\t    && GET_MODE_CLASS (GET_MODE (op)) == MODE_VECTOR_FLOAT))\n+\t\t      goto op_success;\n+\t\t    break;\n+\t\t    \n+\t\t  case 'G':\n+\t\t  case 'H':\n+\t\t    if (CONST_DOUBLE_AS_FLOAT_P (op)\n+\t\t\t&& CONST_DOUBLE_OK_FOR_CONSTRAINT_P (op, c, p))\n+\t\t      goto op_success;\n+\t\t    break;\n+\t\t    \n+\t\t  case 's':\n+\t\t    if (CONST_SCALAR_INT_P (op))\n+\t\t      break;\n+\t\t  case 'i':\n+\t\t    if (CONSTANT_P (op))\n+\t\t      goto op_success;\n+\t\t    break;\n+\t\t    \n+\t\t  case 'n':\n+\t\t    if (CONST_SCALAR_INT_P (op))\n+\t\t      goto op_success;\n+\t\t    break;\n+\t\t    \n+\t\t  case 'I':\n+\t\t  case 'J':\n+\t\t  case 'K':\n+\t\t  case 'L':\n+\t\t  case 'M':\n+\t\t  case 'N':\n+\t\t  case 'O':\n+\t\t  case 'P':\n+\t\t    if (CONST_INT_P (op)\n+\t\t\t&& CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), c, p))\n+\t\t      goto op_success;\n+\t\t    break;\n+\t\t    \n+\t\t  case 'V':\n+\t\t    if (MEM_P (op) && ! offsettable_memref_p (op))\n+\t\t      goto op_success;\n+\t\t    break;\n+\t\t    \n+\t\t  case 'o':\n+\t\t    goto op_success;\n+\t\t    break;\n+\t\t    \n+\t\t  default:\n+\t\t    {\n+\t\t      enum reg_class cl;\n+\t\t      \n+\t\t      cl = (c == 'r' ? GENERAL_REGS : REG_CLASS_FROM_CONSTRAINT (c, p));\n+\t\t      if (cl != NO_REGS)\n+\t\t\tgoto op_success;\n+#ifdef EXTRA_CONSTRAINT_STR\n+\t\t      else if (EXTRA_CONSTRAINT_STR (op, c, p))\n+\t\t\tgoto op_success;\n+\t\t      else if (EXTRA_MEMORY_CONSTRAINT (c, p))\n+\t\t\tgoto op_success;\n+\t\t      else if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n+\t\t\tgoto op_success;\n+#endif\n+\t\t      break;\n+\t\t    }\n+\t\t  }\n+\t      while (p += len, c);\n+\t      break;\n+\t    op_success:\n+\t      ;\n+\t    }\n+\t  if (nop >= recog_data.n_operands)\n+\t    SET_HARD_REG_BIT (alts, nalt);\n+\t}\n+      if (commutative < 0)\n+\tbreak;\n+      if (curr_swapped)\n+\tbreak;\n+      op = recog_data.operand[commutative];\n+      recog_data.operand[commutative] = recog_data.operand[commutative + 1];\n+      recog_data.operand[commutative + 1] = op;\n+\n+    }\n+}\n+\n+/* Return the number of the output non-early clobber operand which\n+   should be the same in any case as operand with number OP_NUM (or\n+   negative value if there is no such operand).  The function takes\n+   only really possible alternatives into consideration.  */\n+int\n+ira_get_dup_out_num (int op_num, HARD_REG_SET &alts)\n+{\n+  int curr_alt, c, original, dup;\n+  bool ignore_p, use_commut_op_p;\n+  const char *str;\n+#ifdef EXTRA_CONSTRAINT_STR\n+  rtx op;\n+#endif\n+\n+  if (op_num < 0 || recog_data.n_alternatives == 0)\n+    return -1;\n+  use_commut_op_p = false;\n+  str = recog_data.constraints[op_num];\n+  for (;;)\n+    {\n+#ifdef EXTRA_CONSTRAINT_STR\n+      op = recog_data.operand[op_num];\n+#endif\n+      \n+      for (ignore_p = false, original = -1, curr_alt = 0;;)\n+\t{\n+\t  c = *str;\n+\t  if (c == '\\0')\n+\t    break;\n+\t  if (c == '#' || !TEST_HARD_REG_BIT (alts, curr_alt))\n+\t    ignore_p = true;\n+\t  else if (c == ',')\n+\t    {\n+\t      curr_alt++;\n+\t      ignore_p = false;\n+\t    }\n+\t  else if (! ignore_p)\n+\t    switch (c)\n+\t      {\n+\t\t/* We should find duplications only for input operands.  */\n+\t      case '=':\n+\t      case '+':\n+\t\tgoto fail;\n+\t      case 'X':\n+\t      case 'p':\n+\t      case 'g':\n+\t\tgoto fail;\n+\t      case 'r':\n+\t      case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n+\t      case 'h': case 'j': case 'k': case 'l':\n+\t      case 'q': case 't': case 'u':\n+\t      case 'v': case 'w': case 'x': case 'y': case 'z':\n+\t      case 'A': case 'B': case 'C': case 'D':\n+\t      case 'Q': case 'R': case 'S': case 'T': case 'U':\n+\t      case 'W': case 'Y': case 'Z':\n+\t\t{\n+\t\t  enum reg_class cl;\n+\t\t  \n+\t\t  cl = (c == 'r'\n+\t\t\t? GENERAL_REGS : REG_CLASS_FROM_CONSTRAINT (c, str));\n+\t\t  if (cl != NO_REGS)\n+\t\t    {\n+\t\t      if (! targetm.class_likely_spilled_p (cl))\n+\t\t\tgoto fail;\n+\t\t    }\n+#ifdef EXTRA_CONSTRAINT_STR\n+\t\t  else if (EXTRA_CONSTRAINT_STR (op, c, str))\n+\t\t    goto fail;\n+#endif\n+\t\t  break;\n+\t\t}\n+\t\t\n+\t      case '0': case '1': case '2': case '3': case '4':\n+\t      case '5': case '6': case '7': case '8': case '9':\n+\t\tif (original != -1 && original != c)\n+\t\t  goto fail;\n+\t\toriginal = c;\n+\t\tbreak;\n+\t      }\n+\t  str += CONSTRAINT_LEN (c, str);\n+\t}\n+      if (original == -1)\n+\tgoto fail;\n+      dup = -1;\n+      for (ignore_p = false, str = recog_data.constraints[original - '0'];\n+\t   *str != 0;\n+\t   str++)\n+\tif (ignore_p)\n+\t  {\n+\t    if (*str == ',')\n+\t      ignore_p = false;\n+\t  }\n+\telse if (*str == '#')\n+\t  ignore_p = true;\n+\telse if (! ignore_p)\n+\t  {\n+\t    if (*str == '=')\n+\t      dup = original - '0';\n+\t    /* It is better ignore an alternative with early clobber.  */\n+\t    else if (*str == '&')\n+\t      goto fail;\n+\t  }\n+      if (dup >= 0)\n+\treturn dup;\n+    fail:\n+      if (use_commut_op_p)\n+\tbreak;\n+      use_commut_op_p = true;\n+      if (commutative_constraint_p (recog_data.constraints[op_num]))\n+\tstr = recog_data.constraints[op_num + 1];\n+      else if (op_num > 0 && commutative_constraint_p (recog_data.constraints\n+\t\t\t\t\t\t       [op_num - 1]))\n+\tstr = recog_data.constraints[op_num - 1];\n+      else\n+\tbreak;\n+    }\n+  return -1;\n+}\n+\n+\f\n+\n+/* Search forward to see if the source register of a copy insn dies\n+   before either it or the destination register is modified, but don't\n+   scan past the end of the basic block.  If so, we can replace the\n+   source with the destination and let the source die in the copy\n+   insn.\n+\n+   This will reduce the number of registers live in that range and may\n+   enable the destination and the source coalescing, thus often saving\n+   one register in addition to a register-register copy.  */\n+\n+static void\n+decrease_live_ranges_number (void)\n+{\n+  basic_block bb;\n+  rtx insn, set, src, dest, dest_death, p, q, note;\n+  int sregno, dregno;\n+\n+  if (! flag_expensive_optimizations)\n+    return;\n+\n+  if (ira_dump_file)\n+    fprintf (ira_dump_file, \"Starting decreasing number of live ranges...\\n\");\n+\n+  FOR_EACH_BB (bb)\n+    FOR_BB_INSNS (bb, insn)\n+      {\n+\tset = single_set (insn);\n+\tif (! set)\n+\t  continue;\n+\tsrc = SET_SRC (set);\n+\tdest = SET_DEST (set);\n+\tif (! REG_P (src) || ! REG_P (dest)\n+\t    || find_reg_note (insn, REG_DEAD, src))\n+\t  continue;\n+\tsregno = REGNO (src);\n+\tdregno = REGNO (dest);\n+\t\n+\t/* We don't want to mess with hard regs if register classes\n+\t   are small.  */\n+\tif (sregno == dregno\n+\t    || (targetm.small_register_classes_for_mode_p (GET_MODE (src))\n+\t\t&& (sregno < FIRST_PSEUDO_REGISTER\n+\t\t    || dregno < FIRST_PSEUDO_REGISTER))\n+\t    /* We don't see all updates to SP if they are in an\n+\t       auto-inc memory reference, so we must disallow this\n+\t       optimization on them.  */\n+\t    || sregno == STACK_POINTER_REGNUM\n+\t    || dregno == STACK_POINTER_REGNUM)\n+\t  continue;\n+\t\n+\tdest_death = NULL_RTX;\n+\n+\tfor (p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n+\t  {\n+\t    if (! INSN_P (p))\n+\t      continue;\n+\t    if (BLOCK_FOR_INSN (p) != bb)\n+\t      break;\n+\t    \n+\t    if (reg_set_p (src, p) || reg_set_p (dest, p)\n+\t\t/* If SRC is an asm-declared register, it must not be\n+\t\t   replaced in any asm.  Unfortunately, the REG_EXPR\n+\t\t   tree for the asm variable may be absent in the SRC\n+\t\t   rtx, so we can't check the actual register\n+\t\t   declaration easily (the asm operand will have it,\n+\t\t   though).  To avoid complicating the test for a rare\n+\t\t   case, we just don't perform register replacement\n+\t\t   for a hard reg mentioned in an asm.  */\n+\t\t|| (sregno < FIRST_PSEUDO_REGISTER\n+\t\t    && asm_noperands (PATTERN (p)) >= 0\n+\t\t    && reg_overlap_mentioned_p (src, PATTERN (p)))\n+\t\t/* Don't change hard registers used by a call.  */\n+\t\t|| (CALL_P (p) && sregno < FIRST_PSEUDO_REGISTER\n+\t\t    && find_reg_fusage (p, USE, src))\n+\t\t/* Don't change a USE of a register.  */\n+\t\t|| (GET_CODE (PATTERN (p)) == USE\n+\t\t    && reg_overlap_mentioned_p (src, XEXP (PATTERN (p), 0))))\n+\t      break;\n+\t    \n+\t    /* See if all of SRC dies in P.  This test is slightly\n+\t       more conservative than it needs to be.  */\n+\t    if ((note = find_regno_note (p, REG_DEAD, sregno))\n+\t\t&& GET_MODE (XEXP (note, 0)) == GET_MODE (src))\n+\t      {\n+\t\tint failed = 0;\n+\t\t\n+\t\t/* We can do the optimization.  Scan forward from INSN\n+\t\t   again, replacing regs as we go.  Set FAILED if a\n+\t\t   replacement can't be done.  In that case, we can't\n+\t\t   move the death note for SRC.  This should be\n+\t\t   rare.  */\n+\t\t\n+\t\t/* Set to stop at next insn.  */\n+\t\tfor (q = next_real_insn (insn);\n+\t\t     q != next_real_insn (p);\n+\t\t     q = next_real_insn (q))\n+\t\t  {\n+\t\t    if (reg_overlap_mentioned_p (src, PATTERN (q)))\n+\t\t      {\n+\t\t\t/* If SRC is a hard register, we might miss\n+\t\t\t   some overlapping registers with\n+\t\t\t   validate_replace_rtx, so we would have to\n+\t\t\t   undo it.  We can't if DEST is present in\n+\t\t\t   the insn, so fail in that combination of\n+\t\t\t   cases.  */\n+\t\t\tif (sregno < FIRST_PSEUDO_REGISTER\n+\t\t\t    && reg_mentioned_p (dest, PATTERN (q)))\n+\t\t\t  failed = 1;\n+\t\t\t\n+\t\t\t/* Attempt to replace all uses.  */\n+\t\t\telse if (!validate_replace_rtx (src, dest, q))\n+\t\t\t  failed = 1;\n+\t\t\t\n+\t\t\t/* If this succeeded, but some part of the\n+\t\t\t   register is still present, undo the\n+\t\t\t   replacement.  */\n+\t\t\telse if (sregno < FIRST_PSEUDO_REGISTER\n+\t\t\t\t && reg_overlap_mentioned_p (src, PATTERN (q)))\n+\t\t\t  {\n+\t\t\t    validate_replace_rtx (dest, src, q);\n+\t\t\t    failed = 1;\n+\t\t\t  }\n+\t\t      }\n+\t\t    \n+\t\t    /* If DEST dies here, remove the death note and\n+\t\t       save it for later.  Make sure ALL of DEST dies\n+\t\t       here; again, this is overly conservative.  */\n+\t\t    if (! dest_death\n+\t\t\t&& (dest_death = find_regno_note (q, REG_DEAD, dregno)))\n+\t\t      {\n+\t\t\tif (GET_MODE (XEXP (dest_death, 0)) == GET_MODE (dest))\n+\t\t\t  remove_note (q, dest_death);\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    failed = 1;\n+\t\t\t    dest_death = 0;\n+\t\t\t  }\n+\t\t      }\n+\t\t  }\n+\t\t\n+\t\tif (! failed)\n+\t\t  {\n+\t\t    /* Move death note of SRC from P to INSN.  */\n+\t\t    remove_note (p, note);\n+\t\t    XEXP (note, 1) = REG_NOTES (insn);\n+\t\t    REG_NOTES (insn) = note;\n+\t\t  }\n+\t\t\n+\t\t/* DEST is also dead if INSN has a REG_UNUSED note for\n+\t\t   DEST.  */\n+\t\tif (! dest_death\n+\t\t    && (dest_death\n+\t\t\t= find_regno_note (insn, REG_UNUSED, dregno)))\n+\t\t  {\n+\t\t    PUT_REG_NOTE_KIND (dest_death, REG_DEAD);\n+\t\t    remove_note (insn, dest_death);\n+\t\t  }\n+\t\t\n+\t\t/* Put death note of DEST on P if we saw it die.  */\n+\t\tif (dest_death)\n+\t\t  {\n+\t\t    XEXP (dest_death, 1) = REG_NOTES (p);\n+\t\t    REG_NOTES (p) = dest_death;\n+\t\t  }\n+\t\tbreak;\n+\t      }\n+\t    \n+\t    /* If SRC is a hard register which is set or killed in\n+\t       some other way, we can't do this optimization.  */\n+\t    else if (sregno < FIRST_PSEUDO_REGISTER && dead_or_set_p (p, src))\n+\t      break;\n+\t  }\n+      }\n+}\n+\n+\f\n+\n /* Return nonzero if REGNO is a particularly bad choice for reloading X.  */\n static bool\n ira_bad_reload_regno_1 (int regno, rtx x)\n@@ -4655,7 +5176,7 @@ ira (FILE *f)\n     }\n \n   setup_prohibited_mode_move_regs ();\n-\n+  decrease_live_ranges_number ();\n   df_note_add_problem ();\n \n   /* DF_LIVE can't be used in the register allocator, too many other\n@@ -4671,6 +5192,7 @@ ira (FILE *f)\n   df->changeable_flags |= DF_VERIFY_SCHEDULED;\n #endif\n   df_analyze ();\n+\n   df_clear_flags (DF_NO_INSN_RESCAN);\n   regstat_init_n_sets_and_refs ();\n   regstat_compute_ri ();"}, {"sha": "b7d56e337150e48bc3df95517844a227817718d4", "filename": "gcc/opts.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -473,7 +473,6 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_2_PLUS_SPEED_ONLY, OPT_fschedule_insns, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fschedule_insns2, NULL, 1 },\n #endif\n-    { OPT_LEVELS_2_PLUS, OPT_fregmove, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fstrict_aliasing, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fstrict_overflow, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_freorder_blocks, NULL, 1 },"}, {"sha": "31ce11381d8703cbebc8876f8ade8917bfdf2d64", "filename": "gcc/passes.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -350,7 +350,6 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_combine);\n       NEXT_PASS (pass_if_after_combine);\n       NEXT_PASS (pass_partition_blocks);\n-      NEXT_PASS (pass_regmove);\n       NEXT_PASS (pass_outof_cfg_layout_mode);\n       NEXT_PASS (pass_split_all_insns);\n       NEXT_PASS (pass_lower_subreg2);"}, {"sha": "85c7ff490c840a439062066f88bc6957a576ecf5", "filename": "gcc/regmove.c", "status": "removed", "additions": 0, "deletions": 1401, "changes": 1401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bef9b2340e56beffd12c4fe84761487ca5f0ce9/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bef9b2340e56beffd12c4fe84761487ca5f0ce9/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=1bef9b2340e56beffd12c4fe84761487ca5f0ce9", "patch": "@@ -1,1401 +0,0 @@\n-/* Move registers around to reduce number of move instructions needed.\n-   Copyright (C) 1987-2013 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-/* This module makes some simple RTL code transformations which\n-   improve the subsequent register allocation.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"tm_p.h\"\n-#include \"insn-config.h\"\n-#include \"recog.h\"\n-#include \"target.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"flags.h\"\n-#include \"function.h\"\n-#include \"expr.h\"\n-#include \"basic-block.h\"\n-#include \"except.h\"\n-#include \"diagnostic-core.h\"\n-#include \"reload.h\"\n-#include \"tree-pass.h\"\n-#include \"df.h\"\n-#include \"ira.h\"\n-\n-static int optimize_reg_copy_1 (rtx, rtx, rtx);\n-static void optimize_reg_copy_2 (rtx, rtx, rtx);\n-static void optimize_reg_copy_3 (rtx, rtx, rtx);\n-static void copy_src_to_dest (rtx, rtx, rtx);\n-\n-enum match_use\n-{\n-  READ,\n-  WRITE,\n-  READWRITE\n-};\n-\n-struct match {\n-  int with[MAX_RECOG_OPERANDS];\n-  enum match_use use[MAX_RECOG_OPERANDS];\n-  int commutative[MAX_RECOG_OPERANDS];\n-  int early_clobber[MAX_RECOG_OPERANDS];\n-};\n-\n-static int find_matches (rtx, struct match *);\n-static int fixup_match_2 (rtx, rtx, rtx, rtx);\n-\n-/* Return nonzero if registers with CLASS1 and CLASS2 can be merged without\n-   causing too much register allocation problems.  */\n-static int\n-regclass_compatible_p (reg_class_t class0, reg_class_t class1)\n-{\n-  return (class0 == class1\n-\t  || (reg_class_subset_p (class0, class1)\n-\t      && ! targetm.class_likely_spilled_p (class0))\n-\t  || (reg_class_subset_p (class1, class0)\n-\t      && ! targetm.class_likely_spilled_p (class1)));\n-}\n-\n-\f\n-#ifdef AUTO_INC_DEC\n-\n-/* Find the place in the rtx X where REG is used as a memory address.\n-   Return the MEM rtx that so uses it.\n-   If PLUSCONST is nonzero, search instead for a memory address equivalent to\n-   (plus REG (const_int PLUSCONST)).\n-\n-   If such an address does not appear, return 0.\n-   If REG appears more than once, or is used other than in such an address,\n-   return (rtx) 1.  */\n-\n-static rtx\n-find_use_as_address (rtx x, rtx reg, HOST_WIDE_INT plusconst)\n-{\n-  enum rtx_code code = GET_CODE (x);\n-  const char * const fmt = GET_RTX_FORMAT (code);\n-  int i;\n-  rtx value = 0;\n-  rtx tem;\n-\n-  if (code == MEM && XEXP (x, 0) == reg && plusconst == 0)\n-    return x;\n-\n-  if (code == MEM && GET_CODE (XEXP (x, 0)) == PLUS\n-      && XEXP (XEXP (x, 0), 0) == reg\n-      && CONST_INT_P (XEXP (XEXP (x, 0), 1))\n-      && INTVAL (XEXP (XEXP (x, 0), 1)) == plusconst)\n-    return x;\n-\n-  if (code == SIGN_EXTRACT || code == ZERO_EXTRACT)\n-    {\n-      /* If REG occurs inside a MEM used in a bit-field reference,\n-\t that is unacceptable.  */\n-      if (find_use_as_address (XEXP (x, 0), reg, 0) != 0)\n-\treturn (rtx) (size_t) 1;\n-    }\n-\n-  if (x == reg)\n-    return (rtx) (size_t) 1;\n-\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\t{\n-\t  tem = find_use_as_address (XEXP (x, i), reg, plusconst);\n-\t  if (value == 0)\n-\t    value = tem;\n-\t  else if (tem != 0)\n-\t    return (rtx) (size_t) 1;\n-\t}\n-      else if (fmt[i] == 'E')\n-\t{\n-\t  int j;\n-\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t    {\n-\t      tem = find_use_as_address (XVECEXP (x, i, j), reg, plusconst);\n-\t      if (value == 0)\n-\t\tvalue = tem;\n-\t      else if (tem != 0)\n-\t\treturn (rtx) (size_t) 1;\n-\t    }\n-\t}\n-    }\n-\n-  return value;\n-}\n-\n-\n-/* INC_INSN is an instruction that adds INCREMENT to REG.\n-   Try to fold INC_INSN as a post/pre in/decrement into INSN.\n-   Iff INC_INSN_SET is nonzero, inc_insn has a destination different from src.\n-   Return nonzero for success.  */\n-static int\n-try_auto_increment (rtx insn, rtx inc_insn, rtx inc_insn_set, rtx reg,\n-\t\t    HOST_WIDE_INT increment, int pre)\n-{\n-  enum rtx_code inc_code;\n-\n-  rtx pset = single_set (insn);\n-  if (pset)\n-    {\n-      /* Can't use the size of SET_SRC, we might have something like\n-\t (sign_extend:SI (mem:QI ...  */\n-      rtx use = find_use_as_address (pset, reg, 0);\n-      if (use != 0 && use != (rtx) (size_t) 1)\n-\t{\n-\t  int size = GET_MODE_SIZE (GET_MODE (use));\n-\t  if (0\n-\t      || (HAVE_POST_INCREMENT\n-\t\t  && pre == 0 && (inc_code = POST_INC, increment == size))\n-\t      || (HAVE_PRE_INCREMENT\n-\t\t  && pre == 1 && (inc_code = PRE_INC, increment == size))\n-\t      || (HAVE_POST_DECREMENT\n-\t\t  && pre == 0 && (inc_code = POST_DEC, increment == -size))\n-\t      || (HAVE_PRE_DECREMENT\n-\t\t  && pre == 1 && (inc_code = PRE_DEC, increment == -size))\n-\t  )\n-\t    {\n-\t      if (inc_insn_set)\n-\t\tvalidate_change\n-\t\t  (inc_insn,\n-\t\t   &SET_SRC (inc_insn_set),\n-\t\t   XEXP (SET_SRC (inc_insn_set), 0), 1);\n-\t      validate_change (insn, &XEXP (use, 0),\n-\t\t\t       gen_rtx_fmt_e (inc_code,\n-\t\t\t\t\t      GET_MODE (XEXP (use, 0)), reg),\n-\t\t\t       1);\n-\t      if (apply_change_group ())\n-\t\t{\n-\t\t  /* If there is a REG_DEAD note on this insn, we must\n-\t\t     change this not to REG_UNUSED meaning that the register\n-\t\t     is set, but the value is dead.  Failure to do so will\n-\t\t     result in sched1 dying -- when it recomputes lifetime\n-\t\t     information, the number of REG_DEAD notes will have\n-\t\t     changed.  */\n-\t\t  rtx note = find_reg_note (insn, REG_DEAD, reg);\n-\t\t  if (note)\n-\t\t    PUT_REG_NOTE_KIND (note, REG_UNUSED);\n-\n-\t\t  add_reg_note (insn, REG_INC, reg);\n-\n-\t\t  if (! inc_insn_set)\n-\t\t    delete_insn (inc_insn);\n-\t\t  return 1;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-  return 0;\n-}\n-#endif\n-\n-\f\n-static int *regno_src_regno;\n-\n-/* INSN is a copy from SRC to DEST, both registers, and SRC does not die\n-   in INSN.\n-\n-   Search forward to see if SRC dies before either it or DEST is modified,\n-   but don't scan past the end of a basic block.  If so, we can replace SRC\n-   with DEST and let SRC die in INSN.\n-\n-   This will reduce the number of registers live in that range and may enable\n-   DEST to be tied to SRC, thus often saving one register in addition to a\n-   register-register copy.  */\n-\n-static int\n-optimize_reg_copy_1 (rtx insn, rtx dest, rtx src)\n-{\n-  rtx p, q;\n-  rtx note;\n-  rtx dest_death = 0;\n-  int sregno = REGNO (src);\n-  int dregno = REGNO (dest);\n-  basic_block bb = BLOCK_FOR_INSN (insn);\n-\n-  /* We don't want to mess with hard regs if register classes are small.  */\n-  if (sregno == dregno\n-      || (targetm.small_register_classes_for_mode_p (GET_MODE (src))\n-\t  && (sregno < FIRST_PSEUDO_REGISTER\n-\t      || dregno < FIRST_PSEUDO_REGISTER))\n-      /* We don't see all updates to SP if they are in an auto-inc memory\n-\t reference, so we must disallow this optimization on them.  */\n-      || sregno == STACK_POINTER_REGNUM || dregno == STACK_POINTER_REGNUM)\n-    return 0;\n-\n-  for (p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n-    {\n-      if (! INSN_P (p))\n-\tcontinue;\n-      if (BLOCK_FOR_INSN (p) != bb)\n-\tbreak;\n-\n-      if (reg_set_p (src, p) || reg_set_p (dest, p)\n-\t  /* If SRC is an asm-declared register, it must not be replaced\n-\t     in any asm.  Unfortunately, the REG_EXPR tree for the asm\n-\t     variable may be absent in the SRC rtx, so we can't check the\n-\t     actual register declaration easily (the asm operand will have\n-\t     it, though).  To avoid complicating the test for a rare case,\n-\t     we just don't perform register replacement for a hard reg\n-\t     mentioned in an asm.  */\n-\t  || (sregno < FIRST_PSEUDO_REGISTER\n-\t      && asm_noperands (PATTERN (p)) >= 0\n-\t      && reg_overlap_mentioned_p (src, PATTERN (p)))\n-\t  /* Don't change hard registers used by a call.  */\n-\t  || (CALL_P (p) && sregno < FIRST_PSEUDO_REGISTER\n-\t      && find_reg_fusage (p, USE, src))\n-\t  /* Don't change a USE of a register.  */\n-\t  || (GET_CODE (PATTERN (p)) == USE\n-\t      && reg_overlap_mentioned_p (src, XEXP (PATTERN (p), 0))))\n-\tbreak;\n-\n-      /* See if all of SRC dies in P.  This test is slightly more\n-\t conservative than it needs to be.  */\n-      if ((note = find_regno_note (p, REG_DEAD, sregno)) != 0\n-\t  && GET_MODE (XEXP (note, 0)) == GET_MODE (src))\n-\t{\n-\t  int failed = 0;\n-\t  int d_length = 0;\n-\t  int s_length = 0;\n-\t  int d_n_calls = 0;\n-\t  int s_n_calls = 0;\n-\t  int s_freq_calls = 0;\n-\t  int d_freq_calls = 0;\n-\n-\t  /* We can do the optimization.  Scan forward from INSN again,\n-\t     replacing regs as we go.  Set FAILED if a replacement can't\n-\t     be done.  In that case, we can't move the death note for SRC.\n-\t     This should be rare.  */\n-\n-\t  /* Set to stop at next insn.  */\n-\t  for (q = next_real_insn (insn);\n-\t       q != next_real_insn (p);\n-\t       q = next_real_insn (q))\n-\t    {\n-\t      if (reg_overlap_mentioned_p (src, PATTERN (q)))\n-\t\t{\n-\t\t  /* If SRC is a hard register, we might miss some\n-\t\t     overlapping registers with validate_replace_rtx,\n-\t\t     so we would have to undo it.  We can't if DEST is\n-\t\t     present in the insn, so fail in that combination\n-\t\t     of cases.  */\n-\t\t  if (sregno < FIRST_PSEUDO_REGISTER\n-\t\t      && reg_mentioned_p (dest, PATTERN (q)))\n-\t\t    failed = 1;\n-\n-\t\t  /* Attempt to replace all uses.  */\n-\t\t  else if (!validate_replace_rtx (src, dest, q))\n-\t\t    failed = 1;\n-\n-\t\t  /* If this succeeded, but some part of the register\n-\t\t     is still present, undo the replacement.  */\n-\t\t  else if (sregno < FIRST_PSEUDO_REGISTER\n-\t\t\t   && reg_overlap_mentioned_p (src, PATTERN (q)))\n-\t\t    {\n-\t\t      validate_replace_rtx (dest, src, q);\n-\t\t      failed = 1;\n-\t\t    }\n-\t\t}\n-\n-\t      /* For SREGNO, count the total number of insns scanned.\n-\t\t For DREGNO, count the total number of insns scanned after\n-\t\t passing the death note for DREGNO.  */\n-\t      if (!DEBUG_INSN_P (p))\n-\t\t{\n-\t\t  s_length++;\n-\t\t  if (dest_death)\n-\t\t    d_length++;\n-\t\t}\n-\n-\t      /* If the insn in which SRC dies is a CALL_INSN, don't count it\n-\t\t as a call that has been crossed.  Otherwise, count it.  */\n-\t      if (q != p && CALL_P (q))\n-\t\t{\n-\t\t  /* Similarly, total calls for SREGNO, total calls beyond\n-\t\t     the death note for DREGNO.  */\n-\t\t  s_n_calls++;\n-\t\t  s_freq_calls += REG_FREQ_FROM_BB  (BLOCK_FOR_INSN (q));\n-\t\t  if (dest_death)\n-\t\t    {\n-\t\t      d_n_calls++;\n-\t\t      d_freq_calls += REG_FREQ_FROM_BB  (BLOCK_FOR_INSN (q));\n-\t\t    }\n-\t\t}\n-\n-\t      /* If DEST dies here, remove the death note and save it for\n-\t\t later.  Make sure ALL of DEST dies here; again, this is\n-\t\t overly conservative.  */\n-\t      if (dest_death == 0\n-\t\t  && (dest_death = find_regno_note (q, REG_DEAD, dregno)) != 0)\n-\t\t{\n-\t\t  if (GET_MODE (XEXP (dest_death, 0)) != GET_MODE (dest))\n-\t\t    failed = 1, dest_death = 0;\n-\t\t  else\n-\t\t    remove_note (q, dest_death);\n-\t\t}\n-\t    }\n-\n-\t  if (! failed)\n-\t    {\n-\t      /* These counters need to be updated if and only if we are\n-\t\t going to move the REG_DEAD note.  */\n-\t      if (sregno >= FIRST_PSEUDO_REGISTER)\n-\t\t{\n-\t\t  if (REG_LIVE_LENGTH (sregno) >= 0)\n-\t\t    {\n-\t\t      REG_LIVE_LENGTH (sregno) -= s_length;\n-\t\t      /* REG_LIVE_LENGTH is only an approximation after\n-\t\t\t combine if sched is not run, so make sure that we\n-\t\t\t still have a reasonable value.  */\n-\t\t      if (REG_LIVE_LENGTH (sregno) < 2)\n-\t\t\tREG_LIVE_LENGTH (sregno) = 2;\n-\t\t    }\n-\n-\t\t  REG_N_CALLS_CROSSED (sregno) -= s_n_calls;\n-\t\t  REG_FREQ_CALLS_CROSSED (sregno) -= s_freq_calls;\n-\t\t}\n-\n-\t      /* Move death note of SRC from P to INSN.  */\n-\t      remove_note (p, note);\n-\t      XEXP (note, 1) = REG_NOTES (insn);\n-\t      REG_NOTES (insn) = note;\n-\t    }\n-\n-\t  /* DEST is also dead if INSN has a REG_UNUSED note for DEST.  */\n-\t  if (! dest_death\n-\t      && (dest_death = find_regno_note (insn, REG_UNUSED, dregno)))\n-\t    {\n-\t      PUT_REG_NOTE_KIND (dest_death, REG_DEAD);\n-\t      remove_note (insn, dest_death);\n-\t    }\n-\n-\t  /* Put death note of DEST on P if we saw it die.  */\n-\t  if (dest_death)\n-\t    {\n-\t      XEXP (dest_death, 1) = REG_NOTES (p);\n-\t      REG_NOTES (p) = dest_death;\n-\n-\t      if (dregno >= FIRST_PSEUDO_REGISTER)\n-\t\t{\n-\t\t  /* If and only if we are moving the death note for DREGNO,\n-\t\t     then we need to update its counters.  */\n-\t\t  if (REG_LIVE_LENGTH (dregno) >= 0)\n-\t\t    REG_LIVE_LENGTH (dregno) += d_length;\n-\t\t  REG_N_CALLS_CROSSED (dregno) += d_n_calls;\n-\t\t  REG_FREQ_CALLS_CROSSED (dregno) += d_freq_calls;\n-\t\t}\n-\t    }\n-\n-\t  return ! failed;\n-\t}\n-\n-      /* If SRC is a hard register which is set or killed in some other\n-\t way, we can't do this optimization.  */\n-      else if (sregno < FIRST_PSEUDO_REGISTER\n-\t       && dead_or_set_p (p, src))\n-\tbreak;\n-    }\n-  return 0;\n-}\n-\f\n-/* INSN is a copy of SRC to DEST, in which SRC dies.  See if we now have\n-   a sequence of insns that modify DEST followed by an insn that sets\n-   SRC to DEST in which DEST dies, with no prior modification of DEST.\n-   (There is no need to check if the insns in between actually modify\n-   DEST.  We should not have cases where DEST is not modified, but\n-   the optimization is safe if no such modification is detected.)\n-   In that case, we can replace all uses of DEST, starting with INSN and\n-   ending with the set of SRC to DEST, with SRC.  We do not do this\n-   optimization if a CALL_INSN is crossed unless SRC already crosses a\n-   call or if DEST dies before the copy back to SRC.\n-\n-   It is assumed that DEST and SRC are pseudos; it is too complicated to do\n-   this for hard registers since the substitutions we may make might fail.  */\n-\n-static void\n-optimize_reg_copy_2 (rtx insn, rtx dest, rtx src)\n-{\n-  rtx p, q;\n-  rtx set;\n-  int sregno = REGNO (src);\n-  int dregno = REGNO (dest);\n-  basic_block bb = BLOCK_FOR_INSN (insn);\n-\n-  for (p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n-    {\n-      if (! INSN_P (p))\n-\tcontinue;\n-      if (BLOCK_FOR_INSN (p) != bb)\n-\tbreak;\n-\n-      set = single_set (p);\n-      if (set && SET_SRC (set) == dest && SET_DEST (set) == src\n-\t  && find_reg_note (p, REG_DEAD, dest))\n-\t{\n-\t  /* We can do the optimization.  Scan forward from INSN again,\n-\t     replacing regs as we go.  */\n-\n-\t  /* Set to stop at next insn.  */\n-\t  for (q = insn; q != NEXT_INSN (p); q = NEXT_INSN (q))\n-\t    if (INSN_P (q))\n-\t      {\n-\t\tif (reg_mentioned_p (dest, PATTERN (q)))\n-\t\t  {\n-\t\t    rtx note;\n-\n-\t\t    PATTERN (q) = replace_rtx (PATTERN (q), dest, src);\n-\t\t    note = FIND_REG_INC_NOTE (q, dest);\n-\t\t    if (note)\n-\t\t      {\n-\t\t\tremove_note (q, note);\n-\t\t\tadd_reg_note (q, REG_INC, src);\n-\t\t      }\n-\t\t    df_insn_rescan (q);\n-\t\t  }\n-\n-\t\tif (CALL_P (q))\n-\t\t  {\n-\t\t    int freq = REG_FREQ_FROM_BB  (BLOCK_FOR_INSN (q));\n-\t\t    REG_N_CALLS_CROSSED (dregno)--;\n-\t\t    REG_N_CALLS_CROSSED (sregno)++;\n-\t\t    REG_FREQ_CALLS_CROSSED (dregno) -= freq;\n-\t\t    REG_FREQ_CALLS_CROSSED (sregno) += freq;\n-\t\t  }\n-\t      }\n-\n-\t  remove_note (p, find_reg_note (p, REG_DEAD, dest));\n-\t  REG_N_DEATHS (dregno)--;\n-\t  remove_note (insn, find_reg_note (insn, REG_DEAD, src));\n-\t  REG_N_DEATHS (sregno)--;\n-\t  return;\n-\t}\n-\n-      if (reg_set_p (src, p)\n-\t  || find_reg_note (p, REG_DEAD, dest)\n-\t  || (CALL_P (p) && REG_N_CALLS_CROSSED (sregno) == 0))\n-\tbreak;\n-    }\n-}\n-\n-/* INSN is a ZERO_EXTEND or SIGN_EXTEND of SRC to DEST.\n-   Look if SRC dies there, and if it is only set once, by loading\n-   it from memory.  If so, try to incorporate the zero/sign extension\n-   into the memory read, change SRC to the mode of DEST, and alter\n-   the remaining accesses to use the appropriate SUBREG.  This allows\n-   SRC and DEST to be tied later.  */\n-static void\n-optimize_reg_copy_3 (rtx insn, rtx dest, rtx src)\n-{\n-  rtx src_reg = XEXP (src, 0);\n-  int src_no = REGNO (src_reg);\n-  int dst_no = REGNO (dest);\n-  rtx p, set, set_insn;\n-  enum machine_mode old_mode;\n-  basic_block bb = BLOCK_FOR_INSN (insn);\n-\n-  if (src_no < FIRST_PSEUDO_REGISTER\n-      || dst_no < FIRST_PSEUDO_REGISTER\n-      || ! find_reg_note (insn, REG_DEAD, src_reg)\n-      || REG_N_DEATHS (src_no) != 1\n-      || REG_N_SETS (src_no) != 1)\n-    return;\n-\n-  for (p = PREV_INSN (insn); p && ! reg_set_p (src_reg, p); p = PREV_INSN (p))\n-    if (INSN_P (p) && BLOCK_FOR_INSN (p) != bb)\n-      break;\n-\n-  if (! p || BLOCK_FOR_INSN (p) != bb)\n-    return;\n-\n-  if (! (set = single_set (p))\n-      || !MEM_P (SET_SRC (set))\n-      /* If there's a REG_EQUIV note, this must be an insn that loads an\n-\t argument.  Prefer keeping the note over doing this optimization.  */\n-      || find_reg_note (p, REG_EQUIV, NULL_RTX)\n-      || SET_DEST (set) != src_reg)\n-    return;\n-\n-  /* Be conservative: although this optimization is also valid for\n-     volatile memory references, that could cause trouble in later passes.  */\n-  if (MEM_VOLATILE_P (SET_SRC (set)))\n-    return;\n-\n-  /* Do not use a SUBREG to truncate from one mode to another if truncation\n-     is not a nop.  */\n-  if (GET_MODE_BITSIZE (GET_MODE (src_reg)) <= GET_MODE_BITSIZE (GET_MODE (src))\n-      && !TRULY_NOOP_TRUNCATION_MODES_P (GET_MODE (src), GET_MODE (src_reg)))\n-    return;\n-\n-  set_insn = p;\n-  old_mode = GET_MODE (src_reg);\n-  PUT_MODE (src_reg, GET_MODE (src));\n-  XEXP (src, 0) = SET_SRC (set);\n-\n-  /* Include this change in the group so that it's easily undone if\n-     one of the changes in the group is invalid.  */\n-  validate_change (p, &SET_SRC (set), src, 1);\n-\n-  /* Now walk forward making additional replacements.  We want to be able\n-     to undo all the changes if a later substitution fails.  */\n-  while (p = NEXT_INSN (p), p != insn)\n-    {\n-      if (! INSN_P (p))\n-\tcontinue;\n-\n-      /* Make a tentative change.  */\n-      validate_replace_rtx_group (src_reg,\n-\t\t\t\t  gen_lowpart_SUBREG (old_mode, src_reg),\n-\t\t\t\t  p);\n-    }\n-\n-  validate_replace_rtx_group (src, src_reg, insn);\n-\n-  /* Now see if all the changes are valid.  */\n-  if (! apply_change_group ())\n-    {\n-      /* One or more changes were no good.  Back out everything.  */\n-      PUT_MODE (src_reg, old_mode);\n-      XEXP (src, 0) = src_reg;\n-    }\n-  else\n-    {\n-      rtx note = find_reg_note (set_insn, REG_EQUAL, NULL_RTX);\n-      if (note)\n-\t{\n-\t  if (rtx_equal_p (XEXP (note, 0), XEXP (src, 0)))\n-\t    {\n-\t      XEXP (note, 0)\n-\t\t= gen_rtx_fmt_e (GET_CODE (src), GET_MODE (src),\n-\t\t\t\t XEXP (note, 0));\n-\t      df_notes_rescan (set_insn);\n-\t    }\n-\t  else\n-\t    remove_note (set_insn, note);\n-\t}\n-    }\n-}\n-\n-\f\n-/* If we were not able to update the users of src to use dest directly, try\n-   instead moving the value to dest directly before the operation.  */\n-\n-static void\n-copy_src_to_dest (rtx insn, rtx src, rtx dest)\n-{\n-  rtx seq;\n-  rtx link;\n-  rtx next;\n-  rtx set;\n-  rtx move_insn;\n-  rtx *p_insn_notes;\n-  rtx *p_move_notes;\n-  int src_regno;\n-  int dest_regno;\n-\n-  /* A REG_LIVE_LENGTH of -1 indicates the register must not go into\n-     a hard register, e.g. because it crosses as setjmp.  See the\n-     comment in regstat.c:regstat_bb_compute_ri.  Don't try to apply\n-     any transformations to such regs.  */\n-\n-  if (REG_P (src)\n-      && REG_LIVE_LENGTH (REGNO (src)) > 0\n-      && REG_P (dest)\n-      && REG_LIVE_LENGTH (REGNO (dest)) > 0\n-      && (set = single_set (insn)) != NULL_RTX\n-      && !reg_mentioned_p (dest, SET_SRC (set))\n-      && GET_MODE (src) == GET_MODE (dest))\n-    {\n-      int old_num_regs = reg_rtx_no;\n-\n-      /* Generate the src->dest move.  */\n-      start_sequence ();\n-      emit_move_insn (dest, src);\n-      seq = get_insns ();\n-      end_sequence ();\n-      /* If this sequence uses new registers, we may not use it.  */\n-      if (old_num_regs != reg_rtx_no\n-\t  || ! validate_replace_rtx (src, dest, insn))\n-\t{\n-\t  /* We have to restore reg_rtx_no to its old value, lest\n-\t     recompute_reg_usage will try to compute the usage of the\n-\t     new regs, yet reg_n_info is not valid for them.  */\n-\t  reg_rtx_no = old_num_regs;\n-\t  return;\n-\t}\n-      emit_insn_before (seq, insn);\n-      move_insn = PREV_INSN (insn);\n-      p_move_notes = &REG_NOTES (move_insn);\n-      p_insn_notes = &REG_NOTES (insn);\n-\n-      /* Move any notes mentioning src to the move instruction.  */\n-      for (link = REG_NOTES (insn); link != NULL_RTX; link = next)\n-\t{\n-\t  next = XEXP (link, 1);\n-\t  if (GET_CODE (link) == EXPR_LIST && XEXP (link, 0) == src)\n-\t    {\n-\t      *p_move_notes = link;\n-\t      p_move_notes = &XEXP (link, 1);\n-\t    }\n-\t  else\n-\t    {\n-\t      *p_insn_notes = link;\n-\t      p_insn_notes = &XEXP (link, 1);\n-\t    }\n-\t}\n-\n-      *p_move_notes = NULL_RTX;\n-      *p_insn_notes = NULL_RTX;\n-\n-      /* Update the various register tables.  */\n-      dest_regno = REGNO (dest);\n-      INC_REG_N_SETS (dest_regno, 1);\n-      REG_LIVE_LENGTH (dest_regno)++;\n-      src_regno = REGNO (src);\n-      if (! find_reg_note (move_insn, REG_DEAD, src))\n-\tREG_LIVE_LENGTH (src_regno)++;\n-    }\n-}\n-\n-/* reg_set_in_bb[REGNO] points to basic block iff the register is set\n-   only once in the given block and has REG_EQUAL note.  */\n-\n-static basic_block *reg_set_in_bb;\n-\n-/* Size of reg_set_in_bb array.  */\n-static unsigned int max_reg_computed;\n-\n-\f\n-/* Return whether REG is set in only one location, and is set to a\n-   constant, but is set in a different basic block from INSN (an\n-   instructions which uses REG).  In this case REG is equivalent to a\n-   constant, and we don't want to break that equivalence, because that\n-   may increase register pressure and make reload harder.  If REG is\n-   set in the same basic block as INSN, we don't worry about it,\n-   because we'll probably need a register anyhow (??? but what if REG\n-   is used in a different basic block as well as this one?).  */\n-\n-static bool\n-reg_is_remote_constant_p (rtx reg, rtx insn)\n-{\n-  basic_block bb;\n-  rtx p;\n-  int max;\n-\n-  if (!reg_set_in_bb)\n-    {\n-      max_reg_computed = max = max_reg_num ();\n-      reg_set_in_bb = XCNEWVEC (basic_block, max);\n-\n-      FOR_EACH_BB (bb)\n-\tFOR_BB_INSNS (bb, p)\n-\t  {\n-\t    rtx s;\n-\n-\t    if (!INSN_P (p))\n-\t      continue;\n-\t    s = single_set (p);\n-\t    /* This is the instruction which sets REG.  If there is a\n-\t       REG_EQUAL note, then REG is equivalent to a constant.  */\n-\t    if (s != 0\n-\t        && REG_P (SET_DEST (s))\n-\t        && REG_N_SETS (REGNO (SET_DEST (s))) == 1\n-\t        && find_reg_note (p, REG_EQUAL, NULL_RTX))\n-\t      reg_set_in_bb[REGNO (SET_DEST (s))] = bb;\n-\t  }\n-    }\n-\n-  gcc_assert (REGNO (reg) < max_reg_computed);\n-  if (reg_set_in_bb[REGNO (reg)] == NULL)\n-    return false;\n-  return (reg_set_in_bb[REGNO (reg)] != BLOCK_FOR_INSN (insn));\n-}\n-\n-/* INSN is adding a CONST_INT to a REG.  We search backwards looking for\n-   another add immediate instruction with the same source and dest registers,\n-   and if we find one, we change INSN to an increment, and return 1.  If\n-   no changes are made, we return 0.\n-\n-   This changes\n-     (set (reg100) (plus reg1 offset1))\n-     ...\n-     (set (reg100) (plus reg1 offset2))\n-   to\n-     (set (reg100) (plus reg1 offset1))\n-     ...\n-     (set (reg100) (plus reg100 offset2-offset1))  */\n-\n-/* ??? What does this comment mean?  */\n-/* cse disrupts preincrement / postdecrement sequences when it finds a\n-   hard register as ultimate source, like the frame pointer.  */\n-\n-static int\n-fixup_match_2 (rtx insn, rtx dst, rtx src, rtx offset)\n-{\n-  rtx p, dst_death = 0;\n-  int length, num_calls = 0, freq_calls = 0;\n-  basic_block bb = BLOCK_FOR_INSN (insn);\n-\n-  /* If SRC dies in INSN, we'd have to move the death note.  This is\n-     considered to be very unlikely, so we just skip the optimization\n-     in this case.  */\n-  if (find_regno_note (insn, REG_DEAD, REGNO (src)))\n-    return 0;\n-\n-  /* Scan backward to find the first instruction that sets DST.  */\n-\n-  for (length = 0, p = PREV_INSN (insn); p; p = PREV_INSN (p))\n-    {\n-      rtx pset;\n-\n-      if (! INSN_P (p))\n-\tcontinue;\n-      if (BLOCK_FOR_INSN (p) != bb)\n-\tbreak;\n-\n-      if (find_regno_note (p, REG_DEAD, REGNO (dst)))\n-\tdst_death = p;\n-      if (! dst_death && !DEBUG_INSN_P (p))\n-\tlength++;\n-\n-      pset = single_set (p);\n-      if (pset && SET_DEST (pset) == dst\n-\t  && GET_CODE (SET_SRC (pset)) == PLUS\n-\t  && XEXP (SET_SRC (pset), 0) == src\n-\t  && CONST_INT_P (XEXP (SET_SRC (pset), 1)))\n-\t{\n-\t  HOST_WIDE_INT newconst\n-\t    = INTVAL (offset) - INTVAL (XEXP (SET_SRC (pset), 1));\n-\t  rtx add = gen_add3_insn (dst, dst,\n-\t\t\t\t   gen_int_mode (newconst, GET_MODE (dst)));\n-\n-\t  if (add && validate_change (insn, &PATTERN (insn), add, 0))\n-\t    {\n-\t      /* Remove the death note for DST from DST_DEATH.  */\n-\t      if (dst_death)\n-\t\t{\n-\t\t  remove_death (REGNO (dst), dst_death);\n-\t\t  REG_LIVE_LENGTH (REGNO (dst)) += length;\n-\t\t  REG_N_CALLS_CROSSED (REGNO (dst)) += num_calls;\n-\t\t  REG_FREQ_CALLS_CROSSED (REGNO (dst)) += freq_calls;\n-\t\t}\n-\n-\t      if (dump_file)\n-\t\tfprintf (dump_file,\n-\t\t\t \"Fixed operand of insn %d.\\n\",\n-\t\t\t  INSN_UID (insn));\n-\n-#ifdef AUTO_INC_DEC\n-\t      for (p = PREV_INSN (insn); p; p = PREV_INSN (p))\n-\t\t{\n-\t\t  if (! INSN_P (p))\n-\t\t    continue;\n-\t\t  if (BLOCK_FOR_INSN (p) != bb)\n-\t\t    break;\n-\t\t  if (reg_overlap_mentioned_p (dst, PATTERN (p)))\n-\t\t    {\n-\t\t      if (try_auto_increment (p, insn, 0, dst, newconst, 0))\n-\t\t\treturn 1;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t      for (p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n-\t\t{\n-\t\t  if (! INSN_P (p))\n-\t\t    continue;\n-\t\t  if (BLOCK_FOR_INSN (p) != bb)\n-\t\t    break;\n-\t\t  if (reg_overlap_mentioned_p (dst, PATTERN (p)))\n-\t\t    {\n-\t\t      try_auto_increment (p, insn, 0, dst, newconst, 1);\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-#endif\n-\t      return 1;\n-\t    }\n-\t}\n-\n-      if (reg_set_p (dst, PATTERN (p)))\n-\tbreak;\n-\n-      /* If we have passed a call instruction, and the\n-         pseudo-reg SRC is not already live across a call,\n-         then don't perform the optimization.  */\n-      /* reg_set_p is overly conservative for CALL_INSNS, thinks that all\n-\t hard regs are clobbered.  Thus, we only use it for src for\n-\t non-call insns.  */\n-      if (CALL_P (p))\n-\t{\n-\t  if (! dst_death)\n-\t    {\n-\t      num_calls++;\n-\t      freq_calls += REG_FREQ_FROM_BB  (BLOCK_FOR_INSN (p));\n-\t    }\n-\n-\t  if (REG_N_CALLS_CROSSED (REGNO (src)) == 0)\n-\t    break;\n-\n-\t  if ((HARD_REGISTER_P (dst) && call_used_regs [REGNO (dst)])\n-\t      || find_reg_fusage (p, CLOBBER, dst))\n-\t    break;\n-\t}\n-      else if (reg_set_p (src, PATTERN (p)))\n-\tbreak;\n-    }\n-\n-  return 0;\n-}\n-\n-/* A forward pass.  Replace output operands with input operands.  */\n-\n-static void\n-regmove_forward_pass (void)\n-{\n-  basic_block bb;\n-  rtx insn;\n-\n-  if (! flag_expensive_optimizations)\n-    return;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"Starting forward pass...\\n\");\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      FOR_BB_INSNS (bb, insn)\n-\t{\n-\t  rtx set = single_set (insn);\n-\t  if (! set)\n-\t    continue;\n-\n-\t  if ((GET_CODE (SET_SRC (set)) == SIGN_EXTEND\n-\t       || GET_CODE (SET_SRC (set)) == ZERO_EXTEND)\n-\t      && REG_P (XEXP (SET_SRC (set), 0))\n-\t      && REG_P (SET_DEST (set)))\n-\t    optimize_reg_copy_3 (insn, SET_DEST (set), SET_SRC (set));\n-\n-\t  if (REG_P (SET_SRC (set))\n-\t      && REG_P (SET_DEST (set)))\n-\t    {\n-\t      /* If this is a register-register copy where SRC is not dead,\n-\t\t see if we can optimize it.  If this optimization succeeds,\n-\t\t it will become a copy where SRC is dead.  */\n-\t      if ((find_reg_note (insn, REG_DEAD, SET_SRC (set))\n-\t\t   || optimize_reg_copy_1 (insn, SET_DEST (set), SET_SRC (set)))\n-\t\t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER)\n-\t\t{\n-\t\t  /* Similarly for a pseudo-pseudo copy when SRC is dead.  */\n-\t\t  if (REGNO (SET_SRC (set)) >= FIRST_PSEUDO_REGISTER)\n-\t\t    optimize_reg_copy_2 (insn, SET_DEST (set), SET_SRC (set));\n-\t\t  if (regno_src_regno[REGNO (SET_DEST (set))] < 0\n-\t\t      && SET_SRC (set) != SET_DEST (set))\n-\t\t    {\n-\t\t      int srcregno = REGNO (SET_SRC (set));\n-\t\t      if (regno_src_regno[srcregno] >= 0)\n-\t\t\tsrcregno = regno_src_regno[srcregno];\n-\t\t      regno_src_regno[REGNO (SET_DEST (set))] = srcregno;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* A backward pass.  Replace input operands with output operands.  */\n-\n-static void\n-regmove_backward_pass (void)\n-{\n-  basic_block bb;\n-  rtx insn, prev;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"Starting backward pass...\\n\");\n-\n-  FOR_EACH_BB_REVERSE (bb)\n-    {\n-      /* ??? Use the safe iterator because fixup_match_2 can remove\n-\t     insns via try_auto_increment.  */\n-      FOR_BB_INSNS_REVERSE_SAFE (bb, insn, prev)\n-\t{\n-\t  struct match match;\n-\t  rtx copy_src, copy_dst;\n-\t  int op_no, match_no;\n-\t  int success = 0;\n-\n-\t  if (! INSN_P (insn))\n-\t    continue;\n-\n-\t  if (! find_matches (insn, &match))\n-\t    continue;\n-\n-\t  /* Now scan through the operands looking for a destination operand\n-\t     which is supposed to match a source operand.\n-\t     Then scan backward for an instruction which sets the source\n-\t     operand.  If safe, then replace the source operand with the\n-\t     dest operand in both instructions.  */\n-\n-\t  copy_src = NULL_RTX;\n-\t  copy_dst = NULL_RTX;\n-\t  for (op_no = 0; op_no < recog_data.n_operands; op_no++)\n-\t    {\n-\t      rtx set, p, src, dst;\n-\t      rtx src_note, dst_note;\n-\t      int num_calls = 0, freq_calls = 0;\n-\t      enum reg_class src_class, dst_class;\n-\t      int length;\n-\n-\t      match_no = match.with[op_no];\n-\n-\t      /* Nothing to do if the two operands aren't supposed to match.  */\n-\t      if (match_no < 0)\n-\t\tcontinue;\n-\n-\t      dst = recog_data.operand[match_no];\n-\t      src = recog_data.operand[op_no];\n-\n-\t      if (!REG_P (src))\n-\t\tcontinue;\n-\n-\t      if (!REG_P (dst)\n-\t\t  || REGNO (dst) < FIRST_PSEUDO_REGISTER\n-\t\t  || REG_LIVE_LENGTH (REGNO (dst)) < 0\n-\t\t  || GET_MODE (src) != GET_MODE (dst))\n-\t\tcontinue;\n-\n-\t      /* If the operands already match, then there is nothing to do.  */\n-\t      if (operands_match_p (src, dst))\n-\t\tcontinue;\n-\n-\t      if (match.commutative[op_no] >= 0)\n-\t\t{\n-\t\t  rtx comm = recog_data.operand[match.commutative[op_no]];\n-\t\t  if (operands_match_p (comm, dst))\n-\t\t    continue;\n-\t\t}\n-\n-\t      set = single_set (insn);\n-\t      if (! set)\n-\t\tcontinue;\n-\n-\t      /* Note that single_set ignores parts of a parallel set for\n-\t\t which one of the destinations is REG_UNUSED.  We can't\n-\t\t handle that here, since we can wind up rewriting things\n-\t\t such that a single register is set twice within a single\n-\t\t parallel.  */\n-\t      if (reg_set_p (src, insn))\n-\t\tcontinue;\n-\n-\t      /* match_no/dst must be a write-only operand, and\n-\t\t operand_operand/src must be a read-only operand.  */\n-\t      if (match.use[op_no] != READ\n-\t\t  || match.use[match_no] != WRITE)\n-\t\tcontinue;\n-\n-\t      if (match.early_clobber[match_no]\n-\t\t  && count_occurrences (PATTERN (insn), src, 0) > 1)\n-\t\tcontinue;\n-\n-\t      /* Make sure match_no is the destination.  */\n-\t      if (recog_data.operand[match_no] != SET_DEST (set))\n-\t\tcontinue;\n-\n-\t      if (REGNO (src) < FIRST_PSEUDO_REGISTER)\n-\t\t{\n-\t\t  if (GET_CODE (SET_SRC (set)) == PLUS\n-\t\t      && CONST_INT_P (XEXP (SET_SRC (set), 1))\n-\t\t      && XEXP (SET_SRC (set), 0) == src\n-\t\t      && fixup_match_2 (insn, dst, src,\n-\t\t\t\t\tXEXP (SET_SRC (set), 1)))\n-\t\t    break;\n-\t\t  continue;\n-\t\t}\n-\t      src_class = reg_preferred_class (REGNO (src));\n-\t      dst_class = reg_preferred_class (REGNO (dst));\n-\n-\t      if (! (src_note = find_reg_note (insn, REG_DEAD, src)))\n-\t\t{\n-\t\t  /* We used to force the copy here like in other cases, but\n-\t\t     it produces worse code, as it eliminates no copy\n-\t\t     instructions and the copy emitted will be produced by\n-\t\t     reload anyway.  On patterns with multiple alternatives,\n-\t\t     there may be better solution available.\n-\n-\t\t     In particular this change produced slower code for numeric\n-\t\t     i387 programs.  */\n-\n-\t\t  continue;\n-\t\t}\n-\n-\t      if (! regclass_compatible_p (src_class, dst_class))\n-\t\t{\n-\t\t  if (!copy_src)\n-\t\t    {\n-\t\t      copy_src = src;\n-\t\t      copy_dst = dst;\n-\t\t    }\n-\t\t  continue;\n-\t\t}\n-\n-\t      /* Can not modify an earlier insn to set dst if this insn\n-\t\t uses an old value in the source.  */\n-\t      if (reg_overlap_mentioned_p (dst, SET_SRC (set)))\n-\t\t{\n-\t\t  if (!copy_src)\n-\t\t    {\n-\t\t      copy_src = src;\n-\t\t      copy_dst = dst;\n-\t\t    }\n-\t\t  continue;\n-\t\t}\n-\n-\t      /* If src is set once in a different basic block,\n-\t\t and is set equal to a constant, then do not use\n-\t\t it for this optimization, as this would make it\n-\t\t no longer equivalent to a constant.  */\n-\n-\t      if (reg_is_remote_constant_p (src, insn))\n-\t\t{\n-\t\t  if (!copy_src)\n-\t\t    {\n-\t\t      copy_src = src;\n-\t\t      copy_dst = dst;\n-\t\t    }\n-\t\t  continue;\n-\t\t}\n-\n-\n-\t      if (dump_file)\n-\t\tfprintf (dump_file,\n-\t\t\t \"Could fix operand %d of insn %d matching operand %d.\\n\",\n-\t\t\t op_no, INSN_UID (insn), match_no);\n-\n-\t      /* Scan backward to find the first instruction that uses\n-\t\t the input operand.  If the operand is set here, then\n-\t\t replace it in both instructions with match_no.  */\n-\n-\t      for (length = 0, p = PREV_INSN (insn); p; p = PREV_INSN (p))\n-\t\t{\n-\t\t  rtx pset;\n-\n-\t\t  if (! INSN_P (p))\n-\t\t    continue;\n-\t\t  if (BLOCK_FOR_INSN (p) != bb)\n-\t\t    break;\n-\n-\t\t  if (!DEBUG_INSN_P (p))\n-\t\t    length++;\n-\n-\t\t  /* ??? See if all of SRC is set in P.  This test is much\n-\t\t     more conservative than it needs to be.  */\n-\t\t  pset = single_set (p);\n-\t\t  if (pset && SET_DEST (pset) == src)\n-\t\t    {\n-\t\t      /* We use validate_replace_rtx, in case there\n-\t\t\t are multiple identical source operands.  All\n-\t\t\t of them have to be changed at the same time:\n-\t\t\t when validate_replace_rtx() calls\n-\t\t\t apply_change_group().  */\n-\t\t      validate_change (p, &SET_DEST (pset), dst, 1);\n-\t\t      if (validate_replace_rtx (src, dst, insn))\n-\t\t\tsuccess = 1;\n-\t\t      break;\n-\t\t    }\n-\n-\t\t  /* We can't make this change if DST is mentioned at\n-\t\t     all in P, since we are going to change its value.\n-\t\t     We can't make this change if SRC is read or\n-\t\t     partially written in P, since we are going to\n-\t\t     eliminate SRC.  However, if it's a debug insn, we\n-\t\t     can't refrain from making the change, for this\n-\t\t     would cause codegen differences, so instead we\n-\t\t     invalidate debug expressions that reference DST,\n-\t\t     and adjust references to SRC in them so that they\n-\t\t     become references to DST.  */\n-\t\t  if (reg_mentioned_p (dst, PATTERN (p)))\n-\t\t    {\n-\t\t      if (DEBUG_INSN_P (p))\n-\t\t\tvalidate_change (p, &INSN_VAR_LOCATION_LOC (p),\n-\t\t\t\t\t gen_rtx_UNKNOWN_VAR_LOC (), 1);\n-\t\t      else\n-\t\t\tbreak;\n-\t\t    }\n-\t\t  if (reg_overlap_mentioned_p (src, PATTERN (p)))\n-\t\t    {\n-\t\t      if (DEBUG_INSN_P (p))\n-\t\t\tvalidate_replace_rtx_group (src, dst, p);\n-\t\t      else\n-\t\t\tbreak;\n-\t\t    }\n-\n-\t\t  /* If we have passed a call instruction, and the\n-\t\t     pseudo-reg DST is not already live across a call,\n-\t\t     then don't perform the optimization.  */\n-\t\t  if (CALL_P (p))\n-\t\t    {\n-\t\t      num_calls++;\n-\t\t      freq_calls += REG_FREQ_FROM_BB  (BLOCK_FOR_INSN (p));\n-\n-\t\t      if (REG_N_CALLS_CROSSED (REGNO (dst)) == 0)\n-\t\t\tbreak;\n-\t\t    }\n-\t\t}\n-\n-\t      if (success)\n-\t\t{\n-\t\t  int dstno, srcno;\n-\n-\t\t  /* Remove the death note for SRC from INSN.  */\n-\t\t  remove_note (insn, src_note);\n-\t\t  /* Move the death note for SRC to P if it is used\n-\t\t     there.  */\n-\t\t  if (reg_overlap_mentioned_p (src, PATTERN (p)))\n-\t\t    {\n-\t\t      XEXP (src_note, 1) = REG_NOTES (p);\n-\t\t      REG_NOTES (p) = src_note;\n-\t\t    }\n-\t\t  /* If there is a REG_DEAD note for DST on P, then remove\n-\t\t     it, because DST is now set there.  */\n-\t\t  if ((dst_note = find_reg_note (p, REG_DEAD, dst)))\n-\t\t    remove_note (p, dst_note);\n-\n-\t\t  dstno = REGNO (dst);\n-\t\t  srcno = REGNO (src);\n-\n-\t\t  INC_REG_N_SETS (dstno, 1);\n-\t\t  INC_REG_N_SETS (srcno, -1);\n-\n-\t\t  REG_N_CALLS_CROSSED (dstno) += num_calls;\n-\t\t  REG_N_CALLS_CROSSED (srcno) -= num_calls;\n-\t\t  REG_FREQ_CALLS_CROSSED (dstno) += freq_calls;\n-\t\t  REG_FREQ_CALLS_CROSSED (srcno) -= freq_calls;\n-\n-\t\t  REG_LIVE_LENGTH (dstno) += length;\n-\t\t  if (REG_LIVE_LENGTH (srcno) >= 0)\n-\t\t    {\n-\t\t      REG_LIVE_LENGTH (srcno) -= length;\n-\t\t      /* REG_LIVE_LENGTH is only an approximation after\n-\t\t\t combine if sched is not run, so make sure that we\n-\t\t\t still have a reasonable value.  */\n-\t\t      if (REG_LIVE_LENGTH (srcno) < 2)\n-\t\t\tREG_LIVE_LENGTH (srcno) = 2;\n-\t\t    }\n-\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file,\n-\t\t\t     \"Fixed operand %d of insn %d matching operand %d.\\n\",\n-\t\t\t     op_no, INSN_UID (insn), match_no);\n-\n-\t\t  break;\n-\t\t}\n-\t      else if (num_changes_pending () > 0)\n-\t\tcancel_changes (0);\n-\t    }\n-\n-\t  /* If we weren't able to replace any of the alternatives, try an\n-\t     alternative approach of copying the source to the destination.  */\n-\t  if (!success && copy_src != NULL_RTX)\n-\t    copy_src_to_dest (insn, copy_src, copy_dst);\n-\t}\n-    }\n-}\n-\n-/* Main entry for the register move optimization.  */\n-\n-static unsigned int\n-regmove_optimize (void)\n-{\n-  int i;\n-  int nregs = max_reg_num ();\n-\n-  df_note_add_problem ();\n-  df_analyze ();\n-\n-  regstat_init_n_sets_and_refs ();\n-  regstat_compute_ri ();\n-\n-  if (flag_ira_loop_pressure)\n-    ira_set_pseudo_classes (true, dump_file);\n-\n-  regno_src_regno = XNEWVEC (int, nregs);\n-  for (i = nregs; --i >= 0; )\n-    regno_src_regno[i] = -1;\n-\n-  /* A forward pass.  Replace output operands with input operands.  */\n-  regmove_forward_pass ();\n-\n-  /* A backward pass.  Replace input operands with output operands.  */\n-  regmove_backward_pass ();\n-\n-  /* Clean up.  */\n-  free (regno_src_regno);\n-  if (reg_set_in_bb)\n-    {\n-      free (reg_set_in_bb);\n-      reg_set_in_bb = NULL;\n-    }\n-  regstat_free_n_sets_and_refs ();\n-  regstat_free_ri ();\n-  if (flag_ira_loop_pressure)\n-    free_reg_info ();\n-  return 0;\n-}\n-\n-/* Returns nonzero if INSN's pattern has matching constraints for any operand.\n-   Returns 0 if INSN can't be recognized, or if the alternative can't be\n-   determined.\n-\n-   Initialize the info in MATCHP based on the constraints.  */\n-\n-static int\n-find_matches (rtx insn, struct match *matchp)\n-{\n-  int likely_spilled[MAX_RECOG_OPERANDS];\n-  int op_no;\n-  int any_matches = 0;\n-\n-  extract_insn (insn);\n-  if (! constrain_operands (0))\n-    return 0;\n-\n-  /* Must initialize this before main loop, because the code for\n-     the commutative case may set matches for operands other than\n-     the current one.  */\n-  for (op_no = recog_data.n_operands; --op_no >= 0; )\n-    matchp->with[op_no] = matchp->commutative[op_no] = -1;\n-\n-  for (op_no = 0; op_no < recog_data.n_operands; op_no++)\n-    {\n-      const char *p;\n-      char c;\n-      int i = 0;\n-\n-      p = recog_data.constraints[op_no];\n-\n-      likely_spilled[op_no] = 0;\n-      matchp->use[op_no] = READ;\n-      matchp->early_clobber[op_no] = 0;\n-      if (*p == '=')\n-\tmatchp->use[op_no] = WRITE;\n-      else if (*p == '+')\n-\tmatchp->use[op_no] = READWRITE;\n-\n-      for (;*p && i < which_alternative; p++)\n-\tif (*p == ',')\n-\t  i++;\n-\n-      while ((c = *p) != '\\0' && c != ',')\n-\t{\n-\t  switch (c)\n-\t    {\n-\t    case '=':\n-\t      break;\n-\t    case '+':\n-\t      break;\n-\t    case '&':\n-\t      matchp->early_clobber[op_no] = 1;\n-\t      break;\n-\t    case '%':\n-\t      matchp->commutative[op_no] = op_no + 1;\n-\t      matchp->commutative[op_no + 1] = op_no;\n-\t      break;\n-\n-\t    case '0': case '1': case '2': case '3': case '4':\n-\t    case '5': case '6': case '7': case '8': case '9':\n-\t      {\n-\t\tchar *end;\n-\t\tunsigned long match_ul = strtoul (p, &end, 10);\n-\t\tint match = match_ul;\n-\n-\t\tp = end;\n-\n-\t\tif (match < op_no && likely_spilled[match])\n-\t\t  continue;\n-\t\tmatchp->with[op_no] = match;\n-\t\tany_matches = 1;\n-\t\tif (matchp->commutative[op_no] >= 0)\n-\t\t  matchp->with[matchp->commutative[op_no]] = match;\n-\t      }\n-\t    continue;\n-\n-\t  case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'h':\n-\t  case 'j': case 'k': case 'l': case 'p': case 'q': case 't': case 'u':\n-\t  case 'v': case 'w': case 'x': case 'y': case 'z': case 'A': case 'B':\n-\t  case 'C': case 'D': case 'W': case 'Y': case 'Z':\n-\t    if (targetm.class_likely_spilled_p (REG_CLASS_FROM_CONSTRAINT ((unsigned char) c, p)))\n-\t      likely_spilled[op_no] = 1;\n-\t    break;\n-\t  }\n-\t  p += CONSTRAINT_LEN (c, p);\n-\t}\n-    }\n-  return any_matches;\n-}\n-\n-\f\n-\n-static bool\n-gate_handle_regmove (void)\n-{\n-  return (optimize > 0 && flag_regmove);\n-}\n-\n-\n-namespace {\n-\n-const pass_data pass_data_regmove =\n-{\n-  RTL_PASS, /* type */\n-  \"regmove\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_gate */\n-  true, /* has_execute */\n-  TV_REGMOVE, /* tv_id */\n-  0, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_df_finish | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n-};\n-\n-class pass_regmove : public rtl_opt_pass\n-{\n-public:\n-  pass_regmove (gcc::context *ctxt)\n-    : rtl_opt_pass (pass_data_regmove, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  bool gate () { return gate_handle_regmove (); }\n-  unsigned int execute () { return regmove_optimize (); }\n-\n-}; // class pass_regmove\n-\n-} // anon namespace\n-\n-rtl_opt_pass *\n-make_pass_regmove (gcc::context *ctxt)\n-{\n-  return new pass_regmove (ctxt);\n-}"}, {"sha": "5b14bfb07999931ea3774e5135b51bce14fba8d2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -1,3 +1,23 @@\n+2013-10-30  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* gcc.target/i386/fma_double_3.c: Use pattern for\n+\tscan-assembler-times instead of just one insn name.\n+\t* gcc.target/i386/fma_double_5.c: Ditto.\n+\t* gcc.target/i386/fma_float_3.c: Ditto.\n+\t* gcc.target/i386/fma_float_5.c: Ditto.\n+\t* gcc.target/i386/l_fma_double_1.c: Ditto.\n+\t* gcc.target/i386/l_fma_double_2.c: Ditto.\n+\t* gcc.target/i386/l_fma_double_3.c: Ditto.\n+\t* gcc.target/i386/l_fma_double_4.c: Ditto.\n+\t* gcc.target/i386/l_fma_double_5.c: Ditto.\n+\t* gcc.target/i386/l_fma_double_6.c: Ditto.\n+\t* gcc.target/i386/l_fma_float_1.c: Ditto.\n+\t* gcc.target/i386/l_fma_float_2.c: Ditto.\n+\t* gcc.target/i386/l_fma_float_3.c: Ditto.\n+\t* gcc.target/i386/l_fma_float_4.c: Ditto.\n+\t* gcc.target/i386/l_fma_float_5.c: Ditto.\n+\t* gcc.target/i386/l_fma_float_6.c: Ditto.\n+\n 2013-10-30  Christian Bruel  <christian.bruel@st.com>\n \n \t* gcc.c-torture/execute/builtins/strncmp-2.c: Enable for SH."}, {"sha": "3a04777c6bfe3ef46d955f459d10ca8661d9bb56", "filename": "gcc/testsuite/gcc.target/i386/fma_double_3.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma_double_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma_double_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma_double_3.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -8,11 +8,7 @@\n \n #include \"fma_3.h\"\n \n-/* { dg-final { scan-assembler-times \"vfmadd132sd\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd231sd\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132sd\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub231sd\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132sd\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd231sd\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132sd\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub231sd\" 4  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+sd\" 8  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[132\\]+sd\" 8  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[132\\]+sd\" 8  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[132\\]+sd\" 8  } } */"}, {"sha": "640b552b0f05c5fd36bcd98a8c7ef34fa7ab9daa", "filename": "gcc/testsuite/gcc.target/i386/fma_double_5.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma_double_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma_double_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma_double_5.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -8,7 +8,7 @@\n \n #include \"fma_5.h\"\n \n-/* { dg-final { scan-assembler-times \"vfmadd132sd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132sd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132sd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132sd\" 8  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[132\\]+sd\" 8  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[132\\]+sd\" 8  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[132\\]+sd\" 8  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[132\\]+sd\" 8  } } */"}, {"sha": "7986ce4ee767d3b991b9f683af7cf7e768e5aa9e", "filename": "gcc/testsuite/gcc.target/i386/fma_float_3.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma_float_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma_float_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma_float_3.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -8,11 +8,7 @@\n \n #include \"fma_3.h\"\n \n-/* { dg-final { scan-assembler-times \"vfmadd132ss\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd231ss\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132ss\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub231ss\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132ss\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd231ss\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132ss\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub231ss\" 4  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[132\\]+ss\" 8  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[132\\]+ss\" 8  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[132\\]+ss\" 8  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[132\\]+ss\" 8  } } */"}, {"sha": "2105ae627f0ce7941e9e6373a5d5699e3b76c9a7", "filename": "gcc/testsuite/gcc.target/i386/fma_float_5.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma_float_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma_float_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma_float_5.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -8,7 +8,7 @@\n \n #include \"fma_5.h\"\n \n-/* { dg-final { scan-assembler-times \"vfmadd132ss\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132ss\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132ss\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132ss\" 8  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[132\\]+ss\" 8  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[132\\]+ss\" 8  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[132\\]+ss\" 8  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[132\\]+ss\" 8  } } */"}, {"sha": "55042f055ce3864f25a042438328bc7eb3c7199a", "filename": "gcc/testsuite/gcc.target/i386/l_fma_double_1.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_1.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -17,11 +17,7 @@ typedef double adouble __attribute__((aligned(sizeof (double))));\n /* { dg-final { scan-assembler-times \"vfnmadd231pd\" 4  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132pd\" 4  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub231pd\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132sd\" 28  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd213sd\" 28 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132sd\" 28 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub213sd\" 28 } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132sd\" 28 } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd213sd\" 28 } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132sd\" 28 } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub213sd\" 28 } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+sd\" 56  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+sd\" 56 } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+sd\" 56 } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+sd\" 56 } } */"}, {"sha": "c61c30114d6926660faf2ca9d307547f21235384", "filename": "gcc/testsuite/gcc.target/i386/l_fma_double_2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_2.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -13,7 +13,7 @@ typedef double adouble __attribute__((aligned(sizeof (double))));\n /* { dg-final { scan-assembler-times \"vfmsub132pd\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmadd132pd\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132pd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132sd\" 56  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132sd\" 56 } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132sd\" 56 } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132sd\" 56 } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+sd\" 56  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+sd\" 56 } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+sd\" 56 } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+sd\" 56 } } */"}, {"sha": "1cfaa4ae3f6c68ff816ea16755831b546a436ebd", "filename": "gcc/testsuite/gcc.target/i386/l_fma_double_3.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_3.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -17,11 +17,7 @@ typedef double adouble __attribute__((aligned(sizeof (double))));\n /* { dg-final { scan-assembler-times \"vfnmadd231pd\" 4  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132pd\" 4  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub231pd\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132sd\" 28 } } */\n-/* { dg-final { scan-assembler-times \"vfmadd213sd\" 28 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132sd\" 28 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub213sd\" 28 } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132sd\" 28 } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd213sd\" 28 } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132sd\" 28 } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub213sd\" 28 } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+sd\" 56 } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+sd\" 56 } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+sd\" 56 } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+sd\" 56 } } */"}, {"sha": "4e6353366022d6c10897bca8ac831ec8e1bfe502", "filename": "gcc/testsuite/gcc.target/i386/l_fma_double_4.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_4.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -13,7 +13,7 @@ typedef double adouble __attribute__((aligned(sizeof (double))));\n /* { dg-final { scan-assembler-times \"vfmsub132pd\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmadd132pd\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132pd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132sd\" 56 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132sd\" 56 } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132sd\" 56 } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132sd\" 56 } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+sd\" 56 } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+sd\" 56 } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+sd\" 56 } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+sd\" 56 } } */"}, {"sha": "4153cf82ce07217a1871aa7ab3558fee65d5e7e2", "filename": "gcc/testsuite/gcc.target/i386/l_fma_double_5.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_5.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -13,7 +13,7 @@ typedef double adouble __attribute__((aligned(sizeof (double))));\n /* { dg-final { scan-assembler-times \"vfmsub132pd\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmadd132pd\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132pd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132sd\" 56 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132sd\" 56  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132sd\" 56  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132sd\" 56  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+sd\" 56 } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+sd\" 56  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+sd\" 56  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+sd\" 56  } } */"}, {"sha": "ea12370d8ea716ecc5be5cf752dc3fa70d131cc6", "filename": "gcc/testsuite/gcc.target/i386/l_fma_double_6.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_6.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -13,7 +13,7 @@ typedef double adouble __attribute__((aligned(sizeof (double))));\n /* { dg-final { scan-assembler-times \"vfmsub132pd\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmadd132pd\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132pd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132sd\" 56 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132sd\" 56  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132sd\" 56  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132sd\" 56  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+sd\" 56 } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+sd\" 56  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+sd\" 56  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+sd\" 56  } } */"}, {"sha": "fa6a9334e83bf28cefb5881864b066ed47d89db8", "filename": "gcc/testsuite/gcc.target/i386/l_fma_float_1.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_1.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -16,11 +16,7 @@\n /* { dg-final { scan-assembler-times \"vfnmadd231ps\" 4  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132ps\" 4  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub231ps\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132ss\" 60 } } */\n-/* { dg-final { scan-assembler-times \"vfmadd213ss\" 60 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132ss\" 60 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub213ss\" 60 } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132ss\" 60 } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd213ss\" 60 } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132ss\" 60 } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub213ss\" 60 } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+ss\" 120 } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ss\" 120 } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ss\" 120 } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ss\" 120 } } */"}, {"sha": "1fd0a08c1f998532d33da674b1331e96ffda7a2b", "filename": "gcc/testsuite/gcc.target/i386/l_fma_float_2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_2.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -12,7 +12,7 @@\n /* { dg-final { scan-assembler-times \"vfmsub132ps\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmadd132ps\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132ps\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132ss\" 120  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132ss\" 120  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132ss\" 120  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132ss\" 120  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+ss\" 120  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ss\" 120  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ss\" 120  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ss\" 120  } } */"}, {"sha": "7bafd967308dff09872a25e5dce058c4d56b147a", "filename": "gcc/testsuite/gcc.target/i386/l_fma_float_3.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_3.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -16,11 +16,7 @@\n /* { dg-final { scan-assembler-times \"vfnmadd231ps\" 4  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132ps\" 4  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub231ps\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132ss\" 60  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd213ss\" 60  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132ss\" 60  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub213ss\" 60  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132ss\" 60  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd213ss\" 60  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132ss\" 60  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub213ss\" 60  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+ss\" 120  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ss\" 120  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ss\" 120  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ss\" 120  } } */"}, {"sha": "5a9d039de60cbbfc953723de11ad2fc9571ff919", "filename": "gcc/testsuite/gcc.target/i386/l_fma_float_4.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_4.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -12,7 +12,7 @@\n /* { dg-final { scan-assembler-times \"vfmsub132ps\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmadd132ps\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132ps\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132ss\" 120  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132ss\" 120  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132ss\" 120  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132ss\" 120  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+ss\" 120  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ss\" 120  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ss\" 120  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ss\" 120  } } */"}, {"sha": "be9909da6e7d784c24c168071ff7a873bdd5b232", "filename": "gcc/testsuite/gcc.target/i386/l_fma_float_5.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_5.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -12,7 +12,7 @@\n /* { dg-final { scan-assembler-times \"vfmsub132ps\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmadd132ps\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132ps\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132ss\" 120  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132ss\" 120  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132ss\" 120  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132ss\" 120  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+ss\" 120  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ss\" 120  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ss\" 120  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ss\" 120  } } */"}, {"sha": "9fdcfda27a270e70dae3651d8059720c1cd5b6f6", "filename": "gcc/testsuite/gcc.target/i386/l_fma_float_6.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_6.c?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -12,7 +12,7 @@\n /* { dg-final { scan-assembler-times \"vfmsub132ps\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmadd132ps\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132ps\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132ss\" 120 } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132ss\" 120  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132ss\" 120  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132ss\" 120  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd\\[123\\]+ss\" 120 } } */\n+/* { dg-final { scan-assembler-times \"vfmsub\\[123\\]+ss\" 120  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd\\[123\\]+ss\" 120  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub\\[123\\]+ss\" 120  } } */"}, {"sha": "66d61aecc4daca5758ac5a0c213d9839b9378c83", "filename": "gcc/timevar.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -221,7 +221,6 @@ DEFTIMEVAR (TV_CSE2                  , \"CSE 2\")\n DEFTIMEVAR (TV_BRANCH_PROB           , \"branch prediction\")\n DEFTIMEVAR (TV_COMBINE               , \"combiner\")\n DEFTIMEVAR (TV_IFCVT\t\t     , \"if-conversion\")\n-DEFTIMEVAR (TV_REGMOVE               , \"regmove\")\n DEFTIMEVAR (TV_MODE_SWITCH           , \"mode switching\")\n DEFTIMEVAR (TV_SMS\t\t     , \"sms modulo scheduling\")\n DEFTIMEVAR (TV_SCHED                 , \"scheduling\")"}, {"sha": "c4d09fe0821fa1a3d9fd795ba7413ff78439513f", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6d16993b9d6812f6212bce4f35547fd9e40457/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=3b6d16993b9d6812f6212bce4f35547fd9e40457", "patch": "@@ -524,7 +524,6 @@ extern rtl_opt_pass *make_pass_if_after_combine (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_ree (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_partition_blocks (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_match_asm_constraints (gcc::context *ctxt);\n-extern rtl_opt_pass *make_pass_regmove (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_split_all_insns (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_fast_rtl_byte_dce (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_lower_subreg2 (gcc::context *ctxt);"}]}