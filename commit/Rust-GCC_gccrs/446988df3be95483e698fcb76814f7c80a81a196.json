{"sha": "446988df3be95483e698fcb76814f7c80a81a196", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ2OTg4ZGYzYmU5NTQ4M2U2OThmY2I3NjgxNGY3YzgwYTgxYTE5Ng==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-02-13T12:33:15Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-02-13T12:33:15Z"}, "message": "i386.c (print_reg): Use ANY_FP_REG instead of FP_REG\n\n\t* i386.c (print_reg): Use ANY_FP_REG instead of FP_REG\n\t* i386.h (MASK_128BIT_LONG_DOUBLE): Renumber\n\t(MASK_SSE2): New.\n\t(MASK_MIX_SSE_I387): New.\n\t(TARGET_SSE): SSE2 imply SSE.\n\t(TARGET_SSE2, TARGET_MIX_SSE_I387): New.\n\t(TARGET_SWITCHES): Add \"sse2\", \"mix-sse-i387\".\n\t(enum reg_class): Add new classes.\n\t(REG_CLASS_NAMES): Likewise.\n\t(REG_CLASS_CONTENTS): Likewise.\n\t(ANY_FP_REG_P, ANY_FP_REGNO_P, SSE_REG_P, SSE_FLOAT_MODE): New macros.\n\t(REG_CLASS_FROM_LETTER): 'x' and 'y' is SSE_REGS only when SSE is\n\tsupported. Add 'Y' to be SSE_REGS when SSE2 is supported.\n\t(CLASS_MAX_NREGS): Use new macros.\n\t(REGISTER_MOVE_COST): Rewrite using SECONDARY_MEMORY_MAYBE_NEEDED.\n\t* i386.md (pushsf, movsf): Support SSE.\n\t(pushdf_nointeger, pushdf_integer, pushdf): Support SSE, update\n\tsplitters to use ANY_FP_REGNO_P.\n\t(movdf_nointeger, movdf_integer): Likewise.\n\nFrom-SVN: r39628", "tree": {"sha": "0edd07a998c9393e1ca0f6506b95add761fed9fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0edd07a998c9393e1ca0f6506b95add761fed9fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/446988df3be95483e698fcb76814f7c80a81a196", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/446988df3be95483e698fcb76814f7c80a81a196", "html_url": "https://github.com/Rust-GCC/gccrs/commit/446988df3be95483e698fcb76814f7c80a81a196", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/446988df3be95483e698fcb76814f7c80a81a196/comments", "author": null, "committer": null, "parents": [{"sha": "c26a370f757e7e9c8c7f12de0baa0920ef13ae74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c26a370f757e7e9c8c7f12de0baa0920ef13ae74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c26a370f757e7e9c8c7f12de0baa0920ef13ae74"}], "stats": {"total": 167, "additions": 121, "deletions": 46}, "files": [{"sha": "d75143ef8fc9b3a9144fd0cbca2ee33d273909ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/446988df3be95483e698fcb76814f7c80a81a196/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/446988df3be95483e698fcb76814f7c80a81a196/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=446988df3be95483e698fcb76814f7c80a81a196", "patch": "@@ -1,3 +1,25 @@\n+Tue Feb 13 13:31:33 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (print_reg): Use ANY_FP_REG instead of FP_REG\n+\t* i386.h (MASK_128BIT_LONG_DOUBLE): Renumber\n+\t(MASK_SSE2): New.\n+\t(MASK_MIX_SSE_I387): New.\n+\t(TARGET_SSE): SSE2 imply SSE.\n+\t(TARGET_SSE2, TARGET_MIX_SSE_I387): New.\n+\t(TARGET_SWITCHES): Add \"sse2\", \"mix-sse-i387\".\n+\t(enum reg_class): Add new classes.\n+\t(REG_CLASS_NAMES): Likewise.\n+\t(REG_CLASS_CONTENTS): Likewise.\n+\t(ANY_FP_REG_P, ANY_FP_REGNO_P, SSE_REG_P, SSE_FLOAT_MODE): New macros.\n+\t(REG_CLASS_FROM_LETTER): 'x' and 'y' is SSE_REGS only when SSE is\n+\tsupported. Add 'Y' to be SSE_REGS when SSE2 is supported.\n+\t(CLASS_MAX_NREGS): Use new macros.\n+\t(REGISTER_MOVE_COST): Rewrite using SECONDARY_MEMORY_MAYBE_NEEDED.\n+\t* i386.md (pushsf, movsf): Support SSE.\n+\t(pushdf_nointeger, pushdf_integer, pushdf): Support SSE, update\n+\tsplitters to use ANY_FP_REGNO_P.\n+\t(movdf_nointeger, movdf_integer): Likewise.\n+\n 2001-02-13  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* combine.c (UWIDE_SHIFT_LEFT_BY_BITS_PER_WORD): New macro."}, {"sha": "84e11b5fec87afd72323eb6cdb4a16a9f2ee4fa6", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/446988df3be95483e698fcb76814f7c80a81a196/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/446988df3be95483e698fcb76814f7c80a81a196/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=446988df3be95483e698fcb76814f7c80a81a196", "patch": "@@ -3285,7 +3285,7 @@ print_reg (x, code, file)\n     case 4:\n     case 8:\n     case 12:\n-      if (! FP_REG_P (x))\n+      if (! ANY_FP_REG_P (x))\n \tputc ('e', file);\n       /* FALLTHRU */\n     case 16:"}, {"sha": "0a1d4417aec1c15809cea9913c60c47fac8979f6", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/446988df3be95483e698fcb76814f7c80a81a196/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/446988df3be95483e698fcb76814f7c80a81a196/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=446988df3be95483e698fcb76814f7c80a81a196", "patch": "@@ -104,7 +104,9 @@ extern int target_flags;\n #define MASK_ACCUMULATE_OUTGOING_ARGS 0x00008000/* Accumulate outgoing args */\n #define MASK_MMX\t\t0x00010000\t/* Support MMX regs/builtins */\n #define MASK_SSE\t\t0x00020000\t/* Support SSE regs/builtins */\n-#define MASK_128BIT_LONG_DOUBLE 0x00040000\t/* long double size is 128bit */\n+#define MASK_SSE2\t\t0x00040000\t/* Support SSE2 regs/builtins */\n+#define MASK_128BIT_LONG_DOUBLE 0x00080000\t/* long double size is 128bit */\n+#define MASK_MIX_SSE_I387\t0x00100000\t/* Mix SSE and i387 instructions */\n \n /* Temporary codegen switches */\n #define MASK_INTEL_SYNTAX\t0x00000200\n@@ -226,7 +228,9 @@ extern const int x86_partial_reg_dependency, x86_memory_mismatch_stall;\n \n #define ASSEMBLER_DIALECT ((target_flags & MASK_INTEL_SYNTAX) != 0)\n \n-#define TARGET_SSE ((target_flags & MASK_SSE) != 0)\n+#define TARGET_SSE ((target_flags & (MASK_SSE | MASK_SSE2)) != 0)\n+#define TARGET_SSE2 ((target_flags & MASK_SSE2) != 0)\n+#define TARGET_MIX_SSE_I387 ((target_flags & MASK_MIX_SSE_I387) != 0)\n #define TARGET_MMX ((target_flags & MASK_MMX) != 0)\n \n #define TARGET_SWITCHES\t\t\t\t\t\t\t      \\\n@@ -298,9 +302,17 @@ extern const int x86_partial_reg_dependency, x86_memory_mismatch_stall;\n   { \"no-mmx\",\t\t\t-MASK_MMX,\t\t\t\t      \\\n     N_(\"Do not support MMX builtins\") },\t\t\t\t      \\\n   { \"sse\",\t\t\t MASK_SSE,\t\t\t\t      \\\n-    N_(\"Support MMX and SSE builtins\") },\t\t\t\t      \\\n+    N_(\"Support MMX and SSE builtins and code generation\") },\t\t      \\\n   { \"no-sse\",\t\t\t-MASK_SSE,\t\t\t\t      \\\n-    N_(\"Do not support MMX and SSE builtins\") },\t\t\t      \\\n+    N_(\"Do not support MMX and SSE builtins and code generation\") },\t      \\\n+  { \"sse2\",\t\t\t MASK_SSE2,\t\t\t\t      \\\n+    N_(\"Support MMX, SSE and SSE2 builtins and code generation\") },\t      \\\n+  { \"no-sse2\",\t\t\t-MASK_SSE2,\t\t\t\t      \\\n+    N_(\"Do not support MMX, SSE and SSE2 builtins and code generation\") },    \\\n+  { \"mix-sse-i387\",\t\t MASK_MIX_SSE_I387,\t\t\t      \\\n+    N_(\"Use both SSE and i387 instruction sets for floating point arithmetics\") },\\\n+  { \"nomix-sse-i387\",\t\t-MASK_MIX_SSE_I387,\t\t\t      \\\n+    N_(\"Use both SSE and i387 instruction sets for floating point arithmetics\") },\\\n   { \"128bit-long-double\",\t MASK_128BIT_LONG_DOUBLE,\t\t      \\\n     N_(\"sizeof(long double) is 16.\") },\t\t\t\t\t      \\\n   { \"96bit-long-double\",\t-MASK_128BIT_LONG_DOUBLE,\t\t      \\\n@@ -765,7 +777,8 @@ extern int ix86_arch;\n       : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)))\n \n #define VALID_SSE_REG_MODE(MODE) \\\n-    ((MODE) == TImode || (MODE) == V4SFmode || (MODE) == V4SImode)\n+    ((MODE) == TImode || (MODE) == V4SFmode || (MODE) == V4SImode \\\n+     || (MODE) == SFmode || (TARGET_SSE2 && (MODE) == DFmode))\n \n #define VALID_MMX_REG_MODE(MODE) \\\n     ((MODE) == DImode || (MODE) == V8QImode || (MODE) == V4HImode \\\n@@ -939,7 +952,12 @@ enum reg_class\n   FLOAT_REGS,\n   SSE_REGS,\n   MMX_REGS,\n-  FLOAT_INT_REGS,\t\t/* FLOAT_REGS and GENERAL_REGS.  */\n+  FP_TOP_SSE_REGS,\n+  FP_SECOND_SSE_REGS,\n+  FLOAT_SSE_REGS,\n+  FLOAT_INT_REGS,\n+  INT_SSE_REGS,\n+  FLOAT_INT_SSE_REGS,\n   ALL_REGS, LIM_REG_CLASSES\n };\n \n@@ -968,7 +986,12 @@ enum reg_class\n    \"FLOAT_REGS\",\t\t\t\\\n    \"SSE_REGS\",\t\t\t\t\\\n    \"MMX_REGS\",\t\t\t\t\\\n+   \"FP_TOP_SSE_REGS\",\t\t\t\\\n+   \"FP_SECOND_SSE_REGS\",\t\t\\\n+   \"FLOAT_SSE_REGS\",\t\t\t\\\n    \"FLOAT_INT_REGS\",\t\t\t\\\n+   \"INT_SSE_REGS\",\t\t\t\\\n+   \"FLOAT_INT_SSE_REGS\",\t\t\\\n    \"ALL_REGS\" }\n \n /* Define which registers fit in which classes.\n@@ -989,7 +1012,12 @@ enum reg_class\n     { 0xff00,  0x0 },\t\t\t/* FLOAT_REGS */\t\t\\\n { 0x1fe00000,  0x0 },\t\t\t/* SSE_REGS */\t\t\t\\\n { 0xe0000000, 0x1f },\t\t\t/* MMX_REGS */\t\t\t\\\n+{ 0x1fe00100,  0x0 },\t\t\t/* FP_TOP_SSE_REG */\t\t\\\n+{ 0x1fe00200,  0x0 },\t\t\t/* FP_SECOND_SSE_REG */\t\t\\\n+{ 0x1fe0ff00,  0x0 },\t\t\t/* FLOAT_SSE_REGS */\t\t\\\n    { 0x1ffff,  0x0 },\t\t\t/* FLOAT_INT_REGS */\t\t\\\n+{ 0x1fe100ff,  0x0 },\t\t\t/* INT_SSE_REGS */\t\t\\\n+{ 0x1fe1ffff,  0x0 },\t\t\t/* FLOAT_INT_SSE_REGS */\t\\\n { 0xffffffff, 0x1f }\t\t\t\t\t\t\t\\\n }\n \n@@ -1013,8 +1041,14 @@ enum reg_class\n \n #define FP_REG_P(X) (REG_P (X) && FP_REGNO_P (REGNO (X)))\n #define FP_REGNO_P(n) ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG)\n+#define ANY_FP_REG_P(X) (REG_P (X) && ANY_FP_REGNO_P (REGNO (X)))\n+#define ANY_FP_REGNO_P(n) (FP_REGNO_P (n) || SSE_REGNO_P (n))\n \n #define SSE_REGNO_P(n) ((n) >= FIRST_SSE_REG && (n) <= LAST_SSE_REG)\n+#define SSE_REG_P(n) (REG_P (n) && SSE_REGNO_P (REGNO (n)))\n+\n+#define SSE_FLOAT_MODE_P(m) \\\n+  ((TARGET_SSE && (m) == SFmode) || (TARGET_SSE2 && (m) == DFmode))\n \n #define MMX_REGNO_P(n) ((n) >= FIRST_MMX_REG && (n) <= LAST_MMX_REG)\n #define MMX_REG_P(xop) (REG_P (xop) && MMX_REGNO_P (REGNO (xop)))\n@@ -1058,8 +1092,9 @@ enum reg_class\n    (C) == 'b' ? BREG :\t\t\t\t\t\t\\\n    (C) == 'c' ? CREG :\t\t\t\t\t\t\\\n    (C) == 'd' ? DREG :\t\t\t\t\t\t\\\n-   (C) == 'x' ? SSE_REGS :\t\t\t\t\t\\\n-   (C) == 'y' ? MMX_REGS :\t\t\t\t\t\\\n+   (C) == 'x' ? TARGET_SSE ? SSE_REGS : NO_REGS :\t\t\\\n+   (C) == 'Y' ? TARGET_SSE2? SSE_REGS : NO_REGS :\t\t\\\n+   (C) == 'y' ? TARGET_MMX ? MMX_REGS : NO_REGS :\t\t\\\n    (C) == 'A' ? AD_REGS :\t\t\t\t\t\\\n    (C) == 'D' ? DIREG :\t\t\t\t\t\t\\\n    (C) == 'S' ? SIREG : NO_REGS)"}, {"sha": "72b242b8c6843ff1f97b30fe000ae0ee99763de5", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 55, "deletions": 37, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/446988df3be95483e698fcb76814f7c80a81a196/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/446988df3be95483e698fcb76814f7c80a81a196/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=446988df3be95483e698fcb76814f7c80a81a196", "patch": "@@ -2100,8 +2100,8 @@\n   \"ix86_expand_move (SFmode, operands); DONE;\")\n \n (define_insn \"*pushsf\"\n-  [(set (match_operand:SF 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:SF 1 \"general_no_elim_operand\" \"f#r,rFm#f\"))]\n+  [(set (match_operand:SF 0 \"push_operand\" \"=<,<,<\")\n+\t(match_operand:SF 1 \"general_no_elim_operand\" \"f#rx,rFm#fx,x\"))]\n   \"\"\n   \"*\n {\n@@ -2119,13 +2119,15 @@\n \n     case 1:\n       return \\\"push{l}\\\\t%1\\\";\n+    case 2:\n+      return \\\"#\\\";\n \n     default:\n       abort ();\n     }\n }\"\n-  [(set_attr \"type\" \"multi,push\")\n-   (set_attr \"mode\" \"SF,SI\")])\n+  [(set_attr \"type\" \"multi,push,multi\")\n+   (set_attr \"mode\" \"SF,SI,SF\")])\n \n (define_split\n   [(set (match_operand:SF 0 \"push_operand\" \"\")\n@@ -2143,13 +2145,13 @@\n (define_split\n   [(set (match_operand:SF 0 \"push_operand\" \"\")\n \t(match_operand:SF 1 \"register_operand\" \"\"))]\n-  \"FP_REGNO_P (REGNO (operands[1]))\"\n+  \"ANY_FP_REGNO_P (REGNO (operands[1]))\"\n   [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -4)))\n    (set (mem:SF (reg:SI 7)) (match_dup 1))])\n \n (define_insn \"*movsf_1\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f#r,m,f#r,r#f,m\")\n-\t(match_operand:SF 1 \"general_operand\" \"fm#r,f#r,G,rmF#f,Fr#f\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f#xr,m,f#xr,r#xf,m,x#rf,m\")\n+\t(match_operand:SF 1 \"general_operand\" \"fm#rx,f#rx,G,rmF#fx,Fr#fx,xm#rf,x#rf\"))]\n   \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n    && (reload_in_progress || reload_completed\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n@@ -2186,13 +2188,16 @@\n     case 3:\n     case 4:\n       return \\\"mov{l}\\\\t{%1, %0|%0, %1}\\\";\n+    case 5:\n+    case 6:\n+      return \\\"movss\\\\t{%1, %0|%0, %1}\\\";\n \n     default:\n       abort();\n     }\n }\"\n-  [(set_attr \"type\" \"fmov,fmov,fmov,imov,imov\")\n-   (set_attr \"mode\" \"SF,SF,SF,SI,SI\")])\n+  [(set_attr \"type\" \"fmov,fmov,fmov,imov,imov,sse,sse\")\n+   (set_attr \"mode\" \"SF,SF,SF,SI,SI,SF,SF\")])\n \n (define_split\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n@@ -2201,6 +2206,8 @@\n    && GET_CODE (operands[1]) == MEM\n    && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n    && CONSTANT_POOL_ADDRESS_P (XEXP (operands[1], 0))\n+   && !(SSE_REG_P (operands[0]) \n+        || (GET_CODE (operands[0]) == SUBREG && SSE_REG_P (operands[0])))\n    && (!(FP_REG_P (operands[0]) || \n \t (GET_CODE (operands[0]) == SUBREG\n \t  && FP_REG_P (SUBREG_REG (operands[0]))))\n@@ -2214,7 +2221,7 @@\n \t(match_operand:SF 1 \"register_operand\" \"+f\"))\n    (set (match_dup 1)\n \t(match_dup 0))]\n-  \"\"\n+  \"reload_completed || !TARGET_SSE2\"\n   \"*\n {\n   if (STACK_TOP_P (operands[0]))\n@@ -2237,8 +2244,8 @@\n ;; pattern for optimize_size too.\n \n (define_insn \"*pushdf_nointeger\"\n-  [(set (match_operand:DF 0 \"push_operand\" \"=<,<,<\")\n-\t(match_operand:DF 1 \"general_no_elim_operand\" \"f,Fo#f,*r#f\"))]\n+  [(set (match_operand:DF 0 \"push_operand\" \"=<,<,<,<\")\n+\t(match_operand:DF 1 \"general_no_elim_operand\" \"f#Y,Fo#fY,*r#fY,Y\"))]\n   \"!TARGET_INTEGER_DFMODE_MOVES\"\n   \"*\n {\n@@ -2256,18 +2263,19 @@\n \n     case 1:\n     case 2:\n+    case 3:\n       return \\\"#\\\";\n \n     default:\n       abort ();\n     }\n }\"\n   [(set_attr \"type\" \"multi\")\n-   (set_attr \"mode\" \"DF,SI,SI\")])\n+   (set_attr \"mode\" \"DF,SI,SI,DF\")])\n \n (define_insn \"*pushdf_integer\"\n-  [(set (match_operand:DF 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:DF 1 \"general_no_elim_operand\" \"f#r,rFo#f\"))]\n+  [(set (match_operand:DF 0 \"push_operand\" \"=<,<,<\")\n+\t(match_operand:DF 1 \"general_no_elim_operand\" \"f#rY,rFo#fY,Y#rf\"))]\n   \"TARGET_INTEGER_DFMODE_MOVES\"\n   \"*\n {\n@@ -2284,20 +2292,21 @@\n \treturn \\\"sub{l}\\\\t{%3, %2|%2, %3}\\;fst%z0\\\\t%y0\\\";\n \n     case 1:\n+    case 2:\n       return \\\"#\\\";\n \n     default:\n       abort ();\n     }\n }\"\n   [(set_attr \"type\" \"multi\")\n-   (set_attr \"mode\" \"DF,SI\")])\n+   (set_attr \"mode\" \"DF,SI,DF\")])\n \n ;; %%% Kill this when call knows how to work this out.\n (define_split\n   [(set (match_operand:DF 0 \"push_operand\" \"\")\n \t(match_operand:DF 1 \"register_operand\" \"\"))]\n-  \"reload_completed && FP_REGNO_P (REGNO (operands[1]))\"\n+  \"reload_completed && ANY_FP_REGNO_P (REGNO (operands[1]))\"\n   [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -8)))\n    (set (mem:DF (reg:SI 7)) (match_dup 1))]\n   \"\")\n@@ -2314,8 +2323,8 @@\n ;; when optimizing for size.\n \n (define_insn \"*movdf_nointeger\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,m,f,*r,o\")\n-\t(match_operand:DF 1 \"general_operand\" \"fm,f,G,*roF,F*r\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f#Y,m,f#Y,*r,o,Y#f,m\")\n+\t(match_operand:DF 1 \"general_operand\" \"fm#Y,f#Y,G,*roF,F*r,Ym#f,Y#f\"))]\n   \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n    && (optimize_size || !TARGET_INTEGER_DFMODE_MOVES)\n    && (reload_in_progress || reload_completed\n@@ -2353,17 +2362,20 @@\n     case 3:\n     case 4:\n       return \\\"#\\\";\n+    case 5:\n+    case 6:\n+      return \\\"movsd\\\\t{%1, %0|%0, %1}\\\";\n \n     default:\n       abort();\n     }\n }\"\n-  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi\")\n-   (set_attr \"mode\" \"DF,DF,DF,SI,SI\")])\n+  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi,sse,sse\")\n+   (set_attr \"mode\" \"DF,DF,DF,SI,SI,DF,DF\")])\n \n (define_insn \"*movdf_integer\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f#r,m,f#r,r#f,o\")\n-\t(match_operand:DF 1 \"general_operand\" \"fm#r,f#r,G,roF#f,Fr#f\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f#Yr,m,f#Yr,r#Yf,o,Y#rf,m\")\n+\t(match_operand:DF 1 \"general_operand\" \"fm#Yr,f#Yr,G,roF#Yf,Fr#Yf,Ym#rf,Y#rf\"))]\n   \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n    && !optimize_size && TARGET_INTEGER_DFMODE_MOVES\n    && (reload_in_progress || reload_completed\n@@ -2402,24 +2414,28 @@\n     case 4:\n       return \\\"#\\\";\n \n+    case 5:\n+    case 6:\n+      return \\\"movsd\\\\t{%1, %0|%0, %1}\\\";\n+\n     default:\n       abort();\n     }\n }\"\n-  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi\")\n-   (set_attr \"mode\" \"DF,DF,DF,SI,SI\")])\n+  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi,sse,sse\")\n+   (set_attr \"mode\" \"DF,DF,DF,SI,SI,DF,DF\")])\n \n (define_split\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:DF 1 \"general_operand\" \"\"))]\n   \"reload_completed\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n-   && ! (FP_REG_P (operands[0]) || \n+   && ! (ANY_FP_REG_P (operands[0]) || \n \t (GET_CODE (operands[0]) == SUBREG\n-\t  && FP_REG_P (SUBREG_REG (operands[0]))))\n-   && ! (FP_REG_P (operands[1]) || \n+\t  && ANY_FP_REG_P (SUBREG_REG (operands[0]))))\n+   && ! (ANY_FP_REG_P (operands[1]) || \n \t (GET_CODE (operands[1]) == SUBREG\n-\t  && FP_REG_P (SUBREG_REG (operands[1]))))\"\n+\t  && ANY_FP_REG_P (SUBREG_REG (operands[1]))))\"\n   [(set (match_dup 2) (match_dup 5))\n    (set (match_dup 3) (match_dup 6))]\n   \"if (ix86_split_long_move (operands)) DONE;\")\n@@ -2431,6 +2447,8 @@\n    && GET_CODE (operands[1]) == MEM\n    && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n    && CONSTANT_POOL_ADDRESS_P (XEXP (operands[1], 0))\n+   && !(SSE_REG_P (operands[0]) \n+        || (GET_CODE (operands[0]) == SUBREG && SSE_REG_P (operands[0])))\n    && standard_80387_constant_p (get_pool_constant (XEXP (operands[1], 0)))\"\n   [(set (match_dup 0)\n \t(match_dup 1))]\n@@ -2441,7 +2459,7 @@\n \t(match_operand:DF 1 \"register_operand\" \"+f\"))\n    (set (match_dup 1)\n \t(match_dup 0))]\n-  \"\"\n+  \"reload_completed || !TARGET_SSE2\"\n   \"*\n {\n   if (STACK_TOP_P (operands[0]))\n@@ -2592,21 +2610,21 @@\n    && (GET_MODE (operands[0]) == XFmode\n        || GET_MODE (operands[0]) == TFmode\n        || GET_MODE (operands[0]) == DFmode)\n-   && (!REG_P (operands[1]) || !FP_REGNO_P (REGNO (operands[1])))\"\n+   && (!REG_P (operands[1]) || !ANY_FP_REGNO_P (REGNO (operands[1])))\"\n   [(const_int 0)]\n   \"if (!ix86_split_long_move (operands)) abort (); DONE;\")\n \n (define_split\n   [(set (match_operand:XF 0 \"push_operand\" \"\")\n \t(match_operand:XF 1 \"register_operand\" \"\"))]\n-  \"FP_REGNO_P (REGNO (operands[1]))\"\n+  \"ANY_FP_REGNO_P (REGNO (operands[1]))\"\n   [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -12)))\n    (set (mem:XF (reg:SI 7)) (match_dup 1))])\n \n (define_split\n   [(set (match_operand:TF 0 \"push_operand\" \"\")\n \t(match_operand:TF 1 \"register_operand\" \"\"))]\n-  \"FP_REGNO_P (REGNO (operands[1]))\"\n+  \"ANY_FP_REGNO_P (REGNO (operands[1]))\"\n   [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -16)))\n    (set (mem:TF (reg:SI 7)) (match_dup 1))])\n \n@@ -2805,12 +2823,12 @@\n   \"reload_completed\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n    && (GET_MODE (operands[0]) == XFmode || GET_MODE (operands[0]) == TFmode)\n-   && ! (FP_REG_P (operands[0]) || \n+   && ! (ANY_FP_REG_P (operands[0]) || \n \t (GET_CODE (operands[0]) == SUBREG\n-\t  && FP_REG_P (SUBREG_REG (operands[0]))))\n-   && ! (FP_REG_P (operands[1]) || \n+\t  && ANY_FP_REG_P (SUBREG_REG (operands[0]))))\n+   && ! (ANY_FP_REG_P (operands[1]) || \n \t (GET_CODE (operands[1]) == SUBREG\n-\t  && FP_REG_P (SUBREG_REG (operands[1]))))\"\n+\t  && ANY_FP_REG_P (SUBREG_REG (operands[1]))))\"\n   [(set (match_dup 2) (match_dup 5))\n    (set (match_dup 3) (match_dup 6))\n    (set (match_dup 4) (match_dup 7))]"}]}