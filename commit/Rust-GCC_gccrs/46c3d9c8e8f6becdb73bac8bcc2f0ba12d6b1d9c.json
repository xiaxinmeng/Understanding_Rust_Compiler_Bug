{"sha": "46c3d9c8e8f6becdb73bac8bcc2f0ba12d6b1d9c", "node_id": "C_kwDOANBUbNoAKDQ2YzNkOWM4ZThmNmJlY2RiNzNiYWM4YmNjMmYwYmExMmQ2YjFkOWM", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-11-07T16:24:14Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-11-15T18:34:56Z"}, "message": "demangler: Templated lambda demangling\n\nTemplated lambdas have a template-head, which is part of their\nsignature.  GCC ABI 18 mangles that into the lambda name.  This adds\nsupport to the demangler.  We have to introduce artificial template\nparameter names, as we need to refer to them from later components of\nthe lambda signature. We use $T:n, $N:n and $TT:n for type, non-type\nand template parameters.  Non-type parameter names are not shown in\nthe strictly correct location -- for instance 'int (&NT) ()' would be\nshown as 'int (&) $N:n'.  That's unfortunate, but an orthogonal issue.\nThe 'is_lambda_arg' field is now repurposed as indicating the number\nof explicit template parameters (1-based).\n\n\tinclude/\n\t* demangle.h (enum demangle_component_type): Add\n\tDEMANGLE_COMPONENT_TEMPLATE_HEAD,\n\tDEMANGLE_COMPONENT_TEMPLATE_TYPE_PARM,\n\tDEMANGLE_COMPONENT_TEMPLATE_NON_TYPE_PARM,\n\tDEMANGLE_COMPONENT_TEMPLATE_TEMPLATE_PARM,\n\tDEMANGLE_COMPONENT_TEMPLATE_PACK_PARM.\n\tlibiberty/\n\t* cp-demangle.c (struct d_print_info): Rename is_lambda_arg to\n\tlambda_tpl_parms.  Augment semantics.\n\t(d_make_comp): Add checks for new components.\n\t(d_template_parm, d_template_head): New.\n\t(d_lambda): Add templated lambda support.\n\t(d_print_init): Adjust.\n\t(d_print_lambda_parm_name): New.\n\t(d_print_comp_inner): Support templated lambdas,\n\t* testsuite/demangle-expected: Add testcases.", "tree": {"sha": "ce741eb8aeff36b6556e824b5752c5ce63e0f10f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce741eb8aeff36b6556e824b5752c5ce63e0f10f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46c3d9c8e8f6becdb73bac8bcc2f0ba12d6b1d9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46c3d9c8e8f6becdb73bac8bcc2f0ba12d6b1d9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46c3d9c8e8f6becdb73bac8bcc2f0ba12d6b1d9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46c3d9c8e8f6becdb73bac8bcc2f0ba12d6b1d9c/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee08aa9ab4100b8774d149bb235b00bddebd4b89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee08aa9ab4100b8774d149bb235b00bddebd4b89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee08aa9ab4100b8774d149bb235b00bddebd4b89"}], "stats": {"total": 319, "additions": 295, "deletions": 24}, "files": [{"sha": "66637ebdc16791b5ba26855c50ac052cffc0594a", "filename": "include/demangle.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c3d9c8e8f6becdb73bac8bcc2f0ba12d6b1d9c/include%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c3d9c8e8f6becdb73bac8bcc2f0ba12d6b1d9c/include%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdemangle.h?ref=46c3d9c8e8f6becdb73bac8bcc2f0ba12d6b1d9c", "patch": "@@ -458,6 +458,12 @@ enum demangle_component_type\n   DEMANGLE_COMPONENT_MODULE_ENTITY,\n   DEMANGLE_COMPONENT_MODULE_INIT,\n \n+  DEMANGLE_COMPONENT_TEMPLATE_HEAD,\n+  DEMANGLE_COMPONENT_TEMPLATE_TYPE_PARM,\n+  DEMANGLE_COMPONENT_TEMPLATE_NON_TYPE_PARM,\n+  DEMANGLE_COMPONENT_TEMPLATE_TEMPLATE_PARM,\n+  DEMANGLE_COMPONENT_TEMPLATE_PACK_PARM,\n+\n   /* A builtin type with argument.  This holds the builtin type\n      information.  */\n   DEMANGLE_COMPONENT_EXTENDED_BUILTIN_TYPE"}, {"sha": "ad533f6085edefd70cb6324b54d08d7ffbe9a2a5", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 236, "deletions": 24, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c3d9c8e8f6becdb73bac8bcc2f0ba12d6b1d9c/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c3d9c8e8f6becdb73bac8bcc2f0ba12d6b1d9c/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=46c3d9c8e8f6becdb73bac8bcc2f0ba12d6b1d9c", "patch": "@@ -347,9 +347,9 @@ struct d_print_info\n   /* Number of times d_print_comp was recursively called.  Should not\n      be bigger than MAX_RECURSION_COUNT.  */\n   int recursion;\n-  /* Non-zero if we're printing a lambda argument.  A template\n-     parameter reference actually means 'auto', a pack expansion means T...  */\n-  int is_lambda_arg;\n+  /* 1 more than the number of explicit template parms of a lambda.  Template\n+     parm references >= are actually 'auto'.  */\n+  int lambda_tpl_parms;\n   /* The current index into any template argument packs we are using\n      for printing, or -1 to print the whole pack.  */\n   int pack_index;\n@@ -491,6 +491,10 @@ static struct demangle_component *d_local_name (struct d_info *);\n \n static int d_discriminator (struct d_info *);\n \n+static struct demangle_component *d_template_parm (struct d_info *, int *bad);\n+\n+static struct demangle_component *d_template_head (struct d_info *, int *bad);\n+\n static struct demangle_component *d_lambda (struct d_info *);\n \n static struct demangle_component *d_unnamed_type (struct d_info *);\n@@ -1028,6 +1032,10 @@ d_make_comp (struct d_info *di, enum demangle_component_type type,\n     case DEMANGLE_COMPONENT_TPARM_OBJ:\n     case DEMANGLE_COMPONENT_STRUCTURED_BINDING:\n     case DEMANGLE_COMPONENT_MODULE_INIT:\n+    case DEMANGLE_COMPONENT_TEMPLATE_HEAD:\n+    case DEMANGLE_COMPONENT_TEMPLATE_NON_TYPE_PARM:\n+    case DEMANGLE_COMPONENT_TEMPLATE_TEMPLATE_PARM:\n+    case DEMANGLE_COMPONENT_TEMPLATE_PACK_PARM:\n       if (left == NULL)\n \treturn NULL;\n       break;\n@@ -1050,6 +1058,7 @@ d_make_comp (struct d_info *di, enum demangle_component_type type,\n     case DEMANGLE_COMPONENT_CONST:\n     case DEMANGLE_COMPONENT_ARGLIST:\n     case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:\n+    case DEMANGLE_COMPONENT_TEMPLATE_TYPE_PARM:\n     FNQUAL_COMPONENT_CASE:\n       break;\n \n@@ -3877,32 +3886,120 @@ d_discriminator (struct d_info *di)\n   return 1;\n }\n \n-/* <closure-type-name> ::= Ul <lambda-sig> E [ <nonnegative number> ] _ */\n+/* <template-parm> ::= Ty\n+                   ::= Tn <type>\n+\t\t   ::= Tt <template-head> E\n+\t\t   ::= Tp <template-parm>  */\n \n static struct demangle_component *\n-d_lambda (struct d_info *di)\n+d_template_parm (struct d_info *di, int *bad)\n {\n-  struct demangle_component *tl;\n-  struct demangle_component *ret;\n-  int num;\n+  if (d_peek_char (di) != 'T')\n+    return NULL;\n+\n+  struct demangle_component *op;\n+  enum demangle_component_type kind;\n+  switch (d_peek_next_char (di))\n+    {\n+    default:\n+      return NULL;\n+\n+    case 'p': /* Pack  */\n+      d_advance (di, 2);\n+      op = d_template_parm (di, bad);\n+      kind = DEMANGLE_COMPONENT_TEMPLATE_PACK_PARM;\n+      if (!op)\n+\t{\n+\t  *bad = 1;\n+\t  return NULL;\n+\t}\n+      break;\n+\n+    case 'y': /* Typename  */\n+      d_advance (di, 2);\n+      op = NULL;\n+      kind = DEMANGLE_COMPONENT_TEMPLATE_TYPE_PARM;\n+      break;\n+\n+    case 'n': /* Non-Type  */\n+      d_advance (di, 2);\n+      op = cplus_demangle_type (di);\n+      kind = DEMANGLE_COMPONENT_TEMPLATE_NON_TYPE_PARM;\n+      if (!op)\n+\t{\n+\t  *bad = 1;\n+\t  return NULL;\n+\t}\n+      break;\n+\n+    case 't': /* Template */\n+      d_advance (di, 2);\n+      op = d_template_head (di, bad);\n+      kind = DEMANGLE_COMPONENT_TEMPLATE_TEMPLATE_PARM;\n+      if (!op || !d_check_char (di, 'E'))\n+\t{\n+\t  *bad = 1;\n+\t  return NULL;\n+\t}\n+    }\n+\n+  return d_make_comp (di, kind, op, NULL);\n+}\n+\n+/* <template-head> ::= <template-head>? <template-parm>  */\n+\n+static struct demangle_component *\n+d_template_head (struct d_info *di, int *bad)\n+{\n+  struct demangle_component *res = NULL, **slot = &res;\n+  struct demangle_component *op;\n+\n+  while ((op = d_template_parm (di, bad)))\n+    {\n+      *slot = op;\n+      slot = &d_right (op);\n+    }\n+\n+  /* Wrap it in a template head, to make concatenating with any parm list, and\n+     printing simpler.  */\n+  if (res)\n+    res = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE_HEAD, res, NULL);\n \n+  return res;\n+}\n+\n+/* <closure-type-name> ::= Ul <template-head>? <lambda-sig> E [ <nonnegative number> ] _ */\n+\n+static struct demangle_component *\n+d_lambda (struct d_info *di)\n+{\n   if (! d_check_char (di, 'U'))\n     return NULL;\n   if (! d_check_char (di, 'l'))\n     return NULL;\n \n-  tl = d_parmlist (di);\n+  int bad = 0;\n+  struct demangle_component *head = d_template_head (di, &bad);\n+  if (bad)\n+    return NULL;\n+\n+  struct demangle_component *tl = d_parmlist (di);\n   if (tl == NULL)\n     return NULL;\n+  if (head)\n+    {\n+      d_right (head) = tl;\n+      tl = head;\n+    }\n \n   if (! d_check_char (di, 'E'))\n     return NULL;\n \n-  num = d_compact_number (di);\n+  int num = d_compact_number (di);\n   if (num < 0)\n     return NULL;\n \n-  ret = d_make_empty (di);\n+  struct demangle_component *ret = d_make_empty (di);\n   if (ret)\n     {\n       ret->type = DEMANGLE_COMPONENT_LAMBDA;\n@@ -4254,6 +4351,11 @@ d_count_templates_scopes (struct d_print_info *dpi,\n     case DEMANGLE_COMPONENT_MODULE_PARTITION:\n     case DEMANGLE_COMPONENT_MODULE_INIT:\n     case DEMANGLE_COMPONENT_FIXED_TYPE:\n+    case DEMANGLE_COMPONENT_TEMPLATE_HEAD:\n+    case DEMANGLE_COMPONENT_TEMPLATE_TYPE_PARM:\n+    case DEMANGLE_COMPONENT_TEMPLATE_NON_TYPE_PARM:\n+    case DEMANGLE_COMPONENT_TEMPLATE_TEMPLATE_PARM:\n+    case DEMANGLE_COMPONENT_TEMPLATE_PACK_PARM:\n       break;\n \n     case DEMANGLE_COMPONENT_TEMPLATE:\n@@ -4384,7 +4486,7 @@ d_print_init (struct d_print_info *dpi, demangle_callbackref callback,\n \n   dpi->demangle_failure = 0;\n   dpi->recursion = 0;\n-  dpi->is_lambda_arg = 0;\n+  dpi->lambda_tpl_parms = 0;\n \n   dpi->component_stack = NULL;\n \n@@ -4881,6 +4983,33 @@ d_maybe_print_designated_init (struct d_print_info *dpi, int options,\n   return 1;\n }\n \n+static void\n+d_print_lambda_parm_name (struct d_print_info *dpi, int type, unsigned index)\n+{\n+  const char *str;\n+  switch (type)\n+    {\n+    default:\n+      dpi->demangle_failure = 1;\n+      str = \"\";\n+      break;\n+\n+    case DEMANGLE_COMPONENT_TEMPLATE_TYPE_PARM:\n+      str = \"$T\";\n+      break;\n+\n+    case DEMANGLE_COMPONENT_TEMPLATE_NON_TYPE_PARM:\n+      str = \"$N\";\n+      break;\n+\n+    case DEMANGLE_COMPONENT_TEMPLATE_TEMPLATE_PARM:\n+      str = \"$TT\";\n+      break;\n+    }\n+  d_append_string (dpi, str);\n+  d_append_num (dpi, index);\n+}\n+\n /* Subroutine to handle components.  */\n \n static void\n@@ -5135,7 +5264,21 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n       }\n \n     case DEMANGLE_COMPONENT_TEMPLATE_PARAM:\n-      if (dpi->is_lambda_arg)\n+      if (dpi->lambda_tpl_parms > dc->u.s_number.number + 1)\n+\t{\n+\t  const struct demangle_component *a\n+\t    = d_left (dpi->templates->template_decl);\n+\t  unsigned c;\n+\t  for (c = dc->u.s_number.number; a && c; c--)\n+\t    a = d_right (a);\n+\t  if (a && a->type == DEMANGLE_COMPONENT_TEMPLATE_PACK_PARM)\n+\t    a = d_left (a);\n+\t  if (!a)\n+\t    dpi->demangle_failure = 1;\n+\t  else\n+\t    d_print_lambda_parm_name (dpi, a->type, dc->u.s_number.number);\n+\t}\n+      else if (dpi->lambda_tpl_parms)\n \t{\n \t  /* Show the template parm index, as that's how g++ displays\n \t     these, and future proofs us against potential\n@@ -5316,7 +5459,7 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n       {\n \t/* Handle reference smashing: & + && = &.  */\n \tstruct demangle_component *sub = d_left (dc);\n-\tif (!dpi->is_lambda_arg\n+\tif (!dpi->lambda_tpl_parms\n \t    && sub->type == DEMANGLE_COMPONENT_TEMPLATE_PARAM)\n \t  {\n \t    struct d_saved_scope *scope = d_get_saved_scope (dpi, sub);\n@@ -5942,7 +6085,7 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n       {\n \tstruct demangle_component *a = NULL;\n \n-\tif (!dpi->is_lambda_arg)\n+\tif (!dpi->lambda_tpl_parms)\n \t  a = d_find_pack (dpi, d_left (dc));\n \tif (a == NULL)\n \t  {\n@@ -5994,15 +6137,50 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n       return;\n \n     case DEMANGLE_COMPONENT_LAMBDA:\n-      d_append_string (dpi, \"{lambda(\");\n-      /* Generic lambda auto parms are mangled as the template type\n-\t parm they are.  */\n-      dpi->is_lambda_arg++;\n-      d_print_comp (dpi, options, dc->u.s_unary_num.sub);\n-      dpi->is_lambda_arg--;\n-      d_append_string (dpi, \")#\");\n-      d_append_num (dpi, dc->u.s_unary_num.num + 1);\n-      d_append_char (dpi, '}');\n+      {\n+\td_append_string (dpi, \"{lambda\");\n+\tstruct demangle_component *parms = dc->u.s_unary_num.sub;\n+\tstruct d_print_template dpt;\n+\t/* Generic lambda auto parms are mangled as the (synthedic) template\n+\t   type parm they are.  We need to tell the printer that (a) we're in\n+\t   a lambda, and (b) the number of synthetic parms.  */\n+\tint saved_tpl_parms = dpi->lambda_tpl_parms;\n+\tdpi->lambda_tpl_parms = 0;\n+\t/* Hang any lambda head as-if template args.  */\n+\tdpt.template_decl = NULL;\n+\tdpt.next = dpi->templates;\n+\tdpi->templates = &dpt;\n+\tif (parms && parms->type == DEMANGLE_COMPONENT_TEMPLATE_HEAD)\n+\t  {\n+\t    dpt.template_decl = parms;\n+\n+\t    d_append_char (dpi, '<');\n+\t    struct demangle_component *parm;\n+\t    for (parm = d_left (parms); parm; parm = d_right (parm))\n+\t      {\n+\t\tif (dpi->lambda_tpl_parms++)\n+\t\t  d_append_string (dpi, \", \");\n+\t\td_print_comp (dpi, options, parm);\n+\t\td_append_char (dpi, ' ');\n+\t\tif (parm->type == DEMANGLE_COMPONENT_TEMPLATE_PACK_PARM)\n+\t\t  parm = d_left (parm);\n+\t\td_print_lambda_parm_name (dpi, parm->type,\n+\t\t\t\t\t  dpi->lambda_tpl_parms - 1);\n+\t      }\n+\t    d_append_char (dpi, '>');\n+\n+\t    parms = d_right (parms);\n+\t  }\n+\tdpi->lambda_tpl_parms++;\n+\n+\td_append_char (dpi, '(');\n+\td_print_comp (dpi, options, parms);\n+\tdpi->lambda_tpl_parms = saved_tpl_parms;\n+\tdpi->templates = dpt.next;\n+\td_append_string (dpi, \")#\");\n+\td_append_num (dpi, dc->u.s_unary_num.num + 1);\n+\td_append_char (dpi, '}');\n+      }\n       return;\n \n     case DEMANGLE_COMPONENT_UNNAMED_TYPE:\n@@ -6018,6 +6196,40 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n       d_append_char (dpi, ']');\n       return;\n \n+    case DEMANGLE_COMPONENT_TEMPLATE_HEAD:\n+      {\n+\td_append_char (dpi, '<');\n+\tint count = 0;\n+\tstruct demangle_component *parm;\n+\tfor (parm = d_left (dc); parm; parm = d_right (parm))\n+\t  {\n+\t    if (count++)\n+\t      d_append_string (dpi, \", \");\n+\t    d_print_comp (dpi, options, parm);\n+\t  }\n+\td_append_char (dpi, '>');\n+      }\n+      return;\n+\n+    case DEMANGLE_COMPONENT_TEMPLATE_TYPE_PARM:\n+      d_append_string (dpi, \"typename\");\n+      return;\n+\n+    case DEMANGLE_COMPONENT_TEMPLATE_NON_TYPE_PARM:\n+      d_print_comp (dpi, options, d_left (dc));\n+      return;\n+\n+    case DEMANGLE_COMPONENT_TEMPLATE_TEMPLATE_PARM:\n+      d_append_string (dpi, \"template\");\n+      d_print_comp (dpi, options, d_left (dc));\n+      d_append_string (dpi, \" class\");\n+      return;\n+\n+    case DEMANGLE_COMPONENT_TEMPLATE_PACK_PARM:\n+      d_print_comp (dpi, options, d_left (dc));\n+      d_append_string (dpi, \"...\");\n+      return;\n+\n     default:\n       d_print_error (dpi);\n       return;"}, {"sha": "d9bc7ed4b1fc33fde1c683202f9e4fd7fbb7e40c", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c3d9c8e8f6becdb73bac8bcc2f0ba12d6b1d9c/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c3d9c8e8f6becdb73bac8bcc2f0ba12d6b1d9c/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=46c3d9c8e8f6becdb73bac8bcc2f0ba12d6b1d9c", "patch": "@@ -1606,3 +1606,56 @@ int foo<q::{lambda()#1}, q::{lambda()#2}>(q::{lambda()#1}&&, q::{lambda()#2}&&)\n _ZNK2L1MUlDpT_E_clIJiPiEEEvS1_\n void L1::{lambda((auto:1)...)#1}::operator()<int, int*>(int, int*) const\n \n+_ZZN1XIfLj0EE2FnEvENKUlTyfT_E_clIiEEDafS1_\n+auto X<float, 0u>::Fn()::{lambda<typename $T0>(float, $T0)#1}::operator()<int>(float, int) const\n+\n+_ZZN1XIfLj0EE2FnEvENKUlTyT_E_clIiEEDaS1_\n+auto X<float, 0u>::Fn()::{lambda<typename $T0>($T0)#1}::operator()<int>(int) const\n+\n+_ZZN1XIfLj1EE2FnEvENKUlTyfT_E_clIiEEDafS1_\n+auto X<float, 1u>::Fn()::{lambda<typename $T0>(float, $T0)#1}::operator()<int>(float, int) const\n+\n+_ZZN1XIfLj1EE2FnEvENKUlTyT_E_clIiEEDaS1_\n+auto X<float, 1u>::Fn()::{lambda<typename $T0>($T0)#1}::operator()<int>(int) const\n+\n+_ZZN1XIiLj0EE2FnEvENKUlTyiT_E_clIiEEDaiS1_\n+auto X<int, 0u>::Fn()::{lambda<typename $T0>(int, $T0)#1}::operator()<int>(int, int) const\n+\n+_ZZN1XIiLj0EE2FnEvENKUlTyT_E_clIiEEDaS1_\n+auto X<int, 0u>::Fn()::{lambda<typename $T0>($T0)#1}::operator()<int>(int) const\n+\n+_ZNK10l_tpl_autoMUlTyT_T0_E_clIiiEEDaS0_S1_\n+auto l_tpl_auto::{lambda<typename $T0>($T0, auto:2)#1}::operator()<int, int>(int, int) const\n+\n+_ZNK12l_tpl_nt_aryMUlTniRAT__iE_clILi2EEEDaS1_\n+auto l_tpl_nt_ary::{lambda<int $N0>(int (&) [$N0])#1}::operator()<2>(int (&) [2]) const\n+\n+_ZNK13l_tpl_nt_autoMUlTnDavE_clILi0EEEDav\n+auto l_tpl_nt_auto::{lambda<auto $N0>()#1}::operator()<0>() const\n+\n+_ZNK9l_tpl_tplMUlTtTyTnjER3TPLIT_EE_clI1UEEDaS3_\n+auto l_tpl_tpl::{lambda<template<typename, unsigned int> class $TT0>(TPL<$TT0>&)#1}::operator()<U>(TPL<U>&) const\n+\n+_ZNK13l_tpl_tpl_tplMUlTtTtTyTnjEER6TPLTPLIT_EE_clI3TPLEEDaS3_\n+auto l_tpl_tpl_tpl::{lambda<template<template<typename, unsigned int> class> class $TT0>(TPLTPL<$TT0>&)#1}::operator()<TPL>(TPLTPL<TPL>&) const\n+\n+_ZNK5l_varMUlTpTyDpT_E_clIJiiiEEEDaS1_\n+auto l_var::{lambda<typename... $T0>(($T0)...)#1}::operator()<int, int, int>(int, int, int) const\n+\n+_ZNK6l_var2MUlTpTniDpRAT__iE_clIJLi2ELi2EEEEDaS2_\n+auto l_var2::{lambda<int... $N0>((int (&) [$N0])...)#1}::operator()<2, 2>(int (&) [2], int (&) [2]) const\n+\n+_ZNK6l_var3MUlTtTpTniETpTniRT_IJXspT0_EEEE_clI1XJLi1ELi2ELi3EEEEDaS2_\n+auto l_var3::{lambda<template<int...> class $TT0, int... $N1>($TT0<($N1)...>&)#1}::operator()<X, 1, 2, 3>(X<1, 2, 3>&) const\n+\n+_ZNK6l_var4MUlTpTtTyTnjER1YIJDpT_EEE_clIJ1US7_EEEDaS4_\n+auto l_var4::{lambda<template<typename, unsigned int> class... $TT0>(Y<($TT0)...>&)#1}::operator()<U, U>(Y<U, U>&) const\n+\n+_ZZ2FnILi1EEvvENKUlTyT_E_clIiEEDaS0_\n+auto Fn<1>()::{lambda<typename $T0>($T0)#1}::operator()<int>(int) const\n+\n+_ZZ1fvENKUlTyP1XIT_EPS_IiEE_clIcEEDaS2_S4_\n+auto f()::{lambda<typename $T0>(X<$T0>*, X<int>*)#1}::operator()<char>(X<char>*, X<int>*) const\n+\n+_ZZN1XIiE1FEvENKUliE_clEi\n+X<int>::F()::{lambda(int)#1}::operator()(int) const"}]}