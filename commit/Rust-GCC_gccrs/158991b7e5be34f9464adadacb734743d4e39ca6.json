{"sha": "158991b7e5be34f9464adadacb734743d4e39ca6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU4OTkxYjdlNWJlMzRmOTQ2NGFkYWRhY2I3MzQ3NDNkNGUzOWNhNg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-01-26T20:51:37Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-01-26T20:51:37Z"}, "message": "call.c: PROTO -> PARAMS.\n\n        * call.c: PROTO -> PARAMS.\n        * class.c: Likewise.\n        * cp-tree.h: Likewise.\n        * cvt.c: Likewise.\n        * decl.c: Likewise.\n        * decl.h: Likewise.\n        * decl2.c: Likewise.\n        * dump.c: Likewise.\n        * errfn.c: Likewise.\n        * error.c: Likewise.\n        * except.c: Likewise.\n        * expr.c: Likewise.\n        * init.c: Likewise.\n        * input.c: Likewise.\n        * lex.c: Likewise.\n        * lex.h: Likewise.\n        * method.c: Likewise.\n        * optimize.c: Likewise.\n        * parse.y: Likewise.\n        * pt.c: Likewise.\n        * repo.c: Likewise.\n        * rtti.c: Likewise.\n        * search.c: Likewise.\n        * semantics.c: Likewise.\n        * spew.c: Likewise.\n        * tree.c: Likewise.\n        * typeck.c: Likewise.\n        * typeck2.c: Likewise.\n        * xref.c: Likewise.\n\nFrom-SVN: r31632", "tree": {"sha": "d6963b0f465ce20472a59151e1711f58104f858f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6963b0f465ce20472a59151e1711f58104f858f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/158991b7e5be34f9464adadacb734743d4e39ca6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/158991b7e5be34f9464adadacb734743d4e39ca6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/158991b7e5be34f9464adadacb734743d4e39ca6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/158991b7e5be34f9464adadacb734743d4e39ca6/comments", "author": null, "committer": null, "parents": [{"sha": "5c5c34a4cb563453ca1f30af9ee6499742a39e45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c5c34a4cb563453ca1f30af9ee6499742a39e45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c5c34a4cb563453ca1f30af9ee6499742a39e45"}], "stats": {"total": 2956, "additions": 1496, "deletions": 1460}, "files": [{"sha": "7cd0cb4f600e1eee83b6bff1e7502511ff6b67f7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -1,3 +1,35 @@\n+2000-01-26  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* call.c: PROTO -> PARAMS.\n+\t* class.c: Likewise.\n+\t* cp-tree.h: Likewise.\n+\t* cvt.c: Likewise.\n+\t* decl.c: Likewise.\n+\t* decl.h: Likewise.\n+\t* decl2.c: Likewise.\n+\t* dump.c: Likewise.\n+\t* errfn.c: Likewise.\n+\t* error.c: Likewise.\n+\t* except.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* init.c: Likewise.\n+\t* input.c: Likewise.\n+\t* lex.c: Likewise.\n+\t* lex.h: Likewise.\n+\t* method.c: Likewise.\n+\t* optimize.c: Likewise.\n+\t* parse.y: Likewise.\n+\t* pt.c: Likewise.\n+\t* repo.c: Likewise.\n+\t* rtti.c: Likewise.\n+\t* search.c: Likewise.\n+\t* semantics.c: Likewise.\n+\t* spew.c: Likewise.\n+\t* tree.c: Likewise.\n+\t* typeck.c: Likewise.\n+\t* typeck2.c: Likewise.\n+\t* xref.c: Likewise.\n+\n 2000-01-25  Richard Henderson  <rth@cygnus.com>\n \n \t* typeck.c (build_binary_op_nodefault): Remove UNNE_EXPR."}, {"sha": "da320b4ffe1fc02dc1084ab91bf68506b3611e13", "filename": "gcc/cp/call.c", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -39,65 +39,65 @@ Boston, MA 02111-1307, USA.  */\n \n extern int inhibit_warnings;\n \n-static tree build_new_method_call PROTO((tree, tree, tree, tree, int));\n-\n-static tree build_field_call PROTO((tree, tree, tree, tree));\n-static struct z_candidate * tourney PROTO((struct z_candidate *));\n-static int equal_functions PROTO((tree, tree));\n-static int joust PROTO((struct z_candidate *, struct z_candidate *, int));\n-static int compare_ics PROTO((tree, tree));\n-static tree build_over_call PROTO((struct z_candidate *, tree, int));\n-static tree convert_like PROTO((tree, tree));\n-static void op_error PROTO((enum tree_code, enum tree_code, tree, tree,\n+static tree build_new_method_call PARAMS ((tree, tree, tree, tree, int));\n+\n+static tree build_field_call PARAMS ((tree, tree, tree, tree));\n+static struct z_candidate * tourney PARAMS ((struct z_candidate *));\n+static int equal_functions PARAMS ((tree, tree));\n+static int joust PARAMS ((struct z_candidate *, struct z_candidate *, int));\n+static int compare_ics PARAMS ((tree, tree));\n+static tree build_over_call PARAMS ((struct z_candidate *, tree, int));\n+static tree convert_like PARAMS ((tree, tree));\n+static void op_error PARAMS ((enum tree_code, enum tree_code, tree, tree,\n \t\t\t    tree, const char *));\n-static tree build_object_call PROTO((tree, tree));\n-static tree resolve_args PROTO((tree));\n+static tree build_object_call PARAMS ((tree, tree));\n+static tree resolve_args PARAMS ((tree));\n static struct z_candidate * build_user_type_conversion_1\n-\tPROTO ((tree, tree, int));\n-static void print_z_candidates PROTO((struct z_candidate *));\n-static tree build_this PROTO((tree));\n-static struct z_candidate * splice_viable PROTO((struct z_candidate *));\n-static int any_viable PROTO((struct z_candidate *));\n+\tPARAMS ((tree, tree, int));\n+static void print_z_candidates PARAMS ((struct z_candidate *));\n+static tree build_this PARAMS ((tree));\n+static struct z_candidate * splice_viable PARAMS ((struct z_candidate *));\n+static int any_viable PARAMS ((struct z_candidate *));\n static struct z_candidate * add_template_candidate\n-\tPROTO((struct z_candidate *, tree, tree, tree, tree, int,\n+\tPARAMS ((struct z_candidate *, tree, tree, tree, tree, int,\n \t       unification_kind_t));\n static struct z_candidate * add_template_candidate_real\n-\tPROTO((struct z_candidate *, tree, tree, tree, tree, int,\n+\tPARAMS ((struct z_candidate *, tree, tree, tree, tree, int,\n \t       tree, unification_kind_t));\n static struct z_candidate * add_template_conv_candidate \n-        PROTO((struct z_candidate *, tree, tree, tree, tree));\n+        PARAMS ((struct z_candidate *, tree, tree, tree, tree));\n static struct z_candidate * add_builtin_candidates\n-\tPROTO((struct z_candidate *, enum tree_code, enum tree_code,\n+\tPARAMS ((struct z_candidate *, enum tree_code, enum tree_code,\n \t       tree, tree *, int));\n static struct z_candidate * add_builtin_candidate\n-\tPROTO((struct z_candidate *, enum tree_code, enum tree_code,\n+\tPARAMS ((struct z_candidate *, enum tree_code, enum tree_code,\n \t       tree, tree, tree, tree *, tree *, int));\n-static int is_complete PROTO((tree));\n+static int is_complete PARAMS ((tree));\n static struct z_candidate * build_builtin_candidate \n-\tPROTO((struct z_candidate *, tree, tree, tree, tree *, tree *,\n+\tPARAMS ((struct z_candidate *, tree, tree, tree, tree *, tree *,\n \t       int));\n static struct z_candidate * add_conv_candidate \n-\tPROTO((struct z_candidate *, tree, tree, tree));\n+\tPARAMS ((struct z_candidate *, tree, tree, tree));\n static struct z_candidate * add_function_candidate \n-\tPROTO((struct z_candidate *, tree, tree, int));\n-static tree implicit_conversion PROTO((tree, tree, tree, int));\n-static tree standard_conversion PROTO((tree, tree, tree));\n-static tree reference_binding PROTO((tree, tree, tree, int));\n-static tree non_reference PROTO((tree));\n-static tree build_conv PROTO((enum tree_code, tree, tree));\n-static int is_subseq PROTO((tree, tree));\n-static int maybe_handle_ref_bind PROTO((tree*, tree*));\n-static void maybe_handle_implicit_object PROTO((tree*));\n-static struct z_candidate * add_candidate PROTO((struct z_candidate *,\n+\tPARAMS ((struct z_candidate *, tree, tree, int));\n+static tree implicit_conversion PARAMS ((tree, tree, tree, int));\n+static tree standard_conversion PARAMS ((tree, tree, tree));\n+static tree reference_binding PARAMS ((tree, tree, tree, int));\n+static tree non_reference PARAMS ((tree));\n+static tree build_conv PARAMS ((enum tree_code, tree, tree));\n+static int is_subseq PARAMS ((tree, tree));\n+static int maybe_handle_ref_bind PARAMS ((tree*, tree*));\n+static void maybe_handle_implicit_object PARAMS ((tree*));\n+static struct z_candidate * add_candidate PARAMS ((struct z_candidate *,\n \t\t\t\t\t\t tree, tree, int));\n-static tree source_type PROTO((tree));\n-static void add_warning PROTO((struct z_candidate *, struct z_candidate *));\n-static int reference_related_p PROTO ((tree, tree));\n-static int reference_compatible_p PROTO ((tree, tree));\n-static tree convert_class_to_reference PROTO ((tree, tree, tree));\n-static tree direct_reference_binding PROTO ((tree, tree));\n-static int promoted_arithmetic_type_p PROTO ((tree));\n-static tree conditional_conversion PROTO ((tree, tree));\n+static tree source_type PARAMS ((tree));\n+static void add_warning PARAMS ((struct z_candidate *, struct z_candidate *));\n+static int reference_related_p PARAMS ((tree, tree));\n+static int reference_compatible_p PARAMS ((tree, tree));\n+static tree convert_class_to_reference PARAMS ((tree, tree, tree));\n+static tree direct_reference_binding PARAMS ((tree, tree));\n+static int promoted_arithmetic_type_p PARAMS ((tree));\n+static tree conditional_conversion PARAMS ((tree, tree));\n \n tree\n build_vfield_ref (datum, type)"}, {"sha": "e7b11f9546901edd67cf40dc182cd8cbfc894432", "filename": "gcc/cp/class.c", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -41,7 +41,7 @@ Boston, MA 02111-1307, USA.  */\n    same.  */\n #define SAME_FN(FN1DECL, FN2DECL) (DECL_ASSEMBLER_NAME (FN1DECL) == DECL_ASSEMBLER_NAME (FN2DECL))\n \n-extern void set_class_shadows PROTO ((tree));\n+extern void set_class_shadows PARAMS ((tree));\n \n /* The number of nested classes being processed.  If we are not in the\n    scope of any class, this is zero.  */\n@@ -72,87 +72,87 @@ typedef struct class_stack_node {\n static int current_class_stack_size;\n static class_stack_node_t current_class_stack;\n \n-static tree get_vfield_name PROTO((tree));\n-static void finish_struct_anon PROTO((tree));\n-static tree build_vbase_pointer PROTO((tree, tree));\n-static tree build_vtable_entry PROTO((tree, tree));\n-static tree get_vtable_name PROTO((tree));\n-static tree get_derived_offset PROTO((tree, tree));\n-static tree get_basefndecls PROTO((tree, tree));\n-static void set_rtti_entry PROTO((tree, tree, tree));\n-static void build_vtable PROTO((tree, tree));\n-static void prepare_fresh_vtable PROTO((tree, tree));\n-static tree dfs_fixup_vtable_deltas PROTO((tree, void *));\n-static tree dfs_finish_vtbls PROTO((tree, void *));\n-static void finish_vtbls PROTO((tree));\n-static void modify_vtable_entry PROTO((tree, tree, tree));\n-static tree get_vtable_entry_n PROTO((tree, unsigned HOST_WIDE_INT));\n-static void add_virtual_function PROTO((tree *, tree *, int *, tree, tree));\n-static tree delete_duplicate_fields_1 PROTO((tree, tree));\n-static void delete_duplicate_fields PROTO((tree));\n-static void finish_struct_bits PROTO((tree));\n-static int alter_access PROTO((tree, tree, tree, tree));\n-static void handle_using_decl PROTO((tree, tree));\n-static int overrides PROTO((tree, tree));\n-static int strictly_overrides PROTO((tree, tree));\n-static void merge_overrides PROTO((tree, tree, int, tree));\n-static void override_one_vtable PROTO((tree, tree, tree));\n-static void mark_overriders PROTO((tree, tree));\n-static void check_for_override PROTO((tree, tree));\n-static tree dfs_get_class_offset PROTO((tree, void *));\n-static tree get_class_offset PROTO((tree, tree, tree, tree));\n-static void modify_one_vtable PROTO((tree, tree, tree));\n-static tree dfs_modify_vtables PROTO((tree, void *));\n-static tree modify_all_vtables PROTO((tree, int *, tree));\n-static void determine_primary_base PROTO((tree, int *));\n-static void finish_struct_methods PROTO((tree));\n-static void maybe_warn_about_overly_private_class PROTO ((tree));\n-static int field_decl_cmp PROTO ((const tree *, const tree *));\n-static int method_name_cmp PROTO ((const tree *, const tree *));\n-static tree add_implicitly_declared_members PROTO((tree, int, int, int));\n-static tree fixed_type_or_null PROTO((tree, int *));\n-static tree resolve_address_of_overloaded_function PROTO((tree, tree, int,\n+static tree get_vfield_name PARAMS ((tree));\n+static void finish_struct_anon PARAMS ((tree));\n+static tree build_vbase_pointer PARAMS ((tree, tree));\n+static tree build_vtable_entry PARAMS ((tree, tree));\n+static tree get_vtable_name PARAMS ((tree));\n+static tree get_derived_offset PARAMS ((tree, tree));\n+static tree get_basefndecls PARAMS ((tree, tree));\n+static void set_rtti_entry PARAMS ((tree, tree, tree));\n+static void build_vtable PARAMS ((tree, tree));\n+static void prepare_fresh_vtable PARAMS ((tree, tree));\n+static tree dfs_fixup_vtable_deltas PARAMS ((tree, void *));\n+static tree dfs_finish_vtbls PARAMS ((tree, void *));\n+static void finish_vtbls PARAMS ((tree));\n+static void modify_vtable_entry PARAMS ((tree, tree, tree));\n+static tree get_vtable_entry_n PARAMS ((tree, unsigned HOST_WIDE_INT));\n+static void add_virtual_function PARAMS ((tree *, tree *, int *, tree, tree));\n+static tree delete_duplicate_fields_1 PARAMS ((tree, tree));\n+static void delete_duplicate_fields PARAMS ((tree));\n+static void finish_struct_bits PARAMS ((tree));\n+static int alter_access PARAMS ((tree, tree, tree, tree));\n+static void handle_using_decl PARAMS ((tree, tree));\n+static int overrides PARAMS ((tree, tree));\n+static int strictly_overrides PARAMS ((tree, tree));\n+static void merge_overrides PARAMS ((tree, tree, int, tree));\n+static void override_one_vtable PARAMS ((tree, tree, tree));\n+static void mark_overriders PARAMS ((tree, tree));\n+static void check_for_override PARAMS ((tree, tree));\n+static tree dfs_get_class_offset PARAMS ((tree, void *));\n+static tree get_class_offset PARAMS ((tree, tree, tree, tree));\n+static void modify_one_vtable PARAMS ((tree, tree, tree));\n+static tree dfs_modify_vtables PARAMS ((tree, void *));\n+static tree modify_all_vtables PARAMS ((tree, int *, tree));\n+static void determine_primary_base PARAMS ((tree, int *));\n+static void finish_struct_methods PARAMS ((tree));\n+static void maybe_warn_about_overly_private_class PARAMS ((tree));\n+static int field_decl_cmp PARAMS ((const tree *, const tree *));\n+static int method_name_cmp PARAMS ((const tree *, const tree *));\n+static tree add_implicitly_declared_members PARAMS ((tree, int, int, int));\n+static tree fixed_type_or_null PARAMS ((tree, int *));\n+static tree resolve_address_of_overloaded_function PARAMS ((tree, tree, int,\n \t\t\t\t\t\t\t  int, tree));\n-static void build_vtable_entry_ref PROTO((tree, tree, tree));\n-static tree build_vtable_entry_for_fn PROTO((tree, tree));\n-static tree build_vtbl_initializer PROTO((tree, tree));\n-static int count_fields PROTO((tree));\n-static int add_fields_to_vec PROTO((tree, tree, int));\n-static void check_bitfield_decl PROTO((tree));\n-static void check_field_decl PROTO((tree, tree, int *, int *, int *, int *));\n-static void check_field_decls PROTO((tree, tree *, int *, int *, int *, \n+static void build_vtable_entry_ref PARAMS ((tree, tree, tree));\n+static tree build_vtable_entry_for_fn PARAMS ((tree, tree));\n+static tree build_vtbl_initializer PARAMS ((tree, tree));\n+static int count_fields PARAMS ((tree));\n+static int add_fields_to_vec PARAMS ((tree, tree, int));\n+static void check_bitfield_decl PARAMS ((tree));\n+static void check_field_decl PARAMS ((tree, tree, int *, int *, int *, int *));\n+static void check_field_decls PARAMS ((tree, tree *, int *, int *, int *, \n \t\t\t\t     int *));\n-static int avoid_overlap PROTO((tree, tree, int *));\n-static tree build_base_field PROTO((tree, tree, int *, int *, unsigned int *));\n-static tree build_base_fields PROTO((tree, int *));\n-static tree build_vbase_pointer_fields PROTO((tree, int *));\n-static tree build_vtbl_or_vbase_field PROTO((tree, tree, tree, tree, int *));\n-static void check_methods PROTO((tree));\n-static void remove_zero_width_bit_fields PROTO((tree));\n-static void check_bases PROTO((tree, int *, int *, int *));\n-static void check_bases_and_members PROTO((tree, int *));\n-static void create_vtable_ptr PROTO((tree, int *, int *, tree *, tree *));\n-static void layout_class_type PROTO((tree, int *, int *, tree *, tree *));\n-static void fixup_pending_inline PROTO((struct pending_inline *));\n-static void fixup_inline_methods PROTO((tree));\n-static void set_primary_base PROTO((tree, int, int *));\n-static tree dfs_propagate_binfo_offsets PROTO((tree, void *));\n-static void propagate_binfo_offsets PROTO((tree, tree));\n-static void layout_basetypes PROTO((tree));\n-static void layout_virtual_bases PROTO((tree));\n-static void remove_base_field PROTO((tree, tree, tree *));\n-static void remove_base_fields PROTO((tree));\n-static tree dfs_set_offset_for_shared_vbases PROTO((tree, void *));\n-static tree dfs_set_offset_for_unshared_vbases PROTO((tree, void *));\n-static tree dfs_build_vbase_offset_vtbl_entries PROTO((tree, void *));\n-static tree build_vbase_offset_vtbl_entries PROTO((tree, tree));\n-static tree dfs_vcall_offset_queue_p PROTO((tree, void *));\n-static tree dfs_build_vcall_offset_vtbl_entries PROTO((tree, void *));\n-static tree build_vcall_offset_vtbl_entries PROTO((tree, tree));\n-static tree dfs_count_virtuals PROTO((tree, void *));\n-static void start_vtable PROTO((tree, int *));\n-static void layout_vtable_decl PROTO((tree, int));\n-static int num_vfun_entries PROTO((tree));\n+static int avoid_overlap PARAMS ((tree, tree, int *));\n+static tree build_base_field PARAMS ((tree, tree, int *, int *, unsigned int *));\n+static tree build_base_fields PARAMS ((tree, int *));\n+static tree build_vbase_pointer_fields PARAMS ((tree, int *));\n+static tree build_vtbl_or_vbase_field PARAMS ((tree, tree, tree, tree, int *));\n+static void check_methods PARAMS ((tree));\n+static void remove_zero_width_bit_fields PARAMS ((tree));\n+static void check_bases PARAMS ((tree, int *, int *, int *));\n+static void check_bases_and_members PARAMS ((tree, int *));\n+static void create_vtable_ptr PARAMS ((tree, int *, int *, tree *, tree *));\n+static void layout_class_type PARAMS ((tree, int *, int *, tree *, tree *));\n+static void fixup_pending_inline PARAMS ((struct pending_inline *));\n+static void fixup_inline_methods PARAMS ((tree));\n+static void set_primary_base PARAMS ((tree, int, int *));\n+static tree dfs_propagate_binfo_offsets PARAMS ((tree, void *));\n+static void propagate_binfo_offsets PARAMS ((tree, tree));\n+static void layout_basetypes PARAMS ((tree));\n+static void layout_virtual_bases PARAMS ((tree));\n+static void remove_base_field PARAMS ((tree, tree, tree *));\n+static void remove_base_fields PARAMS ((tree));\n+static tree dfs_set_offset_for_shared_vbases PARAMS ((tree, void *));\n+static tree dfs_set_offset_for_unshared_vbases PARAMS ((tree, void *));\n+static tree dfs_build_vbase_offset_vtbl_entries PARAMS ((tree, void *));\n+static tree build_vbase_offset_vtbl_entries PARAMS ((tree, tree));\n+static tree dfs_vcall_offset_queue_p PARAMS ((tree, void *));\n+static tree dfs_build_vcall_offset_vtbl_entries PARAMS ((tree, void *));\n+static tree build_vcall_offset_vtbl_entries PARAMS ((tree, tree));\n+static tree dfs_count_virtuals PARAMS ((tree, void *));\n+static void start_vtable PARAMS ((tree, int *));\n+static void layout_vtable_decl PARAMS ((tree, int));\n+static int num_vfun_entries PARAMS ((tree));\n \n /* Variables shared between class.c and call.c.  */\n "}, {"sha": "062586c38c1fb2b116f1695961b135fffa04415a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 800, "deletions": 800, "changes": 1600, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -1135,7 +1135,7 @@ extern int flag_access_control;\n    after the file has been completely parsed.  The argument will be\n    the GLOBAL_NAMESPACE.  */\n \n-extern void (*back_end_hook) PROTO((tree));\n+extern void (*back_end_hook) PARAMS ((tree));\n \n \f\n /* C++ language-specific tree codes.  */\n@@ -2954,44 +2954,44 @@ extern int warn_multichar;\n extern int warn_nontemplate_friend;\n \n /* in c-common.c */\n-extern void declare_function_name               PROTO((void));\n-extern void decl_attributes                     PROTO((tree, tree, tree));\n-extern void init_function_format_info\t\tPROTO((void));\n-extern void record_function_format\t\tPROTO((tree, tree, int, int, int));\n-extern void check_function_format\t\tPROTO((tree, tree, tree));\n+extern void declare_function_name               PARAMS ((void));\n+extern void decl_attributes                     PARAMS ((tree, tree, tree));\n+extern void init_function_format_info\t\tPARAMS ((void));\n+extern void record_function_format\t\tPARAMS ((tree, tree, int, int, int));\n+extern void check_function_format\t\tPARAMS ((tree, tree, tree));\n /* Print an error message for invalid operands to arith operation CODE.\n    NOP_EXPR is used as a special case (see truthvalue_conversion).  */\n-extern void binary_op_error                     PROTO((enum tree_code));\n-extern tree canonical_type_variant              PROTO((tree));\n-extern void c_expand_expr_stmt                  PROTO((tree));\n+extern void binary_op_error                     PARAMS ((enum tree_code));\n+extern tree canonical_type_variant              PARAMS ((tree));\n+extern void c_expand_expr_stmt                  PARAMS ((tree));\n /* Validate the expression after `case' and apply default promotions.  */\n-extern tree check_case_value                    PROTO((tree));\n+extern tree check_case_value                    PARAMS ((tree));\n /* Concatenate a list of STRING_CST nodes into one STRING_CST.  */\n-extern tree combine_strings                     PROTO((tree));\n-extern void constant_expression_warning         PROTO((tree));\n-extern tree convert_and_check\t\t\tPROTO((tree, tree));\n-extern void overflow_warning\t\t\tPROTO((tree));\n-extern void unsigned_conversion_warning\t\tPROTO((tree, tree));\n-extern void c_apply_type_quals_to_decl          PROTO((int, tree));\n+extern tree combine_strings                     PARAMS ((tree));\n+extern void constant_expression_warning         PARAMS ((tree));\n+extern tree convert_and_check\t\t\tPARAMS ((tree, tree));\n+extern void overflow_warning\t\t\tPARAMS ((tree));\n+extern void unsigned_conversion_warning\t\tPARAMS ((tree, tree));\n+extern void c_apply_type_quals_to_decl          PARAMS ((int, tree));\n \n /* Read the rest of the current #-directive line.  */\n #if USE_CPPLIB\n-extern char *get_directive_line                 PROTO((void));\n+extern char *get_directive_line                 PARAMS ((void));\n #define GET_DIRECTIVE_LINE() get_directive_line ()\n #else\n-extern char *get_directive_line                 PROTO((FILE *));\n+extern char *get_directive_line                 PARAMS ((FILE *));\n #define GET_DIRECTIVE_LINE() get_directive_line (finput)\n #endif\n /* Subroutine of build_binary_op, used for comparison operations.\n    See if the operands have both been converted from subword integer types\n    and, if so, perhaps change them both back to their original type.  */\n-extern tree shorten_compare                     PROTO((tree *, tree *, tree *, enum tree_code *));\n+extern tree shorten_compare                     PARAMS ((tree *, tree *, tree *, enum tree_code *));\n /* Prepare expr to be an argument of a TRUTH_NOT_EXPR,\n    or validate its data type for an `if' or `while' statement or ?..: exp.  */\n-extern tree truthvalue_conversion               PROTO((tree));\n-extern tree type_for_mode                       PROTO((enum machine_mode, int));\n-extern tree type_for_size                       PROTO((unsigned, int));\n-extern int c_get_alias_set                      PROTO((tree));\n+extern tree truthvalue_conversion               PARAMS ((tree));\n+extern tree type_for_mode                       PARAMS ((enum machine_mode, int));\n+extern tree type_for_size                       PARAMS ((unsigned, int));\n+extern int c_get_alias_set                      PARAMS ((tree));\n \n /* in decl{2}.c */\n /* A node that is a list (length 1) of error_mark_nodes.  */\n@@ -3033,7 +3033,7 @@ struct tinst_level\n   struct tinst_level *next;\n };\n \n-extern void maybe_print_template_context\tPROTO ((void));\n+extern void maybe_print_template_context\tPARAMS ((void));\n \n /* in class.c */\n \n@@ -3477,869 +3477,869 @@ enum tree_string_flags\n extern const char **opname_tab, **assignop_tab;\n \f\n /* in call.c */\n-extern int check_dtor_name\t\t\tPROTO((tree, tree));\n-extern int get_arglist_len_in_bytes\t\tPROTO((tree));\n-\n-extern tree build_vfield_ref\t\t\tPROTO((tree, tree));\n-extern tree resolve_scope_to_name\t\tPROTO((tree, tree));\n-extern tree build_scoped_method_call\t\tPROTO((tree, tree, tree, tree));\n-extern tree build_addr_func\t\t\tPROTO((tree));\n-extern tree build_call\t\t\t\tPROTO((tree, tree, tree));\n-extern tree build_method_call\t\t\tPROTO((tree, tree, tree, tree, int));\n-extern int null_ptr_cst_p\t\t\tPROTO((tree));\n-extern tree type_decays_to\t\t\tPROTO((tree));\n-extern tree build_user_type_conversion\t\tPROTO((tree, tree, int));\n-extern tree build_new_function_call\t\tPROTO((tree, tree));\n-extern tree build_new_op\t\t\tPROTO((enum tree_code, int, tree, tree, tree));\n-extern tree build_op_new_call\t\t\tPROTO((enum tree_code, tree, tree, int));\n-extern tree build_op_delete_call\t\tPROTO((enum tree_code, tree, tree, int, tree));\n-extern int can_convert\t\t\t\tPROTO((tree, tree));\n-extern int can_convert_arg\t\t\tPROTO((tree, tree, tree));\n-extern int enforce_access                       PROTO((tree, tree));\n-extern tree convert_default_arg                 PROTO((tree, tree, tree));\n-extern tree convert_arg_to_ellipsis             PROTO((tree));\n-extern tree build_x_va_arg                      PROTO((tree, tree));\n-extern tree convert_type_from_ellipsis          PROTO((tree));\n-extern int is_properly_derived_from             PROTO((tree, tree));\n-extern tree initialize_reference                PROTO((tree, tree));\n-extern tree strip_top_quals                     PROTO((tree));\n-extern tree perform_implicit_conversion         PROTO((tree, tree));\n+extern int check_dtor_name\t\t\tPARAMS ((tree, tree));\n+extern int get_arglist_len_in_bytes\t\tPARAMS ((tree));\n+\n+extern tree build_vfield_ref\t\t\tPARAMS ((tree, tree));\n+extern tree resolve_scope_to_name\t\tPARAMS ((tree, tree));\n+extern tree build_scoped_method_call\t\tPARAMS ((tree, tree, tree, tree));\n+extern tree build_addr_func\t\t\tPARAMS ((tree));\n+extern tree build_call\t\t\t\tPARAMS ((tree, tree, tree));\n+extern tree build_method_call\t\t\tPARAMS ((tree, tree, tree, tree, int));\n+extern int null_ptr_cst_p\t\t\tPARAMS ((tree));\n+extern tree type_decays_to\t\t\tPARAMS ((tree));\n+extern tree build_user_type_conversion\t\tPARAMS ((tree, tree, int));\n+extern tree build_new_function_call\t\tPARAMS ((tree, tree));\n+extern tree build_new_op\t\t\tPARAMS ((enum tree_code, int, tree, tree, tree));\n+extern tree build_op_new_call\t\t\tPARAMS ((enum tree_code, tree, tree, int));\n+extern tree build_op_delete_call\t\tPARAMS ((enum tree_code, tree, tree, int, tree));\n+extern int can_convert\t\t\t\tPARAMS ((tree, tree));\n+extern int can_convert_arg\t\t\tPARAMS ((tree, tree, tree));\n+extern int enforce_access                       PARAMS ((tree, tree));\n+extern tree convert_default_arg                 PARAMS ((tree, tree, tree));\n+extern tree convert_arg_to_ellipsis             PARAMS ((tree));\n+extern tree build_x_va_arg                      PARAMS ((tree, tree));\n+extern tree convert_type_from_ellipsis          PARAMS ((tree));\n+extern int is_properly_derived_from             PARAMS ((tree, tree));\n+extern tree initialize_reference                PARAMS ((tree, tree));\n+extern tree strip_top_quals                     PARAMS ((tree));\n+extern tree perform_implicit_conversion         PARAMS ((tree, tree));\n \n /* in class.c */\n-extern tree build_vbase_path\t\t\tPROTO((enum tree_code, tree, tree, tree, int));\n-extern tree build_vtbl_ref\t\t\tPROTO((tree, tree));\n-extern tree build_vfn_ref\t\t\tPROTO((tree *, tree, tree));\n-extern tree get_vtable_decl                     PROTO((tree, int));\n-extern void add_method\t\t\t\tPROTO((tree, tree *, tree));\n-extern int currently_open_class\t\t\tPROTO((tree));\n-extern tree get_vfield_offset\t\t\tPROTO((tree));\n-extern void duplicate_tag_error\t\t\tPROTO((tree));\n-extern tree finish_struct\t\t\tPROTO((tree, tree));\n-extern void finish_struct_1\t\t\tPROTO((tree));\n-extern int resolves_to_fixed_type_p\t\tPROTO((tree, int *));\n-extern void init_class_processing\t\tPROTO((void));\n-extern int is_empty_class\t\t\tPROTO((tree));\n-extern void pushclass\t\t\t\tPROTO((tree, int));\n-extern void popclass\t\t\t\tPROTO((void));\n-extern void push_nested_class\t\t\tPROTO((tree, int));\n-extern void pop_nested_class\t\t\tPROTO((void));\n-extern void push_lang_context\t\t\tPROTO((tree));\n-extern void pop_lang_context\t\t\tPROTO((void));\n-extern tree instantiate_type\t\t\tPROTO((tree, tree, int));\n-extern void print_class_statistics\t\tPROTO((void));\n-extern tree skip_rtti_stuff\t                PROTO((tree, tree, unsigned HOST_WIDE_INT *));\n-extern void build_self_reference\t\tPROTO((void));\n-extern void warn_hidden\t\t\t\tPROTO((tree));\n-extern tree get_enclosing_class\t\t\tPROTO((tree));\n-int is_base_of_enclosing_class\t\t\tPROTO((tree, tree));\n-extern void unreverse_member_declarations       PROTO((tree));\n-extern void invalidate_class_lookup_cache       PROTO((void));\n-extern void maybe_note_name_used_in_class       PROTO((tree, tree));\n-extern void note_name_declared_in_class         PROTO((tree, tree));\n-extern tree num_extra_vtbl_entries              PROTO((tree));\n-extern tree size_extra_vtbl_entries             PROTO((tree));\n+extern tree build_vbase_path\t\t\tPARAMS ((enum tree_code, tree, tree, tree, int));\n+extern tree build_vtbl_ref\t\t\tPARAMS ((tree, tree));\n+extern tree build_vfn_ref\t\t\tPARAMS ((tree *, tree, tree));\n+extern tree get_vtable_decl                     PARAMS ((tree, int));\n+extern void add_method\t\t\t\tPARAMS ((tree, tree *, tree));\n+extern int currently_open_class\t\t\tPARAMS ((tree));\n+extern tree get_vfield_offset\t\t\tPARAMS ((tree));\n+extern void duplicate_tag_error\t\t\tPARAMS ((tree));\n+extern tree finish_struct\t\t\tPARAMS ((tree, tree));\n+extern void finish_struct_1\t\t\tPARAMS ((tree));\n+extern int resolves_to_fixed_type_p\t\tPARAMS ((tree, int *));\n+extern void init_class_processing\t\tPARAMS ((void));\n+extern int is_empty_class\t\t\tPARAMS ((tree));\n+extern void pushclass\t\t\t\tPARAMS ((tree, int));\n+extern void popclass\t\t\t\tPARAMS ((void));\n+extern void push_nested_class\t\t\tPARAMS ((tree, int));\n+extern void pop_nested_class\t\t\tPARAMS ((void));\n+extern void push_lang_context\t\t\tPARAMS ((tree));\n+extern void pop_lang_context\t\t\tPARAMS ((void));\n+extern tree instantiate_type\t\t\tPARAMS ((tree, tree, int));\n+extern void print_class_statistics\t\tPARAMS ((void));\n+extern tree skip_rtti_stuff\t                PARAMS ((tree, tree, unsigned HOST_WIDE_INT *));\n+extern void build_self_reference\t\tPARAMS ((void));\n+extern void warn_hidden\t\t\t\tPARAMS ((tree));\n+extern tree get_enclosing_class\t\t\tPARAMS ((tree));\n+int is_base_of_enclosing_class\t\t\tPARAMS ((tree, tree));\n+extern void unreverse_member_declarations       PARAMS ((tree));\n+extern void invalidate_class_lookup_cache       PARAMS ((void));\n+extern void maybe_note_name_used_in_class       PARAMS ((tree, tree));\n+extern void note_name_declared_in_class         PARAMS ((tree, tree));\n+extern tree num_extra_vtbl_entries              PARAMS ((tree));\n+extern tree size_extra_vtbl_entries             PARAMS ((tree));\n \n /* in cvt.c */\n-extern tree convert_to_reference\t\tPROTO((tree, tree, int, int, tree));\n-extern tree convert_from_reference\t\tPROTO((tree));\n-extern tree convert_pointer_to_real\t\tPROTO((tree, tree));\n-extern tree convert_pointer_to\t\t\tPROTO((tree, tree));\n-extern tree ocp_convert\t\t\t\tPROTO((tree, tree, int, int));\n-extern tree cp_convert\t\t\t\tPROTO((tree, tree));\n-extern tree convert_to_void\t\t\tPROTO((tree, const char */*implicit context*/));\n-extern tree convert\t\t\t\tPROTO((tree, tree));\n-extern tree convert_force\t\t\tPROTO((tree, tree, int));\n-extern tree build_type_conversion\t\tPROTO((tree, tree, int));\n-extern tree build_expr_type_conversion\t\tPROTO((int, tree, int));\n-extern tree type_promotes_to\t\t\tPROTO((tree));\n-extern tree perform_qualification_conversions   PROTO((tree, tree));\n+extern tree convert_to_reference\t\tPARAMS ((tree, tree, int, int, tree));\n+extern tree convert_from_reference\t\tPARAMS ((tree));\n+extern tree convert_pointer_to_real\t\tPARAMS ((tree, tree));\n+extern tree convert_pointer_to\t\t\tPARAMS ((tree, tree));\n+extern tree ocp_convert\t\t\t\tPARAMS ((tree, tree, int, int));\n+extern tree cp_convert\t\t\t\tPARAMS ((tree, tree));\n+extern tree convert_to_void\t\t\tPARAMS ((tree, const char */*implicit context*/));\n+extern tree convert\t\t\t\tPARAMS ((tree, tree));\n+extern tree convert_force\t\t\tPARAMS ((tree, tree, int));\n+extern tree build_type_conversion\t\tPARAMS ((tree, tree, int));\n+extern tree build_expr_type_conversion\t\tPARAMS ((int, tree, int));\n+extern tree type_promotes_to\t\t\tPARAMS ((tree));\n+extern tree perform_qualification_conversions   PARAMS ((tree, tree));\n \n /* decl.c */\n /* resume_binding_level */\n-extern void set_identifier_local_value\t\tPROTO((tree, tree));\n-extern int global_bindings_p\t\t\tPROTO((void));\n-extern int toplevel_bindings_p\t\t\tPROTO((void));\n-extern int namespace_bindings_p\t\t\tPROTO((void));\n-extern void keep_next_level\t\t\tPROTO((int));\n-extern int kept_level_p\t\t\t\tPROTO((void));\n-extern void declare_pseudo_global_level\t\tPROTO((void));\n-extern int pseudo_global_level_p\t\tPROTO((void));\n-extern void set_class_shadows\t\t\tPROTO((tree));\n-extern void pushlevel\t\t\t\tPROTO((int));\n-extern void note_level_for_for\t\t\tPROTO((void));\n-extern void resume_level\t\t\tPROTO((struct binding_level *));\n-extern void delete_block\t\t\tPROTO((tree));\n-extern void insert_block\t\t\tPROTO((tree));\n-extern void add_block_current_level\t\tPROTO((tree));\n-extern void set_block\t\t\t\tPROTO((tree));\n-extern void pushlevel_class\t\t\tPROTO((void));\n-extern void poplevel_class                      PROTO((void));\n-extern void print_binding_stack\t\t\tPROTO((void));\n-extern void print_binding_level\t\t\tPROTO((struct binding_level *));\n-extern void push_namespace\t\t\tPROTO((tree));\n-extern void pop_namespace\t\t\tPROTO((void));\n-extern void push_nested_namespace\t\tPROTO((tree));\n-extern void pop_nested_namespace\t\tPROTO((tree));\n-extern void maybe_push_to_top_level\t\tPROTO((int));\n-extern void push_to_top_level\t\t\tPROTO((void));\n-extern void pop_from_top_level\t\t\tPROTO((void));\n-extern tree identifier_type_value\t\tPROTO((tree));\n-extern void set_identifier_type_value\t\tPROTO((tree, tree));\n-extern void pop_everything\t\t\tPROTO((void));\n-extern void pushtag\t\t\t\tPROTO((tree, tree, int));\n-extern tree make_anon_name\t\t\tPROTO((void));\n-extern void clear_anon_tags\t\t\tPROTO((void));\n-extern int decls_match\t\t\t\tPROTO((tree, tree));\n-extern int duplicate_decls\t\t\tPROTO((tree, tree));\n-extern tree pushdecl\t\t\t\tPROTO((tree));\n-extern tree pushdecl_top_level\t\t\tPROTO((tree));\n-extern void pushdecl_class_level\t\tPROTO((tree));\n+extern void set_identifier_local_value\t\tPARAMS ((tree, tree));\n+extern int global_bindings_p\t\t\tPARAMS ((void));\n+extern int toplevel_bindings_p\t\t\tPARAMS ((void));\n+extern int namespace_bindings_p\t\t\tPARAMS ((void));\n+extern void keep_next_level\t\t\tPARAMS ((int));\n+extern int kept_level_p\t\t\t\tPARAMS ((void));\n+extern void declare_pseudo_global_level\t\tPARAMS ((void));\n+extern int pseudo_global_level_p\t\tPARAMS ((void));\n+extern void set_class_shadows\t\t\tPARAMS ((tree));\n+extern void pushlevel\t\t\t\tPARAMS ((int));\n+extern void note_level_for_for\t\t\tPARAMS ((void));\n+extern void resume_level\t\t\tPARAMS ((struct binding_level *));\n+extern void delete_block\t\t\tPARAMS ((tree));\n+extern void insert_block\t\t\tPARAMS ((tree));\n+extern void add_block_current_level\t\tPARAMS ((tree));\n+extern void set_block\t\t\t\tPARAMS ((tree));\n+extern void pushlevel_class\t\t\tPARAMS ((void));\n+extern void poplevel_class                      PARAMS ((void));\n+extern void print_binding_stack\t\t\tPARAMS ((void));\n+extern void print_binding_level\t\t\tPARAMS ((struct binding_level *));\n+extern void push_namespace\t\t\tPARAMS ((tree));\n+extern void pop_namespace\t\t\tPARAMS ((void));\n+extern void push_nested_namespace\t\tPARAMS ((tree));\n+extern void pop_nested_namespace\t\tPARAMS ((tree));\n+extern void maybe_push_to_top_level\t\tPARAMS ((int));\n+extern void push_to_top_level\t\t\tPARAMS ((void));\n+extern void pop_from_top_level\t\t\tPARAMS ((void));\n+extern tree identifier_type_value\t\tPARAMS ((tree));\n+extern void set_identifier_type_value\t\tPARAMS ((tree, tree));\n+extern void pop_everything\t\t\tPARAMS ((void));\n+extern void pushtag\t\t\t\tPARAMS ((tree, tree, int));\n+extern tree make_anon_name\t\t\tPARAMS ((void));\n+extern void clear_anon_tags\t\t\tPARAMS ((void));\n+extern int decls_match\t\t\t\tPARAMS ((tree, tree));\n+extern int duplicate_decls\t\t\tPARAMS ((tree, tree));\n+extern tree pushdecl\t\t\t\tPARAMS ((tree));\n+extern tree pushdecl_top_level\t\t\tPARAMS ((tree));\n+extern void pushdecl_class_level\t\tPARAMS ((tree));\n #if 0\n-extern void pushdecl_nonclass_level\t\tPROTO((tree));\n+extern void pushdecl_nonclass_level\t\tPARAMS ((tree));\n #endif\n-extern tree pushdecl_namespace_level            PROTO((tree));\n-extern tree push_using_decl                     PROTO((tree, tree));\n-extern tree push_using_directive                PROTO((tree));\n-extern void push_class_level_binding\t\tPROTO((tree, tree));\n-extern tree implicitly_declare\t\t\tPROTO((tree));\n-extern tree lookup_label\t\t\tPROTO((tree));\n-extern tree declare_local_label                 PROTO((tree));\n-extern tree define_label\t\t\tPROTO((char *, int, tree));\n-extern void push_switch\t\t\t\tPROTO((void));\n-extern void pop_switch\t\t\t\tPROTO((void));\n-extern void define_case_label\t\t\tPROTO((void));\n-extern tree getdecls\t\t\t\tPROTO((void));\n-extern tree gettags\t\t\t\tPROTO((void));\n+extern tree pushdecl_namespace_level            PARAMS ((tree));\n+extern tree push_using_decl                     PARAMS ((tree, tree));\n+extern tree push_using_directive                PARAMS ((tree));\n+extern void push_class_level_binding\t\tPARAMS ((tree, tree));\n+extern tree implicitly_declare\t\t\tPARAMS ((tree));\n+extern tree lookup_label\t\t\tPARAMS ((tree));\n+extern tree declare_local_label                 PARAMS ((tree));\n+extern tree define_label\t\t\tPARAMS ((char *, int, tree));\n+extern void push_switch\t\t\t\tPARAMS ((void));\n+extern void pop_switch\t\t\t\tPARAMS ((void));\n+extern void define_case_label\t\t\tPARAMS ((void));\n+extern tree getdecls\t\t\t\tPARAMS ((void));\n+extern tree gettags\t\t\t\tPARAMS ((void));\n #if 0\n-extern void set_current_level_tags_transparency\tPROTO((int));\n+extern void set_current_level_tags_transparency\tPARAMS ((int));\n #endif\n-extern tree binding_for_name                    PROTO((tree, tree));\n-extern tree namespace_binding                   PROTO((tree, tree));\n-extern void set_namespace_binding               PROTO((tree, tree, tree));\n-extern tree lookup_namespace_name\t\tPROTO((tree, tree));\n-extern tree build_typename_type                 PROTO((tree, tree, tree, tree));\n-extern tree make_typename_type\t\t\tPROTO((tree, tree, int));\n-extern tree lookup_name_nonclass\t\tPROTO((tree));\n-extern tree lookup_function_nonclass            PROTO((tree, tree));\n-extern tree lookup_name\t\t\t\tPROTO((tree, int));\n-extern tree lookup_name_current_level\t\tPROTO((tree));\n-extern tree lookup_type_current_level\t\tPROTO((tree));\n-extern tree lookup_name_namespace_only          PROTO((tree));\n-extern void begin_only_namespace_names          PROTO((void));\n-extern void end_only_namespace_names            PROTO((void));\n-extern tree namespace_ancestor\t\t\tPROTO((tree, tree));\n-extern tree unqualified_namespace_lookup\tPROTO((tree, int, tree *));\n-extern int  lookup_using_namespace              PROTO((tree, tree, tree, tree, int, tree *));\n-extern int  qualified_lookup_using_namespace    PROTO((tree, tree, tree, int));\n-extern tree auto_function\t\t\tPROTO((tree, tree));\n-extern void init_decl_processing\t\tPROTO((void));\n-extern int init_type_desc\t\t\tPROTO((void));\n-extern tree define_function\t\t\tPROTO((const char *, tree,\n+extern tree binding_for_name                    PARAMS ((tree, tree));\n+extern tree namespace_binding                   PARAMS ((tree, tree));\n+extern void set_namespace_binding               PARAMS ((tree, tree, tree));\n+extern tree lookup_namespace_name\t\tPARAMS ((tree, tree));\n+extern tree build_typename_type                 PARAMS ((tree, tree, tree, tree));\n+extern tree make_typename_type\t\t\tPARAMS ((tree, tree, int));\n+extern tree lookup_name_nonclass\t\tPARAMS ((tree));\n+extern tree lookup_function_nonclass            PARAMS ((tree, tree));\n+extern tree lookup_name\t\t\t\tPARAMS ((tree, int));\n+extern tree lookup_name_current_level\t\tPARAMS ((tree));\n+extern tree lookup_type_current_level\t\tPARAMS ((tree));\n+extern tree lookup_name_namespace_only          PARAMS ((tree));\n+extern void begin_only_namespace_names          PARAMS ((void));\n+extern void end_only_namespace_names            PARAMS ((void));\n+extern tree namespace_ancestor\t\t\tPARAMS ((tree, tree));\n+extern tree unqualified_namespace_lookup\tPARAMS ((tree, int, tree *));\n+extern int  lookup_using_namespace              PARAMS ((tree, tree, tree, tree, int, tree *));\n+extern int  qualified_lookup_using_namespace    PARAMS ((tree, tree, tree, int));\n+extern tree auto_function\t\t\tPARAMS ((tree, tree));\n+extern void init_decl_processing\t\tPARAMS ((void));\n+extern int init_type_desc\t\t\tPARAMS ((void));\n+extern tree define_function\t\t\tPARAMS ((const char *, tree,\n \t\t\t\t\t\t       void (*) (tree),\n \t\t\t\t\t\t       const char *));\n-extern tree check_tag_decl\t\t\tPROTO((tree));\n-extern void shadow_tag\t\t\t\tPROTO((tree));\n-extern tree groktypename\t\t\tPROTO((tree));\n-extern tree start_decl\t\t\t\tPROTO((tree, tree, int, tree, tree));\n-extern void start_decl_1\t\t\tPROTO((tree));\n-extern void cp_finish_decl\t\t\tPROTO((tree, tree, tree, int));\n-extern void finish_decl\t\t\t\tPROTO((tree, tree, tree));\n-extern void maybe_inject_for_scope_var          PROTO((tree));\n-extern void initialize_local_var                PROTO((tree, tree, int));\n-extern void expand_static_init\t\t\tPROTO((tree, tree));\n-extern tree start_handler_parms                 PROTO((tree, tree));\n-extern int complete_array_type\t\t\tPROTO((tree, tree, int));\n-extern tree build_ptrmemfunc_type\t\tPROTO((tree));\n+extern tree check_tag_decl\t\t\tPARAMS ((tree));\n+extern void shadow_tag\t\t\t\tPARAMS ((tree));\n+extern tree groktypename\t\t\tPARAMS ((tree));\n+extern tree start_decl\t\t\t\tPARAMS ((tree, tree, int, tree, tree));\n+extern void start_decl_1\t\t\tPARAMS ((tree));\n+extern void cp_finish_decl\t\t\tPARAMS ((tree, tree, tree, int));\n+extern void finish_decl\t\t\t\tPARAMS ((tree, tree, tree));\n+extern void maybe_inject_for_scope_var          PARAMS ((tree));\n+extern void initialize_local_var                PARAMS ((tree, tree, int));\n+extern void expand_static_init\t\t\tPARAMS ((tree, tree));\n+extern tree start_handler_parms                 PARAMS ((tree, tree));\n+extern int complete_array_type\t\t\tPARAMS ((tree, tree, int));\n+extern tree build_ptrmemfunc_type\t\tPARAMS ((tree));\n /* the grokdeclarator prototype is in decl.h */\n-extern int parmlist_is_exprlist\t\t\tPROTO((tree));\n-extern int copy_args_p\t\t\t\tPROTO((tree));\n-extern int grok_ctor_properties\t\t\tPROTO((tree, tree));\n-extern void grok_op_properties\t\t\tPROTO((tree, int, int));\n-extern tree xref_tag\t\t\t\tPROTO((tree, tree, int));\n-extern tree xref_tag_from_type\t\t\tPROTO((tree, tree, int));\n-extern void xref_basetypes\t\t\tPROTO((tree, tree, tree, tree));\n-extern tree start_enum\t\t\t\tPROTO((tree));\n-extern tree finish_enum\t\t\t\tPROTO((tree));\n-extern void build_enumerator\t\t\tPROTO((tree, tree, tree));\n-extern int start_function\t\t\tPROTO((tree, tree, tree, int));\n-extern void expand_start_early_try_stmts\tPROTO((void));\n-extern void store_parm_decls\t\t\tPROTO((void));\n-extern void store_return_init\t\t\tPROTO((tree));\n-extern tree finish_function\t\t\tPROTO((int, int));\n-extern tree start_method\t\t\tPROTO((tree, tree, tree));\n-extern tree finish_method\t\t\tPROTO((tree));\n-extern void hack_incomplete_structures\t\tPROTO((tree));\n-extern tree maybe_build_cleanup_and_delete\tPROTO((tree));\n-extern tree maybe_build_cleanup\t\t\tPROTO((tree));\n-extern void cplus_expand_expr_stmt\t\tPROTO((tree));\n-extern void finish_stmt\t\t\t\tPROTO((void));\n-extern int in_function_p\t\t\tPROTO((void));\n-extern void replace_defarg\t\t\tPROTO((tree, tree));\n-extern void print_other_binding_stack\t\tPROTO((struct binding_level *));\n-extern void revert_static_member_fn             PROTO((tree*, tree*, tree*));\n-extern void fixup_anonymous_aggr                PROTO((tree));\n-extern int check_static_variable_definition     PROTO((tree, tree));\n-extern tree compute_array_index_type\t\tPROTO((tree, tree));\n-extern void push_local_binding                  PROTO((tree, tree, int));\n-extern int push_class_binding                   PROTO((tree, tree));\n-extern tree check_default_argument              PROTO((tree, tree));\n-extern tree push_overloaded_decl\t\tPROTO((tree, int));\n-extern void clear_identifier_class_values       PROTO((void));\n-extern void storetags                           PROTO((tree));\n-extern int vtable_decl_p                        PROTO((tree, void *));\n-extern int vtype_decl_p                         PROTO((tree, void *));\n-extern int sigtable_decl_p                      PROTO((tree, void *));\n-typedef int (*walk_globals_pred)                PROTO((tree, void *));\n-typedef int (*walk_globals_fn)                  PROTO((tree *, void *));\n-extern int walk_globals                         PROTO((walk_globals_pred,\n+extern int parmlist_is_exprlist\t\t\tPARAMS ((tree));\n+extern int copy_args_p\t\t\t\tPARAMS ((tree));\n+extern int grok_ctor_properties\t\t\tPARAMS ((tree, tree));\n+extern void grok_op_properties\t\t\tPARAMS ((tree, int, int));\n+extern tree xref_tag\t\t\t\tPARAMS ((tree, tree, int));\n+extern tree xref_tag_from_type\t\t\tPARAMS ((tree, tree, int));\n+extern void xref_basetypes\t\t\tPARAMS ((tree, tree, tree, tree));\n+extern tree start_enum\t\t\t\tPARAMS ((tree));\n+extern tree finish_enum\t\t\t\tPARAMS ((tree));\n+extern void build_enumerator\t\t\tPARAMS ((tree, tree, tree));\n+extern int start_function\t\t\tPARAMS ((tree, tree, tree, int));\n+extern void expand_start_early_try_stmts\tPARAMS ((void));\n+extern void store_parm_decls\t\t\tPARAMS ((void));\n+extern void store_return_init\t\t\tPARAMS ((tree));\n+extern tree finish_function\t\t\tPARAMS ((int, int));\n+extern tree start_method\t\t\tPARAMS ((tree, tree, tree));\n+extern tree finish_method\t\t\tPARAMS ((tree));\n+extern void hack_incomplete_structures\t\tPARAMS ((tree));\n+extern tree maybe_build_cleanup_and_delete\tPARAMS ((tree));\n+extern tree maybe_build_cleanup\t\t\tPARAMS ((tree));\n+extern void cplus_expand_expr_stmt\t\tPARAMS ((tree));\n+extern void finish_stmt\t\t\t\tPARAMS ((void));\n+extern int in_function_p\t\t\tPARAMS ((void));\n+extern void replace_defarg\t\t\tPARAMS ((tree, tree));\n+extern void print_other_binding_stack\t\tPARAMS ((struct binding_level *));\n+extern void revert_static_member_fn             PARAMS ((tree*, tree*, tree*));\n+extern void fixup_anonymous_aggr                PARAMS ((tree));\n+extern int check_static_variable_definition     PARAMS ((tree, tree));\n+extern tree compute_array_index_type\t\tPARAMS ((tree, tree));\n+extern void push_local_binding                  PARAMS ((tree, tree, int));\n+extern int push_class_binding                   PARAMS ((tree, tree));\n+extern tree check_default_argument              PARAMS ((tree, tree));\n+extern tree push_overloaded_decl\t\tPARAMS ((tree, int));\n+extern void clear_identifier_class_values       PARAMS ((void));\n+extern void storetags                           PARAMS ((tree));\n+extern int vtable_decl_p                        PARAMS ((tree, void *));\n+extern int vtype_decl_p                         PARAMS ((tree, void *));\n+extern int sigtable_decl_p                      PARAMS ((tree, void *));\n+typedef int (*walk_globals_pred)                PARAMS ((tree, void *));\n+typedef int (*walk_globals_fn)                  PARAMS ((tree *, void *));\n+extern int walk_globals                         PARAMS ((walk_globals_pred,\n \t\t\t\t\t\t       walk_globals_fn,\n \t\t\t\t\t\t       void *));\n-typedef int (*walk_namespaces_fn)               PROTO((tree, void *));\n-extern int walk_namespaces                      PROTO((walk_namespaces_fn,\n+typedef int (*walk_namespaces_fn)               PARAMS ((tree, void *));\n+extern int walk_namespaces                      PARAMS ((walk_namespaces_fn,\n \t\t\t\t\t\t       void *));\n-extern int wrapup_globals_for_namespace         PROTO((tree, void *));\n-extern tree cp_namespace_decls                  PROTO((tree));\n-extern tree create_implicit_typedef             PROTO((tree, tree));\n-extern tree maybe_push_decl                     PROTO((tree));\n-extern void emit_local_var                      PROTO((tree));\n-extern tree build_target_expr_with_type         PROTO((tree, tree));\n-extern void make_rtl_for_local_static           PROTO((tree));\n-extern int local_variable_p                     PROTO((tree));\n-extern int nonstatic_local_decl_p               PROTO((tree));\n-extern tree declare_global_var                  PROTO((tree, tree));\n-extern void register_dtor_fn                    PROTO((tree));\n+extern int wrapup_globals_for_namespace         PARAMS ((tree, void *));\n+extern tree cp_namespace_decls                  PARAMS ((tree));\n+extern tree create_implicit_typedef             PARAMS ((tree, tree));\n+extern tree maybe_push_decl                     PARAMS ((tree));\n+extern void emit_local_var                      PARAMS ((tree));\n+extern tree build_target_expr_with_type         PARAMS ((tree, tree));\n+extern void make_rtl_for_local_static           PARAMS ((tree));\n+extern int local_variable_p                     PARAMS ((tree));\n+extern int nonstatic_local_decl_p               PARAMS ((tree));\n+extern tree declare_global_var                  PARAMS ((tree, tree));\n+extern void register_dtor_fn                    PARAMS ((tree));\n \n /* in decl2.c */\n-extern void init_decl2\t\t\t\tPROTO((void));\n-extern int check_java_method\t\t\tPROTO((tree));\n-extern int lang_decode_option\t\t\tPROTO((int, char **));\n-extern int grok_method_quals\t\t\tPROTO((tree, tree, tree));\n-extern void warn_if_unknown_interface\t\tPROTO((tree));\n-extern void grok_x_components\t\t\tPROTO((tree));\n-extern void maybe_retrofit_in_chrg\t\tPROTO((tree));\n-extern void maybe_make_one_only\t\t\tPROTO((tree));\n-extern void grokclassfn\t\t\t\tPROTO((tree, tree, enum overload_flags, tree));\n-extern tree grok_alignof\t\t\tPROTO((tree));\n-extern tree grok_array_decl\t\t\tPROTO((tree, tree));\n-extern tree delete_sanity\t\t\tPROTO((tree, tree, int, int));\n-extern tree check_classfn\t\t\tPROTO((tree, tree));\n-extern void check_member_template               PROTO((tree));\n-extern tree grokfield\t\t\t\tPROTO((tree, tree, tree, tree, tree));\n-extern tree grokbitfield\t\t\tPROTO((tree, tree, tree));\n-extern tree groktypefield\t\t\tPROTO((tree, tree));\n-extern tree grokoptypename\t\t\tPROTO((tree, tree));\n-extern int copy_assignment_arg_p\t\tPROTO((tree, int));\n-extern void cplus_decl_attributes\t\tPROTO((tree, tree, tree)); \n-extern tree constructor_name_full\t\tPROTO((tree));\n-extern tree constructor_name\t\t\tPROTO((tree));\n-extern void setup_vtbl_ptr\t\t\tPROTO((void));\n-extern void mark_inline_for_output\t\tPROTO((tree));\n-extern tree get_temp_name\t\t\tPROTO((tree, int));\n-extern void finish_anon_union\t\t\tPROTO((tree));\n-extern tree finish_table\t\t\tPROTO((tree, tree, tree, int));\n-extern void finish_builtin_type\t\t\tPROTO((tree, const char *,\n+extern void init_decl2\t\t\t\tPARAMS ((void));\n+extern int check_java_method\t\t\tPARAMS ((tree));\n+extern int lang_decode_option\t\t\tPARAMS ((int, char **));\n+extern int grok_method_quals\t\t\tPARAMS ((tree, tree, tree));\n+extern void warn_if_unknown_interface\t\tPARAMS ((tree));\n+extern void grok_x_components\t\t\tPARAMS ((tree));\n+extern void maybe_retrofit_in_chrg\t\tPARAMS ((tree));\n+extern void maybe_make_one_only\t\t\tPARAMS ((tree));\n+extern void grokclassfn\t\t\t\tPARAMS ((tree, tree, enum overload_flags, tree));\n+extern tree grok_alignof\t\t\tPARAMS ((tree));\n+extern tree grok_array_decl\t\t\tPARAMS ((tree, tree));\n+extern tree delete_sanity\t\t\tPARAMS ((tree, tree, int, int));\n+extern tree check_classfn\t\t\tPARAMS ((tree, tree));\n+extern void check_member_template               PARAMS ((tree));\n+extern tree grokfield\t\t\t\tPARAMS ((tree, tree, tree, tree, tree));\n+extern tree grokbitfield\t\t\tPARAMS ((tree, tree, tree));\n+extern tree groktypefield\t\t\tPARAMS ((tree, tree));\n+extern tree grokoptypename\t\t\tPARAMS ((tree, tree));\n+extern int copy_assignment_arg_p\t\tPARAMS ((tree, int));\n+extern void cplus_decl_attributes\t\tPARAMS ((tree, tree, tree)); \n+extern tree constructor_name_full\t\tPARAMS ((tree));\n+extern tree constructor_name\t\t\tPARAMS ((tree));\n+extern void setup_vtbl_ptr\t\t\tPARAMS ((void));\n+extern void mark_inline_for_output\t\tPARAMS ((tree));\n+extern tree get_temp_name\t\t\tPARAMS ((tree, int));\n+extern void finish_anon_union\t\t\tPARAMS ((tree));\n+extern tree finish_table\t\t\tPARAMS ((tree, tree, tree, int));\n+extern void finish_builtin_type\t\t\tPARAMS ((tree, const char *,\n \t\t\t\t\t\t       tree *, int, tree));\n-extern tree coerce_new_type\t\t\tPROTO((tree));\n-extern tree coerce_delete_type\t\t\tPROTO((tree));\n-extern void comdat_linkage\t\t\tPROTO((tree));\n-extern void import_export_class\t\t\tPROTO((tree));\n-extern void import_export_vtable\t\tPROTO((tree, tree, int));\n-extern void import_export_decl\t\t\tPROTO((tree));\n-extern tree build_cleanup\t\t\tPROTO((tree));\n-extern void finish_file\t\t\t\tPROTO((void));\n-extern tree reparse_absdcl_as_expr\t\tPROTO((tree, tree));\n-extern tree reparse_absdcl_as_casts\t\tPROTO((tree, tree));\n-extern tree build_expr_from_tree\t\tPROTO((tree));\n-extern tree reparse_decl_as_expr\t\tPROTO((tree, tree));\n-extern tree finish_decl_parsing\t\t\tPROTO((tree));\n-extern tree check_cp_case_value\t\t\tPROTO((tree));\n-extern void set_decl_namespace                  PROTO((tree, tree, int));\n-extern tree current_decl_namespace              PROTO((void));\n-extern void push_decl_namespace                 PROTO((tree));\n-extern void pop_decl_namespace                  PROTO((void));\n-extern void push_scope\t\t\t\tPROTO((tree));\n-extern void pop_scope\t\t\t\tPROTO((tree));\n-extern void do_namespace_alias\t\t\tPROTO((tree, tree));\n-extern void do_toplevel_using_decl\t\tPROTO((tree));\n-extern void do_local_using_decl                 PROTO((tree));\n-extern tree do_class_using_decl\t\t\tPROTO((tree));\n-extern void do_using_directive\t\t\tPROTO((tree));\n-extern void check_default_args\t\t\tPROTO((tree));\n-extern void mark_used\t\t\t\tPROTO((tree));\n-extern tree handle_class_head\t\t\tPROTO((tree, tree, tree));\n-extern tree lookup_arg_dependent                PROTO((tree, tree, tree));\n-extern void finish_static_data_member_decl      PROTO((tree, tree, tree, int));\n+extern tree coerce_new_type\t\t\tPARAMS ((tree));\n+extern tree coerce_delete_type\t\t\tPARAMS ((tree));\n+extern void comdat_linkage\t\t\tPARAMS ((tree));\n+extern void import_export_class\t\t\tPARAMS ((tree));\n+extern void import_export_vtable\t\tPARAMS ((tree, tree, int));\n+extern void import_export_decl\t\t\tPARAMS ((tree));\n+extern tree build_cleanup\t\t\tPARAMS ((tree));\n+extern void finish_file\t\t\t\tPARAMS ((void));\n+extern tree reparse_absdcl_as_expr\t\tPARAMS ((tree, tree));\n+extern tree reparse_absdcl_as_casts\t\tPARAMS ((tree, tree));\n+extern tree build_expr_from_tree\t\tPARAMS ((tree));\n+extern tree reparse_decl_as_expr\t\tPARAMS ((tree, tree));\n+extern tree finish_decl_parsing\t\t\tPARAMS ((tree));\n+extern tree check_cp_case_value\t\t\tPARAMS ((tree));\n+extern void set_decl_namespace                  PARAMS ((tree, tree, int));\n+extern tree current_decl_namespace              PARAMS ((void));\n+extern void push_decl_namespace                 PARAMS ((tree));\n+extern void pop_decl_namespace                  PARAMS ((void));\n+extern void push_scope\t\t\t\tPARAMS ((tree));\n+extern void pop_scope\t\t\t\tPARAMS ((tree));\n+extern void do_namespace_alias\t\t\tPARAMS ((tree, tree));\n+extern void do_toplevel_using_decl\t\tPARAMS ((tree));\n+extern void do_local_using_decl                 PARAMS ((tree));\n+extern tree do_class_using_decl\t\t\tPARAMS ((tree));\n+extern void do_using_directive\t\t\tPARAMS ((tree));\n+extern void check_default_args\t\t\tPARAMS ((tree));\n+extern void mark_used\t\t\t\tPARAMS ((tree));\n+extern tree handle_class_head\t\t\tPARAMS ((tree, tree, tree));\n+extern tree lookup_arg_dependent                PARAMS ((tree, tree, tree));\n+extern void finish_static_data_member_decl      PARAMS ((tree, tree, tree, int));\n \n /* in parse.y */\n-extern void cp_parse_init\t\t\tPROTO((void));\n+extern void cp_parse_init\t\t\tPARAMS ((void));\n \n /* in errfn.c */\n /* The cp_* functions aren't suitable for ATTRIBUTE_PRINTF. */\n-extern void cp_error\t\t\t\tPVPROTO((const char *, ...));\n-extern void cp_error_at\t\t\t\tPVPROTO((const char *, ...));\n-extern void cp_warning\t\t\t\tPVPROTO((const char *, ...));\n-extern void cp_warning_at\t\t\tPVPROTO((const char *, ...));\n-extern void cp_pedwarn\t\t\t\tPVPROTO((const char *, ...));\n-extern void cp_pedwarn_at\t\t\tPVPROTO((const char *, ...));\n-extern void cp_compiler_error\t\t\tPVPROTO((const char *, ...));\n-extern void cp_sprintf\t\t\t\tPVPROTO((const char *, ...));\n-extern void cp_deprecated                       PROTO((const char*));\n+extern void cp_error\t\t\t\tPARAMS ((const char *, ...));\n+extern void cp_error_at\t\t\t\tPARAMS ((const char *, ...));\n+extern void cp_warning\t\t\t\tPARAMS ((const char *, ...));\n+extern void cp_warning_at\t\t\tPARAMS ((const char *, ...));\n+extern void cp_pedwarn\t\t\t\tPARAMS ((const char *, ...));\n+extern void cp_pedwarn_at\t\t\tPARAMS ((const char *, ...));\n+extern void cp_compiler_error\t\t\tPARAMS ((const char *, ...));\n+extern void cp_sprintf\t\t\t\tPARAMS ((const char *, ...));\n+extern void cp_deprecated                       PARAMS ((const char*));\n \n /* in error.c */\n-extern void init_error\t\t\t\tPROTO((void));\n-extern const char *type_as_string\t\tPROTO((tree, enum tree_string_flags));\n-extern const char *decl_as_string\t\tPROTO((tree, enum tree_string_flags));\n-extern const char *expr_as_string\t\tPROTO((tree, enum tree_string_flags));\n-extern const char *context_as_string            PROTO((tree, enum tree_string_flags));\n-extern const char *lang_decl_name\t\tPROTO((tree, int));\n-extern const char *cp_file_of\t\t\tPROTO((tree));\n-extern int cp_line_of\t\t\t\tPROTO((tree));\n+extern void init_error\t\t\t\tPARAMS ((void));\n+extern const char *type_as_string\t\tPARAMS ((tree, enum tree_string_flags));\n+extern const char *decl_as_string\t\tPARAMS ((tree, enum tree_string_flags));\n+extern const char *expr_as_string\t\tPARAMS ((tree, enum tree_string_flags));\n+extern const char *context_as_string            PARAMS ((tree, enum tree_string_flags));\n+extern const char *lang_decl_name\t\tPARAMS ((tree, int));\n+extern const char *cp_file_of\t\t\tPARAMS ((tree));\n+extern int cp_line_of\t\t\t\tPARAMS ((tree));\n \n /* in except.c */\n-extern void init_exception_processing\t\tPROTO((void));\n-extern tree expand_start_catch_block\t\tPROTO((tree));\n-extern void expand_end_catch_block\t\tPROTO((tree));\n-extern void expand_builtin_throw\t\tPROTO((void));\n-extern tree expand_start_eh_spec\t\tPROTO((void));\n-extern void expand_end_eh_spec\t\t        PROTO((tree, tree));\n-extern void expand_exception_blocks\t\tPROTO((void));\n-extern tree build_throw\t\t\t\tPROTO((tree));\n-extern void mark_all_runtime_matches            PROTO((void));\n+extern void init_exception_processing\t\tPARAMS ((void));\n+extern tree expand_start_catch_block\t\tPARAMS ((tree));\n+extern void expand_end_catch_block\t\tPARAMS ((tree));\n+extern void expand_builtin_throw\t\tPARAMS ((void));\n+extern tree expand_start_eh_spec\t\tPARAMS ((void));\n+extern void expand_end_eh_spec\t\t        PARAMS ((tree, tree));\n+extern void expand_exception_blocks\t\tPARAMS ((void));\n+extern tree build_throw\t\t\t\tPARAMS ((tree));\n+extern void mark_all_runtime_matches            PARAMS ((void));\n \n /* in expr.c */\n-extern void init_cplus_expand\t\t\tPROTO((void));\n-extern void fixup_result_decl\t\t\tPROTO((tree, struct rtx_def *));\n-extern int extract_init\t\t\t\tPROTO((tree, tree));\n-extern void do_case\t\t\t\tPROTO((tree, tree));\n-extern tree cplus_expand_constant               PROTO((tree));\n+extern void init_cplus_expand\t\t\tPARAMS ((void));\n+extern void fixup_result_decl\t\t\tPARAMS ((tree, struct rtx_def *));\n+extern int extract_init\t\t\t\tPARAMS ((tree, tree));\n+extern void do_case\t\t\t\tPARAMS ((tree, tree));\n+extern tree cplus_expand_constant               PARAMS ((tree));\n \n /* friend.c */\n-extern int is_friend\t\t\t\tPROTO((tree, tree));\n-extern void make_friend_class\t\t\tPROTO((tree, tree));\n-extern void add_friend                          PROTO((tree, tree));\n-extern void add_friends                         PROTO((tree, tree, tree));\n-extern tree do_friend\t\t\t\tPROTO((tree, tree, tree, tree, tree, enum overload_flags, tree, int));\n+extern int is_friend\t\t\t\tPARAMS ((tree, tree));\n+extern void make_friend_class\t\t\tPARAMS ((tree, tree));\n+extern void add_friend                          PARAMS ((tree, tree));\n+extern void add_friends                         PARAMS ((tree, tree, tree));\n+extern tree do_friend\t\t\t\tPARAMS ((tree, tree, tree, tree, tree, enum overload_flags, tree, int));\n \n /* in init.c */\n-extern void init_init_processing\t\tPROTO((void));\n-extern tree emit_base_init\t\t\tPROTO((tree));\n-extern void check_base_init\t\t\tPROTO((tree));\n-extern void expand_member_init\t\t\tPROTO((tree, tree, tree));\n-extern tree build_aggr_init\t\t\tPROTO((tree, tree, int));\n-extern int is_aggr_typedef\t\t\tPROTO((tree, int));\n-extern int is_aggr_type\t\t\t\tPROTO((tree, int));\n-extern tree get_aggr_from_typedef\t\tPROTO((tree, int));\n-extern tree get_type_value\t\t\tPROTO((tree));\n-extern tree build_member_call\t\t\tPROTO((tree, tree, tree));\n-extern tree build_offset_ref\t\t\tPROTO((tree, tree));\n-extern tree resolve_offset_ref\t\t\tPROTO((tree));\n-extern tree decl_constant_value\t\t\tPROTO((tree));\n-extern tree build_new\t\t\t\tPROTO((tree, tree, tree, int));\n-extern tree build_new_1\t\t\t\tPROTO((tree));\n-extern tree build_vec_init\t\t\tPROTO((tree, tree, tree, tree, int));\n-extern tree build_x_delete\t\t\tPROTO((tree, int, tree));\n-extern tree build_delete\t\t\tPROTO((tree, tree, tree, int, int));\n-extern tree build_vbase_delete\t\t\tPROTO((tree, tree));\n-extern tree build_vec_delete\t\t\tPROTO((tree, tree, tree, int));\n-extern tree create_temporary_var                PROTO((tree));\n-extern void begin_init_stmts                    PROTO((tree *, tree *));\n-extern tree finish_init_stmts                   PROTO((tree, tree));\n-extern void initialize_vtbl_ptrs                PROTO((tree, tree));\n+extern void init_init_processing\t\tPARAMS ((void));\n+extern tree emit_base_init\t\t\tPARAMS ((tree));\n+extern void check_base_init\t\t\tPARAMS ((tree));\n+extern void expand_member_init\t\t\tPARAMS ((tree, tree, tree));\n+extern tree build_aggr_init\t\t\tPARAMS ((tree, tree, int));\n+extern int is_aggr_typedef\t\t\tPARAMS ((tree, int));\n+extern int is_aggr_type\t\t\t\tPARAMS ((tree, int));\n+extern tree get_aggr_from_typedef\t\tPARAMS ((tree, int));\n+extern tree get_type_value\t\t\tPARAMS ((tree));\n+extern tree build_member_call\t\t\tPARAMS ((tree, tree, tree));\n+extern tree build_offset_ref\t\t\tPARAMS ((tree, tree));\n+extern tree resolve_offset_ref\t\t\tPARAMS ((tree));\n+extern tree decl_constant_value\t\t\tPARAMS ((tree));\n+extern tree build_new\t\t\t\tPARAMS ((tree, tree, tree, int));\n+extern tree build_new_1\t\t\t\tPARAMS ((tree));\n+extern tree build_vec_init\t\t\tPARAMS ((tree, tree, tree, tree, int));\n+extern tree build_x_delete\t\t\tPARAMS ((tree, int, tree));\n+extern tree build_delete\t\t\tPARAMS ((tree, tree, tree, int, int));\n+extern tree build_vbase_delete\t\t\tPARAMS ((tree, tree));\n+extern tree build_vec_delete\t\t\tPARAMS ((tree, tree, tree, int));\n+extern tree create_temporary_var                PARAMS ((tree));\n+extern void begin_init_stmts                    PARAMS ((tree *, tree *));\n+extern tree finish_init_stmts                   PARAMS ((tree, tree));\n+extern void initialize_vtbl_ptrs                PARAMS ((tree, tree));\n \n /* in input.c */\n \n /* in lex.c */\n-extern char *file_name_nondirectory\t\tPROTO((const char *));\n-extern tree make_pointer_declarator\t\tPROTO((tree, tree));\n-extern tree make_reference_declarator\t\tPROTO((tree, tree));\n-extern tree make_call_declarator\t\tPROTO((tree, tree, tree, tree));\n-extern void set_quals_and_spec\t\t\tPROTO((tree, tree, tree));\n-extern const char *operator_name_string\t\tPROTO((tree));\n-extern void lang_init\t\t\t\tPROTO((void));\n-extern void lang_finish\t\t\t\tPROTO((void));\n+extern char *file_name_nondirectory\t\tPARAMS ((const char *));\n+extern tree make_pointer_declarator\t\tPARAMS ((tree, tree));\n+extern tree make_reference_declarator\t\tPARAMS ((tree, tree));\n+extern tree make_call_declarator\t\tPARAMS ((tree, tree, tree, tree));\n+extern void set_quals_and_spec\t\t\tPARAMS ((tree, tree, tree));\n+extern const char *operator_name_string\t\tPARAMS ((tree));\n+extern void lang_init\t\t\t\tPARAMS ((void));\n+extern void lang_finish\t\t\t\tPARAMS ((void));\n #if 0\n-extern void reinit_lang_specific\t\tPROTO((void));\n+extern void reinit_lang_specific\t\tPARAMS ((void));\n #endif\n-extern void reinit_parse_for_function\t\tPROTO((void));\n-extern void print_parse_statistics\t\tPROTO((void));\n-extern void extract_interface_info\t\tPROTO((void));\n-extern void do_pending_inlines\t\t\tPROTO((void));\n-extern void process_next_inline\t\t\tPROTO((struct pending_inline *));\n-extern struct pending_input *save_pending_input PROTO((void));\n-extern void restore_pending_input\t\tPROTO((struct pending_input *));\n-extern void yyungetc\t\t\t\tPROTO((int, int));\n-extern void reinit_parse_for_method\t\tPROTO((int, tree));\n-extern void reinit_parse_for_block\t\tPROTO((int, struct obstack *));\n-extern tree cons_up_default_function\t\tPROTO((tree, tree, int));\n-extern void check_for_missing_semicolon\t\tPROTO((tree));\n-extern void note_got_semicolon\t\t\tPROTO((tree));\n-extern void note_list_got_semicolon\t\tPROTO((tree));\n-extern void do_pending_lang_change\t\tPROTO((void));\n-extern int identifier_type\t\t\tPROTO((tree));\n-extern void see_typename\t\t\tPROTO((void));\n-extern tree do_identifier\t\t\tPROTO((tree, int, tree));\n-extern tree do_scoped_id\t\t\tPROTO((tree, int));\n-extern tree identifier_typedecl_value\t\tPROTO((tree));\n-extern int real_yylex\t\t\t\tPROTO((void));\n-extern int is_rid\t\t\t\tPROTO((tree));\n-extern tree build_lang_decl\t\t\tPROTO((enum tree_code, tree, tree));\n-extern void retrofit_lang_decl\t\t\tPROTO((tree));\n-extern void copy_lang_decl\t\t\tPROTO((tree));\n-extern tree cp_make_lang_type\t\t\tPROTO((enum tree_code));\n-extern tree make_aggr_type\t\t\tPROTO((enum tree_code));\n-extern void dump_time_statistics\t\tPROTO((void));\n-extern void compiler_error\t\t\tPVPROTO((const char *, ...))\n+extern void reinit_parse_for_function\t\tPARAMS ((void));\n+extern void print_parse_statistics\t\tPARAMS ((void));\n+extern void extract_interface_info\t\tPARAMS ((void));\n+extern void do_pending_inlines\t\t\tPARAMS ((void));\n+extern void process_next_inline\t\t\tPARAMS ((struct pending_inline *));\n+extern struct pending_input *save_pending_input PARAMS ((void));\n+extern void restore_pending_input\t\tPARAMS ((struct pending_input *));\n+extern void yyungetc\t\t\t\tPARAMS ((int, int));\n+extern void reinit_parse_for_method\t\tPARAMS ((int, tree));\n+extern void reinit_parse_for_block\t\tPARAMS ((int, struct obstack *));\n+extern tree cons_up_default_function\t\tPARAMS ((tree, tree, int));\n+extern void check_for_missing_semicolon\t\tPARAMS ((tree));\n+extern void note_got_semicolon\t\t\tPARAMS ((tree));\n+extern void note_list_got_semicolon\t\tPARAMS ((tree));\n+extern void do_pending_lang_change\t\tPARAMS ((void));\n+extern int identifier_type\t\t\tPARAMS ((tree));\n+extern void see_typename\t\t\tPARAMS ((void));\n+extern tree do_identifier\t\t\tPARAMS ((tree, int, tree));\n+extern tree do_scoped_id\t\t\tPARAMS ((tree, int));\n+extern tree identifier_typedecl_value\t\tPARAMS ((tree));\n+extern int real_yylex\t\t\t\tPARAMS ((void));\n+extern int is_rid\t\t\t\tPARAMS ((tree));\n+extern tree build_lang_decl\t\t\tPARAMS ((enum tree_code, tree, tree));\n+extern void retrofit_lang_decl\t\t\tPARAMS ((tree));\n+extern void copy_lang_decl\t\t\tPARAMS ((tree));\n+extern tree cp_make_lang_type\t\t\tPARAMS ((enum tree_code));\n+extern tree make_aggr_type\t\t\tPARAMS ((enum tree_code));\n+extern void dump_time_statistics\t\tPARAMS ((void));\n+extern void compiler_error\t\t\tPARAMS ((const char *, ...))\n   ATTRIBUTE_PRINTF_1;\n-extern void yyerror\t\t\t\tPROTO((const char *));\n-extern void clear_inline_text_obstack\t\tPROTO((void));\n-extern void maybe_snarf_defarg\t\t\tPROTO((void));\n-extern tree snarf_defarg\t\t\tPROTO((void));\n-extern void add_defarg_fn\t\t\tPROTO((tree));\n-extern void do_pending_defargs\t\t\tPROTO((void));\n-extern int identifier_type\t\t\tPROTO((tree));\n-extern void yyhook\t\t\t\tPROTO((int));\n-extern int cp_type_qual_from_rid                PROTO((tree));\n+extern void yyerror\t\t\t\tPARAMS ((const char *));\n+extern void clear_inline_text_obstack\t\tPARAMS ((void));\n+extern void maybe_snarf_defarg\t\t\tPARAMS ((void));\n+extern tree snarf_defarg\t\t\tPARAMS ((void));\n+extern void add_defarg_fn\t\t\tPARAMS ((tree));\n+extern void do_pending_defargs\t\t\tPARAMS ((void));\n+extern int identifier_type\t\t\tPARAMS ((tree));\n+extern void yyhook\t\t\t\tPARAMS ((int));\n+extern int cp_type_qual_from_rid                PARAMS ((tree));\n \n /* in method.c */\n-extern void init_method\t\t\t\tPROTO((void));\n-extern char *build_overload_name\t\tPROTO((tree, int, int));\n-extern tree build_static_name\t\t\tPROTO((tree, tree));\n-extern tree build_decl_overload\t\t\tPROTO((tree, tree, int));\n-extern tree build_decl_overload_real            PROTO((tree, tree, tree, tree,\n+extern void init_method\t\t\t\tPARAMS ((void));\n+extern char *build_overload_name\t\tPARAMS ((tree, int, int));\n+extern tree build_static_name\t\t\tPARAMS ((tree, tree));\n+extern tree build_decl_overload\t\t\tPARAMS ((tree, tree, int));\n+extern tree build_decl_overload_real            PARAMS ((tree, tree, tree, tree,\n \t\t\t\t\t\t       tree, int)); \n-extern void set_mangled_name_for_decl           PROTO((tree));\n-extern tree build_typename_overload\t\tPROTO((tree));\n-extern tree build_overload_with_type\t\tPROTO((tree, tree));\n-extern tree build_destructor_name\t\tPROTO((tree));\n-extern tree build_opfncall\t\t\tPROTO((enum tree_code, int, tree, tree, tree));\n-extern tree hack_identifier\t\t\tPROTO((tree, tree));\n-extern tree make_thunk\t\t\t\tPROTO((tree, int));\n-extern void emit_thunk\t\t\t\tPROTO((tree));\n-extern void synthesize_method\t\t\tPROTO((tree));\n-extern tree get_id_2\t\t\t\tPROTO((const char *, tree));\n+extern void set_mangled_name_for_decl           PARAMS ((tree));\n+extern tree build_typename_overload\t\tPARAMS ((tree));\n+extern tree build_overload_with_type\t\tPARAMS ((tree, tree));\n+extern tree build_destructor_name\t\tPARAMS ((tree));\n+extern tree build_opfncall\t\t\tPARAMS ((enum tree_code, int, tree, tree, tree));\n+extern tree hack_identifier\t\t\tPARAMS ((tree, tree));\n+extern tree make_thunk\t\t\t\tPARAMS ((tree, int));\n+extern void emit_thunk\t\t\t\tPARAMS ((tree));\n+extern void synthesize_method\t\t\tPARAMS ((tree));\n+extern tree get_id_2\t\t\t\tPARAMS ((const char *, tree));\n \n /* In optimize.c */\n-extern void optimize_function                   PROTO((tree));\n-extern int calls_setjmp_p                       PROTO((tree));\n+extern void optimize_function                   PARAMS ((tree));\n+extern int calls_setjmp_p                       PARAMS ((tree));\n \n /* in pt.c */\n-extern void init_pt                             PROTO ((void));\n-extern void check_template_shadow\t\tPROTO ((tree));\n-extern tree innermost_args\t\t\tPROTO ((tree));\n-extern tree tsubst\t\t\t\tPROTO ((tree, tree, int, tree));\n-extern tree tsubst_expr\t\t\t\tPROTO ((tree, tree, int, tree));\n-extern tree tsubst_copy\t\t\t\tPROTO ((tree, tree, int, tree));\n-extern void maybe_begin_member_template_processing PROTO((tree));\n-extern void maybe_end_member_template_processing PROTO((void));\n-extern tree finish_member_template_decl         PROTO((tree));\n-extern void begin_template_parm_list\t\tPROTO((void));\n-extern void begin_specialization                PROTO((void));\n-extern void reset_specialization                PROTO((void));\n-extern void end_specialization                  PROTO((void));\n-extern void begin_explicit_instantiation        PROTO((void));\n-extern void end_explicit_instantiation          PROTO((void));\n-extern tree check_explicit_specialization       PROTO((tree, tree, int, int));\n-extern tree process_template_parm\t\tPROTO((tree, tree));\n-extern tree end_template_parm_list\t\tPROTO((tree));\n-extern void end_template_decl\t\t\tPROTO((void));\n-extern tree current_template_args\t\tPROTO((void));\n-extern tree push_template_decl\t\t\tPROTO((tree));\n-extern tree push_template_decl_real             PROTO((tree, int));\n-extern void redeclare_class_template            PROTO((tree, tree));\n-extern tree lookup_template_class\t\tPROTO((tree, tree, tree, tree, int));\n-extern tree lookup_template_function            PROTO((tree, tree));\n-extern int uses_template_parms\t\t\tPROTO((tree));\n-extern tree instantiate_class_template\t\tPROTO((tree));\n-extern tree instantiate_template\t\tPROTO((tree, tree));\n-extern void overload_template_name\t\tPROTO((tree));\n-extern int fn_type_unification                  PROTO((tree, tree, tree, tree, tree, unification_kind_t));\n-struct tinst_level *tinst_for_decl\t\tPROTO((void));\n-extern void mark_decl_instantiated\t\tPROTO((tree, int));\n-extern int more_specialized\t\t\tPROTO((tree, tree, tree));\n-extern void mark_class_instantiated\t\tPROTO((tree, int));\n-extern void do_decl_instantiation\t\tPROTO((tree, tree, tree));\n-extern void do_type_instantiation\t\tPROTO((tree, tree));\n-extern tree instantiate_decl\t\t\tPROTO((tree));\n-extern tree get_bindings\t\t\tPROTO((tree, tree, tree));\n-extern void add_tree\t\t\t\tPROTO((tree));\n-extern void add_maybe_template\t\t\tPROTO((tree, tree));\n-extern void pop_tinst_level\t\t\tPROTO((void));\n-extern int more_specialized_class\t\tPROTO((tree, tree));\n-extern int is_member_template                   PROTO((tree));\n-extern int template_parms_equal                 PROTO((tree, tree));\n-extern int comp_template_parms                  PROTO((tree, tree));\n-extern int template_class_depth                 PROTO((tree));\n-extern int is_specialization_of                 PROTO((tree, tree));\n-extern int comp_template_args                   PROTO((tree, tree));\n-extern void maybe_process_partial_specialization PROTO((tree));\n-extern void maybe_check_template_type           PROTO((tree));\n-extern tree most_specialized_instantiation      PROTO((tree, tree));\n-extern void print_candidates                    PROTO((tree));\n-extern int instantiate_pending_templates        PROTO((void));\n-extern tree tsubst_default_argument             PROTO((tree, tree, tree));\n-extern tree most_general_template\t\tPROTO((tree));\n+extern void init_pt                             PARAMS ((void));\n+extern void check_template_shadow\t\tPARAMS ((tree));\n+extern tree innermost_args\t\t\tPARAMS ((tree));\n+extern tree tsubst\t\t\t\tPARAMS ((tree, tree, int, tree));\n+extern tree tsubst_expr\t\t\t\tPARAMS ((tree, tree, int, tree));\n+extern tree tsubst_copy\t\t\t\tPARAMS ((tree, tree, int, tree));\n+extern void maybe_begin_member_template_processing PARAMS ((tree));\n+extern void maybe_end_member_template_processing PARAMS ((void));\n+extern tree finish_member_template_decl         PARAMS ((tree));\n+extern void begin_template_parm_list\t\tPARAMS ((void));\n+extern void begin_specialization                PARAMS ((void));\n+extern void reset_specialization                PARAMS ((void));\n+extern void end_specialization                  PARAMS ((void));\n+extern void begin_explicit_instantiation        PARAMS ((void));\n+extern void end_explicit_instantiation          PARAMS ((void));\n+extern tree check_explicit_specialization       PARAMS ((tree, tree, int, int));\n+extern tree process_template_parm\t\tPARAMS ((tree, tree));\n+extern tree end_template_parm_list\t\tPARAMS ((tree));\n+extern void end_template_decl\t\t\tPARAMS ((void));\n+extern tree current_template_args\t\tPARAMS ((void));\n+extern tree push_template_decl\t\t\tPARAMS ((tree));\n+extern tree push_template_decl_real             PARAMS ((tree, int));\n+extern void redeclare_class_template            PARAMS ((tree, tree));\n+extern tree lookup_template_class\t\tPARAMS ((tree, tree, tree, tree, int));\n+extern tree lookup_template_function            PARAMS ((tree, tree));\n+extern int uses_template_parms\t\t\tPARAMS ((tree));\n+extern tree instantiate_class_template\t\tPARAMS ((tree));\n+extern tree instantiate_template\t\tPARAMS ((tree, tree));\n+extern void overload_template_name\t\tPARAMS ((tree));\n+extern int fn_type_unification                  PARAMS ((tree, tree, tree, tree, tree, unification_kind_t));\n+struct tinst_level *tinst_for_decl\t\tPARAMS ((void));\n+extern void mark_decl_instantiated\t\tPARAMS ((tree, int));\n+extern int more_specialized\t\t\tPARAMS ((tree, tree, tree));\n+extern void mark_class_instantiated\t\tPARAMS ((tree, int));\n+extern void do_decl_instantiation\t\tPARAMS ((tree, tree, tree));\n+extern void do_type_instantiation\t\tPARAMS ((tree, tree));\n+extern tree instantiate_decl\t\t\tPARAMS ((tree));\n+extern tree get_bindings\t\t\tPARAMS ((tree, tree, tree));\n+extern void add_tree\t\t\t\tPARAMS ((tree));\n+extern void add_maybe_template\t\t\tPARAMS ((tree, tree));\n+extern void pop_tinst_level\t\t\tPARAMS ((void));\n+extern int more_specialized_class\t\tPARAMS ((tree, tree));\n+extern int is_member_template                   PARAMS ((tree));\n+extern int template_parms_equal                 PARAMS ((tree, tree));\n+extern int comp_template_parms                  PARAMS ((tree, tree));\n+extern int template_class_depth                 PARAMS ((tree));\n+extern int is_specialization_of                 PARAMS ((tree, tree));\n+extern int comp_template_args                   PARAMS ((tree, tree));\n+extern void maybe_process_partial_specialization PARAMS ((tree));\n+extern void maybe_check_template_type           PARAMS ((tree));\n+extern tree most_specialized_instantiation      PARAMS ((tree, tree));\n+extern void print_candidates                    PARAMS ((tree));\n+extern int instantiate_pending_templates        PARAMS ((void));\n+extern tree tsubst_default_argument             PARAMS ((tree, tree, tree));\n+extern tree most_general_template\t\tPARAMS ((tree));\n \n extern int processing_template_parmlist;\n \n /* in repo.c */\n-extern void repo_template_used\t\t\tPROTO((tree));\n-extern void repo_template_instantiated\t\tPROTO((tree, int));\n-extern void init_repo\t\t\t\tPROTO((const char *));\n-extern void finish_repo\t\t\t\tPROTO((void));\n+extern void repo_template_used\t\t\tPARAMS ((tree));\n+extern void repo_template_instantiated\t\tPARAMS ((tree, int));\n+extern void init_repo\t\t\t\tPARAMS ((const char *));\n+extern void finish_repo\t\t\t\tPARAMS ((void));\n \n /* in rtti.c */\n-extern void init_rtti_processing\t\tPROTO((void));\n-extern tree build_typeid\t\t\tPROTO((tree));\n-extern tree get_tinfo_decl                      PROTO((tree));\n-extern tree get_typeid\t\t\t\tPROTO((tree));\n-extern tree get_typeid_1\t\t\tPROTO((tree));\n-extern tree build_dynamic_cast\t\t\tPROTO((tree, tree));\n-extern void synthesize_tinfo_fn\t\t\tPROTO((tree));\n+extern void init_rtti_processing\t\tPARAMS ((void));\n+extern tree build_typeid\t\t\tPARAMS ((tree));\n+extern tree get_tinfo_decl                      PARAMS ((tree));\n+extern tree get_typeid\t\t\t\tPARAMS ((tree));\n+extern tree get_typeid_1\t\t\tPARAMS ((tree));\n+extern tree build_dynamic_cast\t\t\tPARAMS ((tree, tree));\n+extern void synthesize_tinfo_fn\t\t\tPARAMS ((tree));\n \n /* in search.c */\n-extern int types_overlap_p\t\t\tPROTO((tree, tree));\n-extern tree get_vbase\t\t\t\tPROTO((tree, tree));\n-extern tree get_binfo\t\t\t\tPROTO((tree, tree, int));\n-extern int get_base_distance\t\t\tPROTO((tree, tree, int, tree *));\n-extern tree get_dynamic_cast_base_type          PROTO((tree, tree));\n-extern int accessible_p                         PROTO((tree, tree));\n-extern tree lookup_field\t\t\tPROTO((tree, tree, int, int));\n-extern int lookup_fnfields_1                    PROTO((tree, tree));\n-extern tree lookup_fnfields\t\t\tPROTO((tree, tree, int));\n-extern tree lookup_member\t\t\tPROTO((tree, tree, int, int));\n-extern tree lookup_nested_tag\t\t\tPROTO((tree, tree));\n-extern tree get_matching_virtual\t\tPROTO((tree, tree, int));\n-extern void get_pure_virtuals\t\t        PROTO((tree));\n-extern tree init_vbase_pointers\t\t\tPROTO((tree, tree));\n-extern void expand_indirect_vtbls_init\t\tPROTO((tree, tree));\n-extern void clear_search_slots\t\t\tPROTO((tree));\n-extern void get_vbase_types\t\t\tPROTO((tree));\n-extern void maybe_suppress_debug_info\t\tPROTO((tree));\n-extern void note_debug_info_needed\t\tPROTO((tree));\n-extern void push_class_decls\t\t\tPROTO((tree));\n-extern void pop_class_decls\t\t\tPROTO((void));\n-extern void unuse_fields\t\t\tPROTO((tree));\n-extern void print_search_statistics\t\tPROTO((void));\n-extern void init_search_processing\t\tPROTO((void));\n-extern void reinit_search_statistics\t\tPROTO((void));\n-extern tree current_scope\t\t\tPROTO((void));\n-extern int at_function_scope_p                  PROTO((void));\n-extern tree lookup_conversions\t\t\tPROTO((tree));\n-extern tree binfo_for_vtable\t\t\tPROTO((tree));\n-extern int  binfo_from_vbase\t\t\tPROTO((tree));\n-extern tree dfs_walk                            PROTO((tree, \n+extern int types_overlap_p\t\t\tPARAMS ((tree, tree));\n+extern tree get_vbase\t\t\t\tPARAMS ((tree, tree));\n+extern tree get_binfo\t\t\t\tPARAMS ((tree, tree, int));\n+extern int get_base_distance\t\t\tPARAMS ((tree, tree, int, tree *));\n+extern tree get_dynamic_cast_base_type          PARAMS ((tree, tree));\n+extern int accessible_p                         PARAMS ((tree, tree));\n+extern tree lookup_field\t\t\tPARAMS ((tree, tree, int, int));\n+extern int lookup_fnfields_1                    PARAMS ((tree, tree));\n+extern tree lookup_fnfields\t\t\tPARAMS ((tree, tree, int));\n+extern tree lookup_member\t\t\tPARAMS ((tree, tree, int, int));\n+extern tree lookup_nested_tag\t\t\tPARAMS ((tree, tree));\n+extern tree get_matching_virtual\t\tPARAMS ((tree, tree, int));\n+extern void get_pure_virtuals\t\t        PARAMS ((tree));\n+extern tree init_vbase_pointers\t\t\tPARAMS ((tree, tree));\n+extern void expand_indirect_vtbls_init\t\tPARAMS ((tree, tree));\n+extern void clear_search_slots\t\t\tPARAMS ((tree));\n+extern void get_vbase_types\t\t\tPARAMS ((tree));\n+extern void maybe_suppress_debug_info\t\tPARAMS ((tree));\n+extern void note_debug_info_needed\t\tPARAMS ((tree));\n+extern void push_class_decls\t\t\tPARAMS ((tree));\n+extern void pop_class_decls\t\t\tPARAMS ((void));\n+extern void unuse_fields\t\t\tPARAMS ((tree));\n+extern void print_search_statistics\t\tPARAMS ((void));\n+extern void init_search_processing\t\tPARAMS ((void));\n+extern void reinit_search_statistics\t\tPARAMS ((void));\n+extern tree current_scope\t\t\tPARAMS ((void));\n+extern int at_function_scope_p                  PARAMS ((void));\n+extern tree lookup_conversions\t\t\tPARAMS ((tree));\n+extern tree binfo_for_vtable\t\t\tPARAMS ((tree));\n+extern int  binfo_from_vbase\t\t\tPARAMS ((tree));\n+extern tree dfs_walk                            PARAMS ((tree, \n \t\t\t\t\t\t       tree (*)(tree, void *),\n \t\t\t\t\t\t       tree (*) (tree, void *),\n \t\t\t\t\t\t       void *));\n-extern tree dfs_walk_real                      PROTO ((tree, \n+extern tree dfs_walk_real                      PARAMS ((tree, \n \t\t\t\t\t\t       tree (*) (tree, void *),\n \t\t\t\t\t\t       tree (*) (tree, void *),\n \t\t\t\t\t\t       tree (*) (tree, void *),\n \t\t\t\t\t\t       void *));\n-extern tree dfs_unmark                          PROTO((tree, void *));\n-extern tree dfs_vbase_unmark                    PROTO((tree, void *));\n-extern tree dfs_vtable_path_unmark              PROTO((tree, void *));\n-extern tree markedp                             PROTO((tree, void *));\n-extern tree unmarkedp                           PROTO((tree, void *));\n-extern tree dfs_skip_nonprimary_vbases_unmarkedp PROTO((tree, void *));\n-extern tree dfs_skip_nonprimary_vbases_markedp  PROTO((tree, void *));\n-extern tree dfs_unmarked_real_bases_queue_p     PROTO((tree, void *));\n-extern tree dfs_marked_real_bases_queue_p       PROTO((tree, void *));\n+extern tree dfs_unmark                          PARAMS ((tree, void *));\n+extern tree dfs_vbase_unmark                    PARAMS ((tree, void *));\n+extern tree dfs_vtable_path_unmark              PARAMS ((tree, void *));\n+extern tree markedp                             PARAMS ((tree, void *));\n+extern tree unmarkedp                           PARAMS ((tree, void *));\n+extern tree dfs_skip_nonprimary_vbases_unmarkedp PARAMS ((tree, void *));\n+extern tree dfs_skip_nonprimary_vbases_markedp  PARAMS ((tree, void *));\n+extern tree dfs_unmarked_real_bases_queue_p     PARAMS ((tree, void *));\n+extern tree dfs_marked_real_bases_queue_p       PARAMS ((tree, void *));\n extern tree dfs_vtable_path_unmarked_real_bases_queue_p\n-                                                PROTO((tree, void *));\n+                                                PARAMS ((tree, void *));\n extern tree dfs_vtable_path_marked_real_bases_queue_p\n-                                                PROTO((tree, void *));\n-extern tree dfs_skip_vbases                     PROTO((tree, void *));\n-extern void mark_primary_bases                  PROTO((tree));\n-extern tree convert_pointer_to_vbase            PROTO((tree, tree));\n-extern tree find_vbase_instance                 PROTO((tree, tree));\n+                                                PARAMS ((tree, void *));\n+extern tree dfs_skip_vbases                     PARAMS ((tree, void *));\n+extern void mark_primary_bases                  PARAMS ((tree));\n+extern tree convert_pointer_to_vbase            PARAMS ((tree, tree));\n+extern tree find_vbase_instance                 PARAMS ((tree, tree));\n \n /* in semantics.c */\n-extern void finish_expr_stmt                    PROTO((tree));\n-extern tree begin_if_stmt                       PROTO((void));\n-extern void finish_if_stmt_cond                 PROTO((tree, tree));\n-extern tree finish_then_clause                  PROTO((tree));\n-extern void begin_else_clause                   PROTO((void));\n-extern void finish_else_clause                  PROTO((tree));\n-extern void finish_if_stmt                      PROTO((void));\n-extern tree begin_while_stmt                    PROTO((void));\n-extern void finish_while_stmt_cond              PROTO((tree, tree));\n-extern void finish_while_stmt                   PROTO((tree));\n-extern tree begin_do_stmt                       PROTO((void));\n-extern void finish_do_body                      PROTO((tree));\n-extern void finish_do_stmt                      PROTO((tree, tree));\n-extern void finish_return_stmt                  PROTO((tree));\n-extern tree begin_for_stmt                      PROTO((void));\n-extern void finish_for_init_stmt                PROTO((tree));\n-extern void finish_for_cond                     PROTO((tree, tree));\n-extern void finish_for_expr                     PROTO((tree, tree));\n-extern void finish_for_stmt                     PROTO((tree, tree));\n-extern void finish_break_stmt                   PROTO((void));\n-extern void finish_continue_stmt                PROTO((void));\n-extern tree begin_switch_stmt                   PROTO((void));\n-extern void finish_switch_cond                  PROTO((tree, tree));\n-extern void finish_switch_stmt                  PROTO((tree, tree));\n-extern void finish_case_label                   PROTO((tree, tree));\n-extern void finish_goto_stmt                    PROTO((tree));\n-extern tree begin_try_block                     PROTO((void));\n-extern void finish_try_block                    PROTO((tree));\n-extern void finish_handler_sequence             PROTO((tree));\n-extern tree begin_function_try_block            PROTO((void));\n-extern void finish_function_try_block           PROTO((tree));\n-extern void finish_function_handler_sequence    PROTO((tree));\n-extern void finish_cleanup_try_block            PROTO((tree));\n-extern tree begin_handler                       PROTO((void));\n-extern tree finish_handler_parms                PROTO((tree, tree));\n-extern void begin_catch_block                   PROTO((tree));\n-extern void finish_handler                      PROTO((tree, tree));\n-extern void finish_cleanup                      PROTO((tree, tree));\n-extern tree begin_compound_stmt                 PROTO((int));\n-extern tree finish_compound_stmt                PROTO((int, tree));\n-extern void finish_asm_stmt                     PROTO((tree, tree, tree, tree, tree));\n-extern void finish_label_stmt                   PROTO((tree));\n-extern void finish_label_decl                   PROTO((tree));\n-extern void finish_subobject                    PROTO((tree));\n-extern tree finish_parenthesized_expr           PROTO((tree));\n-extern tree begin_stmt_expr                     PROTO((void));\n-extern tree finish_stmt_expr                    PROTO((tree));\n-extern tree finish_call_expr                    PROTO((tree, tree, int));\n-extern tree finish_increment_expr               PROTO((tree, enum tree_code));\n-extern tree finish_this_expr                    PROTO((void));\n-extern tree finish_object_call_expr             PROTO((tree, tree, tree));\n-extern tree finish_qualified_object_call_expr   PROTO((tree, tree, tree));\n-extern tree finish_pseudo_destructor_call_expr  PROTO((tree, tree, tree));\n-extern tree finish_qualified_call_expr          PROTO ((tree, tree));\n-extern tree finish_label_address_expr           PROTO((tree));\n-extern tree finish_unary_op_expr                PROTO((enum tree_code, tree));\n-extern tree finish_id_expr                      PROTO((tree));\n-extern int begin_function_definition            PROTO((tree, tree));\n-extern tree begin_constructor_declarator        PROTO((tree, tree));\n-extern tree finish_declarator                   PROTO((tree, tree, tree, tree, int));\n-extern void finish_translation_unit             PROTO((void));\n-extern tree finish_template_type_parm           PROTO((tree, tree));\n-extern tree finish_template_template_parm       PROTO((tree, tree));\n-extern tree finish_parmlist                     PROTO((tree, int));\n-extern tree begin_class_definition              PROTO((tree));\n-extern tree finish_class_definition             PROTO((tree, tree, int, int));\n-extern void finish_default_args                 PROTO((void));\n-extern void begin_inline_definitions            PROTO((void));\n-extern void finish_inline_definitions           PROTO((void));\n-extern tree finish_member_class_template        PROTO((tree));\n-extern void finish_template_decl                PROTO((tree));\n-extern tree finish_template_type                PROTO((tree, tree, int));\n-extern void enter_scope_of                      PROTO((tree));\n-extern tree finish_base_specifier               PROTO((tree, tree));\n-extern void finish_member_declaration           PROTO((tree));\n-extern void check_multiple_declarators          PROTO((void));\n-extern tree finish_typeof\t\t\tPROTO((tree));\n-extern void add_decl_stmt                       PROTO((tree));\n-extern void finish_decl_cleanup                 PROTO((tree, tree));\n-extern void finish_named_return_value           PROTO((tree, tree));\n-extern tree expand_stmt                         PROTO((tree));\n-extern void expand_body                         PROTO((tree));\n-extern void begin_stmt_tree                     PROTO((tree *));\n-extern void finish_stmt_tree                    PROTO((tree *));\n-extern void prep_stmt                           PROTO((tree));\n-extern tree add_scope_stmt                      PROTO((int, int));\n-extern void do_pushlevel                        PROTO((void));\n-extern tree do_poplevel                         PROTO((void));\n+extern void finish_expr_stmt                    PARAMS ((tree));\n+extern tree begin_if_stmt                       PARAMS ((void));\n+extern void finish_if_stmt_cond                 PARAMS ((tree, tree));\n+extern tree finish_then_clause                  PARAMS ((tree));\n+extern void begin_else_clause                   PARAMS ((void));\n+extern void finish_else_clause                  PARAMS ((tree));\n+extern void finish_if_stmt                      PARAMS ((void));\n+extern tree begin_while_stmt                    PARAMS ((void));\n+extern void finish_while_stmt_cond              PARAMS ((tree, tree));\n+extern void finish_while_stmt                   PARAMS ((tree));\n+extern tree begin_do_stmt                       PARAMS ((void));\n+extern void finish_do_body                      PARAMS ((tree));\n+extern void finish_do_stmt                      PARAMS ((tree, tree));\n+extern void finish_return_stmt                  PARAMS ((tree));\n+extern tree begin_for_stmt                      PARAMS ((void));\n+extern void finish_for_init_stmt                PARAMS ((tree));\n+extern void finish_for_cond                     PARAMS ((tree, tree));\n+extern void finish_for_expr                     PARAMS ((tree, tree));\n+extern void finish_for_stmt                     PARAMS ((tree, tree));\n+extern void finish_break_stmt                   PARAMS ((void));\n+extern void finish_continue_stmt                PARAMS ((void));\n+extern tree begin_switch_stmt                   PARAMS ((void));\n+extern void finish_switch_cond                  PARAMS ((tree, tree));\n+extern void finish_switch_stmt                  PARAMS ((tree, tree));\n+extern void finish_case_label                   PARAMS ((tree, tree));\n+extern void finish_goto_stmt                    PARAMS ((tree));\n+extern tree begin_try_block                     PARAMS ((void));\n+extern void finish_try_block                    PARAMS ((tree));\n+extern void finish_handler_sequence             PARAMS ((tree));\n+extern tree begin_function_try_block            PARAMS ((void));\n+extern void finish_function_try_block           PARAMS ((tree));\n+extern void finish_function_handler_sequence    PARAMS ((tree));\n+extern void finish_cleanup_try_block            PARAMS ((tree));\n+extern tree begin_handler                       PARAMS ((void));\n+extern tree finish_handler_parms                PARAMS ((tree, tree));\n+extern void begin_catch_block                   PARAMS ((tree));\n+extern void finish_handler                      PARAMS ((tree, tree));\n+extern void finish_cleanup                      PARAMS ((tree, tree));\n+extern tree begin_compound_stmt                 PARAMS ((int));\n+extern tree finish_compound_stmt                PARAMS ((int, tree));\n+extern void finish_asm_stmt                     PARAMS ((tree, tree, tree, tree, tree));\n+extern void finish_label_stmt                   PARAMS ((tree));\n+extern void finish_label_decl                   PARAMS ((tree));\n+extern void finish_subobject                    PARAMS ((tree));\n+extern tree finish_parenthesized_expr           PARAMS ((tree));\n+extern tree begin_stmt_expr                     PARAMS ((void));\n+extern tree finish_stmt_expr                    PARAMS ((tree));\n+extern tree finish_call_expr                    PARAMS ((tree, tree, int));\n+extern tree finish_increment_expr               PARAMS ((tree, enum tree_code));\n+extern tree finish_this_expr                    PARAMS ((void));\n+extern tree finish_object_call_expr             PARAMS ((tree, tree, tree));\n+extern tree finish_qualified_object_call_expr   PARAMS ((tree, tree, tree));\n+extern tree finish_pseudo_destructor_call_expr  PARAMS ((tree, tree, tree));\n+extern tree finish_qualified_call_expr          PARAMS ((tree, tree));\n+extern tree finish_label_address_expr           PARAMS ((tree));\n+extern tree finish_unary_op_expr                PARAMS ((enum tree_code, tree));\n+extern tree finish_id_expr                      PARAMS ((tree));\n+extern int begin_function_definition            PARAMS ((tree, tree));\n+extern tree begin_constructor_declarator        PARAMS ((tree, tree));\n+extern tree finish_declarator                   PARAMS ((tree, tree, tree, tree, int));\n+extern void finish_translation_unit             PARAMS ((void));\n+extern tree finish_template_type_parm           PARAMS ((tree, tree));\n+extern tree finish_template_template_parm       PARAMS ((tree, tree));\n+extern tree finish_parmlist                     PARAMS ((tree, int));\n+extern tree begin_class_definition              PARAMS ((tree));\n+extern tree finish_class_definition             PARAMS ((tree, tree, int, int));\n+extern void finish_default_args                 PARAMS ((void));\n+extern void begin_inline_definitions            PARAMS ((void));\n+extern void finish_inline_definitions           PARAMS ((void));\n+extern tree finish_member_class_template        PARAMS ((tree));\n+extern void finish_template_decl                PARAMS ((tree));\n+extern tree finish_template_type                PARAMS ((tree, tree, int));\n+extern void enter_scope_of                      PARAMS ((tree));\n+extern tree finish_base_specifier               PARAMS ((tree, tree));\n+extern void finish_member_declaration           PARAMS ((tree));\n+extern void check_multiple_declarators          PARAMS ((void));\n+extern tree finish_typeof\t\t\tPARAMS ((tree));\n+extern void add_decl_stmt                       PARAMS ((tree));\n+extern void finish_decl_cleanup                 PARAMS ((tree, tree));\n+extern void finish_named_return_value           PARAMS ((tree, tree));\n+extern tree expand_stmt                         PARAMS ((tree));\n+extern void expand_body                         PARAMS ((tree));\n+extern void begin_stmt_tree                     PARAMS ((tree *));\n+extern void finish_stmt_tree                    PARAMS ((tree *));\n+extern void prep_stmt                           PARAMS ((tree));\n+extern tree add_scope_stmt                      PARAMS ((int, int));\n+extern void do_pushlevel                        PARAMS ((void));\n+extern tree do_poplevel                         PARAMS ((void));\n /* Non-zero if we are presently building a statement tree, rather\n    than expanding each statement as we encounter it.  */\n #define building_stmt_tree() (last_tree != NULL_TREE)\n \n /* in spew.c */\n-extern void init_spew\t\t\t\tPROTO((void));\n-extern int peekyylex\t\t\t\tPROTO((void));\n-extern int yylex\t\t\t\tPROTO((void));\n-extern tree arbitrate_lookup\t\t\tPROTO((tree, tree, tree));\n+extern void init_spew\t\t\t\tPARAMS ((void));\n+extern int peekyylex\t\t\t\tPARAMS ((void));\n+extern int yylex\t\t\t\tPARAMS ((void));\n+extern tree arbitrate_lookup\t\t\tPARAMS ((tree, tree, tree));\n \n /* in tree.c */\n-extern void init_tree\t\t\t        PROTO((void));\n-extern int pod_type_p\t\t\t\tPROTO((tree));\n-extern void unshare_base_binfos\t\t\tPROTO((tree));\n-extern int member_p\t\t\t\tPROTO((tree));\n-extern cp_lvalue_kind real_lvalue_p\t\tPROTO((tree));\n-extern tree build_min\t\t\t\tPVPROTO((enum tree_code, tree, ...));\n-extern tree build_min_nt\t\t\tPVPROTO((enum tree_code, ...));\n-extern int lvalue_p\t\t\t\tPROTO((tree));\n-extern int lvalue_or_else\t\t\tPROTO((tree, const char *));\n-extern tree build_cplus_new\t\t\tPROTO((tree, tree));\n-extern tree get_target_expr\t\t\tPROTO((tree));\n-extern tree break_out_cleanups\t\t\tPROTO((tree));\n-extern tree break_out_calls\t\t\tPROTO((tree));\n-extern tree build_cplus_method_type\t\tPROTO((tree, tree, tree));\n-extern tree build_cplus_staticfn_type\t\tPROTO((tree, tree, tree));\n-extern tree build_cplus_array_type\t\tPROTO((tree, tree));\n-extern tree hash_tree_cons\t\t\tPROTO((tree, tree, tree));\n-extern tree hash_tree_chain\t\t\tPROTO((tree, tree));\n-extern tree hash_chainon\t\t\tPROTO((tree, tree));\n-extern tree make_binfo\t\t\t\tPROTO((tree, tree, tree, tree));\n-extern tree binfo_value\t\t\t\tPROTO((tree, tree));\n-extern tree reverse_path\t\t\tPROTO((tree));\n-extern int count_functions\t\t\tPROTO((tree));\n-extern int is_overloaded_fn\t\t\tPROTO((tree));\n-extern tree get_first_fn\t\t\tPROTO((tree));\n-extern int bound_pmf_p\t\t\t\tPROTO((tree));\n-extern tree ovl_cons                            PROTO((tree, tree));\n-extern int ovl_member                           PROTO((tree, tree));\n-extern tree build_overload                      PROTO((tree, tree));\n-extern tree fnaddr_from_vtable_entry\t\tPROTO((tree));\n-extern tree function_arg_chain\t\t\tPROTO((tree));\n-extern int promotes_to_aggr_type\t\tPROTO((tree, enum tree_code));\n-extern int is_aggr_type_2\t\t\tPROTO((tree, tree));\n-extern const char *lang_printable_name\t\tPROTO((tree, int));\n-extern tree build_exception_variant\t\tPROTO((tree, tree));\n-extern tree copy_template_template_parm\t\tPROTO((tree));\n-extern void print_lang_statistics\t\tPROTO((void));\n-extern tree array_type_nelts_total\t\tPROTO((tree));\n-extern tree array_type_nelts_top\t\tPROTO((tree));\n-extern tree break_out_target_exprs\t\tPROTO((tree));\n-extern tree get_type_decl\t\t\tPROTO((tree));\n-extern tree vec_binfo_member\t\t\tPROTO((tree, tree));\n-extern tree hack_decl_function_context \t\tPROTO((tree));\n-extern tree decl_namespace_context \t\tPROTO((tree));\n-extern tree lvalue_type\t\t\t\tPROTO((tree));\n-extern tree error_type\t\t\t\tPROTO((tree));\n-extern tree build_ptr_wrapper\t\t\tPROTO((void *));\n-extern tree build_expr_ptr_wrapper\t\tPROTO((void *));\n-extern tree build_int_wrapper\t\t\tPROTO((int));\n-extern tree build_srcloc_here\t\t\tPROTO((void));\n-extern int varargs_function_p\t\t\tPROTO((tree));\n-extern int really_overloaded_fn\t\t\tPROTO((tree));\n-extern int cp_tree_equal\t\t\tPROTO((tree, tree));\n-extern int can_free\t\t\t\tPROTO((struct obstack *, tree));\n-extern tree no_linkage_check\t\t\tPROTO((tree));\n-extern void debug_binfo\t\t\t\tPROTO((tree));\n-extern tree build_dummy_object\t\t\tPROTO((tree));\n-extern tree maybe_dummy_object\t\t\tPROTO((tree, tree *));\n-extern int is_dummy_object\t\t\tPROTO((tree));\n-typedef tree (*walk_tree_fn)                    PROTO((tree *, int *, void *));\n-extern tree walk_tree                           PROTO((tree *, walk_tree_fn, void *));\n-extern tree copy_tree_r                         PROTO((tree *, int *, void *));\n-extern int cp_valid_lang_attribute\t\tPROTO((tree, tree, tree, tree));\n-extern tree make_ptrmem_cst                     PROTO((tree, tree));\n-extern tree cp_build_qualified_type_real        PROTO((tree, int, int));\n-extern void remap_save_expr                     PROTO((tree *, splay_tree, tree, int *));\n+extern void init_tree\t\t\t        PARAMS ((void));\n+extern int pod_type_p\t\t\t\tPARAMS ((tree));\n+extern void unshare_base_binfos\t\t\tPARAMS ((tree));\n+extern int member_p\t\t\t\tPARAMS ((tree));\n+extern cp_lvalue_kind real_lvalue_p\t\tPARAMS ((tree));\n+extern tree build_min\t\t\t\tPARAMS ((enum tree_code, tree, ...));\n+extern tree build_min_nt\t\t\tPARAMS ((enum tree_code, ...));\n+extern int lvalue_p\t\t\t\tPARAMS ((tree));\n+extern int lvalue_or_else\t\t\tPARAMS ((tree, const char *));\n+extern tree build_cplus_new\t\t\tPARAMS ((tree, tree));\n+extern tree get_target_expr\t\t\tPARAMS ((tree));\n+extern tree break_out_cleanups\t\t\tPARAMS ((tree));\n+extern tree break_out_calls\t\t\tPARAMS ((tree));\n+extern tree build_cplus_method_type\t\tPARAMS ((tree, tree, tree));\n+extern tree build_cplus_staticfn_type\t\tPARAMS ((tree, tree, tree));\n+extern tree build_cplus_array_type\t\tPARAMS ((tree, tree));\n+extern tree hash_tree_cons\t\t\tPARAMS ((tree, tree, tree));\n+extern tree hash_tree_chain\t\t\tPARAMS ((tree, tree));\n+extern tree hash_chainon\t\t\tPARAMS ((tree, tree));\n+extern tree make_binfo\t\t\t\tPARAMS ((tree, tree, tree, tree));\n+extern tree binfo_value\t\t\t\tPARAMS ((tree, tree));\n+extern tree reverse_path\t\t\tPARAMS ((tree));\n+extern int count_functions\t\t\tPARAMS ((tree));\n+extern int is_overloaded_fn\t\t\tPARAMS ((tree));\n+extern tree get_first_fn\t\t\tPARAMS ((tree));\n+extern int bound_pmf_p\t\t\t\tPARAMS ((tree));\n+extern tree ovl_cons                            PARAMS ((tree, tree));\n+extern int ovl_member                           PARAMS ((tree, tree));\n+extern tree build_overload                      PARAMS ((tree, tree));\n+extern tree fnaddr_from_vtable_entry\t\tPARAMS ((tree));\n+extern tree function_arg_chain\t\t\tPARAMS ((tree));\n+extern int promotes_to_aggr_type\t\tPARAMS ((tree, enum tree_code));\n+extern int is_aggr_type_2\t\t\tPARAMS ((tree, tree));\n+extern const char *lang_printable_name\t\tPARAMS ((tree, int));\n+extern tree build_exception_variant\t\tPARAMS ((tree, tree));\n+extern tree copy_template_template_parm\t\tPARAMS ((tree));\n+extern void print_lang_statistics\t\tPARAMS ((void));\n+extern tree array_type_nelts_total\t\tPARAMS ((tree));\n+extern tree array_type_nelts_top\t\tPARAMS ((tree));\n+extern tree break_out_target_exprs\t\tPARAMS ((tree));\n+extern tree get_type_decl\t\t\tPARAMS ((tree));\n+extern tree vec_binfo_member\t\t\tPARAMS ((tree, tree));\n+extern tree hack_decl_function_context \t\tPARAMS ((tree));\n+extern tree decl_namespace_context \t\tPARAMS ((tree));\n+extern tree lvalue_type\t\t\t\tPARAMS ((tree));\n+extern tree error_type\t\t\t\tPARAMS ((tree));\n+extern tree build_ptr_wrapper\t\t\tPARAMS ((void *));\n+extern tree build_expr_ptr_wrapper\t\tPARAMS ((void *));\n+extern tree build_int_wrapper\t\t\tPARAMS ((int));\n+extern tree build_srcloc_here\t\t\tPARAMS ((void));\n+extern int varargs_function_p\t\t\tPARAMS ((tree));\n+extern int really_overloaded_fn\t\t\tPARAMS ((tree));\n+extern int cp_tree_equal\t\t\tPARAMS ((tree, tree));\n+extern int can_free\t\t\t\tPARAMS ((struct obstack *, tree));\n+extern tree no_linkage_check\t\t\tPARAMS ((tree));\n+extern void debug_binfo\t\t\t\tPARAMS ((tree));\n+extern tree build_dummy_object\t\t\tPARAMS ((tree));\n+extern tree maybe_dummy_object\t\t\tPARAMS ((tree, tree *));\n+extern int is_dummy_object\t\t\tPARAMS ((tree));\n+typedef tree (*walk_tree_fn)                    PARAMS ((tree *, int *, void *));\n+extern tree walk_tree                           PARAMS ((tree *, walk_tree_fn, void *));\n+extern tree copy_tree_r                         PARAMS ((tree *, int *, void *));\n+extern int cp_valid_lang_attribute\t\tPARAMS ((tree, tree, tree, tree));\n+extern tree make_ptrmem_cst                     PARAMS ((tree, tree));\n+extern tree cp_build_qualified_type_real        PARAMS ((tree, int, int));\n+extern void remap_save_expr                     PARAMS ((tree *, splay_tree, tree, int *));\n #define cp_build_qualified_type(TYPE, QUALS) \\\n   cp_build_qualified_type_real ((TYPE), (QUALS), /*complain=*/1)\n-extern tree build_shared_int_cst                PROTO((int));\n+extern tree build_shared_int_cst                PARAMS ((int));\n \n /* in typeck.c */\n-extern int string_conv_p\t\t\tPROTO((tree, tree, int));\n-extern tree condition_conversion\t\tPROTO((tree));\n-extern tree target_type\t\t\t\tPROTO((tree));\n-extern tree require_complete_type\t\tPROTO((tree));\n-extern tree complete_type\t\t\tPROTO((tree));\n-extern tree complete_type_or_else               PROTO((tree, tree));\n-extern int type_unknown_p\t\t\tPROTO((tree));\n-extern int fntype_p\t\t\t\tPROTO((tree));\n-extern tree commonparms\t\t\t\tPROTO((tree, tree));\n-extern tree original_type\t\t\tPROTO((tree));\n-extern tree common_type\t\t\t\tPROTO((tree, tree));\n-extern int comp_except_specs\t\t\tPROTO((tree, tree, int));\n-extern int comptypes\t\t\t\tPROTO((tree, tree, int));\n-extern int comp_target_types\t\t\tPROTO((tree, tree, int));\n-extern int compparms\t\t\t\tPROTO((tree, tree));\n-extern int comp_target_types\t\t\tPROTO((tree, tree, int));\n-extern int comp_cv_qualification                PROTO((tree, tree));\n-extern int comp_cv_qual_signature               PROTO((tree, tree));\n-extern tree unsigned_type\t\t\tPROTO((tree));\n-extern tree signed_type\t\t\t\tPROTO((tree));\n-extern tree signed_or_unsigned_type\t\tPROTO((int, tree));\n-extern tree expr_sizeof\t\t\t\tPROTO((tree));\n-extern tree c_sizeof\t\t\t\tPROTO((tree));\n-extern tree c_sizeof_nowarn\t\t\tPROTO((tree));\n-extern tree c_alignof\t\t\t\tPROTO((tree));\n-extern tree inline_conversion\t\t\tPROTO((tree));\n-extern tree decay_conversion\t\t\tPROTO((tree));\n-extern tree default_conversion\t\t\tPROTO((tree));\n-extern tree build_object_ref\t\t\tPROTO((tree, tree, tree));\n-extern tree build_component_ref_1\t\tPROTO((tree, tree, int));\n-extern tree build_component_ref\t\t\tPROTO((tree, tree, tree, int));\n-extern tree build_x_component_ref\t\tPROTO((tree, tree, tree, int));\n-extern tree build_x_indirect_ref\t\tPROTO((tree, const char *));\n-extern tree build_indirect_ref\t\t\tPROTO((tree, const char *));\n-extern tree build_array_ref\t\t\tPROTO((tree, tree));\n-extern tree build_x_function_call\t\tPROTO((tree, tree, tree));\n-extern tree get_member_function_from_ptrfunc\tPROTO((tree *, tree));\n-extern tree build_function_call_real\t\tPROTO((tree, tree, int, int));\n-extern tree build_function_call\t\t\tPROTO((tree, tree));\n-extern tree build_function_call_maybe\t\tPROTO((tree, tree));\n-extern tree convert_arguments\t\t\tPROTO((tree, tree, tree, int));\n-extern tree build_x_binary_op\t\t\tPROTO((enum tree_code, tree, tree));\n-extern tree build_binary_op\t\t\tPROTO((enum tree_code, tree, tree));\n-extern tree build_binary_op_nodefault\t\tPROTO((enum tree_code, tree, tree, enum tree_code));\n-extern tree build_x_unary_op\t\t\tPROTO((enum tree_code, tree));\n-extern tree build_unary_op\t\t\tPROTO((enum tree_code, tree, int));\n-extern tree unary_complex_lvalue\t\tPROTO((enum tree_code, tree));\n-extern int mark_addressable\t\t\tPROTO((tree));\n-extern tree build_x_conditional_expr\t\tPROTO((tree, tree, tree));\n-extern tree build_conditional_expr\t\tPROTO((tree, tree, tree));\n-extern tree build_x_compound_expr\t\tPROTO((tree));\n-extern tree build_compound_expr\t\t\tPROTO((tree));\n-extern tree build_static_cast\t\t\tPROTO((tree, tree));\n-extern tree build_reinterpret_cast\t\tPROTO((tree, tree));\n-extern tree build_const_cast\t\t\tPROTO((tree, tree));\n-extern tree build_c_cast\t\t\tPROTO((tree, tree));\n-extern tree build_x_modify_expr\t\t\tPROTO((tree, enum tree_code, tree));\n-extern tree build_modify_expr\t\t\tPROTO((tree, enum tree_code, tree));\n-extern tree convert_for_initialization\t\tPROTO((tree, tree, tree, int, const char *, tree, int));\n-extern void c_expand_asm_operands\t\tPROTO((tree, tree, tree, tree, int, char *, int));\n-extern void c_expand_return\t\t\tPROTO((tree));\n-extern tree c_expand_start_case\t\t\tPROTO((tree));\n-extern int comp_ptr_ttypes\t\t\tPROTO((tree, tree));\n-extern int ptr_reasonably_similar\t\tPROTO((tree, tree));\n-extern tree build_ptrmemfunc\t\t\tPROTO((tree, tree, int));\n-extern tree strip_array_types                   PROTO((tree));\n-extern int cp_type_quals                        PROTO((tree));\n-extern int cp_has_mutable_p                     PROTO((tree));\n-extern int at_least_as_qualified_p              PROTO((tree, tree));\n-extern int more_qualified_p                     PROTO((tree, tree));\n-extern tree build_ptrmemfunc1                   PROTO((tree, tree, tree, tree, tree));\n-extern void expand_ptrmemfunc_cst               PROTO((tree, tree *, tree *, tree *, tree *));\n-extern tree delta2_from_ptrmemfunc              PROTO((tree));\n-extern tree pfn_from_ptrmemfunc                 PROTO((tree));\n-extern tree type_after_usual_arithmetic_conversions PROTO((tree, tree));\n-extern tree composite_pointer_type              PROTO((tree, tree, tree, tree,\n+extern int string_conv_p\t\t\tPARAMS ((tree, tree, int));\n+extern tree condition_conversion\t\tPARAMS ((tree));\n+extern tree target_type\t\t\t\tPARAMS ((tree));\n+extern tree require_complete_type\t\tPARAMS ((tree));\n+extern tree complete_type\t\t\tPARAMS ((tree));\n+extern tree complete_type_or_else               PARAMS ((tree, tree));\n+extern int type_unknown_p\t\t\tPARAMS ((tree));\n+extern int fntype_p\t\t\t\tPARAMS ((tree));\n+extern tree commonparms\t\t\t\tPARAMS ((tree, tree));\n+extern tree original_type\t\t\tPARAMS ((tree));\n+extern tree common_type\t\t\t\tPARAMS ((tree, tree));\n+extern int comp_except_specs\t\t\tPARAMS ((tree, tree, int));\n+extern int comptypes\t\t\t\tPARAMS ((tree, tree, int));\n+extern int comp_target_types\t\t\tPARAMS ((tree, tree, int));\n+extern int compparms\t\t\t\tPARAMS ((tree, tree));\n+extern int comp_target_types\t\t\tPARAMS ((tree, tree, int));\n+extern int comp_cv_qualification                PARAMS ((tree, tree));\n+extern int comp_cv_qual_signature               PARAMS ((tree, tree));\n+extern tree unsigned_type\t\t\tPARAMS ((tree));\n+extern tree signed_type\t\t\t\tPARAMS ((tree));\n+extern tree signed_or_unsigned_type\t\tPARAMS ((int, tree));\n+extern tree expr_sizeof\t\t\t\tPARAMS ((tree));\n+extern tree c_sizeof\t\t\t\tPARAMS ((tree));\n+extern tree c_sizeof_nowarn\t\t\tPARAMS ((tree));\n+extern tree c_alignof\t\t\t\tPARAMS ((tree));\n+extern tree inline_conversion\t\t\tPARAMS ((tree));\n+extern tree decay_conversion\t\t\tPARAMS ((tree));\n+extern tree default_conversion\t\t\tPARAMS ((tree));\n+extern tree build_object_ref\t\t\tPARAMS ((tree, tree, tree));\n+extern tree build_component_ref_1\t\tPARAMS ((tree, tree, int));\n+extern tree build_component_ref\t\t\tPARAMS ((tree, tree, tree, int));\n+extern tree build_x_component_ref\t\tPARAMS ((tree, tree, tree, int));\n+extern tree build_x_indirect_ref\t\tPARAMS ((tree, const char *));\n+extern tree build_indirect_ref\t\t\tPARAMS ((tree, const char *));\n+extern tree build_array_ref\t\t\tPARAMS ((tree, tree));\n+extern tree build_x_function_call\t\tPARAMS ((tree, tree, tree));\n+extern tree get_member_function_from_ptrfunc\tPARAMS ((tree *, tree));\n+extern tree build_function_call_real\t\tPARAMS ((tree, tree, int, int));\n+extern tree build_function_call\t\t\tPARAMS ((tree, tree));\n+extern tree build_function_call_maybe\t\tPARAMS ((tree, tree));\n+extern tree convert_arguments\t\t\tPARAMS ((tree, tree, tree, int));\n+extern tree build_x_binary_op\t\t\tPARAMS ((enum tree_code, tree, tree));\n+extern tree build_binary_op\t\t\tPARAMS ((enum tree_code, tree, tree));\n+extern tree build_binary_op_nodefault\t\tPARAMS ((enum tree_code, tree, tree, enum tree_code));\n+extern tree build_x_unary_op\t\t\tPARAMS ((enum tree_code, tree));\n+extern tree build_unary_op\t\t\tPARAMS ((enum tree_code, tree, int));\n+extern tree unary_complex_lvalue\t\tPARAMS ((enum tree_code, tree));\n+extern int mark_addressable\t\t\tPARAMS ((tree));\n+extern tree build_x_conditional_expr\t\tPARAMS ((tree, tree, tree));\n+extern tree build_conditional_expr\t\tPARAMS ((tree, tree, tree));\n+extern tree build_x_compound_expr\t\tPARAMS ((tree));\n+extern tree build_compound_expr\t\t\tPARAMS ((tree));\n+extern tree build_static_cast\t\t\tPARAMS ((tree, tree));\n+extern tree build_reinterpret_cast\t\tPARAMS ((tree, tree));\n+extern tree build_const_cast\t\t\tPARAMS ((tree, tree));\n+extern tree build_c_cast\t\t\tPARAMS ((tree, tree));\n+extern tree build_x_modify_expr\t\t\tPARAMS ((tree, enum tree_code, tree));\n+extern tree build_modify_expr\t\t\tPARAMS ((tree, enum tree_code, tree));\n+extern tree convert_for_initialization\t\tPARAMS ((tree, tree, tree, int, const char *, tree, int));\n+extern void c_expand_asm_operands\t\tPARAMS ((tree, tree, tree, tree, int, char *, int));\n+extern void c_expand_return\t\t\tPARAMS ((tree));\n+extern tree c_expand_start_case\t\t\tPARAMS ((tree));\n+extern int comp_ptr_ttypes\t\t\tPARAMS ((tree, tree));\n+extern int ptr_reasonably_similar\t\tPARAMS ((tree, tree));\n+extern tree build_ptrmemfunc\t\t\tPARAMS ((tree, tree, int));\n+extern tree strip_array_types                   PARAMS ((tree));\n+extern int cp_type_quals                        PARAMS ((tree));\n+extern int cp_has_mutable_p                     PARAMS ((tree));\n+extern int at_least_as_qualified_p              PARAMS ((tree, tree));\n+extern int more_qualified_p                     PARAMS ((tree, tree));\n+extern tree build_ptrmemfunc1                   PARAMS ((tree, tree, tree, tree, tree));\n+extern void expand_ptrmemfunc_cst               PARAMS ((tree, tree *, tree *, tree *, tree *));\n+extern tree delta2_from_ptrmemfunc              PARAMS ((tree));\n+extern tree pfn_from_ptrmemfunc                 PARAMS ((tree));\n+extern tree type_after_usual_arithmetic_conversions PARAMS ((tree, tree));\n+extern tree composite_pointer_type              PARAMS ((tree, tree, tree, tree,\n \t\t\t\t\t\t       const char*));\n-extern tree check_return_expr                   PROTO((tree));\n+extern tree check_return_expr                   PARAMS ((tree));\n \n /* in typeck2.c */\n-extern tree error_not_base_type\t\t\tPROTO((tree, tree));\n-extern tree binfo_or_else\t\t\tPROTO((tree, tree));\n-extern void readonly_error\t\t\tPROTO((tree, const char *, int));\n-extern int abstract_virtuals_error\t\tPROTO((tree, tree));\n-extern void incomplete_type_error\t\tPROTO((tree, tree));\n-extern void my_friendly_abort\t\t\tPROTO((int))\n+extern tree error_not_base_type\t\t\tPARAMS ((tree, tree));\n+extern tree binfo_or_else\t\t\tPARAMS ((tree, tree));\n+extern void readonly_error\t\t\tPARAMS ((tree, const char *, int));\n+extern int abstract_virtuals_error\t\tPARAMS ((tree, tree));\n+extern void incomplete_type_error\t\tPARAMS ((tree, tree));\n+extern void my_friendly_abort\t\t\tPARAMS ((int))\n   ATTRIBUTE_NORETURN;\n-extern void my_friendly_assert\t\t\tPROTO((int, int));\n-extern tree store_init_value\t\t\tPROTO((tree, tree));\n-extern tree digest_init\t\t\t\tPROTO((tree, tree, tree *));\n-extern tree build_scoped_ref\t\t\tPROTO((tree, tree));\n-extern tree build_x_arrow\t\t\tPROTO((tree));\n-extern tree build_m_component_ref\t\tPROTO((tree, tree));\n-extern tree build_functional_cast\t\tPROTO((tree, tree));\n-extern char *enum_name_string\t\t\tPROTO((tree, tree));\n-extern void report_case_error\t\t\tPROTO((int, tree, tree, tree));\n-extern void check_for_new_type\t\t\tPROTO((const char *, flagged_type_tree));\n-extern tree add_exception_specifier             PROTO((tree, tree, int));\n+extern void my_friendly_assert\t\t\tPARAMS ((int, int));\n+extern tree store_init_value\t\t\tPARAMS ((tree, tree));\n+extern tree digest_init\t\t\t\tPARAMS ((tree, tree, tree *));\n+extern tree build_scoped_ref\t\t\tPARAMS ((tree, tree));\n+extern tree build_x_arrow\t\t\tPARAMS ((tree));\n+extern tree build_m_component_ref\t\tPARAMS ((tree, tree));\n+extern tree build_functional_cast\t\tPARAMS ((tree, tree));\n+extern char *enum_name_string\t\t\tPARAMS ((tree, tree));\n+extern void report_case_error\t\t\tPARAMS ((int, tree, tree, tree));\n+extern void check_for_new_type\t\t\tPARAMS ((const char *, flagged_type_tree));\n+extern tree add_exception_specifier             PARAMS ((tree, tree, int));\n \n /* in xref.c */\n-extern void GNU_xref_begin\t\t\tPROTO((const char *));\n-extern void GNU_xref_end\t\t\tPROTO((int));\n-extern void GNU_xref_file\t\t\tPROTO((const char *));\n-extern void GNU_xref_start_scope\t\tPROTO((HOST_WIDE_INT));\n-extern void GNU_xref_end_scope\t\t\tPROTO((HOST_WIDE_INT, HOST_WIDE_INT, int, int));\n-extern void GNU_xref_ref\t\t\tPROTO((tree, const char *));\n-extern void GNU_xref_decl\t\t\tPROTO((tree, tree));\n-extern void GNU_xref_call\t\t\tPROTO((tree, const char *));\n-extern void GNU_xref_function\t\t\tPROTO((tree, tree));\n-extern void GNU_xref_assign\t\t\tPROTO((tree));\n-extern void GNU_xref_hier\t\t\tPROTO((tree, tree, int, int, int));\n-extern void GNU_xref_member\t\t\tPROTO((tree, tree));\n+extern void GNU_xref_begin\t\t\tPARAMS ((const char *));\n+extern void GNU_xref_end\t\t\tPARAMS ((int));\n+extern void GNU_xref_file\t\t\tPARAMS ((const char *));\n+extern void GNU_xref_start_scope\t\tPARAMS ((HOST_WIDE_INT));\n+extern void GNU_xref_end_scope\t\t\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT, int, int));\n+extern void GNU_xref_ref\t\t\tPARAMS ((tree, const char *));\n+extern void GNU_xref_decl\t\t\tPARAMS ((tree, tree));\n+extern void GNU_xref_call\t\t\tPARAMS ((tree, const char *));\n+extern void GNU_xref_function\t\t\tPARAMS ((tree, tree));\n+extern void GNU_xref_assign\t\t\tPARAMS ((tree));\n+extern void GNU_xref_hier\t\t\tPARAMS ((tree, tree, int, int, int));\n+extern void GNU_xref_member\t\t\tPARAMS ((tree, tree));\n \n /* in dump.c */\n-extern void dump_node_to_file                   PROTO ((tree, const char *));\n+extern void dump_node_to_file                   PARAMS ((tree, const char *));\n \n /* -- end of C++ */\n "}, {"sha": "22c3e3c5c3524265a2915d433ad842e7206d45f8", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -34,9 +34,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"decl.h\"\n \n-static tree cp_convert_to_pointer PROTO((tree, tree));\n-static tree convert_to_pointer_force PROTO((tree, tree));\n-static tree build_up_reference PROTO((tree, tree, int));\n+static tree cp_convert_to_pointer PARAMS ((tree, tree));\n+static tree convert_to_pointer_force PARAMS ((tree, tree));\n+static tree build_up_reference PARAMS ((tree, tree, int));\n \n /* Change of width--truncation and extension of integers or reals--\n    is represented with NOP_EXPR.  Proper functioning of many things"}, {"sha": "72de97cb904587b25bcd16b195bb507d6aba571b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -56,7 +56,7 @@ extern tree static_ctors, static_dtors;\n \n extern tree global_namespace;\n \n-extern int (*valid_lang_attribute) PROTO ((tree, tree, tree, tree));\n+extern int (*valid_lang_attribute) PARAMS ((tree, tree, tree, tree));\n \n /* Use garbage collection.  */\n \n@@ -99,91 +99,91 @@ int ggc_p = 1;\n #define WCHAR_TYPE \"int\"\n #endif\n \n-static tree grokparms\t\t\t\tPROTO((tree, int));\n-static const char *redeclaration_error_message\tPROTO((tree, tree));\n+static tree grokparms\t\t\t\tPARAMS ((tree, int));\n+static const char *redeclaration_error_message\tPARAMS ((tree, tree));\n \n-static void push_binding_level PROTO((struct binding_level *, int,\n+static void push_binding_level PARAMS ((struct binding_level *, int,\n \t\t\t\t      int));\n-static void pop_binding_level PROTO((void));\n-static void suspend_binding_level PROTO((void));\n-static void resume_binding_level PROTO((struct binding_level *));\n-static struct binding_level *make_binding_level PROTO((void));\n-static void declare_namespace_level PROTO((void));\n-static void signal_catch PROTO((int)) ATTRIBUTE_NORETURN;\n-static void storedecls PROTO((tree));\n-static void require_complete_types_for_parms PROTO((tree));\n-static void push_overloaded_decl_1 PROTO((tree));\n-static int ambi_op_p PROTO((tree));\n-static int unary_op_p PROTO((tree));\n-static tree store_bindings PROTO((tree, tree));\n-static tree lookup_tag_reverse PROTO((tree, tree));\n-static tree obscure_complex_init PROTO((tree, tree));\n-static tree maybe_build_cleanup_1 PROTO((tree, tree));\n-static tree lookup_name_real PROTO((tree, int, int, int));\n-static void warn_extern_redeclared_static PROTO((tree, tree));\n-static void grok_reference_init PROTO((tree, tree, tree));\n-static tree grokfndecl PROTO((tree, tree, tree, tree, int,\n+static void pop_binding_level PARAMS ((void));\n+static void suspend_binding_level PARAMS ((void));\n+static void resume_binding_level PARAMS ((struct binding_level *));\n+static struct binding_level *make_binding_level PARAMS ((void));\n+static void declare_namespace_level PARAMS ((void));\n+static void signal_catch PARAMS ((int)) ATTRIBUTE_NORETURN;\n+static void storedecls PARAMS ((tree));\n+static void require_complete_types_for_parms PARAMS ((tree));\n+static void push_overloaded_decl_1 PARAMS ((tree));\n+static int ambi_op_p PARAMS ((tree));\n+static int unary_op_p PARAMS ((tree));\n+static tree store_bindings PARAMS ((tree, tree));\n+static tree lookup_tag_reverse PARAMS ((tree, tree));\n+static tree obscure_complex_init PARAMS ((tree, tree));\n+static tree maybe_build_cleanup_1 PARAMS ((tree, tree));\n+static tree lookup_name_real PARAMS ((tree, int, int, int));\n+static void warn_extern_redeclared_static PARAMS ((tree, tree));\n+static void grok_reference_init PARAMS ((tree, tree, tree));\n+static tree grokfndecl PARAMS ((tree, tree, tree, tree, int,\n \t\t\t      enum overload_flags, tree,\n \t\t\t      tree, int, int, int, int, int, int, tree));\n-static tree grokvardecl PROTO((tree, tree, RID_BIT_TYPE *, int, int, tree));\n-static tree lookup_tag PROTO((enum tree_code, tree,\n+static tree grokvardecl PARAMS ((tree, tree, RID_BIT_TYPE *, int, int, tree));\n+static tree lookup_tag PARAMS ((enum tree_code, tree,\n \t\t\t      struct binding_level *, int));\n static void set_identifier_type_value_with_scope\n-\tPROTO((tree, tree, struct binding_level *));\n-static void record_builtin_type PROTO((enum rid, const char *, tree));\n-static void record_unknown_type PROTO((tree, const char *));\n-static int member_function_or_else PROTO((tree, tree, enum overload_flags));\n-static void bad_specifiers PROTO((tree, const char *, int, int, int, int,\n+\tPARAMS ((tree, tree, struct binding_level *));\n+static void record_builtin_type PARAMS ((enum rid, const char *, tree));\n+static void record_unknown_type PARAMS ((tree, const char *));\n+static int member_function_or_else PARAMS ((tree, tree, enum overload_flags));\n+static void bad_specifiers PARAMS ((tree, const char *, int, int, int, int,\n \t\t\t\t  int));\n-static void lang_print_error_function PROTO((const char *));\n-static tree maybe_process_template_type_declaration PROTO((tree, int, struct binding_level*));\n-static void check_for_uninitialized_const_var PROTO((tree));\n-static unsigned long typename_hash PROTO((hash_table_key));\n-static boolean typename_compare PROTO((hash_table_key, hash_table_key));\n-static void push_binding PROTO((tree, tree, struct binding_level*));\n-static int add_binding PROTO((tree, tree));\n-static void pop_binding PROTO((tree, tree));\n-static tree local_variable_p_walkfn PROTO((tree *, int *, void *));\n-static tree find_binding PROTO((tree, tree));\n-static tree select_decl PROTO((tree, int));\n-static int lookup_flags PROTO((int, int));\n-static tree qualify_lookup PROTO((tree, int));\n-static tree record_builtin_java_type PROTO((const char *, int));\n-static const char *tag_name PROTO((enum tag_types code));\n-static void find_class_binding_level PROTO((void));\n-static struct binding_level *innermost_nonclass_level PROTO((void));\n-static void warn_about_implicit_typename_lookup PROTO((tree, tree));\n-static int walk_namespaces_r PROTO((tree, walk_namespaces_fn, void *));\n-static int walk_globals_r PROTO((tree, void *));\n-static void add_decl_to_level PROTO((tree, struct binding_level *));\n-static tree make_label_decl PROTO((tree, int));\n-static void pop_label PROTO((tree));\n-static void pop_labels PROTO((tree));\n-static void maybe_deduce_size_from_array_init PROTO((tree, tree));\n-static void layout_var_decl PROTO((tree));\n-static void maybe_commonize_var PROTO((tree));\n-static tree check_initializer PROTO((tree, tree));\n-static void make_rtl_for_nonlocal_decl PROTO((tree, tree, const char *));\n-static void push_cp_function_context PROTO((struct function *));\n-static void pop_cp_function_context PROTO((struct function *));\n-static void mark_binding_level PROTO((void *));\n-static void mark_cp_function_context PROTO((struct function *));\n-static void mark_saved_scope PROTO((void *));\n-static void mark_lang_function PROTO((struct language_function *));\n-static void mark_stmt_tree PROTO((struct stmt_tree *));\n-static void save_function_data PROTO((tree));\n-static void check_function_type PROTO((tree));\n-static void destroy_local_var PROTO((tree));\n-static void finish_constructor_body PROTO((void));\n-static void finish_destructor_body PROTO((void));\n-static tree create_array_type_for_decl PROTO((tree, tree, tree));\n-static tree get_atexit_node PROTO((void));\n-static tree get_dso_handle_node PROTO((void));\n-static tree start_cleanup_fn PROTO((void));\n-static void end_cleanup_fn PROTO((void));\n+static void lang_print_error_function PARAMS ((const char *));\n+static tree maybe_process_template_type_declaration PARAMS ((tree, int, struct binding_level*));\n+static void check_for_uninitialized_const_var PARAMS ((tree));\n+static unsigned long typename_hash PARAMS ((hash_table_key));\n+static boolean typename_compare PARAMS ((hash_table_key, hash_table_key));\n+static void push_binding PARAMS ((tree, tree, struct binding_level*));\n+static int add_binding PARAMS ((tree, tree));\n+static void pop_binding PARAMS ((tree, tree));\n+static tree local_variable_p_walkfn PARAMS ((tree *, int *, void *));\n+static tree find_binding PARAMS ((tree, tree));\n+static tree select_decl PARAMS ((tree, int));\n+static int lookup_flags PARAMS ((int, int));\n+static tree qualify_lookup PARAMS ((tree, int));\n+static tree record_builtin_java_type PARAMS ((const char *, int));\n+static const char *tag_name PARAMS ((enum tag_types code));\n+static void find_class_binding_level PARAMS ((void));\n+static struct binding_level *innermost_nonclass_level PARAMS ((void));\n+static void warn_about_implicit_typename_lookup PARAMS ((tree, tree));\n+static int walk_namespaces_r PARAMS ((tree, walk_namespaces_fn, void *));\n+static int walk_globals_r PARAMS ((tree, void *));\n+static void add_decl_to_level PARAMS ((tree, struct binding_level *));\n+static tree make_label_decl PARAMS ((tree, int));\n+static void pop_label PARAMS ((tree));\n+static void pop_labels PARAMS ((tree));\n+static void maybe_deduce_size_from_array_init PARAMS ((tree, tree));\n+static void layout_var_decl PARAMS ((tree));\n+static void maybe_commonize_var PARAMS ((tree));\n+static tree check_initializer PARAMS ((tree, tree));\n+static void make_rtl_for_nonlocal_decl PARAMS ((tree, tree, const char *));\n+static void push_cp_function_context PARAMS ((struct function *));\n+static void pop_cp_function_context PARAMS ((struct function *));\n+static void mark_binding_level PARAMS ((void *));\n+static void mark_cp_function_context PARAMS ((struct function *));\n+static void mark_saved_scope PARAMS ((void *));\n+static void mark_lang_function PARAMS ((struct language_function *));\n+static void mark_stmt_tree PARAMS ((struct stmt_tree *));\n+static void save_function_data PARAMS ((tree));\n+static void check_function_type PARAMS ((tree));\n+static void destroy_local_var PARAMS ((tree));\n+static void finish_constructor_body PARAMS ((void));\n+static void finish_destructor_body PARAMS ((void));\n+static tree create_array_type_for_decl PARAMS ((tree, tree, tree));\n+static tree get_atexit_node PARAMS ((void));\n+static tree get_dso_handle_node PARAMS ((void));\n+static tree start_cleanup_fn PARAMS ((void));\n+static void end_cleanup_fn PARAMS ((void));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n-static void indent PROTO((void));\n+static void indent PARAMS ((void));\n #endif\n \n /* Erroneous argument lists can use this *IFF* they do not modify it.  */\n@@ -536,7 +536,7 @@ indent ()\n }\n #endif /* defined(DEBUG_CP_BINDING_LEVELS) */\n \n-static tree pushdecl_with_scope\tPROTO((tree, struct binding_level *));\n+static tree pushdecl_with_scope\tPARAMS ((tree, struct binding_level *));\n \n static void\n push_binding_level (newlevel, tag_transparent, keep)\n@@ -6404,7 +6404,7 @@ tree\n define_function (name, type, pfn, library_name)\n      const char *name;\n      tree type;\n-     void (*pfn) PROTO((tree));\n+     void (*pfn) PARAMS ((tree));\n      const char *library_name;\n {\n   tree decl = build_lang_decl (FUNCTION_DECL, get_identifier (name), type);\n@@ -6439,7 +6439,7 @@ builtin_function (name, type, code, class, libname)\n      enum built_in_class class;\n      const char *libname;\n {\n-  tree decl = define_function (name, type, (void (*) PROTO((tree)))pushdecl,\n+  tree decl = define_function (name, type, (void (*) PARAMS ((tree)))pushdecl,\n \t\t\t       libname);\n   DECL_BUILT_IN_CLASS (decl) = class;\n   DECL_FUNCTION_CODE (decl) = code;"}, {"sha": "c5417d1ea48285f5a12447c25372921ff07b9754", "filename": "gcc/cp/decl.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fdecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fdecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.h?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -1,5 +1,5 @@\n /* Variables and structures for declaration processing.\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -31,7 +31,7 @@ enum decl_context\n };\n \n /* We need this in here to get the decl_context definition.  */\n-extern tree grokdeclarator\t\t\tPROTO((tree, tree, enum decl_context, int, tree));\n+extern tree grokdeclarator\t\t\tPARAMS ((tree, tree, enum decl_context, int, tree));\n \n /* Parsing a function declarator leaves a list of parameter names\n    or a chain or parameter decls here.  */"}, {"sha": "619696380f372ac4adde4f950ff1b5544d808de3", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -60,36 +60,36 @@ typedef struct priority_info_s {\n   int destructions_p;\n } *priority_info;\n \n-static tree get_sentry PROTO((tree));\n-static void mark_vtable_entries PROTO((tree));\n-static void grok_function_init PROTO((tree, tree));\n-static int finish_vtable_vardecl PROTO((tree *, void *));\n-static int prune_vtable_vardecl PROTO((tree *, void *));\n-static int is_namespace_ancestor PROTO((tree, tree));\n-static void add_using_namespace PROTO((tree, tree, int));\n-static tree ambiguous_decl PROTO((tree, tree, tree,int));\n-static tree build_anon_union_vars PROTO((tree, tree*, int, int));\n-static int acceptable_java_type PROTO((tree));\n-static void output_vtable_inherit PROTO((tree));\n-static tree start_objects PROTO((int, int));\n-static void finish_objects PROTO((int, int, tree));\n-static tree merge_functions PROTO((tree, tree));\n-static tree decl_namespace PROTO((tree));\n-static tree validate_nonmember_using_decl PROTO((tree, tree *, tree *));\n-static void do_nonmember_using_decl PROTO((tree, tree, tree, tree,\n+static tree get_sentry PARAMS ((tree));\n+static void mark_vtable_entries PARAMS ((tree));\n+static void grok_function_init PARAMS ((tree, tree));\n+static int finish_vtable_vardecl PARAMS ((tree *, void *));\n+static int prune_vtable_vardecl PARAMS ((tree *, void *));\n+static int is_namespace_ancestor PARAMS ((tree, tree));\n+static void add_using_namespace PARAMS ((tree, tree, int));\n+static tree ambiguous_decl PARAMS ((tree, tree, tree,int));\n+static tree build_anon_union_vars PARAMS ((tree, tree*, int, int));\n+static int acceptable_java_type PARAMS ((tree));\n+static void output_vtable_inherit PARAMS ((tree));\n+static tree start_objects PARAMS ((int, int));\n+static void finish_objects PARAMS ((int, int, tree));\n+static tree merge_functions PARAMS ((tree, tree));\n+static tree decl_namespace PARAMS ((tree));\n+static tree validate_nonmember_using_decl PARAMS ((tree, tree *, tree *));\n+static void do_nonmember_using_decl PARAMS ((tree, tree, tree, tree,\n \t\t\t\t\t   tree *, tree *));\n-static tree start_static_storage_duration_function PROTO((void));\n-static void finish_static_storage_duration_function PROTO((tree));\n-static priority_info get_priority_info PROTO((int));\n-static void do_static_initialization PROTO((tree, tree));\n-static void do_static_destruction PROTO((tree));\n-static tree start_static_initialization_or_destruction PROTO((tree, int));\n-static void finish_static_initialization_or_destruction PROTO((tree));\n-static void generate_ctor_or_dtor_function PROTO((int, int));\n+static tree start_static_storage_duration_function PARAMS ((void));\n+static void finish_static_storage_duration_function PARAMS ((tree));\n+static priority_info get_priority_info PARAMS ((int));\n+static void do_static_initialization PARAMS ((tree, tree));\n+static void do_static_destruction PARAMS ((tree));\n+static tree start_static_initialization_or_destruction PARAMS ((tree, int));\n+static void finish_static_initialization_or_destruction PARAMS ((tree));\n+static void generate_ctor_or_dtor_function PARAMS ((int, int));\n static int generate_ctor_and_dtor_functions_for_priority\n-                                  PROTO((splay_tree_node, void *));\n-static tree prune_vars_needing_no_initialization PROTO((tree));\n-static void write_out_vars PROTO((tree));\n+                                  PARAMS ((splay_tree_node, void *));\n+static tree prune_vars_needing_no_initialization PARAMS ((tree));\n+static void write_out_vars PARAMS ((tree));\n \n extern int current_class_depth;\n \n@@ -489,7 +489,7 @@ int flag_permissive;\n /* If this variable is defined to a non-NULL value, it will be called\n    after the file has been completely parsed.  */\n \n-void (*back_end_hook) PROTO((tree));\n+void (*back_end_hook) PARAMS ((tree));\n \n /* Table of language-dependent -f options.\n    STRING is the option name.  VARIABLE is the address of the variable.\n@@ -4527,13 +4527,13 @@ struct arg_lookup\n   tree functions;\n };\n \n-static int arg_assoc         PROTO((struct arg_lookup*, tree));\n-static int arg_assoc_args    PROTO((struct arg_lookup*, tree));\n-static int arg_assoc_type    PROTO((struct arg_lookup*, tree));\n-static int add_function      PROTO((struct arg_lookup *, tree));\n-static int arg_assoc_namespace PROTO((struct arg_lookup *, tree));\n-static int arg_assoc_class   PROTO((struct arg_lookup *, tree));\n-static int arg_assoc_template_arg PROTO((struct arg_lookup*, tree));\n+static int arg_assoc         PARAMS ((struct arg_lookup*, tree));\n+static int arg_assoc_args    PARAMS ((struct arg_lookup*, tree));\n+static int arg_assoc_type    PARAMS ((struct arg_lookup*, tree));\n+static int add_function      PARAMS ((struct arg_lookup *, tree));\n+static int arg_assoc_namespace PARAMS ((struct arg_lookup *, tree));\n+static int arg_assoc_class   PARAMS ((struct arg_lookup *, tree));\n+static int arg_assoc_template_arg PARAMS ((struct arg_lookup*, tree));\n \n /* Add a function to the lookup structure.\n    Returns 1 on error.  */"}, {"sha": "34444bb8a63c8ae76d1e5b1b1e31753fcd31518f", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -71,19 +71,19 @@ typedef struct dump_info\n   splay_tree nodes;\n } *dump_info_p;\n \n-static unsigned int queue PROTO ((dump_info_p, tree, int));\n-static void dump_index PROTO ((dump_info_p, unsigned int));\n-static void queue_and_dump_index PROTO ((dump_info_p, const char *, tree, int));\n-static void queue_and_dump_type PROTO ((dump_info_p, tree));\n-static void dequeue_and_dump PROTO ((dump_info_p));\n-static void dump_new_line PROTO ((dump_info_p));\n-static void dump_maybe_newline PROTO ((dump_info_p));\n-static void dump_int PROTO ((dump_info_p, const char *, int));\n-static void dump_string PROTO ((dump_info_p, const char *));\n-static void dump_string_field PROTO ((dump_info_p, const char *, const char *));\n-static void dump_node PROTO ((tree, FILE *));\n-static void dump_stmt PROTO ((dump_info_p, tree));\n-static void dump_next_stmt PROTO ((dump_info_p, tree));\n+static unsigned int queue PARAMS ((dump_info_p, tree, int));\n+static void dump_index PARAMS ((dump_info_p, unsigned int));\n+static void queue_and_dump_index PARAMS ((dump_info_p, const char *, tree, int));\n+static void queue_and_dump_type PARAMS ((dump_info_p, tree));\n+static void dequeue_and_dump PARAMS ((dump_info_p));\n+static void dump_new_line PARAMS ((dump_info_p));\n+static void dump_maybe_newline PARAMS ((dump_info_p));\n+static void dump_int PARAMS ((dump_info_p, const char *, int));\n+static void dump_string PARAMS ((dump_info_p, const char *));\n+static void dump_string_field PARAMS ((dump_info_p, const char *, const char *));\n+static void dump_node PARAMS ((tree, FILE *));\n+static void dump_stmt PARAMS ((dump_info_p, tree));\n+static void dump_next_stmt PARAMS ((dump_info_p, tree));\n \n /* Add T to the end of the queue of nodes to dump.  Returns the index\n    assigned to T.  */"}, {"sha": "ff2fb31e3e5162e2f45afd48a9efeb8cac957989", "filename": "gcc/cp/errfn.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Ferrfn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Ferrfn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferrfn.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -1,5 +1,6 @@\n /* Provide a call-back mechanism for handling error output.\n-   Copyright (C) 1993, 94-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 94, 95, 96, 97, 98, 99, 2000\n+   Free Software Foundation, Inc.\n    Contributed by Jason Merrill (jason@cygnus.com)\n \n    This file is part of GNU CC.\n@@ -30,7 +31,7 @@ Boston, MA 02111-1307, USA.  */\n    with all memory management; the functions in this file will not free\n    the char*s returned.  See error.c for an example use of this code.  */\n \n-typedef const char *cp_printer PROTO((tree, int));\n+typedef const char *cp_printer PARAMS ((tree, int));\n extern cp_printer * cp_printers[256];\n \n /* Whether or not we should try to be quiet for errors and warnings; this is\n@@ -40,7 +41,7 @@ int cp_silent = 0;\n \n typedef void errorfn ();\t/* deliberately vague */\n \n-static void cp_thing PROTO ((errorfn *, int, const char *, va_list));\n+static void cp_thing PARAMS ((errorfn *, int, const char *, va_list));\n \n #define STRDUP(f) (ap = (char *) alloca (strlen (f) +1), strcpy (ap, (f)), ap)\n \n@@ -190,7 +191,7 @@ cp_thing (errfn, atarg1, format, ap)\n }\n \n void\n-cp_error VPROTO((const char *format, ...))\n+cp_error VPARAMS ((const char *format, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   char *format;\n@@ -209,7 +210,7 @@ cp_error VPROTO((const char *format, ...))\n }\n \n void\n-cp_warning VPROTO((const char *format, ...))\n+cp_warning VPARAMS ((const char *format, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   char *format;\n@@ -228,7 +229,7 @@ cp_warning VPROTO((const char *format, ...))\n }\n \n void\n-cp_pedwarn VPROTO((const char *format, ...))\n+cp_pedwarn VPARAMS ((const char *format, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   char *format;\n@@ -247,7 +248,7 @@ cp_pedwarn VPROTO((const char *format, ...))\n }\n \n void\n-cp_compiler_error VPROTO((const char *format, ...))\n+cp_compiler_error VPARAMS ((const char *format, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   char *format;\n@@ -277,7 +278,7 @@ cp_deprecated (msg)\n }\n \n void\n-cp_sprintf VPROTO((const char *format, ...))\n+cp_sprintf VPARAMS ((const char *format, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   char *format;\n@@ -295,7 +296,7 @@ cp_sprintf VPROTO((const char *format, ...))\n }\n \n void\n-cp_error_at VPROTO((const char *format, ...))\n+cp_error_at VPARAMS ((const char *format, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   char *format;\n@@ -314,7 +315,7 @@ cp_error_at VPROTO((const char *format, ...))\n }\n \n void\n-cp_warning_at VPROTO((const char *format, ...))\n+cp_warning_at VPARAMS ((const char *format, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   char *format;\n@@ -333,7 +334,7 @@ cp_warning_at VPROTO((const char *format, ...))\n }\n \n void\n-cp_pedwarn_at VPROTO((const char *format, ...))\n+cp_pedwarn_at VPARAMS ((const char *format, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   char *format;"}, {"sha": "d0196f58f7d09c880f767ee5d7a07e1414529bdc", "filename": "gcc/cp/error.c", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -1,6 +1,7 @@\n /* Call-backs for C++ error reporting.\n    This code is non-reentrant.\n-   Copyright (C) 1993, 94-97, 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 94, 95, 96, 97, 98, 99, 2000\n+   Free Software Foundation, Inc.\n \n    This file is part of GNU CC.\n \n@@ -57,44 +58,44 @@ static char *scratch_firstobj;\n \n enum pad { none, before, after };\n \n-static const char *args_to_string\t\tPROTO((tree, int));\n-static const char *assop_to_string\t\tPROTO((enum tree_code, int));\n-static const char *code_to_string\t\tPROTO((enum tree_code, int));\n-static const char *cv_to_string\t\t\tPROTO((tree, int));\n-static const char *decl_to_string\t\tPROTO((tree, int));\n-static const char *expr_to_string\t\tPROTO((tree, int));\n-static const char *fndecl_to_string\t\tPROTO((tree, int));\n-static const char *language_to_string\t\tPROTO((enum languages, int));\n-static const char *op_to_string\t\t\tPROTO((enum tree_code, int));\n-static const char *parm_to_string\t\tPROTO((int, int));\n-static const char *type_to_string\t\tPROTO((tree, int));\n-\n-static void dump_type PROTO((tree, enum tree_string_flags));\n-static void dump_simple_decl PROTO((tree, tree, enum tree_string_flags));\n-static void dump_decl PROTO((tree, enum tree_string_flags));\n-static void dump_template_decl PROTO((tree, enum tree_string_flags));\n-static void dump_function_decl PROTO((tree, enum tree_string_flags));\n-static void dump_expr PROTO((tree, enum tree_string_flags));\n-static void dump_unary_op PROTO((const char *, tree, enum tree_string_flags));\n-static void dump_binary_op PROTO((const char *, tree, enum tree_string_flags));\n-static void dump_aggr_type PROTO((tree, enum tree_string_flags));\n-static enum pad dump_type_prefix PROTO((tree, enum tree_string_flags));\n-static void dump_type_suffix PROTO((tree, enum tree_string_flags));\n-static void dump_function_name PROTO((tree, enum tree_string_flags));\n-static void dump_expr_list PROTO((tree, enum tree_string_flags));\n-static void dump_global_iord PROTO((tree));\n-static enum pad dump_qualifiers PROTO((tree, enum pad));\n-static void dump_char PROTO((int));\n-static void dump_parameters PROTO((tree, enum tree_string_flags));\n-static void dump_exception_spec PROTO((tree, enum tree_string_flags));\n-static const char *aggr_variety PROTO((tree));\n-static tree ident_fndecl PROTO((tree));\n-static void dump_template_argument PROTO((tree, enum tree_string_flags));\n-static void dump_template_argument_list PROTO((tree, enum tree_string_flags));\n-static void dump_template_parameter PROTO((tree, enum tree_string_flags));\n-static void dump_template_bindings PROTO((tree, tree));\n-static void dump_scope PROTO((tree, enum tree_string_flags));\n-static void dump_template_parms PROTO((tree, int, enum tree_string_flags));\n+static const char *args_to_string\t\tPARAMS ((tree, int));\n+static const char *assop_to_string\t\tPARAMS ((enum tree_code, int));\n+static const char *code_to_string\t\tPARAMS ((enum tree_code, int));\n+static const char *cv_to_string\t\t\tPARAMS ((tree, int));\n+static const char *decl_to_string\t\tPARAMS ((tree, int));\n+static const char *expr_to_string\t\tPARAMS ((tree, int));\n+static const char *fndecl_to_string\t\tPARAMS ((tree, int));\n+static const char *language_to_string\t\tPARAMS ((enum languages, int));\n+static const char *op_to_string\t\t\tPARAMS ((enum tree_code, int));\n+static const char *parm_to_string\t\tPARAMS ((int, int));\n+static const char *type_to_string\t\tPARAMS ((tree, int));\n+\n+static void dump_type PARAMS ((tree, enum tree_string_flags));\n+static void dump_simple_decl PARAMS ((tree, tree, enum tree_string_flags));\n+static void dump_decl PARAMS ((tree, enum tree_string_flags));\n+static void dump_template_decl PARAMS ((tree, enum tree_string_flags));\n+static void dump_function_decl PARAMS ((tree, enum tree_string_flags));\n+static void dump_expr PARAMS ((tree, enum tree_string_flags));\n+static void dump_unary_op PARAMS ((const char *, tree, enum tree_string_flags));\n+static void dump_binary_op PARAMS ((const char *, tree, enum tree_string_flags));\n+static void dump_aggr_type PARAMS ((tree, enum tree_string_flags));\n+static enum pad dump_type_prefix PARAMS ((tree, enum tree_string_flags));\n+static void dump_type_suffix PARAMS ((tree, enum tree_string_flags));\n+static void dump_function_name PARAMS ((tree, enum tree_string_flags));\n+static void dump_expr_list PARAMS ((tree, enum tree_string_flags));\n+static void dump_global_iord PARAMS ((tree));\n+static enum pad dump_qualifiers PARAMS ((tree, enum pad));\n+static void dump_char PARAMS ((int));\n+static void dump_parameters PARAMS ((tree, enum tree_string_flags));\n+static void dump_exception_spec PARAMS ((tree, enum tree_string_flags));\n+static const char *aggr_variety PARAMS ((tree));\n+static tree ident_fndecl PARAMS ((tree));\n+static void dump_template_argument PARAMS ((tree, enum tree_string_flags));\n+static void dump_template_argument_list PARAMS ((tree, enum tree_string_flags));\n+static void dump_template_parameter PARAMS ((tree, enum tree_string_flags));\n+static void dump_template_bindings PARAMS ((tree, tree));\n+static void dump_scope PARAMS ((tree, enum tree_string_flags));\n+static void dump_template_parms PARAMS ((tree, int, enum tree_string_flags));\n \n #define A args_to_string\n #define C code_to_string"}, {"sha": "3a9f5b08aa05536dd6b10a1b509fd78dbe3e1e7f", "filename": "gcc/cp/except.c", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -1,5 +1,6 @@\n /* Handle exceptional things in C++.\n-   Copyright (C) 1989, 92-97, 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 92, 93, 94, 95, 96, 97, 98, 99, 2000\n+   Free Software Foundation, Inc.\n    Contributed by Michael Tiemann <tiemann@cygnus.com>\n    Rewritten by Mike Stump <mrs@cygnus.com>, based upon an\n    initial re-implementation courtesy Tad Hunt.\n@@ -36,24 +37,24 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"eh-common.h\"\n \n-static void push_eh_cleanup PROTO((void));\n-static tree build_eh_type_type PROTO((tree));\n-static tree call_eh_info PROTO((void));\n-static void push_eh_info PROTO((void));\n-static tree get_eh_info PROTO((void));\n-static tree get_eh_value PROTO((void));\n+static void push_eh_cleanup PARAMS ((void));\n+static tree build_eh_type_type PARAMS ((tree));\n+static tree call_eh_info PARAMS ((void));\n+static void push_eh_info PARAMS ((void));\n+static tree get_eh_info PARAMS ((void));\n+static tree get_eh_value PARAMS ((void));\n #if 0\n-static tree get_eh_type PROTO((void));\n-static tree get_eh_caught PROTO((void));\n-static tree get_eh_handlers PROTO((void));\n+static tree get_eh_type PARAMS ((void));\n+static tree get_eh_caught PARAMS ((void));\n+static tree get_eh_handlers PARAMS ((void));\n #endif\n-static tree do_pop_exception PROTO((void));\n-static tree build_eh_type_type_ref PROTO((tree));\n-static tree build_terminate_handler PROTO((void));\n-static tree alloc_eh_object PROTO((tree));\n-static int complete_ptr_ref_or_void_ptr_p PROTO((tree, tree));\n-static void initialize_handler_parm PROTO((tree));\n-static tree expand_throw PROTO((tree));\n+static tree do_pop_exception PARAMS ((void));\n+static tree build_eh_type_type_ref PARAMS ((tree));\n+static tree build_terminate_handler PARAMS ((void));\n+static tree alloc_eh_object PARAMS ((tree));\n+static int complete_ptr_ref_or_void_ptr_p PARAMS ((tree, tree));\n+static void initialize_handler_parm PARAMS ((tree));\n+static tree expand_throw PARAMS ((tree));\n \n #if 0\n /* This is the startup, and finish stuff per exception table.  */"}, {"sha": "1fcecff39aac250d596c06b89437602fe0449c06", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -32,10 +32,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"tm_p.h\"\n \n #if 0\n-static tree extract_aggr_init PROTO((tree, tree));\n-static tree extract_scalar_init PROTO((tree, tree));\n+static tree extract_aggr_init PARAMS ((tree, tree));\n+static tree extract_scalar_init PARAMS ((tree, tree));\n #endif\n-static rtx cplus_expand_expr PROTO((tree, rtx, enum machine_mode,\n+static rtx cplus_expand_expr PARAMS ((tree, rtx, enum machine_mode,\n \t\t\t\t    enum expand_modifier));\n \n /* Hook used by output_constant to expand language-specific"}, {"sha": "ffc67f7fbdee92bcc899ed3337399d66ffca2ff0", "filename": "gcc/cp/init.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -33,22 +33,22 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"ggc.h\"\n \n-static void expand_aggr_vbase_init_1 PROTO((tree, tree, tree, tree));\n-static void construct_virtual_bases PROTO((tree, tree, tree, tree, tree));\n-static void expand_aggr_init_1 PROTO((tree, tree, tree, tree, int));\n-static void expand_default_init PROTO((tree, tree, tree, tree, int));\n-static tree build_vec_delete_1 PROTO((tree, tree, tree, tree, int));\n-static void perform_member_init PROTO((tree, tree, tree, int));\n-static void sort_base_init PROTO((tree, tree *, tree *));\n-static tree build_builtin_delete_call PROTO((tree));\n-static int member_init_ok_or_else PROTO((tree, tree, const char *));\n-static void expand_virtual_init PROTO((tree, tree));\n-static tree sort_member_init PROTO((tree));\n-static tree initializing_context PROTO((tree));\n-static tree build_java_class_ref PROTO((tree));\n-static void expand_cleanup_for_base PROTO((tree, tree));\n-static tree get_temp_regvar PROTO((tree, tree));\n-static tree dfs_initialize_vtbl_ptrs PROTO((tree, void *));\n+static void expand_aggr_vbase_init_1 PARAMS ((tree, tree, tree, tree));\n+static void construct_virtual_bases PARAMS ((tree, tree, tree, tree, tree));\n+static void expand_aggr_init_1 PARAMS ((tree, tree, tree, tree, int));\n+static void expand_default_init PARAMS ((tree, tree, tree, tree, int));\n+static tree build_vec_delete_1 PARAMS ((tree, tree, tree, tree, int));\n+static void perform_member_init PARAMS ((tree, tree, tree, int));\n+static void sort_base_init PARAMS ((tree, tree *, tree *));\n+static tree build_builtin_delete_call PARAMS ((tree));\n+static int member_init_ok_or_else PARAMS ((tree, tree, const char *));\n+static void expand_virtual_init PARAMS ((tree, tree));\n+static tree sort_member_init PARAMS ((tree));\n+static tree initializing_context PARAMS ((tree));\n+static tree build_java_class_ref PARAMS ((tree));\n+static void expand_cleanup_for_base PARAMS ((tree, tree));\n+static tree get_temp_regvar PARAMS ((tree, tree));\n+static tree dfs_initialize_vtbl_ptrs PARAMS ((tree, void *));\n \n /* Set up local variable for this file.  MUST BE CALLED AFTER\n    INIT_DECL_PROCESSING.  */"}, {"sha": "c82fc8f417d7ec539b2a3ba46a50ec989ee3accc", "filename": "gcc/cp/input.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finput.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -1,5 +1,6 @@\n /* Input handling for G++.\n-   Copyright (C) 1992, 93-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 93, 94, 95, 96, 97, 98, 99, 2000\n+   Free Software Foundation, Inc.\n    Written by Ken Raeburn (raeburn@cygnus.com) while at Watchmaker Computing.\n    Enhanced by Michael Tiemann (tiemann@cygnus.com) to better support USE_CPPLIB\n \n@@ -69,15 +70,15 @@ extern unsigned char *yy_cur, *yy_lim;\n extern int yy_get_token ();\n #endif\n \n-extern void feed_input PROTO((char *, int, char *, int));\n-extern void put_input PROTO((int));\n-extern void put_back PROTO((int));\n-extern int getch PROTO((void));\n-extern int input_redirected PROTO((void));\n+extern void feed_input PARAMS ((char *, int, char *, int));\n+extern void put_input PARAMS ((int));\n+extern void put_back PARAMS ((int));\n+extern int getch PARAMS ((void));\n+extern int input_redirected PARAMS ((void));\n \n-static inline struct input_source * allocate_input PROTO((void));\n-static inline void free_input PROTO((struct input_source *));\n-static inline void end_input PROTO((void));\n+static inline struct input_source * allocate_input PARAMS ((void));\n+static inline void free_input PARAMS ((struct input_source *));\n+static inline void end_input PARAMS ((void));\n \n static inline struct input_source *\n allocate_input ()"}, {"sha": "6bea28742063465999b6b3b09174857aee485175", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -48,47 +48,47 @@ Boston, MA 02111-1307, USA.  */\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-extern void yyprint PROTO((FILE *, int, YYSTYPE));\n-\n-static tree get_time_identifier PROTO((const char *));\n-static int check_newline PROTO((void));\n-static int whitespace_cr\t\tPROTO((int));\n-static int skip_white_space PROTO((int));\n-static void finish_defarg PROTO((void));\n-static int my_get_run_time PROTO((void));\n-static int interface_strcmp PROTO((const char *));\n-static int readescape PROTO((int *));\n-static char *extend_token_buffer PROTO((const char *));\n-static void consume_string PROTO((struct obstack *, int));\n-static void feed_defarg PROTO((tree, tree));\n-static void store_pending_inline PROTO((tree, struct pending_inline *));\n-static void reinit_parse_for_expr PROTO((struct obstack *));\n-static int *init_cpp_parse PROTO((void));\n-static void cp_pragma_interface PROTO((char *));\n-static void cp_pragma_implementation PROTO ((char *));\n-static int handle_cp_pragma PROTO((const char *));\n+extern void yyprint PARAMS ((FILE *, int, YYSTYPE));\n+\n+static tree get_time_identifier PARAMS ((const char *));\n+static int check_newline PARAMS ((void));\n+static int whitespace_cr\t\tPARAMS ((int));\n+static int skip_white_space PARAMS ((int));\n+static void finish_defarg PARAMS ((void));\n+static int my_get_run_time PARAMS ((void));\n+static int interface_strcmp PARAMS ((const char *));\n+static int readescape PARAMS ((int *));\n+static char *extend_token_buffer PARAMS ((const char *));\n+static void consume_string PARAMS ((struct obstack *, int));\n+static void feed_defarg PARAMS ((tree, tree));\n+static void store_pending_inline PARAMS ((tree, struct pending_inline *));\n+static void reinit_parse_for_expr PARAMS ((struct obstack *));\n+static int *init_cpp_parse PARAMS ((void));\n+static void cp_pragma_interface PARAMS ((char *));\n+static void cp_pragma_implementation PARAMS ((char *));\n+static int handle_cp_pragma PARAMS ((const char *));\n #ifdef HANDLE_GENERIC_PRAGMAS\n-static int handle_generic_pragma PROTO((int));\n+static int handle_generic_pragma PARAMS ((int));\n #endif\n #ifdef GATHER_STATISTICS\n #ifdef REDUCE_LENGTH\n-static int reduce_cmp PROTO((int *, int *));\n-static int token_cmp PROTO((int *, int *));\n+static int reduce_cmp PARAMS ((int *, int *));\n+static int token_cmp PARAMS ((int *, int *));\n #endif\n #endif\n-static void begin_definition_of_inclass_inline PROTO((struct pending_inline*));\n-static void parse_float PROTO((PTR));\n-static int is_global PROTO((tree));\n-static void init_filename_times PROTO((void));\n-static void extend_token_buffer_to PROTO((int));\n+static void begin_definition_of_inclass_inline PARAMS ((struct pending_inline*));\n+static void parse_float PARAMS ((PTR));\n+static int is_global PARAMS ((tree));\n+static void init_filename_times PARAMS ((void));\n+static void extend_token_buffer_to PARAMS ((int));\n #ifdef HANDLE_PRAGMA\n-static int pragma_getc PROTO((void));\n-static void pragma_ungetc PROTO((int));\n+static int pragma_getc PARAMS ((void));\n+static void pragma_ungetc PARAMS ((int));\n #endif\n-static int read_line_number PROTO((int *));\n-static int token_getch PROTO ((void));\n-static void token_put_back PROTO ((int));\n-static void mark_impl_file_chain PROTO ((void *));\n+static int read_line_number PARAMS ((int *));\n+static int token_getch PARAMS ((void));\n+static void token_put_back PARAMS ((int));\n+static void mark_impl_file_chain PARAMS ((void *));\n \n /* Given a file name X, return the nondirectory portion.\n    Keep in mind that X can be computed more than once.  */\n@@ -4851,7 +4851,7 @@ dump_time_statistics ()\n }\n \n void\n-compiler_error VPROTO ((const char *msg, ...))\n+compiler_error VPARAMS ((const char *msg, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *msg;"}, {"sha": "d2c9352fa9a4035d8d30f4e703c2657c978bb155", "filename": "gcc/cp/lex.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -1,5 +1,5 @@\n /* Define constants and variables for communication with parse.y.\n-   Copyright (C) 1987, 92-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 92-97, 1998, 2000 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n    and by Brendan Kehoe (brendan@cygnus.com).\n \n@@ -130,6 +130,6 @@ extern tree got_object;\n    Positive is push count, negative is pop count.  */\n extern int pending_lang_change;\n \n-extern int yylex PROTO((void));\n+extern int yylex PARAMS ((void));\n \n extern struct lang_decl *free_lang_decl_chain;"}, {"sha": "b43cc60f4691154b4d2a9447be591ae58f74e1f9", "filename": "gcc/cp/method.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -65,39 +65,39 @@ struct pending_inline *pending_inlines;\n static struct obstack scratch_obstack;\n static char *scratch_firstobj;\n \n-static void icat PROTO((HOST_WIDE_INT));\n-static void dicat PROTO((HOST_WIDE_INT, HOST_WIDE_INT));\n-static int old_backref_index PROTO((tree));\n-static int flush_repeats PROTO((int, tree));\n-static void build_overload_identifier PROTO((tree));\n-static void build_overload_nested_name PROTO((tree));\n-static void mangle_expression PROTO((tree));\n-static void build_overload_int PROTO((tree, mangling_flags));\n-static void build_overload_identifier PROTO((tree));\n-static void build_qualified_name PROTO((tree));\n-static void build_overload_value PROTO((tree, tree, mangling_flags));\n-static void issue_nrepeats PROTO((int, tree));\n-static char *build_mangled_name PROTO((tree,int,int));\n-static void process_modifiers PROTO((tree));\n-static void process_overload_item PROTO((tree,int));\n-static void do_build_assign_ref PROTO((tree));\n-static void do_build_copy_constructor PROTO((tree));\n-static void build_template_template_parm_names PROTO((tree));\n-static void build_template_parm_names PROTO((tree, tree));\n-static void build_underscore_int PROTO((int));\n-static void start_squangling PROTO((void));\n-static void end_squangling PROTO((void));\n-static int check_ktype PROTO((tree, int));\n-static int issue_ktype PROTO((tree));\n-static void build_overload_scope_ref PROTO((tree));\n-static void build_mangled_template_parm_index PROTO((const char *, tree));\n+static void icat PARAMS ((HOST_WIDE_INT));\n+static void dicat PARAMS ((HOST_WIDE_INT, HOST_WIDE_INT));\n+static int old_backref_index PARAMS ((tree));\n+static int flush_repeats PARAMS ((int, tree));\n+static void build_overload_identifier PARAMS ((tree));\n+static void build_overload_nested_name PARAMS ((tree));\n+static void mangle_expression PARAMS ((tree));\n+static void build_overload_int PARAMS ((tree, mangling_flags));\n+static void build_overload_identifier PARAMS ((tree));\n+static void build_qualified_name PARAMS ((tree));\n+static void build_overload_value PARAMS ((tree, tree, mangling_flags));\n+static void issue_nrepeats PARAMS ((int, tree));\n+static char *build_mangled_name PARAMS ((tree,int,int));\n+static void process_modifiers PARAMS ((tree));\n+static void process_overload_item PARAMS ((tree,int));\n+static void do_build_assign_ref PARAMS ((tree));\n+static void do_build_copy_constructor PARAMS ((tree));\n+static void build_template_template_parm_names PARAMS ((tree));\n+static void build_template_parm_names PARAMS ((tree, tree));\n+static void build_underscore_int PARAMS ((int));\n+static void start_squangling PARAMS ((void));\n+static void end_squangling PARAMS ((void));\n+static int check_ktype PARAMS ((tree, int));\n+static int issue_ktype PARAMS ((tree));\n+static void build_overload_scope_ref PARAMS ((tree));\n+static void build_mangled_template_parm_index PARAMS ((const char *, tree));\n #if HOST_BITS_PER_WIDE_INT >= 64\n-static void build_mangled_C9x_name PROTO((int));\n+static void build_mangled_C9x_name PARAMS ((int));\n #endif\n-static int is_back_referenceable_type PROTO((tree));\n-static int check_btype PROTO((tree));\n-static void build_mangled_name_for_type PROTO((tree));\n-static void build_mangled_name_for_type_with_Gcode PROTO((tree, int));\n+static int is_back_referenceable_type PARAMS ((tree));\n+static int check_btype PARAMS ((tree));\n+static void build_mangled_name_for_type PARAMS ((tree));\n+static void build_mangled_name_for_type_with_Gcode PARAMS ((tree, int));\n \n # define OB_INIT() (scratch_firstobj ? (obstack_free (&scratch_obstack, scratch_firstobj), 0) : 0)\n # define OB_PUTC(C) (obstack_1grow (&scratch_obstack, (C)))"}, {"sha": "d97749d2634ad5985e13949e2c610f1539d18487", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -65,17 +65,17 @@ typedef struct inline_data\n \n /* Prototypes.  */\n \n-static tree initialize_inlined_parameters PROTO((inline_data *, tree, tree));\n-static tree declare_return_variable PROTO((inline_data *, tree *));\n-static tree copy_body_r PROTO((tree *, int *, void *));\n-static tree copy_body PROTO((inline_data *));\n-static tree expand_call_inline PROTO((tree *, int *, void *));\n-static void expand_calls_inline PROTO((tree *, inline_data *));\n-static int inlinable_function_p PROTO((tree, inline_data *));\n-static tree remap_decl PROTO((tree, inline_data *));\n-static void remap_block PROTO((tree, tree, inline_data *));\n-static void copy_scope_stmt PROTO((tree *, int *, inline_data *));\n-static tree calls_setjmp_r PROTO((tree *, int *, void *));\n+static tree initialize_inlined_parameters PARAMS ((inline_data *, tree, tree));\n+static tree declare_return_variable PARAMS ((inline_data *, tree *));\n+static tree copy_body_r PARAMS ((tree *, int *, void *));\n+static tree copy_body PARAMS ((inline_data *));\n+static tree expand_call_inline PARAMS ((tree *, int *, void *));\n+static void expand_calls_inline PARAMS ((tree *, inline_data *));\n+static int inlinable_function_p PARAMS ((tree, inline_data *));\n+static tree remap_decl PARAMS ((tree, inline_data *));\n+static void remap_block PARAMS ((tree, tree, inline_data *));\n+static void copy_scope_stmt PARAMS ((tree *, int *, inline_data *));\n+static tree calls_setjmp_r PARAMS ((tree *, int *, void *));\n \n /* Remap DECL during the copying of the BLOCK tree for the function.\n    DATA is really an `inline_data *'.  */"}, {"sha": "1d3f44a706ddd4667dd0c85f242f9c74a7d64752", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -127,8 +127,8 @@ extern int end_of_file;\n    error message if the user supplies an empty conditional expression.  */\n static const char *cond_stmt_keyword;\n \n-static tree empty_parms PROTO((void));\n-static void parse_decl PROTO((tree, tree, tree, int, tree *));\n+static tree empty_parms PARAMS ((void));\n+static void parse_decl PARAMS ((tree, tree, tree, int, tree *));\n \n /* Nonzero if we have an `extern \"C\"' acting as an extern specifier.  */\n int have_extern_spec;\n@@ -180,8 +180,8 @@ static tree current_enum_type;\n /* Tell yyparse how to print a token's value, if yydebug is set.  */\n \n #define YYPRINT(FILE,YYCHAR,YYLVAL) yyprint(FILE,YYCHAR,YYLVAL)\n-extern void yyprint\t\t\tPROTO((FILE *, int, YYSTYPE));\n-extern tree combine_strings\t\tPROTO((tree));\n+extern void yyprint\t\t\tPARAMS ((FILE *, int, YYSTYPE));\n+extern tree combine_strings\t\tPARAMS ((tree));\n \n static void\n parse_decl (declarator, specs_attrs, attributes, initialized, decl)"}, {"sha": "7aacbdd03ec3bb75c19a3c4f1222163d8e3ec71e", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -62,8 +62,8 @@ extern int end_of_file;\n    error message if the user supplies an empty conditional expression.  */\n static const char *cond_stmt_keyword;\n \n-static tree empty_parms PROTO((void));\n-static void parse_decl PROTO((tree, tree, tree, int, tree *));\n+static tree empty_parms PARAMS ((void));\n+static void parse_decl PARAMS ((tree, tree, tree, int, tree *));\n \n /* Nonzero if we have an `extern \"C\"' acting as an extern specifier.  */\n int have_extern_spec;\n@@ -311,8 +311,8 @@ static tree current_enum_type;\n /* Tell yyparse how to print a token's value, if yydebug is set.  */\n \n #define YYPRINT(FILE,YYCHAR,YYLVAL) yyprint(FILE,YYCHAR,YYLVAL)\n-extern void yyprint\t\t\tPROTO((FILE *, int, YYSTYPE));\n-extern tree combine_strings\t\tPROTO((tree));\n+extern void yyprint\t\t\tPARAMS ((FILE *, int, YYSTYPE));\n+extern tree combine_strings\t\tPARAMS ((tree));\n \n static void\n parse_decl (declarator, specs_attrs, attributes, initialized, decl)"}, {"sha": "b0b3289869f9dd2cc52a4a9e3188ee362bf13bc7", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -45,7 +45,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* The type of functions taking a tree, and some additional data, and\n    returning an int.  */\n-typedef int (*tree_fn_t) PROTO((tree, void*));\n+typedef int (*tree_fn_t) PARAMS ((tree, void*));\n \n extern struct obstack permanent_obstack;\n \n@@ -87,77 +87,77 @@ static size_t inline_parm_levels_used;\n #define GTB_IGNORE_TYPE 2 /* We don't need to try to unify the current\n \t\t\t     type with the desired type.  */\n \n-static int resolve_overloaded_unification PROTO((tree, tree, tree, tree,\n+static int resolve_overloaded_unification PARAMS ((tree, tree, tree, tree,\n \t\t\t\t\t\t unification_kind_t, int));\n-static int try_one_overload PROTO((tree, tree, tree, tree, tree,\n+static int try_one_overload PARAMS ((tree, tree, tree, tree, tree,\n \t\t\t\t   unification_kind_t, int));\n-static int unify PROTO((tree, tree, tree, tree, int));\n-static void add_pending_template PROTO((tree));\n-static int push_tinst_level PROTO((tree));\n-static tree classtype_mangled_name PROTO((tree));\n-static char *mangle_class_name_for_template PROTO((char *, tree, tree));\n-static tree tsubst_expr_values PROTO((tree, tree));\n-static int list_eq PROTO((tree, tree));\n-static tree get_class_bindings PROTO((tree, tree, tree));\n-static tree coerce_template_parms PROTO((tree, tree, tree, int, int));\n-static void tsubst_enum\tPROTO((tree, tree, tree));\n-static tree add_to_template_args PROTO((tree, tree));\n-static tree add_outermost_template_args PROTO((tree, tree));\n-static void maybe_adjust_types_for_deduction PROTO((unification_kind_t, tree*,\n+static int unify PARAMS ((tree, tree, tree, tree, int));\n+static void add_pending_template PARAMS ((tree));\n+static int push_tinst_level PARAMS ((tree));\n+static tree classtype_mangled_name PARAMS ((tree));\n+static char *mangle_class_name_for_template PARAMS ((char *, tree, tree));\n+static tree tsubst_expr_values PARAMS ((tree, tree));\n+static int list_eq PARAMS ((tree, tree));\n+static tree get_class_bindings PARAMS ((tree, tree, tree));\n+static tree coerce_template_parms PARAMS ((tree, tree, tree, int, int));\n+static void tsubst_enum\tPARAMS ((tree, tree, tree));\n+static tree add_to_template_args PARAMS ((tree, tree));\n+static tree add_outermost_template_args PARAMS ((tree, tree));\n+static void maybe_adjust_types_for_deduction PARAMS ((unification_kind_t, tree*,\n \t\t\t\t\t\t    tree*)); \n-static int  type_unification_real PROTO((tree, tree, tree, tree,\n+static int  type_unification_real PARAMS ((tree, tree, tree, tree,\n \t\t\t\t\t int, unification_kind_t, int));\n-static void note_template_header PROTO((int));\n-static tree maybe_fold_nontype_arg PROTO((tree));\n-static tree convert_nontype_argument PROTO((tree, tree));\n-static tree convert_template_argument PROTO ((tree, tree, tree, int,\n+static void note_template_header PARAMS ((int));\n+static tree maybe_fold_nontype_arg PARAMS ((tree));\n+static tree convert_nontype_argument PARAMS ((tree, tree));\n+static tree convert_template_argument PARAMS ((tree, tree, tree, int,\n \t\t\t\t\t      int , tree));\n-static tree get_bindings_overload PROTO((tree, tree, tree));\n-static int for_each_template_parm PROTO((tree, tree_fn_t, void*));\n-static tree build_template_parm_index PROTO((int, int, int, tree, tree));\n-static int inline_needs_template_parms PROTO((tree));\n-static void push_inline_template_parms_recursive PROTO((tree, int));\n-static tree retrieve_specialization PROTO((tree, tree));\n-static tree retrieve_local_specialization PROTO((tree, tree));\n-static tree register_specialization PROTO((tree, tree, tree));\n-static tree register_local_specialization PROTO((tree, tree, tree));\n-static int unregister_specialization PROTO((tree, tree));\n-static tree reduce_template_parm_level PROTO((tree, tree, int));\n-static tree build_template_decl PROTO((tree, tree));\n-static int mark_template_parm PROTO((tree, void *));\n-static tree tsubst_friend_function PROTO((tree, tree));\n-static tree tsubst_friend_class PROTO((tree, tree));\n-static tree get_bindings_real PROTO((tree, tree, tree, int));\n-static int template_decl_level PROTO((tree));\n-static tree maybe_get_template_decl_from_type_decl PROTO((tree));\n-static int check_cv_quals_for_unify PROTO((int, tree, tree));\n-static tree tsubst_template_arg_vector PROTO((tree, tree, int));\n-static tree tsubst_template_parms PROTO((tree, tree, int));\n-static void regenerate_decl_from_template PROTO((tree, tree));\n-static tree most_specialized PROTO((tree, tree, tree));\n-static tree most_specialized_class PROTO((tree, tree));\n-static void set_mangled_name_for_template_decl PROTO((tree));\n-static int template_class_depth_real PROTO((tree, int));\n-static tree tsubst_aggr_type PROTO((tree, tree, int, tree, int));\n-static tree tsubst_decl PROTO((tree, tree, tree, tree));\n-static tree tsubst_arg_types PROTO((tree, tree, int, tree));\n-static tree tsubst_function_type PROTO((tree, tree, int, tree));\n-static void check_specialization_scope PROTO((void));\n-static tree process_partial_specialization PROTO((tree));\n-static void set_current_access_from_decl PROTO((tree));\n-static void check_default_tmpl_args PROTO((tree, tree, int, int));\n-static tree tsubst_call_declarator_parms PROTO((tree, tree, int, tree));\n-static tree get_template_base_recursive PROTO((tree, tree,\n+static tree get_bindings_overload PARAMS ((tree, tree, tree));\n+static int for_each_template_parm PARAMS ((tree, tree_fn_t, void*));\n+static tree build_template_parm_index PARAMS ((int, int, int, tree, tree));\n+static int inline_needs_template_parms PARAMS ((tree));\n+static void push_inline_template_parms_recursive PARAMS ((tree, int));\n+static tree retrieve_specialization PARAMS ((tree, tree));\n+static tree retrieve_local_specialization PARAMS ((tree, tree));\n+static tree register_specialization PARAMS ((tree, tree, tree));\n+static tree register_local_specialization PARAMS ((tree, tree, tree));\n+static int unregister_specialization PARAMS ((tree, tree));\n+static tree reduce_template_parm_level PARAMS ((tree, tree, int));\n+static tree build_template_decl PARAMS ((tree, tree));\n+static int mark_template_parm PARAMS ((tree, void *));\n+static tree tsubst_friend_function PARAMS ((tree, tree));\n+static tree tsubst_friend_class PARAMS ((tree, tree));\n+static tree get_bindings_real PARAMS ((tree, tree, tree, int));\n+static int template_decl_level PARAMS ((tree));\n+static tree maybe_get_template_decl_from_type_decl PARAMS ((tree));\n+static int check_cv_quals_for_unify PARAMS ((int, tree, tree));\n+static tree tsubst_template_arg_vector PARAMS ((tree, tree, int));\n+static tree tsubst_template_parms PARAMS ((tree, tree, int));\n+static void regenerate_decl_from_template PARAMS ((tree, tree));\n+static tree most_specialized PARAMS ((tree, tree, tree));\n+static tree most_specialized_class PARAMS ((tree, tree));\n+static void set_mangled_name_for_template_decl PARAMS ((tree));\n+static int template_class_depth_real PARAMS ((tree, int));\n+static tree tsubst_aggr_type PARAMS ((tree, tree, int, tree, int));\n+static tree tsubst_decl PARAMS ((tree, tree, tree, tree));\n+static tree tsubst_arg_types PARAMS ((tree, tree, int, tree));\n+static tree tsubst_function_type PARAMS ((tree, tree, int, tree));\n+static void check_specialization_scope PARAMS ((void));\n+static tree process_partial_specialization PARAMS ((tree));\n+static void set_current_access_from_decl PARAMS ((tree));\n+static void check_default_tmpl_args PARAMS ((tree, tree, int, int));\n+static tree tsubst_call_declarator_parms PARAMS ((tree, tree, int, tree));\n+static tree get_template_base_recursive PARAMS ((tree, tree,\n \t\t\t\t\t       tree, tree, tree, int)); \n-static tree get_template_base PROTO((tree, tree, tree, tree));\n-static tree try_class_unification PROTO((tree, tree, tree, tree));\n-static int coerce_template_template_parms PROTO((tree, tree, int,\n+static tree get_template_base PARAMS ((tree, tree, tree, tree));\n+static tree try_class_unification PARAMS ((tree, tree, tree, tree));\n+static int coerce_template_template_parms PARAMS ((tree, tree, int,\n \t\t\t\t\t\t tree, tree));\n-static tree determine_specialization PROTO((tree, tree, tree *, int));\n-static int template_args_equal PROTO((tree, tree));\n-static void print_template_context PROTO((int));\n-static void tsubst_default_arguments PROTO((tree));\n-static tree for_each_template_parm_r PROTO((tree *, int *, void *));\n+static tree determine_specialization PARAMS ((tree, tree, tree *, int));\n+static int template_args_equal PARAMS ((tree, tree));\n+static void print_template_context PARAMS ((int));\n+static void tsubst_default_arguments PARAMS ((tree));\n+static tree for_each_template_parm_r PARAMS ((tree *, int *, void *));\n \n /* Called once to initialize pt.c.  */\n "}, {"sha": "7812823d19ae4b8a4f9259714ff0512ee97e4ae7", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -1,5 +1,5 @@\n /* Code to maintain a C++ template repository.\n-   Copyright (C) 1995, 96-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 96-97, 1998, 2000 Free Software Foundation, Inc.\n    Contributed by Jason Merrill (jason@cygnus.com)\n \n This file is part of GNU CC.\n@@ -34,12 +34,12 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"ggc.h\"\n \n-static tree repo_get_id PROTO((tree));\n-static char *extract_string PROTO((char **));\n-static char *get_base_filename PROTO((const char *));\n-static void open_repo_file PROTO((const char *));\n-static char *afgets PROTO((FILE *));\n-static void reopen_repo_file_for_write PROTO((void));\n+static tree repo_get_id PARAMS ((tree));\n+static char *extract_string PARAMS ((char **));\n+static char *get_base_filename PARAMS ((const char *));\n+static void open_repo_file PARAMS ((const char *));\n+static char *afgets PARAMS ((FILE *));\n+static void reopen_repo_file_for_write PARAMS ((void));\n \n static tree pending_repo;\n static tree original_repo;"}, {"sha": "e962b6a75fedac126768203a681335156639667b", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -35,23 +35,23 @@ Boston, MA 02111-1307, USA.  */\n \n extern struct obstack permanent_obstack;\n \n-static tree build_runtime_decl PROTO((const char *, tree));\n-static tree build_headof_sub PROTO((tree));\n-static tree build_headof PROTO((tree));\n-static tree get_tinfo_var PROTO((tree));\n-static tree ifnonnull PROTO((tree, tree));\n-static tree tinfo_name PROTO((tree));\n-static tree get_base_offset PROTO((tree, tree));\n-static tree build_dynamic_cast_1 PROTO((tree, tree));\n-static void expand_si_desc PROTO((tree, tree));\n-static void expand_class_desc PROTO((tree, tree));\n-static void expand_attr_desc PROTO((tree, tree));\n-static void expand_ptr_desc PROTO((tree, tree));\n-static void expand_generic_desc PROTO((tree, tree, const char *));\n-static tree throw_bad_cast PROTO((void));\n-static tree throw_bad_typeid PROTO((void));\n-static tree get_tinfo_decl_dynamic PROTO((tree));\n-static tree tinfo_from_decl PROTO((tree));\n+static tree build_runtime_decl PARAMS ((const char *, tree));\n+static tree build_headof_sub PARAMS ((tree));\n+static tree build_headof PARAMS ((tree));\n+static tree get_tinfo_var PARAMS ((tree));\n+static tree ifnonnull PARAMS ((tree, tree));\n+static tree tinfo_name PARAMS ((tree));\n+static tree get_base_offset PARAMS ((tree, tree));\n+static tree build_dynamic_cast_1 PARAMS ((tree, tree));\n+static void expand_si_desc PARAMS ((tree, tree));\n+static void expand_class_desc PARAMS ((tree, tree));\n+static void expand_attr_desc PARAMS ((tree, tree));\n+static void expand_ptr_desc PARAMS ((tree, tree));\n+static void expand_generic_desc PARAMS ((tree, tree, const char *));\n+static tree throw_bad_cast PARAMS ((void));\n+static tree throw_bad_typeid PARAMS ((void));\n+static tree get_tinfo_decl_dynamic PARAMS ((tree));\n+static tree tinfo_from_decl PARAMS ((tree));\n \f\n void\n init_rtti_processing ()"}, {"sha": "a293142454438fa7d9543d4492ed52637330281c", "filename": "gcc/cp/search.c", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -75,78 +75,78 @@ pop_stack_level (stack)\n #define search_level stack_level\n static struct search_level *search_stack;\n \n-static tree next_baselink PROTO((tree));\n-static tree get_vbase_1 PROTO((tree, tree, unsigned int *));\n-static tree lookup_field_1 PROTO((tree, tree));\n-static tree convert_pointer_to_single_level PROTO((tree, tree));\n-static int lookup_fnfields_here PROTO((tree, tree));\n-static int is_subobject_of_p PROTO((tree, tree));\n-static int hides PROTO((tree, tree));\n-static tree virtual_context PROTO((tree, tree, tree));\n-static tree dfs_check_overlap PROTO((tree, void *));\n-static tree dfs_no_overlap_yet PROTO((tree, void *));\n+static tree next_baselink PARAMS ((tree));\n+static tree get_vbase_1 PARAMS ((tree, tree, unsigned int *));\n+static tree lookup_field_1 PARAMS ((tree, tree));\n+static tree convert_pointer_to_single_level PARAMS ((tree, tree));\n+static int lookup_fnfields_here PARAMS ((tree, tree));\n+static int is_subobject_of_p PARAMS ((tree, tree));\n+static int hides PARAMS ((tree, tree));\n+static tree virtual_context PARAMS ((tree, tree, tree));\n+static tree dfs_check_overlap PARAMS ((tree, void *));\n+static tree dfs_no_overlap_yet PARAMS ((tree, void *));\n static int get_base_distance_recursive\n-\tPROTO((tree, int, int, int, int *, tree *, tree,\n+\tPARAMS ((tree, int, int, int, int *, tree *, tree,\n \t       int, int *, int, int));\n-static int dynamic_cast_base_recurse PROTO((tree, tree, int, tree *));\n+static int dynamic_cast_base_recurse PARAMS ((tree, tree, int, tree *));\n static void expand_upcast_fixups \n-\tPROTO((tree, tree, tree, tree, tree, tree, tree *));\n+\tPARAMS ((tree, tree, tree, tree, tree, tree, tree *));\n static void fixup_virtual_upcast_offsets\n-\tPROTO((tree, tree, int, int, tree, tree, tree, tree,\n+\tPARAMS ((tree, tree, int, int, tree, tree, tree, tree,\n \t       tree *));\n-static tree marked_vtable_pathp PROTO((tree, void *));\n-static tree unmarked_vtable_pathp PROTO((tree, void *));\n-static tree marked_new_vtablep PROTO((tree, void *));\n-static tree unmarked_new_vtablep PROTO((tree, void *));\n-static tree marked_pushdecls_p PROTO((tree, void *));\n-static tree unmarked_pushdecls_p PROTO((tree, void *));\n+static tree marked_vtable_pathp PARAMS ((tree, void *));\n+static tree unmarked_vtable_pathp PARAMS ((tree, void *));\n+static tree marked_new_vtablep PARAMS ((tree, void *));\n+static tree unmarked_new_vtablep PARAMS ((tree, void *));\n+static tree marked_pushdecls_p PARAMS ((tree, void *));\n+static tree unmarked_pushdecls_p PARAMS ((tree, void *));\n #if 0\n-static tree dfs_debug_unmarkedp PROTO((tree, void *));\n-static tree dfs_debug_mark PROTO((tree, void *));\n+static tree dfs_debug_unmarkedp PARAMS ((tree, void *));\n+static tree dfs_debug_mark PARAMS ((tree, void *));\n #endif\n-static tree dfs_find_vbases PROTO((tree, void *));\n-static tree dfs_clear_vbase_slots PROTO((tree, void *));\n-static tree dfs_init_vbase_pointers PROTO((tree, void *));\n-static tree dfs_get_vbase_types PROTO((tree, void *));\n-static tree dfs_push_type_decls PROTO((tree, void *));\n-static tree dfs_push_decls PROTO((tree, void *));\n-static tree dfs_unuse_fields PROTO((tree, void *));\n-static tree add_conversions PROTO((tree, void *));\n-static tree get_virtuals_named_this PROTO((tree, tree));\n-static tree get_virtual_destructor PROTO((tree, void *));\n-static tree tree_has_any_destructor_p PROTO((tree, void *));\n-static int covariant_return_p PROTO((tree, tree));\n-static int check_final_overrider PROTO((tree, tree));\n+static tree dfs_find_vbases PARAMS ((tree, void *));\n+static tree dfs_clear_vbase_slots PARAMS ((tree, void *));\n+static tree dfs_init_vbase_pointers PARAMS ((tree, void *));\n+static tree dfs_get_vbase_types PARAMS ((tree, void *));\n+static tree dfs_push_type_decls PARAMS ((tree, void *));\n+static tree dfs_push_decls PARAMS ((tree, void *));\n+static tree dfs_unuse_fields PARAMS ((tree, void *));\n+static tree add_conversions PARAMS ((tree, void *));\n+static tree get_virtuals_named_this PARAMS ((tree, tree));\n+static tree get_virtual_destructor PARAMS ((tree, void *));\n+static tree tree_has_any_destructor_p PARAMS ((tree, void *));\n+static int covariant_return_p PARAMS ((tree, tree));\n+static int check_final_overrider PARAMS ((tree, tree));\n static struct search_level *push_search_level\n-\tPROTO((struct stack_level *, struct obstack *));\n+\tPARAMS ((struct stack_level *, struct obstack *));\n static struct search_level *pop_search_level\n-\tPROTO((struct stack_level *));\n+\tPARAMS ((struct stack_level *));\n static tree bfs_walk\n-\tPROTO((tree, tree (*) (tree, void *), tree (*) (tree, void *),\n+\tPARAMS ((tree, tree (*) (tree, void *), tree (*) (tree, void *),\n \t       void *));\n-static tree lookup_field_queue_p PROTO((tree, void *));\n-static tree lookup_field_r PROTO((tree, void *));\n-static tree get_virtuals_named_this_r PROTO ((tree, void *));\n-static tree context_for_name_lookup PROTO ((tree));\n-static tree canonical_binfo PROTO ((tree));\n-static tree shared_marked_p PROTO ((tree, void *));\n-static tree shared_unmarked_p PROTO ((tree, void *));\n-static int  dependent_base_p PROTO ((tree));\n-static tree dfs_accessible_queue_p PROTO ((tree, void *));\n-static tree dfs_accessible_p PROTO ((tree, void *));\n-static tree dfs_access_in_type PROTO ((tree, void *));\n-static tree access_in_type PROTO ((tree, tree));\n-static tree dfs_canonical_queue PROTO ((tree, void *));\n-static tree dfs_assert_unmarked_p PROTO ((tree, void *));\n-static void assert_canonical_unmarked PROTO ((tree));\n-static int protected_accessible_p PROTO ((tree, tree, tree, tree));\n-static int friend_accessible_p PROTO ((tree, tree, tree, tree));\n-static void setup_class_bindings PROTO ((tree, int));\n-static int template_self_reference_p PROTO ((tree, tree));\n-static void fixup_all_virtual_upcast_offsets PROTO ((tree, tree));\n-static tree dfs_mark_primary_bases PROTO((tree, void *));\n-static tree get_shared_vbase_if_not_primary PROTO((tree, void *));\n-static tree dfs_find_vbase_instance PROTO((tree, void *));\n+static tree lookup_field_queue_p PARAMS ((tree, void *));\n+static tree lookup_field_r PARAMS ((tree, void *));\n+static tree get_virtuals_named_this_r PARAMS ((tree, void *));\n+static tree context_for_name_lookup PARAMS ((tree));\n+static tree canonical_binfo PARAMS ((tree));\n+static tree shared_marked_p PARAMS ((tree, void *));\n+static tree shared_unmarked_p PARAMS ((tree, void *));\n+static int  dependent_base_p PARAMS ((tree));\n+static tree dfs_accessible_queue_p PARAMS ((tree, void *));\n+static tree dfs_accessible_p PARAMS ((tree, void *));\n+static tree dfs_access_in_type PARAMS ((tree, void *));\n+static tree access_in_type PARAMS ((tree, tree));\n+static tree dfs_canonical_queue PARAMS ((tree, void *));\n+static tree dfs_assert_unmarked_p PARAMS ((tree, void *));\n+static void assert_canonical_unmarked PARAMS ((tree));\n+static int protected_accessible_p PARAMS ((tree, tree, tree, tree));\n+static int friend_accessible_p PARAMS ((tree, tree, tree, tree));\n+static void setup_class_bindings PARAMS ((tree, int));\n+static int template_self_reference_p PARAMS ((tree, tree));\n+static void fixup_all_virtual_upcast_offsets PARAMS ((tree, tree));\n+static tree dfs_mark_primary_bases PARAMS ((tree, void *));\n+static tree get_shared_vbase_if_not_primary PARAMS ((tree, void *));\n+static tree dfs_find_vbase_instance PARAMS ((tree, void *));\n \n /* Allocate a level of searching.  */\n \n@@ -1707,8 +1707,8 @@ lookup_fnfields_1 (type, name)\n static tree\n bfs_walk (binfo, fn, qfn, data)\n      tree binfo;\n-     tree (*fn) PROTO((tree, void *));\n-     tree (*qfn) PROTO((tree, void *));\n+     tree (*fn) PARAMS ((tree, void *));\n+     tree (*qfn) PARAMS ((tree, void *));\n      void *data;\n {\n   size_t head;\n@@ -1773,9 +1773,9 @@ bfs_walk (binfo, fn, qfn, data)\n tree\n dfs_walk_real (binfo, prefn, postfn, qfn, data)\n      tree binfo;\n-     tree (*prefn) PROTO((tree, void *));\n-     tree (*postfn) PROTO((tree, void *));\n-     tree (*qfn) PROTO((tree, void *));\n+     tree (*prefn) PARAMS ((tree, void *));\n+     tree (*postfn) PARAMS ((tree, void *));\n+     tree (*qfn) PARAMS ((tree, void *));\n      void *data;\n {\n   int i;\n@@ -1822,8 +1822,8 @@ dfs_walk_real (binfo, prefn, postfn, qfn, data)\n tree\n dfs_walk (binfo, fn, qfn, data)\n      tree binfo;\n-     tree (*fn) PROTO((tree, void *));\n-     tree (*qfn) PROTO((tree, void *));\n+     tree (*fn) PARAMS ((tree, void *));\n+     tree (*qfn) PARAMS ((tree, void *));\n      void *data;\n {\n   return dfs_walk_real (binfo, 0, fn, qfn, data);"}, {"sha": "d85a710f25a28fcde3588324be4d72b722427d66", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -45,9 +45,9 @@\n    parsing into this file; that will make implementing the new parser\n    much easier since it will be able to make use of these routines.  */\n \n-static tree expand_cond PROTO((tree));\n-static tree maybe_convert_cond PROTO((tree));\n-static tree simplify_aggr_init_exprs_r PROTO((tree *, int *, void *));\n+static tree expand_cond PARAMS ((tree));\n+static tree maybe_convert_cond PARAMS ((tree));\n+static tree simplify_aggr_init_exprs_r PARAMS ((tree *, int *, void *));\n \n /* Record the fact that STMT was the last statement added to the\n    statement tree.  */"}, {"sha": "8d95be650bd6631b4941d92835007e6037d85b73", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -1,5 +1,5 @@\n /* Type Analyzer for GNU C++.\n-   Copyright (C) 1987, 89, 92-97, 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 89, 92-97, 98, 99, 2000 Free Software Foundation, Inc.\n    Hacked... nay, bludgeoned... by Mark Eichin (eichin@cygnus.com)\n \n This file is part of GNU CC.\n@@ -46,15 +46,15 @@ struct token  {\n   YYSTYPE\tyylval;\n };\n \n-static int do_aggr PROTO((void));\n-static void scan_tokens PROTO((unsigned int));\n+static int do_aggr PARAMS ((void));\n+static void scan_tokens PARAMS ((unsigned int));\n \n #ifdef SPEW_DEBUG\n-static int num_tokens PROTO((void));\n-static struct token *nth_token PROTO((int));\n-static void add_token PROTO((struct token *));\n-static void consume_token PROTO((void));\n-static int debug_yychar PROTO((int));\n+static int num_tokens PARAMS ((void));\n+static struct token *nth_token PARAMS ((int));\n+static void add_token PARAMS ((struct token *));\n+static void consume_token PARAMS ((void));\n+static int debug_yychar PARAMS ((int));\n #endif\n \n /* From lex.c: */"}, {"sha": "392ea547f2cbec00409869d1881a0afe8a7592c0", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -31,21 +31,21 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-config.h\"\n #include \"integrate.h\"\n \n-static tree bot_manip PROTO((tree *, int *, void *));\n-static tree bot_replace PROTO((tree *, int *, void *));\n-static tree build_cplus_array_type_1 PROTO((tree, tree));\n-static void list_hash_add PROTO((int, tree));\n-static int list_hash PROTO((tree, tree, tree));\n-static tree list_hash_lookup PROTO((int, tree, tree, tree));\n-static cp_lvalue_kind lvalue_p_1 PROTO((tree, int));\n-static tree no_linkage_helper PROTO((tree *, int *, void *));\n-static tree build_srcloc PROTO((char *, int));\n-static void mark_list_hash PROTO ((void *));\n-static int statement_code_p PROTO((enum tree_code));\n-static tree mark_local_for_remap_r PROTO((tree *, int *, void *));\n-static tree cp_unsave_r PROTO ((tree *, int *, void *));\n-static void cp_unsave PROTO((tree *));\n-static tree build_target_expr PROTO((tree, tree));\n+static tree bot_manip PARAMS ((tree *, int *, void *));\n+static tree bot_replace PARAMS ((tree *, int *, void *));\n+static tree build_cplus_array_type_1 PARAMS ((tree, tree));\n+static void list_hash_add PARAMS ((int, tree));\n+static int list_hash PARAMS ((tree, tree, tree));\n+static tree list_hash_lookup PARAMS ((int, tree, tree, tree));\n+static cp_lvalue_kind lvalue_p_1 PARAMS ((tree, int));\n+static tree no_linkage_helper PARAMS ((tree *, int *, void *));\n+static tree build_srcloc PARAMS ((char *, int));\n+static void mark_list_hash PARAMS ((void *));\n+static int statement_code_p PARAMS ((enum tree_code));\n+static tree mark_local_for_remap_r PARAMS ((tree *, int *, void *));\n+static tree cp_unsave_r PARAMS ((tree *, int *, void *));\n+static void cp_unsave PARAMS ((tree *));\n+static tree build_target_expr PARAMS ((tree, tree));\n \n /* If REF is an lvalue, returns the kind of lvalue that REF is.\n    Otherwise, returns clk_none.  If TREAT_CLASS_RVALUES_AS_LVALUES is\n@@ -1630,7 +1630,7 @@ break_out_target_exprs (t)\n    current line number.  */\n \n tree\n-build_min_nt VPROTO((enum tree_code code, ...))\n+build_min_nt VPARAMS ((enum tree_code code, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   enum tree_code code;\n@@ -1664,7 +1664,7 @@ build_min_nt VPROTO((enum tree_code code, ...))\n    line-number.  */\n \n tree\n-build_min VPROTO((enum tree_code code, tree tt, ...))\n+build_min VPARAMS ((enum tree_code code, tree tt, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   enum tree_code code;"}, {"sha": "c9c10854fb5c5c134057ec7f413139430acdae8b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -41,31 +41,31 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"defaults.h\"\n \n-static tree convert_for_assignment PROTO((tree, tree, const char *, tree,\n+static tree convert_for_assignment PARAMS ((tree, tree, const char *, tree,\n \t\t\t\t\t  int));\n-static tree pointer_int_sum PROTO((enum tree_code, tree, tree));\n-static tree rationalize_conditional_expr PROTO((enum tree_code, tree));\n-static int comp_target_parms PROTO((tree, tree, int));\n-static int comp_ptr_ttypes_real PROTO((tree, tree, int));\n-static int comp_ptr_ttypes_const PROTO((tree, tree));\n-static int comp_ptr_ttypes_reinterpret PROTO((tree, tree));\n-static int comp_except_types PROTO((tree, tree, int));\n-static int comp_array_types PROTO((int (*) (tree, tree, int), tree,\n+static tree pointer_int_sum PARAMS ((enum tree_code, tree, tree));\n+static tree rationalize_conditional_expr PARAMS ((enum tree_code, tree));\n+static int comp_target_parms PARAMS ((tree, tree, int));\n+static int comp_ptr_ttypes_real PARAMS ((tree, tree, int));\n+static int comp_ptr_ttypes_const PARAMS ((tree, tree));\n+static int comp_ptr_ttypes_reinterpret PARAMS ((tree, tree));\n+static int comp_except_types PARAMS ((tree, tree, int));\n+static int comp_array_types PARAMS ((int (*) (tree, tree, int), tree,\n \t\t\t\t   tree, int));\n-static tree common_base_type PROTO((tree, tree));\n+static tree common_base_type PARAMS ((tree, tree));\n #if 0\n-static tree convert_sequence PROTO((tree, tree));\n+static tree convert_sequence PARAMS ((tree, tree));\n #endif\n-static tree lookup_anon_field PROTO((tree, tree));\n-static tree pointer_diff PROTO((tree, tree, tree));\n-static tree build_component_addr PROTO((tree, tree));\n-static tree qualify_type PROTO((tree, tree));\n-static tree get_delta_difference PROTO((tree, tree, int));\n-static int comp_cv_target_types PROTO((tree, tree, int));\n-static void casts_away_constness_r PROTO((tree *, tree *));\n-static int casts_away_constness PROTO ((tree, tree));\n-static void maybe_warn_about_returning_address_of_local PROTO ((tree));\n-static tree strip_all_pointer_quals PROTO ((tree));\n+static tree lookup_anon_field PARAMS ((tree, tree));\n+static tree pointer_diff PARAMS ((tree, tree, tree));\n+static tree build_component_addr PARAMS ((tree, tree));\n+static tree qualify_type PARAMS ((tree, tree));\n+static tree get_delta_difference PARAMS ((tree, tree, int));\n+static int comp_cv_target_types PARAMS ((tree, tree, int));\n+static void casts_away_constness_r PARAMS ((tree *, tree *));\n+static int casts_away_constness PARAMS ((tree, tree));\n+static void maybe_warn_about_returning_address_of_local PARAMS ((tree));\n+static tree strip_all_pointer_quals PARAMS ((tree));\n \n /* Return the target type of TYPE, which means return T for:\n    T*, T&, T[], T (...), and otherwise, just T.  */\n@@ -857,7 +857,7 @@ comp_except_specs (t1, t2, exact)\n \n static int\n comp_array_types (cmp, t1, t2, strict)\n-     register int (*cmp) PROTO((tree, tree, int));\n+     register int (*cmp) PARAMS ((tree, tree, int));\n      tree t1, t2;\n      int strict;\n {"}, {"sha": "f49398b84a4fbd2cd7b5761e56aff74d703d8918", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -1,6 +1,6 @@\n /* Report error messages, build initializers, and perform\n    some front-end optimizations for C++ compiler.\n-   Copyright (C) 1987, 88, 89, 92-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92-98, 99, 2000 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -38,8 +38,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"output.h\"\n \n-static tree process_init_constructor PROTO((tree, tree, tree *));\n-static void ack PVPROTO ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n+static tree process_init_constructor PARAMS ((tree, tree, tree *));\n+static void ack PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n \n /* Print an error message stemming from an attempt to use\n    BASETYPE as a base class for TYPE.  */\n@@ -83,7 +83,7 @@ readonly_error (arg, string, soft)\n      int soft;\n {\n   const char *fmt;\n-  void (*fn) PVPROTO ((const char *, ...));\n+  void (*fn) PARAMS ((const char *, ...));\n \n   if (soft)\n     fn = cp_pedwarn;\n@@ -248,7 +248,7 @@ incomplete_type_error (value, type)\n /* Like error(), but don't call report_error_function().  */\n \n static void\n-ack VPROTO ((const char *msg, ...))\n+ack VPARAMS ((const char *msg, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *msg;"}, {"sha": "22a4ab859f370a3bd303e0657f92c9d78b85605c", "filename": "gcc/cp/xref.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fxref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158991b7e5be34f9464adadacb734743d4e39ca6/gcc%2Fcp%2Fxref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fxref.c?ref=158991b7e5be34f9464adadacb734743d4e39ca6", "patch": "@@ -1,5 +1,5 @@\n /* Code for handling XREF output from GNU C++.\n-   Copyright (C) 1992, 93-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 93-97, 1998, 2000 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -117,15 +117,15 @@ static\ttree\t\tlast_fndecl = NULL;\n /*\tForward definitions\t\t\t\t\t\t*/\n /*\t\t\t\t\t\t\t\t\t*/\n /************************************************************************/\n-static\tvoid\t\tgen_assign PROTO((XREF_FILE, tree));\n-static\tXREF_FILE\tfind_file PROTO((const char *));\n-static\tconst char *\tfilename PROTO((XREF_FILE));\n-static\tconst char *\tfctname PROTO((tree));\n-static\tconst char *\tdeclname PROTO((tree));\n-static\tvoid\t\tsimplify_type PROTO((char *));\n-static\tconst char *\tfixname PROTO((const char *, char *));\n-static\tvoid\t\topen_xref_file PROTO((const char *));\n-static  const char *\tclassname PROTO((tree));\n+static\tvoid\t\tgen_assign PARAMS ((XREF_FILE, tree));\n+static\tXREF_FILE\tfind_file PARAMS ((const char *));\n+static\tconst char *\tfilename PARAMS ((XREF_FILE));\n+static\tconst char *\tfctname PARAMS ((tree));\n+static\tconst char *\tdeclname PARAMS ((tree));\n+static\tvoid\t\tsimplify_type PARAMS ((char *));\n+static\tconst char *\tfixname PARAMS ((const char *, char *));\n+static\tvoid\t\topen_xref_file PARAMS ((const char *));\n+static  const char *\tclassname PARAMS ((tree));\n \n /* Start cross referencing.  FILE is the name of the file we xref.  */\n "}]}