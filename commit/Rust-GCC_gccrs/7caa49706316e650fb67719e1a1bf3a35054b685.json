{"sha": "7caa49706316e650fb67719e1a1bf3a35054b685", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NhYTQ5NzA2MzE2ZTY1MGZiNjc3MTllMWExYmYzYTM1MDU0YjY4NQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-11-23T12:40:04Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-12-04T09:13:51Z"}, "message": "Refactor -frecord-gcc-switches.\n\ngcc/ChangeLog:\n\n\t* doc/tm.texi: Change argument of the record_gcc_switches\n\thook and remove SWITCH_TYPE_* enum values.\n\t* dwarf2out.c (gen_producer_string): Move to opts.c and remove\n\thandling of the dwarf_record_gcc_switches option.\n\t(dwarf2out_early_finish): Use moved gen_producer_string\n\tfunction.\n\t* opts.c (gen_producer_string): New.\n\t* opts.h (gen_producer_string): New.\n\t* target.def: Change type of record_gcc_switches.\n\t* target.h (enum print_switch_type): Remove.\n\t(elf_record_gcc_switches): Change first argument.\n\t* toplev.c (MAX_LINE): Remove.\n\t(print_to_asm_out_file):  Likewise.\n\t(print_to_stderr): Likewise.\n\t(print_single_switch): Likewise.\n\t(print_switch_values): Likewise.\n\t(init_asm_output): Use new gen_producer_string function.\n\t(process_options): Likewise.\n\t* varasm.c (elf_record_gcc_switches): Just save the string argument\n\tto the ELF container.", "tree": {"sha": "bfe3d80eb7261ea7781761b41c645f4951d47e1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfe3d80eb7261ea7781761b41c645f4951d47e1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7caa49706316e650fb67719e1a1bf3a35054b685", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7caa49706316e650fb67719e1a1bf3a35054b685", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7caa49706316e650fb67719e1a1bf3a35054b685", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7caa49706316e650fb67719e1a1bf3a35054b685/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "241a2c498005207d52a3d64884e41953fc00275c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/241a2c498005207d52a3d64884e41953fc00275c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/241a2c498005207d52a3d64884e41953fc00275c"}], "stats": {"total": 557, "additions": 166, "deletions": 391}, "files": [{"sha": "d9b855c13aca30c0cc66a2fcd65957c9bb8d5e6a", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 2, "deletions": 36, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7caa49706316e650fb67719e1a1bf3a35054b685/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7caa49706316e650fb67719e1a1bf3a35054b685/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=7caa49706316e650fb67719e1a1bf3a35054b685", "patch": "@@ -8090,43 +8090,9 @@ need to override this if your target has special flags that might be\n set via @code{__attribute__}.\n @end deftypefn\n \n-@deftypefn {Target Hook} int TARGET_ASM_RECORD_GCC_SWITCHES (print_switch_type @var{type}, const char *@var{text})\n+@deftypefn {Target Hook} void TARGET_ASM_RECORD_GCC_SWITCHES (const char *@var{})\n Provides the target with the ability to record the gcc command line\n-switches that have been passed to the compiler, and options that are\n-enabled.  The @var{type} argument specifies what is being recorded.\n-It can take the following values:\n-\n-@table @gcctabopt\n-@item SWITCH_TYPE_PASSED\n-@var{text} is a command line switch that has been set by the user.\n-\n-@item SWITCH_TYPE_ENABLED\n-@var{text} is an option which has been enabled.  This might be as a\n-direct result of a command line switch, or because it is enabled by\n-default or because it has been enabled as a side effect of a different\n-command line switch.  For example, the @option{-O2} switch enables\n-various different individual optimization passes.\n-\n-@item SWITCH_TYPE_DESCRIPTIVE\n-@var{text} is either NULL or some descriptive text which should be\n-ignored.  If @var{text} is NULL then it is being used to warn the\n-target hook that either recording is starting or ending.  The first\n-time @var{type} is SWITCH_TYPE_DESCRIPTIVE and @var{text} is NULL, the\n-warning is for start up and the second time the warning is for\n-wind down.  This feature is to allow the target hook to make any\n-necessary preparations before it starts to record switches and to\n-perform any necessary tidying up after it has finished recording\n-switches.\n-\n-@item SWITCH_TYPE_LINE_START\n-This option can be ignored by this target hook.\n-\n-@item  SWITCH_TYPE_LINE_END\n-This option can be ignored by this target hook.\n-@end table\n-\n-The hook's return value must be zero.  Other return values may be\n-supported in the future.\n+switches provided as argument.\n \n By default this hook is set to NULL, but an example implementation is\n provided for ELF based targets.  Called @var{elf_record_gcc_switches},"}, {"sha": "30e7ca68dbc27730e1f2a542b2ad1485cdbe0304", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 8, "deletions": 110, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7caa49706316e650fb67719e1a1bf3a35054b685/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7caa49706316e650fb67719e1a1bf3a35054b685/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=7caa49706316e650fb67719e1a1bf3a35054b685", "patch": "@@ -24438,115 +24438,6 @@ gen_ptr_to_mbr_type_die (tree type, dw_die_ref context_die)\n \n static char *producer_string;\n \n-/* Return a heap allocated producer string including command line options\n-   if -grecord-gcc-switches.  */\n-\n-static char *\n-gen_producer_string (void)\n-{\n-  size_t j;\n-  auto_vec<const char *> switches;\n-  const char *language_string = lang_hooks.name;\n-  char *producer, *tail;\n-  const char *p;\n-  size_t len = dwarf_record_gcc_switches ? 0 : 3;\n-  size_t plen = strlen (language_string) + 1 + strlen (version_string);\n-\n-  for (j = 1; dwarf_record_gcc_switches && j < save_decoded_options_count; j++)\n-    switch (save_decoded_options[j].opt_index)\n-      {\n-      case OPT_o:\n-      case OPT_d:\n-      case OPT_dumpbase:\n-      case OPT_dumpbase_ext:\n-      case OPT_dumpdir:\n-      case OPT_quiet:\n-      case OPT_version:\n-      case OPT_v:\n-      case OPT_w:\n-      case OPT_L:\n-      case OPT_D:\n-      case OPT_I:\n-      case OPT_U:\n-      case OPT_SPECIAL_unknown:\n-      case OPT_SPECIAL_ignore:\n-      case OPT_SPECIAL_warn_removed:\n-      case OPT_SPECIAL_program_name:\n-      case OPT_SPECIAL_input_file:\n-      case OPT_grecord_gcc_switches:\n-      case OPT__output_pch_:\n-      case OPT_fdiagnostics_show_location_:\n-      case OPT_fdiagnostics_show_option:\n-      case OPT_fdiagnostics_show_caret:\n-      case OPT_fdiagnostics_show_labels:\n-      case OPT_fdiagnostics_show_line_numbers:\n-      case OPT_fdiagnostics_color_:\n-      case OPT_fdiagnostics_format_:\n-      case OPT_fverbose_asm:\n-      case OPT____:\n-      case OPT__sysroot_:\n-      case OPT_nostdinc:\n-      case OPT_nostdinc__:\n-      case OPT_fpreprocessed:\n-      case OPT_fltrans_output_list_:\n-      case OPT_fresolution_:\n-      case OPT_fdebug_prefix_map_:\n-      case OPT_fmacro_prefix_map_:\n-      case OPT_ffile_prefix_map_:\n-      case OPT_fcompare_debug:\n-      case OPT_fchecking:\n-      case OPT_fchecking_:\n-\t/* Ignore these.  */\n-\tcontinue;\n-      case OPT_flto_:\n-\t{\n-\t  const char *lto_canonical = \"-flto\";\n-\t  switches.safe_push (lto_canonical);\n-\t  len += strlen (lto_canonical) + 1;\n-\t  break;\n-\t}\n-      default:\n-        if (cl_options[save_decoded_options[j].opt_index].flags\n-\t    & CL_NO_DWARF_RECORD)\n-\t  continue;\n-        gcc_checking_assert (save_decoded_options[j].canonical_option[0][0]\n-\t\t\t     == '-');\n-        switch (save_decoded_options[j].canonical_option[0][1])\n-\t  {\n-\t  case 'M':\n-\t  case 'i':\n-\t  case 'W':\n-\t    continue;\n-\t  case 'f':\n-\t    if (strncmp (save_decoded_options[j].canonical_option[0] + 2,\n-\t\t\t \"dump\", 4) == 0)\n-\t      continue;\n-\t    break;\n-\t  default:\n-\t    break;\n-\t  }\n-\tswitches.safe_push (save_decoded_options[j].orig_option_with_args_text);\n-\tlen += strlen (save_decoded_options[j].orig_option_with_args_text) + 1;\n-\tbreak;\n-      }\n-\n-  producer = XNEWVEC (char, plen + 1 + len + 1);\n-  tail = producer;\n-  sprintf (tail, \"%s %s\", language_string, version_string);\n-  tail += plen;\n-\n-  FOR_EACH_VEC_ELT (switches, j, p)\n-    {\n-      len = strlen (p);\n-      *tail = ' ';\n-      memcpy (tail + 1, p, len);\n-      tail += len + 1;\n-    }\n-\n-  *tail = '\\0';\n-  return producer;\n-}\n-\n /* Given a C and/or C++ language/version string return the \"highest\".\n    C++ is assumed to be \"higher\" than C in this case.  Used for merging\n    LTO translation unit languages.  */\n@@ -32157,7 +32048,14 @@ dwarf2out_early_finish (const char *filename)\n      header compilation, so always fill it with empty string initially\n      and overwrite only here.  */\n   dw_attr_node *producer = get_AT (comp_unit_die (), DW_AT_producer);\n-  producer_string = gen_producer_string ();\n+\n+  if (dwarf_record_gcc_switches)\n+    producer_string = gen_producer_string (lang_hooks.name,\n+\t\t\t\t\t   save_decoded_options,\n+\t\t\t\t\t   save_decoded_options_count);\n+  else\n+    producer_string = concat (lang_hooks.name, \" \", version_string, NULL);\n+\n   producer->dw_attr_val.v.val_str->refcount--;\n   producer->dw_attr_val.v.val_str = find_AT_string (producer_string);\n "}, {"sha": "3db08b3e4785214f9036e7b83c8f38b79fa62550", "filename": "gcc/opts.c", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7caa49706316e650fb67719e1a1bf3a35054b685/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7caa49706316e650fb67719e1a1bf3a35054b685/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=7caa49706316e650fb67719e1a1bf3a35054b685", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"spellcheck.h\"\n #include \"opt-suggestions.h\"\n #include \"diagnostic-color.h\"\n+#include \"version.h\"\n #include \"selftest.h\"\n \n static void set_Wstrict_aliasing (struct gcc_options *opts, int onoff);\n@@ -3266,6 +3267,124 @@ get_option_url (diagnostic_context *, int option_index)\n     return NULL;\n }\n \n+/* Return a heap allocated producer with command line options.  */\n+\n+char *\n+gen_command_line_string (cl_decoded_option *options,\n+\t\t\t unsigned int options_count)\n+{\n+  auto_vec<const char *> switches;\n+  char *options_string, *tail;\n+  const char *p;\n+  size_t len = 0;\n+\n+  for (unsigned i = 0; i < options_count; i++)\n+    switch (options[i].opt_index)\n+      {\n+      case OPT_o:\n+      case OPT_d:\n+      case OPT_dumpbase:\n+      case OPT_dumpdir:\n+      case OPT_quiet:\n+      case OPT_version:\n+      case OPT_v:\n+      case OPT_w:\n+      case OPT_L:\n+      case OPT_D:\n+      case OPT_I:\n+      case OPT_U:\n+      case OPT_SPECIAL_unknown:\n+      case OPT_SPECIAL_ignore:\n+      case OPT_SPECIAL_warn_removed:\n+      case OPT_SPECIAL_program_name:\n+      case OPT_SPECIAL_input_file:\n+      case OPT_grecord_gcc_switches:\n+      case OPT_frecord_gcc_switches:\n+      case OPT__output_pch_:\n+      case OPT_fdiagnostics_show_location_:\n+      case OPT_fdiagnostics_show_option:\n+      case OPT_fdiagnostics_show_caret:\n+      case OPT_fdiagnostics_show_labels:\n+      case OPT_fdiagnostics_show_line_numbers:\n+      case OPT_fdiagnostics_color_:\n+      case OPT_fdiagnostics_format_:\n+      case OPT_fverbose_asm:\n+      case OPT____:\n+      case OPT__sysroot_:\n+      case OPT_nostdinc:\n+      case OPT_nostdinc__:\n+      case OPT_fpreprocessed:\n+      case OPT_fltrans_output_list_:\n+      case OPT_fresolution_:\n+      case OPT_fdebug_prefix_map_:\n+      case OPT_fmacro_prefix_map_:\n+      case OPT_ffile_prefix_map_:\n+      case OPT_fcompare_debug:\n+      case OPT_fchecking:\n+      case OPT_fchecking_:\n+\t/* Ignore these.  */\n+\tcontinue;\n+      case OPT_flto_:\n+\t{\n+\t  const char *lto_canonical = \"-flto\";\n+\t  switches.safe_push (lto_canonical);\n+\t  len += strlen (lto_canonical) + 1;\n+\t  break;\n+\t}\n+      default:\n+\tif (cl_options[options[i].opt_index].flags\n+\t    & CL_NO_DWARF_RECORD)\n+\t  continue;\n+\tgcc_checking_assert (options[i].canonical_option[0][0] == '-');\n+\tswitch (options[i].canonical_option[0][1])\n+\t  {\n+\t  case 'M':\n+\t  case 'i':\n+\t  case 'W':\n+\t    continue;\n+\t  case 'f':\n+\t    if (strncmp (options[i].canonical_option[0] + 2,\n+\t\t\t \"dump\", 4) == 0)\n+\t      continue;\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n+\tswitches.safe_push (options[i].orig_option_with_args_text);\n+\tlen += strlen (options[i].orig_option_with_args_text) + 1;\n+\tbreak;\n+      }\n+\n+  options_string = XNEWVEC (char, len + 1);\n+  tail = options_string;\n+\n+  unsigned i;\n+  FOR_EACH_VEC_ELT (switches, i, p)\n+    {\n+      len = strlen (p);\n+      memcpy (tail, p, len);\n+      tail += len;\n+      if (i != switches.length () - 1)\n+\t{\n+\t  *tail = ' ';\n+\t  ++tail;\n+\t}\n+    }\n+\n+  *tail = '\\0';\n+  return options_string;\n+}\n+\n+/* Return a heap allocated producer string including command line options.  */\n+\n+char *\n+gen_producer_string (const char *language_string, cl_decoded_option *options,\n+\t\t     unsigned int options_count)\n+{\n+  return concat (language_string, \" \", version_string, \" \",\n+\t\t gen_command_line_string (options, options_count), NULL);\n+}\n+\n #if CHECKING_P\n \n namespace selftest {"}, {"sha": "b36c0d1875949c630babb2d1ea8b6453f37960f1", "filename": "gcc/opts.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7caa49706316e650fb67719e1a1bf3a35054b685/gcc%2Fopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7caa49706316e650fb67719e1a1bf3a35054b685/gcc%2Fopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.h?ref=7caa49706316e650fb67719e1a1bf3a35054b685", "patch": "@@ -482,6 +482,12 @@ extern void parse_options_from_collect_gcc_options (const char *, obstack *,\n \n extern void prepend_xassembler_to_collect_as_options (const char *, obstack *);\n \n+extern char *gen_command_line_string (cl_decoded_option *options,\n+\t\t\t\t      unsigned int options_count);\n+extern char *gen_producer_string (const char *language_string,\n+\t\t\t\t  cl_decoded_option *options,\n+\t\t\t\t  unsigned int options_count);\n+\n /* Set OPTION in OPTS to VALUE if the option is not set in OPTS_SET.  */\n \n #define SET_OPTION_IF_UNSET(OPTS, OPTS_SET, OPTION, VALUE) \\"}, {"sha": "acdc694d44cdd708a9f58d1b889daeb09b79fa8c", "filename": "gcc/target.def", "status": "modified", "additions": 2, "deletions": 36, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7caa49706316e650fb67719e1a1bf3a35054b685/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7caa49706316e650fb67719e1a1bf3a35054b685/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=7caa49706316e650fb67719e1a1bf3a35054b685", "patch": "@@ -757,49 +757,15 @@ directive to annotate @var{symbol} as used.  The Darwin target uses the\\n\\\n DEFHOOK\n (record_gcc_switches,\n  \"Provides the target with the ability to record the gcc command line\\n\\\n-switches that have been passed to the compiler, and options that are\\n\\\n-enabled.  The @var{type} argument specifies what is being recorded.\\n\\\n-It can take the following values:\\n\\\n-\\n\\\n-@table @gcctabopt\\n\\\n-@item SWITCH_TYPE_PASSED\\n\\\n-@var{text} is a command line switch that has been set by the user.\\n\\\n-\\n\\\n-@item SWITCH_TYPE_ENABLED\\n\\\n-@var{text} is an option which has been enabled.  This might be as a\\n\\\n-direct result of a command line switch, or because it is enabled by\\n\\\n-default or because it has been enabled as a side effect of a different\\n\\\n-command line switch.  For example, the @option{-O2} switch enables\\n\\\n-various different individual optimization passes.\\n\\\n-\\n\\\n-@item SWITCH_TYPE_DESCRIPTIVE\\n\\\n-@var{text} is either NULL or some descriptive text which should be\\n\\\n-ignored.  If @var{text} is NULL then it is being used to warn the\\n\\\n-target hook that either recording is starting or ending.  The first\\n\\\n-time @var{type} is SWITCH_TYPE_DESCRIPTIVE and @var{text} is NULL, the\\n\\\n-warning is for start up and the second time the warning is for\\n\\\n-wind down.  This feature is to allow the target hook to make any\\n\\\n-necessary preparations before it starts to record switches and to\\n\\\n-perform any necessary tidying up after it has finished recording\\n\\\n-switches.\\n\\\n-\\n\\\n-@item SWITCH_TYPE_LINE_START\\n\\\n-This option can be ignored by this target hook.\\n\\\n-\\n\\\n-@item  SWITCH_TYPE_LINE_END\\n\\\n-This option can be ignored by this target hook.\\n\\\n-@end table\\n\\\n-\\n\\\n-The hook's return value must be zero.  Other return values may be\\n\\\n-supported in the future.\\n\\\n+switches provided as argument.\\n\\\n \\n\\\n By default this hook is set to NULL, but an example implementation is\\n\\\n provided for ELF based targets.  Called @var{elf_record_gcc_switches},\\n\\\n it records the switches as ASCII text inside a new, string mergeable\\n\\\n section in the assembler output file.  The name of the new section is\\n\\\n provided by the @code{TARGET_ASM_RECORD_GCC_SWITCHES_SECTION} target\\n\\\n hook.\",\n- int, (print_switch_type type, const char *text),\n+ void, (const char *),\n  NULL)\n \n /* The name of the section that the example ELF implementation of"}, {"sha": "960188023f13a8e9baa482349fa2b23cc92fef52", "filename": "gcc/target.h", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7caa49706316e650fb67719e1a1bf3a35054b685/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7caa49706316e650fb67719e1a1bf3a35054b685/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=7caa49706316e650fb67719e1a1bf3a35054b685", "patch": "@@ -68,16 +68,6 @@ union cumulative_args_t { void *p; };\n \n #endif /* !CHECKING_P */\n \n-/* Types used by the record_gcc_switches() target function.  */\n-enum print_switch_type\n-{\n-  SWITCH_TYPE_PASSED,\t\t/* A switch passed on the command line.  */\n-  SWITCH_TYPE_ENABLED,\t\t/* An option that is currently enabled.  */\n-  SWITCH_TYPE_DESCRIPTIVE,\t/* Descriptive text, not a switch or option.  */\n-  SWITCH_TYPE_LINE_START,\t/* Please emit any necessary text at the start of a line.  */\n-  SWITCH_TYPE_LINE_END\t\t/* Please emit a line terminator.  */\n-};\n-\n /* Types of memory operation understood by the \"by_pieces\" infrastructure.\n    Used by the TARGET_USE_BY_PIECES_INFRASTRUCTURE_P target hook and\n    internally by the functions in expr.c.  */\n@@ -96,10 +86,8 @@ extern unsigned HOST_WIDE_INT by_pieces_ninsns (unsigned HOST_WIDE_INT,\n \t\t\t\t\t\tunsigned int,\n \t\t\t\t\t\tby_pieces_operation);\n \n-typedef int (* print_switch_fn_type) (print_switch_type, const char *);\n-\n /* An example implementation for ELF targets.  Defined in varasm.c  */\n-extern int elf_record_gcc_switches (print_switch_type type, const char *);\n+extern void elf_record_gcc_switches (const char *);\n \n /* Some places still assume that all pointer or address modes are the\n    standard Pmode and ptr_mode.  These optimizations become invalid if"}, {"sha": "93a41943b8c0520b6e2d15cdd1c553795414c73e", "filename": "gcc/toplev.c", "status": "modified", "additions": 18, "deletions": 158, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7caa49706316e650fb67719e1a1bf3a35054b685/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7caa49706316e650fb67719e1a1bf3a35054b685/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=7caa49706316e650fb67719e1a1bf3a35054b685", "patch": "@@ -116,9 +116,6 @@ static void compile_file (void);\n /* True if we don't need a backend (e.g. preprocessing only).  */\n static bool no_backend;\n \n-/* Length of line when printing switch values.  */\n-#define MAX_LINE 75\n-\n /* Decoded options, and number of such options.  */\n struct cl_decoded_option *save_decoded_options;\n unsigned int save_decoded_options_count;\n@@ -687,148 +684,7 @@ print_version (FILE *file, const char *indent, bool show_global_state)\n     }\n }\n \n-static int\n-print_to_asm_out_file (print_switch_type type, const char * text)\n-{\n-  bool prepend_sep = true;\n-\n-  switch (type)\n-    {\n-    case SWITCH_TYPE_LINE_END:\n-      putc ('\\n', asm_out_file);\n-      return 1;\n-\n-    case SWITCH_TYPE_LINE_START:\n-      fputs (ASM_COMMENT_START, asm_out_file);\n-      return strlen (ASM_COMMENT_START);\n-\n-    case SWITCH_TYPE_DESCRIPTIVE:\n-      if (ASM_COMMENT_START[0] == 0)\n-\tprepend_sep = false;\n-      /* FALLTHRU */\n-    case SWITCH_TYPE_PASSED:\n-    case SWITCH_TYPE_ENABLED:\n-      if (prepend_sep)\n-\tfputc (' ', asm_out_file);\n-      fputs (text, asm_out_file);\n-      /* No need to return the length here as\n-\t print_single_switch has already done it.  */\n-      return 0;\n-\n-    default:\n-      return -1;\n-    }\n-}\n-\n-static int\n-print_to_stderr (print_switch_type type, const char * text)\n-{\n-  switch (type)\n-    {\n-    case SWITCH_TYPE_LINE_END:\n-      putc ('\\n', stderr);\n-      return 1;\n-\n-    case SWITCH_TYPE_LINE_START:\n-      return 0;\n-\n-    case SWITCH_TYPE_PASSED:\n-    case SWITCH_TYPE_ENABLED:\n-      fputc (' ', stderr);\n-      /* FALLTHRU */\n-\n-    case SWITCH_TYPE_DESCRIPTIVE:\n-      fputs (text, stderr);\n-      /* No need to return the length here as\n-\t print_single_switch has already done it.  */\n-      return 0;\n-\n-    default:\n-      return -1;\n-    }\n-}\n-\n-/* Print an option value and return the adjusted position in the line.\n-   ??? print_fn doesn't handle errors, eg disk full; presumably other\n-   code will catch a disk full though.  */\n-\n-static int\n-print_single_switch (print_switch_fn_type print_fn,\n-\t\t     int pos,\n-\t\t     print_switch_type type,\n-\t\t     const char * text)\n-{\n-  /* The ultrix fprintf returns 0 on success, so compute the result\n-     we want here since we need it for the following test.  The +1\n-     is for the separator character that will probably be emitted.  */\n-  int len = strlen (text) + 1;\n-\n-  if (pos != 0\n-      && pos + len > MAX_LINE)\n-    {\n-      print_fn (SWITCH_TYPE_LINE_END, NULL);\n-      pos = 0;\n-    }\n-\n-  if (pos == 0)\n-    pos += print_fn (SWITCH_TYPE_LINE_START, NULL);\n-\n-  print_fn (type, text);\n-  return pos + len;\n-}\n-\n-/* Print active target switches using PRINT_FN.\n-   POS is the current cursor position and MAX is the size of a \"line\".\n-   Each line begins with INDENT and ends with TERM.\n-   Each switch is separated from the next by SEP.  */\n \n-static void\n-print_switch_values (print_switch_fn_type print_fn)\n-{\n-  int pos = 0;\n-  size_t j;\n-\n-  /* Print the options as passed.  */\n-  pos = print_single_switch (print_fn, pos,\n-\t\t\t     SWITCH_TYPE_DESCRIPTIVE, _(\"options passed: \"));\n-\n-  for (j = 1; j < save_decoded_options_count; j++)\n-    {\n-      switch (save_decoded_options[j].opt_index)\n-\t{\n-\tcase OPT_o:\n-\tcase OPT_d:\n-\tcase OPT_dumpbase:\n-\tcase OPT_dumpbase_ext:\n-\tcase OPT_dumpdir:\n-\tcase OPT_quiet:\n-\tcase OPT_version:\n-\t  /* Ignore these.  */\n-\t  continue;\n-\t}\n-\n-      pos = print_single_switch (print_fn, pos, SWITCH_TYPE_PASSED,\n-\t\t\t\t save_decoded_options[j].orig_option_with_args_text);\n-    }\n-\n-  if (pos > 0)\n-    print_fn (SWITCH_TYPE_LINE_END, NULL);\n-\n-  /* Print the -f and -m options that have been enabled.\n-     We don't handle language specific options but printing argv\n-     should suffice.  */\n-  pos = print_single_switch (print_fn, 0,\n-\t\t\t     SWITCH_TYPE_DESCRIPTIVE, _(\"options enabled: \"));\n-\n-  unsigned lang_mask = lang_hooks.option_lang_mask ();\n-  for (j = 0; j < cl_options_count; j++)\n-    if (cl_options[j].cl_report\n-\t&& option_enabled (j, lang_mask, &global_options) > 0)\n-      pos = print_single_switch (print_fn, pos,\n-\t\t\t\t SWITCH_TYPE_ENABLED, cl_options[j].opt_text);\n-\n-  print_fn (SWITCH_TYPE_LINE_END, NULL);\n-}\n \n /* Open assembly code output file.  Do this even if -fsyntax-only is\n    on, because then the driver will have provided the name of a\n@@ -875,14 +731,11 @@ init_asm_output (const char *name)\n \t{\n \t  if (targetm.asm_out.record_gcc_switches)\n \t    {\n-\t      /* Let the target know that we are about to start recording.  */\n-\t      targetm.asm_out.record_gcc_switches (SWITCH_TYPE_DESCRIPTIVE,\n-\t\t\t\t\t\t   NULL);\n-\t      /* Now record the switches.  */\n-\t      print_switch_values (targetm.asm_out.record_gcc_switches);\n-\t      /* Let the target know that the recording is over.  */\n-\t      targetm.asm_out.record_gcc_switches (SWITCH_TYPE_DESCRIPTIVE,\n-\t\t\t\t\t\t   NULL);\n+\t      const char *str\n+\t\t= gen_producer_string (lang_hooks.name,\n+\t\t\t\t       save_decoded_options,\n+\t\t\t\t       save_decoded_options_count);\n+\t      targetm.asm_out.record_gcc_switches (str);\n \t    }\n \t  else\n \t    inform (UNKNOWN_LOCATION,\n@@ -892,11 +745,13 @@ init_asm_output (const char *name)\n \n       if (flag_verbose_asm)\n \t{\n-\t  /* Print the list of switches in effect\n-\t     into the assembler file as comments.  */\n \t  print_version (asm_out_file, ASM_COMMENT_START, true);\n-\t  print_switch_values (print_to_asm_out_file);\n-\t  putc ('\\n', asm_out_file);\n+\t  fputs (ASM_COMMENT_START, asm_out_file);\n+\t  fputs (\" options passed: \", asm_out_file);\n+\t  fputs (gen_command_line_string (save_decoded_options,\n+\t\t\t\t\t  save_decoded_options_count),\n+\t\t asm_out_file);\n+\t  fputc ('\\n', asm_out_file);\n \t}\n     }\n }\n@@ -1526,8 +1381,13 @@ process_options (void)\n   if (version_flag)\n     {\n       print_version (stderr, \"\", true);\n-      if (! quiet_flag)\n-\tprint_switch_values (print_to_stderr);\n+      if (!quiet_flag)\n+\t{\n+\t  fputs (\"options passed: \", stderr);\n+\t  fputs (gen_command_line_string (save_decoded_options,\n+\t\t\t\t\t  save_decoded_options_count), stderr);\n+\t  fputc ('\\n', stderr);\n+\t}\n     }\n \n   if (flag_syntax_only)"}, {"sha": "0fac36888287f07624a6f244a4d9cc48c40efecc", "filename": "gcc/varasm.c", "status": "modified", "additions": 10, "deletions": 38, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7caa49706316e650fb67719e1a1bf3a35054b685/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7caa49706316e650fb67719e1a1bf3a35054b685/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=7caa49706316e650fb67719e1a1bf3a35054b685", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"fold-const.h\"\n #include \"stor-layout.h\"\n #include \"varasm.h\"\n+#include \"version.h\"\n #include \"flags.h\"\n #include \"stmt.h\"\n #include \"expr.h\"\n@@ -58,6 +59,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtl-iter.h\"\n #include \"file-prefix-map.h\" /* remap_debug_filename()  */\n #include \"alloc-pool.h\"\n+#include \"toplev.h\"\n+#include \"opts.h\"\n \n #ifdef XCOFF_DEBUGGING_INFO\n #include \"xcoffout.h\"\t\t/* Needed for external data declarations.  */\n@@ -8053,45 +8056,14 @@ output_object_blocks (void)\n    we want to emit NUL strings terminators into the object file we have to use\n    ASM_OUTPUT_SKIP.  */\n \n-int\n-elf_record_gcc_switches (print_switch_type type, const char * name)\n+void\n+elf_record_gcc_switches (const char *options)\n {\n-  switch (type)\n-    {\n-    case SWITCH_TYPE_PASSED:\n-      ASM_OUTPUT_ASCII (asm_out_file, name, strlen (name));\n-      ASM_OUTPUT_SKIP (asm_out_file, HOST_WIDE_INT_1U);\n-      break;\n-\n-    case SWITCH_TYPE_DESCRIPTIVE:\n-      if (name == NULL)\n-\t{\n-\t  /* Distinguish between invocations where name is NULL.  */\n-\t  static bool started = false;\n-\n-\t  if (!started)\n-\t    {\n-\t      section * sec;\n-\n-\t      sec = get_section (targetm.asm_out.record_gcc_switches_section,\n-\t\t\t\t SECTION_DEBUG\n-\t\t\t\t | SECTION_MERGE\n-\t\t\t\t | SECTION_STRINGS\n-\t\t\t\t | (SECTION_ENTSIZE & 1),\n-\t\t\t\t NULL);\n-\t      switch_to_section (sec);\n-\t      started = true;\n-\t    }\n-\t}\n-\n-    default:\n-      break;\n-    }\n-\n-  /* The return value is currently ignored by the caller, but must be 0.\n-     For -fverbose-asm the return value would be the number of characters\n-     emitted into the assembler file.  */\n-  return 0;\n+  section *sec = get_section (targetm.asm_out.record_gcc_switches_section,\n+\t\t\t      SECTION_DEBUG | SECTION_MERGE\n+\t\t\t      | SECTION_STRINGS | (SECTION_ENTSIZE & 1), NULL);\n+  switch_to_section (sec);\n+  ASM_OUTPUT_ASCII (asm_out_file, options, strlen (options) + 1);\n }\n \n /* Emit text to declare externally defined symbols. It is needed to"}]}