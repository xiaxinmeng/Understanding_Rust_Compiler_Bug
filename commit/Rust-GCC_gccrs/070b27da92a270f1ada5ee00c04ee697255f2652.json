{"sha": "070b27da92a270f1ada5ee00c04ee697255f2652", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDcwYjI3ZGE5MmEyNzBmMWFkYTVlZTAwYzA0ZWU2OTcyNTVmMjY1Mg==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2010-06-15T07:33:43Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2010-06-15T07:33:43Z"}, "message": "invoke.texi: Add mcmodel to powerpc options.\n\n\t* doc/invoke.texi: Add mcmodel to powerpc options.\n\t* configure.ac: Add HAVE_LD_LARGE_TOC test.\n\t* configure: Regenerate.\n\t* config.in: Regenerate.\n\t* config/rs6000/linux64.opt (mcmodel): New.\n\t* config/rs6000/linux64.h (TARGET_USES_LINUX64_OPT): Define.\n\t(TARGET_CMODEL): Define.\n\t(SUBSUBTARGET_OVERRIDE_OPTIONS): Check user -mcmodel choice,\n\tselect CMODEL_MEDIUM default.\n\t* config/rs6000/rs6000.h (enum rs6000_cmodel): New.\n\t(TARGET_CMODEL): Define default.\n\t* config/rs6000/rs6000.c (cmodel): New variable.\n\t(rs6000_explicit_options): Add cmodel field.\n\t(rs6000_handle_option): Handle -mcmodel.\n\t(create_TOC_reference): Add largetoc_reg param.  Generate high,\n\tlo_sum rtl for CMODEL_MEDIUM and CMODEL_LARGE.  Update all callers.\n\t(rs6000_delegitimize_address): Recognise new toc reference rtl\n\tand minimal-toc rtl.\n\t(rs6000_legitimize_reload_address): Handle new toc references.\n\t(print_operand_address): Handle legitimate_constant_pool_address_p\n\tmatch before lo_sum.\n\t(rs6000_eliminate_indexed_memrefs): Tidy.\n\t(rs6000_emit_move): Tweak threshold for inlining constants.\n\tKeep rs6000_emit_allocate_stack large stack frame offsets\n\tloaded into r0 inline.\n\t(rs6000_generate_compare <cmptf_internal2>): One more clobber.\n\t(tocrel_base, tocrel_offset): New variables.\n\t(toc_relative_expr_p): Set them here.\n\t(print_operand_address): Skip over any offset on constant pool\n\taddress.\n\t(rs6000_output_addr_const_extra): Print tocrel_offset before @toc.\n\t(rs6000_mode_dependent_address <LO_SUM>): False for new toc refs.\n\t(offsettable_ok_by_alignment): New function.\n\t(rs6000_emit_move): Address suitably aligned local symbol_refs\n\trelative to the toc pointer for -mcmodel=medium.\n\t(legitimate_constant_pool_address_p): Make param const_rtx.  Add\n\tstrict param.  Allow lo_sum version of addressing.  Verify reg\n\tused for -mminimal-toc and -mcmodel != small.  Update all callers.\n\t* config/rs6000/constraints.md: Update for above change.\n\t* config/rs6000/predicates.md: Likewise.\n\t* config/rs6000/rs6000.md (tls_gd_aix): Generate -mcmodel=medium/large\n\tcode.\n\t(tls_gd): Split for -mcmodel=medium/large.\n\t(tls_gd_high, tls_gd_low): New.\n\t(tls_ld_aix, tls_ld, tls_ld_high, tls_ld_low): Similarly.\n\t(tls_got_dtprel, tls_got_dtprel_high, tls_got_dtprel_low): Similarly.\n\t(tls_got_tprel, tls_got_tprel_high, tls_got_tprel_low): Similarly.\n\t(largetoc_high, largetoc_low): New.\n\t(cmptf_internal2): Add clobber.\n\t* config/rs6000/rs6000-protos.h: Update.\n\nFrom-SVN: r160773", "tree": {"sha": "5c65b177818e2b8c73663e18852b25e829aa44c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c65b177818e2b8c73663e18852b25e829aa44c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/070b27da92a270f1ada5ee00c04ee697255f2652", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/070b27da92a270f1ada5ee00c04ee697255f2652", "html_url": "https://github.com/Rust-GCC/gccrs/commit/070b27da92a270f1ada5ee00c04ee697255f2652", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/070b27da92a270f1ada5ee00c04ee697255f2652/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "309b8e7dd612d4acda9f685ec5b9ea6a867cf0ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/309b8e7dd612d4acda9f685ec5b9ea6a867cf0ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/309b8e7dd612d4acda9f685ec5b9ea6a867cf0ed"}], "stats": {"total": 666, "additions": 583, "deletions": 83}, "files": [{"sha": "b623f3b0a7dac6912d085bd35c0c16e8f225dba8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=070b27da92a270f1ada5ee00c04ee697255f2652", "patch": "@@ -1,3 +1,56 @@\n+2010-06-15  Alan Modra  <amodra@gmail.com>\n+\n+\t* doc/invoke.texi: Add mcmodel to powerpc options.\n+\t* configure.ac: Add HAVE_LD_LARGE_TOC test.\n+\t* configure: Regenerate.\n+\t* config.in: Regenerate.\n+\t* config/rs6000/linux64.opt (mcmodel): New.\n+\t* config/rs6000/linux64.h (TARGET_USES_LINUX64_OPT): Define.\n+\t(TARGET_CMODEL): Define.\n+\t(SUBSUBTARGET_OVERRIDE_OPTIONS): Check user -mcmodel choice,\n+\tselect CMODEL_MEDIUM default.\n+\t* config/rs6000/rs6000.h (enum rs6000_cmodel): New.\n+\t(TARGET_CMODEL): Define default.\n+\t* config/rs6000/rs6000.c (cmodel): New variable.\n+\t(rs6000_explicit_options): Add cmodel field.\n+\t(rs6000_handle_option): Handle -mcmodel.\n+\t(create_TOC_reference): Add largetoc_reg param.  Generate high,\n+\tlo_sum rtl for CMODEL_MEDIUM and CMODEL_LARGE.  Update all callers.\n+\t(rs6000_delegitimize_address): Recognise new toc reference rtl\n+\tand minimal-toc rtl.\n+\t(rs6000_legitimize_reload_address): Handle new toc references.\n+\t(print_operand_address): Handle legitimate_constant_pool_address_p\n+\tmatch before lo_sum.\n+\t(rs6000_eliminate_indexed_memrefs): Tidy.\n+\t(rs6000_emit_move): Tweak threshold for inlining constants.\n+\tKeep rs6000_emit_allocate_stack large stack frame offsets\n+\tloaded into r0 inline.\n+\t(rs6000_generate_compare <cmptf_internal2>): One more clobber.\n+\t(tocrel_base, tocrel_offset): New variables.\n+\t(toc_relative_expr_p): Set them here.\n+\t(print_operand_address): Skip over any offset on constant pool\n+\taddress.\n+\t(rs6000_output_addr_const_extra): Print tocrel_offset before @toc.\n+\t(rs6000_mode_dependent_address <LO_SUM>): False for new toc refs.\n+\t(offsettable_ok_by_alignment): New function.\n+\t(rs6000_emit_move): Address suitably aligned local symbol_refs\n+\trelative to the toc pointer for -mcmodel=medium.\n+\t(legitimate_constant_pool_address_p): Make param const_rtx.  Add\n+\tstrict param.  Allow lo_sum version of addressing.  Verify reg\n+\tused for -mminimal-toc and -mcmodel != small.  Update all callers.\n+\t* config/rs6000/constraints.md: Update for above change.\n+\t* config/rs6000/predicates.md: Likewise.\n+\t* config/rs6000/rs6000.md (tls_gd_aix): Generate -mcmodel=medium/large\n+\tcode.\n+\t(tls_gd): Split for -mcmodel=medium/large.\n+\t(tls_gd_high, tls_gd_low): New.\n+\t(tls_ld_aix, tls_ld, tls_ld_high, tls_ld_low): Similarly.\n+\t(tls_got_dtprel, tls_got_dtprel_high, tls_got_dtprel_low): Similarly.\n+\t(tls_got_tprel, tls_got_tprel_high, tls_got_tprel_low): Similarly.\n+\t(largetoc_high, largetoc_low): New.\n+\t(cmptf_internal2): Add clobber.\n+\t* config/rs6000/rs6000-protos.h: Update.\n+\n 2010-06-14  Changpeng Fang  <changpeng.fang@amd.com>\n \n \t* tree-ssa-loop-prefetch.c (nothing_to_prefetch_p): New.  Return"}, {"sha": "35d406d187265be8a42135b1ab54bf2bc5541623", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=070b27da92a270f1ada5ee00c04ee697255f2652", "patch": "@@ -1168,6 +1168,12 @@\n #endif\n \n \n+/* Define if your PowerPC64 linker supports a large TOC. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_LD_LARGE_TOC\n+#endif\n+\n+\n /* Define if your PowerPC64 linker only needs function descriptor syms. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_LD_NO_DOT_SYMS"}, {"sha": "7eb991a326f32f70ad1a60673a8a87b2b93aa9e0", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=070b27da92a270f1ada5ee00c04ee697255f2652", "patch": "@@ -166,7 +166,7 @@ usually better to use @samp{m} or @samp{es} in @code{asm} statements)\"\n \n (define_constraint \"R\"\n   \"AIX TOC entry\"\n-  (match_test \"legitimate_constant_pool_address_p (op)\"))\n+  (match_test \"legitimate_constant_pool_address_p (op, false)\"))\n \n ;; General constraints\n "}, {"sha": "d787d297db5810dcaed22ba2a0ce4aa5bd9e425c", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=070b27da92a270f1ada5ee00c04ee697255f2652", "patch": "@@ -63,6 +63,16 @@ extern int dot_symbols;\n \n #define TARGET_PROFILE_KERNEL profile_kernel\n \n+#define TARGET_USES_LINUX64_OPT 1\n+#ifdef HAVE_LD_LARGE_TOC\n+extern enum rs6000_cmodel cmodel;\n+#undef TARGET_CMODEL\n+#define TARGET_CMODEL cmodel\n+#define SET_CMODEL(opt) cmodel = opt\n+#else\n+#define SET_CMODEL(opt)\n+#endif\n+\n #undef  PROCESSOR_DEFAULT\n #define PROCESSOR_DEFAULT PROCESSOR_POWER6\n #undef  PROCESSOR_DEFAULT64\n@@ -114,6 +124,23 @@ extern int dot_symbols;\n \t      target_flags |= MASK_POWERPC64;\t\t\t\\\n \t      error (\"-m64 requires a PowerPC64 cpu\");\t\t\\\n \t    }\t\t\t\t\t\t\t\\\n+\t  if ((target_flags_explicit & MASK_MINIMAL_TOC) != 0)\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      if (rs6000_explicit_options.cmodel\t\t\\\n+\t\t  && cmodel != CMODEL_SMALL)\t\t\t\\\n+\t\terror (\"-mcmodel incompatible with other toc options\"); \\\n+\t      SET_CMODEL (CMODEL_SMALL);\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      if (!rs6000_explicit_options.cmodel)\t\t\\\n+\t\tSET_CMODEL (CMODEL_MEDIUM);\t\t\t\\\n+\t      if (cmodel != CMODEL_SMALL)\t\t\t\\\n+\t\t{\t\t\t\t\t\t\\\n+\t\t  TARGET_NO_FP_IN_TOC = 0;\t\t\t\\\n+\t\t  TARGET_NO_SUM_IN_TOC = 0;\t\t\t\\\n+\t\t}\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\\\n@@ -124,6 +151,11 @@ extern int dot_symbols;\n \t      TARGET_PROFILE_KERNEL = 0;\t\t\t\\\n \t      error (INVALID_32BIT, \"profile-kernel\");\t\t\\\n \t    }\t\t\t\t\t\t\t\\\n+\t  if (rs6000_explicit_options.cmodel)\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      SET_CMODEL (CMODEL_SMALL);\t\t\t\\\n+\t      error (INVALID_32BIT, \"cmodel\");\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   while (0)"}, {"sha": "9d0e26ace33214a7f2c0370214896dae8c676632", "filename": "gcc/config/rs6000/linux64.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfig%2Frs6000%2Flinux64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfig%2Frs6000%2Flinux64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.opt?ref=070b27da92a270f1ada5ee00c04ee697255f2652", "patch": "@@ -22,3 +22,7 @@\n mprofile-kernel\n Target Report Var(profile_kernel)\n Call mcount for profiling before a function prologue\n+\n+mcmodel=\n+Target RejectNegative Joined\n+Select code model"}, {"sha": "c94af469fcd595d837683864b4739a28f856e041", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=070b27da92a270f1ada5ee00c04ee697255f2652", "patch": "@@ -837,7 +837,7 @@\n     return 1;\n \n   /* A SYMBOL_REF referring to the TOC is valid.  */\n-  if (legitimate_constant_pool_address_p (op))\n+  if (legitimate_constant_pool_address_p (op, false))\n     return 1;\n \n   /* A constant pool expression (relative to the TOC) is valid */"}, {"sha": "9e978bdae8941b3da74c3bc17a114b1cea23c12d", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=070b27da92a270f1ada5ee00c04ee697255f2652", "patch": "@@ -39,7 +39,7 @@ extern int small_data_operand (rtx, enum machine_mode);\n extern bool toc_relative_expr_p (rtx);\n extern bool invalid_e500_subreg (rtx, enum machine_mode);\n extern void validate_condition_mode (enum rtx_code, enum machine_mode);\n-extern bool legitimate_constant_pool_address_p (rtx);\n+extern bool legitimate_constant_pool_address_p (const_rtx, bool);\n extern bool legitimate_indirect_address_p (rtx, int);\n extern bool legitimate_indexed_address_p (rtx, int);\n extern bool avoiding_indexed_address_p (enum machine_mode);\n@@ -111,7 +111,7 @@ extern void rs6000_emit_swrsqrt (rtx, rtx);\n extern void output_toc (FILE *, rtx, int, enum machine_mode);\n extern rtx rs6000_longcall_ref (rtx);\n extern void rs6000_fatal_bad_address (rtx);\n-extern rtx create_TOC_reference (rtx);\n+extern rtx create_TOC_reference (rtx, rtx);\n extern void rs6000_split_multireg_move (rtx, rtx);\n extern void rs6000_emit_move (rtx, rtx, enum machine_mode);\n extern rtx rs6000_secondary_memory_needed_rtx (enum machine_mode);"}, {"sha": "863e7fa225cdc574bb35ac0b22f4ee9a323aa0f5", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 191, "deletions": 53, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=070b27da92a270f1ada5ee00c04ee697255f2652", "patch": "@@ -279,6 +279,9 @@ static GTY(()) section *toc_section;\n /* String from -malign-XXXXX.  */\n int rs6000_alignment_flags;\n \n+/* Code model for 64-bit linux.  */\n+enum rs6000_cmodel cmodel;\n+\n /* True for any options that were explicitly set.  */\n static struct {\n   bool aix_struct_ret;\t\t/* True if -maix-struct-ret was used.  */\n@@ -290,6 +293,7 @@ static struct {\n   bool long_double;\t        /* True if -mlong-double- was used.  */\n   bool ieee;\t\t\t/* True if -mabi=ieee/ibmlongdouble used.  */\n   bool vrsave;\t\t\t/* True if -mvrsave was used.  */\n+  bool cmodel;\t\t\t/* True if -mcmodel was used.  */\n } rs6000_explicit_options;\n \n struct builtin_description\n@@ -3645,6 +3649,22 @@ rs6000_handle_option (size_t code, const char *arg, int value)\n       break;\n #endif\n \n+#if defined (HAVE_LD_LARGE_TOC) && defined (TARGET_USES_LINUX64_OPT)\n+    case OPT_mcmodel_:\n+      if (strcmp (arg, \"small\") == 0)\n+\tcmodel = CMODEL_SMALL;\n+      else if (strcmp (arg, \"medium\") == 0)\n+\tcmodel = CMODEL_MEDIUM;\n+      else if (strcmp (arg, \"large\") == 0)\n+\tcmodel = CMODEL_LARGE;\n+      else\n+\t{\n+\t  error (\"invalid option for -mcmodel: '%s'\", arg);\n+\t  return false;\n+\t}\n+      rs6000_explicit_options.cmodel = true;\n+#endif\n+\n #ifdef TARGET_USES_AIX64_OPT\n     case OPT_maix64:\n #else\n@@ -5098,26 +5118,29 @@ constant_pool_expr_p (rtx op)\n \t  && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (base), Pmode));\n }\n \n+static rtx tocrel_base, tocrel_offset;\n+\n bool\n toc_relative_expr_p (rtx op)\n {\n-  rtx base, offset;\n-\n   if (GET_CODE (op) != CONST)\n     return false;\n \n-  split_const (op, &base, &offset);\n-  return (GET_CODE (base) == UNSPEC\n-\t  && XINT (base, 1) == UNSPEC_TOCREL);\n+  split_const (op, &tocrel_base, &tocrel_offset);\n+  return (GET_CODE (tocrel_base) == UNSPEC\n+\t  && XINT (tocrel_base, 1) == UNSPEC_TOCREL);\n }\n \n bool\n-legitimate_constant_pool_address_p (rtx x)\n+legitimate_constant_pool_address_p (const_rtx x, bool strict)\n {\n   return (TARGET_TOC\n-\t  && GET_CODE (x) == PLUS\n+\t  && (GET_CODE (x) == PLUS || GET_CODE (x) == LO_SUM)\n \t  && GET_CODE (XEXP (x, 0)) == REG\n-\t  && (TARGET_MINIMAL_TOC || REGNO (XEXP (x, 0)) == TOC_REGISTER)\n+\t  && (REGNO (XEXP (x, 0)) == TOC_REGISTER\n+\t      || ((TARGET_MINIMAL_TOC\n+\t\t   || TARGET_CMODEL != CMODEL_SMALL)\n+\t\t  && INT_REG_OK_FOR_BASE_P (XEXP (x, 0), strict)))\n \t  && toc_relative_expr_p (XEXP (x, 1)));\n }\n \n@@ -5146,7 +5169,7 @@ rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x, int strict)\n     return false;\n   if (!reg_offset_addressing_ok_p (mode))\n     return virtual_stack_registers_memory_p (x);\n-  if (legitimate_constant_pool_address_p (x))\n+  if (legitimate_constant_pool_address_p (x, strict))\n     return true;\n   if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n     return false;\n@@ -5494,7 +5517,8 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t   && constant_pool_expr_p (x)\n \t   && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (x), Pmode))\n     {\n-      return create_TOC_reference (x);\n+      rtx reg = TARGET_CMODEL != CMODEL_SMALL ? gen_reg_rtx (Pmode) : NULL_RTX;\n+      return create_TOC_reference (x, reg);\n     }\n   else\n     return x;\n@@ -5585,10 +5609,13 @@ rs6000_delegitimize_address (rtx orig_x)\n   if (MEM_P (x))\n     x = XEXP (x, 0);\n \n-  if (GET_CODE (x) == PLUS\n-      && GET_CODE (XEXP (x, 1)) == CONST\n+  if ((GET_CODE (x) == PLUS\n+       || GET_CODE (x) == LO_SUM)\n       && GET_CODE (XEXP (x, 0)) == REG\n-      && REGNO (XEXP (x, 0)) == TOC_REGISTER)\n+      && (REGNO (XEXP (x, 0)) == TOC_REGISTER\n+\t  || TARGET_MINIMAL_TOC\n+\t  || TARGET_CMODEL != CMODEL_SMALL)\n+      && GET_CODE (XEXP (x, 1)) == CONST)\n     {\n       y = XEXP (XEXP (x, 1), 0);\n       if (GET_CODE (y) == UNSPEC\n@@ -5600,7 +5627,6 @@ rs6000_delegitimize_address (rtx orig_x)\n \t  else\n \t    return replace_equiv_address_nv (orig_x, y);\n \t}\n-      return orig_x;\n     }\n \n   if (TARGET_MACHO\n@@ -5896,6 +5922,24 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n     }\n #endif\n \n+  if (TARGET_CMODEL != CMODEL_SMALL\n+      && GET_CODE (x) == LO_SUM\n+      && GET_CODE (XEXP (x, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n+      && REGNO (XEXP (XEXP (x, 0), 0)) == TOC_REGISTER\n+      && GET_CODE (XEXP (XEXP (x, 0), 1)) == HIGH\n+      && GET_CODE (XEXP (x, 1)) == CONST\n+      && GET_CODE (XEXP (XEXP (x, 1), 0)) == UNSPEC\n+      && XINT (XEXP (XEXP (x, 1), 0), 1) == UNSPEC_TOCREL\n+      && rtx_equal_p (XEXP (XEXP (XEXP (x, 0), 1), 0), XEXP (x, 1)))\n+    {\n+      push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n+\t\t   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n+\t\t   opnum, (enum reload_type) type);\n+      *win = 1;\n+      return x;\n+    }\n+\n   /* Force ld/std non-word aligned offset into base register by wrapping\n      in offset 0.  */\n   if (GET_CODE (x) == PLUS\n@@ -6021,7 +6065,11 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n       && constant_pool_expr_p (x)\n       && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (x), mode))\n     {\n-      x = create_TOC_reference (x);\n+      x = create_TOC_reference (x, NULL_RTX);\n+      if (TARGET_CMODEL != CMODEL_SMALL)\n+\tpush_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n+\t\t     BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n+\t\t     opnum, (enum reload_type) type);\n       *win = 1;\n       return x;\n     }\n@@ -6104,7 +6152,7 @@ rs6000_legitimate_address_p (enum machine_mode mode, rtx x, bool reg_ok_strict)\n     return 1;\n   if (reg_offset_p && legitimate_small_data_p (mode, x))\n     return 1;\n-  if (reg_offset_p && legitimate_constant_pool_address_p (x))\n+  if (reg_offset_p && legitimate_constant_pool_address_p (x, reg_ok_strict))\n     return 1;\n   /* If not REG_OK_STRICT (before reload) let pass any stack offset.  */\n   if (! reg_ok_strict\n@@ -6212,7 +6260,9 @@ rs6000_mode_dependent_address (const_rtx addr)\n       break;\n \n     case LO_SUM:\n-      return true;\n+      /* Anything in the constant pool is sufficiently aligned that\n+\t all bytes have the same high part address.  */\n+      return !legitimate_constant_pool_address_p (addr, false);\n \n     /* Auto-increment cases are now treated generically in recog.c.  */\n     case PRE_MODIFY:\n@@ -6568,23 +6618,54 @@ rs6000_emit_set_long_const (rtx dest, HOST_WIDE_INT c1, HOST_WIDE_INT c2)\n static void\n rs6000_eliminate_indexed_memrefs (rtx operands[2])\n {\n+  if (reload_in_progress)\n+    return;\n+\n   if (GET_CODE (operands[0]) == MEM\n       && GET_CODE (XEXP (operands[0], 0)) != REG\n-      && ! legitimate_constant_pool_address_p (XEXP (operands[0], 0))\n-      && ! reload_in_progress)\n+      && ! legitimate_constant_pool_address_p (XEXP (operands[0], 0), false))\n     operands[0]\n       = replace_equiv_address (operands[0],\n \t\t\t       copy_addr_to_reg (XEXP (operands[0], 0)));\n \n   if (GET_CODE (operands[1]) == MEM\n       && GET_CODE (XEXP (operands[1], 0)) != REG\n-      && ! legitimate_constant_pool_address_p (XEXP (operands[1], 0))\n-      && ! reload_in_progress)\n+      && ! legitimate_constant_pool_address_p (XEXP (operands[1], 0), false))\n     operands[1]\n       = replace_equiv_address (operands[1],\n \t\t\t       copy_addr_to_reg (XEXP (operands[1], 0)));\n }\n \n+/* Return true if memory accesses to DECL are known to never straddle\n+   a 32k boundary.  */\n+\n+static bool\n+offsettable_ok_by_alignment (tree decl)\n+{\n+  unsigned HOST_WIDE_INT dsize;\n+\n+  /* Presume any compiler generated symbol_ref is suitably aligned.  */\n+  if (!decl)\n+    return true;\n+\n+  if (TREE_CODE (decl) != VAR_DECL\n+      && TREE_CODE (decl) != PARM_DECL\n+      && TREE_CODE (decl) != RESULT_DECL\n+      && TREE_CODE (decl) != FIELD_DECL)\n+    return true;\n+\n+  if (!host_integerp (DECL_SIZE_UNIT (decl), 1))\n+    return false;\n+\n+  dsize = tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n+  if (dsize <= 1)\n+    return true;\n+  if (dsize > 32768)\n+    return false;\n+\n+  return DECL_ALIGN_UNIT (decl) >= dsize;\n+}\n+\n /* Emit a move from SOURCE to DEST in mode MODE.  */\n void\n rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n@@ -6898,25 +6979,43 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n       /* If this is a SYMBOL_REF that refers to a constant pool entry,\n \t and we have put it in the TOC, we just need to make a TOC-relative\n \t reference to it.  */\n-      if (TARGET_TOC\n-\t  && GET_CODE (operands[1]) == SYMBOL_REF\n-\t  && constant_pool_expr_p (operands[1])\n-\t  && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (operands[1]),\n-\t\t\t\t\t      get_pool_mode (operands[1])))\n+      if ((TARGET_TOC\n+\t   && GET_CODE (operands[1]) == SYMBOL_REF\n+\t   && constant_pool_expr_p (operands[1])\n+\t   && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (operands[1]),\n+\t\t\t\t\t       get_pool_mode (operands[1])))\n+\t  || (TARGET_CMODEL == CMODEL_MEDIUM\n+\t      && GET_CODE (operands[1]) == SYMBOL_REF\n+\t      && !CONSTANT_POOL_ADDRESS_P (operands[1])\n+\t      && SYMBOL_REF_LOCAL_P (operands[1])\n+\t      && offsettable_ok_by_alignment (SYMBOL_REF_DECL (operands[1]))))\n \t{\n-\t  operands[1] = create_TOC_reference (operands[1]);\n+\t  rtx reg = NULL_RTX;\n+\t  if (TARGET_CMODEL != CMODEL_SMALL)\n+\t    {\n+\t      if (can_create_pseudo_p ())\n+\t\treg = gen_reg_rtx (Pmode);\n+\t      else\n+\t\treg = operands[0];\n+\t    }\n+\t  operands[1] = create_TOC_reference (operands[1], reg);\n \t}\n       else if (mode == Pmode\n \t       && CONSTANT_P (operands[1])\n \t       && ((GET_CODE (operands[1]) != CONST_INT\n \t\t    && ! easy_fp_constant (operands[1], mode))\n \t\t   || (GET_CODE (operands[1]) == CONST_INT\n-\t\t       && num_insns_constant (operands[1], mode) > 2)\n+\t\t       && (num_insns_constant (operands[1], mode)\n+\t\t\t   > (TARGET_CMODEL != CMODEL_SMALL ? 3 : 2)))\n \t\t   || (GET_CODE (operands[0]) == REG\n \t\t       && FP_REGNO_P (REGNO (operands[0]))))\n \t       && GET_CODE (operands[1]) != HIGH\n-\t       && ! legitimate_constant_pool_address_p (operands[1])\n-\t       && ! toc_relative_expr_p (operands[1]))\n+\t       && ! legitimate_constant_pool_address_p (operands[1], false)\n+\t       && ! toc_relative_expr_p (operands[1])\n+\t       && (TARGET_CMODEL == CMODEL_SMALL\n+\t\t   || can_create_pseudo_p ()\n+\t\t   || (REG_P (operands[0])\n+\t\t       && INT_REG_OK_FOR_BASE_P (operands[0], true))))\n \t{\n \n #if TARGET_MACHO\n@@ -6962,9 +7061,17 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n \t\t\tget_pool_constant (XEXP (operands[1], 0)),\n \t\t\tget_pool_mode (XEXP (operands[1], 0))))\n \t    {\n-\t      operands[1]\n-\t\t= gen_const_mem (mode,\n-\t\t\t\t create_TOC_reference (XEXP (operands[1], 0)));\n+\t      rtx tocref;\n+\t      rtx reg = NULL_RTX;\n+\t      if (TARGET_CMODEL != CMODEL_SMALL)\n+\t\t{\n+\t\t  if (can_create_pseudo_p ())\n+\t\t    reg = gen_reg_rtx (Pmode);\n+\t\t  else\n+\t\t    reg = operands[0];\n+\t\t}\n+\t      tocref = create_TOC_reference (XEXP (operands[1], 0), reg);\n+\t      operands[1] = gen_const_mem (mode, tocref);\n \t      set_mem_alias_set (operands[1], get_TOC_alias_set ());\n \t    }\n \t}\n@@ -15328,14 +15435,6 @@ print_operand_address (FILE *file, rtx x)\n   else if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n     fprintf (file, HOST_WIDE_INT_PRINT_DEC \"(%s)\",\n \t     INTVAL (XEXP (x, 1)), reg_names[ REGNO (XEXP (x, 0)) ]);\n-#if TARGET_ELF\n-  else if (GET_CODE (x) == LO_SUM && GET_CODE (XEXP (x, 0)) == REG\n-\t   && CONSTANT_P (XEXP (x, 1)))\n-    {\n-      output_addr_const (file, XEXP (x, 1));\n-      fprintf (file, \"@l(%s)\", reg_names[ REGNO (XEXP (x, 0)) ]);\n-    }\n-#endif\n #if TARGET_MACHO\n   else if (GET_CODE (x) == LO_SUM && GET_CODE (XEXP (x, 0)) == REG\n \t   && CONSTANT_P (XEXP (x, 1)))\n@@ -15345,11 +15444,29 @@ print_operand_address (FILE *file, rtx x)\n       fprintf (file, \")(%s)\", reg_names[ REGNO (XEXP (x, 0)) ]);\n     }\n #endif\n-  else if (legitimate_constant_pool_address_p (x))\n+  else if (legitimate_constant_pool_address_p (x, true))\n+    {\n+      /* This hack along with a corresponding hack in\n+\t rs6000_output_addr_const_extra arranges to output addends\n+\t where the assembler expects to find them.  eg.\n+\t (lo_sum (reg 9)\n+\t .       (const (plus (unspec [symbol_ref (\"x\") tocrel]) 8)))\n+\t without this hack would be output as \"x@toc+8@l(9)\".  We\n+\t want \"x+8@toc@l(9)\".  */\n+      output_addr_const (file, tocrel_base);\n+      if (GET_CODE (x) == LO_SUM)\n+\tfprintf (file, \"@l(%s)\", reg_names[ REGNO (XEXP (x, 0)) ]);\n+      else\n+\tfprintf (file, \"(%s)\", reg_names[REGNO (XEXP (x, 0))]);\n+    }\n+#if TARGET_ELF\n+  else if (GET_CODE (x) == LO_SUM && GET_CODE (XEXP (x, 0)) == REG\n+\t   && CONSTANT_P (XEXP (x, 1)))\n     {\n       output_addr_const (file, XEXP (x, 1));\n-      fprintf (file, \"(%s)\", reg_names[REGNO (XEXP (x, 0))]);\n+      fprintf (file, \"@l(%s)\", reg_names[ REGNO (XEXP (x, 0)) ]);\n     }\n+#endif\n   else\n     gcc_unreachable ();\n }\n@@ -15363,9 +15480,14 @@ rs6000_output_addr_const_extra (FILE *file, rtx x)\n     switch (XINT (x, 1))\n       {\n       case UNSPEC_TOCREL:\n-\tx = XVECEXP (x, 0, 0);\n-\tgcc_assert (GET_CODE (x) == SYMBOL_REF);\n-\toutput_addr_const (file, x);\n+\tgcc_assert (GET_CODE (XVECEXP (x, 0, 0)) == SYMBOL_REF);\n+\toutput_addr_const (file, XVECEXP (x, 0, 0));\n+\tif (x == tocrel_base && tocrel_offset != const0_rtx)\n+\t  {\n+\t    if (INTVAL (tocrel_offset) >= 0)\n+\t      fprintf (file, \"+\");\n+\t    output_addr_const (file, tocrel_offset);\n+\t  }\n \tif (!TARGET_AIX || (TARGET_ELF && TARGET_MINIMAL_TOC))\n \t  {\n \t    putc ('-', file);\n@@ -15689,7 +15811,7 @@ rs6000_generate_compare (rtx cmp, enum machine_mode mode)\n \t  && !TARGET_IEEEQUAD\n \t  && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128)\n \temit_insn (gen_rtx_PARALLEL (VOIDmode,\n-\t  gen_rtvec (9,\n+\t  gen_rtvec (10,\n \t\t     gen_rtx_SET (VOIDmode,\n \t\t\t\t  compare_result,\n \t\t\t\t  gen_rtx_COMPARE (comp_mode, op0, op1)),\n@@ -15700,7 +15822,8 @@ rs6000_generate_compare (rtx cmp, enum machine_mode mode)\n \t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (DFmode)),\n \t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (DFmode)),\n \t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (DFmode)),\n-\t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (DFmode)))));\n+\t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (DFmode)),\n+\t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (Pmode)))));\n       else if (GET_CODE (op1) == UNSPEC\n \t       && XINT (op1, 1) == UNSPEC_SP_TEST)\n \t{\n@@ -18259,8 +18382,10 @@ uses_TOC (void)\n #endif\n \n rtx\n-create_TOC_reference (rtx symbol)\n+create_TOC_reference (rtx symbol, rtx largetoc_reg)\n {\n+  rtx tocrel, tocreg;\n+\n   if (TARGET_DEBUG_ADDR)\n     {\n       if (GET_CODE (symbol) == SYMBOL_REF)\n@@ -18276,10 +18401,23 @@ create_TOC_reference (rtx symbol)\n \n   if (!can_create_pseudo_p ())\n     df_set_regs_ever_live (TOC_REGISTER, true);\n-  return gen_rtx_PLUS (Pmode,\n-\t   gen_rtx_REG (Pmode, TOC_REGISTER),\n-\t     gen_rtx_CONST (Pmode,\n-\t       gen_rtx_UNSPEC (Pmode, gen_rtvec (1, symbol), UNSPEC_TOCREL)));\n+\n+  tocrel = gen_rtx_CONST (Pmode,\n+\t\t\t  gen_rtx_UNSPEC (Pmode, gen_rtvec (1, symbol),\n+\t\t\t\t\t  UNSPEC_TOCREL));\n+  tocreg = gen_rtx_REG (Pmode, TOC_REGISTER);\n+  if (TARGET_CMODEL != CMODEL_SMALL)\n+    {\n+      rtx hi = gen_rtx_PLUS (Pmode, tocreg, gen_rtx_HIGH (Pmode, tocrel));\n+      if (largetoc_reg != NULL)\n+\t{\n+\t  emit_move_insn (largetoc_reg, hi);\n+\t  hi = largetoc_reg;\n+\t}\n+      return gen_rtx_LO_SUM (Pmode, hi, copy_rtx (tocrel));\n+    }\n+  else\n+    return gen_rtx_PLUS (Pmode, tocreg, tocrel);\n }\n \n /* Issue assembly directives that create a reference to the given DWARF"}, {"sha": "cd7b9281bef0b0a6842947f6fb36ca2ea9a5b0b5", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=070b27da92a270f1ada5ee00c04ee697255f2652", "patch": "@@ -293,6 +293,20 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #define TARGET_SECURE_PLT 0\n #endif\n \n+/* Code model for 64-bit linux.\n+   small: 16-bit toc offsets.\n+   medium: 32-bit toc offsets, static data and code within 2G of TOC pointer.\n+   large: 32-bit toc offsets, no limit on static data and code.  */\n+enum rs6000_cmodel {\n+  CMODEL_SMALL,\n+  CMODEL_MEDIUM,\n+  CMODEL_LARGE\n+};\n+\n+#ifndef TARGET_CMODEL\n+#define TARGET_CMODEL CMODEL_SMALL\n+#endif\n+\n #define TARGET_32BIT\t\t(! TARGET_64BIT)\n \n #ifndef HAVE_AS_TLS"}, {"sha": "b3faab8375d2e6e794a7cdb5d5d44ccd5f339d52", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 195, "deletions": 26, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=070b27da92a270f1ada5ee00c04ee697255f2652", "patch": "@@ -11004,7 +11004,12 @@\n \t\t   UNSPEC_TLSGD)\n    (clobber (reg:SI LR_REGNO))]\n   \"HAVE_AS_TLS && DEFAULT_ABI == ABI_AIX\"\n-  \"addi %0,%1,%2@got@tlsgd\\;bl %z3\\;%.\"\n+{\n+  if (TARGET_CMODEL != CMODEL_SMALL)\n+    return \"addis %0,%1,%2@got@tlsgd@ha\\;addi %0,%0,%2@got@tlsgd@l\\;bl %z3\\;%.\";\n+  else\n+    return \"addi %0,%1,%2@got@tlsgd\\;bl %z3\\;%.\";\n+}\n   \"&& TARGET_TLS_MARKERS\"\n   [(set (match_dup 0)\n \t(unspec:TLSmode [(match_dup 1)\n@@ -11017,7 +11022,10 @@\n \t      (clobber (reg:SI LR_REGNO))])]\n   \"\"\n   [(set_attr \"type\" \"two\")\n-   (set_attr \"length\" \"12\")])\n+   (set (attr \"length\")\n+     (if_then_else (ne (symbol_ref \"TARGET_CMODEL\") (symbol_ref \"CMODEL_SMALL\"))\n+     \t\t   (const_int 16)\n+     \t\t   (const_int 12)))])\n \n (define_insn_and_split \"tls_gd_sysv<TLSmode:tls_sysv_suffix>\"\n   [(set (match_operand:TLSmode 0 \"gpc_reg_operand\" \"=b\")\n@@ -11053,13 +11061,47 @@\n   [(set_attr \"type\" \"two\")\n    (set_attr \"length\" \"8\")])\n \n-(define_insn \"*tls_gd<TLSmode:tls_abi_suffix>\"\n+(define_insn_and_split \"*tls_gd<TLSmode:tls_abi_suffix>\"\n   [(set (match_operand:TLSmode 0 \"gpc_reg_operand\" \"=b\")\n \t(unspec:TLSmode [(match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")\n \t\t\t (match_operand:TLSmode 2 \"rs6000_tls_symbol_ref\" \"\")]\n \t\t\tUNSPEC_TLSGD))]\n   \"HAVE_AS_TLS && TARGET_TLS_MARKERS\"\n   \"addi %0,%1,%2@got@tlsgd\"\n+  \"&& TARGET_CMODEL != CMODEL_SMALL\"\n+  [(set (match_dup 3)\n+  \t(plus:TLSmode (match_dup 1)\n+\t  (high:TLSmode\n+\t    (unspec:TLSmode [(match_dup 2)] UNSPEC_TLSGD))))\n+   (set (match_dup 0)\n+   \t(lo_sum:TLSmode (match_dup 3)\n+\t    (unspec:TLSmode [(match_dup 2)] UNSPEC_TLSGD)))]\n+  \"\n+{\n+  operands[3] = gen_reg_rtx (TARGET_64BIT ? DImode : SImode);\n+}\"\n+  [(set (attr \"length\")\n+     (if_then_else (ne (symbol_ref \"TARGET_CMODEL\") (symbol_ref \"CMODEL_SMALL\"))\n+     \t\t   (const_int 8)\n+     \t\t   (const_int 4)))])\n+\n+(define_insn \"*tls_gd_high<TLSmode:tls_abi_suffix>\"\n+  [(set (match_operand:TLSmode 0 \"gpc_reg_operand\" \"=b\")\n+     (plus:TLSmode (match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")\n+       (high:TLSmode\n+\t  (unspec:TLSmode [(match_operand:TLSmode 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t\t  UNSPEC_TLSGD))))]\n+  \"HAVE_AS_TLS && TARGET_TLS_MARKERS && TARGET_CMODEL != CMODEL_SMALL\"\n+  \"addis %0,%1,%2@got@tlsgd@ha\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"*tls_gd_low<TLSmode:tls_abi_suffix>\"\n+  [(set (match_operand:TLSmode 0 \"gpc_reg_operand\" \"=b\")\n+     (lo_sum:TLSmode (match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")\n+       (unspec:TLSmode [(match_operand:TLSmode 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t       UNSPEC_TLSGD)))]\n+  \"HAVE_AS_TLS && TARGET_TLS_MARKERS && TARGET_CMODEL != CMODEL_SMALL\"\n+  \"addi %0,%1,%2@got@tlsgd@l\"\n   [(set_attr \"length\" \"4\")])\n \n (define_insn \"*tls_gd_call_aix<TLSmode:tls_abi_suffix>\"\n@@ -11102,7 +11144,12 @@\n \t\t   UNSPEC_TLSLD)\n    (clobber (reg:SI LR_REGNO))]\n   \"HAVE_AS_TLS && DEFAULT_ABI == ABI_AIX\"\n-  \"addi %0,%1,%&@got@tlsld\\;bl %z2\\;%.\"\n+{\n+  if (TARGET_CMODEL != CMODEL_SMALL)\n+    return \"addis %0,%1,%&@got@tlsld@ha\\;addi %0,%0,%&@got@tlsld@l\\;bl %z2\\;%.\";\n+  else\n+    return \"addi %0,%1,%&@got@tlsld\\;bl %z2\\;%.\";\n+}\n   \"&& TARGET_TLS_MARKERS\"\n   [(set (match_dup 0)\n \t(unspec:TLSmode [(match_dup 1)]\n@@ -11113,7 +11160,11 @@\n \t      (unspec:TLSmode [(const_int 0)] UNSPEC_TLSLD)\n \t      (clobber (reg:SI LR_REGNO))])]\n   \"\"\n-  [(set_attr \"length\" \"12\")])\n+  [(set_attr \"type\" \"two\")\n+   (set (attr \"length\")\n+     (if_then_else (ne (symbol_ref \"TARGET_CMODEL\") (symbol_ref \"CMODEL_SMALL\"))\n+     \t\t   (const_int 16)\n+     \t\t   (const_int 12)))])\n \n (define_insn_and_split \"tls_ld_sysv<TLSmode:tls_sysv_suffix>\"\n   [(set (match_operand:TLSmode 0 \"gpc_reg_operand\" \"=b\")\n@@ -11146,12 +11197,44 @@\n   \"\"\n   [(set_attr \"length\" \"8\")])\n \n-(define_insn \"*tls_ld<TLSmode:tls_abi_suffix>\"\n+(define_insn_and_split \"*tls_ld<TLSmode:tls_abi_suffix>\"\n   [(set (match_operand:TLSmode 0 \"gpc_reg_operand\" \"=b\")\n \t(unspec:TLSmode [(match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")]\n \t\t\tUNSPEC_TLSLD))]\n   \"HAVE_AS_TLS && TARGET_TLS_MARKERS\"\n   \"addi %0,%1,%&@got@tlsld\"\n+  \"&& TARGET_CMODEL != CMODEL_SMALL\"\n+  [(set (match_dup 2)\n+  \t(plus:TLSmode (match_dup 1)\n+\t  (high:TLSmode\n+\t    (unspec:TLSmode [(const_int 0)] UNSPEC_TLSLD))))\n+   (set (match_dup 0)\n+   \t(lo_sum:TLSmode (match_dup 2)\n+\t    (unspec:TLSmode [(const_int 0)] UNSPEC_TLSLD)))]\n+  \"\n+{\n+  operands[2] = gen_reg_rtx (TARGET_64BIT ? DImode : SImode);\n+}\"\n+  [(set (attr \"length\")\n+     (if_then_else (ne (symbol_ref \"TARGET_CMODEL\") (symbol_ref \"CMODEL_SMALL\"))\n+     \t\t   (const_int 8)\n+     \t\t   (const_int 4)))])\n+\n+(define_insn \"*tls_ld_high<TLSmode:tls_abi_suffix>\"\n+  [(set (match_operand:TLSmode 0 \"gpc_reg_operand\" \"=b\")\n+     (plus:TLSmode (match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")\n+       (high:TLSmode\n+\t  (unspec:TLSmode [(const_int 0)] UNSPEC_TLSLD))))]\n+  \"HAVE_AS_TLS && TARGET_TLS_MARKERS && TARGET_CMODEL != CMODEL_SMALL\"\n+  \"addis %0,%1,%&@got@tlsld@ha\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"*tls_ld_low<TLSmode:tls_abi_suffix>\"\n+  [(set (match_operand:TLSmode 0 \"gpc_reg_operand\" \"=b\")\n+     (lo_sum:TLSmode (match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")\n+       (unspec:TLSmode [(const_int 0)] UNSPEC_TLSLD)))]\n+  \"HAVE_AS_TLS && TARGET_TLS_MARKERS && TARGET_CMODEL != CMODEL_SMALL\"\n+  \"addi %0,%1,%&@got@tlsld@l\"\n   [(set_attr \"length\" \"4\")])\n \n (define_insn \"*tls_ld_call_aix<TLSmode:tls_abi_suffix>\"\n@@ -11208,13 +11291,48 @@\n   \"HAVE_AS_TLS\"\n   \"addi %0,%1,%2@dtprel@l\")\n \n-(define_insn \"tls_got_dtprel_<TLSmode:tls_abi_suffix>\"\n+(define_insn_and_split \"tls_got_dtprel_<TLSmode:tls_abi_suffix>\"\n   [(set (match_operand:TLSmode 0 \"gpc_reg_operand\" \"=r\")\n \t(unspec:TLSmode [(match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")\n \t\t\t (match_operand:TLSmode 2 \"rs6000_tls_symbol_ref\" \"\")]\n \t\t\tUNSPEC_TLSGOTDTPREL))]\n   \"HAVE_AS_TLS\"\n-  \"l<TLSmode:tls_insn_suffix> %0,%2@got@dtprel(%1)\")\n+  \"l<TLSmode:tls_insn_suffix> %0,%2@got@dtprel(%1)\"\n+  \"&& TARGET_CMODEL != CMODEL_SMALL\"\n+  [(set (match_dup 3)\n+\t(plus:TLSmode (match_dup 1)\n+\t  (high:TLSmode\n+\t    (unspec:TLSmode [(match_dup 2)] UNSPEC_TLSGOTDTPREL))))\n+   (set (match_dup 0)\n+\t(lo_sum:TLSmode (match_dup 3)\n+\t    (unspec:TLSmode [(match_dup 2)] UNSPEC_TLSGOTDTPREL)))]\n+  \"\n+{\n+  operands[3] = gen_reg_rtx (TARGET_64BIT ? DImode : SImode);\n+}\"\n+  [(set (attr \"length\")\n+     (if_then_else (ne (symbol_ref \"TARGET_CMODEL\") (symbol_ref \"CMODEL_SMALL\"))\n+     \t\t   (const_int 8)\n+     \t\t   (const_int 4)))])\n+\n+(define_insn \"*tls_got_dtprel_high<TLSmode:tls_abi_suffix>\"\n+  [(set (match_operand:TLSmode 0 \"gpc_reg_operand\" \"=b\")\n+     (plus:TLSmode (match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")\n+       (high:TLSmode\n+\t (unspec:TLSmode [(match_operand:TLSmode 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t\t UNSPEC_TLSGOTDTPREL))))]\n+  \"HAVE_AS_TLS && TARGET_CMODEL != CMODEL_SMALL\"\n+  \"addis %0,%1,%2@got@dtprel@ha\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"*tls_got_dtprel_low<TLSmode:tls_abi_suffix>\"\n+  [(set (match_operand:TLSmode 0 \"gpc_reg_operand\" \"=r\")\n+     (lo_sum:TLSmode (match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")\n+\t (unspec:TLSmode [(match_operand:TLSmode 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t\t UNSPEC_TLSGOTDTPREL)))]\n+  \"HAVE_AS_TLS && TARGET_CMODEL != CMODEL_SMALL\"\n+  \"l<TLSmode:tls_insn_suffix> %0,%2@got@dtprel@l(%1)\"\n+  [(set_attr \"length\" \"4\")])\n \n (define_insn \"tls_tprel_<TLSmode:tls_abi_suffix>\"\n   [(set (match_operand:TLSmode 0 \"gpc_reg_operand\" \"=r\")\n@@ -11243,13 +11361,48 @@\n ;; \"b\" output constraint here and on tls_tls input to support linker tls\n ;; optimization.  The linker may edit the instructions emitted by a\n ;; tls_got_tprel/tls_tls pair to addis,addi.\n-(define_insn \"tls_got_tprel_<TLSmode:tls_abi_suffix>\"\n+(define_insn_and_split \"tls_got_tprel_<TLSmode:tls_abi_suffix>\"\n   [(set (match_operand:TLSmode 0 \"gpc_reg_operand\" \"=b\")\n \t(unspec:TLSmode [(match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")\n \t\t\t (match_operand:TLSmode 2 \"rs6000_tls_symbol_ref\" \"\")]\n \t\t\tUNSPEC_TLSGOTTPREL))]\n   \"HAVE_AS_TLS\"\n-  \"l<TLSmode:tls_insn_suffix> %0,%2@got@tprel(%1)\")\n+  \"l<TLSmode:tls_insn_suffix> %0,%2@got@tprel(%1)\"\n+  \"&& TARGET_CMODEL != CMODEL_SMALL\"\n+  [(set (match_dup 3)\n+\t(plus:TLSmode (match_dup 1)\n+\t  (high:TLSmode\n+\t    (unspec:TLSmode [(match_dup 2)] UNSPEC_TLSGOTTPREL))))\n+   (set (match_dup 0)\n+\t(lo_sum:TLSmode (match_dup 3)\n+\t    (unspec:TLSmode [(match_dup 2)] UNSPEC_TLSGOTTPREL)))]\n+  \"\n+{\n+  operands[3] = gen_reg_rtx (TARGET_64BIT ? DImode : SImode);\n+}\"\n+  [(set (attr \"length\")\n+     (if_then_else (ne (symbol_ref \"TARGET_CMODEL\") (symbol_ref \"CMODEL_SMALL\"))\n+     \t\t   (const_int 8)\n+     \t\t   (const_int 4)))])\n+\n+(define_insn \"*tls_got_tprel_high<TLSmode:tls_abi_suffix>\"\n+  [(set (match_operand:TLSmode 0 \"gpc_reg_operand\" \"=b\")\n+     (plus:TLSmode (match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")\n+       (high:TLSmode\n+\t (unspec:TLSmode [(match_operand:TLSmode 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t\t UNSPEC_TLSGOTTPREL))))]\n+  \"HAVE_AS_TLS && TARGET_CMODEL != CMODEL_SMALL\"\n+  \"addis %0,%1,%2@got@tprel@ha\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"*tls_got_tprel_low<TLSmode:tls_abi_suffix>\"\n+  [(set (match_operand:TLSmode 0 \"gpc_reg_operand\" \"=r\")\n+     (lo_sum:TLSmode (match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")\n+\t (unspec:TLSmode [(match_operand:TLSmode 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t\t UNSPEC_TLSGOTTPREL)))]\n+  \"HAVE_AS_TLS && TARGET_CMODEL != CMODEL_SMALL\"\n+  \"l<TLSmode:tls_insn_suffix> %0,%2@got@tprel@l(%1)\"\n+  [(set_attr \"length\" \"4\")])\n \n (define_insn \"tls_tls_<TLSmode:tls_abi_suffix>\"\n   [(set (match_operand:TLSmode 0 \"gpc_reg_operand\" \"=r\")\n@@ -11258,7 +11411,6 @@\n \t\t\tUNSPEC_TLSTLS))]\n   \"HAVE_AS_TLS\"\n   \"add %0,%1,%2@tls\")\n-\n \f\n ;; Next come insns related to the calling sequence.\n ;;\n@@ -11548,6 +11700,21 @@\n    \"@\n     {cal|la} %0,%2@l(%1)\n     {ai|addic} %0,%1,%K2\")\n+\n+;; Largetoc support\n+(define_insn \"largetoc_high\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=b\")\n+        (plus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"b\")\n+\t         (high:DI (match_operand:DI 2 \"\" \"\"))))]\n+   \"TARGET_ELF && TARGET_CMODEL != CMODEL_SMALL\"\n+   \"{cau|addis} %0,%1,%2@ha\")\n+\n+(define_insn \"largetoc_low\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+        (lo_sum:DI (match_operand:DI 1 \"gpc_reg_operand\" \"b\")\n+\t           (match_operand:DI 2 \"\" \"\")))]\n+   \"TARGET_ELF && TARGET_CMODEL != CMODEL_SMALL\"\n+   \"{cal %0,%2@l(%1)|addi %0,%1,%2@l}\")\n \f\n ;; A function pointer under AIX is a pointer to a data area whose first word\n ;; contains the actual address of the function, whose second word contains a\n@@ -12822,26 +12989,27 @@\n     (clobber (match_scratch:DF 7 \"=d\"))\n     (clobber (match_scratch:DF 8 \"=d\"))\n     (clobber (match_scratch:DF 9 \"=d\"))\n-    (clobber (match_scratch:DF 10 \"=d\"))]\n+    (clobber (match_scratch:DF 10 \"=d\"))\n+    (clobber (match_scratch:GPR 11 \"=b\"))]\n   \"!TARGET_IEEEQUAD && TARGET_XL_COMPAT\n    && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LONG_DOUBLE_128\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(set (match_dup 3) (match_dup 13))\n-   (set (match_dup 4) (match_dup 14))\n+  [(set (match_dup 3) (match_dup 14))\n+   (set (match_dup 4) (match_dup 15))\n    (set (match_dup 9) (abs:DF (match_dup 5)))\n    (set (match_dup 0) (compare:CCFP (match_dup 9) (match_dup 3)))\n    (set (pc) (if_then_else (ne (match_dup 0) (const_int 0))\n-\t\t\t   (label_ref (match_dup 11))\n+\t\t\t   (label_ref (match_dup 12))\n \t\t\t   (pc)))\n    (set (match_dup 0) (compare:CCFP (match_dup 5) (match_dup 7)))\n-   (set (pc) (label_ref (match_dup 12)))\n-   (match_dup 11)\n+   (set (pc) (label_ref (match_dup 13)))\n+   (match_dup 12)\n    (set (match_dup 10) (minus:DF (match_dup 5) (match_dup 7)))\n    (set (match_dup 9) (minus:DF (match_dup 6) (match_dup 8)))\n    (set (match_dup 9) (plus:DF (match_dup 10) (match_dup 9)))\n    (set (match_dup 0) (compare:CCFP (match_dup 9) (match_dup 4)))\n-   (match_dup 12)]\n+   (match_dup 13)]\n {\n   REAL_VALUE_TYPE rv;\n   const int lo_word = FLOAT_WORDS_BIG_ENDIAN ? GET_MODE_SIZE (DFmode) : 0;\n@@ -12851,22 +13019,23 @@\n   operands[6] = simplify_gen_subreg (DFmode, operands[1], TFmode, lo_word);\n   operands[7] = simplify_gen_subreg (DFmode, operands[2], TFmode, hi_word);\n   operands[8] = simplify_gen_subreg (DFmode, operands[2], TFmode, lo_word);\n-  operands[11] = gen_label_rtx ();\n   operands[12] = gen_label_rtx ();\n+  operands[13] = gen_label_rtx ();\n   real_inf (&rv);\n-  operands[13] = force_const_mem (DFmode,\n-\t\t\t\t  CONST_DOUBLE_FROM_REAL_VALUE (rv, DFmode));\n   operands[14] = force_const_mem (DFmode,\n+\t\t\t\t  CONST_DOUBLE_FROM_REAL_VALUE (rv, DFmode));\n+  operands[15] = force_const_mem (DFmode,\n \t\t\t\t  CONST_DOUBLE_FROM_REAL_VALUE (dconst0,\n \t\t\t\t\t\t\t\tDFmode));\n   if (TARGET_TOC)\n     {\n-      operands[13] = gen_const_mem (DFmode,\n-\t\t\t\t    create_TOC_reference (XEXP (operands[13], 0)));\n-      operands[14] = gen_const_mem (DFmode,\n-\t\t\t\t    create_TOC_reference (XEXP (operands[14], 0)));\n-      set_mem_alias_set (operands[13], get_TOC_alias_set ());\n+      rtx tocref;\n+      tocref = create_TOC_reference (XEXP (operands[14], 0), operands[11]);\n+      operands[14] = gen_const_mem (DFmode, tocref);\n+      tocref = create_TOC_reference (XEXP (operands[15], 0), operands[11]);\n+      operands[15] = gen_const_mem (DFmode, tocref);\n       set_mem_alias_set (operands[14], get_TOC_alias_set ());\n+      set_mem_alias_set (operands[15], get_TOC_alias_set ());\n     }\n })\n \f"}, {"sha": "d1dcf891b8d382acf57e599a47562564727d5a5d", "filename": "gcc/configure", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=070b27da92a270f1ada5ee00c04ee697255f2652", "patch": "@@ -24843,6 +24843,43 @@ $as_echo \"$gcc_cv_ld_no_dot_syms\" >&6; }\n \n $as_echo \"#define HAVE_LD_NO_DOT_SYMS 1\" >>confdefs.h\n \n+    fi\n+\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking linker large toc support\" >&5\n+$as_echo_n \"checking linker large toc support... \" >&6; }\n+if test \"${gcc_cv_ld_large_toc+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  gcc_cv_ld_large_toc=no\n+    if test $in_tree_ld = yes ; then\n+      if test \"$gcc_cv_gld_major_version\" -eq 2 -a \"$gcc_cv_gld_minor_version\" -ge 21 -o \"$gcc_cv_gld_major_version\" -gt 2; then\n+        gcc_cv_ld_large_toc=yes\n+      fi\n+    elif test x$gcc_cv_as != x -a x$gcc_cv_ld != x ; then\n+      cat > conftest.s <<EOF\n+\t.section \".tbss\",\"awT\",@nobits\n+\t.align 3\n+ie0:\t.space 8\n+\t.global _start\n+\t.text\n+_start:\n+\taddis 9,13,ie0@got@tprel@ha\n+\tld 9,ie0@got@tprel@l(9)\n+EOF\n+      if $gcc_cv_as -a64 -o conftest.o conftest.s > /dev/null 2>&1 \\\n+         && $gcc_cv_ld -melf64ppc --no-toc-sort -o conftest conftest.o > /dev/null 2>&1; then\n+        gcc_cv_ld_large_toc=yes\n+      fi\n+      rm -f conftest conftest.o conftest.s\n+    fi\n+\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_ld_large_toc\" >&5\n+$as_echo \"$gcc_cv_ld_large_toc\" >&6; }\n+    if test x\"$gcc_cv_ld_large_toc\" = xyes; then\n+\n+$as_echo \"#define HAVE_LD_LARGE_TOC 1\" >>confdefs.h\n+\n     fi\n     ;;\n esac"}, {"sha": "9b3a75d95eb6a3dbfa7926d0107e68c30c1914bf", "filename": "gcc/configure.ac", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=070b27da92a270f1ada5ee00c04ee697255f2652", "patch": "@@ -3996,6 +3996,36 @@ EOF\n       AC_DEFINE(HAVE_LD_NO_DOT_SYMS, 1,\n     [Define if your PowerPC64 linker only needs function descriptor syms.])\n     fi\n+\n+    AC_CACHE_CHECK(linker large toc support,\n+    gcc_cv_ld_large_toc,\n+    [gcc_cv_ld_large_toc=no\n+    if test $in_tree_ld = yes ; then\n+      if test \"$gcc_cv_gld_major_version\" -eq 2 -a \"$gcc_cv_gld_minor_version\" -ge 21 -o \"$gcc_cv_gld_major_version\" -gt 2; then\n+        gcc_cv_ld_large_toc=yes\n+      fi\n+    elif test x$gcc_cv_as != x -a x$gcc_cv_ld != x ; then\n+      cat > conftest.s <<EOF\n+\t.section \".tbss\",\"awT\",@nobits\n+\t.align 3\n+ie0:\t.space 8\n+\t.global _start\n+\t.text\n+_start:\n+\taddis 9,13,ie0@got@tprel@ha\n+\tld 9,ie0@got@tprel@l(9)\n+EOF\n+      if $gcc_cv_as -a64 -o conftest.o conftest.s > /dev/null 2>&1 \\\n+         && $gcc_cv_ld -melf64ppc --no-toc-sort -o conftest conftest.o > /dev/null 2>&1; then\n+        gcc_cv_ld_large_toc=yes\n+      fi\n+      rm -f conftest conftest.o conftest.s\n+    fi\n+    ])\n+    if test x\"$gcc_cv_ld_large_toc\" = xyes; then\n+      AC_DEFINE(HAVE_LD_LARGE_TOC, 1,\n+    [Define if your PowerPC64 linker supports a large TOC.])\n+    fi\n     ;;\n esac\n "}, {"sha": "9e517e9c678e34144d98fb89961de9aa3209661f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070b27da92a270f1ada5ee00c04ee697255f2652/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=070b27da92a270f1ada5ee00c04ee697255f2652", "patch": "@@ -744,6 +744,7 @@ See RS/6000 and PowerPC Options.\n @emph{RS/6000 and PowerPC Options}\n @gccoptlist{-mcpu=@var{cpu-type} @gol\n -mtune=@var{cpu-type} @gol\n+-mcmodel=@var{code-model} @gol\n -mpower  -mno-power  -mpower2  -mno-power2 @gol\n -mpowerpc  -mpowerpc64  -mno-powerpc @gol\n -maltivec  -mno-altivec @gol\n@@ -14967,6 +14968,22 @@ values for @var{cpu_type} are used for @option{-mtune} as for\n architecture, registers, and mnemonics set by @option{-mcpu}, but the\n scheduling parameters set by @option{-mtune}.\n \n+@item -mcmodel=small\n+@opindex mcmodel=small\n+Generate PowerPC64 code for the small model: The TOC is limited to\n+64k.\n+\n+@item -mcmodel=medium\n+@opindex mcmodel=medium\n+Generate PowerPC64 code for the medium model: The TOC and other static\n+data may be up to a total of 4G in size.\n+\n+@item -mcmodel=large\n+@opindex mcmodel=large\n+Generate PowerPC64 code for the large model: The TOC may be up to 4G\n+in size.  Other data and code is only limited by the 64-bit address\n+space.\n+\n @item -maltivec\n @itemx -mno-altivec\n @opindex maltivec"}]}