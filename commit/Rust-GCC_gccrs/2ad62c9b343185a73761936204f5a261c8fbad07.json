{"sha": "2ad62c9b343185a73761936204f5a261c8fbad07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFkNjJjOWIzNDMxODVhNzM3NjE5MzYyMDRmNWEyNjFjOGZiYWQwNw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2007-02-02T03:49:36Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2007-02-02T03:49:36Z"}, "message": "trans-stmt.c (compute_overall_iter_number): Document function arguments.\n\n\n\t* trans-stmt.c (compute_overall_iter_number): Document function\n\targuments.  Generalize \"unconditional forall nest with constant\n\tbounds\" optimization to eliminate unconditional inner loops with\n\tconstant bounds.\n\nFrom-SVN: r121489", "tree": {"sha": "327313e525453d6a5947f578050c235bf82790f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/327313e525453d6a5947f578050c235bf82790f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ad62c9b343185a73761936204f5a261c8fbad07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ad62c9b343185a73761936204f5a261c8fbad07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ad62c9b343185a73761936204f5a261c8fbad07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ad62c9b343185a73761936204f5a261c8fbad07/comments", "author": null, "committer": null, "parents": [{"sha": "546dcc43525d33bb2ff29ce1c74c365ff7baa0b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546dcc43525d33bb2ff29ce1c74c365ff7baa0b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/546dcc43525d33bb2ff29ce1c74c365ff7baa0b8"}], "stats": {"total": 60, "additions": 32, "deletions": 28}, "files": [{"sha": "cf147cce12c2fa122c39f7a10c596a46b5ff9fac", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ad62c9b343185a73761936204f5a261c8fbad07/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ad62c9b343185a73761936204f5a261c8fbad07/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2ad62c9b343185a73761936204f5a261c8fbad07", "patch": "@@ -1,3 +1,10 @@\n+2007-02-01  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* trans-stmt.c (compute_overall_iter_number): Document function\n+\targuments.  Generalize \"unconditional forall nest with constant\n+\tbounds\" optimization to eliminate unconditional inner loops with\n+\tconstant bounds.\n+\n 2007-01-31  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/30520"}, {"sha": "daf68db4246ff213ed6afaf23e6a5a050720284f", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ad62c9b343185a73761936204f5a261c8fbad07/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ad62c9b343185a73761936204f5a261c8fbad07/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=2ad62c9b343185a73761936204f5a261c8fbad07", "patch": "@@ -2022,51 +2022,48 @@ compute_inner_temp_size (gfc_expr *expr1, gfc_expr *expr2,\n }\n \n \n-/* Calculate the overall iterator number of the nested forall construct.  */\n+/* Calculate the overall iterator number of the nested forall construct.\n+   This routine actually calculates the number of times the body of the\n+   nested forall specified by NESTED_FORALL_INFO is executed and multiplies\n+   that by the expression INNER_SIZE.  The BLOCK argument specifies the\n+   block in which to calculate the result, and the optional INNER_SIZE_BODY\n+   argument contains any statements that need to executed (inside the loop)\n+   to initialize or calculate INNER_SIZE.  */\n \n static tree\n compute_overall_iter_number (forall_info *nested_forall_info, tree inner_size,\n \t\t\t     stmtblock_t *inner_size_body, stmtblock_t *block)\n {\n+  forall_info *forall_tmp = nested_forall_info;\n   tree tmp, number;\n   stmtblock_t body;\n \n-  /* Optimize the case of unconditional FORALL nests with constant bounds.  */\n+  /* We can eliminate the innermost unconditional loops with constant\n+     array bounds.  */\n   if (INTEGER_CST_P (inner_size))\n     {\n-      bool all_const_p = true;\n-      forall_info *forall_tmp;\n-\n-      /* First check whether all the bounds are constant.  */\n-      for (forall_tmp = nested_forall_info;\n-\t   forall_tmp;\n-\t   forall_tmp = forall_tmp->prev_nest)\n-\tif (forall_tmp->mask || !INTEGER_CST_P (forall_tmp->size))\n-\t  {\n-\t    all_const_p = false;\n-\t    break;\n-\t  }\n-\n-      if (all_const_p)\n+      while (forall_tmp\n+\t     && !forall_tmp->mask \n+\t     && INTEGER_CST_P (forall_tmp->size))\n \t{\n-\t  tree tmp = inner_size;\n-\t  for (forall_tmp = nested_forall_info;\n-\t       forall_tmp;\n-\t       forall_tmp = forall_tmp->prev_nest)\n-\t    tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t       tmp, forall_tmp->size);\n-\t  return tmp;\n+\t  inner_size = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t    inner_size, forall_tmp->size);\n+\t  forall_tmp = forall_tmp->prev_nest;\n \t}\n+\n+      /* If there are no loops left, we have our constant result.  */\n+      if (!forall_tmp)\n+\treturn inner_size;\n     }\n-  \n-  /* TODO: optimizing the computing process.  */\n+\n+  /* Otherwise, create a temporary variable to compute the result.  */\n   number = gfc_create_var (gfc_array_index_type, \"num\");\n   gfc_add_modify_expr (block, number, gfc_index_zero_node);\n \n   gfc_start_block (&body);\n   if (inner_size_body)\n     gfc_add_block_to_block (&body, inner_size_body);\n-  if (nested_forall_info)\n+  if (forall_tmp)\n     tmp = build2 (PLUS_EXPR, gfc_array_index_type, number,\n \t\t  inner_size);\n   else\n@@ -2075,8 +2072,8 @@ compute_overall_iter_number (forall_info *nested_forall_info, tree inner_size,\n   tmp = gfc_finish_block (&body);\n \n   /* Generate loops.  */\n-  if (nested_forall_info != NULL)\n-    tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 1);\n+  if (forall_tmp != NULL)\n+    tmp = gfc_trans_nested_forall_loop (forall_tmp, tmp, 1);\n \n   gfc_add_expr_to_block (block, tmp);\n "}]}