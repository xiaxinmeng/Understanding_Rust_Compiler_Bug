{"sha": "e42922b1ae4c3da94882d3a92ce978a0db123064", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQyOTIyYjFhZTRjM2RhOTQ4ODJkM2E5MmNlOTc4YTBkYjEyMzA2NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-05-19T10:38:42Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-05-19T10:38:42Z"}, "message": "basic-block.h (REG_BR_PROB_BASE): Define.\n\n\n\t* basic-block.h (REG_BR_PROB_BASE): Define.\n\t* cgraph.c (cgraph_create_edge): Initialize loop_nest and count.\n\t(dump_cgraph_node): Dump count.\n\t(cgraph_clone_edge): Rescale counts.\n\t(cgraph_clone_node): Likewise.\n\t* cgraph.h: Include basic-block.h\n\t(cgraph_node): Add count.\n\t(cgraph_edge): Add count and loop_nest.\n\t(cgraph_node, cgraph_edge, cgraph_clone_edge, cgraph_clone_node):\n\tUpdate prototypes.\n\t* cgraphunit.c: Kill now redundant inlining comment.\n\t(cgraph_create_edges): Make static, maintain current basic block;\n\tfix pasto.\n\t(record_call_1): Fill in new fields.\n\t* ipa-inline.c (cgraph_clone_inlined_nodes): Update call of\n\tcgraph_clone_node.\n\t(cgraph_decide_recursive_inlining): Likewise.\n\t* rtl.h (REG_BR_PROB_BASE): Kill.\n\t* tree-inline.c (copy_body_r): Update call of cgraph_clone_edge.\n\t(expand_call_inline): Update call of cgraph_create_edge.\n\t* tree-optimize.c (tree_rest_of_compilation): Likewise.\n\nFrom-SVN: r99976", "tree": {"sha": "1d011084a5002e1aadab35d8ef841e441fb68211", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d011084a5002e1aadab35d8ef841e441fb68211"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e42922b1ae4c3da94882d3a92ce978a0db123064", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e42922b1ae4c3da94882d3a92ce978a0db123064", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e42922b1ae4c3da94882d3a92ce978a0db123064", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e42922b1ae4c3da94882d3a92ce978a0db123064/comments", "author": null, "committer": null, "parents": [{"sha": "eef16504e21f8d504b6a648cf73955e977d5adf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eef16504e21f8d504b6a648cf73955e977d5adf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eef16504e21f8d504b6a648cf73955e977d5adf6"}], "stats": {"total": 145, "additions": 89, "deletions": 56}, "files": [{"sha": "51df4dc1950686ee0e18f88f70f0a35073f3086c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e42922b1ae4c3da94882d3a92ce978a0db123064/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e42922b1ae4c3da94882d3a92ce978a0db123064/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e42922b1ae4c3da94882d3a92ce978a0db123064", "patch": "@@ -1,3 +1,27 @@\n+2005-05-19  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (REG_BR_PROB_BASE): Define.\n+\t* cgraph.c (cgraph_create_edge): Initialize loop_nest and count.\n+\t(dump_cgraph_node): Dump count.\n+\t(cgraph_clone_edge): Rescale counts.\n+\t(cgraph_clone_node): Likewise.\n+\t* cgraph.h: Include basic-block.h\n+\t(cgraph_node): Add count.\n+\t(cgraph_edge): Add count and loop_nest.\n+\t(cgraph_node, cgraph_edge, cgraph_clone_edge, cgraph_clone_node):\n+\tUpdate prototypes.\n+\t* cgraphunit.c: Kill now redundant inlining comment.\n+\t(cgraph_create_edges): Make static, maintain current basic block;\n+\tfix pasto.\n+\t(record_call_1): Fill in new fields.\n+\t* ipa-inline.c (cgraph_clone_inlined_nodes): Update call of\n+\tcgraph_clone_node.\n+\t(cgraph_decide_recursive_inlining): Likewise.\n+\t* rtl.h (REG_BR_PROB_BASE): Kill.\n+\t* tree-inline.c (copy_body_r): Update call of cgraph_clone_edge.\n+\t(expand_call_inline): Update call of cgraph_create_edge.\n+\t* tree-optimize.c (tree_rest_of_compilation): Likewise.\n+\n 2005-05-19  Nick Clifton  <nickc@redhat.com>\n \n \t* config/rs6000/eabispe.h (SUBSUBTARGET_OVERRIDE_OPTIONS): Use the"}, {"sha": "4deeb8997550f8029bc7507ca1e43a8ff0df4a38", "filename": "gcc/basic-block.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e42922b1ae4c3da94882d3a92ce978a0db123064/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e42922b1ae4c3da94882d3a92ce978a0db123064/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=e42922b1ae4c3da94882d3a92ce978a0db123064", "patch": "@@ -555,6 +555,9 @@ struct edge_list\n   edge *index_to_edge;\n };\n \n+/* The base value for branch probability notes and edge probabilities.  */\n+#define REG_BR_PROB_BASE  10000\n+\n /* This is the value which indicates no edge is present.  */\n #define EDGE_INDEX_NO_EDGE\t-1\n "}, {"sha": "c2509ffc033fbc34cd159069eadca13fe3f9382c", "filename": "gcc/cgraph.c", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e42922b1ae4c3da94882d3a92ce978a0db123064/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e42922b1ae4c3da94882d3a92ce978a0db123064/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=e42922b1ae4c3da94882d3a92ce978a0db123064", "patch": "@@ -275,7 +275,7 @@ cgraph_edge (struct cgraph_node *node, tree call_expr)\n \n struct cgraph_edge *\n cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n-\t\t    tree call_expr)\n+\t\t    tree call_expr, gcov_type count, int nest)\n {\n   struct cgraph_edge *edge = ggc_alloc (sizeof (struct cgraph_edge));\n #ifdef ENABLE_CHECKING\n@@ -312,6 +312,8 @@ cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n     caller->callees->prev_callee = edge;\n   caller->callees = edge;\n   callee->callers = edge;\n+  edge->count = count;\n+  edge->loop_nest = nest;\n   return edge;\n }\n \n@@ -559,6 +561,9 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     fprintf (f, \" (inline copy in %s/%i)\",\n \t     cgraph_node_name (node->global.inlined_to),\n \t     node->global.inlined_to->uid);\n+  if (node->count)\n+    fprintf (f, \" executed \"HOST_WIDEST_INT_PRINT_DEC\"x\",\n+\t     (HOST_WIDEST_INT)node->count);\n   if (node->local.self_insns)\n     fprintf (f, \" %i insns\", node->local.self_insns);\n   if (node->global.insns && node->global.insns != node->local.self_insns)\n@@ -587,6 +592,9 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     {\n       fprintf (f, \"%s/%i \", cgraph_node_name (edge->caller),\n \t       edge->caller->uid);\n+      if (edge->count)\n+\tfprintf (f, \"(\"HOST_WIDEST_INT_PRINT_DEC\"x) \",\n+\t\t (HOST_WIDEST_INT)edge->count);\n       if (!edge->inline_failed)\n \tfprintf(f, \"(inlined) \");\n     }\n@@ -829,20 +837,28 @@ cgraph_function_possibly_inlined_p (tree decl)\n \n /* Create clone of E in the node N represented by CALL_EXPR the callgraph.  */\n struct cgraph_edge *\n-cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n, tree call_expr)\n+cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n+\t\t   tree call_expr, int count_scale, int loop_nest)\n {\n-  struct cgraph_edge *new = cgraph_create_edge (n, e->callee, call_expr);\n+  struct cgraph_edge *new;\n+\n+  new = cgraph_create_edge (n, e->callee, call_expr,\n+                            e->count * count_scale / REG_BR_PROB_BASE,\n+\t\t            e->loop_nest + loop_nest);\n \n   new->inline_failed = e->inline_failed;\n+  e->count -= new->count;\n   return new;\n }\n \n-/* Create node representing clone of N.  */\n+/* Create node representing clone of N executed COUNT times.  Decrease\n+   the execution counts from original node too.  */\n struct cgraph_node *\n-cgraph_clone_node (struct cgraph_node *n)\n+cgraph_clone_node (struct cgraph_node *n, gcov_type count, int loop_nest)\n {\n   struct cgraph_node *new = cgraph_create_node ();\n   struct cgraph_edge *e;\n+  int count_scale;\n \n   new->decl = n->decl;\n   new->origin = n->origin;\n@@ -855,9 +871,15 @@ cgraph_clone_node (struct cgraph_node *n)\n   new->local = n->local;\n   new->global = n->global;\n   new->rtl = n->rtl;\n+  new->count = count;\n+  if (n->count)\n+    count_scale = new->count * REG_BR_PROB_BASE / n->count;\n+  else\n+    count_scale = 0;\n+  n->count -= count;\n \n   for (e = n->callees;e; e=e->next_callee)\n-    cgraph_clone_edge (e, new, e->call_expr);\n+    cgraph_clone_edge (e, new, e->call_expr, count_scale, loop_nest);\n \n   new->next_clone = n->next_clone;\n   new->prev_clone = n;"}, {"sha": "294b690787b3601149df1887c9e8a9a0e939170d", "filename": "gcc/cgraph.h", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e42922b1ae4c3da94882d3a92ce978a0db123064/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e42922b1ae4c3da94882d3a92ce978a0db123064/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=e42922b1ae4c3da94882d3a92ce978a0db123064", "patch": "@@ -22,6 +22,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifndef GCC_CGRAPH_H\n #define GCC_CGRAPH_H\n #include \"tree.h\"\n+#include \"basic-block.h\"\n \n /* Information about the function collected locally.\n    Available after function is analyzed.  */\n@@ -109,6 +110,8 @@ struct cgraph_node GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\")))\n   struct cgraph_global_info global;\n   struct cgraph_rtl_info rtl;\n   \n+  /* Expected number of executions: calculated in profile.c.  */\n+  gcov_type count;\n   /* Unique id of the node.  */\n   int uid;\n   /* Set when function must be output - it is externally visible\n@@ -141,6 +144,10 @@ struct cgraph_edge GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_call\n   /* When NULL, inline this call.  When non-NULL, points to the explanation\n      why function was not inlined.  */\n   const char *inline_failed;\n+  /* Expected number of executions: calculated in profile.c.  */\n+  gcov_type count;\n+  /* Depth of loop nest, 1 means no loop nest.  */\n+  int loop_nest;\n };\n \n /* The cgraph_varpool data structure.\n@@ -190,25 +197,25 @@ void cgraph_remove_node (struct cgraph_node *);\n void cgraph_node_remove_callees (struct cgraph_node *node);\n struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,\n \t\t\t\t\tstruct cgraph_node *,\n-\t\t\t\t        tree);\n-struct cgraph_node *cgraph_node (tree decl);\n+\t\t\t\t        tree, gcov_type, int);\n+struct cgraph_node *cgraph_node (tree);\n struct cgraph_node *cgraph_node_for_asm (tree asmname);\n-struct cgraph_edge *cgraph_edge (struct cgraph_node *, tree call_expr);\n+struct cgraph_edge *cgraph_edge (struct cgraph_node *, tree);\n struct cgraph_local_info *cgraph_local_info (tree);\n struct cgraph_global_info *cgraph_global_info (tree);\n struct cgraph_rtl_info *cgraph_rtl_info (tree);\n const char * cgraph_node_name (struct cgraph_node *);\n-struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *, struct cgraph_node *, tree);\n-struct cgraph_node * cgraph_clone_node (struct cgraph_node *);\n+struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *, struct cgraph_node *, tree, int, int);\n+struct cgraph_node * cgraph_clone_node (struct cgraph_node *, gcov_type, int);\n \n-struct cgraph_varpool_node *cgraph_varpool_node (tree decl);\n+struct cgraph_varpool_node *cgraph_varpool_node (tree);\n struct cgraph_varpool_node *cgraph_varpool_node_for_asm (tree asmname);\n void cgraph_varpool_mark_needed_node (struct cgraph_varpool_node *);\n void cgraph_varpool_finalize_decl (tree);\n void cgraph_redirect_edge_callee (struct cgraph_edge *, struct cgraph_node *);\n \n bool cgraph_function_possibly_inlined_p (tree);\n-void cgraph_unnest_node (struct cgraph_node *node);\n+void cgraph_unnest_node (struct cgraph_node *);\n void cgraph_varpool_enqueue_needed_node (struct cgraph_varpool_node *);\n void cgraph_varpool_reset_queue (void);\n bool decide_is_variable_needed (struct cgraph_varpool_node *, tree);\n@@ -219,7 +226,6 @@ bool cgraph_varpool_assemble_pending_decls (void);\n void cgraph_finalize_function (tree, bool);\n void cgraph_lower_function (struct cgraph_node *);\n void cgraph_finalize_compilation_unit (void);\n-void cgraph_create_edges (struct cgraph_node *, tree);\n void cgraph_optimize (void);\n void cgraph_mark_needed_node (struct cgraph_node *);\n void cgraph_mark_reachable_node (struct cgraph_node *);"}, {"sha": "14eb46b22c0f6bb8b89cebb409fb8de213e3c379", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 13, "deletions": 34, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e42922b1ae4c3da94882d3a92ce978a0db123064/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e42922b1ae4c3da94882d3a92ce978a0db123064/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=e42922b1ae4c3da94882d3a92ce978a0db123064", "patch": "@@ -136,33 +136,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \tdecision on whether function is needed is made more conservative so\n \tuninlininable static functions are needed too.  During the call-graph\n \tconstruction the edge destinations are not marked as reachable and it\n-\tis completely relied upn assemble_variable to mark them.\n-\t\n-     Inlining decision heuristics\n-        ??? Move this to separate file after tree-ssa merge.\n-\n-\tWe separate inlining decisions from the inliner itself and store it\n-\tinside callgraph as so called inline plan.  Refer to cgraph.c\n-\tdocumentation about particular representation of inline plans in the\n-\tcallgraph\n-\n-\tThe implementation of particular heuristics is separated from\n-\tthe rest of code to make it easier to replace it with more complicated\n-\timplementation in the future.  The rest of inlining code acts as a\n-\tlibrary aimed to modify the callgraph and verify that the parameters\n-\ton code size growth fits.\n-\n-\tTo mark given call inline, use cgraph_mark_inline function, the\n-\tverification is performed by cgraph_default_inline_p and\n-\tcgraph_check_inline_limits.\n-\n-\tThe heuristics implements simple knapsack style algorithm ordering\n-\tall functions by their \"profitability\" (estimated by code size growth)\n-\tand inlining them in priority order.\n-\n-\tcgraph_decide_inlining implements heuristics taking whole callgraph\n-\tinto account, while cgraph_decide_inlining_incrementally considers\n-\tonly one function at a time and is used in non-unit-at-a-time mode.  */\n+\tis completely relied upn assemble_variable to mark them.  */\n \n \n #include \"config.h\"\n@@ -198,6 +172,7 @@ static void cgraph_expand_function (struct cgraph_node *);\n static tree record_call_1 (tree *, int *, void *);\n static void cgraph_mark_local_functions (void);\n static void cgraph_analyze_function (struct cgraph_node *node);\n+static void cgraph_create_edges (struct cgraph_node *node, tree body);\n \n /* Records tree nodes seen in cgraph_create_edges.  Simply using\n    walk_tree_without_duplicates doesn't guarantee each node is visited\n@@ -460,6 +435,9 @@ cgraph_finalize_function (tree decl, bool nested)\n     do_warn_unused_parameter (decl);\n }\n \n+/* Used only while constructing the callgraph.  */\n+static basic_block current_basic_block;\n+\n void\n cgraph_lower_function (struct cgraph_node *node)\n {\n@@ -469,7 +447,6 @@ cgraph_lower_function (struct cgraph_node *node)\n   node->lowered = true;\n }\n \n-\n /* Walk tree and record all calls.  Called via walk_tree.  */\n static tree\n record_call_1 (tree *tp, int *walk_subtrees, void *data)\n@@ -508,7 +485,9 @@ record_call_1 (tree *tp, int *walk_subtrees, void *data)\n \ttree decl = get_callee_fndecl (*tp);\n \tif (decl && TREE_CODE (decl) == FUNCTION_DECL)\n \t  {\n-\t    cgraph_create_edge (data, cgraph_node (decl), *tp);\n+\t    cgraph_create_edge (data, cgraph_node (decl), *tp,\n+\t\t\t        current_basic_block->count,\n+\t\t\t\tcurrent_basic_block->loop_depth);\n \n \t    /* When we see a function call, we don't want to look at the\n \t       function reference in the ADDR_EXPR that is hanging from\n@@ -543,24 +522,25 @@ record_call_1 (tree *tp, int *walk_subtrees, void *data)\n \n /* Create cgraph edges for function calls inside BODY from NODE.  */\n \n-void\n+static void\n cgraph_create_edges (struct cgraph_node *node, tree body)\n {\n   /* The nodes we're interested in are never shared, so walk\n      the tree ignoring duplicates.  */\n   visited_nodes = pointer_set_create ();\n+  gcc_assert (current_basic_block == NULL);\n   if (TREE_CODE (body) == FUNCTION_DECL)\n     {\n       struct function *this_cfun = DECL_STRUCT_FUNCTION (body);\n-      basic_block this_block;\n       block_stmt_iterator bsi;\n       tree step;\n \n       /* Reach the trees by walking over the CFG, and note the \n \t enclosing basic-blocks in the call edges.  */\n-      FOR_EACH_BB_FN (this_block, this_cfun)\n-        for (bsi = bsi_start (this_block); !bsi_end_p (bsi); bsi_next (&bsi))\n+      FOR_EACH_BB_FN (current_basic_block, this_cfun)\n+        for (bsi = bsi_start (current_basic_block); !bsi_end_p (bsi); bsi_next (&bsi))\n \t  walk_tree (bsi_stmt_ptr (bsi), record_call_1, node, visited_nodes);\n+      current_basic_block = NULL;\n \n       /* Walk over any private statics that may take addresses of functions.  */\n       if (TREE_CODE (DECL_INITIAL (body)) == BLOCK)\n@@ -586,7 +566,6 @@ cgraph_create_edges (struct cgraph_node *node, tree body)\n   else\n     walk_tree (&body, record_call_1, node, visited_nodes);\n     \n-  walk_tree (&body, record_call_1, node, visited_nodes);\n   pointer_set_destroy (visited_nodes);\n   visited_nodes = NULL;\n }"}, {"sha": "79150d2ba9a339923c83e50c65b26705bb808047", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e42922b1ae4c3da94882d3a92ce978a0db123064/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e42922b1ae4c3da94882d3a92ce978a0db123064/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=e42922b1ae4c3da94882d3a92ce978a0db123064", "patch": "@@ -123,7 +123,7 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate)\n     }\n    else if (duplicate)\n     {\n-      n = cgraph_clone_node (e->callee);\n+      n = cgraph_clone_node (e->callee, e->count, e->loop_nest);\n       cgraph_redirect_edge_callee (e, n);\n     }\n \n@@ -369,7 +369,7 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node)\n \t     cgraph_node_name (node));\n \n   /* We need original clone to copy around.  */\n-  master_clone = cgraph_clone_node (node);\n+  master_clone = cgraph_clone_node (node, 0, 1);\n   master_clone->needed = true;\n   for (e = master_clone->callees; e; e = e->next_callee)\n     if (!e->inline_failed)"}, {"sha": "2eb5d9c84b814bf37e151c52b1a85b8feeb59bfe", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e42922b1ae4c3da94882d3a92ce978a0db123064/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e42922b1ae4c3da94882d3a92ce978a0db123064/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e42922b1ae4c3da94882d3a92ce978a0db123064", "patch": "@@ -706,9 +706,6 @@ enum reg_note\n   REG_NOTE_MAX\n };\n \n-/* The base value for branch probability notes.  */\n-#define REG_BR_PROB_BASE  10000\n-\n /* Define macros to extract and insert the reg-note kind in an EXPR_LIST.  */\n #define REG_NOTE_KIND(LINK) ((enum reg_note) GET_MODE (LINK))\n #define PUT_REG_NOTE_KIND(LINK, KIND) \\"}, {"sha": "118f493e2992529f167139dd54675546725a7a10", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e42922b1ae4c3da94882d3a92ce978a0db123064/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e42922b1ae4c3da94882d3a92ce978a0db123064/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=e42922b1ae4c3da94882d3a92ce978a0db123064", "patch": "@@ -656,7 +656,8 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t\t associate callgraph nodes.  */\n \t      edge = cgraph_edge (id->current_node, old_node);\n \t      if (edge)\n-\t\t cgraph_clone_edge (edge, id->node, *tp);\n+\t\t cgraph_clone_edge (edge, id->node, *tp,\n+\t\t\t\t    REG_BR_PROB_BASE, 1);\n \t    }\n \t}\n       else if (TREE_CODE (*tp) == RESX_EXPR && id->eh_region_offset)\n@@ -1922,7 +1923,8 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n          constant propagating arguments.  In all other cases we hit a bug\n          (incorrect node sharing is most common reason for missing edges.  */\n       gcc_assert (dest->needed || !flag_unit_at_a_time);\n-      cgraph_create_edge (id->node, dest, t)->inline_failed\n+      cgraph_create_edge (id->node, dest, t,\n+\t\t\t  bb->count, bb->loop_depth)->inline_failed\n \t= N_(\"originally indirect function call not considered for inlining\");\n       goto egress;\n     }"}, {"sha": "7c9beb812dccd0a329bb39e11f869a32692ee35a", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e42922b1ae4c3da94882d3a92ce978a0db123064/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e42922b1ae4c3da94882d3a92ce978a0db123064/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=e42922b1ae4c3da94882d3a92ce978a0db123064", "patch": "@@ -741,7 +741,7 @@ tree_rest_of_compilation (tree fndecl)\n \t{\n \t  struct cgraph_edge *e;\n \n-\t  saved_node = cgraph_clone_node (node);\n+\t  saved_node = cgraph_clone_node (node, node->count, 1);\n \t  for (e = saved_node->callees; e; e = e->next_callee)\n \t    if (!e->inline_failed)\n \t      cgraph_clone_inlined_nodes (e, true);"}]}