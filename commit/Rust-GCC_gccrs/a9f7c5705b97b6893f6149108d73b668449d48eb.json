{"sha": "a9f7c5705b97b6893f6149108d73b668449d48eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTlmN2M1NzA1Yjk3YjY4OTNmNjE0OTEwOGQ3M2I2Njg0NDlkNDhlYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-10-16T05:08:26Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-10-16T05:08:26Z"}, "message": "gimplify.c (gimplify_var_or_parm_decl): Split out from ...\n\n        * gimplify.c (gimplify_var_or_parm_decl): Split out from ...\n        (gimplify_expr): ... here.\n        (gimplify_compound_lval): Use it in initial scan loop.  Allow\n        fb_lvalue in base expression.\n\nFrom-SVN: r105458", "tree": {"sha": "a1958d73f7b111bd65e7572b20f61193496c187f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1958d73f7b111bd65e7572b20f61193496c187f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9f7c5705b97b6893f6149108d73b668449d48eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9f7c5705b97b6893f6149108d73b668449d48eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9f7c5705b97b6893f6149108d73b668449d48eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9f7c5705b97b6893f6149108d73b668449d48eb/comments", "author": null, "committer": null, "parents": [{"sha": "cb807ba36b80c6e350c1493ee2e48bea7a4cdeb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb807ba36b80c6e350c1493ee2e48bea7a4cdeb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb807ba36b80c6e350c1493ee2e48bea7a4cdeb8"}], "stats": {"total": 106, "additions": 66, "deletions": 40}, "files": [{"sha": "9384f1705a90c28afe6a48dddece0d1e5ca0a29b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9f7c5705b97b6893f6149108d73b668449d48eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9f7c5705b97b6893f6149108d73b668449d48eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9f7c5705b97b6893f6149108d73b668449d48eb", "patch": "@@ -1,3 +1,10 @@\n+2005-10-15  Richard Henderson  <rth@redhat.com>\n+\n+\t* gimplify.c (gimplify_var_or_parm_decl): Split out from ...\n+\t(gimplify_expr): ... here.\n+\t(gimplify_compound_lval): Use it in initial scan loop.  Allow\n+\tfb_lvalue in base expression.\n+\n 2005-10-15  Richard Henderson  <rth@redhat.com>\n \n \tPR 23714\n@@ -418,7 +425,7 @@\n 2005-10-06  Daniel Berlin  <dberlin@dberlin.org>\n \t\n \t* tree-ssa-structalias.c (check_for_overlaps): Fix bug in last\n-        change.\n+\tchange.\n \n 2005-10-06  Richard Henderson  <rth@redhat.com>\n \n@@ -1000,8 +1007,8 @@\n 2005-09-23  Fariborz Jahanian <fjahanian@apple.com>\n \n \tPR target/23847\n-        * config/rs6000/rs6000.c (rs6000_function_value): Parallel pattern\n-        for __complex__ double in -mcpu=G5 mode.\n+\t* config/rs6000/rs6000.c (rs6000_function_value): Parallel pattern\n+\tfor __complex__ double in -mcpu=G5 mode.\n \n 2005-09-26  Sebastian Pop  <pop@cri.ensmp.fr>\n \n@@ -1026,7 +1033,7 @@\n \n 2005-09-26    Fariborz Jahanian <fjahanian@apple.com>\n \n-        * combine.c (make_extraction): Check for valid use of subreg.\n+\t* combine.c (make_extraction): Check for valid use of subreg.\n \n 2005-09-26  Uros Bizjak  <uros@kss-loka.si>\n \n@@ -1170,10 +1177,10 @@\n \n 2005-09-22  David Edelsohn  <edelsohn@gnu.org>\n \n-        PR target/24007\n-        * config/rs6000/rs6000.md (movsf_hardfloat): Ignore special\n-        registers when choosing register preferences.\n-        (movdf_hardfloat64): Same.\n+\tPR target/24007\n+\t* config/rs6000/rs6000.md (movsf_hardfloat): Ignore special\n+\tregisters when choosing register preferences.\n+\t(movdf_hardfloat64): Same.\n \n 2005-09-22  Andreas Krebbel  <krebbel1@de.ibm.com>\n "}, {"sha": "b7d891e041e4531500e908954f1088023e0878d2", "filename": "gcc/gimplify.c", "status": "modified", "additions": 51, "deletions": 32, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9f7c5705b97b6893f6149108d73b668449d48eb/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9f7c5705b97b6893f6149108d73b668449d48eb/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=a9f7c5705b97b6893f6149108d73b668449d48eb", "patch": "@@ -1468,6 +1468,40 @@ gimplify_conversion (tree *expr_p)\n   return GS_OK;\n }\n \n+/* Gimplify a VAR_DECL or PARM_DECL.  Returns GS_OK if we expanded a \n+   DECL_VALUE_EXPR, and it's worth re-examining things.  */\n+\n+static enum gimplify_status\n+gimplify_var_or_parm_decl (tree *expr_p)\n+{\n+  tree decl = *expr_p;\n+\n+  /* ??? If this is a local variable, and it has not been seen in any\n+     outer BIND_EXPR, then it's probably the result of a duplicate\n+     declaration, for which we've already issued an error.  It would\n+     be really nice if the front end wouldn't leak these at all.\n+     Currently the only known culprit is C++ destructors, as seen\n+     in g++.old-deja/g++.jason/binding.C.  */\n+  if (TREE_CODE (decl) == VAR_DECL\n+      && !DECL_SEEN_IN_BIND_EXPR_P (decl)\n+      && !TREE_STATIC (decl) && !DECL_EXTERNAL (decl)\n+      && decl_function_context (decl) == current_function_decl)\n+    {\n+      gcc_assert (errorcount || sorrycount);\n+      return GS_ERROR;\n+    }\n+\n+  /* If the decl is an alias for another expression, substitute it now.  */\n+  if (DECL_HAS_VALUE_EXPR_P (decl))\n+    {\n+      *expr_p = unshare_expr (DECL_VALUE_EXPR (decl));\n+      return GS_OK;\n+    }\n+\n+  return GS_ALL_DONE;\n+}\n+\n+\n /* Gimplify the COMPONENT_REF, ARRAY_REF, REALPART_EXPR or IMAGPART_EXPR\n    node pointed to by EXPR_P.\n \n@@ -1506,11 +1540,21 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n   /* We can handle anything that get_inner_reference can deal with.  */\n   for (p = expr_p; ; p = &TREE_OPERAND (*p, 0))\n     {\n+    restart:\n       /* Fold INDIRECT_REFs now to turn them into ARRAY_REFs.  */\n       if (TREE_CODE (*p) == INDIRECT_REF)\n \t*p = fold_indirect_ref (*p);\n-      if (!handled_component_p (*p))\n+\n+      if (handled_component_p (*p))\n+\t;\n+      /* Expand DECL_VALUE_EXPR now.  In some cases that may expose\n+\t additional COMPONENT_REFs.  */\n+      else if ((TREE_CODE (*p) == VAR_DECL || TREE_CODE (*p) == PARM_DECL)\n+\t       && gimplify_var_or_parm_decl (p) == GS_OK)\n+\tgoto restart;\n+      else\n \tbreak;\n+\t       \n       VEC_safe_push (tree, heap, stack, *p);\n     }\n \n@@ -1592,8 +1636,11 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n \t}\n     }\n \n-  /* Step 2 is to gimplify the base expression.  */\n-  tret = gimplify_expr (p, pre_p, post_p, is_gimple_min_lval, fallback);\n+  /* Step 2 is to gimplify the base expression.  Make sure lvalue is set\n+     so as to match the min_lval predicate.  Failure to do so may result\n+     in the creation of large aggregate temporaries.  */\n+  tret = gimplify_expr (p, pre_p, post_p, is_gimple_min_lval,\n+\t\t\tfallback | fb_lvalue);\n   ret = MIN (ret, tret);\n \n   /* And finally, the indices and operands to BIT_FIELD_REF.  During this\n@@ -4371,36 +4418,8 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  break;\n \n \tcase VAR_DECL:\n-\t  /* ??? If this is a local variable, and it has not been seen in any\n-\t     outer BIND_EXPR, then it's probably the result of a duplicate\n-\t     declaration, for which we've already issued an error.  It would\n-\t     be really nice if the front end wouldn't leak these at all.\n-\t     Currently the only known culprit is C++ destructors, as seen\n-\t     in g++.old-deja/g++.jason/binding.C.  */\n-\t  tmp = *expr_p;\n-\t  if (!TREE_STATIC (tmp) && !DECL_EXTERNAL (tmp)\n-\t      && decl_function_context (tmp) == current_function_decl\n-\t      && !DECL_SEEN_IN_BIND_EXPR_P (tmp))\n-\t    {\n-\t      gcc_assert (errorcount || sorrycount);\n-\t      ret = GS_ERROR;\n-\t      break;\n-\t    }\n-\t  /* FALLTHRU */\n-\n \tcase PARM_DECL:\n-\t  tmp = *expr_p;\n-\n-\t  /* If this is a local variable sized decl, it must be accessed\n-\t     indirectly.  Perform that substitution.  */\n-\t  if (DECL_HAS_VALUE_EXPR_P (tmp))\n-\t    {\n-\t      *expr_p = unshare_expr (DECL_VALUE_EXPR (tmp));\n-\t      ret = GS_OK;\n-\t      break;\n-\t    }\n-\n-\t  ret = GS_ALL_DONE;\n+\t  ret = gimplify_var_or_parm_decl (expr_p);\n \t  break;\n \n \tcase SSA_NAME:"}]}