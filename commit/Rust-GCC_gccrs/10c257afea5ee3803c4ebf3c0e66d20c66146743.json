{"sha": "10c257afea5ee3803c4ebf3c0e66d20c66146743", "node_id": "C_kwDOANBUbNoAKDEwYzI1N2FmZWE1ZWUzODAzYzRlYmYzYzBlNjZkMjBjNjYxNDY3NDM", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2022-04-08T17:48:10Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-19T14:05:29Z"}, "message": "[Ada] Support Ada 2022 null array aggregates\n\nAdd support for Ada 2022's \"[]\" null array aggregates (thanks to Ed\nSchonberg for producing most of this patch).\n\ngcc/ada/\n\n\t* erroutc.ads: Fix a single-character typo in a comment.\n\t* exp_aggr.adb: Fix a single-character typo in a comment.\n\tReplace several pairs of calls to Low_Bound and\n\tHigh_Bound (which do not handle an identifier that denotes a\n\tscalar subtype) with corresponding calls to Get_Index_Bounds\n\t(which does handle that case).\n\t* par-ch4.adb (P_Aggregate_Or_Paren_Expr): Set the\n\tComponent_Associations attribute of a null array aggregate to\n\tNew_List.\n\t* sem_aggr.ads: New visible function\n\tIs_Null_Array_Aggregate_High_Bound.\n\t* sem_aggr.adb (Is_Null_Array_Aggregate_High_Bound,\n\tIs_Null_Aggregate, Resolve_Null_Array_Aggregate): New functions.\n\t(Resolve_Aggregate): Recognize null array aggregates (using\n\tIs_Null_Aggregate) and, when one is recognized, resolve\n\tit (using Resolve_Null_Array_Aggregate).  Avoid calling\n\tArray_Aggr_Subtype for a null array aggregate; the needed\n\tsubtype is built in Resolve_Null_Array_Aggregate. Do not\n\tincorrectly flag a null aggregate (after it is transformed by\n\texpansion) as being both positional and named.\n\t* sem_attr.adb (Eval_Attribute): Special treatment for null\n\tarray aggregate high bounds to avoid incorrectly flagging\n\tsomething like Integer'Pred (Integer'First) as an illegal static\n\texpression.\n\t* sem_eval.adb (Out_Of_Range): Special treatment for null array\n\taggregate high bounds to avoid incorrectly flagging something\n\tlike Integer'Pred (Integer'First) as an illegal static\n\texpression.", "tree": {"sha": "5074ef7a986c8e2fe0de0cdbf891951489de7d5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5074ef7a986c8e2fe0de0cdbf891951489de7d5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10c257afea5ee3803c4ebf3c0e66d20c66146743", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10c257afea5ee3803c4ebf3c0e66d20c66146743", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10c257afea5ee3803c4ebf3c0e66d20c66146743", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10c257afea5ee3803c4ebf3c0e66d20c66146743/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "054cf924ac00a47301a1c49f6433f70775fe1c0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/054cf924ac00a47301a1c49f6433f70775fe1c0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/054cf924ac00a47301a1c49f6433f70775fe1c0d"}], "stats": {"total": 215, "additions": 197, "deletions": 18}, "files": [{"sha": "be8755b316e044ee14b4af088eb8e47d7e611029", "filename": "gcc/ada/erroutc.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c257afea5ee3803c4ebf3c0e66d20c66146743/gcc%2Fada%2Ferroutc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c257afea5ee3803c4ebf3c0e66d20c66146743/gcc%2Fada%2Ferroutc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferroutc.ads?ref=10c257afea5ee3803c4ebf3c0e66d20c66146743", "patch": "@@ -465,7 +465,7 @@ package Erroutc is\n    --  Tests if message buffer ends with given string preceded by a space\n \n    procedure Buffer_Remove (C : Character);\n-   --  Remove given character fron end of buffer if it is present\n+   --  Remove given character from end of buffer if it is present\n \n    procedure Buffer_Remove (S : String);\n    --  Removes given string from end of buffer if it is present at end of"}, {"sha": "13be987b3e6c0f500e52144a59859f817d755fba", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c257afea5ee3803c4ebf3c0e66d20c66146743/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c257afea5ee3803c4ebf3c0e66d20c66146743/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=10c257afea5ee3803c4ebf3c0e66d20c66146743", "patch": "@@ -2280,8 +2280,10 @@ package body Exp_Aggr is\n \n       New_Code : constant List_Id := New_List;\n \n-      Aggr_L : constant Node_Id := Low_Bound (Aggregate_Bounds (N));\n-      Aggr_H : constant Node_Id := High_Bound (Aggregate_Bounds (N));\n+      Aggr_Bounds : constant Range_Nodes :=\n+        Get_Index_Bounds (Aggregate_Bounds (N));\n+      Aggr_L : Node_Id renames Aggr_Bounds.First;\n+      Aggr_H : Node_Id renames Aggr_Bounds.Last;\n       --  The aggregate bounds of this specific subaggregate. Note that if the\n       --  code generated by Build_Array_Aggr_Code is executed then these bounds\n       --  are OK. Otherwise a Constraint_Error would have been raised.\n@@ -2577,7 +2579,7 @@ package body Exp_Aggr is\n       --  If Typ is derived, and constrains discriminants of the parent type,\n       --  these discriminants are not components of the aggregate, and must be\n       --  initialized. The assignments are appended to List. The same is done\n-      --  if Typ derives fron an already constrained subtype of a discriminated\n+      --  if Typ derives from an already constrained subtype of a discriminated\n       --  parent type.\n \n       procedure Init_Stored_Discriminants;\n@@ -5226,6 +5228,11 @@ package body Exp_Aggr is\n          Others_Present := False;\n \n          if Present (Component_Associations (N)) then\n+            if Is_Empty_List (Component_Associations (N)) then\n+               --  an expanded null array aggregate\n+               return False;\n+            end if;\n+\n             declare\n                Assoc   : Node_Id;\n                Choice  : Node_Id;\n@@ -5914,8 +5921,10 @@ package body Exp_Aggr is\n       ----------------------------\n \n       procedure Check_Same_Aggr_Bounds (Sub_Aggr : Node_Id; Dim : Pos) is\n-         Sub_Lo : constant Node_Id := Low_Bound (Aggregate_Bounds (Sub_Aggr));\n-         Sub_Hi : constant Node_Id := High_Bound (Aggregate_Bounds (Sub_Aggr));\n+         Sub_Bounds : constant Range_Nodes\n+           := Get_Index_Bounds (Aggregate_Bounds (Sub_Aggr));\n+         Sub_Lo : Node_Id renames Sub_Bounds.First;\n+         Sub_Hi : Node_Id renames Sub_Bounds.Last;\n          --  The bounds of this specific subaggregate\n \n          Aggr_Lo : constant Node_Id := Aggr_Low (Dim);\n@@ -6019,7 +6028,9 @@ package body Exp_Aggr is\n          if Present (Component_Associations (Sub_Aggr)) then\n             Assoc := Last (Component_Associations (Sub_Aggr));\n \n-            if Nkind (First (Choice_List (Assoc))) = N_Others_Choice then\n+            if Present (Assoc)\n+              and then Nkind (First (Choice_List (Assoc))) = N_Others_Choice\n+            then\n                Others_Present (Dim) := True;\n \n                --  An others_clause may be superfluous if previous components\n@@ -6107,7 +6118,10 @@ package body Exp_Aggr is\n          elsif Present (Expressions (Sub_Aggr))\n            and then Present (Component_Associations (Sub_Aggr))\n          then\n-            Need_To_Check := True;\n+            Need_To_Check :=\n+              not (Is_Empty_List (Expressions (Sub_Aggr))\n+                    and then Is_Empty_List\n+                               (Component_Associations (Sub_Aggr)));\n \n          elsif Present (Component_Associations (Sub_Aggr)) then\n             Assoc := Last (Component_Associations (Sub_Aggr));\n@@ -6666,8 +6680,8 @@ package body Exp_Aggr is\n             --  Save the low and high bounds of the aggregate index as well as\n             --  the index type for later use in checks (b) and (c) below.\n \n-            Aggr_Low  (J) := Low_Bound (Aggr_Index_Range);\n-            Aggr_High (J) := High_Bound (Aggr_Index_Range);\n+            Get_Index_Bounds\n+              (Aggr_Index_Range, L => Aggr_Low (J), H => Aggr_High (J));\n \n             Aggr_Index_Typ (J) := Etype (Index_Constraint);\n \n@@ -7180,7 +7194,8 @@ package body Exp_Aggr is\n                MX : constant         := 80;\n \n             begin\n-               if Nkind (First (Choice_List (CA))) = N_Others_Choice\n+               if Present (CA)\n+                 and then Nkind (First (Choice_List (CA))) = N_Others_Choice\n                  and then Nkind (Expression (CA)) = N_Character_Literal\n                  and then No (Expressions (N))\n                then"}, {"sha": "4ab4dcb0920b993b61245f97fc1a050927304015", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c257afea5ee3803c4ebf3c0e66d20c66146743/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c257afea5ee3803c4ebf3c0e66d20c66146743/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=10c257afea5ee3803c4ebf3c0e66d20c66146743", "patch": "@@ -1405,6 +1405,7 @@ package body Ch4 is\n             Scan;   --  past ]\n             Aggregate_Node := New_Node (N_Aggregate, Lparen_Sloc);\n             Set_Expressions (Aggregate_Node, New_List);\n+            Set_Component_Associations (Aggregate_Node, New_List);\n             Set_Is_Homogeneous_Aggregate (Aggregate_Node);\n             return Aggregate_Node;\n          end if;"}, {"sha": "b85f766f82ca44f1f66d44e53206c285136df6b0", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 129, "deletions": 4, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c257afea5ee3803c4ebf3c0e66d20c66146743/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c257afea5ee3803c4ebf3c0e66d20c66146743/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=10c257afea5ee3803c4ebf3c0e66d20c66146743", "patch": "@@ -404,11 +404,25 @@ package body Sem_Aggr is\n    --  The bounds of the aggregate itype are cooked up to look reasonable\n    --  (in this particular case the bounds will be 1 .. 2).\n \n+   function Is_Null_Aggregate (N : Node_Id) return Boolean;\n+   --  Returns True for a \"[]\" aggregate (an Ada 2022 feature), even after\n+   --  it has been transformed by expansion. Returns False otherwise.\n+\n    procedure Make_String_Into_Aggregate (N : Node_Id);\n    --  A string literal can appear in a context in which a one dimensional\n    --  array of characters is expected. This procedure simply rewrites the\n    --  string as an aggregate, prior to resolution.\n \n+   function Resolve_Null_Array_Aggregate (N : Node_Id) return Boolean;\n+   --  For the Ada 2022 construct, build a subtype with a null range for each\n+   --  dimension, using the bounds from the context subtype (if the subtype\n+   --  is constrained). If the subtype is unconstrained, then the bounds\n+   --  are determined in much the same way as the bounds for a null string\n+   --  literal with no applicable index constraint.\n+   --  Emit a check that the bounds for each dimension define a null\n+   --  range; no check is emitted if it is statically known that the\n+   --  check would succeed.\n+\n    ---------------------------------\n    --  Delta aggregate processing --\n    ---------------------------------\n@@ -754,6 +768,34 @@ package body Sem_Aggr is\n         and then No (Next (First (Choice_List (First (Assoc)))));\n    end Is_Single_Aggregate;\n \n+   -----------------------\n+   -- Is_Null_Aggregate --\n+   -----------------------\n+\n+   function Is_Null_Aggregate (N : Node_Id) return Boolean is\n+   begin\n+      return Ada_Version >= Ada_2022\n+        and then Is_Homogeneous_Aggregate (N)\n+        and then Is_Empty_List (Expressions (N))\n+        and then Is_Empty_List (Component_Associations (N));\n+   end Is_Null_Aggregate;\n+\n+   ----------------------------------------\n+   -- Is_Null_Array_Aggregate_High_Bound --\n+   ----------------------------------------\n+\n+   function Is_Null_Array_Aggregate_High_Bound (N : Node_Id) return Boolean is\n+      Original_N : constant Node_Id := Original_Node (N);\n+   begin\n+      return Ada_Version >= Ada_2022\n+        and then not Comes_From_Source (Original_N)\n+        and then Nkind (Original_N) = N_Attribute_Reference\n+        and then\n+          Get_Attribute_Id (Attribute_Name (Original_N)) = Attribute_Pred\n+        and then Nkind (Parent (N)) in N_Range | N_Op_Le\n+        and then not Comes_From_Source (Parent (N));\n+   end Is_Null_Array_Aggregate_High_Bound;\n+\n    --------------------------------\n    -- Make_String_Into_Aggregate --\n    --------------------------------\n@@ -983,13 +1025,14 @@ package body Sem_Aggr is\n \n          Array_Aggregate : declare\n             Aggr_Resolved : Boolean;\n-\n             Aggr_Typ : constant Entity_Id := Etype (Typ);\n             --  This is the unconstrained array type, which is the type against\n             --  which the aggregate is to be resolved. Typ itself is the array\n             --  type of the context which may not be the same subtype as the\n             --  subtype for the final aggregate.\n \n+            Is_Null_Aggr : constant Boolean := Is_Null_Aggregate (N);\n+\n          begin\n             --  In the following we determine whether an OTHERS choice is\n             --  allowed inside the array aggregate. The test checks the context\n@@ -1021,7 +1064,11 @@ package body Sem_Aggr is\n \n             Set_Etype (N, Aggr_Typ);  --  May be overridden later on\n \n-            if Nkind (Parent (N)) = N_Assignment_Statement\n+            if Is_Null_Aggr then\n+               Set_Etype (N, Typ);\n+               Aggr_Resolved := Resolve_Null_Array_Aggregate (N);\n+\n+            elsif Nkind (Parent (N)) = N_Assignment_Statement\n               or else Inside_Init_Proc\n               or else (Is_Constrained (Typ)\n                         and then Nkind (Parent (N)) in\n@@ -1074,6 +1121,9 @@ package body Sem_Aggr is\n \n                Aggr_Subtyp := Any_Composite;\n \n+            elsif Is_Null_Aggr then\n+               Aggr_Subtyp := Etype (N);\n+\n             else\n                Aggr_Subtyp := Array_Aggr_Subtype (N, Typ);\n             end if;\n@@ -3139,8 +3189,12 @@ package body Sem_Aggr is\n                end loop;\n             end if;\n \n-            if Present (Component_Associations (N)) then\n-               if Present (Expressions (N)) then\n+            if Present (Component_Associations (N))\n+              and then not Is_Empty_List (Component_Associations (N))\n+            then\n+               if Present (Expressions (N))\n+                 and then not Is_Empty_List (Expressions (N))\n+               then\n                   Error_Msg_N (\"container aggregate cannot be \"\n                     & \"both positional and named\", N);\n                   return;\n@@ -3957,6 +4011,77 @@ package body Sem_Aggr is\n       Check_Function_Writable_Actuals (N);\n    end Resolve_Extension_Aggregate;\n \n+   ----------------------------------\n+   -- Resolve_Null_Array_Aggregate --\n+   ----------------------------------\n+\n+   function Resolve_Null_Array_Aggregate (N : Node_Id) return Boolean is\n+      --  Never returns False, but declared as a function to match\n+      --  other Resolve_Mumble functions.\n+\n+      Loc    : constant Source_Ptr := Sloc (N);\n+      Typ    : constant Entity_Id := Etype (N);\n+\n+      Check  : Node_Id;\n+      Decl   : Node_Id;\n+      Index  : Node_Id;\n+      Lo, Hi : Node_Id;\n+      Constr : constant List_Id := New_List;\n+      Subt   : constant Entity_Id := Make_Temporary (Loc, 'S');\n+\n+   begin\n+      --  Create a constrained subtype with null dimensions\n+\n+      Index := First_Index (Typ);\n+      while Present (Index) loop\n+         Get_Index_Bounds (Index, L => Lo, H => Hi);\n+\n+         --  The upper bound is the predecessor of the lower bound\n+\n+         Hi := Make_Attribute_Reference\n+            (Loc,\n+             Prefix         => New_Occurrence_Of (Etype (Index), Loc),\n+             Attribute_Name => Name_Pred,\n+             Expressions    => New_List (New_Copy_Tree (Lo)));\n+\n+         --  Check that high bound (i.e., low bound predecessor) exists.\n+         --  Fail if low bound is low bound of base subtype (in all cases,\n+         --  including modular).\n+\n+         Check :=\n+           Make_If_Statement (Loc,\n+             Condition =>\n+               Make_Op_Le (Loc, New_Copy_Tree (Lo), New_Copy_Tree (Hi)),\n+             Then_Statements =>\n+               New_List (Make_Raise_Constraint_Error\n+                           (Loc, Reason => CE_Range_Check_Failed)));\n+\n+         Insert_Action (N, Check);\n+\n+         Append (Make_Range (Loc, Lo, Hi), Constr);\n+\n+         Index := Next_Index (Index);\n+      end loop;\n+\n+      Decl := Make_Subtype_Declaration (Loc,\n+                Defining_Identifier => Subt,\n+                Subtype_Indication  =>\n+                  Make_Subtype_Indication (Loc,\n+                    Subtype_Mark =>\n+                      New_Occurrence_Of (Base_Type (Typ), Loc),\n+                    Constraint =>\n+                      Make_Index_Or_Discriminant_Constraint (Loc, Constr)));\n+\n+      Insert_Action (N, Decl);\n+      Set_Is_Internal (Subt);\n+      Analyze (Decl);\n+      Set_Etype (N, Subt);\n+      Set_Compile_Time_Known_Aggregate (N);\n+      Set_Aggregate_Bounds (N, New_Copy_Tree (First_Index (Etype (N))));\n+\n+      return True;\n+   end Resolve_Null_Array_Aggregate;\n+\n    ------------------------------\n    -- Resolve_Record_Aggregate --\n    ------------------------------"}, {"sha": "75af8f7ce07ca593d6f8517fd2a66a4c0a6519c7", "filename": "gcc/ada/sem_aggr.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c257afea5ee3803c4ebf3c0e66d20c66146743/gcc%2Fada%2Fsem_aggr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c257afea5ee3803c4ebf3c0e66d20c66146743/gcc%2Fada%2Fsem_aggr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.ads?ref=10c257afea5ee3803c4ebf3c0e66d20c66146743", "patch": "@@ -43,4 +43,7 @@ package Sem_Aggr is\n \n    --  WARNING: There is a matching C declaration of this subprogram in fe.h\n \n+   function Is_Null_Array_Aggregate_High_Bound (N : Node_Id) return Boolean;\n+   --  Returns True for the high bound of a null array aggregate.\n+\n end Sem_Aggr;"}, {"sha": "7b05cdc2bd6e53ec20d178b728e586056a3ba0d1", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c257afea5ee3803c4ebf3c0e66d20c66146743/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c257afea5ee3803c4ebf3c0e66d20c66146743/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=10c257afea5ee3803c4ebf3c0e66d20c66146743", "patch": "@@ -52,6 +52,7 @@ with Rident;         use Rident;\n with Rtsfind;        use Rtsfind;\n with Sdefault;\n with Sem;            use Sem;\n+with Sem_Aggr;       use Sem_Aggr;\n with Sem_Aux;        use Sem_Aux;\n with Sem_Cat;        use Sem_Cat;\n with Sem_Ch6;        use Sem_Ch6;\n@@ -8438,6 +8439,12 @@ package body Sem_Attr is\n             or else (Is_Static_Expression (E2)\n                       and then Is_Scalar_Type (Etype (E1))))\n         and then Id /= Attribute_Descriptor_Size\n+\n+        --  If the front-end conjures up Integer'Pred (Integer'First)\n+        --  as the high bound of a null array aggregate, then we don't\n+        --  want to reject that as an illegal static expression.\n+\n+        and then not Is_Null_Array_Aggregate_High_Bound (N)\n       then\n          Static := True;\n          Set_Is_Static_Expression (N, True);\n@@ -9923,6 +9930,25 @@ package body Sem_Attr is\n \n                Check_Expressions;\n                return;\n+\n+            --  Rewrite the FE-constructed high bound of a null array\n+            --  aggregate to raise CE.\n+\n+            elsif Is_Signed_Integer_Type (P_Type)\n+              and then Expr_Value (E1) =\n+                         Expr_Value (Type_Low_Bound (P_Base_Type))\n+              and then Is_Null_Array_Aggregate_High_Bound (N)\n+            then\n+               Apply_Compile_Time_Constraint_Error\n+                 (N, \"Pred of `&''First`\",\n+                  CE_Overflow_Check_Failed,\n+                  Ent  => P_Base_Type,\n+                  Warn => True);\n+\n+               Rewrite (N, Make_Raise_Constraint_Error (Sloc (N),\n+                             Reason => CE_Overflow_Check_Failed));\n+               Set_Etype (N, P_Base_Type);\n+               return;\n             end if;\n \n             Fold_Uint (N, Expr_Value (E1) - 1, Static);"}, {"sha": "553c7e1cc8617f304e18981eca99a56f84443bd9", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c257afea5ee3803c4ebf3c0e66d20c66146743/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c257afea5ee3803c4ebf3c0e66d20c66146743/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=10c257afea5ee3803c4ebf3c0e66d20c66146743", "patch": "@@ -43,6 +43,7 @@ with Opt;            use Opt;\n with Par_SCO;        use Par_SCO;\n with Rtsfind;        use Rtsfind;\n with Sem;            use Sem;\n+with Sem_Aggr;       use Sem_Aggr;\n with Sem_Aux;        use Sem_Aux;\n with Sem_Cat;        use Sem_Cat;\n with Sem_Ch3;        use Sem_Ch3;\n@@ -6054,6 +6055,16 @@ package body Sem_Eval is\n    ------------------\n \n    procedure Out_Of_Range (N : Node_Id) is\n+\n+      --  If the FE conjures up an expression that would normally be\n+      --  an illegal static expression (e.g., an integer literal with\n+      --  a value outside of its base subtype), we don't want to\n+      --  flag it as illegal; we only want a warning in such cases.\n+\n+      function Force_Warning return Boolean is\n+        (if Comes_From_Source (Original_Node (N)) then False\n+         elsif Nkind (Original_Node (N)) = N_Type_Conversion then True\n+         else Is_Null_Array_Aggregate_High_Bound (N));\n    begin\n       --  If we have the static expression case, then this is an illegality\n       --  in Ada 95 mode, except that in an instance, we never generate an\n@@ -6093,9 +6104,7 @@ package body Sem_Eval is\n             --  Determine if the out-of-range violation constitutes a warning\n             --  or an error based on context, according to RM 4.9 (34/3).\n \n-            if Nkind (Original_Node (N)) = N_Type_Conversion\n-              and then not Comes_From_Source (Original_Node (N))\n-            then\n+            if Force_Warning then\n                Apply_Compile_Time_Constraint_Error\n                  (N, \"value not in range of}??\", CE_Range_Check_Failed);\n             else"}]}