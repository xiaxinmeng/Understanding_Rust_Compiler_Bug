{"sha": "a5b3d713ccade591a3dd972f5586912f8ef5cb48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTViM2Q3MTNjY2FkZTU5MWEzZGQ5NzJmNTU4NjkxMmY4ZWY1Y2I0OA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-11-09T19:36:54Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-11-09T19:36:54Z"}, "message": "symbol.c (clear_sym_mark, [...]): Remove functions.\n\n2011-11-09  Tobias Burnus  <burnus@net-b.de>\n\n        * symbol.c (clear_sym_mark, traverse_ns): Remove functions.\n        (count_st_nodes, do_traverse_symtree, fill_st_vector): New functions.\n        (gfc_traverse_symtree, gfc_traverse_ns): Call do_traverse_symtree.\n\nFrom-SVN: r181232", "tree": {"sha": "49fac99f233a41394dac7a4594189d6e57d2bc08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49fac99f233a41394dac7a4594189d6e57d2bc08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5b3d713ccade591a3dd972f5586912f8ef5cb48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5b3d713ccade591a3dd972f5586912f8ef5cb48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5b3d713ccade591a3dd972f5586912f8ef5cb48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5b3d713ccade591a3dd972f5586912f8ef5cb48/comments", "author": null, "committer": null, "parents": [{"sha": "5cc66776c46dedbda21a89d5422663feb4a7cc45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cc66776c46dedbda21a89d5422663feb4a7cc45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cc66776c46dedbda21a89d5422663feb4a7cc45"}], "stats": {"total": 94, "additions": 66, "deletions": 28}, "files": [{"sha": "dca83988744b87b488fcd3730cd48ee64d09e37c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5b3d713ccade591a3dd972f5586912f8ef5cb48/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5b3d713ccade591a3dd972f5586912f8ef5cb48/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a5b3d713ccade591a3dd972f5586912f8ef5cb48", "patch": "@@ -1,7 +1,13 @@\n+2011-11-09  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* symbol.c (clear_sym_mark, traverse_ns): Remove functions.\n+\t(count_st_nodes, do_traverse_symtree, fill_st_vector): New functions.\n+\t(gfc_traverse_symtree, gfc_traverse_ns): Call do_traverse_symtree.\n+\n 2011-11-09  Janne Blomqvist  <jb@gcc.gnu.org>\n \n-        PR libfortran/50016\n-        * gfortran.texi (Data consistency and durability): New section.\n+\tPR libfortran/50016\n+\t* gfortran.texi (Data consistency and durability): New section.\n \n 2011-11-09  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n@@ -638,7 +644,7 @@\n 2011-10-23  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* simplify.c (simplify_transformation_to_array): Fix memory leak.\n- \n+\n 2011-10-20  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/50821"}, {"sha": "33ec706f40a627734b8b47f52cdd4ac114e616be", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 57, "deletions": 25, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5b3d713ccade591a3dd972f5586912f8ef5cb48/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5b3d713ccade591a3dd972f5586912f8ef5cb48/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=a5b3d713ccade591a3dd972f5586912f8ef5cb48", "patch": "@@ -3310,59 +3310,91 @@ gfc_symbol_done_2 (void)\n }\n \n \n-/* Clear mark bits from symbol nodes associated with a symtree node.  */\n+/* Count how many nodes a symtree has.  */\n \n-static void\n-clear_sym_mark (gfc_symtree *st)\n+static unsigned\n+count_st_nodes (const gfc_symtree *st)\n {\n+  unsigned nodes;\n+  if (!st)\n+    return 0;\n \n-  st->n.sym->mark = 0;\n+  nodes = count_st_nodes (st->left);\n+  nodes++;\n+  nodes += count_st_nodes (st->right);\n+\n+  return nodes;\n }\n \n \n-/* Recursively traverse the symtree nodes.  */\n+/* Convert symtree tree into symtree vector.  */\n \n-void\n-gfc_traverse_symtree (gfc_symtree *st, void (*func) (gfc_symtree *))\n+static unsigned\n+fill_st_vector (gfc_symtree *st, gfc_symtree **st_vec, unsigned node_cntr)\n {\n   if (!st)\n-    return;\n+    return node_cntr;\n+\n+  node_cntr = fill_st_vector (st->left, st_vec, node_cntr);\n+  st_vec[node_cntr++] = st;\n+  node_cntr = fill_st_vector (st->right, st_vec, node_cntr);\n \n-  gfc_traverse_symtree (st->left, func);\n-  (*func) (st);\n-  gfc_traverse_symtree (st->right, func);\n+  return node_cntr;\n }\n \n \n-/* Recursive namespace traversal function.  */\n+/* Traverse namespace.  As the functions might modify the symtree, we store the\n+   symtree as a vector and operate on this vector.  Note: We assume that\n+   sym_func or st_func never deletes nodes from the symtree - only adding is\n+   allowed. Additionally, newly added nodes are not traversed.  */\n \n static void\n-traverse_ns (gfc_symtree *st, void (*func) (gfc_symbol *))\n+do_traverse_symtree (gfc_symtree *st, void (*st_func) (gfc_symtree *),\n+\t\t     void (*sym_func) (gfc_symbol *))\n {\n+  gfc_symtree **st_vec;\n+  unsigned nodes, i, node_cntr;\n \n-  if (st == NULL)\n-    return;\n+  gcc_assert ((st_func && !sym_func) || (!st_func && sym_func));\n+  nodes = count_st_nodes (st);\n+  st_vec = XALLOCAVEC (gfc_symtree *, nodes);\n+  node_cntr = 0; \n+  fill_st_vector (st, st_vec, node_cntr);\n+\n+  if (sym_func)\n+    {\n+      /* Clear marks.  */\n+      for (i = 0; i < nodes; i++)\n+\tst_vec[i]->n.sym->mark = 0;\n+      for (i = 0; i < nodes; i++)\n+\tif (!st_vec[i]->n.sym->mark)\n+\t  {\n+\t    (*sym_func) (st_vec[i]->n.sym);\n+\t    st_vec[i]->n.sym->mark = 1;\n+\t  }\n+     }\n+   else\n+      for (i = 0; i < nodes; i++)\n+\t(*st_func) (st_vec[i]);\n+}\n \n-  traverse_ns (st->left, func);\n \n-  if (st->n.sym->mark == 0)\n-    (*func) (st->n.sym);\n-  st->n.sym->mark = 1;\n+/* Recursively traverse the symtree nodes.  */\n \n-  traverse_ns (st->right, func);\n+void\n+gfc_traverse_symtree (gfc_symtree *st, void (*st_func) (gfc_symtree *))\n+{\n+  do_traverse_symtree (st, st_func, NULL);\n }\n \n \n /* Call a given function for all symbols in the namespace.  We take\n    care that each gfc_symbol node is called exactly once.  */\n \n void\n-gfc_traverse_ns (gfc_namespace *ns, void (*func) (gfc_symbol *))\n+gfc_traverse_ns (gfc_namespace *ns, void (*sym_func) (gfc_symbol *))\n {\n-\n-  gfc_traverse_symtree (ns->sym_root, clear_sym_mark);\n-\n-  traverse_ns (ns->sym_root, func);\n+  do_traverse_symtree (ns->sym_root, NULL, sym_func);\n }\n \n "}]}