{"sha": "03d1cb6dc60e6386d484bc4ba77a837ce0dffef6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNkMWNiNmRjNjBlNjM4NmQ0ODRiYzRiYTc3YTgzN2NlMGRmZmVmNg==", "commit": {"author": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2003-10-30T00:30:37Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2003-10-30T00:30:37Z"}, "message": "* pa.md: Missed update in previous commit.\n\nFrom-SVN: r73072", "tree": {"sha": "5d59d27d25ea4dcd4692c69a9ebab7aeb345077f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d59d27d25ea4dcd4692c69a9ebab7aeb345077f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03d1cb6dc60e6386d484bc4ba77a837ce0dffef6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03d1cb6dc60e6386d484bc4ba77a837ce0dffef6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03d1cb6dc60e6386d484bc4ba77a837ce0dffef6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03d1cb6dc60e6386d484bc4ba77a837ce0dffef6/comments", "author": null, "committer": null, "parents": [{"sha": "2df99aea861fac8a3308ffc474a384637d2289c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2df99aea861fac8a3308ffc474a384637d2289c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2df99aea861fac8a3308ffc474a384637d2289c2"}], "stats": {"total": 226, "additions": 164, "deletions": 62}, "files": [{"sha": "79f2e26cd27be0ab4c3af1594130d40f50af721f", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 164, "deletions": 62, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d1cb6dc60e6386d484bc4ba77a837ce0dffef6/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d1cb6dc60e6386d484bc4ba77a837ce0dffef6/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=03d1cb6dc60e6386d484bc4ba77a837ce0dffef6", "patch": "@@ -32,7 +32,7 @@\n ;; type \"binary\" insns have two input operands (1,2) and one output (0)\n \n (define_attr \"type\"\n-  \"move,unary,binary,shift,nullshift,compare,load,store,uncond_branch,branch,cbranch,fbranch,call,dyncall,fpload,fpstore,fpalu,fpcc,fpmulsgl,fpmuldbl,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl,multi,milli,parallel_branch\"\n+  \"move,unary,binary,shift,nullshift,compare,load,store,uncond_branch,btable_branch,branch,cbranch,fbranch,call,dyncall,fpload,fpstore,fpalu,fpcc,fpmulsgl,fpmuldbl,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl,multi,milli,parallel_branch\"\n   (const_string \"binary\"))\n \n (define_attr \"pa_combine_type\"\n@@ -74,23 +74,23 @@\n \n ;; For conditional branches.\n (define_attr \"in_branch_delay\" \"false,true\"\n-  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,cbranch,fbranch,call,dyncall,multi,milli,parallel_branch\")\n+  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,btable_branch,branch,cbranch,fbranch,call,dyncall,multi,milli,parallel_branch\")\n \t\t     (eq_attr \"length\" \"4\"))\n \t\t(const_string \"true\")\n \t\t(const_string \"false\")))\n \n ;; Disallow instructions which use the FPU since they will tie up the FPU\n ;; even if the instruction is nullified.\n (define_attr \"in_nullified_branch_delay\" \"false,true\"\n-  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,cbranch,fbranch,call,dyncall,multi,milli,fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl,parallel_branch\")\n+  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,btable_branch,branch,cbranch,fbranch,call,dyncall,multi,milli,fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl,parallel_branch\")\n \t\t     (eq_attr \"length\" \"4\"))\n \t\t(const_string \"true\")\n \t\t(const_string \"false\")))\n \n ;; For calls and millicode calls.  Allow unconditional branches in the\n ;; delay slot.\n (define_attr \"in_call_delay\" \"false,true\"\n-  (cond [(and (eq_attr \"type\" \"!uncond_branch,branch,cbranch,fbranch,call,dyncall,multi,milli,parallel_branch\")\n+  (cond [(and (eq_attr \"type\" \"!uncond_branch,btable_branch,branch,cbranch,fbranch,call,dyncall,multi,milli,parallel_branch\")\n \t      (eq_attr \"length\" \"4\"))\n \t   (const_string \"true\")\n \t (eq_attr \"type\" \"uncond_branch\")\n@@ -110,7 +110,7 @@\n   [(eq_attr \"in_call_delay\" \"true\") (nil) (nil)])\n \n ;; Return and other similar instructions.\n-(define_delay (eq_attr \"type\" \"branch,parallel_branch\")\n+(define_delay (eq_attr \"type\" \"btable_branch,branch,parallel_branch\")\n   [(eq_attr \"in_branch_delay\" \"true\") (nil) (nil)])\n \n ;; Floating point conditional branch delay slot description and\n@@ -505,15 +505,15 @@\n ;; to assume have zero latency.\n (define_insn_reservation \"Z2\" 0\n   (and\n-    (eq_attr \"type\" \"!load,fpload,store,fpstore,uncond_branch,branch,cbranch,fbranch,call,dyncall,multi,milli,parallel_branch,fpcc,fpalu,fpmulsgl,fpmuldbl,fpsqrtsgl,fpsqrtdbl,fpdivsgl,fpdivdbl\")\n+    (eq_attr \"type\" \"!load,fpload,store,fpstore,uncond_branch,btable_branch,branch,cbranch,fbranch,call,dyncall,multi,milli,parallel_branch,fpcc,fpalu,fpmulsgl,fpmuldbl,fpsqrtsgl,fpsqrtdbl,fpdivsgl,fpdivdbl\")\n     (eq_attr \"cpu\" \"8000\"))\n   \"inm_8000,rnm_8000\")\n \n ;; Branches use both slots in the non-memory issue and\n ;; retirement unit.\n (define_insn_reservation \"Z3\" 0\n   (and\n-    (eq_attr \"type\" \"uncond_branch,branch,cbranch,fbranch,call,dyncall,multi,milli,parallel_branch\")\n+    (eq_attr \"type\" \"uncond_branch,btable_branch,branch,cbranch,fbranch,call,dyncall,multi,milli,parallel_branch\")\n     (eq_attr \"cpu\" \"8000\"))\n   \"inm0_8000+inm1_8000,rnm0_8000+rnm1_8000\")\n \n@@ -2453,52 +2453,68 @@\n ;; Note since this pattern can be created at reload time (via movsi), all\n ;; the same rules for movsi apply here.  (no new pseudos, no temporaries).\n (define_insn \"\"\n-  [(set (match_operand 0 \"pmode_register_operand\" \"=a\")\n+  [(set (match_operand 0 \"pmode_register_operand\" \"=r\")\n \t(match_operand 1 \"pic_label_operand\" \"\"))]\n-  \"\"\n+  \"TARGET_PA_20\"\n   \"*\n {\n   rtx xoperands[3];\n   extern FILE *asm_out_file;\n \n   xoperands[0] = operands[0];\n   xoperands[1] = operands[1];\n-  if (TARGET_SOM || ! TARGET_GAS)\n-    xoperands[2] = gen_label_rtx ();\n+  xoperands[2] = gen_label_rtx ();\n \n-  output_asm_insn (\\\"{bl|b,l} .+8,%0\\\", xoperands);\n-  output_asm_insn (\\\"{depi|depwi} 0,31,2,%0\\\", xoperands);\n-  if (TARGET_SOM || ! TARGET_GAS)\n-    (*targetm.asm_out.internal_label) (asm_out_file, \\\"L\\\",\n-\t\t\t       CODE_LABEL_NUMBER (xoperands[2]));\n+  (*targetm.asm_out.internal_label) (asm_out_file, \\\"L\\\",\n+\t\t\t\t     CODE_LABEL_NUMBER (xoperands[2]));\n+  output_asm_insn (\\\"mfia %0\\\", xoperands);\n \n   /* If we're trying to load the address of a label that happens to be\n      close, then we can use a shorter sequence.  */\n   if (GET_CODE (operands[1]) == LABEL_REF\n       && INSN_ADDRESSES_SET_P ()\n       && abs (INSN_ADDRESSES (INSN_UID (XEXP (operands[1], 0)))\n \t        - INSN_ADDRESSES (INSN_UID (insn))) < 8100)\n+    output_asm_insn (\\\"ldo %1-%2(%0),%0\\\", xoperands);\n+  else\n     {\n-      /* Prefixing with R% here is wrong, it extracts just 11 bits and is\n-\t always non-negative.  */\n-      if (TARGET_SOM || ! TARGET_GAS)\n-\toutput_asm_insn (\\\"ldo %1-%2(%0),%0\\\", xoperands);\n-      else\n-\toutput_asm_insn (\\\"ldo %1-$PIC_pcrel$0+8(%0),%0\\\", xoperands);\n+      output_asm_insn (\\\"addil L%%%1-%2,%0\\\", xoperands);\n+      output_asm_insn (\\\"ldo R%%%1-%2(%0),%0\\\", xoperands);\n     }\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"12\")])\t\t; 8 or 12\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"pmode_register_operand\" \"=a\")\n+\t(match_operand 1 \"pic_label_operand\" \"\"))]\n+  \"!TARGET_PA_20\"\n+  \"*\n+{\n+  rtx xoperands[3];\n+  extern FILE *asm_out_file;\n+\n+  xoperands[0] = operands[0];\n+  xoperands[1] = operands[1];\n+  xoperands[2] = gen_label_rtx ();\n+\n+  output_asm_insn (\\\"bl .+8,%0\\\", xoperands);\n+  output_asm_insn (\\\"depi 0,31,2,%0\\\", xoperands);\n+  (*targetm.asm_out.internal_label) (asm_out_file, \\\"L\\\",\n+\t\t\t\t     CODE_LABEL_NUMBER (xoperands[2]));\n+\n+  /* If we're trying to load the address of a label that happens to be\n+     close, then we can use a shorter sequence.  */\n+  if (GET_CODE (operands[1]) == LABEL_REF\n+      && INSN_ADDRESSES_SET_P ()\n+      && abs (INSN_ADDRESSES (INSN_UID (XEXP (operands[1], 0)))\n+\t        - INSN_ADDRESSES (INSN_UID (insn))) < 8100)\n+    output_asm_insn (\\\"ldo %1-%2(%0),%0\\\", xoperands);\n   else\n     {\n-      if (TARGET_SOM || ! TARGET_GAS)\n-\t{\n-\t  output_asm_insn (\\\"addil L%%%1-%2,%0\\\", xoperands);\n-\t  output_asm_insn (\\\"ldo R%%%1-%2(%0),%0\\\", xoperands);\n-\t}\n-      else\n-\t{\n-\t  output_asm_insn (\\\"addil L%%%1-$PIC_pcrel$0+8,%0\\\", xoperands);\n-\t  output_asm_insn (\\\"ldo R%%%1-$PIC_pcrel$0+12(%0),%0\\\",\n-\t  \t\t   xoperands);\n-\t}\n+      output_asm_insn (\\\"addil L%%%1-%2,%0\\\", xoperands);\n+      output_asm_insn (\\\"ldo R%%%1-%2(%0),%0\\\", xoperands);\n     }\n   return \\\"\\\";\n }\"\n@@ -5735,9 +5751,6 @@\n   \"\"\n   \"*\n {\n-  if (GET_MODE (insn) == SImode)\n-    return \\\"b %l0%#\\\";\n-\n   /* An unconditional branch which can reach its target.  */\n   if (get_attr_length (insn) != 24\n       && get_attr_length (insn) != 16)\n@@ -5761,6 +5774,24 @@\n \t\t\t (const_int 24))]\n \t  (const_int 4)))])\n \n+;;; Hope this is only within a function...\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand 0 \"register_operand\" \"r\"))]\n+  \"GET_MODE (operands[0]) == word_mode\"\n+  \"bv%* %%r0(%0)\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4\")])\n+\n+;;; This jump is used in branch tables where the insn length is fixed.\n+;;; The length of this insn is adjusted if the delay slot is not filled.\n+(define_insn \"short_jump\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))\n+   (const_int 0)]\n+  \"\"\n+  \"b%* %l0%#\"\n+  [(set_attr \"type\" \"btable_branch\")\n+   (set_attr \"length\" \"4\")])\n+\n ;; Subroutines of \"casesi\".\n ;; operand 0 is index\n ;; operand 1 is the minimum bound\n@@ -5782,53 +5813,132 @@\n \n   if (operands[1] != const0_rtx)\n     {\n-      rtx reg = gen_reg_rtx (SImode);\n+      rtx index = gen_reg_rtx (SImode);\n \n       operands[1] = GEN_INT (-INTVAL (operands[1]));\n       if (!INT_14_BITS (operands[1]))\n \toperands[1] = force_reg (SImode, operands[1]);\n-      emit_insn (gen_addsi3 (reg, operands[0], operands[1]));\n-\n-      operands[0] = reg;\n+      emit_insn (gen_addsi3 (index, operands[0], operands[1]));\n+      operands[0] = index;\n     }\n \n   /* In 64bit mode we must make sure to wipe the upper bits of the register\n      just in case the addition overflowed or we had random bits in the\n      high part of the register.  */\n   if (TARGET_64BIT)\n     {\n-      rtx reg = gen_reg_rtx (DImode);\n-      emit_insn (gen_extendsidi2 (reg, operands[0]));\n-      operands[0] = gen_rtx_SUBREG (SImode, reg, 4);\n+      rtx index = gen_reg_rtx (DImode);\n+\n+      emit_insn (gen_extendsidi2 (index, operands[0]));\n+      operands[0] = gen_rtx_SUBREG (SImode, index, 4);\n     }\n \n   if (!INT_5_BITS (operands[2]))\n     operands[2] = force_reg (SImode, operands[2]);\n \n+  /* This branch prevents us finding an insn for the delay slot of the\n+     following vectored branch.  It might be possible to use the delay\n+     slot if an index value of -1 was used to transfer to the out-of-range\n+     label.  In order to do this, we would have to output the -1 vector\n+     element after the delay insn.  The casesi output code would have to\n+     check if the casesi insn is in a delay branch sequence and output\n+     the delay insn if one is found.  If this was done, then it might\n+     then be worthwhile to split the casesi patterns to improve scheduling.\n+     However, it's not clear that all this extra complexity is worth\n+     the effort.  */\n   emit_insn (gen_cmpsi (operands[0], operands[2]));\n   emit_jump_insn (gen_bgtu (operands[4]));\n+\n   if (TARGET_BIG_SWITCH)\n     {\n-      rtx temp = gen_reg_rtx (SImode);\n-      emit_move_insn (temp, gen_rtx_PLUS (SImode, operands[0], operands[0]));\n-      operands[0] = temp;\n+      if (TARGET_64BIT)\n+\t{\n+          rtx tmp1 = gen_reg_rtx (DImode);\n+          rtx tmp2 = gen_reg_rtx (DImode);\n+\n+          emit_jump_insn (gen_casesi64p (operands[0], operands[3],\n+                                         tmp1, tmp2));\n+\t}\n+      else\n+\t{\n+\t  rtx tmp1 = gen_reg_rtx (SImode);\n+\n+\t  if (flag_pic)\n+\t    {\n+\t      rtx tmp2 = gen_reg_rtx (SImode);\n+\n+\t      emit_jump_insn (gen_casesi32p (operands[0], operands[3],\n+\t\t\t\t\t     tmp1, tmp2));\n+\t    }\n+\t  else\n+\t    emit_jump_insn (gen_casesi32 (operands[0], operands[3], tmp1));\n+\t}\n     }\n-  emit_jump_insn (gen_casesi0 (operands[0], operands[3]));\n+  else\n+    emit_jump_insn (gen_casesi0 (operands[0], operands[3]));\n   DONE;\n }\")\n \n+;;; The rtl for this pattern doesn't accurately describe what the insn\n+;;; actually does, particularly when case-vector elements are exploded\n+;;; in pa_reorg.  However, the initial SET in these patterns must show\n+;;; the connection of the insn to the following jump table.\n (define_insn \"casesi0\"\n-  [(set (pc) (plus:SI\n-\t       (mem:SI (plus:SI (pc)\n-\t\t\t\t(match_operand:SI 0 \"register_operand\" \"r\")))\n-\t       (label_ref (match_operand 1 \"\" \"\"))))]\n+  [(set (pc) (mem:SI (plus:SI\n+\t\t       (mult:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t\t(const_int 4))\n+\t\t       (label_ref (match_operand 1 \"\" \"\")))))]\n   \"\"\n-  \"blr %0,%%r0\\;nop\"\n+  \"blr,n %0,%%r0\\;nop\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"8\")])\n \n-;; Need nops for the calls because execution is supposed to continue\n-;; past; we don't want to nullify an instruction that we need.\n+;;; 32-bit code, absolute branch table.\n+(define_insn \"casesi32\"\n+  [(set (pc) (mem:SI (plus:SI\n+\t\t       (mult:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t\t(const_int 4))\n+\t\t       (label_ref (match_operand 1 \"\" \"\")))))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&r\"))]\n+  \"!TARGET_64BIT && TARGET_BIG_SWITCH\"\n+  \"ldil L'%l1,%2\\;ldo R'%l1(%2),%2\\;{ldwx|ldw},s %0(%2),%2\\;bv,n %%r0(%2)\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"16\")])\n+\n+;;; 32-bit code, relative branch table.\n+(define_insn \"casesi32p\"\n+  [(set (pc) (mem:SI (plus:SI\n+\t\t       (mult:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t\t(const_int 4))\n+\t\t       (label_ref (match_operand 1 \"\" \"\")))))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&a\"))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"=&r\"))]\n+  \"!TARGET_64BIT && TARGET_BIG_SWITCH\"\n+  \"{bl .+8,%2\\;depi 0,31,2,%2|mfia %2}\\;ldo {16|20}(%2),%2\\;\\\n+{ldwx|ldw},s %0(%2),%3\\;{addl|add,l} %2,%3,%3\\;bv,n %%r0(%3)\"\n+  [(set_attr \"type\" \"multi\")\n+   (set (attr \"length\")\n+     (if_then_else (ne (symbol_ref \"TARGET_PA_20\") (const_int 0))\n+\t(const_int 20)\n+\t(const_int 24)))])\n+\n+;;; 64-bit code, 32-bit relative branch table.\n+(define_insn \"casesi64p\"\n+  [(set (pc) (mem:DI (plus:DI\n+\t\t       (mult:DI (sign_extend:DI\n+\t\t\t\t  (match_operand:SI 0 \"register_operand\" \"r\"))\n+\t\t\t\t(const_int 8))\n+\t\t       (label_ref (match_operand 1 \"\" \"\")))))\n+   (clobber (match_operand:DI 2 \"register_operand\" \"=&r\"))\n+   (clobber (match_operand:DI 3 \"register_operand\" \"=&r\"))]\n+  \"TARGET_64BIT && TARGET_BIG_SWITCH\"\n+  \"mfia %2\\;ldo 24(%2),%2\\;ldw,s %0(%2),%3\\;extrd,s %3,63,32,%3\\;\\\n+add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"24\")])\n+\n+\n+;; Call patterns.\n ;;- jump to subroutine\n \n (define_expand \"call\"\n@@ -7137,14 +7247,6 @@\n   DONE;\n }\")\n \n-;;; Hope this is only within a function...\n-(define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand 0 \"register_operand\" \"r\"))]\n-  \"GET_MODE (operands[0]) == word_mode\"\n-  \"bv%* %%r0(%0)\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"4\")])\n-\n ;;; Operands 2 and 3 are assumed to be CONST_INTs.\n (define_expand \"extzv\"\n   [(set (match_operand 0 \"register_operand\" \"\")"}]}