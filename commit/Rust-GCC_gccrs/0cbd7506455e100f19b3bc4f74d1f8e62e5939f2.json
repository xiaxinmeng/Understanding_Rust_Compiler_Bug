{"sha": "0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNiZDc1MDY0NTVlMTAwZjE5YjNiYzRmNzRkMWY4ZTYyZTU5MzlmMg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2005-06-15T00:41:35Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2005-06-15T00:41:35Z"}, "message": "Canonicalize whitespace.\n\nFrom-SVN: r100965", "tree": {"sha": "d8691b706a5d24462549fd36e73e1589e7ac65d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8691b706a5d24462549fd36e73e1589e7ac65d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/comments", "author": null, "committer": null, "parents": [{"sha": "cbcabe5bedf6d06bf37e4be778a4fb633e5c7c2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbcabe5bedf6d06bf37e4be778a4fb633e5c7c2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbcabe5bedf6d06bf37e4be778a4fb633e5c7c2a"}], "stats": {"total": 5560, "additions": 2788, "deletions": 2772}, "files": [{"sha": "28b08adf287132b58e806b99a5fd71c98f4def97", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -6378,7 +6378,7 @@\n \t(cp_parser_direct_declarator): Likewise.\n \t* pt.c (tsubst): Likewise.\n \t(tsubst_copy, tsubst_copy_and_build): Likewise; also add new operand\n- \tfor COMPONENT_REF.\n+\tfor COMPONENT_REF.\n \t* semantics.c (finish_non_static_data_member): Add new operand\n \tfor COMPONENT_REF.\n \t* typeck.c (build_class_member_access_expr): Likewise."}, {"sha": "4b17345d1668039fcb2520edecd48c64bd0d4ce9", "filename": "gcc/cp/ChangeLog-1999", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2FChangeLog-1999", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2FChangeLog-1999", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog-1999?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -454,8 +454,8 @@\n \t    Greg McGary  <gkm@gnu.org>\n \n \t* decl.c (duplicate_decls): Merge\n- \tDECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT,\n- \tDECL_NO_CHECK_MEMORY_USAGE, DECL_NO_LIMIT_STACK.\n+\tDECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT,\n+\tDECL_NO_CHECK_MEMORY_USAGE, DECL_NO_LIMIT_STACK.\n \n 1999-12-02  Mike Stump  <mrs@wrs.com>\n \n@@ -860,7 +860,7 @@ Thu Nov 11 12:42:11 MST 1999\tDiego Novillo <dnovillo@cygnus.com>\n \t* pt.c (tsubst_enum): Adjust according to build_enumerator changes.\n \n Wed Nov 10 12:43:21 1999  Philippe De Muyter  <phdm@macqel.be>\n-\t                  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\t\t\t  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* cp-tree.h: Test `GCC_VERSION', not `HAVE_GCC_VERSION'.\n \n@@ -2183,8 +2183,8 @@ Sun Sep 12 23:29:07 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* g++spec.c: Include gcc.h.\n \t(lang_specific_driver): Constify a char*.  Call xcalloc, not\n- \txmalloc/bzero.  All calls to the function pointer parameter now\n- \texplicitly call `fatal'.\n+\txmalloc/bzero.  All calls to the function pointer parameter now\n+\texplicitly call `fatal'.\n \n 1999-09-12  Mark Mitchell  <mark@codesourcery.com>\n \n@@ -4791,7 +4791,7 @@ Wed Jul  7 01:26:47 1999  Alexandre Oliva  <oliva@dcc.unicamp.br>\n \t(pt.c): Or CP_TYPE_QUALS for an ERROR_MARK.\n \t(typeck.c): Or TYPE_MAIN_VARIANT for a type.\n \n- \t* pt.c (for_each_template_parm): Rework to match documentation.\n+\t* pt.c (for_each_template_parm): Rework to match documentation.\n \tDon't be fooled by a COMPONENT_REF with no TREE_TYPE.\n \n 1999-05-20  Jason Merrill  <jason@yorick.cygnus.com>"}, {"sha": "1cd19fa8e205bb00d61810366b5347611ab76555", "filename": "gcc/cp/ChangeLog-2003", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2FChangeLog-2003", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2FChangeLog-2003", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog-2003?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -85,12 +85,12 @@\n 2003-12-22  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR c++/5050\n-        * tree.c (cp_start_inlining): Remove.\n-        (cp_end_inlining): Remove.\n-        * cp-lang.c (LANG_HOOKS_TREE_INLINING_START_INLINING): Do not define.\n-        (LANG_HOOKS_TREE_INLINING_END_INLINING): Do not define.\n-        * cp-tree.h (cp_start_inlining): Do not declare.\n-        (cp_end_inlining): Do not declare.\n+\t* tree.c (cp_start_inlining): Remove.\n+\t(cp_end_inlining): Remove.\n+\t* cp-lang.c (LANG_HOOKS_TREE_INLINING_START_INLINING): Do not define.\n+\t(LANG_HOOKS_TREE_INLINING_END_INLINING): Do not define.\n+\t* cp-tree.h (cp_start_inlining): Do not declare.\n+\t(cp_end_inlining): Do not declare.\n \n 2003-12-22  Mark Mitchell  <mark@codesourcery.com>\n \n@@ -304,7 +304,7 @@\n \t* decl.c (xref_basetypes): Check java class inheritance.\n \t* decl2.c (check_java_method): Skip artificial params.\n \n- \tPR c++/13241\n+\tPR c++/13241\n \tC++ ABI change. Mangling of symbols in expressions.\n \t* mangle.c (write_mangled_name): Add top_level flag. Rework for\n \tnested and unnested mangling. Deal with abi version 1 and version\n@@ -514,8 +514,8 @@\n 2003-12-02  Richard Henderson  <rth@redhat.com>\n \n \t* name-lookup.h (struct cp_binding_level): Use ENUM_BITFIELD.\n-        * parser.c (struct cp_token): Likewise.\n-        (struct cp_parser_token_tree_map_node): Likewise.\n+\t* parser.c (struct cp_token): Likewise.\n+\t(struct cp_parser_token_tree_map_node): Likewise.\n \t* lex.c (struct resword): Move const after ENUM_BITFIELD.\n \n 2003-11-30  Mark Mitchell  <mark@codesourcery.com>\n@@ -630,11 +630,11 @@\n \n 2003-11-14  Giovanni Bajo  <giovannibajo@libero.it>\n \n-        PR c++/2294\n-        * name-lookup.c (push_overloaded_decl): Always construct an OVERLOAD\n-        unless the declaration is a built-in.\n-        (set_namespace_binding): While binding OVERLOADs with only one\n-        declaration, we still need to call supplement_binding.\n+\tPR c++/2294\n+\t* name-lookup.c (push_overloaded_decl): Always construct an OVERLOAD\n+\tunless the declaration is a built-in.\n+\t(set_namespace_binding): While binding OVERLOADs with only one\n+\tdeclaration, we still need to call supplement_binding.\n \n 2003-11-14  Mark Mitchell  <mark@codesourcery.com>\n \n@@ -647,9 +647,9 @@\n \n 2003-11-14  Giovanni Bajo  <giovannibajo@libero.it>\n \n-        PR c++/2094\n-        * pt.c (unify): Add support for PTRMEM_CST and\n-        FIELD_DECL unification.\n+\tPR c++/2094\n+\t* pt.c (unify): Add support for PTRMEM_CST and\n+\tFIELD_DECL unification.\n \n 2003-11-13  Richard Earnshaw  <rearnsha@arm.com>\n \n@@ -801,7 +801,7 @@\n 2003-10-21  Robert Bowdidge   <bowdidge@apple.com>\n \n \t* decl.c (cp_finish_decl): Remove clause intended for asm directives\n-          in struct or class fields: this code is never executed.\n+\t  in struct or class fields: this code is never executed.\n \n 2003-10-22  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n@@ -1194,7 +1194,7 @@\n 2003-09-27  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* cp-tree.h, name-lookup.h, decl.c, decl2.c: Remove reference to\n-\tmacros \tBINDING_SCOPE, BINDING_VALUE and BINDING_TYPE.\n+\tmacros BINDING_SCOPE, BINDING_VALUE and BINDING_TYPE.\n \n 2003-09-26  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n@@ -1344,7 +1344,7 @@\n 2003-09-17  Richard Henderson  <rth@redhat.com>\n \n \tPR c++/12316\n-        * semantics.c (expand_or_defer_fn): Inc/dec function_depth.\n+\t* semantics.c (expand_or_defer_fn): Inc/dec function_depth.\n \n 2003-09-16  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n "}, {"sha": "dc4636bf3beb94f636262705c4348007193f33c0", "filename": "gcc/cp/ChangeLog-2004", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2FChangeLog-2004", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2FChangeLog-2004", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog-2004?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -4631,7 +4631,7 @@\n \t(cp_parser_direct_declarator): Likewise.\n \t* pt.c (tsubst): Likewise.\n \t(tsubst_copy, tsubst_copy_and_build): Likewise; also add new operand\n- \tfor COMPONENT_REF.\n+\tfor COMPONENT_REF.\n \t* semantics.c (finish_non_static_data_member): Add new operand\n \tfor COMPONENT_REF.\n \t* typeck.c (build_class_member_access_expr): Likewise."}, {"sha": "e02c76515e4eea04d98a34b67b1c1bac88e85ba3", "filename": "gcc/cp/ChangeLog.tree-ssa", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2FChangeLog.tree-ssa", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2FChangeLog.tree-ssa", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog.tree-ssa?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -261,8 +261,8 @@\n \n 2003-09-03  Richard Henderson  <rth@redhat.com>\n \n-        * decl.c (finish_function): Fix misapplied patch.  Don't\n-        free_after_parsing or free_after_compilation.  For real this time.\n+\t* decl.c (finish_function): Fix misapplied patch.  Don't\n+\tfree_after_parsing or free_after_compilation.  For real this time.\n \n 2003-08-22  Jason Merrill  <jason@redhat.com>\n \n@@ -314,7 +314,7 @@\n \n 2003-06-05  Frank Ch. Eigler  <fche@redhat.com>\n \n-        * cp-mudflap.c (mx_flag): Remove.  Update callers to use mf_mark.\n+\t* cp-mudflap.c (mx_flag): Remove.  Update callers to use mf_mark.\n \n 2003-05-24  Diego Novillo  <dnovillo@redhat.com>\n "}, {"sha": "26ce8ac5607fa4a66a48defad9db1898383eb139", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -164,7 +164,7 @@ c++.install-common: installdirs\n \t      $(INSTALL_PROGRAM) g++-cross$(exeext) $(DESTDIR)$(gcc_tooldir)/bin/g++$(exeext); \\\n \t      rm -f $(DESTDIR)$(gcc_tooldir)/bin/c++$(exeext); \\\n \t      ( cd $(DESTDIR)$(gcc_tooldir)/bin && \\\n-\t        $(LN) g++$(exeext) c++$(exeext) ); \\\n+\t\t$(LN) g++$(exeext) c++$(exeext) ); \\\n \t    else true; fi; \\\n \t  else \\\n \t    rm -f $(DESTDIR)$(bindir)/$(GXX_TARGET_INSTALL_NAME)$(exeext); \\"}, {"sha": "6825b9e3cfe7a5c6dfaefbdf1cb05db19097a7f9", "filename": "gcc/cp/NEWS", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FNEWS?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -250,7 +250,7 @@\n        but not all, the compiler will tell you where you need to add\n        'typename'.  For more information, see\n \n-            http://www.cygnus.com/misc/wp/dec96pub/template.html#temp.res\n+\t    http://www.cygnus.com/misc/wp/dec96pub/template.html#temp.res\n \n      + Guiding declarations are no longer supported.  Function declarations,\n        including friend declarations, do not refer to template instantiations.\n@@ -269,7 +269,7 @@\n      + Explicit instantiation of template constructors and destructors is\n        now supported.  For instance:\n \n-            template A<int>::A(const A&);\n+\t    template A<int>::A(const A&);\n \n   Still not supported:\n \n@@ -324,9 +324,9 @@\n        signatures are overridden) as it did before.\n \n      + -Wall no longer implies -W.  The new warning flag, -Wsign-compare,\n-        included in -Wall, warns about dangerous comparisons of signed and\n-        unsigned values. Only the flag is new; it was previously part of\n-        -W.\n+\tincluded in -Wall, warns about dangerous comparisons of signed and\n+\tunsigned values. Only the flag is new; it was previously part of\n+\t-W.\n \n      + The new flag, -fno-weak, disables the use of weak symbols.\n \n@@ -377,12 +377,12 @@\n   supported.  For instance:\n \n        struct A {\n-              struct B;\n-              B* bp;\n+\t      struct B;\n+\t      B* bp;\n        };\n \n        struct A::B {\n-              int member;\n+\t      int member;\n        };\n \n * On the HPPA, some classes that do not define a copy constructor"}, {"sha": "d245171a91557173216912ce0a8134dfcd7132e2", "filename": "gcc/cp/call.c", "status": "modified", "additions": 91, "deletions": 91, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -134,11 +134,11 @@ static tree build_java_interface_fn_ref (tree, tree);\n #define convert_like_with_context(CONV, EXPR, FN, ARGNO)\t\\\n   convert_like_real ((CONV), (EXPR), (FN), (ARGNO), 0,\t\t\\\n \t\t     /*issue_conversion_warnings=*/true,\t\\\n-                     /*c_cast_p=*/false)\n+\t\t     /*c_cast_p=*/false)\n static tree convert_like_real (conversion *, tree, tree, int, int, bool,\n \t\t\t       bool);\n static void op_error (enum tree_code, enum tree_code, tree, tree,\n-\t\t\t    tree, const char *);\n+\t\t      tree, const char *);\n static tree build_object_call (tree, tree);\n static tree resolve_args (tree);\n static struct z_candidate *build_user_type_conversion_1 (tree, tree, int);\n@@ -148,23 +148,23 @@ static tree build_this (tree);\n static struct z_candidate *splice_viable (struct z_candidate *, bool, bool *);\n static bool any_strictly_viable (struct z_candidate *);\n static struct z_candidate *add_template_candidate\n-        (struct z_candidate **, tree, tree, tree, tree, tree,\n-         tree, tree, int, unification_kind_t);\n+\t(struct z_candidate **, tree, tree, tree, tree, tree,\n+\t tree, tree, int, unification_kind_t);\n static struct z_candidate *add_template_candidate_real\n \t(struct z_candidate **, tree, tree, tree, tree, tree,\n-           tree, tree, int, tree, unification_kind_t);\n+\t tree, tree, int, tree, unification_kind_t);\n static struct z_candidate *add_template_conv_candidate\n-        (struct z_candidate **, tree, tree, tree, tree, tree, tree);\n+\t(struct z_candidate **, tree, tree, tree, tree, tree, tree);\n static void add_builtin_candidates\n \t(struct z_candidate **, enum tree_code, enum tree_code,\n-\t       tree, tree *, int);\n+\t tree, tree *, int);\n static void add_builtin_candidate\n \t(struct z_candidate **, enum tree_code, enum tree_code,\n-\t       tree, tree, tree, tree *, tree *, int);\n+\t tree, tree, tree, tree *, tree *, int);\n static bool is_complete (tree);\n static void build_builtin_candidate\n \t(struct z_candidate **, tree, tree, tree, tree *, tree *,\n-\t       int);\n+\t int);\n static struct z_candidate *add_conv_candidate\n \t(struct z_candidate **, tree, tree, tree, tree, tree);\n static struct z_candidate *add_function_candidate\n@@ -177,7 +177,7 @@ static bool is_subseq (conversion *, conversion *);\n static tree maybe_handle_ref_bind (conversion **);\n static void maybe_handle_implicit_object (conversion **);\n static struct z_candidate *add_candidate\n-        (struct z_candidate **, tree, tree, size_t,\n+\t(struct z_candidate **, tree, tree, size_t,\n \t conversion **, tree, tree, int);\n static tree source_type (conversion *);\n static void add_warning (struct z_candidate *, struct z_candidate *);\n@@ -227,11 +227,11 @@ check_dtor_name (tree basetype, tree name)\n     {\n       /* In the case of:\n \n-      \t template <class T> struct S { ~S(); };\n-      \t int i;\n-       \t i.~S();\n+\t template <class T> struct S { ~S(); };\n+\t int i;\n+\t i.~S();\n \n-     \t NAME will be a class template.  */\n+\t NAME will be a class template.  */\n       gcc_assert (DECL_CLASS_TEMPLATE_P (name));\n       return false;\n     }\n@@ -628,18 +628,18 @@ standard_conversion (tree to, tree from, tree expr, int flags)\n   if (tcode == COMPLEX_TYPE && fcode == COMPLEX_TYPE)\n     {\n       /* The standard conversion sequence to convert FROM to TO is\n-         the standard conversion sequence to perform componentwise\n-         conversion.  */\n+\t the standard conversion sequence to perform componentwise\n+\t conversion.  */\n       conversion *part_conv = standard_conversion\n-        (TREE_TYPE (to), TREE_TYPE (from), NULL_TREE, flags);\n+\t(TREE_TYPE (to), TREE_TYPE (from), NULL_TREE, flags);\n \n       if (part_conv)\n-        {\n+\t{\n \t  conv = build_conv (part_conv->kind, to, conv);\n \t  conv->rank = part_conv->rank;\n-        }\n+\t}\n       else\n-        conv = NULL;\n+\tconv = NULL;\n \n       return conv;\n     }\n@@ -705,15 +705,15 @@ standard_conversion (tree to, tree from, tree expr, int flags)\n \t       && IS_AGGR_TYPE (TREE_TYPE (to))\n \t       /* [conv.ptr]\n \n-\t          An rvalue of type \"pointer to cv D,\" where D is a\n+\t\t  An rvalue of type \"pointer to cv D,\" where D is a\n \t\t  class type, can be converted to an rvalue of type\n \t\t  \"pointer to cv B,\" where B is a base class (clause\n \t\t  _class.derived_) of D.  If B is an inaccessible\n \t\t  (clause _class.access_) or ambiguous\n \t\t  (_class.member.lookup_) base class of D, a program\n \t\t  that necessitates this conversion is ill-formed.\n-\t          Therefore, we use DERIVED_FROM_P, and do not check\n-\t          access or uniqueness.  */\n+\t\t  Therefore, we use DERIVED_FROM_P, and do not check\n+\t\t  access or uniqueness.  */\n \t       && DERIVED_FROM_P (TREE_TYPE (to), TREE_TYPE (from)))\n \t{\n \t  from =\n@@ -778,7 +778,7 @@ standard_conversion (tree to, tree from, tree expr, int flags)\n     {\n       /* [conv.bool]\n \n-          An rvalue of arithmetic, enumeration, pointer, or pointer to\n+\t  An rvalue of arithmetic, enumeration, pointer, or pointer to\n \t  member type can be converted to an rvalue of type bool.  */\n       if (ARITHMETIC_TYPE_P (from)\n \t  || fcode == ENUMERAL_TYPE\n@@ -921,7 +921,7 @@ convert_class_to_reference (tree t, tree s, tree expr)\n \t  cand = NULL;\n \n \t  /* If this is a template function, try to get an exact\n-             match.  */\n+\t     match.  */\n \t  if (TREE_CODE (f) == TEMPLATE_DECL)\n \t    {\n \t      cand = add_template_candidate (&candidates,\n@@ -1133,7 +1133,7 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n \t    conversion functions (_over.match.ref_) and choosing the\n \t    best one through overload resolution.  (_over.match_).\n \n-        the reference is bound to the lvalue result of the conversion\n+\tthe reference is bound to the lvalue result of the conversion\n \tin the second case.  */\n       conv = convert_class_to_reference (to, from, expr);\n       if (conv)\n@@ -1169,7 +1169,7 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n      is bound in one of the following ways:\n \n      -- The reference is bound to the object represented by the rvalue\n-        or to a sub-object within that object.\n+\tor to a sub-object within that object.\n \n      -- ...\n \n@@ -1427,7 +1427,7 @@ add_function_candidate (struct z_candidate **candidates,\n \n static struct z_candidate *\n add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n-                    tree arglist, tree access_path, tree conversion_path)\n+\t\t    tree arglist, tree access_path, tree conversion_path)\n {\n   tree totype = TREE_TYPE (TREE_TYPE (fn));\n   int i, len, viable, flags;\n@@ -1494,8 +1494,8 @@ add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n \n static void\n build_builtin_candidate (struct z_candidate **candidates, tree fnname,\n-                         tree type1, tree type2, tree *args, tree *argtypes,\n-                         int flags)\n+\t\t\t tree type1, tree type2, tree *args, tree *argtypes,\n+\t\t\t int flags)\n {\n   conversion *t;\n   conversion **convs;\n@@ -1580,8 +1580,8 @@ promoted_arithmetic_type_p (tree type)\n \n static void\n add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n-                       enum tree_code code2, tree fnname, tree type1,\n-                       tree type2, tree *args, tree *argtypes, int flags)\n+\t\t       enum tree_code code2, tree fnname, tree type1,\n+\t\t       tree type2, tree *args, tree *argtypes, int flags)\n {\n   switch (code)\n     {\n@@ -1769,11 +1769,11 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n     case MAX_EXPR:\n     case MIN_EXPR:\n       if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n-        break;\n+\tbreak;\n       if (TYPE_PTR_P (type1) && TYPE_PTR_P (type2))\n \tbreak;\n       if (TREE_CODE (type1) == ENUMERAL_TYPE && TREE_CODE (type2) == ENUMERAL_TYPE)\n-        break;\n+\tbreak;\n       if (TYPE_PTR_P (type1) && null_ptr_cst_p (args[1]))\n \t{\n \t  type2 = type1;\n@@ -1988,8 +1988,8 @@ type_decays_to (tree type)\n \n static void\n add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n-                        enum tree_code code2, tree fnname, tree *args,\n-                        int flags)\n+\t\t\tenum tree_code code2, tree fnname, tree *args,\n+\t\t\tint flags)\n {\n   int ref1, i;\n   int enum_p = 0;\n@@ -2104,8 +2104,8 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n \t      if (i != 0 || ! ref1)\n \t\t{\n \t\t  type = TYPE_MAIN_VARIANT (type_decays_to (type));\n-\t          if (enum_p && TREE_CODE (type) == ENUMERAL_TYPE)\n-\t            types[i] = tree_cons (NULL_TREE, type, types[i]);\n+\t\t  if (enum_p && TREE_CODE (type) == ENUMERAL_TYPE)\n+\t\t    types[i] = tree_cons (NULL_TREE, type, types[i]);\n \t\t  if (INTEGRAL_TYPE_P (type))\n \t\t    type = type_promotes_to (type);\n \t\t}\n@@ -2124,7 +2124,7 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n \t    {\n \t      type = TYPE_MAIN_VARIANT (type_decays_to (type));\n \t      if (enum_p && TREE_CODE (type) == ENUMERAL_TYPE)\n-\t        types[i] = tree_cons (NULL_TREE, type, types[i]);\n+\t\ttypes[i] = tree_cons (NULL_TREE, type, types[i]);\n \t      if (INTEGRAL_TYPE_P (type))\n \t\ttype = type_promotes_to (type);\n \t    }\n@@ -2163,10 +2163,10 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n \n static struct z_candidate*\n add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n-                             tree ctype, tree explicit_targs, tree arglist,\n-                             tree return_type, tree access_path,\n+\t\t\t     tree ctype, tree explicit_targs, tree arglist,\n+\t\t\t     tree return_type, tree access_path,\n \t\t\t     tree conversion_path, int flags, tree obj,\n-                             unification_kind_t strict)\n+\t\t\t     unification_kind_t strict)\n {\n   int ntparms = DECL_NTPARMS (tmpl);\n   tree targs = make_tree_vec (ntparms);\n@@ -2206,7 +2206,7 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n      in:\n \n        struct A {\n-         A(A&);\n+\t A(A&);\n \t template <class T> A(const T&);\n        };\n        const A f ();\n@@ -2262,9 +2262,9 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n \n static struct z_candidate *\n add_template_candidate (struct z_candidate **candidates, tree tmpl, tree ctype,\n-                        tree explicit_targs, tree arglist, tree return_type,\n-                        tree access_path, tree conversion_path, int flags,\n-                        unification_kind_t strict)\n+\t\t\ttree explicit_targs, tree arglist, tree return_type,\n+\t\t\ttree access_path, tree conversion_path, int flags,\n+\t\t\tunification_kind_t strict)\n {\n   return\n     add_template_candidate_real (candidates, tmpl, ctype,\n@@ -2276,7 +2276,7 @@ add_template_candidate (struct z_candidate **candidates, tree tmpl, tree ctype,\n \n static struct z_candidate *\n add_template_conv_candidate (struct z_candidate **candidates, tree tmpl,\n-                             tree obj, tree arglist, tree return_type,\n+\t\t\t     tree obj, tree arglist, tree return_type,\n \t\t\t     tree access_path, tree conversion_path)\n {\n   return\n@@ -2997,7 +2997,7 @@ build_object_call (tree obj, tree args)\n \n static void\n op_error (enum tree_code code, enum tree_code code2,\n-          tree arg1, tree arg2, tree arg3, const char *problem)\n+\t  tree arg1, tree arg2, tree arg3, const char *problem)\n {\n   const char *opname;\n \n@@ -3010,7 +3010,7 @@ op_error (enum tree_code code, enum tree_code code2,\n     {\n     case COND_EXPR:\n       error (\"%s for ternary %<operator?:%> in %<%E ? %E : %E%>\",\n-             problem, arg1, arg2, arg3);\n+\t     problem, arg1, arg2, arg3);\n       break;\n \n     case POSTINCREMENT_EXPR:\n@@ -3030,10 +3030,10 @@ op_error (enum tree_code code, enum tree_code code2,\n     default:\n       if (arg2)\n \terror (\"%s for %<operator%s%> in %<%E %s %E%>\",\n-               problem, opname, arg1, opname, arg2);\n+\t       problem, opname, arg1, opname, arg2);\n       else\n \terror (\"%s for %<operator%s%> in %<%s%E%>\",\n-               problem, opname, opname, arg1);\n+\t       problem, opname, opname, arg1);\n       break;\n     }\n }\n@@ -3176,7 +3176,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \t --Both the second and the third operands have type void; the\n \t   result is of type void and is an rvalue.\n \n-         We must avoid calling force_rvalue for expressions of type\n+\t We must avoid calling force_rvalue for expressions of type\n \t \"void\" because it will complain that their value is being\n \t used.  */\n       if (TREE_CODE (arg2) == THROW_EXPR\n@@ -3401,15 +3401,15 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \t\t\t\t\t\t\t     arg3_type);\n \n       if (TREE_CODE (arg2_type) == ENUMERAL_TYPE\n-          && TREE_CODE (arg3_type) == ENUMERAL_TYPE)\n-         warning (0, \"enumeral mismatch in conditional expression: %qT vs %qT\",\n-                   arg2_type, arg3_type);\n+\t  && TREE_CODE (arg3_type) == ENUMERAL_TYPE)\n+\t warning (0, \"enumeral mismatch in conditional expression: %qT vs %qT\",\n+\t\t   arg2_type, arg3_type);\n       else if (extra_warnings\n-               && ((TREE_CODE (arg2_type) == ENUMERAL_TYPE\n-                    && !same_type_p (arg3_type, type_promotes_to (arg2_type)))\n-                   || (TREE_CODE (arg3_type) == ENUMERAL_TYPE\n-                       && !same_type_p (arg2_type, type_promotes_to (arg3_type)))))\n-        warning (0, \"enumeral and non-enumeral type in conditional expression\");\n+\t       && ((TREE_CODE (arg2_type) == ENUMERAL_TYPE\n+\t\t    && !same_type_p (arg3_type, type_promotes_to (arg2_type)))\n+\t\t   || (TREE_CODE (arg3_type) == ENUMERAL_TYPE\n+\t\t       && !same_type_p (arg2_type, type_promotes_to (arg3_type)))))\n+\twarning (0, \"enumeral and non-enumeral type in conditional expression\");\n \n       arg2 = perform_implicit_conversion (result_type, arg2);\n       arg3 = perform_implicit_conversion (result_type, arg3);\n@@ -3704,9 +3704,9 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t     one, then we fall back to the old way of doing things.  */\n \t  if (flags & LOOKUP_COMPLAIN)\n \t    pedwarn (\"no %<%D(int)%> declared for postfix %qs, \"\n-                     \"trying prefix operator instead\",\n-                     fnname,\n-                     operator_name_info[code].name);\n+\t\t     \"trying prefix operator instead\",\n+\t\t     fnname,\n+\t\t     operator_name_info[code].name);\n \t  if (code == POSTINCREMENT_EXPR)\n \t    code = PREINCREMENT_EXPR;\n \t  else\n@@ -3777,7 +3777,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t\t      != TYPE_MAIN_VARIANT (TREE_TYPE (arg2))))\n \t\t{\n \t\t  warning (0, \"comparison between %q#T and %q#T\",\n-                           TREE_TYPE (arg1), TREE_TYPE (arg2));\n+\t\t\t   TREE_TYPE (arg1), TREE_TYPE (arg2));\n \t\t}\n \t      break;\n \t    default:\n@@ -4444,7 +4444,7 @@ convert_arg_to_ellipsis (tree arg)\n \t evaluated. We keep the builtin_trap just as a safety check.  */\n       if (!skip_evaluation)\n \twarning (0, \"cannot pass objects of non-POD type %q#T through %<...%>; \"\n-\t         \"call will abort at runtime\", TREE_TYPE (arg));\n+\t\t \"call will abort at runtime\", TREE_TYPE (arg));\n       arg = call_builtin_trap ();\n       arg = build2 (COMPOUND_EXPR, integer_type_node, arg,\n \t\t    integer_zero_node);\n@@ -4470,7 +4470,7 @@ build_x_va_arg (tree expr, tree type)\n     {\n       /* Undefined behavior [expr.call] 5.2.2/7.  */\n       warning (0, \"cannot receive objects of non-POD type %q#T through %<...%>; \"\n-               \"call will abort at runtime\", type);\n+\t       \"call will abort at runtime\", type);\n       expr = convert (build_pointer_type (type), null_node);\n       expr = build2 (COMPOUND_EXPR, TREE_TYPE (expr),\n \t\t     call_builtin_trap (), expr);\n@@ -4718,13 +4718,13 @@ build_over_call (struct z_candidate *cand, int flags)\n \n       if (convs[i]->bad_p)\n \tpedwarn (\"passing %qT as %<this%> argument of %q#D discards qualifiers\",\n-                 TREE_TYPE (argtype), fn);\n+\t\t TREE_TYPE (argtype), fn);\n \n       /* [class.mfct.nonstatic]: If a nonstatic member function of a class\n \t X is called for an object that is not of type X, or of a type\n \t derived from X, the behavior is undefined.\n \n-         So we can assume that anything passed as 'this' is non-null, and\n+\t So we can assume that anything passed as 'this' is non-null, and\n \t optimize accordingly.  */\n       gcc_assert (TREE_CODE (parmtype) == POINTER_TYPE);\n       /* Convert to the base in which the function was declared.  */\n@@ -4740,8 +4740,8 @@ build_over_call (struct z_candidate *cand, int flags)\n \t       BINFO_TYPE (cand->conversion_path),\n \t       TREE_TYPE (argtype));\n       /* If fn was found by a using declaration, the conversion path\n-         will be to the derived class, not the base declaring fn. We\n-         must convert from derived to base.  */\n+\t will be to the derived class, not the base declaring fn. We\n+\t must convert from derived to base.  */\n       base_binfo = lookup_base (TREE_TYPE (TREE_TYPE (converted_arg)),\n \t\t\t\tTREE_TYPE (parmtype), ba_unique, NULL);\n       converted_arg = build_base_path (PLUS_EXPR, converted_arg,\n@@ -4830,10 +4830,10 @@ build_over_call (struct z_candidate *cand, int flags)\n \tmark_used (fn);\n \n       /* If we're creating a temp and we already have one, don't create a\n-         new one.  If we're not creating a temp but we get one, use\n-         INIT_EXPR to collapse the temp into our target.  Otherwise, if the\n-         ctor is trivial, do a bitwise copy with a simple TARGET_EXPR for a\n-         temp or an INIT_EXPR otherwise.  */\n+\t new one.  If we're not creating a temp but we get one, use\n+\t INIT_EXPR to collapse the temp into our target.  Otherwise, if the\n+\t ctor is trivial, do a bitwise copy with a simple TARGET_EXPR for a\n+\t temp or an INIT_EXPR otherwise.  */\n       if (integer_zerop (TREE_VALUE (args)))\n \t{\n \t  if (TREE_CODE (arg) == TARGET_EXPR)\n@@ -4998,9 +4998,9 @@ build_java_interface_fn_ref (tree fn, tree instance)\n   for (method = TYPE_METHODS (iface); method; method = TREE_CHAIN (method))\n     {\n       if (!DECL_VIRTUAL_P (method))\n-        continue;\n+\tcontinue;\n       if (fn == method)\n-        break;\n+\tbreak;\n       i++;\n     }\n   idx = build_int_cst (NULL_TREE, i);\n@@ -5272,7 +5272,7 @@ build_new_method_call (tree instance, tree fns, tree args,\n     {\n       if ((flags & LOOKUP_COMPLAIN) && basetype != error_mark_node)\n \terror (\"request for member %qD in %qE, which is of non-aggregate \"\n-               \"type %qT\",\n+\t       \"type %qT\",\n \t       fns, instance, basetype);\n \n       return error_mark_node;\n@@ -6085,9 +6085,9 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n   if (cand1->template_decl && cand2->template_decl)\n     {\n       winner = more_specialized_fn\n-        (TI_TEMPLATE (cand1->template_decl),\n-         TI_TEMPLATE (cand2->template_decl),\n-         /* Tell the deduction code how many real function arguments\n+\t(TI_TEMPLATE (cand1->template_decl),\n+\t TI_TEMPLATE (cand2->template_decl),\n+\t /* Tell the deduction code how many real function arguments\n \t    we saw, not counting the implicit 'this' argument.  But,\n \t    add_function_candidate() suppresses the \"this\" argument\n \t    for constructors.\n@@ -6099,7 +6099,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n \t - (DECL_NONSTATIC_MEMBER_FUNCTION_P (cand1->fn)\n \t    - DECL_CONSTRUCTOR_P (cand1->fn)));\n       if (winner)\n-        return winner;\n+\treturn winner;\n     }\n \n   /* or, if not that,\n@@ -6114,7 +6114,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n     {\n       winner = compare_ics (cand1->second_conv, cand2->second_conv);\n       if (winner)\n-        return winner;\n+\treturn winner;\n     }\n \n   /* Check whether we can discard a builtin candidate, either because we\n@@ -6176,7 +6176,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n       if (rank1 > rank2)\n \twinner = -1, w = cand2, l = cand1;\n       if (winner)\n-        {\n+\t{\n \t  if (warn)\n \t    {\n \t      pedwarn (\"\\\n@@ -6188,8 +6188,8 @@ the worst conversion for the second:\");\n \t    }\n \t  else\n \t    add_warning (w, l);\n-          return winner;\n-        }\n+\t  return winner;\n+\t}\n     }\n \n   gcc_assert (!winner);\n@@ -6450,12 +6450,12 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n   if (!conv || conv->bad_p)\n     {\n       if (!(TYPE_QUALS (TREE_TYPE (type)) & TYPE_QUAL_CONST)\n-          && !real_lvalue_p (expr))\n-        error (\"invalid initialization of non-const reference of \"\n-               \"type %qT from a temporary of type %qT\",\n-               type, TREE_TYPE (expr));\n+\t  && !real_lvalue_p (expr))\n+\terror (\"invalid initialization of non-const reference of \"\n+\t       \"type %qT from a temporary of type %qT\",\n+\t       type, TREE_TYPE (expr));\n       else\n-        error (\"invalid initialization of reference of type \"\n+\terror (\"invalid initialization of reference of type \"\n \t       \"%qT from expression of type %qT\", type,\n \t       TREE_TYPE (expr));\n       return error_mark_node;\n@@ -6508,7 +6508,7 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n       if (conv->kind == ck_base)\n \t{\n \t  if (conv->check_copy_constructor_p)\n- \t    check_constructor_callable (TREE_TYPE (expr), expr);\n+\t    check_constructor_callable (TREE_TYPE (expr), expr);\n \t  base_conv_type = conv->type;\n \t  conv = conv->u.next;\n \t}"}, {"sha": "520442f953ea09149e88b19e8b1de7f7f5509cf4", "filename": "gcc/cp/class.c", "status": "modified", "additions": 126, "deletions": 126, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -227,9 +227,9 @@ int n_inner_fields_searched = 0;\n \n tree\n build_base_path (enum tree_code code,\n-                 tree expr,\n-                 tree binfo,\n-                 int nonnull)\n+\t\t tree expr,\n+\t\t tree binfo,\n+\t\t int nonnull)\n {\n   tree v_binfo = NULL_TREE;\n   tree d_binfo = NULL_TREE;\n@@ -318,8 +318,8 @@ build_base_path (enum tree_code code,\n   if (virtual_access)\n     {\n       /* Going via virtual base V_BINFO.  We need the static offset\n-         from V_BINFO to BINFO, and the dynamic offset from D_BINFO to\n-         V_BINFO.  That offset is an entry in D_BINFO's vtable.  */\n+\t from V_BINFO to BINFO, and the dynamic offset from D_BINFO to\n+\t V_BINFO.  That offset is an entry in D_BINFO's vtable.  */\n       tree v_offset;\n \n       if (fixed_type_p < 0 && in_base_initializer)\n@@ -414,9 +414,9 @@ build_simple_base_path (tree expr, tree binfo)\n       gcc_assert (TYPE_MAIN_VARIANT (TREE_TYPE (expr)) == type);\n \n       /* Transform `(a, b).x' into `(*(a, &b)).x', `(a ? b : c).x'\n-     \t into `(*(a ?  &b : &c)).x', and so on.  A COND_EXPR is only\n-     \t an lvalue in the frontend; only _DECLs and _REFs are lvalues\n-     \t in the backend.  */\n+\t into `(*(a ?  &b : &c)).x', and so on.  A COND_EXPR is only\n+\t an lvalue in the frontend; only _DECLs and _REFs are lvalues\n+\t in the backend.  */\n       temp = unary_complex_lvalue (ADDR_EXPR, expr);\n       if (temp)\n \texpr = build_indirect_ref (temp, NULL);\n@@ -847,10 +847,10 @@ make_new_vtable (tree t, tree binfo)\n \n static void\n modify_vtable_entry (tree t,\n-                     tree binfo,\n-                     tree fndecl,\n-                     tree delta,\n-                     tree *virtuals)\n+\t\t     tree binfo,\n+\t\t     tree fndecl,\n+\t\t     tree delta,\n+\t\t     tree *virtuals)\n {\n   tree v;\n \n@@ -1093,7 +1093,7 @@ alter_access (tree t, tree fdecl, tree access)\n \t{\n \t  if (TREE_CODE (TREE_TYPE (fdecl)) == FUNCTION_DECL)\n \t    cp_error_at (\"conflicting access specifications for method\"\n-                         \" %qD, ignored\", TREE_TYPE (fdecl));\n+\t\t\t \" %qD, ignored\", TREE_TYPE (fdecl));\n \t  else\n \t    error (\"conflicting access specifications for field %qE, ignored\",\n \t\t   DECL_NAME (fdecl));\n@@ -1186,8 +1186,8 @@ handle_using_decl (tree using_decl, tree t)\n \n static void\n check_bases (tree t,\n-             int* cant_have_const_ctor_p,\n-             int* no_const_asn_ref_p)\n+\t     int* cant_have_const_ctor_p,\n+\t     int* no_const_asn_ref_p)\n {\n   int i;\n   int seen_non_virtual_nearly_empty_base_p;\n@@ -1301,8 +1301,8 @@ determine_primary_bases (tree t)\n \t      BINFO_INHERITANCE_CHAIN (this_primary) = base_binfo;\n \n \t      /* A virtual binfo might have been copied from within\n-  \t         another hierarchy. As we're about to use it as a\n-  \t         primary base, make sure the offsets match.  */\n+\t\t another hierarchy. As we're about to use it as a\n+\t\t primary base, make sure the offsets match.  */\n \t      delta = size_diffop (convert (ssizetype,\n \t\t\t\t\t    BINFO_OFFSET (base_binfo)),\n \t\t\t\t   convert (ssizetype,\n@@ -1364,8 +1364,8 @@ determine_primary_bases (tree t)\n \n \t  BINFO_INHERITANCE_CHAIN (primary) = type_binfo;\n \t  /* A virtual binfo might have been copied from within\n-  \t     another hierarchy. As we're about to use it as a primary\n-  \t     base, make sure the offsets match.  */\n+\t     another hierarchy. As we're about to use it as a primary\n+\t     base, make sure the offsets match.  */\n \t  delta = size_diffop (ssize_int (0),\n \t\t\t       convert (ssizetype, BINFO_OFFSET (primary)));\n \n@@ -1573,7 +1573,7 @@ maybe_warn_about_overly_private_class (tree t)\n       if (nonprivate_ctor == 0)\n \t{\n \t  warning (0, \"%q#T only defines private constructors and has no friends\",\n-                   t);\n+\t\t   t);\n \t  return;\n \t}\n     }\n@@ -1632,9 +1632,9 @@ resort_method_name_cmp (const void* m1_p, const void* m2_p)\n \n void\n resort_type_method_vec (void* obj,\n-                        void* orig_obj ATTRIBUTE_UNUSED ,\n-                        gt_pointer_operator new_value,\n-                        void* cookie)\n+\t\t\tvoid* orig_obj ATTRIBUTE_UNUSED ,\n+\t\t\tgt_pointer_operator new_value,\n+\t\t\tvoid* cookie)\n {\n   VEC(tree,gc) *method_vec = (VEC(tree,gc) *) obj;\n   int len = VEC_length (tree, method_vec);\n@@ -1981,9 +1981,9 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n       && CLASS_TYPE_P (TREE_TYPE (base_return)))\n     {\n       /* If FN is a covariant thunk, we must figure out the adjustment\n-         to the final base FN was converting to. As OVERRIDER_TARGET might\n-         also be converting to the return type of FN, we have to\n-         combine the two conversions here.  */\n+\t to the final base FN was converting to. As OVERRIDER_TARGET might\n+\t also be converting to the return type of FN, we have to\n+\t combine the two conversions here.  */\n       tree fixed_offset, virtual_offset;\n \n       over_return = TREE_TYPE (over_return);\n@@ -2099,19 +2099,19 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n   if (overrider_fn != overrider_target && !virtual_base)\n     {\n       /* The ABI specifies that a covariant thunk includes a mangling\n-   \t for a this pointer adjustment.  This-adjusting thunks that\n-   \t override a function from a virtual base have a vcall\n-   \t adjustment.  When the virtual base in question is a primary\n-   \t virtual base, we know the adjustments are zero, (and in the\n-   \t non-covariant case, we would not use the thunk).\n-   \t Unfortunately we didn't notice this could happen, when\n-   \t designing the ABI and so never mandated that such a covariant\n-   \t thunk should be emitted.  Because we must use the ABI mandated\n-   \t name, we must continue searching from the binfo where we\n-   \t found the most recent definition of the function, towards the\n-   \t primary binfo which first introduced the function into the\n-   \t vtable.  If that enters a virtual base, we must use a vcall\n-   \t this-adjusting thunk.  Bleah! */\n+\t for a this pointer adjustment.  This-adjusting thunks that\n+\t override a function from a virtual base have a vcall\n+\t adjustment.  When the virtual base in question is a primary\n+\t virtual base, we know the adjustments are zero, (and in the\n+\t non-covariant case, we would not use the thunk).\n+\t Unfortunately we didn't notice this could happen, when\n+\t designing the ABI and so never mandated that such a covariant\n+\t thunk should be emitted.  Because we must use the ABI mandated\n+\t name, we must continue searching from the binfo where we\n+\t found the most recent definition of the function, towards the\n+\t primary binfo which first introduced the function into the\n+\t vtable.  If that enters a virtual base, we must use a vcall\n+\t this-adjusting thunk.  Bleah! */\n       tree probe = first_defn;\n \n       while ((probe = get_primary_binfo (probe))\n@@ -2296,8 +2296,8 @@ check_for_override (tree decl, tree ctype)\n   if (TREE_CODE (decl) == TEMPLATE_DECL)\n     /* In [temp.mem] we have:\n \n-         A specialization of a member function template does not\n-         override a virtual function from a base class.  */\n+\t A specialization of a member function template does not\n+\t override a virtual function from a base class.  */\n     return;\n   if ((DECL_DESTRUCTOR_P (decl)\n        || IDENTIFIER_VIRTUAL_P (DECL_NAME (decl))\n@@ -2426,7 +2426,7 @@ finish_struct_anon (tree t)\n \t      if (TREE_CODE (elt) != FIELD_DECL)\n \t\t{\n \t\t  cp_pedwarn_at (\"%q#D invalid; an anonymous union can \"\n-                                 \"only have non-static data members\",\n+\t\t\t\t \"only have non-static data members\",\n \t\t\t\t elt);\n \t\t  continue;\n \t\t}\n@@ -2672,9 +2672,9 @@ check_bitfield_decl (tree field)\n \n static void\n check_field_decl (tree field,\n-                  tree t,\n-                  int* cant_have_const_ctor,\n-                  int* no_const_asn_ref,\n+\t\t  tree t,\n+\t\t  int* cant_have_const_ctor,\n+\t\t  int* no_const_asn_ref,\n \t\t  int* any_default_members)\n {\n   tree type = strip_array_types (TREE_TYPE (field));\n@@ -2861,7 +2861,7 @@ check_field_decls (tree t, tree *access_decls,\n \t  if (TREE_CODE (type) == REFERENCE_TYPE)\n \t    {\n \t      cp_error_at (\"%qD may not have reference type %qT because\"\n-                           \" it is a member of a union\",\n+\t\t\t   \" it is a member of a union\",\n \t\t\t   x, type);\n \t      continue;\n \t    }\n@@ -2900,7 +2900,7 @@ check_field_decls (tree t, tree *access_decls,\n       /* If this is of reference type, check if it needs an init.\n \t Also do a little ANSI jig if necessary.  */\n       if (TREE_CODE (type) == REFERENCE_TYPE)\n- \t{\n+\t{\n \t  CLASSTYPE_NON_POD_P (t) = 1;\n \t  if (DECL_INITIAL (x) == NULL_TREE)\n \t    SET_CLASSTYPE_REF_FIELDS_NEED_INIT (t, 1);\n@@ -2913,7 +2913,7 @@ check_field_decls (tree t, tree *access_decls,\n \n \t  if (! TYPE_HAS_CONSTRUCTOR (t) && CLASSTYPE_NON_AGGREGATE (t)\n \t      && extra_warnings)\n-            cp_warning_at (\"non-static reference %q#D in class without a constructor\", x);\n+\t    cp_warning_at (\"non-static reference %q#D in class without a constructor\", x);\n \t}\n \n       type = strip_array_types (type);\n@@ -2938,8 +2938,8 @@ check_field_decls (tree t, tree *access_decls,\n \tCLASSTYPE_HAS_MUTABLE (t) = 1;\n \n       if (! pod_type_p (type))\n-        /* DR 148 now allows pointers to members (which are POD themselves),\n-           to be allowed in POD structs.  */\n+\t/* DR 148 now allows pointers to members (which are POD themselves),\n+\t   to be allowed in POD structs.  */\n \tCLASSTYPE_NON_POD_P (t) = 1;\n \n       if (! zero_init_p (type))\n@@ -2960,7 +2960,7 @@ check_field_decls (tree t, tree *access_decls,\n \n \t  if (! TYPE_HAS_CONSTRUCTOR (t) && CLASSTYPE_NON_AGGREGATE (t)\n \t      && extra_warnings)\n-            cp_warning_at (\"non-static const member %q#D in class without a constructor\", x);\n+\t    cp_warning_at (\"non-static const member %q#D in class without a constructor\", x);\n \t}\n       /* A field that is pseudo-const makes the structure likewise.  */\n       else if (CLASS_TYPE_P (type))\n@@ -3091,11 +3091,11 @@ check_subobject_offset (tree type, tree offset, splay_tree offsets)\n \n static int\n walk_subobject_offsets (tree type,\n-                        subobject_offset_fn f,\n-                        tree offset,\n-                        splay_tree offsets,\n-                        tree max_offset,\n-                        int vbases_p)\n+\t\t\tsubobject_offset_fn f,\n+\t\t\ttree offset,\n+\t\t\tsplay_tree offsets,\n+\t\t\ttree max_offset,\n+\t\t\tint vbases_p)\n {\n   int r = 0;\n   tree type_binfo = NULL_TREE;\n@@ -3285,9 +3285,9 @@ walk_subobject_offsets (tree type,\n \n static void\n record_subobject_offsets (tree type,\n-                          tree offset,\n-                          splay_tree offsets,\n-                          int vbases_p)\n+\t\t\t  tree offset,\n+\t\t\t  splay_tree offsets,\n+\t\t\t  int vbases_p)\n {\n   walk_subobject_offsets (type, record_subobject_offset, offset,\n \t\t\t  offsets, /*max_offset=*/NULL_TREE, vbases_p);\n@@ -3299,9 +3299,9 @@ record_subobject_offsets (tree type,\n \n static int\n layout_conflict_p (tree type,\n-                   tree offset,\n-                   splay_tree offsets,\n-                   int vbases_p)\n+\t\t   tree offset,\n+\t\t   splay_tree offsets,\n+\t\t   int vbases_p)\n {\n   splay_tree_node max_node;\n \n@@ -3817,7 +3817,7 @@ clone_function_decl (tree fn, int update_method_vec_p)\n \t corresponds to the correct layout order in the virtual\n \t function table.\n \n-         For a non-virtual destructor, we do not build a deleting\n+\t For a non-virtual destructor, we do not build a deleting\n \t destructor.  */\n       if (DECL_VIRTUAL_P (fn))\n \t{\n@@ -4126,7 +4126,7 @@ create_vtable_ptr (tree t, tree* virtuals_p)\n \t class constructor was inlined, we could generate bad code for\n \t setting up the vtable pointer.\n \n-         Therefore, we use one type for all vtable pointers.  We still\n+\t Therefore, we use one type for all vtable pointers.  We still\n \t use a type-correct type; it's just doesn't indicate the array\n \t bounds.  That's better than using `void*' or some such; it's\n \t cleaner, and it let's the alias analysis code know that these\n@@ -4308,7 +4308,7 @@ layout_virtual_bases (record_layout_info rli, splay_tree offsets)\n \t\t\t       bitsize_unit_node),\n \t\t   BINFO_OFFSET (vbase))))\n \t    warning (0, \"offset of virtual base %qT is not ABI-compliant and \"\n-                     \"may change in a future version of GCC\",\n+\t\t     \"may change in a future version of GCC\",\n \t\t     basetype);\n \n \t  first_vbase = false;\n@@ -4542,7 +4542,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \t       struct S1;\n \t       struct S2 { static S1 s1; };\n \n-             At this point, finish_record_layout will be called, but\n+\t     At this point, finish_record_layout will be called, but\n \t     S1 is still incomplete.)  */\n \t  if (TREE_CODE (field) == VAR_DECL)\n \t    {\n@@ -4663,7 +4663,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \t\t\t\t\t DECL_FIELD_BIT_OFFSET (field),\n \t\t\t\t\t bitsize_unit_node)))\n \tcp_warning_at (\"offset of %qD is not ABI-compliant and may \"\n-                       \"change in a future version of GCC\",\n+\t\t       \"change in a future version of GCC\",\n \t\t       field);\n \n       /* G++ used to use DECL_FIELD_OFFSET as if it were the byte\n@@ -4989,8 +4989,8 @@ finish_struct_1 (tree t)\n   if (n_fields > 7)\n     {\n       struct sorted_fields_type *field_vec = GGC_NEWVAR\n-         (struct sorted_fields_type,\n-          sizeof (struct sorted_fields_type) + n_fields * sizeof (tree));\n+\t (struct sorted_fields_type,\n+\t  sizeof (struct sorted_fields_type) + n_fields * sizeof (tree));\n       field_vec->len = n_fields;\n       add_fields_to_record_type (TYPE_FIELDS (t), field_vec, 0);\n       qsort (field_vec->elts, n_fields, sizeof (tree),\n@@ -5198,7 +5198,7 @@ fixed_type_or_null (tree instance, int* nonnull, int* cdtorp)\n       /* If this component is really a base class reference, then the field\n \t itself isn't definitive.  */\n       if (DECL_FIELD_IS_BASE (TREE_OPERAND (instance, 1)))\n-        return fixed_type_or_null (TREE_OPERAND (instance, 0), nonnull, cdtorp);\n+\treturn fixed_type_or_null (TREE_OPERAND (instance, 0), nonnull, cdtorp);\n       return fixed_type_or_null (TREE_OPERAND (instance, 1), nonnull, cdtorp);\n \n     case VAR_DECL:\n@@ -5221,24 +5221,24 @@ fixed_type_or_null (tree instance, int* nonnull, int* cdtorp)\n \t  return TREE_TYPE (instance);\n \t}\n       else if (instance == current_class_ptr)\n-        {\n-          if (nonnull)\n-            *nonnull = 1;\n-\n-          /* if we're in a ctor or dtor, we know our type.  */\n-          if (DECL_LANG_SPECIFIC (current_function_decl)\n-              && (DECL_CONSTRUCTOR_P (current_function_decl)\n-                  || DECL_DESTRUCTOR_P (current_function_decl)))\n-            {\n-              if (cdtorp)\n-                *cdtorp = 1;\n-              return TREE_TYPE (TREE_TYPE (instance));\n-            }\n-        }\n+\t{\n+\t  if (nonnull)\n+\t    *nonnull = 1;\n+\n+\t  /* if we're in a ctor or dtor, we know our type.  */\n+\t  if (DECL_LANG_SPECIFIC (current_function_decl)\n+\t      && (DECL_CONSTRUCTOR_P (current_function_decl)\n+\t\t  || DECL_DESTRUCTOR_P (current_function_decl)))\n+\t    {\n+\t      if (cdtorp)\n+\t\t*cdtorp = 1;\n+\t      return TREE_TYPE (TREE_TYPE (instance));\n+\t    }\n+\t}\n       else if (TREE_CODE (TREE_TYPE (instance)) == REFERENCE_TYPE)\n-        {\n-          /* Reference variables should be references to objects.  */\n-          if (nonnull)\n+\t{\n+\t  /* Reference variables should be references to objects.  */\n+\t  if (nonnull)\n \t    *nonnull = 1;\n \n \t  /* DECL_VAR_MARKED_P is used to prevent recursion; a\n@@ -5623,8 +5623,8 @@ resolve_address_of_overloaded_function (tree target_type,\n     {\n       if (flags & tf_error)\n \terror (\"cannot resolve overloaded function %qD based on\"\n-               \" conversion to type %qT\",\n-               DECL_NAME (OVL_FUNCTION (overload)), target_type);\n+\t       \" conversion to type %qT\",\n+\t       DECL_NAME (OVL_FUNCTION (overload)), target_type);\n       return error_mark_node;\n     }\n \n@@ -5747,15 +5747,15 @@ resolve_address_of_overloaded_function (tree target_type,\n       /* There were *no* matches.  */\n       if (flags & tf_error)\n \t{\n- \t  error (\"no matches converting function %qD to type %q#T\",\n-                 DECL_NAME (OVL_FUNCTION (overload)),\n-                 target_type);\n+\t  error (\"no matches converting function %qD to type %q#T\",\n+\t\t DECL_NAME (OVL_FUNCTION (overload)),\n+\t\t target_type);\n \n \t  /* print_candidates expects a chain with the functions in\n-             TREE_VALUE slots, so we cons one up here (we're losing anyway,\n-             so why be clever?).  */\n-          for (; overload; overload = OVL_NEXT (overload))\n-            matches = tree_cons (NULL_TREE, OVL_CURRENT (overload),\n+\t     TREE_VALUE slots, so we cons one up here (we're losing anyway,\n+\t     so why be clever?).  */\n+\t  for (; overload; overload = OVL_NEXT (overload))\n+\t    matches = tree_cons (NULL_TREE, OVL_CURRENT (overload),\n \t\t\t\t matches);\n \n \t  print_candidates (matches);\n@@ -5770,7 +5770,7 @@ resolve_address_of_overloaded_function (tree target_type,\n \t{\n \t  tree match;\n \n- \t  error (\"converting overloaded function %qD to type %q#T is ambiguous\",\n+\t  error (\"converting overloaded function %qD to type %q#T is ambiguous\",\n \t\t    DECL_NAME (OVL_FUNCTION (overload)),\n \t\t    target_type);\n \n@@ -5794,14 +5794,14 @@ resolve_address_of_overloaded_function (tree target_type,\n       static int explained;\n \n       if (!(flags & tf_error))\n-        return error_mark_node;\n+\treturn error_mark_node;\n \n       pedwarn (\"assuming pointer to member %qD\", fn);\n       if (!explained)\n-        {\n-          pedwarn (\"(a pointer to member can only be formed with %<&%E%>)\", fn);\n-          explained = 1;\n-        }\n+\t{\n+\t  pedwarn (\"(a pointer to member can only be formed with %<&%E%>)\", fn);\n+\t  explained = 1;\n+\t}\n     }\n \n   /* If we're doing overload resolution purely for the purpose of\n@@ -6061,7 +6061,7 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n     case ADDR_EXPR:\n     {\n       if (PTRMEM_OK_P (rhs))\n-        flags |= tf_ptrmem_ok;\n+\tflags |= tf_ptrmem_ok;\n \n       return instantiate_type (lhstype, TREE_OPERAND (rhs, 0), flags);\n     }\n@@ -6123,7 +6123,7 @@ print_class_statistics (void)\n \n /* Build a dummy reference to ourselves so Derived::Base (and A::A) works,\n    according to [class]:\n-                                          The class-name is also inserted\n+\t\t\t\t\t  The class-name is also inserted\n    into  the scope of the class itself.  For purposes of access checking,\n    the inserted class name is treated as if it were a public member name.  */\n \n@@ -6313,10 +6313,10 @@ maybe_indent_hierarchy (FILE * stream, int indent, int indented_p)\n \n static tree\n dump_class_hierarchy_r (FILE *stream,\n-                        int flags,\n-                        tree binfo,\n-                        tree igo,\n-                        int indent)\n+\t\t\tint flags,\n+\t\t\ttree binfo,\n+\t\t\ttree igo,\n+\t\t\tint indent)\n {\n   int indented = 0;\n   tree base_binfo;\n@@ -6808,10 +6808,10 @@ dfs_build_secondary_vptr_vtt_inits (tree binfo, void *data_)\n \n       if (BINFO_VIRTUAL_P (binfo))\n \t{\n-          /* It's a primary virtual base, and this is not a\n-             construction vtable.  Find the base this is primary of in\n-             the inheritance graph, and use that base's vtable\n-             now.  */\n+\t  /* It's a primary virtual base, and this is not a\n+\t     construction vtable.  Find the base this is primary of in\n+\t     the inheritance graph, and use that base's vtable\n+\t     now.  */\n \t  while (BINFO_PRIMARY_P (binfo))\n \t    binfo = BINFO_INHERITANCE_CHAIN (binfo);\n \t}\n@@ -6922,10 +6922,10 @@ build_ctor_vtbl_group (tree binfo, tree t)\n \n static void\n accumulate_vtbl_inits (tree binfo,\n-                       tree orig_binfo,\n-                       tree rtti_binfo,\n-                       tree t,\n-                       tree inits)\n+\t\t       tree orig_binfo,\n+\t\t       tree rtti_binfo,\n+\t\t       tree t,\n+\t\t       tree inits)\n {\n   int i;\n   tree base_binfo;\n@@ -6972,10 +6972,10 @@ accumulate_vtbl_inits (tree binfo,\n \n static tree\n dfs_accumulate_vtbl_inits (tree binfo,\n-                           tree orig_binfo,\n-                           tree rtti_binfo,\n-                           tree t,\n-                           tree l)\n+\t\t\t   tree orig_binfo,\n+\t\t\t   tree rtti_binfo,\n+\t\t\t   tree t,\n+\t\t\t   tree l)\n {\n   tree inits = NULL_TREE;\n   tree vtbl = NULL_TREE;\n@@ -7097,10 +7097,10 @@ static GTY(()) tree abort_fndecl_addr;\n \n static tree\n build_vtbl_initializer (tree binfo,\n-                        tree orig_binfo,\n-                        tree t,\n-                        tree rtti_binfo,\n-                        int* non_fn_entries_p)\n+\t\t\ttree orig_binfo,\n+\t\t\ttree t,\n+\t\t\ttree rtti_binfo,\n+\t\t\tint* non_fn_entries_p)\n {\n   tree v, b;\n   tree vfun_inits;\n@@ -7261,7 +7261,7 @@ build_vtbl_initializer (tree binfo,\n \t      }\n \t}\n       else\n-        vfun_inits = tree_cons (NULL_TREE, init, vfun_inits);\n+\tvfun_inits = tree_cons (NULL_TREE, init, vfun_inits);\n     }\n \n   /* The initializers for virtual functions were built up in reverse\n@@ -7638,7 +7638,7 @@ build_rtti_vtbl_entries (tree binfo, vtbl_init_data* vid)\n      primary base, and then add the offset in the vtbl to that value.  */\n   b = binfo;\n   while (CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (b))\n-         && !BINFO_LOST_PRIMARY_P (b))\n+\t && !BINFO_LOST_PRIMARY_P (b))\n     {\n       tree primary_base;\n "}, {"sha": "785498b9e90622f4673f9527c86135fce6bd3dd9", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -409,7 +409,7 @@ cp_gimplify_init_expr (tree *expr_p, tree *pre_p, tree *post_p)\n       *expr_p = from;\n \n       /* The initialization is now a side-effect, so the container can\n-         become void.  */\n+\t become void.  */\n       if (from != sub)\n \tTREE_TYPE (from) = void_type_node;\n     }"}, {"sha": "3bbe56be32bb220e95223e8d6a50748e3c271e5f", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -89,15 +89,15 @@ cp_expr_size (tree exp)\n \t\t  /* And, the gimplifier will sometimes make a copy of\n \t\t     an aggregate.  In particular, for a case like:\n \n-\t\t        struct S { S(); };\n-                        struct X { int a; S s; };\n-                        X x = { 0 };\n-\n-                     the gimplifier will create a temporary with\n-                     static storage duration, perform static\n-                     initialization of the temporary, and then copy\n-                     the result.  Since the \"s\" subobject is never\n-                     constructed, this is a valid transformation.  */\n+\t\t\tstruct S { S(); };\n+\t\t\tstruct X { int a; S s; };\n+\t\t\tX x = { 0 };\n+\n+\t\t     the gimplifier will create a temporary with\n+\t\t     static storage duration, perform static\n+\t\t     initialization of the temporary, and then copy\n+\t\t     the result.  Since the \"s\" subobject is never\n+\t\t     constructed, this is a valid transformation.  */\n \t\t  || CP_AGGREGATE_TYPE_P (type));\n \n       /* This would be wrong for a type with virtual bases, but they are\n@@ -118,9 +118,9 @@ cp_tree_size (enum tree_code code)\n   switch (code)\n     {\n     case TINST_LEVEL:\t\treturn sizeof (struct tinst_level_s);\n-    case PTRMEM_CST: \t\treturn sizeof (struct ptrmem_cst);\n+    case PTRMEM_CST:\t\treturn sizeof (struct ptrmem_cst);\n     case BASELINK:\t\treturn sizeof (struct tree_baselink);\n-    case TEMPLATE_PARM_INDEX: \treturn sizeof (template_parm_index);\n+    case TEMPLATE_PARM_INDEX:\treturn sizeof (template_parm_index);\n     case DEFAULT_ARG:\t\treturn sizeof (struct tree_default_arg);\n     case OVERLOAD:\t\treturn sizeof (struct tree_overload);\n     default:"}, {"sha": "82e39390b566cbb21f21d0210133492bbc386301", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -108,17 +108,17 @@ DEFTREECODE (BASELINK, \"baselink\", tcc_exceptional, 0)\n /* Template definition.  The following fields have the specified uses,\n    although there are other macros in cp-tree.h that should be used for\n    accessing this data.\n-        DECL_ARGUMENTS          template parm vector\n-        DECL_TEMPLATE_INFO      template text &c\n+\tDECL_ARGUMENTS\t\ttemplate parm vector\n+\tDECL_TEMPLATE_INFO      template text &c\n \tDECL_VINDEX\t\tlist of instantiations already produced;\n \t\t\t\tonly done for functions so far\n    For class template:\n-        DECL_INITIAL            associated templates (methods &c)\n-        DECL_TEMPLATE_RESULT    null\n+\tDECL_INITIAL\t\tassociated templates (methods &c)\n+\tDECL_TEMPLATE_RESULT    null\n    For non-class templates:\n \tTREE_TYPE\t\ttype of object to be constructed\n-        DECL_TEMPLATE_RESULT    decl for object to be created\n-                                (e.g., FUNCTION_DECL with tmpl parms used)\n+\tDECL_TEMPLATE_RESULT    decl for object to be created\n+\t\t\t\t(e.g., FUNCTION_DECL with tmpl parms used)\n  */\n DEFTREECODE (TEMPLATE_DECL, \"template_decl\", tcc_declaration, 0)\n \n@@ -132,7 +132,7 @@ DEFTREECODE (TEMPLATE_DECL, \"template_decl\", tcc_declaration, 0)\n    struct S\n    {\n       template <class U, // Index 0, Level 2.\n-                class V> // Index 1, Level 2.\n+\t\tclass V> // Index 1, Level 2.\n       void f();\n    };\n \n@@ -148,7 +148,7 @@ DEFTREECODE (TEMPLATE_DECL, \"template_decl\", tcc_declaration, 0)\n    struct S<int>\n    {\n      template <class U, // Index 0, Level 1, Orig Level 2\n-               class V> // Index 1, Level 1, Orig Level 2\n+\t       class V> // Index 1, Level 1, Orig Level 2\n      void f();\n    };\n "}, {"sha": "29baa7c34b3dcf5d08d08f5af9009d952e187a2a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 510, "deletions": 494, "changes": 1004, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -70,7 +70,7 @@ struct diagnostic_context;\n       IDENTIFIER_CTOR_OR_DTOR_P (in IDENTIFIER_NODE)\n       BIND_EXPR_BODY_BLOCK (in BIND_EXPR)\n    4: TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n-          or FIELD_DECL).\n+\t  or FIELD_DECL).\n       IDENTIFIER_TYPENAME_P (in IDENTIFIER_NODE)\n       DECL_TINFO_P (in VAR_DECL)\n    5: C_IS_RESERVED_WORD (in IDENTIFIER_NODE)\n@@ -174,15 +174,15 @@ struct diagnostic_context;\n #define NON_THUNK_FUNCTION_CHECK(NODE) __extension__\t\t\t\\\n ({  const tree __t = (NODE);\t\t\t\t\t\t\\\n     if (TREE_CODE (__t) != FUNCTION_DECL &&\t\t\t\t\\\n- \tTREE_CODE (__t) != TEMPLATE_DECL && __t->decl.lang_specific\t\\\n+\tTREE_CODE (__t) != TEMPLATE_DECL && __t->decl.lang_specific\t\\\n \t&& __t->decl.lang_specific->decl_flags.thunk_p)\t\t\t\\\n       tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__, 0);\t\\\n     __t; })\n #define THUNK_FUNCTION_CHECK(NODE) __extension__\t\t\t\\\n ({  const tree __t = (NODE);\t\t\t\t\t\t\\\n     if (TREE_CODE (__t) != FUNCTION_DECL || !__t->decl.lang_specific\t\\\n \t|| !__t->decl.lang_specific->decl_flags.thunk_p)\t\t\\\n-      tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__, 0); \t\\\n+      tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__, 0);\t\\\n      __t; })\n #else\n #define NON_THUNK_FUNCTION_CHECK(NODE) (NODE)\n@@ -247,7 +247,7 @@ typedef struct ptrmem_cst * ptrmem_cst_t;\n #define SET_IDENTIFIER_NAMESPACE_VALUE(NODE, VAL) \\\n   set_namespace_binding ((NODE), current_namespace, (VAL))\n \n-#define CLEANUP_P(NODE)         TREE_LANG_FLAG_0 (TRY_BLOCK_CHECK (NODE))\n+#define CLEANUP_P(NODE)\t\tTREE_LANG_FLAG_0 (TRY_BLOCK_CHECK (NODE))\n \n #define BIND_EXPR_TRY_BLOCK(NODE) \\\n   TREE_LANG_FLAG_0 (BIND_EXPR_CHECK (NODE))\n@@ -291,7 +291,7 @@ typedef struct ptrmem_cst * ptrmem_cst_t;\n /* Returns nonzero iff NODE is a declaration for the global function\n    `main'.  */\n #define DECL_MAIN_P(NODE)\t\t\t\t\\\n-   (DECL_EXTERN_C_FUNCTION_P (NODE)                     \\\n+   (DECL_EXTERN_C_FUNCTION_P (NODE)\t\t\t\\\n     && DECL_NAME (NODE) != NULL_TREE\t\t\t\\\n     && MAIN_NAME_P (DECL_NAME (NODE)))\n \n@@ -300,14 +300,14 @@ typedef struct ptrmem_cst * ptrmem_cst_t;\n   (((struct tree_overload*)OVERLOAD_CHECK (NODE))->function)\n #define OVL_CHAIN(NODE)      TREE_CHAIN (NODE)\n /* Polymorphic access to FUNCTION and CHAIN.  */\n-#define OVL_CURRENT(NODE)     \\\n+#define OVL_CURRENT(NODE)\t\\\n   ((TREE_CODE (NODE) == OVERLOAD) ? OVL_FUNCTION (NODE) : (NODE))\n-#define OVL_NEXT(NODE)        \\\n+#define OVL_NEXT(NODE)\t\t\\\n   ((TREE_CODE (NODE) == OVERLOAD) ? TREE_CHAIN (NODE) : NULL_TREE)\n /* If set, this was imported in a using declaration.\n    This is not to confuse with being used somewhere, which\n    is not important for this node.  */\n-#define OVL_USED(NODE)        TREE_USED (NODE)\n+#define OVL_USED(NODE)\t\tTREE_USED (NODE)\n \n struct tree_overload GTY(())\n {\n@@ -557,7 +557,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n    pointer in pointer-to-member types.  */\n #define delta_type_node\t\t\tcp_global_trees[CPTI_DELTA_TYPE]\n /* The type used to represent an index into the vtable.  */\n-#define vtable_index_type               cp_global_trees[CPTI_VTABLE_INDEX_TYPE]\n+#define vtable_index_type\t\tcp_global_trees[CPTI_VTABLE_INDEX_TYPE]\n \n #define ti_desc_type_node\t\tcp_global_trees[CPTI_TI_DESC_TYPE]\n #define bltn_desc_type_node\t\tcp_global_trees[CPTI_BLTN_DESC_TYPE]\n@@ -576,7 +576,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n #define vtbl_type_node\t\t\tcp_global_trees[CPTI_VTBL_TYPE]\n #define vtbl_ptr_type_node\t\tcp_global_trees[CPTI_VTBL_PTR_TYPE]\n #define std_node\t\t\tcp_global_trees[CPTI_STD]\n-#define abi_node                        cp_global_trees[CPTI_ABI]\n+#define abi_node\t\t\tcp_global_trees[CPTI_ABI]\n #define const_type_info_type_node\tcp_global_trees[CPTI_CONST_TYPE_INFO_TYPE]\n #define type_info_ptr_type\t\tcp_global_trees[CPTI_TYPE_INFO_PTR_TYPE]\n #define abort_fndecl\t\t\tcp_global_trees[CPTI_ABORT_FNDECL]\n@@ -588,70 +588,70 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n \n /* The name of a constructor that takes an in-charge parameter to\n    decide whether or not to construct virtual base classes.  */\n-#define ctor_identifier                 cp_global_trees[CPTI_CTOR_IDENTIFIER]\n+#define ctor_identifier\t\t\tcp_global_trees[CPTI_CTOR_IDENTIFIER]\n /* The name of a constructor that constructs virtual base classes.  */\n-#define complete_ctor_identifier        cp_global_trees[CPTI_COMPLETE_CTOR_IDENTIFIER]\n+#define complete_ctor_identifier\tcp_global_trees[CPTI_COMPLETE_CTOR_IDENTIFIER]\n /* The name of a constructor that does not construct virtual base classes.  */\n-#define base_ctor_identifier            cp_global_trees[CPTI_BASE_CTOR_IDENTIFIER]\n+#define base_ctor_identifier\t\tcp_global_trees[CPTI_BASE_CTOR_IDENTIFIER]\n /* The name of a destructor that takes an in-charge parameter to\n    decide whether or not to destroy virtual base classes and whether\n    or not to delete the object.  */\n-#define dtor_identifier                 cp_global_trees[CPTI_DTOR_IDENTIFIER]\n+#define dtor_identifier\t\t\tcp_global_trees[CPTI_DTOR_IDENTIFIER]\n /* The name of a destructor that destroys virtual base classes.  */\n-#define complete_dtor_identifier        cp_global_trees[CPTI_COMPLETE_DTOR_IDENTIFIER]\n+#define complete_dtor_identifier\tcp_global_trees[CPTI_COMPLETE_DTOR_IDENTIFIER]\n /* The name of a destructor that does not destroy virtual base\n    classes.  */\n-#define base_dtor_identifier            cp_global_trees[CPTI_BASE_DTOR_IDENTIFIER]\n+#define base_dtor_identifier\t\tcp_global_trees[CPTI_BASE_DTOR_IDENTIFIER]\n /* The name of a destructor that destroys virtual base classes, and\n    then deletes the entire object.  */\n-#define deleting_dtor_identifier        cp_global_trees[CPTI_DELETING_DTOR_IDENTIFIER]\n-#define delta_identifier                cp_global_trees[CPTI_DELTA_IDENTIFIER]\n-#define in_charge_identifier            cp_global_trees[CPTI_IN_CHARGE_IDENTIFIER]\n+#define deleting_dtor_identifier\tcp_global_trees[CPTI_DELETING_DTOR_IDENTIFIER]\n+#define delta_identifier\t\tcp_global_trees[CPTI_DELTA_IDENTIFIER]\n+#define in_charge_identifier\t\tcp_global_trees[CPTI_IN_CHARGE_IDENTIFIER]\n /* The name of the parameter that contains a pointer to the VTT to use\n    for this subobject constructor or destructor.  */\n-#define vtt_parm_identifier             cp_global_trees[CPTI_VTT_PARM_IDENTIFIER]\n-#define nelts_identifier                cp_global_trees[CPTI_NELTS_IDENTIFIER]\n-#define this_identifier                 cp_global_trees[CPTI_THIS_IDENTIFIER]\n-#define pfn_identifier                  cp_global_trees[CPTI_PFN_IDENTIFIER]\n-#define vptr_identifier                 cp_global_trees[CPTI_VPTR_IDENTIFIER]\n+#define vtt_parm_identifier\t\tcp_global_trees[CPTI_VTT_PARM_IDENTIFIER]\n+#define nelts_identifier\t\tcp_global_trees[CPTI_NELTS_IDENTIFIER]\n+#define this_identifier\t\t\tcp_global_trees[CPTI_THIS_IDENTIFIER]\n+#define pfn_identifier\t\t\tcp_global_trees[CPTI_PFN_IDENTIFIER]\n+#define vptr_identifier\t\t\tcp_global_trees[CPTI_VPTR_IDENTIFIER]\n /* The name of the std namespace.  */\n-#define std_identifier                  cp_global_trees[CPTI_STD_IDENTIFIER]\n-#define lang_name_c                     cp_global_trees[CPTI_LANG_NAME_C]\n-#define lang_name_cplusplus             cp_global_trees[CPTI_LANG_NAME_CPLUSPLUS]\n-#define lang_name_java                  cp_global_trees[CPTI_LANG_NAME_JAVA]\n+#define std_identifier\t\t\tcp_global_trees[CPTI_STD_IDENTIFIER]\n+#define lang_name_c\t\t\tcp_global_trees[CPTI_LANG_NAME_C]\n+#define lang_name_cplusplus\t\tcp_global_trees[CPTI_LANG_NAME_CPLUSPLUS]\n+#define lang_name_java\t\t\tcp_global_trees[CPTI_LANG_NAME_JAVA]\n \n /* Exception specifier used for throw().  */\n-#define empty_except_spec               cp_global_trees[CPTI_EMPTY_EXCEPT_SPEC]\n+#define empty_except_spec\t\tcp_global_trees[CPTI_EMPTY_EXCEPT_SPEC]\n \n /* If non-NULL, a POINTER_TYPE equivalent to (java::lang::Class*).  */\n-#define jclass_node                     cp_global_trees[CPTI_JCLASS]\n+#define jclass_node\t\t\tcp_global_trees[CPTI_JCLASS]\n \n /* The declaration for `std::terminate'.  */\n-#define terminate_node                  cp_global_trees[CPTI_TERMINATE]\n+#define terminate_node\t\t\tcp_global_trees[CPTI_TERMINATE]\n \n /* The declaration for \"__cxa_call_unexpected\".  */\n-#define call_unexpected_node            cp_global_trees[CPTI_CALL_UNEXPECTED]\n+#define call_unexpected_node\t\tcp_global_trees[CPTI_CALL_UNEXPECTED]\n \n /* A pointer to `std::atexit'.  */\n-#define atexit_node                     cp_global_trees[CPTI_ATEXIT]\n+#define atexit_node\t\t\tcp_global_trees[CPTI_ATEXIT]\n \n /* A pointer to `__dso_handle'.  */\n-#define dso_handle_node                 cp_global_trees[CPTI_DSO_HANDLE]\n+#define dso_handle_node\t\t\tcp_global_trees[CPTI_DSO_HANDLE]\n \n /* The declaration of the dynamic_cast runtime.  */\n-#define dynamic_cast_node               cp_global_trees[CPTI_DCAST]\n+#define dynamic_cast_node\t\tcp_global_trees[CPTI_DCAST]\n \n /* The type of a destructor.  */\n-#define cleanup_type                    cp_global_trees[CPTI_CLEANUP_TYPE]\n+#define cleanup_type\t\t\tcp_global_trees[CPTI_CLEANUP_TYPE]\n \n /* The type of the vtt parameter passed to subobject constructors and\n    destructors.  */\n-#define vtt_parm_type                   cp_global_trees[CPTI_VTT_PARM_TYPE]\n+#define vtt_parm_type\t\t\tcp_global_trees[CPTI_VTT_PARM_TYPE]\n \n /* A TREE_LIST of the dynamic classes whose vtables may have to be\n    emitted in this translation unit.  */\n \n-#define keyed_classes                   cp_global_trees[CPTI_KEYED_CLASSES]\n+#define keyed_classes\t\t\tcp_global_trees[CPTI_KEYED_CLASSES]\n \n /* Node to indicate default access. This must be distinct from the\n    access nodes in tree.h.  */\n@@ -828,9 +828,9 @@ struct language_function GTY(())\n /* True if NAME is the IDENTIFIER_NODE for an overloaded \"operator\n    new\" or \"operator delete\".  */\n #define NEW_DELETE_OPNAME_P(NAME)\t\t\\\n-  ((NAME) == ansi_opname (NEW_EXPR) \t\t\\\n-   || (NAME) == ansi_opname (VEC_NEW_EXPR) \t\\\n-   || (NAME) == ansi_opname (DELETE_EXPR) \t\\\n+  ((NAME) == ansi_opname (NEW_EXPR)\t\t\\\n+   || (NAME) == ansi_opname (VEC_NEW_EXPR)\t\\\n+   || (NAME) == ansi_opname (DELETE_EXPR)\t\\\n    || (NAME) == ansi_opname (VEC_DELETE_EXPR))\n \n #define ansi_opname(CODE) \\\n@@ -841,7 +841,7 @@ struct language_function GTY(())\n /* True if NODE is an erroneous expression.  */\n \n #define error_operand_p(NODE)\t\t\t\t\t\\\n-  ((NODE) == error_mark_node \t\t\t\t\t\\\n+  ((NODE) == error_mark_node\t\t\t\t\t\\\n    || ((NODE) && TREE_TYPE ((NODE)) == error_mark_node))\n \f\n /* C++ language-specific tree codes.  */\n@@ -963,7 +963,7 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n /* Nonzero iff TYPE is publicly & uniquely derived from PARENT.  */\n #define PUBLICLY_UNIQUELY_DERIVED_P(PARENT, TYPE) \\\n   (lookup_base ((TYPE), (PARENT), ba_ignore_scope | ba_check | ba_quiet, \\\n-   \t\tNULL) != NULL_TREE)\n+\t\tNULL) != NULL_TREE)\n \n /* Gives the visibility specification for a class type.  */\n #define CLASSTYPE_VISIBILITY(TYPE)\t\t\\\n@@ -1580,8 +1580,8 @@ struct lang_decl GTY(())\n \tunsigned spare : 22;\n \n \t/* For a non-thunk function decl, this is a tree list of\n-  \t   friendly classes. For a thunk function decl, it is the\n-  \t   thunked to function decl.  */\n+\t   friendly classes. For a thunk function decl, it is the\n+\t   thunked to function decl.  */\n \ttree befriending_classes;\n \n \t/* For a non-virtual FUNCTION_DECL, this is\n@@ -1607,7 +1607,7 @@ struct lang_decl GTY(())\n \t{\n \t  struct sorted_fields_type * GTY ((tag (\"0\"), reorder (\"resort_sorted_fields\")))\n \t       sorted_fields;\n- \t  struct cp_token_cache * GTY ((tag (\"2\"))) pending_inline_info;\n+\t  struct cp_token_cache * GTY ((tag (\"2\"))) pending_inline_info;\n \t  struct language_function * GTY ((tag (\"1\")))\n \t       saved_language_function;\n \t} GTY ((desc (\"%1.u3sel + %1.pending_inline_p\"))) u;\n@@ -1639,8 +1639,8 @@ struct lang_decl GTY(())\n    created by language-independent code, and has C linkage.  Most\n    VAR_DECLs have C++ linkage, and do not have DECL_LANG_SPECIFIC, but\n    we do create DECL_LANG_SPECIFIC for variables with non-C++ linkage.  */\n-#define DECL_LANGUAGE(NODE) \t\t\t\t\\\n-  (DECL_LANG_SPECIFIC (NODE) \t\t\t\t\\\n+#define DECL_LANGUAGE(NODE)\t\t\t\t\\\n+  (DECL_LANG_SPECIFIC (NODE)\t\t\t\t\\\n    ? DECL_LANG_SPECIFIC (NODE)->decl_flags.language\t\\\n    : (TREE_CODE (NODE) == FUNCTION_DECL\t\t\t\\\n       ? lang_c : lang_cplusplus))\n@@ -1721,7 +1721,7 @@ struct lang_decl GTY(())\n    clones.  This macro should be used like:\n \n       FOR_EACH_CLONE (clone, fn)\n-        { ... }\n+\t{ ... }\n \n   */\n #define FOR_EACH_CLONE(CLONE, FN)\t\t\t\\\n@@ -2136,7 +2136,7 @@ struct lang_decl GTY(())\n \n /* Nonzero if the template arguments is actually a vector of vectors,\n    rather than just a vector.  */\n-#define TMPL_ARGS_HAVE_MULTIPLE_LEVELS(NODE) \t\t\\\n+#define TMPL_ARGS_HAVE_MULTIPLE_LEVELS(NODE)\t\t\\\n   (NODE && TREE_VEC_ELT (NODE, 0)\t\t\t\\\n    && TREE_CODE (TREE_VEC_ELT (NODE, 0)) == TREE_VEC)\n \n@@ -2201,7 +2201,7 @@ struct lang_decl GTY(())\n    DECL_TI_TEMPLATE, the DECL_TI_ARGS will be {int, double}.  These\n    are always the full set of arguments required to instantiate this\n    declaration from the most general template specialized here.  */\n-#define DECL_TI_ARGS(NODE)          TI_ARGS (DECL_TEMPLATE_INFO (NODE))\n+#define DECL_TI_ARGS(NODE)\t    TI_ARGS (DECL_TEMPLATE_INFO (NODE))\n #define CLASSTYPE_TI_TEMPLATE(NODE) TI_TEMPLATE (CLASSTYPE_TEMPLATE_INFO (NODE))\n #define CLASSTYPE_TI_ARGS(NODE)     TI_ARGS (CLASSTYPE_TEMPLATE_INFO (NODE))\n \n@@ -2339,7 +2339,7 @@ struct lang_decl GTY(())\n /* Keep these codes in ascending code order.  CHAR_TYPE is used here\n    to completely fill the range.  */\n \n-#define INTEGRAL_CODE_P(CODE) \t\t\t\t\\\n+#define INTEGRAL_CODE_P(CODE)\t\t\t\t\\\n   ((CODE) == ENUMERAL_TYPE || (CODE) == BOOLEAN_TYPE\t\\\n    || (CODE) == CHAR_TYPE || (CODE) == INTEGER_TYPE)\n \n@@ -2439,10 +2439,10 @@ struct lang_decl GTY(())\n      destructor and if:\n \n        - all of the direct base classes of its class have trivial\n-         destructors,\n+\t destructors,\n \n        - for all of the non-static data members of its class that are\n-         of class type (or array thereof), each such class has a\n+\t of class type (or array thereof), each such class has a\n \t trivial destructor.  */\n #define TYPE_HAS_TRIVIAL_DESTRUCTOR(NODE) \\\n   (!TYPE_HAS_NONTRIVIAL_DESTRUCTOR (NODE))\n@@ -2473,23 +2473,23 @@ struct lang_decl GTY(())\n /* Returns true if NODE is a pointer to an object.  Keep these checks\n    in ascending tree code order.  */\n #define TYPE_PTROB_P(NODE)\t\t\t\t\t\\\n-  (TYPE_PTR_P (NODE) \t\t\t\t\t\t\\\n+  (TYPE_PTR_P (NODE)\t\t\t\t\t\t\\\n    && !(TREE_CODE (TREE_TYPE (NODE)) == VOID_TYPE\t\t\\\n-        || TREE_CODE (TREE_TYPE (NODE)) == FUNCTION_TYPE\t\\\n-        || TREE_CODE (TREE_TYPE (NODE)) == METHOD_TYPE))\n+\t|| TREE_CODE (TREE_TYPE (NODE)) == FUNCTION_TYPE\t\\\n+\t|| TREE_CODE (TREE_TYPE (NODE)) == METHOD_TYPE))\n /* Returns true if NODE is a reference to an object.  Keep these checks\n    in ascending tree code order.  */\n #define TYPE_REF_OBJ_P(NODE)\t\t\t\t\t\\\n   (TREE_CODE (NODE) == REFERENCE_TYPE\t\t\t\t\\\n    && !(TREE_CODE (TREE_TYPE (NODE)) == VOID_TYPE\t\t\\\n-        || TREE_CODE (TREE_TYPE (NODE)) == FUNCTION_TYPE\t\\\n-        || TREE_CODE (TREE_TYPE (NODE)) == METHOD_TYPE))\n+\t|| TREE_CODE (TREE_TYPE (NODE)) == FUNCTION_TYPE\t\\\n+\t|| TREE_CODE (TREE_TYPE (NODE)) == METHOD_TYPE))\n /* Returns true if NODE is a pointer to an object, or a pointer to\n    void.  Keep these checks in ascending tree code order.  */\n #define TYPE_PTROBV_P(NODE)\t\t\t\t\t\\\n-  (TYPE_PTR_P (NODE) \t\t\t\t\t\t\\\n+  (TYPE_PTR_P (NODE)\t\t\t\t\t\t\\\n    && !(TREE_CODE (TREE_TYPE (NODE)) == FUNCTION_TYPE\t\t\\\n-        || TREE_CODE (TREE_TYPE (NODE)) == METHOD_TYPE))\n+\t|| TREE_CODE (TREE_TYPE (NODE)) == METHOD_TYPE))\n /* Returns true if NODE is a pointer to function.  */\n #define TYPE_PTRFN_P(NODE)\t\t\t\t\\\n   (TREE_CODE (NODE) == POINTER_TYPE\t\t\t\\\n@@ -2536,8 +2536,8 @@ struct lang_decl GTY(())\n   do {\t\t\t\t\t\t\t\t\t\\\n     if (TYPE_LANG_SPECIFIC (NODE) == NULL)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n-\tTYPE_LANG_SPECIFIC (NODE) = GGC_CNEWVAR                         \\\n-         (struct lang_type, sizeof (struct lang_type_ptrmem));\t\\\n+\tTYPE_LANG_SPECIFIC (NODE) = GGC_CNEWVAR\t\t\t\t\\\n+\t (struct lang_type, sizeof (struct lang_type_ptrmem));\t\t\\\n \tTYPE_LANG_SPECIFIC (NODE)->u.ptrmem.h.is_lang_type_class = 0;\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n     TYPE_LANG_SPECIFIC (NODE)->u.ptrmem.record = (VALUE);\t\t\\\n@@ -2668,7 +2668,7 @@ struct lang_decl GTY(())\n    arguments are always complete.  For example, given:\n \n       template <class T> struct S1 {\n-        template <class U> struct S2 {};\n+\ttemplate <class U> struct S2 {};\n \ttemplate <class U> struct S2<U*> {};\n       };\n \n@@ -2687,7 +2687,7 @@ struct lang_decl GTY(())\n    partial instantiation.  For example, given:\n \n       template <class T> struct S {\n-        template <class U> void f(U);\n+\ttemplate <class U> void f(U);\n \ttemplate <> void f(T);\n       };\n \n@@ -2917,18 +2917,18 @@ struct lang_decl GTY(())\n \n /* These macros provide convenient access to the various _STMT nodes\n    created when parsing template declarations.  */\n-#define TRY_STMTS(NODE)         TREE_OPERAND (TRY_BLOCK_CHECK (NODE), 0)\n-#define TRY_HANDLERS(NODE)      TREE_OPERAND (TRY_BLOCK_CHECK (NODE), 1)\n+#define TRY_STMTS(NODE)\t\tTREE_OPERAND (TRY_BLOCK_CHECK (NODE), 0)\n+#define TRY_HANDLERS(NODE)\tTREE_OPERAND (TRY_BLOCK_CHECK (NODE), 1)\n \n-#define EH_SPEC_STMTS(NODE)     TREE_OPERAND (EH_SPEC_BLOCK_CHECK (NODE), 0)\n-#define EH_SPEC_RAISES(NODE)    TREE_OPERAND (EH_SPEC_BLOCK_CHECK (NODE), 1)\n+#define EH_SPEC_STMTS(NODE)\tTREE_OPERAND (EH_SPEC_BLOCK_CHECK (NODE), 0)\n+#define EH_SPEC_RAISES(NODE)\tTREE_OPERAND (EH_SPEC_BLOCK_CHECK (NODE), 1)\n \n #define USING_STMT_NAMESPACE(NODE) TREE_OPERAND (USING_STMT_CHECK (NODE), 0)\n \n /* Nonzero if this try block is a function try block.  */\n-#define FN_TRY_BLOCK_P(NODE)    TREE_LANG_FLAG_3 (TRY_BLOCK_CHECK (NODE))\n-#define HANDLER_PARMS(NODE)     TREE_OPERAND (HANDLER_CHECK (NODE), 0)\n-#define HANDLER_BODY(NODE)      TREE_OPERAND (HANDLER_CHECK (NODE), 1)\n+#define FN_TRY_BLOCK_P(NODE)\tTREE_LANG_FLAG_3 (TRY_BLOCK_CHECK (NODE))\n+#define HANDLER_PARMS(NODE)\tTREE_OPERAND (HANDLER_CHECK (NODE), 0)\n+#define HANDLER_BODY(NODE)\tTREE_OPERAND (HANDLER_CHECK (NODE), 1)\n #define HANDLER_TYPE(NODE)\tTREE_TYPE (HANDLER_CHECK (NODE))\n \n /* CLEANUP_STMT accessors.  The statement(s) covered, the cleanup to run\n@@ -2940,38 +2940,38 @@ struct lang_decl GTY(())\n /* IF_STMT accessors. These give access to the condition of the if\n    statement, the then block of the if statement, and the else block\n    of the if statement if it exists.  */\n-#define IF_COND(NODE)           TREE_OPERAND (IF_STMT_CHECK (NODE), 0)\n-#define THEN_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 1)\n-#define ELSE_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 2)\n+#define IF_COND(NODE)\t\tTREE_OPERAND (IF_STMT_CHECK (NODE), 0)\n+#define THEN_CLAUSE(NODE)\tTREE_OPERAND (IF_STMT_CHECK (NODE), 1)\n+#define ELSE_CLAUSE(NODE)\tTREE_OPERAND (IF_STMT_CHECK (NODE), 2)\n \n /* WHILE_STMT accessors. These give access to the condition of the\n    while statement and the body of the while statement, respectively.  */\n-#define WHILE_COND(NODE)        TREE_OPERAND (WHILE_STMT_CHECK (NODE), 0)\n-#define WHILE_BODY(NODE)        TREE_OPERAND (WHILE_STMT_CHECK (NODE), 1)\n+#define WHILE_COND(NODE)\tTREE_OPERAND (WHILE_STMT_CHECK (NODE), 0)\n+#define WHILE_BODY(NODE)\tTREE_OPERAND (WHILE_STMT_CHECK (NODE), 1)\n \n /* DO_STMT accessors. These give access to the condition of the do\n    statement and the body of the do statement, respectively.  */\n-#define DO_COND(NODE)           TREE_OPERAND (DO_STMT_CHECK (NODE), 0)\n-#define DO_BODY(NODE)           TREE_OPERAND (DO_STMT_CHECK (NODE), 1)\n+#define DO_COND(NODE)\t\tTREE_OPERAND (DO_STMT_CHECK (NODE), 0)\n+#define DO_BODY(NODE)\t\tTREE_OPERAND (DO_STMT_CHECK (NODE), 1)\n \n /* FOR_STMT accessors. These give access to the init statement,\n    condition, update expression, and body of the for statement,\n    respectively.  */\n-#define FOR_INIT_STMT(NODE)     TREE_OPERAND (FOR_STMT_CHECK (NODE), 0)\n-#define FOR_COND(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 1)\n-#define FOR_EXPR(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 2)\n-#define FOR_BODY(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 3)\n+#define FOR_INIT_STMT(NODE)\tTREE_OPERAND (FOR_STMT_CHECK (NODE), 0)\n+#define FOR_COND(NODE)\t\tTREE_OPERAND (FOR_STMT_CHECK (NODE), 1)\n+#define FOR_EXPR(NODE)\t\tTREE_OPERAND (FOR_STMT_CHECK (NODE), 2)\n+#define FOR_BODY(NODE)\t\tTREE_OPERAND (FOR_STMT_CHECK (NODE), 3)\n \n #define SWITCH_STMT_COND(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 0)\n #define SWITCH_STMT_BODY(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 1)\n #define SWITCH_STMT_TYPE(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 2)\n \n /* STMT_EXPR accessor.  */\n-#define STMT_EXPR_STMT(NODE)    TREE_OPERAND (STMT_EXPR_CHECK (NODE), 0)\n+#define STMT_EXPR_STMT(NODE)\tTREE_OPERAND (STMT_EXPR_CHECK (NODE), 0)\n \n /* EXPR_STMT accessor. This gives the expression associated with an\n    expression statement.  */\n-#define EXPR_STMT_EXPR(NODE)    TREE_OPERAND (EXPR_STMT_CHECK (NODE), 0)\n+#define EXPR_STMT_EXPR(NODE)\tTREE_OPERAND (EXPR_STMT_CHECK (NODE), 0)\n \n /* An enumeration of the kind of tags that C++ accepts.  */\n enum tag_types {\n@@ -2994,49 +2994,49 @@ typedef enum cp_lvalue_kind {\n \n /* Various kinds of template specialization, instantiation, etc.  */\n typedef enum tmpl_spec_kind {\n-  tsk_none,                /* Not a template at all.  */\n+  tsk_none,\t\t   /* Not a template at all.  */\n   tsk_invalid_member_spec, /* An explicit member template\n \t\t\t      specialization, but the enclosing\n \t\t\t      classes have not all been explicitly\n \t\t\t      specialized.  */\n   tsk_invalid_expl_inst,   /* An explicit instantiation containing\n \t\t\t      template parameter lists.  */\n-  tsk_excessive_parms,     /* A template declaration with too many\n+  tsk_excessive_parms,\t   /* A template declaration with too many\n \t\t\t      template parameter lists.  */\n   tsk_insufficient_parms,  /* A template declaration with too few\n \t\t\t      parameter lists.  */\n-  tsk_template,            /* A template declaration.  */\n-  tsk_expl_spec,           /* An explicit specialization.  */\n-  tsk_expl_inst            /* An explicit instantiation.  */\n+  tsk_template,\t\t   /* A template declaration.  */\n+  tsk_expl_spec,\t   /* An explicit specialization.  */\n+  tsk_expl_inst\t\t   /* An explicit instantiation.  */\n } tmpl_spec_kind;\n \n /* The various kinds of access.  BINFO_ACCESS depends on these being\n    two bit quantities.  The numerical values are important; they are\n    used to initialize RTTI data structures, so changing them changes\n    the ABI.  */\n typedef enum access_kind {\n-  ak_none = 0,             /* Inaccessible.  */\n-  ak_public = 1,           /* Accessible, as a `public' thing.  */\n-  ak_protected = 2,        /* Accessible, as a `protected' thing.  */\n-  ak_private = 3           /* Accessible, as a `private' thing.  */\n+  ak_none = 0,\t\t   /* Inaccessible.  */\n+  ak_public = 1,\t   /* Accessible, as a `public' thing.  */\n+  ak_protected = 2,\t   /* Accessible, as a `protected' thing.  */\n+  ak_private = 3\t   /* Accessible, as a `private' thing.  */\n } access_kind;\n \n /* The various kinds of special functions.  If you add to this list,\n    you should update special_function_p as well.  */\n typedef enum special_function_kind {\n-  sfk_none = 0,            /* Not a special function.  This enumeral\n+  sfk_none = 0,\t\t   /* Not a special function.  This enumeral\n \t\t\t      must have value zero; see\n \t\t\t      special_function_p.  */\n-  sfk_constructor,         /* A constructor.  */\n+  sfk_constructor,\t   /* A constructor.  */\n   sfk_copy_constructor,    /* A copy constructor.  */\n   sfk_assignment_operator, /* An assignment operator.  */\n-  sfk_destructor,          /* A destructor.  */\n+  sfk_destructor,\t   /* A destructor.  */\n   sfk_complete_destructor, /* A destructor for complete objects.  */\n   sfk_base_destructor,     /* A destructor for base subobjects.  */\n   sfk_deleting_destructor, /* A destructor for complete objects that\n \t\t\t      deletes the object after it has been\n \t\t\t      destroyed.  */\n-  sfk_conversion           /* A conversion operator.  */\n+  sfk_conversion\t   /* A conversion operator.  */\n } special_function_kind;\n \n /* The various kinds of linkage.  From [basic.link],\n@@ -3046,35 +3046,35 @@ typedef enum special_function_kind {\n       as a name introduced in another scope:\n \n       -- When a name has external linkage, the entity it denotes can\n-         be referred to from scopes of other translation units or from\n+\t be referred to from scopes of other translation units or from\n \t other scopes of the same translation unit.\n \n       -- When a name has internal linkage, the entity it denotes can\n-         be referred to by names from other scopes in the same\n+\t be referred to by names from other scopes in the same\n \t translation unit.\n \n       -- When a name has no linkage, the entity it denotes cannot be\n-         referred to by names from other scopes.  */\n+\t referred to by names from other scopes.  */\n \n typedef enum linkage_kind {\n-  lk_none,                 /* No linkage.  */\n-  lk_internal,             /* Internal linkage.  */\n-  lk_external              /* External linkage.  */\n+  lk_none,\t\t\t/* No linkage.  */\n+  lk_internal,\t\t\t/* Internal linkage.  */\n+  lk_external\t\t\t/* External linkage.  */\n } linkage_kind;\n \n /* Bitmask flags to control type substitution.  */\n typedef enum tsubst_flags_t {\n-  tf_none = 0,               /* nothing special */\n-  tf_error = 1 << 0,         /* give error messages  */\n-  tf_warning = 1 << 1,       /* give warnings too  */\n-  tf_ignore_bad_quals = 1 << 2, /* ignore bad cvr qualifiers */\n+  tf_none = 0,\t\t\t/* nothing special */\n+  tf_error = 1 << 0,\t\t/* give error messages  */\n+  tf_warning = 1 << 1,\t\t/* give warnings too  */\n+  tf_ignore_bad_quals = 1 << 2,\t/* ignore bad cvr qualifiers */\n   tf_keep_type_decl = 1 << 3,\t/* retain typedef type decls\n \t\t\t\t   (make_typename_type use) */\n-  tf_ptrmem_ok = 1 << 4,        /* pointers to member ok (internal\n+  tf_ptrmem_ok = 1 << 4,\t/* pointers to member ok (internal\n \t\t\t\t   instantiate_type use) */\n   tf_user = 1 << 5,\t\t/* found template must be a user template\n \t\t\t\t   (lookup_template_class use) */\n-  tf_conv = 1 << 6              /* We are determining what kind of\n+  tf_conv = 1 << 6\t\t/* We are determining what kind of\n \t\t\t\t   conversion might be permissible,\n \t\t\t\t   not actually performing the\n \t\t\t\t   conversion.  */\n@@ -3102,11 +3102,11 @@ typedef enum deferring_kind {\n    Values <0 indicate we failed.  */\n typedef enum base_kind {\n   bk_inaccessible = -3,   /* The base is inaccessible */\n-  bk_ambig = -2,          /* The base is ambiguous */\n-  bk_not_base = -1,       /* It is not a base */\n-  bk_same_type = 0,       /* It is the same type */\n-  bk_proper_base = 1,     /* It is a proper base */\n-  bk_via_virtual = 2      /* It is a proper base, but via a virtual\n+  bk_ambig = -2,\t  /* The base is ambiguous */\n+  bk_not_base = -1,\t  /* It is not a base */\n+  bk_same_type = 0,\t  /* It is the same type */\n+  bk_proper_base = 1,\t  /* It is a proper base */\n+  bk_via_virtual = 2\t  /* It is a proper base, but via a virtual\n \t\t\t     path. This might not be the canonical\n \t\t\t     binfo.  */\n } base_kind;\n@@ -3249,7 +3249,7 @@ extern GTY(()) VEC(tree,gc) *local_classes;\n /* Returns nonzero iff NODE is a declaration for the global function\n    `main'.  */\n #define DECL_MAIN_P(NODE)\t\t\t\t\\\n-   (DECL_EXTERN_C_FUNCTION_P (NODE)                     \\\n+   (DECL_EXTERN_C_FUNCTION_P (NODE)\t\t\t\\\n     && DECL_NAME (NODE) != NULL_TREE\t\t\t\\\n     && MAIN_NAME_P (DECL_NAME (NODE)))\n \n@@ -3353,27 +3353,27 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n /* Used with comptypes, and related functions, to guide type\n    comparison.  */\n \n-#define COMPARE_STRICT        0 /* Just check if the types are the\n+#define COMPARE_STRICT\t      0 /* Just check if the types are the\n \t\t\t\t   same.  */\n-#define COMPARE_BASE          1 /* Check to see if the second type is\n+#define COMPARE_BASE\t      1 /* Check to see if the second type is\n \t\t\t\t   derived from the first.  */\n-#define COMPARE_DERIVED       2 /* Like COMPARE_BASE, but in\n+#define COMPARE_DERIVED\t      2 /* Like COMPARE_BASE, but in\n \t\t\t\t   reverse.  */\n #define COMPARE_REDECLARATION 4 /* The comparison is being done when\n \t\t\t\t   another declaration of an existing\n \t\t\t\t   entity is seen.  */\n \n /* Used with push_overloaded_decl.  */\n-#define PUSH_GLOBAL          0  /* Push the DECL into namespace scope,\n+#define PUSH_GLOBAL\t     0  /* Push the DECL into namespace scope,\n \t\t\t\t   regardless of the current scope.  */\n-#define PUSH_LOCAL           1  /* Push the DECL into the current\n+#define PUSH_LOCAL\t     1  /* Push the DECL into the current\n \t\t\t\t   scope.  */\n-#define PUSH_USING           2  /* We are pushing this DECL as the\n+#define PUSH_USING\t     2  /* We are pushing this DECL as the\n \t\t\t\t   result of a using declaration.  */\n \n /* Used with start function.  */\n-#define SF_DEFAULT           0  /* No flags.  */\n-#define SF_PRE_PARSED        1  /* The function declaration has\n+#define SF_DEFAULT\t     0  /* No flags.  */\n+#define SF_PRE_PARSED\t     1  /* The function declaration has\n \t\t\t\t   already been parsed.  */\n #define SF_INCLASS_INLINE    2  /* The function is an inline, defined\n \t\t\t\t   in the class body.  */\n@@ -3424,18 +3424,18 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n    TFF_EXPR_IN_PARENS: parenthesize expressions.\n    TFF_NO_FUNCTION_ARGUMENTS: don't show function arguments.  */\n \n-#define TFF_PLAIN_IDENTIFIER               (0)\n-#define TFF_SCOPE                \t   (1)\n-#define TFF_CHASE_TYPEDEF                  (1 << 1)\n-#define TFF_DECL_SPECIFIERS                (1 << 2)\n-#define TFF_CLASS_KEY_OR_ENUM              (1 << 3)\n-#define TFF_RETURN_TYPE                    (1 << 4)\n-#define TFF_FUNCTION_DEFAULT_ARGUMENTS     (1 << 5)\n-#define TFF_EXCEPTION_SPECIFICATION        (1 << 6)\n-#define TFF_TEMPLATE_HEADER                (1 << 7)\n-#define TFF_TEMPLATE_NAME                  (1 << 8)\n-#define TFF_EXPR_IN_PARENS                 (1 << 9)\n-#define TFF_NO_FUNCTION_ARGUMENTS          (1 << 10)\n+#define TFF_PLAIN_IDENTIFIER\t\t\t(0)\n+#define TFF_SCOPE\t\t\t\t(1)\n+#define TFF_CHASE_TYPEDEF\t\t\t(1 << 1)\n+#define TFF_DECL_SPECIFIERS\t\t\t(1 << 2)\n+#define TFF_CLASS_KEY_OR_ENUM\t\t\t(1 << 3)\n+#define TFF_RETURN_TYPE\t\t\t\t(1 << 4)\n+#define TFF_FUNCTION_DEFAULT_ARGUMENTS\t\t(1 << 5)\n+#define TFF_EXCEPTION_SPECIFICATION\t\t(1 << 6)\n+#define TFF_TEMPLATE_HEADER\t\t\t(1 << 7)\n+#define TFF_TEMPLATE_NAME\t\t\t(1 << 8)\n+#define TFF_EXPR_IN_PARENS\t\t\t(1 << 9)\n+#define TFF_NO_FUNCTION_ARGUMENTS\t\t(1 << 10)\n \n /* Returns the TEMPLATE_DECL associated to a TEMPLATE_TEMPLATE_PARM\n    node.  */\n@@ -3592,7 +3592,7 @@ struct cp_declarator {\n     /* For identifiers.  */\n     struct {\n       /* If non-NULL, the qualifying scope (a NAMESPACE_DECL or\n-         *_TYPE) for this identifier.  */\n+\t *_TYPE) for this identifier.  */\n       tree qualifying_scope;\n       /* The unqualified name of the entity -- an IDENTIFIER_NODE,\n \t BIT_NOT_EXPR, or TEMPLATE_ID_EXPR.  */\n@@ -3633,53 +3633,54 @@ extern cp_declarator *cp_error_declarator;\n extern cp_parameter_declarator *no_parameters;\n \n /* in call.c */\n-extern bool check_dtor_name (tree, tree);\n+extern bool check_dtor_name\t\t\t(tree, tree);\n \n extern tree build_vfield_ref\t\t\t(tree, tree);\n extern tree build_conditional_expr\t\t(tree, tree, tree);\n-extern tree build_addr_func (tree);\n-extern tree build_call (tree, tree);\n-extern bool null_ptr_cst_p (tree);\n-extern bool sufficient_parms_p (tree);\n-extern tree type_decays_to (tree);\n-extern tree build_user_type_conversion (tree, tree, int);\n-extern tree build_new_function_call (tree, tree);\n-extern tree build_operator_new_call (tree, tree, tree *, tree *);\n-extern tree build_new_method_call (tree, tree, tree, tree, int);\n-extern tree build_special_member_call (tree, tree, tree, tree, int);\n-extern tree build_new_op (enum tree_code, int, tree, tree, tree, bool *);\n-extern tree build_op_delete_call (enum tree_code, tree, tree, bool, tree);\n-extern bool can_convert (tree, tree);\n-extern bool can_convert_arg (tree, tree, tree);\n-extern bool can_convert_arg_bad (tree, tree, tree);\n-extern bool enforce_access (tree, tree);\n-extern tree convert_default_arg (tree, tree, tree, int);\n-extern tree convert_arg_to_ellipsis (tree);\n-extern tree build_x_va_arg (tree, tree);\n-extern tree cxx_type_promotes_to (tree);\n-extern tree type_passed_as (tree);\n-extern tree convert_for_arg_passing (tree, tree);\n-extern bool is_properly_derived_from (tree, tree);\n-extern tree initialize_reference (tree, tree, tree, tree *);\n-extern tree make_temporary_var_for_ref_to_temp (tree, tree);\n-extern tree strip_top_quals (tree);\n-extern tree perform_implicit_conversion (tree, tree);\n+extern tree build_addr_func\t\t\t(tree);\n+extern tree build_call\t\t\t\t(tree, tree);\n+extern bool null_ptr_cst_p\t\t\t(tree);\n+extern bool sufficient_parms_p\t\t\t(tree);\n+extern tree type_decays_to\t\t\t(tree);\n+extern tree build_user_type_conversion\t\t(tree, tree, int);\n+extern tree build_new_function_call\t\t(tree, tree);\n+extern tree build_operator_new_call\t\t(tree, tree, tree *, tree *);\n+extern tree build_new_method_call\t\t(tree, tree, tree, tree, int);\n+extern tree build_special_member_call\t\t(tree, tree, tree, tree, int);\n+extern tree build_new_op\t\t\t(enum tree_code, int, tree, tree, tree, bool *);\n+extern tree build_op_delete_call\t\t(enum tree_code, tree, tree, bool, tree);\n+extern bool can_convert\t\t\t\t(tree, tree);\n+extern bool can_convert_arg\t\t\t(tree, tree, tree);\n+extern bool can_convert_arg_bad\t\t\t(tree, tree, tree);\n+extern bool enforce_access\t\t\t(tree, tree);\n+extern tree convert_default_arg\t\t\t(tree, tree, tree, int);\n+extern tree convert_arg_to_ellipsis\t\t(tree);\n+extern tree build_x_va_arg\t\t\t(tree, tree);\n+extern tree cxx_type_promotes_to\t\t(tree);\n+extern tree type_passed_as\t\t\t(tree);\n+extern tree convert_for_arg_passing\t\t(tree, tree);\n+extern bool is_properly_derived_from\t\t(tree, tree);\n+extern tree initialize_reference\t\t(tree, tree, tree, tree *);\n+extern tree make_temporary_var_for_ref_to_temp\t(tree, tree);\n+extern tree strip_top_quals\t\t\t(tree);\n+extern tree perform_implicit_conversion\t\t(tree, tree);\n extern tree perform_direct_initialization_if_possible (tree, tree, bool);\n-extern tree in_charge_arg_for_name (tree);\n-extern tree build_cxx_call (tree, tree);\n+extern tree in_charge_arg_for_name\t\t(tree);\n+extern tree build_cxx_call\t\t\t(tree, tree);\n #ifdef ENABLE_CHECKING\n-extern void validate_conversion_obstack (void);\n+extern void validate_conversion_obstack\t\t(void);\n #endif /* ENABLE_CHECKING */\n \n /* in class.c */\n-extern tree build_base_path\t\t\t(enum tree_code, tree, tree, int);\n-extern tree convert_to_base                     (tree, tree, bool, bool);\n-extern tree convert_to_base_statically (tree, tree);\n+extern tree build_base_path\t\t\t(enum tree_code, tree,\n+\t\t\t\t\t\t tree, int);\n+extern tree convert_to_base\t\t\t(tree, tree, bool, bool);\n+extern tree convert_to_base_statically\t\t(tree, tree);\n extern tree build_vtbl_ref\t\t\t(tree, tree);\n extern tree build_vfn_ref\t\t\t(tree, tree);\n-extern tree get_vtable_decl                     (tree, int);\n-extern void resort_type_method_vec\n-  (void *, void *, gt_pointer_operator, void *);\n+extern tree get_vtable_decl\t\t\t(tree, int);\n+extern void resort_type_method_vec\t\t(void *, void *,\n+\t\t\t\t\t\t gt_pointer_operator, void *);\n extern void add_method\t\t\t\t(tree, tree, tree);\n extern int currently_open_class\t\t\t(tree);\n extern tree currently_open_derived_class\t(tree);\n@@ -3696,45 +3697,45 @@ extern int current_lang_depth\t\t\t(void);\n extern void push_lang_context\t\t\t(tree);\n extern void pop_lang_context\t\t\t(void);\n extern tree instantiate_type\t\t\t(tree, tree, tsubst_flags_t);\n-extern void print_class_statistics              (void);\n+extern void print_class_statistics\t\t(void);\n extern void cxx_print_statistics\t\t(void);\n-extern void cxx_print_xnode (FILE *, tree, int);\n-extern void cxx_print_decl (FILE *, tree, int);\n-extern void cxx_print_type (FILE *, tree, int);\n-extern void cxx_print_identifier (FILE *, tree, int);\n+extern void cxx_print_xnode\t\t\t(FILE *, tree, int);\n+extern void cxx_print_decl\t\t\t(FILE *, tree, int);\n+extern void cxx_print_type\t\t\t(FILE *, tree, int);\n+extern void cxx_print_identifier\t\t(FILE *, tree, int);\n extern void cxx_print_error_function\t(struct diagnostic_context *,\n \t\t\t\t\t\t const char *);\n extern void build_self_reference\t\t(void);\n extern int same_signature_p\t\t\t(tree, tree);\n extern void warn_hidden\t\t\t\t(tree);\n extern void maybe_add_class_template_decl_list\t(tree, tree, int);\n-extern void unreverse_member_declarations       (tree);\n-extern void invalidate_class_lookup_cache       (void);\n-extern void maybe_note_name_used_in_class       (tree, tree);\n-extern void note_name_declared_in_class         (tree, tree);\n-extern tree get_vtbl_decl_for_binfo             (tree);\n-extern tree get_vtt_name                        (tree);\n-extern tree get_primary_binfo                   (tree);\n+extern void unreverse_member_declarations\t(tree);\n+extern void invalidate_class_lookup_cache\t(void);\n+extern void maybe_note_name_used_in_class\t(tree, tree);\n+extern void note_name_declared_in_class\t\t(tree, tree);\n+extern tree get_vtbl_decl_for_binfo\t\t(tree);\n+extern tree get_vtt_name\t\t\t(tree);\n+extern tree get_primary_binfo\t\t\t(tree);\n extern void debug_class\t\t\t\t(tree);\n-extern void debug_thunks \t\t\t(tree);\n+extern void debug_thunks\t\t\t(tree);\n extern tree cp_fold_obj_type_ref\t\t(tree, tree);\n-extern void set_linkage_according_to_type       (tree, tree);\n-extern void determine_key_method                (tree);\n-extern void check_for_override                  (tree, tree);\n+extern void set_linkage_according_to_type\t(tree, tree);\n+extern void determine_key_method\t\t(tree);\n+extern void check_for_override\t\t\t(tree, tree);\n \n /* in cvt.c */\n-extern tree convert_to_reference (tree, tree, int, int, tree);\n-extern tree convert_from_reference (tree);\n-extern tree force_rvalue (tree);\n-extern tree ocp_convert (tree, tree, int, int);\n-extern tree cp_convert (tree, tree);\n-extern tree convert_to_void (tree, const char */*implicit context*/);\n-extern tree convert_force (tree, tree, int);\n-extern tree build_type_conversion (tree, tree);\n-extern tree build_expr_type_conversion (int, tree, bool);\n-extern tree type_promotes_to (tree);\n-extern tree perform_qualification_conversions (tree, tree);\n-extern void clone_function_decl                 (tree, int);\n+extern tree convert_to_reference\t\t(tree, tree, int, int, tree);\n+extern tree convert_from_reference\t\t(tree);\n+extern tree force_rvalue\t\t\t(tree);\n+extern tree ocp_convert\t\t\t\t(tree, tree, int, int);\n+extern tree cp_convert\t\t\t\t(tree, tree);\n+extern tree convert_to_void\t(tree, const char */*implicit context*/);\n+extern tree convert_force\t\t\t(tree, tree, int);\n+extern tree build_type_conversion\t\t(tree, tree);\n+extern tree build_expr_type_conversion\t\t(int, tree, bool);\n+extern tree type_promotes_to\t\t\t(tree);\n+extern tree perform_qualification_conversions\t(tree, tree);\n+extern void clone_function_decl\t\t\t(tree, int);\n extern void adjust_clone_args\t\t\t(tree);\n \n /* decl.c */\n@@ -3743,27 +3744,27 @@ extern void insert_block\t\t\t(tree);\n extern tree pushdecl\t\t\t\t(tree);\n extern void cxx_init_decl_processing\t\t(void);\n enum cp_tree_node_structure_enum cp_tree_node_structure\n-  (union lang_tree_node *);\n+\t\t\t\t\t\t(union lang_tree_node *);\n extern bool cxx_mark_addressable\t\t(tree);\n extern void cxx_push_function_context\t\t(struct function *);\n extern void cxx_pop_function_context\t\t(struct function *);\n-extern void maybe_push_cleanup_level (tree);\n-extern void finish_scope                        (void);\n+extern void maybe_push_cleanup_level\t\t(tree);\n+extern void finish_scope\t\t\t(void);\n extern void push_switch\t\t\t\t(tree);\n extern void pop_switch\t\t\t\t(void);\n extern tree pushtag\t\t\t\t(tree, tree, tag_scope);\n extern tree make_anon_name\t\t\t(void);\n extern int decls_match\t\t\t\t(tree, tree);\n extern tree duplicate_decls\t\t\t(tree, tree);\n extern tree pushdecl_top_level\t\t\t(tree);\n-extern tree pushdecl_top_level_and_finish       (tree, tree);\n-extern tree push_using_decl                     (tree, tree);\n-extern tree declare_local_label                 (tree);\n+extern tree pushdecl_top_level_and_finish\t(tree, tree);\n+extern tree push_using_decl\t\t\t(tree, tree);\n+extern tree declare_local_label\t\t\t(tree);\n extern tree define_label\t\t\t(location_t, tree);\n extern void check_goto\t\t\t\t(tree);\n extern tree make_typename_type\t\t\t(tree, tree, enum tag_types, tsubst_flags_t);\n extern tree make_unbound_class_template\t\t(tree, tree, tree, tsubst_flags_t);\n-extern tree check_for_out_of_scope_variable     (tree);\n+extern tree check_for_out_of_scope_variable\t(tree);\n extern tree build_library_fn\t\t\t(tree, tree);\n extern tree build_library_fn_ptr\t\t(const char *, tree);\n extern tree build_cp_library_fn_ptr\t\t(const char *, tree);\n@@ -3779,10 +3780,10 @@ extern void cp_finish_decl\t\t\t(tree, tree, tree, int);\n extern void finish_decl\t\t\t\t(tree, tree, tree);\n extern int cp_complete_array_type\t\t(tree *, tree, bool);\n extern tree build_ptrmemfunc_type\t\t(tree);\n-extern tree build_ptrmem_type                   (tree, tree);\n+extern tree build_ptrmem_type\t\t\t(tree, tree);\n /* the grokdeclarator prototype is in decl.h */\n extern int copy_fn_p\t\t\t\t(tree);\n-extern tree get_scope_of_declarator             (const cp_declarator *);\n+extern tree get_scope_of_declarator\t\t(const cp_declarator *);\n extern void grok_special_member_properties\t(tree);\n extern int grok_ctor_properties\t\t\t(tree, tree);\n extern void grok_op_properties\t\t\t(tree, bool);\n@@ -3792,92 +3793,97 @@ extern void xref_basetypes\t\t\t(tree, tree);\n extern tree start_enum\t\t\t\t(tree);\n extern void finish_enum\t\t\t\t(tree);\n extern void build_enumerator\t\t\t(tree, tree, tree);\n-extern void start_preparsed_function            (tree, tree, int);\n+extern void start_preparsed_function\t\t(tree, tree, int);\n extern int start_function\t\t\t(cp_decl_specifier_seq *, const cp_declarator *, tree);\n extern tree begin_function_body\t\t\t(void);\n extern void finish_function_body\t\t(tree);\n extern tree finish_function\t\t\t(int);\n extern tree start_method\t\t\t(cp_decl_specifier_seq *, const cp_declarator *, tree);\n extern tree finish_method\t\t\t(tree);\n-extern void maybe_register_incomplete_var       (tree);\n+extern void maybe_register_incomplete_var\t(tree);\n extern void complete_vars\t\t\t(tree);\n extern void finish_stmt\t\t\t\t(void);\n extern void print_other_binding_stack\t\t(struct cp_binding_level *);\n-extern void revert_static_member_fn             (tree);\n-extern void fixup_anonymous_aggr                (tree);\n-extern int check_static_variable_definition     (tree, tree);\n+extern void revert_static_member_fn\t\t(tree);\n+extern void fixup_anonymous_aggr\t\t(tree);\n+extern int check_static_variable_definition\t(tree, tree);\n extern tree compute_array_index_type\t\t(tree, tree);\n-extern tree check_default_argument              (tree, tree);\n-typedef int (*walk_namespaces_fn)               (tree, void *);\n-extern int walk_namespaces                      (walk_namespaces_fn,\n-\t\t\t\t\t\t       void *);\n-extern int wrapup_globals_for_namespace         (tree, void *);\n-extern tree create_implicit_typedef             (tree, tree);\n-extern tree maybe_push_decl                     (tree);\n+extern tree check_default_argument\t\t(tree, tree);\n+typedef int (*walk_namespaces_fn)\t\t(tree, void *);\n+extern int walk_namespaces\t\t\t(walk_namespaces_fn,\n+\t\t\t\t\t\t void *);\n+extern int wrapup_globals_for_namespace\t\t(tree, void *);\n+extern tree create_implicit_typedef\t\t(tree, tree);\n+extern tree maybe_push_decl\t\t\t(tree);\n extern tree force_target_expr\t\t\t(tree, tree);\n-extern tree build_target_expr_with_type         (tree, tree);\n-extern int local_variable_p                     (tree);\n-extern int nonstatic_local_decl_p               (tree);\n-extern tree declare_global_var                  (tree, tree);\n-extern tree register_dtor_fn                    (tree);\n-extern tmpl_spec_kind current_tmpl_spec_kind    (int);\n+extern tree build_target_expr_with_type\t\t(tree, tree);\n+extern int local_variable_p\t\t\t(tree);\n+extern int nonstatic_local_decl_p\t\t(tree);\n+extern tree declare_global_var\t\t\t(tree, tree);\n+extern tree register_dtor_fn\t\t\t(tree);\n+extern tmpl_spec_kind current_tmpl_spec_kind\t(int);\n extern tree cp_fname_init\t\t\t(const char *, tree *);\n-extern tree builtin_function (const char *name, tree type,\n-\t\t\t      int code,\n-\t\t\t      enum built_in_class cl,\n-\t\t\t      const char *libname, tree attrs);\n-extern tree check_elaborated_type_specifier     (enum tag_types, tree, bool);\n-extern void warn_extern_redeclared_static (tree, tree);\n-extern const char *cxx_comdat_group             (tree);\n+extern tree builtin_function\t\t\t(const char *name, tree type,\n+\t\t\t\t\t\t int code,\n+\t\t\t\t\t\t enum built_in_class cl,\n+\t\t\t\t\t\t const char *libname,\n+\t\t\t\t\t\t tree attrs);\n+extern tree check_elaborated_type_specifier\t(enum tag_types, tree, bool);\n+extern void warn_extern_redeclared_static\t(tree, tree);\n+extern const char *cxx_comdat_group\t\t(tree);\n extern bool cp_missing_noreturn_ok_p\t\t(tree);\n-extern void initialize_artificial_var            (tree, tree);\n-extern tree check_var_type (tree, tree);\n+extern void initialize_artificial_var\t\t(tree, tree);\n+extern tree check_var_type\t\t\t(tree, tree);\n \n extern bool have_extern_spec;\n \n /* in decl2.c */\n-extern bool check_java_method (tree);\n-extern cp_cv_quals grok_method_quals (tree, tree, cp_cv_quals);\n-extern void maybe_retrofit_in_chrg (tree);\n-extern void maybe_make_one_only\t(tree);\n-extern void grokclassfn\t(tree, tree, enum overload_flags, cp_cv_quals);\n-extern tree grok_array_decl (tree, tree);\n-extern tree delete_sanity (tree, tree, bool, int);\n-extern tree check_classfn (tree, tree, tree);\n-extern void check_member_template (tree);\n-extern tree grokfield (const cp_declarator *, cp_decl_specifier_seq *, tree, tree, tree);\n-extern tree grokbitfield (const cp_declarator *, cp_decl_specifier_seq *, tree);\n-extern void cplus_decl_attributes (tree *, tree, int);\n-extern void finish_anon_union (tree);\n-extern void cp_finish_file (void);\n-extern tree coerce_new_type (tree);\n-extern tree coerce_delete_type (tree);\n-extern void comdat_linkage (tree);\n-extern void determine_visibility (tree);\n-extern void import_export_decl (tree);\n+extern bool check_java_method\t\t\t(tree);\n+extern cp_cv_quals grok_method_quals\t\t(tree, tree, cp_cv_quals);\n+extern void maybe_retrofit_in_chrg\t\t(tree);\n+extern void maybe_make_one_only\t\t\t(tree);\n+extern void grokclassfn\t\t\t\t(tree, tree,\n+\t\t\t\t\t\t enum overload_flags,\n+\t\t\t\t\t\t cp_cv_quals);\n+extern tree grok_array_decl\t\t\t(tree, tree);\n+extern tree delete_sanity\t\t\t(tree, tree, bool, int);\n+extern tree check_classfn\t\t\t(tree, tree, tree);\n+extern void check_member_template\t\t(tree);\n+extern tree grokfield (const cp_declarator *, cp_decl_specifier_seq *,\n+\t\t       tree, tree, tree);\n+extern tree grokbitfield (const cp_declarator *, cp_decl_specifier_seq *,\n+\t\t\t  tree);\n+extern void cplus_decl_attributes\t\t(tree *, tree, int);\n+extern void finish_anon_union\t\t\t(tree);\n+extern void cp_finish_file\t\t\t(void);\n+extern tree coerce_new_type\t\t\t(tree);\n+extern tree coerce_delete_type\t\t\t(tree);\n+extern void comdat_linkage\t\t\t(tree);\n+extern void determine_visibility\t\t(tree);\n+extern void import_export_decl\t\t\t(tree);\n extern tree build_cleanup\t\t\t(tree);\n-extern tree build_offset_ref_call_from_tree     (tree, tree);\n-extern void check_default_args (tree);\n-extern void mark_used (tree);\n-extern void finish_static_data_member_decl (tree, tree, tree, int);\n-extern tree cp_build_parm_decl (tree, tree);\n-extern tree get_guard (tree);\n-extern tree get_guard_cond (tree);\n-extern tree set_guard (tree);\n-extern tree cxx_callgraph_analyze_expr (tree *, int *, tree);\n-extern void mark_needed (tree);\n-extern bool decl_needed_p (tree);\n-extern void note_vague_linkage_fn (tree);\n+extern tree build_offset_ref_call_from_tree\t(tree, tree);\n+extern void check_default_args\t\t\t(tree);\n+extern void mark_used\t\t\t\t(tree);\n+extern void finish_static_data_member_decl\t(tree, tree, tree, int);\n+extern tree cp_build_parm_decl\t\t\t(tree, tree);\n+extern tree get_guard\t\t\t\t(tree);\n+extern tree get_guard_cond\t\t\t(tree);\n+extern tree set_guard\t\t\t\t(tree);\n+extern tree cxx_callgraph_analyze_expr\t\t(tree *, int *, tree);\n+extern void mark_needed\t\t\t\t(tree);\n+extern bool decl_needed_p\t\t\t(tree);\n+extern void note_vague_linkage_fn\t\t(tree);\n \n /* in error.c */\n extern void init_error\t\t\t\t(void);\n extern const char *type_as_string\t\t(tree, int);\n extern const char *decl_as_string\t\t(tree, int);\n extern const char *expr_as_string\t\t(tree, int);\n extern const char *lang_decl_name\t\t(tree, int);\n-extern const char *language_to_string           (enum languages);\n-extern const char *class_key_or_enum_as_string  (tree);\n-extern void print_instantiation_context         (void);\n+extern const char *language_to_string\t\t(enum languages);\n+extern const char *class_key_or_enum_as_string\t(tree);\n+extern void print_instantiation_context\t\t(void);\n \n /* in except.c */\n extern void init_exception_processing\t\t(void);\n@@ -3894,12 +3900,12 @@ extern tree eh_type_info\t\t\t(tree);\n extern rtx cxx_expand_expr\t\t\t(tree, rtx,\n \t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t int, rtx *);\n-extern tree cplus_expand_constant               (tree);\n+extern tree cplus_expand_constant\t\t(tree);\n \n /* friend.c */\n extern int is_friend\t\t\t\t(tree, tree);\n extern void make_friend_class\t\t\t(tree, tree, bool);\n-extern void add_friend                          (tree, tree, bool);\n+extern void add_friend\t\t\t\t(tree, tree, bool);\n extern tree do_friend\t\t\t\t(tree, tree, tree, tree, enum overload_flags, cp_cv_quals, int);\n \n /* in init.c */\n@@ -3909,77 +3915,84 @@ extern tree build_aggr_init\t\t\t(tree, tree, int);\n extern tree build_init\t\t\t\t(tree, tree, int);\n extern int is_aggr_type\t\t\t\t(tree, int);\n extern tree get_type_value\t\t\t(tree);\n-extern tree build_zero_init       \t\t(tree, tree, bool);\n+extern tree build_zero_init\t\t\t(tree, tree, bool);\n extern tree build_offset_ref\t\t\t(tree, tree, bool);\n extern tree build_new\t\t\t\t(tree, tree, tree, tree, int);\n extern tree build_vec_init\t\t\t(tree, tree, tree, int);\n extern tree build_x_delete\t\t\t(tree, int, tree);\n-extern tree build_delete\t\t\t(tree, tree, special_function_kind, int, int);\n+extern tree build_delete\t\t\t(tree, tree,\n+\t\t\t\t\t\t special_function_kind,\n+\t\t\t\t\t\t int, int);\n extern void push_base_cleanups\t\t\t(void);\n-extern tree build_vec_delete\t\t\t(tree, tree, special_function_kind, int);\n-extern tree create_temporary_var                (tree);\n-extern void initialize_vtbl_ptrs                (tree);\n-extern tree build_java_class_ref                (tree);\n-extern tree integral_constant_value \t\t(tree);\n+extern tree build_vec_delete\t\t\t(tree, tree,\n+\t\t\t\t\t\t special_function_kind, int);\n+extern tree create_temporary_var\t\t(tree);\n+extern void initialize_vtbl_ptrs\t\t(tree);\n+extern tree build_java_class_ref\t\t(tree);\n+extern tree integral_constant_value\t\t(tree);\n \n /* in lex.c */\n extern void cxx_dup_lang_specific_decl\t\t(tree);\n extern void yyungetc\t\t\t\t(int, int);\n \n-extern tree unqualified_name_lookup_error       (tree);\n-extern tree unqualified_fn_lookup_error         (tree);\n+extern tree unqualified_name_lookup_error\t(tree);\n+extern tree unqualified_fn_lookup_error\t\t(tree);\n extern tree build_lang_decl\t\t\t(enum tree_code, tree, tree);\n extern void retrofit_lang_decl\t\t\t(tree);\n-extern tree copy_decl                           (tree);\n-extern tree copy_type                           (tree);\n+extern tree copy_decl\t\t\t\t(tree);\n+extern tree copy_type\t\t\t\t(tree);\n extern tree cxx_make_type\t\t\t(enum tree_code);\n extern tree make_aggr_type\t\t\t(enum tree_code);\n extern void yyerror\t\t\t\t(const char *);\n extern void yyhook\t\t\t\t(int);\n extern bool cxx_init\t\t\t\t(void);\n-extern void cxx_finish (void);\n+extern void cxx_finish\t\t\t\t(void);\n \n /* in method.c */\n-extern void init_method\t(void);\n-extern tree make_thunk (tree, bool, tree, tree);\n-extern void finish_thunk (tree);\n-extern void use_thunk (tree, bool);\n-extern void synthesize_method (tree);\n-extern tree implicitly_declare_fn (special_function_kind, tree, bool);\n-extern tree lazily_declare_fn (special_function_kind, tree);\n-extern tree skip_artificial_parms_for (tree, tree);\n-extern tree make_alias_for (tree, tree);\n+extern void init_method\t\t\t\t(void);\n+extern tree make_thunk\t\t\t\t(tree, bool, tree, tree);\n+extern void finish_thunk\t\t\t(tree);\n+extern void use_thunk\t\t\t\t(tree, bool);\n+extern void synthesize_method\t\t\t(tree);\n+extern tree implicitly_declare_fn\t\t(special_function_kind,\n+\t\t\t\t\t\t tree, bool);\n+extern tree lazily_declare_fn\t\t\t(special_function_kind,\n+\t\t\t\t\t\t tree);\n+extern tree skip_artificial_parms_for\t\t(tree, tree);\n+extern tree make_alias_for\t\t\t(tree, tree);\n \n /* In optimize.c */\n-extern bool maybe_clone_body (tree);\n+extern bool maybe_clone_body\t\t\t(tree);\n \n /* in pt.c */\n extern void check_template_shadow\t\t(tree);\n-extern tree get_innermost_template_args         (tree, int);\n+extern tree get_innermost_template_args\t\t(tree, int);\n extern void maybe_begin_member_template_processing (tree);\n extern void maybe_end_member_template_processing (void);\n-extern tree finish_member_template_decl         (tree);\n+extern tree finish_member_template_decl\t\t(tree);\n extern void begin_template_parm_list\t\t(void);\n-extern void begin_specialization                (void);\n-extern void reset_specialization                (void);\n-extern void end_specialization                  (void);\n-extern void begin_explicit_instantiation        (void);\n-extern void end_explicit_instantiation          (void);\n-extern tree check_explicit_specialization       (tree, tree, int, int);\n+extern void begin_specialization\t\t(void);\n+extern void reset_specialization\t\t(void);\n+extern void end_specialization\t\t\t(void);\n+extern void begin_explicit_instantiation\t(void);\n+extern void end_explicit_instantiation\t\t(void);\n+extern tree check_explicit_specialization\t(tree, tree, int, int);\n extern tree process_template_parm\t\t(tree, tree, bool);\n extern tree end_template_parm_list\t\t(tree);\n extern void end_template_decl\t\t\t(void);\n extern tree current_template_args\t\t(void);\n extern tree push_template_decl\t\t\t(tree);\n-extern tree push_template_decl_real             (tree, int);\n-extern void redeclare_class_template            (tree, tree);\n-extern tree lookup_template_class\t\t(tree, tree, tree, tree, int, tsubst_flags_t);\n-extern tree lookup_template_function            (tree, tree);\n+extern tree push_template_decl_real\t\t(tree, int);\n+extern void redeclare_class_template\t\t(tree, tree);\n+extern tree lookup_template_class\t\t(tree, tree, tree, tree,\n+\t\t\t\t\t\t int, tsubst_flags_t);\n+extern tree lookup_template_function\t\t(tree, tree);\n extern int uses_template_parms\t\t\t(tree);\n extern int uses_template_parms_level\t\t(tree, int);\n extern tree instantiate_class_template\t\t(tree);\n extern tree instantiate_template\t\t(tree, tree, tsubst_flags_t);\n-extern int fn_type_unification                  (tree, tree, tree, tree, tree, unification_kind_t);\n+extern int fn_type_unification\t\t\t(tree, tree, tree, tree,\n+\t\t\t\t\t\t tree, unification_kind_t);\n extern void mark_decl_instantiated\t\t(tree, int);\n extern int more_specialized_fn\t\t\t(tree, tree, int);\n extern void mark_class_instantiated\t\t(tree, int);\n@@ -3989,78 +4002,80 @@ extern tree instantiate_decl\t\t\t(tree, int, int);\n extern int push_tinst_level\t\t\t(tree);\n extern void pop_tinst_level\t\t\t(void);\n extern int more_specialized_class\t\t(tree, tree, tree);\n-extern int comp_template_parms                  (tree, tree);\n-extern int template_class_depth                 (tree);\n-extern int is_specialization_of                 (tree, tree);\n-extern bool is_specialization_of_friend         (tree, tree);\n-extern int comp_template_args                   (tree, tree);\n+extern int comp_template_parms\t\t\t(tree, tree);\n+extern int template_class_depth\t\t\t(tree);\n+extern int is_specialization_of\t\t\t(tree, tree);\n+extern bool is_specialization_of_friend\t\t(tree, tree);\n+extern int comp_template_args\t\t\t(tree, tree);\n extern void maybe_process_partial_specialization (tree);\n-extern tree most_specialized_instantiation      (tree);\n-extern void print_candidates                    (tree);\n-extern void instantiate_pending_templates       (int);\n-extern tree tsubst_default_argument             (tree, tree, tree);\n-extern tree tsubst_copy_and_build               (tree, tree, tsubst_flags_t, tree, bool);\n+extern tree most_specialized_instantiation\t(tree);\n+extern void print_candidates\t\t\t(tree);\n+extern void instantiate_pending_templates\t(int);\n+extern tree tsubst_default_argument\t\t(tree, tree, tree);\n+extern tree tsubst_copy_and_build\t\t(tree, tree, tsubst_flags_t,\n+\t\t\t\t\t\t tree, bool);\n extern tree most_general_template\t\t(tree);\n extern tree get_mostly_instantiated_function_type (tree);\n-extern int problematic_instantiation_changed    (void);\n+extern int problematic_instantiation_changed\t(void);\n extern void record_last_problematic_instantiation (void);\n-extern tree current_instantiation               (void);\n+extern tree current_instantiation\t\t(void);\n extern tree maybe_get_template_decl_from_type_decl (tree);\n extern int processing_template_parmlist;\n-extern bool dependent_type_p                    (tree);\n+extern bool dependent_type_p\t\t\t(tree);\n extern bool any_dependent_template_arguments_p  (tree);\n-extern bool dependent_template_p                (tree);\n-extern bool dependent_template_id_p             (tree, tree);\n-extern bool type_dependent_expression_p         (tree);\n+extern bool dependent_template_p\t\t(tree);\n+extern bool dependent_template_id_p\t\t(tree, tree);\n+extern bool type_dependent_expression_p\t\t(tree);\n extern bool any_type_dependent_arguments_p      (tree);\n-extern bool value_dependent_expression_p        (tree);\n-extern tree resolve_typename_type               (tree, bool);\n-extern tree template_for_substitution           (tree);\n-extern tree build_non_dependent_expr            (tree);\n-extern tree build_non_dependent_args            (tree);\n-extern bool reregister_specialization           (tree, tree, tree);\n-extern tree fold_non_dependent_expr             (tree);\n-extern tree fold_decl_constant_value            (tree);\n+extern bool value_dependent_expression_p\t(tree);\n+extern tree resolve_typename_type\t\t(tree, bool);\n+extern tree template_for_substitution\t\t(tree);\n+extern tree build_non_dependent_expr\t\t(tree);\n+extern tree build_non_dependent_args\t\t(tree);\n+extern bool reregister_specialization\t\t(tree, tree, tree);\n+extern tree fold_non_dependent_expr\t\t(tree);\n+extern tree fold_decl_constant_value\t\t(tree);\n \n /* in repo.c */\n-extern void init_repo (void);\n-extern int repo_emit_p (tree);\n-extern bool repo_export_class_p (tree);\n-extern void finish_repo (void);\n+extern void init_repo\t\t\t\t(void);\n+extern int repo_emit_p\t\t\t\t(tree);\n+extern bool repo_export_class_p\t\t\t(tree);\n+extern void finish_repo\t\t\t\t(void);\n \n /* in rtti.c */\n /* A vector of all tinfo decls that haven't been emitted yet.  */\n extern GTY(()) VEC(tree,gc) *unemitted_tinfo_decls;\n \n-extern void init_rtti_processing (void);\n-extern tree build_typeid (tree);\n-extern tree get_tinfo_decl (tree);\n-extern tree get_typeid (tree);\n-extern tree build_dynamic_cast (tree, tree);\n-extern void emit_support_tinfos (void);\n-extern bool emit_tinfo_decl (tree);\n+extern void init_rtti_processing\t\t(void);\n+extern tree build_typeid\t\t\t(tree);\n+extern tree get_tinfo_decl\t\t\t(tree);\n+extern tree get_typeid\t\t\t\t(tree);\n+extern tree build_dynamic_cast\t\t\t(tree, tree);\n+extern void emit_support_tinfos\t\t\t(void);\n+extern bool emit_tinfo_decl\t\t\t(tree);\n \n /* in search.c */\n-extern bool accessible_base_p (tree, tree, bool);\n-extern tree lookup_base (tree, tree, base_access, base_kind *);\n-extern tree dcast_base_hint                     (tree, tree);\n-extern int accessible_p                         (tree, tree, bool);\n-extern tree lookup_field_1                      (tree, tree, bool);\n+extern bool accessible_base_p\t\t\t(tree, tree, bool);\n+extern tree lookup_base\t\t\t\t(tree, tree, base_access,\n+\t\t\t\t\t\t base_kind *);\n+extern tree dcast_base_hint\t\t\t(tree, tree);\n+extern int accessible_p\t\t\t\t(tree, tree, bool);\n+extern tree lookup_field_1\t\t\t(tree, tree, bool);\n extern tree lookup_field\t\t\t(tree, tree, int, bool);\n-extern int lookup_fnfields_1                    (tree, tree);\n-extern int class_method_index_for_fn            (tree, tree);\n+extern int lookup_fnfields_1\t\t\t(tree, tree);\n+extern int class_method_index_for_fn\t\t(tree, tree);\n extern tree lookup_fnfields\t\t\t(tree, tree, int);\n extern tree lookup_member\t\t\t(tree, tree, int, bool);\n extern int look_for_overrides\t\t\t(tree, tree);\n-extern void get_pure_virtuals\t\t        (tree);\n+extern void get_pure_virtuals\t\t\t(tree);\n extern void maybe_suppress_debug_info\t\t(tree);\n extern void note_debug_info_needed\t\t(tree);\n extern void print_search_statistics\t\t(void);\n extern void reinit_search_statistics\t\t(void);\n extern tree current_scope\t\t\t(void);\n-extern int at_function_scope_p                  (void);\n-extern bool at_class_scope_p                    (void);\n-extern bool at_namespace_scope_p                (void);\n+extern int at_function_scope_p\t\t\t(void);\n+extern bool at_class_scope_p\t\t\t(void);\n+extern bool at_namespace_scope_p\t\t(void);\n extern tree context_for_name_lookup\t\t(tree);\n extern tree lookup_conversions\t\t\t(tree);\n extern tree binfo_from_vbase\t\t\t(tree);\n@@ -4071,133 +4086,133 @@ extern tree dfs_walk_all (tree, tree (*) (tree, void *),\n \t\t\t  tree (*) (tree, void *), void *);\n extern tree dfs_walk_once (tree, tree (*) (tree, void *),\n \t\t\t   tree (*) (tree, void *), void *);\n-extern tree binfo_via_virtual                   (tree, tree);\n-extern tree build_baselink                      (tree, tree, tree, tree);\n+extern tree binfo_via_virtual\t\t\t(tree, tree);\n+extern tree build_baselink\t\t\t(tree, tree, tree, tree);\n extern tree adjust_result_of_qualified_name_lookup\n-                                                (tree, tree, tree);\n+\t\t\t\t\t\t(tree, tree, tree);\n extern tree copied_binfo\t\t\t(tree, tree);\n extern tree original_binfo\t\t\t(tree, tree);\n-extern int shared_member_p                      (tree);\n+extern int shared_member_p\t\t\t(tree);\n \n /* in semantics.c */\n extern void push_deferring_access_checks\t(deferring_kind);\n extern void resume_deferring_access_checks\t(void);\n extern void stop_deferring_access_checks\t(void);\n extern void pop_deferring_access_checks\t\t(void);\n extern tree get_deferred_access_checks\t\t(void);\n-extern void pop_to_parent_deferring_access_checks\t(void);\n+extern void pop_to_parent_deferring_access_checks (void);\n extern void perform_deferred_access_checks\t(void);\n extern void perform_or_defer_access_check\t(tree, tree);\n extern int stmts_are_full_exprs_p\t\t(void);\n-extern void init_cp_semantics                   (void);\n+extern void init_cp_semantics\t\t\t(void);\n extern tree do_poplevel\t\t\t\t(tree);\n extern void add_decl_expr\t\t\t(tree);\n-extern tree finish_expr_stmt                    (tree);\n-extern tree begin_if_stmt                       (void);\n-extern void finish_if_stmt_cond                 (tree, tree);\n-extern tree finish_then_clause                  (tree);\n+extern tree finish_expr_stmt\t\t\t(tree);\n+extern tree begin_if_stmt\t\t\t(void);\n+extern void finish_if_stmt_cond\t\t\t(tree, tree);\n+extern tree finish_then_clause\t\t\t(tree);\n extern void begin_else_clause\t\t\t(tree);\n-extern void finish_else_clause                  (tree);\n-extern void finish_if_stmt                      (tree);\n-extern tree begin_while_stmt                    (void);\n-extern void finish_while_stmt_cond              (tree, tree);\n-extern void finish_while_stmt                   (tree);\n-extern tree begin_do_stmt                       (void);\n-extern void finish_do_body                      (tree);\n-extern void finish_do_stmt                      (tree, tree);\n-extern tree finish_return_stmt                  (tree);\n-extern tree begin_for_stmt                      (void);\n-extern void finish_for_init_stmt                (tree);\n-extern void finish_for_cond                     (tree, tree);\n-extern void finish_for_expr                     (tree, tree);\n-extern void finish_for_stmt                     (tree);\n-extern tree finish_break_stmt                   (void);\n-extern tree finish_continue_stmt                (void);\n-extern tree begin_switch_stmt                   (void);\n-extern void finish_switch_cond                  (tree, tree);\n-extern void finish_switch_stmt                  (tree);\n-extern tree finish_case_label                   (tree, tree);\n-extern tree finish_goto_stmt                    (tree);\n-extern tree begin_try_block                     (void);\n-extern void finish_try_block                    (tree);\n+extern void finish_else_clause\t\t\t(tree);\n+extern void finish_if_stmt\t\t\t(tree);\n+extern tree begin_while_stmt\t\t\t(void);\n+extern void finish_while_stmt_cond\t\t(tree, tree);\n+extern void finish_while_stmt\t\t\t(tree);\n+extern tree begin_do_stmt\t\t\t(void);\n+extern void finish_do_body\t\t\t(tree);\n+extern void finish_do_stmt\t\t\t(tree, tree);\n+extern tree finish_return_stmt\t\t\t(tree);\n+extern tree begin_for_stmt\t\t\t(void);\n+extern void finish_for_init_stmt\t\t(tree);\n+extern void finish_for_cond\t\t\t(tree, tree);\n+extern void finish_for_expr\t\t\t(tree, tree);\n+extern void finish_for_stmt\t\t\t(tree);\n+extern tree finish_break_stmt\t\t\t(void);\n+extern tree finish_continue_stmt\t\t(void);\n+extern tree begin_switch_stmt\t\t\t(void);\n+extern void finish_switch_cond\t\t\t(tree, tree);\n+extern void finish_switch_stmt\t\t\t(tree);\n+extern tree finish_case_label\t\t\t(tree, tree);\n+extern tree finish_goto_stmt\t\t\t(tree);\n+extern tree begin_try_block\t\t\t(void);\n+extern void finish_try_block\t\t\t(tree);\n extern tree begin_eh_spec_block\t\t\t(void);\n extern void finish_eh_spec_block\t\t(tree, tree);\n-extern void finish_handler_sequence             (tree);\n-extern tree begin_function_try_block            (void);\n-extern void finish_function_try_block           (tree);\n+extern void finish_handler_sequence\t\t(tree);\n+extern tree begin_function_try_block\t\t(void);\n+extern void finish_function_try_block\t\t(tree);\n extern void finish_function_handler_sequence    (tree);\n-extern void finish_cleanup_try_block            (tree);\n-extern tree begin_handler                       (void);\n-extern void finish_handler_parms                (tree, tree);\n-extern void finish_handler                      (tree);\n-extern void finish_cleanup                      (tree, tree);\n+extern void finish_cleanup_try_block\t\t(tree);\n+extern tree begin_handler\t\t\t(void);\n+extern void finish_handler_parms\t\t(tree, tree);\n+extern void finish_handler\t\t\t(tree);\n+extern void finish_cleanup\t\t\t(tree, tree);\n \n enum {\n   BCS_NO_SCOPE = 1,\n   BCS_TRY_BLOCK = 2,\n   BCS_FN_BODY = 4\n };\n-extern tree begin_compound_stmt                 (unsigned int);\n+extern tree begin_compound_stmt\t\t\t(unsigned int);\n \n-extern void finish_compound_stmt                (tree);\n-extern tree finish_asm_stmt                     (int, tree, tree, tree, tree);\n-extern tree finish_label_stmt                   (tree);\n-extern void finish_label_decl                   (tree);\n-extern tree finish_parenthesized_expr           (tree);\n+extern void finish_compound_stmt\t\t(tree);\n+extern tree finish_asm_stmt\t\t\t(int, tree, tree, tree, tree);\n+extern tree finish_label_stmt\t\t\t(tree);\n+extern void finish_label_decl\t\t\t(tree);\n+extern tree finish_parenthesized_expr\t\t(tree);\n extern tree finish_non_static_data_member       (tree, tree, tree);\n-extern tree begin_stmt_expr                     (void);\n-extern tree finish_stmt_expr_expr \t\t(tree, tree);\n-extern tree finish_stmt_expr                    (tree, bool);\n-extern tree perform_koenig_lookup               (tree, tree);\n-extern tree finish_call_expr                    (tree, tree, bool, bool);\n-extern tree finish_increment_expr               (tree, enum tree_code);\n-extern tree finish_this_expr                    (void);\n+extern tree begin_stmt_expr\t\t\t(void);\n+extern tree finish_stmt_expr_expr\t\t(tree, tree);\n+extern tree finish_stmt_expr\t\t\t(tree, bool);\n+extern tree perform_koenig_lookup\t\t(tree, tree);\n+extern tree finish_call_expr\t\t\t(tree, tree, bool, bool);\n+extern tree finish_increment_expr\t\t(tree, enum tree_code);\n+extern tree finish_this_expr\t\t\t(void);\n extern tree finish_pseudo_destructor_expr       (tree, tree, tree);\n-extern tree finish_unary_op_expr                (enum tree_code, tree);\n-extern tree finish_compound_literal             (tree, tree);\n-extern tree finish_fname                        (tree);\n-extern void finish_translation_unit             (void);\n-extern tree finish_template_type_parm           (tree, tree);\n+extern tree finish_unary_op_expr\t\t(enum tree_code, tree);\n+extern tree finish_compound_literal\t\t(tree, tree);\n+extern tree finish_fname\t\t\t(tree);\n+extern void finish_translation_unit\t\t(void);\n+extern tree finish_template_type_parm\t\t(tree, tree);\n extern tree finish_template_template_parm       (tree, tree);\n-extern tree begin_class_definition              (tree);\n-extern void finish_template_decl                (tree);\n-extern tree finish_template_type                (tree, tree, int);\n-extern tree finish_base_specifier               (tree, tree, bool);\n-extern void finish_member_declaration           (tree);\n+extern tree begin_class_definition\t\t(tree);\n+extern void finish_template_decl\t\t(tree);\n+extern tree finish_template_type\t\t(tree, tree, int);\n+extern tree finish_base_specifier\t\t(tree, tree, bool);\n+extern void finish_member_declaration\t\t(tree);\n extern void qualified_name_lookup_error\t\t(tree, tree, tree);\n-extern tree finish_id_expression                (tree, tree, tree,\n+extern tree finish_id_expression\t\t(tree, tree, tree,\n \t\t\t\t\t\t cp_id_kind *, tree *,\n \t\t\t\t\t\t bool, bool, bool *,\n \t\t\t\t\t\t const char **);\n extern tree finish_typeof\t\t\t(tree);\n-extern void finish_decl_cleanup                 (tree, tree);\n-extern void finish_eh_cleanup                   (tree);\n-extern void expand_body                         (tree);\n-extern void finish_mem_initializers             (tree);\n+extern void finish_decl_cleanup\t\t\t(tree, tree);\n+extern void finish_eh_cleanup\t\t\t(tree);\n+extern void expand_body\t\t\t\t(tree);\n+extern void finish_mem_initializers\t\t(tree);\n extern tree check_template_template_default_arg (tree);\n extern void expand_or_defer_fn\t\t\t(tree);\n extern void check_accessibility_of_qualified_id (tree, tree, tree);\n-extern tree finish_qualified_id_expr            (tree, tree, bool, bool);\n+extern tree finish_qualified_id_expr\t\t(tree, tree, bool, bool);\n extern void simplify_aggr_init_expr\t\t(tree *);\n extern void finalize_nrv\t\t\t(tree *, tree, tree);\n-extern void note_decl_for_pch                   (tree);\n+extern void note_decl_for_pch\t\t\t(tree);\n \n /* in tree.c */\n extern void lang_check_failed\t\t\t(const char *, int,\n-\t\t\t\t\t\t\t const char *);\n+\t\t\t\t\t\t const char *);\n extern tree stabilize_expr\t\t\t(tree, tree *);\n extern void stabilize_call\t\t\t(tree, tree *);\n extern bool stabilize_init\t\t\t(tree, tree *);\n extern tree add_stmt_to_compound\t\t(tree, tree);\n extern tree cxx_maybe_build_cleanup\t\t(tree);\n-extern void init_tree\t\t\t        (void);\n+extern void init_tree\t\t\t\t(void);\n extern int pod_type_p\t\t\t\t(tree);\n extern int zero_init_p\t\t\t\t(tree);\n-extern tree canonical_type_variant              (tree);\n+extern tree canonical_type_variant\t\t(tree);\n extern tree copy_binfo\t\t\t\t(tree, tree, tree,\n \t\t\t\t\t\t tree *, int);\n extern int member_p\t\t\t\t(tree);\n-extern cp_lvalue_kind real_lvalue_p             (tree);\n+extern cp_lvalue_kind real_lvalue_p\t\t(tree);\n extern bool builtin_valid_in_constant_expr_p    (tree);\n extern tree build_min\t\t\t\t(enum tree_code, tree, ...);\n extern tree build_min_nt\t\t\t(enum tree_code, ...);\n@@ -4209,8 +4224,8 @@ extern tree hash_tree_cons\t\t\t(tree, tree, tree);\n extern tree hash_tree_chain\t\t\t(tree, tree);\n extern int is_overloaded_fn\t\t\t(tree);\n extern tree get_first_fn\t\t\t(tree);\n-extern tree ovl_cons                            (tree, tree);\n-extern tree build_overload                      (tree, tree);\n+extern tree ovl_cons\t\t\t\t(tree, tree);\n+extern tree build_overload\t\t\t(tree, tree);\n extern const char *cxx_printable_name\t\t(tree, int);\n extern tree build_exception_variant\t\t(tree, tree);\n extern tree bind_template_template_parm\t\t(tree, tree);\n@@ -4230,23 +4245,23 @@ extern tree build_dummy_object\t\t\t(tree);\n extern tree maybe_dummy_object\t\t\t(tree, tree *);\n extern int is_dummy_object\t\t\t(tree);\n extern const struct attribute_spec cxx_attribute_table[];\n-extern tree make_ptrmem_cst                     (tree, tree);\n+extern tree make_ptrmem_cst\t\t\t(tree, tree);\n extern tree cp_build_type_attribute_variant     (tree, tree);\n-extern tree cp_build_qualified_type_real        (tree, int, tsubst_flags_t);\n+extern tree cp_build_qualified_type_real\t(tree, int, tsubst_flags_t);\n #define cp_build_qualified_type(TYPE, QUALS) \\\n   cp_build_qualified_type_real ((TYPE), (QUALS), tf_error | tf_warning)\n extern special_function_kind special_function_p (tree);\n-extern int count_trees                          (tree);\n-extern int char_type_p                          (tree);\n-extern void verify_stmt_tree                    (tree);\n-extern tree find_tree                           (tree, tree);\n-extern linkage_kind decl_linkage                (tree);\n+extern int count_trees\t\t\t\t(tree);\n+extern int char_type_p\t\t\t\t(tree);\n+extern void verify_stmt_tree\t\t\t(tree);\n+extern tree find_tree\t\t\t\t(tree, tree);\n+extern linkage_kind decl_linkage\t\t(tree);\n extern tree cp_walk_subtrees (tree*, int*, walk_tree_fn,\n-\t\t\t\t      void*, struct pointer_set_t*);\n-extern int cp_cannot_inline_tree_fn (tree*);\n-extern tree cp_add_pending_fn_decls (void*,tree);\n-extern int cp_auto_var_in_fn_p (tree,tree);\n-extern tree fold_if_not_in_template             (tree);\n+\t\t\t      void*, struct pointer_set_t*);\n+extern int cp_cannot_inline_tree_fn\t\t(tree*);\n+extern tree cp_add_pending_fn_decls\t\t(void*,tree);\n+extern int cp_auto_var_in_fn_p\t\t\t(tree,tree);\n+extern tree fold_if_not_in_template\t\t(tree);\n \n /* in typeck.c */\n extern int string_conv_p\t\t\t(tree, tree, int);\n@@ -4260,14 +4275,14 @@ extern tree original_type\t\t\t(tree);\n extern bool comp_except_specs\t\t\t(tree, tree, bool);\n extern bool comptypes\t\t\t\t(tree, tree, int);\n extern bool compparms\t\t\t\t(tree, tree);\n-extern int comp_cv_qualification                (tree, tree);\n-extern int comp_cv_qual_signature               (tree, tree);\n-extern tree cxx_sizeof_or_alignof_expr    (tree, enum tree_code);\n-extern tree cxx_sizeof_or_alignof_type    (tree, enum tree_code, bool);\n+extern int comp_cv_qualification\t\t(tree, tree);\n+extern int comp_cv_qual_signature\t\t(tree, tree);\n+extern tree cxx_sizeof_or_alignof_expr\t\t(tree, enum tree_code);\n+extern tree cxx_sizeof_or_alignof_type\t\t(tree, enum tree_code, bool);\n #define cxx_sizeof_nowarn(T) cxx_sizeof_or_alignof_type (T, SIZEOF_EXPR, false)\n extern tree inline_conversion\t\t\t(tree);\n extern tree decay_conversion\t\t\t(tree);\n-extern tree default_conversion                  (tree);\n+extern tree default_conversion\t\t\t(tree);\n extern tree build_class_member_access_expr      (tree, tree, tree, bool);\n extern tree finish_class_member_access_expr     (tree, tree);\n extern tree build_x_indirect_ref\t\t(tree, const char *);\n@@ -4279,7 +4294,7 @@ extern tree build_x_binary_op\t\t\t(enum tree_code, tree, tree,\n extern tree build_x_unary_op\t\t\t(enum tree_code, tree);\n extern tree unary_complex_lvalue\t\t(enum tree_code, tree);\n extern tree build_x_conditional_expr\t\t(tree, tree, tree);\n-extern tree build_x_compound_expr_from_list \t(tree, const char *);\n+extern tree build_x_compound_expr_from_list\t(tree, const char *);\n extern tree build_x_compound_expr\t\t(tree, tree);\n extern tree build_compound_expr\t\t\t(tree, tree);\n extern tree build_static_cast\t\t\t(tree, tree);\n@@ -4288,35 +4303,36 @@ extern tree build_const_cast\t\t\t(tree, tree);\n extern tree build_c_cast\t\t\t(tree, tree);\n extern tree build_x_modify_expr\t\t\t(tree, enum tree_code, tree);\n extern tree build_modify_expr\t\t\t(tree, enum tree_code, tree);\n-extern tree convert_for_initialization\t\t(tree, tree, tree, int, const char *, tree, int);\n+extern tree convert_for_initialization\t\t(tree, tree, tree, int,\n+\t\t\t\t\t\t const char *, tree, int);\n extern int comp_ptr_ttypes\t\t\t(tree, tree);\n extern int ptr_reasonably_similar\t\t(tree, tree);\n extern tree build_ptrmemfunc\t\t\t(tree, tree, int, bool);\n-extern int cp_type_quals                        (tree);\n-extern bool cp_has_mutable_p                     (tree);\n-extern bool at_least_as_qualified_p              (tree, tree);\n-extern void cp_apply_type_quals_to_decl         (int, tree);\n-extern tree build_ptrmemfunc1                   (tree, tree, tree);\n-extern void expand_ptrmemfunc_cst               (tree, tree *, tree *);\n-extern tree pfn_from_ptrmemfunc                 (tree);\n+extern int cp_type_quals\t\t\t(tree);\n+extern bool cp_has_mutable_p\t\t\t(tree);\n+extern bool at_least_as_qualified_p\t\t(tree, tree);\n+extern void cp_apply_type_quals_to_decl\t\t(int, tree);\n+extern tree build_ptrmemfunc1\t\t\t(tree, tree, tree);\n+extern void expand_ptrmemfunc_cst\t\t(tree, tree *, tree *);\n+extern tree pfn_from_ptrmemfunc\t\t\t(tree);\n extern tree type_after_usual_arithmetic_conversions (tree, tree);\n-extern tree composite_pointer_type              (tree, tree, tree, tree,\n-\t\t\t\t\t\t       const char*);\n+extern tree composite_pointer_type\t\t(tree, tree, tree, tree,\n+\t\t\t\t\t\t const char*);\n extern tree merge_types\t\t\t\t(tree, tree);\n-extern tree check_return_expr                   (tree);\n+extern tree check_return_expr\t\t\t(tree);\n #define cp_build_binary_op(code, arg1, arg2) \\\n   build_binary_op(code, arg1, arg2, 1)\n #define cxx_sizeof(T)  cxx_sizeof_or_alignof_type (T, SIZEOF_EXPR, true)\n-extern tree build_ptrmemfunc_access_expr       (tree, tree);\n-extern tree build_address                       (tree);\n-extern tree build_nop                           (tree, tree);\n-extern tree non_reference                       (tree);\n-extern tree lookup_anon_field                   (tree, tree);\n-extern bool invalid_nonstatic_memfn_p           (tree);\n-extern tree convert_member_func_to_ptr          (tree, tree);\n-extern tree convert_ptrmem                      (tree, tree, bool, bool);\n-extern int lvalue_or_else                       (tree, enum lvalue_use);\n-extern int lvalue_p                             (tree);\n+extern tree build_ptrmemfunc_access_expr\t(tree, tree);\n+extern tree build_address\t\t\t(tree);\n+extern tree build_nop\t\t\t\t(tree, tree);\n+extern tree non_reference\t\t\t(tree);\n+extern tree lookup_anon_field\t\t\t(tree, tree);\n+extern bool invalid_nonstatic_memfn_p\t\t(tree);\n+extern tree convert_member_func_to_ptr\t\t(tree, tree);\n+extern tree convert_ptrmem\t\t\t(tree, tree, bool, bool);\n+extern int lvalue_or_else\t\t\t(tree, enum lvalue_use);\n+extern int lvalue_p\t\t\t\t(tree);\n \n /* in typeck2.c */\n extern void require_complete_eh_spec_types\t(tree, tree);\n@@ -4337,38 +4353,38 @@ extern tree build_scoped_ref\t\t\t(tree, tree, tree *);\n extern tree build_x_arrow\t\t\t(tree);\n extern tree build_m_component_ref\t\t(tree, tree);\n extern tree build_functional_cast\t\t(tree, tree);\n-extern tree add_exception_specifier             (tree, tree, int);\n-extern tree merge_exception_specifiers          (tree, tree);\n+extern tree add_exception_specifier\t\t(tree, tree, int);\n+extern tree merge_exception_specifiers\t\t(tree, tree);\n \n /* in mangle.c */\n-extern void init_mangle                         (void);\n-extern void mangle_decl                         (tree);\n-extern const char *mangle_type_string           (tree);\n-extern tree mangle_typeinfo_for_type            (tree);\n-extern tree mangle_typeinfo_string_for_type     (tree);\n-extern tree mangle_vtbl_for_type                (tree);\n-extern tree mangle_vtt_for_type                 (tree);\n-extern tree mangle_ctor_vtbl_for_type           (tree, tree);\n-extern tree mangle_thunk                        (tree, int, tree, tree);\n-extern tree mangle_conv_op_name_for_type        (tree);\n-extern tree mangle_guard_variable               (tree);\n-extern tree mangle_ref_init_variable            (tree);\n+extern void init_mangle\t\t\t\t(void);\n+extern void mangle_decl\t\t\t\t(tree);\n+extern const char *mangle_type_string\t\t(tree);\n+extern tree mangle_typeinfo_for_type\t\t(tree);\n+extern tree mangle_typeinfo_string_for_type\t(tree);\n+extern tree mangle_vtbl_for_type\t\t(tree);\n+extern tree mangle_vtt_for_type\t\t\t(tree);\n+extern tree mangle_ctor_vtbl_for_type\t\t(tree, tree);\n+extern tree mangle_thunk\t\t\t(tree, int, tree, tree);\n+extern tree mangle_conv_op_name_for_type\t(tree);\n+extern tree mangle_guard_variable\t\t(tree);\n+extern tree mangle_ref_init_variable\t\t(tree);\n \n /* in dump.c */\n-extern bool cp_dump_tree                         (void *, tree);\n+extern bool cp_dump_tree\t\t\t(void *, tree);\n \n /* In cp/cp-objcp-common.c.  */\n \n-extern HOST_WIDE_INT cxx_get_alias_set (tree);\n-extern bool cxx_warn_unused_global_decl (tree);\n-extern tree cp_expr_size (tree);\n-extern size_t cp_tree_size (enum tree_code);\n-extern bool cp_var_mod_type_p (tree, tree);\n-extern void cxx_initialize_diagnostics (struct diagnostic_context *);\n-extern int cxx_types_compatible_p (tree, tree);\n+extern HOST_WIDE_INT cxx_get_alias_set\t\t(tree);\n+extern bool cxx_warn_unused_global_decl\t\t(tree);\n+extern tree cp_expr_size\t\t\t(tree);\n+extern size_t cp_tree_size\t\t\t(enum tree_code);\n+extern bool cp_var_mod_type_p\t\t\t(tree, tree);\n+extern void cxx_initialize_diagnostics\t\t(struct diagnostic_context *);\n+extern int cxx_types_compatible_p\t\t(tree, tree);\n \n /* in cp-gimplify.c */\n-extern int cp_gimplify_expr\t\t        (tree *, tree *, tree *);\n+extern int cp_gimplify_expr\t\t\t(tree *, tree *, tree *);\n extern void cp_genericize\t\t\t(tree);\n \n /* -- end of C++ */"}, {"sha": "c1eafe79f7c22d95fa65d22e8fd9985c62fdfad9", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -54,7 +54,7 @@ static void warn_ref_binding (tree, tree, tree);\n    narrowing is always done with a NOP_EXPR:\n      In convert.c, convert_to_integer.\n      In c-typeck.c, build_binary_op_nodefault (boolean ops),\n-        and c_common_truthvalue_conversion.\n+\tand c_common_truthvalue_conversion.\n      In expr.c: expand_expr, for operands of a MULT_EXPR.\n      In fold-const.c: fold.\n      In tree.c: get_narrower and get_unwidened.\n@@ -88,7 +88,7 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n       if (!COMPLETE_TYPE_P (intype))\n \t{\n \t  error (\"can't convert from incomplete type %qT to %qT\",\n-                 intype, type);\n+\t\t intype, type);\n \t  return error_mark_node;\n \t}\n \n@@ -97,7 +97,7 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n \t{\n \t  if (rval == error_mark_node)\n \t    error (\"conversion of %qE from %qT to %qT is ambiguous\",\n-                   expr, intype, type);\n+\t\t   expr, intype, type);\n \t  return rval;\n \t}\n     }\n@@ -166,7 +166,7 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n       if (TYPE_PTRMEMFUNC_P (type))\n \t{\n \t  error (\"cannot convert %qE from type %qT to type %qT\",\n-                 expr, intype, type);\n+\t\t expr, intype, type);\n \t  return error_mark_node;\n \t}\n \n@@ -195,11 +195,11 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n \t{\n \t  if (force)\n \t    warning (0, \"pointer to member cast from %qT to %qT is via\"\n-                     \" virtual base\", intype, type);\n+\t\t     \" virtual base\", intype, type);\n \t  else\n \t    {\n \t      error (\"pointer to member cast from %qT to %qT is\"\n-                     \" via virtual base\", intype, type);\n+\t\t     \" via virtual base\", intype, type);\n \t      return error_mark_node;\n \t    }\n \t  /* This is a reinterpret cast, whose result is unspecified.\n@@ -235,7 +235,7 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n \t    }\n \t}\n       error (\"cannot convert %qE from type %qT to type %qT\",\n-             expr, intype, type);\n+\t     expr, intype, type);\n       return error_mark_node;\n     }\n \n@@ -282,7 +282,7 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n     return instantiate_type (type, expr, tf_error | tf_warning);\n \n   error (\"cannot convert %qE from type %qT to type %qT\",\n-         expr, intype, type);\n+\t expr, intype, type);\n   return error_mark_node;\n }\n \n@@ -322,8 +322,8 @@ convert_to_pointer_force (tree type, tree expr)\n \t  if (binfo)\n \t    {\n \t      expr = build_base_path (code, expr, binfo, 0);\n-              if (expr == error_mark_node)\n-                 return error_mark_node;\n+\t      if (expr == error_mark_node)\n+\t\t return error_mark_node;\n \t      /* Add any qualifier conversions.  */\n \t      if (!same_type_p (TREE_TYPE (TREE_TYPE (expr)),\n \t\t\t\tTREE_TYPE (type)))\n@@ -414,16 +414,16 @@ warn_ref_binding (tree reftype, tree intype, tree decl)\n \n       if (CP_TYPE_VOLATILE_P (ttl) && decl)\n \t  msg = \"initialization of volatile reference type %q#T from\"\n-            \" rvalue of type %qT\";\n+\t    \" rvalue of type %qT\";\n       else if (CP_TYPE_VOLATILE_P (ttl))\n \t  msg = \"conversion to volatile reference type %q#T \"\n-            \" from rvalue of type %qT\";\n+\t    \" from rvalue of type %qT\";\n       else if (decl)\n \t  msg = \"initialization of non-const reference type %q#T from\"\n-            \" rvalue of type %qT\";\n+\t    \" rvalue of type %qT\";\n       else\n \t  msg = \"conversion to non-const reference type %q#T from\"\n-            \" rvalue of type %qT\";\n+\t    \" rvalue of type %qT\";\n \n       pedwarn (msg, reftype, intype);\n     }\n@@ -438,7 +438,7 @@ warn_ref_binding (tree reftype, tree intype, tree decl)\n \n tree\n convert_to_reference (tree reftype, tree expr, int convtype,\n-                      int flags, tree decl)\n+\t\t      int flags, tree decl)\n {\n   tree type = TYPE_MAIN_VARIANT (TREE_TYPE (reftype));\n   tree intype;\n@@ -495,7 +495,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n \t  if (! (convtype & CONV_CONST)\n \t\t   && !at_least_as_qualified_p (ttl, ttr))\n \t    pedwarn (\"conversion from %qT to %qT discards qualifiers\",\n-                     ttr, reftype);\n+\t\t     ttr, reftype);\n \t}\n \n       return build_up_reference (reftype, expr, flags, decl);\n@@ -508,7 +508,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n \t should be done directly (jason).  (int &)ri ---> *(int*)&ri */\n \n       /* B* bp; A& ar = (A&)bp; is valid, but it's probably not what they\n-         meant.  */\n+\t meant.  */\n       if (TREE_CODE (intype) == POINTER_TYPE\n \t  && (comptypes (TREE_TYPE (intype), type,\n \t\t\t COMPARE_BASE | COMPARE_DERIVED)))\n@@ -627,9 +627,9 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t   convert, which will call ocp_convert, etc.  */\n \treturn e;\n       /* For complex data types, we need to perform componentwise\n-         conversion.  */\n+\t conversion.  */\n       else if (TREE_CODE (type) == COMPLEX_TYPE)\n-        return fold_if_not_in_template (convert_to_complex (type, e));\n+\treturn fold_if_not_in_template (convert_to_complex (type, e));\n       else if (TREE_CODE (e) == TARGET_EXPR)\n \t{\n \t  /* Don't build a NOP_EXPR of class type.  Instead, change the\n@@ -659,10 +659,10 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n     {\n       tree intype = TREE_TYPE (e);\n       /* enum = enum, enum = int, enum = float, (enum)pointer are all\n-         errors.  */\n+\t errors.  */\n       if (TREE_CODE (type) == ENUMERAL_TYPE\n \t  && (((INTEGRAL_OR_ENUMERATION_TYPE_P (intype)\n-\t        || TREE_CODE (intype) == REAL_TYPE)\n+\t\t|| TREE_CODE (intype) == REAL_TYPE)\n \t       && ! (convtype & CONV_STATIC))\n \t      || TREE_CODE (intype) == POINTER_TYPE))\n \t{\n@@ -696,11 +696,11 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t{\n \t  tree ret_val;\n \t  ret_val = build_type_conversion (type, e);\n-          if (ret_val)\n-            return ret_val;\n-          if (flags & LOOKUP_COMPLAIN)\n-            error (\"%q#T used where a %qT was expected\", in_vtype, type);\n-          return error_mark_node;\n+\t  if (ret_val)\n+\t    return ret_val;\n+\t  if (flags & LOOKUP_COMPLAIN)\n+\t    error (\"%q#T used where a %qT was expected\", in_vtype, type);\n+\t  return error_mark_node;\n \t}\n       return fold_if_not_in_template (convert_to_vector (type, e));\n     }\n@@ -762,7 +762,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \n   if (flags & LOOKUP_COMPLAIN)\n     error (\"conversion from %qT to non-scalar type %qT requested\",\n-           TREE_TYPE (expr), type);\n+\t   TREE_TYPE (expr), type);\n   return error_mark_node;\n }\n \n@@ -804,37 +804,37 @@ convert_to_void (tree expr, const char *implicit)\n     {\n     case COND_EXPR:\n       {\n-        /* The two parts of a cond expr might be separate lvalues.  */\n-        tree op1 = TREE_OPERAND (expr,1);\n-        tree op2 = TREE_OPERAND (expr,2);\n-        tree new_op1 = convert_to_void\n+\t/* The two parts of a cond expr might be separate lvalues.  */\n+\ttree op1 = TREE_OPERAND (expr,1);\n+\ttree op2 = TREE_OPERAND (expr,2);\n+\ttree new_op1 = convert_to_void\n \t  (op1, (implicit && !TREE_SIDE_EFFECTS (op2)\n \t\t ? \"second operand of conditional\" : NULL));\n-        tree new_op2 = convert_to_void\n+\ttree new_op2 = convert_to_void\n \t  (op2, (implicit && !TREE_SIDE_EFFECTS (op1)\n \t\t ? \"third operand of conditional\" : NULL));\n \n \texpr = build3 (COND_EXPR, TREE_TYPE (new_op1),\n \t\t       TREE_OPERAND (expr, 0), new_op1, new_op2);\n-        break;\n+\tbreak;\n       }\n \n     case COMPOUND_EXPR:\n       {\n-        /* The second part of a compound expr contains the value.  */\n-        tree op1 = TREE_OPERAND (expr,1);\n-        tree new_op1 = convert_to_void\n+\t/* The second part of a compound expr contains the value.  */\n+\ttree op1 = TREE_OPERAND (expr,1);\n+\ttree new_op1 = convert_to_void\n \t  (op1, (implicit && !TREE_NO_WARNING (expr)\n \t\t ? \"right-hand operand of comma\" : NULL));\n \n-        if (new_op1 != op1)\n+\tif (new_op1 != op1)\n \t  {\n \t    tree t = build2 (COMPOUND_EXPR, TREE_TYPE (new_op1),\n \t\t\t     TREE_OPERAND (expr, 0), new_op1);\n \t    expr = t;\n \t  }\n \n-        break;\n+\tbreak;\n       }\n \n     case NON_LVALUE_EXPR:\n@@ -847,35 +847,35 @@ convert_to_void (tree expr, const char *implicit)\n \n     case INDIRECT_REF:\n       {\n-        tree type = TREE_TYPE (expr);\n-        int is_reference = TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0)))\n-                           == REFERENCE_TYPE;\n-        int is_volatile = TYPE_VOLATILE (type);\n-        int is_complete = COMPLETE_TYPE_P (complete_type (type));\n-\n-        if (is_volatile && !is_complete)\n-          warning (0, \"object of incomplete type %qT will not be accessed in %s\",\n-                   type, implicit ? implicit : \"void context\");\n-        else if (is_reference && is_volatile)\n-          warning (0, \"object of type %qT will not be accessed in %s\",\n-                   TREE_TYPE (TREE_OPERAND (expr, 0)),\n-                   implicit ? implicit : \"void context\");\n-        if (is_reference || !is_volatile || !is_complete)\n-          expr = TREE_OPERAND (expr, 0);\n-\n-        break;\n+\ttree type = TREE_TYPE (expr);\n+\tint is_reference = TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0)))\n+\t\t\t   == REFERENCE_TYPE;\n+\tint is_volatile = TYPE_VOLATILE (type);\n+\tint is_complete = COMPLETE_TYPE_P (complete_type (type));\n+\n+\tif (is_volatile && !is_complete)\n+\t  warning (0, \"object of incomplete type %qT will not be accessed in %s\",\n+\t\t   type, implicit ? implicit : \"void context\");\n+\telse if (is_reference && is_volatile)\n+\t  warning (0, \"object of type %qT will not be accessed in %s\",\n+\t\t   TREE_TYPE (TREE_OPERAND (expr, 0)),\n+\t\t   implicit ? implicit : \"void context\");\n+\tif (is_reference || !is_volatile || !is_complete)\n+\t  expr = TREE_OPERAND (expr, 0);\n+\n+\tbreak;\n       }\n \n     case VAR_DECL:\n       {\n-        /* External variables might be incomplete.  */\n-        tree type = TREE_TYPE (expr);\n-        int is_complete = COMPLETE_TYPE_P (complete_type (type));\n-\n-        if (TYPE_VOLATILE (type) && !is_complete)\n-          warning (0, \"object %qE of incomplete type %qT will not be accessed in %s\",\n-                   expr, type, implicit ? implicit : \"void context\");\n-        break;\n+\t/* External variables might be incomplete.  */\n+\ttree type = TREE_TYPE (expr);\n+\tint is_complete = COMPLETE_TYPE_P (complete_type (type));\n+\n+\tif (TYPE_VOLATILE (type) && !is_complete)\n+\t  warning (0, \"object %qE of incomplete type %qT will not be accessed in %s\",\n+\t\t   expr, type, implicit ? implicit : \"void context\");\n+\tbreak;\n       }\n \n     default:;\n@@ -1074,7 +1074,7 @@ build_expr_type_conversion (int desires, tree expr, bool complain)\n       case FUNCTION_TYPE:\n       case ARRAY_TYPE:\n \treturn (desires & WANT_POINTER) ? decay_conversion (expr)\n-     \t                                : NULL_TREE;\n+\t\t\t\t\t: NULL_TREE;\n       default:\n \treturn NULL_TREE;\n       }\n@@ -1120,9 +1120,9 @@ build_expr_type_conversion (int desires, tree expr, bool complain)\n \t      if (complain)\n \t\t{\n \t\t  error (\"ambiguous default type conversion from %qT\",\n-                         basetype);\n+\t\t\t basetype);\n \t\t  error (\"  candidate conversions include %qD and %qD\",\n-                         winner, cand);\n+\t\t\t winner, cand);\n \t\t}\n \t      return error_mark_node;\n \t    }"}, {"sha": "61adb81dd1bfbaabf9ccb32b5175ad6317de0a2c", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 210, "deletions": 210, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -162,20 +162,20 @@ pp_cxx_unqualified_id (cxx_pretty_printer *pp, tree t)\n \n     case IDENTIFIER_NODE:\n       if (t == NULL)\n-        pp_cxx_identifier (pp, \"<unnamed>\");\n+\tpp_cxx_identifier (pp, \"<unnamed>\");\n       else if (IDENTIFIER_TYPENAME_P (t))\n-        pp_cxx_conversion_function_id (pp, t);\n+\tpp_cxx_conversion_function_id (pp, t);\n       else\n-        {\n-          if (is_destructor_name (t))\n-            {\n-              pp_complement (pp);\n-              /* FIXME: Why is this necessary? */\n-              if (TREE_TYPE (t))\n-                t = constructor_name (TREE_TYPE (t));\n-            }\n-          pp_cxx_tree_identifier (pp, t);\n-        }\n+\t{\n+\t  if (is_destructor_name (t))\n+\t    {\n+\t      pp_complement (pp);\n+\t      /* FIXME: Why is this necessary? */\n+\t      if (TREE_TYPE (t))\n+\t\tt = constructor_name (TREE_TYPE (t));\n+\t    }\n+\t  pp_cxx_tree_identifier (pp, t);\n+\t}\n       break;\n \n     case TEMPLATE_ID_EXPR:\n@@ -195,9 +195,9 @@ pp_cxx_unqualified_id (cxx_pretty_printer *pp, tree t)\n     case TEMPLATE_TYPE_PARM:\n     case TEMPLATE_TEMPLATE_PARM:\n       if (TYPE_IDENTIFIER (t))\n-        pp_cxx_unqualified_id (pp, TYPE_IDENTIFIER (t));\n+\tpp_cxx_unqualified_id (pp, TYPE_IDENTIFIER (t));\n       else\n-        pp_cxx_canonical_template_parameter (pp, t);\n+\tpp_cxx_canonical_template_parameter (pp, t);\n       break;\n \n     case TEMPLATE_PARM_INDEX:\n@@ -255,20 +255,20 @@ pp_cxx_qualified_id (cxx_pretty_printer *pp, tree t)\n       break;\n \n       /* In Standard C++, functions cannot possibly be used as\n-         nested-name-specifiers.  However, there are situations where\n-         is \"makes sense\" to output the surrounding function name for the\n-         purpose of emphasizing on the scope kind.  Just printing the\n-         function name might not be sufficient as it may be overloaded; so,\n-         we decorate the function with its signature too.\n-         FIXME:  This is probably the wrong pretty-printing for conversion\n-         functions and some function templates.  */\n+\t nested-name-specifiers.  However, there are situations where\n+\t is \"makes sense\" to output the surrounding function name for the\n+\t purpose of emphasizing on the scope kind.  Just printing the\n+\t function name might not be sufficient as it may be overloaded; so,\n+\t we decorate the function with its signature too.\n+\t FIXME:  This is probably the wrong pretty-printing for conversion\n+\t functions and some function templates.  */\n     case OVERLOAD:\n       t = OVL_CURRENT (t);\n     case FUNCTION_DECL:\n       if (DECL_FUNCTION_MEMBER_P (t))\n-        pp_cxx_nested_name_specifier (pp, DECL_CONTEXT (t));\n+\tpp_cxx_nested_name_specifier (pp, DECL_CONTEXT (t));\n       pp_cxx_unqualified_id\n-        (pp, DECL_CONSTRUCTOR_P (t) ? DECL_CONTEXT (t) : t);\n+\t(pp, DECL_CONSTRUCTOR_P (t) ? DECL_CONTEXT (t) : t);\n       pp_cxx_parameter_declaration_clause (pp, TREE_TYPE (t));\n       break;\n \n@@ -280,13 +280,13 @@ pp_cxx_qualified_id (cxx_pretty_printer *pp, tree t)\n \n     default:\n       {\n-        tree scope = TYPE_P (t) ? TYPE_CONTEXT (t) : DECL_CONTEXT (t);\n-        if (scope != pp->enclosing_scope)\n-          {\n-            pp_cxx_nested_name_specifier (pp, scope);\n-            pp_cxx_template_keyword_if_needed (pp, scope, t);\n-          }\n-        pp_cxx_unqualified_id (pp, t);\n+\ttree scope = TYPE_P (t) ? TYPE_CONTEXT (t) : DECL_CONTEXT (t);\n+\tif (scope != pp->enclosing_scope)\n+\t  {\n+\t    pp_cxx_nested_name_specifier (pp, scope);\n+\t    pp_cxx_template_keyword_if_needed (pp, scope, t);\n+\t  }\n+\tpp_cxx_unqualified_id (pp, t);\n       }\n       break;\n     }\n@@ -365,7 +365,7 @@ pp_cxx_primary_expression (cxx_pretty_printer *pp, tree t)\n      simple-type-specifier ( expression-list(opt) )\n      typename ::(opt) nested-name-specifier identifier ( expression-list(opt) )\n      typename ::(opt) nested-name-specifier template(opt)\n-                                       template-id ( expression-list(opt) )\n+\t\t\t\t       template-id ( expression-list(opt) )\n      postfix-expression . template(opt) ::(opt) id-expression\n      postfix-expression -> template(opt) ::(opt) id-expression\n      postfix-expression . pseudo-destructor-name\n@@ -389,54 +389,54 @@ pp_cxx_postfix_expression (cxx_pretty_printer *pp, tree t)\n     case AGGR_INIT_EXPR:\n     case CALL_EXPR:\n       {\n-        tree fun = TREE_OPERAND (t, 0);\n-        tree args = TREE_OPERAND (t, 1);\n-        tree saved_scope = pp->enclosing_scope;\n-\n-        if (TREE_CODE (fun) == ADDR_EXPR)\n-          fun = TREE_OPERAND (fun, 0);\n-\n-        /* In templates, where there is no way to tell whether a given\n-           call uses an actual member function.  So the parser builds\n-           FUN as a COMPONENT_REF or a plain IDENTIFIER_NODE until\n-           instantiation time.  */\n-        if (TREE_CODE (fun) != FUNCTION_DECL)\n-          ;\n-        else if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fun))\n-          {\n-            tree object = code == AGGR_INIT_EXPR && AGGR_INIT_VIA_CTOR_P (t)\n-              ? TREE_OPERAND (t, 2)\n-              : TREE_VALUE (args);\n-\n-            while (TREE_CODE (object) == NOP_EXPR)\n-              object = TREE_OPERAND (object, 0);\n-\n-            if (TREE_CODE (object) == ADDR_EXPR)\n-              object = TREE_OPERAND (object, 0);\n-\n-            if (TREE_CODE (TREE_TYPE (object)) != POINTER_TYPE)\n-              {\n-                pp_cxx_postfix_expression (pp, object);\n-                pp_cxx_dot (pp);\n-              }\n-            else\n-              {\n-                pp_cxx_postfix_expression (pp, object);\n-                pp_cxx_arrow (pp);\n-              }\n-            args = TREE_CHAIN (args);\n-            pp->enclosing_scope = strip_pointer_operator (TREE_TYPE (object));\n-          }\n-\n-        pp_cxx_postfix_expression (pp, fun);\n-        pp->enclosing_scope = saved_scope;\n-        pp_cxx_call_argument_list (pp, args);\n+\ttree fun = TREE_OPERAND (t, 0);\n+\ttree args = TREE_OPERAND (t, 1);\n+\ttree saved_scope = pp->enclosing_scope;\n+\n+\tif (TREE_CODE (fun) == ADDR_EXPR)\n+\t  fun = TREE_OPERAND (fun, 0);\n+\n+\t/* In templates, where there is no way to tell whether a given\n+\t   call uses an actual member function.  So the parser builds\n+\t   FUN as a COMPONENT_REF or a plain IDENTIFIER_NODE until\n+\t   instantiation time.  */\n+\tif (TREE_CODE (fun) != FUNCTION_DECL)\n+\t  ;\n+\telse if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fun))\n+\t  {\n+\t    tree object = code == AGGR_INIT_EXPR && AGGR_INIT_VIA_CTOR_P (t)\n+\t      ? TREE_OPERAND (t, 2)\n+\t      : TREE_VALUE (args);\n+\n+\t    while (TREE_CODE (object) == NOP_EXPR)\n+\t      object = TREE_OPERAND (object, 0);\n+\n+\t    if (TREE_CODE (object) == ADDR_EXPR)\n+\t      object = TREE_OPERAND (object, 0);\n+\n+\t    if (TREE_CODE (TREE_TYPE (object)) != POINTER_TYPE)\n+\t      {\n+\t\tpp_cxx_postfix_expression (pp, object);\n+\t\tpp_cxx_dot (pp);\n+\t      }\n+\t    else\n+\t      {\n+\t\tpp_cxx_postfix_expression (pp, object);\n+\t\tpp_cxx_arrow (pp);\n+\t      }\n+\t    args = TREE_CHAIN (args);\n+\t    pp->enclosing_scope = strip_pointer_operator (TREE_TYPE (object));\n+\t  }\n+\n+\tpp_cxx_postfix_expression (pp, fun);\n+\tpp->enclosing_scope = saved_scope;\n+\tpp_cxx_call_argument_list (pp, args);\n       }\n       if (code == AGGR_INIT_EXPR && AGGR_INIT_VIA_CTOR_P (t))\n-        {\n-          pp_cxx_separate_with (pp, ',');\n-          pp_cxx_postfix_expression (pp, TREE_OPERAND (t, 2));\n-        }\n+\t{\n+\t  pp_cxx_separate_with (pp, ',');\n+\t  pp_cxx_postfix_expression (pp, TREE_OPERAND (t, 2));\n+\t}\n       break;\n \n     case BASELINK:\n@@ -456,13 +456,13 @@ pp_cxx_postfix_expression (cxx_pretty_printer *pp, tree t)\n     case REINTERPRET_CAST_EXPR:\n     case CONST_CAST_EXPR:\n       if (code == DYNAMIC_CAST_EXPR)\n-        pp_cxx_identifier (pp, \"dynamic_cast\");\n+\tpp_cxx_identifier (pp, \"dynamic_cast\");\n       else if (code == STATIC_CAST_EXPR)\n-        pp_cxx_identifier (pp, \"static_cast\");\n+\tpp_cxx_identifier (pp, \"static_cast\");\n       else if (code == REINTERPRET_CAST_EXPR)\n-        pp_cxx_identifier (pp, \"reinterpret_cast\");\n+\tpp_cxx_identifier (pp, \"reinterpret_cast\");\n       else\n-        pp_cxx_identifier (pp, \"const_cast\");\n+\tpp_cxx_identifier (pp, \"const_cast\");\n       pp_cxx_begin_template_argument_list (pp);\n       pp_cxx_type_id (pp, TREE_TYPE (t));\n       pp_cxx_end_template_argument_list (pp);\n@@ -482,9 +482,9 @@ pp_cxx_postfix_expression (cxx_pretty_printer *pp, tree t)\n       pp_cxx_identifier (pp, \"typeid\");\n       pp_left_paren (pp);\n       if (TYPE_P (t))\n-        pp_cxx_type_id (pp, t);\n+\tpp_cxx_type_id (pp, t);\n       else\n-        pp_cxx_expression (pp, t);\n+\tpp_cxx_expression (pp, t);\n       pp_right_paren (pp);\n       break;\n \n@@ -538,27 +538,27 @@ pp_cxx_new_expression (cxx_pretty_printer *pp, tree t)\n     case NEW_EXPR:\n     case VEC_NEW_EXPR:\n       if (NEW_EXPR_USE_GLOBAL (t))\n-        pp_cxx_colon_colon (pp);\n+\tpp_cxx_colon_colon (pp);\n       pp_cxx_identifier (pp, \"new\");\n       if (TREE_OPERAND (t, 0))\n-        {\n-          pp_cxx_call_argument_list (pp, TREE_OPERAND (t, 0));\n-          pp_space (pp);\n-        }\n+\t{\n+\t  pp_cxx_call_argument_list (pp, TREE_OPERAND (t, 0));\n+\t  pp_space (pp);\n+\t}\n       /* FIXME: array-types are built with one more element.  */\n       pp_cxx_type_id (pp, TREE_OPERAND (t, 1));\n       if (TREE_OPERAND (t, 2))\n-        {\n-          pp_left_paren (pp);\n-          t = TREE_OPERAND (t, 2);\n-          if (TREE_CODE (t) == TREE_LIST)\n-            pp_c_expression_list (pp_c_base (pp), t);\n-          else if (t == void_zero_node)\n-            ;                   /* OK, empty initializer list.  */\n-          else\n-            pp_cxx_expression (pp, t);\n-          pp_right_paren (pp);\n-        }\n+\t{\n+\t  pp_left_paren (pp);\n+\t  t = TREE_OPERAND (t, 2);\n+\t  if (TREE_CODE (t) == TREE_LIST)\n+\t    pp_c_expression_list (pp_c_base (pp), t);\n+\t  else if (t == void_zero_node)\n+\t    ;\t\t\t/* OK, empty initializer list.  */\n+\t  else\n+\t    pp_cxx_expression (pp, t);\n+\t  pp_right_paren (pp);\n+\t}\n       break;\n \n     default:\n@@ -579,13 +579,13 @@ pp_cxx_delete_expression (cxx_pretty_printer *pp, tree t)\n     case DELETE_EXPR:\n     case VEC_DELETE_EXPR:\n       if (DELETE_EXPR_USE_GLOBAL (t))\n-        pp_cxx_colon_colon (pp);\n+\tpp_cxx_colon_colon (pp);\n       pp_cxx_identifier (pp, \"delete\");\n       if (code == VEC_DELETE_EXPR)\n-        {\n-          pp_left_bracket (pp);\n-          pp_right_bracket (pp);\n-        }\n+\t{\n+\t  pp_left_bracket (pp);\n+\t  pp_right_bracket (pp);\n+\t}\n       pp_c_cast_expression (pp_c_base (pp), TREE_OPERAND (t, 0));\n       break;\n \n@@ -685,10 +685,10 @@ pp_cxx_pm_expression (cxx_pretty_printer *pp, tree t)\n       /* Handle unfortunate OFFESET_REF overloading here.  */\n     case OFFSET_REF:\n       if (TYPE_P (TREE_OPERAND (t, 0)))\n-        {\n-          pp_cxx_qualified_id (pp, t);\n-          break;\n-        }\n+\t{\n+\t  pp_cxx_qualified_id (pp, t);\n+\t  break;\n+\t}\n       /* Else fall through.  */\n     case MEMBER_REF:\n     case DOTSTAR_EXPR:\n@@ -825,7 +825,7 @@ pp_cxx_assignment_expression (cxx_pretty_printer *pp, tree e)\n     case THROW_EXPR:\n       pp_cxx_identifier (pp, \"throw\");\n       if (TREE_OPERAND (e, 0))\n-        pp_cxx_assignment_expression (pp, TREE_OPERAND (e, 0));\n+\tpp_cxx_assignment_expression (pp, TREE_OPERAND (e, 0));\n       break;\n \n     case MODOP_EXPR:\n@@ -963,11 +963,11 @@ pp_cxx_function_specifier (cxx_pretty_printer *pp, tree t)\n     {\n     case FUNCTION_DECL:\n       if (DECL_VIRTUAL_P (t))\n-        pp_cxx_identifier (pp, \"virtual\");\n+\tpp_cxx_identifier (pp, \"virtual\");\n       else if (DECL_CONSTRUCTOR_P (t) && DECL_NONCONVERTING_P (t))\n-        pp_cxx_identifier (pp, \"explicit\");\n+\tpp_cxx_identifier (pp, \"explicit\");\n       else\n-        pp_c_function_specifier (pp_c_base (pp), t);\n+\tpp_c_function_specifier (pp_c_base (pp), t);\n \n     default:\n       break;\n@@ -1004,23 +1004,23 @@ pp_cxx_decl_specifier_seq (cxx_pretty_printer *pp, tree t)\n \n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (t))\n-        {\n-          tree pfm = TYPE_PTRMEMFUNC_FN_TYPE (t);\n-          pp_cxx_decl_specifier_seq (pp, TREE_TYPE (TREE_TYPE (pfm)));\n-          pp_cxx_whitespace (pp);\n-          pp_cxx_ptr_operator (pp, t);\n-        }\n+\t{\n+\t  tree pfm = TYPE_PTRMEMFUNC_FN_TYPE (t);\n+\t  pp_cxx_decl_specifier_seq (pp, TREE_TYPE (TREE_TYPE (pfm)));\n+\t  pp_cxx_whitespace (pp);\n+\t  pp_cxx_ptr_operator (pp, t);\n+\t}\n       break;\n \n     case FUNCTION_DECL:\n       /* Constructors don't have return types.  And conversion functions\n-         do not have a type-specifier in their return types.  */\n+\t do not have a type-specifier in their return types.  */\n       if (DECL_CONSTRUCTOR_P (t) || DECL_CONV_FN_P (t))\n-        pp_cxx_function_specifier (pp, t);\n+\tpp_cxx_function_specifier (pp, t);\n       else if (DECL_NONSTATIC_MEMBER_FUNCTION_P (t))\n-        pp_cxx_decl_specifier_seq (pp, TREE_TYPE (TREE_TYPE (t)));\n+\tpp_cxx_decl_specifier_seq (pp, TREE_TYPE (TREE_TYPE (t)));\n       else\n-        default:\n+\tdefault:\n       pp_c_declaration_specifiers (pp_c_base (pp), t);\n       break;\n     }\n@@ -1102,7 +1102,7 @@ pp_cxx_type_specifier_seq (cxx_pretty_printer *pp, tree t)\n \n     default:\n       if (!(TREE_CODE (t) == FUNCTION_DECL && DECL_CONSTRUCTOR_P (t)))\n-        pp_c_specifier_qualifier_list (pp_c_base (pp), t);\n+\tpp_c_specifier_qualifier_list (pp_c_base (pp), t);\n     }\n }\n \n@@ -1121,35 +1121,35 @@ pp_cxx_ptr_operator (cxx_pretty_printer *pp, tree t)\n     case REFERENCE_TYPE:\n     case POINTER_TYPE:\n       if (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE\n-          || TYPE_PTR_TO_MEMBER_P (TREE_TYPE (t)))\n-        pp_cxx_ptr_operator (pp, TREE_TYPE (t));\n+\t  || TYPE_PTR_TO_MEMBER_P (TREE_TYPE (t)))\n+\tpp_cxx_ptr_operator (pp, TREE_TYPE (t));\n       if (TREE_CODE (t) == POINTER_TYPE)\n-        {\n-          pp_star (pp);\n-          pp_cxx_cv_qualifier_seq (pp, t);\n-        }\n+\t{\n+\t  pp_star (pp);\n+\t  pp_cxx_cv_qualifier_seq (pp, t);\n+\t}\n       else\n-        pp_ampersand (pp);\n+\tpp_ampersand (pp);\n       break;\n \n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (t))\n-        {\n-          pp_cxx_left_paren (pp);\n-          pp_cxx_nested_name_specifier (pp, TYPE_PTRMEMFUNC_OBJECT_TYPE (t));\n-          pp_star (pp);\n-          break;\n-        }\n+\t{\n+\t  pp_cxx_left_paren (pp);\n+\t  pp_cxx_nested_name_specifier (pp, TYPE_PTRMEMFUNC_OBJECT_TYPE (t));\n+\t  pp_star (pp);\n+\t  break;\n+\t}\n     case OFFSET_TYPE:\n       if (TYPE_PTR_TO_MEMBER_P (t))\n-        {\n-          if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n-            pp_cxx_left_paren (pp);\n-          pp_cxx_nested_name_specifier (pp, TYPE_PTRMEM_CLASS_TYPE (t));\n-          pp_star (pp);\n-          pp_cxx_cv_qualifier_seq (pp, t);\n-          break;\n-        }\n+\t{\n+\t  if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n+\t    pp_cxx_left_paren (pp);\n+\t  pp_cxx_nested_name_specifier (pp, TYPE_PTRMEM_CLASS_TYPE (t));\n+\t  pp_star (pp);\n+\t  pp_cxx_cv_qualifier_seq (pp, t);\n+\t  break;\n+\t}\n       /* else fall through.  */\n \n     default:\n@@ -1207,16 +1207,16 @@ pp_cxx_parameter_declaration_clause (cxx_pretty_printer *pp, tree t)\n   for (; args; args = TREE_CHAIN (args), types = TREE_CHAIN (types))\n     {\n       if (!first)\n-        pp_cxx_separate_with (pp, ',');\n+\tpp_cxx_separate_with (pp, ',');\n       first = false;\n       pp_cxx_parameter_declaration (pp, abstract ? TREE_VALUE (types) : args);\n       if (!abstract && pp_c_base (pp)->flags & pp_cxx_flag_default_argument)\n-        {\n-          pp_cxx_whitespace (pp);\n-          pp_equal (pp);\n-          pp_cxx_whitespace (pp);\n-          pp_cxx_assignment_expression (pp, TREE_PURPOSE (types));\n-        }\n+\t{\n+\t  pp_cxx_whitespace (pp);\n+\t  pp_equal (pp);\n+\t  pp_cxx_whitespace (pp);\n+\t  pp_cxx_assignment_expression (pp, TREE_PURPOSE (types));\n+\t}\n     }\n   pp_cxx_right_paren (pp);\n }\n@@ -1241,15 +1241,15 @@ pp_cxx_exception_specification (cxx_pretty_printer *pp, tree t)\n     {\n       pp_cxx_type_id (pp, TREE_VALUE (ex_spec));\n       if (TREE_CHAIN (ex_spec))\n-        pp_cxx_separate_with (pp, ',');\n+\tpp_cxx_separate_with (pp, ',');\n     }\n   pp_cxx_right_paren (pp);\n }\n \n /* direct-declarator:\n       declarator-id\n       direct-declarator ( parameter-declaration-clause ) cv-qualifier-seq(opt)\n-                                            exception-specification(opt)\n+\t\t\t\t\t    exception-specification(opt)\n       direct-declaration [ constant-expression(opt) ]\n       ( declarator )  */\n \n@@ -1263,10 +1263,10 @@ pp_cxx_direct_declarator (cxx_pretty_printer *pp, tree t)\n     case CONST_DECL:\n     case FIELD_DECL:\n       if (DECL_NAME (t))\n-        {\n-          pp_cxx_space_for_pointer_operator (pp, TREE_TYPE (t));\n-          pp_cxx_id_expression (pp, DECL_NAME (t));\n-        }\n+\t{\n+\t  pp_cxx_space_for_pointer_operator (pp, TREE_TYPE (t));\n+\t  pp_cxx_id_expression (pp, DECL_NAME (t));\n+\t}\n       pp_cxx_abstract_declarator (pp, TREE_TYPE (t));\n       break;\n \n@@ -1276,10 +1276,10 @@ pp_cxx_direct_declarator (cxx_pretty_printer *pp, tree t)\n       pp_cxx_parameter_declaration_clause (pp, t);\n \n       if (DECL_NONSTATIC_MEMBER_FUNCTION_P (t))\n-        {\n-          pp_base (pp)->padding = pp_before;\n-          pp_cxx_cv_qualifier_seq (pp, pp_cxx_implicit_parameter_type (t));\n-        }\n+\t{\n+\t  pp_base (pp)->padding = pp_before;\n+\t  pp_cxx_cv_qualifier_seq (pp, pp_cxx_implicit_parameter_type (t));\n+\t}\n \n       pp_cxx_exception_specification (pp, TREE_TYPE (t));\n       break;\n@@ -1333,7 +1333,7 @@ pp_cxx_ctor_initializer (cxx_pretty_printer *pp, tree t)\n       pp_cxx_primary_expression (pp, TREE_PURPOSE (t));\n       pp_cxx_call_argument_list (pp, TREE_VALUE (t));\n       if (TREE_CHAIN (t))\n-        pp_cxx_separate_with (pp, ',');\n+\tpp_cxx_separate_with (pp, ',');\n     }\n }\n \n@@ -1372,16 +1372,16 @@ pp_cxx_abstract_declarator (cxx_pretty_printer *pp, tree t)\n   else if (POINTER_TYPE_P (t))\n     {\n       if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE\n-          || TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n-        pp_cxx_right_paren (pp);\n+\t  || TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n+\tpp_cxx_right_paren (pp);\n       t = TREE_TYPE (t);\n     }\n   pp_cxx_direct_abstract_declarator (pp, t);\n }\n \n /* direct-abstract-declarator:\n       direct-abstract-declarator(opt) ( parameter-declaration-clause )\n-                           cv-qualifier-seq(opt) exception-specification(opt)\n+\t\t\t   cv-qualifier-seq(opt) exception-specification(opt)\n       direct-abstract-declarator(opt) [ constant-expression(opt) ]\n       ( abstract-declarator )  */\n \n@@ -1396,19 +1396,19 @@ pp_cxx_direct_abstract_declarator (cxx_pretty_printer *pp, tree t)\n \n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (t))\n-        pp_cxx_direct_abstract_declarator (pp, TYPE_PTRMEMFUNC_FN_TYPE (t));\n+\tpp_cxx_direct_abstract_declarator (pp, TYPE_PTRMEMFUNC_FN_TYPE (t));\n       break;\n \n     case METHOD_TYPE:\n     case FUNCTION_TYPE:\n       pp_cxx_parameter_declaration_clause (pp, t);\n       pp_cxx_direct_abstract_declarator (pp, TREE_TYPE (t));\n       if (TREE_CODE (t) == METHOD_TYPE)\n-        {\n-          pp_base (pp)->padding = pp_before;\n-          pp_cxx_cv_qualifier_seq\n-            (pp, TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t))));\n-        }\n+\t{\n+\t  pp_base (pp)->padding = pp_before;\n+\t  pp_cxx_cv_qualifier_seq\n+\t    (pp, TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t))));\n+\t}\n       pp_cxx_exception_specification (pp, t);\n       break;\n \n@@ -1479,12 +1479,12 @@ pp_cxx_template_argument_list (cxx_pretty_printer *pp, tree t)\n     {\n       tree arg = TREE_VEC_ELT (t, i);\n       if (i != 0)\n-        pp_cxx_separate_with (pp, ',');\n+\tpp_cxx_separate_with (pp, ',');\n       if (TYPE_P (arg) || (TREE_CODE (arg) == TEMPLATE_DECL\n \t\t\t   && TYPE_P (DECL_TEMPLATE_RESULT (arg))))\n-        pp_cxx_type_id (pp, arg);\n+\tpp_cxx_type_id (pp, arg);\n       else\n-        pp_cxx_expression (pp, arg);\n+\tpp_cxx_expression (pp, arg);\n     }\n }\n \n@@ -1527,30 +1527,30 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n       break;\n \n       /* try-block:\n-            try compound-statement handler-seq  */\n+\t    try compound-statement handler-seq  */\n     case TRY_BLOCK:\n       pp_maybe_newline_and_indent (pp, 0);\n       pp_cxx_identifier (pp, \"try\");\n       pp_newline_and_indent (pp, 3);\n       pp_cxx_statement (pp, TRY_STMTS (t));\n       pp_newline_and_indent (pp, -3);\n       if (CLEANUP_P (t))\n-        ;\n+\t;\n       else\n-        pp_cxx_statement (pp, TRY_HANDLERS (t));\n+\tpp_cxx_statement (pp, TRY_HANDLERS (t));\n       break;\n \n       /*\n-         handler-seq:\n-            handler handler-seq(opt)\n+\t handler-seq:\n+\t    handler handler-seq(opt)\n \n-         handler:\n-         catch ( exception-declaration ) compound-statement\n+\t handler:\n+\t catch ( exception-declaration ) compound-statement\n \n-         exception-declaration:\n-            type-specifier-seq declarator\n-            type-specifier-seq abstract-declarator\n-            ...   */\n+\t exception-declaration:\n+\t    type-specifier-seq declarator\n+\t    type-specifier-seq abstract-declarator\n+\t    ...   */\n     case HANDLER:\n       pp_cxx_identifier (pp, \"catch\");\n       pp_cxx_left_paren (pp);\n@@ -1564,8 +1564,8 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n       break;\n \n       /* selection-statement:\n-            if ( expression ) statement\n-            if ( expression ) statement else statement  */\n+\t    if ( expression ) statement\n+\t    if ( expression ) statement else statement  */\n     case IF_STMT:\n       pp_cxx_identifier (pp, \"if\");\n       pp_cxx_whitespace (pp);\n@@ -1602,10 +1602,10 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n       break;\n \n       /* iteration-statement:\n-            while ( expression ) statement\n-            do statement while ( expression ) ;\n-            for ( expression(opt) ; expression(opt) ; expression(opt) ) statement\n-            for ( declaration expression(opt) ; expression(opt) ) statement  */\n+\t    while ( expression ) statement\n+\t    do statement while ( expression ) ;\n+\t    for ( expression(opt) ; expression(opt) ; expression(opt) ) statement\n+\t    for ( declaration expression(opt) ; expression(opt) ) statement  */\n     case WHILE_STMT:\n       pp_cxx_identifier (pp, \"while\");\n       pp_space (pp);\n@@ -1637,9 +1637,9 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n       pp_space (pp);\n       pp_cxx_left_paren (pp);\n       if (FOR_INIT_STMT (t))\n-        pp_cxx_statement (pp, FOR_INIT_STMT (t));\n+\tpp_cxx_statement (pp, FOR_INIT_STMT (t));\n       else\n-        pp_cxx_semicolon (pp);\n+\tpp_cxx_semicolon (pp);\n       pp_needs_newline (pp) = false;\n       pp_cxx_whitespace (pp);\n       if (FOR_COND (t))\n@@ -1657,9 +1657,9 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n       break;\n \n       /* jump-statement:\n-            goto identifier;\n-            continue ;\n-            return expression(opt) ;  */\n+\t    goto identifier;\n+\t    continue ;\n+\t    return expression(opt) ;  */\n     case BREAK_STMT:\n     case CONTINUE_STMT:\n       pp_identifier (pp, TREE_CODE (t) == BREAK_STMT ? \"break\" : \"continue\");\n@@ -1668,7 +1668,7 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n       break;\n \n       /* expression-statement:\n-            expression(opt) ;  */\n+\t    expression(opt) ;  */\n     case EXPR_STMT:\n       pp_cxx_expression (pp, EXPR_STMT_EXPR (t));\n       pp_cxx_semicolon (pp);\n@@ -1756,7 +1756,7 @@ pp_cxx_template_parameter_list (cxx_pretty_printer *pp, tree t)\n   for (i = 0; i < n; ++i)\n     {\n       if (i)\n-        pp_cxx_separate_with (pp, ',');\n+\tpp_cxx_separate_with (pp, ',');\n       pp_cxx_template_parameter (pp, TREE_VEC_ELT (t, i));\n     }\n }\n@@ -1783,7 +1783,7 @@ pp_cxx_template_parameter (cxx_pretty_printer *pp, tree t)\n     case TYPE_DECL:\n       pp_cxx_identifier (pp, \"class\");\n       if (DECL_NAME (parameter))\n-        pp_cxx_tree_identifier (pp, DECL_NAME (parameter));\n+\tpp_cxx_tree_identifier (pp, DECL_NAME (parameter));\n       /* FIXME: Chech if we should print also default argument.  */\n       break;\n \n@@ -1885,19 +1885,19 @@ pp_cxx_declaration (cxx_pretty_printer *pp, tree t)\n     switch (DECL_USE_TEMPLATE (t))\n       {\n       case 1:\n-        pp_cxx_template_declaration (pp, t);\n-        break;\n+\tpp_cxx_template_declaration (pp, t);\n+\tbreak;\n \n       case 2:\n-        pp_cxx_explicit_specialization (pp, t);\n-        break;\n+\tpp_cxx_explicit_specialization (pp, t);\n+\tbreak;\n \n       case 3:\n-        pp_cxx_explicit_instantiation (pp, t);\n-        break;\n+\tpp_cxx_explicit_instantiation (pp, t);\n+\tbreak;\n \n       default:\n-        break;\n+\tbreak;\n       }\n   else switch (TREE_CODE (t))\n     {\n@@ -1908,16 +1908,16 @@ pp_cxx_declaration (cxx_pretty_printer *pp, tree t)\n \n     case FUNCTION_DECL:\n       if (DECL_SAVED_TREE (t))\n-        pp_cxx_function_definition (pp, t);\n+\tpp_cxx_function_definition (pp, t);\n       else\n-        pp_cxx_simple_declaration (pp, t);\n+\tpp_cxx_simple_declaration (pp, t);\n       break;\n \n     case NAMESPACE_DECL:\n       if (DECL_NAMESPACE_ALIAS (t))\n-        pp_cxx_namespace_alias_definition (pp, t);\n+\tpp_cxx_namespace_alias_definition (pp, t);\n       else\n-        pp_cxx_original_namespace_definition (pp, t);\n+\tpp_cxx_original_namespace_definition (pp, t);\n       break;\n \n     default:"}, {"sha": "a489279de442a1662031f25360b52e8cf3f0193e", "filename": "gcc/cp/cxx-pretty-print.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fcxx-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fcxx-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.h?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -44,21 +44,21 @@ typedef struct\n #define pp_cxx_cv_qualifier_seq(PP, T)   \\\n    pp_c_type_qualifier_list (pp_c_base (PP), T)\n \n-#define pp_cxx_whitespace(PP)          pp_c_whitespace (pp_c_base (PP))\n-#define pp_cxx_left_paren(PP)          pp_c_left_paren (pp_c_base (PP))\n-#define pp_cxx_right_paren(PP)         pp_c_right_paren (pp_c_base (PP))\n-#define pp_cxx_left_brace(PP)          pp_c_left_brace (pp_c_base (PP))\n-#define pp_cxx_right_brace(PP)         pp_c_right_brace (pp_c_base (PP))\n-#define pp_cxx_left_bracket(PP)        pp_c_left_bracket (pp_c_base (PP))\n-#define pp_cxx_right_bracket(PP)       pp_c_right_bracket (pp_c_base (PP))\n-#define pp_cxx_dot(PP)                 pp_c_dot (pp_c_base (PP))\n-#define pp_cxx_ampersand(PP)           pp_c_ampersand (pp_c_base (PP))\n-#define pp_cxx_star(PP)                pp_c_star (pp_c_base (PP))\n-#define pp_cxx_arrow(PP)               pp_c_arrow (pp_c_base (PP))\n-#define pp_cxx_semicolon(PP)           pp_c_semicolon (pp_c_base (PP))\n-#define pp_cxx_complement(PP)          pp_c_complement (pp_c_base (PP))\n-\n-#define pp_cxx_identifier(PP, I)       pp_c_identifier (pp_c_base (PP), I)\n+#define pp_cxx_whitespace(PP)\t\tpp_c_whitespace (pp_c_base (PP))\n+#define pp_cxx_left_paren(PP)\t\tpp_c_left_paren (pp_c_base (PP))\n+#define pp_cxx_right_paren(PP)\t\tpp_c_right_paren (pp_c_base (PP))\n+#define pp_cxx_left_brace(PP)\t\tpp_c_left_brace (pp_c_base (PP))\n+#define pp_cxx_right_brace(PP)\t\tpp_c_right_brace (pp_c_base (PP))\n+#define pp_cxx_left_bracket(PP)\t\tpp_c_left_bracket (pp_c_base (PP))\n+#define pp_cxx_right_bracket(PP)\tpp_c_right_bracket (pp_c_base (PP))\n+#define pp_cxx_dot(PP)\t\t\tpp_c_dot (pp_c_base (PP))\n+#define pp_cxx_ampersand(PP)\t\tpp_c_ampersand (pp_c_base (PP))\n+#define pp_cxx_star(PP)\t\t\tpp_c_star (pp_c_base (PP))\n+#define pp_cxx_arrow(PP)\t\tpp_c_arrow (pp_c_base (PP))\n+#define pp_cxx_semicolon(PP)\t\tpp_c_semicolon (pp_c_base (PP))\n+#define pp_cxx_complement(PP)\t\tpp_c_complement (pp_c_base (PP))\n+\n+#define pp_cxx_identifier(PP, I)\tpp_c_identifier (pp_c_base (PP), I)\n #define pp_cxx_tree_identifier(PP, T) \\\n   pp_c_tree_identifier (pp_c_base (PP), T)\n "}, {"sha": "44b45fc9d0afdc5aaed7697825b51494ba6ab8c6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 295, "deletions": 295, "changes": 590, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -66,7 +66,7 @@ static tree grokvardecl (tree, tree, const cp_decl_specifier_seq *,\n static void record_unknown_type (tree, const char *);\n static tree builtin_function_1 (const char *, tree, tree,\n \t\t\t\tenum built_in_function code,\n-                                enum built_in_class cl, const char *,\n+\t\t\t\tenum built_in_class cl, const char *,\n \t\t\t\ttree);\n static tree build_library_fn_1 (tree, enum tree_code, tree);\n static int member_function_or_else (tree, tree, enum overload_flags);\n@@ -128,7 +128,7 @@ tree error_mark_list;\n \ttree vtable_entry_type;\n \ttree delta_type_node;\n \ttree __t_desc_type_node;\n-        tree ti_desc_type_node;\n+\ttree ti_desc_type_node;\n \ttree bltn_desc_type_node, ptr_desc_type_node;\n \ttree ary_desc_type_node, func_desc_type_node, enum_desc_type_node;\n \ttree class_desc_type_node, si_class_desc_type_node, vmi_class_desc_type_node;\n@@ -306,7 +306,7 @@ current_tmpl_spec_kind (int n_class_scopes)\n     /* We've not seen enough template headers to match all the\n        specialized classes present.  For example:\n \n-         template <class T> void R<T>::S<T>::f(int);\n+\t template <class T> void R<T>::S<T>::f(int);\n \n        This is invalid; there needs to be one set of template\n        parameters for each class.  */\n@@ -315,22 +315,22 @@ current_tmpl_spec_kind (int n_class_scopes)\n     /* We're processing a non-template declaration (even though it may\n        be a member of a template class.)  For example:\n \n-         template <class T> void S<T>::f(int);\n+\t template <class T> void S<T>::f(int);\n \n        The `class T' maches the `S<T>', leaving no template headers\n        corresponding to the `f'.  */\n     return tsk_none;\n   else if (n_template_parm_scopes > n_class_scopes + 1)\n     /* We've got too many template headers.  For example:\n \n-         template <> template <class T> void f (T);\n+\t template <> template <class T> void f (T);\n \n        There need to be more enclosing classes.  */\n     return tsk_excessive_parms;\n   else\n     /* This must be a template.  It's of the form:\n \n-         template <class T> template <class U> void S<T>::f(U);\n+\t template <class T> template <class U> void S<T>::f(U);\n \n        This is a specialization if the innermost level was a\n        specialization; otherwise it's just a definition of the\n@@ -362,7 +362,7 @@ pop_label (tree label, tree old_value)\n #ifdef USE_MAPPED_LOCATION\n \t  location = input_location; /* FIXME want (input_filename, (line)0) */\n #else\n- \t  location.file = input_filename;\n+\t  location.file = input_filename;\n \t  location.line = 0;\n #endif\n \t  /* Avoid crashing later.  */\n@@ -569,7 +569,7 @@ poplevel (int keep, int reverse, int functionbody)\n   for (link = decls; link; link = TREE_CHAIN (link))\n     {\n       if (leaving_for_scope && TREE_CODE (link) == VAR_DECL\n-          && DECL_NAME (link))\n+\t  && DECL_NAME (link))\n \t{\n \t  tree name = DECL_NAME (link);\n \t  cxx_binding *ob;\n@@ -586,8 +586,8 @@ poplevel (int keep, int reverse, int functionbody)\n \t  if (ob && ob->scope == current_binding_level->level_chain)\n \t    /* We have something like:\n \n-\t         int i;\n-\t         for (int i; ;);\n+\t\t int i;\n+\t\t for (int i; ;);\n \n \t       and we are leaving the `for' scope.  There's no reason to\n \t       keep the binding of the inner `i' in this case.  */\n@@ -890,15 +890,15 @@ decls_match (tree newdecl, tree olddecl)\n \treturn 0;\n \n       if (TREE_CODE (f1) != TREE_CODE (f2))\n-        return 0;\n+\treturn 0;\n \n       if (same_type_p (TREE_TYPE (f1), TREE_TYPE (f2)))\n \t{\n \t  if (p2 == NULL_TREE && DECL_EXTERN_C_P (olddecl)\n \t      && (DECL_BUILT_IN (olddecl)\n #ifndef NO_IMPLICIT_EXTERN_C\n-\t          || (DECL_IN_SYSTEM_HEADER (newdecl) && !DECL_CLASS_SCOPE_P (newdecl))\n-\t          || (DECL_IN_SYSTEM_HEADER (olddecl) && !DECL_CLASS_SCOPE_P (olddecl))\n+\t\t  || (DECL_IN_SYSTEM_HEADER (newdecl) && !DECL_CLASS_SCOPE_P (newdecl))\n+\t\t  || (DECL_IN_SYSTEM_HEADER (olddecl) && !DECL_CLASS_SCOPE_P (olddecl))\n #endif\n \t      ))\n \t    {\n@@ -909,11 +909,11 @@ decls_match (tree newdecl, tree olddecl)\n #ifndef NO_IMPLICIT_EXTERN_C\n \t  else if (p1 == NULL_TREE\n \t\t   && (DECL_EXTERN_C_P (olddecl)\n-\t               && DECL_IN_SYSTEM_HEADER (olddecl)\n-\t               && !DECL_CLASS_SCOPE_P (olddecl))\n+\t\t       && DECL_IN_SYSTEM_HEADER (olddecl)\n+\t\t       && !DECL_CLASS_SCOPE_P (olddecl))\n \t\t   && (DECL_EXTERN_C_P (newdecl)\n-\t               && DECL_IN_SYSTEM_HEADER (newdecl)\n-\t               && !DECL_CLASS_SCOPE_P (newdecl)))\n+\t\t       && DECL_IN_SYSTEM_HEADER (newdecl)\n+\t\t       && !DECL_CLASS_SCOPE_P (newdecl)))\n \t    {\n \t      types_match = self_promoting_args_p (p2);\n \t      TREE_TYPE (newdecl) = TREE_TYPE (olddecl);\n@@ -1073,39 +1073,39 @@ duplicate_decls (tree newdecl, tree olddecl)\n     {\n       if (TREE_CODE (newdecl) != FUNCTION_DECL)\n \t{\n-          /* Avoid warnings redeclaring anticipated built-ins.  */\n-          if (DECL_ANTICIPATED (olddecl))\n-            return NULL_TREE;\n+\t  /* Avoid warnings redeclaring anticipated built-ins.  */\n+\t  if (DECL_ANTICIPATED (olddecl))\n+\t    return NULL_TREE;\n \n \t  /* If you declare a built-in or predefined function name as static,\n \t     the old definition is overridden, but optionally warn this was a\n \t     bad choice of name.  */\n \t  if (! TREE_PUBLIC (newdecl))\n \t    {\n \t      if (warn_shadow)\n-                warning (0, \"shadowing %s function %q#D\",\n-                         DECL_BUILT_IN (olddecl) ? \"built-in\" : \"library\",\n-                         olddecl);\n+\t\twarning (0, \"shadowing %s function %q#D\",\n+\t\t\t DECL_BUILT_IN (olddecl) ? \"built-in\" : \"library\",\n+\t\t\t olddecl);\n \t      /* Discard the old built-in function.  */\n \t      return NULL_TREE;\n \t    }\n \t  /* If the built-in is not ansi, then programs can override\n \t     it even globally without an error.  */\n \t  else if (! DECL_BUILT_IN (olddecl))\n \t    warning (0, \"library function %q#D redeclared as non-function %q#D\",\n-                     olddecl, newdecl);\n+\t\t     olddecl, newdecl);\n \t  else\n \t    {\n \t      error (\"declaration of %q#D\", newdecl);\n \t      error (\"conflicts with built-in declaration %q#D\",\n-                     olddecl);\n+\t\t     olddecl);\n \t    }\n \t  return NULL_TREE;\n \t}\n       else if (!types_match)\n \t{\n-          /* Avoid warnings redeclaring anticipated built-ins.  */\n-          if (DECL_ANTICIPATED (olddecl))\n+\t  /* Avoid warnings redeclaring anticipated built-ins.  */\n+\t  if (DECL_ANTICIPATED (olddecl))\n \t    {\n \t      /* Deal with fileptr_type_node.  FILE type is not known\n \t\t at the time we create the builtins.  */\n@@ -1151,12 +1151,12 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t\t{\n \t\t  warning (0, \"new declaration %q#D\", newdecl);\n \t\t  warning (0, \"ambiguates built-in declaration %q#D\",\n-                           olddecl);\n+\t\t\t   olddecl);\n \t\t}\n \t      else if (warn_shadow)\n \t\twarning (0, \"shadowing %s function %q#D\",\n-                         DECL_BUILT_IN (olddecl) ? \"built-in\" : \"library\",\n-                         olddecl);\n+\t\t\t DECL_BUILT_IN (olddecl) ? \"built-in\" : \"library\",\n+\t\t\t olddecl);\n \t    }\n \t  else\n \t    /* Discard the old built-in function.  */\n@@ -1268,7 +1268,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t  if (DECL_EXTERN_C_P (newdecl) && DECL_EXTERN_C_P (olddecl))\n \t    {\n \t      error (\"declaration of C function %q#D conflicts with\",\n-                     newdecl);\n+\t\t     newdecl);\n \t      cp_error_at (\"previous declaration %q#D here\", olddecl);\n \t    }\n \t  else if (compparms (TYPE_ARG_TYPES (TREE_TYPE (newdecl)),\n@@ -1284,8 +1284,8 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t{\n \t  error (\"conflicting declaration %q#D\", newdecl);\n \t  cp_error_at (\"%qD has a previous declaration as %q#D\",\n-                       olddecl, olddecl);\n-          return error_mark_node;\n+\t\t       olddecl, olddecl);\n+\t  return error_mark_node;\n \t}\n     }\n   else if (TREE_CODE (newdecl) == FUNCTION_DECL\n@@ -1318,7 +1318,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n     {\n       /* In [namespace.alias] we have:\n \n-           In a declarative region, a namespace-alias-definition can be\n+\t   In a declarative region, a namespace-alias-definition can be\n \t   used to redefine a namespace-alias declared in that declarative\n \t   region to refer only to the namespace to which it already\n \t   refers.\n@@ -1331,7 +1331,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \treturn olddecl;\n       /* [namespace.alias]\n \n-         A namespace-name or namespace-alias shall not be declared as\n+\t A namespace-name or namespace-alias shall not be declared as\n \t the name of any other entity in the same declarative region.\n \t A namespace-name defined at global scope shall not be\n \t declared as the name of any other entity in any global scope\n@@ -1375,7 +1375,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t      cp_error_at (\"previous declaration of %q#D with %qL linkage\",\n \t\t\t   olddecl, DECL_LANGUAGE (olddecl));\n \t      error (\"conflicts with new declaration with %qL linkage\",\n-                     DECL_LANGUAGE (newdecl));\n+\t\t     DECL_LANGUAGE (newdecl));\n \t    }\n \t}\n \n@@ -1400,12 +1400,12 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t\t    pedwarn (\"default argument given for parameter %d of %q#D\",\n \t\t\t     i, newdecl);\n \t\t    cp_pedwarn_at (\"after previous specification in %q#D\",\n-\t\t\t           olddecl);\n+\t\t\t\t   olddecl);\n \t\t  }\n \t\telse\n \t\t  {\n \t\t    error (\"default argument given for parameter %d of %q#D\",\n-                           i, newdecl);\n+\t\t\t   i, newdecl);\n \t\t    cp_error_at (\"after previous specification in %q#D\",\n \t\t\t\t olddecl);\n \t\t  }\n@@ -1459,8 +1459,8 @@ duplicate_decls (tree newdecl, tree olddecl)\n       new_defines_function = DECL_INITIAL (newdecl) != NULL_TREE;\n \n       /* Optionally warn about more than one declaration for the same\n-         name, but don't warn about a function declaration followed by a\n-         definition.  */\n+\t name, but don't warn about a function declaration followed by a\n+\t definition.  */\n       if (warn_redundant_decls && ! DECL_ARTIFICIAL (olddecl)\n \t  && !(new_defines_function && DECL_INITIAL (olddecl) == NULL_TREE)\n \t  /* Don't warn about extern decl followed by definition.  */\n@@ -1560,10 +1560,10 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t      && ! DECL_IS_BUILTIN (olddecl)\n \t      && flag_exceptions\n \t      && !comp_except_specs (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (newdecl)),\n-\t                             TYPE_RAISES_EXCEPTIONS (TREE_TYPE (olddecl)), 1))\n+\t\t\t\t     TYPE_RAISES_EXCEPTIONS (TREE_TYPE (olddecl)), 1))\n \t    {\n \t      error (\"declaration of %qF throws different exceptions\",\n-                     newdecl);\n+\t\t     newdecl);\n \t      cp_error_at (\"than previous declaration %qF\", olddecl);\n \t    }\n \t}\n@@ -1611,7 +1611,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t}\n \n       /* Merge the section attribute.\n-         We want to issue an error if the sections conflict but that must be\n+\t We want to issue an error if the sections conflict but that must be\n \t done later in decl_attributes since we are called before attributes\n \t are assigned.  */\n       if (DECL_SECTION_NAME (newdecl) == NULL_TREE)\n@@ -1689,7 +1689,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n       DECL_REPO_AVAILABLE_P (newdecl) = DECL_REPO_AVAILABLE_P (olddecl);\n       DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);\n       DECL_INITIALIZED_IN_CLASS_P (newdecl)\n-        |= DECL_INITIALIZED_IN_CLASS_P (olddecl);\n+\t|= DECL_INITIALIZED_IN_CLASS_P (olddecl);\n       olddecl_friend = DECL_FRIEND_P (olddecl);\n \n       /* Only functions have DECL_BEFRIENDING_CLASSES.  */\n@@ -1930,7 +1930,7 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n \treturn \"%qD conflicts with used function\";\n \n       /* We'll complain about linkage mismatches in\n-         warn_extern_redeclared_static.  */\n+\t warn_extern_redeclared_static.  */\n \n       /* Defining the same name twice is no good.  */\n       if (DECL_INITIAL (olddecl) != NULL_TREE\n@@ -2127,8 +2127,8 @@ decl_jump_unsafe (tree decl)\n \n static void\n check_previous_goto_1 (tree decl,\n-                       struct cp_binding_level* level,\n-                       tree names, const location_t *locus)\n+\t\t       struct cp_binding_level* level,\n+\t\t       tree names, const location_t *locus)\n {\n   int identified = 0;\n   int saw_eh = 0;\n@@ -2583,7 +2583,7 @@ make_typename_type (tree context, tree name, enum tag_types tag_type,\n \t    {\n \t      if (complain & tf_error)\n \t\terror (\"no class template named %q#T in %q#T\",\n-                       name, context);\n+\t\t       name, context);\n \t      return error_mark_node;\n \t    }\n \n@@ -2594,11 +2594,11 @@ make_typename_type (tree context, tree name, enum tag_types tag_type,\n \t\t\t\t\tTREE_OPERAND (fullname, 1),\n \t\t\t\t\tNULL_TREE, context,\n \t\t\t\t\t/*entering_scope=*/0,\n-\t                                tf_error | tf_warning | tf_user);\n+\t\t\t\t\ttf_error | tf_warning | tf_user);\n \t}\n       else\n \t{\n-          tree t;\n+\t  tree t;\n \n \t  if (!IS_AGGR_TYPE (context))\n \t    {\n@@ -2719,8 +2719,8 @@ make_unbound_class_template (tree context, tree name, tree parm_list,\n \n void\n record_builtin_type (enum rid rid_index,\n-                     const char* name,\n-                     tree type)\n+\t\t     const char* name,\n+\t\t     tree type)\n {\n   tree rname = NULL_TREE, tname = NULL_TREE;\n   tree tdecl = NULL_TREE;\n@@ -2885,7 +2885,7 @@ cxx_init_decl_processing (void)\n   /* Enter the global namespace.  */\n   gcc_assert (global_namespace == NULL_TREE);\n   global_namespace = build_lang_decl (NAMESPACE_DECL, global_scope_name,\n-                                      void_type_node);\n+\t\t\t\t      void_type_node);\n   begin_scope (sk_namespace, global_namespace);\n \n   current_lang_name = NULL_TREE;\n@@ -3141,12 +3141,12 @@ cp_make_fname_decl (tree id, int type_dep)\n \n static tree\n builtin_function_1 (const char* name,\n-                    tree type,\n-                    tree context,\n+\t\t    tree type,\n+\t\t    tree context,\n \t\t    enum built_in_function code,\n-                    enum built_in_class class,\n-                    const char* libname,\n-                    tree attrs)\n+\t\t    enum built_in_class class,\n+\t\t    const char* libname,\n+\t\t    tree attrs)\n {\n   tree decl = build_library_fn_1 (get_identifier (name), ERROR_MARK, type);\n   DECL_BUILT_IN_CLASS (decl) = class;\n@@ -3193,11 +3193,11 @@ builtin_function_1 (const char* name,\n \n tree\n builtin_function (const char* name,\n-                  tree type,\n-                  int code,\n-                  enum built_in_class cl,\n-                  const char* libname,\n-                  tree attrs)\n+\t\t  tree type,\n+\t\t  int code,\n+\t\t  enum built_in_class cl,\n+\t\t  const char* libname,\n+\t\t  tree attrs)\n {\n   /* All builtins that don't begin with an '_' should additionally\n      go in the 'std' namespace.  */\n@@ -3372,17 +3372,17 @@ fixup_anonymous_aggr (tree t)\n \t    type = TREE_TYPE (field);\n \t    if (CLASS_TYPE_P (type))\n \t      {\n-\t        if (TYPE_NEEDS_CONSTRUCTING (type))\n+\t\tif (TYPE_NEEDS_CONSTRUCTING (type))\n \t\t  cp_error_at (\"member %q#D with constructor not allowed \"\n-                               \"in anonymous aggregate\",\n+\t\t\t       \"in anonymous aggregate\",\n \t\t\t       field);\n \t\tif (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n \t\t  cp_error_at (\"member %q#D with destructor not allowed \"\n-                               \"in anonymous aggregate\",\n+\t\t\t       \"in anonymous aggregate\",\n \t\t\t       field);\n \t\tif (TYPE_HAS_COMPLEX_ASSIGN_REF (type))\n \t\t  cp_error_at (\"member %q#D with copy assignment operator \"\n-                               \"not allowed in anonymous aggregate\",\n+\t\t\t       \"not allowed in anonymous aggregate\",\n \t\t\t       field);\n \t      }\n \t  }\n@@ -3431,26 +3431,26 @@ check_tag_decl (cp_decl_specifier_seq *declspecs)\n \t   && TYPE_ANONYMOUS_P (declared_type))\n     {\n       /* 7/3 In a simple-declaration, the optional init-declarator-list\n-         can be omitted only when declaring a class (clause 9) or\n-         enumeration (7.2), that is, when the decl-specifier-seq contains\n-         either a class-specifier, an elaborated-type-specifier with\n-         a class-key (9.1), or an enum-specifier.  In these cases and\n-         whenever a class-specifier or enum-specifier is present in the\n-         decl-specifier-seq, the identifiers in these specifiers are among\n-         the names being declared by the declaration (as class-name,\n-         enum-names, or enumerators, depending on the syntax).  In such\n-         cases, and except for the declaration of an unnamed bit-field (9.6),\n-         the decl-specifier-seq shall introduce one or more names into the\n-         program, or shall redeclare a name introduced by a previous\n-         declaration.  [Example:\n-             enum { };            // ill-formed\n-             typedef class { };   // ill-formed\n-         --end example]  */\n+\t can be omitted only when declaring a class (clause 9) or\n+\t enumeration (7.2), that is, when the decl-specifier-seq contains\n+\t either a class-specifier, an elaborated-type-specifier with\n+\t a class-key (9.1), or an enum-specifier.  In these cases and\n+\t whenever a class-specifier or enum-specifier is present in the\n+\t decl-specifier-seq, the identifiers in these specifiers are among\n+\t the names being declared by the declaration (as class-name,\n+\t enum-names, or enumerators, depending on the syntax).  In such\n+\t cases, and except for the declaration of an unnamed bit-field (9.6),\n+\t the decl-specifier-seq shall introduce one or more names into the\n+\t program, or shall redeclare a name introduced by a previous\n+\t declaration.  [Example:\n+\t     enum { };\t\t\t// ill-formed\n+\t     typedef class { };\t\t// ill-formed\n+\t --end example]  */\n       if (saw_typedef)\n-        {\n-          error (\"missing type-name in typedef-declaration\");\n-          return NULL_TREE;\n-        }\n+\t{\n+\t  error (\"missing type-name in typedef-declaration\");\n+\t  return NULL_TREE;\n+\t}\n       /* Anonymous unions are objects, so they can have specifiers.  */;\n       SET_ANON_AGGR_TYPE_P (declared_type);\n \n@@ -3572,9 +3572,9 @@ groktypename (cp_decl_specifier_seq *type_specifiers,\n tree\n start_decl (const cp_declarator *declarator,\n \t    cp_decl_specifier_seq *declspecs,\n-            int initialized,\n-            tree attributes,\n-            tree prefix_attributes,\n+\t    int initialized,\n+\t    tree attributes,\n+\t    tree prefix_attributes,\n \t    tree *pushed_scope_p)\n {\n   tree decl;\n@@ -3646,7 +3646,7 @@ start_decl (const cp_declarator *declarator,\n       if (! toplevel_bindings_p ()\n \t  && DECL_EXTERNAL (decl))\n \twarning (0, \"declaration of %q#D has %<extern%> and is initialized\",\n-                 decl);\n+\t\t decl);\n       DECL_EXTERNAL (decl) = 0;\n       if (toplevel_bindings_p ())\n \tTREE_STATIC (decl) = 1;\n@@ -3682,7 +3682,7 @@ start_decl (const cp_declarator *declarator,\n \t\t{\n \t\t  if (!same_type_p (DECL_CONTEXT (field), context))\n \t\t    pedwarn (\"ISO C++ does not permit %<%T::%D%> \"\n-                             \"to be defined as %<%T::%D%>\",\n+\t\t\t     \"to be defined as %<%T::%D%>\",\n \t\t\t     DECL_CONTEXT (field), DECL_NAME (decl),\n \t\t\t     context, DECL_NAME (decl));\n \t\t  DECL_CONTEXT (decl) = DECL_CONTEXT (field);\n@@ -3737,7 +3737,7 @@ start_decl (const cp_declarator *declarator,\n \n       if (DECL_EXTERNAL (decl) && ! DECL_TEMPLATE_SPECIALIZATION (decl))\n \tpedwarn (\"declaration of %q#D outside of class is not definition\",\n-                 decl);\n+\t\t decl);\n     }\n \n   /* Enter this declaration into the symbol table.  */\n@@ -3865,7 +3865,7 @@ grok_reference_init (tree decl, tree type, tree init, tree *cleanup)\n   if (TREE_CODE (init) == CONSTRUCTOR)\n     {\n       error (\"ISO C++ forbids use of initializer list to \"\n-             \"initialize reference %qD\", decl);\n+\t     \"initialize reference %qD\", decl);\n       return NULL_TREE;\n     }\n \n@@ -4052,10 +4052,10 @@ maybe_commonize_var (tree decl)\n \t      TREE_PUBLIC (decl) = 0;\n \t      DECL_COMMON (decl) = 0;\n \t      cp_warning_at (\"sorry: semantics of inline function static \"\n-                             \"data %q#D are wrong (you'll wind up \"\n-                             \"with multiple copies)\", decl);\n+\t\t\t     \"data %q#D are wrong (you'll wind up \"\n+\t\t\t     \"with multiple copies)\", decl);\n \t      warning (0, \"%J  you can work around this by removing \"\n-                       \"the initializer\",\n+\t\t       \"the initializer\",\n \t\t       decl);\n \t    }\n \t}\n@@ -4473,7 +4473,7 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n \t      if (TYPE_NON_AGGREGATE_CLASS (type))\n \t\t{\n \t\t  error (\"%qD must be initialized by constructor, \"\n-                         \"not by %<{...}%>\",\n+\t\t\t \"not by %<{...}%>\",\n \t\t\t decl);\n \t\t  init = error_mark_node;\n \t\t}\n@@ -5054,7 +5054,7 @@ get_atexit_node (void)\n     {\n       /* The declaration for `atexit' is:\n \n-           int atexit (void (*)());\n+\t   int atexit (void (*)());\n \n \t We build up the argument types and then then function type\n \t itself.  */\n@@ -5253,16 +5253,16 @@ expand_static_init (tree decl, tree init)\n       /* Emit code to perform this initialization but once.  This code\n \t looks like:\n \n-           static <type> guard;\n-           if (!guard.first_byte) {\n+\t   static <type> guard;\n+\t   if (!guard.first_byte) {\n \t     if (__cxa_guard_acquire (&guard)) {\n \t       bool flag = false;\n \t       try {\n-\t         // Do initialization.\n-\t         flag = true; __cxa_guard_release (&guard);\n-\t         // Register variable for destruction at end of program.\n+\t\t // Do initialization.\n+\t\t flag = true; __cxa_guard_release (&guard);\n+\t\t // Register variable for destruction at end of program.\n \t       } catch {\n-\t         if (!flag) __cxa_guard_abort (&guard);\n+\t\t if (!flag) __cxa_guard_abort (&guard);\n \t       }\n \t   }\n \n@@ -5277,7 +5277,7 @@ expand_static_init (tree decl, tree init)\n \t   initialization is not complete, so it will be tried again\n \t   the next time control enters the declaration.\n \n-         This process should be thread-safe, too; multiple threads\n+\t This process should be thread-safe, too; multiple threads\n \t should not be able to initialize the variable more than\n \t once.  */\n \n@@ -5436,21 +5436,21 @@ member_function_or_else (tree ctype, tree cur_type, enum overload_flags flags)\n \n static void\n bad_specifiers (tree object,\n-                const char* type,\n-                int virtualp,\n-                int quals,\n-                int inlinep,\n-                int friendp,\n-                int raises)\n+\t\tconst char* type,\n+\t\tint virtualp,\n+\t\tint quals,\n+\t\tint inlinep,\n+\t\tint friendp,\n+\t\tint raises)\n {\n   if (virtualp)\n     error (\"%qD declared as a %<virtual%> %s\", object, type);\n   if (inlinep)\n     error (\"%qD declared as an %<inline%> %s\", object, type);\n   if (quals)\n     error (\"%<const%> and %<volatile%> function specifiers on \"\n-           \"%qD invalid in %s declaration\",\n-           object, type);\n+\t   \"%qD invalid in %s declaration\",\n+\t   object, type);\n   if (friendp)\n     cp_error_at (\"%qD declared as a friend\", object);\n   if (raises\n@@ -5481,22 +5481,22 @@ bad_specifiers (tree object,\n \n static tree\n grokfndecl (tree ctype,\n-            tree type,\n-            tree declarator,\n+\t    tree type,\n+\t    tree declarator,\n \t    tree parms,\n-            tree orig_declarator,\n-            int virtualp,\n-            enum overload_flags flags,\n+\t    tree orig_declarator,\n+\t    int virtualp,\n+\t    enum overload_flags flags,\n \t    cp_cv_quals quals,\n-            tree raises,\n-            int check,\n-            int friendp,\n-            int publicp,\n-            int inlinep,\n+\t    tree raises,\n+\t    int check,\n+\t    int friendp,\n+\t    int publicp,\n+\t    int inlinep,\n \t    special_function_kind sfk,\n-            int funcdef_flag,\n-            int template_count,\n-            tree in_namespace,\n+\t    int funcdef_flag,\n+\t    int template_count,\n+\t    tree in_namespace,\n \t    tree* attrlist)\n {\n   tree decl;\n@@ -5586,8 +5586,8 @@ grokfndecl (tree ctype,\n \t\t\t      decl);\n \t\t  if (DECL_ORIGINAL_TYPE (TYPE_NAME (t)))\n \t\t    cp_pedwarn_at (\"%q#D does not refer to the unqualified \"\n-                                   \"type, so it is not used for linkage\",\n-                                   TYPE_NAME (t));\n+\t\t\t\t   \"type, so it is not used for linkage\",\n+\t\t\t\t   TYPE_NAME (t));\n \t\t}\n \t    }\n \t  else\n@@ -5649,8 +5649,8 @@ grokfndecl (tree ctype,\n \t    {\n \t      /* Something like `template <class T> friend void f<T>()'.  */\n \t      error (\"invalid use of template-id %qD in declaration \"\n-                     \"of primary template\",\n-                     orig_declarator);\n+\t\t     \"of primary template\",\n+\t\t     orig_declarator);\n \t      return NULL_TREE;\n \t    }\n \n@@ -5659,34 +5659,34 @@ grokfndecl (tree ctype,\n \t     the information in the TEMPLATE_ID_EXPR.  */\n \t  SET_DECL_IMPLICIT_INSTANTIATION (decl);\n \n-          if (TREE_CODE (fns) == COMPONENT_REF)\n-            {\n-              /* Due to bison parser ickiness, we will have already looked\n-                 up an operator_name or PFUNCNAME within the current class\n-                 (see template_id in parse.y). If the current class contains\n-                 such a name, we'll get a COMPONENT_REF here. Undo that.  */\n+\t  if (TREE_CODE (fns) == COMPONENT_REF)\n+\t    {\n+\t      /* Due to bison parser ickiness, we will have already looked\n+\t\t up an operator_name or PFUNCNAME within the current class\n+\t\t (see template_id in parse.y). If the current class contains\n+\t\t such a name, we'll get a COMPONENT_REF here. Undo that.  */\n \n-              gcc_assert (TREE_TYPE (TREE_OPERAND (fns, 0))\n+\t      gcc_assert (TREE_TYPE (TREE_OPERAND (fns, 0))\n \t\t\t  == current_class_type);\n-              fns = TREE_OPERAND (fns, 1);\n-            }\n+\t      fns = TREE_OPERAND (fns, 1);\n+\t    }\n \t  gcc_assert (TREE_CODE (fns) == IDENTIFIER_NODE\n \t\t      || TREE_CODE (fns) == OVERLOAD);\n \t  DECL_TEMPLATE_INFO (decl) = tree_cons (fns, args, NULL_TREE);\n \n \t  if (has_default_arg)\n \t    {\n \t      error (\"default arguments are not allowed in declaration \"\n-                     \"of friend template specialization %qD\",\n-                     decl);\n+\t\t     \"of friend template specialization %qD\",\n+\t\t     decl);\n \t      return NULL_TREE;\n \t    }\n \n \t  if (inlinep)\n \t    {\n \t      error (\"%<inline%> is not allowed in declaration of friend \"\n-                     \"template specialization %qD\",\n-                     decl);\n+\t\t     \"template specialization %qD\",\n+\t\t     decl);\n \t      return NULL_TREE;\n \t    }\n \t}\n@@ -5817,11 +5817,11 @@ set_linkage_for_static_data_member (tree decl)\n \n static tree\n grokvardecl (tree type,\n-             tree name,\n+\t     tree name,\n \t     const cp_decl_specifier_seq *declspecs,\n-             int initialized,\n-             int constp,\n-             tree scope)\n+\t     int initialized,\n+\t     int constp,\n+\t     tree scope)\n {\n   tree decl;\n   tree explicit_scope;\n@@ -6045,7 +6045,7 @@ check_static_variable_definition (tree decl, tree type)\n   if (!ARITHMETIC_TYPE_P (type) && TREE_CODE (type) != ENUMERAL_TYPE)\n     {\n       error (\"invalid in-class initialization of static data member \"\n-             \"of non-integral type %qT\",\n+\t     \"of non-integral type %qT\",\n \t     type);\n       /* If we just return the declaration, crashes will sometimes\n \t occur.  We therefore return void_type_node, as if this were a\n@@ -6055,11 +6055,11 @@ check_static_variable_definition (tree decl, tree type)\n     }\n   else if (!CP_TYPE_CONST_P (type))\n     error (\"ISO C++ forbids in-class initialization of non-const \"\n-           \"static member %qD\",\n-           decl);\n+\t   \"static member %qD\",\n+\t   decl);\n   else if (pedantic && !INTEGRAL_TYPE_P (type))\n     pedwarn (\"ISO C++ forbids initialization of member constant \"\n-             \"%qD of non-integral type %qT\", decl, type);\n+\t     \"%qD of non-integral type %qT\", decl, type);\n \n   return 0;\n }\n@@ -6136,7 +6136,7 @@ compute_array_index_type (tree name, tree size)\n       /* `(int) &fn' is not a valid array bound.  */\n       if (name)\n \terror (\"size of array %qD is not an integral constant-expression\",\n-               name);\n+\t       name);\n       else\n \terror (\"size of array is not an integral constant-expression\");\n     }\n@@ -6156,9 +6156,9 @@ compute_array_index_type (tree name, tree size)\n       HOST_WIDE_INT saved_processing_template_decl;\n \n       /* Compute the index of the largest element in the array.  It is\n-     \t one less than the number of elements in the array.  We save\n-     \t and restore PROCESSING_TEMPLATE_DECL so that computations in\n-     \t cp_build_binary_op will be appropriately folded.  */\n+\t one less than the number of elements in the array.  We save\n+\t and restore PROCESSING_TEMPLATE_DECL so that computations in\n+\t cp_build_binary_op will be appropriately folded.  */\n       saved_processing_template_decl = processing_template_decl;\n       processing_template_decl = 0;\n       itype = cp_build_binary_op (MINUS_EXPR,\n@@ -6171,8 +6171,8 @@ compute_array_index_type (tree name, tree size)\n \t/* A variable sized array.  */\n \titype = variable_size (itype);\n       /* Make sure that there was no overflow when creating to a signed\n-     \t index type.  (For example, on a 32-bit machine, an array with\n-     \t size 2^32 - 1 is too big.)  */\n+\t index type.  (For example, on a 32-bit machine, an array with\n+\t size 2^32 - 1 is too big.)  */\n       else if (TREE_OVERFLOW (itype))\n \t{\n \t  error (\"overflow in array dimension\");\n@@ -6264,11 +6264,11 @@ create_array_type_for_decl (tree name, tree type, tree size)\n     {\n       if (name)\n \terror (\"declaration of %qD as multidimensional array must \"\n-               \"have bounds for all dimensions except the first\",\n-               name);\n+\t       \"have bounds for all dimensions except the first\",\n+\t       name);\n       else\n \terror (\"multidimensional array must have bounds for all \"\n-               \"dimensions except the first\");\n+\t       \"dimensions except the first\");\n \n       return error_mark_node;\n     }\n@@ -6295,8 +6295,8 @@ create_array_type_for_decl (tree name, tree type, tree size)\n \n static tree\n check_special_function_return_type (special_function_kind sfk,\n-                                    tree type,\n-                                    tree optype)\n+\t\t\t\t    tree type,\n+\t\t\t\t    tree optype)\n {\n   switch (sfk)\n     {\n@@ -6405,9 +6405,9 @@ check_var_type (tree identifier, tree type)\n tree\n grokdeclarator (const cp_declarator *declarator,\n \t\tconst cp_decl_specifier_seq *declspecs,\n-                enum decl_context decl_context,\n-                int initialized,\n-                tree* attrlist)\n+\t\tenum decl_context decl_context,\n+\t\tint initialized,\n+\t\ttree* attrlist)\n {\n   tree type = NULL_TREE;\n   int longlong = 0;\n@@ -6897,26 +6897,26 @@ grokdeclarator (const cp_declarator *declarator,\n     type_quals |= TYPE_QUAL_RESTRICT;\n   if (sfk == sfk_conversion && type_quals != TYPE_UNQUALIFIED)\n     error (\"qualifiers are not allowed on declaration of %<operator %T%>\",\n-           ctor_return_type);\n+\t   ctor_return_type);\n \n   if (TREE_CODE (type) == FUNCTION_TYPE\n       && type_quals != TYPE_UNQUALIFIED)\n     {\n       /* This was an error in C++98 (cv-qualifiers cannot be added to\n-         a function type), but DR 295 makes the code well-formed by\n-         dropping the extra qualifiers. */\n+\t a function type), but DR 295 makes the code well-formed by\n+\t dropping the extra qualifiers. */\n       if (pedantic)\n-        {\n-          tree bad_type = build_qualified_type (type, type_quals);\n-          pedwarn (\"ignoring %qV qualifiers added to function type %qT\",\n-                   bad_type, type);\n-        }\n+\t{\n+\t  tree bad_type = build_qualified_type (type, type_quals);\n+\t  pedwarn (\"ignoring %qV qualifiers added to function type %qT\",\n+\t\t   bad_type, type);\n+\t}\n       type_quals = TYPE_UNQUALIFIED;\n     }\n   type_quals |= cp_type_quals (type);\n   type = cp_build_qualified_type_real\n     (type, type_quals, ((typedef_decl && !DECL_ARTIFICIAL (typedef_decl)\n- \t\t\t ? tf_ignore_bad_quals : 0) | tf_error | tf_warning));\n+\t\t\t ? tf_ignore_bad_quals : 0) | tf_error | tf_warning));\n   /* We might have ignored or rejected some of the qualifiers.  */\n   type_quals = cp_type_quals (type);\n \n@@ -7124,7 +7124,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t       Make sure we have a valid type for the function to return.  */\n \n \t    /* We now know that the TYPE_QUALS don't apply to the\n-               decl, but to its return type.  */\n+\t       decl, but to its return type.  */\n \t    type_quals = TYPE_UNQUALIFIED;\n \n \t    /* Warn about some types functions can't return.  */\n@@ -7186,7 +7186,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t  return void_type_node;\n \t\t      }\n \t\t  }\n-\t\telse            /* It's a constructor.  */\n+\t\telse /* It's a constructor.  */\n \t\t  {\n \t\t    if (explicitp == 1)\n \t\t      explicitp = 2;\n@@ -7234,8 +7234,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  error (\"friend declaration not in class definition\");\n \t\tif (current_function_decl && funcdef_flag)\n \t\t  error (\"can't define friend function %qs in a local \"\n-                         \"class definition\",\n-                         name);\n+\t\t\t \"class definition\",\n+\t\t\t name);\n \t      }\n \n \t    arg_types = grokparms (declarator->u.function.parameters,\n@@ -7252,7 +7252,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t      }\n \n \t    type = build_function_type (type, arg_types);\n-            type = cp_build_qualified_type (type, quals);\n+\t    type = cp_build_qualified_type (type, quals);\n \t  }\n \t  break;\n \n@@ -7287,11 +7287,11 @@ grokdeclarator (const cp_declarator *declarator,\n \t    {\n \t      tree dummy;\n \n-              /* If the type is a FUNCTION_TYPE, pick up the\n-                 qualifiers from that function type. No other\n-                 qualifiers may be supplied. */\n-              if (TREE_CODE (type) == FUNCTION_TYPE)\n-                quals = cp_type_quals (type);\n+\t      /* If the type is a FUNCTION_TYPE, pick up the\n+\t\t qualifiers from that function type. No other\n+\t\t qualifiers may be supplied. */\n+\t      if (TREE_CODE (type) == FUNCTION_TYPE)\n+\t\tquals = cp_type_quals (type);\n \n \t      dummy = build_decl (TYPE_DECL, NULL_TREE, type);\n \t      grok_method_quals (declarator->u.pointer.class_type,\n@@ -7419,7 +7419,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t  else\n \t    {\n \t      error (\"cannot declare member function %<%T::%s%> within %<%T%>\",\n- \t\t     ctype, name, current_class_type);\n+\t\t     ctype, name, current_class_type);\n \t      return error_mark_node;\n \t    }\n \t}\n@@ -7482,29 +7482,29 @@ grokdeclarator (const cp_declarator *declarator,\n   if (explicitp == 1 || (explicitp && friendp))\n     {\n       /* [dcl.fct.spec] The explicit specifier shall only be used in\n-         declarations of constructors within a class definition.  */\n+\t declarations of constructors within a class definition.  */\n       error (\"only declarations of constructors can be %<explicit%>\");\n       explicitp = 0;\n     }\n \n   if (storage_class == sc_mutable)\n     {\n       if (decl_context != FIELD || friendp)\n-        {\n+\t{\n \t  error (\"non-member %qs cannot be declared %<mutable%>\", name);\n \t  storage_class = sc_none;\n-        }\n+\t}\n       else if (decl_context == TYPENAME || declspecs->specs[(int)ds_typedef])\n \t{\n \t  error (\"non-object member %qs cannot be declared %<mutable%>\", name);\n \t  storage_class = sc_none;\n \t}\n       else if (TREE_CODE (type) == FUNCTION_TYPE\n-               || TREE_CODE (type) == METHOD_TYPE)\n-        {\n+\t       || TREE_CODE (type) == METHOD_TYPE)\n+\t{\n \t  error (\"function %qs cannot be declared %<mutable%>\", name);\n \t  storage_class = sc_none;\n-        }\n+\t}\n       else if (staticp)\n \t{\n \t  error (\"static %qs cannot be declared %<mutable%>\", name);\n@@ -7591,12 +7591,12 @@ grokdeclarator (const cp_declarator *declarator,\n \t{\n \t  if (ctype == NULL_TREE)\n \t    {\n-              if (TREE_CODE (type) == METHOD_TYPE)\n+\t      if (TREE_CODE (type) == METHOD_TYPE)\n \t\tctype = TYPE_METHOD_BASETYPE (type);\n-              /* Any qualifiers on a function type typedef have\n-                 already been dealt with. */\n-              else if (TREE_CODE (type) == FUNCTION_TYPE)\n-                quals = TYPE_UNQUALIFIED;\n+\t      /* Any qualifiers on a function type typedef have\n+\t\t already been dealt with. */\n+\t      else if (TREE_CODE (type) == FUNCTION_TYPE)\n+\t\tquals = TYPE_UNQUALIFIED;\n \t    }\n \t  if (ctype != NULL_TREE)\n \t    grok_method_quals (ctype, decl, quals);\n@@ -7641,21 +7641,21 @@ grokdeclarator (const cp_declarator *declarator,\n       parms = nreverse (decls);\n \n       if (decl_context != TYPENAME)\n-        {\n-          /* A cv-qualifier-seq shall only be part of the function type\n-             for a non-static member function. [8.3.5/4 dcl.fct] */\n-          if (cp_type_quals (type) != TYPE_UNQUALIFIED\n-              && (current_class_type == NULL_TREE || staticp) )\n-            {\n-              error (\"qualified function types cannot be used to declare %s functions\",\n-                     (staticp? \"static member\" : \"free\"));\n-              type = TYPE_MAIN_VARIANT (type);\n-            }\n-\n-          /* The qualifiers on the function type become the qualifiers on\n-             the non-static member function. */\n-          quals |= cp_type_quals (type);\n-        }\n+\t{\n+\t  /* A cv-qualifier-seq shall only be part of the function type\n+\t     for a non-static member function. [8.3.5/4 dcl.fct] */\n+\t  if (cp_type_quals (type) != TYPE_UNQUALIFIED\n+\t      && (current_class_type == NULL_TREE || staticp) )\n+\t    {\n+\t      error (\"qualified function types cannot be used to declare %s functions\",\n+\t\t     (staticp? \"static member\" : \"free\"));\n+\t      type = TYPE_MAIN_VARIANT (type);\n+\t    }\n+\n+\t  /* The qualifiers on the function type become the qualifiers on\n+\t     the non-static member function. */\n+\t  quals |= cp_type_quals (type);\n+\t}\n     }\n \n   /* If this is a type name (such as, in a cast or sizeof),\n@@ -7688,11 +7688,11 @@ grokdeclarator (const cp_declarator *declarator,\n \t      if (TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n \t\tpedwarn (\"template parameters cannot be friends\");\n \t      else if (TREE_CODE (type) == TYPENAME_TYPE)\n-\t        pedwarn (\"friend declaration requires class-key, \"\n+\t\tpedwarn (\"friend declaration requires class-key, \"\n \t\t\t \"i.e. %<friend class %T::%D%>\",\n \t\t\t TYPE_CONTEXT (type), TYPENAME_TYPE_FULLNAME (type));\n \t      else\n-\t        pedwarn (\"friend declaration requires class-key, \"\n+\t\tpedwarn (\"friend declaration requires class-key, \"\n \t\t\t \"i.e. %<friend %#T%>\",\n \t\t\t type);\n \t    }\n@@ -7706,7 +7706,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t\t   /*complain=*/true);\n \t      else\n \t\terror (\"trying to make class %qT a friend of global scope\",\n-                       type);\n+\t\t       type);\n \n \t      type = void_type_node;\n \t    }\n@@ -7716,9 +7716,9 @@ grokdeclarator (const cp_declarator *declarator,\n \t  if (ctype == NULL_TREE)\n \t    {\n \t      if (TREE_CODE (type) != METHOD_TYPE)\n-\t        error (\"invalid qualifiers on non-member function type\");\n+\t\terror (\"invalid qualifiers on non-member function type\");\n \t      else\n-\t        ctype = TYPE_METHOD_BASETYPE (type);\n+\t\tctype = TYPE_METHOD_BASETYPE (type);\n \t    }\n \t  if (ctype)\n \t    {\n@@ -7839,7 +7839,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t    if (virtualp)\n \t\t      {\n \t\t\terror (\"%qD cannot be declared virtual, since it \"\n-                               \"is always static\",\n+\t\t\t       \"is always static\",\n \t\t\t       unqualified_id);\n \t\t\tvirtualp = 0;\n \t\t      }\n@@ -7944,7 +7944,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t&& declspecs->type\n \t\t&& declspecs->type == type)\n \t      error (\"  in instantiation of template %qT\",\n-                     current_class_type);\n+\t\t     current_class_type);\n \n \t    type = error_mark_node;\n \t    decl = NULL_TREE;\n@@ -7954,7 +7954,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t    if (friendp)\n \t      {\n \t\terror (\"%qE is neither function nor member function; \"\n-                       \"cannot be declared friend\", unqualified_id);\n+\t\t       \"cannot be declared friend\", unqualified_id);\n \t\tfriendp = 0;\n \t      }\n \t    decl = NULL_TREE;\n@@ -7965,7 +7965,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t    /* Friends are treated specially.  */\n \t    if (ctype == current_class_type)\n \t      warning (0, \"member functions are implicitly friends of their class\");\n- \t    else if (decl && DECL_NAME (decl))\n+\t    else if (decl && DECL_NAME (decl))\n \t      {\n \t\tif (template_class_depth (current_class_type) == 0)\n \t\t  {\n@@ -8080,10 +8080,10 @@ grokdeclarator (const cp_declarator *declarator,\n \t  {\n \t    if (storage_class == sc_static)\n \t      pedwarn (\"%<static%> specified invalid for function %qs \"\n-                       \"declared out of global scope\", name);\n+\t\t       \"declared out of global scope\", name);\n \t    else\n \t      pedwarn (\"%<inline%> specifier invalid for function %qs \"\n-                       \"declared out of global scope\", name);\n+\t\t       \"declared out of global scope\", name);\n \t  }\n \n \tif (ctype == NULL_TREE)\n@@ -8122,7 +8122,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t    if (TREE_CODE (type) == METHOD_TYPE)\n \t      {\n \t\tpedwarn (\"cannot declare member function %qD to have \"\n-                         \"static linkage\", decl);\n+\t\t\t \"static linkage\", decl);\n \t\tinvalid_static = 1;\n \t      }\n \t    else if (current_function_decl)\n@@ -8157,9 +8157,9 @@ grokdeclarator (const cp_declarator *declarator,\n \t    DECL_CONTEXT (decl) = ctype;\n \t    if (staticp == 1)\n \t      {\n-                pedwarn (\"%<static%> may not be used when defining \"\n-                         \"(as opposed to declaring) a static data member\");\n-\t        staticp = 0;\n+\t\tpedwarn (\"%<static%> may not be used when defining \"\n+\t\t\t \"(as opposed to declaring) a static data member\");\n+\t\tstaticp = 0;\n \t\tstorage_class = sc_none;\n \t      }\n \t    if (storage_class == sc_register && TREE_STATIC (decl))\n@@ -8169,9 +8169,9 @@ grokdeclarator (const cp_declarator *declarator,\n \t      }\n \t    if (storage_class == sc_extern && pedantic)\n \t      {\n-\t        pedwarn (\"cannot explicitly declare member %q#D to have \"\n-                         \"extern linkage\",\n-                         decl);\n+\t\tpedwarn (\"cannot explicitly declare member %q#D to have \"\n+\t\t\t \"extern linkage\",\n+\t\t\t decl);\n \t\tstorage_class = sc_none;\n \t      }\n \t  }\n@@ -8209,8 +8209,8 @@ require_complete_types_for_parms (tree parms)\n       if (dependent_type_p (TREE_TYPE (parms)))\n \tcontinue;\n       if (VOID_TYPE_P (TREE_TYPE (parms)))\n-        /* grokparms will have already issued an error.  */\n-        TREE_TYPE (parms) = error_mark_node;\n+\t/* grokparms will have already issued an error.  */\n+\tTREE_TYPE (parms) = error_mark_node;\n       else if (complete_type_or_else (TREE_TYPE (parms), parms))\n \t{\n \t  layout_decl (parms, 0);\n@@ -8313,10 +8313,10 @@ check_default_argument (tree decl, tree arg)\n     {\n       if (decl)\n \terror (\"default argument for %q#D has type %qT\",\n-               decl, TREE_TYPE (arg));\n+\t       decl, TREE_TYPE (arg));\n       else\n \terror (\"default argument for parameter of type %qT has type %qT\",\n-               decl_type, TREE_TYPE (arg));\n+\t       decl_type, TREE_TYPE (arg));\n \n       return error_mark_node;\n     }\n@@ -8366,32 +8366,32 @@ grokparms (cp_parameter_declarator *first_parm, tree *parms)\n       tree decl;\n \n       if (parm == no_parameters)\n-        break;\n+\tbreak;\n \n       attrs = parm->decl_specifiers.attributes;\n       parm->decl_specifiers.attributes = NULL_TREE;\n       decl = grokdeclarator (parm->declarator, &parm->decl_specifiers,\n \t\t\t     PARM, init != NULL_TREE, &attrs);\n       if (! decl || TREE_TYPE (decl) == error_mark_node)\n-        continue;\n+\tcontinue;\n \n       if (attrs)\n \tcplus_decl_attributes (&decl, attrs, 0);\n \n       type = TREE_TYPE (decl);\n       if (VOID_TYPE_P (type))\n-        {\n-          if (same_type_p (type, void_type_node)\n-              && !DECL_NAME (decl) && !result && !parm->next && !ellipsis)\n-            /* this is a parmlist of `(void)', which is ok.  */\n-            break;\n-          cxx_incomplete_type_error (decl, type);\n+\t{\n+\t  if (same_type_p (type, void_type_node)\n+\t      && !DECL_NAME (decl) && !result && !parm->next && !ellipsis)\n+\t    /* this is a parmlist of `(void)', which is ok.  */\n+\t    break;\n+\t  cxx_incomplete_type_error (decl, type);\n \t  /* It's not a good idea to actually create parameters of\n \t     type `void'; other parts of the compiler assume that a\n \t     void type terminates the parameter list.  */\n \t  type = error_mark_node;\n \t  TREE_TYPE (decl) = error_mark_node;\n-        }\n+\t}\n \n       if (type != error_mark_node)\n \t{\n@@ -8413,20 +8413,20 @@ grokparms (cp_parameter_declarator *first_parm, tree *parms)\n \t      tree t = TREE_TYPE (type);\n \t      int ptr = TYPE_PTR_P (type);\n \n-              while (1)\n-                {\n-                  if (TYPE_PTR_P (t))\n-                    ptr = 1;\n-                  else if (TREE_CODE (t) != ARRAY_TYPE)\n-                    break;\n-                  else if (!TYPE_DOMAIN (t))\n-\t            break;\n-\t          t = TREE_TYPE (t);\n-\t        }\n+\t      while (1)\n+\t\t{\n+\t\t  if (TYPE_PTR_P (t))\n+\t\t    ptr = 1;\n+\t\t  else if (TREE_CODE (t) != ARRAY_TYPE)\n+\t\t    break;\n+\t\t  else if (!TYPE_DOMAIN (t))\n+\t\t    break;\n+\t\t  t = TREE_TYPE (t);\n+\t\t}\n \t      if (TREE_CODE (t) == ARRAY_TYPE)\n \t\terror (\"parameter %qD includes %s to array of unknown \"\n-                       \"bound %qT\",\n-                       decl, ptr ? \"pointer\" : \"reference\", t);\n+\t\t       \"bound %qT\",\n+\t\t       decl, ptr ? \"pointer\" : \"reference\", t);\n \t    }\n \n \t  if (!any_error && init)\n@@ -8527,11 +8527,11 @@ void grok_special_member_properties (tree decl)\n \t{\n \t  /* [class.copy]\n \n-     \t     A non-template constructor for class X is a copy\n-     \t     constructor if its first parameter is of type X&, const\n-     \t     X&, volatile X& or const volatile X&, and either there\n-     \t     are no other parameters or else all other parameters have\n-     \t     default arguments.  */\n+\t     A non-template constructor for class X is a copy\n+\t     constructor if its first parameter is of type X&, const\n+\t     X&, volatile X& or const volatile X&, and either there\n+\t     are no other parameters or else all other parameters have\n+\t     default arguments.  */\n \t  TYPE_HAS_INIT_REF (DECL_CONTEXT (decl)) = 1;\n \t  if (ctor > 1)\n \t    TYPE_HAS_CONST_INIT_REF (DECL_CONTEXT (decl)) = 1;\n@@ -8543,9 +8543,9 @@ void grok_special_member_properties (tree decl)\n     {\n       /* [class.copy]\n \n-     \t A non-template assignment operator for class X is a copy\n-     \t assignment operator if its parameter is of type X, X&, const\n-     \t X&, volatile X& or const volatile X&.  */\n+\t A non-template assignment operator for class X is a copy\n+\t assignment operator if its parameter is of type X, X&, const\n+\t X&, volatile X& or const volatile X&.  */\n \n       int assop = copy_fn_p (decl);\n \n@@ -8570,19 +8570,19 @@ grok_ctor_properties (tree ctype, tree decl)\n     {\n       /* [class.copy]\n \n-     \t A declaration of a constructor for a class X is ill-formed if\n-     \t its first parameter is of type (optionally cv-qualified) X\n-     \t and either there are no other parameters or else all other\n-     \t parameters have default arguments.\n-\n-     \t We *don't* complain about member template instantiations that\n-     \t have this form, though; they can occur as we try to decide\n-     \t what constructor to use during overload resolution.  Since\n-     \t overload resolution will never prefer such a constructor to\n-     \t the non-template copy constructor (which is either explicitly\n-     \t or implicitly defined), there's no need to worry about their\n-     \t existence.  Theoretically, they should never even be\n-     \t instantiated, but that's hard to forestall.  */\n+\t A declaration of a constructor for a class X is ill-formed if\n+\t its first parameter is of type (optionally cv-qualified) X\n+\t and either there are no other parameters or else all other\n+\t parameters have default arguments.\n+\n+\t We *don't* complain about member template instantiations that\n+\t have this form, though; they can occur as we try to decide\n+\t what constructor to use during overload resolution.  Since\n+\t overload resolution will never prefer such a constructor to\n+\t the non-template copy constructor (which is either explicitly\n+\t or implicitly defined), there's no need to worry about their\n+\t existence.  Theoretically, they should never even be\n+\t instantiated, but that's hard to forestall.  */\n       error (\"invalid constructor; you probably meant %<%T (const %T&)%>\",\n \t\tctype, ctype);\n       return 0;\n@@ -8887,7 +8887,7 @@ grok_op_properties (tree decl, bool complain)\n \t\t      || !same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (ret)),\n \t\t\t\t       arg))\n \t\t    warning (0, \"prefix %qD should return %qT\", decl,\n-                             build_reference_type (arg));\n+\t\t\t     build_reference_type (arg));\n \t\t}\n \t      else\n \t\t{\n@@ -8922,7 +8922,7 @@ grok_op_properties (tree decl, bool complain)\n \t\t  || operator_code == TRUTH_ORIF_EXPR\n \t\t  || operator_code == COMPOUND_EXPR))\n \t    warning (0, \"user-defined %qD always evaluates both arguments\",\n-                     decl);\n+\t\t     decl);\n \t}\n \n       /* Effective C++ rule 23.  */\n@@ -8939,19 +8939,19 @@ grok_op_properties (tree decl, bool complain)\n \n       /* [over.oper]/8 */\n       for (; argtypes && argtypes != void_list_node;\n-          argtypes = TREE_CHAIN (argtypes))\n-        if (TREE_PURPOSE (argtypes))\n-          {\n-            TREE_PURPOSE (argtypes) = NULL_TREE;\n-            if (operator_code == POSTINCREMENT_EXPR\n+\t  argtypes = TREE_CHAIN (argtypes))\n+\tif (TREE_PURPOSE (argtypes))\n+\t  {\n+\t    TREE_PURPOSE (argtypes) = NULL_TREE;\n+\t    if (operator_code == POSTINCREMENT_EXPR\n \t\t|| operator_code == POSTDECREMENT_EXPR)\n-              {\n-                if (pedantic)\n-                  pedwarn (\"%qD cannot have default arguments\", decl);\n-              }\n-            else\n-              error (\"%qD cannot have default arguments\", decl);\n-          }\n+\t      {\n+\t\tif (pedantic)\n+\t\t  pedwarn (\"%qD cannot have default arguments\", decl);\n+\t      }\n+\t    else\n+\t      error (\"%qD cannot have default arguments\", decl);\n+\t  }\n \n     }\n \n@@ -9274,7 +9274,7 @@ xref_tag (enum tag_types tag_code, tree name,\n \t      DECL_ANTICIPATED (TYPE_TI_TEMPLATE (t)) = 0;\n \t      DECL_FRIEND_P (TYPE_TI_TEMPLATE (t)) = 0;\n \t    }\n-     \t}\n+\t}\n     }\n \n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n@@ -9763,7 +9763,7 @@ build_enumerator (tree name, tree value, tree enumtype)\n \t      bool overflowed;\n \n \t      /* The next value is the previous value plus one.  We can\n-\t         safely assume that the previous value is an INTEGER_CST.\n+\t\t safely assume that the previous value is an INTEGER_CST.\n \t\t add_double doesn't know the type of the target expression,\n \t\t so we must check with int_fits_type_p as well.  */\n \t      prev_value = DECL_INITIAL (TREE_VALUE (TYPE_VALUES (enumtype)));\n@@ -9981,7 +9981,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n       /* FIXME: Handle error_mark_node more gracefully.  */\n       tree newdecl1 = push_template_decl (decl1);\n       if (newdecl1 != error_mark_node)\n-        decl1 = newdecl1;\n+\tdecl1 = newdecl1;\n     }\n \n   /* We are now in the scope of the function being defined.  */\n@@ -10624,7 +10624,7 @@ finish_function (int flags)\n       gcc_assert (errorcount);\n \n       /* Throw away the broken statement tree and extra binding\n-         levels.  */\n+\t levels.  */\n       DECL_SAVED_TREE (fndecl) = alloc_stmt_list ();\n \n       while (current_binding_level->kind != sk_function_parms)\n@@ -10772,7 +10772,7 @@ finish_function (int flags)\n \n tree\n start_method (cp_decl_specifier_seq *declspecs,\n-              const cp_declarator *declarator, tree attrlist)\n+\t      const cp_declarator *declarator, tree attrlist)\n {\n   tree fndecl = grokdeclarator (declarator, declspecs, MEMFUNCDEF, 0,\n \t\t\t\t&attrlist);\n@@ -11075,7 +11075,7 @@ cp_tree_node_structure (union lang_tree_node * t)\n     case TEMPLATE_PARM_INDEX:\treturn TS_CP_TPI;\n     case TINST_LEVEL:\t\treturn TS_CP_TINST_LEVEL;\n     case PTRMEM_CST:\t\treturn TS_CP_PTRMEM;\n-    case BASELINK:              return TS_CP_BASELINK;\n+    case BASELINK:\t\treturn TS_CP_BASELINK;\n     default:\t\t\treturn TS_CP_GENERIC;\n     }\n }"}, {"sha": "1fe54a1a9157c1fe20278bf858163948649adabd", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -77,7 +77,7 @@ static tree start_static_initialization_or_destruction (tree, int);\n static void finish_static_initialization_or_destruction (tree);\n static void generate_ctor_or_dtor_function (bool, int, location_t *);\n static int generate_ctor_and_dtor_functions_for_priority (splay_tree_node,\n-                                                          void *);\n+\t\t\t\t\t\t\t  void *);\n static tree prune_vars_needing_no_initialization (tree *);\n static void write_out_vars (tree);\n static void import_export_class (tree);\n@@ -370,7 +370,7 @@ grok_array_decl (tree array_expr, tree index_exp)\n       else\n \t{\n \t  error (\"invalid types %<%T[%T]%> for array subscript\",\n-                 type, TREE_TYPE (index_exp));\n+\t\t type, TREE_TYPE (index_exp));\n \t  return error_mark_node;\n \t}\n \n@@ -419,7 +419,7 @@ delete_sanity (tree exp, tree size, bool doing_vec, int use_global_delete)\n   if (t == NULL_TREE || t == error_mark_node)\n     {\n       error (\"type %q#T argument given to %<delete%>, expected pointer\",\n-             TREE_TYPE (exp));\n+\t     TREE_TYPE (exp));\n       return error_mark_node;\n     }\n \n@@ -431,7 +431,7 @@ delete_sanity (tree exp, tree size, bool doing_vec, int use_global_delete)\n   if (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n     {\n       error (\"cannot delete a function.  Only pointer-to-objects are \"\n-             \"valid arguments to %<delete%>\");\n+\t     \"valid arguments to %<delete%>\");\n       return error_mark_node;\n     }\n \n@@ -475,7 +475,7 @@ check_member_template (tree tmpl)\n \n \t   A local class shall not have member templates.  */\n \terror (\"invalid declaration of member template %q#D in local class\",\n-               decl);\n+\t       decl);\n \n       if (TREE_CODE (decl) == FUNCTION_DECL && DECL_VIRTUAL_P (decl))\n \t{\n@@ -543,7 +543,7 @@ check_java_method (tree method)\n   if (!acceptable_java_type (ret_type))\n     {\n       error (\"Java method %qD has non-Java return type %qT\",\n-             method, ret_type);\n+\t     method, ret_type);\n       jerr = true;\n     }\n \n@@ -558,8 +558,8 @@ check_java_method (tree method)\n       tree type = TREE_VALUE (arg_types);\n       if (!acceptable_java_type (type))\n \t{\n-          error (\"Java method %qD has non-Java parameter type %qT\",\n-                 method, type);\n+\t  error (\"Java method %qD has non-Java parameter type %qT\",\n+\t\t method, type);\n \t  jerr = true;\n \t}\n     }\n@@ -590,8 +590,8 @@ check_classfn (tree ctype, tree function, tree template_parms)\n        we're not going to find the declaration in the class.\n        For example, in:\n \n-         struct S { template <typename T> void f(T); };\n-         template <> void S::f(int);\n+\t struct S { template <typename T> void f(T); };\n+\t template <> void S::f(int);\n \n        we're not going to find `S::f(int)', but there's no\n        reason we should, either.  We let our callers know we didn't\n@@ -743,7 +743,7 @@ note_vague_linkage_var (tree var)\n \n void\n finish_static_data_member_decl (tree decl, tree init, tree asmspec_tree,\n-                                int flags)\n+\t\t\t\tint flags)\n {\n   gcc_assert (TREE_PUBLIC (decl));\n \n@@ -770,7 +770,7 @@ finish_static_data_member_decl (tree decl, tree init, tree asmspec_tree,\n \n       error (\"initializer invalid for static member with constructor\");\n       if (!explained)\n-        {\n+\t{\n \t  error (\"(an out of class initialization is required)\");\n \t  explained = 1;\n \t}\n@@ -808,7 +808,7 @@ tree\n grokfield (const cp_declarator *declarator,\n \t   cp_decl_specifier_seq *declspecs,\n \t   tree init, tree asmspec_tree,\n-           tree attrlist)\n+\t   tree attrlist)\n {\n   tree value;\n   const char *asmspec = 0;\n@@ -853,7 +853,7 @@ grokfield (const cp_declarator *declarator,\n       && IDENTIFIER_POINTER (DECL_NAME (value))[0] == '_'\n       && ! strcmp (IDENTIFIER_POINTER (DECL_NAME (value)), \"_vptr\"))\n     error (\"member %qD conflicts with virtual function table field name\",\n-           value);\n+\t   value);\n \n   /* Stash away type declarations.  */\n   if (TREE_CODE (value) == TYPE_DECL)\n@@ -904,7 +904,7 @@ grokfield (const cp_declarator *declarator,\n       else\n \t{\n \t  /* We allow initializers to become parameters to base\n-             initializers.  */\n+\t     initializers.  */\n \t  if (TREE_CODE (init) == TREE_LIST)\n \t    {\n \t      if (TREE_CHAIN (init) == NULL_TREE)\n@@ -1021,7 +1021,7 @@ grokbitfield (const cp_declarator *declarator,\n   if (DECL_IN_AGGR_P (value))\n     {\n       error (\"%qD is already defined in the class %qT\", value,\n-             DECL_CONTEXT (value));\n+\t     DECL_CONTEXT (value));\n       return void_type_node;\n     }\n \n@@ -1086,7 +1086,7 @@ build_anon_union_vars (tree type, tree object)\n       if (TREE_CODE (field) != FIELD_DECL)\n \t{\n \t  cp_pedwarn_at (\"%q#D invalid; an anonymous union can only \"\n-                         \"have non-static data members\",\n+\t\t\t \"have non-static data members\",\n \t\t\t field);\n \t  continue;\n \t}\n@@ -1200,9 +1200,9 @@ coerce_new_type (tree type)\n     {\n       e = 2;\n       if (args && args != void_list_node)\n-        args = TREE_CHAIN (args);\n+\targs = TREE_CHAIN (args);\n       pedwarn (\"%<operator new%> takes type %<size_t%> (%qT) \"\n-               \"as first parameter\", size_type_node);\n+\t       \"as first parameter\", size_type_node);\n     }\n   switch (e)\n   {\n@@ -1211,8 +1211,8 @@ coerce_new_type (tree type)\n       /* Fall through.  */\n     case 1:\n       type = build_exception_variant\n-              (build_function_type (ptr_type_node, args),\n-               TYPE_RAISES_EXCEPTIONS (type));\n+\t      (build_function_type (ptr_type_node, args),\n+\t       TYPE_RAISES_EXCEPTIONS (type));\n       /* Fall through.  */\n     default:;\n   }\n@@ -1238,9 +1238,9 @@ coerce_delete_type (tree type)\n     {\n       e = 2;\n       if (args && args != void_list_node)\n-        args = TREE_CHAIN (args);\n+\targs = TREE_CHAIN (args);\n       error (\"%<operator delete%> takes type %qT as first parameter\",\n-             ptr_type_node);\n+\t     ptr_type_node);\n     }\n   switch (e)\n   {\n@@ -1249,8 +1249,8 @@ coerce_delete_type (tree type)\n       /* Fall through.  */\n     case 1:\n       type = build_exception_variant\n-              (build_function_type (void_type_node, args),\n-               TYPE_RAISES_EXCEPTIONS (type));\n+\t      (build_function_type (void_type_node, args),\n+\t       TYPE_RAISES_EXCEPTIONS (type));\n       /* Fall through.  */\n     default:;\n   }\n@@ -1983,7 +1983,7 @@ get_guard (tree decl)\n       DECL_COMMON (guard) = DECL_COMMON (decl);\n       DECL_ONE_ONLY (guard) = DECL_ONE_ONLY (decl);\n       if (TREE_PUBLIC (decl))\n-        DECL_WEAK (guard) = DECL_WEAK (decl);\n+\tDECL_WEAK (guard) = DECL_WEAK (decl);\n \n       DECL_ARTIFICIAL (guard) = 1;\n       DECL_IGNORED_P (guard) = 1;\n@@ -2813,9 +2813,9 @@ cp_finish_file (void)\n      These include:\n \n        o Template specializations that we have not yet instantiated,\n-         but which are needed.\n+\t but which are needed.\n        o Initialization and destruction for non-local objects with\n-         static storage duration.  (Local objects with static storage\n+\t static storage duration.  (Local objects with static storage\n \t duration are initialized when their scope is first entered,\n \t and are cleaned up via atexit.)\n        o Virtual function tables.\n@@ -2842,42 +2842,42 @@ cp_finish_file (void)\n       ggc_collect ();\n \n       /* Write out virtual tables as required.  Note that writing out\n-  \t the virtual table for a template class may cause the\n- \t instantiation of members of that class.  If we write out\n- \t vtables then we remove the class from our list so we don't\n- \t have to look at it again.  */\n+\t the virtual table for a template class may cause the\n+\t instantiation of members of that class.  If we write out\n+\t vtables then we remove the class from our list so we don't\n+\t have to look at it again.  */\n \n       while (keyed_classes != NULL_TREE\n- \t     && maybe_emit_vtables (TREE_VALUE (keyed_classes)))\n- \t{\n-  \t  reconsider = true;\n- \t  keyed_classes = TREE_CHAIN (keyed_classes);\n- \t}\n+\t     && maybe_emit_vtables (TREE_VALUE (keyed_classes)))\n+\t{\n+\t  reconsider = true;\n+\t  keyed_classes = TREE_CHAIN (keyed_classes);\n+\t}\n \n       t = keyed_classes;\n       if (t != NULL_TREE)\n- \t{\n- \t  tree next = TREE_CHAIN (t);\n-\n- \t  while (next)\n- \t    {\n- \t      if (maybe_emit_vtables (TREE_VALUE (next)))\n- \t\t{\n- \t\t  reconsider = true;\n- \t\t  TREE_CHAIN (t) = TREE_CHAIN (next);\n- \t\t}\n- \t      else\n- \t\tt = next;\n-\n- \t      next = TREE_CHAIN (t);\n- \t    }\n- \t}\n+\t{\n+\t  tree next = TREE_CHAIN (t);\n+\n+\t  while (next)\n+\t    {\n+\t      if (maybe_emit_vtables (TREE_VALUE (next)))\n+\t\t{\n+\t\t  reconsider = true;\n+\t\t  TREE_CHAIN (t) = TREE_CHAIN (next);\n+\t\t}\n+\t      else\n+\t\tt = next;\n+\n+\t      next = TREE_CHAIN (t);\n+\t    }\n+\t}\n \n       /* Write out needed type info variables.  We have to be careful\n- \t looping through unemitted decls, because emit_tinfo_decl may\n- \t cause other variables to be needed. New elements will be\n- \t appended, and we remove from the vector those that actually\n- \t get emitted.  */\n+\t looping through unemitted decls, because emit_tinfo_decl may\n+\t cause other variables to be needed. New elements will be\n+\t appended, and we remove from the vector those that actually\n+\t get emitted.  */\n       for (i = VEC_length (tree, unemitted_tinfo_decls);\n \t   VEC_iterate (tree, unemitted_tinfo_decls, --i, t);)\n \tif (emit_tinfo_decl (t))\n@@ -2967,8 +2967,8 @@ cp_finish_file (void)\n \t\t up with CURRENT_FUNCTION_DECL set.  */\n \t      push_to_top_level ();\n \t      /* The decl's location will mark where it was first\n-\t         needed.  Save that so synthesize method can indicate\n-\t         where it was needed from, in case of error  */\n+\t\t needed.  Save that so synthesize method can indicate\n+\t\t where it was needed from, in case of error  */\n \t      input_location = DECL_SOURCE_LOCATION (decl);\n \t      synthesize_method (decl);\n \t      pop_from_top_level ();\n@@ -3234,8 +3234,8 @@ mark_used (tree decl)\n \treturn;\n \n       /* Remember the current location for a function we will end up\n-         synthesizing.  Then we can inform the user where it was\n-         required in the case of error.  */\n+\t synthesizing.  Then we can inform the user where it was\n+\t required in the case of error.  */\n       if (DECL_ARTIFICIAL (decl) && DECL_NONSTATIC_MEMBER_FUNCTION_P (decl)\n \t  && !DECL_THUNK_P (decl))\n \tDECL_SOURCE_LOCATION (decl) = input_location;"}, {"sha": "81b6be7badfc0e87d06feb172532b066551632b8", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -91,63 +91,63 @@ dump_op (dump_info_p di, tree t)\n       break;\n     case PLUS_EXPR:\n       if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-        dump_string (di, \"plusassign\");\n+\tdump_string (di, \"plusassign\");\n       else\n-        dump_string(di, \"plus\");\n+\tdump_string(di, \"plus\");\n       break;\n     case MINUS_EXPR:\n       if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-        dump_string (di, \"minusassign\");\n+\tdump_string (di, \"minusassign\");\n       else\n-        dump_string(di, \"minus\");\n+\tdump_string(di, \"minus\");\n       break;\n     case MULT_EXPR:\n       if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-        dump_string (di, \"multassign\");\n+\tdump_string (di, \"multassign\");\n       else\n-        dump_string (di, \"mult\");\n+\tdump_string (di, \"mult\");\n       break;\n     case TRUNC_DIV_EXPR:\n       if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-        dump_string (di, \"divassign\");\n+\tdump_string (di, \"divassign\");\n       else\n-        dump_string (di, \"div\");\n+\tdump_string (di, \"div\");\n       break;\n     case TRUNC_MOD_EXPR:\n       if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-         dump_string (di, \"modassign\");\n+\t dump_string (di, \"modassign\");\n       else\n-        dump_string (di, \"mod\");\n+\tdump_string (di, \"mod\");\n       break;\n     case BIT_AND_EXPR:\n       if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-        dump_string (di, \"andassign\");\n+\tdump_string (di, \"andassign\");\n       else\n-        dump_string (di, \"and\");\n+\tdump_string (di, \"and\");\n       break;\n     case BIT_IOR_EXPR:\n       if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-        dump_string (di, \"orassign\");\n+\tdump_string (di, \"orassign\");\n       else\n-        dump_string (di, \"or\");\n+\tdump_string (di, \"or\");\n       break;\n     case BIT_XOR_EXPR:\n       if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-        dump_string (di, \"xorassign\");\n+\tdump_string (di, \"xorassign\");\n       else\n-        dump_string (di, \"xor\");\n+\tdump_string (di, \"xor\");\n       break;\n     case LSHIFT_EXPR:\n       if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-        dump_string (di, \"lshiftassign\");\n+\tdump_string (di, \"lshiftassign\");\n       else\n-        dump_string (di, \"lshift\");\n+\tdump_string (di, \"lshift\");\n       break;\n     case RSHIFT_EXPR:\n       if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-        dump_string (di, \"rshiftassign\");\n+\tdump_string (di, \"rshiftassign\");\n       else\n-        dump_string (di, \"rshift\");\n+\tdump_string (di, \"rshift\");\n       break;\n     case EQ_EXPR:\n       dump_string (di, \"eq\");\n@@ -196,7 +196,7 @@ dump_op (dump_info_p di, tree t)\n       break;\n     case NOP_EXPR:\n       if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-        dump_string (di, \"assign\");\n+\tdump_string (di, \"assign\");\n       break;\n     default:\n       break;\n@@ -263,7 +263,7 @@ cp_dump_tree (void* dump_info, tree t)\n \n       dump_child (\"vfld\", TYPE_VFIELD (t));\n       if (CLASSTYPE_TEMPLATE_SPECIALIZATION(t))\n-        dump_string(di, \"spec\");\n+\tdump_string(di, \"spec\");\n \n       if (!dump_flag (di, TDF_SLIM, t) && TYPE_BINFO (t))\n \t{\n@@ -285,32 +285,32 @@ cp_dump_tree (void* dump_info, tree t)\n     case FIELD_DECL:\n       dump_access (di, t);\n       if (DECL_MUTABLE_P (t))\n-        dump_string(di, \"mutable\");\n+\tdump_string(di, \"mutable\");\n       break;\n \n     case VAR_DECL:\n       if (TREE_CODE (CP_DECL_CONTEXT (t)) == RECORD_TYPE)\n-        dump_access (di, t);\n+\tdump_access (di, t);\n       if (TREE_STATIC (t) && !TREE_PUBLIC (t))\n-        dump_string (di, \"static\");\n+\tdump_string (di, \"static\");\n       break;\n \n     case FUNCTION_DECL:\n       if (!DECL_THUNK_P (t))\n \t{\n-          if (DECL_OVERLOADED_OPERATOR_P (t)) {\n+\t  if (DECL_OVERLOADED_OPERATOR_P (t)) {\n \t    dump_string (di, \"operator\");\n-            dump_op (di, t);\n-          }\n+\t    dump_op (di, t);\n+\t  }\n \t  if (DECL_FUNCTION_MEMBER_P (t))\n \t    {\n \t      dump_string (di, \"member\");\n \t      dump_access (di, t);\n \t    }\n-          if (DECL_PURE_VIRTUAL_P (t))\n-            dump_string (di, \"pure\");\n-          if (DECL_VIRTUAL_P (t))\n-            dump_string (di, \"virtual\");\n+\t  if (DECL_PURE_VIRTUAL_P (t))\n+\t    dump_string (di, \"pure\");\n+\t  if (DECL_VIRTUAL_P (t))\n+\t    dump_string (di, \"virtual\");\n \t  if (DECL_CONSTRUCTOR_P (t))\n \t    dump_string (di, \"constructor\");\n \t  if (DECL_DESTRUCTOR_P (t))"}, {"sha": "c247c97c61e7c35dfb754f5683bc29616b807847", "filename": "gcc/cp/error.c", "status": "modified", "additions": 197, "deletions": 197, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -81,7 +81,7 @@ static const char *function_category (tree);\n static void maybe_print_instantiation_context (diagnostic_context *);\n static void print_instantiation_full_context (diagnostic_context *);\n static void print_instantiation_partial_context (diagnostic_context *,\n-                                                 tree, location_t);\n+\t\t\t\t\t\t tree, location_t);\n static void cp_diagnostic_starter (diagnostic_context *, diagnostic_info *);\n static void cp_diagnostic_finalizer (diagnostic_context *, diagnostic_info *);\n static void cp_print_error_function (diagnostic_context *, diagnostic_info *);\n@@ -114,10 +114,10 @@ dump_scope (tree scope, int flags)\n   if (TREE_CODE (scope) == NAMESPACE_DECL)\n     {\n       if (scope != global_namespace)\n-        {\n-          dump_decl (scope, f);\n-          pp_cxx_colon_colon (cxx_pp);\n-        }\n+\t{\n+\t  dump_decl (scope, f);\n+\t  pp_cxx_colon_colon (cxx_pp);\n+\t}\n     }\n   else if (AGGREGATE_TYPE_P (scope))\n     {\n@@ -155,7 +155,7 @@ dump_template_argument_list (tree args, int flags)\n   for (i = 0; i< n; ++i)\n     {\n       if (need_comma)\n-        pp_separate_with_comma (cxx_pp);\n+\tpp_separate_with_comma (cxx_pp);\n       dump_template_argument (TREE_VEC_ELT (args, i), flags);\n       need_comma = 1;\n     }\n@@ -172,15 +172,15 @@ dump_template_parameter (tree parm, int flags)\n   if (TREE_CODE (p) == TYPE_DECL)\n     {\n       if (flags & TFF_DECL_SPECIFIERS)\n-        {\n-          pp_cxx_identifier (cxx_pp, \"class\");\n-          if (DECL_NAME (p))\n-            pp_cxx_tree_identifier (cxx_pp, DECL_NAME (p));\n-        }\n+\t{\n+\t  pp_cxx_identifier (cxx_pp, \"class\");\n+\t  if (DECL_NAME (p))\n+\t    pp_cxx_tree_identifier (cxx_pp, DECL_NAME (p));\n+\t}\n       else if (DECL_NAME (p))\n-        pp_cxx_tree_identifier (cxx_pp, DECL_NAME (p));\n+\tpp_cxx_tree_identifier (cxx_pp, DECL_NAME (p));\n       else\n-        pp_cxx_canonical_template_parameter (cxx_pp, TREE_TYPE (p));\n+\tpp_cxx_canonical_template_parameter (cxx_pp, TREE_TYPE (p));\n     }\n   else\n     dump_decl (p, flags | TFF_DECL_SPECIFIERS);\n@@ -191,9 +191,9 @@ dump_template_parameter (tree parm, int flags)\n       pp_equal (cxx_pp);\n       pp_cxx_whitespace (cxx_pp);\n       if (TREE_CODE (p) == TYPE_DECL || TREE_CODE (p) == TEMPLATE_DECL)\n-        dump_type (a, flags & ~TFF_CHASE_TYPEDEF);\n+\tdump_type (a, flags & ~TFF_CHASE_TYPEDEF);\n       else\n-        dump_expr (a, flags | TFF_EXPR_IN_PARENS);\n+\tdump_expr (a, flags | TFF_EXPR_IN_PARENS);\n     }\n }\n \n@@ -228,9 +228,9 @@ dump_template_bindings (tree parms, tree args)\n \t  if (need_comma)\n \t    pp_separate_with_comma (cxx_pp);\n \t  dump_template_parameter (TREE_VEC_ELT (p, i), TFF_PLAIN_IDENTIFIER);\n-          pp_cxx_whitespace (cxx_pp);\n-          pp_equal (cxx_pp);\n-          pp_cxx_whitespace (cxx_pp);\n+\t  pp_cxx_whitespace (cxx_pp);\n+\t  pp_equal (cxx_pp);\n+\t  pp_cxx_whitespace (cxx_pp);\n \t  if (arg)\n \t    dump_template_argument (arg, TFF_PLAIN_IDENTIFIER);\n \t  else\n@@ -283,11 +283,11 @@ dump_type (tree t, int flags)\n \n     case TYPE_DECL:\n       if (flags & TFF_CHASE_TYPEDEF)\n-        {\n-          dump_type (DECL_ORIGINAL_TYPE (t)\n-                     ? DECL_ORIGINAL_TYPE (t) : TREE_TYPE (t), flags);\n-          break;\n-        }\n+\t{\n+\t  dump_type (DECL_ORIGINAL_TYPE (t)\n+\t\t     ? DECL_ORIGINAL_TYPE (t) : TREE_TYPE (t), flags);\n+\t  break;\n+\t}\n       /* Else fall through.  */\n \n     case TEMPLATE_DECL:\n@@ -309,7 +309,7 @@ dump_type (tree t, int flags)\n       if (TYPE_IDENTIFIER (t))\n \tpp_cxx_tree_identifier (cxx_pp, TYPE_IDENTIFIER (t));\n       else\n-        pp_cxx_canonical_template_parameter (cxx_pp, t);\n+\tpp_cxx_canonical_template_parameter (cxx_pp, t);\n       break;\n \n     case BOUND_TEMPLATE_TEMPLATE_PARM:\n@@ -318,7 +318,7 @@ dump_type (tree t, int flags)\n \tpp_cxx_cv_qualifier_seq (cxx_pp, t);\n \tpp_cxx_tree_identifier (cxx_pp, TYPE_IDENTIFIER (t));\n \tpp_cxx_begin_template_argument_list (cxx_pp);\n-        dump_template_argument_list (args, flags);\n+\tdump_template_argument_list (args, flags);\n \tpp_cxx_end_template_argument_list (cxx_pp);\n       }\n       break;\n@@ -328,8 +328,8 @@ dump_type (tree t, int flags)\n       if (TYPE_IDENTIFIER (t))\n \tpp_cxx_tree_identifier (cxx_pp, TYPE_IDENTIFIER (t));\n       else\n-        pp_cxx_canonical_template_parameter\n-          (cxx_pp, TEMPLATE_TYPE_PARM_INDEX (t));\n+\tpp_cxx_canonical_template_parameter\n+\t  (cxx_pp, TEMPLATE_TYPE_PARM_INDEX (t));\n       break;\n \n       /* This is not always necessary for pointers and such, but doing this\n@@ -436,38 +436,38 @@ dump_aggr_type (tree t, int flags)\n     {\n       typdef = !DECL_ARTIFICIAL (name);\n       tmplate = !typdef && TREE_CODE (t) != ENUMERAL_TYPE\n-                && TYPE_LANG_SPECIFIC (t) && CLASSTYPE_TEMPLATE_INFO (t)\n-                && (CLASSTYPE_TEMPLATE_SPECIALIZATION (t)\n-                    || TREE_CODE (CLASSTYPE_TI_TEMPLATE (t)) != TEMPLATE_DECL\n-                    || DECL_TEMPLATE_SPECIALIZATION (CLASSTYPE_TI_TEMPLATE (t))\n-                    || PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (t)));\n+\t\t&& TYPE_LANG_SPECIFIC (t) && CLASSTYPE_TEMPLATE_INFO (t)\n+\t\t&& (CLASSTYPE_TEMPLATE_SPECIALIZATION (t)\n+\t\t    || TREE_CODE (CLASSTYPE_TI_TEMPLATE (t)) != TEMPLATE_DECL\n+\t\t    || DECL_TEMPLATE_SPECIALIZATION (CLASSTYPE_TI_TEMPLATE (t))\n+\t\t    || PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (t)));\n       dump_scope (CP_DECL_CONTEXT (name), flags | TFF_SCOPE);\n       if (tmplate)\n-        {\n-          /* Because the template names are mangled, we have to locate\n-             the most general template, and use that name.  */\n-          tree tpl = CLASSTYPE_TI_TEMPLATE (t);\n-\n-          while (DECL_TEMPLATE_INFO (tpl))\n-            tpl = DECL_TI_TEMPLATE (tpl);\n-          name = tpl;\n-        }\n+\t{\n+\t  /* Because the template names are mangled, we have to locate\n+\t     the most general template, and use that name.  */\n+\t  tree tpl = CLASSTYPE_TI_TEMPLATE (t);\n+\n+\t  while (DECL_TEMPLATE_INFO (tpl))\n+\t    tpl = DECL_TI_TEMPLATE (tpl);\n+\t  name = tpl;\n+\t}\n       name = DECL_NAME (name);\n     }\n \n   if (name == 0 || ANON_AGGRNAME_P (name))\n     {\n       if (flags & TFF_CLASS_KEY_OR_ENUM)\n-        pp_identifier (cxx_pp, \"<anonymous>\");\n+\tpp_identifier (cxx_pp, \"<anonymous>\");\n       else\n-        pp_printf (pp_base (cxx_pp), \"<anonymous %s>\", variety);\n+\tpp_printf (pp_base (cxx_pp), \"<anonymous %s>\", variety);\n     }\n   else\n     pp_cxx_tree_identifier (cxx_pp, name);\n   if (tmplate)\n     dump_template_parms (TYPE_TEMPLATE_INFO (t),\n-                         !CLASSTYPE_USE_TEMPLATE (t),\n-                         flags & ~TFF_TEMPLATE_HEADER);\n+\t\t\t !CLASSTYPE_USE_TEMPLATE (t),\n+\t\t\t flags & ~TFF_TEMPLATE_HEADER);\n }\n \n /* Dump into the obstack the initial part of the output for a given type.\n@@ -504,8 +504,8 @@ dump_type_prefix (tree t, int flags)\n \t    pp_cxx_left_paren (cxx_pp);\n \t  }\n \tpp_character (cxx_pp, \"&*\"[TREE_CODE (t) == POINTER_TYPE]);\n-        pp_base (cxx_pp)->padding = pp_before;\n-        pp_cxx_cv_qualifier_seq (cxx_pp, t);\n+\tpp_base (cxx_pp)->padding = pp_before;\n+\tpp_cxx_cv_qualifier_seq (cxx_pp, t);\n       }\n       break;\n \n@@ -514,9 +514,9 @@ dump_type_prefix (tree t, int flags)\n       dump_type_prefix (TREE_TYPE (t), flags);\n       if (TREE_CODE (t) == OFFSET_TYPE)\t/* pmfs deal with this in d_t_p */\n \t{\n-          pp_maybe_space (cxx_pp);\n-          if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n-             pp_cxx_left_paren (cxx_pp);\n+\t  pp_maybe_space (cxx_pp);\n+\t  if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n+\t     pp_cxx_left_paren (cxx_pp);\n \t  dump_type (TYPE_OFFSET_BASETYPE (t), flags);\n \t  pp_cxx_colon_colon (cxx_pp);\n \t}\n@@ -526,7 +526,7 @@ dump_type_prefix (tree t, int flags)\n       break;\n \n       /* Can only be reached through function pointer -- this would not be\n-         correct if FUNCTION_DECLs used it.  */\n+\t correct if FUNCTION_DECLs used it.  */\n     case FUNCTION_TYPE:\n       dump_type_prefix (TREE_TYPE (t), flags);\n       pp_maybe_space (cxx_pp);\n@@ -601,7 +601,7 @@ dump_type_suffix (tree t, int flags)\n     case METHOD_TYPE:\n       {\n \ttree arg;\n-        pp_cxx_right_paren (cxx_pp);\n+\tpp_cxx_right_paren (cxx_pp);\n \targ = TYPE_ARG_TYPES (t);\n \tif (TREE_CODE (t) == METHOD_TYPE)\n \t  arg = TREE_CHAIN (arg);\n@@ -611,10 +611,10 @@ dump_type_suffix (tree t, int flags)\n \tdump_parameters (arg, flags & ~TFF_FUNCTION_DEFAULT_ARGUMENTS);\n \n \tif (TREE_CODE (t) == METHOD_TYPE)\n-          pp_cxx_cv_qualifier_seq\n-            (cxx_pp, TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t))));\n-        else\n-          pp_cxx_cv_qualifier_seq(cxx_pp, t);\n+\t  pp_cxx_cv_qualifier_seq\n+\t    (cxx_pp, TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t))));\n+\telse\n+\t  pp_cxx_cv_qualifier_seq(cxx_pp, t);\n \tdump_exception_spec (TYPE_RAISES_EXCEPTIONS (t), flags);\n \tdump_type_suffix (TREE_TYPE (t), flags);\n \tbreak;\n@@ -627,15 +627,15 @@ dump_type_suffix (tree t, int flags)\n \t{\n \t  if (host_integerp (TYPE_MAX_VALUE (TYPE_DOMAIN (t)), 0))\n \t    pp_wide_integer\n-              (cxx_pp, tree_low_cst (TYPE_MAX_VALUE (TYPE_DOMAIN (t)), 0) + 1);\n+\t      (cxx_pp, tree_low_cst (TYPE_MAX_VALUE (TYPE_DOMAIN (t)), 0) + 1);\n \t  else if (TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (t))) == MINUS_EXPR)\n \t    dump_expr (TREE_OPERAND (TYPE_MAX_VALUE (TYPE_DOMAIN (t)), 0),\n-\t               flags & ~TFF_EXPR_IN_PARENS);\n+\t\t       flags & ~TFF_EXPR_IN_PARENS);\n \t  else\n \t    dump_expr (fold (cp_build_binary_op\n \t\t\t     (PLUS_EXPR, TYPE_MAX_VALUE (TYPE_DOMAIN (t)),\n \t\t\t      integer_one_node)),\n-\t               flags & ~TFF_EXPR_IN_PARENS);\n+\t\t       flags & ~TFF_EXPR_IN_PARENS);\n \t}\n       pp_cxx_right_bracket (cxx_pp);\n       dump_type_suffix (TREE_TYPE (t), flags);\n@@ -666,7 +666,7 @@ dump_type_suffix (tree t, int flags)\n       pp_unsupported_tree (cxx_pp, t);\n     case ERROR_MARK:\n       /* Don't mark it here, we should have already done in\n-         dump_type_prefix.  */\n+\t dump_type_prefix.  */\n       break;\n     }\n }\n@@ -730,7 +730,7 @@ dump_decl (tree t, int flags)\n \tpp_cxx_identifier (cxx_pp, \"typedef\");\n       dump_simple_decl (t, DECL_ORIGINAL_TYPE (t)\n \t\t\t? DECL_ORIGINAL_TYPE (t) : TREE_TYPE (t),\n-\t                flags);\n+\t\t\tflags);\n       break;\n \n     case VAR_DECL:\n@@ -755,15 +755,15 @@ dump_decl (tree t, int flags)\n \n     case NAMESPACE_DECL:\n       if (flags & TFF_DECL_SPECIFIERS)\n-        pp_cxx_declaration (cxx_pp, t);\n+\tpp_cxx_declaration (cxx_pp, t);\n       else\n-        {\n-          dump_scope (CP_DECL_CONTEXT (t), flags);\n-          if (DECL_NAME (t) == NULL_TREE)\n-            pp_identifier (cxx_pp, \"<unnamed>\");\n-          else\n-            pp_cxx_tree_identifier (cxx_pp, DECL_NAME (t));\n-        }\n+\t{\n+\t  dump_scope (CP_DECL_CONTEXT (t), flags);\n+\t  if (DECL_NAME (t) == NULL_TREE)\n+\t    pp_identifier (cxx_pp, \"<unnamed>\");\n+\t  else\n+\t    pp_cxx_tree_identifier (cxx_pp, DECL_NAME (t));\n+\t}\n       break;\n \n     case SCOPE_REF:\n@@ -786,7 +786,7 @@ dump_decl (tree t, int flags)\n \n     case BIT_NOT_EXPR:\n       /* This is a pseudo destructor call which has not been folded into\n-         a PSEUDO_DTOR_EXPR yet.  */\n+\t a PSEUDO_DTOR_EXPR yet.  */\n       pp_cxx_complement (cxx_pp);\n       dump_type (TREE_OPERAND (t, 0), flags);\n       break;\n@@ -816,12 +816,12 @@ dump_decl (tree t, int flags)\n \t  if (DECL_CLASS_SCOPE_P (t))\n \t    {\n \t      dump_type (DECL_CONTEXT (t), flags);\n-              pp_cxx_colon_colon (cxx_pp);\n+\t      pp_cxx_colon_colon (cxx_pp);\n \t    }\n \t  else if (DECL_CONTEXT (t))\n \t    {\n \t      dump_decl (DECL_CONTEXT (t), flags);\n-              pp_cxx_colon_colon (cxx_pp);\n+\t      pp_cxx_colon_colon (cxx_pp);\n \t    }\n \t  dump_decl (DECL_NAME (t), flags);\n \t  break;\n@@ -838,7 +838,7 @@ dump_decl (tree t, int flags)\n       else if (DECL_GLOBAL_CTOR_P (t) || DECL_GLOBAL_DTOR_P (t))\n \tdump_global_iord (t);\n       else\n-        dump_function_decl (t, flags);\n+\tdump_function_decl (t, flags);\n       break;\n \n     case TEMPLATE_DECL:\n@@ -893,9 +893,9 @@ dump_decl (tree t, int flags)\n \n     case TEMPLATE_TYPE_PARM:\n       if (flags & TFF_DECL_SPECIFIERS)\n-        pp_cxx_declaration (cxx_pp, t);\n+\tpp_cxx_declaration (cxx_pp, t);\n       else\n-        pp_type_id (cxx_pp, t);\n+\tpp_type_id (cxx_pp, t);\n       break;\n \n     default:\n@@ -921,28 +921,28 @@ dump_template_decl (tree t, int flags)\n   if (flags & TFF_TEMPLATE_HEADER)\n     {\n       for (parms = orig_parms = nreverse (orig_parms);\n-           parms;\n-           parms = TREE_CHAIN (parms))\n-        {\n+\t   parms;\n+\t   parms = TREE_CHAIN (parms))\n+\t{\n \t  tree inner_parms = INNERMOST_TEMPLATE_PARMS (parms);\n-          int len = TREE_VEC_LENGTH (inner_parms);\n+\t  int len = TREE_VEC_LENGTH (inner_parms);\n \n-          pp_cxx_identifier (cxx_pp, \"template\");\n-          pp_cxx_begin_template_argument_list (cxx_pp);\n+\t  pp_cxx_identifier (cxx_pp, \"template\");\n+\t  pp_cxx_begin_template_argument_list (cxx_pp);\n \n \t  /* If we've shown the template prefix, we'd better show the\n \t     parameters' and decl's type too.  */\n \t    flags |= TFF_DECL_SPECIFIERS;\n \n-          for (i = 0; i < len; i++)\n-            {\n-              if (i)\n-                pp_separate_with_comma (cxx_pp);\n-              dump_template_parameter (TREE_VEC_ELT (inner_parms, i), flags);\n-            }\n-          pp_cxx_end_template_argument_list (cxx_pp);\n-          pp_cxx_whitespace (cxx_pp);\n-        }\n+\t  for (i = 0; i < len; i++)\n+\t    {\n+\t      if (i)\n+\t\tpp_separate_with_comma (cxx_pp);\n+\t      dump_template_parameter (TREE_VEC_ELT (inner_parms, i), flags);\n+\t    }\n+\t  pp_cxx_end_template_argument_list (cxx_pp);\n+\t  pp_cxx_whitespace (cxx_pp);\n+\t}\n       nreverse(orig_parms);\n \n       if (DECL_TEMPLATE_TEMPLATE_PARM_P (t))\n@@ -952,8 +952,8 @@ dump_template_decl (tree t, int flags)\n \n   if (TREE_CODE (DECL_TEMPLATE_RESULT (t)) == TYPE_DECL)\n     dump_type (TREE_TYPE (t),\n-               ((flags & ~TFF_CLASS_KEY_OR_ENUM) | TFF_TEMPLATE_NAME\n-                | (flags & TFF_DECL_SPECIFIERS ? TFF_CLASS_KEY_OR_ENUM : 0)));\n+\t       ((flags & ~TFF_CLASS_KEY_OR_ENUM) | TFF_TEMPLATE_NAME\n+\t\t| (flags & TFF_DECL_SPECIFIERS ? TFF_CLASS_KEY_OR_ENUM : 0)));\n   else if (TREE_CODE (DECL_TEMPLATE_RESULT (t)) == VAR_DECL)\n     dump_decl (DECL_TEMPLATE_RESULT (t), flags | TFF_TEMPLATE_NAME);\n   else\n@@ -1026,7 +1026,7 @@ dump_function_decl (tree t, int flags)\n   /* Print the return type?  */\n   if (show_return)\n     show_return = !DECL_CONV_FN_P (t)  && !DECL_CONSTRUCTOR_P (t)\n-                  && !DECL_DESTRUCTOR_P (t);\n+\t\t  && !DECL_DESTRUCTOR_P (t);\n   if (show_return)\n     dump_type_prefix (TREE_TYPE (fntype), flags);\n \n@@ -1046,17 +1046,17 @@ dump_function_decl (tree t, int flags)\n       dump_parameters (parmtypes, flags);\n \n       if (TREE_CODE (fntype) == METHOD_TYPE)\n-        {\n-          pp_base (cxx_pp)->padding = pp_before;\n-          pp_cxx_cv_qualifier_seq\n-            (cxx_pp, TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (fntype))));\n-        }\n+\t{\n+\t  pp_base (cxx_pp)->padding = pp_before;\n+\t  pp_cxx_cv_qualifier_seq\n+\t    (cxx_pp, TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (fntype))));\n+\t}\n \n       if (flags & TFF_EXCEPTION_SPECIFICATION)\n-        {\n-          pp_base (cxx_pp)->padding = pp_before;\n-          dump_exception_spec (TYPE_RAISES_EXCEPTIONS (fntype), flags);\n-        }\n+\t{\n+\t  pp_base (cxx_pp)->padding = pp_before;\n+\t  dump_exception_spec (TYPE_RAISES_EXCEPTIONS (fntype), flags);\n+\t}\n \n       if (show_return)\n \tdump_type_suffix (TREE_TYPE (fntype), flags);\n@@ -1089,22 +1089,22 @@ dump_parameters (tree parmtypes, int flags)\n        parmtypes = TREE_CHAIN (parmtypes))\n     {\n       if (!first)\n-        pp_separate_with_comma (cxx_pp);\n+\tpp_separate_with_comma (cxx_pp);\n       first = 0;\n       if (!parmtypes)\n-        {\n-          pp_cxx_identifier (cxx_pp, \"...\");\n-          break;\n-        }\n+\t{\n+\t  pp_cxx_identifier (cxx_pp, \"...\");\n+\t  break;\n+\t}\n       dump_type (TREE_VALUE (parmtypes), flags);\n \n       if ((flags & TFF_FUNCTION_DEFAULT_ARGUMENTS) && TREE_PURPOSE (parmtypes))\n-        {\n-          pp_cxx_whitespace (cxx_pp);\n-          pp_equal (cxx_pp);\n-          pp_cxx_whitespace (cxx_pp);\n-          dump_expr (TREE_PURPOSE (parmtypes), flags | TFF_EXPR_IN_PARENS);\n-        }\n+\t{\n+\t  pp_cxx_whitespace (cxx_pp);\n+\t  pp_equal (cxx_pp);\n+\t  pp_cxx_whitespace (cxx_pp);\n+\t  dump_expr (TREE_PURPOSE (parmtypes), flags | TFF_EXPR_IN_PARENS);\n+\t}\n     }\n \n   pp_cxx_right_paren (cxx_pp);\n@@ -1121,14 +1121,14 @@ dump_exception_spec (tree t, int flags)\n       pp_cxx_whitespace (cxx_pp);\n       pp_cxx_left_paren (cxx_pp);\n       if (TREE_VALUE (t) != NULL_TREE)\n-        while (1)\n-          {\n-            dump_type (TREE_VALUE (t), flags);\n-            t = TREE_CHAIN (t);\n-            if (!t)\n-              break;\n-            pp_separate_with_comma (cxx_pp);\n-          }\n+\twhile (1)\n+\t  {\n+\t    dump_type (TREE_VALUE (t), flags);\n+\t    t = TREE_CHAIN (t);\n+\t    if (!t)\n+\t      break;\n+\t    pp_separate_with_comma (cxx_pp);\n+\t  }\n       pp_cxx_right_paren (cxx_pp);\n     }\n }\n@@ -1218,17 +1218,17 @@ dump_template_parms (tree info, int primary, int flags)\n       len = TREE_VEC_LENGTH (args);\n \n       for (ix = 0; ix != len; ix++)\n-        {\n-          tree arg = TREE_VEC_ELT (args, ix);\n+\t{\n+\t  tree arg = TREE_VEC_ELT (args, ix);\n \n-          if (ix)\n-            pp_separate_with_comma (cxx_pp);\n+\t  if (ix)\n+\t    pp_separate_with_comma (cxx_pp);\n \n-          if (!arg)\n-            pp_identifier (cxx_pp, \"<template parameter error>\");\n-          else\n-            dump_template_argument (arg, flags);\n-        }\n+\t  if (!arg)\n+\t    pp_identifier (cxx_pp, \"<template parameter error>\");\n+\t  else\n+\t    dump_template_argument (arg, flags);\n+\t}\n     }\n   else if (primary)\n     {\n@@ -1240,14 +1240,14 @@ dump_template_parms (tree info, int primary, int flags)\n       len = parms ? TREE_VEC_LENGTH (parms) : 0;\n \n       for (ix = 0; ix != len; ix++)\n-        {\n-          tree parm = TREE_VALUE (TREE_VEC_ELT (parms, ix));\n+\t{\n+\t  tree parm = TREE_VALUE (TREE_VEC_ELT (parms, ix));\n \n-          if (ix)\n-            pp_separate_with_comma (cxx_pp);\n+\t  if (ix)\n+\t    pp_separate_with_comma (cxx_pp);\n \n-          dump_decl (parm, flags & ~TFF_DECL_SPECIFIERS);\n-        }\n+\t  dump_decl (parm, flags & ~TFF_DECL_SPECIFIERS);\n+\t}\n     }\n   pp_cxx_end_template_argument_list (cxx_pp);\n }\n@@ -1335,11 +1335,11 @@ dump_expr (tree t, int flags)\n       if (TREE_HAS_CONSTRUCTOR (t))\n \t{\n \t  pp_cxx_identifier (cxx_pp, \"new\");\n-          pp_cxx_whitespace (cxx_pp);\n+\t  pp_cxx_whitespace (cxx_pp);\n \t  dump_type (TREE_TYPE (TREE_TYPE (t)), flags);\n \t}\n       else\n-        dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n+\tdump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n       break;\n \n     case AGGR_INIT_EXPR:\n@@ -1401,14 +1401,14 @@ dump_expr (tree t, int flags)\n \ttree type = TREE_OPERAND (t, 1);\n \ttree init = TREE_OPERAND (t, 2);\n \tif (NEW_EXPR_USE_GLOBAL (t))\n-          pp_cxx_colon_colon (cxx_pp);\n+\t  pp_cxx_colon_colon (cxx_pp);\n \tpp_cxx_identifier (cxx_pp, \"new\");\n \tif (TREE_OPERAND (t, 0))\n \t  {\n \t    pp_cxx_left_paren (cxx_pp);\n \t    dump_expr_list (TREE_OPERAND (t, 0), flags);\n-            pp_cxx_right_paren (cxx_pp);\n-            pp_cxx_whitespace (cxx_pp);\n+\t    pp_cxx_right_paren (cxx_pp);\n+\t    pp_cxx_whitespace (cxx_pp);\n \t  }\n \tif (TREE_CODE (type) == ARRAY_REF)\n \t  type = build_cplus_array_type\n@@ -1579,11 +1579,11 @@ dump_expr (tree t, int flags)\n \t  if (TREE_CODE (next) == FUNCTION_TYPE)\n \t    {\n \t      if (flags & TFF_EXPR_IN_PARENS)\n-\t        pp_cxx_left_paren (cxx_pp);\n+\t\tpp_cxx_left_paren (cxx_pp);\n \t      pp_cxx_star (cxx_pp);\n \t      dump_expr (TREE_OPERAND (t, 0), flags & ~TFF_EXPR_IN_PARENS);\n \t      if (flags & TFF_EXPR_IN_PARENS)\n-\t        pp_cxx_right_paren (cxx_pp);\n+\t\tpp_cxx_right_paren (cxx_pp);\n \t      break;\n \t    }\n \t  /* Else fall through.  */\n@@ -1622,12 +1622,12 @@ dump_expr (tree t, int flags)\n \t  if (integer_zerop (idx))\n \t    {\n \t      /* A NULL pointer-to-member constant.  */\n-              pp_cxx_left_paren (cxx_pp);\n-              pp_cxx_left_paren (cxx_pp);\n+\t      pp_cxx_left_paren (cxx_pp);\n+\t      pp_cxx_left_paren (cxx_pp);\n \t      dump_type (TREE_TYPE (t), flags);\n-              pp_cxx_right_paren (cxx_pp);\n-              pp_character (cxx_pp, '0');\n-              pp_cxx_right_paren (cxx_pp);\n+\t      pp_cxx_right_paren (cxx_pp);\n+\t      pp_character (cxx_pp, '0');\n+\t      pp_cxx_right_paren (cxx_pp);\n \t      break;\n \t    }\n \t  else if (host_integerp (idx, 0))\n@@ -1653,22 +1653,22 @@ dump_expr (tree t, int flags)\n \t      if (virtuals)\n \t\t{\n \t\t  dump_expr (BV_FN (virtuals),\n-\t                     flags | TFF_EXPR_IN_PARENS);\n+\t\t\t     flags | TFF_EXPR_IN_PARENS);\n \t\t  break;\n \t\t}\n \t    }\n \t}\n       if (TREE_TYPE (t) && !CONSTRUCTOR_ELTS (t))\n \t{\n \t  dump_type (TREE_TYPE (t), 0);\n-          pp_cxx_left_paren (cxx_pp);\n-          pp_cxx_right_paren (cxx_pp);\n+\t  pp_cxx_left_paren (cxx_pp);\n+\t  pp_cxx_right_paren (cxx_pp);\n \t}\n       else\n \t{\n-          pp_cxx_left_brace (cxx_pp);\n+\t  pp_cxx_left_brace (cxx_pp);\n \t  dump_expr_list (CONSTRUCTOR_ELTS (t), flags);\n-          pp_cxx_right_brace (cxx_pp);\n+\t  pp_cxx_right_brace (cxx_pp);\n \t}\n \n       break;\n@@ -1693,14 +1693,14 @@ dump_expr (tree t, int flags)\n \t    if (TREE_CODE (ob) == INDIRECT_REF)\n \t      {\n \t\tdump_expr (TREE_OPERAND (ob, 0), flags | TFF_EXPR_IN_PARENS);\n-                pp_cxx_arrow (cxx_pp);\n-                pp_cxx_star (cxx_pp);\n+\t\tpp_cxx_arrow (cxx_pp);\n+\t\tpp_cxx_star (cxx_pp);\n \t      }\n \t    else\n \t      {\n \t\tdump_expr (ob, flags | TFF_EXPR_IN_PARENS);\n-                pp_cxx_dot (cxx_pp);\n-                pp_cxx_star (cxx_pp);\n+\t\tpp_cxx_dot (cxx_pp);\n+\t\tpp_cxx_star (cxx_pp);\n \t      }\n \t    dump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n \t  }\n@@ -1728,8 +1728,8 @@ dump_expr (tree t, int flags)\n \t{\n \t  pp_cxx_left_paren (cxx_pp);\n \t  dump_type (TREE_TYPE (t), flags);\n-          pp_cxx_right_paren (cxx_pp);\n-          pp_cxx_left_paren (cxx_pp);\n+\t  pp_cxx_right_paren (cxx_pp);\n+\t  pp_cxx_left_paren (cxx_pp);\n \t  dump_expr_list (TREE_OPERAND (t, 0), flags);\n \t  pp_cxx_right_paren (cxx_pp);\n \t}\n@@ -1763,7 +1763,7 @@ dump_expr (tree t, int flags)\n     case SIZEOF_EXPR:\n     case ALIGNOF_EXPR:\n       if (TREE_CODE (t) == SIZEOF_EXPR)\n-        pp_cxx_identifier (cxx_pp, \"sizeof\");\n+\tpp_cxx_identifier (cxx_pp, \"sizeof\");\n       else\n \t{\n \t  gcc_assert (TREE_CODE (t) == ALIGNOF_EXPR);\n@@ -1774,7 +1774,7 @@ dump_expr (tree t, int flags)\n       if (TYPE_P (TREE_OPERAND (t, 0)))\n \tdump_type (TREE_OPERAND (t, 0), flags);\n       else\n-        dump_expr (TREE_OPERAND (t, 0), flags);\n+\tdump_expr (TREE_OPERAND (t, 0), flags);\n       pp_cxx_right_paren (cxx_pp);\n       break;\n \n@@ -2111,7 +2111,7 @@ cxx_print_error_function (diagnostic_context *context, const char *file)\n \n static void\n cp_diagnostic_starter (diagnostic_context *context,\n-                       diagnostic_info *diagnostic)\n+\t\t       diagnostic_info *diagnostic)\n {\n   diagnostic_report_current_module (context);\n   cp_print_error_function (context, diagnostic);\n@@ -2121,7 +2121,7 @@ cp_diagnostic_starter (diagnostic_context *context,\n \n static void\n cp_diagnostic_finalizer (diagnostic_context *context,\n-                         diagnostic_info *diagnostic ATTRIBUTE_UNUSED)\n+\t\t\t diagnostic_info *diagnostic ATTRIBUTE_UNUSED)\n {\n   pp_base_destroy_prefix (context->printer);\n }\n@@ -2130,7 +2130,7 @@ cp_diagnostic_finalizer (diagnostic_context *context,\n    a diagnostic message.  Called from cp_diagnostic_starter.  */\n static void\n cp_print_error_function (diagnostic_context *context,\n-                         diagnostic_info *diagnostic)\n+\t\t\t diagnostic_info *diagnostic)\n {\n   if (diagnostic_last_function_changed (context))\n     {\n@@ -2141,11 +2141,11 @@ cp_print_error_function (diagnostic_context *context,\n       pp_base_set_prefix (context->printer, new_prefix);\n \n       if (current_function_decl == NULL)\n-        pp_base_string (context->printer, \"At global scope:\");\n+\tpp_base_string (context->printer, \"At global scope:\");\n       else\n-        pp_printf (context->printer, \"In %s %qs:\",\n-                   function_category (current_function_decl),\n-                   cxx_printable_name (current_function_decl, 2));\n+\tpp_printf (context->printer, \"In %s %qs:\",\n+\t\t   function_category (current_function_decl),\n+\t\t   cxx_printable_name (current_function_decl, 2));\n       pp_base_newline (context->printer);\n \n       diagnostic_set_last_function (context);\n@@ -2161,15 +2161,15 @@ function_category (tree fn)\n   if (DECL_FUNCTION_MEMBER_P (fn))\n     {\n       if (DECL_STATIC_FUNCTION_P (fn))\n-        return \"static member function\";\n+\treturn \"static member function\";\n       else if (DECL_COPY_CONSTRUCTOR_P (fn))\n-        return \"copy constructor\";\n+\treturn \"copy constructor\";\n       else if (DECL_CONSTRUCTOR_P (fn))\n-        return \"constructor\";\n+\treturn \"constructor\";\n       else if (DECL_DESTRUCTOR_P (fn))\n-        return \"destructor\";\n+\treturn \"destructor\";\n       else\n-        return \"member function\";\n+\treturn \"member function\";\n     }\n   else\n     return \"function\";\n@@ -2197,10 +2197,10 @@ print_instantiation_full_context (diagnostic_context *context)\n \t    /* Avoid redundancy with the \"In function\" line.  */;\n \t  else\n \t    pp_verbatim (context->printer,\n-                         \"%s: In instantiation of %qs:\\n\",\n+\t\t\t \"%s: In instantiation of %qs:\\n\",\n \t\t\t LOCATION_FILE (location),\n-                         decl_as_string (TINST_DECL (p),\n-                                         TFF_DECL_SPECIFIERS | TFF_RETURN_TYPE));\n+\t\t\t decl_as_string (TINST_DECL (p),\n+\t\t\t\t\t TFF_DECL_SPECIFIERS | TFF_RETURN_TYPE));\n \n \t  location = TINST_LOCATION (p);\n \t  p = TREE_CHAIN (p);\n@@ -2213,7 +2213,7 @@ print_instantiation_full_context (diagnostic_context *context)\n /* Same as above but less verbose.  */\n static void\n print_instantiation_partial_context (diagnostic_context *context,\n-                                     tree t, location_t loc)\n+\t\t\t\t     tree t, location_t loc)\n {\n   expanded_location xloc;\n   for (; ; t = TREE_CHAIN (t))\n@@ -2222,13 +2222,13 @@ print_instantiation_partial_context (diagnostic_context *context,\n       if (t == NULL_TREE)\n \tbreak;\n       pp_verbatim (context->printer, \"%s:%d:   instantiated from %qs\\n\",\n-                   xloc.file, xloc.line,\n-                   decl_as_string (TINST_DECL (t),\n-                                   TFF_DECL_SPECIFIERS | TFF_RETURN_TYPE));\n+\t\t   xloc.file, xloc.line,\n+\t\t   decl_as_string (TINST_DECL (t),\n+\t\t\t\t   TFF_DECL_SPECIFIERS | TFF_RETURN_TYPE));\n       loc = TINST_LOCATION (t);\n     }\n   pp_verbatim (context->printer, \"%s:%d:   instantiated from here\\n\",\n-               xloc.file, xloc.line);\n+\t       xloc.file, xloc.line);\n }\n \n /* Called from cp_thing to print the template context for an error.  */\n@@ -2285,14 +2285,14 @@ cp_printer (pretty_printer *pp, text_info *text)\n   switch (*text->format_spec)\n     {\n     case 'A': result = args_to_string (next_tree, verbose);\tbreak;\n-    case 'C': result = code_to_string (next_tcode);\t        break;\n+    case 'C': result = code_to_string (next_tcode);\t\tbreak;\n     case 'D': result = decl_to_string (next_tree, verbose);\tbreak;\n-    case 'E': result = expr_to_string (next_tree);      \tbreak;\n+    case 'E': result = expr_to_string (next_tree);\t\tbreak;\n     case 'F': result = fndecl_to_string (next_tree, verbose);\tbreak;\n-    case 'L': result = language_to_string (next_lang);          break;\n-    case 'O': result = op_to_string (next_tcode);       \tbreak;\n-    case 'P': result = parm_to_string (next_int);\t        break;\n-    case 'Q': result = assop_to_string (next_tcode);\t        break;\n+    case 'L': result = language_to_string (next_lang);\t\tbreak;\n+    case 'O': result = op_to_string (next_tcode);\t\tbreak;\n+    case 'P': result = parm_to_string (next_int);\t\tbreak;\n+    case 'Q': result = assop_to_string (next_tcode);\t\tbreak;\n     case 'T': result = type_to_string (next_tree, verbose);\tbreak;\n     case 'V': result = cv_to_string (next_tree, verbose);\tbreak;\n \n@@ -2323,14 +2323,14 @@ locate_error (const char *gmsgid, va_list ap)\n       plus = 0;\n       if (*f == '%')\n \t{\n-          if (*++f == 'q')\n-            ++f;                /* ignore quoting flag.  */\n+\t  if (*++f == 'q')\n+\t    ++f;\t\t\t/* ignore quoting flag.  */\n \n \t  if (*f == '+')\n-            {\n-              ++f;\n-              plus = 1;\n-            }\n+\t    {\n+\t      ++f;\n+\t      plus = 1;\n+\t    }\n \t  if (*f == '#')\n \t    f++;\n \n@@ -2386,10 +2386,10 @@ cp_error_at (const char *gmsgid, ...)\n \n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap,\n-                       input_location, DK_ERROR);\n+\t\t       input_location, DK_ERROR);\n   cp_diagnostic_starter (global_dc, &diagnostic);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap,\n-                       location_of (here), DK_ERROR);\n+\t\t       location_of (here), DK_ERROR);\n   report_diagnostic (&diagnostic);\n   va_end (ap);\n }\n@@ -2407,7 +2407,7 @@ cp_warning_at (const char *gmsgid, ...)\n \n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap,\n-                       location_of (here), DK_WARNING);\n+\t\t       location_of (here), DK_WARNING);\n   report_diagnostic (&diagnostic);\n   va_end (ap);\n }\n@@ -2425,7 +2425,7 @@ cp_pedwarn_at (const char *gmsgid, ...)\n \n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap,\n-                       location_of (here), pedantic_error_kind());\n+\t\t       location_of (here), pedantic_error_kind());\n   report_diagnostic (&diagnostic);\n   va_end (ap);\n }"}, {"sha": "6f97312666db84e0dc04716e14cad050d2fc7e5c", "filename": "gcc/cp/except.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -260,7 +260,7 @@ decl_is_java_type (tree decl, int err)\n \t{\n \t  /* Can't throw a reference.  */\n \t  error (\"type %qT is disallowed in Java %<throw%> or %<catch%>\",\n-                 decl);\n+\t\t decl);\n \t}\n \n       if (r)\n@@ -278,7 +278,7 @@ decl_is_java_type (tree decl, int err)\n \t    {\n \t      /* Thrown object must be a Throwable.  */\n \t      error (\"type %qT is not derived from %<java::lang::Throwable%>\",\n-                     TREE_TYPE (decl));\n+\t\t     TREE_TYPE (decl));\n \t    }\n \t}\n     }\n@@ -557,7 +557,7 @@ do_free_exception (tree ptr)\n \n static tree\n wrap_cleanups_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n-                 void *data ATTRIBUTE_UNUSED)\n+\t\t void *data ATTRIBUTE_UNUSED)\n {\n   tree exp = *tp;\n   tree cleanup;\n@@ -604,7 +604,7 @@ build_throw (tree exp)\n   if (exp != NULL_TREE)\n     {\n       if (!is_admissible_throw_operand (exp))\n-        return error_mark_node;\n+\treturn error_mark_node;\n     }\n \n   if (! doing_eh (1))\n@@ -710,10 +710,10 @@ build_throw (tree exp)\n \t BUT: Issue 475 may do away with this inconsistency by removing the\n \t terminate() in this situation.\n \n-         Note that we don't check the return value from stabilize_init\n-         because it will only return false in cases where elided is true,\n-         and therefore we don't need to work around the failure to\n-         preevaluate.  */\n+\t Note that we don't check the return value from stabilize_init\n+\t because it will only return false in cases where elided is true,\n+\t and therefore we don't need to work around the failure to\n+\t preevaluate.  */\n       temp_expr = NULL_TREE;\n       stabilize_init (exp, &temp_expr);\n \n@@ -805,9 +805,9 @@ complete_ptr_ref_or_void_ptr_p (tree type, tree from)\n       tree core = TREE_TYPE (type);\n \n       if (is_ptr && VOID_TYPE_P (core))\n-        /* OK */;\n+\t/* OK */;\n       else if (!complete_type_or_else (core, from))\n-        return 0;\n+\treturn 0;\n     }\n   return 1;\n }\n@@ -822,22 +822,22 @@ is_admissible_throw_operand (tree expr)\n   tree type = TREE_TYPE (expr);\n \n   /* 15.1/4 [...] The type of the throw-expression shall not be an\n-            incomplete type, or a pointer or a reference to an incomplete\n-            type, other than void*, const void*, volatile void*, or\n-            const volatile void*.  Except for these restriction and the\n-            restrictions on type matching mentioned in 15.3, the operand\n-            of throw is treated exactly as a function argument in a call\n-            (5.2.2) or the operand of a return statement.  */\n+\t    incomplete type, or a pointer or a reference to an incomplete\n+\t    type, other than void*, const void*, volatile void*, or\n+\t    const volatile void*.  Except for these restriction and the\n+\t    restrictions on type matching mentioned in 15.3, the operand\n+\t    of throw is treated exactly as a function argument in a call\n+\t    (5.2.2) or the operand of a return statement.  */\n   if (!complete_ptr_ref_or_void_ptr_p (type, expr))\n     return false;\n \n   /* 10.4/3 An abstract class shall not be used as a parameter type,\n-            as a function return type or as type of an explicit\n-            conversion.  */\n+\t    as a function return type or as type of an explicit\n+\t    conversion.  */\n   else if (CLASS_TYPE_P (type) && CLASSTYPE_PURE_VIRTUALS (type))\n     {\n       error (\"expression %qE of abstract class type %qT cannot \"\n-             \"be used in throw-expression\", expr, type);\n+\t     \"be used in throw-expression\", expr, type);\n       return false;\n     }\n \n@@ -926,7 +926,7 @@ check_handlers_1 (tree master, tree_stmt_iterator i)\n \t  warning (0, \"%H   by earlier handler for %qT\",\n \t\t   EXPR_LOCUS (master), type);\n \t  break;\n-        }\n+\t}\n     }\n }\n \n@@ -946,7 +946,7 @@ check_handlers (tree handlers)\n   if (!tsi_end_p (i))\n     while (1)\n       {\n-        tree handler = tsi_stmt (i);\n+\ttree handler = tsi_stmt (i);\n \ttsi_next (&i);\n \n \t/* No more handlers; nothing to shadow.  */"}, {"sha": "5086f63fa0296a153f283ae51ac2ab3d12938db6", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -537,9 +537,9 @@ do_friend (tree ctype, tree declarator, tree decl,\n \t  else\n \t    {\n \t      /* We can't use pushdecl, as we might be in a template\n-\t         class specialization, and pushdecl will insert an\n-\t         unqualified friend decl into the template parameter\n-\t         scope, rather than the namespace containing it.  */\n+\t\t class specialization, and pushdecl will insert an\n+\t\t unqualified friend decl into the template parameter\n+\t\t scope, rather than the namespace containing it.  */\n \t      tree ns = decl_namespace_context (decl);\n \n \t      push_nested_namespace (ns);\n@@ -551,13 +551,13 @@ do_friend (tree ctype, tree declarator, tree decl,\n \t    {\n \t      static int explained;\n \t      warning (0, \"friend declaration %q#D declares a non-template \"\n-                       \"function\", decl);\n+\t\t       \"function\", decl);\n \t      if (! explained)\n \t\t{\n \t\t  warning (0, \"(if this is not what you intended, make sure \"\n-                           \"the function template has already been declared \"\n-                           \"and add <> after the function name here) \"\n-                           \"-Wno-non-template-friend disables this warning\");\n+\t\t\t   \"the function template has already been declared \"\n+\t\t\t   \"and add <> after the function name here) \"\n+\t\t\t   \"-Wno-non-template-friend disables this warning\");\n \t\t  explained = 1;\n \t\t}\n \t    }"}, {"sha": "1ceb9b29471d25c37b3596d0020055d1eeb49914", "filename": "gcc/cp/init.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -156,16 +156,16 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n      To zero-initialization storage for an object of type T means:\n \n      -- if T is a scalar type, the storage is set to the value of zero\n-        converted to T.\n+\tconverted to T.\n \n      -- if T is a non-union class type, the storage for each nonstatic\n-        data member and each base-class subobject is zero-initialized.\n+\tdata member and each base-class subobject is zero-initialized.\n \n      -- if T is a union type, the storage for its first data member is\n-        zero-initialized.\n+\tzero-initialized.\n \n      -- if T is an array type, the storage for each element is\n-        zero-initialized.\n+\tzero-initialized.\n \n      -- if T is a reference type, no initialization is performed.  */\n \n@@ -518,7 +518,7 @@ sort_mem_initializers (tree t, tree mem_inits)\n \n       /* Issue a warning if the explicit initializer order does not\n \t match that which will actually occur.\n-         ??? Are all these on the correct lines?  */\n+\t ??? Are all these on the correct lines?  */\n       if (warn_reorder && !subobject_init)\n \t{\n \t  if (TREE_CODE (TREE_PURPOSE (next_subobject)) == FIELD_DECL)\n@@ -1004,7 +1004,7 @@ expand_member_init (tree name)\n \n       /* [class.base.init]\n \n-         If a mem-initializer-id is ambiguous because it designates\n+\t If a mem-initializer-id is ambiguous because it designates\n \t both a direct non-virtual base class and an inherited virtual\n \t base class, the mem-initializer is ill-formed.  */\n       if (direct_binfo && virtual_binfo)\n@@ -1372,9 +1372,9 @@ build_offset_ref (tree type, tree name, bool address_p)\n     {\n       tree t = lookup_namespace_name (type, name);\n       if (t == error_mark_node)\n-        return t;\n+\treturn t;\n       if (TREE_CODE (orig_name) == TEMPLATE_ID_EXPR)\n-        /* Reconstruct the TEMPLATE_ID_EXPR.  */\n+\t/* Reconstruct the TEMPLATE_ID_EXPR.  */\n \tt = build2 (TEMPLATE_ID_EXPR, TREE_TYPE (t),\n \t\t    t, TREE_OPERAND (orig_name, 1));\n       if (! type_unknown_p (t))\n@@ -1462,11 +1462,11 @@ build_offset_ref (tree type, tree name, bool address_p)\n \t       expects to encounter OVERLOADs, not raw functions.  */\n \t    t = ovl_cons (t, NULL_TREE);\n \n-          t = build2 (TEMPLATE_ID_EXPR, TREE_TYPE (t), t,\n+\t  t = build2 (TEMPLATE_ID_EXPR, TREE_TYPE (t), t,\n \t\t      TREE_OPERAND (orig_name, 1));\n \t  t = build2 (OFFSET_REF, unknown_type_node, decl, t);\n \n-          PTRMEM_OK_P (t) = 1;\n+\t  PTRMEM_OK_P (t) = 1;\n \n \t  return t;\n \t}\n@@ -1588,13 +1588,13 @@ decl_constant_value (tree decl)\n   if ((TREE_CODE (decl) == CONST_DECL\n       || (TREE_CODE (decl) == VAR_DECL\n \t  /* And so are variables with a 'const' type -- unless they\n-             are also 'volatile'.  */\n+\t     are also 'volatile'.  */\n \t  && CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (decl))))\n       && DECL_INITIAL (decl)\n       && DECL_INITIAL (decl) != error_mark_node\n       /* This is invalid if initial value is not constant.  If it has\n-       \t either a function call, a memory reference, or a variable,\n-       \t then re-evaluating it could give different results.  */\n+\t either a function call, a memory reference, or a variable,\n+\t then re-evaluating it could give different results.  */\n       && TREE_CONSTANT (DECL_INITIAL (decl)))\n     return DECL_INITIAL (decl);\n \n@@ -2446,7 +2446,7 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n \t   ++t1;\n \t }\n        } catch (...) {\n-         ... destroy elements that were constructed ...\n+\t ... destroy elements that were constructed ...\n        }\n        rval;\n      })"}, {"sha": "dfa4ce3302f8dedd2608ada8bc7a2b72519bf57d", "filename": "gcc/cp/lang-specs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-specs.h?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -43,7 +43,7 @@ Boston, MA 02111-1307, USA.  */\n       cc1plus %{save-temps|no-integrated-cpp:-fpreprocessed %{save-temps:%b.ii} %{!save-temps:%g.ii}}\\\n \t      %{!save-temps:%{!no-integrated-cpp:%(cpp_unique_options)}}\\\n \t%(cc1_options) %2 %{+e1*}\\\n-        -o %g.s %{!o*:--output-pch=%i.gch} %W{o*:--output-pch=%*}%V}}}\",\n+\t-o %g.s %{!o*:--output-pch=%i.gch} %W{o*:--output-pch=%*}%V}}}\",\n      CPLUSPLUS_CPP_SPEC, 0, 0},\n   {\"@c++\",\n     \"%{E|M|MM:cc1plus -E %(cpp_options) %2 %(cpp_debug_options)}\\"}, {"sha": "92334ea809c6e9b3b80ea51d9be2ce5db26c0df9", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -117,7 +117,7 @@ init_operators (void)\n \t : &operator_name_info[(int) CODE]);\t\t\t\t    \\\n   oni->identifier = identifier;\t\t\t\t\t\t    \\\n   oni->name = NAME;\t\t\t\t\t\t\t    \\\n-  oni->mangled_name = MANGLING;                                             \\\n+  oni->mangled_name = MANGLING;\t\t\t\t\t\t    \\\n   oni->arity = ARITY;\n \n #include \"operators.def\"\n@@ -184,7 +184,7 @@ static const struct resword reswords[] =\n   { \"_Complex\",\t\tRID_COMPLEX,\t0 },\n   { \"__FUNCTION__\",\tRID_FUNCTION_NAME, 0 },\n   { \"__PRETTY_FUNCTION__\", RID_PRETTY_FUNCTION_NAME, 0 },\n-  { \"__alignof\", \tRID_ALIGNOF,\t0 },\n+  { \"__alignof\",\tRID_ALIGNOF,\t0 },\n   { \"__alignof__\",\tRID_ALIGNOF,\t0 },\n   { \"__asm\",\t\tRID_ASM,\t0 },\n   { \"__asm__\",\t\tRID_ASM,\t0 },\n@@ -277,7 +277,7 @@ static const struct resword reswords[] =\n   { \"virtual\",\t\tRID_VIRTUAL,\t0 },\n   { \"void\",\t\tRID_VOID,\t0 },\n   { \"volatile\",\t\tRID_VOLATILE,\t0 },\n-  { \"wchar_t\",          RID_WCHAR,\t0 },\n+  { \"wchar_t\",\t\tRID_WCHAR,\t0 },\n   { \"while\",\t\tRID_WHILE,\t0 },\n \n   /* The remaining keywords are specific to Objective-C++.  NB:\n@@ -553,7 +553,7 @@ handle_pragma_implementation (cpp_reader* dfile ATTRIBUTE_UNUSED )\n       filename = ggc_strdup (TREE_STRING_POINTER (fname));\n #if 0\n       /* We currently cannot give this diagnostic, as we reach this point\n-         only after cpplib has scanned the entire translation unit, so\n+\t only after cpplib has scanned the entire translation unit, so\n \t cpp_included always returns true.  A plausible fix is to compare\n \t the current source-location cookie with the first source-location\n \t cookie (if any) of the filename, but this requires completing the"}, {"sha": "f6448b094de8c3ec13a5b6e26320c8652bc0a841", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 112, "deletions": 112, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -39,12 +39,12 @@\n    particular constructs when the appropriate decl for that construct\n    is not available.  These are:\n \n-     mangle_typeinfo_for_type:        typeinfo data\n-     mangle_typeinfo_string_for_type: typeinfo type name\n-     mangle_vtbl_for_type:            virtual table data\n-     mangle_vtt_for_type:             VTT data\n-     mangle_ctor_vtbl_for_type:       `C-in-B' constructor virtual table data\n-     mangle_thunk:                    thunk function or entry\n+     mangle_typeinfo_for_type:\t\ttypeinfo data\n+     mangle_typeinfo_string_for_type:\ttypeinfo type name\n+     mangle_vtbl_for_type:\t\tvirtual table data\n+     mangle_vtt_for_type:\t\tVTT data\n+     mangle_ctor_vtbl_for_type:\t\t`C-in-B' constructor virtual table data\n+     mangle_thunk:\t\t\tthunk function or entry\n \n */\n \n@@ -75,7 +75,7 @@\n   fprintf (stderr, \"  %-24s: %-24s\\n\", (FN), (INPUT))\n # define MANGLE_TRACE_TREE(FN, NODE) \\\n   fprintf (stderr, \"  %-24s: %-24s (%p)\\n\", \\\n-           (FN), tree_code_name[TREE_CODE (NODE)], (void *) (NODE))\n+\t   (FN), tree_code_name[TREE_CODE (NODE)], (void *) (NODE))\n #else\n # define MANGLE_TRACE(FN, INPUT)\n # define MANGLE_TRACE_TREE(FN, NODE)\n@@ -234,32 +234,32 @@ static void write_java_integer_type_codes (const tree);\n \n /* Append a single character to the end of the mangled\n    representation.  */\n-#define write_char(CHAR)                                              \\\n+#define write_char(CHAR)\t\t\t\t\t\t\\\n   obstack_1grow (mangle_obstack, (CHAR))\n \n /* Append a sized buffer to the end of the mangled representation.  */\n-#define write_chars(CHAR, LEN)                                        \\\n+#define write_chars(CHAR, LEN)\t\t\t\t\t\t\\\n   obstack_grow (mangle_obstack, (CHAR), (LEN))\n \n /* Append a NUL-terminated string to the end of the mangled\n    representation.  */\n-#define write_string(STRING)                                          \\\n+#define write_string(STRING)\t\t\t\t\t\t\\\n   obstack_grow (mangle_obstack, (STRING), strlen (STRING))\n \n /* Nonzero if NODE1 and NODE2 are both TREE_LIST nodes and have the\n    same purpose (context, which may be a type) and value (template\n    decl).  See write_template_prefix for more information on what this\n    is used for.  */\n-#define NESTED_TEMPLATE_MATCH(NODE1, NODE2)                         \\\n-  (TREE_CODE (NODE1) == TREE_LIST                                     \\\n-   && TREE_CODE (NODE2) == TREE_LIST                                  \\\n-   && ((TYPE_P (TREE_PURPOSE (NODE1))                                 \\\n-        && same_type_p (TREE_PURPOSE (NODE1), TREE_PURPOSE (NODE2)))\\\n-       || TREE_PURPOSE (NODE1) == TREE_PURPOSE (NODE2))             \\\n+#define NESTED_TEMPLATE_MATCH(NODE1, NODE2)\t\t\t\t\\\n+  (TREE_CODE (NODE1) == TREE_LIST\t\t\t\t\t\\\n+   && TREE_CODE (NODE2) == TREE_LIST\t\t\t\t\t\\\n+   && ((TYPE_P (TREE_PURPOSE (NODE1))\t\t\t\t\t\\\n+\t&& same_type_p (TREE_PURPOSE (NODE1), TREE_PURPOSE (NODE2)))\t\\\n+       || TREE_PURPOSE (NODE1) == TREE_PURPOSE (NODE2))\t\t\t\\\n    && TREE_VALUE (NODE1) == TREE_VALUE (NODE2))\n \n /* Write out an unsigned quantity in base 10.  */\n-#define write_unsigned_number(NUMBER) \\\n+#define write_unsigned_number(NUMBER)\t\t\t\t\t\\\n   write_number ((NUMBER), /*unsigned_p=*/1, 10)\n \n /* Save the current (incomplete) mangled name and release the obstack\n@@ -497,27 +497,27 @@ is_std_substitution_char (const tree node,\n    First, check standard special-case substitutions.\n \n      <substitution> ::= St\n-         # ::std\n+\t # ::std\n \n-                    ::= Sa\n+\t\t    ::= Sa\n \t # ::std::allocator\n \n-                    ::= Sb\n-         # ::std::basic_string\n+\t\t    ::= Sb\n+\t # ::std::basic_string\n \n-                    ::= Ss\n-         # ::std::basic_string<char,\n+\t\t    ::= Ss\n+\t # ::std::basic_string<char,\n \t\t\t       ::std::char_traits<char>,\n \t\t\t       ::std::allocator<char> >\n \n-                    ::= Si\n-         # ::std::basic_istream<char, ::std::char_traits<char> >\n+\t\t    ::= Si\n+\t # ::std::basic_istream<char, ::std::char_traits<char> >\n \n-                    ::= So\n-         # ::std::basic_ostream<char, ::std::char_traits<char> >\n+\t\t    ::= So\n+\t # ::std::basic_ostream<char, ::std::char_traits<char> >\n \n-                    ::= Sd\n-         # ::std::basic_iostream<char, ::std::char_traits<char> >\n+\t\t    ::= Sd\n+\t # ::std::basic_iostream<char, ::std::char_traits<char> >\n \n    Then examine the stack of currently available substitution\n    candidates for entities appearing earlier in the same mangling\n@@ -562,8 +562,8 @@ find_substitution (tree node)\n \t{\n \t  /* If this is a type (i.e. a fully-qualified template-id),\n \t     check for\n-  \t         std::basic_string <char,\n-\t\t \t\t    std::char_traits<char>,\n+\t\t std::basic_string <char,\n+\t\t\t\t    std::char_traits<char>,\n \t\t\t\t    std::allocator<char> > .  */\n \t  if (cp_type_quals (type) == TYPE_UNQUALIFIED\n \t      && CLASSTYPE_USE_TEMPLATE (type))\n@@ -679,10 +679,10 @@ write_mangled_name (const tree decl, bool top_level)\n       else\n \t{\n \t  /* The standard notes: \"The <encoding> of an extern \"C\"\n-             function is treated like global-scope data, i.e. as its\n-             <source-name> without a type.\"  We cannot write\n-             overloaded operators that way though, because it contains\n-             characters invalid in assembler.  */\n+\t     function is treated like global-scope data, i.e. as its\n+\t     <source-name> without a type.\"  We cannot write\n+\t     overloaded operators that way though, because it contains\n+\t     characters invalid in assembler.  */\n \t  if (abi_version_at_least (2))\n \t    write_string (\"_Z\");\n \t  else\n@@ -771,7 +771,7 @@ write_encoding (const tree decl)\n }\n \n /* <name> ::= <unscoped-name>\n-          ::= <unscoped-template-name> <template-args>\n+\t  ::= <unscoped-template-name> <template-args>\n \t  ::= <nested-name>\n \t  ::= <local-name>\n \n@@ -823,10 +823,10 @@ write_name (tree decl, const int ignore_local_scope)\n   else\n     {\n       /* Handle local names, unless we asked not to (that is, invoked\n-         under <local-name>, to handle only the part of the name under\n-         the local scope).  */\n+\t under <local-name>, to handle only the part of the name under\n+\t the local scope).  */\n       if (!ignore_local_scope)\n-        {\n+\t{\n \t  /* Scan up the list of scope context, looking for a\n \t     function.  If we find one, this entity is in local\n \t     function scope.  local_entity tracks context one scope\n@@ -861,7 +861,7 @@ write_name (tree decl, const int ignore_local_scope)\n }\n \n /* <unscoped-name> ::= <unqualified-name>\n-                   ::= St <unqualified-name>   # ::std::  */\n+\t\t   ::= St <unqualified-name>   # ::std::  */\n \n static void\n write_unscoped_name (const tree decl)\n@@ -879,7 +879,7 @@ write_unscoped_name (const tree decl)\n   else\n     {\n       /* If not, it should be either in the global namespace, or directly\n-     \t in a local function scope.  */\n+\t in a local function scope.  */\n       gcc_assert (context == global_namespace\n \t\t  || context == NULL\n \t\t  || TREE_CODE (context) == FUNCTION_DECL);\n@@ -889,7 +889,7 @@ write_unscoped_name (const tree decl)\n }\n \n /* <unscoped-template-name> ::= <unscoped-name>\n-                            ::= <substitution>  */\n+\t\t\t    ::= <substitution>  */\n \n static void\n write_unscoped_template_name (const tree decl)\n@@ -905,7 +905,7 @@ write_unscoped_template_name (const tree decl)\n /* Write the nested name, including CV-qualifiers, of DECL.\n \n    <nested-name> ::= N [<CV-qualifiers>] <prefix> <unqualified-name> E\n-                 ::= N [<CV-qualifiers>] <template-prefix> <template-args> E\n+\t\t ::= N [<CV-qualifiers>] <template-prefix> <template-args> E\n \n    <CV-qualifiers> ::= [r] [V] [K]  */\n \n@@ -945,8 +945,8 @@ write_nested_name (const tree decl)\n }\n \n /* <prefix> ::= <prefix> <unqualified-name>\n-            ::= <template-param>\n-            ::= <template-prefix> <template-args>\n+\t    ::= <template-param>\n+\t    ::= <template-prefix> <template-args>\n \t    ::= # empty\n \t    ::= <substitution>  */\n \n@@ -1012,8 +1012,8 @@ write_prefix (const tree node)\n }\n \n /* <template-prefix> ::= <prefix> <template component>\n-                     ::= <template-param>\n-                     ::= <substitution>  */\n+\t\t     ::= <template-param>\n+\t\t     ::= <substitution>  */\n \n static void\n write_template_prefix (const tree node)\n@@ -1105,7 +1105,7 @@ write_unqualified_name (const tree decl)\n   else if (DECL_CONV_FN_P (decl))\n     {\n       /* Conversion operator. Handle it right here.\n-           <operator> ::= cv <type>  */\n+\t   <operator> ::= cv <type>  */\n       tree type;\n       if (decl_is_template_id (decl, NULL))\n \t{\n@@ -1296,11 +1296,11 @@ write_integer_cst (const tree cst)\n     for floating point numbers.  (Spaces are for readability, not\n     part of the encoding.)\n \n-        1.0f                    Lf 3f80 0000 E\n-       -1.0f                    Lf bf80 0000 E\n-        1.17549435e-38f         Lf 0080 0000 E\n-        1.40129846e-45f         Lf 0000 0001 E\n-        0.0f                    Lf 0000 0000 E\"\n+\t1.0f\t\t\tLf 3f80 0000 E\n+       -1.0f\t\t\tLf bf80 0000 E\n+\t1.17549435e-38f\t\tLf 0080 0000 E\n+\t1.40129846e-45f\t\tLf 0000 0001 E\n+\t0.0f\t\t\tLf 0000 0000 E\"\n \n    Caller is responsible for the Lx and the E.  */\n static void\n@@ -1319,7 +1319,7 @@ write_real_cst (const tree value)\n \t\t      TYPE_MODE (type));\n \n       /* The value in target_real is in the target word order,\n-         so we must write it out backward if that happens to be\n+\t so we must write it out backward if that happens to be\n \t little-endian.  write_number cannot be used, it will\n \t produce uppercase.  */\n       if (FLOAT_WORDS_BIG_ENDIAN)\n@@ -1363,8 +1363,8 @@ write_identifier (const char *identifier)\n    CTOR is a constructor FUNCTION_DECL.\n \n      <special-name> ::= C1   # complete object constructor\n-                    ::= C2   # base object constructor\n-                    ::= C3   # complete object allocating constructor\n+\t\t    ::= C2   # base object constructor\n+\t\t    ::= C3   # complete object allocating constructor\n \n    Currently, allocating constructors are never used.\n \n@@ -1393,8 +1393,8 @@ write_special_name_constructor (const tree ctor)\n    DTOR is a destructor FUNCTION_DECL.\n \n      <special-name> ::= D0 # deleting (in-charge) destructor\n-                    ::= D1 # complete object (in-charge) destructor\n-                    ::= D2 # base object (not-in-charge) destructor\n+\t\t    ::= D1 # complete object (in-charge) destructor\n+\t\t    ::= D2 # base object (not-in-charge) destructor\n \n    We also need to provide mangled names for the maybe-incharge\n    destructor, so we treat it here too.  mangle_decl_string will\n@@ -1411,9 +1411,9 @@ write_special_name_destructor (const tree dtor)\n     {\n       gcc_assert (DECL_COMPLETE_DESTRUCTOR_P (dtor)\n \t\t  /* Even though we don't ever emit a definition of\n-\t      \t     the old-style destructor, we still have to\n-\t      \t     consider entities (like static variables) nested\n-\t      \t     inside it.  */\n+\t\t     the old-style destructor, we still have to\n+\t\t     consider entities (like static variables) nested\n+\t\t     inside it.  */\n \t\t  || DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (dtor));\n       write_string (\"D1\");\n     }\n@@ -1487,7 +1487,7 @@ write_discriminator (const int discriminator)\n    of ENTITY.\n \n      <local-name> := Z <function encoding> E <entity name> [<discriminator>]\n-                  := Z <function encoding> E s [<discriminator>]  */\n+\t\t  := Z <function encoding> E s [<discriminator>]  */\n \n static void\n write_local_name (const tree function, const tree local_entity,\n@@ -1517,18 +1517,18 @@ write_local_name (const tree function, const tree local_entity,\n /* Non-terminals <type> and <CV-qualifier>.\n \n      <type> ::= <builtin-type>\n-            ::= <function-type>\n-            ::= <class-enum-type>\n-            ::= <array-type>\n-            ::= <pointer-to-member-type>\n-            ::= <template-param>\n-            ::= <substitution>\n-            ::= <CV-qualifier>\n-            ::= P <type>    # pointer-to\n-            ::= R <type>    # reference-to\n-            ::= C <type>    # complex pair (C 2000)\n-            ::= G <type>    # imaginary (C 2000)     [not supported]\n-            ::= U <source-name> <type>   # vendor extended type qualifier\n+\t    ::= <function-type>\n+\t    ::= <class-enum-type>\n+\t    ::= <array-type>\n+\t    ::= <pointer-to-member-type>\n+\t    ::= <template-param>\n+\t    ::= <substitution>\n+\t    ::= <CV-qualifier>\n+\t    ::= P <type>    # pointer-to\n+\t    ::= R <type>    # reference-to\n+\t    ::= C <type>    # complex pair (C 2000)\n+\t    ::= G <type>    # imaginary (C 2000)     [not supported]\n+\t    ::= U <source-name> <type>   # vendor extended type qualifier\n \n    TYPE is a type node.  */\n \n@@ -1700,26 +1700,26 @@ write_CV_qualifiers_for_type (const tree type)\n /* Non-terminal <builtin-type>.\n \n      <builtin-type> ::= v   # void\n-                    ::= b   # bool\n-                    ::= w   # wchar_t\n-                    ::= c   # char\n-                    ::= a   # signed char\n-                    ::= h   # unsigned char\n-                    ::= s   # short\n-                    ::= t   # unsigned short\n-                    ::= i   # int\n-                    ::= j   # unsigned int\n-                    ::= l   # long\n-                    ::= m   # unsigned long\n-                    ::= x   # long long, __int64\n-                    ::= y   # unsigned long long, __int64\n-                    ::= n   # __int128\n-                    ::= o   # unsigned __int128\n-                    ::= f   # float\n-                    ::= d   # double\n-                    ::= e   # long double, __float80\n-                    ::= g   # __float128          [not supported]\n-                    ::= u <source-name>  # vendor extended type */\n+\t\t    ::= b   # bool\n+\t\t    ::= w   # wchar_t\n+\t\t    ::= c   # char\n+\t\t    ::= a   # signed char\n+\t\t    ::= h   # unsigned char\n+\t\t    ::= s   # short\n+\t\t    ::= t   # unsigned short\n+\t\t    ::= i   # int\n+\t\t    ::= j   # unsigned int\n+\t\t    ::= l   # long\n+\t\t    ::= m   # unsigned long\n+\t\t    ::= x   # long long, __int64\n+\t\t    ::= y   # unsigned long long, __int64\n+\t\t    ::= n   # __int128\n+\t\t    ::= o   # unsigned __int128\n+\t\t    ::= f   # float\n+\t\t    ::= d   # double\n+\t\t    ::= e   # long double, __float80\n+\t\t    ::= g   # __float128          [not supported]\n+\t\t    ::= u <source-name>  # vendor extended type */\n \n static void\n write_builtin_type (tree type)\n@@ -1843,7 +1843,7 @@ write_function_type (const tree type)\n \n        extern \"C\" typedef void function_t();\n        function_t f; // f has C++ linkage, but its type is\n-                     // `extern \"C\"'\n+\t\t     // `extern \"C\"'\n \n        typedef void function_t();\n        extern \"C\" function_t f; // Vice versa.\n@@ -1982,10 +1982,10 @@ write_template_args (tree args)\n \t\t::= <expr-primary>\n \n    <expr-primary> ::= <template-param>\n-\t\t  ::= L <type> <value number> E  # literal\n-\t\t  ::= L <mangled-name> E         # external name\n-                  ::= sr <type> <unqualified-name>\n-                  ::= sr <type> <unqualified-name> <template-args> */\n+\t\t  ::= L <type> <value number> E\t\t# literal\n+\t\t  ::= L <mangled-name> E\t\t# external name\n+\t\t  ::= sr <type> <unqualified-name>\n+\t\t  ::= sr <type> <unqualified-name> <template-args> */\n \n static void\n write_expression (tree expr)\n@@ -2135,9 +2135,9 @@ write_expression (tree expr)\n \n       switch (code)\n \t{\n-        case CALL_EXPR:\n-          sorry (\"call_expr cannot be mangled due to a defect in the C++ ABI\");\n-          break;\n+\tcase CALL_EXPR:\n+\t  sorry (\"call_expr cannot be mangled due to a defect in the C++ ABI\");\n+\t  break;\n \n \tcase CAST_EXPR:\n \t  write_type (TREE_TYPE (expr));\n@@ -2242,10 +2242,10 @@ write_template_arg_literal (const tree value)\n \n /* Non-terminal <template-arg>.\n \n-     <template-arg> ::= <type>                        # type\n-                    ::= L <type> </value/ number> E   # literal\n-                    ::= LZ <name> E                   # external name\n-                    ::= X <expression> E              # expression  */\n+     <template-arg> ::= <type>\t\t\t\t# type\n+\t\t    ::= L <type> </value/ number> E\t# literal\n+\t\t    ::= LZ <name> E\t\t\t# external name\n+\t\t    ::= X <expression> E\t\t# expression  */\n \n static void\n write_template_arg (tree node)\n@@ -2335,7 +2335,7 @@ write_template_template_arg (const tree decl)\n /* Non-terminal <array-type>.  TYPE is an ARRAY_TYPE.\n \n      <array-type> ::= A [</dimension/ number>] _ </element/ type>\n-                  ::= A <expression> _ </element/ type>\n+\t\t  ::= A <expression> _ </element/ type>\n \n      \"Array types encode the dimension (number of elements) and the\n      element type. For variable length arrays, the dimension (but not\n@@ -2367,7 +2367,7 @@ write_array_type (const tree type)\n \t  if (!abi_version_at_least (2))\n \t    {\n \t      /* value_dependent_expression_p presumes nothing is\n-\t         dependent when PROCESSING_TEMPLATE_DECL is zero.  */\n+\t\t dependent when PROCESSING_TEMPLATE_DECL is zero.  */\n \t      ++processing_template_decl;\n \t      if (!value_dependent_expression_p (max))\n \t\tG.need_abi_warning = 1;\n@@ -2437,7 +2437,7 @@ write_template_param (const tree parm)\n }\n \n /*  <template-template-param>\n-                        ::= <template-param>\n+\t\t\t::= <template-param>\n \t\t\t::= <substitution>  */\n \n static void\n@@ -2466,7 +2466,7 @@ write_template_template_param (const tree parm)\n /* Non-terminal <substitution>.\n \n       <substitution> ::= S <seq-id> _\n-                     ::= S_  */\n+\t\t     ::= S_  */\n \n static void\n write_substitution (const int seq_id)\n@@ -2718,8 +2718,8 @@ mangle_call_offset (const tree fixed_offset, const tree virtual_offset)\n    for the this pointer, even if there is none.\n \n    <special-name> ::= T <call-offset> <base encoding>\n-                  ::= Tc <this_adjust call-offset> <result_adjust call-offset>\n-\t\t  \t\t\t<base encoding>\n+\t\t  ::= Tc <this_adjust call-offset> <result_adjust call-offset>\n+\t\t\t\t\t<base encoding>\n */\n \n tree"}, {"sha": "2f5e1f67e810785324214447fbbba998a1060a07", "filename": "gcc/cp/method.c", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -99,9 +99,9 @@ make_thunk (tree function, bool this_adjusting,\n   if (this_adjusting && virtual_offset)\n     virtual_offset\n       = size_binop (MULT_EXPR,\n- \t\t    virtual_offset,\n-  \t\t    convert (ssizetype,\n-  \t\t\t     TYPE_SIZE_UNIT (vtable_entry_type)));\n+\t\t    virtual_offset,\n+\t\t    convert (ssizetype,\n+\t\t\t     TYPE_SIZE_UNIT (vtable_entry_type)));\n \n   d = tree_low_cst (fixed_offset, 0);\n \n@@ -688,14 +688,14 @@ do_build_assign_ref (tree fndecl)\n \n \t  if (CP_TYPE_CONST_P (expr_type))\n \t    {\n-              error (\"non-static const member %q#D, can't use default \"\n-                     \"assignment operator\", field);\n+\t      error (\"non-static const member %q#D, can't use default \"\n+\t\t     \"assignment operator\", field);\n \t      continue;\n \t    }\n \t  else if (TREE_CODE (expr_type) == REFERENCE_TYPE)\n \t    {\n \t      error (\"non-static reference member %q#D, can't use \"\n-                     \"default assignment operator\", field);\n+\t\t     \"default assignment operator\", field);\n \t      continue;\n \t    }\n \n@@ -818,7 +818,7 @@ synthesize_method (tree fndecl)\n \n static tree\n synthesize_exception_spec (tree type, tree (*extractor) (tree, void*),\n-                           void *client)\n+\t\t\t   void *client)\n {\n   tree raises = empty_except_spec;\n   tree fields = TYPE_FIELDS (type);\n@@ -830,31 +830,31 @@ synthesize_exception_spec (tree type, tree (*extractor) (tree, void*),\n     {\n       tree fn = (*extractor) (BINFO_TYPE (base_binfo), client);\n       if (fn)\n-        {\n-          tree fn_raises = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn));\n+\t{\n+\t  tree fn_raises = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn));\n \n-          raises = merge_exception_specifiers (raises, fn_raises);\n-        }\n+\t  raises = merge_exception_specifiers (raises, fn_raises);\n+\t}\n     }\n   for (; fields; fields = TREE_CHAIN (fields))\n     {\n       tree type = TREE_TYPE (fields);\n       tree fn;\n \n       if (TREE_CODE (fields) != FIELD_DECL || DECL_ARTIFICIAL (fields))\n-        continue;\n+\tcontinue;\n       while (TREE_CODE (type) == ARRAY_TYPE)\n-  \ttype = TREE_TYPE (type);\n+\ttype = TREE_TYPE (type);\n       if (TREE_CODE (type) != RECORD_TYPE)\n-        continue;\n+\tcontinue;\n \n       fn = (*extractor) (type, client);\n       if (fn)\n-        {\n-          tree fn_raises = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn));\n+\t{\n+\t  tree fn_raises = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn));\n \n-          raises = merge_exception_specifiers (raises, fn_raises);\n-        }\n+\t  raises = merge_exception_specifiers (raises, fn_raises);\n+\t}\n     }\n   return raises;\n }\n@@ -888,7 +888,7 @@ locate_ctor (tree type, void *client ATTRIBUTE_UNUSED)\n       tree parms = TYPE_ARG_TYPES (TREE_TYPE (fn));\n \n       if (sufficient_parms_p (TREE_CHAIN (parms)))\n-        return fn;\n+\treturn fn;\n     }\n   return NULL_TREE;\n }\n@@ -939,24 +939,24 @@ locate_copy (tree type, void *client_)\n \n       parms = TREE_CHAIN (parms);\n       if (!parms)\n-        continue;\n+\tcontinue;\n       src_type = non_reference (TREE_VALUE (parms));\n       if (!same_type_ignoring_top_level_qualifiers_p (src_type, type))\n-        continue;\n+\tcontinue;\n       if (!sufficient_parms_p (TREE_CHAIN (parms)))\n-        continue;\n+\tcontinue;\n       quals = cp_type_quals (src_type);\n       if (client->quals & ~quals)\n-        continue;\n+\tcontinue;\n       excess = quals & ~client->quals;\n       if (!best || (excess_p && !excess))\n-        {\n-          best = fn;\n-          excess_p = excess;\n-        }\n+\t{\n+\t  best = fn;\n+\t  excess_p = excess;\n+\t}\n       else\n-        /* Ambiguous */\n-        return NULL_TREE;\n+\t/* Ambiguous */\n+\treturn NULL_TREE;\n     }\n   return best;\n }\n@@ -1026,19 +1026,19 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n       data.name = NULL;\n       data.quals = 0;\n       if (kind == sfk_assignment_operator)\n-        {\n+\t{\n \t  return_type = build_reference_type (type);\n-          name = ansi_assopname (NOP_EXPR);\n-          data.name = name;\n-        }\n+\t  name = ansi_assopname (NOP_EXPR);\n+\t  data.name = name;\n+\t}\n       else\n \tname = constructor_name (type);\n \n       if (const_p)\n-        {\n-          data.quals = TYPE_QUAL_CONST;\n+\t{\n+\t  data.quals = TYPE_QUAL_CONST;\n \t  rhs_parm_type = build_qualified_type (type, TYPE_QUAL_CONST);\n-        }\n+\t}\n       else\n \trhs_parm_type = type;\n       rhs_parm_type = build_reference_type (rhs_parm_type);"}, {"sha": "b76b8aff8d2f04d3c08b88ab0fa914a519c87d3f", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 150, "deletions": 150, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -46,7 +46,7 @@ static cxx_binding *binding_for_name (cxx_scope *, tree);\n static tree lookup_name_innermost_nonclass_level (tree);\n static tree push_overloaded_decl (tree, int);\n static bool lookup_using_namespace (tree, struct scope_binding *, tree,\n-                                    tree, int);\n+\t\t\t\t    tree, int);\n static bool qualified_lookup_using_namespace (tree, tree,\n \t\t\t\t\t      struct scope_binding *, int);\n static tree lookup_type_current_level (tree);\n@@ -145,11 +145,11 @@ binding_table_free (binding_table table)\n     {\n       binding_entry temp = table->chain[i];\n       while (temp != NULL)\n-        {\n-          binding_entry entry = temp;\n-          temp = entry->chain;\n-          binding_entry_free (entry);\n-        }\n+\t{\n+\t  binding_entry entry = temp;\n+\t  temp = entry->chain;\n+\t  binding_entry_free (entry);\n+\t}\n       table->chain[i] = NULL;\n     }\n   table->entry_count = 0;\n@@ -183,14 +183,14 @@ binding_table_expand (binding_table table)\n     {\n       binding_entry entry = old_chains[i];\n       for (; entry != NULL; entry = old_chains[i])\n-        {\n-          const unsigned int hash = IDENTIFIER_HASH_VALUE (entry->name);\n-          const size_t j = ENTRY_INDEX (hash, new_chain_count);\n-\n-          old_chains[i] = entry->chain;\n-          entry->chain = table->chain[j];\n-          table->chain[j] = entry;\n-        }\n+\t{\n+\t  const unsigned int hash = IDENTIFIER_HASH_VALUE (entry->name);\n+\t  const size_t j = ENTRY_INDEX (hash, new_chain_count);\n+\n+\t  old_chains[i] = entry->chain;\n+\t  entry->chain = table->chain[j];\n+\t  table->chain[j] = entry;\n+\t}\n     }\n   table->entry_count = old_entry_count;\n }\n@@ -238,7 +238,7 @@ binding_table_foreach (binding_table table, bt_foreach_proc proc, void *data)\n     {\n       binding_entry entry = table->chain[i];\n       for (; entry != NULL; entry = entry->chain)\n-        proc (entry, data);\n+\tproc (entry, data);\n     }\n }\n \f\n@@ -465,7 +465,7 @@ supplement_binding (cxx_binding *binding, tree decl)\n     /* We have two typedef-names, both naming the same type to have\n        the same name.  In general, this is OK because of:\n \n-         [dcl.typedef]\n+\t [dcl.typedef]\n \n \t In a given scope, a typedef specifier can be used to redefine\n \t the name of any type declared in that scope to refer to the\n@@ -531,7 +531,7 @@ add_decl_to_level (tree decl, cxx_scope *b)\n   else\n     {\n       /* We build up the list in reverse order, and reverse it later if\n-         necessary.  */\n+\t necessary.  */\n       TREE_CHAIN (decl) = b->names;\n       b->names = decl;\n       b->names_size++;\n@@ -576,7 +576,7 @@ pushdecl (tree x)\n     {\n       if (current_function_decl && x != current_function_decl\n \t  /* A local declaration for a function doesn't constitute\n-             nesting.  */\n+\t     nesting.  */\n \t  && TREE_CODE (x) != FUNCTION_DECL\n \t  /* A local declaration for an `extern' variable is in the\n \t     scope of the current namespace, not the current\n@@ -690,7 +690,7 @@ pushdecl (tree x)\n \t    {\n \t      if (pedantic && ! DECL_IN_SYSTEM_HEADER (x))\n \t\tpedwarn (\"redeclaration of %<wchar_t%> as %qT\",\n-                         TREE_TYPE (x));\n+\t\t\t TREE_TYPE (x));\n \n \t      /* Throw away the redeclaration.  */\n \t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n@@ -766,28 +766,28 @@ pushdecl (tree x)\n \t{\n \t  tree type = TREE_TYPE (x);\n \t  if (DECL_IS_BUILTIN (x))\n-            {\n+\t    {\n \t      if (TYPE_NAME (type) == 0)\n-\t        TYPE_NAME (type) = x;\n-            }\n-          else if (type != error_mark_node && TYPE_NAME (type) != x\n+\t\tTYPE_NAME (type) = x;\n+\t    }\n+\t  else if (type != error_mark_node && TYPE_NAME (type) != x\n \t\t   /* We don't want to copy the type when all we're\n \t\t      doing is making a TYPE_DECL for the purposes of\n \t\t      inlining.  */\n \t\t   && (!TYPE_NAME (type)\n \t\t       || TYPE_NAME (type) != DECL_ABSTRACT_ORIGIN (x)))\n-            {\n+\t    {\n \t      DECL_ORIGINAL_TYPE (x) = type;\n-              type = build_variant_type_copy (type);\n+\t      type = build_variant_type_copy (type);\n \t      TYPE_STUB_DECL (type) = TYPE_STUB_DECL (DECL_ORIGINAL_TYPE (x));\n-              TYPE_NAME (type) = x;\n-              TREE_TYPE (x) = type;\n-            }\n+\t      TYPE_NAME (type) = x;\n+\t      TREE_TYPE (x) = type;\n+\t    }\n \n \t  if (type != error_mark_node\n \t      && TYPE_NAME (type)\n \t      && TYPE_IDENTIFIER (type))\n-            set_identifier_type_value (DECL_NAME (x), x);\n+\t    set_identifier_type_value (DECL_NAME (x), x);\n \t}\n \n       /* Multiple external decls of the same identifier ought to match.\n@@ -826,16 +826,16 @@ pushdecl (tree x)\n \t  if (IDENTIFIER_GLOBAL_VALUE (name) == NULL_TREE && TREE_PUBLIC (x))\n \t    TREE_PUBLIC (name) = 1;\n \n- \t  /* Bind the name for the entity.  */\n- \t  if (!(TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)\n-  \t\t&& t != NULL_TREE)\n- \t      && (TREE_CODE (x) == TYPE_DECL\n- \t\t  || TREE_CODE (x) == VAR_DECL\n- \t\t  || TREE_CODE (x) == ALIAS_DECL\n- \t\t  || TREE_CODE (x) == NAMESPACE_DECL\n- \t\t  || TREE_CODE (x) == CONST_DECL\n- \t\t  || TREE_CODE (x) == TEMPLATE_DECL))\n- \t    SET_IDENTIFIER_NAMESPACE_VALUE (name, x);\n+\t  /* Bind the name for the entity.  */\n+\t  if (!(TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)\n+\t\t&& t != NULL_TREE)\n+\t      && (TREE_CODE (x) == TYPE_DECL\n+\t\t  || TREE_CODE (x) == VAR_DECL\n+\t\t  || TREE_CODE (x) == ALIAS_DECL\n+\t\t  || TREE_CODE (x) == NAMESPACE_DECL\n+\t\t  || TREE_CODE (x) == CONST_DECL\n+\t\t  || TREE_CODE (x) == TEMPLATE_DECL))\n+\t    SET_IDENTIFIER_NAMESPACE_VALUE (name, x);\n \n \t  /* If new decl is `static' and an `extern' was seen previously,\n \t     warn about it.  */\n@@ -1115,7 +1115,7 @@ check_for_out_of_scope_variable (tree decl)\n       error (\"name lookup of %qD changed for new ISO %<for%> scoping\",\n \t     DECL_NAME (decl));\n       cp_error_at (\"  cannot use obsolete binding at %qD because \"\n-                   \"it has a destructor\", decl);\n+\t\t   \"it has a destructor\", decl);\n       return error_mark_node;\n     }\n   else\n@@ -1176,7 +1176,7 @@ cxx_scope_debug (cxx_scope *scope, int line, const char *action)\n   const char *desc = cxx_scope_descriptor (scope);\n   if (scope->this_entity)\n     verbatim (\"%s %s(%E) %p %d\\n\", action, desc,\n-              scope->this_entity, (void *) scope, line);\n+\t      scope->this_entity, (void *) scope, line);\n   else\n     verbatim (\"%s %s %p %d\\n\", action, desc, (void *) scope, line);\n }\n@@ -1302,10 +1302,10 @@ leave_scope (void)\n       indent (--binding_depth);\n       cxx_scope_debug (scope, input_line, \"leave\");\n       if (is_class_level != (scope == class_binding_level))\n-        {\n-          indent (binding_depth);\n-          verbatim (\"XXX is_class_level != (current_scope == class_scope)\\n\");\n-        }\n+\t{\n+\t  indent (binding_depth);\n+\t  verbatim (\"XXX is_class_level != (current_scope == class_scope)\\n\");\n+\t}\n       is_class_level = 0;\n     }\n \n@@ -1432,7 +1432,7 @@ kept_level_p (void)\n {\n   return (current_binding_level->blocks != NULL_TREE\n \t  || current_binding_level->keep\n-          || current_binding_level->kind == sk_cleanup\n+\t  || current_binding_level->kind == sk_cleanup\n \t  || current_binding_level->names != NULL_TREE);\n }\n \n@@ -1517,7 +1517,7 @@ print_binding_level (struct cp_binding_level* lvl)\n \t    break;\n \t}\n       if (i)\n-        fprintf (stderr, \"\\n\");\n+\tfprintf (stderr, \"\\n\");\n     }\n   if (VEC_length (cp_class_binding, lvl->class_shadowed))\n     {\n@@ -1534,9 +1534,9 @@ print_binding_level (struct cp_binding_level* lvl)\n     {\n       fprintf (stderr, \" type-shadowed:\");\n       for (t = lvl->type_shadowed; t; t = TREE_CHAIN (t))\n-        {\n+\t{\n \t  fprintf (stderr, \" %s \", IDENTIFIER_POINTER (TREE_PURPOSE (t)));\n-        }\n+\t}\n       fprintf (stderr, \"\\n\");\n     }\n }\n@@ -1560,7 +1560,7 @@ print_binding_stack (void)\n \t   \"\\nclass_binding_level=\" HOST_PTR_PRINTF\n \t   \"\\nNAMESPACE_LEVEL (global_namespace)=\" HOST_PTR_PRINTF \"\\n\",\n \t   (void *) current_binding_level, (void *) class_binding_level,\n-           (void *) NAMESPACE_LEVEL (global_namespace));\n+\t   (void *) NAMESPACE_LEVEL (global_namespace));\n   if (class_binding_level)\n     {\n       for (b = class_binding_level; b; b = b->level_chain)\n@@ -1737,7 +1737,7 @@ cxx_scope_find_binding_for_name (cxx_scope *scope, tree name)\n     {\n       /* Fold-in case where NAME is used only once.  */\n       if (scope == b->scope && b->previous == NULL)\n-        return b;\n+\treturn b;\n       return find_binding (scope, b);\n     }\n   return NULL;\n@@ -1782,7 +1782,7 @@ push_using_decl (tree scope, tree name)\n       break;\n   if (decl)\n     POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n-                            namespace_bindings_p () ? decl : NULL_TREE);\n+\t\t\t    namespace_bindings_p () ? decl : NULL_TREE);\n   decl = build_lang_decl (USING_DECL, name, NULL_TREE);\n   USING_DECL_SCOPE (decl) = scope;\n   TREE_CHAIN (decl) = current_binding_level->usings;\n@@ -1830,9 +1830,9 @@ pushdecl_with_scope (tree x, cxx_scope *level)\n \n    FLAGS is a bitwise-or of the following values:\n      PUSH_LOCAL: Bind DECL in the current scope, rather than at\n-                 namespace scope.\n+\t\t namespace scope.\n      PUSH_USING: DECL is being pushed as the result of a using\n-                 declaration.\n+\t\t declaration.\n \n    The value returned may be a previous declaration if we guessed wrong\n    about what language DECL should belong to (C or C++).  Otherwise,\n@@ -1864,8 +1864,8 @@ push_overloaded_decl (tree decl, int flags)\n \t  old = NULL_TREE;\n \t}\n       else if (is_overloaded_fn (old))\n-        {\n-          tree tmp;\n+\t{\n+\t  tree tmp;\n \n \t  for (tmp = old; tmp; tmp = OVL_NEXT (tmp))\n \t    {\n@@ -1877,7 +1877,7 @@ push_overloaded_decl (tree decl, int flags)\n \t\t\t\tTYPE_ARG_TYPES (TREE_TYPE (decl)))\n \t\t  && ! decls_match (fn, decl))\n \t\terror (\"%q#D conflicts with previous using declaration %q#D\",\n-                       decl, fn);\n+\t\t       decl, fn);\n \n \t      if (duplicate_decls (decl, fn) == fn)\n \t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, fn);\n@@ -1985,7 +1985,7 @@ validate_nonmember_using_decl (tree decl, tree scope, tree name)\n       /* 7.3.3/5\n \t   A using-declaration shall not name a template-id.  */\n       error (\"a using-declaration cannot specify a template-id.  \"\n-             \"Try %<using %D%>\", name);\n+\t     \"Try %<using %D%>\", name);\n       return NULL_TREE;\n     }\n \n@@ -2016,7 +2016,7 @@ validate_nonmember_using_decl (tree decl, tree scope, tree name)\n \n static void\n do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n-                         tree *newval, tree *newtype)\n+\t\t\t tree *newval, tree *newtype)\n {\n   struct scope_binding decls = EMPTY_SCOPE_BINDING;\n \n@@ -2066,23 +2066,23 @@ do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n \t    {\n \t      tree old_fn = OVL_CURRENT (tmp1);\n \n-              if (new_fn == old_fn)\n-                /* The function already exists in the current namespace.  */\n-                break;\n+\t      if (new_fn == old_fn)\n+\t\t/* The function already exists in the current namespace.  */\n+\t\tbreak;\n \t      else if (OVL_USED (tmp1))\n-\t        continue; /* this is a using decl */\n+\t\tcontinue; /* this is a using decl */\n \t      else if (compparms (TYPE_ARG_TYPES (TREE_TYPE (new_fn)),\n-\t\t  \t\t  TYPE_ARG_TYPES (TREE_TYPE (old_fn))))\n+\t\t\t\t  TYPE_ARG_TYPES (TREE_TYPE (old_fn))))\n \t\t{\n \t\t  gcc_assert (!DECL_ANTICIPATED (old_fn));\n \n-\t          /* There was already a non-using declaration in\n+\t\t  /* There was already a non-using declaration in\n \t\t     this scope with the same parameter types. If both\n-\t             are the same extern \"C\" functions, that's ok.  */\n-                  if (decls_match (new_fn, old_fn))\n+\t\t     are the same extern \"C\" functions, that's ok.  */\n+\t\t  if (decls_match (new_fn, old_fn))\n \t\t    break;\n \t\t  else\n- \t\t    {\n+\t\t    {\n \t\t      error (\"%qD is already declared in this scope\", name);\n \t\t      break;\n \t\t    }\n@@ -2124,7 +2124,7 @@ do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n   if (oldtype && *newtype && !same_type_p (oldtype, *newtype))\n     {\n       error (\"using declaration %qD introduced ambiguous type %qT\",\n-             name, oldtype);\n+\t     name, oldtype);\n       return;\n     }\n }\n@@ -2629,9 +2629,9 @@ push_class_level_binding (tree name, tree x)\n       if (INHERITED_VALUE_BINDING_P (binding))\n \t{\n \t  /* If the old binding was from a base class, and was for a\n-  \t     tag name, slide it over to make room for the new binding.\n-  \t     The old binding is still visible if explicitly qualified\n-  \t     with a class-key.  */\n+\t     tag name, slide it over to make room for the new binding.\n+\t     The old binding is still visible if explicitly qualified\n+\t     with a class-key.  */\n \t  if (TREE_CODE (bval) == TYPE_DECL && DECL_ARTIFICIAL (bval)\n \t      && !(TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)))\n \t    {\n@@ -2818,7 +2818,7 @@ set_decl_namespace (tree decl, tree scope, bool friendp)\n   /* It is ok for friends to be qualified in parallel space.  */\n   if (!friendp && !is_ancestor (current_namespace, scope))\n     error (\"declaration of %qD not in a namespace surrounding %qD\",\n-           decl, scope);\n+\t   decl, scope);\n   DECL_CONTEXT (decl) = FROB_CONTEXT (scope);\n \n   /* Writing \"int N::i\" to declare a variable within \"N\" is invalid.  */\n@@ -2904,30 +2904,30 @@ push_namespace (tree name)\n   if (anon)\n     {\n       /* The name of anonymous namespace is unique for the translation\n-         unit.  */\n+\t unit.  */\n       if (!anonymous_namespace_name)\n-        anonymous_namespace_name = get_file_function_name ('N');\n+\tanonymous_namespace_name = get_file_function_name ('N');\n       name = anonymous_namespace_name;\n       d = IDENTIFIER_NAMESPACE_VALUE (name);\n       if (d)\n-        /* Reopening anonymous namespace.  */\n-        need_new = 0;\n+\t/* Reopening anonymous namespace.  */\n+\tneed_new = 0;\n       implicit_use = 1;\n     }\n   else\n     {\n       /* Check whether this is an extended namespace definition.  */\n       d = IDENTIFIER_NAMESPACE_VALUE (name);\n       if (d != NULL_TREE && TREE_CODE (d) == NAMESPACE_DECL)\n-        {\n-          need_new = 0;\n-          if (DECL_NAMESPACE_ALIAS (d))\n-            {\n-              error (\"namespace alias %qD not allowed here, assuming %qD\",\n-                     d, DECL_NAMESPACE_ALIAS (d));\n-              d = DECL_NAMESPACE_ALIAS (d);\n-            }\n-        }\n+\t{\n+\t  need_new = 0;\n+\t  if (DECL_NAMESPACE_ALIAS (d))\n+\t    {\n+\t      error (\"namespace alias %qD not allowed here, assuming %qD\",\n+\t\t     d, DECL_NAMESPACE_ALIAS (d));\n+\t      d = DECL_NAMESPACE_ALIAS (d);\n+\t    }\n+\t}\n     }\n \n   if (need_new)\n@@ -3006,7 +3006,7 @@ push_decl_namespace (tree decl)\n   if (TREE_CODE (decl) != NAMESPACE_DECL)\n     decl = decl_namespace_context (decl);\n   decl_namespace_list = tree_cons (ORIGINAL_NAMESPACE (decl),\n-                                   NULL_TREE, decl_namespace_list);\n+\t\t\t\t   NULL_TREE, decl_namespace_list);\n }\n \n /* [namespace.memdef]/2 */\n@@ -3027,7 +3027,7 @@ namespace_ancestor (tree ns1, tree ns2)\n   if (is_ancestor (ns1, ns2))\n     POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, ns1);\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n-                          namespace_ancestor (CP_DECL_CONTEXT (ns1), ns2));\n+\t\t\t  namespace_ancestor (CP_DECL_CONTEXT (ns1), ns2));\n }\n \n /* Process a namespace-alias declaration.  */\n@@ -3075,28 +3075,28 @@ pushdecl_namespace_level (tree x)\n       tree newval;\n       tree *ptr = (tree *)0;\n       for (; !global_scope_p (b); b = b->level_chain)\n-        {\n-          tree shadowed = b->type_shadowed;\n-          for (; shadowed; shadowed = TREE_CHAIN (shadowed))\n-            if (TREE_PURPOSE (shadowed) == name)\n-              {\n+\t{\n+\t  tree shadowed = b->type_shadowed;\n+\t  for (; shadowed; shadowed = TREE_CHAIN (shadowed))\n+\t    if (TREE_PURPOSE (shadowed) == name)\n+\t      {\n \t\tptr = &TREE_VALUE (shadowed);\n \t\t/* Can't break out of the loop here because sometimes\n \t\t   a binding level will have duplicate bindings for\n \t\t   PT names.  It's gross, but I haven't time to fix it.  */\n-              }\n-        }\n+\t      }\n+\t}\n       newval = TREE_TYPE (t);\n       if (ptr == (tree *)0)\n-        {\n-          /* @@ This shouldn't be needed.  My test case \"zstring.cc\" trips\n-             up here if this is changed to an assertion.  --KR  */\n+\t{\n+\t  /* @@ This shouldn't be needed.  My test case \"zstring.cc\" trips\n+\t     up here if this is changed to an assertion.  --KR  */\n \t  SET_IDENTIFIER_TYPE_VALUE (name, t);\n \t}\n       else\n-        {\n+\t{\n \t  *ptr = newval;\n-        }\n+\t}\n     }\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n }\n@@ -3344,42 +3344,42 @@ ambiguous_decl (tree name, struct scope_binding *old, cxx_binding *new,\n     switch (TREE_CODE (val))\n       {\n       case TEMPLATE_DECL:\n-        /* If we expect types or namespaces, and not templates,\n-           or this is not a template class.  */\n-        if ((LOOKUP_QUALIFIERS_ONLY (flags)\n+\t/* If we expect types or namespaces, and not templates,\n+\t   or this is not a template class.  */\n+\tif ((LOOKUP_QUALIFIERS_ONLY (flags)\n \t     && !DECL_CLASS_TEMPLATE_P (val))\n \t    || hidden_name_p (val))\n-          val = NULL_TREE;\n-        break;\n+\t  val = NULL_TREE;\n+\tbreak;\n       case TYPE_DECL:\n-        if (LOOKUP_NAMESPACES_ONLY (flags) || hidden_name_p (val))\n-          val = NULL_TREE;\n-        break;\n+\tif (LOOKUP_NAMESPACES_ONLY (flags) || hidden_name_p (val))\n+\t  val = NULL_TREE;\n+\tbreak;\n       case NAMESPACE_DECL:\n-        if (LOOKUP_TYPES_ONLY (flags))\n-          val = NULL_TREE;\n-        break;\n+\tif (LOOKUP_TYPES_ONLY (flags))\n+\t  val = NULL_TREE;\n+\tbreak;\n       case FUNCTION_DECL:\n-        /* Ignore built-in functions that are still anticipated.  */\n-        if (LOOKUP_QUALIFIERS_ONLY (flags) || hidden_name_p (val))\n-          val = NULL_TREE;\n-        break;\n+\t/* Ignore built-in functions that are still anticipated.  */\n+\tif (LOOKUP_QUALIFIERS_ONLY (flags) || hidden_name_p (val))\n+\t  val = NULL_TREE;\n+\tbreak;\n       default:\n-        if (LOOKUP_QUALIFIERS_ONLY (flags))\n-          val = NULL_TREE;\n+\tif (LOOKUP_QUALIFIERS_ONLY (flags))\n+\t  val = NULL_TREE;\n       }\n \n   if (!old->value)\n     old->value = val;\n   else if (val && val != old->value)\n     {\n       if (is_overloaded_fn (old->value) && is_overloaded_fn (val))\n-        old->value = merge_functions (old->value, val);\n+\told->value = merge_functions (old->value, val);\n       else\n \t{\n \t  /* Some declarations are functions, some are not.  */\n-          if (flags & LOOKUP_COMPLAIN)\n-            {\n+\t  if (flags & LOOKUP_COMPLAIN)\n+\t    {\n \t      /* If we've already given this error for this lookup,\n \t\t old->value is error_mark_node, so let's not\n \t\t repeat ourselves.  */\n@@ -3388,8 +3388,8 @@ ambiguous_decl (tree name, struct scope_binding *old, cxx_binding *new,\n \t\t  error (\"use of %qD is ambiguous\", name);\n \t\t  cp_error_at (\"  first declared as %q#D here\", old->value);\n \t\t}\n-              cp_error_at (\"  also declared as %q#D here\", val);\n-            }\n+\t      cp_error_at (\"  also declared as %q#D here\", val);\n+\t    }\n \t  old->value = error_mark_node;\n \t}\n     }\n@@ -3402,11 +3402,11 @@ ambiguous_decl (tree name, struct scope_binding *old, cxx_binding *new,\n   else if (type && old->type != type)\n     {\n       if (flags & LOOKUP_COMPLAIN)\n-        {\n-          error (\"%qD denotes an ambiguous type\",name);\n-          error (\"%J  first type here\", TYPE_MAIN_DECL (old->type));\n-          error (\"%J  other type here\", TYPE_MAIN_DECL (type));\n-        }\n+\t{\n+\t  error (\"%qD denotes an ambiguous type\",name);\n+\t  error (\"%J  first type here\", TYPE_MAIN_DECL (old->type));\n+\t  error (\"%J  other type here\", TYPE_MAIN_DECL (type));\n+\t}\n     }\n }\n \n@@ -3516,7 +3516,7 @@ lookup_namespace_name (tree namespace, tree name)\n \t\t\t\t\t /*in_decl=*/NULL_TREE,\n \t\t\t\t\t /*context=*/NULL_TREE,\n \t\t\t\t\t /*entering_scope=*/0,\n-\t                                 tf_error | tf_warning);\n+\t\t\t\t\t tf_error | tf_warning);\n \t  else if (DECL_FUNCTION_TEMPLATE_P (val)\n \t\t   || TREE_CODE (val) == OVERLOAD)\n \t    val = lookup_template_function (val,\n@@ -3535,7 +3535,7 @@ lookup_namespace_name (tree namespace, tree name)\n       /* Ignore built-in functions and friends that haven't been declared\n \t yet.  */\n       if (!val || !hidden_name_p (val))\n-        POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n+\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n     }\n \n   error (\"%qD undeclared in namespace %qD\", name, namespace);\n@@ -3555,7 +3555,7 @@ select_decl (const struct scope_binding *binding, int flags)\n     {\n       /* We are not interested in types.  */\n       if (val && TREE_CODE (val) == NAMESPACE_DECL)\n-        POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n+\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n       POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n     }\n \n@@ -3589,7 +3589,7 @@ unqualified_namespace_lookup (tree name, int flags)\n   for (; !val; scope = CP_DECL_CONTEXT (scope))\n     {\n       cxx_binding *b =\n-         cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n+\t cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n \n       if (b)\n \t{\n@@ -3606,7 +3606,7 @@ unqualified_namespace_lookup (tree name, int flags)\n \t   level->kind != sk_namespace;\n \t   level = level->level_chain)\n \tif (!lookup_using_namespace (name, &binding, level->using_directives,\n-                                     scope, flags))\n+\t\t\t\t     scope, flags))\n \t  /* Give up because of error.  */\n \t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \n@@ -3616,7 +3616,7 @@ unqualified_namespace_lookup (tree name, int flags)\n       while (1)\n \t{\n \t  if (!lookup_using_namespace (name, &binding,\n-                                       DECL_NAMESPACE_USING (siter),\n+\t\t\t\t       DECL_NAMESPACE_USING (siter),\n \t\t\t\t       scope, flags))\n \t    /* Give up because of error.  */\n \t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n@@ -3684,12 +3684,12 @@ lookup_using_namespace (tree name, struct scope_binding *val,\n   for (iter = usings; iter; iter = TREE_CHAIN (iter))\n     if (TREE_VALUE (iter) == scope)\n       {\n-        tree used = ORIGINAL_NAMESPACE (TREE_PURPOSE (iter));\n-        cxx_binding *val1 =\n-          cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (used), name);\n-        /* Resolve ambiguities.  */\n-        if (val1)\n-          ambiguous_decl (name, val, val1, flags);\n+\ttree used = ORIGINAL_NAMESPACE (TREE_PURPOSE (iter));\n+\tcxx_binding *val1 =\n+\t  cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (used), name);\n+\t/* Resolve ambiguities.  */\n+\tif (val1)\n+\t  ambiguous_decl (name, val, val1, flags);\n       }\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val->value != error_mark_node);\n }\n@@ -3718,7 +3718,7 @@ qualified_lookup_using_namespace (tree name, tree scope,\n \tcxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n       seen = tree_cons (scope, NULL_TREE, seen);\n       if (binding)\n-        ambiguous_decl (name, result, binding, flags);\n+\tambiguous_decl (name, result, binding, flags);\n \n       /* Consider strong using directives always, and non-strong ones\n \t if we haven't found a binding yet.  ??? Shouldn't we consider\n@@ -4107,7 +4107,7 @@ lookup_type_current_level (tree name)\n \t{\n \t  if (purpose_member (name, b->type_shadowed))\n \t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n-                                    REAL_IDENTIFIER_TYPE_VALUE (name));\n+\t\t\t\t    REAL_IDENTIFIER_TYPE_VALUE (name));\n \t  if (b->kind == sk_cleanup)\n \t    b = b->level_chain;\n \t  else\n@@ -4258,10 +4258,10 @@ arg_assoc_template_arg (struct arg_lookup *k, tree arg)\n \n       /* It's not a member template.  */\n       if (TREE_CODE (ctx) == NAMESPACE_DECL)\n-        return arg_assoc_namespace (k, ctx);\n+\treturn arg_assoc_namespace (k, ctx);\n       /* Otherwise, it must be member template.  */\n       else\n-        return arg_assoc_class (k, ctx);\n+\treturn arg_assoc_class (k, ctx);\n     }\n   /* It's not a template template argument, but it is a type template\n      argument.  */\n@@ -4333,7 +4333,7 @@ arg_assoc_class (struct arg_lookup *k, tree type)\n     {\n       list = INNERMOST_TEMPLATE_ARGS (CLASSTYPE_TI_ARGS (type));\n       for (i = 0; i < TREE_VEC_LENGTH (list); ++i)\n-        arg_assoc_template_arg (k, TREE_VEC_ELT (list, i));\n+\targ_assoc_template_arg (k, TREE_VEC_ELT (list, i));\n     }\n \n   return false;\n@@ -4454,7 +4454,7 @@ arg_assoc (struct arg_lookup *k, tree n)\n       int ix;\n \n       if (TREE_CODE (template) == COMPONENT_REF)\n-        template = TREE_OPERAND (template, 1);\n+\ttemplate = TREE_OPERAND (template, 1);\n \n       /* First, the template.  There may actually be more than one if\n \t this is an overloaded function template.  But, in that case,\n@@ -4566,15 +4566,15 @@ push_using_directive (tree used)\n \n static tree\n maybe_process_template_type_declaration (tree type, int is_friend,\n-                                         cxx_scope *b)\n+\t\t\t\t\t cxx_scope *b)\n {\n   tree decl = TYPE_NAME (type);\n \n   if (processing_template_parmlist)\n     /* You can't declare a new template type in a template parameter\n        list.  But, you can declare a non-template type:\n \n-         template <class A*> struct S;\n+\t template <class A*> struct S;\n \n        is a forward-declaration of `A'.  */\n     ;\n@@ -4665,8 +4665,8 @@ pushtag (tree name, tree type, tag_scope scope)\n     {\n       /* Do C++ gratuitous typedefing.  */\n       if (IDENTIFIER_TYPE_VALUE (name) != type)\n-        {\n-          tree d = NULL_TREE;\n+\t{\n+\t  tree d = NULL_TREE;\n \t  int in_class = 0;\n \t  tree context = TYPE_CONTEXT (type);\n \n@@ -4744,7 +4744,7 @@ pushtag (tree name, tree type, tag_scope scope)\n \t  if (TYPE_CONTEXT (type)\n \t      && TREE_CODE (TYPE_CONTEXT (type)) == FUNCTION_DECL)\n \t    VEC_safe_push (tree, gc, local_classes, type);\n-        }\n+\t}\n       if (b->kind == sk_class\n \t  && !COMPLETE_TYPE_P (current_class_type))\n \t{"}, {"sha": "72472337c7d99b8c10ff6eb1d679350ff9b9c307", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -40,11 +40,11 @@ struct binding_entry_s GTY(())\n };\n \n /* These macros indicate the initial chains count for binding_table.  */\n-#define SCOPE_DEFAULT_HT_SIZE                        (1 << 3)\n-#define CLASS_SCOPE_HT_SIZE                          (1 << 3)\n-#define NAMESPACE_ORDINARY_HT_SIZE                   (1 << 5)\n-#define NAMESPACE_STD_HT_SIZE                        (1 << 8)\n-#define GLOBAL_SCOPE_HT_SIZE                         (1 << 8)\n+#define SCOPE_DEFAULT_HT_SIZE\t\t(1 << 3)\n+#define CLASS_SCOPE_HT_SIZE\t\t(1 << 3)\n+#define NAMESPACE_ORDINARY_HT_SIZE\t(1 << 5)\n+#define NAMESPACE_STD_HT_SIZE\t\t(1 << 8)\n+#define GLOBAL_SCOPE_HT_SIZE\t\t(1 << 8)\n \n extern void binding_table_foreach (binding_table, bt_foreach_proc, void *);\n extern binding_entry binding_table_find (binding_table, tree);\n@@ -105,16 +105,16 @@ typedef enum scope_kind {\n \t\t\tis initialized by using \"memset\" to set the\n \t\t\tcontents to zero, and the default scope kind\n \t\t\tis \"sk_block\".  */\n-  sk_cleanup,        /* A scope for (pseudo-)scope for cleanup.  It is\n-                        peusdo in that it is transparent to name lookup\n-                        activities.  */\n+  sk_cleanup,\t     /* A scope for (pseudo-)scope for cleanup.  It is\n+\t\t\tpeusdo in that it is transparent to name lookup\n+\t\t\tactivities.  */\n   sk_try,\t     /* A try-block.  */\n-  sk_catch,          /* A catch-block.  */\n-  sk_for,            /* The scope of the variable declared in a\n+  sk_catch,\t     /* A catch-block.  */\n+  sk_for,\t     /* The scope of the variable declared in a\n \t\t\tfor-init-statement.  */\n   sk_function_parms, /* The scope containing function parameters.  */\n-  sk_class,          /* The scope containing the members of a class.  */\n-  sk_namespace,      /* The scope containing the members of a\n+  sk_class,\t     /* The scope containing the members of a class.  */\n+  sk_namespace,\t     /* The scope containing the members of a\n \t\t\tnamespace, including the global scope.  */\n   sk_template_parms, /* A scope for template parameters.  */\n   sk_template_spec   /* Like sk_template_parms, but for an explicit"}, {"sha": "db3fa63164b40056b7a6ffc17cb16243fdde9746", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 159, "deletions": 159, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -379,7 +379,7 @@ cp_lexer_saving_tokens (const cp_lexer* lexer)\n \n static void\n cp_lexer_get_preprocessor_token (cp_lexer *lexer ATTRIBUTE_UNUSED ,\n-                                 cp_token *token)\n+\t\t\t\t cp_token *token)\n {\n   static int is_extern_c = 0;\n \n@@ -904,7 +904,7 @@ cp_declarator *\n make_call_declarator (cp_declarator *target,\n \t\t      cp_parameter_declarator *parms,\n \t\t      cp_cv_quals cv_qualifiers,\n-                      tree exception_specification)\n+\t\t      tree exception_specification)\n {\n   cp_declarator *declarator;\n \n@@ -2082,7 +2082,7 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser, tree scope, tree id)\n \t\t\t&& DECL_NAME (field) == id)\n \t\t      {\n \t\t\tinform (\"(perhaps %<typename %T::%E%> was intended)\",\n-\t\t\t        BINFO_TYPE (b), id);\n+\t\t\t\tBINFO_TYPE (b), id);\n \t\t\tbreak;\n \t\t      }\n \t\t  if (field)\n@@ -2268,7 +2268,7 @@ cp_parser_skip_to_end_of_statement (cp_parser* parser)\n \t     scanned, stop -- but only after consuming the token.\n \t     That way given:\n \n-\t        void f g () { ... }\n+\t\tvoid f g () { ... }\n \t\ttypedef int I;\n \n \t     we will stop after the body of the erroneously declared\n@@ -2800,7 +2800,7 @@ cp_parser_primary_expression (cp_parser *parser,\n     case CPP_STRING:\n     case CPP_WSTRING:\n       /* ??? Should wide strings be allowed when parser->translate_strings_p\n-         is false (i.e. in attributes)?  If not, we can kill the third\n+\t is false (i.e. in attributes)?  If not, we can kill the third\n \t argument to cp_parser_string_literal.  */\n       return cp_parser_string_literal (parser,\n \t\t\t\t       parser->translate_strings_p,\n@@ -2830,7 +2830,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    /* And they're not allowed outside of a function-body; you\n \t       cannot, for example, write:\n \n-\t         int i = ({ int j = 3; j + 1; });\n+\t\t int i = ({ int j = 3; j + 1; });\n \n \t       at class or namespace scope.  */\n \t    if (!at_function_scope_p ())\n@@ -3229,7 +3229,7 @@ cp_parser_id_expression (cp_parser *parser,\n \n static tree\n cp_parser_unqualified_id (cp_parser* parser,\n-                          bool template_keyword_p,\n+\t\t\t  bool template_keyword_p,\n \t\t\t  bool check_dependency_p,\n \t\t\t  bool declarator_p)\n {\n@@ -3279,7 +3279,7 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t     template <typename T> struct S { ~S (); };\n \t     template <typename T> S<T>::~S() {}\n \n-           is invalid, since `~' must be followed by a class-name, but\n+\t   is invalid, since `~' must be followed by a class-name, but\n \t   `S<T>' is dependent, and so not known to be a class.\n \t   That's not right; we need to look in uninstantiated\n \t   templates.  A further complication arises from:\n@@ -3294,14 +3294,14 @@ cp_parser_unqualified_id (cp_parser* parser,\n \n \t   Yet another issue is:\n \n-             struct S {\n-               int S;\n-               ~S();\n-             };\n+\t     struct S {\n+\t       int S;\n+\t       ~S();\n+\t     };\n \n-             S::~S() {}\n+\t     S::~S() {}\n \n-           The standard does not seem to say that the `S' in `~S'\n+\t   The standard does not seem to say that the `S' in `~S'\n \t   should refer to the type `S' and not the data member\n \t   `S::S'.  */\n \n@@ -4472,8 +4472,8 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \t However, if the name was not dependent and has already been\n \t resolved; there is no need to build the SCOPE_REF.  For example;\n \n-             struct X { void f(); };\n-             template <typename T> void f(T* t) { t->X::f(); }\n+\t     struct X { void f(); };\n+\t     template <typename T> void f(T* t) { t->X::f(); }\n \n \t Even though \"t\" is dependent, \"X::f\" is not and has been resolved\n \t to a BASELINK; there is no need to include scope information.  */\n@@ -4659,8 +4659,8 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \n static void\n cp_parser_pseudo_destructor_name (cp_parser* parser,\n-                                  tree* scope,\n-                                  tree* type)\n+\t\t\t\t  tree* scope,\n+\t\t\t\t  tree* type)\n {\n   bool nested_name_specifier_p;\n \n@@ -5003,7 +5003,7 @@ cp_parser_new_expression (cp_parser* parser)\n       /* Look for the closing `)'.  */\n       cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n       /* There should not be a direct-new-declarator in this production,\n-         but GCC used to allowed this, so we check and emit a sensible error\n+\t but GCC used to allowed this, so we check and emit a sensible error\n \t message for this case.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_SQUARE))\n \t{\n@@ -5211,7 +5211,7 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n \t      if (!expression)\n \t\t{\n \t\t  error (\"expression in new-declarator must have integral \"\n-                         \"or enumeration type\");\n+\t\t\t \"or enumeration type\");\n \t\t  expression = error_mark_node;\n \t\t}\n \t    }\n@@ -5384,9 +5384,9 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p)\n       parser->type_definition_forbidden_message = saved_message;\n \n       /* If ok so far, parse the dependent expression. We cannot be\n-         sure it is a cast. Consider `(T ())'.  It is a parenthesized\n-         ctor of T, but looks like a cast to function returning T\n-         without a dependent expression.  */\n+\t sure it is a cast. Consider `(T ())'.  It is a parenthesized\n+\t ctor of T, but looks like a cast to function returning T\n+\t without a dependent expression.  */\n       if (!cp_parser_error_occurred (parser))\n \texpr = cp_parser_cast_expression (parser,\n \t\t\t\t\t  /*address_p=*/false,\n@@ -5524,19 +5524,19 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p)\n       new_prec = TOKEN_PRECEDENCE (token);\n \n       /* Popping an entry off the stack means we completed a subexpression:\n-         - either we found a token which is not an operator (`>' where it is not\n-           an operator, or prec == PREC_NOT_OPERATOR), in which case popping\n-           will happen repeatedly;\n-         - or, we found an operator which has lower priority.  This is the case\n-           where the recursive descent *ascends*, as in `3 * 4 + 5' after\n-           parsing `3 * 4'.  */\n+\t - either we found a token which is not an operator (`>' where it is not\n+\t   an operator, or prec == PREC_NOT_OPERATOR), in which case popping\n+\t   will happen repeatedly;\n+\t - or, we found an operator which has lower priority.  This is the case\n+\t   where the recursive descent *ascends*, as in `3 * 4 + 5' after\n+\t   parsing `3 * 4'.  */\n       if (new_prec <= prec)\n-        {\n-          if (sp == stack)\n+\t{\n+\t  if (sp == stack)\n \t    break;\n-          else\n+\t  else\n \t    goto pop;\n-        }\n+\t}\n \n      get_rhs:\n       tree_type = binops_by_token[token->type].tree_type;\n@@ -5545,57 +5545,57 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p)\n       cp_lexer_consume_token (parser->lexer);\n \n       /* Extract another operand.  It may be the RHS of this expression\n-         or the LHS of a new, higher priority expression.  */\n+\t or the LHS of a new, higher priority expression.  */\n       rhs = cp_parser_simple_cast_expression (parser);\n \n       /* Get another operator token.  Look up its precedence to avoid\n-         building a useless (immediately popped) stack entry for common\n-         cases such as 3 + 4 + 5 or 3 * 4 + 5.  */\n+\t building a useless (immediately popped) stack entry for common\n+\t cases such as 3 + 4 + 5 or 3 * 4 + 5.  */\n       token = cp_lexer_peek_token (parser->lexer);\n       lookahead_prec = TOKEN_PRECEDENCE (token);\n       if (lookahead_prec > new_prec)\n-        {\n-          /* ... and prepare to parse the RHS of the new, higher priority\n-             expression.  Since precedence levels on the stack are\n+\t{\n+\t  /* ... and prepare to parse the RHS of the new, higher priority\n+\t     expression.  Since precedence levels on the stack are\n \t     monotonically increasing, we do not have to care about\n \t     stack overflows.  */\n-          sp->prec = prec;\n-          sp->tree_type = tree_type;\n-          sp->lhs = lhs;\n-          sp++;\n-          lhs = rhs;\n-          prec = new_prec;\n-          new_prec = lookahead_prec;\n-          goto get_rhs;\n-\n-         pop:\n-          /* If the stack is not empty, we have parsed into LHS the right side\n+\t  sp->prec = prec;\n+\t  sp->tree_type = tree_type;\n+\t  sp->lhs = lhs;\n+\t  sp++;\n+\t  lhs = rhs;\n+\t  prec = new_prec;\n+\t  new_prec = lookahead_prec;\n+\t  goto get_rhs;\n+\n+\t pop:\n+\t  /* If the stack is not empty, we have parsed into LHS the right side\n \t     (`4' in the example above) of an expression we had suspended.\n \t     We can use the information on the stack to recover the LHS (`3')\n \t     from the stack together with the tree code (`MULT_EXPR'), and\n \t     the precedence of the higher level subexpression\n \t     (`PREC_ADDITIVE_EXPRESSION').  TOKEN is the CPP_PLUS token,\n \t     which will be used to actually build the additive expression.  */\n-          --sp;\n+\t  --sp;\n \t  prec = sp->prec;\n-          tree_type = sp->tree_type;\n-          rhs = lhs;\n-          lhs = sp->lhs;\n-        }\n+\t  tree_type = sp->tree_type;\n+\t  rhs = lhs;\n+\t  lhs = sp->lhs;\n+\t}\n \n       overloaded_p = false;\n       lhs = build_x_binary_op (tree_type, lhs, rhs, &overloaded_p);\n \n       /* If the binary operator required the use of an overloaded operator,\n-         then this expression cannot be an integral constant-expression.\n-         An overloaded operator can be used even if both operands are\n-         otherwise permissible in an integral constant-expression if at\n-         least one of the operands is of enumeration type.  */\n+\t then this expression cannot be an integral constant-expression.\n+\t An overloaded operator can be used even if both operands are\n+\t otherwise permissible in an integral constant-expression if at\n+\t least one of the operands is of enumeration type.  */\n \n       if (overloaded_p\n-          && (cp_parser_non_integral_constant_expression\n-              (parser, \"calls to overloaded operators\")))\n-        return error_mark_node;\n+\t  && (cp_parser_non_integral_constant_expression\n+\t      (parser, \"calls to overloaded operators\")))\n+\treturn error_mark_node;\n     }\n \n   return lhs;\n@@ -6165,11 +6165,11 @@ cp_parser_labeled_statement (cp_parser* parser, tree in_statement_expr)\n \tellipsis = cp_lexer_peek_token (parser->lexer);\n \tif (ellipsis->type == CPP_ELLIPSIS)\n \t  {\n-            /* Consume the `...' token.  */\n+\t    /* Consume the `...' token.  */\n \t    cp_lexer_consume_token (parser->lexer);\n \t    expr_hi =\n \t      cp_parser_constant_expression (parser,\n-\t    \t\t\t\t     /*allow_non_constant_p=*/false,\n+\t\t\t\t\t     /*allow_non_constant_p=*/false,\n \t\t\t\t\t     NULL);\n \t    /* We don't need to emit warnings here, as the common code\n \t       will do this for us.  */\n@@ -7074,7 +7074,7 @@ cp_parser_block_declaration (cp_parser *parser,\n \n static void\n cp_parser_simple_declaration (cp_parser* parser,\n-                              bool function_definition_allowed_p)\n+\t\t\t      bool function_definition_allowed_p)\n {\n   cp_decl_specifier_seq decl_specifiers;\n   int declares_class_or_enum;\n@@ -7203,9 +7203,9 @@ cp_parser_simple_declaration (cp_parser* parser,\n       /* After the first time around, a function-definition is not\n \t allowed -- even if it was OK at first.  For example:\n \n-           int i, f() {}\n+\t   int i, f() {}\n \n-         is not valid.  */\n+\t is not valid.  */\n       function_definition_allowed_p = false;\n     }\n \n@@ -7252,9 +7252,9 @@ cp_parser_simple_declaration (cp_parser* parser,\n    flags:\n \n      1: one of the decl-specifiers is an elaborated-type-specifier\n-        (i.e., a type declaration)\n+\t(i.e., a type declaration)\n      2: one of the decl-specifiers is an enum-specifier or a\n-        class-specifier (i.e., a type definition)\n+\tclass-specifier (i.e., a type definition)\n \n    */\n \n@@ -7335,7 +7335,7 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t       extern\n \t       mutable\n \n-             GNU Extension:\n+\t     GNU Extension:\n \t       thread  */\n \tcase RID_AUTO:\n \t  /* Consume the token.  */\n@@ -7641,7 +7641,7 @@ cp_parser_conversion_function_id (cp_parser* parser)\n      conversion-type-id.  For example, consider:\n \n        struct S {\n-         typedef int I;\n+\t typedef int I;\n \t operator I();\n        };\n \n@@ -7693,7 +7693,7 @@ cp_parser_conversion_type_id (cp_parser* parser)\n   declarator = cp_parser_conversion_declarator_opt (parser);\n \n   type_specified =  grokdeclarator (declarator, &type_specifiers, TYPENAME,\n-\t\t\t            /*initialized=*/0, &attributes);\n+\t\t\t\t    /*initialized=*/0, &attributes);\n   if (attributes)\n     cplus_decl_attributes (&type_specified, attributes, /*flags=*/0);\n   return type_specified;\n@@ -8397,7 +8397,7 @@ cp_parser_type_parameter (cp_parser* parser)\n \ttree default_argument;\n \n \t/* If the next token is an identifier, then it names the\n-           parameter.  */\n+\t   parameter.  */\n \tif (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n \t  identifier = cp_parser_identifier (parser);\n \telse\n@@ -8599,7 +8599,7 @@ cp_parser_template_id (cp_parser *parser,\n       /* Change `:' into `::'.  */\n       next_token_2->type = CPP_SCOPE;\n       /* Consume the first token (CPP_OPEN_SQUARE - which we pretend it is\n-         CPP_LESS.  */\n+\t CPP_LESS.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* Parse the arguments.  */\n       arguments = cp_parser_enclosed_template_argument_list (parser);\n@@ -8614,7 +8614,7 @@ cp_parser_template_id (cp_parser *parser,\n \t  return error_mark_node;\n \t}\n       /* Otherwise, emit an error about the invalid digraph, but continue\n-         parsing because we got our argument list.  */\n+\t parsing because we got our argument list.  */\n       pedwarn (\"%<<::%> cannot begin a template-argument list\");\n       inform (\"%<<:%> is an alternate spelling for %<[%>. Insert whitespace \"\n \t      \"between %<<%> and %<::%>\");\n@@ -8733,8 +8733,8 @@ cp_parser_template_id (cp_parser *parser,\n \n static tree\n cp_parser_template_name (cp_parser* parser,\n-                         bool template_keyword_p,\n-                         bool check_dependency_p,\n+\t\t\t bool template_keyword_p,\n+\t\t\t bool check_dependency_p,\n \t\t\t bool is_declaration,\n \t\t\t bool *is_identifier)\n {\n@@ -8753,10 +8753,10 @@ cp_parser_template_name (cp_parser* parser,\n       identifier = cp_parser_operator_function_id (parser);\n       /* If that didn't work, try a conversion-function-id.  */\n       if (!cp_parser_parse_definitely (parser))\n-        {\n+\t{\n \t  cp_parser_error (parser, \"expected template-name\");\n \t  return error_mark_node;\n-        }\n+\t}\n     }\n   /* Look for the identifier.  */\n   else\n@@ -9045,7 +9045,7 @@ cp_parser_template_argument (cp_parser* parser)\n      in [temp.arg.nontype]:\n \n      -- an integral constant-expression of integral or enumeration\n-        type; or\n+\ttype; or\n \n      -- the name of a non-type template-parameter; or\n \n@@ -9386,7 +9386,7 @@ cp_parser_type_specifier (cp_parser* parser,\n       if (cp_lexer_peek_nth_token (parser->lexer, 2)->type == CPP_OPEN_BRACE\n \t  || (cp_lexer_peek_nth_token (parser->lexer, 2)->type == CPP_NAME\n \t      && cp_lexer_peek_nth_token (parser->lexer, 3)->type\n-\t         == CPP_OPEN_BRACE))\n+\t\t == CPP_OPEN_BRACE))\n \t{\n \t  if (parser->num_template_parameter_lists)\n \t    {\n@@ -9823,7 +9823,7 @@ cp_parser_type_name (cp_parser* parser)\n    elaborated-type-specifier:\n      class-key attributes :: [opt] nested-name-specifier [opt] identifier\n      class-key attributes :: [opt] nested-name-specifier [opt]\n-               template [opt] template-id\n+\t       template [opt] template-id\n      enum attributes :: [opt] nested-name-specifier [opt] identifier\n \n    If IS_FRIEND is TRUE, then this elaborated-type-specifier is being\n@@ -9835,8 +9835,8 @@ cp_parser_type_name (cp_parser* parser)\n \n static tree\n cp_parser_elaborated_type_specifier (cp_parser* parser,\n-                                     bool is_friend,\n-                                     bool is_declaration)\n+\t\t\t\t     bool is_friend,\n+\t\t\t\t     bool is_declaration)\n {\n   enum tag_types tag_type;\n   tree identifier;\n@@ -9906,15 +9906,15 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n       /* Allow the `template' keyword.  */\n       template_p = cp_parser_optional_template_keyword (parser);\n       /* If we didn't see `template', we don't know if there's a\n-         template-id or not.  */\n+\t template-id or not.  */\n       if (!template_p)\n \tcp_parser_parse_tentatively (parser);\n       /* Parse the template-id.  */\n       decl = cp_parser_template_id (parser, template_p,\n \t\t\t\t    /*check_dependency_p=*/true,\n \t\t\t\t    is_declaration);\n       /* If we didn't find a template-id, look for an ordinary\n-         identifier.  */\n+\t identifier.  */\n       if (!template_p && !cp_parser_parse_definitely (parser))\n \t;\n       /* If DECL is a TEMPLATE_ID_EXPR, and the `typename' keyword is\n@@ -10055,8 +10055,8 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t  else\n \t    ts = ts_global;\n \n- \t  /* Warn about attributes. They are ignored.  */\n- \t  if (attributes)\n+\t  /* Warn about attributes. They are ignored.  */\n+\t  if (attributes)\n \t    warning (OPT_Wattributes,\n \t\t     \"type attributes are honored only at type definition\");\n \n@@ -10511,10 +10511,10 @@ cp_parser_using_directive (cp_parser* parser)\n      asm volatile [opt] ( string-literal ) ;\n      asm volatile [opt] ( string-literal : asm-operand-list [opt] ) ;\n      asm volatile [opt] ( string-literal : asm-operand-list [opt]\n-                          : asm-operand-list [opt] ) ;\n+\t\t\t  : asm-operand-list [opt] ) ;\n      asm volatile [opt] ( string-literal : asm-operand-list [opt]\n-                          : asm-operand-list [opt]\n-                          : asm-operand-list [opt] ) ;  */\n+\t\t\t  : asm-operand-list [opt]\n+\t\t\t  : asm-operand-list [opt] ) ;  */\n \n static void\n cp_parser_asm_definition (cp_parser* parser)\n@@ -10989,8 +10989,8 @@ cp_parser_init_declarator (cp_parser* parser,\n \n static cp_declarator *\n cp_parser_declarator (cp_parser* parser,\n-                      cp_parser_declarator_kind dcl_kind,\n-                      int* ctor_dtor_or_conv_p,\n+\t\t      cp_parser_declarator_kind dcl_kind,\n+\t\t      int* ctor_dtor_or_conv_p,\n \t\t      bool* parenthesized_p,\n \t\t      bool member_p)\n {\n@@ -11098,8 +11098,8 @@ cp_parser_declarator (cp_parser* parser,\n \n static cp_declarator *\n cp_parser_direct_declarator (cp_parser* parser,\n-                             cp_parser_declarator_kind dcl_kind,\n-                             int* ctor_dtor_or_conv_p,\n+\t\t\t     cp_parser_declarator_kind dcl_kind,\n+\t\t\t     int* ctor_dtor_or_conv_p,\n \t\t\t     bool member_p)\n {\n   cp_token *token;\n@@ -11117,15 +11117,15 @@ cp_parser_direct_declarator (cp_parser* parser,\n       if (token->type == CPP_OPEN_PAREN)\n \t{\n \t  /* This is either a parameter-declaration-clause, or a\n-  \t     parenthesized declarator. When we know we are parsing a\n-  \t     named declarator, it must be a parenthesized declarator\n-  \t     if FIRST is true. For instance, `(int)' is a\n-  \t     parameter-declaration-clause, with an omitted\n-  \t     direct-abstract-declarator. But `((*))', is a\n-  \t     parenthesized abstract declarator. Finally, when T is a\n-  \t     template parameter `(T)' is a\n-  \t     parameter-declaration-clause, and not a parenthesized\n-  \t     named declarator.\n+\t     parenthesized declarator. When we know we are parsing a\n+\t     named declarator, it must be a parenthesized declarator\n+\t     if FIRST is true. For instance, `(int)' is a\n+\t     parameter-declaration-clause, with an omitted\n+\t     direct-abstract-declarator. But `((*))', is a\n+\t     parenthesized abstract declarator. Finally, when T is a\n+\t     template parameter `(T)' is a\n+\t     parameter-declaration-clause, and not a parenthesized\n+\t     named declarator.\n \n \t     We first try and parse a parameter-declaration-clause,\n \t     and then try a nested declarator (if FIRST is true).\n@@ -11145,7 +11145,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t     these two alternatives should be selected.  Even more\n \t     complex are examples like:\n \n-               int i (int (a));\n+\t       int i (int (a));\n \t       int i (int (3));\n \n \t     The former is a function-declaration; the latter is a\n@@ -11191,7 +11191,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t= saved_num_template_parameter_lists;\n \n \t      /* If all went well, parse the cv-qualifier-seq and the\n-\t     \t exception-specification.  */\n+\t\t exception-specification.  */\n \t      if (member_p || cp_parser_parse_definitely (parser))\n \t\t{\n \t\t  cp_cv_quals cv_quals;\n@@ -11215,8 +11215,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t\t\t\t\t     cv_quals,\n \t\t\t\t\t\t     exception_specification);\n \t\t  /* Any subsequent parameter lists are to do with\n-\t \t     return type, so are not those of the declared\n-\t \t     function.  */\n+\t\t     return type, so are not those of the declared\n+\t\t     function.  */\n \t\t  parser->default_arg_ok_p = false;\n \n \t\t  /* Repeat the main loop.  */\n@@ -11337,21 +11337,21 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      && TREE_CODE (qualifying_scope) == TYPENAME_TYPE)\n \t    {\n \t      /* In the declaration of a member of a template class\n-\t     \t outside of the class itself, the SCOPE will sometimes\n-\t     \t be a TYPENAME_TYPE.  For example, given:\n+\t\t outside of the class itself, the SCOPE will sometimes\n+\t\t be a TYPENAME_TYPE.  For example, given:\n \n-               \t template <typename T>\n-\t       \t int S<T>::R::i = 3;\n+\t\t template <typename T>\n+\t\t int S<T>::R::i = 3;\n \n-             \t the SCOPE will be a TYPENAME_TYPE for `S<T>::R'.  In\n-             \t this context, we must resolve S<T>::R to an ordinary\n-             \t type, rather than a typename type.\n+\t\t the SCOPE will be a TYPENAME_TYPE for `S<T>::R'.  In\n+\t\t this context, we must resolve S<T>::R to an ordinary\n+\t\t type, rather than a typename type.\n \n-\t     \t The reason we normally avoid resolving TYPENAME_TYPEs\n-\t     \t is that a specialization of `S' might render\n-\t     \t `S<T>::R' not a type.  However, if `S' is\n-\t     \t specialized, then this `i' will not be used, so there\n-\t     \t is no harm in resolving the types here.  */\n+\t\t The reason we normally avoid resolving TYPENAME_TYPEs\n+\t\t is that a specialization of `S' might render\n+\t\t `S<T>::R' not a type.  However, if `S' is\n+\t\t specialized, then this `i' will not be used, so there\n+\t\t is no harm in resolving the types here.  */\n \t      tree type;\n \n \t      /* Resolve the TYPENAME_TYPE.  */\n@@ -11404,8 +11404,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t    {\n \t\t      error (\"invalid use of constructor as a template\");\n \t\t      inform (\"use %<%T::%D%> instead of %<%T::%T%> to name \"\n-                              \"the constructor in a qualified name\",\n-                              class_type,\n+\t\t\t      \"the constructor in a qualified name\",\n+\t\t\t      class_type,\n \t\t\t      DECL_NAME (TYPE_TI_TEMPLATE (class_type)),\n \t\t\t      class_type, class_type);\n \t\t    }\n@@ -11470,7 +11470,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \n static enum tree_code\n cp_parser_ptr_operator (cp_parser* parser,\n-                        tree* type,\n+\t\t\ttree* type,\n \t\t\tcp_cv_quals *cv_quals)\n {\n   enum tree_code code = ERROR_MARK;\n@@ -11740,20 +11740,20 @@ cp_parser_type_specifier_seq (cp_parser* parser,\n       seen_type_specifier = true;\n       /* The standard says that a condition can be:\n \n-            type-specifier-seq declarator = assignment-expression\n+\t    type-specifier-seq declarator = assignment-expression\n \n \t However, given:\n \n \t   struct S {};\n \t   if (int S = ...)\n \n-         we should treat the \"S\" as a declarator, not as a\n-         type-specifier.  The standard doesn't say that explicitly for\n-         type-specifier-seq, but it does say that for\n-         decl-specifier-seq in an ordinary declaration.  Perhaps it\n-         would be clearer just to allow a decl-specifier-seq here, and\n-         then add a semantic restriction that if any decl-specifiers\n-         that are not type-specifiers appear, the program is invalid.  */\n+\t we should treat the \"S\" as a declarator, not as a\n+\t type-specifier.  The standard doesn't say that explicitly for\n+\t type-specifier-seq, but it does say that for\n+\t decl-specifier-seq in an ordinary declaration.  Perhaps it\n+\t would be clearer just to allow a decl-specifier-seq here, and\n+\t then add a semantic restriction that if any decl-specifiers\n+\t that are not type-specifiers appear, the program is invalid.  */\n       if (is_condition && !is_cv_qualifier)\n \tflags |= CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES;\n     }\n@@ -11913,9 +11913,9 @@ cp_parser_parameter_declaration_list (cp_parser* parser, bool *is_error)\n \t  cp_lexer_consume_token (parser->lexer);\n \t  /* When parsing something like:\n \n-\t        int i(float f, double d)\n+\t\tint i(float f, double d)\n \n-             we can tell after seeing the declaration for \"f\" that we\n+\t     we can tell after seeing the declaration for \"f\" that we\n \t     are not looking at an initialization of a variable \"i\",\n \t     but rather at the declaration of a function \"i\".\n \n@@ -12151,14 +12151,14 @@ cp_parser_parameter_declaration (cp_parser *parser,\n \t    }\n \n \t  /* Create a DEFAULT_ARG to represented the unparsed default\n-             argument.  */\n+\t     argument.  */\n \t  default_argument = make_node (DEFAULT_ARG);\n \t  DEFARG_TOKENS (default_argument)\n \t    = cp_token_cache_new (first_token, token);\n \t  DEFARG_INSTANTIATIONS (default_argument) = NULL;\n \t}\n       /* Outside of a class definition, we can just parse the\n-         assignment-expression.  */\n+\t assignment-expression.  */\n       else\n \t{\n \t  bool saved_local_variables_forbidden_p;\n@@ -12650,7 +12650,7 @@ cp_parser_class_specifier (cp_parser* parser)\n      class-specifier for that class.  Consider:\n \n        struct A {\n-         struct B { void f() { sizeof (A); } };\n+\t struct B { void f() { sizeof (A); } };\n        };\n \n      If `f' were processed before the processing of `A' were\n@@ -12675,11 +12675,11 @@ cp_parser_class_specifier (cp_parser* parser)\n \t This two-phased approach handles cases like:\n \n \t    struct S {\n-              void f() { g(); }\n-              void g(int i = 3);\n-            };\n+\t      void f() { g(); }\n+\t      void g(int i = 3);\n+\t    };\n \n-         */\n+\t */\n       for (TREE_PURPOSE (parser->unparsed_functions_queues)\n \t     = nreverse (TREE_PURPOSE (parser->unparsed_functions_queues));\n \t   (queue_entry = TREE_PURPOSE (parser->unparsed_functions_queues));\n@@ -12826,10 +12826,10 @@ cp_parser_class_head (cp_parser* parser,\n \n \t It is OK to define an inaccessible class; for example:\n \n-           class A { class B; };\n-           class A::B {};\n+\t   class A { class B; };\n+\t   class A::B {};\n \n-         We do not know if we will see a class-name, or a\n+\t We do not know if we will see a class-name, or a\n \t template-name.  We look for a class-name first, in case the\n \t class-name is a template-id; if we looked for the\n \t template-name first we would stop after the template-name.  */\n@@ -12942,13 +12942,13 @@ cp_parser_class_head (cp_parser* parser,\n       if (scope && !is_ancestor (scope, nested_name_specifier))\n \t{\n \t  error (\"declaration of %qD in %qD which does not enclose %qD\",\n-                 type, scope, nested_name_specifier);\n+\t\t type, scope, nested_name_specifier);\n \t  type = NULL_TREE;\n \t  goto done;\n \t}\n       /* [dcl.meaning]\n \n-         A declarator-id shall not be qualified exception of the\n+\t A declarator-id shall not be qualified exception of the\n \t definition of a ... nested class outside of its class\n \t ... [or] a the definition or explicit instantiation of a\n \t class member of a namespace outside of its namespace.  */\n@@ -13306,8 +13306,8 @@ cp_parser_member_declaration (cp_parser* parser)\n \t       /* In this case:\n \n \t\t    template <typename T> struct A {\n-                      friend struct A<T>::B;\n-                    };\n+\t\t      friend struct A<T>::B;\n+\t\t    };\n \n \t\t  A<T>::B will be represented by a TYPENAME_TYPE, and\n \t\t  therefore not recognized by check_tag_decl.  */\n@@ -14679,7 +14679,7 @@ cp_parser_maybe_treat_template_as_class (tree decl, bool tag_name_p)\n      the translation from TEMPLATE_DECL to TYPE_DECL occurs:\n \n        struct A {\n-         template <typename T> struct B;\n+\t template <typename T> struct B;\n        };\n \n        template <typename T> struct A::B {};\n@@ -14689,7 +14689,7 @@ cp_parser_maybe_treat_template_as_class (tree decl, bool tag_name_p)\n        namespace N { struct X{}; }\n \n        struct A {\n-         template <typename T> friend struct N::X;\n+\t template <typename T> friend struct N::X;\n        };\n \n      However, if the DECL refers to a class type, and we are in\n@@ -14698,7 +14698,7 @@ cp_parser_maybe_treat_template_as_class (tree decl, bool tag_name_p)\n      than a TEMPLATE_DECL.  For example, in:\n \n        template <class T> struct S {\n-         S s;\n+\t S s;\n        };\n \n      there is no need to handle such case.  */\n@@ -14786,7 +14786,7 @@ cp_parser_check_declarator_template_parameters (cp_parser* parser,\n \n static bool\n cp_parser_check_template_parameters (cp_parser* parser,\n-                                     unsigned num_templates)\n+\t\t\t\t     unsigned num_templates)\n {\n   /* If there are more template classes than parameter lists, we have\n      something like:\n@@ -15158,7 +15158,7 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n   else\n     {\n       /* There are no access checks when parsing a template, as we do not\n-         know if a specialization will be a friend.  */\n+\t know if a specialization will be a friend.  */\n       push_deferring_access_checks (dk_no_check);\n \n       decl = cp_parser_single_declaration (parser,\n@@ -15831,8 +15831,8 @@ cp_parser_friend_p (const cp_decl_specifier_seq *decl_specifiers)\n \n static cp_token *\n cp_parser_require (cp_parser* parser,\n-                   enum cpp_ttype type,\n-                   const char* token_desc)\n+\t\t   enum cpp_ttype type,\n+\t\t   const char* token_desc)\n {\n   if (cp_lexer_next_token_is (parser->lexer, type))\n     return cp_lexer_consume_token (parser->lexer);\n@@ -15855,8 +15855,8 @@ cp_parser_require (cp_parser* parser,\n \n static void\n cp_parser_skip_until_found (cp_parser* parser,\n-                            enum cpp_ttype type,\n-                            const char* token_desc)\n+\t\t\t    enum cpp_ttype type,\n+\t\t\t    const char* token_desc)\n {\n   cp_token *token;\n   unsigned nesting_depth = 0;\n@@ -15903,8 +15903,8 @@ cp_parser_skip_until_found (cp_parser* parser,\n \n static cp_token *\n cp_parser_require_keyword (cp_parser* parser,\n-                           enum rid keyword,\n-                           const char* token_desc)\n+\t\t\t   enum rid keyword,\n+\t\t\t   const char* token_desc)\n {\n   cp_token *token = cp_parser_require (parser, CPP_KEYWORD, token_desc);\n \n@@ -16669,7 +16669,7 @@ cp_parser_objc_protocol_qualifiers (cp_parser* parser)\n \t     || node == ridpointers [(int) RID_OUT]\n \t     || node == ridpointers [(int) RID_INOUT]\n \t     || node == ridpointers [(int) RID_BYCOPY]\n-             || node == ridpointers [(int) RID_BYREF]\n+\t     || node == ridpointers [(int) RID_BYREF]\n \t     || node == ridpointers [(int) RID_ONEWAY]))\n     {\n       quals = tree_cons (NULL_TREE, node, quals);"}, {"sha": "f130859d3c5892c2f795b7da9e84990bd92eb441", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 292, "deletions": 292, "changes": 584, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -350,7 +350,7 @@ push_inline_template_parms_recursive (tree parmlist, int levels)\n   TEMPLATE_PARMS_FOR_INLINE (current_template_parms) = 1;\n \n   begin_scope (TREE_VEC_LENGTH (parms) ? sk_template_parms : sk_template_spec,\n-               NULL);\n+\t       NULL);\n   for (i = 0; i < TREE_VEC_LENGTH (parms); ++i)\n     {\n       tree parm = TREE_VALUE (TREE_VEC_ELT (parms, i));\n@@ -542,7 +542,7 @@ begin_template_parm_list (void)\n      e.g.:\n \n        template <class T> struct S1 {\n-         template <class T> struct S2 {};\n+\t template <class T> struct S2 {};\n        };\n \n      pushtag contains special code to call pushdecl_with_scope on the\n@@ -1133,7 +1133,7 @@ register_specialization (tree spec, tree tmpl, tree args)\n        with default function arguments.  In particular, given\n        something like this:\n \n-          template <class T> void f(T t1, T t = T())\n+\t  template <class T> void f(T t1, T t = T())\n \n        the default argument expression is not substituted for in an\n        instantiation unless and until it is actually needed.  */\n@@ -1315,8 +1315,8 @@ print_candidates (tree fns)\n \n static tree\n determine_specialization (tree template_id,\n-                          tree decl,\n-                          tree* targs_out,\n+\t\t\t  tree decl,\n+\t\t\t  tree* targs_out,\n \t\t\t  int need_member_template,\n \t\t\t  int template_count)\n {\n@@ -1518,7 +1518,7 @@ determine_specialization (tree template_id,\n \t   the function template to which a function template\n \t   specialization refers:\n \n-           -- when an explicit specialization refers to a function\n+\t   -- when an explicit specialization refers to a function\n \t      template.\n \n \t So, we do use the partial ordering rules, at least for now.\n@@ -1539,7 +1539,7 @@ determine_specialization (tree template_id,\n   if (templates == NULL_TREE && candidates == NULL_TREE)\n     {\n       cp_error_at (\"template-id %qD for %q+D does not match any template \"\n-                   \"declaration\",\n+\t\t   \"declaration\",\n \t\t   template_id, decl);\n       return error_mark_node;\n     }\n@@ -1644,16 +1644,16 @@ copy_default_args_to_explicit_spec (tree decl)\n   if (DECL_NONSTATIC_MEMBER_FUNCTION_P (decl))\n     {\n       /* Remove the this pointer, but remember the object's type for\n-         CV quals.  */\n+\t CV quals.  */\n       object_type = TREE_TYPE (TREE_VALUE (spec_types));\n       spec_types = TREE_CHAIN (spec_types);\n       tmpl_types = TREE_CHAIN (tmpl_types);\n \n       if (DECL_HAS_IN_CHARGE_PARM_P (decl))\n-        {\n-          /* DECL may contain more parameters than TMPL due to the extra\n-             in-charge parameter in constructors and destructors.  */\n-          in_charge = spec_types;\n+\t{\n+\t  /* DECL may contain more parameters than TMPL due to the extra\n+\t     in-charge parameter in constructors and destructors.  */\n+\t  in_charge = spec_types;\n \t  spec_types = TREE_CHAIN (spec_types);\n \t}\n       if (DECL_HAS_VTT_PARM_P (decl))\n@@ -1671,15 +1671,15 @@ copy_default_args_to_explicit_spec (tree decl)\n   if (object_type)\n     {\n       if (vtt)\n-        new_spec_types = hash_tree_cons (TREE_PURPOSE (vtt),\n-\t\t\t  \t         TREE_VALUE (vtt),\n-\t\t\t\t         new_spec_types);\n+\tnew_spec_types = hash_tree_cons (TREE_PURPOSE (vtt),\n+\t\t\t\t\t TREE_VALUE (vtt),\n+\t\t\t\t\t new_spec_types);\n \n       if (in_charge)\n-        /* Put the in-charge parameter back.  */\n-        new_spec_types = hash_tree_cons (TREE_PURPOSE (in_charge),\n-\t\t\t  \t         TREE_VALUE (in_charge),\n-\t\t\t\t         new_spec_types);\n+\t/* Put the in-charge parameter back.  */\n+\tnew_spec_types = hash_tree_cons (TREE_PURPOSE (in_charge),\n+\t\t\t\t\t TREE_VALUE (in_charge),\n+\t\t\t\t\t new_spec_types);\n \n       new_type = build_method_type_directly (object_type,\n \t\t\t\t\t     TREE_TYPE (old_type),\n@@ -1734,9 +1734,9 @@ copy_default_args_to_explicit_spec (tree decl)\n \n tree\n check_explicit_specialization (tree declarator,\n-                               tree decl,\n-                               int template_count,\n-                               int flags)\n+\t\t\t       tree decl,\n+\t\t\t       int template_count,\n+\t\t\t       int flags)\n {\n   int have_def = flags & 2;\n   int is_friend = flags & 4;\n@@ -1779,7 +1779,7 @@ check_explicit_specialization (tree declarator,\n \t\t template <class T> void f<int>(); */\n \n \t      error (\"template-id %qD in declaration of primary template\",\n-                     declarator);\n+\t\t     declarator);\n \t      return decl;\n \t    }\n \t}\n@@ -1805,7 +1805,7 @@ check_explicit_specialization (tree declarator,\n     case tsk_excessive_parms:\n     case tsk_insufficient_parms:\n       if (tsk == tsk_excessive_parms)\n-        error (\"too many template parameter lists in declaration of %qD\",\n+\terror (\"too many template parameter lists in declaration of %qD\",\n \t       decl);\n       else if (template_header_count)\n \terror(\"too few template parameter lists in declaration of %qD\", decl);\n@@ -1833,7 +1833,7 @@ check_explicit_specialization (tree declarator,\n \t\t   \"is not allowed\", declarator);\n \t  else\n \t    error (\"template-id %qD in declaration of primary template\",\n-                   declarator);\n+\t\t   declarator);\n \t  return decl;\n \t}\n \n@@ -1843,7 +1843,7 @@ check_explicit_specialization (tree declarator,\n \n \t     template <class T> struct S {\n \t       template <class U> void f (U);\n-             };\n+\t     };\n \t     template <> template <class U> void S<int>::f(U) {}\n \n \t   That's a specialization -- but of the entire template.  */\n@@ -1884,11 +1884,11 @@ check_explicit_specialization (tree declarator,\n \t  else\n \t    {\n \t      /* If there is no class context, the explicit instantiation\n-                 must be at namespace scope.  */\n+\t\t must be at namespace scope.  */\n \t      gcc_assert (DECL_NAMESPACE_SCOPE_P (decl));\n \n \t      /* Find the namespace binding, using the declaration\n-                 context.  */\n+\t\t context.  */\n \t      fns = namespace_binding (dname, CP_DECL_CONTEXT (decl));\n \t      if (!fns || !is_overloaded_fn (fns))\n \t\t{\n@@ -1915,7 +1915,7 @@ check_explicit_specialization (tree declarator,\n \t      /* It's not valid to write an explicit instantiation in\n \t\t class scope, e.g.:\n \n-\t           class C { template void f(); }\n+\t\t   class C { template void f(); }\n \n \t\t   This case is caught by the parser.  However, on\n \t\t   something like:\n@@ -2211,10 +2211,10 @@ check_template_shadow (tree decl)\n \n static tree\n build_template_parm_index (int index,\n-                           int level,\n-                           int orig_level,\n-                           tree decl,\n-                           tree type)\n+\t\t\t   int level,\n+\t\t\t   int orig_level,\n+\t\t\t   tree decl,\n+\t\t\t   tree type)\n {\n   tree t = make_node (TEMPLATE_PARM_INDEX);\n   TEMPLATE_PARM_IDX (t) = index;\n@@ -2311,7 +2311,7 @@ process_template_parm (tree list, tree next, bool is_non_type)\n       TREE_INVARIANT (parm) = 1;\n       TREE_READONLY (parm) = 1;\n       if (invalid_nontype_parm_type_p (TREE_TYPE (parm), 1))\n-        TREE_TYPE (parm) = void_type_node;\n+\tTREE_TYPE (parm) = void_type_node;\n       decl = build_decl (CONST_DECL, DECL_NAME (parm), TREE_TYPE (parm));\n       TREE_CONSTANT (decl) = 1;\n       TREE_INVARIANT (decl) = 1;\n@@ -2690,9 +2690,9 @@ process_partial_specialization (tree decl)\n \t\t\t&& tpd.arg_uses_template_parms [j])\n \t\t      {\n \t\t\terror (\"type %qT of template argument %qE depends \"\n-                               \"on template parameter(s)\",\n-                               type,\n-                               arg);\n+\t\t\t       \"on template parameter(s)\",\n+\t\t\t       type,\n+\t\t\t       arg);\n \t\t\tbreak;\n \t\t      }\n \t\t}\n@@ -2787,7 +2787,7 @@ check_default_tmpl_args (tree decl, tree parms, int is_primary, int is_partial)\n   if (TREE_CODE (decl) != TYPE_DECL || is_partial || !is_primary)\n     /* For an ordinary class template, default template arguments are\n        allowed at the innermost level, e.g.:\n-         template <class T = int>\n+\t template <class T = int>\n \t struct S {};\n        but, in a partial specialization, they're not allowed even\n        there, as we have in [temp.class.spec]:\n@@ -2817,8 +2817,8 @@ check_default_tmpl_args (tree decl, tree parms, int is_primary, int is_partial)\n        examine the parameters to the class itself.  On the one\n        hand, they will be checked when the class is defined, and,\n        on the other, default arguments are valid in things like:\n-         template <class T = double>\n-         struct S { template <class U> void f(U); };\n+\t template <class T = double>\n+\t struct S { template <class U> void f(U); };\n        Here the default argument for `S' has no bearing on the\n        declaration of `f'.  */\n     last_level_to_check = template_class_depth (current_class_type) + 1;\n@@ -2943,7 +2943,7 @@ push_template_decl_real (tree decl, int is_friend)\n \t    {\n \t      /* [temp.mem]\n \n-\t         A destructor shall not be a member template.  */\n+\t\t A destructor shall not be a member template.  */\n \t      error (\"destructor %qD declared as member template\", decl);\n \t      return error_mark_node;\n \t    }\n@@ -2956,7 +2956,7 @@ push_template_decl_real (tree decl, int is_friend)\n \t    {\n \t      /* [basic.stc.dynamic.allocation]\n \n-\t         An allocation function can be a function\n+\t\t An allocation function can be a function\n \t\t template. ... Template allocation functions shall\n \t\t have two or more parameters.  */\n \t      error (\"invalid template declaration of %qD\", decl);\n@@ -3089,7 +3089,7 @@ push_template_decl_real (tree decl, int is_friend)\n       if (TMPL_ARGS_DEPTH (args) != i)\n \t{\n \t  error (\"expected %d levels of template parms for %q#D, got %d\",\n-                 i, decl, TMPL_ARGS_DEPTH (args));\n+\t\t i, decl, TMPL_ARGS_DEPTH (args));\n \t}\n       else\n \tfor (current = decl; i > 0; --i, parms = TREE_CHAIN (parms))\n@@ -3101,15 +3101,15 @@ push_template_decl_real (tree decl, int is_friend)\n \t      {\n \t\tif (current == decl)\n \t\t  error (\"got %d template parameters for %q#D\",\n-                         TREE_VEC_LENGTH (a), decl);\n+\t\t\t TREE_VEC_LENGTH (a), decl);\n \t\telse\n \t\t  error (\"got %d template parameters for %q#T\",\n-                         TREE_VEC_LENGTH (a), current);\n+\t\t\t TREE_VEC_LENGTH (a), current);\n \t\terror (\"  but %d required\", TREE_VEC_LENGTH (t));\n \t      }\n \n \t    /* Perhaps we should also check that the parms are used in the\n-               appropriate qualifying scopes in the declarator?  */\n+\t       appropriate qualifying scopes in the declarator?  */\n \n \t    if (current == decl)\n \t      current = ctx;\n@@ -3546,7 +3546,7 @@ convert_nontype_argument (tree type, tree expr)\n       if (!real_lvalue_p (expr))\n \t{\n \t  error (\"%qE is not a valid template argument for type %qT \"\n-\t         \"because it is not a lvalue\", expr, type);\n+\t\t \"because it is not a lvalue\", expr, type);\n \t  return NULL_TREE;\n \t}\n \n@@ -3576,7 +3576,7 @@ convert_nontype_argument (tree type, tree expr)\n   else if (TYPE_PTRFN_P (type))\n     {\n       /* If the argument is a template-id, we might not have enough\n-         context information to decay the pointer.\n+\t context information to decay the pointer.\n \t ??? Why static5.C requires decay and subst1.C works fine\n \t even without it?  */\n       if (!type_unknown_p (expr_type))\n@@ -3684,10 +3684,10 @@ convert_nontype_argument (tree type, tree expr)\n \n static int\n coerce_template_template_parms (tree parm_parms,\n-                                tree arg_parms,\n-                                tsubst_flags_t complain,\n+\t\t\t\ttree arg_parms,\n+\t\t\t\ttsubst_flags_t complain,\n \t\t\t\ttree in_decl,\n-                                tree outer_args)\n+\t\t\t\ttree outer_args)\n {\n   int nparms, nargs, i;\n   tree parm, arg;\n@@ -3710,11 +3710,11 @@ coerce_template_template_parms (tree parm_parms,\n       arg = TREE_VALUE (TREE_VEC_ELT (arg_parms, i));\n \n       if (arg == NULL_TREE || arg == error_mark_node\n-          || parm == NULL_TREE || parm == error_mark_node)\n+\t  || parm == NULL_TREE || parm == error_mark_node)\n \treturn 0;\n \n       if (TREE_CODE (arg) != TREE_CODE (parm))\n-        return 0;\n+\treturn 0;\n \n       switch (TREE_CODE (parm))\n \t{\n@@ -3766,11 +3766,11 @@ coerce_template_template_parms (tree parm_parms,\n \n static tree\n convert_template_argument (tree parm,\n-                           tree arg,\n-                           tree args,\n-                           tsubst_flags_t complain,\n-                           int i,\n-                           tree in_decl)\n+\t\t\t   tree arg,\n+\t\t\t   tree args,\n+\t\t\t   tsubst_flags_t complain,\n+\t\t\t   int i,\n+\t\t\t   tree in_decl)\n {\n   tree val;\n   tree inner_args;\n@@ -3810,7 +3810,7 @@ convert_template_argument (tree parm,\n       && TREE_CODE (TREE_OPERAND (arg, 0)) == TEMPLATE_TYPE_PARM)\n     {\n       pedwarn (\"to refer to a type member of a template parameter, \"\n-               \"use %<typename %E%>\", arg);\n+\t       \"use %<typename %E%>\", arg);\n \n       arg = make_typename_type (TREE_OPERAND (arg, 0),\n \t\t\t\tTREE_OPERAND (arg, 1),\n@@ -3825,12 +3825,12 @@ convert_template_argument (tree parm,\n \t  if (complain & tf_error)\n \t    {\n \t      error (\"type/value mismatch at argument %d in template \"\n-                     \"parameter list for %qD\",\n-                     i + 1, in_decl);\n+\t\t     \"parameter list for %qD\",\n+\t\t     i + 1, in_decl);\n \t      if (is_type)\n \t\terror (\"  expected a constant of type %qT, got %qT\",\n-                       TREE_TYPE (parm),\n-                       (is_tmpl_type ? DECL_NAME (arg) : arg));\n+\t\t       TREE_TYPE (parm),\n+\t\t       (is_tmpl_type ? DECL_NAME (arg) : arg));\n \t      else if (requires_tmpl_type)\n \t\terror (\"  expected a class template, got %qE\", arg);\n \t      else\n@@ -3844,8 +3844,8 @@ convert_template_argument (tree parm,\n       if (in_decl && (complain & tf_error))\n \t{\n \t  error (\"type/value mismatch at argument %d in template \"\n-                 \"parameter list for %qD\",\n-                 i + 1, in_decl);\n+\t\t \"parameter list for %qD\",\n+\t\t i + 1, in_decl);\n \t  if (is_tmpl_type)\n \t    error (\"  expected a type, got %qT\", DECL_NAME (arg));\n \t  else\n@@ -3884,10 +3884,10 @@ convert_template_argument (tree parm,\n \t\t  if (in_decl && (complain & tf_error))\n \t\t    {\n \t\t      error (\"type/value mismatch at argument %d in \"\n-                             \"template parameter list for %qD\",\n-                             i + 1, in_decl);\n+\t\t\t     \"template parameter list for %qD\",\n+\t\t\t     i + 1, in_decl);\n \t\t      error (\"  expected a template of type %qD, got %qD\",\n-                             parm, arg);\n+\t\t\t     parm, arg);\n \t\t    }\n \n \t\t  val = error_mark_node;\n@@ -3902,7 +3902,7 @@ convert_template_argument (tree parm,\n       tree t = tsubst (TREE_TYPE (parm), args, complain, in_decl);\n \n       if (invalid_nontype_parm_type_p (t, complain))\n-        return error_mark_node;\n+\treturn error_mark_node;\n \n       if (!uses_template_parms (arg) && !uses_template_parms (t))\n \t/* We used to call digest_init here.  However, digest_init\n@@ -3940,8 +3940,8 @@ convert_template_argument (tree parm,\n \n static tree\n coerce_template_parms (tree parms,\n-                       tree args,\n-                       tree in_decl,\n+\t\t       tree args,\n+\t\t       tree in_decl,\n \t\t       tsubst_flags_t complain,\n \t\t       int require_all_arguments)\n {\n@@ -3962,7 +3962,7 @@ coerce_template_parms (tree parms,\n       if (complain & tf_error)\n \t{\n \t  error (\"wrong number of template arguments (%d, should be %d)\",\n-                 nargs, nparms);\n+\t\t nargs, nparms);\n \n \t  if (in_decl)\n \t    cp_error_at (\"provided for %qD\", in_decl);\n@@ -4097,12 +4097,12 @@ mangle_class_name_for_template (const char* name, tree parms, tree arglist)\n \t    {\n \t      /* Already substituted with real template.  Just output\n \t\t the template name here */\n-              tree context = DECL_CONTEXT (arg);\n-              if (context)\n-                {\n-                  /* The template may be defined in a namespace, or\n-                     may be a member template.  */\n-                  gcc_assert (TREE_CODE (context) == NAMESPACE_DECL\n+\t      tree context = DECL_CONTEXT (arg);\n+\t      if (context)\n+\t\t{\n+\t\t  /* The template may be defined in a namespace, or\n+\t\t     may be a member template.  */\n+\t\t  gcc_assert (TREE_CODE (context) == NAMESPACE_DECL\n \t\t\t      || CLASS_TYPE_P (context));\n \t\t  cat (decl_as_string (DECL_CONTEXT (arg),\n \t\t\t\t      TFF_PLAIN_IDENTIFIER));\n@@ -4277,11 +4277,11 @@ maybe_get_template_decl_from_type_decl (tree decl)\n \n tree\n lookup_template_class (tree d1,\n-                       tree arglist,\n-                       tree in_decl,\n-                       tree context,\n-                       int entering_scope,\n-                       tsubst_flags_t complain)\n+\t\t       tree arglist,\n+\t\t       tree in_decl,\n+\t\t       tree context,\n+\t\t       int entering_scope,\n+\t\t       tsubst_flags_t complain)\n {\n   tree template = NULL_TREE, parmlist;\n   tree t;\n@@ -4338,20 +4338,20 @@ lookup_template_class (tree d1,\n   if (! template)\n     {\n       if (complain & tf_error)\n-        error (\"%qT is not a template\", d1);\n+\terror (\"%qT is not a template\", d1);\n       POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n     }\n \n   if (TREE_CODE (template) != TEMPLATE_DECL\n-         /* Make sure it's a user visible template, if it was named by\n+\t /* Make sure it's a user visible template, if it was named by\n \t    the user.  */\n       || ((complain & tf_user) && !DECL_TEMPLATE_PARM_P (template)\n \t  && !PRIMARY_TEMPLATE_P (template)))\n     {\n       if (complain & tf_error)\n-        {\n-          error (\"non-template type %qT used as a template\", d1);\n-          if (in_decl)\n+\t{\n+\t  error (\"non-template type %qT used as a template\", d1);\n+\t  if (in_decl)\n \t    cp_error_at (\"for template declaration %qD\", in_decl);\n \t}\n       POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n@@ -4362,7 +4362,7 @@ lookup_template_class (tree d1,\n   if (DECL_TEMPLATE_TEMPLATE_PARM_P (template))\n     {\n       /* Create a new TEMPLATE_DECL and TEMPLATE_TEMPLATE_PARM node to store\n-         template arguments */\n+\t template arguments */\n \n       tree parm;\n       tree arglist2;\n@@ -4389,11 +4389,11 @@ lookup_template_class (tree d1,\n \targlist = add_to_template_args (current_template_args (), arglist);\n \n       arglist2 = coerce_template_parms (parmlist, arglist, template,\n-                                        complain, /*require_all_args=*/1);\n+\t\t\t\t\tcomplain, /*require_all_args=*/1);\n       if (arglist2 == error_mark_node\n \t  || (!uses_template_parms (arglist2)\n \t      && check_instantiated_args (template, arglist2, complain)))\n-        POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \n       parm = bind_template_template_parm (TREE_TYPE (template), arglist2);\n       POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, parm);\n@@ -4419,9 +4419,9 @@ lookup_template_class (tree d1,\n \t     For example, given:\n \n \t       template <class T> struct S1 {\n-\t         template <class U> struct S2 {};\n+\t\t template <class U> struct S2 {};\n \t\t template <class U> struct S2<U*> {};\n-\t        };\n+\t\t};\n \n \t     we will be called with an ARGLIST of `U*', but the\n \t     TEMPLATE will be `template <class T> template\n@@ -4458,7 +4458,7 @@ lookup_template_class (tree d1,\n \t    {\n \t      tree a = coerce_template_parms (TREE_VALUE (t),\n \t\t\t\t\t      arglist, template,\n-\t                                      complain, /*require_all_args=*/1);\n+\t\t\t\t\t      complain, /*require_all_args=*/1);\n \n \t      /* Don't process further if one of the levels fails.  */\n \t      if (a == error_mark_node)\n@@ -4487,7 +4487,7 @@ lookup_template_class (tree d1,\n \t  = coerce_template_parms (INNERMOST_TEMPLATE_PARMS (parmlist),\n \t\t\t\t   INNERMOST_TEMPLATE_ARGS (arglist),\n \t\t\t\t   template,\n-\t                           complain, /*require_all_args=*/1);\n+\t\t\t\t   complain, /*require_all_args=*/1);\n \n       if (arglist == error_mark_node)\n \t/* We were unable to bind the arguments.  */\n@@ -4525,7 +4525,7 @@ lookup_template_class (tree d1,\n \t    }\n \t}\n       if (found)\n-        POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, found);\n+\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, found);\n \n       /* If we already have this specialization, return it.  */\n       found = retrieve_specialization (template, arglist,\n@@ -4660,18 +4660,18 @@ lookup_template_class (tree d1,\n \t  if (!found)\n \t    {\n \t      /* There was no partial instantiation. This happens\n-                 where C<T> is a member template of A<T> and it's used\n-                 in something like\n+\t\t where C<T> is a member template of A<T> and it's used\n+\t\t in something like\n \n-                  template <typename T> struct B { A<T>::C<int> m; };\n-                  B<float>;\n+\t\t  template <typename T> struct B { A<T>::C<int> m; };\n+\t\t  B<float>;\n \n-                 Create the partial instantiation.\n-               */\n-              TREE_VEC_LENGTH (arglist)--;\n-              found = tsubst (template, arglist, complain, NULL_TREE);\n-              TREE_VEC_LENGTH (arglist)++;\n-            }\n+\t\t Create the partial instantiation.\n+\t       */\n+\t      TREE_VEC_LENGTH (arglist)--;\n+\t      found = tsubst (template, arglist, complain, NULL_TREE);\n+\t      TREE_VEC_LENGTH (arglist)++;\n+\t    }\n \t}\n \n       SET_TYPE_TEMPLATE_INFO (t, tree_cons (found, arglist, NULL_TREE));\n@@ -4989,13 +4989,13 @@ push_tinst_level (tree d)\n     {\n       /* If the instantiation in question still has unbound template parms,\n \t we don't really care if we can't instantiate it, so just return.\n-         This happens with base instantiation for implicit `typename'.  */\n+\t This happens with base instantiation for implicit `typename'.  */\n       if (uses_template_parms (d))\n \treturn 0;\n \n       last_template_error_tick = tinst_level_tick;\n       error (\"template instantiation depth exceeds maximum of %d (use \"\n-             \"-ftemplate-depth-NN to increase the maximum) instantiating %qD\",\n+\t     \"-ftemplate-depth-NN to increase the maximum) instantiating %qD\",\n \t     max_tinst_depth, d);\n \n       print_instantiation_context ();\n@@ -5082,14 +5082,14 @@ tsubst_friend_function (tree decl, tree args)\n       tree ns = decl_namespace_context (TYPE_MAIN_DECL (current_class_type));\n \n       /* Friend functions are looked up in the containing namespace scope.\n-         We must enter that scope, to avoid finding member functions of the\n-         current cless with same name.  */\n+\t We must enter that scope, to avoid finding member functions of the\n+\t current cless with same name.  */\n       push_nested_namespace (ns);\n       fns = tsubst_expr (DECL_TI_TEMPLATE (decl), args,\n-                         tf_error | tf_warning, NULL_TREE);\n+\t\t\t tf_error | tf_warning, NULL_TREE);\n       pop_nested_namespace (ns);\n       arglist = tsubst (DECL_TI_ARGS (decl), args,\n-                        tf_error | tf_warning, NULL_TREE);\n+\t\t\ttf_error | tf_warning, NULL_TREE);\n       template_id = lookup_template_function (fns, arglist);\n \n       new_friend = tsubst (decl, args, tf_error | tf_warning, NULL_TREE);\n@@ -5198,8 +5198,8 @@ tsubst_friend_function (tree decl, tree args)\n \n \t       friend void f(int);\n \t       template <class T> class C {\n-\t         friend void f(T) {}\n-               };\n+\t\t friend void f(T) {}\n+\t       };\n \n \t     when `C<int>' is instantiated.  Now, `f(int)' is defined\n \t     in the class.  */\n@@ -5367,7 +5367,7 @@ tsubst_friend_class (tree friend_tmpl, tree args)\n       tmpl = tsubst (friend_tmpl, args, tf_error | tf_warning, NULL_TREE);\n \n       /* The new TMPL is not an instantiation of anything, so we\n- \t forget its origins.  We don't reset CLASSTYPE_TI_TEMPLATE for\n+\t forget its origins.  We don't reset CLASSTYPE_TI_TEMPLATE for\n \t the new type because that is supposed to be the corresponding\n \t template decl, i.e., TMPL.  */\n       DECL_USE_TEMPLATE (tmpl) = 0;\n@@ -5711,7 +5711,7 @@ instantiate_class_template (tree type)\n \t\t      if (!COMPLETE_TYPE_P (rtype))\n \t\t\t{\n \t\t\t  cxx_incomplete_type_error (r, rtype);\n-\t\t  \t  r = error_mark_node;\n+\t\t\t  r = error_mark_node;\n \t\t\t}\n \t\t    }\n \n@@ -5726,7 +5726,7 @@ instantiate_class_template (tree type)\n \t\t      set_current_access_from_decl (r);\n \t\t      finish_member_declaration (r);\n \t\t    }\n-\t        }\n+\t\t}\n \t    }\n \t}\n       else\n@@ -5742,7 +5742,7 @@ instantiate_class_template (tree type)\n \t\t{\n \t\t  /* template <class T> friend class C;  */\n \t\t  friend_type = tsubst_friend_class (friend_type, args);\n-\t  \t  adjust_processing_template_decl = true;\n+\t\t  adjust_processing_template_decl = true;\n \t\t}\n \t      else if (TREE_CODE (friend_type) == UNBOUND_CLASS_TEMPLATE)\n \t\t{\n@@ -5751,7 +5751,7 @@ instantiate_class_template (tree type)\n \t\t\t\t\ttf_error | tf_warning, NULL_TREE);\n \t\t  if (TREE_CODE (friend_type) == TEMPLATE_DECL)\n \t\t    friend_type = TREE_TYPE (friend_type);\n-\t  \t  adjust_processing_template_decl = true;\n+\t\t  adjust_processing_template_decl = true;\n \t\t}\n \t      else if (TREE_CODE (friend_type) == TYPENAME_TYPE)\n \t\t{\n@@ -5803,7 +5803,7 @@ instantiate_class_template (tree type)\n \n \t\t   friend class C<int>;\n \n-\t         We don't have to do anything in these cases.  */\n+\t\t We don't have to do anything in these cases.  */\n \n \t      if (adjust_processing_template_decl)\n \t\t/* Trick make_friend_class into realizing that the friend\n@@ -5814,7 +5814,7 @@ instantiate_class_template (tree type)\n \t\t++processing_template_decl;\n \n \t      if (friend_type != error_mark_node)\n-\t        make_friend_class (type, friend_type, /*complain=*/false);\n+\t\tmake_friend_class (type, friend_type, /*complain=*/false);\n \n \t      if (adjust_processing_template_decl)\n \t\t--processing_template_decl;\n@@ -6016,10 +6016,10 @@ tsubst_template_parms (tree parms, tree args, tsubst_flags_t complain)\n \n static tree\n tsubst_aggr_type (tree t,\n-                  tree args,\n-                  tsubst_flags_t complain,\n-                  tree in_decl,\n-                  int entering_scope)\n+\t\t  tree args,\n+\t\t  tsubst_flags_t complain,\n+\t\t  tree in_decl,\n+\t\t  int entering_scope)\n {\n   if (t == NULL_TREE)\n     return NULL_TREE;\n@@ -6060,7 +6060,7 @@ tsubst_aggr_type (tree t,\n \t  if (argvec == error_mark_node)\n \t    return error_mark_node;\n \n-  \t  r = lookup_template_class (t, argvec, in_decl, context,\n+\t  r = lookup_template_class (t, argvec, in_decl, context,\n \t\t\t\t     entering_scope, complain);\n \n \t  return cp_build_qualified_type_real (r, TYPE_QUALS (t), complain);\n@@ -6332,7 +6332,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t       there was a specialization of a member template, like\n \t       this:\n \n-\t         template <class T> struct S { template <class U> void f(); }\n+\t\t template <class T> struct S { template <class U> void f(); }\n \t\t template <> template <class U> void S<int>::f(U);\n \n \t       Here, we'll be substituting into the specialization,\n@@ -6371,7 +6371,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t  {\n \t    /* This special case arises when we have something like this:\n \n-\t         template <class T> struct S {\n+\t\t template <class T> struct S {\n \t\t   friend void f<int>(int, double);\n \t\t };\n \n@@ -6402,9 +6402,9 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t  return error_mark_node;\n \n \t/* We do NOT check for matching decls pushed separately at this\n-           point, as they may not represent instantiations of this\n-           template, and in any case are considered separate under the\n-           discrete model.  */\n+\t   point, as they may not represent instantiations of this\n+\t   template, and in any case are considered separate under the\n+\t   discrete model.  */\n \tr = copy_decl (t);\n \tDECL_USE_TEMPLATE (r) = 0;\n \tTREE_TYPE (r) = type;\n@@ -6458,8 +6458,8 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t       until they are called, for a template.  But, for a\n \t       declaration like:\n \n-\t         template <class T> void f ()\n-                 { extern void g(int i = T()); }\n+\t\t template <class T> void f ()\n+\t\t { extern void g(int i = T()); }\n \n \t       we should do the substitution when the template is\n \t       instantiated.  We handle the member function case in\n@@ -6702,9 +6702,9 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \n static tree\n tsubst_arg_types (tree arg_types,\n-                  tree args,\n-                  tsubst_flags_t complain,\n-                  tree in_decl)\n+\t\t  tree args,\n+\t\t  tsubst_flags_t complain,\n+\t\t  tree in_decl)\n {\n   tree remaining_arg_types;\n   tree type;\n@@ -6725,11 +6725,11 @@ tsubst_arg_types (tree arg_types,\n   if (VOID_TYPE_P (type))\n     {\n       if (complain & tf_error)\n-        {\n-          error (\"invalid parameter type %qT\", type);\n-          if (in_decl)\n-            cp_error_at (\"in declaration %qD\", in_decl);\n-        }\n+\t{\n+\t  error (\"invalid parameter type %qT\", type);\n+\t  if (in_decl)\n+\t    cp_error_at (\"in declaration %qD\", in_decl);\n+\t}\n       return error_mark_node;\n     }\n \n@@ -6745,9 +6745,9 @@ tsubst_arg_types (tree arg_types,\n   if (default_arg && TREE_CODE (default_arg) == DEFAULT_ARG)\n     {\n       /* We've instantiated a template before its default arguments\n- \t have been parsed.  This can happen for a nested template\n- \t class, and is not an error unless we require the default\n- \t argument in a call of this function.  */\n+\t have been parsed.  This can happen for a nested template\n+\t class, and is not an error unless we require the default\n+\t argument in a call of this function.  */\n       result = tree_cons (default_arg, type, remaining_arg_types);\n       VEC_safe_push (tree, gc, DEFARG_INSTANTIATIONS (default_arg), result);\n     }\n@@ -6776,9 +6776,9 @@ tsubst_arg_types (tree arg_types,\n \n static tree\n tsubst_function_type (tree t,\n-                      tree args,\n-                      tsubst_flags_t complain,\n-                      tree in_decl)\n+\t\t      tree args,\n+\t\t      tsubst_flags_t complain,\n+\t\t      tree in_decl)\n {\n   tree return_type;\n   tree arg_types;\n@@ -6881,9 +6881,9 @@ tsubst_exception_specification (tree fntype,\n \n static tree\n tsubst_call_declarator_parms (tree parms,\n-                              tree args,\n-                              tsubst_flags_t complain,\n-                              tree in_decl)\n+\t\t\t      tree args,\n+\t\t\t      tsubst_flags_t complain,\n+\t\t\t      tree in_decl)\n {\n   tree new_parms;\n   tree type;\n@@ -7108,8 +7108,8 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    if (cp_type_quals (t))\n \t      {\n \t\tr = tsubst (TYPE_MAIN_VARIANT (t), args, complain, in_decl);\n- \t\tr = cp_build_qualified_type_real\n- \t\t  (r, cp_type_quals (t),\n+\t\tr = cp_build_qualified_type_real\n+\t\t  (r, cp_type_quals (t),\n \t\t   complain | (TREE_CODE (t) == TEMPLATE_TYPE_PARM\n \t\t\t       ? tf_ignore_bad_quals : 0));\n \t      }\n@@ -7232,8 +7232,8 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t  error (\"forming reference to void\");\n \t\telse\n \t\t  error (\"forming %s to reference type %qT\",\n-                         (code == POINTER_TYPE) ? \"pointer\" : \"reference\",\n-                         type);\n+\t\t\t (code == POINTER_TYPE) ? \"pointer\" : \"reference\",\n+\t\t\t type);\n \t\tlast_loc = input_location;\n \t      }\n \n@@ -7266,7 +7266,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t       reasons:\n \n \t       -- Attempting to create \"pointer to member of T\" when T\n-\t          is not a class type.  */\n+\t\t  is not a class type.  */\n \t    if (complain & tf_error)\n \t      error (\"creating pointer to member of non-class type %qT\", r);\n \t    return error_mark_node;\n@@ -7286,18 +7286,18 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tgcc_assert (TREE_CODE (type) != METHOD_TYPE);\n \tif (TREE_CODE (type) == FUNCTION_TYPE)\n \t  {\n-            /* The type of the implicit object parameter gets its\n-               cv-qualifiers from the FUNCTION_TYPE. */\n+\t    /* The type of the implicit object parameter gets its\n+\t       cv-qualifiers from the FUNCTION_TYPE. */\n \t    tree method_type;\n-            tree this_type = cp_build_qualified_type (TYPE_MAIN_VARIANT (r),\n-                                                      cp_type_quals (type));\n-            tree memptr;\n-            method_type = build_method_type_directly (this_type,\n+\t    tree this_type = cp_build_qualified_type (TYPE_MAIN_VARIANT (r),\n+\t\t\t\t\t\t      cp_type_quals (type));\n+\t    tree memptr;\n+\t    method_type = build_method_type_directly (this_type,\n \t\t\t\t\t\t      TREE_TYPE (type),\n \t\t\t\t\t\t      TYPE_ARG_TYPES (type));\n-            memptr = build_ptrmemfunc_type (build_pointer_type (method_type));\n-            return cp_build_qualified_type_real (memptr, cp_type_quals (t),\n-                                                 complain);\n+\t    memptr = build_ptrmemfunc_type (build_pointer_type (method_type));\n+\t    return cp_build_qualified_type_real (memptr, cp_type_quals (t),\n+\t\t\t\t\t\t complain);\n \t  }\n \telse\n \t  return cp_build_qualified_type_real (build_ptrmem_type (r, type),\n@@ -7403,7 +7403,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    /* Normally, make_typename_type does not require that the CTX\n \t       have complete type in order to allow things like:\n \n-\t         template <class T> struct S { typename S<T>::X Y; };\n+\t\t template <class T> struct S { typename S<T>::X Y; };\n \n \t       But, such constructs have already been resolved by this\n \t       point, so here CTX really should have complete type, unless\n@@ -7421,11 +7421,11 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t\t\t(complain & tf_error) | tf_keep_type_decl);\n \tif (f == error_mark_node)\n \t  return f;\n- \tif (TREE_CODE (f) == TYPE_DECL)\n- \t  {\n+\tif (TREE_CODE (f) == TYPE_DECL)\n+\t  {\n \t    complain |= tf_ignore_bad_quals;\n- \t    f = TREE_TYPE (f);\n- \t  }\n+\t    f = TREE_TYPE (f);\n+\t  }\n \n \tif (TREE_CODE (f) != TYPENAME_TYPE)\n \t  {\n@@ -7437,8 +7437,8 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t     t, f);\n \t  }\n \n- \treturn cp_build_qualified_type_real\n- \t  (f, cp_type_quals (f) | cp_type_quals (t), complain);\n+\treturn cp_build_qualified_type_real\n+\t  (f, cp_type_quals (f) | cp_type_quals (t), complain);\n       }\n \n     case UNBOUND_CLASS_TEMPLATE:\n@@ -7775,7 +7775,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t       template <template <class> class TT> struct C {};\n \t       template <class T> struct D {\n \t\t template <class U> struct E {};\n-\t \t C<E> c;\t\t\t\t// #1\n+\t\t C<E> c;\t\t\t\t// #1\n \t       };\n \t       D<int> d;\t\t\t\t// #2\n \n@@ -7942,7 +7942,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \n     case TEMPLATE_ID_EXPR:\n       {\n-        /* Substituted template arguments */\n+\t/* Substituted template arguments */\n \ttree fn = TREE_OPERAND (t, 0);\n \ttree targs = TREE_OPERAND (t, 1);\n \n@@ -8108,15 +8108,15 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    decl = tsubst (decl, args, complain, in_decl);\n \t    if (decl != error_mark_node)\n \t      {\n-\t        if (init)\n-\t          DECL_INITIAL (decl) = error_mark_node;\n-\t        /* By marking the declaration as instantiated, we avoid\n-\t           trying to instantiate it.  Since instantiate_decl can't\n-\t           handle local variables, and since we've already done\n-\t           all that needs to be done, that's the right thing to\n-\t           do.  */\n-\t        if (TREE_CODE (decl) == VAR_DECL)\n-\t          DECL_TEMPLATE_INSTANTIATED (decl) = 1;\n+\t\tif (init)\n+\t\t  DECL_INITIAL (decl) = error_mark_node;\n+\t\t/* By marking the declaration as instantiated, we avoid\n+\t\t   trying to instantiate it.  Since instantiate_decl can't\n+\t\t   handle local variables, and since we've already done\n+\t\t   all that needs to be done, that's the right thing to\n+\t\t   do.  */\n+\t\tif (TREE_CODE (decl) == VAR_DECL)\n+\t\t  DECL_TEMPLATE_INSTANTIATED (decl) = 1;\n \t\tif (TREE_CODE (decl) == VAR_DECL\n \t\t    && ANON_AGGR_TYPE_P (TREE_TYPE (decl)))\n \t\t  /* Anonymous aggregates are a special case.  */\n@@ -8349,9 +8349,9 @@ tsubst_non_call_postfix_expression (tree t, tree args,\n \n tree\n tsubst_copy_and_build (tree t,\n-                       tree args,\n-                       tsubst_flags_t complain,\n-                       tree in_decl,\n+\t\t       tree args,\n+\t\t       tsubst_flags_t complain,\n+\t\t       tree in_decl,\n \t\t       bool function_p)\n {\n #define RECUR(NODE) \\\n@@ -9101,10 +9101,10 @@ instantiate_template (tree tmpl, tree targ_ptr, tsubst_flags_t complain)\n \n int\n fn_type_unification (tree fn,\n-                     tree explicit_targs,\n-                     tree targs,\n-                     tree args,\n-                     tree return_type,\n+\t\t     tree explicit_targs,\n+\t\t     tree targs,\n+\t\t     tree args,\n+\t\t     tree return_type,\n \t\t     unification_kind_t strict)\n {\n   tree parms;\n@@ -9148,11 +9148,11 @@ fn_type_unification (tree fn,\n \treturn 1;\n \n       /* Substitute the explicit args into the function type.  This is\n-         necessary so that, for instance, explicitly declared function\n-         arguments can match null pointed constants.  If we were given\n-         an incomplete set of explicit args, we must not do semantic\n-         processing during substitution as we could create partial\n-         instantiations.  */\n+\t necessary so that, for instance, explicitly declared function\n+\t arguments can match null pointed constants.  If we were given\n+\t an incomplete set of explicit args, we must not do semantic\n+\t processing during substitution as we could create partial\n+\t instantiations.  */\n       incomplete = NUM_TMPL_ARGS (explicit_targs) != NUM_TMPL_ARGS (targs);\n       processing_template_decl += incomplete;\n       fntype = tsubst (fntype, converted_args, tf_none, NULL_TREE);\n@@ -9212,8 +9212,8 @@ fn_type_unification (tree fn,\n \n static int\n maybe_adjust_types_for_deduction (unification_kind_t strict,\n-                                  tree* parm,\n-                                  tree* arg)\n+\t\t\t\t  tree* parm,\n+\t\t\t\t  tree* arg)\n {\n   int result = 0;\n \n@@ -9296,12 +9296,12 @@ maybe_adjust_types_for_deduction (unification_kind_t strict,\n \n static int\n type_unification_real (tree tparms,\n-                       tree targs,\n-                       tree xparms,\n-                       tree xargs,\n-                       int subr,\n+\t\t       tree targs,\n+\t\t       tree xparms,\n+\t\t       tree xargs,\n+\t\t       int subr,\n \t\t       unification_kind_t strict,\n-                       int allow_incomplete)\n+\t\t       int allow_incomplete)\n {\n   tree parm, arg;\n   int i;\n@@ -9319,7 +9319,7 @@ type_unification_real (tree tparms,\n     {\n     case DEDUCE_CALL:\n       sub_strict = (UNIFY_ALLOW_OUTER_LEVEL | UNIFY_ALLOW_MORE_CV_QUAL\n-                    | UNIFY_ALLOW_DERIVED);\n+\t\t    | UNIFY_ALLOW_DERIVED);\n       break;\n \n     case DEDUCE_CONV:\n@@ -9403,13 +9403,13 @@ type_unification_real (tree tparms,\n \t}\n \n       {\n-        int arg_strict = sub_strict;\n+\tint arg_strict = sub_strict;\n \n-        if (!subr)\n+\tif (!subr)\n \t  arg_strict |= maybe_adjust_types_for_deduction (strict, &parm, &arg);\n \n-        if (unify (tparms, targs, parm, arg, arg_strict))\n-          return 1;\n+\tif (unify (tparms, targs, parm, arg, arg_strict))\n+\t  return 1;\n       }\n     }\n \n@@ -9452,10 +9452,10 @@ type_unification_real (tree tparms,\n \n static int\n resolve_overloaded_unification (tree tparms,\n-                                tree targs,\n-                                tree parm,\n-                                tree arg,\n-                                unification_kind_t strict,\n+\t\t\t\ttree targs,\n+\t\t\t\ttree parm,\n+\t\t\t\ttree arg,\n+\t\t\t\tunification_kind_t strict,\n \t\t\t\tint sub_strict)\n {\n   tree tempargs = copy_node (targs);\n@@ -9551,11 +9551,11 @@ resolve_overloaded_unification (tree tparms,\n \n static int\n try_one_overload (tree tparms,\n-                  tree orig_targs,\n-                  tree targs,\n-                  tree parm,\n-                  tree arg,\n-                  unification_kind_t strict,\n+\t\t  tree orig_targs,\n+\t\t  tree targs,\n+\t\t  tree parm,\n+\t\t  tree arg,\n+\t\t  unification_kind_t strict,\n \t\t  int sub_strict,\n \t\t  bool addr_p)\n {\n@@ -9640,7 +9640,7 @@ static int\n verify_class_unification (tree targs, tree parms, tree args)\n {\n   parms = tsubst (parms, add_outermost_template_args (args, targs),\n-  \t\t  tf_none, NULL_TREE);\n+\t\t  tf_none, NULL_TREE);\n   if (parms == error_mark_node)\n     return 1;\n \n@@ -9680,10 +9680,10 @@ try_class_unification (tree tparms, tree targs, tree parm, tree arg)\n        void f(S<I, J, K>, S<I, I, I>);\n \n        void g() {\n-         S<0, 0, 0> s0;\n-         S<0, 1, 2> s2;\n+\t S<0, 0, 0> s0;\n+\t S<0, 1, 2> s2;\n \n-         f(s0, s2);\n+\t f(s0, s2);\n        }\n \n      Now, by the time we consider the unification involving `s2', we\n@@ -9782,11 +9782,11 @@ check_cv_quals_for_unify (int strict, tree arg, tree parm)\n       && !(strict & UNIFY_ALLOW_OUTER_MORE_CV_QUAL))\n     {\n       /*  Although a CVR qualifier is ignored when being applied to a\n-          substituted template parameter ([8.3.2]/1 for example), that\n-          does not apply during deduction [14.8.2.4]/1, (even though\n-          that is not explicitly mentioned, [14.8.2.4]/9 indicates\n-          this).  Except when we're allowing additional CV qualifiers\n-          at the outer level [14.8.2.1]/3,1st bullet.  */\n+\t  substituted template parameter ([8.3.2]/1 for example), that\n+\t  does not apply during deduction [14.8.2.4]/1, (even though\n+\t  that is not explicitly mentioned, [14.8.2.4]/9 indicates\n+\t  this).  Except when we're allowing additional CV qualifiers\n+\t  at the outer level [14.8.2.1]/3,1st bullet.  */\n       if ((TREE_CODE (arg) == REFERENCE_TYPE\n \t   || TREE_CODE (arg) == FUNCTION_TYPE\n \t   || TREE_CODE (arg) == METHOD_TYPE)\n@@ -9875,8 +9875,8 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n   if (TREE_CODE (arg) == TREE_CODE (parm)\n       && TYPE_P (arg)\n       /* It is the elements of the array which hold the cv quals of an array\n-         type, and the elements might be template type parms. We'll check\n-         when we recurse.  */\n+\t type, and the elements might be template type parms. We'll check\n+\t when we recurse.  */\n       && TREE_CODE (arg) != ARRAY_TYPE\n       /* We check the cv-qualifiers when unifying with template type\n \t parameters below.  We want to allow ARG `const T' to unify with\n@@ -9950,7 +9950,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t       class vector.  */\n \n \t    if (coerce_template_parms (argtmplvec, parmvec, parmtmpl, 0, 1)\n-\t        == error_mark_node)\n+\t\t== error_mark_node)\n \t      return 1;\n \n \t    /* Deduce arguments T, i from TT<T> or TT<i>.\n@@ -9960,7 +9960,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \n \t    for (i = 0; i < TREE_VEC_LENGTH (parmvec); ++i)\n \t      {\n-\t        if (unify (tparms, targs,\n+\t\tif (unify (tparms, targs,\n \t\t\t   TREE_VEC_ELT (parmvec, i),\n \t\t\t   TREE_VEC_ELT (argvec, i),\n \t\t\t   UNIFY_ALLOW_NONE))\n@@ -10070,23 +10070,23 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \n     case PTRMEM_CST:\n      {\n-        /* A pointer-to-member constant can be unified only with\n-         another constant.  */\n+\t/* A pointer-to-member constant can be unified only with\n+\t another constant.  */\n       if (TREE_CODE (arg) != PTRMEM_CST)\n-        return 1;\n+\treturn 1;\n \n       /* Just unify the class member. It would be useless (and possibly\n-         wrong, depending on the strict flags) to unify also\n-         PTRMEM_CST_CLASS, because we want to be sure that both parm and\n-         arg refer to the same variable, even if through different\n-         classes. For instance:\n+\t wrong, depending on the strict flags) to unify also\n+\t PTRMEM_CST_CLASS, because we want to be sure that both parm and\n+\t arg refer to the same variable, even if through different\n+\t classes. For instance:\n \n-         struct A { int x; };\n-         struct B : A { };\n+\t struct A { int x; };\n+\t struct B : A { };\n \n-         Unification of &A::x and &B::x must succeed.  */\n+\t Unification of &A::x and &B::x must succeed.  */\n       return unify (tparms, targs, PTRMEM_CST_MEMBER (parm),\n-                    PTRMEM_CST_MEMBER (arg), strict);\n+\t\t    PTRMEM_CST_MEMBER (arg), strict);\n      }\n \n     case POINTER_TYPE:\n@@ -10269,35 +10269,35 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \n     case OFFSET_TYPE:\n       /* Unify a pointer to member with a pointer to member function, which\n-         deduces the type of the member as a function type. */\n+\t deduces the type of the member as a function type. */\n       if (TYPE_PTRMEMFUNC_P (arg))\n-        {\n-          tree method_type;\n-          tree fntype;\n-          cp_cv_quals cv_quals;\n-\n-          /* Check top-level cv qualifiers */\n-          if (!check_cv_quals_for_unify (UNIFY_ALLOW_NONE, arg, parm))\n-            return 1;\n-\n-          if (unify (tparms, targs, TYPE_OFFSET_BASETYPE (parm),\n-                     TYPE_PTRMEMFUNC_OBJECT_TYPE (arg), UNIFY_ALLOW_NONE))\n-            return 1;\n-\n-          /* Determine the type of the function we are unifying against. */\n-          method_type = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (arg));\n-          fntype =\n-            build_function_type (TREE_TYPE (method_type),\n-                                 TREE_CHAIN (TYPE_ARG_TYPES (method_type)));\n-\n-          /* Extract the cv-qualifiers of the member function from the\n-             implicit object parameter and place them on the function\n-             type to be restored later. */\n-          cv_quals =\n-            cp_type_quals(TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (method_type))));\n-          fntype = build_qualified_type (fntype, cv_quals);\n-          return unify (tparms, targs, TREE_TYPE (parm), fntype, strict);\n-        }\n+\t{\n+\t  tree method_type;\n+\t  tree fntype;\n+\t  cp_cv_quals cv_quals;\n+\n+\t  /* Check top-level cv qualifiers */\n+\t  if (!check_cv_quals_for_unify (UNIFY_ALLOW_NONE, arg, parm))\n+\t    return 1;\n+\n+\t  if (unify (tparms, targs, TYPE_OFFSET_BASETYPE (parm),\n+\t\t     TYPE_PTRMEMFUNC_OBJECT_TYPE (arg), UNIFY_ALLOW_NONE))\n+\t    return 1;\n+\n+\t  /* Determine the type of the function we are unifying against. */\n+\t  method_type = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (arg));\n+\t  fntype =\n+\t    build_function_type (TREE_TYPE (method_type),\n+\t\t\t\t TREE_CHAIN (TYPE_ARG_TYPES (method_type)));\n+\n+\t  /* Extract the cv-qualifiers of the member function from the\n+\t     implicit object parameter and place them on the function\n+\t     type to be restored later. */\n+\t  cv_quals =\n+\t    cp_type_quals(TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (method_type))));\n+\t  fntype = build_qualified_type (fntype, cv_quals);\n+\t  return unify (tparms, targs, TREE_TYPE (parm), fntype, strict);\n+\t}\n \n       if (TREE_CODE (arg) != OFFSET_TYPE)\n \treturn 1;\n@@ -10649,7 +10649,7 @@ get_bindings (tree fn, tree decl, tree explicit_args, bool check_rettype)\n   if (fn_type_unification (fn, explicit_args, targs,\n \t\t\t   decl_arg_types,\n \t\t\t   (check_rettype || DECL_CONV_FN_P (fn)\n-\t                    ? TREE_TYPE (decl_type) : NULL_TREE),\n+\t\t\t    ? TREE_TYPE (decl_type) : NULL_TREE),\n \t\t\t   DEDUCE_EXACT))\n     return NULL_TREE;\n \n@@ -10678,7 +10678,7 @@ get_class_bindings (tree tparms, tree parms, tree args)\n   tree vec = make_tree_vec (ntparms);\n \n   if (unify (tparms, vec, parms, INNERMOST_TEMPLATE_ARGS (args),\n-  \t     UNIFY_ALLOW_NONE))\n+\t     UNIFY_ALLOW_NONE))\n     return NULL_TREE;\n \n   for (i =  0; i < ntparms; ++i)\n@@ -10988,7 +10988,7 @@ do_decl_instantiation (tree decl, tree storage)\n     {\n       if (pedantic && !in_system_header)\n \tpedwarn (\"ISO C++ forbids the use of %<extern%> on explicit \"\n-                 \"instantiations\");\n+\t\t \"instantiations\");\n       extern_p = 1;\n     }\n   else\n@@ -11064,15 +11064,15 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n     {\n       if (complain & tf_error)\n \terror (\"explicit instantiation of %q#T before definition of template\",\n-               t);\n+\t       t);\n       return;\n     }\n \n   if (storage != NULL_TREE)\n     {\n       if (pedantic && !in_system_header)\n \tpedwarn(\"ISO C++ forbids the use of %qE on explicit instantiations\",\n-                storage);\n+\t\tstorage);\n \n       if (storage == ridpointers[(int) RID_INLINE])\n \tnomem_p = 1;\n@@ -11083,7 +11083,7 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n       else\n \t{\n \t  error (\"storage class %qD applied to template instantiation\",\n-                 storage);\n+\t\t storage);\n \t  extern_p = 0;\n \t}\n     }\n@@ -11109,7 +11109,7 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n \t No program shall explicitly instantiate any template more\n \t than once.\n \n-         If PREVIOUS_INSTANTIATION_EXTERN_P, then the first explicit\n+\t If PREVIOUS_INSTANTIATION_EXTERN_P, then the first explicit\n \t instantiation was `extern'.  If EXTERN_P then the second is.\n \t These cases are OK.  */\n       previous_instantiation_extern_p = CLASSTYPE_INTERFACE_ONLY (t);\n@@ -11135,7 +11135,7 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n        declarations, and not the definitions, of members are\n        instantiated, we have here:\n \n-         [temp.explicit]\n+\t [temp.explicit]\n \n \t The explicit instantiation of a class template specialization\n \t implies the instantiation of all of its members not\n@@ -11160,7 +11160,7 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n \n     if (CLASSTYPE_NESTED_UTDS (t))\n       binding_table_foreach (CLASSTYPE_NESTED_UTDS (t),\n-                             bt_instantiate_type_proc, &storage);\n+\t\t\t     bt_instantiate_type_proc, &storage);\n   }\n }\n \n@@ -11279,9 +11279,9 @@ template_for_substitution (tree decl)\n      for the instantiation.  This is not always the most general\n      template.  Consider, for example:\n \n-        template <class T>\n+\ttemplate <class T>\n \tstruct S { template <class U> void f();\n-\t           template <> void f<int>(); };\n+\t\t   template <> void f<int>(); };\n \n      and an instantiation of S<double>::f<int>.  We want TD to be the\n      specialization S<T>::f<int>, not the more general S<T>::f<U>.  */\n@@ -11926,12 +11926,12 @@ dependent_type_p_r (tree type)\n       || TREE_CODE (type) == TEMPLATE_TEMPLATE_PARM)\n     return true;\n   /* -- a qualified-id with a nested-name-specifier which contains a\n-        class-name that names a dependent type or whose unqualified-id\n+\tclass-name that names a dependent type or whose unqualified-id\n \tnames a dependent type.  */\n   if (TREE_CODE (type) == TYPENAME_TYPE)\n     return true;\n   /* -- a cv-qualified type where the cv-unqualified type is\n-        dependent.  */\n+\tdependent.  */\n   type = TYPE_MAIN_VARIANT (type);\n   /* -- a compound type constructed from any dependent type.  */\n   if (TYPE_PTR_TO_MEMBER_P (type))\n@@ -11956,7 +11956,7 @@ dependent_type_p_r (tree type)\n       return false;\n     }\n   /* -- an array type constructed from any dependent type or whose\n-        size is specified by a constant expression that is\n+\tsize is specified by a constant expression that is\n \tvalue-dependent.  */\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n@@ -11991,7 +11991,7 @@ dependent_type_p_r (tree type)\n      considered dependent too.  For example:\n \n        template <int I> void f() {\n-         enum E { a = I };\n+\t enum E { a = I };\n \t S<sizeof (E)> s;\n        }\n \n@@ -12103,7 +12103,7 @@ value_dependent_expression_p (tree expression)\n \n     case VAR_DECL:\n        /* A constant with integral or enumeration type and is initialized\n-     \t  with an expression that is value-dependent.  */\n+\t  with an expression that is value-dependent.  */\n       if (DECL_INITIAL (expression)\n \t  && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (expression))\n \t  && value_dependent_expression_p (DECL_INITIAL (expression)))\n@@ -12116,8 +12116,8 @@ value_dependent_expression_p (tree expression)\n     case REINTERPRET_CAST_EXPR:\n     case CAST_EXPR:\n       /* These expressions are value-dependent if the type to which\n-     \t the cast occurs is dependent or the expression being casted\n-     \t is value-dependent.  */\n+\t the cast occurs is dependent or the expression being casted\n+\t is value-dependent.  */\n       {\n \ttree type = TREE_TYPE (expression);\n \n@@ -12150,7 +12150,7 @@ value_dependent_expression_p (tree expression)\n     case SIZEOF_EXPR:\n     case ALIGNOF_EXPR:\n       /* A `sizeof' expression is value-dependent if the operand is\n-     \t type-dependent.  */\n+\t type-dependent.  */\n       expression = TREE_OPERAND (expression, 0);\n       if (TYPE_P (expression))\n \treturn dependent_type_p (expression);\n@@ -12165,11 +12165,11 @@ value_dependent_expression_p (tree expression)\n \n     case CALL_EXPR:\n       /* A CALL_EXPR is value-dependent if any argument is\n-     \t value-dependent.  Why do we have to handle CALL_EXPRs in this\n-     \t function at all?  First, some function calls, those for which\n-     \t value_dependent_expression_p is true, man appear in constant\n-     \t expressions.  Second, there appear to be bugs which result in\n-     \t other CALL_EXPRs reaching this point. */\n+\t value-dependent.  Why do we have to handle CALL_EXPRs in this\n+\t function at all?  First, some function calls, those for which\n+\t value_dependent_expression_p is true, man appear in constant\n+\t expressions.  Second, there appear to be bugs which result in\n+\t other CALL_EXPRs reaching this point. */\n       {\n \ttree function = TREE_OPERAND (expression, 0);\n \ttree args = TREE_OPERAND (expression, 1);\n@@ -12193,7 +12193,7 @@ value_dependent_expression_p (tree expression)\n \n     default:\n       /* A constant expression is value-dependent if any subexpression is\n-     \t value-dependent.  */\n+\t value-dependent.  */\n       switch (TREE_CODE_CLASS (TREE_CODE (expression)))\n \t{\n \tcase tcc_reference:"}, {"sha": "ad8b94d771568f944c25d1451fdcd722589bdbc4", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -320,7 +320,7 @@ get_tinfo_decl (tree type)\n       && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n     {\n       error (\"cannot create type information for type %qT because \"\n-             \"its size is variable\",\n+\t     \"its size is variable\",\n \t     type);\n       return error_mark_node;\n     }\n@@ -420,7 +420,7 @@ ifnonnull (tree test, tree result)\n {\n   return build3 (COND_EXPR, TREE_TYPE (result),\n \t\t build2 (EQ_EXPR, boolean_type_node, test,\n-\t\t         cp_convert (TREE_TYPE (test), integer_zero_node)),\n+\t\t\t cp_convert (TREE_TYPE (test), integer_zero_node)),\n \t\t cp_convert (TREE_TYPE (result), integer_zero_node),\n \t\t result);\n }\n@@ -557,21 +557,21 @@ build_dynamic_cast_1 (tree type, tree expr)\n       else\n \t{\n \t  tree retval;\n-          tree result, td2, td3, elems;\n-          tree static_type, target_type, boff;\n+\t  tree result, td2, td3, elems;\n+\t  tree static_type, target_type, boff;\n \n- \t  /* If we got here, we can't convert statically.  Therefore,\n+\t  /* If we got here, we can't convert statically.  Therefore,\n \t     dynamic_cast<D&>(b) (b an object) cannot succeed.  */\n \t  if (tc == REFERENCE_TYPE)\n \t    {\n \t      if (TREE_CODE (old_expr) == VAR_DECL\n \t\t  && TREE_CODE (TREE_TYPE (old_expr)) == RECORD_TYPE)\n \t\t{\n-\t          tree expr = throw_bad_cast ();\n+\t\t  tree expr = throw_bad_cast ();\n \t\t  warning (0, \"dynamic_cast of %q#D to %q#T can never succeed\",\n-                           old_expr, type);\n-\t          /* Bash it to the expected type.  */\n-\t          TREE_TYPE (expr) = type;\n+\t\t\t   old_expr, type);\n+\t\t  /* Bash it to the expected type.  */\n+\t\t  TREE_TYPE (expr) = type;\n \t\t  return expr;\n \t\t}\n \t    }\n@@ -583,7 +583,7 @@ build_dynamic_cast_1 (tree type, tree expr)\n \t\t  && TREE_CODE (TREE_TYPE (op)) == RECORD_TYPE)\n \t\t{\n \t\t  warning (0, \"dynamic_cast of %q#D to %q#T can never succeed\",\n-                           op, type);\n+\t\t\t   op, type);\n \t\t  retval = build_int_cst (type, 0);\n \t\t  return retval;\n \t\t}\n@@ -598,8 +598,8 @@ build_dynamic_cast_1 (tree type, tree expr)\n \t  mark_used (td3);\n \t  td3 = build_unary_op (ADDR_EXPR, td3, 0);\n \n-          /* Determine how T and V are related.  */\n-          boff = dcast_base_hint (static_type, target_type);\n+\t  /* Determine how T and V are related.  */\n+\t  boff = dcast_base_hint (static_type, target_type);\n \n \t  /* Since expr is used twice below, save it.  */\n \t  expr = save_expr (expr);\n@@ -639,10 +639,10 @@ build_dynamic_cast_1 (tree type, tree expr)\n \t      tmp = build_function_type (ptr_type_node, tmp);\n \t      dcast_fn = build_library_fn_ptr (name, tmp);\n \t      DECL_IS_PURE (dcast_fn) = 1;\n-              pop_nested_namespace (ns);\n-              dynamic_cast_node = dcast_fn;\n+\t      pop_nested_namespace (ns);\n+\t      dynamic_cast_node = dcast_fn;\n \t    }\n-          result = build_cxx_call (dcast_fn, elems);\n+\t  result = build_cxx_call (dcast_fn, elems);\n \n \t  if (tc == REFERENCE_TYPE)\n \t    {\n@@ -654,15 +654,15 @@ build_dynamic_cast_1 (tree type, tree expr)\n \n \t  /* Now back to the type we want from a void*.  */\n \t  result = cp_convert (type, result);\n-          return ifnonnull (expr, result);\n+\t  return ifnonnull (expr, result);\n \t}\n     }\n   else\n     errstr = \"source type is not polymorphic\";\n \n  fail:\n   error (\"cannot dynamic_cast %qE (of type %q#T) to type %q#T (%s)\",\n-         expr, exprtype, type, errstr);\n+\t expr, exprtype, type, errstr);\n   return error_mark_node;\n }\n \n@@ -769,8 +769,8 @@ tinfo_base_init (tree desc, tree target)\n \n     /* Generate the NTBS array variable.  */\n     tree name_type = build_cplus_array_type\n-                     (build_qualified_type (char_type_node, TYPE_QUAL_CONST),\n-                     NULL_TREE);\n+\t\t     (build_qualified_type (char_type_node, TYPE_QUAL_CONST),\n+\t\t     NULL_TREE);\n     tree name_string = tinfo_name (target);\n \n     /* Determine the name of the variable -- and remember with which\n@@ -811,7 +811,7 @@ tinfo_base_init (tree desc, tree target)\n \n       if (!COMPLETE_TYPE_P (real_type))\n \t{\n-          /* We never saw a definition of this type, so we need to\n+\t  /* We never saw a definition of this type, so we need to\n \t     tell the compiler that this is an exported class, as\n \t     indeed all of the __*_type_info classes are.  */\n \t  SET_CLASSTYPE_INTERFACE_KNOWN (real_type);\n@@ -876,8 +876,8 @@ ptr_initializer (tree desc, tree target)\n     flags |= 8;\n   init = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, flags), init);\n   init = tree_cons (NULL_TREE,\n-                    get_tinfo_ptr (TYPE_MAIN_VARIANT (to)),\n-                    init);\n+\t\t    get_tinfo_ptr (TYPE_MAIN_VARIANT (to)),\n+\t\t    init);\n \n   init = build_constructor (NULL_TREE, nreverse (init));\n   TREE_CONSTANT (init) = 1;\n@@ -907,7 +907,7 @@ ptm_initializer (tree desc, tree target)\n   init = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, flags), init);\n   init = tree_cons (NULL_TREE,\n \t\t    get_tinfo_ptr (TYPE_MAIN_VARIANT (to)),\n-                    init);\n+\t\t    init);\n   init = tree_cons (NULL_TREE,\n \t\t    get_tinfo_ptr (klass),\n \t\t    init);\n@@ -992,55 +992,55 @@ get_pseudo_ti_init (tree type, tree var_desc)\n \treturn class_initializer (var_desc, type, NULL_TREE);\n       else if (var_desc == si_class_desc_type_node)\n \t{\n-          tree base_binfo = BINFO_BASE_BINFO (TYPE_BINFO (type), 0);\n+\t  tree base_binfo = BINFO_BASE_BINFO (TYPE_BINFO (type), 0);\n \t  tree tinfo = get_tinfo_ptr (BINFO_TYPE (base_binfo));\n \t  tree base_inits = tree_cons (NULL_TREE, tinfo, NULL_TREE);\n \n \t  return class_initializer (var_desc, type, base_inits);\n \t}\n       else\n-        {\n+\t{\n \t  int hint = ((CLASSTYPE_REPEATED_BASE_P (type) << 0)\n \t\t      | (CLASSTYPE_DIAMOND_SHAPED_P (type) << 1));\n \t  tree binfo = TYPE_BINFO (type);\n-          int nbases = BINFO_N_BASE_BINFOS (binfo);\n+\t  int nbases = BINFO_N_BASE_BINFOS (binfo);\n \t  VEC(tree,gc) *base_accesses = BINFO_BASE_ACCESSES (binfo);\n-          tree base_inits = NULL_TREE;\n-          int ix;\n-\n-          /* Generate the base information initializer.  */\n-          for (ix = nbases; ix--;)\n-            {\n-              tree base_binfo = BINFO_BASE_BINFO (binfo, ix);\n-              tree base_init = NULL_TREE;\n-              int flags = 0;\n-              tree tinfo;\n-              tree offset;\n-\n-              if (VEC_index (tree, base_accesses, ix) == access_public_node)\n-                flags |= 2;\n-              tinfo = get_tinfo_ptr (BINFO_TYPE (base_binfo));\n+\t  tree base_inits = NULL_TREE;\n+\t  int ix;\n+\n+\t  /* Generate the base information initializer.  */\n+\t  for (ix = nbases; ix--;)\n+\t    {\n+\t      tree base_binfo = BINFO_BASE_BINFO (binfo, ix);\n+\t      tree base_init = NULL_TREE;\n+\t      int flags = 0;\n+\t      tree tinfo;\n+\t      tree offset;\n+\n+\t      if (VEC_index (tree, base_accesses, ix) == access_public_node)\n+\t\tflags |= 2;\n+\t      tinfo = get_tinfo_ptr (BINFO_TYPE (base_binfo));\n \t      if (BINFO_VIRTUAL_P (base_binfo))\n \t\t{\n \t\t   /* We store the vtable offset at which the virtual\n-       \t\t      base offset can be found.  */\n+\t\t      base offset can be found.  */\n \t\t  offset = BINFO_VPTR_FIELD (base_binfo);\n \t\t  offset = convert (sizetype, offset);\n \t\t  flags |= 1;\n \t\t}\n \t      else\n \t\toffset = BINFO_OFFSET (base_binfo);\n \n-              /* Combine offset and flags into one field.  */\n-              offset = cp_build_binary_op (LSHIFT_EXPR, offset,\n+\t      /* Combine offset and flags into one field.  */\n+\t      offset = cp_build_binary_op (LSHIFT_EXPR, offset,\n \t\t\t\t\t   build_int_cst (NULL_TREE, 8));\n-              offset = cp_build_binary_op (BIT_IOR_EXPR, offset,\n+\t      offset = cp_build_binary_op (BIT_IOR_EXPR, offset,\n \t\t\t\t\t   build_int_cst (NULL_TREE, flags));\n-              base_init = tree_cons (NULL_TREE, offset, base_init);\n-              base_init = tree_cons (NULL_TREE, tinfo, base_init);\n-              base_init = build_constructor (NULL_TREE, base_init);\n-              base_inits = tree_cons (NULL_TREE, base_init, base_inits);\n-            }\n+\t      base_init = tree_cons (NULL_TREE, offset, base_init);\n+\t      base_init = tree_cons (NULL_TREE, tinfo, base_init);\n+\t      base_init = build_constructor (NULL_TREE, base_init);\n+\t      base_inits = tree_cons (NULL_TREE, base_init, base_inits);\n+\t    }\n \t  base_inits = build_constructor (NULL_TREE, base_inits);\n \t  base_inits = tree_cons (NULL_TREE, base_inits, NULL_TREE);\n \t  /* Prepend the number of bases.  */\n@@ -1052,8 +1052,8 @@ get_pseudo_ti_init (tree type, tree var_desc)\n \t\t\t\t  build_int_cst (NULL_TREE, hint),\n \t\t\t\t  base_inits);\n \n-          return class_initializer (var_desc, type, base_inits);\n-        }\n+\t  return class_initializer (var_desc, type, base_inits);\n+\t}\n       break;\n \n     default:\n@@ -1250,22 +1250,22 @@ create_tinfo_types (void)\n        NULL);\n   func_desc_type_node = create_pseudo_type_info\n        (\"__function_type_info\", 0,\n-        NULL);\n+\tNULL);\n   enum_desc_type_node = create_pseudo_type_info\n        (\"__enum_type_info\", 0,\n-        NULL);\n+\tNULL);\n \n   /* Class type_info. Add a flags field.  */\n   class_desc_type_node = create_pseudo_type_info\n-        (\"__class_type_info\", 0,\n-         NULL);\n+\t(\"__class_type_info\", 0,\n+\t NULL);\n \n   /* Single public non-virtual base class. Add pointer to base class.\n      This is really a descendant of __class_type_info.  */\n   si_class_desc_type_node = create_pseudo_type_info\n-           (\"__si_class_type_info\", 0,\n-            build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n-            NULL);\n+\t   (\"__si_class_type_info\", 0,\n+\t    build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n+\t    NULL);\n \n   /* Base class internal helper. Pointer to base type, offset to base,\n      flags.  */\n@@ -1302,10 +1302,10 @@ create_tinfo_types (void)\n      This is really a descendant of __pbase_type_info.  */\n   ptm_desc_type_node = create_pseudo_type_info\n        (\"__pointer_to_member_type_info\", 0,\n-        build_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n-        build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n-        build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n-        NULL);\n+\tbuild_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n+\tbuild_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n+\tbuild_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n+\tNULL);\n \n   pop_nested_namespace (abi_node);\n }"}, {"sha": "a0758c369baba235c57c56a677cfd8e9280dc829", "filename": "gcc/cp/search.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -82,13 +82,13 @@ static int n_contexts_saved;\n struct lookup_base_data_s\n {\n   tree t;\t\t/* type being searched.  */\n-  tree base;            /* The base type we're looking for.  */\n-  tree binfo;           /* Found binfo.  */\n-  bool via_virtual;  \t/* Found via a virtual path.  */\n+  tree base;\t\t/* The base type we're looking for.  */\n+  tree binfo;\t\t/* Found binfo.  */\n+  bool via_virtual;\t/* Found via a virtual path.  */\n   bool ambiguous;\t/* Found multiply ambiguous */\n-  bool repeated_base;   /* Whether there are repeated bases in the\n+  bool repeated_base;\t/* Whether there are repeated bases in the\n \t\t\t    hierarchy.  */\n-  bool want_any;  \t/* Whether we want any matching binfo.  */\n+  bool want_any;\t/* Whether we want any matching binfo.  */\n };\n \n /* Worker function for lookup_base.  See if we've found the desired\n@@ -1084,8 +1084,8 @@ lookup_field_r (tree binfo, void *data)\n \tnval = NULL_TREE;\n       if (!nval && CLASSTYPE_NESTED_UTDS (type) != NULL)\n \t{\n-          binding_entry e = binding_table_find (CLASSTYPE_NESTED_UTDS (type),\n-                                                lfi->name);\n+\t  binding_entry e = binding_table_find (CLASSTYPE_NESTED_UTDS (type),\n+\t\t\t\t\t\tlfi->name);\n \t  if (e != NULL)\n \t    nval = TYPE_MAIN_DECL (e->type);\n \t  else\n@@ -1256,7 +1256,7 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type)\n     {\n       error (errstr, name, type);\n       if (lfi.ambiguous)\n-        print_candidates (lfi.ambiguous);\n+\tprint_candidates (lfi.ambiguous);\n       rval = error_mark_node;\n     }\n \n@@ -1655,8 +1655,8 @@ dfs_walk_once (tree binfo, tree (*pre_fn) (tree, void *),\n       if (!BINFO_INHERITANCE_CHAIN (binfo))\n \t{\n \t  /* We are at the top of the hierarchy, and can use the\n-             CLASSTYPE_VBASECLASSES list for unmarking the virtual\n-             bases.  */\n+\t     CLASSTYPE_VBASECLASSES list for unmarking the virtual\n+\t     bases.  */\n \t  VEC(tree,gc) *vbases;\n \t  unsigned ix;\n \t  tree base_binfo;\n@@ -1710,8 +1710,8 @@ dfs_walk_once_accessible_r (tree binfo, bool friends_p, bool once,\n \tcontinue;\n \n       /* If the base is inherited via private or protected\n-     \t inheritance, then we can't see it, unless we are a friend of\n-     \t the current binfo.  */\n+\t inheritance, then we can't see it, unless we are a friend of\n+\t the current binfo.  */\n       if (BINFO_BASE_ACCESS (binfo, ix) != access_public_node)\n \t{\n \t  tree scope;\n@@ -1763,8 +1763,8 @@ dfs_walk_once_accessible (tree binfo, bool friends_p,\n       if (!BINFO_INHERITANCE_CHAIN (binfo))\n \t{\n \t  /* We are at the top of the hierarchy, and can use the\n-             CLASSTYPE_VBASECLASSES list for unmarking the virtual\n-             bases.  */\n+\t     CLASSTYPE_VBASECLASSES list for unmarking the virtual\n+\t     bases.  */\n \t  VEC(tree,gc) *vbases;\n \t  unsigned ix;\n \t  tree base_binfo;\n@@ -1903,7 +1903,7 @@ look_for_overrides (tree type, tree fndecl)\n       tree basetype = BINFO_TYPE (base_binfo);\n \n       if (TYPE_POLYMORPHIC_P (basetype))\n-        found += look_for_overrides_r (basetype, fndecl);\n+\tfound += look_for_overrides_r (basetype, fndecl);\n     }\n   return found;\n }\n@@ -1931,21 +1931,21 @@ look_for_overrides_here (tree type, tree fndecl)\n       tree fns = VEC_index (tree, CLASSTYPE_METHOD_VEC (type), ix);\n \n       for (; fns; fns = OVL_NEXT (fns))\n-        {\n-          tree fn = OVL_CURRENT (fns);\n+\t{\n+\t  tree fn = OVL_CURRENT (fns);\n \n-          if (!DECL_VIRTUAL_P (fn))\n-            /* Not a virtual.  */;\n-          else if (DECL_CONTEXT (fn) != type)\n-            /* Introduced with a using declaration.  */;\n+\t  if (!DECL_VIRTUAL_P (fn))\n+\t    /* Not a virtual.  */;\n+\t  else if (DECL_CONTEXT (fn) != type)\n+\t    /* Introduced with a using declaration.  */;\n \t  else if (DECL_STATIC_FUNCTION_P (fndecl))\n \t    {\n \t      tree btypes = TYPE_ARG_TYPES (TREE_TYPE (fn));\n \t      tree dtypes = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n-  \t      if (compparms (TREE_CHAIN (btypes), dtypes))\n+\t      if (compparms (TREE_CHAIN (btypes), dtypes))\n \t\treturn fn;\n-            }\n-          else if (same_signature_p (fndecl, fn))\n+\t    }\n+\t  else if (same_signature_p (fndecl, fn))\n \t    return fn;\n \t}\n     }\n@@ -2149,7 +2149,7 @@ check_hidden_convs (tree binfo, int virtual_depth, int virtualness,\n   if (virtual_depth || virtualness)\n     {\n      /* In a virtual hierarchy, we could be hidden, or could hide a\n-        conversion function on the other_convs list.  */\n+\tconversion function on the other_convs list.  */\n       for (level = other_convs; level; level = TREE_CHAIN (level))\n \t{\n \t  int we_hide_them;"}, {"sha": "0c559752bac3fe8e90da490c2c64e7c4c601d80e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -75,9 +75,9 @@ static tree finalize_nrv_r (tree *, int *, void *);\n    example:\n \n      class A {\n-         typedef int X;\n+\t typedef int X;\n        public:\n-         X f();\n+\t X f();\n      };\n \n      A::X A::f();\n@@ -122,8 +122,8 @@ typedef struct deferred_access GTY(())\n      declared because code like:\n \n        class A {\n-         class B {};\n-         B* f();\n+\t class B {};\n+\t B* f();\n        }\n \n        A::B* A::f() { return 0; }\n@@ -498,11 +498,11 @@ finish_cond (tree *cond_p, tree expr)\n \n /* If *COND_P specifies a conditional with a declaration, transform the\n    loop such that\n-            while (A x = 42) { }\n-            for (; A x = 42;) { }\n+\t    while (A x = 42) { }\n+\t    for (; A x = 42;) { }\n    becomes\n-            while (true) { A x = 42; if (!x) break; }\n-            for (;;) { A x = 42; if (!x) break; }\n+\t    while (true) { A x = 42; if (!x) break; }\n+\t    for (;;) { A x = 42; if (!x) break; }\n    The statement list for BODY will be empty if the conditional did\n    not declare anything.  */\n \n@@ -827,7 +827,7 @@ finish_for_expr (tree expr, tree for_stmt)\n   if (!processing_template_decl)\n     {\n       if (warn_sequence_point)\n-        verify_sequence_points (expr);\n+\tverify_sequence_points (expr);\n       expr = convert_to_void (expr, \"3rd expression in for\");\n     }\n   else if (!type_dependent_expression_p (expr))\n@@ -1224,7 +1224,7 @@ finish_asm_stmt (int volatile_p, tree string, tree output_operands,\n \t  if (TREE_TYPE (operand) == unknown_type_node)\n \t    {\n \t      error (\"type of asm operand %qE could not be determined\",\n-                     TREE_VALUE (t));\n+\t\t     TREE_VALUE (t));\n \t      operand = error_mark_node;\n \t    }\n \n@@ -1445,7 +1445,7 @@ check_accessibility_of_qualified_id (tree decl,\n \t   I *p;\n \t   p->A::I::~I();\n \n-         In this case, we will have \"A::I\" as the DECL, but \"I\" as the\n+\t In this case, we will have \"A::I\" as the DECL, but \"I\" as the\n \t OBJECT_TYPE.  */\n       && CLASS_TYPE_P (object_type)\n       && DERIVED_FROM_P (scope, object_type))\n@@ -1822,7 +1822,7 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n \t   . operator.... [Otherwise] a contrived object of type T\n \t   becomes the implied object argument.\n \n-        This paragraph is unclear about this situation:\n+\tThis paragraph is unclear about this situation:\n \n \t  struct A { void f(); };\n \t  struct B : public A {};\n@@ -1865,7 +1865,7 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n       if (TREE_CODE (fn) == FUNCTION_DECL\n \t  && (DECL_BUILT_IN_CLASS (fn) == BUILT_IN_NORMAL\n \t      || DECL_BUILT_IN_CLASS (fn) == BUILT_IN_MD))\n-        result = resolve_overloaded_builtin (fn, args);\n+\tresult = resolve_overloaded_builtin (fn, args);\n \n       if (!result)\n \t/* A call to a namespace-scope function.  */\n@@ -1963,17 +1963,17 @@ finish_pseudo_destructor_expr (tree object, tree scope, tree destructor)\n \n       /* [expr.pseudo] says both:\n \n-           The type designated by the pseudo-destructor-name shall be\n+\t   The type designated by the pseudo-destructor-name shall be\n \t   the same as the object type.\n \n-         and:\n+\t and:\n \n-           The cv-unqualified versions of the object type and of the\n+\t   The cv-unqualified versions of the object type and of the\n \t   type designated by the pseudo-destructor-name shall be the\n \t   same type.\n \n-         We implement the more generous second sentence, since that is\n-         what most other compilers do.  */\n+\t We implement the more generous second sentence, since that is\n+\t what most other compilers do.  */\n       if (!same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (object),\n \t\t\t\t\t\t      destructor))\n \t{\n@@ -2122,10 +2122,10 @@ check_template_template_default_arg (tree argument)\n \t  if (CLASSTYPE_TEMPLATE_INFO (t)\n \t      && CLASSTYPE_TEMPLATE_INSTANTIATION (t))\n \t    error (\"invalid use of type %qT as a default value for a \"\n-\t           \"template template-parameter\", t);\n+\t\t   \"template template-parameter\", t);\n \t  else\n \t    error (\"invalid use of %qD as a default value for a template \"\n-\t           \"template-parameter\", argument);\n+\t\t   \"template-parameter\", argument);\n \t}\n       else\n \terror (\"invalid default argument for a template template parameter\");\n@@ -2151,7 +2151,7 @@ begin_class_definition (tree t)\n   /* A non-implicit typename comes from code like:\n \n        template <typename T> struct A {\n-         template <typename U> struct A<T>::B ...\n+\t template <typename U> struct A<T>::B ...\n \n      This is erroneous.  */\n   else if (TREE_CODE (t) == TYPENAME_TYPE)\n@@ -2380,10 +2380,10 @@ finish_base_specifier (tree base, tree access, bool virtual_p)\n   else\n     {\n       if (cp_type_quals (base) != 0)\n-        {\n-          error (\"base class %qT has cv qualifiers\", base);\n-          base = TYPE_MAIN_VARIANT (base);\n-        }\n+\t{\n+\t  error (\"base class %qT has cv qualifiers\", base);\n+\t  base = TYPE_MAIN_VARIANT (base);\n+\t}\n       result = build_tree_list (access, base);\n       if (virtual_p)\n \tTREE_TYPE (result) = integer_type_node;\n@@ -2686,8 +2686,8 @@ finish_id_expression (tree id_expression,\n \t}\n \n       /* Only certain kinds of names are allowed in constant\n-         expression.  Enumerators and template parameters have already\n-         been handled above.  */\n+\t expression.  Enumerators and template parameters have already\n+\t been handled above.  */\n       if (integral_constant_expression_p\n \t  && ! DECL_INTEGRAL_CONSTANT_VAR_P (decl)\n \t  && ! builtin_valid_in_constant_expr_p (decl))\n@@ -2851,8 +2851,8 @@ finish_typeof (tree expr)\n \n static tree\n simplify_aggr_init_exprs_r (tree* tp,\n-                            int* walk_subtrees,\n-                            void* data ATTRIBUTE_UNUSED)\n+\t\t\t    int* walk_subtrees,\n+\t\t\t    void* data ATTRIBUTE_UNUSED)\n {\n   /* We don't need to walk into types; there's nothing in a type that\n      needs simplification.  (And, furthermore, there are places we\n@@ -3022,9 +3022,9 @@ expand_body (tree fn)\n   if (DECL_CLONED_FUNCTION_P (fn))\n     {\n       /* If this is a clone, go through the other clones now and mark\n-         their parameters used.  We have to do that here, as we don't\n-         know whether any particular clone will be expanded, and\n-         therefore cannot pick one arbitrarily.  */\n+\t their parameters used.  We have to do that here, as we don't\n+\t know whether any particular clone will be expanded, and\n+\t therefore cannot pick one arbitrarily.  */\n       tree probe;\n \n       for (probe = TREE_CHAIN (DECL_CLONED_FUNCTION (fn));"}, {"sha": "06b8532d23d8b1bce6c6aa060a04ef37e49a36cd", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -59,7 +59,7 @@ static tree handle_init_priority_attribute (tree *, tree, tree, int, bool *);\n \n static cp_lvalue_kind\n lvalue_p_1 (tree ref,\n-            int treat_class_rvalues_as_lvalues)\n+\t    int treat_class_rvalues_as_lvalues)\n {\n   cp_lvalue_kind op1_lvalue_kind = clk_none;\n   cp_lvalue_kind op2_lvalue_kind = clk_none;\n@@ -93,9 +93,9 @@ lvalue_p_1 (tree ref,\n       /* Look at the member designator.  */\n       if (!op1_lvalue_kind\n \t  /* The \"field\" can be a FUNCTION_DECL or an OVERLOAD in some\n-  \t     situations.  */\n- \t  || TREE_CODE (TREE_OPERAND (ref, 1)) != FIELD_DECL)\n- \t;\n+\t     situations.  */\n+\t  || TREE_CODE (TREE_OPERAND (ref, 1)) != FIELD_DECL)\n+\t;\n       else if (DECL_C_BIT_FIELD (TREE_OPERAND (ref, 1)))\n \t{\n \t  /* Clear the ordinary bit.  If this object was a class\n@@ -433,8 +433,8 @@ build_cplus_array_type (tree elt_type, tree index_type)\n \n tree\n cp_build_qualified_type_real (tree type,\n-                              int type_quals,\n-                              tsubst_flags_t complain)\n+\t\t\t      int type_quals,\n+\t\t\t      tsubst_flags_t complain)\n {\n   tree result;\n   int bad_quals = TYPE_UNQUALIFIED;\n@@ -528,17 +528,17 @@ cp_build_qualified_type_real (tree type,\n   else\n     {\n       if (complain & tf_ignore_bad_quals)\n- \t/* We're not going to warn about constifying things that can't\n- \t   be constified.  */\n- \tbad_quals &= ~TYPE_QUAL_CONST;\n+\t/* We're not going to warn about constifying things that can't\n+\t   be constified.  */\n+\tbad_quals &= ~TYPE_QUAL_CONST;\n       if (bad_quals)\n- \t{\n- \t  tree bad_type = build_qualified_type (ptr_type_node, bad_quals);\n+\t{\n+\t  tree bad_type = build_qualified_type (ptr_type_node, bad_quals);\n \n- \t  if (!(complain & tf_ignore_bad_quals))\n- \t    error (\"%qV qualifiers cannot be applied to %qT\",\n+\t  if (!(complain & tf_ignore_bad_quals))\n+\t    error (\"%qV qualifiers cannot be applied to %qT\",\n \t\t   bad_type, type);\n- \t}\n+\t}\n     }\n \n   /* Retrieve (or create) the appropriately qualified variant.  */\n@@ -899,7 +899,7 @@ build_exception_variant (tree type, tree raises)\n \n   for (; v; v = TYPE_NEXT_VARIANT (v))\n     if (check_qualified_type (v, type, type_quals)\n-        && comp_except_specs (raises, TYPE_RAISES_EXCEPTIONS (v), 1))\n+\t&& comp_except_specs (raises, TYPE_RAISES_EXCEPTIONS (v), 1))\n       return v;\n \n   /* Need to build a new variant.  */\n@@ -965,8 +965,8 @@ count_trees (tree t)\n \n static tree\n verify_stmt_tree_r (tree* tp,\n-                    int* walk_subtrees ATTRIBUTE_UNUSED ,\n-                    void* data)\n+\t\t    int* walk_subtrees ATTRIBUTE_UNUSED ,\n+\t\t    void* data)\n {\n   tree t = *tp;\n   htab_t *statements = (htab_t *) data;\n@@ -1002,8 +1002,8 @@ verify_stmt_tree (tree t)\n \n static tree\n find_tree_r (tree* tp,\n-             int* walk_subtrees ATTRIBUTE_UNUSED ,\n-             void* data)\n+\t     int* walk_subtrees ATTRIBUTE_UNUSED ,\n+\t     void* data)\n {\n   if (*tp == (tree) data)\n     return (tree) data;\n@@ -1146,8 +1146,8 @@ bot_manip (tree* tp, int* walk_subtrees, void* data)\n   if (!TYPE_P (t) && TREE_CONSTANT (t))\n     {\n       /* There can't be any TARGET_EXPRs or their slot variables below\n-         this point.  We used to check !TREE_SIDE_EFFECTS, but then we\n-         failed to copy an ADDR_EXPR of the slot VAR_DECL.  */\n+\t this point.  We used to check !TREE_SIDE_EFFECTS, but then we\n+\t failed to copy an ADDR_EXPR of the slot VAR_DECL.  */\n       *walk_subtrees = 0;\n       return NULL_TREE;\n     }\n@@ -1193,8 +1193,8 @@ bot_manip (tree* tp, int* walk_subtrees, void* data)\n \n static tree\n bot_replace (tree* t,\n-             int* walk_subtrees ATTRIBUTE_UNUSED ,\n-             void* data)\n+\t     int* walk_subtrees ATTRIBUTE_UNUSED ,\n+\t     void* data)\n {\n   splay_tree target_remap = ((splay_tree) data);\n \n@@ -1642,8 +1642,8 @@ maybe_dummy_object (tree type, tree* binfop)\n \n   if (current_class_ref && context == current_class_type\n       /* Kludge: Make sure that current_class_type is actually\n-         correct.  It might not be if we're in the middle of\n-         tsubst_default_argument.  */\n+\t correct.  It might not be if we're in the middle of\n+\t tsubst_default_argument.  */\n       && same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (current_class_ref)),\n \t\t      current_class_type))\n     decl = current_class_ref;\n@@ -1722,17 +1722,17 @@ const struct attribute_spec cxx_attribute_table[] =\n   { \"java_interface\", 0, 0, false, false, false, handle_java_interface_attribute },\n   { \"com_interface\",  0, 0, false, false, false, handle_com_interface_attribute },\n   { \"init_priority\",  1, 1, true,  false, false, handle_init_priority_attribute },\n-  { NULL,             0, 0, false, false, false, NULL }\n+  { NULL,\t      0, 0, false, false, false, NULL }\n };\n \n /* Handle a \"java_interface\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n handle_java_interface_attribute (tree* node,\n-                                 tree name,\n-                                 tree args ATTRIBUTE_UNUSED ,\n-                                 int flags,\n-                                 bool* no_add_attrs)\n+\t\t\t\t tree name,\n+\t\t\t\t tree args ATTRIBUTE_UNUSED ,\n+\t\t\t\t int flags,\n+\t\t\t\t bool* no_add_attrs)\n {\n   if (DECL_P (*node)\n       || !CLASS_TYPE_P (*node)\n@@ -1754,10 +1754,10 @@ handle_java_interface_attribute (tree* node,\n    struct attribute_spec.handler.  */\n static tree\n handle_com_interface_attribute (tree* node,\n-                                tree name,\n-                                tree args ATTRIBUTE_UNUSED ,\n-                                int flags ATTRIBUTE_UNUSED ,\n-                                bool* no_add_attrs)\n+\t\t\t\ttree name,\n+\t\t\t\ttree args ATTRIBUTE_UNUSED ,\n+\t\t\t\tint flags ATTRIBUTE_UNUSED ,\n+\t\t\t\tbool* no_add_attrs)\n {\n   static int warned;\n \n@@ -1783,10 +1783,10 @@ handle_com_interface_attribute (tree* node,\n    struct attribute_spec.handler.  */\n static tree\n handle_init_priority_attribute (tree* node,\n-                                tree name,\n-                                tree args,\n-                                int flags ATTRIBUTE_UNUSED ,\n-                                bool* no_add_attrs)\n+\t\t\t\ttree name,\n+\t\t\t\ttree args,\n+\t\t\t\tint flags ATTRIBUTE_UNUSED ,\n+\t\t\t\tbool* no_add_attrs)\n {\n   tree initp_expr = TREE_VALUE (args);\n   tree decl = *node;\n@@ -1819,7 +1819,7 @@ handle_init_priority_attribute (tree* node,\n       || current_function_decl)\n     {\n       error (\"can only use %qE attribute on file-scope definitions \"\n-             \"of objects of class type\", name);\n+\t     \"of objects of class type\", name);\n       *no_add_attrs = true;\n       return NULL_TREE;\n     }\n@@ -1921,7 +1921,7 @@ cp_walk_subtrees (tree *tp, int *walk_subtrees_p, walk_tree_fn func,\n     case TYPEOF_TYPE:\n     case BASELINK:\n       /* None of these have subtrees other than those already walked\n-         above.  */\n+\t above.  */\n       *walk_subtrees_p = 0;\n       break;\n "}, {"sha": "3581ea2749bec3c41aa10282e63094cf17a3495c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 102, "deletions": 102, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -380,10 +380,10 @@ type_after_usual_arithmetic_conversions (tree t1, tree t2)\n \t\t\t\t\t     attributes);\n \n       /* Two floating-point types whose TYPE_MAIN_VARIANTs are none of\n-         the standard C++ floating-point types.  Logic earlier in this\n-         function has already eliminated the possibility that\n-         TYPE_PRECISION (t2) != TYPE_PRECISION (t1), so there's no\n-         compelling reason to choose one or the other.  */\n+\t the standard C++ floating-point types.  Logic earlier in this\n+\t function has already eliminated the possibility that\n+\t TYPE_PRECISION (t2) != TYPE_PRECISION (t1), so there's no\n+\t compelling reason to choose one or the other.  */\n       return build_type_attribute_variant (t1, attributes);\n     }\n }\n@@ -504,7 +504,7 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n \n       if (pedantic && TYPE_PTRFN_P (t2))\n \tpedwarn (\"ISO C++ forbids %s between pointer of type %<void *%> \"\n-                 \"and pointer-to-function\", location);\n+\t\t \"and pointer-to-function\", location);\n       result_type\n \t= cp_build_qualified_type (void_type_node,\n \t\t\t\t   (cp_type_quals (TREE_TYPE (t1))\n@@ -785,23 +785,23 @@ comp_except_types (tree a, tree b, bool exact)\n   else if (!exact)\n     {\n       if (cp_type_quals (a) || cp_type_quals (b))\n-        return false;\n+\treturn false;\n \n       if (TREE_CODE (a) == POINTER_TYPE\n-          && TREE_CODE (b) == POINTER_TYPE)\n-        {\n-          a = TREE_TYPE (a);\n-          b = TREE_TYPE (b);\n-          if (cp_type_quals (a) || cp_type_quals (b))\n-            return false;\n-        }\n+\t  && TREE_CODE (b) == POINTER_TYPE)\n+\t{\n+\t  a = TREE_TYPE (a);\n+\t  b = TREE_TYPE (b);\n+\t  if (cp_type_quals (a) || cp_type_quals (b))\n+\t    return false;\n+\t}\n \n       if (TREE_CODE (a) != RECORD_TYPE\n-          || TREE_CODE (b) != RECORD_TYPE)\n-        return false;\n+\t  || TREE_CODE (b) != RECORD_TYPE)\n+\treturn false;\n \n       if (PUBLICLY_UNIQUELY_DERIVED_P (a, b))\n-        return true;\n+\treturn true;\n     }\n   return false;\n }\n@@ -822,11 +822,11 @@ comp_except_specs (tree t1, tree t2, bool exact)\n   if (t1 == t2)\n     return true;\n \n-  if (t1 == NULL_TREE)              /* T1 is ...  */\n+  if (t1 == NULL_TREE)\t\t\t   /* T1 is ...  */\n     return t2 == NULL_TREE || !exact;\n-  if (!TREE_VALUE (t1)) /* t1 is EMPTY */\n+  if (!TREE_VALUE (t1))\t\t\t   /* t1 is EMPTY */\n     return t2 != NULL_TREE && !TREE_VALUE (t2);\n-  if (t2 == NULL_TREE)              /* T2 is ...  */\n+  if (t2 == NULL_TREE)\t\t\t   /* T2 is ...  */\n     return false;\n   if (TREE_VALUE (t1) && !TREE_VALUE (t2)) /* T2 is EMPTY, T1 is not */\n     return !exact;\n@@ -838,20 +838,20 @@ comp_except_specs (tree t1, tree t2, bool exact)\n   for (base = t1; t2 != NULL_TREE; t2 = TREE_CHAIN (t2))\n     {\n       for (probe = base; probe != NULL_TREE; probe = TREE_CHAIN (probe))\n-        {\n-          tree a = TREE_VALUE (probe);\n-          tree b = TREE_VALUE (t2);\n-\n-          if (comp_except_types (a, b, exact))\n-            {\n-              if (probe == base && exact)\n-                base = TREE_CHAIN (probe);\n-              length++;\n-              break;\n-            }\n-        }\n+\t{\n+\t  tree a = TREE_VALUE (probe);\n+\t  tree b = TREE_VALUE (t2);\n+\n+\t  if (comp_except_types (a, b, exact))\n+\t    {\n+\t      if (probe == base && exact)\n+\t\tbase = TREE_CHAIN (probe);\n+\t      length++;\n+\t      break;\n+\t    }\n+\t}\n       if (probe == NULL_TREE)\n-        return false;\n+\treturn false;\n     }\n   return !exact || base == NULL_TREE || length == list_length (t1);\n }\n@@ -905,9 +905,9 @@ comp_array_types (tree t1, tree t2, bool allow_redeclaration)\n       && !value_dependent_expression_p (max2))\n     {\n       /* With abi-1 we do not fold non-dependent array bounds, (and\n-         consequently mangle them incorrectly).  We must therefore\n-         fold them here, to verify the domains have the same\n-         value.  */\n+\t consequently mangle them incorrectly).  We must therefore\n+\t fold them here, to verify the domains have the same\n+\t value.  */\n       max1 = fold (max1);\n       max2 = fold (max2);\n     }\n@@ -1058,14 +1058,14 @@ comptypes (tree t1, tree t2, int strict)\n     case TYPENAME_TYPE:\n       if (!cp_tree_equal (TYPENAME_TYPE_FULLNAME (t1),\n \t\t\t  TYPENAME_TYPE_FULLNAME (t2)))\n-        return false;\n+\treturn false;\n       if (!same_type_p (TYPE_CONTEXT (t1), TYPE_CONTEXT (t2)))\n \treturn false;\n       break;\n \n     case UNBOUND_CLASS_TEMPLATE:\n       if (!cp_tree_equal (TYPE_IDENTIFIER (t1), TYPE_IDENTIFIER (t2)))\n-        return false;\n+\treturn false;\n       if (!same_type_p (TYPE_CONTEXT (t1), TYPE_CONTEXT (t2)))\n \treturn false;\n       break;\n@@ -1291,7 +1291,7 @@ cxx_sizeof_or_alignof_expr (tree e, enum tree_code op)\n   else if (is_overloaded_fn (e))\n     {\n       pedwarn (\"ISO C++ forbids applying %qs to an expression of \"\n-               \"function type\", op_name);\n+\t       \"function type\", op_name);\n       e = char_type_node;\n     }\n   else if (type_unknown_p (e))\n@@ -1632,9 +1632,9 @@ build_class_member_access_expr (tree object, tree member,\n   if (!member_scope || !DERIVED_FROM_P (member_scope, object_type))\n     {\n       if (TREE_CODE (member) == FIELD_DECL)\n-        error (\"invalid use of nonstatic data member %qE\", member);\n+\terror (\"invalid use of nonstatic data member %qE\", member);\n       else\n-        error (\"%qD is not a member of %qT\", member, object_type);\n+\terror (\"%qD is not a member of %qT\", member, object_type);\n       return error_mark_node;\n     }\n \n@@ -1685,7 +1685,7 @@ build_class_member_access_expr (tree object, tree member,\n \t  if (null_object_p && kind == bk_via_virtual)\n \t    {\n \t      error (\"invalid access to non-static data member %qD of \"\n-                     \"NULL object\",\n+\t\t     \"NULL object\",\n \t\t     member);\n \t      error (\"(perhaps the %<offsetof%> macro was used incorrectly)\");\n \t      return error_mark_node;\n@@ -2088,18 +2088,18 @@ build_indirect_ref (tree ptr, const char *errorstring)\n \t If the type of the expression is \"pointer to T,\" the type\n \t of  the  result  is  \"T.\"\n \n-         We must use the canonical variant because certain parts of\n+\t We must use the canonical variant because certain parts of\n \t the back end, like fold, do pointer comparisons between\n \t types.  */\n       tree t = canonical_type_variant (TREE_TYPE (type));\n \n       if (VOID_TYPE_P (t))\n-        {\n-          /* A pointer to incomplete type (other than cv void) can be\n-             dereferenced [expr.unary.op]/1  */\n-          error (\"%qT is not a pointer-to-object type\", type);\n-          return error_mark_node;\n-        }\n+\t{\n+\t  /* A pointer to incomplete type (other than cv void) can be\n+\t     dereferenced [expr.unary.op]/1  */\n+\t  error (\"%qT is not a pointer-to-object type\", type);\n+\t  return error_mark_node;\n+\t}\n       else if (TREE_CODE (pointer) == ADDR_EXPR\n \t       && same_type_p (t, TREE_TYPE (TREE_OPERAND (pointer, 0))))\n \t/* The POINTER was something like `&x'.  We simplify `*&x' to\n@@ -2467,8 +2467,8 @@ build_function_call (tree function, tree params)\n   if (TYPE_PTRMEMFUNC_P (fntype))\n     {\n       error (\"must use %<.*%> or %<->*%> to call pointer-to-member \"\n-             \"function in %<%E (...)%>\",\n-             original);\n+\t     \"function in %<%E (...)%>\",\n+\t     original);\n       return error_mark_node;\n     }\n \n@@ -2663,7 +2663,7 @@ convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n \t  if (fndecl)\n \t    {\n \t      cp_error_at (\"too few arguments to %s %q+#D\",\n-\t                   called_thing, fndecl);\n+\t\t\t   called_thing, fndecl);\n \t      error (\"at this point in file\");\n \t    }\n \t  else\n@@ -2815,7 +2815,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       if (t != error_mark_node)\n \t{\n \t  pedwarn (\"assuming cast to type %qT from overloaded function\",\n-                   TREE_TYPE (t));\n+\t\t   TREE_TYPE (t));\n \t  op0 = t;\n \t}\n     }\n@@ -2825,7 +2825,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       if (t != error_mark_node)\n \t{\n \t  pedwarn (\"assuming cast to type %qT from overloaded function\",\n-                   TREE_TYPE (t));\n+\t\t   TREE_TYPE (t));\n \t  op1 = t;\n \t}\n     }\n@@ -3356,10 +3356,10 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  if (TREE_CODE (TREE_TYPE (orig_op0)) == ENUMERAL_TYPE\n \t      && TREE_CODE (TREE_TYPE (orig_op1)) == ENUMERAL_TYPE\n \t      && TYPE_MAIN_VARIANT (TREE_TYPE (orig_op0))\n-\t         != TYPE_MAIN_VARIANT (TREE_TYPE (orig_op1)))\n+\t\t != TYPE_MAIN_VARIANT (TREE_TYPE (orig_op1)))\n \t    {\n \t      warning (0, \"comparison between types %q#T and %q#T\",\n-                       TREE_TYPE (orig_op0), TREE_TYPE (orig_op1));\n+\t\t       TREE_TYPE (orig_op0), TREE_TYPE (orig_op1));\n \t    }\n \n \t  /* Give warnings for comparisons between signed and unsigned\n@@ -3607,34 +3607,34 @@ build_x_unary_op (enum tree_code code, tree xarg)\n \t  if (TREE_CODE (xarg) != OFFSET_REF)\n \t    {\n \t      error (\"invalid use of %qE to form a pointer-to-member-function.\"\n-                     \"  Use a qualified-id.\",\n+\t\t     \"  Use a qualified-id.\",\n \t\t     xarg);\n \t      return error_mark_node;\n \t    }\n \t  else\n \t    {\n \t      error (\"parenthesis around %qE cannot be used to form a\"\n-                     \" pointer-to-member-function\",\n+\t\t     \" pointer-to-member-function\",\n \t\t     xarg);\n \t      PTRMEM_OK_P (xarg) = 1;\n \t    }\n \t}\n \n       if (TREE_CODE (xarg) == OFFSET_REF)\n-        {\n-          ptrmem = PTRMEM_OK_P (xarg);\n+\t{\n+\t  ptrmem = PTRMEM_OK_P (xarg);\n \n-          if (!ptrmem && !flag_ms_extensions\n-              && TREE_CODE (TREE_TYPE (TREE_OPERAND (xarg, 1))) == METHOD_TYPE)\n+\t  if (!ptrmem && !flag_ms_extensions\n+\t      && TREE_CODE (TREE_TYPE (TREE_OPERAND (xarg, 1))) == METHOD_TYPE)\n \t    {\n \t      /* A single non-static member, make sure we don't allow a\n-                 pointer-to-member.  */\n+\t\t pointer-to-member.  */\n \t      xarg = build2 (OFFSET_REF, TREE_TYPE (xarg),\n \t\t\t     TREE_OPERAND (xarg, 0),\n \t\t\t     ovl_cons (TREE_OPERAND (xarg, 1), NULL_TREE));\n \t      PTRMEM_OK_P (xarg) = ptrmem;\n \t    }\n-        }\n+\t}\n       else if (TREE_CODE (xarg) == TARGET_EXPR)\n \twarning (0, \"taking address of temporary\");\n       exp = build_unary_op (ADDR_EXPR, xarg, 0);\n@@ -3882,15 +3882,15 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \n \t    if (!COMPLETE_OR_VOID_TYPE_P (type))\n \t      error (\"cannot %s a pointer to incomplete type %qT\",\n-                     ((code == PREINCREMENT_EXPR\n-                       || code == POSTINCREMENT_EXPR)\n-                      ? \"increment\" : \"decrement\"), TREE_TYPE (argtype));\n+\t\t     ((code == PREINCREMENT_EXPR\n+\t\t       || code == POSTINCREMENT_EXPR)\n+\t\t      ? \"increment\" : \"decrement\"), TREE_TYPE (argtype));\n \t    else if ((pedantic || warn_pointer_arith)\n \t\t     && !TYPE_PTROB_P (argtype))\n \t      pedwarn (\"ISO C++ forbids %sing a pointer of type %qT\",\n-                       ((code == PREINCREMENT_EXPR\n-                         || code == POSTINCREMENT_EXPR)\n-                        ? \"increment\" : \"decrement\"), argtype);\n+\t\t       ((code == PREINCREMENT_EXPR\n+\t\t\t || code == POSTINCREMENT_EXPR)\n+\t\t\t? \"increment\" : \"decrement\"), argtype);\n \t    inc = cxx_sizeof_nowarn (TREE_TYPE (argtype));\n \t  }\n \telse\n@@ -4007,7 +4007,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \n       if (TREE_CODE (arg) == COMPONENT_REF && type_unknown_p (arg)\n \t  && !really_overloaded_fn (TREE_OPERAND (arg, 1)))\n-        {\n+\t{\n \t  /* They're trying to take the address of a unique non-static\n \t     member function.  This is ill-formed (except in MS-land),\n \t     but let's try to DTRT.\n@@ -4041,7 +4041,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t\t\t base, name);\n \t    }\n \t  arg = build_offset_ref (base, name, /*address_p=*/true);\n-        }\n+\t}\n \n     offset_ref:\n       if (type_unknown_p (arg))\n@@ -4297,7 +4297,7 @@ cxx_mark_addressable (tree exp)\n       case PARM_DECL:\n \tif (x == current_class_ptr)\n \t  {\n-            error (\"cannot take the address of %<this%>, which is an rvalue expression\");\n+\t    error (\"cannot take the address of %<this%>, which is an rvalue expression\");\n \t    TREE_ADDRESSABLE (x) = 1; /* so compiler doesn't die later.  */\n \t    return true;\n \t  }\n@@ -4442,7 +4442,7 @@ build_compound_expr (tree lhs, tree rhs)\n   if (TREE_CODE (rhs) == TARGET_EXPR)\n     {\n       /* If the rhs is a TARGET_EXPR, then build the compound\n-         expression inside the target_expr's initializer. This\n+\t expression inside the target_expr's initializer. This\n \t helps the compiler to eliminate unnecessary temporaries.  */\n       tree init = TREE_OPERAND (rhs, 1);\n \n@@ -4614,7 +4614,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n \t}\n       /* [expr.static.cast]\n \n-         If T is a reference type, the result is an lvalue; otherwise,\n+\t If T is a reference type, the result is an lvalue; otherwise,\n \t the result is an rvalue.  */\n       if (TREE_CODE (type) != REFERENCE_TYPE\n \t  && real_lvalue_p (result))\n@@ -4833,7 +4833,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n       if (! real_lvalue_p (expr))\n \t{\n \t  error (\"invalid cast of an rvalue expression of type \"\n-                 \"%qT to type %qT\",\n+\t\t \"%qT to type %qT\",\n \t\t intype, type);\n \t  return error_mark_node;\n \t}\n@@ -4892,7 +4892,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n     {\n       if (TYPE_PRECISION (type) < TYPE_PRECISION (intype))\n \tpedwarn (\"cast from %qT to %qT loses precision\",\n-                 intype, type);\n+\t\t intype, type);\n     }\n   /* [expr.reinterpret.cast]\n      A value of integral or enumeration type can be explicitly\n@@ -4927,10 +4927,10 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n     {\n       if (pedantic)\n \t/* Only issue a warning, as we have always supported this\n- \t   where possible, and it is necessary in some cases.  DR 195\n- \t   addresses this issue, but as of 2004/10/26 is still in\n- \t   drafting.  */\n- \twarning (0, \"ISO C++ forbids casting between pointer-to-function and pointer-to-object\");\n+\t   where possible, and it is necessary in some cases.  DR 195\n+\t   addresses this issue, but as of 2004/10/26 is still in\n+\t   drafting.  */\n+\twarning (0, \"ISO C++ forbids casting between pointer-to-function and pointer-to-object\");\n       return fold_if_not_in_template (build_nop (type, expr));\n     }\n   else if (TREE_CODE (type) == VECTOR_TYPE)\n@@ -5360,8 +5360,8 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n       else\n \t{\n \t  /* A binary op has been requested.  Combine the old LHS\n-     \t     value with the RHS producing the value we should actually\n-     \t     store into the LHS.  */\n+\t     value with the RHS producing the value we should actually\n+\t     store into the LHS.  */\n \n \t  gcc_assert (!PROMOTES_TO_AGGR_TYPE (lhstype, REFERENCE_TYPE));\n \t  lhs = stabilize_reference (lhs);\n@@ -5447,7 +5447,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \tpedwarn (\"ISO C++ forbids assignment of arrays\");\n \n       from_array = TREE_CODE (TREE_TYPE (newrhs)) == ARRAY_TYPE\n-\t           ? 1 + (modifycode != INIT_EXPR): 0;\n+\t\t   ? 1 + (modifycode != INIT_EXPR): 0;\n       return build_vec_init (lhs, NULL_TREE, newrhs, from_array);\n     }\n \n@@ -5674,7 +5674,7 @@ build_ptrmemfunc (tree type, tree pfn, int force, bool c_cast_p)\n       if (!force\n \t  && !can_convert_arg (to_type, TREE_TYPE (pfn), pfn))\n \terror (\"invalid conversion to type %qT from type %qT\",\n-               to_type, pfn_type);\n+\t       to_type, pfn_type);\n \n       n = get_delta_difference (TYPE_PTRMEMFUNC_OBJECT_TYPE (pfn_type),\n \t\t\t\tTYPE_PTRMEMFUNC_OBJECT_TYPE (to_type),\n@@ -5765,8 +5765,8 @@ expand_ptrmemfunc_cst (tree cst, tree *delta, tree *pfn)\n   else\n     {\n       /* If we're dealing with a virtual function, we have to adjust 'this'\n-         again, to point to the base which provides the vtable entry for\n-         fn; the call will do the opposite adjustment.  */\n+\t again, to point to the base which provides the vtable entry for\n+\t fn; the call will do the opposite adjustment.  */\n       tree orig_class = DECL_CONTEXT (fn);\n       tree binfo = binfo_or_else (orig_class, fn_class);\n       *delta = build2 (PLUS_EXPR, TREE_TYPE (*delta),\n@@ -5918,7 +5918,7 @@ convert_for_assignment (tree type, tree rhs,\n \t    instantiate_type (type, rhs, tf_error | tf_warning);\n \t  else if (fndecl)\n \t    error (\"cannot convert %qT to %qT for argument %qP to %qD\",\n-                   rhstype, type, parmnum, fndecl);\n+\t\t   rhstype, type, parmnum, fndecl);\n \t  else\n \t    error (\"cannot convert %qT to %qT in %s\", rhstype, type, errtype);\n \t  return error_mark_node;\n@@ -6149,7 +6149,7 @@ check_return_expr (tree retval)\n \t  finish_expr_stmt (retval);\n       else\n \tpedwarn (\"return-statement with a value, in function \"\n-                 \"returning 'void'\");\n+\t\t \"returning 'void'\");\n \n       current_function_returns_null = 1;\n \n@@ -6180,7 +6180,7 @@ check_return_expr (tree retval)\n       && ! flag_check_new\n       && null_ptr_cst_p (retval))\n     warning (0, \"%<operator new%> must not return NULL unless it is \"\n-             \"declared %<throw()%> (or -fcheck-new is in effect)\");\n+\t     \"declared %<throw()%> (or -fcheck-new is in effect)\");\n \n   /* Effective C++ rule 15.  See also start_function.  */\n   if (warn_ecpp\n@@ -6262,7 +6262,7 @@ check_return_expr (tree retval)\n \n       /* First convert the value to the function's return type, then\n \t to the type of return value's location to handle the\n-         case that functype is smaller than the valtype.  */\n+\t case that functype is smaller than the valtype.  */\n       retval = convert_for_initialization\n \t(NULL_TREE, functype, retval, LOOKUP_NORMAL|LOOKUP_ONLYCONVERTING,\n \t \"return\", NULL_TREE, 0);\n@@ -6446,14 +6446,14 @@ cp_apply_type_quals_to_decl (int type_quals, tree decl)\n       && type_quals != TYPE_UNQUALIFIED)\n     {\n       /* This was an error in C++98 (cv-qualifiers cannot be added to\n-         a function type), but DR 295 makes the code well-formed by\n-         dropping the extra qualifiers. */\n+\t a function type), but DR 295 makes the code well-formed by\n+\t dropping the extra qualifiers. */\n       if (pedantic)\n-        {\n-          tree bad_type = build_qualified_type (type, type_quals);\n-          pedwarn (\"ignoring %qV qualifiers added to function type %qT\",\n-                   bad_type, type);\n-        }\n+\t{\n+\t  tree bad_type = build_qualified_type (type, type_quals);\n+\t  pedwarn (\"ignoring %qV qualifiers added to function type %qT\",\n+\t\t   bad_type, type);\n+\t}\n \n       TREE_TYPE (decl) = TYPE_MAIN_VARIANT (type);\n       return;\n@@ -6494,19 +6494,19 @@ casts_away_constness_r (tree *t1, tree *t2)\n \n      For  two  pointer types:\n \n-            X1 is T1cv1,1 * ... cv1,N *   where T1 is not a pointer type\n-            X2 is T2cv2,1 * ... cv2,M *   where T2 is not a pointer type\n-            K is min(N,M)\n+\t    X1 is T1cv1,1 * ... cv1,N *   where T1 is not a pointer type\n+\t    X2 is T2cv2,1 * ... cv2,M *   where T2 is not a pointer type\n+\t    K is min(N,M)\n \n      casting from X1 to X2 casts away constness if, for a non-pointer\n      type T there does not exist an implicit conversion (clause\n      _conv_) from:\n \n-            Tcv1,(N-K+1) * cv1,(N-K+2) * ... cv1,N *\n+\t    Tcv1,(N-K+1) * cv1,(N-K+2) * ... cv1,N *\n \n      to\n \n-            Tcv2,(M-K+1) * cv2,(M-K+2) * ... cv2,M *.  */\n+\t    Tcv2,(M-K+1) * cv2,(M-K+2) * ... cv2,M *.  */\n   if ((!TYPE_PTR_P (*t1) && !TYPE_PTRMEM_P (*t1))\n       || (!TYPE_PTR_P (*t2) && !TYPE_PTRMEM_P (*t2)))\n     {"}, {"sha": "50940645944db81e4ae7d34adbec9e1ad45f34aa", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbd7506455e100f19b3bc4f74d1f8e62e5939f2/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=0cbd7506455e100f19b3bc4f74d1f8e62e5939f2", "patch": "@@ -84,9 +84,9 @@ readonly_error (tree arg, const char* string, int soft)\n   if (TREE_CODE (arg) == COMPONENT_REF)\n     {\n       if (TYPE_READONLY (TREE_TYPE (TREE_OPERAND (arg, 0))))\n-        fmt = \"%s of data-member %qD in read-only structure\";\n+\tfmt = \"%s of data-member %qD in read-only structure\";\n       else\n-        fmt = \"%s of read-only data-member %qD\";\n+\tfmt = \"%s of read-only data-member %qD\";\n       (*fn) (fmt, string, TREE_OPERAND (arg, 1));\n     }\n   else if (TREE_CODE (arg) == VAR_DECL)\n@@ -102,9 +102,9 @@ readonly_error (tree arg, const char* string, int soft)\n   else if (TREE_CODE (arg) == PARM_DECL)\n     (*fn) (\"%s of read-only parameter %qD\", string, arg);\n   else if (TREE_CODE (arg) == INDIRECT_REF\n-           && TREE_CODE (TREE_TYPE (TREE_OPERAND (arg, 0))) == REFERENCE_TYPE\n-           && (TREE_CODE (TREE_OPERAND (arg, 0)) == VAR_DECL\n-               || TREE_CODE (TREE_OPERAND (arg, 0)) == PARM_DECL))\n+\t   && TREE_CODE (TREE_TYPE (TREE_OPERAND (arg, 0))) == REFERENCE_TYPE\n+\t   && (TREE_CODE (TREE_OPERAND (arg, 0)) == VAR_DECL\n+\t       || TREE_CODE (TREE_OPERAND (arg, 0)) == PARM_DECL))\n     (*fn) (\"%s of read-only reference %qD\", string, TREE_OPERAND (arg, 0));\n   else if (TREE_CODE (arg) == RESULT_DECL)\n     (*fn) (\"%s of read-only named return value %qD\", string, arg);\n@@ -326,8 +326,8 @@ abstract_virtuals_error (tree decl, tree type)\n       for (ix = 0; VEC_iterate (tree, pure, ix, fn); ix++)\n \tinform (\"%J\\t%#D\", fn, fn);\n       /* Now truncate the vector.  This leaves it non-null, so we know\n-         there are pure virtuals, but empty so we don't list them out\n-         again.  */\n+\t there are pure virtuals, but empty so we don't list them out\n+\t again.  */\n       VEC_truncate (tree, pure, 0);\n     }\n   else\n@@ -386,7 +386,7 @@ cxx_incomplete_type_diagnostic (tree value, tree type, int diag_type)\n     case UNION_TYPE:\n     case ENUMERAL_TYPE:\n       if (!decl)\n-        (*p_msg) (\"invalid use of undefined type %q#T\", type);\n+\t(*p_msg) (\"invalid use of undefined type %q#T\", type);\n       if (!TYPE_TEMPLATE_INFO (type))\n \t(*p_msg_at) (\"forward declaration of %q#T\", type);\n       else\n@@ -399,10 +399,10 @@ cxx_incomplete_type_diagnostic (tree value, tree type, int diag_type)\n \n     case ARRAY_TYPE:\n       if (TYPE_DOMAIN (type))\n-        {\n-          type = TREE_TYPE (type);\n-          goto retry;\n-        }\n+\t{\n+\t  type = TREE_TYPE (type);\n+\t  goto retry;\n+\t}\n       (*p_msg) (\"invalid use of array with unspecified bounds\");\n       break;\n \n@@ -417,14 +417,14 @@ cxx_incomplete_type_diagnostic (tree value, tree type, int diag_type)\n \n     case UNKNOWN_TYPE:\n       if (value && TREE_CODE (value) == COMPONENT_REF)\n-        goto bad_member;\n+\tgoto bad_member;\n       else if (value && TREE_CODE (value) == ADDR_EXPR)\n-        (*p_msg) (\"address of overloaded function with no contextual \"\n-                  \"type information\");\n+\t(*p_msg) (\"address of overloaded function with no contextual \"\n+\t\t  \"type information\");\n       else if (value && TREE_CODE (value) == OVERLOAD)\n-        (*p_msg) (\"overloaded function with no contextual type information\");\n+\t(*p_msg) (\"overloaded function with no contextual type information\");\n       else\n-        (*p_msg) (\"insufficient contextual information to determine type\");\n+\t(*p_msg) (\"insufficient contextual information to determine type\");\n       break;\n \n     default:\n@@ -474,10 +474,10 @@ split_nonconstant_init_1 (tree dest, tree init)\n \t  if (TREE_CODE (value) == CONSTRUCTOR)\n \t    {\n \t      if (array_type_p)\n-\t        sub = build4 (ARRAY_REF, inner_type, dest, field_index,\n+\t\tsub = build4 (ARRAY_REF, inner_type, dest, field_index,\n \t\t\t      NULL_TREE, NULL_TREE);\n \t      else\n-\t        sub = build3 (COMPONENT_REF, inner_type, dest, field_index,\n+\t\tsub = build3 (COMPONENT_REF, inner_type, dest, field_index,\n \t\t\t      NULL_TREE);\n \n \t      split_nonconstant_init_1 (sub, value);\n@@ -487,10 +487,10 @@ split_nonconstant_init_1 (tree dest, tree init)\n \t      *pelt = TREE_CHAIN (elt);\n \n \t      if (array_type_p)\n-\t        sub = build4 (ARRAY_REF, inner_type, dest, field_index,\n+\t\tsub = build4 (ARRAY_REF, inner_type, dest, field_index,\n \t\t\t      NULL_TREE, NULL_TREE);\n \t      else\n-\t        sub = build3 (COMPONENT_REF, inner_type, dest, field_index,\n+\t\tsub = build3 (COMPONENT_REF, inner_type, dest, field_index,\n \t\t\t      NULL_TREE);\n \n \t      code = build2 (MODIFY_EXPR, inner_type, sub, value);\n@@ -580,7 +580,7 @@ store_init_value (tree decl, tree init)\n       if (TREE_CODE (init) == TREE_LIST)\n \t{\n \t  error (\"constructor syntax used, but no constructor declared \"\n-                 \"for type %qT\", type);\n+\t\t \"for type %qT\", type);\n \t  init = build_constructor (NULL_TREE, nreverse (init));\n \t}\n     }\n@@ -774,7 +774,7 @@ digest_init (tree type, tree init, tree* tail)\n \t  if (TYPE_NON_AGGREGATE_CLASS (type))\n \t    {\n \t      error (\"subobject of type %qT must be initialized by \"\n-                     \"constructor, not by %qE\",\n+\t\t     \"constructor, not by %qE\",\n \t\t     type, init);\n \t      return error_mark_node;\n \t    }\n@@ -994,17 +994,17 @@ process_init_constructor (tree type, tree init, tree* elts)\n \t\tnext1 = build_functional_cast (TREE_TYPE (field),\n \t\t\t\t\t       NULL_TREE);\n \t      else\n-\t        {\n+\t\t{\n \t\t  next1 = build_constructor (NULL_TREE, NULL_TREE);\n-                  if (init)\n-                    TREE_HAS_CONSTRUCTOR (next1)\n-                       = TREE_HAS_CONSTRUCTOR (init);\n-                }\n+\t\t  if (init)\n+\t\t    TREE_HAS_CONSTRUCTOR (next1)\n+\t\t       = TREE_HAS_CONSTRUCTOR (init);\n+\t\t}\n \t      next1 = digest_init (TREE_TYPE (field), next1, 0);\n \n \t      /* Warn when some struct elements are implicitly initialized.  */\n \t      if (warn_missing_field_initializers\n-\t          && (!init || BRACE_ENCLOSED_INITIALIZER_P (init)))\n+\t\t  && (!init || BRACE_ENCLOSED_INITIALIZER_P (init)))\n \t\twarning (0, \"missing initializer for member %qD\", field);\n \t    }\n \t  else\n@@ -1019,7 +1019,7 @@ process_init_constructor (tree type, tree init, tree* elts)\n \t      /* Warn when some struct elements are implicitly initialized\n \t\t to zero.  */\n \t      if (warn_missing_field_initializers\n-\t          && (!init || BRACE_ENCLOSED_INITIALIZER_P (init)))\n+\t\t  && (!init || BRACE_ENCLOSED_INITIALIZER_P (init)))\n \t\twarning (0, \"missing initializer for member %qD\", field);\n \n \t      if (! zero_init_p (TREE_TYPE (field)))\n@@ -1074,15 +1074,15 @@ process_init_constructor (tree type, tree init, tree* elts)\n \t\tfield = temp, win = 1;\n \t      else\n \t\terror (\"no field %qD in union being initialized\",\n-                       TREE_PURPOSE (tail));\n+\t\t       TREE_PURPOSE (tail));\n \t    }\n \t  if (!win)\n \t    TREE_VALUE (tail) = error_mark_node;\n \t}\n       else if (field == 0)\n \t{\n \t  error (\"union %qT with no named members cannot be initialized\",\n-                 type);\n+\t\t type);\n \t  TREE_VALUE (tail) = error_mark_node;\n \t}\n \n@@ -1288,7 +1288,7 @@ build_m_component_ref (tree datum, tree component)\n   if (!TYPE_PTR_TO_MEMBER_P (ptrmem_type))\n     {\n       error (\"%qE cannot be used as a member pointer, since it is of \"\n-             \"type %qT\",\n+\t     \"type %qT\",\n \t     component, ptrmem_type);\n       return error_mark_node;\n     }\n@@ -1297,8 +1297,8 @@ build_m_component_ref (tree datum, tree component)\n   if (! IS_AGGR_TYPE (objtype))\n     {\n       error (\"cannot apply member pointer %qE to %qE, which is of \"\n-             \"non-aggregate type %qT\",\n-             component, datum, objtype);\n+\t     \"non-aggregate type %qT\",\n+\t     component, datum, objtype);\n       return error_mark_node;\n     }\n \n@@ -1319,7 +1319,7 @@ build_m_component_ref (tree datum, tree component)\n \t{\n \tmismatch:\n \t  error (\"pointer to member type %qT incompatible with object \"\n-                 \"type %qT\",\n+\t\t \"type %qT\",\n \t\t type, objtype);\n \t  return error_mark_node;\n \t}\n@@ -1459,9 +1459,9 @@ add_exception_specifier (tree list, tree spec, int complain)\n     {\n       ok = true;\n       /* 15.4/1 says that types in an exception specifier must be complete,\n-         but it seems more reasonable to only require this on definitions\n-         and calls.  So just give a pedwarn at this point; we will give an\n-         error later if we hit one of those two cases.  */\n+\t but it seems more reasonable to only require this on definitions\n+\t and calls.  So just give a pedwarn at this point; we will give an\n+\t error later if we hit one of those two cases.  */\n       if (!COMPLETE_TYPE_P (complete_type (core)))\n \tdiag_type = 2; /* pedwarn */\n     }\n@@ -1471,8 +1471,8 @@ add_exception_specifier (tree list, tree spec, int complain)\n       tree probe;\n \n       for (probe = list; probe; probe = TREE_CHAIN (probe))\n-        if (same_type_p (TREE_VALUE (probe), spec))\n-          break;\n+\tif (same_type_p (TREE_VALUE (probe), spec))\n+\t  break;\n       if (!probe)\n \tlist = tree_cons (NULL_TREE, spec, list);\n     }\n@@ -1502,20 +1502,20 @@ merge_exception_specifiers (tree list, tree add)\n       tree orig_list = list;\n \n       for (; add; add = TREE_CHAIN (add))\n-        {\n-          tree spec = TREE_VALUE (add);\n-          tree probe;\n-\n-          for (probe = orig_list; probe; probe = TREE_CHAIN (probe))\n-            if (same_type_p (TREE_VALUE (probe), spec))\n-              break;\n-          if (!probe)\n-            {\n-              spec = build_tree_list (NULL_TREE, spec);\n-              TREE_CHAIN (spec) = list;\n-              list = spec;\n-            }\n-        }\n+\t{\n+\t  tree spec = TREE_VALUE (add);\n+\t  tree probe;\n+\n+\t  for (probe = orig_list; probe; probe = TREE_CHAIN (probe))\n+\t    if (same_type_p (TREE_VALUE (probe), spec))\n+\t      break;\n+\t  if (!probe)\n+\t    {\n+\t      spec = build_tree_list (NULL_TREE, spec);\n+\t      TREE_CHAIN (spec) = list;\n+\t      list = spec;\n+\t    }\n+\t}\n     }\n   return list;\n }"}]}