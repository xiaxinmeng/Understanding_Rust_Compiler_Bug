{"sha": "0a4e5cf3122f8237d840b34d0515151b61ffeb5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE0ZTVjZjMxMjJmODIzN2Q4NDBiMzRkMDUxNTE1MWI2MWZmZWI1ZQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2016-10-03T19:28:24Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-10-03T19:28:24Z"}, "message": "re PR tree-optimization/71550 (wrong code at -O3 on x86_64-linux-gnu)\n\n\tPR tree-optimization/71550\n\tPR tree-optimization/71403\n\t* tree-ssa-threadbackward.c: Include tree-vectorizer.h\n\t(profitable_jump_thread_path): Also return boolean indicating if\n\tthe realized path will create an irreducible loop.\n\tRemove loop depth tests from 71403.\n\t(fsm_find_control_statement_thread_paths): Remove loop depth tests\n\tfrom 71403.  If threading will create an irreducible loop, then\n\tthrow away loop iteration and related information.\n\n\tPR tree-optimization/71550\n\tPR tree-optimization/71403\n\t* gcc.c-torture/execute/pr71550.c: New test.\n\nFrom-SVN: r240727", "tree": {"sha": "8f5ba8447a97730e48ec8aeadb75ec9d3eb338d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f5ba8447a97730e48ec8aeadb75ec9d3eb338d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a4e5cf3122f8237d840b34d0515151b61ffeb5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a4e5cf3122f8237d840b34d0515151b61ffeb5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a4e5cf3122f8237d840b34d0515151b61ffeb5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a4e5cf3122f8237d840b34d0515151b61ffeb5e/comments", "author": null, "committer": null, "parents": [{"sha": "95ccd17c610e928f1b8089192d89456dd0dc891f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95ccd17c610e928f1b8089192d89456dd0dc891f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95ccd17c610e928f1b8089192d89456dd0dc891f"}], "stats": {"total": 82, "additions": 64, "deletions": 18}, "files": [{"sha": "ba56e636584e9e5bfa55cf0ae4a0021aec2f2e64", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a4e5cf3122f8237d840b34d0515151b61ffeb5e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a4e5cf3122f8237d840b34d0515151b61ffeb5e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a4e5cf3122f8237d840b34d0515151b61ffeb5e", "patch": "@@ -1,3 +1,15 @@\n+2016-10-03  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/71550\n+\tPR tree-optimization/71403\n+\t* tree-ssa-threadbackward.c: Include tree-vectorizer.h\n+\t(profitable_jump_thread_path): Also return boolean indicating if\n+\tthe realized path will create an irreducible loop.\n+\tRemove loop depth tests from 71403.\n+\t(fsm_find_control_statement_thread_paths): Remove loop depth tests\n+\tfrom 71403.  If threading will create an irreducible loop, then\n+\tthrow away loop iteration and related information.\n+\n 2016-10-03  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* configure.ac (strict_warn): Merge -Wmissing-format-attribute and"}, {"sha": "9e6246455cadbd332f35101a0a8c012d946e2308", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a4e5cf3122f8237d840b34d0515151b61ffeb5e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a4e5cf3122f8237d840b34d0515151b61ffeb5e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0a4e5cf3122f8237d840b34d0515151b61ffeb5e", "patch": "@@ -1,3 +1,9 @@\n+2016-09-26  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/71550\n+\tPR tree-optimization/71403\n+\t* gcc.c-torture/execute/pr71550.c: New test.\n+\n 2016-10-03  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>\n \n \t* gcc.target/avr/torture/builtins-error.c: Add -ffat-lto-objects"}, {"sha": "8d1ecdaa06dec45ce7af0f33c7e3fd705886c50e", "filename": "gcc/testsuite/gcc.c-torture/execute/pr71550.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a4e5cf3122f8237d840b34d0515151b61ffeb5e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr71550.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a4e5cf3122f8237d840b34d0515151b61ffeb5e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr71550.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr71550.c?ref=0a4e5cf3122f8237d840b34d0515151b61ffeb5e", "patch": "@@ -0,0 +1,26 @@\n+\n+extern void exit (int);\n+\n+int a = 3, b, c, f, g, h;\n+unsigned d;\n+char *e;\n+\n+int\n+main ()\n+{\n+  for (; a; a--)\n+    {\n+      int i;\n+      if (h && i)\n+\t__builtin_printf (\"%d%d\", c, f);\n+      i = 0;\n+      for (; i < 2; i++)\n+\tif (g)\n+\t  for (; d < 10; d++)\n+\t    b = *e;\n+      i = 0;\n+      for (; i < 1; i++)\n+\t;\n+    }\n+  exit (0);\n+}"}, {"sha": "fd7d855449d7b85f3e2d834d615e7dab23a5674c", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a4e5cf3122f8237d840b34d0515151b61ffeb5e/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a4e5cf3122f8237d840b34d0515151b61ffeb5e/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=0a4e5cf3122f8237d840b34d0515151b61ffeb5e", "patch": "@@ -36,6 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-ssa.h\"\n #include \"tree-phinodes.h\"\n #include \"tree-inline.h\"\n+#include \"tree-vectorizer.h\"\n \n static int max_threaded_paths;\n \n@@ -110,7 +111,8 @@ fsm_find_thread_path (basic_block start_bb, basic_block end_bb,\n \n static edge\n profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n-\t\t\t     basic_block bbi, tree name, tree arg, bool speed_p)\n+\t\t\t     basic_block bbi, tree name, tree arg, bool speed_p,\n+\t\t\t     bool *creates_irreducible_loop)\n {\n   /* Note BBI is not in the path yet, hence the +1 in the test below\n      to make sure BBI is accounted for in the path length test.  */\n@@ -296,12 +298,12 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n       return NULL;\n     }\n \n-  bool creates_irreducible_loop = false;\n+  *creates_irreducible_loop = false;\n   if (threaded_through_latch\n       && loop == taken_edge->dest->loop_father\n       && (determine_bb_domination_status (loop, taken_edge->dest)\n \t  == DOMST_NONDOMINATING))\n-    creates_irreducible_loop = true;\n+    *creates_irreducible_loop = true;\n \n   if (path_crosses_loops)\n     {\n@@ -343,7 +345,7 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n      the path -- in that case there's little the traditional loop\n      optimizer would have done anyway, so an irreducible loop is not\n      so bad.  */\n-  if (!threaded_multiway_branch && creates_irreducible_loop\n+  if (!threaded_multiway_branch && *creates_irreducible_loop\n       && (n_insns * PARAM_VALUE (PARAM_FSM_SCALE_PATH_STMTS)\n \t  > path_length * PARAM_VALUE (PARAM_FSM_SCALE_PATH_BLOCKS)))\n \n@@ -479,9 +481,6 @@ fsm_find_control_statement_thread_paths (tree name,\n       seen_loop_phi = true;\n     }\n \n-  if (bb_loop_depth (last_bb_in_path) > bb_loop_depth (var_bb))\n-    return;\n-\n   /* Following the chain of SSA_NAME definitions, we jumped from a definition in\n      LAST_BB_IN_PATH to a definition in VAR_BB.  When these basic blocks are\n      different, append to PATH the blocks from LAST_BB_IN_PATH to VAR_BB.  */\n@@ -528,9 +527,7 @@ fsm_find_control_statement_thread_paths (tree name,\n \t NEXT_PATH.  Don't add them here to avoid pollution.  */\n       for (unsigned int i = 0; i < next_path->length () - 1; i++)\n \t{\n-\t  if (visited_bbs->contains ((*next_path)[i])\n-\t      || (bb_loop_depth (last_bb_in_path)\n-\t\t  > bb_loop_depth ((*next_path)[i])))\n+\t  if (visited_bbs->contains ((*next_path)[i]))\n \t    {\n \t      vec_free (next_path);\n \t      return;\n@@ -580,14 +577,16 @@ fsm_find_control_statement_thread_paths (tree name,\n \n \t  /* If this is a profitable jump thread path, then convert it\n \t     into the canonical form and register it.  */\n+\t  bool irreducible = false;\n \t  edge taken_edge = profitable_jump_thread_path (path, bbi, name, arg,\n-\t\t\t\t\t\t\t speed_p);\n+\t\t\t\t\t\t\t speed_p, &irreducible);\n \t  if (taken_edge)\n \t    {\n-\t      if (bb_loop_depth (taken_edge->src)\n-\t\t  >= bb_loop_depth (taken_edge->dest))\n-\t\tconvert_and_register_jump_thread_path (path, taken_edge);\n+\t      convert_and_register_jump_thread_path (path, taken_edge);\n \t      path->pop ();\n+\n+\t      if (irreducible)\n+\t\tvect_free_loop_info_assumptions ((*path)[0]->loop_father);\n \t    }\n \t}\n     }\n@@ -606,14 +605,17 @@ fsm_find_control_statement_thread_paths (tree name,\n \t     block at this point.  So we can just pop it.  */\n \t  path->pop ();\n \n+\t  bool irreducible = false;\n \t  edge taken_edge = profitable_jump_thread_path (path, var_bb,\n-\t\t\t\t\t\t         name, arg, speed_p);\n+\t\t\t\t\t\t         name, arg, speed_p,\n+\t\t\t\t\t\t\t &irreducible);\n \t  if (taken_edge)\n \t    {\n-\t      if (bb_loop_depth (taken_edge->src)\n-\t\t  >= bb_loop_depth (taken_edge->dest))\n-\t\tconvert_and_register_jump_thread_path (path, taken_edge);\n+\t      convert_and_register_jump_thread_path (path, taken_edge);\n \t      path->pop ();\n+\n+\t      if (irreducible)\n+\t\tvect_free_loop_info_assumptions ((*path)[0]->loop_father);\n \t    }\n \n \t  /* And put the current block back onto the path so that the"}]}