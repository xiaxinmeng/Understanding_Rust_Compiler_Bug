{"sha": "5277688be09abdc754e56919ed6011caf7191ede", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI3NzY4OGJlMDlhYmRjNzU0ZTU2OTE5ZWQ2MDExY2FmNzE5MWVkZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-05-25T21:05:03Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-05-25T21:05:03Z"}, "message": "decl.c (gnat_to_gnu_entity): Move around.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Constant>: Move around.\n\t<E_Exception>: Merge with E_Variable case.\n\t<E_Variable>: Remove 'object' label.\n\nFrom-SVN: r223654", "tree": {"sha": "afaf6ee4f4e5ffbb5d28d57bbf3fe9a8d54802ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afaf6ee4f4e5ffbb5d28d57bbf3fe9a8d54802ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5277688be09abdc754e56919ed6011caf7191ede", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5277688be09abdc754e56919ed6011caf7191ede", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5277688be09abdc754e56919ed6011caf7191ede", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5277688be09abdc754e56919ed6011caf7191ede/comments", "author": null, "committer": null, "parents": [{"sha": "2117b9bb988c489ff1a2233e066abc7cf9b136c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2117b9bb988c489ff1a2233e066abc7cf9b136c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2117b9bb988c489ff1a2233e066abc7cf9b136c1"}], "stats": {"total": 169, "additions": 85, "deletions": 84}, "files": [{"sha": "2851ff1e1f85ea02df8f218ccf7c5c1aadaea53e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5277688be09abdc754e56919ed6011caf7191ede/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5277688be09abdc754e56919ed6011caf7191ede/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5277688be09abdc754e56919ed6011caf7191ede", "patch": "@@ -1,3 +1,9 @@\n+2015-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Constant>: Move around.\n+\t<E_Exception>: Merge with E_Variable case.\n+\t<E_Variable>: Remove 'object' label.\n+\n 2015-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity): Minor tweak."}, {"sha": "e8cacb43c5b8ba846116d9d8374f92c0c49b50cf", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 79, "deletions": 84, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5277688be09abdc754e56919ed6011caf7191ede/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5277688be09abdc754e56919ed6011caf7191ede/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=5277688be09abdc754e56919ed6011caf7191ede", "patch": "@@ -448,87 +448,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n   switch (kind)\n     {\n-    case E_Constant:\n-      /* If this is a use of a deferred constant without address clause,\n-\t get its full definition.  */\n-      if (!definition\n-\t  && No (Address_Clause (gnat_entity))\n-\t  && Present (Full_View (gnat_entity)))\n-\t{\n-\t  gnu_decl\n-\t    = gnat_to_gnu_entity (Full_View (gnat_entity), gnu_expr, 0);\n-\t  saved = true;\n-\t  break;\n-\t}\n-\n-      /* If we have an external constant that we are not defining, get the\n-\t expression that is was defined to represent.  We may throw it away\n-\t later if it is not a constant.  But do not retrieve the expression\n-\t if it is an allocator because the designated type might be dummy\n-\t at this point.  */\n-      if (!definition\n-\t  && !No_Initialization (Declaration_Node (gnat_entity))\n-\t  && Present (Expression (Declaration_Node (gnat_entity)))\n-\t  && Nkind (Expression (Declaration_Node (gnat_entity)))\n-\t     != N_Allocator)\n-\t{\n-\t  bool went_into_elab_proc = false;\n-\t  int save_force_global = force_global;\n-\n-\t  /* The expression may contain N_Expression_With_Actions nodes and\n-\t     thus object declarations from other units.  In this case, even\n-\t     though the expression will eventually be discarded since not a\n-\t     constant, the declarations would be stuck either in the global\n-\t     varpool or in the current scope.  Therefore we force the local\n-\t     context and create a fake scope that we'll zap at the end.  */\n-\t  if (!current_function_decl)\n-\t    {\n-\t      current_function_decl = get_elaboration_procedure ();\n-\t      went_into_elab_proc = true;\n-\t    }\n-\t  force_global = 0;\n-\t  gnat_pushlevel ();\n-\n-\t  gnu_expr = gnat_to_gnu (Expression (Declaration_Node (gnat_entity)));\n-\n-\t  gnat_zaplevel ();\n-\t  force_global = save_force_global;\n-\t  if (went_into_elab_proc)\n-\t    current_function_decl = NULL_TREE;\n-\t}\n-\n-      /* Ignore deferred constant definitions without address clause since\n-\t they are processed fully in the front-end.  If No_Initialization\n-\t is set, this is not a deferred constant but a constant whose value\n-\t is built manually.  And constants that are renamings are handled\n-\t like variables.  */\n-      if (definition\n-\t  && !gnu_expr\n-\t  && No (Address_Clause (gnat_entity))\n-\t  && !No_Initialization (Declaration_Node (gnat_entity))\n-\t  && No (Renamed_Object (gnat_entity)))\n-\t{\n-\t  gnu_decl = error_mark_node;\n-\t  saved = true;\n-\t  break;\n-\t}\n-\n-      /* Ignore constant definitions already marked with the error node.  See\n-\t the N_Object_Declaration case of gnat_to_gnu for the rationale.  */\n-      if (definition\n-\t  && gnu_expr\n-\t  && present_gnu_tree (gnat_entity)\n-\t  && get_gnu_tree (gnat_entity) == error_mark_node)\n-\t{\n-\t  maybe_present = true;\n-\t  break;\n-\t}\n-\n-      goto object;\n-\n-    case E_Exception:\n-      goto object;\n-\n     case E_Component:\n     case E_Discriminant:\n       {\n@@ -596,12 +515,88 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  gcc_unreachable ();\n       }\n \n+    case E_Constant:\n+      /* Ignore constant definitions already marked with the error node.  See\n+\t the N_Object_Declaration case of gnat_to_gnu for the rationale.  */\n+      if (definition\n+\t  && gnu_expr\n+\t  && present_gnu_tree (gnat_entity)\n+\t  && get_gnu_tree (gnat_entity) == error_mark_node)\n+\t{\n+\t  maybe_present = true;\n+\t  break;\n+\t}\n+\n+      /* Ignore deferred constant definitions without address clause since\n+\t they are processed fully in the front-end.  If No_Initialization\n+\t is set, this is not a deferred constant but a constant whose value\n+\t is built manually.  And constants that are renamings are handled\n+\t like variables.  */\n+      if (definition\n+\t  && !gnu_expr\n+\t  && No (Address_Clause (gnat_entity))\n+\t  && !No_Initialization (Declaration_Node (gnat_entity))\n+\t  && No (Renamed_Object (gnat_entity)))\n+\t{\n+\t  gnu_decl = error_mark_node;\n+\t  saved = true;\n+\t  break;\n+\t}\n+\n+      /* If this is a use of a deferred constant without address clause,\n+\t get its full definition.  */\n+      if (!definition\n+\t  && No (Address_Clause (gnat_entity))\n+\t  && Present (Full_View (gnat_entity)))\n+\t{\n+\t  gnu_decl\n+\t    = gnat_to_gnu_entity (Full_View (gnat_entity), gnu_expr, 0);\n+\t  saved = true;\n+\t  break;\n+\t}\n+\n+      /* If we have an external constant that we are not defining, get the\n+\t expression that is was defined to represent.  We may throw it away\n+\t later if it is not a constant.  But do not retrieve the expression\n+\t if it is an allocator because the designated type might be dummy\n+\t at this point.  */\n+      if (!definition\n+\t  && !No_Initialization (Declaration_Node (gnat_entity))\n+\t  && Present (Expression (Declaration_Node (gnat_entity)))\n+\t  && Nkind (Expression (Declaration_Node (gnat_entity)))\n+\t     != N_Allocator)\n+\t{\n+\t  bool went_into_elab_proc = false;\n+\t  int save_force_global = force_global;\n+\n+\t  /* The expression may contain N_Expression_With_Actions nodes and\n+\t     thus object declarations from other units.  In this case, even\n+\t     though the expression will eventually be discarded since not a\n+\t     constant, the declarations would be stuck either in the global\n+\t     varpool or in the current scope.  Therefore we force the local\n+\t     context and create a fake scope that we'll zap at the end.  */\n+\t  if (!current_function_decl)\n+\t    {\n+\t      current_function_decl = get_elaboration_procedure ();\n+\t      went_into_elab_proc = true;\n+\t    }\n+\t  force_global = 0;\n+\t  gnat_pushlevel ();\n+\n+\t  gnu_expr = gnat_to_gnu (Expression (Declaration_Node (gnat_entity)));\n+\n+\t  gnat_zaplevel ();\n+\t  force_global = save_force_global;\n+\t  if (went_into_elab_proc)\n+\t    current_function_decl = NULL_TREE;\n+\t}\n+\n+      /* ... fall through ... */\n+\n+    case E_Exception:\n     case E_Loop_Parameter:\n     case E_Out_Parameter:\n     case E_Variable:\n-\n-      /* Simple variables, loop variables, Out parameters and exceptions.  */\n-    object:\n       {\n \t/* Always create a variable for volatile objects and variables seen\n \t   constant but with a Linker_Section pragma.  */"}]}