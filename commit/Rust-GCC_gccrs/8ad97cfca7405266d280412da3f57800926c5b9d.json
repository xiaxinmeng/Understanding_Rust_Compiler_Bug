{"sha": "8ad97cfca7405266d280412da3f57800926c5b9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFkOTdjZmNhNzQwNTI2NmQyODA0MTJkYTNmNTc4MDA5MjZjNWI5ZA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2008-07-09T06:45:21Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2008-07-09T06:45:21Z"}, "message": "genattrtab.c (insert_right_side, [...]): Avoid C++ keywords.\n\n\t* genattrtab.c (insert_right_side, evaluate_eq_attr): Avoid C++\n\tkeywords.\n\t* genemit.c (gen_insn): Likewise.\n\t* gengtype.c (note_def_vec): Likewise.\n\t* gengtype.h (note_def_vec): Likewise.\n\t* genoutput.c (struct data, output_insn_data, process_template,\n\tgen_expand, gen_split, note_constraint): Likewise.\n\t* genrecog.c (new_decision, add_to_sequence, factor_tests,\n\tmake_insn_sequence): Likewise.\n\t* gensupport.c (record_insn_name): Likewise.\n\nFrom-SVN: r137653", "tree": {"sha": "6954eaaa696c6bf48cf413495c59ff795a740dc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6954eaaa696c6bf48cf413495c59ff795a740dc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ad97cfca7405266d280412da3f57800926c5b9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ad97cfca7405266d280412da3f57800926c5b9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ad97cfca7405266d280412da3f57800926c5b9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ad97cfca7405266d280412da3f57800926c5b9d/comments", "author": null, "committer": null, "parents": [{"sha": "588021c0e8ef99701465aee44d7a18135bc1bbee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/588021c0e8ef99701465aee44d7a18135bc1bbee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/588021c0e8ef99701465aee44d7a18135bc1bbee"}], "stats": {"total": 157, "additions": 85, "deletions": 72}, "files": [{"sha": "463a649f6272664f0d14e097b4c2c8d8c28d68a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad97cfca7405266d280412da3f57800926c5b9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad97cfca7405266d280412da3f57800926c5b9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ad97cfca7405266d280412da3f57800926c5b9d", "patch": "@@ -1,3 +1,16 @@\n+2008-07-09  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* genattrtab.c (insert_right_side, evaluate_eq_attr): Avoid C++\n+\tkeywords.\n+\t* genemit.c (gen_insn): Likewise.\n+\t* gengtype.c (note_def_vec): Likewise.\n+\t* gengtype.h (note_def_vec): Likewise.\n+\t* genoutput.c (struct data, output_insn_data, process_template,\n+\tgen_expand, gen_split, note_constraint): Likewise.\n+\t* genrecog.c (new_decision, add_to_sequence, factor_tests,\n+\tmake_insn_sequence): Likewise.\n+\t* gensupport.c (record_insn_name): Likewise.\n+\n 2008-07-08  Doug Kwan  <dougkwan@google.com>\n \n \t* config/arm/arm.opt (mandroid): New option."}, {"sha": "794a8db1bb10fa158edee56889355d844d837a53", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad97cfca7405266d280412da3f57800926c5b9d/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad97cfca7405266d280412da3f57800926c5b9d/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=8ad97cfca7405266d280412da3f57800926c5b9d", "patch": "@@ -1846,11 +1846,11 @@ insert_right_side (enum rtx_code code, rtx exp, rtx term, int insn_code, int ins\n \n   if (GET_CODE (exp) == code)\n     {\n-      rtx new = insert_right_side (code, XEXP (exp, 1),\n-\t\t\t\t   term, insn_code, insn_index);\n-      if (new != XEXP (exp, 1))\n+      rtx new_rtx = insert_right_side (code, XEXP (exp, 1),\n+\t\t\t\t       term, insn_code, insn_index);\n+      if (new_rtx != XEXP (exp, 1))\n \t/* Make a copy of this expression and call recursively.  */\n-\tnewexp = attr_rtx (code, XEXP (exp, 0), new);\n+\tnewexp = attr_rtx (code, XEXP (exp, 0), new_rtx);\n       else\n \tnewexp = exp;\n     }\n@@ -1980,10 +1980,10 @@ evaluate_eq_attr (rtx exp, rtx value, int insn_code, int insn_index)\n \n       for (i = 0; i < XVECLEN (value, 0); i += 2)\n \t{\n-\t  rtx this = simplify_test_exp_in_temp (XVECEXP (value, 0, i),\n-\t\t\t\t\t\tinsn_code, insn_index);\n+\t  rtx this_cond = simplify_test_exp_in_temp (XVECEXP (value, 0, i),\n+\t\t\t\t\t\t    insn_code, insn_index);\n \n-\t  right = insert_right_side (AND, andexp, this,\n+\t  right = insert_right_side (AND, andexp, this_cond,\n \t\t\t\t     insn_code, insn_index);\n \t  right = insert_right_side (AND, right,\n \t\t\t\t     evaluate_eq_attr (exp,\n@@ -1995,7 +1995,7 @@ evaluate_eq_attr (rtx exp, rtx value, int insn_code, int insn_index)\n \t\t\t\t     insn_code, insn_index);\n \n \t  /* Add this condition into the AND expression.  */\n-\t  newexp = attr_rtx (NOT, this);\n+\t  newexp = attr_rtx (NOT, this_cond);\n \t  andexp = insert_right_side (AND, andexp, newexp,\n \t\t\t\t      insn_code, insn_index);\n \t}"}, {"sha": "35e5691b94fc77accef3c18dd5bb6f6f48102f46", "filename": "gcc/genemit.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad97cfca7405266d280412da3f57800926c5b9d/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad97cfca7405266d280412da3f57800926c5b9d/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=8ad97cfca7405266d280412da3f57800926c5b9d", "patch": "@@ -357,17 +357,17 @@ gen_insn (rtx insn, int lineno)\n \n \t      for (j = i + 1; j < XVECLEN (insn, 1); j++)\n \t\t{\n-\t\t  rtx old = XEXP (XVECEXP (p->pattern, 1, j), 0);\n-\t\t  rtx new = XEXP (XVECEXP (insn, 1, j), 0);\n+\t\t  rtx old_rtx = XEXP (XVECEXP (p->pattern, 1, j), 0);\n+\t\t  rtx new_rtx = XEXP (XVECEXP (insn, 1, j), 0);\n \n-\t\t  /* OLD and NEW are the same if both are to be a SCRATCH\n+\t\t  /* OLD and NEW_INSN are the same if both are to be a SCRATCH\n \t\t     of the same mode,\n \t\t     or if both are registers of the same mode and number.  */\n-\t\t  if (! (GET_MODE (old) == GET_MODE (new)\n-\t\t\t && ((GET_CODE (old) == MATCH_SCRATCH\n-\t\t\t      && GET_CODE (new) == MATCH_SCRATCH)\n-\t\t\t     || (REG_P (old) && REG_P (new)\n-\t\t\t\t && REGNO (old) == REGNO (new)))))\n+\t\t  if (! (GET_MODE (old_rtx) == GET_MODE (new_rtx)\n+\t\t\t && ((GET_CODE (old_rtx) == MATCH_SCRATCH\n+\t\t\t      && GET_CODE (new_rtx) == MATCH_SCRATCH)\n+\t\t\t     || (REG_P (old_rtx) && REG_P (new_rtx)\n+\t\t\t\t && REGNO (old_rtx) == REGNO (new_rtx)))))\n \t\t    break;\n \t\t}\n "}, {"sha": "f7309b16c88c5bbfc6c93409fca33a5bc791aa3f", "filename": "gcc/gengtype.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad97cfca7405266d280412da3f57800926c5b9d/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad97cfca7405266d280412da3f57800926c5b9d/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=8ad97cfca7405266d280412da3f57800926c5b9d", "patch": "@@ -3529,22 +3529,22 @@ write_roots (pair_p variables)\n    where the GTY(()) tags are only present if is_scalar is _false_.  */\n \n void\n-note_def_vec (const char *typename, bool is_scalar, struct fileloc *pos)\n+note_def_vec (const char *type_name, bool is_scalar, struct fileloc *pos)\n {\n   pair_p fields;\n   type_p t;\n   options_p o;\n   type_p len_ty = create_scalar_type (\"unsigned\");\n-  const char *name = concat (\"VEC_\", typename, \"_base\", (char *)0);\n+  const char *name = concat (\"VEC_\", type_name, \"_base\", (char *)0);\n \n   if (is_scalar)\n     {\n-      t = create_scalar_type (typename);\n+      t = create_scalar_type (type_name);\n       o = 0;\n     }\n   else\n     {\n-      t = resolve_typedef (typename, pos);\n+      t = resolve_typedef (type_name, pos);\n       o = create_option (0, \"length\", \"%h.num\");\n     }\n "}, {"sha": "916570a8b9c43f9873632401043bf46f1edb4f1a", "filename": "gcc/gengtype.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad97cfca7405266d280412da3f57800926c5b9d/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad97cfca7405266d280412da3f57800926c5b9d/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=8ad97cfca7405266d280412da3f57800926c5b9d", "patch": "@@ -64,7 +64,7 @@ extern pair_p nreverse_pairs (pair_p list);\n extern type_p adjust_field_type (type_p, options_p);\n extern void note_variable (const char *s, type_p t, options_p o,\n \t\t\t   struct fileloc *pos);\n-extern void note_def_vec (const char *typename, bool is_scalar,\n+extern void note_def_vec (const char *type_name, bool is_scalar,\n \t\t\t  struct fileloc *pos);\n extern void note_def_vec_alloc (const char *type, const char *astrat,\n \t\t\t\tstruct fileloc *pos);"}, {"sha": "601483d8b2f2bf5869489dfbc6575fb40b20fa58", "filename": "gcc/genoutput.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad97cfca7405266d280412da3f57800926c5b9d/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad97cfca7405266d280412da3f57800926c5b9d/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=8ad97cfca7405266d280412da3f57800926c5b9d", "patch": "@@ -154,7 +154,7 @@ struct data\n {\n   struct data *next;\n   const char *name;\n-  const char *template;\n+  const char *template_code;\n   int code_number;\n   int index_number;\n   const char *filename;\n@@ -336,7 +336,7 @@ output_insn_data (void)\n \t  break;\n \tcase INSN_OUTPUT_FORMAT_SINGLE:\n \t  {\n-\t    const char *p = d->template;\n+\t    const char *p = d->template_code;\n \t    char prev = 0;\n \n \t    printf (\"#if HAVE_DESIGNATED_INITIALIZERS\\n\");\n@@ -656,36 +656,36 @@ place_operands (struct data *d)\n    templates, or C code to generate the assembler code template.  */\n \n static void\n-process_template (struct data *d, const char *template)\n+process_template (struct data *d, const char *template_code)\n {\n   const char *cp;\n   int i;\n \n   /* Templates starting with * contain straight code to be run.  */\n-  if (template[0] == '*')\n+  if (template_code[0] == '*')\n     {\n-      d->template = 0;\n+      d->template_code = 0;\n       d->output_format = INSN_OUTPUT_FORMAT_FUNCTION;\n \n       puts (\"\\nstatic const char *\");\n       printf (\"output_%d (rtx *operands ATTRIBUTE_UNUSED, rtx insn ATTRIBUTE_UNUSED)\\n\",\n \t      d->code_number);\n       puts (\"{\");\n-      print_rtx_ptr_loc (template);\n-      puts (template + 1);\n+      print_rtx_ptr_loc (template_code);\n+      puts (template_code + 1);\n       puts (\"}\");\n     }\n \n   /* If the assembler code template starts with a @ it is a newline-separated\n      list of assembler code templates, one for each alternative.  */\n-  else if (template[0] == '@')\n+  else if (template_code[0] == '@')\n     {\n-      d->template = 0;\n+      d->template_code = 0;\n       d->output_format = INSN_OUTPUT_FORMAT_MULTI;\n \n       printf (\"\\nstatic const char * const output_%d[] = {\\n\", d->code_number);\n \n-      for (i = 0, cp = &template[1]; *cp; )\n+      for (i = 0, cp = &template_code[1]; *cp; )\n \t{\n \t  const char *ep, *sp;\n \n@@ -725,7 +725,7 @@ process_template (struct data *d, const char *template)\n     }\n   else\n     {\n-      d->template = template;\n+      d->template_code = template_code;\n       d->output_format = INSN_OUTPUT_FORMAT_SINGLE;\n     }\n }\n@@ -952,7 +952,7 @@ gen_expand (rtx insn, int lineno)\n \n   d->n_operands = max_opno + 1;\n   d->n_dups = num_dups;\n-  d->template = 0;\n+  d->template_code = 0;\n   d->output_format = INSN_OUTPUT_FORMAT_NONE;\n \n   validate_insn_alternatives (d);\n@@ -993,7 +993,7 @@ gen_split (rtx split, int lineno)\n   d->n_operands = max_opno + 1;\n   d->n_dups = 0;\n   d->n_alternatives = 0;\n-  d->template = 0;\n+  d->template_code = 0;\n   d->output_format = INSN_OUTPUT_FORMAT_NONE;\n \n   place_operands (d);\n@@ -1120,7 +1120,7 @@ note_constraint (rtx exp, int lineno)\n {\n   const char *name = XSTR (exp, 0);\n   unsigned int namelen = strlen (name);\n-  struct constraint_data **iter, **slot, *new;\n+  struct constraint_data **iter, **slot, *new_cdata;\n \n   /* The 'm' constraint is special here since that constraint letter\n      can be overridden by the back end by defining the\n@@ -1173,12 +1173,12 @@ note_constraint (rtx exp, int lineno)\n \t  return;\n \t}\n     }\n-  new = XNEWVAR (struct constraint_data, sizeof (struct constraint_data) + namelen);\n-  strcpy ((char *)new + offsetof(struct constraint_data, name), name);\n-  new->namelen = namelen;\n-  new->lineno = lineno;\n-  new->next_this_letter = *slot;\n-  *slot = new;\n+  new_cdata = XNEWVAR (struct constraint_data, sizeof (struct constraint_data) + namelen);\n+  strcpy ((char *)new_cdata + offsetof(struct constraint_data, name), name);\n+  new_cdata->namelen = namelen;\n+  new_cdata->lineno = lineno;\n+  new_cdata->next_this_letter = *slot;\n+  *slot = new_cdata;\n }\n \n /* Return the length of the constraint name beginning at position S"}, {"sha": "70ab87745d372a21146f8fbdc6281b52458de28b", "filename": "gcc/genrecog.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad97cfca7405266d280412da3f57800926c5b9d/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad97cfca7405266d280412da3f57800926c5b9d/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=8ad97cfca7405266d280412da3f57800926c5b9d", "patch": "@@ -474,14 +474,14 @@ extern void debug_decision_list\n static struct decision *\n new_decision (const char *position, struct decision_head *last)\n {\n-  struct decision *new = XCNEW (struct decision);\n+  struct decision *new_decision = XCNEW (struct decision);\n \n-  new->success = *last;\n-  new->position = xstrdup (position);\n-  new->number = next_number++;\n+  new_decision->success = *last;\n+  new_decision->position = xstrdup (position);\n+  new_decision->number = next_number++;\n \n-  last->first = last->last = new;\n-  return new;\n+  last->first = last->last = new_decision;\n+  return new_decision;\n }\n \n /* Create a new test and link it in at PLACE.  */\n@@ -877,7 +877,7 @@ add_to_sequence (rtx pattern, struct decision_head *last, const char *position,\n \t\t enum routine_type insn_type, int top)\n {\n   RTX_CODE code;\n-  struct decision *this, *sub;\n+  struct decision *this_decision, *sub;\n   struct decision_test *test;\n   struct decision_test **place;\n   char *subpos;\n@@ -894,8 +894,8 @@ add_to_sequence (rtx pattern, struct decision_head *last, const char *position,\n   strcpy (subpos, position);\n   subpos[depth + 1] = 0;\n \n-  sub = this = new_decision (position, last);\n-  place = &this->tests;\n+  sub = this_decision = new_decision (position, last);\n+  place = &this_decision->tests;\n \n  restart:\n   mode = GET_MODE (pattern);\n@@ -1142,20 +1142,20 @@ add_to_sequence (rtx pattern, struct decision_head *last, const char *position,\n      before any of the nodes we may have added above.  */\n   if (code != UNKNOWN)\n     {\n-      place = &this->tests;\n+      place = &this_decision->tests;\n       test = new_decision_test (DT_code, &place);\n       test->u.code = code;\n     }\n \n   if (mode != VOIDmode)\n     {\n-      place = &this->tests;\n+      place = &this_decision->tests;\n       test = new_decision_test (DT_mode, &place);\n       test->u.mode = mode;\n     }\n \n   /* If we didn't insert any tests or accept nodes, hork.  */\n-  gcc_assert (this->tests);\n+  gcc_assert (this_decision->tests);\n \n  ret:\n   free (subpos);\n@@ -1592,7 +1592,7 @@ factor_tests (struct decision_head *head)\n   for (first = head->first; first && first->next; first = next)\n     {\n       enum decision_type type;\n-      struct decision *new, *old_last;\n+      struct decision *new_dec, *old_last;\n \n       type = first->tests->type;\n       next = first->next;\n@@ -1615,8 +1615,8 @@ factor_tests (struct decision_head *head)\n          below our first test.  */\n       if (first->tests->next != NULL)\n \t{\n-\t  new = new_decision (first->position, &first->success);\n-\t  new->tests = first->tests->next;\n+\t  new_dec = new_decision (first->position, &first->success);\n+\t  new_dec->tests = first->tests->next;\n \t  first->tests->next = NULL;\n \t}\n \n@@ -1633,14 +1633,14 @@ factor_tests (struct decision_head *head)\n \n \t  if (next->tests->next != NULL)\n \t    {\n-\t      new = new_decision (next->position, &next->success);\n-\t      new->tests = next->tests->next;\n+\t      new_dec = new_decision (next->position, &next->success);\n+\t      new_dec->tests = next->tests->next;\n \t      next->tests->next = NULL;\n \t    }\n-\t  new = next;\n+\t  new_dec = next;\n \t  next = next->next;\n-\t  new->next = NULL;\n-\t  h.first = h.last = new;\n+\t  new_dec->next = NULL;\n+\t  h.first = h.last = new_dec;\n \n \t  merge_trees (head, &h);\n \t}\n@@ -2618,25 +2618,25 @@ make_insn_sequence (rtx insn, enum routine_type type)\n \n \t  if (i != XVECLEN (x, 0))\n \t    {\n-\t      rtx new;\n+\t      rtx new_rtx;\n \t      struct decision_head clobber_head;\n \n \t      /* Build a similar insn without the clobbers.  */\n \t      if (i == 1)\n-\t\tnew = XVECEXP (x, 0, 0);\n+\t\tnew_rtx = XVECEXP (x, 0, 0);\n \t      else\n \t\t{\n \t\t  int j;\n \n-\t\t  new = rtx_alloc (PARALLEL);\n-\t\t  XVEC (new, 0) = rtvec_alloc (i);\n+\t\t  new_rtx = rtx_alloc (PARALLEL);\n+\t\t  XVEC (new_rtx, 0) = rtvec_alloc (i);\n \t\t  for (j = i - 1; j >= 0; j--)\n-\t\t    XVECEXP (new, 0, j) = XVECEXP (x, 0, j);\n+\t\t    XVECEXP (new_rtx, 0, j) = XVECEXP (x, 0, j);\n \t\t}\n \n \t      /* Recognize it.  */\n \t      memset (&clobber_head, 0, sizeof(clobber_head));\n-\t      last = add_to_sequence (new, &clobber_head, \"\", type, 1);\n+\t      last = add_to_sequence (new_rtx, &clobber_head, \"\", type, 1);\n \n \t      /* Find the end of the test chain on the last node.  */\n \t      for (test = last->tests; test->next; test = test->next)"}, {"sha": "540c30e35758c1bc8df004feee5e517809e83aa6", "filename": "gcc/gensupport.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad97cfca7405266d280412da3f57800926c5b9d/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad97cfca7405266d280412da3f57800926c5b9d/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=8ad97cfca7405266d280412da3f57800926c5b9d", "patch": "@@ -1428,7 +1428,7 @@ record_insn_name (int code, const char *name)\n {\n   static const char *last_real_name = \"insn\";\n   static int last_real_code = 0;\n-  char *new;\n+  char *new_name;\n \n   if (insn_name_ptr_size <= code)\n     {\n@@ -1442,14 +1442,14 @@ record_insn_name (int code, const char *name)\n \n   if (!name || name[0] == '\\0')\n     {\n-      new = XNEWVAR (char, strlen (last_real_name) + 10);\n-      sprintf (new, \"%s+%d\", last_real_name, code - last_real_code);\n+      new_name = XNEWVAR (char, strlen (last_real_name) + 10);\n+      sprintf (new_name, \"%s+%d\", last_real_name, code - last_real_code);\n     }\n   else\n     {\n-      last_real_name = new = xstrdup (name);\n+      last_real_name = new_name = xstrdup (name);\n       last_real_code = code;\n     }\n \n-  insn_name_ptr[code] = new;\n+  insn_name_ptr[code] = new_name;\n }"}]}