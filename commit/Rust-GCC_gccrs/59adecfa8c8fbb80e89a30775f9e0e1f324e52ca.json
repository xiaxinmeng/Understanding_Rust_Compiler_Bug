{"sha": "59adecfa8c8fbb80e89a30775f9e0e1f324e52ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTlhZGVjZmE4YzhmYmI4MGU4OWEzMDc3NWY5ZTBlMWYzMjRlNTJjYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "1999-11-29T22:56:39Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1999-11-29T22:56:39Z"}, "message": "fold-const.c (extract_muldiv, [...]): Reverse operation if C is negative.\n\n\t* fold-const.c (extract_muldiv, case {MIN,MAX}_EXPR): Reverse\n\toperation if C is negative.\n\t(extract_muldiv, case SAVE_EXPR): Supresss if arg has side effects.\n\t(extract_muldiv, case {PLUS,MINUS}_EXPR): Don't apply distributive\n\tlaw for some divisions if constant is negative and change other\n\tdivisions to the opposite rounding.\n\nFrom-SVN: r30714", "tree": {"sha": "1c896300e51d20eabe1dc79b9551f9bcde35d9f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c896300e51d20eabe1dc79b9551f9bcde35d9f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59adecfa8c8fbb80e89a30775f9e0e1f324e52ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59adecfa8c8fbb80e89a30775f9e0e1f324e52ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59adecfa8c8fbb80e89a30775f9e0e1f324e52ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59adecfa8c8fbb80e89a30775f9e0e1f324e52ca/comments", "author": null, "committer": null, "parents": [{"sha": "ce64861eed4220d7a75b09079c13f42553d9b804", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce64861eed4220d7a75b09079c13f42553d9b804", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce64861eed4220d7a75b09079c13f42553d9b804"}], "stats": {"total": 73, "additions": 54, "deletions": 19}, "files": [{"sha": "50560378d2d54311cdd9b2f06c0624657a57b953", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59adecfa8c8fbb80e89a30775f9e0e1f324e52ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59adecfa8c8fbb80e89a30775f9e0e1f324e52ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=59adecfa8c8fbb80e89a30775f9e0e1f324e52ca", "patch": "@@ -1,5 +1,12 @@\n Mon Nov 29 16:56:42 1999  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* fold-const.c (extract_muldiv, case {MIN,MAX}_EXPR): Reverse\n+\toperation if C is negative.\n+\t(extract_muldiv, case SAVE_EXPR): Supresss if arg has side effects.\n+\t(extract_muldiv, case {PLUS,MINUS}_EXPR): Don't apply distributive\n+\tlaw for some divisions if constant is negative and change other\n+\tdivisions to the opposite rounding.\n+\n \t* expr.c (store_constructor_field): If bit position is not multiple\n \tof alignment of TARGET's mode, use BLKmode.\n "}, {"sha": "8766eb8ee0d0f29e88c5236d8921a9c5fa2d02cd", "filename": "gcc/fold-const.c", "status": "modified", "additions": 47, "deletions": 19, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59adecfa8c8fbb80e89a30775f9e0e1f324e52ca/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59adecfa8c8fbb80e89a30775f9e0e1f324e52ca/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=59adecfa8c8fbb80e89a30775f9e0e1f324e52ca", "patch": "@@ -4299,8 +4299,8 @@ extract_muldiv (t, c, code, wide_type)\n     case CONVERT_EXPR:  case NON_LVALUE_EXPR:  case NOP_EXPR:\n \n       /* Pass the constant down and see if we can make a simplification.  If\n-\t we can, replace this expression with a conversion of that result to\n-\t our type.  */\n+\t we can, replace this expression with the inner simplification for\n+\t possible later conversion to our or some other type.  */\n       if (0 != (t1 = extract_muldiv (op0, convert (TREE_TYPE (op0), c), code,\n \t\t\t\t     code == MULT_EXPR ? ctype : NULL_TREE)))\n \treturn t1;\n@@ -4315,8 +4315,13 @@ extract_muldiv (t, c, code, wide_type)\n       /* MIN (a, b) / 5 -> MIN (a / 5, b / 5)  */\n       if ((t1 = extract_muldiv (op0, c, code, wide_type)) != 0\n \t  && (t2 = extract_muldiv (op1, c, code, wide_type)) != 0)\n-\treturn fold (build (tcode, ctype, convert (ctype, t1),\n-\t\t\t    convert (ctype, t2)));\n+\t{\n+\t  if (tree_int_cst_sgn (c) < 0)\n+\t    tcode = (tcode == MIN_EXPR ? MAX_EXPR : MIN_EXPR);\n+\n+\t  return fold (build (tcode, ctype, convert (ctype, t1),\n+\t\t\t      convert (ctype, t2)));\n+\t}\n       break;\n \n     case WITH_RECORD_EXPR:\n@@ -4326,9 +4331,12 @@ extract_muldiv (t, c, code, wide_type)\n       break;\n \n     case SAVE_EXPR:\n-      /* If this has not been evaluated, we can see if we can do\n-\t something inside it and make a new one.  */\n-      if (SAVE_EXPR_RTL (t) == 0\n+      /* If this has not been evaluated and the operand has no side effects,\n+\t we can see if we can do something inside it and make a new one.\n+\t Note that this test is overly conservative since we can do this\n+\t if the only reason it had side effects is that it was another\n+\t similar SAVE_EXPR, but that isn't worth bothering with.  */\n+      if (SAVE_EXPR_RTL (t) == 0 && ! TREE_SIDE_EFFECTS (TREE_OPERAND (t, 0))\n \t  && 0 != (t1 = extract_muldiv (TREE_OPERAND (t, 0), c, code,\n \t\t\t\t\twide_type)))\n \treturn save_expr (t1);\n@@ -4362,26 +4370,46 @@ extract_muldiv (t, c, code, wide_type)\n       else if (TREE_CODE (op1) != INTEGER_CST)\n \tbreak;\n \n+      /* If this was a subtraction, negate OP1 and set it to be an addition.\n+\t This simplifies the logic below.  */\n+      if (tcode == MINUS_EXPR)\n+\ttcode = PLUS_EXPR, op1 = negate_expr (op1);\n+\n+      /* If either OP1 or C are negative, this optimization is not safe for\n+\t some of the division and remainder types while for others we need\n+\t to change the code.  */\n+      if (tree_int_cst_sgn (op1) < 0 || tree_int_cst_sgn (c) < 0)\n+\t{\n+\t  if (code == CEIL_DIV_EXPR)\n+\t    code = FLOOR_DIV_EXPR;\n+\t  else if (code == CEIL_MOD_EXPR)\n+\t    code = FLOOR_MOD_EXPR;\n+\t  else if (code == FLOOR_DIV_EXPR)\n+\t    code = CEIL_DIV_EXPR;\n+\t  else if (code == FLOOR_MOD_EXPR)\n+\t    code = CEIL_MOD_EXPR;\n+\t  else if (code != MULT_EXPR)\n+\t    break;\n+\t}\n+\n+      /* Now do the operation and verify it doesn't overflow.  */\n+      op1 = const_binop (code, convert (ctype, op1), convert (ctype, c), 0);\n+      if (op1 == 0 || TREE_OVERFLOW (op1))\n+\tbreak;\n+\n       /* If we were able to eliminate our operation from the first side,\n-\t apply our operation to the second side and reform the PLUS or\n-\t MINUS.  */\n-      if (t1 != 0 && (TREE_CODE (t1) != code || code == MULT_EXPR)\n-\t  && 0 != (t2 = const_binop (code, convert (ctype, op1),\n-\t\t\t\t     convert (ctype, c), 0))\n-\t  && ! TREE_OVERFLOW (t2))\n-\treturn fold (build (tcode, ctype, convert (ctype, t1), t2));\n+\t apply our operation to the second side and reform the PLUS.  */\n+      if (t1 != 0 && (TREE_CODE (t1) != code || code == MULT_EXPR))\n+\treturn fold (build (tcode, ctype, convert (ctype, t1), op1));\n \n       /* The last case is if we are a multiply.  In that case, we can\n \t apply the distributive law to commute the multiply and addition\n \t if the multiplication of the constants doesn't overflow. */\n-      if (code == MULT_EXPR\n-\t  && 0 != (t1 = const_binop (code, convert (ctype, op1),\n-\t\t\t\t     convert (ctype, c), 0))\n-\t  && ! TREE_OVERFLOW (t1))\n+      if (code == MULT_EXPR)\n \treturn fold (build (tcode, ctype, fold (build (code, ctype,\n \t\t\t\t\t\t       convert (ctype, op0),\n \t\t\t\t\t\t       convert (ctype, c))),\n-\t\t\t    t1));\n+\t\t\t    op1));\n \n       break;\n "}]}