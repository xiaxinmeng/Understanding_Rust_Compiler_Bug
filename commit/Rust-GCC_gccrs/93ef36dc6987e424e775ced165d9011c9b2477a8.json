{"sha": "93ef36dc6987e424e775ced165d9011c9b2477a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNlZjM2ZGM2OTg3ZTQyNGU3NzVjZWQxNjVkOTAxMWM5YjI0NzdhOA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-11-05T13:35:38Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-11-05T13:35:38Z"}, "message": "Fix GNU coding style.\n\n2018-11-05  Martin Liska  <mliska@suse.cz>\n\n\t* mem-stats.h (mem_alloc_description::get_list): Fix GNU coding\n\tstyle.\n\t* vec.c: Likewise.\n\nFrom-SVN: r265798", "tree": {"sha": "1bd01ca286b1f5797d93ef459ca2306b01398e18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bd01ca286b1f5797d93ef459ca2306b01398e18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93ef36dc6987e424e775ced165d9011c9b2477a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93ef36dc6987e424e775ced165d9011c9b2477a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93ef36dc6987e424e775ced165d9011c9b2477a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93ef36dc6987e424e775ced165d9011c9b2477a8/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "46aeb07ff8f75808f6a76af52e9d8d9647e3b935", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46aeb07ff8f75808f6a76af52e9d8d9647e3b935", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46aeb07ff8f75808f6a76af52e9d8d9647e3b935"}], "stats": {"total": 68, "additions": 32, "deletions": 36}, "files": [{"sha": "45f2e904f3b62c3e4b45bef7ee3efd4ead75e7c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93ef36dc6987e424e775ced165d9011c9b2477a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93ef36dc6987e424e775ced165d9011c9b2477a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93ef36dc6987e424e775ced165d9011c9b2477a8", "patch": "@@ -1,3 +1,9 @@\n+2018-11-05  Martin Liska  <mliska@suse.cz>\n+\n+\t* mem-stats.h (mem_alloc_description::get_list): Fix GNU coding\n+\tstyle.\n+\t* vec.c: Likewise.\n+\n 2018-11-05  Richard Biener  <rguenther@suse.de>\n \n \t* tree-scalar-evolution.h (final_value_replacement_loop): Update"}, {"sha": "3ef6d53dfa625e235d47dcddefcf042fdf4a3758", "filename": "gcc/mem-stats.h", "status": "modified", "additions": 26, "deletions": 35, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93ef36dc6987e424e775ced165d9011c9b2477a8/gcc%2Fmem-stats.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93ef36dc6987e424e775ced165d9011c9b2477a8/gcc%2Fmem-stats.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmem-stats.h?ref=93ef36dc6987e424e775ced165d9011c9b2477a8", "patch": "@@ -282,21 +282,21 @@ class mem_alloc_description\n     static hashval_t\n     hash (value_type l)\n     {\n-\tinchash::hash hstate;\n+      inchash::hash hstate;\n \n-\thstate.add_ptr ((const void *)l->m_filename);\n-\thstate.add_ptr (l->m_function);\n-\thstate.add_int (l->m_line);\n+      hstate.add_ptr ((const void *)l->m_filename);\n+      hstate.add_ptr (l->m_function);\n+      hstate.add_int (l->m_line);\n \n-\treturn hstate.end ();\n+      return hstate.end ();\n     }\n \n     static bool\n     equal (value_type l1, value_type l2)\n     {\n-      return l1->m_filename == l2->m_filename\n-\t&& l1->m_function == l2->m_function\n-\t&& l1->m_line == l2->m_line;\n+      return (l1->m_filename == l2->m_filename\n+\t      && l1->m_function == l2->m_function\n+\t      && l1->m_line == l2->m_line);\n     }\n   };\n \n@@ -313,59 +313,50 @@ class mem_alloc_description\n   ~mem_alloc_description ();\n \n   /* Returns true if instance PTR is registered by the memory description.  */\n-  bool\n-  contains_descriptor_for_instance (const void *ptr);\n+  bool contains_descriptor_for_instance (const void *ptr);\n \n   /* Return descriptor for instance PTR.  */\n-  T *\n-  get_descriptor_for_instance (const void *ptr);\n+  T * get_descriptor_for_instance (const void *ptr);\n \n   /* Register memory allocation descriptor for container PTR which is\n      described by a memory LOCATION.  */\n-  T *\n-  register_descriptor (const void *ptr, mem_location *location);\n+  T * register_descriptor (const void *ptr, mem_location *location);\n \n   /* Register memory allocation descriptor for container PTR.  ORIGIN identifies\n      type of container and GGC identifes if the allocation is handled in GGC\n      memory.  Each location is identified by file NAME, LINE in source code and\n      FUNCTION name.  */\n-  T *\n-  register_descriptor (const void *ptr, mem_alloc_origin origin,\n-\t\t\t  bool ggc, const char *name, int line,\n-\t\t\t  const char *function);\n+  T * register_descriptor (const void *ptr, mem_alloc_origin origin,\n+\t\t\t   bool ggc, const char *name, int line,\n+\t\t\t   const char *function);\n \n   /* Register instance overhead identified by PTR pointer. Allocation takes\n      SIZE bytes.  */\n-  T *\n-  register_instance_overhead (size_t size, const void *ptr);\n+  T * register_instance_overhead (size_t size, const void *ptr);\n \n   /* For containers (and GGC) where we want to track every instance object,\n      we register allocation of SIZE bytes, identified by PTR pointer, belonging\n      to USAGE descriptor.  */\n-  void\n-  register_object_overhead (T *usage, size_t size, const void *ptr);\n+  void register_object_overhead (T *usage, size_t size, const void *ptr);\n \n   /* Release PTR pointer of SIZE bytes. If REMOVE_FROM_MAP is set to true,\n      remove the instance from reverse map.  */\n-  void\n-  release_instance_overhead (void *ptr, size_t size,\n+  void release_instance_overhead (void *ptr, size_t size,\n \t\t\t\t  bool remove_from_map = false);\n \n   /* Release intance object identified by PTR pointer.  */\n-  void\n-  release_object_overhead (void *ptr);\n+  void release_object_overhead (void *ptr);\n \n   /* Get sum value for ORIGIN type of allocation for the descriptor.  */\n-  T\n-  get_sum (mem_alloc_origin origin);\n+  T get_sum (mem_alloc_origin origin);\n \n   /* Get all tracked instances registered by the description. Items\n      are filtered by ORIGIN type, LENGTH is return value where we register\n      the number of elements in the list. If we want to process custom order,\n      CMP comparator can be provided.  */\n-  mem_list_t *\n-  get_list (mem_alloc_origin origin, unsigned *length,\n-\t    int (*cmp) (const void *first, const void *second) = NULL);\n+  mem_list_t * get_list (mem_alloc_origin origin, unsigned *length,\n+\t\t\t int (*cmp) (const void *first,\n+\t\t\t\t     const void *second) = NULL);\n \n   /* Dump all tracked instances of type ORIGIN. If we want to process custom\n      order, CMP comparator can be provided.  */\n@@ -391,7 +382,6 @@ class mem_alloc_description\n   reverse_mem_map_t *m_reverse_map;\n };\n \n-\n /* Returns true if instance PTR is registered by the memory description.  */\n \n template <class T>\n@@ -410,9 +400,9 @@ mem_alloc_description<T>::get_descriptor_for_instance (const void *ptr)\n   return m_reverse_map->get (ptr) ? (*m_reverse_map->get (ptr)).usage : NULL;\n }\n \n+/* Register memory allocation descriptor for container PTR which is\n+   described by a memory LOCATION.  */\n \n-  /* Register memory allocation descriptor for container PTR which is\n-     described by a memory LOCATION.  */\n template <class T>\n inline T*\n mem_alloc_description<T>::register_descriptor (const void *ptr,\n@@ -584,7 +574,8 @@ template <class T>\n inline\n typename mem_alloc_description<T>::mem_list_t *\n mem_alloc_description<T>::get_list (mem_alloc_origin origin, unsigned *length,\n-\t\t\tint (*cmp) (const void *first, const void *second))\n+\t\t\t\t    int (*cmp) (const void *first,\n+\t\t\t\t\t\tconst void *second))\n {\n   /* vec data structure is not used because all vectors generate memory\n      allocation info a it would create a cycle.  */"}, {"sha": "ff2456aead9ea67e738ee7c72aedb3e51c0dd48c", "filename": "gcc/vec.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93ef36dc6987e424e775ced165d9011c9b2477a8/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93ef36dc6987e424e775ced165d9011c9b2477a8/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=93ef36dc6987e424e775ced165d9011c9b2477a8", "patch": "@@ -141,7 +141,6 @@ vec_prefix::release_overhead (void *ptr, size_t size, bool in_dtor\n   vec_mem_desc.release_instance_overhead (ptr, size, in_dtor);\n }\n \n-\n /* Calculate the number of slots to reserve a vector, making sure that\n    it is of at least DESIRED size by growing ALLOC exponentially.  */\n "}]}