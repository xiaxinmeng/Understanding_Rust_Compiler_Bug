{"sha": "6a9a79a866b120d678d6463bcdb718fe87c8717f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE5YTc5YTg2NmIxMjBkNjc4ZDY0NjNiY2RiNzE4ZmU4N2M4NzE3Zg==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-07-19T18:46:15Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2005-07-19T18:46:15Z"}, "message": "Makefile.in: Removed tree-promote-statics.c\n\n2005-07-19  Danny Berlin <dberlin@dberlin.org>\n\t    Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\t* Makefile.in: Removed tree-promote-statics.c\n\t* tree-promote-statics.c: Removed.\n\t* common.opt: Removed flag-promote-statics.\n\t* opts.c: Ditto.\n\t* passes.c: Removed tree-promote-statics pass.\n\t* tree-pass.h: Ditto.\n\t* timevar.def: Removed TV_PROMOTE_STATICS.\n\n\n2005-07-19  Danny Berlin <dberlin@dberlin.org>\n\t    Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\t* gcc.dg/tree-ssa/sra-2.c: Changed back to -O1 and added xfail.\n\nCo-Authored-By: Kenneth Zadeck <zadeck@naturalbridge.com>\n\nFrom-SVN: r102165", "tree": {"sha": "ad122a8fd681f6240e07c7b412f0d56a45f067f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad122a8fd681f6240e07c7b412f0d56a45f067f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a9a79a866b120d678d6463bcdb718fe87c8717f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a9a79a866b120d678d6463bcdb718fe87c8717f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a9a79a866b120d678d6463bcdb718fe87c8717f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a9a79a866b120d678d6463bcdb718fe87c8717f/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "89a0b917ad42084fcadd237119beca05b5b18edf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89a0b917ad42084fcadd237119beca05b5b18edf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89a0b917ad42084fcadd237119beca05b5b18edf"}], "stats": {"total": 631, "additions": 20, "deletions": 611}, "files": [{"sha": "3e3c6e3b1cbcb3367fb6bcb8dc67370b5d03353d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9a79a866b120d678d6463bcdb718fe87c8717f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9a79a866b120d678d6463bcdb718fe87c8717f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a9a79a866b120d678d6463bcdb718fe87c8717f", "patch": "@@ -1,3 +1,15 @@\n+2005-07-19  Danny Berlin <dberlin@dberlin.org>\n+\t    Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t* Makefile.in: Removed tree-promote-statics.c\n+\t* tree-promote-statics.c: Removed.\n+\t* common.opt: Removed flag-promote-statics.\n+\t* opts.c: Ditto.\n+\t* passes.c: Removed tree-promote-statics pass. \n+\t* tree-pass.h: Ditto.\n+\t* timevar.def: Removed TV_PROMOTE_STATICS.\n+\n+\n 2005-07-19  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* config.gcc: Add support for *-*-freebsd7, *-*-freebsd8,"}, {"sha": "cc52cc3ea1322df95df1ee631fc91225dd0ba0a9", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9a79a866b120d678d6463bcdb718fe87c8717f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9a79a866b120d678d6463bcdb718fe87c8717f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6a9a79a866b120d678d6463bcdb718fe87c8717f", "patch": "@@ -948,7 +948,7 @@ OBJS-common = \\\n  integrate.o intl.o jump.o  langhooks.o lcm.o lists.o local-alloc.o  \t   \\\n  loop.o mode-switching.o modulo-sched.o optabs.o options.o opts.o\t   \\\n  params.o postreload.o postreload-gcse.o predict.o\t\t\t   \\\n- insn-preds.o pointer-set.o tree-promote-statics.o\t\t   \t   \\\n+ insn-preds.o pointer-set.o \t\t\t\t\t   \t   \\\n  print-rtl.o print-tree.o profile.o value-prof.o var-tracking.o\t\t   \\\n  real.o recog.o reg-stack.o regclass.o regmove.o regrename.o\t\t   \\\n  reload.o reload1.o reorg.o resource.o rtl.o rtlanal.o rtl-error.o\t   \\\n@@ -2218,9 +2218,6 @@ tree-vect-generic.o : tree-vect-generic.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n     $(FLAGS_H) $(OPTABS_H) $(RTL_H) $(MACHMODE_H) $(EXPR_H) \\\n     langhooks.h $(FLAGS_H) $(DIAGNOSTIC_H) gt-tree-vect-generic.h $(GGC_H) \\\n     coretypes.h insn-codes.h\n-tree-promote-statics.o : tree-promote-statics.c $(CONFIG_H) system.h \\\n-   $(TREE_H) $(TM_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(IPA_UTILS_H) \\\n-   $(IPA_REFERENCE_H) bitmap.h tree-pass.h $(FLAGS_H) $(TIMEVAR_H) \n df.o : df.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    insn-config.h $(RECOG_H) function.h $(REGS_H) alloc-pool.h hard-reg-set.h \\\n    $(BASIC_BLOCK_H) $(DF_H) bitmap.h sbitmap.h $(TM_P_H)"}, {"sha": "c6ab1091be770f7efac00fbbbae2963538848bf6", "filename": "gcc/common.opt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9a79a866b120d678d6463bcdb718fe87c8717f/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9a79a866b120d678d6463bcdb718fe87c8717f/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=6a9a79a866b120d678d6463bcdb718fe87c8717f", "patch": "@@ -927,10 +927,6 @@ ftree-pre\n Common Report Var(flag_tree_pre)\n Enable SSA-PRE optimization on trees\n \n-ftree-promote-statics\n-Common Report Var(flag_tree_promote_statics) Init(0)\n-Enable promotion of static variables\n-\n ftree-salias\n Common Report Var(flag_tree_salias)\n Perform structural alias analysis"}, {"sha": "afa25d5bc4895850e53fff7917f801cc8b1014ea", "filename": "gcc/opts.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9a79a866b120d678d6463bcdb718fe87c8717f/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9a79a866b120d678d6463bcdb718fe87c8717f/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=6a9a79a866b120d678d6463bcdb718fe87c8717f", "patch": "@@ -586,7 +586,6 @@ decode_options (unsigned int argc, const char **argv)\n \n   if (optimize >= 3)\n     {\n-      flag_tree_promote_statics = 1;\n       flag_inline_functions = 1;\n       flag_unswitch_loops = 1;\n       flag_gcse_after_reload = 1;"}, {"sha": "ee060f5960e3e0671f9ac5522399cb400391db37", "filename": "gcc/passes.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9a79a866b120d678d6463bcdb718fe87c8717f/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9a79a866b120d678d6463bcdb718fe87c8717f/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=6a9a79a866b120d678d6463bcdb718fe87c8717f", "patch": "@@ -472,7 +472,6 @@ init_optimization_passes (void)\n \n   p = &pass_all_optimizations.sub;\n   NEXT_PASS (pass_referenced_vars);\n-  NEXT_PASS (pass_promote_statics); \n   NEXT_PASS (pass_create_structure_vars);\n   NEXT_PASS (pass_build_ssa);\n   NEXT_PASS (pass_may_alias);"}, {"sha": "745f2b135c4f055d6dfa9aa7f518eedba974c39c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9a79a866b120d678d6463bcdb718fe87c8717f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9a79a866b120d678d6463bcdb718fe87c8717f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6a9a79a866b120d678d6463bcdb718fe87c8717f", "patch": "@@ -1,3 +1,8 @@\n+2005-07-19  Danny Berlin <dberlin@dberlin.org>\n+\t    Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t* gcc.dg/tree-ssa/sra-2.c: Changed back to -O1 and added xfail.\n+\n 2005-07-19  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.dg/format/miss-1.c, gcc.dg/format/miss-2.c: Don't"}, {"sha": "ec30bc904d72b11182cad9762d720f39225e1fa5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/sra-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9a79a866b120d678d6463bcdb718fe87c8717f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9a79a866b120d678d6463bcdb718fe87c8717f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-2.c?ref=6a9a79a866b120d678d6463bcdb718fe87c8717f", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */ \n-/* { dg-options \"-O3 -fdump-tree-optimized --param sra-max-structure-size=32\" } */\n+/* { dg-options \"-O1 -fdump-tree-optimized --param sra-max-structure-size=32\" } */\n \n /* Test for SRA. */\n \n@@ -22,5 +22,5 @@ copystruct11 (teststruct *param)\n \n \n /* There should be no reference to link_error. */\n-/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"optimized\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "05d8b386246f554abc5b8ba8f87f59abff85220a", "filename": "gcc/timevar.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9a79a866b120d678d6463bcdb718fe87c8717f/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9a79a866b120d678d6463bcdb718fe87c8717f/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=6a9a79a866b120d678d6463bcdb718fe87c8717f", "patch": "@@ -69,7 +69,6 @@ DEFTIMEVAR (TV_TREE_GIMPLIFY\t     , \"tree gimplify\")\n DEFTIMEVAR (TV_TREE_EH\t\t     , \"tree eh\")\n DEFTIMEVAR (TV_TREE_CFG\t\t     , \"tree CFG construction\")\n DEFTIMEVAR (TV_TREE_CLEANUP_CFG\t     , \"tree CFG cleanup\")\n-DEFTIMEVAR (TV_TREE_PROMOTE_STATICS  , \"tree promote statics\")\n DEFTIMEVAR (TV_TREE_VRP              , \"tree VRP\")\n DEFTIMEVAR (TV_TREE_COPY_PROP        , \"tree copy propagation\")\n DEFTIMEVAR (TV_TREE_STORE_COPY_PROP  , \"tree store copy prop\")"}, {"sha": "a51054df246f19ac7e00f38606e119c221d32923", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a9a79a866b120d678d6463bcdb718fe87c8717f/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a9a79a866b120d678d6463bcdb718fe87c8717f/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=6a9a79a866b120d678d6463bcdb718fe87c8717f", "patch": "@@ -278,7 +278,6 @@ extern struct tree_opt_pass pass_store_copy_prop;\n extern struct tree_opt_pass pass_vrp;\n extern struct tree_opt_pass pass_create_structure_vars;\n extern struct tree_opt_pass pass_uncprop;\n-extern struct tree_opt_pass pass_promote_statics;\n extern struct tree_opt_pass pass_return_slot;\n extern struct tree_opt_pass pass_reassoc;\n extern struct tree_opt_pass pass_rebuild_cgraph_edges;"}, {"sha": "a4ac8b7930544eb04ae73ecb12051be2fbc33fdc", "filename": "gcc/tree-promote-statics.c", "status": "removed", "additions": 0, "deletions": 597, "changes": 597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a0b917ad42084fcadd237119beca05b5b18edf/gcc%2Ftree-promote-statics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a0b917ad42084fcadd237119beca05b5b18edf/gcc%2Ftree-promote-statics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-promote-statics.c?ref=89a0b917ad42084fcadd237119beca05b5b18edf", "patch": "@@ -1,597 +0,0 @@\n-/* Promotion of static variables to ssa registers\n-   Copyright (C) 2004-2005 Free Software Foundation, Inc.\n-   Contributed by Kenneth Zadeck <zadeck@naturalbridge.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"basic-block.h\"\n-#include \"tree-flow.h\"\n-#include \"ipa-utils.h\"\n-#include \"ipa-reference.h\"\n-#include \"bitmap.h\"\n-#include \"tree-pass.h\"\n-#include \"flags.h\"\n-#include \"timevar.h\"\n-#include \"langhooks.h\"\n-\n-/*\n-The main idea is to promote some static variables from memory to SSA\n-registers.  This transformation is only applied to those static\n-variables for which the effects of subroutine calls can be understood.\n-Such infomation is provided by functions in cgraphunit.c.\n-\n-The following table shows the actions that are taken to promote\n-variables.  The analysis in cgraphunit constructs information about\n-both local usage and the effect of any particular call.  Variables are\n-broken into 4 categories: only-read, only-write, read-write, and no\n-information.  (No information variables are never promoted.)  \n-\n-All information is of the \"may\" variety: if a function is marked read,\n-it means the call may read the variable, but it also may not read the\n-variable.\n-\n-There are two possible ways to perform the promotion: assume that the\n-static is live everywhere or compute the minimal live range for the\n-static variable.\n-\n-The minimal live range path has a lot of problems:\n-\n-1) live variables and upwards exposed uses must be first comuputed.\n-2) new machiney must be invented to prevent code motion algorithms\n-from floating a use of the surrogate register across a register\n-function call that clobbers the variable, but was not in any minimal\n-live range at the time of this analysis.\n-\n-While the first problem is simply a lot of code, the second problem\n-requires a new mechanism for pinning code and teaching all passes that\n-can move code to obey this new fenceposts.  \n-\n-The maximum live range path has the problem that this technique can\n-create many false live ranges where the register is loaded after on\n-call only to be stored back right before the next call.  This will eat\n-a certain amount of space and requires special smarts to get rid of them.\n-\n-There are really 7 situations to cover in the following table.  \n-\n-action             read                    write                   read-write\n-\n-             -+---------------------------------------------------------------\n-\n-entry         |  load                    load                    load\n-              |\n-load          |  getfromreg              xxxxx                   getfromreg\n-              |\n-store         |  xxxx                    puttoreg                puttoreg\n-              |\n-call-read     |  noaction                store before            store before\n-              |\n-call-write    |  load after              store before            store before\n-              |                          load after              load after  \n-call-readwrite|  load after              store before            store before\n-              |                          load after              load after  \n-              |\n-return        |  no action               store                   store         \n-\n-\n-l-r\tl-w\tc-r\tc-w\tstore-b\tload-a\n-\n-0\t0\t0\t0   |\t0\t0\n-0\t0\t0\t1   |\t0\t0\n-0\t0       1      \t0   |\t0\t0\n-0\t0\t1\t1   |\t0\t0\n-0\t1\t0\t0   |\t0\t0\n-0\t1\t0\t1   |\t1\t1\t \n-0\t1       1      \t0   |\t1\t0\n-0\t1\t1\t1   |\t1\t1\n-1\t0\t0\t0   |\t0\t0\n-1\t0\t0\t1   |   0       1\n-1\t0       1      \t0   |\t0\t0\t\n-1\t0\t1\t1   |\t0\t1\n-1\t1\t0\t0   |\t0\t0\n-1\t1\t0\t1   |\t1\t1\n-1\t1       1      \t0   |\t1\t0\n-1\t1\t1\t1   |\t1\t1\n-\n-store_before = local_written & (callee_read | callee_written)\n-load_after = (local_read | local_written) & callee_written\n-*/\n-\n-static bitmap_obstack promote_obstack;\n-\n-/* All of the static variables under consideration by this pass that\n-   do reads or writes withing this function.   */\n-static bitmap local_read;\n-static bitmap local_written;\n-static bitmap local_all;\n-\n-/* Return true if the asm STMT clobbers memory.  */\n-\n-static bool\n-asm_clobbers_mem (tree stmt)\n-{\n-  tree link;\n-  for (link = ASM_CLOBBERS (stmt); link; link = TREE_CHAIN (link))\n-    if (simple_cst_equal(TREE_VALUE (link), memory_identifier_string) == 1) \n-      return true;\n-\n-  return false;\n-}\n-\n-/* Return a INPUT_BITMAP for the asm inputs and OUTPUT_BITMAP for the\n-   asm outputs of variables written by the asm STMT.  */\n-\n-static void\n-get_asm_read_and_write (bitmap input_bitmap, bitmap output_bitmap, tree stmt) \n-{\n-  int noutputs = list_length (ASM_OUTPUTS (stmt));\n-  const char **oconstraints\n-    = (const char **) alloca ((noutputs) * sizeof (const char *));\n-  int i;\n-  tree link;\n-  const char *constraint;\n-  bool allows_mem, allows_reg, is_inout;\n-\n-  for (i=0, link = ASM_OUTPUTS (stmt); link; ++i, link = TREE_CHAIN (link))\n-    {\n-      oconstraints[i] = constraint\n-\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n-      parse_output_constraint (&constraint, i, 0, 0,\n-\t  &allows_mem, &allows_reg, &is_inout);\n-\n-      /* The variable is only added to the bitmap if there is an aux\n-\t field, ie.this is a variable we care about.  */\n-      if (!allows_reg && allows_mem)\n-\t{\n-\t  tree var = TREE_VALUE (link);\n-\t  var = get_base_address (var);\n-\t  if (TREE_CODE (var) == VAR_DECL)\n-\t    {\n-\t      var_ann_t va = var_ann (var);\n-\t      if (va && va->common.aux) \n-\t\tbitmap_set_bit(output_bitmap, DECL_UID (var));\n-\t    }\n-\t}\n-    }\n-\n-  for (link = ASM_INPUTS (stmt); link; link = TREE_CHAIN (link))\n-    {\n-      constraint\n-\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n-      parse_input_constraint (&constraint, 0, 0, noutputs, 0,\n-\t\t\t      oconstraints, &allows_mem, &allows_reg);\n-      \n-      /* The variable is only added to the bitmap if there is an aux\n-\t field, ie.this is a variable we care about.  */\n-      if (!allows_reg && allows_mem)\n-\t{\n-\t  tree var = TREE_VALUE (link);\n-\t  var = get_base_address (var);\n-\t  if (TREE_CODE (var) == VAR_DECL)\n-\t    {\n-\t      var_ann_t va = var_ann (var);\n-\t      if (va && va->common.aux) \n-\t\tbitmap_set_bit(input_bitmap, DECL_UID (var));\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Generate a series of loads from the static variables pointed to by\n-   B1 && B2 or just B1 (if B2 is NULL) and insert them after\n-   BSI).  */\n-\n-static void\n-gen_loads (bitmap b1, bitmap b2, block_stmt_iterator *bsi) \n-{\n-  bitmap result;\n-  bitmap_iterator bi;\n-  unsigned int index;\n-  tree list = NULL;\n-\n-  if (b2) \n-    {\n-      result = BITMAP_ALLOC (&promote_obstack);\n-      bitmap_and (result, b1, b2);\n-    }\n-  else \n-    result = b1;\n-\n-  EXECUTE_IF_SET_IN_BITMAP(result, 0, index, bi) \n-      {\n-\ttree src = referenced_var (index);\n-\ttree dest = (tree) (var_ann (src)->common.aux);\n-\ttree stmt = build (MODIFY_EXPR, TREE_TYPE (src), dest, src);\n-\tappend_to_statement_list (stmt, &list);\n-      }\n-\n-  if (list)\n-    sra_insert_after (bsi, list);\n-\t\t\t   \n-  if (b2)\n-    BITMAP_FREE (result);\n-}\n-\n-/* Generate a series of stores to the static variables pointed to by\n-   B1 && B2 or just B1 (if B2 is NULL) and insert them before\n-   BSI).  */\n-\n-static void\n-gen_stores (bitmap b1, bitmap b2, block_stmt_iterator *bsi) \n-{\n-  bitmap result;\n-  bitmap_iterator bi;\n-  unsigned int index;\n-  tree list = NULL;\n-\n-  if (b2) \n-    {\n-      result = BITMAP_ALLOC (&promote_obstack);\n-      bitmap_and (result, b1, b2);\n-    }\n-  else \n-    result = b1;\n-\n-  EXECUTE_IF_SET_IN_BITMAP(result, 0, index, bi) \n-      {\n-\ttree dest = referenced_var (index);\n-\ttree src = (tree) (var_ann (dest)->common.aux);\n-\ttree stmt = build (MODIFY_EXPR, TREE_TYPE (src), dest, src);\n-\tappend_to_statement_list (stmt, &list);\n-      }\n-\n-  if (list)\n-    sra_insert_before (bsi, list);\n-\t\t\t   \n-  if (b2)\n-    BITMAP_FREE (result);\n-}\n-\n-/* Replace the static references if it exists in the TPTR.  */\n-\n-static void \n-try_replace_operand(tree * tptr)\n-{\n-  tree t = *tptr;\n-  if (TREE_CODE (t) == VAR_DECL)\n-    {\n-      var_ann_t va = var_ann (t);\n-      tree replacement = (tree) (va->common.aux);\n-      if (replacement)\n-\t*tptr = replacement;\n-    }\n-}\n-\n-/* Walk an expression TPTR replacing all of the static references.  */\n-\n-static void\n-try_replace (tree *tptr) \n-{\n-  tree t = *tptr;\n-  if ((TREE_CODE (t) == EXC_PTR_EXPR) || (TREE_CODE (t) == FILTER_EXPR))\n-    return;\n-\n-  /* The INTEGER_CST is because some people use cute things like &0->a\n-     for offsetof.  */\n-  while (t && !SSA_VAR_P (t) \n-\t && (!CONSTANT_CLASS_P (t)) \n-\t && TREE_CODE (t) != LABEL_DECL\n-\t && TREE_CODE (t) != CONST_DECL\n-\t && TREE_CODE (t) != FUNCTION_DECL\n-         && TREE_CODE (t) != EXC_PTR_EXPR)\n-    {\n-      if (TREE_CODE (t) == ARRAY_REF)\n-\ttry_replace_operand (&TREE_OPERAND (t, 1));\n-\n-      tptr = &TREE_OPERAND (t, 0);\n-      t = *tptr;\n-    }\n-  if (t)\n-    try_replace_operand (tptr);\n-}\n-\n-/* Repalce the static references that exist in a constructor.  */\n-\n-static void\n-try_replace_constructor (tree ctor)\n-{\n-  tree t;\n-  for (t = TREE_OPERAND (ctor, 0); t; t = TREE_CHAIN (t))\n-    {\n-      try_replace (&TREE_VALUE (t));\n-    }\n-}\n-\n-/* Replace all the static references in the operand list of\n-   CALL_EXPR.  */\n-\n-static void\n-try_replace_call_operands (tree call_expr) \n-{\n-  tree operandList = TREE_OPERAND (call_expr, 1);\n-  tree operand;\n-\n-  for (operand = operandList;\n-       operand != NULL_TREE;\n-       operand = TREE_CHAIN (operand))\n- \n-    if (TREE_CODE(TREE_VALUE (operand)) != FUNCTION_DECL)\n-      try_replace (&TREE_VALUE (operand));\n-}\n-\n-/* Generate loads and stores and replace all the static references in\n-   function FN using statement iterator SI. This form is used when\n-   there is not info available about the caller.  */\n-\n-static void \n-gen_dumb_call (tree fn, block_stmt_iterator si) \n-{\n-  gen_stores (local_written, NULL, &si);\n-  try_replace (&TREE_OPERAND (fn, 0));\n-  try_replace_call_operands (fn);\n-  gen_loads (local_all, NULL, &si);\n-}\n-\n-\n-/* Generate loads and stores and replace all the static references in\n-   function FN using statement iterator SI.  */\n-\n-static void \n-try_replace_call (tree fn, block_stmt_iterator si)\n-{\n-  /* Store intersection of call_read and local_written\n-     registers back to memory before calling.  */\n-  /* int call_flags = call_expr_flags (fn); */\n-  tree callee = get_callee_fndecl (fn);\n-  if (callee) \n-    {\n-      bitmap callee_all = BITMAP_ALLOC (&promote_obstack);\n-      bitmap callee_written = ipa_reference_get_written_global (callee);\n-      if (callee_written) \n-\t{\n-\t  bitmap_ior (callee_all, \n-\t\t      ipa_reference_get_read_global (callee), \n-\t\t      callee_written);\n-\t  \n-\t  gen_stores (local_written, callee_all, &si);\n-\t  \n-\t  if (TREE_CODE (callee) != FUNCTION_DECL)\n-\t    try_replace (&TREE_OPERAND (fn, 0));\n-\t  try_replace_call_operands (fn);\n-\t  \n-\t  /* This is a hack required because the call_flags are set on a\n-\t     function by function basis during compilation.  Thus these\n-\t     flags are only set if the callee has already been compiled.  */\n-\t  /* if (!(call_flags & (ECF_PURE | ECF_CONST | ECF_NORETURN))) */\n-\t  gen_loads (local_all, callee_written, &si);\n-\t  BITMAP_FREE (callee_all);\n-\t}\n-      else \n-\tgen_dumb_call (fn, si);\n-    }\n-  else\n-    gen_dumb_call (fn, si);\n-}\n-\n-\n-/* Walk the entire function looking uses or stores to global variables\n-   and changing them to use ssa shadow registers.  */ \n-\n-static void\n-walk_function (void)\n-{\n-  basic_block bb;\n-  block_stmt_iterator si, ni;\n-\n-  FOR_EACH_BB (bb)\n-    for (si = bsi_start (bb); !bsi_end_p (si); si = ni)\n-      {\n-\ttree stmt = bsi_stmt (si);\n-\n-\tni = si;\n-\tbsi_next (&ni);\n-\n-\tswitch (TREE_CODE (stmt))\n-\t  {\n-\t  case RETURN_EXPR:\n-\t    /* Store all of the local_written registers back to memory\n-\t       before returning. */\n-\t    gen_stores (local_written, NULL, &si);\n-\t    break;\n-\n-\t  case MODIFY_EXPR:\n-\t    /* Change load of static to use of reg.  Change store of\n-\t       static to store of reg.  */\n-\t    {\n-\t      tree rhs = TREE_OPERAND (stmt, 1);\n-\t      tree *rhsp = &TREE_OPERAND (stmt, 1);\n-\t      tree *lhsp = &TREE_OPERAND (stmt, 0);\n-\n-\t      /* If we have a call on the rhs, try to replace the arguments.\n-\t\t Otherwise, try to replace the operand on the LHS and the operand on\n-\t\t the RHS.  */\n-\t      if (TREE_CODE (rhs) == CALL_EXPR)\n-\t\ttry_replace_call (rhs, si);\n-\t      else if (TREE_CODE (rhs) == CONSTRUCTOR)\n-\t\ttry_replace_constructor (rhs);\n-\t      else\n-\t\ttry_replace (rhsp);\n-\t      try_replace (lhsp);\n-\t    }\n-\t    break;\n-\t  case CALL_EXPR:\n-\t    try_replace_call (stmt, si);\n-   \n-\t    break;\n-\t  case ASM_EXPR:\n-\t    /* If the asm clobbers memory, just store everything and\n-\t       load it back.  */\n-\t    if (asm_clobbers_mem (stmt)) \n-\t      { \n-\t\tgen_stores (local_written, NULL, &si);\n-\t\tgen_loads (local_all, NULL, &si);\n-\t      }\n-\t    else \n-\t      {\n-\t\tbitmap store_bitmap = BITMAP_ALLOC (&promote_obstack);\n-\t\tbitmap load_bitmap = BITMAP_ALLOC (&promote_obstack);\n-\t\tbitmap all_bitmap = BITMAP_ALLOC (&promote_obstack);\n-\t\t/* The asm read generates a stores before, and the asm\n-\t\t   write generates loads after.  */\n-\t\tget_asm_read_and_write (store_bitmap, load_bitmap, stmt);\n-\t\tbitmap_ior (all_bitmap, store_bitmap, load_bitmap);\n-\t\t\n-\t\tgen_stores (local_written, all_bitmap , &si);\n-\t\tgen_loads (local_all, load_bitmap, &si);\n-\t\t\n-\t\tBITMAP_FREE (store_bitmap);\n-\t\tBITMAP_FREE (load_bitmap);\n-\t\tBITMAP_FREE (all_bitmap);\n-\t      } \n-\t    break;\n-\t    \n-\t  default:\n-\t    break;\n-\t  }\n-      }\n-}\n-\n-/* Main entry point for the promotion of statics to ssa regsisters. */\n-\n-static void\n-execute_promote_statics (void)\n-{\n-  unsigned int index;\n-  bitmap_iterator bi;\n-  bitmap tb = ipa_reference_get_read_local (current_function_decl);\n-\n-\n-  /* There are some options that cause this pass to run even if file\n-     at a time is not set.  */\n-  if (!tb)\n-    return;\n-\n-  bitmap_obstack_initialize (&promote_obstack);\n-  sra_init_cache ();\n-\n-  local_read = BITMAP_ALLOC (&promote_obstack);\n-  bitmap_copy (local_read, tb);\n-  tb = ipa_reference_get_written_local (current_function_decl);\n-  local_written = BITMAP_ALLOC (&promote_obstack);\n-  bitmap_copy (local_written, tb);\n-\n-  local_all = BITMAP_ALLOC (&promote_obstack);\n-  tb = BITMAP_ALLOC (&promote_obstack);\n-  bitmap_ior (local_all, local_read, local_written);\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"promoting in %s\\n\", \n-\t     lang_hooks.decl_printable_name (current_function_decl, 2)); \n-\n-  EXECUTE_IF_SET_IN_BITMAP (local_all, 0, index, bi) \n-    {\n-      tree svar = referenced_var_lookup_if_exists (index);\n-      if (svar)\n-\t{\n-\t  tree type = TREE_TYPE (svar);\n-\t  /* We only promote variables that are either scalars or if\n-\t     they are aggregrates, they must be a type that sra is\n-\t     willing to scalarize.  Otherwise there is no reason to\n-\t     promote it a register.  \n-\t     \n-\t     We also do not promote anything that is marked READONLY\n-\t     since there is little gain.  The optimizations should\n-\t     generally be able to look thru the operations and find the\n-\t     constants.  */\n-\t  if ((!TREE_READONLY(svar)) \n-\t      && (TREE_CODE (type) != ARRAY_TYPE)\n-\t      && ((!AGGREGATE_TYPE_P (type))\n-\t\t  || (sra_type_can_be_decomposed_p (type))))\n-\t    {\n-\t      tree tmp = create_tmp_var (type, get_name (svar));\n-\t      add_referenced_tmp_var (tmp);\n-\t      var_ann (svar)->common.aux = tmp;\n-\t      \n-\t      /* Insert loads from all read statics in the entry\n-\t\t block.  */\n-\t      insert_edge_copies (build (MODIFY_EXPR, TREE_TYPE (svar), \n-\t\t\t\t\t tmp, svar), \n-\t\t\t\t  ENTRY_BLOCK_PTR);\n-\t      if (dump_file) \n-\t\tfprintf (dump_file, \"  var=%s, read=%d,write=%d\\n\", \n-\t\t\t get_name (svar), \n-\t\t\t bitmap_bit_p (local_read, index),  \n-\t\t\t bitmap_bit_p (local_written, index)); \n-\t    }\n-\t  else \n-\t    /* There is nothing to be done with this variable.  */ \n-\t    bitmap_set_bit (tb, index);\n-\t}\n-      else\n-\t/* There is nothing to be done with this variable because the\n-\t   reference was optimized out before we got here.  */ \n-\tbitmap_set_bit (tb, index);\n-    }\n-\n-  /* Clear the to be ignored variables from the local maps.  */\n-  bitmap_and_compl_into (local_read, tb);\n-  bitmap_and_compl_into (local_written, tb);\n-  bitmap_and_compl_into (local_all, tb);\n-\n-  walk_function ();\n-  bsi_commit_edge_inserts ();\n-\n-  EXECUTE_IF_SET_IN_BITMAP (local_all, 0, index, bi) \n-    {\n-      tree svar = referenced_var (index);\n-      var_ann (svar)->common.aux = NULL;\n-    }\n-\n-  bitmap_obstack_release (&promote_obstack);\n-}\n-\n-static bool\n-gate_promote_statics (void)\n-{\n-  return flag_unit_at_a_time != 0 \n-    && flag_ipa_reference \n-    && flag_tree_promote_statics;\n-}\n-\n-struct tree_opt_pass pass_promote_statics = \n-{\n-  \"promote-statics\",\t\t\t/* name */\n-  gate_promote_statics,\t\t\t/* gate */\n-  execute_promote_statics,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_PROMOTE_STATICS,\t\t/* tv_id */\n-  PROP_cfg,                    \t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func,\t\t\t/* todo_flags_finish */\n-  0                                     /* letter */\n-};\n-\n-"}]}