{"sha": "70ce4a25c465584cee191674cefe7b00aa47def4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBjZTRhMjVjNDY1NTg0Y2VlMTkxNjc0Y2VmZTdiMDBhYTQ3ZGVmNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2012-08-01T20:41:16Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-08-01T20:41:16Z"}, "message": "re PR middle-end/34548 (GCC generates too many alignment adds for alloca)\n\nPR 34548\n\n\t* function.h (struct rtl_data): Add max_dynamic_stack_alignment.\n\t* cfgexpand.c (gimple_expand_cfg): Initialise it.\n\t* explow.c (allocate_dynamic_stack_space): Set it.  Simplify\n\talignment requirements given the known alignment of dynamic_offset.\n\t* function.c (instantiate_virtual_regs): Align dtnamic_offset.\n\nFrom-SVN: r190051", "tree": {"sha": "040c558b53700de0429c84a129ccd952f1ec8dfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/040c558b53700de0429c84a129ccd952f1ec8dfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70ce4a25c465584cee191674cefe7b00aa47def4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70ce4a25c465584cee191674cefe7b00aa47def4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70ce4a25c465584cee191674cefe7b00aa47def4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70ce4a25c465584cee191674cefe7b00aa47def4/comments", "author": null, "committer": null, "parents": [{"sha": "91f8035e9b79eef334ef701af7bb05ff9b5780be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91f8035e9b79eef334ef701af7bb05ff9b5780be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91f8035e9b79eef334ef701af7bb05ff9b5780be"}], "stats": {"total": 76, "additions": 39, "deletions": 37}, "files": [{"sha": "ea98416a494c7061959019ff8f22f6322c9f5df5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70ce4a25c465584cee191674cefe7b00aa47def4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70ce4a25c465584cee191674cefe7b00aa47def4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70ce4a25c465584cee191674cefe7b00aa47def4", "patch": "@@ -1,3 +1,12 @@\n+2012-08-01  Richard Henderson  <rth@redhat.com>\n+\n+\tPR middle-end/34548\n+\t* function.h (struct rtl_data): Add max_dynamic_stack_alignment.\n+\t* cfgexpand.c (gimple_expand_cfg): Initialise it.\n+\t* explow.c (allocate_dynamic_stack_space): Set it.  Simplify\n+\talignment requirements given the known alignment of dynamic_offset.\n+\t* function.c (instantiate_virtual_regs): Align dtnamic_offset.\n+\n 2012-08-01  Richard Henderson  <rth@redhat.com>\n \n \t* expmed.h (NUM_MODE_PARTIAL_INT): New."}, {"sha": "1f165343b305568cc4c2fb16e6760144ccab160a", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70ce4a25c465584cee191674cefe7b00aa47def4/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70ce4a25c465584cee191674cefe7b00aa47def4/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=70ce4a25c465584cee191674cefe7b00aa47def4", "patch": "@@ -4363,6 +4363,7 @@ gimple_expand_cfg (void)\n   crtl->max_used_stack_slot_alignment = STACK_BOUNDARY;\n   crtl->stack_alignment_estimated = 0;\n   crtl->preferred_stack_boundary = STACK_BOUNDARY;\n+  crtl->max_dynamic_stack_alignment = 0;\n   cfun->cfg->max_jumptable_ents = 0;\n \n   /* Resovle the function section.  Some targets, like ARM EABI rely on knowledge"}, {"sha": "c7581b0661662a141f8be46e682c182be301d8c4", "filename": "gcc/explow.c", "status": "modified", "additions": 18, "deletions": 37, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70ce4a25c465584cee191674cefe7b00aa47def4/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70ce4a25c465584cee191674cefe7b00aa47def4/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=70ce4a25c465584cee191674cefe7b00aa47def4", "patch": "@@ -1173,7 +1173,6 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n {\n   HOST_WIDE_INT stack_usage_size = -1;\n   rtx final_label, final_target, target;\n-  unsigned extra_align = 0;\n   bool must_align;\n \n   /* If we're asking for zero bytes, it doesn't matter what we point\n@@ -1237,58 +1236,40 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n   else if (size_align < BITS_PER_UNIT)\n     size_align = BITS_PER_UNIT;\n \n-  /* We can't attempt to minimize alignment necessary, because we don't\n-     know the final value of preferred_stack_boundary yet while executing\n-     this code.  */\n-  if (crtl->preferred_stack_boundary < PREFERRED_STACK_BOUNDARY)\n-    crtl->preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;\n-\n   /* We will need to ensure that the address we return is aligned to\n-     REQUIRED_ALIGN.  If STACK_DYNAMIC_OFFSET is defined, we don't\n-     always know its final value at this point in the compilation (it\n-     might depend on the size of the outgoing parameter lists, for\n-     example), so we must align the value to be returned in that case.\n-     (Note that STACK_DYNAMIC_OFFSET will have a default nonzero value if\n-     STACK_POINTER_OFFSET or ACCUMULATE_OUTGOING_ARGS are defined).\n-     We must also do an alignment operation on the returned value if\n-     the stack pointer alignment is less strict than REQUIRED_ALIGN.\n-\n-     If we have to align, we must leave space in SIZE for the hole\n-     that might result from the alignment operation.  */\n-\n-  must_align = (crtl->preferred_stack_boundary < required_align);\n-  if (must_align)\n+     REQUIRED_ALIGN.  If that alignment is no larger than\n+     PREFERRED_STACK_BOUNDARY, we can handle everything without an\n+     explicit alignment.  */\n+  if (required_align <= PREFERRED_STACK_BOUNDARY)\n     {\n-      if (required_align > PREFERRED_STACK_BOUNDARY)\n-\textra_align = PREFERRED_STACK_BOUNDARY;\n-      else if (required_align > STACK_BOUNDARY)\n-\textra_align = STACK_BOUNDARY;\n-      else\n-\textra_align = BITS_PER_UNIT;\n+      if (crtl->preferred_stack_boundary < required_align)\n+\tcrtl->preferred_stack_boundary = required_align;\n+      if (crtl->max_dynamic_stack_alignment < required_align)\n+\tcrtl->max_dynamic_stack_alignment = required_align;\n+      must_align = false;\n     }\n+  else\n+    {\n+      unsigned extra, extra_align;\n \n-  /* ??? STACK_POINTER_OFFSET is always defined now.  */\n-#if defined (STACK_DYNAMIC_OFFSET) || defined (STACK_POINTER_OFFSET)\n-  must_align = true;\n-  extra_align = BITS_PER_UNIT;\n-#endif\n+      crtl->preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;\n+      crtl->max_dynamic_stack_alignment = PREFERRED_STACK_BOUNDARY;\n \n-  if (must_align)\n-    {\n-      unsigned extra = (required_align - extra_align) / BITS_PER_UNIT;\n+      extra_align = PREFERRED_STACK_BOUNDARY;\n+      extra = (required_align - extra_align) / BITS_PER_UNIT;\n \n       size = plus_constant (Pmode, size, extra);\n       size = force_operand (size, NULL_RTX);\n \n       if (flag_stack_usage_info)\n \tstack_usage_size += extra;\n-\n       if (extra && size_align > extra_align)\n \tsize_align = extra_align;\n+      must_align = true;\n     }\n \n   /* Round the size to a multiple of the required stack alignment.\n-     Since the stack if presumed to be rounded before this allocation,\n+     Since the stack is presumed to be rounded before this allocation,\n      this will maintain the required alignment.\n \n      If the stack grows downward, we could save an insn by subtracting"}, {"sha": "827f687f4218c72e76e81794ba0ad536debce12f", "filename": "gcc/function.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70ce4a25c465584cee191674cefe7b00aa47def4/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70ce4a25c465584cee191674cefe7b00aa47def4/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=70ce4a25c465584cee191674cefe7b00aa47def4", "patch": "@@ -1892,7 +1892,14 @@ instantiate_virtual_regs (void)\n   /* Compute the offsets to use for this function.  */\n   in_arg_offset = FIRST_PARM_OFFSET (current_function_decl);\n   var_offset = STARTING_FRAME_OFFSET;\n+\n   dynamic_offset = STACK_DYNAMIC_OFFSET (current_function_decl);\n+  if (crtl->max_dynamic_stack_alignment)\n+    {\n+      int align = crtl->max_dynamic_stack_alignment / BITS_PER_UNIT;\n+      dynamic_offset = (dynamic_offset + align - 1) & -align;\n+    }\n+\n   out_arg_offset = STACK_POINTER_OFFSET;\n #ifdef FRAME_POINTER_CFA_OFFSET\n   cfa_offset = FRAME_POINTER_CFA_OFFSET (current_function_decl);"}, {"sha": "ed6fcb198d53d79b16f37bcd59433658ccc317f7", "filename": "gcc/function.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70ce4a25c465584cee191674cefe7b00aa47def4/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70ce4a25c465584cee191674cefe7b00aa47def4/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=70ce4a25c465584cee191674cefe7b00aa47def4", "patch": "@@ -347,6 +347,10 @@ struct GTY(()) rtl_data {\n         local stack.  */\n   unsigned int stack_alignment_estimated;\n \n+  /* The (capped) maximum alignment of dynamic stack space, and thus the\n+     required alignment of STACK_DYNAMIC_OFFSET.  */\n+  unsigned int max_dynamic_stack_alignment;\n+\n   /* For reorg.  */\n \n   /* If some insns can be deferred to the delay slots of the epilogue, the"}]}