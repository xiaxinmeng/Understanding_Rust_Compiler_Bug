{"sha": "c7da0e818fee3d260a1d86d9371e508666f1e137", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdkYTBlODE4ZmVlM2QyNjBhMWQ4NmQ5MzcxZTUwODY2NmYxZTEzNw==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-05-02T16:19:51Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-05-02T16:19:51Z"}, "message": "tree-ssa-loop-ivopts.c (get_computation_at): Reorder parameters.\n\n\t* tree-ssa-loop-ivopts.c (get_computation_at): Reorder parameters.\n\t(get_computation): Delete.\n\t(get_computation_cost): Implement like get_computation_cost_at.\n\tUse get_computation_at.\n\t(get_computation_cost_at): Delete.\n\t(rewrite_use_nonlinear_expr): Use get_computation_at.\n\t(rewrite_use_compare, remove_unused_ivs): Ditto.\n\nFrom-SVN: r247517", "tree": {"sha": "b5b70ded9849f530b4f02e063e665aae33de58db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5b70ded9849f530b4f02e063e665aae33de58db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7da0e818fee3d260a1d86d9371e508666f1e137", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7da0e818fee3d260a1d86d9371e508666f1e137", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7da0e818fee3d260a1d86d9371e508666f1e137", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7da0e818fee3d260a1d86d9371e508666f1e137/comments", "author": null, "committer": null, "parents": [{"sha": "d6176f728590716d95bab9ba3622446919dbf079", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6176f728590716d95bab9ba3622446919dbf079", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6176f728590716d95bab9ba3622446919dbf079"}], "stats": {"total": 66, "additions": 24, "deletions": 42}, "files": [{"sha": "b17b918f170c7dfee75a3fefbbc9b2ac9e115646", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7da0e818fee3d260a1d86d9371e508666f1e137/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7da0e818fee3d260a1d86d9371e508666f1e137/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7da0e818fee3d260a1d86d9371e508666f1e137", "patch": "@@ -1,3 +1,13 @@\n+2017-05-02  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-ssa-loop-ivopts.c (get_computation_at): Reorder parameters.\n+\t(get_computation): Delete.\n+\t(get_computation_cost): Implement like get_computation_cost_at.\n+\tUse get_computation_at.\n+\t(get_computation_cost_at): Delete.\n+\t(rewrite_use_nonlinear_expr): Use get_computation_at.\n+\t(rewrite_use_compare, remove_unused_ivs): Ditto.\n+\n 2017-05-02  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-ssa-loop-ivopts.c (rewrite_use_address): Simple refactor."}, {"sha": "6eaeaf14807107f8dcd912851ab2491f3dc05922", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 14, "deletions": 42, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7da0e818fee3d260a1d86d9371e508666f1e137/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7da0e818fee3d260a1d86d9371e508666f1e137/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=c7da0e818fee3d260a1d86d9371e508666f1e137", "patch": "@@ -3846,8 +3846,8 @@ get_use_type (struct iv_use *use)\n    CAND at statement AT in LOOP.  The computation is unshared.  */\n \n static tree\n-get_computation_at (struct loop *loop,\n-\t\t    struct iv_use *use, struct iv_cand *cand, gimple *at)\n+get_computation_at (struct loop *loop, gimple *at,\n+\t\t    struct iv_use *use, struct iv_cand *cand)\n {\n   aff_tree aff;\n   tree type = get_use_type (use);\n@@ -3858,15 +3858,6 @@ get_computation_at (struct loop *loop,\n   return fold_convert (type, aff_combination_to_tree (&aff));\n }\n \n-/* Determines the expression by that USE is expressed from induction variable\n-   CAND in LOOP.  The computation is unshared.  */\n-\n-static tree\n-get_computation (struct loop *loop, struct iv_use *use, struct iv_cand *cand)\n-{\n-  return get_computation_at (loop, use, cand, use->stmt);\n-}\n-\n /* Adjust the cost COST for being in loop setup rather than loop body.\n    If we're optimizing for space, the loop setup overhead is constant;\n    if we're optimizing for speed, amortize it over the per-iteration cost.  */\n@@ -4834,18 +4825,17 @@ get_scaled_computation_cost_at (ivopts_data *data, gimple *at, iv_cand *cand,\n /* Determines the cost of the computation by that USE is expressed\n    from induction variable CAND.  If ADDRESS_P is true, we just need\n    to create an address from it, otherwise we want to get it into\n-   register.  A set of invariants we depend on is stored in\n-   INV_VARS.  AT is the statement at that the value is computed.\n+   register.  A set of invariants we depend on is stored in INV_VARS.\n    If CAN_AUTOINC is nonnull, use it to record whether autoinc\n-   addressing is likely.  */\n+   addressing is likely.  If INV_EXPR is nonnull, record invariant\n+   expr entry in it.  */\n \n static comp_cost\n-get_computation_cost_at (struct ivopts_data *data,\n-\t\t\t struct iv_use *use, struct iv_cand *cand,\n-\t\t\t bool address_p, bitmap *inv_vars, gimple *at,\n-\t\t\t bool *can_autoinc,\n-\t\t\t iv_inv_expr_ent **inv_expr)\n+get_computation_cost (struct ivopts_data *data, struct iv_use *use,\n+\t\t      struct iv_cand *cand, bool address_p, bitmap *inv_vars,\n+\t\t      bool *can_autoinc, iv_inv_expr_ent **inv_expr)\n {\n+  gimple *at = use->stmt;\n   tree ubase = use->iv->base, ustep = use->iv->step;\n   tree cbase, cstep;\n   tree utype = TREE_TYPE (ubase), ctype;\n@@ -5054,7 +5044,7 @@ get_computation_cost_at (struct ivopts_data *data,\n     *can_autoinc = false;\n \n   /* Just get the expression, expand it and measure the cost.  */\n-  tree comp = get_computation_at (data->current_loop, use, cand, at);\n+  tree comp = get_computation_at (data->current_loop, at, use, cand);\n \n   if (!comp)\n     return infinite_cost;\n@@ -5067,24 +5057,6 @@ get_computation_cost_at (struct ivopts_data *data,\n   return get_scaled_computation_cost_at (data, at, cand, cost);\n }\n \n-/* Determines the cost of the computation by that USE is expressed\n-   from induction variable CAND.  If ADDRESS_P is true, we just need\n-   to create an address from it, otherwise we want to get it into\n-   register.  A set of invariants we depend on is stored in\n-   INV_VARS.  If CAN_AUTOINC is nonnull, use it to record whether\n-   autoinc addressing is likely.  */\n-\n-static comp_cost\n-get_computation_cost (struct ivopts_data *data,\n-\t\t      struct iv_use *use, struct iv_cand *cand,\n-\t\t      bool address_p, bitmap *inv_vars,\n-\t\t      bool *can_autoinc, iv_inv_expr_ent **inv_expr)\n-{\n-  return get_computation_cost_at (data,\n-\t\t\t\t  use, cand, address_p, inv_vars, use->stmt,\n-\t\t\t\t  can_autoinc, inv_expr);\n-}\n-\n /* Determines cost of computing the use in GROUP with CAND in a generic\n    expression.  */\n \n@@ -7213,7 +7185,7 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n \t}\n     }\n \n-  comp = get_computation (data->current_loop, use, cand);\n+  comp = get_computation_at (data->current_loop, use->stmt, use, cand);\n   gcc_assert (comp != NULL_TREE);\n \n   switch (gimple_code (use->stmt))\n@@ -7438,7 +7410,7 @@ rewrite_use_compare (struct ivopts_data *data,\n \n   /* The induction variable elimination failed; just express the original\n      giv.  */\n-  comp = get_computation (data->current_loop, use, cand);\n+  comp = get_computation_at (data->current_loop, use->stmt, use, cand);\n   gcc_assert (comp != NULL_TREE);\n \n   ok = extract_cond_operands (data, use->stmt, &var_p, NULL, NULL, NULL);\n@@ -7579,8 +7551,8 @@ remove_unused_ivs (struct ivopts_data *data)\n \t\tcontinue;\n \n \t      tree comp = get_computation_at (data->current_loop,\n-\t\t\t\t\t      &dummy_use, best_cand,\n-\t\t\t\t\t      SSA_NAME_DEF_STMT (def));\n+\t\t\t\t\t      SSA_NAME_DEF_STMT (def),\n+\t\t\t\t\t      &dummy_use, best_cand);\n \t      if (!comp)\n \t\tcontinue;\n "}]}