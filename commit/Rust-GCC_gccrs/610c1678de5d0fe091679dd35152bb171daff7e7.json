{"sha": "610c1678de5d0fe091679dd35152bb171daff7e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjEwYzE2NzhkZTVkMGZlMDkxNjc5ZGQzNTE1MmJiMTcxZGFmZjdlNw==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-07-31T08:13:14Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T21:13:20Z"}, "message": "Enhancements to x86 target hook, should be feature complete with llvm to the greatest extent possible", "tree": {"sha": "cf5dea15cffb43d4837645d713c1b3e4ba9cd914", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf5dea15cffb43d4837645d713c1b3e4ba9cd914"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/610c1678de5d0fe091679dd35152bb171daff7e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/610c1678de5d0fe091679dd35152bb171daff7e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/610c1678de5d0fe091679dd35152bb171daff7e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/610c1678de5d0fe091679dd35152bb171daff7e7/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f12a7eba28bdd2d3d4514113247d8423afe8a46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f12a7eba28bdd2d3d4514113247d8423afe8a46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f12a7eba28bdd2d3d4514113247d8423afe8a46"}], "stats": {"total": 544, "additions": 406, "deletions": 138}, "files": [{"sha": "63f0fef0e65bbf3f7efd15db24bc69c21d14455c", "filename": "gcc/config/i386/i386-rust.c", "status": "modified", "additions": 406, "deletions": 138, "changes": 544, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610c1678de5d0fe091679dd35152bb171daff7e7/gcc%2Fconfig%2Fi386%2Fi386-rust.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610c1678de5d0fe091679dd35152bb171daff7e7/gcc%2Fconfig%2Fi386%2Fi386-rust.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-rust.c?ref=610c1678de5d0fe091679dd35152bb171daff7e7", "patch": "@@ -47,186 +47,454 @@ ix86_rust_target_cpu_info (void)\n         rust_add_target_info(\"target_arch\", \"x86\");\n     }\n \n-    // maybe more stuff I don't understand if evidenced by ix86_target_macros in i386-c.c\n-\n-    // note: options that don't seem to have a target feature in rust are commented out\n-\n-    // TODO: properly change at some point instead of macro def\n-#ifndef isa_flag\n-# define isa_flag ix86_isa_flags\n-# define isa_flag2 ix86_isa_flags2\n-# define fpmath ix86_fpmath\n-#else\n-# error \"isa_flag and isa_flag2 already defined in i386-rust.c - weird things might happen\"\n-#endif\n-\n-    // options should be feature complete for rustc atm\n-  if (isa_flag2 & OPTION_MASK_ISA2_WBNOINVD)\n-    ; //def_or_undef (parse_in, \"__WBNOINVD__\");\n-  if (isa_flag2 & OPTION_MASK_ISA2_AVX512VP2INTERSECT)\n-    ; //def_or_undef (parse_in, \"__AVX512VP2INTERSECT__\");\n-  if (isa_flag & OPTION_MASK_ISA_MMX)\n+  // features officially \"stabilised\" in rustc\n+  if (TARGET_ISA_MMX)\n     rust_add_target_info(\"target_feature\", \"mmx\");\n-  if (isa_flag & OPTION_MASK_ISA_3DNOW)\n-    ; //def_or_undef (parse_in, \"__3dNOW__\");\n-  if (isa_flag & OPTION_MASK_ISA_3DNOW_A)\n-    ; //def_or_undef (parse_in, \"__3dNOW_A__\");\n-  if (isa_flag & OPTION_MASK_ISA_SSE)\n+  if (TARGET_ISA_SSE)\n     rust_add_target_info(\"target_feature\", \"sse\");\n-  if (isa_flag & OPTION_MASK_ISA_SSE2)\n+  if (TARGET_ISA_SSE2)\n     rust_add_target_info(\"target_feature\", \"sse2\");\n-  if (isa_flag & OPTION_MASK_ISA_SSE3)\n+  if (TARGET_ISA_SSE3)\n     rust_add_target_info(\"target_feature\", \"sse3\");\n-  if (isa_flag & OPTION_MASK_ISA_SSSE3)\n+  if (TARGET_ISA_SSSE3)\n     rust_add_target_info(\"target_feature\", \"ssse3\");\n-  if (isa_flag & OPTION_MASK_ISA_SSE4_1)\n+  if (TARGET_ISA_SSE4_1)\n     rust_add_target_info(\"target_feature\", \"sse4.1\");\n-  if (isa_flag & OPTION_MASK_ISA_SSE4_2)\n+  if (TARGET_ISA_SSE4_2)\n     rust_add_target_info(\"target_feature\", \"sse4.2\");\n-  if (isa_flag & OPTION_MASK_ISA_AES)\n+  if (TARGET_ISA_AES)\n     rust_add_target_info(\"target_feature\", \"aes\");\n-  if (isa_flag & OPTION_MASK_ISA_SHA)\n+  if (TARGET_ISA_SHA)\n     rust_add_target_info(\"target_feature\", \"sha\");\n-  if (isa_flag & OPTION_MASK_ISA_PCLMUL)\n-    ; //def_or_undef (parse_in, \"__PCLMUL__\");\n-  if (isa_flag & OPTION_MASK_ISA_AVX)\n+  if (TARGET_ISA_AVX)\n     rust_add_target_info(\"target_feature\", \"avx\");\n-  if (isa_flag & OPTION_MASK_ISA_AVX2)\n+  if (TARGET_ISA_AVX2)\n     rust_add_target_info(\"target_feature\", \"avx2\");\n-  if (isa_flag & OPTION_MASK_ISA_AVX512F)\n+  if (TARGET_ISA_AVX512F)\n     rust_add_target_info(\"target_feature\", \"avx512f\");\n-  if (isa_flag & OPTION_MASK_ISA_AVX512ER)\n+  if (TARGET_ISA_AVX512ER)\n     rust_add_target_info(\"target_feature\", \"avx512er\");\n-  if (isa_flag & OPTION_MASK_ISA_AVX512CD)\n+  if (TARGET_ISA_AVX512CD)\n     rust_add_target_info(\"target_feature\", \"avx512cd\");\n-  if (isa_flag & OPTION_MASK_ISA_AVX512PF)\n+  if (TARGET_ISA_AVX512PF)\n     rust_add_target_info(\"target_feature\", \"avx512pf\");\n-  if (isa_flag & OPTION_MASK_ISA_AVX512DQ)\n+  if (TARGET_ISA_AVX512DQ)\n     rust_add_target_info(\"target_feature\", \"avx512dq\");\n-  if (isa_flag & OPTION_MASK_ISA_AVX512BW)\n+  if (TARGET_ISA_AVX512BW)\n     rust_add_target_info(\"target_feature\", \"avx512bw\");\n-  if (isa_flag & OPTION_MASK_ISA_AVX512VL)\n+  if (TARGET_ISA_AVX512VL)\n     rust_add_target_info(\"target_feature\", \"avx512vl\");\n-  if (isa_flag & OPTION_MASK_ISA_AVX512VBMI)\n+  if (TARGET_ISA_AVX512VBMI)\n     rust_add_target_info(\"target_feature\", \"avx512vbmi\");\n-  if (isa_flag & OPTION_MASK_ISA_AVX512IFMA)\n+  if (TARGET_ISA_AVX512IFMA)\n     rust_add_target_info(\"target_feature\", \"avx512ifma\");\n-  if (isa_flag2 & OPTION_MASK_ISA2_AVX5124VNNIW)\n-    ; //def_or_undef (parse_in, \"__AVX5124VNNIW__\");\n-  if (isa_flag & OPTION_MASK_ISA_AVX512VBMI2)\n-    ; //def_or_undef (parse_in, \"__AVX512VBMI2__\");\n-  if (isa_flag & OPTION_MASK_ISA_AVX512VNNI)\n-    ; //def_or_undef (parse_in, \"__AVX512VNNI__\");\n-  if (isa_flag2 & OPTION_MASK_ISA2_PCONFIG)\n-    ; //def_or_undef (parse_in, \"__PCONFIG__\");\n-  if (isa_flag2 & OPTION_MASK_ISA2_SGX)\n-    ; //def_or_undef (parse_in, \"__SGX__\");\n-  if (isa_flag2 & OPTION_MASK_ISA2_AVX5124FMAPS)\n-    ; //def_or_undef (parse_in, \"__AVX5124FMAPS__\");\n-  if (isa_flag & OPTION_MASK_ISA_AVX512BITALG)\n-    ; //def_or_undef (parse_in, \"__AVX512BITALG__\");\n-  if (isa_flag & OPTION_MASK_ISA_AVX512VPOPCNTDQ)\n+  if (TARGET_ISA_AVX512VPOPCNTDQ)\n     rust_add_target_info(\"target_feature\", \"avx512vpopcntdq\");\n-  if (isa_flag & OPTION_MASK_ISA_FMA)\n+  if (TARGET_ISA_FMA)\n     rust_add_target_info(\"target_feature\", \"fma\");\n-  if (isa_flag & OPTION_MASK_ISA_RTM)\n+  if (TARGET_ISA_RTM)\n     rust_add_target_info(\"target_feature\", \"rtm\");\n-  if (isa_flag & OPTION_MASK_ISA_SSE4A)\n+  if (TARGET_ISA_SSE4A)\n     rust_add_target_info(\"target_feature\", \"sse4a\");\n-  if (isa_flag & OPTION_MASK_ISA_FMA4)\n-    ; //def_or_undef (parse_in, \"__FMA4__\");\n-  if (isa_flag & OPTION_MASK_ISA_XOP)\n-    ; //def_or_undef (parse_in, \"__XOP__\");\n-  if (isa_flag & OPTION_MASK_ISA_LWP)\n-    ; //def_or_undef (parse_in, \"__LWP__\");\n-  if (isa_flag & OPTION_MASK_ISA_ABM)\n-    ; //def_or_undef (parse_in, \"__ABM__\");\n-  if (isa_flag & OPTION_MASK_ISA_BMI)\n+  if (TARGET_ISA_BMI) {\n     rust_add_target_info(\"target_feature\", \"bmi1\");\n-  if (isa_flag & OPTION_MASK_ISA_BMI2)\n+    rust_add_target_info(\"target_feature\", \"bmi\");\n+  }\n+  if (TARGET_ISA_BMI2)\n     rust_add_target_info(\"target_feature\", \"bmi2\");\n-  if (isa_flag & OPTION_MASK_ISA_LZCNT)\n+  if (TARGET_ISA_LZCNT)\n     rust_add_target_info(\"target_feature\", \"lzcnt\");\n-  if (isa_flag & OPTION_MASK_ISA_TBM)\n+  if (TARGET_ISA_TBM)\n     rust_add_target_info(\"target_feature\", \"tbm\");\n-  if (isa_flag & OPTION_MASK_ISA_POPCNT)\n+  if (TARGET_ISA_POPCNT)\n     rust_add_target_info(\"target_feature\", \"popcnt\");\n-  if (isa_flag & OPTION_MASK_ISA_FSGSBASE)\n-    ; //def_or_undef (parse_in, \"__FSGSBASE__\");\n-  if (isa_flag & OPTION_MASK_ISA_RDRND)\n+  if (TARGET_ISA_RDRND) {\n     rust_add_target_info(\"target_feature\", \"rdrand\");\n-  if (isa_flag & OPTION_MASK_ISA_F16C)\n+    rust_add_target_info(\"target_feature\", \"rdrnd\");\n+  }\n+  if (TARGET_ISA_F16C)\n     rust_add_target_info(\"target_feature\", \"f16c\");\n-  if (isa_flag & OPTION_MASK_ISA_RDSEED)\n+  if (TARGET_ISA_RDSEED)\n     rust_add_target_info(\"target_feature\", \"rdseed\");\n-  if (isa_flag & OPTION_MASK_ISA_PRFCHW)\n-    ; //def_or_undef (parse_in, \"__PRFCHW__\");\n-  if (isa_flag & OPTION_MASK_ISA_ADX)\n+  if (TARGET_ISA_ADX)\n     rust_add_target_info(\"target_feature\", \"adx\");\n-  if (isa_flag & OPTION_MASK_ISA_FXSR)\n+  if (TARGET_ISA_FXSR)\n     rust_add_target_info(\"target_feature\", \"fxsr\");\n-  if (isa_flag & OPTION_MASK_ISA_XSAVE)\n+  if (TARGET_ISA_XSAVE)\n     rust_add_target_info(\"target_feature\", \"xsave\");\n-  if (isa_flag & OPTION_MASK_ISA_XSAVEOPT)\n+  if (TARGET_ISA_XSAVEOPT)\n     rust_add_target_info(\"target_feature\", \"xsaveopt\");\n-  if (isa_flag & OPTION_MASK_ISA_PREFETCHWT1)\n-    ; //def_or_undef (parse_in, \"__PREFETCHWT1__\");\n-  if ((fpmath & FPMATH_SSE) && (isa_flag & OPTION_MASK_ISA_SSE))\n-    ; //def_or_undef (parse_in, \"__SSE_MATH__\");\n-  if ((fpmath & FPMATH_SSE) && (isa_flag & OPTION_MASK_ISA_SSE2))\n-    ; //def_or_undef (parse_in, \"__SSE2_MATH__\");\n-  if (isa_flag & OPTION_MASK_ISA_CLFLUSHOPT)\n-    ; //def_or_undef (parse_in, \"__CLFLUSHOPT__\");\n-  if (isa_flag2 & OPTION_MASK_ISA2_CLZERO)\n-    ; //def_or_undef (parse_in, \"__CLZERO__\");\n-  if (isa_flag & OPTION_MASK_ISA_XSAVEC)\n+  if (TARGET_ISA_XSAVEC)\n     rust_add_target_info(\"target_feature\", \"xsavec\");\n-  if (isa_flag & OPTION_MASK_ISA_XSAVES)\n+  if (TARGET_ISA_XSAVES)\n     rust_add_target_info(\"target_feature\", \"xsaves\");\n-  if (isa_flag & OPTION_MASK_ISA_CLWB)\n-    ; //def_or_undef (parse_in, \"__CLWB__\");\n-  if (isa_flag2 & OPTION_MASK_ISA2_MWAITX)\n-    ; //def_or_undef (parse_in, \"__MWAITX__\");\n-  if (isa_flag & OPTION_MASK_ISA_PKU)\n-    ; //def_or_undef (parse_in, \"__PKU__\");\n-  if (isa_flag2 & OPTION_MASK_ISA2_RDPID)\n-    ; //def_or_undef (parse_in, \"__RDPID__\");\n-  if (isa_flag & OPTION_MASK_ISA_GFNI)\n-    ; //def_or_undef (parse_in, \"__GFNI__\");\n-  if ((isa_flag & OPTION_MASK_ISA_SHSTK))\n-    ; //def_or_undef (parse_in, \"__SHSTK__\");\n-  if (isa_flag2 & OPTION_MASK_ISA2_VAES)\n-    ; //def_or_undef (parse_in, \"__VAES__\");\n-  if (isa_flag & OPTION_MASK_ISA_VPCLMULQDQ)\n+  if (TARGET_ISA_VPCLMULQDQ) {\n     rust_add_target_info(\"target_feature\", \"pclmulqdq\");\n-  if (isa_flag & OPTION_MASK_ISA_MOVDIRI)\n-    ; //def_or_undef (parse_in, \"__MOVDIRI__\");\n-  if (isa_flag2 & OPTION_MASK_ISA2_MOVDIR64B)\n-    ; //def_or_undef (parse_in, \"__MOVDIR64B__\");\n-  if (isa_flag2 & OPTION_MASK_ISA2_WAITPKG)\n-    ; //def_or_undef (parse_in, \"__WAITPKG__\");\n-  if (isa_flag2 & OPTION_MASK_ISA2_CLDEMOTE)\n-    ; //def_or_undef (parse_in, \"__CLDEMOTE__\");\n-  if (isa_flag2 & OPTION_MASK_ISA2_PTWRITE)\n-    ; //def_or_undef (parse_in, \"__PTWRITE__\");\n-  if (isa_flag2 & OPTION_MASK_ISA2_AVX512BF16)\n-    ; //def_or_undef (parse_in, \"__AVX512BF16__\");\n-  if (TARGET_MMX_WITH_SSE)\n-    ; //def_or_undef (parse_in, \"__MMX_WITH_SSE__\");\n-  if (isa_flag2 & OPTION_MASK_ISA2_ENQCMD)\n-    ; //def_or_undef (parse_in, \"__ENQCMD__\");\n-  if (TARGET_IAMCU)\n-    {\n-      //def_or_undef (parse_in, \"__iamcu\");\n-      //def_or_undef (parse_in, \"__iamcu__\");\n-    }\n+    rust_add_target_info(\"target_feature\", \"vpclmulqdq\");\n+  }\n   if (TARGET_CMPXCHG16B)\n     rust_add_target_info(\"target_feature\", \"cmpxchg16b\");\n   if (TARGET_MOVBE)\n     rust_add_target_info(\"target_feature\", \"movbe\");\n \n-#undef isa_flag\n-#undef isa_flag2\n-#undef fpmath\n-}\n+  // features derived from llvm not yet in rustc:\n+  if (TARGET_ISA_64BIT)\n+    rust_add_target_info(\"target_feature\", \"64bit-mode\");\n+  else if (TARGET_CODE16)\n+    rust_add_target_info(\"target_feature\", \"16bit-mode\");\n+  else\n+    rust_add_target_info(\"target_feature\", \"32bit-mode\");\n+  \n+  // TODO: assuming that the TARGET_80387 (which seems to mean \"hard float\") is also required for x87\n+  if (TARGET_80387 && (ix86_fpmath & FPMATH_387) != 0)\n+    rust_add_target_info(\"target_feature\", \"x87\");\n+\n+  // nopl: hard-coded (as gcc doesn't technically have feature) to return true for cpu arches with it\n+  // maybe refactor into switch if multiple options\n+  bool hasNOPL = ix86_arch == PROCESSOR_PENTIUMPRO || ix86_arch == PROCESSOR_PENTIUM4 \n+    || ix86_arch == PROCESSOR_NOCONA || ix86_arch == PROCESSOR_CORE2 || ix86_arch == PROCESSOR_NEHALEM \n+    || ix86_arch == PROCESSOR_BONNELL || ix86_arch == PROCESSOR_SILVERMONT \n+    || ix86_arch == PROCESSOR_GOLDMONT || ix86_arch == PROCESSOR_GOLDMONT_PLUS \n+    || ix86_arch == PROCESSOR_TREMONT || ix86_arch == PROCESSOR_SANDYBRIDGE \n+    || ix86_arch == PROCESSOR_HASWELL || ix86_arch == PROCESSOR_SKYLAKE \n+    || ix86_arch == PROCESSOR_SKYLAKE_AVX512 || ix86_arch == PROCESSOR_CANNONLAKE \n+    || ix86_arch == PROCESSOR_CASCADELAKE  || ix86_arch == PROCESSOR_COOPERLAKE \n+    || ix86_arch == PROCESSOR_ICELAKE_CLIENT || ix86_arch == PROCESSOR_ICELAKE_SERVER \n+    || ix86_arch == PROCESSOR_TIGERLAKE || ix86_arch == PROCESSOR_KNL || ix86_arch == PROCESSOR_KNM \n+    || ix86_arch == PROCESSOR_AMDFAM10 || ix86_arch == PROCESSOR_BTVER1 || ix86_arch == PROCESSOR_BTVER2 \n+    || ix86_arch == PROCESSOR_BDVER1 || ix86_arch == PROCESSOR_BDVER2 || ix86_arch == PROCESSOR_BDVER3 \n+    || ix86_arch == PROCESSOR_BDVER4 || ix86_arch == PROCESSOR_ZNVER1 || ix86_arch == PROCESSOR_ZNVER2 \n+    || ix86_arch == PROCESSOR_ATHLON || ix86_arch == PROCESSOR_K8; \n+  // this list should be exhaustive\n+  if (hasNOPL)\n+    rust_add_target_info(\"target_feature\", \"nopl\");\n+  if (TARGET_CMOVE)\n+    rust_add_target_info(\"target_feature\", \"cmov\");\n+  if (TARGET_CMPXCHG8B)\n+    rust_add_target_info(\"target_feature\", \"cx8\");\n+  if (TARGET_ISA_3DNOW)\n+    rust_add_target_info(\"target_feature\", \"3dnow\");\n+  if (TARGET_ISA_3DNOW_A)\n+    rust_add_target_info(\"target_feature\", \"3dnowa\");\n+  if (TARGET_64BIT)\n+    rust_add_target_info(\"target_feature\", \"64bit\");\n+  if (TARGET_CMPXCHG16B)\n+    rust_add_target_info(\"target_feature\", \"cx16\");\n+\n+  bool hasSlowSHLD = ix86_arch == PROCESSOR_AMDFAM10 || ix86_arch == PROCESSOR_BTVER1 \n+    || ix86_arch == PROCESSOR_BTVER2 || ix86_arch == PROCESSOR_BDVER1 || ix86_arch == PROCESSOR_BDVER2 \n+    || ix86_arch == PROCESSOR_BDVER3 || ix86_arch == PROCESSOR_BDVER4 || ix86_arch == PROCESSOR_ZNVER1 \n+    || ix86_arch == PROCESSOR_ZNVER2 || ix86_arch == PROCESSOR_ATHLON || ix86_arch == PROCESSOR_K8; \n+  // TODO: this is not ideal as it marks the baseline x86-64 CPU as having it - only AMD ones do\n+  if (hasSlowSHLD)\n+    rust_add_target_info(\"target_feature\", \"slow-shld\");\n+  if (ix86_arch == PROCESSOR_SILVERMONT)\n+    rust_add_target_info(\"target_feature\", \"slow-pmulld\");\n+  if (ix86_arch == PROCESSOR_KNL || ix86_arch == PROCESSOR_KNM)\n+    rust_add_target_info(\"target_feature\", \"slow-pmaddwd\");\n+\n+  bool hasSlowUnaligned16 = ix86_arch == PROCESSOR_BONNELL || ix86_arch == PROCESSOR_GENERIC \n+    || ix86_arch == PROCESSOR_I386 || ix86_arch == PROCESSOR_I486 || ix86_arch == PROCESSOR_PENTIUM \n+    || ix86_arch == PROCESSOR_PENTIUMPRO || ix86_arch == PROCESSOR_PENTIUM4 \n+    || ix86_arch == PROCESSOR_NOCONA || ix86_arch == PROCESSOR_CORE2 || ix86_arch == PROCESSOR_K6 \n+    || ix86_arch == PROCESSOR_ATHLON || ix86_arch == PROCESSOR_K8 || ix86_arch == PROCESSOR_GEODE;\n+  if (hasSlowUnaligned16)\n+    rust_add_target_info(\"target_feature\", \"slow-unaligned-mem-16\");\n+  if (ix86_arch == PROCESSOR_SANDYBRIDGE)\n+    rust_add_target_info(\"target_feature\", \"slow-unaligned-mem-32\");\n+  if (TARGET_ISA_PREFETCHWT1)\n+    rust_add_target_info(\"target_feature\", \"prefetchwt1\");\n+  if (TARGET_ISA_AVX512VBMI2)\n+    rust_add_target_info(\"target_feature\", \"avx512vbmi2\");\n+  if (TARGET_ISA_PKU)\n+    rust_add_target_info(\"target_feature\", \"pku\");\n+  if (TARGET_ISA_AVX512VNNI)\n+    rust_add_target_info(\"target_feature\", \"avx512vnni\");\n+  if (TARGET_ISA_AVX512BF16)\n+    rust_add_target_info(\"target_feature\", \"avx512bf16\");\n+  if (TARGET_ISA_AVX512BITALG)\n+    rust_add_target_info(\"target_feature\", \"avx512bitalg\");\n+  if (TARGET_ISA_AVX512VP2INTERSECT)\n+    rust_add_target_info(\"target_feature\", \"avx512vp2intersect\");\n+  if (TARGET_ISA_PCLMUL)\n+    rust_add_target_info(\"target_feature\", \"pclmul\");\n+  if (TARGET_ISA_GFNI)\n+    rust_add_target_info(\"target_feature\", \"gfni\");\n+  if (TARGET_ISA_FMA4)\n+    rust_add_target_info(\"target_feature\", \"fma4\");\n+  if (TARGET_ISA_XOP)\n+    rust_add_target_info(\"target_feature\", \"xop\");\n+\n+  // this is only enabled by choice in llvm, never by default - TODO determine if gcc enables it\n+  // rust_add_target_info(\"target_feature\", \"sse-unaligned-mem\");\n+\n+  if (TARGET_ISA_VAES)\n+    rust_add_target_info(\"target_feature\", \"vaes\");\n+  if (TARGET_ISA_LWP)\n+    rust_add_target_info(\"target_feature\", \"lwp\");\n+  if (TARGET_ISA_FSGSBASE)\n+    rust_add_target_info(\"target_feature\", \"fsgsbase\");\n+  if (TARGET_ISA_SHSTK)\n+    rust_add_target_info(\"target_feature\", \"shstk\");\n+  if (TARGET_ISA_PRFCHW)\n+    rust_add_target_info(\"target_feature\", \"prfchw\");\n+  if (TARGET_ISA_SAHF) // would this be better as TARGET_USE_SAHF?\n+    rust_add_target_info(\"target_feature\", \"sahf\");\n+  if (TARGET_ISA_MWAITX)\n+    rust_add_target_info(\"target_feature\", \"mwaitx\");\n+  if (TARGET_ISA_CLZERO)\n+    rust_add_target_info(\"target_feature\", \"clzero\");\n+  if (TARGET_ISA_CLDEMOTE)\n+    rust_add_target_info(\"target_feature\", \"cldemote\");\n+  if (TARGET_ISA_PTWRITE)\n+    rust_add_target_info(\"target_feature\", \"ptwrite\");\n+  // TODO: add amx-tile, amx-int8, amx-bf16 features when gcc supports them \n+\n+  // TODO: can't find any gcc option relating to using LEA for adjusting stack pointer, so hardcoding\n+  if (ix86_arch == PROCESSOR_BONNELL)\n+    rust_add_target_info(\"target_feature\", \"lea-sp\");\n+\n+  // TODO: confirm that this is what it actually refers to\n+  if (TARGET_USE_8BIT_IDIV)\n+    rust_add_target_info(\"target_feature\", \"idivl-to-divb\");\n+\n+  /* TODO: can't find any gcc option corresponding to idivq-to-divl - does gcc perform this optimisation?\n+   * if so, add that feature (use 32-bit divide for positive values less than 2^32) */\n+  /* bool llvmHasSlowDivide64 = ix86_arch == PROCESSOR_SANDYBRIDGE || ix86_arch == PROCESSOR_HASWELL \n+    || ix86_arch == PROCESSOR_SKYLAKE || ix86_arch == PROCESSOR_SKYLAKE_AVX512 \n+    || ix86_arch == PROCESSOR_CANNONLAKE || ix86_arch == PROCESSOR_ICELAKE_CLIENT \n+    || ix86_arch == PROCESSOR_ICELAKE_SERVER || ix86_arch == PROCESSOR_CASCADELAKE \n+    || ix86_arch == PROCESSOR_TIGERLAKE || ix86_arch == PROCESSOR_COOPERLAKE \n+    || ix86_arch == PROCESSOR_BONNELL || ix86_arch == PROCESSOR_SILVERMONT || ix86_arch == PROCESSOR_KNL \n+    || ix86_arch == PROCESSOR_KNM || ix86_arch == PROCESSOR_K8;*/\n+\n+  if (TARGET_PAD_SHORT_FUNCTION)\n+    rust_add_target_info(\"target_feature\", \"pad-short-functions\");\n+\n+  // TODO: gcc seems to not record whether INVPCID exists, so basing it on llvm\n+  bool hasINVPCID = ix86_arch == PROCESSOR_HASWELL || ix86_arch == PROCESSOR_SKYLAKE \n+    || ix86_arch == PROCESSOR_SKYLAKE_AVX512 || ix86_arch == PROCESSOR_CANNONLAKE \n+    || ix86_arch == PROCESSOR_ICELAKE_CLIENT || ix86_arch == PROCESSOR_ICELAKE_SERVER \n+    || ix86_arch == PROCESSOR_CASCADELAKE || ix86_arch == PROCESSOR_TIGERLAKE \n+    || ix86_arch == PROCESSOR_COOPERLAKE; \n+  if (hasINVPCID)\n+    rust_add_target_info(\"target_feature\", \"invpcid\");\n+  if (TARGET_ISA_SGX)\n+    rust_add_target_info(\"target_feature\", \"sgx\");\n+  if (TARGET_ISA_CLFLUSHOPT)\n+    rust_add_target_info(\"target_feature\", \"clflushopt\");\n+  if (TARGET_ISA_CLWB)\n+    rust_add_target_info(\"target_feature\", \"clwb\");\n+  if (TARGET_ISA_WBNOINVD)\n+    rust_add_target_info(\"target_feature\", \"wbnoinvd\");\n+  if (TARGET_ISA_RDPID)\n+    rust_add_target_info(\"target_feature\", \"rdpid\");\n+  if (TARGET_ISA_WAITPKG)\n+    rust_add_target_info(\"target_feature\", \"waitpkg\");\n+  if (TARGET_ISA_ENQCMD)\n+    rust_add_target_info(\"target_feature\", \"enqcmd\");\n+\n+  // these are only enabled by choice in llvm, never by default - TODO determine if gcc supports them\n+  // rust_add_target_info(\"target_feature\", \"serialize\");\n+  // rust_add_target_info(\"target_feature\", \"tsxldtrk\");\n+\n+  // TODO: gcc seems to not record whether to avoid memory operanded instructions, so basing it on llvm\n+  bool hasSlowTwoMemOps = ix86_arch == PROCESSOR_BONNELL || ix86_arch == PROCESSOR_SILVERMONT \n+    || ix86_arch == PROCESSOR_GOLDMONT || ix86_arch == PROCESSOR_GOLDMONT_PLUS \n+    || ix86_arch == PROCESSOR_TREMONT || ix86_arch == PROCESSOR_KNL || ix86_arch == PROCESSOR_KNM; \n+  if (hasSlowTwoMemOps)\n+    rust_add_target_info(\"target_feature\", \"slow-two-mem-ops\");\n+\n+  // TODO: gcc seems to not record whether LEA needs input at AG stage, so basing it on llvm\n+  // TODO: maybe something to do with X86_TUNE_OPT_AGU?\n+  if (ix86_arch == PROCESSOR_BONNELL)\n+    rust_add_target_info(\"target_feature\", \"lea-uses-ag\");\n+\n+  // TODO: gcc seems to not record whether LEA with certain arguments is slow, so basing it on llvm\n+  // TODO: maybe TARGET_AVOID_LEA_FOR_ADDR has something to do with it?\n+  bool hasSlowLEA = ix86_arch == PROCESSOR_SILVERMONT || ix86_arch == PROCESSOR_GOLDMONT \n+    || ix86_arch == PROCESSOR_GOLDMONT_PLUS || ix86_arch == PROCESSOR_TREMONT;\n+  if (hasSlowLEA)\n+    rust_add_target_info(\"target_feature\", \"slow-lea\");\n+  \n+  // TODO: gcc seems to not record whether LEA with 3 ops or certain regs is slow, so basing it on llvm\n+  // TODO: maybe TARGET_AVOID_LEA_FOR_ADDR has something to do with it?\n+  bool hasSlow3OpsLEA = ix86_arch == PROCESSOR_SANDYBRIDGE || ix86_arch == PROCESSOR_HASWELL \n+    || ix86_arch == PROCESSOR_SKYLAKE || ix86_arch == PROCESSOR_SKYLAKE_AVX512 \n+    || ix86_arch == PROCESSOR_CANNONLAKE || ix86_arch == PROCESSOR_ICELAKE_CLIENT \n+    || ix86_arch == PROCESSOR_ICELAKE_SERVER || ix86_arch == PROCESSOR_CASCADELAKE \n+    || ix86_arch == PROCESSOR_TIGERLAKE || ix86_arch == PROCESSOR_COOPERLAKE \n+    || ix86_arch == PROCESSOR_KNL || ix86_arch == PROCESSOR_KNM || ix86_arch == PROCESSOR_K8; \n+  if (hasSlow3OpsLEA)\n+    rust_add_target_info(\"target_feature\", \"slow-3ops-lea\");\n+\n+  // TODO: assuming that this is equivalent option - it strictly doesn't cover same cpus\n+  if (!TARGET_USE_INCDEC)\n+    rust_add_target_info(\"target_feature\", \"slow-incdec\");\n+  // TODO: assuming that this mask actually refers to \"hard float\" and not x87 specifically\n+  if (!TARGET_80387)\n+    rust_add_target_info(\"target_feature\", \"soft-float\");\n+\n+  // TODO: gcc seems to not record if LZCNT/TZCNT has false deps on dest register, so basing it on llvm\n+  if (ix86_arch == PROCESSOR_HASWELL)\n+    rust_add_target_info(\"target_feature\", \"false-deps-lzcnt-tzcnt\");\n+\n+  if (TARGET_ISA_PCONFIG)\n+    rust_add_target_info(\"target_feature\", \"pconfig\");\n+\n+  // TODO: gcc seems to not record if variable-mask shuffles are fast, so basing it on llvm\n+  bool hasFastVariableShuffle = ix86_arch == PROCESSOR_HASWELL || ix86_arch == PROCESSOR_SKYLAKE \n+    || ix86_arch == PROCESSOR_SKYLAKE_AVX512 || ix86_arch == PROCESSOR_CANNONLAKE \n+    || ix86_arch == PROCESSOR_ICELAKE_CLIENT || ix86_arch == PROCESSOR_ICELAKE_SERVER \n+    || ix86_arch == PROCESSOR_CASCADELAKE || ix86_arch == PROCESSOR_TIGERLAKE \n+    || ix86_arch == PROCESSOR_COOPERLAKE; \n+  if (hasFastVariableShuffle)\n+    rust_add_target_info(\"target_feature\", \"fast-variable-shuffle\");\n+\n+  // TODO: ensure that this actually refers to the right thing - difference in gcc and llvm description\n+  if (TARGET_VZEROUPPER)\n+    rust_add_target_info(\"target_feature\", \"vzeroupper\");\n \n+  // option based on llvm arch analysis as gcc tuning costs seem to indicate a different result\n+  bool hasFastScalarFSQRT = ix86_arch == PROCESSOR_SANDYBRIDGE || ix86_arch == PROCESSOR_HASWELL \n+    || ix86_arch == PROCESSOR_SKYLAKE || ix86_arch == PROCESSOR_SKYLAKE_AVX512 \n+    || ix86_arch == PROCESSOR_CANNONLAKE || ix86_arch == PROCESSOR_ICELAKE_CLIENT \n+    || ix86_arch == PROCESSOR_ICELAKE_SERVER || ix86_arch == PROCESSOR_CASCADELAKE \n+    || ix86_arch == PROCESSOR_TIGERLAKE || ix86_arch == PROCESSOR_COOPERLAKE;\n+  if (hasFastScalarFSQRT)\n+    rust_add_target_info(\"target_feature\", \"fast-scalar-fsqrt\");\n+\n+  // option also based on llvm arch analysis \n+  bool hasFastVectorFSQRT = ix86_arch == PROCESSOR_SKYLAKE || ix86_arch == PROCESSOR_SKYLAKE_AVX512 \n+    || ix86_arch == PROCESSOR_CANNONLAKE || ix86_arch == PROCESSOR_ICELAKE_CLIENT \n+    || ix86_arch == PROCESSOR_ICELAKE_SERVER || ix86_arch == PROCESSOR_CASCADELAKE \n+    || ix86_arch == PROCESSOR_TIGERLAKE || ix86_arch == PROCESSOR_COOPERLAKE;\n+  if (hasFastVectorFSQRT)\n+    rust_add_target_info(\"target_feature\", \"fast-vector-fsqrt\");\n+\n+  bool hasFastLZCNT = ix86_arch == PROCESSOR_BTVER2 || ix86_arch == PROCESSOR_ZNVER1 \n+    || ix86_arch == PROCESSOR_ZNVER2;\n+  if (hasFastLZCNT)\n+    rust_add_target_info(\"target_feature\", \"fast-lzcnt\");\n+\n+  if (ix86_arch == PROCESSOR_SILVERMONT)\n+    rust_add_target_info(\"target_feature\", \"fast-7bytenop\");\n+\n+  bool hasFast11ByteNOP = ix86_arch == PROCESSOR_BDVER1 || ix86_arch == PROCESSOR_BDVER2 \n+    || ix86_arch == PROCESSOR_BDVER3 || ix86_arch == PROCESSOR_BDVER4;\n+  if (hasFast11ByteNOP)\n+    rust_add_target_info(\"target_feature\", \"fast-11bytenop\");\n+\n+  bool hasFast15ByteNOP = ix86_arch == PROCESSOR_SANDYBRIDGE || ix86_arch == PROCESSOR_HASWELL \n+    || ix86_arch == PROCESSOR_SKYLAKE || ix86_arch == PROCESSOR_SKYLAKE_AVX512 \n+    || ix86_arch == PROCESSOR_CANNONLAKE || ix86_arch == PROCESSOR_ICELAKE_CLIENT \n+    || ix86_arch == PROCESSOR_ICELAKE_SERVER || ix86_arch == PROCESSOR_CASCADELAKE \n+    || ix86_arch == PROCESSOR_TIGERLAKE || ix86_arch == PROCESSOR_COOPERLAKE \n+    || ix86_arch == PROCESSOR_BTVER1 || ix86_arch == PROCESSOR_BTVER2\n+    || ix86_arch == PROCESSOR_ZNVER1 || ix86_arch == PROCESSOR_ZNVER2;\n+  if (hasFast15ByteNOP)\n+    rust_add_target_info(\"target_feature\", \"fast-15bytenop\");\n+\n+  bool hasFastSHLDRotate = ix86_arch == PROCESSOR_SANDYBRIDGE || ix86_arch == PROCESSOR_HASWELL \n+    || ix86_arch == PROCESSOR_SKYLAKE || ix86_arch == PROCESSOR_SKYLAKE_AVX512 \n+    || ix86_arch == PROCESSOR_CANNONLAKE || ix86_arch == PROCESSOR_ICELAKE_CLIENT \n+    || ix86_arch == PROCESSOR_ICELAKE_SERVER || ix86_arch == PROCESSOR_CASCADELAKE \n+    || ix86_arch == PROCESSOR_TIGERLAKE || ix86_arch == PROCESSOR_COOPERLAKE;\n+  if (hasFastSHLDRotate)\n+    rust_add_target_info(\"target_feature\", \"fast-shld-rotate\");\n+\n+  bool hasERMSB = ix86_arch == PROCESSOR_HASWELL || ix86_arch == PROCESSOR_SKYLAKE \n+    || ix86_arch == PROCESSOR_SKYLAKE_AVX512 || ix86_arch == PROCESSOR_CANNONLAKE \n+    || ix86_arch == PROCESSOR_ICELAKE_CLIENT || ix86_arch == PROCESSOR_ICELAKE_SERVER \n+    || ix86_arch == PROCESSOR_CASCADELAKE || ix86_arch == PROCESSOR_TIGERLAKE \n+    || ix86_arch == PROCESSOR_COOPERLAKE; \n+  if (hasERMSB)\n+    rust_add_target_info(\"target_feature\", \"ermsbd\");\n+\n+  // TODO: may exist in gcc as tune macros, but not sure, so based on llvm arches\n+  bool hasBranchFusion = ix86_arch == PROCESSOR_BDVER1 || ix86_arch == PROCESSOR_BDVER2 \n+    || ix86_arch == PROCESSOR_BDVER3 || ix86_arch == PROCESSOR_BDVER4 || ix86_arch == PROCESSOR_ZNVER1 \n+    || ix86_arch == PROCESSOR_ZNVER2;\n+  if (hasBranchFusion)\n+    rust_add_target_info(\"target_feature\", \"branchfusion\");\n+\n+  // TODO: again, may exist as tune macros, but again based on llvm arches\n+  bool hasMacroFusion = ix86_arch == PROCESSOR_CORE2 || ix86_arch == PROCESSOR_NEHALEM \n+    || ix86_arch == PROCESSOR_SANDYBRIDGE || ix86_arch == PROCESSOR_HASWELL \n+    || ix86_arch == PROCESSOR_SKYLAKE || ix86_arch == PROCESSOR_SKYLAKE_AVX512 \n+    || ix86_arch == PROCESSOR_CANNONLAKE || ix86_arch == PROCESSOR_ICELAKE_CLIENT \n+    || ix86_arch == PROCESSOR_ICELAKE_SERVER || ix86_arch == PROCESSOR_CASCADELAKE \n+    || ix86_arch == PROCESSOR_TIGERLAKE || ix86_arch == PROCESSOR_COOPERLAKE || ix86_arch == PROCESSOR_K8;\n+  if (hasMacroFusion)\n+    rust_add_target_info(\"target_feature\", \"macrofusion\");\n+\n+  // TODO: is this equivalent to TARGET_USE_GATHER?\n+  bool hasFastGather = ix86_arch == PROCESSOR_SKYLAKE || ix86_arch == PROCESSOR_SKYLAKE_AVX512 \n+    || ix86_arch == PROCESSOR_CASCADELAKE || ix86_arch == PROCESSOR_COOPERLAKE \n+    || ix86_arch == PROCESSOR_CANNONLAKE || ix86_arch == PROCESSOR_ICELAKE_CLIENT \n+    || ix86_arch == PROCESSOR_ICELAKE_SERVER || ix86_arch == PROCESSOR_TIGERLAKE \n+    || ix86_arch == PROCESSOR_KNL || ix86_arch == PROCESSOR_KNM;\n+  if (hasFastGather)\n+    rust_add_target_info(\"target_feature\", \"fast-gather\");\n+\n+  if (TARGET_PREFER_AVX128)\n+    rust_add_target_info(\"target_feature\", \"prefer-128-bit\");\n+  if (TARGET_PREFER_AVX256)\n+    rust_add_target_info(\"target_feature\", \"prefer-256-bit\");\n+\n+  bool preferMaskRegisters = ix86_arch == PROCESSOR_KNL || ix86_arch == PROCESSOR_KNM;\n+  if (preferMaskRegisters)\n+    rust_add_target_info(\"target_feature\", \"prefer-mask-registers\");\n+\n+  /* TODO: add retpoline-indirect-calls, retpoline-indirect-branches, retpoline, retpoline-external-thunk, \n+   * lvi-cfi (LVI control flow integrity), seses (speculative execution side-effect suppression)\n+   * lvi-load-hardening if gcc gets support */\n+\n+  if (TARGET_ISA_MOVDIRI)\n+    rust_add_target_info(\"target_feature\", \"movdiri\");\n+  if (TARGET_ISA_MOVDIR64B)\n+    rust_add_target_info(\"target_feature\", \"movdir64b\");\n+\n+  bool hasFastBEXTR = ix86_arch == PROCESSOR_BTVER2 || ix86_arch == PROCESSOR_BDVER2 \n+    || ix86_arch == PROCESSOR_BDVER3 || ix86_arch == PROCESSOR_BDVER4 || ix86_arch == PROCESSOR_ZNVER1 \n+    || ix86_arch == PROCESSOR_ZNVER2;\n+  if (hasFastBEXTR)\n+    rust_add_target_info(\"target_feature\", \"fast-bextr\");\n+\n+  if (ix86_arch == PROCESSOR_BTVER2)\n+    rust_add_target_info(\"target_feature\", \"fast-hops\");\n+\n+  bool hasFastScalarShiftMasks = ix86_arch == PROCESSOR_AMDFAM10 || ix86_arch == PROCESSOR_BTVER1 \n+    || ix86_arch == PROCESSOR_BTVER2 || ix86_arch == PROCESSOR_BDVER1 || ix86_arch == PROCESSOR_BDVER2 \n+    || ix86_arch == PROCESSOR_BDVER3 || ix86_arch == PROCESSOR_BDVER4 || ix86_arch == PROCESSOR_ZNVER1 \n+    || ix86_arch == PROCESSOR_ZNVER2 || ix86_arch == PROCESSOR_K8;\n+  if (hasFastScalarShiftMasks)\n+    rust_add_target_info(\"target_feature\", \"fast-scalar-shift-masks\");\n+\n+  bool hasFastVectorShiftMasks = ix86_arch == PROCESSOR_BTVER1 || ix86_arch == PROCESSOR_BTVER2;\n+  if (hasFastVectorShiftMasks)\n+    rust_add_target_info(\"target_feature\", \"fast-vector-shift-masks\");\n+\n+  bool useGoldmontDivSqrtCosts = ix86_arch == PROCESSOR_GOLDMONT || ix86_arch == PROCESSOR_GOLDMONT_PLUS \n+    || ix86_arch == PROCESSOR_TREMONT;\n+  if (useGoldmontDivSqrtCosts)\n+    rust_add_target_info(\"target_feature\", \"use-glm-div-sqrt-costs\");\n+  \n+  // TODO: determine if gcc supports alias analysis (in which case \"use-aa\" is defined)\n+\n+  // features not supported by llvm but important enough for c frontend to define macros for\n+  /*if (TARGET_ISA_AVX5124VNNIW)\n+    rust_add_target_info(\"target_feature\", \"avx5124vnniw\");\n+  if (TARGET_ISA_AVX5124FMAPS)\n+    rust_add_target_info(\"target_feature\", \"avx5124fmaps\");\n+  if (TARGET_ISA_ABM)\n+    rust_add_target_info(\"target_feature\", \"abm\");\n+  if ((ix86_fpmath & FPMATH_SSE) && TARGET_ISA_SSE)\n+    ; //def_or_undef (parse_in, \"__SSE_MATH__\");\n+  if ((ix86_fpmath & FPMATH_SSE) && TARGET_ISA_SSE2)\n+    ; //def_or_undef (parse_in, \"__SSE2_MATH__\");\n+  if (TARGET_MMX_WITH_SSE)\n+    ; //def_or_undef (parse_in, \"__MMX_WITH_SSE__\");\n+  if (TARGET_IAMCU)\n+    rust_add_target_info(\"target_feature\", \"iamcu\");*/\n+}"}]}