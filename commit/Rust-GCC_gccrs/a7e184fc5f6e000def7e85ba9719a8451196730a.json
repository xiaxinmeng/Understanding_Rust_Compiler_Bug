{"sha": "a7e184fc5f6e000def7e85ba9719a8451196730a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdlMTg0ZmM1ZjZlMDAwZGVmN2U4NWJhOTcxOWE4NDUxMTk2NzMwYQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2001-04-13T05:13:43Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2001-04-13T05:13:43Z"}, "message": "Add new files.\n\nFrom-SVN: r41323", "tree": {"sha": "04f6fd96115cbc3662f9b2b72fa14a2ab18bf060", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04f6fd96115cbc3662f9b2b72fa14a2ab18bf060"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7e184fc5f6e000def7e85ba9719a8451196730a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e184fc5f6e000def7e85ba9719a8451196730a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7e184fc5f6e000def7e85ba9719a8451196730a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e184fc5f6e000def7e85ba9719a8451196730a/comments", "author": null, "committer": null, "parents": [{"sha": "e25724d8849fe80ef00f2b5ff2eeaf387b1b4ff7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e25724d8849fe80ef00f2b5ff2eeaf387b1b4ff7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e25724d8849fe80ef00f2b5ff2eeaf387b1b4ff7"}], "stats": {"total": 441, "additions": 441, "deletions": 0}, "files": [{"sha": "874321f80f79c0724d1a2103cdf6a6f9b749035d", "filename": "gcc/config/pa/pa32-linux.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e184fc5f6e000def7e85ba9719a8451196730a/gcc%2Fconfig%2Fpa%2Fpa32-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e184fc5f6e000def7e85ba9719a8451196730a/gcc%2Fconfig%2Fpa%2Fpa32-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa32-linux.h?ref=a7e184fc5f6e000def7e85ba9719a8451196730a", "patch": "@@ -0,0 +1,26 @@\n+/* Definitions for PA_RISC with ELF-32 format\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Turn off various SOM crap we don't want. */\n+#undef TARGET_ELF32\n+#define TARGET_ELF32 1\n+\n+#undef CPP_SPEC\n+#define CPP_SPEC \"%{fPIC:-D__PIC__ -D__pic__} %{fpic:-D__PIC__ -D__pic__} %{mhppa:-D__hppa__} %{posix:-D_POSIX_SOURCE} -D_PA_RISC1_1\""}, {"sha": "04bc25bad74dc17f69032309e6a612f92f087c15", "filename": "gcc/config/pa/pa64-hpux.h", "status": "added", "additions": 340, "deletions": 0, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e184fc5f6e000def7e85ba9719a8451196730a/gcc%2Fconfig%2Fpa%2Fpa64-hpux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e184fc5f6e000def7e85ba9719a8451196730a/gcc%2Fconfig%2Fpa%2Fpa64-hpux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-hpux.h?ref=a7e184fc5f6e000def7e85ba9719a8451196730a", "patch": "@@ -0,0 +1,340 @@\n+/* Definitions of target machine for GNU compiler, for HPs running\n+   HPUX using the 64bit runtime model.\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* We can debug dynamically linked executables on hpux11; we also\n+   want dereferencing of a NULL pointer to cause a SEGV.  */\n+#undef LINK_SPEC\n+#define LINK_SPEC \\\n+  \"-E %{mlinker-opt:-O} %{!shared:-u main} %{static:-a archive} %{shared:-shared}\"\n+\n+/* Like the default, except no -lg.  */\n+#undef LIB_SPEC\n+#define LIB_SPEC \\\n+  \"%{!shared:\\\n+     %{!p:\\\n+       %{!pg:\\\n+         %{!threads:-lc}\\\n+         %{threads:-lcma -lc_r}}\\\n+       %{p: -L/lib/libp/ -lc}\\\n+       %{pg: -L/lib/libp/ -lc}}} /usr/lib/pa20_64/milli.a\"\n+\n+/* Under hpux11, the normal location of the `ld' and `as' programs is the\n+   /usr/ccs/bin directory.  */\n+\n+#ifndef CROSS_COMPILE\n+#undef MD_EXEC_PREFIX\n+#define MD_EXEC_PREFIX \"/opt/langtools/bin\"\n+#endif\n+\n+/* Under hpux11 the normal location of the various *crt*.o files is the\n+   /usr/ccs/lib directory.  */\n+\n+#ifndef CROSS_COMPILE\n+#undef MD_STARTFILE_PREFIX\n+#define MD_STARTFILE_PREFIX \"/opt/langtools/lib/pa20_64/\"\n+#endif\n+\n+/* hpux11 has the new HP assembler.  It's still lousy, but it's a whole lot\n+   better than the assembler shipped with older versions of hpux.  */\n+#undef NEW_HP_ASSEMBLER\n+#define NEW_HP_ASSEMBLER 1\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE) \\\n+do {  \\\n+     if (TARGET_64BIT) \\\n+       fputs(\"\\t.LEVEL 2.0w\\n\", FILE); \\\n+     else if (TARGET_PA_20) \\\n+       fputs(\"\\t.LEVEL 2.0\\n\", FILE); \\\n+     else if (TARGET_PA_11) \\\n+       fputs(\"\\t.LEVEL 1.1\\n\", FILE); \\\n+     else \\\n+       fputs(\"\\t.LEVEL 1.0\\n\", FILE); \\\n+     if (profile_flag)\\\n+       fprintf (FILE, \"\\t.IMPORT _mcount, CODE\\n\");\\\n+     if (write_symbols != NO_DEBUG) \\\n+       output_file_directive ((FILE), main_input_filename); \\\n+   } while (0)\n+\n+/* It looks like DWARF2 will be the easiest debug format to handle on this\n+   platform.  */\n+#define OBJECT_FORMAT_ELF\n+#define DWARF2_DEBUGGING_INFO\n+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n+/* This isn't quite ready yet.  I'm seeing it mess up some line\n+   tables.  For example, we're getting lines starting/ending at\n+   impossible addresses.  */\n+#define DWARF2_ASM_LINE_DEBUG_INFO 1\n+\n+\n+/* The rest of this file is copied from the generic svr4.h.  One day we\n+   would like to simply include svr4.h instead of copying all these\n+   definitions.  */\n+\n+/* Support const sections and the ctors and dtors sections for g++.\n+   Note that there appears to be two different ways to support const\n+   sections at the moment.  You can either #define the symbol\n+   READONLY_DATA_SECTION (giving it some code which switches to the\n+   readonly data section) or else you can #define the symbols\n+   EXTRA_SECTIONS, EXTRA_SECTION_FUNCTIONS, SELECT_SECTION, and\n+   SELECT_RTX_SECTION.  We do both here just to be on the safe side.  */\n+\n+#define USE_CONST_SECTION\t1\n+\n+#define CONST_SECTION_ASM_OP\t\"\\t.section\\t.rodata\"\n+\n+/* Define the pseudo-ops used to switch to the .ctors and .dtors sections.\n+\n+   Note that we want to give these sections the SHF_WRITE attribute\n+   because these sections will actually contain data (i.e. tables of\n+   addresses of functions in the current root executable or shared library\n+   file) and, in the case of a shared library, the relocatable addresses\n+   will have to be properly resolved/relocated (and then written into) by\n+   the dynamic linker when it actually attaches the given shared library\n+   to the executing process.  (Note that on SVR4, you may wish to use the\n+   `-z text' option to the ELF linker, when building a shared library, as\n+   an additional check that you are doing everything right.  But if you do\n+   use the `-z text' option when building a shared library, you will get\n+   errors unless the .ctors and .dtors sections are marked as writable\n+   via the SHF_WRITE attribute.)  */\n+\n+#define CTORS_SECTION_ASM_OP\t\"\\t.section\\t.ctors,\\\"aw\\\"\"\n+#define DTORS_SECTION_ASM_OP\t\"\\t.section\\t.dtors,\\\"aw\\\"\"\n+\n+/* On svr4, we *do* have support for the .init and .fini sections, and we\n+   can put stuff in there to be executed before and after `main'.  We let\n+   crtstuff.c and other files know this by defining the following symbols.\n+   The definitions say how to change sections to the .init and .fini\n+   sections.  This is the same for all known svr4 assemblers.  */\n+\n+/* ??? For the time being, we aren't using init sections. */\n+#if 0\n+#define INIT_SECTION_ASM_OP\t\"\\t.section\\t.init\"\n+#define FINI_SECTION_ASM_OP\t\"\\t.section\\t.fini\"\n+#endif\n+\n+/* A default list of other sections which we might be \"in\" at any given\n+   time.  For targets that use additional sections (e.g. .tdesc) you\n+   should override this definition in the target-specific file which\n+   includes this file.  */\n+\n+#undef EXTRA_SECTIONS\n+#define EXTRA_SECTIONS in_const, in_ctors, in_dtors\n+\n+/* A default list of extra section function definitions.  For targets\n+   that use additional sections (e.g. .tdesc) you should override this\n+   definition in the target-specific file which includes this file.  */\n+\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n+  CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  DTORS_SECTION_FUNCTION\n+\n+#define READONLY_DATA_SECTION() const_section ()\n+\n+#define CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+const_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (!USE_CONST_SECTION)\t\t\t\t\t\t\\\n+    text_section();\t\t\t\t\t\t\t\\\n+  else if (in_section != in_const)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CONST_SECTION_ASM_OP);\t\t\\\n+      in_section = in_const;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+ctors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_ctors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_ctors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define DTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+dtors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_dtors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_dtors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Switch into a generic section.\n+ \n+   We make the section read-only and executable for a function decl,\n+   read-only for a const data decl, and writable for a non-const data decl.\n+ \n+   If the section has already been defined, we must not\n+   emit the attributes here. The SVR4 assembler does not\n+   recognize section redefinitions.\n+   If DECL is NULL, no attributes are emitted.  */\n+\n+#define ASM_OUTPUT_SECTION_NAME(FILE, DECL, NAME, RELOC)\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      static htab_t htab;                                               \\\n+                                                                        \\\n+      struct section_info                                               \\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tenum sect_enum {SECT_RW, SECT_RO, SECT_EXEC} type;\t\t\\\n+      };                                                                \\\n+                                                                        \\\n+      struct section_info *s;\t\t\t\t\t\t\\\n+      const char *mode;\t\t\t\t\t\t\t\\\n+      enum sect_enum type;                                              \\\n+      PTR* slot;                                                        \\\n+                                                                        \\\n+      /* The names we put in the hashtable will always be the unique    \\\n+\t versions gived to us by the stringtable, so we can just use    \\\n+\t their addresses as the keys.  */                               \\\n+      if (!htab)                                                        \\\n+\thtab = htab_create (31,                                         \\\n+\t\t\t    htab_hash_pointer,                          \\\n+\t\t\t    htab_eq_pointer,                            \\\n+\t\t\t    NULL);                                      \\\n+                                                                        \\\n+      if (DECL && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n+\ttype = SECT_EXEC, mode = \"ax\";\t\t\t\t\t\\\n+      else if (DECL && DECL_READONLY_SECTION (DECL, RELOC))\t\t\\\n+\ttype = SECT_RO, mode = \"a\";\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\ttype = SECT_RW, mode = \"aw\";\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n+                                                                        \\\n+      /* See if we already have an entry for this section.  */          \\\n+      slot = htab_find_slot (htab, NAME, INSERT);                       \\\n+      if (!*slot)                                                       \\\n+\t{                                                               \\\n+\t  s = (struct section_info *) xmalloc (sizeof (* s));\t\t\\\n+\t  s->type = type;\t\t\t\t\t\t\\\n+\t  *slot = s;\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\t.section\\t%s,\\\"%s\\\",@progbits\\n\",\t\t\\\n+\t\t   NAME, mode);\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  s = (struct section_info *) *slot;                            \\\n+\t  if (DECL && s->type != type)\t\t\t\t\t\\\n+\t    error_with_decl (DECL,                                      \\\n+\t\t\t     \"%s causes a section type conflict\");      \\\n+\t  \t\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\t.section\\t%s\\n\", NAME);\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)\n+#define UNIQUE_SECTION_P(DECL) (DECL_ONE_ONLY (DECL))\n+#define UNIQUE_SECTION(DECL,RELOC)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  int len;\t\t\t\t\t\t\t\\\n+  char *name, *string, *prefix;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (DECL));\t\\\n+\t\t\t\t\t\t\t\t\\\n+  if (! DECL_ONE_ONLY (DECL))\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      prefix = \".\";                                             \\\n+      if (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n+\tprefix = \".text.\";\t\t\t\t\t\\\n+      else if (DECL_READONLY_SECTION (DECL, RELOC))\t\t\\\n+\tprefix = \".rodata.\";\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tprefix = \".data.\";\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n+    prefix = \".gnu.linkonce.t.\";\t\t\t\t\\\n+  else if (DECL_READONLY_SECTION (DECL, RELOC))\t\t\t\\\n+    prefix = \".gnu.linkonce.r.\";\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    prefix = \".gnu.linkonce.d.\";\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  len = strlen (name) + strlen (prefix);\t\t\t\\\n+  string = alloca (len + 1);\t\t\t\t\t\\\n+  sprintf (string, \"%s%s\", prefix, name);\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  DECL_SECTION_NAME (DECL) = build_string (len, string);\t\\\n+} while (0)\n+\n+#define INT_ASM_OP \"\\t.dword\\t\"\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global constructors.  */\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    ctors_section ();\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%sP%%\", INT_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global destructors.  */\n+#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)       \t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    dtors_section ();                   \t\t\t\t\\\n+    fprintf (FILE, \"%sP%%\", INT_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);              \t\t\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* ??? For the time being, we aren't using .ctors/.dtors sections. */\n+#undef ASM_OUTPUT_DESTRUCTOR\n+#undef ASM_OUTPUT_CONSTRUCTOR\n+\n+/* Define the strings used for the special svr4 .type and .size directives.\n+   These strings generally do not vary from one system running svr4 to\n+   another, but if a given system (e.g. m88k running svr) needs to use\n+   different pseudo-op names for these, they may be overridden in the\n+   file which includes this one.  */\n+\n+#define TYPE_ASM_OP\t\"\\t.type\\t\"\n+#define SIZE_ASM_OP\t\"\\t.size\\t\"\n+\n+/* This is how we tell the assembler that a symbol is weak.  */\n+\n+#define ASM_WEAKEN_LABEL(FILE,NAME) \\\n+  do { fputs (\"\\t.weak\\t\", FILE); assemble_name (FILE, NAME); \\\n+       fputc ('\\n', FILE); } while (0)\n+\n+/* The following macro defines the format used to output the second\n+   operand of the .type assembler directive.  Different svr4 assemblers\n+   expect various different forms for this operand.  The one given here\n+   is just a default.  You may need to override it in your machine-\n+   specific tm.h file (depending upon the particulars of your assembler).  */\n+\n+#define TYPE_OPERAND_FMT\t\"@%s\"\n+\n+/* Write the extra assembler code needed to declare a function's result.\n+   Most svr4 assemblers don't require any special declaration of the\n+   result value, but there are exceptions.  */\n+\n+#ifndef ASM_DECLARE_RESULT\n+#define ASM_DECLARE_RESULT(FILE, RESULT)\n+#endif"}, {"sha": "e4abfe6a704f161356d86b353eaa2441f4242ad4", "filename": "gcc/config/pa/pa64-linux.h", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e184fc5f6e000def7e85ba9719a8451196730a/gcc%2Fconfig%2Fpa%2Fpa64-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e184fc5f6e000def7e85ba9719a8451196730a/gcc%2Fconfig%2Fpa%2Fpa64-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-linux.h?ref=a7e184fc5f6e000def7e85ba9719a8451196730a", "patch": "@@ -0,0 +1,75 @@\n+/* Definitions for PA_RISC with ELF format on 64-bit Linux\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#undef CPP_SPEC\n+#define CPP_SPEC \"%{fPIC:-D__PIC__ -D__pic__} %{fpic:-D__PIC__ -D__pic__} %{mhppa:-D__hppa__} %{posix:-D_POSIX_SOURCE} -D_PA_RISC2_0 -D__LP64__\"\n+\n+#if 0 /* needs some work :-( */\n+/* If defined, this macro specifies a table of register pairs used to\n+   eliminate unneeded registers that point into the stack frame.  */\n+\n+#define ELIMINABLE_REGS\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\t\t\\\n+  {ARG_POINTER_REGNUM,\t STACK_POINTER_REGNUM},\t\t\t\t\\\n+  {ARG_POINTER_REGNUM,\t FRAME_POINTER_REGNUM},\t\t\t\t\\\n+}\n+\n+/* A C expression that returns non-zero if the compiler is allowed to try to\n+   replace register number FROM with register number TO.  The frame pointer\n+   is automatically handled.  */\n+\n+#define CAN_ELIMINATE(FROM, TO) 1\n+\n+/* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It\n+   specifies the initial difference between the specified pair of\n+   registers.  This macro must be defined if `ELIMINABLE_REGS' is\n+   defined.  */\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      int fsize;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      fsize = compute_frame_size (get_frame_size (), 0);\t\\\n+      if ((TO) == FRAME_POINTER_REGNUM\t\t\t\t\\\n+\t  && (FROM) == ARG_POINTER_REGNUM)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  (OFFSET) = -16;\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      if ((TO) != STACK_POINTER_REGNUM)\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      switch (FROM)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\tcase FRAME_POINTER_REGNUM:\t\t\t\t\\\n+\t  (OFFSET) = - fsize;\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\tcase ARG_POINTER_REGNUM:\t\t\t\t\\\n+\t  (OFFSET) = - fsize - 16;\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\tdefault:\t\t\t\t\t\t\\\n+\t  abort ();\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    } while (0)\n+#endif"}]}