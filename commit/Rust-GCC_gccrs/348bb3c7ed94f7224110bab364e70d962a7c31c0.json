{"sha": "348bb3c7ed94f7224110bab364e70d962a7c31c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ4YmIzYzdlZDk0ZjcyMjQxMTBiYWIzNjRlNzBkOTYyYTdjMzFjMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@casey.cygnus.com", "date": "1999-11-16T00:13:51Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-11-16T00:13:51Z"}, "message": "dwarf2out.c (scope_die_for): Don't rely on the decl_scope_table notion of nesting to find the DIE for a type...\n\n        * dwarf2out.c (scope_die_for): Don't rely on the decl_scope_table\n        notion of nesting to find the DIE for a type or function.\n        DIEs can go in limbo even if we got a context_die.\n        (push_decl_scope): Our context doesn't need to be in decl_scope_table.\n        (gen_struct_or_union_type_die): Don't use TREE_PERMANENT to test\n        for local type.\n        (gen_decl_die): Ignore NAMESPACE_DECLs for now.\n        (gen_type_die): Writing out the context doesn't cause member class\n        template instantiations to be written out as well.\n\nFrom-SVN: r30540", "tree": {"sha": "9aeae364af652309cab1200a2c135753c48d65bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9aeae364af652309cab1200a2c135753c48d65bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/348bb3c7ed94f7224110bab364e70d962a7c31c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/348bb3c7ed94f7224110bab364e70d962a7c31c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/348bb3c7ed94f7224110bab364e70d962a7c31c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/348bb3c7ed94f7224110bab364e70d962a7c31c0/comments", "author": null, "committer": null, "parents": [{"sha": "290ad3550bbd3227775b898477a1a8eae353574a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/290ad3550bbd3227775b898477a1a8eae353574a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/290ad3550bbd3227775b898477a1a8eae353574a"}], "stats": {"total": 119, "additions": 89, "deletions": 30}, "files": [{"sha": "8c4e0ff9f18492ecbad520f2b11abdc45e00f73d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/348bb3c7ed94f7224110bab364e70d962a7c31c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/348bb3c7ed94f7224110bab364e70d962a7c31c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=348bb3c7ed94f7224110bab364e70d962a7c31c0", "patch": "@@ -1,3 +1,15 @@\n+1999-11-15  Jason Merrill  <jason@casey.cygnus.com>\n+\n+\t* dwarf2out.c (scope_die_for): Don't rely on the decl_scope_table\n+\tnotion of nesting to find the DIE for a type or function.\n+\tDIEs can go in limbo even if we got a context_die.\n+\t(push_decl_scope): Our context doesn't need to be in decl_scope_table.\n+\t(gen_struct_or_union_type_die): Don't use TREE_PERMANENT to test\n+\tfor local type.\n+\t(gen_decl_die): Ignore NAMESPACE_DECLs for now.\n+\t(gen_type_die): Writing out the context doesn't cause member class\n+\ttemplate instantiations to be written out as well.\n+\n Mon Nov 15 15:33:18 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* rs6000.h (ASM_OUTPUT_DEF): New.\n@@ -11923,7 +11935,3 @@ Wed May 19 00:34:40 1999  Jeffrey A Law  (law@cygnus.com)\n \tgcc-2.95 branch.\n \n See ChangeLog.1 for earlier changes.\n-\n-Local Variables:\n-add-log-time-format: current-time-string\n-End:"}, {"sha": "3dcdc15739e420b0957b34aa62ecbe37f36adb58", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 77, "deletions": 26, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/348bb3c7ed94f7224110bab364e70d962a7c31c0/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/348bb3c7ed94f7224110bab364e70d962a7c31c0/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=348bb3c7ed94f7224110bab364e70d962a7c31c0", "patch": "@@ -21,6 +21,19 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+/* TODO: Implement .debug_str handling.\n+\t Share .debug_str entries via comdat.\n+         Use compact DIE references; we don't always need a 4-byte reference.\n+\t   (maybe; would it be worth the larger abbrev section?)\n+\t Eliminate duplicates by putting common info in a separate section\n+\t   to be collected by the linker and referring to it with\n+\t   DW_FORM_ref_addr.\n+\t Emit .debug_line header even when there are no functions, since\n+\t   the file numbers are used by .debug_info.  Alternately, leave\n+\t   out locations for types and decls.\n+\t Avoid talking about ctors and op= for PODs.\n+\t Factor out common prologue sequences into multiple CIEs.  */\n+\n /* The first part of this file deals with the DWARF 2 frame unwind\n    information, which is also used by the GCC efficient exception handling\n    mechanism.  The second part, controlled only by an #ifdef\n@@ -7536,20 +7549,17 @@ push_decl_scope (scope)\n   if (decl_scope_depth == 0\n       || containing_scope == NULL_TREE\n       /* Ignore namespaces for the moment.  */\n-      || TREE_CODE (containing_scope) == NAMESPACE_DECL\n-      || containing_scope == decl_scope_table[decl_scope_depth - 1].scope)\n-    decl_scope_table[decl_scope_depth].previous = decl_scope_depth - 1;\n+      || TREE_CODE (containing_scope) == NAMESPACE_DECL)\n+    decl_scope_table[decl_scope_depth].previous = -1;\n   else\n     {\n-      /* We need to search for the containing_scope.  */\n-      for (i = 0; i < decl_scope_depth; i++)\n+      /* We need to search for the containing_scope.  If we don't find it,\n+         that's OK; we stick ourselves at global scope.  */\n+      for (i = decl_scope_depth - 1; i >= 0; --i)\n \tif (decl_scope_table[i].scope == containing_scope)\n \t  break;\n \n-      if (i == decl_scope_depth)\n-\tabort ();\n-      else\n-\tdecl_scope_table[decl_scope_depth].previous = i;\n+      decl_scope_table[decl_scope_depth].previous = i;\n     }\n \n   decl_scope_depth++;\n@@ -7593,8 +7603,46 @@ scope_die_for (t, context_die)\n \n   if (containing_scope == NULL_TREE)\n     scope_die = comp_unit_die;\n+  else if (TYPE_P (containing_scope) || DECL_P (containing_scope))\n+    {\n+      /* For types and decls, we can just look up the appropriate DIE.  But\n+\t first we check to see if we're in the middle of emitting it so we\n+\t know where the new DIE should go.  */\n+\n+      for (i = decl_scope_depth - 1; i >= 0; --i)\n+\tif (decl_scope_table[i].scope == containing_scope)\n+\t  break;\n+\n+      if (i < 0)\n+\t{\n+\t  /* Function-local tags and functions get stuck in limbo\n+\t     until they are fixed up by decls_for_scope.  */\n+\t  if (TREE_CODE (containing_scope) == FUNCTION_DECL\n+\t      && (TREE_CODE (t) == FUNCTION_DECL || is_tagged_type (t)))\n+\t    return NULL;\n+\t    \n+\t  if (! TYPE_P (containing_scope))\n+\t    abort ();\n+\t  if (debug_info_level > DINFO_LEVEL_TERSE\n+\t      && !TREE_ASM_WRITTEN (containing_scope))\n+\t    abort ();\n+\n+\t  /* If none of the current dies are suitable, we get file scope.  */\n+\t  scope_die = comp_unit_die;\n+\t}\n+      else\n+\t{\n+\t  if (TYPE_P (containing_scope))\n+\t    scope_die = lookup_type_die (containing_scope);\n+\t  else\n+\t    scope_die = lookup_decl_die (containing_scope);\n+\t}\n+    }\n   else\n     {\n+      /* Something that we can't just look up the DIE for, such as a\n+         BLOCK.  */\n+\n       for (i = decl_scope_depth - 1, scope_die = context_die;\n \t   i >= 0 && decl_scope_table[i].scope != containing_scope;\n \t   (scope_die = scope_die->die_parent,\n@@ -7620,16 +7668,7 @@ scope_die_for (t, context_die)\n \t}\n \n       if (i < 0)\n-\t{\n-\t  if (TREE_CODE_CLASS (TREE_CODE (containing_scope)) != 't')\n-\t    abort ();\n-\t  if (debug_info_level > DINFO_LEVEL_TERSE\n-\t      && !TREE_ASM_WRITTEN (containing_scope))\n-\t    abort ();\n-\n-\t  /* If none of the current dies are suitable, we get file scope.  */\n-\t  scope_die = comp_unit_die;\n-\t}\n+\tabort ();\n     }\n \n   return scope_die;\n@@ -8217,7 +8256,7 @@ gen_subprogram_die (decl, context_die)\n \t debugger can find it.  For inlines, that is the concrete instance,\n \t so we can use the old DIE here.  For non-inline methods, we want a\n \t specification DIE at toplevel, so we need a new DIE.  For local\n-\t class methods, this does not apply.  */\n+\t class methods, we just use the old DIE.  */\n       if ((DECL_ABSTRACT (decl) || old_die->die_parent == comp_unit_die\n \t   || context_die == NULL)\n \t  && get_AT_unsigned (old_die, DW_AT_decl_file) == file_index\n@@ -8913,7 +8952,7 @@ gen_struct_or_union_type_die (type, context_die)\n       add_AT_flag (type_die, DW_AT_declaration, 1);\n \n       /* We can't do this for function-local types, and we don't need to.  */\n-      if (TREE_PERMANENT (type))\n+      if (! decl_function_context (TYPE_STUB_DECL (type)))\n \tadd_incomplete_type (type);\n     }\n }\n@@ -8979,6 +9018,8 @@ gen_type_die (type, context_die)\n      register tree type;\n      register dw_die_ref context_die;\n {\n+  int need_pop;\n+\n   if (type == NULL_TREE || type == error_mark_node)\n     return;\n \n@@ -9067,29 +9108,35 @@ gen_type_die (type, context_die)\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n       /* If this is a nested type whose containing class hasn't been\n-\t written out yet, writing it out will cover this one, too.  */\n+\t written out yet, writing it out will cover this one, too.\n+         This does not apply to instantiations of member class templates;\n+\t they need to be added to the containing class as they are\n+\t generated.  FIXME: This breaks the idea of combining type decls\n+         from multiple TUs, since we can't predict what set of template\n+         instantiations we'll get.  */\n       if (TYPE_CONTEXT (type)\n \t  && AGGREGATE_TYPE_P (TYPE_CONTEXT (type))\n \t  && ! TREE_ASM_WRITTEN (TYPE_CONTEXT (type)))\n \t{\n \t  gen_type_die (TYPE_CONTEXT (type), context_die);\n \n-\t  if (TREE_ASM_WRITTEN (TYPE_CONTEXT (type)))\n+\t  if (TREE_ASM_WRITTEN (type))\n \t    return;\n \n \t  /* If that failed, attach ourselves to the stub.  */\n \t  push_decl_scope (TYPE_CONTEXT (type));\n \t  context_die = lookup_type_die (TYPE_CONTEXT (type));\n+\t  need_pop = 1;\n \t}\n+      else\n+\tneed_pop = 0;\n \n       if (TREE_CODE (type) == ENUMERAL_TYPE)\n \tgen_enumeration_type_die (type, context_die);\n       else\n \tgen_struct_or_union_type_die (type, context_die);\n \n-      if (TYPE_CONTEXT (type)\n-\t  && AGGREGATE_TYPE_P (TYPE_CONTEXT (type))\n-\t  && ! TREE_ASM_WRITTEN (TYPE_CONTEXT (type)))\n+      if (need_pop)\n \tpop_decl_scope ();\n \n       /* Don't set TREE_ASM_WRITTEN on an incomplete struct; we want to fix\n@@ -9444,6 +9491,10 @@ gen_decl_die (decl, context_die)\n       gen_formal_parameter_die (decl, context_die);\n       break;\n \n+    case NAMESPACE_DECL:\n+      /* Ignore for now.  */\n+      break;\n+\n     default:\n       abort ();\n     }"}]}