{"sha": "0ed5edac59d8ee8ad66e9a92763257895008eb8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVkNWVkYWM1OWQ4ZWU4YWQ2NmU5YTkyNzYzMjU3ODk1MDA4ZWI4Yw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2006-03-21T03:19:06Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2006-03-21T03:19:06Z"}, "message": "re PR c++/21764 (visibility attributes on namespace scope)\n\n        PR c++/21764\n        * c-pragma.c (visstack): Move out of handle_pragma_visibility.\n        (push_visibility, pop_visibility): Likewise.\n        * c-pragma.h: Declare them.\n        * cp/name-lookup.h (struct cp_binding_level): Add has_visibility\n        bitfield.\n        * cp/name-lookup.c: Include c-pragma.h.\n        (push_namespace_with_attribs): Split out from push_namespace.\n        Push visibility if appropriate.  Set TREE_PUBLIC on namespaces.\n        (leave_scope): Pop visibility if appropriate.\n        * cp/parser.c (cp_parser_declaration, cp_parser_namespace_name): Allow\n        attributes on namespace declarations.\n\n        PR c++/19238\n        * cp/decl.c (cp_finish_decl): Call determine_visibility later.\n        (start_preparsed_function): Likewise.\n        * cp/cp-tree.h (CP_TYPE_CONTEXT, TYPE_NAMESPACE_SCOPE_P): New macros.\n        (TYPE_CLASS_SCOPE_P, TYPE_FUNCTION_SCOPE_P): New macros.\n        * cp/decl2.c (determine_visibility_from_class): Split out from...\n        (determine_visibility): ...here.  Handle function scope and\n        nested classes.\n        (import_export_decl): Move visibility handling to\n        determine_visibility_from_class.\n\nFrom-SVN: r112239", "tree": {"sha": "6e55c5f98ba55a6fcaf4861b4df4e8d7233c36ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e55c5f98ba55a6fcaf4861b4df4e8d7233c36ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ed5edac59d8ee8ad66e9a92763257895008eb8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ed5edac59d8ee8ad66e9a92763257895008eb8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ed5edac59d8ee8ad66e9a92763257895008eb8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ed5edac59d8ee8ad66e9a92763257895008eb8c/comments", "author": null, "committer": null, "parents": [{"sha": "29c14e849ec20e0e16fcd9822f50fa831204af60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29c14e849ec20e0e16fcd9822f50fa831204af60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29c14e849ec20e0e16fcd9822f50fa831204af60"}], "stats": {"total": 367, "additions": 282, "deletions": 85}, "files": [{"sha": "fb19e1f51eb3b3df94f60986f4e4c851ee95886c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ed5edac59d8ee8ad66e9a92763257895008eb8c", "patch": "@@ -1,3 +1,10 @@\n+2006-03-20  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/21764\n+\t* c-pragma.c (visstack): Move out of handle_pragma_visibility.\n+\t(push_visibility, pop_visibility): Likewise.\n+\t* c-pragma.h: Declare them.\n+\n 2006-03-20  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/sh.c (untangle_mova): Initialize n_addr and n_target."}, {"sha": "b62352c2e6b0be985d3a21650d3e8e536d6bb3c9", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 37, "deletions": 30, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=0ed5edac59d8ee8ad66e9a92763257895008eb8c", "patch": "@@ -593,17 +593,49 @@ static void handle_pragma_visibility (cpp_reader *);\n typedef enum symbol_visibility visibility;\n DEF_VEC_I (visibility);\n DEF_VEC_ALLOC_I (visibility, heap);\n+static VEC (visibility, heap) *visstack;\n+\n+/* Push the visibility indicated by STR onto the top of the #pragma\n+   visibility stack.  */\n+\n+void\n+push_visibility (const char *str)\n+{\n+  VEC_safe_push (visibility, heap, visstack,\n+\t\t default_visibility);\n+  if (!strcmp (str, \"default\"))\n+    default_visibility = VISIBILITY_DEFAULT;\n+  else if (!strcmp (str, \"internal\"))\n+    default_visibility = VISIBILITY_INTERNAL;\n+  else if (!strcmp (str, \"hidden\"))\n+    default_visibility = VISIBILITY_HIDDEN;  \n+  else if (!strcmp (str, \"protected\"))\n+    default_visibility = VISIBILITY_PROTECTED;\n+  else\n+    GCC_BAD (\"#pragma GCC visibility push() must specify default, internal, hidden or protected\");\n+  visibility_options.inpragma = 1;\n+}\n+\n+/* Pop a level of the #pragma visibility stack.  */\n+\n+void\n+pop_visibility (void)\n+{\n+  default_visibility = VEC_pop (visibility, visstack);\n+  visibility_options.inpragma\n+    = VEC_length (visibility, visstack) != 0;\n+}  \n \n /* Sets the default visibility for symbols to something other than that\n    specified on the command line.  */\n+\n static void\n handle_pragma_visibility (cpp_reader *dummy ATTRIBUTE_UNUSED)\n {\n   /* Form is #pragma GCC visibility push(hidden)|pop */\n   tree x;\n   enum cpp_ttype token;\n   enum { bad, push, pop } action = bad;\n-  static VEC (visibility, heap) *visstack;\n  \n   token = pragma_lex (&x);\n   if (token == CPP_NAME)\n@@ -621,44 +653,19 @@ handle_pragma_visibility (cpp_reader *dummy ATTRIBUTE_UNUSED)\n       if (pop == action)\n         {\n           if (!VEC_length (visibility, visstack))\n-            {\n-              GCC_BAD (\"no matching push for %<#pragma GCC visibility pop%>\");\n-            }\n+\t    GCC_BAD (\"no matching push for %<#pragma GCC visibility pop%>\");\n           else\n-            {\n-\t      default_visibility = VEC_pop (visibility, visstack);\n-\t      visibility_options.inpragma\n-\t\t= VEC_length (visibility, visstack) != 0;\n-            }\n+\t    pop_visibility ();\n         }\n       else\n         {\n           if (pragma_lex (&x) != CPP_OPEN_PAREN)\n             GCC_BAD (\"missing %<(%> after %<#pragma GCC visibility push%> - ignored\");\n           token = pragma_lex (&x);\n           if (token != CPP_NAME)\n-            {\n-              GCC_BAD (\"malformed #pragma GCC visibility push\");\n-            }\n+\t    GCC_BAD (\"malformed #pragma GCC visibility push\");\n           else\n-            {\n-              const char *str = IDENTIFIER_POINTER (x);\n-\t      VEC_safe_push (visibility, heap, visstack,\n-\t\t\t     default_visibility);\n-              if (!strcmp (str, \"default\"))\n-                default_visibility = VISIBILITY_DEFAULT;\n-              else if (!strcmp (str, \"internal\"))\n-                default_visibility = VISIBILITY_INTERNAL;\n-              else if (!strcmp (str, \"hidden\"))\n-                default_visibility = VISIBILITY_HIDDEN;  \n-              else if (!strcmp (str, \"protected\"))\n-                default_visibility = VISIBILITY_PROTECTED;\n-              else\n-                {\n-                  GCC_BAD (\"#pragma GCC visibility push() must specify default, internal, hidden or protected\");\n-                }\n-              visibility_options.inpragma = 1;\n-            }\n+\t    push_visibility (IDENTIFIER_POINTER (x));\n           if (pragma_lex (&x) != CPP_CLOSE_PAREN)\n             GCC_BAD (\"missing %<(%> after %<#pragma GCC visibility push%> - ignored\");\n         }"}, {"sha": "6ebb08b685c0784ca351f90fa5682a3e5e13f582", "filename": "gcc/c-pragma.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.h?ref=0ed5edac59d8ee8ad66e9a92763257895008eb8c", "patch": "@@ -75,6 +75,8 @@ extern struct cpp_reader* parse_in;\n    visibility is not supported on the host OS platform the\n    statements are ignored.  */\n #define HANDLE_PRAGMA_VISIBILITY 1\n+extern void push_visibility (const char *);\n+extern void pop_visibility (void);\n \n extern void init_pragma (void);\n "}, {"sha": "983165551be168c5c15c9149fff3f5624468992b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0ed5edac59d8ee8ad66e9a92763257895008eb8c", "patch": "@@ -1,7 +1,28 @@\n+2006-03-20  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/21764, c++/19238\n+\t* decl.c (cp_finish_decl): Call determine_visibility later.\n+\t(start_preparsed_function): Likewise.\n+\t* cp-tree.h (CP_TYPE_CONTEXT, TYPE_NAMESPACE_SCOPE_P): New macros.\n+\t(TYPE_CLASS_SCOPE_P, TYPE_FUNCTION_SCOPE_P): New macros.\n+\t* name-lookup.h (struct cp_binding_level): Add has_visibility \n+\tbitfield.\n+\t* name-lookup.c: Include c-pragma.h.\n+\t(push_namespace_with_attribs): Split out from push_namespace.\n+\tPush visibility if appropriate.  Set TREE_PUBLIC on namespaces.\n+\t(leave_scope): Pop visibility if appropriate.\n+\t* decl2.c (determine_visibility_from_class): Split out from...\n+\t(determine_visibility): ...here.  Handle function scope and \n+\tnested classes.\n+\t(import_export_decl): Move visibility handling to \n+\tdetermine_visibility_from_class.\n+\t* parser.c (cp_parser_declaration, cp_parser_namespace_name): Allow\n+\tattributes on namespace declarations.\n+\n 2006-03-15  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/6634\n-\tdecl.c (grokdeclarator): Do not accept long long double.\n+\t* decl.c (grokdeclarator): Do not accept long long double.\n \tReorganize checks for invalid (combinations of) type modifiers.\n \tQuote modifiers in messages.\n "}, {"sha": "4b155735427598ecbca14e627c1bd692b22b14a7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0ed5edac59d8ee8ad66e9a92763257895008eb8c", "patch": "@@ -1964,22 +1964,34 @@ struct lang_decl GTY(())\n /* NULL_TREE in DECL_CONTEXT represents the global namespace.  */\n #define CP_DECL_CONTEXT(NODE) \\\n   (DECL_CONTEXT (NODE) ? DECL_CONTEXT (NODE) : global_namespace)\n+#define CP_TYPE_CONTEXT(NODE) \\\n+  (TYPE_CONTEXT (NODE) ? TYPE_CONTEXT (NODE) : global_namespace)\n #define FROB_CONTEXT(NODE)   ((NODE) == global_namespace ? NULL_TREE : (NODE))\n \n /* 1 iff NODE has namespace scope, including the global namespace.  */\n #define DECL_NAMESPACE_SCOPE_P(NODE)\t\t\t\t\\\n   (!DECL_TEMPLATE_PARM_P (NODE)\t\t\t\t\t\\\n    && TREE_CODE (CP_DECL_CONTEXT (NODE)) == NAMESPACE_DECL)\n \n+#define TYPE_NAMESPACE_SCOPE_P(NODE)\t\t\t\t\\\n+  (TREE_CODE (CP_TYPE_CONTEXT (NODE)) == NAMESPACE_DECL)\n+\n /* 1 iff NODE is a class member.  */\n #define DECL_CLASS_SCOPE_P(NODE) \\\n   (DECL_CONTEXT (NODE) && TYPE_P (DECL_CONTEXT (NODE)))\n \n+#define TYPE_CLASS_SCOPE_P(NODE) \\\n+  (TYPE_CONTEXT (NODE) && TYPE_P (TYPE_CONTEXT (NODE)))\n+\n /* 1 iff NODE is function-local.  */\n #define DECL_FUNCTION_SCOPE_P(NODE) \\\n   (DECL_CONTEXT (NODE) \\\n    && TREE_CODE (DECL_CONTEXT (NODE)) == FUNCTION_DECL)\n \n+#define TYPE_FUNCTION_SCOPE_P(NODE) \\\n+  (TYPE_CONTEXT (NODE) \\\n+   && TREE_CODE (TYPE_CONTEXT (NODE)) == FUNCTION_DECL)\n+\n /* 1 iff VAR_DECL node NODE is a type-info decl.  This flag is set for\n    both the primary typeinfo object and the associated NTBS name.  */\n #define DECL_TINFO_P(NODE) TREE_LANG_FLAG_4 (VAR_DECL_CHECK (NODE))"}, {"sha": "45feb9f0c589ced38afd134141a613bd6892e13a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0ed5edac59d8ee8ad66e9a92763257895008eb8c", "patch": "@@ -5178,9 +5178,6 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t     the class specifier.  */\n \t  if (!DECL_EXTERNAL (decl))\n \t    var_definition_p = true;\n-\t  /* The variable is being defined, so determine its\n-\t     visibility.  */\n-\t  determine_visibility (decl);\n \t}\n       /* If the variable has an array type, lay out the type, even if\n \t there is no initializer.  It is valid to index through the\n@@ -5244,6 +5241,10 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t\tinitialize_local_var (decl, init);\n \t    }\n \n+\t  /* The variable is being defined, so determine its visibility.\n+\t     This needs to happen after the linkage is set. */\n+\t  determine_visibility (decl);\n+\n \t  /* If a variable is defined, and then a subsequent\n \t     definition with external linkage is encountered, we will\n \t     get here twice for the same variable.  We want to avoid\n@@ -10422,12 +10423,6 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \tmaybe_apply_pragma_weak (decl1);\n     }\n \n-  /* Determine the ELF visibility attribute for the function.  We must\n-     not do this before calling \"pushdecl\", as we must allow\n-     \"duplicate_decls\" to merge any attributes appropriately.  */\n-  if (!DECL_CLONED_FUNCTION_P (decl1))\n-    determine_visibility (decl1);\n-\n   /* Reset these in case the call to pushdecl changed them.  */\n   current_function_decl = decl1;\n   cfun->decl = decl1;\n@@ -10546,6 +10541,13 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \tDECL_INTERFACE_KNOWN (decl1) = 1;\n     }\n \n+  /* Determine the ELF visibility attribute for the function.  We must not\n+     do this before calling \"pushdecl\", as we must allow \"duplicate_decls\"\n+     to merge any attributes appropriately.  We also need to wait until\n+     linkage is set.  */\n+  if (!DECL_CLONED_FUNCTION_P (decl1))\n+    determine_visibility (decl1);\n+\n   begin_scope (sk_function_parms, decl1);\n \n   ++function_depth;"}, {"sha": "88d7e8e95f347b2b3f22527b87791c98f0c9a096", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 77, "deletions": 40, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=0ed5edac59d8ee8ad66e9a92763257895008eb8c", "patch": "@@ -82,6 +82,7 @@ static tree prune_vars_needing_no_initialization (tree *);\n static void write_out_vars (tree);\n static void import_export_class (tree);\n static tree get_guard_bits (tree);\n+static void determine_visibility_from_class (tree, tree);\n \n /* A list of static class variables.  This is needed, because a\n    static class variable can be declared inside the class without\n@@ -1566,13 +1567,27 @@ maybe_emit_vtables (tree ctype)\n }\n \n /* Like c_determine_visibility, but with additional C++-specific\n-   behavior.  */\n+   behavior.\n+\n+   Function-scope entities can rely on the function's visibility because\n+   it is set in start_preparsed_function.\n+\n+   Class-scope entities cannot rely on the class's visibility until the end\n+   of the enclosing class definition.\n+\n+   Note that because namespaces have multiple independent definitions,\n+   namespace visibility is handled elsewhere using the #pragma visibility\n+   machinery rather than by decorating the namespace declaration.  */\n \n void\n determine_visibility (tree decl)\n {\n   tree class_type;\n \n+  /* Only relevant for names with external linkage.  */\n+  if (!TREE_PUBLIC (decl))\n+    return;\n+\n   /* Cloned constructors and destructors get the same visibility as\n      the underlying function.  That should be set up in\n      maybe_clone_body.  */\n@@ -1596,6 +1611,14 @@ determine_visibility (tree decl)\n \t so they are automatically handled above.  */\n       gcc_assert (TREE_CODE (decl) != VAR_DECL\n \t\t  || !DECL_VTABLE_OR_VTT_P (decl));\n+\n+      if (DECL_FUNCTION_SCOPE_P (decl))\n+\t{\n+\t  tree fn = DECL_CONTEXT (decl);\n+\t  DECL_VISIBILITY (decl) = DECL_VISIBILITY (fn);\n+\t  DECL_VISIBILITY_SPECIFIED (decl) = DECL_VISIBILITY_SPECIFIED (fn);\n+\t}\n+\n       /* Entities not associated with any class just get the\n \t visibility specified by their attributes.  */\n       return;\n@@ -1605,33 +1628,62 @@ determine_visibility (tree decl)\n      the visibility of their containing class.  */\n   if (class_type)\n     {\n-      if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-\t  && lookup_attribute (\"dllexport\", TYPE_ATTRIBUTES (class_type)))\n-\t{\n-\t  DECL_VISIBILITY (decl) = VISIBILITY_DEFAULT;\n-\t  DECL_VISIBILITY_SPECIFIED (decl) = 1;\n-\t}\n-      else if (TREE_CODE (decl) == FUNCTION_DECL\n-\t       && DECL_DECLARED_INLINE_P (decl)\n-\t       && visibility_options.inlines_hidden)\n-\t{\n-\t  /* Don't change it if it has been set explicitly by user.  */\n-\t  if (!DECL_VISIBILITY_SPECIFIED (decl))\n-\t    {\n-\t      DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;\n-\t      DECL_VISIBILITY_SPECIFIED (decl) = 1;\n-\t    }\n-\t}\n-      else if (CLASSTYPE_VISIBILITY_SPECIFIED (class_type))\n+      determine_visibility_from_class (decl, class_type);\n+\n+      /* Give the target a chance to override the visibility associated\n+\t with DECL.  */\n+      if (TREE_CODE (decl) == VAR_DECL\n+\t  && (DECL_TINFO_P (decl)\n+\t      || (DECL_VTABLE_OR_VTT_P (decl)\n+\t\t  /* Construction virtual tables are not exported because\n+\t\t     they cannot be referred to from other object files;\n+\t\t     their name is not standardized by the ABI.  */\n+\t\t  && !DECL_CONSTRUCTION_VTABLE_P (decl)))\n+\t  && TREE_PUBLIC (decl)\n+\t  && !DECL_REALLY_EXTERN (decl)\n+\t  && DECL_VISIBILITY_SPECIFIED (decl)\n+\t  && (!class_type || !CLASSTYPE_VISIBILITY_SPECIFIED (class_type)))\n+\ttargetm.cxx.determine_class_data_visibility (decl);\n+    }      \n+}\n+\n+static void\n+determine_visibility_from_class (tree decl, tree class_type)\n+{\n+  if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n+      && lookup_attribute (\"dllexport\", TYPE_ATTRIBUTES (class_type)))\n+    {\n+      DECL_VISIBILITY (decl) = VISIBILITY_DEFAULT;\n+      DECL_VISIBILITY_SPECIFIED (decl) = 1;\n+    }\n+  else if (TREE_CODE (decl) == FUNCTION_DECL\n+\t   && DECL_DECLARED_INLINE_P (decl)\n+\t   && visibility_options.inlines_hidden)\n+    {\n+      /* Don't change it if it has been set explicitly by user.  */\n+      if (!DECL_VISIBILITY_SPECIFIED (decl))\n \t{\n-\t  DECL_VISIBILITY (decl) = CLASSTYPE_VISIBILITY (class_type);\n+\t  DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;\n \t  DECL_VISIBILITY_SPECIFIED (decl) = 1;\n \t}\n-      else if (!DECL_VISIBILITY_SPECIFIED (decl))\n-\t{\n-\t  DECL_VISIBILITY (decl) = CLASSTYPE_VISIBILITY (class_type);\n-\t  DECL_VISIBILITY_SPECIFIED (decl) = 0;\n-\t}\n+    }\n+  else if (CLASSTYPE_VISIBILITY_SPECIFIED (class_type))\n+    {\n+      DECL_VISIBILITY (decl) = CLASSTYPE_VISIBILITY (class_type);\n+      DECL_VISIBILITY_SPECIFIED (decl) = 1;\n+    }\n+  else if (TYPE_CLASS_SCOPE_P (class_type))\n+    determine_visibility_from_class (decl, TYPE_CONTEXT (class_type));\n+  else if (TYPE_FUNCTION_SCOPE_P (class_type))\n+    {\n+      tree fn = TYPE_CONTEXT (class_type);\n+      DECL_VISIBILITY (decl) = DECL_VISIBILITY (fn);\n+      DECL_VISIBILITY_SPECIFIED (decl) = DECL_VISIBILITY_SPECIFIED (fn);\n+    }\n+  else if (!DECL_VISIBILITY_SPECIFIED (decl))\n+    {\n+      DECL_VISIBILITY (decl) = CLASSTYPE_VISIBILITY (class_type);\n+      DECL_VISIBILITY_SPECIFIED (decl) = 0;\n     }\n }\n \n@@ -1905,21 +1957,6 @@ import_export_decl (tree decl)\n       comdat_linkage (decl);\n     }\n \n-  /* Give the target a chance to override the visibility associated\n-     with DECL.  */\n-  if (TREE_CODE (decl) == VAR_DECL\n-      && (DECL_TINFO_P (decl)\n-\t  || (DECL_VTABLE_OR_VTT_P (decl)\n-\t      /* Construction virtual tables are not exported because\n-\t\t they cannot be referred to from other object files;\n-\t\t their name is not standardized by the ABI.  */\n-\t      && !DECL_CONSTRUCTION_VTABLE_P (decl)))\n-      && TREE_PUBLIC (decl)\n-      && !DECL_REALLY_EXTERN (decl)\n-      && DECL_VISIBILITY_SPECIFIED (decl)\n-      && (!class_type || !CLASSTYPE_VISIBILITY_SPECIFIED (class_type)))\n-    targetm.cxx.determine_class_data_visibility (decl);\n-\n   DECL_INTERFACE_KNOWN (decl) = 1;\n }\n "}, {"sha": "9b10fb4a9d7c1e03a91b238a428d50e5b2fef5b7", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=0ed5edac59d8ee8ad66e9a92763257895008eb8c", "patch": "@@ -31,6 +31,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"toplev.h\"\n #include \"diagnostic.h\"\n #include \"debug.h\"\n+#include \"c-pragma.h\"\n \n /* The bindings for a particular name in a particular scope.  */\n \n@@ -1330,11 +1331,16 @@ leave_scope (void)\n       is_class_level = 0;\n     }\n \n+#ifdef HANDLE_PRAGMA_VISIBILITY\n+  if (scope->has_visibility)\n+    pop_visibility ();\n+#endif\n+\n   /* Move one nesting level up.  */\n   current_binding_level = scope->level_chain;\n \n   /* Namespace-scopes are left most probably temporarily, not\n-     completely; they can be reopen later, e.g. in namespace-extension\n+     completely; they can be reopened later, e.g. in namespace-extension\n      or any name binding activity that requires us to resume a\n      namespace.  For classes, we cache some binding levels.  For other\n      scopes, we just make the structure available for reuse.  */\n@@ -2957,6 +2963,15 @@ current_decl_namespace (void)\n \n void\n push_namespace (tree name)\n+{\n+  push_namespace_with_attribs (name, NULL_TREE);\n+}\n+\n+/* Same, but specify attributes to apply to the namespace.  The attributes\n+   only apply to the current namespace-body, not to any later extensions. */\n+\n+void\n+push_namespace_with_attribs (tree name, tree attributes)\n {\n   tree d = NULL_TREE;\n   int need_new = 1;\n@@ -3004,6 +3019,7 @@ push_namespace (tree name)\n       /* Make a new namespace, binding the name to it.  */\n       d = build_lang_decl (NAMESPACE_DECL, name, void_type_node);\n       DECL_CONTEXT (d) = FROB_CONTEXT (current_namespace);\n+      TREE_PUBLIC (d) = 1;\n       pushdecl (d);\n       if (anon)\n \t{\n@@ -3021,6 +3037,36 @@ push_namespace (tree name)\n   /* Enter the name space.  */\n   current_namespace = d;\n \n+#ifdef HANDLE_PRAGMA_VISIBILITY\n+  /* Clear has_visibility in case a previous namespace-definition had a\n+     visibility attribute and this one doesn't.  */\n+  current_binding_level->has_visibility = 0;\n+  for (d = attributes; d; d = TREE_CHAIN (d))\n+    {\n+      tree name = TREE_PURPOSE (d);\n+      tree args = TREE_VALUE (d);\n+      tree x;\n+      \n+      if (! is_attribute_p (\"visibility\", name))\n+\t{\n+\t  warning (OPT_Wattributes, \"%qs attribute directive ignored\",\n+\t\t   IDENTIFIER_POINTER (name));\n+\t  continue;\n+\t}\n+\n+      x = args ? TREE_VALUE (args) : NULL_TREE;\n+      if (x == NULL_TREE || TREE_CODE (x) != STRING_CST)\n+\t{\n+\t  warning (OPT_Wattributes, \"%qs attribute requires an NTBS argument\",\n+\t\t   IDENTIFIER_POINTER (name));\n+\t  continue;\n+\t}\n+\n+      current_binding_level->has_visibility = 1;\n+      push_visibility (TREE_STRING_POINTER (x));\n+    }\n+#endif\n+\n   timevar_pop (TV_NAME_LOOKUP);\n }\n "}, {"sha": "ede7747d00df07da42a029d1d1df7abcfb61b501", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=0ed5edac59d8ee8ad66e9a92763257895008eb8c", "patch": "@@ -259,7 +259,11 @@ struct cp_binding_level GTY(())\n     unsigned more_cleanups_ok : 1;\n     unsigned have_cleanups : 1;\n \n-    /* 22 bits left to fill a 32-bit word.  */\n+    /* Nonzero if this level has associated visibility which we should pop\n+       when leaving the scope. */\n+    unsigned has_visibility : 1;\n+\n+    /* 23 bits left to fill a 32-bit word.  */\n   };\n \n /* The binding level currently in effect.  */\n@@ -307,6 +311,7 @@ extern void pop_inner_scope (tree, tree);\n extern void push_binding_level (struct cp_binding_level *);\n \f\n extern void push_namespace (tree);\n+extern void push_namespace_with_attribs (tree, tree);\n extern void pop_namespace (void);\n extern void push_nested_namespace (tree);\n extern void pop_nested_namespace (tree);"}, {"sha": "e04a8e7f0d6cce66afb32f711e0b9c49834b37fe", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0ed5edac59d8ee8ad66e9a92763257895008eb8c", "patch": "@@ -7064,7 +7064,7 @@ cp_parser_declaration (cp_parser* parser)\n \t   && (/* A named namespace definition.  */\n \t       (token2.type == CPP_NAME\n \t\t&& (cp_lexer_peek_nth_token (parser->lexer, 3)->type\n-\t\t    == CPP_OPEN_BRACE))\n+\t\t    != CPP_EQ))\n \t       /* An unnamed namespace definition.  */\n \t       || token2.type == CPP_OPEN_BRACE))\n     cp_parser_namespace_definition (parser);\n@@ -10470,7 +10470,7 @@ cp_parser_namespace_name (cp_parser* parser)\n static void\n cp_parser_namespace_definition (cp_parser* parser)\n {\n-  tree identifier;\n+  tree identifier, attribs;\n \n   /* Look for the `namespace' keyword.  */\n   cp_parser_require_keyword (parser, RID_NAMESPACE, \"`namespace'\");\n@@ -10484,10 +10484,13 @@ cp_parser_namespace_definition (cp_parser* parser)\n   else\n     identifier = NULL_TREE;\n \n+  /* Parse any specified attributes.  */\n+  attribs = cp_parser_attributes_opt (parser);\n+\n   /* Look for the `{' to start the namespace.  */\n   cp_parser_require (parser, CPP_OPEN_BRACE, \"`{'\");\n   /* Start the namespace.  */\n-  push_namespace (identifier);\n+  push_namespace_with_attribs (identifier, attribs);\n   /* Parse the body of the namespace.  */\n   cp_parser_namespace_body (parser);\n   /* Finish the namespace.  */"}, {"sha": "4871009ded20b1ec6bba36107debfff95f94fc45", "filename": "gcc/testsuite/g++.dg/ext/visibility/local1.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Flocal1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Flocal1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Flocal1.C?ref=0ed5edac59d8ee8ad66e9a92763257895008eb8c", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/19238\n+// Test that hidden visibility on an inline function is inherited by static\n+// local variables and local classes.\n+\n+// { dg-do compile { target i?86-*-linux* x86_64-*-linux* powerpc*-*-linux* } }\n+// { dg-final { scan-assembler \"hidden\\[ \\t\\]*_Z1fv\" } }\n+// { dg-final { scan-assembler \"hidden\\[ \\t\\]*_ZZ1fvE1i\" } }\n+// { dg-final { scan-assembler \"hidden\\[ \\t\\]*_ZZ1fvEN1A1fEv\" } }\n+\n+__attribute ((visibility (\"hidden\"))) inline int\n+f()\n+{\n+  static int i = 2;\n+  struct A\n+  {\n+    void f () { }\n+  } a;\n+  a.f();\n+  return i;\n+}\n+\n+int main()\n+{\n+  f();\n+}"}, {"sha": "903a1f2524c286f88dd25ab705cf0fa5628f93eb", "filename": "gcc/testsuite/g++.dg/ext/visibility/namespace1.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fnamespace1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ed5edac59d8ee8ad66e9a92763257895008eb8c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fnamespace1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fnamespace1.C?ref=0ed5edac59d8ee8ad66e9a92763257895008eb8c", "patch": "@@ -0,0 +1,30 @@\n+// PR c++/21764\n+// Test for namespace visibility attribute semantics.\n+\n+// { dg-do compile { target i?86-*-linux* x86_64-*-linux* powerpc*-*-linux* } }\n+// { dg-final { scan-assembler \"hidden\\[ \\t\\]*_ZN3foo1fEv\" } }\n+// { dg-final { scan-assembler \"hidden\\[ \\t\\]*_ZN3foo1gEv\" } }\n+// { dg-final { scan-assembler \"hidden\\[ \\t\\]*_ZN3foo1A1mEv\" } }\n+// { dg-final { scan-assembler \"hidden\\[ \\t\\]*_ZN3foo1tIiEEvv\" } }\n+// { dg-final { scan-assembler-not \"hidden\\[ \\t\\]*_ZN3foo1hEv\" } }\n+\n+namespace foo __attribute ((visibility (\"hidden\")))\n+{\n+  int f() { }\n+  void g();\n+  template <typename T> void t() { }\n+  class A\n+  {\n+    void m ();\n+  };\n+}\n+\n+namespace foo\n+{\n+  void h() {}\n+}\n+\n+void foo::g() { t<int> (); }\n+\n+void foo::A::m() { }\n+"}]}