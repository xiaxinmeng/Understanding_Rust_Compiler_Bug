{"sha": "8dc63166e0b859546ba53093c5fc6c09925210dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRjNjMxNjZlMGI4NTk1NDZiYTUzMDkzYzVmYzZjMDk5MjUyMTBkZA==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2019-07-23T21:43:21Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2019-07-23T21:43:21Z"}, "message": "arith.c (gfc_convert_integer, [...]): Move to ...\n\n2019-07-23  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\t* arith.c (gfc_convert_integer, gfc_convert_real, gfc_convert_complex):\n\tMove to ...\n\t* primary.c (convert_integer, convert_real, convert_complex): ... here.\n\tRename and make static functions.\n\t(match_integer_constant): Use convert_integer\n\t(match_real_constant): Use convert_real.\n\t(match_complex_constant: Use convert_complex.\n\t* arith.h (gfc_convert_integer, gfc_convert_real, gfc_convert_complex):\n\tRemove prototypes.\n\t* array.c (match_array_cons_element): A BOZ cannot be a data \n\tstatement value.  Jump to a common exit point.\n\t* check.c (gfc_invalid_boz): New function.  Emit error or warning\n\tfor a BOZ in an invalid context.\n\t(boz_args_check): Move to top of file to prevent need of forward\n\tdeclaration.\n\t(is_boz_constant): New function.  Check that BOZ expr is constant.\n\t(gfc_b\tz2real): New function. In-place conversion of BOZ literal\n\tconstant to REAL in accordance to F2018.\n\t(gfc_boz2int): New function. In-place conversion of BOZ literal\n \tonstant to INTEGER in accordance to F2018.\n\t(gfc_check_achar, gfc_check_char, gfc_check_float): Use gfc_invalid_boz.\n\tConvert BOZ as needed.\n\t(gfc_check_bge_bgt_ble_blt): Enforce F2018 requirements on BGE, \n\tBGT, BLE, and BLT intrinsic functions.\n\t(gfc_check_cmplx): Re-organize to check kind, if present, first.\n\tConvert BOZ real and/or imaginary parts as needed in accordance to\n\tF2018.\n\t(gfc_check_complex):  Use gfc_invalid_boz.  Convert BOZ as needed.\n\t(gfc_check_dcmplx, gfc_check_dble ): Convert BOZ as needed.\n\t(gfc_check_dshift):  Make dshift[lr] conform to F2018 standard.\n\t gfc_check_float (gfc_expr *a)\n\t(gfc_check_iand_ieor_ior):  Make IAND, IEOR, and IOR conform to \n\tF2018 standard.\n\t(gfc_check_int): Conform to F2018 standard.\n\t(gfc_check_intconv): Deprecate SHORT and LONG aliases for INT2 and\n\tINT.  Simply return for a BOZ argument. See gfc_simplify_intconv.\n\t(gfc_check_merge_bits): Make MERGE_BITS conform to Fortran 2018\n\tstandard.\n\t(gfc_check_real): Remove incorrect comment. Check kind, if present,\n\tfirst.  Simply return for a BOZ argument. See gfc_simplify_real.\n\t(gfc_check_and): Re-do error handling for BOZ arguments.  Remove\n\tspecial casing ts.type != BT_INTEGER or BT_LOGICAL.\n\t* decl.c (match_old_style_init): Check for BOZ in old-style\n\tinitialization.  Issue error or warning depending on\n\t-fallow-invalid-boz option.  Issue error if variable is not an\n\tINTEGER or REAL and the value is BOZ.\n\t* expr.c (gfc_copy_expr): Copy a BT_BOZ gfc_expr.\n\t(gfc_check_assign): Re-do error handling for a BOZ in an assignment\n\tstatement.  Do in-place conversion of RHS based on LHS type of\n\tINTEGER or REAL.\n\t* gfortran.h (gfc_expr): Add a boz component.  Remove is_boz component.\n\t(gfc_boz2int, gfc_boz2real, gfc_invalid_boz): New prototypes.\n\t* interface.c (gfc_extend_assign): Guard against replacing an \n\tintrinsic involving a BOZ literal constant on RHS.\n\t* invoke.texi: Doument -fallow-invalid-boz.\n\t* lang.opt: New option. -fallow-invalid-boz.\n\t* libgfortran.h (bt): Elevate BOZ to a basic type.\n\t* misc.c (gfc_basic_typename, gfc_typename): Translate BT_BOZ to BOZ.\n\t* primary.c (convert_integer, convert_real, convert_complex): to here.\n\tRename and make static functions.\n\t* primary.c(match_boz_constant): Rewrite parsing of a BOZ. Re-do\n\terror handling.  Deprecate 'X' for hexidecimal and postfix notation.\n\tUse -fallow-invalid-boz and gfc_invalid_boz to accept deprecated code.\n\t* resolve.c (resolve_ordinary_assign): Rework a RHS that is a\n\tBOZ literal constant.  Use gfc_invalid_boz to allow previous\n\tnonstandard behavior.  Remove range checking of BOZ conversion.\n\t* simplify.c (convert_boz): Remove function.\n\t(simplify_cmplx): Remove conversion of BOZ constants, because\n\tconversion is done in gfc_check_cmplx.\n\t(gfc_simplify_float): Remove conversion of BOZ constant, because\n\tconversion is done in gfc_check_float.\n\t(simplify_intconv): Use gfc_boz2int to convert BOZ to INTEGER.\n\tRemove range checking for BOZ conversion.\n\t(gfc_simplify_real): Use k, if present, to determine kind.  Convert\n\tBOZ to REAL.  Remove range checking for BOZ conversion.\n\ttarget-memory.c (gfc_convert_boz): Rewrite to deal with convert of\n\ta BOZ to a REAL value.\n\n2019-07-23  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\t* gfortran.dg/achar_5.f90: Fix for new BOZ handling.\n\t* arithmetic_overflow_1.f90: Ditto.\n\t* gfortran.dg/boz_11.f90: Ditto.\n\t* gfortran.dg/boz_12.f90: Ditto.\n\t* gfortran.dg/boz_4.f90: Ditto.\n\t* gfortran.dg/boz_5.f90: Ditto.\n\t* gfortran.dg/boz_6.f90: Ditto.\n\t* gfortran.dg/boz_7.f90: Ditto.\n\t* gfortran.dg/boz_8.f90: Ditto.\n\t* gfortran.dg/dec_structure_6.f90: Ditto.\n\t* gfortran.dg/dec_union_1.f90: Ditto.\n\t* gfortran.dg/dec_union_2.f90: Ditto.\n\t* gfortran.dg/dec_union_5.f90: Ditto.\n\t* gfortran.dg/dshift_3.f90: Ditto.\n\t* gfortran.dg/gnu_logical_2.f90: Ditto.\n\t* gfortran.dg/int_conv_1.f90: Ditto.\n\t* gfortran.dg/ishft_1.f90: Ditto.\n\t* gfortran.dg/nan_4.f90: Ditto.\n\t* gfortran.dg/no_range_check_3.f90: Ditto.\n\t* gfortran.dg/pr16433.f: Ditto.\n\t* gfortran.dg/pr44491.f90: Ditto.\n\t* gfortran.dg/pr58027.f90: Ditto.\n\t* gfortran.dg/pr81509_2.f90: Ditto.\n\t* gfortran.dg/unf_io_convert_1.f90: Ditto.\n\t* gfortran.dg/unf_io_convert_2.f90: Ditto.\n\t* gfortran.fortran-torture/execute/intrinsic_fraction_exponent.f90:\n\tDitto.\n\t* gfortran.fortran-torture/execute/intrinsic_mvbits.f90: Ditto.\n\t* gfortran.fortran-torture/execute/intrinsic_nearest.f90: Ditto.\n\t* gfortran.fortran-torture/execute/seq_io.f90: Ditto.\n\t* gfortran.dg/gnu_logical_1.F: Delete test.\n\t* gfortran.dg/merge_bits_3.f90: New test.\n\t* gfortran.dg/merge_bits_3.f90: Ditto.\n\t* gfortran.dg/boz_int.f90: Ditto.\n\t* gfortran.dg/boz_bge.f90: Ditto.\n\t* gfortran.dg/boz_complex_1.f90: Ditto.\n\t* gfortran.dg/boz_complex_2.f90: Ditto.\n\t* gfortran.dg/boz_complex_3.f90: Ditto.\n\t* gfortran.dg/boz_dble.f90: Ditto.\n\t* gfortran.dg/boz_dshift_1.f90: Ditto.\n\t* gfortran.dg/boz_dshift_2.f90: Ditto.\n\t* gfortran.dg/boz_float_1.f90: Ditto.\n\t* gfortran.dg/boz_float_2.f90: Ditto.\n\t* gfortran.dg/boz_float_3.f90: Ditto.\n\t* gfortran.dg/boz_iand_1.f90: Ditto.\n\t* gfortran.dg/boz_iand_2.f90: Ditto.\n\n2019-07-23  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\t* testsuite/libgomp.fortran/reduction4.f90: Update BOZ usage\n\t* testsuite/libgomp.fortran/reduction5.f90: Ditto.\n\nFrom-SVN: r273747", "tree": {"sha": "d8cd9da5b8bca4b00b103577f9637fb996d8024a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8cd9da5b8bca4b00b103577f9637fb996d8024a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dc63166e0b859546ba53093c5fc6c09925210dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc63166e0b859546ba53093c5fc6c09925210dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dc63166e0b859546ba53093c5fc6c09925210dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc63166e0b859546ba53093c5fc6c09925210dd/comments", "author": null, "committer": null, "parents": [{"sha": "000a002072d04d70bcd1d4be0daf8838035afa23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/000a002072d04d70bcd1d4be0daf8838035afa23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/000a002072d04d70bcd1d4be0daf8838035afa23"}], "stats": {"total": 1654, "additions": 1072, "deletions": 582}, "files": [{"sha": "7cac31028e6fd5010449d85072656c15076bb0f9", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -1,3 +1,83 @@\n+2019-07-23  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\t* arith.c (gfc_convert_integer, gfc_convert_real, gfc_convert_complex):\n+\tMove to ...\n+\t* primary.c (convert_integer, convert_real, convert_complex): ... here.\n+\tRename and make static functions.\n+\t(match_integer_constant): Use convert_integer\n+\t(match_real_constant): Use convert_real.\n+\t(match_complex_constant: Use convert_complex.\n+\t* arith.h (gfc_convert_integer, gfc_convert_real, gfc_convert_complex):\n+\tRemove prototypes.\n+\t* array.c (match_array_cons_element): A BOZ cannot be a data \n+\tstatement value.  Jump to a common exit point.\n+\t* check.c (gfc_invalid_boz): New function.  Emit error or warning\n+\tfor a BOZ in an invalid context.\n+\t(boz_args_check): Move to top of file to prevent need of forward\n+\tdeclaration.\n+\t(is_boz_constant): New function.  Check that BOZ expr is constant.\n+\t(gfc_boz2real): New function. In-place conversion of BOZ literal\n+\tconstant to REAL in accordance to F2018.\n+\t(gfc_boz2int): New function. In-place conversion of BOZ literal\n+\tconstant to INTEGER in accordance to F2018.\n+\t(gfc_check_achar, gfc_check_char, gfc_check_float): Use gfc_invalid_boz.  Convert BOZ\n+\tas needed.\n+\t(gfc_check_bge_bgt_ble_blt): Enforce F2018 requirements on BGE, \n+\tBGT, BLE, and BLT intrinsic functions.\n+\t(gfc_check_cmplx): Re-organize to check kind, if present, first.\n+\tConvert BOZ real and/or imaginary parts as needed in accordance to\n+\tF2018.\n+\t(gfc_check_complex):  Use gfc_invalid_boz.  Convert BOZ as needed.\n+\t(gfc_check_dcmplx, gfc_check_dble ): Convert BOZ as needed.\n+\t(gfc_check_dshift):  Make dshift[lr] conform to F2018 standard.\n+ \tgfc_check_float (gfc_expr *a)\n+\t(gfc_check_iand_ieor_ior):  Make IAND, IEOR, and IOR conform to \n+\tF2018 standard.\n+\t(gfc_check_int): Conform to F2018 standard.\n+\t(gfc_check_intconv): Deprecate SHORT and LONG aliases for INT2 and\n+\tINT.  Simply return for a BOZ argument. See gfc_simplify_intconv.\n+\t(gfc_check_merge_bits): Make MERGE_BITS conform to Fortran 2018\n+\tstandard.\n+\t(gfc_check_real): Remove incorrect comment. Check kind, if present,\n+\tfirst.  Simply return for a BOZ argument. See gfc_simplify_real.\n+\t(gfc_check_and): Re-do error handling for BOZ arguments.  Remove\n+\tspecial casing ts.type != BT_INTEGER or BT_LOGICAL.\n+\t* decl.c (match_old_style_init): Check for BOZ in old-style\n+\tinitialization.  Issue error or warning depending on\n+\t-fallow-invalid-boz option.  Issue error if variable is not an\n+\tINTEGER or REAL and the value is BOZ.\n+\t* expr.c (gfc_copy_expr): Copy a BT_BOZ gfc_expr.\n+\t(gfc_check_assign): Re-do error handling for a BOZ in an assignment\n+\tstatement.  Do in-place conversion of RHS based on LHS type of\n+\tINTEGER or REAL.\n+\t* gfortran.h (gfc_expr): Add a boz component.  Remove is_boz component.\n+\t(gfc_boz2int, gfc_boz2real, gfc_invalid_boz): New prototypes.\n+\t* interface.c (gfc_extend_assign): Guard against replacing an \n+\tintrinsic involving a BOZ literal constant on RHS.\n+\t* invoke.texi: Doument -fallow-invalid-boz.\n+\t* lang.opt: New option. -fallow-invalid-boz.\n+\t* libgfortran.h (bt): Elevate BOZ to a basic type.\n+\t* misc.c (gfc_basic_typename, gfc_typename): Translate BT_BOZ to BOZ.\n+\t* primary.c (convert_integer, convert_real, convert_complex): to here.\n+\tRename and make static functions.\n+\t* primary.c(match_boz_constant): Rewrite parsing of a BOZ. Re-do\n+\terror handling.  Deprecate 'X' for hexidecimal and postfix notation.\n+\tUse -fallow-invalid-boz and gfc_invalid_boz to accept deprecated code.\n+\t* resolve.c (resolve_ordinary_assign): Rework a RHS that is a\n+\tBOZ literal constant.  Use gfc_invalid_boz to allow previous\n+\tnonstandard behavior.  Remove range checking of BOZ conversion.\n+\t* simplify.c (convert_boz): Remove function.\n+\t(simplify_cmplx): Remove conversion of BOZ constants, because\n+\tconversion is done in gfc_check_cmplx.\n+\t(gfc_simplify_float): Remove conversion of BOZ constant, because\n+\tconversion is done in gfc_check_float.\n+\t(simplify_intconv): Use gfc_boz2int to convert BOZ to INTEGER.\n+\tRemove range checking for BOZ conversion.\n+\t(gfc_simplify_real): Use k, if present, to determine kind.  Convert\n+\tBOZ to REAL.  Remove range checking for BOZ conversion.\n+\ttarget-memory.c (gfc_convert_boz): Rewrite to deal with convert of\n+\ta BOZ to a REAL value.\n+\n 2019-07-21  Thomas K\u00f6nig  <tkoenig@gcc.gnu.org>\n \n \tPR libfortran/91030"}, {"sha": "ff279db49926c6068add85217ac789859d033474", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -1892,56 +1892,6 @@ gfc_le (gfc_expr *op1, gfc_expr *op2, gfc_intrinsic_op op)\n }\n \n \n-/* Convert an integer string to an expression node.  */\n-\n-gfc_expr *\n-gfc_convert_integer (const char *buffer, int kind, int radix, locus *where)\n-{\n-  gfc_expr *e;\n-  const char *t;\n-\n-  e = gfc_get_constant_expr (BT_INTEGER, kind, where);\n-  /* A leading plus is allowed, but not by mpz_set_str.  */\n-  if (buffer[0] == '+')\n-    t = buffer + 1;\n-  else\n-    t = buffer;\n-  mpz_set_str (e->value.integer, t, radix);\n-\n-  return e;\n-}\n-\n-\n-/* Convert a real string to an expression node.  */\n-\n-gfc_expr *\n-gfc_convert_real (const char *buffer, int kind, locus *where)\n-{\n-  gfc_expr *e;\n-\n-  e = gfc_get_constant_expr (BT_REAL, kind, where);\n-  mpfr_set_str (e->value.real, buffer, 10, GFC_RND_MODE);\n-\n-  return e;\n-}\n-\n-\n-/* Convert a pair of real, constant expression nodes to a single\n-   complex expression node.  */\n-\n-gfc_expr *\n-gfc_convert_complex (gfc_expr *real, gfc_expr *imag, int kind)\n-{\n-  gfc_expr *e;\n-\n-  e = gfc_get_constant_expr (BT_COMPLEX, kind, &real->where);\n-  mpc_set_fr_fr (e->value.complex, real->value.real, imag->value.real,\n-\t\t GFC_MPC_RND_MODE);\n-\n-  return e;\n-}\n-\n-\n /******* Simplification of intrinsic functions with constant arguments *****/\n \n "}, {"sha": "39366caaba13a2b0028576f389e237bc9d534460", "filename": "gcc/fortran/arith.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Farith.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Farith.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.h?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -59,11 +59,6 @@ gfc_expr *gfc_ge (gfc_expr *, gfc_expr *, gfc_intrinsic_op);\n gfc_expr *gfc_lt (gfc_expr *, gfc_expr *, gfc_intrinsic_op);\n gfc_expr *gfc_le (gfc_expr *, gfc_expr *, gfc_intrinsic_op);\n \n-/* Convert strings to literal constants.  */\n-gfc_expr *gfc_convert_integer (const char *, int, int, locus *);\n-gfc_expr *gfc_convert_real (const char *, int, locus *);\n-gfc_expr *gfc_convert_complex (gfc_expr *, gfc_expr *, int);\n-\n /* Convert a constant of one kind to another kind.  */\n gfc_expr *gfc_int2int (gfc_expr *, int);\n gfc_expr *gfc_int2real (gfc_expr *, int);"}, {"sha": "396dd976642950324ea0306bfd84bf9940fd69f9", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -1110,17 +1110,27 @@ match_array_cons_element (gfc_constructor_base *result)\n   if (m != MATCH_YES)\n     return m;\n \n+  if (expr->ts.type == BT_BOZ)\n+    {\n+      gfc_error (\"BOZ literal constant at %L cannot appear in an \"\n+\t\t \"array constructor\", &expr->where);\n+      goto done;\n+    }\n+\n   if (expr->expr_type == EXPR_FUNCTION\n       && expr->ts.type == BT_UNKNOWN\n       && strcmp(expr->symtree->name, \"null\") == 0)\n-   {\n+    {\n       gfc_error (\"NULL() at %C cannot appear in an array constructor\");\n-      gfc_free_expr (expr);\n-      return MATCH_ERROR;\n-   }\n+      goto done;\n+    }\n \n   gfc_constructor_append_expr (result, expr, &gfc_current_locus);\n   return MATCH_YES;\n+\n+done:\n+  gfc_free_expr (expr);\n+  return MATCH_ERROR;\n }\n \n "}, {"sha": "1543f136699b2434883f0c7e8f766bca5851cfc9", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 409, "deletions": 79, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -34,6 +34,225 @@ along with GCC; see the file COPYING3.  If not see\n #include \"constructor.h\"\n #include \"target-memory.h\"\n \n+/* A BOZ literal constant can appear in a limited number of contexts.\n+   gfc_invalid_boz() is a help function to simplify error/warning generation.\n+   Note, gfortran accepts the nonstandard 'X' for 'Z' the nonstandard\n+   suffix location.  If -fallow-invalid-boz is used, then issue a warning;\n+   otherwise issue an error.  */\n+\n+bool\n+gfc_invalid_boz (const char *msg, locus *loc)\n+{\n+  if (flag_allow_invalid_boz)\n+    {\n+      gfc_warning (0, msg, loc);\n+      return false;\n+    }\n+\n+  gfc_error (msg, loc);\n+  return true;\n+}\n+\n+\n+/* Some precedures take two arguments such that both cannot be BOZ.  */\n+\n+static bool\n+boz_args_check(gfc_expr *i, gfc_expr *j)\n+{\n+  if (i->ts.type == BT_BOZ && j->ts.type == BT_BOZ)\n+    {\n+      gfc_error (\"Arguments of %qs at %L and %L cannot both be BOZ \"\n+\t\t \"literal constants\", gfc_current_intrinsic, &i->where,\n+\t\t &j->where);\n+      return false;\n+\n+    }\n+\n+  return true;\n+}\n+\n+\n+/* Check that a BOZ is a constant.  */\n+\n+static bool\n+is_boz_constant (gfc_expr *a)\n+{\n+  if (a->expr_type != EXPR_CONSTANT)\n+    {\n+      gfc_error (\"Invalid use of BOZ literal constant at %L\", &a->where);\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+\n+/* Fortran 2018 treats a BOZ as simply a string of bits.  gfc_boz2real () \n+   converts the string into a REAL of the appropriate kind.  The treatment\n+   of the sign bit is processor dependent.  */\n+\n+bool\n+gfc_boz2real (gfc_expr *x, int kind)\n+{\n+  extern int gfc_max_integer_kind;\n+  gfc_typespec ts;\n+  int len;\n+  char *buf, *str;\n+\n+  if (!is_boz_constant (x))\n+    return false;\n+\n+  /* Determine the length of the required string.  */\n+  len = 8 * kind;\n+  if (x->boz.rdx == 16) len /= 4;\n+  if (x->boz.rdx == 8) len = len / 3 + 1;\n+  buf = (char *) alloca (len + 1);\t\t/* +1 for NULL terminator.  */\n+\n+  if (x->boz.len >= len)\t\t\t/* Truncate if necessary.  */\n+    {\n+      str = x->boz.str + (x->boz.len - len);\n+      strcpy(buf, str);\n+    }\n+  else\t\t\t\t\t\t/* Copy and pad. */\n+    {\n+      memset (buf, 48, len);\n+      str = buf + (len - x->boz.len);\n+      strcpy (str, x->boz.str);\n+    }\n+\n+  /* Need to adjust leading bits in an octal string.  */\n+  if (x->boz.rdx == 8)\n+    {\n+      /* Clear first bit.  */\n+      if (kind == 4 || kind == 10 || kind == 16)\n+\t{\n+\t  if (buf[0] == '4')\n+\t    buf[0] = '0';\n+\t  else if (buf[0] == '5')\n+\t    buf[0] = '1';\n+\t  else if (buf[0] == '6')\n+\t    buf[0] = '2';\n+\t  else if (buf[0] == '7')\n+\t    buf[0] = '3';\n+\t}\n+      /* Clear first two bits.  */\n+      else\n+\t{\n+\t  if (buf[0] == '4' || buf[0] == '6')\n+\t    buf[0] = '0';\n+\t  else if (buf[0] == '5' || buf[0] == '7')\n+\t    buf[0] = '1';\n+\t}\n+    }\n+ \n+  /* Reset BOZ string to the truncated or padded version.  */\n+  free (x->boz.str);\n+  x->boz.len = len;\n+  x->boz.str = XCNEWVEC (char, len + 1);\n+  strncpy (x->boz.str, buf, len);\n+\n+  /* Convert to widest possible integer.  */\n+  gfc_boz2int (x, gfc_max_integer_kind);\n+  ts.type = BT_REAL;\n+  ts.kind = kind;\n+  if (!gfc_convert_boz (x, &ts))\n+    {\n+      gfc_error (\"Failure in conversion of BOZ to REAL at %L\", &x->where);\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+\n+/* Fortran 2018 treats a BOZ as simply a string of bits.  gfc_boz2int () \n+   converts the string into an INTEGER of the appropriate kind.  The\n+   treatment of the sign bit is processor dependent.  If the  converted\n+   value exceeds the range of the type, then wrap-around semantics are\n+   applied.  */\n+ \n+bool\n+gfc_boz2int (gfc_expr *x, int kind)\n+{\n+  int i, len;\n+  char *buf, *str;\n+  mpz_t tmp1;\n+\n+  if (!is_boz_constant (x))\n+    return false;\n+\n+  i = gfc_validate_kind (BT_INTEGER, kind, false);\n+  len = gfc_integer_kinds[i].bit_size;\n+  if (x->boz.rdx == 16) len /= 4;\n+  if (x->boz.rdx == 8) len = len / 3 + 1;\n+  buf = (char *) alloca (len + 1);\t\t/* +1 for NULL terminator.  */\n+\n+  if (x->boz.len >= len)\t\t\t/* Truncate if necessary.  */\n+    {\n+      str = x->boz.str + (x->boz.len - len);\n+      strcpy(buf, str);\n+    }\n+  else\t\t\t\t\t\t/* Copy and pad. */\n+    {\n+      memset (buf, 48, len);\n+      str = buf + (len - x->boz.len);\n+      strcpy (str, x->boz.str);\n+    }\n+\n+  /* Need to adjust leading bits in an octal string.  */\n+  if (x->boz.rdx == 8)\n+    {\n+      /* Clear first bit.  */\n+      if (kind == 1 || kind == 4 || kind == 16)\n+\t{\n+\t  if (buf[0] == '4')\n+\t    buf[0] = '0';\n+\t  else if (buf[0] == '5')\n+\t    buf[0] = '1';\n+\t  else if (buf[0] == '6')\n+\t    buf[0] = '2';\n+\t  else if (buf[0] == '7')\n+\t    buf[0] = '3';\n+\t}\n+      /* Clear first two bits.  */\n+      else\n+\t{\n+\t  if (buf[0] == '4' || buf[0] == '6')\n+\t    buf[0] = '0';\n+\t  else if (buf[0] == '5' || buf[0] == '7')\n+\t    buf[0] = '1';\n+\t}\n+    }\n+\n+  /* Convert as-if unsigned integer.  */\n+  mpz_init (tmp1);\n+  mpz_set_str (tmp1, buf, x->boz.rdx);\n+\n+  /* Check for wrap-around.  */\n+  if (mpz_cmp (tmp1, gfc_integer_kinds[i].huge) > 0)\n+    {\n+      mpz_t tmp2;\n+      mpz_init (tmp2);\n+      mpz_add_ui (tmp2, gfc_integer_kinds[i].huge, 1);\n+      mpz_mod (tmp1, tmp1, tmp2);\n+      mpz_sub (tmp1, tmp1, tmp2);\n+      mpz_clear (tmp2);\n+    }\n+\n+  /* Clear boz info.  */\n+  x->boz.rdx = 0;\n+  x->boz.len = 0;\n+  free (x->boz.str);\n+\n+  mpz_init (x->value.integer);\n+  mpz_set (x->value.integer, tmp1);\n+  x->ts.type = BT_INTEGER;\n+  x->ts.kind = kind;\n+  mpz_clear (tmp1);\n+\n+  return true;\n+}\n+\n \n /* Make sure an expression is a scalar.  */\n \n@@ -880,8 +1099,19 @@ gfc_check_abs (gfc_expr *a)\n bool\n gfc_check_achar (gfc_expr *a, gfc_expr *kind)\n {\n+  if (a->ts.type == BT_BOZ)\n+    {\n+      if (gfc_invalid_boz (\"BOZ literal constant at %L cannot appear in \"\n+\t\t\t   \"ACHAR intrinsic subprogram\", &a->where))\n+\treturn false;\n+\n+      if (!gfc_boz2int (a, gfc_default_integer_kind))\n+\treturn false;\n+    }\n+\n   if (!type_check (a, 0, BT_INTEGER))\n     return false;\n+\n   if (!kind_check (kind, 1, BT_CHARACTER))\n     return false;\n \n@@ -1471,6 +1701,27 @@ gfc_check_bessel_n2 (gfc_expr *n1, gfc_expr *n2, gfc_expr *x)\n bool\n gfc_check_bge_bgt_ble_blt (gfc_expr *i, gfc_expr *j)\n {\n+  extern int gfc_max_integer_kind;\n+\n+  /* If i and j are both BOZ, convert to widest INTEGER.  */\n+  if (i->ts.type == BT_BOZ && j->ts.type == BT_BOZ)\n+    {\n+      if (!gfc_boz2int (i, gfc_max_integer_kind))\n+\treturn false;\n+      if (!gfc_boz2int (j, gfc_max_integer_kind))\n+\treturn false;\n+    }\n+\n+  /* If i is BOZ and j is integer, convert i to type of j.  */\n+  if (i->ts.type == BT_BOZ && j->ts.type == BT_INTEGER\n+      && !gfc_boz2int (i, j->ts.kind))\n+    return false;\n+\n+  /* If j is BOZ and i is integer, convert j to type of i.  */\n+  if (j->ts.type == BT_BOZ && i->ts.type == BT_INTEGER\n+      && !gfc_boz2int (j, i->ts.kind))\n+    return false;\n+\n   if (!type_check (i, 0, BT_INTEGER))\n     return false;\n \n@@ -1503,8 +1754,19 @@ gfc_check_bitfcn (gfc_expr *i, gfc_expr *pos)\n bool\n gfc_check_char (gfc_expr *i, gfc_expr *kind)\n {\n+  if (i->ts.type == BT_BOZ)\n+    {\n+      if (gfc_invalid_boz (\"BOZ literal constant at %L cannot appear in \"\n+\t\t\t   \"CHAR intrinsic subprogram\", &i->where))\n+\treturn false;\n+\n+      if (!gfc_boz2int (i, gfc_default_integer_kind))\n+\treturn false;\n+    }\n+\n   if (!type_check (i, 0, BT_INTEGER))\n     return false;\n+\n   if (!kind_check (kind, 1, BT_CHARACTER))\n     return false;\n \n@@ -1590,11 +1852,29 @@ gfc_check_chmod_sub (gfc_expr *name, gfc_expr *mode, gfc_expr *status)\n bool\n gfc_check_cmplx (gfc_expr *x, gfc_expr *y, gfc_expr *kind)\n {\n+  int k;\n+\n+  /* Check kind first, because it may be needed in conversion of a BOZ.  */\n+  if (kind)\n+    {\n+      if (!kind_check (kind, 2, BT_COMPLEX))\n+\treturn false;\n+      gfc_extract_int (kind, &k);\n+    }\n+  else\n+    k = gfc_default_complex_kind;\n+\n+  if (x->ts.type == BT_BOZ && !gfc_boz2real (x, k))\n+    return false;\n+\n   if (!numeric_check (x, 0))\n     return false;\n \n   if (y != NULL)\n     {\n+      if (y->ts.type == BT_BOZ && !gfc_boz2real (y, k))\n+\treturn false;\n+\n       if (!numeric_check (y, 1))\n \treturn false;\n \n@@ -1615,12 +1895,8 @@ gfc_check_cmplx (gfc_expr *x, gfc_expr *y, gfc_expr *kind)\n \t\t     &y->where);\n \t  return false;\n \t}\n-\n     }\n \n-  if (!kind_check (kind, 2, BT_COMPLEX))\n-    return false;\n-\n   if (!kind && warn_conversion\n       && x->ts.type == BT_REAL && x->ts.kind > gfc_default_real_kind)\n     gfc_warning_now (OPT_Wconversion, \"Conversion from %s to default-kind \"\n@@ -1926,6 +2202,33 @@ gfc_check_co_sum (gfc_expr *a, gfc_expr *result_image, gfc_expr *stat,\n bool\n gfc_check_complex (gfc_expr *x, gfc_expr *y)\n {\n+\n+  /* FIXME BOZ.  What to do with complex?  */\n+  if (!boz_args_check (x, y))\n+    return false;\n+\n+  if (x->ts.type == BT_BOZ)\n+    {\n+      if (gfc_invalid_boz (\"BOZ constant at %L cannot appear in the COMPLEX \"\n+\t\t\t   \"intrinsic subprogram\", &x->where))\n+\treturn false;\n+      if (y->ts.type == BT_INTEGER && !gfc_boz2int (x, y->ts.kind))\n+\treturn false;\n+      if (y->ts.type == BT_REAL && !gfc_boz2real (x, y->ts.kind))\n+    \treturn false;\n+    }\n+\n+  if (y->ts.type == BT_BOZ)\n+    {\n+      if (gfc_invalid_boz (\"BOZ constant at %L cannot appear in the COMPLEX \"\n+\t\t\t   \"intrinsic subprogram\", &y->where))\n+\treturn false;\n+      if (x->ts.type == BT_INTEGER && !gfc_boz2int (y, x->ts.kind))\n+\treturn false;\n+      if (x->ts.type == BT_REAL && !gfc_boz2real (y, x->ts.kind))\n+\treturn false;\n+    }\n+\n   if (!int_or_real_check (x, 0))\n     return false;\n   if (!scalar_check (x, 0))\n@@ -2047,11 +2350,17 @@ bool gfc_check_datan2 (gfc_expr *y, gfc_expr *x)\n bool\n gfc_check_dcmplx (gfc_expr *x, gfc_expr *y)\n {\n+  if (x->ts.type == BT_BOZ && !gfc_boz2real (x, gfc_default_double_kind))\n+    return false;\n+\n   if (!numeric_check (x, 0))\n     return false;\n \n   if (y != NULL)\n     {\n+      if (y->ts.type == BT_BOZ && !gfc_boz2real (y, gfc_default_double_kind))\n+\treturn false;\n+\n       if (!numeric_check (y, 1))\n \treturn false;\n \n@@ -2081,6 +2390,9 @@ gfc_check_dcmplx (gfc_expr *x, gfc_expr *y)\n bool\n gfc_check_dble (gfc_expr *x)\n {\n+  if (x->ts.type == BT_BOZ && !gfc_boz2real (x, gfc_default_double_kind))\n+    return false;\n+\n   if (!numeric_check (x, 0))\n     return false;\n \n@@ -2167,35 +2479,30 @@ gfc_check_dprod (gfc_expr *x, gfc_expr *y)\n   return true;\n }\n \n-\n-static bool\n-boz_args_check(gfc_expr *i, gfc_expr *j)\n+bool\n+gfc_check_dshift (gfc_expr *i, gfc_expr *j, gfc_expr *shift)\n {\n-  if (i->is_boz && j->is_boz)\n-    {\n-      gfc_error (\"Arguments of %qs at %L and %L cannot both be BOZ \"\n-\t\t \"literal constants\", gfc_current_intrinsic, &i->where,\n-\t\t &j->where);\n-      return false;\n+  /* i and j cannot both be BOZ literal constants.  */\n+  if (!boz_args_check (i, j))\n+    return false;\n \n-    }\n-  return true;\n-}\n+  /* If i is BOZ and j is integer, convert i to type of j.  */\n+  if (i->ts.type == BT_BOZ && j->ts.type == BT_INTEGER\n+      && !gfc_boz2int (i, j->ts.kind))\n+    return false;\n \n+  /* If j is BOZ and i is integer, convert j to type of i.  */\n+  if (j->ts.type == BT_BOZ && i->ts.type == BT_INTEGER\n+      && !gfc_boz2int (j, i->ts.kind))\n+    return false;\n \n-bool\n-gfc_check_dshift (gfc_expr *i, gfc_expr *j, gfc_expr *shift)\n-{\n   if (!type_check (i, 0, BT_INTEGER))\n     return false;\n \n   if (!type_check (j, 1, BT_INTEGER))\n     return false;\n \n-  if (!boz_args_check (i, j))\n-    return false;\n-\n-  if (!i->is_boz && !j->is_boz && !same_type_check (i, 0, j, 1))\n+  if (!same_type_check (i, 0, j, 1))\n     return false;\n \n   if (!type_check (shift, 2, BT_INTEGER))\n@@ -2204,18 +2511,8 @@ gfc_check_dshift (gfc_expr *i, gfc_expr *j, gfc_expr *shift)\n   if (!nonnegative_check (\"SHIFT\", shift))\n     return false;\n \n-  if (i->is_boz)\n-    {\n-      if (!less_than_bitsize1 (\"J\", j, \"SHIFT\", shift, true))\n-    \treturn false;\n-      i->ts.kind = j->ts.kind;\n-    }\n-  else\n-    {\n-      if (!less_than_bitsize1 (\"I\", i, \"SHIFT\", shift, true))\n-    \treturn false;\n-      j->ts.kind = i->ts.kind;\n-    }\n+  if (!less_than_bitsize1 (\"I\", i, \"SHIFT\", shift, true))\n+    return false;\n \n   return true;\n }\n@@ -2367,9 +2664,19 @@ gfc_check_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n   return true;\n }\n \n+\n bool\n gfc_check_float (gfc_expr *a)\n {\n+  if (a->ts.type == BT_BOZ)\n+    {\n+      if (gfc_invalid_boz (\"BOZ literal constant at %L cannot appear in the \"\n+\t\t\t   \"FLOAT intrinsic subprogram\", &a->where))\n+\treturn false;\n+      if (!gfc_boz2int (a, gfc_default_integer_kind))\n+\treturn false;\n+    }\n+\n   if (!type_check (a, 0, BT_INTEGER))\n     return false;\n \n@@ -2495,17 +2802,25 @@ gfc_check_i (gfc_expr *i)\n bool\n gfc_check_iand_ieor_ior (gfc_expr *i, gfc_expr *j)\n {\n-  if (!type_check (i, 0, BT_INTEGER))\n+  /* i and j cannot both be BOZ literal constants.  */\n+  if (!boz_args_check (i, j))\n     return false;\n \n-  if (!type_check (j, 1, BT_INTEGER))\n+  /* If i is BOZ and j is integer, convert i to type of j.  */\n+  if (i->ts.type == BT_BOZ && j->ts.type == BT_INTEGER\n+      && !gfc_boz2int (i, j->ts.kind))\n     return false;\n \n-  if (!boz_args_check (i, j))\n+  /* If j is BOZ and i is integer, convert j to type of i.  */\n+  if (j->ts.type == BT_BOZ && i->ts.type == BT_INTEGER\n+      && !gfc_boz2int (j, i->ts.kind))\n+    return false;\n+\n+  if (!type_check (i, 0, BT_INTEGER))\n     return false;\n \n-  if (i->is_boz) i->ts.kind = j->ts.kind;\n-  if (j->is_boz) j->ts.kind = i->ts.kind;\n+  if (!type_check (j, 1, BT_INTEGER))\n+    return false;\n \n   if (i->ts.kind != j->ts.kind)\n     {\n@@ -2658,6 +2973,10 @@ gfc_check_index (gfc_expr *string, gfc_expr *substring, gfc_expr *back,\n bool\n gfc_check_int (gfc_expr *x, gfc_expr *kind)\n {\n+  /* BOZ is dealt within simplify_int*.  */\n+  if (x->ts.type == BT_BOZ)\n+    return true;\n+\n   if (!numeric_check (x, 0))\n     return false;\n \n@@ -2671,6 +2990,19 @@ gfc_check_int (gfc_expr *x, gfc_expr *kind)\n bool\n gfc_check_intconv (gfc_expr *x)\n {\n+  if (strcmp (gfc_current_intrinsic, \"short\") == 0\n+      || strcmp (gfc_current_intrinsic, \"long\") == 0)\n+    {\n+      gfc_error (\"%qs intrinsic subprogram at %L has been deprecated.  \"\n+\t\t \"Use INT intrinsic subprogram.\", gfc_current_intrinsic, \n+\t\t &x->where);\n+      return false;\n+    }\n+\n+  /* BOZ is dealt within simplify_int*.  */\n+  if (x->ts.type == BT_BOZ)\n+    return true;\n+\n   if (!numeric_check (x, 0))\n     return false;\n \n@@ -3554,28 +3886,37 @@ gfc_check_merge (gfc_expr *tsource, gfc_expr *fsource, gfc_expr *mask)\n bool\n gfc_check_merge_bits (gfc_expr *i, gfc_expr *j, gfc_expr *mask)\n {\n-  if (!type_check (i, 0, BT_INTEGER))\n+  /* i and j cannot both be BOZ literal constants.  */\n+  if (!boz_args_check (i, j))\n     return false;\n \n-  if (!type_check (j, 1, BT_INTEGER))\n+  /* If i is BOZ and j is integer, convert i to type of j.  */\n+  if (i->ts.type == BT_BOZ && j->ts.type == BT_INTEGER\n+      && !gfc_boz2int (i, j->ts.kind))\n     return false;\n \n-  if (!boz_args_check (i, j))\n+  /* If j is BOZ and i is integer, convert j to type of i.  */\n+  if (j->ts.type == BT_BOZ && i->ts.type == BT_INTEGER\n+      && !gfc_boz2int (j, i->ts.kind))\n     return false;\n \n-  if (i->is_boz) i->ts.kind = j->ts.kind;\n-  if (j->is_boz) j->ts.kind = i->ts.kind;\n+  if (!type_check (i, 0, BT_INTEGER))\n+    return false;\n \n-  if (!type_check (mask, 2, BT_INTEGER))\n+  if (!type_check (j, 1, BT_INTEGER))\n     return false;\n \n   if (!same_type_check (i, 0, j, 1))\n     return false;\n \n-  if (!same_type_check (i, 0, mask, 2))\n+  if (mask->ts.type == BT_BOZ && !gfc_boz2int(mask, i->ts.kind))\n+    return false;\n+\n+  if (!type_check (mask, 2, BT_INTEGER))\n     return false;\n \n-  if (mask->is_boz) mask->ts.kind = i->ts.kind;\n+  if (!same_type_check (i, 0, mask, 2))\n+    return false;\n \n   return true;\n }\n@@ -3977,14 +4318,17 @@ gfc_check_rank (gfc_expr *a)\n }\n \n \n-/* real, float, sngl.  */\n bool\n gfc_check_real (gfc_expr *a, gfc_expr *kind)\n {\n-  if (!numeric_check (a, 0))\n+  if (!kind_check (kind, 1, BT_REAL))\n     return false;\n \n-  if (!kind_check (kind, 1, BT_REAL))\n+  /* BOZ is dealt with in gfc_simplify_real.  */\n+  if (a->ts.type == BT_BOZ)\n+    return true;\n+\n+  if (!numeric_check (a, 0))\n     return false;\n \n   return true;\n@@ -6726,42 +7070,28 @@ gfc_check_system_sub (gfc_expr *cmd, gfc_expr *status)\n bool\n gfc_check_and (gfc_expr *i, gfc_expr *j)\n {\n-  if (i->ts.type != BT_INTEGER && i->ts.type != BT_LOGICAL)\n-    {\n-      gfc_error (\"%qs argument of %qs intrinsic at %L must be INTEGER \"\n-\t\t \"or LOGICAL\", gfc_current_intrinsic_arg[0]->name,\n-\t\t gfc_current_intrinsic, &i->where);\n-      return false;\n-    }\n-\n-  if (j->ts.type != BT_INTEGER && j->ts.type != BT_LOGICAL)\n-    {\n-      gfc_error (\"%qs argument of %qs intrinsic at %L must be INTEGER \"\n-\t\t \"or LOGICAL\", gfc_current_intrinsic_arg[1]->name,\n-\t\t gfc_current_intrinsic, &j->where);\n-      return false;\n-    }\n+  /* i and j cannot both be BOZ literal constants.  */\n+  if (!boz_args_check (i, j))\n+    return false;\n \n-  if (i->ts.type != j->ts.type)\n-    {\n-      gfc_error (\"%qs and %qs arguments of %qs intrinsic at %L must \"\n-\t\t \"have the same type\", gfc_current_intrinsic_arg[0]->name,\n-\t\t gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n-\t\t &j->where);\n-      return false;\n-    }\n+  /* If i is BOZ and j is integer, convert i to type of j.  */\n+  if (i->ts.type == BT_BOZ && j->ts.type == BT_INTEGER\n+      && !gfc_boz2int (i, j->ts.kind))\n+    return false;\n \n-  if (!scalar_check (i, 0))\n+  /* If j is BOZ and i is integer, convert j to type of i.  */\n+  if (j->ts.type == BT_BOZ && i->ts.type == BT_INTEGER\n+      && !gfc_boz2int (j, i->ts.kind))\n     return false;\n \n-  if (!scalar_check (j, 1))\n+  if (!same_type_check (i, 0, j, 1, false))\n     return false;\n \n-  if (!boz_args_check (i, j))\n+  if (!scalar_check (i, 0))\n     return false;\n \n-  if (i->is_boz) i->ts.kind = j->ts.kind;\n-  if (j->is_boz) j->ts.kind = i->ts.kind;\n+  if (!scalar_check (j, 1))\n+    return false;\n \n   return true;\n }"}, {"sha": "a7886b0efcd956afa664c6dad681cc719f537db0", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -547,7 +547,7 @@ match_old_style_init (const char *name)\n   match m;\n   gfc_symtree *st;\n   gfc_symbol *sym;\n-  gfc_data *newdata;\n+  gfc_data *newdata, *nd;\n \n   /* Set up data structure to hold initializers.  */\n   gfc_find_sym_tree (name, NULL, 0, &st);\n@@ -567,6 +567,25 @@ match_old_style_init (const char *name)\n       return m;\n     }\n \n+  /* Check that a BOZ did not creep into an old-style initialization.  */\n+  for (nd = newdata; nd; nd = nd->next)\n+    {\n+      if (nd->value->expr->ts.type == BT_BOZ\n+\t  && gfc_invalid_boz (\"BOZ at %L cannot appear in an old-style \"\n+\t\t\t      \"initialization\", &nd->value->expr->where))\n+\treturn MATCH_ERROR;\n+\n+      if (nd->var->expr->ts.type != BT_INTEGER\n+\t  && nd->var->expr->ts.type != BT_REAL\n+\t  && nd->value->expr->ts.type == BT_BOZ)\n+\t{\n+\t  gfc_error (\"Mismatch in variable type and BOZ literal constant \"\n+\t\t     \"at %L in an old-style initialization\",\n+\t\t     &nd->value->expr->where);\n+\t  return MATCH_ERROR;\n+\t}\n+    }\n+\n   if (gfc_pure (NULL))\n     {\n       gfc_error (\"Initialization at %C is not allowed in a PURE procedure\");"}, {"sha": "a10a17dd62983c11450190d7155d957198ebb6a3", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -342,6 +342,13 @@ gfc_copy_expr (gfc_expr *p)\n \tcase BT_ASSUMED:\n \t  break;\t\t/* Already done.  */\n \n+\tcase BT_BOZ:\n+\t  q->boz.len = p->boz.len;\n+\t  q->boz.rdx = p->boz.rdx;\n+\t  q->boz.str = XCNEWVEC (char, q->boz.len + 1);\n+\t  strncpy (q->boz.str, p->boz.str, p->boz.len);\n+\t  break;\n+\n \tcase BT_PROCEDURE:\n         case BT_VOID:\n            /* Should never be reached.  */\n@@ -3634,45 +3641,30 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform,\n       && !gfc_check_conformance (lvalue, rvalue, \"array assignment\"))\n     return false;\n \n-  if (rvalue->is_boz && lvalue->ts.type != BT_INTEGER\n+  if (rvalue->ts.type == BT_BOZ && lvalue->ts.type != BT_INTEGER\n       && lvalue->symtree->n.sym->attr.data\n       && !gfc_notify_std (GFC_STD_GNU, \"BOZ literal at %L used to \"\n \t\t\t  \"initialize non-integer variable %qs\",\n \t\t\t  &rvalue->where, lvalue->symtree->n.sym->name))\n     return false;\n-  else if (rvalue->is_boz && !lvalue->symtree->n.sym->attr.data\n+  else if (rvalue->ts.type == BT_BOZ && !lvalue->symtree->n.sym->attr.data\n       && !gfc_notify_std (GFC_STD_GNU, \"BOZ literal at %L outside \"\n \t\t\t  \"a DATA statement and outside INT/REAL/DBLE/CMPLX\",\n \t\t\t  &rvalue->where))\n     return false;\n \n   /* Handle the case of a BOZ literal on the RHS.  */\n-  if (rvalue->is_boz && lvalue->ts.type != BT_INTEGER)\n-    {\n-      int rc;\n-      if (warn_surprising)\n-\tgfc_warning (OPT_Wsurprising,\n-\t\t     \"BOZ literal at %L is bitwise transferred \"\n-\t\t     \"non-integer symbol %qs\", &rvalue->where,\n-\t\t     lvalue->symtree->n.sym->name);\n-      if (!gfc_convert_boz (rvalue, &lvalue->ts))\n-\treturn false;\n-      if ((rc = gfc_range_check (rvalue)) != ARITH_OK)\n-\t{\n-\t  if (rc == ARITH_UNDERFLOW)\n-\t    gfc_error (\"Arithmetic underflow of bit-wise transferred BOZ at %L\"\n-\t\t       \". This check can be disabled with the option \"\n-\t\t       \"%<-fno-range-check%>\", &rvalue->where);\n-\t  else if (rc == ARITH_OVERFLOW)\n-\t    gfc_error (\"Arithmetic overflow of bit-wise transferred BOZ at %L\"\n-\t\t       \". This check can be disabled with the option \"\n-\t\t       \"%<-fno-range-check%>\", &rvalue->where);\n-\t  else if (rc == ARITH_NAN)\n-\t    gfc_error (\"Arithmetic NaN of bit-wise transferred BOZ at %L\"\n-\t\t       \". This check can be disabled with the option \"\n-\t\t       \"%<-fno-range-check%>\", &rvalue->where);\n-\t  return false;\n-\t}\n+  if (rvalue->ts.type == BT_BOZ)\n+    {\n+      /* FIXME BOZ.  Need gfc_invalid_boz() here?.  */\n+      if (lvalue->ts.type == BT_INTEGER\n+\t  && gfc_boz2int (rvalue, lvalue->ts.kind))\n+\treturn true;\n+      if (lvalue->ts.type == BT_REAL\n+\t  && gfc_boz2real (rvalue, lvalue->ts.kind))\n+\treturn true;\n+\n+      return false;\n     }\n \n   if (gfc_expr_attr (lvalue).pdt_kind || gfc_expr_attr (lvalue).pdt_len)"}, {"sha": "700e6dcbcd8ce504288419794ef0e8619412eb6c", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -2152,9 +2152,8 @@ typedef struct gfc_expr\n      is not a variable.  */\n   struct gfc_expr *base_expr;\n \n-  /* is_boz is true if the integer is regarded as BOZ bit pattern and is_snan\n-     denotes a signalling not-a-number.  */\n-  unsigned int is_boz : 1, is_snan : 1;\n+  /* is_snan denotes a signalling not-a-number.  */\n+  unsigned int is_snan : 1;\n \n   /* Sometimes, when an error has been emitted, it is necessary to prevent\n       it from recurring.  */\n@@ -2198,6 +2197,14 @@ typedef struct gfc_expr\n   }\n   representation;\n \n+  struct\n+  {\n+    int len;\t/* Length of BOZ string without terminating NULL.  */\n+    int rdx;\t/* Radix of BOZ.  */\n+    char *str;\t/* BOZ string with NULL terminating character.  */\n+  }\n+  boz;\n+\n   union\n   {\n     int logical;\n@@ -3479,6 +3486,10 @@ bool gfc_dep_difference (gfc_expr *, gfc_expr *, mpz_t *);\n bool gfc_check_same_strlen (const gfc_expr*, const gfc_expr*, const char*);\n bool gfc_calculate_transfer_sizes (gfc_expr*, gfc_expr*, gfc_expr*,\n \t\t\t\t      size_t*, size_t*, size_t*);\n+bool gfc_boz2int (gfc_expr *, int);\n+bool gfc_boz2real (gfc_expr *, int);\n+bool gfc_invalid_boz (const char *, locus *);\n+\n \n /* class.c */\n void gfc_fix_class_refs (gfc_expr *e);"}, {"sha": "f9715866c958449ce2947faa19c6596000da2d52", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -4274,6 +4274,12 @@ gfc_extend_assign (gfc_code *c, gfc_namespace *ns)\n   lhs = c->expr1;\n   rhs = c->expr2;\n \n+  /* Don't allow an intrinsic assignment with a BOZ rhs to be replaced.  */\n+  if (c->op == EXEC_ASSIGN\n+      && c->expr1->expr_type == EXPR_VARIABLE\n+      && c->expr2->expr_type == EXPR_CONSTANT && c->expr2->ts.type == BT_BOZ)\n+    return false;\n+\n   /* Don't allow an intrinsic assignment to be replaced.  */\n   if (lhs->ts.type != BT_DERIVED && lhs->ts.type != BT_CLASS\n       && (rhs->rank == 0 || rhs->rank == lhs->rank)"}, {"sha": "5d538faae384c7fee14966f4369f06293a95b6ba", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -116,13 +116,13 @@ by type.  Explanations are in the following sections.\n @table @emph\n @item Fortran Language Options\n @xref{Fortran Dialect Options,,Options controlling Fortran dialect}.\n-@gccoptlist{-fall-intrinsics -fbackslash -fcray-pointer -fd-lines-as-code @gol\n--fd-lines-as-comments -fdec -fdec-structure -fdec-intrinsic-ints @gol\n--fdec-static -fdec-math -fdec-include -fdec-format-defaults @gol\n--fdec-blank-format-item -fdefault-double-8 -fdefault-integer-8 @gol\n--fdefault-real-8 -fdefault-real-10 -fdefault-real-16 -fdollar-ok @gol\n--ffixed-line-length-@var{n} -ffixed-line-length-none -fpad-source @gol\n--ffree-form -ffree-line-length-@var{n} -ffree-line-length-none @gol\n+@gccoptlist{-fall-intrinsics -fallow-invalid-boz -fbackslash -fcray-pointer @gol\n+-fd-lines-as-code -fd-lines-as-comments -fdec -fdec-structure @gol\n+-fdec-intrinsic-ints -fdec-static -fdec-math -fdec-include @gol\n+-fdec-format-defaults -fdec-blank-format-item -fdefault-double-8 @gol\n+-fdefault-integer-8 -fdefault-real-8 -fdefault-real-10 -fdefault-real-16 @gol\n+-fdollar-ok @gol -ffixed-line-length-@var{n} -ffixed-line-length-none @gol\n+-fpad-source -ffree-form -ffree-line-length-@var{n} -ffree-line-length-none @gol\n -fimplicit-none -finteger-4-integer-8 -fmax-identifier-length @gol\n -fmodule-private -ffixed-form -fno-range-check -fopenacc -fopenmp @gol\n -freal-4-real-10 -freal-4-real-16 -freal-4-real-8 -freal-8-real-10 @gol\n@@ -231,6 +231,13 @@ available with @command{gfortran}.  As a consequence, @option{-Wintrinsics-std}\n will be ignored and no user-defined procedure with the same name as any\n intrinsic will be called except when it is explicitly declared @code{EXTERNAL}.\n \n+@item -fallow-invalid-boz\n+@opindex @code{allow-invalid-boz}\n+A BOZ literal constant can occur in a limited number of context in\n+standard conforming Fortran.  This option degrades an error condition\n+to a warning, and allows a BOZ literal constant to appear where the\n+Fortran standard would otherwise prohibits it.\n+\n @item -fd-lines-as-code\n @itemx -fd-lines-as-comments\n @opindex @code{fd-lines-as-code}"}, {"sha": "fdf5061b64f91d77cddcd71578a33676a94b959f", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -377,6 +377,10 @@ fall-intrinsics\n Fortran RejectNegative Var(flag_all_intrinsics)\n All intrinsics procedures are available regardless of selected standard.\n \n+fallow-invalid-boz\n+Fortran RejectNegative Var(flag_allow_invalid_boz)\n+Allow a BOZ literal constant to appear in an invalid context.\n+\n fallow-leading-underscore\n Fortran Undocumented Var(flag_allow_leading_underscore)\n ; For internal use only: allow the first character of symbol names to be an underscore"}, {"sha": "30cb6efef07e2a24eaac66f48a8681369320de89", "filename": "gcc/fortran/libgfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flibgfortran.h?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -174,6 +174,6 @@ typedef enum\n typedef enum\n { BT_UNKNOWN = 0, BT_INTEGER, BT_LOGICAL, BT_REAL, BT_COMPLEX,\n   BT_DERIVED, BT_CHARACTER, BT_CLASS, BT_PROCEDURE, BT_HOLLERITH, BT_VOID,\n-  BT_ASSUMED, BT_UNION\n+  BT_ASSUMED, BT_UNION, BT_BOZ\n }\n bt;"}, {"sha": "2569f6bfdfc776f7385eb79a0b1354099bbd8f0b", "filename": "gcc/fortran/misc.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmisc.c?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -100,6 +100,9 @@ gfc_basic_typename (bt type)\n     case BT_VOID:\n       p = \"VOID\";\n       break;\n+    case BT_BOZ:\n+      p = \"BOZ\";\n+      break;\n     case BT_UNKNOWN:\n       p = \"UNKNOWN\";\n       break;\n@@ -169,6 +172,9 @@ gfc_typename (gfc_typespec *ts)\n     case BT_PROCEDURE:\n       strcpy (buffer, \"PROCEDURE\");\n       break;\n+    case BT_BOZ:\n+      strcpy (buffer, \"BOZ\");\n+      break;\n     case BT_UNKNOWN:\n       strcpy (buffer, \"UNKNOWN\");\n       break;"}, {"sha": "da524e9b71448021871ddf0e8bcf11657760eb59", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 69, "deletions": 30, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -189,6 +189,55 @@ match_digits (int signflag, int radix, char *buffer)\n   return length;\n }\n \n+/* Convert an integer string to an expression node.  */\n+\n+static gfc_expr *\n+convert_integer (const char *buffer, int kind, int radix, locus *where)\n+{\n+  gfc_expr *e;\n+  const char *t;\n+\n+  e = gfc_get_constant_expr (BT_INTEGER, kind, where);\n+  /* A leading plus is allowed, but not by mpz_set_str.  */\n+  if (buffer[0] == '+')\n+    t = buffer + 1;\n+  else\n+    t = buffer;\n+  mpz_set_str (e->value.integer, t, radix);\n+\n+  return e;\n+}\n+\n+\n+/* Convert a real string to an expression node.  */\n+\n+static gfc_expr *\n+convert_real (const char *buffer, int kind, locus *where)\n+{\n+  gfc_expr *e;\n+\n+  e = gfc_get_constant_expr (BT_REAL, kind, where);\n+  mpfr_set_str (e->value.real, buffer, 10, GFC_RND_MODE);\n+\n+  return e;\n+}\n+\n+\n+/* Convert a pair of real, constant expression nodes to a single\n+   complex expression node.  */\n+\n+static gfc_expr *\n+convert_complex (gfc_expr *real, gfc_expr *imag, int kind)\n+{\n+  gfc_expr *e;\n+\n+  e = gfc_get_constant_expr (BT_COMPLEX, kind, &real->where);\n+  mpc_set_fr_fr (e->value.complex, real->value.real, imag->value.real,\n+\t\t GFC_MPC_RND_MODE);\n+\n+  return e;\n+}\n+\n \n /* Match an integer (digit string and optional kind).\n    A sign will be accepted if signflag is set.  */\n@@ -231,7 +280,7 @@ match_integer_constant (gfc_expr **result, int signflag)\n       return MATCH_ERROR;\n     }\n \n-  e = gfc_convert_integer (buffer, kind, 10, &gfc_current_locus);\n+  e = convert_integer (buffer, kind, 10, &gfc_current_locus);\n   e->ts.is_c_interop = is_iso_c;\n \n   if (gfc_range_check (e) != ARITH_OK)\n@@ -337,7 +386,7 @@ match_hollerith_constant (gfc_expr **result)\n static match\n match_boz_constant (gfc_expr **result)\n {\n-  int radix, length, x_hex, kind;\n+  int radix, length, x_hex;\n   locus old_loc, start_loc;\n   char *buffer, post, delim;\n   gfc_expr *e;\n@@ -383,9 +432,9 @@ match_boz_constant (gfc_expr **result)\n     goto backup;\n \n   if (x_hex\n-      && (!gfc_notify_std(GFC_STD_GNU, \"Hexadecimal \"\n-\t\t\t  \"constant at %C uses non-standard syntax\")))\n-      return MATCH_ERROR;\n+      && gfc_invalid_boz (\"Hexadecimal constant at %L uses \"\n+\t\t\t  \"nonstandard syntax\", &gfc_current_locus))\n+    return MATCH_ERROR;\n \n   old_loc = gfc_current_locus;\n \n@@ -421,8 +470,8 @@ match_boz_constant (gfc_expr **result)\n \t  goto backup;\n \t}\n \n-      if (!gfc_notify_std (GFC_STD_GNU, \"BOZ constant \"\n-\t\t\t   \"at %C uses non-standard postfix syntax\"))\n+      if (gfc_invalid_boz (\"BOZ constant at %C uses nonstandard postfix \"\n+\t\t\t   \"syntax\", &gfc_current_locus))\n \treturn MATCH_ERROR;\n     }\n \n@@ -436,30 +485,20 @@ match_boz_constant (gfc_expr **result)\n   if (post == 1)\n     gfc_next_ascii_char ();  /* Eat postfixed b, o, z, or x.  */\n \n-  /* In section 5.2.5 and following C567 in the Fortran 2003 standard, we find\n-     \"If a data-stmt-constant is a boz-literal-constant, the corresponding\n-     variable shall be of type integer.  The boz-literal-constant is treated\n-     as if it were an int-literal-constant with a kind-param that specifies\n-     the representation method with the largest decimal exponent range\n-     supported by the processor.\"  */\n-\n-  kind = gfc_max_integer_kind;\n-  e = gfc_convert_integer (buffer, kind, radix, &gfc_current_locus);\n-\n-  /* Mark as boz variable.  */\n-  e->is_boz = 1;\n-\n-  if (gfc_range_check (e) != ARITH_OK)\n-    {\n-      gfc_error (\"Integer too big for integer kind %i at %C\", kind);\n-      gfc_free_expr (e);\n-      return MATCH_ERROR;\n-    }\n+  e = gfc_get_expr ();\n+  e->expr_type = EXPR_CONSTANT;\n+  e->ts.type = BT_BOZ;\n+  e->where = gfc_current_locus;\n+  e->boz.rdx = radix;\n+  e->boz.len = length;\n+  e->boz.str = XCNEWVEC (char, length + 1);\n+  strncpy (e->boz.str, buffer, length);\n \n+  /* FIXME BOZ.  */\n   if (!gfc_in_match_data ()\n       && (!gfc_notify_std(GFC_STD_F2003, \"BOZ used outside a DATA \"\n-\t\t\t  \"statement at %C\")))\n-      return MATCH_ERROR;\n+\t\t\t  \"statement at %L\", &e->where)))\n+    return MATCH_ERROR;\n \n   *result = e;\n   return MATCH_YES;\n@@ -715,7 +754,7 @@ match_real_constant (gfc_expr **result, int signflag)\n \t}\n     }\n \n-  e = gfc_convert_real (buffer, kind, &gfc_current_locus);\n+  e = convert_real (buffer, kind, &gfc_current_locus);\n   if (negate)\n     mpfr_neg (e->value.real, e->value.real, GFC_RND_MODE);\n   e->ts.is_c_interop = is_iso_c;\n@@ -1433,7 +1472,7 @@ match_complex_constant (gfc_expr **result)\n   if (imag->ts.type != BT_REAL || kind != imag->ts.kind)\n     gfc_convert_type (imag, &target, 2);\n \n-  e = gfc_convert_complex (real, imag, kind);\n+  e = convert_complex (real, imag, kind);\n   e->where = gfc_current_locus;\n \n   gfc_free_expr (real);"}, {"sha": "70c7f82dd2f98235a992af18faa45d02bdfd0b83", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 19, "deletions": 31, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -10473,44 +10473,32 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n   lhs = code->expr1;\n   rhs = code->expr2;\n \n-  if (rhs->is_boz\n-      && !gfc_notify_std (GFC_STD_GNU, \"BOZ literal at %L outside \"\n-\t\t\t  \"a DATA statement and outside INT/REAL/DBLE/CMPLX\",\n-\t\t\t  &code->loc))\n-    return false;\n-\n   /* Handle the case of a BOZ literal on the RHS.  */\n-  if (rhs->is_boz && lhs->ts.type != BT_INTEGER)\n+  if (rhs->ts.type == BT_BOZ)\n     {\n-      int rc;\n-      if (warn_surprising)\n-\tgfc_warning (OPT_Wsurprising,\n-\t\t     \"BOZ literal at %L is bitwise transferred \"\n-\t\t     \"non-integer symbol %qs\", &code->loc,\n-\t\t     lhs->symtree->n.sym->name);\n-\n-      if (!gfc_convert_boz (rhs, &lhs->ts))\n+      if (gfc_invalid_boz (\"BOZ literal constant at %L is neither a DATA \"\n+\t\t\t   \"statement value nor an actual argument of \"\n+\t\t\t   \"INT/REAL/DBLE/CMPLX intrinsic subprogram\",\n+\t\t\t   &rhs->where))\n \treturn false;\n-      if ((rc = gfc_range_check (rhs)) != ARITH_OK)\n-\t{\n-\t  if (rc == ARITH_UNDERFLOW)\n-\t    gfc_error (\"Arithmetic underflow of bit-wise transferred BOZ at %L\"\n-\t\t       \". This check can be disabled with the option \"\n-\t\t       \"%<-fno-range-check%>\", &rhs->where);\n-\t  else if (rc == ARITH_OVERFLOW)\n-\t    gfc_error (\"Arithmetic overflow of bit-wise transferred BOZ at %L\"\n-\t\t       \". This check can be disabled with the option \"\n-\t\t       \"%<-fno-range-check%>\", &rhs->where);\n-\t  else if (rc == ARITH_NAN)\n-\t    gfc_error (\"Arithmetic NaN of bit-wise transferred BOZ at %L\"\n-\t\t       \". This check can be disabled with the option \"\n-\t\t       \"%<-fno-range-check%>\", &rhs->where);\n+\n+      switch (lhs->ts.type)\n+\t{\n+\tcase BT_INTEGER:\n+\t  if (!gfc_boz2int (rhs, lhs->ts.kind))\n+\t    return false;\n+\t  break;\n+\tcase BT_REAL:\n+\t  if (!gfc_boz2real (rhs, lhs->ts.kind))\n+\t    return false;\n+\t  break;\n+\tdefault:\n+\t  gfc_error (\"Invalid use of BOZ literal constant at %L\", &rhs->where);\n \t  return false;\n \t}\n     }\n \n-  if (lhs->ts.type == BT_CHARACTER\n-\t&& warn_character_truncation)\n+  if (lhs->ts.type == BT_CHARACTER && warn_character_truncation)\n     {\n       HOST_WIDE_INT llen = 0, rlen = 0;\n       if (lhs->ts.u.cl != NULL"}, {"sha": "5ab7c81c13af4a0b615fc81f1a77ccb25910c671", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 25, "deletions": 41, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -211,26 +211,6 @@ gfc_convert_mpz_to_signed (mpz_t x, int bitsize)\n }\n \n \n-/* In-place convert BOZ to REAL of the specified kind.  */\n-\n-static gfc_expr *\n-convert_boz (gfc_expr *x, int kind)\n-{\n-  if (x && x->ts.type == BT_INTEGER && x->is_boz)\n-    {\n-      gfc_typespec ts;\n-      gfc_clear_ts (&ts);\n-      ts.type = BT_REAL;\n-      ts.kind = kind;\n-\n-      if (!gfc_convert_boz (x, &ts))\n-\treturn &gfc_bad_expr;\n-    }\n-\n-  return x;\n-}\n-\n-\n /* Test that the expression is a constant array, simplifying if\n    we are dealing with a parameter array.  */\n \n@@ -1660,12 +1640,6 @@ simplify_cmplx (const char *name, gfc_expr *x, gfc_expr *y, int kind)\n {\n   gfc_expr *result;\n \n-  if (convert_boz (x, kind) == &gfc_bad_expr)\n-    return &gfc_bad_expr;\n-\n-  if (convert_boz (y, kind) == &gfc_bad_expr)\n-    return &gfc_bad_expr;\n-\n   if (x->expr_type != EXPR_CONSTANT\n       || (y != NULL && y->expr_type != EXPR_CONSTANT))\n     return NULL;\n@@ -2219,9 +2193,6 @@ gfc_simplify_dble (gfc_expr *e)\n   if (e->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  if (convert_boz (e, gfc_default_double_kind) == &gfc_bad_expr)\n-    return &gfc_bad_expr;\n-\n   result = gfc_convert_constant (e, BT_REAL, gfc_default_double_kind);\n   if (result == &gfc_bad_expr)\n     return &gfc_bad_expr;\n@@ -2965,15 +2936,7 @@ gfc_simplify_float (gfc_expr *a)\n   if (a->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  if (a->is_boz)\n-    {\n-      if (convert_boz (a, gfc_default_real_kind) == &gfc_bad_expr)\n-\treturn &gfc_bad_expr;\n-\n-      result = gfc_copy_expr (a);\n-    }\n-  else\n-    result = gfc_int2real (a, gfc_default_real_kind);\n+  result = gfc_int2real (a, gfc_default_real_kind);\n \n   return range_check (result, \"FLOAT\");\n }\n@@ -3610,6 +3573,15 @@ simplify_intconv (gfc_expr *e, int kind, const char *name)\n {\n   gfc_expr *result = NULL;\n \n+  /* Convert BOZ to integer, and return without range checking.  */\n+  if (e->ts.type == BT_BOZ)\n+    {\n+      if (!gfc_boz2int (e, kind))\n+\treturn NULL;\n+      result = gfc_copy_expr (e);\n+      return result;\n+    }\n+\n   if (e->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n@@ -6497,6 +6469,21 @@ gfc_simplify_real (gfc_expr *e, gfc_expr *k)\n   gfc_expr *result = NULL;\n   int kind;\n \n+  /* Convert BOZ to real, and return without range checking.  */\n+  if (e->ts.type == BT_BOZ)\n+    {\n+      /* Determine kind for conversion of the BOZ.  */\n+      if (k)\n+\tgfc_extract_int (k, &kind);\n+      else\n+\tkind = gfc_default_real_kind;\n+\n+      if (!gfc_boz2real (e, kind))\n+\treturn NULL;\n+      result = gfc_copy_expr (e);\n+      return result;\n+    }\n+\n   if (e->ts.type == BT_COMPLEX)\n     kind = get_kind (BT_REAL, k, \"REAL\", e->ts.kind);\n   else\n@@ -6508,9 +6495,6 @@ gfc_simplify_real (gfc_expr *e, gfc_expr *k)\n   if (e->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  if (convert_boz (e, kind) == &gfc_bad_expr)\n-    return &gfc_bad_expr;\n-\n   result = gfc_convert_constant (e, BT_REAL, kind);\n   if (result == &gfc_bad_expr)\n     return &gfc_bad_expr;"}, {"sha": "1b23a445de3485ec44712fa9f0b5701283cbcd22", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 9, "deletions": 34, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -769,35 +769,19 @@ gfc_convert_boz (gfc_expr *expr, gfc_typespec *ts)\n   int index;\n   unsigned char *buffer;\n \n-  if (!expr->is_boz)\n+  if (expr->ts.type != BT_INTEGER)\n     return true;\n \n-  gcc_assert (expr->expr_type == EXPR_CONSTANT\n-\t      && expr->ts.type == BT_INTEGER);\n-\n   /* Don't convert BOZ to logical, character, derived etc.  */\n-  if (ts->type == BT_REAL)\n-    {\n-      buffer_size = size_float (ts->kind);\n-      ts_bit_size = buffer_size * 8;\n-    }\n-  else if (ts->type == BT_COMPLEX)\n-    {\n-      buffer_size = size_complex (ts->kind);\n-      ts_bit_size = buffer_size * 8 / 2;\n-    }\n-  else\n-    return true;\n+  gcc_assert (ts->type == BT_REAL);\n+\n+  buffer_size = size_float (ts->kind);\n+  ts_bit_size = buffer_size * 8;\n \n   /* Convert BOZ to the smallest possible integer kind.  */\n   boz_bit_size = mpz_sizeinbase (expr->value.integer, 2);\n \n-  if (boz_bit_size > ts_bit_size)\n-    {\n-      gfc_error_now (\"BOZ constant at %L is too large (%ld vs %ld bits)\",\n-\t\t     &expr->where, (long) boz_bit_size, (long) ts_bit_size);\n-      return false;\n-    }\n+  gcc_assert (boz_bit_size <= ts_bit_size);\n \n   for (index = 0; gfc_integer_kinds[index].kind != 0; ++index)\n     if ((unsigned) gfc_integer_kinds[index].bit_size >= ts_bit_size)\n@@ -810,18 +794,9 @@ gfc_convert_boz (gfc_expr *expr, gfc_typespec *ts)\n   encode_integer (expr->ts.kind, expr->value.integer, buffer, buffer_size);\n   mpz_clear (expr->value.integer);\n \n-  if (ts->type == BT_REAL)\n-    {\n-      mpfr_init (expr->value.real);\n-      gfc_interpret_float (ts->kind, buffer, buffer_size, expr->value.real);\n-    }\n-  else\n-    {\n-      mpc_init2 (expr->value.complex, mpfr_get_default_prec());\n-      gfc_interpret_complex (ts->kind, buffer, buffer_size,\n-\t\t\t     expr->value.complex);\n-    }\n-  expr->is_boz = 0;\n+  mpfr_init (expr->value.real);\n+  gfc_interpret_float (ts->kind, buffer, buffer_size, expr->value.real);\n+\n   expr->ts.type = ts->type;\n   expr->ts.kind = ts->kind;\n "}, {"sha": "43e7862c8f20c8bf6b6521dc8a0b605725ebd0ef", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -1,3 +1,52 @@\n+2019-07-23  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\t* gfortran.dg/achar_5.f90: Fix for new BOZ handling.\n+\t* arithmetic_overflow_1.f90: Ditto.\n+\t* gfortran.dg/boz_11.f90: Ditto.\n+\t* gfortran.dg/boz_12.f90: Ditto.\n+\t* gfortran.dg/boz_4.f90: Ditto.\n+\t* gfortran.dg/boz_5.f90: Ditto.\n+\t* gfortran.dg/boz_6.f90: Ditto.\n+\t* gfortran.dg/boz_7.f90: Ditto.\n+\t* gfortran.dg/boz_8.f90: Ditto.\n+\t* gfortran.dg/dec_structure_6.f90: Ditto.\n+\t* gfortran.dg/dec_union_1.f90: Ditto.\n+\t* gfortran.dg/dec_union_2.f90: Ditto.\n+\t* gfortran.dg/dec_union_5.f90: Ditto.\n+\t* gfortran.dg/dshift_3.f90: Ditto.\n+\t* gfortran.dg/gnu_logical_2.f90: Ditto.\n+\t* gfortran.dg/int_conv_1.f90: Ditto.\n+\t* gfortran.dg/ishft_1.f90: Ditto.\n+\t* gfortran.dg/nan_4.f90: Ditto.\n+\t* gfortran.dg/no_range_check_3.f90: Ditto.\n+\t* gfortran.dg/pr16433.f: Ditto.\n+\t* gfortran.dg/pr44491.f90: Ditto.\n+\t* gfortran.dg/pr58027.f90: Ditto.\n+\t* gfortran.dg/pr81509_2.f90: Ditto.\n+\t* gfortran.dg/unf_io_convert_1.f90: Ditto.\n+\t* gfortran.dg/unf_io_convert_2.f90: Ditto.\n+\t* gfortran.fortran-torture/execute/intrinsic_fraction_exponent.f90:\n+\tDitto.\n+\t* gfortran.fortran-torture/execute/intrinsic_mvbits.f90: Ditto.\n+\t* gfortran.fortran-torture/execute/intrinsic_nearest.f90: Ditto.\n+\t* gfortran.fortran-torture/execute/seq_io.f90: Ditto.\n+\t* gfortran.dg/gnu_logical_1.F: Delete test.\n+\t* gfortran.dg/merge_bits_3.f90: New test.\n+\t* gfortran.dg/merge_bits_3.f90: Ditto.\n+\t* gfortran.dg/boz_int.f90: Ditto.\n+\t* gfortran.dg/boz_bge.f90: Ditto.\n+\t* gfortran.dg/boz_complex_1.f90: Ditto.\n+\t* gfortran.dg/boz_complex_2.f90: Ditto.\n+\t* gfortran.dg/boz_complex_3.f90: Ditto.\n+\t* gfortran.dg/boz_dble.f90: Ditto.\n+\t* gfortran.dg/boz_dshift_1.f90: Ditto.\n+\t* gfortran.dg/boz_dshift_2.f90: Ditto.\n+\t* gfortran.dg/boz_float_1.f90: Ditto.\n+\t* gfortran.dg/boz_float_2.f90: Ditto.\n+\t* gfortran.dg/boz_float_3.f90: Ditto.\n+\t* gfortran.dg/boz_iand_1.f90: Ditto.\n+\t* gfortran.dg/boz_iand_2.f90: Ditto.\n+\n 2019-07-23  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/86061"}, {"sha": "498c6e3e057bc4d091141ad2d5a655aa6bc2f23c", "filename": "gcc/testsuite/gfortran.dg/achar_5.f90", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fachar_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fachar_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fachar_5.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -37,9 +37,4 @@ program test\n   print *, char(huge(0_8),kind=4) ! { dg-error \"too large for the collating sequence\" }\n   print *, achar(huge(0_8),kind=4) ! { dg-error \"too large for the collating sequence\" }\n \n-  print *, char(z'FFFFFFFF', kind=4)\n-  print *, achar(z'FFFFFFFF', kind=4)\n-  print *, char(z'100000000', kind=4) ! { dg-error \"too large for the collating sequence\" }\n-  print *, achar(z'100000000', kind=4) ! { dg-error \"too large for the collating sequence\" }\n-\n end program test"}, {"sha": "95b15a8558450b5dbc8610aa58df8447a45e042f", "filename": "gcc/testsuite/gfortran.dg/arithmetic_overflow_1.f90", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Farithmetic_overflow_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Farithmetic_overflow_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farithmetic_overflow_1.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -3,8 +3,10 @@\n !\n ! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n !\n+! In F2008 and F2018, overflow cannot happen, but a BOZ cannot appear \n+! in an array constructor.\n+!\n program bug\n   implicit none\n-   integer(1) :: a(2) = (/ Z'FF', Z'FF' /) ! { dg-error \"Arithmetic overflow\" }\n-   print*, a\n+   integer(1) :: a(2) = (/ Z'FF', Z'FF' /) ! { dg-error \"cannot appear in\" }\n end program bug"}, {"sha": "c9bae41a675f48329068cd695f09bed20f30a408", "filename": "gcc/testsuite/gfortran.dg/boz_11.f90", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_11.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -12,16 +12,5 @@ program test0\n \n    if (cmplx(b'01000000001010010101001111111101',x,4) /= r) STOP 1\n    if (cmplx(x,b'01000000001010010101001111111101',4) /= z) STOP 2\n-   if (complex(b'01000000001010010101001111111101',0) /= r) STOP 3\n-   if (complex(0,b'01000000001010010101001111111101') /= z) STOP 4\n-\n-   !if (cmplx(b'00000000000000000000000000000000&\n-   !           &01000000001010010101001111111101',x,8) /= rd) STOP 5\n-   !if (cmplx(x,b'00000000000000000000000000000000&\n-   !             &01000000001010010101001111111101',8) /= zd) STOP 6\n-   !if (dcmplx(b'00000000000000000000000000000000&\n-   !            &01000000001010010101001111111101',x) /= rd) STOP 7\n-   !if (dcmplx(x,b'00000000000000000000000000000000&\n-   !              &01000000001010010101001111111101') /= zd) STOP 8\n \n end program test0"}, {"sha": "60a89522b93724e7e7287b45a542d945475aae36", "filename": "gcc/testsuite/gfortran.dg/boz_12.f90", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_12.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -4,11 +4,8 @@ program test\n   implicit none\n   real x4\n   double precision x8\n-\n   x4 = 1.7\n   x8 = 1.7\n-  write(*,*) complex(x4,z'1FFFFFFFF') ! { dg-error \"too\" }\n-  write(*,*) cmplx(x8,z'1FFFFFFFFFFFFFFFF') ! { dg-error \"too\" }\n-  write(*,*) complex(x8,z'1FFFFFFFFFFFFFFFF') ! { dg-error \"too\" }\n-  write(*,*) dcmplx(x8,z'1FFFFFFFFFFFFFFFF') ! { dg-error \"too\" }\n+  write(*,*) cmplx(x8,z'1FFFFFFFFFFFFFFFF')\n+  write(*,*) dcmplx(x8,z'1FFFFFFFFFFFFFFFF')\n end program test"}, {"sha": "35113b72bb8e82cae7056a4d36351a31540931c7", "filename": "gcc/testsuite/gfortran.dg/boz_4.f90", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_4.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -1,29 +1,20 @@\n ! { dg-do compile }\n ! Test that the conversion of a BOZ constant that is too large for the\n ! integer variable is caught by the compiler.\n+!\n+! In F2008 and F2018, overflow cannot happen.\n+!\n program boz\n-\n    implicit none\n-\n-   integer(1), parameter :: &\n-   &  b1 = b'0101010110101010'  ! { dg-error \"overflow converting\" }\n-   integer(2), parameter :: &\n-   &  b2 = b'01110000111100001111000011110000'  ! { dg-error \"overflow converting\" }\n+   integer(1), parameter :: b1 = b'0101010110101010'\n+   integer(2), parameter :: b2 = b'01110000111100001111000011110000'\n    integer(4), parameter :: &\n-   &  b4 = b'0111000011110000111100001111000011110000111100001111000011110000'  ! { dg-error \"overflow converting\" }\n-\n-   integer(1), parameter :: &\n-   &  o1 = o'1234567076543210'  ! { dg-error \"overflow converting\" }\n-   integer(2), parameter :: &\n-   &  o2 = o'1234567076543210'  ! { dg-error \"overflow converting\" }\n-   integer(4), parameter :: &\n-   &  o4 = o'1234567076543210'  ! { dg-error \"overflow converting\" }\n-\n-   integer(1), parameter :: &\n-   &  z1 = z'deadbeef'  ! { dg-error \"overflow converting\" }\n-   integer(2), parameter :: &\n-   &  z2 = z'deadbeef'  ! { dg-error \"overflow converting\" }\n-   integer(4), parameter :: &\n-   &  z4 = z'deadbeeffeed'  ! { dg-error \"overflow converting\" }\n-\n+   &  b4 = b'0111000011110000111100001111000011110000111100001111000011110000'\n+   integer(1), parameter :: o1 = o'1234567076543210'\n+   integer(2), parameter :: o2 = o'1234567076543210'\n+   integer(4), parameter :: o4 = o'1234567076543210'\n+   integer(1), parameter :: z1 = z'deadbeef'\n+   integer(2), parameter :: z2 = z'deadbeef'\n+   integer(4), parameter :: z4 = z'deadbeeffeed'\n end program boz\n+! { dg-prune-output \"BOZ literal at\" }"}, {"sha": "f4176b957ee38d9f7e3d64e7bdc3cec24127746d", "filename": "gcc/testsuite/gfortran.dg/boz_5.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_5.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -1,4 +1,4 @@\n ! { dg-do compile }\n   integer, dimension (2) :: i\n-  i = (/Z'abcde', Z'abcde/)\t! { dg-error \"Illegal character\" }\n+  i = (/Z'abcde', Z'abcde/)\t! { dg-error \"cannot appear in\" }\n end"}, {"sha": "57a8beb4fcf1849bc016b556f5afbd6e6029e405", "filename": "gcc/testsuite/gfortran.dg/boz_6.f90", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_6.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -1,13 +1,13 @@\n ! { dg-do run }\n-! { dg-options \"-std=gnu\" }\n+! { dg-options \"-std=gnu -fallow-invalid-boz\" }\n ! PR 24917\n program test\n   integer ib, io, iz, ix\n   integer jb, jo, jz, jx\n-  data ib, jb /b'111', '111'b/\n-  data io, jo /o'234', '234'o/\n-  data iz, jz /z'abc', 'abc'z/\n-  data ix, jx /x'abc', 'abc'x/\n+  data ib, jb /b'111', '111'b/   ! { dg-warning \"nonstandard\" }\n+  data io, jo /o'234', '234'o/   ! { dg-warning \"nonstandard\" }\n+  data iz, jz /z'abc', 'abc'z/   ! { dg-warning \"nonstandard\" }\n+  data ix, jx /x'abc', 'abc'x/   ! { dg-warning \"nonstandard\" }\n   if (ib /= jb) STOP 1\n   if (io /= jo) STOP 2\n   if (iz /= jz) STOP 3"}, {"sha": "45fa7a7df19a83d894876cbc8558cdf3d1e6813f", "filename": "gcc/testsuite/gfortran.dg/boz_7.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_7.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -7,6 +7,6 @@\n !\n integer :: k, m\n integer :: j = z'000abc' ! { dg-error \"BOZ used outside a DATA statement\" }\n-data k/x'0003'/ ! { dg-error \"uses non-standard syntax\" }\n-data m/'0003'z/ ! { dg-error \"uses non-standard postfix syntax\" }\n+data k/x'0003'/ ! { dg-error \"nonstandard syntax\" }\n+data m/'0003'z/ ! { dg-error \"nonstandard postfix\" }\n end"}, {"sha": "0f47c673ce9a042e03c0a8ad09657d1816d782eb", "filename": "gcc/testsuite/gfortran.dg/boz_8.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_8.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -11,7 +11,7 @@\n real :: r\n integer :: i\n data i/z'111'/, r/z'4455'/ ! { dg-error \"BOZ literal at .1. used to initialize non-integer variable 'r'\" }\n-r = z'FFFF' ! { dg-error \"outside a DATA statement\" }\n-i = z'4455' ! { dg-error \"outside a DATA statement\" }\n-r = real(z'FFFFFFFFF') ! { dg-error \"is too large\" }\n+r = z'FFFF' ! { dg-error \"a DATA statement value\" }\n+i = z'4455' ! { dg-error \"a DATA statement value\" }\n+r = real(z'FFFFFFFFF')\n end"}, {"sha": "46891e3c649aefd130ebdbe053e2f879d9950fe7", "filename": "gcc/testsuite/gfortran.dg/boz_bge.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_bge.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_bge.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_bge.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+program foo\n+\n+   integer :: k = 4242\n+\n+   if (bge(z'1234', z'5678') .neqv. .false.) stop 1\n+   if (bgt(z'1234', z'5678') .neqv. .false.) stop 2\n+   if (ble(z'1234', z'5678') .eqv. .false.)  stop 3\n+   if (blt(z'1234', z'5678') .eqv. .false.)  stop 4\n+\n+   if (bge(z'1234', k) .eqv. .false.)  stop 5\n+   if (bgt(z'1234', k) .eqv. .false.)  stop 6\n+   if (ble(z'1234', k) .neqv. .false.)  stop 7\n+   if (blt(z'1234', k) .neqv. .false.)  stop 8\n+\n+   if (bge(k, z'5678') .neqv. .false.) stop 9\n+   if (bgt(k, z'5678') .neqv. .false.) stop 10\n+   if (ble(k, z'5678') .eqv. .false.)  stop 11\n+   if (blt(k, z'5678') .eqv. .false.)  stop 12\n+\n+end program foo\n+"}, {"sha": "e05246aa1b3c51a359bb84f09176301b3bc915ab", "filename": "gcc/testsuite/gfortran.dg/boz_complex_1.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_complex_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_complex_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_complex_1.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+program foo\n+\n+   implicit none\n+\n+   complex(4) z\n+\n+   z = complex(z'4444', z'4444')    ! { dg-error \"cannot both be BOZ\" }\n+   if (real(z,4) /= 17476.0 .or. aimag(z) /= 42.0) stop 2\n+\n+   z = complex(z'4444', 42)         ! { dg-error \"cannot appear in the\" }\n+   if (real(z,4) /= 17476.0 .or. aimag(z) /= 42.0) stop 2\n+\n+   z = complex(z'44444400', 42.)    ! { dg-error \"cannot appear in the\" }\n+   if (real(z,4) /= 785.062500 .or. aimag(z) /= 42.0) stop 3\n+\n+end program foo"}, {"sha": "345027b3aee9eb32adef0a2f0add7bcd6020c3a0", "filename": "gcc/testsuite/gfortran.dg/boz_complex_2.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_complex_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_complex_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_complex_2.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! { dg-options \"-fallow-invalid-boz\" }\n+program foo\n+\n+   implicit none\n+\n+   complex(4) z\n+\n+   z = complex(z'4444', 42)         ! { dg-warning \"cannot appear in the\" }\n+   if (real(z,4) /= 17476.0 .or. aimag(z) /= 42.0) stop 2\n+\n+   z = complex(z'44444400', 42.)    ! { dg-warning \"cannot appear in the\" }\n+   if (real(z,4) /= 785.062500 .or. aimag(z) /= 42.0) stop 3\n+\n+end program foo"}, {"sha": "4318a7f3c594de4c0d6a8ffa860d39eb5c15652d", "filename": "gcc/testsuite/gfortran.dg/boz_complex_3.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_complex_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_complex_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_complex_3.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do run }\n+! { dg-options \"-fallow-invalid-boz -w\" }\n+program foo\n+\n+   implicit none\n+\n+   complex(4) z\n+\n+   z = complex(z'4444', 42)\n+   if (real(z,4) /= 17476.0 .or. aimag(z) /= 42.0) stop 2\n+\n+   z = complex(z'44444400', 42.)\n+   if (real(z,4) /= 785.062500 .or. aimag(z) /= 42.0) stop 3\n+\n+end program foo"}, {"sha": "c15524398775f0710d1d5c35dd7f32760a9aea2f", "filename": "gcc/testsuite/gfortran.dg/boz_dble.f90", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_dble.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_dble.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_dble.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -0,0 +1,6 @@\n+! { dg-do run }\n+program foo\n+   double precision x\n+   x = dble(z\"400921FB54411744\");\n+   if (x /= 3.1415926535_8) stop 1\n+end"}, {"sha": "ba10315ae5b76e8b8653e340d12f2e193353dd14", "filename": "gcc/testsuite/gfortran.dg/boz_dshift_1.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_dshift_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_dshift_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_dshift_1.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+program foo\n+   integer k, n\n+   k = dshiftl(z'1234',z'2345',1)   ! { dg-error \"cannot both be BOZ\" }\n+   n = dshiftr(z'1234',z'2345',1)   ! { dg-error \"cannot both be BOZ\" }\n+   if (k .eq. n) stop 1\n+   k = dshiftl(z'1234',3.1415,1)   ! { dg-error \"must be INTEGER\" }\n+   n = dshiftr(2.7362,z'2345',1)   ! { dg-error \"must be INTEGER\" }\n+   if (k .eq. n) stop 2\n+end program foo"}, {"sha": "c2fbd1b2eb94593e021ac13d8e83e029cc2fe38d", "filename": "gcc/testsuite/gfortran.dg/boz_dshift_2.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_dshift_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_dshift_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_dshift_2.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do run }\n+program foo\n+   integer k, n\n+   k = dshiftl(z'1234',42,1)\n+   n = dshiftr(z'1234',42,1)\n+   if (k /= 9320) stop 1\n+   if (n /= 21) stop 2\n+   k = dshiftl(42,b'01010101', 1)\n+   n = dshiftr(22,o'12345', 1)\n+   if (k /= 84) stop 1\n+   if (n /= 2674) stop 2\n+end program foo"}, {"sha": "e444b09241bf0c0401c0fda1ded1002e21289f77", "filename": "gcc/testsuite/gfortran.dg/boz_float_1.f90", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_float_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_float_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_float_1.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -0,0 +1,4 @@\n+! { dg-do compile }\n+program foo\n+   print *, float(z'1234') ! { dg-error \"cannot appear in\" }\n+end program foo"}, {"sha": "638dae22d7cc78bd680452f2918a79dd3d1bedd9", "filename": "gcc/testsuite/gfortran.dg/boz_float_2.f90", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_float_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_float_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_float_2.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -0,0 +1,5 @@\n+! { dg-do compile }\n+! { dg-options \"-fallow-invalid-boz\" }\n+program foo\n+   print *, float(z'1234') ! { dg-warning \"cannot appear in\" }\n+end program foo"}, {"sha": "7262495529d8d9d6ecc2a51d8d9c2e649e8f981d", "filename": "gcc/testsuite/gfortran.dg/boz_float_3.f90", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_float_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_float_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_float_3.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -0,0 +1,7 @@\n+! { dg-do run }\n+! { dg-options \"-fallow-invalid-boz -w\" }\n+program foo\n+   integer i\n+   i = float(z'1234')\n+   if (i /= 4660.0) stop 1\n+end program foo"}, {"sha": "45d8c39e56d1bee607b097c21d3a4a186752eab6", "filename": "gcc/testsuite/gfortran.dg/boz_iand_1.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_iand_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_iand_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_iand_1.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+program foo\n+   print *, iand(z'1234', z'3456')  ! { dg-error \"cannot both be\" }\n+   print *,  and(z'1234', z'3456')  ! { dg-error \"cannot both be\" }\n+   print *, ieor(z'1234', z'3456')  ! { dg-error \"cannot both be\" }\n+   print *,  xor(z'1234', z'3456')  ! { dg-error \"cannot both be\" }\n+   print *,  ior(z'1234', z'3456')  ! { dg-error \"cannot both be\" }\n+   print *,   or(z'1234', z'3456')  ! { dg-error \"cannot both be\" }\n+end program foo\n+"}, {"sha": "e656ac005c3f0692e59c66adc527f9f1ffc37678", "filename": "gcc/testsuite/gfortran.dg/boz_iand_2.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_iand_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_iand_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_iand_2.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do run }\n+program foo\n+   integer :: k = 42\n+   n = iand(k, z'3456'); if (n /=  2) stop 1\n+   n = iand(z'1234', k); if (n /= 32) stop 2\n+   n =  and(k, z'3456'); if (n /=  2)  stop 3\n+   n =  and(z'1234', k); if (n /=  32) stop 4\n+   n = ieor(k, z'3456'); if (n /= 13436) stop 5\n+   n = ieor(z'1234', k); if (n /=  4638) stop 6\n+   n =  xor(k, z'3456'); if (n /= 13436) stop 7\n+   n =  xor(z'1234', k); if (n /=  4638) stop 8\n+   n =  ior(k, z'3456'); if (n /= 13438) stop 9\n+   n =  ior(z'1234', k); if (n /=  4670) stop 10\n+   n =   or(k, z'3456'); if (n /= 13438) stop 11\n+   n =   or(z'1234', k); if (n /=  4670) stop 12\n+end program foo\n+"}, {"sha": "79302cd924772ceceb54c9e84bb8f0039e925a3f", "filename": "gcc/testsuite/gfortran.dg/boz_int.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_int.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_int.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_int.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do run }\n+program foo\n+   implicit none\n+   integer(1) i1\n+   integer(2) i2\n+   integer(4) i4, j4\n+   integer(8) i8\n+   i1 = int(z'12', 1);      if (i1 /= 18)         stop 1\n+   i2 = int(z'1234', 2);    if (i2 /= 4660)       stop 2\n+   i4 = int(z'1234', 4);    if (i4 /= 4660)       stop 3\n+   j4 = int(z'1234');       if (i4 /= 4660)       stop 4\n+   i8 = int(z'1233456',8);  if (i8 /= 19084374_8) stop 5\n+end program"}, {"sha": "69ff50c26ad4f06aaaa6d0eeafc4c8ea05936d07", "filename": "gcc/testsuite/gfortran.dg/dec_structure_6.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_6.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -41,6 +41,6 @@ subroutine aborts (s)\n if (     r8.p(1,1) /= 1 .or. r8.p(2,1) /= 2 .or. r8.p(1,2) /= 3 &\n     .or. r8.p(2,2) /= 4) &\n   call aborts (\"r8.p\")\n-if ( r8.canary /= z'3D3D3D3D' ) call aborts (\"r8.canary\")\n+if ( r8.canary /= int(z'3D3D3D3D') ) call aborts (\"r8.canary\")\n \n end"}, {"sha": "689628c66c543e8c433e4e83b36b024c2d27345b", "filename": "gcc/testsuite/gfortran.dg/dec_union_1.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_1.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -28,8 +28,8 @@ subroutine sub ()\n     end union\n   end structure\n   record /s6/ r6\n-  r6.ibuf(1) = z'badbeef'\n-  r6.ibuf(2) = z'badbeef'\n+  r6.ibuf(1) = int(z'badbeef')\n+  r6.ibuf(2) = int(z'badbeef')\n end subroutine\n \n ! Repeat definition from subroutine sub with different size parameter.\n@@ -55,7 +55,7 @@ subroutine sub ()\n ! Copied type declaration - this should not cause problems\n i = 1\n do while (i < siz)\n-  r6.ibuf(i) = z'badbeef'\n+  r6.ibuf(i) = int(z'badbeef')\n   i = i + 1\n end do\n "}, {"sha": "4e23955438ad8adce2978c80a70cc331a9d8f548", "filename": "gcc/testsuite/gfortran.dg/dec_union_2.f90", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_2.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -31,6 +31,7 @@ subroutine aborts (s)\n     end map\n   end union\n end structure\n+\n structure /s2/\n   union ! U2\n     map ! M4\n@@ -51,9 +52,9 @@ subroutine aborts (s)\n if ( r1.a .eq. 0 ) call aborts (\"basic union 1\")\n \n ! Endian-agnostic runtime check\n-r2.long = z'12345678'\n-if (.not. (     (r2.w1 .eq. z'1234' .and. r2.w2 .eq. z'5678') &\n-           .or. (r2.w1 .eq. z'5678' .and. r2.w2 .eq. z'1234')) ) then\n+r2.long = int(z'12345678')\n+if (.not. (     (r2.w1 .eq. int(z'1234',2) .and. r2.w2 .eq. int(z'5678',2)) &\n+           .or. (r2.w1 .eq. int(z'5678',2) .and. r2.w2 .eq. int(z'1234',2))) ) then\n     call aborts (\"basic union 2\")\n endif\n "}, {"sha": "712b9a437c6f60af86bf746ecd10279a116b9abd", "filename": "gcc/testsuite/gfortran.dg/dec_union_5.f90", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_5.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -25,11 +25,11 @@ subroutine aborts (s)\n record /s5/ r5\n \n ! Unions with arrays\n-r5.a(1) = z'41'\n-r5.a(2) = z'42'\n-r5.a(3) = z'43'\n-r5.a(4) = z'44'\n-r5.a(5) = z'45'\n+r5.a(1) = int(z'41',1)\n+r5.a(2) = int(z'42',1)\n+r5.a(3) = int(z'43',1)\n+r5.a(4) =int( z'44',1)\n+r5.a(5) = int(z'45',1)\n if (     r5.s(1) .ne. 'A' &\n     .or. r5.s(2) .ne. 'B' &\n     .or. r5.s(3) .ne. 'C' &"}, {"sha": "2ed284083f64185e94ac4b10b349de40511ee1b4", "filename": "gcc/testsuite/gfortran.dg/dshift_3.f90", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fdshift_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fdshift_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdshift_3.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -17,7 +17,6 @@ subroutine foo(i, j, k)\n    print *, dshiftl(i, k, 10)           ! { dg-error \"must be the same type and kind\" }\n    print *, dshiftl(k, j, 10)           ! { dg-error \"must be the same type and kind\" }\n    print *, dshiftl(i, j, k)\n-   print *, dshiftl(i, j, z'd')\n \n    print *, dshiftr(i,      j, 134)     ! { dg-error \"must be less than or equal\" }\n    print *, dshiftr(z'FFF', j, 134)     ! { dg-error \"must be less than or equal\" }\n@@ -29,6 +28,5 @@ subroutine foo(i, j, k)\n    print *, dshiftr(i, k, 10)           ! { dg-error \"must be the same type and kind\" }\n    print *, dshiftr(k, j, 10)           ! { dg-error \"must be the same type and kind\" }\n    print *, dshiftr(i, j, k)\n-   print *, dshiftr(i, j, z'd')\n \n end subroutine foo"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/gfortran.dg/gnu_logical_1.F", "status": "modified", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fgnu_logical_1.F", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fgnu_logical_1.F", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgnu_logical_1.F?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -1,91 +0,0 @@\n-! Testcases for the AND, OR and XOR functions (GNU intrinsics).\n-! { dg-do run }\n-! { dg-options \"-ffixed-line-length-none\" }\n-      integer(kind=1) i1, j1\n-      integer(kind=2) i2, j2\n-      integer         i4, j4\n-      integer(kind=8) i8, j8\n-      logical(kind=1) l1, k1\n-      logical(kind=2) l2, k2\n-      logical         l4, k4\n-      logical(kind=8) l8, k8\n-\n-#define TEST_INTEGER(u,ukind,v,vkind) \\\n-      ukind = u;\\\n-      vkind = v;\\\n-      if (iand(u,v) /= and(ukind, vkind)) STOP 1;\\\n-      if (iand(u,v) /= and(vkind, ukind)) STOP 1;\\\n-      if (ieor(u,v) /= xor(ukind, vkind)) STOP 1;\\\n-      if (ieor(u,v) /= xor(vkind, ukind)) STOP 1;\\\n-      if (ior(u,v) /= or(ukind, vkind)) STOP 1;\\\n-      if (ior(u,v) /= or(vkind, ukind)) STOP 1\n-\n-      TEST_INTEGER(19,i1,6,j1)\n-      TEST_INTEGER(19,i1,6,j2)\n-      TEST_INTEGER(19,i1,6,j4)\n-      TEST_INTEGER(19,i1,6,j8)\n-\n-      TEST_INTEGER(19,i2,6,j1)\n-      TEST_INTEGER(19,i2,6,j2)\n-      TEST_INTEGER(19,i2,6,j4)\n-      TEST_INTEGER(19,i2,6,j8)\n-\n-      TEST_INTEGER(19,i4,6,j1)\n-      TEST_INTEGER(19,i4,6,j2)\n-      TEST_INTEGER(19,i4,6,j4)\n-      TEST_INTEGER(19,i4,6,j8)\n-\n-      TEST_INTEGER(19,i8,6,j1)\n-      TEST_INTEGER(19,i8,6,j2)\n-      TEST_INTEGER(19,i8,6,j4)\n-      TEST_INTEGER(19,i8,6,j8)\n-\n-\n-\n-#define TEST_LOGICAL(u,ukind,v,vkind) \\\n-      ukind = u;\\\n-      vkind = v;\\\n-      if ((u .and. v) .neqv. and(ukind, vkind)) STOP 1;\\\n-      if ((u .and. v) .neqv. and(vkind, ukind)) STOP 1;\\\n-      if (((u .and. .not. v) .or. (.not. u .and. v)) .neqv. xor(ukind, vkind)) STOP 1;\\\n-      if (((u .and. .not. v) .or. (.not. u .and. v)) .neqv. xor(vkind, ukind)) STOP 1;\\\n-      if ((u .or. v) .neqv. or(ukind, vkind)) STOP 1;\\\n-      if ((u .or. v) .neqv. or(vkind, ukind)) STOP 2\n-\n-      TEST_LOGICAL(.true.,l1,.false.,k1)\n-      TEST_LOGICAL(.true.,l1,.true.,k1)\n-      TEST_LOGICAL(.true.,l1,.false.,k2)\n-      TEST_LOGICAL(.true.,l1,.true.,k2)\n-      TEST_LOGICAL(.true.,l1,.false.,k4)\n-      TEST_LOGICAL(.true.,l1,.true.,k4)\n-      TEST_LOGICAL(.true.,l1,.false.,k8)\n-      TEST_LOGICAL(.true.,l1,.true.,k8)\n-\n-      TEST_LOGICAL(.true.,l2,.false.,k1)\n-      TEST_LOGICAL(.true.,l2,.true.,k1)\n-      TEST_LOGICAL(.true.,l2,.false.,k2)\n-      TEST_LOGICAL(.true.,l2,.true.,k2)\n-      TEST_LOGICAL(.true.,l2,.false.,k4)\n-      TEST_LOGICAL(.true.,l2,.true.,k4)\n-      TEST_LOGICAL(.true.,l2,.false.,k8)\n-      TEST_LOGICAL(.true.,l2,.true.,k8)\n-\n-      TEST_LOGICAL(.true.,l4,.false.,k1)\n-      TEST_LOGICAL(.true.,l4,.true.,k1)\n-      TEST_LOGICAL(.true.,l4,.false.,k2)\n-      TEST_LOGICAL(.true.,l4,.true.,k2)\n-      TEST_LOGICAL(.true.,l4,.false.,k4)\n-      TEST_LOGICAL(.true.,l4,.true.,k4)\n-      TEST_LOGICAL(.true.,l4,.false.,k8)\n-      TEST_LOGICAL(.true.,l4,.true.,k8)\n-\n-      TEST_LOGICAL(.true.,l8,.false.,k1)\n-      TEST_LOGICAL(.true.,l8,.true.,k1)\n-      TEST_LOGICAL(.true.,l8,.false.,k2)\n-      TEST_LOGICAL(.true.,l8,.true.,k2)\n-      TEST_LOGICAL(.true.,l8,.false.,k4)\n-      TEST_LOGICAL(.true.,l8,.true.,k4)\n-      TEST_LOGICAL(.true.,l8,.false.,k8)\n-      TEST_LOGICAL(.true.,l8,.true.,k8)\n-\n-      end"}, {"sha": "a7b31b4a7e29d8b29f735c9f57f0ed131d879531", "filename": "gcc/testsuite/gfortran.dg/gnu_logical_2.f90", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fgnu_logical_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fgnu_logical_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgnu_logical_2.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -7,23 +7,23 @@\n \n   print *, and(i,i)\n   print *, and(l,l)\n-  print *, and(i,r) ! { dg-error \"must be INTEGER or LOGICAL\" }\n-  print *, and(c,l) ! { dg-error \"must be INTEGER or LOGICAL\" }\n-  print *, and(i,l) ! { dg-error \"must have the same type\" }\n-  print *, and(l,i) ! { dg-error \"must have the same type\" }\n+  print *, and(i,r) ! { dg-error \"must be the same type\" }\n+  print *, and(c,l) ! { dg-error \"must be the same type\" }\n+  print *, and(i,l) ! { dg-error \"must be the same type\" }\n+  print *, and(l,i) ! { dg-error \"must be the same type\" }\n \n   print *, or(i,i)\n   print *, or(l,l)\n-  print *, or(i,r) ! { dg-error \"must be INTEGER or LOGICAL\" }\n-  print *, or(c,l) ! { dg-error \"must be INTEGER or LOGICAL\" }\n-  print *, or(i,l) ! { dg-error \"must have the same type\" }\n-  print *, or(l,i) ! { dg-error \"must have the same type\" }\n+  print *, or(i,r) ! { dg-error \"must be the same type\" }\n+  print *, or(c,l) ! { dg-error \"must be the same type\" }\n+  print *, or(i,l) ! { dg-error \"must be the same type\" }\n+  print *, or(l,i) ! { dg-error \"must be the same type\" }\n \n   print *, xor(i,i)\n   print *, xor(l,l)\n-  print *, xor(i,r) ! { dg-error \"must be INTEGER or LOGICAL\" }\n-  print *, xor(c,l) ! { dg-error \"must be INTEGER or LOGICAL\" }\n-  print *, xor(i,l) ! { dg-error \"must have the same type\" }\n-  print *, xor(l,i) ! { dg-error \"must have the same type\" }\n+  print *, xor(i,r) ! { dg-error \"must be the same type\" }\n+  print *, xor(c,l) ! { dg-error \"must be the same type\" }\n+  print *, xor(i,l) ! { dg-error \"must be the same type\" }\n+  print *, xor(l,i) ! { dg-error \"must be the same type\" }\n \n   end"}, {"sha": "daf0dfd0b783f0d17afcc047de16c4d9af48d361", "filename": "gcc/testsuite/gfortran.dg/int_conv_1.f90", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fint_conv_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fint_conv_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fint_conv_1.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -1,36 +1,25 @@\n ! { dg-do run }\n ! { dg-options \"-std=gnu\" }\n-  integer(kind=2) :: i2, j2, k2, l2, m2, n2, o2\n-  integer(kind=4) :: i4, j4\n-  integer(kind=8) :: i8, j8\n+  integer(kind=2) :: i2, k2, l2\n+  integer(kind=8) :: i8\n   real :: x\n   complex :: z\n \n   i2 = huge(i2) / 3\n   i8 = int8(i2)\n-  i4 = long(i2)\n-  j2 = short(i2)\n   k2 = int2(i2)\n   l2 = int2(i8)\n-  m2 = short(i8)\n-  n2 = int2(i4)\n-  o2 = short(i4)\n \n-  if (i8 /= i2 .or. i4 /= i2 .or. j2 /= i2 .or. k2 /= i2 &\n-      .or. l2 /= i2 .or. m2 /= i2 .or. n2 /= i2 .or. o2 /= i2) STOP 1\n+  if (i8 /= i2 .or. k2 /= i2 .or. l2 /= i2 ) STOP 1\n \n   x = i2\n   i8 = int8(x)\n-  i4 = long(x)\n-  j2 = short(x)\n   k2 = int2(x)\n-  if (i8 /= i2 .or. i4 /= i2 .or. j2 /= i2 .or. k2 /= i2) STOP 2\n+  if (i8 /= i2 .or. k2 /= i2) STOP 2\n \n   z = i2 + (0.,-42.)\n   i8 = int8(z)\n-  i4 = long(z)\n-  j2 = short(z)\n   k2 = int2(z)\n-  if (i8 /= i2 .or. i4 /= i2 .or. j2 /= i2 .or. k2 /= i2) STOP 3\n+  if (i8 /= i2 .or. k2 /= i2) STOP 3\n \n   end"}, {"sha": "ffac32396a1ffe8d34da739535f66fc27a648099", "filename": "gcc/testsuite/gfortran.dg/ishft_1.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fishft_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fishft_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fishft_1.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -25,7 +25,6 @@\n if (ishft (1_8, 1) /= 2) STOP 20\n if (ishft (3_8, 1) /= 6) STOP 21\n if (ishft (-1_8, 1) /= -2) STOP 22\n-if (ishft (-1_8, -60) /= z'F') STOP 23\n \n if (ishftc (1_1, 0) /= 1) STOP 24\n if (ishftc (1_1, 1) /= 2) STOP 25"}, {"sha": "8193b32ed161153aade8c1eaf5f520e289d77474", "filename": "gcc/testsuite/gfortran.dg/merge_bits_3.f90", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fmerge_bits_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fmerge_bits_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmerge_bits_3.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -0,0 +1,5 @@\n+! { dg-do compile }\n+program foo\n+   integer m\n+   m = merge_bits(b'010101', b\"101010\", 42) ! { dg-error \"cannot both be\" }\n+end program foo"}, {"sha": "5622ecb4ee5456294ad1f7133ee676dc1cf00713", "filename": "gcc/testsuite/gfortran.dg/merge_bits_4.f90", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fmerge_bits_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fmerge_bits_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmerge_bits_4.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -0,0 +1,7 @@\n+! { dg-do run }\n+program foo\n+   integer m, n, k\n+   m = merge_bits(b'010101', 1234, 42);   if (m /=  1232) stop 1\n+   n = merge_bits(1234, z'3456', 42);     if (n /= 13398) stop 2\n+   k = merge_bits(1234, 3456, o'12334');  if (k /=  3536) stop 3\n+end program foo"}, {"sha": "707f9e92ef11bf473cd067788fe7f3a3f8c1e714", "filename": "gcc/testsuite/gfortran.dg/nan_4.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_4.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-options \"-std=gnu\" } \n+! { dg-options \"-std=gnu -fallow-invalid-boz\" } \n ! { dg-add-options ieee }\n ! { dg-skip-if \"NaN not supported\" { spu-*-* } }\n !\n@@ -9,8 +9,8 @@\n !\n program test\n   implicit none\n-  real(4), parameter :: r0 = z'FFFFFFFF' ! { dg-error \"Arithmetic NaN\" }\n+  real(4), parameter :: r0 = z'FFFFFFFF'\n   real(4) r\n-  data r/z'FFFFFFFF'/ ! { dg-error \"Arithmetic NaN\" }\n-  r = z'FFFFFFFF' ! { dg-error \"Arithmetic NaN\" }\n+  data r/z'FFFFFFFF'/\n+  r = z'FFFFFFFF'       ! { dg-warning \"neither a DATA statement value\" }\n end program test"}, {"sha": "4653ff060694df17b776640936293fe71d467c2a", "filename": "gcc/testsuite/gfortran.dg/no_range_check_3.f90", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fno_range_check_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fno_range_check_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fno_range_check_3.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -1,6 +1,6 @@\n ! { dg-do run }\n-! { dg-options \"-fno-range-check\" }\n program test\n+  integer(2) :: j, k\n   integer :: i\n   i = int(z'FFFFFFFF',kind(i))\n   if (i /= -1) STOP 1\n@@ -9,4 +9,8 @@ program test\n   if (popcnt(int(z'0F00F00080000001',8)) /= 10) STOP 3\n   if (popcnt(int(z'800F0001',4)) /= 6) STOP 4\n \n+  j = -1234_2\n+  k = int(z'FB2E',kind(j))\n+  if (k /= j) STOP 5\n+  if (int(z'FB2E',kind(j)) /= j) STOP 6\n end program test"}, {"sha": "925eb52ca936fbb11b56490d701555d4c10977ad", "filename": "gcc/testsuite/gfortran.dg/pr16433.f", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr16433.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr16433.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr16433.f?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -1,6 +1,6 @@\n ! { dg-do compile }\n       real x\n       double precision dx\n-      data x/x'2ffde'/ ! { dg-warning \"Hexadecimal constant | used to initialize non-integer\" } \n-      dx = x  ! { dg-bogus \"exadecimal constant\" \"Hex constant where there is none\" }\n+      data x/x'2ffde'/ ! { dg-error \"Hexadecimal constant\" } \n+      dx = x\n       end"}, {"sha": "3bd31c4f8a6ae26396cc4ac5258a15f2d994eb84", "filename": "gcc/testsuite/gfortran.dg/pr44491.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr44491.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr44491.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr44491.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n ! { dg-options \"-std=gnu\" }\n ! PR fortran/44491\n-      character*2 escape /z'1B'/  ! { dg-error \"Incompatible types in DATA\" }\n+      character*2 escape /z'1B'/  ! { dg-error \"cannot appear in\" }\n       end"}, {"sha": "7398c6c812904e8370b850a21d961ef1108d7c25", "filename": "gcc/testsuite/gfortran.dg/pr58027.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr58027.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr58027.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr58027.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n ! PR fortran/58027\n-integer, parameter :: i(1)=(/z'ff800000'/) ! { dg-error \"overflow converting\" }\n+integer, parameter :: i(1)=(/z'ff800000'/) ! { dg-error \"cannot appear in\" }\n print *, isclass\n end"}, {"sha": "a0618cc49b200f568eac1b7253f6f6af212e11f0", "filename": "gcc/testsuite/gfortran.dg/pr81509_2.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr81509_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr81509_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr81509_2.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -12,7 +12,7 @@ program foo\n k = ieor(z'ade',i)\n k = ior(i,z'1111')\n k = ior(i,k)                  ! { dg-error \"different kind type parameters\" }\n-k = and(i,k)\n-k = and(a,z'1234')            ! { dg-error \"must have the same type\" }\n+k = and(i,k)                  ! { dg-error \"must be the same type\" }\n+k = and(a,z'1234')            ! { dg-error \"must be the same type\" }\n end program foo\n "}, {"sha": "61d982dd2d4f403f6a2ca1bd1429ac15ff4c0118", "filename": "gcc/testsuite/gfortran.dg/unf_io_convert_1.f90", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_io_convert_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_io_convert_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_io_convert_1.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -18,9 +18,9 @@ program main\n   integer i\n   character(4) str\n \n-  m(1) = Z'11223344' ! { dg-warning \"BOZ literal at .1. outside a DATA statement\" }\n-  m(2) = Z'55667788' ! { dg-warning \"BOZ literal at .1. outside a DATA statement\" }\n-  n    = Z'77AABBCC' ! { dg-warning \"BOZ literal at .1. outside a DATA statement\" }\n+  m(1) = int(Z'11223344')\n+  m(2) = int(Z'55667788')\n+  n    = int(Z'77AABBCC')\n   str = 'asdf'\n   do i = 1,size\n      r(i) = i\n@@ -46,23 +46,23 @@ program main\n   read(9) str\n   !\n   ! check results\n-  if (m(1).ne.Z'11223344') then\n+  if (m(1).ne.int(Z'11223344')) then\n      if (debug) then\n         print '(A,Z8)','m(1) incorrect.  m(1) = ',m(1)\n      else\n         STOP 1\n      endif\n   endif\n   \n-  if (m(2).ne.Z'55667788') then\n+  if (m(2).ne.int(Z'55667788')) then\n      if (debug) then\n         print '(A,Z8)','m(2) incorrect.  m(2) = ',m(2)\n      else\n         STOP 2\n      endif\n   endif\n   \n-  if (n.ne.Z'77AABBCC') then\n+  if (n.ne.int(Z'77AABBCC')) then\n      if (debug) then\n         print '(A,Z8)','n incorrect.  n = ',n\n      else"}, {"sha": "cc5ab4de5e77b215d26e23450b769d3b62cab861", "filename": "gcc/testsuite/gfortran.dg/unf_io_convert_2.f90", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_io_convert_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_io_convert_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_io_convert_2.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -15,26 +15,28 @@ program main\n   close(10,status=\"delete\")\n \n   open (10, form=\"unformatted\",convert=\"big_endian\") ! { dg-warning \"Extension: CONVERT\" }\n-  i = (/ Z'11223344', Z'55667700' /)\n+  i = (/ int(Z'11223344'), int(Z'55667700') /)\n   write (10) i\n   rewind (10)\n   read (10) b\n-  if (any(b /= (/ Z'11', Z'22', Z'33', Z'44', Z'55', Z'66', Z'77', Z'00' /))) &\n+  if (any(b /= (/ int(Z'11',1), int(Z'22',1), int(Z'33',1), int(Z'44',1), &\n+  &   int(Z'55',1), int(Z'66',1), int(Z'77',1), int(Z'00',1) /))) &\n     STOP 2\n   backspace 10\n   read (10) j\n-  if (j /= Z'1122334455667700') STOP 3\n+  if (j /= int(Z'1122334455667700',8)) STOP 3\n   close (10, status=\"delete\")\n \n   open (10, form=\"unformatted\", convert=\"little_endian\") ! { dg-warning \"Extension: CONVERT\" }\n   write (10) i\n   rewind (10)\n   read (10) b\n-  if (any(b /= (/ Z'44', Z'33', Z'22', Z'11', Z'00', Z'77', Z'66', Z'55' /))) &\n+  if (any(b /= (/ int(Z'44',1), int(Z'33',1), int(Z'22',1), int(Z'11',1), &\n+  &   int(Z'00',1),  int(Z'77',1), int(Z'66',1), int(Z'55',1) /))) &\n     STOP 4\n   backspace 10\n   read (10) j\n-  if (j /= Z'5566770011223344') STOP 5\n+  if (j /= int(Z'5566770011223344',8)) STOP 5\n   close (10, status=\"delete\")\n \n end program main"}, {"sha": "ce7f0fbf1f11347b13a17cebe0c7595e36676dd6", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_fraction_exponent.f90", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_fraction_exponent.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_fraction_exponent.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_fraction_exponent.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -13,25 +13,25 @@ program test_exponent_fraction\n   x = 0.\n   call test_4(x)\n \n-  i = o'00000000001'\n+  i = int(o'00000000001')\n   call test_4(x)\n \n-  i = o'00010000000'\n+  i = int(o'00010000000')\n   call test_4(x)\n \n-  i = o'17700000000'\n+  i = int(o'17700000000')\n   call test_4(x)\n \n-  i = o'00004000001'\n+  i = int(o'00004000001')\n   call test_4(x)\n \n-  i = o'17737777777'\n+  i = int(o'17737777777')\n   call test_4(x)\n \n-  i = o'10000000000'\n+  i = int(o'10000000000')\n   call test_4(x)\n \n-  i = o'0000010000'\n+  i = int(o'0000010000')\n   call test_4(x)\n \n   y = 0.5\n@@ -40,7 +40,7 @@ program test_exponent_fraction\n   y = 0.\n   call test_8(y)\n \n-  j = o'00000000001'\n+  j = int(o'00000000001',8)\n   call test_8(y)\n \n   y = 0.2938735877D-38\n@@ -49,7 +49,7 @@ program test_exponent_fraction\n   y = -1.469369D-39\n   call test_8(y)\n \n-  y = z'7fe00000'\n+  y = real(z'7fe00000',8)\n   call test_8(y)\n \n   y = -5.739719D+42"}, {"sha": "13ff85ea9c86ee7dddf5234089ccd6eddc51f2cc", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_mvbits.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_mvbits.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_mvbits.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_mvbits.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -10,7 +10,7 @@\n if (to /= result) STOP 1\n \n to8 = 0_8\n-from8 = b'1011'*2_8**32\n+from8 = int(b'1011',8)*2_8**32\n call mvbits (from8, 33, 3, to8, 2)\n-if (to8 /= b'10100') STOP 1\n+if (to8 /= int(b'10100',8)) STOP 1\n end"}, {"sha": "222da0a70834f4801d51a6e2dddbb145d25156ec", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_nearest.f90", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_nearest.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_nearest.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_nearest.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -11,23 +11,22 @@ program test_nearest\n   s = 3.0\n   call test_n (s, r)\n \n-  i = z'00800000'\n+  i = int(z'00800000')\n   call test_n (s, r)\n \n-  i = z'007fffff'\n+  i = int(z'007fffff')\n   call test_n (s, r)\n \n-  i = z'00800100'\n+  i = int(z'00800100')\n   call test_n (s, r)\n \n   s = 0\n   x = nearest(s, r)\n   y = nearest(s, -r)\n   if (.not. (x .gt. s .and. y .lt. s )) STOP 1\n \n-! ??? This is pretty sketchy, but passes on most targets.\n-  infi = z'7f800000'\n-  maxi = z'7f7fffff'\n+  infi = int(z'7f800000')\n+  maxi = int(z'7f7fffff')\n \n   call test_up(max, inf)\n   call test_up(-inf, -max)"}, {"sha": "54f2aa78ddd8c0eea304df55122e86c801d64077", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/seq_io.f90", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fseq_io.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fseq_io.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fseq_io.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -16,9 +16,9 @@\n        integer n\n        real*4 r(size)\n        integer i\n-       m(1) = Z'11111111'\n-       m(2) = Z'22222222'\n-       n    = Z'33333333'\n+       m(1) = int(Z'11111111')\n+       m(2) = int(Z'22222222')\n+       n    = int(Z'33333333')\n        do i = 1,size\n          r(i) = i\n        end do\n@@ -39,23 +39,23 @@\n        read(9)r\n !\n ! check results\n-       if (m(1).ne.Z'11111111') then\n+       if (m(1).ne. int(Z'11111111')) then\n          if (debug) then\n             print '(A,Z8)','m(1) incorrect.  m(1) = ',m(1)\n          else\n             STOP 1\n          endif\n        endif\n \n-       if (m(2).ne.Z'22222222') then\n+       if (m(2).ne. int(Z'22222222')) then\n          if (debug) then\n             print '(A,Z8)','m(2) incorrect.  m(2) = ',m(2)\n          else\n             STOP 2\n          endif\n        endif\n \n-       if (n.ne.Z'33333333') then\n+       if (n.ne. int(Z'33333333')) then\n          if (debug) then\n             print '(A,Z8)','n incorrect.  n = ',n\n          else"}, {"sha": "85900470792a72a1ece820f891e7bcf2e3096e6c", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -1,3 +1,8 @@\n+2019-07-23  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\t* testsuite/libgomp.fortran/reduction4.f90: Update BOZ usage\n+\t* testsuite/libgomp.fortran/reduction5.f90: Ditto.\n+\t\n 2019-07-20  Jakub Jelinek  <jakub@redhat.com>\n \n \t* testsuite/libgomp.c-c++-common/loop-1.c: New test."}, {"sha": "498d54605549eca1864104f4e53b31b70df9d1b1", "filename": "libgomp/testsuite/libgomp.fortran/reduction4.f90", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction4.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -4,12 +4,12 @@\n   integer (kind = 4) :: i, ia (6), j, ja (6), k, ka (6), ta (6), n, cnt, x\n   logical :: v\n \n-  i = Z'ffff0f'\n-  ia = Z'f0ff0f'\n-  j = Z'0f0000'\n-  ja = Z'0f5a00'\n-  k = Z'055aa0'\n-  ka = Z'05a5a5'\n+  i = int(Z'ffff0f')\n+  ia = int(Z'f0ff0f')\n+  j = int(Z'0f0000')\n+  ja = int(Z'0f5a00')\n+  k = int(Z'055aa0')\n+  ka = int(Z'05a5a5')\n   v = .false.\n   cnt = -1\n   x = not(0)\n@@ -22,35 +22,35 @@\n   n = omp_get_thread_num ()\n   if (n .eq. 0) then\n     cnt = omp_get_num_threads ()\n-    i = Z'ff7fff'\n-    ia(3:5) = Z'fffff1'\n-    j = Z'078000'\n+    i = int(Z'ff7fff')\n+    ia(3:5) = int(Z'fffff1')\n+    j = int(Z'078000')\n     ja(1:3) = 1\n-    k = Z'78'\n-    ka(3:6) = Z'f0f'\n+    k = int(Z'78')\n+    ka(3:6) = int(Z'f0f')\n   else if (n .eq. 1) then\n-    i = Z'ffff77'\n-    ia(2:5) = Z'ffafff'\n-    j = Z'007800'\n+    i = int(Z'ffff77')\n+    ia(2:5) = int(Z'ffafff')\n+    j = int(Z'007800')\n     ja(2:5) = 8\n-    k = Z'57'\n-    ka(3:4) = Z'f0108'\n+    k = int(Z'57')\n+    ka(3:4) = int(Z'f0108')\n   else\n-    i = Z'777fff'\n-    ia(1:2) = Z'fffff3'\n-    j = Z'000780'\n-    ja(5:6) = Z'f00'\n-    k = Z'1000'\n-    ka(6:6) = Z'777'\n+    i = int(Z'777fff')\n+    ia(1:2) = int(Z'fffff3')\n+    j = int(Z'000780')\n+    ja(5:6) = int(Z'f00')\n+    k = int(Z'1000')\n+    ka(6:6) = int(Z'777')\n   end if\n !$omp end parallel\n   if (v) STOP 1\n   if (cnt .eq. 3) then\n-    ta = (/Z'f0ff03', Z'f0af03', Z'f0af01', Z'f0af01', Z'f0af01', Z'f0ff0f'/)\n-    if (i .ne. Z'777f07' .or. any (ia .ne. ta)) STOP 2\n-    ta = (/Z'f5a01', Z'f5a09', Z'f5a09', Z'f5a08', Z'f5f08', Z'f5f00'/)\n-    if (j .ne. Z'fff80' .or. any (ja .ne. ta)) STOP 3\n-    ta = (/Z'5a5a5', Z'5a5a5', Z'aaba2', Z'aaba2', Z'5aaaa', Z'5addd'/)\n-    if (k .ne. Z'54a8f' .or. any (ka .ne. ta)) STOP 4\n+    ta = (/int(Z'f0ff03'), int(Z'f0af03'), int(Z'f0af01'), int(Z'f0af01'), int(Z'f0af01'), int(Z'f0ff0f')/)\n+    if (i .ne. int(Z'777f07') .or. any (ia .ne. ta)) STOP 2\n+    ta = (/int(Z'f5a01'), int(Z'f5a09'), int(Z'f5a09'), int(Z'f5a08'), int(Z'f5f08'), int(Z'f5f00')/)\n+    if (j .ne. int(Z'fff80') .or. any (ja .ne. ta)) STOP 3\n+    ta = (/int(Z'5a5a5'), int(Z'5a5a5'), int(Z'aaba2'), int(Z'aaba2'), int(Z'5aaaa'), int(Z'5addd')/)\n+    if (k .ne. int(Z'54a8f') .or. any (ka .ne. ta)) STOP 4\n   end if\n end"}, {"sha": "a1d1a8e5425999b530bb2874650ec9bf20a811eb", "filename": "libgomp/testsuite/libgomp.fortran/reduction5.f90", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc63166e0b859546ba53093c5fc6c09925210dd/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc63166e0b859546ba53093c5fc6c09925210dd/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction5.f90?ref=8dc63166e0b859546ba53093c5fc6c09925210dd", "patch": "@@ -10,15 +10,15 @@ end module reduction5\n   subroutine test1\n     use reduction5, bitwise_or => ior\n     integer :: n\n-    n = Z'f'\n+    n = int(Z'f')\n !$omp parallel sections num_threads (3) reduction (bitwise_or: n)\n-    n = ior (n, Z'20')\n+    n = ior (n, int(Z'20'))\n !$omp section\n-    n = bitwise_or (Z'410', n)\n+    n = bitwise_or (int(Z'410'), n)\n !$omp section\n-    n = bitwise_or (n, Z'2000')\n+    n = bitwise_or (n, int(Z'2000'))\n !$omp end parallel sections\n-    if (n .ne. Z'243f') STOP 1\n+    if (n .ne. int(Z'243f')) STOP 1\n   end subroutine\n   subroutine test2\n     use reduction5, min => max, max => min"}]}