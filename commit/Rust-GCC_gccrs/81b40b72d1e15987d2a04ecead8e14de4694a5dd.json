{"sha": "81b40b72d1e15987d2a04ecead8e14de4694a5dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFiNDBiNzJkMWUxNTk4N2QyYTA0ZWNlYWQ4ZTE0ZGU0Njk0YTVkZA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2002-05-30T18:58:31Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2002-05-30T18:58:31Z"}, "message": "lcm.c (output.h): #include.\n\n\t* lcm.c (output.h): #include.\n\t(compute_earliest): Remove hack to treat renumbered EXIT_BLOCK\n\tas an ordinary block.\n\t(optimize_mode_switching): Don't pretend that the exit block is\n\tan ordinary block, or handle sucessors of entry block specially.\n\tInstead, split edges from entry block and to exit block, and\n\tput a computing definition on the thus gained post-entry-block,\n\tand a need on the pre-exit-block.\n\nFrom-SVN: r54064", "tree": {"sha": "ed3abb74f12d0028246c8852eee1f0196a4f7ce8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed3abb74f12d0028246c8852eee1f0196a4f7ce8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81b40b72d1e15987d2a04ecead8e14de4694a5dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81b40b72d1e15987d2a04ecead8e14de4694a5dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81b40b72d1e15987d2a04ecead8e14de4694a5dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81b40b72d1e15987d2a04ecead8e14de4694a5dd/comments", "author": null, "committer": null, "parents": [{"sha": "b1c12c4ba10fc0ee9c8eea601790e2e33290aa44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1c12c4ba10fc0ee9c8eea601790e2e33290aa44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1c12c4ba10fc0ee9c8eea601790e2e33290aa44"}], "stats": {"total": 170, "additions": 63, "deletions": 107}, "files": [{"sha": "b38f8e30a6f1b8fbf27359aaadbefe3edb088e21", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b40b72d1e15987d2a04ecead8e14de4694a5dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b40b72d1e15987d2a04ecead8e14de4694a5dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81b40b72d1e15987d2a04ecead8e14de4694a5dd", "patch": "@@ -1,3 +1,14 @@\n+Thu May 30 19:54:30 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* lcm.c (output.h): #include.\n+\t(compute_earliest): Remove hack to treat renumbered EXIT_BLOCK\n+\tas an ordinary block.\n+\t(optimize_mode_switching): Don't pretend that the exit block is\n+\tan ordinary block, or handle sucessors of entry block specially.\n+\tInstead, split edges from entry block and to exit block, and\n+\tput a computing definition on the thus gained post-entry-block,\n+\tand a need on the pre-exit-block.\n+\n Thu May 30 20:28:01 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* gengenrtl.c (type_from_format, accessor_from_format): Support 'B'."}, {"sha": "783c70f7f0a6161e4d3579884e69263f3e86d924", "filename": "gcc/lcm.c", "status": "modified", "additions": 52, "deletions": 107, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b40b72d1e15987d2a04ecead8e14de4694a5dd/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b40b72d1e15987d2a04ecead8e14de4694a5dd/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=81b40b72d1e15987d2a04ecead8e14de4694a5dd", "patch": "@@ -59,6 +59,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"insn-config.h\"\n #include \"recog.h\"\n #include \"basic-block.h\"\n+#include \"output.h\"\n #include \"tm_p.h\"\n \n /* We want target macros for the mode switching code to be able to refer\n@@ -207,11 +208,7 @@ compute_earliest (edge_list, n_exprs, antin, antout, avout, kill, earliest)\n \tsbitmap_copy (earliest[x], antin[succ->index]);\n       else\n         {\n-\t  /* We refer to the EXIT_BLOCK index, instead of testing for\n-\t     EXIT_BLOCK_PTR, so that EXIT_BLOCK_PTR's index can be\n-\t     changed so as to pretend it's a regular block, so that\n-\t     its antin can be taken into account.  */\n-\t  if (succ->index == EXIT_BLOCK)\n+\t  if (succ == EXIT_BLOCK_PTR)\n \t    sbitmap_zero (earliest[x]);\n \t  else\n \t    {\n@@ -1027,43 +1024,54 @@ optimize_mode_switching (file)\n   int n_entities;\n   int max_num_modes = 0;\n   bool emited = false;\n+  basic_block post_entry, pre_exit ATTRIBUTE_UNUSED;\n \n   clear_bb_flags ();\n-#ifdef NORMAL_MODE\n-  /* Increment last_basic_block before allocating bb_info.  */\n-  last_basic_block++;\n-#endif\n \n   for (e = N_ENTITIES - 1, n_entities = 0; e >= 0; e--)\n     if (OPTIMIZE_MODE_SWITCHING (e))\n       {\n-\t/* Create the list of segments within each basic block.  */\n+\tint entry_exit_extra = 0;\n+\n+\t/* Create the list of segments within each basic block.\n+\t   If NORMAL_MODE is defined, allow for two extra\n+\t   blocks split from the entry and exit block. */\n+#ifdef NORMAL_MODE\n+\tentry_exit_extra = 2;\n+#endif\n \tbb_info[n_entities]\n-\t  = (struct bb_info *) xcalloc (last_basic_block, sizeof **bb_info);\n+\t  = (struct bb_info *) xcalloc (last_basic_block + entry_exit_extra,\n+\t\t\t\t\tsizeof **bb_info);\n \tentity_map[n_entities++] = e;\n \tif (num_modes[e] > max_num_modes)\n \t  max_num_modes = num_modes[e];\n       }\n \n-#ifdef NORMAL_MODE\n-  /* Decrement it back in case we return below.  */\n-  last_basic_block--;\n-#endif\n-\n   if (! n_entities)\n     return 0;\n \n #ifdef NORMAL_MODE\n-  /* We're going to pretend the EXIT_BLOCK is a regular basic block,\n-     so that switching back to normal mode when entering the\n-     EXIT_BLOCK isn't optimized away.  We do this by incrementing the\n-     basic block count, growing the VARRAY of basic_block_info and\n-     appending the EXIT_BLOCK_PTR to it.  */\n-  last_basic_block++;\n-  if (VARRAY_SIZE (basic_block_info) < last_basic_block)\n-    VARRAY_GROW (basic_block_info, last_basic_block);\n-  BASIC_BLOCK (last_basic_block - 1) = EXIT_BLOCK_PTR;\n-  EXIT_BLOCK_PTR->index = last_basic_block - 1;\n+  {\n+    /* Split the edge from the entry block and the fallthrough edge to the\n+       exit block, so that we can note that there NORMAL_MODE is supplied /\n+       required.  */\n+    edge eg;\n+    post_entry = split_edge (ENTRY_BLOCK_PTR->succ);\n+    /* The only non-call predecessor at this stage is a block with a\n+       fallthrough edge; there can be at most one, but there could be\n+       none at all, e.g. when exit is called.  */\n+    for (pre_exit = 0, eg = EXIT_BLOCK_PTR->pred; eg; eg = eg->pred_next)\n+      if (eg->flags & EDGE_FALLTHRU)\n+\t{\n+\t  regset live_at_end = eg->src->global_live_at_end;\n+\n+\t  if (pre_exit)\n+\t    abort ();\n+\t  pre_exit = split_edge (eg);\n+\t  COPY_REG_SET (pre_exit->global_live_at_start, live_at_end);\n+\t  COPY_REG_SET (pre_exit->global_live_at_end, live_at_end);\n+\t}\n+  }\n #endif\n \n   /* Create the bitmap vectors.  */\n@@ -1124,7 +1132,7 @@ optimize_mode_switching (file)\n \t  /* Check for blocks without ANY mode requirements.  */\n \t  if (last_mode == no_mode)\n \t    {\n-\t      ptr = new_seginfo (no_mode, insn, bb->index, live_now);\n+\t      ptr = new_seginfo (no_mode, bb->end, bb->index, live_now);\n \t      add_seginfo (info + bb->index, ptr);\n \t    }\n \t}\n@@ -1134,36 +1142,21 @@ optimize_mode_switching (file)\n \n \tif (mode != no_mode)\n \t  {\n-\t    edge eg;\n+\t    bb = post_entry;\n \n-\t    for (eg = ENTRY_BLOCK_PTR->succ; eg; eg = eg->succ_next)\n-\t      {\n-\t\tbb = eg->dest;\n-\n-\t        /* By always making this nontransparent, we save\n-\t\t   an extra check in make_preds_opaque.  We also\n-\t\t   need this to avoid confusing pre_edge_lcm when\n-\t\t   antic is cleared but transp and comp are set.  */\n-\t\tRESET_BIT (transp[bb->index], j);\n-\n-\t\t/* If the block already has MODE, pretend it\n-\t\t   has none (because we don't need to set it),\n-\t\t   but retain whatever mode it computes.  */\n-\t\tif (info[bb->index].seginfo->mode == mode)\n-\t\t  info[bb->index].seginfo->mode = no_mode;\n-\n-\t\t/* Insert a fake computing definition of MODE into entry\n-\t\t   blocks which compute no mode. This represents the mode on\n-\t\t   entry.  */\n-\t\telse if (info[bb->index].computing == no_mode)\n-\t\t  {\n-\t\t    info[bb->index].computing = mode;\n-\t\t    info[bb->index].seginfo->mode = no_mode;\n-\t\t  }\n-\t      }\n+\t    /* By always making this nontransparent, we save\n+\t       an extra check in make_preds_opaque.  We also\n+\t       need this to avoid confusing pre_edge_lcm when\n+\t       antic is cleared but transp and comp are set.  */\n+\t    RESET_BIT (transp[bb->index], j);\n \n-\t    bb = EXIT_BLOCK_PTR;\n-\t    info[bb->index].seginfo->mode = mode;\n+\t    /* Insert a fake computing definition of MODE into entry\n+\t       blocks which compute no mode. This represents the mode on\n+\t       entry.  */\n+\t    info[bb->index].computing = mode;\n+\n+\t    if (pre_exit)\n+\t      info[pre_exit->index].seginfo->mode = mode;\n \t  }\n       }\n #endif /* NORMAL_MODE */\n@@ -1288,63 +1281,11 @@ optimize_mode_switching (file)\n       free_edge_list (edge_list);\n     }\n \n-#ifdef NORMAL_MODE\n-  /* Restore the special status of EXIT_BLOCK.  */\n-  last_basic_block--;\n-  VARRAY_POP (basic_block_info);\n-  EXIT_BLOCK_PTR->index = EXIT_BLOCK;\n-#endif\n-\n   /* Now output the remaining mode sets in all the segments.  */\n   for (j = n_entities - 1; j >= 0; j--)\n     {\n       int no_mode = num_modes[entity_map[j]];\n \n-#ifdef NORMAL_MODE\n-      if (bb_info[j][last_basic_block].seginfo->mode != no_mode)\n-\t{\n-\t  edge eg;\n-\t  struct seginfo *ptr = bb_info[j][last_basic_block].seginfo;\n-\n-\t  for (eg = EXIT_BLOCK_PTR->pred; eg; eg = eg->pred_next)\n-\t    {\n-\t      rtx mode_set;\n-\n-\t      if (bb_info[j][eg->src->index].computing == ptr->mode)\n-\t\tcontinue;\n-\n-\t      start_sequence ();\n-\t      EMIT_MODE_SET (entity_map[j], ptr->mode, ptr->regs_live);\n-\t      mode_set = gen_sequence ();\n-\t      end_sequence ();\n-\n-\t      /* Do not bother to insert empty sequence.  */\n-\t      if (GET_CODE (mode_set) == SEQUENCE\n-\t\t  && !XVECLEN (mode_set, 0))\n-\t\tcontinue;\n-\n-\t      /* If this is an abnormal edge, we'll insert at the end of the\n-\t\t previous block.  */\n-\t      if (eg->flags & EDGE_ABNORMAL)\n-\t\t{\n-\t\t  emited = true;\n-\t\t  if (GET_CODE (eg->src->end) == JUMP_INSN)\n-\t\t    emit_insn_before (mode_set, eg->src->end);\n-\t\t  else if (GET_CODE (eg->src->end) == INSN)\n-\t\t    emit_insn_after (mode_set, eg->src->end);\n-\t\t  else\n-\t\t    abort ();\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  need_commit = 1;\n-\t\t  insert_insn_on_edge (mode_set, eg);\n-\t\t}\n-\t    }\n-\n-\t}\n-#endif\n-\n       FOR_EACH_BB_REVERSE (bb)\n \t{\n \t  struct seginfo *ptr, *next;\n@@ -1393,8 +1334,12 @@ optimize_mode_switching (file)\n   if (need_commit)\n     commit_edge_insertions ();\n \n+#ifdef NORMAL_MODE\n+  cleanup_cfg (CLEANUP_NO_INSN_DEL);\n+#else\n   if (!need_commit && !emited)\n     return 0;\n+#endif\n \n   max_regno = max_reg_num ();\n   allocate_reg_info (max_regno, FALSE, FALSE);"}]}