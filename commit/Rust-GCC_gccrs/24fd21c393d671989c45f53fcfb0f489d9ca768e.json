{"sha": "24fd21c393d671989c45f53fcfb0f489d9ca768e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRmZDIxYzM5M2Q2NzE5ODljNDVmNTNmY2ZiMGY0ODlkOWNhNzY4ZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T11:31:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T11:31:06Z"}, "message": "[multiple changes]\n\n2015-10-26  Yannick Moy  <moy@adacore.com>\n\n\t* lib-xref-spark_specific.adb (Add_SPARK_Xrefs): Use character 'r' to\n\tdenote a reference to a constant which may have variable input, and\n\tthus may be treated as a variable in GNATprove, instead of the\n\tcharacter 'c' used for constants.\n\n2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_util.adb (Object_Access_Level): Only aliased formals of\n\tfunctions have the accessibility level of the point of call;\n\taliased formals of procedures have the same level as unaliased\n\tformals.\n\t(New_Copy_Tree): Add guard on copying itypes. From code reading.\n\nFrom-SVN: r229337", "tree": {"sha": "0f9950631aa45cfa54c57c97b5eed3b4ebc9d641", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f9950631aa45cfa54c57c97b5eed3b4ebc9d641"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24fd21c393d671989c45f53fcfb0f489d9ca768e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24fd21c393d671989c45f53fcfb0f489d9ca768e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24fd21c393d671989c45f53fcfb0f489d9ca768e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24fd21c393d671989c45f53fcfb0f489d9ca768e/comments", "author": null, "committer": null, "parents": [{"sha": "529ce461f0ec3b81458e8478a1342e7a89a43861", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/529ce461f0ec3b81458e8478a1342e7a89a43861", "html_url": "https://github.com/Rust-GCC/gccrs/commit/529ce461f0ec3b81458e8478a1342e7a89a43861"}], "stats": {"total": 177, "additions": 123, "deletions": 54}, "files": [{"sha": "f2deda17c4e60f9290af9011fe1db990ac2be54b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24fd21c393d671989c45f53fcfb0f489d9ca768e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24fd21c393d671989c45f53fcfb0f489d9ca768e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=24fd21c393d671989c45f53fcfb0f489d9ca768e", "patch": "@@ -1,3 +1,18 @@\n+2015-10-26  Yannick Moy  <moy@adacore.com>\n+\n+\t* lib-xref-spark_specific.adb (Add_SPARK_Xrefs): Use character 'r' to\n+\tdenote a reference to a constant which may have variable input, and\n+\tthus may be treated as a variable in GNATprove, instead of the\n+\tcharacter 'c' used for constants.\n+\n+2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_util.adb (Object_Access_Level): Only aliased formals of\n+\tfunctions have the accessibility level of the point of call;\n+\taliased formals of procedures have the same level as unaliased\n+\tformals.\n+\t(New_Copy_Tree): Add guard on copying itypes. From code reading.\n+\n 2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* inline.adb: Minor reformatting."}, {"sha": "a53942d59f9e6baac2d0de1c398d7b0051f268a7", "filename": "gcc/ada/lib-xref-spark_specific.adb", "status": "modified", "additions": 95, "deletions": 49, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24fd21c393d671989c45f53fcfb0f489d9ca768e/gcc%2Fada%2Flib-xref-spark_specific.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24fd21c393d671989c45f53fcfb0f489d9ca768e/gcc%2Fada%2Flib-xref-spark_specific.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-spark_specific.adb?ref=24fd21c393d671989c45f53fcfb0f489d9ca768e", "patch": "@@ -272,9 +272,7 @@ package body SPARK_Specific is\n          =>\n             Typ := Xref_Entity_Letters (Ekind (E));\n \n-         when E_Package_Body\n-            | E_Subprogram_Body\n-         =>\n+         when E_Package_Body | E_Subprogram_Body =>\n             Typ := Xref_Entity_Letters (Ekind (Unique_Entity (E)));\n \n          when E_Void =>\n@@ -317,6 +315,16 @@ package body SPARK_Specific is\n       function Get_Entity_Type (E : Entity_Id) return Character;\n       --  Return a character representing the type of entity\n \n+      function Is_Constant_Object_Without_Variable_Input\n+        (E : Entity_Id) return Boolean;\n+      --  Return True if E is known to have no variable input, as defined in\n+      --  SPARK RM.\n+\n+      function Is_Future_Scope_Entity\n+        (E : Entity_Id;\n+         S : Scope_Index) return Boolean;\n+      --  Check whether entity E is in SPARK_Scope_Table at index S or higher\n+\n       function Is_SPARK_Reference\n         (E   : Entity_Id;\n          Typ : Character) return Boolean;\n@@ -327,11 +335,6 @@ package body SPARK_Specific is\n       --  Return whether the entity or reference scope meets requirements for\n       --  being an SPARK scope.\n \n-      function Is_Future_Scope_Entity\n-        (E : Entity_Id;\n-         S : Scope_Index) return Boolean;\n-      --  Check whether entity E is in SPARK_Scope_Table at index S or higher\n-\n       function Lt (Op1 : Natural; Op2 : Natural) return Boolean;\n       --  Comparison function for Sort call\n \n@@ -418,48 +421,47 @@ package body SPARK_Specific is\n          return Scopes.Get (N).Num;\n       end Get_Scope_Num;\n \n-      ------------------------\n-      -- Is_SPARK_Reference --\n-      ------------------------\n+      -----------------------------------------------\n+      -- Is_Constant_Object_Without_Variable_Input --\n+      -----------------------------------------------\n \n-      function Is_SPARK_Reference\n-        (E   : Entity_Id;\n-         Typ : Character) return Boolean\n+      function Is_Constant_Object_Without_Variable_Input\n+        (E : Entity_Id) return Boolean\n       is\n+         Result : Boolean;\n+\n       begin\n-         --  The only references of interest on callable entities are calls. On\n-         --  non-callable entities, the only references of interest are reads\n-         --  and writes.\n+         case Ekind (E) is\n \n-         if Ekind (E) in Overloadable_Kind then\n-            return Typ = 's';\n+            --  A constant is known to have no variable input if its\n+            --  initializing expression is static (a value which is\n+            --  compile-time-known is not guaranteed to have no variable input\n+            --  as defined in the SPARK RM). Otherwise, the constant may or not\n+            --  have variable input.\n \n-         --  Objects of Task type or protected type are not SPARK references\n+            when E_Constant =>\n+               declare\n+                  Decl : Node_Id;\n+               begin\n+                  if Present (Full_View (E)) then\n+                     Decl := Parent (Full_View (E));\n+                  else\n+                     Decl := Parent (E);\n+                  end if;\n \n-         elsif Present (Etype (E))\n-           and then Ekind (Etype (E)) in Concurrent_Kind\n-         then\n-            return False;\n+                  pragma Assert (Present (Expression (Decl)));\n+                  Result := Is_Static_Expression (Expression (Decl));\n+               end;\n \n-         --  In all other cases, result is true for reference/modify cases,\n-         --  and false for all other cases.\n+            when E_Loop_Parameter | E_In_Parameter =>\n+               Result := True;\n \n-         else\n-            return Typ = 'r' or else Typ = 'm';\n-         end if;\n-      end Is_SPARK_Reference;\n+            when others =>\n+               Result := False;\n+         end case;\n \n-      --------------------\n-      -- Is_SPARK_Scope --\n-      --------------------\n-\n-      function Is_SPARK_Scope (E : Entity_Id) return Boolean is\n-      begin\n-         return Present (E)\n-           and then not Is_Generic_Unit (E)\n-           and then Renamed_Entity (E) = Empty\n-           and then Get_Scope_Num (E) /= No_Scope;\n-      end Is_SPARK_Scope;\n+         return Result;\n+      end Is_Constant_Object_Without_Variable_Input;\n \n       ----------------------------\n       -- Is_Future_Scope_Entity --\n@@ -511,6 +513,49 @@ package body SPARK_Specific is\n          return False;\n       end Is_Future_Scope_Entity;\n \n+      ------------------------\n+      -- Is_SPARK_Reference --\n+      ------------------------\n+\n+      function Is_SPARK_Reference\n+        (E   : Entity_Id;\n+         Typ : Character) return Boolean\n+      is\n+      begin\n+         --  The only references of interest on callable entities are calls. On\n+         --  non-callable entities, the only references of interest are reads\n+         --  and writes.\n+\n+         if Ekind (E) in Overloadable_Kind then\n+            return Typ = 's';\n+\n+         --  Objects of Task type or protected type are not SPARK references\n+\n+         elsif Present (Etype (E))\n+           and then Ekind (Etype (E)) in Concurrent_Kind\n+         then\n+            return False;\n+\n+         --  In all other cases, result is true for reference/modify cases,\n+         --  and false for all other cases.\n+\n+         else\n+            return Typ = 'r' or else Typ = 'm';\n+         end if;\n+      end Is_SPARK_Reference;\n+\n+      --------------------\n+      -- Is_SPARK_Scope --\n+      --------------------\n+\n+      function Is_SPARK_Scope (E : Entity_Id) return Boolean is\n+      begin\n+         return Present (E)\n+           and then not Is_Generic_Unit (E)\n+           and then Renamed_Entity (E) = Empty\n+           and then Get_Scope_Num (E) /= No_Scope;\n+      end Is_SPARK_Scope;\n+\n       --------\n       -- Lt --\n       --------\n@@ -819,12 +864,15 @@ package body SPARK_Specific is\n                Col  := Int (Get_Column_Number (Ref_Entry.Def));\n             end if;\n \n-            --  References to constant objects are considered specially in\n-            --  SPARK section, because these will be translated as constants in\n-            --  the intermediate language for formal verification, and should\n-            --  therefore never appear in frame conditions.\n+            --  References to constant objects without variable inputs (see\n+            --  SPARK RM 3.3.1) are considered specially in SPARK section,\n+            --  because these will be translated as constants in the\n+            --  intermediate language for formal verification, and should\n+            --  therefore never appear in frame conditions. Other constants may\n+            --  later be treated the same, up to GNATprove to decide based on\n+            --  its flow analysis.\n \n-            if Is_Constant_Object (Ref.Ent) then\n+            if Is_Constant_Object_Without_Variable_Input (Ref.Ent) then\n                Typ := 'c';\n             else\n                Typ := Ref.Typ;\n@@ -1230,9 +1278,7 @@ package body SPARK_Specific is\n          when N_Subprogram_Declaration =>\n             null;\n \n-         when N_Entry_Body\n-            | N_Subprogram_Body\n-         =>\n+         when N_Entry_Body | N_Subprogram_Body =>\n             if not Is_Generic_Subprogram (Defining_Entity (N)) then\n                Traverse_Subprogram_Body (N, Process, Inside_Stubs);\n             end if;"}, {"sha": "464619a2061623c6d416b35dc2f55129b3525309", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24fd21c393d671989c45f53fcfb0f489d9ca768e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24fd21c393d671989c45f53fcfb0f489d9ca768e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=24fd21c393d671989c45f53fcfb0f489d9ca768e", "patch": "@@ -15330,7 +15330,10 @@ package body Sem_Util is\n             while Present (Elmt) loop\n                Next_Elmt (Elmt);\n                New_Itype := Node (Elmt);\n-               Copy_Itype_With_Replacement (New_Itype);\n+\n+               if Is_Itype (New_Itype) then\n+                  Copy_Itype_With_Replacement (New_Itype);\n+               end if;\n                Next_Elmt (Elmt);\n             end loop;\n          end;\n@@ -16041,10 +16044,15 @@ package body Sem_Util is\n             return Type_Access_Level (Scope (E)) + 1;\n \n          else\n-            --  Aliased formals take their access level from the point of call.\n-            --  This is smaller than the level of the subprogram itself.\n-\n-            if Is_Formal (E) and then Is_Aliased (E) then\n+            --  Aliased formals of functions take their access level from the\n+            --  point of call, i.e. require a dynamic check. For static check\n+            --  purposes, this is smaller than the level of the subprogram\n+            --  itself. For procedures the aliased makes no difference.\n+\n+            if Is_Formal (E)\n+               and then Is_Aliased (E)\n+               and then Ekind (Scope (E)) = E_Function\n+            then\n                return Type_Access_Level (Etype (E));\n \n             else"}]}