{"sha": "7bac1be089a8a64dbbaeba20856e5441b5f1794d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JhYzFiZTA4OWE4YTY0ZGJiYWViYTIwODU2ZTU0NDFiNWYxNzk0ZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-05T13:05:42Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-05T13:05:42Z"}, "message": "(memory_extend_rtx): New variable.\n\n(cse_main): Initialize it.\n(cse_insn): See if we have already loaded a MEM in a wider  mode.\n\nFrom-SVN: r6484", "tree": {"sha": "faf69af25525c459c820b307b367688fbeeff6d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/faf69af25525c459c820b307b367688fbeeff6d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7bac1be089a8a64dbbaeba20856e5441b5f1794d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bac1be089a8a64dbbaeba20856e5441b5f1794d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bac1be089a8a64dbbaeba20856e5441b5f1794d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bac1be089a8a64dbbaeba20856e5441b5f1794d/comments", "author": null, "committer": null, "parents": [{"sha": "17a08984d38e8bc6cf581651a8dcc02ee2a11f26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17a08984d38e8bc6cf581651a8dcc02ee2a11f26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17a08984d38e8bc6cf581651a8dcc02ee2a11f26"}], "stats": {"total": 61, "additions": 60, "deletions": 1}, "files": [{"sha": "e2a49efad7f0df3b322f3f6881b229d7307ea755", "filename": "gcc/cse.c", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bac1be089a8a64dbbaeba20856e5441b5f1794d/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bac1be089a8a64dbbaeba20856e5441b5f1794d/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=7bac1be089a8a64dbbaeba20856e5441b5f1794d", "patch": "@@ -348,6 +348,12 @@ static int cse_jumps_altered;\n \n static int do_not_record;\n \n+#ifdef LOAD_EXTEND_OP\n+\n+/* Scratch rtl used when looking for load-extended copy of a MEM.  */\n+static rtx memory_extend_rtx;\n+#endif\n+\n /* canon_hash stores 1 in hash_arg_in_memory\n    if it notices a reference to memory within the expression being hashed.  */\n \n@@ -6378,7 +6384,53 @@ cse_insn (insn, in_libcall_block)\n \t\t}\n \t    }\n \t}\n-\t\t  \n+\n+#ifdef LOAD_EXTEND_OP\n+      /* See if a MEM has already been loaded with a widening operation;\n+\t if it has, we can use a subreg of that.  Many CISC machines\n+\t also have such operations, but this is only likely to be\n+\t beneficial these machines.  */\n+      \n+      if (flag_expensive_optimizations &&  src_related == 0\n+\t  && (GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n+\t  && GET_MODE_CLASS (mode) == MODE_INT\n+\t  && GET_CODE (src) == MEM && ! do_not_record\n+\t  && LOAD_EXTEND_OP (mode) != NIL)\n+\t{\n+\t  enum machine_mode tmode;\n+\t  \n+\t  /* Set what we are trying to extend and the operation it might\n+\t     have been extended with.  */\n+\t  PUT_CODE (memory_extend_rtx, LOAD_EXTEND_OP (mode));\n+\t  XEXP (memory_extend_rtx, 0) = src;\n+\t  \n+\t  for (tmode = GET_MODE_WIDER_MODE (mode);\n+\t       GET_MODE_SIZE (tmode) <= UNITS_PER_WORD;\n+\t       tmode = GET_MODE_WIDER_MODE (tmode))\n+\t    {\n+\t      struct table_elt *larger_elt;\n+\t      \n+\t      PUT_MODE (memory_extend_rtx, tmode);\n+\t      larger_elt = lookup (memory_extend_rtx, \n+\t\t\t\t   HASH (memory_extend_rtx, tmode), tmode);\n+\t      if (larger_elt == 0)\n+\t\tcontinue;\n+\t      \n+\t      for (larger_elt = larger_elt->first_same_value;\n+\t\t   larger_elt; larger_elt = larger_elt->next_same_value)\n+\t\tif (GET_CODE (larger_elt->exp) == REG)\n+\t\t  {\n+\t\t    src_related = gen_lowpart_if_possible (mode, \n+\t\t\t\t\t\t\t   larger_elt->exp);\n+\t\t    break;\n+\t\t  }\n+\t      \n+\t      if (src_related)\n+\t\tbreak;\n+\t    }\n+\t}\n+#endif /* LOAD_EXTEND_OP */\n+ \n       if (src == src_folded)\n         src_folded = 0;\n \n@@ -7916,6 +7968,13 @@ cse_main (f, nregs, after_loop, file)\n   reg_in_table = (int *) alloca (nregs * sizeof (int));\n   reg_tick = (int *) alloca (nregs * sizeof (int));\n \n+#ifdef LOAD_EXTEND_OP\n+\n+  /* Allocate scratch rtl here.  cse_insn will fill in the memory reference\n+     and change the code and mode as appropriate.  */\n+  memory_extend_rtx = gen_rtx (ZERO_EXTEND, VOIDmode, 0);\n+#endif\n+\n   /* Discard all the free elements of the previous function\n      since they are allocated in the temporarily obstack.  */\n   bzero (table, sizeof table);"}]}