{"sha": "f903b91f37ac738712b8a6494ce261ebccaad9c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkwM2I5MWYzN2FjNzM4NzEyYjhhNjQ5NGNlMjYxZWJjY2FhZDljMQ==", "commit": {"author": {"name": "David S. Miller", "email": "davem@pierdol.cobaltmicro.com", "date": "1998-07-13T03:34:12Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1998-07-13T03:34:12Z"}, "message": "More efficient version of Jul 10 bugfix of mine, as discussed on egcs-patches.\n\nMore efficient version of Jul 10 bugfix of mine, as\ndiscussed on egcs-patches.\n\t* regclass.c (reg_scan_mark_refs): New arg min_regno.  Only update\n\tregscan information for REGs with numbers greater than or equal to\n\tthis.  All callers changed.\n\t(reg_scan_update): New function to efficiently update regscan\n\tinformation on the fly.\n\t* rtl.h: Add prototype.\n\t* jump.c (jump_optimize): Call it when we make a transformation\n\twhich generates new pseudo-REGs.\n\nFrom-SVN: r21096", "tree": {"sha": "13bf604991dc573e48b0831d75446e37541a2e97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13bf604991dc573e48b0831d75446e37541a2e97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f903b91f37ac738712b8a6494ce261ebccaad9c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f903b91f37ac738712b8a6494ce261ebccaad9c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f903b91f37ac738712b8a6494ce261ebccaad9c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f903b91f37ac738712b8a6494ce261ebccaad9c1/comments", "author": null, "committer": null, "parents": [{"sha": "1b07eafaae2a861b9afe080be61cbfc4cdf75c66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b07eafaae2a861b9afe080be61cbfc4cdf75c66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b07eafaae2a861b9afe080be61cbfc4cdf75c66"}], "stats": {"total": 136, "additions": 108, "deletions": 28}, "files": [{"sha": "2ea15267abbd9cb87a3369d3ee102ffe6f596639", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f903b91f37ac738712b8a6494ce261ebccaad9c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f903b91f37ac738712b8a6494ce261ebccaad9c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f903b91f37ac738712b8a6494ce261ebccaad9c1", "patch": "@@ -1,3 +1,14 @@\n+Mon Jul 13 02:24:08 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n+\n+\t* regclass.c (reg_scan_mark_refs): New arg min_regno.  Only update\n+\tregscan information for REGs with numbers greater than or equal to\n+\tthis.  All callers changed.\n+\t(reg_scan_update): New function to efficiently update regscan\n+\tinformation on the fly.\n+\t* rtl.h: Add prototype.\n+\t* jump.c (jump_optimize): Call it when we make a transformation\n+\twhich generates new pseudo-REGs.\n+\n Sun Jul 12 13:08:14 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* collect2.c (main): Use \"-x c\" instead of \"-lang-c\" for force the"}, {"sha": "fce3dc027718743597a6c44aa9edcb73c9453b17", "filename": "gcc/jump.c", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f903b91f37ac738712b8a6494ce261ebccaad9c1/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f903b91f37ac738712b8a6494ce261ebccaad9c1/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=f903b91f37ac738712b8a6494ce261ebccaad9c1", "patch": "@@ -605,15 +605,6 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t  int this_is_simplejump, this_is_condjump, reversep = 0;\n \t  int this_is_condjump_in_parallel;\n \n-\t  /* If one of our transformations has created more REGs we\n-\t     must rerun reg_scan or else we risk missed optimizations,\n-\t     erroneous optimizations, or even worse a crash.  */\n-\t  if (after_regscan &&\n-\t      old_max_reg < max_reg_num ())\n-\t    {\n-\t      reg_scan (f, max_reg_num (), 0);\n-\t      old_max_reg = max_reg_num ();\n-\t    }\n #if 0\n \t  /* If NOT the first iteration, if this is the last jump pass\n \t     (just before final), do the special peephole optimizations.\n@@ -987,7 +978,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t     We set:\n \n \t     TEMP to the \"x = exp;\" insn.\n-\t     TEMP1 to the single set in the \"x = exp; insn.\n+\t     TEMP1 to the single set in the \"x = exp;\" insn.\n \t     TEMP2 to \"x\".  */\n \n \t  if (! reload_completed\n@@ -1021,6 +1012,12 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t\t\t\t\t   PREV_INSN (temp3), temp);\n \t\t  delete_insn (temp);\n \t\t  reallabelprev = prev_active_insn (JUMP_LABEL (insn));\n+\n+\t\t  if (after_regscan)\n+\t\t    {\n+\t\t      reg_scan_update (temp3, NEXT_INSN (next), old_max_reg);\n+\t\t      old_max_reg = max_reg_num ();\n+\t\t    }\n \t\t}\n \t    }\n \n@@ -1073,6 +1070,12 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t  delete_insn (temp);\n \t\t  delete_insn (temp3);\n \t\t  reallabelprev = prev_active_insn (JUMP_LABEL (insn));\n+\n+\t\t  if (after_regscan)\n+\t\t    {\n+\t\t      reg_scan_update (temp6, NEXT_INSN (next), old_max_reg);\n+\t\t      old_max_reg = max_reg_num ();\n+\t\t    }\n \t\t}\n \t    }\n \n@@ -1133,6 +1136,12 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t  delete_insn (temp);\n \t\t  delete_insn (temp3);\n \t\t  reallabelprev = prev_active_insn (JUMP_LABEL (insn));\n+\n+\t\t  if (after_regscan)\n+\t\t    {\n+\t\t      reg_scan_update (temp6, NEXT_INSN (next), old_max_reg);\n+\t\t      old_max_reg = max_reg_num ();\n+\t\t    }\n \t\t}\n \t    }\n #endif /* HAVE_cc0 */\n@@ -1244,7 +1253,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \n \t\tif (target)\n \t\t  {\n-\t\t    rtx seq1,seq2;\n+\t\t    rtx seq1,seq2,last;\n \n \t\t    /* Save the conditional move sequence but don't emit it\n \t\t       yet.  On some machines, like the alpha, it is possible\n@@ -1266,13 +1275,20 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t    emit_insns_before (seq1, temp5);\n \t\t    /* Insert conditional move after insn, to be sure that\n \t\t       the jump and a possible compare won't be separated */\n-\t\t    emit_insns_after (seq2, insn);\n+\t\t    last = emit_insns_after (seq2, insn);\n \n \t\t    /* ??? We can also delete the insn that sets X to A.\n \t\t       Flow will do it too though.  */\n \t\t    delete_insn (temp);\n \t\t    next = NEXT_INSN (insn);\n \t\t    delete_jump (insn);\n+\n+\t\t    if (after_regscan)\n+\t\t      {\n+\t\t\treg_scan_update (seq1, NEXT_INSN (last), old_max_reg);\n+\t\t\told_max_reg = max_reg_num ();\n+\t\t      }\n+\n \t\t    changed = 1;\n \t\t    continue;\n \t\t  }\n@@ -1455,6 +1471,13 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t      delete_insn (temp);\n \t\t      next = NEXT_INSN (insn);\n \t\t      delete_jump (insn);\n+\n+\t\t      if (after_regscan)\n+\t\t\t{\n+\t\t\t  reg_scan_update (seq, NEXT_INSN (next), old_max_reg);\n+\t\t\t  old_max_reg = max_reg_num ();\n+\t\t\t}\n+\n \t\t      changed = 1;\n \t\t      continue;\n \t\t    }\n@@ -1574,6 +1597,13 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t  delete_insn (prev_nonnote_insn (insn));\n #endif\n \t\t  delete_insn (insn);\n+\n+\t\t  if (after_regscan)\n+\t\t    {\n+\t\t      reg_scan_update (seq, NEXT_INSN (next), old_max_reg);\n+\t\t      old_max_reg = max_reg_num ();\n+\t\t    }\n+\n \t\t  changed = 1;\n \t\t  continue;\n \t\t}"}, {"sha": "256d92bcc9ee84699f00941fdadba16bc7365063", "filename": "gcc/regclass.c", "status": "modified", "additions": 54, "deletions": 16, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f903b91f37ac738712b8a6494ce261ebccaad9c1/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f903b91f37ac738712b8a6494ce261ebccaad9c1/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=f903b91f37ac738712b8a6494ce261ebccaad9c1", "patch": "@@ -673,7 +673,7 @@ static void record_address_regs\tPROTO((rtx, enum reg_class, int));\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n static int auto_inc_dec_reg_p\tPROTO((rtx, enum machine_mode));\n #endif\n-static void reg_scan_mark_refs\tPROTO((rtx, rtx, int));\n+static void reg_scan_mark_refs\tPROTO((rtx, rtx, int, int));\n \n /* Return the reg_class in which pseudo reg number REGNO is best allocated.\n    This function is sometimes called before the info has been computed.\n@@ -1939,21 +1939,54 @@ reg_scan (f, nregs, repeat)\n \tif (GET_CODE (PATTERN (insn)) == PARALLEL\n \t    && XVECLEN (PATTERN (insn), 0) > max_parallel)\n \t  max_parallel = XVECLEN (PATTERN (insn), 0);\n-\treg_scan_mark_refs (PATTERN (insn), insn, 0);\n+\treg_scan_mark_refs (PATTERN (insn), insn, 0, 0);\n \n \tif (REG_NOTES (insn))\n-\t  reg_scan_mark_refs (REG_NOTES (insn), insn, 1);\n+\t  reg_scan_mark_refs (REG_NOTES (insn), insn, 1, 0);\n+      }\n+}\n+\n+/* Update 'regscan' information by looking at the insns\n+   from FIRST to LAST.  Some new REGs have been created,\n+   and any REG with number greater than OLD_MAX_REGNO is\n+   such a REG.  We only update information for those.  */\n+\n+void\n+reg_scan_update(first, last, old_max_regno)\n+     rtx first;\n+     rtx last;\n+     int old_max_regno;\n+{\n+  register rtx insn;\n+\n+  allocate_reg_info (max_reg_num (), FALSE, FALSE);\n+\n+  for (insn = first; insn != last; insn = NEXT_INSN (insn))\n+    if (GET_CODE (insn) == INSN\n+\t|| GET_CODE (insn) == CALL_INSN\n+\t|| GET_CODE (insn) == JUMP_INSN)\n+      {\n+\tif (GET_CODE (PATTERN (insn)) == PARALLEL\n+\t    && XVECLEN (PATTERN (insn), 0) > max_parallel)\n+\t  max_parallel = XVECLEN (PATTERN (insn), 0);\n+\treg_scan_mark_refs (PATTERN (insn), insn, 0, old_max_regno);\n+\n+\tif (REG_NOTES (insn))\n+\t  reg_scan_mark_refs (REG_NOTES (insn), insn, 1, old_max_regno);\n       }\n }\n \n /* X is the expression to scan.  INSN is the insn it appears in.\n-   NOTE_FLAG is nonzero if X is from INSN's notes rather than its body.  */\n+   NOTE_FLAG is nonzero if X is from INSN's notes rather than its body.\n+   We should only record information for REGs with numbers\n+   greater than or equal to MIN_REGNO.  */\n \n static void\n-reg_scan_mark_refs (x, insn, note_flag)\n+reg_scan_mark_refs (x, insn, note_flag, min_regno)\n      rtx x;\n      rtx insn;\n      int note_flag;\n+     int min_regno;\n {\n   register enum rtx_code code = GET_CODE (x);\n   register rtx dest;\n@@ -1976,24 +2009,27 @@ reg_scan_mark_refs (x, insn, note_flag)\n       {\n \tregister int regno = REGNO (x);\n \n-\tREGNO_LAST_NOTE_UID (regno) = INSN_UID (insn);\n-\tif (!note_flag)\n-\t  REGNO_LAST_UID (regno) = INSN_UID (insn);\n-\tif (REGNO_FIRST_UID (regno) == 0)\n-\t  REGNO_FIRST_UID (regno) = INSN_UID (insn);\n+\tif (regno >= min_regno)\n+\t  {\n+\t    REGNO_LAST_NOTE_UID (regno) = INSN_UID (insn);\n+\t    if (!note_flag)\n+\t      REGNO_LAST_UID (regno) = INSN_UID (insn);\n+\t    if (REGNO_FIRST_UID (regno) == 0)\n+\t      REGNO_FIRST_UID (regno) = INSN_UID (insn);\n+\t  }\n       }\n       break;\n \n     case EXPR_LIST:\n       if (XEXP (x, 0))\n-\treg_scan_mark_refs (XEXP (x, 0), insn, note_flag);\n+\treg_scan_mark_refs (XEXP (x, 0), insn, note_flag, min_regno);\n       if (XEXP (x, 1))\n-\treg_scan_mark_refs (XEXP (x, 1), insn, note_flag);\n+\treg_scan_mark_refs (XEXP (x, 1), insn, note_flag, min_regno);\n       break;\n \n     case INSN_LIST:\n       if (XEXP (x, 1))\n-\treg_scan_mark_refs (XEXP (x, 1), insn, note_flag);\n+\treg_scan_mark_refs (XEXP (x, 1), insn, note_flag, min_regno);\n       break;\n \n     case SET:\n@@ -2004,7 +2040,8 @@ reg_scan_mark_refs (x, insn, note_flag)\n \t   dest = XEXP (dest, 0))\n \t;\n \n-      if (GET_CODE (dest) == REG)\n+      if (GET_CODE (dest) == REG\n+\t  && REGNO (dest) >= min_regno)\n \tREG_N_SETS (REGNO (dest))++;\n \n       /* If this is setting a pseudo from another pseudo or the sum of a\n@@ -2021,6 +2058,7 @@ reg_scan_mark_refs (x, insn, note_flag)\n \n       if (GET_CODE (SET_DEST (x)) == REG\n \t  && REGNO (SET_DEST (x)) >= FIRST_PSEUDO_REGISTER\n+\t  && REGNO (SET_DEST (x)) >= min_regno\n \t  /* If the destination pseudo is set more than once, then other\n \t     sets might not be to a pointer value (consider access to a\n \t     union in two threads of control in the presense of global\n@@ -2063,12 +2101,12 @@ reg_scan_mark_refs (x, insn, note_flag)\n \tfor (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n \t  {\n \t    if (fmt[i] == 'e')\n-\t      reg_scan_mark_refs (XEXP (x, i), insn, note_flag);\n+\t      reg_scan_mark_refs (XEXP (x, i), insn, note_flag, min_regno);\n \t    else if (fmt[i] == 'E' && XVEC (x, i) != 0)\n \t      {\n \t\tregister int j;\n \t\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t\t  reg_scan_mark_refs (XVECEXP (x, i, j), insn, note_flag);\n+\t\t  reg_scan_mark_refs (XVECEXP (x, i, j), insn, note_flag, min_regno);\n \t      }\n \t  }\n       }"}, {"sha": "4aa25b2ee0d84e27deaa5be434a26b9857db4bf4", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f903b91f37ac738712b8a6494ce261ebccaad9c1/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f903b91f37ac738712b8a6494ce261ebccaad9c1/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=f903b91f37ac738712b8a6494ce261ebccaad9c1", "patch": "@@ -1449,6 +1449,7 @@ extern void regset_release_memory\tPROTO ((void));\n extern void regclass_init\t\tPROTO ((void));\n extern void regclass\t\t\tPROTO ((rtx, int));\n extern void reg_scan\t\t\tPROTO ((rtx, int, int));\n+extern void reg_scan_update\t\tPROTO ((rtx, rtx, int));\n extern void fix_register\t\tPROTO ((char *, int, int));\n \n /* In regmove.c */"}]}