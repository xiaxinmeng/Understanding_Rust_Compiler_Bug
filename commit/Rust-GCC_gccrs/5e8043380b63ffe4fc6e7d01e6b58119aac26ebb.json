{"sha": "5e8043380b63ffe4fc6e7d01e6b58119aac26ebb", "node_id": "C_kwDOANBUbNoAKDVlODA0MzM4MGI2M2ZmZTRmYzZlN2QwMWU2YjU4MTE5YWFjMjZlYmI", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-11-02T10:10:58Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-11-02T10:10:58Z"}, "message": "Refactor struct-expr typechecking into its own impl file", "tree": {"sha": "e0bbb5da76bb344593da2dae124414a309ee0696", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0bbb5da76bb344593da2dae124414a309ee0696"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e8043380b63ffe4fc6e7d01e6b58119aac26ebb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e8043380b63ffe4fc6e7d01e6b58119aac26ebb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e8043380b63ffe4fc6e7d01e6b58119aac26ebb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e8043380b63ffe4fc6e7d01e6b58119aac26ebb/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8d57d424b94f6278140784561dfb6e3d4173cf3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8d57d424b94f6278140784561dfb6e3d4173cf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8d57d424b94f6278140784561dfb6e3d4173cf3"}], "stats": {"total": 567, "additions": 296, "deletions": 271}, "files": [{"sha": "15c0a8fa85d0626a381d9b43cae87b1baf28a085", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8043380b63ffe4fc6e7d01e6b58119aac26ebb/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8043380b63ffe4fc6e7d01e6b58119aac26ebb/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=5e8043380b63ffe4fc6e7d01e6b58119aac26ebb", "patch": "@@ -85,6 +85,7 @@ GRS_OBJS = \\\n     rust/rust-hir-trait-resolve.o \\\n     rust/rust-hir-const-fold.o \\\n     rust/rust-hir-type-check-type.o \\\n+    rust/rust-hir-type-check-struct.o \\\n     rust/rust-lint-marklive.o \\\n     rust/rust-hir-type-check-path.o \\\n     rust/rust-compile-intrinsic.o \\"}, {"sha": "eedd5817ac9cf4e341b4bd1fd892be8dc50dff89", "filename": "gcc/rust/typecheck/rust-hir-type-check-struct.cc", "status": "added", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8043380b63ffe4fc6e7d01e6b58119aac26ebb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8043380b63ffe4fc6e7d01e6b58119aac26ebb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc?ref=5e8043380b63ffe4fc6e7d01e6b58119aac26ebb", "patch": "@@ -0,0 +1,295 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-struct-field.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n+{\n+  TyTy::BaseType *struct_path_ty\n+    = TypeCheckExpr::Resolve (&struct_expr.get_struct_name (), false);\n+  if (struct_path_ty->get_kind () != TyTy::TypeKind::ADT)\n+    {\n+      rust_error_at (struct_expr.get_struct_name ().get_locus (),\n+\t\t     \"expected an ADT type for constructor\");\n+      return;\n+    }\n+\n+  struct_path_resolved = static_cast<TyTy::ADTType *> (struct_path_ty);\n+  TyTy::ADTType *struct_def = struct_path_resolved;\n+  if (struct_expr.has_struct_base ())\n+    {\n+      TyTy::BaseType *base_resolved\n+\t= TypeCheckExpr::Resolve (struct_expr.struct_base->base_struct.get (),\n+\t\t\t\t  false);\n+      struct_def\n+\t= (TyTy::ADTType *) struct_path_resolved->unify (base_resolved);\n+      if (struct_def == nullptr)\n+\t{\n+\t  rust_fatal_error (struct_expr.struct_base->base_struct->get_locus (),\n+\t\t\t    \"incompatible types for base struct reference\");\n+\t  return;\n+\t}\n+    }\n+\n+  std::vector<TyTy::StructFieldType *> infered_fields;\n+  bool ok = true;\n+\n+  for (auto &field : struct_expr.get_fields ())\n+    {\n+      resolved_field_value_expr = nullptr;\n+      field->accept_vis (*this);\n+      if (resolved_field_value_expr == nullptr)\n+\t{\n+\t  rust_fatal_error (field->get_locus (),\n+\t\t\t    \"failed to resolve type for field\");\n+\t  ok = false;\n+\t  break;\n+\t}\n+\n+      context->insert_type (field->get_mappings (), resolved_field_value_expr);\n+    }\n+\n+  // something failed setting up the fields\n+  if (!ok)\n+    {\n+      rust_error_at (struct_expr.get_locus (),\n+\t\t     \"constructor type resolution failure\");\n+      return;\n+    }\n+\n+  // check the arguments are all assigned and fix up the ordering\n+  rust_assert (!struct_path_resolved->is_enum ());\n+  rust_assert (struct_path_resolved->number_of_variants () == 1);\n+  TyTy::VariantDef *variant = struct_path_resolved->get_variants ().at (0);\n+\n+  if (fields_assigned.size () != variant->num_fields ())\n+    {\n+      if (struct_def->is_union ())\n+\t{\n+\t  if (fields_assigned.size () != 1 || struct_expr.has_struct_base ())\n+\t    {\n+\t      rust_error_at (\n+\t\tstruct_expr.get_locus (),\n+\t\t\"union must have exactly one field variant assigned\");\n+\t      return;\n+\t    }\n+\t}\n+      else if (!struct_expr.has_struct_base ())\n+\t{\n+\t  rust_error_at (struct_expr.get_locus (),\n+\t\t\t \"constructor is missing fields\");\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  // we have a struct base to assign the missing fields from.\n+\t  // the missing fields can be implicit FieldAccessExprs for the value\n+\t  std::set<std::string> missing_fields;\n+\t  for (auto &field : variant->get_fields ())\n+\t    {\n+\t      auto it = fields_assigned.find (field->get_name ());\n+\t      if (it == fields_assigned.end ())\n+\t\tmissing_fields.insert (field->get_name ());\n+\t    }\n+\n+\t  // we can generate FieldAccessExpr or TupleAccessExpr for the\n+\t  // values of the missing fields.\n+\t  for (auto &missing : missing_fields)\n+\t    {\n+\t      HIR::Expr *receiver\n+\t\t= struct_expr.struct_base->base_struct->clone_expr_impl ();\n+\n+\t      HIR::StructExprField *implicit_field = nullptr;\n+\n+\t      AST::AttrVec outer_attribs;\n+\t      auto crate_num = mappings->get_current_crate ();\n+\t      Analysis::NodeMapping mapping (\n+\t\tcrate_num,\n+\t\tstruct_expr.struct_base->base_struct->get_mappings ()\n+\t\t  .get_nodeid (),\n+\t\tmappings->get_next_hir_id (crate_num), UNKNOWN_LOCAL_DEFID);\n+\n+\t      HIR::Expr *field_value = new HIR::FieldAccessExpr (\n+\t\tmapping, std::unique_ptr<HIR::Expr> (receiver), missing,\n+\t\tstd::move (outer_attribs),\n+\t\tstruct_expr.struct_base->base_struct->get_locus ());\n+\n+\t      implicit_field = new HIR::StructExprFieldIdentifierValue (\n+\t\tmapping, missing, std::unique_ptr<HIR::Expr> (field_value),\n+\t\tstruct_expr.struct_base->base_struct->get_locus ());\n+\n+\t      size_t field_index;\n+\t      bool ok = variant->lookup_field (missing, nullptr, &field_index);\n+\t      rust_assert (ok);\n+\n+\t      adtFieldIndexToField[field_index] = implicit_field;\n+\t      struct_expr.get_fields ().push_back (\n+\t\tstd::unique_ptr<HIR::StructExprField> (implicit_field));\n+\t    }\n+\t}\n+    }\n+\n+  if (struct_def->is_union ())\n+    {\n+      // There is exactly one field in this constructor, we need to\n+      // figure out the field index to make sure we initialize the\n+      // right union field.\n+      for (size_t i = 0; i < adtFieldIndexToField.size (); i++)\n+\t{\n+\t  if (adtFieldIndexToField[i])\n+\t    {\n+\t      struct_expr.union_index = i;\n+\t      break;\n+\t    }\n+\t}\n+      rust_assert (struct_expr.union_index != -1);\n+    }\n+  else\n+    {\n+      // everything is ok, now we need to ensure all field values are ordered\n+      // correctly. The GIMPLE backend uses a simple algorithm that assumes each\n+      // assigned field in the constructor is in the same order as the field in\n+      // the type\n+      for (auto &field : struct_expr.get_fields ())\n+\tfield.release ();\n+\n+      std::vector<std::unique_ptr<HIR::StructExprField> > ordered_fields;\n+      for (size_t i = 0; i < adtFieldIndexToField.size (); i++)\n+\t{\n+\t  ordered_fields.push_back (\n+\t    std::unique_ptr<HIR::StructExprField> (adtFieldIndexToField[i]));\n+\t}\n+      struct_expr.set_fields_as_owner (std::move (ordered_fields));\n+    }\n+\n+  resolved = struct_def;\n+}\n+\n+void\n+TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifierValue &field)\n+{\n+  auto it = fields_assigned.find (field.field_name);\n+  if (it != fields_assigned.end ())\n+    {\n+      rust_fatal_error (field.get_locus (), \"used more than once\");\n+      return;\n+    }\n+\n+  rust_assert (!struct_path_resolved->is_enum ());\n+  rust_assert (struct_path_resolved->number_of_variants () == 1);\n+  TyTy::VariantDef *variant = struct_path_resolved->get_variants ().at (0);\n+\n+  size_t field_index;\n+  TyTy::StructFieldType *field_type;\n+  bool ok = variant->lookup_field (field.field_name, &field_type, &field_index);\n+  if (!ok)\n+    {\n+      rust_error_at (field.get_locus (), \"unknown field\");\n+      return;\n+    }\n+\n+  TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value (), false);\n+  resolved_field_value_expr = field_type->get_field_type ()->unify (value);\n+  if (resolved_field_value_expr != nullptr)\n+    {\n+      fields_assigned.insert (field.field_name);\n+      adtFieldIndexToField[field_index] = &field;\n+    }\n+}\n+\n+void\n+TypeCheckStructExpr::visit (HIR::StructExprFieldIndexValue &field)\n+{\n+  std::string field_name (std::to_string (field.get_tuple_index ()));\n+  auto it = fields_assigned.find (field_name);\n+  if (it != fields_assigned.end ())\n+    {\n+      rust_fatal_error (field.get_locus (), \"used more than once\");\n+      return;\n+    }\n+\n+  rust_assert (!struct_path_resolved->is_enum ());\n+  rust_assert (struct_path_resolved->number_of_variants () == 1);\n+  TyTy::VariantDef *variant = struct_path_resolved->get_variants ().at (0);\n+\n+  size_t field_index;\n+  TyTy::StructFieldType *field_type;\n+  bool ok = variant->lookup_field (field_name, &field_type, &field_index);\n+  if (!ok)\n+    {\n+      rust_error_at (field.get_locus (), \"unknown field\");\n+      return;\n+    }\n+\n+  TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value (), false);\n+  resolved_field_value_expr = field_type->get_field_type ()->unify (value);\n+  if (resolved_field_value_expr != nullptr)\n+    {\n+      fields_assigned.insert (field_name);\n+      adtFieldIndexToField[field_index] = &field;\n+    }\n+}\n+\n+void\n+TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifier &field)\n+{\n+  auto it = fields_assigned.find (field.get_field_name ());\n+  if (it != fields_assigned.end ())\n+    {\n+      rust_fatal_error (field.get_locus (), \"used more than once\");\n+      return;\n+    }\n+\n+  rust_assert (!struct_path_resolved->is_enum ());\n+  rust_assert (struct_path_resolved->number_of_variants () == 1);\n+  TyTy::VariantDef *variant = struct_path_resolved->get_variants ().at (0);\n+\n+  size_t field_index;\n+  TyTy::StructFieldType *field_type;\n+  bool ok = variant->lookup_field (field.get_field_name (), &field_type,\n+\t\t\t\t   &field_index);\n+  if (!ok)\n+    {\n+      rust_error_at (field.get_locus (), \"unknown field\");\n+      return;\n+    }\n+\n+  // we can make the field look like an identifier expr to take advantage of\n+  // existing code to figure out the type\n+  HIR::IdentifierExpr expr (field.get_mappings (), field.get_field_name (),\n+\t\t\t    field.get_locus ());\n+  TyTy::BaseType *value = TypeCheckExpr::Resolve (&expr, false);\n+\n+  resolved_field_value_expr = field_type->get_field_type ()->unify (value);\n+  if (resolved_field_value_expr != nullptr)\n+\n+    {\n+      fields_assigned.insert (field.field_name);\n+      adtFieldIndexToField[field_index] = &field;\n+    }\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "5237082461dd42c80903410f82f4e6fcd9475ec4", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 0, "deletions": 271, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8043380b63ffe4fc6e7d01e6b58119aac26ebb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8043380b63ffe4fc6e7d01e6b58119aac26ebb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=5e8043380b63ffe4fc6e7d01e6b58119aac26ebb", "patch": "@@ -120,277 +120,6 @@ TypeCheckExpr::visit (HIR::BlockExpr &expr)\n     infered = new TyTy::NeverType (expr.get_mappings ().get_hirid ());\n }\n \n-// RUST_HIR_TYPE_CHECK_STRUCT_FIELD\n-\n-void\n-TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n-{\n-  TyTy::BaseType *struct_path_ty\n-    = TypeCheckExpr::Resolve (&struct_expr.get_struct_name (), false);\n-  if (struct_path_ty->get_kind () != TyTy::TypeKind::ADT)\n-    {\n-      rust_error_at (struct_expr.get_struct_name ().get_locus (),\n-\t\t     \"expected an ADT type for constructor\");\n-      return;\n-    }\n-\n-  struct_path_resolved = static_cast<TyTy::ADTType *> (struct_path_ty);\n-  TyTy::ADTType *struct_def = struct_path_resolved;\n-  if (struct_expr.has_struct_base ())\n-    {\n-      TyTy::BaseType *base_resolved\n-\t= TypeCheckExpr::Resolve (struct_expr.struct_base->base_struct.get (),\n-\t\t\t\t  false);\n-      struct_def\n-\t= (TyTy::ADTType *) struct_path_resolved->unify (base_resolved);\n-      if (struct_def == nullptr)\n-\t{\n-\t  rust_fatal_error (struct_expr.struct_base->base_struct->get_locus (),\n-\t\t\t    \"incompatible types for base struct reference\");\n-\t  return;\n-\t}\n-    }\n-\n-  std::vector<TyTy::StructFieldType *> infered_fields;\n-  bool ok = true;\n-\n-  for (auto &field : struct_expr.get_fields ())\n-    {\n-      resolved_field_value_expr = nullptr;\n-      field->accept_vis (*this);\n-      if (resolved_field_value_expr == nullptr)\n-\t{\n-\t  rust_fatal_error (field->get_locus (),\n-\t\t\t    \"failed to resolve type for field\");\n-\t  ok = false;\n-\t  break;\n-\t}\n-\n-      context->insert_type (field->get_mappings (), resolved_field_value_expr);\n-    }\n-\n-  // something failed setting up the fields\n-  if (!ok)\n-    {\n-      rust_error_at (struct_expr.get_locus (),\n-\t\t     \"constructor type resolution failure\");\n-      return;\n-    }\n-\n-  // check the arguments are all assigned and fix up the ordering\n-  rust_assert (!struct_path_resolved->is_enum ());\n-  rust_assert (struct_path_resolved->number_of_variants () == 1);\n-  TyTy::VariantDef *variant = struct_path_resolved->get_variants ().at (0);\n-\n-  if (fields_assigned.size () != variant->num_fields ())\n-    {\n-      if (struct_def->is_union ())\n-\t{\n-\t  if (fields_assigned.size () != 1 || struct_expr.has_struct_base ())\n-\t    {\n-\t      rust_error_at (\n-\t\tstruct_expr.get_locus (),\n-\t\t\"union must have exactly one field variant assigned\");\n-\t      return;\n-\t    }\n-\t}\n-      else if (!struct_expr.has_struct_base ())\n-\t{\n-\t  rust_error_at (struct_expr.get_locus (),\n-\t\t\t \"constructor is missing fields\");\n-\t  return;\n-\t}\n-      else\n-\t{\n-\t  // we have a struct base to assign the missing fields from.\n-\t  // the missing fields can be implicit FieldAccessExprs for the value\n-\t  std::set<std::string> missing_fields;\n-\t  for (auto &field : variant->get_fields ())\n-\t    {\n-\t      auto it = fields_assigned.find (field->get_name ());\n-\t      if (it == fields_assigned.end ())\n-\t\tmissing_fields.insert (field->get_name ());\n-\t    }\n-\n-\t  // we can generate FieldAccessExpr or TupleAccessExpr for the\n-\t  // values of the missing fields.\n-\t  for (auto &missing : missing_fields)\n-\t    {\n-\t      HIR::Expr *receiver\n-\t\t= struct_expr.struct_base->base_struct->clone_expr_impl ();\n-\n-\t      HIR::StructExprField *implicit_field = nullptr;\n-\n-\t      AST::AttrVec outer_attribs;\n-\t      auto crate_num = mappings->get_current_crate ();\n-\t      Analysis::NodeMapping mapping (\n-\t\tcrate_num,\n-\t\tstruct_expr.struct_base->base_struct->get_mappings ()\n-\t\t  .get_nodeid (),\n-\t\tmappings->get_next_hir_id (crate_num), UNKNOWN_LOCAL_DEFID);\n-\n-\t      HIR::Expr *field_value = new HIR::FieldAccessExpr (\n-\t\tmapping, std::unique_ptr<HIR::Expr> (receiver), missing,\n-\t\tstd::move (outer_attribs),\n-\t\tstruct_expr.struct_base->base_struct->get_locus ());\n-\n-\t      implicit_field = new HIR::StructExprFieldIdentifierValue (\n-\t\tmapping, missing, std::unique_ptr<HIR::Expr> (field_value),\n-\t\tstruct_expr.struct_base->base_struct->get_locus ());\n-\n-\t      size_t field_index;\n-\t      bool ok = variant->lookup_field (missing, nullptr, &field_index);\n-\t      rust_assert (ok);\n-\n-\t      adtFieldIndexToField[field_index] = implicit_field;\n-\t      struct_expr.get_fields ().push_back (\n-\t\tstd::unique_ptr<HIR::StructExprField> (implicit_field));\n-\t    }\n-\t}\n-    }\n-\n-  if (struct_def->is_union ())\n-    {\n-      // There is exactly one field in this constructor, we need to\n-      // figure out the field index to make sure we initialize the\n-      // right union field.\n-      for (size_t i = 0; i < adtFieldIndexToField.size (); i++)\n-\t{\n-\t  if (adtFieldIndexToField[i])\n-\t    {\n-\t      struct_expr.union_index = i;\n-\t      break;\n-\t    }\n-\t}\n-      rust_assert (struct_expr.union_index != -1);\n-    }\n-  else\n-    {\n-      // everything is ok, now we need to ensure all field values are ordered\n-      // correctly. The GIMPLE backend uses a simple algorithm that assumes each\n-      // assigned field in the constructor is in the same order as the field in\n-      // the type\n-      for (auto &field : struct_expr.get_fields ())\n-\tfield.release ();\n-\n-      std::vector<std::unique_ptr<HIR::StructExprField> > ordered_fields;\n-      for (size_t i = 0; i < adtFieldIndexToField.size (); i++)\n-\t{\n-\t  ordered_fields.push_back (\n-\t    std::unique_ptr<HIR::StructExprField> (adtFieldIndexToField[i]));\n-\t}\n-      struct_expr.set_fields_as_owner (std::move (ordered_fields));\n-    }\n-\n-  resolved = struct_def;\n-}\n-\n-void\n-TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifierValue &field)\n-{\n-  auto it = fields_assigned.find (field.field_name);\n-  if (it != fields_assigned.end ())\n-    {\n-      rust_fatal_error (field.get_locus (), \"used more than once\");\n-      return;\n-    }\n-\n-  rust_assert (!struct_path_resolved->is_enum ());\n-  rust_assert (struct_path_resolved->number_of_variants () == 1);\n-  TyTy::VariantDef *variant = struct_path_resolved->get_variants ().at (0);\n-\n-  size_t field_index;\n-  TyTy::StructFieldType *field_type;\n-  bool ok = variant->lookup_field (field.field_name, &field_type, &field_index);\n-  if (!ok)\n-    {\n-      rust_error_at (field.get_locus (), \"unknown field\");\n-      return;\n-    }\n-\n-  TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value (), false);\n-  resolved_field_value_expr = field_type->get_field_type ()->unify (value);\n-  if (resolved_field_value_expr != nullptr)\n-    {\n-      fields_assigned.insert (field.field_name);\n-      adtFieldIndexToField[field_index] = &field;\n-    }\n-}\n-\n-void\n-TypeCheckStructExpr::visit (HIR::StructExprFieldIndexValue &field)\n-{\n-  std::string field_name (std::to_string (field.get_tuple_index ()));\n-  auto it = fields_assigned.find (field_name);\n-  if (it != fields_assigned.end ())\n-    {\n-      rust_fatal_error (field.get_locus (), \"used more than once\");\n-      return;\n-    }\n-\n-  rust_assert (!struct_path_resolved->is_enum ());\n-  rust_assert (struct_path_resolved->number_of_variants () == 1);\n-  TyTy::VariantDef *variant = struct_path_resolved->get_variants ().at (0);\n-\n-  size_t field_index;\n-  TyTy::StructFieldType *field_type;\n-  bool ok = variant->lookup_field (field_name, &field_type, &field_index);\n-  if (!ok)\n-    {\n-      rust_error_at (field.get_locus (), \"unknown field\");\n-      return;\n-    }\n-\n-  TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value (), false);\n-  resolved_field_value_expr = field_type->get_field_type ()->unify (value);\n-  if (resolved_field_value_expr != nullptr)\n-    {\n-      fields_assigned.insert (field_name);\n-      adtFieldIndexToField[field_index] = &field;\n-    }\n-}\n-\n-void\n-TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifier &field)\n-{\n-  auto it = fields_assigned.find (field.get_field_name ());\n-  if (it != fields_assigned.end ())\n-    {\n-      rust_fatal_error (field.get_locus (), \"used more than once\");\n-      return;\n-    }\n-\n-  rust_assert (!struct_path_resolved->is_enum ());\n-  rust_assert (struct_path_resolved->number_of_variants () == 1);\n-  TyTy::VariantDef *variant = struct_path_resolved->get_variants ().at (0);\n-\n-  size_t field_index;\n-  TyTy::StructFieldType *field_type;\n-  bool ok = variant->lookup_field (field.get_field_name (), &field_type,\n-\t\t\t\t   &field_index);\n-  if (!ok)\n-    {\n-      rust_error_at (field.get_locus (), \"unknown field\");\n-      return;\n-    }\n-\n-  // we can make the field look like an identifier expr to take advantage of\n-  // existing code to figure out the type\n-  HIR::IdentifierExpr expr (field.get_mappings (), field.get_field_name (),\n-\t\t\t    field.get_locus ());\n-  TyTy::BaseType *value = TypeCheckExpr::Resolve (&expr, false);\n-\n-  resolved_field_value_expr = field_type->get_field_type ()->unify (value);\n-  if (resolved_field_value_expr != nullptr)\n-\n-    {\n-      fields_assigned.insert (field.field_name);\n-      adtFieldIndexToField[field_index] = &field;\n-    }\n-}\n-\n-// rust-hir-type-check-type.h\n-\n void\n TypeCheckType::visit (HIR::ArrayType &type)\n {"}]}