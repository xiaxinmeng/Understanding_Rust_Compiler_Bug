{"sha": "85f3d674d453d980199d404c188b217dcc6ee9c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVmM2Q2NzRkNDUzZDk4MDE5OWQ0MDRjMTg4YjIxN2RjYzZlZTljMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-08-30T02:00:55Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-08-30T02:00:55Z"}, "message": "expr.c (store_constructor): Allow variable bounds of array type.\n\n\t* expr.c (store_constructor): Allow variable bounds of array type.\n\t(expand_expr): Don't blow up if type is ERROR_MARK.\n\t* varasm.c (output_constructor): Don't access lower bound of array\n\ttype unless need it if index is supplied (so it can be a variable\n\tif no index is supplied).\n\tUse tree_low_cst; use HOST_WIDE_INT for sizes; change BITPOS to POS.\n\tOther minor cleanups.\n\nFrom-SVN: r36060", "tree": {"sha": "93a77b8da110b5aa2e972ff4785ebafed42b4547", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93a77b8da110b5aa2e972ff4785ebafed42b4547"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85f3d674d453d980199d404c188b217dcc6ee9c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85f3d674d453d980199d404c188b217dcc6ee9c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85f3d674d453d980199d404c188b217dcc6ee9c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85f3d674d453d980199d404c188b217dcc6ee9c1/comments", "author": null, "committer": null, "parents": [{"sha": "5b67ad6f4566834f8c0ffb253769727307bf0a11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b67ad6f4566834f8c0ffb253769727307bf0a11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b67ad6f4566834f8c0ffb253769727307bf0a11"}], "stats": {"total": 129, "additions": 73, "deletions": 56}, "files": [{"sha": "2897519466ce82e17f32b56c82b0be085c741426", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f3d674d453d980199d404c188b217dcc6ee9c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f3d674d453d980199d404c188b217dcc6ee9c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=85f3d674d453d980199d404c188b217dcc6ee9c1", "patch": "@@ -1,3 +1,13 @@\n+Tue Aug 29 22:09:59 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expr.c (store_constructor): Allow variable bounds of array type.\n+\t(expand_expr): Don't blow up if type is ERROR_MARK.\n+\t* varasm.c (output_constructor): Don't access lower bound of array\n+\ttype unless need it if index is supplied (so it can be a variable\n+\tif no index is supplied).\n+\tUse tree_low_cst; use HOST_WIDE_INT for sizes; change BITPOS to POS.\n+\tOther minor cleanups.\n+\n 2000-08-29  J. David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* Makefile.in: Revamp handling of cflags to allow different WARN_CFLAGS"}, {"sha": "341586affd05084555b8e4c8cb98f0689c2ac355", "filename": "gcc/expr.c", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f3d674d453d980199d404c188b217dcc6ee9c1/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f3d674d453d980199d404c188b217dcc6ee9c1/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=85f3d674d453d980199d404c188b217dcc6ee9c1", "patch": "@@ -4397,9 +4397,18 @@ store_constructor (exp, target, align, cleared, size)\n       register int i;\n       int need_to_clear;\n       tree domain = TYPE_DOMAIN (type);\n-      HOST_WIDE_INT minelt = TREE_INT_CST_LOW (TYPE_MIN_VALUE (domain));\n-      HOST_WIDE_INT maxelt = TREE_INT_CST_LOW (TYPE_MAX_VALUE (domain));\n       tree elttype = TREE_TYPE (type);\n+      int const_bounds_p = (host_integerp (TYPE_MIN_VALUE (domain), 0)\n+\t\t\t    && host_integerp (TYPE_MAX_VALUE (domain), 0));\n+      HOST_WIDE_INT minelt;\n+      HOST_WIDE_INT maxelt;\n+\n+      /* If we have constant bounds for the range of the type, get them.  */\n+      if (const_bounds_p)\n+\t{\n+\t  minelt = tree_low_cst (TYPE_MIN_VALUE (domain), 0);\n+\t  maxelt = tree_low_cst (TYPE_MAX_VALUE (domain), 0);\n+\t}\n \n       /* If the constructor has fewer elements than the array,\n          clear the whole array first.  Similarly if this is\n@@ -4409,12 +4418,13 @@ store_constructor (exp, target, align, cleared, size)\n       else\n \t{\n \t  HOST_WIDE_INT count = 0, zero_count = 0;\n-\t  need_to_clear = 0;\n+\t  need_to_clear = ! const_bounds_p;\n+\n \t  /* This loop is a more accurate version of the loop in\n \t     mostly_zeros_p (it handles RANGE_EXPR in an index).\n \t     It is also needed to check for missing elements.  */\n \t  for (elt = CONSTRUCTOR_ELTS (exp);\n-\t       elt != NULL_TREE;\n+\t       elt != NULL_TREE && ! need_to_clear;\n \t       elt = TREE_CHAIN (elt))\n \t    {\n \t      tree index = TREE_PURPOSE (elt);\n@@ -4437,16 +4447,19 @@ store_constructor (exp, target, align, cleared, size)\n \t\t}\n \t      else\n \t\tthis_node_count = 1;\n+\n \t      count += this_node_count;\n \t      if (mostly_zeros_p (TREE_VALUE (elt)))\n \t\tzero_count += this_node_count;\n \t    }\n+\n \t  /* Clear the entire array first if there are any missing elements,\n \t     or if the incidence of zero elements is >= 75%.  */\n-\t  if (count < maxelt - minelt + 1\n-\t      || 4 * zero_count >= 3 * count)\n+\t  if (! need_to_clear\n+\t      && (count < maxelt - minelt + 1 || 4 * zero_count >= 3 * count))\n \t    need_to_clear = 1;\n \t}\n+\n       if (need_to_clear && size > 0)\n \t{\n \t  if (! cleared)\n@@ -4495,7 +4508,8 @@ store_constructor (exp, target, align, cleared, size)\n \t      tree position;\n \n \t      /* If the range is constant and \"small\", unroll the loop.  */\n-\t      if (host_integerp (lo_index, 0)\n+\t      if (const_bounds_p\n+\t\t  && host_integerp (lo_index, 0)\n \t\t  && host_integerp (hi_index, 0)\n \t\t  && (lo = tree_low_cst (lo_index, 0),\n \t\t      hi = tree_low_cst (hi_index, 0),\n@@ -5762,7 +5776,7 @@ expand_expr (exp, target, tmode, modifier)\n   enum expand_modifier ro_modifier;\n \n   /* Handle ERROR_MARK before anybody tries to access its type.  */\n-  if (TREE_CODE (exp) == ERROR_MARK)\n+  if (TREE_CODE (exp) == ERROR_MARK || TREE_CODE (type) == ERROR_MARK)\n     {\n       op0 = CONST0_RTX (tmode);\n       if (op0 != 0)"}, {"sha": "478daf8286184c1a9f12f2726217237f925824df", "filename": "gcc/varasm.c", "status": "modified", "additions": 41, "deletions": 48, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f3d674d453d980199d404c188b217dcc6ee9c1/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f3d674d453d980199d404c188b217dcc6ee9c1/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=85f3d674d453d980199d404c188b217dcc6ee9c1", "patch": "@@ -4361,25 +4361,25 @@ output_constructor (exp, size)\n      tree exp;\n      int size;\n {\n+  tree type = TREE_TYPE (exp);\n   register tree link, field = 0;\n-  HOST_WIDE_INT min_index = 0;\n+  tree min_index = 0;\n   /* Number of bytes output or skipped so far.\n      In other words, current position within the constructor.  */\n-  int total_bytes = 0;\n+  HOST_WIDE_INT total_bytes = 0;\n   /* Non-zero means BYTE contains part of a byte, to be output.  */\n   int byte_buffer_in_use = 0;\n   register int byte = 0;\n \n   if (HOST_BITS_PER_WIDE_INT < BITS_PER_UNIT)\n     abort ();\n \n-  if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE)\n-    field = TYPE_FIELDS (TREE_TYPE (exp));\n+  if (TREE_CODE (type) == RECORD_TYPE)\n+    field = TYPE_FIELDS (type);\n \n-  if (TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE\n-      && TYPE_DOMAIN (TREE_TYPE (exp)) != 0)\n-    min_index\n-      = TREE_INT_CST_LOW (TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (exp))));\n+  if (TREE_CODE (type) == ARRAY_TYPE\n+      && TYPE_DOMAIN (type) != 0)\n+    min_index = TYPE_MIN_VALUE (TYPE_DOMAIN (type));\n \n   /* As LINK goes through the elements of the constant,\n      FIELD goes through the structure fields, if the constant is a structure.\n@@ -4398,17 +4398,14 @@ output_constructor (exp, size)\n       tree val = TREE_VALUE (link);\n       tree index = 0;\n \n-      /* the element in a union constructor specifies the proper field.  */\n+      /* The element in a union constructor specifies the proper field\n+\t or index.  */\n+      if ((TREE_CODE (type) == RECORD_TYPE || TREE_CODE (type) == UNION_TYPE\n+\t   || TREE_CODE (type) == QUAL_UNION_TYPE)\n+\t  && TREE_PURPOSE (link) != 0)\n+\tfield = TREE_PURPOSE (link);\n \n-      if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE\n-\t  || TREE_CODE (TREE_TYPE (exp)) == UNION_TYPE)\n-\t{\n-\t  /* if available, use the type given by link */\n-\t  if (TREE_PURPOSE (link) != 0)\n-\t    field = TREE_PURPOSE (link);\n-\t}\n-\n-      if (TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE)\n+      else if (TREE_CODE (type) == ARRAY_TYPE)\n \tindex = TREE_PURPOSE (link);\n \n       /* Eliminate the marker that makes a cast not be an lvalue.  */\n@@ -4418,10 +4415,11 @@ output_constructor (exp, size)\n       if (index && TREE_CODE (index) == RANGE_EXPR)\n \t{\n \t  register int fieldsize\n-\t    = int_size_in_bytes (TREE_TYPE (TREE_TYPE (exp)));\n-\t  HOST_WIDE_INT lo_index = TREE_INT_CST_LOW (TREE_OPERAND (index, 0));\n-\t  HOST_WIDE_INT hi_index = TREE_INT_CST_LOW (TREE_OPERAND (index, 1));\n+\t    = int_size_in_bytes (TREE_TYPE (type));\n+\t  HOST_WIDE_INT lo_index = tree_low_cst (TREE_OPERAND (index, 0), 0);\n+\t  HOST_WIDE_INT hi_index = tree_low_cst (TREE_OPERAND (index, 1), 0);\n \t  HOST_WIDE_INT index;\n+\n \t  for (index = lo_index; index <= hi_index; index++)\n \t    {\n \t      /* Output the element's initial value.  */\n@@ -4441,12 +4439,11 @@ output_constructor (exp, size)\n \t  register int fieldsize;\n \t  /* Since this structure is static,\n \t     we know the positions are constant.  */\n-\t  HOST_WIDE_INT bitpos = field ? int_byte_position (field) : 0;\n+\t  HOST_WIDE_INT pos = field ? int_byte_position (field) : 0;\n \n \t  if (index != 0)\n-\t    bitpos\n-\t      = (tree_low_cst (TYPE_SIZE_UNIT (TREE_TYPE (val)), 1)\n-\t\t* (tree_low_cst (index, 0) - min_index));\n+\t    pos = (tree_low_cst (TYPE_SIZE_UNIT (TREE_TYPE (val)), 1)\n+\t\t   * (tree_low_cst (index, 0) - tree_low_cst (min_index, 0)));\n \n \t  /* Output any buffered-up bit-fields preceding this element.  */\n \t  if (byte_buffer_in_use)\n@@ -4459,31 +4456,24 @@ output_constructor (exp, size)\n \t  /* Advance to offset of this element.\n \t     Note no alignment needed in an array, since that is guaranteed\n \t     if each element has the proper size.  */\n-\t  if ((field != 0 || index != 0) && bitpos != total_bytes)\n+\t  if ((field != 0 || index != 0) && pos != total_bytes)\n \t    {\n-\t      assemble_zeros (bitpos - total_bytes);\n-\t      total_bytes = bitpos;\n+\t      assemble_zeros (pos - total_bytes);\n+\t      total_bytes = pos;\n \t    }\n-          else if (field != 0 && DECL_PACKED (field))\n-            {\n-               /* Some assemblers automaticallly align a datum according to\n-                  its size if no align directive is specified.  The datum,\n-                  however, may be declared with 'packed' attribute, so we\n-                  have to disable such a feature.  */\n \n-               ASM_OUTPUT_ALIGN (asm_out_file, 0);\n-            }\n+          else if (field != 0 && DECL_PACKED (field))\n+\t    /* Some assemblers automaticallly align a datum according to its\n+\t       size if no align directive is specified.  The datum, however,\n+\t       may be declared with 'packed' attribute, so we have to disable\n+\t       such a feature.  */\n+\t    ASM_OUTPUT_ALIGN (asm_out_file, 0);\n \n \t  /* Determine size this element should occupy.  */\n \t  if (field)\n-\t    {\n-\t      if (TREE_CODE (DECL_SIZE_UNIT (field)) != INTEGER_CST)\n-\t\tabort ();\n-\n-\t      fieldsize = TREE_INT_CST_LOW (DECL_SIZE_UNIT (field));\n-\t    }\n+\t    fieldsize = tree_low_cst (DECL_SIZE_UNIT (field), 1);\n \t  else\n-\t    fieldsize = int_size_in_bytes (TREE_TYPE (TREE_TYPE (exp)));\n+\t    fieldsize = int_size_in_bytes (TREE_TYPE (type));\n \n \t  /* Output the element's initial value.  */\n \t  if (val == 0)\n@@ -4544,8 +4534,8 @@ output_constructor (exp, size)\n \t      int this_time;\n \t      int shift;\n \t      HOST_WIDE_INT value;\n-\t      int next_byte = next_offset / BITS_PER_UNIT;\n-\t      int next_bit = next_offset % BITS_PER_UNIT;\n+\t      HOST_WIDE_INT next_byte = next_offset / BITS_PER_UNIT;\n+\t      HOST_WIDE_INT next_bit = next_offset % BITS_PER_UNIT;\n \n \t      /* Advance from byte to byte\n \t\t within this element when necessary.  */\n@@ -4566,6 +4556,7 @@ output_constructor (exp, size)\n \t\t     first (of the bits that are significant)\n \t\t     and put them into bytes from the most significant end.  */\n \t\t  shift = end_offset - next_offset - this_time;\n+\n \t\t  /* Don't try to take a bunch of bits that cross\n \t\t     the word boundary in the INTEGER_CST. We can\n \t\t     only select bits from the LOW or HIGH part\n@@ -4579,16 +4570,15 @@ output_constructor (exp, size)\n \n \t\t  /* Now get the bits from the appropriate constant word.  */\n \t\t  if (shift < HOST_BITS_PER_WIDE_INT)\n-\t\t    {\n-\t\t      value = TREE_INT_CST_LOW (val);\n-\t\t    }\n+\t\t    value = TREE_INT_CST_LOW (val);\n \t\t  else if (shift < 2 * HOST_BITS_PER_WIDE_INT)\n \t\t    {\n \t\t      value = TREE_INT_CST_HIGH (val);\n \t\t      shift -= HOST_BITS_PER_WIDE_INT;\n \t\t    }\n \t\t  else\n \t\t    abort ();\n+\n \t\t  /* Get the result. This works only when:\n \t\t     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */\n \t\t  byte |= (((value >> shift)\n@@ -4628,16 +4618,19 @@ output_constructor (exp, size)\n \t\t\t    & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))\n \t\t\t   << next_bit);\n \t\t}\n+\n \t      next_offset += this_time;\n \t      byte_buffer_in_use = 1;\n \t    }\n \t}\n     }\n+\n   if (byte_buffer_in_use)\n     {\n       ASM_OUTPUT_BYTE (asm_out_file, byte);\n       total_bytes++;\n     }\n+\n   if (total_bytes < size)\n     assemble_zeros (size - total_bytes);\n }"}]}