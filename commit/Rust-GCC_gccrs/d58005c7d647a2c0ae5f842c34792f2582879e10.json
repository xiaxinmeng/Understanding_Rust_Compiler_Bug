{"sha": "d58005c7d647a2c0ae5f842c34792f2582879e10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU4MDA1YzdkNjQ3YTJjMGFlNWY4NDJjMzQ3OTJmMjU4Mjg3OWUxMA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2004-10-14T18:32:04Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-10-14T18:32:04Z"}, "message": "reload.c (find_reloads): When reloading a PLUS with constant operand...\n\n\t* reload.c (find_reloads): When reloading a PLUS with constant\n\toperand, make sure the constant is pushed to the constant pool\n\tif required.\n\t* config/s390/s390.c (s390_secondary_input_reload_class): Remove\n\treload bug workaround.\n\t(s390_expand_plus_operand): Likewise.\n\nFrom-SVN: r89047", "tree": {"sha": "0c4c2b3cfe155b28ab774d52e64484b7007ac262", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c4c2b3cfe155b28ab774d52e64484b7007ac262"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d58005c7d647a2c0ae5f842c34792f2582879e10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d58005c7d647a2c0ae5f842c34792f2582879e10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d58005c7d647a2c0ae5f842c34792f2582879e10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d58005c7d647a2c0ae5f842c34792f2582879e10/comments", "author": null, "committer": null, "parents": [{"sha": "3020563ae2865bc728ad4f113dfd36e6b0bb764a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3020563ae2865bc728ad4f113dfd36e6b0bb764a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3020563ae2865bc728ad4f113dfd36e6b0bb764a"}], "stats": {"total": 46, "additions": 31, "deletions": 15}, "files": [{"sha": "a685ef6e705aeae0753a5f82b99bc71c594c74a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d58005c7d647a2c0ae5f842c34792f2582879e10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d58005c7d647a2c0ae5f842c34792f2582879e10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d58005c7d647a2c0ae5f842c34792f2582879e10", "patch": "@@ -1,3 +1,12 @@\n+2004-10-14  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* reload.c (find_reloads): When reloading a PLUS with constant\n+\toperand, make sure the constant is pushed to the constant pool\n+\tif required.\n+\t* config/s390/s390.c (s390_secondary_input_reload_class): Remove\n+\treload bug workaround.\n+\t(s390_expand_plus_operand): Likewise.\n+\n 2004-10-14  David Edelsohn  <edelsohn@gnu.org>\n \n \t* opts.c (common_handle_option): Do not enable"}, {"sha": "89e1cb19425f46b4752e18cdea0d83272a3a91d5", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d58005c7d647a2c0ae5f842c34792f2582879e10/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d58005c7d647a2c0ae5f842c34792f2582879e10/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=d58005c7d647a2c0ae5f842c34792f2582879e10", "patch": "@@ -2274,17 +2274,7 @@ s390_secondary_input_reload_class (enum reg_class class ATTRIBUTE_UNUSED,\n \t\t\t\t   enum machine_mode mode, rtx in)\n {\n   if (s390_plus_operand (in, mode))\n-    {\n-      /* ??? Reload sometimes pushes a PLUS reload with a too-large constant.\n-\t Until reload is fixed, we need to force_const_mem while emitting the\n-\t secondary reload insn -- thus we need to make sure here that we do\n-\t have a literal pool for the current function.  */\n-      if (CONSTANT_P (XEXP (in, 1))\n-\t  && !legitimate_reload_constant_p (XEXP (in, 1)))\n-\tcurrent_function_uses_const_pool = true;\n-\n-      return ADDR_REGS;\n-    }\n+    return ADDR_REGS;\n \n   return NO_REGS;\n }\n@@ -2366,10 +2356,6 @@ s390_expand_plus_operand (register rtx target, register rtx src,\n \t}\n       if (true_regnum (sum2) < 1 || true_regnum (sum2) > 15)\n \t{\n-\t  /* ??? See comment in s390_secondary_input_reload_class.  */\n-\t  if (CONSTANT_P (sum2) && !legitimate_reload_constant_p (sum2))\n-\t    sum2 = force_const_mem (Pmode, sum2);\n-\n \t  emit_move_insn (scratch, sum2);\n \t  sum2 = scratch;\n \t}"}, {"sha": "66894dc1db7bebd792cf7aff5011bdb340d45c96", "filename": "gcc/reload.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d58005c7d647a2c0ae5f842c34792f2582879e10/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d58005c7d647a2c0ae5f842c34792f2582879e10/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=d58005c7d647a2c0ae5f842c34792f2582879e10", "patch": "@@ -3778,6 +3778,27 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t  goal_alternative_win[i] = 1;\n       }\n \n+  /* Likewise any invalid constants appearing as operand of a PLUS\n+     that is to be reloaded.  */\n+  for (i = 0; i < noperands; i++)\n+    if (! goal_alternative_win[i]\n+\t&& GET_CODE (recog_data.operand[i]) == PLUS\n+\t&& CONST_POOL_OK_P (XEXP (recog_data.operand[i], 1))\n+\t&& (PREFERRED_RELOAD_CLASS (XEXP (recog_data.operand[i], 1),\n+\t\t\t\t    (enum reg_class) goal_alternative[i])\n+\t     == NO_REGS)\n+\t&& operand_mode[i] != VOIDmode)\n+      {\n+\trtx tem = force_const_mem (operand_mode[i],\n+\t\t\t\t   XEXP (recog_data.operand[i], 1));\n+\ttem = gen_rtx_PLUS (operand_mode[i],\n+\t\t\t    XEXP (recog_data.operand[i], 0), tem);\n+\n+\tsubsted_operand[i] = recog_data.operand[i]\n+\t  = find_reloads_toplev (tem, i, address_type[i],\n+\t\t\t\t ind_levels, 0, insn, NULL);\n+      }\n+\n   /* Record the values of the earlyclobber operands for the caller.  */\n   if (goal_earlyclobber)\n     for (i = 0; i < noperands; i++)"}]}