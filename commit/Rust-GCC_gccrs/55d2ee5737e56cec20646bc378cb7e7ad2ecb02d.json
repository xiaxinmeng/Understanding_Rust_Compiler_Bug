{"sha": "55d2ee5737e56cec20646bc378cb7e7ad2ecb02d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVkMmVlNTczN2U1NmNlYzIwNjQ2YmMzNzhjYjdlN2FkMmVjYjAyZA==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2015-04-14T05:04:03Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2015-04-14T05:04:03Z"}, "message": "predicates.md (any_QIreg_operand): Rename from q_regs_operand.\n\n\t* config/i386/predicates.md (any_QIreg_operand): Rename from\n\tq_regs_operand.  Do not process subregs.\n\t(QIreg_operand): Use QI_REGNO_P predicate.\n\t(ext_QIreg_operand): Ditto.\n\t(ext_register_operand): Ditto.\n\t* config/i386/i386.md (TEST splitters): Use QIreg_operand predicate.\n\t(AND splitters): Ditto.\n\t(AND with -65536 splitter): Add SWI48 mode for operand 0.\n\t(AND with -256 splitter): Use any_QIreg_operand predicate and\n\tSWI248 mode for operand 0.\n\t(AND with -65281 splitter): Use QIreg_operand predicate and SWI248\n\tmode for operand 0.\n\t(SETCC + MOVZBL peepholes): Update for renamed any_QIreg_operand.\n\nFrom-SVN: r222076", "tree": {"sha": "5be58b39ce29fdfe8cabfb57dd9130e53bff609b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5be58b39ce29fdfe8cabfb57dd9130e53bff609b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55d2ee5737e56cec20646bc378cb7e7ad2ecb02d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55d2ee5737e56cec20646bc378cb7e7ad2ecb02d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55d2ee5737e56cec20646bc378cb7e7ad2ecb02d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55d2ee5737e56cec20646bc378cb7e7ad2ecb02d/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "035762594004b36e416fde0245d2c1c412605389", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/035762594004b36e416fde0245d2c1c412605389", "html_url": "https://github.com/Rust-GCC/gccrs/commit/035762594004b36e416fde0245d2c1c412605389"}], "stats": {"total": 129, "additions": 68, "deletions": 61}, "files": [{"sha": "b1b06b3bf4ee0c180775adaa30d32cd6a3167001", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d2ee5737e56cec20646bc378cb7e7ad2ecb02d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d2ee5737e56cec20646bc378cb7e7ad2ecb02d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=55d2ee5737e56cec20646bc378cb7e7ad2ecb02d", "patch": "@@ -1,3 +1,19 @@\n+2015-04-14  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/predicates.md (any_QIreg_operand): Rename from\n+\tq_regs_operand.  Do not process subregs.\n+\t(QIreg_operand): Use QI_REGNO_P predicate.\n+\t(ext_QIreg_operand): Ditto.\n+\t(ext_register_operand): Ditto.\n+\t* config/i386/i386.md (TEST splitters): Use QIreg_operand predicate.\n+\t(AND splitters): Ditto.\n+\t(AND with -65536 splitter): Add SWI48 mode for operand 0.\n+\t(AND with -256 splitter): Use any_QIreg_operand predicate and\n+\tSWI248 mode for operand 0.\n+\t(AND with -65281 splitter): Use QIreg_operand predicate and SWI248\n+\tmode for operand 0.\n+\t(SETCC + MOVZBL peepholes): Update for renamed any_QIreg_operand.\n+\n 2015-04-13  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* doc/plugins.texi: Rewrite first introductory paragraph."}, {"sha": "7195882f03dd382053d297c18a0ba3279f434162", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d2ee5737e56cec20646bc378cb7e7ad2ecb02d/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d2ee5737e56cec20646bc378cb7e7ad2ecb02d/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=55d2ee5737e56cec20646bc378cb7e7ad2ecb02d", "patch": "@@ -7661,11 +7661,10 @@\n (define_split\n   [(set (match_operand 0 \"flags_reg_operand\")\n \t(match_operator 1 \"compare_operator\"\n-\t  [(and (match_operand 2 \"register_operand\")\n+\t  [(and (match_operand 2 \"QIreg_operand\")\n \t        (match_operand 3 \"const_int_operand\"))\n \t   (const_int 0)]))]\n    \"reload_completed\n-    && QI_REG_P (operands[2])\n     && GET_MODE (operands[2]) != QImode\n     && ((ix86_match_ccmode (insn, CCZmode)\n     \t && !(INTVAL (operands[3]) & ~(255 << 8)))\n@@ -8022,29 +8021,29 @@\n })\n \n (define_split\n-  [(set (match_operand 0 \"register_operand\")\n-\t(and (match_dup 0)\n-\t     (const_int -65536)))\n+  [(set (match_operand:SWI48 0 \"register_operand\")\n+\t(and:SWI48 (match_dup 0)\n+\t\t   (const_int -65536)))\n    (clobber (reg:CC FLAGS_REG))]\n   \"(TARGET_FAST_PREFIX && !TARGET_PARTIAL_REG_STALL)\n     || optimize_function_for_size_p (cfun)\"\n   [(set (strict_low_part (match_dup 1)) (const_int 0))]\n   \"operands[1] = gen_lowpart (HImode, operands[0]);\")\n \n (define_split\n-  [(set (match_operand 0 \"ext_register_operand\")\n-\t(and (match_dup 0)\n-\t     (const_int -256)))\n+  [(set (match_operand:SWI248 0 \"any_QIreg_operand\")\n+\t(and:SWI248 (match_dup 0)\n+\t\t    (const_int -256)))\n    (clobber (reg:CC FLAGS_REG))]\n   \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n    && reload_completed\"\n   [(set (strict_low_part (match_dup 1)) (const_int 0))]\n   \"operands[1] = gen_lowpart (QImode, operands[0]);\")\n \n (define_split\n-  [(set (match_operand 0 \"ext_register_operand\")\n-\t(and (match_dup 0)\n-\t     (const_int -65281)))\n+  [(set (match_operand:SWI248 0 \"QIreg_operand\")\n+\t(and:SWI248 (match_dup 0)\n+\t\t    (const_int -65281)))\n    (clobber (reg:CC FLAGS_REG))]\n   \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n    && reload_completed\"\n@@ -8252,12 +8251,11 @@\n ;; of memory mismatch stalls.  We may want to do the splitting for optimizing\n ;; for size, but that can (should?) be handled by generic code instead.\n (define_split\n-  [(set (match_operand 0 \"register_operand\")\n+  [(set (match_operand 0 \"QIreg_operand\")\n \t(and (match_operand 1 \"register_operand\")\n \t     (match_operand 2 \"const_int_operand\")))\n    (clobber (reg:CC FLAGS_REG))]\n    \"reload_completed\n-    && QI_REG_P (operands[0])\n     && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n     && !(~INTVAL (operands[2]) & ~(255 << 8))\n     && GET_MODE (operands[0]) != QImode\"\n@@ -8275,12 +8273,11 @@\n ;; Since AND can be encoded with sign extended immediate, this is only\n ;; profitable when 7th bit is not set.\n (define_split\n-  [(set (match_operand 0 \"register_operand\")\n+  [(set (match_operand 0 \"any_QIreg_operand\")\n \t(and (match_operand 1 \"general_operand\")\n \t     (match_operand 2 \"const_int_operand\")))\n    (clobber (reg:CC FLAGS_REG))]\n    \"reload_completed\n-    && ANY_QI_REG_P (operands[0])\n     && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n     && !(~INTVAL (operands[2]) & ~255)\n     && !(INTVAL (operands[2]) & 128)\n@@ -8620,12 +8617,11 @@\n    (set_attr \"mode\" \"QI\")])\n \n (define_split\n-  [(set (match_operand 0 \"register_operand\")\n+  [(set (match_operand 0 \"QIreg_operand\")\n \t(any_or (match_operand 1 \"register_operand\")\n \t\t(match_operand 2 \"const_int_operand\")))\n    (clobber (reg:CC FLAGS_REG))]\n    \"reload_completed\n-    && QI_REG_P (operands[0])\n     && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n     && !(INTVAL (operands[2]) & ~(255 << 8))\n     && GET_MODE (operands[0]) != QImode\"\n@@ -8643,12 +8639,11 @@\n ;; Since OR can be encoded with sign extended immediate, this is only\n ;; profitable when 7th bit is set.\n (define_split\n-  [(set (match_operand 0 \"register_operand\")\n+  [(set (match_operand 0 \"any_QIreg_operand\")\n \t(any_or (match_operand 1 \"general_operand\")\n \t\t(match_operand 2 \"const_int_operand\")))\n    (clobber (reg:CC FLAGS_REG))]\n    \"reload_completed\n-    && ANY_QI_REG_P (operands[0])\n     && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n     && !(INTVAL (operands[2]) & ~255)\n     && (INTVAL (operands[2]) & 128)\n@@ -9574,7 +9569,7 @@\n \n     case TYPE_ALU:\n       gcc_assert (operands[2] == const1_rtx);\n-      if (REG_P (operands[1]) && !ANY_QI_REG_P (operands[1]))\n+      if (REG_P (operands[1]) && !ANY_QI_REGNO_P (REGNO (operands[1])))\n         return \"add{l}\\t%k0, %k0\";\n       else\n         return \"add{b}\\t%0, %0\";\n@@ -11567,7 +11562,7 @@\n    (set (match_operand:QI 1 \"register_operand\")\n \t(match_operator:QI 2 \"ix86_comparison_operator\"\n \t  [(reg FLAGS_REG) (const_int 0)]))\n-   (set (match_operand 3 \"q_regs_operand\")\n+   (set (match_operand 3 \"any_QIreg_operand\")\n \t(zero_extend (match_dup 1)))]\n   \"(peep2_reg_dead_p (3, operands[1])\n     || operands_match_p (operands[1], operands[3]))\n@@ -11587,7 +11582,7 @@\n    (set (match_operand:QI 1 \"register_operand\")\n \t(match_operator:QI 2 \"ix86_comparison_operator\"\n \t  [(reg FLAGS_REG) (const_int 0)]))\n-   (set (match_operand 3 \"q_regs_operand\")\n+   (set (match_operand 3 \"any_QIreg_operand\")\n \t(zero_extend (match_dup 1)))]\n   \"(peep2_reg_dead_p (3, operands[1])\n     || operands_match_p (operands[1], operands[3]))\n@@ -11609,7 +11604,7 @@\n    (set (match_operand:QI 1 \"register_operand\")\n \t(match_operator:QI 2 \"ix86_comparison_operator\"\n \t  [(reg FLAGS_REG) (const_int 0)]))\n-   (parallel [(set (match_operand:SI 3 \"q_regs_operand\")\n+   (parallel [(set (match_operand:SI 3 \"any_QIreg_operand\")\n \t\t   (and:SI (match_dup 3) (const_int 255)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"REGNO (operands[1]) == REGNO (operands[3])\n@@ -11629,7 +11624,7 @@\n    (set (match_operand:QI 1 \"register_operand\")\n \t(match_operator:QI 2 \"ix86_comparison_operator\"\n \t  [(reg FLAGS_REG) (const_int 0)]))\n-   (parallel [(set (match_operand 3 \"q_regs_operand\")\n+   (parallel [(set (match_operand 3 \"any_QIreg_operand\")\n \t\t   (zero_extend (match_dup 1)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"(peep2_reg_dead_p (3, operands[1])\n@@ -17454,7 +17449,7 @@\n \t(match_operator 1 \"compare_operator\"\n \t  [(and:SI\n \t     (zero_extract:SI\n-\t       (match_operand 2 \"ext_register_operand\")\n+\t       (match_operand 2 \"QIreg_operand\")\n \t       (const_int 8)\n \t       (const_int 8))\n \t     (match_operand 3 \"const_int_operand\"))\n@@ -17599,7 +17594,7 @@\n    && !reg_overlap_mentioned_p (operands[0], operands[2])\n    && (<MODE>mode != QImode\n        || immediate_operand (operands[2], QImode)\n-       || q_regs_operand (operands[2], QImode))\n+       || any_QIreg_operand (operands[2], QImode))\n    && ix86_match_ccmode (peep2_next_insn (3),\n \t\t\t (GET_CODE (operands[3]) == PLUS\n \t\t\t  || GET_CODE (operands[3]) == MINUS)\n@@ -17659,7 +17654,7 @@\n    && peep2_reg_dead_p (4, operands[0])\n    && (<MODE>mode != QImode\n        || immediate_operand (operands[2], SImode)\n-       || q_regs_operand (operands[2], SImode))\n+       || any_QIreg_operand (operands[2], SImode))\n    && !reg_overlap_mentioned_p (operands[0], operands[1])\n    && !reg_overlap_mentioned_p (operands[0], operands[2])\n    && ix86_match_ccmode (peep2_next_insn (3),"}, {"sha": "136a3887acaef0446e34010c8e8b0c58a9e64cd6", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 30, "deletions": 34, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d2ee5737e56cec20646bc378cb7e7ad2ecb02d/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d2ee5737e56cec20646bc378cb7e7ad2ecb02d/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=55d2ee5737e56cec20646bc378cb7e7ad2ecb02d", "patch": "@@ -62,19 +62,31 @@\n   (and (match_code \"reg\")\n        (match_test \"MASK_REGNO_P (REGNO (op))\")))\n \n-;; True if the operand is a Q_REGS class register.\n-(define_predicate \"q_regs_operand\"\n-  (match_operand 0 \"register_operand\")\n-{\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  return ANY_QI_REG_P (op);\n-})\n+;; Return true if op is a QImode register.\n+(define_predicate \"any_QIreg_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"ANY_QI_REGNO_P (REGNO (op))\")))\n \n-;; Return true if OP is a memory operands that can be used in sibcalls.\n-(define_predicate \"sibcall_memory_operand\"\n-  (and (match_operand 0 \"memory_operand\")\n-       (match_test \"CONSTANT_P (XEXP (op, 0))\")))\n+;; Return true if op is one of QImode registers: %[abcd][hl].\n+(define_predicate \"QIreg_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"QI_REGNO_P (REGNO (op))\")))\n+\n+;; Return true if op is a QImode register operand other than %[abcd][hl].\n+(define_predicate \"ext_QIreg_operand\"\n+  (and (match_test \"TARGET_64BIT\")\n+       (match_code \"reg\")\n+       (not (match_test \"QI_REGNO_P (REGNO (op))\"))))\n+\n+;; Return true if op is the AX register.\n+(define_predicate \"ax_reg_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == AX_REG\")))\n+\n+;; Return true if op is the flags register.\n+(define_predicate \"flags_reg_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == FLAGS_REG\")))\n \n ;; Match an SI or HImode register for a zero_extract.\n (define_special_predicate \"ext_register_operand\"\n@@ -88,7 +100,7 @@\n \n   /* Be careful to accept only registers having upper parts.  */\n   return (REG_P (op)\n-\t  && (REGNO (op) > LAST_VIRTUAL_REGISTER || REGNO (op) <= BX_REG));\n+\t  && (REGNO (op) > LAST_VIRTUAL_REGISTER || QI_REGNO_P (REGNO (op))));\n })\n \n ;; Match nonimmediate operands, but exclude memory operands on 64bit targets.\n@@ -103,27 +115,6 @@\n     (match_operand 0 \"nonmemory_operand\")\n     (match_operand 0 \"general_operand\")))\n \n-;; Return true if op is the AX register.\n-(define_predicate \"ax_reg_operand\"\n-  (and (match_code \"reg\")\n-       (match_test \"REGNO (op) == AX_REG\")))\n-\n-;; Return true if op is the flags register.\n-(define_predicate \"flags_reg_operand\"\n-  (and (match_code \"reg\")\n-       (match_test \"REGNO (op) == FLAGS_REG\")))\n-\n-;; Return true if op is one of QImode registers: %[abcd][hl].\n-(define_predicate \"QIreg_operand\"\n-  (match_test \"QI_REG_P (op)\"))\n-\n-;; Return true if op is a QImode register operand other than\n-;; %[abcd][hl].\n-(define_predicate \"ext_QIreg_operand\"\n-  (and (match_code \"reg\")\n-       (match_test \"TARGET_64BIT\")\n-       (match_test \"REGNO (op) > BX_REG\")))\n-\n ;; Return true if VALUE is symbol reference\n (define_predicate \"symbol_operand\"\n   (match_code \"symbol_ref\"))\n@@ -604,6 +595,11 @@\n        (and (not (match_test \"TARGET_X32\"))\n \t    (match_operand 0 \"memory_operand\"))))\n \n+;; Return true if OP is a memory operands that can be used in sibcalls.\n+(define_predicate \"sibcall_memory_operand\"\n+  (and (match_operand 0 \"memory_operand\")\n+       (match_test \"CONSTANT_P (XEXP (op, 0))\")))\n+\n ;; Test for a valid operand for a call instruction.\n ;; Allow constant call address operands in Pmode only.\n (define_special_predicate \"call_insn_operand\""}]}