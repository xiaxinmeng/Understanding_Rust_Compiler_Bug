{"sha": "6d73fddc3f93058d8f3534a3b888779a134c484e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ3M2ZkZGMzZjkzMDU4ZDhmMzUzNGEzYjg4ODc3OWExMzRjNDg0ZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchell@usa.net", "date": "1998-05-18T12:28:30Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-05-18T12:28:30Z"}, "message": "parse.y (.finish_new_placement): New non-terminal.\n\n\t* parse.y (.finish_new_placement): New non-terminal.\n\t(unary_expr, new_type_id): Use it.\n\t* parse.c: Regenerated.\n\nFrom-SVN: r19852", "tree": {"sha": "4756cb9356d2b3c4c576d79b7c7187d972897a4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4756cb9356d2b3c4c576d79b7c7187d972897a4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d73fddc3f93058d8f3534a3b888779a134c484e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d73fddc3f93058d8f3534a3b888779a134c484e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d73fddc3f93058d8f3534a3b888779a134c484e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d73fddc3f93058d8f3534a3b888779a134c484e/comments", "author": null, "committer": null, "parents": [{"sha": "4a95fafeda4731aba81d44ac49e0468599ebe2dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a95fafeda4731aba81d44ac49e0468599ebe2dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a95fafeda4731aba81d44ac49e0468599ebe2dc"}], "stats": {"total": 7589, "additions": 3789, "deletions": 3800}, "files": [{"sha": "981787a37ad962139e66ab05cd334d1b3a734973", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d73fddc3f93058d8f3534a3b888779a134c484e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d73fddc3f93058d8f3534a3b888779a134c484e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6d73fddc3f93058d8f3534a3b888779a134c484e", "patch": "@@ -1,3 +1,9 @@\n+Mon May 18 12:28:44 1998  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* parse.y (.finish_new_placement): New non-terminal.\n+\t(unary_expr, new_type_id): Use it.  \n+\t* parse.c: Regenerated.\n+\t\n Mon May 18 12:20:27 1998  Brendan Kehoe  <brendan@cygnus.com>\n \n \t* pt.c (redeclare_class_template): Say where the original definition"}, {"sha": "c78ffbcaf7f8aa954162717ca9cbd58af8a40be8", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 3756, "deletions": 3777, "changes": 7533, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d73fddc3f93058d8f3534a3b888779a134c484e/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d73fddc3f93058d8f3534a3b888779a134c484e/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=6d73fddc3f93058d8f3534a3b888779a134c484e"}, {"sha": "f6f638cc0f0a93c8354254c1d5f437c55d60bf89", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d73fddc3f93058d8f3534a3b888779a134c484e/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d73fddc3f93058d8f3534a3b888779a134c484e/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=6d73fddc3f93058d8f3534a3b888779a134c484e", "patch": "@@ -1040,23 +1040,23 @@ unary_expr:\n \t   so there is nothing we can do.  Fortunately,\n \t   begin_new_placement does nothing harmful.  When we rewrite\n \t   the parser, this lossage should be removed, of course.  */\n-\t| new '(' .begin_new_placement type_id \n-                { finish_new_placement (NULL_TREE, $3); }\n-\t    ')'  %prec EMPTY\n+\t| new '(' .begin_new_placement type_id .finish_new_placement\n+            %prec EMPTY\n \t\t{ $$ = build_new (NULL_TREE, groktypename($4.t),\n \t\t\t\t  NULL_TREE, $1); \n \t\t  check_for_new_type (\"new\", $4); }\n-\t| new '(' .begin_new_placement type_id \n-                { finish_new_placement (NULL_TREE, $3); }\n-            ')' new_initializer\n-\t\t{ $$ = build_new (NULL_TREE, groktypename($4.t), $7, $1); \n-\t\t  check_for_new_type (\"new\", $4); }\n-\t| new new_placement '(' type_id ')'  %prec EMPTY\n-\t\t{ $$ = build_new ($2, groktypename($4.t), NULL_TREE, $1); \n-\t  check_for_new_type (\"new\", $4); }\n-\t| new new_placement '(' type_id ')' new_initializer\n-\t\t{ $$ = build_new ($2, groktypename($4.t), $6, $1); \n+\t| new '(' .begin_new_placement type_id .finish_new_placement\n+            new_initializer\n+\t\t{ $$ = build_new (NULL_TREE, groktypename($4.t), $6, $1); \n \t\t  check_for_new_type (\"new\", $4); }\n+\t| new new_placement '(' .begin_new_placement type_id\n+\t    .finish_new_placement   %prec EMPTY\n+\t\t{ $$ = build_new ($2, groktypename($5.t), NULL_TREE, $1); \n+\t\t  check_for_new_type (\"new\", $5); }\n+\t| new new_placement '(' .begin_new_placement type_id\n+\t    .finish_new_placement  new_initializer\n+\t\t{ $$ = build_new ($2, groktypename($5.t), $7, $1); \n+\t\t  check_for_new_type (\"new\", $5); }\n \n \t| delete cast_expr  %prec UNARY\n \t\t{ $$ = delete_sanity ($2, NULL_TREE, 0, $1); }\n@@ -1074,17 +1074,22 @@ unary_expr:\n \t\t{ $$ = build_x_unary_op (IMAGPART_EXPR, $2); }\n \t;\n \n+        /* Note this rule is not suitable for use in new_placement\n+\t   since it uses NULL_TREE as the argument to\n+\t   finish_new_placement.  This rule serves only to avoid\n+\t   reduce/reduce conflicts in unary_expr.  See the comments\n+\t   there on the use of begin/finish_new_placement.  */\n+.finish_new_placement:\n+\t  ')'\n+                { finish_new_placement (NULL_TREE, $<itype>-1); }\n+\n .begin_new_placement:\n                 { $$ = begin_new_placement (); }\n \n new_placement:\n-\t  '(' \n-\t    .begin_new_placement\n-            nonnull_exprlist ')'\n+\t  '(' .begin_new_placement nonnull_exprlist ')'\n                 { $$ = finish_new_placement ($3, $2); }\n-\t| '{' \n-\t    .begin_new_placement\n-\t    nonnull_exprlist '}'\n+\t| '{' .begin_new_placement nonnull_exprlist '}'\n                 { cp_pedwarn (\"old style placement syntax, use () instead\");\n \t\t  $$ = finish_new_placement ($3, $2); }\n \t;\n@@ -2570,13 +2575,12 @@ new_type_id:\n \t/* GNU extension to allow arrays of arbitrary types with\n \t   non-constant dimension.  For the use of begin_new_placement\n \t   here, see the comments in unary_expr above.  */\n-\t| '(' .begin_new_placement type_id \n-                { finish_new_placement (NULL_TREE, $2); }\n-\t   ')' '[' expr ']'\n+\t| '(' .begin_new_placement type_id .finish_new_placement\n+\t      '[' expr ']'\n \t\t{\n \t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids array dimensions with parenthesized type in new\");\n-\t\t  $$.t = build_parse_node (ARRAY_REF, TREE_VALUE ($3.t), $7);\n+\t\t  $$.t = build_parse_node (ARRAY_REF, TREE_VALUE ($3.t), $6);\n \t\t  $$.t = build_decl_list (TREE_PURPOSE ($3.t), $$.t);\n \t\t  $$.new_type_flag = $3.new_type_flag;\n \t\t}"}]}