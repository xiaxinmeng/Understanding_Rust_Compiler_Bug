{"sha": "fa47911c5600725d7d72e224e4a61829267b00b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE0NzkxMWM1NjAwNzI1ZDdkNzJlMjI0ZTRhNjE4MjkyNjdiMDBiOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2005-06-23T14:44:21Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2005-06-23T14:44:21Z"}, "message": "re PR c++/19317 (removing a temporary return value when we cannot)\n\n        PR c++/19317\n        Leave the return slot target in the MODIFY_EXPR rather than making\n        it an argument, but only use it if the CALL_EXPR has a flag set.\n        * tree.h (CALL_EXPR_HAS_RETURN_SLOT_ADDR): Rename to\n        CALL_EXPR_RETURN_SLOT_OPT.\n        * calls.c (expand_call): Adjust.\n        * tree-inline.c (expand_call_inline): Adjust.\n        * tree-pretty-print.c (dump_generic_node): Adjust.\n\n        And set the flag as appropriate.\n        * gimplify.c (gimplify_modify_expr_rhs): Set\n        CALL_EXPR_HAS_RETURN_SLOT_ADDR where the LHS is obviously safe.\n        * tree-nrv.c (execute_return_slot_opt): Set\n        CALL_EXPR_HAS_RETURN_SLOT_ADDR based on escape analysis.\n        * tree-pass.h: Declare pass_return_slot.\n        * tree-optimize.c (init_tree_optimization_passes): Add it.\n\n        * cp/semantics.c (simplify_aggr_init_expr): Use\n        CALL_EXPR_RETURN_SLOT_OPT, not CALL_EXPR_HAS_RETURN_SLOT_ADDR.\n\nFrom-SVN: r101269", "tree": {"sha": "672b804a497a6d4d52b747f00969c6d7b30ebbfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/672b804a497a6d4d52b747f00969c6d7b30ebbfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa47911c5600725d7d72e224e4a61829267b00b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa47911c5600725d7d72e224e4a61829267b00b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa47911c5600725d7d72e224e4a61829267b00b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa47911c5600725d7d72e224e4a61829267b00b9/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f565b0a1a58554b7dd3cbd540f6dca295bd0cdbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f565b0a1a58554b7dd3cbd540f6dca295bd0cdbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f565b0a1a58554b7dd3cbd540f6dca295bd0cdbe"}], "stats": {"total": 244, "additions": 198, "deletions": 46}, "files": [{"sha": "c7aaa16eee6d2545b9ca69e5e4bea5d1fffc0780", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa47911c5600725d7d72e224e4a61829267b00b9", "patch": "@@ -1,3 +1,22 @@\n+2005-06-23  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/19317\n+\tLeave the return slot target in the MODIFY_EXPR rather than making\n+\tit an argument, but only use it if the CALL_EXPR has a flag set.\n+\t* tree.h (CALL_EXPR_HAS_RETURN_SLOT_ADDR): Rename to\n+\tCALL_EXPR_RETURN_SLOT_OPT.\n+\t* calls.c (expand_call): Adjust.\n+\t* tree-inline.c (expand_call_inline): Adjust.\n+\t* tree-pretty-print.c (dump_generic_node): Adjust.\n+\n+\tAnd set the flag as appropriate.\n+\t* gimplify.c (gimplify_modify_expr_rhs): Set\n+\tCALL_EXPR_HAS_RETURN_SLOT_ADDR where the LHS is obviously safe.\n+\t* tree-nrv.c (execute_return_slot_opt): Set\n+\tCALL_EXPR_HAS_RETURN_SLOT_ADDR based on escape analysis.\n+\t* tree-pass.h: Declare pass_return_slot.\n+\t* tree-optimize.c (init_tree_optimization_passes): Add it.\n+\t\n 2005-06-23  David Edelsohn  <edelsohn@gnu.org>\n \n \tPR target/21760"}, {"sha": "043888e6bde63d4eb29c5d29a8f67672f28b72cb", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=fa47911c5600725d7d72e224e4a61829267b00b9", "patch": "@@ -1964,17 +1964,7 @@ expand_call (tree exp, rtx target, int ignore)\n       {\n \tstruct_value_size = int_size_in_bytes (TREE_TYPE (exp));\n \n-\tif (CALL_EXPR_HAS_RETURN_SLOT_ADDR (exp))\n-\t  {\n-\t    /* The structure value address arg is already in actparms.\n-\t       Pull it out.  It might be nice to just leave it there, but\n-\t       we need to set structure_value_addr.  */\n-\t    tree return_arg = TREE_VALUE (actparms);\n-\t    actparms = TREE_CHAIN (actparms);\n-\t    structure_value_addr = expand_expr (return_arg, NULL_RTX,\n-\t\t\t\t\t\tVOIDmode, EXPAND_NORMAL);\n-\t  }\n-\telse if (target && MEM_P (target))\n+\tif (target && MEM_P (target) && CALL_EXPR_RETURN_SLOT_OPT (exp))\n \t  structure_value_addr = XEXP (target, 0);\n \telse\n \t  {"}, {"sha": "61b8a03c25a739d9a6041d93b621cf53b04ef1b8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fa47911c5600725d7d72e224e4a61829267b00b9", "patch": "@@ -1,3 +1,9 @@\n+2005-06-23  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/19317\n+\t* semantics.c (simplify_aggr_init_expr): Use\n+\tCALL_EXPR_RETURN_SLOT_OPT, not CALL_EXPR_HAS_RETURN_SLOT_ADDR.\n+\n 2005-06-23  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \t* pt.c (register_specialization): Remove superfluous assertion."}, {"sha": "157ec9c792e1eb0e8f2c5a10b79b841d6ffa7e70", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=fa47911c5600725d7d72e224e4a61829267b00b9", "patch": "@@ -2904,27 +2904,15 @@ simplify_aggr_init_expr (tree *tp)\n       style = arg;\n     }\n \n-  if (style == ctor || style == arg)\n+  if (style == ctor)\n     {\n-      /* Pass the address of the slot.  If this is a constructor, we\n-\t replace the first argument; otherwise, we tack on a new one.  */\n+      /* Replace the first argument to the ctor with the address of the\n+\t slot.  */\n       tree addr;\n \n-      if (style == ctor)\n-\targs = TREE_CHAIN (args);\n-\n+      args = TREE_CHAIN (args);\n       cxx_mark_addressable (slot);\n       addr = build1 (ADDR_EXPR, build_pointer_type (type), slot);\n-      if (style == arg)\n-\t{\n-\t  /* The return type might have different cv-quals from the slot.  */\n-\t  tree fntype = TREE_TYPE (TREE_TYPE (fn));\n-\n-\t  gcc_assert (TREE_CODE (fntype) == FUNCTION_TYPE\n-\t\t      || TREE_CODE (fntype) == METHOD_TYPE);\n-\t  addr = convert (build_pointer_type (TREE_TYPE (fntype)), addr);\n-\t}\n-\n       args = tree_cons (NULL_TREE, addr, args);\n     }\n \n@@ -2933,9 +2921,13 @@ simplify_aggr_init_expr (tree *tp)\n \t\t      fn, args, NULL_TREE);\n \n   if (style == arg)\n-    /* Tell the backend that we've added our return slot to the argument\n-       list.  */\n-    CALL_EXPR_HAS_RETURN_SLOT_ADDR (call_expr) = 1;\n+    {\n+      /* Just mark it addressable here, and leave the rest to\n+\t expand_call{,_inline}.  */\n+      cxx_mark_addressable (slot);\n+      CALL_EXPR_RETURN_SLOT_OPT (call_expr) = true;\n+      call_expr = build2 (MODIFY_EXPR, TREE_TYPE (call_expr), slot, call_expr);\n+    }\n   else if (style == pcc)\n     {\n       /* If we're using the non-reentrant PCC calling convention, then we\n@@ -2945,6 +2937,7 @@ simplify_aggr_init_expr (tree *tp)\n       call_expr = build_aggr_init (slot, call_expr,\n \t\t\t\t   DIRECT_BIND | LOOKUP_ONLYCONVERTING);\n       pop_deferring_access_checks ();\n+      call_expr = build (COMPOUND_EXPR, TREE_TYPE (slot), call_expr, slot);\n     }\n \n   *tp = call_expr;"}, {"sha": "81512728dc531bc34828494a77468ccbe9943683", "filename": "gcc/gimplify.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=fa47911c5600725d7d72e224e4a61829267b00b9", "patch": "@@ -3015,6 +3015,46 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n \t  ret = GS_UNHANDLED;\n \tbreak;\n \n+      case CALL_EXPR:\n+\t/* For calls that return in memory, give *to_p as the CALL_EXPR's\n+\t   return slot so that we don't generate a temporary.  */\n+\tif (!CALL_EXPR_RETURN_SLOT_OPT (*from_p)\n+\t    && aggregate_value_p (*from_p, *from_p))\n+\t  {\n+\t    bool use_target;\n+\n+\t    if (TREE_CODE (*to_p) == RESULT_DECL\n+\t\t&& needs_to_live_in_memory (*to_p))\n+\t      /* It's always OK to use the return slot directly.  */\n+\t      use_target = true;\n+\t    else if (!is_gimple_non_addressable (*to_p))\n+\t      /* Don't use the original target if it's already addressable;\n+\t\t if its address escapes, and the called function uses the\n+\t\t NRV optimization, a conforming program could see *to_p\n+\t\t change before the called function returns; see c++/19317.\n+\t\t When optimizing, the return_slot pass marks more functions\n+\t\t as safe after we have escape info.  */\n+\t      use_target = false;\n+\t    else if (DECL_GIMPLE_FORMAL_TEMP_P (*to_p))\n+\t      /* Don't use the original target if it's a formal temp; we\n+\t\t don't want to take their addresses.  */\n+\t      use_target = false;\n+\t    else if (is_gimple_reg_type (TREE_TYPE (*to_p)))\n+\t      /* Also don't force regs into memory.  */\n+\t      use_target = false;\n+\t    else\n+\t      use_target = true;\n+\n+\t    if (use_target)\n+\t      {\n+\t\tCALL_EXPR_RETURN_SLOT_OPT (*from_p) = 1;\n+\t\tlang_hooks.mark_addressable (*to_p);\n+\t      }\n+\t  }\n+\n+\tret = GS_UNHANDLED;\n+\tbreak;\n+\n       default:\n \tret = GS_UNHANDLED;\n \tbreak;"}, {"sha": "6f8d54975faa702df47258dbb80658bd22902f40", "filename": "gcc/testsuite/g++.dg/opt/nrv9.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fnrv9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fnrv9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fnrv9.C?ref=fa47911c5600725d7d72e224e4a61829267b00b9", "patch": "@@ -0,0 +1,28 @@\n+// PR c++/19317\n+// If we do both NRV and caller-side return slot opt for ma = ma.f,\n+// constructing fa incorrectly sets ma.i to 0.\n+\n+extern \"C\" void abort();\n+\n+struct A\n+{\n+  int i;\n+  int pad[32];\t\t\t// force return in memory\n+  A(): i(0) {}\n+  A(int ia): i(ia) {}\n+};\n+\n+A ga(42);\n+\n+A f()\n+{\n+  A la;\n+  if (ga.i != 42)\n+    abort();\n+  return la;\n+}\n+\n+int main()\n+{\n+  ga = f ();\n+}"}, {"sha": "8f9e278ecebf3e9457ef8222781035669729eca8", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=fa47911c5600725d7d72e224e4a61829267b00b9", "patch": "@@ -2026,13 +2026,6 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n \n   /* Initialize the parameters.  */\n   args = TREE_OPERAND (t, 1);\n-  if (CALL_EXPR_HAS_RETURN_SLOT_ADDR (t))\n-    {\n-      return_slot_addr = TREE_VALUE (args);\n-      args = TREE_CHAIN (args);\n-    }\n-  else\n-    return_slot_addr = NULL_TREE;\n \n   initialize_inlined_parameters (id, args, TREE_OPERAND (t, 2), fn, bb);\n \n@@ -2046,10 +2039,10 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n   gcc_assert (TREE_CODE (DECL_INITIAL (fn)) == BLOCK);\n \n   /* Find the lhs to which the result of this call is assigned.  */\n-  modify_dest = stmt;\n-  if (TREE_CODE (modify_dest) == MODIFY_EXPR)\n+  return_slot_addr = NULL;\n+  if (TREE_CODE (stmt) == MODIFY_EXPR)\n     {\n-      modify_dest = TREE_OPERAND (modify_dest, 0);\n+      modify_dest = TREE_OPERAND (stmt, 0);\n \n       /* The function which we are inlining might not return a value,\n \t in which case we should issue a warning that the function\n@@ -2059,6 +2052,11 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n \t uninitialized variable.  */\n       if (DECL_P (modify_dest))\n \tTREE_NO_WARNING (modify_dest) = 1;\n+      if (CALL_EXPR_RETURN_SLOT_OPT (t))\n+\t{\n+\t  return_slot_addr = build_fold_addr_expr (modify_dest);\n+\t  modify_dest = NULL;\n+\t}\n     }\n   else\n     modify_dest = NULL;"}, {"sha": "a88c97785baba688ab3c7aa1417ab37b9f690b1c", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=fa47911c5600725d7d72e224e4a61829267b00b9", "patch": "@@ -218,3 +218,79 @@ struct tree_opt_pass pass_nrv =\n   TODO_dump_func | TODO_ggc_collect,\t\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n+\n+/* Walk through the function looking for MODIFY_EXPRs with calls that\n+   return in memory on the RHS.  For each of these, determine whether it is\n+   safe to pass the address of the LHS as the return slot, and mark the\n+   call appropriately if so.\n+\n+   The NRV shares the return slot with a local variable in the callee; this\n+   optimization shares the return slot with the target of the call within\n+   the caller.  If the NRV is performed (which we can't know in general),\n+   this optimization is safe if the address of the target has not\n+   escaped prior to the call.  If it has, modifications to the local\n+   variable will produce visible changes elsewhere, as in PR c++/19317.  */\n+\n+static void\n+execute_return_slot_opt (void)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator i;\n+      for (i = bsi_start (bb); !bsi_end_p (i); bsi_next (&i))\n+\t{\n+\t  tree stmt = bsi_stmt (i);\n+\t  tree call;\n+\n+\t  if (TREE_CODE (stmt) == MODIFY_EXPR\n+\t      && (call = TREE_OPERAND (stmt, 1),\n+\t\t  TREE_CODE (call) == CALL_EXPR)\n+\t      && !CALL_EXPR_RETURN_SLOT_OPT (call)\n+\t      && aggregate_value_p (call, call))\n+\t    {\n+\t      def_operand_p def_p;\n+\t      ssa_op_iter op_iter;\n+\n+\t      /* We determine whether or not the LHS address escapes by\n+\t\t asking whether it is call clobbered.  When the LHS isn't a\n+\t\t simple decl, we need to check the VDEFs, so it's simplest\n+\t\t to just loop through all the DEFs.  */\n+\t      FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, op_iter, SSA_OP_ALL_DEFS)\n+\t\t{\n+\t\t  tree def = DEF_FROM_PTR (def_p);\n+\t\t  if (TREE_CODE (def) == SSA_NAME)\n+\t\t    def = SSA_NAME_VAR (def);\n+\t\t  if (is_call_clobbered (def))\n+\t\t    goto unsafe;\n+\t\t}\n+\n+\t      /* No defs are call clobbered, so the optimization is safe.  */\n+\t      CALL_EXPR_RETURN_SLOT_OPT (call) = 1;\n+\t      /* This is too late to mark the target addressable like we do\n+\t\t in gimplify_modify_expr_rhs, but that's OK; anything that\n+\t\t wasn't already addressable was handled there.  */\n+\n+\t      unsafe:;\n+\t    }\n+\t}\n+    }\n+}\n+\n+struct tree_opt_pass pass_return_slot = \n+{\n+  \"retslot\",\t\t\t\t/* name */\n+  NULL,\t\t\t\t\t/* gate */\n+  execute_return_slot_opt,\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  PROP_ssa | PROP_alias,\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  0,\t\t\t\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};"}, {"sha": "c2f4fc9d247ebdd1af4d59c5604f78508ec9f8f1", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=fa47911c5600725d7d72e224e4a61829267b00b9", "patch": "@@ -397,6 +397,7 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_build_ssa);\n   NEXT_PASS (pass_build_pta);  \n   NEXT_PASS (pass_may_alias);\n+  NEXT_PASS (pass_return_slot);\n   NEXT_PASS (pass_del_pta);  \n   NEXT_PASS (pass_rename_ssa_copies);\n   NEXT_PASS (pass_early_warn_uninitialized);"}, {"sha": "eb1ad31e720b004bdd980e87f8dd9609293676b9", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=fa47911c5600725d7d72e224e4a61829267b00b9", "patch": "@@ -224,6 +224,7 @@ extern struct tree_opt_pass pass_create_structure_vars;\n extern struct tree_opt_pass pass_build_pta;\n extern struct tree_opt_pass pass_del_pta;\n extern struct tree_opt_pass pass_uncprop;\n+extern struct tree_opt_pass pass_return_slot;\n extern struct tree_opt_pass pass_reassoc;\n \n /* IPA Passes */"}, {"sha": "251c03ced05dd32f7e54ebb424b8a7286d8287e8", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=fa47911c5600725d7d72e224e4a61829267b00b9", "patch": "@@ -1003,8 +1003,8 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t  pp_character (buffer, ']');\n \t}\n \n-      if (CALL_EXPR_HAS_RETURN_SLOT_ADDR (node))\n-\tpp_string (buffer, \" [return slot addr]\");\n+      if (CALL_EXPR_RETURN_SLOT_OPT (node))\n+\tpp_string (buffer, \" [return slot optimization]\");\n       if (CALL_EXPR_TAILCALL (node))\n \tpp_string (buffer, \" [tail call]\");\n       break;"}, {"sha": "831856da599ac90aa3c7b588f58bca41c1666349", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa47911c5600725d7d72e224e4a61829267b00b9/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=fa47911c5600725d7d72e224e4a61829267b00b9", "patch": "@@ -337,7 +337,7 @@ struct tree_common GTY(())\n \n        TREE_PRIVATE in\n            ..._DECL\n-       CALL_EXPR_HAS_RETURN_SLOT_ADDR in\n+       CALL_EXPR_RETURN_SLOT_OPT in\n            CALL_EXPR\n        DECL_BY_REFERENCE in\n            PARM_DECL, RESULT_DECL\n@@ -980,9 +980,9 @@ extern void tree_operand_check_failed (int, enum tree_code,\n    an exception.  In a CALL_EXPR, nonzero means the call cannot throw.  */\n #define TREE_NOTHROW(NODE) ((NODE)->common.nothrow_flag)\n \n-/* In a CALL_EXPR, means that the address of the return slot is part of the\n-   argument list.  */\n-#define CALL_EXPR_HAS_RETURN_SLOT_ADDR(NODE) ((NODE)->common.private_flag)\n+/* In a CALL_EXPR, means that it's safe to use the target of the call\n+   expansion as the return slot for a call that returns in memory.  */\n+#define CALL_EXPR_RETURN_SLOT_OPT(NODE) ((NODE)->common.private_flag)\n \n /* In a RESULT_DECL or PARM_DECL, means that it is passed by invisible\n    reference (and the TREE_TYPE is a pointer to the true type).  */"}]}