{"sha": "aef5ef9d11ab16f9eb326f70224c6ccc02b7eac3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVmNWVmOWQxMWFiMTZmOWViMzI2ZjcwMjI0YzZjY2MwMmI3ZWFjMw==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2013-03-11T00:44:28Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2013-03-11T00:44:28Z"}, "message": "re PR target/56347 (FAIL: gfortran.dg/integer_exponentiation_2.f90  -O2  execution test)\n\n\tPR target/56347\n\t* config/pa/pa.md (call_value): Check for calls to powf and direct to\n\tnew call patterns that clobber %fr12.\n\t(call_val_powf, call_val_powf_pic, call_val_powf_64bit): New insn,\n\tsplit and postreload patterns.\n\t* config/pa/pa.c (pa_conditional_register_usage): Revert marking\n\tregisters %fr12 and %fr12R as call used.\n\nFrom-SVN: r196588", "tree": {"sha": "332a3049038409c188e3f806a37cd4933763d755", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/332a3049038409c188e3f806a37cd4933763d755"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aef5ef9d11ab16f9eb326f70224c6ccc02b7eac3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aef5ef9d11ab16f9eb326f70224c6ccc02b7eac3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aef5ef9d11ab16f9eb326f70224c6ccc02b7eac3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aef5ef9d11ab16f9eb326f70224c6ccc02b7eac3/comments", "author": null, "committer": null, "parents": [{"sha": "115211e9d406a2286393bd65fd73c2ea6df703a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/115211e9d406a2286393bd65fd73c2ea6df703a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/115211e9d406a2286393bd65fd73c2ea6df703a5"}], "stats": {"total": 257, "additions": 237, "deletions": 20}, "files": [{"sha": "a3469f47b07aaf2e11f1ec3e8fd51182d7314b63", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef5ef9d11ab16f9eb326f70224c6ccc02b7eac3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef5ef9d11ab16f9eb326f70224c6ccc02b7eac3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aef5ef9d11ab16f9eb326f70224c6ccc02b7eac3", "patch": "@@ -1,3 +1,13 @@\n+2013-03-10  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR target/56347\n+\t* config/pa/pa.md (call_value): Check for calls to powf and direct to\n+\tnew call patterns that clobber %fr12.\n+\t(call_val_powf, call_val_powf_pic, call_val_powf_64bit): New insn,\n+\tsplit and postreload patterns.\n+\t* config/pa/pa.c (pa_conditional_register_usage): Revert marking\n+\tregisters %fr12 and %fr12R as call used.\n+\n 2013-03-09  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* dse.c (delete_dead_store_insn): Respect TDF_DETAILS."}, {"sha": "0d39483d908ec1250e97f6833891ac7e46da1886", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef5ef9d11ab16f9eb326f70224c6ccc02b7eac3/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef5ef9d11ab16f9eb326f70224c6ccc02b7eac3/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=aef5ef9d11ab16f9eb326f70224c6ccc02b7eac3", "patch": "@@ -10313,21 +10313,6 @@ pa_conditional_register_usage (void)\n {\n   int i;\n \n-  if (TARGET_HPUX)\n-    {\n-      /* Work around powf bug in libm.  */\n-      if (TARGET_64BIT)\n-\t{\n-\t  /* Mark %fr12 as call used.  */\n-\t  call_used_regs[40] = 1;\n-\t}\n-      else\n-\t{\n-\t  /* Mark %fr12 and %fr12R as call used.  */\n-\t  call_used_regs[48] = 1;\n-\t  call_used_regs[49] = 1;\n-\t}\n-    }\n   if (!TARGET_64BIT && !TARGET_PA_11)\n     {\n       for (i = 56; i <= FP_REG_LAST; i++)"}, {"sha": "5e6d5652e71c4bd4fb69af93c6d2c42d5a540c1f", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 227, "deletions": 5, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef5ef9d11ab16f9eb326f70224c6ccc02b7eac3/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef5ef9d11ab16f9eb326f70224c6ccc02b7eac3/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=aef5ef9d11ab16f9eb326f70224c6ccc02b7eac3", "patch": "@@ -7600,7 +7600,6 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t\t\t (match_operand 2 \"\" \"\")))\n \t      (clobber (reg:SI 2))])]\n   \"\"\n-  \"\n {\n   rtx op;\n   rtx dst = operands[0];\n@@ -7668,7 +7667,13 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n     {\n       rtx r4 = gen_rtx_REG (word_mode, 4);\n       if (GET_CODE (op) == SYMBOL_REF)\n-\t  emit_call_insn (gen_call_val_symref_64bit (dst, op, nb, r4));\n+\t{\n+\t  if (TARGET_HPUX && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT\n+\t      && !strcmp (targetm.strip_name_encoding (XSTR (op, 0)), \"powf\"))\n+\t    emit_call_insn (gen_call_val_powf_64bit (dst, op, nb, r4));\n+\t  else\n+\t    emit_call_insn (gen_call_val_symref_64bit (dst, op, nb, r4));\n+\t}\n       else\n \t{\n \t  op = force_reg (word_mode, op);\n@@ -7682,10 +7687,23 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t  if (flag_pic)\n \t    {\n \t      rtx r4 = gen_rtx_REG (word_mode, 4);\n-\t      emit_call_insn (gen_call_val_symref_pic (dst, op, nb, r4));\n+\n+\t      if (TARGET_HPUX && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT\n+\t\t  && !strcmp (targetm.strip_name_encoding (XSTR (op, 0)),\n+\t\t\t      \"powf\"))\n+\t\temit_call_insn (gen_call_val_powf_pic (dst, op, nb, r4));\n+\t      else\n+\t\temit_call_insn (gen_call_val_symref_pic (dst, op, nb, r4));\n \t    }\n \t  else\n-\t    emit_call_insn (gen_call_val_symref (dst, op, nb));\n+\t    {\n+\t      if (TARGET_HPUX && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT\n+\t\t  && !strcmp (targetm.strip_name_encoding (XSTR (op, 0)),\n+\t\t\t      \"powf\"))\n+\t\temit_call_insn (gen_call_val_powf (dst, op, nb));\n+\t      else\n+\t\temit_call_insn (gen_call_val_symref (dst, op, nb));\n+\t    }\n \t}\n       else\n \t{\n@@ -7702,7 +7720,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n     }\n \n   DONE;\n-}\")\n+})\n \n (define_insn \"call_val_symref\"\n   [(set (match_operand 0 \"\" \"\")\n@@ -7722,6 +7740,26 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t(cond [(and (const_int 0) (eq (const_int 0) (pc))) (const_int 8)]\n \t      (symbol_ref \"pa_attr_length_call (insn, 0)\")))])\n \n+;; powf function clobbers %fr12\n+(define_insn \"call_val_powf\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n+\t      (match_operand 2 \"\" \"i\")))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 2))\n+   (clobber (reg:DF 48))\n+   (use (const_int 1))]\n+  \"TARGET_HPUX && !TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n+  \"*\n+{\n+  pa_output_arg_descriptor (insn);\n+  return pa_output_call (insn, operands[1], 0);\n+}\"\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"length\")\n+\t(cond [(and (const_int 0) (eq (const_int 0) (pc))) (const_int 8)]\n+\t      (symbol_ref \"pa_attr_length_call (insn, 0)\")))])\n+\n (define_insn \"call_val_symref_pic\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n@@ -7804,6 +7842,95 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t(cond [(and (const_int 0) (eq (const_int 0) (pc))) (const_int 8)]\n \t      (symbol_ref \"pa_attr_length_call (insn, 0)\")))])\n \n+;; powf function clobbers %fr12\n+(define_insn \"call_val_powf_pic\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n+\t      (match_operand 2 \"\" \"i\")))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 2))\n+   (clobber (reg:DF 48))\n+   (clobber (match_operand 3))\n+   (use (reg:SI 19))\n+   (use (const_int 1))]\n+  \"TARGET_HPUX && !TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n+  \"#\")\n+\n+;; Split out the PIC register save and restore after reload.  As the\n+;; split is done after reload, there are some situations in which we\n+;; unnecessarily save and restore %r4.  This happens when there is a\n+;; single call and the PIC register is not used after the call.\n+;;\n+;; The split has to be done since call_from_call_insn () can't handle\n+;; the pattern as is.  Noreturn calls are special because they have to\n+;; terminate the basic block.  The split has to contain more than one\n+;; insn.\n+(define_split\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t      (call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n+\t\t    (match_operand 2 \"\" \"\")))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (clobber (reg:DF 48))\n+\t      (clobber (match_operand 3))\n+\t      (use (reg:SI 19))\n+\t      (use (const_int 1))])]\n+  \"TARGET_HPUX && !TARGET_PORTABLE_RUNTIME && !TARGET_64BIT && reload_completed\n+   && find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  [(set (match_dup 3) (reg:SI 19))\n+   (parallel [(set (match_dup 0)\n+\t      (call (mem:SI (match_dup 1))\n+\t\t    (match_dup 2)))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (clobber (reg:DF 48))\n+\t      (use (reg:SI 19))\n+\t      (use (const_int 1))])]\n+  \"\")\n+\n+(define_split\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t      (call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n+\t\t    (match_operand 2 \"\" \"\")))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (clobber (reg:DF 48))\n+\t      (clobber (match_operand 3))\n+\t      (use (reg:SI 19))\n+\t      (use (const_int 1))])]\n+  \"TARGET_HPUX && !TARGET_PORTABLE_RUNTIME && !TARGET_64BIT && reload_completed\"\n+  [(set (match_dup 3) (reg:SI 19))\n+   (parallel [(set (match_dup 0)\n+\t      (call (mem:SI (match_dup 1))\n+\t\t    (match_dup 2)))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (clobber (reg:DF 48))\n+\t      (use (reg:SI 19))\n+\t      (use (const_int 1))])\n+   (set (reg:SI 19) (match_dup 3))]\n+  \"\")\n+\n+(define_insn \"*call_val_powf_pic_post_reload\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n+\t      (match_operand 2 \"\" \"i\")))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 2))\n+   (clobber (reg:DF 48))\n+   (use (reg:SI 19))\n+   (use (const_int 1))]\n+  \"TARGET_HPUX && !TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n+  \"*\n+{\n+  pa_output_arg_descriptor (insn);\n+  return pa_output_call (insn, operands[1], 0);\n+}\"\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"length\")\n+\t(cond [(and (const_int 0) (eq (const_int 0) (pc))) (const_int 8)]\n+\t      (symbol_ref \"pa_attr_length_call (insn, 0)\")))])\n+\n ;; This pattern is split if it is necessary to save and restore the\n ;; PIC register.\n (define_insn \"call_val_symref_64bit\"\n@@ -7894,6 +8021,101 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t(cond [(and (const_int 0) (eq (const_int 0) (pc))) (const_int 8)]\n \t      (symbol_ref \"pa_attr_length_call (insn, 0)\")))])\n \n+;; powf function clobbers %fr12\n+(define_insn \"call_val_powf_64bit\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n+\t      (match_operand 2 \"\" \"i\")))\n+   (clobber (reg:DI 1))\n+   (clobber (reg:DI 2))\n+   (clobber (reg:DF 40))\n+   (clobber (match_operand 3))\n+   (use (reg:DI 27))\n+   (use (reg:DI 29))\n+   (use (const_int 1))]\n+  \"TARGET_64BIT && TARGET_HPUX\"\n+  \"#\")\n+\n+;; Split out the PIC register save and restore after reload.  As the\n+;; split is done after reload, there are some situations in which we\n+;; unnecessarily save and restore %r4.  This happens when there is a\n+;; single call and the PIC register is not used after the call.\n+;;\n+;; The split has to be done since call_from_call_insn () can't handle\n+;; the pattern as is.  Noreturn calls are special because they have to\n+;; terminate the basic block.  The split has to contain more than one\n+;; insn.\n+(define_split\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t      (call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n+\t\t    (match_operand 2 \"\" \"\")))\n+\t      (clobber (reg:DI 1))\n+\t      (clobber (reg:DI 2))\n+\t      (clobber (reg:DF 40))\n+\t      (clobber (match_operand 3))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))\n+\t      (use (const_int 1))])]\n+  \"TARGET_64BIT && TARGET_HPUX && reload_completed\n+   && find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  [(set (match_dup 3) (reg:DI 27))\n+   (parallel [(set (match_dup 0)\n+\t      (call (mem:SI (match_dup 1))\n+\t\t    (match_dup 2)))\n+\t      (clobber (reg:DI 1))\n+\t      (clobber (reg:DI 2))\n+\t      (clobber (reg:DF 40))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))\n+\t      (use (const_int 1))])]\n+  \"\")\n+\n+(define_split\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t      (call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n+\t\t    (match_operand 2 \"\" \"\")))\n+\t      (clobber (reg:DI 1))\n+\t      (clobber (reg:DI 2))\n+\t      (clobber (reg:DF 40))\n+\t      (clobber (match_operand 3))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))\n+\t      (use (const_int 1))])]\n+  \"TARGET_64BIT && TARGET_HPUX && reload_completed\"\n+  [(set (match_dup 3) (reg:DI 27))\n+   (parallel [(set (match_dup 0)\n+\t      (call (mem:SI (match_dup 1))\n+\t\t    (match_dup 2)))\n+\t      (clobber (reg:DI 1))\n+\t      (clobber (reg:DI 2))\n+\t      (clobber (reg:DF 40))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))\n+\t      (use (const_int 1))])\n+   (set (reg:DI 27) (match_dup 3))]\n+  \"\")\n+\n+(define_insn \"*call_val_powf_64bit_post_reload\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n+\t      (match_operand 2 \"\" \"i\")))\n+   (clobber (reg:DI 1))\n+   (clobber (reg:DI 2))\n+   (clobber (reg:DF 40))\n+   (use (reg:DI 27))\n+   (use (reg:DI 29))\n+   (use (const_int 1))]\n+  \"TARGET_64BIT && TARGET_HPUX\"\n+  \"*\n+{\n+  pa_output_arg_descriptor (insn);\n+  return pa_output_call (insn, operands[1], 0);\n+}\"\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"length\")\n+\t(cond [(and (const_int 0) (eq (const_int 0) (pc))) (const_int 8)]\n+\t      (symbol_ref \"pa_attr_length_call (insn, 0)\")))])\n+\n (define_insn \"call_val_reg\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (reg:SI 22))"}]}