{"sha": "10bbbb591cfe6cac200e926a73f3b8065147ce84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBiYmJiNTkxY2ZlNmNhYzIwMGU5MjZhNzNmM2I4MDY1MTQ3Y2U4NA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-03-04T22:14:49Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-03-04T22:14:49Z"}, "message": "PR tree-optimization/93986 - ICE on mixed-precision wide_int arguments\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/93986\n        * gcc.dg/pr93986.c: New test.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/93986\n        * tree-ssa-strlen.c (maybe_warn_overflow): Convert all wide_int\n        operands to the same precision widest_int to avoid ICEs.", "tree": {"sha": "e474548ec09e6e9eaf3898560057ebe44a73673b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e474548ec09e6e9eaf3898560057ebe44a73673b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10bbbb591cfe6cac200e926a73f3b8065147ce84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10bbbb591cfe6cac200e926a73f3b8065147ce84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10bbbb591cfe6cac200e926a73f3b8065147ce84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10bbbb591cfe6cac200e926a73f3b8065147ce84/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c1645a379e405c7ce33060846fa424373b1f5f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c1645a379e405c7ce33060846fa424373b1f5f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c1645a379e405c7ce33060846fa424373b1f5f4"}], "stats": {"total": 137, "additions": 97, "deletions": 40}, "files": [{"sha": "0df606a82115a9686340be604f7e848d45bf690e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bbbb591cfe6cac200e926a73f3b8065147ce84/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bbbb591cfe6cac200e926a73f3b8065147ce84/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10bbbb591cfe6cac200e926a73f3b8065147ce84", "patch": "@@ -1,3 +1,9 @@\n+2020-03-04  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/93986\n+\t* tree-ssa-strlen.c (maybe_warn_overflow): Convert all wide_int\n+\toperands to the same precision widest_int to avoid ICEs.\n+\n 2020-03-04  Bill Schmidt  <wschmidt@linux.ibm.com>\n \n \tPR target/87560"}, {"sha": "468f7673e2956ccc5ddf300c8da6438c9b951a61", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bbbb591cfe6cac200e926a73f3b8065147ce84/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bbbb591cfe6cac200e926a73f3b8065147ce84/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=10bbbb591cfe6cac200e926a73f3b8065147ce84", "patch": "@@ -1,3 +1,8 @@\n+2020-03-04  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/93986\n+        * gcc.dg/pr93986.c: New test.\n+\n 2020-03-04  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR analyzer/94028"}, {"sha": "bdbc192a01da314510226a3b62d669c4009a3e06", "filename": "gcc/testsuite/gcc.dg/pr93986.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bbbb591cfe6cac200e926a73f3b8065147ce84/gcc%2Ftestsuite%2Fgcc.dg%2Fpr93986.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bbbb591cfe6cac200e926a73f3b8065147ce84/gcc%2Ftestsuite%2Fgcc.dg%2Fpr93986.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr93986.c?ref=10bbbb591cfe6cac200e926a73f3b8065147ce84", "patch": "@@ -0,0 +1,16 @@\n+/* PR tree-optimization/93986 - ICE in decompose, at wide-int.h:984\n+   { dg-do compile }\n+   { dg-options \"-O1 -foptimize-strlen -ftree-slp-vectorize\" } */\n+\n+int dd (void);\n+\n+void ya (int cm)\n+{\n+  char s2[cm];\n+\n+  s2[cm-12] = s2[cm-11] = s2[cm-10] = s2[cm-9]\n+    = s2[cm-8] = s2[cm-7] = s2[cm-6] = s2[cm-5] = ' ';\n+\n+  if (dd ())\n+    __builtin_exit (0);\n+}"}, {"sha": "81be11de797123d9db0702b5e2535fce4ebb4823", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 70, "deletions": 40, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bbbb591cfe6cac200e926a73f3b8065147ce84/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bbbb591cfe6cac200e926a73f3b8065147ce84/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=10bbbb591cfe6cac200e926a73f3b8065147ce84", "patch": "@@ -1924,11 +1924,21 @@ maybe_warn_overflow (gimple *stmt, tree len,\n   if (TREE_NO_WARNING (dest))\n     return;\n \n+  /* Use maximum precision to avoid overflow in the addition below.\n+     Make sure all operands have the same precision to keep wide_int\n+     from ICE'ing.  */\n+\n+  /* Convenience constants.  */\n+  const widest_int diff_min\n+    = wi::to_widest (TYPE_MIN_VALUE (ptrdiff_type_node));\n+  const widest_int diff_max\n+    = wi::to_widest (TYPE_MAX_VALUE (ptrdiff_type_node));\n+  const widest_int size_max\n+    = wi::to_widest (TYPE_MAX_VALUE (size_type_node));\n+\n   /* The offset into the destination object computed below and not\n      reflected in DESTSIZE.  */\n-  wide_int offrng[2];\n-  const int off_prec = TYPE_PRECISION (ptrdiff_type_node);\n-  offrng[0] = offrng[1] = wi::zero (off_prec);\n+  widest_int offrng[2] = { 0, 0 };\n \n   if (!si)\n     {\n@@ -1941,41 +1951,43 @@ maybe_warn_overflow (gimple *stmt, tree len,\n \t     ARRAY_REF (MEM_REF (vlaptr, 0), N].  */\n \t  tree off = TREE_OPERAND (ref, 1);\n \t  ref = TREE_OPERAND (ref, 0);\n-\t  if (get_range (off, offrng, rvals))\n+\t  wide_int rng[2];\n+\t  if (get_range (off, rng, rvals))\n \t    {\n-\t      offrng[0] = offrng[0].from (offrng[0], off_prec, SIGNED);\n-\t      offrng[1] = offrng[1].from (offrng[1], off_prec, SIGNED);\n+\t      /* Convert offsets to the maximum precision.  */\n+\t      offrng[0] = widest_int::from (rng[0], SIGNED);\n+\t      offrng[1] = widest_int::from (rng[1], SIGNED);\n \t    }\n \t  else\n \t    {\n-\t      offrng[0] = wi::to_wide (TYPE_MIN_VALUE (ptrdiff_type_node));\n-\t      offrng[1] = wi::to_wide (TYPE_MAX_VALUE (ptrdiff_type_node));\n+\t      offrng[0] = diff_min;\n+\t      offrng[1] = diff_max;\n \t    }\n \t}\n \n       if (TREE_CODE (ref) == MEM_REF)\n \t{\n \t  tree mem_off = TREE_OPERAND (ref, 1);\n \t  ref = TREE_OPERAND (ref, 0);\n-\t  wide_int memoffrng[2];\n-\t  if (get_range (mem_off, memoffrng, rvals))\n+\t  wide_int rng[2];\n+\t  if (get_range (mem_off, rng, rvals))\n \t    {\n-\t      offrng[0] += memoffrng[0];\n-\t      offrng[1] += memoffrng[1];\n+\t      offrng[0] += widest_int::from (rng[0], SIGNED);\n+\t      offrng[1] += widest_int::from (rng[1], SIGNED);\n \t    }\n \t  else\n \t    {\n-\t      offrng[0] = wi::to_wide (TYPE_MIN_VALUE (ptrdiff_type_node));\n-\t      offrng[1] = wi::to_wide (TYPE_MAX_VALUE (ptrdiff_type_node));\n+\t      offrng[0] = diff_min;\n+\t      offrng[1] = diff_max;\n \t    }\n \t}\n \n-      wide_int stroffrng[2];\n-      if (int idx = get_stridx (ref, stroffrng, rvals))\n+      wide_int rng[2];\n+      if (int idx = get_stridx (ref, rng, rvals))\n \t{\n \t  si = get_strinfo (idx);\n-\t  offrng[0] += stroffrng[0];\n-\t  offrng[1] += stroffrng[1];\n+\t  offrng[0] += widest_int::from (rng[0], SIGNED);\n+\t  offrng[1] += widest_int::from (rng[1], SIGNED);\n \t}\n     }\n \n@@ -1995,15 +2007,20 @@ maybe_warn_overflow (gimple *stmt, tree len,\n   /* Compute the range of sizes of the destination object.  The range\n      is constant for declared objects but may be a range for allocated\n      objects.  */\n-  const int siz_prec = TYPE_PRECISION (size_type_node);\n-  wide_int sizrng[2];\n+  widest_int sizrng[2] = { 0, 0 };\n   if (si)\n     {\n-      destsize = gimple_call_alloc_size (si->alloc, sizrng, rvals);\n+      wide_int rng[2];\n+      destsize = gimple_call_alloc_size (si->alloc, rng, rvals);\n+      if (destsize)\n+\t{\n+\t  sizrng[0] = widest_int::from (rng[0], UNSIGNED);\n+\t  sizrng[1] = widest_int::from (rng[1], UNSIGNED);\n+\t}\n       alloc_call = si->alloc;\n     }\n   else\n-    offrng[0] = offrng[1] = wi::zero (off_prec);\n+    offrng[0] = offrng[1] = 0;\n \n   if (!destsize)\n     {\n@@ -2014,7 +2031,7 @@ maybe_warn_overflow (gimple *stmt, tree len,\n \t{\n \t  /* Remember OFF but clear OFFRNG that may have been set above.  */\n \t  destoff = off;\n-\t  offrng[0] = offrng[1] = wi::zero (off_prec);\n+\t  offrng[0] = offrng[1] = 0;\n \n \t  if (destdecl && TREE_CODE (destdecl) == SSA_NAME)\n \t    {\n@@ -2024,38 +2041,44 @@ maybe_warn_overflow (gimple *stmt, tree len,\n \t      destdecl = NULL_TREE;\n \t    }\n \n-\t  if (!get_range (destsize, sizrng, rvals))\n+\t  wide_int rng[2];\n+\t  if (get_range (destsize, rng, rvals))\n+\t    {\n+\t      sizrng[0] = widest_int::from (rng[0], UNSIGNED);\n+\t      sizrng[1] = widest_int::from (rng[1], UNSIGNED);\n+\t    }\n+\t  else\n \t    {\n \t      /* On failure, rather than failing, set the maximum range\n \t\t so that overflow in allocated objects whose size depends\n \t\t on the strlen of the source can still be diagnosed\n \t\t below.  */\n-\t      sizrng[0] = wi::zero (siz_prec);\n-\t      sizrng[1] = wi::to_wide (TYPE_MAX_VALUE (sizetype));\n+\t      sizrng[0] = 0;\n+\t      sizrng[1] = size_max;\n \t    }\n \t}\n     }\n \n   if (!destsize)\n     {\n-      sizrng[0] = wi::zero (siz_prec);\n-      sizrng[1] = wi::to_wide (TYPE_MAX_VALUE (sizetype));\n+      sizrng[0] = 0;\n+      sizrng[1] = size_max;\n     };\n \n-  sizrng[0] = sizrng[0].from (sizrng[0], siz_prec, UNSIGNED);\n-  sizrng[1] = sizrng[1].from (sizrng[1], siz_prec, UNSIGNED);\n-\n   /* Return early if the DESTSIZE size expression is the same as LEN\n      and the offset into the destination is zero.  This might happen\n      in the case of a pair of malloc and memset calls to allocate\n      an object and clear it as if by calloc.  */\n   if (destsize == len && !plus_one && offrng[0] == 0 && offrng[0] == offrng[1])\n     return;\n \n-  wide_int lenrng[2];\n-  if (!get_range (len, lenrng, rvals))\n+  wide_int rng[2];\n+  if (!get_range (len, rng, rvals))\n     return;\n \n+  widest_int lenrng[2] =\n+    { widest_int::from (rng[0], SIGNED), widest_int::from (rng[1], SIGNED) };\n+\n   if (plus_one)\n     {\n       lenrng[0] += 1;\n@@ -2064,7 +2087,7 @@ maybe_warn_overflow (gimple *stmt, tree len,\n \n   /* The size of the remaining space in the destination computed\n      as the size of the latter minus the offset into it.  */\n-  wide_int spcrng[2] = { sizrng[0], sizrng[1] };\n+  widest_int spcrng[2] = { sizrng[0], sizrng[1] };\n   if (wi::neg_p (offrng[0]) && wi::neg_p (offrng[1]))\n     {\n       /* When the offset is negative and the size of the destination\n@@ -2075,7 +2098,7 @@ maybe_warn_overflow (gimple *stmt, tree len,\n \treturn;\n \n       /* The remaining space is necessarily zero.  */\n-      spcrng[0] = spcrng[1] = wi::zero (spcrng->get_precision ());\n+      spcrng[0] = spcrng[1] = 0;\n     }\n   else if (wi::neg_p (offrng[0]))\n     {\n@@ -2203,7 +2226,16 @@ maybe_warn_overflow (gimple *stmt, tree len,\n \n   /* If DESTOFF is not null, use it to format the offset value/range.  */\n   if (destoff)\n-    get_range (destoff, offrng);\n+    {\n+      wide_int rng[2];\n+      if (get_range (destoff, rng))\n+\t{\n+\t  offrng[0] = widest_int::from (rng[0], SIGNED);\n+\t  offrng[1] = widest_int::from (rng[1], SIGNED);\n+\t}\n+      else\n+\toffrng[0] = offrng[1] = 0;\n+    }\n \n   /* Format the offset to keep the number of inform calls from growing\n      out of control.  */\n@@ -2259,8 +2291,7 @@ maybe_warn_overflow (gimple *stmt, tree len,\n       else if (sizrng[0] == 0)\n \t{\n \t  /* Avoid printing impossible sizes.  */\n-\t  if (wi::ltu_p (sizrng[1],\n-\t\t\t wi::to_wide (TYPE_MAX_VALUE (ptrdiff_type_node)) - 2))\n+\t  if (wi::ltu_p (sizrng[1], diff_max - 2))\n \t    inform (gimple_location (alloc_call),\n \t\t    \"at offset %s to an object with size at most %wu \"\n \t\t    \"declared here\",\n@@ -2284,8 +2315,7 @@ maybe_warn_overflow (gimple *stmt, tree len,\n   else if (sizrng[0] == 0)\n     {\n       /* Avoid printing impossible sizes.  */\n-      if (wi::ltu_p (sizrng[1],\n-\t\t     wi::to_wide (TYPE_MAX_VALUE (ptrdiff_type_node)) - 2))\n+      if (wi::ltu_p (sizrng[1], diff_max - 2))\n \tinform (gimple_location (alloc_call),\n \t\t\"at offset %s to an object with size at most %wu allocated \"\n \t\t\"by %qD here\","}]}