{"sha": "881430620003209aa70da850787de3e25e97dc36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODgxNDMwNjIwMDAzMjA5YWE3MGRhODUwNzg3ZGUzZTI1ZTk3ZGMzNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-03T19:42:39Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-03T19:42:39Z"}, "message": "Initial revision\n\nFrom-SVN: r5567", "tree": {"sha": "e621f141ad56282742e8a4a04dc36c519a9a868b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e621f141ad56282742e8a4a04dc36c519a9a868b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/881430620003209aa70da850787de3e25e97dc36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/881430620003209aa70da850787de3e25e97dc36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/881430620003209aa70da850787de3e25e97dc36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/881430620003209aa70da850787de3e25e97dc36/comments", "author": null, "committer": null, "parents": [{"sha": "32620c1a4214d8091b4fae9a7158585e942869ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32620c1a4214d8091b4fae9a7158585e942869ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32620c1a4214d8091b4fae9a7158585e942869ae"}], "stats": {"total": 5840, "additions": 5840, "deletions": 0}, "files": [{"sha": "b1ee3ce5a85559f5cdc1bfe678d4d5ce19c9e186", "filename": "gcc/config/i370/i370.h", "status": "added", "additions": 1498, "deletions": 0, "changes": 1498, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881430620003209aa70da850787de3e25e97dc36/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881430620003209aa70da850787de3e25e97dc36/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=881430620003209aa70da850787de3e25e97dc36", "patch": "@@ -0,0 +1,1498 @@\n+/* Definitions of target machine for GNU compiler.  System/370 version.\n+   Copyright (C) 1989, 1993 Free Software Foundation, Inc.\n+   Contributed by Jan Stein (jan@cd.chalmers.se).\n+   Modified for C/370 MVS by Dave Pitts (pitts@mcdata.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#ifdef sun\n+#include <sys/types.h>\n+#include <ctype.h>\n+#endif\n+#include <time.h>\n+\n+#define TARGET_VERSION printf (\" (370/MVS)\");\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-DGCC -Dgcc -DMVS -Dmvs -Asystem(mvs) -Acpu(i370) -Amachine(i370)\"\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+extern int target_flags;\n+\n+/* The sizes of the code and literals on the current page.  */\n+\n+extern int mvs_page_code, mvs_page_lit;\n+\n+/* The current page number and the base page number for the function.  */\n+\n+extern int mvs_page_num, function_base_page;\n+\n+/* True if a label has been emitted.  */\n+\n+extern int mvs_label_emited;\n+\n+/* The name of the current function.  */\n+\n+extern char *mvs_function_name;\n+\n+/* The length of the function name malloc'd area.  */\n+\n+extern int mvs_function_name_length;\n+\n+/* The amount of space used for outgoing arguments.  */\n+\n+extern int current_function_outgoing_args_size;\n+\n+/* Compile using char instructins (mvc, nc, oc, xc).  On 4341 use this since\n+   these are more than twice as fast as load-op-store.\n+   On 3090 don't use this since load-op-store is much faster.  */\n+\n+#define TARGET_CHAR_INSTRUCTIONS (target_flags & 1)\n+\n+/* Default target switches */\n+\n+#define TARGET_DEFAULT 1\n+\n+/* Macro to define tables used to set the flags.  This is a list in braces\n+   of pairs in braces, each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n+{ { \"char-instructions\", 1},\t\t\t\t\t\t\\\n+  { \"no-char-instructions\", -1},\t\t\t\t\t\\\n+  { \"\", TARGET_DEFAULT} }\n+\n+/* Target machine storage layout */\n+\n+/* Define this if most significant bit is lowest numbered in instructions\n+   that operate on numbered bit-fields.  */\n+\n+#define BITS_BIG_ENDIAN 1\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+\n+#define BYTES_BIG_ENDIAN 1\n+\n+/* Define this if MS word of a multiword is the lowest numbered.  */\n+\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* Number of bits in an addressible storage unit.  */\n+\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.  */\n+\n+#define BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+\n+#define UNITS_PER_WORD 4\n+\n+/* Width in bits of a pointer.  See also the macro `Pmode' defined below.  */\n+\n+#define POINTER_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing pointers in memory.  */\n+\n+#define POINTER_BOUNDARY 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+\n+#define PARM_BOUNDARY 32\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+\n+#define STACK_BOUNDARY 32\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+\n+#define FUNCTION_BOUNDARY 32\n+\n+/* There is no point aligning anything to a rounder boundary than this.  */\n+\n+#define BIGGEST_ALIGNMENT 64\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* Define this if move instructions will actually fail to work when given\n+   unaligned data.  */\n+\n+#define STRICT_ALIGNMENT 0\n+\n+/* Define target floating point format.  */\n+\n+#define TARGET_FLOAT_FORMAT IBM_FLOAT_FORMAT\n+\n+/* Define character mapping for cross-compiling.  */\n+\n+#define TARGET_EBCDIC 1\n+\n+#ifdef HOST_EBCDIC\n+#define MAP_CHARACTER(c) ((char)(c))\n+#else\n+#define MAP_CHARACTER(c) ((char)mvs_map_char (c))\n+#endif\n+\n+/* Define maximum length of page minus page escape overhead.  */\n+\n+#define MAX_MVS_PAGE_LENGTH 4080\n+\n+/* Define if special allocation order desired.  */\n+\n+#define REG_ALLOC_ORDER\t\t\t\t\t\t\t\\\n+{ 0, 1, 2, 3, 14, 15, 12, 10, 9, 8, 7, 6, 5, 4, 16, 17, 18, 19, 11, 13 }\n+\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.  The hardware registers are\n+   assigned numbers for the compiler from 0 to just below\n+   FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+   For the 370, we give the data registers numbers 0-15,\n+   and the floating point registers numbers 16-19.  */\n+\n+#define FIRST_PSEUDO_REGISTER 20\n+\n+/* Define base and page registers.  */\n+\n+#define BASE_REGISTER 3\n+#define PAGE_REGISTER 4\n+\n+/* 1 for registers that have pervasive standard uses and are not available\n+   for the register allocator.  On the 370 under C/370, R13 is stack (DSA)\n+   pointer, R12 is the TCA pointer, R3 is the base register, R4 is the page\n+   origin table pointer and R11 is the arg pointer.  */\n+\n+#define FIXED_REGISTERS \t\t\t\t\t\t\\\n+{ 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0 }\n+/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n+\n+/* 1 for registers not available across function calls.  These must include\n+   the FIXED_REGISTERS and also any registers that can be used without being\n+   saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   NOTE: all floating registers are undefined across calls.  */\n+\n+#define CALL_USED_REGISTERS \t\t\t\t\t\t\\\n+{ 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n+/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.  */\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE) \t\t\t\t\t\\\n+  ((REGNO) > 15 ? 1 : (GET_MODE_SIZE(MODE)+UNITS_PER_WORD-1) / UNITS_PER_WORD)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   On the 370, the cpu registers can hold QI, HI, SI, SF and DF.  The\n+   even registers can hold DI.  The floating point registers can hold\n+   either SF or DF.  */\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n+  ((REGNO) < 16 ? ((REGNO) & 1) == 0 || (MODE) != DImode\t\t\\\n+\t\t: (MODE) == SFmode || (MODE) == DFmode)\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers when one has\n+   mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+\n+#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\t\\\n+  (((MODE1) == SFmode || (MODE1) == DFmode)\t\t\t\t\\\n+   == ((MODE2) == SFmode || (MODE2) == DFmode))\n+\n+/* Mark external references.  */\n+\n+#define ENCODE_SECTION_INFO(decl)  \t\t\t\t\t\\\n+  if (DECL_EXTERNAL (decl) && TREE_PUBLIC (decl)) \t\t\t\\\n+    SYMBOL_REF_FLAG (XEXP (DECL_RTL (decl), 0)) = 1;\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* 370 PC isn't overloaded on a register.  */\n+\n+/* #define PC_REGNUM */\n+\n+/* Register to use for pushing function arguments.  */\n+\n+#define STACK_POINTER_REGNUM 13\n+\n+/* Base register for access to local variables of the function.  */\n+\n+#define FRAME_POINTER_REGNUM 13\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms may be\n+   accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+\n+#define FRAME_POINTER_REQUIRED 1\n+\n+/* Base register for access to arguments of the function.  */\n+\n+#define ARG_POINTER_REGNUM 11\n+\n+/* Register in which static-chain is passed to a function.  */\n+\n+#define STATIC_CHAIN_REGNUM 10\n+\n+/* Register in which address to store a structure value is passed to\n+   a function.  */\n+\n+#define STRUCT_VALUE_REGNUM 1\n+\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+\n+enum reg_class\n+  {\n+    NO_REGS, ADDR_REGS, DATA_REGS,\n+    FP_REGS, ALL_REGS, LIM_REG_CLASSES\n+  };\n+\n+#define GENERAL_REGS DATA_REGS\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.  */\n+\n+#define REG_CLASS_NAMES \t\t\t\t\t\t\\\n+{ \"NO_REGS\", \"ADDR_REGS\", \"DATA_REGS\", \"FP_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.  This is an initializer for\n+   a vector of HARD_REG_SET of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS {0, 0x0fffe, 0x0ffff, 0xf0000, 0xfffff}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO) \t\t\t\t\t\t\\\n+  ((REGNO) >= 16 ? FP_REGS : (REGNO) != 0 ? ADDR_REGS : DATA_REGS)\n+\n+/* The class value for index registers, and the one for base regs.  */\n+\n+#define INDEX_REG_CLASS ADDR_REGS\n+#define BASE_REG_CLASS ADDR_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C)\t\t\t\t\t\\\n+  ((C) == 'a' ? ADDR_REGS :\t\t\t\t\t\t\\\n+  ((C) == 'd' ? DATA_REGS :\t\t\t\t\t\t\\\n+  ((C) == 'f' ? FP_REGS   : NO_REGS)))\n+\n+/* The letters I, J, K, L and M in a register constraint string can be used\n+   to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.  */\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n+  ((C) == 'I' ? (unsigned) (VALUE) < 256 :\t\t\t\t\\\n+   (C) == 'J' ? (unsigned) (VALUE) < 4096 :\t\t\t\t\\\n+   (C) == 'K' ? (VALUE) >= -32768 && (VALUE) < 32768 : 0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself.  */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  1\n+\n+/* Given an rtx X being reloaded into a reg required to be in class CLASS,\n+   return the class of reg to actually use.  In general this is just CLASS;\n+   but on some machines in some cases it is preferable to use a more\n+   restrictive class.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X, CLASS)\t\t\t\t\\\n+    (GET_CODE(X) == CONST_DOUBLE ? FP_REGS :\t\t\t\t\\\n+     GET_CODE(X) == CONST_INT ? DATA_REGS :\t\t\t\t\\\n+     GET_CODE(X) == LABEL_REF ||\t\t\t\t\t\\\n+     GET_CODE(X) == SYMBOL_REF ||\t\t\t\t\t\\\n+     GET_CODE(X) == CONST ? ADDR_REGS : (CLASS))\n+\n+/* Return the maximum number of consecutive registers needed to represent\n+   mode MODE in a register of class CLASS.  */\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n+  ((CLASS) == FP_REGS ? 1 :\t\t\t\t\t\t\\\n+   (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack makes the stack pointer a\n+   smaller address.  */\n+\n+/* #define STACK_GROWS_DOWNWARD */\n+\n+/* Define this if the nominal address of the stack frame is at the\n+   high-address end of the local variables; that is, each additional local\n+   variable allocated goes at a more negative offset in the frame.  */\n+\n+/* #define FRAME_GROWS_DOWNWARD */\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+\n+#define STARTING_FRAME_OFFSET  \t\t\t\t\t\t\\\n+     (STACK_POINTER_OFFSET + current_function_outgoing_args_size)\n+\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = STARTING_FRAME_OFFSET\n+\n+/* If we generate an insn to push BYTES bytes, this says how many the stack\n+   pointer really advances by.  On the 370, we have no push instruction.  */\n+\n+/* #define PUSH_ROUNDING(BYTES) */\n+\n+/* Accumulate the outgoing argument count so we can request the right\n+   DSA size and determine stack offset.  */\n+\n+#define ACCUMULATE_OUTGOING_ARGS\n+\n+/* Define offset from stack pointer, to location where a parm can be\n+   pushed.  */\n+\n+#define STACK_POINTER_OFFSET 148\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   On the 370, no registers are used in this way.  */\n+\n+#define FUNCTION_ARG_REGNO_P(N) 0\n+\n+/* Define a data type for recording info about an argument list during\n+   the scan of that argument list.  This data type should hold all\n+   necessary information about the function itself and about the args\n+   processed so far, enough to enable macros such as FUNCTION_ARG to\n+   determine where the next arg should go.  */\n+\n+#define CUMULATIVE_ARGS int\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS for a call to\n+   a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME)  ((CUM) = 0)\n+\n+/* Update the data in CUM to advance over an argument of mode MODE and\n+   data type TYPE.  (TYPE is null for libcalls where that information\n+   may not be available.) */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n+ ((CUM) += ((MODE) == DFmode || (MODE) == SFmode\t\t\t\\\n+\t    ? 256\t\t\t\t\t\t\t\\\n+\t    : (MODE) != BLKmode                 \t\t\t\\\n+\t    ? (GET_MODE_SIZE (MODE) + 3) / 4 \t\t\t\t\\\n+\t    : (int_size_in_bytes (TYPE) + 3) / 4))\n+\n+/* Define where to put the arguments to a function.  Value is zero to push\n+   the argument on the stack, or a hard register in which to store the\n+   argument.  */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n+\n+/* For an arg passed partly in registers and partly in memory, this is the\n+   number of registers used.  For args passed entirely in registers or\n+   entirely in memory, zero.  */\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n+\n+/* Define if returning from a function call automatically pops the\n+   arguments described by the number-of-args field in the call.  */\n+\n+#define RETURN_POPS_ARGS(FUNTYPE, STACKSIZE) 0\n+\n+/* Define how to find the value returned by a function.  VALTYPE is the\n+   data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 15.  */\n+\n+#define RET_REG(MODE)\t((MODE) == DFmode || (MODE) == SFmode ? 16 : 15)\n+\n+/* On the 370 the return value is in R15 or R16.  */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \t\t\t\t\t\\\n+  gen_rtx(REG, TYPE_MODE (VALTYPE), RET_REG(TYPE_MODE(VALTYPE)))\n+\n+/* Define how to find the value returned by a library function assuming\n+   the value has mode MODE.  */\n+\n+#define LIBCALL_VALUE(MODE)  gen_rtx(REG, MODE, RET_REG(MODE))\n+\n+/* 1 if N is a possible register number for a function value.\n+   On the 370 under C/370, R15 and R16 are thus used.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 15 || (N) == 16)\n+\n+/* This macro definition sets up a default value for `main' to return.  */\n+\n+#define DEFAULT_MAIN_RETURN  c_expand_return (integer_zero_node)\n+\n+/* This macro generates the assembly code for function entry.\n+   All of the C/370 environment is preserved.  */\n+\n+#define FUNCTION_PROLOGUE(FILE, LSIZE)\t\t\t\t\t\\\n+{ \t\t\t\t\t\t\t\t\t\\\n+  static int function_label_index = 1;\t\t\t\t\t\\\n+  static int function_first = 0;\t\t\t\t\t\\\n+  static int function_year, function_month, function_day;\t\t\\\n+  static int function_hour, function_minute, function_second;\t\t\\\n+  int i;\t\t\t\t\t\t\t\t\\\n+  if (!function_first)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      struct tm *function_time;\t\t\t\t\t\t\\\n+      time_t lcltime;\t\t\t\t\t\t\t\\\n+      time (&lcltime);\t\t\t\t\t\t\t\\\n+      function_time = localtime (&lcltime);\t\t\t\t\\\n+      function_year = function_time->tm_year + 1900;\t\t\t\\\n+      function_month = function_time->tm_mon + 1;\t\t\t\\\n+      function_day = function_time->tm_mday;\t\t\t\t\\\n+      function_hour = function_time->tm_hour;\t\t\t\t\\\n+      function_minute = function_time->tm_min;\t\t\t\t\\\n+      function_second = function_time->tm_sec;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tUSING\\t*,15\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tB\\tFPL%03d\\n\", function_label_index);\t\t\\\n+  fprintf (FILE, \"\\tDC\\tAL1(FPL%03d+4-*)\\n\", function_label_index + 1);\t\\\n+  fprintf (FILE, \"\\tDC\\tX'CE',X'A0',X'10'\\n\");\t\t\t\t\\\n+  fprintf (FILE, \"\\tDC\\tA($PPA2)\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDC\\tF'%d'\\n\", 0);\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDC\\tF'%d'\\n\", STACK_POINTER_OFFSET + LSIZE\t\t\\\n+\t\t\t+ current_function_outgoing_args_size);\t\t\\\n+  fprintf (FILE, \"FPL%03d\\tEQU\\t*\\n\", function_label_index + 1);\t\\\n+  fprintf (FILE, \"\\tDC\\tAL2(%d),C'%s'\\n\", strlen (mvs_function_name),\t\\\n+\tmvs_function_name);\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n+  if (!function_first)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"$PPA2\\tEQU\\t*\\n\");\t\t\t\t\\\n+      fprintf (FILE, \"\\tDC\\tX'03',X'00',X'33',X'00'\\n\");\t\t\\\n+      fprintf (FILE, \"\\tDC\\tV(CEESTART),A(0)\\n\");\t\t\t\\\n+      fprintf (FILE, \"\\tDC\\tA($TIMES)\\n\");\t\t\t\t\\\n+      fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\\\n+      fprintf (FILE, \"$TIMES\\tEQU\\t*\\n\");\t\t\t\t\\\n+      fprintf (FILE, \"\\tDC\\tCL4'%d',CL4'%02d%02d',CL6'%02d%02d00'\\n\",\t\\\n+\t\t      function_year, function_month, function_day,\t\\\n+\t\t      function_hour, function_minute, function_second);\t\\\n+      fprintf (FILE, \"\\tDC\\tCL2'01',CL4'0100'\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDS\\t0H\\n\");\t\t\t\t\t\t\\\n+  fprintf (FILE, \"FPL%03d\\tEQU\\t*\\n\", function_label_index);\t\t\\\n+  fprintf (FILE, \"\\tSTM\\t14,12,12(13)\\n\");\t\t\t\t\\\n+  fprintf (FILE, \"\\tL\\t2,76(,13)\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tL\\t0,16(,15)\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tALR\\t0,2\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tCL\\t0,12(,12)\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tBNH\\t*+10\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tL\\t15,116(,12)\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tBALR\\t14,15\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tL\\t15,72(,13)\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tSTM\\t15,0,72(2)\\n\");\t\t\t\t\\\n+  fprintf (FILE, \"\\tMVI\\t0(2),X'10'\\n\");\t\t\t\t\\\n+  fprintf (FILE, \"\\tST\\t13,4(,2)\\n \");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tLR\\t13,2\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tLR\\t11,1\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDROP\\t15\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tBALR\\t%d,0\\n\", BASE_REGISTER);\t\t\t\\\n+  fprintf (FILE, \"PG%d\\tEQU\\t*\\n\", mvs_page_num );\t\t\t\\\n+  fprintf (FILE, \"\\tUSING\\t*,%d\\n\", BASE_REGISTER);\t\t\t\\\n+  fprintf (FILE, \"\\tL\\t%d,=A(PGT%d)\\n\", PAGE_REGISTER, mvs_page_num);\t\\\n+  mvs_page_code = 4;\t\t\t\t\t\t\t\\\n+  mvs_page_lit = 4;\t\t\t\t\t\t\t\\\n+  mvs_check_page (FILE, 0, 0);\t\t\t\t\t\t\\\n+  function_base_page = mvs_page_num;\t\t\t\t\t\\\n+  function_first = 1;\t\t\t\t\t\t\t\\\n+  function_label_index += 2;\t\t\t\t\t\t\\\n+}\n+\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (strlen (NAME) * 2 > mvs_function_name_length)\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (mvs_function_name)\t\t\t\t\t\t\\\n+\tfree (mvs_function_name);\t\t\t\t\t\\\n+      mvs_function_name = 0;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  if (!mvs_function_name)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      mvs_function_name_length = strlen (NAME) * 2;\t\t\t\\\n+      mvs_function_name = (char *) malloc (mvs_function_name_length);\t\\\n+      if (mvs_function_name == 0)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  fatal (\"virtual memory exceeded\");\t\t\t\t\\\n+\t  abort ();\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  if (!strcmp (NAME, \"main\"))\t\t\t\t\t\t\\\n+    strcpy (mvs_function_name, \"gccmain\");\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    strcpy (mvs_function_name, NAME);\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDS\\t0H\\n\");\t\t\t\t\t\t\\\n+  assemble_name (FILE, mvs_function_name);\t\t\t\t\\\n+  fputs (\"\\tCSECT\\n\", FILE);\t\t\t\t\t\t\\\n+}\n+\n+/* This macro generates the assembly code for function exit, on machines\n+   that need it.  If FUNCTION_EPILOGUE is not defined then individual\n+   return instructions are generated for each return statement.  Args are\n+   same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.  */\n+\n+#define FUNCTION_EPILOGUE(FILE, LSIZE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\t\t\t\\\n+  check_label_emit();\t\t\t\t\t\t\t\\\n+  mvs_check_page (FILE,14,0);\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tL\\t13,4(,13)\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tL\\t14,12(,13)\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tLM\\t2,12,28(13)\\n\");\t\t\t\t\\\n+  fprintf (FILE, \"\\tBALR\\t1,14\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDC\\tA(\");\t\t\t\t\t\t\\\n+  mvs_page_num++;\t\t\t\t\t\t\t\\\n+  assemble_name (FILE, mvs_function_name);\t\t\t\t\\\n+  fprintf (FILE, \")\\n\" );\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDS\\t0F\\n\" );\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tLTORG\\n\");\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n+  fprintf (FILE, \"PGT%d\\tEQU\\t*\\n\", function_base_page);\t\t\\\n+  mvs_free_label();\t\t\t\t\t\t\t\\\n+  for ( i = function_base_page; i < mvs_page_num; i++ )\t\t\t\\\n+    fprintf (FILE, \"\\tDC\\tA(PG%d)\\n\", i);\t\t\t\t\\\n+}\n+\n+/* Output assembler code for a block containing the constant parts of a\n+   trampoline, leaving space for the variable parts.\n+\n+   On the 370, the trampoline contains these instructions:\n+\n+        BALR  14,0\n+        USING *,14\n+        L     STATIC_CHAIN_REGISTER,X\n+        L     15,Y\n+        BR    15\n+   X    DS    0F\n+   Y    DS    0F  */\n+\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x05E0));\t\\\n+  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x5800 | \t\\\n+\t\t\t   STATIC_CHAIN_REGNUM << 4));\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0xE00A));\t\\\n+  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x58F0)); \t\\\n+  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0xE00E));\t\\\n+  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x07FF));\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE 20\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.  */\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 12)), CXT); \\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 16)), FNADDR); \\\n+}\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO) \t\t\t\t\\\n+  fprintf (FILE, \"Error: No profiling availble.\\n\")\n+\n+/* Define EXIT_IGNORE_STACK if, when returning from a function, the stack\n+   pointer does not matter (provided there is a frame pointer).  */\n+\n+#define EXIT_IGNORE_STACK\t1\n+\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* #define HAVE_POST_INCREMENT */\n+/* #define HAVE_POST_DECREMENT */\n+\n+/* #define HAVE_PRE_DECREMENT */\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.  They give\n+   nonzero only if REGNO is a hard reg of the suitable class or a pseudo\n+   reg currently allocated to a suitable hard reg.\n+   These definitions are NOT overridden anywhere.  */\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO) \t\t\t\t\t\\\n+  (((REGNO) > 0 && (REGNO) < 16)\t\t\t\t\t\\\n+    || (reg_renumber[REGNO] > 0 && reg_renumber[REGNO] < 16))\n+\n+#define REGNO_OK_FOR_BASE_P(REGNO) REGNO_OK_FOR_INDEX_P(REGNO)\n+\n+#define REGNO_OK_FOR_DATA_P(REGNO) \t\t\t\t\t\\\n+  ((REGNO) < 16 || (unsigned) reg_renumber[REGNO] < 16)\n+\n+#define REGNO_OK_FOR_FP_P(REGNO) \t\t\t\t\t\\\n+  ((unsigned) ((REGNO) - 16) < 4 || (unsigned) (reg_renumber[REGNO] - 16) < 4)\n+\n+/* Now macros that check whether X is a register and also,\n+   strictly, whether it is in a specified class.  */\n+\n+/* 1 if X is a data register.  */\n+\n+#define DATA_REG_P(X) (REG_P (X) && REGNO_OK_FOR_DATA_P (REGNO (X)))\n+\n+/* 1 if X is an fp register.  */\n+\n+#define FP_REG_P(X) (REG_P (X) && REGNO_OK_FOR_FP_P (REGNO (X)))\n+\n+/* 1 if X is an address register.  */\n+\n+#define ADDRESS_REG_P(X) (REG_P (X) && REGNO_OK_FOR_BASE_P (REGNO (X)))\n+\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+/* Recognize any constant value that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n+  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n+  || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST_DOUBLE\t\t\\\n+  || (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n+\t  && GET_CODE (XEXP (XEXP (X, 0), 0)) == LABEL_REF)\t\t\\\n+  || (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n+\t  && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF\t\t\\\n+\t  && !SYMBOL_REF_FLAG (XEXP (XEXP (X, 0), 0))))\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) 1\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx and check\n+   its validity for a certain class.  We have two alternate definitions\n+   for each of them.  The usual definition accepts all pseudo regs; the\n+   other rejects them all.  The symbol REG_OK_STRICT causes the latter\n+   definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that they will\n+   get allocated to the class that the insn wants them to be in.\n+   Some source files that are used after register allocation\n+   need to be strict.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index or if it is\n+  a pseudo reg.  */\n+\n+#define REG_OK_FOR_INDEX_P(X)\t\t\t\t\t\t\\\n+  ((REGNO(X) > 0 && REGNO(X) < 16) || REGNO(X) >= 20)\n+\n+/* Nonzero if X is a hard reg that can be used as a base reg or if it is\n+   a pseudo reg.  */\n+\n+#define REG_OK_FOR_BASE_P(X)\tREG_OK_FOR_INDEX_P(X)\n+\n+#else /* REG_OK_STRICT */\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P(REGNO(X))\n+\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P(REGNO(X))\n+\n+#endif /* REG_OK_STRICT */\n+\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a\n+   valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n+   except for CONSTANT_ADDRESS_P which is actually machine-independent.  */\n+\n+#define COUNT_REGS(X, REGS, FAIL)\t\t\t\t\t\\\n+ if (REG_P (X) && REG_OK_FOR_BASE_P (X))\t\t\t\t\\\n+   REGS += 1;\t\t\t\t\t\t\t\t\\\n+ else if (GET_CODE (X) != CONST_INT || (unsigned) INTVAL (X) >= 4096)\t\\\n+   goto FAIL;\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (REG_P (X) && REG_OK_FOR_BASE_P (X))\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int regs = 0;\t\t\t\t\t\t\t\\\n+      rtx x0 = XEXP (X, 0);\t\t\t\t\t\t\\\n+      rtx x1 = XEXP (X, 1);\t\t\t\t\t\t\\\n+      if (GET_CODE (x0) == PLUS)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  COUNT_REGS (XEXP (x0, 0), regs, FAIL);\t\t\t\\\n+\t  COUNT_REGS (XEXP (x0, 1), regs, FAIL);\t\t\t\\\n+\t  COUNT_REGS (x1, regs, FAIL);\t\t\t\t\t\\\n+\t  if (regs == 2)\t\t\t\t\t\t\\\n+\t    goto ADDR;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (x1) == PLUS)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  COUNT_REGS (x0, regs, FAIL);\t\t\t\t\t\\\n+\t  COUNT_REGS (XEXP (x1, 0), regs, FAIL);\t\t\t\\\n+\t  COUNT_REGS (XEXP (x1, 1), regs, FAIL);\t\t\t\\\n+\t  if (regs == 2)\t\t\t\t\t\t\\\n+\t    goto ADDR;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  COUNT_REGS (x0, regs, FAIL);\t\t\t\t\t\\\n+\t  COUNT_REGS (x1, regs, FAIL);\t\t\t\t\t\\\n+\t  if (regs != 0)\t\t\t\t\t\t\\\n+\t    goto ADDR;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  FAIL: ;\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* The 370 has no mode dependent addresses.  */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\n+\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.  */\n+\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\t\\\n+    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\t\\\n+\t\t   copy_to_mode_reg (SImode, XEXP (X, 1)));\t\t\\\n+  if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\t\\\n+    (X) = gen_rtx (PLUS, SImode, XEXP (X, 1),\t\t\t\t\\\n+\t\t   copy_to_mode_reg (SImode, XEXP (X, 0)));\t\t\\\n+  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\t\\\n+    (X) = gen_rtx (PLUS, SImode, XEXP (X, 1),\t\t\t\t\\\n+\t\t   force_operand (XEXP (X, 0), 0));\t\t\t\\\n+  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)\t\t\\\n+    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\t\\\n+\t\t   force_operand (XEXP (X, 1), 0));\t\t\t\\\n+  if (memory_address_p (MODE, X))\t\t\t\t\t\\\n+    goto WIN;\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Specify the machine mode that this machine uses for the index in the\n+   tablejump instruction.  */\n+\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define this if the tablejump instruction expects the table to contain\n+   offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+\n+/* #define CASE_VECTOR_PC_RELATIVE */\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* Define this if fixuns_trunc is the same as fix_trunc.  */\n+\n+#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n+\n+/* We use \"unsigned char\" as default.  */\n+\n+#define DEFAULT_SIGNED_CHAR 0\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Max number of bytes we can move from memory to memory in one reasonably\n+   fast instruction.  */\n+\n+#define MOVE_MAX 256\n+\n+/* Define this if zero-extension is slow (more than one real instruction).  */\n+\n+#define SLOW_ZERO_EXTEND\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* Define if shifts truncate the shift count which implies one can omit\n+   a sign-extension or zero-extension of a shift count.  */\n+\n+/* #define SHIFT_COUNT_TRUNCATED */\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)\t(OUTPREC != 16)\n+\n+/* We assume that the store-condition-codes instructions store 0 for false\n+   and some other value for true.  This is the value stored for true.  */\n+\n+/* #define STORE_FLAG_VALUE -1 */\n+\n+/* When a prototype says `char' or `short', really pass an `int'.  */\n+\n+#define PROMOTE_PROTOTYPES\n+\n+/* Don't perform CSE on function addresses.  */\n+\n+#define NO_FUNCTION_CSE\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+\n+#define Pmode SImode\n+\n+/* A function address in a call instruction is a byte address (for\n+   indexing purposes) so give the MEM rtx a byte's mode.  */\n+\n+#define FUNCTION_MODE QImode\n+\n+/* Compute the cost of computing a constant rtl expression RTX whose\n+   rtx-code is CODE.  The body of this macro is a portion of a switch\n+   statement.  If the code is computed here, return it with a return\n+   statement.  Otherwise, break from the switch.  */\n+\n+#define CONST_COSTS(RTX, CODE, OUTERCODE)\t\t\t\t\\\n+  case CONST_INT:\t\t\t\t\t\t\t\\\n+    if ((unsigned) INTVAL (RTX) < 0xfff) return 1;\t\t\t\\\n+  case CONST:\t\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\t\\\n+    return 2;\t\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n+    return 4;\n+\n+/* Tell final.c how to eliminate redundant test instructions.  */\n+\n+/* Here we define machine-dependent flags and fields in cc_status\n+   (see `conditions.h').  */\n+\n+/* Store in cc_status the expressions that the condition codes will\n+   describe after execution of an instruction whose pattern is EXP.\n+   Do not alter them if the instruction would not alter the cc's.\n+\n+   On the 370, load insns do not alter the cc's.  However, in some\n+   cases these instructions can make it possibly invalid to use the\n+   saved cc's.  In those cases we clear out some or all of the saved\n+   cc's so they won't be used.  */\n+\n+#define NOTICE_UPDATE_CC(EXP, INSN)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  rtx exp = (EXP);\t\t\t\t\t\t\t\\\n+  if (GET_CODE (exp) == PARALLEL) /* Check this */\t\t\t\\\n+    exp = XVECEXP (exp, 0, 0);\t\t\t\t\t\t\\\n+  if (GET_CODE (exp) != SET)\t\t\t\t\t\t\\\n+    CC_STATUS_INIT;\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (XEXP (exp, 0) == cc0_rtx)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  cc_status.value1 = XEXP (exp, 0);\t\t\t\t\\\n+\t  cc_status.value2 = XEXP (exp, 1);\t\t\t\t\\\n+\t  cc_status.flags = 0;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (cc_status.value1\t\t\t\t\t\t\\\n+\t      && reg_mentioned_p (XEXP (exp, 0), cc_status.value1))\t\\\n+\t    cc_status.value1 = 0;\t\t\t\t\t\\\n+\t  if (cc_status.value2\t\t\t\t\t\t\\\n+\t      && reg_mentioned_p (XEXP (exp, 0), cc_status.value2))\t\\\n+\t    cc_status.value2 = 0;\t\t\t\t\t\\\n+\t  switch (GET_CODE (XEXP (exp, 1)))\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      case PLUS:     case MINUS: case MULT:   /* case UMULT: */\t\\\n+\t      case DIV:      case UDIV:  case NEG:    case ASHIFT:\t\\\n+\t      case ASHIFTRT: case AND:   case IOR:    case XOR:\t\t\\\n+\t      case ABS:      case NOT:\t\t\t\t\t\\\n+\t\tCC_STATUS_SET (XEXP (exp, 0), XEXP (exp, 1));\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+\n+#define CC_STATUS_SET(V1, V2)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  cc_status.flags = 0;\t\t\t\t\t\t\t\\\n+  cc_status.value1 = (V1);\t\t\t\t\t\t\\\n+  cc_status.value2 = (V2);\t\t\t\t\t\t\\\n+  if (cc_status.value1\t\t\t\t\t\t\t\\\n+      && reg_mentioned_p (cc_status.value1, cc_status.value2))\t\t\\\n+    cc_status.value2 = 0;\t\t\t\t\t\t\\\n+}\n+\n+#define OUTPUT_JUMP(NORMAL, FLOAT, NO_OV) \t\t\t\t\\\n+{ if (cc_status.flags & CC_NO_OVERFLOW)\treturn NO_OV; return NORMAL; }\n+\n+/* Control the assembler format that we output.  */\n+\n+#define TEXT_SECTION_ASM_OP \"* Program text area\"\n+#define DATA_SECTION_ASM_OP \"* Program data area\"\n+#define INIT_SECTION_ASM_OP \"* Program initialization area\"\n+#define CTOR_LIST_BEGIN\t\t/* NO OP */\n+#define CTOR_LIST_END\t\t/* NO OP */\n+\n+/* How to refer to registers in assembler output.  This sequence is\n+   indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n+{ \"0\",  \"1\",  \"2\",  \"3\",  \"4\",  \"5\",  \"6\",  \"7\",\t\t\t\\\n+  \"8\",  \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\t\t\t\\\n+  \"0\",  \"2\",  \"4\",  \"6\"\t\t\t\t\t\t\t\\\n+}\n+\n+/* How to renumber registers for dbx and gdb.  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+#define ASM_FILE_START(FILE) fputs (\"\\tCSECT\\n\", FILE);\n+#define ASM_FILE_END(FILE) fputs (\"\\tEND\\n\", FILE);\n+#define ASM_IDENTIFY_GCC(FILE)\n+#define ASM_COMMENT_START \"*\"\n+#define ASM_APP_OFF \"\"\n+#define ASM_APP_ON \"\"\n+\n+#define ASM_OUTPUT_LABEL(FILE, NAME) \t\t\t\t\t\\\n+{ assemble_name (FILE, NAME); fputs (\"\\tEQU\\t*\\n\", FILE); }\n+\n+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t/* NO OP */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE, NAME)\t\t\t\t\t\\\n+{ fputs (\"\\tENTRY\\t\", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE); }\n+\n+/* MVS externals are limited to 8 characters, upper case only.\n+   The '_' is mapped to '@', except for MVS functions, then '#'.  */\n+\n+#define MAX_MVS_LABEL_SIZE 8\n+\n+#define ASM_OUTPUT_LABELREF(FILE, NAME)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  char *bp, ch, temp[MAX_MVS_LABEL_SIZE + 1];\t\t\t\t\\\n+  if (strlen (NAME) > MAX_MVS_LABEL_SIZE)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      strncpy (temp, NAME, MAX_MVS_LABEL_SIZE);\t\t\t\t\\\n+      temp[MAX_MVS_LABEL_SIZE] = '\\0';\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    strcpy (temp,NAME);\t\t\t\t\t\t\t\\\n+  if (!strcmp (temp,\"main\"))\t\t\t\t\t\t\\\n+    strcpy (temp,\"gccmain\");\t\t\t\t\t\t\\\n+  if (mvs_function_check (temp))\t\t\t\t\t\\\n+    ch = '#';\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    ch = '@';\t\t\t\t\t\t\t\t\\\n+  for (bp = temp; *bp; bp++)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (islower (*bp)) *bp = toupper (*bp);\t\t\t\t\\\n+      if (*bp == '_') *bp = ch;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"%s\", temp);\t\t\t\t\t\t\\\n+}\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\t\t\\\n+  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n+\n+/* Generate internal label.  Since we can branch here from off page, we\n+   must reload the base register.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE, PREFIX, NUM) \t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (!strcmp (PREFIX,\"L\"))\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      mvs_add_label(NUM);\t\t\t\t\t\t\\\n+      mvs_label_emited = 1;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"%s%d\\tEQU\\t*\\n\", PREFIX, NUM);\t\t\t\\\n+}\n+\n+/* Generate case label.  */\n+\n+#define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)\t\t\t\\\n+   fprintf (FILE, \"%s%d\\tEQU\\t*\\n\", PREFIX, NUM)\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \t\t\t\t\\\n+  mvs_check_page (FILE, 4, 0);\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDC\\tA(L%d)\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \t\t\t\\\n+  mvs_check_page (FILE, 4, 0);\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDC\\tA(L%d-L%d)\\n\", VALUE, REL)\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE, REGNO)\t\t\t\t\\\n+  mvs_check_page (FILE, 8, 4);\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tS\\t13,=F'4'\\n\\tST\\t%s,%d(13)\\n\",\t\t\t\\\n+     reg_names[REGNO], STACK_POINTER_OFFSET)\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE, REGNO)\t\t\t\t\t\\\n+  mvs_check_page (FILE, 8, 0);\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tL\\t%s,%d(13)\\n\\tLA\\t13,4(13)\\n\",\t\t\t\\\n+     reg_names[REGNO], STACK_POINTER_OFFSET)\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE, VALUE)\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDC\\tD'%.18G'\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#define ASM_OUTPUT_FLOAT(FILE, VALUE)\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDC\\tE'%.9G'\\n\", (VALUE))\n+\n+/* This outputs an integer, if not a CONST_INT must be address constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE, EXP)\t\t\t\t\t\\\n+{ \t\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (EXP) == CONST_INT)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tDC\\tF'\");\t\t\t\t\t\\\n+      output_addr_const (FILE, EXP);\t\t\t\t\t\\\n+      fprintf (FILE, \"'\\n\");\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tDC\\tA(\");\t\t\t\t\t\\\n+      output_addr_const (FILE, EXP);\t\t\t\t\t\\\n+      fprintf (FILE, \")\\n\");\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* This outputs a short integer.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE, EXP)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDC\\tH'\");\t\t\t\t\t\t\\\n+  output_addr_const (FILE, EXP);\t\t\t\t\t\\\n+  fprintf (FILE, \"'\\n\");\t\t\t\t\t\t\\\n+}\n+\n+/* This outputs a byte sized integer.  */\n+\n+#define ASM_OUTPUT_CHAR(FILE, EXP)\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDC\\tX'%02X'\\n\", INTVAL (EXP) )\n+\n+#define ASM_OUTPUT_BYTE(FILE, VALUE)\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDC\\tX'%02X'\\n\", VALUE)\n+\n+/* This outputs a text string.  The string are chopped up to fit into\n+   an 80 byte record.  Also, control and special characters, interpreted\n+   by the IBM assembler, are output numerically.  */\n+\n+#define MVS_ASCII_TEXT_LENGTH 48\n+\n+#define ASM_OUTPUT_ASCII(FILE, PTR, LEN)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  int i, j;\t\t\t\t\t\t\t\t\\\n+  int c;\t\t\t\t\t\t\t\t\\\n+  for (j = 0, i = 0; i < LEN; j++, i++)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      c = PTR[i];\t\t\t\t\t\t\t\\\n+      if (iscntrl (c) || c == '&')\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (j % MVS_ASCII_TEXT_LENGTH != 0 )\t\t\t\t\\\n+\t    fprintf (FILE, \"'\\n\");\t\t\t\t\t\\\n+\t  j = -1;\t\t\t\t\t\t\t\\\n+\t  if (c == '&') c = MAP_CHARACTER (c);\t\t\t\t\\\n+\t  fprintf (FILE, \"\\tDC\\tX'%X'\\n\", c );\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (j % MVS_ASCII_TEXT_LENGTH == 0)\t\t\t\t\\\n+            fprintf (FILE, \"\\tDC\\tC'%c\", c);\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if ( c == '\\'' )\t\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"%c%c\", c, c);\t\t\t\t\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"%c\", c);\t\t\t\t\\\n+\t      if (j % MVS_ASCII_TEXT_LENGTH\t\t\t\t\\\n+\t\t  == MVS_ASCII_TEXT_LENGTH - 1)\t\t\t\t\\\n+\t\tfprintf (FILE, \"'\\n\" );\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  if (j % MVS_ASCII_TEXT_LENGTH != 0)\t\t\t\t\t\\\n+    fprintf (FILE, \"'\\n\");\t\t\t\t\t\t\\\n+}\n+\n+/* This is how to output an assembler line that says to advance the\n+   location counter to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE, LOG)\t\t\t\t\t\\\n+  if (LOG)\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if ((LOG) == 1)\t\t\t\t\t\t\t\\\n+        fprintf (FILE, \"\\tDS\\t0H\\n\" );\t\t\t\t\t\\\n+      else \t\t\t\t\t\t\t\t\\\n+        fprintf (FILE, \"\\tDS\\t0F\\n\" );\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\n+/* The maximum length of memory that the IBM assembler will allow in one\n+   DS operation.  */\n+\n+#define MAX_CHUNK 32767\n+\n+/* A C statement to output to the stdio stream FILE an assembler\n+   instruction to advance the location counter by SIZE bytes. Those\n+   bytes should be zero when loaded.  */\n+\n+#define ASM_OUTPUT_SKIP(FILE, SIZE)  \t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  int s, k;\t\t\t\t\t\t\t\t\\\n+  for (s = (SIZE); s > 0; s -= MAX_CHUNK)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (s > MAX_CHUNK)\t\t\t\t\t\t\\\n+\tk = MAX_CHUNK;\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tk = s;\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tDS\\tXL%d\\n\", k);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* A C statement (sans semicolon) to output to the stdio stream\n+   FILE the assembler definition of a common-label named NAME whose\n+   size is SIZE bytes.  The variable ROUNDED is the size rounded up\n+   to whatever alignment the caller wants.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED) \t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  fputs (\"\\tENTRY\\t\", FILE);\t\t\t\t\t\t\\\n+  assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+  fputs (\"\\n\", FILE);\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n+  ASM_OUTPUT_LABEL (FILE,NAME);\t\t\t\t\t\t\\\n+  ASM_OUTPUT_SKIP (FILE,SIZE);\t\t\t\t\t\t\\\n+}\n+\n+/* A C statement (sans semicolon) to output to the stdio stream\n+   FILE the assembler definition of a local-common-label named NAME\n+   whose size is SIZE bytes.  The variable ROUNDED is the size\n+   rounded up to whatever alignment the caller wants.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED) \t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n+  ASM_OUTPUT_LABEL (FILE,NAME);\t\t\t\t\t\t\\\n+  ASM_OUTPUT_SKIP (FILE,SIZE);\t\t\t\t\t\t\\\n+}\n+\n+/* Store in OUTPUT a string (made with alloca) containing an\n+   assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)  \t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10);\t\t\t\\\n+  sprintf ((OUTPUT), \"%s%d\", (NAME), (LABELNO));\t\t\t\\\n+}\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+\n+#define TARGET_BELL\t47\n+#define TARGET_BS\t22\n+#define TARGET_TAB\t5\n+#define TARGET_NEWLINE\t21\n+#define TARGET_VT\t11\n+#define TARGET_FF\t12\n+#define TARGET_CR\t13\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n+\n+#define PRINT_OPERAND(FILE, X, CODE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  switch (GET_CODE (X))\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      static char curreg[4];\t\t\t\t\t\t\\\n+      case REG:\t\t\t\t\t\t\t\t\\\n+\tif (CODE == 'N')\t\t\t\t\t\t\\\n+\t    strcpy (curreg, reg_names[REGNO (X) + 1]);\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t    strcpy (curreg, reg_names[REGNO (X)]);\t\t\t\\\n+\tfprintf (FILE, \"%s\", curreg);\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      case MEM:\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  rtx addr = XEXP (X, 0);\t\t\t\t\t\\\n+\t  if (CODE == 'O')\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n+\t\tfprintf (FILE, \"%d\", INTVAL (XEXP (addr, 1)));\t\t\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"0\");\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else if (CODE == 'R')\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n+\t\tfprintf (FILE, \"%s\", reg_names[REGNO (XEXP (addr, 0))]);\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"%s\", reg_names[REGNO (addr)]);\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    output_address (XEXP (X, 0));\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      case SYMBOL_REF:\t\t\t\t\t\t\t\\\n+      case LABEL_REF:\t\t\t\t\t\t\t\\\n+\tmvs_page_lit += 4;\t\t\t\t\t\t\\\n+\tif (SYMBOL_REF_FLAG (X)) fprintf (FILE, \"=V(\");\t\t\t\\\n+\telse                     fprintf (FILE, \"=A(\");\t\t\t\\\n+\toutput_addr_const (FILE, X);\t\t\t\t\t\\\n+\tfprintf (FILE, \")\");\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      case CONST_INT:\t\t\t\t\t        \t\\\n+\tif (CODE == 'B')\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"%d\", INTVAL (X) & 0xff);\t\t\t\\\n+\telse if (CODE == 'X')\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"%02X\", INTVAL (X) & 0xff);\t\t\t\\\n+\telse if (CODE == 'h')\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"%d\", (INTVAL (X) << 16) >> 16);\t\t\\\n+\telse if (CODE == 'H')\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"=F'%d'\", (INTVAL (X) << 16) >> 16);\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"=F'%d'\", INTVAL (X));\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      case CONST_DOUBLE:\t\t\t\t\t\t\\\n+\tif (GET_MODE (X) == DImode)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    if (CODE == 'M')\t\t\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_LOW (X));\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t    else if (CODE == 'L')\t\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_HIGH (X));\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"=XL8'%08X%08X'\", CONST_DOUBLE_LOW (X),\t\\\n+\t\t\tCONST_DOUBLE_HIGH (X));\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  { \t\t\t\t\t\t\t\t\\\n+\t    union { double d; int i[2]; } u;\t\t\t\t\\\n+\t    u.i[0] = CONST_DOUBLE_LOW (X);\t\t\t\t\\\n+\t    u.i[1] = CONST_DOUBLE_HIGH (X);\t\t\t\t\\\n+\t    if (GET_MODE (X) == SFmode)\t\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"=E'%.9G'\", u.d);\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"=D'%.18G'\", u.d);\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      case CONST:\t\t\t\t\t\t\t\\\n+\tif (GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\t\\\n+\t   && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF)\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n+\t    if (SYMBOL_REF_FLAG (XEXP (XEXP (X, 0), 0)))\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"=V(\");\t\t\t\t\t\\\n+\t\tASM_OUTPUT_LABELREF (FILE,\t\t\t\t\\\n+\t\t\t\t  XSTR (XEXP (XEXP (X, 0), 0), 0));\t\\\n+\t\tfprintf (FILE, \")\\n\\tA\\t%s,=F'%d'\", curreg,\t\t\\\n+\t\t\t\t  INTVAL (XEXP (XEXP (X, 0), 1)));\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"=A(\");\t\t\t\t\t\\\n+\t\toutput_addr_const (FILE, X);\t\t\t\t\\\n+\t\tfprintf (FILE, \")\");\t\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"=F'\");\t\t\t\t\t\\\n+\t    output_addr_const (FILE, X);\t\t\t\t\\\n+\t    fprintf (FILE, \"'\");\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      default:\t\t\t\t\t\t\t\t\\\n+\tabort();\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  rtx breg, xreg, offset, plus;\t\t\t\t\t\t\\\n+  \t\t\t\t\t\t\t\t\t\\\n+  switch (GET_CODE (ADDR))\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      case REG:\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"0(%s)\", reg_names[REGNO (ADDR)]);\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      case PLUS:\t\t\t\t\t\t\t\\\n+\tbreg = 0;\t\t\t\t\t\t\t\\\n+\txreg = 0;\t\t\t\t\t\t\t\\\n+\toffset = 0;\t\t\t\t\t\t\t\\\n+\tif (GET_CODE (XEXP (ADDR, 0)) == PLUS)\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    if (GET_CODE (XEXP (ADDR, 1)) == REG)\t\t\t\\\n+\t      breg = XEXP (ADDR, 1);\t\t\t\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      offset = XEXP (ADDR, 1);\t\t\t\t\t\\\n+\t    plus = XEXP (ADDR, 0);\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    if (GET_CODE (XEXP (ADDR, 0)) == REG)\t\t\t\\\n+\t      breg = XEXP (ADDR, 0);\t\t\t\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      offset = XEXP (ADDR, 0);\t\t\t\t\t\\\n+\t    plus = XEXP (ADDR, 1);\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\tif (GET_CODE (plus) == PLUS)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    if (GET_CODE (XEXP (plus, 0)) == REG)\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tif (breg)\t\t\t\t\t\t\\\n+\t\t  xreg = XEXP (plus, 0);\t\t\t\t\\\n+\t\telse\t\t\t\t\t\t\t\\\n+\t\t  breg = XEXP (plus, 0);\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\toffset = XEXP (plus, 0);\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t    if (GET_CODE (XEXP (plus, 1)) == REG)\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tif (breg)\t\t\t\t\t\t\\\n+\t\t  xreg = XEXP (plus, 1);\t\t\t\t\\\n+\t\telse\t\t\t\t\t\t\t\\\n+\t\t  breg = XEXP (plus, 1);\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\toffset = XEXP (plus, 1);\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse if (GET_CODE (plus) == REG)\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    if (breg)\t\t\t\t\t\t\t\\\n+\t      xreg = plus;\t\t\t\t\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      breg = plus;\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    offset = plus;\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\tif (offset)\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    if (GET_CODE (offset) == LABEL_REF)\t\t\t\t\\\n+\t      fprintf (FILE, \"L%d\",\t\t\t\t\t\\\n+\t\t\tCODE_LABEL_NUMBER (XEXP (offset, 0)));\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      output_addr_const (FILE, offset);\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"0\");\t\t\t\t\t\t\\\n+\tif (xreg)\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"(%s,%s)\",\t\t\t\t\t\\\n+\t\t    reg_names[REGNO (xreg)], reg_names[REGNO (breg)]); \t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"(%s)\", reg_names[REGNO (breg)]);\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      default:\t\t\t\t\t\t\t\t\\\n+\tmvs_page_lit += 4;\t\t\t\t\t\t\\\n+\tif (SYMBOL_REF_FLAG (ADDR)) fprintf (FILE, \"=V(\");\t\t\\\n+\telse                        fprintf (FILE, \"=A(\");\t\t\\\n+\toutput_addr_const (FILE, ADDR);\t\t\t\t\t\\\n+\tfprintf (FILE, \")\");\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}"}, {"sha": "ab82f938845df430f798d834b9408c8209ba0d97", "filename": "gcc/config/i370/i370.md", "status": "added", "additions": 4286, "deletions": 0, "changes": 4286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881430620003209aa70da850787de3e25e97dc36/gcc%2Fconfig%2Fi370%2Fi370.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881430620003209aa70da850787de3e25e97dc36/gcc%2Fconfig%2Fi370%2Fi370.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.md?ref=881430620003209aa70da850787de3e25e97dc36"}, {"sha": "244da8fba8a73e0736e54f1c3fe259e1068af2c0", "filename": "gcc/config/i370/xm-i370.h", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881430620003209aa70da850787de3e25e97dc36/gcc%2Fconfig%2Fi370%2Fxm-i370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881430620003209aa70da850787de3e25e97dc36/gcc%2Fconfig%2Fi370%2Fxm-i370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fxm-i370.h?ref=881430620003209aa70da850787de3e25e97dc36", "patch": "@@ -0,0 +1,56 @@\n+/* Configuration for GNU C-compiler for System/370.\n+   Copyright (C) 1989, 1993 Free Software Foundation, Inc.\n+   Contributed by Jan Stein (jan@cd.chalmers.se).\n+   Modifed for MVS C/370 by Dave Pitts (pitts@mcdata.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* #defines that need visibility everywhere.  */\n+\n+#define FALSE 0\n+#define TRUE 1\n+\n+/* This describes the machine the compiler is hosted on.  */\n+\n+#define HOST_BITS_PER_CHAR\t8\n+#define HOST_BITS_PER_SHORT\t16\n+#define HOST_BITS_PER_INT\t32\n+#define HOST_BITS_PER_LONG\t32\n+#define HOST_FLOAT_FORMAT\tIBM_FLOAT_FORMAT\n+#define HOST_EBCDIC\t\t1\n+\n+#define USG\n+#ifndef MVS\n+#define MVS\n+#endif\n+\n+/* Target machine dependencies.  tm.h is a symbolic link to the actual\n+   target specific file.  */\n+\n+#include \"tm.h\"\n+\n+#define bcopy(a,b,c) memcpy (b,a,c)\n+#define bzero(a,b) memset (a,0,b)\n+#define bcmp(a,b,c) memcmp (a,b,c)\n+\n+/* Arguments to use with `exit'.  */\n+\n+#define SUCCESS_EXIT_CODE\t0\n+#define FATAL_EXIT_CODE\t\t12\n+\n+#define NO_DBX_FORMAT\n+"}]}