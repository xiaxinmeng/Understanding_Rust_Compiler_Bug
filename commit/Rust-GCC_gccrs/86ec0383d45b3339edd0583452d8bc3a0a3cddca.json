{"sha": "86ec0383d45b3339edd0583452d8bc3a0a3cddca", "node_id": "C_kwDOANBUbNoAKDg2ZWMwMzgzZDQ1YjMzMzllZGQwNTgzNDUyZDhiYzNhMGEzY2RkY2E", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-22T10:15:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-22T10:15:12Z"}, "message": "Merge #757 #758 #759 #760\n\n757: Fix TypePath resolution to iterate segments r=philberty a=philberty\n\nAssociated types in rust can be of the form:\r\n\r\n```rust\r\ntrait Foo {\r\n  type A;\r\n   ...\r\n}\r\n\r\nfn test<T:Foo>(a:T) -> T::A { .. }\r\n```\r\n\r\nWhere the type-bound of Foo is applied to T this allows for a the associated type T::A to exist\r\nwhich is a placeholder type within the trait definition. This path cannot be resolved at name-resolution\r\ntime and requires a path probe.\r\n\r\nFixes #746 \n\n758: The number of required substituions is offset from inherited ones r=philberty a=philberty\n\nWhen doing HIR::GenericArgs substitutions we must offset from the already\r\npartially substituted arguments.\r\n\n\n759: Remove second lookup for query compiled functions r=philberty a=philberty\n\nThis cleans up the code here to make use of the query based\r\ncompilation which returns the address of the function which\r\nremoves extra lookups.\r\n\n\n760: Cleanup lookup interfaces r=philberty a=philberty\n\nThese patches change the associated impl mapping's to use a boolean\r\nreturn type for error handling, to stop looking for UNKNOWN_HIRID for\r\nerror handling which is too easy to make mistakes with.\r\n\r\nIt also updates instances of code to use TyTy::ErrorType node instead of\r\nnullptr's for error handling.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "a9e36801352ce3ee308f18c78a2221000d1c1752", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9e36801352ce3ee308f18c78a2221000d1c1752"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86ec0383d45b3339edd0583452d8bc3a0a3cddca", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhco8wCRBK7hj4Ov3rIwAArB0IABCOYRSrJcakKi/thW3iYwSz\nlvlyOTktwWPWX92Fp5HpCuM5i/wMo09cpS1l6hCur5pVhVbFAZCOU2QK/zjoD4el\nwjCt6KHShO+x0VDSDM0AIjPHDJcAPWRxk4gGIjYplzkQrbpFgQymxXAdKgdOcHsC\njHvFosR2PC/1uUXAoCwciwpqxATpb6FpvnYu4nHNgKhc94XQBL+7zTkCuH6OXUJc\nz4YmGme84+kA2f8QKzeKb6G5rtmk+f3f6aOKtk9kGhv3mZWULU7bjxZnqdWKDTk7\nbMLDdh5vWQypEPgGkhB5GpI/e+C2I0lH8fXMDpNXhSsDJNobf4rfQK0Uzpixg/w=\n=8RPh\n-----END PGP SIGNATURE-----\n", "payload": "tree a9e36801352ce3ee308f18c78a2221000d1c1752\nparent 2cd9855d914e760f4c74ac01ad2f7e9378cd80fa\nparent d755769bd15209193d1c178862ed3e01ba5c3d9d\nparent b538aa91056a10b31c54580316c49c764f884d67\nparent d17b799df72e7d5dc6379b8e46f5188c2981faed\nparent ef70f0310a6739727ee97cd4f996f8938b0e6a1d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1634897712 +0000\ncommitter GitHub <noreply@github.com> 1634897712 +0000\n\nMerge #757 #758 #759 #760\n\n757: Fix TypePath resolution to iterate segments r=philberty a=philberty\n\nAssociated types in rust can be of the form:\r\n\r\n```rust\r\ntrait Foo {\r\n  type A;\r\n   ...\r\n}\r\n\r\nfn test<T:Foo>(a:T) -> T::A { .. }\r\n```\r\n\r\nWhere the type-bound of Foo is applied to T this allows for a the associated type T::A to exist\r\nwhich is a placeholder type within the trait definition. This path cannot be resolved at name-resolution\r\ntime and requires a path probe.\r\n\r\nFixes #746 \n\n758: The number of required substituions is offset from inherited ones r=philberty a=philberty\n\nWhen doing HIR::GenericArgs substitutions we must offset from the already\r\npartially substituted arguments.\r\n\n\n759: Remove second lookup for query compiled functions r=philberty a=philberty\n\nThis cleans up the code here to make use of the query based\r\ncompilation which returns the address of the function which\r\nremoves extra lookups.\r\n\n\n760: Cleanup lookup interfaces r=philberty a=philberty\n\nThese patches change the associated impl mapping's to use a boolean\r\nreturn type for error handling, to stop looking for UNKNOWN_HIRID for\r\nerror handling which is too easy to make mistakes with.\r\n\r\nIt also updates instances of code to use TyTy::ErrorType node instead of\r\nnullptr's for error handling.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86ec0383d45b3339edd0583452d8bc3a0a3cddca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86ec0383d45b3339edd0583452d8bc3a0a3cddca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86ec0383d45b3339edd0583452d8bc3a0a3cddca/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cd9855d914e760f4c74ac01ad2f7e9378cd80fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cd9855d914e760f4c74ac01ad2f7e9378cd80fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cd9855d914e760f4c74ac01ad2f7e9378cd80fa"}, {"sha": "d755769bd15209193d1c178862ed3e01ba5c3d9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d755769bd15209193d1c178862ed3e01ba5c3d9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d755769bd15209193d1c178862ed3e01ba5c3d9d"}, {"sha": "b538aa91056a10b31c54580316c49c764f884d67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b538aa91056a10b31c54580316c49c764f884d67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b538aa91056a10b31c54580316c49c764f884d67"}, {"sha": "d17b799df72e7d5dc6379b8e46f5188c2981faed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d17b799df72e7d5dc6379b8e46f5188c2981faed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d17b799df72e7d5dc6379b8e46f5188c2981faed"}, {"sha": "ef70f0310a6739727ee97cd4f996f8938b0e6a1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef70f0310a6739727ee97cd4f996f8938b0e6a1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef70f0310a6739727ee97cd4f996f8938b0e6a1d"}], "stats": {"total": 652, "additions": 491, "deletions": 161}, "files": [{"sha": "9e8236c3893103d140a4de8a1d62ced8a2477ddc", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=86ec0383d45b3339edd0583452d8bc3a0a3cddca", "patch": "@@ -197,11 +197,11 @@ ResolvePathRef::query_compile (HirId ref, TyTy::BaseType *lookup,\n \n \t      Analysis::NodeMapping trait_mappings\n \t\t= trait_item_ref->get_parent_trait_mappings ();\n-\t      auto associated_impl_id\n-\t\t= ctx->get_tyctx ()->lookup_associated_impl_mapping_for_self (\n-\t\t  trait_mappings.get_hirid (), receiver);\n \n-\t      rust_assert (associated_impl_id != UNKNOWN_HIRID);\n+\t      HirId associated_impl_id;\n+\t      ok = ctx->get_tyctx ()->lookup_associated_impl_mapping_for_self (\n+\t\ttrait_mappings.get_hirid (), receiver, &associated_impl_id);\n+\t      rust_assert (ok);\n \n \t      Resolver::AssociatedImplTrait *associated = nullptr;\n \t      bool found_associated_trait_impl"}, {"sha": "f97f701de124c5b339f65eb2ff2165e7b5eb264c", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 28, "deletions": 42, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=86ec0383d45b3339edd0583452d8bc3a0a3cddca", "patch": "@@ -322,12 +322,21 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n       return;\n     }\n \n-  // lookup compiled functions\n+  // address of compiled function\n+  Bexpression *fn_expr = ctx->get_backend ()->error_expression ();\n+\n+  // lookup compiled functions since it may have already been compiled\n   Bfunction *fn = nullptr;\n-  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n+  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n+    {\n+      fn_expr\n+\t= ctx->get_backend ()->function_code_expression (fn, expr.get_locus ());\n+    }\n+  else\n     {\n-      // this might fail because its a forward decl so we can attempt to\n-      // resolve it now\n+      // Now we can try and resolve the address since this might be a forward\n+      // declared function, generic function which has not be compiled yet or\n+      // its an not yet trait bound function\n       HIR::ImplItem *resolved_item = ctx->get_mappings ()->lookup_hir_implitem (\n \texpr.get_mappings ().get_crate_num (), ref, nullptr);\n       if (resolved_item == nullptr)\n@@ -380,16 +389,9 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \t\t  return;\n \t\t}\n \n-\t      CompileTraitItem::Compile (self_type,\n-\t\t\t\t\t trait_item_ref->get_hir_trait_item (),\n-\t\t\t\t\t ctx, fntype);\n-\t      if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n-\t\t{\n-\t\t  translated = ctx->get_backend ()->error_expression ();\n-\t\t  rust_error_at (expr.get_locus (),\n-\t\t\t\t \"forward declaration was not compiled\");\n-\t\t  return;\n-\t\t}\n+\t      fn_expr = CompileTraitItem::Compile (\n+\t\tself_type, trait_item_ref->get_hir_trait_item (), ctx, fntype,\n+\t\ttrue, expr.get_locus ());\n \t    }\n \t  else\n \t    {\n@@ -418,20 +420,13 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \t\t}\n \n \t      if (!fntype->has_subsititions_defined ())\n-\t\tCompileInherentImplItem::Compile (self_type, impl_item, ctx,\n-\t\t\t\t\t\t  true);\n+\t\tfn_expr\n+\t\t  = CompileInherentImplItem::Compile (self_type, impl_item, ctx,\n+\t\t\t\t\t\t      true);\n \t      else\n-\t\tCompileInherentImplItem::Compile (self_type, impl_item, ctx,\n-\t\t\t\t\t\t  true, fntype);\n-\n-\t      if (!ctx->lookup_function_decl (\n-\t\t    impl_item->get_impl_mappings ().get_hirid (), &fn))\n-\t\t{\n-\t\t  translated = ctx->get_backend ()->error_expression ();\n-\t\t  rust_error_at (expr.get_locus (),\n-\t\t\t\t \"forward declaration was not compiled\");\n-\t\t  return;\n-\t\t}\n+\t\tfn_expr\n+\t\t  = CompileInherentImplItem::Compile (self_type, impl_item, ctx,\n+\t\t\t\t\t\t      true, fntype);\n \t    }\n \t}\n       else\n@@ -446,25 +441,16 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \t    }\n \n \t  if (!fntype->has_subsititions_defined ())\n-\t    CompileInherentImplItem::Compile (self_type, resolved_item, ctx,\n-\t\t\t\t\t      true);\n+\t    fn_expr\n+\t      = CompileInherentImplItem::Compile (self_type, resolved_item, ctx,\n+\t\t\t\t\t\t  true);\n \t  else\n-\t    CompileInherentImplItem::Compile (self_type, resolved_item, ctx,\n-\t\t\t\t\t      true, fntype);\n-\n-\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n-\t    {\n-\t      translated = ctx->get_backend ()->error_expression ();\n-\t      rust_error_at (expr.get_locus (),\n-\t\t\t     \"forward declaration was not compiled\");\n-\t      return;\n-\t    }\n+\t    fn_expr\n+\t      = CompileInherentImplItem::Compile (self_type, resolved_item, ctx,\n+\t\t\t\t\t\t  true, fntype);\n \t}\n     }\n \n-  Bexpression *fn_expr\n-    = ctx->get_backend ()->function_code_expression (fn, expr.get_locus ());\n-\n   std::vector<Bexpression *> args;\n \n   // lookup the autoderef mappings"}, {"sha": "a04398e7ef4c6dfab0652433340532bc2ff2fb54", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=86ec0383d45b3339edd0583452d8bc3a0a3cddca", "patch": "@@ -420,6 +420,11 @@ class TypePathSegment\n   const Analysis::NodeMapping &get_mappings () const { return mappings; }\n \n   const PathIdentSegment &get_ident_segment () const { return ident_segment; }\n+\n+  bool is_generic_segment () const\n+  {\n+    return get_type () == SegmentType::GENERIC;\n+  }\n };\n \n // Segment used in type path with generic args"}, {"sha": "71085f675bb834e32941cc446508460dd4fb7ac2", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=86ec0383d45b3339edd0583452d8bc3a0a3cddca", "patch": "@@ -591,7 +591,7 @@ class ResolveItem : public ResolverBase\n \n     // Self is an implicit TypeParam so lets mark it as such\n     resolver->get_type_scope ().append_reference_for_def (\n-      Self.get_id (), implicit_self->get_node_id ());\n+      Self.get_node_id (), implicit_self->get_node_id ());\n \n     if (trait.has_type_param_bounds ())\n       {"}, {"sha": "2dc7fbf10c0a77d113952c4f7c82469e7819c6f1", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 53, "deletions": 43, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=86ec0383d45b3339edd0583452d8bc3a0a3cddca", "patch": "@@ -188,46 +188,11 @@ class ResolveRelativeTypePath : public ResolveTypeToCanonicalPath\n   using ResolveTypeToCanonicalPath::visit;\n \n public:\n-  static NodeId go (AST::TypePath &path, NodeId parent,\n-\t\t    const CanonicalPath &prefix,\n-\t\t    bool canonicalize_type_with_generics)\n-  {\n-    CanonicalPath canonical_path\n-      = ResolveTypeToCanonicalPath::resolve (path,\n-\t\t\t\t\t     canonicalize_type_with_generics,\n-\t\t\t\t\t     true);\n-    if (canonical_path.is_empty ())\n-      {\n-\trust_error_at (path.get_locus (),\n-\t\t       \"Failed to resolve canonical path for TypePath\");\n-\treturn UNKNOWN_NODEID;\n-      }\n-\n-    CanonicalPath lookup = canonical_path;\n-    if (!prefix.is_empty ())\n-      lookup = prefix.append (canonical_path);\n-\n-    auto resolver = Resolver::get ();\n-    NodeId resolved_node = UNKNOWN_NODEID;\n-\n-    // We may need to change how names are resolved, like described in :\n-    // https://github.com/rust-lang/rust/blob/1f94abcda6884893d4723304102089198caa0839/compiler/rustc_resolve/src/lib.rs#L1722\n-    if (!resolver->get_type_scope ().lookup (canonical_path, &resolved_node))\n-      {\n-\trust_error_at (path.get_locus (), \"failed to resolve TypePath: %s\",\n-\t\t       canonical_path.get ().c_str ());\n-\treturn UNKNOWN_NODEID;\n-      }\n-\n-    return resolved_node;\n-  }\n-\n   static NodeId go (AST::QualifiedPathInType &path, NodeId parent,\n-\t\t    const CanonicalPath &prefix,\n \t\t    bool canonicalize_type_with_generics)\n   {\n     auto &qualified_path = path.get_qualified_path_type ();\n-    CanonicalPath result = prefix;\n+    CanonicalPath result = CanonicalPath::create_empty ();\n     if (!resolve_qual_seg (qualified_path, result))\n       return UNKNOWN_NODEID;\n \n@@ -322,12 +287,58 @@ class ResolveType : public ResolverBase\n \n   void visit (AST::TypePath &path) override\n   {\n-    resolved_node\n-      = ResolveRelativeTypePath::go (path, parent,\n-\t\t\t\t     CanonicalPath::create_empty (),\n-\t\t\t\t     canonicalize_type_with_generics);\n-    ok = resolved_node != UNKNOWN_NODEID;\n-    if (ok)\n+    auto canonical_path\n+      = ResolveTypeToCanonicalPath::resolve (path,\n+\t\t\t\t\t     canonicalize_type_with_generics,\n+\t\t\t\t\t     true);\n+    if (canonical_path.is_empty ())\n+      {\n+\trust_error_at (path.get_locus (),\n+\t\t       \"Failed to resolve canonical path for TypePath\");\n+\treturn;\n+      }\n+\n+    ok = !canonical_path.is_empty ();\n+\n+    // lets try and resolve in one go else leave it up to the type resolver to\n+    // figure outer\n+\n+    if (resolver->get_type_scope ().lookup (canonical_path, &resolved_node))\n+      {\n+\tresolver->insert_resolved_type (path.get_node_id (), resolved_node);\n+\tresolver->insert_new_definition (path.get_node_id (),\n+\t\t\t\t\t Definition{path.get_node_id (),\n+\t\t\t\t\t\t    parent});\n+\treturn;\n+      }\n+\n+    // lets resolve as many segments as we can and leave it up to the type\n+    // resolver otherwise\n+    size_t nprocessed = 0;\n+    canonical_path.iterate ([&] (const CanonicalPath &seg) -> bool {\n+      resolved_node = UNKNOWN_NODEID;\n+\n+      if (!resolver->get_type_scope ().lookup (seg, &resolved_node))\n+\treturn false;\n+\n+      resolver->insert_resolved_type (seg.get_node_id (), resolved_node);\n+      resolver->insert_new_definition (seg.get_node_id (),\n+\t\t\t\t       Definition{path.get_node_id (), parent});\n+      nprocessed++;\n+      return true;\n+    });\n+\n+    if (nprocessed == 0)\n+      {\n+\trust_error_at (path.get_locus (), \"failed to resolve TypePath: %s\",\n+\t\t       path.as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    // its ok if this fails since the type resolver sometimes will need to\n+    // investigate the bounds of a type for the associated type for example see:\n+    // https://github.com/Rust-GCC/gccrs/issues/746\n+    if (nprocessed == canonical_path.size ())\n       {\n \tresolver->insert_resolved_type (path.get_node_id (), resolved_node);\n \tresolver->insert_new_definition (path.get_node_id (),\n@@ -340,7 +351,6 @@ class ResolveType : public ResolverBase\n   {\n     resolved_node\n       = ResolveRelativeTypePath::go (path, parent,\n-\t\t\t\t     CanonicalPath::create_empty (),\n \t\t\t\t     canonicalize_type_with_generics);\n     ok = resolved_node != UNKNOWN_NODEID;\n   }"}, {"sha": "0aea8ca669a8a4baf422e7e4fb8115b52fb7ee11", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=86ec0383d45b3339edd0583452d8bc3a0a3cddca", "patch": "@@ -41,6 +41,7 @@ TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n \n       resolve_segments (root_resolved_node_id, expr.get_segments (), 0, root,\n \t\t\texpr.get_mappings (), expr.get_locus ());\n+      return;\n     }\n \n   // Resolve the trait now"}, {"sha": "be53a0d5c3d68e437a42b7e053d59f9a79bee5bd", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=86ec0383d45b3339edd0583452d8bc3a0a3cddca", "patch": "@@ -266,7 +266,7 @@ class TypeCheckTopLevel : public TypeCheckBase\n       {\n \tauto resolved\n \t  = TypeCheckType::Resolve (function.get_return_type ().get ());\n-\tif (resolved == nullptr)\n+\tif (resolved->get_kind () == TyTy::TypeKind::ERROR)\n \t  {\n \t    rust_error_at (function.get_locus (),\n \t\t\t   \"failed to resolve return type\");"}, {"sha": "a4795813a57857c94b48aff3559adb3cacc16a73", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 314, "deletions": 11, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=86ec0383d45b3339edd0583452d8bc3a0a3cddca", "patch": "@@ -28,10 +28,26 @@ TypeCheckType::visit (HIR::TypePath &path)\n   // lookup the Node this resolves to\n   NodeId ref;\n   auto nid = path.get_mappings ().get_nodeid ();\n-  if (!resolver->lookup_resolved_type (nid, &ref))\n+  bool is_fully_resolved = resolver->lookup_resolved_type (nid, &ref);\n+\n+  TyTy::BaseType *lookup = nullptr;\n+  if (!is_fully_resolved)\n     {\n-      rust_fatal_error (path.get_locus (), \"failed to resolve node '%d' to HIR\",\n-\t\t\tnid);\n+      // this can happen so we need to look up the root then resolve the\n+      // remaining segments if possible\n+      size_t offset = 0;\n+      NodeId resolved_node_id = UNKNOWN_NODEID;\n+      TyTy::BaseType *root\n+\t= resolve_root_path (path, &offset, &resolved_node_id);\n+\n+      rust_assert (root != nullptr);\n+      if (root->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn;\n+\n+      translated\n+\t= resolve_segments (resolved_node_id, path.get_mappings ().get_hirid (),\n+\t\t\t    path.get_segments (), offset, root,\n+\t\t\t    path.get_mappings (), path.get_locus ());\n       return;\n     }\n \n@@ -43,7 +59,6 @@ TypeCheckType::visit (HIR::TypePath &path)\n       return;\n     }\n \n-  TyTy::BaseType *lookup = nullptr;\n   if (!context->lookup_type (hir_lookup, &lookup))\n     {\n       rust_error_at (path.get_locus (), \"failed to lookup HIR TyTy\");\n@@ -109,8 +124,12 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n \t&root_resolved_node_id);\n       rust_assert (ok);\n \n-      resolve_segments (root_resolved_node_id, path.get_segments (), 0,\n-\t\t\ttranslated, path.get_mappings (), path.get_locus ());\n+      translated = resolve_segments (root_resolved_node_id,\n+\t\t\t\t     path.get_mappings ().get_hirid (),\n+\t\t\t\t     path.get_segments (), 0, translated,\n+\t\t\t\t     path.get_mappings (), path.get_locus ());\n+\n+      return;\n     }\n \n   // Resolve the trait now\n@@ -207,18 +226,302 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n       return;\n     }\n \n-  resolve_segments (root_resolved_node_id, path.get_segments (), 0, translated,\n-\t\t    path.get_mappings (), path.get_locus ());\n+  translated\n+    = resolve_segments (root_resolved_node_id,\n+\t\t\tpath.get_mappings ().get_hirid (), path.get_segments (),\n+\t\t\t0, translated, path.get_mappings (), path.get_locus ());\n }\n \n-void\n+TyTy::BaseType *\n+TypeCheckType::resolve_root_path (HIR::TypePath &path, size_t *offset,\n+\t\t\t\t  NodeId *root_resolved_node_id)\n+{\n+  TyTy::BaseType *root_tyty = nullptr;\n+  *offset = 0;\n+  for (size_t i = 0; i < path.get_num_segments (); i++)\n+    {\n+      std::unique_ptr<HIR::TypePathSegment> &seg = path.get_segments ().at (i);\n+\n+      bool have_more_segments = (path.get_num_segments () - 1 != i);\n+      bool is_root = *offset == 0;\n+      NodeId ast_node_id = seg->get_mappings ().get_nodeid ();\n+\n+      // then lookup the reference_node_id\n+      NodeId ref_node_id = UNKNOWN_NODEID;\n+      if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+\t{\n+\t  // these ref_node_ids will resolve to a pattern declaration but we\n+\t  // are interested in the definition that this refers to get the\n+\t  // parent id\n+\t  Definition def;\n+\t  if (!resolver->lookup_definition (ref_node_id, &def))\n+\t    {\n+\t      rust_error_at (path.get_locus (),\n+\t\t\t     \"unknown reference for resolved name\");\n+\t      return new TyTy::ErrorType (path.get_mappings ().get_hirid ());\n+\t    }\n+\t  ref_node_id = def.parent;\n+\t}\n+      else\n+\t{\n+\t  resolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n+\t}\n+\n+      // ref_node_id is the NodeId that the segments refers to.\n+      if (ref_node_id == UNKNOWN_NODEID)\n+\t{\n+\t  if (is_root)\n+\t    {\n+\t      rust_error_at (seg->get_locus (),\n+\t\t\t     \"failed to type resolve root segment\");\n+\t      return new TyTy::ErrorType (path.get_mappings ().get_hirid ());\n+\t    }\n+\t  return root_tyty;\n+\t}\n+\n+      // node back to HIR\n+      HirId ref;\n+      if (!mappings->lookup_node_to_hir (path.get_mappings ().get_crate_num (),\n+\t\t\t\t\t ref_node_id, &ref))\n+\t{\n+\t  if (is_root)\n+\t    {\n+\t      rust_error_at (seg->get_locus (), \"789 reverse lookup failure\");\n+\t      rust_debug_loc (\n+\t\tseg->get_locus (),\n+\t\t\"failure with [%s] mappings [%s] ref_node_id [%u]\",\n+\t\tseg->as_string ().c_str (),\n+\t\tseg->get_mappings ().as_string ().c_str (), ref_node_id);\n+\n+\t      return new TyTy::ErrorType (path.get_mappings ().get_hirid ());\n+\t    }\n+\n+\t  return root_tyty;\n+\t}\n+\n+      auto seg_is_module\n+\t= (nullptr\n+\t   != mappings->lookup_module (path.get_mappings ().get_crate_num (),\n+\t\t\t\t       ref));\n+\n+      if (seg_is_module)\n+\t{\n+\t  // A::B::C::this_is_a_module::D::E::F\n+\t  //          ^^^^^^^^^^^^^^^^\n+\t  //          Currently handling this.\n+\t  if (have_more_segments)\n+\t    {\n+\t      (*offset)++;\n+\t      continue;\n+\t    }\n+\n+\t  // In the case of :\n+\t  // A::B::C::this_is_a_module\n+\t  //          ^^^^^^^^^^^^^^^^\n+\t  // This is an error, we are not expecting a module.\n+\t  rust_error_at (seg->get_locus (), \"expected value\");\n+\t  return new TyTy::ErrorType (path.get_mappings ().get_hirid ());\n+\t}\n+\n+      TyTy::BaseType *lookup = nullptr;\n+      if (!context->lookup_type (ref, &lookup))\n+\t{\n+\t  if (is_root)\n+\t    {\n+\t      rust_error_at (seg->get_locus (),\n+\t\t\t     \"failed to resolve root segment\");\n+\t      return new TyTy::ErrorType (path.get_mappings ().get_hirid ());\n+\t    }\n+\t  return root_tyty;\n+\t}\n+\n+      // if we have a previous segment type\n+      if (root_tyty != nullptr)\n+\t{\n+\t  // if this next segment needs substitution we must apply the\n+\t  // previous type arguments\n+\t  //\n+\t  // such as: GenericStruct::<_>::new(123, 456)\n+\t  if (lookup->needs_generic_substitutions ())\n+\t    {\n+\t      if (!root_tyty->needs_generic_substitutions ())\n+\t\t{\n+\t\t  auto used_args_in_prev_segment\n+\t\t    = GetUsedSubstArgs::From (root_tyty);\n+\t\t  lookup\n+\t\t    = SubstMapperInternal::Resolve (lookup,\n+\t\t\t\t\t\t    used_args_in_prev_segment);\n+\t\t}\n+\t    }\n+\t}\n+\n+      // turbo-fish segment path::<ty>\n+      if (seg->is_generic_segment ())\n+\t{\n+\t  HIR::TypePathSegmentGeneric *generic_segment\n+\t    = static_cast<HIR::TypePathSegmentGeneric *> (seg.get ());\n+\n+\t  if (!lookup->can_substitute ())\n+\t    {\n+\t      rust_error_at (seg->get_locus (),\n+\t\t\t     \"substitutions not supported for %s\",\n+\t\t\t     lookup->as_string ().c_str ());\n+\t      return new TyTy::ErrorType (lookup->get_ref ());\n+\t    }\n+\t  lookup = SubstMapper::Resolve (lookup, path.get_locus (),\n+\t\t\t\t\t &generic_segment->get_generic_args ());\n+\t}\n+\n+      *root_resolved_node_id = ref_node_id;\n+      *offset = *offset + 1;\n+      root_tyty = lookup;\n+    }\n+\n+  return root_tyty;\n+}\n+\n+TyTy::BaseType *\n TypeCheckType::resolve_segments (\n-  NodeId root_resolved_node_id,\n+  NodeId root_resolved_node_id, HirId expr_id,\n   std::vector<std::unique_ptr<HIR::TypePathSegment>> &segments, size_t offset,\n   TyTy::BaseType *tyseg, const Analysis::NodeMapping &expr_mappings,\n   Location expr_locus)\n {\n-  gcc_unreachable ();\n+  NodeId resolved_node_id = root_resolved_node_id;\n+  TyTy::BaseType *prev_segment = tyseg;\n+  for (size_t i = offset; i < segments.size (); i++)\n+    {\n+      std::unique_ptr<HIR::TypePathSegment> &seg = segments.at (i);\n+\n+      bool reciever_is_generic\n+\t= prev_segment->get_kind () == TyTy::TypeKind::PARAM;\n+      bool probe_bounds = true;\n+      bool probe_impls = !reciever_is_generic;\n+      bool ignore_mandatory_trait_items = !reciever_is_generic;\n+\n+      // probe the path is done in two parts one where we search impls if no\n+      // candidate is found then we search extensions from traits\n+      auto candidates\n+\t= PathProbeType::Probe (prev_segment, seg->get_ident_segment (),\n+\t\t\t\tprobe_impls, false,\n+\t\t\t\tignore_mandatory_trait_items);\n+      if (candidates.size () == 0)\n+\t{\n+\t  candidates\n+\t    = PathProbeType::Probe (prev_segment, seg->get_ident_segment (),\n+\t\t\t\t    false, probe_bounds,\n+\t\t\t\t    ignore_mandatory_trait_items);\n+\n+\t  if (candidates.size () == 0)\n+\t    {\n+\t      rust_error_at (\n+\t\tseg->get_locus (),\n+\t\t\"failed to resolve path segment using an impl Probe\");\n+\t      return new TyTy::ErrorType (expr_id);\n+\t    }\n+\t}\n+\n+      if (candidates.size () > 1)\n+\t{\n+\t  ReportMultipleCandidateError::Report (candidates,\n+\t\t\t\t\t\tseg->get_ident_segment (),\n+\t\t\t\t\t\tseg->get_locus ());\n+\t  return new TyTy::ErrorType (expr_id);\n+\t}\n+\n+      auto &candidate = candidates.at (0);\n+      prev_segment = tyseg;\n+      tyseg = candidate.ty;\n+\n+      if (candidate.is_impl_candidate ())\n+\t{\n+\t  resolved_node_id\n+\t    = candidate.item.impl.impl_item->get_impl_mappings ().get_nodeid ();\n+\t}\n+      else\n+\t{\n+\t  resolved_node_id\n+\t    = candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n+\n+\t  // lookup the associated-impl-trait\n+\t  HIR::ImplBlock *impl = candidate.item.trait.impl;\n+\t  if (impl != nullptr)\n+\t    {\n+\t      AssociatedImplTrait *lookup_associated = nullptr;\n+\t      bool found_impl_trait = context->lookup_associated_trait_impl (\n+\t\timpl->get_mappings ().get_hirid (), &lookup_associated);\n+\t      rust_assert (found_impl_trait);\n+\n+\t      lookup_associated->setup_associated_types ();\n+\n+\t      // we need a new ty_ref_id for this trait item\n+\t      tyseg = tyseg->clone ();\n+\t      tyseg->set_ty_ref (mappings->get_next_hir_id ());\n+\t    }\n+\t}\n+\n+      if (seg->is_generic_segment ())\n+\t{\n+\t  HIR::TypePathSegmentGeneric *generic_segment\n+\t    = static_cast<HIR::TypePathSegmentGeneric *> (seg.get ());\n+\n+\t  if (!tyseg->can_substitute ())\n+\t    {\n+\t      rust_error_at (expr_locus, \"substitutions not supported for %s\",\n+\t\t\t     tyseg->as_string ().c_str ());\n+\t      return new TyTy::ErrorType (expr_id);\n+\t    }\n+\n+\t  tyseg = SubstMapper::Resolve (tyseg, expr_locus,\n+\t\t\t\t\t&generic_segment->get_generic_args ());\n+\t  if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\t    return new TyTy::ErrorType (expr_id);\n+\t}\n+    }\n+\n+  context->insert_receiver (expr_mappings.get_hirid (), prev_segment);\n+  if (tyseg->needs_generic_substitutions ())\n+    {\n+      Location locus = segments.back ()->get_locus ();\n+      if (!prev_segment->needs_generic_substitutions ())\n+\t{\n+\t  auto used_args_in_prev_segment\n+\t    = GetUsedSubstArgs::From (prev_segment);\n+\t  if (!used_args_in_prev_segment.is_error ())\n+\t    tyseg\n+\t      = SubstMapperInternal::Resolve (tyseg, used_args_in_prev_segment);\n+\t}\n+      else\n+\t{\n+\t  tyseg = SubstMapper::InferSubst (tyseg, locus);\n+\t}\n+\n+      if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn new TyTy::ErrorType (expr_id);\n+    }\n+\n+  rust_assert (resolved_node_id != UNKNOWN_NODEID);\n+\n+  // lookup if the name resolver was able to canonically resolve this or not\n+  NodeId path_resolved_id = UNKNOWN_NODEID;\n+  if (resolver->lookup_resolved_name (expr_mappings.get_nodeid (),\n+\t\t\t\t      &path_resolved_id))\n+    {\n+      rust_assert (path_resolved_id == resolved_node_id);\n+    }\n+  // check the type scope\n+  else if (resolver->lookup_resolved_type (expr_mappings.get_nodeid (),\n+\t\t\t\t\t   &path_resolved_id))\n+    {\n+      rust_assert (path_resolved_id == resolved_node_id);\n+    }\n+  else\n+    {\n+      resolver->insert_resolved_name (expr_mappings.get_nodeid (),\n+\t\t\t\t      resolved_node_id);\n+    }\n+\n+  return tyseg;\n }\n \n void"}, {"sha": "e0c0e91063295f504963786c021d9111e27dd161", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=86ec0383d45b3339edd0583452d8bc3a0a3cddca", "patch": "@@ -185,8 +185,11 @@ class TypeCheckType : public TypeCheckBase\n       }\n   }\n \n-  void resolve_segments (\n-    NodeId root_resolved_node_id,\n+  TyTy::BaseType *resolve_root_path (HIR::TypePath &path, size_t *offset,\n+\t\t\t\t     NodeId *root_resolved_node_id);\n+\n+  TyTy::BaseType *resolve_segments (\n+    NodeId root_resolved_node_id, HirId expr_id,\n     std::vector<std::unique_ptr<HIR::TypePathSegment>> &segments, size_t offset,\n     TyTy::BaseType *tyseg, const Analysis::NodeMapping &expr_mappings,\n     Location expr_locus);"}, {"sha": "d3dc4c997c08ad4d59bef8ea9c5290eb0e9e5d49", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=86ec0383d45b3339edd0583452d8bc3a0a3cddca", "patch": "@@ -144,16 +144,24 @@ class TypeCheckContext\n \n   void clear_associated_type_mapping (HirId id)\n   {\n-    associated_type_mappings[id] = UNKNOWN_HIRID;\n+    auto it = associated_type_mappings.find (id);\n+    rust_assert (it != associated_type_mappings.end ());\n+    associated_type_mappings.erase (it);\n   }\n \n-  HirId lookup_associated_type_mapping (HirId id, HirId default_value)\n+  // lookup any associated type mappings, the out parameter of mapping is\n+  // allowed to be nullptr which allows this interface to do a simple does exist\n+  // check\n+  bool lookup_associated_type_mapping (HirId id, HirId *mapping)\n   {\n     auto it = associated_type_mappings.find (id);\n     if (it == associated_type_mappings.end ())\n-      return default_value;\n+      return false;\n+\n+    if (mapping != nullptr)\n+      *mapping = it->second;\n \n-    return it->second;\n+    return true;\n   }\n \n   void insert_associated_impl_mapping (HirId trait_id,\n@@ -169,19 +177,23 @@ class TypeCheckContext\n     associated_traits_to_impls[trait_id].push_back ({impl_type, impl_id});\n   }\n \n-  HirId lookup_associated_impl_mapping_for_self (HirId trait_id,\n-\t\t\t\t\t\t const TyTy::BaseType *self)\n+  bool lookup_associated_impl_mapping_for_self (HirId trait_id,\n+\t\t\t\t\t\tconst TyTy::BaseType *self,\n+\t\t\t\t\t\tHirId *mapping)\n   {\n     auto it = associated_traits_to_impls.find (trait_id);\n     if (it == associated_traits_to_impls.end ())\n-      return UNKNOWN_HIRID;\n+      return false;\n \n     for (auto &item : it->second)\n       {\n \tif (item.first->can_eq (self, false))\n-\t  return item.second;\n+\t  {\n+\t    *mapping = item.second;\n+\t    return true;\n+\t  }\n       }\n-    return UNKNOWN_HIRID;\n+    return false;\n   }\n \n   void insert_autoderef_mappings (HirId id,"}, {"sha": "f2216f9fada6e9e68fdf6b07e6e2ad6d197eeee7", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 39, "deletions": 16, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=86ec0383d45b3339edd0583452d8bc3a0a3cddca", "patch": "@@ -108,6 +108,9 @@ void\n BaseType::inherit_bounds (\n   const std::vector<TyTy::TypeBoundPredicate> &specified_bounds)\n {\n+  // FIXME\n+  // 1. This needs to union the bounds\n+  // 2. Do some checking for trait polarity to ensure compatibility\n   for (auto &bound : specified_bounds)\n     {\n       add_bound (bound);\n@@ -328,6 +331,30 @@ StructFieldType::clone () const\n \t\t\t      get_field_type ()->clone ());\n }\n \n+void\n+SubstitutionParamMapping::fill_param_ty (BaseType &type, Location locus)\n+{\n+  if (type.get_kind () == TyTy::TypeKind::INFER)\n+    {\n+      type.inherit_bounds (*param);\n+    }\n+  else\n+    {\n+      if (!param->bounds_compatible (type, locus, true))\n+\treturn;\n+    }\n+\n+  if (type.get_kind () == TypeKind::PARAM)\n+    {\n+      delete param;\n+      param = static_cast<ParamType *> (type.clone ());\n+    }\n+  else\n+    {\n+      param->set_ty_ref (type.get_ref ());\n+    }\n+}\n+\n void\n SubstitutionParamMapping::override_context ()\n {\n@@ -357,7 +384,9 @@ SubstitutionRef::get_mappings_from_generic_args (HIR::GenericArgs &args)\n       return SubstitutionArgumentMappings::error ();\n     }\n \n-  if (args.get_type_args ().size () > substitutions.size ())\n+  // for inherited arguments\n+  size_t offs = used_arguments.size ();\n+  if (args.get_type_args ().size () + offs > substitutions.size ())\n     {\n       RichLocation r (args.get_locus ());\n       r.add_range (substitutions.front ().get_param_locus ());\n@@ -369,7 +398,7 @@ SubstitutionRef::get_mappings_from_generic_args (HIR::GenericArgs &args)\n       return SubstitutionArgumentMappings::error ();\n     }\n \n-  if (args.get_type_args ().size () < min_required_substitutions ())\n+  if (args.get_type_args ().size () + offs < min_required_substitutions ())\n     {\n       RichLocation r (args.get_locus ());\n       r.add_range (substitutions.front ().get_param_locus ());\n@@ -381,9 +410,6 @@ SubstitutionRef::get_mappings_from_generic_args (HIR::GenericArgs &args)\n       return SubstitutionArgumentMappings::error ();\n     }\n \n-  // for inherited arguments\n-  size_t offs = used_arguments.size ();\n-\n   std::vector<SubstitutionArg> mappings;\n   for (auto &arg : args.get_type_args ())\n     {\n@@ -643,7 +669,7 @@ ADTType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n       bool ok\n \t= subst_mappings.get_argument_for_symbol (sub.get_param_ty (), &arg);\n       if (ok)\n-\tsub.fill_param_ty (arg.get_tyty (), subst_mappings.get_locus ());\n+\tsub.fill_param_ty (*arg.get_tyty (), subst_mappings.get_locus ());\n     }\n \n   adt->iterate_fields ([&] (StructFieldType *field) mutable -> bool {\n@@ -924,7 +950,7 @@ FnType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n \t= subst_mappings.get_argument_for_symbol (sub.get_param_ty (), &arg);\n       if (ok)\n \t{\n-\t  sub.fill_param_ty (arg.get_tyty (), subst_mappings.get_locus ());\n+\t  sub.fill_param_ty (*arg.get_tyty (), subst_mappings.get_locus ());\n \t}\n     }\n \n@@ -2174,22 +2200,19 @@ bool\n PlaceholderType::can_resolve () const\n {\n   auto context = Resolver::TypeCheckContext::get ();\n-  HirId val\n-    = context->lookup_associated_type_mapping (get_ty_ref (), UNKNOWN_HIRID);\n-  return val != UNKNOWN_HIRID;\n+  return context->lookup_associated_type_mapping (get_ty_ref (), nullptr);\n }\n \n BaseType *\n PlaceholderType::resolve () const\n {\n   auto context = Resolver::TypeCheckContext::get ();\n \n-  rust_assert (can_resolve ());\n-  HirId val\n-    = context->lookup_associated_type_mapping (get_ty_ref (), UNKNOWN_HIRID);\n-  rust_assert (val != UNKNOWN_HIRID);\n+  HirId mapping;\n+  bool ok = context->lookup_associated_type_mapping (get_ty_ref (), &mapping);\n+  rust_assert (ok);\n \n-  return TyVar (val).get_tyty ();\n+  return TyVar (mapping).get_tyty ();\n }\n \n bool\n@@ -2275,7 +2298,7 @@ ProjectionType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n       bool ok\n \t= subst_mappings.get_argument_for_symbol (sub.get_param_ty (), &arg);\n       if (ok)\n-\tsub.fill_param_ty (arg.get_tyty (), subst_mappings.get_locus ());\n+\tsub.fill_param_ty (*arg.get_tyty (), subst_mappings.get_locus ());\n     }\n \n   auto fty = projection->base;"}, {"sha": "054e3274c0e8de28de25cace39a11edefe389918", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=86ec0383d45b3339edd0583452d8bc3a0a3cddca", "patch": "@@ -626,28 +626,7 @@ class SubstitutionParamMapping\n \n   std::string as_string () const { return param->as_string (); }\n \n-  void fill_param_ty (BaseType *type, Location locus)\n-  {\n-    if (type->get_kind () == TyTy::TypeKind::INFER)\n-      {\n-\ttype->inherit_bounds (*param);\n-      }\n-    else\n-      {\n-\tif (!param->bounds_compatible (*type, locus, true))\n-\t  return;\n-      }\n-\n-    if (type->get_kind () == TypeKind::PARAM)\n-      {\n-\tdelete param;\n-\tparam = static_cast<ParamType *> (type->clone ());\n-      }\n-    else\n-      {\n-\tparam->set_ty_ref (type->get_ref ());\n-      }\n-  }\n+  void fill_param_ty (BaseType &type, Location locus);\n \n   SubstitutionParamMapping clone () const\n   {"}, {"sha": "6b4bfa188c0665647dd83d566bd526b9092011a1", "filename": "gcc/rust/util/rust-canonical-path.h", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Futil%2Frust-canonical-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Frust%2Futil%2Frust-canonical-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-canonical-path.h?ref=86ec0383d45b3339edd0583452d8bc3a0a3cddca", "patch": "@@ -95,7 +95,12 @@ class CanonicalPath\n   }\n \n   // if we have the path A::B::C this will give a callback for each segment\n-  // example:\n+  // including the prefix, example:\n+  //\n+  // path:\n+  //   A::B::C\n+  //\n+  // iterate:\n   //   A\n   //   A::B\n   //   A::B::C\n@@ -110,6 +115,16 @@ class CanonicalPath\n       }\n   }\n \n+  // if we have the path A::B::C this will give a callback for each segment\n+  // example:\n+  //\n+  // path:\n+  //   A::B::C\n+  //\n+  // iterate:\n+  //   A\n+  //      B\n+  //         C\n   void iterate_segs (std::function<bool (const CanonicalPath &)> cb) const\n   {\n     for (auto &seg : segs)\n@@ -123,7 +138,7 @@ class CanonicalPath\n \n   size_t size () const { return segs.size (); }\n \n-  NodeId get_id () const\n+  NodeId get_node_id () const\n   {\n     rust_assert (!segs.empty ());\n     return segs.back ().first;"}, {"sha": "0a132bf5d6bf2c51314fbacd49419617b8642132", "filename": "gcc/testsuite/rust/compile/generic-default1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgeneric-default1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgeneric-default1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgeneric-default1.rs?ref=86ec0383d45b3339edd0583452d8bc3a0a3cddca", "patch": "@@ -1,5 +1,3 @@\n-// { dg-error \"unresolved type\" \"\" { target *-*-* } 0 }\n-\n struct Foo<A = i321>(A);\n // { dg-error \"failed to resolve TypePath: i321\" \"\" { target *-*-* } .-1 }\n "}, {"sha": "6c847b5a29b5ed57cac2a2cfe1bfbbe19c863e6f", "filename": "gcc/testsuite/rust/compile/generics5.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics5.rs?ref=86ec0383d45b3339edd0583452d8bc3a0a3cddca", "patch": "@@ -1,12 +1,9 @@\n-// Current errors are too noisy to match specific ones.\n-// { dg-error \"failed to resolve TypePath: T\" \"\" { target *-*-* } 0 }\n-// { dg-error \"unresolved type\" \"\" { target *-*-* } 0 }\n-\n struct GenericStruct<T>(T, usize);\n \n fn main() {\n     let a2;\n     a2 = GenericStruct::<i8, T>(1, 456);\n+    // { dg-error \"failed to resolve TypePath: T\" \"\" { target *-*-* } .-1 }\n \n     let b2: i32 = a2.0;\n     let c2: usize = a2.1;"}, {"sha": "3766703431eca114b84bac2a8e5e80123202fdbb", "filename": "gcc/testsuite/rust/compile/generics9.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics9.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics9.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics9.rs?ref=86ec0383d45b3339edd0583452d8bc3a0a3cddca", "patch": "@@ -1,6 +1,5 @@\n struct Foo<A, B = (A, B)>(A, B);\n // { dg-error \"failed to resolve TypePath: B\" \"\" { target *-*-* } .-1 }\n-// { dg-error \"unresolved type\" \"\" { target *-*-* } .-2 }\n \n fn main() {\n     let a: Foo<bool>;"}, {"sha": "c8699f77c6ab55d418bf638601f3bad06d5cbd05", "filename": "gcc/testsuite/rust/compile/method2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmethod2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ec0383d45b3339edd0583452d8bc3a0a3cddca/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmethod2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmethod2.rs?ref=86ec0383d45b3339edd0583452d8bc3a0a3cddca", "patch": "@@ -13,5 +13,4 @@ fn main() {\n     let b;\n     b = a.test::<asfasfr>(false);\n     // { dg-error \"failed to resolve TypePath: asfasfr\" \"\" { target *-*-* } .-1 }\n-    // { dg-error \"unresolved type\" \"\" { target *-*-* } .-2 }\n }"}]}