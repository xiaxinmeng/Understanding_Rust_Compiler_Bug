{"sha": "2cee58d81076c99ab3db3305c1850bf79fa12f17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNlZTU4ZDgxMDc2Yzk5YWIzZGIzMzA1YzE4NTBiZjc5ZmExMmYxNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-12-16T10:34:27Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-12-16T10:34:27Z"}, "message": "[Ada] Fully propagate representation aspects through renaming\n\n2019-12-16  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* sem_ch8.adb (Analyze_Object_Renaming): Set Atomic, Independent\n\tand Volatile_Full_Access aspects on the entity of the renaming\n\tthe same way as the Volatile aspect is set.\n\t* sem_util.ads (Is_Atomic_Object_Entity): Move declaration to...\n\t(Is_Independent_Object): New function.\n\t(Is_Volatile_Full_Access_Object): Likewise.\n\t* sem_util.adb (Is_Atomic_Object_Entity): ...here.\n\t(Prefix_Has_Atomic_Components): Minor tweak.\n\t(Is_Atomic_Object): Test Is_Atomic on the Etype uniformly.\n\t(Is_Atomic_Or_VFA_Object): Call Is_Volatile_Full_Access_Object.\n\t(Is_Independent_Object): New predicate.\n\t(Is_Subcomponent_Of_Atomic_Object): Remove redundant test.\n\t(Is_Volatile_Full_Access_Object): New predicate.\n\t(Is_Volatile_Prefix): Rename into...\n\t(Prefix_Has_Volatile_Components): ... and call\n\tIs_Volatile_Object.\n\t(Object_Has_Volatile_Components): Delete.\n\t(Is_Volatile_Object): Simplify.\n\t* gcc-interface/trans.c (node_is_volatile_full_access): Adjust\n\tcomment.\n\nFrom-SVN: r279429", "tree": {"sha": "0161b2c951d4dd1cdd64eee3a940052271d687ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0161b2c951d4dd1cdd64eee3a940052271d687ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2cee58d81076c99ab3db3305c1850bf79fa12f17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cee58d81076c99ab3db3305c1850bf79fa12f17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cee58d81076c99ab3db3305c1850bf79fa12f17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cee58d81076c99ab3db3305c1850bf79fa12f17/comments", "author": null, "committer": null, "parents": [{"sha": "0bba838d7f4e9b851416d463d077b28aff0b561f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bba838d7f4e9b851416d463d077b28aff0b561f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bba838d7f4e9b851416d463d077b28aff0b561f"}], "stats": {"total": 350, "additions": 216, "deletions": 134}, "files": [{"sha": "a3832b8234dab70db0a5b782eb41727f59bcab59", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cee58d81076c99ab3db3305c1850bf79fa12f17/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cee58d81076c99ab3db3305c1850bf79fa12f17/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2cee58d81076c99ab3db3305c1850bf79fa12f17", "patch": "@@ -1,3 +1,26 @@\n+2019-12-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_ch8.adb (Analyze_Object_Renaming): Set Atomic, Independent\n+\tand Volatile_Full_Access aspects on the entity of the renaming\n+\tthe same way as the Volatile aspect is set.\n+\t* sem_util.ads (Is_Atomic_Object_Entity): Move declaration to...\n+\t(Is_Independent_Object): New function.\n+\t(Is_Volatile_Full_Access_Object): Likewise.\n+\t* sem_util.adb (Is_Atomic_Object_Entity): ...here.\n+\t(Prefix_Has_Atomic_Components): Minor tweak.\n+\t(Is_Atomic_Object): Test Is_Atomic on the Etype uniformly.\n+\t(Is_Atomic_Or_VFA_Object): Call Is_Volatile_Full_Access_Object.\n+\t(Is_Independent_Object): New predicate.\n+\t(Is_Subcomponent_Of_Atomic_Object): Remove redundant test.\n+\t(Is_Volatile_Full_Access_Object): New predicate.\n+\t(Is_Volatile_Prefix): Rename into...\n+\t(Prefix_Has_Volatile_Components): ... and call\n+\tIs_Volatile_Object.\n+\t(Object_Has_Volatile_Components): Delete.\n+\t(Is_Volatile_Object): Simplify.\n+\t* gcc-interface/trans.c (node_is_volatile_full_access): Adjust\n+\tcomment.\n+\n 2019-12-16  Bob Duff  <duff@adacore.com>\n \n \t* par.adb: Add Scopes function to do range checking on the scope"}, {"sha": "e6914cc470c03513fdd4a45c6760d70bea3ba0c0", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cee58d81076c99ab3db3305c1850bf79fa12f17/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cee58d81076c99ab3db3305c1850bf79fa12f17/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=2cee58d81076c99ab3db3305c1850bf79fa12f17", "patch": "@@ -4835,8 +4835,8 @@ node_is_atomic (Node_Id gnat_node)\n }\n \n /* Return true if GNAT_NODE references a Volatile_Full_Access entity.  This is\n-   modeled on the Is_VFA_Object predicate of the front-end, but additionally\n-   handles explicit dereferences.  */\n+   modeled on the Is_Volatile_Full_Access_Object predicate of the front-end,\n+   but additionally handles explicit dereferences.  */\n \n static bool\n node_is_volatile_full_access (Node_Id gnat_node)"}, {"sha": "a1a5274d078c19e2043203622f2c1ebc986a22c4", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cee58d81076c99ab3db3305c1850bf79fa12f17/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cee58d81076c99ab3db3305c1850bf79fa12f17/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=2cee58d81076c99ab3db3305c1850bf79fa12f17", "patch": "@@ -1358,19 +1358,13 @@ package body Sem_Ch8 is\n       end if;\n \n       --  The entity of the renaming declaration needs to reflect whether the\n-      --  renamed object is volatile. Is_Volatile is set if the renamed object\n-      --  is volatile in the RM legality sense.\n+      --  renamed object is atomic, independent, volatile or VFA. These flags\n+      --  are set on the renamed object in the RM legality sense.\n \n-      Set_Is_Volatile (Id, Is_Volatile_Object (Nam));\n-\n-      --  Also copy settings of Atomic/Independent/Volatile_Full_Access\n-\n-      if Is_Entity_Name (Nam) then\n-         Set_Is_Atomic               (Id, Is_Atomic      (Entity (Nam)));\n-         Set_Is_Independent          (Id, Is_Independent (Entity (Nam)));\n-         Set_Is_Volatile_Full_Access (Id,\n-           Is_Volatile_Full_Access (Entity (Nam)));\n-      end if;\n+      Set_Is_Atomic               (Id, Is_Atomic_Object (Nam));\n+      Set_Is_Independent          (Id, Is_Independent_Object (Nam));\n+      Set_Is_Volatile             (Id, Is_Volatile_Object (Nam));\n+      Set_Is_Volatile_Full_Access (Id, Is_Volatile_Full_Access_Object (Nam));\n \n       --  Treat as volatile if we just set the Volatile flag\n "}, {"sha": "e1703e995f11d8bc31cd1fa02a1a484904e90118", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 171, "deletions": 110, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cee58d81076c99ab3db3305c1850bf79fa12f17/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cee58d81076c99ab3db3305c1850bf79fa12f17/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=2cee58d81076c99ab3db3305c1850bf79fa12f17", "patch": "@@ -122,6 +122,10 @@ package body Sem_Util is\n    --  T is a derived tagged type. Check whether the type extension is null.\n    --  If the parent type is fully initialized, T can be treated as such.\n \n+   function Is_Atomic_Object_Entity (Id : Entity_Id) return Boolean;\n+   --  Determine whether arbitrary entity Id denotes an atomic object as per\n+   --  RM C.6(7).\n+\n    function Is_Fully_Initialized_Variant (Typ : Entity_Id) return Boolean;\n    --  Subsidiary to Is_Fully_Initialized_Type. For an unconstrained type\n    --  with discriminants whose default values are static, examine only the\n@@ -13724,16 +13728,16 @@ package body Sem_Util is\n    ----------------------\n \n    function Is_Atomic_Object (N : Node_Id) return Boolean is\n-      function Prefix_Has_Atomic_Components (Pref : Node_Id) return Boolean;\n-      --  Determine whether prefix Pref of an indexed component has atomic\n-      --  components.\n+      function Prefix_Has_Atomic_Components (P : Node_Id) return Boolean;\n+      --  Determine whether prefix P has atomic components. This requires the\n+      --  presence of an Atomic_Components aspect/pragma.\n \n       ---------------------------------\n       -- Prefix_Has_Atomic_Components --\n       ---------------------------------\n \n-      function Prefix_Has_Atomic_Components (Pref : Node_Id) return Boolean is\n-         Typ : constant Entity_Id := Etype (Pref);\n+      function Prefix_Has_Atomic_Components (P : Node_Id) return Boolean is\n+         Typ : constant Entity_Id := Etype (P);\n \n       begin\n          if Is_Access_Type (Typ) then\n@@ -13742,8 +13746,8 @@ package body Sem_Util is\n          elsif Has_Atomic_Components (Typ) then\n             return True;\n \n-         elsif Is_Entity_Name (Pref)\n-           and then Has_Atomic_Components (Entity (Pref))\n+         elsif Is_Entity_Name (P)\n+           and then Has_Atomic_Components (Entity (P))\n          then\n             return True;\n \n@@ -13758,18 +13762,18 @@ package body Sem_Util is\n       if Is_Entity_Name (N) then\n          return Is_Atomic_Object_Entity (Entity (N));\n \n+      elsif Is_Atomic (Etype (N)) then\n+         return True;\n+\n       elsif Nkind (N) = N_Indexed_Component then\n-         return\n-           Is_Atomic (Etype (N))\n-             or else Prefix_Has_Atomic_Components (Prefix (N));\n+         return Prefix_Has_Atomic_Components (Prefix (N));\n \n       elsif Nkind (N) = N_Selected_Component then\n-         return\n-           Is_Atomic (Etype (N))\n-             or else Is_Atomic (Entity (Selector_Name (N)));\n-      end if;\n+         return Is_Atomic (Entity (Selector_Name (N)));\n \n-      return False;\n+      else\n+         return False;\n+      end if;\n    end Is_Atomic_Object;\n \n    -----------------------------\n@@ -13788,50 +13792,8 @@ package body Sem_Util is\n    -----------------------------\n \n    function Is_Atomic_Or_VFA_Object (N : Node_Id) return Boolean is\n-      function Is_VFA_Object (N : Node_Id) return Boolean;\n-      --  Determine whether arbitrary node N denotes a reference to an object\n-      --  that is Volatile_Full_Access. Modeled on Is_Atomic_Object above.\n-\n-      function Is_VFA_Object_Entity (Id : Entity_Id) return Boolean;\n-      --  Determine whether arbitrary entity Id denotes an object that is\n-      --  Volatile_Full_Access. Modeled on Is_Atomic_Object_Entity above.\n-\n-      ---------------------\n-      --  Is_VFA_Object  --\n-      ---------------------\n-\n-      function Is_VFA_Object (N : Node_Id) return Boolean is\n-      begin\n-         if Is_Entity_Name (N) then\n-            return Is_VFA_Object_Entity (Entity (N));\n-\n-         elsif Nkind (N) = N_Indexed_Component then\n-            return Is_Volatile_Full_Access (Etype (N));\n-\n-         elsif Nkind (N) = N_Selected_Component then\n-            return\n-              Is_Volatile_Full_Access (Etype (N))\n-                or else Is_Volatile_Full_Access (Entity (Selector_Name (N)));\n-         end if;\n-\n-         return False;\n-      end Is_VFA_Object;\n-\n-      ----------------------------\n-      --  Is_VFA_Object_Entity  --\n-      ----------------------------\n-\n-      function Is_VFA_Object_Entity (Id : Entity_Id) return Boolean is\n-      begin\n-         return\n-           Is_Object (Id)\n-             and then (Is_Volatile_Full_Access (Id)\n-                         or else\n-                       Is_Volatile_Full_Access (Etype (Id)));\n-      end Is_VFA_Object_Entity;\n-\n    begin\n-      return Is_Atomic_Object (N) or else Is_VFA_Object (N);\n+      return Is_Atomic_Object (N) or else Is_Volatile_Full_Access_Object (N);\n    end Is_Atomic_Or_VFA_Object;\n \n    ----------------------\n@@ -15479,6 +15441,78 @@ package body Sem_Util is\n                              N_Generic_Subprogram_Declaration);\n    end Is_Generic_Declaration_Or_Body;\n \n+   ---------------------------\n+   -- Is_Independent_Object --\n+   ---------------------------\n+\n+   function Is_Independent_Object (N : Node_Id) return Boolean is\n+      function Is_Independent_Object_Entity (Id : Entity_Id) return Boolean;\n+      --  Determine whether arbitrary entity Id denotes an object that is\n+      --  Independent.\n+\n+      function Prefix_Has_Independent_Components (P : Node_Id) return Boolean;\n+      --  Determine whether prefix P has independent components. This requires\n+      --  the presence of an Independent_Components aspect/pragma.\n+\n+      ------------------------------------\n+      --  Is_Independent_Object_Entity  --\n+      ------------------------------------\n+\n+      function Is_Independent_Object_Entity (Id : Entity_Id) return Boolean is\n+      begin\n+         return\n+           Is_Object (Id)\n+             and then (Is_Independent (Id)\n+                        or else\n+                      Is_Independent (Etype (Id)));\n+      end Is_Independent_Object_Entity;\n+\n+      -------------------------------------\n+      -- Prefix_Has_Independent_Components --\n+      -------------------------------------\n+\n+      function Prefix_Has_Independent_Components (P : Node_Id) return Boolean\n+      is\n+         Typ : constant Entity_Id := Etype (P);\n+\n+      begin\n+         if Is_Access_Type (Typ) then\n+            return Has_Independent_Components (Designated_Type (Typ));\n+\n+         elsif Has_Independent_Components (Typ) then\n+            return True;\n+\n+         elsif Is_Entity_Name (P)\n+           and then Has_Independent_Components (Entity (P))\n+         then\n+            return True;\n+\n+         else\n+            return False;\n+         end if;\n+      end Prefix_Has_Independent_Components;\n+\n+   --  Start of processing for Is_Independent_Object\n+\n+   begin\n+      if Is_Entity_Name (N) then\n+         return Is_Independent_Object_Entity (Entity (N));\n+\n+      elsif Is_Independent (Etype (N)) then\n+         return True;\n+\n+      elsif Nkind (N) = N_Indexed_Component then\n+         return Prefix_Has_Independent_Components (Prefix (N));\n+\n+      elsif Nkind (N) = N_Selected_Component then\n+         return Prefix_Has_Independent_Components (Prefix (N))\n+           or else Is_Independent (Entity (Selector_Name (N)));\n+\n+      else\n+         return False;\n+      end if;\n+   end Is_Independent_Object;\n+\n    ----------------------------\n    -- Is_Inherited_Operation --\n    ----------------------------\n@@ -17903,7 +17937,7 @@ package body Sem_Util is\n             end if;\n \n          else\n-            if Is_Atomic (Etype (R)) or else Is_Atomic_Object (R) then\n+            if Is_Atomic_Object (R) then\n                return True;\n             end if;\n          end if;\n@@ -18545,6 +18579,45 @@ package body Sem_Util is\n         and then Scope (Scope (Scope (Root))) = Standard_Standard;\n    end Is_Visibly_Controlled;\n \n+   --------------------------------------\n+   --  Is_Volatile_Full_Access_Object  --\n+   --------------------------------------\n+\n+   function Is_Volatile_Full_Access_Object (N : Node_Id) return Boolean is\n+      function Is_VFA_Object_Entity (Id : Entity_Id) return Boolean;\n+      --  Determine whether arbitrary entity Id denotes an object that is\n+      --  Volatile_Full_Access.\n+\n+      ----------------------------\n+      --  Is_VFA_Object_Entity  --\n+      ----------------------------\n+\n+      function Is_VFA_Object_Entity (Id : Entity_Id) return Boolean is\n+      begin\n+         return\n+           Is_Object (Id)\n+             and then (Is_Volatile_Full_Access (Id)\n+                         or else\n+                       Is_Volatile_Full_Access (Etype (Id)));\n+      end Is_VFA_Object_Entity;\n+\n+   --  Start of processing for Is_Volatile_Full_Access_Object\n+\n+   begin\n+      if Is_Entity_Name (N) then\n+         return Is_VFA_Object_Entity (Entity (N));\n+\n+      elsif Is_Volatile_Full_Access (Etype (N)) then\n+         return True;\n+\n+      elsif Nkind (N) = N_Selected_Component then\n+         return Is_Volatile_Full_Access (Entity (Selector_Name (N)));\n+\n+      else\n+         return False;\n+      end if;\n+   end Is_Volatile_Full_Access_Object;\n+\n    --------------------------\n    -- Is_Volatile_Function --\n    --------------------------\n@@ -18580,86 +18653,74 @@ package body Sem_Util is\n    ------------------------\n \n    function Is_Volatile_Object (N : Node_Id) return Boolean is\n-      function Is_Volatile_Prefix (N : Node_Id) return Boolean;\n-      --  If prefix is an implicit dereference, examine designated type\n+      function Is_Volatile_Object_Entity (Id : Entity_Id) return Boolean;\n+      --  Determine whether arbitrary entity Id denotes an object that is\n+      --  Volatile.\n \n-      function Object_Has_Volatile_Components (N : Node_Id) return Boolean;\n-      --  Determines if given object has volatile components\n+      function Prefix_Has_Volatile_Components (P : Node_Id) return Boolean;\n+      --  Determine whether prefix P has volatile components. This requires\n+      --  the presence of a Volatile_Components aspect/pragma or that P be\n+      --  itself a volatile object as per RM C.6(8).\n \n-      ------------------------\n-      -- Is_Volatile_Prefix --\n-      ------------------------\n+      ---------------------------------\n+      --  Is_Volatile_Object_Entity  --\n+      ---------------------------------\n+\n+      function Is_Volatile_Object_Entity (Id : Entity_Id) return Boolean is\n+      begin\n+         return\n+           Is_Object (Id)\n+             and then (Is_Volatile (Id) or else Is_Volatile (Etype (Id)));\n+      end Is_Volatile_Object_Entity;\n \n-      function Is_Volatile_Prefix (N : Node_Id) return Boolean is\n-         Typ  : constant Entity_Id := Etype (N);\n+      ------------------------------------\n+      -- Prefix_Has_Volatile_Components --\n+      ------------------------------------\n+\n+      function Prefix_Has_Volatile_Components (P : Node_Id) return Boolean is\n+         Typ  : constant Entity_Id := Etype (P);\n \n       begin\n          if Is_Access_Type (Typ) then\n             declare\n                Dtyp : constant Entity_Id := Designated_Type (Typ);\n \n             begin\n-               return Is_Volatile (Dtyp)\n-                 or else Has_Volatile_Components (Dtyp);\n+               return Has_Volatile_Components (Dtyp)\n+                 or else Is_Volatile (Dtyp);\n             end;\n \n-         else\n-            return Object_Has_Volatile_Components (N);\n-         end if;\n-      end Is_Volatile_Prefix;\n-\n-      ------------------------------------\n-      -- Object_Has_Volatile_Components --\n-      ------------------------------------\n-\n-      function Object_Has_Volatile_Components (N : Node_Id) return Boolean is\n-         Typ : constant Entity_Id := Etype (N);\n-\n-      begin\n-         if Is_Volatile (Typ)\n-           or else Has_Volatile_Components (Typ)\n-         then\n+         elsif Has_Volatile_Components (Typ) then\n             return True;\n \n-         elsif Is_Entity_Name (N)\n-           and then (Has_Volatile_Components (Entity (N))\n-                      or else Is_Volatile (Entity (N)))\n+         elsif Is_Entity_Name (P)\n+           and then Has_Volatile_Component (Entity (P))\n          then\n             return True;\n \n-         elsif Nkind (N) = N_Indexed_Component\n-           or else Nkind (N) = N_Selected_Component\n-         then\n-            return Is_Volatile_Prefix (Prefix (N));\n+         elsif Is_Volatile_Object (P) then\n+            return True;\n \n          else\n             return False;\n          end if;\n-      end Object_Has_Volatile_Components;\n+      end Prefix_Has_Volatile_Components;\n \n    --  Start of processing for Is_Volatile_Object\n \n    begin\n-      if Nkind (N) = N_Defining_Identifier then\n-         return Is_Volatile (N) or else Is_Volatile (Etype (N));\n-\n-      elsif Nkind (N) = N_Expanded_Name then\n-         return Is_Volatile_Object (Entity (N));\n+      if Is_Entity_Name (N) then\n+         return Is_Volatile_Object_Entity (Entity (N));\n \n-      elsif Is_Volatile (Etype (N))\n-        or else (Is_Entity_Name (N) and then Is_Volatile (Entity (N)))\n-      then\n+      elsif Is_Volatile (Etype (N)) then\n          return True;\n \n-      elsif Nkind_In (N, N_Indexed_Component, N_Selected_Component)\n-        and then Is_Volatile_Prefix (Prefix (N))\n-      then\n-         return True;\n+      elsif Nkind (N) = N_Indexed_Component then\n+         return Prefix_Has_Volatile_Components (Prefix (N));\n \n-      elsif Nkind (N) = N_Selected_Component\n-        and then Is_Volatile (Entity (Selector_Name (N)))\n-      then\n-         return True;\n+      elsif Nkind (N) = N_Selected_Component then\n+         return Prefix_Has_Volatile_Components (Prefix (N))\n+           or else Is_Volatile (Entity (Selector_Name (N)));\n \n       else\n          return False;"}, {"sha": "2882917bf9f6606f217e2e6f6f936df3b0f677fb", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cee58d81076c99ab3db3305c1850bf79fa12f17/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cee58d81076c99ab3db3305c1850bf79fa12f17/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=2cee58d81076c99ab3db3305c1850bf79fa12f17", "patch": "@@ -1531,11 +1531,7 @@ package Sem_Util is\n \n    function Is_Atomic_Object (N : Node_Id) return Boolean;\n    --  Determine whether arbitrary node N denotes a reference to an atomic\n-   --  object as per Ada RM C.6(7) and the crucial remark in C.6(8).\n-\n-   function Is_Atomic_Object_Entity (Id : Entity_Id) return Boolean;\n-   --  Determine whether arbitrary entity Id denotes an atomic object as per\n-   --  Ada RM C.6(7).\n+   --  object as per RM C.6(7) and the crucial remark in RM C.6(8).\n \n    function Is_Atomic_Or_VFA_Object (N : Node_Id) return Boolean;\n    --  Determine whether arbitrary node N denotes a reference to an object\n@@ -1749,6 +1745,10 @@ package Sem_Util is\n    --  Determine whether arbitrary declaration Decl denotes a generic package,\n    --  a generic subprogram or a generic body.\n \n+   function Is_Independent_Object (N : Node_Id) return Boolean;\n+   --  Determine whether arbitrary node N denotes a reference to an independent\n+   --  object as per RM C.6(8).\n+\n    function Is_Inherited_Operation (E : Entity_Id) return Boolean;\n    --  E is a subprogram. Return True is E is an implicit operation inherited\n    --  by a derived type declaration.\n@@ -1996,7 +1996,7 @@ package Sem_Util is\n \n    function Is_Subcomponent_Of_Atomic_Object (N : Node_Id) return Boolean;\n    --  Determine whether arbitrary node N denotes a reference to a subcomponent\n-   --  of an atomic object as per Ada RM C.6(7).\n+   --  of an atomic object as per RM C.6(7).\n \n    function Is_Subprogram_Contract_Annotation (Item : Node_Id) return Boolean;\n    --  Determine whether aspect specification or pragma Item is one of the\n@@ -2095,16 +2095,20 @@ package Sem_Util is\n    --  Initialize/Adjust/Finalize subprogram does not override the inherited\n    --  one.\n \n+   function Is_Volatile_Full_Access_Object (N : Node_Id) return Boolean;\n+   --  Determine whether arbitrary node N denotes a reference to an object\n+   --  which is Volatile_Full_Access.\n+\n    function Is_Volatile_Function (Func_Id : Entity_Id) return Boolean;\n    --  Determine whether [generic] function Func_Id is subject to enabled\n    --  pragma Volatile_Function. Protected functions are treated as volatile\n    --  (SPARK RM 7.1.2).\n \n    function Is_Volatile_Object (N : Node_Id) return Boolean;\n-   --  Determines if the given node denotes an volatile object in the sense of\n-   --  the legality checks described in RM C.6(12). Note that the test here is\n-   --  for something actually declared as volatile, not for an object that gets\n-   --  treated as volatile (see Einfo.Treat_As_Volatile).\n+   --  Determine whether arbitrary node N denotes a reference to a volatile\n+   --  object as per RM C.6(8). Note that the test here is for something that\n+   --  is actually declared as volatile, not for an object that gets treated\n+   --  as volatile (see Einfo.Treat_As_Volatile).\n \n    generic\n       with procedure Handle_Parameter (Formal : Entity_Id; Actual : Node_Id);"}]}