{"sha": "a8b4881f10494c320f195bf30605967970712913", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThiNDg4MWYxMDQ5NGMzMjBmMTk1YmYzMDYwNTk2Nzk3MDcxMjkxMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2002-05-09T20:10:54Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2002-05-09T20:10:54Z"}, "message": "mips.c (mips_add_large_offset_to_sp): Remove FILE arg.\n\n\t* config/mips/mips.c (mips_add_large_offset_to_sp): Remove FILE arg.\n\t(save_restore_insns): Likewise.\n\t(mips_expand_prologue, mips_expand_epilogue): Update callers.\n\t(highpart_shift_operator): Attach ATTRIBUTE_UNUSED to mode argument.\n\nFrom-SVN: r53341", "tree": {"sha": "d0a4390181791d6f60ecbb425069a41acf7bc011", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0a4390181791d6f60ecbb425069a41acf7bc011"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8b4881f10494c320f195bf30605967970712913", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8b4881f10494c320f195bf30605967970712913", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8b4881f10494c320f195bf30605967970712913", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8b4881f10494c320f195bf30605967970712913/comments", "author": null, "committer": null, "parents": [{"sha": "b70b3534faa6a03b3e2d03d75ab26ab698aa3970", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b70b3534faa6a03b3e2d03d75ab26ab698aa3970", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b70b3534faa6a03b3e2d03d75ab26ab698aa3970"}], "stats": {"total": 277, "additions": 94, "deletions": 183}, "files": [{"sha": "eba1ddcd8d3b750c32542ab5d69b90ec6e03d36a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b4881f10494c320f195bf30605967970712913/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b4881f10494c320f195bf30605967970712913/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a8b4881f10494c320f195bf30605967970712913", "patch": "@@ -1,3 +1,10 @@\n+2002-05-09  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.c (mips_add_large_offset_to_sp): Remove FILE arg.\n+\t(save_restore_insns): Likewise.\n+\t(mips_expand_prologue, mips_expand_epilogue): Update callers.\n+\t(highpart_shift_operator): Attach ATTRIBUTE_UNUSED to mode argument.\n+\n Thu May  9 11:50:09 2002  Jeffrey A Law  (law@cygnus.com)\n \n \t* i386.md (type attribute): Add \"rotate\" for rotate insns."}, {"sha": "d523e1323f6e1aea83e44d88b62a86336eb6fada", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 87, "deletions": 183, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b4881f10494c320f195bf30605967970712913/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b4881f10494c320f195bf30605967970712913/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=a8b4881f10494c320f195bf30605967970712913", "patch": "@@ -104,15 +104,13 @@ static void mips_arg_info\t\tPARAMS ((const CUMULATIVE_ARGS *,\n \t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t tree, int,\n \t\t\t\t\t\t struct mips_arg_info *));\n-static rtx mips_add_large_offset_to_sp\t\tPARAMS ((HOST_WIDE_INT,\n-\t\t\t\t\t\t\t FILE *));\n+static rtx mips_add_large_offset_to_sp\t\tPARAMS ((HOST_WIDE_INT));\n static void mips_annotate_frame_insn\t\tPARAMS ((rtx, rtx));\n static rtx mips_frame_set\t\t\tPARAMS ((enum machine_mode,\n \t\t\t\t\t\t\t int, int));\n static void mips_emit_frame_related_store\tPARAMS ((rtx, rtx,\n \t\t\t\t\t\t\t HOST_WIDE_INT));\n-static void save_restore_insns\t\t\tPARAMS ((int, rtx,\n-\t\t\t\t\t\t\tlong, FILE *));\n+static void save_restore_insns\t\t\tPARAMS ((int, rtx, long));\n static void mips16_output_gp_offset\t\tPARAMS ((FILE *, rtx));\n static void mips16_fp_args\t\t\tPARAMS ((FILE *, int, int));\n static void build_mips16_function_stub\t\tPARAMS ((FILE *));\n@@ -6719,40 +6717,23 @@ compute_frame_size (size)\n #define BITSET_P(VALUE,BIT) (((VALUE) & (1L << (BIT))) != 0)\n \n /* Emit instructions to load the value (SP + OFFSET) into MIPS_TEMP2_REGNUM\n-   and return an rtl expression for the register.  Write the assembly\n-   instructions directly to FILE if it is not null, otherwise emit them as\n-   rtl.\n+   and return an rtl expression for the register.\n \n    This function is a subroutine of save_restore_insns.  It is used when\n    OFFSET is too large to add in a single instruction.  */\n \n static rtx\n-mips_add_large_offset_to_sp (offset, file)\n+mips_add_large_offset_to_sp (offset)\n      HOST_WIDE_INT offset;\n-     FILE *file;\n {\n   rtx reg = gen_rtx_REG (Pmode, MIPS_TEMP2_REGNUM);\n-  if (file == 0)\n-    {\n-      rtx offset_rtx = GEN_INT (offset);\n+  rtx offset_rtx = GEN_INT (offset);\n \n-      emit_move_insn (reg, offset_rtx);\n-      if (Pmode == DImode)\n-\temit_insn (gen_adddi3 (reg, reg, stack_pointer_rtx));\n-      else\n-\temit_insn (gen_addsi3 (reg, reg, stack_pointer_rtx));\n-    }\n+  emit_move_insn (reg, offset_rtx);\n+  if (Pmode == DImode)\n+    emit_insn (gen_adddi3 (reg, reg, stack_pointer_rtx));\n   else\n-    {\n-      fprintf (file, \"\\tli\\t%s,0x%.08lx\\t# \",\n-\t       reg_names[MIPS_TEMP2_REGNUM], (long) offset);\n-      fprintf (file, HOST_WIDE_INT_PRINT_DEC, offset);\n-      fprintf (file, \"\\n\\t%s\\t%s,%s,%s\\n\",\n-\t       Pmode == DImode ? \"daddu\" : \"addu\",\n-\t       reg_names[MIPS_TEMP2_REGNUM],\n-\t       reg_names[MIPS_TEMP2_REGNUM],\n-\t       reg_names[STACK_POINTER_REGNUM]);\n-    }\n+    emit_insn (gen_addsi3 (reg, reg, stack_pointer_rtx));\n   return reg;\n }\n \n@@ -6818,11 +6799,10 @@ mips_emit_frame_related_store (mem, reg, offset)\n }\n \n static void\n-save_restore_insns (store_p, large_reg, large_offset, file)\n+save_restore_insns (store_p, large_reg, large_offset)\n      int store_p;\t/* true if this is prologue */\n      rtx large_reg;\t/* register holding large offset constant or NULL */\n      long large_offset;\t/* large constant offset value */\n-     FILE *file;\t/* file to write instructions instead of making RTL */\n {\n   long mask = current_frame_info.mask;\n   long fmask = current_frame_info.fmask;\n@@ -6886,26 +6866,17 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t{\n \t  base_reg_rtx = gen_rtx_REG (Pmode, MIPS_TEMP2_REGNUM);\n \t  base_offset = large_offset;\n-\t  if (file == 0)\n-\t    {\n-\t      if (Pmode == DImode)\n-\t\tinsn = emit_insn (gen_adddi3 (base_reg_rtx, large_reg,\n-\t\t\t\t\t      stack_pointer_rtx));\n-\t      else\n-\t\tinsn = emit_insn (gen_addsi3 (base_reg_rtx, large_reg,\n-\t\t\t\t\t      stack_pointer_rtx));\n-\t    }\n+\t  if (Pmode == DImode)\n+\t    insn = emit_insn (gen_adddi3 (base_reg_rtx, large_reg,\n+\t\t\t\t\t  stack_pointer_rtx));\n \t  else\n-\t    fprintf (file, \"\\t%s\\t%s,%s,%s\\n\",\n-\t\t     Pmode == DImode ? \"daddu\" : \"addu\",\n-\t\t     reg_names[MIPS_TEMP2_REGNUM],\n-\t\t     reg_names[REGNO (large_reg)],\n-\t\t     reg_names[STACK_POINTER_REGNUM]);\n+\t    insn = emit_insn (gen_addsi3 (base_reg_rtx, large_reg,\n+\t\t\t\t\t  stack_pointer_rtx));\n \t}\n       else\n \t{\n \t  base_offset = gp_offset;\n-\t  base_reg_rtx = mips_add_large_offset_to_sp (base_offset, file);\n+\t  base_reg_rtx = mips_add_large_offset_to_sp (base_offset);\n \t}\n \n       /* When we restore the registers in MIPS16 mode, then if we are\n@@ -6922,99 +6893,57 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \tbase_offset += current_function_outgoing_args_size;\n \n       for (regno = GP_REG_LAST; regno >= GP_REG_FIRST; regno--)\n-\tif (BITSET_P (mask, regno - GP_REG_FIRST))\n-\t  {\n-\t    if (file == 0)\n-\t      {\n-\t\trtx reg_rtx;\n-\t\trtx mem_rtx\n-\t\t  = gen_rtx (MEM, gpr_mode,\n-\t\t\t     gen_rtx (PLUS, Pmode, base_reg_rtx,\n-\t\t\t\t      GEN_INT (gp_offset - base_offset)));\n-\n-\t\tif (! current_function_calls_eh_return)\n-\t\t  RTX_UNCHANGING_P (mem_rtx) = 1;\n-\n-\t\t/* The mips16 does not have an instruction to load\n-                   $31, so we load $7 instead, and work things out\n-                   in mips_expand_epilogue.  */\n-\t\tif (TARGET_MIPS16 && ! store_p && regno == GP_REG_FIRST + 31)\n-\t\t  reg_rtx = gen_rtx (REG, gpr_mode, GP_REG_FIRST + 7);\n-\t\t/* The mips16 sometimes needs to save $18.  */\n-\t\telse if (TARGET_MIPS16\n-\t\t\t && regno != GP_REG_FIRST + 31\n-\t\t\t && ! M16_REG_P (regno))\n-\t\t  {\n-\t\t    if (! store_p)\n-\t\t      reg_rtx = gen_rtx (REG, gpr_mode, 6);\n-\t\t    else\n-\t\t      {\n-\t\t\treg_rtx = gen_rtx (REG, gpr_mode, 3);\n-\t\t\temit_move_insn (reg_rtx,\n-\t\t\t\t\tgen_rtx (REG, gpr_mode, regno));\n-\t\t      }\n-\t\t  }\n-\t\telse\n-\t\t  reg_rtx = gen_rtx (REG, gpr_mode, regno);\n-\n-\t\tif (store_p)\n-\t\t  mips_emit_frame_related_store (mem_rtx, reg_rtx, gp_offset);\n-\t\telse\n-\t\t  {\n-\t\t    emit_move_insn (reg_rtx, mem_rtx);\n-\t\t    if (TARGET_MIPS16\n-\t\t\t&& regno != GP_REG_FIRST + 31\n-\t\t\t&& ! M16_REG_P (regno))\n-\t\t      emit_move_insn (gen_rtx (REG, gpr_mode, regno),\n-\t\t\t\t      reg_rtx);\n-\t\t  }\n-\t      }\n-\t    else\n-\t      {\n-\t\tint r = regno;\n-\n-\t\t/* The mips16 does not have an instruction to\n-\t\t   load $31, so we load $7 instead, and work\n-\t\t   things out in the caller.  */\n-\t\tif (TARGET_MIPS16 && ! store_p && r == GP_REG_FIRST + 31)\n-\t\t  r = GP_REG_FIRST + 7;\n-\t\t/* The mips16 sometimes needs to save $18.  */\n-\t\tif (TARGET_MIPS16\n-\t\t    && regno != GP_REG_FIRST + 31\n-\t\t    && ! M16_REG_P (regno))\n-\t\t  {\n-\t\t    if (! store_p)\n-\t\t      r = GP_REG_FIRST + 6;\n-\t\t    else\n-\t\t      {\n-\t\t\tr = GP_REG_FIRST + 3;\n-\t\t\tfprintf (file, \"\\tmove\\t%s,%s\\n\",\n-\t\t\t\t reg_names[r], reg_names[regno]);\n-\t\t      }\n-\t\t  }\n-\t\tfprintf (file, \"\\t%s\\t%s,\",\n-\t\t\t (TARGET_64BIT\n-\t\t\t  ? (store_p) ? \"sd\" : \"ld\"\n-\t\t\t  : (store_p) ? \"sw\" : \"lw\"),\n-\t\t\t reg_names[r]);\n-\t\tfprintf (file, HOST_WIDE_INT_PRINT_DEC,\n-\t\t\t gp_offset - base_offset);\n-\t\tfprintf (file, \"(%s)\\n\", reg_names[REGNO(base_reg_rtx)]);\n-\t\tif (! store_p\n-\t\t    && TARGET_MIPS16\n-\t\t    && regno != GP_REG_FIRST + 31\n-\t\t    && ! M16_REG_P (regno))\n-\t\t  fprintf (file, \"\\tmove\\t%s,%s\\n\",\n-\t\t\t   reg_names[regno], reg_names[r]);\n-\t      }\n-\t    gp_offset -= GET_MODE_SIZE (gpr_mode);\n-\t  }\n-        /* If the restore is being supressed, still take into account\n-\t   the offset at which it is stored.  */\n- \telse if (BITSET_P (real_mask, regno - GP_REG_FIRST))\n- \t  {\n+\t{\n+\t  if (BITSET_P (mask, regno - GP_REG_FIRST))\n+\t    {\n+\t      rtx reg_rtx;\n+\t      rtx mem_rtx\n+\t\t= gen_rtx (MEM, gpr_mode,\n+\t\t\t   gen_rtx (PLUS, Pmode, base_reg_rtx,\n+\t\t\t\t    GEN_INT (gp_offset - base_offset)));\n+\n+\t      if (! current_function_calls_eh_return)\n+\t\tRTX_UNCHANGING_P (mem_rtx) = 1;\n+\n+\t      /* The mips16 does not have an instruction to load\n+\t\t $31, so we load $7 instead, and work things out\n+\t\t in mips_expand_epilogue.  */\n+\t      if (TARGET_MIPS16 && ! store_p && regno == GP_REG_FIRST + 31)\n+\t\treg_rtx = gen_rtx (REG, gpr_mode, GP_REG_FIRST + 7);\n+\t      /* The mips16 sometimes needs to save $18.  */\n+\t      else if (TARGET_MIPS16\n+\t\t       && regno != GP_REG_FIRST + 31\n+\t\t       && ! M16_REG_P (regno))\n+\t\t{\n+\t\t  if (! store_p)\n+\t\t    reg_rtx = gen_rtx (REG, gpr_mode, 6);\n+\t\t  else\n+\t\t    {\n+\t\t      reg_rtx = gen_rtx (REG, gpr_mode, 3);\n+\t\t      emit_move_insn (reg_rtx,\n+\t\t\t\t      gen_rtx (REG, gpr_mode, regno));\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\treg_rtx = gen_rtx (REG, gpr_mode, regno);\n+\n+\t      if (store_p)\n+\t\tmips_emit_frame_related_store (mem_rtx, reg_rtx, gp_offset);\n+\t      else\n+\t\t{\n+\t\t  emit_move_insn (reg_rtx, mem_rtx);\n+\t\t  if (TARGET_MIPS16\n+\t\t      && regno != GP_REG_FIRST + 31\n+\t\t      && ! M16_REG_P (regno))\n+\t\t    emit_move_insn (gen_rtx (REG, gpr_mode, regno),\n+\t\t\t\t    reg_rtx);\n+\t\t}\n+\t    }\n+\t  /* If the restore is being supressed, still take into account\n+\t     the offset at which it is stored.  */\n+\t  if (BITSET_P (real_mask, regno - GP_REG_FIRST))\n \t    gp_offset -= GET_MODE_SIZE (gpr_mode);\n-\t  }\n+\t}\n     }\n   else\n     base_reg_rtx = 0, base_offset  = 0;\n@@ -7046,27 +6975,17 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t{\n \t  base_reg_rtx = gen_rtx_REG (Pmode, MIPS_TEMP2_REGNUM);\n \t  base_offset = large_offset;\n-\t  if (file == 0)\n-\t    {\n-\t      if (Pmode == DImode)\n-\t\tinsn = emit_insn (gen_adddi3 (base_reg_rtx, large_reg,\n-\t\t\t\t\t      stack_pointer_rtx));\n-\t      else\n-\t\tinsn = emit_insn (gen_addsi3 (base_reg_rtx, large_reg,\n-\t\t\t\t\t      stack_pointer_rtx));\n-\t    }\n-\n+\t  if (Pmode == DImode)\n+\t    insn = emit_insn (gen_adddi3 (base_reg_rtx, large_reg,\n+\t\t\t\t\t  stack_pointer_rtx));\n \t  else\n-\t    fprintf (file, \"\\t%s\\t%s,%s,%s\\n\",\n-\t\t     Pmode == DImode ? \"daddu\" : \"addu\",\n-\t\t     reg_names[MIPS_TEMP2_REGNUM],\n-\t\t     reg_names[REGNO (large_reg)],\n-\t\t     reg_names[STACK_POINTER_REGNUM]);\n+\t    insn = emit_insn (gen_addsi3 (base_reg_rtx, large_reg,\n+\t\t\t\t\t  stack_pointer_rtx));\n \t}\n       else\n \t{\n \t  base_offset = fp_offset;\n-\t  base_reg_rtx = mips_add_large_offset_to_sp (fp_offset, file);\n+\t  base_reg_rtx = mips_add_large_offset_to_sp (fp_offset);\n \t}\n \n       /* This loop must iterate over the same space as its companion in\n@@ -7076,34 +6995,19 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t   regno -= FP_INC)\n \tif (BITSET_P (fmask, regno - FP_REG_FIRST))\n \t  {\n-\t    if (file == 0)\n-\t      {\n-\t\tenum machine_mode sz\n-\t\t  = TARGET_SINGLE_FLOAT ? SFmode : DFmode;\n-\t\trtx reg_rtx = gen_rtx (REG, sz, regno);\n-\t\trtx mem_rtx = gen_rtx (MEM, sz,\n-\t\t\t\t       gen_rtx (PLUS, Pmode, base_reg_rtx,\n-\t\t\t\t\t\tGEN_INT (fp_offset\n-\t\t\t\t\t\t\t - base_offset)));\n-\t\tif (! current_function_calls_eh_return)\n-\t\t  RTX_UNCHANGING_P (mem_rtx) = 1;\n-\n-\t\tif (store_p)\n-\t\t  mips_emit_frame_related_store (mem_rtx, reg_rtx, fp_offset);\n-\t\telse\n-\t\t  emit_move_insn (reg_rtx, mem_rtx);\n-\t      }\n+\t    enum machine_mode sz = TARGET_SINGLE_FLOAT ? SFmode : DFmode;\n+\t    rtx reg_rtx = gen_rtx (REG, sz, regno);\n+\t    rtx mem_rtx = gen_rtx (MEM, sz,\n+\t\t\t\t   gen_rtx (PLUS, Pmode, base_reg_rtx,\n+\t\t\t\t\t    GEN_INT (fp_offset\n+\t\t\t\t\t\t     - base_offset)));\n+\t    if (! current_function_calls_eh_return)\n+\t      RTX_UNCHANGING_P (mem_rtx) = 1;\n+\n+\t    if (store_p)\n+\t      mips_emit_frame_related_store (mem_rtx, reg_rtx, fp_offset);\n \t    else\n-\t      {\n-\t\tfprintf (file, \"\\t%s\\t%s,\",\n-\t\t\t (TARGET_SINGLE_FLOAT\n-\t\t\t  ? (store_p ? \"s.s\" : \"l.s\")\n-\t\t\t  : (store_p ? \"s.d\" : \"l.d\")),\n-\t\t\t reg_names[regno]);\n-\t\tfprintf (file, HOST_WIDE_INT_PRINT_DEC,\n-\t\t\t fp_offset - base_offset);\n-\t\tfprintf (file, \"(%s)\\n\", reg_names[REGNO(base_reg_rtx)]);\n-\t      }\n+\t      emit_move_insn (reg_rtx, mem_rtx);\n \n \t    fp_offset -= UNITS_PER_FPVALUE;\n \t  }\n@@ -7593,7 +7497,7 @@ mips_expand_prologue ()\n \t}\n \n       if (! mips_entry)\n-\tsave_restore_insns (1, tmp_rtx, tsize, (FILE *)0);\n+\tsave_restore_insns (1, tmp_rtx, tsize);\n       else if (reg_18_save != NULL_RTX)\n \temit_insn (reg_18_save);\n \n@@ -7862,7 +7766,7 @@ mips_expand_epilogue ()\n \t\t   & (1L << (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))))\n \temit_insn (gen_blockage ());\n \n-      save_restore_insns (0, tmp_rtx, orig_tsize, (FILE *)0);\n+      save_restore_insns (0, tmp_rtx, orig_tsize);\n \n       /* In mips16 mode with a large frame, we adjust the stack\n          pointer before restoring the registers.  In this case, we\n@@ -9743,7 +9647,7 @@ highpart_shift_operator (x, mode)\n \n int\n mips_register_move_cost (mode, to, from)\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n      enum reg_class to, from;\n {\n   if (from == M16_REGS && GR_REG_CLASS_P (to))"}]}