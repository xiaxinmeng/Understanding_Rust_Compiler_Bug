{"sha": "1edf43d63f1f23b070786a1da29edbc63cdebae1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVkZjQzZDYzZjFmMjNiMDcwNzg2YTFkYTI5ZWRiYzYzY2RlYmFlMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2001-02-16T13:03:10Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-02-16T13:03:10Z"}, "message": "dwarf2out.c (add_bound_info): Don't crash if SAVE_EXPR_RTL is NULL.\n\n        * dwarf2out.c (add_bound_info): Don't crash if SAVE_EXPR_RTL is\n        NULL.\n        (gen_subprogram_die): Don't abort on seeing a second definition if\n        the previous one was abstract.  Don't replace an abstract instance\n        in the lookup table.\n\n        * dwarf2out.c (dwarf2out_abstract_function): Rename from\n        gen_abstract_function.\n        * dwarf2out.h: Declare it.\n        * toplev.c (note_outlining_of_inline_function): New fn.\n        * toplev.h: Declare it.\n        * integrate.c (output_inline_function): Call it.\n        * c-decl.c (duplicate_decls): Call it when redefining an extern\n        inline.  Don't inline the new defn.\n\nFrom-SVN: r39763", "tree": {"sha": "5ae76ee139c95d2ba34d0cb6fa406f2f92e70519", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ae76ee139c95d2ba34d0cb6fa406f2f92e70519"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1edf43d63f1f23b070786a1da29edbc63cdebae1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1edf43d63f1f23b070786a1da29edbc63cdebae1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1edf43d63f1f23b070786a1da29edbc63cdebae1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1edf43d63f1f23b070786a1da29edbc63cdebae1/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a901fa64045a73517d8c212740b57e8b7650f3ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a901fa64045a73517d8c212740b57e8b7650f3ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a901fa64045a73517d8c212740b57e8b7650f3ad"}], "stats": {"total": 98, "additions": 78, "deletions": 20}, "files": [{"sha": "35ecb4b14ffb3b1022b06b0bc06227777c70e2e4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1edf43d63f1f23b070786a1da29edbc63cdebae1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1edf43d63f1f23b070786a1da29edbc63cdebae1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1edf43d63f1f23b070786a1da29edbc63cdebae1", "patch": "@@ -1,5 +1,20 @@\n 2001-02-16  Jason Merrill  <jason@redhat.com>\n \n+\t* dwarf2out.c (add_bound_info): Don't crash if SAVE_EXPR_RTL is\n+\tNULL.\n+\t(gen_subprogram_die): Don't abort on seeing a second definition if \n+\tthe previous one was abstract.  Don't replace an abstract instance\n+\tin the lookup table.\n+\n+\t* dwarf2out.c (dwarf2out_abstract_function): Rename from\n+\tgen_abstract_function.\n+\t* dwarf2out.h: Declare it.\n+\t* toplev.c (note_outlining_of_inline_function): New fn.\n+\t* toplev.h: Declare it.\n+\t* integrate.c (output_inline_function): Call it.\n+\t* c-decl.c (duplicate_decls): Call it when redefining an extern\n+\tinline.  Don't inline the new defn.\n+\n \t* tree.h (BLOCK_CHAIN): Use BLOCK_CHECK.\n \n 2001-02-16  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>"}, {"sha": "a2118fdfdc1a27ce077ac6070fd0fb08866b3258", "filename": "gcc/c-decl.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1edf43d63f1f23b070786a1da29edbc63cdebae1/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1edf43d63f1f23b070786a1da29edbc63cdebae1/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=1edf43d63f1f23b070786a1da29edbc63cdebae1", "patch": "@@ -1928,6 +1928,19 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n   /* For functions, static overrides non-static.  */\n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n+      /* If we're redefining a function previously defined as extern\n+\t inline, make sure we emit debug info for the inline before we\n+\t throw it away, in case it was inlined into a function that hasn't\n+\t been written out yet.  */\n+      if (new_is_definition && DECL_INITIAL (olddecl) && TREE_USED (olddecl))\n+\t{\n+\t  note_outlining_of_inline_function (olddecl);\n+\n+\t  /* The new defn must not be inline.\n+\t     FIXME what about -finline-functions? */\n+\t  DECL_INLINE (newdecl) = 0;\n+\t}\n+\n       TREE_PUBLIC (newdecl) &= TREE_PUBLIC (olddecl);\n       /* This is since we don't automatically\n \t copy the attributes of NEWDECL into OLDDECL.  */"}, {"sha": "ed4970cbf39bf0f96cf2a977fd3eab23a8f3ddc3", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1edf43d63f1f23b070786a1da29edbc63cdebae1/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1edf43d63f1f23b070786a1da29edbc63cdebae1/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=1edf43d63f1f23b070786a1da29edbc63cdebae1", "patch": "@@ -3760,7 +3760,6 @@ static void init_file_table\t\tPARAMS ((struct file_table *));\n static void add_incomplete_type\t\tPARAMS ((tree));\n static void retry_incomplete_types\tPARAMS ((void));\n static void gen_type_die_for_member\tPARAMS ((tree, tree, dw_die_ref));\n-static void gen_abstract_function\tPARAMS ((tree));\n static rtx save_rtx\t\t\tPARAMS ((rtx));\n static void splice_child_die\t\tPARAMS ((dw_die_ref, dw_die_ref));\n static int file_info_cmp\t\tPARAMS ((const void *, const void *));\n@@ -9014,8 +9013,8 @@ add_bound_info (subrange_die, bound_attr, bound)\n \t We assume that a MEM rtx is safe because gcc wouldn't put the\n \t value there unless it was going to be used repeatedly in the\n \t function, i.e. for cleanups.  */\n-      if (! optimize || (SAVE_EXPR_RTL (bound)\n-\t\t\t && GET_CODE (SAVE_EXPR_RTL (bound)) == MEM))\n+      if (SAVE_EXPR_RTL (bound)\n+\t  && (! optimize || GET_CODE (SAVE_EXPR_RTL (bound)) == MEM))\n \t{\n \t  register dw_die_ref ctx = lookup_decl_die (current_function_decl);\n \t  register dw_die_ref decl_die = new_die (DW_TAG_variable, ctx);\n@@ -9320,7 +9319,7 @@ add_abstract_origin_attribute (die, origin)\n \tfn = TYPE_STUB_DECL (fn);\n       fn = decl_function_context (fn);\n       if (fn)\n-\tgen_abstract_function (fn);\n+\tdwarf2out_abstract_function (fn);\n     }\n \n   if (DECL_P (origin))\n@@ -10022,8 +10021,8 @@ gen_type_die_for_member (type, member, context_die)\n    of a function which we may later generate inlined and/or\n    out-of-line instances of.  */\n \n-static void\n-gen_abstract_function (decl)\n+void\n+dwarf2out_abstract_function (decl)\n      tree decl;\n {\n   register dw_die_ref old_die = lookup_decl_die (decl);\n@@ -10105,7 +10104,11 @@ gen_subprogram_die (decl, context_die)\n       register unsigned file_index\n \t= lookup_filename (&decl_file_table, DECL_SOURCE_FILE (decl));\n \n-      if (get_AT_flag (old_die, DW_AT_declaration) != 1)\n+      if (!get_AT_flag (old_die, DW_AT_declaration)\n+\t  /* We can have a normal definition following an inline one in the\n+\t     case of redefinition of GNU C extern inlines.\n+\t     It seems reasonable to use AT_specification in this case.  */\n+\t  && !get_AT_unsigned (old_die, DW_AT_inline))\n \t{\n \t  /* ??? This can happen if there is a bug in the program, for\n \t     instance, if it has duplicate function definitions.  Ideally,\n@@ -10175,15 +10178,17 @@ gen_subprogram_die (decl, context_die)\n \n   if (declaration)\n     {\n-      if (! origin)\n-\tadd_AT_flag (subr_die, DW_AT_declaration, 1);\n-\n-      /* The first time we see a member function, it is in the context of\n-         the class to which it belongs.  We make sure of this by emitting\n-         the class first.  The next time is the definition, which is\n-         handled above.  The two may come from the same source text.  */\n-      if (DECL_CONTEXT (decl) || DECL_ABSTRACT (decl))\n-\tequate_decl_number_to_die (decl, subr_die);\n+      if (!(old_die && get_AT_unsigned (old_die, DW_AT_inline)))\n+\t{\n+\t  add_AT_flag (subr_die, DW_AT_declaration, 1);\n+\n+\t  /* The first time we see a member function, it is in the context of\n+\t     the class to which it belongs.  We make sure of this by emitting\n+\t     the class first.  The next time is the definition, which is\n+\t     handled above.  The two may come from the same source text.  */\n+\t  if (DECL_CONTEXT (decl) || DECL_ABSTRACT (decl))\n+\t    equate_decl_number_to_die (decl, subr_die);\n+\t}\n     }\n   else if (DECL_ABSTRACT (decl))\n     {\n@@ -10206,7 +10211,7 @@ gen_subprogram_die (decl, context_die)\n     }\n   else if (!DECL_EXTERNAL (decl))\n     {\n-      if (origin == NULL_TREE)\n+      if (!(old_die && get_AT_unsigned (old_die, DW_AT_inline)))\n \tequate_decl_number_to_die (decl, subr_die);\n \n       ASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_BEGIN_LABEL,\n@@ -10490,7 +10495,7 @@ gen_inlined_subroutine_die (stmt, context_die, depth)\n       char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n       /* Emit info for the abstract instance first, if we haven't yet.  */\n-      gen_abstract_function (decl);\n+      dwarf2out_abstract_function (decl);\n \n       add_abstract_origin_attribute (subr_die, decl);\n       ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_BEGIN_LABEL,\n@@ -11265,12 +11270,12 @@ gen_decl_die (decl, context_die)\n \t emit info for the abstract instance and set up to refer to it.  */\n       if (DECL_INLINE (decl) && ! DECL_ABSTRACT (decl)\n \t  && ! class_scope_p (context_die)\n-\t  /* gen_abstract_function won't emit a die if this is just a\n+\t  /* dwarf2out_abstract_function won't emit a die if this is just a\n \t     declaration.  We must avoid setting DECL_ABSTRACT_ORIGIN in\n \t     that case, because that works only if we have a die.  */\n \t  && DECL_INITIAL (decl) != NULL_TREE)\n \t{\n-\t  gen_abstract_function (decl);\n+\t  dwarf2out_abstract_function (decl);\n \t  set_decl_origin_self (decl);\n \t}\n "}, {"sha": "a48dbf8e86485c4e8732bfdb76ca65f65bde209f", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1edf43d63f1f23b070786a1da29edbc63cdebae1/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1edf43d63f1f23b070786a1da29edbc63cdebae1/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=1edf43d63f1f23b070786a1da29edbc63cdebae1", "patch": "@@ -39,4 +39,5 @@ extern void debug_dwarf\t\t\tPARAMS ((void));\n struct die_struct;\n extern void debug_dwarf_die\t\tPARAMS ((struct die_struct *));\n extern void dwarf2out_set_demangle_name_func PARAMS ((const char *(*) (const char *)));\n+extern void dwarf2out_abstract_function PARAMS ((tree));\n extern void dwarf2out_add_library_unit_info PARAMS ((const char *, const char *));"}, {"sha": "bcb3619458fa8850290755c9925284f8a2b4b975", "filename": "gcc/integrate.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1edf43d63f1f23b070786a1da29edbc63cdebae1/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1edf43d63f1f23b070786a1da29edbc63cdebae1/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=1edf43d63f1f23b070786a1da29edbc63cdebae1", "patch": "@@ -2846,6 +2846,10 @@ output_inline_function (fndecl)\n   if (f->no_debugging_symbols)\n     write_symbols = NO_DEBUG;\n \n+  /* Do any preparation, such as emitting abstract debug info for the inline\n+     before it gets mangled by optimization.  */\n+  note_outlining_of_inline_function (fndecl);\n+\n   /* Compile this function all the way down to assembly code.  */\n   rest_of_compilation (fndecl);\n "}, {"sha": "6a001079664b1ed78a6938e39b93ed826cadc4da", "filename": "gcc/toplev.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1edf43d63f1f23b070786a1da29edbc63cdebae1/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1edf43d63f1f23b070786a1da29edbc63cdebae1/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=1edf43d63f1f23b070786a1da29edbc63cdebae1", "patch": "@@ -2681,6 +2681,24 @@ note_deferral_of_defined_inline_function (decl)\n #endif\n }\n \n+/* FNDECL is an inline function which is about to be emitted out of line.\n+   Do any preparation, such as emitting abstract debug info for the inline\n+   before it gets mangled by optimization.  */\n+\n+void\n+note_outlining_of_inline_function (fndecl)\n+     tree fndecl;\n+{\n+#ifdef DWARF2_DEBUGGING_INFO\n+  /* The DWARF 2 backend tries to reduce debugging bloat by not emitting\n+     the abstract description of inline functions until something tries to\n+     reference them.  Force it out now, before optimizations mangle the\n+     block tree.  */\n+  if (write_symbols == DWARF2_DEBUG)\n+    dwarf2out_abstract_function (fndecl);\n+#endif\n+}\n+\n /* This is called from finish_function (within yyparse)\n    after each top-level definition is parsed.\n    It is supposed to compile that function or variable"}, {"sha": "dc36dd5b9d4d7b32643e59f9198b1faf8fadef54", "filename": "gcc/toplev.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1edf43d63f1f23b070786a1da29edbc63cdebae1/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1edf43d63f1f23b070786a1da29edbc63cdebae1/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=1edf43d63f1f23b070786a1da29edbc63cdebae1", "patch": "@@ -128,6 +128,8 @@ extern int wrapup_global_declarations   PARAMS ((union tree_node **, int));\n extern void check_global_declarations   PARAMS ((union tree_node **, int));\n extern void note_deferral_of_defined_inline_function\n \t\t\t\t\tPARAMS ((union tree_node *));\n+extern void note_outlining_of_inline_function\n+\t\t\t\t\tPARAMS ((union tree_node *));\n extern int errorcount;\n extern int warningcount;\n extern int sorrycount;"}]}