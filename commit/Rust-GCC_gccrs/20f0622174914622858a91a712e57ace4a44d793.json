{"sha": "20f0622174914622858a91a712e57ace4a44d793", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBmMDYyMjE3NDkxNDYyMjg1OGE5MWE3MTJlNTdhY2U0YTQ0ZDc5Mw==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2006-01-19T10:24:00Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2006-01-19T10:24:00Z"}, "message": "Makefile.in (tree-vect-patterns.o): Add rule for new file.\n\n        * Makefile.in (tree-vect-patterns.o): Add rule for new file.\n        * tree-vect-analyze.c (vect_determine_vectorization_factor): Use\n        existing STMT_VINFO_VECTYPE if available.\n        (vect_mark_relevant): Add special handling for stmts that are\n        marked as STMT_VINFO_IN_PATTERN_P.\n        (vect_analyze_loop): Call vect_pattern_recog.\n        * tree-vectorizer.c (new_stmt_vec_info): Initialize new fields.\n        * tree-vectorizer.h (in_pattern_p, related_stmt): New fields in\n        stmt_info.\n        (STMT_VINFO_IN_PATTERN_P, STMT_VINFO_RELATED_STMT): New macros.\n        (vect_recog_func_ptr): New function-pointer type.\n        * tree-vect-patterns.c: New file.\n        (vect_recog_widen_sum_pattern, vect_recog_widen_mult_pattern):\n        (vect_recog_dot_prod_pattern, vect_pattern_recog):\n        (vect_pattern_recog_1): New functions.\n        (vect_pattern_recog_funcs): New array of function pointers.\n\n        * tree-vectorizer.h (ternary_op): New enum value.\n        * tree-vect-transform.c (vect_create_epilog_for_reduction): Added\n        declaration. Revised documentation. Removed redundant dump prints.\n        Removed redundant argument. Added support for reduction patterns.\n        (vectorizable_reduction): Added support for reduction patterns.\n        (vect_transform_stmt): Added support for patterns.\n\n        * expr.c (expand_expr_real_1): Added case for DOT_PROD_EXPR.\n        * genopinit.c (udot_prod_optab, sdot_prod_optab): Initialize.\n        * optabs.c (optab_for_tree_code): Added case for DOT_PROD_EXPR.\n        (expand_widen_pattern_expr): New function.\n        (init_optabs): Initialize new optabs udot_prod_optab,\n        sdot_prod_optab.\n        * optabs.h (OTI_sdot_prod, OTI_udot_prod): New.\n        (sdot_prod_optab, udot_prod_optab): Define new optabs.\n        (expand_widen_pattern_expr): New function declaration.\n        * tree.def (DOT_PROD_EXPR, WIDEN_SUM_EXPR, WIDEN_MULT_EXPR): New\n        tree-codes.\n        * tree-inline.c (estimate_num_insns_1): Added cases for new\n        tree-codes DOT_PROD_EXPR, WIDEN_SUM_EXPR, WIDEN_MULT_EXPR.\n        * tree-pretty-print.c (dump_generic_node): Likewise.\n        (op_prio): Likewise.\n        (op_symbol): Added cases for WIDEN_SUM_EXPR, WIDEN_MULT_EXPR.\n        * tree-ssa-operands.c (get_expr_operands): Added case for\n        DOT_PROD_EXPR.\n        * tree-vect-patterns.c (widened_name_p): New function.\n        (vect_recog_dot_prod_pattern): Added function implementation.\n        * tree-vect-transform.c (get_initial_def_for_reduction): Added\n        cases for DOT_PROD_EXPR, WIDEN_SUM_EXPR.\n        * config/rs6000/altivec.md (udot_prod<mode>, sdot_prodv8hi): New.\n        * config/i386/sse.md (sdot_prodv8hi, udot_prodv4si): New.\n\n        * expr.c (expand_expr_real_1): Added case for WIDEN_SUM_EXPR.\n        * genopinit.c (widen_ssum_optab, widen_usum_optab): Initialize.\n        * optabs.c (optab_for_tree_code): Added case for WIDEN_SUM_EXPR.\n        (init_optabs): Initialize new optabs widen_ssum_optab,\n        widen_usum_optab.\n        * optabs.h (OTI_widen_ssum, OTI_widen_usum): New.\n        (widen_ssum_optab, widen_usum_optab): Define new optabs.\n        * tree-vect-generic.c: (expand_vector_operations_1): Check type of\n        use instead of type of def.\n        * tree-vect-patterns.c (vect_recog_widen_sum_pattern): Added\n        function implementation.\n        * config/rs6000/altivec.md (widen_usum<mode>, widen_ssumv16qi,\n        widen_ssumv8hi): New.\n\n        * doc/tm.texi (ssum_widen, usum_widen, sdot_prod, udot_prod): New\n        patterns.\n\nFrom-SVN: r109954", "tree": {"sha": "ea695128e2e8754b43a2c74530a77e2dab617567", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea695128e2e8754b43a2c74530a77e2dab617567"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20f0622174914622858a91a712e57ace4a44d793", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20f0622174914622858a91a712e57ace4a44d793", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20f0622174914622858a91a712e57ace4a44d793", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20f0622174914622858a91a712e57ace4a44d793/comments", "author": null, "committer": null, "parents": [{"sha": "681f47f25ded25effb19bc87d3f1f659f0354746", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/681f47f25ded25effb19bc87d3f1f659f0354746", "html_url": "https://github.com/Rust-GCC/gccrs/commit/681f47f25ded25effb19bc87d3f1f659f0354746"}], "stats": {"total": 2452, "additions": 2284, "deletions": 168}, "files": [{"sha": "510e1a761e00eb4d86e99c0483cf8bb62bce73da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -1,3 +1,71 @@\n+2006-01-19  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* Makefile.in (tree-vect-patterns.o): Add rule for new file.\n+\t* tree-vect-analyze.c (vect_determine_vectorization_factor): Use\n+\texisting STMT_VINFO_VECTYPE if available.\n+\t(vect_mark_relevant): Add special handling for stmts that are\n+\tmarked as STMT_VINFO_IN_PATTERN_P.\n+\t(vect_analyze_loop): Call vect_pattern_recog.\n+\t* tree-vectorizer.c (new_stmt_vec_info): Initialize new fields.\n+\t* tree-vectorizer.h (in_pattern_p, related_stmt): New fields in\n+\tstmt_info.\n+\t(STMT_VINFO_IN_PATTERN_P, STMT_VINFO_RELATED_STMT): New macros.\n+\t(vect_recog_func_ptr): New function-pointer type.\n+\t* tree-vect-patterns.c: New file.\n+\t(vect_recog_widen_sum_pattern, vect_recog_widen_mult_pattern):\n+\t(vect_recog_dot_prod_pattern, vect_pattern_recog):\n+\t(vect_pattern_recog_1): New functions.\n+\t(vect_pattern_recog_funcs): New array of function pointers.\n+\n+\t* tree-vectorizer.h (ternary_op): New enum value.\n+\t* tree-vect-transform.c (vect_create_epilog_for_reduction): Added\n+\tdeclaration. Revised documentation. Removed redundant dump prints.\n+\tRemoved redundant argument. Added support for reduction patterns.\n+\t(vectorizable_reduction): Added support for reduction patterns.\n+\t(vect_transform_stmt): Added support for patterns.\n+\n+\t* expr.c (expand_expr_real_1): Added case for DOT_PROD_EXPR.\n+\t* genopinit.c (udot_prod_optab, sdot_prod_optab): Initialize.\n+\t* optabs.c (optab_for_tree_code): Added case for DOT_PROD_EXPR.\n+\t(expand_widen_pattern_expr): New function.\n+\t(init_optabs): Initialize new optabs udot_prod_optab,\n+\tsdot_prod_optab.\n+\t* optabs.h (OTI_sdot_prod, OTI_udot_prod): New.\n+\t(sdot_prod_optab, udot_prod_optab): Define new optabs.\n+\t(expand_widen_pattern_expr): New function declaration.\n+\t* tree.def (DOT_PROD_EXPR, WIDEN_SUM_EXPR, WIDEN_MULT_EXPR): New\n+\ttree-codes.\n+\t* tree-inline.c (estimate_num_insns_1): Added cases for new\n+\ttree-codes DOT_PROD_EXPR, WIDEN_SUM_EXPR, WIDEN_MULT_EXPR.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\t(op_prio): Likewise.\n+\t(op_symbol): Added cases for WIDEN_SUM_EXPR, WIDEN_MULT_EXPR.\n+\t* tree-ssa-operands.c (get_expr_operands): Added case for\n+\tDOT_PROD_EXPR.\n+\t* tree-vect-patterns.c (widened_name_p): New function.\n+\t(vect_recog_dot_prod_pattern): Added function implementation.\n+\t* tree-vect-transform.c (get_initial_def_for_reduction): Added\n+\tcases for DOT_PROD_EXPR, WIDEN_SUM_EXPR.\n+\t* config/rs6000/altivec.md (udot_prod<mode>, sdot_prodv8hi): New.\n+\t* config/i386/sse.md (sdot_prodv8hi, udot_prodv4si): New.\n+\n+\t* expr.c (expand_expr_real_1): Added case for WIDEN_SUM_EXPR.\n+\t* genopinit.c (widen_ssum_optab, widen_usum_optab): Initialize.\n+\t* optabs.c (optab_for_tree_code): Added case for WIDEN_SUM_EXPR.\n+\t(init_optabs): Initialize new optabs widen_ssum_optab,\n+\twiden_usum_optab.\n+\t* optabs.h (OTI_widen_ssum, OTI_widen_usum): New.\n+\t(widen_ssum_optab, widen_usum_optab): Define new optabs.\n+\t* tree-vect-generic.c: (expand_vector_operations_1): Check type of\n+\tuse instead of type of def.\n+\t* tree-vect-patterns.c (vect_recog_widen_sum_pattern): Added\n+\tfunction implementation.\n+\t* config/rs6000/altivec.md (widen_usum<mode>, widen_ssumv16qi,\n+\twiden_ssumv8hi): New.\n+\n+\t* doc/tm.texi (ssum_widen, usum_widen, sdot_prod, udot_prod): New\n+\tpatterns.\n+\n 2006-01-19  Richard Sandiford  <richard@codesourcery.com>\n \n \tPR c/25805"}, {"sha": "e1c6a1d84e3719cd9b6f0ebdcc358975796dfc96", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -967,6 +967,7 @@ OBJS-common = \\\n  tree-vect-generic.o tree-ssa-loop.o tree-ssa-loop-niter.o\t\t   \\\n  tree-ssa-loop-manip.o tree-ssa-threadupdate.o\t\t\t\t   \\\n  tree-vectorizer.o tree-vect-analyze.o tree-vect-transform.o\t\t   \\\n+ tree-vect-patterns.o                                                      \\\n  tree-ssa-loop-ivcanon.o tree-ssa-propagate.o tree-ssa-address.o\t   \\\n  tree-ssa-math-opts.o\t\t\t\t\t\t\t   \\\n  tree-ssa-loop-ivopts.o tree-if-conv.o tree-ssa-loop-unswitch.o\t\t   \\\n@@ -2065,6 +2066,10 @@ tree-vect-analyze.o: tree-vect-analyze.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(OPTABS_H) $(TREE_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\\n    tree-vectorizer.h $(TREE_DATA_REF_H) $(SCEV_H) $(EXPR_H) tree-chrec.h\n+tree-vect-patterns.o: tree-vect-patterns.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TM_H) errors.h $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) \\\n+   diagnostic.h $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) cfgloop.h \\\n+   tree-vectorizer.h tree-data-ref.h $(EXPR_H)\n tree-vect-transform.o: tree-vect-transform.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(GGC_H) $(OPTABS_H) $(RECOG_H) $(TREE_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) \\"}, {"sha": "88c7adf081d619f7b53f8da6ab30f47d9cda2c41", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -1,5 +1,5 @@\n ;; GCC machine description for SSE instructions\n-;; Copyright (C) 2005\n+;; Copyright (C) 2005, 2006\n ;; Free Software Foundation, Inc.\n ;;\n ;; This file is part of GCC.\n@@ -2700,6 +2700,48 @@\n   DONE;\n })\n \n+(define_expand \"sdot_prodv8hi\"\n+  [(match_operand:V4SI 0 \"register_operand\" \"\")\n+   (match_operand:V8HI 1 \"nonimmediate_operand\" \"\")\n+   (match_operand:V8HI 2 \"nonimmediate_operand\" \"\")\n+   (match_operand:V4SI 3 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  rtx t = gen_reg_rtx (V4SImode);\n+  emit_insn (gen_sse2_pmaddwd (t, operands[1], operands[2]));\n+  emit_insn (gen_addv4si3 (operands[0], operands[3], t));\n+  DONE;\n+})\n+\n+(define_expand \"udot_prodv4si\"\n+  [(match_operand:V2DI 0 \"register_operand\" \"\") \n+   (match_operand:V4SI 1 \"register_operand\" \"\") \n+   (match_operand:V4SI 2 \"register_operand\" \"\")\n+   (match_operand:V2DI 3 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  rtx t1, t2, t3, t4;\n+\n+  t1 = gen_reg_rtx (V2DImode);\n+  emit_insn (gen_sse2_umulv2siv2di3 (t1, operands[1], operands[2]));\n+  emit_insn (gen_addv2di3 (t1, t1, operands[3]));\n+\n+  t2 = gen_reg_rtx (V4SImode);\n+  t3 = gen_reg_rtx (V4SImode);\n+  emit_insn (gen_sse2_lshrti3 (gen_lowpart (TImode, t2),\n+                               gen_lowpart (TImode, operands[1]),\n+                               GEN_INT (32)));\n+  emit_insn (gen_sse2_lshrti3 (gen_lowpart (TImode, t3),\n+                               gen_lowpart (TImode, operands[2]),\n+                               GEN_INT (32)));\n+\n+  t4 = gen_reg_rtx (V2DImode);\n+  emit_insn (gen_sse2_umulv2siv2di3 (t4, t2, t3));\n+\n+  emit_insn (gen_addv2di3 (operands[0], t1, t4));\n+  DONE;\n+})\n+\n (define_insn \"ashr<mode>3\"\n   [(set (match_operand:SSEMODE24 0 \"register_operand\" \"=x\")\n \t(ashiftrt:SSEMODE24"}, {"sha": "d4bf08e228ce125f13ae4fc92b56e735c19f0829", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 72, "deletions": 1, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -1,5 +1,5 @@\n ;; AltiVec patterns.\n-;; Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+;; Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n ;; Contributed by Aldy Hernandez (aldy@quesejoda.com)\n \n ;; This file is part of GCC.\n@@ -2150,6 +2150,77 @@\n   DONE;\n }\")\n \n+(define_expand \"udot_prod<mode>\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+        (plus:V4SI (match_operand:V4SI 3 \"register_operand\" \"v\")\n+                   (unspec:V4SI [(match_operand:VIshort 1 \"register_operand\" \"v\")  \n+                                 (match_operand:VIshort 2 \"register_operand\" \"v\")] \n+                                UNSPEC_VMSUMU)))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{  \n+  emit_insn (gen_altivec_vmsumu<VI_char>m (operands[0], operands[1], operands[2], operands[3]));\n+  DONE;\n+}\")\n+   \n+(define_expand \"sdot_prodv8hi\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+        (plus:V4SI (match_operand:V4SI 3 \"register_operand\" \"v\")\n+                   (unspec:V4SI [(match_operand:V8HI 1 \"register_operand\" \"v\")\n+                                 (match_operand:V8HI 2 \"register_operand\" \"v\")]\n+                                UNSPEC_VMSUMSHM)))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  emit_insn (gen_altivec_vmsumshm (operands[0], operands[1], operands[2], operands[3]));\n+  DONE;\n+}\")\n+\n+(define_expand \"widen_usum<mode>3\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+        (plus:V4SI (match_operand:V4SI 2 \"register_operand\" \"v\")\n+                   (unspec:V4SI [(match_operand:VIshort 1 \"register_operand\" \"v\")]\n+                                UNSPEC_VMSUMU)))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  rtx vones = gen_reg_rtx (GET_MODE (operands[1]));\n+\n+  emit_insn (gen_altivec_vspltis<VI_char> (vones, const1_rtx));\n+  emit_insn (gen_altivec_vmsumu<VI_char>m (operands[0], operands[1], vones, operands[2]));\n+  DONE;\n+}\")\n+\n+(define_expand \"widen_ssumv16qi3\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+        (plus:V4SI (match_operand:V4SI 2 \"register_operand\" \"v\")\n+                   (unspec:V4SI [(match_operand:V16QI 1 \"register_operand\" \"v\")]\n+                                UNSPEC_VMSUMM)))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  rtx vones = gen_reg_rtx (V16QImode);\n+\n+  emit_insn (gen_altivec_vspltisb (vones, const1_rtx));\n+  emit_insn (gen_altivec_vmsummbm (operands[0], operands[1], vones, operands[2]));\n+  DONE;\n+}\")\n+\n+(define_expand \"widen_ssumv8hi3\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+        (plus:V4SI (match_operand:V4SI 2 \"register_operand\" \"v\")\n+                   (unspec:V4SI [(match_operand:V8HI 1 \"register_operand\" \"v\")]\n+                                UNSPEC_VMSUMSHM)))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  rtx vones = gen_reg_rtx (V8HImode);\n+\n+  emit_insn (gen_altivec_vspltish (vones, const1_rtx));\n+  emit_insn (gen_altivec_vmsumshm (operands[0], operands[1], vones, operands[2]));\n+  DONE;\n+}\")\n+\n (define_expand \"negv4sf2\"\n   [(use (match_operand:V4SF 0 \"register_operand\" \"\"))\n    (use (match_operand:V4SF 1 \"register_operand\" \"\"))]"}, {"sha": "b6dd8382f8e8f7fb52a3b0e31f182762eed9174d", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -1,5 +1,5 @@\n @c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1996, 1998, 1999, 2000, 2001,\n-@c 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+@c 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n@@ -3099,6 +3099,25 @@ Compute the sum of the unsigned elements of a vector. The vector is operand 1,\n and the scalar result is stored in the least significant bits of operand 0\n (also a vector). The output and input vector should have the same modes.\n \n+@cindex @code{sdot_prod@var{m}} instruction pattern\n+@item @samp{sdot_prod@var{m}}\n+@cindex @code{udot_prod@var{m}} instruction pattern\n+@item @samp{udot_prod@var{m}}\n+Compute the sum of the products of two signed/unsigned elements. \n+Operand 1 and operand 2 are of the same mode. Their product, which is of a \n+wider mode, is computed and added to operand 3. Operand 3 is of a mode equal or \n+wider than the mode of the product. The result is placed in operand 0, which\n+is of the same mode as operand 3. \n+\n+@cindex @code{ssum_widen@var{m3}} instruction pattern\n+@item @samp{ssum_widen@var{m3}}\n+@cindex @code{usum_widen@var{m3}} instruction pattern\n+@item @samp{usum_widen@var{m3}}\n+Operands 0 and 2 are of the same mode, which is wider than the mode of \n+operand 1. Add operand 1 to operand 2 and place the widened result in\n+operand 0. (This is used express accumulation of elements into an accumulator\n+of a wider mode.)\n+\n @cindex @code{vec_shl_@var{m}} instruction pattern\n @cindex @code{vec_shr_@var{m}} instruction pattern\n @item @samp{vec_shl_@var{m}}, @samp{vec_shr_@var{m}}"}, {"sha": "b15b43cb7d9a93b5159a657cdd5c7a44945ec8a0", "filename": "gcc/expr.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -8553,6 +8553,31 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n         return temp;\n       }\n \n+    case DOT_PROD_EXPR:\n+      {\n+\ttree oprnd0 = TREE_OPERAND (exp, 0);\n+\ttree oprnd1 = TREE_OPERAND (exp, 1);\n+\ttree oprnd2 = TREE_OPERAND (exp, 2);\n+\trtx op2;\n+\n+\texpand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, 0);\n+\top2 = expand_expr (oprnd2, NULL_RTX, VOIDmode, 0);\n+\ttarget = expand_widen_pattern_expr (exp, op0, op1, op2, \n+\t\t\t\t\t    target, unsignedp);\n+\treturn target;\n+      }\n+\n+    case WIDEN_SUM_EXPR:\n+      {\n+        tree oprnd0 = TREE_OPERAND (exp, 0);\n+        tree oprnd1 = TREE_OPERAND (exp, 1);\n+                                                                               \n+        expand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, 0);\n+        target = expand_widen_pattern_expr (exp, op0, NULL_RTX, op1,\n+                                            target, unsignedp);\n+        return target;\n+      }\n+\n     case REDUC_MAX_EXPR:\n     case REDUC_MIN_EXPR:\n     case REDUC_PLUS_EXPR:"}, {"sha": "d9582202b3b99a5f5592a8e5c06f4b12a4993b9d", "filename": "gcc/genopinit.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -1,6 +1,6 @@\n /* Generate code to initialize optabs from machine description.\n    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -203,6 +203,10 @@ static const char * const optabs[] =\n   \"vec_realign_load_optab->handlers[$A].insn_code = CODE_FOR_$(vec_realign_load_$a$)\",\n   \"vcond_gen_code[$A] = CODE_FOR_$(vcond$a$)\",\n   \"vcondu_gen_code[$A] = CODE_FOR_$(vcondu$a$)\",\n+  \"ssum_widen_optab->handlers[$A].insn_code = CODE_FOR_$(widen_ssum$I$a3$)\",\n+  \"usum_widen_optab->handlers[$A].insn_code = CODE_FOR_$(widen_usum$I$a3$)\",\n+  \"udot_prod_optab->handlers[$A].insn_code = CODE_FOR_$(udot_prod$I$a$)\",\n+  \"sdot_prod_optab->handlers[$A].insn_code = CODE_FOR_$(sdot_prod$I$a$)\",\n   \"reduc_smax_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_smax_$a$)\",\n   \"reduc_umax_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_umax_$a$)\",\n   \"reduc_smin_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_smin_$a$)\","}, {"sha": "da5251c554be29e0f3c6c4bc076d85e2bad6d29e", "filename": "gcc/optabs.c", "status": "modified", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -294,6 +294,12 @@ optab_for_tree_code (enum tree_code code, tree type)\n     case REALIGN_LOAD_EXPR:\n       return vec_realign_load_optab;\n \n+    case WIDEN_SUM_EXPR:\n+      return TYPE_UNSIGNED (type) ? usum_widen_optab : ssum_widen_optab;\n+\n+    case DOT_PROD_EXPR:\n+      return TYPE_UNSIGNED (type) ? udot_prod_optab : sdot_prod_optab;\n+\n     case REDUC_MAX_EXPR:\n       return TYPE_UNSIGNED (type) ? reduc_umax_optab : reduc_smax_optab;\n \n@@ -337,6 +343,154 @@ optab_for_tree_code (enum tree_code code, tree type)\n }\n \f\n \n+/* Expand vector widening operations.\n+\n+   There are two different classes of operations handled here:\n+   1) Operations whose result is wider than all the arguments to the operation.\n+      Examples: VEC_UNPACK_HI/LO_EXPR, VEC_WIDEN_MULT_HI/LO_EXPR\n+      In this case OP0 and optionally OP1 would be initialized,\n+      but WIDE_OP wouldn't (not relevant for this case).\n+   2) Operations whose result is of the same size as the last argument to the\n+      operation, but wider than all the other arguments to the operation.\n+      Examples: WIDEN_SUM_EXPR, VEC_DOT_PROD_EXPR.\n+      In the case WIDE_OP, OP0 and optionally OP1 would be initialized.\n+\n+   E.g, when called to expand the following operations, this is how\n+   the arguments will be initialized:\n+                                nops    OP0     OP1     WIDE_OP\n+   widening-sum                 2       oprnd0  -       oprnd1          \n+   widening-dot-product         3       oprnd0  oprnd1  oprnd2\n+   widening-mult                2       oprnd0  oprnd1  -\n+   type-promotion (vec-unpack)  1       oprnd0  -       -  */\n+\n+rtx\n+expand_widen_pattern_expr (tree exp, rtx op0, rtx op1, rtx wide_op, rtx target,\n+                           int unsignedp)\n+{   \n+  tree oprnd0, oprnd1, oprnd2;\n+  enum machine_mode wmode = 0, tmode0, tmode1 = 0;\n+  optab widen_pattern_optab;\n+  int icode; \n+  enum machine_mode xmode0, xmode1 = 0, wxmode = 0;\n+  rtx temp;\n+  rtx pat;\n+  rtx xop0, xop1, wxop;\n+  int nops = TREE_CODE_LENGTH (TREE_CODE (exp));\n+\n+  oprnd0 = TREE_OPERAND (exp, 0);\n+  tmode0 = TYPE_MODE (TREE_TYPE (oprnd0));\n+  widen_pattern_optab =\n+        optab_for_tree_code (TREE_CODE (exp), TREE_TYPE (oprnd0));\n+  icode = (int) widen_pattern_optab->handlers[(int) tmode0].insn_code;\n+  gcc_assert (icode != CODE_FOR_nothing);\n+  xmode0 = insn_data[icode].operand[1].mode;\n+\n+  if (nops >= 2)\n+    {\n+      oprnd1 = TREE_OPERAND (exp, 1);\n+      tmode1 = TYPE_MODE (TREE_TYPE (oprnd1));\n+      xmode1 = insn_data[icode].operand[2].mode;\n+    }\n+\n+  /* The last operand is of a wider mode than the rest of the operands.  */\n+  if (nops == 2)\n+    {\n+      wmode = tmode1;\n+      wxmode = xmode1;\n+    }\n+  else if (nops == 3)\n+    {\n+      gcc_assert (tmode1 == tmode0);\n+      gcc_assert (op1);\n+      oprnd2 = TREE_OPERAND (exp, 2);\n+      wmode = TYPE_MODE (TREE_TYPE (oprnd2));\n+      wxmode = insn_data[icode].operand[3].mode;\n+    }\n+\n+  if (!wide_op)\n+    wmode = wxmode = insn_data[icode].operand[0].mode;\n+\n+  if (!target\n+      || ! (*insn_data[icode].operand[0].predicate) (target, wmode))\n+    temp = gen_reg_rtx (wmode);\n+  else\n+    temp = target;\n+\n+  xop0 = op0;\n+  xop1 = op1;\n+  wxop = wide_op;\n+\n+  /* In case the insn wants input operands in modes different from\n+     those of the actual operands, convert the operands.  It would\n+     seem that we don't need to convert CONST_INTs, but we do, so\n+     that they're properly zero-extended, sign-extended or truncated\n+     for their mode.  */\n+\n+  if (GET_MODE (op0) != xmode0 && xmode0 != VOIDmode)\n+    xop0 = convert_modes (xmode0,\n+                          GET_MODE (op0) != VOIDmode\n+                          ? GET_MODE (op0)\n+                          : tmode0,\n+                          xop0, unsignedp);\n+\n+  if (op1)\n+    if (GET_MODE (op1) != xmode1 && xmode1 != VOIDmode)\n+      xop1 = convert_modes (xmode1,\n+                            GET_MODE (op1) != VOIDmode\n+                            ? GET_MODE (op1)\n+                            : tmode1,\n+                            xop1, unsignedp);\n+\n+  if (wide_op)\n+    if (GET_MODE (wide_op) != wxmode && wxmode != VOIDmode)\n+      wxop = convert_modes (wxmode,\n+                            GET_MODE (wide_op) != VOIDmode\n+                            ? GET_MODE (wide_op)\n+                            : wmode,\n+                            wxop, unsignedp);\n+\n+  /* Now, if insn's predicates don't allow our operands, put them into\n+     pseudo regs.  */\n+\n+  if (! (*insn_data[icode].operand[1].predicate) (xop0, xmode0)\n+      && xmode0 != VOIDmode)\n+    xop0 = copy_to_mode_reg (xmode0, xop0);\n+\n+  if (op1)\n+    {\n+      if (! (*insn_data[icode].operand[2].predicate) (xop1, xmode1)\n+          && xmode1 != VOIDmode)\n+        xop1 = copy_to_mode_reg (xmode1, xop1);\n+\n+      if (wide_op)\n+        {\n+          if (! (*insn_data[icode].operand[3].predicate) (wxop, wxmode)\n+              && wxmode != VOIDmode)\n+            wxop = copy_to_mode_reg (wxmode, wxop);\n+\n+          pat = GEN_FCN (icode) (temp, xop0, xop1, wxop);\n+        }\n+      else\n+        pat = GEN_FCN (icode) (temp, xop0, xop1);\n+    }\n+  else\n+    {\n+      if (wide_op)\n+        {\n+          if (! (*insn_data[icode].operand[2].predicate) (wxop, wxmode)\n+              && wxmode != VOIDmode)\n+            wxop = copy_to_mode_reg (wxmode, wxop);\n+\n+          pat = GEN_FCN (icode) (temp, xop0, wxop);\n+        }\n+      else\n+        pat = GEN_FCN (icode) (temp, xop0);\n+    }\n+\n+  emit_insn (pat);\n+  return temp;\n+}\n+\n /* Generate code to perform an operation specified by TERNARY_OPTAB\n    on operands OP0, OP1 and OP2, with result having machine-mode MODE.\n \n@@ -5139,6 +5293,11 @@ init_optabs (void)\n   reduc_splus_optab = init_optab (UNKNOWN);\n   reduc_uplus_optab = init_optab (UNKNOWN);\n \n+  ssum_widen_optab = init_optab (UNKNOWN);\n+  usum_widen_optab = init_optab (UNKNOWN);\n+  sdot_prod_optab = init_optab (UNKNOWN); \n+  udot_prod_optab = init_optab (UNKNOWN);\n+\n   vec_extract_optab = init_optab (UNKNOWN);\n   vec_set_optab = init_optab (UNKNOWN);\n   vec_init_optab = init_optab (UNKNOWN);"}, {"sha": "58fb6905175c54a846f9086739489be4958e5806", "filename": "gcc/optabs.h", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -1,5 +1,6 @@\n /* Definitions for code generation pass of GNU compiler.\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006 \n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -241,6 +242,14 @@ enum optab_index\n   OTI_reduc_splus,\n   OTI_reduc_uplus,\n \n+  /* Summation, with result machine mode one or more wider than args.  */\n+  OTI_ssum_widen,\n+  OTI_usum_widen,\n+\n+  /* Dot product, with result machine mode one or more wider than args.  */\n+  OTI_sdot_prod,\n+  OTI_udot_prod,\n+\n   /* Set specified field of vector operand.  */\n   OTI_vec_set,\n   /* Extract specified field of vector operand.  */\n@@ -367,6 +376,11 @@ extern GTY(()) optab optab_table[OTI_MAX];\n #define reduc_umin_optab (optab_table[OTI_reduc_umin])\n #define reduc_splus_optab (optab_table[OTI_reduc_splus])\n #define reduc_uplus_optab (optab_table[OTI_reduc_uplus])\n+                                                                                \n+#define ssum_widen_optab (optab_table[OTI_ssum_widen])\n+#define usum_widen_optab (optab_table[OTI_usum_widen])\n+#define sdot_prod_optab (optab_table[OTI_sdot_prod])\n+#define udot_prod_optab (optab_table[OTI_udot_prod])\n \n #define vec_set_optab (optab_table[OTI_vec_set])\n #define vec_extract_optab (optab_table[OTI_vec_extract])\n@@ -495,6 +509,9 @@ extern enum insn_code sync_lock_release[NUM_MACHINE_MODES];\n \n /* Define functions given in optabs.c.  */\n \n+extern rtx expand_widen_pattern_expr (tree exp, rtx op0, rtx op1, rtx wide_op,\n+                                      rtx target, int unsignedp);\n+\n extern rtx expand_ternary_op (enum machine_mode mode, optab ternary_optab,\n \t\t\t      rtx op0, rtx op1, rtx op2, rtx target,\n \t\t\t      int unsignedp);"}, {"sha": "c54f6b0868d9e41d6651fda724845dd662a7d123", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -1,3 +1,22 @@\n+2006-01-19  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* lib/target-suports.exp (check_effective_target_vect_sdot_qi): New.\n+\t(check_effective_target_vect_udot_qi): New.\n+\t(check_effective_target_vect_sdot_hi): New.\n+\t(check_effective_target_vect_udot_hi): New.\n+\t* gcc.dg/vect/vect.exp: Use dump-details, and compile testcases\n+\tprefixed with \"wrapv-\" with -fwrapv.\n+\t* gcc.dg/vect/wrapv-vect-reduc-dot-s8.c: New.\n+\t* gcc.dg/vect/vect-reduc-dot-u8.c: New.\n+\t* gcc.dg/vect/vect-reduc-dot-u16.c: New.\n+\t* gcc.dg/vect/vect-reduc-dot-s8.c: New.\n+\t* gcc.dg/vect/vect-reduc-dot-s16.c: New.\n+\n+\t* lib/target-suports.exp (check_effective_target_vect_widen_sum): New.\n+\t* gcc.dg/vect/vect-reduc-pattern-1.c: New.\n+\t* gcc.dg/vect/vect-reduc-pattern-2.c: New.\n+\t* gcc.dg/vect/wrapv-vect-reduc-pattern-2.c: New.\n+\n 2006-01-19  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/16829"}, {"sha": "ddffc109d35f82b075e0adaefd701cbcc798b3ca", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-s16.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-s16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-s16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-s16.c?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+#define DOT1 43680\n+#define DOT2 43680\n+\n+signed short X[N] __attribute__ ((__aligned__(16)));\n+signed short Y[N] __attribute__ ((__aligned__(16)));\n+\n+/* short->short->int dot product. \n+   Not detected as a dot-product pattern.\n+   Currently fails to be vectorized due to presence of type conversions. */\n+int\n+foo1(int len) {\n+  int i;\n+  int result = 0;\n+  short prod;\n+\n+  for (i=0; i<len; i++) {\n+    prod = X[i] * Y[i];\n+    result += prod;\n+  }\n+  return result;\n+}\n+\n+/* short->int->int dot product.\n+   Detected as a dot-product pattern.\n+   Vectorized on targets that support dot-product for signed shorts.  */ \n+int\n+foo2(int len) {\n+  int i;\n+  int result = 0;\n+\n+  for (i=0; i<len; i++) {\n+    result += (X[i] * Y[i]);\n+  }\n+  return result;\n+}\n+\n+\n+int main (void)\n+{\n+  int i, dot1, dot2;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+  }\n+\n+  dot1 = foo1 (N);\n+  if (dot1 != DOT1)\n+    abort ();\n+\n+  dot2 = foo2 (N);\n+  if (dot2 != DOT2)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_dot_prod_pattern: detected\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_sdot_hi } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "8e5d48035b304195bf933b9952e27a016b8e0167", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-s8.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-s8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-s8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-s8.c?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -0,0 +1,111 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+#define DOT1 43680\n+#define DOT2 -21856\n+#define DOT3 43680\n+\n+signed char X[N] __attribute__ ((__aligned__(16)));\n+signed char Y[N] __attribute__ ((__aligned__(16)));\n+\n+/* char->short->int dot product.\n+   The dot-product pattern should be detected.\n+   Vectorizable on vect_sdot_qi targets (targets that support dot-product of \n+   signed chars).\n+\n+   In the future could also be vectorized as widening-mult + widening-summation,\n+   or with type-conversion support.\n+ */\n+int\n+foo1(int len) {\n+  int i;\n+  int result = 0;\n+  short prod;\n+\n+  for (i=0; i<len; i++) {\n+    prod = X[i] * Y[i];\n+    result += prod;\n+  }\n+  return result;\n+}\n+\n+/* char->short->short dot product.\n+   The dot-product pattern should be detected.\n+   The reduction is currently not vectorized becaus of the signed->unsigned->signed\n+   casts, since this patch:\n+\n+     2005-12-26  Kazu Hirata  <kazu@codesourcery.com>\n+                                                                                                \n+        PR tree-optimization/25125\n+\n+   When the dot-product is detected, the loop should be vectorized on vect_sdot_qi \n+   targets (targets that support dot-product of signed char).  \n+   This test would currently fail to vectorize on targets that support\n+   dot-product of chars when the accumulator is int.\n+\n+   In the future could also be vectorized as widening-mult + summation,\n+   or with type-conversion support.\n+ */\n+short\n+foo2(int len) {\n+  int i;\n+  short result = 0;\n+\n+  for (i=0; i<len; i++) {\n+    result += (X[i] * Y[i]);\n+  }\n+  return result;\n+}\n+\n+/* char->int->int dot product. \n+   Not detected as a dot-product pattern.\n+   Currently fails to be vectorized due to presence of type conversions. */\n+int\n+foo3(int len) {\n+  int i;\n+  int result = 0;\n+\n+  for (i=0; i<len; i++) {\n+    result += (X[i] * Y[i]);\n+  }\n+  return result;\n+}\n+\n+int main (void)\n+{\n+  int i, dot1, dot3;\n+  short dot2;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+  }\n+\n+  dot1 = foo1 (N);\n+  if (dot1 != DOT1)\n+    abort ();\n+\n+  dot2 = foo2 (N);\n+  if (dot2 != DOT2)\n+    abort ();\n+\n+  dot3 = foo3 (N);\n+  if (dot3 != DOT3)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_dot_prod_pattern: detected\" 2 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_dot_prod_pattern: detected\" 1 \"vect\" } } */\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_sdot_qi } } } */\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "03db7e0b6a6c55908706b53fc0b33ec53e42c7e4", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-u16.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u16.c?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+#define DOT1 43680\n+#define DOT2 43680\n+\n+unsigned short X[N] __attribute__ ((__aligned__(16)));\n+unsigned short Y[N] __attribute__ ((__aligned__(16)));\n+\n+/* short->short->int dot product. \n+   Not detected as a dot-product pattern.\n+   Not vectorized due to presence of type-conversions. */\n+unsigned int\n+foo1(int len) {\n+  int i;\n+  unsigned int result = 0;\n+  unsigned short prod;\n+\n+  for (i=0; i<len; i++) {\n+    prod = X[i] * Y[i];\n+    result += prod;\n+  }\n+  return result;\n+}\n+\n+/* short->int->int dot product. \n+   Currently not detected as a dot-product pattern: the multiplication \n+   promotes the ushorts to int, and then the product is promoted to unsigned \n+   int for the addition.  Which results in an int->unsigned int cast, which \n+   since no bits are modified in the cast should be trivially vectorizable.  */\n+unsigned int\n+foo2(int len) {\n+  int i;\n+  unsigned int result = 0;\n+\n+  for (i=0; i<len; i++) {\n+    result += (X[i] * Y[i]);\n+  }\n+  return result;\n+}\n+\n+\n+int main (void)\n+{\n+  unsigned int dot1, dot2;\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+  }\n+\n+  dot1 = foo1 (N);\n+  if (dot1 != DOT1)\n+    abort ();\n+\n+  dot2 = foo2 (N);\n+  if (dot2 != DOT2)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_dot_prod_pattern: detected\" 1 \"vect\" { xfail *-*-* } } } */\n+\n+/* Once the dot-product pattern is detected in the second loop, we expect\n+   that loop to be vectorized on vect_udot_hi targets (targets that support \n+   dot-product of unsigned shorts).  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */ \n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ad68bc752c5f673c6eab31afdf417b801f5e8b0f", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-u8.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u8.c?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -0,0 +1,101 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+#define DOT1 43680\n+#define DOT2 43680\n+#define DOT3 43680\n+\n+unsigned char X[N] __attribute__ ((__aligned__(16)));\n+unsigned char Y[N] __attribute__ ((__aligned__(16)));\n+\n+/* char->short->int dot product. \n+   Detected as a dot-product pattern.\n+   Should be vectorized on targets that support dot-product for unsigned chars.\n+   */\n+unsigned int\n+foo1(int len) {\n+  int i;\n+  unsigned int result = 0;\n+  unsigned short prod;\n+\n+  for (i=0; i<len; i++) {\n+    prod = X[i] * Y[i];\n+    result += prod;\n+  }\n+  return result;\n+}\n+\n+/* char->short->short dot product. \n+   Detected as a dot-product pattern.\n+   Should be vectorized on targets that support dot-product for unsigned chars.\n+   This test currently fails to vectorize on targets that support dot-product \n+   of chars only when the accumulator is int.\n+   */\n+unsigned short\n+foo2(int len) {\n+  int i;\n+  unsigned short result = 0;\n+\n+  for (i=0; i<len; i++) {\n+    result += (unsigned short)(X[i] * Y[i]);\n+  }\n+  return result;\n+}\n+\n+/* char->int->int dot product. \n+   Not detected as a dot-product.\n+   Doesn't get vectorized due to presence of type converisons.  */\n+unsigned int\n+foo3(int len) {\n+  int i;\n+  unsigned int result = 0;\n+\n+  for (i=0; i<len; i++) {\n+    result += (X[i] * Y[i]);\n+  }\n+  return result;\n+}\n+\n+int main (void)\n+{\n+  unsigned int dot1, dot3;\n+  unsigned short dot2;\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+  }\n+\n+  dot1 = foo1 (N);\n+  if (dot1 != DOT1)\n+    abort ();\n+\n+  dot2 = foo2 (N);\n+  if (dot2 != DOT2)\n+    abort ();\n+\n+  dot3 = foo3 (N);\n+  if (dot3 != DOT3)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_dot_prod_pattern: detected\" 2 \"vect\" } } */\n+\n+/* When the vectorizer is enhanced to vectorize foo2 (accumulation into short) for \n+   targets that support accumulation into int (powerpc, ia64) we'd have:\n+dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_udot_qi } }\n+*/\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_udot_qi } } } */\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "61f1da19d6e9524f1f2e6b8aa27a381278c94eba", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-1.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-pattern-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-pattern-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-pattern-1.c?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define SH_SUM 210\n+#define CH_SUM 120\n+\n+int main1 ()\n+{\n+  int i;\n+  unsigned short udata_sh[N] = {0,2,4,6,8,10,12,14,16,18,20,22,24,26,28};\n+  unsigned char udata_ch[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+  unsigned int intsum = 0;\n+  unsigned short shortsum = 0;\n+\n+  /* widenning sum: sum shorts into int.  */\n+  for (i = 0; i < N; i++){\n+    intsum += udata_sh[i];\n+  }\n+\n+  /* check results:  */\n+  if (intsum != SH_SUM)\n+    abort ();\n+\n+  /* widenning sum: sum chars into int.  */\n+  intsum = 0;\n+  for (i = 0; i < N; i++){\n+    intsum += udata_ch[i];\n+  }\n+\n+  /* check results:  */\n+  if (intsum != CH_SUM)\n+    abort ();\n+\n+  /* widenning sum: sum chars into short.  \n+     pattern detected, but not vectorized yet. */\n+  for (i = 0; i < N; i++){\n+    shortsum += udata_ch[i];\n+  }\n+\n+  /* check results:  */\n+  if (shortsum != CH_SUM)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_sum_pattern: detected\" 3 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { target vect_widen_sum } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "5423c4376d9fb951ebef7206e34430827d76ac09", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-2.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-pattern-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-pattern-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-pattern-2.c?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define SH_SUM 210\n+#define CH_SUM 120\n+\n+int main1 ()\n+{\n+  int i;\n+  signed short data_sh[N] = {0,2,4,6,8,10,12,14,16,18,20,22,24,26,28};\n+  signed char data_ch[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+  signed int intsum = 0;\n+  signed short shortsum = 0;\n+\n+  /* widenning sum: sum shorts into int.  */\n+  for (i = 0; i < N; i++){\n+    intsum += data_sh[i];\n+  }\n+\n+  /* check results:  */\n+  if (intsum != SH_SUM)\n+    abort ();\n+\n+  /* widenning sum: sum chars into int.  */\n+  intsum = 0;\n+  for (i = 0; i < N; i++){\n+    intsum += data_ch[i];\n+  }\n+\n+  /* check results:  */\n+  if (intsum != CH_SUM)\n+    abort ();\n+\n+  /* widenning sum: sum chars into short.\n+     The widening-summation pattern is currently not detected because of this\n+     patch:\n+\n+     2005-12-26  Kazu Hirata  <kazu@codesourcery.com>\n+                                                                                \n+        PR tree-optimization/25125\n+   */\n+  for (i = 0; i < N; i++){\n+    shortsum += data_ch[i];\n+  }\n+\n+  /* check results:  */\n+  if (shortsum != CH_SUM)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_sum_pattern: detected\" 3 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_sum_pattern: detected\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { target vect_widen_sum } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "9cf78ff85192d0737932be260949f03dbc3551c6", "filename": "gcc/testsuite/gcc.dg/vect/vect.exp", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -1,4 +1,4 @@\n-# Copyright (C) 1997, 2004 Free Software Foundation, Inc.\n+# Copyright (C) 1997, 2004, 2005, 2006 Free Software Foundation, Inc.\n \n # This program is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -78,7 +78,7 @@ dg-init\n dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/nodump-*.\\[cS\\]]]  \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n-lappend DEFAULT_VECTCFLAGS \"-ftree-vectorizer-verbose=4\" \"-fdump-tree-vect-stats\"\n+lappend DEFAULT_VECTCFLAGS \"-fdump-tree-vect-details\"\n \n # Main loop.\n dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/pr*.\\[cS\\]]]  \\\n@@ -96,6 +96,12 @@ lappend DEFAULT_VECTCFLAGS \"-ffast-math\"\n dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/fast-math-vect*.\\[cS\\]]]  \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n+# -fwrapv tests\n+set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n+lappend DEFAULT_VECTCFLAGS \"-fwrapv\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/wrapv-vect*.\\[cS\\]]]  \\\n+        \"\" $DEFAULT_VECTCFLAGS\n+\n # -ftrapv tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-ftrapv\""}, {"sha": "b11b9c70086a418e38d8be2a55b625361a299058", "filename": "gcc/testsuite/gcc.dg/vect/wrapv-vect-reduc-dot-s8.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fwrapv-vect-reduc-dot-s8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fwrapv-vect-reduc-dot-s8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fwrapv-vect-reduc-dot-s8.c?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -0,0 +1,108 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+#define DOT1 43680\n+#define DOT2 -21856\n+#define DOT3 43680\n+\n+signed char X[N] __attribute__ ((__aligned__(16)));\n+signed char Y[N] __attribute__ ((__aligned__(16)));\n+\n+/* char->short->int dot product.\n+   The dot-product pattern should be detected.\n+   Vectorizable on vect_sdot_qi targets (targets that support dot-product of \n+   signed chars).\n+\n+   In the future could also be vectorized as widening-mult + widening-summation,\n+   or with type-conversion support.\n+ */\n+int\n+foo1(int len) {\n+  int i;\n+  int result = 0;\n+  short prod;\n+\n+  for (i=0; i<len; i++) {\n+    prod = X[i] * Y[i];\n+    result += prod;\n+  }\n+  return result;\n+}\n+\n+/* char->short->short dot product.\n+   The dot-product pattern should be detected.\n+   Should be vectorized on vect_sdot_qi targets (targets that support \n+   dot-product of signed char).  \n+   This test currently fails to vectorize on targets that support\n+   dot-product of chars when the accumulator is int.\n+\n+   In the future could also be vectorized as widening-mult + summation,\n+   or with type-conversion support.\n+ */\n+short\n+foo2(int len) {\n+  int i;\n+  short result = 0;\n+\n+  for (i=0; i<len; i++) {\n+    result += (X[i] * Y[i]);\n+  }\n+  return result;\n+}\n+\n+/* char->int->int dot product. \n+   Not detected as a dot-product pattern.\n+   Currently fails to be vectorized due to presence of type conversions. */\n+int\n+foo3(int len) {\n+  int i;\n+  int result = 0;\n+\n+  for (i=0; i<len; i++) {\n+    result += (X[i] * Y[i]);\n+  }\n+  return result;\n+}\n+\n+int main (void)\n+{\n+  int i, dot1, dot3;\n+  short dot2;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+  }\n+\n+  dot1 = foo1 (N);\n+  if (dot1 != DOT1)\n+    abort ();\n+\n+  dot2 = foo2 (N);\n+  if (dot2 != DOT2)\n+    abort ();\n+\n+  dot3 = foo3 (N);\n+  if (dot3 != DOT3)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_dot_prod_pattern: detected\" 2 \"vect\" } } */\n+\n+/* When vectorizer is enhanced to vectorize foo2 (accumulation into short) for targets \n+   that support accumulation into int (ia64) we'd have:\n+dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_sdot_qi } }\n+*/\n+/* In the meantime expect: */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_sdot_qi } } } */\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "6c844eac38ebd1ef1af3b8552b9ecb9a603eddf2", "filename": "gcc/testsuite/gcc.dg/vect/wrapv-vect-reduc-pattern-2.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fwrapv-vect-reduc-pattern-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fwrapv-vect-reduc-pattern-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fwrapv-vect-reduc-pattern-2.c?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define SH_SUM 210\n+#define CH_SUM 120\n+\n+int main1 ()\n+{\n+  int i;\n+  signed short data_sh[N] = {0,2,4,6,8,10,12,14,16,18,20,22,24,26,28};\n+  signed char data_ch[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+  signed int intsum = 0;\n+  signed short shortsum = 0;\n+\n+  /* widenning sum: sum shorts into int.  */\n+  for (i = 0; i < N; i++){\n+    intsum += data_sh[i];\n+  }\n+\n+  /* check results:  */\n+  if (intsum != SH_SUM)\n+    abort ();\n+\n+  /* widenning sum: sum chars into int.  */\n+  intsum = 0;\n+  for (i = 0; i < N; i++){\n+    intsum += data_ch[i];\n+  }\n+\n+  /* check results:  */\n+  if (intsum != CH_SUM)\n+    abort ();\n+\n+  /* widenning sum: sum chars into short.  */\n+  for (i = 0; i < N; i++){\n+    shortsum += data_ch[i];\n+  }\n+\n+  /* check results:  */\n+  if (shortsum != CH_SUM)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_sum_pattern: detected\" 3 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { target vect_widen_sum } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "05a180eb9cccdee557ff4d7d88fd3fcf90a8d932", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -1364,6 +1364,112 @@ proc check_effective_target_vect_no_bitwise { } {\n     return $et_vect_no_bitwise_saved\n }\n \n+# Return 1 if the target plus current options supports a vector\n+# widening summation, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+                                                                                                \n+proc check_effective_target_vect_widen_sum { } {\n+    global et_vect_widen_sum\n+                                                                                                \n+    if [info exists et_vect_widen_sum_saved] {\n+        verbose \"check_effective_target_vect_widen_sum: using cached result\" 2\n+    } else {\n+        set et_vect_widen_sum_saved 0\n+        if { [istarget powerpc*-*-*]\n+\t     || [istarget ia64-*-*] } {\n+            set et_vect_widen_sum_saved 1\n+        }\n+    }\n+    verbose \"check_effective_target_vect_widen_sum: returning $et_vect_widen_sum_saved\" 2\n+    return $et_vect_widen_sum_saved\n+}\n+\n+# Return 1 if the target plus current options supports a vector\n+# dot-product of signed chars, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_vect_sdot_qi { } {\n+    global et_vect_sdot_qi\n+\n+    if [info exists et_vect_sdot_qi_saved] {\n+        verbose \"check_effective_target_vect_sdot_qi: using cached result\" 2\n+    } else {\n+        set et_vect_sdot_qi_saved 0\n+        if { [istarget ia64-*-*] } {\n+            set et_vect_sdot_qi_saved 1\n+        }\n+    }\n+    verbose \"check_effective_target_vect_sdot_qi: returning $et_vect_sdot_qi_saved\" 2\n+    return $et_vect_sdot_qi_saved\n+}\n+\n+# Return 1 if the target plus current options supports a vector\n+# dot-product of unsigned chars, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_vect_udot_qi { } {\n+    global et_vect_udot_qi\n+\n+    if [info exists et_vect_udot_qi_saved] {\n+        verbose \"check_effective_target_vect_udot_qi: using cached result\" 2\n+    } else {\n+        set et_vect_udot_qi_saved 0\n+        if { [istarget powerpc*-*-*]\n+             || [istarget ia64-*-*] } {\n+            set et_vect_udot_qi_saved 1\n+        }\n+    }\n+    verbose \"check_effective_target_vect_udot_qi: returning $et_vect_udot_qi_saved\" 2\n+    return $et_vect_udot_qi_saved\n+}\n+\n+# Return 1 if the target plus current options supports a vector\n+# dot-product of signed shorts, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_vect_sdot_hi { } {\n+    global et_vect_sdot_hi\n+\n+    if [info exists et_vect_sdot_hi_saved] {\n+        verbose \"check_effective_target_vect_sdot_hi: using cached result\" 2\n+    } else {\n+        set et_vect_sdot_hi_saved 0\n+        if { [istarget powerpc*-*-*] \n+\t     || [istarget i?86-*-*]\n+             || [istarget x86_64-*-*]\n+             || [istarget ia64-*-*] } {\n+            set et_vect_sdot_hi_saved 1\n+        }\n+    }\n+    verbose \"check_effective_target_vect_sdot_hi: returning $et_vect_sdot_hi_saved\" 2\n+    return $et_vect_sdot_hi_saved\n+}\n+\n+# Return 1 if the target plus current options supports a vector\n+# dot-product of unsigned shorts, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_vect_udot_hi { } {\n+    global et_vect_udot_hi\n+\n+    if [info exists et_vect_udot_hi_saved] {\n+        verbose \"check_effective_target_vect_udot_hi: using cached result\" 2\n+    } else {\n+        set et_vect_udot_hi_saved 0\n+        if { [istarget powerpc*-*-*] } {\n+            set et_vect_udot_hi_saved 1\n+        }\n+    }\n+    verbose \"check_effective_target_vect_udot_hi: returning $et_vect_udot_hi_saved\" 2\n+    return $et_vect_udot_hi_saved\n+}\n+\n+\n # Return 1 if the target plus current options does not support a vector\n # alignment mechanism, 0 otherwise.\n #"}, {"sha": "9a93427d468aa320ca91f6b6677f38cfe6eba681", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -1,5 +1,5 @@\n /* Tree inlining.\n-   Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n    Contributed by Alexandre Oliva <aoliva@redhat.com>\n \n This file is part of GCC.\n@@ -1728,6 +1728,10 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     case REDUC_MAX_EXPR:\n     case REDUC_MIN_EXPR:\n     case REDUC_PLUS_EXPR:\n+    case WIDEN_SUM_EXPR:\n+    case DOT_PROD_EXPR: \n+\n+    case WIDEN_MULT_EXPR:\n \n     case RESX_EXPR:\n       *count += 1;"}, {"sha": "4e50b8daf915e5d632f19039c7d428743a1dfb6a", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -1,5 +1,6 @@\n /* Pretty formatting of GENERIC trees in C syntax.\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006 \n+   Free Software Foundation, Inc.\n    Adapted from c-pretty-print.c by Diego Novillo <dnovillo@redhat.com>\n \n This file is part of GCC.\n@@ -1168,6 +1169,8 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       break;\n \n       /* Binary arithmetic and logic expressions.  */\n+    case WIDEN_SUM_EXPR:\n+    case WIDEN_MULT_EXPR:\n     case MULT_EXPR:\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n@@ -1686,6 +1689,16 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_string (buffer, \" > \");\n       break;\n \n+    case DOT_PROD_EXPR:\n+      pp_string (buffer, \" DOT_PROD_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \" , \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      pp_string (buffer, \" , \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 2), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+\n     case OMP_PARALLEL:\n       pp_string (buffer, \"#pragma omp parallel\");\n       dump_omp_clauses (buffer, OMP_PARALLEL_CLAUSES (node), spc, flags);\n@@ -2105,10 +2118,13 @@ op_prio (tree op)\n     case RROTATE_EXPR:\n       return 11;\n \n+    case WIDEN_SUM_EXPR:\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n       return 12;\n \n+    case WIDEN_MULT_EXPR:\n+    case DOT_PROD_EXPR:\n     case MULT_EXPR:\n     case TRUNC_DIV_EXPR:\n     case CEIL_DIV_EXPR:\n@@ -2263,6 +2279,12 @@ op_symbol_1 (enum tree_code code)\n     case REDUC_PLUS_EXPR:\n       return \"r+\";\n \n+    case WIDEN_SUM_EXPR:\n+      return \"w+\";\n+\n+    case WIDEN_MULT_EXPR:\n+      return \"w*\";\n+\n     case NEGATE_EXPR:\n     case MINUS_EXPR:\n       return \"-\";"}, {"sha": "e3b95e7a95431e4e347df89a8a4d99f1316938a9", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -1,5 +1,5 @@\n /* SSA operands management for trees.\n-   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1273,6 +1273,7 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n \treturn;\n       }\n \n+    case DOT_PROD_EXPR:\n     case REALIGN_LOAD_EXPR:\n       {\n \tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);"}, {"sha": "c5882d42afb2157f9f7e55c9ab2d2a0f4cef308b", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 53, "deletions": 22, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -1,5 +1,5 @@\n /* Analysis Utilities for Loop Vectorization.\n-   Copyright (C) 2003,2004,2005 Free Software Foundation, Inc.\n+   Copyright (C) 2003,2004,2005,2006 Free Software Foundation, Inc.\n    Contributed by Dorit Naishlos <dorit@il.ibm.com>\n \n This file is part of GCC.\n@@ -142,35 +142,46 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n               return false;\n             }\n \n-          if (STMT_VINFO_DATA_REF (stmt_info))\n-            scalar_type = TREE_TYPE (DR_REF (STMT_VINFO_DATA_REF (stmt_info)));\n-          else if (TREE_CODE (stmt) == MODIFY_EXPR)\n-            scalar_type = TREE_TYPE (TREE_OPERAND (stmt, 0));\n-          else\n-            scalar_type = TREE_TYPE (stmt);\n+\t  if (STMT_VINFO_VECTYPE (stmt_info))\n+\t    {\n+\t      vectype = STMT_VINFO_VECTYPE (stmt_info);\n+\t      scalar_type = TREE_TYPE (vectype);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (STMT_VINFO_DATA_REF (stmt_info))\n+\t\tscalar_type = \n+\t\t\tTREE_TYPE (DR_REF (STMT_VINFO_DATA_REF (stmt_info)));\n+\t      else if (TREE_CODE (stmt) == MODIFY_EXPR)\n+\t\tscalar_type = TREE_TYPE (TREE_OPERAND (stmt, 0));\n+\t      else\n+\t\tscalar_type = TREE_TYPE (stmt);\n \n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            {\n-              fprintf (vect_dump, \"get vectype for scalar type:  \");\n-              print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n-            }\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t\t{\n+\t\t  fprintf (vect_dump, \"get vectype for scalar type:  \");\n+\t\t  print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n+\t\t}\n \n-          vectype = get_vectype_for_scalar_type (scalar_type);\n-          if (!vectype)\n-            {\n-              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-                {\n-                  fprintf (vect_dump, \"not vectorized: unsupported data-type \");\n-                  print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n-                }\n-              return false;\n+\t      vectype = get_vectype_for_scalar_type (scalar_type);\n+\t      if (!vectype)\n+\t\t{\n+\t\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+\t\t    {\n+\t\t      fprintf (vect_dump, \n+\t\t\t       \"not vectorized: unsupported data-type \");\n+\t\t      print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n+\t\t    }\n+\t\t  return false;\n+\t\t}\n+\t      STMT_VINFO_VECTYPE (stmt_info) = vectype;\n             }\n+\n           if (vect_print_dump_info (REPORT_DETAILS))\n             {\n               fprintf (vect_dump, \"vectype: \");\n               print_generic_expr (vect_dump, vectype, TDF_SLIM);\n             }\n-          STMT_VINFO_VECTYPE (stmt_info) = vectype;\n \n           nunits = TYPE_VECTOR_SUBPARTS (vectype);\n           if (vect_print_dump_info (REPORT_DETAILS))\n@@ -1439,6 +1450,24 @@ vect_mark_relevant (VEC(tree,heap) **worklist, tree stmt,\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"mark relevant %d, live %d.\",relevant_p, live_p);\n \n+  if (STMT_VINFO_IN_PATTERN_P (stmt_info))\n+    {\n+      tree pattern_stmt;\n+\n+      /* This is the last stmt in a sequence that was detected as a \n+         pattern that can potentially be vectorized.  Don't mark the stmt\n+         as relevant/live because it's not going to vectorized.\n+         Instead mark the pattern-stmt that replaces it.  */\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"last stmt in pattern. don't mark relevant/live.\");\n+      pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n+      stmt_info = vinfo_for_stmt (pattern_stmt);\n+      gcc_assert (STMT_VINFO_RELATED_STMT (stmt_info) == stmt);\n+      save_relevant_p = STMT_VINFO_RELEVANT_P (stmt_info);\n+      save_live_p = STMT_VINFO_LIVE_P (stmt_info);\n+      stmt = pattern_stmt;\n+    }\n+\n   STMT_VINFO_LIVE_P (stmt_info) |= live_p;\n   STMT_VINFO_RELEVANT_P (stmt_info) |= relevant_p;\n \n@@ -2002,6 +2031,8 @@ vect_analyze_loop (struct loop *loop)\n \n   vect_analyze_scalar_cycles (loop_vinfo);\n \n+  vect_pattern_recog (loop_vinfo);\n+\n   /* Data-flow analysis to detect stmts that do not need to be vectorized.  */\n \n   ok = vect_mark_stmts_to_be_vectorized (loop_vinfo);"}, {"sha": "dd58cb914e83217e8bab9218fb3b9fa0609b8466", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -1,5 +1,5 @@\n /* Lower vector operations to scalar operations.\n-   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.\n \n This file is part of GCC.\n    \n@@ -411,6 +411,11 @@ expand_vector_operations_1 (block_stmt_iterator *bsi)\n   gcc_assert (code != CONVERT_EXPR);\n   op = optab_for_tree_code (code, type);\n \n+  /* For widening vector operations, the relevant type is of the arguments,\n+     not the widened result.  */\n+  if (code == WIDEN_SUM_EXPR)\n+    type = TREE_TYPE (TREE_OPERAND (rhs, 0));\n+\n   /* Optabs will try converting a negation into a subtraction, so\n      look for it as well.  TODO: negation of floating-point vectors\n      might be turned into an exclusive OR toggling the sign bit.  */"}, {"sha": "0ef76fe311a1485cea221507712b86444f6d457c", "filename": "gcc/tree-vect-patterns.c", "status": "added", "additions": 637, "deletions": 0, "changes": 637, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -0,0 +1,637 @@\n+/* Analysis Utilities for Loop Vectorization.\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+   Contributed by Dorit Nuzman <dorit@il.ibm.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+\n+#include \"target.h\"\n+#include \"basic-block.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"cfgloop.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+#include \"params.h\"\n+#include \"tree-data-ref.h\"\n+#include \"tree-vectorizer.h\"\n+#include \"recog.h\"\n+#include \"toplev.h\"\n+\n+/* Funcion prototypes */\n+static void vect_pattern_recog_1 \n+  (tree (* ) (tree, tree *, tree *), block_stmt_iterator);\n+static bool widened_name_p (tree, tree, tree *, tree *);\n+\n+/* Pattern recognition functions  */\n+static tree vect_recog_widen_sum_pattern (tree, tree *, tree *);\n+static tree vect_recog_widen_mult_pattern (tree, tree *, tree *);\n+static tree vect_recog_dot_prod_pattern (tree, tree *, tree *);\n+static vect_recog_func_ptr vect_vect_recog_func_ptrs[NUM_PATTERNS] = {\n+\tvect_recog_widen_mult_pattern,\n+\tvect_recog_widen_sum_pattern,\n+\tvect_recog_dot_prod_pattern};\n+\n+\n+/* Function widened_name_p\n+\n+   Check whether NAME, an ssa-name used in USE_STMT,\n+   is a result of a type-promotion, such that:\n+     DEF_STMT: NAME = NOP (name0)\n+   where the type of name0 (HALF_TYPE) is smaller than the type of NAME. \n+*/\n+\n+static bool\n+widened_name_p (tree name, tree use_stmt, tree *half_type, tree *def_stmt)\n+{\n+  tree dummy;\n+  loop_vec_info loop_vinfo;\n+  stmt_vec_info stmt_vinfo;\n+  tree expr;\n+  tree type = TREE_TYPE (name);\n+  tree oprnd0;\n+  enum vect_def_type dt;\n+  tree def;\n+\n+  stmt_vinfo = vinfo_for_stmt (use_stmt);\n+  loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+\n+  if (!vect_is_simple_use (name, loop_vinfo, def_stmt, &def, &dt))\n+    return false;\n+\n+  if (dt != vect_loop_def\n+      && dt != vect_invariant_def && dt != vect_constant_def)\n+    return false;\n+\n+  if (! *def_stmt)\n+    return false;\n+\n+  if (TREE_CODE (*def_stmt) != MODIFY_EXPR)\n+    return false;\n+\n+  expr = TREE_OPERAND (*def_stmt, 1);\n+  if (TREE_CODE (expr) != NOP_EXPR)\n+    return false;\n+\n+  oprnd0 = TREE_OPERAND (expr, 0);\n+\n+  *half_type = TREE_TYPE (oprnd0);\n+  if (!INTEGRAL_TYPE_P (type) || !INTEGRAL_TYPE_P (*half_type)\n+      || (TYPE_UNSIGNED (type) != TYPE_UNSIGNED (*half_type))\n+      || (TYPE_PRECISION (type) < (TYPE_PRECISION (*half_type) * 2)))\n+    return false;\n+\n+  if (!vect_is_simple_use (oprnd0, loop_vinfo, &dummy, &dummy, &dt))\n+    return false;\n+\n+  if (dt != vect_invariant_def && dt != vect_constant_def\n+      && dt != vect_loop_def)\n+    return false;\n+\n+  return true;\n+}\n+\n+\n+/* Function vect_recog_dot_prod_pattern\n+\n+   Try to find the following pattern:\n+\n+     type x_t, y_t;\n+     TYPE1 prod;\n+     TYPE2 sum = init;\n+   loop:\n+     sum_0 = phi <init, sum_1>\n+     S1  x_t = ...\n+     S2  y_t = ...\n+     S3  x_T = (TYPE1) x_t;\n+     S4  y_T = (TYPE1) y_t;\n+     S5  prod = x_T * y_T;\n+     [S6  prod = (TYPE2) prod;  #optional]\n+     S7  sum_1 = prod + sum_0;\n+\n+   where 'TYPE1' is exactly double the size of type 'type', and 'TYPE2' is the \n+   same size of 'TYPE1' or bigger. This is a sepcial case of a reduction \n+   computation.\n+      \n+   Input:\n+\n+   * LAST_STMT: A stmt from which the pattern search begins. In the example,\n+   when this function is called with S7, the pattern {S3,S4,S5,S6,S7} will be\n+   detected.\n+\n+   Output:\n+\n+   * TYPE_IN: The type of the input arguments to the pattern.\n+\n+   * TYPE_OUT: The type of the output  of this pattern.\n+\n+   * Return value: A new stmt that will be used to replace the sequence of\n+   stmts that constitute the pattern. In this case it will be:\n+        WIDEN_DOT_PRODUCT <x_t, y_t, sum_0>\n+*/\n+\n+static tree\n+vect_recog_dot_prod_pattern (tree last_stmt, tree *type_in, tree *type_out)\n+{\n+  tree stmt, expr;\n+  tree oprnd0, oprnd1;\n+  tree oprnd00, oprnd01;\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n+  tree type, half_type;\n+  tree pattern_expr;\n+  tree prod_type;\n+\n+  if (TREE_CODE (last_stmt) != MODIFY_EXPR)\n+    return NULL;\n+\n+  expr = TREE_OPERAND (last_stmt, 1);\n+  type = TREE_TYPE (expr);\n+\n+  /* Look for the following pattern \n+          DX = (TYPE1) X;\n+          DY = (TYPE1) Y;\n+          DPROD = DX * DY; \n+          DDPROD = (TYPE2) DPROD;\n+          sum_1 = DDPROD + sum_0;\n+     In which \n+     - DX is double the size of X\n+     - DY is double the size of Y\n+     - DX, DY, DPROD all have the same type\n+     - sum is the same size of DPROD or bigger\n+     - sum has been recognized as a reduction variable.\n+\n+     This is equivalent to:\n+       DPROD = X w* Y;          #widen mult\n+       sum_1 = DPROD w+ sum_0;  #widen summation\n+     or\n+       DPROD = X w* Y;          #widen mult\n+       sum_1 = DPROD + sum_0;   #summation\n+   */\n+\n+  /* Starting from LAST_STMT, follow the defs of its uses in search\n+     of the above pattern.  */\n+\n+  if (TREE_CODE (expr) != PLUS_EXPR)\n+    return NULL;\n+\n+  if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n+    {\n+      /* Has been detected as widening-summation?  */\n+\n+      stmt = STMT_VINFO_RELATED_STMT (stmt_vinfo);\n+      expr = TREE_OPERAND (stmt, 1);\n+      type = TREE_TYPE (expr);\n+      if (TREE_CODE (expr) != WIDEN_SUM_EXPR)\n+        return NULL;\n+      oprnd0 = TREE_OPERAND (expr, 0);\n+      oprnd1 = TREE_OPERAND (expr, 1);\n+      half_type = TREE_TYPE (oprnd0);\n+    }\n+  else\n+    {\n+      tree def_stmt;\n+\n+      if (STMT_VINFO_DEF_TYPE (stmt_vinfo) != vect_reduction_def)\n+        return NULL;\n+      oprnd0 = TREE_OPERAND (expr, 0);\n+      oprnd1 = TREE_OPERAND (expr, 1);\n+      if (TYPE_MAIN_VARIANT (TREE_TYPE (oprnd0)) != TYPE_MAIN_VARIANT (type)\n+          || TYPE_MAIN_VARIANT (TREE_TYPE (oprnd1)) != TYPE_MAIN_VARIANT (type))\n+        return NULL;\n+      stmt = last_stmt;\n+\n+      if (widened_name_p (oprnd0, stmt, &half_type, &def_stmt))\n+        {\n+          stmt = def_stmt;\n+          expr = TREE_OPERAND (stmt, 1);\n+          oprnd0 = TREE_OPERAND (expr, 0);\n+        }\n+      else\n+        half_type = type;\n+    }\n+\n+  /* So far so good. Since last_stmt was detected as a (summation) reduction,\n+     we know that oprnd1 is the reduction variable (defined by a loop-header\n+     phi), and oprnd0 is an ssa-name defined by a stmt in the loop body.\n+     Left to check that oprnd0 is defined by a (widen_)mult_expr  */\n+\n+  prod_type = half_type;\n+  stmt = SSA_NAME_DEF_STMT (oprnd0);\n+  gcc_assert (stmt);\n+  stmt_vinfo = vinfo_for_stmt (stmt);\n+  gcc_assert (stmt_vinfo);\n+  gcc_assert (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_loop_def);\n+  expr = TREE_OPERAND (stmt, 1);\n+  if (TREE_CODE (expr) != MULT_EXPR)\n+    return NULL;\n+  if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n+    {\n+      /* Has been detected as a widening multiplication?  */\n+\n+      stmt = STMT_VINFO_RELATED_STMT (stmt_vinfo);\n+      expr = TREE_OPERAND (stmt, 1);\n+      if (TREE_CODE (expr) != WIDEN_MULT_EXPR)\n+        return NULL;\n+      stmt_vinfo = vinfo_for_stmt (stmt);\n+      gcc_assert (stmt_vinfo);\n+      gcc_assert (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_loop_def);\n+      oprnd00 = TREE_OPERAND (expr, 0);\n+      oprnd01 = TREE_OPERAND (expr, 1);\n+    }\n+  else\n+    {\n+      tree half_type0, half_type1;\n+      tree def_stmt;\n+      tree oprnd0, oprnd1;\n+\n+      oprnd0 = TREE_OPERAND (expr, 0);\n+      oprnd1 = TREE_OPERAND (expr, 1);\n+      if (TYPE_MAIN_VARIANT (TREE_TYPE (oprnd0)) \n+\t\t\t\t!= TYPE_MAIN_VARIANT (prod_type)\n+          || TYPE_MAIN_VARIANT (TREE_TYPE (oprnd1)) \n+\t\t\t\t!= TYPE_MAIN_VARIANT (prod_type))\n+        return NULL;\n+      if (!widened_name_p (oprnd0, stmt, &half_type0, &def_stmt))\n+        return NULL;\n+      oprnd00 = TREE_OPERAND (TREE_OPERAND (def_stmt, 1), 0);\n+      if (!widened_name_p (oprnd1, stmt, &half_type1, &def_stmt))\n+        return NULL;\n+      oprnd01 = TREE_OPERAND (TREE_OPERAND (def_stmt, 1), 0);\n+      if (TYPE_MAIN_VARIANT (half_type0) != TYPE_MAIN_VARIANT (half_type1))\n+        return NULL;\n+      if (TYPE_PRECISION (prod_type) != TYPE_PRECISION (half_type0) * 2)\n+\treturn NULL;\n+    }\n+\n+  half_type = TREE_TYPE (oprnd00);\n+  *type_in = half_type;\n+  *type_out = type;\n+  \n+  /* Pattern detected. Create a stmt to be used to replace the pattern: */\n+  pattern_expr = build3 (DOT_PROD_EXPR, type, oprnd00, oprnd01, oprnd1);\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    {\n+      fprintf (vect_dump, \"vect_recog_dot_prod_pattern: detected: \");\n+      print_generic_expr (vect_dump, pattern_expr, TDF_SLIM);\n+    }\n+  return pattern_expr;\n+}\n+\n+\n+/* Function vect_recog_widen_mult_pattern\n+\n+   Try to find the following pattern:\n+\n+     type a_t, b_t;\n+     TYPE a_T, b_T, prod_T;\n+\n+     S1  a_t = ;\n+     S2  b_t = ;\n+     S3  a_T = (TYPE) a_t;\n+     S4  b_T = (TYPE) b_t;\n+     S5  prod_T = a_T * b_T;\n+\n+   where type 'TYPE' is at least double the size of type 'type'.\n+\n+   Input:\n+\n+   * LAST_STMT: A stmt from which the pattern search begins. In the example,\n+   when this function is called with S5, the pattern {S3,S4,S5} is be detected.\n+\n+   Output:\n+\n+   * TYPE_IN: The type of the input arguments to the pattern.\n+\n+   * TYPE_OUT: The type of the output  of this pattern.\n+\n+   * Return value: A new stmt that will be used to replace the sequence of\n+   stmts that constitute the pattern. In this case it will be:\n+        WIDEN_MULT <a_t, b_t>\n+*/\n+\n+static tree\n+vect_recog_widen_mult_pattern (tree last_stmt ATTRIBUTE_UNUSED, \n+\t\t\t       tree *type_in ATTRIBUTE_UNUSED, \n+\t\t\t       tree *type_out ATTRIBUTE_UNUSED)\n+{\n+  /* Yet to be implemented.   */\n+  return NULL;\n+}\n+\n+\n+/* Function vect_recog_widen_sum_pattern\n+\n+   Try to find the following pattern:\n+\n+     type x_t; \n+     TYPE x_T, sum = init;\n+   loop:\n+     sum_0 = phi <init, sum_1>\n+     S1  x_t = *p;\n+     S2  x_T = (TYPE) x_t;\n+     S3  sum_1 = x_T + sum_0;\n+\n+   where type 'TYPE' is at least double the size of type 'type', i.e - we're \n+   summing elements of type 'type' into an accumulator of type 'TYPE'. This is\n+   a sepcial case of a reduction computation.\n+\n+   Input:\n+\n+   * LAST_STMT: A stmt from which the pattern search begins. In the example,\n+   when this function is called with S3, the pattern {S2,S3} will be detected.\n+        \n+   Output:\n+      \n+   * TYPE_IN: The type of the input arguments to the pattern.\n+\n+   * TYPE_OUT: The type of the output of this pattern.\n+\n+   * Return value: A new stmt that will be used to replace the sequence of\n+   stmts that constitute the pattern. In this case it will be:\n+        WIDEN_SUM <x_t, sum_0>\n+*/\n+\n+static tree\n+vect_recog_widen_sum_pattern (tree last_stmt, tree *type_in, tree *type_out)\n+{\n+  tree stmt, expr;\n+  tree oprnd0, oprnd1;\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n+  tree type, half_type;\n+  tree pattern_expr;\n+\n+  if (TREE_CODE (last_stmt) != MODIFY_EXPR)\n+    return NULL;\n+\n+  expr = TREE_OPERAND (last_stmt, 1);\n+  type = TREE_TYPE (expr);\n+\n+  /* Look for the following pattern\n+          DX = (TYPE) X;\n+          sum_1 = DX + sum_0;\n+     In which DX is at least double the size of X, and sum_1 has been\n+     recognized as a reduction variable.\n+   */\n+\n+  /* Starting from LAST_STMT, follow the defs of its uses in search\n+     of the above pattern.  */\n+\n+  if (TREE_CODE (expr) != PLUS_EXPR)\n+    return NULL;\n+\n+  if (STMT_VINFO_DEF_TYPE (stmt_vinfo) != vect_reduction_def)\n+    return NULL;\n+\n+  oprnd0 = TREE_OPERAND (expr, 0);\n+  oprnd1 = TREE_OPERAND (expr, 1);\n+  if (TYPE_MAIN_VARIANT (TREE_TYPE (oprnd0)) != TYPE_MAIN_VARIANT (type)\n+      || TYPE_MAIN_VARIANT (TREE_TYPE (oprnd1)) != TYPE_MAIN_VARIANT (type))\n+    return NULL;\n+\n+  /* So far so good. Since last_stmt was detected as a (summation) reduction,\n+     we know that oprnd1 is the reduction variable (defined by a loop-header\n+     phi), and oprnd0 is an ssa-name defined by a stmt in the loop body.\n+     Left to check that oprnd0 is defined by a cast from type 'type' to type\n+     'TYPE'.  */\n+\n+  if (!widened_name_p (oprnd0, last_stmt, &half_type, &stmt))\n+    return NULL;\n+\n+  oprnd0 = TREE_OPERAND (TREE_OPERAND (stmt, 1), 0);\n+  *type_in = half_type;\n+  *type_out = type;\n+\n+  /* Pattern detected. Create a stmt to be used to replace the pattern: */\n+  pattern_expr = build2 (WIDEN_SUM_EXPR, type, oprnd0, oprnd1);\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    {\n+      fprintf (vect_dump, \"vect_recog_widen_sum_pattern: detected: \");\n+      print_generic_expr (vect_dump, pattern_expr, TDF_SLIM);\n+    }\n+  return pattern_expr;\n+}\n+\n+\n+/* Function vect_pattern_recog_1 \n+\n+   Input:\n+   PATTERN_RECOG_FUNC: A pointer to a function that detects a certain\n+        computation pattern.\n+   STMT: A stmt from which the pattern search should start.\n+\n+   If PATTERN_RECOG_FUNC successfully detected the pattern, it creates an\n+   expression that computes the same functionality and can be used to \n+   replace the sequence of stmts that are involved in the pattern. \n+\n+   Output:\n+   This function checks if the expression returned by PATTERN_RECOG_FUNC is \n+   supported in vector form by the target.  We use 'TYPE_IN' to obtain the \n+   relevant vector type. If 'TYPE_IN' is already a vector type, then this \n+   indicates that target support had already been checked by PATTERN_RECOG_FUNC.\n+   If 'TYPE_OUT' is also returned by PATTERN_RECOG_FUNC, we check that it fits\n+   to the available target pattern.\n+\n+   This function also does some bookeeping, as explained in the documentation \n+   for vect_recog_pattern.  */\n+\n+static void\n+vect_pattern_recog_1 (\n+\ttree (* vect_recog_func_ptr) (tree, tree *, tree *),\n+\tblock_stmt_iterator si)\n+{\n+  tree stmt = bsi_stmt (si);\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  stmt_vec_info pattern_stmt_info;\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  tree pattern_expr;\n+  tree pattern_vectype;\n+  tree type_in, type_out;\n+  tree pattern_type;\n+  enum tree_code code;\n+  tree var, var_name;\n+  stmt_ann_t ann;\n+\n+  pattern_expr = (* vect_recog_func_ptr) (stmt, &type_in, &type_out);\n+  if (!pattern_expr) \n+    return; \n+ \n+  if (VECTOR_MODE_P (TYPE_MODE (type_in))) \n+    { \n+      /* No need to check target support (already checked by the pattern \n+         recognition function).  */ \n+      pattern_vectype = type_in;\n+    }\n+  else\n+    {\n+      enum tree_code vec_mode;\n+      enum insn_code icode;\n+      optab optab;\n+\n+      /* Check target support  */\n+      pattern_vectype = get_vectype_for_scalar_type (type_in);\n+      optab = optab_for_tree_code (TREE_CODE (pattern_expr), pattern_vectype);\n+      vec_mode = TYPE_MODE (pattern_vectype);\n+      if (!optab\n+          || (icode = optab->handlers[(int) vec_mode].insn_code) ==\n+              CODE_FOR_nothing\n+          || (type_out\n+              && (insn_data[icode].operand[0].mode !=\n+                  TYPE_MODE (get_vectype_for_scalar_type (type_out)))))\n+\treturn;\n+    }\n+\n+  /* Found a vectorizable pattern.  */\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    {\n+      fprintf (vect_dump, \"pattern recognized: \"); \n+      print_generic_expr (vect_dump, pattern_expr, TDF_SLIM);\n+    }\n+  \n+  /* Mark the stmts that are involved in the pattern,\n+     create a new stmt to express the pattern and insert it.  */\n+  code = TREE_CODE (pattern_expr);\n+  pattern_type = TREE_TYPE (pattern_expr);\n+  var = create_tmp_var (pattern_type, \"patt\");\n+  add_referenced_tmp_var (var);\n+  var_name = make_ssa_name (var, NULL_TREE);\n+  pattern_expr = build2 (MODIFY_EXPR, void_type_node, var_name, pattern_expr);\n+  SSA_NAME_DEF_STMT (var_name) = pattern_expr;\n+  bsi_insert_before (&si, pattern_expr, BSI_SAME_STMT);\n+  ann = stmt_ann (pattern_expr);\n+  set_stmt_info ((tree_ann_t)ann, new_stmt_vec_info (pattern_expr, loop_vinfo));\n+  pattern_stmt_info = vinfo_for_stmt (pattern_expr);\n+  \n+  STMT_VINFO_RELATED_STMT (pattern_stmt_info) = stmt;\n+  STMT_VINFO_DEF_TYPE (pattern_stmt_info) = STMT_VINFO_DEF_TYPE (stmt_info);\n+  STMT_VINFO_VECTYPE (pattern_stmt_info) = pattern_vectype;\n+  STMT_VINFO_IN_PATTERN_P (stmt_info) = true;\n+  STMT_VINFO_RELATED_STMT (stmt_info) = pattern_expr;\n+\n+  return;\n+}\n+\n+\n+/* Function vect_pattern_recog\n+\n+   Input:\n+   LOOP_VINFO - a struct_loop_info of a loop in which we want to look for\n+        computation idioms.\n+\n+   Output - for each computation idiom that is detected we insert a new stmt\n+        that provides the same functionality and that can be vectorized. We\n+        also record some information in the struct_stmt_info of the relevant\n+        stmts, as explained below:\n+\n+   At the entry to this function we have the following stmts, with the\n+   following initial value in the STMT_VINFO fields:\n+\n+         stmt                     in_pattern_p  related_stmt    vec_stmt\n+         S1: a_i = ....                 -       -               -\n+         S2: a_2 = ..use(a_i)..         -       -               -\n+         S3: a_1 = ..use(a_2)..         -       -               -\n+         S4: a_0 = ..use(a_1)..         -       -               -\n+         S5: ... = ..use(a_0)..         -       -               -\n+\n+   Say the sequence {S1,S2,S3,S4} was detected as a pattern that can be\n+   represented by a single stmt. We then:\n+   - create a new stmt S6 that will replace the pattern.\n+   - insert the new stmt S6 before the last stmt in the pattern\n+   - fill in the STMT_VINFO fields as follows:\n+\n+                                  in_pattern_p  related_stmt    vec_stmt\n+         S1: a_i = ....                 -       -               -       \n+         S2: a_2 = ..use(a_i)..         -       -               -\n+         S3: a_1 = ..use(a_2)..         -       -               -\n+       > S6: a_new = ....               -       S4              -\n+         S4: a_0 = ..use(a_1)..         true    S6              -\n+         S5: ... = ..use(a_0)..         -       -               -\n+\n+   (the last stmt in the pattern (S4) and the new pattern stmt (S6) point\n+    to each other through the RELATED_STMT field).\n+\n+   S6 will be marked as relevant in vect_mark_stmts_to_be_vectorized instead\n+   of S4 because it will replace all its uses.  Stmts {S1,S2,S3} will\n+   remain irrelevant unless used by stmts other than S4.\n+\n+   If vectorization succeeds, vect_transform_stmt will skip over {S1,S2,S3}\n+   (because they are marked as irrelevent). It will vectorize S6, and record\n+   a pointer to the new vector stmt VS6 both from S6 (as usual), and also \n+   from S4. We do that so that when we get to vectorizing stmts that use the\n+   def of S4 (like S5 that uses a_0), we'll know where to take the relevant\n+   vector-def from. S4 will be skipped, and S5 will be vectorized as usual:\n+\n+                                  in_pattern_p  related_stmt    vec_stmt\n+         S1: a_i = ....                 -       -               -\n+         S2: a_2 = ..use(a_i)..         -       -               -\n+         S3: a_1 = ..use(a_2)..         -       -               -\n+       > VS6: va_new = ....             -       -               -\n+         S6: a_new = ....               -       S4              VS6\n+         S4: a_0 = ..use(a_1)..         true    S6              VS6\n+       > VS5: ... = ..vuse(va_new)..    -       -               -\n+         S5: ... = ..use(a_0)..         -       -               -\n+\n+   DCE could then get rid of {S1,S2,S3,S4,S5,S6} (if their defs are not used\n+   elsewhere), and we'll end up with:\n+\n+        VS6: va_new = .... \n+        VS5: ... = ..vuse(va_new)..\n+\n+   If vectorization does not succeed, DCE will clean S6 away (its def is\n+   not used), and we'll end up with the original sequence.\n+*/\n+\n+void\n+vect_pattern_recog (loop_vec_info loop_vinfo)\n+{\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n+  unsigned int nbbs = loop->num_nodes;\n+  block_stmt_iterator si;\n+  tree stmt;\n+  unsigned int i, j;\n+  tree (* vect_recog_func_ptr) (tree, tree *, tree *);\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"=== vect_pattern_recog ===\");\n+\n+  /* Scan through the loop stmts, applying the pattern recognition\n+     functions starting at each stmt visited:  */\n+  for (i = 0; i < nbbs; i++)\n+    {\n+      basic_block bb = bbs[i];\n+      for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n+        {\n+          stmt = bsi_stmt (si);\n+\n+          /* Scan over all generic vect_recog_xxx_pattern functions.  */\n+          for (j = 0; j < NUM_PATTERNS; j++)\n+            {\n+              vect_recog_func_ptr = vect_vect_recog_func_ptrs[j];\n+              vect_pattern_recog_1 (vect_recog_func_ptr, si);\n+            }\n+        }\n+    }\n+}"}, {"sha": "db0573ce6f5cf8e5f25f50b3a97348bd20e9a272", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 294, "deletions": 128, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -1,5 +1,5 @@\n /* Transformation Utilities for Loop Vectorization.\n-   Copyright (C) 2003,2004,2005 Free Software Foundation, Inc.\n+   Copyright (C) 2003,2004,2005,2006 Free Software Foundation, Inc.\n    Contributed by Dorit Naishlos <dorit@il.ibm.com>\n \n This file is part of GCC.\n@@ -59,6 +59,7 @@ static void vect_finish_stmt_generation\n   (tree stmt, tree vec_stmt, block_stmt_iterator *bsi);\n static bool vect_is_simple_cond (tree, loop_vec_info); \n static void update_vuses_to_preheader (tree, struct loop*);\n+static void vect_create_epilog_for_reduction (tree, tree, enum tree_code, tree);\n static tree get_initial_def_for_reduction (tree, tree, tree *);\n \n /* Utility function dealing with loop peeling (not peeling itself).  */\n@@ -656,6 +657,8 @@ get_initial_def_for_reduction (tree stmt, tree init_val, tree *scalar_def)\n \n   switch (code)\n   {\n+  case WIDEN_SUM_EXPR:\n+  case DOT_PROD_EXPR:\n   case PLUS_EXPR:\n     if (INTEGRAL_TYPE_P (type))\n       def = build_int_cst (type, 0);\n@@ -711,66 +714,66 @@ get_initial_def_for_reduction (tree stmt, tree init_val, tree *scalar_def)\n }\n \n \n-/* Function vect_create_epilog_for_reduction:\n+/* Function vect_create_epilog_for_reduction\n     \n    Create code at the loop-epilog to finalize the result of a reduction\n-   computation.\n+   computation. \n   \n-   LOOP_EXIT_VECT_DEF is a vector of partial results. We need to \"reduce\" it\n-   into a single result, by applying the operation REDUC_CODE on the\n-   partial-results-vector. For this, we need to create a new phi node at the\n-   loop exit to preserve loop-closed form, as illustrated below.\n-\n-   STMT is the original scalar reduction stmt that is being vectorized.\n-   REDUCTION_OP is the scalar reduction-variable.\n+   VECT_DEF is a vector of partial results. \n+   REDUC_CODE is the tree-code for the epilog reduction.\n+   STMT is the scalar reduction stmt that is being vectorized.\n    REDUCTION_PHI is the phi-node that carries the reduction computation.\n-   This function also sets the arguments for the REDUCTION_PHI:\n-   The loop-entry argument is the (vectorized) initial-value of REDUCTION_OP.\n-   The loop-latch argument is VECT_DEF - the vector of partial sums.\n \n-     This function transforms this:\n+   This function:\n+   1. Creates the reduction def-use cycle: sets the the arguments for \n+      REDUCTION_PHI:\n+      The loop-entry argument is the vectorized initial-value of the reduction.\n+      The loop-latch argument is VECT_DEF - the vector of partial sums.\n+   2. \"Reduces\" the vector of partial results VECT_DEF into a single result,\n+      by applying the operation specified by REDUC_CODE if available, or by \n+      other means (whole-vector shifts or a scalar loop).\n+      The function also creates a new phi node at the loop exit to preserve \n+      loop-closed form, as illustrated below.\n+  \n+     The flow at the entry to this function:\n     \n         loop:\n-          vec_def = phi <null, null>    # REDUCTION_PHI\n-          ....\n-          VECT_DEF = ...\n-\n+          vec_def = phi <null, null>            # REDUCTION_PHI\n+          VECT_DEF = vector_stmt                # vectorized form of STMT       \n+          s_loop = scalar_stmt                  # (scalar) STMT\n         loop_exit:\n-          s_out0 = phi <s_loop>         # EXIT_PHI\n-\n+          s_out0 = phi <s_loop>                 # (scalar) EXIT_PHI\n           use <s_out0>\n           use <s_out0>\n \n-     Into:\n+     The above is transformed by this function into:\n \n         loop:\n-          vec_def = phi <vec_init, VECT_DEF> # REDUCTION_PHI\n-          ....\n-          VECT_DEF = ...\n-\n+          vec_def = phi <vec_init, VECT_DEF>    # REDUCTION_PHI\n+          VECT_DEF = vector_stmt                # vectorized form of STMT\n+          s_loop = scalar_stmt                  # (scalar) STMT \n         loop_exit:\n-          s_out0 = phi <s_loop>         # EXIT_PHI\n-          v_out1 = phi <VECT_DEF>       # NEW_EXIT_PHI\n-\n-          v_out2 = reduc_expr <v_out1>\n+          s_out0 = phi <s_loop>                 # (scalar) EXIT_PHI\n+          v_out1 = phi <VECT_DEF>               # NEW_EXIT_PHI\n+          v_out2 = reduce <v_out1>\n           s_out3 = extract_field <v_out2, 0>\n-\n-          use <s_out3>\n-          use <s_out3>\n+          s_out4 = adjust_result <s_out3>\n+          use <s_out4>\n+          use <s_out4>\n */\n \n static void\n-vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n+vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n                                   enum tree_code reduc_code, tree reduction_phi)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  enum machine_mode mode = TYPE_MODE (vectype);\n+  tree vectype;\n+  enum machine_mode mode;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block exit_bb;\n-  tree scalar_dest = TREE_OPERAND (stmt, 0);\n-  tree scalar_type = TREE_TYPE (scalar_dest);\n+  tree scalar_dest;\n+  tree scalar_type;\n   tree new_phi;\n   block_stmt_iterator exit_bsi;\n   tree vec_dest;\n@@ -786,7 +789,16 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n   bool extract_scalar_result;\n+  tree reduction_op;\n+  tree orig_stmt;\n+  tree operation = TREE_OPERAND (stmt, 1);\n+  int op_type;\n   \n+  op_type = TREE_CODE_LENGTH (TREE_CODE (operation));\n+  reduction_op = TREE_OPERAND (operation, op_type-1);\n+  vectype = get_vectype_for_scalar_type (TREE_TYPE (reduction_op));\n+  mode = TYPE_MODE (vectype);\n+\n   /*** 1. Create the reduction def-use cycle  ***/\n   \n   /* 1.1 set the loop-entry arg of the reduction-phi:  */\n@@ -797,7 +809,6 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n \t\t\t\t\t\t  &scalar_initial_def);\n   add_phi_arg (reduction_phi, vec_initial_def, loop_preheader_edge (loop));\n \n-\n   /* 1.2 set the loop-latch arg for the reduction-phi:  */\n   add_phi_arg (reduction_phi, vect_def, loop_latch_edge (loop));\n \n@@ -810,23 +821,72 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n     }\n \n \n-  /*** 2. Create epilog code ***/\n+  /*** 2. Create epilog code\n+\t  The reduction epilog code operates across the elements of the vector\n+          of partial results computed by the vectorized loop.\n+          The reduction epilog code consists of:\n+          step 1: compute the scalar result in a vector (v_out2)\n+          step 2: extract the scalar result (s_out3) from the vector (v_out2)\n+          step 3: adjust the scalar result (s_out3) if needed.\n+\n+          Step 1 can be accomplished using one the following three schemes:\n+          (scheme 1) using reduc_code, if available.\n+          (scheme 2) using whole-vector shifts, if available.\n+          (scheme 3) using a scalar loop. In this case steps 1+2 above are \n+                     combined.\n+                \n+          The overall epilog code looks like this:\n+\n+          s_out0 = phi <s_loop>         # original EXIT_PHI\n+          v_out1 = phi <VECT_DEF>       # NEW_EXIT_PHI\n+          v_out2 = reduce <v_out1>              # step 1\n+          s_out3 = extract_field <v_out2, 0>    # step 2\n+          s_out4 = adjust_result <s_out3>       # step 3\n+\n+          (step 3 is optional, and step2 1 and 2 may be combined).\n+          Lastly, the uses of s_out0 are replaced by s_out4.\n+\n+\t  ***/\n \n   /* 2.1 Create new loop-exit-phi to preserve loop-closed form:\n         v_out1 = phi <v_loop>  */\n \n   exit_bb = loop->single_exit->dest;\n   new_phi = create_phi_node (SSA_NAME_VAR (vect_def), exit_bb);\n   SET_PHI_ARG_DEF (new_phi, loop->single_exit->dest_idx, vect_def);\n-\n   exit_bsi = bsi_start (exit_bb);\n \n-\n+  /* 2.2 Get the relevant tree-code to use in the epilog for schemes 2,3 \n+         (i.e. when reduc_code is not available) and in the final adjusment code\n+         (if needed).  Also get the original scalar reduction variable as\n+         defined in the loop.  In case STMT is a \"pattern-stmt\" (i.e. - it \n+         represents a reduction pattern), the tree-code and scalar-def are \n+         taken from the original stmt that the pattern-stmt (STMT) replaces.  \n+         Otherwise (it is a regular reduction) - the tree-code and scalar-def\n+         are taken from STMT.  */ \n+\n+  orig_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n+  if (!orig_stmt)\n+    {\n+      /* Regular reduction  */\n+      orig_stmt = stmt;\n+    }\n+  else\n+    {\n+      /* Reduction pattern  */\n+      stmt_vec_info stmt_vinfo = vinfo_for_stmt (orig_stmt);\n+      gcc_assert (STMT_VINFO_IN_PATTERN_P (stmt_vinfo));\n+      gcc_assert (STMT_VINFO_RELATED_STMT (stmt_vinfo) == stmt);\n+    }\n+  code = TREE_CODE (TREE_OPERAND (orig_stmt, 1));\n+  scalar_dest = TREE_OPERAND (orig_stmt, 0);\n+  scalar_type = TREE_TYPE (scalar_dest);\n   new_scalar_dest = vect_create_destination_var (scalar_dest, NULL);\n   bitsize = TYPE_SIZE (scalar_type);\n   bytesize = TYPE_SIZE_UNIT (scalar_type);\n \n-  /* 2.2 Create the reduction code.  */\n+  /* 2.3 Create the reduction code, using one of the three schemes described\n+         above.  */\n \n   if (reduc_code < NUM_TREE_CODES)\n     {\n@@ -849,16 +909,11 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n     {\n       enum tree_code shift_code = 0;\n       bool have_whole_vector_shift = true;\n-      enum tree_code code = TREE_CODE (TREE_OPERAND (stmt, 1)); /* CHECKME */\n       int bit_offset;\n       int element_bitsize = tree_low_cst (bitsize, 1);\n       int vec_size_in_bits = tree_low_cst (TYPE_SIZE (vectype), 1);\n       tree vec_temp;\n \n-      /* The result of the reduction is expected to be at the least\n-\t significant bits of the vector.  This is merely convention,\n-\t as it's the extraction later that really matters, and that\n-\t is also under our control.  */\n       if (vec_shr_optab->handlers[mode].insn_code != CODE_FOR_nothing)\n \tshift_code = VEC_RSHIFT_EXPR;\n       else\n@@ -881,7 +936,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n \n       if (have_whole_vector_shift)\n         {\n-\t  /*** Case 2:\n+\t  /*** Case 2: Create:\n \t     for (offset = VS/2; offset >= element_size; offset/=2)\n \t        {\n \t          Create:  va' = vec_shift <va, offset>\n@@ -905,17 +960,12 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n \t      new_name = make_ssa_name (vec_dest, epilog_stmt);\n \t      TREE_OPERAND (epilog_stmt, 0) = new_name;\n \t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\tprint_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n-\n \n \t      epilog_stmt = build2 (MODIFY_EXPR, vectype, vec_dest,\n \t      build2 (code, vectype, new_name, new_temp));\n \t      new_temp = make_ssa_name (vec_dest, epilog_stmt);\n \t      TREE_OPERAND (epilog_stmt, 0) = new_temp;\n \t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\tprint_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n \t    }\n \n \t  extract_scalar_result = true;\n@@ -924,10 +974,11 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n         {\n \t  tree rhs;\n \n-\t  /*** Case 3:\n-\t     Create:  \n+\t  /*** Case 3: Create:  \n \t     s = extract_field <v_out2, 0>\n-\t     for (offset=element_size; offset<vector_size; offset+=element_size;)\n+\t     for (offset = element_size; \n+\t\t  offset < vector_size; \n+\t\t  offset += element_size;)\n \t       {\n \t         Create:  s' = extract_field <v_out2, offset>\n \t         Create:  s = op <s, s'>\n@@ -938,18 +989,13 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n \n \t  vec_temp = PHI_RESULT (new_phi);\n \t  vec_size_in_bits = tree_low_cst (TYPE_SIZE (vectype), 1);\n-\n \t  rhs = build3 (BIT_FIELD_REF, scalar_type, vec_temp, bitsize,\n \t\t\t bitsize_zero_node);\n-\n \t  BIT_FIELD_REF_UNSIGNED (rhs) = TYPE_UNSIGNED (scalar_type);\n-\t  epilog_stmt = build2 (MODIFY_EXPR, scalar_type, new_scalar_dest, \n-\t\t\t        rhs);\n+\t  epilog_stmt = build2 (MODIFY_EXPR, scalar_type, new_scalar_dest, rhs);\n \t  new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n \t  TREE_OPERAND (epilog_stmt, 0) = new_temp;\n \t  bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    print_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n \t      \n \t  for (bit_offset = element_bitsize;\n \t       bit_offset < vec_size_in_bits;\n@@ -965,25 +1011,19 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n \t      new_name = make_ssa_name (new_scalar_dest, epilog_stmt);\n \t      TREE_OPERAND (epilog_stmt, 0) = new_name;\n \t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\tprint_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n-\n \n \t      epilog_stmt = build2 (MODIFY_EXPR, scalar_type, new_scalar_dest,\n \t\t\t\tbuild2 (code, scalar_type, new_name, new_temp));\n \t      new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n \t      TREE_OPERAND (epilog_stmt, 0) = new_temp;\n \t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\tprint_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n \t    }\n \n \t  extract_scalar_result = false;\n \t}\n     }\n \n-\n-  /* 2.3  Extract the final scalar result.  Create:\n+  /* 2.4  Extract the final scalar result.  Create:\n          s_out3 = extract_field <v_out2, bitpos>  */\n   \n   if (extract_scalar_result)\n@@ -993,7 +1033,6 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"extract scalar result\");\n \n-      /* The result is in the low order bits.  */\n       if (BYTES_BIG_ENDIAN)\n \tbitpos = size_binop (MULT_EXPR,\n \t\t       bitsize_int (TYPE_VECTOR_SUBPARTS (vectype) - 1),\n@@ -1007,17 +1046,14 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n       new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n       TREE_OPERAND (epilog_stmt, 0) = new_temp; \n       bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tprint_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n     }\n \n-\n   /* 2.4 Adjust the final result by the initial value of the reduction\n-\t variable. (when such adjustment is not needed, then\n+\t variable. (When such adjustment is not needed, then\n \t 'scalar_initial_def' is zero).\n \n \t Create: \n-\t s_out = scalar_expr <s_out, scalar_initial_def>  */\n+\t s_out4 = scalar_expr <s_out3, scalar_initial_def>  */\n   \n   if (scalar_initial_def)\n     {\n@@ -1026,18 +1062,13 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n       new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n       TREE_OPERAND (epilog_stmt, 0) = new_temp;\n       bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n-\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        print_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n     }\n \n+  /* 2.6 Replace uses of s_out0 with uses of s_out3  */\n \n-  /* 2.5 Replace uses of s_out0 with uses of s_out3  */\n-\n-  /* Find the loop-closed-use at the loop exit of the original\n-     scalar result.  (The reduction result is expected to have\n-     two immediate uses - one at the latch block, and one at the\n-     loop exit).  */\n+  /* Find the loop-closed-use at the loop exit of the original scalar result.  \n+     (The reduction result is expected to have two immediate uses - one at the \n+     latch block, and one at the loop exit).  */\n   exit_phi = NULL;\n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, scalar_dest)\n     {\n@@ -1047,9 +1078,10 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n \t  break;\n \t}\n     }\n-\n+  /* We expect to have found an exit_phi because of loop-closed-ssa form.  */\n+  gcc_assert (exit_phi);\n+  /* Replace the uses:  */\n   orig_name = PHI_RESULT (exit_phi);\n-\n   FOR_EACH_IMM_USE_SAFE (use_p, imm_iter, orig_name)\n     SET_USE (use_p, new_temp);\n } \n@@ -1060,33 +1092,69 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n    Check if STMT performs a reduction operation that can be vectorized.\n    If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n    stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n-   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+   Return FALSE if not a vectorizable STMT, TRUE otherwise.\n+\n+   This function also handles reduction idioms (patterns) that have been \n+   recognized in advance during vect_pattern_recog. In this case, STMT may be\n+   of this form:\n+     X = pattern_expr (arg0, arg1, ..., X)\n+   and it's STMT_VINFO_RELATED_STMT points to the last stmt in the original\n+   sequence that had been detected and replaced by the pattern-stmt (STMT).\n+  \n+   In some cases of reduction patterns, the type of the reduction variable X is \n+   different than the type of the other arguments of STMT.\n+   In such cases, the vectype that is used when transforming STMT into a vector\n+   stmt is different than the vectype that is used to determine the \n+   vectorization factor, because it consists of a different number of elements \n+   than the actual number of elements that are being operated upon in parallel.\n+\n+   For example, consider an accumulation of shorts into an int accumulator. \n+   On some targets it's possible to vectorize this pattern operating on 8\n+   shorts at a time (hence, the vectype for purposes of determining the\n+   vectorization factor should be V8HI); on the other hand, the vectype that\n+   is used to create the vector form is actually V4SI (the type of the result). \n+\n+   Upon entry to this function, STMT_VINFO_VECTYPE records the vectype that \n+   indicates what is the actual level of parallelism (V8HI in the example), so \n+   that the right vectorization factor would be derived. This vectype \n+   corresponds to the type of arguments to the reduction stmt, and should *NOT* \n+   be used to create the vectorized stmt. The right vectype for the vectorized\n+   stmt is obtained from the type of the result X: \n+        get_vectype_for_scalar_type (TREE_TYPE (X))\n+\n+   This means that, contrary to \"regular\" reductions (or \"regular\" stmts in \n+   general), the following equation:\n+      STMT_VINFO_VECTYPE == get_vectype_for_scalar_type (TREE_TYPE (X))\n+   does *NOT* necessarily hold for reduction patterns.  */\n \n bool\n vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n {\n   tree vec_dest;\n   tree scalar_dest;\n-  tree op0, op1;\n-  tree loop_vec_def;\n+  tree op;\n+  tree loop_vec_def0, loop_vec_def1;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree operation;\n-  enum tree_code code, reduc_code = 0;\n+  enum tree_code code, orig_code, epilog_reduc_code = 0;\n   enum machine_mode vec_mode;\n   int op_type;\n   optab optab, reduc_optab;\n   tree new_temp;\n-  tree def0, def1, def_stmt0, def_stmt1;\n-  enum vect_def_type dt0, dt1;\n+  tree def, def_stmt;\n+  enum vect_def_type dt;\n   tree new_phi;\n   tree scalar_type;\n-  bool is_simple_use0;\n-  bool is_simple_use1;\n+  bool is_simple_use;\n+  tree orig_stmt;\n+  stmt_vec_info orig_stmt_info;\n+  tree expr = NULL_TREE;\n+  int i;\n \n-  /* Is vectorizable reduction?  */\n+  /* 1. Is vectorizable reduction?  */\n \n   /* Not supportable if the reduction variable is used in the loop.  */\n   if (STMT_VINFO_RELEVANT_P (stmt_info))\n@@ -1095,43 +1163,68 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (!STMT_VINFO_LIVE_P (stmt_info))\n     return false;\n \n-  /* Make sure it was already recognized as a reduction pattern.  */\n+  /* Make sure it was already recognized as a reduction computation.  */\n   if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_reduction_def)\n     return false;\n \n+  /* 2. Has this been recognized as a reduction pattern? \n+\n+     Check if STMT represents a pattern that has been recognized\n+     in earlier analysis stages.  For stmts that represent a pattern,\n+     the STMT_VINFO_RELATED_STMT field records the last stmt in\n+     the original sequence that constitutes the pattern.  */\n+\n+  orig_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n+  if (orig_stmt)\n+    {\n+      orig_stmt_info = vinfo_for_stmt (orig_stmt);\n+      gcc_assert (STMT_VINFO_RELATED_STMT (orig_stmt_info) == stmt);\n+      gcc_assert (STMT_VINFO_IN_PATTERN_P (orig_stmt_info));\n+      gcc_assert (!STMT_VINFO_IN_PATTERN_P (stmt_info));\n+    }\n+ \n+  /* 3. Check the operands of the operation. The first operands are defined\n+        inside the loop body. The last operand is the reduction variable,\n+        which is defined by the loop-header-phi.  */\n+\n   gcc_assert (TREE_CODE (stmt) == MODIFY_EXPR);\n \n   operation = TREE_OPERAND (stmt, 1);\n   code = TREE_CODE (operation);\n   op_type = TREE_CODE_LENGTH (code);\n \n-  if (op_type != binary_op)\n+  if (op_type != binary_op && op_type != ternary_op)\n     return false;\n-\n-  op0 = TREE_OPERAND (operation, 0);\n-  op1 = TREE_OPERAND (operation, 1);\n   scalar_dest = TREE_OPERAND (stmt, 0);\n   scalar_type = TREE_TYPE (scalar_dest);\n \n-  /* Check the first operand. It is expected to be defined inside the loop.  */\n-  is_simple_use0 =\n-        vect_is_simple_use (op0, loop_vinfo, &def_stmt0, &def0, &dt0);\n-  is_simple_use1 =\n-        vect_is_simple_use (op1, loop_vinfo, &def_stmt1, &def1, &dt1);\n-\n-  gcc_assert (is_simple_use0);\n-  gcc_assert (is_simple_use1);\n-  gcc_assert (dt0 == vect_loop_def);\n-  gcc_assert (dt1 == vect_reduction_def);\n-  gcc_assert (TREE_CODE (def_stmt1) == PHI_NODE);\n-  gcc_assert (stmt == vect_is_simple_reduction (loop, def_stmt1));\n+  /* All uses but the last are expected to be defined in the loop.\n+     The last use is the reduction variable.  */\n+  for (i = 0; i < op_type-1; i++)\n+    {\n+      op = TREE_OPERAND (operation, i);\n+      is_simple_use = vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt);\n+      gcc_assert (is_simple_use);\n+      gcc_assert (dt == vect_loop_def || dt == vect_invariant_def ||\n+                  dt == vect_constant_def);\n+    }\n \n-  if (STMT_VINFO_LIVE_P (vinfo_for_stmt (def_stmt1)))\n-   return false;\n+  op = TREE_OPERAND (operation, i);\n+  is_simple_use = vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt);\n+  gcc_assert (is_simple_use);\n+  gcc_assert (dt == vect_reduction_def);\n+  gcc_assert (TREE_CODE (def_stmt) == PHI_NODE);\n+  if (orig_stmt) \n+    gcc_assert (orig_stmt == vect_is_simple_reduction (loop, def_stmt));\n+  else\n+    gcc_assert (stmt == vect_is_simple_reduction (loop, def_stmt));\n+  \n+  if (STMT_VINFO_LIVE_P (vinfo_for_stmt (def_stmt)))\n+    return false;\n \n-  /* Supportable by target?  */\n+  /* 4. Supportable by target?  */\n \n-  /* check support for the operation in the loop  */\n+  /* 4.1. check support for the operation in the loop  */\n   optab = optab_for_tree_code (code, vectype);\n   if (!optab)\n     {\n@@ -1162,21 +1255,69 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       return false;\n     }\n \n-  /* check support for the epilog operation  */\n-  if (!reduction_code_for_scalar_code (code, &reduc_code))\n+  /* 4.2. Check support for the epilog operation.\n+\n+          If STMT represents a reduction pattern, then the type of the\n+          reduction variable may be different than the type of the rest\n+          of the arguments.  For example, consider the case of accumulation\n+          of shorts into an int accumulator; The original code:\n+                        S1: int_a = (int) short_a;\n+          orig_stmt->   S2: int_acc = plus <int_a ,int_acc>;\n+\n+          was replaced with:\n+                        STMT: int_acc = widen_sum <short_a, int_acc>\n+\n+          This means that:\n+          1. The tree-code that is used to create the vector operation in the \n+             epilog code (that reduces the partial results) is not the \n+             tree-code of STMT, but is rather the tree-code of the original \n+             stmt from the pattern that STMT is replacing. I.e, in the example \n+             above we want to use 'widen_sum' in the loop, but 'plus' in the \n+             epilog.\n+          2. The type (mode) we use to check available target support\n+             for the vector operation to be created in the *epilog*, is \n+             determined by the type of the reduction variable (in the example \n+             above we'd check this: plus_optab[vect_int_mode]).\n+             However the type (mode) we use to check available target support\n+             for the vector operation to be created *inside the loop*, is\n+             determined by the type of the other arguments to STMT (in the\n+             example we'd check this: widen_sum_optab[vect_short_mode]).\n+  \n+          This is contrary to \"regular\" reductions, in which the types of all \n+          the arguments are the same as the type of the reduction variable. \n+          For \"regular\" reductions we can therefore use the same vector type \n+          (and also the same tree-code) when generating the epilog code and\n+          when generating the code inside the loop.  */\n+\n+  if (orig_stmt)\n+    {\n+      /* This is a reduction pattern: get the vectype from the type of the\n+         reduction variable, and get the tree-code from orig_stmt.  */\n+      orig_code = TREE_CODE (TREE_OPERAND (orig_stmt, 1));\n+      vectype = get_vectype_for_scalar_type (TREE_TYPE (def));\n+      vec_mode = TYPE_MODE (vectype);\n+    }\n+  else\n+    {\n+      /* Regular reduction: use the same vectype and tree-code as used for\n+         the vector code inside the loop can be used for the epilog code. */\n+      orig_code = code;\n+    }\n+\n+  if (!reduction_code_for_scalar_code (orig_code, &epilog_reduc_code))\n     return false;\n-  reduc_optab = optab_for_tree_code (reduc_code, vectype);\n+  reduc_optab = optab_for_tree_code (epilog_reduc_code, vectype);\n   if (!reduc_optab)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"no optab for reduction.\");\n-      reduc_code = NUM_TREE_CODES;\n+      epilog_reduc_code = NUM_TREE_CODES;\n     }\n   if (reduc_optab->handlers[(int) vec_mode].insn_code == CODE_FOR_nothing)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"reduc op not supported by target.\");\n-      reduc_code = NUM_TREE_CODES;\n+      epilog_reduc_code = NUM_TREE_CODES;\n     }\n  \n   if (!vec_stmt) /* transformation not required.  */\n@@ -1193,25 +1334,31 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   /* Create the destination vector  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \n-\n   /* Create the reduction-phi that defines the reduction-operand.  */\n   new_phi = create_phi_node (vec_dest, loop->header);\n \n-\n   /* Prepare the operand that is defined inside the loop body  */\n-  loop_vec_def = vect_get_vec_def_for_operand (op0, stmt, NULL);\n+  op = TREE_OPERAND (operation, 0);\n+  loop_vec_def0 = vect_get_vec_def_for_operand (op, stmt, NULL);\n+  if (op_type == binary_op)\n+    expr = build2 (code, vectype, loop_vec_def0, PHI_RESULT (new_phi));\n+  else if (op_type == ternary_op)\n+    {\n+      op = TREE_OPERAND (operation, 1);\n+      loop_vec_def1 = vect_get_vec_def_for_operand (op, stmt, NULL);\n+      expr = build3 (code, vectype, loop_vec_def0, loop_vec_def1, \n+\t\t     PHI_RESULT (new_phi));\n+    }\n \n   /* Create the vectorized operation that computes the partial results  */\n-  *vec_stmt = build2 (MODIFY_EXPR, vectype, vec_dest,\n-                build2 (code, vectype, loop_vec_def, PHI_RESULT (new_phi)));\n+  *vec_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, expr);\n   new_temp = make_ssa_name (vec_dest, *vec_stmt);\n   TREE_OPERAND (*vec_stmt, 0) = new_temp;\n   vect_finish_stmt_generation (stmt, *vec_stmt, bsi);\n \n-\n   /* Finalize the reduction-phi (set it's arguments) and create the\n      epilog reduction code.  */\n-  vect_create_epilog_for_reduction (new_temp, stmt, op1, reduc_code, new_phi);\n+  vect_create_epilog_for_reduction (new_temp, stmt, epilog_reduc_code, new_phi);\n   return true;\n }\n \n@@ -2040,6 +2187,7 @@ vect_transform_stmt (tree stmt, block_stmt_iterator *bsi)\n   bool is_store = false;\n   tree vec_stmt = NULL_TREE;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  tree orig_stmt_in_pattern;\n   bool done;\n \n   if (STMT_VINFO_RELEVANT_P (stmt_info))\n@@ -2078,7 +2226,25 @@ vect_transform_stmt (tree stmt, block_stmt_iterator *bsi)\n \tgcc_unreachable ();\n       }\n \n+      gcc_assert (vec_stmt);\n       STMT_VINFO_VEC_STMT (stmt_info) = vec_stmt;\n+      orig_stmt_in_pattern = STMT_VINFO_RELATED_STMT (stmt_info);\n+      if (orig_stmt_in_pattern)\n+        {\n+          stmt_vec_info stmt_vinfo = vinfo_for_stmt (orig_stmt_in_pattern);\n+          if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n+            {\n+              gcc_assert (STMT_VINFO_RELATED_STMT (stmt_vinfo) == stmt);\n+\n+              /* STMT was inserted by the vectorizer to replace a computation \n+                 idiom.  ORIG_STMT_IN_PATTERN is a stmt in the original\n+                 sequence that computed this idiom.  We need to record a pointer\n+                 to VEC_STMT in the stmt_info of ORIG_STMT_IN_PATTERN.  See more\n+                 detail in the documentation of vect_pattern_recog.  */\n+\n+              STMT_VINFO_VEC_STMT (stmt_vinfo) = vec_stmt;\n+            }\n+        }\n     }\n \n   if (STMT_VINFO_LIVE_P (stmt_info))"}, {"sha": "f03a2a2ce9a9b5975c90dfbca36c24f85cd595c4", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -1,5 +1,5 @@\n /* Loop Vectorization\n-   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n    Contributed by Dorit Naishlos <dorit@il.ibm.com>\n \n This file is part of GCC.\n@@ -1361,6 +1361,8 @@ new_stmt_vec_info (tree stmt, loop_vec_info loop_vinfo)\n   STMT_VINFO_LIVE_P (res) = 0;\n   STMT_VINFO_VECTYPE (res) = NULL;\n   STMT_VINFO_VEC_STMT (res) = NULL;\n+  STMT_VINFO_IN_PATTERN_P (res) = false;\n+  STMT_VINFO_RELATED_STMT (res) = NULL;\n   STMT_VINFO_DATA_REF (res) = NULL;\n   if (TREE_CODE (stmt) == PHI_NODE)\n     STMT_VINFO_DEF_TYPE (res) = vect_unknown_def_type;"}, {"sha": "c5b1378143611f0256e3780468a10292d7107e23", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -1,5 +1,5 @@\n /* Loop Vectorization\n-   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n    Contributed by Dorit Naishlos <dorit@il.ibm.com>\n \n This file is part of GCC.\n@@ -43,10 +43,11 @@ enum vect_var_kind {\n   vect_scalar_var\n };\n \n-/* Defines type of operation: unary or binary.  */\n+/* Defines type of operation.  */\n enum operation_type {\n   unary_op = 1,\n-  binary_op\n+  binary_op,\n+  ternary_op\n };\n \n /* Define type of available alignment support.  */\n@@ -204,6 +205,20 @@ typedef struct _stmt_vec_info {\n   /* Information about the data-ref (access function, etc).  */\n   struct data_reference *data_ref_info;\n \n+  /* Stmt is part of some pattern (computation idiom)  */\n+  bool in_pattern_p;\n+\n+  /* Used for various bookeeping purposes, generally holding a pointer to \n+     some other stmt S that is in some way \"related\" to this stmt. \n+     Current use of this field is:\n+        If this stmt is part of a pattern (i.e. the field 'in_pattern_p' is \n+        true): S is the \"pattern stmt\" that represents (and replaces) the \n+        sequence of stmts that constitutes the pattern.  Similarly, the \n+        related_stmt of the \"pattern stmt\" points back to this stmt (which is \n+        the last stmt in the original sequence of stmts that constitutes the \n+        pattern).  */\n+  tree related_stmt;\n+\n   /* List of datarefs that are known to have the same alignment as the dataref\n      of this stmt.  */\n   VEC(dr_p,heap) *same_align_refs;\n@@ -222,6 +237,8 @@ typedef struct _stmt_vec_info {\n #define STMT_VINFO_VECTYPE(S)             (S)->vectype\n #define STMT_VINFO_VEC_STMT(S)            (S)->vectorized_stmt\n #define STMT_VINFO_DATA_REF(S)            (S)->data_ref_info\n+#define STMT_VINFO_IN_PATTERN_P(S)        (S)->in_pattern_p\n+#define STMT_VINFO_RELATED_STMT(S)        (S)->related_stmt\n #define STMT_VINFO_SAME_ALIGN_REFS(S)     (S)->same_align_refs\n #define STMT_VINFO_DEF_TYPE(S)            (S)->def_type\n \n@@ -312,18 +329,28 @@ extern bool vect_can_force_dr_alignment_p (tree, unsigned int);\n extern enum dr_alignment_support vect_supportable_dr_alignment\n   (struct data_reference *);\n extern bool reduction_code_for_scalar_code (enum tree_code, enum tree_code *);\n-\n /* Creation and deletion of loop and stmt info structs.  */\n extern loop_vec_info new_loop_vec_info (struct loop *loop);\n extern void destroy_loop_vec_info (loop_vec_info);\n extern stmt_vec_info new_stmt_vec_info (tree stmt, loop_vec_info);\n /* Main driver.  */\n extern void vectorize_loops (struct loops *);\n \n+\n /** In tree-vect-analyze.c  **/\n /* Driver for analysis stage.  */\n extern loop_vec_info vect_analyze_loop (struct loop *);\n \n+\n+/** In tree-vect-patterns.c  **/\n+/* Pattern recognition functions.\n+   Additional pattern recognition functions can (and will) be added\n+   in the future.  */\n+typedef tree (* vect_recog_func_ptr) (tree, tree *, tree *);\n+#define NUM_PATTERNS 3\n+void vect_pattern_recog (loop_vec_info);\n+\n+\n /** In tree-vect-transform.c  **/\n extern bool vectorizable_load (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_store (tree, block_stmt_iterator *, tree *);"}, {"sha": "3cd03fd9f030dfbfefefa7b2cdd477f2c72a8f7f", "filename": "gcc/tree.def", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f0622174914622858a91a712e57ace4a44d793/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=20f0622174914622858a91a712e57ace4a44d793", "patch": "@@ -1,7 +1,7 @@\n /* This file contains the definitions and documentation for the\n    tree codes used in GCC.\n-   Copyright (C) 1987, 1988, 1993, 1995, 1997, 1998, 2000, 2001, 2004, 2005\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1993, 1995, 1997, 1998, 2000, 2001, 2004, 2005, \n+   2006 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1073,6 +1073,33 @@ DEFTREECODE (REDUC_MAX_EXPR, \"reduc_max_expr\", tcc_unary, 1)\n DEFTREECODE (REDUC_MIN_EXPR, \"reduc_min_expr\", tcc_unary, 1)\n DEFTREECODE (REDUC_PLUS_EXPR, \"reduc_plus_expr\", tcc_unary, 1)\n \n+/* Widenning dot-product.\n+   The first two arguments are of type t1.\n+   The third argument and the result are of type t2, such that t2 is at least\n+   twice the size of t1. DOT_PROD_EXPR(arg1,arg2,arg3) is equivalent to:\n+   \ttmp = WIDEN_MULT_EXPR(arg1, arg2);\n+   \targ3 = PLUS_EXPR (tmp, arg3);\n+   or: \n+\ttmp = WIDEN_MULT_EXPR(arg1, arg2);\n+        arg3 = WIDEN_SUM_EXPR (tmp, arg3);\t\t */\n+DEFTREECODE (DOT_PROD_EXPR, \"dot_prod_expr\", tcc_expression, 3)\n+\n+/* Widenning summation.\n+   The first argument is of type t1.\n+   The second argument is of type t2, such that t2 is at least twice\n+   the size of t1. The type of the entire expression is also t2.\n+   WIDEN_SUM_EXPR is equivalent to first widening (promoting)\n+   the first argument from type t1 to type t2, and then summing it\n+   with the second argument.  */\n+DEFTREECODE (WIDEN_SUM_EXPR, \"widen_sum_expr\", tcc_binary, 2)\n+   \n+/* Widenning multiplication. \n+   The two arguments are of type t1.\n+   The result is of type t2, such that t2 is at least twice\n+   the size of t1. WIDEN_MULT_EXPR is equivalent to first widening (promoting)\n+   the arguments from type t1 to type t2, and then multiplying them.  */\n+DEFTREECODE (WIDEN_MULT_EXPR, \"widen_mult_expr\", tcc_binary, 2)\n+\n /* Whole vector left/right shift in bits.\n    Operand 0 is a vector to be shifted.\n    Operand 1 is an integer shift amount in bits.  */"}]}