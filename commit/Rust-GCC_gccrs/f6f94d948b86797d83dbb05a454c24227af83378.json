{"sha": "f6f94d948b86797d83dbb05a454c24227af83378", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZmOTRkOTQ4Yjg2Nzk3ZDgzZGJiMDVhNDU0YzI0MjI3YWY4MzM3OA==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2013-01-09T03:01:07Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2013-01-09T03:01:07Z"}, "message": "pa.h (VAL_U6_BITS_P): Define.\n\n\t* config/pa/pa.h (VAL_U6_BITS_P): Define.\n\t(INT_U6_BITS): Likewise.\n\t* config/pa/predicates.md (uint6_operand): New predicate.\n\t(shift5_operand, shift6_operand): Likewise.\n\t* config/pa/pa.md (lshrsi3, rotrsi3): Use shift5_operand instead of\n\tarith32_operand.\n\t(lshrdi3): Use shift6_operand.\n\t(shrpsi4, shrpdi4): New insn patterns.\n\t(extzv): Delete expander.\n\t(extzvsi, extzvdi): New expanders.  Use uint5_operand and uint6_operand\n\tpredicates in unamed zero extract patterns.  Tighten common constraint.\n\t(extv): Delete expander.\n\t(extvsi, extvdi): New expanders.  Use uint5_operand and uint6_operand\n\tpredicates in unamed sign extract patterns.  Tighten common constraint.\n\t(insv): Delete expander.\n\t(insvsi, insvdi): New expanders.  Use uint5_operand and uint6_operand\n\tpredicates in unamed insert patterns.  Tighten common constraint.\n\tChange uint32_operand predicate to uint6_operand predicate in unamed\n\tDImode pattern to insert constant values of type 1...1xxxx.\n\nFrom-SVN: r195045", "tree": {"sha": "0cbde4d9f4cd5ba302b8129439c2dc85107fcdf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cbde4d9f4cd5ba302b8129439c2dc85107fcdf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6f94d948b86797d83dbb05a454c24227af83378", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6f94d948b86797d83dbb05a454c24227af83378", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6f94d948b86797d83dbb05a454c24227af83378", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6f94d948b86797d83dbb05a454c24227af83378/comments", "author": null, "committer": null, "parents": [{"sha": "2a4e207b711fda02c76a844e55ce44f0286e4f67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a4e207b711fda02c76a844e55ce44f0286e4f67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a4e207b711fda02c76a844e55ce44f0286e4f67"}], "stats": {"total": 292, "additions": 226, "deletions": 66}, "files": [{"sha": "b29c10b31b4dc5d5e4f91bee816e39a535f8831e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6f94d948b86797d83dbb05a454c24227af83378/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6f94d948b86797d83dbb05a454c24227af83378/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f6f94d948b86797d83dbb05a454c24227af83378", "patch": "@@ -1,3 +1,25 @@\n+2013-01-08  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\t* config/pa/pa.h (VAL_U6_BITS_P): Define.\n+\t(INT_U6_BITS): Likewise.\n+\t* config/pa/predicates.md (uint6_operand): New predicate.\n+\t(shift5_operand, shift6_operand): Likewise.\n+\t* config/pa/pa.md (lshrsi3, rotrsi3): Use shift5_operand instead of\n+\tarith32_operand.\n+\t(lshrdi3): Use shift6_operand.\n+\t(shrpsi4, shrpdi4): New insn patterns.\n+\t(extzv): Delete expander.\n+\t(extzvsi, extzvdi): New expanders.  Use uint5_operand and uint6_operand\n+\tpredicates in unamed zero extract patterns.  Tighten common constraint.\n+\t(extv): Delete expander.\n+\t(extvsi, extvdi): New expanders.  Use uint5_operand and uint6_operand\n+\tpredicates in unamed sign extract patterns.  Tighten common constraint.\n+\t(insv): Delete expander.\n+\t(insvsi, insvdi): New expanders.  Use uint5_operand and uint6_operand\n+\tpredicates in unamed insert patterns.  Tighten common constraint.\n+\tChange uint32_operand predicate to uint6_operand predicate in unamed\n+\tDImode pattern to insert constant values of type 1...1xxxx.\n+\n 2013-01-04  Jan Hubicka  <jh@suse.cz>\n \n \tPR tree-optimization/55823"}, {"sha": "ee89320582cf7b0cecdfc2593a6f148c490941b5", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6f94d948b86797d83dbb05a454c24227af83378/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6f94d948b86797d83dbb05a454c24227af83378/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=f6f94d948b86797d83dbb05a454c24227af83378", "patch": "@@ -956,6 +956,9 @@ extern int may_call_alloca;\n #define VAL_U5_BITS_P(X) ((unsigned HOST_WIDE_INT)(X) < 0x20)\n #define INT_U5_BITS(X) VAL_U5_BITS_P (INTVAL (X))\n \n+#define VAL_U6_BITS_P(X) ((unsigned HOST_WIDE_INT)(X) < 0x40)\n+#define INT_U6_BITS(X) VAL_U6_BITS_P (INTVAL (X))\n+\n #define VAL_11_BITS_P(X) ((unsigned HOST_WIDE_INT)(X) + 0x400 < 0x800)\n #define INT_11_BITS(X) VAL_11_BITS_P (INTVAL (X))\n "}, {"sha": "6cbe9aaf3ef0ad87677c53c863e41c4756c13488", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 180, "deletions": 66, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6f94d948b86797d83dbb05a454c24227af83378/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6f94d948b86797d83dbb05a454c24227af83378/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=f6f94d948b86797d83dbb05a454c24227af83378", "patch": "@@ -6584,7 +6584,7 @@\n (define_insn \"lshrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n-\t\t     (match_operand:SI 2 \"arith32_operand\" \"q,n\")))]\n+\t\t     (match_operand:SI 2 \"shift5_operand\" \"q,n\")))]\n   \"\"\n   \"@\n    {vshd %%r0,%1,%0|shrpw %%r0,%1,%%sar,%0}\n@@ -6595,18 +6595,48 @@\n (define_insn \"lshrdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"r,r\")\n-\t\t     (match_operand:DI 2 \"arith32_operand\" \"q,n\")))]\n+\t\t     (match_operand:DI 2 \"shift6_operand\" \"q,n\")))]\n   \"TARGET_64BIT\"\n   \"@\n    shrpd %%r0,%1,%%sar,%0\n    extrd,u %1,%p2,%Q2,%0\"\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n \n+; Shift right pair word 0 to 31 bits.\n+(define_insn \"shrpsi4\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ior:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t\t   (minus:SI (const_int 32)\n+\t\t\t     (match_operand:SI 3 \"shift5_operand\" \"q,n\")))\n+\t\t(lshiftrt:SI (match_operand:SI 2 \"register_operand\" \"r,r\")\n+\t\t\t     (match_dup 3))))]\n+  \"\"\n+  \"@\n+   {vshd %1,%2,%0|shrpw %1,%2,%%sar,%0}\n+   {shd|shrpw} %1,%2,%3,%0\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n+\n+; Shift right pair doubleword 0 to 63 bits.\n+(define_insn \"shrpdi4\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(ior:DI (ashift:DI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t\t   (minus:DI (const_int 64)\n+\t\t\t     (match_operand:DI 3 \"shift6_operand\" \"q,n\")))\n+\t\t(lshiftrt:DI (match_operand:DI 2 \"register_operand\" \"r,r\")\n+\t\t\t     (match_dup 3))))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   shrpd %1,%2,%%sar,%0\n+   shrpd %1,%2,%3,%0\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"rotrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(rotatert:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n-\t\t     (match_operand:SI 2 \"arith32_operand\" \"q,n\")))]\n+\t\t     (match_operand:SI 2 \"shift5_operand\" \"q,n\")))]\n   \"\"\n   \"*\n {\n@@ -8365,34 +8395,31 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n }\")\n \n ;;; Operands 2 and 3 are assumed to be CONST_INTs.\n-(define_expand \"extzv\"\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-\t(zero_extract (match_operand 1 \"register_operand\" \"\")\n-\t\t      (match_operand 2 \"uint32_operand\" \"\")\n-\t\t      (match_operand 3 \"uint32_operand\" \"\")))]\n+(define_expand \"extzvsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"uint5_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"uint5_operand\" \"\")))]\n   \"\"\n   \"\n {\n-  HOST_WIDE_INT len = INTVAL (operands[2]);\n-  HOST_WIDE_INT pos = INTVAL (operands[3]);\n+  unsigned HOST_WIDE_INT len = UINTVAL (operands[2]);\n+  unsigned HOST_WIDE_INT pos = UINTVAL (operands[3]);\n \n   /* PA extraction insns don't support zero length bitfields or fields\n-     extending beyond the left or right-most bits.  Also, we reject lengths\n-     equal to a word as they are better handled by the move patterns.  */\n-  if (len <= 0 || len >= BITS_PER_WORD || pos < 0 || pos + len > BITS_PER_WORD)\n+     extending beyond the left or right-most bits.  Also, the predicate\n+     rejects lengths equal to a word as they are better handled by\n+     the move patterns.  */\n+  if (len == 0 || pos + len > 32)\n     FAIL;\n \n   /* From mips.md: extract_bit_field doesn't verify that our source\n      matches the predicate, so check it again here.  */\n   if (!register_operand (operands[1], VOIDmode))\n     FAIL;\n \n-  if (TARGET_64BIT)\n-    emit_insn (gen_extzv_64 (operands[0], operands[1],\n-\t\t\t     operands[2], operands[3]));\n-  else\n-    emit_insn (gen_extzv_32 (operands[0], operands[1],\n-\t\t\t     operands[2], operands[3]));\n+  emit_insn (gen_extzv_32 (operands[0], operands[1],\n+\t\t\t   operands[2], operands[3]));\n   DONE;\n }\")\n \n@@ -8401,7 +8428,8 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t (match_operand:SI 2 \"uint5_operand\" \"\")\n \t\t\t (match_operand:SI 3 \"uint5_operand\" \"\")))]\n-  \"\"\n+  \"UINTVAL (operands[2]) > 0\n+   && UINTVAL (operands[2]) + UINTVAL (operands[3]) <= 32\"\n   \"{extru|extrw,u} %1,%3+%2-1,%2,%0\"\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n@@ -8416,12 +8444,42 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n \n+(define_expand \"extzvdi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(zero_extract:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t\t (match_operand:DI 2 \"uint6_operand\" \"\")\n+\t\t\t (match_operand:DI 3 \"uint6_operand\" \"\")))]\n+  \"TARGET_64BIT\"\n+  \"\n+{\n+  unsigned HOST_WIDE_INT len = UINTVAL (operands[2]);\n+  unsigned HOST_WIDE_INT pos = UINTVAL (operands[3]);\n+\n+  /* PA extraction insns don't support zero length bitfields or fields\n+     extending beyond the left or right-most bits.  Also, the predicate\n+     rejects lengths equal to a doubleword as they are better handled by\n+     the move patterns.  */\n+  if (len == 0 || pos + len > 64)\n+    FAIL;\n+\n+  /* From mips.md: extract_bit_field doesn't verify that our source\n+     matches the predicate, so check it again here.  */\n+  if (!register_operand (operands[1], VOIDmode))\n+    FAIL;\n+\n+  emit_insn (gen_extzv_64 (operands[0], operands[1],\n+\t\t\t   operands[2], operands[3]));\n+  DONE;\n+}\")\n+\n (define_insn \"extzv_64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extract:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t\t (match_operand:DI 2 \"uint32_operand\" \"\")\n-\t\t\t (match_operand:DI 3 \"uint32_operand\" \"\")))]\n-  \"TARGET_64BIT\"\n+\t\t\t (match_operand:DI 2 \"uint6_operand\" \"\")\n+\t\t\t (match_operand:DI 3 \"uint6_operand\" \"\")))]\n+  \"TARGET_64BIT\n+   && UINTVAL (operands[2]) > 0\n+   && UINTVAL (operands[2]) + UINTVAL (operands[3]) <= 64\"\n   \"extrd,u %1,%3+%2-1,%2,%0\"\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n@@ -8437,34 +8495,31 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n    (set_attr \"length\" \"4\")])\n \n ;;; Operands 2 and 3 are assumed to be CONST_INTs.\n-(define_expand \"extv\"\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-\t(sign_extract (match_operand 1 \"register_operand\" \"\")\n-\t\t      (match_operand 2 \"uint32_operand\" \"\")\n-\t\t      (match_operand 3 \"uint32_operand\" \"\")))]\n+(define_expand \"extvsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"uint5_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"uint5_operand\" \"\")))]\n   \"\"\n   \"\n {\n-  HOST_WIDE_INT len = INTVAL (operands[2]);\n-  HOST_WIDE_INT pos = INTVAL (operands[3]);\n+  unsigned HOST_WIDE_INT len = UINTVAL (operands[2]);\n+  unsigned HOST_WIDE_INT pos = UINTVAL (operands[3]);\n \n   /* PA extraction insns don't support zero length bitfields or fields\n-     extending beyond the left or right-most bits.  Also, we reject lengths\n-     equal to a word as they are better handled by the move patterns.  */\n-  if (len <= 0 || len >= BITS_PER_WORD || pos < 0 || pos + len > BITS_PER_WORD)\n+     extending beyond the left or right-most bits.  Also, the predicate\n+     rejects lengths equal to a word as they are better handled by\n+     the move patterns.  */\n+  if (len == 0 || pos + len > 32)\n     FAIL;\n \n   /* From mips.md: extract_bit_field doesn't verify that our source\n      matches the predicate, so check it again here.  */\n   if (!register_operand (operands[1], VOIDmode))\n     FAIL;\n \n-  if (TARGET_64BIT)\n-    emit_insn (gen_extv_64 (operands[0], operands[1],\n-\t\t\t    operands[2], operands[3]));\n-  else\n-    emit_insn (gen_extv_32 (operands[0], operands[1],\n-\t\t\t    operands[2], operands[3]));\n+  emit_insn (gen_extv_32 (operands[0], operands[1],\n+\t\t\t  operands[2], operands[3]));\n   DONE;\n }\")\n \n@@ -8473,7 +8528,8 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t (match_operand:SI 2 \"uint5_operand\" \"\")\n \t\t\t (match_operand:SI 3 \"uint5_operand\" \"\")))]\n-  \"\"\n+  \"UINTVAL (operands[2]) > 0\n+   && UINTVAL (operands[2]) + UINTVAL (operands[3]) <= 32\"\n   \"{extrs|extrw,s} %1,%3+%2-1,%2,%0\"\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n@@ -8488,12 +8544,42 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n \n+(define_expand \"extvdi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(sign_extract:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t\t (match_operand:DI 2 \"uint6_operand\" \"\")\n+\t\t\t (match_operand:DI 3 \"uint6_operand\" \"\")))]\n+  \"TARGET_64BIT\"\n+  \"\n+{\n+  unsigned HOST_WIDE_INT len = UINTVAL (operands[2]);\n+  unsigned HOST_WIDE_INT pos = UINTVAL (operands[3]);\n+\n+  /* PA extraction insns don't support zero length bitfields or fields\n+     extending beyond the left or right-most bits.  Also, the predicate\n+     rejects lengths equal to a doubleword as they are better handled by\n+     the move patterns.  */\n+  if (len == 0 || pos + len > 64)\n+    FAIL;\n+\n+  /* From mips.md: extract_bit_field doesn't verify that our source\n+     matches the predicate, so check it again here.  */\n+  if (!register_operand (operands[1], VOIDmode))\n+    FAIL;\n+\n+  emit_insn (gen_extv_64 (operands[0], operands[1],\n+\t\t\t  operands[2], operands[3]));\n+  DONE;\n+}\")\n+\n (define_insn \"extv_64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(sign_extract:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t\t (match_operand:DI 2 \"uint32_operand\" \"\")\n-\t\t\t (match_operand:DI 3 \"uint32_operand\" \"\")))]\n-  \"TARGET_64BIT\"\n+\t\t\t (match_operand:DI 2 \"uint6_operand\" \"\")\n+\t\t\t (match_operand:DI 3 \"uint6_operand\" \"\")))]\n+  \"TARGET_64BIT\n+   && UINTVAL (operands[2]) > 0\n+   && UINTVAL (operands[2]) + UINTVAL (operands[3]) <= 64\"\n   \"extrd,s %1,%3+%2-1,%2,%0\"\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n@@ -8509,34 +8595,31 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n    (set_attr \"length\" \"4\")])\n \n ;;; Operands 1 and 2 are assumed to be CONST_INTs.\n-(define_expand \"insv\"\n-  [(set (zero_extract (match_operand 0 \"register_operand\" \"\")\n-                      (match_operand 1 \"uint32_operand\" \"\")\n-                      (match_operand 2 \"uint32_operand\" \"\"))\n-        (match_operand 3 \"arith5_operand\" \"\"))]\n+(define_expand \"insvsi\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t\t (match_operand:SI 1 \"uint5_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"uint5_operand\" \"\"))\n+\t(match_operand:SI 3 \"arith5_operand\" \"\"))]\n   \"\"\n   \"\n {\n-  HOST_WIDE_INT len = INTVAL (operands[1]);\n-  HOST_WIDE_INT pos = INTVAL (operands[2]);\n+  unsigned HOST_WIDE_INT len = UINTVAL (operands[1]);\n+  unsigned HOST_WIDE_INT pos = UINTVAL (operands[2]);\n \n   /* PA insertion insns don't support zero length bitfields or fields\n-     extending beyond the left or right-most bits.  Also, we reject lengths\n-     equal to a word as they are better handled by the move patterns.  */\n-  if (len <= 0 || len >= BITS_PER_WORD || pos < 0 || pos + len > BITS_PER_WORD)\n+     extending beyond the left or right-most bits.  Also, the predicate\n+     rejects lengths equal to a word as they are better handled by\n+     the move patterns.  */\n+  if (len <= 0 || pos + len > 32)\n     FAIL;\n \n   /* From mips.md: insert_bit_field doesn't verify that our destination\n      matches the predicate, so check it again here.  */\n   if (!register_operand (operands[0], VOIDmode))\n     FAIL;\n \n-  if (TARGET_64BIT)\n-    emit_insn (gen_insv_64 (operands[0], operands[1],\n-\t\t\t    operands[2], operands[3]));\n-  else\n-    emit_insn (gen_insv_32 (operands[0], operands[1],\n-\t\t\t    operands[2], operands[3]));\n+  emit_insn (gen_insv_32 (operands[0], operands[1],\n+\t\t\t  operands[2], operands[3]));\n   DONE;\n }\")\n \n@@ -8545,7 +8628,8 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t\t\t (match_operand:SI 1 \"uint5_operand\" \"\")\n \t\t\t (match_operand:SI 2 \"uint5_operand\" \"\"))\n \t(match_operand:SI 3 \"arith5_operand\" \"r,L\"))]\n-  \"\"\n+  \"UINTVAL (operands[1]) > 0\n+   && UINTVAL (operands[1]) + UINTVAL (operands[2]) <= 32\"\n   \"@\n    {dep|depw} %3,%2+%1-1,%1,%0\n    {depi|depwi} %3,%2+%1-1,%1,%0\"\n@@ -8568,12 +8652,42 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n \n+(define_expand \"insvdi\"\n+  [(set (zero_extract:DI (match_operand:DI 0 \"register_operand\" \"\")\n+\t\t\t (match_operand:DI 1 \"uint6_operand\" \"\")\n+\t\t\t (match_operand:DI 2 \"uint6_operand\" \"\"))\n+\t(match_operand:DI 3 \"arith5_operand\" \"\"))]\n+  \"TARGET_64BIT\"\n+  \"\n+{\n+  unsigned HOST_WIDE_INT len = UINTVAL (operands[1]);\n+  unsigned HOST_WIDE_INT pos = UINTVAL (operands[2]);\n+\n+  /* PA insertion insns don't support zero length bitfields or fields\n+     extending beyond the left or right-most bits.  Also, the predicate\n+     rejects lengths equal to a doubleword as they are better handled by\n+     the move patterns.  */\n+  if (len <= 0 || pos + len > 64)\n+    FAIL;\n+\n+  /* From mips.md: insert_bit_field doesn't verify that our destination\n+     matches the predicate, so check it again here.  */\n+  if (!register_operand (operands[0], VOIDmode))\n+    FAIL;\n+\n+  emit_insn (gen_insv_64 (operands[0], operands[1],\n+\t\t\t  operands[2], operands[3]));\n+  DONE;\n+}\")\n+\n (define_insn \"insv_64\"\n   [(set (zero_extract:DI (match_operand:DI 0 \"register_operand\" \"+r,r\")\n-\t\t\t (match_operand:DI 1 \"uint32_operand\" \"\")\n-\t\t\t (match_operand:DI 2 \"uint32_operand\" \"\"))\n-\t(match_operand:DI 3 \"arith32_operand\" \"r,L\"))]\n-  \"TARGET_64BIT\"\n+\t\t\t (match_operand:DI 1 \"uint6_operand\" \"\")\n+\t\t\t (match_operand:DI 2 \"uint6_operand\" \"\"))\n+\t(match_operand:DI 3 \"arith5_operand\" \"r,L\"))]\n+  \"TARGET_64BIT\n+   && UINTVAL (operands[1]) > 0\n+   && UINTVAL (operands[1]) + UINTVAL (operands[2]) <= 64\"\n   \"@\n    depd %3,%2+%1-1,%1,%0\n    depdi %3,%2+%1-1,%1,%0\"\n@@ -8583,8 +8697,8 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n ;; Optimize insertion of const_int values of type 1...1xxxx.\n (define_insn \"\"\n   [(set (zero_extract:DI (match_operand:DI 0 \"register_operand\" \"+r\")\n-\t\t\t (match_operand:DI 1 \"uint32_operand\" \"\")\n-\t\t\t (match_operand:DI 2 \"uint32_operand\" \"\"))\n+\t\t\t (match_operand:DI 1 \"uint6_operand\" \"\")\n+\t\t\t (match_operand:DI 2 \"uint6_operand\" \"\"))\n \t(match_operand:DI 3 \"const_int_operand\" \"\"))]\n   \"(INTVAL (operands[3]) & 0x10) != 0\n    && TARGET_64BIT"}, {"sha": "408a416be59718a994cd0adf5d889fe31639d85a", "filename": "gcc/config/pa/predicates.md", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6f94d948b86797d83dbb05a454c24227af83378/gcc%2Fconfig%2Fpa%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6f94d948b86797d83dbb05a454c24227af83378/gcc%2Fconfig%2Fpa%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpredicates.md?ref=f6f94d948b86797d83dbb05a454c24227af83378", "patch": "@@ -31,6 +31,13 @@\n   (and (match_code \"const_int\")\n        (match_test \"INT_U5_BITS (op)\")))\n \n+;; Return truth value of whether OP is an integer which fits the range\n+;; constraining 6-bit unsigned immediate operands in three-address insns.\n+\n+(define_predicate \"uint6_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INT_U6_BITS (op)\")))\n+\n ;; Return truth value of whether OP is an integer which fits the range\n ;; constraining 11-bit signed immediate operands in three-address insns.\n \n@@ -125,6 +132,20 @@\n   (ior (match_operand 0 \"register_operand\")\n        (match_code \"const_int\")))\n \n+;; Return truth value of whether OP can be used as a shift operand in\n+;; a shift insn that accepts registers of mode MODE or 5-bit shift amounts.\n+\n+(define_predicate \"shift5_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"uint5_operand\")))\n+\n+;; Return truth value of whether OP can be used as a shift operand in\n+;; a shift insn that accepts registers of mode MODE or 6-bit shift amounts.\n+\n+(define_predicate \"shift6_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"uint6_operand\")))\n+\n ;; True iff OP can be used as an operand in an adddi3 insn.\n \n (define_predicate \"adddi3_operand\""}]}