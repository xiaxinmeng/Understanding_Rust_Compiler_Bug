{"sha": "11017cc737b10f7eb7544ae55a340584d22fb9a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTEwMTdjYzczN2IxMGY3ZWI3NTQ0YWU1NWEzNDA1ODRkMjJmYjlhOA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-08-12T01:45:23Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-08-12T01:45:23Z"}, "message": "expr.c (expand_expr): If an ABS_EXPR has a complex type, abort.\n\n\n\t* expr.c (expand_expr): If an ABS_EXPR has a complex type, abort.\n\t* c-typeck.c (build_unary_op): COMPLEX_TYPE is not a valid\n\ttypecode for an ABS_EXPR.\n\n\t* doc/c-tree.texi: Document ABS_EXPR.\n\nFrom-SVN: r70349", "tree": {"sha": "a8d42fe56d075487227b2ad0039a17a20b332091", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8d42fe56d075487227b2ad0039a17a20b332091"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11017cc737b10f7eb7544ae55a340584d22fb9a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11017cc737b10f7eb7544ae55a340584d22fb9a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11017cc737b10f7eb7544ae55a340584d22fb9a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11017cc737b10f7eb7544ae55a340584d22fb9a8/comments", "author": null, "committer": null, "parents": [{"sha": "af7b5c1c00a3ee89369358ef8a53f4b4b74bbbf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af7b5c1c00a3ee89369358ef8a53f4b4b74bbbf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af7b5c1c00a3ee89369358ef8a53f4b4b74bbbf9"}], "stats": {"total": 30, "additions": 26, "deletions": 4}, "files": [{"sha": "92b6a3eb395cd83be64adde4bcfcd730480637f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11017cc737b10f7eb7544ae55a340584d22fb9a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11017cc737b10f7eb7544ae55a340584d22fb9a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=11017cc737b10f7eb7544ae55a340584d22fb9a8", "patch": "@@ -1,3 +1,11 @@\n+2003-08-11  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* expr.c (expand_expr): If an ABS_EXPR has a complex type, abort.\n+\t* c-typeck.c (build_unary_op): COMPLEX_TYPE is not a valid\n+\ttypecode for an ABS_EXPR.\n+\n+\t* doc/c-tree.texi: Document ABS_EXPR.\n+\n 2003-08-11  Roger Sayle  <roger@eyesopen.com>\n \n \t* fold-const.c (fold): Optimize any associative floating point"}, {"sha": "224741bf819b98c71b13a573ace6490dc8239e3b", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11017cc737b10f7eb7544ae55a340584d22fb9a8/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11017cc737b10f7eb7544ae55a340584d22fb9a8/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=11017cc737b10f7eb7544ae55a340584d22fb9a8", "patch": "@@ -2152,8 +2152,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n       break;\n \n     case ABS_EXPR:\n-      if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE\n-\t    || typecode == COMPLEX_TYPE))\n+      if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE))\n \t{\n \t  error (\"wrong type argument to abs\");\n \t  return error_mark_node;"}, {"sha": "29ccaec317dedfeaebda8caf7922066bb9c29da7", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11017cc737b10f7eb7544ae55a340584d22fb9a8/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11017cc737b10f7eb7544ae55a340584d22fb9a8/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=11017cc737b10f7eb7544ae55a340584d22fb9a8", "patch": "@@ -1720,6 +1720,7 @@ This macro returns the attributes on the type @var{type}.\n @findex PTRMEM_CST_MEMBER\n @tindex VAR_DECL\n @tindex NEGATE_EXPR\n+@tindex ABS_EXPR\n @tindex BIT_NOT_EXPR\n @tindex TRUTH_NOT_EXPR\n @tindex ADDR_EXPR\n@@ -1915,6 +1916,20 @@ determined by looking at the type of the expression.\n The behavior of this operation on signed arithmetic overflow is\n controlled by the @code{flag_wrapv} and @code{flag_trapv} variables.\n \n+@item ABS_EXPR\n+These nodes represent the absolute value of the single operand, for\n+both integer and floating-point types.  This is typically used to\n+implement the @code{abs}, @code{labs} and @code{llabs} builtins for\n+integer types, and the @code{fabs}, @code{fabsf} and @code{fabsl}\n+builtins for floating point types.  The type of abs operation can\n+be determined by looking at the type of the expression.\n+\n+This node is not used for complex types.  To represent the modulus\n+or complex abs of a complex value, use the @code{BUILT_IN_CABS},\n+@code{BUILT_IN_CABSF} or @code{BUILT_IN_CABSL} builtins, as used\n+to implement the C99 @code{cabs}, @code{cabsf} and @code{cabsl}\n+built-in functions.\n+\n @item BIT_NOT_EXPR\n These nodes represent bitwise complement, and will always have integral\n type.  The only operand is the value to be complemented."}, {"sha": "f2c21c4d82d390a1e5df93427638e7a6ffffb5c0", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11017cc737b10f7eb7544ae55a340584d22fb9a8/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11017cc737b10f7eb7544ae55a340584d22fb9a8/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=11017cc737b10f7eb7544ae55a340584d22fb9a8", "patch": "@@ -8475,10 +8475,10 @@ expand_expr (tree exp, rtx target, enum machine_mode tmode, enum expand_modifier\n       if (modifier == EXPAND_STACK_PARM)\n \ttarget = 0;\n \n-      /* Handle complex values specially.  */\n+      /* ABS_EXPR is not valid for complex arguments.  */\n       if (GET_MODE_CLASS (mode) == MODE_COMPLEX_INT\n \t  || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n-\treturn expand_complex_abs (mode, op0, target, unsignedp);\n+\tabort ();\n \n       /* Unsigned abs is simply the operand.  Testing here means we don't\n \t risk generating incorrect code below.  */"}]}