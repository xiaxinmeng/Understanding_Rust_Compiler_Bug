{"sha": "1f3b1e1a0bb4549b57a060c36ceb49db0ddbfa41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYzYjFlMWEwYmI0NTQ5YjU3YTA2MGMzNmNlYjQ5ZGIwZGRiZmE0MQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-29T23:07:56Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-29T23:07:56Z"}, "message": "reload1.c (struct elim_table): Delete MAX_OFFSET member.\n\n\ufffd\n\t* reload1.c (struct elim_table): Delete MAX_OFFSET member.\n\t(update_eliminable_offsets): Don't compute it.\n\t(set_initial_elim_offsets): Don't initialize it.\n\tBreak out some code into set_initial_label_offsets so the rest of\n\tthis function can be called from reload_as_needed.\n\tAssume that INITIAL_FRAME_POINTER_OFFSET is defeined when\n\tELIMINABLE_REGS isn't.\n\t(set_initial_label_offsets): New function, broken out of\n\tset_initial_elim_offsets.\n\t(set_offsets_for_label): New function, broken out of set_label_offsets\n\tand reload_as_needed.\n\t(reload): Call the two new functions.\n\t(reload_as_needed): Call set_initial_elim_offsets instead of\n\tduplicating the code.  Likewise for set_offsets_for_label.\n\nFrom-SVN: r23442", "tree": {"sha": "57777d9ed3480e6091df243927234c2a0ce971b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57777d9ed3480e6091df243927234c2a0ce971b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f3b1e1a0bb4549b57a060c36ceb49db0ddbfa41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f3b1e1a0bb4549b57a060c36ceb49db0ddbfa41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f3b1e1a0bb4549b57a060c36ceb49db0ddbfa41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f3b1e1a0bb4549b57a060c36ceb49db0ddbfa41/comments", "author": null, "committer": null, "parents": [{"sha": "6467c05f009c4711c47cef786530b9fe66253997", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6467c05f009c4711c47cef786530b9fe66253997", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6467c05f009c4711c47cef786530b9fe66253997"}], "stats": {"total": 110, "additions": 42, "deletions": 68}, "files": [{"sha": "831436c10859f14521643dbd139f5c9e87cd436f", "filename": "gcc/reload1.c", "status": "modified", "additions": 42, "deletions": 68, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3b1e1a0bb4549b57a060c36ceb49db0ddbfa41/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3b1e1a0bb4549b57a060c36ceb49db0ddbfa41/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=1f3b1e1a0bb4549b57a060c36ceb49db0ddbfa41", "patch": "@@ -299,7 +299,6 @@ static struct elim_table\n   int can_eliminate_previous;\t/* Value of CAN_ELIMINATE in previous scan over\n \t\t\t\t   insns made by reload.  */\n   int offset;\t\t\t/* Current offset between the two regs.  */\n-  int max_offset;\t\t/* Maximum offset between the two regs.  */\n   int previous_offset;\t\t/* Offset at end of previous insn.  */\n   int ref_outside_mem;\t\t/* \"to\" has been referenced outside a MEM.  */\n   rtx from_rtx;\t\t\t/* REG rtx for the register to be eliminated.\n@@ -378,6 +377,8 @@ static void update_eliminable_offsets\tPROTO((void));\n static void mark_not_eliminable\t\tPROTO((rtx, rtx));\n static void set_initial_elim_offsets\tPROTO((void));\n static void verify_initial_elim_offsets\tPROTO((void));\n+static void set_initial_label_offsets\tPROTO((void));\n+static void set_offsets_for_label\tPROTO((rtx));\n static void init_elim_table\t\tPROTO((void));\n static void update_eliminables\t\tPROTO((HARD_REG_SET *));\n static void spill_hard_reg\t\tPROTO((int, FILE *, int));\n@@ -824,6 +825,7 @@ reload (first, global, dumpfile)\n       starting_frame_size = get_frame_size ();\n \n       set_initial_elim_offsets ();\n+      set_initial_label_offsets ();\n \n       /* For each pseudo register that has an equivalent location defined,\n \t try to eliminate any eliminable registers (such as the frame pointer)\n@@ -2449,19 +2451,7 @@ set_label_offsets (x, insn, initial_p)\n       else if (x == insn\n \t       && (tem = prev_nonnote_insn (insn)) != 0\n \t       && GET_CODE (tem) == BARRIER)\n-\t{\n-\t  num_not_at_initial_offset = 0;\n-\t  for (i = 0; i < NUM_ELIMINABLE_REGS; i++)\n-\t    {\n-\t      reg_eliminate[i].offset = reg_eliminate[i].previous_offset\n-\t\t= offsets_at[CODE_LABEL_NUMBER (x)][i];\n-\t      if (reg_eliminate[i].can_eliminate\n-\t\t  && (reg_eliminate[i].offset\n-\t\t      != reg_eliminate[i].initial_offset))\n-\t\tnum_not_at_initial_offset++;\n-\t    }\n-\t}\n-\n+\tset_offsets_for_label (insn);\n       else\n \t/* If neither of the above cases is true, compare each offset\n \t   with those previously recorded and suppress any eliminations\n@@ -3381,12 +3371,6 @@ update_eliminable_offsets ()\n       ep->previous_offset = ep->offset;\n       if (ep->can_eliminate && ep->offset != ep->initial_offset)\n \tnum_not_at_initial_offset++;\n-\n-#ifdef STACK_GROWS_DOWNWARD\n-      ep->max_offset = MAX (ep->max_offset, ep->offset);\n-#else\n-      ep->max_offset = MIN (ep->max_offset, ep->offset);\n-#endif\n     }\n }\n \n@@ -3462,43 +3446,59 @@ verify_initial_elim_offsets ()\n static void\n set_initial_elim_offsets ()\n {\n-  rtx x;\n+  struct elim_table *ep = reg_eliminate;\n \n #ifdef ELIMINABLE_REGS\n-  struct elim_table *ep;\n-\n-  for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n+  for (; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     {\n       INITIAL_ELIMINATION_OFFSET (ep->from, ep->to, ep->initial_offset);\n-      ep->previous_offset = ep->offset\n-\t= ep->max_offset = ep->initial_offset;\n+      ep->previous_offset = ep->offset = ep->initial_offset;\n     }\n #else\n-#ifdef INITIAL_FRAME_POINTER_OFFSET\n-  INITIAL_FRAME_POINTER_OFFSET (reg_eliminate[0].initial_offset);\n-#else\n-  if (!FRAME_POINTER_REQUIRED)\n-    abort ();\n-  reg_eliminate[0].initial_offset = 0;\n-#endif\n-  reg_eliminate[0].previous_offset = reg_eliminate[0].max_offset\n-    = reg_eliminate[0].offset = reg_eliminate[0].initial_offset;\n+  INITIAL_FRAME_POINTER_OFFSET (ep->initial_offset);\n+  ep->previous_offset = ep->offset = ep->initial_offset;\n #endif\n \n   num_not_at_initial_offset = 0;\n+}\n \n-  bzero ((char *) &offsets_known_at[get_first_label_num ()], num_labels);\n+/* Initialize the known label offsets.\n+   Set a known offset for each forced label to be at the initial offset\n+   of each elimination.  We do this because we assume that all\n+   computed jumps occur from a location where each elimination is\n+   at its initial offset.\n+   For all other labels, show that we don't know the offsets.  */\n \n-  /* Set a known offset for each forced label to be at the initial offset\n-     of each elimination.  We do this because we assume that all\n-     computed jumps occur from a location where each elimination is\n-     at its initial offset.  */\n+static void\n+set_initial_label_offsets ()\n+{\n+  rtx x;\n+  bzero ((char *) &offsets_known_at[get_first_label_num ()], num_labels);\n \n   for (x = forced_labels; x; x = XEXP (x, 1))\n     if (XEXP (x, 0))\n       set_label_offsets (XEXP (x, 0), NULL_RTX, 1);\n }\n \n+/* Set all elimination offsets to the known values for the code label given\n+   by INSN.  */\n+static void\n+set_offsets_for_label (insn)\n+     rtx insn;\n+{\n+  int i;\n+  int label_nr = CODE_LABEL_NUMBER (insn);\n+  struct elim_table *ep;\n+\n+  num_not_at_initial_offset = 0;\n+  for (i = 0, ep = reg_eliminate; i < NUM_ELIMINABLE_REGS; ep++, i++)\n+    {\n+      ep->offset = ep->previous_offset = offsets_at[label_nr][i];\n+      if (ep->can_eliminate && ep->offset != ep->initial_offset)\n+\tnum_not_at_initial_offset++;\n+    }\n+}\n+\n /* See if anything that happened changes which eliminations are valid.\n    For example, on the Sparc, whether or not the frame pointer can\n    be eliminated can depend on what registers have been used.  We need\n@@ -4056,22 +4056,7 @@ reload_as_needed (live_known)\n   reg_has_output_reload = (char *) alloca (max_regno);\n   CLEAR_HARD_REG_SET (reg_reloaded_valid);\n \n-  /* Reset all offsets on eliminable registers to their initial values.  */\n-#ifdef ELIMINABLE_REGS\n-  for (i = 0; i < (int) NUM_ELIMINABLE_REGS; i++)\n-    {\n-      INITIAL_ELIMINATION_OFFSET (reg_eliminate[i].from, reg_eliminate[i].to,\n-\t\t\t\t  reg_eliminate[i].initial_offset);\n-      reg_eliminate[i].previous_offset\n-\t= reg_eliminate[i].offset = reg_eliminate[i].initial_offset;\n-    }\n-#else\n-  INITIAL_FRAME_POINTER_OFFSET (reg_eliminate[0].initial_offset);\n-  reg_eliminate[0].previous_offset\n-    = reg_eliminate[0].offset = reg_eliminate[0].initial_offset;\n-#endif\n-\n-  num_not_at_initial_offset = 0;\n+  set_initial_elim_offsets ();\n \n   for (chain = reload_insn_chain; chain; chain = chain->next)\n     {\n@@ -4082,18 +4067,7 @@ reload_as_needed (live_known)\n       /* If we pass a label, copy the offsets from the label information\n \t into the current offsets of each elimination.  */\n       if (GET_CODE (insn) == CODE_LABEL)\n-\t{\n-\t  num_not_at_initial_offset = 0;\n-\t  for (i = 0; i < (int) NUM_ELIMINABLE_REGS; i++)\n-\t    {\n-\t      reg_eliminate[i].offset = reg_eliminate[i].previous_offset\n-\t\t= offsets_at[CODE_LABEL_NUMBER (insn)][i];\n-\t      if (reg_eliminate[i].can_eliminate\n-\t\t  && (reg_eliminate[i].offset\n-\t\t      != reg_eliminate[i].initial_offset))\n-\t\tnum_not_at_initial_offset++;\n-\t    }\n-\t}\n+\tset_offsets_for_label (insn);\n \n       else if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t{"}]}