{"sha": "c85ba4fb34b8dc43ac29ddb7009863b2cb03565d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg1YmE0ZmIzNGI4ZGM0M2FjMjlkZGI3MDA5ODYzYjJjYjAzNTY1ZA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2005-08-22T16:12:14Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2005-08-22T16:12:14Z"}, "message": "invoke.texi (Option Summary): Add ms1 options.\n\n\t* doc/invoke.texi (Option Summary): Add ms1 options.\n\t* doc/extend.texi: Document interrupt handler attribute for ms1.\n\t* doc/md.texi: Document ms1 constraints.\n\t* config.gcc: Add ms1-*-elf.\n\t* config/ms1/ms1.h: New.\n\t* config/ms1/ms1.c: New.\n\t* config/ms1/ms1.md: New.\n\t* config/ms1/ms1-protos.h: New.\n\t* config/ms1/ABI.txt: New.\n\t* config/ms1/crti.asm: New.\n\t* config/ms1/crtn.asm: New.\n\t* config/ms1/lib2extra-funcs.c: New.\n\t* config/ms1/t-ms1: New.\n\t* config/ms1/ms1.opt: New.\n\nFrom-SVN: r103342", "tree": {"sha": "6d47d5f01d0de0d62f368013d99fc58115723117", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d47d5f01d0de0d62f368013d99fc58115723117"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f1cc051537237722be3976b782bfd4336610ba55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1cc051537237722be3976b782bfd4336610ba55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1cc051537237722be3976b782bfd4336610ba55"}], "stats": {"total": 4820, "additions": 4819, "deletions": 1}, "files": [{"sha": "d98726f05b70e076b49bd0090d3992551cb28f65", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c85ba4fb34b8dc43ac29ddb7009863b2cb03565d", "patch": "@@ -1,3 +1,20 @@\n+2005-08-22  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* doc/invoke.texi (Option Summary): Add ms1 options.\n+\t* doc/extend.texi: Document interrupt handler attribute for ms1.\n+\t* doc/md.texi: Document ms1 constraints.\n+\t* config.gcc: Add ms1-*-elf.\n+\t* config/ms1/ms1.h: New.\n+\t* config/ms1/ms1.c: New.\n+\t* config/ms1/ms1.md: New.\n+\t* config/ms1/ms1-protos.h: New.\n+\t* config/ms1/ABI.txt: New.\n+\t* config/ms1/crti.asm: New.\n+\t* config/ms1/crtn.asm: New.\n+\t* config/ms1/lib2extra-funcs.c: New.\n+\t* config/ms1/t-ms1: New.\n+\t* config/ms1/ms1.opt: New.\n+\n 2005-08-22 Ira Rosen <irar@il.ibm.com>\n \n \t* config/rs6000/altivec.md (xorv4sf3): New."}, {"sha": "dde53d7a6cf32596bc3d2e6319b5f2f0d0714ccf", "filename": "gcc/config.gcc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=c85ba4fb34b8dc43ac29ddb7009863b2cb03565d", "patch": "@@ -1553,6 +1553,20 @@ mn10300-*-*)\n \tuse_collect2=no\n \tuse_fixproto=yes\n \t;;\n+ms1-*-elf)\n+        tm_file=\"dbxelf.h elfos.h svr4.h ${tm_file}\"\n+        tmake_file=\"${tmake_file} ms1/t-ms1\"\n+        ;;\n+ns32k-*-netbsdelf*)\n+\techo \"GCC does not yet support the ${target} target\"; exit 1\n+\t;;\n+ns32k-*-netbsd*)\n+\ttm_file=\"${tm_file} netbsd.h netbsd-aout.h ns32k/netbsd.h\"\n+\t# On NetBSD, the headers are already okay, except for math.h.\n+\ttmake_file=\"t-netbsd ns32k/t-ns32k\"\n+\textra_parts=\"\"\n+\tuse_collect2=yes\n+\t;;\n pdp11-*-bsd)\n \ttm_file=\"${tm_file} pdp11/2bsd.h\"\n \tuse_fixproto=yes"}, {"sha": "97dfbb80a866c154b492ed3b211dbbd3ce62fafe", "filename": "gcc/config/ms1/ABI.txt", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig%2Fms1%2FABI.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig%2Fms1%2FABI.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2FABI.txt?ref=c85ba4fb34b8dc43ac29ddb7009863b2cb03565d", "patch": "@@ -0,0 +1,219 @@\n+     Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+     Copying and distribution of this file, with or without modification,\n+     are permitted in any medium without royalty provided the copyright\n+     notice and this notice are preserved.\n+\n+--------------------------------------------------------------------------\n+\n+\t\t\tMS1 ABI\n+\t\t\t=========\n+\n+Sizes and alignments\n+--------------------\n+\n+\tType\t\tSize (bytes)\tAlignment (bytes)\n+\n+\tchar\t\t1\t\t1\n+\tshort\t\t2\t\t2\n+\tint\t\t4\t\t4\n+\tunsigned\t4\t\t4\n+\tlong\t\t4\t\t4 \n+\tlong long\t8\t\t8\n+\tfloat\t\t4\t\t4\n+\tdouble\t\t8\t\t8\n+\tpointers\t4\t\t4 \n+\n+* alignment within aggregates (structs and unions) is as above, with\n+  padding added if needed\n+* aggregates have alignment equal to that of their most aligned\n+  member\n+* aggregates have sizes which are a multiple of their alignment\n+\n+\n+Floating point\n+--------------\n+\n+All emulated using IEEE floating point conventions.\n+\n+Registers\n+----------------\n+\n+r0\t\talways zero\n+r1\t\targument register 1\n+r2\t\targument register 2\n+r3\t\targument register 3\n+r4\t\targument register 4\n+r5\t\tcallee must save\n+r6\t\tcallee must save\n+r7\t\tcall clobbers\n+r8\t\tcall clobbers\n+r9\t\tcall clobbers\n+r10\t\tcall clobbers\n+r11\t\tfunction return value\n+r12\t\tframe pointer\n+r13\t\tstack pointer\n+r14\t\tlinkage pointer\n+r15\t\tinterrupt pointer\n+\n+Stack alignment\t\t8 bytes\n+\n+Structures passed\t<= 32 bits as values, else as pointers\n+\n+The MS1 Stack\n+---------------\n+\n+Space is allocated as needed in the stack frame for the following at compile\n+time:\n+\n+* Outgoing parameters beyond the fourth\n+\n+* All automatic arrays, automatic data aggregates, automatic\n+  scalars which must be addressable, and automatic scalars for\n+  which there is no room in registers \n+\n+* Compiler-generated temporary values (typically when there are\n+  too many for the compiler to keep them all in registers) \n+\n+Space can be allocated dynamically (at runtime) in the stack frame for the\n+following:\n+\n+* Memory allocated using the alloca() function of the C library\n+\n+Addressable automatic variables on the stack are addressed with positive\n+offsets relative to r12; dynamically allocated space is addressed with positive\n+offsets from the pointer returned by alloca().\n+\n+Stack Frame\n+-----------\n+\n+        +-----------------------+\n+\t|    Parameter Word 1\t|\n+        +-----------------------+ <-sp\n+\t|    Previous FP\t|\n+\t+-----------------------+\n+ \t|    Return address\t|\n+\t+-----------------------+\n+\t|    Saved Registers\t|\n+\t+-----------------------+\n+\t|        ...\t\t|\n+\t+-----------------------+\n+\t|    Local Variables\t|\n+\t+-----------------------+ <-fp\n+\t|    Alloca\t\t|\n+\t+-----------------------+\n+\t|        ...\t\t|\n+\t+-----------------------+\n+\t|   Parameter Word 2\t|\n+\t+-----------------------+\n+\t|   Parameter Word 1\t|\n+\t+-----------------------+ <-sp\n+\n+\n+Parameter Assignment to Registers\n+---------------------------------\n+\n+Consider the parameters in a function call as ordered from left (first\n+parameter) to right.  GR contains the number of the next available\n+general-purpose register.  STARG is the address of the next available stack\n+parameter word.\n+\n+INITIALIZE:\n+\tSet GR=r1 and STARG to point to parameter word 1.\n+\n+SCAN:\n+\tIf there are no more parameters, terminate.\n+\tOtherwise, select one of the following depending on the type\n+\tof the next parameter:\n+\n+    SIMPLE ARG:\n+\n+\tA SIMPLE ARG is one of the following:\n+\n+\t* One of the simple integer types which will fit into a\n+\t  general-purpose register,\n+\t* A pointer to an object of any type,\n+\t* A struct or union small enough to fit in a register (<= 32 bits)\n+\t* A larger struct or union, which shall be treated as a\n+\t  pointer to the object or to a copy of the object.\n+\t  (See below for when copies are made.)\n+\n+\tIf GR > r4, go to STACK.  Otherwise, load the parameter value into\n+\tgeneral-purpose register GR and advance GR to the next general-purpose\n+\tregister.  Values shorter than the register size are sign-extended or\n+\tzero-extended depending on whether they are signed or unsigned.  Then\n+\tgo to SCAN.\n+\n+    DOUBLE or LONG LONG\n+\n+\tIf GR > r3, go to STACK.  Otherwise, if GR is odd, advance GR to the\n+\tnext register.  Load the 64-bit long long or double value into register\n+\tpair GR and GR+1.  Advance GR to GR+2 and go to SCAN.\n+\n+    STACK:\n+\n+\tParameters not otherwise handled above are passed in the parameter\n+\twords of the caller's stack frame.  SIMPLE ARGs, as defined above, are\n+\tconsidered to have size and alignment equal to the size of a\n+\tgeneral-purpose register, with simple argument types shorter than this\n+\tsign- or zero-extended to this width.  Round STARG up to a multiple of\n+\tthe alignment requirement of the parameter and copy the argument\n+\tbyte-for-byte into STARG, STARG+1, ...  STARG+size-1.  Set STARG to\n+\tSTARG+size and go to SCAN.\n+\n+\n+Structure passing\n+-----------------\n+\n+As noted above, code which passes structures and unions by value is implemented\n+specially.  (In this section, \"struct\" will refer to structs and unions\n+inclusively.)  Structs small enough to fit in a register are passed by value in\n+a single register or in a stack frame slot the size of a register.  Structs\n+containing a single double or long long component are passed by value in two\n+registers or in a stack frame slot the size of two registers.  Other structs\n+are handled by passing the address of the structure.  In this case, a copy of\n+the structure will be made if necessary in order to preserve the pass-by-value\n+semantics.\n+\n+Copies of large structs are made under the following rules:\n+\n+\t\t\tANSI mode\t\t\tK&R Mode\n+\t\t\t---------\t\t\t--------\n+Normal param\t \tCallee copies if needed\t\tCaller copies\n+Varargs (...) param\tCaller copies\t\t\tCaller copies\n+\n+In the case of normal (non-varargs) large-struct parameters in ANSI mode, the\n+callee is responsible for producing the same effect as if a copy of the\n+structure were passed, preserving the pass-by-value semantics.  This may be\n+accomplished by having the callee make a copy, but in some cases the callee may\n+be able to determine that a copy is not necessary in order to produce the same\n+results.  In such cases, the callee may choose to avoid making a copy of the\n+parameter.\n+\n+\n+Varargs handling\n+----------------\n+\n+No special changes are needed for handling varargs parameters other than the\n+caller knowing that a copy is needed on struct parameters larger than a\n+register (see above).\n+\n+The varargs macros set up a register save area for the general-purpose\n+registers to be saved.  Because the save area lies between the caller and\n+callee stack frames, the saved register parameters are contiguous with\n+parameters passed on the stack.  A pointer advances from the register save area\n+into the caller's stack frame.\n+\n+\n+Function return values\n+----------------------\n+\n+\tType\t\tRegister\n+\t----\t\t--------\n+\tint\t\tr11\n+\tshort\t\tr11\n+\tlong\t\tr11\n+\tlong long\tstack\n+\tfloat\t\tr11\n+\tdouble\t\tstack\n+"}, {"sha": "115b96e7cb8f7719d7fbe3994682bdfe4f8918fe", "filename": "gcc/config/ms1/crti.asm", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig%2Fms1%2Fcrti.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig%2Fms1%2Fcrti.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fcrti.asm?ref=c85ba4fb34b8dc43ac29ddb7009863b2cb03565d", "patch": "@@ -0,0 +1,71 @@\n+# crti.asm for ms1\n+#\n+#   Copyright (C) 2005 Free Software Foundation, Inc.\n+# \n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 2, or (at your option) any\n+# later version.\n+# \n+# In addition to the permissions in the GNU General Public License, the\n+# Free Software Foundation gives you unlimited permission to link the\n+# compiled version of this file with other programs, and to distribute\n+# those programs without any restriction coming from the use of this\n+# file.  (The General Public License restrictions do apply in other\n+# respects; for example, they cover modification of the file, and\n+# distribution when not linked into another program.)\n+# \n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING.  If not, write to the Free\n+# Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+# 02110-1301, USA.\n+# \n+#    As a special exception, if you link this library with files\n+#    compiled with GCC to produce an executable, this does not cause\n+#    the resulting executable to be covered by the GNU General Public License.\n+#    This exception does not however invalidate any other reasons why\n+#    the executable file might be covered by the GNU General Public License.\n+# \n+\n+# This file just make a stack frame for the contents of the .fini and\n+# .init sections.  Users may put any desired instructions in those\n+# sections.\n+\n+\t.file\t\t\"crti.asm\"\n+\n+\t.section\t\".init\"\n+\t.global\t_init\n+\t.type\t_init,#function\n+\t.align\t4\n+_init:\n+\tsubi\tsp, sp, #4\n+\tstw\tr14, sp, #0\n+\tor\tr0, r0, r0\n+\tor\tr0, r0, r0\n+\tor\tr0, r0, r0\n+\tor\tr0, r0, r0\n+\tor\tr0, r0, r0\n+\tor\tr0, r0, r0\n+\tor\tr0, r0, r0\n+\tor\tr0, r0, r0\n+\n+\t.section\t\".fini\"\n+\t.global\t_fini\n+\t.type\t_fini,#function\n+\t.align\t4\n+_fini:\n+\tsubi\tsp, sp, #4\n+\tstw\tr14, sp, #0\n+\tor\tr0, r0, r0\n+\tor\tr0, r0, r0\n+\tor\tr0, r0, r0\n+\tor\tr0, r0, r0\n+\tor\tr0, r0, r0\n+\tor\tr0, r0, r0\n+\tor\tr0, r0, r0\n+\tor\tr0, r0, r0"}, {"sha": "1fa42ac56a4112d37cb71d7bfb5ffdc9eed803c6", "filename": "gcc/config/ms1/crtn.asm", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig%2Fms1%2Fcrtn.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig%2Fms1%2Fcrtn.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fcrtn.asm?ref=c85ba4fb34b8dc43ac29ddb7009863b2cb03565d", "patch": "@@ -0,0 +1,54 @@\n+# crtn.asm for ms1\n+\n+#   Copyright (C) 2005 Free Software Foundation, Inc.\n+# \n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 2, or (at your option) any\n+# later version.\n+# \n+# In addition to the permissions in the GNU General Public License, the\n+# Free Software Foundation gives you unlimited permission to link the\n+# compiled version of this file with other programs, and to distribute\n+# those programs without any restriction coming from the use of this\n+# file.  (The General Public License restrictions do apply in other\n+# respects; for example, they cover modification of the file, and\n+# distribution when not linked into another program.)\n+# \n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING.  If not, write to the Free\n+# Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+# 02110-1301, USA.\n+# \n+#    As a special exception, if you link this library with files\n+#    compiled with GCC to produce an executable, this does not cause\n+#    the resulting executable to be covered by the GNU General Public License.\n+#    This exception does not however invalidate any other reasons why\n+#    the executable file might be covered by the GNU General Public License.\n+# \n+\n+# This file just makes sure that the .fini and .init sections do in\n+# fact return.  Users may put any desired instructions in those sections.\n+# This file is the last thing linked into any executable.\n+\n+\t.file\t\t\"crtn.asm\"\n+\n+\t.section\t\".init\"\n+\t.align\t\t4\n+\tldw\tr14, sp, #0\n+\taddi\tsp, sp, #4\n+\tjal\tr0, r14\n+\tor\tr0, r0, r0\n+\t\n+\t.section\t\".fini\"\n+\t.align\t\t4\n+\n+\tldw\tr14, sp, #0\n+\taddi\tsp, sp, #4\n+\tjal\tr0, r14\n+\tor\tr0, r0, r0"}, {"sha": "6f5ec6a619ca29134914bf58960e7998161a7f75", "filename": "gcc/config/ms1/lib2extra-funcs.c", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig%2Fms1%2Flib2extra-funcs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig%2Fms1%2Flib2extra-funcs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Flib2extra-funcs.c?ref=c85ba4fb34b8dc43ac29ddb7009863b2cb03565d", "patch": "@@ -0,0 +1,232 @@\n+/* Copyright (C) 2005 Free Software Foundation,\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#define BITS_PER_UNIT\t8\n+\n+typedef \t int HItype\t\t__attribute__ ((mode (HI)));\n+typedef unsigned int UHItype\t\t__attribute__ ((mode (HI)));\n+\n+typedef\t\t int SItype\t\t__attribute__ ((mode (SI)));\n+typedef unsigned int USItype\t\t__attribute__ ((mode (SI)));\n+\n+typedef int word_type\t\t\t__attribute__ ((mode (__word__)));\n+\n+struct SIstruct {HItype low, high;};\n+\n+typedef union\n+{\n+  struct SIstruct s;\n+  SItype ll;\n+} SIunion;\n+\n+SItype\n+__lshrsi3 (SItype u, word_type b)\n+{\n+  SIunion w;\n+  word_type bm;\n+  SIunion uu;\n+\n+  if (b == 0)\n+    return u;\n+\n+  uu.ll = u;\n+\n+  bm = (sizeof (HItype) * BITS_PER_UNIT) - b;\n+  if (bm <= 0)\n+    {\n+      w.s.high = 0;\n+      w.s.low = (UHItype)uu.s.high >> -bm;\n+    }\n+  else\n+    {\n+      UHItype carries = (UHItype)uu.s.high << bm;\n+      w.s.high = (UHItype)uu.s.high >> b;\n+      w.s.low = ((UHItype)uu.s.low >> b) | carries;\n+    }\n+\n+  return w.ll;\n+}\n+\n+SItype\n+__ashlsi3 (SItype u, word_type b)\n+{\n+  SIunion w;\n+  word_type bm;\n+  SIunion uu;\n+\n+  if (b == 0)\n+    return u;\n+\n+  uu.ll = u;\n+\n+  bm = (sizeof (HItype) * BITS_PER_UNIT) - b;\n+  if (bm <= 0)\n+    {\n+      w.s.low = 0;\n+      w.s.high = (UHItype)uu.s.low << -bm;\n+    }\n+  else\n+    {\n+      UHItype carries = (UHItype)uu.s.low >> bm;\n+      w.s.low = (UHItype)uu.s.low << b;\n+      w.s.high = ((UHItype)uu.s.high << b) | carries;\n+    }\n+\n+  return w.ll;\n+}\n+\n+SItype\n+__ashrsi3 (SItype u, word_type b)\n+{\n+  SIunion w;\n+  word_type bm;\n+  SIunion uu;\n+\n+  if (b == 0)\n+    return u;\n+\n+  uu.ll = u;\n+\n+  bm = (sizeof (HItype) * BITS_PER_UNIT) - b;\n+  if (bm <= 0)\n+    {\n+      /* w.s.high = 1..1 or 0..0 */\n+      w.s.high = uu.s.high >> (sizeof (HItype) * BITS_PER_UNIT - 1);\n+      w.s.low = uu.s.high >> -bm;\n+    }\n+  else\n+    {\n+      UHItype carries = (UHItype)uu.s.high << bm;\n+      w.s.high = uu.s.high >> b;\n+      w.s.low = ((UHItype)uu.s.low >> b) | carries;\n+    }\n+\n+  return w.ll;\n+}\n+\n+USItype\n+__mulsi3 (USItype a, USItype b)\n+{\n+  USItype c = 0;\n+\n+  while (a != 0)\n+    {\n+      if (a & 1)\n+\tc += b;\n+      a >>= 1;\n+      b <<= 1;\n+    }\n+\n+  return c;\n+}\n+\n+USItype\n+udivmodsi4(USItype num, USItype den, word_type modwanted)\n+{\n+  USItype bit = 1;\n+  USItype res = 0;\n+\n+  while (den < num && bit && !(den & (1L<<31)))\n+    {\n+      den <<=1;\n+      bit <<=1;\n+    }\n+  while (bit)\n+    {\n+      if (num >= den)\n+\t{\n+\t  num -= den;\n+\t  res |= bit;\n+\t}\n+      bit >>=1;\n+      den >>=1;\n+    }\n+  if (modwanted) return num;\n+  return res;\n+}\n+\n+SItype\n+__divsi3 (SItype a, SItype b)\n+{\n+  word_type neg = 0;\n+  SItype res;\n+\n+  if (a < 0)\n+    {\n+      a = -a;\n+      neg = !neg;\n+    }\n+\n+  if (b < 0)\n+    {\n+      b = -b;\n+      neg = !neg;\n+    }\n+\n+  res = udivmodsi4 (a, b, 0);\n+\n+  if (neg)\n+    res = -res;\n+\n+  return res;\n+}\n+\n+SItype\n+__modsi3 (SItype a, SItype b)\n+{\n+  word_type neg = 0;\n+  SItype res;\n+\n+  if (a < 0)\n+    {\n+      a = -a;\n+      neg = 1;\n+    }\n+\n+  if (b < 0)\n+    b = -b;\n+\n+  res = udivmodsi4 (a, b, 1);\n+\n+  if (neg)\n+    res = -res;\n+\n+  return res;\n+}\n+\n+SItype\n+__udivsi3 (SItype a, SItype b)\n+{\n+  return udivmodsi4 (a, b, 0);\n+}\n+\n+SItype\n+__umodsi3 (SItype a, SItype b)\n+{\n+  return udivmodsi4 (a, b, 1);\n+}"}, {"sha": "412b42d2ac24786c49bbfd68b8e0e8d2fabb26a5", "filename": "gcc/config/ms1/ms1-protos.h", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig%2Fms1%2Fms1-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig%2Fms1%2Fms1-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fms1-protos.h?ref=c85ba4fb34b8dc43ac29ddb7009863b2cb03565d", "patch": "@@ -0,0 +1,65 @@\n+/* Prototypes for exported functions defined in ms1.c\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful,but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+extern void         ms1_init_expanders\t (void);\n+extern void         ms1_expand_prologue\t (void);\n+extern void         ms1_expand_epilogue\t (enum epilogue_type);\n+extern unsigned     ms1_compute_frame_size (int);\n+extern void\t    ms1_override_options (void);\n+extern int\t    ms1_initial_elimination_offset (int, int);\n+extern const char * ms1_asm_output_opcode (FILE *, const char *);\n+extern int          ms1_epilogue_uses\t (int);\n+\n+#ifdef TREE_CODE\n+extern const char * ms1_cannot_inline_p\t (tree);\n+extern int          ms1_function_arg_boundary (enum machine_mode, tree);\n+extern void         ms1_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode, tree,  int);\n+#endif\n+\n+#ifdef RTX_CODE\n+extern void\t    ms1_expand_eh_return (rtx *);\n+extern void\t    ms1_emit_eh_epilogue (rtx *);\n+extern void         ms1_print_operand\t (FILE *, rtx, int);\n+extern void         ms1_print_operand_address (FILE *, rtx);\n+extern int          ms1_check_split\t (rtx, enum machine_mode);\n+extern int          ms1_reg_ok_for_base_p (rtx, int);\n+extern int          ms1_legitimate_address_p (enum machine_mode, rtx, int);\n+/* Predicates for machine description.  */\n+extern int          uns_arith_operand\t (rtx, enum machine_mode);\n+extern int          arith_operand\t (rtx, enum machine_mode);\n+extern int          reg_or_0_operand\t (rtx, enum machine_mode);\n+extern int\t    big_const_operand\t (rtx, enum machine_mode);\n+extern int\t    single_const_operand (rtx, enum machine_mode);\n+extern void\t    ms1_emit_cbranch\t (enum rtx_code, rtx, rtx, rtx);\n+extern void\t    ms1_set_memflags\t (rtx);\n+extern rtx\t    ms1_return_addr_rtx\t (int);\n+extern void\t    ms1_split_words\t (enum machine_mode, enum machine_mode, rtx *);\n+extern void\t    ms1_final_prescan_insn (rtx, rtx *, int);\n+#endif\n+\n+#ifdef TREE_CODE\n+#ifdef RTX_CODE\n+extern void         ms1_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);\n+extern rtx          ms1_function_arg\t (const CUMULATIVE_ARGS *, enum machine_mode, tree, int, int);\n+extern void\t    ms1_va_start\t (tree, rtx);\n+extern enum reg_class ms1_secondary_reload_class (enum reg_class, enum machine_mode, rtx);\n+extern rtx\t    ms1_function_value\t (tree, enum machine_mode, tree);\n+#endif\n+#endif"}, {"sha": "0257f7d31eb457824617ba3cd6bf531f6e6a2721", "filename": "gcc/config/ms1/ms1.c", "status": "added", "additions": 1652, "deletions": 0, "changes": 1652, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig%2Fms1%2Fms1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig%2Fms1%2Fms1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fms1.c?ref=c85ba4fb34b8dc43ac29ddb7009863b2cb03565d", "patch": "@@ -0,0 +1,1652 @@\n+/* Target definitions for the MorphoRISC1\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Red Hat, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-attr.h\"\n+#include \"recog.h\"\n+#include \"toplev.h\"\n+#include \"output.h\"\n+#include \"integrate.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+#include \"libfuncs.h\"\n+#include \"flags.h\"\n+#include \"tm_p.h\"\n+#include \"ggc.h\"\n+#include \"insn-flags.h\"\n+#include \"obstack.h\"\n+#include \"except.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n+\n+/* Frame pointer register mask.  */\n+#define FP_MASK\t\t \t (1 << (GPR_FP))\n+\n+/* Link register mask.  */\n+#define LINK_MASK\t \t (1 << (GPR_LINK))\n+\n+/* First GPR.  */\n+#define MS1_INT_ARG_FIRST 1\n+\n+/* Given a SIZE in bytes, advance to the next word.  */\n+#define ROUND_ADVANCE(SIZE) (((SIZE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* A C structure for machine-specific, per-function data.\n+   This is added to the cfun structure.  */\n+struct machine_function GTY(())\n+{\n+  /* Flags if __builtin_return_address (n) with n >= 1 was used.  */\n+  int ra_needs_full_frame;\n+  struct rtx_def * eh_stack_adjust;\n+  int interrupt_handler;\n+};\n+\n+/* Define the information needed to generate branch and scc insns.\n+   This is stored from the compare operation.  */\n+struct rtx_def * ms1_compare_op0;\n+struct rtx_def * ms1_compare_op1;\n+\n+/* Current frame information calculated by compute_frame_size.  */\n+struct ms1_frame_info current_frame_info;\n+\n+/* Zero structure to initialize current_frame_info.  */\n+struct ms1_frame_info zero_frame_info;\n+\n+/* ms1 doesn't have unsigned compares need a library call for this.  */\n+struct rtx_def * ms1_ucmpsi3_libcall;\n+\n+\f\n+static rtx\n+ms1_struct_value_rtx (tree fndecl ATTRIBUTE_UNUSED,\n+\t\t\t int incoming ATTRIBUTE_UNUSED)\n+{\n+  return gen_rtx_REG (Pmode, RETVAL_REGNUM);\n+}\n+\n+/* Implement RETURN_ADDR_RTX.  */\n+rtx\n+ms1_return_addr_rtx (int count)\n+{\n+  if (count != 0)\n+    return NULL_RTX;\n+\n+  return get_hard_reg_initial_val (Pmode, GPR_LINK);\n+}\n+\n+/* The following variable value indicates the number of nops required\n+   between the current instruction and the next instruction to avoid\n+   any pipeline hazards.  */\n+static int ms1_nops_required = 0;\n+static const char * ms1_nop_reasons = \"\";\n+\n+/* Implement ASM_OUTPUT_OPCODE.  */\n+const char *\n+ms1_asm_output_opcode (FILE *f ATTRIBUTE_UNUSED, const char *ptr)\n+{\n+  if (ms1_nops_required)\n+    fprintf (f, \";# need %d nops because of %s\\n\\t\",\n+\t     ms1_nops_required, ms1_nop_reasons);\n+  \n+  while (ms1_nops_required)\n+    {\n+      fprintf (f, \"or r0, r0, r0\\n\\t\");\n+      -- ms1_nops_required;\n+    }\n+  \n+  return ptr;\n+}\n+\n+/* Return TRUE if INSN is a memory load.  */\n+static bool\n+ms1_memory_load (rtx insn)\n+{\n+  return ((GET_CODE (insn) == SET) && (GET_CODE (XEXP (insn,1)) == MEM));\n+}\n+\n+/* Given an insn, return whether it's a memory operation or a branch\n+   operation, otherwise return TYPE_ARITH.  */\n+static enum attr_type\n+ms1_get_attr_type (rtx complete_insn)\n+{\n+  rtx insn = PATTERN (complete_insn);\n+\n+  if ((GET_CODE (insn) == SET)\n+      && ((GET_CODE (XEXP (insn, 0)) == MEM)\n+\t  || (GET_CODE (XEXP (insn, 1)) == MEM)))\n+    return TYPE_MEM;\n+\n+  else if (((GET_CODE (insn) == SET) && (XEXP (insn, 0) == pc_rtx))\n+\t   || (GET_CODE (complete_insn) == JUMP_INSN)\n+\t   || (GET_CODE (complete_insn) == CALL_INSN))\n+    return TYPE_BRANCH;\n+\n+  else\n+    return TYPE_ARITH;\n+}\n+\n+/* A helper routine for insn_dependent_p called through note_stores.  */\n+\n+static void\n+insn_dependent_p_1 (rtx x, rtx pat ATTRIBUTE_UNUSED, void *data)\n+{\n+  rtx * pinsn = (rtx *) data;\n+\n+  if (*pinsn && reg_mentioned_p (x, *pinsn))\n+    *pinsn = NULL_RTX;\n+}\n+\n+/* Return true if anything in insn X is (anti,output,true)\n+   dependent on anything in insn Y.  */\n+\n+static bool\n+insn_dependent_p (rtx x, rtx y)\n+{\n+  rtx tmp;\n+\n+  if (! INSN_P (x) || ! INSN_P (y))\n+    return 0;\n+\n+  tmp = PATTERN (y);\n+  note_stores (PATTERN (x), insn_dependent_p_1, &tmp);\n+  if (tmp == NULL_RTX)\n+    return true;\n+\n+  tmp = PATTERN (x);\n+  note_stores (PATTERN (y), insn_dependent_p_1, &tmp);\n+  return (tmp == NULL_RTX);\n+}\n+\n+\n+/* Return true if anything in insn X is true dependent on anything in\n+   insn Y.  */\n+static bool\n+insn_true_dependent_p (rtx x, rtx y)\n+{\n+  rtx tmp;\n+\n+  if (! INSN_P (x) || ! INSN_P (y))\n+    return 0;\n+\n+  tmp = PATTERN (y);\n+  note_stores (PATTERN (x), insn_dependent_p_1, &tmp);\n+  return (tmp == NULL_RTX);\n+}\n+\n+/* The following determines the number of nops that need to be\n+   inserted between the previous instructions and current instruction\n+   to avoid pipeline hazards on the ms1 processor.  Remember that\n+   the function is not called for asm insns.  */\n+\n+void\n+ms1_final_prescan_insn (rtx   insn,\n+\t\t\trtx * opvec ATTRIBUTE_UNUSED,\n+\t\t\tint   noperands ATTRIBUTE_UNUSED)\n+{\n+  rtx prev_i;\n+\n+  ms1_nops_required = 0;\n+  ms1_nop_reasons = \"\";\n+\n+  /* Only worry about real instructions.  */\n+  if (! INSN_P (insn))\n+    return;\n+\n+  /* Find the previous real instructions.  */\n+  prev_i = PREV_INSN (insn);\n+  while (prev_i != NULL\n+\t && (! INSN_P (prev_i)\n+\t     || GET_CODE (PATTERN (prev_i)) == USE\n+\t     || GET_CODE (PATTERN (prev_i)) == CLOBBER))\n+    prev_i = PREV_INSN (prev_i);\n+\n+  /* If there isn't one then there is nothing that we need do.  */\n+  if (prev_i == NULL || ! INSN_P (prev_i))\n+    return;\n+\n+  /* Delayed branch slots already taken care of by delay branch scheduling.  */\n+  if (ms1_get_attr_type (prev_i) == TYPE_BRANCH)\n+    return;\n+\n+  switch (ms1_get_attr_type (insn))\n+    {\n+    case TYPE_MEM:\n+      /* Avoid consecutive memory operation.  */\n+      if  (ms1_get_attr_type (prev_i) == TYPE_MEM\n+\t   && ms1_cpu == PROCESSOR_MS1_64_001)\n+\t{\n+\t  ms1_nops_required = 1;\n+\t  ms1_nop_reasons = \"consecutive mem ops\";\n+\t}\n+      /* Drop through.  */\n+\n+    case TYPE_ARITH:\n+    case TYPE_COMPLEX:\n+      /* One cycle of delay is required between load\n+\t and the dependent arithmetic instruction.  */\n+      if (ms1_memory_load (PATTERN (prev_i))\n+\t  && insn_true_dependent_p (prev_i, insn))\n+\t{\n+\t  ms1_nops_required = 1;\n+\t  ms1_nop_reasons = \"load->arith dependency delay\";\n+\t}\n+      break;\n+\n+    case TYPE_BRANCH:\n+      if (insn_dependent_p (prev_i, insn))\n+\t{\n+\t  if (ms1_get_attr_type (prev_i) == TYPE_ARITH\n+\t      && ms1_cpu == PROCESSOR_MS1_64_001)\n+\t    {\n+\t      /* One cycle of delay between arith\n+\t\t instructions and branch dependent on arith.  */\n+\t      ms1_nops_required = 1;\n+\t      ms1_nop_reasons = \"arith->branch dependency delay\";\n+\t    }\n+\t  else if (ms1_memory_load (PATTERN (prev_i)))\n+\t    {\n+\t      /* Two cycles of delay are required\n+\t\t between load and dependent branch.  */\n+\t      if (ms1_cpu == PROCESSOR_MS1_64_001)\n+\t\tms1_nops_required = 2;\n+\t      else\n+\t\tms1_nops_required = 1;\n+\t      ms1_nop_reasons = \"load->branch dependency delay\";\n+\t    }\n+\t}\n+      break;\n+\n+    default:\n+      fatal_insn (\"ms1_final_prescan_insn, invalid insn #1\", insn);\n+      break;\n+    }\n+}\n+\n+/* Print debugging information for a frame.  */\n+static void\n+ms1_debug_stack (struct ms1_frame_info * info)\n+{\n+  int regno;\n+\n+  if (!info)\n+    {\n+      error (\"info pointer NULL\");\n+      gcc_unreachable ();\n+    }\n+\n+  fprintf (stderr, \"\\nStack information for function %s:\\n\",\n+\t   ((current_function_decl && DECL_NAME (current_function_decl))\n+\t    ? IDENTIFIER_POINTER (DECL_NAME (current_function_decl))\n+\t    : \"<unknown>\"));\n+\n+  fprintf (stderr, \"\\ttotal_size       = %d\\n\", info->total_size);\n+  fprintf (stderr, \"\\tpretend_size     = %d\\n\", info->pretend_size);\n+  fprintf (stderr, \"\\targs_size        = %d\\n\", info->args_size);\n+  fprintf (stderr, \"\\textra_size       = %d\\n\", info->extra_size);\n+  fprintf (stderr, \"\\treg_size         = %d\\n\", info->reg_size);\n+  fprintf (stderr, \"\\tvar_size         = %d\\n\", info->var_size);\n+  fprintf (stderr, \"\\tframe_size       = %d\\n\", info->frame_size);\n+  fprintf (stderr, \"\\treg_mask         = 0x%x\\n\", info->reg_mask);\n+  fprintf (stderr, \"\\tsave_fp          = %d\\n\", info->save_fp);\n+  fprintf (stderr, \"\\tsave_lr          = %d\\n\", info->save_lr);\n+  fprintf (stderr, \"\\tinitialized      = %d\\n\", info->initialized);\n+  fprintf (stderr, \"\\tsaved registers =\");\n+\n+  /* Print out reg_mask in a more readable format.  */\n+  for (regno = GPR_R0; regno <= GPR_LAST; regno++)\n+    if ( (1 << regno) & info->reg_mask)\n+      fprintf (stderr, \" %s\", reg_names[regno]);\n+\n+  putc ('\\n', stderr);\n+  fflush (stderr);\n+}\n+\n+/* Print a memory address as an operand to reference that memory location.  */\n+\n+static void\n+ms1_print_operand_simple_address (FILE * file, rtx addr)\n+{\n+  if (!addr)\n+    error (\"PRINT_OPERAND_ADDRESS, null pointer\");\n+\n+  else\n+    switch (GET_CODE (addr))\n+      {\n+      case REG:\n+\tfprintf (file, \"%s, #0\", reg_names [REGNO (addr)]);\n+\tbreak;\n+\t\n+      case PLUS:\n+\t{\n+\t  rtx reg = 0;\n+\t  rtx offset = 0;\n+\t  rtx arg0 = XEXP (addr, 0);\n+\t  rtx arg1 = XEXP (addr, 1);\n+\n+\t  if (GET_CODE (arg0) == REG)\n+\t    {\n+\t      reg = arg0;\n+\t      offset = arg1;\n+\t      if (GET_CODE (offset) == REG)\n+\t\tfatal_insn (\"PRINT_OPERAND_ADDRESS, 2 regs\", addr);\n+\t    }\n+\n+\t  else if (GET_CODE (arg1) == REG)\n+\t      reg = arg1, offset = arg0;\n+\t  else if (CONSTANT_P (arg0) && CONSTANT_P (arg1))\n+\t    {\n+\t      fprintf (file, \"%s, #\", reg_names [GPR_R0]);\n+\t      output_addr_const (file, addr);\n+\t      break;\n+\t    }\n+\t  fprintf (file, \"%s, #\", reg_names [REGNO (reg)]);\n+\t  output_addr_const (file, offset);\n+\t  break;\n+\t}\n+\n+      case LABEL_REF:\n+      case SYMBOL_REF:\n+      case CONST_INT:\n+      case CONST:\n+\toutput_addr_const (file, addr);\n+\tbreak;\n+\n+      default:\n+\tfatal_insn (\"PRINT_OPERAND_ADDRESS, invalid insn #1\", addr);\n+\tbreak;\n+      }\n+}\n+\n+/* Implement PRINT_OPERAND_ADDRESS.  */\n+void\n+ms1_print_operand_address (FILE * file, rtx addr)\n+{\n+  if (GET_CODE (addr) == AND\n+      && GET_CODE (XEXP (addr, 1)) == CONST_INT\n+      && INTVAL (XEXP (addr, 1)) == -3)\n+    ms1_print_operand_simple_address (file, XEXP (addr, 0));\n+  else\n+    ms1_print_operand_simple_address (file, addr);\n+}\n+\n+/* Implement PRINT_OPERAND.  */\n+void\n+ms1_print_operand (FILE * file, rtx x, int code)\n+{\n+  switch (code)\n+    {\n+    case '#':\n+      /* Output a nop if there's nothing for the delay slot.  */\n+      if (dbr_sequence_length () == 0)\n+\tfputs (\"\\n\\tor r0, r0, r0\", file);\n+      return;\n+      \n+    case 'H': \n+      fprintf(file, \"#%%hi16(\");\n+      output_addr_const (file, x);\n+      fprintf(file, \")\");\n+      return;\n+      \n+    case 'L': \n+      fprintf(file, \"#%%lo16(\");\n+      output_addr_const (file, x);\n+      fprintf(file, \")\");\n+      return;\n+\n+    case 'N': \n+      fprintf(file, \"#%ld\", ~INTVAL (x));\n+      return;\n+\n+    case 'z':\n+      if (GET_CODE (x) == CONST_INT && INTVAL (x) == 0)\n+\t{\n+\t  fputs (reg_names[GPR_R0], file);\n+\t  return;\n+\t}\n+\n+    case 0:\n+      /* Handled below.  */\n+      break;\n+\n+    default:\n+      /* output_operand_lossage (\"ms1_print_operand: unknown code\"); */\n+      fprintf (file, \"unknown code\");\n+      return;\n+    }\n+\n+  switch (GET_CODE (x))\n+    {\n+    case REG:\n+      fputs (reg_names [REGNO (x)], file);\n+      break;\n+\n+    case CONST:\n+    case CONST_INT:\n+      fprintf(file, \"#%ld\", INTVAL (x));\n+      break;\n+\n+    case MEM:\n+      ms1_print_operand_address(file, XEXP (x,0));\n+      break;\n+\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      output_addr_const (file, x);\n+      break;\n+      \n+    default:\n+      fprintf(file, \"Uknown code: %d\", GET_CODE (x));\n+      break;\n+    }\n+\n+  return;\n+}\n+\n+/* Implement INIT_CUMULATIVE_ARGS.  */\n+void\n+ms1_init_cumulative_args (CUMULATIVE_ARGS * cum, tree fntype, rtx libname,\n+\t\t\t     tree fndecl ATTRIBUTE_UNUSED, int incoming)\n+{\n+  *cum = 0;\n+\n+  if (TARGET_DEBUG_ARG)\n+    {\n+      fprintf (stderr, \"\\nms1_init_cumulative_args:\");\n+\n+      if (incoming)\n+\tfputs (\" incoming\", stderr);\n+\n+      if (fntype)\n+\t{\n+\t  tree ret_type = TREE_TYPE (fntype);\n+\t  fprintf (stderr, \" return = %s,\",\n+\t\t   tree_code_name[ (int)TREE_CODE (ret_type) ]);\n+\t}\n+\n+      if (libname && GET_CODE (libname) == SYMBOL_REF)\n+\tfprintf (stderr, \" libname = %s\", XSTR (libname, 0));\n+\n+      if (cfun->returns_struct)\n+\tfprintf (stderr, \" return-struct\");\n+\n+      putc ('\\n', stderr);\n+    }\n+}\n+\n+/* Compute the slot number to pass an argument in.\n+   Returns the slot number or -1 if passing on the stack.\n+\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).\n+   INCOMING_P is zero for FUNCTION_ARG, nonzero for FUNCTION_INCOMING_ARG.\n+   *PREGNO records the register number to use if scalar type.  */\n+\n+static int\n+ms1_function_arg_slotno (const CUMULATIVE_ARGS * cum,\n+\t\t\t    enum machine_mode mode,\n+\t\t\t    tree type,\n+\t\t\t    int named ATTRIBUTE_UNUSED,\n+\t\t\t    int incoming_p ATTRIBUTE_UNUSED,\n+\t\t\t    int * pregno)\n+{\n+  int regbase = MS1_INT_ARG_FIRST;\n+  int slotno  = * cum;\n+\n+  if (mode == VOIDmode || targetm.calls.must_pass_in_stack (mode, type))\n+    return -1;\n+\n+  if (slotno >= MS1_NUM_ARG_REGS)\n+    return -1;\n+\n+  * pregno = regbase + slotno;\n+\n+  return slotno;\n+}\n+\n+/* Implement FUNCTION_ARG.  */\n+rtx\n+ms1_function_arg (const CUMULATIVE_ARGS * cum,\n+\t\t  enum machine_mode mode,\n+\t\t  tree type,\n+\t\t  int named,\n+\t\t  int incoming_p)\n+{\n+  int slotno, regno;\n+  rtx reg;\n+\n+  slotno = ms1_function_arg_slotno (cum, mode, type, named, incoming_p, \n+\t\t\t\t       & regno);\n+\n+  if (slotno == -1)\n+    reg = NULL_RTX;\n+  else\n+    reg = gen_rtx_REG (mode, regno);\n+\n+  return reg;\n+}\n+\n+/* Implement FUNCTION_ARG_ADVANCE.  */\n+void\n+ms1_function_arg_advance (CUMULATIVE_ARGS * cum,\n+\t\t\t  enum machine_mode mode,\n+\t\t\t  tree type ATTRIBUTE_UNUSED,\n+\t\t\t  int named)\n+{\n+  int slotno, regno;\n+\n+  /* We pass 0 for incoming_p here, it doesn't matter.  */\n+  slotno = ms1_function_arg_slotno (cum, mode, type, named, 0, &regno);\n+\n+  * cum += (mode != BLKmode\n+\t    ? ROUND_ADVANCE (GET_MODE_SIZE (mode))\n+\t    : ROUND_ADVANCE (int_size_in_bytes (type)));\n+\n+  if (TARGET_DEBUG_ARG)\n+    fprintf (stderr,\n+\t     \"ms1_function_arg_advance: words = %2d, mode = %4s, named = %d, size = %3d\\n\",\n+\t     *cum, GET_MODE_NAME (mode), named, \n+\t     (*cum) * UNITS_PER_WORD);\n+}\n+\n+/* Implement hook TARGET_ARG_PARTIAL_BYTES.\n+\n+   Returns the number of bytes at the beginning of an argument that\n+   must be put in registers.  The value must be zero for arguments\n+   that are passed entirely in registers or that are entirely pushed\n+   on the stack.  */\n+static int\n+ms1_arg_partial_bytes (CUMULATIVE_ARGS * pcum,\n+\t\t       enum machine_mode mode,\n+\t\t       tree type,\n+\t\t       bool named ATTRIBUTE_UNUSED)\n+{\n+  int cum = * pcum;\n+  int words;\n+\n+  if (mode == BLKmode)\n+    words = ((int_size_in_bytes (type) + UNITS_PER_WORD - 1)\n+\t     / UNITS_PER_WORD);\n+  else\n+    words = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\n+  if (! targetm.calls.pass_by_reference (& cum, mode, type, named)\n+      && cum < MS1_NUM_ARG_REGS\n+      && (cum + words) > MS1_NUM_ARG_REGS)\n+    {\n+      int bytes = (MS1_NUM_ARG_REGS - cum) * UNITS_PER_WORD; \n+\n+      if (TARGET_DEBUG)\n+\tfprintf (stderr, \"function_arg_partial_nregs = %d\\n\", bytes);\n+      return bytes;\n+    }\n+\n+  return 0;\n+}\n+\n+\n+/* Implement TARGET_PASS_BY_REFERENCE hook.  */\n+static bool\n+ms1_pass_by_reference (CUMULATIVE_ARGS * cum ATTRIBUTE_UNUSED,\n+\t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t       tree type,\n+\t\t       bool named ATTRIBUTE_UNUSED)\n+{\n+  return (type && int_size_in_bytes (type) > 4 * UNITS_PER_WORD);\n+}\n+\n+/* Implement FUNCTION_ARG_BOUNDARY.  */\n+int\n+ms1_function_arg_boundary (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t   tree type ATTRIBUTE_UNUSED)\n+{\n+  return BITS_PER_WORD;\n+}\n+\n+/* Implement REG_OK_FOR_BASE_P.  */\n+int\n+ms1_reg_ok_for_base_p (rtx x, int strict)\n+{\n+  if (strict)\n+    return  (((unsigned) REGNO (x)) < FIRST_PSEUDO_REGISTER);\n+  return 1;\n+}\n+\n+/* Helper function of ms1_legitimate_address_p.  Return true if XINSN\n+   is a simple address, otherwise false.  */\n+static bool\n+ms1_legitimate_simple_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\t rtx xinsn,\n+\t\t\t\t int strict)\n+{\n+  if (TARGET_DEBUG)\t\t\t\t\t\t\n+    {\t\t\t\t\t\t\t\t\t\n+      fprintf (stderr, \"\\n========== GO_IF_LEGITIMATE_ADDRESS, %sstrict\\n\",\n+\t       strict ? \"\" : \"not \");\n+      debug_rtx (xinsn);\n+    }\n+\n+  if (GET_CODE (xinsn) == REG && ms1_reg_ok_for_base_p (xinsn, strict))\n+    return true;\n+\n+  if (GET_CODE (xinsn) == PLUS\n+      && GET_CODE (XEXP (xinsn, 0)) == REG\n+      && ms1_reg_ok_for_base_p (XEXP (xinsn, 0), strict)\n+      && GET_CODE (XEXP (xinsn, 1)) == CONST_INT\n+      && SMALL_INT (XEXP (xinsn, 1)))\n+    return true;\n+\n+  return false;\n+}\n+\n+\n+/* Helper function of GO_IF_LEGITIMATE_ADDRESS.  Return non-zero if\n+   XINSN is a legitimate address on MS1.  */\n+int\n+ms1_legitimate_address_p (enum machine_mode mode,\n+\t\t\t  rtx xinsn,\n+\t\t\t  int strict)\n+{\n+  if (ms1_legitimate_simple_address_p (mode, xinsn, strict))\n+    return 1;\n+\n+  if ((mode) == SImode\n+      && GET_CODE (xinsn) == AND\n+      && GET_CODE (XEXP (xinsn, 1)) == CONST_INT\n+      && INTVAL (XEXP (xinsn, 1)) == -3)\n+    return ms1_legitimate_simple_address_p (mode, XEXP (xinsn, 0), strict);\n+  else\n+    return 0;\n+}\n+\n+/* Return truth value of whether OP can be used as an operands where a\n+   register or 16 bit unsigned integer is needed.  */\n+\n+int\n+uns_arith_operand (rtx op, enum machine_mode mode)\n+{\n+  if (GET_CODE (op) == CONST_INT && SMALL_INT_UNSIGNED (op))\n+    return 1;\n+\n+  return register_operand (op, mode);\n+}\n+\n+/* Return truth value of whether OP can be used as an operands where a\n+   16 bit integer is needed.  */\n+\n+int\n+arith_operand (rtx op, enum machine_mode mode)\n+{\n+  if (GET_CODE (op) == CONST_INT && SMALL_INT (op))\n+    return 1;\n+\n+  return register_operand (op, mode);\n+}\n+\n+/* Return truth value of whether OP is a register or the constant 0.  */\n+\n+int\n+reg_or_0_operand (rtx op, enum machine_mode mode)\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case CONST_INT:\n+      return INTVAL (op) == 0;\n+\n+    case REG:\n+    case SUBREG:\n+      return register_operand (op, mode);\n+\n+    default:\n+      break;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return truth value of whether OP is a constant that requires two\n+   loads to put in a register.  */\n+\n+int\n+big_const_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_LETTER_P (INTVAL (op), 'M'))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Return truth value of whether OP is a constant that require only\n+   one load to put in a register.  */\n+\n+int\n+single_const_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  if (big_const_operand (op, mode)\n+      || GET_CODE (op) == CONST\n+      || GET_CODE (op) == LABEL_REF\n+      || GET_CODE (op) == SYMBOL_REF)\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* True if the current function is an interrupt handler\n+   (either via #pragma or an attribute specification).  */\n+int interrupt_handler;\n+enum processor_type ms1_cpu;\n+\n+static struct machine_function *\n+ms1_init_machine_status (void)\n+{\n+  struct machine_function *f;\n+\n+  f = ggc_alloc_cleared (sizeof (struct machine_function));\n+\n+  return f;\n+}\n+\n+/* Implement OVERRIDE_OPTIONS.  */\n+void\n+ms1_override_options (void)\n+{\n+  if (ms1_cpu_string != NULL)\n+    {\n+      if (!strcasecmp (ms1_cpu_string, \"MS1-64-001\"))\n+\tms1_cpu = PROCESSOR_MS1_64_001;\n+      else if (!strcasecmp (ms1_cpu_string, \"MS1-16-002\"))\n+\tms1_cpu = PROCESSOR_MS1_16_002;\n+      else if  (!strcasecmp (ms1_cpu_string, \"MS1-16-003\"))\n+\t{\n+\t  ms1_cpu = PROCESSOR_MS1_16_003;\n+\t  target_flags |= MASK_MUL;\n+\t}\n+      else\n+\terror (\"bad value (%s) for -march= switch\", ms1_cpu_string);\n+    }\n+  else\n+    ms1_cpu = PROCESSOR_MS1_64_001;\n+\n+  if (flag_exceptions)\n+    {\n+      flag_omit_frame_pointer = 0;\n+      flag_gcse = 0;\n+    }\n+\n+  init_machine_status = ms1_init_machine_status;\n+}\n+\n+/* Do what is necessary for `va_start'.  We look at the current function\n+   to determine if stdarg or varargs is used and return the address of the\n+   first unnamed parameter.  */\n+\n+static rtx\n+ms1_builtin_saveregs (void)\n+{\n+  int first_reg = 0;\n+  rtx address;\n+  int regno;\n+\n+  for (regno = first_reg; regno < MS1_NUM_ARG_REGS; regno ++)\n+    emit_move_insn (gen_rtx_MEM (word_mode,\n+\t\t\t\t gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t       gen_rtx_REG (SImode, ARG_POINTER_REGNUM),\n+\t\t\t\t\t       GEN_INT (UNITS_PER_WORD * regno))),\n+\t\t    gen_rtx_REG (word_mode,\n+\t\t\t\t MS1_INT_ARG_FIRST + regno));\n+\n+  address = gen_rtx_PLUS (Pmode,\n+\t\t\t  gen_rtx_REG (SImode, ARG_POINTER_REGNUM),\n+\t\t\t  GEN_INT (UNITS_PER_WORD * first_reg));\n+  return address;\n+}\n+\n+/* Implement `va_start'.  */\n+\n+void\n+ms1_va_start (tree valist, rtx nextarg)\n+{\n+  ms1_builtin_saveregs ();\n+  std_expand_builtin_va_start (valist, nextarg);\n+}\n+\n+/* Returns the number of bytes offset between the frame pointer and the stack\n+   pointer for the current function.  SIZE is the number of bytes of space\n+   needed for local variables.  */\n+\n+unsigned int\n+ms1_compute_frame_size (int size)\n+{\n+  int           regno;\n+  unsigned int  total_size;\n+  unsigned int  var_size;\n+  unsigned int  args_size;\n+  unsigned int  pretend_size;\n+  unsigned int  extra_size;\n+  unsigned int  reg_size;\n+  unsigned int  frame_size;\n+  unsigned int  reg_mask;\n+\n+  var_size      = size;\n+  args_size     = current_function_outgoing_args_size;\n+  pretend_size  = current_function_pretend_args_size;\n+  extra_size    = FIRST_PARM_OFFSET (0);\n+  total_size    = extra_size + pretend_size + args_size + var_size;\n+  reg_size      = 0;\n+  reg_mask\t= 0;\n+\n+  /* Calculate space needed for registers.  */\n+  for (regno = GPR_R0; regno <= GPR_LAST; regno++)\n+    {\n+      if (MUST_SAVE_REGISTER (regno))\n+        {\n+          reg_size += UNITS_PER_WORD;\n+          reg_mask |= 1 << regno;\n+        }\n+    }\n+\n+  current_frame_info.save_fp = (regs_ever_live [GPR_FP]\n+\t\t\t\t|| frame_pointer_needed\n+\t\t\t\t|| interrupt_handler);\n+  current_frame_info.save_lr = (regs_ever_live [GPR_LINK]\n+\t\t\t\t|| profile_flag\n+\t\t\t\t|| interrupt_handler);\n+ \n+  reg_size += (current_frame_info.save_fp + current_frame_info.save_lr)\n+               * UNITS_PER_WORD;\n+  total_size += reg_size;\n+  total_size = ((total_size + 3) & ~3);\n+\n+  frame_size = total_size;\n+\n+  /* Save computed information.  */\n+  current_frame_info.pretend_size = pretend_size;\n+  current_frame_info.var_size     = var_size;\n+  current_frame_info.args_size    = args_size;\n+  current_frame_info.reg_size     = reg_size;\n+  current_frame_info.frame_size   = args_size + var_size;\n+  current_frame_info.total_size   = total_size;\n+  current_frame_info.extra_size   = extra_size;\n+  current_frame_info.reg_mask     = reg_mask;\n+  current_frame_info.initialized  = reload_completed;\n+ \n+  return total_size;\n+}\n+\n+/* Emit code to save REG in stack offset pointed to by MEM.\n+   STACK_OFFSET is the offset from the SP where the save will happen.\n+   This function sets the REG_FRAME_RELATED_EXPR note accordingly.  */\n+static void\n+ms1_emit_save_restore (enum save_direction direction,\n+\t\t       rtx reg,\n+\t\t       rtx mem,\n+\t\t       int stack_offset)\n+{\n+  if (direction == FROM_PROCESSOR_TO_MEM)\n+    {\n+      rtx insn;\n+  \n+      insn = emit_move_insn (mem, reg);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      REG_NOTES (insn)\n+\t= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\t\t     gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t  gen_rtx_MEM\n+\t\t\t\t\t  (SImode,\n+\t\t\t\t\t   gen_rtx_PLUS (SImode,\n+\t\t\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t\t\t GEN_INT (stack_offset))),\n+\t\t\t\t\t  reg),\n+\t\t\t     REG_NOTES (insn));\n+    }\n+  else\n+    emit_move_insn (reg, mem);\n+}\n+\n+\n+/* Emit code to save the frame pointer in the prologue and restore\n+   frame pointer in epilogue.  */\n+\n+static void\n+ms1_emit_save_fp (enum save_direction direction,\n+\t\t  struct ms1_frame_info info)\n+{\n+  rtx base_reg;\n+  int reg_mask = info.reg_mask  & ~(FP_MASK | LINK_MASK);\n+  int offset = info.total_size;\n+  int stack_offset = info.total_size;\n+\n+  /* If there is nothing to save, get out now.  */\n+  if (! info.save_fp && ! info.save_lr && ! reg_mask)\n+    return;\n+\n+  /* If offset doesn't fit in a 15-bit signed integer,\n+     uses a scratch registers to get a smaller offset.  */\n+  if (CONST_OK_FOR_LETTER_P(offset, 'O'))\n+    base_reg = stack_pointer_rtx;\n+  else\n+    {\n+      /* Use the scratch register R9 that holds old stack pointer.  */\n+      base_reg = gen_rtx_REG (SImode, GPR_R9);\n+      offset = 0;\n+    }\n+\n+  if (info.save_fp)\n+    {\n+      offset -= UNITS_PER_WORD;\n+      stack_offset -= UNITS_PER_WORD;\n+      ms1_emit_save_restore (direction, gen_rtx_REG (SImode, GPR_FP),\n+\t     gen_rtx_MEM (SImode, \n+\t\t\t  gen_rtx_PLUS (SImode, base_reg, GEN_INT (offset))),\n+\t     stack_offset);\n+    }\n+}\n+\n+/* Emit code to save registers in the prologue and restore register\n+   in epilogue.  */\n+\n+static void\n+ms1_emit_save_regs (enum save_direction direction,\n+\t\t    struct ms1_frame_info info)\n+{\n+  rtx base_reg;\n+  int regno;\n+  int reg_mask = info.reg_mask  & ~(FP_MASK | LINK_MASK);\n+  int offset = info.total_size;\n+  int stack_offset = info.total_size;\n+\n+  /* If there is nothing to save, get out now.  */\n+  if (! info.save_fp && ! info.save_lr && ! reg_mask)\n+    return;\n+\n+  /* If offset doesn't fit in a 15-bit signed integer,\n+     uses a scratch registers to get a smaller offset.  */\n+  if (CONST_OK_FOR_LETTER_P(offset, 'O'))\n+    base_reg = stack_pointer_rtx;\n+  else\n+    {\n+      /* Use the scratch register R9 that holds old stack pointer.  */\n+      base_reg = gen_rtx_REG (SImode, GPR_R9);\n+      offset = 0;\n+    }\n+\n+  if (info.save_fp)\n+    {\n+      /* This just records the space for it, the actual move generated in\n+\t ms1_emit_save_fp ().  */\n+      offset -= UNITS_PER_WORD;\n+      stack_offset -= UNITS_PER_WORD;\n+    }\n+\n+  if (info.save_lr)\n+    {\n+      offset -= UNITS_PER_WORD;\n+      stack_offset -= UNITS_PER_WORD;\n+      ms1_emit_save_restore (direction, gen_rtx_REG (SImode, GPR_LINK), \n+\t\tgen_rtx_MEM (SImode,\n+\t\t\t     gen_rtx_PLUS (SImode, base_reg, GEN_INT (offset))),\n+\t\tstack_offset);\n+    }\n+\n+  /* Save any needed call-saved regs.  */\n+  for (regno = GPR_R0; regno <= GPR_LAST; regno++)\n+    {\n+      if ((reg_mask & (1 << regno)) != 0)\n+\t{\n+\t  offset -= UNITS_PER_WORD;\n+\t  stack_offset -= UNITS_PER_WORD;\n+\t  ms1_emit_save_restore (direction, gen_rtx_REG (SImode, regno),\n+\t\t\t\t    gen_rtx_MEM (SImode,\n+\t\t\t\t\t\t gen_rtx_PLUS (SImode, base_reg, GEN_INT (offset))),\n+\t\t\t\t    stack_offset);\n+\t}\n+    }\n+}\n+\n+/* Return true if FUNC is a function with the 'interrupt' attribute.  */\n+static bool\n+ms1_interrupt_function_p (tree func)\n+{\n+  tree a;\n+\n+  if (TREE_CODE (func) != FUNCTION_DECL)\n+    return false;\n+\n+  a = lookup_attribute (\"interrupt\", DECL_ATTRIBUTES (func));\n+  return a != NULL_TREE;\n+}\n+\n+/* Generate prologue code.  */\n+void\n+ms1_expand_prologue (void)\n+{\n+  rtx size_rtx, insn;\n+  unsigned int frame_size;\n+\n+  if (ms1_interrupt_function_p (current_function_decl))\n+    {\n+      interrupt_handler = 1;\n+      if (cfun->machine)\n+\tcfun->machine->interrupt_handler = 1;\n+    }\n+\n+  ms1_compute_frame_size (get_frame_size ());\n+\n+  if (TARGET_DEBUG_STACK)\n+    ms1_debug_stack (&current_frame_info);\n+\n+  /* Compute size of stack adjustment.  */\n+  frame_size = current_frame_info.total_size;\n+\n+  /* If offset doesn't fit in a 15-bit signed integer,\n+     uses a scratch registers to get a smaller offset.  */\n+  if (CONST_OK_FOR_LETTER_P(frame_size, 'O'))\n+    size_rtx = GEN_INT (frame_size);\n+  else\n+    {\n+      /* We do not have any scratch registers.  */\n+      gcc_assert (!interrupt_handler);\n+\n+      size_rtx = gen_rtx_REG (SImode, GPR_R9);\n+      insn = emit_move_insn (size_rtx, GEN_INT (frame_size & 0xffff0000));\n+      insn = emit_insn (gen_iorsi3 (size_rtx, size_rtx,\n+\t\t\t\t    GEN_INT (frame_size & 0x0000ffff)));\n+    }\n+\n+  /* Allocate stack for this frame.  */\n+  /* Make stack adjustment and use scratch register if constant too\n+     large to fit as immediate.  */\n+  if (frame_size)\n+    {\n+      insn = emit_insn (gen_subsi3 (stack_pointer_rtx,\n+\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t size_rtx));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      REG_NOTES (insn)\n+\t= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\t\t     gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t  gen_rtx_MINUS (SImode,\n+\t\t\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\t\t\tGEN_INT (frame_size))),\n+\t\t\t     REG_NOTES (insn));\n+    }\n+\n+  /* Set R9 to point to old sp if required for access to register save area.  */\n+  if ( current_frame_info.reg_size != 0\n+       && !CONST_OK_FOR_LETTER_P (frame_size, 'O'))\n+      emit_insn (gen_addsi3 (size_rtx, size_rtx, stack_pointer_rtx));\n+  \n+  /* Save the frame pointer.  */\n+  ms1_emit_save_fp (FROM_PROCESSOR_TO_MEM, current_frame_info);\n+\n+  /* Now put the frame pointer into the frame pointer register.  */\n+  if (frame_pointer_needed)\n+    {\n+      insn = emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n+  /* Save the registers.  */\n+  ms1_emit_save_regs (FROM_PROCESSOR_TO_MEM, current_frame_info);\n+\n+  /* If we are profiling, make sure no instructions are scheduled before\n+     the call to mcount.  */\n+  if (profile_flag)\n+    emit_insn (gen_blockage ());\n+}\n+\n+/* Implement EPILOGUE_USES.  */\n+int\n+ms1_epilogue_uses (int regno)\n+{\n+  if (cfun->machine && cfun->machine->interrupt_handler && reload_completed)\n+    return 1;\n+  return regno == GPR_LINK;\n+}\n+\n+/* Generate epilogue.  EH_MODE is NORMAL_EPILOGUE when generating a\n+   function epilogue, or EH_EPILOGUE when generating an EH\n+   epilogue.  */\n+void\n+ms1_expand_epilogue (enum epilogue_type eh_mode)\n+{\n+  rtx size_rtx, insn;\n+  unsigned frame_size;\n+\n+  ms1_compute_frame_size (get_frame_size ());\n+\n+  if (TARGET_DEBUG_STACK)\n+    ms1_debug_stack (& current_frame_info);\n+\n+  /* Compute size of stack adjustment.  */\n+  frame_size = current_frame_info.total_size;\n+\n+  /* If offset doesn't fit in a 15-bit signed integer,\n+     uses a scratch registers to get a smaller offset.  */\n+  if (CONST_OK_FOR_LETTER_P(frame_size, 'O'))\n+    size_rtx = GEN_INT (frame_size);\n+  else\n+    {\n+      /* We do not have any scratch registers.  */\n+      gcc_assert (!interrupt_handler);\n+\n+      size_rtx = gen_rtx_REG (SImode, GPR_R9);\n+      insn = emit_move_insn (size_rtx, GEN_INT (frame_size & 0xffff0000));\n+      insn = emit_insn (gen_iorsi3 (size_rtx, size_rtx,\n+\t\t\t\t    GEN_INT (frame_size & 0x0000ffff)));\n+      /* Set R9 to point to old sp if required for access to register\n+\t save area.  */\n+      emit_insn (gen_addsi3 (size_rtx, size_rtx, stack_pointer_rtx));\n+    }\n+\n+  /* Restore sp if there was some possible change to it.  */\n+  if (frame_pointer_needed)\n+    insn = emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n+\n+  /* Restore the registers.  */\n+  ms1_emit_save_fp (FROM_MEM_TO_PROCESSOR, current_frame_info);\n+  ms1_emit_save_regs (FROM_MEM_TO_PROCESSOR, current_frame_info);\n+\n+  /* Make stack adjustment and use scratch register if constant too\n+     large to fit as immediate.  */\n+  if (frame_size)\n+    {\n+      if (CONST_OK_FOR_LETTER_P(frame_size, 'O'))\n+\t/* Can handle this with simple add.  */\n+\tinsn = emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t      stack_pointer_rtx,\n+\t\t\t\t      size_rtx));\n+      else\n+\t/* Scratch reg R9 has the old sp value.  */\n+\tinsn = emit_move_insn (stack_pointer_rtx, \n+\t\t\t       gen_rtx_REG (SImode, GPR_R9));\n+\n+      REG_NOTES (insn)\n+\t= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\t\t     gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t  gen_rtx_PLUS (SImode,\n+\t\t\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\t\t\tGEN_INT (frame_size))),\n+\t\t\t     REG_NOTES (insn));\n+    }\n+\n+  if (cfun->machine && cfun->machine->eh_stack_adjust != NULL_RTX)\n+    /* Perform the additional bump for __throw.  */\n+    emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t   stack_pointer_rtx,\n+\t\t\t   cfun->machine->eh_stack_adjust));\n+\n+  /* Generate the approriate return.  */\n+  if (eh_mode == EH_EPILOGUE)\n+    {\n+      emit_jump_insn (gen_eh_return_internal ());\n+      emit_barrier ();\n+    }\n+  else if (interrupt_handler)\n+    emit_jump_insn (gen_return_interrupt_internal ());\n+  else\n+    emit_jump_insn (gen_return_internal ());\n+\n+  /* Reset state info for each function.  */\n+  interrupt_handler = 0;\n+  current_frame_info = zero_frame_info;\n+  if (cfun->machine)\n+    cfun->machine->eh_stack_adjust = NULL_RTX;\n+}\n+\n+\n+/* Generate code for the \"eh_return\" pattern.  */\n+void\n+ms1_expand_eh_return (rtx * operands)\n+{\n+  if (GET_CODE (operands[0]) != REG\n+      || REGNO (operands[0]) != EH_RETURN_STACKADJ_REGNO)\n+    {\n+      rtx sp = EH_RETURN_STACKADJ_RTX;\n+\n+      emit_move_insn (sp, operands[0]);\n+      operands[0] = sp;\n+    }\n+\n+  emit_insn (gen_eh_epilogue (operands[0]));\n+}\n+\n+/* Generate code for the \"eh_epilogue\" pattern.  */\n+void\n+ms1_emit_eh_epilogue (rtx * operands ATTRIBUTE_UNUSED)\n+{\n+  cfun->machine->eh_stack_adjust = EH_RETURN_STACKADJ_RTX; /* operands[0]; */\n+  ms1_expand_epilogue (EH_EPILOGUE);\n+}\n+\n+/* Handle an \"interrupt\" attribute.  */\n+static tree\n+ms1_handle_interrupt_attribute (tree * node,\n+\t\t\t  tree   name,\n+\t\t\t  tree   args  ATTRIBUTE_UNUSED,\n+\t\t\t  int    flags ATTRIBUTE_UNUSED,\n+\t\t\t  bool * no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"%qs attribute only applies to functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Table of machine attributes.  */\n+const struct attribute_spec ms1_attribute_table[] =\n+{\n+  /* name,        min, max, decl?, type?, func?, handler  */\n+  { \"interrupt\",  0,   0,   false, false, false, ms1_handle_interrupt_attribute },\n+  { NULL,         0,   0,   false, false, false, NULL }\n+};\n+\n+/* Implement INITIAL_ELIMINATION_OFFSET.  */\n+int\n+ms1_initial_elimination_offset (int from, int to)\n+{\n+  ms1_compute_frame_size (get_frame_size ());\n+\n+  if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+    return 0;\n+\n+  else if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+    return current_frame_info.total_size;\n+\n+  else if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n+    return current_frame_info.total_size;\n+\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Generate a compare for CODE.  Return a brand-new rtx that\n+   represents the result of the compare.  */\n+\n+static rtx\n+ms1_generate_compare (enum rtx_code code, rtx op0, rtx op1)\n+{\n+  rtx scratch0, scratch1, const_scratch;\n+\n+  switch (code)\n+    {\n+    case GTU:\n+    case LTU:\n+    case GEU:\n+    case LEU:\n+      /* Need to adjust ranges for faking unsigned compares.  */\n+      scratch0 = gen_reg_rtx (SImode);\n+      scratch1 = gen_reg_rtx (SImode);\n+      const_scratch = force_reg (SImode, GEN_INT(MS1_MIN_INT));\n+      emit_insn (gen_addsi3 (scratch0, const_scratch, op0));\n+      emit_insn (gen_addsi3 (scratch1, const_scratch, op1));\n+      break;\n+    default:\n+      scratch0 = op0;\n+      scratch1 = op1;\n+      break;\n+    }\n+    \n+  /* Adjust compare operator to fake unsigned compares.  */\n+  switch (code)\n+    {\n+    case GTU:\n+      code = GT; break;\n+    case LTU:\n+      code = LT; break;\n+    case GEU:\n+      code = GE; break;\n+    case LEU:\n+      code = LE; break;\n+    default:\n+      /* do nothing */\n+      break;\n+    }\n+\n+  /* Generate the actual compare.  */\n+  return gen_rtx_fmt_ee (code, VOIDmode, scratch0, scratch1);\n+}\n+\n+/* Emit a branch of kind CODE to location LOC.  */\n+\n+void\n+ms1_emit_cbranch (enum rtx_code code, rtx loc, rtx op0, rtx op1)\n+{\n+  rtx condition_rtx, loc_ref;\n+\n+  if (! reg_or_0_operand (op0, SImode))\n+    op0 = copy_to_mode_reg (SImode, op0);\n+\n+  if (! reg_or_0_operand (op1, SImode))\n+    op1 = copy_to_mode_reg (SImode, op1);\n+\n+  condition_rtx = ms1_generate_compare (code, op0, op1);\n+  loc_ref = gen_rtx_LABEL_REF (VOIDmode, loc);\n+  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n+\t\t\t       gen_rtx_IF_THEN_ELSE (VOIDmode, condition_rtx,\n+\t\t\t\t\t\t     loc_ref, pc_rtx)));\n+}\n+\n+/* Subfunction of the following function.  Update the flags of any MEM\n+   found in part of X.  */\n+\n+static void\n+ms1_set_memflags_1 (rtx x, int in_struct_p, int volatile_p)\n+{\n+  int i;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case SEQUENCE:\n+    case PARALLEL:\n+      for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n+\tms1_set_memflags_1 (XVECEXP (x, 0, i), in_struct_p, volatile_p);\n+      break;\n+\n+    case INSN:\n+      ms1_set_memflags_1 (PATTERN (x), in_struct_p, volatile_p);\n+      break;\n+\n+    case SET:\n+      ms1_set_memflags_1 (SET_DEST (x), in_struct_p, volatile_p);\n+      ms1_set_memflags_1 (SET_SRC (x), in_struct_p, volatile_p);\n+      break;\n+\n+    case MEM:\n+      MEM_IN_STRUCT_P (x) = in_struct_p;\n+      MEM_VOLATILE_P (x) = volatile_p;\n+      /* Sadly, we cannot use alias sets because the extra aliasing\n+\t produced by the AND interferes.  Given that two-byte quantities\n+\t are the only thing we would be able to differentiate anyway,\n+\t there does not seem to be any point in convoluting the early\n+\t out of the alias check.  */\n+      /* set_mem_alias_set (x, alias_set); */\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+/* Look for any MEMs in the current sequence of insns and set the\n+   in-struct, unchanging, and volatile flags from the flags in REF.\n+   If REF is not a MEM, don't do anything.  */\n+\n+void\n+ms1_set_memflags (rtx ref)\n+{\n+  rtx insn;\n+  int in_struct_p, volatile_p;\n+\n+  if (GET_CODE (ref) != MEM)\n+    return;\n+\n+  in_struct_p = MEM_IN_STRUCT_P (ref);\n+  volatile_p = MEM_VOLATILE_P (ref);\n+\n+  /* This is only called from ms1.md, after having had something \n+     generated from one of the insn patterns.  So if everything is\n+     zero, the pattern is already up-to-date.  */\n+  if (! in_struct_p && ! volatile_p)\n+    return;\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    ms1_set_memflags_1 (insn, in_struct_p, volatile_p);\n+}\n+\n+/* Implement SECONDARY_RELOAD_CLASS.  */\n+enum reg_class\n+ms1_secondary_reload_class (enum reg_class class ATTRIBUTE_UNUSED,\n+\t\t\t    enum machine_mode mode,\n+\t\t\t    rtx x)\n+{\n+  if ((mode == QImode && (!TARGET_BYTE_ACCESS)) || mode == HImode)\n+    {\n+      if (GET_CODE (x) == MEM\n+\t  || (GET_CODE (x) == REG && true_regnum (x) == -1)\n+\t  || (GET_CODE (x) == SUBREG\n+\t      && (GET_CODE (SUBREG_REG (x)) == MEM\n+\t\t  || (GET_CODE (SUBREG_REG (x)) == REG\n+\t\t      && true_regnum (SUBREG_REG (x)) == -1))))\n+\treturn GENERAL_REGS;\n+    }\n+\n+  return NO_REGS;\n+}\n+\n+/* Handle FUNCTION_VALUE, FUNCTION_OUTGOING_VALUE, and LIBCALL_VALUE\n+   macros.  */\n+rtx\n+ms1_function_value (tree valtype, enum machine_mode mode, tree func_decl ATTRIBUTE_UNUSED)\n+{\n+  if ((mode) == DImode || (mode) == DFmode)\n+    return gen_rtx_MEM (mode, gen_rtx_REG (mode, RETURN_VALUE_REGNUM));\n+\n+  if (valtype)\n+    mode = TYPE_MODE (valtype);\n+\n+  return gen_rtx_REG (mode, RETURN_VALUE_REGNUM);\n+}\n+\n+/* Split a move into two smaller pieces.\n+   MODE indicates the reduced mode.  OPERANDS[0] is the original destination\n+   OPERANDS[1] is the original src.  The new destinations are\n+   OPERANDS[2] and OPERANDS[4], while the new sources are OPERANDS[3]\n+   and OPERANDS[5].  */\n+\n+void\n+ms1_split_words (enum machine_mode nmode,\n+\t\t enum machine_mode omode,\n+\t\t rtx *operands)\n+{\n+  rtx dl,dh;\t/* src/dest pieces.  */\n+  rtx sl,sh;\n+  int\tmove_high_first = 0;\t/* Assume no overlap.  */\n+\n+  switch (GET_CODE (operands[0])) /* Dest.  */\n+    {\n+    case SUBREG:\n+    case REG:\n+      if ((GET_CODE (operands[1]) == REG\n+\t   || GET_CODE (operands[1]) == SUBREG)\n+\t  && true_regnum (operands[0]) <= true_regnum (operands[1]))\n+\tmove_high_first = 1;\n+\n+      if (GET_CODE (operands[0]) == SUBREG)\n+\t{\n+\t  dl = gen_rtx_SUBREG (nmode, SUBREG_REG (operands[0]),\n+\t\t\t       SUBREG_BYTE (operands[0]) + GET_MODE_SIZE (nmode));\n+\t  dh = gen_rtx_SUBREG (nmode, SUBREG_REG (operands[0]), SUBREG_BYTE (operands[0]));\n+\t}\n+      else if (GET_CODE (operands[0]) == REG && ! IS_PSEUDO_P (operands[0]))\n+\t{\n+\t  int\tr = REGNO (operands[0]);\n+\t  dh = gen_rtx_REG (nmode, r);\n+\t  dl = gen_rtx_REG (nmode, r + HARD_REGNO_NREGS (r, nmode));\n+\t}\n+      else\n+\t{\n+\t  dh = gen_rtx_SUBREG (nmode, operands[0], 0);\n+\t  dl = gen_rtx_SUBREG (nmode, operands[0], GET_MODE_SIZE (nmode));\n+\t}\n+      break;\n+\n+    case MEM:\n+      switch (GET_CODE (XEXP (operands[0], 0)))\n+\t{\n+\tcase POST_INC:\n+\tcase POST_DEC:\n+\t  gcc_unreachable ();\n+\tdefault:\n+\t  dl = operand_subword (operands[0],\n+\t\t\t\tGET_MODE_SIZE (nmode)/UNITS_PER_WORD,\n+\t\t\t\t0, omode);\n+\t  dh = operand_subword (operands[0], 0, 0, omode);\n+\t}\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  switch (GET_CODE (operands[1]))\n+    {\n+    case REG:\n+      if (! IS_PSEUDO_P (operands[1]))\n+\t{\n+\t  int r = REGNO (operands[1]);\n+\n+\t  sh = gen_rtx_REG (nmode, r);\n+\t  sl = gen_rtx_REG (nmode, r + HARD_REGNO_NREGS (r, nmode));\n+\t}\n+      else\n+\t{\n+\t  sh = gen_rtx_SUBREG (nmode, operands[1], 0);\n+\t  sl = gen_rtx_SUBREG (nmode, operands[1], GET_MODE_SIZE (nmode));\n+\t}\n+      break;\n+\n+    case CONST_DOUBLE:\n+      if (operands[1] == const0_rtx)\n+\tsh = sl = const0_rtx;\n+      else\n+\tsplit_double (operands[1], & sh, & sl);\n+      break;\n+\n+    case CONST_INT:\n+      if (operands[1] == const0_rtx)\n+\tsh = sl = const0_rtx;\n+      else\n+\t{\n+\t  int vl, vh;\n+\n+\t  switch (nmode)\n+\t    {\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t    \n+\t  sl = GEN_INT (vl);\n+\t  sh = GEN_INT (vh);\n+\t}\n+      break;\n+\n+    case SUBREG:\n+      sl = gen_rtx_SUBREG (nmode,\n+\t\t\t   SUBREG_REG (operands[1]),\n+\t\t\t   SUBREG_BYTE (operands[1]) + GET_MODE_SIZE (nmode));\n+      sh = gen_rtx_SUBREG (nmode,\n+\t\t\t   SUBREG_REG (operands[1]),\n+\t\t\t   SUBREG_BYTE (operands[1]));\n+      break;\n+\n+    case MEM:\n+      switch (GET_CODE (XEXP (operands[1], 0)))\n+\t{\n+\tcase POST_DEC:\n+\tcase POST_INC:\n+\t  gcc_unreachable ();\n+\t  break;\n+\tdefault:\n+\t  sl = operand_subword (operands[1], \n+\t\t\t\tGET_MODE_SIZE (nmode)/UNITS_PER_WORD,\n+\t\t\t\t0, omode);\n+\t  sh = operand_subword (operands[1], 0, 0, omode);\n+\t  \n+\t  /* Check if the DF load is going to clobber the register\n+             used for the address, and if so make sure that is going\n+             to be the second move.  */\n+\t  if (GET_CODE (dl) == REG\n+\t      && true_regnum (dl)\n+\t      == true_regnum (XEXP (XEXP (sl, 0 ), 0)))\n+\t    move_high_first = 1;\n+\t}\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (move_high_first)\n+    {\n+      operands[2] = dh;\n+      operands[3] = sh;\n+      operands[4] = dl;\n+      operands[5] = sl;\n+    }\n+  else\n+    {\n+      operands[2] = dl;\n+      operands[3] = sl;\n+      operands[4] = dh;\n+      operands[5] = sh;\n+    }\n+  return;\n+}\n+\n+/* Implement TARGET_MUST_PASS_IN_STACK hook.  */\n+static bool\n+ms1_pass_in_stack (enum machine_mode mode ATTRIBUTE_UNUSED, tree type)\n+{\n+  return (((type) != 0\n+\t   && (TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST\n+\t       || TREE_ADDRESSABLE (type))));\n+}\n+\f\n+/* Initialize the GCC target structure.  */\n+const struct attribute_spec ms1_attribute_table[];\n+\n+#undef  TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE \t\tms1_attribute_table\n+#undef  TARGET_STRUCT_VALUE_RTX\n+#define TARGET_STRUCT_VALUE_RTX\t\tms1_struct_value_rtx\n+#undef  TARGET_PROMOTE_PROTOTYPES\n+#define TARGET_PROMOTE_PROTOTYPES\thook_bool_tree_true\n+#undef  TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE\tms1_pass_by_reference\n+#undef  TARGET_MUST_PASS_IN_STACK\n+#define TARGET_MUST_PASS_IN_STACK       ms1_pass_in_stack\n+#undef  TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES\tms1_arg_partial_bytes\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;\n+\f\n+#include \"gt-ms1.h\""}, {"sha": "4183bb109593d2969e22aec70d8532cd264a8e6b", "filename": "gcc/config/ms1/ms1.h", "status": "added", "additions": 861, "deletions": 0, "changes": 861, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig%2Fms1%2Fms1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig%2Fms1%2Fms1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fms1.h?ref=c85ba4fb34b8dc43ac29ddb7009863b2cb03565d", "patch": "@@ -0,0 +1,861 @@\n+/* Target Definitions for MorphoRISC1\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Red Hat, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+extern struct rtx_def * ms1_ucmpsi3_libcall;\n+\n+enum processor_type\n+{\n+  PROCESSOR_MS1_64_001,\n+  PROCESSOR_MS1_16_002,\n+  PROCESSOR_MS1_16_003\n+};\n+\n+enum epilogue_type\n+{\n+  EH_EPILOGUE,\n+  NORMAL_EPILOGUE\n+};\n+\n+extern enum processor_type ms1_cpu;\n+\n+\f\n+/* A C string constant that tells the GCC driver program options to pass to\n+   the assembler.  */\n+#undef  ASM_SPEC\n+#define ASM_SPEC \"%{march=ms1-16-002: -march=ms1-16-002} %{march=ms1-16-003: -march=ms1-16-003} %{!march=*: -march=ms1-16-002}\"\n+\n+/* A string to pass to at the end of the comman given to the linker.  */\n+#undef  LIB_SPEC\n+#define LIB_SPEC \"--start-group -lc -lsim --end-group \\\n+%{msim: ; \\\n+march=ms1-64-001:-T 64-001.ld%s; \\\n+march=MS1-64-001:-T 64-001.ld%s; \\\n+march=ms1-16-002:-T 16-002.ld%s; \\\n+march=MS1-16-002:-T 16-002.ld%s; \\\n+march=ms1-16-003:-T 16-003.ld%s; \\\n+march=MS1-16-003:-T 16-003.ld%s}\"\n+\n+/* A string to pass at the very beginning of the command given to the\n+   linker.  */\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC \"%{msim:crt0.o%s;\\\n+march=ms1-64-001:%{!mno-crt0:crt0-64-001.o%s} startup-64-001.o%s; \\\n+march=MS1-64-001:%{!mno-crt0:crt0-64-001.o%s} startup-64-001.o%s; \\\n+march=ms1-16-002:%{!mno-crt0:crt0-16-002.o%s} startup-16-002.o%s; \\\n+march=MS1-16-002:%{!mno-crt0:crt0-16-002.o%s} startup-16-002.o%s; \\\n+march=ms1-16-003:%{!mno-crt0:crt0-16-003.o%s} startup-16-003.o%s; \\\n+march=MS1-16-003:%{!mno-crt0:crt0-16-003.o%s} startup-16-003.o%s} \\\n+crti.o%s crtbegin.o%s\"\n+\n+/* A string to pass at the end of the command given to the linker.  */\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC \"%{msim:exit.o%s; \\\n+march=ms1-64-001:exit-64-001.o%s; \\\n+march=MS1-64-001:exit-64-001.o%s; \\\n+march=ms1-16-002:exit-16-002.o%s; \\\n+march=MS1-16-002:exit-16-002.o%s; \\\n+march=ms1-16-003:exit-16-003.o%s; \\\n+march=MS1-16-003:exit-16-003.o%s} \\\n+ crtend.o%s crtn.o%s\"\n+\f\n+/* Run-time target specifications.  */\n+\n+#define TARGET_CPU_CPP_BUILTINS() \t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      builtin_define_std (\"ms1\");\t\t\\\n+      builtin_assert (\"machine=ms1\");\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define TARGET_VERSION  fprintf (stderr, \" (ms1)\");\n+\n+#define OVERRIDE_OPTIONS ms1_override_options ()\n+\n+#define CAN_DEBUG_WITHOUT_FP 1\n+\n+\f\n+/* Storage Layout.  */\n+\n+#define BITS_BIG_ENDIAN 0\n+\n+#define BYTES_BIG_ENDIAN 1\n+\n+#define WORDS_BIG_ENDIAN 1\n+\n+#define UNITS_PER_WORD 4\n+\n+/* A macro to update MODE and UNSIGNEDP when an object whose type is TYPE and\n+   which has the specified mode and signedness is to be stored in a register.\n+   This macro is only called when TYPE is a scalar type.\n+\n+   On most RISC machines, which only have operations that operate on a full\n+   register, define this macro to set M to `word_mode' if M is an integer mode\n+   narrower than `BITS_PER_WORD'.  In most cases, only integer modes should be\n+   widened because wider-precision floating-point operations are usually more\n+   expensive than their narrower counterparts.\n+\n+   For most machines, the macro definition does not change UNSIGNEDP.  However,\n+   some machines, have instructions that preferentially handle either signed or\n+   unsigned quantities of certain modes.  For example, on the DEC Alpha, 32-bit\n+   loads from memory and 32-bit add instructions sign-extend the result to 64\n+   bits.  On such machines, set UNSIGNEDP according to which kind of extension\n+   is more efficient.\n+\n+   Do not define this macro if it would never modify MODE.  */\n+#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\\\n+\t  && GET_MODE_SIZE (MODE) < 4)\t\t\t\t\\\n+\t(MODE) = SImode;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* Normal alignment required for function parameters on the stack, in bits.\n+   All stack parameters receive at least this much alignment regardless of data\n+   type.  On most machines, this is the same as the size of an integer.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Define this macro to the minimum alignment enforced by hardware for\n+   the stack pointer on this machine.  The definition is a C\n+   expression for the desired alignment (measured in bits).  This\n+   value is used as a default if PREFERRED_STACK_BOUNDARY is not\n+   defined.  On most machines, this should be the same as\n+   PARM_BOUNDARY.  */\n+#define STACK_BOUNDARY 32\n+\n+/* Alignment required for a function entry point, in bits.  */\n+#define FUNCTION_BOUNDARY 32\n+\n+/* Biggest alignment that any data type can require on this machine,\n+   in bits.  */\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* If defined, a C expression to compute the alignment for a variable\n+   in the static store.  TYPE is the data type, and ALIGN is the\n+   alignment that the object would ordinarily have.  The value of this\n+   macro is used instead of that alignment to align the object.\n+\n+   If this macro is not defined, then ALIGN is used.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* If defined, a C expression to compute the alignment given to a constant that\n+   is being placed in memory.  CONSTANT is the constant and ALIGN is the\n+   alignment that the object would ordinarily have.  The value of this macro is\n+   used instead of that alignment to align the object.\n+\n+   If this macro is not defined, then ALIGN is used.\n+\n+   The typical use of this macro is to increase alignment for string constants\n+   to be word aligned so that `strcpy' calls that copy constants can be done\n+   inline.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  (TREE_CODE (EXP) == STRING_CST\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* Number of bits which any structure or union's size must be a multiple of.\n+   Each structure or union's size is rounded up to a multiple of this.\n+\n+   If you do not define this macro, the default is the same as `BITS_PER_UNIT'.  */\n+#define STRUCTURE_SIZE_BOUNDARY 32\n+\n+/* Define this macro to be the value 1 if instructions will fail to work if\n+   given data not on the nominal alignment.  If instructions will merely go\n+   slower in that case, define this macro as 0.  */\n+#define STRICT_ALIGNMENT 1\n+\n+/* Define this if you wish to imitate the way many other C compilers handle\n+   alignment of bitfields and the structures that contain them.  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\f\n+/* Layout of Source Language Data Types.  */\n+\n+#define INT_TYPE_SIZE 32\n+\n+#define SHORT_TYPE_SIZE 16\n+\n+#define LONG_TYPE_SIZE 32\n+\n+#define LONG_LONG_TYPE_SIZE 64\n+\n+#define CHAR_TYPE_SIZE 8\n+\n+#define FLOAT_TYPE_SIZE 32\n+\n+#define DOUBLE_TYPE_SIZE 64\n+\n+#define LONG_DOUBLE_TYPE_SIZE 64\n+\n+#define DEFAULT_SIGNED_CHAR 1\n+\f\n+/* Register Basics.  */\n+\n+/* General purpose registers.  */\n+#define GPR_FIRST       0               /* First gpr */\n+#define GPR_LAST        15\t\t/* Last possible gpr */\n+\n+#define GPR_R0          0\t\t/* Always 0 */\n+#define GPR_R7          7\t\t/* Used as a scratch register */\n+#define GPR_R8          8\t\t/* Used as a scratch register */\n+#define GPR_R9          9\t\t/* Used as a scratch register */\n+#define GPR_R10         10\t\t/* Used as a scratch register */\n+#define GPR_R11         11\t\t/* Used as a scratch register */\n+#define GPR_FP          12\t\t/* Frame pointer */\n+#define GPR_SP          13\t        /* Stack pointer */\n+#define GPR_LINK\t14\t\t/* Saved return address as\n+\t\t\t\t\t   seen  by the caller */\n+#define GPR_INTERRUPT_LINK 15\t\t/* hold return addres for interrupts */\n+\n+/* Argument register that is eliminated in favor of the frame and/or stack\n+   pointer.  Also add register to point to where the return address is\n+   stored.  */\n+#define SPECIAL_REG_FIRST\t\t(GPR_LAST + 1)\n+#define SPECIAL_REG_LAST\t\t(SPECIAL_REG_FIRST)\n+#define ARG_POINTER_REGNUM\t\t(SPECIAL_REG_FIRST + 0)\n+#define SPECIAL_REG_P(R)\t\t((R) == SPECIAL_REG_FIRST)\n+\n+/* The first/last register that can contain the arguments to a function.  */\n+#define FIRST_ARG_REGNUM\t1\n+#define LAST_ARG_REGNUM\t\t4\n+\n+/* The register used to hold functions return value */\n+#define RETVAL_REGNUM\t\t11\n+\n+#define FIRST_PSEUDO_REGISTER (GPR_FIRST + 17)\n+\n+#define IS_PSEUDO_P(R)\t(REGNO (R) >= FIRST_PSEUDO_REGISTER)\n+\n+/* R0\t\talways has the value 0\n+   R10          static link\n+   R12\tFP\tpointer to active frame\n+   R13\tSP\tpointer to top of stack\n+   R14\tRA\treturn address\n+   R15\tIRA\tinterrupt return address.  */\n+#define FIXED_REGISTERS { 1, 0, 0, 0, 0, 0, 0, 0, \\\n+\t\t\t  0, 0, 0, 0, 1, 1, 1, 1, \\\n+\t\t\t  1\t\t\t  \\\n+\t\t\t }\n+\n+/* Like `FIXED_REGISTERS' but has 1 for each register that is clobbered (in\n+   general) by function calls as well as for fixed registers.  This macro\n+   therefore identifies the registers that are not available for general\n+   allocation of values that must live across function calls.  */\n+#define CALL_USED_REGISTERS\t{ 1, 1, 1, 1, 1, 0, 0, 1, \\\n+\t\t\t\t  1, 1, 1, 1, 1, 1, 1, 1, \\\n+\t\t\t\t  1\t\t\t  \\\n+\t\t\t\t}\n+\n+\f\n+/* How Values Fit in Registers.  */\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE) \t\t\t\t\\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n+\n+/* A C expression that is nonzero if a value of mode MODE1 is\n+   accessible in mode MODE2 without copying.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) 1\n+\f\n+/* Register Classes.  */\n+\n+enum reg_class\n+{\n+  NO_REGS,\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+#define   GENERAL_REGS\tALL_REGS\n+\n+#define N_REG_CLASSES ((int) LIM_REG_CLASSES)\n+\n+#define REG_CLASS_NAMES {\"NO_REGS\", \"ALL_REGS\" }\n+\n+#define REG_CLASS_CONTENTS \\\n+   {\t\t\t\t\t\t\t\t\t\\\n+     { 0x0, 0x0 },\t\t\t\t\t\t\t\\\n+     { (((1 << (GPR_LAST + 1)) - 1) & ~(1 << GPR_FIRST)), 0x0 },\t\\\n+   }\n+\n+/* A C expression whose value is a register class containing hard register\n+   REGNO.  In general there is more than one such class; choose a class which\n+   is \"minimal\", meaning that no smaller class also contains the register.  */\n+#define REGNO_REG_CLASS(REGNO) GENERAL_REGS\n+\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+#define INDEX_REG_CLASS NO_REGS\n+\n+#define REG_CLASS_FROM_LETTER(CHAR) NO_REGS\n+\n+#define REGNO_OK_FOR_BASE_P(NUM) 1\n+\n+#define REGNO_OK_FOR_INDEX_P(NUM) 1\n+\n+/* A C expression that places additional restrictions on the register class to\n+   use when it is necessary to copy value X into a register in class CLASS.\n+   The value is a register class; perhaps CLASS, or perhaps another, smaller\n+   class.  On many machines, the following definition is safe:\n+\n+        #define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS\n+*/\n+#define PREFERRED_RELOAD_CLASS(X, CLASS) (CLASS)\n+\n+#define SECONDARY_RELOAD_CLASS(CLASS,MODE,X) \\\n+  ms1_secondary_reload_class((CLASS), (MODE), (X))\n+\n+/* A C expression for the maximum number of consecutive registers of\n+   class CLASS needed to hold a value of mode MODE.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE) \\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* For MorphoRISC1:\n+\n+   `I'\tis used for the range of constants an arithmetic insn can\n+\tactually contain (16 bits signed integers).\n+\n+   `J'\tis used for the range which is just zero (ie, $r0).\n+\n+   `K'\tis used for the range of constants a logical insn can actually\n+\tcontain (16 bit zero-extended integers).\n+\n+   `L'\tis used for the range of constants that be loaded with lui\n+\t(ie, the bottom 16 bits are zero).\n+\n+   `M'\tis used for the range of constants that take two words to load\n+\t(ie, not matched by `I', `K', and `L').\n+\n+   `N'\tis used for negative 16 bit constants other than -65536.\n+\n+   `O'\tis a 15 bit signed integer.\n+\n+   `P'\tis used for positive 16 bit constants.  */\n+\n+#define SMALL_INT(X) ((unsigned HOST_WIDE_INT) (INTVAL (X) + 0x8000) < 0x10000)\n+#define SMALL_INT_UNSIGNED(X) ((unsigned HOST_WIDE_INT) (INTVAL (X)) < 0x10000)\n+\n+/* A C expression that defines the machine-dependent operand\n+   constraint letters that specify particular ranges of integer\n+   values.  If C is one of those letters, the expression should check\n+   that VALUE, an integer, is in the appropriate range and return 1 if\n+   so, 0 otherwise.  If C is not one of those letters, the value\n+   should be 0 regardless of VALUE.  */\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n+  ((C) == 'I' ? ((unsigned HOST_WIDE_INT) ((VALUE) + 0x8000) < 0x10000)\t\\\n+   : (C) == 'J' ? ((VALUE) == 0)\t\t\t\t\t\\\n+   : (C) == 'K' ? ((unsigned HOST_WIDE_INT) (VALUE) < 0x10000)\t\t\\\n+   : (C) == 'L' ? (((VALUE) & 0x0000ffff) == 0\t\t\t\t\\\n+\t\t   && (((VALUE) & ~2147483647) == 0\t\t\t\\\n+\t\t       || ((VALUE) & ~2147483647) == ~2147483647))\t\\\n+   : (C) == 'M' ? ((((VALUE) & ~0x0000ffff) != 0)\t\t\t\\\n+\t\t   && (((VALUE) & ~0x0000ffff) != ~0x0000ffff)\t\t\\\n+\t\t   && (((VALUE) & 0x0000ffff) != 0\t\t\t\\\n+\t\t       || (((VALUE) & ~2147483647) != 0\t\t\t\\\n+\t\t\t   && ((VALUE) & ~2147483647) != ~2147483647)))\t\\\n+   : (C) == 'N' ? ((unsigned HOST_WIDE_INT) ((VALUE) + 0xffff) < 0xffff) \\\n+   : (C) == 'O' ? ((unsigned HOST_WIDE_INT) ((VALUE) + 0x4000) < 0x8000) \\\n+   : (C) == 'P' ? ((VALUE) != 0 && (((VALUE) & ~0x0000ffff) == 0))\t\\\n+   : 0)\n+\n+/* A C expression that defines the machine-dependent operand constraint letters\n+   (`G', `H') that specify particular ranges of `const_double' values.  */\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) 0\n+\n+/* Most negative value represent on ms1 */\n+#define MS1_MIN_INT 0x80000000\n+\f\n+/* Basic Stack Layout.  */\n+\n+enum save_direction\n+{\n+  FROM_PROCESSOR_TO_MEM,\n+  FROM_MEM_TO_PROCESSOR\n+};\n+\n+/* Tell prologue and epilogue if register REGNO should be saved / restored.\n+   The return address and frame pointer are treated separately.\n+   Don't consider them here.  */\n+#define MUST_SAVE_REGISTER(regno)\t\t\t\t\\\n+  (   (regno) != GPR_LINK \t\t\t\t\t\\\n+   && (regno) != GPR_FP\t\t  \t\t\t\t\\\n+   && (regno) != GPR_SP\t\t  \t\t\t\t\\\n+   && (regno) != GPR_R0\t\t  \t\t\t\t\\\n+   &&   (( regs_ever_live [regno] && ! call_used_regs [regno] ) \\\n+       /* Save ira register in an interrupt handler.  */\t\\\n+\t|| (interrupt_handler && (regno) == GPR_INTERRUPT_LINK)\t\\\n+       /* Save any register used in an interrupt handler.  */\t\\\n+\t|| (interrupt_handler && regs_ever_live [regno])\t\\\n+       /* Save call clobbered registers in non-leaf interrupt\t\\\n+\t  handlers.  */\t\t\t\t\t\t\\\n+\t|| (interrupt_handler && call_used_regs[regno] \t\t\\\n+\t   && !current_function_is_leaf)\t\t\t\\\n+\t||(current_function_calls_eh_return\t\t\t\\\n+\t   && (regno == GPR_R7 || regno == GPR_R8))\t\t\\\n+\t)\t\t\t\t\t\t\t\\\n+  )\n+\n+#define STACK_GROWS_DOWNWARD 1\n+\n+/* Offset from the frame pointer to the first local variable slot to be\n+   allocated.\n+\n+   If `FRAME_GROWS_DOWNWARD', find the next slot's offset by\n+   subtracting the first slot's length from `STARTING_FRAME_OFFSET'.\n+   Otherwise, it is found by adding the length of the first slot to\n+   the value `STARTING_FRAME_OFFSET'.  */\n+#define STARTING_FRAME_OFFSET current_function_outgoing_args_size\n+\n+/* Offset from the argument pointer register to the first argument's address.\n+   On some machines it may depend on the data type of the function.\n+\n+   If `ARGS_GROW_DOWNWARD', this is the offset to the location above the first\n+   argument's address.  */\n+#define FIRST_PARM_OFFSET(FUNDECL) 0\n+\n+#define RETURN_ADDR_RTX(COUNT, FRAMEADDR) \t\t\t\t\\\n+    ms1_return_addr_rtx (COUNT)\n+\n+/* A C expression whose value is RTL representing the location of the incoming\n+   return address at the beginning of any function, before the prologue.  This\n+   RTL is either a `REG', indicating that the return value is saved in `REG',\n+   or a `MEM' representing a location in the stack.\n+\n+   You only need to define this macro if you want to support call frame\n+   debugging information like that provided by DWARF 2.  */\n+#define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (SImode, GPR_LINK)\n+\n+/* A C expression whose value is an integer giving the offset, in bytes, from\n+   the value of the stack pointer register to the top of the stack frame at the\n+   beginning of any function, before the prologue.  The top of the frame is\n+   defined to be the value of the stack pointer in the previous frame, just\n+   before the call instruction.\n+\n+   You only need to define this macro if you want to support call frame\n+   debugging information like that provided by DWARF 2.  */\n+#define INCOMING_FRAME_SP_OFFSET 0\n+\n+#define STACK_POINTER_REGNUM GPR_SP\n+\n+#define FRAME_POINTER_REGNUM GPR_FP\n+\n+/* The register number of the arg pointer register, which is used to\n+   access the function's argument list.  */\n+#define ARG_POINTER_REGNUM\t\t(SPECIAL_REG_FIRST + 0)\n+\n+/* Register numbers used for passing a function's static chain pointer.  */\n+#define STATIC_CHAIN_REGNUM 10\n+\n+/* A C expression which is nonzero if a function must have and use a frame\n+   pointer.  */\n+#define FRAME_POINTER_REQUIRED 0\n+\n+/* Structure to be filled in by compute_frame_size with register\n+   save masks, and offsets for the current function.  */\n+\n+struct ms1_frame_info\n+{\n+  unsigned int total_size;      /* # Bytes that the entire frame takes up.  */\n+  unsigned int pretend_size;    /* # Bytes we push and pretend caller did.  */\n+  unsigned int args_size;       /* # Bytes that outgoing arguments take up.  */\n+  unsigned int extra_size;\n+  unsigned int reg_size;        /* # Bytes needed to store regs.  */\n+  unsigned int var_size;        /* # Bytes that variables take up.  */\n+  unsigned int frame_size;      /* # Bytes in current frame.  */\n+  unsigned int reg_mask;        /* Mask of saved registers.  */\n+  unsigned int save_fp;         /* Nonzero if frame pointer must be saved.  */\n+  unsigned int save_lr;         /* Nonzero if return pointer must be saved.  */\n+  int          initialized;     /* Nonzero if frame size already calculated.  */\n+}; \n+\n+extern struct ms1_frame_info current_frame_info;\n+\n+/* If defined, this macro specifies a table of register pairs used to eliminate\n+   unneeded registers that point into the stack frame.  */\n+#define ELIMINABLE_REGS\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  {ARG_POINTER_REGNUM,\t STACK_POINTER_REGNUM},\t\t\t\t\\\n+  {ARG_POINTER_REGNUM,\t FRAME_POINTER_REGNUM},\t\t\t\t\\\n+  {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}\t\t\t\t\\\n+}\n+\n+/* A C expression that returns non-zero if the compiler is allowed to try to\n+   replace register number FROM with register number TO.  */\n+#define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\t\\\n+ ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM\t\t\\\n+  ? ! frame_pointer_needed\t\t\t\t\t\t\\\n+  : 1)\n+\n+/* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It\n+   specifies the initial difference between the specified pair of\n+   registers.  This macro must be defined if `ELIMINABLE_REGS' is\n+   defined.  */\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n+  (OFFSET) = ms1_initial_elimination_offset (FROM, TO)\n+\n+/* If defined, the maximum amount of space required for outgoing\n+   arguments will be computed and placed into the variable\n+   `current_function_outgoing_args_size'.  */\n+#define ACCUMULATE_OUTGOING_ARGS 1\n+\n+/* Define this if it is the responsibility of the caller to\n+   allocate the area reserved for arguments passed in registers.  */\n+#define OUTGOING_REG_PARM_STACK_SPACE\n+\n+/* The number of register assigned to holding function arguments.  */\n+#define MS1_NUM_ARG_REGS        4\n+\n+/* Define this if it is the responsibility of the caller to allocate\n+   the area reserved for arguments passed in registers.  */\n+#define REG_PARM_STACK_SPACE(FNDECL) (MS1_NUM_ARG_REGS * UNITS_PER_WORD)\n+\n+/* Define this macro if `REG_PARM_STACK_SPACE' is defined, but the stack\n+   parameters don't skip the area specified by it.  */\n+#define STACK_PARMS_IN_REG_PARM_AREA\n+\n+/* A C expression that should indicate the number of bytes of its own\n+   arguments that a function pops on returning, or 0 if the function\n+   pops no arguments and the caller must therefore pop them all after\n+   the function returns.  */\n+#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, STACK_SIZE) 0\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+   ms1_function_arg (& (CUM), (MODE), (TYPE), (NAMED), FALSE)\n+\n+#define CUMULATIVE_ARGS int\n+\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS)\t\\\n+    ms1_init_cumulative_args (& (CUM), FNTYPE, LIBNAME, FNDECL, FALSE)\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n+    ms1_function_arg_advance (&CUM, MODE, TYPE, NAMED)\n+\n+#define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\t\t\t\t\\\n+    ms1_function_arg_boundary (MODE, TYPE)\n+\n+#define FUNCTION_ARG_REGNO_P(REGNO)\t\t\t\t\t\\\n+  ((REGNO) >= FIRST_ARG_REGNUM && ((REGNO) <= LAST_ARG_REGNUM))\n+\n+#define RETURN_VALUE_REGNUM\tRETVAL_REGNUM\n+     \n+#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n+   ms1_function_value (VALTYPE, TYPE_MODE(VALTYPE), FUNC)\n+\n+#define LIBCALL_VALUE(MODE) \\\n+   ms1_function_value (NULL_TREE, MODE, NULL_TREE)\n+\n+#define FUNCTION_VALUE_REGNO_P(REGNO) ((REGNO) == RETURN_VALUE_REGNUM)\n+\n+/* A C expression which can inhibit the returning of certain function\n+   values in registers, based on the type of value.  */\n+#define RETURN_IN_MEMORY(TYPE) (int_size_in_bytes (TYPE) > UNITS_PER_WORD)\n+\n+/* Define this macro to be 1 if all structure and union return values must be\n+   in memory.  */\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\n+/* Define this macro as a C expression that is nonzero if the return\n+   instruction or the function epilogue ignores the value of the stack\n+   pointer; in other words, if it is safe to delete an instruction to\n+   adjust the stack pointer before a return from the function.  */\n+#define EXIT_IGNORE_STACK 1\n+\n+#define EPILOGUE_USES(REGNO) ms1_epilogue_uses(REGNO)\n+\n+/* Define this macro if the function epilogue contains delay slots to which\n+   instructions from the rest of the function can be \"moved\".  */\n+#define DELAY_SLOTS_FOR_EPILOGUE 1\n+\n+/* A C expression that returns 1 if INSN can be placed in delay slot number N\n+   of the epilogue.  */\n+#define ELIGIBLE_FOR_EPILOGUE_DELAY(INSN, N) 0\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO) gcc_unreachable ()\n+\n+#define EXPAND_BUILTIN_VA_START(VALIST, NEXTARG)\t\t\\\n+  ms1_va_start (VALIST, NEXTARG)\n+\n+/* Trampolines are not implemented.  */\n+#define TRAMPOLINE_SIZE 0\n+\n+#define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, STATIC_CHAIN)\n+\n+/* ?? What is this -- aldyh ?? */\n+#define UCMPSI3_LIBCALL\t\t\"__ucmpsi3\"\n+\n+/* Addressing Modes.  */\n+\n+/* A C expression that is 1 if the RTX X is a constant which is a valid\n+   address.  */\n+#define CONSTANT_ADDRESS_P(X) CONSTANT_P (X)\n+\n+/* A number, the maximum number of registers that can appear in a valid memory\n+   address.  Note that it is up to you to specify a value equal to the maximum\n+   number that `GO_IF_LEGITIMATE_ADDRESS' would ever accept.  */\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+#ifdef REG_OK_STRICT\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\\\n+{\t\t\t\t\t\t\\\n+  if (ms1_legitimate_address_p (MODE, X, 1))\t\\\n+    goto ADDR;\t\t\t\t\t\\\n+}\n+#else\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\\\n+{\t\t\t\t\t\t\\\n+  if (ms1_legitimate_address_p (MODE, X, 0))\t\\\n+    goto ADDR;\t\t\t\t\t\\\n+}\n+#endif\n+\n+#ifdef REG_OK_STRICT\n+#define REG_OK_FOR_BASE_P(X) ms1_reg_ok_for_base_p (X, 1)\n+#else\n+#define REG_OK_FOR_BASE_P(X) ms1_reg_ok_for_base_p (X, 0)\n+#endif\n+\n+#define REG_OK_FOR_INDEX_P(X) REG_OK_FOR_BASE_P (X)\n+\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN) {}\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\n+\n+#define LEGITIMATE_CONSTANT_P(X) 1\n+\n+/* A C expression for the cost of moving data of mode M between a register and\n+   memory.  A value of 2 is the default; this cost is relative to those in\n+   `REGISTER_MOVE_COST'.\n+\n+   If moving between registers and memory is more expensive than between two\n+   registers, you should define this macro to express the relative cost.  */\n+#define MEMORY_MOVE_COST(M,C,I) 10\n+\n+/* Define this macro as a C expression which is nonzero if accessing less than\n+   a word of memory (i.e. a `char' or a `short') is no faster than accessing a\n+   word of memory.  */\n+#define SLOW_BYTE_ACCESS 1\n+\n+#define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) 1 \n+\n+#define TEXT_SECTION_ASM_OP \".text\"\n+\n+#define DATA_SECTION_ASM_OP \".data\"\n+\n+#define BSS_SECTION_ASM_OP \"\\t.section\\t.bss\"\n+\n+/* A C string constant for text to be output before each `asm' statement or\n+   group of consecutive ones.  Normally this is `\"#APP\"', which is a comment\n+   that has no effect on most assemblers but tells the GNU assembler that it\n+   must check the lines that follow for all valid assembler constructs.  */\n+#define ASM_APP_ON \"#APP\\n\"\n+\n+/* A C string constant for text to be output after each `asm' statement or\n+   group of consecutive ones.  Normally this is `\"#NO_APP\"', which tells the\n+   GNU assembler to resume making the time-saving assumptions that are valid\n+   for ordinary compiler output.  */\n+#define ASM_APP_OFF \"#NO_APP\\n\"\n+\n+/* This is how to output an assembler line defining a `char' constant.  */\n+#define ASM_OUTPUT_CHAR(FILE, VALUE)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.byte\\t\");\t\t\t\\\n+      output_addr_const (FILE, (VALUE));\t\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* This is how to output an assembler line defining a `short' constant.  */\n+#define ASM_OUTPUT_SHORT(FILE, VALUE)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.hword\\t\");\t\t\t\\\n+      output_addr_const (FILE, (VALUE));\t\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* This is how to output an assembler line defining an `int' constant.\n+   We also handle symbol output here.  */\n+#define ASM_OUTPUT_INT(FILE, VALUE)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.word\\t\");\t\t\t\\\n+      output_addr_const (FILE, (VALUE));\t\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* A C statement to output to the stdio stream STREAM an assembler instruction\n+   to assemble a single byte containing the number VALUE.\n+\n+   This declaration must be present.  */\n+#define ASM_OUTPUT_BYTE(STREAM, VALUE) \\\n+  fprintf (STREAM, \"\\t%s\\t0x%x\\n\", ASM_BYTE_OP, (VALUE))\n+\n+/* Globalizing directive for a label.  */\n+#define GLOBAL_ASM_OP \"\\t.globl \"\n+\n+#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n+{ \"R0\", \"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"R6\", \"R7\",\t\t\t\\\n+  \"R8\", \"R9\", \"R10\", \"R11\", \"R12\", \"R13\", \"R14\", \"R15\",\t\t\t\\\n+  \"ap\" }\n+\n+/* If defined, a C initializer for an array of structures containing a name and\n+   a register number.  This macro defines additional names for hard registers,\n+   thus allowing the `asm' option in declarations to refer to registers using\n+   alternate names.  */\n+#define ADDITIONAL_REGISTER_NAMES \\\n+{ { \"FP\", 12}, {\"SP\", 13}, {\"RA\", 14}, {\"IRA\", 15} }\n+\n+/* Define this macro if you are using an unusual assembler that requires\n+   different names for the machine instructions.\n+\n+   The definition is a C statement or statements which output an assembler\n+   instruction opcode to the stdio stream STREAM.  The macro-operand PTR is a\n+   variable of type `char *' which points to the opcode name in its \"internal\"\n+   form--the form that is written in the machine description.  The definition\n+   should output the opcode name to STREAM, performing any translation you\n+   desire, and increment the variable PTR to point at the end of the opcode so\n+   that it will not be output twice.  */\n+#define ASM_OUTPUT_OPCODE(STREAM, PTR) \\\n+   (PTR) = ms1_asm_output_opcode (STREAM, PTR)\n+\n+#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS) \\\n+  ms1_final_prescan_insn (INSN, OPVEC, NOPERANDS)\n+\n+#define PRINT_OPERAND(STREAM, X, CODE) ms1_print_operand (STREAM, X, CODE)\n+\n+/* A C expression which evaluates to true if CODE is a valid punctuation\n+   character for use in the `PRINT_OPERAND' macro.  */\n+/* #:  Print nop for delay slot.  */\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '#')\n+\n+#define PRINT_OPERAND_ADDRESS(STREAM, X) ms1_print_operand_address (STREAM, X)\n+\n+/* If defined, C string expressions to be used for the `%R', `%L', `%U', and\n+   `%I' options of `asm_fprintf' (see `final.c').  These are useful when a\n+   single `md' file must support multiple assembler formats.  In that case, the\n+   various `tm.h' files can define these macros differently.\n+\n+   USER_LABEL_PREFIX is defined in svr4.h.  */\n+#define REGISTER_PREFIX     \"%\"\n+#define LOCAL_LABEL_PREFIX  \".\"\n+#define USER_LABEL_PREFIX   \"\"\n+#define IMMEDIATE_PREFIX    \"\"\n+\n+/* This macro should be provided on machines where the addresses in a dispatch\n+   table are relative to the table's own address.\n+\n+   The definition should be a C statement to output to the stdio stream STREAM\n+   an assembler pseudo-instruction to generate a difference between two labels.\n+   VALUE and REL are the numbers of two internal labels.  The definitions of\n+   these labels are output using `targetm.asm_out.internal_label', and they\n+   must be printed in the same way here.  */\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL) \\\n+fprintf (STREAM, \"\\t.word .L%d-.L%d\\n\", VALUE, REL)\n+\n+/* This macro should be provided on machines where the addresses in a dispatch\n+   table are absolute.\n+\n+   The definition should be a C statement to output to the stdio stream STREAM\n+   an assembler pseudo-instruction to generate a reference to a label.  VALUE\n+   is the number of an internal label whose definition is output using\n+   `targetm.asm_out.internal_label'.  */\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE) \\\n+fprintf (STREAM, \"\\t.word .L%d\\n\", VALUE)\n+\n+#define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (GPR_LINK)\n+\n+#define EH_RETURN_DATA_REGNO(N) \\\n+  ((N) == 0 ? GPR_R7 : (N) == 1 ? GPR_R8 : INVALID_REGNUM)\n+\n+#define EH_RETURN_STACKADJ_REGNO\tGPR_R11\n+#define EH_RETURN_STACKADJ_RTX\t\t\\\n+\tgen_rtx_REG (SImode, EH_RETURN_STACKADJ_REGNO)\n+#define EH_RETURN_HANDLER_REGNO\t\tGPR_R10\n+#define EH_RETURN_HANDLER_RTX\t\t\\\n+\tgen_rtx_REG (SImode, EH_RETURN_HANDLER_REGNO)\n+\f\n+#define ASM_OUTPUT_ALIGN(STREAM, POWER) \\\n+  fprintf ((STREAM), \"\\t.p2align %d\\n\", (POWER))\n+\n+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n+\n+#ifndef DWARF2_DEBUGGING_INFO\n+#define DWARF2_DEBUGGING_INFO\n+#endif\n+\n+/* Define this macro if GCC should produce dwarf version 2-style\n+   line numbers.  This usually requires extending the assembler to\n+   support them, and #defining DWARF2_LINE_MIN_INSN_LENGTH in the\n+   assembler configuration header files.  */\n+#define DWARF2_ASM_LINE_DEBUG_INFO 1\n+\n+/* An alias for a machine mode name.  This is the machine mode that\n+   elements of a jump-table should have.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define this macro if operations between registers with integral\n+   mode smaller than a word are always performed on the entire\n+   register.  Most RISC machines have this property and most CISC\n+   machines do not.  */\n+#define WORD_REGISTER_OPERATIONS\n+\n+/* The maximum number of bytes that a single instruction can move quickly from\n+   memory to memory.  */\n+#define MOVE_MAX 4\n+\n+/* A C expression which is nonzero if on this machine it is safe to \"convert\"\n+   an integer of INPREC bits to one of OUTPREC bits (where OUTPREC is smaller\n+   than INPREC) by merely operating on it as if it had only OUTPREC bits.\n+\n+   On many machines, this expression can be 1.\n+\n+   When `TRULY_NOOP_TRUNCATION' returns 1 for a pair of sizes for modes for\n+   which `MODES_TIEABLE_P' is 0, suboptimal code can result.  If this is the\n+   case, making `TRULY_NOOP_TRUNCATION' return 0 in such cases may improve\n+   things.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+#define Pmode SImode\n+\n+/* An alias for the machine mode used for memory references to functions being\n+   called, in `call' RTL expressions.  On most machines this should be\n+   `QImode'.  */\n+#define FUNCTION_MODE QImode\n+\n+#define HANDLE_SYSV_PRAGMA 1\n+\n+/* Indicate how many instructions can be issued at the same time.  */\n+#define ISSUE_RATE 1\n+\n+/* Define the information needed to generate branch and scc insns.  This is\n+   stored from the compare operation.  Note that we can't use \"rtx\" here\n+   since it hasn't been defined!  */\n+\n+extern struct rtx_def * ms1_compare_op0;\n+extern struct rtx_def * ms1_compare_op1;\n+"}, {"sha": "662a6ceb70b234ce3df7cad6bfe2f29e3b3fa357", "filename": "gcc/config/ms1/ms1.md", "status": "added", "additions": 1423, "deletions": 0, "changes": 1423, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig%2Fms1%2Fms1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig%2Fms1%2Fms1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fms1.md?ref=c85ba4fb34b8dc43ac29ddb7009863b2cb03565d", "patch": "@@ -0,0 +1,1423 @@\n+;; Machine description for MorphoRISC1\n+;; Copyright (C) 2005 Free Software Foundation, Inc.\n+;; Contributed by Red Hat, Inc.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+;; 02110-1301, USA.\n+\f\n+;; Attributes\n+(define_attr \"type\" \"branch,mem,io,arith,complex,unknown\"\n+\t (const_string \"unknown\") )\n+\n+;; If the attribute takes numeric values, no `enum' type will be defined and\n+;; the function to obtain the attribute's value will return `int'.\n+\n+(define_attr \"length\" \"\" (const_int 4))\n+\n+\f\n+;; DFA scheduler.\n+(define_automaton \"other\")\n+(define_cpu_unit \"decode_unit\" \"other\")\n+(define_cpu_unit \"memory_unit\" \"other\")\n+(define_cpu_unit \"branch_unit\" \"other\")\n+\n+(define_insn_reservation \"mem_access\" 2\n+  (eq_attr \"type\" \"mem\")\n+  \"decode_unit+memory_unit*2\")\n+\n+(define_insn_reservation \"io_access\" 2\n+  (eq_attr \"type\" \"io\")\n+  \"decode_unit+memory_unit*2\")\n+\n+(define_insn_reservation \"branch_access\" 2\n+  (eq_attr \"type\" \"branch\")\n+  \"decode_unit+branch_unit*2\")\n+\n+(define_insn_reservation \"arith_access\" 1\n+  (eq_attr \"type\" \"arith\")\n+  \"decode_unit\")\n+\n+(define_bypass 2 \"arith_access\" \"branch_access\")\n+(define_bypass 3 \"mem_access\" \"branch_access\")\n+(define_bypass 3 \"io_access\" \"branch_access\")\n+\n+\f\n+;; Delay Slots\n+\n+;; The ms1 does not allow branches in the delay slot.\n+;; The ms1 does not allow back to back memory or io instruction.\n+;; The compiler does not know what the type of instruction is at\n+;; the destination of the branch.  Thus, only type that will be acceptable\n+;; (safe) is the arith type.\n+\n+(define_delay (eq_attr \"type\" \"branch\")\n+\t\t [(eq_attr \"type\" \"arith\") (nil) (nil)])\n+\n+\f\n+;; Issue 64382\n+;; This pattern implements the decrement and branch non-zero instruction\n+;; which can be used by gcc loop optimizer under certain conditions.\n+;; For an example of it being used try compiling the gcc test case\n+;; gcc.c-torture/execute/921213-1.c with optimisations enabled.\n+\n+;; XXX - FIXME - TARGET_MUL is used as a condition since it is set when the\n+;; target is the MS1-16-003, which is the only Morpho CPU which currently\n+;; implements this instruction.  Stricly speaking we ought to define a\n+;; new command line switch to enable/disable the DBNZ instruction or else\n+;; change this pattern so that it explicitly checks for an MS1-16-003\n+;; architecture.\n+\n+(define_insn \"decrement_and_branch_until_zero\"\n+  [(parallel [(set (pc)\n+\t           (if_then_else\n+\t              (ne (match_operand:SI 0 \"register_operand\" \"+r\") (const_int 0))\n+\t              (label_ref (match_operand 1 \"\" \"\"))\n+\t              (pc)))\n+              (set (match_dup 0)\n+\t           (plus:SI (match_dup 0) (const_int -1)))\n+\t     ])\n+  ]\n+  \"TARGET_MUL\"\n+  \"dbnz\\t%0, %l1%#\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+;; This peephole is defined in the vain hope that it might actually trigger one\n+;; day, although I have yet to find a test case that matches it.  The normal\n+;; problem is that GCC likes to move the loading of the constant value -1 out\n+;; of the loop, so it is not here to be matched.\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_dup 0) (const_int -1)))\n+   (set (match_operand:SI 1 \"register_operand\" \"\")\n+\t(const_int -1))\n+   (set (pc) (if_then_else\n+\t        (ne (match_dup 0) (match_dup 1))\n+\t\t(label_ref (match_operand 2 \"\" \"\"))\n+\t\t(pc)))\n+   ]\n+  \"TARGET_MUL\"\n+  [(parallel [(set (pc)\n+\t           (if_then_else\n+\t              (ne (match_dup 0) (const_int 0))\n+\t              (label_ref (match_dup 2))\n+\t              (pc)))\n+              (set (match_dup 0)\n+\t           (plus:SI (match_dup 0) (const_int -1)))\n+\t     ])\n+  ]\n+  \"\"\n+)\n+\f\n+;; Moves\n+\n+(define_expand \"loadqi\"\n+  [\n+   ;; compute shift\n+   (set (match_operand:SI 2 \"register_operand\" \"\")\n+\t(and:SI (match_dup 1) (const_int 3)))\n+   (set (match_dup 2)\t(xor:SI (match_dup 2) (const_int 3)))\n+   (set (match_dup 2 )\t(ashift:SI (match_dup 2) (const_int 3)))\n+\n+   ;; get word that contains byte\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mem:SI (and:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t(const_int -3))))\n+\n+   ;; align byte\n+   (set (match_dup 0)   (ashiftrt:SI (match_dup 0) (match_dup 2)))\n+  ]\n+  \"\"\n+  \"\")\n+\n+\n+;; storeqi\n+;; operand 0 byte value to store\n+;; operand 1 address\n+;; operand 2 temp, word containing byte\n+;; operand 3 temp, shift count\n+;; operand 4 temp, mask, aligned and masked byte\n+;; operand 5 (unused)\n+(define_expand \"storeqi\"\n+  [\n+   ;; compute shift\n+   (set (match_operand:SI 3 \"register_operand\" \"\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"\") (const_int 3)))\n+   (set (match_dup 3)\t(xor:SI (match_dup 3) (const_int 3)))\n+   (set (match_dup 3)\t(ashift:SI (match_dup 3) (const_int 3)))\n+\n+   ;; get word that contains byte\n+   (set (match_operand:SI 2 \"register_operand\" \"\")\n+\t(mem:SI (and:SI (match_dup 1) (const_int -3))))\n+\n+   ;; generate mask\n+   (set (match_operand:SI 4 \"register_operand\" \"\") (const_int 255))\n+   (set (match_dup 4) (ashift:SI (match_dup 4) (match_dup 3)))\n+   (set (match_dup 4) (not:SI (match_dup 4)))\n+\n+   ;; clear appropriate bits\n+   (set (match_dup 2) (and:SI (match_dup 2) (match_dup 4)))\n+\n+   ;; align byte\n+   (set (match_dup 4)\n+\t(and:SI (match_operand:SI 0 \"register_operand\" \"\") (const_int 255)))\n+   (set (match_dup 4) (ashift:SI (match_dup 4) (match_dup 3)))\n+\n+   ;; combine\n+   (set (match_dup 2) (ior:SI (match_dup 4) (match_dup 2)))\n+   ;; store updated word\n+   (set (mem:SI (and:SI (match_dup 1) (const_int -3))) (match_dup 2))\n+  ]\n+  \"\"\n+  \"\")\n+\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (!reload_in_progress\n+      && !reload_completed\n+      && GET_CODE (operands[0]) == MEM\n+      && GET_CODE (operands[1]) == MEM)\n+    operands[1] = copy_to_mode_reg (QImode, operands[1]);\n+  \n+  if ( (! TARGET_BYTE_ACCESS) && GET_CODE (operands[0]) == MEM)\n+    {\n+\trtx scratch1 = gen_reg_rtx (SImode);\n+\trtx scratch2 = gen_reg_rtx (SImode);\n+\trtx scratch3 = gen_reg_rtx (SImode);\n+\trtx data     = operands[1];\n+\trtx address  = XEXP (operands[0], 0);\n+\trtx seq;\n+\n+\tif ( GET_CODE (data) != REG )\n+\t    data = copy_to_mode_reg (QImode, data);\n+\n+\tif ( GET_CODE (address) != REG )\n+\t  address = copy_to_mode_reg (SImode, address);\n+\n+\tstart_sequence ();\n+\temit_insn (gen_storeqi (gen_lowpart (SImode, data), address,\n+\t\t\t\tscratch1, scratch2, scratch3));\n+\tms1_set_memflags (operands[0]);\n+\tseq = get_insns ();\n+\tend_sequence ();\n+\temit_insn (seq);\n+\tDONE;\n+    }\n+\n+  if ( (! TARGET_BYTE_ACCESS) && GET_CODE (operands[1]) == MEM)\n+    {\n+\trtx scratch1 = gen_reg_rtx (SImode);\n+\trtx data = operands[0];\n+\trtx address = XEXP (operands[1], 0);\n+\trtx seq;\n+\n+\tif ( GET_CODE (address) != REG )\n+\t  address = copy_to_mode_reg (SImode, address);\n+\n+\tstart_sequence ();\n+\temit_insn (gen_loadqi (gen_lowpart (SImode, data), address, scratch1));\n+\tms1_set_memflags (operands[1]);\n+\tseq = get_insns ();\n+\tend_sequence ();\n+\temit_insn (seq);\n+\tDONE;\n+    }\n+\n+   /* If the load is a psuedo register in a stack slot, some simplification\n+      can be made because the loads are aligned */\n+  if ( (! TARGET_BYTE_ACCESS) \n+        && (reload_in_progress && GET_CODE (operands[1]) == SUBREG\n+\t  && GET_CODE (SUBREG_REG (operands[1])) == REG\n+\t  && REGNO (SUBREG_REG (operands[1])) >= FIRST_PSEUDO_REGISTER))\n+    {\n+\trtx data = operands[0];\n+\trtx address = XEXP (operands[1], 0);\n+\trtx seq;\n+\n+\tstart_sequence ();\n+\temit_insn (gen_movsi (gen_lowpart (SImode, data), address));\n+\tms1_set_memflags (operands[1]);\n+\tseq = get_insns ();\n+\tend_sequence ();\n+\temit_insn (seq);\n+\tDONE;\n+    }\n+}\")\n+\n+(define_insn \"*movqi_internal\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,m,r\")\n+\t(match_operand:QI 1 \"general_operand\" \"r,m,r,I\"))]\n+  \"TARGET_BYTE_ACCESS\n+    && (!memory_operand (operands[0], QImode)\n+        || !memory_operand (operands[1], QImode))\"\n+  \"@\n+   or  %0, %1, %1\n+   ldb %0, %1\n+   stb %1, %0\n+   addi %0, r0, %1\"\n+  [(set_attr \"length\" \"4,4,4,4\")\n+   (set_attr \"type\" \"arith,mem,mem,arith\")])\n+\n+(define_insn \"*movqi_internal_nobyte\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n+\t(match_operand:QI 1 \"arith_operand\" \"r,I\"))]\n+  \"!TARGET_BYTE_ACCESS\n+    && (!memory_operand (operands[0], QImode)\n+        || !memory_operand (operands[1], QImode))\"\n+  \"@\n+   or   %0, %1, %1\n+   addi %0, r0, %1\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"type\" \"arith,arith\")])\n+\n+\n+;; The MorphoRISC does not have 16-bit loads and stores.\n+;; These operations must be synthesized.  Note that the code\n+;; for loadhi and storehi assumes that the least significant bits\n+;; is ignored.\n+\n+;; loadhi\n+;; operand 0 location of result\n+;; operand 1 memory address\n+;; operand 2 temp\n+(define_expand \"loadhi\"\n+  [\n+   ;; compute shift\n+   (set (match_operand:SI 2 \"register_operand\" \"\")\n+\t(and:SI (match_dup 1) (const_int 2)))\n+   (set (match_dup 2)\t(xor:SI (match_dup 2) (const_int 2)))\n+   (set (match_dup 2 )\t(ashift:SI (match_dup 2) (const_int 3)))\n+\n+   ;; get word that contains the 16-bits\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mem:SI (and:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t(const_int -3))))\n+\n+   ;; align 16-bit value\n+   (set (match_dup 0)\t(ashiftrt:SI (match_dup 0) (match_dup 2)))\n+  ]\n+  \"\"\n+  \"\")\n+\n+;; storehi\n+;; operand 0 byte value to store\n+;; operand 1 address\n+;; operand 2 temp, word containing byte\n+;; operand 3 temp, shift count\n+;; operand 4 temp, mask, aligned and masked byte\n+;; operand 5 (unused)\n+(define_expand \"storehi\"\n+  [\n+   ;; compute shift\n+   (set (match_operand:SI 3 \"register_operand\" \"\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"\") (const_int 2)))\n+   (set (match_dup 3)\t(xor:SI (match_dup 3) (const_int 2)))\n+   (set (match_dup 3)\t(ashift:SI (match_dup 3) (const_int 3)))\n+\n+   ;; get word that contains the 16-bits\n+   (set (match_operand:SI 2 \"register_operand\" \"\")\n+\t(mem:SI (and:SI (match_dup 1) (const_int -3))))\n+\n+   ;; generate mask\n+   (set (match_operand:SI 4 \"register_operand\" \"\") (const_int 65535))\n+   (set (match_dup 4) (ashift:SI (match_dup 4) (match_dup 3)))\n+   (set (match_dup 4) (not:SI (match_dup 4)))\n+\n+   ;; clear appropriate bits\n+   (set (match_dup 2) (and:SI (match_dup 2) (match_dup 4)))\n+\n+   ;; align 16-bit value\n+   (set (match_dup 4)\n+\t(and:SI (match_operand:SI 0 \"register_operand\" \"\") (const_int 65535)))\n+   (set (match_dup 4) (ashift:SI (match_dup 4) (match_dup 3)))\n+\n+   ;; combine\n+   (set (match_dup 2) (ior:SI (match_dup 4) (match_dup 2)))\n+   ;; store updated word\n+   (set (mem:SI (and:SI (match_dup 1) (const_int -3))) (match_dup 2))\n+  ]\n+  \"\"\n+  \"\")\n+\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (!reload_in_progress\n+      && !reload_completed\n+      && GET_CODE (operands[0]) == MEM\n+      && GET_CODE (operands[1]) == MEM)\n+    operands[1] = copy_to_mode_reg (HImode, operands[1]);\n+\n+  if ( GET_CODE (operands[0]) == MEM)\n+    {\n+\trtx scratch1 = gen_reg_rtx (SImode);\n+\trtx scratch2 = gen_reg_rtx (SImode);\n+\trtx scratch3 = gen_reg_rtx (SImode);\n+\trtx data     = operands[1];\n+\trtx address  = XEXP (operands[0], 0);\n+\trtx seq;\n+\n+\tif (GET_CODE (data) != REG)\n+\t  data = copy_to_mode_reg (HImode, data);\n+\n+\tif (GET_CODE (address) != REG)\n+\t  address = copy_to_mode_reg (SImode, address);\n+\n+\tstart_sequence ();\n+\temit_insn (gen_storehi (gen_lowpart (SImode, data), address,\n+\t\t\t        scratch1, scratch2, scratch3));\n+\tms1_set_memflags (operands[0]);\n+\tseq = get_insns ();\n+\tend_sequence ();\n+\temit_insn (seq);\n+\tDONE;\n+    }\n+\n+  if ( GET_CODE (operands[1]) == MEM)\n+    {\n+\trtx scratch1 = gen_reg_rtx (SImode);\n+\trtx data     = operands[0];\n+\trtx address  = XEXP (operands[1], 0);\n+\trtx seq;\n+\n+\tif (GET_CODE (address) != REG)\n+\t    address = copy_to_mode_reg (SImode, address);\n+\n+\tstart_sequence ();\n+\temit_insn (gen_loadhi (gen_lowpart (SImode, data), address,\n+\t\t\t       scratch1));\n+\tms1_set_memflags (operands[1]);\n+\tseq = get_insns ();\n+\tend_sequence ();\n+\temit_insn (seq);\n+\tDONE;\n+    }\n+\n+   /* If the load is a psuedo register in a stack slot, some simplification\n+      can be made because the loads are aligned */\n+  if ( (reload_in_progress && GET_CODE (operands[1]) == SUBREG\n+\t  && GET_CODE (SUBREG_REG (operands[1])) == REG\n+\t  && REGNO (SUBREG_REG (operands[1])) >= FIRST_PSEUDO_REGISTER))\n+    {\n+\trtx data = operands[0];\n+\trtx address = XEXP (operands[1], 0);\n+\trtx seq;\n+\n+\tstart_sequence ();\n+\temit_insn (gen_movsi (gen_lowpart (SImode, data), address));\n+\tms1_set_memflags (operands[1]);\n+\tseq = get_insns ();\n+\tend_sequence ();\n+\temit_insn (seq);\n+\tDONE;\n+    }\n+}\")\n+\n+(define_insn \"*movhi_internal\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(match_operand:HI 1 \"arith_operand\" \"r,I\"))]\n+  \"!memory_operand (operands[0], HImode) || !memory_operand (operands[1], HImode)\"\n+  \"@\n+  or    %0, %1, %1\n+  addi  %0, r0, %1\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"type\" \"arith,arith\")])\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (!reload_in_progress  && !reload_completed\n+      && !register_operand (operands[0], SImode)\n+      && !register_operand (operands[1], SImode))\n+    operands[1] = copy_to_mode_reg (SImode, operands[1]);\n+\n+  /* Take care of constants that don't fit in single instruction */\n+  if ( (reload_in_progress || reload_completed)\n+   && !single_const_operand (operands[1], SImode))\n+    {\n+      emit_insn (gen_movsi_high (operands[0], operands[1]));\n+      emit_insn (gen_movsi_lo_sum (operands[0], operands[0], operands[1]));\n+      DONE;\n+    }\n+\n+}\")\n+\n+(define_insn \"movsi_high\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (high:SI (match_operand:SI 1 \"general_operand\" \"i\")))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"ldui\\\\t%0, %H1\\\";\n+}\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"arith\")])\n+\n+\n+(define_insn \"movsi_lo_sum\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+                   (match_operand:SI 2 \"general_operand\" \"i\")))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"addui\\\\t%0, %1, %L2\\\";\n+}\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"arith\")])\n+\n+/* Take care of constants that don't fit in single instruction */\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"(reload_in_progress || reload_completed)\n+   && !single_const_operand (operands[1], SImode)\"\n+\n+  [(set (match_dup 0 )\n+        (high:SI (match_dup 1)))\n+   (set (match_dup 0 )\n+        (lo_sum:SI (match_dup 0)\n+                   (match_dup 1)))]\n+)\n+\n+\n+;; The last pattern in movsi (with two instructions)\n+;; is really handled by the emit_insn's in movsi\n+;; and the define_split above.  This provides additional\n+;; instructions to fill delay slots.\n+\n+;; Note - it is best to only have one movsi pattern and to handle\n+;; all the various contingencies by the use of alternatives.  This\n+;; allows reload the greatest amount of flexability (since reload will\n+;; only choose amoungst alternatives for a selected insn, it will not\n+;; replace the insn with another one).\n+(define_insn \"*movsi_internal\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r,r,r\")\n+\t(match_operand:SI 1 \"general_operand\"       \"r,m,r,I,P,L,N,i\"))]\n+  \"(!memory_operand (operands[0], SImode) || !memory_operand (operands[1], SImode))\n+   && !((reload_in_progress || reload_completed)\n+\t && !single_const_operand (operands[1], SImode))\"\n+  \"@\n+  or     %0, %1, %1\n+  ldw    %0, %1\n+  stw    %1, %0\n+  addi   %0, r0, %1\n+  addui  %0, r0, %1\n+  ldui   %0, %H1\n+  nori   %0, r0, %N1\n+  ldui   %0, %H1\\;addui %0, %0, %L1\"\n+  [(set_attr \"length\" \"4,4,4,4,4,4,4,8\")\n+   (set_attr \"type\" \"arith,mem,mem,arith,arith,arith,arith,complex\")]\n+)\n+\n+;; Floating Point Moves\n+;;\n+;; Note - Patterns for SF mode moves are compulsory, but\n+;; patterns for DF are optional, as GCC can synthesize them.\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (!reload_in_progress\n+      && !reload_completed\n+      && GET_CODE (operands[0]) == MEM\n+      && (GET_CODE (operands[1]) == MEM\n+         || GET_CODE (operands[1]) == CONST_DOUBLE))\n+    operands[1] = copy_to_mode_reg (SFmode, operands[1]);\n+\n+  /* Take care of reg <- SF constant */\n+  if ( const_double_operand (operands[1], GET_MODE (operands[1]) ) )\n+    {\n+      emit_insn (gen_movsf_high (operands[0], operands[1]));\n+      emit_insn (gen_movsf_lo_sum (operands[0], operands[0], operands[1]));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"movsf_lo_sum\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+        (lo_sum:SF (match_operand:SF 1 \"register_operand\" \"r\")\n+                   (match_operand:SF 2 \"const_double_operand\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  REAL_VALUE_TYPE r;\n+  long i;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[2]);\n+  REAL_VALUE_TO_TARGET_SINGLE (r, i);\n+  operands[2] = GEN_INT (i);\n+  return \\\"addui\\\\t%0, %1, %L2\\\";\n+}\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"arith\")])\n+\n+(define_insn \"movsf_high\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+        (high:SF (match_operand:SF 1 \"const_double_operand\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  REAL_VALUE_TYPE r;\n+  long i;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+  REAL_VALUE_TO_TARGET_SINGLE (r, i);\n+  operands[1] = GEN_INT (i);\n+  return \\\"ldui\\\\t%0, %H1\\\";\n+}\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"arith\")])\n+\n+\n+(define_insn \"*movsf_internal\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,m\")\n+\t(match_operand:SF 1 \"nonimmediate_operand\" \"r,m,r\"))]\n+  \"!memory_operand (operands[0], SFmode) || !memory_operand (operands[1], SFmode)\"\n+  \"@\n+  or     %0, %1, %1\n+  ldw    %0, %1\n+  stw    %1, %0\"\n+  [(set_attr \"length\" \"4,4,4\")\n+   (set_attr \"type\" \"arith,mem,mem\")]\n+)\n+\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register or 0 */\n+  if (!register_operand (operand0, DFmode)\n+      && !reg_or_0_operand (operand1, DFmode))\n+    operands[1] = copy_to_mode_reg (DFmode, operand1);\n+}\")\n+\n+(define_insn_and_split \"*movdf_internal\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,o\")\n+\t(match_operand:DF 1 \"general_operand\" \t   \"rim,r\"))]\n+  \"! (memory_operand (operands[0], DFmode)\n+         && memory_operand (operands[1], DFmode))\"\n+  \"#\"\n+\n+  \"(reload_completed || reload_in_progress)\"\n+\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))\n+  ]\n+\n+  \"{\n+    /* figure out what precisely to put into operands 2, 3, 4, and 5 */\n+    ms1_split_words (SImode, DFmode, operands);\n+  }\"\n+)\n+\n+\f\n+;; Reloads\n+\n+;; Like `movM', but used when a scratch register is required to move between\n+;; operand 0 and operand 1.  Operand 2 describes the scratch register.  See the\n+;; discussion of the `SECONDARY_RELOAD_CLASS' macro.\n+\n+(define_expand \"reload_inqi\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+        (match_operand:QI 1 \"memory_operand\" \"m\"))\n+   (clobber (match_operand:DI 2 \"register_operand\" \"=&r\"))]\n+  \"! TARGET_BYTE_ACCESS\"\n+  \"\n+{\n+  rtx scratch1 = gen_rtx_REG (SImode, REGNO (operands[2]));\n+  rtx scratch2 = gen_rtx_REG (SImode, REGNO (operands[2])+1);\n+  rtx data = operands[0];\n+  rtx address = XEXP (operands[1], 0);\n+  rtx swap, seq;\n+\n+  /* It is possible that the registers we got for scratch1\n+     might coincide with that of operands[0].  gen_loadqi\n+     requires operand0 and operand2 to be different registers.\n+     The following statement ensure that is always the case. */\n+  if (REGNO(operands[0]) == REGNO(scratch1))\n+    {\n+\tswap = scratch1;\n+\tscratch1 = scratch2;\n+\tscratch2 = swap;\n+    }\n+\n+  /* need to make sure address is already in register */\n+  if ( GET_CODE (address) != REG )\n+    address = force_operand (address, scratch2);\n+\n+  start_sequence ();\n+  emit_insn (gen_loadqi (gen_lowpart (SImode, data), address, scratch1));\n+  ms1_set_memflags (operands[1]);\n+  seq = get_insns ();\n+  end_sequence ();\n+  emit_insn (seq);\n+  DONE;\n+}\")\n+\n+(define_expand \"reload_outqi\"\n+  [(set (match_operand:QI 0 \"memory_operand\" \"=m\")\n+        (match_operand:QI 1 \"register_operand\" \"r\"))\n+   (clobber (match_operand:TI 2 \"register_operand\" \"=&r\"))]\n+  \"! TARGET_BYTE_ACCESS\"\n+  \"\n+{\n+  rtx scratch1 = gen_rtx_REG (SImode, REGNO (operands[2]));\n+  rtx scratch2 = gen_rtx_REG (SImode, REGNO (operands[2])+1);\n+  rtx scratch3 = gen_rtx_REG (SImode, REGNO (operands[2])+2);\n+  rtx scratch4 = gen_rtx_REG (SImode, REGNO (operands[2])+3);\n+  rtx data     = operands[1];\n+  rtx address  = XEXP (operands[0], 0);\n+  rtx seq;\n+\n+  /* need to make sure address is already in register */\n+  if ( GET_CODE (address) != REG )\n+    address = force_operand (address, scratch4);\n+\n+  start_sequence ();\n+  emit_insn (gen_storeqi (gen_lowpart (SImode, data), address, \n+\t\t\t  scratch1, scratch2, scratch3));\n+  ms1_set_memflags (operands[0]);\n+  seq = get_insns ();\n+  end_sequence ();\n+  emit_insn (seq);\n+  DONE;\n+}\")\n+\n+(define_expand \"reload_inhi\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (match_operand:HI 1 \"memory_operand\" \"m\"))\n+   (clobber (match_operand:DI 2 \"register_operand\" \"=&r\"))]\n+  \"\"\n+  \"\n+{\n+  rtx scratch1 = gen_rtx_REG (SImode, REGNO (operands[2]));\n+  rtx scratch2 = gen_rtx_REG (SImode, REGNO (operands[2])+1);\n+  rtx data     = operands[0];\n+  rtx address  = XEXP (operands[1], 0);\n+  rtx swap, seq;\n+\n+  /* It is possible that the registers we got for scratch1\n+     might coincide with that of operands[0].  gen_loadqi\n+     requires operand0 and operand2 to be different registers.\n+     The following statement ensure that is always the case. */\n+  if (REGNO(operands[0]) == REGNO(scratch1))\n+    {\n+\tswap = scratch1;\n+\tscratch1 = scratch2;\n+\tscratch2 = swap;\n+    }\n+\n+  /* need to make sure address is already in register */\n+  if ( GET_CODE (address) != REG )\n+    address = force_operand (address, scratch2);\n+\n+  start_sequence ();\n+  emit_insn (gen_loadhi (gen_lowpart (SImode, data), address,\n+\t\t         scratch1));\n+  ms1_set_memflags (operands[1]);\n+  seq = get_insns ();\n+  end_sequence ();\n+  emit_insn (seq);\n+  DONE;\n+}\")\n+\n+(define_expand \"reload_outhi\"\n+  [(set (match_operand:HI 0 \"memory_operand\" \"=m\")\n+        (match_operand:HI 1 \"register_operand\" \"r\"))\n+   (clobber (match_operand:TI 2 \"register_operand\" \"=&r\"))]\n+  \"\"\n+  \"\n+{\n+  rtx scratch1 = gen_rtx_REG (SImode, REGNO (operands[2]));\n+  rtx scratch2 = gen_rtx_REG (SImode, REGNO (operands[2])+1);\n+  rtx scratch3 = gen_rtx_REG (SImode, REGNO (operands[2])+2);\n+  rtx scratch4 = gen_rtx_REG (SImode, REGNO (operands[2])+3);\n+  rtx data     = operands[1];\n+  rtx address  = XEXP (operands[0], 0);\n+  rtx seq;\n+\n+  /* need to make sure address is already in register */\n+  if ( GET_CODE (address) != REG )\n+    address = force_operand (address, scratch4);\n+\n+  start_sequence ();\n+  emit_insn (gen_storehi (gen_lowpart (SImode, data), address,\n+\t\t          scratch1, scratch2, scratch3));\n+  ms1_set_memflags (operands[0]);\n+  seq = get_insns ();\n+  end_sequence ();\n+  emit_insn (seq);\n+  DONE;\n+}\")\n+\n+\f\n+;; 32 bit Integer arithmetic\n+\n+;; Addition\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%r,r\")\n+\t\t (match_operand:SI 2 \"arith_operand\" \"r,I\")))]\n+  \"\"\n+  \"@\n+  add %0, %1, %2\n+  addi %0, %1, %2\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"type\" \"arith,arith\")])\n+\n+;; Subtraction\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rJ,rJ\")\n+\t\t  (match_operand:SI 2 \"arith_operand\" \"rJ,I\")))]\n+  \"\"\n+  \"@\n+  sub %0, %z1, %z2\n+  subi %0, %z1, %2\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"type\" \"arith,arith\")])\n+\n+;;  Negation \n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(neg:SI (match_operand:SI 1 \"arith_operand\" \"r,I\")))]\n+  \"\"\n+  \"@\n+  sub  %0, r0, %1\n+  subi  %0, r0, %1\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"type\" \"arith,arith\")])\n+\n+\f\n+;; 32 bit Integer Shifts and Rotates\n+\n+;; Arithmetic Shift Left\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t   (match_operand:SI 2 \"arith_operand\" \"r,K\")))]\n+  \"\"\n+  \"@\n+  lsl %0, %1, %2\n+  lsli %0, %1, %2\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"type\" \"arith,arith\")])\n+\n+;; Arithmetic Shift Right\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t     (match_operand:SI 2 \"uns_arith_operand\" \"r,K\")))]\n+  \"\"\n+  \"@\n+  asr %0, %1, %2\n+  asri %0, %1, %2\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"type\" \"arith,arith\")])\n+\n+;; Logical Shift Right\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t     (match_operand:SI 2 \"uns_arith_operand\" \"r,K\")))]\n+  \"\"\n+  \"@\n+  lsr %0, %1, %2\n+  lsri %0, %1, %2\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"type\" \"arith,arith\")])\n+\n+\f\n+;; 32 Bit Integer Logical operations\n+\n+;; Logical AND, 32 bit integers\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%r,r\")\n+\t\t(match_operand:SI 2 \"uns_arith_operand\" \"r,K\")))]\n+  \"\"\n+  \"@\n+  and %0, %1, %2\n+  andi %0, %1, %2\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"type\" \"arith,arith\")])\n+\n+;; Inclusive OR, 32 bit integers\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%r,r\")\n+\t\t(match_operand:SI 2 \"uns_arith_operand\" \"r,K\")))]\n+  \"\"\n+  \"@\n+  or %0, %1, %2\n+  ori %0, %1, %2\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"type\" \"arith,arith\")])\n+\n+;; Exclusive OR, 32 bit integers\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%r,r\")\n+\t\t(match_operand:SI 2 \"uns_arith_operand\" \"r,K\")))]\n+  \"\"\n+  \"@\n+  xor %0, %1, %2\n+  xori %0, %1, %2\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"type\" \"arith,arith\")])\n+\n+\n+;; One's complement, 32 bit integers\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"nor %0, %1, %1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"arith\")])\n+\n+\f\n+;; Multiply\n+\n+(define_insn \"mulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+     (mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"%r,r\"))\n+     \t      (sign_extend:SI (match_operand:HI 2 \"arith_operand\" \"r,I\"))))]\n+  \"TARGET_MUL\"\n+  \"@\n+  mul %0, %1, %2\n+  muli %0, %1, %2\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"type\" \"arith,arith\")])\n+\n+\f\n+;; Comparisons\n+\n+;; Note, we store the operands in the comparison insns, and use them later\n+;; when generating the branch or scc operation.\n+\n+;; First the routines called by the machine independent part of the compiler\n+(define_expand \"cmpsi\"\n+  [(set (cc0)\n+        (compare (match_operand:SI 0 \"register_operand\" \"\")\n+  \t\t (match_operand:SI 1 \"arith_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  ms1_compare_op0 = operands[0];\n+  ms1_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+\f\n+;; Branches\n+\n+(define_expand \"beq\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"\n+{  ms1_emit_cbranch (EQ, operands[0],\n+\tms1_compare_op0, ms1_compare_op1);\n+  DONE;\n+}\")\n+\n+(define_expand \"bne\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"\n+{  ms1_emit_cbranch (NE, operands[0],\n+\tms1_compare_op0, ms1_compare_op1);\n+  DONE;\n+}\")\n+\n+(define_expand \"bge\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"\n+{  ms1_emit_cbranch (GE, operands[0],\n+\tms1_compare_op0, ms1_compare_op1);\n+  DONE;\n+}\")\n+\n+(define_expand \"bgt\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"\n+{  ms1_emit_cbranch (GT, operands[0],\n+\tms1_compare_op0, ms1_compare_op1);\n+  DONE;\n+}\")\n+\n+(define_expand \"ble\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"\n+{  ms1_emit_cbranch (LE, operands[0],\n+\tms1_compare_op0, ms1_compare_op1);\n+  DONE;\n+}\")\n+\n+(define_expand \"blt\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"\n+{  ms1_emit_cbranch (LT, operands[0],\n+\tms1_compare_op0, ms1_compare_op1);\n+  DONE;\n+}\")\n+\n+(define_expand \"bgeu\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"\n+{  ms1_emit_cbranch (GEU, operands[0],\n+\tms1_compare_op0, ms1_compare_op1);\n+  DONE;\n+}\")\n+\n+(define_expand \"bgtu\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"\n+{  ms1_emit_cbranch (GTU, operands[0],\n+\tms1_compare_op0, ms1_compare_op1);\n+  DONE;\n+}\")\n+\n+(define_expand \"bleu\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"\n+{  ms1_emit_cbranch (LEU, operands[0],\n+\tms1_compare_op0, ms1_compare_op1);\n+  DONE;\n+}\")\n+\n+(define_expand \"bltu\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"\n+{  ms1_emit_cbranch (LTU, operands[0],\n+\tms1_compare_op0, ms1_compare_op1);\n+  DONE;\n+}\")\n+\n+(define_expand \"bunge\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"\n+{  ms1_emit_cbranch (GEU, operands[0],\n+\tms1_compare_op0, ms1_compare_op1);\n+  DONE;\n+}\")\n+\n+(define_expand \"bungt\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  ms1_emit_cbranch (GTU, operands[0],\n+\tms1_compare_op0, ms1_compare_op1);\n+  DONE;\n+}\")\n+\n+(define_expand \"bunle\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  ms1_emit_cbranch (LEU, operands[0],\n+\tms1_compare_op0, ms1_compare_op1);\n+  DONE;\n+}\")\n+\n+(define_expand \"bunlt\"\n+  [(use (match_operand 0 \"\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  ms1_emit_cbranch (LTU, operands[0],\n+\tms1_compare_op0, ms1_compare_op1);\n+  DONE;\n+}\")\n+\n+(define_insn \"*beq_true\"\n+  [(set (pc)\n+\t(if_then_else (eq (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"breq %z0, %z1, %l2%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+(define_insn \"*beq_false\"\n+  [(set (pc)\n+\t(if_then_else (eq (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"brne %z0, %z1, %l2%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+\n+(define_insn \"*bne_true\"\n+  [(set (pc)\n+\t(if_then_else (ne (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"brne %z0, %z1, %l2%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+(define_insn \"*bne_false\"\n+  [(set (pc)\n+\t(if_then_else (ne (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"breq %z0, %z1, %l2%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+(define_insn \"*blt_true\"\n+  [(set (pc)\n+\t(if_then_else (lt (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"brlt %z0, %z1, %l2%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+(define_insn \"*blt_false\"\n+  [(set (pc)\n+\t(if_then_else (lt (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"brle %z1, %z0,%l2%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+(define_insn \"*ble_true\"\n+  [(set (pc)\n+\t(if_then_else (le (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"brle %z0, %z1, %l2%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+(define_insn \"*ble_false\"\n+  [(set (pc)\n+\t(if_then_else (le (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"brlt %z1, %z0,%l2%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+(define_insn \"*bgt_true\"\n+  [(set (pc)\n+\t(if_then_else (gt (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"brlt %z1, %z0, %l2%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+(define_insn \"*bgt_false\"\n+  [(set (pc)\n+\t(if_then_else (gt (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"brle %z0, %z1, %l2%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+(define_insn \"*bge_true\"\n+  [(set (pc)\n+\t(if_then_else (ge (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"brle %z1, %z0,%l2%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+(define_insn \"*bge_false\"\n+  [(set (pc)\n+\t(if_then_else (ge (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"brlt %z0, %z1, %l2%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+;; No unsigned operators on Morpho ms1.  All the unsigned operations are\n+;; converted to the signed operations above.\n+\n+\f\n+;; Set flag operations\n+\n+;; \"seq\", \"sne\", \"slt\", \"sle\", \"sgt\", \"sge\", \"sltu\", \"sleu\",\n+;; \"sgtu\", and \"sgeu\" don't exist as regular instruction on the\n+;; ms1, so these are not defined\n+\n+;; Call and branch instructions\n+\n+(define_expand \"call\"\n+  [(parallel [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"\"))\n+\t\t\t    (match_operand 1 \"\" \"\"))\n+\t      (clobber (reg:SI 14))])]\n+  \"\"\n+  \"\n+{\n+    operands[0] = force_reg (SImode, XEXP (operands[0], 0));\n+}\")\n+\n+(define_insn \"call_internal\"\n+  [(call (mem:SI (match_operand 0 \"register_operand\" \"r\"))\n+\t (match_operand 1 \"\" \"\"))\n+   ;; possibly add a clobber of the reg that gets the return address\n+   (clobber (reg:SI 14))]\n+  \"\"\n+  \"jal r14, %0%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+(define_expand \"call_value\"\n+  [(parallel [(set (match_operand 0 \"register_operand\" \"\")\n+\t\t   (call (mem:SI (match_operand:SI 1 \"register_operand\" \"\"))\n+\t\t\t\t (match_operand 2 \"general_operand\" \"\")))\n+\t      (clobber (reg:SI 14))])]\n+  \"\"\n+  \"\n+{\n+    operands[1] = force_reg (SImode, XEXP (operands[1], 0));\n+}\")\n+\n+\n+(define_insn \"call_value_internal\"\n+  [(set (match_operand 0 \"register_operand\" \"=r\")\n+\t(call (mem:SI (match_operand 1 \"register_operand\" \"r\"))\n+\t      (match_operand 2 \"\" \"\")))\n+\t;; possibly add a clobber of the reg that gets the return address\n+\t(clobber (reg:SI 14))]\n+  \"\"\n+  \"jal r14, %1%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+;; Subroutine return\n+(define_insn \"return_internal\"\n+  [(const_int 2)\n+   (return)\n+   (use (reg:SI 14))]\n+  \"\"\n+  \"jal r0, r14%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+;; Interrupt return\n+(define_insn \"return_interrupt_internal\"\n+  [(const_int 3)\n+   (return)\n+   (use (reg:SI 15))]\n+  \"\"\n+  \"reti r15%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+;; Subroutine return\n+(define_insn \"eh_return_internal\"\n+  [(return)\n+   (use (reg:SI 7))\n+   (use (reg:SI 8))\n+   (use (reg:SI 11))\n+   (use (reg:SI 10))]\n+  \"\"\n+  \"jal r0, r11%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+\n+;; Normal unconditional jump\n+(define_insn \"jump\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"jmp %l0%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+;; Indirect jump through a register\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"jal r0,%0%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+(define_insn \"tablejump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"jal r0, %0%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+\f\n+(define_expand \"prologue\"\n+  [(const_int 1)]\n+  \"\"\n+  \"\n+{\n+  ms1_expand_prologue ();\n+  DONE;\n+}\")\n+\n+(define_expand \"epilogue\"\n+  [(const_int 2)]\n+  \"\"\n+  \"\n+{\n+  ms1_expand_epilogue (NORMAL_EPILOGUE);\n+  DONE;\n+}\")\n+\n+\n+(define_expand \"eh_return\"\n+  [(use (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"\n+{\n+  ms1_expand_eh_return (operands);\n+  DONE;\n+}\")\n+\n+\n+(define_insn_and_split \"eh_epilogue\"\n+  [(unspec [(match_operand 0 \"register_operand\" \"r\")] 6)]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 1)]\n+  \"ms1_emit_eh_epilogue (operands); DONE;\"\n+)\n+\f\n+;; No operation, needed in case the user uses -g but not -O.\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"or\tr0,r0,r0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"arith\")])\n+\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: UNSPEC_VOLATILE usage\n+;; ::\n+;; ::::::::::::::::::::\n+;; \n+;;\t0\tblockage\n+;;\t1\tEnable interrupts\n+;;\t2\tDisable interrupts\n+;;\n+\n+;; Pseudo instruction that prevents the scheduler from moving code above this\n+;; point.\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"length\" \"0\")])\n+\n+;; Trap instruction to allow usage of the __builtin_trap function\n+(define_insn \"trap\"\n+  [(trap_if (const_int 1) (const_int 0))\n+   (clobber (reg:SI 14))]\n+  \"\"\n+  \"si\tr14%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+(define_expand \"conditional_trap\"\n+  [(trap_if (match_operator 0 \"comparison_operator\"\n+\t\t\t    [(match_dup 2)\n+\t\t\t     (match_dup 3)])\n+\t    (match_operand 1 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  operands[2] = ms1_compare_op0;\n+  operands[3] = ms1_compare_op1;\n+}\")\n+\n+;; Templates to control handling of interrupts\n+\n+;; Enable interrupts template\n+(define_insn \"ei\"\n+  [(unspec_volatile [(const_int 0)] 1)]\n+  \"\"\n+  \"ei\"\n+  [(set_attr \"length\" \"4\")])\n+\n+;; Enable interrupts template\n+(define_insn \"di\"\n+  [(unspec_volatile [(const_int 0)] 2)]\n+  \"\"\n+  \"di\"\n+  [(set_attr \"length\" \"4\")])"}, {"sha": "44baad37ef2e284645b57a266e9c297302ddccd6", "filename": "gcc/config/ms1/ms1.opt", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig%2Fms1%2Fms1.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig%2Fms1%2Fms1.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fms1.opt?ref=c85ba4fb34b8dc43ac29ddb7009863b2cb03565d", "patch": "@@ -0,0 +1,60 @@\n+; Options for the ms1 port of the compiler\n+;\n+; Copyright (C) 2005 Free Software Foundation, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 2, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT\n+; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+; License for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING.  If not, write to the Free\n+; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+; 02110-1301, USA.\n+\n+mmul\n+Target Report Mask(MUL)\n+Generate multiply instructions\n+\n+mbacc\n+Target Report Mask(BYTE_ACCESS)\n+Use byte loads and stores when generating code.\n+\n+msim\n+Target RejectNegative\n+Use simulator runtime\n+\n+mno-crt0\n+Target RejectNegative\n+Do not include crt0.o in the startup files\n+\n+mdebug-arg\n+Target RejectNegative Mask(DEBUG_ARG)\n+Internal debug switch\n+\n+mdebug-addr\n+Target RejectNegative Mask(DEBUG_ADDR)\n+Internal debug switch\n+\n+mdebug-stack\n+Target RejectNegative Mask(DEBUG_STACK)\n+Internal debug switch\n+\n+mdebug-loc\n+Target RejectNegative Mask(DEBUG_LOC)\n+Internal debug switch\n+\n+mdebug\n+Target RejectNegative Mask(DEBUG)\n+Internal debug switch\n+\n+march=\n+Target RejectNegative Joined Var(ms1_cpu_string)\n+Specify CPU for code generation purposes"}, {"sha": "d9aa314ba46b3da09b5b9ea75ce41c1fbd2a26ba", "filename": "gcc/config/ms1/t-ms1", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig%2Fms1%2Ft-ms1", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fconfig%2Fms1%2Ft-ms1", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Ft-ms1?ref=c85ba4fb34b8dc43ac29ddb7009863b2cb03565d", "patch": "@@ -0,0 +1,70 @@\n+#  Copyright (C) 2005 Free Software Foundation, Inc.\n+#\n+#   This file is part of GCC.\n+#\n+#   GCC is free software; you can redistribute it and/or modify it\n+#   under the terms of the GNU General Public License as published\n+#   by the Free Software Foundation; either version 2, or (at your\n+#   option) any later version.\n+#\n+#   GCC is distributed in the hope that it will be useful, but WITHOUT\n+#   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+#   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+#   License for more details.\n+#\n+#   You should have received a copy of the GNU General Public License\n+#   along with GCC; see the file COPYING.  If not, write to the Free\n+#   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+#   02110-1301, USA.\n+\n+# Name of assembly file containing libgcc1 functions.\n+# This entry must be present, but it can be empty if the target does\n+# not need any assembler functions to support its code generation.\n+CROSS_LIBGCC1 =\n+#\n+# Alternatively if assembler functions *are* needed then define the\n+# entries below:\n+# CROSS_LIBGCC1 = libgcc1-asm.a\n+# LIB1ASMSRC    = ms1/lib1funcs.asm\n+# LIB1ASMFUNCS  = _udivsi3 etc...\n+\n+LIB2FUNCS_EXTRA = $(srcdir)/config/ms1/lib2extra-funcs.c\n+\n+# If any special flags are necessary when building libgcc2 put them here.\n+#\n+# TARGET_LIBGCC2_CFLAGS = \n+\n+EXTRA_PARTS = crtbegin.o crtend.o crti.o crtn.o\n+\n+# We want fine grained libraries, so use the new code to build the\n+# floating point emulation libraries.\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n+\n+# Assemble startup files.\n+crti.o: $(srcdir)/config/ms1/crti.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) -c -o crti.o -x assembler $(srcdir)/config/ms1/crti.asm\n+ \n+crtn.o: $(srcdir)/config/ms1/crtn.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) -c -o crtn.o -x assembler $(srcdir)/config/ms1/crtn.asm\n+\n+# Enable the following if multilibs are needed.\n+# See gcc/genmultilib, gcc/gcc.texi and gcc/tm.texi for a\n+# description of the options and their values.\n+#\n+# MULTILIB_OPTIONS    = \n+# MULTILIB_DIRNAMES   = \n+# MULTILIB_MATCHES    =\n+# MULTILIB_EXCEPTIONS =\n+# MULTILIB_EXTRA_OPTS = \n+#\n+# LIBGCC = stmp-multilib\n+# INSTALL_LIBGCC = install-multilib\n+"}, {"sha": "0d2f653ff1681d72a705fef4609e5fd6abd656a4", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=c85ba4fb34b8dc43ac29ddb7009863b2cb03565d", "patch": "@@ -1887,7 +1887,7 @@ this attribute to work correctly.\n \n @item interrupt\n @cindex interrupt handler functions\n-Use this attribute on the ARM, AVR, C4x, CRX, M32C, M32R/D and Xstormy16\n+Use this attribute on the ARM, AVR, C4x, CRX, M32C, M32R/D, MS1, and Xstormy16\n ports to indicate that the specified function is an interrupt handler.\n The compiler will generate function entry and exit sequences suitable\n for use in an interrupt handler when this attribute is present."}, {"sha": "444c3d9823fbbe7f47b27c9bb3beccb2546deffa", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c85ba4fb34b8dc43ac29ddb7009863b2cb03565d", "patch": "@@ -610,6 +610,10 @@ Objective-C and Objective-C++ Dialects}.\n -mam33-2  -mno-am33-2 @gol\n -mno-crt0  -mrelax}\n \n+@emph{MS1 Options}\n+@gccoptlist{-mno-crt0 -mmul -mbacc -msim @gol\n+-march=@var{cpu-type} }\n+\n @emph{PDP-11 Options}\n @gccoptlist{-mfpu  -msoft-float  -mac0  -mno-ac0  -m40  -m45  -m10 @gol\n -mbcopy  -mbcopy-builtin  -mint32  -mno-int16 @gol\n@@ -7033,6 +7037,7 @@ platform.\n * MIPS Options::\n * MMIX Options::\n * MN10300 Options::\n+* MS1 Options::\n * PDP-11 Options::\n * PowerPC Options::\n * RS/6000 and PowerPC Options::\n@@ -10549,6 +10554,52 @@ has an effect when used on the command line for the final link step.\n This option makes symbolic debugging impossible.\n @end table\n \n+@node MS1 Options\n+@subsection MS1 Options\n+@cindex MS1 options\n+\n+These @option{-m} options are defined for Morpho MS1 architectures:\n+\n+@table @gcctabopt\n+\n+@item -march=@var{cpu-type}\n+@opindex march\n+Generate code that will run on @var{cpu-type}, which is the name of a system\n+representing a certain processor type.  Possible values for\n+@var{cpu-type} are @samp{MS1-64-001}, @samp{MS1-16-002}, and\n+@samp{MS1-16-003}.\n+\n+When this option is not used, the default is @option{-march=MS1-16-003}.\n+\n+@item -mmul\n+@opindex mmul\n+Generate multiply instructions.\n+\n+@item -mno-mul\n+@opindex mno-mul\n+Do not generate multiply instructions.\n+\n+@item -mbacc\n+@opindex mbacc\n+Use byte loads and stores when generating code.\n+\n+@item -mno-bacc\n+@opindex mno-bacc\n+Do not use byte loads and stores when generating code.\n+\n+@item -msim\n+@opindex msim\n+Use simulator runtime\n+\n+@item -mno-crt0\n+@opindex mno-crt0\n+Do not link in the C run-time initialization object file\n+@file{crti.o}.  Other run-time initialisation and termination files\n+such as @file{startup.o} and @file{exit.o} are still included on the\n+linker command line.\n+\n+@end table\n+\n @node PDP-11 Options\n @subsection PDP-11 Options\n @cindex PDP-11 Options"}, {"sha": "38c311debadfc9c710bc54d290a1e218250d09db", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85ba4fb34b8dc43ac29ddb7009863b2cb03565d/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=c85ba4fb34b8dc43ac29ddb7009863b2cb03565d", "patch": "@@ -1855,6 +1855,35 @@ Constant suitable as a 32-bit mask operand\n System V Release 4 small data area reference\n @end table\n \n+@item MorphoRISC family---@file{ms1.h}\n+@table @code\n+@item I\n+Constant for an arithmetic insn (16-bit signed integer).\n+\n+@item J\n+The constant 0.\n+\n+@item K\n+Constant for a logical insn (16-bit zero-extended integer).\n+\n+@item L\n+A constant that can be loaded with @code{lui} (i.e.@: the bottom 16\n+bits are zero).\n+\n+@item M\n+A constant that takes two words to load (i.e.@: not matched by\n+@code{I}, @code{K}, or @code{L}).\n+\n+@item N\n+Negative 16-bit constants other than -65536.\n+\n+@item O\n+A 15-bit signed integer constant.\n+\n+@item P\n+A positive 16-bit constant.\n+@end table\n+\n @item Intel 386---@file{i386.h}\n @table @code\n @item q"}]}