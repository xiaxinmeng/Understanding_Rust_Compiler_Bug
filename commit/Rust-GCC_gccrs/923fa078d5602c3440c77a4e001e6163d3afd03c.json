{"sha": "923fa078d5602c3440c77a4e001e6163d3afd03c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIzZmEwNzhkNTYwMmMzNDQwYzc3YTRlMDAxZTYxNjNkM2FmZDAzYw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2006-10-31T18:08:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:08:29Z"}, "message": "sem_ch8.adb: Minor error msg rewording\n\n2006-10-31  Robert Dewar  <dewar@adacore.com>\n\t    Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n        \n\t* sem_ch8.adb: Minor error msg rewording\n\t(Undefined): When checking for misspellings, invert arguments (to get\n\texpected and found set right)\n\t(Analyze_Subprogram_Renaming): Propagate Is_Pure, Is_Preelaborated\n\t(Analyze_Generic_Renaming): Same fix\n\t(Use_One_Package): Do not take into account the internal entities of\n\tabstract interfaces during the analysis of entities that are marked\n\tas potentially use-visible.\n\t(Find_Type): Handle the case of an attribute reference for\n\timplementation defined attribute Stub_Type (simply let the analysis of\n\tthe attribute reference rewrite it).\n\t(Use_One_Type, End_Use_Type): Reject a reference to a limited view of a\n\ttype that appears in a Use_Type clause.\n\t(Analyze_Object_Renaming): Add support for renaming of the Priority\n\tattribute.\n\t(Find_Type): In Ada 2005, a task type can be used within its own body,\n\twhen it appears in an access definition.\n\t(Analyze_Object_Renaming): Remove warning on null_exclusion.\n\t(Analyze_Object_Renaming): Introduce checks for required null exclusion\n\t in a formal object declaration or in a subtype declaration.\n\t(Analyze_Subprogram_Renaming): Add call to Check_Null_Exclusion.\n\t(Check_Null_Exclusion): New local routine to\n\tAnalyze_Subprogram_Renaming. Check whether the formals and return\n\tprofile of a renamed subprogram have required null exclusions when\n\ttheir counterparts of the renaming already impose them.\n\t(In_Generic_Scope): New local routine to Analyze_Object_Renaming.\n\tDetermine whether an entity is inside a generic scope.\n\t(In_Open_Scope): First pass of documentation update.\n\t(Find_Expanded_Name): Add support for shadow entities associated with\n\tlimited withed packages. This is required to handle nested packages.\n\t(Analyze_Package_Renaming): Remove the restriction imposed by AI-217\n\tthat makes a renaming of a limited withed package illegal.\n\nFrom-SVN: r118306", "tree": {"sha": "4fd2cea51c75fc2668e541126130f235677ca4cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fd2cea51c75fc2668e541126130f235677ca4cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/923fa078d5602c3440c77a4e001e6163d3afd03c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/923fa078d5602c3440c77a4e001e6163d3afd03c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/923fa078d5602c3440c77a4e001e6163d3afd03c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/923fa078d5602c3440c77a4e001e6163d3afd03c/comments", "author": null, "committer": null, "parents": [{"sha": "3b75bcab982e569bef561176f3181632d542cb3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b75bcab982e569bef561176f3181632d542cb3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b75bcab982e569bef561176f3181632d542cb3f"}], "stats": {"total": 374, "additions": 296, "deletions": 78}, "files": [{"sha": "5f70d86a831f2112ccec85385a638b62ff5d42b5", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 296, "deletions": 78, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/923fa078d5602c3440c77a4e001e6163d3afd03c/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/923fa078d5602c3440c77a4e001e6163d3afd03c/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=923fa078d5602c3440c77a4e001e6163d3afd03c", "patch": "@@ -646,6 +646,9 @@ package body Sem_Ch8 is\n             Set_Renamed_Object (New_P, Old_P);\n          end if;\n \n+         Set_Is_Pure          (New_P, Is_Pure          (Old_P));\n+         Set_Is_Preelaborated (New_P, Is_Preelaborated (Old_P));\n+\n          Set_Etype (New_P, Etype (Old_P));\n          Set_Has_Completion (New_P);\n \n@@ -655,7 +658,6 @@ package body Sem_Ch8 is\n \n          Check_Library_Unit_Renaming (N, Old_P);\n       end if;\n-\n    end Analyze_Generic_Renaming;\n \n    -----------------------------\n@@ -669,6 +671,31 @@ package body Sem_Ch8 is\n       T   : Entity_Id;\n       T2  : Entity_Id;\n \n+      function In_Generic_Scope (E : Entity_Id) return Boolean;\n+      --  Determine whether entity E is inside a generic cope\n+\n+      ----------------------\n+      -- In_Generic_Scope --\n+      ----------------------\n+\n+      function In_Generic_Scope (E : Entity_Id) return Boolean is\n+         S : Entity_Id;\n+\n+      begin\n+         S := Scope (E);\n+         while Present (S) and then S /= Standard_Standard loop\n+            if Is_Generic_Unit (S) then\n+               return True;\n+            end if;\n+\n+            S := Scope (S);\n+         end loop;\n+\n+         return False;\n+      end In_Generic_Scope;\n+\n+   --  Start of processing for Analyze_Object_Renaming\n+\n    begin\n       if Nam = Error then\n          return;\n@@ -719,10 +746,6 @@ package body Sem_Ch8 is\n          then\n             Error_Msg_N (\"(Ada 2005): the renamed object is not \"\n                          & \"access-to-constant ('R'M 8.5.1(6))\", N);\n-\n-         elsif Null_Exclusion_Present (Access_Definition (N)) then\n-            Error_Msg_N (\"(Ada 2005): null-excluding attribute ignored \"\n-                         & \"('R'M 8.5.1(6))?\", N);\n          end if;\n       end if;\n \n@@ -746,14 +769,80 @@ package body Sem_Ch8 is\n          return;\n       end if;\n \n+      --  Ada 2005 (AI-327)\n+\n+      if Ada_Version >= Ada_05\n+        and then Nkind (Nam) = N_Attribute_Reference\n+        and then Attribute_Name (Nam) = Name_Priority\n+      then\n+         null;\n+\n+      elsif Ada_Version >= Ada_05\n+        and then Nkind (Nam) in N_Has_Entity\n+      then\n+         declare\n+            Error_Node  : Node_Id;\n+            Nam_Decl    : Node_Id;\n+            Nam_Ent     : Entity_Id;\n+            Subtyp_Decl : Node_Id;\n+\n+         begin\n+            if Nkind (Nam) = N_Attribute_Reference then\n+               Nam_Ent := Entity (Prefix (Nam));\n+            else\n+               Nam_Ent := Entity (Nam);\n+            end if;\n+\n+            Nam_Decl    := Parent (Nam_Ent);\n+            Subtyp_Decl := Parent (Etype (Nam_Ent));\n+\n+            if Has_Null_Exclusion (N)\n+              and then not Has_Null_Exclusion (Nam_Decl)\n+            then\n+               --  Ada 2005 (AI-423): If the object name denotes a generic\n+               --  formal object of a generic unit G, and the object renaming\n+               --  declaration occurs within the body of G or within the body\n+               --  of a generic unit declared within the declarative region\n+               --  of G, then the declaration of the formal object of G shall\n+               --  have a null exclusion.\n+\n+               if Is_Formal_Object (Nam_Ent)\n+                 and then In_Generic_Scope (Id)\n+               then\n+                  if Present (Subtype_Mark (Nam_Decl)) then\n+                     Error_Node := Subtype_Mark (Nam_Decl);\n+                  else\n+                     pragma Assert\n+                       (Ada_Version >= Ada_05\n+                          and then Present (Access_Definition (Nam_Decl)));\n+\n+                     Error_Node := Access_Definition (Nam_Decl);\n+                  end if;\n+\n+                  Error_Msg_N (\"null-exclusion required in formal \" &\n+                               \"object declaration\", Error_Node);\n+\n+               --  Ada 2005 (AI-423): Otherwise, the subtype of the object\n+               --  name shall exclude null.\n+\n+               elsif Nkind (Subtyp_Decl) = N_Subtype_Declaration\n+                 and then not Has_Null_Exclusion (Subtyp_Decl)\n+               then\n+                  Error_Msg_N (\"subtype must have null-exclusion\",\n+                               Subtyp_Decl);\n+               end if;\n+            end if;\n+         end;\n+      end if;\n+\n       Set_Ekind (Id, E_Variable);\n       Init_Size_Align (Id);\n \n       if T = Any_Type or else Etype (Nam) = Any_Type then\n          return;\n \n-      --  Verify that the renamed entity is an object or a function call.\n-      --  It may have been rewritten in several ways.\n+      --  Verify that the renamed entity is an object or a function call. It\n+      --  may have been rewritten in several ways.\n \n       elsif Is_Object_Reference (Nam) then\n          if Comes_From_Source (N)\n@@ -777,9 +866,9 @@ package body Sem_Ch8 is\n                   and then Is_Function_Attribute_Name\n                     (Attribute_Name (Original_Node (Nam))))\n \n-            --  Weird but legal, equivalent to renaming a function call\n-            --  Illegal if the literal is the result of constant-folding\n-            --  an attribute reference that is not a function.\n+            --  Weird but legal, equivalent to renaming a function call.\n+            --  Illegal if the literal is the result of constant-folding an\n+            --  attribute reference that is not a function.\n \n         or else (Is_Entity_Name (Nam)\n                   and then Ekind (Entity (Nam)) = E_Enumeration_Literal\n@@ -791,14 +880,20 @@ package body Sem_Ch8 is\n       then\n          null;\n \n-      else\n-         if Nkind (Nam) = N_Type_Conversion then\n-            Error_Msg_N\n-              (\"renaming of conversion only allowed for tagged types\", Nam);\n+      elsif Nkind (Nam) = N_Type_Conversion then\n+         Error_Msg_N\n+           (\"renaming of conversion only allowed for tagged types\", Nam);\n \n-         else\n-            Error_Msg_N (\"expect object name in renaming\", Nam);\n-         end if;\n+      --  Ada 2005 (AI-327)\n+\n+      elsif Ada_Version >= Ada_05\n+        and then Nkind (Nam) = N_Attribute_Reference\n+        and then Attribute_Name (Nam) = Name_Priority\n+      then\n+         null;\n+\n+      else\n+         Error_Msg_N (\"expect object name in renaming\", Nam);\n       end if;\n \n       Set_Etype (Id, T2);\n@@ -826,8 +921,8 @@ package body Sem_Ch8 is\n          return;\n       end if;\n \n-      --  Apply Text_IO kludge here, since we may be renaming one of\n-      --  the children of Text_IO\n+      --  Apply Text_IO kludge here, since we may be renaming one of the\n+      --  children of Text_IO\n \n       Text_IO_Kludge (Name (N));\n \n@@ -847,14 +942,6 @@ package body Sem_Ch8 is\n          Error_Msg_N\n            (\"expect package name in renaming\", Name (N));\n \n-      --  Ada 2005 (AI-50217): Limited withed packages cannot be renamed\n-\n-      elsif Ekind (Old_P) = E_Package\n-        and then From_With_Type (Old_P)\n-      then\n-         Error_Msg_N\n-           (\"limited withed package cannot be renamed\", Name (N));\n-\n       elsif Ekind (Old_P) /= E_Package\n         and then not (Ekind (Old_P) = E_Generic_Package\n                        and then In_Open_Scopes (Old_P))\n@@ -875,9 +962,9 @@ package body Sem_Ch8 is\n          Set_Etype (New_P, Standard_Void_Type);\n \n       else\n-         --  Entities in the old package are accessible through the\n-         --  renaming entity. The simplest implementation is to have\n-         --  both packages share the entity list.\n+         --  Entities in the old package are accessible through the renaming\n+         --  entity. The simplest implementation is to have both packages share\n+         --  the entity list.\n \n          Set_Ekind (New_P, E_Package);\n          Set_Etype (New_P, Standard_Void_Type);\n@@ -1128,16 +1215,30 @@ package body Sem_Ch8 is\n    ---------------------------------\n \n    procedure Analyze_Subprogram_Renaming (N : Node_Id) is\n-      Spec        : constant Node_Id          := Specification (N);\n-      Save_AV     : constant Ada_Version_Type := Ada_Version;\n-      Save_AV_Exp : constant Ada_Version_Type := Ada_Version_Explicit;\n+      Formal_Spec : constant Node_Id          := Corresponding_Formal_Spec (N);\n+      Is_Actual   : constant Boolean          := Present (Formal_Spec);\n+      Inst_Node   : Node_Id                   := Empty;\n       Nam         : constant Node_Id          := Name (N);\n       New_S       : Entity_Id;\n       Old_S       : Entity_Id                 := Empty;\n       Rename_Spec : Entity_Id;\n-      Formal_Spec : constant Node_Id          := Corresponding_Formal_Spec (N);\n-      Is_Actual   : constant Boolean          := Present (Formal_Spec);\n-      Inst_Node   : Node_Id                   := Empty;\n+      Save_AV     : constant Ada_Version_Type := Ada_Version;\n+      Save_AV_Exp : constant Ada_Version_Type := Ada_Version_Explicit;\n+      Spec        : constant Node_Id          := Specification (N);\n+\n+      procedure Check_Null_Exclusion\n+        (Ren : Entity_Id;\n+         Sub : Entity_Id);\n+      --  Ada 2005 (AI-423): Given renaming Ren of subprogram Sub, check the\n+      --  following AI rules:\n+      --     o If Ren is a renaming of a formal subprogram and one of its\n+      --       parameters has a null exclusion, then the corresponding formal\n+      --       in Sub must also have one. Otherwise the subtype of the Sub's\n+      --       formal parameter must exclude null.\n+      --     o If Ren is a renaming of a formal function and its retrun\n+      --       profile has a null exclusion, then Sub's return profile must\n+      --       have one. Otherwise the subtype of Sub's return profile must\n+      --       exclude null.\n \n       function Original_Subprogram (Subp : Entity_Id) return Entity_Id;\n       --  Find renamed entity when the declaration is a renaming_as_body\n@@ -1146,6 +1247,50 @@ package body Sem_Ch8 is\n       --  occurs before the subprogram it completes is frozen, and renaming\n       --  indirectly renames the subprogram itself.(Defect Report 8652/0027).\n \n+      --------------------------\n+      -- Check_Null_Exclusion --\n+      --------------------------\n+\n+      procedure Check_Null_Exclusion\n+        (Ren : Entity_Id;\n+         Sub : Entity_Id)\n+      is\n+         Ren_Formal : Entity_Id := First_Formal (Ren);\n+         Sub_Formal : Entity_Id := First_Formal (Sub);\n+\n+      begin\n+         --  Parameter check\n+\n+         while Present (Ren_Formal)\n+           and then Present (Sub_Formal)\n+         loop\n+            if Has_Null_Exclusion (Parent (Ren_Formal))\n+              and then\n+                not (Has_Null_Exclusion (Parent (Sub_Formal))\n+                       or else Can_Never_Be_Null (Etype (Sub_Formal)))\n+            then\n+               Error_Msg_N (\"null-exclusion required in parameter profile\",\n+                            Parent (Sub_Formal));\n+            end if;\n+\n+            Next_Formal (Ren_Formal);\n+            Next_Formal (Sub_Formal);\n+         end loop;\n+\n+         --  Return profile check\n+\n+         if Nkind (Parent (Ren)) = N_Function_Specification\n+           and then Nkind (Parent (Sub)) = N_Function_Specification\n+           and then Has_Null_Exclusion (Parent (Ren))\n+           and then\n+             not (Has_Null_Exclusion (Parent (Sub))\n+                    or else Can_Never_Be_Null (Etype (Sub)))\n+         then\n+            Error_Msg_N (\"null-exclusion required in return profile\",\n+                         Result_Definition (Parent (Sub)));\n+         end if;\n+      end Check_Null_Exclusion;\n+\n       -------------------------\n       -- Original_Subprogram --\n       -------------------------\n@@ -1332,7 +1477,7 @@ package body Sem_Ch8 is\n                        and then In_Open_Scopes (Scope (Hidden))\n                        and then Is_Immediately_Visible (Hidden)\n                        and then Comes_From_Source (Hidden)\n-                       and then  Hidden /= Old_S\n+                       and then Hidden /= Old_S\n                      then\n                         Error_Msg_Sloc := Sloc (Hidden);\n                         Error_Msg_N (\"?default subprogram is resolved \" &\n@@ -1411,7 +1556,7 @@ package body Sem_Ch8 is\n             Error_Msg_N (\"(Ada 83) renaming cannot serve as a body\", N);\n          end if;\n \n-         Set_Convention (New_S,  Convention (Rename_Spec));\n+         Set_Convention (New_S, Convention (Rename_Spec));\n          Check_Fully_Conformant (New_S, Rename_Spec);\n          Set_Public_Status (New_S);\n \n@@ -1500,7 +1645,18 @@ package body Sem_Ch8 is\n       --  in this case, so we must indicate the declaration is complete as is.\n \n       if No (Rename_Spec) then\n-         Set_Has_Completion (New_S);\n+         Set_Has_Completion   (New_S);\n+         Set_Is_Pure          (New_S, Is_Pure          (Entity (Nam)));\n+         Set_Is_Preelaborated (New_S, Is_Preelaborated (Entity (Nam)));\n+\n+         --  Ada 2005 (AI-423): Check the consistency of null exclusions\n+         --  between a subprogram and its renaming.\n+\n+         if Ada_Version >= Ada_05 then\n+            Check_Null_Exclusion\n+              (Ren => New_S,\n+               Sub => Entity (Nam));\n+         end if;\n       end if;\n \n       --  Find the renamed entity that matches the given specification. Disable\n@@ -1940,7 +2096,7 @@ package body Sem_Ch8 is\n             Use_One_Type (Id);\n \n             if Nkind (Parent (N)) = N_Compilation_Unit then\n-               if  Nkind (Id) = N_Identifier then\n+               if Nkind (Id) = N_Identifier then\n                   Error_Msg_N (\"type is not directly visible\", Id);\n \n                elsif Is_Child_Unit (Scope (Entity (Id)))\n@@ -2664,7 +2820,9 @@ package body Sem_Ch8 is\n \n          T := Entity (Id);\n \n-         if T = Any_Type then\n+         if T = Any_Type\n+           or else From_With_Type (T)\n+         then\n             null;\n \n          --  Note that the use_Type clause may mention a subtype of the\n@@ -2977,7 +3135,7 @@ package body Sem_Ch8 is\n                          Nkind (Parent (Parent (N))) = N_Use_Package_Clause\n                      then\n                         Error_Msg_NE\n-                         (\"\\possibly missing with_clause for&\", N, Ent);\n+                         (\"\\possible missing with_clause for&\", N, Ent);\n                      end if;\n                   end if;\n \n@@ -3147,7 +3305,7 @@ package body Sem_Ch8 is\n                      Get_Name_String (N);\n \n                      if Is_Bad_Spelling_Of\n-                          (Name_Buffer (1 .. Name_Len), S)\n+                          (S, Name_Buffer (1 .. Name_Len))\n                      then\n                         Ematch := E;\n                         exit;\n@@ -3668,23 +3826,51 @@ package body Sem_Ch8 is\n \n       Id := Current_Entity (Selector);\n \n-      while Present (Id) loop\n-\n-         if Scope (Id) = P_Name then\n-            Candidate := Id;\n+      declare\n+         Is_New_Candidate : Boolean;\n \n-            if Is_Child_Unit (Id) then\n-               exit when Is_Visible_Child_Unit (Id)\n-                 or else Is_Immediately_Visible (Id);\n+      begin\n+         while Present (Id) loop\n+            if Scope (Id) = P_Name then\n+               Candidate        := Id;\n+               Is_New_Candidate := True;\n+\n+            --  Ada 2005 (AI-217): Handle shadow entities associated with types\n+            --  declared in limited-withed nested packages. We don't need to\n+            --  handle E_Incomplete_Subtype entities because the entities in\n+            --  the limited view are always E_Incomplete_Type entities (see\n+            --  Build_Limited_Views). Regarding the expression used to evaluate\n+            --  the scope, it is important to note that the limited view also\n+            --  has shadow entities associated nested packages. For this reason\n+            --  the correct scope of the entity is the scope of the real entity\n+\n+            elsif From_With_Type (Id)\n+              and then Is_Type (Id)\n+              and then Ekind (Id) = E_Incomplete_Type\n+              and then Present (Non_Limited_View (Id))\n+              and then Scope (Non_Limited_View (Id)) = P_Name\n+            then\n+               Candidate        := Non_Limited_View (Id);\n+               Is_New_Candidate := True;\n \n             else\n-               exit when not Is_Hidden (Id)\n-                 or else Is_Immediately_Visible (Id);\n+               Is_New_Candidate := False;\n             end if;\n-         end if;\n \n-         Id := Homonym (Id);\n-      end loop;\n+            if Is_New_Candidate then\n+               if Is_Child_Unit (Id) then\n+                  exit when Is_Visible_Child_Unit (Id)\n+                    or else Is_Immediately_Visible (Id);\n+\n+               else\n+                  exit when not Is_Hidden (Id)\n+                    or else Is_Immediately_Visible (Id);\n+               end if;\n+            end if;\n+\n+            Id := Homonym (Id);\n+         end loop;\n+      end;\n \n       if No (Id)\n         and then (Ekind (P_Name) = E_Procedure\n@@ -4041,18 +4227,22 @@ package body Sem_Ch8 is\n       --  but is a reasonable heuristic on the use of nested generics.\n       --  The proper solution requires a full renaming model.\n \n-      function Within (Inner, Outer : Entity_Id) return Boolean;\n-      --  Determine whether a candidate subprogram is defined within\n-      --  the enclosing instance. If yes, it has precedence over outer\n-      --  candidates.\n-\n       function Is_Visible_Operation (Op : Entity_Id) return Boolean;\n       --  If the renamed entity is an implicit operator, check whether it is\n       --  visible because its operand type is properly visible. This\n       --  check applies to explicit renamed entities that appear in the\n       --  source in a renaming declaration or a formal subprogram instance,\n       --  but not to default generic actuals with a name.\n \n+      function Report_Overload return Entity_Id;\n+      --  List possible interpretations, and specialize message in the\n+      --  case of a generic actual.\n+\n+      function Within (Inner, Outer : Entity_Id) return Boolean;\n+      --  Determine whether a candidate subprogram is defined within\n+      --  the enclosing instance. If yes, it has precedence over outer\n+      --  candidates.\n+\n       ------------------------\n       -- Enclosing_Instance --\n       ------------------------\n@@ -4149,7 +4339,6 @@ package body Sem_Ch8 is\n \n       begin\n          while Sc /= Standard_Standard loop\n-\n             if Sc = Outer then\n                return True;\n             else\n@@ -4160,20 +4349,20 @@ package body Sem_Ch8 is\n          return False;\n       end Within;\n \n-      function Report_Overload return Entity_Id;\n-      --  List possible interpretations, and specialize message in the\n-      --  case of a generic actual.\n+      ---------------------\n+      -- Report_Overload --\n+      ---------------------\n \n       function Report_Overload return Entity_Id is\n       begin\n          if Is_Actual then\n             Error_Msg_NE\n               (\"ambiguous actual subprogram&, \" &\n-                 \"possible interpretations: \", N, Nam);\n+                 \"possible interpretations:\", N, Nam);\n          else\n             Error_Msg_N\n               (\"ambiguous subprogram, \" &\n-                 \"possible interpretations: \", N);\n+                 \"possible interpretations:\", N);\n          end if;\n \n          List_Interps (Nam, N);\n@@ -4758,6 +4947,12 @@ package body Sem_Ch8 is\n                Set_Etype (N, T);\n             end if;\n \n+         elsif Attribute_Name (N) = Name_Stub_Type then\n+\n+            --  This is handled in Analyze_Attribute\n+\n+            Analyze (N);\n+\n          --  All other attributes are invalid in a subtype mark\n \n          else\n@@ -4786,16 +4981,30 @@ package body Sem_Ch8 is\n          then\n             Error_Msg_Sloc := Sloc (T_Name);\n             Error_Msg_N (\"subtype mark required in this context\", N);\n-            Error_Msg_NE (\"\\found & declared#\", N, T_Name);\n+            Error_Msg_NE (\"\\\\found & declared#\", N, T_Name);\n             Set_Entity (N, Any_Type);\n \n          else\n             T_Name := Get_Full_View (T_Name);\n \n             if In_Open_Scopes (T_Name) then\n                if Ekind (Base_Type (T_Name)) = E_Task_Type then\n-                  Error_Msg_N (\"task type cannot be used as type mark \" &\n-                     \"within its own body\", N);\n+\n+                  --  In Ada 2005, a task name can be used in an access\n+                  --  definition within its own body.\n+\n+                  if Ada_Version >= Ada_05\n+                    and then Nkind (Parent (N)) = N_Access_Definition\n+                  then\n+                     Set_Entity (N, T_Name);\n+                     Set_Etype  (N, T_Name);\n+                     return;\n+\n+                  else\n+                     Error_Msg_N\n+                       (\"task type cannot be used as type mark \" &\n+                        \"within its own body\", N);\n+                  end if;\n                else\n                   Error_Msg_N (\"type declaration cannot refer to itself\", N);\n                end if;\n@@ -5108,21 +5317,24 @@ package body Sem_Ch8 is\n \n    function In_Open_Scopes (S : Entity_Id) return Boolean is\n    begin\n-      --  Since there are several scope stacks maintained by Scope_Stack each\n-      --  delineated by Standard (see comments by definition of Scope_Stack)\n-      --  it is necessary to end the search when Standard is reached.\n+      --  Several scope stacks are maintained by Scope_Stack. The base of the\n+      --  currently active scope stack is denoted by the Is_Active_Stack_Base\n+      --  flag in the scope stack entry. Note that the scope stacks used to\n+      --  simply be delimited implicitly by the presence of Standard_Standard\n+      --  at their base, but there now are cases where this is not sufficient\n+      --  because Standard_Standard actually may appear in the middle of the\n+      --  active set of scopes.\n \n       for J in reverse 0 .. Scope_Stack.Last loop\n          if Scope_Stack.Table (J).Entity = S then\n             return True;\n          end if;\n \n-         --  We need Is_Active_Stack_Base to tell us when to stop rather\n-         --  than checking for Standard_Standard because there are cases\n-         --  where Standard_Standard appears in the middle of the active\n-         --  set of scopes. This affects the declaration and overriding\n-         --  of private inherited operations in instantiations of generic\n-         --  child units.\n+         --  Check Is_Active_Stack_Base to tell us when to stop, as there are\n+         --  cases where Standard_Standard appears in the middle of the active\n+         --  set of scopes. This affects the declaration and overriding of\n+         --  private inherited operations in instantiations of generic child\n+         --  units.\n \n          exit when Scope_Stack.Table (J).Is_Active_Stack_Base;\n       end loop;\n@@ -5359,6 +5571,7 @@ package body Sem_Ch8 is\n          SST.Actions_To_Be_Wrapped_After    := No_List;\n          SST.First_Use_Clause               := Empty;\n          SST.Is_Active_Stack_Base           := False;\n+         SST.Previous_Visibility            := False;\n       end;\n \n       if Debug_Flag_W then\n@@ -6235,6 +6448,11 @@ package body Sem_Ch8 is\n       if In_Open_Scopes (Scope (T)) then\n          null;\n \n+      elsif From_With_Type (T) then\n+         Error_Msg_N\n+           (\"incomplete type from limited view \"\n+             & \"cannot appear in use clause\", Id);\n+\n       --  If the subtype mark designates a subtype in a different package,\n       --  we have to check that the parent type is visible, otherwise the\n       --  use type clause is a noop. Not clear how to do that???"}]}