{"sha": "df2dbbc0343afcca95d515d8843612b0334bc17b", "node_id": "C_kwDOANBUbNoAKGRmMmRiYmMwMzQzYWZjY2E5NWQ1MTVkODg0MzYxMmIwMzM0YmMxN2I", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-02-11T10:02:46Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-02-11T10:02:46Z"}, "message": "Remove error_mark_node wrappers from backend proxy class.", "tree": {"sha": "e762da6a57371929a844d3b526cca7d2ed84f345", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e762da6a57371929a844d3b526cca7d2ed84f345"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df2dbbc0343afcca95d515d8843612b0334bc17b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df2dbbc0343afcca95d515d8843612b0334bc17b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df2dbbc0343afcca95d515d8843612b0334bc17b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df2dbbc0343afcca95d515d8843612b0334bc17b/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2aa172ff69591452e3566c105f2a4cd8450eab5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2aa172ff69591452e3566c105f2a4cd8450eab5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2aa172ff69591452e3566c105f2a4cd8450eab5"}], "stats": {"total": 239, "additions": 83, "deletions": 156}, "files": [{"sha": "a592e352c00f47d5ed5d2c72f0e1d02b75b1e476", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2dbbc0343afcca95d515d8843612b0334bc17b/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2dbbc0343afcca95d515d8843612b0334bc17b/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=df2dbbc0343afcca95d515d8843612b0334bc17b", "patch": "@@ -205,7 +205,7 @@ CompileExpr::visit (HIR::MatchExpr &expr)\n \texpr.get_scrutinee_expr ()->get_mappings ().get_hirid (),\n \t&scrutinee_expr_tyty))\n     {\n-      translated = ctx->get_backend ()->error_expression ();\n+      translated = error_mark_node;\n       return;\n     }\n \n@@ -221,7 +221,7 @@ CompileExpr::visit (HIR::MatchExpr &expr)\n   if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n \t\t\t\t       &expr_tyty))\n     {\n-      translated = ctx->get_backend ()->error_expression ();\n+      translated = error_mark_node;\n       return;\n     }\n \n@@ -644,7 +644,7 @@ CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n     }\n \n   if (ref == nullptr)\n-    return ctx->get_backend ()->error_expression ();\n+    return error_mark_node;\n \n   // get any indirection sorted out\n   if (receiver->get_kind () == TyTy::TypeKind::REF)"}, {"sha": "2fee3bea6a66582cac9a4171a97d5975c6d13f4f", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2dbbc0343afcca95d515d8843612b0334bc17b/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2dbbc0343afcca95d515d8843612b0334bc17b/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=df2dbbc0343afcca95d515d8843612b0334bc17b", "patch": "@@ -383,8 +383,8 @@ class CompileExpr : public HIRCompileBase\n \tctx->add_statement (ret_var_stmt);\n       }\n \n-    auto code_block = CompileBlock::compile (&expr, ctx, tmp);\n-    auto block_stmt = ctx->get_backend ()->block_statement (code_block);\n+    auto block_stmt = CompileBlock::compile (&expr, ctx, tmp);\n+    rust_assert (TREE_CODE (block_stmt) == BIND_EXPR);\n     ctx->add_statement (block_stmt);\n \n     if (tmp != NULL)\n@@ -680,9 +680,9 @@ class CompileExpr : public HIRCompileBase\n       = ctx->get_backend ()->expression_statement (fnctx.fndecl, exit_expr);\n     ctx->add_statement (break_stmt);\n \n-    tree code_block\n+    tree code_block_stmt\n       = CompileBlock::compile (expr.get_loop_block ().get (), ctx, nullptr);\n-    tree code_block_stmt = ctx->get_backend ()->block_statement (code_block);\n+    rust_assert (TREE_CODE (code_block_stmt) == BIND_EXPR);\n     ctx->add_statement (code_block_stmt);\n \n     ctx->pop_loop_begin_label ();"}, {"sha": "4d49c0b83d02d24f2d77c27e082cc88b61dd468d", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2dbbc0343afcca95d515d8843612b0334bc17b/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2dbbc0343afcca95d515d8843612b0334bc17b/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=df2dbbc0343afcca95d515d8843612b0334bc17b", "patch": "@@ -40,8 +40,7 @@ class CompileInherentImplItem : public CompileItem\n     CompileInherentImplItem compiler (ctx, concrete, ref_locus);\n     item->accept_vis (compiler);\n \n-    if (is_query_mode\n-\t&& ctx->get_backend ()->is_error_expression (compiler.reference))\n+    if (is_query_mode && compiler.reference == error_mark_node)\n       rust_internal_error_at (ref_locus, \"failed to compile impl item: %s\",\n \t\t\t      item->as_string ().c_str ());\n \n@@ -67,8 +66,7 @@ class CompileTraitItem : public HIRCompileBase\n     CompileTraitItem compiler (ctx, concrete, ref_locus);\n     item->accept_vis (compiler);\n \n-    if (is_query_mode\n-\t&& ctx->get_backend ()->is_error_expression (compiler.reference))\n+    if (is_query_mode && compiler.reference == error_mark_node)\n       rust_internal_error_at (ref_locus, \"failed to compile trait item: %s\",\n \t\t\t      item->as_string ().c_str ());\n \n@@ -81,8 +79,7 @@ class CompileTraitItem : public HIRCompileBase\n \n private:\n   CompileTraitItem (Context *ctx, TyTy::BaseType *concrete, Location ref_locus)\n-    : HIRCompileBase (ctx), concrete (concrete),\n-      reference (ctx->get_backend ()->error_expression ()),\n+    : HIRCompileBase (ctx), concrete (concrete), reference (error_mark_node),\n       ref_locus (ref_locus)\n   {}\n "}, {"sha": "8c5b073488d52c6e16004449cdc50353affa1621", "filename": "gcc/rust/backend/rust-compile-intrinsic.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2dbbc0343afcca95d515d8843612b0334bc17b/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2dbbc0343afcca95d515d8843612b0334bc17b/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc?ref=df2dbbc0343afcca95d515d8843612b0334bc17b", "patch": "@@ -85,7 +85,7 @@ Intrinsics::compile (TyTy::FnType *fntype)\n   Location locus = ctx->get_mappings ()->lookup_location (fntype->get_ref ());\n   rust_error_at (locus, \"unknown builtin\");\n \n-  return ctx->get_backend ()->error_function ();\n+  return error_mark_node;\n }\n \n } // namespace Compile"}, {"sha": "897fe851755c323948a4f933ecc258538972b85e", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2dbbc0343afcca95d515d8843612b0334bc17b/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2dbbc0343afcca95d515d8843612b0334bc17b/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=df2dbbc0343afcca95d515d8843612b0334bc17b", "patch": "@@ -38,8 +38,7 @@ class CompileItem : public HIRCompileBase\n     CompileItem compiler (ctx, concrete, ref_locus);\n     item->accept_vis (compiler);\n \n-    if (is_query_mode\n-\t&& ctx->get_backend ()->is_error_expression (compiler.reference))\n+    if (is_query_mode && compiler.reference == error_mark_node)\n       rust_internal_error_at (ref_locus, \"failed to compile item: %s\",\n \t\t\t      item->as_string ().c_str ());\n "}, {"sha": "e41ee7f1493a15cca72971376a43b843bf21f3ee", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2dbbc0343afcca95d515d8843612b0334bc17b/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2dbbc0343afcca95d515d8843612b0334bc17b/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=df2dbbc0343afcca95d515d8843612b0334bc17b", "patch": "@@ -58,7 +58,7 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n       if (!ctx->get_resolver ()->lookup_definition (ref_node_id, &def))\n \t{\n \t  rust_error_at (expr_locus, \"unknown reference for resolved name\");\n-\t  return ctx->get_backend ()->error_expression ();\n+\t  return error_mark_node;\n \t}\n       ref_node_id = def.parent;\n     }\n@@ -69,22 +69,22 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n     {\n       // it might be an enum data-less enum variant\n       if (lookup->get_kind () != TyTy::TypeKind::ADT)\n-\treturn ctx->get_backend ()->error_expression ();\n+\treturn error_mark_node;\n \n       TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (lookup);\n       if (!adt->is_enum ())\n-\treturn ctx->get_backend ()->error_expression ();\n+\treturn error_mark_node;\n \n       HirId variant_id;\n       if (!ctx->get_tyctx ()->lookup_variant_definition (mappings.get_hirid (),\n \t\t\t\t\t\t\t &variant_id))\n-\treturn ctx->get_backend ()->error_expression ();\n+\treturn error_mark_node;\n \n       int union_disriminator = -1;\n       TyTy::VariantDef *variant = nullptr;\n       if (!adt->lookup_variant_by_id (variant_id, &variant,\n \t\t\t\t      &union_disriminator))\n-\treturn ctx->get_backend ()->error_expression ();\n+\treturn error_mark_node;\n \n       // this can only be for discriminant variants the others are built up\n       // using call-expr or struct-init\n@@ -111,7 +111,7 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n \t\t\t\t\t\t ref_node_id, &ref))\n     {\n       rust_error_at (expr_locus, \"reverse call path lookup failure\");\n-      return ctx->get_backend ()->error_expression ();\n+      return error_mark_node;\n     }\n \n   // might be a constant\n@@ -274,7 +274,7 @@ HIRCompileBase::query_compile (HirId ref, TyTy::BaseType *lookup,\n \t}\n     }\n \n-  return ctx->get_backend ()->error_expression ();\n+  return error_mark_node;\n }\n \n } // namespace Compile"}, {"sha": "9c9d7c558ef8b1a4d14f38f15738cf4a73c89d52", "filename": "gcc/rust/backend/rust-compile-resolve-path.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2dbbc0343afcca95d515d8843612b0334bc17b/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2dbbc0343afcca95d515d8843612b0334bc17b/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h?ref=df2dbbc0343afcca95d515d8843612b0334bc17b", "patch": "@@ -50,7 +50,7 @@ class ResolvePathRef : public HIRCompileBase\n \n private:\n   ResolvePathRef (Context *ctx)\n-    : HIRCompileBase (ctx), resolved (ctx->get_backend ()->error_expression ())\n+    : HIRCompileBase (ctx), resolved (error_mark_node)\n   {}\n \n   tree resolve (const HIR::PathIdentSegment &final_segment,"}, {"sha": "c431edd9172fc13538ec0294cc51d13e9c311f24", "filename": "gcc/rust/backend/rust-compile-var-decl.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2dbbc0343afcca95d515d8843612b0334bc17b/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2dbbc0343afcca95d515d8843612b0334bc17b/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h?ref=df2dbbc0343afcca95d515d8843612b0334bc17b", "patch": "@@ -72,8 +72,7 @@ class CompileVarDecl : public HIRCompileBase\n \n private:\n   CompileVarDecl (Context *ctx, tree fndecl)\n-    : HIRCompileBase (ctx), fndecl (fndecl),\n-      translated_type (ctx->get_backend ()->error_type ()),\n+    : HIRCompileBase (ctx), fndecl (fndecl), translated_type (error_mark_node),\n       compiled_variable (ctx->get_backend ()->error_variable ())\n   {}\n "}, {"sha": "c228f6b7e897e04b2b4906a83fd6ff61b2f3bb7a", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2dbbc0343afcca95d515d8843612b0334bc17b/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2dbbc0343afcca95d515d8843612b0334bc17b/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=df2dbbc0343afcca95d515d8843612b0334bc17b", "patch": "@@ -76,10 +76,6 @@ class Backend\n \n   // Types.\n \n-  // Produce an error type.  Actually the backend could probably just\n-  // crash if this is called.\n-  virtual tree error_type () = 0;\n-\n   // Get a void type.  This is used in (at least) two ways: 1) as the\n   // return type of a function with no result parameters; 2)\n   // unsafe.Pointer is represented as *void.\n@@ -188,17 +184,6 @@ class Backend\n   // converting nil to other types.\n   virtual tree zero_expression (tree) = 0;\n \n-  // Create an error expression. This is used for cases which should\n-  // not occur in a correct program, in order to keep the compilation\n-  // going without crashing.\n-  virtual tree error_expression () = 0;\n-\n-  // return whether this is error_mark_node\n-  virtual bool is_error_expression (tree) = 0;\n-\n-  // Create a nil pointer expression.\n-  virtual tree nil_pointer_expression () = 0;\n-\n   virtual tree unit_expression () = 0;\n \n   // Create a reference to a variable.\n@@ -324,11 +309,6 @@ class Backend\n \n   // Statements.\n \n-  // Create an error statement.  This is used for cases which should\n-  // not occur in a correct program, in order to keep the compilation\n-  // going without crashing.\n-  virtual tree error_statement () = 0;\n-\n   // Create an expression statement within the specified function.\n   virtual tree expression_statement (tree, tree) = 0;\n \n@@ -405,10 +385,6 @@ class Backend\n   // be empty if there are no statements.\n   virtual void block_add_statements (tree, const std::vector<tree> &) = 0;\n \n-  // Return the block as a statement.  This is used to include a block\n-  // in a list of statements.\n-  virtual tree block_statement (tree) = 0;\n-\n   // Variables.\n \n   // Create an error variable.  This is used for cases which should\n@@ -508,11 +484,6 @@ class Backend\n \n   // Functions.\n \n-  // Create an error function.  This is used for cases which should\n-  // not occur in a correct program, in order to keep the compilation\n-  // going without crashing.\n-  virtual tree error_function () = 0;\n-\n   // Bit flags to pass to the function method.\n \n   // Set if this is a function declaration rather than a definition;\n@@ -557,10 +528,6 @@ class Backend\n \t\t\t   const std::vector<Bvariable *> &param_vars)\n     = 0;\n \n-  // Set the function body for FUNCTION using the code in CODE_STMT.  Returns\n-  // true on success, false on failure.\n-  virtual bool function_set_body (tree function, tree code_stmt) = 0;\n-\n   // Look up a named built-in function in the current backend implementation.\n   // Returns NULL if no built-in function by that name exists.\n   virtual tree lookup_gcc_builtin (const std::string &) = 0;"}, {"sha": "b052ce299dd2cdbf7a90f7bf68916c88ab155912", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 62, "deletions": 97, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2dbbc0343afcca95d515d8843612b0334bc17b/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2dbbc0343afcca95d515d8843612b0334bc17b/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=df2dbbc0343afcca95d515d8843612b0334bc17b", "patch": "@@ -116,7 +116,6 @@ class Gcc_backend : public Backend\n   }\n \n   // Types.\n-  tree error_type () { return error_mark_node; }\n \n   tree void_type () { return void_type_node; }\n \n@@ -192,12 +191,6 @@ class Gcc_backend : public Backend\n \n   tree zero_expression (tree);\n \n-  tree error_expression () { return error_mark_node; }\n-\n-  bool is_error_expression (tree expr) { return expr == error_mark_node; }\n-\n-  tree nil_pointer_expression () { return null_pointer_node; }\n-\n   tree unit_expression () { return integer_zero_node; }\n \n   tree var_expression (Bvariable *var, Location);\n@@ -261,8 +254,6 @@ class Gcc_backend : public Backend\n \n   // Statements.\n \n-  tree error_statement () { return error_mark_node; }\n-\n   tree expression_statement (tree, tree);\n \n   tree init_statement (tree, Bvariable *var, tree init);\n@@ -295,8 +286,6 @@ class Gcc_backend : public Backend\n \n   void block_add_statements (tree, const std::vector<tree> &);\n \n-  tree block_statement (tree);\n-\n   // Variables.\n \n   Bvariable *error_variable () { return new Bvariable (error_mark_node); }\n@@ -330,8 +319,6 @@ class Gcc_backend : public Backend\n \n   // Functions.\n \n-  tree error_function () { return error_mark_node; }\n-\n   tree function (tree fntype, const std::string &name,\n \t\t const std::string &asm_name, unsigned int flags, Location);\n \n@@ -341,8 +328,6 @@ class Gcc_backend : public Backend\n   bool function_set_parameters (tree function,\n \t\t\t\tconst std::vector<Bvariable *> &);\n \n-  bool function_set_body (tree function, tree code_stmt);\n-\n   tree lookup_gcc_builtin (const std::string &);\n \n   tree lookup_builtin_by_rust_name (const std::string &);\n@@ -715,7 +700,7 @@ tree\n Gcc_backend::pointer_type (tree to_type)\n {\n   if (to_type == error_mark_node)\n-    return this->error_type ();\n+    return error_mark_node;\n   tree type = build_pointer_type (to_type);\n   return type;\n }\n@@ -726,7 +711,7 @@ tree\n Gcc_backend::reference_type (tree to_type)\n {\n   if (to_type == error_mark_node)\n-    return this->error_type ();\n+    return error_mark_node;\n   tree type = build_reference_type (to_type);\n   return type;\n }\n@@ -737,7 +722,7 @@ tree\n Gcc_backend::immutable_type (tree base)\n {\n   if (base == error_mark_node)\n-    return this->error_type ();\n+    return error_mark_node;\n   tree constified = build_qualified_type (base, TYPE_QUAL_CONST);\n   return constified;\n }\n@@ -756,7 +741,7 @@ Gcc_backend::function_type (const typed_identifier &receiver,\n     {\n       tree t = receiver.type;\n       if (t == error_mark_node)\n-\treturn this->error_type ();\n+\treturn error_mark_node;\n       *pp = tree_cons (NULL_TREE, t, NULL_TREE);\n       pp = &TREE_CHAIN (*pp);\n     }\n@@ -766,7 +751,7 @@ Gcc_backend::function_type (const typed_identifier &receiver,\n     {\n       tree t = p->type;\n       if (t == error_mark_node)\n-\treturn this->error_type ();\n+\treturn error_mark_node;\n       *pp = tree_cons (NULL_TREE, t, NULL_TREE);\n       pp = &TREE_CHAIN (*pp);\n     }\n@@ -786,7 +771,7 @@ Gcc_backend::function_type (const typed_identifier &receiver,\n       result = result_struct;\n     }\n   if (result == error_mark_node)\n-    return this->error_type ();\n+    return error_mark_node;\n \n   // The libffi library cannot represent a zero-sized object.  To\n   // avoid causing confusion on 32-bit SPARC, we treat a function that\n@@ -798,7 +783,7 @@ Gcc_backend::function_type (const typed_identifier &receiver,\n \n   tree fntype = build_function_type (result, args);\n   if (fntype == error_mark_node)\n-    return this->error_type ();\n+    return error_mark_node;\n \n   return build_pointer_type (fntype);\n }\n@@ -817,7 +802,7 @@ Gcc_backend::function_type_varadic (\n     {\n       tree t = receiver.type;\n       if (t == error_mark_node)\n-\treturn this->error_type ();\n+\treturn error_mark_node;\n \n       args[offs++] = t;\n     }\n@@ -827,7 +812,7 @@ Gcc_backend::function_type_varadic (\n     {\n       tree t = p->type;\n       if (t == error_mark_node)\n-\treturn this->error_type ();\n+\treturn error_mark_node;\n       args[offs++] = t;\n     }\n \n@@ -842,7 +827,7 @@ Gcc_backend::function_type_varadic (\n       result = result_struct;\n     }\n   if (result == error_mark_node)\n-    return this->error_type ();\n+    return error_mark_node;\n \n   // The libffi library cannot represent a zero-sized object.  To\n   // avoid causing confusion on 32-bit SPARC, we treat a function that\n@@ -854,7 +839,7 @@ Gcc_backend::function_type_varadic (\n \n   tree fntype = build_varargs_function_type_array (result, n, args);\n   if (fntype == error_mark_node)\n-    return this->error_type ();\n+    return error_mark_node;\n \n   return build_pointer_type (fntype);\n }\n@@ -870,7 +855,7 @@ Gcc_backend::function_ptr_type (tree result_type,\n   for (auto &param : parameters)\n     {\n       if (param == error_mark_node)\n-\treturn this->error_type ();\n+\treturn error_mark_node;\n \n       *pp = tree_cons (NULL_TREE, param, NULL_TREE);\n       pp = &TREE_CHAIN (*pp);\n@@ -884,7 +869,7 @@ Gcc_backend::function_ptr_type (tree result_type,\n \n   tree fntype = build_function_type (result, args);\n   if (fntype == error_mark_node)\n-    return this->error_type ();\n+    return error_mark_node;\n \n   return build_pointer_type (fntype);\n }\n@@ -919,7 +904,7 @@ Gcc_backend::fill_in_fields (tree fill,\n       tree name_tree = get_identifier_from_string (p->name);\n       tree type_tree = p->type;\n       if (type_tree == error_mark_node)\n-\treturn this->error_type ();\n+\treturn error_mark_node;\n       tree field = build_decl (p->location.gcc_location (), FIELD_DECL,\n \t\t\t       name_tree, type_tree);\n       DECL_CONTEXT (field) = fill;\n@@ -952,7 +937,7 @@ tree\n Gcc_backend::fill_in_array (tree fill, tree element_type, tree length_tree)\n {\n   if (element_type == error_mark_node || length_tree == error_mark_node)\n-    return this->error_type ();\n+    return error_mark_node;\n \n   gcc_assert (TYPE_SIZE (element_type) != NULL_TREE);\n \n@@ -984,7 +969,7 @@ tree\n Gcc_backend::named_type (const std::string &name, tree type, Location location)\n {\n   if (type == error_mark_node)\n-    return this->error_type ();\n+    return error_mark_node;\n \n   // The middle-end expects a basic type to have a name.  In Rust every\n   // basic type will have a name.  The first time we see a basic type,\n@@ -1087,7 +1072,7 @@ Gcc_backend::var_expression (Bvariable *var, Location location)\n {\n   tree ret = var->get_tree (location);\n   if (ret == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n   return ret;\n }\n \n@@ -1098,7 +1083,7 @@ Gcc_backend::indirect_expression (tree type_tree, tree expr_tree,\n \t\t\t\t  bool known_valid, Location location)\n {\n   if (expr_tree == error_mark_node || type_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   // If the type of EXPR is a recursive pointer type, then we\n   // need to insert a cast before indirecting.\n@@ -1121,7 +1106,7 @@ Gcc_backend::named_constant_expression (tree type_tree, const std::string &name,\n \t\t\t\t\ttree const_val, Location location)\n {\n   if (type_tree == error_mark_node || const_val == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   tree name_tree = get_identifier_from_string (name);\n   tree decl\n@@ -1140,7 +1125,7 @@ tree\n Gcc_backend::integer_constant_expression (tree t, mpz_t val)\n {\n   if (t == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   tree ret = double_int_to_tree (t, mpz_get_double_int (t, val, true));\n   return ret;\n@@ -1153,7 +1138,7 @@ Gcc_backend::float_constant_expression (tree t, mpfr_t val)\n {\n   tree ret;\n   if (t == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   REAL_VALUE_TYPE r1;\n   real_from_mpfr (&r1, val, t, GMP_RNDN);\n@@ -1170,7 +1155,7 @@ Gcc_backend::complex_constant_expression (tree t, mpc_t val)\n {\n   tree ret;\n   if (t == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   REAL_VALUE_TYPE r1;\n   real_from_mpfr (&r1, mpc_realref (val), TREE_TYPE (t), GMP_RNDN);\n@@ -1228,7 +1213,7 @@ tree\n Gcc_backend::real_part_expression (tree complex_tree, Location location)\n {\n   if (complex_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n   gcc_assert (COMPLEX_FLOAT_TYPE_P (TREE_TYPE (complex_tree)));\n   tree ret\n     = fold_build1_loc (location.gcc_location (), REALPART_EXPR,\n@@ -1242,7 +1227,7 @@ tree\n Gcc_backend::imag_part_expression (tree complex_tree, Location location)\n {\n   if (complex_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n   gcc_assert (COMPLEX_FLOAT_TYPE_P (TREE_TYPE (complex_tree)));\n   tree ret\n     = fold_build1_loc (location.gcc_location (), IMAGPART_EXPR,\n@@ -1257,7 +1242,7 @@ Gcc_backend::complex_expression (tree real_tree, tree imag_tree,\n \t\t\t\t Location location)\n {\n   if (real_tree == error_mark_node || imag_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n   gcc_assert (TYPE_MAIN_VARIANT (TREE_TYPE (real_tree))\n \t      == TYPE_MAIN_VARIANT (TREE_TYPE (imag_tree)));\n   gcc_assert (SCALAR_FLOAT_TYPE_P (TREE_TYPE (real_tree)));\n@@ -1275,7 +1260,7 @@ Gcc_backend::convert_expression (tree type_tree, tree expr_tree,\n {\n   if (type_tree == error_mark_node || expr_tree == error_mark_node\n       || TREE_TYPE (expr_tree) == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   tree ret;\n   if (this->type_size (type_tree) == 0\n@@ -1311,23 +1296,23 @@ Gcc_backend::struct_field_expression (tree struct_tree, size_t index,\n {\n   if (struct_tree == error_mark_node\n       || TREE_TYPE (struct_tree) == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n   gcc_assert (TREE_CODE (TREE_TYPE (struct_tree)) == RECORD_TYPE\n \t      || TREE_CODE (TREE_TYPE (struct_tree)) == UNION_TYPE);\n   tree field = TYPE_FIELDS (TREE_TYPE (struct_tree));\n   if (field == NULL_TREE)\n     {\n       // This can happen for a type which refers to itself indirectly\n       // and then turns out to be erroneous.\n-      return this->error_expression ();\n+      return error_mark_node;\n     }\n   for (unsigned int i = index; i > 0; --i)\n     {\n       field = DECL_CHAIN (field);\n       gcc_assert (field != NULL_TREE);\n     }\n   if (TREE_TYPE (field) == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n   tree ret = fold_build3_loc (location.gcc_location (), COMPONENT_REF,\n \t\t\t      TREE_TYPE (field), struct_tree, field, NULL_TREE);\n   if (TREE_CONSTANT (struct_tree))\n@@ -1341,7 +1326,7 @@ tree\n Gcc_backend::compound_expression (tree stat, tree expr, Location location)\n {\n   if (stat == error_mark_node || expr == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n   tree ret = fold_build2_loc (location.gcc_location (), COMPOUND_EXPR,\n \t\t\t      TREE_TYPE (expr), stat, expr);\n   return ret;\n@@ -1357,7 +1342,7 @@ Gcc_backend::conditional_expression (tree, tree type_tree, tree cond_expr,\n {\n   if (type_tree == error_mark_node || cond_expr == error_mark_node\n       || then_expr == error_mark_node || else_expr == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n   tree ret = build3_loc (location.gcc_location (), COND_EXPR, type_tree,\n \t\t\t cond_expr, then_expr, else_expr);\n   return ret;\n@@ -1469,7 +1454,7 @@ Gcc_backend::negation_expression (NegationOperator op, tree expr_tree,\n   /* Check if the expression is an error, in which case we return an error\n      expression. */\n   if (expr_tree == error_mark_node || TREE_TYPE (expr_tree) == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   /* For negation operators, the resulting type should be the same as its\n      operand. */\n@@ -1508,7 +1493,7 @@ Gcc_backend::arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n   /* Check if either expression is an error, in which case we return an error\n      expression. */\n   if (left_tree == error_mark_node || right_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   /* We need to determine if we're doing floating point arithmetics of integer\n      arithmetics. */\n@@ -1553,7 +1538,7 @@ Gcc_backend::comparison_expression (ComparisonOperator op, tree left_tree,\n   /* Check if either expression is an error, in which case we return an error\n      expression. */\n   if (left_tree == error_mark_node || right_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   /* For comparison operators, the resulting type should be boolean. */\n   auto tree_type = boolean_type_node;\n@@ -1573,7 +1558,7 @@ Gcc_backend::lazy_boolean_expression (LazyBooleanOperator op, tree left_tree,\n   /* Check if either expression is an error, in which case we return an error\n      expression. */\n   if (left_tree == error_mark_node || right_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   /* For lazy boolean operators, the resulting type should be the same as the\n      rhs operand. */\n@@ -1594,7 +1579,7 @@ Gcc_backend::constructor_expression (tree type_tree, bool is_variant,\n \t\t\t\t     int union_index, Location location)\n {\n   if (type_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   vec<constructor_elt, va_gc> *init;\n   vec_alloc (init, vals.size ());\n@@ -1638,7 +1623,7 @@ Gcc_backend::constructor_expression (tree type_tree, bool is_variant,\n \t    }\n \t  if (TREE_TYPE (field) == error_mark_node || val == error_mark_node\n \t      || TREE_TYPE (val) == error_mark_node)\n-\t    return this->error_expression ();\n+\t    return error_mark_node;\n \n \t  if (int_size_in_bytes (TREE_TYPE (field)) == 0)\n \t    {\n@@ -1670,7 +1655,7 @@ Gcc_backend::constructor_expression (tree type_tree, bool is_variant,\n \t      tree val = (*p);\n \t      if (TREE_TYPE (field) == error_mark_node || val == error_mark_node\n \t\t  || TREE_TYPE (val) == error_mark_node)\n-\t\treturn this->error_expression ();\n+\t\treturn error_mark_node;\n \n \t      if (int_size_in_bytes (TREE_TYPE (field)) == 0)\n \t\t{\n@@ -1710,7 +1695,7 @@ Gcc_backend::array_constructor_expression (\n   const std::vector<tree> &vals, Location location)\n {\n   if (type_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   gcc_assert (indexes.size () == vals.size ());\n \n@@ -1727,7 +1712,7 @@ Gcc_backend::array_constructor_expression (\n       tree val = vals[i];\n \n       if (index == error_mark_node || val == error_mark_node)\n-\treturn this->error_expression ();\n+\treturn error_mark_node;\n \n       if (element_size == 0)\n \t{\n@@ -1766,7 +1751,7 @@ Gcc_backend::pointer_offset_expression (tree base_tree, tree index_tree,\n   tree element_type_tree = TREE_TYPE (TREE_TYPE (base_tree));\n   if (base_tree == error_mark_node || TREE_TYPE (base_tree) == error_mark_node\n       || index_tree == error_mark_node || element_type_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   tree element_size = TYPE_SIZE_UNIT (element_type_tree);\n   index_tree\n@@ -1786,7 +1771,7 @@ Gcc_backend::array_index_expression (tree array_tree, tree index_tree,\n {\n   if (array_tree == error_mark_node || TREE_TYPE (array_tree) == error_mark_node\n       || index_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   // A function call that returns a zero sized object will have been\n   // changed to return void.  If we see void here, assume we are\n@@ -1810,7 +1795,7 @@ Gcc_backend::call_expression (tree, // containing fcn for call\n \t\t\t      tree chain_expr, Location location)\n {\n   if (fn == error_mark_node || TREE_TYPE (fn) == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   gcc_assert (FUNCTION_POINTER_TYPE_P (TREE_TYPE (fn)));\n   tree rettype = TREE_TYPE (TREE_TYPE (TREE_TYPE (fn)));\n@@ -1821,7 +1806,7 @@ Gcc_backend::call_expression (tree, // containing fcn for call\n     {\n       args[i] = fn_args.at (i);\n       if (args[i] == error_mark_node)\n-\treturn this->error_expression ();\n+\treturn error_mark_node;\n     }\n \n   tree fndecl = fn;\n@@ -1893,7 +1878,7 @@ Gcc_backend::init_statement (tree, Bvariable *var, tree init_tree)\n {\n   tree var_tree = var->get_decl ();\n   if (var_tree == error_mark_node || init_tree == error_mark_node)\n-    return this->error_statement ();\n+    return error_mark_node;\n   gcc_assert (TREE_CODE (var_tree) == VAR_DECL);\n \n   // To avoid problems with GNU ld, we don't make zero-sized\n@@ -1925,7 +1910,7 @@ Gcc_backend::assignment_statement (tree bfn, tree lhs, tree rhs,\n \t\t\t\t   Location location)\n {\n   if (lhs == error_mark_node || rhs == error_mark_node)\n-    return this->error_statement ();\n+    return error_mark_node;\n \n   // To avoid problems with GNU ld, we don't make zero-sized\n   // externally visible variables.  That might lead us to doing an\n@@ -1953,10 +1938,10 @@ Gcc_backend::return_statement (tree fntree, const std::vector<tree> &vals,\n \t\t\t       Location location)\n {\n   if (fntree == error_mark_node)\n-    return this->error_statement ();\n+    return error_mark_node;\n   tree result = DECL_RESULT (fntree);\n   if (result == error_mark_node)\n-    return this->error_statement ();\n+    return error_mark_node;\n \n   // If the result size is zero bytes, we have set the function type\n   // to have a result type of void, so don't return anything.\n@@ -1970,7 +1955,7 @@ Gcc_backend::return_statement (tree fntree, const std::vector<tree> &vals,\n \t{\n \t  tree val = (*p);\n \t  if (val == error_mark_node)\n-\t    return this->error_statement ();\n+\t    return error_mark_node;\n \t  append_to_statement_list (val, &stmt_list);\n \t}\n       tree ret = fold_build1_loc (location.gcc_location (), RETURN_EXPR,\n@@ -1987,7 +1972,7 @@ Gcc_backend::return_statement (tree fntree, const std::vector<tree> &vals,\n     {\n       tree val = vals.front ();\n       if (val == error_mark_node)\n-\treturn this->error_statement ();\n+\treturn error_mark_node;\n       tree set = fold_build2_loc (location.gcc_location (), MODIFY_EXPR,\n \t\t\t\t  void_type_node, result, vals.front ());\n       ret = fold_build1_loc (location.gcc_location (), RETURN_EXPR,\n@@ -2019,7 +2004,7 @@ Gcc_backend::return_statement (tree fntree, const std::vector<tree> &vals,\n \t\t\t       TREE_TYPE (field), rettmp, field, NULL_TREE);\n \t  tree val = (*p);\n \t  if (val == error_mark_node)\n-\t    return this->error_statement ();\n+\t    return error_mark_node;\n \t  tree set = fold_build2_loc (location.gcc_location (), MODIFY_EXPR,\n \t\t\t\t      void_type_node, ref, (*p));\n \t  append_to_statement_list (set, &stmt_list);\n@@ -2047,7 +2032,7 @@ Gcc_backend::exception_handler_statement (tree try_stmt, tree except_stmt,\n {\n   if (try_stmt == error_mark_node || except_stmt == error_mark_node\n       || finally_stmt == error_mark_node)\n-    return this->error_statement ();\n+    return error_mark_node;\n \n   if (except_stmt != NULL_TREE)\n     try_stmt = build2_loc (location.gcc_location (), TRY_CATCH_EXPR,\n@@ -2068,7 +2053,7 @@ Gcc_backend::if_statement (tree, tree cond_tree, tree then_tree, tree else_tree,\n {\n   if (cond_tree == error_mark_node || then_tree == error_mark_node\n       || else_tree == error_mark_node)\n-    return this->error_statement ();\n+    return error_mark_node;\n   tree ret = build3_loc (location.gcc_location (), COND_EXPR, void_type_node,\n \t\t\t cond_tree, then_tree, else_tree);\n   return ret;\n@@ -2125,7 +2110,7 @@ Gcc_backend::switch_statement (tree decl, tree value,\n \t    {\n \t      tree t = (*pcv);\n \t      if (t == error_mark_node)\n-\t\treturn this->error_statement ();\n+\t\treturn error_mark_node;\n \t      location_t loc = EXPR_LOCATION (t);\n \t      tree label = create_artificial_label (loc);\n \t      tree c = build_case_label ((*pcv), NULL_TREE, label);\n@@ -2137,15 +2122,15 @@ Gcc_backend::switch_statement (tree decl, tree value,\n \t{\n \t  tree t = (*ps);\n \t  if (t == error_mark_node)\n-\t    return this->error_statement ();\n+\t    return error_mark_node;\n \t  append_to_statement_list (t, &stmt_list);\n \t}\n     }\n   pop_cfun ();\n \n   tree tv = value;\n   if (tv == error_mark_node)\n-    return this->error_statement ();\n+    return error_mark_node;\n   tree t = build2_loc (switch_location.gcc_location (), SWITCH_EXPR, NULL_TREE,\n \t\t       tv, stmt_list);\n   return t;\n@@ -2159,11 +2144,11 @@ Gcc_backend::compound_statement (tree s1, tree s2)\n   tree stmt_list = NULL_TREE;\n   tree t = s1;\n   if (t == error_mark_node)\n-    return this->error_statement ();\n+    return error_mark_node;\n   append_to_statement_list (t, &stmt_list);\n   t = s2;\n   if (t == error_mark_node)\n-    return this->error_statement ();\n+    return error_mark_node;\n   append_to_statement_list (t, &stmt_list);\n \n   // If neither statement has any side effects, stmt_list can be NULL\n@@ -2185,7 +2170,7 @@ Gcc_backend::statement_list (const std::vector<tree> &statements)\n     {\n       tree t = (*p);\n       if (t == error_mark_node)\n-\treturn this->error_statement ();\n+\treturn error_mark_node;\n       append_to_statement_list (t, &stmt_list);\n     }\n   return stmt_list;\n@@ -2275,15 +2260,6 @@ Gcc_backend::block_add_statements (tree bind_tree,\n   BIND_EXPR_BODY (bind_tree) = stmt_list;\n }\n \n-// Return a block as a statement.\n-\n-tree\n-Gcc_backend::block_statement (tree bind_tree)\n-{\n-  gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n-  return bind_tree;\n-}\n-\n // This is not static because we declare it with GTY(()) in rust-c.h.\n tree rust_non_zero_struct;\n \n@@ -2527,7 +2503,7 @@ Gcc_backend::temporary_variable (tree fndecl, tree bind_tree, tree type_tree,\n   if (type_tree == error_mark_node || init_tree == error_mark_node\n       || fndecl == error_mark_node)\n     {\n-      *pstatement = this->error_statement ();\n+      *pstatement = error_mark_node;\n       return this->error_variable ();\n     }\n \n@@ -2656,7 +2632,7 @@ Gcc_backend::function (tree functype, const std::string &name,\n     }\n   tree id = get_identifier_from_string (name);\n   if (functype == error_mark_node || id == error_mark_node)\n-    return this->error_function ();\n+    return error_mark_node;\n \n   tree decl\n     = build_decl (location.gcc_location (), FUNCTION_DECL, id, functype);\n@@ -2697,7 +2673,7 @@ Gcc_backend::function_defer_statement (tree function, tree undefer_tree,\n {\n   if (undefer_tree == error_mark_node || defer_tree == error_mark_node\n       || function == error_mark_node)\n-    return this->error_statement ();\n+    return error_mark_node;\n \n   if (DECL_STRUCT_FUNCTION (function) == NULL)\n     push_struct_function (function);\n@@ -2745,17 +2721,6 @@ Gcc_backend::function_set_parameters (\n   return true;\n }\n \n-// Set the function body for FUNCTION using the code in CODE_BLOCK.\n-\n-bool\n-Gcc_backend::function_set_body (tree function, tree code_stmt)\n-{\n-  if (function == error_mark_node || code_stmt == error_mark_node)\n-    return false;\n-  DECL_SAVED_TREE (function) = code_stmt;\n-  return true;\n-}\n-\n // Look up a named built-in function in the current backend implementation.\n // Returns NULL if no built-in function by that name exists.\n "}]}