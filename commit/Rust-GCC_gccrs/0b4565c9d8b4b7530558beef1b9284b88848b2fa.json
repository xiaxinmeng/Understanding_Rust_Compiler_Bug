{"sha": "0b4565c9d8b4b7530558beef1b9284b88848b2fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI0NTY1YzlkOGI0Yjc1MzA1NThiZWVmMWI5Mjg0Yjg4ODQ4YjJmYQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "2000-06-24T19:26:42Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "2000-06-24T19:26:42Z"}, "message": "Vector conversions support\n\nFrom-SVN: r34680", "tree": {"sha": "db94b2c1a07d5c04365806edf03c813ecba575c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db94b2c1a07d5c04365806edf03c813ecba575c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b4565c9d8b4b7530558beef1b9284b88848b2fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b4565c9d8b4b7530558beef1b9284b88848b2fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b4565c9d8b4b7530558beef1b9284b88848b2fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b4565c9d8b4b7530558beef1b9284b88848b2fa/comments", "author": null, "committer": null, "parents": [{"sha": "cf036e712cdd515d1fed36a58023926e0dabb1aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf036e712cdd515d1fed36a58023926e0dabb1aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf036e712cdd515d1fed36a58023926e0dabb1aa"}], "stats": {"total": 98, "additions": 93, "deletions": 5}, "files": [{"sha": "9633f0bc9e9601c1f7bf936e0cb4ef4bae2152a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4565c9d8b4b7530558beef1b9284b88848b2fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4565c9d8b4b7530558beef1b9284b88848b2fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b4565c9d8b4b7530558beef1b9284b88848b2fa", "patch": "@@ -1,3 +1,16 @@\n+2000-06-24  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* tree.def (VECTOR_TYPE): New node type.\n+\t* tree.h: Adjust some comments to reflect addition of vector types.\n+\t(TYPE_VECTOR_SUBPARTS): New macro.\n+\t* stor-layout.c (layout_type): Handle VECTOR_TYPE.\n+\t* c-convert.c (convert): Likewise.\n+\t* convert.c (convert_to_integer): Handle vector modes.\n+\t(convert_to_vector): New function.\n+\t* convert.h (convert_to_vector): Declare.\n+\t* expr.c (convert_move): Handle vector modes.\n+\t* expmed.c (extract_bit_field): Don't abort for vector modes.\n+\n 2000-06-24  Marek Michalkiewicz  <marekm@linux.org.pl>\n \n \t* config/avr/avr-protos.h (avr_hard_regno_mode_ok): New prototype."}, {"sha": "5d7ea00f82bb62cb5f89785e44b8a9b024c2b918", "filename": "gcc/c-convert.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4565c9d8b4b7530558beef1b9284b88848b2fa/gcc%2Fc-convert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4565c9d8b4b7530558beef1b9284b88848b2fa/gcc%2Fc-convert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-convert.c?ref=0b4565c9d8b4b7530558beef1b9284b88848b2fa", "patch": "@@ -94,6 +94,8 @@ convert (type, expr)\n     return fold (convert_to_real (type, e));\n   if (code == COMPLEX_TYPE)\n     return fold (convert_to_complex (type, e));\n+  if (code == VECTOR_TYPE)\n+    return fold (convert_to_vector (type, e));\n \n   error (\"conversion to non-scalar type requested\");\n   return error_mark_node;"}, {"sha": "6eea7d684c60c1374c8c0395ddd075e665f296a8", "filename": "gcc/convert.c", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4565c9d8b4b7530558beef1b9284b88848b2fa/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4565c9d8b4b7530558beef1b9284b88848b2fa/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=0b4565c9d8b4b7530558beef1b9284b88848b2fa", "patch": "@@ -108,8 +108,8 @@ convert_to_real (type, expr)\n \n /* Convert EXPR to some integer (or enum) type TYPE.\n \n-   EXPR must be pointer, integer, discrete (enum, char, or bool), or float;\n-   in other cases error is called.\n+   EXPR must be pointer, integer, discrete (enum, char, or bool), float, or\n+   vector; in other cases error is called.\n \n    The result of this is always supposed to be a newly created tree node\n    not in use in any existing structure.  */\n@@ -383,6 +383,15 @@ convert_to_integer (type, expr)\n \t\t      fold (build1 (REALPART_EXPR,\n \t\t\t\t    TREE_TYPE (TREE_TYPE (expr)), expr)));\n \n+    case VECTOR_TYPE:\n+      if (GET_MODE_SIZE (TYPE_MODE (type))\n+\t  != GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (expr))))\n+\t{\n+\t  error (\"can't convert between vector values of different size\");\n+\t  return error_mark_node;\n+\t}\n+      return build1 (NOP_EXPR, type, expr);\n+\n     default:\n       error (\"aggregate value used where an integer was expected\");\n       return convert (type, integer_zero_node);\n@@ -444,3 +453,29 @@ convert_to_complex (type, expr)\n       return convert_to_complex (type, integer_zero_node);\n     }\n }\n+\n+/* Convert EXPR to the vector type TYPE in the usual ways.  */\n+\n+tree\n+convert_to_vector (type, expr)\n+     tree type, expr;\n+{\n+  tree subtype = TREE_TYPE (type);\n+  \n+  switch (TREE_CODE (TREE_TYPE (expr)))\n+    {\n+    case INTEGER_TYPE:\n+    case VECTOR_TYPE:\n+      if (GET_MODE_SIZE (TYPE_MODE (type))\n+\t  != GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (expr))))\n+\t{\n+\t  error (\"can't convert between vector values of different size\");\n+\t  return error_mark_node;\n+\t}\n+      return build1 (NOP_EXPR, type, expr);\n+\n+    default:\n+      error (\"can't convert value to a vector\");\n+      return convert_to_vector (type, integer_zero_node);\n+    }\n+}"}, {"sha": "ed93c4b9e571511324338914624b2715ba479306", "filename": "gcc/convert.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4565c9d8b4b7530558beef1b9284b88848b2fa/gcc%2Fconvert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4565c9d8b4b7530558beef1b9284b88848b2fa/gcc%2Fconvert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.h?ref=0b4565c9d8b4b7530558beef1b9284b88848b2fa", "patch": "@@ -22,3 +22,4 @@ extern tree convert_to_integer PARAMS ((tree, tree));\n extern tree convert_to_pointer PARAMS ((tree, tree));\n extern tree convert_to_real PARAMS ((tree, tree));\n extern tree convert_to_complex PARAMS ((tree, tree));\n+extern tree convert_to_vector PARAMS ((tree, tree));"}, {"sha": "883d33f470c3edab333c859809de7c931e07e7b0", "filename": "gcc/expmed.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4565c9d8b4b7530558beef1b9284b88848b2fa/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4565c9d8b4b7530558beef1b9284b88848b2fa/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=0b4565c9d8b4b7530558beef1b9284b88848b2fa", "patch": "@@ -1072,7 +1072,8 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t\t  : bitpos == 0))))\n     {\n       enum machine_mode mode1\n-\t= mode_for_size (bitsize, GET_MODE_CLASS (tmode), 0);\n+\t= (VECTOR_MODE_P (tmode) ? mode\n+\t   : mode_for_size (bitsize, GET_MODE_CLASS (tmode), 0));\n \n       if (mode1 != GET_MODE (op0))\n \t{"}, {"sha": "02a7a3548619f2815ba44a7556e1bfecc8d47193", "filename": "gcc/expr.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4565c9d8b4b7530558beef1b9284b88848b2fa/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4565c9d8b4b7530558beef1b9284b88848b2fa/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0b4565c9d8b4b7530558beef1b9284b88848b2fa", "patch": "@@ -545,6 +545,23 @@ convert_move (to, from, unsignedp)\n       return;\n     }\n \n+  if (VECTOR_MODE_P (to_mode) || VECTOR_MODE_P (from_mode))\n+    {\n+      if (GET_MODE_BITSIZE (from_mode) != GET_MODE_BITSIZE (to_mode))\n+\tabort ();\n+      \n+      if (VECTOR_MODE_P (to_mode))\n+\tfrom = gen_rtx_SUBREG (to_mode, from, 0);\n+      else\n+\tto = gen_rtx_SUBREG (from_mode, to, 0);\n+\n+      emit_move_insn (to, from);\n+      return;\n+    }\n+\n+  if (to_real != from_real)\n+    abort ();\n+\n   if (to_real)\n     {\n       rtx value;"}, {"sha": "12162e7f14b86e9e25390b502978b68e244eb62b", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4565c9d8b4b7530558beef1b9284b88848b2fa/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4565c9d8b4b7530558beef1b9284b88848b2fa/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=0b4565c9d8b4b7530558beef1b9284b88848b2fa", "patch": "@@ -1286,6 +1286,17 @@ layout_type (type)\n       TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n       break;\n \n+    case VECTOR_TYPE:\n+      {\n+\ttree subtype;\n+\n+\tsubtype = TREE_TYPE (type);\n+\tTREE_UNSIGNED (type) = TREE_UNSIGNED (subtype);\n+\tTYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n+\tTYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n+      }\n+      break;\n+\n     case VOID_TYPE:\n       /* This is an incomplete type and so doesn't have a size.  */\n       TYPE_ALIGN (type) = 1;"}, {"sha": "28c47d97a79054e8c90afe16b320879acd59d86b", "filename": "gcc/tree.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4565c9d8b4b7530558beef1b9284b88848b2fa/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4565c9d8b4b7530558beef1b9284b88848b2fa/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=0b4565c9d8b4b7530558beef1b9284b88848b2fa", "patch": "@@ -150,6 +150,10 @@ DEFTREECODE (REAL_TYPE, \"real_type\", 't', 0)\n    of the real and imaginary parts.  */\n DEFTREECODE (COMPLEX_TYPE, \"complex_type\", 't', 0)\n \n+/* Vector types.  The TREE_TYPE field is the data type of the vector\n+   elements.  */\n+DEFTREECODE (VECTOR_TYPE, \"vector_type\", 't', 0)\n+\n /* C enums.  The type node looks just like an INTEGER_TYPE node.\n    The symbols for the values of the enum type are defined by\n    CONST_DECL nodes, but the type does not point to them;"}, {"sha": "f683357f1482c632b60d5258db0e273c04d4d908", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4565c9d8b4b7530558beef1b9284b88848b2fa/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4565c9d8b4b7530558beef1b9284b88848b2fa/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0b4565c9d8b4b7530558beef1b9284b88848b2fa", "patch": "@@ -332,7 +332,8 @@ extern void tree_class_check_failed PARAMS ((const tree, int,\n \n /* In all nodes that are expressions, this is the data type of the expression.\n    In POINTER_TYPE nodes, this is the type that the pointer points to.\n-   In ARRAY_TYPE nodes, this is the type of the elements.  */\n+   In ARRAY_TYPE nodes, this is the type of the elements.\n+   In VECTOR_TYPE nodes, this is the type of the elements.  */\n #define TREE_TYPE(NODE) ((NODE)->common.type)\n \n /* Nodes are chained together for many purposes.\n@@ -1012,7 +1013,10 @@ struct tree_block\n    object of the given ARRAY_TYPE.  This allows temporaries to be allocated. */\n #define TYPE_ARRAY_MAX_SIZE(ARRAY_TYPE) TYPE_MAX_VALUE (ARRAY_TYPE)\n \n-/* Indicates that objects of this type must be initialized by calling a\n+/* For a VECTOR_TYPE, this is the number of sub-parts of the vector.  */\n+#define TYPE_VECTOR_SUBPARTS(VECTOR_TYPE) (GET_MODE_NUNITS (TYPE_CHECK (VECTOR_TYPE)->type.mode))\n+\n+  /* Indicates that objects of this type must be initialized by calling a\n    function when they are created.  */\n #define TYPE_NEEDS_CONSTRUCTING(NODE) \\\n   (TYPE_CHECK (NODE)->type.needs_constructing_flag)"}]}