{"sha": "23190837c6b9b947cd9bcc80c28639bfb6d8a032", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjMxOTA4MzdjNmI5Yjk0N2NkOWJjYzgwYzI4NjM5YmZiNmQ4YTAzMg==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2001-07-16T09:16:04Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2001-07-16T09:16:04Z"}, "message": "gcov.c (output_data): Use HOST_WIDEST_INT_PRINT_DEC to output variables of type HOST_WIDEST_INT.\n\n\t* gcov.c (output_data): Use HOST_WIDEST_INT_PRINT_DEC to output\n\tvariables of type HOST_WIDEST_INT.\n\n\t* libgcc2.c (__bb_exit_func): Handle gcov_type as long long.\n\t(__bb_exit_func): Correct type of count_max to avoid overflow.\n\t(num_digits): Handle long long argument.\n\n\t* combine.c (gen_lowpart_for_combine): Remove unused variable.\n\nFrom-SVN: r44033", "tree": {"sha": "e4dcc2ea6ccc61dc1c0096e4977098b476823584", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4dcc2ea6ccc61dc1c0096e4977098b476823584"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23190837c6b9b947cd9bcc80c28639bfb6d8a032", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23190837c6b9b947cd9bcc80c28639bfb6d8a032", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23190837c6b9b947cd9bcc80c28639bfb6d8a032", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23190837c6b9b947cd9bcc80c28639bfb6d8a032/comments", "author": null, "committer": null, "parents": [{"sha": "cc385017aae7dfb0df730ca826aeedde39f41ef6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc385017aae7dfb0df730ca826aeedde39f41ef6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc385017aae7dfb0df730ca826aeedde39f41ef6"}], "stats": {"total": 211, "additions": 116, "deletions": 95}, "files": [{"sha": "c5dd275ed535ba1aacc788be39873629baf31a1e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23190837c6b9b947cd9bcc80c28639bfb6d8a032/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23190837c6b9b947cd9bcc80c28639bfb6d8a032/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=23190837c6b9b947cd9bcc80c28639bfb6d8a032", "patch": "@@ -1,3 +1,14 @@\n+2001-07-16  Andreas Jaeger  <aj@suse.de>\n+\n+\t* gcov.c (output_data): Use HOST_WIDEST_INT_PRINT_DEC to output\n+\tvariables of type HOST_WIDEST_INT.\n+\n+\t* libgcc2.c (__bb_exit_func): Handle gcov_type as long long.\n+\t(__bb_exit_func): Correct type of count_max to avoid overflow.\n+\t(num_digits): Handle long long argument.\n+\n+\t* combine.c (gen_lowpart_for_combine): Remove unused variable.\n+\n 2001-07-16  Neil Booth  <neil@cat.daikokuya.demon.co.uk>\n \n \t* output.h (sdb_begin_function_line): Restore as an extern\n@@ -271,16 +282,16 @@ Fri Jul 13 23:04:00 2001  Denis Chertykov  <denisc@overta.ru>\n \n 2001-07-13  Hartmut Penner  <hpenner@de.ibm.com>\n \n-        * config.gcc: Add configuration for s/390. \n-        * config/s390/s390.c: New. Subroutines for code generation.\n+\t* config.gcc: Add configuration for s/390.\n+\t* config/s390/s390.c: New. Subroutines for code generation.\n \t* config/s390/s390.h: New. Definitions for s/390.\n \t* config/s390/s390-protos.h: New. Prototypes.\n \t* config/s390/linux.h: New. Definitions for linux for s/390.\n \t* config/s390/linux64.h: New. Definitions for linux for zSeries.\n-        * config/s390/t-linux: New. Makefile fragment.\n-        * config/s390/s390.md: New. Machine description for s/390 and zSeries.\n+\t* config/s390/t-linux: New. Makefile fragment.\n+\t* config/s390/s390.md: New. Machine description for s/390 and zSeries.\n \t* config/s390/fixdfdi.h: New. Fix L_fix*di.\n-\t\n+\n Fri Jul 13 14:46:21 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* emit-rtl.c (try_split): Update mark_jump_label call.\n@@ -475,7 +486,7 @@ Wed Jul 11 21:27:25 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \t* jump.c (rtx_renumbered_equal_p): Handle 't' fields.\n \t* output.h (cleanup_cfg): Update prototype.\n \t* reg-stack.c (reg_to_stack): Use cleanup_cfg instead of jump_optimize\n-\t* sibcall.c (optimize_sibling_and_tail_recursive_call): Update \n+\t* sibcall.c (optimize_sibling_and_tail_recursive_call): Update\n \tcleanup_cfg call; kill missleading comment.\n \t* toplev.c (rest_of_compilation): Update all cleanup_cfg calls.\n \t* flow.c (merge_blocks, try_optimize_cfg, cleanup_cfg): Accept mode\n@@ -506,7 +517,7 @@ Wed Jul 11 21:27:25 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n 2001-07-11  Mark Mitchell  <mark@codesourcery.com>\n \n-\t* stmt.c (parse_output_constraint): New function, split out \n+\t* stmt.c (parse_output_constraint): New function, split out\n \tfrom ...\n \t(expand_asm_operands): ... here.  Use parse_output_constraint.\n \t* tree.h (parse_output_constraint): Declare it.\n@@ -573,7 +584,7 @@ Tue Jul 10 07:27:53 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t* recog.c (offsettable_address_p): Handle LO_SUM case.\n \t* config/mips/mips.c (double_memory_operand): Use adjust_address_nv\n \tinstead of plus_constant.\n-\t\n+\n 2001-07-10  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n \n \t* reload1.c (merge_assigned_reloads): After a RELOAD_OTHER merge,\n@@ -640,7 +651,7 @@ Tue Jul 10 09:04:45 2001  Jeffrey A Law  (law@cygnus.com)\n \t.loc support.\n \n \t* collect2.c (main): Set COLLECT_NO_DEMANGLE for subprocesses.\n-\t(dump_file): Only pad the demangled name with spaces if the \n+\t(dump_file): Only pad the demangled name with spaces if the\n \tmangled name was padded with spaces.\n \n 2001-07-10  Bernd Schmidt  <bernds@redhat.com>"}, {"sha": "6c2f40fdb74cb931c8060a422cccfd9779b2fe98", "filename": "gcc/combine.c", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23190837c6b9b947cd9bcc80c28639bfb6d8a032/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23190837c6b9b947cd9bcc80c28639bfb6d8a032/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=23190837c6b9b947cd9bcc80c28639bfb6d8a032", "patch": "@@ -1133,7 +1133,7 @@ can_combine_p (insn, i3, pred, succ, pdest, psrc)\n \n       for (p = NEXT_INSN (insn); p != i3; p = NEXT_INSN (p))\n         if (INSN_P (p) && p != succ && volatile_refs_p (PATTERN (p)))\n-  \treturn 0;\n+\treturn 0;\n     }\n \n   /* If INSN is an asm, and DEST is a hard register, reject, since it has\n@@ -1245,7 +1245,7 @@ sets_function_arg_p (pat)\n    This is NOT equivalent to:\n \n          (parallel [(set (subreg:SI (reg:DI 100) 0) <foo>)\n-\t \t    (set (reg:DI 101) (reg:DI 100))])\n+\t\t    (set (reg:DI 101) (reg:DI 100))])\n \n    Not only does this modify 100 (in which case it might still be valid\n    if 100 were dead in I2), it sets 101 to the ORIGINAL value of 100.\n@@ -1421,7 +1421,7 @@ cant_combine_insn_p (insn)\n {\n   rtx set;\n   rtx src, dest;\n-  \n+\n   /* If this isn't really an insn, we can't do anything.\n      This can occur when flow deletes an insn that it has merged into an\n      auto-increment address.  */\n@@ -1771,7 +1771,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n   /* If I3 has an inc, then give up if I1 or I2 uses the reg that is inc'd.\n      We used to do this EXCEPT in one case: I3 has a post-inc in an\n      output operand.  However, that exception can give rise to insns like\n-     \tmov r3,(r3)+\n+\tmov r3,(r3)+\n      which is a famous insn on the PDP-11 where the value of r3 used as the\n      source was model-dependent.  Avoid this sort of thing.  */\n \n@@ -2136,7 +2136,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \t  insn_code_number = recog_for_combine (&m_split, i3, &new_i3_notes);\n \t  if (insn_code_number >= 0)\n \t    newpat = m_split;\n-\t} \n+\t}\n       else if (m_split && GET_CODE (m_split) == SEQUENCE\n \t       && XVECLEN (m_split, 0) == 2\n \t       && (next_real_insn (i2) == i3\n@@ -3786,7 +3786,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n       {\n \trtx temp;\n \ttemp = simplify_subreg (mode, SUBREG_REG (x), op0_mode,\n-\t\t       \t\tSUBREG_BYTE (x));\n+\t\t\t\tSUBREG_BYTE (x));\n \tif (temp)\n \t  return temp;\n       }\n@@ -3861,12 +3861,12 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \treturn gen_rtx_GE (mode, XEXP (XEXP (x, 0), 0), const0_rtx);\n \n       /* Apply De Morgan's laws to reduce number of patterns for machines\n- \t with negating logical insns (and-not, nand, etc.).  If result has\n- \t only one NOT, put it first, since that is how the patterns are\n- \t coded.  */\n+\t with negating logical insns (and-not, nand, etc.).  If result has\n+\t only one NOT, put it first, since that is how the patterns are\n+\t coded.  */\n \n       if (GET_CODE (XEXP (x, 0)) == IOR || GET_CODE (XEXP (x, 0)) == AND)\n- \t{\n+\t{\n \t  rtx in1 = XEXP (XEXP (x, 0), 0), in2 = XEXP (XEXP (x, 0), 1);\n \t  enum machine_mode op_mode;\n \n@@ -3931,7 +3931,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n       temp = expand_compound_operation (XEXP (x, 0));\n \n       /* For C equal to the width of MODE minus 1, (neg (ashiftrt X C)) can be\n- \t replaced by (lshiftrt X C).  This will convert\n+\t replaced by (lshiftrt X C).  This will convert\n \t (neg (sign_extract X 1 Y)) to (zero_extract X 1 Y).  */\n \n       if (GET_CODE (temp) == ASHIFTRT\n@@ -4015,7 +4015,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  && num_sign_bit_copies (XEXP (x, 0), GET_MODE (XEXP (x, 0)))\n \t     >= GET_MODE_BITSIZE (mode) + 1\n \t  && ! (GET_CODE (XEXP (x, 0)) == LSHIFTRT\n- \t\t&& GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT))\n+\t\t&& GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT))\n \treturn gen_lowpart_for_combine (mode, XEXP (x, 0));\n \n       /* A truncate of a comparison can be replaced with a subreg if\n@@ -4250,8 +4250,8 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n     case GT:  case GTU:  case GE:  case GEU:\n     case LT:  case LTU:  case LE:  case LEU:\n     case UNEQ:  case LTGT:\n-    case UNGT:  case UNGE:  \n-    case UNLT:  case UNLE:  \n+    case UNGT:  case UNGE:\n+    case UNLT:  case UNLE:\n     case UNORDERED: case ORDERED:\n       /* If the first operand is a condition code, we can't do anything\n \t with it.  */\n@@ -4527,7 +4527,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n       }\n \n       break;\n-      \n+\n     default:\n       break;\n     }\n@@ -5579,7 +5579,7 @@ expand_compound_operation (x)\n \t  && GET_RTX_CLASS (GET_CODE (XEXP (XEXP (x, 0), 0))) == '<'\n \t  && (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))\n \t      <= HOST_BITS_PER_WIDE_INT)\n- \t  && ((HOST_WIDE_INT) STORE_FLAG_VALUE\n+\t  && ((HOST_WIDE_INT) STORE_FLAG_VALUE\n \t      & ~GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)\n \treturn XEXP (XEXP (x, 0), 0);\n \n@@ -5922,9 +5922,9 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \n \t      new = gen_rtx_SUBREG (tmode, inner, final_word);\n \t    }\n-  \t  else\n-  \t    new = inner;\n-  \t}\n+\t  else\n+\t    new = inner;\n+\t}\n       else\n \tnew = force_to_mode (inner, tmode,\n \t\t\t     len >= HOST_BITS_PER_WIDE_INT\n@@ -7418,7 +7418,7 @@ known_cond (x, cond, reg, val)\n \t      /* Do not reverse the condition when it is NE or EQ.\n \t\t This is because we cannot conclude anything about\n \t\t the value of 'SMAX (x, y)' when x is not equal to y,\n-\t\t but we can when x equals y.  */ \n+\t\t but we can when x equals y.  */\n \t      if ((code == SMAX || code == UMAX)\n \t\t  && ! (cond == EQ || cond == NE))\n \t\tcond = reverse_condition (cond);\n@@ -9717,7 +9717,6 @@ gen_lowpart_for_combine (mode, x)\n   if (GET_CODE (x) == MEM)\n     {\n       register int offset = 0;\n-      rtx new;\n \n       /* Refuse to work on a volatile memory ref or one with a mode-dependent\n \t address.  */\n@@ -10530,7 +10529,7 @@ simplify_comparison (code, pop0, pop1)\n \t\tnew_code = GET_CODE (op0);\n \t      else\n \t\tnew_code = combine_reversed_comparison_code (op0);\n-\t  \n+\n \t      if (new_code != UNKNOWN)\n \t\t{\n \t\t  code = new_code;"}, {"sha": "0251a65703ea883dd818cc83d08a41402f408c85", "filename": "gcc/gcov.c", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23190837c6b9b947cd9bcc80c28639bfb6d8a032/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23190837c6b9b947cd9bcc80c28639bfb6d8a032/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=23190837c6b9b947cd9bcc80c28639bfb6d8a032", "patch": "@@ -1,7 +1,7 @@\n /* Gcov.c: prepend line execution counts and branch probabilities to a\n    source file.\n    Copyright (C) 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by James E. Wilson of Cygnus Support.\n    Mangled by Bob Manson of Cygnus Support.\n \n@@ -218,7 +218,7 @@ static char *object_directory = 0;\n \n /* Output the number of times a branch was taken as opposed to the percentage\n    of times it was taken.  Turned on by the -c option */\n-   \n+\n static int output_branch_counts = 0;\n \n /* Forward declarations.  */\n@@ -438,7 +438,7 @@ open_files ()\n       fnotice (stderr, \"Could not open data file %s.\\n\", da_file_name);\n       fnotice (stderr, \"Assuming that all execution counts are zero.\\n\");\n     }\n-    \n+\n   bbg_file = fopen (bbg_file_name, \"rb\");\n   if (bbg_file == NULL)\n     {\n@@ -590,7 +590,7 @@ create_program_flow_graph (bptr)\n \t  bb_graph[arcptr->target].pred_count--;\n \t}\n }\n-  \n+\n static void\n solve_program_flow_graph (bptr)\n      struct bb_info_list *bptr;\n@@ -707,7 +707,7 @@ solve_program_flow_graph (bptr)\n \t    }\n \t}\n     }\n-\t      \n+\n   /* If the graph has been correctly solved, every block will have a\n      succ and pred count of zero.  */\n   for (i = 0; i < num_blocks; i++)\n@@ -772,7 +772,7 @@ read_files ()\n \n   bb_data = (char *) xmalloc ((unsigned) buf.st_size);\n   fread (bb_data, sizeof (char), buf.st_size, bb_file);\n-  \n+\n   fclose (bb_file);\n   if (da_file)\n     fclose (da_file);\n@@ -890,7 +890,7 @@ calculate_branch_probs (current_graph, block_num, branch_probs, last_line_num)\n \n       if (arcptr->fall_through)\n \tcontinue;\n-\t\t      \n+\n       a_ptr = (struct arcdata *) xmalloc (sizeof (struct arcdata));\n       a_ptr->total = total;\n       if (total == 0)\n@@ -1042,7 +1042,7 @@ output_data ()\n       if (output_branch_probs)\n \tbranch_probs = (struct arcdata **)\n \t  xcalloc (sizeof (struct arcdata *), s_ptr->maxlineno);\n-      \n+\n       /* There will be a zero at the beginning of the bb info, before the\n \t first list of line numbers, so must initialize block_num to 0.  */\n       block_num = 0;\n@@ -1066,7 +1066,7 @@ output_data ()\n \t\t  this_file = 0;\n \t\telse\n \t\t  this_file = 1;\n-\t      \n+\n \t\t/* Scan past the file name.  */\n \t\tdo {\n \t\t  count++;\n@@ -1139,7 +1139,7 @@ output_data ()\n \t\t\t     function_name);\n \t\t    abort ();\n \t\t  }\n-\t\t  \n+\n \t\tif (output_branch_probs && this_file)\n \t\t  calculate_branch_probs (current_graph, block_num,\n \t\t\t\t\t  branch_probs, last_line_num);\n@@ -1246,7 +1246,7 @@ output_data ()\n \t  /* Now the statistics are ready.  Read in the source file one line\n \t     at a time, and output that line to the gcov file preceded by\n \t     its execution count if non zero.  */\n-      \n+\n \t  source_file = fopen (source_file_name, \"r\");\n \t  if (source_file == NULL)\n \t    {\n@@ -1266,7 +1266,7 @@ output_data ()\n \t  if (output_long_names && strcmp (cptr, input_file_name))\n \t    {\n \t      gcov_file_name = xmalloc (count + 7 + strlen (input_file_name));\n-\t      \n+\n \t      cptr = strrchr (input_file_name, '/');\n \t      if (cptr)\n \t\tstrcpy (gcov_file_name, cptr + 1);\n@@ -1361,11 +1361,13 @@ output_data ()\n \t\t\t      {\n \t\t\t\tif (output_branch_counts)\n \t\t\t\t  fnotice (gcov_file,\n-\t\t\t\t           \"call %d returns = %d\\n\",\n+\t\t\t\t           \"call %d returns = \"\n+\t\t\t\t\t   HOST_WIDEST_INT_PRINT_DEC \"\\n\",\n \t\t\t\t           i, a_ptr->total - a_ptr->hits);\n \t\t\t        else\n                                   fnotice (gcov_file,\n-\t\t\t\t           \"call %d returns = %d%%\\n\",\n+\t\t\t\t           \"call %d returns = \"\n+\t\t\t\t\t   HOST_WIDEST_INT_PRINT_DEC \"%%\\n\",\n \t\t\t\t            i, 100 - ((a_ptr->hits * 100) +\n                                            (a_ptr->total >> 1))/a_ptr->total);\n \t\t\t      }\n@@ -1379,11 +1381,13 @@ output_data ()\n \t\t\t    {\n \t\t\t      if (output_branch_counts)\n \t\t\t        fnotice (gcov_file,\n-\t\t\t\t         \"branch %d taken = %d\\n\",\n+\t\t\t\t         \"branch %d taken = \"\n+\t\t\t\t\t HOST_WIDEST_INT_PRINT_DEC \"\\n\",\n                                          i, a_ptr->hits);\n \t\t\t      else\n                                 fnotice (gcov_file,\n-                                         \"branch %d taken = %d%%\\n\", i,\n+                                         \"branch %d taken = \"\n+\t\t\t\t\t HOST_WIDEST_INT_PRINT_DEC \"%%\\n\", i,\n                                          ((a_ptr->hits * 100) +\n                                           (a_ptr->total >> 1))/\n                                           a_ptr->total);"}, {"sha": "0ab29f747ab70436d1549a719c3bc360e7e6b274", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 55, "deletions": 48, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23190837c6b9b947cd9bcc80c28639bfb6d8a032/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23190837c6b9b947cd9bcc80c28639bfb6d8a032/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=23190837c6b9b947cd9bcc80c28639bfb6d8a032", "patch": "@@ -76,7 +76,7 @@ __addvsi3 (Wtype a, Wtype b)\n     abort ();\n \n   return w;\n-} \n+}\n #endif\n \f\n #ifdef L_addvdi3\n@@ -1069,7 +1069,7 @@ __floatdidf (DWtype u)\n \n /* Define codes for all the float formats that we know of.  Note\n    that this is copied from real.h.  */\n-   \n+\n #define UNKNOWN_FLOAT_FORMAT 0\n #define IEEE_FLOAT_FORMAT 1\n #define VAX_FLOAT_FORMAT 2\n@@ -1311,13 +1311,13 @@ char *ctime PARAMS ((const time_t *));\n \n static struct bb *bb_head;\n \n-static int num_digits (long value, int base) __attribute__ ((const));\n+static int num_digits (long long value, int base) __attribute__ ((const));\n \n /* Return the number of digits needed to print a value */\n-/* __inline__ */ static int num_digits (long value, int base)\n+/* __inline__ */ static int num_digits (long long value, int base)\n {\n   int minus = (value < 0 && base != 16);\n-  unsigned long v = (minus) ? -value : value;\n+  unsigned long long v = (minus) ? -value : value;\n   int ret = minus;\n \n   do\n@@ -1406,7 +1406,7 @@ __bb_exit_func (void)\n \t  else\n \t    {\n \t      long n_counts = 0;\n-\t      \n+\n \t      if (ungetc (firstchar, da_file) == EOF)\n \t\trewind (da_file);\n \t      if (__read_long (&n_counts, da_file, 8) != 0)\n@@ -1448,7 +1448,7 @@ __bb_exit_func (void)\n \n \t  if (__write_gcov_type (ptr->ncounts, da_file, 8) != 0)\n \t    {\n-\t      \n+\n \t      fprintf (stderr, \"arc profiling: Error writing output file %s.\\n\",\n \t\t       ptr->filename);\n \t    }\n@@ -1470,7 +1470,7 @@ __bb_exit_func (void)\n \t\tfprintf (stderr, \"arc profiling: Error writing output file %s.\\n\",\n \t\t\t ptr->filename);\n \t    }\n-\t  \n+\n \t  if (fclose (da_file) == EOF)\n \t    fprintf (stderr, \"arc profiling: Error closing output file %s.\\n\",\n \t\t     ptr->filename);\n@@ -1512,7 +1512,7 @@ __bb_exit_func (void)\n \t  int file_p\t= (func_p && ptr->filenames);\n \t  int addr_p\t= (ptr->addresses != 0);\n \t  long ncounts\t= ptr->ncounts;\n-\t  long cnt_max  = 0;\n+\t  gcov_type cnt_max  = 0;\n \t  long line_max = 0;\n \t  long addr_max = 0;\n \t  int file_len\t= 0;\n@@ -1564,10 +1564,17 @@ __bb_exit_func (void)\n \t  /* Now print out the basic block information.  */\n \t  for (i = 0; i < ncounts; i++)\n \t    {\n+#if LONG_TYPE_SIZE == GCOV_TYPE_SIZE\n \t      fprintf (file,\n \t\t       \"    Block #%*d: executed %*ld time(s)\",\n \t\t       blk_len, i+1,\n \t\t       cnt_len, ptr->counts[i]);\n+#else\n+\t      fprintf (file,\n+\t\t       \"    Block #%*d: executed %*lld time(s)\",\n+\t\t       blk_len, i+1,\n+\t\t       cnt_len, ptr->counts[i]);\n+#endif\n \n \t      if (addr_p)\n \t\tfprintf (file, \" address= 0x%.*lx\", addr_len,\n@@ -1677,7 +1684,7 @@ struct {\n   struct bb *blocks;\n } __bb;\n \n-/* Vars to store addrs of source and destination basic blocks \n+/* Vars to store addrs of source and destination basic blocks\n    of a jump.  */\n \n static unsigned long bb_src = 0;\n@@ -1727,7 +1734,7 @@ gopen (char *fn, char *mode)\n   if (mode[1])\n     return (FILE *) 0;\n \n-  if (mode[0] != 'r' && mode[0] != 'w') \n+  if (mode[0] != 'r' && mode[0] != 'w')\n     return (FILE *) 0;\n \n   p = fn + strlen (fn)-1;\n@@ -1791,7 +1798,7 @@ __bb_exit_trace_func (void)\n   FILE *file = fopen (\"bb.out\", \"a\");\n   struct bb_func *f;\n   struct bb *b;\n-        \n+\n   if (!file)\n     perror (\"bb.out\");\n \n@@ -1832,7 +1839,7 @@ __bb_exit_trace_func (void)\n                     goto found;\n                 }\n             }\n-  \n+\n           if (!printed_something)\n             {\n               fprintf (file, \"Functions in `bb.in' not executed during basic block profiling on %s\\n\", ctime ((void *) &time_value));\n@@ -1843,7 +1850,7 @@ __bb_exit_trace_func (void)\n           if (p->filename)\n               fprintf (file, \" of file %s\", p->filename);\n           fprintf (file, \"\\n\" );\n-  \n+\n found:        ;\n         }\n \n@@ -1863,7 +1870,7 @@ found:        ;\n             }\n           return;\n         }\n-    \n+\n       else if (file)\n         {\n           long time_value;\n@@ -1872,13 +1879,13 @@ found:        ;\n           unsigned long cnt_max  = 0;\n           int cnt_len;\n           int addr_len;\n-    \n+\n           /* This is somewhat type incorrect, but it avoids worrying about\n              exactly where time.h is included from.  It should be ok unless\n              a void * differs from other pointer formats, or if sizeof (long)\n              is < sizeof (time_t).  It would be nice if we could assume the\n              use of rationale standards here.  */\n-    \n+\n           time ((void *) &time_value);\n           fprintf (file, \"Basic block jump tracing\");\n \n@@ -1902,36 +1909,36 @@ found:        ;\n             }\n \n           fprintf (file, \" finished on %s\\n\", ctime ((void *) &time_value));\n-    \n+\n           for (i = 0; i < BB_BUCKETS; i++)\n             {\n                struct bb_edge *bucket = bb_hashbuckets[i];\n                for ( ; bucket; bucket = bucket->next )\n                  {\n-                   if (addr_max < bucket->src_addr) \n+                   if (addr_max < bucket->src_addr)\n                      addr_max = bucket->src_addr;\n-                   if (addr_max < bucket->dst_addr) \n+                   if (addr_max < bucket->dst_addr)\n                      addr_max = bucket->dst_addr;\n-                   if (cnt_max < bucket->count) \n+                   if (cnt_max < bucket->count)\n                      cnt_max = bucket->count;\n                  }\n             }\n           addr_len = num_digits (addr_max, 16);\n           cnt_len  = num_digits (cnt_max, 10);\n-    \n+\n           for ( i = 0; i < BB_BUCKETS; i++)\n             {\n                struct bb_edge *bucket = bb_hashbuckets[i];\n                for ( ; bucket; bucket = bucket->next )\n                  {\n                    fprintf (file,\n-\t\"Jump from block 0x%.*lx to block 0x%.*lx executed %*lu time(s)\\n\", \n-                            addr_len, bucket->src_addr, \n-                            addr_len, bucket->dst_addr, \n+\t\"Jump from block 0x%.*lx to block 0x%.*lx executed %*lu time(s)\\n\",\n+                            addr_len, bucket->src_addr,\n+                            addr_len, bucket->dst_addr,\n                             cnt_len, bucket->count);\n                  }\n             }\n-  \n+\n           fprintf (file, \"\\n\");\n \n         }\n@@ -2003,14 +2010,14 @@ __bb_init_prg (void)\n \tbuf[i--] = '\\0';\n \n       p = buf;\n-      if (*p == '-') \n-        { \n-          m = TRACE_OFF; \n-          p++; \n+      if (*p == '-')\n+        {\n+          m = TRACE_OFF;\n+          p++;\n         }\n-      else \n-        { \n-          m = TRACE_ON; \n+      else\n+        {\n+          m = TRACE_ON;\n         }\n       if (!strcmp (p, \"__bb_trace__\"))\n         bb_mode |= 1;\n@@ -2020,7 +2027,7 @@ __bb_init_prg (void)\n         bb_mode |= 4;\n       else if (!strcmp (p, \"__bb_showret__\"))\n         bb_mode |= 8;\n-      else \n+      else\n         {\n           struct bb_func *f = (struct bb_func *) malloc (sizeof (struct bb_func));\n           if (f)\n@@ -2055,7 +2062,7 @@ __bb_init_prg (void)\n     }\n   fclose (file);\n \n-#ifdef HAVE_POPEN \n+#ifdef HAVE_POPEN\n \n   if (bb_mode & 1)\n       bb_tracefile = gopen (\"bbtrace.gz\", \"w\");\n@@ -2069,7 +2076,7 @@ __bb_init_prg (void)\n \n   if (bb_mode & 2)\n     {\n-      bb_hashbuckets = (struct bb_edge **) \n+      bb_hashbuckets = (struct bb_edge **)\n                    malloc (BB_BUCKETS * sizeof (struct bb_edge *));\n       if (bb_hashbuckets)\n \t/* Use a loop here rather than calling bzero to avoid having to\n@@ -2116,7 +2123,7 @@ __bb_trace_func (void)\n \t= & bb_hashbuckets[ (((int) bb_src*8) ^ (int) bb_dst) % BB_BUCKETS ];\n       bucket = *startbucket;\n \n-      for (bucket = *startbucket; bucket; \n+      for (bucket = *startbucket; bucket;\n            oldnext = &(bucket->next), bucket = *oldnext)\n         {\n           if (bucket->src_addr == bb_src\n@@ -2179,7 +2186,7 @@ __bb_trace_func_ret (void)\n \t= & bb_hashbuckets[ (((int) bb_dst * 8) ^ (int) bb_src) % BB_BUCKETS ];\n       bucket = *startbucket;\n \n-      for (bucket = *startbucket; bucket; \n+      for (bucket = *startbucket; bucket;\n            oldnext = &(bucket->next), bucket = *oldnext)\n         {\n           if (bucket->src_addr == bb_dst\n@@ -2293,9 +2300,9 @@ __bb_init_trace_func (struct bb *blocks, unsigned long blockno)\n   MACHINE_STATE_SAVE(\"3\")\n \n   if (!blocks->zero_word)\n-    { \n+    {\n       if (!trace_init)\n-        { \n+        {\n           trace_init = 1;\n           __bb_init_prg ();\n         }\n@@ -2362,7 +2369,7 @@ void\n __clear_cache (char *beg __attribute__((__unused__)),\n \t       char *end __attribute__((__unused__)))\n {\n-#ifdef CLEAR_INSN_CACHE \n+#ifdef CLEAR_INSN_CACHE\n   CLEAR_INSN_CACHE (beg, end);\n #else\n #ifdef INSN_CACHE_SIZE\n@@ -2426,7 +2433,7 @@ __clear_cache (char *beg __attribute__((__unused__)),\n   /* Compute the cache alignment of the place to stop clearing.  */\n #if 0  /* This is not needed for gcc's purposes.  */\n   /* If the block to clear is bigger than a cache plane,\n-     we clear the entire cache, and OFFSET is already correct.  */ \n+     we clear the entire cache, and OFFSET is already correct.  */\n   if (end < beg + INSN_CACHE_PLANE_SIZE)\n #endif\n     offset = (((int) (end + INSN_CACHE_LINE_WIDTH - 1)\n@@ -2514,8 +2521,8 @@ mprotect (char *addr, int len, int prot)\n \n #endif /* WINNT && ! __CYGWIN__ && ! _UWIN */\n \n-#ifdef TRANSFER_FROM_TRAMPOLINE \n-TRANSFER_FROM_TRAMPOLINE \n+#ifdef TRANSFER_FROM_TRAMPOLINE\n+TRANSFER_FROM_TRAMPOLINE\n #endif\n \n #if defined (NeXT) && defined (__MACH__)\n@@ -2550,7 +2557,7 @@ __enable_execute_stack (char *addr)\n #else\n   __clear_cache ((int) addr, (int) eaddr);\n #endif\n-} \n+}\n \n #endif /* defined (NeXT) && defined (__MACH__) */\n \n@@ -2596,7 +2603,7 @@ __enable_execute_stack (void)\n   int save_errno;\n   static unsigned long lowest = USRSTACK;\n   unsigned long current = (unsigned long) &save_errno & -NBPC;\n-  \n+\n   /* Ignore errno being set. memctl sets errno to EINVAL whenever the\n      address is seen as 'negative'. That is the case with the stack.   */\n \n@@ -2650,7 +2657,7 @@ __clear_insn_cache (void)\n   errno changing without explicitly calling any system-call. */\n   save_errno = errno;\n \n-  /* Keep it simple : memctl (MCT_TEXT) always fully clears the insn cache. \n+  /* Keep it simple : memctl (MCT_TEXT) always fully clears the insn cache.\n      No need to use an address derived from _start or %sp, as 0 works also. */\n   memctl(0, 4096, MCT_TEXT);\n   errno = save_errno;\n@@ -2878,7 +2885,7 @@ atexit (func_ptr func)\n extern void _cleanup (void);\n extern void _exit (int) __attribute__ ((__noreturn__));\n \n-void \n+void\n exit (int status)\n {\n   if (atexit_chain)"}]}