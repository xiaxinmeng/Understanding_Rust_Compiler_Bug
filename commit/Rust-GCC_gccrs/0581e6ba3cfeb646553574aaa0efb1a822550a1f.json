{"sha": "0581e6ba3cfeb646553574aaa0efb1a822550a1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU4MWU2YmEzY2ZlYjY0NjU1MzU3NGFhYTBlZmIxYTgyMjU1MGExZg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2020-01-09T15:58:42Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2020-01-09T15:58:42Z"}, "message": "compiler: don't add composite literal keys to package bindings\n    \n    Adding composite literal keys to package bindings gets confusing when\n    it is combined with dot imports.  The test case showing the resulting\n    compilation failure is https://golang.org/cl/213899.\n    \n    Fix this by adding a new expression type to hold composite literal keys.\n    We shouldn't see it during lowering if it is a struct field name,\n    because Composite_literal_expression::do_traverse skips struct field names.\n    Or, it should, but that didn't quite work with pointer types so it had to\n    be tweaked.\n    \n    This lets us remove the code that recorded whether an Unknown_expression\n    is a composite literal key.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/214017\n\nFrom-SVN: r280056", "tree": {"sha": "fa419773d258339a511cb550a8739b57ca49d154", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa419773d258339a511cb550a8739b57ca49d154"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0581e6ba3cfeb646553574aaa0efb1a822550a1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0581e6ba3cfeb646553574aaa0efb1a822550a1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0581e6ba3cfeb646553574aaa0efb1a822550a1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0581e6ba3cfeb646553574aaa0efb1a822550a1f/comments", "author": null, "committer": null, "parents": [{"sha": "d6491d15676b0255eaaa4f5394fbb8ec7e3c6a5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6491d15676b0255eaaa4f5394fbb8ec7e3c6a5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6491d15676b0255eaaa4f5394fbb8ec7e3c6a5f"}], "stats": {"total": 134, "additions": 101, "deletions": 33}, "files": [{"sha": "500237671be1184d9abf00c87a8bfca96292966c", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0581e6ba3cfeb646553574aaa0efb1a822550a1f/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0581e6ba3cfeb646553574aaa0efb1a822550a1f/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=0581e6ba3cfeb646553574aaa0efb1a822550a1f", "patch": "@@ -1,4 +1,4 @@\n-e0790a756e9ba77e2d3d6ef5d0abbb11dd71211b\n+8ad32fb3e1e8b19ac125d03db24a73a800abdfa6\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "14bec9a427f065b88b2e1fc6a87a85832e44dfdd", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 78, "deletions": 7, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0581e6ba3cfeb646553574aaa0efb1a822550a1f/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0581e6ba3cfeb646553574aaa0efb1a822550a1f/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=0581e6ba3cfeb646553574aaa0efb1a822550a1f", "patch": "@@ -1761,8 +1761,6 @@ Unknown_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n       real = no->unknown_value()->real_named_object();\n       if (real == NULL)\n \t{\n-\t  if (this->is_composite_literal_key_)\n-\t    return this;\n \t  if (!this->no_error_message_)\n \t    go_error_at(location, \"reference to undefined name %qs\",\n \t\t\tthis->named_object_->message_name().c_str());\n@@ -1776,8 +1774,6 @@ Unknown_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n     case Named_object::NAMED_OBJECT_TYPE:\n       return Expression::make_type(real->type_value(), location);\n     case Named_object::NAMED_OBJECT_TYPE_DECLARATION:\n-      if (this->is_composite_literal_key_)\n-\treturn this;\n       if (!this->no_error_message_)\n \tgo_error_at(location, \"reference to undefined type %qs\",\n \t\t    real->message_name().c_str());\n@@ -1789,8 +1785,6 @@ Unknown_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n     case Named_object::NAMED_OBJECT_FUNC_DECLARATION:\n       return Expression::make_func_reference(real, NULL, location);\n     case Named_object::NAMED_OBJECT_PACKAGE:\n-      if (this->is_composite_literal_key_)\n-\treturn this;\n       if (!this->no_error_message_)\n \tgo_error_at(location, \"unexpected reference to package\");\n       return Expression::make_error(location);\n@@ -15992,6 +15986,77 @@ Map_construction_expression::do_dump_expression(\n   ast_dump_context->ostream() << \"}\";\n }\n \n+// A composite literal key.  This is seen during parsing, but is not\n+// resolved to a named_object in case this is a composite literal of\n+// struct type.\n+\n+class Composite_literal_key_expression : public Parser_expression\n+{\n+ public:\n+  Composite_literal_key_expression(const std::string& name, Location location)\n+    : Parser_expression(EXPRESSION_COMPOSITE_LITERAL_KEY, location),\n+      name_(name)\n+  { }\n+\n+  const std::string&\n+  name() const\n+  { return this->name_; }\n+\n+ protected:\n+  Expression*\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return new Composite_literal_key_expression(this->name_, this->location());\n+  }\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+ private:\n+  // The name.\n+  std::string name_;\n+};\n+\n+// Lower a composite literal key.  We will never get here for keys in\n+// composite literals of struct types, because that is prevented by\n+// Composite_literal_expression::do_traverse.  So if we do get here,\n+// this must be a regular name reference after all.\n+\n+Expression*\n+Composite_literal_key_expression::do_lower(Gogo* gogo, Named_object*,\n+\t\t\t\t\t   Statement_inserter*, int)\n+{\n+  Named_object* no = gogo->lookup(this->name_, NULL);\n+  if (no == NULL)\n+    {\n+      go_error_at(this->location(), \"reference to undefined name %qs\",\n+\t\t  Gogo::message_name(this->name_).c_str());\n+      return Expression::make_error(this->location());\n+    }\n+  return Expression::make_unknown_reference(no, this->location());\n+}\n+\n+// Dump a composite literal key.\n+\n+void\n+Composite_literal_key_expression::do_dump_expression(\n+    Ast_dump_context* ast_dump_context) const\n+{\n+  ast_dump_context->ostream() << \"_UnknownName_(\" << this->name_ << \")\";\n+}\n+\n+// Make a composite literal key.\n+\n+Expression*\n+Expression::make_composite_literal_key(const std::string& name,\n+\t\t\t\t       Location location)\n+{\n+  return new Composite_literal_key_expression(name, location);\n+}\n+\n // Class Composite_literal_expression.\n \n // Traversal.\n@@ -16013,6 +16078,7 @@ Composite_literal_expression::do_traverse(Traverse* traverse)\n \n       for (int depth = 0; depth < this->depth_; ++depth)\n         {\n+\t  type = type->deref();\n           if (type->array_type() != NULL)\n             type = type->array_type()->element_type();\n           else if (type->map_type() != NULL)\n@@ -16028,6 +16094,7 @@ Composite_literal_expression::do_traverse(Traverse* traverse)\n               return TRAVERSE_CONTINUE;\n             }\n         }\n+      type = type->deref();\n \n       while (true)\n \t{\n@@ -16186,6 +16253,11 @@ Composite_literal_expression::lower_struct(Gogo* gogo, Type* type)\n       const Named_object* no = NULL;\n       switch (name_expr->classification())\n \t{\n+\tcase EXPRESSION_COMPOSITE_LITERAL_KEY:\n+\t  name =\n+\t    static_cast<Composite_literal_key_expression*>(name_expr)->name();\n+\t  break;\n+\n \tcase EXPRESSION_UNKNOWN_REFERENCE:\n \t  name = name_expr->unknown_expression()->name();\n \t  if (type->named_type() != NULL)\n@@ -16593,7 +16665,6 @@ Composite_literal_expression::lower_map(Gogo* gogo, Named_object* function,\n \t  // literals.  Lower it now to get the right error message.\n \t  if ((*p)->unknown_expression() != NULL)\n \t    {\n-\t      (*p)->unknown_expression()->clear_is_composite_literal_key();\n \t      gogo->lower_expression(function, inserter, &*p);\n \t      go_assert((*p)->is_error_expression());\n \t      return Expression::make_error(location);"}, {"sha": "a4f892acaf782dcb68cc3bafd7906a6f0b8fec6e", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0581e6ba3cfeb646553574aaa0efb1a822550a1f/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0581e6ba3cfeb646553574aaa0efb1a822550a1f/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=0581e6ba3cfeb646553574aaa0efb1a822550a1f", "patch": "@@ -127,6 +127,7 @@ class Expression\n     EXPRESSION_SLICE_CONSTRUCTION,\n     EXPRESSION_MAP_CONSTRUCTION,\n     EXPRESSION_COMPOSITE_LITERAL,\n+    EXPRESSION_COMPOSITE_LITERAL_KEY,\n     EXPRESSION_HEAP,\n     EXPRESSION_RECEIVE,\n     EXPRESSION_TYPE_DESCRIPTOR,\n@@ -384,6 +385,10 @@ class Expression\n   make_composite_literal(Type*, int depth, bool has_keys, Expression_list*,\n \t\t\t bool all_are_names, Location);\n \n+  // Make a composite literal key.\n+  static Expression*\n+  make_composite_literal_key(const std::string& name, Location);\n+\n   // Make a struct composite literal.\n   static Expression*\n   make_struct_composite_literal(Type*, Expression_list*, Location);\n@@ -2881,8 +2886,7 @@ class Unknown_expression : public Parser_expression\n  public:\n   Unknown_expression(Named_object* named_object, Location location)\n     : Parser_expression(EXPRESSION_UNKNOWN_REFERENCE, location),\n-      named_object_(named_object), no_error_message_(false),\n-      is_composite_literal_key_(false)\n+      named_object_(named_object), no_error_message_(false)\n   { }\n \n   // The associated named object.\n@@ -2901,18 +2905,6 @@ class Unknown_expression : public Parser_expression\n   set_no_error_message()\n   { this->no_error_message_ = true; }\n \n-  // Note that this expression is being used as the key in a composite\n-  // literal, so it may be OK if it is not resolved.\n-  void\n-  set_is_composite_literal_key()\n-  { this->is_composite_literal_key_ = true; }\n-\n-  // Note that this expression should no longer be treated as a\n-  // composite literal key.\n-  void\n-  clear_is_composite_literal_key()\n-  { this->is_composite_literal_key_ = false; }\n-\n  protected:\n   Expression*\n   do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n@@ -2930,8 +2922,6 @@ class Unknown_expression : public Parser_expression\n   // True if we should not give errors if this is undefined.  This is\n   // used if there was a parse failure.\n   bool no_error_message_;\n-  // True if this is the key in a composite literal.\n-  bool is_composite_literal_key_;\n };\n \n // An index expression.  This is lowered to an array index, a string"}, {"sha": "084cdbfbb9c746ac7c26724eb790a1db5bd61569", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0581e6ba3cfeb646553574aaa0efb1a822550a1f/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0581e6ba3cfeb646553574aaa0efb1a822550a1f/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=0581e6ba3cfeb646553574aaa0efb1a822550a1f", "patch": "@@ -2200,7 +2200,7 @@ Parse::simple_var_decl_or_assignment(const std::string& name,\n \t       p != til.end();\n \t       ++p)\n \t    exprs->push_back(this->id_to_expression(p->name(), p->location(),\n-\t\t\t\t\t\t    true));\n+\t\t\t\t\t\t    true, false));\n \n \t  Expression_list* more_exprs =\n \t    this->expression_list(NULL, true, may_be_composite_lit);\n@@ -2820,7 +2820,7 @@ Parse::composite_lit(Type* type, int depth, Location location)\n \t      Gogo* gogo = this->gogo_;\n \t      val = this->id_to_expression(gogo->pack_hidden_name(identifier,\n \t\t\t\t\t\t\t\t  is_exported),\n-\t\t\t\t\t   id_location, false);\n+\t\t\t\t\t   id_location, false, true);\n \t      is_name = true;\n \t    }\n \t  else\n@@ -2877,9 +2877,6 @@ Parse::composite_lit(Type* type, int depth, Location location)\n \t    }\n \t  has_keys = true;\n \n-\t  if (val->unknown_expression() != NULL)\n-\t    val->unknown_expression()->set_is_composite_literal_key();\n-\n \t  vals->push_back(val);\n \n \t  if (!token->is_op(OPERATOR_LCURLY))\n@@ -3345,12 +3342,22 @@ Parse::call(Expression* func)\n \n Expression*\n Parse::id_to_expression(const std::string& name, Location location,\n-\t\t\tbool is_lhs)\n+\t\t\tbool is_lhs, bool is_composite_literal_key)\n {\n   Named_object* in_function;\n   Named_object* named_object = this->gogo_->lookup(name, &in_function);\n   if (named_object == NULL)\n-    named_object = this->gogo_->add_unknown_name(name, location);\n+    {\n+      if (is_composite_literal_key)\n+\t{\n+\t  // This is a composite literal key, which means that it\n+\t  // could just be a struct field name, so avoid confusiong by\n+\t  // not adding it to the bindings.  We'll look up the name\n+\t  // later during the lowering phase if necessary.\n+\t  return Expression::make_composite_literal_key(name, location);\n+\t}\n+      named_object = this->gogo_->add_unknown_name(name, location);\n+    }\n \n   if (in_function != NULL\n       && in_function != this->gogo_->current_function()\n@@ -5167,7 +5174,7 @@ Parse::send_or_recv_stmt(bool* is_send, Expression** channel, Expression** val,\n \n \t  *val = this->id_to_expression(gogo->pack_hidden_name(recv_var,\n \t\t\t\t\t\t\t       is_rv_exported),\n-\t\t\t\t\trecv_var_loc, true);\n+\t\t\t\t\trecv_var_loc, true, false);\n \t  saw_comma = true;\n \t}\n       else"}, {"sha": "4a5a4b8fbe4a8dba7b1c26fa811b30cf10f430ff", "filename": "gcc/go/gofrontend/parse.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0581e6ba3cfeb646553574aaa0efb1a822550a1f/gcc%2Fgo%2Fgofrontend%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0581e6ba3cfeb646553574aaa0efb1a822550a1f/gcc%2Fgo%2Fgofrontend%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.h?ref=0581e6ba3cfeb646553574aaa0efb1a822550a1f", "patch": "@@ -231,7 +231,7 @@ class Parse\n \t\t\t bool* is_type_switch, bool* is_parenthesized);\n   Type* reassociate_chan_direction(Channel_type*, Location);\n   Expression* qualified_expr(Expression*, Location);\n-  Expression* id_to_expression(const std::string&, Location, bool);\n+  Expression* id_to_expression(const std::string&, Location, bool, bool);\n   void statement(Label*);\n   bool statement_may_start_here();\n   void labeled_stmt(const std::string&, Location);"}]}