{"sha": "7256233c7a1637bf3880bc71ece8c5d3f327d518", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI1NjIzM2M3YTE2MzdiZjM4ODBiYzcxZWNlOGM1ZDNmMzI3ZDUxOA==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2005-02-24T14:18:46Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2005-02-24T14:18:46Z"}, "message": "* tree-into-ssa.c: Re-organize internal functions.\n\nFrom-SVN: r95499", "tree": {"sha": "cf57b3ab2d2da29b087ffa80f065b57ce00c5fe4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf57b3ab2d2da29b087ffa80f065b57ce00c5fe4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7256233c7a1637bf3880bc71ece8c5d3f327d518", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7256233c7a1637bf3880bc71ece8c5d3f327d518", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7256233c7a1637bf3880bc71ece8c5d3f327d518", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7256233c7a1637bf3880bc71ece8c5d3f327d518/comments", "author": null, "committer": null, "parents": [{"sha": "f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a"}], "stats": {"total": 1814, "additions": 916, "deletions": 898}, "files": [{"sha": "a367dbd1ef7ce24e74f2f93e96b6b44b76f1a7a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7256233c7a1637bf3880bc71ece8c5d3f327d518/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7256233c7a1637bf3880bc71ece8c5d3f327d518/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7256233c7a1637bf3880bc71ece8c5d3f327d518", "patch": "@@ -1,3 +1,7 @@\n+2005-02-24  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-into-ssa.c: Re-organize internal functions.\n+\n 2005-02-24  Richard Henderson  <rth@redhat.com>\n \n \tPR middle-end/18902"}, {"sha": "bdc7623e87ff73fefc4a612044069643ac4443f7", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 912, "deletions": 898, "changes": 1810, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7256233c7a1637bf3880bc71ece8c5d3f327d518/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7256233c7a1637bf3880bc71ece8c5d3f327d518/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=7256233c7a1637bf3880bc71ece8c5d3f327d518", "patch": "@@ -54,7 +54,6 @@ Boston, MA 02111-1307, USA.  */\n    Graph. ACM Transactions on Programming Languages and Systems,\n    13(4):451-490, October 1991.  */\n \n-\n /* Structure to map a variable VAR to the set of blocks that contain\n    definitions for VAR.  */\n struct def_blocks_d\n@@ -66,14 +65,15 @@ struct def_blocks_d\n      Ith block contains a definition of VAR.  */\n   bitmap def_blocks;\n \n-  /* Blocks that contain a phi node for VAR.  */\n+  /* Blocks that contain a PHI node for VAR.  */\n   bitmap phi_blocks;\n \n   /* Blocks where VAR is live-on-entry.  Similar semantics as\n      DEF_BLOCKS.  */\n   bitmap livein_blocks;\n };\n \n+\n /* Each entry in DEF_BLOCKS contains an element of type STRUCT\n    DEF_BLOCKS_D, mapping a variable VAR to a bitmap describing all the\n    basic blocks where VAR is defined (assigned a new value).  It also\n@@ -87,19 +87,18 @@ static htab_t def_blocks;\n    state after completing rewriting of a block and its dominator children.\n \n    This vector is used in two contexts.  The first is rewriting of _DECL\n-   nodes into SSA_NAMEs.  In that context it's elements have the\n+   nodes into SSA_NAMEs.  In that context its elements have the\n    following properties:\n \n      An SSA_NAME indicates that the current definition of the underlying\n      variable should be set to the given SSA_NAME.\n-                                                                                \n+\n      A _DECL node indicates that the underlying variable has no current\n      definition.\n-                                                                                \n+\n      A NULL node is used to mark the last node associated with the\n      current block. \n \n-\n    This vector is also used when rewriting an SSA_NAME which has multiple\n    definition sites into multiple SSA_NAMEs.  In that context entries come\n    in pairs.\n@@ -127,8 +126,8 @@ struct mark_def_sites_global_data\n   sbitmap names_to_rename;\n };\n \n-/* Information stored for ssa names.  */\n \n+/* Information stored for ssa names.  */\n struct ssa_name_info\n {\n   /* This field indicates whether or not the variable may need PHI nodes.\n@@ -140,31 +139,6 @@ struct ssa_name_info\n   tree current_def;\n };\n \n-/* Local functions.  */\n-static void rewrite_finalize_block (struct dom_walk_data *, basic_block);\n-static void rewrite_initialize_block (struct dom_walk_data *, basic_block);\n-static void rewrite_add_phi_arguments (struct dom_walk_data *, basic_block);\n-static void mark_def_sites (struct dom_walk_data *walk_data,\n-\t\t\t    basic_block bb, block_stmt_iterator);\n-static void mark_def_sites_initialize_block (struct dom_walk_data *walk_data,\n-\t\t\t\t\t     basic_block bb);\n-static void set_def_block (tree, basic_block, bool, bool);\n-static void set_livein_block (tree, basic_block);\n-static bool prepare_use_operand_for_rename (use_operand_p, size_t *uid_p);\n-static bool prepare_def_operand_for_rename (tree def, size_t *uid_p);\n-static void insert_phi_nodes (bitmap *, bitmap);\n-static void rewrite_stmt (struct dom_walk_data *, basic_block,\n-\t\t\t  block_stmt_iterator);\n-static inline void rewrite_operand (use_operand_p);\n-static void insert_phi_nodes_for (tree, bitmap *, VEC(basic_block) **);\n-static tree get_reaching_def (tree);\n-static hashval_t def_blocks_hash (const void *);\n-static int def_blocks_eq (const void *, const void *);\n-static void def_blocks_free (void *);\n-static int debug_def_blocks_r (void **, void *);\n-static inline struct def_blocks_d *get_def_blocks_for (tree);\n-static inline struct def_blocks_d *find_def_blocks_for (tree);\n-static void htab_statistics (FILE *, htab_t);\n \n /* Use TREE_VISITED to keep track of which statements we want to\n    rename.  When renaming a subset of the variables, not all\n@@ -183,6 +157,7 @@ get_ssa_name_ann (tree name)\n   return SSA_NAME_AUX (name);\n }\n \n+\n /* Gets phi_state field for VAR.  */\n \n static inline enum need_phi_state\n@@ -194,6 +169,7 @@ get_phi_state (tree var)\n     return var_ann (var)->need_phi_state;\n }\n \n+\n /* Sets phi_state field for VAR to STATE.  */\n \n static inline void\n@@ -205,6 +181,7 @@ set_phi_state (tree var, enum need_phi_state state)\n     var_ann (var)->need_phi_state = state;\n }\n \n+\n /* Return the current definition for VAR.  */\n \n static inline tree\n@@ -216,6 +193,7 @@ get_current_def (tree var)\n     return var_ann (var)->current_def;\n }\n \n+\n /* Sets current definition of VAR to DEF.  */\n \n static inline void\n@@ -227,6 +205,7 @@ set_current_def (tree var, tree def)\n     var_ann (var)->current_def = def;\n }\n \n+\n /* Compute global livein information given the set of blockx where\n    an object is locally live at the start of the block (LIVEIN)\n    and the set of blocks where the object is defined (DEF_BLOCKS).\n@@ -280,215 +259,45 @@ compute_global_livein (bitmap livein, bitmap def_blocks)\n }\n \n \n-/* Block initialization routine for mark_def_sites.  Clear the \n-   KILLS bitmap at the start of each block.  */\n-\n-static void\n-mark_def_sites_initialize_block (struct dom_walk_data *walk_data,\n-\t\t\t\t basic_block bb ATTRIBUTE_UNUSED)\n-{\n-  struct mark_def_sites_global_data *gd = walk_data->global_data;\n-  bitmap kills = gd->kills;\n-\n-  bitmap_clear (kills);\n-}\n-\n-/* Block initialization routine for mark_def_sites.  Clear the \n-   KILLS bitmap at the start of each block.  */\n-\n-static void\n-ssa_mark_def_sites_initialize_block (struct dom_walk_data *walk_data,\n-\t\t\t\t     basic_block bb)\n-{\n-  struct mark_def_sites_global_data *gd = walk_data->global_data;\n-  bitmap kills = gd->kills;\n-  tree phi, def;\n-  unsigned def_uid;\n-\n-  bitmap_clear (kills);\n-\n-  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-    {\n-      def = PHI_RESULT (phi);\n-      def_uid = SSA_NAME_VERSION (def);\n-\n-      if (!TEST_BIT (gd->names_to_rename, def_uid))\n-\tcontinue;\n-\n-      set_def_block (def, bb, true, true);\n-      bitmap_set_bit (kills, def_uid);\n-    }\n-}\n-\n-/* Marks ssa names used as arguments of phis at the end of BB.  */\n-\n-static void\n-ssa_mark_phi_uses (struct dom_walk_data *walk_data, basic_block bb)\n-{\n-  struct mark_def_sites_global_data *gd = walk_data->global_data;\n-  bitmap kills = gd->kills;\n-  edge e;\n-  tree phi, use;\n-  unsigned uid;\n-  edge_iterator ei;\n-\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    {\n-      if (e->dest == EXIT_BLOCK_PTR)\n-\tcontinue;\n-\n-      for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  use = PHI_ARG_DEF_FROM_EDGE (phi, e);\n-\t  if (TREE_CODE (use) != SSA_NAME)\n-\t    continue;\n-\n-\t  uid = SSA_NAME_VERSION (use);\n-\n-\t  if (TEST_BIT (gd->names_to_rename, uid)\n-\t      && !bitmap_bit_p (kills, uid))\n-\t    set_livein_block (use, bb);\n-\t}\n-    }\n-}\n-\n-/* Call back for walk_dominator_tree used to collect definition sites\n-   for every variable in the function.  For every statement S in block\n-   BB:\n-\n-   1- Variables defined by S in DEF_OPS(S) are marked in the bitmap\n-      WALK_DATA->GLOBAL_DATA->KILLS.\n-\n-   2- If S uses a variable VAR and there is no preceding kill of VAR,\n-      then it is marked in marked in the LIVEIN_BLOCKS bitmap\n-      associated with VAR.\n-\n-   This information is used to determine which variables are live\n-   across block boundaries to reduce the number of PHI nodes\n-   we create.  */\n+/* Return the set of blocks where variable VAR is defined and the blocks\n+   where VAR is live on entry (livein).  If no entry is found in\n+   DEF_BLOCKS, a new one is created and returned.  */\n \n-static void\n-mark_def_sites (struct dom_walk_data *walk_data,\n-\t\tbasic_block bb,\n-\t\tblock_stmt_iterator bsi)\n+static inline struct def_blocks_d *\n+get_def_blocks_for (tree var)\n {\n-  struct mark_def_sites_global_data *gd = walk_data->global_data;\n-  bitmap kills = gd->kills;\n-  size_t uid;\n-  tree stmt, def;\n-  use_operand_p use_p;\n-  def_operand_p def_p;\n-  ssa_op_iter iter;\n-\n-  /* Mark all the blocks that have definitions for each variable in the\n-     VARS_TO_RENAME bitmap.  */\n-  stmt = bsi_stmt (bsi);\n-  get_stmt_operands (stmt);\n-\n-  REWRITE_THIS_STMT (stmt) = 0;\n-\n-  /* If a variable is used before being set, then the variable is live\n-     across a block boundary, so mark it live-on-entry to BB.  */\n+  struct def_blocks_d db, *db_p;\n+  void **slot;\n \n-  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter,\n-\t\t\t    SSA_OP_USE | SSA_OP_VUSE | SSA_OP_VMUSTDEFKILL)\n-    {\n-      if (prepare_use_operand_for_rename (use_p, &uid))\n-\t{\n-\t  REWRITE_THIS_STMT (stmt) = 1;\n-\t  if (!bitmap_bit_p (kills, uid))\n-\t    set_livein_block (USE_FROM_PTR (use_p), bb);\n-\t}\n-    }\n-  \n-  /* Note that virtual definitions are irrelevant for computing KILLS\n-     because a V_MAY_DEF does not constitute a killing definition of the\n-     variable.  However, the operand of a virtual definitions is a use\n-     of the variable, so it may cause the variable to be considered\n-     live-on-entry.  */\n-  FOR_EACH_SSA_MAYDEF_OPERAND (def_p, use_p, stmt, iter)\n+  db.var = var;\n+  slot = htab_find_slot (def_blocks, (void *) &db, INSERT);\n+  if (*slot == NULL)\n     {\n-      if (prepare_use_operand_for_rename (use_p, &uid))\n-\t{\n-\t  /* If we do not already have an SSA_NAME for our destination,\n-\t     then set the destination to the source.  */\n-\t  if (TREE_CODE (DEF_FROM_PTR (def_p)) != SSA_NAME)\n-\t    SET_DEF (def_p, USE_FROM_PTR (use_p));\n-\t    \n-          set_livein_block (USE_FROM_PTR (use_p), bb);\n-\t  set_def_block (DEF_FROM_PTR (def_p), bb, false, false);\n-\t  REWRITE_THIS_STMT (stmt) = 1;\n-\t}\n+      db_p = xmalloc (sizeof (*db_p));\n+      db_p->var = var;\n+      db_p->def_blocks = BITMAP_ALLOC (NULL);\n+      db_p->phi_blocks = BITMAP_ALLOC (NULL);\n+      db_p->livein_blocks = BITMAP_ALLOC (NULL);\n+      *slot = (void *) db_p;\n     }\n+  else\n+    db_p = (struct def_blocks_d *) *slot;\n \n-  /* Now process the defs and must-defs made by this statement.  */\n-  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF | SSA_OP_VMUSTDEF)\n-    {\n-      if (prepare_def_operand_for_rename (def, &uid))\n-\t{\n-\t  set_def_block (def, bb, false, false);\n-\t  bitmap_set_bit (kills, uid);\n-\t  REWRITE_THIS_STMT (stmt) = 1;\n-\t}\n-    }\n+  return db_p;\n }\n \n \n-/* Same as mark_def_sites, but works over SSA names.  */\n-\n-static void\n-ssa_mark_def_sites (struct dom_walk_data *walk_data,\n-\t\t    basic_block bb,\n-\t\t    block_stmt_iterator bsi)\n-{\n-  struct mark_def_sites_global_data *gd = walk_data->global_data;\n-  bitmap kills = gd->kills;\n-  size_t uid, def_uid;\n-  tree stmt, use, def;\n-  ssa_op_iter iter;\n-\n-  /* Mark all the blocks that have definitions for each variable in the\n-     names_to_rename bitmap.  */\n-  stmt = bsi_stmt (bsi);\n-  get_stmt_operands (stmt);\n-\n-  /* If a variable is used before being set, then the variable is live\n-     across a block boundary, so mark it live-on-entry to BB.  */\n-  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_ALL_USES | SSA_OP_ALL_KILLS)\n-    {\n-      uid = SSA_NAME_VERSION (use);\n-\n-      if (TEST_BIT (gd->names_to_rename, uid)\n-\t  && !bitmap_bit_p (kills, uid))\n-\tset_livein_block (use, bb);\n-    }\n-\t  \n-  /* Now process the definition made by this statement.  Mark the\n-     variables in KILLS.  */\n-  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n-    {\n-      def_uid = SSA_NAME_VERSION (def);\n-\n-      if (TEST_BIT (gd->names_to_rename, def_uid))\n-\t{\n-\t  set_def_block (def, bb, false, true);\n-\t  bitmap_set_bit (kills, def_uid);\n-\t}\n-    }\n-}\n-\n /* Mark block BB as the definition site for variable VAR.  PHI_P is true if\n-   VAR is defined by a phi node.  SSA_P is true if we are called from\n-   rewrite_ssa_into_ssa.  */\n+   VAR is defined by a PHI node.  IS_UPDATE is true if the caller is\n+   updating an existing SSA form.  */\n \n static void\n-set_def_block (tree var, basic_block bb, bool phi_p, bool ssa_p)\n+set_def_block (tree var, basic_block bb, bool phi_p, bool is_update)\n {\n   struct def_blocks_d *db_p;\n   enum need_phi_state state;\n \n-  if (!ssa_p\n-      && TREE_CODE (var) == SSA_NAME)\n+  if (!is_update && TREE_CODE (var) == SSA_NAME)\n     var = SSA_NAME_VAR (var);\n \n   state = get_phi_state (var);\n@@ -499,11 +308,11 @@ set_def_block (tree var, basic_block bb, bool phi_p, bool ssa_p)\n   if (phi_p)\n     bitmap_set_bit (db_p->phi_blocks, bb->index);\n \n-  /* Keep track of whether or not we may need to insert phi nodes.\n+  /* Keep track of whether or not we may need to insert PHI nodes.\n \n      If we are in the UNKNOWN state, then this is the first definition\n      of VAR.  Additionally, we have not seen any uses of VAR yet, so\n-     we do not need a phi node for this variable at this time (i.e.,\n+     we do not need a PHI node for this variable at this time (i.e.,\n      transition to NEED_PHI_STATE_NO).\n \n      If we are in any other state, then we either have multiple definitions\n@@ -531,7 +340,7 @@ set_livein_block (tree var, basic_block bb)\n   /* Set the bit corresponding to the block where VAR is live in.  */\n   bitmap_set_bit (db_p->livein_blocks, bb->index);\n \n-  /* Keep track of whether or not we may need to insert phi nodes.\n+  /* Keep track of whether or not we may need to insert PHI nodes.\n \n      If we reach here in NEED_PHI_STATE_NO, see if this use is dominated\n      by the single block containing the definition(s) of this variable.  If\n@@ -579,6 +388,7 @@ prepare_use_operand_for_rename (use_operand_p op_p, size_t *uid_p)\n   return true;\n }\n \n+\n /* If the def variable DEF needs to be renamed, then strip away any SSA_NAME \n    wrapping the operand, set *UID_P to the underlying variable's uid and return\n    true.  Otherwise return false.  */\n@@ -596,66 +406,299 @@ prepare_def_operand_for_rename (tree def, size_t *uid_p)\n   return true;\n }\n \n-/* Helper for insert_phi_nodes.  If VAR needs PHI nodes, insert them\n-   at the dominance frontier (DFS) of blocks defining VAR.\n-   WORK_STACK is the vector used to implement the worklist of basic\n-   blocks.  */\n-\n-static inline void\n-insert_phi_nodes_1 (tree var, bitmap *dfs, VEC(basic_block) **work_stack)\n-{\n-  if (get_phi_state (var) != NEED_PHI_STATE_NO)\n-    insert_phi_nodes_for (var, dfs, work_stack);\n-}\n \n-/* Insert PHI nodes at the dominance frontier of blocks with variable\n-   definitions.  DFS contains the dominance frontier information for\n-   the flowgraph.  PHI nodes will only be inserted at the dominance\n-   frontier of definition blocks for variables whose NEED_PHI_STATE\n-   annotation is marked as ``maybe'' or ``unknown'' (computed by\n-   mark_def_sites).  If NAMES_TO_RENAME is not NULL, do the same but\n-   for ssa name rewriting.  */\n+/* Call back for walk_dominator_tree used to collect definition sites\n+   for every variable in the function.  For every statement S in block\n+   BB:\n \n-static void\n-insert_phi_nodes (bitmap *dfs, bitmap names_to_rename)\n-{\n-  unsigned i;\n-  VEC(basic_block) *work_stack;\n-  bitmap_iterator bi;\n+   1- Variables defined by S in DEF_OPS(S) are marked in the bitmap\n+      WALK_DATA->GLOBAL_DATA->KILLS.\n \n-  timevar_push (TV_TREE_INSERT_PHI_NODES);\n+   2- If S uses a variable VAR and there is no preceding kill of VAR,\n+      then it is marked in marked in the LIVEIN_BLOCKS bitmap\n+      associated with VAR.\n \n-  /* Vector WORK_STACK is a stack of CFG blocks.  Each block that contains\n-     an assignment or PHI node will be pushed to this stack.  */\n-  work_stack = VEC_alloc (basic_block, n_basic_blocks);\n+   This information is used to determine which variables are live\n+   across block boundaries to reduce the number of PHI nodes\n+   we create.  */\n \n-  /* Iterate over all variables in VARS_TO_RENAME.  For each variable, add\n-     to the work list all the blocks that have a definition for the\n+static void\n+mark_def_sites (struct dom_walk_data *walk_data,\n+\t\tbasic_block bb,\n+\t\tblock_stmt_iterator bsi)\n+{\n+  struct mark_def_sites_global_data *gd = walk_data->global_data;\n+  bitmap kills = gd->kills;\n+  size_t uid;\n+  tree stmt, def;\n+  use_operand_p use_p;\n+  def_operand_p def_p;\n+  ssa_op_iter iter;\n+\n+  /* Mark all the blocks that have definitions for each variable in the\n+     VARS_TO_RENAME bitmap.  */\n+  stmt = bsi_stmt (bsi);\n+  get_stmt_operands (stmt);\n+\n+  REWRITE_THIS_STMT (stmt) = 0;\n+\n+  /* If a variable is used before being set, then the variable is live\n+     across a block boundary, so mark it live-on-entry to BB.  */\n+\n+  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter,\n+\t\t\t    SSA_OP_USE | SSA_OP_VUSE | SSA_OP_VMUSTDEFKILL)\n+    {\n+      if (prepare_use_operand_for_rename (use_p, &uid))\n+\t{\n+\t  REWRITE_THIS_STMT (stmt) = 1;\n+\t  if (!bitmap_bit_p (kills, uid))\n+\t    set_livein_block (USE_FROM_PTR (use_p), bb);\n+\t}\n+    }\n+  \n+  /* Note that virtual definitions are irrelevant for computing KILLS\n+     because a V_MAY_DEF does not constitute a killing definition of the\n+     variable.  However, the operand of a virtual definitions is a use\n+     of the variable, so it may cause the variable to be considered\n+     live-on-entry.  */\n+  FOR_EACH_SSA_MAYDEF_OPERAND (def_p, use_p, stmt, iter)\n+    {\n+      if (prepare_use_operand_for_rename (use_p, &uid))\n+\t{\n+\t  /* If we do not already have an SSA_NAME for our destination,\n+\t     then set the destination to the source.  */\n+\t  if (TREE_CODE (DEF_FROM_PTR (def_p)) != SSA_NAME)\n+\t    SET_DEF (def_p, USE_FROM_PTR (use_p));\n+\t    \n+          set_livein_block (USE_FROM_PTR (use_p), bb);\n+\t  set_def_block (DEF_FROM_PTR (def_p), bb, false, false);\n+\t  REWRITE_THIS_STMT (stmt) = 1;\n+\t}\n+    }\n+\n+  /* Now process the defs and must-defs made by this statement.  */\n+  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF | SSA_OP_VMUSTDEF)\n+    {\n+      if (prepare_def_operand_for_rename (def, &uid))\n+\t{\n+\t  set_def_block (def, bb, false, false);\n+\t  bitmap_set_bit (kills, uid);\n+\t  REWRITE_THIS_STMT (stmt) = 1;\n+\t}\n+    }\n+}\n+\n+\n+/* Given a set of blocks with variable definitions (DEF_BLOCKS),\n+   return a bitmap with all the blocks in the iterated dominance\n+   frontier of the blocks in DEF_BLOCKS.  DFS contains dominance\n+   frontier information as returned by compute_dominance_frontiers.\n+   \n+   The resulting set of blocks are the potential sites where PHI nodes\n+   are needed.  The caller is responsible from freeing the memory\n+   allocated for the return value.  */\n+\n+static bitmap\n+find_idf (bitmap def_blocks, bitmap *dfs)\n+{\n+  bitmap_iterator bi;\n+  unsigned bb_index;\n+  VEC(basic_block) *work_stack;\n+  bitmap phi_insertion_points;\n+\n+  work_stack = VEC_alloc (basic_block, n_basic_blocks);\n+  phi_insertion_points = BITMAP_ALLOC (NULL);\n+\n+  /* Seed the work list with all the blocks in DEF_BLOCKS.  */\n+  EXECUTE_IF_SET_IN_BITMAP (def_blocks, 0, bb_index, bi)\n+    VEC_safe_push (basic_block, work_stack, BASIC_BLOCK (bb_index));\n+\n+  /* Pop a block off the worklist, add every block that appears in\n+     the original block's DF that we have not already processed to\n+     the worklist.  Iterate until the worklist is empty.   Blocks\n+     which are added to the worklist are potential sites for\n+     PHI nodes.  */\n+  while (VEC_length (basic_block, work_stack) > 0)\n+    {\n+      basic_block bb = VEC_pop (basic_block, work_stack);\n+      bb_index = bb->index;\n+      \n+      EXECUTE_IF_AND_COMPL_IN_BITMAP (dfs[bb_index], phi_insertion_points,\n+\t\t\t\t      0, bb_index, bi)\n+\t{\n+\t  bb = BASIC_BLOCK (bb_index);\n+\n+\t  /* Use a safe push because if there is a definition of VAR\n+\t     in every basic block, then WORK_STACK may eventually have\n+\t     more than N_BASIC_BLOCK entries.  */\n+\t  VEC_safe_push (basic_block, work_stack, bb);\n+\t  bitmap_set_bit (phi_insertion_points, bb_index);\n+\t}\n+    }\n+\n+  VEC_free (basic_block, work_stack);\n+\n+  return phi_insertion_points;\n+}\n+\n+\n+/* Return the set of blocks where variable VAR is defined and the blocks\n+   where VAR is live on entry (livein).  Return NULL, if no entry is\n+   found in DEF_BLOCKS.  */\n+\n+static inline struct def_blocks_d *\n+find_def_blocks_for (tree var)\n+{\n+  struct def_blocks_d dm;\n+  dm.var = var;\n+  return (struct def_blocks_d *) htab_find (def_blocks, &dm);\n+}\n+\n+\n+/* Insert PHI nodes for variable VAR using the iterated dominance\n+   frontier given in PHI_INSERTION_POINTS.  */\n+\n+static void\n+insert_phi_nodes_for (tree var, bitmap phi_insertion_points)\n+{\n+  unsigned bb_index;\n+  edge e;\n+  tree phi;\n+  basic_block bb;\n+  bitmap_iterator bi;\n+  struct def_blocks_d *def_map;\n+\n+  def_map = find_def_blocks_for (var);\n+\n+  /* Remove the blocks where we already have PHI nodes for VAR.  */\n+  bitmap_and_compl_into (phi_insertion_points, def_map->phi_blocks);\n+\n+  /* Now compute global livein for this variable.  Note this modifies\n+     def_map->livein_blocks.  */\n+  compute_global_livein (def_map->livein_blocks, def_map->def_blocks);\n+\n+  /* And insert the PHI nodes.  */\n+  EXECUTE_IF_AND_IN_BITMAP (phi_insertion_points, def_map->livein_blocks,\n+\t\t\t    0, bb_index, bi)\n+    {\n+      bb = BASIC_BLOCK (bb_index);\n+      phi = create_phi_node (var, bb);\n+\n+      /* If we are rewriting SSA names, add also the PHI arguments.  */\n+      if (TREE_CODE (var) == SSA_NAME)\n+\t{\n+\t  edge_iterator ei;\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    add_phi_arg (phi, var, e);\n+\t}\n+\n+      /* Mark this PHI node as interesting for the rename process.  */\n+      REWRITE_THIS_STMT (phi) = 1;\n+    }\n+}\n+\n+\n+/* Helper for insert_phi_nodes.  If VAR needs PHI nodes, insert them\n+   at the dominance frontier (DFS) of blocks defining VAR.  */\n+\n+static inline void\n+insert_phi_nodes_1 (tree var, bitmap *dfs)\n+{\n+  struct def_blocks_d *def_map;\n+  bitmap idf;\n+\n+  def_map = find_def_blocks_for (var);\n+  if (def_map == NULL)\n+    return;\n+\n+  idf = find_idf (def_map->def_blocks, dfs);\n+\n+  if (get_phi_state (var) != NEED_PHI_STATE_NO)\n+    insert_phi_nodes_for (var, idf);\n+\n+  BITMAP_FREE (idf);\n+}\n+\n+\n+/* Insert PHI nodes at the dominance frontier of blocks with variable\n+   definitions.  DFS contains the dominance frontier information for\n+   the flowgraph.  PHI nodes will only be inserted at the dominance\n+   frontier of definition blocks for variables whose NEED_PHI_STATE\n+   annotation is marked as ``maybe'' or ``unknown'' (computed by\n+   mark_def_sites).  If NAMES_TO_RENAME is not NULL, do the same but\n+   for ssa name rewriting.  */\n+\n+static void\n+insert_phi_nodes (bitmap *dfs, bitmap names_to_rename)\n+{\n+  unsigned i;\n+  bitmap_iterator bi;\n+\n+  timevar_push (TV_TREE_INSERT_PHI_NODES);\n+\n+  /* Iterate over all variables in VARS_TO_RENAME.  For each variable, add\n+     to the work list all the blocks that have a definition for the\n      variable.  PHI nodes will be added to the dominance frontier blocks of\n      each definition block.  */\n   if (names_to_rename)\n     {\n       EXECUTE_IF_SET_IN_BITMAP (names_to_rename, 0, i, bi)\n-\t{\n-\t  if (ssa_name (i))\n-\t    insert_phi_nodes_1 (ssa_name (i), dfs, &work_stack);\n-\t}\n+\tif (ssa_name (i))\n+\t  insert_phi_nodes_1 (ssa_name (i), dfs);\n     }\n   else if (vars_to_rename)\n-    EXECUTE_IF_SET_IN_BITMAP (vars_to_rename, 0, i, bi)\n-      {\n-\tinsert_phi_nodes_1 (referenced_var (i), dfs, &work_stack);\n-      }\n+    {\n+      EXECUTE_IF_SET_IN_BITMAP (vars_to_rename, 0, i, bi)\n+\tinsert_phi_nodes_1 (referenced_var (i), dfs);\n+    }\n   else\n-    for (i = 0; i < num_referenced_vars; i++)\n-      insert_phi_nodes_1 (referenced_var (i), dfs, &work_stack);\n-\n-  VEC_free (basic_block, work_stack);\n+    {\n+      for (i = 0; i < num_referenced_vars; i++)\n+\tinsert_phi_nodes_1 (referenced_var (i), dfs);\n+    }\n \n   timevar_pop (TV_TREE_INSERT_PHI_NODES);\n }\n \n \n+/* Register DEF (an SSA_NAME) to be a new definition for its underlying\n+   variable (SSA_NAME_VAR (DEF)) and push VAR's current reaching definition\n+   into the stack pointed by BLOCK_DEFS_P.  */\n+\n+void\n+register_new_def (tree def, VEC (tree_on_heap) **block_defs_p)\n+{\n+  tree var = SSA_NAME_VAR (def);\n+  tree currdef;\n+   \n+  /* If this variable is set in a single basic block and all uses are\n+     dominated by the set(s) in that single basic block, then there is\n+     no reason to record anything for this variable in the block local\n+     definition stacks.  Doing so just wastes time and memory.\n+\n+     This is the same test to prune the set of variables which may\n+     need PHI nodes.  So we just use that information since it's already\n+     computed and available for us to use.  */\n+  if (get_phi_state (var) == NEED_PHI_STATE_NO)\n+    {\n+      set_current_def (var, def);\n+      return;\n+    }\n+\n+  currdef = get_current_def (var);\n+\n+  /* Push the current reaching definition into *BLOCK_DEFS_P.  This stack is\n+     later used by the dominator tree callbacks to restore the reaching\n+     definitions for all the variables defined in the block after a recursive\n+     visit to all its immediately dominated blocks.  If there is no current\n+     reaching definition, then just record the underlying _DECL node.  */\n+  VEC_safe_push (tree_on_heap, *block_defs_p, currdef ? currdef : var);\n+\n+  /* Set the current reaching definition for VAR to be DEF.  */\n+  set_current_def (var, def);\n+}\n+\n+\n /* Perform a depth-first traversal of the dominator tree looking for\n    variables to rename.  BB is the block where to start searching.\n    Renaming is a five step process:\n@@ -702,84 +745,124 @@ rewrite_initialize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n     {\n       tree result = PHI_RESULT (phi);\n-\n-      register_new_def (result, &block_defs_stack);\n+      if (REWRITE_THIS_STMT (phi))\n+\tregister_new_def (result, &block_defs_stack);\n     }\n }\n \n-/* Register DEF (an SSA_NAME) to be a new definition for the original\n-   ssa name VAR and push VAR's current reaching definition\n-   into the stack pointed by BLOCK_DEFS_P.  */\n-\n-static void\n-ssa_register_new_def (tree var, tree def)\n-{\n-  tree currdef;\n-   \n-  /* If this variable is set in a single basic block and all uses are\n-     dominated by the set(s) in that single basic block, then there is\n-     nothing to do.  TODO we should not be called at all, and just\n-     keep the original name.  */\n-  if (get_phi_state (var) == NEED_PHI_STATE_NO)\n-    {\n-      set_current_def (var, def);\n-      return;\n-    }\n \n-  currdef = get_current_def (var);\n+/* Return the current definition for variable VAR.  If none is found,\n+   create a new SSA name to act as the zeroth definition for VAR.  If VAR\n+   is call clobbered and there exists a more recent definition of\n+   GLOBAL_VAR, return the definition for GLOBAL_VAR.  This means that VAR\n+   has been clobbered by a function call since its last assignment.  */\n \n-  /* Push the current reaching definition into *BLOCK_DEFS_P.  This stack is\n-     later used by the dominator tree callbacks to restore the reaching\n-     definitions for all the variables defined in the block after a recursive\n-     visit to all its immediately dominated blocks.  */\n-  VEC_safe_push (tree_on_heap, block_defs_stack, currdef);\n-  VEC_safe_push (tree_on_heap, block_defs_stack, var);\n+static tree\n+get_reaching_def (tree var)\n+{\n+  tree default_d, currdef_var, avar;\n+  \n+  /* Lookup the current reaching definition for VAR.  */\n+  default_d = NULL_TREE;\n+  currdef_var = get_current_def (var);\n \n-  /* Set the current reaching definition for VAR to be DEF.  */\n-  set_current_def (var, def);\n+  /* If there is no reaching definition for VAR, create and register a\n+     default definition for it (if needed).  */\n+  if (currdef_var == NULL_TREE)\n+    {\n+      if (TREE_CODE (var) == SSA_NAME)\n+\tavar = SSA_NAME_VAR (var);\n+      else\n+\tavar = var;\n+\n+      default_d = default_def (avar);\n+      if (default_d == NULL_TREE)\n+\t{\n+\t  default_d = make_ssa_name (avar, build_empty_stmt ());\n+\t  set_default_def (avar, default_d);\n+\t}\n+      set_current_def (var, default_d);\n+    }\n+\n+  /* Return the current reaching definition for VAR, or the default\n+     definition, if we had to create one.  */\n+  return (currdef_var) ? currdef_var : default_d;\n }\n \n-/* Ditto, for rewriting ssa names.  */\n+\n+/* Replace the operand pointed by OP_P with its immediate reaching\n+   definition.  */\n+\n+static inline void\n+rewrite_operand (use_operand_p op_p)\n+{\n+  tree var = USE_FROM_PTR (op_p);\n+  if (TREE_CODE (var) != SSA_NAME)\n+    SET_USE (op_p, get_reaching_def (var));\n+  else\n+    {\n+#if defined ENABLE_CHECKING\n+      /* If we get to this point, VAR is an SSA_NAME.  If VAR's symbol\n+\t was marked for renaming, make sure that its reaching\n+\t definition is VAR itself.  Otherwise, something has gone\n+\t wrong.  */\n+      tree sym = SSA_NAME_VAR (var);\n+      if (bitmap_bit_p (vars_to_rename, var_ann (sym)->uid))\n+\tgcc_assert (var == get_reaching_def (SSA_NAME_VAR (var)));\n+#endif\n+    }\n+}\n+\n+\n+/* SSA Rewriting Step 2.  Rewrite every variable used in each statement in\n+   the block with its immediate reaching definitions.  Update the current\n+   definition of a variable when a new real or virtual definition is found.  */\n \n static void\n-ssa_rewrite_initialize_block (struct dom_walk_data *walk_data, basic_block bb)\n+rewrite_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t      basic_block bb ATTRIBUTE_UNUSED,\n+\t      block_stmt_iterator si)\n {\n-  tree phi, new_name;\n-  sbitmap names_to_rename = walk_data->global_data;\n-  edge e;\n-  bool abnormal_phi;\n-  edge_iterator ei;\n+  stmt_ann_t ann;\n+  tree stmt;\n+  use_operand_p use_p;\n+  def_operand_p def_p;\n+  ssa_op_iter iter;\n+\n+  stmt = bsi_stmt (si);\n+  ann = stmt_ann (stmt);\n+\n+  /* If mark_def_sites decided that we don't need to rewrite this\n+     statement, ignore it.  */\n+  if (!REWRITE_THIS_STMT (stmt))\n+    return;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\n\\nRenaming block #%d\\n\\n\", bb->index);\n+    {\n+      fprintf (dump_file, \"Renaming statement \");\n+      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+      fprintf (dump_file, \"\\n\");\n+    }\n \n-  /* Mark the unwind point for this block.  */\n-  VEC_safe_push (tree_on_heap, block_defs_stack, NULL_TREE);\n+  get_stmt_operands (stmt);\n \n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    if (e->flags & EDGE_ABNORMAL)\n-      break;\n-  abnormal_phi = (e != NULL);\n+  /* Step 1.  Rewrite USES and VUSES in the statement.  */\n+  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES | SSA_OP_ALL_KILLS)\n+    rewrite_operand (use_p);\n \n-  /* Step 1.  Register new definitions for every PHI node in the block.\n-     Conceptually, all the PHI nodes are executed in parallel and each PHI\n-     node introduces a new version for the associated variable.  */\n-  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+  /* Step 2.  Register the statement's DEF and VDEF operands.  */\n+  FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_ALL_DEFS)\n     {\n-      tree result = PHI_RESULT (phi);\n-\n-      if (TEST_BIT (names_to_rename, SSA_NAME_VERSION (result)))\n-\t{\n-\t  new_name = duplicate_ssa_name (result, phi);\n-\t  SET_PHI_RESULT (phi, new_name);\n+      if (TREE_CODE (DEF_FROM_PTR (def_p)) != SSA_NAME)\n+\tSET_DEF (def_p, make_ssa_name (DEF_FROM_PTR (def_p), stmt));\n \n-\t  if (abnormal_phi)\n-\t    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (new_name) = 1;\n-\t  ssa_register_new_def (result, new_name);\n-\t}\n+      /* FIXME: We shouldn't be registering new defs if the variable\n+\t doesn't need to be renamed.  */\n+      register_new_def (DEF_FROM_PTR (def_p), &block_defs_stack);\n     }\n }\n \n+\n /* SSA Rewriting Step 3.  Visit all the successor blocks of BB looking for\n    PHI nodes.  For every PHI node found, add a new argument containing the\n    current reaching definition for the variable and the edge through which\n@@ -812,9 +895,10 @@ rewrite_add_phi_arguments (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n     }\n }\n \n+\n /*  Rewrite existing virtual PHI arguments so that they have the correct\n     reaching definitions.  BB is the basic block whose successors contain the\n-    phi nodes we want to add arguments for.  */\n+    PHI nodes we want to add arguments for.  */\n \n static void\n rewrite_virtual_phi_arguments (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n@@ -848,42 +932,10 @@ rewrite_virtual_phi_arguments (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n     }\n }\n \n-/* Ditto, for ssa name rewriting.  */\n-\n-static void\n-ssa_rewrite_phi_arguments (struct dom_walk_data *walk_data, basic_block bb)\n-{\n-  edge e;\n-  sbitmap names_to_rename = walk_data->global_data;\n-  use_operand_p op;\n-  edge_iterator ei;\n-\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    {\n-      tree phi;\n-\n-      if (e->dest == EXIT_BLOCK_PTR)\n-\tcontinue;\n-\n-      for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  op = PHI_ARG_DEF_PTR_FROM_EDGE (phi, e);\n-\t  if (TREE_CODE (USE_FROM_PTR (op)) != SSA_NAME)\n-\t    continue;\n-\t  \n-\t  if (!TEST_BIT (names_to_rename, SSA_NAME_VERSION (USE_FROM_PTR (op))))\n-\t    continue; \n-\n-\t  SET_USE (op, get_reaching_def (USE_FROM_PTR (op)));\n-\t  if (e->flags & EDGE_ABNORMAL)\n-\t    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (USE_FROM_PTR (op)) = 1;\n-\t}\n-    }\n-}\n \n+/* Called after visiting basic block BB.  Restore CURRDEFS to its\n+   original value.  */\n \n-/* Similar to restore_vars_to_original_value, except that it restores \n-   CURRDEFS to its original value.  */\n static void\n rewrite_finalize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \t\t\tbasic_block bb ATTRIBUTE_UNUSED)\n@@ -916,28 +968,6 @@ rewrite_finalize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n     }\n }\n \n-/* Ditto, for rewriting ssa names.  */\n-\n-static void\n-ssa_rewrite_finalize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t\t    basic_block bb ATTRIBUTE_UNUSED)\n-{\n-\n-  /* Step 5.  Restore the current reaching definition for each variable\n-     referenced in the block (in reverse order).  */\n-  while (VEC_length (tree_on_heap, block_defs_stack) > 0)\n-    {\n-      tree var = VEC_pop (tree_on_heap, block_defs_stack);\n-      tree saved_def;\n-      \n-      if (var == NULL)\n-\tbreak;\n-\n-      saved_def = VEC_pop (tree_on_heap, block_defs_stack);\n-\n-      set_current_def (var, saved_def);\n-    }\n-}\n \n /* Dump SSA information to FILE.  */\n \n@@ -969,6 +999,18 @@ debug_tree_ssa (void)\n }\n \n \n+/* Dump statistics for the hash table HTAB.  */\n+\n+static void\n+htab_statistics (FILE *file, htab_t htab)\n+{\n+  fprintf (file, \"size %ld, %ld elements, %f collision/search ratio\\n\",\n+\t   (long) htab_size (htab),\n+\t   (long) htab_elements (htab),\n+\t   htab_collisions (htab));\n+}\n+\n+\n /* Dump SSA statistics on FILE.  */\n \n void\n@@ -992,656 +1034,653 @@ debug_tree_ssa_stats (void)\n }\n \n \n-/* Dump statistics for the hash table HTAB.  */\n+/* Hashing and equality functions for DEF_BLOCKS.  */\n \n-static void\n-htab_statistics (FILE *file, htab_t htab)\n+static hashval_t\n+def_blocks_hash (const void *p)\n {\n-  fprintf (file, \"size %ld, %ld elements, %f collision/search ratio\\n\",\n-\t   (long) htab_size (htab),\n-\t   (long) htab_elements (htab),\n-\t   htab_collisions (htab));\n+  return htab_hash_pointer\n+\t((const void *)((const struct def_blocks_d *)p)->var);\n+}\n+\n+static int\n+def_blocks_eq (const void *p1, const void *p2)\n+{\n+  return ((const struct def_blocks_d *)p1)->var\n+\t == ((const struct def_blocks_d *)p2)->var;\n }\n \n \n-/* Insert PHI nodes for variable VAR using the dominance frontier\n-   information given in DFS.  WORK_STACK is the vector used to\n-   implement the worklist of basic blocks.  */\n+/* Free memory allocated by one entry in DEF_BLOCKS.  */\n \n static void\n-insert_phi_nodes_for (tree var, bitmap *dfs, VEC(basic_block) **work_stack)\n+def_blocks_free (void *p)\n {\n-  struct def_blocks_d *def_map;\n-  bitmap phi_insertion_points;\n-  unsigned bb_index;\n-  edge e;\n-  tree phi;\n-  basic_block bb;\n-  bitmap_iterator bi;\n-\n-  def_map = find_def_blocks_for (var);\n-  if (def_map == NULL)\n-    return;\n+  struct def_blocks_d *entry = p;\n+  BITMAP_FREE (entry->def_blocks);\n+  BITMAP_FREE (entry->phi_blocks);\n+  BITMAP_FREE (entry->livein_blocks);\n+  free (entry);\n+}\n \n-  phi_insertion_points = BITMAP_ALLOC (NULL);\n \n-  EXECUTE_IF_SET_IN_BITMAP (def_map->def_blocks, 0, bb_index, bi)\n-    {\n-      VEC_safe_push (basic_block, *work_stack, BASIC_BLOCK (bb_index));\n-    }\n+/* Callback for htab_traverse to dump the DEF_BLOCKS hash table.  */\n \n-  /* Pop a block off the worklist, add every block that appears in\n-     the original block's dfs that we have not already processed to\n-     the worklist.  Iterate until the worklist is empty.   Blocks\n-     which are added to the worklist are potential sites for\n-     PHI nodes. \n+static int\n+debug_def_blocks_r (void **slot, void *data ATTRIBUTE_UNUSED)\n+{\n+  struct def_blocks_d *db_p = (struct def_blocks_d *) *slot;\n+  \n+  fprintf (stderr, \"VAR: \");\n+  print_generic_expr (stderr, db_p->var, dump_flags);\n+  bitmap_print (stderr, db_p->def_blocks, \", DEF_BLOCKS: { \", \"}\");\n+  bitmap_print (stderr, db_p->livein_blocks, \", LIVEIN_BLOCKS: { \", \"}\\n\");\n \n-     The iteration step could be done during PHI insertion just as\n-     easily.  We do it here for historical reasons -- we used to have\n-     a heuristic which used the potential PHI insertion points to\n-     determine if fully pruned or semi pruned SSA form was appropriate.\n+  return 1;\n+}\n \n-     We now always use fully pruned SSA form.  */\n-  while (VEC_length (basic_block, *work_stack) > 0)\n-    {\n-      unsigned dfs_index;\n-      bitmap_iterator bi;\n \n-      bb = VEC_pop (basic_block, *work_stack);\n-      bb_index = bb->index;\n-      \n-      EXECUTE_IF_AND_COMPL_IN_BITMAP (dfs[bb_index],\n-\t\t\t\t      phi_insertion_points,\n-\t\t\t\t      0, dfs_index, bi)\n-\t{\n-\t  basic_block bb = BASIC_BLOCK (dfs_index);\n+/* Dump the DEF_BLOCKS hash table on stderr.  */\n \n-\t  /* Use a safe push because if there is a definition of VAR\n-\t     in every basic block, then WORK_STACK may eventually have\n-\t     more than N_BASIC_BLOCK entries.  */\n-\t  VEC_safe_push (basic_block, *work_stack, bb);\n-\t  bitmap_set_bit (phi_insertion_points, dfs_index);\n-\t}\n-    }\n+void\n+debug_def_blocks (void)\n+{\n+  htab_traverse (def_blocks, debug_def_blocks_r, NULL);\n+}\n \n-  /* Remove the blocks where we already have the phis.  */\n-  bitmap_and_compl_into (phi_insertion_points, def_map->phi_blocks);\n \n-  /* Now compute global livein for this variable.  Note this modifies\n-     def_map->livein_blocks.  */\n-  compute_global_livein (def_map->livein_blocks, def_map->def_blocks);\n+/* If a variable V in VARS_TO_RENAME is a pointer, the renaming\n+   process will cause us to lose the name memory tags that may have\n+   been associated with the various SSA_NAMEs of V.  This means that\n+   the variables aliased to those name tags also need to be renamed\n+   again.\n \n-  /* And insert the PHI nodes.  */\n-  EXECUTE_IF_AND_IN_BITMAP (phi_insertion_points, def_map->livein_blocks,\n-\t\t\t    0, bb_index, bi)\n-    {\n-      bb = BASIC_BLOCK (bb_index);\n+   FIXME 1- We should either have a better scheme for renaming\n+\t    pointers that doesn't lose name tags or re-run alias\n+\t    analysis to recover points-to information.\n \n-      phi = create_phi_node (var, bb);\n+\t 2- Currently we just invalidate *all* the name tags.  This\n+\t    should be more selective.  */\n \n-      /* If we are rewriting ssa names, add also the phi arguments.  */\n-      if (TREE_CODE (var) == SSA_NAME)\n+static void\n+invalidate_name_tags (bitmap vars_to_rename)\n+{\n+  unsigned i;\n+  bool rename_name_tags_p;\n+  bitmap_iterator bi;\n+\n+  rename_name_tags_p = false;\n+  EXECUTE_IF_SET_IN_BITMAP (vars_to_rename, 0, i, bi)\n+    {\n+      if (POINTER_TYPE_P (TREE_TYPE (referenced_var (i))))\n \t{\n-\t  edge_iterator ei;\n-\t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t    add_phi_arg (phi, var, e);\n+\t  rename_name_tags_p = true;\n+\t  break;\n \t}\n     }\n \n-  BITMAP_FREE (phi_insertion_points);\n+  if (rename_name_tags_p)\n+    for (i = 0; i < num_referenced_vars; i++)\n+      {\n+\tvar_ann_t ann = var_ann (referenced_var (i));\n+\n+\tif (ann->mem_tag_kind == NAME_TAG)\n+\t  {\n+\t    size_t j;\n+\t    varray_type may_aliases = ann->may_aliases;\n+\n+\t    bitmap_set_bit (vars_to_rename, ann->uid);\n+\t    if (ann->may_aliases)\n+\t      for (j = 0; j < VARRAY_ACTIVE_SIZE (may_aliases); j++)\n+\t\t{\n+\t\t  tree var = VARRAY_TREE (may_aliases, j);\n+\t\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n+\t\t}\n+\t  }\n+      }\n }\n \n-/* SSA Rewriting Step 2.  Rewrite every variable used in each statement in\n-   the block with its immediate reaching definitions.  Update the current\n-   definition of a variable when a new real or virtual definition is found.  */\n+\n+/* Rewrite the actual blocks, statements, and PHI arguments, to be in SSA\n+   form.  FIX_VIRTUAL_PHIS is true if we should only be fixing up virtual\n+   PHI arguments, instead of adding new PHI arguments for just added PHI\n+   nodes.  */\n \n static void\n-rewrite_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t      basic_block bb ATTRIBUTE_UNUSED,\n-\t      block_stmt_iterator si)\n+rewrite_blocks (bool fix_virtual_phis)\n {\n-  stmt_ann_t ann;\n-  tree stmt;\n-  use_operand_p use_p;\n-  def_operand_p def_p;\n-  ssa_op_iter iter;\n+  struct dom_walk_data walk_data;\n+  \n+  /* Rewrite all the basic blocks in the program.  */\n+  timevar_push (TV_TREE_SSA_REWRITE_BLOCKS);\n \n-  stmt = bsi_stmt (si);\n-  ann = stmt_ann (stmt);\n+  /* Setup callbacks for the generic dominator tree walker.  */\n+  walk_data.walk_stmts_backward = false;\n+  walk_data.dom_direction = CDI_DOMINATORS;\n+  walk_data.initialize_block_local_data = NULL;\n+  walk_data.before_dom_children_before_stmts = rewrite_initialize_block;\n+  walk_data.before_dom_children_walk_stmts = rewrite_stmt;\n+  walk_data.before_dom_children_after_stmts = NULL;\n+  if (!fix_virtual_phis)\n+    walk_data.before_dom_children_after_stmts = rewrite_add_phi_arguments;\n+  else\n+    walk_data.before_dom_children_after_stmts = rewrite_virtual_phi_arguments;\n+  \n+  walk_data.after_dom_children_before_stmts =  NULL;\n+  walk_data.after_dom_children_walk_stmts =  NULL;\n+  walk_data.after_dom_children_after_stmts =  rewrite_finalize_block;\n+  walk_data.global_data = NULL;\n+  walk_data.block_local_data_size = 0;\n \n-  /* If mark_def_sites decided that we don't need to rewrite this\n-     statement, ignore it.  */\n-  if (!REWRITE_THIS_STMT (stmt))\n-    return;\n+  block_defs_stack = VEC_alloc (tree_on_heap, 10);\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"Renaming statement \");\n-      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n-      fprintf (dump_file, \"\\n\");\n-    }\n+  /* Initialize the dominator walker.  */\n+  init_walk_dominator_tree (&walk_data);\n \n-  /* We have just scanned the code for operands.  No statement should\n-     be modified.  */\n-  gcc_assert (!ann->modified);\n+  /* Recursively walk the dominator tree rewriting each statement in\n+     each basic block.  */\n+  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n \n-  /* Step 1.  Rewrite USES and VUSES in the statement.  */\n-  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES | SSA_OP_ALL_KILLS)\n-    rewrite_operand (use_p);\n+  /* Finalize the dominator walker.  */\n+  fini_walk_dominator_tree (&walk_data);\n \n-  /* Step 2.  Register the statement's DEF and VDEF operands.  */\n-  FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_ALL_DEFS)\n+  /* Debugging dumps.  */\n+  if (dump_file && (dump_flags & TDF_STATS))\n     {\n-      if (TREE_CODE (DEF_FROM_PTR (def_p)) != SSA_NAME)\n-\tSET_DEF (def_p, make_ssa_name (DEF_FROM_PTR (def_p), stmt));\n-\n-      /* FIXME: We shouldn't be registering new defs if the variable\n-\t doesn't need to be renamed.  */\n-      register_new_def (DEF_FROM_PTR (def_p), &block_defs_stack);\n+      dump_dfa_stats (dump_file);\n+      dump_tree_ssa_stats (dump_file);\n     }\n+\n+  htab_delete (def_blocks);\n+  def_blocks = NULL;\n+  \n+  VEC_free (tree_on_heap, block_defs_stack);\n+  block_defs_stack = NULL;\n+\n+  timevar_pop (TV_TREE_SSA_REWRITE_BLOCKS);\n }\n \n \n-/* Same as rewrite_stmt, for rewriting ssa names.  */\n+/* Block initialization routine for mark_def_sites.  Clear the \n+   KILLS bitmap at the start of each block.  */\n \n static void\n-ssa_rewrite_stmt (struct dom_walk_data *walk_data,\n-\t\t  basic_block bb ATTRIBUTE_UNUSED,\n-\t\t  block_stmt_iterator si)\n+mark_def_sites_initialize_block (struct dom_walk_data *walk_data,\n+\t\t\t\t basic_block bb ATTRIBUTE_UNUSED)\n {\n-  stmt_ann_t ann;\n-  tree stmt, var;\n-  ssa_op_iter iter;\n-  use_operand_p use_p;\n-  def_operand_p def_p;\n-  sbitmap names_to_rename = walk_data->global_data;\n+  struct mark_def_sites_global_data *gd = walk_data->global_data;\n+  bitmap kills = gd->kills;\n+  bitmap_clear (kills);\n+}\n \n-  stmt = bsi_stmt (si);\n-  ann = stmt_ann (stmt);\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"Renaming statement \");\n-      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n-      fprintf (dump_file, \"\\n\");\n-    }\n+/* Mark the definition site blocks for each variable, so that we know where\n+   the variable is actually live.  */\n \n-  /* We have just scanned the code for operands.  No statement should\n-     be modified.  */\n-  gcc_assert (!ann->modified);\n+static void \n+mark_def_site_blocks (void)\n+{\n+  size_t i;\n+  struct dom_walk_data walk_data;\n+  struct mark_def_sites_global_data mark_def_sites_global_data;\n \n-  /* Step 1.  Rewrite USES and VUSES in the statement.  */\n-  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES | SSA_OP_ALL_KILLS)\n-    {\n-      if (TEST_BIT (names_to_rename, SSA_NAME_VERSION (USE_FROM_PTR (use_p))))\n-\tSET_USE (use_p, get_reaching_def (USE_FROM_PTR (use_p)));\n-    }\n+  /* Allocate memory for the DEF_BLOCKS hash table.  */\n+  def_blocks = htab_create (VARRAY_ACTIVE_SIZE (referenced_vars),\n+\t\t\t    def_blocks_hash, def_blocks_eq, def_blocks_free);\n \n-  /* Step 2.  Register the statement's DEF and VDEF operands.  */\n-  FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_ALL_DEFS)\n-    {\n-      var = DEF_FROM_PTR (def_p);\n+  for (i = 0; i < num_referenced_vars; i++)\n+    set_current_def (referenced_var (i), NULL_TREE);\n \n-      if (!TEST_BIT (names_to_rename, SSA_NAME_VERSION (var)))\n-\tcontinue;\n+  /* Ensure that the dominance information is OK.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n \n-      SET_DEF (def_p, duplicate_ssa_name (var, stmt));\n-      ssa_register_new_def (var, DEF_FROM_PTR (def_p));\n-    }\n-}\n+  /* Setup callbacks for the generic dominator tree walker to find and\n+     mark definition sites.  */\n+  walk_data.walk_stmts_backward = false;\n+  walk_data.dom_direction = CDI_DOMINATORS;\n+  walk_data.initialize_block_local_data = NULL;\n+  walk_data.before_dom_children_before_stmts = mark_def_sites_initialize_block;\n+  walk_data.before_dom_children_walk_stmts = mark_def_sites;\n+  walk_data.before_dom_children_after_stmts = NULL; \n+  walk_data.after_dom_children_before_stmts =  NULL;\n+  walk_data.after_dom_children_walk_stmts =  NULL;\n+  walk_data.after_dom_children_after_stmts =  NULL;\n \n-/* Replace the operand pointed by OP_P with its immediate reaching\n-   definition.  */\n+  /* Notice that this bitmap is indexed using variable UIDs, so it must be\n+     large enough to accommodate all the variables referenced in the\n+     function, not just the ones we are renaming.  */\n+  mark_def_sites_global_data.kills = BITMAP_ALLOC (NULL);\n+  walk_data.global_data = &mark_def_sites_global_data;\n \n-static inline void\n-rewrite_operand (use_operand_p op_p)\n-{\n-  tree var = USE_FROM_PTR (op_p);\n-  if (TREE_CODE (var) != SSA_NAME)\n-    SET_USE (op_p, get_reaching_def (var));\n-  else\n-    {\n-#if defined ENABLE_CHECKING\n-      /* If we get to this point, VAR is an SSA_NAME.  If VAR's symbol\n-\t was marked for renaming, make sure that its reaching\n-\t definition is VAR itself.  Otherwise, something has gone\n-\t wrong.  */\n-      tree sym = SSA_NAME_VAR (var);\n-      if (bitmap_bit_p (vars_to_rename, var_ann (sym)->uid))\n-\tgcc_assert (var == get_reaching_def (SSA_NAME_VAR (var)));\n-#endif\n-    }\n+  /* We do not have any local data.  */\n+  walk_data.block_local_data_size = 0;\n+\n+  /* Initialize the dominator walker.  */\n+  init_walk_dominator_tree (&walk_data);\n+\n+  /* Recursively walk the dominator tree.  */\n+  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n+\n+  /* Finalize the dominator walker.  */\n+  fini_walk_dominator_tree (&walk_data);\n+\n+  /* We no longer need this bitmap, clear and free it.  */\n+  BITMAP_FREE (mark_def_sites_global_data.kills);\n }\n \n-/* Register DEF (an SSA_NAME) to be a new definition for its underlying\n-   variable (SSA_NAME_VAR (DEF)) and push VAR's current reaching definition\n-   into the stack pointed by BLOCK_DEFS_P.  */\n \n-void\n-register_new_def (tree def, VEC (tree_on_heap) **block_defs_p)\n-{\n-  tree var = SSA_NAME_VAR (def);\n-  tree currdef;\n-   \n-  /* If this variable is set in a single basic block and all uses are\n-     dominated by the set(s) in that single basic block, then there is\n-     no reason to record anything for this variable in the block local\n-     definition stacks.  Doing so just wastes time and memory.\n+/* Main entry point into the SSA builder.  The renaming process\n+   proceeds in five main phases:\n \n-     This is the same test to prune the set of variables which may\n-     need PHI nodes.  So we just use that information since it's already\n-     computed and available for us to use.  */\n-  if (get_phi_state (var) == NEED_PHI_STATE_NO)\n-    {\n-      set_current_def (var, def);\n-      return;\n-    }\n+   1- If VARS_TO_RENAME has any entries, any existing PHI nodes for\n+      those variables are removed from the flow graph so that they can\n+      be computed again.\n \n-  currdef = get_current_def (var);\n+   2- Compute dominance frontier and immediate dominators, needed to\n+      insert PHI nodes and rename the function in dominator tree\n+      order.\n \n-  /* Push the current reaching definition into *BLOCK_DEFS_P.  This stack is\n-     later used by the dominator tree callbacks to restore the reaching\n-     definitions for all the variables defined in the block after a recursive\n-     visit to all its immediately dominated blocks.  If there is no current\n-     reaching definition, then just record the underlying _DECL node.  */\n-  VEC_safe_push (tree_on_heap, *block_defs_p, currdef ? currdef : var);\n+   3- Find and mark all the blocks that define variables\n+      (mark_def_site_blocks).\n \n-  /* Set the current reaching definition for VAR to be DEF.  */\n-  set_current_def (var, def);\n-}\n+   4- Insert PHI nodes at dominance frontiers (insert_phi_nodes).\n \n-/* Return the current definition for variable VAR.  If none is found,\n-   create a new SSA name to act as the zeroth definition for VAR.  If VAR\n-   is call clobbered and there exists a more recent definition of\n-   GLOBAL_VAR, return the definition for GLOBAL_VAR.  This means that VAR\n-   has been clobbered by a function call since its last assignment.  */\n+   5- Rename all the blocks (rewrite_blocks) and statements in the program.\n \n-static tree\n-get_reaching_def (tree var)\n+   Steps 3 and 5 are done using the dominator tree walker\n+   (walk_dominator_tree).\n+\n+   ALL is true if all variables should be renamed (otherwise just those\n+   mentioned in vars_to_rename are taken into account).  */\n+\n+void\n+rewrite_into_ssa (bool all)\n {\n-  tree default_d, currdef_var, avar;\n+  bitmap *dfs;\n+  basic_block bb;\n+  bitmap old_vars_to_rename = vars_to_rename;\n   \n-  /* Lookup the current reaching definition for VAR.  */\n-  default_d = NULL_TREE;\n-  currdef_var = get_current_def (var);\n+  timevar_push (TV_TREE_SSA_OTHER);\n \n-  /* If there is no reaching definition for VAR, create and register a\n-     default definition for it (if needed).  */\n-  if (currdef_var == NULL_TREE)\n+  if (all)\n+    vars_to_rename = NULL;\n+  else\n     {\n-      if (TREE_CODE (var) == SSA_NAME)\n-\tavar = SSA_NAME_VAR (var);\n-      else\n-\tavar = var;\n+      /* Initialize the array of variables to rename.  */\n+      gcc_assert (vars_to_rename);\n \n-      default_d = default_def (avar);\n-      if (default_d == NULL_TREE)\n+      if (bitmap_empty_p (vars_to_rename))\n \t{\n-\t  default_d = make_ssa_name (avar, build_empty_stmt ());\n-\t  set_default_def (avar, default_d);\n+\t  timevar_pop (TV_TREE_SSA_OTHER);\n+\t  return;\n \t}\n-      set_current_def (var, default_d);\n+      \n+      invalidate_name_tags (vars_to_rename);\n+\n+      /* Now remove all the existing PHI nodes (if any) for the variables\n+\t that we are about to rename into SSA.  */\n+      remove_all_phi_nodes_for (vars_to_rename);\n     }\n \n-  /* Return the current reaching definition for VAR, or the default\n-     definition, if we had to create one.  */\n-  return (currdef_var) ? currdef_var : default_d;\n-}\n+  mark_def_site_blocks ();\n \n+  /* Initialize dominance frontier and immediate dominator bitmaps. \n+     Also count the number of predecessors for each block.  Doing so\n+     can save significant time during PHI insertion for large graphs.  */\n+  dfs = (bitmap *) xmalloc (last_basic_block * sizeof (bitmap *));\n+  FOR_EACH_BB (bb)\n+    dfs[bb->index] = BITMAP_ALLOC (NULL);\n \n-/* Hashing and equality functions for DEF_BLOCKS.  */\n+  /* Compute dominance frontiers.  */\n+  compute_dominance_frontiers (dfs);\n \n-static hashval_t\n-def_blocks_hash (const void *p)\n-{\n-  return htab_hash_pointer\n-\t((const void *)((const struct def_blocks_d *)p)->var);\n-}\n+  /* Insert PHI nodes at dominance frontiers of definition blocks.  */\n+  insert_phi_nodes (dfs, NULL);\n \n-static int\n-def_blocks_eq (const void *p1, const void *p2)\n-{\n-  return ((const struct def_blocks_d *)p1)->var\n-\t == ((const struct def_blocks_d *)p2)->var;\n-}\n+  rewrite_blocks (false);\n \n-/* Free memory allocated by one entry in DEF_BLOCKS.  */\n+  /* Free allocated memory.  */\n+  FOR_EACH_BB (bb)\n+    BITMAP_FREE (dfs[bb->index]);\n+  free (dfs);\n \n-static void\n-def_blocks_free (void *p)\n-{\n-  struct def_blocks_d *entry = p;\n-  BITMAP_FREE (entry->def_blocks);\n-  BITMAP_FREE (entry->phi_blocks);\n-  BITMAP_FREE (entry->livein_blocks);\n-  free (entry);\n+  vars_to_rename = old_vars_to_rename;\n+  timevar_pop (TV_TREE_SSA_OTHER);\n }\n \n \n-/* Dump the DEF_BLOCKS hash table on stderr.  */\n+/* Rewrites all variables into SSA.  */\n \n-void\n-debug_def_blocks (void)\n+static void\n+rewrite_all_into_ssa (void)\n {\n-  htab_traverse (def_blocks, debug_def_blocks_r, NULL);\n+  rewrite_into_ssa (true);\n }\n \n-/* Callback for htab_traverse to dump the DEF_BLOCKS hash table.  */\n-\n-static int\n-debug_def_blocks_r (void **slot, void *data ATTRIBUTE_UNUSED)\n+struct tree_opt_pass pass_build_ssa = \n {\n-  struct def_blocks_d *db_p = (struct def_blocks_d *) *slot;\n-  \n-  fprintf (stderr, \"VAR: \");\n-  print_generic_expr (stderr, db_p->var, dump_flags);\n-  bitmap_print (stderr, db_p->def_blocks, \", DEF_BLOCKS: { \", \"}\");\n-  bitmap_print (stderr, db_p->livein_blocks, \", LIVEIN_BLOCKS: { \", \"}\\n\");\n-\n-  return 1;\n-}\n+  \"ssa\",\t\t\t\t/* name */\n+  NULL,\t\t\t\t\t/* gate */\n+  rewrite_all_into_ssa,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  PROP_cfg | PROP_referenced_vars,\t/* properties_required */\n+  PROP_ssa,\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func | TODO_verify_ssa,\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n \n \n-/* Return the set of blocks where variable VAR is defined and the blocks\n-   where VAR is live on entry (livein).  Return NULL, if no entry is\n-   found in DEF_BLOCKS.  */\n+/* Rewrite the def-def chains of virtual operands so that they have\n+   the correct reaching definitions.  */\n \n-static inline struct def_blocks_d *\n-find_def_blocks_for (tree var)\n+void\n+rewrite_def_def_chains (void)\n {\n-  struct def_blocks_d dm;\n-  dm.var = var;\n-  return (struct def_blocks_d *) htab_find (def_blocks, &dm);\n+  /* Ensure that the dominance information is OK.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  mark_def_site_blocks ();\n+  rewrite_blocks (true);\n }\n \n \n-/* Return the set of blocks where variable VAR is defined and the blocks\n-   where VAR is live on entry (livein).  If no entry is found in\n-   DEF_BLOCKS, a new one is created and returned.  */\n \n-static inline struct def_blocks_d *\n-get_def_blocks_for (tree var)\n+/*---------------------------------------------------------------------------\n+    Functions to fix a program in invalid SSA form into valid SSA\n+    form.  The main entry point here is rewrite_ssa_into_ssa.\n+---------------------------------------------------------------------------*/\n+\n+/* Called after visiting basic block BB.  Restore CURRDEFS to its\n+   original value.  */\n+\n+static void\n+ssa_rewrite_finalize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t\t    basic_block bb ATTRIBUTE_UNUSED)\n {\n-  struct def_blocks_d db, *db_p;\n-  void **slot;\n \n-  db.var = var;\n-  slot = htab_find_slot (def_blocks, (void *) &db, INSERT);\n-  if (*slot == NULL)\n+  /* Step 5.  Restore the current reaching definition for each variable\n+     referenced in the block (in reverse order).  */\n+  while (VEC_length (tree_on_heap, block_defs_stack) > 0)\n     {\n-      db_p = xmalloc (sizeof (*db_p));\n-      db_p->var = var;\n-      db_p->def_blocks = BITMAP_ALLOC (NULL);\n-      db_p->phi_blocks = BITMAP_ALLOC (NULL);\n-      db_p->livein_blocks = BITMAP_ALLOC (NULL);\n-      *slot = (void *) db_p;\n-    }\n-  else\n-    db_p = (struct def_blocks_d *) *slot;\n+      tree var = VEC_pop (tree_on_heap, block_defs_stack);\n+      tree saved_def;\n+      \n+      if (var == NULL)\n+\tbreak;\n \n-  return db_p;\n+      saved_def = VEC_pop (tree_on_heap, block_defs_stack);\n+      set_current_def (var, saved_def);\n+    }\n }\n \n-/* If a variable V in VARS_TO_RENAME is a pointer, the renaming\n-   process will cause us to lose the name memory tags that may have\n-   been associated with the various SSA_NAMEs of V.  This means that\n-   the variables aliased to those name tags also need to be renamed\n-   again.\n-\n-   FIXME 1- We should either have a better scheme for renaming\n-\t    pointers that doesn't lose name tags or re-run alias\n-\t    analysis to recover points-to information.\n \n-\t 2- Currently we just invalidate *all* the name tags.  This\n-\t    should be more selective.  */\n+/* Register DEF (an SSA_NAME) to be a new definition for the original\n+   ssa name VAR and push VAR's current reaching definition\n+   into the stack pointed by BLOCK_DEFS_P.  */\n \n static void\n-invalidate_name_tags (bitmap vars_to_rename)\n+ssa_register_new_def (tree var, tree def)\n {\n-  unsigned i;\n-  bool rename_name_tags_p;\n-  bitmap_iterator bi;\n-\n-  rename_name_tags_p = false;\n-  EXECUTE_IF_SET_IN_BITMAP (vars_to_rename, 0, i, bi)\n+  tree currdef;\n+   \n+  /* If this variable is set in a single basic block and all uses are\n+     dominated by the set(s) in that single basic block, then there is\n+     nothing to do.  TODO we should not be called at all, and just\n+     keep the original name.  */\n+  if (get_phi_state (var) == NEED_PHI_STATE_NO)\n     {\n-      if (POINTER_TYPE_P (TREE_TYPE (referenced_var (i))))\n-\t{\n-\t  rename_name_tags_p = true;\n-\t  break;\n-\t}\n+      set_current_def (var, def);\n+      return;\n     }\n \n-  if (rename_name_tags_p)\n-    for (i = 0; i < num_referenced_vars; i++)\n-      {\n-\tvar_ann_t ann = var_ann (referenced_var (i));\n+  currdef = get_current_def (var);\n \n-\tif (ann->mem_tag_kind == NAME_TAG)\n-\t  {\n-\t    size_t j;\n-\t    varray_type may_aliases = ann->may_aliases;\n+  /* Push the current reaching definition into *BLOCK_DEFS_P.  This stack is\n+     later used by the dominator tree callbacks to restore the reaching\n+     definitions for all the variables defined in the block after a recursive\n+     visit to all its immediately dominated blocks.  */\n+  VEC_safe_push (tree_on_heap, block_defs_stack, currdef);\n+  VEC_safe_push (tree_on_heap, block_defs_stack, var);\n \n-\t    bitmap_set_bit (vars_to_rename, ann->uid);\n-\t    if (ann->may_aliases)\n-\t      for (j = 0; j < VARRAY_ACTIVE_SIZE (may_aliases); j++)\n-\t\t{\n-\t\t  tree var = VARRAY_TREE (may_aliases, j);\n-\t\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n-\t\t}\n-\t  }\n-      }\n+  /* Set the current reaching definition for VAR to be DEF.  */\n+  set_current_def (var, def);\n }\n \n-/* Rewrite the actual blocks, statements, and phi arguments, to be in SSA\n-   form.  FIX_VIRTUAL_PHIS is true if we should only be fixing up virtual\n-   phi arguments, instead of adding new phi arguments for just added phi\n-   nodes.  */\n \n+/* Same as rewrite_stmt, for rewriting ssa names.  */\n \n static void\n-rewrite_blocks (bool fix_virtual_phis)\n+ssa_rewrite_stmt (struct dom_walk_data *walk_data,\n+\t\t  basic_block bb ATTRIBUTE_UNUSED,\n+\t\t  block_stmt_iterator si)\n {\n-  struct dom_walk_data walk_data;\n-  \n-  /* Rewrite all the basic blocks in the program.  */\n-  timevar_push (TV_TREE_SSA_REWRITE_BLOCKS);\n-\n-  /* Setup callbacks for the generic dominator tree walker.  */\n-  walk_data.walk_stmts_backward = false;\n-  walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.initialize_block_local_data = NULL;\n-  walk_data.before_dom_children_before_stmts = rewrite_initialize_block;\n-  walk_data.before_dom_children_walk_stmts = rewrite_stmt;\n-  walk_data.before_dom_children_after_stmts = NULL;\n-  if (!fix_virtual_phis)\n-    walk_data.before_dom_children_after_stmts = rewrite_add_phi_arguments;\n-  else\n-    walk_data.before_dom_children_after_stmts = rewrite_virtual_phi_arguments;\n-  \n-  walk_data.after_dom_children_before_stmts =  NULL;\n-  walk_data.after_dom_children_walk_stmts =  NULL;\n-  walk_data.after_dom_children_after_stmts =  rewrite_finalize_block;\n-  walk_data.global_data = NULL;\n-  walk_data.block_local_data_size = 0;\n-\n-  block_defs_stack = VEC_alloc (tree_on_heap, 10);\n-\n-  /* Initialize the dominator walker.  */\n-  init_walk_dominator_tree (&walk_data);\n-\n-  /* Recursively walk the dominator tree rewriting each statement in\n-     each basic block.  */\n-  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n+  stmt_ann_t ann;\n+  tree stmt, var;\n+  ssa_op_iter iter;\n+  use_operand_p use_p;\n+  def_operand_p def_p;\n+  sbitmap names_to_rename = walk_data->global_data;\n \n-  /* Finalize the dominator walker.  */\n-  fini_walk_dominator_tree (&walk_data);\n+  stmt = bsi_stmt (si);\n+  ann = stmt_ann (stmt);\n \n-  /* Debugging dumps.  */\n-  if (dump_file && (dump_flags & TDF_STATS))\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      dump_dfa_stats (dump_file);\n-      dump_tree_ssa_stats (dump_file);\n+      fprintf (dump_file, \"Renaming statement \");\n+      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+      fprintf (dump_file, \"\\n\");\n     }\n \n-  htab_delete (def_blocks);\n-  def_blocks = NULL;\n-  \n-  VEC_free (tree_on_heap, block_defs_stack);\n-  block_defs_stack = NULL;\n-\n-  timevar_pop (TV_TREE_SSA_REWRITE_BLOCKS);\n-}\n-\n-/* Mark the definition site blocks for each variable, so that we know where\n-   the variable is actually live.  */\n-\n-static void \n-mark_def_site_blocks (void)\n-{\n-  size_t i;\n-  struct dom_walk_data walk_data;\n-  struct mark_def_sites_global_data mark_def_sites_global_data;\n+  /* We have just scanned the code for operands.  No statement should\n+     be modified.  */\n+  gcc_assert (!ann->modified);\n \n-  /* Allocate memory for the DEF_BLOCKS hash table.  */\n-  def_blocks = htab_create (VARRAY_ACTIVE_SIZE (referenced_vars),\n-\t\t\t    def_blocks_hash, def_blocks_eq, def_blocks_free);\n+  /* Step 1.  Rewrite USES and VUSES in the statement.  */\n+  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES | SSA_OP_ALL_KILLS)\n+    {\n+      if (TEST_BIT (names_to_rename, SSA_NAME_VERSION (USE_FROM_PTR (use_p))))\n+\tSET_USE (use_p, get_reaching_def (USE_FROM_PTR (use_p)));\n+    }\n \n-  for (i = 0; i < num_referenced_vars; i++)\n-    set_current_def (referenced_var (i), NULL_TREE);\n+  /* Step 2.  Register the statement's DEF and VDEF operands.  */\n+  FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_ALL_DEFS)\n+    {\n+      var = DEF_FROM_PTR (def_p);\n \n-  /* Ensure that the dominance information is OK.  */\n-  calculate_dominance_info (CDI_DOMINATORS);\n+      if (!TEST_BIT (names_to_rename, SSA_NAME_VERSION (var)))\n+\tcontinue;\n \n+      SET_DEF (def_p, duplicate_ssa_name (var, stmt));\n+      ssa_register_new_def (var, DEF_FROM_PTR (def_p));\n+    }\n+}\n \n-  /* Setup callbacks for the generic dominator tree walker to find and\n-     mark definition sites.  */\n-  walk_data.walk_stmts_backward = false;\n-  walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.initialize_block_local_data = NULL;\n-  walk_data.before_dom_children_before_stmts = mark_def_sites_initialize_block;\n-  walk_data.before_dom_children_walk_stmts = mark_def_sites;\n-  walk_data.before_dom_children_after_stmts = NULL; \n-  walk_data.after_dom_children_before_stmts =  NULL;\n-  walk_data.after_dom_children_walk_stmts =  NULL;\n-  walk_data.after_dom_children_after_stmts =  NULL;\n \n-  /* Notice that this bitmap is indexed using variable UIDs, so it must be\n-     large enough to accommodate all the variables referenced in the\n-     function, not just the ones we are renaming.  */\n-  mark_def_sites_global_data.kills = BITMAP_ALLOC (NULL);\n-  walk_data.global_data = &mark_def_sites_global_data;\n+/* Ditto, for ssa name rewriting.  */\n \n-  /* We do not have any local data.  */\n-  walk_data.block_local_data_size = 0;\n+static void\n+ssa_rewrite_phi_arguments (struct dom_walk_data *walk_data, basic_block bb)\n+{\n+  edge e;\n+  sbitmap names_to_rename = walk_data->global_data;\n+  use_operand_p op;\n+  edge_iterator ei;\n \n-  /* Initialize the dominator walker.  */\n-  init_walk_dominator_tree (&walk_data);\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      tree phi;\n \n-  /* Recursively walk the dominator tree.  */\n-  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n+      if (e->dest == EXIT_BLOCK_PTR)\n+\tcontinue;\n \n-  /* Finalize the dominator walker.  */\n-  fini_walk_dominator_tree (&walk_data);\n+      for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  op = PHI_ARG_DEF_PTR_FROM_EDGE (phi, e);\n+\t  if (TREE_CODE (USE_FROM_PTR (op)) != SSA_NAME)\n+\t    continue;\n+\t  \n+\t  if (!TEST_BIT (names_to_rename, SSA_NAME_VERSION (USE_FROM_PTR (op))))\n+\t    continue; \n \n-  /* We no longer need this bitmap, clear and free it.  */\n-  BITMAP_FREE (mark_def_sites_global_data.kills);\n+\t  SET_USE (op, get_reaching_def (USE_FROM_PTR (op)));\n+\t  if (e->flags & EDGE_ABNORMAL)\n+\t    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (USE_FROM_PTR (op)) = 1;\n+\t}\n+    }\n }\n \n+/* Ditto, for rewriting ssa names.  */\n \n-/* Main entry point into the SSA builder.  The renaming process\n-   proceeds in five main phases:\n+static void\n+ssa_rewrite_initialize_block (struct dom_walk_data *walk_data, basic_block bb)\n+{\n+  tree phi, new_name;\n+  sbitmap names_to_rename = walk_data->global_data;\n+  edge e;\n+  bool abnormal_phi;\n+  edge_iterator ei;\n \n-   1- If VARS_TO_RENAME has any entries, any existing PHI nodes for\n-      those variables are removed from the flow graph so that they can\n-      be computed again.\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\n\\nRenaming block #%d\\n\\n\", bb->index);\n \n-   2- Compute dominance frontier and immediate dominators, needed to\n-      insert PHI nodes and rename the function in dominator tree\n-      order.\n+  /* Mark the unwind point for this block.  */\n+  VEC_safe_push (tree_on_heap, block_defs_stack, NULL_TREE);\n \n-   3- Find and mark all the blocks that define variables\n-      (mark_def_site_blocks).\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (e->flags & EDGE_ABNORMAL)\n+      break;\n+  abnormal_phi = (e != NULL);\n \n-   4- Insert PHI nodes at dominance frontiers (insert_phi_nodes).\n+  /* Step 1.  Register new definitions for every PHI node in the block.\n+     Conceptually, all the PHI nodes are executed in parallel and each PHI\n+     node introduces a new version for the associated variable.  */\n+  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+    {\n+      tree result = PHI_RESULT (phi);\n \n-   5- Rename all the blocks (rewrite_blocks) and statements in the program.\n+      if (TEST_BIT (names_to_rename, SSA_NAME_VERSION (result)))\n+\t{\n+\t  new_name = duplicate_ssa_name (result, phi);\n+\t  SET_PHI_RESULT (phi, new_name);\n \n-   Steps 3 and 5 are done using the dominator tree walker\n-   (walk_dominator_tree).\n+\t  if (abnormal_phi)\n+\t    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (new_name) = 1;\n+\t  ssa_register_new_def (result, new_name);\n+\t}\n+    }\n+}\n \n-   ALL is true if all variables should be renamed (otherwise just those\n-   mentioned in vars_to_rename are taken into account).  */\n \n-void\n-rewrite_into_ssa (bool all)\n+/* Same as mark_def_sites, but works over SSA names.  */\n+\n+static void\n+ssa_mark_def_sites (struct dom_walk_data *walk_data,\n+\t\t    basic_block bb,\n+\t\t    block_stmt_iterator bsi)\n {\n-  bitmap *dfs;\n-  basic_block bb;\n-  bitmap old_vars_to_rename = vars_to_rename;\n-  \n-  timevar_push (TV_TREE_SSA_OTHER);\n+  struct mark_def_sites_global_data *gd = walk_data->global_data;\n+  bitmap kills = gd->kills;\n+  size_t uid, def_uid;\n+  tree stmt, use, def;\n+  ssa_op_iter iter;\n \n-  if (all)\n-    vars_to_rename = NULL;\n-  else\n+  /* Mark all the blocks that have definitions for each variable in the\n+     names_to_rename bitmap.  */\n+  stmt = bsi_stmt (bsi);\n+  get_stmt_operands (stmt);\n+\n+  /* If a variable is used before being set, then the variable is live\n+     across a block boundary, so mark it live-on-entry to BB.  */\n+  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_ALL_USES | SSA_OP_ALL_KILLS)\n     {\n-      /* Initialize the array of variables to rename.  */\n-      gcc_assert (vars_to_rename);\n+      uid = SSA_NAME_VERSION (use);\n \n-      if (bitmap_empty_p (vars_to_rename))\n+      if (TEST_BIT (gd->names_to_rename, uid)\n+\t  && !bitmap_bit_p (kills, uid))\n+\tset_livein_block (use, bb);\n+    }\n+\t  \n+  /* Now process the definition made by this statement.  Mark the\n+     variables in KILLS.  */\n+  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n+    {\n+      def_uid = SSA_NAME_VERSION (def);\n+\n+      if (TEST_BIT (gd->names_to_rename, def_uid))\n \t{\n-\t  timevar_pop (TV_TREE_SSA_OTHER);\n-\t  return;\n+\t  set_def_block (def, bb, false, true);\n+\t  bitmap_set_bit (kills, def_uid);\n \t}\n-      \n-      invalidate_name_tags (vars_to_rename);\n-\n-      /* Now remove all the existing PHI nodes (if any) for the variables\n-\t that we are about to rename into SSA.  */\n-      remove_all_phi_nodes_for (vars_to_rename);\n     }\n+}\n \n-  mark_def_site_blocks ();\n \n-  /* Initialize dominance frontier and immediate dominator bitmaps. \n-     Also count the number of predecessors for each block.  Doing so\n-     can save significant time during PHI insertion for large graphs.  */\n-  dfs = (bitmap *) xmalloc (last_basic_block * sizeof (bitmap *));\n-  FOR_EACH_BB (bb)\n-    dfs[bb->index] = BITMAP_ALLOC (NULL);\n+/* Block initialization routine for mark_def_sites.  Clear the \n+   KILLS bitmap at the start of each block.  */\n \n-  /* Compute dominance frontiers.  */\n-  compute_dominance_frontiers (dfs);\n+static void\n+ssa_mark_def_sites_initialize_block (struct dom_walk_data *walk_data,\n+\t\t\t\t     basic_block bb)\n+{\n+  struct mark_def_sites_global_data *gd = walk_data->global_data;\n+  bitmap kills = gd->kills;\n+  tree phi, def;\n+  unsigned def_uid;\n \n-  /* Insert PHI nodes at dominance frontiers of definition blocks.  */\n-  insert_phi_nodes (dfs, NULL);\n+  bitmap_clear (kills);\n \n-  rewrite_blocks (false);\n+  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+    {\n+      def = PHI_RESULT (phi);\n+      def_uid = SSA_NAME_VERSION (def);\n \n-  /* Free allocated memory.  */\n-  FOR_EACH_BB (bb)\n-    BITMAP_FREE (dfs[bb->index]);\n-  free (dfs);\n+      if (!TEST_BIT (gd->names_to_rename, def_uid))\n+\tcontinue;\n \n-  vars_to_rename = old_vars_to_rename;\n-  timevar_pop (TV_TREE_SSA_OTHER);\n+      set_def_block (def, bb, true, true);\n+      bitmap_set_bit (kills, def_uid);\n+    }\n }\n \n-/* Rewrite the def-def chains so that they have the correct reaching\n-   definitions.  */\n+/* Marks ssa names used as arguments of phis at the end of BB.  */\n \n-void\n-rewrite_def_def_chains (void)\n+static void\n+ssa_mark_phi_uses (struct dom_walk_data *walk_data, basic_block bb)\n {\n-  /* Ensure that the dominance information is OK.  */\n-  calculate_dominance_info (CDI_DOMINATORS);\n-  mark_def_site_blocks ();\n-  rewrite_blocks (true);\n+  struct mark_def_sites_global_data *gd = walk_data->global_data;\n+  bitmap kills = gd->kills;\n+  edge e;\n+  tree phi, use;\n+  unsigned uid;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      if (e->dest == EXIT_BLOCK_PTR)\n+\tcontinue;\n+\n+      for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  use = PHI_ARG_DEF_FROM_EDGE (phi, e);\n+\t  if (TREE_CODE (use) != SSA_NAME)\n+\t    continue;\n+\n+\t  uid = SSA_NAME_VERSION (use);\n \n+\t  if (TEST_BIT (gd->names_to_rename, uid)\n+\t      && !bitmap_bit_p (kills, uid))\n+\t    set_livein_block (use, bb);\n+\t}\n+    }\n }\n+       \n+   \n /* The marked ssa names may have more than one definition;\n-   add phi nodes and rewrite them to fix this.  */\n+   add PHI nodes and rewrite them to fix this.  */\n \n void\n rewrite_ssa_into_ssa (void)\n@@ -1796,28 +1835,3 @@ rewrite_ssa_into_ssa (void)\n   block_defs_stack = NULL;\n   timevar_pop (TV_TREE_SSA_OTHER);\n }\n-\n-/* Rewrites all variables into ssa.  */\n-\n-static void\n-rewrite_all_into_ssa (void)\n-{\n-  rewrite_into_ssa (true);\n-}\n-\n-struct tree_opt_pass pass_build_ssa = \n-{\n-  \"ssa\",\t\t\t\t/* name */\n-  NULL,\t\t\t\t\t/* gate */\n-  rewrite_all_into_ssa,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  0,\t\t\t\t\t/* tv_id */\n-  PROP_cfg | PROP_referenced_vars,\t/* properties_required */\n-  PROP_ssa,\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func | TODO_verify_ssa,\t\t\t/* todo_flags_finish */\n-  0\t\t\t\t\t/* letter */\n-};"}]}