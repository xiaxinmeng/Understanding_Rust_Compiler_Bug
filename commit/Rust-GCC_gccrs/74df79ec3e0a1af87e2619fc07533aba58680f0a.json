{"sha": "74df79ec3e0a1af87e2619fc07533aba58680f0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRkZjc5ZWMzZTBhMWFmODdlMjYxOWZjMDc1MzNhYmE1ODY4MGYwYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-08-19T19:29:54Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-09-05T23:10:51Z"}, "message": "libgo: update to final Go 1.17 release\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/343729", "tree": {"sha": "321354569188d7b7de54cd23d3c6785030163cef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/321354569188d7b7de54cd23d3c6785030163cef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74df79ec3e0a1af87e2619fc07533aba58680f0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74df79ec3e0a1af87e2619fc07533aba58680f0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74df79ec3e0a1af87e2619fc07533aba58680f0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74df79ec3e0a1af87e2619fc07533aba58680f0a/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a827909537cf085e5673ca7816b7bd7151d89fc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a827909537cf085e5673ca7816b7bd7151d89fc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a827909537cf085e5673ca7816b7bd7151d89fc5"}], "stats": {"total": 282, "additions": 216, "deletions": 66}, "files": [{"sha": "e9f38d449a41de71594c76b3b758300f822f14ec", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74df79ec3e0a1af87e2619fc07533aba58680f0a/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74df79ec3e0a1af87e2619fc07533aba58680f0a/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=74df79ec3e0a1af87e2619fc07533aba58680f0a", "patch": "@@ -1,4 +1,4 @@\n-77bc32767b61feb6499ca7921e96b356603517dc\n+b3fad6957a04520013197ea7cab11bec3298d552\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "d037d8d06a2a9f9619abc7497af1a486c5e8e3ed", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=74df79ec3e0a1af87e2619fc07533aba58680f0a", "patch": "@@ -1,4 +1,4 @@\n-72ab3ff68b1ec894fe5599ec82b8849f3baa9d94\n+ec5170397c724a8ae440b2bc529f857c86f0e6b1\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "efcff2916b0f04de0a83a9cba938648498757551", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=74df79ec3e0a1af87e2619fc07533aba58680f0a", "patch": "@@ -1 +1 @@\n-go1.17rc2\n+go1.17"}, {"sha": "bf6956731676d39e66e74642f6a43b40607d619a", "filename": "libgo/go/cmd/go/internal/modload/buildlist.go", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuildlist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuildlist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuildlist.go?ref=74df79ec3e0a1af87e2619fc07533aba58680f0a", "patch": "@@ -191,6 +191,19 @@ func (rs *Requirements) rootSelected(path string) (version string, ok bool) {\n \treturn \"\", false\n }\n \n+// hasRedundantRoot returns true if the root list contains multiple requirements\n+// of the same module or a requirement on any version of the main module.\n+// Redundant requirements should be pruned, but they may influence version\n+// selection.\n+func (rs *Requirements) hasRedundantRoot() bool {\n+\tfor i, m := range rs.rootModules {\n+\t\tif m.Path == Target.Path || (i > 0 && m.Path == rs.rootModules[i-1].Path) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n // Graph returns the graph of module requirements loaded from the current\n // root modules (as reported by RootModules).\n //\n@@ -882,6 +895,12 @@ func updateLazyRoots(ctx context.Context, direct map[string]bool, rs *Requiremen\n \t\t// and (trivially) version.\n \n \t\tif !rootsUpgraded {\n+\t\t\tif cfg.BuildMod != \"mod\" {\n+\t\t\t\t// The only changes to the root set (if any) were to remove duplicates.\n+\t\t\t\t// The requirements are consistent (if perhaps redundant), so keep the\n+\t\t\t\t// original rs to preserve its ModuleGraph.\n+\t\t\t\treturn rs, nil\n+\t\t\t}\n \t\t\t// The root set has converged: every root going into this iteration was\n \t\t\t// already at its selected version, although we have have removed other\n \t\t\t// (redundant) roots for the same path."}, {"sha": "45f724d5e3658f5d21d757d7a955b24af6b89be9", "filename": "libgo/go/cmd/go/internal/modload/init.go", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go?ref=74df79ec3e0a1af87e2619fc07533aba58680f0a", "patch": "@@ -449,13 +449,22 @@ func loadModFile(ctx context.Context) (rs *Requirements, needCommit bool) {\n \t}\n \n \tsetDefaultBuildMod() // possibly enable automatic vendoring\n-\trs = requirementsFromModFile(ctx)\n-\n+\trs = requirementsFromModFile()\n \tif cfg.BuildMod == \"vendor\" {\n \t\treadVendorList()\n \t\tcheckVendorConsistency()\n \t\trs.initVendor(vendorList)\n \t}\n+\tif rs.hasRedundantRoot() {\n+\t\t// If any module path appears more than once in the roots, we know that the\n+\t\t// go.mod file needs to be updated even though we have not yet loaded any\n+\t\t// transitive dependencies.\n+\t\trs, err = updateRoots(ctx, rs.direct, rs, nil, nil, false)\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n+\t\t}\n+\t}\n+\n \tif index.goVersionV == \"\" {\n \t\t// TODO(#45551): Do something more principled instead of checking\n \t\t// cfg.CmdName directly here.\n@@ -530,7 +539,12 @@ func CreateModFile(ctx context.Context, modPath string) {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n-\tcommitRequirements(ctx, modFileGoVersion(), requirementsFromModFile(ctx))\n+\trs := requirementsFromModFile()\n+\trs, err = updateRoots(ctx, rs.direct, rs, nil, nil, false)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: %v\", err)\n+\t}\n+\tcommitRequirements(ctx, modFileGoVersion(), rs)\n \n \t// Suggest running 'go mod tidy' unless the project is empty. Even if we\n \t// imported all the correct requirements above, we're probably missing\n@@ -641,9 +655,8 @@ func initTarget(m module.Version) {\n \n // requirementsFromModFile returns the set of non-excluded requirements from\n // the global modFile.\n-func requirementsFromModFile(ctx context.Context) *Requirements {\n+func requirementsFromModFile() *Requirements {\n \troots := make([]module.Version, 0, len(modFile.Require))\n-\tmPathCount := map[string]int{Target.Path: 1}\n \tdirect := map[string]bool{}\n \tfor _, r := range modFile.Require {\n \t\tif index != nil && index.exclude[r.Mod] {\n@@ -656,28 +669,12 @@ func requirementsFromModFile(ctx context.Context) *Requirements {\n \t\t}\n \n \t\troots = append(roots, r.Mod)\n-\t\tmPathCount[r.Mod.Path]++\n \t\tif !r.Indirect {\n \t\t\tdirect[r.Mod.Path] = true\n \t\t}\n \t}\n \tmodule.Sort(roots)\n \trs := newRequirements(modDepthFromGoVersion(modFileGoVersion()), roots, direct)\n-\n-\t// If any module path appears more than once in the roots, we know that the\n-\t// go.mod file needs to be updated even though we have not yet loaded any\n-\t// transitive dependencies.\n-\tfor _, n := range mPathCount {\n-\t\tif n > 1 {\n-\t\t\tvar err error\n-\t\t\trs, err = updateRoots(ctx, rs.direct, rs, nil, nil, false)\n-\t\t\tif err != nil {\n-\t\t\t\tbase.Fatalf(\"go: %v\", err)\n-\t\t\t}\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\n \treturn rs\n }\n "}, {"sha": "9abbabd2ebe47345e3e1cbe9067a9e98fcf76b7f", "filename": "libgo/go/cmd/go/testdata/script/mod_tidy_lazy_self.txt", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy_lazy_self.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy_lazy_self.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy_lazy_self.txt?ref=74df79ec3e0a1af87e2619fc07533aba58680f0a", "patch": "@@ -2,18 +2,13 @@\n # 'go mod tidy' should not panic if the main module initially\n # requires an older version of itself.\n \n+# A module may require an older version of itself without error. This is\n+# inconsistent (the required version is never selected), but we still get\n+# a reproducible build list.\n+go list -m all\n+stdout '^golang.org/issue/46078$'\n \n-# A module that explicitly requires an older version of itself should be\n-# rejected as inconsistent: we enforce that every explicit requirement is the\n-# selected version of its module path, but the selected version of the main\n-# module is always itself \u2014 not some explicit version.\n-\n-! go list -m all\n-stderr '^go: updates to go\\.mod needed; to update it:\\n\\tgo mod tidy$'\n-\n-\n-# The suggested 'go mod tidy' command should succeed (not crash).\n-\n+# 'go mod tidy' should fix this (and not crash).\n go mod tidy\n \n "}, {"sha": "e603afadb0b1b166e646ed0be6a11c98333fb798", "filename": "libgo/go/io/fs/fs.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2Fgo%2Fio%2Ffs%2Ffs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2Fgo%2Fio%2Ffs%2Ffs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Ffs%2Ffs.go?ref=74df79ec3e0a1af87e2619fc07533aba58680f0a", "patch": "@@ -86,7 +86,7 @@ type File interface {\n type DirEntry interface {\n \t// Name returns the name of the file (or subdirectory) described by the entry.\n \t// This name is only the final element of the path (the base name), not the entire path.\n-\t// For example, Name would return \"hello.go\" not \"/home/gopher/hello.go\".\n+\t// For example, Name would return \"hello.go\" not \"home/gopher/hello.go\".\n \tName() string\n \n \t// IsDir reports whether the entry describes a directory."}, {"sha": "7e14749f838436d98695f7957c9af10af38e97b6", "filename": "libgo/go/net/http/transport_test.go", "status": "modified", "additions": 51, "deletions": 26, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go?ref=74df79ec3e0a1af87e2619fc07533aba58680f0a", "patch": "@@ -6445,10 +6445,11 @@ func TestErrorWriteLoopRace(t *testing.T) {\n // Test that a new request which uses the connection of an active request\n // cannot cause it to be canceled as well.\n func TestCancelRequestWhenSharingConnection(t *testing.T) {\n-\tif testing.Short() {\n-\t\tt.Skip(\"skipping in short mode\")\n-\t}\n+\treqc := make(chan chan struct{}, 2)\n \tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, req *Request) {\n+\t\tch := make(chan struct{}, 1)\n+\t\treqc <- ch\n+\t\t<-ch\n \t\tw.Header().Add(\"Content-Length\", \"0\")\n \t}))\n \tdefer ts.Close()\n@@ -6460,34 +6461,58 @@ func TestCancelRequestWhenSharingConnection(t *testing.T) {\n \n \tvar wg sync.WaitGroup\n \n-\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n+\twg.Add(1)\n+\tputidlec := make(chan chan struct{})\n+\tgo func() {\n+\t\tdefer wg.Done()\n+\t\tctx := httptrace.WithClientTrace(context.Background(), &httptrace.ClientTrace{\n+\t\t\tPutIdleConn: func(error) {\n+\t\t\t\t// Signal that the idle conn has been returned to the pool,\n+\t\t\t\t// and wait for the order to proceed.\n+\t\t\t\tch := make(chan struct{})\n+\t\t\t\tputidlec <- ch\n+\t\t\t\t<-ch\n+\t\t\t},\n+\t\t})\n+\t\treq, _ := NewRequestWithContext(ctx, \"GET\", ts.URL, nil)\n+\t\tres, err := client.Do(req)\n+\t\tif err == nil {\n+\t\t\tres.Body.Close()\n+\t\t}\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"request 1: got err %v, want nil\", err)\n+\t\t}\n+\t}()\n \n-\tfor i := 0; i < 10; i++ {\n-\t\twg.Add(1)\n-\t\tgo func() {\n-\t\t\tdefer wg.Done()\n-\t\t\tfor ctx.Err() == nil {\n-\t\t\t\treqctx, reqcancel := context.WithCancel(ctx)\n-\t\t\t\tgo reqcancel()\n-\t\t\t\treq, _ := NewRequestWithContext(reqctx, \"GET\", ts.URL, nil)\n-\t\t\t\tres, err := client.Do(req)\n-\t\t\t\tif err == nil {\n-\t\t\t\t\tres.Body.Close()\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}()\n-\t}\n+\t// Wait for the first request to receive a response and return the\n+\t// connection to the idle pool.\n+\tr1c := <-reqc\n+\tclose(r1c)\n+\tidlec := <-putidlec\n \n-\tfor ctx.Err() == nil {\n-\t\treq, _ := NewRequest(\"GET\", ts.URL, nil)\n-\t\tif res, err := client.Do(req); err != nil {\n-\t\t\tt.Errorf(\"unexpected: %p %v\", req, err)\n-\t\t\tbreak\n-\t\t} else {\n+\twg.Add(1)\n+\tcancelctx, cancel := context.WithCancel(context.Background())\n+\tgo func() {\n+\t\tdefer wg.Done()\n+\t\treq, _ := NewRequestWithContext(cancelctx, \"GET\", ts.URL, nil)\n+\t\tres, err := client.Do(req)\n+\t\tif err == nil {\n \t\t\tres.Body.Close()\n \t\t}\n-\t}\n+\t\tif !errors.Is(err, context.Canceled) {\n+\t\t\tt.Errorf(\"request 2: got err %v, want Canceled\", err)\n+\t\t}\n+\t}()\n \n+\t// Wait for the second request to arrive at the server, and then cancel\n+\t// the request context.\n+\tr2c := <-reqc\n \tcancel()\n+\n+\t// Give the cancelation a moment to take effect, and then unblock the first request.\n+\ttime.Sleep(1 * time.Millisecond)\n+\tclose(idlec)\n+\n+\tclose(r2c)\n \twg.Wait()\n }"}, {"sha": "b4afaee0613f6ba3cd7b9277614f0058a91675c3", "filename": "libgo/go/runtime/mfinal.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2Fgo%2Fruntime%2Fmfinal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2Fgo%2Fruntime%2Fmfinal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmfinal.go?ref=74df79ec3e0a1af87e2619fc07533aba58680f0a", "patch": "@@ -402,6 +402,10 @@ okarg:\n // Without the KeepAlive call, the finalizer could run at the start of\n // syscall.Read, closing the file descriptor before syscall.Read makes\n // the actual system call.\n+//\n+// Note: KeepAlive should only be used to prevent finalizers from\n+// running prematurely. In particular, when used with unsafe.Pointer,\n+// the rules for valid uses of unsafe.Pointer still apply.\n func KeepAlive(x interface{}) {\n \t// Introduce a use of x that the compiler can't eliminate.\n \t// This makes sure x is alive on entry. We need x to be alive"}, {"sha": "3500cd22f4e74e7991d4f9cfca1ea6856695b722", "filename": "libgo/go/sync/atomic/value.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2Fgo%2Fsync%2Fatomic%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2Fgo%2Fsync%2Fatomic%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fatomic%2Fvalue.go?ref=74df79ec3e0a1af87e2619fc07533aba58680f0a", "patch": "@@ -126,7 +126,7 @@ func (v *Value) Swap(new interface{}) (old interface{}) {\n \t}\n }\n \n-// CompareAndSwapPointer executes the compare-and-swap operation for the Value.\n+// CompareAndSwap executes the compare-and-swap operation for the Value.\n //\n // All calls to CompareAndSwap for a given Value must use values of the same\n // concrete type. CompareAndSwap of an inconsistent type panics, as does"}, {"sha": "f4b4f48142f69387b72babac32ac888ff036145d", "filename": "libgo/go/time/format.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2Fgo%2Ftime%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2Fgo%2Ftime%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fformat.go?ref=74df79ec3e0a1af87e2619fc07533aba58680f0a", "patch": "@@ -77,9 +77,9 @@ import \"errors\"\n // The formats  and 002 are space-padded and zero-padded\n // three-character day of year; there is no unpadded day of year format.\n //\n-// A decimal point followed by one or more zeros represents a fractional\n-// second, printed to the given number of decimal places.\n-// Either a comma or decimal point followed by one or more nines represents\n+// A comma or decimal point followed by one or more zeros represents\n+// a fractional second, printed to the given number of decimal places.\n+// A comma or decimal point followed by one or more nines represents\n // a fractional second, printed to the given number of decimal places, with\n // trailing zeros removed.\n // For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with"}, {"sha": "5ee9947a58504faa5f94e22b6419a7c46e882948", "filename": "libgo/misc/cgo/testsanitizers/msan_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan_test.go?ref=74df79ec3e0a1af87e2619fc07533aba58680f0a", "patch": "@@ -42,6 +42,7 @@ func TestMSAN(t *testing.T) {\n \t\t{src: \"msan5.go\"},\n \t\t{src: \"msan6.go\"},\n \t\t{src: \"msan7.go\"},\n+\t\t{src: \"msan8.go\"},\n \t\t{src: \"msan_fail.go\", wantErr: true},\n \t}\n \tfor _, tc := range cases {"}, {"sha": "1cb5c5677fa758711ae44a6d04e3fdcccbe6c00e", "filename": "libgo/misc/cgo/testsanitizers/testdata/msan8.go", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftestdata%2Fmsan8.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74df79ec3e0a1af87e2619fc07533aba58680f0a/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftestdata%2Fmsan8.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftestdata%2Fmsan8.go?ref=74df79ec3e0a1af87e2619fc07533aba58680f0a", "patch": "@@ -0,0 +1,109 @@\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+/*\n+#include <pthread.h>\n+#include <signal.h>\n+#include <stdint.h>\n+\n+#include <sanitizer/msan_interface.h>\n+\n+// cgoTracebackArg is the type of the argument passed to msanGoTraceback.\n+struct cgoTracebackArg {\n+\tuintptr_t context;\n+\tuintptr_t sigContext;\n+\tuintptr_t* buf;\n+\tuintptr_t max;\n+};\n+\n+// msanGoTraceback is registered as the cgo traceback function.\n+// This will be called when a signal occurs.\n+void msanGoTraceback(void* parg) {\n+\tstruct cgoTracebackArg* arg = (struct cgoTracebackArg*)(parg);\n+        arg->buf[0] = 0;\n+}\n+\n+// msanGoWait will be called with all registers undefined as far as\n+// msan is concerned. It just waits for a signal.\n+// Because the registers are msan-undefined, the signal handler will\n+// be invoked with all registers msan-undefined.\n+__attribute__((noinline))\n+void msanGoWait(unsigned long a1, unsigned long a2, unsigned long a3, unsigned long a4, unsigned long a5, unsigned long a6) {\n+\tsigset_t mask;\n+\n+\tsigemptyset(&mask);\n+        sigsuspend(&mask);\n+}\n+\n+// msanGoSignalThread is the thread ID of the msanGoLoop thread.\n+static pthread_t msanGoSignalThread;\n+\n+// msanGoSignalThreadSet is used to record that msanGoSignalThread\n+// has been initialized. This is accessed atomically.\n+static int32_t msanGoSignalThreadSet;\n+\n+// uninit is explicitly poisoned, so that we can make all registers\n+// undefined by calling msanGoWait.\n+static unsigned long uninit;\n+\n+// msanGoLoop loops calling msanGoWait, with the arguments passed\n+// such that msan thinks that they are undefined. msan permits\n+// undefined values to be used as long as they are not used to\n+// for conditionals or for memory access.\n+void msanGoLoop() {\n+\tint i;\n+\n+\tmsanGoSignalThread = pthread_self();\n+        __atomic_store_n(&msanGoSignalThreadSet, 1, __ATOMIC_SEQ_CST);\n+\n+\t// Force uninit to be undefined for msan.\n+\t__msan_poison(&uninit, sizeof uninit);\n+\tfor (i = 0; i < 100; i++) {\n+\t\tmsanGoWait(uninit, uninit, uninit, uninit, uninit, uninit);\n+        }\n+}\n+\n+// msanGoReady returns whether msanGoSignalThread is set.\n+int msanGoReady() {\n+\treturn __atomic_load_n(&msanGoSignalThreadSet, __ATOMIC_SEQ_CST) != 0;\n+}\n+\n+// msanGoSendSignal sends a signal to the msanGoLoop thread.\n+void msanGoSendSignal() {\n+\tpthread_kill(msanGoSignalThread, SIGWINCH);\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"runtime\"\n+\t\"time\"\n+)\n+\n+func main() {\n+\truntime.SetCgoTraceback(0, C.msanGoTraceback, nil, nil)\n+\n+\tc := make(chan bool)\n+\tgo func() {\n+\t\tdefer func() { c <- true }()\n+\t\tC.msanGoLoop()\n+\t}()\n+\n+\tfor C.msanGoReady() == 0 {\n+\t\ttime.Sleep(time.Microsecond)\n+\t}\n+\n+loop:\n+\tfor {\n+\t\tselect {\n+\t\tcase <-c:\n+\t\t\tbreak loop\n+\t\tdefault:\n+\t\t\tC.msanGoSendSignal()\n+\t\t\ttime.Sleep(time.Microsecond)\n+\t\t}\n+\t}\n+}"}]}