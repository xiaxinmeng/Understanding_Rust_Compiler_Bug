{"sha": "30da41ed0e281e0fd35454eb24490ed35325e9b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBkYTQxZWQwZTI4MWUwZmQzNTQ1NGViMjQ0OTBlZDM1MzI1ZTliNQ==", "commit": {"author": {"name": "Xinliang David Li", "email": "davidxl@google.com", "date": "2008-05-17T07:36:10Z"}, "committer": {"name": "Xinliang David Li", "email": "davidxl@gcc.gnu.org", "date": "2008-05-17T07:36:10Z"}, "message": "Check in tree-dce enh to trunk\n\nFrom-SVN: r135463", "tree": {"sha": "645c57e5f272bb82a71867eaeaf0a98d545e37df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/645c57e5f272bb82a71867eaeaf0a98d545e37df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30da41ed0e281e0fd35454eb24490ed35325e9b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30da41ed0e281e0fd35454eb24490ed35325e9b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30da41ed0e281e0fd35454eb24490ed35325e9b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30da41ed0e281e0fd35454eb24490ed35325e9b5/comments", "author": {"login": "vns-mn", "id": 57157229, "node_id": "MDQ6VXNlcjU3MTU3MjI5", "avatar_url": "https://avatars.githubusercontent.com/u/57157229?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vns-mn", "html_url": "https://github.com/vns-mn", "followers_url": "https://api.github.com/users/vns-mn/followers", "following_url": "https://api.github.com/users/vns-mn/following{/other_user}", "gists_url": "https://api.github.com/users/vns-mn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vns-mn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vns-mn/subscriptions", "organizations_url": "https://api.github.com/users/vns-mn/orgs", "repos_url": "https://api.github.com/users/vns-mn/repos", "events_url": "https://api.github.com/users/vns-mn/events{/privacy}", "received_events_url": "https://api.github.com/users/vns-mn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b61eacd60f0d11775049ab521ab6111a3e298749", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b61eacd60f0d11775049ab521ab6111a3e298749", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b61eacd60f0d11775049ab521ab6111a3e298749"}], "stats": {"total": 805, "additions": 798, "deletions": 7}, "files": [{"sha": "0b51053fa7e78193dec1e73c250e6b0e2192a7d6", "filename": "ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30da41ed0e281e0fd35454eb24490ed35325e9b5/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30da41ed0e281e0fd35454eb24490ed35325e9b5/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=30da41ed0e281e0fd35454eb24490ed35325e9b5", "patch": "@@ -1,3 +1,14 @@\n+\n+2008-05-17 Xinliang David Li   <davidxl@google.com>\n+\n+        * gcc/tree-ssa-dce.c : conditional dead call elimination\n+        * gcc/opts.c         : enable the optimization at >=O2\n+        * gcc/common.opt      : new flag for control the optimization\n+        * gcc/doc/invoke.texi : documentation change\n+        * gcc/testsuite/gcc.dg/cdce1.c : new test case\n+        * gcc/testsuite/gcc.dg/cdce2.c : new test case\n+        *MAINTAINERS  : Add myself (write after approval) \n+\n 2008-05-15  Janus Weil  <janus@gcc.gnu.org>\n \n \t* MAINTAINERS (Write After Approval): Add myself."}, {"sha": "b116397597496e90d3623bcb53b4299c18b27440", "filename": "MAINTAINERS", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30da41ed0e281e0fd35454eb24490ed35325e9b5/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30da41ed0e281e0fd35454eb24490ed35325e9b5/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=30da41ed0e281e0fd35454eb24490ed35325e9b5", "patch": "@@ -372,6 +372,7 @@ Manuel L\n Dave Love\t\t\t\t\td.love@dl.ac.uk\n Martin v. L\ufffdwis\t\t\t\t\tloewis@informatik.hu-berlin.de\n H.J. Lu\t\t\t\t\t\thjl.tools@gmail.com\n+Xinliang David Li                               davidxl@google.com\n William Maddox\t\t\t\t\tmaddox@google.com\n Ziga Mahkovec\t\t\t\t\tziga.mahkovec@klika.si\n Simon Martin\t\t\t\t\tsimartin@users.sourceforge.net"}, {"sha": "c7c6f49f40ccb3ceabfbe657cd7793754852ced1", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30da41ed0e281e0fd35454eb24490ed35325e9b5/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30da41ed0e281e0fd35454eb24490ed35325e9b5/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=30da41ed0e281e0fd35454eb24490ed35325e9b5", "patch": "@@ -1259,6 +1259,10 @@ fweb\n Common Report Var(flag_web) Init(2) Optimization\n Construct webs and split unrelated uses of single variable\n \n+ftree-builtin-dce\n+Common Report Var(flag_tree_builtin_dce) Init(0) Optimization\n+Enable conditional dead code elimination for builtin calls.\n+\n fwhole-program\n Common Report Var(flag_whole_program) Init(0) Optimization\n Perform whole program optimizations"}, {"sha": "0fdadd2aec14a8bba39070362874da3b9d6e7896", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30da41ed0e281e0fd35454eb24490ed35325e9b5/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30da41ed0e281e0fd35454eb24490ed35325e9b5/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=30da41ed0e281e0fd35454eb24490ed35325e9b5", "patch": "@@ -353,7 +353,7 @@ Objective-C and Objective-C++ Dialects}.\n -fsignaling-nans -fsingle-precision-constant -fsplit-ivs-in-unroller @gol\n -fsplit-wide-types -fstack-protector -fstack-protector-all @gol\n -fstrict-aliasing -fstrict-overflow -fthread-jumps -ftracer -ftree-ccp @gol\n--ftree-ch -ftree-copy-prop -ftree-copyrename -ftree-dce @gol\n+-ftree-ch -ftree-copy-prop -ftree-copyrename -ftree-dce -ftree-builtin-dce@gol\n -ftree-dominator-opts -ftree-dse -ftree-fre -ftree-loop-im @gol\n -ftree-loop-distribution @gol\n -ftree-loop-ivcanon -ftree-loop-linear -ftree-loop-optimize @gol\n@@ -5157,6 +5157,7 @@ compilation time.\n -ftree-ch @gol\n -ftree-copyrename @gol\n -ftree-dce @gol\n+-ftree-builtin-dce @gol\n -ftree-dominator-opts @gol\n -ftree-dse @gol\n -ftree-fre @gol\n@@ -5873,6 +5874,12 @@ enabled by default at @option{-O2} and higher.\n Perform dead code elimination (DCE) on trees.  This flag is enabled by\n default at @option{-O} and higher.\n \n+@item -ftree-builtin-dce\n+@opindex ftree-builtin-dce\n+Perform conditional dead code elimination (DCE) on builtin calls that\n+may set errno but are otherwise side-effect free.  This flag is enabled by\n+default at @option{-O} and higher.\n+\n @item -ftree-dominator-opts\n @opindex ftree-dominator-opts\n Perform a variety of simple scalar cleanups (constant/copy"}, {"sha": "b03c5a7a627c99805284904eb71fa2aafbdb0450", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30da41ed0e281e0fd35454eb24490ed35325e9b5/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30da41ed0e281e0fd35454eb24490ed35325e9b5/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=30da41ed0e281e0fd35454eb24490ed35325e9b5", "patch": "@@ -886,6 +886,7 @@ decode_options (unsigned int argc, const char **argv)\n       flag_reorder_functions = 1;\n       flag_tree_store_ccp = 1;\n       flag_tree_vrp = 1;\n+      flag_tree_builtin_dce = 1;\n \n       if (!optimize_size)\n \t{"}, {"sha": "8e29fc4979cff89d082e9707c72f5f3fe5a54295", "filename": "gcc/testsuite/gcc.dg/cdce1.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30da41ed0e281e0fd35454eb24490ed35325e9b5/gcc%2Ftestsuite%2Fgcc.dg%2Fcdce1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30da41ed0e281e0fd35454eb24490ed35325e9b5/gcc%2Ftestsuite%2Fgcc.dg%2Fcdce1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcdce1.c?ref=30da41ed0e281e0fd35454eb24490ed35325e9b5", "patch": "@@ -0,0 +1,81 @@\n+/* { dg-do  run } */\n+/* { dg-options \"-O2 -fdump-tree-dce1-details  -lm\" } */\n+/* { dg-message  \"note: function call is shrink-wrapped into error conditions\\.\" \"Missing conditional dce\" {target \"*-*-*\"} 15 } */\n+ \n+#include <stdlib.h>\n+#include <math.h>\n+#include <errno.h>\n+#include <stdio.h>\n+int total_err_count = 0;\n+double foo_opt(int x, double y) __attribute__((noinline));\n+double foo_opt(int x, double y)\n+{\n+    double yy = 0;\n+    errno = 0;\n+    yy = pow(x,y);\n+    return 0;\n+}\n+\n+double foo(int x, double y) __attribute__((noinline));\n+double foo(int x, double y)\n+{\n+    double yy = 0;\n+    errno = 0;\n+    yy = pow(x,y);\n+    return yy;\n+}\n+\n+int test(double (*fp)(int x, double y))\n+{\n+   int i,x;\n+\n+   x = 127; \n+   for (i = 30; i < 300; i++)\n+   {  \n+      fp(x,i);\n+      if (errno)\n+         total_err_count ++;\n+   }\n+\n+   x = -300; \n+   for (i = 100; i < 300; i++)\n+   {  \n+      fp(x,i);\n+      if (errno)\n+         total_err_count ++;\n+   }\n+\n+   x = 65577;\n+   for (i = 60; i < 200; i++)\n+   {  \n+      fp(x,i);\n+      if (errno)\n+         total_err_count ++;\n+   }\n+\n+   x = 65577*127;\n+   for (i = 1; i < 100; i++)\n+   {  \n+      fp(x,i);\n+      if (errno)\n+         total_err_count ++;\n+   }\n+\n+   return total_err_count;\n+}\n+\n+int main()\n+{\n+  int en1, en2;\n+  total_err_count = 0;\n+  en1 = test(foo_opt);\n+  total_err_count = 0;\n+  en2 = test(foo);\n+  \n+  printf(\"total number of errors = %d, %d\\n\", en1, en2);\n+  if (en1 != en2)\n+     abort();\n+\n+  return 0;\n+\n+}"}, {"sha": "8761872ad1fa79423d6ddd3850fa0b3afcacc7a4", "filename": "gcc/testsuite/gcc.dg/cdce2.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30da41ed0e281e0fd35454eb24490ed35325e9b5/gcc%2Ftestsuite%2Fgcc.dg%2Fcdce2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30da41ed0e281e0fd35454eb24490ed35325e9b5/gcc%2Ftestsuite%2Fgcc.dg%2Fcdce2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcdce2.c?ref=30da41ed0e281e0fd35454eb24490ed35325e9b5", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do  run } */\n+/* { dg-options \"-O2 -fdump-tree-dce1-details  -lm\" } */\n+/* { dg-message  \"note: function call is shrink-wrapped into error conditions\\.\" \"Missing conditional dce\" {target \"*-*-*\"} 15 } */\n+ \n+#include <stdlib.h>\n+#include <math.h>\n+#include <errno.h>\n+#include <stdio.h>\n+int total_err_count = 0;\n+double foo_opt(double y) __attribute__((noinline));\n+double foo_opt(double y)\n+{\n+    double yy = 0;\n+    errno = 0;\n+    yy = log(y);\n+    return 0;\n+}\n+\n+double foo(double y) __attribute__((noinline));\n+double foo(double y)\n+{\n+    double yy = 0;\n+    errno = 0;\n+    yy = log(y);\n+    return yy;\n+}\n+\n+int test(double (*fp)(double y) )\n+{\n+   int i,x;\n+\n+   for (i = -100; i < 100; i++)\n+   {  \n+      fp(i);\n+      if (errno)\n+         total_err_count ++;\n+   }\n+\n+  return total_err_count;\n+}\n+\n+int main()\n+{\n+  int en1, en2;\n+  double yy;\n+  total_err_count = 0;\n+  en1 = test(foo_opt);\n+  total_err_count = 0;\n+  en2 = test(foo);\n+\n+  if (en1 != en2)\n+     abort();\n+\n+  return 0;\n+\n+}"}, {"sha": "d1f1c06214d33adf42b342e8d3fcdc76f6439ded", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 636, "deletions": 6, "changes": 642, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30da41ed0e281e0fd35454eb24490ed35325e9b5/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30da41ed0e281e0fd35454eb24490ed35325e9b5/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=30da41ed0e281e0fd35454eb24490ed35325e9b5", "patch": "@@ -48,7 +48,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"ggc.h\"\n-\n+#include \"diagnostic.h\"\n+#include \"toplev.h\"\n /* These RTL headers are needed for basic-block.h.  */\n #include \"rtl.h\"\n #include \"tm_p.h\"\n@@ -75,7 +76,9 @@ static struct stmt_stats\n   int removed_phis;\n } stats;\n \n-static VEC(tree,heap) *worklist;\n+\n+static VEC (tree, heap) *worklist;\n+static VEC (tree, heap) *cond_dead_built_in_calls;\n \n /* Vector indicating an SSA name has already been processed and marked\n    as necessary.  */\n@@ -199,6 +202,189 @@ find_all_control_dependences (struct edge_list *el)\n \n #define NECESSARY(stmt)\t\tstmt->base.asm_written_flag\n \n+/*  Conditional dead call elimination \n+\n+   Some builtin functions can set errno on error conditions, but they\n+   are otherwise pure. If the result of a call to such a function is \n+   not used, the compiler can still not eliminate the call without \n+   powerful interprocedural analysis to prove that the errno is not\n+   checked. However, if the conditions under which the error occurs\n+   are known, compiler can conditionally dead code eliminate the calls\n+   by shrink-wrapping the semi-dead calls into the error condition:\n+      \n+        built_in_call(args) \n+          ==>\n+        if (error_cond(args))\n+             built_in_call(args)\n+\n+   ( An actual simple exampl is :\n+         log (x);   // Mostly dead call\n+     ==>\n+         if (x < 0)\n+             log(x);\n+     With this change, call to log(x) is effectively eliminated, as\n+     in majority of the cases, log won't be called with x out of \n+     range. The branch is totally predicatible, so the branch cost\n+     is low.  Such optimization improves the performance of  \n+     an important application in a big search company by 20% )\n+   \n+   Note that library functions are not supposed to clear errno to zero without\n+   error.\n+   \n+   In this implementation, only 'pow' and 'log' are handled. ('sin' and 'cos' \n+   seem to be wrongly handled by gcc -- they are treated as not touching errno\n+   which is not correct.)\n+   \n+   The condition wrapping the builtin call is conservatively set to avoid too\n+   aggressive (wrong) shrink wrapping. The optimization is called conditional\n+   dead call elimination because the call is eliminated under the condition \n+   that the input arguments would not lead to domain or range error (for \n+   instance when x <= 0 for a log(x) call), however the chances that the error\n+   condition is hit is very low (those builtin calls which are conditionally \n+   dead are usually part of the C++ abstraction penalty exposed after \n+   inlining).  */\n+\n+\n+static bool\n+check_pow (tree pow_call)\n+{\n+  tree base, expn;\n+  enum tree_code bc, ec;\n+\n+  gcc_assert (TREE_CODE (pow_call) == CALL_EXPR);\n+  if (call_expr_nargs (pow_call) != 2)\n+    return false;\n+\n+  base = CALL_EXPR_ARG (pow_call, 0);\n+  expn = CALL_EXPR_ARG (pow_call, 1);\n+\n+  bc = TREE_CODE (base);\n+  ec = TREE_CODE (expn);\n+ \n+  gcc_assert (TREE_CODE_CLASS (bc) != tcc_constant \n+             || bc == REAL_CST);\n+  gcc_assert (TREE_CODE_CLASS (ec) != tcc_constant \n+             || ec == REAL_CST);\n+\n+  /* Folding candidates are not interesting.  */\n+  if (ec == REAL_CST && bc == REAL_CST)\n+    return false;\n+\n+  if (bc == REAL_CST)\n+   {\n+     /* Only handle a fixed range of constant.  */\n+     REAL_VALUE_TYPE mv;\n+     REAL_VALUE_TYPE bcv = TREE_REAL_CST (base);\n+     if (REAL_VALUES_EQUAL (bcv, dconst1))\n+       return false;\n+     if (REAL_VALUES_LESS (bcv, dconst1))\n+       return false;\n+     real_from_integer (&mv, VOIDmode,256,0,1);\n+     if (REAL_VALUES_LESS (mv, bcv))\n+       return false;\n+     return true;\n+   }\n+  else if (bc == SSA_NAME)\n+   {\n+     tree def, nm, rhs, rhs0, var, typ;\n+     int sz;\n+\n+     def = SSA_NAME_DEF_STMT (base);\n+     if (TREE_CODE (def) != GIMPLE_MODIFY_STMT)\n+       return false;\n+\n+     nm = GIMPLE_STMT_OPERAND (def,0);\n+     gcc_assert (TREE_CODE (nm) == SSA_NAME);\n+     if (nm != base) \n+       return false;\n+\n+     rhs = GIMPLE_STMT_OPERAND (def,1);\n+     \n+     if (TREE_CODE (rhs) != FLOAT_EXPR)\n+       return false;\n+     rhs0 = TREE_OPERAND (rhs,0);\n+\n+     if (TREE_CODE (rhs0) != SSA_NAME)\n+       return false;\n+\n+     var = SSA_NAME_VAR (rhs0);\n+     if (TREE_CODE (var) != VAR_DECL &&\n+         TREE_CODE (var) != PARM_DECL)\n+       return false;\n+\n+     typ = TREE_TYPE (var);\n+     if (TREE_CODE (typ) != INTEGER_TYPE)\n+       return false;\n+     sz = int_size_in_bytes (typ);\n+     if (sz == -1 || sz > INT_TYPE_SIZE) \n+       return false;\n+\n+     return true;\n+   }\n+  else\n+    return false;\n+}\n+\n+static bool\n+check_log (tree log_call)\n+{\n+  tree arg_typ;\n+  gcc_assert (TREE_CODE (log_call) == CALL_EXPR);\n+  if (call_expr_nargs (log_call) != 1)\n+    return false;\n+\n+  arg_typ = TREE_TYPE (CALL_EXPR_ARG (log_call, 0));\n+  if (!is_gimple_reg_type (arg_typ))\n+    return false;\n+  return true;\n+}\n+\n+\n+/*  A helper function to determine if a builtin function\n+    call is a candidate for conditional DCE.  */\n+\n+static bool\n+is_unnecessary_except_errno_call (tree call)\n+{\n+  tree fn;\n+  bool is_unnecessary_except_errno = false;\n+  enum built_in_function fnc;\n+\n+  if (!flag_tree_builtin_dce) \n+    return false;\n+\n+  gcc_assert (call);\n+  gcc_assert (!DECL_P (call));\n+  gcc_assert (TREE_CODE (call) == CALL_EXPR);\n+\n+  fn = get_callee_fndecl (call);\n+  if (!fn || !DECL_BUILT_IN (fn)) \n+    return false;\n+\n+  fnc = DECL_FUNCTION_CODE (fn);\n+  switch (fnc)\n+   {\n+     CASE_FLT_FN (BUILT_IN_POW): \n+         if (check_pow (call))\n+           is_unnecessary_except_errno = true;\n+     break;\n+\n+     CASE_FLT_FN (BUILT_IN_LOG):\n+         if (check_log (call))\n+           is_unnecessary_except_errno = true;\n+     break;\n+     default : \n+       is_unnecessary_except_errno = false;\n+     break;\n+   }\n+\n+  if (!is_unnecessary_except_errno) \n+    return false;\n+\n+  return is_unnecessary_except_errno;\n+}\n+\n+\n /* If STMT is not already marked necessary, mark it, and add it to the\n    worklist if ADD_TO_WORKLIST is true.  */\n static inline void\n@@ -244,6 +430,13 @@ mark_operand_necessary (tree op)\n   if (NECESSARY (stmt) || IS_EMPTY_STMT (stmt))\n     return;\n \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+   {\n+     fprintf (dump_file, \" Marked as necessary: \");\n+     print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+     fprintf (dump_file, \"\\n\");\n+   }\n+\n   NECESSARY (stmt) = 1;\n   VEC_safe_push (tree, heap, worklist, stmt);\n }\n@@ -294,15 +487,16 @@ mark_stmt_if_obviously_necessary (tree stmt, bool aggressive)\n       /* Most, but not all function calls are required.  Function calls that\n \t produce no result and have no side effects (i.e. const pure\n \t functions) are unnecessary.  */\n-      if (TREE_SIDE_EFFECTS (stmt))\n-\tmark_stmt_necessary (stmt, true);\n+      if (TREE_SIDE_EFFECTS (stmt)) \n+        mark_stmt_necessary (stmt, true);\n+      \n       return;\n \n     case GIMPLE_MODIFY_STMT:\n       op = get_call_expr_in (stmt);\n       if (op && TREE_SIDE_EFFECTS (op))\n \t{\n-\t  mark_stmt_necessary (stmt, true);\n+          mark_stmt_necessary (stmt, true);\n \t  return;\n \t}\n \n@@ -523,6 +717,421 @@ propagate_necessity (struct edge_list *el)\n     }\n }\n \n+/*  Method to generate conditional statements for guarding condionally\n+    dead calls to pow. One or more statements can be generated for \n+    each logical condition. Statement groups of different conditions\n+    are separated by a NULL tree.  */\n+static void\n+gen_conditions_for_pow (tree pow_call, enum built_in_function fnc, \n+                        VEC (tree, heap)* conds, unsigned * nconds)\n+{\n+  tree base, expn;\n+  enum tree_code bc, ec;\n+  gcc_assert (TREE_CODE (pow_call) == CALL_EXPR);\n+  gcc_assert (call_expr_nargs (pow_call) == 2);\n+  gcc_assert (fnc == BUILT_IN_POW);\n+\n+  *nconds = 0;\n+\n+  base = CALL_EXPR_ARG (pow_call, 0);\n+  expn = CALL_EXPR_ARG (pow_call, 1);\n+\n+  bc = TREE_CODE (base);\n+  ec = TREE_CODE (expn);\n+  \n+  gcc_assert (TREE_CODE_CLASS (bc) != tcc_constant ||\n+             bc == REAL_CST);\n+  gcc_assert (TREE_CODE_CLASS (ec) != tcc_constant ||\n+             ec == REAL_CST);\n+\n+  if (bc == REAL_CST)\n+   {\n+     tree float_typ, max_exp_real_cst;\n+     tree temp, tempn, tempc, tempcn, stmt1, stmt2, stmt3;\n+     REAL_VALUE_TYPE mv;\n+\n+     /* See candidate selection in check_pow. \n+        Since the candidates have a given range\n+        of base values, the guard code generated\n+        for such calls: pow(const,y) are simple:\n+           if ( y > max_y )\n+               pow(const, y);\n+        max_y can be computed separately for each\n+        const base, but in this implemetation, we\n+        choose to compute it using the max base\n+        in the allowed range.  */\n+\n+     REAL_VALUE_TYPE bcv = TREE_REAL_CST (base);\n+     gcc_assert (!REAL_VALUES_EQUAL (bcv, dconst1));\n+     gcc_assert (!REAL_VALUES_LESS (bcv, dconst1));\n+     real_from_integer (&mv, VOIDmode,256,0,1),\n+     gcc_assert (!REAL_VALUES_LESS (mv, bcv));\n+     float_typ = TREE_TYPE (expn); \n+\n+     max_exp_real_cst = build_real (float_typ, mv);\n+     temp = create_tmp_var (float_typ, \"DCE_COND\");\n+     stmt1 = build_gimple_modify_stmt (temp, expn);\n+     tempn = make_ssa_name (temp, stmt1);\n+     GIMPLE_STMT_OPERAND (stmt1, 0) = tempn;\n+\n+     tempc = create_tmp_var (boolean_type_node, \"DCE_COND_TEST\");\n+     stmt2 = build_gimple_modify_stmt (tempc, \n+                                       build2 (GT_EXPR, \n+                                               boolean_type_node, \n+                                               tempn, max_exp_real_cst));\n+     tempcn = make_ssa_name (tempc, stmt2);\n+     GIMPLE_STMT_OPERAND (stmt2, 0) = tempcn;\n+\n+     stmt3 = build3 (COND_EXPR, void_type_node,\n+                     tempcn, NULL_TREE, NULL_TREE);\n+     VEC_safe_push (tree, heap, conds, stmt1);\n+     VEC_safe_push (tree, heap, conds, stmt2);\n+     VEC_safe_push (tree, heap, conds, stmt3);\n+     (*nconds)++;\n+\n+   }\n+  else if (bc == SSA_NAME)\n+   {\n+     tree def, nm, rhs, rhs0, var, int_typ, float_typ;\n+     tree max_exp_cst, max_exp_real_cst;\n+     tree temp1, temp1n, temp2, temp2n, temp2c, temp2cn; \n+     tree cst0, stmt1, stmt2, stmt3;\n+     int sz, max_exp;\n+\n+     /* Generate error condition code for pow calls with\n+        non constant base value. The candidates selected\n+        have their base argument value converted from\n+        integer (see check_pow) value (1,2,4 bytes), and\n+        the max exp value is computed based on the size\n+        of the integer type.  The code below first does\n+        sanity check and then does code generation.  */\n+\n+     def = SSA_NAME_DEF_STMT (base);\n+     gcc_assert (TREE_CODE (def) == GIMPLE_MODIFY_STMT);\n+\n+     nm = GIMPLE_STMT_OPERAND (def,0);\n+     gcc_assert (TREE_CODE (nm) == SSA_NAME);\n+     gcc_assert (nm == base); \n+\n+     rhs = GIMPLE_STMT_OPERAND (def,1);\n+     \n+     gcc_assert (TREE_CODE (rhs) == FLOAT_EXPR);\n+     rhs0 = TREE_OPERAND (rhs,0);\n+     gcc_assert (TREE_CODE (rhs0) == SSA_NAME);\n+\n+     var = SSA_NAME_VAR (rhs0);\n+     gcc_assert (TREE_CODE (var) == VAR_DECL \n+                 || TREE_CODE (var) == PARM_DECL);\n+     \n+     int_typ = TREE_TYPE (var);\n+     gcc_assert (TREE_CODE (int_typ) == INTEGER_TYPE);\n+\n+     sz = int_size_in_bytes (int_typ);\n+     gcc_assert (sz > 0 && sz <= INT_TYPE_SIZE) ;\n+\n+\n+     float_typ = TREE_TYPE (SSA_NAME_VAR (expn)); \n+     if (sz == 1)\n+       max_exp = 128;\n+     else if (sz == 2)\n+       max_exp = 64;\n+     else \n+      {\n+        gcc_assert (sz == 4);\n+        max_exp = 32;\n+      }\n+     max_exp_cst = build_int_cst (integer_type_node, max_exp);\n+     max_exp_real_cst = build_real_from_int_cst (float_typ, max_exp_cst);\n+     \n+     /* For pow ((dobule)x,y), generate the following conditions:\n+      cond 1:\n+        temp1 = x;\n+        if (temp1 <= 0)\n+\n+      cond 2:\n+        temp2 = y;\n+        if (temp2 > max_exp_real_cst)  */\n+\n+     temp2 = create_tmp_var (float_typ, \"DCE_COND2\");\n+     stmt1 = build_gimple_modify_stmt (temp2, expn);\n+     temp2n = make_ssa_name (temp2, stmt1);\n+     GIMPLE_STMT_OPERAND (stmt1,0) = temp2n;\n+\n+     temp2c = create_tmp_var (boolean_type_node, \"DCE_COND2_TEST\");\n+     stmt2 = build_gimple_modify_stmt (temp2c, \n+                                       build2 (GT_EXPR, \n+                                               boolean_type_node, \n+                                               temp2n, max_exp_real_cst));\n+     temp2cn = make_ssa_name (temp2c, stmt2);\n+     GIMPLE_STMT_OPERAND (stmt2, 0) = temp2cn;\n+\n+     stmt3 = build3 (COND_EXPR, void_type_node,\n+                     temp2cn, NULL_TREE, NULL_TREE);\n+     VEC_safe_push (tree, heap, conds, stmt1);\n+     VEC_safe_push (tree, heap, conds, stmt2);\n+     VEC_safe_push (tree, heap, conds, stmt3);\n+     (*nconds)++;\n+\n+     /* now a seperator*/\n+     VEC_safe_push (tree, heap, conds, NULL);\n+\n+     temp1 = create_tmp_var (int_typ, \"DCE_COND1\");\n+     cst0 = build_int_cst (int_typ, 0);\n+     stmt1 = build_gimple_modify_stmt (temp1, rhs0);\n+     temp1n = make_ssa_name (temp1, stmt1);\n+     GIMPLE_STMT_OPERAND (stmt1,0) = temp1n;\n+     stmt2 = build3 (COND_EXPR, void_type_node,\n+                     build2 (LE_EXPR, boolean_type_node, temp1n, cst0),\n+                     NULL_TREE, NULL_TREE);\n+\n+     VEC_safe_push (tree, heap, conds, stmt1);\n+     VEC_safe_push (tree, heap, conds, stmt2);\n+     (*nconds)++;\n+\n+   }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/*  The method to generate error condition guard code for log(x)\n+    calls.  */\n+static void\n+gen_conditions_for_log (tree call, enum built_in_function fnc, \n+                        VEC (tree, heap)* conds, unsigned * nconds)\n+{\n+  tree arg, cst0, temp, tempn, tempc, tempcn, stmt1, stmt2, stmt3;\n+  gcc_assert (TREE_CODE (call) == CALL_EXPR);\n+  gcc_assert (fnc == BUILT_IN_LOG || fnc == BUILT_IN_LOGF || fnc == BUILT_IN_LOGL);\n+\n+  *nconds = 0;\n+\n+  /* for log(x), \n+   Generate condition\n+\n+   temp = x\n+   if (x <= 0)\n+  */\n+  arg = CALL_EXPR_ARG (call, 0);\n+  cst0 = build_real (TREE_TYPE (arg), dconst0);\n+  temp = create_tmp_var (TREE_TYPE (arg), \"DCE_COND\");\n+  stmt1 = build_gimple_modify_stmt (temp, arg);\n+  tempn = make_ssa_name (temp, stmt1);\n+  GIMPLE_STMT_OPERAND (stmt1,0) = tempn;\n+\n+  tempc = create_tmp_var (boolean_type_node, \"DCE_COND_TEST\");\n+  stmt2 = build_gimple_modify_stmt (tempc, \n+                                    build2 (LE_EXPR, \n+                                            boolean_type_node, \n+                                            tempn, cst0));\n+  tempcn = make_ssa_name (tempc, stmt2);\n+  GIMPLE_STMT_OPERAND (stmt2, 0) = tempcn;\n+\n+  stmt3 = build3 (COND_EXPR, void_type_node, tempcn,\n+                       NULL_TREE, NULL_TREE);\n+\n+  VEC_safe_push (tree, heap, conds, stmt1);\n+  VEC_safe_push (tree, heap, conds, stmt2);\n+  VEC_safe_push (tree, heap, conds, stmt3);\n+  (*nconds)++;\n+\n+}\n+\n+\n+/*  The method to generate shrink wrap conditions for partially \n+    a dead builtin call whose return value is not used anywhere,\n+    but has to be kept live due to potential error condition.  \n+\n+    BI_CALL:  the builtin call\n+    CONDS  :  the vector of statements for condition code\n+    NCODES :  the pointer to the number of logical conditions, \n+              which may be different from the length of CONDS\n+              vector. Statements belonging to different logical\n+              condition are separated by NULL tree in the vector\n+*/\n+\n+static void\n+gen_shrink_wrap_conditions (tree bi_call, VEC (tree, heap)* conds, unsigned int * nconds)\n+{\n+  tree call, fn;\n+  enum built_in_function fnc; \n+  gcc_assert (nconds && conds);\n+  gcc_assert (VEC_length(tree, conds) == 0);\n+  gcc_assert (TREE_CODE (bi_call) == GIMPLE_MODIFY_STMT ||\n+             TREE_CODE (bi_call) == CALL_EXPR);\n+\n+  call = bi_call;\n+  if (TREE_CODE (call) == GIMPLE_MODIFY_STMT)\n+    call = get_call_expr_in (bi_call);\n+\n+  fn = get_callee_fndecl (call);\n+  gcc_assert (fn && DECL_BUILT_IN (fn)); \n+  fnc = DECL_FUNCTION_CODE (fn);\n+  *nconds = 0;\n+\n+  switch (fnc)\n+   {\n+     /*CASE_FLT_FN(BUILT_IN_POW)*/\n+     case BUILT_IN_POW:\n+       gen_conditions_for_pow (call, fnc, conds, nconds);\n+     break;\n+     /*CASE_FLT_FN(BUILT_IN_LOG):*/\n+     case BUILT_IN_LOG:\n+     case BUILT_IN_LOGF:\n+     case BUILT_IN_LOGL:\n+       gen_conditions_for_log (call, fnc, conds, nconds);\n+     break;\n+     default : \n+       gcc_assert (0);\n+     break;\n+   }\n+\n+  gcc_assert (*nconds);\n+  return;\n+}\n+\n+\n+#define ERR_PROB 0.01\n+\n+/*  The method to shrink wrap a partially  dead builtin call \n+    whose return value is not used anywhere, but has to be kept \n+    live due to potential error condition.  */\n+static void\n+shrink_wrap_one_built_in_call (tree bi_call)\n+{\n+  block_stmt_iterator bi_call_bsi, join_tgt_bsi;\n+  basic_block bi_call_bb, join_tgt_bb, guard_bb, guard_bb0;\n+  edge join_tgt_in_edge_from_call, join_tgt_in_edge_fall_thru;\n+  tree join_tgt_label_decl, join_tgt_label;\n+  edge bi_call_in_edge0, guard_bb_in_edge;\n+  VEC (tree, heap) *conds;\n+  unsigned tn_cond_stmts, nconds;\n+  unsigned ci;\n+  tree cond_expr = NULL;\n+  tree cond_expr_start;\n+  tree bi_call_label_decl;\n+  tree bi_call_label;\n+\n+  conds = VEC_alloc (tree, heap, 10);\n+  gen_shrink_wrap_conditions (bi_call, conds, &nconds);\n+\n+  gcc_assert (nconds > 0);\n+  /* Make sure no reallocation happens. */\n+  gcc_assert (VEC_length (tree, conds) <= 10);\n+  gcc_assert (VEC_length (tree, conds) >= nconds);\n+  bi_call_bb = bb_for_stmt (bi_call);\n+\n+  /* Now find the join target bb -- split \n+     bi_call_bb if needed */\n+  bi_call_bsi = bsi_for_stmt (bi_call);\n+\n+  gcc_assert (!bsi_end_p (bi_call_bsi));\n+  join_tgt_in_edge_from_call = split_block (bi_call_bb, bi_call);\n+  bi_call_bsi = bsi_for_stmt (bi_call);\n+\n+  join_tgt_bb = join_tgt_in_edge_from_call->dest;\n+  join_tgt_label_decl = create_artificial_label ();\n+  join_tgt_label = build1 (LABEL_EXPR, void_type_node, join_tgt_label_decl);\n+  join_tgt_bsi = bsi_start (join_tgt_bb);\n+  bsi_insert_before (&join_tgt_bsi, join_tgt_label, BSI_SAME_STMT);\n+\n+  /* Now it is time to insert the first condtional expression \n+     into bi_call_bb and split this bb so that bi_call is \n+     shrink-wrapped*/\n+  tn_cond_stmts = VEC_length (tree, conds);\n+  cond_expr = NULL;\n+  cond_expr_start = VEC_index (tree, conds,0);\n+  for (ci = 0; ci < tn_cond_stmts; ci++)\n+   {\n+     tree c = VEC_index (tree, conds, ci);\n+     gcc_assert ( c || ci != 0 );\n+     if (!c) break;\n+     bsi_insert_before (&bi_call_bsi, c, BSI_SAME_STMT);\n+     cond_expr = c;\n+   }\n+  nconds --;\n+  ci ++;\n+  gcc_assert (cond_expr && TREE_CODE (cond_expr) == COND_EXPR);\n+\n+  /* now the label*/\n+  bi_call_label_decl = create_artificial_label ();\n+  bi_call_label = build1 (LABEL_EXPR, void_type_node, bi_call_label_decl);\n+  bsi_insert_before (&bi_call_bsi, bi_call_label, BSI_SAME_STMT);\n+\n+  bi_call_in_edge0 = split_block (bi_call_bb, cond_expr);\n+  bi_call_in_edge0->flags &= ~EDGE_FALLTHRU;\n+  bi_call_in_edge0->flags |= EDGE_TRUE_VALUE;\n+  guard_bb0 = bi_call_bb;\n+  bi_call_bb = bi_call_in_edge0->dest;\n+  join_tgt_in_edge_fall_thru = make_edge (guard_bb0, join_tgt_bb, EDGE_FALSE_VALUE);\n+\n+  bi_call_in_edge0->probability = REG_BR_PROB_BASE*ERR_PROB;\n+  join_tgt_in_edge_fall_thru->probability = \n+      REG_BR_PROB_BASE - bi_call_in_edge0->probability;\n+\n+  /* code generation for the rest of the conditions */\n+  guard_bb = guard_bb0;\n+  for (; nconds > 0; )\n+   {\n+     unsigned ci0;\n+     edge bi_call_in_edge; \n+     block_stmt_iterator guard_bsi = bsi_for_stmt (cond_expr_start);\n+     ci0 = ci;\n+     cond_expr_start = VEC_index (tree, conds, ci0);\n+     for (; ci < tn_cond_stmts; ci++)\n+      {\n+        tree c = VEC_index (tree, conds, ci);\n+        gcc_assert ( c || ci != ci0 );\n+        if (!c) \n+          break;\n+        bsi_insert_before (&guard_bsi, c, BSI_SAME_STMT);\n+        cond_expr = c;\n+      }\n+     nconds --;\n+     ci ++;\n+     gcc_assert (cond_expr && TREE_CODE (cond_expr) == COND_EXPR);\n+     guard_bb_in_edge = split_block (guard_bb, cond_expr);\n+     guard_bb_in_edge->flags &= ~EDGE_FALLTHRU;\n+     guard_bb_in_edge->flags |= EDGE_FALSE_VALUE;\n+\n+     bi_call_in_edge = make_edge (guard_bb, bi_call_bb, EDGE_TRUE_VALUE);\n+\n+     bi_call_in_edge->probability = REG_BR_PROB_BASE*ERR_PROB;\n+     guard_bb_in_edge->probability = \n+         REG_BR_PROB_BASE - bi_call_in_edge->probability;\n+\n+   }\n+\n+  VEC_free (tree, heap, conds);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+   {\n+     location_t loc;\n+     loc = EXPR_LOCATION (bi_call);\n+     inform (\n+         \"%Hfunction call is shrink-wrapped into error conditions.\",\n+         &loc);\n+   }\n+}\n+\n+/*  The top level method for conditional dead code shrink \n+    wrapping transformation.  */\n+\n+static bool\n+shrink_wrap_conditional_dead_built_in_calls (void)\n+{\n+  unsigned i = 0;\n+  unsigned n = VEC_length (tree, cond_dead_built_in_calls);\n+  if (n == 0) return false;\n+\n+  for (; i < n ; i++)\n+   {\n+     tree bi_call = VEC_index (tree,  cond_dead_built_in_calls, i);\n+     shrink_wrap_one_built_in_call (bi_call);\n+   }\n+\n+  cfg_altered = true;\n+\n+  return true;\n+}\n \n /* Remove dead PHI nodes from block BB.  */\n \n@@ -711,13 +1320,27 @@ eliminate_unnecessary_stmts (void)\n \t\t\t  print_generic_stmt (dump_file, t, TDF_SLIM);\n \t\t\t  fprintf (dump_file, \"\\n\");\n \t\t\t}\n+\n+                      if (is_unnecessary_except_errno_call (call))\n+                       {\n+                         if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t\t  {\n+                            fprintf (dump_file, \"Found conditional dead call: \");\n+                            print_generic_stmt (dump_file, t, TDF_SLIM);\n+                            fprintf (dump_file, \"\\n\");\n+                          }\n+                         VEC_safe_push (tree, heap, cond_dead_built_in_calls, call);\n+                       }\n+\n \t\t      push_stmt_changes (bsi_stmt_ptr (i));\n \t\t      TREE_BLOCK (call) = TREE_BLOCK (t);\n \t\t      bsi_replace (&i, call, false);\n \t\t      maybe_clean_or_replace_eh_stmt (t, call);\n \t\t      mark_symbols_for_renaming (call);\n \t\t      pop_stmt_changes (bsi_stmt_ptr (i));\n \t\t      release_ssa_name (oldlhs);\n+\n+\n \t\t    }\n \t\t  notice_special_calls (call);\n \t\t}\n@@ -726,6 +1349,9 @@ eliminate_unnecessary_stmts (void)\n \t}\n     }\n \n+  something_changed |= \n+      shrink_wrap_conditional_dead_built_in_calls ();\n+\n   return something_changed;\n }\n \n@@ -776,7 +1402,9 @@ tree_dce_init (bool aggressive)\n   sbitmap_zero (processed);\n \n   worklist = VEC_alloc (tree, heap, 64);\n+  cond_dead_built_in_calls = VEC_alloc (tree, heap,64);\n   cfg_altered = false;\n+  \n }\n \n /* Cleanup after this pass.  */\n@@ -799,7 +1427,9 @@ tree_dce_done (bool aggressive)\n   sbitmap_free (processed);\n \n   VEC_free (tree, heap, worklist);\n+  VEC_free (tree, heap, cond_dead_built_in_calls);\n }\n+\n \f\n /* Main routine to eliminate dead code.\n \n@@ -841,7 +1471,7 @@ perform_tree_ssa_dce (bool aggressive)\n   find_obviously_necessary_stmts (el);\n \n   propagate_necessity (el);\n-\n+  \n   something_changed |= eliminate_unnecessary_stmts ();\n   something_changed |= cfg_altered;\n "}]}