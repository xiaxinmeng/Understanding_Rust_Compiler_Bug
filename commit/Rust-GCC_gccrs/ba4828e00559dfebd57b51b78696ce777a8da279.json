{"sha": "ba4828e00559dfebd57b51b78696ce777a8da279", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE0ODI4ZTAwNTU5ZGZlYmQ1N2I1MWI3ODY5NmNlNzc3YThkYTI3OQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-07-11T20:35:55Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-07-11T20:35:55Z"}, "message": "alias.c (set_mem_alias_set): New function.\n\n\t* alias.c (set_mem_alias_set): New function.\n\t* rtl.h (set_mem_alias_set): Declare it.\n\t* builtins.c (expand_builtin_return_addr): Call it instead of\n\tusing MEM_ALIAS_SET accessor.\n\t(expand_builtin_setjmp_setup, expand_builtin_longjmp): Likewise.\n\t(get_memory_rtx, expand_builtin_va_arg): Likewise.\n\t(expand_builtin_va_copy):Likewise.\n\t* caller-save.c (setup_save_areas): Likewise.\n\t* calls.c (compute_argument_addresses): Likewise.\n\t* explow.c (set_mem_attributes): Likewise.\n\t* expr.c (emit_single_push_insn, emit_push_insn): Likewise.\n\t(expand_assignment, store_constructor_field, store_field): Likewise.\n\t(expand_expr_unaligned): Likewise.\n\t* function.c (assign_stack_temp_for_type): Likewise.\n\t(put_reg_into_stack, gen_mem_addressof): Likewise.\n\t* ifcvt.c (noce_try_cmove_arith): Likewise.\n\t* reload1.c (reload, alter_reg): Likewise.\n\t* config/alpha/alpha.c (get_aligned_mem): Likewise.\n\t(alpha_set_memflags_1, alpha_expand_unaligned_load): Likewise.\n\t(alpha_expand_unaligned_store): Likewise\n\t(alpha_expand_unaligned_load_words): Likewise.\n\t(alpha_expand_unaligned_store_words): Likewise.\n\t(alpha_expand_block_clear, alpha_expand_prologue): Likewise.\n\t(alpha_expand_epilogue): Likewise.\n\t* config/arc/arc.c (arc_setup_incoming_varargs): Likewise.\n\t* config/clipper/clipper.c (clipper_builtin_saveregs): Likewise.\n\t* config/i386/i386.c (legitimize_pic_address): Likewise.\n\t* config/i960/i960.c (setup_incoming_varargs): Likewise.\n\t* config/ia64/ia64.c (spill_restore_mem): Likewise.\n\t* config/m32r/m32r.c (m32r_setup_incoming_varargs): Likewise.\n\t* config/m8k/m88k.c (m88k_builtin_saveregs): Likewise.\n\t* config/mips/mips.c (mips_va_arg): Likewise.\n\t* config/mn10300/mn10300.c (mn10300_builtin_saveregs): Likewise.\n\t* config/pa/pa.c (hppa_builtin_saveregs): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_emit_move): Likewise.\n\t(setup_incoming_varargs, rs6000_va_arg): Likewise.\n\t(rs6000_emit_eh_toc_restore, rs6000_emit_prologue): Likewise.\n\t(rs6000_emit_epilogue): Likewise.\n\t* config/sh/sh.c (sh_builtin_saveregs): Likewise.\n\t* config/sparc/sparc.c (sparc_va_arg): Likewise.\n\t* config/v850/v850.c (v850_va_arg): Likewise.\n\nFrom-SVN: r43951", "tree": {"sha": "ea2ecbe0d6bd9cbb548d5205145a8127268d347b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea2ecbe0d6bd9cbb548d5205145a8127268d347b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba4828e00559dfebd57b51b78696ce777a8da279", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba4828e00559dfebd57b51b78696ce777a8da279", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba4828e00559dfebd57b51b78696ce777a8da279", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba4828e00559dfebd57b51b78696ce777a8da279/comments", "author": null, "committer": null, "parents": [{"sha": "46fac66482f1cf5cc61f7fef9de8b7593c8357e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46fac66482f1cf5cc61f7fef9de8b7593c8357e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46fac66482f1cf5cc61f7fef9de8b7593c8357e7"}], "stats": {"total": 323, "additions": 193, "deletions": 130}, "files": [{"sha": "6e8f49130d4f0aaa17aa99024c9df281857edab1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -1,3 +1,47 @@\n+Wed Jul 11 10:07:18 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* alias.c (set_mem_alias_set): New function.\n+\t* rtl.h (set_mem_alias_set): Declare it.\n+\t* builtins.c (expand_builtin_return_addr): Call it instead of\n+\tusing MEM_ALIAS_SET accessor.\n+\t(expand_builtin_setjmp_setup, expand_builtin_longjmp): Likewise.\n+\t(get_memory_rtx, expand_builtin_va_arg): Likewise.\n+\t(expand_builtin_va_copy):Likewise.\n+\t* caller-save.c (setup_save_areas): Likewise.\n+\t* calls.c (compute_argument_addresses): Likewise.\n+\t* explow.c (set_mem_attributes): Likewise.\n+\t* expr.c (emit_single_push_insn, emit_push_insn): Likewise.\n+\t(expand_assignment, store_constructor_field, store_field): Likewise.\n+\t(expand_expr_unaligned): Likewise.\n+\t* function.c (assign_stack_temp_for_type): Likewise.\n+\t(put_reg_into_stack, gen_mem_addressof): Likewise.\n+\t* ifcvt.c (noce_try_cmove_arith): Likewise.\n+\t* reload1.c (reload, alter_reg): Likewise.\n+\t* config/alpha/alpha.c (get_aligned_mem): Likewise.\n+\t(alpha_set_memflags_1, alpha_expand_unaligned_load): Likewise.\n+\t(alpha_expand_unaligned_store): Likewise\n+\t(alpha_expand_unaligned_load_words): Likewise.\n+\t(alpha_expand_unaligned_store_words): Likewise.\n+\t(alpha_expand_block_clear, alpha_expand_prologue): Likewise.\n+\t(alpha_expand_epilogue): Likewise.\n+\t* config/arc/arc.c (arc_setup_incoming_varargs): Likewise.\n+\t* config/clipper/clipper.c (clipper_builtin_saveregs): Likewise.\n+\t* config/i386/i386.c (legitimize_pic_address): Likewise.\n+\t* config/i960/i960.c (setup_incoming_varargs): Likewise.\n+\t* config/ia64/ia64.c (spill_restore_mem): Likewise.\n+\t* config/m32r/m32r.c (m32r_setup_incoming_varargs): Likewise.\n+\t* config/m8k/m88k.c (m88k_builtin_saveregs): Likewise.\n+\t* config/mips/mips.c (mips_va_arg): Likewise.\n+\t* config/mn10300/mn10300.c (mn10300_builtin_saveregs): Likewise.\n+\t* config/pa/pa.c (hppa_builtin_saveregs): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_emit_move): Likewise.\n+\t(setup_incoming_varargs, rs6000_va_arg): Likewise.\n+\t(rs6000_emit_eh_toc_restore, rs6000_emit_prologue): Likewise.\n+\t(rs6000_emit_epilogue): Likewise.\n+\t* config/sh/sh.c (sh_builtin_saveregs): Likewise.\n+\t* config/sparc/sparc.c (sparc_va_arg): Likewise.\n+\t* config/v850/v850.c (v850_va_arg): Likewise.\n+\n Wed Jul 11 21:27:25 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* flow.c (merge_blocks_move_successor_nojumps): Do not crash"}, {"sha": "912be4819c2bc426295e0be55de655ea2602e4ef", "filename": "gcc/alias.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -278,6 +278,24 @@ alias_sets_conflict_p (set1, set2)\n   return 0;\n }\n \f\n+/* Set the alias set of MEM to SET.  */\n+\n+void\n+set_mem_alias_set (mem, set)\n+     rtx mem;\n+     HOST_WIDE_INT set;\n+{\n+  /* We would like to do this test but can't yet since when converting a\n+     REG to a MEM, the alias set field is undefined.  */\n+#if 0\n+  /* If the new and old alias sets don't conflict, something is wrong.  */\n+  if (!alias_sets_conflict_p (set, MEM_ALIAS_SET (mem)))\n+    abort ();\n+#endif\n+\n+  MEM_ALIAS_SET (mem) = set;\n+}\n+\f\n /* Return 1 if TYPE is a RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE and has\n    has any readonly fields.  If any of the fields have types that\n    contain readonly fields, return true as well.  */"}, {"sha": "219714dd7d1cd551b225bdb1702ee4707d063fb8", "filename": "gcc/builtins.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -427,7 +427,7 @@ expand_builtin_return_addr (fndecl_code, count, tem)\n #endif\n       tem = memory_address (Pmode, tem);\n       tem = gen_rtx_MEM (Pmode, tem);\n-      MEM_ALIAS_SET (tem) = get_frame_alias_set ();\n+      set_mem_alias_set (tem, get_frame_alias_set ());\n       tem = copy_to_reg (tem);\n     }\n \n@@ -443,7 +443,7 @@ expand_builtin_return_addr (fndecl_code, count, tem)\n   tem = memory_address (Pmode,\n \t\t\tplus_constant (tem, GET_MODE_SIZE (Pmode)));\n   tem = gen_rtx_MEM (Pmode, tem);\n-  MEM_ALIAS_SET (tem) = get_frame_alias_set ();\n+  set_mem_alias_set (tem, get_frame_alias_set ());\n #endif\n   return tem;\n }\n@@ -484,19 +484,19 @@ expand_builtin_setjmp_setup (buf_addr, receiver_label)\n #endif\n \n   mem = gen_rtx_MEM (Pmode, buf_addr);\n-  MEM_ALIAS_SET (mem) = setjmp_alias_set;\n+  set_mem_alias_set (mem, setjmp_alias_set);\n   emit_move_insn (mem, BUILTIN_SETJMP_FRAME_VALUE);\n \n   mem = gen_rtx_MEM (Pmode, plus_constant (buf_addr, GET_MODE_SIZE (Pmode))),\n-  MEM_ALIAS_SET (mem) = setjmp_alias_set;\n+  set_mem_alias_set (mem, setjmp_alias_set);\n \n   emit_move_insn (validize_mem (mem),\n \t\t  force_reg (Pmode, gen_rtx_LABEL_REF (Pmode, receiver_label)));\n \n   stack_save = gen_rtx_MEM (sa_mode,\n \t\t\t    plus_constant (buf_addr,\n \t\t\t\t\t   2 * GET_MODE_SIZE (Pmode)));\n-  MEM_ALIAS_SET (stack_save) = setjmp_alias_set;\n+  set_mem_alias_set (stack_save, setjmp_alias_set);\n   emit_stack_save (SAVE_NONLOCAL, &stack_save, NULL_RTX);\n \n   /* If there is further processing to do, do it.  */\n@@ -685,8 +685,9 @@ expand_builtin_longjmp (buf_addr, value)\n \n       stack = gen_rtx_MEM (sa_mode, plus_constant (buf_addr,\n \t\t\t\t\t\t   2 * GET_MODE_SIZE (Pmode)));\n-      MEM_ALIAS_SET (fp) = MEM_ALIAS_SET (lab) = MEM_ALIAS_SET (stack)\n-\t= setjmp_alias_set;\n+      set_mem_alias_set (fp, setjmp_alias_set);\n+      set_mem_alias_set (lab, setjmp_alias_set);\n+      set_mem_alias_set (stack, setjmp_alias_set);\n \n       /* Pick up FP, label, and SP from the block and jump.  This code is\n \t from expand_goto in stmt.c; see there for detailed comments.  */\n@@ -756,9 +757,8 @@ get_memory_rtx (exp)\n     return mem;\n \n   set_mem_attributes (mem, exp, 0);\n-\n   /* memcpy, memset and other builtin stringops can alias with anything. */\n-  MEM_ALIAS_SET (mem) = 0;\n+  set_mem_alias_set (mem, 0);\n   return mem;\n }\n \f\n@@ -2965,7 +2965,7 @@ expand_builtin_va_arg (valist, type)\n     }\n \n   result = gen_rtx_MEM (TYPE_MODE (type), addr);\n-  MEM_ALIAS_SET (result) = get_varargs_alias_set ();\n+  set_mem_alias_set (result, get_varargs_alias_set ());\n \n   return result;\n }\n@@ -3025,9 +3025,9 @@ expand_builtin_va_copy (arglist)\n \n       /* \"Dereference\" to BLKmode memories.  */\n       dstb = gen_rtx_MEM (BLKmode, dstb);\n-      MEM_ALIAS_SET (dstb) = get_alias_set (TREE_TYPE (TREE_TYPE (dst)));\n+      set_mem_alias_set (dstb, get_alias_set (TREE_TYPE (TREE_TYPE (dst))));\n       srcb = gen_rtx_MEM (BLKmode, srcb);\n-      MEM_ALIAS_SET (srcb) = get_alias_set (TREE_TYPE (TREE_TYPE (src)));\n+      set_mem_alias_set (srcb, get_alias_set (TREE_TYPE (TREE_TYPE (src))));\n \n       /* Copy.  */\n       emit_block_move (dstb, srcb, size, TYPE_ALIGN (va_list_type_node));"}, {"sha": "0d36f30c31a1af7134a8c09e1068ec7ea06cd4cc", "filename": "gcc/caller-save.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -342,7 +342,7 @@ setup_save_areas ()\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     for (j = MOVE_MAX_WORDS; j > 0; j--)\n       if (regno_save_mem[i][j] != 0)\n-\tMEM_ALIAS_SET (regno_save_mem[i][j]) = get_frame_alias_set ();\n+\tset_mem_alias_set (regno_save_mem[i][j], get_frame_alias_set ());\n }\n \f\n /* Find the places where hard regs are live across calls and save them.  */"}, {"sha": "7421d340cd192ba7b098a44e2e6afedddc3ad4ff", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -1626,8 +1626,8 @@ compute_argument_addresses (args, argblock, num_actuals)\n \t     outgoing arguments and we cannot allow reordering of reads\n \t     from function arguments with stores to outgoing arguments\n \t     of sibling calls.  */\n-\t  MEM_ALIAS_SET (args[i].stack) = 0;\n-\t  MEM_ALIAS_SET (args[i].stack_slot) = 0;\n+\t  set_mem_alias_set (args[i].stack, 0);\n+\t  set_mem_alias_set (args[i].stack_slot, 0);\n \t}\n     }\n }"}, {"sha": "1f62d0d8e7f870b34ef692de12ab34337a9b8bd6", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -1102,7 +1102,7 @@ get_aligned_mem (ref, paligned_mem, pbitnum)\n \n   /* Sadly, we cannot use alias sets here because we may overlap other\n      data in a different alias set.  */\n-  MEM_ALIAS_SET (*paligned_mem) = 0;\n+  set_mem_alias_set (*paligned_mem, 0);\n \n   *pbitnum = GEN_INT ((offset & 3) * 8);\n }\n@@ -1229,7 +1229,6 @@ alpha_set_memflags_1 (x, in_struct_p, volatile_p, unchanging_p)\n \t are the only thing we would be able to differentiate anyway,\n \t there does not seem to be any point in convoluting the early\n \t out of the alias check.  */\n-      /* MEM_ALIAS_SET (x) = alias_set; */\n       break;\n \n     default:\n@@ -2519,15 +2518,15 @@ alpha_expand_unaligned_load (tgt, mem, size, ofs, sign)\n \t\t\tgen_rtx_AND (DImode, \n \t\t\t\t     plus_constant (XEXP (mem, 0), ofs),\n \t\t\t\t     GEN_INT (-8)));\n-  MEM_ALIAS_SET (tmp) = 0;\n+  set_mem_alias_set (tmp, 0);\n   emit_move_insn (meml, tmp);\n \n   tmp = change_address (mem, DImode,\n \t\t\tgen_rtx_AND (DImode, \n \t\t\t\t     plus_constant (XEXP (mem, 0),\n \t\t\t\t\t\t    ofs + size - 1),\n \t\t\t\t     GEN_INT (-8)));\n-  MEM_ALIAS_SET (tmp) = 0;\n+  set_mem_alias_set (tmp, 0);\n   emit_move_insn (memh, tmp);\n \n   if (sign && size == 2)\n@@ -2600,14 +2599,14 @@ alpha_expand_unaligned_store (dst, src, size, ofs)\n \t\t\t gen_rtx_AND (DImode, \n \t\t\t\t      plus_constant (XEXP (dst, 0), ofs),\n \t\t\t\t      GEN_INT (-8)));\n-  MEM_ALIAS_SET (meml) = 0;\n+  set_mem_alias_set (meml, 0);\n \n   memh = change_address (dst, DImode,\n \t\t\t gen_rtx_AND (DImode, \n \t\t\t\t      plus_constant (XEXP (dst, 0),\n \t\t\t\t\t\t     ofs+size-1),\n \t\t\t\t      GEN_INT (-8)));\n-  MEM_ALIAS_SET (memh) = 0;\n+  set_mem_alias_set (memh, 0);\n \n   emit_move_insn (dsth, memh);\n   emit_move_insn (dstl, meml);\n@@ -2705,15 +2704,15 @@ alpha_expand_unaligned_load_words (out_regs, smem, words, ofs)\n \t\t\t    gen_rtx_AND (DImode,\n \t\t\t\t\t plus_constant (XEXP(smem,0), 8*i),\n \t\t\t\t\t im8));\n-      MEM_ALIAS_SET (tmp) = 0;\n+      set_mem_alias_set (tmp, 0);\n       emit_move_insn (data_regs[i], tmp);\n     }\n \n   tmp = change_address (smem, DImode,\n \t\t\tgen_rtx_AND (DImode,\n \t\t\t\t     plus_constant (XEXP(smem,0), 8*words - 1),\n \t\t\t\t     im8));\n-  MEM_ALIAS_SET (tmp) = 0;\n+  set_mem_alias_set (tmp, 0);\n   emit_move_insn (data_regs[words], tmp);\n \n   /* Extract the half-word fragments.  Unfortunately DEC decided to make\n@@ -2779,13 +2778,13 @@ alpha_expand_unaligned_store_words (data_regs, dmem, words, ofs)\n \t\t\t\t\t   plus_constant (XEXP(dmem,0),\n \t\t\t\t\t\t\t  words*8 - 1),\n \t\t\t\t       im8));\n-  MEM_ALIAS_SET (st_addr_2) = 0;\n+  set_mem_alias_set (st_addr_2, 0);\n \n   st_addr_1 = change_address (dmem, DImode,\n \t\t\t      gen_rtx_AND (DImode, \n \t\t\t\t\t   XEXP (dmem, 0),\n \t\t\t\t\t   im8));\n-  MEM_ALIAS_SET (st_addr_1) = 0;\n+  set_mem_alias_set (st_addr_1, 0);\n \n   /* Load up the destination end bits.  */\n   emit_move_insn (st_tmp_2, st_addr_2);\n@@ -2828,7 +2827,7 @@ alpha_expand_unaligned_store_words (data_regs, dmem, words, ofs)\n \t\t\t\tgen_rtx_AND (DImode,\n \t\t\t\t\t     plus_constant(XEXP (dmem,0), i*8),\n \t\t\t\t\t     im8));\n-      MEM_ALIAS_SET (tmp) = 0;\n+      set_mem_alias_set (tmp, 0);\n       emit_move_insn (tmp, data_regs ? ins_tmps[i-1] : const0_rtx);\n     }\n   emit_move_insn (st_addr_1, st_tmp_1);\n@@ -3253,7 +3252,7 @@ alpha_expand_block_clear (operands)\n \t  HOST_WIDE_INT mask;\n \n \t  mem = adjust_address (orig_dst, mode, ofs - inv_alignofs);\n-\t  MEM_ALIAS_SET (mem) = 0;\n+\t  set_mem_alias_set (mem, 0);\n \n \t  mask = ~(~(HOST_WIDE_INT)0 << (inv_alignofs * 8));\n \t  if (bytes < alignofs)\n@@ -3333,13 +3332,13 @@ alpha_expand_block_clear (operands)\n       words = bytes / 8;\n       for (i = 0; i < words; ++i)\n \t{\n-\t  rtx mem;\n-\t  mem = change_address (orig_dst, DImode,\n-\t\t\t\tgen_rtx_AND (DImode,\n-\t\t\t\t\t     plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t\t    ofs + i*8),\n-\t\t\t\t\t     GEN_INT (-8)));\n-\t  MEM_ALIAS_SET (mem) = 0;\n+\t  rtx mem\n+\t    = change_address (orig_dst, DImode,\n+\t\t\t      gen_rtx_AND (DImode,\n+\t\t\t\t\t   plus_constant (XEXP (orig_dst, 0),\n+\t\t\t\t\t\t\t  ofs + i*8),\n+\t\t\t\t\t   GEN_INT (-8)));\n+\t  set_mem_alias_set (mem, 0);\n \t  emit_move_insn (mem, const0_rtx);\n \t}\n \n@@ -3398,7 +3397,7 @@ alpha_expand_block_clear (operands)\n \t  HOST_WIDE_INT mask;\n \n \t  mem = adjust_address (orig_dst, DImode, ofs);\n-\t  MEM_ALIAS_SET (mem) = 0;\n+\t  set_mem_alias_set (mem, 0);\n \n \t  mask = ~(HOST_WIDE_INT)0 << (bytes * 8);\n \n@@ -3414,7 +3413,7 @@ alpha_expand_block_clear (operands)\n \t  HOST_WIDE_INT mask;\n \n \t  mem = adjust_address (orig_dst, SImode, ofs);\n-\t  MEM_ALIAS_SET (mem) = 0;\n+\t  set_mem_alias_set (mem, 0);\n \n \t  mask = ~(HOST_WIDE_INT)0 << (bytes * 8);\n \n@@ -4741,15 +4740,15 @@ alpha_expand_prologue ()\n   if (TARGET_OPEN_VMS && vms_is_stack_procedure)\n     {\n       mem = gen_rtx_MEM (DImode, stack_pointer_rtx);\n-      MEM_ALIAS_SET (mem) = alpha_sr_alias_set;\n+      set_mem_alias_set (mem, alpha_sr_alias_set);\n       FRP (emit_move_insn (mem, gen_rtx_REG (DImode, REG_PV)));\n     }\n \n   /* Save register RA next.  */\n   if (imask & (1L << REG_RA))\n     {\n       mem = gen_rtx_MEM (DImode, plus_constant (sa_reg, reg_offset));\n-      MEM_ALIAS_SET (mem) = alpha_sr_alias_set;\n+      set_mem_alias_set (mem, alpha_sr_alias_set);\n       FRP (emit_move_insn (mem, gen_rtx_REG (DImode, REG_RA)));\n       imask &= ~(1L << REG_RA);\n       reg_offset += 8;\n@@ -4760,7 +4759,7 @@ alpha_expand_prologue ()\n     if (imask & (1L << i))\n       {\n \tmem = gen_rtx_MEM (DImode, plus_constant (sa_reg, reg_offset));\n-\tMEM_ALIAS_SET (mem) = alpha_sr_alias_set;\n+\tset_mem_alias_set (mem, alpha_sr_alias_set);\n \tFRP (emit_move_insn (mem, gen_rtx_REG (DImode, i)));\n \treg_offset += 8;\n       }\n@@ -4769,7 +4768,7 @@ alpha_expand_prologue ()\n     if (fmask & (1L << i))\n       {\n \tmem = gen_rtx_MEM (DFmode, plus_constant (sa_reg, reg_offset));\n-\tMEM_ALIAS_SET (mem) = alpha_sr_alias_set;\n+\tset_mem_alias_set (mem, alpha_sr_alias_set);\n \tFRP (emit_move_insn (mem, gen_rtx_REG (DFmode, i+32)));\n \treg_offset += 8;\n       }\n@@ -5104,7 +5103,7 @@ alpha_expand_epilogue ()\n \n       mem = gen_rtx_MEM (DImode, plus_constant (sa_reg, reg_offset));\n       if (! eh_ofs)\n-        MEM_ALIAS_SET (mem) = alpha_sr_alias_set;\n+        set_mem_alias_set (mem, alpha_sr_alias_set);\n       FRP (emit_move_insn (gen_rtx_REG (DImode, REG_RA), mem));\n \n       reg_offset += 8;\n@@ -5118,7 +5117,7 @@ alpha_expand_epilogue ()\n \t    else\n \t      {\n \t\tmem = gen_rtx_MEM (DImode, plus_constant(sa_reg, reg_offset));\n-\t\tMEM_ALIAS_SET (mem) = alpha_sr_alias_set;\n+\t\tset_mem_alias_set (mem, alpha_sr_alias_set);\n \t\tFRP (emit_move_insn (gen_rtx_REG (DImode, i), mem));\n \t      }\n \t    reg_offset += 8;\n@@ -5128,7 +5127,7 @@ alpha_expand_epilogue ()\n \tif (fmask & (1L << i))\n \t  {\n \t    mem = gen_rtx_MEM (DFmode, plus_constant(sa_reg, reg_offset));\n-\t    MEM_ALIAS_SET (mem) = alpha_sr_alias_set;\n+\t    set_mem_alias_set (mem, alpha_sr_alias_set);\n \t    FRP (emit_move_insn (gen_rtx_REG (DFmode, i+32), mem));\n \t    reg_offset += 8;\n \t  }\n@@ -5186,7 +5185,7 @@ alpha_expand_epilogue ()\n \t{\n \t  emit_insn (gen_blockage ());\n \t  mem = gen_rtx_MEM (DImode, plus_constant (sa_reg, fp_offset));\n-\t  MEM_ALIAS_SET (mem) = alpha_sr_alias_set;\n+\t  set_mem_alias_set (mem, alpha_sr_alias_set);\n \t  FRP (emit_move_insn (hard_frame_pointer_rtx, mem));\n \t}\n       else if (TARGET_OPEN_VMS)"}, {"sha": "0fe070be9a251acee4cab5ca05d181ec673e4031", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines used for code generation on the Argonaut ARC cpu.\n-   Copyright (C) 1994, 1995, 1997, 1998, 1999,\n-   2000 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001\n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -797,7 +797,7 @@ arc_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n \t\t\t      plus_constant (arg_pointer_rtx,\n \t\t\t\t\t     FIRST_PARM_OFFSET (0)\n \t\t\t\t\t     + align_slop * UNITS_PER_WORD));\n-      MEM_ALIAS_SET (regblock) = get_varargs_alias_set ();\n+      set_mem_alias_set (regblock, get_varargs_alias_set ());\n       move_block_from_reg (first_reg_offset, regblock,\n \t\t\t   MAX_ARC_PARM_REGS - first_reg_offset,\n \t\t\t   ((MAX_ARC_PARM_REGS - first_reg_offset)"}, {"sha": "1e3118e84f34239f6027493e3a95129694dacebc", "filename": "gcc/config/clipper/clipper.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fclipper%2Fclipper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fclipper%2Fclipper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for insn-output.c for Clipper\n-   Copyright (C) 1987, 1988, 1991, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1991, 1997, 1998, 1999, 2000, 2001\n+   Free Software Foundation, Inc.\n    Contributed by Holger Teutsch (holger@hotbso.rhein-main.de)\n \n This file is part of GNU CC.\n@@ -402,21 +402,21 @@ clipper_builtin_saveregs ()\n   /* Store int regs  */\n \n   mem = gen_rtx_MEM (SImode, r0_addr);\n-  MEM_ALIAS_SET (mem) = set;\n+  set_mem_alias_set (mem, set);\n   emit_move_insn (mem, gen_rtx_REG (SImode, 0));\n \n   mem = gen_rtx_MEM (SImode, r1_addr);\n-  MEM_ALIAS_SET (mem) = set;\n+  set_mem_alias_set (mem, set);\n   emit_move_insn (mem, gen_rtx_REG (SImode, 1));\n \n   /* Store float regs  */\n \n   mem = gen_rtx_MEM (DFmode, f0_addr);\n-  MEM_ALIAS_SET (mem) = set;\n+  set_mem_alias_set (mem, set);\n   emit_move_insn (mem, gen_rtx_REG (DFmode, 16));\n \n   mem = gen_rtx_MEM (DFmode, f1_addr);\n-  MEM_ALIAS_SET (mem) = set;\n+  set_mem_alias_set (mem, set);\n   emit_move_insn (mem, gen_rtx_REG (DFmode, 17));\n \n   if (current_function_check_memory_usage)"}, {"sha": "81cfcd72a200799fe28f686ab098b8e918f6e8d4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -3421,7 +3421,7 @@ legitimize_pic_address (orig, reg)\n       new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n       new = gen_rtx_MEM (Pmode, new);\n       RTX_UNCHANGING_P (new) = 1;\n-      MEM_ALIAS_SET (new) = ix86_GOT_alias_set ();\n+      set_mem_alias_set (new, ix86_GOT_alias_set ());\n \n       if (reg == 0)\n \treg = gen_reg_rtx (Pmode);"}, {"sha": "12b1548d3d80ace31ea0a5f12e19cade0d8a3cd8", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -2581,9 +2581,8 @@ i960_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n       /* ??? Note that we unnecessarily store one extra register for stdarg\n \t fns.  We could optimize this, but it's kept as for now.  */\n       regblock = gen_rtx_MEM (BLKmode,\n-\t\t\t  plus_constant (arg_pointer_rtx,\n-\t\t\t\t\t first_reg * 4));\n-      MEM_ALIAS_SET (regblock) = get_varargs_alias_set ();\n+\t\t\t      plus_constant (arg_pointer_rtx, first_reg * 4));\n+      set_mem_alias_set (regblock, get_varargs_alias_set ());\n       move_block_from_reg (first_reg, regblock,\n \t\t\t   NPARM_REGS - first_reg,\n \t\t\t   (NPARM_REGS - first_reg) * UNITS_PER_WORD);"}, {"sha": "9d1d5061b34380bb9dde4d2c6a52516a5a248766", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -1702,7 +1702,7 @@ spill_restore_mem (reg, cfa_off)\n \t   && frame_pointer_needed)\n     {\n       mem = gen_rtx_MEM (GET_MODE (reg), hard_frame_pointer_rtx);\n-      MEM_ALIAS_SET (mem) = get_varargs_alias_set ();\n+      set_mem_alias_set (mem, get_varargs_alias_set ());\n       return mem;\n     }\n   else\n@@ -1751,7 +1751,7 @@ spill_restore_mem (reg, cfa_off)\n   /* ??? Not all of the spills are for varargs, but some of them are.\n      The rest of the spills belong in an alias set of their own.  But\n      it doesn't actually hurt to include them here.  */\n-  MEM_ALIAS_SET (mem) = get_varargs_alias_set ();\n+  set_mem_alias_set (mem, get_varargs_alias_set ());\n \n   spill_fill_data.prev_addr[iter] = &XEXP (mem, 0);\n   spill_fill_data.prev_off[iter] = cfa_off;"}, {"sha": "a37ed65324717726a37c16d99ab709b9686fca67", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -1400,7 +1400,7 @@ m32r_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n       regblock = gen_rtx_MEM (BLKmode,\n \t\t\t      plus_constant (arg_pointer_rtx,\n \t\t\t\t\t     FIRST_PARM_OFFSET (0)));\n-      MEM_ALIAS_SET (regblock) = get_varargs_alias_set ();\n+      set_mem_alias_set (regblock, get_varargs_alias_set ());\n       move_block_from_reg (first_reg_offset, regblock,\n \t\t\t   size, size * UNITS_PER_WORD);\n "}, {"sha": "9ac034919c4dcfe012aed20841aa97aa4f89b35c", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -2612,15 +2612,13 @@ m88k_builtin_saveregs ()\n   variable_args_p = 1;\n \n   fixed = 0;\n-  if (CONSTANT_P (current_function_arg_offset_rtx))\n-    {\n-      fixed = (XINT (current_function_arg_offset_rtx, 0)\n-\t       + argadj) / UNITS_PER_WORD;\n-    }\n+  if (GET_CODE (current_function_arg_offset_rtx) == CONST_INT)\n+    fixed = ((INTVAL (current_function_arg_offset_rtx) + argadj)\n+\t     / UNITS_PER_WORD);\n \n   /* Allocate the register space, and store it as the __va_reg member.  */\n   addr = assign_stack_local (BLKmode, 8 * UNITS_PER_WORD, -1);\n-  MEM_ALIAS_SET (addr) = get_varargs_alias_set ();\n+  set_mem_alias_set (addr, get_varargs_alias_set ());\n   RTX_UNCHANGING_P (addr) = 1;\n   RTX_UNCHANGING_P (XEXP (addr, 0)) = 1;\n "}, {"sha": "dd2e3e39cd20770c0b443333f3a3d29cabfef305", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -4515,7 +4515,7 @@ mips_va_arg (valist, type)\n       \t  if (indirect)\n \t    {\n \t      r = gen_rtx_MEM (Pmode, addr_rtx);\n-\t      MEM_ALIAS_SET (r) = get_varargs_alias_set ();\n+\t      set_mem_alias_set (r, get_varargs_alias_set ());\n \t      emit_move_insn (addr_rtx, r);\n \t    }\n       \t  else\n@@ -4656,7 +4656,7 @@ mips_va_arg (valist, type)\n           if (indirect)\n    \t    {\n        \t      r = gen_rtx_MEM (Pmode, addr_rtx);\n-\t      MEM_ALIAS_SET (r) = get_varargs_alias_set ();\n+\t      set_mem_alias_set (r, get_varargs_alias_set ());\n \t      emit_move_insn (addr_rtx, r);\n \t    }\n       \t  else"}, {"sha": "7ea66d8a9b373ef3d21ab5adbae5928ae852a943", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -869,12 +869,12 @@ mn10300_builtin_saveregs ()\n     offset = current_function_arg_offset_rtx;\n \n   mem = gen_rtx_MEM (SImode, current_function_internal_arg_pointer);\n-  MEM_ALIAS_SET (mem) = set;\n+  set_mem_alias_set (mem, set);\n   emit_move_insn (mem, gen_rtx_REG (SImode, 0));\n \n   mem = gen_rtx_MEM (SImode,\n \t\t     plus_constant (current_function_internal_arg_pointer, 4));\n-  MEM_ALIAS_SET (mem) = set;\n+  set_mem_alias_set (mem, set);\n   emit_move_insn (mem, gen_rtx_REG (SImode, 1));\n \n   return copy_to_reg (expand_binop (Pmode, add_optab,"}, {"sha": "c1fa4fe8aa5ad5222e834e210e363216ca2976ce", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -4799,7 +4799,7 @@ hppa_builtin_saveregs ()\n   dest = gen_rtx_MEM (BLKmode,\n \t\t      plus_constant (current_function_internal_arg_pointer,\n \t\t\t\t     -16));\n-  MEM_ALIAS_SET (dest) = get_varargs_alias_set ();\n+  set_mem_alias_set (dest, get_varargs_alias_set ());\n   move_block_from_reg (23, dest, 4, 4 * UNITS_PER_WORD);\n \n   /* move_block_from_reg will emit code to store the argument registers"}, {"sha": "73aa3d505f0926b403048daaadb430a3da63bfb4", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -1861,9 +1861,10 @@ rs6000_emit_move (dest, source, mode)\n \t\t\tget_pool_constant (XEXP (operands[1], 0)),\n \t\t\tget_pool_mode (XEXP (operands[1], 0))))\n \t    {\n-\t      operands[1] = gen_rtx_MEM (mode,\n-\t\t\t\t\t create_TOC_reference (XEXP (operands[1], 0)));\n-\t      MEM_ALIAS_SET (operands[1]) = get_TOC_alias_set ();\t\n+\t      operands[1]\n+\t\t= gen_rtx_MEM (mode,\n+\t\t\t       create_TOC_reference (XEXP (operands[1], 0)));\n+\t      set_mem_alias_set (operands[1], get_TOC_alias_set ());\n \t      RTX_UNCHANGING_P (operands[1]) = 1;\n \t    }\n \t}\n@@ -2355,7 +2356,7 @@ setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n       mem = gen_rtx_MEM (BLKmode,\n \t\t         plus_constant (save_area,\n \t\t\t\t\tfirst_reg_offset * reg_size)),\n-      MEM_ALIAS_SET (mem) = set;\n+      set_mem_alias_set (mem, set);\n \n       move_block_from_reg\n \t(GP_ARG_MIN_REG + first_reg_offset, mem,\n@@ -2387,7 +2388,7 @@ setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n       while (fregno <= FP_ARG_V4_MAX_REG)\n \t{\n \t  mem = gen_rtx_MEM (DFmode, plus_constant (save_area, off));\n-          MEM_ALIAS_SET (mem) = set;\n+          set_mem_alias_set (mem, set);\n \t  emit_move_insn (mem, gen_rtx_REG (DFmode, fregno));\n \t  fregno++;\n \t  off += 8;\n@@ -2692,7 +2693,7 @@ rs6000_va_arg (valist, type)\n   if (indirect_p)\n     {\n       r = gen_rtx_MEM (Pmode, addr_rtx);\n-      MEM_ALIAS_SET (r) = get_varargs_alias_set ();\n+      set_mem_alias_set (r, get_varargs_alias_set ());\n       emit_move_insn (addr_rtx, r);\n     }\n \n@@ -5673,7 +5674,7 @@ rs6000_emit_eh_toc_restore (stacksize)\n   rtx loop_exit = gen_label_rtx ();\n   \n   mem = gen_rtx_MEM (Pmode, hard_frame_pointer_rtx);\n-  MEM_ALIAS_SET (mem) = rs6000_sr_alias_set;\n+  set_mem_alias_set (mem, rs6000_sr_alias_set);\n   emit_move_insn (bottom_of_stack, mem);\n \n   top_of_stack = expand_binop (Pmode, add_optab, \n@@ -5707,7 +5708,7 @@ rs6000_emit_eh_toc_restore (stacksize)\n \t\t\t   loop_exit);\n \n   mem = gen_rtx_MEM (Pmode, bottom_of_stack);\n-  MEM_ALIAS_SET (mem) = rs6000_sr_alias_set;\n+  set_mem_alias_set (mem, rs6000_sr_alias_set);\n   emit_move_insn (bottom_of_stack, mem);\n   \n   mem = gen_rtx_MEM (Pmode, \n@@ -5723,15 +5724,15 @@ rs6000_emit_eh_toc_restore (stacksize)\n }\n #endif /* TARGET_AIX */\n \f\n-/* This ties together stack memory \n-   (MEM with an alias set of rs6000_sr_alias_set)\n-   and the change to the stack pointer.  */\n+/* This ties together stack memory (MEM with an alias set of\n+   rs6000_sr_alias_set) and the change to the stack pointer.  */\n+\n static void\n rs6000_emit_stack_tie ()\n {\n-  rtx mem;\n-  mem = gen_rtx_MEM (BLKmode, gen_rtx_REG (Pmode, STACK_POINTER_REGNUM));\n-  MEM_ALIAS_SET (mem) = rs6000_sr_alias_set;\n+  rtx mem = gen_rtx_MEM (BLKmode, gen_rtx_REG (Pmode, STACK_POINTER_REGNUM));\n+\n+  set_mem_alias_set (mem, rs6000_sr_alias_set);\n   emit_insn (gen_stack_tie (mem));\n }\n \n@@ -5972,7 +5973,7 @@ rs6000_emit_prologue ()\n \t\t\t\t\t  + sp_offset \n \t\t\t\t\t  + 8*i));\n \t    mem = gen_rtx_MEM (DFmode, addr);\n-\t    MEM_ALIAS_SET (mem) = rs6000_sr_alias_set;\n+\t    set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n \t    insn = emit_move_insn (mem, reg);\n \t    rs6000_frame_related (insn, frame_ptr_rtx, info->total_size, \n@@ -6004,7 +6005,7 @@ rs6000_emit_prologue ()\n \t\t\t       GEN_INT (info->fp_save_offset \n \t\t\t\t\t+ sp_offset + 8*i));\n \t  mem = gen_rtx_MEM (DFmode, addr);\n-\t  MEM_ALIAS_SET (mem) = rs6000_sr_alias_set;\n+\t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n \t  RTVEC_ELT (p, i + 2) = gen_rtx_SET (VOIDmode, mem, reg);\n \t}\n@@ -6030,7 +6031,7 @@ rs6000_emit_prologue ()\n \t\t\t\t\t+ sp_offset \n \t\t\t\t\t+ reg_size * i));\n \t  mem = gen_rtx_MEM (reg_mode, addr);\n-\t  MEM_ALIAS_SET (mem) = rs6000_sr_alias_set;\n+\t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n \t  RTVEC_ELT (p, i) = gen_rtx_SET (VOIDmode, mem, reg);\n \t}\n@@ -6057,7 +6058,7 @@ rs6000_emit_prologue ()\n \t\t\t\t\t  + sp_offset \n \t\t\t\t\t  + reg_size * i));\n \t    mem = gen_rtx_MEM (reg_mode, addr);\n-\t    MEM_ALIAS_SET (mem) = rs6000_sr_alias_set;\n+\t    set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n \t    insn = emit_move_insn (mem, reg);\n \t    rs6000_frame_related (insn, frame_ptr_rtx, info->total_size, \n@@ -6084,7 +6085,7 @@ rs6000_emit_prologue ()\n \t\t\t\tinfo->ehrd_offset + sp_offset\n \t\t\t\t+ reg_size * (int) i);\n \t  mem = gen_rtx_MEM (reg_mode, addr);\n-\t  MEM_ALIAS_SET (mem) = rs6000_sr_alias_set;\n+\t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n \t  insn = emit_move_insn (mem, reg);\n \t  rs6000_frame_related (insn, frame_ptr_rtx, info->total_size, \n@@ -6113,7 +6114,8 @@ rs6000_emit_prologue ()\n       rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n \t\t\t       GEN_INT (info->cr_save_offset + sp_offset));\n       rtx mem = gen_rtx_MEM (SImode, addr);\n-      MEM_ALIAS_SET (mem) = rs6000_sr_alias_set;\n+\n+      set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n       /* If r12 was used to hold the original sp, copy cr into r0 now\n \t that it's free.  */\n@@ -6304,7 +6306,8 @@ rs6000_emit_epilogue (sibcall)\n       rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n \t\t\t       GEN_INT (info->lr_save_offset + sp_offset));\n       rtx mem = gen_rtx_MEM (Pmode, addr);\n-      MEM_ALIAS_SET (mem) = rs6000_sr_alias_set;\n+\n+      set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n       emit_move_insn (gen_rtx_REG (Pmode, 0), mem);\n     }\n@@ -6315,7 +6318,8 @@ rs6000_emit_epilogue (sibcall)\n       rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n \t\t\t       GEN_INT (info->cr_save_offset + sp_offset));\n       rtx mem = gen_rtx_MEM (SImode, addr);\n-      MEM_ALIAS_SET (mem) = rs6000_sr_alias_set;\n+\n+      set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n       emit_move_insn (gen_rtx_REG (SImode, 12), mem);\n     }\n@@ -6342,7 +6346,7 @@ rs6000_emit_epilogue (sibcall)\n \t\t\t\tinfo->ehrd_offset + sp_offset\n \t\t\t\t+ reg_size * (int) i);\n \t  mem = gen_rtx_MEM (reg_mode, addr);\n-\t  MEM_ALIAS_SET (mem) = rs6000_sr_alias_set;\n+\t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n \t  emit_move_insn (gen_rtx_REG (reg_mode, regno), mem);\n \t}\n@@ -6361,7 +6365,8 @@ rs6000_emit_epilogue (sibcall)\n \t\t\t\t\t    + sp_offset \n \t\t\t\t\t    + reg_size * i));\n \t  rtx mem = gen_rtx_MEM (reg_mode, addr);\n-\t  MEM_ALIAS_SET (mem) = rs6000_sr_alias_set;\n+\n+\t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n \t  RTVEC_ELT (p, i) = \n \t    gen_rtx_SET (VOIDmode,\n@@ -6385,7 +6390,8 @@ rs6000_emit_epilogue (sibcall)\n \t\t\t\t\t    + sp_offset \n \t\t\t\t\t    + reg_size * i));\n \t  rtx mem = gen_rtx_MEM (reg_mode, addr);\n-\t  MEM_ALIAS_SET (mem) = rs6000_sr_alias_set;\n+\n+\t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n \t  emit_move_insn (gen_rtx_REG (reg_mode, \n \t\t\t\t       info->first_gp_reg_save + i),\n@@ -6404,7 +6410,7 @@ rs6000_emit_epilogue (sibcall)\n \t\t\t\t\t+ sp_offset \n \t\t\t\t\t+ 8*i));\n \t  mem = gen_rtx_MEM (DFmode, addr);\n-\t  MEM_ALIAS_SET (mem) = rs6000_sr_alias_set;\n+\t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n \t  emit_move_insn (gen_rtx_REG (DFmode, \n \t\t\t\t       info->first_fp_reg_save + i),\n@@ -6526,7 +6532,7 @@ rs6000_emit_epilogue (sibcall)\n \t      addr = gen_rtx_PLUS (Pmode, sp_reg_rtx,\n \t\t\t\t   GEN_INT (info->fp_save_offset + 8*i));\n \t      mem = gen_rtx_MEM (DFmode, addr);\n-\t      MEM_ALIAS_SET (mem) = rs6000_sr_alias_set;\n+\t      set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n \t      RTVEC_ELT (p, i+3) = \n \t\tgen_rtx_SET (VOIDmode,"}, {"sha": "18e6379fd60a07d7d0558c405822402ba8a5cb6e", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -4224,7 +4224,8 @@ sh_builtin_saveregs ()\n   /* Number of SFmode float regs to save.  */\n   int n_floatregs = MAX (0, NPARM_REGS (SFmode) - first_floatreg);\n   rtx regbuf, fpregs;\n-  int bufsize, regno, alias_set;\n+  int bufsize, regno;\n+  HOST_WIDE_INT alias_set;\n \n   /* Allocate block of memory for the regs. */\n   /* ??? If n_intregs + n_floatregs == 0, should we allocate at least 1 byte?\n@@ -4233,7 +4234,7 @@ sh_builtin_saveregs ()\n \n   regbuf = assign_stack_local (BLKmode, bufsize, 0);\n   alias_set = get_varargs_alias_set ();\n-  MEM_ALIAS_SET (regbuf) = alias_set;\n+  set_mem_alias_set (regbuf, alias_set);\n \n   /* Save int args.\n      This is optimized to only save the regs that are necessary.  Explicitly\n@@ -4264,7 +4265,7 @@ sh_builtin_saveregs ()\n \t  emit_insn (gen_addsi3 (fpregs, fpregs,\n \t\t\t\t GEN_INT (-2 * UNITS_PER_WORD)));\n \t  mem = gen_rtx_MEM (DFmode, fpregs);\n-\t  MEM_ALIAS_SET (mem) = alias_set;\n+\t  set_mem_alias_set (mem, alias_set);\n \t  emit_move_insn (mem, \n \t\t\t  gen_rtx (REG, DFmode, BASE_ARG_REG (DFmode) + regno));\n \t}\n@@ -4273,7 +4274,7 @@ sh_builtin_saveregs ()\n \t{\n \t  emit_insn (gen_addsi3 (fpregs, fpregs, GEN_INT (- UNITS_PER_WORD)));\n \t  mem = gen_rtx_MEM (SFmode, fpregs);\n-\t  MEM_ALIAS_SET (mem) = alias_set;\n+\t  set_mem_alias_set (mem, alias_set);\n \t  emit_move_insn (mem,\n \t\t\t  gen_rtx (REG, SFmode, BASE_ARG_REG (SFmode) + regno\n \t\t\t\t\t\t- (TARGET_LITTLE_ENDIAN != 0)));\n@@ -4283,9 +4284,10 @@ sh_builtin_saveregs ()\n     for (regno = NPARM_REGS (SFmode) - 1; regno >= first_floatreg; regno--)\n       {\n         rtx mem;\n+\n \temit_insn (gen_addsi3 (fpregs, fpregs, GEN_INT (- UNITS_PER_WORD)));\n \tmem = gen_rtx_MEM (SFmode, fpregs);\n-\tMEM_ALIAS_SET (mem) = alias_set;\n+\tset_mem_alias_set (mem, alias_set);\n \temit_move_insn (mem,\n \t\t\tgen_rtx_REG (SFmode, BASE_ARG_REG (SFmode) + regno));\n       }"}, {"sha": "e7413ee30467c0a5eed9bc816312c86ea3571e96", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -4929,10 +4929,10 @@ sparc_va_arg (valist, type)\n \n       addr_rtx = force_reg (Pmode, addr_rtx);\n       addr_rtx = gen_rtx_MEM (BLKmode, addr_rtx);\n-      MEM_ALIAS_SET (addr_rtx) = get_varargs_alias_set ();\n+      set_mem_alias_set (addr_rtx, get_varargs_alias_set ());\n       tmp = shallow_copy_rtx (tmp);\n       PUT_MODE (tmp, BLKmode);\n-      MEM_ALIAS_SET (tmp) = 0;\n+      set_mem_alias_set (tmp, 0);\n       \n       dest_addr = emit_block_move (tmp, addr_rtx, GEN_INT (rsize), \n \t\t\t\t   BITS_PER_WORD);\n@@ -4946,7 +4946,7 @@ sparc_va_arg (valist, type)\n     {\n       addr_rtx = force_reg (Pmode, addr_rtx);\n       addr_rtx = gen_rtx_MEM (Pmode, addr_rtx);\n-      MEM_ALIAS_SET (addr_rtx) = get_varargs_alias_set ();\n+      set_mem_alias_set (addr_rtx, get_varargs_alias_set ());\n     }\n \n   return addr_rtx;"}, {"sha": "e742eeb4f6ce1e44af6286b803a1b3920bb50416", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -2791,7 +2791,7 @@ v850_va_arg (valist, type)\n     {\n       addr_rtx = force_reg (Pmode, addr_rtx);\n       addr_rtx = gen_rtx_MEM (Pmode, addr_rtx);\n-      MEM_ALIAS_SET (addr_rtx) = get_varargs_alias_set ();\n+      set_mem_alias_set (addr_rtx, get_varargs_alias_set ());\n     }\n \n   return addr_rtx;"}, {"sha": "afb51d9e65556c5d51870d9a96ca8db0128d567f", "filename": "gcc/explow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -661,7 +661,7 @@ set_mem_attributes (ref, t, objectp)\n      here, because, in C and C++, the fact that a location is accessed\n      through a const expression does not mean that the value there can\n      never change.  */\n-  MEM_ALIAS_SET (ref) = get_alias_set (t);\n+  set_mem_alias_set (ref, get_alias_set (t));\n   MEM_VOLATILE_P (ref) = TYPE_VOLATILE (type);\n   MEM_IN_STRUCT_P (ref) = AGGREGATE_TYPE_P (type);\n "}, {"sha": "0021910515942a017098f23032bff693aa404fd2", "filename": "gcc/expr.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -3181,7 +3181,7 @@ emit_single_push_insn (mode, x, type)\n          outgoing arguments and we cannot allow reordering of reads\n          from function arguments with stores to outgoing arguments\n          of sibling calls.  */\n-      MEM_ALIAS_SET (dest) = 0;\n+      set_mem_alias_set (dest, 0);\n     }\n   emit_move_insn (dest, x);\n #else\n@@ -3399,7 +3399,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t\t outgoing arguments and we cannot allow reordering of reads\n \t\t from function arguments with stores to outgoing arguments\n \t\t of sibling calls.  */\n-\t      MEM_ALIAS_SET (target) = 0;\n+\t      set_mem_alias_set (target, 0);\n \t    }\n \n \t  /* TEMP is the address of the block.  Copy the data there.  */\n@@ -3582,7 +3582,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t\t outgoing arguments and we cannot allow reordering of reads\n \t\t from function arguments with stores to outgoing arguments\n \t\t of sibling calls.  */\n-\t      MEM_ALIAS_SET (dest) = 0;\n+\t      set_mem_alias_set (dest, 0);\n \t    }\n \n \t  emit_move_insn (dest, x);\n@@ -3906,7 +3906,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n     {\n       to_rtx = expand_expr (to, NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_WO);\n       if (GET_CODE (to_rtx) == MEM)\n-\tMEM_ALIAS_SET (to_rtx) = get_alias_set (to);\n+\tset_mem_alias_set (to_rtx, get_alias_set (to));\n     }\n \n   /* Don't move directly into a return register.  */\n@@ -4478,7 +4478,7 @@ store_constructor_field (target, bitsize, bitpos,\n       if (bitpos != 0)\n \talign = MIN (align, (unsigned int) bitpos & - bitpos);\n       if (GET_CODE (target) == MEM)\n-\tMEM_ALIAS_SET (target) = alias_set;\n+\tset_mem_alias_set (target, alias_set);\n \n       store_constructor (exp, target, align, cleared, bitsize / BITS_PER_UNIT);\n     }\n@@ -5334,10 +5334,9 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n \t at the same location.  We will give the structures alias set\n \t zero; here we must be careful not to give non-zero alias sets\n \t to their fields.  */\n-      if (!rtx_varies_p (addr, /*for_alias=*/0))\n-\tMEM_ALIAS_SET (to_rtx) = alias_set;\n-      else\n-\tMEM_ALIAS_SET (to_rtx) = 0;\n+      set_mem_alias_set (to_rtx,\n+\t\t\t rtx_varies_p (addr, /*for_alias=*/0)\n+\t\t\t ? 0 : alias_set);\n \n       return store_expr (exp, to_rtx, value_mode != VOIDmode);\n     }\n@@ -9141,7 +9140,7 @@ expand_expr_unaligned (exp, palign)\n \t  /* Get a reference to just this component.  */\n \t  op0 = adjust_address (op0, mode1, bitpos / BITS_PER_UNIT);\n \n-\tMEM_ALIAS_SET (op0) = get_alias_set (exp);\n+\tset_mem_alias_set (op0, get_alias_set (exp));\n \n \t/* Adjust the alignment in case the bit position is not\n \t   a multiple of the alignment of the inner object.  */"}, {"sha": "c91da12a80b19cfa82faac7fc0ac28c74967a4c3", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -808,10 +808,7 @@ assign_stack_temp_for_type (mode, size, keep, type)\n   /* If we know the alias set for the memory that will be used, use\n      it.  If there's no TYPE, then we don't know anything about the\n      alias set for the memory.  */\n-  if (type)\n-    MEM_ALIAS_SET (p->slot) = get_alias_set (type);\n-  else\n-    MEM_ALIAS_SET (p->slot) = 0;\n+  set_mem_alias_set (p->slot, type ? get_alias_set (type) : 0);\n \n   /* If a type is specified, set the relevant flags. */\n   if (type != 0)\n@@ -1499,7 +1496,7 @@ put_reg_into_stack (function, reg, type, promoted_mode, decl_mode, volatile_p,\n     {\n       MEM_SET_IN_STRUCT_P (reg,\n \t\t\t   AGGREGATE_TYPE_P (type) || MEM_IN_STRUCT_P (new));\n-      MEM_ALIAS_SET (reg) = get_alias_set (type);\n+      set_mem_alias_set (reg, get_alias_set (type));\n     }\n   if (used_p)\n     schedule_fixup_var_refs (function, reg, type, promoted_mode, ht);\n@@ -2876,15 +2873,15 @@ gen_mem_addressof (reg, decl)\n       PUT_MODE (reg, decl_mode);\n       MEM_VOLATILE_P (reg) = TREE_SIDE_EFFECTS (decl);\n       MEM_SET_IN_STRUCT_P (reg, AGGREGATE_TYPE_P (type));\n-      MEM_ALIAS_SET (reg) = get_alias_set (decl);\n+      set_mem_alias_set (reg, get_alias_set (decl));\n \n       if (TREE_USED (decl) || DECL_INITIAL (decl) != 0)\n \tfixup_var_refs (reg, GET_MODE (reg), TREE_UNSIGNED (type), 0);\n     }\n   else\n     {\n       /* We have no alias information about this newly created MEM.  */\n-      MEM_ALIAS_SET (reg) = 0;\n+      set_mem_alias_set (reg, 0);\n \n       fixup_var_refs (reg, GET_MODE (reg), 0, 0);\n     }"}, {"sha": "6cb2fabcd13fe278341d736bed747896e0a2fe87", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -1098,7 +1098,7 @@ noce_try_cmove_arith (if_info)\n       if (MEM_SCALAR_P (if_info->a) && MEM_SCALAR_P (if_info->b))\n \tMEM_SCALAR_P (tmp) = 1;\n       if (MEM_ALIAS_SET (if_info->a) == MEM_ALIAS_SET (if_info->b))\n-\tMEM_ALIAS_SET (tmp) = MEM_ALIAS_SET (if_info->a);\n+\tset_mem_alias_set (tmp, MEM_ALIAS_SET (if_info->a));\n \n       noce_emit_move_insn (if_info->x, tmp);\n     }"}, {"sha": "c494990e1f57a6ba12fa42850a5ab24215331467", "filename": "gcc/reload1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -1157,7 +1157,7 @@ reload (first, global)\n \t      MEM_SCALAR_P (reg) = is_scalar;\n \t      /* We have no alias information about this newly created\n \t\t MEM.  */\n-\t      MEM_ALIAS_SET (reg) = 0;\n+\t      set_mem_alias_set (reg, 0);\n \t    }\n \t  else if (reg_equiv_mem[i])\n \t    XEXP (reg_equiv_mem[i], 0) = addr;\n@@ -1988,7 +1988,7 @@ alter_reg (i, from_reg)\n \t  RTX_UNCHANGING_P (x) = RTX_UNCHANGING_P (regno_reg_rtx[i]);\n \n \t  /* Nothing can alias this slot except this pseudo.  */\n-\t  MEM_ALIAS_SET (x) = new_alias_set ();\n+\t  set_mem_alias_set (x, new_alias_set ());\n \t}\n \n       /* Reuse a stack slot if possible.  */\n@@ -2022,9 +2022,9 @@ alter_reg (i, from_reg)\n \n \t  /* All pseudos mapped to this slot can alias each other.  */\n \t  if (spill_stack_slot[from_reg])\n-\t    MEM_ALIAS_SET (x) = MEM_ALIAS_SET (spill_stack_slot[from_reg]);\n+\t    set_mem_alias_set (x, MEM_ALIAS_SET (spill_stack_slot[from_reg]));\n \t  else\n-\t    MEM_ALIAS_SET (x) = new_alias_set ();\n+\t    set_mem_alias_set (x, new_alias_set ());\n \n \t  if (BYTES_BIG_ENDIAN)\n \t    {"}, {"sha": "121e0f000a5e77468b0e9746ccedd9a6ce2d0f49", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4828e00559dfebd57b51b78696ce777a8da279/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ba4828e00559dfebd57b51b78696ce777a8da279", "patch": "@@ -2004,6 +2004,7 @@ extern void init_alias_once\t\tPARAMS ((void));\n extern void init_alias_analysis\t\tPARAMS ((void));\n extern void end_alias_analysis\t\tPARAMS ((void));\n extern rtx addr_side_effect_eval\tPARAMS ((rtx, int, int));\n+extern void set_mem_alias_set\t\tPARAMS ((rtx, HOST_WIDE_INT));\n \n /* In sibcall.c */\n typedef enum {"}]}