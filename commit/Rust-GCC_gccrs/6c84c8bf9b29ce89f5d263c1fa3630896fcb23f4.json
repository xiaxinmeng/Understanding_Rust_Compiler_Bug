{"sha": "6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM4NGM4YmY5YjI5Y2U4OWY1ZDI2M2MxZmEzNjMwODk2ZmNiMjNmNA==", "commit": {"author": {"name": "Maciej W. Rozycki", "email": "macro@codesourcery.com", "date": "2019-12-22T19:54:09Z"}, "committer": {"name": "Frederik Harwath", "email": "frederik@gcc.gnu.org", "date": "2019-12-22T19:54:09Z"}, "message": "Add OpenACC 2.6 `acc_get_property' support\n\nAdd generic support for the OpenACC 2.6 `acc_get_property' and\n`acc_get_property_string' routines, as well as full handlers for the\nhost and the NVPTX offload targets and minimal handlers for the HSA,\nIntel MIC, and AMD GCN offload targets.\n\nIncluded are C/C++ and Fortran tests that, in particular, print\nthe property values for acc_property_vendor, acc_property_memory,\nacc_property_free_memory, acc_property_name, and acc_property_driver.\nThe output looks as follows:\n\nVendor: GNU\nName: GOMP\nTotal memory: 0\nFree memory: 0\nDriver: 1.0\n\nwith the host driver (where the memory related properties are not\nsupported for the host device and yield 0, conforming to the standard)\nand output like:\n\nVendor: Nvidia\nTotal memory: 12651462656\nFree memory: 12202737664\nName: TITAN V\nDriver: CUDA Driver 9.1\n\nwith the NVPTX driver.\n\n2019-12-22  Maciej W. Rozycki  <macro@codesourcery.com>\n\t    Frederik Harwath  <frederik@codesourcery.com>\n\t    Thomas Schwinge  <tschwinge@codesourcery.com>\n\n\tinclude/\n\t* gomp-constants.h (gomp_device_property): New enum.\n\n\tlibgomp/\n\t* libgomp.h (gomp_device_descr): Add `get_property_func' member.\n\t* libgomp-plugin.h (gomp_device_property_value): New union.\n\t(gomp_device_property_value): New prototype.\n\t* openacc.h (acc_device_t): Add `acc_device_current' enumeration\n\tconstant.\n\t(acc_device_property_t): New enum.\n\t(acc_get_property, acc_get_property_string): New prototypes.\n\t* oacc-init.c (acc_get_device_type): Also assert that result\n\tis not `acc_device_current'.\n\t(get_property_any, acc_get_property, acc_get_property_string):\n\tNew functions.\n\t* openacc.f90 (openacc_kinds): Add `acc_device_current' and\n\t`acc_property_memory', `acc_property_free_memory',\n\t`acc_property_name', `acc_property_vendor' and\n\t`acc_property_driver' constants.  Add `acc_device_property' data\n\ttype.\n\t(openacc_internal): Add `acc_get_property' and\n\t`acc_get_property_string' interfaces.  Add `acc_get_property_h',\n\t`acc_get_property_string_h', `acc_get_property_l' and\n\t`acc_get_property_string_l'.\n\t* oacc-host.c (host_get_property): New function.\n\t(host_dispatch): Wire it.\n\t* target.c (gomp_load_plugin_for_device): Handle `get_property'.\n\t* libgomp.map (OACC_2.6): Add `acc_get_property', `acc_get_property_h_',\n\t`acc_get_property_string' and `acc_get_property_string_h_' symbols.\n\t* libgomp.texi (OpenACC Runtime Library Routines): Add\n\t`acc_get_property'.\n\t(acc_get_property): New node.\n\t* plugin/plugin-gcn.c (GOMP_OFFLOAD_get_property): New\n\tfunction (stub).\n\t* plugin/plugin-hsa.c (GOMP_OFFLOAD_get_property): New function.\n\t* plugin/plugin-nvptx.c (CUDA_CALLS): Add `cuDeviceGetName',\n\t`cuDeviceTotalMem', `cuDriverGetVersion' and `cuMemGetInfo'\n\tcalls.\n\t(GOMP_OFFLOAD_get_property): New function.\n\t(struct ptx_device): Add new field \"name\".\n\t(cuda_driver_version_s): Add new static variable ...\n\t(nvptx_init): ... and init from here.\n\n\t* testsuite/libgomp.oacc-c-c++-common/acc_get_property.c: New test.\n\t* testsuite/libgomp.oacc-c-c++-common/acc_get_property-2.c: New test.\n\t* testsuite/libgomp.oacc-c-c++-common/acc_get_property-3.c: New test.\n\t* testsuite/libgomp.oacc-c-c++-common/acc_get_property-aux.c: New file\n\twith test helper functions.\n\n\t* testsuite/libgomp.oacc-fortran/acc_get_property.f90: New test.\n\n\tliboffloadmic/\n\t* plugin/libgomp-plugin-intelmic.cpp (GOMP_OFFLOAD_get_property):\n\tNew function.\n\nReviewed-by: Thomas Schwinge <thomas@codesourcery.com>\n\n\nCo-Authored-By: Frederik Harwath <frederik@codesourcery.com>\nCo-Authored-By: Thomas Schwinge <tschwinge@codesourcery.com>\n\nFrom-SVN: r279710", "tree": {"sha": "0e15cf12a4c3396702ed004deabe3c86ea7ac18e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e15cf12a4c3396702ed004deabe3c86ea7ac18e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/comments", "author": null, "committer": null, "parents": [{"sha": "edadb8adc3563bf782e4781bf3be6425af566368", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edadb8adc3563bf782e4781bf3be6425af566368", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edadb8adc3563bf782e4781bf3be6425af566368"}], "stats": {"total": 847, "additions": 841, "deletions": 6}, "files": [{"sha": "60d9f207cbd3b0e642759ac893e89fc626a20b21", "filename": "include/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -1,3 +1,9 @@\n+2019-12-22  Maciej W. Rozycki  <macro@codesourcery.com>\n+\t    Frederik Harwath  <frederik@codesourcery.com>\n+\t    Thomas Schwinge  <tschwinge@codesourcery.com>\n+\n+\t* gomp-constants.h (gomp_device_property): New enum.\n+\n 2019-12-19  Julian Brown  <julian@codesourcery.com>\n \n \t* gomp-constants.h (gomp_map_kind): Add GOMP_MAP_ATTACH_DETACH."}, {"sha": "d14e8b0394a92cb1992a6b74d9bbea3865131468", "filename": "include/gomp-constants.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/include%2Fgomp-constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/include%2Fgomp-constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgomp-constants.h?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -195,6 +195,21 @@ enum gomp_map_kind\n #define GOMP_DEVICE_ICV\t\t\t-1\n #define GOMP_DEVICE_HOST_FALLBACK\t-2\n \n+/* Device property codes.  Keep in sync with\n+   libgomp/{openacc.h,openacc.f90}:acc_device_property_t */\n+/* Start from 1 to catch uninitialized use.  */\n+enum gomp_device_property\n+  {\n+   GOMP_DEVICE_PROPERTY_MEMORY =\t1,\n+   GOMP_DEVICE_PROPERTY_FREE_MEMORY = \t2,\n+   GOMP_DEVICE_PROPERTY_NAME =\t\t0x10001,\n+   GOMP_DEVICE_PROPERTY_VENDOR =\t0x10002,\n+   GOMP_DEVICE_PROPERTY_DRIVER =\t0x10003\n+  };\n+\n+/* Internal property mask to tell numeric and string values apart.  */\n+#define GOMP_DEVICE_PROPERTY_STRING_MASK\t0x10000\n+\n /* GOMP_task/GOMP_taskloop* flags argument.  */\n #define GOMP_TASK_FLAG_UNTIED\t\t(1 << 0)\n #define GOMP_TASK_FLAG_FINAL\t\t(1 << 1)"}, {"sha": "deaff15c4e4f4d416253b8abc8c0f61d7b8fa6fd", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -1,3 +1,54 @@\n+2019-12-22  Maciej W. Rozycki  <macro@codesourcery.com>\n+\t    Frederik Harwath  <frederik@codesourcery.com>\n+\t    Thomas Schwinge  <tschwinge@codesourcery.com>\n+\n+\t* libgomp.h (gomp_device_descr): Add `get_property_func' member.\n+\t* libgomp-plugin.h (gomp_device_property_value): New union.\n+\t(gomp_device_property_value): New prototype.\n+\t* openacc.h (acc_device_t): Add `acc_device_current' enumeration\n+\tconstant.\n+\t(acc_device_property_t): New enum.\n+\t(acc_get_property, acc_get_property_string): New prototypes.\n+\t* oacc-init.c (acc_get_device_type): Also assert that result\n+\tis not `acc_device_current'.\n+\t(get_property_any, acc_get_property, acc_get_property_string):\n+\tNew functions.\n+\t* openacc.f90 (openacc_kinds): Add `acc_device_current' and\n+\t`acc_property_memory', `acc_property_free_memory',\n+\t`acc_property_name', `acc_property_vendor' and\n+\t`acc_property_driver' constants.  Add `acc_device_property' data\n+\ttype.\n+\t(openacc_internal): Add `acc_get_property' and\n+\t`acc_get_property_string' interfaces.  Add `acc_get_property_h',\n+\t`acc_get_property_string_h', `acc_get_property_l' and\n+\t`acc_get_property_string_l'.\n+\t* oacc-host.c (host_get_property): New function.\n+\t(host_dispatch): Wire it.\n+\t* target.c (gomp_load_plugin_for_device): Handle `get_property'.\n+\t* libgomp.map (OACC_2.6): Add `acc_get_property', `acc_get_property_h_',\n+\t`acc_get_property_string' and `acc_get_property_string_h_' symbols.\n+\t* libgomp.texi (OpenACC Runtime Library Routines): Add\n+\t`acc_get_property'.\n+\t(acc_get_property): New node.\n+\t* plugin/plugin-gcn.c (GOMP_OFFLOAD_get_property): New\n+\tfunction (stub).\n+\t* plugin/plugin-hsa.c (GOMP_OFFLOAD_get_property): New function.\n+\t* plugin/plugin-nvptx.c (CUDA_CALLS): Add `cuDeviceGetName',\n+\t`cuDeviceTotalMem', `cuDriverGetVersion' and `cuMemGetInfo'\n+\tcalls.\n+\t(GOMP_OFFLOAD_get_property): New function.\n+\t(struct ptx_device): Add new field \"name\".\n+\t(cuda_driver_version_s): Add new static variable ...\n+\t(nvptx_init): ... and init from here.\n+\n+\t* testsuite/libgomp.oacc-c-c++-common/acc_get_property.c: New test.\n+\t* testsuite/libgomp.oacc-c-c++-common/acc_get_property-2.c: New test.\n+\t* testsuite/libgomp.oacc-c-c++-common/acc_get_property-3.c: New test.\n+\t* testsuite/libgomp.oacc-c-c++-common/acc_get_property-aux.c: New file\n+\twith test helper functions.\n+\n+\t* testsuite/libgomp.oacc-fortran/acc_get_property.f90: New test.\n+\n 2019-12-22  Maciej W. Rozycki  <macro@wdc.com>\n \n \t* testsuite/libgomp-test-support.exp.in (GCC_UNDER_TEST): New"}, {"sha": "d3c6dc36276586646365489aa009b357c66ada40", "filename": "libgomp/libgomp-plugin.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Flibgomp-plugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Flibgomp-plugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp-plugin.h?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -54,6 +54,13 @@ enum offload_target_type\n   OFFLOAD_TARGET_TYPE_GCN = 8\n };\n \n+/* Container type for passing device properties.  */\n+union gomp_device_property_value\n+{\n+  const char *ptr;\n+  size_t val;\n+};\n+\n /* Opaque type to represent plugin-dependent implementation of an\n    OpenACC asynchronous queue.  */\n struct goacc_asyncqueue;\n@@ -94,6 +101,7 @@ extern const char *GOMP_OFFLOAD_get_name (void);\n extern unsigned int GOMP_OFFLOAD_get_caps (void);\n extern int GOMP_OFFLOAD_get_type (void);\n extern int GOMP_OFFLOAD_get_num_devices (void);\n+extern union gomp_device_property_value GOMP_OFFLOAD_get_property (int, int);\n extern bool GOMP_OFFLOAD_init_device (int);\n extern bool GOMP_OFFLOAD_fini_device (int);\n extern unsigned GOMP_OFFLOAD_version (void);"}, {"sha": "24c76698c4e170caf740448004dfcd76ca996cff", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -1113,6 +1113,7 @@ struct gomp_device_descr\n   __typeof (GOMP_OFFLOAD_get_caps) *get_caps_func;\n   __typeof (GOMP_OFFLOAD_get_type) *get_type_func;\n   __typeof (GOMP_OFFLOAD_get_num_devices) *get_num_devices_func;\n+  __typeof (GOMP_OFFLOAD_get_property) *get_property_func;\n   __typeof (GOMP_OFFLOAD_init_device) *init_device_func;\n   __typeof (GOMP_OFFLOAD_fini_device) *fini_device_func;\n   __typeof (GOMP_OFFLOAD_version) *version_func;"}, {"sha": "c7268bfc8e76cd66041107090a651b6b940a069a", "filename": "libgomp/libgomp.map", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -492,6 +492,10 @@ OACC_2.6 {\n \tacc_detach_async;\n \tacc_detach_finalize;\n \tacc_detach_finalize_async;\n+\tacc_get_property;\n+\tacc_get_property_h_;\n+\tacc_get_property_string;\n+\tacc_get_property_string_h_;\n } OACC_2.5.1;\n \n GOACC_2.0 {"}, {"sha": "5f8f1beedaffe3028284f2c40c4b8f700cea743e", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -1849,6 +1849,7 @@ acceleration device.\n * acc_get_device_type::         Get type of device accelerator to be used.\n * acc_set_device_num::          Set device number to use.\n * acc_get_device_num::          Get device number to be used.\n+* acc_get_property::            Get device property.\n * acc_async_test::              Tests for completion of a specific asynchronous\n                                 operation.\n * acc_async_test_all::          Tests for completion of all asychronous\n@@ -2038,6 +2039,44 @@ region.\n \n \n \n+@node acc_get_property\n+@section @code{acc_get_property} -- Get device property.\n+@cindex acc_get_property\n+@cindex acc_get_property_string\n+@table @asis\n+@item @emph{Description}\n+These routines return the value of the specified @var{property} for the\n+device being queried according to @var{devicenum} and @var{devicetype}.\n+Integer-valued and string-valued properties are returned by\n+@code{acc_get_property} and @code{acc_get_property_string} respectively.\n+The Fortran @code{acc_get_property_string} subroutine returns the string\n+retrieved in its fourth argument while the remaining entry points are\n+functions, which pass the return value as their result.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{size_t acc_get_property(int devicenum, acc_device_t devicetype, acc_device_property_t property);}\n+@item @emph{Prototype}: @tab @code{const char *acc_get_property_string(int devicenum, acc_device_t devicetype, acc_device_property_t property);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{function acc_get_property(devicenum, devicetype, property)}\n+@item @emph{Interface}: @tab @code{subroutine acc_get_property_string(devicenum, devicetype, property, string)}\n+@item                   @tab @code{integer devicenum}\n+@item                   @tab @code{integer(kind=acc_device_kind) devicetype}\n+@item                   @tab @code{integer(kind=acc_device_property) property}\n+@item                   @tab @code{integer(kind=acc_device_property) acc_get_property}\n+@item                   @tab @code{character(*) string}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{https://www.openacc.org, OpenACC specification v2.6}, section\n+3.2.6.\n+@end table\n+\n+\n+\n @node acc_async_test\n @section @code{acc_async_test} -- Test for completion of a specific asynchronous operation.\n @table @asis"}, {"sha": "ec9e3247a1afc8911e6d6d6358bfaa6378fe6959", "filename": "libgomp/oacc-host.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Foacc-host.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Foacc-host.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-host.c?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -59,6 +59,27 @@ host_get_num_devices (void)\n   return 1;\n }\n \n+static union gomp_device_property_value\n+host_get_property (int n, int prop)\n+{\n+  union gomp_device_property_value nullval = { .val = 0 };\n+\n+  if (n >= host_get_num_devices ())\n+    return nullval;\n+\n+  switch (prop)\n+    {\n+    case GOMP_DEVICE_PROPERTY_NAME:\n+      return (union gomp_device_property_value) { .ptr = \"GOMP\" };\n+    case GOMP_DEVICE_PROPERTY_VENDOR:\n+      return (union gomp_device_property_value) { .ptr = \"GNU\" };\n+    case GOMP_DEVICE_PROPERTY_DRIVER:\n+      return (union gomp_device_property_value) { .ptr = VERSION };\n+    default:\n+      return nullval;\n+    }\n+}\n+\n static bool\n host_init_device (int n __attribute__ ((unused)))\n {\n@@ -248,6 +269,7 @@ static struct gomp_device_descr host_dispatch =\n     .get_caps_func = host_get_caps,\n     .get_type_func = host_get_type,\n     .get_num_devices_func = host_get_num_devices,\n+    .get_property_func = host_get_property,\n     .init_device_func = host_init_device,\n     .fini_device_func = host_fini_device,\n     .version_func = host_version,"}, {"sha": "487a2cca61f8779f4b93fb6361c175e5c6afae5c", "filename": "libgomp/oacc-init.c", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Foacc-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Foacc-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-init.c?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -670,7 +670,8 @@ acc_get_device_type (void)\n     }\n \n   assert (res != acc_device_default\n-\t  && res != acc_device_not_host);\n+\t  && res != acc_device_not_host\n+\t  && res != acc_device_current);\n \n   return res;\n }\n@@ -759,6 +760,66 @@ acc_set_device_num (int ord, acc_device_t d)\n \n ialias (acc_set_device_num)\n \n+static union gomp_device_property_value\n+get_property_any (int ord, acc_device_t d, acc_device_property_t prop)\n+{\n+  goacc_lazy_initialize ();\n+  struct goacc_thread *thr = goacc_thread ();\n+\n+  if (d == acc_device_current && thr && thr->dev)\n+    return thr->dev->get_property_func (thr->dev->target_id, prop);\n+\n+  gomp_mutex_lock (&acc_device_lock);\n+\n+  struct gomp_device_descr *dev = resolve_device (d, true);\n+\n+  int num_devices = dev->get_num_devices_func ();\n+\n+  if (num_devices <= 0 || ord >= num_devices)\n+    acc_dev_num_out_of_range (d, ord, num_devices);\n+\n+  dev += ord;\n+\n+  gomp_mutex_lock (&dev->lock);\n+  if (dev->state == GOMP_DEVICE_UNINITIALIZED)\n+    gomp_init_device (dev);\n+  gomp_mutex_unlock (&dev->lock);\n+\n+  gomp_mutex_unlock (&acc_device_lock);\n+\n+  assert (dev);\n+\n+  return dev->get_property_func (dev->target_id, prop);\n+}\n+\n+size_t\n+acc_get_property (int ord, acc_device_t d, acc_device_property_t prop)\n+{\n+  if (!known_device_type_p (d))\n+    unknown_device_type_error(d);\n+\n+  if (prop & GOMP_DEVICE_PROPERTY_STRING_MASK)\n+    return 0;\n+  else\n+    return get_property_any (ord, d, prop).val;\n+}\n+\n+ialias (acc_get_property)\n+\n+const char *\n+acc_get_property_string (int ord, acc_device_t d, acc_device_property_t prop)\n+{\n+  if (!known_device_type_p (d))\n+    unknown_device_type_error(d);\n+\n+  if (prop & GOMP_DEVICE_PROPERTY_STRING_MASK)\n+    return get_property_any (ord, d, prop).ptr;\n+  else\n+    return NULL;\n+}\n+\n+ialias (acc_get_property_string)\n+\n /* For -O and higher, the compiler always attempts to expand acc_on_device, but\n    if the user disables the builtin, or calls it via a pointer, we'll need this\n    version."}, {"sha": "e5b4b40c3cce2daaee1b0b73d5e68dc4202202fa", "filename": "libgomp/openacc.f90", "status": "modified", "additions": 125, "deletions": 4, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Fopenacc.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Fopenacc.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fopenacc.f90?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -31,16 +31,18 @@\n \n module openacc_kinds\n   use iso_fortran_env, only: int32\n+  use iso_c_binding, only: c_size_t\n   implicit none\n \n   public\n-  private :: int32\n+  private :: int32, c_size_t\n \n   ! When adding items, also update 'public' setting in 'module openacc' below.\n \n   integer, parameter :: acc_device_kind = int32\n \n   ! Keep in sync with include/gomp-constants.h.\n+  integer (acc_device_kind), parameter :: acc_device_current = -3\n   integer (acc_device_kind), parameter :: acc_device_none = 0\n   integer (acc_device_kind), parameter :: acc_device_default = 1\n   integer (acc_device_kind), parameter :: acc_device_host = 2\n@@ -49,6 +51,15 @@ module openacc_kinds\n   integer (acc_device_kind), parameter :: acc_device_nvidia = 5\n   integer (acc_device_kind), parameter :: acc_device_gcn = 8\n \n+  integer, parameter :: acc_device_property = c_size_t\n+\n+  ! Keep in sync with include/gomp-constants.h.\n+  integer (acc_device_property), parameter :: acc_property_memory = 1\n+  integer (acc_device_property), parameter :: acc_property_free_memory = 2\n+  integer (acc_device_property), parameter :: acc_property_name = int(Z'10001')\n+  integer (acc_device_property), parameter :: acc_property_vendor = int(Z'10002')\n+  integer (acc_device_property), parameter :: acc_property_driver = int(Z'10003')\n+\n   integer, parameter :: acc_handle_kind = int32\n \n   ! Keep in sync with include/gomp-constants.h.\n@@ -89,6 +100,24 @@ function acc_get_device_num_h (d)\n       integer (acc_device_kind) d\n     end function\n \n+    function acc_get_property_h (n, d, p)\n+      import\n+      implicit none (type, external)\n+      integer (acc_device_property) :: acc_get_property_h\n+      integer, value :: n\n+      integer (acc_device_kind), value :: d\n+      integer (acc_device_property), value :: p\n+    end function\n+\n+    subroutine acc_get_property_string_h (n, d, p, s)\n+      import\n+      implicit none (type, external)\n+      integer, value :: n\n+      integer (acc_device_kind), value :: d\n+      integer (acc_device_property), value :: p\n+      character (*) :: s\n+    end subroutine\n+\n     function acc_async_test_h (a)\n       logical acc_async_test_h\n       integer a\n@@ -508,6 +537,26 @@ function acc_get_device_num_l (d) &\n       integer (c_int), value :: d\n     end function\n \n+    function acc_get_property_l (n, d, p) &\n+        bind (C, name = \"acc_get_property\")\n+      use iso_c_binding, only: c_int, c_size_t\n+      implicit none (type, external)\n+      integer (c_size_t) :: acc_get_property_l\n+      integer (c_int), value :: n\n+      integer (c_int), value :: d\n+      integer (c_int), value :: p\n+    end function\n+\n+    function acc_get_property_string_l (n, d, p) &\n+        bind (C, name = \"acc_get_property_string\")\n+      use iso_c_binding, only: c_int, c_ptr\n+      implicit none (type, external)\n+      type (c_ptr) :: acc_get_property_string_l\n+      integer (c_int), value :: n\n+      integer (c_int), value :: d\n+      integer (c_int), value :: p\n+    end function\n+\n     function acc_async_test_l (a) &\n         bind (C, name = \"acc_async_test\")\n       use iso_c_binding, only: c_int\n@@ -716,16 +765,23 @@ module openacc\n   private\n \n   ! From openacc_kinds\n-  public :: acc_device_kind, acc_handle_kind\n+  public :: acc_device_kind\n   public :: acc_device_none, acc_device_default, acc_device_host\n   public :: acc_device_not_host, acc_device_nvidia, acc_device_gcn\n+\n+  public :: acc_device_property\n+  public :: acc_property_memory, acc_property_free_memory\n+  public :: acc_property_name, acc_property_vendor, acc_property_driver\n+\n+  public :: acc_handle_kind\n   public :: acc_async_noval, acc_async_sync\n \n   public :: openacc_version\n \n   public :: acc_get_num_devices, acc_set_device_type, acc_get_device_type\n-  public :: acc_set_device_num, acc_get_device_num, acc_async_test\n-  public :: acc_async_test_all\n+  public :: acc_set_device_num, acc_get_device_num\n+  public :: acc_get_property, acc_get_property_string\n+  public :: acc_async_test, acc_async_test_all\n   public :: acc_wait, acc_async_wait, acc_wait_async\n   public :: acc_wait_all, acc_async_wait_all, acc_wait_all_async\n   public :: acc_init, acc_shutdown, acc_on_device\n@@ -758,6 +814,14 @@ module openacc\n     procedure :: acc_get_device_num_h\n   end interface\n \n+  interface acc_get_property\n+    procedure :: acc_get_property_h\n+  end interface\n+\n+  interface acc_get_property_string\n+    procedure :: acc_get_property_string_h\n+  end interface\n+\n   interface acc_async_test\n     procedure :: acc_async_test_h\n   end interface\n@@ -976,6 +1040,63 @@ function acc_get_device_num_h (d)\n   acc_get_device_num_h = acc_get_device_num_l (d)\n end function\n \n+function acc_get_property_h (n, d, p)\n+  use iso_c_binding, only: c_int, c_size_t\n+  use openacc_internal, only: acc_get_property_l\n+  use openacc_kinds\n+  implicit none (type, external)\n+  integer (acc_device_property) :: acc_get_property_h\n+  integer, value :: n\n+  integer (acc_device_kind), value :: d\n+  integer (acc_device_property), value :: p\n+\n+  integer (c_int) :: pint\n+\n+  pint = int (p, c_int)\n+  acc_get_property_h = acc_get_property_l (n, d, pint)\n+end function\n+\n+subroutine acc_get_property_string_h (n, d, p, s)\n+  use iso_c_binding, only: c_char, c_int, c_ptr, c_f_pointer, c_associated\n+  use openacc_internal, only: acc_get_property_string_l\n+  use openacc_kinds\n+  implicit none (type, external)\n+  integer, value :: n\n+  integer (acc_device_kind), value :: d\n+  integer (acc_device_property), value :: p\n+  character (*) :: s\n+\n+  integer (c_int) :: pint\n+  type (c_ptr) :: cptr\n+  integer :: clen\n+  character (kind=c_char, len=1), pointer, contiguous :: sptr (:)\n+  integer :: slen\n+  integer :: i\n+\n+  interface\n+     function strlen (s) bind (C, name = \"strlen\")\n+       use iso_c_binding, only: c_ptr, c_size_t\n+       type (c_ptr), intent(in), value :: s\n+       integer (c_size_t) :: strlen\n+     end function strlen\n+  end interface\n+\n+  pint = int (p, c_int)\n+  cptr = acc_get_property_string_l (n, d, pint)\n+  s = \"\"\n+  if (.not. c_associated (cptr)) then\n+     return\n+  end if\n+\n+  clen = int (strlen (cptr))\n+  call c_f_pointer (cptr, sptr, [clen])\n+\n+  slen = min (clen, len (s))\n+  do i = 1, slen\n+    s (i:i) = sptr (i)\n+  end do\n+end subroutine\n+\n function acc_async_test_h (a)\n   use openacc_internal, only: acc_async_test_l\n   logical acc_async_test_h"}, {"sha": "9b143064b7d4e04ba1998e3011285ed7d45ebb80", "filename": "libgomp/openacc.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Fopenacc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Fopenacc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fopenacc.h?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -49,6 +49,7 @@ extern \"C\" {\n /* Types */\n typedef enum acc_device_t {\n   /* Keep in sync with include/gomp-constants.h.  */\n+  acc_device_current = -3,\n   acc_device_none = 0,\n   acc_device_default = 1,\n   acc_device_host = 2,\n@@ -62,6 +63,16 @@ typedef enum acc_device_t {\n   _ACC_neg = -1\n } acc_device_t;\n \n+typedef enum acc_device_property_t {\n+  /* Keep in sync with include/gomp-constants.h.  */\n+  /* Start from 1 to catch uninitialized use.  */\n+  acc_property_memory = 1,\n+  acc_property_free_memory = 2,\n+  acc_property_name = 0x10001,\n+  acc_property_vendor = 0x10002,\n+  acc_property_driver = 0x10003\n+} acc_device_property_t;\n+\n typedef enum acc_async_t {\n   /* Keep in sync with include/gomp-constants.h.  */\n   acc_async_noval = -1,\n@@ -73,6 +84,10 @@ void acc_set_device_type (acc_device_t) __GOACC_NOTHROW;\n acc_device_t acc_get_device_type (void) __GOACC_NOTHROW;\n void acc_set_device_num (int, acc_device_t) __GOACC_NOTHROW;\n int acc_get_device_num (acc_device_t) __GOACC_NOTHROW;\n+size_t acc_get_property\n+  (int, acc_device_t, acc_device_property_t) __GOACC_NOTHROW;\n+const char *acc_get_property_string\n+  (int, acc_device_t, acc_device_property_t) __GOACC_NOTHROW;\n int acc_async_test (int) __GOACC_NOTHROW;\n int acc_async_test_all (void) __GOACC_NOTHROW;\n void acc_wait (int) __GOACC_NOTHROW;"}, {"sha": "cd91b39b1d2721ebf131813bf78b0aa0c3094fc3", "filename": "libgomp/plugin/cuda-lib.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Fplugin%2Fcuda-lib.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Fplugin%2Fcuda-lib.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fcuda-lib.def?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -8,6 +8,9 @@ CUDA_ONE_CALL (cuCtxSynchronize)\n CUDA_ONE_CALL (cuDeviceGet)\n CUDA_ONE_CALL (cuDeviceGetAttribute)\n CUDA_ONE_CALL (cuDeviceGetCount)\n+CUDA_ONE_CALL (cuDeviceGetName)\n+CUDA_ONE_CALL (cuDeviceTotalMem)\n+CUDA_ONE_CALL (cuDriverGetVersion)\n CUDA_ONE_CALL (cuEventCreate)\n CUDA_ONE_CALL (cuEventDestroy)\n CUDA_ONE_CALL (cuEventElapsedTime)\n@@ -35,6 +38,7 @@ CUDA_ONE_CALL (cuMemcpyHtoDAsync)\n CUDA_ONE_CALL (cuMemFree)\n CUDA_ONE_CALL (cuMemFreeHost)\n CUDA_ONE_CALL (cuMemGetAddressRange)\n+CUDA_ONE_CALL (cuMemGetInfo)\n CUDA_ONE_CALL (cuMemHostGetDevicePointer)\n CUDA_ONE_CALL (cuModuleGetFunction)\n CUDA_ONE_CALL (cuModuleGetGlobal)"}, {"sha": "32239c71c61b81651ffbabe2be764b3e6d8023fe", "filename": "libgomp/plugin/plugin-gcn.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Fplugin%2Fplugin-gcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Fplugin%2Fplugin-gcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-gcn.c?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -3236,6 +3236,17 @@ GOMP_OFFLOAD_get_num_devices (void)\n   return hsa_context.agent_count;\n }\n \n+union gomp_device_property_value\n+GOMP_OFFLOAD_get_property (int device, int prop)\n+{\n+  /* Stub. Check device and return default value for unsupported properties. */\n+  /* TODO: Implement this function. */\n+  get_agent_info (device);\n+\n+  union gomp_device_property_value nullval = { .val = 0 };\n+  return nullval;\n+}\n+\n /* Initialize device (agent) number N so that it can be used for computation.\n    Return TRUE on success.  */\n "}, {"sha": "259f704b2e955d85cde83347d09b0296e405b3e8", "filename": "libgomp/plugin/plugin-hsa.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Fplugin%2Fplugin-hsa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Fplugin%2Fplugin-hsa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-hsa.c?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -699,6 +699,32 @@ GOMP_OFFLOAD_get_num_devices (void)\n   return hsa_context.agent_count;\n }\n \n+/* Part of the libgomp plugin interface.  Return the value of property\n+   PROP of agent number N.  */\n+\n+union gomp_device_property_value\n+GOMP_OFFLOAD_get_property (int n, int prop)\n+{\n+  union gomp_device_property_value nullval = { .val = 0 };\n+\n+  if (!init_hsa_context ())\n+    return nullval;\n+  if (n >= hsa_context.agent_count)\n+    {\n+      GOMP_PLUGIN_error\n+\t(\"Request for a property of a non-existing HSA device %i\", n);\n+      return nullval;\n+    }\n+\n+  switch (prop)\n+    {\n+    case GOMP_DEVICE_PROPERTY_VENDOR:\n+      return (union gomp_device_property_value) { .ptr = \"HSA\" };\n+    default:\n+      return nullval;\n+    }\n+}\n+\n /* Part of the libgomp plugin interface.  Initialize agent number N so that it\n    can be used for computation.  Return TRUE on success.  */\n "}, {"sha": "80e547541e33622d90e78e1a86684ee8fbd64649", "filename": "libgomp/plugin/plugin-nvptx.c", "status": "modified", "additions": 86, "deletions": 1, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Fplugin%2Fplugin-nvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Fplugin%2Fplugin-nvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-nvptx.c?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -189,6 +189,10 @@ cuda_error (CUresult r)\n   return fallback;\n }\n \n+/* Version of the CUDA Toolkit in the same MAJOR.MINOR format that is used by\n+   Nvidia, such as in the 'deviceQuery' program (Nvidia's CUDA samples). */\n+static char cuda_driver_version_s[30];\n+\n static unsigned int instantiated_devices = 0;\n static pthread_mutex_t ptx_dev_lock = PTHREAD_MUTEX_INITIALIZER;\n \n@@ -284,7 +288,7 @@ struct ptx_device\n   bool map;\n   bool concur;\n   bool mkern;\n-  int  mode;\n+  int mode;\n   int clock_khz;\n   int num_sms;\n   int regs_per_block;\n@@ -294,6 +298,9 @@ struct ptx_device\n   int max_threads_per_multiprocessor;\n   int default_dims[GOMP_DIM_MAX];\n \n+  /* Length as used by the CUDA Runtime API ('struct cudaDeviceProp').  */\n+  char name[256];\n+\n   struct ptx_image_data *images;  /* Images loaded on device.  */\n   pthread_mutex_t image_lock;     /* Lock for above list.  */\n \n@@ -327,9 +334,16 @@ nvptx_init (void)\n \n   CUDA_CALL (cuInit, 0);\n \n+  int cuda_driver_version;\n+  CUDA_CALL_ERET (NULL, cuDriverGetVersion, &cuda_driver_version);\n+  snprintf (cuda_driver_version_s, sizeof cuda_driver_version_s,\n+\t    \"CUDA Driver %u.%u\",\n+\t    cuda_driver_version / 1000, cuda_driver_version % 1000 / 10);\n+\n   CUDA_CALL (cuDeviceGetCount, &ndevs);\n   ptx_devices = GOMP_PLUGIN_malloc_cleared (sizeof (struct ptx_device *)\n \t\t\t\t\t    * ndevs);\n+\n   return true;\n }\n \n@@ -491,6 +505,9 @@ nvptx_open_device (int n)\n   for (int i = 0; i != GOMP_DIM_MAX; i++)\n     ptx_dev->default_dims[i] = 0;\n \n+  CUDA_CALL_ERET (NULL, cuDeviceGetName, ptx_dev->name, sizeof ptx_dev->name,\n+\t\t  dev);\n+\n   ptx_dev->images = NULL;\n   pthread_mutex_init (&ptx_dev->image_lock, NULL);\n \n@@ -1104,6 +1121,74 @@ GOMP_OFFLOAD_get_num_devices (void)\n   return nvptx_get_num_devices ();\n }\n \n+union gomp_device_property_value\n+GOMP_OFFLOAD_get_property (int n, int prop)\n+{\n+  union gomp_device_property_value propval = { .val = 0 };\n+\n+  pthread_mutex_lock (&ptx_dev_lock);\n+\n+  if (n >= nvptx_get_num_devices () || n < 0 || ptx_devices[n] == NULL)\n+    {\n+      pthread_mutex_unlock (&ptx_dev_lock);\n+      return propval;\n+    }\n+\n+  struct ptx_device *ptx_dev = ptx_devices[n];\n+  switch (prop)\n+    {\n+    case GOMP_DEVICE_PROPERTY_MEMORY:\n+      {\n+\tsize_t total_mem;\n+\n+\tCUDA_CALL_ERET (propval, cuDeviceTotalMem, &total_mem, ptx_dev->dev);\n+\tpropval.val = total_mem;\n+      }\n+      break;\n+    case GOMP_DEVICE_PROPERTY_FREE_MEMORY:\n+      {\n+\tsize_t total_mem;\n+\tsize_t free_mem;\n+\tCUdevice ctxdev;\n+\n+\tCUDA_CALL_ERET (propval, cuCtxGetDevice, &ctxdev);\n+\tif (ptx_dev->dev == ctxdev)\n+\t  CUDA_CALL_ERET (propval, cuMemGetInfo, &free_mem, &total_mem);\n+\telse if (ptx_dev->ctx)\n+\t  {\n+\t    CUcontext old_ctx;\n+\n+\t    CUDA_CALL_ERET (propval, cuCtxPushCurrent, ptx_dev->ctx);\n+\t    CUDA_CALL_ERET (propval, cuMemGetInfo, &free_mem, &total_mem);\n+\t    CUDA_CALL_ASSERT (cuCtxPopCurrent, &old_ctx);\n+\t  }\n+\telse\n+\t  {\n+\t    CUcontext new_ctx;\n+\n+\t    CUDA_CALL_ERET (propval, cuCtxCreate, &new_ctx, CU_CTX_SCHED_AUTO,\n+\t\t\t    ptx_dev->dev);\n+\t    CUDA_CALL_ERET (propval, cuMemGetInfo, &free_mem, &total_mem);\n+\t    CUDA_CALL_ASSERT (cuCtxDestroy, new_ctx);\n+\t  }\n+\tpropval.val = free_mem;\n+      }\n+      break;\n+    case GOMP_DEVICE_PROPERTY_NAME:\n+      propval.ptr = ptx_dev->name;\n+      break;\n+    case GOMP_DEVICE_PROPERTY_VENDOR:\n+      propval.ptr = \"Nvidia\";\n+      break;\n+    case GOMP_DEVICE_PROPERTY_DRIVER:\n+      propval.ptr = cuda_driver_version_s;\n+      break;\n+    }\n+\n+  pthread_mutex_unlock (&ptx_dev_lock);\n+  return propval;\n+}\n+\n bool\n GOMP_OFFLOAD_init_device (int n)\n {"}, {"sha": "3562c3790f10703c76b591a0d37e5c3e18fb28dd", "filename": "libgomp/target.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -3001,6 +3001,7 @@ gomp_load_plugin_for_device (struct gomp_device_descr *device,\n   DLSYM (get_caps);\n   DLSYM (get_type);\n   DLSYM (get_num_devices);\n+  DLSYM (get_property);\n   DLSYM (init_device);\n   DLSYM (fini_device);\n   DLSYM (load_image);"}, {"sha": "4dd13c401d36fd8da37538147e6b1d4e54e53100", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/acc_get_property-2.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_get_property-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_get_property-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_get_property-2.c?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -0,0 +1,68 @@\n+/* Test the `acc_get_property' and '`acc_get_property_string' library\n+   functions on Nvidia devices by comparing property values with\n+   those obtained through the CUDA API. */\n+/* { dg-additional-sources acc_get_property-aux.c } */\n+/* { dg-additional-options \"-lcuda -lcudart\" } */\n+/* { dg-do run { target openacc_nvidia_accel_selected } } */\n+\n+#include <openacc.h>\n+#include <cuda.h>\n+#include <cuda_runtime_api.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+void expect_device_properties\n+(acc_device_t dev_type, int dev_num,\n+ int expected_total_mem, int expected_free_mem,\n+ const char* expected_vendor, const char* expected_name,\n+ const char* expected_driver);\n+\n+int main ()\n+{\n+  int dev_count;\n+  cudaGetDeviceCount (&dev_count);\n+\n+  for (int dev_num = 0; dev_num < dev_count; ++dev_num)\n+    {\n+      if (cudaSetDevice (dev_num) != cudaSuccess)\n+\t{\n+\t  fprintf (stderr, \"cudaSetDevice failed.\\n\");\n+\t  abort ();\n+\t}\n+\n+      printf(\"Checking device %d\\n\", dev_num);\n+\n+      const char *vendor = \"Nvidia\";\n+      size_t free_mem;\n+      size_t total_mem;\n+      if (cudaMemGetInfo(&free_mem, &total_mem) != cudaSuccess)\n+\t{\n+\t  fprintf (stderr, \"cudaMemGetInfo failed.\\n\");\n+\t  abort ();\n+\t}\n+\n+      struct cudaDeviceProp p;\n+      if (cudaGetDeviceProperties(&p, dev_num) != cudaSuccess)\n+\t{\n+\t  fprintf (stderr, \"cudaGetDeviceProperties failed.\\n\");\n+\t  abort ();\n+\t}\n+\n+      int driver_version;\n+      if (cudaDriverGetVersion(&driver_version) != cudaSuccess)\n+\t{\n+\t  fprintf (stderr, \"cudaDriverGetVersion failed.\\n\");\n+\t  abort ();\n+\t}\n+      /* The version string should contain the version of the CUDA Toolkit\n+\t in the same MAJOR.MINOR format that is used by Nvidia.\n+\t The format string below is the same that is used by the deviceQuery\n+\t program, which belongs to Nvidia's CUDA samples, to print the version. */\n+      char driver[30];\n+      snprintf (driver, sizeof driver, \"CUDA Driver %u.%u\",\n+\t\tdriver_version / 1000, driver_version % 1000 / 10);\n+\n+      expect_device_properties(acc_device_nvidia, dev_num,\n+\t\t\t       total_mem, free_mem, vendor, p.name, driver);\n+    }\n+}"}, {"sha": "92565000e4998761a032e9e1ed76b1a545259cf5", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/acc_get_property-3.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_get_property-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_get_property-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_get_property-3.c?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -0,0 +1,19 @@\n+/* Test the `acc_get_property' and '`acc_get_property_string' library\n+   functions for the host device. */\n+/* { dg-additional-sources acc_get_property-aux.c } */\n+/* { dg-do run } */\n+\n+#include <openacc.h>\n+#include <stdio.h>\n+\n+void expect_device_properties\n+(acc_device_t dev_type, int dev_num,\n+ int expected_total_mem, int expected_free_mem,\n+ const char* expected_vendor, const char* expected_name,\n+ const char* expected_driver);\n+\n+int main()\n+{\n+  printf (\"Checking acc_device_host device properties\\n\");\n+  expect_device_properties (acc_device_host, 0, 0, 0, \"GNU\", \"GOMP\", \"1.0\");\n+}"}, {"sha": "952bdbf6aeab148c943f387d6662359fe67b4ad0", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/acc_get_property-aux.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_get_property-aux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_get_property-aux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_get_property-aux.c?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -0,0 +1,80 @@\n+/* Auxiliary functions for acc_get_property tests */\n+/* { dg-do compile  { target skip-all-targets } } */\n+\n+#include <openacc.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+void expect_device_properties\n+(acc_device_t dev_type, int dev_num,\n+ int expected_total_mem, int expected_free_mem,\n+ const char* expected_vendor, const char* expected_name,\n+ const char* expected_driver)\n+{\n+  const char *vendor = acc_get_property_string (dev_num, dev_type,\n+\t\t\t\t\t\tacc_property_vendor);\n+  if (strcmp (vendor, expected_vendor))\n+    {\n+      fprintf (stderr, \"Expected acc_property_vendor to equal \\\"%s\\\", \"\n+\t       \"but was \\\"%s\\\".\\n\", expected_vendor, vendor);\n+      abort ();\n+    }\n+\n+  int total_mem = acc_get_property (dev_num, dev_type,\n+\t\t\t\t    acc_property_memory);\n+  if (total_mem != expected_total_mem)\n+    {\n+      fprintf (stderr, \"Expected acc_property_memory to equal %d, \"\n+\t       \"but was %d.\\n\", expected_total_mem, total_mem);\n+      abort ();\n+\n+    }\n+\n+  int free_mem = acc_get_property (dev_num, dev_type,\n+\t\t\t\t   acc_property_free_memory);\n+  if (free_mem != expected_free_mem)\n+    {\n+      fprintf (stderr, \"Expected acc_property_free_memory to equal %d, \"\n+\t       \"but was %d.\\n\", expected_free_mem, free_mem);\n+      abort ();\n+    }\n+\n+  const char *name = acc_get_property_string (dev_num, dev_type,\n+\t\t\t\t\t      acc_property_name);\n+  if (strcmp (name, expected_name))\n+    {\n+      fprintf(stderr, \"Expected acc_property_name to equal \\\"%s\\\", \"\n+\t      \"but was \\\"%s\\\".\\n\", expected_name, name);\n+      abort ();\n+    }\n+\n+  const char *driver = acc_get_property_string (dev_num, dev_type,\n+\t\t\t\t\t\tacc_property_driver);\n+  if (strcmp (expected_driver, driver))\n+    {\n+      fprintf (stderr, \"Expected acc_property_driver to equal %s, \"\n+\t       \"but was %s.\\n\", expected_driver, driver);\n+      abort ();\n+    }\n+\n+  int unknown_property = 16058;\n+  int v = acc_get_property (dev_num, dev_type, (acc_device_property_t)unknown_property);\n+  if (v != 0)\n+    {\n+      fprintf (stderr, \"Expected value of unknown numeric property to equal 0, \"\n+\t       \"but was %d.\\n\", v);\n+      abort ();\n+    }\n+\n+  int unknown_property2 = -16058;\n+  const char *s = acc_get_property_string (dev_num, dev_type, (acc_device_property_t)unknown_property2);\n+  if (s != NULL)\n+    {\n+      fprintf (stderr, \"Expected value of unknown string property to be NULL, \"\n+\t       \"but was %d.\\n\", s);\n+      abort ();\n+    }\n+\n+\n+}"}, {"sha": "289d1bab7f81473b8a573b2515318ed7989fb9d8", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/acc_get_property.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_get_property.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_get_property.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_get_property.c?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -0,0 +1,76 @@\n+/* Test the `acc_get_property' and '`acc_get_property_string' library\n+   functions by printing the results of those functions for all devices\n+   of all device types mentioned in the OpenACC standard.\n+\n+   See also acc_get_property.f90. */\n+/* { dg-do run { target { { ! { openacc_host_selected } } && { ! { openacc_amdgcn_accel_selected } } } } } */\n+/* FIXME: This test does not work with the GCN implementation stub yet.  */\n+\n+#include <openacc.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+/* Print the values of the properties of all devices of the given type\n+   and do basic device independent validation. */\n+\n+void\n+print_device_properties(acc_device_t type)\n+{\n+  const char *s;\n+  size_t v;\n+\n+  int dev_count = acc_get_num_devices(type);\n+\n+  for (int i = 0; i < dev_count; ++i)\n+    {\n+      printf(\"  Device %d:\\n\", i+1);\n+\n+      s = acc_get_property_string (i, type, acc_property_vendor);\n+      printf (\"    Vendor: %s\\n\", s);\n+      if (s == NULL || *s == 0)\n+\t{\n+\t  fprintf (stderr, \"acc_property_vendor should not be null or empty.\\n\");\n+\t  abort ();\n+\t}\n+\n+      v = acc_get_property (i, type,  acc_property_memory);\n+      printf (\"    Total memory: %zd\\n\", v);\n+\n+      v = acc_get_property (i, type, acc_property_free_memory);\n+      printf (\"    Free memory: %zd\\n\", v);\n+\n+      s = acc_get_property_string (i, type, acc_property_name);\n+      printf (\"    Name: %s\\n\", s);\n+      if (s == NULL || *s == 0)\n+\t{\n+\t  fprintf (stderr, \"acc_property_name should not be null or empty.\\n\");\n+\t  abort ();\n+\t}\n+\n+      s = acc_get_property_string (i, type, acc_property_driver);\n+      printf (\"    Driver: %s\\n\", s);\n+      if (s == NULL || *s == 0)\n+\t{\n+\t  fprintf (stderr, \"acc_property_string should not be null or empty.\\n\");\n+\t  abort ();\n+\t}\n+    }\n+}\n+\n+int main ()\n+{\n+  printf(\"acc_device_none:\\n\");\n+  /* For completness; not expected to print anything since there\n+     should be no devices of this type. */\n+  print_device_properties(acc_device_none);\n+\n+  printf(\"acc_device_default:\\n\");\n+  print_device_properties(acc_device_default);\n+\n+  printf(\"acc_device_host:\\n\");\n+  print_device_properties(acc_device_host);\n+\n+  printf(\"acc_device_not_host:\\n\");\n+  print_device_properties(acc_device_not_host);\n+}"}, {"sha": "ce695475ae4e89c9f6102c8bfd1f6f4ee216c53c", "filename": "libgomp/testsuite/libgomp.oacc-fortran/acc_get_property.f90", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Facc_get_property.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Facc_get_property.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Facc_get_property.f90?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -0,0 +1,93 @@\n+! Test the `acc_get_property' and '`acc_get_property_string' library\n+! functions by printing the results of those functions for all devices\n+! of all device types mentioned in the OpenACC standard.\n+!\n+! See also acc_get_property.c\n+! { dg-do run { target { { ! { openacc_host_selected } } && { ! { openacc_amdgcn_accel_selected } } } } }\n+! FIXME: This test does not work with the GCN implementation stub yet.\n+\n+program test\n+  use openacc\n+  implicit none\n+\n+  print *, \"acc_device_none:\"\n+  ! For completeness; not expected to print anything\n+  call print_device_properties (acc_device_none)\n+\n+  print *, \"acc_device_default:\"\n+  call print_device_properties (acc_device_default)\n+\n+  print *, \"acc_device_host:\"\n+  call print_device_properties (acc_device_host)\n+\n+  print *, \"acc_device_not_host:\"\n+  call print_device_properties (acc_device_not_host)\n+end program test\n+\n+! Print the values of the properties of all devices of the given type\n+! and do basic device independent validation.\n+subroutine print_device_properties (device_type)\n+  use openacc\n+  implicit none\n+\n+  integer, intent(in) :: device_type\n+\n+  integer :: device_count\n+  integer :: device\n+  integer(acc_device_property) :: v\n+  character*256 :: s\n+\n+  device_count = acc_get_num_devices(device_type)\n+\n+  do device = 0, device_count - 1\n+     print \"(a, i0)\", \"  Device \", device\n+\n+     call acc_get_property_string (device, device_type, acc_property_vendor, s)\n+     print \"(a, a)\", \"    Vendor: \", trim (s)\n+     if (s == \"\") then\n+        print *, \"acc_property_vendor should not be empty.\"\n+        stop 1\n+     end if\n+\n+     v = acc_get_property (device, device_type, acc_property_memory)\n+     print \"(a, i0)\", \"    Total memory: \", v\n+     if (v < 0) then\n+        print *, \"acc_property_memory should not be negative.\"\n+        stop 1\n+     end if\n+\n+     v = acc_get_property (device, device_type, acc_property_free_memory)\n+     print \"(a, i0)\", \"    Free memory: \", v\n+     if (v < 0) then\n+        print *, \"acc_property_free_memory should not to be negative.\"\n+        stop 1\n+     end if\n+\n+     v = acc_get_property (device, device_type, int(2360, kind = acc_device_property))\n+     if (v /= 0) then\n+        print *, \"Value of unknown numeric property should be 0.\"\n+        stop 1\n+     end if\n+\n+     call acc_get_property_string (device, device_type, acc_property_name, s)\n+     print \"(a, a)\", \"    Name: \", trim (s)\n+     if (s == \"\") then\n+        print *, \"acc_property_name should not be empty.\"\n+        stop 1\n+     end if\n+\n+     call acc_get_property_string (device, device_type, acc_property_driver, s)\n+     print \"(a, a)\", \"    Driver: \", trim (s)\n+     if (s == \"\") then\n+        print *, \"acc_property_driver should not be empty.\"\n+        stop 1\n+     end if\n+\n+     call acc_get_property_string (device, device_type, int(4060, kind = acc_device_property), s)\n+     if (s /= \"\") then\n+        print *, \"Value of unknown string property should be empty string.\"\n+        stop 1\n+     end if\n+\n+  end do\n+end subroutine print_device_properties"}, {"sha": "b5fae878e9d55a7a8fa0d56838d42b29a9b2dbdf", "filename": "liboffloadmic/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/liboffloadmic%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/liboffloadmic%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FChangeLog?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -1,3 +1,11 @@\n+2019-12-22  Maciej W. Rozycki  <macro@codesourcery.com>\n+\t    Frederik Harwath  <frederik@codesourcery.com>\n+\t    Thomas Schwinge  <tschwinge@codesourcery.com>\n+\n+\tliboffloadmic/\n+\t* plugin/libgomp-plugin-intelmic.cpp (GOMP_OFFLOAD_get_property):\n+\tNew function.\n+\n 2019-10-01  Maciej W. Rozycki  <macro@wdc.com>\n \n \t* plugin/configure: Regenerate."}, {"sha": "40d97702b87e108fef1b4e181dee8a30971103d4", "filename": "liboffloadmic/plugin/libgomp-plugin-intelmic.cpp", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp?ref=6c84c8bf9b29ce89f5d263c1fa3630896fcb23f4", "patch": "@@ -174,6 +174,27 @@ GOMP_OFFLOAD_get_num_devices (void)\n   return num_devices;\n }\n \n+extern \"C\" union gomp_device_property_value\n+GOMP_OFFLOAD_get_property (int n, int prop)\n+{\n+  union gomp_device_property_value nullval = { .val = 0 };\n+\n+  if (n >= num_devices)\n+    {\n+      GOMP_PLUGIN_error\n+       (\"Request for a property of a non-existing Intel MIC device %i\", n);\n+      return nullval;\n+    }\n+\n+  switch (prop)\n+    {\n+    case GOMP_DEVICE_PROPERTY_VENDOR:\n+      return (union gomp_device_property_value) { .ptr =  \"Intel\" };\n+    default:\n+      return nullval;\n+    }\n+}\n+\n static bool\n offload (const char *file, uint64_t line, int device, const char *name,\n \t int num_vars, VarDesc *vars, const void **async_data)"}]}