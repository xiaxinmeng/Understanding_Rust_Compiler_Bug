{"sha": "b4da855a9e7a57ea89694006b33f35231b777bbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRkYTg1NWE5ZTdhNTdlYTg5Njk0MDA2YjMzZjM1MjMxYjc3N2JiZg==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@vnet.ibm.com", "date": "2007-10-05T17:55:18Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@gcc.gnu.org", "date": "2007-10-05T17:55:18Z"}, "message": "ra-conflict.c: Include \"sparseset.h\".\n\n\t* ra-conflict.c: Include \"sparseset.h\".\n\t(conflicts): Change to HOST_WIDEST_FAST_INT.\n\t(allocnos_live): Redefine variable as a sparseset.\n\t(SET_ALLOCNO_LIVE, CLEAR_ALLOCNO_LIVE, GET_ALLOCNO_LIVE): Delete macros.\n\t(allocno_row_words): Removed global variable.\n\t(partial_bitnum, max_bitnum, adjacency_pool, adjacency): New variables.\n\t(CONFLICT_BITNUM, CONFLICT_BITNUM_FAST): New defines.\n\t(conflict_p, set_conflict_p, set_conflicts_p): New functions.\n\t(record_one_conflict_between_regnos): Cache allocno values and reuse.\n\tUse set_conflict_p.\n\t(record_one_conflict): Update uses of allocnos_live to use\n\tthe sparseset routines.  Use set_conflicts_p.\n\t(mark_reg_store): Likewise.\n\t(set_reg_in_live): Likewise.\n\t(global_conflicts): Update uses of allocnos_live.\n\tUse the new adjacency list to visit an allocno's neighbors\n\trather than iterating over all possible allocnos.\n\tCall set_conflicts_p to setup conflicts rather than adding\n\tthem manually.\n\t* global.c: Comments updated.  \n\t(CONFLICTP): Delete define.\n\t(regno_compare): New function.  Add prototype.\n\t(global_alloc): Sort the allocno to regno mapping according to\n\twhich basic blocks the regnos are referenced in.  Modify the\n\tconflict bit matrix to a compressed triangular bitmatrix.\n\tOnly allocate the conflict bit matrix and adjacency lists if\n\twe are actually going to allocate something.\n\t(expand_preferences): Use conflict_p.  Update uses of allocnos_live.\n\t(prune_preferences): Use the FOR_EACH_CONFLICT macro to visit an\n\tallocno's neighbors rather than iterating over all possible allocnos.\n\t(mirror_conflicts): Removed function.\n\t(dump_conflicts): Iterate over regnos rather than allocnos so\n\tthat all dump output will be sorted by regno number.\n\tUse the FOR_EACH_CONFLICT macro.\n\t* ra.h: Comments updated.\n\t(conflicts): Update prototype to HOST_WIDEST_FAST_INT.\n\t(partial_bitnum, max_bitnum, adjacency, adjacency_pool): Add prototypes.\n\t(ADJACENCY_VEC_LENGTH, FOR_EACH_CONFLICT): New defines.\n\t(adjacency_list_d, adjacency_iterator_d): New types.\n\t(add_neighbor, adjacency_iter_init, adjacency_iter_done,\n\tadjacency_iter_next, regno_basic_block): New static inline functions.\n\t(EXECUTE_IF_SET_IN_ALLOCNO_SET): Removed define.\n\t(conflict_p): Add function prototype.\n\t* sparseset.h, sparseset.c: New files.\n\t* Makefile.in (OBJS-common): Add sparseset.o.\n\t(sparseset.o): New rule.\n\nFrom-SVN: r129037", "tree": {"sha": "2e03ef60b9463aa8d6f1cf89bba364c677a542ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e03ef60b9463aa8d6f1cf89bba364c677a542ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4da855a9e7a57ea89694006b33f35231b777bbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4da855a9e7a57ea89694006b33f35231b777bbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4da855a9e7a57ea89694006b33f35231b777bbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4da855a9e7a57ea89694006b33f35231b777bbf/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6aa12f4ffb5d7156e36ccceece6b8a8a83ae520f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6aa12f4ffb5d7156e36ccceece6b8a8a83ae520f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6aa12f4ffb5d7156e36ccceece6b8a8a83ae520f"}], "stats": {"total": 1172, "additions": 949, "deletions": 223}, "files": [{"sha": "c8d1beb770b75b938b5577c5beb6a85dfe7e4f19", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4da855a9e7a57ea89694006b33f35231b777bbf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4da855a9e7a57ea89694006b33f35231b777bbf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4da855a9e7a57ea89694006b33f35231b777bbf", "patch": "@@ -1,3 +1,52 @@\n+2007-10-05  Peter Bergner  <bergner@vnet.ibm.com>\n+\n+\t* ra-conflict.c: Include \"sparseset.h\".\n+\t(conflicts): Change to HOST_WIDEST_FAST_INT.\n+\t(allocnos_live): Redefine variable as a sparseset.\n+\t(SET_ALLOCNO_LIVE, CLEAR_ALLOCNO_LIVE, GET_ALLOCNO_LIVE): Delete macros.\n+\t(allocno_row_words): Removed global variable.\n+\t(partial_bitnum, max_bitnum, adjacency_pool, adjacency): New variables.\n+\t(CONFLICT_BITNUM, CONFLICT_BITNUM_FAST): New defines.\n+\t(conflict_p, set_conflict_p, set_conflicts_p): New functions.\n+\t(record_one_conflict_between_regnos): Cache allocno values and reuse.\n+\tUse set_conflict_p.\n+\t(record_one_conflict): Update uses of allocnos_live to use\n+\tthe sparseset routines.  Use set_conflicts_p.\n+\t(mark_reg_store): Likewise.\n+\t(set_reg_in_live): Likewise.\n+\t(global_conflicts): Update uses of allocnos_live.\n+\tUse the new adjacency list to visit an allocno's neighbors\n+\trather than iterating over all possible allocnos.\n+\tCall set_conflicts_p to setup conflicts rather than adding\n+\tthem manually.\n+\t* global.c: Comments updated.  \n+\t(CONFLICTP): Delete define.\n+\t(regno_compare): New function.  Add prototype.\n+\t(global_alloc): Sort the allocno to regno mapping according to\n+\twhich basic blocks the regnos are referenced in.  Modify the\n+\tconflict bit matrix to a compressed triangular bitmatrix.\n+\tOnly allocate the conflict bit matrix and adjacency lists if\n+\twe are actually going to allocate something.\n+\t(expand_preferences): Use conflict_p.  Update uses of allocnos_live.\n+\t(prune_preferences): Use the FOR_EACH_CONFLICT macro to visit an\n+\tallocno's neighbors rather than iterating over all possible allocnos.\n+\t(mirror_conflicts): Removed function.\n+\t(dump_conflicts): Iterate over regnos rather than allocnos so\n+\tthat all dump output will be sorted by regno number.\n+\tUse the FOR_EACH_CONFLICT macro.\n+\t* ra.h: Comments updated.\n+\t(conflicts): Update prototype to HOST_WIDEST_FAST_INT.\n+\t(partial_bitnum, max_bitnum, adjacency, adjacency_pool): Add prototypes.\n+\t(ADJACENCY_VEC_LENGTH, FOR_EACH_CONFLICT): New defines.\n+\t(adjacency_list_d, adjacency_iterator_d): New types.\n+\t(add_neighbor, adjacency_iter_init, adjacency_iter_done,\n+\tadjacency_iter_next, regno_basic_block): New static inline functions.\n+\t(EXECUTE_IF_SET_IN_ALLOCNO_SET): Removed define.\n+\t(conflict_p): Add function prototype.\n+\t* sparseset.h, sparseset.c: New files.\n+\t* Makefile.in (OBJS-common): Add sparseset.o.\n+\t(sparseset.o): New rule.\n+\n 2007-10-05  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/33666"}, {"sha": "c31b25916a78deac1bff2dcd054d13af4e91c90f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4da855a9e7a57ea89694006b33f35231b777bbf/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4da855a9e7a57ea89694006b33f35231b777bbf/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b4da855a9e7a57ea89694006b33f35231b777bbf", "patch": "@@ -1126,6 +1126,7 @@ OBJS-common = \\\n \tsdbout.o \\\n \tsee.o \\\n \tsimplify-rtx.o \\\n+\tsparseset.o \\\n \tsreal.o \\\n \tstack-ptr-mod.o \\\n \tstmt.o \\\n@@ -1765,6 +1766,7 @@ sbitmap.o: sbitmap.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n     $(FLAGS_H) hard-reg-set.h $(BASIC_BLOCK_H) $(OBSTACK_H)\n ebitmap.o: ebitmap.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n \t$(EBITMAP_H)\n+sparseset.o: sparseset.c $(SYSTEM_H) sparseset.h\n \n COLLECT2_OBJS = collect2.o tlink.o intl.o version.o\n COLLECT2_LIBS = @COLLECT2_LIBS@"}, {"sha": "f1964f4fc1daf7b12137f392865fbf3cbcb084c9", "filename": "gcc/global.c", "status": "modified", "additions": 208, "deletions": 125, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4da855a9e7a57ea89694006b33f35231b777bbf/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4da855a9e7a57ea89694006b33f35231b777bbf/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=b4da855a9e7a57ea89694006b33f35231b777bbf", "patch": "@@ -63,39 +63,48 @@ along with GCC; see the file COPYING3.  If not see\n    reg numbers to allocnos and vice versa.\n    max_allocno gets the number of allocnos in use.\n \n-   2. Allocate a max_allocno by max_allocno conflict bit matrix and\n-   clear it.  This is called \"conflict\".\n+   2. Allocate a max_allocno by max_allocno compressed triangular conflict\n+   bit matrix (a triangular bit matrix with portions removed for which we\n+   can guarantee there are no conflicts, example: two local pseudos that\n+   live in different basic blocks) and clear it.  This is called \"conflict\".\n+   Note that for triangular bit matrices, there are two possible equations\n+   for computing the bit number for two allocnos: LOW and HIGH (LOW < HIGH):\n+\n+     1) BITNUM = f(HIGH) + LOW, where\n+       f(HIGH) = (HIGH * (HIGH - 1)) / 2\n+\n+     2) BITNUM = f(LOW) + HIGH, where\n+       f(LOW) = LOW * (max_allocno - LOW) + (LOW * (LOW - 1)) / 2 - LOW - 1\n+\n+   We use the second (and less common) equation as this gives us better\n+   cache locality for local allocnos that are live within the same basic\n+   block.  Also note that f(HIGH) and f(LOW) can be precalculated for all\n+   values of HIGH and LOW, so all that is necessary to compute the bit\n+   number for two allocnos LOW and HIGH is a load followed by an addition.\n \n    Allocate a max_allocno by FIRST_PSEUDO_REGISTER conflict matrix for\n    conflicts between allocnos and explicit hard register use (which\n    includes use of pseudo-registers allocated by local_alloc).  This\n    is the hard_reg_conflicts inside each allocno.\n \n-   3. For each basic block\n-    walk forward through the block, recording which\n-    pseudo-registers and which hardware registers are live.\n-    Build the conflict matrix between the pseudo-registers\n-    and another of pseudo-registers versus hardware registers.\n-    Also record the preferred hardware registers\n-    for each pseudo-register.\n+   3. For each basic block, walk backward through the block, recording\n+   which pseudo-registers and which hardware registers are live.\n+   Build the conflict matrix between the pseudo-registers and another of\n+   pseudo-registers versus hardware registers.\n \n-   4. Sort a table of the allocnos into order of\n-   desirability of the variables.\n+   4. For each basic block, walk backward through the block, recording\n+   the preferred hardware registers for each pseudo-register.\n \n-   5. Allocate the variables in that order; each if possible into\n+   5. Sort a table of the allocnos into order of desirability of the variables.\n+\n+   6. Allocate the variables in that order; each if possible into\n    a preferred register, else into another register.  */\n \f\n /* A vector of the integers from 0 to max_allocno-1,\n    sorted in the order of first-to-be-allocated first.  */\n \n static int *allocno_order;\n \n-/* Two macros to test or store 1 in an element of `conflicts'.  */\n-\n-#define CONFLICTP(I, J) \\\n- (conflicts[(I) * allocno_row_words + (unsigned) (J) / HOST_BITS_PER_WIDE_INT]\t\\\n-  & ((HOST_WIDE_INT) 1 << ((unsigned) (J) % HOST_BITS_PER_WIDE_INT)))\n-\n /* Set of registers that global-alloc isn't supposed to use.  */\n \n static HARD_REG_SET no_global_alloc_regs;\n@@ -206,8 +215,8 @@ compute_regs_asm_clobbered (char *regs_asm_clobbered)\n \n static HARD_REG_SET eliminable_regset;\n \n+static int regno_compare (const void *, const void *);\n static int allocno_compare (const void *, const void *);\n-static void mirror_conflicts (void);\n static void expand_preferences (void);\n static void prune_preferences (void);\n static void set_preferences (void);\n@@ -315,6 +324,8 @@ global_alloc (void)\n {\n   int retval;\n   size_t i;\n+  int max_blk;\n+  int *num_allocnos_per_blk;\n \n   compute_regsets (&eliminable_regset, &no_global_alloc_regs);\n \n@@ -357,9 +368,8 @@ global_alloc (void)\n \n   reg_allocno = XNEWVEC (int, max_regno);\n \n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    reg_allocno[i] = -1;\n-\n+  /* Initially fill the reg_allocno array with regno's...  */\n+  max_blk = 0;\n   max_allocno = 0;\n   for (i = FIRST_PSEUDO_REGISTER; i < (size_t) max_regno; i++)\n     /* Note that reg_live_length[i] < 0 indicates a \"constant\" reg\n@@ -371,28 +381,88 @@ global_alloc (void)\n \t&& (! current_function_has_nonlocal_label\n \t    || REG_N_CALLS_CROSSED (i) == 0))\n       {\n-\treg_allocno[i] = max_allocno++;\n+\tint blk = regno_basic_block (i);\n+\treg_allocno[max_allocno++] = i;\n+\tif (blk > max_blk)\n+\t  max_blk = blk;\n \tgcc_assert (REG_LIVE_LENGTH (i));\n       }\n-    else\n-      reg_allocno[i] = -1;\n \n   allocno = XCNEWVEC (struct allocno, max_allocno);\n+  partial_bitnum = XNEWVEC (int, max_allocno);\n+  num_allocnos_per_blk = XCNEWVEC (int, max_blk + 1);\n \n-  for (i = FIRST_PSEUDO_REGISTER; i < (size_t) max_regno; i++)\n-    if (reg_allocno[i] >= 0)\n-      {\n-\tint num = reg_allocno[i];\n-\tallocno[num].reg = i;\n-\tallocno[num].size = PSEUDO_REGNO_SIZE (i);\n-\tallocno[num].calls_crossed += REG_N_CALLS_CROSSED (i);\n-\tallocno[num].throwing_calls_crossed\n-\t  += REG_N_THROWING_CALLS_CROSSED (i);\n-\tallocno[num].n_refs += REG_N_REFS (i);\n-\tallocno[num].freq += REG_FREQ (i);\n-\tif (allocno[num].live_length < REG_LIVE_LENGTH (i))\n-\t  allocno[num].live_length = REG_LIVE_LENGTH (i);\n-      }\n+  /* ...so we can sort them in the order we want them to receive\n+     their allocnos.  */\n+  qsort (reg_allocno, max_allocno, sizeof (int), regno_compare);\n+\n+  for (i = 0; i < (size_t) max_allocno; i++)\n+    {\n+      int regno = reg_allocno[i];\n+      int blk = regno_basic_block (regno);\n+      num_allocnos_per_blk[blk]++;\n+      allocno[i].reg = regno;\n+      allocno[i].size = PSEUDO_REGNO_SIZE (regno);\n+      allocno[i].calls_crossed += REG_N_CALLS_CROSSED (regno);\n+      allocno[i].throwing_calls_crossed\n+\t+= REG_N_THROWING_CALLS_CROSSED (regno);\n+      allocno[i].n_refs += REG_N_REFS (regno);\n+      allocno[i].freq += REG_FREQ (regno);\n+      if (allocno[i].live_length < REG_LIVE_LENGTH (regno))\n+\tallocno[i].live_length = REG_LIVE_LENGTH (regno);\n+    }\n+\n+  /* The \"global\" block must contain all allocnos.  */\n+  num_allocnos_per_blk[0] = max_allocno;\n+\n+  /* Now reinitialize the reg_allocno array in terms of the\n+     optimized regno to allocno mapping we created above.  */\n+  for (i = 0; i < (size_t) max_regno; i++)\n+    reg_allocno[i] = -1;\n+\n+  max_bitnum = 0;\n+  for (i = 0; i < (size_t) max_allocno; i++)\n+    {\n+      int regno = allocno[i].reg;\n+      int blk = regno_basic_block (regno);\n+      int row_size = --num_allocnos_per_blk[blk];\n+      reg_allocno[regno] = (int) i;\n+      partial_bitnum[i] = (row_size > 0) ? max_bitnum - ((int) i + 1) : -1;\n+      max_bitnum += row_size;\n+    }\n+\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (max_bitnum <= ((max_allocno * (max_allocno - 1)) / 2));\n+#endif\n+\n+  if (dump_file)\n+    {\n+      int num_bits, num_bytes, actual_bytes;\n+\n+      fprintf (dump_file, \"## max_blk:     %d\\n\", max_blk);\n+      fprintf (dump_file, \"## max_regno:   %d\\n\", max_regno);\n+      fprintf (dump_file, \"## max_allocno: %d\\n\", max_allocno);\n+\n+      num_bits = max_bitnum;\n+      num_bytes = CEIL (num_bits, 8);\n+      actual_bytes = num_bytes;\n+      fprintf (dump_file, \"## Compressed triangular bitmatrix size: \");\n+      fprintf (dump_file, \"%d bits, %d bytes\\n\", num_bits, num_bytes);\n+\n+      num_bits = (max_allocno * (max_allocno - 1)) / 2;\n+      num_bytes = CEIL (num_bits, 8);\n+      fprintf (dump_file, \"## Standard triangular bitmatrix size:   \");\n+      fprintf (dump_file, \"%d bits, %d bytes [%.2f%%]\\n\",\n+\t       num_bits, num_bytes,\n+\t       100.0 * ((double) actual_bytes / (double) num_bytes));\n+\n+      num_bits = max_allocno * max_allocno;\n+      num_bytes = CEIL (num_bits, 8);\n+      fprintf (dump_file, \"## Square bitmatrix size:                \");\n+      fprintf (dump_file, \"%d bits, %d bytes [%.2f%%]\\n\",\n+\t       num_bits, num_bytes,\n+\t       100.0 * ((double) actual_bytes / (double) num_bytes));\n+    }\n \n   /* Calculate amount of usage of each hard reg by pseudos\n      allocated by local-alloc.  This is to see if we want to\n@@ -433,18 +503,26 @@ global_alloc (void)\n \t  fprintf (dump_file, \" %d\", (int)i);\n       fprintf (dump_file, \"\\n\");\n     }\n-  allocno_row_words = (max_allocno + HOST_BITS_PER_WIDE_INT - 1) / HOST_BITS_PER_WIDE_INT;\n \n-  /* We used to use alloca here, but the size of what it would try to\n-     allocate would occasionally cause it to exceed the stack limit and\n-     cause unpredictable core dumps.  Some examples were > 2Mb in size.  */\n-  conflicts = XCNEWVEC (HOST_WIDE_INT, max_allocno * allocno_row_words);\n+  conflicts = NULL;\n+  adjacency = NULL;\n+  adjacency_pool = NULL;\n \n   /* If there is work to be done (at least one reg to allocate),\n      perform global conflict analysis and allocate the regs.  */\n \n   if (max_allocno > 0)\n     {\n+      /* We used to use alloca here, but the size of what it would try to\n+\t allocate would occasionally cause it to exceed the stack limit and\n+\t cause unpredictable core dumps.  Some examples were > 2Mb in size.  */\n+      conflicts = XCNEWVEC (HOST_WIDEST_FAST_INT,\n+\t\t\t    CEIL(max_bitnum, HOST_BITS_PER_WIDEST_FAST_INT));\n+\n+      adjacency = XCNEWVEC (adjacency_t *, max_allocno);\n+      adjacency_pool = create_alloc_pool (\"global_alloc adjacency list pool\",\n+\t\t\t\t\t  sizeof (adjacency_t), 1024);\n+\n       /* Scan all the insns and compute the conflicts among allocnos\n \t and between allocnos and hard regs.  */\n \n@@ -460,8 +538,6 @@ global_alloc (void)\n \t global_conflicts.  */\n       df_set_flags (DF_NO_INSN_RESCAN);\n \n-      mirror_conflicts ();\n-\n       /* Eliminate conflicts between pseudos and eliminable registers.  If\n \t the register is not eliminated, the pseudo won't really be able to\n \t live in the eliminable register, so the conflict doesn't matter.\n@@ -536,6 +612,7 @@ global_alloc (void)\n \t  }\n \n       free (allocno_order);\n+      free (conflicts);\n     }\n \n   /* Do the reloads now while the allocno data still exists, so that we can\n@@ -552,12 +629,44 @@ global_alloc (void)\n \n   /* Clean up.  */\n   free (reg_allocno);\n+  free (num_allocnos_per_blk);\n+  free (partial_bitnum);\n   free (allocno);\n-  free (conflicts);\n+  if (adjacency != NULL)\n+    {\n+      free_alloc_pool (adjacency_pool);\n+      free (adjacency);\n+    }\n \n   return retval;\n }\n \n+/* Sort predicate for ordering the regnos.  We want the regno to allocno\n+   mapping to have the property that all \"global\" regnos (ie, regnos that\n+   are referenced in more than one basic block) have smaller allocno values\n+   than \"local\" regnos (ie, regnos referenced in only one basic block).\n+   In addition, for two basic blocks \"i\" and \"j\" with i < j, all regnos\n+   local to basic block i should have smaller allocno values than regnos\n+   local to basic block j.\n+   Returns -1 (1) if *v1p should be allocated before (after) *v2p.  */\n+\n+static int\n+regno_compare (const void *v1p, const void *v2p)\n+{\n+  int regno1 = *(const int *)v1p;\n+  int regno2 = *(const int *)v2p;\n+  int blk1 = REG_BASIC_BLOCK (regno1);\n+  int blk2 = REG_BASIC_BLOCK (regno2);\n+\n+  /* Prefer lower numbered basic blocks.  Note that global and unknown\n+     blocks have negative values, giving them high precedence.  */\n+  if (blk1 - blk2)\n+    return blk1 - blk2;\n+\n+  /* If both regs are referenced from the same block, sort by regno.  */\n+  return regno1 - regno2;\n+}\n+\n /* Sort predicate for ordering the allocnos.\n    Returns -1 (1) if *v1 should be allocated before (after) *v2.  */\n \n@@ -609,8 +718,8 @@ expand_preferences (void)\n \tif (REG_NOTE_KIND (link) == REG_DEAD\n \t    && REG_P (XEXP (link, 0))\n \t    && reg_allocno[REGNO (XEXP (link, 0))] >= 0\n-\t    && ! CONFLICTP (reg_allocno[REGNO (SET_DEST (set))],\n-\t\t\t    reg_allocno[REGNO (XEXP (link, 0))]))\n+\t    && ! conflict_p (reg_allocno[REGNO (SET_DEST (set))],\n+\t\t\t     reg_allocno[REGNO (XEXP (link, 0))]))\n \t  {\n \t    int a1 = reg_allocno[REGNO (SET_DEST (set))];\n \t    int a2 = reg_allocno[REGNO (XEXP (link, 0))];\n@@ -828,14 +937,14 @@ prune_preferences (void)\n \t these registers).  */\n       HARD_REG_SET temp, temp2;\n       int allocno2;\n+      adjacency_iter ai;\n \n       num = allocno_order[i];\n \n       CLEAR_HARD_REG_SET (temp);\n       CLEAR_HARD_REG_SET (temp2);\n \n-      EXECUTE_IF_SET_IN_ALLOCNO_SET (conflicts + num * allocno_row_words,\n-\t\t\t\t     allocno2,\n+      FOR_EACH_CONFLICT (num, allocno2, ai)\n \t{\n \t  if (allocno_to_order[allocno2] > i)\n \t    {\n@@ -846,7 +955,7 @@ prune_preferences (void)\n \t\tIOR_HARD_REG_SET (temp2,\n \t\t\t\t  allocno[allocno2].hard_reg_full_preferences);\n \t    }\n-\t});\n+\t}\n \n       AND_COMPL_HARD_REG_SET (temp, allocno[num].hard_reg_full_preferences);\n       IOR_HARD_REG_SET (temp, temp2);\n@@ -1167,6 +1276,7 @@ find_reg (int num, HARD_REG_SET losers, int alt_regs_p, int accept_call_clobbere\n     {\n       int lim, j;\n       HARD_REG_SET this_reg;\n+      adjacency_iter ai;\n \n       /* Yes.  Record it as the hard register of this pseudo-reg.  */\n       reg_renumber[allocno[num].reg] = best_reg;\n@@ -1184,11 +1294,10 @@ find_reg (int num, HARD_REG_SET losers, int alt_regs_p, int accept_call_clobbere\n \t}\n       /* For each other pseudo-reg conflicting with this one,\n \t mark it as conflicting with the hard regs this one occupies.  */\n-      lim = num;\n-      EXECUTE_IF_SET_IN_ALLOCNO_SET (conflicts + lim * allocno_row_words, j,\n+      FOR_EACH_CONFLICT (num, j, ai)\n \t{\n \t  IOR_HARD_REG_SET (allocno[j].hard_reg_conflicts, this_reg);\n-\t});\n+\t}\n     }\n }\n \f\n@@ -1224,38 +1333,6 @@ retry_global_alloc (int regno, HARD_REG_SET forbidden_regs)\n     }\n }\n \f\n-/* If CONFLICTP (i, j) is true, make sure CONFLICTP (j, i) is also true.  */\n-static void\n-mirror_conflicts (void)\n-{\n-  int i, j;\n-  int rw = allocno_row_words;\n-  int rwb = rw * HOST_BITS_PER_WIDE_INT;\n-  HOST_WIDE_INT *p = conflicts;\n-  HOST_WIDE_INT *q0 = conflicts, *q1, *q2;\n-  unsigned HOST_WIDE_INT mask;\n-\n-  for (i = max_allocno - 1, mask = 1; i >= 0; i--, mask <<= 1)\n-    {\n-      if (! mask)\n-\t{\n-\t  mask = 1;\n-\t  q0++;\n-\t}\n-      for (j = allocno_row_words - 1, q1 = q0; j >= 0; j--, q1 += rwb)\n-\t{\n-\t  unsigned HOST_WIDE_INT word;\n-\n-\t  for (word = (unsigned HOST_WIDE_INT) *p++, q2 = q1; word;\n-\t       word >>= 1, q2 += rw)\n-\t    {\n-\t      if (word & 1)\n-\t\t*q2 |= mask;\n-\t    }\n-\t}\n-    }\n-}\n-\f\n /* Indicate that hard register number FROM was eliminated and replaced with\n    an offset from hard register number TO.  The status of hard registers live\n    at the start of a basic block is updated by replacing a use of FROM with\n@@ -1519,6 +1596,7 @@ static void\n dump_conflicts (FILE *file)\n {\n   int i;\n+  int regno;\n   int has_preferences;\n   int nregs;\n   nregs = 0;\n@@ -1529,46 +1607,51 @@ dump_conflicts (FILE *file)\n       nregs++;\n     }\n   fprintf (file, \";; %d regs to allocate:\", nregs);\n-  for (i = 0; i < max_allocno; i++)\n-    {\n-      int j;\n-      if (reg_renumber[allocno[allocno_order[i]].reg] >= 0)\n-\tcontinue;\n-      fprintf (file, \" %d\", allocno[allocno_order[i]].reg);\n-      for (j = 0; j < max_regno; j++)\n-\tif (reg_allocno[j] == allocno_order[i]\n-\t    && j != allocno[allocno_order[i]].reg)\n-\t  fprintf (file, \"+%d\", j);\n-      if (allocno[allocno_order[i]].size != 1)\n-\tfprintf (file, \" (%d)\", allocno[allocno_order[i]].size);\n-    }\n+  for (regno = 0; regno < max_regno; regno++)\n+    if ((i = reg_allocno[regno]) >= 0)\n+      {\n+\tint j;\n+\tif (reg_renumber[allocno[allocno_order[i]].reg] >= 0)\n+\t  continue;\n+\tfprintf (file, \" %d\", allocno[allocno_order[i]].reg);\n+\tfor (j = 0; j < max_regno; j++)\n+\t  if (reg_allocno[j] == allocno_order[i]\n+\t      && j != allocno[allocno_order[i]].reg)\n+\t    fprintf (file, \"+%d\", j);\n+\tif (allocno[allocno_order[i]].size != 1)\n+\t  fprintf (file, \" (%d)\", allocno[allocno_order[i]].size);\n+      }\n   fprintf (file, \"\\n\");\n \n-  for (i = 0; i < max_allocno; i++)\n-    {\n-      int j;\n-      fprintf (file, \";; %d conflicts:\", allocno[i].reg);\n-      for (j = 0; j < max_allocno; j++)\n-\tif (CONFLICTP (j, i))\n-\t  fprintf (file, \" %d\", allocno[j].reg);\n-      for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n-\tif (TEST_HARD_REG_BIT (allocno[i].hard_reg_conflicts, j) && ! fixed_regs[j])\n-\t  fprintf (file, \" %d\", j);\n-      fprintf (file, \"\\n\");\n-\n-      has_preferences = 0;\n-      for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n-\tif (TEST_HARD_REG_BIT (allocno[i].hard_reg_preferences, j))\n-\t  has_preferences = 1;\n-\n-      if (! has_preferences)\n-\tcontinue;\n-      fprintf (file, \";; %d preferences:\", allocno[i].reg);\n-      for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n-\tif (TEST_HARD_REG_BIT (allocno[i].hard_reg_preferences, j))\n-\t  fprintf (file, \" %d\", j);\n-      fprintf (file, \"\\n\");\n-    }\n+  for (regno = 0; regno < max_regno; regno++)\n+    if ((i = reg_allocno[regno]) >= 0)\n+      {\n+\tint j;\n+\tadjacency_iter ai;\n+\tfprintf (file, \";; %d conflicts:\", allocno[i].reg);\n+\tFOR_EACH_CONFLICT (i, j, ai)\n+\t  {\n+\t    fprintf (file, \" %d\", allocno[j].reg);\n+\t  }\n+\tfor (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n+\t  if (TEST_HARD_REG_BIT (allocno[i].hard_reg_conflicts, j)\n+\t      && !fixed_regs[j])\n+\t    fprintf (file, \" %d\", j);\n+\tfprintf (file, \"\\n\");\n+\n+\thas_preferences = 0;\n+\tfor (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n+\t  if (TEST_HARD_REG_BIT (allocno[i].hard_reg_preferences, j))\n+\t    has_preferences = 1;\n+\n+\tif (!has_preferences)\n+\t  continue;\n+\tfprintf (file, \";; %d preferences:\", allocno[i].reg);\n+\tfor (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n+\t  if (TEST_HARD_REG_BIT (allocno[i].hard_reg_preferences, j))\n+\t    fprintf (file, \" %d\", j);\n+\tfprintf (file, \"\\n\");\n+      }\n   fprintf (file, \"\\n\");\n }\n "}, {"sha": "27a9fcc81eb5b42939198fc57417edc9e8e3d736", "filename": "gcc/ra-conflict.c", "status": "modified", "additions": 174, "deletions": 66, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4da855a9e7a57ea89694006b33f35231b777bbf/gcc%2Fra-conflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4da855a9e7a57ea89694006b33f35231b777bbf/gcc%2Fra-conflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-conflict.c?ref=b4da855a9e7a57ea89694006b33f35231b777bbf", "patch": "@@ -41,63 +41,174 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vecprim.h\"\n #include \"ra.h\"\n #include \"sbitmap.h\"\n-\n-/* Test, set or clear bit number I in allocnos_live,\n-   a bit vector indexed by allocno.  */\n-\n-#define SET_ALLOCNO_LIVE(A, I)\t\t\t\\\n-  ((A)[(unsigned) (I) / HOST_BITS_PER_WIDE_INT]\t\t\t\t\\\n-     |= ((HOST_WIDE_INT) 1 << ((unsigned) (I) % HOST_BITS_PER_WIDE_INT)))\n-\n-#define CLEAR_ALLOCNO_LIVE(A, I)\t\t\\\n-  ((A)[(unsigned) (I) / HOST_BITS_PER_WIDE_INT]\t\t\t\\\n-     &= ~((HOST_WIDE_INT) 1 << ((unsigned) (I) % HOST_BITS_PER_WIDE_INT)))\n-\n-#define GET_ALLOCNO_LIVE(A, I)\t\t\\\n-  ((A)[(unsigned) (I) / HOST_BITS_PER_WIDE_INT]\t\t\t\\\n-     & ((HOST_WIDE_INT) 1 << ((unsigned) (I) % HOST_BITS_PER_WIDE_INT)))\n+#include \"sparseset.h\"\n \n /* Externs defined in regs.h.  */\n \n int max_allocno;\n struct allocno *allocno;\n-HOST_WIDE_INT *conflicts;\n-int allocno_row_words;\n+HOST_WIDEST_FAST_INT *conflicts;\n int *reg_allocno;\n+int *partial_bitnum;\n+int max_bitnum;\n+alloc_pool adjacency_pool;\n+adjacency_t **adjacency;\n \n typedef struct df_ref * df_ref_t;\n DEF_VEC_P(df_ref_t);\n DEF_VEC_ALLOC_P(df_ref_t,heap);\n \n+/* Macros to determine the bit number within the triangular bit matrix for\n+   the two allocnos Low and HIGH, with LOW strictly less than HIGH.  */\n+\n+#define CONFLICT_BITNUM(I, J) \\\n+  (((I) < (J)) ? (partial_bitnum[I] + (J)) : (partial_bitnum[J] + (I)))\n+\n+#define CONFLICT_BITNUM_FAST(I, I_PARTIAL_BITNUM, J) \\\n+  (((I) < (J)) ? ((I_PARTIAL_BITNUM) + (J)) : (partial_bitnum[J] + (I)))\n+\n+bool\n+conflict_p (int allocno1, int allocno2)\n+{\n+  int bitnum;\n+  HOST_WIDEST_FAST_INT word, mask;\n+\n+#ifdef ENABLE_CHECKING\n+  int blk1, blk2;\n+\n+  gcc_assert (allocno1 >= 0 && allocno1 < max_allocno);\n+  gcc_assert (allocno2 >= 0 && allocno2 < max_allocno);\n+\n+  blk1 = regno_basic_block (allocno[allocno1].reg);\n+  blk2 = regno_basic_block (allocno[allocno2].reg);\n+  gcc_assert (blk1 == 0 || blk2 == 0 || blk1 == blk2);\n+#endif\n+\n+  if (allocno1 == allocno2)\n+    /* By definition, an allocno does not conflict with itself.  */\n+    return 0;\n+\n+  bitnum = CONFLICT_BITNUM (allocno1, allocno2);\n+\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (bitnum >= 0 && bitnum < max_bitnum);\n+#endif\n+\n+  word = conflicts[bitnum / HOST_BITS_PER_WIDEST_FAST_INT];\n+  mask = (HOST_WIDEST_FAST_INT) 1 << (bitnum % HOST_BITS_PER_WIDEST_FAST_INT);\n+  return (word & mask) != 0;\n+}\n+\n+/* Add conflict edges between ALLOCNO1 and ALLOCNO2.  */\n+\n+static void\n+set_conflict (int allocno1, int allocno2)\n+{\n+  int bitnum, index;\n+  HOST_WIDEST_FAST_INT word, mask;\n+\n+#ifdef ENABLE_CHECKING\n+  int blk1, blk2;\n+\n+  gcc_assert (allocno1 >= 0 && allocno1 < max_allocno);\n+  gcc_assert (allocno2 >= 0 && allocno2 < max_allocno);\n+\n+  blk1 = regno_basic_block (allocno[allocno1].reg);\n+  blk2 = regno_basic_block (allocno[allocno2].reg);\n+  gcc_assert (blk1 == 0 || blk2 == 0 || blk1 == blk2);\n+#endif\n+\n+  /* By definition, an allocno does not conflict with itself.  */\n+  if (allocno1 == allocno2)\n+    return;\n+\n+  bitnum = CONFLICT_BITNUM (allocno1, allocno2);\n+\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (bitnum >= 0 && bitnum < max_bitnum);\n+#endif\n+\n+  index = bitnum / HOST_BITS_PER_WIDEST_FAST_INT;\n+  word = conflicts[index];\n+  mask = (HOST_WIDEST_FAST_INT) 1 << (bitnum % HOST_BITS_PER_WIDEST_FAST_INT);\n+\n+  if ((word & mask) == 0)\n+    {\n+      conflicts[index] = word | mask;\n+      add_neighbor (allocno1, allocno2);\n+      add_neighbor (allocno2, allocno1);\n+    }\n+}\n+\n+/* Add conflict edges between ALLOCNO1 and all allocnos currently live.  */\n+\n+static void\n+set_conflicts (int allocno1, sparseset live)\n+{\n+  int i;\n+  int bitnum, index;\n+  HOST_WIDEST_FAST_INT word, mask;\n+  int partial_bitnum_allocno1;\n+\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (allocno1 >= 0 && allocno1 < max_allocno);\n+#endif\n+\n+  partial_bitnum_allocno1 = partial_bitnum[allocno1];\n+\n+  EXECUTE_IF_SET_IN_SPARSESET (live, i)\n+  {\n+    /* By definition, an allocno does not conflict with itself.  */\n+    if (allocno1 == i)\n+      continue;\n+\n+#ifdef ENABLE_CHECKING\n+    gcc_assert (i >= 0 && i < max_allocno);\n+#endif\n+\n+    bitnum = CONFLICT_BITNUM_FAST (allocno1, partial_bitnum_allocno1, i);\n+\n+#ifdef ENABLE_CHECKING\n+    gcc_assert (bitnum >= 0 && bitnum < max_bitnum);\n+#endif\n+\n+    index = bitnum / HOST_BITS_PER_WIDEST_FAST_INT;\n+    word = conflicts[index];\n+    mask = (HOST_WIDEST_FAST_INT) 1 << (bitnum % HOST_BITS_PER_WIDEST_FAST_INT);\n+\n+    if ((word & mask) == 0)\n+      {\n+\tconflicts[index] = word | mask;\n+\tadd_neighbor (allocno1, i);\n+\tadd_neighbor (i, allocno1);\n+      }\n+  }\n+}\n+\n+\n /* Add a conflict between R1 and R2.  */\n \n static void\n record_one_conflict_between_regnos (enum machine_mode mode1, int r1, \n \t\t\t\t    enum machine_mode mode2, int r2)\n {\n+  int allocno1 = reg_allocno[r1];\n+  int allocno2 = reg_allocno[r2];\n+\n   if (dump_file)\n     fprintf (dump_file, \"  rocbr adding %d<=>%d\\n\", r1, r2);\n-  if (reg_allocno[r1] >= 0 && reg_allocno[r2] >= 0)\n-    {\n-      int tr1 = reg_allocno[r1];\n-      int tr2 = reg_allocno[r2];\n-      int ialloc_prod = tr1 * allocno_row_words;\n \n-      SET_ALLOCNO_LIVE ((&conflicts[ialloc_prod]), tr2);\n-    }\n-  else if (reg_allocno[r1] >= 0)\n+  if (allocno1 >= 0 && allocno2 >= 0)\n+    set_conflict (allocno1, allocno2);\n+  else if (allocno1 >= 0)\n     {\n-      int tr1 = reg_allocno[r1];\n-\n       if (r2 < FIRST_PSEUDO_REGISTER)\n-\tadd_to_hard_reg_set (&allocno[tr1].hard_reg_conflicts, mode2, r2);\n+\tadd_to_hard_reg_set (&allocno[allocno1].hard_reg_conflicts, mode2, r2);\n     }\n-  else if (reg_allocno[r2] >= 0)\n+  else if (allocno2 >= 0)\n     {\n-      int tr2 = reg_allocno[r2];\n-\n       if (r1 < FIRST_PSEUDO_REGISTER)\n-        add_to_hard_reg_set (&allocno[tr2].hard_reg_conflicts, mode1, r1);\n+        add_to_hard_reg_set (&allocno[allocno2].hard_reg_conflicts, mode1, r1);\n     }\n \n   /* Now, recursively handle the reg_renumber cases.  */\n@@ -115,26 +226,25 @@ record_one_conflict_between_regnos (enum machine_mode mode1, int r1,\n    before calling here.  */\n \n static void\n-record_one_conflict (HOST_WIDE_INT *allocnos_live, \n+record_one_conflict (sparseset allocnos_live, \n \t\t     HARD_REG_SET *hard_regs_live, int regno)\n {\n   int i;\n \n   if (regno < FIRST_PSEUDO_REGISTER)\n     /* When a hard register becomes live, record conflicts with live\n        pseudo regs.  */\n-    EXECUTE_IF_SET_IN_ALLOCNO_SET (allocnos_live, i,\n+    EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n       {\n \tSET_HARD_REG_BIT (allocno[i].hard_reg_conflicts, regno);\n \tif (dump_file)\n \t  fprintf (dump_file, \"  roc adding %d<=>%d\\n\", allocno[i].reg, regno);\n-      });\n+      }\n   else\n     /* When a pseudo-register becomes live, record conflicts first\n        with hard regs, then with other pseudo regs.  */\n     {\n       int ialloc = reg_allocno[regno];\n-      int ialloc_prod = ialloc * allocno_row_words;\n \n       if (dump_file)\n \t{\n@@ -144,18 +254,16 @@ record_one_conflict (HOST_WIDE_INT *allocnos_live,\n \t\t&& !TEST_HARD_REG_BIT (allocno[ialloc].hard_reg_conflicts, i))\n \t      fprintf (dump_file, \"%d \", i);\n \t  \n-\t  EXECUTE_IF_SET_IN_ALLOCNO_SET (allocnos_live, i,\n+\t  EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n \t    {\n-\t      if (!GET_ALLOCNO_LIVE (&conflicts[ialloc_prod], i))\n+\t      if (!conflict_p (ialloc, i))\n \t\tfprintf (dump_file, \"%d \", allocno[i].reg);\n-\t    });\n+\t    }\n \t  fprintf (dump_file, \")\\n\");\n \t}\n \n       IOR_HARD_REG_SET (allocno[ialloc].hard_reg_conflicts, *hard_regs_live);\n-\n-      for (i = allocno_row_words - 1; i >= 0; i--)\n-\tconflicts[ialloc_prod + i] |= allocnos_live[i];\n+      set_conflicts (ialloc, allocnos_live);\n     }\n }\n \n@@ -168,7 +276,7 @@ record_one_conflict (HOST_WIDE_INT *allocnos_live,\n    nothing.  */\n \n static void\n-mark_reg_store (HOST_WIDE_INT *allocnos_live, \n+mark_reg_store (sparseset allocnos_live, \n \t\tHARD_REG_SET *hard_regs_live, \n \t\tstruct df_ref *ref)\n {\n@@ -340,7 +448,7 @@ ra_init_live_subregs (bool init_value,\n    set not live even if REG is a subreg.  */\n \n inline static void\n-clear_reg_in_live (HOST_WIDE_INT *allocnos_live,\n+clear_reg_in_live (sparseset allocnos_live,\n \t\t   sbitmap *live_subregs, \n \t\t   int *live_subregs_used,\n \t\t   HARD_REG_SET *hard_regs_live, \n@@ -359,7 +467,7 @@ clear_reg_in_live (HOST_WIDE_INT *allocnos_live,\n \t  unsigned int start = SUBREG_BYTE (reg);\n \t  unsigned int last = start + GET_MODE_SIZE (GET_MODE (reg));\n \n-\t  ra_init_live_subregs (GET_ALLOCNO_LIVE (allocnos_live, allocnum) != 0, \n+\t  ra_init_live_subregs (sparseset_bit_p (allocnos_live, allocnum), \n \t\t\t\tlive_subregs, live_subregs_used, allocnum, reg);\n \n \t  /* Ignore the paradoxical bits.  */\n@@ -375,19 +483,19 @@ clear_reg_in_live (HOST_WIDE_INT *allocnos_live,\n \t  if (sbitmap_empty_p (live_subregs[allocnum]))\n \t    {\n \t      live_subregs_used[allocnum] = 0;\n-\t      CLEAR_ALLOCNO_LIVE (allocnos_live, allocnum);\n+\t      sparseset_clear_bit (allocnos_live, allocnum);\n \t    }\n \t  else\n \t    /* Set the allocnos live here because that bit has to be\n \t       true to get us to look at the live_subregs fields.  */\n-\t    SET_ALLOCNO_LIVE (allocnos_live, allocnum);\n+\t    sparseset_set_bit (allocnos_live, allocnum);\n \t}\n       else\n \t{\n \t  /* Resetting the live_subregs_used is effectively saying do not use the \n \t     subregs because we are writing the whole pseudo.  */\n \t  live_subregs_used[allocnum] = 0;\n-\t  CLEAR_ALLOCNO_LIVE (allocnos_live, allocnum);\n+\t  sparseset_clear_bit (allocnos_live, allocnum);\n \t}\n     }\n \n@@ -423,7 +531,7 @@ clear_reg_in_live (HOST_WIDE_INT *allocnos_live,\n    set live even if REG is a subreg.  */\n \n inline static void\n-set_reg_in_live (HOST_WIDE_INT *allocnos_live, \n+set_reg_in_live (sparseset allocnos_live, \n \t\t sbitmap *live_subregs, \n \t\t int *live_subregs_used,\n \t\t HARD_REG_SET *hard_regs_live, \n@@ -441,7 +549,7 @@ set_reg_in_live (HOST_WIDE_INT *allocnos_live,\n \t  unsigned int start = SUBREG_BYTE (reg);\n \t  unsigned int last = start + GET_MODE_SIZE (GET_MODE (reg));\n \n-\t  ra_init_live_subregs (GET_ALLOCNO_LIVE (allocnos_live, allocnum) != 0, \n+\t  ra_init_live_subregs (sparseset_bit_p (allocnos_live, allocnum), \n \t\t\t\tlive_subregs, live_subregs_used, allocnum, reg);\n \t  \n \t  /* Ignore the paradoxical bits.  */\n@@ -459,7 +567,7 @@ set_reg_in_live (HOST_WIDE_INT *allocnos_live,\n \t   subregs because we are writing the whole pseudo.  */\n \t  live_subregs_used[allocnum] = 0;\n      \n-      SET_ALLOCNO_LIVE (allocnos_live, allocnum);\n+      sparseset_set_bit (allocnos_live, allocnum);\n     }\n       \n   if (regno >= FIRST_PSEUDO_REGISTER)\n@@ -630,7 +738,7 @@ global_conflicts (void)\n \n   HARD_REG_SET hard_regs_live;\n   HARD_REG_SET renumbers_live;\n-  HOST_WIDE_INT *allocnos_live;\n+  sparseset allocnos_live;\n   bitmap live = BITMAP_ALLOC (NULL);\n   VEC (df_ref_t, heap) *clobbers = NULL;\n   VEC (df_ref_t, heap) *dying_regs = NULL;\n@@ -654,7 +762,7 @@ global_conflicts (void)\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  allocnos_live = XNEWVEC (HOST_WIDE_INT, allocno_row_words);\n+  allocnos_live = sparseset_alloc (max_allocno);\n \n   FOR_EACH_BB (bb)\n     {\n@@ -663,7 +771,7 @@ global_conflicts (void)\n       bitmap_copy (live, DF_LIVE_OUT (bb));\n       df_simulate_artificial_refs_at_end (bb, live);\n \n-      memset (allocnos_live, 0, allocno_row_words * sizeof (HOST_WIDE_INT));\n+      sparseset_clear (allocnos_live);\n       memset (live_subregs_used, 0, max_allocno * sizeof (int));\n       CLEAR_HARD_REG_SET (hard_regs_live);\n       CLEAR_HARD_REG_SET (renumbers_live);\n@@ -720,11 +828,11 @@ global_conflicts (void)\n \t\t  fprintf (dump_file, \"%d \", i);\n \n \t      fprintf (dump_file, \"] pseudos [\");\n-\t      EXECUTE_IF_SET_IN_ALLOCNO_SET (allocnos_live, i,\n+\t      EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n \t\t{\n \t\t  dump_ref (dump_file, \" \", \"\", regno_reg_rtx[allocno[i].reg],\n \t\t\t    allocno[i].reg, live_subregs, live_subregs_used);\n-\t\t});\n+\t\t}\n \t      fprintf (dump_file, \"]\\n\");\n \t    }\n \n@@ -803,15 +911,15 @@ global_conflicts (void)\n \t     cannot not want to kill the renumbers from the other\n \t     pseudos.  */\n \t  CLEAR_HARD_REG_SET (renumbers_live);\n-\t  EXECUTE_IF_SET_IN_ALLOCNO_SET (allocnos_live, i,\n+\t  EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n \t    {\n \t      unsigned int regno = allocno[i].reg;\n \t      int renumber = reg_renumber[regno];\n \n \t      if (renumber >= 0 && renumber < FIRST_PSEUDO_REGISTER)\n \t\tset_renumbers_live (&renumbers_live, live_subregs, live_subregs_used, \n \t\t\t\t    i, renumber);\n-\t    }); \n+\t    }\n \t\t\t\t\t \n \t  /* Add the uses to the live sets.  Keep track of the regs\n \t     that are dying inside the insn, this set will be useful\n@@ -850,7 +958,7 @@ global_conflicts (void)\n \t\t      unsigned int start = SUBREG_BYTE (reg);\n \t\t      unsigned int last = start + GET_MODE_SIZE (GET_MODE (reg));\n \n-\t\t      ra_init_live_subregs (GET_ALLOCNO_LIVE (allocnos_live, allocnum) != 0, \n+\t\t      ra_init_live_subregs (sparseset_bit_p (allocnos_live, allocnum), \n \t\t\t\t\t    live_subregs, live_subregs_used, allocnum, reg);\n \t\t      \n \t\t      /* Ignore the paradoxical bits.  */\n@@ -870,13 +978,13 @@ global_conflicts (void)\n \t\t\t  start++;\n \t\t\t}\n \t\t      \n-\t\t      SET_ALLOCNO_LIVE (allocnos_live, allocnum);\n+\t\t      sparseset_set_bit (allocnos_live, allocnum);\n \t\t      if (renumber >= 0 && renumber < FIRST_PSEUDO_REGISTER)\n \t\t\tset_renumbers_live (&renumbers_live, live_subregs, live_subregs_used, \n \t\t\t\t\t    allocnum, renumber);\n \t\t    }\n \t\t  \n-\t\t  else if (GET_ALLOCNO_LIVE (allocnos_live, allocnum) == 0)\n+\t\t  else if (!sparseset_bit_p (allocnos_live, allocnum))\n \t\t    {\n \t\t      if (dump_file)\n \t\t\tfprintf (dump_file, \"    dying pseudo\\n\");\n@@ -885,7 +993,7 @@ global_conflicts (void)\n \t\t\t effectively saying do not use the subregs\n \t\t\t because we are reading the whole pseudo.  */\n \t\t      live_subregs_used[allocnum] = 0;\n-\t\t      SET_ALLOCNO_LIVE (allocnos_live, allocnum);\n+\t\t      sparseset_set_bit (allocnos_live, allocnum);\n \t\t      if (renumber >= 0 && renumber < FIRST_PSEUDO_REGISTER)\n \t\t\tset_renumbers_live (&renumbers_live, live_subregs, live_subregs_used, \n \t\t\t\t\t    allocnum, renumber);\n@@ -1087,10 +1195,10 @@ global_conflicts (void)\n \t     because caller-save, fixup_abnormal_edges and possibly the table\n \t     driven EH machinery are not quite ready to handle such regs live\n \t     across such edges.  */\n-\t  EXECUTE_IF_SET_IN_ALLOCNO_SET (allocnos_live, i,\n-\t\t\t\t\t {\n-\t\t\t\t\t   allocno[i].no_stack_reg = 1;\n-\t\t\t\t\t });\n+\t  EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n+\t    {\n+\t      allocno[i].no_stack_reg = 1;\n+\t    }\n \n \t  for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n \t    record_one_conflict (allocnos_live, &hard_regs_live, i);"}, {"sha": "bd4af6d2daf1e51f46a84931f3ab9f94e43750ab", "filename": "gcc/ra.h", "status": "modified", "additions": 122, "deletions": 32, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4da855a9e7a57ea89694006b33f35231b777bbf/gcc%2Fra.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4da855a9e7a57ea89694006b33f35231b777bbf/gcc%2Fra.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra.h?ref=b4da855a9e7a57ea89694006b33f35231b777bbf", "patch": "@@ -85,49 +85,139 @@ extern struct allocno *allocno;\n \n extern int max_allocno;\n \n-/* max_allocno by max_allocno array of bits, recording whether two\n-   allocno's conflict (can't go in the same hardware register).\n+/* max_allocno by max_allocno compressed triangular bit matrix,\n+   recording whether two allocnos conflict (can't go in the same\n+   hardware register).  */\n \n-   `conflicts' is symmetric after the call to mirror_conflicts.  */\n-\n-extern HOST_WIDE_INT *conflicts;\n-\n-/* Number of ints required to hold max_allocno bits.\n-   This is the length of a row in `conflicts'.  */\n-\n-extern int allocno_row_words;\n+extern HOST_WIDEST_FAST_INT *conflicts;\n \n /* Indexed by (pseudo) reg number, gives the allocno, or -1\n    for pseudo registers which are not to be allocated.  */\n \n extern int *reg_allocno;\n \n+/* Precalculated partial bit number in the compressed triangular bit matrix.\n+   For two allocnos, the final bit number is: partial_bitnum[LOW] + HIGH.  */\n+\n+extern int *partial_bitnum;\n+\n+/* Size in bits of the compressed triangular bit matrix.  */\n+\n+extern int max_bitnum;\n+\n+/* The pool to allocate the adjacency list elements from.  */\n+\n+extern alloc_pool adjacency_pool;\n+\n+/* The maximum number of neighbors stored in the neighbors vector before\n+   we have to chain in another vector.  */\n+\n+#define ADJACENCY_VEC_LENGTH 30\n+\n+/* Conflict graph adjacency list.  */\n+\n+typedef struct adjacency_list_d\n+{\n+  int neighbors[ADJACENCY_VEC_LENGTH];\n+  unsigned int index;\n+  struct adjacency_list_d *next;\n+} adjacency_t;\n+\n+extern adjacency_t **adjacency;\n+\n+/* Add NEIGHBOR to ALLOC_NO's adjacency list.  It is assumed the caller\n+   has already determined that NEIGHBOR is not already neighbor by\n+   checking the conflict bit matrix.  */\n+\n+static inline void\n+add_neighbor (int alloc_no, int neighbor)\n+{\n+  adjacency_t *adjlist = adjacency[alloc_no];\n+\n+  if (adjlist == NULL || adjlist->index == ADJACENCY_VEC_LENGTH)\n+    {\n+      adjacency_t *new = pool_alloc (adjacency_pool);\n+      new->index = 0;\n+      new->next = adjlist;\n+      adjlist = new;\n+      adjacency[alloc_no] = adjlist;\n+    }\n+\n+  adjlist->neighbors[adjlist->index++] = neighbor;\n+}\n+\n+/* Iterator for adjacency lists.  */\n+\n+typedef struct adjacency_iterator_d\n+{\n+  adjacency_t *vec;\n+  unsigned int idx;\n+} adjacency_iter;\n+\n+/* Initialize a single adjacency list iterator.  */\n+\n+static inline int\n+adjacency_iter_init (adjacency_iter *ai, int allocno1)\n+{\n+  ai->vec = adjacency[allocno1];\n+  ai->idx = 0;\n+  return ai->vec != NULL;\n+}\n+\n+/* Test whether we have visited all of the neighbors.  */\n+\n+static inline int\n+adjacency_iter_done (adjacency_iter *ai)\n+{\n+  return ai->idx > ai->vec->index;\n+}\n+\n+/* Advance to the next neighbor in AI.  */\n+\n+static inline int\n+adjacency_iter_next (adjacency_iter *ai)\n+{\n+  unsigned int idx = ai->idx;\n+  int neighbor = ai->vec->neighbors[idx++];\n+  if (idx >= ai->vec->index && ai->vec->next != NULL)\n+    {\n+      ai->vec = ai->vec->next;\n+      ai->idx = 0;\n+    }\n+  else\n+    ai->idx = idx;\n+  return neighbor;\n+}\n+\n+/* Return the one basic block regno is used in.  If regno is used\n+   in more than one basic block or if it is unknown which block it\n+   is used in, return 0.  */\n+\n+static inline int\n+regno_basic_block (int regno)\n+{\n+  int block = REG_BASIC_BLOCK (regno);\n+  if (block < 0)\n+    block = 0;\n+  return block;\n+}\n+\n extern void global_conflicts (void);\n \n /* In global.c  */\n \n-/* For any allocno set in ALLOCNO_SET, set ALLOCNO to that allocno,\n-   and execute CODE.  */\n-#define EXECUTE_IF_SET_IN_ALLOCNO_SET(ALLOCNO_SET, ALLOCNO, CODE)\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  int i_;\t\t\t\t\t\t\t\t\\\n-  int allocno_;\t\t\t\t\t\t\t\t\\\n-  HOST_WIDE_INT *p_ = (ALLOCNO_SET);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  for (i_ = allocno_row_words - 1, allocno_ = 0; i_ >= 0;\t\t\\\n-       i_--, allocno_ += HOST_BITS_PER_WIDE_INT)\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      unsigned HOST_WIDE_INT word_ = (unsigned HOST_WIDE_INT) *p_++;\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      for ((ALLOCNO) = allocno_; word_; word_ >>= 1, (ALLOCNO)++)\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (word_ & 1)\t\t\t\t\t\t\\\n-\t    {CODE;}\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-extern void ra_init_live_subregs (bool, sbitmap *, int *, int, rtx reg);\n+/* Macro to visit all of IN_ALLOCNO's neighbors.  Neighbors are\n+   returned in OUT_ALLOCNO for each iteration of the loop.  */\n+\n+#define FOR_EACH_CONFLICT(IN_ALLOCNO, OUT_ALLOCNO, ITER)\t\t\\\n+  if (!adjacency || !adjacency_iter_init (&(ITER), (IN_ALLOCNO)))\t\\\n+    ;\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    for ((OUT_ALLOCNO) = adjacency_iter_next (&(ITER));\t\t\t\\\n+\t !adjacency_iter_done (&(ITER));\t\t\t\t\\\n+\t (OUT_ALLOCNO) = adjacency_iter_next (&(ITER)))\n \n+extern void ra_init_live_subregs (bool, sbitmap *, int *, int, rtx);\n+extern bool conflict_p (int, int);\n \n #endif /* GCC_RA_H */"}, {"sha": "8d7cd9373bdd6bc384d6498e854bb56565555d5a", "filename": "gcc/sparseset.c", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4da855a9e7a57ea89694006b33f35231b777bbf/gcc%2Fsparseset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4da855a9e7a57ea89694006b33f35231b777bbf/gcc%2Fsparseset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsparseset.c?ref=b4da855a9e7a57ea89694006b33f35231b777bbf", "patch": "@@ -0,0 +1,232 @@\n+/* SparseSet implementation.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Contributed by Peter Bergner <bergner@vnet.ibm.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libiberty.h\"\n+#include \"sparseset.h\"\n+\n+\n+/* Allocate and clear a n_elms SparseSet.  */\n+\n+sparseset\n+sparseset_alloc (SPARSESET_ELT_TYPE n_elms)\n+{\n+  unsigned int n_bytes = sizeof (struct sparseset_def)\n+\t\t\t + ((n_elms - 1) * 2 * sizeof (SPARSESET_ELT_TYPE));\n+\n+  sparseset set = (sparseset) xmalloc (n_bytes);\n+  set->dense = &(set->elms[0]);\n+  set->sparse = &(set->elms[n_elms]);\n+  set->size = n_elms;\n+  sparseset_clear (set);\n+  return set;\n+}\n+\n+/* Low level routine not meant for use outside of sparseset.[ch].\n+   Assumes idx1 < s->members and idx2 < s->members.  */\n+\n+static inline void\n+sparseset_swap (sparseset s, SPARSESET_ELT_TYPE idx1, SPARSESET_ELT_TYPE idx2)\n+{\n+  SPARSESET_ELT_TYPE tmp = s->dense[idx2];\n+  sparseset_insert_bit (s, s->dense[idx1], idx2);\n+  sparseset_insert_bit (s, tmp, idx1);\n+}\n+\n+/* Operation: S = S - {e}\n+   Delete e from the set S if it is a member of S.  */\n+\n+void\n+sparseset_clear_bit (sparseset s, SPARSESET_ELT_TYPE e)\n+{\n+  if (sparseset_bit_p (s, e))\n+    {\n+      SPARSESET_ELT_TYPE idx = s->sparse[e];\n+      SPARSESET_ELT_TYPE iter = s->iter;\n+      SPARSESET_ELT_TYPE mem = s->members - 1;\n+\n+      /* If we are iterating over this set and we want to delete a\n+\t member we've already visited, then we swap the element we\n+\t want to delete with the element at the current iteration\n+\t index so that it plays well together with the code below\n+\t that actually removes the element.  */\n+      if (s->iterating && idx <= iter)\n+\t{\n+\t  if (idx < iter)\n+\t    {\n+\t      sparseset_swap (s, idx, iter);\n+\t      idx = iter;\n+\t    }\n+\t  s->iter_inc = 0;\n+\t}\n+\n+      /* Replace the element we want to delete with the last element\n+\t in the dense array and then decrement s->members, effectively\n+\t removing the element we want to delete.  */\n+      sparseset_insert_bit (s, s->dense[mem], idx);\n+      s->members = mem;\n+    }\n+}\n+\n+/* Operation: D = S\n+   Restrictions: none.  */\n+\n+void\n+sparseset_copy (sparseset d, sparseset s)\n+{\n+  SPARSESET_ELT_TYPE i;\n+\n+  if (d == s)\n+    return;\n+\n+  sparseset_clear (d);\n+  for (i = 0; i < s->members; i++)\n+    sparseset_insert_bit (d, s->dense[i], i);\n+  d->members = s->members;\n+}\n+\n+/* Operation: D = A & B.\n+   Restrictions: none.  */\n+\n+void\n+sparseset_and (sparseset d, sparseset a, sparseset b)\n+{\n+  SPARSESET_ELT_TYPE e;\n+\n+  if (a == b)\n+    {\n+      if (d != a)\n+\tsparseset_copy (d, a);\n+      return;\n+    }\n+\n+  if (d == a || d == b)\n+    {\n+      sparseset s = (d == a) ? b : a;\n+\n+      EXECUTE_IF_SET_IN_SPARSESET (d, e)\n+\tif (!sparseset_bit_p (s, e))\n+\t  sparseset_clear_bit (d, e);\n+    }\n+  else\n+    {\n+      sparseset sml, lrg;\n+\n+      if (sparseset_cardinality (a) < sparseset_cardinality (b))\n+\t{\n+\t  sml = a;\n+\t  lrg = b;\n+\t}\n+      else\n+\t{\n+\t  sml = b;\n+\t  lrg = a;\n+\t}\n+\n+      sparseset_clear (d);\n+      EXECUTE_IF_SET_IN_SPARSESET (sml, e)\n+\tif (sparseset_bit_p (lrg, e))\n+\t  sparseset_set_bit (d, e);\n+    }\n+}\n+\n+/* Operation: D = A & ~B.\n+   Restrictions: D != B, unless D == A == B.  */\n+\n+void\n+sparseset_and_compl (sparseset d, sparseset a, sparseset b)\n+{\n+  SPARSESET_ELT_TYPE e;\n+\n+  if (a == b)\n+    {\n+      sparseset_clear (d);\n+      return;\n+    }\n+\n+  gcc_assert (d != b);\n+\n+  if (d == a)\n+    {\n+      if (sparseset_cardinality (d) < sparseset_cardinality (b))\n+\t{\n+\t  EXECUTE_IF_SET_IN_SPARSESET (d, e)\n+\t    if (sparseset_bit_p (b, e))\n+\t      sparseset_clear_bit (d, e);\n+\t}\n+      else\n+\t{\n+\t  EXECUTE_IF_SET_IN_SPARSESET (b, e)\n+\t    sparseset_clear_bit (d, e);\n+\t}\n+    }\n+  else\n+    {\n+      sparseset_clear (d);\n+      EXECUTE_IF_SET_IN_SPARSESET (a, e)\n+\tif (!sparseset_bit_p (b, e))\n+\t  sparseset_set_bit (d, e);\n+    }\n+}\n+\n+/* Operation: D = A | B.\n+   Restrictions: none.  */\n+\n+void\n+sparseset_ior (sparseset d, sparseset a, sparseset b)\n+{\n+  SPARSESET_ELT_TYPE e;\n+\n+  if (a == b)\n+    sparseset_copy (d, a);\n+  else if (d == b)\n+    {\n+      EXECUTE_IF_SET_IN_SPARSESET (a, e)\n+\tsparseset_set_bit (d, e);\n+    }\n+  else\n+    {\n+      if (d != a)\n+        sparseset_copy (d, a);\n+      EXECUTE_IF_SET_IN_SPARSESET (b, e)\n+\tsparseset_set_bit (d, e);\n+    }\n+}\n+\n+/* Operation: A == B\n+   Restrictions: none.  */\n+\n+bool\n+sparseset_equal_p (sparseset a, sparseset b)\n+{\n+  SPARSESET_ELT_TYPE e;\n+\n+  if (a == b)\n+    return true;\n+\n+  if (sparseset_cardinality (a) != sparseset_cardinality (b))\n+    return false;\n+\n+  EXECUTE_IF_SET_IN_SPARSESET (a, e)\n+    if (!sparseset_bit_p (b, e))\n+      return false;\n+\n+  return true;\n+}\n+"}, {"sha": "96ee19acdd787fb2f2e06700a8420a91a0fa8c13", "filename": "gcc/sparseset.h", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4da855a9e7a57ea89694006b33f35231b777bbf/gcc%2Fsparseset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4da855a9e7a57ea89694006b33f35231b777bbf/gcc%2Fsparseset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsparseset.h?ref=b4da855a9e7a57ea89694006b33f35231b777bbf", "patch": "@@ -0,0 +1,162 @@\n+/* SparseSet implementation.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Contributed by Peter Bergner <bergner@vnet.ibm.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_SPARSESET_H\n+#define GCC_SPARSESET_H\n+\n+#include \"system.h\"\n+#include <assert.h>\n+\n+#define SPARSESET_ELT_BITS ((unsigned) HOST_BITS_PER_WIDEST_FAST_INT)\n+#define SPARSESET_ELT_TYPE unsigned int\n+\n+/* Data Structure used for the SparseSet representation.  */\n+\n+typedef struct sparseset_def\n+{\n+  SPARSESET_ELT_TYPE *dense;\t/* Dense array.  */\n+  SPARSESET_ELT_TYPE *sparse; \t/* Sparse array.  */\n+  SPARSESET_ELT_TYPE members;\t/* Number of elements.  */\n+  SPARSESET_ELT_TYPE size;\t/* Maximum number of elements.  */\n+  SPARSESET_ELT_TYPE iter;\t/* Iterator index.  */\n+  unsigned char iter_inc;\t/* Iteration increment amount.  */\n+  bool iterating;\n+  SPARSESET_ELT_TYPE elms[2];   /* Combined dense and sparse arrays.  */\n+} *sparseset;\n+\n+#define sparseset_free(MAP)  free(MAP)\n+extern sparseset sparseset_alloc (SPARSESET_ELT_TYPE n_elms);\n+extern void sparseset_clear_bit (sparseset, SPARSESET_ELT_TYPE);\n+extern void sparseset_copy (sparseset, sparseset);\n+extern void sparseset_and (sparseset, sparseset, sparseset);\n+extern void sparseset_and_compl (sparseset, sparseset, sparseset);\n+extern void sparseset_ior (sparseset, sparseset, sparseset);\n+extern bool sparseset_equal_p (sparseset, sparseset);\n+\n+/* Operation: S = {}\n+   Clear the set of all elements.  */\n+\n+static inline void\n+sparseset_clear (sparseset s)\n+{\n+  s->members = 0;\n+  s->iterating = false;\n+}\n+\n+/* Return the number of elements currently in the set.  */\n+\n+static inline SPARSESET_ELT_TYPE\n+sparseset_cardinality (sparseset s)\n+{\n+  return s->members;\n+}\n+\n+/* Return the maximum number of elements this set can hold.  */\n+\n+static inline SPARSESET_ELT_TYPE\n+sparseset_size (sparseset s)\n+{\n+  return s->size;\n+}\n+\n+/* Return true if e is a member of the set S, otherwise return false.  */\n+\n+static inline bool\n+sparseset_bit_p (sparseset s, SPARSESET_ELT_TYPE e)\n+{\n+  SPARSESET_ELT_TYPE idx;\n+\n+  gcc_assert (e < s->size);\n+\n+  idx = s->sparse[e];\n+\n+  return idx < s->members && s->dense[idx] == e;\n+}\n+\n+/* Low level insertion routine not meant for use outside of sparseset.[ch].\n+   Assumes E is valid and not already a member of the set S.  */\n+\n+static inline void\n+sparseset_insert_bit (sparseset s, SPARSESET_ELT_TYPE e, SPARSESET_ELT_TYPE idx)\n+{\n+  s->sparse[e] = idx;\n+  s->dense[idx] = e;\n+}\n+\n+/* Operation: S = S + {e}\n+   Insert E into the set S, if it isn't already a member.  */\n+\n+static inline void\n+sparseset_set_bit (sparseset s, SPARSESET_ELT_TYPE e)\n+{\n+  if (!sparseset_bit_p (s, e))\n+    sparseset_insert_bit (s, e, s->members++);\n+}\n+\n+/* Return and remove an arbitrary element from the set S.  */\n+\n+static inline SPARSESET_ELT_TYPE\n+sparseset_pop (sparseset s)\n+{\n+  SPARSESET_ELT_TYPE mem = s->members;\n+\n+  gcc_assert (mem != 0);\n+\n+  s->members = mem - 1;\n+  return s->dense[mem];\n+}\n+\n+static inline void\n+sparseset_iter_init (sparseset s)\n+{\n+  s->iter = 0;\n+  s->iter_inc = 1;\n+  s->iterating = true;\n+}\n+\n+static inline bool\n+sparseset_iter_p (sparseset s)\n+{\n+  if (s->iterating && s->iter < s->members)\n+    return true;\n+  else\n+    return s->iterating = false;\n+}\n+\n+static inline SPARSESET_ELT_TYPE\n+sparseset_iter_elm (sparseset s)\n+{\n+  return s->dense[s->iter];\n+}\n+\n+static inline void\n+sparseset_iter_next (sparseset s)\n+{\n+  s->iter += s->iter_inc;\n+  s->iter_inc = 1;\n+}\n+\n+#define EXECUTE_IF_SET_IN_SPARSESET(SPARSESET, ITER)\t\t\t\\\n+  for (sparseset_iter_init (SPARSESET);\t\t\t\t\t\\\n+       sparseset_iter_p (SPARSESET)\t\t\t\t\t\\\n+       && (((ITER) = sparseset_iter_elm (SPARSESET)) || 1);\t\t\\\n+       sparseset_iter_next (SPARSESET))\n+\n+#endif /* GCC_SPARSESET_H */"}]}