{"sha": "aa475c4ac80733f85ba47b109fc1900f05e810e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE0NzVjNGFjODA3MzNmODViYTQ3YjEwOWZjMTkwMGYwNWU4MTBlMg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-04-30T13:07:28Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-04-30T13:33:19Z"}, "message": "libstdc++: Implement LWG 1203 for rvalue iostreams\n\nThis implements the resolution of LWG 1203 so that the constraints for\nrvalue stream insertion/extraction are simpler, and the return type is\nthe original rvalue stream type not its base class.\n\nSigned-off-by: Jonathan Wakely <jwakely@redhat.com>\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/istream (operator>>(Istream&&, x&)): Simplify, as\n\tper LWG 1203.\n\t* include/std/ostream (operator<<(Ostream&&, const x&)):\n\tLikewise.\n\t* testsuite/27_io/basic_istream/extractors_character/char/lwg2499_neg.cc:\n\tAdjust dg-error pattern.\n\t* testsuite/27_io/basic_istream/extractors_character/wchar_t/lwg2499_neg.cc:\n\tLikewise.\n\t* testsuite/27_io/basic_istream/extractors_other/char/4.cc: Define\n\tis_extractable trait to replace std::__is_extractable. Make it\n\twork with rvalue streams as well as lvalues, to replace f() and\n\tg() helper functions.\n\t* testsuite/27_io/basic_istream/extractors_other/wchar_t/4.cc:\n\tLikewise.\n\t* testsuite/27_io/basic_ostream/inserters_other/char/6.cc:\n\tDefine is_insertable trait to replace std::__is_insertable. Make\n\tit work with rvalue streams as well as lvalues, to replace f()\n\tand g() helper functions.\n\t* testsuite/27_io/basic_ostream/inserters_other/wchar_t/6.cc:\n\tLikewise.\n\t* testsuite/27_io/filesystem/path/io/dr2989.cc: Prune additional\n\terrors from new constraints.\n\t* testsuite/27_io/rvalue_streams-2.cc: Remove PR 80675 checks,\n\twhich are no longer expected to compile.\n\t* testsuite/27_io/rvalue_streams.cc: Adjust existing test.\n\tVerify LWG 1203 changes.", "tree": {"sha": "d8a24aef9026d5d67e999a1884510e487567867e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8a24aef9026d5d67e999a1884510e487567867e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa475c4ac80733f85ba47b109fc1900f05e810e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa475c4ac80733f85ba47b109fc1900f05e810e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa475c4ac80733f85ba47b109fc1900f05e810e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa475c4ac80733f85ba47b109fc1900f05e810e2/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d501c338548152f9d2728d383eec3e9cef16784", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d501c338548152f9d2728d383eec3e9cef16784", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d501c338548152f9d2728d383eec3e9cef16784"}], "stats": {"total": 573, "additions": 233, "deletions": 340}, "files": [{"sha": "ea34cce62980b6d0d19706d7b5470d6e127073ba", "filename": "libstdc++-v3/include/std/istream", "status": "modified", "additions": 14, "deletions": 60, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fistream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fistream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fistream?ref=aa475c4ac80733f85ba47b109fc1900f05e810e2", "patch": "@@ -953,80 +953,34 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     ws(basic_istream<_CharT, _Traits>& __is);\n \n #if __cplusplus >= 201103L\n-  template<typename _Ch, typename _Up>\n-    basic_istream<_Ch, _Up>&\n-    __is_convertible_to_basic_istream_test(basic_istream<_Ch, _Up>*);\n-\n-  template<typename _Tp, typename = void>\n-    struct __is_convertible_to_basic_istream_impl\n-    {\n-      using __istream_type = void;\n-    };\n-\n-  template<typename _Tp>\n-    using __do_is_convertible_to_basic_istream_impl =\n-    decltype(__is_convertible_to_basic_istream_test\n-\t     (declval<typename remove_reference<_Tp>::type*>()));\n-\n-  template<typename _Tp>\n-    struct __is_convertible_to_basic_istream_impl\n-    <_Tp,\n-     __void_t<__do_is_convertible_to_basic_istream_impl<_Tp>>>\n-    {\n-      using __istream_type =\n-\t__do_is_convertible_to_basic_istream_impl<_Tp>;\n-    };\n-\n-  template<typename _Tp>\n-    struct __is_convertible_to_basic_istream\n-    : __is_convertible_to_basic_istream_impl<_Tp>\n-    {\n-    public:\n-      using type = __not_<is_void<\n-        typename __is_convertible_to_basic_istream_impl<_Tp>::__istream_type>>;\n-      constexpr static bool value = type::value;\n-    };\n-\n-  template<typename _Istream, typename _Tp, typename = void>\n-    struct __is_extractable : false_type {};\n-\n-  template<typename _Istream, typename _Tp>\n-    struct __is_extractable<_Istream, _Tp,\n-\t\t\t    __void_t<decltype(declval<_Istream&>()\n-\t\t\t\t\t      >> declval<_Tp>())>>\n-    : true_type {};\n-\n-  template<typename _Istream>\n-    using __rvalue_istream_type =\n-      typename __is_convertible_to_basic_istream<\n-\t_Istream>::__istream_type;\n-\n-  // [27.7.1.6] Rvalue stream extraction\n+  // C++11 27.7.2.6 Rvalue stream extraction [istream.rvalue]\n   // _GLIBCXX_RESOLVE_LIB_DEFECTS\n   // 2328. Rvalue stream extraction should use perfect forwarding\n+  // 1203. More useful rvalue stream insertion\n+\n+  // SFINAE helper to check constraints for operator>>(Istream&&, T&&).\n+  // If the constraints are satisfied, it is an alias for Istream&&.\n+  template<typename _Is, typename _Tp,\n+\t   typename = decltype(std::__rval_streamable<_Is>()\n+\t\t\t\t >> std::declval<_Tp>())>\n+    using __rvalue_stream_extraction_t = _Is&&;\n+\n   /**\n    *  @brief  Generic extractor for rvalue stream\n    *  @param  __is  An input stream.\n    *  @param  __x  A reference to the extraction target.\n-   *  @return  is\n+   *  @return  __is\n    *\n    *  This is just a forwarding function to allow extraction from\n    *  rvalue streams since they won't bind to the extractor functions\n    *  that take an lvalue reference.\n   */\n   template<typename _Istream, typename _Tp>\n-    inline\n-    typename enable_if<__and_<__not_<is_lvalue_reference<_Istream>>,\n-\t\t\t      __is_convertible_to_basic_istream<_Istream>,\n-\t\t\t      __is_extractable<\n-\t\t\t\t__rvalue_istream_type<_Istream>,\n-\t\t\t\t_Tp&&>>::value,\n-\t\t       __rvalue_istream_type<_Istream>>::type\n+    inline __rvalue_stream_extraction_t<_Istream, _Tp>\n     operator>>(_Istream&& __is, _Tp&& __x)\n     {\n-      __rvalue_istream_type<_Istream> __ret_is = __is;\n-      __ret_is >> std::forward<_Tp>(__x);\n-      return __ret_is;\n+      __is >> std::forward<_Tp>(__x);\n+      return std::move(__is);\n     }\n #endif // C++11\n "}, {"sha": "fdd2a87665cc2938ce7a9ccfb670e335a845bc07", "filename": "libstdc++-v3/include/std/ostream", "status": "modified", "additions": 31, "deletions": 56, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fostream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fostream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fostream?ref=aa475c4ac80733f85ba47b109fc1900f05e810e2", "patch": "@@ -704,77 +704,52 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return __os.flush(); }\n \n #if __cplusplus >= 201103L\n-  template<typename _Ch, typename _Up>\n-    basic_ostream<_Ch, _Up>&\n-    __is_convertible_to_basic_ostream_test(basic_ostream<_Ch, _Up>*);\n-\n-  template<typename _Tp, typename = void>\n-    struct __is_convertible_to_basic_ostream_impl\n-    {\n-      using __ostream_type = void;\n-    };\n-\n+  // C++11 27.7.3.9 Rvalue stream insertion [ostream.rvalue]\n+  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+  // 1203. More useful rvalue stream insertion\n+\n+  // SFINAE helper to check constraints for operator<<(Ostream&&, const T&).\n+  // If Ostream is publicly and unambiguously derived from ios_base, then\n+  // __rval_streamable<Ostream>() is equivalent to declval<Ostream&>().\n+  // Otherwise, it results in a substitution failure. Specifically, it will\n+  // fail if Ostream is an lvalue reference or the same type as ios_base.\n+  // Use concepts if possible because they're cheaper to evaluate.\n+#if __cpp_lib_concepts\n   template<typename _Tp>\n-    using __do_is_convertible_to_basic_ostream_impl =\n-    decltype(__is_convertible_to_basic_ostream_test\n-\t     (declval<typename remove_reference<_Tp>::type*>()));\n-\n-  template<typename _Tp>\n-    struct __is_convertible_to_basic_ostream_impl\n-    <_Tp,\n-     __void_t<__do_is_convertible_to_basic_ostream_impl<_Tp>>>\n-    {\n-      using __ostream_type =\n-\t__do_is_convertible_to_basic_ostream_impl<_Tp>;\n-    };\n-\n-  template<typename _Tp>\n-    struct __is_convertible_to_basic_ostream\n-    : __is_convertible_to_basic_ostream_impl<_Tp>\n-    {\n-    public:\n-      using type = __not_<is_void<\n-        typename __is_convertible_to_basic_ostream_impl<_Tp>::__ostream_type>>;\n-      constexpr static bool value = type::value;\n-    };\n-\n-  template<typename _Ostream, typename _Tp, typename = void>\n-    struct __is_insertable : false_type {};\n-\n-  template<typename _Ostream, typename _Tp>\n-    struct __is_insertable<_Ostream, _Tp,\n-\t\t\t   __void_t<decltype(declval<_Ostream&>()\n-\t\t\t\t\t     << declval<const _Tp&>())>>\n-\t\t\t\t    : true_type {};\n+    requires (!is_same_v<_Tp, ios_base>)\n+      && requires (_Tp* __t, ios_base* __b) { __b = __t; }\n+    _Tp&\n+    __rval_streamable();\n+#else\n+  template<typename _Tp,\n+\t   typename = _Require<__not_<__is_one_of<_Tp, _Tp&, ios_base>>>>\n+    _Tp&\n+    __rval_streamable(ios_base* = (_Tp*)nullptr);\n+#endif\n \n-  template<typename _Ostream>\n-    using __rvalue_ostream_type =\n-      typename __is_convertible_to_basic_ostream<\n-\t_Ostream>::__ostream_type;\n+  // SFINAE helper to check constraints for operator<<(Ostream&&, const T&).\n+  // If the constraints are satisfied, it is an alias for Ostream&&.\n+  template<typename _Os, typename _Tp,\n+\t   typename = decltype(std::__rval_streamable<_Os>()\n+\t\t\t\t << std::declval<const _Tp&>())>\n+    using __rvalue_stream_insertion_t = _Os&&;\n \n   /**\n    *  @brief  Generic inserter for rvalue stream\n    *  @param  __os  An input stream.\n    *  @param  __x  A reference to the object being inserted.\n-   *  @return  os\n+   *  @return  __os\n    *\n    *  This is just a forwarding function to allow insertion to\n    *  rvalue streams since they won't bind to the inserter functions\n    *  that take an lvalue reference.\n   */\n   template<typename _Ostream, typename _Tp>\n-    inline\n-    typename enable_if<__and_<__not_<is_lvalue_reference<_Ostream>>,\n-\t\t\t      __is_convertible_to_basic_ostream<_Ostream>,\n-\t\t\t      __is_insertable<\n-\t\t\t\t__rvalue_ostream_type<_Ostream>,\n-\t\t\t\tconst _Tp&>>::value,\n-\t\t       __rvalue_ostream_type<_Ostream>>::type\n+    inline __rvalue_stream_insertion_t<_Ostream, _Tp>\n     operator<<(_Ostream&& __os, const _Tp& __x)\n     {\n-      __rvalue_ostream_type<_Ostream> __ret_os = __os;\n-      __ret_os << __x;\n-      return __ret_os;\n+      __os << __x;\n+      return std::move(__os);\n     }\n \n #if __cplusplus > 201703L && _GLIBCXX_USE_CXX11_ABI"}, {"sha": "abd68af8a9a89bf959572be0451084dc13351d63", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/extractors_character/char/lwg2499_neg.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_character%2Fchar%2Flwg2499_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_character%2Fchar%2Flwg2499_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_character%2Fchar%2Flwg2499_neg.cc?ref=aa475c4ac80733f85ba47b109fc1900f05e810e2", "patch": "@@ -26,9 +26,9 @@\n void\n test01(std::istream& in, char* pc, signed char* sc, unsigned char* uc)\n {\n-  in >> pc; // { dg-error \"here\" }\n-  in >> sc; // { dg-error \"here\" }\n-  in >> uc; // { dg-error \"here\" }\n+  in >> pc; // { dg-error \"no match\" }\n+  in >> sc; // { dg-error \"no match\" }\n+  in >> uc; // { dg-error \"no match\" }\n }\n \n struct CT : std::char_traits<char> { };\n@@ -37,9 +37,9 @@ void\n test02(std::basic_istream<char, CT>& in, char* pc, signed char* sc,\n        unsigned char* uc)\n {\n-  in >> pc; // { dg-error \"here\" }\n-  in >> sc; // { dg-error \"here\" }\n-  in >> uc; // { dg-error \"here\" }\n+  in >> pc; // { dg-error \"no match\" }\n+  in >> sc; // { dg-error \"no match\" }\n+  in >> uc; // { dg-error \"no match\" }\n }\n \n // { dg-excess-errors \"\" }"}, {"sha": "214f8d6a931f4e21940caf1b2f7ffe728c2e36f4", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/extractors_character/wchar_t/lwg2499_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_character%2Fwchar_t%2Flwg2499_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_character%2Fwchar_t%2Flwg2499_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_character%2Fwchar_t%2Flwg2499_neg.cc?ref=aa475c4ac80733f85ba47b109fc1900f05e810e2", "patch": "@@ -26,15 +26,15 @@\n void\n test01(std::wistream& in, wchar_t* wc)\n {\n-  in >> wc; // { dg-error \"here\" }\n+  in >> wc; // { dg-error \"no match\" }\n }\n \n struct WT : std::char_traits<wchar_t> { };\n \n void\n test02(std::basic_istream<wchar_t, WT>& in, wchar_t* wc)\n {\n-  in >> wc; // { dg-error \"here\" }\n+  in >> wc; // { dg-error \"no match\" }\n }\n \n // { dg-excess-errors \"\" }"}, {"sha": "9f1e293474fd321c23dda2730bd18733f15f4848", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/char/4.cc", "status": "modified", "additions": 27, "deletions": 50, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_other%2Fchar%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_other%2Fchar%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_other%2Fchar%2F4.cc?ref=aa475c4ac80733f85ba47b109fc1900f05e810e2", "patch": "@@ -21,6 +21,21 @@\n \n #include <sstream>\n \n+template<typename Istream, typename T, typename = void>\n+  struct is_extractable : std::false_type\n+  { };\n+\n+template<typename> using void_t = void;\n+\n+template<typename Istream, typename T>\n+  using extract_result\n+    = decltype(std::declval<Istream>() >> std::declval<const T&>());\n+\n+template<typename Istream, typename T>\n+  struct is_extractable<Istream, T, void_t<extract_result<Istream, T>>>\n+  : std::true_type\n+  { };\n+\n struct X {};\n std::istream& operator>>(std::istream&, X&) = delete;\n \n@@ -30,20 +45,6 @@ std::istream& operator>>(std::istream& is, Y&&) {return is;}\n \n struct Z{};\n \n-template <class T>\n-auto f(T&&) -> decltype(void(std::declval<std::istream&>()\n-\t\t\t     >> std::declval<T&&>()),\n-\t\t\tstd::true_type());\n-\n-std::false_type f(...);\n-\n-template <class T>\n-auto g(T&&) -> decltype(void(std::declval<std::istream&&>()\n-\t\t\t     >> std::declval<T&&>()),\n-\t\t\tstd::true_type());\n-\n-std::false_type g(...);\n-\n void test01()\n {\n   Y y;\n@@ -52,42 +53,18 @@ void test01()\n   is >> Y();\n   std::istringstream() >> y;\n   std::istringstream() >> Y();\n-  static_assert(!std::__is_extractable<std::istream&, X&>::value, \"\");\n-  static_assert(!std::__is_extractable<std::istream&&, X&>::value, \"\");\n-  static_assert(!std::__is_extractable<std::istream&, X&&>::value, \"\");\n-  static_assert(!std::__is_extractable<std::istream&&, X&&>::value, \"\");\n-  static_assert(std::__is_extractable<std::istream&, Y&>::value, \"\");\n-  static_assert(std::__is_extractable<std::istream&&, Y&>::value, \"\");\n-  static_assert(std::__is_extractable<std::istream&, Y&&>::value, \"\");\n-  static_assert(std::__is_extractable<std::istream&&, Y&&>::value, \"\");\n-  static_assert(!std::__is_extractable<std::istream&, Z&>::value, \"\");\n-  static_assert(!std::__is_extractable<std::istream&&, Z&>::value, \"\");\n-  static_assert(!std::__is_extractable<std::istream&, Z&&>::value, \"\");\n-  static_assert(!std::__is_extractable<std::istream&&, Z&&>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<X&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<X&&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<Y&>())),\n-\t\tstd::true_type>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<Y&&>())),\n-\t\tstd::true_type>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<Z&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<Z&&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<X&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<X&&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<Y&>())),\n-\t\tstd::true_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<Y&&>())),\n-\t\tstd::true_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<Z&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<Z&&>())),\n-\t\tstd::false_type>::value, \"\");\n+  static_assert(!is_extractable<std::istream&, X&>::value, \"\");\n+  static_assert(!is_extractable<std::istream&&, X&>::value, \"\");\n+  static_assert(!is_extractable<std::istream&, X&&>::value, \"\");\n+  static_assert(!is_extractable<std::istream&&, X&&>::value, \"\");\n+  static_assert(is_extractable<std::istream&, Y&>::value, \"\");\n+  static_assert(is_extractable<std::istream&&, Y&>::value, \"\");\n+  static_assert(is_extractable<std::istream&, Y&&>::value, \"\");\n+  static_assert(is_extractable<std::istream&&, Y&&>::value, \"\");\n+  static_assert(!is_extractable<std::istream&, Z&>::value, \"\");\n+  static_assert(!is_extractable<std::istream&&, Z&>::value, \"\");\n+  static_assert(!is_extractable<std::istream&, Z&&>::value, \"\");\n+  static_assert(!is_extractable<std::istream&&, Z&&>::value, \"\");\n }\n \n int main()"}, {"sha": "fc7f5505bf4682e6ad8acb2c889d9c32fe02f7d2", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/wchar_t/4.cc", "status": "modified", "additions": 27, "deletions": 50, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_other%2Fwchar_t%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_other%2Fwchar_t%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_other%2Fwchar_t%2F4.cc?ref=aa475c4ac80733f85ba47b109fc1900f05e810e2", "patch": "@@ -21,6 +21,21 @@\n \n #include <sstream>\n \n+template<typename Istream, typename T, typename = void>\n+  struct is_extractable : std::false_type\n+  { };\n+\n+template<typename> using void_t = void;\n+\n+template<typename Istream, typename T>\n+  using extract_result\n+    = decltype(std::declval<Istream>() >> std::declval<const T&>());\n+\n+template<typename Istream, typename T>\n+  struct is_extractable<Istream, T, void_t<extract_result<Istream, T>>>\n+  : std::true_type\n+  { };\n+\n struct X {};\n std::wistream& operator>>(std::wistream&, X&) = delete;\n \n@@ -30,20 +45,6 @@ std::wistream& operator>>(std::wistream& is, Y&&) {return is;}\n \n struct Z{};\n \n-template <class T>\n-auto f(T&&) -> decltype(void(std::declval<std::wistream&>()\n-\t\t\t     >> std::declval<T&&>()),\n-\t\t\tstd::true_type());\n-\n-std::false_type f(...);\n-\n-template <class T>\n-auto g(T&&) -> decltype(void(std::declval<std::wistream&&>()\n-\t\t\t     >> std::declval<T&&>()),\n-\t\t\tstd::true_type());\n-\n-std::false_type g(...);\n-\n void test01()\n {\n   Y y;\n@@ -52,42 +53,18 @@ void test01()\n   is >> Y();\n   std::wistringstream() >> y;\n   std::wistringstream() >> Y();\n-  static_assert(!std::__is_extractable<std::wistream&, X&>::value, \"\");\n-  static_assert(!std::__is_extractable<std::wistream&&, X&>::value, \"\");\n-  static_assert(!std::__is_extractable<std::wistream&, X&&>::value, \"\");\n-  static_assert(!std::__is_extractable<std::wistream&&, X&&>::value, \"\");\n-  static_assert(std::__is_extractable<std::wistream&, Y&>::value, \"\");\n-  static_assert(std::__is_extractable<std::wistream&&, Y&>::value, \"\");\n-  static_assert(std::__is_extractable<std::wistream&, Y&&>::value, \"\");\n-  static_assert(std::__is_extractable<std::wistream&&, Y&&>::value, \"\");\n-  static_assert(!std::__is_extractable<std::wistream&, Z&>::value, \"\");\n-  static_assert(!std::__is_extractable<std::wistream&&, Z&>::value, \"\");\n-  static_assert(!std::__is_extractable<std::wistream&, Z&&>::value, \"\");\n-  static_assert(!std::__is_extractable<std::wistream&&, Z&&>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<X&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<X&&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<Y&>())),\n-\t\tstd::true_type>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<Y&&>())),\n-\t\tstd::true_type>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<Z&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<Z&&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<X&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<X&&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<Y&>())),\n-\t\tstd::true_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<Y&&>())),\n-\t\tstd::true_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<Z&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<Z&&>())),\n-\t\tstd::false_type>::value, \"\");\n+  static_assert(!is_extractable<std::wistream&, X&>::value, \"\");\n+  static_assert(!is_extractable<std::wistream&&, X&>::value, \"\");\n+  static_assert(!is_extractable<std::wistream&, X&&>::value, \"\");\n+  static_assert(!is_extractable<std::wistream&&, X&&>::value, \"\");\n+  static_assert(is_extractable<std::wistream&, Y&>::value, \"\");\n+  static_assert(is_extractable<std::wistream&&, Y&>::value, \"\");\n+  static_assert(is_extractable<std::wistream&, Y&&>::value, \"\");\n+  static_assert(is_extractable<std::wistream&&, Y&&>::value, \"\");\n+  static_assert(!is_extractable<std::wistream&, Z&>::value, \"\");\n+  static_assert(!is_extractable<std::wistream&&, Z&>::value, \"\");\n+  static_assert(!is_extractable<std::wistream&, Z&&>::value, \"\");\n+  static_assert(!is_extractable<std::wistream&&, Z&&>::value, \"\");\n }\n \n int main()"}, {"sha": "4801afcba6c07067edd10daaa005718f6aa8413d", "filename": "libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/char/6.cc", "status": "modified", "additions": 28, "deletions": 50, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostream%2Finserters_other%2Fchar%2F6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostream%2Finserters_other%2Fchar%2F6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostream%2Finserters_other%2Fchar%2F6.cc?ref=aa475c4ac80733f85ba47b109fc1900f05e810e2", "patch": "@@ -21,6 +21,22 @@\n \n #include <sstream>\n \n+template<typename Ostream, typename T, typename = void>\n+  struct is_insertable\n+  : std::false_type\n+  { };\n+\n+template<typename> using void_t = void;\n+\n+template<typename Ostream, typename T>\n+  using insert_result\n+    = decltype(std::declval<Ostream>() << std::declval<const T&>());\n+\n+template<typename Ostream, typename T>\n+  struct is_insertable<Ostream, T, void_t<insert_result<Ostream, T>>>\n+  : std::true_type\n+  { };\n+\n struct X {};\n std::ostream& operator<<(std::ostream&, const X&) = delete;\n \n@@ -30,20 +46,6 @@ std::ostream& operator<<(std::ostream&& os, const Y&) {return os;}\n \n struct Z{};\n \n-template <class T>\n-auto f(T&&) -> decltype(void(std::declval<std::ostream&>()\n-\t\t\t     << std::declval<T&&>()),\n-\t\t\tstd::true_type());\n-\n-std::false_type f(...);\n-\n-template <class T>\n-auto g(T&&) -> decltype(void(std::declval<std::ostream&&>()\n-\t\t\t     << std::declval<T&&>()),\n-\t\t\tstd::true_type());\n-\n-std::false_type g(...);\n-\n void test01()\n {\n   Y y;\n@@ -52,42 +54,18 @@ void test01()\n   os << Y();\n   std::ostringstream() << y;\n   std::ostringstream() << Y();\n-  static_assert(!std::__is_insertable<std::ostream&, X&>::value, \"\");\n-  static_assert(!std::__is_insertable<std::ostream&&, X&>::value, \"\");\n-  static_assert(!std::__is_insertable<std::ostream&, X&&>::value, \"\");\n-  static_assert(!std::__is_insertable<std::ostream&&, X&&>::value, \"\");\n-  static_assert(std::__is_insertable<std::ostream&, Y&>::value, \"\");\n-  static_assert(std::__is_insertable<std::ostream&&, Y&&>::value, \"\");\n-  static_assert(std::__is_insertable<std::ostream&, Y&>::value, \"\");\n-  static_assert(std::__is_insertable<std::ostream&&, Y&&>::value, \"\");\n-  static_assert(!std::__is_insertable<std::ostream&, Z&>::value, \"\");\n-  static_assert(!std::__is_insertable<std::ostream&&, Z&>::value, \"\");\n-  static_assert(!std::__is_insertable<std::ostream&, Z&&>::value, \"\");\n-  static_assert(!std::__is_insertable<std::ostream&&, Z&&>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<X&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<X&&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<Y&>())),\n-\t\tstd::true_type>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<Y&&>())),\n-\t\tstd::true_type>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<Z&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<Z&&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<X&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<X&&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<Y&>())),\n-\t\tstd::true_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<Y&&>())),\n-\t\tstd::true_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<Z&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<Z&&>())),\n-\t\tstd::false_type>::value, \"\");\n+  static_assert(!is_insertable<std::ostream&, X&>::value, \"\");\n+  static_assert(!is_insertable<std::ostream&&, X&>::value, \"\");\n+  static_assert(!is_insertable<std::ostream&, X&&>::value, \"\");\n+  static_assert(!is_insertable<std::ostream&&, X&&>::value, \"\");\n+  static_assert(is_insertable<std::ostream&, Y&>::value, \"\");\n+  static_assert(is_insertable<std::ostream&&, Y&&>::value, \"\");\n+  static_assert(is_insertable<std::ostream&, Y&>::value, \"\");\n+  static_assert(is_insertable<std::ostream&&, Y&&>::value, \"\");\n+  static_assert(!is_insertable<std::ostream&, Z&>::value, \"\");\n+  static_assert(!is_insertable<std::ostream&&, Z&>::value, \"\");\n+  static_assert(!is_insertable<std::ostream&, Z&&>::value, \"\");\n+  static_assert(!is_insertable<std::ostream&&, Z&&>::value, \"\");\n }\n \n int main()"}, {"sha": "3efeb804b00e42fbd925c4595485e3a21b3768d6", "filename": "libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/6.cc", "status": "modified", "additions": 28, "deletions": 50, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostream%2Finserters_other%2Fwchar_t%2F6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostream%2Finserters_other%2Fwchar_t%2F6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostream%2Finserters_other%2Fwchar_t%2F6.cc?ref=aa475c4ac80733f85ba47b109fc1900f05e810e2", "patch": "@@ -21,6 +21,22 @@\n \n #include <sstream>\n \n+template<typename Ostream, typename T, typename = void>\n+  struct is_insertable\n+  : std::false_type\n+  { };\n+\n+template<typename> using void_t = void;\n+\n+template<typename Ostream, typename T>\n+  using insert_result\n+    = decltype(std::declval<Ostream>() << std::declval<const T&>());\n+\n+template<typename Ostream, typename T>\n+  struct is_insertable<Ostream, T, void_t<insert_result<Ostream, T>>>\n+  : std::true_type\n+  { };\n+\n struct X {};\n std::wostream& operator<<(std::wostream&, const X&) = delete;\n \n@@ -30,20 +46,6 @@ std::wostream& operator<<(std::wostream&& os, const Y&) {return os;}\n \n struct Z{};\n \n-template <class T>\n-auto f(T&&) -> decltype(void(std::declval<std::wostream&>()\n-\t\t\t     << std::declval<T&&>()),\n-\t\t\tstd::true_type());\n-\n-std::false_type f(...);\n-\n-template <class T>\n-auto g(T&&) -> decltype(void(std::declval<std::wostream&&>()\n-\t\t\t     << std::declval<T&&>()),\n-\t\t\tstd::true_type());\n-\n-std::false_type g(...);\n-\n void test01()\n {\n   Y y;\n@@ -52,42 +54,18 @@ void test01()\n   os << Y();\n   std::wostringstream() << y;\n   std::wostringstream() << Y();\n-  static_assert(!std::__is_insertable<std::wostream&, X&>::value, \"\");\n-  static_assert(!std::__is_insertable<std::wostream&&, X&>::value, \"\");\n-  static_assert(!std::__is_insertable<std::wostream&, X&&>::value, \"\");\n-  static_assert(!std::__is_insertable<std::wostream&&, X&&>::value, \"\");\n-  static_assert(std::__is_insertable<std::wostream&, Y&>::value, \"\");\n-  static_assert(std::__is_insertable<std::wostream&&, Y&&>::value, \"\");\n-  static_assert(std::__is_insertable<std::wostream&, Y&>::value, \"\");\n-  static_assert(std::__is_insertable<std::wostream&&, Y&&>::value, \"\");\n-  static_assert(!std::__is_insertable<std::wostream&, Z&>::value, \"\");\n-  static_assert(!std::__is_insertable<std::wostream&&, Z&>::value, \"\");\n-  static_assert(!std::__is_insertable<std::wostream&, Z&&>::value, \"\");\n-  static_assert(!std::__is_insertable<std::wostream&&, Z&&>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<X&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<X&&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<Y&>())),\n-\t\tstd::true_type>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<Y&&>())),\n-\t\tstd::true_type>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<Z&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(f(std::declval<Z&&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<X&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<X&&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<Y&>())),\n-\t\tstd::true_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<Y&&>())),\n-\t\tstd::true_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<Z&>())),\n-\t\tstd::false_type>::value, \"\");\n-  static_assert(std::is_same<decltype(g(std::declval<Z&&>())),\n-\t\tstd::false_type>::value, \"\");\n+  static_assert(!is_insertable<std::wostream&, X&>::value, \"\");\n+  static_assert(!is_insertable<std::wostream&&, X&>::value, \"\");\n+  static_assert(!is_insertable<std::wostream&, X&&>::value, \"\");\n+  static_assert(!is_insertable<std::wostream&&, X&&>::value, \"\");\n+  static_assert(is_insertable<std::wostream&, Y&>::value, \"\");\n+  static_assert(is_insertable<std::wostream&&, Y&&>::value, \"\");\n+  static_assert(is_insertable<std::wostream&, Y&>::value, \"\");\n+  static_assert(is_insertable<std::wostream&&, Y&&>::value, \"\");\n+  static_assert(!is_insertable<std::wostream&, Z&>::value, \"\");\n+  static_assert(!is_insertable<std::wostream&&, Z&>::value, \"\");\n+  static_assert(!is_insertable<std::wostream&, Z&&>::value, \"\");\n+  static_assert(!is_insertable<std::wostream&&, Z&&>::value, \"\");\n }\n \n int main()"}, {"sha": "609f1c32a0e3c372086fdb92f3716622c38934d0", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/io/dr2989.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fio%2Fdr2989.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fio%2Fdr2989.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fio%2Fdr2989.cc?ref=aa475c4ac80733f85ba47b109fc1900f05e810e2", "patch": "@@ -33,3 +33,4 @@ void foo(std::iostream& s) {\n   s >> p; // { dg-error \"no match\" }\n }\n // { dg-prune-output \"no type .*enable_if\" }\n+// { dg-prune-output \"no matching function for call to '__rval_streamable\" }"}, {"sha": "d2b6997e4b92b4e1898d65a38e9ad262ab07ff7c", "filename": "libstdc++-v3/testsuite/27_io/rvalue_streams-2.cc", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Frvalue_streams-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Frvalue_streams-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Frvalue_streams-2.cc?ref=aa475c4ac80733f85ba47b109fc1900f05e810e2", "patch": "@@ -58,16 +58,7 @@ struct X { };\n std::ostream& operator<<(std::ostream& os, const X&) { return os; }\n std::istream& operator>>(std::istream& is, X&&) { return is; }\n \n-struct O : std::ostream { };\n-\n-void operator<<(O&, X) = delete;\n-\n-struct I : std::istream { };\n-\n-void operator>>(I&, X) = delete;\n-\n // PR libstdc++/65543\n-// PR libstdc++/80675\n // PR libstdc++/80940\n int main()\n {\n@@ -82,6 +73,4 @@ int main()\n   MyStream2 stream2{};\n   stream2 << \"aaa\";\n   stream2 >> msi;\n-  O{} << X{};\n-  I{} >> X{};\n }"}, {"sha": "3d359091b76a87c9eda29191fd9156baf08142fa", "filename": "libstdc++-v3/testsuite/27_io/rvalue_streams.cc", "status": "modified", "additions": 69, "deletions": 5, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Frvalue_streams.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa475c4ac80733f85ba47b109fc1900f05e810e2/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Frvalue_streams.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Frvalue_streams.cc?ref=aa475c4ac80733f85ba47b109fc1900f05e810e2", "patch": "@@ -25,8 +25,6 @@ void\n test01()\n {\n   int i = 1742;\n-  // This usage isn't supported by the current draft.\n-  // std::string result = (std::ostringstream() << i).str();\n   std::ostringstream() << i;\n   std::string result (\"1742\");\n   int i2;\n@@ -45,10 +43,10 @@ test02()\n {\n   X x;\n   std::istringstream is;\n-  auto& ref1 = (std::move(is) >> x);\n+  auto&& ref1 = (std::move(is) >> x);\n   VERIFY( &ref1 == &is );\n   VERIFY( x.as_rvalue == false );\n-  auto& ref2 = (std::move(is) >> std::move(x));\n+  auto&& ref2 = (std::move(is) >> std::move(x));\n   VERIFY( &ref2 == &is );\n   VERIFY( x.as_rvalue == true );\n \n@@ -57,12 +55,78 @@ test02()\n   std::istringstream(\"x\") >> &arr[0];\n #endif\n   std::istringstream(\"x\") >> arr;\n+  VERIFY( std::string(arr) == \"x\" );\n+}\n+\n+// LWG 1203 More useful rvalue stream insertion\n+void\n+test03()\n+{\n+  int i = 1203;\n+  std::string result = (std::ostringstream() << \"i = \" << i).str();\n+  VERIFY( result == \"i = 1203\" );\n+\n+  std::ostringstream os;\n+  std::ostringstream&& ros = std::move(os) << result;\n+  VERIFY( &ros == &os );\n+  VERIFY( ros.str() == result );\n+\n+  std::stringstream ss;\n+  std::stringstream&& rss = std::move(ss) << result;\n+  VERIFY( &rss == &ss );\n+  VERIFY( rss.str() == result );\n+\n+  std::istringstream is(\"first second third\");\n+  std::istringstream&& ris = std::move(is) >> result;\n+  VERIFY( &ris == &is );\n+  VERIFY( result == \"first\" );\n+\n+  std::stringstream ss2(\"fourth fifth sixth\");\n+  std::stringstream&& rss2 = std::move(ss2) >> result;\n+  VERIFY( &rss2 == &ss2 );\n+  VERIFY( result == \"fourth\" );\n+}\n+\n+struct A { friend void operator<<(std::ios_base&, A) { } };\n+\n+struct O : private std::ios_base { friend void operator<<(O&, int) { } };\n+\n+template<typename Ostream, typename T, typename = void>\n+  struct is_insertable\n+  : std::false_type\n+  { };\n+\n+template<typename> using void_t = void;\n+\n+template<typename Ostream, typename T>\n+  using insert_result\n+    = decltype(std::declval<Ostream>() << std::declval<const T&>());\n+\n+template<typename Ostream, typename T>\n+  struct is_insertable<Ostream, T, void_t<insert_result<Ostream, T>>>\n+  : std::true_type\n+  { };\n+\n+// LWG 1203 negative tests\n+void\n+test04()\n+{\n+  static_assert( is_insertable<std::ios_base&, A>::value,\n+      \"valid using the friend operator<<\" );\n+  static_assert( !is_insertable<std::ios_base&&, A>::value,\n+      \"ill-formed because ios_base is not derived from ios_base\" );\n+\n+  static_assert( is_insertable<O&, int>::value,\n+      \"valid using the friend operator<<\" );\n+  static_assert( !is_insertable<O&&, int>::value,\n+      \"ill-formed because O is not publicly derived from ios_base\" );\n }\n \n int\n main()\n {\n   test01();\n   test02();\n-  return 0;\n+  test03();\n+  test04();\n }"}]}