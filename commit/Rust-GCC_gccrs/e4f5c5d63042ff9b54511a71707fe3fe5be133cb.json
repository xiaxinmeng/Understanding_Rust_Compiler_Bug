{"sha": "e4f5c5d63042ff9b54511a71707fe3fe5be133cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRmNWM1ZDYzMDQyZmY5YjU0NTExYTcxNzA3ZmUzZmU1YmUxMzNjYg==", "commit": {"author": {"name": "Ken Raeburn", "email": "raeburn@cygnus.com", "date": "1998-07-20T19:53:04Z"}, "committer": {"name": "Ken Raeburn", "email": "raeburn@gcc.gnu.org", "date": "1998-07-20T19:53:04Z"}, "message": "mips.md (reload_outsi): Added missing REGNO call.\n\n* mips.md (reload_outsi): Added missing REGNO call.\n(smulsi3_highpart, umulsi3_highpart): Provide prototype for function pointer.\n(mul_acc_di, mul_acc_64bit_di): Don't use match_op_dup, use another\nmatch_operator and compare the codes.\n* mips.h (MASK_DEBUG_E, MASK_DEBUG_I): Set to zero.\n* MIPS multiply pattern fixes:\n* mips.h (enum reg_class, REG_CLASS_NAMES, REG_CLASS_CONTENTS): Add union\nclasses for HI, LO, or HILO plus general registers.\n(GENERATE_MADD): Deleted.\n* mips.md (mulsi3_mult3): Don't disparage output-LO alternative.  Add\nTARGET_MAD to condition.\n(mulsi3): Test HAVE_mulsi3_mult3, not specific flags.\n(mul_acc_si): Expand GENERATE_MADD here; it's the only use.  Use \"*d\" for\naccumulator, to give preference to LO initially but not during reload.\n\nFrom-SVN: r21305", "tree": {"sha": "941a8ebde6d83be3a977beb68eb37e387adfa808", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/941a8ebde6d83be3a977beb68eb37e387adfa808"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4f5c5d63042ff9b54511a71707fe3fe5be133cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4f5c5d63042ff9b54511a71707fe3fe5be133cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4f5c5d63042ff9b54511a71707fe3fe5be133cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4f5c5d63042ff9b54511a71707fe3fe5be133cb/comments", "author": null, "committer": null, "parents": [{"sha": "0d3ba7398c61d69c79d74da37406192d96432b25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d3ba7398c61d69c79d74da37406192d96432b25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d3ba7398c61d69c79d74da37406192d96432b25"}], "stats": {"total": 101, "additions": 76, "deletions": 25}, "files": [{"sha": "d879540c90b0a1cbfc487ed94ff03e6a79a46a72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4f5c5d63042ff9b54511a71707fe3fe5be133cb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4f5c5d63042ff9b54511a71707fe3fe5be133cb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e4f5c5d63042ff9b54511a71707fe3fe5be133cb", "patch": "@@ -1,3 +1,24 @@\n+Mon Jul 20 22:51:57 1998  Ken Raeburn  <raeburn@cygnus.com>\n+\n+\t* mips.md (reload_outsi): Added missing REGNO call.\n+\t(smulsi3_highpart, umulsi3_highpart): Provide prototype for\n+\tfunction pointer.\n+\t(mul_acc_di, mul_acc_64bit_di): Don't use match_op_dup, use\n+\tanother match_operator and compare the codes.\n+\n+\t* mips.h (MASK_DEBUG_E, MASK_DEBUG_I): Set to zero.\n+\n+\t* MIPS multiply pattern fixes:\n+\t* mips.h (enum reg_class, REG_CLASS_NAMES, REG_CLASS_CONTENTS):\n+\tAdd union classes for HI, LO, or HILO plus general registers.\n+\t(GENERATE_MADD): Deleted.\n+\t* mips.md (mulsi3_mult3): Don't disparage output-LO alternative.\n+\tAdd TARGET_MAD to condition.\n+\t(mulsi3): Test HAVE_mulsi3_mult3, not specific flags.\n+\t(mul_acc_si): Expand GENERATE_MADD here; it's the only use.  Use\n+\t\"*d\" for accumulator, to give preference to LO initially but not\n+\tduring reload.\n+\n Mon Jul 20 16:16:38 1998  Dave Brolley  <brolley@cygnus.com>\n \n \t* configure.in (enable_c_mbchar): New configure option."}, {"sha": "27256e5919cdd3e31ac22b0477ef2a74207be142", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4f5c5d63042ff9b54511a71707fe3fe5be133cb/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4f5c5d63042ff9b54511a71707fe3fe5be133cb/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=e4f5c5d63042ff9b54511a71707fe3fe5be133cb", "patch": "@@ -342,11 +342,11 @@ extern void\t\tmips_select_section ();\n #define MASK_DEBUG_B\t0x10000000\t/* GO_IF_LEGITIMATE_ADDRESS debug */\n #define MASK_DEBUG_C\t0x08000000\t/* don't expand seq, etc. */\n #define MASK_DEBUG_D\t0x04000000\t/* don't do define_split's */\n-#define MASK_DEBUG_E\t0x02000000\t/* function_arg debug */\n+#define MASK_DEBUG_E\t0\t\t/* function_arg debug */\n #define MASK_DEBUG_F\t0\n #define MASK_DEBUG_G\t0\t\t/* don't support 64 bit arithmetic */\n #define MASK_DEBUG_H\t0               /* allow ints in FP registers */\n-#define MASK_DEBUG_I\t0x00200000\t/* unused */\n+#define MASK_DEBUG_I\t0\t\t/* unused */\n \n \t\t\t\t\t/* r4000 64 bit sizes */\n #define TARGET_INT64\t\t(target_flags & MASK_INT64)\n@@ -570,12 +570,10 @@ extern void\t\tmips_select_section ();\n #define SUBTARGET_TARGET_OPTIONS\n \n #define GENERATE_BRANCHLIKELY  (!TARGET_MIPS16 && (TARGET_MIPS3900 || (mips_isa >= 2)))\n+\n+/* Generate three-operand multiply instructions for both SImode and DImode.  */\n #define GENERATE_MULT3         (TARGET_MIPS3900\t\t\t\t\\\n \t\t\t\t&& !TARGET_MIPS16)\n-#define GENERATE_MADD          (TARGET_MIPS3900\t\t\t\t\\\n-\t\t\t\t&& !TARGET_MIPS16)\n-\n-\n \n /* Macros to decide whether certain features are available or not,\n    depending on the instruction set architecture level.  */\n@@ -1712,6 +1710,9 @@ enum reg_class\n   LO_REG,\t\t\t/* lo register */\n   HILO_REG,\t\t\t/* hilo register pair for 64 bit mode mult */\n   MD_REGS,\t\t\t/* multiply/divide registers (hi/lo) */\n+  HI_AND_GR_REGS,\t\t/* union classes */\n+  LO_AND_GR_REGS,\n+  HILO_AND_GR_REGS,\n   ST_REGS,\t\t\t/* status registers (fp status) */\n   ALL_REGS,\t\t\t/* all registers */\n   LIM_REG_CLASSES\t\t/* max value + 1 */\n@@ -1738,6 +1739,9 @@ enum reg_class\n   \"LO_REG\",\t\t\t\t\t\t\t\t\\\n   \"HILO_REG\",\t\t\t\t\t\t\t\t\\\n   \"MD_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"HI_AND_GR_REGS\",\t\t\t\t\t\t\t\\\n+  \"LO_AND_GR_REGS\",\t\t\t\t\t\t\t\\\n+  \"HILO_AND_GR_REGS\",\t\t\t\t\t\t\t\\\n   \"ST_REGS\",\t\t\t\t\t\t\t\t\\\n   \"ALL_REGS\"\t\t\t\t\t\t\t\t\\\n }\n@@ -1766,6 +1770,9 @@ enum reg_class\n   { 0x00000000, 0x00000000, 0x00000002 },\t/* lo register */\t\\\n   { 0x00000000, 0x00000000, 0x00000004 },\t/* hilo register */\t\\\n   { 0x00000000, 0x00000000, 0x00000003 },\t/* mul/div registers */\t\\\n+  { 0xffffffff, 0x00000000, 0x00000001 },\t/* union classes */     \\\n+  { 0xffffffff, 0x00000000, 0x00000002 },\t\t\t\t\\\n+  { 0xffffffff, 0x00000000, 0x00000004 },\t\t\t\t\\\n   { 0x00000000, 0x00000000, 0x000007f8 },\t/* status registers */\t\\\n   { 0xffffffff, 0xffffffff, 0x000007ff }\t/* all registers */\t\\\n }"}, {"sha": "558a83293441106fd4e8f948fe19d174d56a1023", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4f5c5d63042ff9b54511a71707fe3fe5be133cb/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4f5c5d63042ff9b54511a71707fe3fe5be133cb/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=e4f5c5d63042ff9b54511a71707fe3fe5be133cb", "patch": "@@ -1645,7 +1645,7 @@\n   \"\"\n   \"\n {\n-  if (GENERATE_MULT3)\n+  if (HAVE_mulsi3_mult3)\n     emit_insn (gen_mulsi3_mult3 (operands[0], operands[1], operands[2]));\n   else if (mips_cpu != PROCESSOR_R4000 || TARGET_MIPS16)\n     emit_insn (gen_mulsi3_internal (operands[0], operands[1], operands[2]));\n@@ -1655,13 +1655,14 @@\n }\")\n \n (define_insn \"mulsi3_mult3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,?l\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,l\")\n \t(mult:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n \t\t (match_operand:SI 2 \"register_operand\" \"d,d\")))\n    (clobber (match_scratch:SI 3 \"=h,h\"))\n    (clobber (match_scratch:SI 4 \"=l,X\"))\n    (clobber (match_scratch:SI 5 \"=a,a\"))]\n-  \"GENERATE_MULT3\"\n+  \"GENERATE_MULT3\n+   || TARGET_MAD\"\n   \"*\n {\n   if (which_alternative == 1)\n@@ -1709,22 +1710,29 @@\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"3\")])\t\t;; mult + mflo + delay\n \n+;; Multiply-accumulate patterns\n+\n+;; For processors that can copy the output to a general register:\n+;;\n ;; The all-d alternative is needed because the combiner will find this\n ;; pattern and then register alloc/reload will move registers around to\n ;; make them fit, and we don't want to trigger unnecessary loads to LO.\n-;; For the moment, that seems to mostly disable the \"macc\" instruction\n-;; though; some \"?\" marks may be needed.  Using \"*d\" helps, but causes\n-;; stack spills in some cases.\n+;;\n+;; The last alternative should be made slightly less desirable, but adding\n+;; \"?\" to the constraint is too strong, and causes values to be loaded into\n+;; LO even when that's more costly.  For now, using \"*d\" mostly does the\n+;; trick.\n (define_insn \"*mul_acc_si\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l,d,d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,*d,*d\")\n \t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"d,d,d\")\n \t\t\t  (match_operand:SI 2 \"register_operand\" \"d,d,d\"))\n-\t\t (match_operand:SI 3 \"register_operand\" \"0,l,d\")))\n+\t\t (match_operand:SI 3 \"register_operand\" \"0,l,*d\")))\n    (clobber (match_scratch:SI 4 \"=h,h,h\"))\n    (clobber (match_scratch:SI 5 \"=X,3,l\"))\n    (clobber (match_scratch:SI 6 \"=a,a,a\"))\n    (clobber (match_scratch:SI 7 \"=X,X,d\"))]\n-  \"GENERATE_MADD\"\n+  \"TARGET_MIPS3900\n+   && !TARGET_MIPS16\"\n   \"*\n {\n   static char *const madd[] = { \\\"madd\\\\t%1,%2\\\",    \\\"madd\\\\t%0,%1,%2\\\" };\n@@ -1736,6 +1744,7 @@\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"1,1,2\")])\n \n+;; Split the above insn if we failed to get LO allocated.\n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n@@ -1922,7 +1931,12 @@\n {\n   rtx dummy = gen_rtx (SIGN_EXTEND, DImode, const0_rtx);\n   rtx dummy2 = gen_rtx_LSHIFTRT (DImode, const0_rtx, const0_rtx);\n-  rtx (*genfn)() = gen_xmulsi3_highpart_internal;\n+#ifndef NO_MD_PROTOTYPES\n+  rtx (*genfn) PROTO((rtx, rtx, rtx, rtx, rtx, rtx));\n+#else\n+  rtx (*genfn) ();\n+#endif\n+  genfn = gen_xmulsi3_highpart_internal;\n   emit_insn ((*genfn) (operands[0], operands[1], operands[2], dummy,\n \t\t       dummy, dummy2));\n   DONE;\n@@ -1939,7 +1953,12 @@\n {\n   rtx dummy = gen_rtx (ZERO_EXTEND, DImode, const0_rtx);\n   rtx dummy2 = gen_rtx_LSHIFTRT (DImode, const0_rtx, const0_rtx);\n-  rtx (*genfn)() = gen_xmulsi3_highpart_internal;\n+#ifndef NO_MD_PROTOTYPES\n+  rtx (*genfn) PROTO((rtx, rtx, rtx, rtx, rtx, rtx));\n+#else\n+  rtx (*genfn) ();\n+#endif\n+  genfn = gen_xmulsi3_highpart_internal;\n   emit_insn ((*genfn) (operands[0], operands[1], operands[2], dummy,\n \t\t       dummy, dummy2));\n   DONE;\n@@ -2016,11 +2035,13 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"+x\")\n \t(plus:DI (mult:DI (match_operator:DI 3 \"extend_operator\"\n \t\t\t   [(match_operand:SI 1 \"register_operand\" \"d\")])\n-\t\t\t  (match_op_dup:DI 3\n+\t\t\t  (match_operator:DI 4 \"extend_operator\"\n \t\t\t   [(match_operand:SI 2 \"register_operand\" \"d\")]))\n \t\t (match_dup 0)))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n-  \"TARGET_MAD && ! TARGET_64BIT\"\n+   (clobber (match_scratch:SI 5 \"=a\"))]\n+  \"TARGET_MAD\n+   && ! TARGET_64BIT\n+   && GET_CODE (operands[3]) == GET_CODE (operands[4])\"\n   \"*\n {\n   if (GET_CODE (operands[3]) == SIGN_EXTEND)\n@@ -2036,12 +2057,14 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"+a\")\n \t(plus:DI (mult:DI (match_operator:DI 3 \"extend_operator\"\n \t\t\t   [(match_operand:SI 1 \"register_operand\" \"d\")])\n-\t\t\t  (match_op_dup:DI 3\n+\t\t\t  (match_operator:DI 4 \"extend_operator\"\n \t\t\t   [(match_operand:SI 2 \"register_operand\" \"d\")]))\n \t\t (match_dup 0)))\n-   (clobber (match_scratch:DI 4 \"=l\"))\n-   (clobber (match_scratch:DI 5 \"=h\"))]\n-  \"TARGET_MAD && TARGET_64BIT\"\n+   (clobber (match_scratch:SI 5 \"=h\"))\n+   (clobber (match_scratch:SI 6 \"=l\"))]\n+  \"TARGET_MAD\n+   && TARGET_64BIT\n+   && GET_CODE (operands[3]) == GET_CODE (operands[4])\"\n   \"*\n {\n   if (GET_CODE (operands[3]) == SIGN_EXTEND)\n@@ -5107,7 +5130,7 @@ move\\\\t%0,%z4\\\\n\\\\\n       DONE;\n     }\n   /* FIXME: I don't know how to get a value into the HI register.  */\n-  if (GET_CODE (operands[0]) == REG && GP_REG_P (operands[0]))\n+  if (GET_CODE (operands[0]) == REG && GP_REG_P (REGNO (operands[0])))\n     {\n       emit_move_insn (operands[0], operands[1]);\n       DONE;"}]}