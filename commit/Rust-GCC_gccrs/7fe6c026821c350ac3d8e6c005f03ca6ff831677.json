{"sha": "7fe6c026821c350ac3d8e6c005f03ca6ff831677", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZlNmMwMjY4MjFjMzUwYWMzZDhlNmMwMDVmMDNjYTZmZjgzMTY3Nw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2013-09-10T14:56:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-09-10T14:56:41Z"}, "message": "exp_prag.adb (Expand_Pragma_Check): Ignore pragma if Is_Ignored set.\n\n2013-09-10  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_prag.adb (Expand_Pragma_Check): Ignore pragma if Is_Ignored set.\n\t* sem_ch13.adb (Make_Aitem_Pragma): Set Is_Checked if needed.\n\t* sem_prag.adb (Check_Kind): Moved from spec (Analyze_Pragma):\n\tMake sure Is_Ignored/Is_Checked are set right (Analyze_Pragma,\n\tcase Check): Ditto (Check_Applicable_Policy): Handle\n\tStatement_Assertion case Throughout, set and check the Is_Checked\n\tflag as appropriate.\n\t* sem_prag.ads (Check_Kind): Moved to body.\n\t* sinfo.ads, sinfo.adb (Is_Checked): New flag.\n\nFrom-SVN: r202457", "tree": {"sha": "82895488fd4b208b6f38e6064fe55f999dd81b60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82895488fd4b208b6f38e6064fe55f999dd81b60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fe6c026821c350ac3d8e6c005f03ca6ff831677", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fe6c026821c350ac3d8e6c005f03ca6ff831677", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fe6c026821c350ac3d8e6c005f03ca6ff831677", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fe6c026821c350ac3d8e6c005f03ca6ff831677/comments", "author": null, "committer": null, "parents": [{"sha": "15e934bf713f8a57abdd0d93d17deac3340e5158", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e934bf713f8a57abdd0d93d17deac3340e5158", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15e934bf713f8a57abdd0d93d17deac3340e5158"}], "stats": {"total": 217, "additions": 159, "deletions": 58}, "files": [{"sha": "bfb9586b5b69501da6c4534ddcd65d5ddc5de57d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fe6c026821c350ac3d8e6c005f03ca6ff831677/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fe6c026821c350ac3d8e6c005f03ca6ff831677/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7fe6c026821c350ac3d8e6c005f03ca6ff831677", "patch": "@@ -1,3 +1,15 @@\n+2013-09-10  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_prag.adb (Expand_Pragma_Check): Ignore pragma if Is_Ignored set.\n+\t* sem_ch13.adb (Make_Aitem_Pragma): Set Is_Checked if needed.\n+\t* sem_prag.adb (Check_Kind): Moved from spec (Analyze_Pragma):\n+\tMake sure Is_Ignored/Is_Checked are set right (Analyze_Pragma,\n+\tcase Check): Ditto (Check_Applicable_Policy): Handle\n+\tStatement_Assertion case Throughout, set and check the Is_Checked\n+\tflag as appropriate.\n+\t* sem_prag.ads (Check_Kind): Moved to body.\n+\t* sinfo.ads, sinfo.adb (Is_Checked): New flag.\n+\n 2013-09-10  Robert Dewar  <dewar@adacore.com>\n \n \t* aspects.ads (Delay_Type): New type (Aspect_Delay): New table."}, {"sha": "eeafa72d3560d727513fbc4f53bfc304110429ae", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fe6c026821c350ac3d8e6c005f03ca6ff831677/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fe6c026821c350ac3d8e6c005f03ca6ff831677/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=7fe6c026821c350ac3d8e6c005f03ca6ff831677", "patch": "@@ -287,10 +287,13 @@ package body Exp_Prag is\n       Msg  : Node_Id;\n \n    begin\n-      --  We already know that this check is enabled, because otherwise the\n-      --  semantic pass dealt with rewriting the assertion (see Sem_Prag)\n+      --  Nothing to do if pragma is ignored\n \n-      --  Since this check is enabled, we rewrite the pragma into a\n+      if Is_Ignored (N) then\n+         return;\n+      end if;\n+\n+      --  Since this check is active, we rewrite the pragma into a\n       --  corresponding if statement, and then analyze the statement\n \n       --  The normal case expansion transforms:"}, {"sha": "6738a5bfbbd8aef36bc8a039285a140fae70ca2b", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fe6c026821c350ac3d8e6c005f03ca6ff831677/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fe6c026821c350ac3d8e6c005f03ca6ff831677/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=7fe6c026821c350ac3d8e6c005f03ca6ff831677", "patch": "@@ -1377,6 +1377,8 @@ package body Sem_Ch13 is\n \n                if Is_Ignored (Aspect) then\n                   Set_Is_Ignored (Aitem);\n+               elsif Is_Checked (Aspect) then\n+                  Set_Is_Checked (Aspect);\n                end if;\n \n                Set_Corresponding_Aspect (Aitem, Aspect);"}, {"sha": "f9dfab7568bdc2eaa28b87328dbd961371d5c002", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 102, "deletions": 36, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fe6c026821c350ac3d8e6c005f03ca6ff831677/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fe6c026821c350ac3d8e6c005f03ca6ff831677/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=7fe6c026821c350ac3d8e6c005f03ca6ff831677", "patch": "@@ -186,6 +186,25 @@ package body Sem_Prag is\n    --  whether a particular item appears in a mixed list of nodes and entities.\n    --  It is assumed that all nodes in the list have entities.\n \n+   function Check_Kind (Nam : Name_Id) return Name_Id;\n+   --  This function is used in connection with pragmas Assert, Check,\n+   --  and assertion aspects and pragmas, to determine if Check pragmas\n+   --  (or corresponding assertion aspects or pragmas) are currently active\n+   --  as determined by the presence of -gnata on the command line (which\n+   --  sets the default), and the appearance of pragmas Check_Policy and\n+   --  Assertion_Policy as configuration pragmas either in a configuration\n+   --  pragma file, or at the start of the current unit, or locally given\n+   --  Check_Policy and Assertion_Policy pragmas that are currently active.\n+   --\n+   --  The value returned is one of the names Check, Ignore, Disable (On\n+   --  returns Check, and Off returns Ignore).\n+   --\n+   --  Note: for assertion kinds Pre'Class, Post'Class, Invariant'Class,\n+   --  and Type_Invariant'Class, the name passed is Name_uPre, Name_uPost,\n+   --  Name_uInvariant, or Name_uType_Invariant, which corresponds to _Pre,\n+   --  _Post, _Invariant, or _Type_Invariant, which are special names used\n+   --  in identifiers to represent these attribute references.\n+\n    procedure Collect_Subprogram_Inputs_Outputs\n      (Subp_Id      : Entity_Id;\n       Subp_Inputs  : in out Elist_Id;\n@@ -3502,7 +3521,7 @@ package body Sem_Prag is\n          --  For a pragma PPC in the extended main source unit, record enabled\n          --  status in SCO.\n \n-         if not Is_Ignored (N) and then not Split_PPC (N) then\n+         if Is_Checked (N) and then not Split_PPC (N) then\n             Set_SCO_Pragma_Enabled (Loc);\n          end if;\n \n@@ -8171,11 +8190,27 @@ package body Sem_Prag is\n       Prag_Id := Get_Pragma_Id (Pname);\n       Pname := Original_Name (N);\n \n-      --  Check applicable policy. We skip this for a pragma that came from\n-      --  an aspect, since we already dealt with the Disable case, and we set\n-      --  the Is_Ignored flag at the time the aspect was analyzed.\n+      --  Check applicable policy. We skip this if Is_Checked or Is_Ignored\n+      --  is already set, indicating that we have already checked the policy\n+      --  at the right point. This happens for example in the case of a pragma\n+      --  that is derived from an Aspect.\n+\n+      if Is_Ignored (N) or else Is_Checked (N) then\n+         null;\n+\n+      --  For a pragma that is a rewriting of another pragma, copy the\n+      --  Is_Checked/Is_Ignored status from the rewritten pragma.\n+\n+      elsif Is_Rewrite_Substitution (N)\n+        and then Nkind (Original_Node (N)) = N_Pragma\n+        and then Original_Node (N) /= N\n+      then\n+         Set_Is_Ignored (N, Is_Ignored (Original_Node (N)));\n+         Set_Is_Checked (N, Is_Checked (Original_Node (N)));\n+\n+      --  Otherwise query the applicable policy at this point\n \n-      if not From_Aspect_Specification (N) then\n+      else\n          Check_Applicable_Policy (N);\n \n          --  If pragma is disabled, rewrite as NULL and skip analysis\n@@ -8886,6 +8921,8 @@ package body Sem_Prag is\n                Append_To (Newa, New_Copy_Tree (Arg2));\n             end if;\n \n+            --  Rewrite as Check pragma\n+\n             Rewrite (N,\n               Make_Pragma (Loc,\n                 Chars                        => Name_Check,\n@@ -9497,9 +9534,6 @@ package body Sem_Prag is\n             Cname : Name_Id;\n             Str   : Node_Id;\n \n-            Check_On : Boolean;\n-            --  Set True if category of assertions referenced by Name enabled\n-\n          begin\n             GNAT_Pragma;\n             Check_At_Least_N_Arguments (2);\n@@ -9533,24 +9567,33 @@ package body Sem_Prag is\n                   null;\n             end case;\n \n-            --  Set Check_On to indicate check status\n+            --  Check applicable policy. We skip this if Checked/Ignored status\n+            --  is already set (e.g. in the casse of a pragma from an aspect).\n \n-            --  If this comes from an aspect, we have already taken care of\n-            --  the policy active when the aspect was analyzed, and Is_Ignored\n-            --  is set appropriately already.\n+            if Is_Checked (N) or else Is_Ignored (N) then\n+               null;\n \n-            if From_Aspect_Specification (N) then\n-               Check_On := not Is_Ignored (N);\n+            --  For a non-source pragma that is a rewriting of another pragma,\n+            --  copy the Is_Checked/Ignored status from the rewritten pragma.\n \n-            --  Otherwise check the status right now\n+            elsif Is_Rewrite_Substitution (N)\n+              and then Nkind (Original_Node (N)) = N_Pragma\n+              and then Original_Node (N) /= N\n+            then\n+               Set_Is_Ignored (N, Is_Ignored (Original_Node (N)));\n+               Set_Is_Checked (N, Is_Checked (Original_Node (N)));\n+\n+            --  Otherwise query the applicable policy at this point\n \n             else\n                case Check_Kind (Cname) is\n                   when Name_Ignore =>\n-                     Check_On := False;\n+                     Set_Is_Ignored (N, True);\n+                     Set_Is_Checked (N, False);\n \n                   when Name_Check =>\n-                     Check_On := True;\n+                     Set_Is_Ignored (N, False);\n+                     Set_Is_Checked (N, True);\n \n                   --  For disable, rewrite pragma as null statement and skip\n                   --  rest of the analysis of the pragma.\n@@ -9585,7 +9628,7 @@ package body Sem_Prag is\n \n                when others =>\n \n-                  if Check_On and then not Split_PPC (N) then\n+                  if Is_Checked (N) and then not Split_PPC (N) then\n \n                      --  Mark pragma/aspect SCO as enabled\n \n@@ -9602,7 +9645,7 @@ package body Sem_Prag is\n                --  we do want to analyze (to get proper references).\n                --  The Preanalyze_And_Resolve routine does just what we want\n \n-               if not Check_On then\n+               if Is_Ignored (N) then\n                   Preanalyze_And_Resolve (Str, Standard_String);\n \n                   --  Otherwise we need a proper analysis and expansion\n@@ -9625,19 +9668,19 @@ package body Sem_Prag is\n             --       null;\n             --    end if;\n \n-            --  The reason we do this rewriting during semantic analysis\n-            --  rather than as part of normal expansion is that we cannot\n-            --  analyze and expand the code for the boolean expression\n-            --  directly, or it may cause insertion of actions that would\n-            --  escape the attempt to suppress the check code.\n+            --  The reason we do this rewriting during semantic analysis rather\n+            --  than as part of normal expansion is that we cannot analyze and\n+            --  expand the code for the boolean expression directly, or it may\n+            --  cause insertion of actions that would escape the attempt to\n+            --  suppress the check code.\n \n             --  Note that the Sloc for the if statement corresponds to the\n             --  argument condition, not the pragma itself. The reason for\n             --  this is that we may generate a warning if the condition is\n             --  False at compile time, and we do not want to delete this\n             --  warning when we delete the if statement.\n \n-            if Expander_Active and not Check_On then\n+            if Expander_Active and Is_Ignored (N) then\n                Eloc := Sloc (Expr);\n \n                Rewrite (N,\n@@ -15047,11 +15090,9 @@ package body Sem_Prag is\n             Check_Optional_Identifier (Arg1, Name_Check);\n             Check_Precondition_Postcondition (In_Body);\n \n-            --  If in spec, nothing more to do. If in body, then we convert the\n-            --  pragma to an equivalent pragam Check. Note we do this whether\n-            --  or not precondition checks are enabled. That works fine since\n-            --  pragma Check will do this check, and will also analyze the\n-            --  condition itself in the proper context.\n+            --  If in spec, nothing more to do. If in body, then we convert\n+            --  the pragma to an equivalent pragma Check. That works fine since\n+            --  pragma Check will analyze the condition in the proper context.\n \n             --  The form of the pragma Check is either:\n \n@@ -15064,20 +15105,25 @@ package body Sem_Prag is\n             --  pragmas are checked.\n \n             if In_Body then\n+\n+               --  Rewrite as Check pragma\n+\n                Rewrite (N,\n                  Make_Pragma (Loc,\n                    Chars                        => Name_Check,\n                    Pragma_Argument_Associations => New_List (\n                      Make_Pragma_Argument_Association (Loc,\n-                       Expression => Make_Identifier (Loc, Pname)),\n+                     Expression => Make_Identifier (Loc, Pname)),\n \n                      Make_Pragma_Argument_Association (Sloc (Arg1),\n-                       Expression => Relocate_Node (Get_Pragma_Arg (Arg1))))));\n+                       Expression =>\n+                         Relocate_Node (Get_Pragma_Arg (Arg1))))));\n \n                if Arg_Count = 2 then\n                   Append_To (Pragma_Argument_Associations (N),\n                     Make_Pragma_Argument_Association (Sloc (Arg2),\n-                      Expression => Relocate_Node (Get_Pragma_Arg (Arg2))));\n+                      Expression =>\n+                        Relocate_Node (Get_Pragma_Arg (Arg2))));\n                end if;\n \n                Analyze (N);\n@@ -18298,17 +18344,33 @@ package body Sem_Prag is\n             Pnm : constant Name_Id := Chars (Get_Pragma_Arg (First (PPA)));\n \n          begin\n-            if Ename = Pnm or else Pnm = Name_Assertion then\n+            if Ename = Pnm\n+              or else Pnm = Name_Assertion\n+              or else (Pnm = Name_Statement_Assertions\n+                        and then (Ename = Name_Assert         or else\n+                                  Ename = Name_Assert_And_Cut or else\n+                                  Ename = Name_Assume         or else\n+                                  Ename = Name_Loop_Invariant))\n+            then\n                Policy := Chars (Get_Pragma_Arg (Last (PPA)));\n \n                case Policy is\n                   when Name_Off | Name_Ignore =>\n                      Set_Is_Ignored (N, True);\n+                     Set_Is_Checked (N, False);\n+\n+                  when Name_On | Name_Check =>\n+                     Set_Is_Checked (N, True);\n+                     Set_Is_Ignored (N, False);\n \n                   when Name_Disable =>\n                      Set_Is_Ignored  (N, True);\n+                     Set_Is_Checked  (N, False);\n                      Set_Is_Disabled (N, True);\n \n+                  --  That should be exhaustive, the null here is a defence\n+                  --  against a malformed tree from previous errors.\n+\n                   when others =>\n                      null;\n                end case;\n@@ -18325,8 +18387,12 @@ package body Sem_Prag is\n       --  compatibility with the RM for the cases of assertion, invariant,\n       --  precondition, predicate, and postcondition.\n \n-      if not Assertions_Enabled then\n-         Set_Is_Ignored (N);\n+      if Assertions_Enabled then\n+         Set_Is_Checked (N, True);\n+         Set_Is_Ignored (N, False);\n+      else\n+         Set_Is_Checked (N, False);\n+         Set_Is_Ignored (N, True);\n       end if;\n    end Check_Applicable_Policy;\n "}, {"sha": "78199319208111f9525b5508af7a70711063545e", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fe6c026821c350ac3d8e6c005f03ca6ff831677/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fe6c026821c350ac3d8e6c005f03ca6ff831677/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=7fe6c026821c350ac3d8e6c005f03ca6ff831677", "patch": "@@ -63,25 +63,6 @@ package Sem_Prag is\n    --  expressions in the pragma as \"spec expressions\" (see section in Sem\n    --  \"Handling of Default and Per-Object Expressions...\").\n \n-   function Check_Kind (Nam : Name_Id) return Name_Id;\n-   --  This function is used in connection with pragmas Assert, Check,\n-   --  and assertion aspects and pragmas, to determine if Check pragmas\n-   --  (or corresponding assertion aspects or pragmas) are currently active\n-   --  as determined by the presence of -gnata on the command line (which\n-   --  sets the default), and the appearance of pragmas Check_Policy and\n-   --  Assertion_Policy as configuration pragmas either in a configuration\n-   --  pragma file, or at the start of the current unit, or locally given\n-   --  Check_Policy and Assertion_Policy pragmas that are currently active.\n-   --\n-   --  The value returned is one of the names Check, Ignore, Disable (On\n-   --  returns Check, and Off returns Ignore).\n-   --\n-   --  Note: for assertion kinds Pre'Class, Post'Class, Invariant'Class,\n-   --  and Type_Invariant'Class, the name passed is Name_uPre, Name_uPost,\n-   --  Name_uInvariant, or Name_uType_Invariant, which corresponds to _Pre,\n-   --  _Post, _Invariant, or _Type_Invariant, which are special names used\n-   --  in identifiers to represent these attribute references.\n-\n    procedure Check_Applicable_Policy (N : Node_Id);\n    --  N is either an N_Aspect or an N_Pragma node. There are two cases. If\n    --  the name of the aspect or pragma is not one of those recognized as"}, {"sha": "6cb18c1890cc4a786bee0a0369c152ce6b456478", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fe6c026821c350ac3d8e6c005f03ca6ff831677/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fe6c026821c350ac3d8e6c005f03ca6ff831677/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=7fe6c026821c350ac3d8e6c005f03ca6ff831677", "patch": "@@ -1732,6 +1732,15 @@ package body Sinfo is\n       return Flag16 (N);\n    end Is_Boolean_Aspect;\n \n+   function Is_Checked\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Aspect_Specification\n+        or else NT (N).Nkind = N_Pragma);\n+      return Flag11 (N);\n+   end Is_Checked;\n+\n    function Is_Component_Left_Opnd\n       (N : Node_Id) return Boolean is\n    begin\n@@ -4840,6 +4849,15 @@ package body Sinfo is\n       Set_Flag16 (N, Val);\n    end Set_Is_Boolean_Aspect;\n \n+   procedure Set_Is_Checked\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Aspect_Specification\n+        or else NT (N).Nkind = N_Pragma);\n+      Set_Flag11 (N, Val);\n+   end Set_Is_Checked;\n+\n    procedure Set_Is_Component_Left_Opnd\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "906077b979378cf0bbeac48076ed95d5b1ddfcfd", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fe6c026821c350ac3d8e6c005f03ca6ff831677/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fe6c026821c350ac3d8e6c005f03ca6ff831677/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=7fe6c026821c350ac3d8e6c005f03ca6ff831677", "patch": "@@ -1269,6 +1269,15 @@ package Sinfo is\n    --    Present in N_Aspect_Specification node. Set if the aspect is for a\n    --    boolean aspect (i.e. Aspect_Id is in Boolean_Aspect subtype).\n \n+   --  Is_Checked (Flag11-Sem)\n+   --    Present in N_Aspect_Specification and N_Pragma nodes. Set for an\n+   --    assertion aspect or pragma, or check pragma for an assertion, that\n+   --    is to be checked at run - time. If either Is_Checked or Is_Ignored\n+   --    is set (they cannot both be set), then this means that the status of\n+   --    the pragma has been checked at the appropriate point and should not\n+   --    be further modified (in some cases these flags are copied when a\n+   --    pragma is rewritten).\n+\n    --  Is_Component_Left_Opnd  (Flag13-Sem)\n    --  Is_Component_Right_Opnd (Flag14-Sem)\n    --    Present in concatenation nodes, to indicate that the corresponding\n@@ -2116,6 +2125,7 @@ package Sinfo is\n       --  Is_Delayed_Aspect (Flag14-Sem)\n       --  Is_Disabled (Flag15-Sem)\n       --  Is_Ignored (Flag9-Sem)\n+      --  Is_Checked (Flag11-Sem)\n       --  Import_Interface_Present (Flag16-Sem)\n       --  Split_PPC (Flag17) set if corresponding aspect had Split_PPC set\n \n@@ -6763,6 +6773,7 @@ package Sinfo is\n       --  Next_Rep_Item (Node5-Sem)\n       --  Split_PPC (Flag17) Set if split pre/post attribute\n       --  Is_Boolean_Aspect (Flag16-Sem)\n+      --  Is_Checked (Flag11-Sem)\n       --  Is_Delayed_Aspect (Flag14-Sem)\n       --  Is_Disabled (Flag15-Sem)\n       --  Is_Ignored (Flag9-Sem)\n@@ -8725,6 +8736,9 @@ package Sinfo is\n    function Is_Boolean_Aspect\n      (N : Node_Id) return Boolean;    -- Flag16\n \n+   function Is_Checked\n+     (N : Node_Id) return Boolean;    -- Flag11\n+\n    function Is_Component_Left_Opnd\n      (N : Node_Id) return Boolean;    -- Flag13\n \n@@ -9715,6 +9729,9 @@ package Sinfo is\n    procedure Set_Is_Boolean_Aspect\n      (N : Node_Id; Val : Boolean := True);    -- Flag16\n \n+   procedure Set_Is_Checked\n+     (N : Node_Id; Val : Boolean := True);    -- Flag11\n+\n    procedure Set_Is_Component_Left_Opnd\n      (N : Node_Id; Val : Boolean := True);    -- Flag13\n \n@@ -12100,6 +12117,7 @@ package Sinfo is\n    pragma Inline (Is_Accessibility_Actual);\n    pragma Inline (Is_Asynchronous_Call_Block);\n    pragma Inline (Is_Boolean_Aspect);\n+   pragma Inline (Is_Checked);\n    pragma Inline (Is_Component_Left_Opnd);\n    pragma Inline (Is_Component_Right_Opnd);\n    pragma Inline (Is_Controlling_Actual);\n@@ -12425,6 +12443,7 @@ package Sinfo is\n    pragma Inline (Set_Is_Accessibility_Actual);\n    pragma Inline (Set_Is_Asynchronous_Call_Block);\n    pragma Inline (Set_Is_Boolean_Aspect);\n+   pragma Inline (Set_Is_Checked);\n    pragma Inline (Set_Is_Component_Left_Opnd);\n    pragma Inline (Set_Is_Component_Right_Opnd);\n    pragma Inline (Set_Is_Controlling_Actual);"}]}