{"sha": "97a0928c524753bcebed187fb087862705fcdda3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTdhMDkyOGM1MjQ3NTNiY2ViZWQxODdmYjA4Nzg2MjcwNWZjZGRhMw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-07-28T17:42:05Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-07-28T17:42:05Z"}, "message": "compiler: use a single temporary for calls with multiple results\n    \n    For calls that return multiple results we used to create a temporary\n    of struct type to hold the results, and also create a separate\n    temporary for each result.  Then the call expression would copy each\n    result out of the struct to the temporary, and Call_result_expression\n    would refer to the desired temporary.\n    \n    Simplify this to just use a single temporary of struct type, and\n    change Call_result_expression to fetch a field of the struct.\n    \n    This may reduce some incorrect tree sharing in the backend code.\n    \n    Reviewed-on: https://go-review.googlesource.com/51770\n\nFrom-SVN: r250682", "tree": {"sha": "fa10dc5e6dd7a1545853a515294f4213cdb38e31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa10dc5e6dd7a1545853a515294f4213cdb38e31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97a0928c524753bcebed187fb087862705fcdda3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97a0928c524753bcebed187fb087862705fcdda3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97a0928c524753bcebed187fb087862705fcdda3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97a0928c524753bcebed187fb087862705fcdda3/comments", "author": null, "committer": null, "parents": [{"sha": "9de009354e6e6fb7dd0c97186ec6f9b7aa92f3a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9de009354e6e6fb7dd0c97186ec6f9b7aa92f3a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9de009354e6e6fb7dd0c97186ec6f9b7aa92f3a4"}], "stats": {"total": 195, "additions": 60, "deletions": 135}, "files": [{"sha": "1c649cb6ca95e4716d213bf67530e2dcfcd5c876", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a0928c524753bcebed187fb087862705fcdda3/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a0928c524753bcebed187fb087862705fcdda3/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=97a0928c524753bcebed187fb087862705fcdda3", "patch": "@@ -1,4 +1,4 @@\n-feb26fbb5065eadfe1f8610e9b74b3749a87c52d\n+27804ec53590e3644e030c9860822139a0cfb03f\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "79a2f524aa734568c9163e196e05facc825ec3ac", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 53, "deletions": 122, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a0928c524753bcebed187fb087862705fcdda3/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a0928c524753bcebed187fb087862705fcdda3/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=97a0928c524753bcebed187fb087862705fcdda3", "patch": "@@ -9463,24 +9463,28 @@ Call_expression::do_lower(Gogo* gogo, Named_object* function,\n \t\t\t\t       this->is_varargs_, loc);\n \n   // If this call returns multiple results, create a temporary\n-  // variable for each result.\n-  size_t rc = this->result_count();\n-  if (rc > 1 && this->results_ == NULL)\n+  // variable to hold them.\n+  if (this->result_count() > 1 && this->call_temp_ == NULL)\n     {\n-      std::vector<Temporary_statement*>* temps =\n-\tnew std::vector<Temporary_statement*>;\n-      temps->reserve(rc);\n+      Struct_field_list* sfl = new Struct_field_list();\n+      Function_type* fntype = this->get_function_type();\n       const Typed_identifier_list* results = fntype->results();\n+      Location loc = this->location();\n+\n+      int i = 0;\n+      char buf[20];\n       for (Typed_identifier_list::const_iterator p = results->begin();\n-\t   p != results->end();\n-\t   ++p)\n-\t{\n-\t  Temporary_statement* temp = Statement::make_temporary(p->type(),\n-\t\t\t\t\t\t\t\tNULL, loc);\n-\t  inserter->insert(temp);\n-\t  temps->push_back(temp);\n-\t}\n-      this->results_ = temps;\n+           p != results->end();\n+           ++p, ++i)\n+        {\n+          snprintf(buf, sizeof buf, \"res%d\", i);\n+          sfl->push_back(Struct_field(Typed_identifier(buf, p->type(), loc)));\n+        }\n+\n+      Struct_type* st = Type::make_struct_type(sfl, loc);\n+      st->set_is_struct_incomparable();\n+      this->call_temp_ = Statement::make_temporary(st, NULL, loc);\n+      inserter->insert(this->call_temp_);\n     }\n \n   // Handle a call to a varargs function by packaging up the extra\n@@ -9779,30 +9783,6 @@ Call_expression::do_flatten(Gogo* gogo, Named_object*,\n       this->args_ = args;\n     }\n \n-  size_t rc = this->result_count();\n-  if (rc > 1 && this->call_temp_ == NULL)\n-    {\n-      Struct_field_list* sfl = new Struct_field_list();\n-      Function_type* fntype = this->get_function_type();\n-      const Typed_identifier_list* results = fntype->results();\n-      Location loc = this->location();\n-\n-      int i = 0;\n-      char buf[20];\n-      for (Typed_identifier_list::const_iterator p = results->begin();\n-           p != results->end();\n-           ++p, ++i)\n-        {\n-          snprintf(buf, sizeof buf, \"res%d\", i);\n-          sfl->push_back(Struct_field(Typed_identifier(buf, p->type(), loc)));\n-        }\n-\n-      Struct_type* st = Type::make_struct_type(sfl, loc);\n-      st->set_is_struct_incomparable();\n-      this->call_temp_ = Statement::make_temporary(st, NULL, loc);\n-      inserter->insert(this->call_temp_);\n-    }\n-\n   return this;\n }\n \n@@ -9827,17 +9807,18 @@ Call_expression::result_count() const\n   return fntype->results()->size();\n }\n \n-// Return the temporary which holds a result.\n+// Return the temporary that holds the result for a call with multiple\n+// results.\n \n Temporary_statement*\n-Call_expression::result(size_t i) const\n+Call_expression::results() const\n {\n-  if (this->results_ == NULL || this->results_->size() <= i)\n+  if (this->call_temp_ == NULL)\n     {\n       go_assert(saw_errors());\n       return NULL;\n     }\n-  return (*this->results_)[i];\n+  return this->call_temp_;\n }\n \n // Set the number of results expected from a call expression.\n@@ -10191,8 +10172,21 @@ Call_expression::interface_method_function(\n Bexpression*\n Call_expression::do_get_backend(Translate_context* context)\n {\n+  Location location = this->location();\n+\n   if (this->call_ != NULL)\n-    return this->call_;\n+    {\n+      // If the call returns multiple results, make a new reference to\n+      // the temporary.\n+      if (this->call_temp_ != NULL)\n+\t{\n+\t  Expression* ref =\n+\t    Expression::make_temporary_reference(this->call_temp_, location);\n+\t  return ref->get_backend(context);\n+\t}\n+\n+      return this->call_;\n+    }\n \n   Function_type* fntype = this->get_function_type();\n   if (fntype == NULL)\n@@ -10202,7 +10196,6 @@ Call_expression::do_get_backend(Translate_context* context)\n     return context->backend()->error_expression();\n \n   Gogo* gogo = context->gogo();\n-  Location location = this->location();\n \n   Func_expression* func = this->fn_->func_expression();\n   Interface_field_reference_expression* interface_method =\n@@ -10323,91 +10316,28 @@ Call_expression::do_get_backend(Translate_context* context)\n                                                        fn_args, bclosure,\n                                                        location);\n \n-  if (this->results_ != NULL)\n+  if (this->call_temp_ != NULL)\n     {\n-      Bexpression* bcall_ref = this->call_result_ref(context);\n-      Bstatement* assn_stmt =\n-          gogo->backend()->assignment_statement(bfunction,\n-                                                bcall_ref, call, location);\n+      // This case occurs when the call returns multiple results.\n \n-      this->call_ = this->set_results(context);\n+      Expression* ref = Expression::make_temporary_reference(this->call_temp_,\n+\t\t\t\t\t\t\t     location);\n+      Bexpression* bref = ref->get_backend(context);\n+      Bstatement* bassn = gogo->backend()->assignment_statement(bfunction,\n+\t\t\t\t\t\t\t\tbref, call,\n+\t\t\t\t\t\t\t\tlocation);\n \n-      Bexpression* set_and_call =\n-          gogo->backend()->compound_expression(assn_stmt, this->call_,\n-                                               location);\n-      return set_and_call;\n+      ref = Expression::make_temporary_reference(this->call_temp_, location);\n+      this->call_ = ref->get_backend(context);\n+\n+      return gogo->backend()->compound_expression(bassn, this->call_,\n+\t\t\t\t\t\t  location);\n     }\n \n   this->call_ = call;\n   return this->call_;\n }\n \n-// Return the backend representation of a reference to the struct used\n-// to capture the result of a multiple-output call.\n-\n-Bexpression*\n-Call_expression::call_result_ref(Translate_context* context)\n-{\n-  go_assert(this->call_temp_ != NULL);\n-  Location location = this->location();\n-  Expression* call_ref =\n-      Expression::make_temporary_reference(this->call_temp_, location);\n-  Bexpression* bcall_ref = call_ref->get_backend(context);\n-  return bcall_ref;\n-}\n-\n-// Set the result variables if this call returns multiple results.\n-\n-Bexpression*\n-Call_expression::set_results(Translate_context* context)\n-{\n-  Gogo* gogo = context->gogo();\n-\n-  Bexpression* results = NULL;\n-  Location loc = this->location();\n-\n-  go_assert(this->call_temp_ != NULL);\n-\n-  size_t rc = this->result_count();\n-  for (size_t i = 0; i < rc; ++i)\n-    {\n-      Temporary_statement* temp = this->result(i);\n-      if (temp == NULL)\n-\t{\n-\t  go_assert(saw_errors());\n-\t  return gogo->backend()->error_expression();\n-\t}\n-      Temporary_reference_expression* ref =\n-\tExpression::make_temporary_reference(temp, loc);\n-      ref->set_is_lvalue();\n-\n-      Bfunction* bfunction = context->function()->func_value()->get_decl();\n-      Bexpression* result_ref = ref->get_backend(context);\n-      Bexpression* bcall_ref = this->call_result_ref(context);\n-      Bexpression* call_result =\n-          gogo->backend()->struct_field_expression(bcall_ref, i, loc);\n-      Bstatement* assn_stmt =\n-          gogo->backend()->assignment_statement(bfunction,\n-                                                result_ref, call_result, loc);\n-\n-      bcall_ref = this->call_result_ref(context);\n-      call_result = gogo->backend()->struct_field_expression(bcall_ref, i, loc);\n-      Bexpression* result =\n-          gogo->backend()->compound_expression(assn_stmt, call_result, loc);\n-\n-      if (results == NULL)\n-        results = result;\n-      else\n-        {\n-          Bstatement* expr_stmt =\n-              gogo->backend()->expression_statement(bfunction, result);\n-          results =\n-              gogo->backend()->compound_expression(expr_stmt, results, loc);\n-        }\n-    }\n-  return results;\n-}\n-\n // Dump ast representation for a call expressin.\n \n void\n@@ -10528,13 +10458,14 @@ Call_result_expression::do_get_backend(Translate_context* context)\n       go_assert(this->call_->is_error_expression());\n       return context->backend()->error_expression();\n     }\n-  Temporary_statement* ts = ce->result(this->index_);\n+  Temporary_statement* ts = ce->results();\n   if (ts == NULL)\n     {\n       go_assert(saw_errors());\n       return context->backend()->error_expression();\n     }\n   Expression* ref = Expression::make_temporary_reference(ts, this->location());\n+  ref = Expression::make_field_reference(ref, this->index_, this->location());\n   return ref->get_backend(context);\n }\n "}, {"sha": "0c742fd92dfff6e11149427a41e00287db1ccdda", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a0928c524753bcebed187fb087862705fcdda3/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a0928c524753bcebed187fb087862705fcdda3/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=97a0928c524753bcebed187fb087862705fcdda3", "patch": "@@ -2115,8 +2115,8 @@ class Call_expression : public Expression\n   Call_expression(Expression* fn, Expression_list* args, bool is_varargs,\n \t\t  Location location)\n     : Expression(EXPRESSION_CALL, location),\n-      fn_(fn), args_(args), type_(NULL), results_(NULL), call_(NULL),\n-      call_temp_(NULL), expected_result_count_(0), is_varargs_(is_varargs),\n+      fn_(fn), args_(args), type_(NULL), call_(NULL), call_temp_(NULL)\n+    , expected_result_count_(0), is_varargs_(is_varargs),\n       varargs_are_lowered_(false), types_are_determined_(false),\n       is_deferred_(false), is_concurrent_(false), issued_error_(false),\n       is_multi_value_arg_(false), is_flattened_(false)\n@@ -2144,11 +2144,11 @@ class Call_expression : public Expression\n   size_t\n   result_count() const;\n \n-  // Return the temporary variable which holds result I.  This is only\n-  // valid after the expression has been lowered, and is only valid\n-  // for calls which return multiple results.\n+  // Return the temporary variable that holds the results.  This is\n+  // only valid after the expression has been lowered, and is only\n+  // valid for calls which return multiple results.\n   Temporary_statement*\n-  result(size_t i) const;\n+  results() const;\n \n   // Set the number of results expected from this call.  This is used\n   // when the call appears in a context that expects multiple results,\n@@ -2292,19 +2292,13 @@ class Call_expression : public Expression\n   Bexpression*\n   set_results(Translate_context*);\n \n-  Bexpression*\n-  call_result_ref(Translate_context* context);\n-\n   // The function to call.\n   Expression* fn_;\n   // The arguments to pass.  This may be NULL if there are no\n   // arguments.\n   Expression_list* args_;\n   // The type of the expression, to avoid recomputing it.\n   Type* type_;\n-  // The list of temporaries which will hold the results if the\n-  // function returns a tuple.\n-  std::vector<Temporary_statement*>* results_;\n   // The backend expression for the call, used for a call which returns a tuple.\n   Bexpression* call_;\n   // A temporary variable to store this call if the function returns a tuple."}]}