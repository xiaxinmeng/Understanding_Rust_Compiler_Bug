{"sha": "0e564ab485f5db3094a2716fa79e57dcb1d181b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU1NjRhYjQ4NWY1ZGIzMDk0YTI3MTZmYTc5ZTU3ZGNiMWQxODFiOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-04T10:08:58Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-04T10:08:58Z"}, "message": "[multiple changes]\n\n2013-01-04  Robert Dewar  <dewar@adacore.com>\n\n\t* warnsw.adb: Minor fixes to -gnatw.d handling.\n\n2013-01-04  Robert Dewar  <dewar@adacore.com>\n\n\t* einfo.adb, atree.adb: Enlarge entities to make 63 more flags, 6 more\n\tfields.\n\n2013-01-04  Joel Brobecker  <brobecker@adacore.com brobecker>\n\n\t* gnat_ugn.texi: Fix typo.\n\n2013-01-04  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_rm.texi: Document alignment choice for subtypes.\n\n2013-01-04  Robert Dewar  <dewar@adacore.com>\n\n\t* validsw.ads: Minor fix to comment.\n\n2013-01-04  Doug Rupp  <rupp@adacore.com>\n\n\t* Makefile.rtl (GNATRTL_NONTASKING_OBJS,\n\tGNATRTL_ALTIVEC_OBJS): Factor g-al* objects.\n\t* gcc-interface/Makefile.in (ADA_EXCLUDE_SRCS): Add g-al* sources.\n\t(GNATRTL_ALTIVEC_OBJS): Override to null for VMS.\n\tRename leon vxworks toolchain as leon-wrs-vxworks.\n\t* gcc-interface/Make-lang.in: Update dependencies\n\n2013-01-04  Pascal Obry  <obry@adacore.com>\n\n\t* prj.ads (For_Each_Source): Add Locally_Removed parameter.\n\t(Source_Iterator): Add Locally_Removed field.\n\t* prj.adb (For_Each_Source): Ignore Locally_Removed files if needed.\n\t(Next): Likewise.\n\n2013-01-04  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_attr.adb: Minor reformatting.\n\n2013-01-04  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb (Insert_Valid_Check): Fix handling of renamed\n\tpacked array element.\n\t* exp_ch4.adb (Expand_Concatenate): Fix some missing parent\n\tfields in generated code.\n\t* exp_util.adb (Side_Effect_Free): Improve detection of cases\n\tneeding renaming.\n\n2013-01-04  Robert Dewar  <dewar@adacore.com>\n\n\t* sinfo.ads: Clean up order of N_xxx subtypes\n\n2013-01-04  Vincent Celier  <celier@adacore.com>\n\n\t* prj-conf.adb (Check_Target): Allow --autoconf= with no target.\n\nFrom-SVN: r194896", "tree": {"sha": "b62ad05a8d3f032da4975d203bb50785b5b7ca02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b62ad05a8d3f032da4975d203bb50785b5b7ca02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e564ab485f5db3094a2716fa79e57dcb1d181b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e564ab485f5db3094a2716fa79e57dcb1d181b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e564ab485f5db3094a2716fa79e57dcb1d181b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e564ab485f5db3094a2716fa79e57dcb1d181b8/comments", "author": null, "committer": null, "parents": [{"sha": "7fcd29e08c49eff92770f7e50895dcfe3d306479", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fcd29e08c49eff92770f7e50895dcfe3d306479", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fcd29e08c49eff92770f7e50895dcfe3d306479"}], "stats": {"total": 1968, "additions": 1785, "deletions": 183}, "files": [{"sha": "14ee24d182f900fb1038de6144253d09bb420aad", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0e564ab485f5db3094a2716fa79e57dcb1d181b8", "patch": "@@ -1,3 +1,61 @@\n+2013-01-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* warnsw.adb: Minor fixes to -gnatw.d handling.\n+\n+2013-01-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* einfo.adb, atree.adb: Enlarge entities to make 63 more flags, 6 more\n+\tfields.\n+\n+2013-01-04  Joel Brobecker  <brobecker@adacore.com brobecker>\n+\n+\t* gnat_ugn.texi: Fix typo.\n+\n+2013-01-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_rm.texi: Document alignment choice for subtypes.\n+\n+2013-01-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* validsw.ads: Minor fix to comment.\n+\n+2013-01-04  Doug Rupp  <rupp@adacore.com>\n+\n+\t* Makefile.rtl (GNATRTL_NONTASKING_OBJS,\n+\tGNATRTL_ALTIVEC_OBJS): Factor g-al* objects.\n+\t* gcc-interface/Makefile.in (ADA_EXCLUDE_SRCS): Add g-al* sources.\n+\t(GNATRTL_ALTIVEC_OBJS): Override to null for VMS.\n+\tRename leon vxworks toolchain as leon-wrs-vxworks.\n+\t* gcc-interface/Make-lang.in: Update dependencies\n+\n+2013-01-04  Pascal Obry  <obry@adacore.com>\n+\n+\t* prj.ads (For_Each_Source): Add Locally_Removed parameter.\n+\t(Source_Iterator): Add Locally_Removed field.\n+\t* prj.adb (For_Each_Source): Ignore Locally_Removed files if needed.\n+\t(Next): Likewise.\n+\n+2013-01-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_attr.adb: Minor reformatting.\n+\n+2013-01-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.adb (Insert_Valid_Check): Fix handling of renamed\n+\tpacked array element.\n+\t* exp_ch4.adb (Expand_Concatenate): Fix some missing parent\n+\tfields in generated code.\n+\t* exp_util.adb (Side_Effect_Free): Improve detection of cases\n+\tneeding renaming.\n+\n+2013-01-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sinfo.ads: Clean up order of N_xxx subtypes\n+\n+2013-01-04  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-conf.adb (Check_Target): Allow --autoconf= with no target.\n+\n 2013-01-04  Robert Dewar  <dewar@adacore.com>\n \n \t* types.ads, prj-conf.adb, par-tchk.adb: Minor reformatting."}, {"sha": "5a8f15ac48a2b9952fcb595b23aa805c5fe38c14", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=0e564ab485f5db3094a2716fa79e57dcb1d181b8", "patch": "@@ -79,6 +79,16 @@ GNATRTL_TASKING_OBJS= \\\n   thread$(objext) \\\n   $(EXTRA_GNATRTL_TASKING_OBJS)\n \n+# Objects the require IEEE Float\n+GNATRTL_ALTIVEC_OBJS= \\\n+  g-allein$(objext) \\\n+  g-alleve$(objext) \\\n+  g-altcon$(objext) \\\n+  g-altive$(objext) \\\n+  g-alveop$(objext) \\\n+  g-alvety$(objext) \\\n+  g-alvevi$(objext)\n+\n # Objects needed for non-tasking.\n GNATRTL_NONTASKING_OBJS= \\\n   a-assert$(objext) \\\n@@ -367,13 +377,6 @@ GNATRTL_NONTASKING_OBJS= \\\n   ada$(objext) \\\n   calendar$(objext) \\\n   directio$(objext) \\\n-  g-allein$(objext) \\\n-  g-alleve$(objext) \\\n-  g-altcon$(objext) \\\n-  g-altive$(objext) \\\n-  g-alveop$(objext) \\\n-  g-alvety$(objext) \\\n-  g-alvevi$(objext) \\\n   g-arrspl$(objext) \\\n   g-awk$(objext) \\\n   g-bubsor$(objext) \\\n@@ -703,5 +706,6 @@ GNATRTL_NONTASKING_OBJS= \\\n   text_io$(objext) \\\n   unchconv$(objext) \\\n   unchdeal$(objext) \\\n+  $(GNATRTL_ALTIVEC_OBJS) \\\n   $(GNATRTL_SOCKETS_OBJS) \\\n   $(EXTRA_GNATRTL_NONTASKING_OBJS)"}, {"sha": "01fc081c5c88daf53d77f5d253ce158382acb5c5", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 988, "deletions": 2, "changes": 990, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=0e564ab485f5db3094a2716fa79e57dcb1d181b8", "patch": "@@ -205,6 +205,31 @@ package body Atree is\n    function To_Flag_Byte3_Ptr is new\n      Unchecked_Conversion (Node_Kind_Ptr, Flag_Byte3_Ptr);\n \n+   --  The following declarations are used to store flags 310-317 in the\n+   --  Nkind field of the sixth component of an extended (entity) node.\n+\n+   type Flag_Byte4 is record\n+      Flag310 : Boolean;\n+      Flag311 : Boolean;\n+      Flag312 : Boolean;\n+      Flag313 : Boolean;\n+      Flag314 : Boolean;\n+      Flag315 : Boolean;\n+      Flag316 : Boolean;\n+      Flag317 : Boolean;\n+   end record;\n+\n+   pragma Pack (Flag_Byte4);\n+   for Flag_Byte4'Size use 8;\n+\n+   type Flag_Byte4_Ptr is access all Flag_Byte4;\n+\n+   function To_Flag_Byte4 is new\n+     Unchecked_Conversion (Node_Kind, Flag_Byte4);\n+\n+   function To_Flag_Byte4_Ptr is new\n+     Unchecked_Conversion (Node_Kind_Ptr, Flag_Byte4_Ptr);\n+\n    --  The following declarations are used to store flags 73-96 and the\n    --  Convention field in the Field12 field of the third component of an\n    --  extended (Entity) node.\n@@ -412,6 +437,59 @@ package body Atree is\n    function To_Flag_Word4_Ptr is new\n      Unchecked_Conversion (Union_Id_Ptr, Flag_Word4_Ptr);\n \n+   --  The following declarations are used to store flags 255-286 in the\n+   --  Field12 field of the sixth component of an extended (entity) node.\n+\n+   type Flag_Word5 is record\n+      Flag255 : Boolean;\n+      Flag256 : Boolean;\n+      Flag257 : Boolean;\n+      Flag258 : Boolean;\n+      Flag259 : Boolean;\n+      Flag260 : Boolean;\n+      Flag261 : Boolean;\n+      Flag262 : Boolean;\n+\n+      Flag263 : Boolean;\n+      Flag264 : Boolean;\n+      Flag265 : Boolean;\n+      Flag266 : Boolean;\n+      Flag267 : Boolean;\n+      Flag268 : Boolean;\n+      Flag269 : Boolean;\n+      Flag270 : Boolean;\n+\n+      Flag271 : Boolean;\n+      Flag272 : Boolean;\n+      Flag273 : Boolean;\n+      Flag274 : Boolean;\n+      Flag275 : Boolean;\n+      Flag276 : Boolean;\n+      Flag277 : Boolean;\n+      Flag278 : Boolean;\n+\n+      Flag279 : Boolean;\n+      Flag280 : Boolean;\n+      Flag281 : Boolean;\n+      Flag282 : Boolean;\n+      Flag283 : Boolean;\n+      Flag284 : Boolean;\n+      Flag285 : Boolean;\n+      Flag286 : Boolean;\n+   end record;\n+\n+   pragma Pack (Flag_Word5);\n+   for Flag_Word5'Size use 32;\n+   for Flag_Word5'Alignment use 4;\n+\n+   type Flag_Word5_Ptr is access all Flag_Word5;\n+\n+   function To_Flag_Word5 is new\n+     Unchecked_Conversion (Union_Id, Flag_Word5);\n+\n+   function To_Flag_Word5_Ptr is new\n+     Unchecked_Conversion (Union_Id_Ptr, Flag_Word5_Ptr);\n+\n    --------------------------------------------------\n    -- Implementation of Tree Substitution Routines --\n    --------------------------------------------------\n@@ -470,8 +548,8 @@ package body Atree is\n    function Allocate_Initialize_Node\n      (Src            : Node_Id;\n       With_Extension : Boolean) return Node_Id;\n-   --  Allocate a new node or node extension. If Src is not empty,\n-   --  the information for the newly-allocated node is copied from it.\n+   --  Allocate a new node or node extension. If Src is not empty, the\n+   --  information for the newly-allocated node is copied from it.\n \n    ------------------------------\n    -- Allocate_Initialize_Node --\n@@ -2232,6 +2310,42 @@ package body Atree is\n          return Nodes.Table (N + 4).Field11;\n       end Field29;\n \n+      function Field30 (N : Node_Id) return Union_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Field6;\n+      end Field30;\n+\n+      function Field31 (N : Node_Id) return Union_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Field7;\n+      end Field31;\n+\n+      function Field32 (N : Node_Id) return Union_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Field8;\n+      end Field32;\n+\n+      function Field33 (N : Node_Id) return Union_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Field9;\n+      end Field33;\n+\n+      function Field34 (N : Node_Id) return Union_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Field10;\n+      end Field34;\n+\n+      function Field35 (N : Node_Id) return Union_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Field11;\n+      end Field35;\n+\n       function Node1 (N : Node_Id) return Node_Id is\n       begin\n          pragma Assert (N <= Nodes.Last);\n@@ -4337,6 +4451,384 @@ package body Atree is\n          return To_Flag_Byte3 (Nodes.Table (N + 4).Nkind).Flag254;\n       end Flag254;\n \n+      function Flag255 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag255;\n+      end Flag255;\n+\n+      function Flag256 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag256;\n+      end Flag256;\n+\n+      function Flag257 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag257;\n+      end Flag257;\n+\n+      function Flag258 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag258;\n+      end Flag258;\n+\n+      function Flag259 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag259;\n+      end Flag259;\n+\n+      function Flag260 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag260;\n+      end Flag260;\n+\n+      function Flag261 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag261;\n+      end Flag261;\n+\n+      function Flag262 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag262;\n+      end Flag262;\n+\n+      function Flag263 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag263;\n+      end Flag263;\n+\n+      function Flag264 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag264;\n+      end Flag264;\n+\n+      function Flag265 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag265;\n+      end Flag265;\n+\n+      function Flag266 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag266;\n+      end Flag266;\n+\n+      function Flag267 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag267;\n+      end Flag267;\n+\n+      function Flag268 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag268;\n+      end Flag268;\n+\n+      function Flag269 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag269;\n+      end Flag269;\n+\n+      function Flag270 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag270;\n+      end Flag270;\n+\n+      function Flag271 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag271;\n+      end Flag271;\n+\n+      function Flag272 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag272;\n+      end Flag272;\n+\n+      function Flag273 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag273;\n+      end Flag273;\n+\n+      function Flag274 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag274;\n+      end Flag274;\n+\n+      function Flag275 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag275;\n+      end Flag275;\n+\n+      function Flag276 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag276;\n+      end Flag276;\n+\n+      function Flag277 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag277;\n+      end Flag277;\n+\n+      function Flag278 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag278;\n+      end Flag278;\n+\n+      function Flag279 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag279;\n+      end Flag279;\n+\n+      function Flag280 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag280;\n+      end Flag280;\n+\n+      function Flag281 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag281;\n+      end Flag281;\n+\n+      function Flag282 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag282;\n+      end Flag282;\n+\n+      function Flag283 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag283;\n+      end Flag283;\n+\n+      function Flag284 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag284;\n+      end Flag284;\n+\n+      function Flag285 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag285;\n+      end Flag285;\n+\n+      function Flag286 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 5).Field12).Flag286;\n+      end Flag286;\n+\n+      function Flag287 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).In_List;\n+      end Flag287;\n+\n+      function Flag288 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Has_Aspects;\n+      end Flag288;\n+\n+      function Flag289 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Rewrite_Ins;\n+      end Flag289;\n+\n+      function Flag290 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Analyzed;\n+      end Flag290;\n+\n+      function Flag291 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Comes_From_Source;\n+      end Flag291;\n+\n+      function Flag292 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Error_Posted;\n+      end Flag292;\n+\n+      function Flag293 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Flag4;\n+      end Flag293;\n+\n+      function Flag294 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Flag5;\n+      end Flag294;\n+\n+      function Flag295 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Flag6;\n+      end Flag295;\n+\n+      function Flag296 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Flag7;\n+      end Flag296;\n+\n+      function Flag297 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Flag8;\n+      end Flag297;\n+\n+      function Flag298 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Flag9;\n+      end Flag298;\n+\n+      function Flag299 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Flag10;\n+      end Flag299;\n+\n+      function Flag300 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Flag11;\n+      end Flag300;\n+\n+      function Flag301 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Flag12;\n+      end Flag301;\n+\n+      function Flag302 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Flag13;\n+      end Flag302;\n+\n+      function Flag303 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Flag14;\n+      end Flag303;\n+\n+      function Flag304 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Flag15;\n+      end Flag304;\n+\n+      function Flag305 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Flag16;\n+      end Flag305;\n+\n+      function Flag306 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Flag17;\n+      end Flag306;\n+\n+      function Flag307 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Flag18;\n+      end Flag307;\n+\n+      function Flag308 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Pflag1;\n+      end Flag308;\n+\n+      function Flag309 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 5).Pflag2;\n+      end Flag309;\n+\n+      function Flag310 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Byte4 (Nodes.Table (N + 5).Nkind).Flag310;\n+      end Flag310;\n+\n+      function Flag311 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Byte4 (Nodes.Table (N + 5).Nkind).Flag311;\n+      end Flag311;\n+\n+      function Flag312 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Byte4 (Nodes.Table (N + 5).Nkind).Flag312;\n+      end Flag312;\n+\n+      function Flag313 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Byte4 (Nodes.Table (N + 5).Nkind).Flag313;\n+      end Flag313;\n+\n+      function Flag314 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Byte4 (Nodes.Table (N + 5).Nkind).Flag314;\n+      end Flag314;\n+\n+      function Flag315 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Byte4 (Nodes.Table (N + 5).Nkind).Flag315;\n+      end Flag315;\n+\n+      function Flag316 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Byte4 (Nodes.Table (N + 5).Nkind).Flag316;\n+      end Flag316;\n+\n+      function Flag317 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Byte4 (Nodes.Table (N + 5).Nkind).Flag317;\n+      end Flag317;\n+\n       procedure Set_Nkind (N : Node_Id; Val : Node_Kind) is\n       begin\n          pragma Assert (N <= Nodes.Last);\n@@ -4517,6 +5009,42 @@ package body Atree is\n          Nodes.Table (N + 4).Field11 := Val;\n       end Set_Field29;\n \n+      procedure Set_Field30 (N : Node_Id; Val : Union_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Field6 := Val;\n+      end Set_Field30;\n+\n+      procedure Set_Field31 (N : Node_Id; Val : Union_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Field7 := Val;\n+      end Set_Field31;\n+\n+      procedure Set_Field32 (N : Node_Id; Val : Union_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Field8 := Val;\n+      end Set_Field32;\n+\n+      procedure Set_Field33 (N : Node_Id; Val : Union_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Field9 := Val;\n+      end Set_Field33;\n+\n+      procedure Set_Field34 (N : Node_Id; Val : Union_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Field10 := Val;\n+      end Set_Field34;\n+\n+      procedure Set_Field35 (N : Node_Id; Val : Union_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Field11 := Val;\n+      end Set_Field35;\n+\n       procedure Set_Node1 (N : Node_Id; Val : Node_Id) is\n       begin\n          pragma Assert (N <= Nodes.Last);\n@@ -6750,6 +7278,464 @@ package body Atree is\n              (Nodes.Table (N + 4).Nkind'Unrestricted_Access)).Flag254 := Val;\n       end Set_Flag254;\n \n+      procedure Set_Flag255 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag255 := Val;\n+      end Set_Flag255;\n+\n+      procedure Set_Flag256 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag256 := Val;\n+      end Set_Flag256;\n+\n+      procedure Set_Flag257 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag257 := Val;\n+      end Set_Flag257;\n+\n+      procedure Set_Flag258 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag258 := Val;\n+      end Set_Flag258;\n+\n+      procedure Set_Flag259 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag259 := Val;\n+      end Set_Flag259;\n+\n+      procedure Set_Flag260 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag260 := Val;\n+      end Set_Flag260;\n+\n+      procedure Set_Flag261 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag261 := Val;\n+      end Set_Flag261;\n+\n+      procedure Set_Flag262 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag262 := Val;\n+      end Set_Flag262;\n+\n+      procedure Set_Flag263 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag263 := Val;\n+      end Set_Flag263;\n+\n+      procedure Set_Flag264 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag264 := Val;\n+      end Set_Flag264;\n+\n+      procedure Set_Flag265 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag265 := Val;\n+      end Set_Flag265;\n+\n+      procedure Set_Flag266 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag266 := Val;\n+      end Set_Flag266;\n+\n+      procedure Set_Flag267 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag267 := Val;\n+      end Set_Flag267;\n+\n+      procedure Set_Flag268 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag268 := Val;\n+      end Set_Flag268;\n+\n+      procedure Set_Flag269 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag269 := Val;\n+      end Set_Flag269;\n+\n+      procedure Set_Flag270 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag270 := Val;\n+      end Set_Flag270;\n+\n+      procedure Set_Flag271 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag271 := Val;\n+      end Set_Flag271;\n+\n+      procedure Set_Flag272 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag272 := Val;\n+      end Set_Flag272;\n+\n+      procedure Set_Flag273 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag273 := Val;\n+      end Set_Flag273;\n+\n+      procedure Set_Flag274 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag274 := Val;\n+      end Set_Flag274;\n+\n+      procedure Set_Flag275 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag275 := Val;\n+      end Set_Flag275;\n+\n+      procedure Set_Flag276 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag276 := Val;\n+      end Set_Flag276;\n+\n+      procedure Set_Flag277 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag277 := Val;\n+      end Set_Flag277;\n+\n+      procedure Set_Flag278 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag278 := Val;\n+      end Set_Flag278;\n+\n+      procedure Set_Flag279 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag279 := Val;\n+      end Set_Flag279;\n+\n+      procedure Set_Flag280 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag280 := Val;\n+      end Set_Flag280;\n+\n+      procedure Set_Flag281 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag281 := Val;\n+      end Set_Flag281;\n+\n+      procedure Set_Flag282 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag282 := Val;\n+      end Set_Flag282;\n+\n+      procedure Set_Flag283 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag283 := Val;\n+      end Set_Flag283;\n+\n+      procedure Set_Flag284 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag284 := Val;\n+      end Set_Flag284;\n+\n+      procedure Set_Flag285 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag285 := Val;\n+      end Set_Flag285;\n+\n+      procedure Set_Flag286 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 5).Field12'Unrestricted_Access)).Flag286 := Val;\n+      end Set_Flag286;\n+\n+      procedure Set_Flag287 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).In_List := Val;\n+      end Set_Flag287;\n+\n+      procedure Set_Flag288 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Has_Aspects := Val;\n+      end Set_Flag288;\n+\n+      procedure Set_Flag289 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Rewrite_Ins := Val;\n+      end Set_Flag289;\n+\n+      procedure Set_Flag290 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Analyzed := Val;\n+      end Set_Flag290;\n+\n+      procedure Set_Flag291 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Comes_From_Source := Val;\n+      end Set_Flag291;\n+\n+      procedure Set_Flag292 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Error_Posted := Val;\n+      end Set_Flag292;\n+\n+      procedure Set_Flag293 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Flag4 := Val;\n+      end Set_Flag293;\n+\n+      procedure Set_Flag294 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Flag5 := Val;\n+      end Set_Flag294;\n+\n+      procedure Set_Flag295 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Flag6 := Val;\n+      end Set_Flag295;\n+\n+      procedure Set_Flag296 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Flag7 := Val;\n+      end Set_Flag296;\n+\n+      procedure Set_Flag297 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Flag8 := Val;\n+      end Set_Flag297;\n+\n+      procedure Set_Flag298 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Flag9 := Val;\n+      end Set_Flag298;\n+\n+      procedure Set_Flag299 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Flag10 := Val;\n+      end Set_Flag299;\n+\n+      procedure Set_Flag300 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Flag11 := Val;\n+      end Set_Flag300;\n+\n+      procedure Set_Flag301 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Flag12 := Val;\n+      end Set_Flag301;\n+\n+      procedure Set_Flag302 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Flag13 := Val;\n+      end Set_Flag302;\n+\n+      procedure Set_Flag303 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Flag14 := Val;\n+      end Set_Flag303;\n+\n+      procedure Set_Flag304 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Flag15 := Val;\n+      end Set_Flag304;\n+\n+      procedure Set_Flag305 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Flag16 := Val;\n+      end Set_Flag305;\n+\n+      procedure Set_Flag306 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Flag17 := Val;\n+      end Set_Flag306;\n+\n+      procedure Set_Flag307 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Flag18 := Val;\n+      end Set_Flag307;\n+\n+      procedure Set_Flag308 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Pflag1 := Val;\n+      end Set_Flag308;\n+\n+      procedure Set_Flag309 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Pflag2 := Val;\n+      end Set_Flag309;\n+\n+      procedure Set_Flag310 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Byte4_Ptr\n+           (Node_Kind_Ptr'\n+             (Nodes.Table (N + 5).Nkind'Unrestricted_Access)).Flag310 := Val;\n+      end Set_Flag310;\n+\n+      procedure Set_Flag311 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Byte4_Ptr\n+           (Node_Kind_Ptr'\n+             (Nodes.Table (N + 5).Nkind'Unrestricted_Access)).Flag311 := Val;\n+      end Set_Flag311;\n+\n+      procedure Set_Flag312 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Byte4_Ptr\n+           (Node_Kind_Ptr'\n+             (Nodes.Table (N + 5).Nkind'Unrestricted_Access)).Flag312 := Val;\n+      end Set_Flag312;\n+\n+      procedure Set_Flag313 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Byte4_Ptr\n+           (Node_Kind_Ptr'\n+             (Nodes.Table (N + 5).Nkind'Unrestricted_Access)).Flag313 := Val;\n+      end Set_Flag313;\n+\n+      procedure Set_Flag314 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Byte4_Ptr\n+           (Node_Kind_Ptr'\n+             (Nodes.Table (N + 5).Nkind'Unrestricted_Access)).Flag314 := Val;\n+      end Set_Flag314;\n+\n+      procedure Set_Flag315 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Byte4_Ptr\n+           (Node_Kind_Ptr'\n+             (Nodes.Table (N + 5).Nkind'Unrestricted_Access)).Flag315 := Val;\n+      end Set_Flag315;\n+\n+      procedure Set_Flag316 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Byte4_Ptr\n+           (Node_Kind_Ptr'\n+             (Nodes.Table (N + 5).Nkind'Unrestricted_Access)).Flag316 := Val;\n+      end Set_Flag316;\n+\n+      procedure Set_Flag317 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Byte4_Ptr\n+           (Node_Kind_Ptr'\n+             (Nodes.Table (N + 5).Nkind'Unrestricted_Access)).Flag317 := Val;\n+      end Set_Flag317;\n+\n       procedure Set_Node1_With_Parent (N : Node_Id; Val : Node_Id) is\n       begin\n          pragma Assert (N <= Nodes.Last);"}, {"sha": "2b616bd27967ac31e54722796a7492f13d15c7c2", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 463, "deletions": 42, "changes": 505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=0e564ab485f5db3094a2716fa79e57dcb1d181b8", "patch": "@@ -196,9 +196,9 @@ package Atree is\n    --                 entity, it is of type Entity_Kind which is defined\n    --                 in package Einfo.\n \n-   --   Flag19        235 additional flags\n+   --   Flag19        299 additional flags\n    --   ...\n-   --   Flag254\n+   --   Flag317\n \n    --   Convention    Entity convention (Convention_Id value)\n \n@@ -208,9 +208,9 @@ package Atree is\n    --   Elist6        Synonym for Field6 typed as Elist_Id (Empty = No_Elist)\n    --   Uint6         Synonym for Field6 typed as Uint (Empty = Uint_0)\n \n-   --   Similar definitions for Field7 to Field28 (and Node7-Node28,\n-   --   Elist7-Elist28, Uint7-Uint28, Ureal7-Ureal28). Note that not all these\n-   --   functions are defined, only the ones that are actually used.\n+   --   Similar definitions for Field7 to Field35 (and also Node7-Node35,\n+   --   Elist7-Elist35, Uint7-Uint35, Ureal7-Ureal35). Note that not all\n+   --   these functions are defined, only the ones that are actually used.\n \n    function Last_Node_Id return Node_Id;\n    pragma Inline (Last_Node_Id);\n@@ -334,22 +334,22 @@ package Atree is\n \n    --  Field1-5 fields are set to Empty\n \n-   --  Field6-29 fields in extended nodes are set to Empty\n+   --  Field6-35 fields in extended nodes are set to Empty\n \n    --  Parent is set to Empty\n \n    --  All Boolean flag fields are set to False\n \n-   --  Note: the value Empty is used in Field1-Field17 to indicate a null node.\n-   --  The usage varies. The common uses are to indicate absence of an\n-   --  optional clause or a completely unused Field1-17 field.\n+   --  Note: the value Empty is used in Field1-Field35 to indicate a null node.\n+   --  The usage varies. The common uses are to indicate absence of an optional\n+   --  clause or a completely unused Field1-35 field.\n \n    -------------------------------------\n    -- Use of Synonyms for Node Fields --\n    -------------------------------------\n \n    --  A subpackage Atree.Unchecked_Access provides routines for reading and\n-   --  writing the fields defined above (Field1-27, Node1-27, Flag4-254 etc).\n+   --  writing the fields defined above (Field1-35, Node1-35, Flag4-317 etc).\n    --  These unchecked access routines can be used for untyped traversals.\n    --  In addition they are used in the implementations of the Sinfo and\n    --  Einfo packages. These packages both provide logical synonyms for\n@@ -481,10 +481,9 @@ package Atree is\n    --  valid. This routine is used in conjunction with the tree rewrite\n    --  routines (see descriptions of Replace/Rewrite).\n    --\n-   --  Note that the resulting node has the same parent as the source\n-   --  node, and is thus still attached to the tree. It is valid for\n-   --  Source to be Empty, in which case Relocate_Node simply returns\n-   --  Empty as the result.\n+   --  Note that the resulting node has the same parent as the source node, and\n+   --  is thus still attached to the tree. It is valid for Source to be Empty,\n+   --  in which case Relocate_Node simply returns Empty as the result.\n \n    function Copy_Separate_Tree (Source : Node_Id) return Node_Id;\n    --  Given a node that is the root of a subtree, Copy_Separate_Tree copies\n@@ -1063,6 +1062,24 @@ package Atree is\n       function Field29 (N : Node_Id) return Union_Id;\n       pragma Inline (Field29);\n \n+      function Field30 (N : Node_Id) return Union_Id;\n+      pragma Inline (Field30);\n+\n+      function Field31 (N : Node_Id) return Union_Id;\n+      pragma Inline (Field31);\n+\n+      function Field32 (N : Node_Id) return Union_Id;\n+      pragma Inline (Field32);\n+\n+      function Field33 (N : Node_Id) return Union_Id;\n+      pragma Inline (Field33);\n+\n+      function Field34 (N : Node_Id) return Union_Id;\n+      pragma Inline (Field34);\n+\n+      function Field35 (N : Node_Id) return Union_Id;\n+      pragma Inline (Field35);\n+\n       function Node1 (N : Node_Id) return Node_Id;\n       pragma Inline (Node1);\n \n@@ -2043,6 +2060,195 @@ package Atree is\n       function Flag254 (N : Node_Id) return Boolean;\n       pragma Inline (Flag254);\n \n+      function Flag255 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag255);\n+\n+      function Flag256 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag256);\n+\n+      function Flag257 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag257);\n+\n+      function Flag258 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag258);\n+\n+      function Flag259 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag259);\n+\n+      function Flag260 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag260);\n+\n+      function Flag261 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag261);\n+\n+      function Flag262 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag262);\n+\n+      function Flag263 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag263);\n+\n+      function Flag264 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag264);\n+\n+      function Flag265 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag265);\n+\n+      function Flag266 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag266);\n+\n+      function Flag267 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag267);\n+\n+      function Flag268 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag268);\n+\n+      function Flag269 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag269);\n+\n+      function Flag270 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag270);\n+\n+      function Flag271 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag271);\n+\n+      function Flag272 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag272);\n+\n+      function Flag273 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag273);\n+\n+      function Flag274 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag274);\n+\n+      function Flag275 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag275);\n+\n+      function Flag276 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag276);\n+\n+      function Flag277 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag277);\n+\n+      function Flag278 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag278);\n+\n+      function Flag279 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag279);\n+\n+      function Flag280 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag280);\n+\n+      function Flag281 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag281);\n+\n+      function Flag282 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag282);\n+\n+      function Flag283 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag283);\n+\n+      function Flag284 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag284);\n+\n+      function Flag285 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag285);\n+\n+      function Flag286 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag286);\n+\n+      function Flag287 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag287);\n+\n+      function Flag288 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag288);\n+\n+      function Flag289 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag289);\n+\n+      function Flag290 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag290);\n+\n+      function Flag291 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag291);\n+\n+      function Flag292 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag292);\n+\n+      function Flag293 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag293);\n+\n+      function Flag294 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag294);\n+\n+      function Flag295 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag295);\n+\n+      function Flag296 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag296);\n+\n+      function Flag297 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag297);\n+\n+      function Flag298 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag298);\n+\n+      function Flag299 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag299);\n+\n+      function Flag300 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag300);\n+\n+      function Flag301 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag301);\n+\n+      function Flag302 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag302);\n+\n+      function Flag303 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag303);\n+\n+      function Flag304 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag304);\n+\n+      function Flag305 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag305);\n+\n+      function Flag306 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag306);\n+\n+      function Flag307 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag307);\n+\n+      function Flag308 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag308);\n+\n+      function Flag309 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag309);\n+\n+      function Flag310 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag310);\n+\n+      function Flag311 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag311);\n+\n+      function Flag312 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag312);\n+\n+      function Flag313 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag313);\n+\n+      function Flag314 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag314);\n+\n+      function Flag315 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag315);\n+\n+      function Flag316 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag316);\n+\n+      function Flag317 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag317);\n+\n       --  Procedures to set value of indicated field\n \n       procedure Set_Nkind (N : Node_Id; Val : Node_Kind);\n@@ -2135,6 +2341,24 @@ package Atree is\n       procedure Set_Field29 (N : Node_Id; Val : Union_Id);\n       pragma Inline (Set_Field29);\n \n+      procedure Set_Field30 (N : Node_Id; Val : Union_Id);\n+      pragma Inline (Set_Field30);\n+\n+      procedure Set_Field31 (N : Node_Id; Val : Union_Id);\n+      pragma Inline (Set_Field31);\n+\n+      procedure Set_Field32 (N : Node_Id; Val : Union_Id);\n+      pragma Inline (Set_Field32);\n+\n+      procedure Set_Field33 (N : Node_Id; Val : Union_Id);\n+      pragma Inline (Set_Field33);\n+\n+      procedure Set_Field34 (N : Node_Id; Val : Union_Id);\n+      pragma Inline (Set_Field34);\n+\n+      procedure Set_Field35 (N : Node_Id; Val : Union_Id);\n+      pragma Inline (Set_Field35);\n+\n       procedure Set_Node1 (N : Node_Id; Val : Node_Id);\n       pragma Inline (Set_Node1);\n \n@@ -3110,6 +3334,195 @@ package Atree is\n       procedure Set_Flag254 (N : Node_Id; Val : Boolean);\n       pragma Inline (Set_Flag254);\n \n+      procedure Set_Flag255 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag255);\n+\n+      procedure Set_Flag256 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag256);\n+\n+      procedure Set_Flag257 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag257);\n+\n+      procedure Set_Flag258 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag258);\n+\n+      procedure Set_Flag259 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag259);\n+\n+      procedure Set_Flag260 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag260);\n+\n+      procedure Set_Flag261 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag261);\n+\n+      procedure Set_Flag262 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag262);\n+\n+      procedure Set_Flag263 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag263);\n+\n+      procedure Set_Flag264 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag264);\n+\n+      procedure Set_Flag265 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag265);\n+\n+      procedure Set_Flag266 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag266);\n+\n+      procedure Set_Flag267 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag267);\n+\n+      procedure Set_Flag268 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag268);\n+\n+      procedure Set_Flag269 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag269);\n+\n+      procedure Set_Flag270 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag270);\n+\n+      procedure Set_Flag271 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag271);\n+\n+      procedure Set_Flag272 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag272);\n+\n+      procedure Set_Flag273 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag273);\n+\n+      procedure Set_Flag274 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag274);\n+\n+      procedure Set_Flag275 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag275);\n+\n+      procedure Set_Flag276 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag276);\n+\n+      procedure Set_Flag277 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag277);\n+\n+      procedure Set_Flag278 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag278);\n+\n+      procedure Set_Flag279 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag279);\n+\n+      procedure Set_Flag280 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag280);\n+\n+      procedure Set_Flag281 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag281);\n+\n+      procedure Set_Flag282 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag282);\n+\n+      procedure Set_Flag283 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag283);\n+\n+      procedure Set_Flag284 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag284);\n+\n+      procedure Set_Flag285 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag285);\n+\n+      procedure Set_Flag286 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag286);\n+\n+      procedure Set_Flag287 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag287);\n+\n+      procedure Set_Flag288 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag288);\n+\n+      procedure Set_Flag289 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag289);\n+\n+      procedure Set_Flag290 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag290);\n+\n+      procedure Set_Flag291 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag291);\n+\n+      procedure Set_Flag292 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag292);\n+\n+      procedure Set_Flag293 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag293);\n+\n+      procedure Set_Flag294 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag294);\n+\n+      procedure Set_Flag295 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag295);\n+\n+      procedure Set_Flag296 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag296);\n+\n+      procedure Set_Flag297 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag297);\n+\n+      procedure Set_Flag298 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag298);\n+\n+      procedure Set_Flag299 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag299);\n+\n+      procedure Set_Flag300 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag300);\n+\n+      procedure Set_Flag301 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag301);\n+\n+      procedure Set_Flag302 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag302);\n+\n+      procedure Set_Flag303 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag303);\n+\n+      procedure Set_Flag304 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag304);\n+\n+      procedure Set_Flag305 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag305);\n+\n+      procedure Set_Flag306 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag306);\n+\n+      procedure Set_Flag307 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag307);\n+\n+      procedure Set_Flag308 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag308);\n+\n+      procedure Set_Flag309 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag309);\n+\n+      procedure Set_Flag310 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag310);\n+\n+      procedure Set_Flag311 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag311);\n+\n+      procedure Set_Flag312 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag312);\n+\n+      procedure Set_Flag313 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag313);\n+\n+      procedure Set_Flag314 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag314);\n+\n+      procedure Set_Flag315 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag315);\n+\n+      procedure Set_Flag316 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag316);\n+\n+      procedure Set_Flag317 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag317);\n+\n       --  The following versions of Set_Noden also set the parent pointer of\n       --  the referenced node if it is not Empty.\n \n@@ -3226,32 +3639,32 @@ package Atree is\n          Flag18 : Boolean;\n          --  The eighteen flags for a normal node\n \n-         --  The above fields are used as follows in components 2-5 of\n+         --  The above fields are used as follows in components 2-6 of\n          --  an extended node entry.\n \n-         --    In_List              used as  Flag19, Flag40, Flag129, Flag216\n-         --    Has_Aspects          used as  Flag20, Flag41, Flag130, Flag217\n-         --    Rewrite_Ins          used as  Flag21, Flag42, Flag131, Flag218\n-         --    Analyzed             used as  Flag22, Flag43, Flag132, Flag219\n-         --    Comes_From_Source    used as  Flag23, Flag44, Flag133, Flag220\n-         --    Error_Posted         used as  Flag24, Flag45, Flag134, Flag221\n-         --    Flag4                used as  Flag25, Flag46, Flag135, Flag222\n-         --    Flag5                used as  Flag26, Flag47, Flag136, Flag223\n-         --    Flag6                used as  Flag27, Flag48, Flag137, Flag224\n-         --    Flag7                used as  Flag28, Flag49, Flag138, Flag225\n-         --    Flag8                used as  Flag29, Flag50, Flag139, Flag226\n-         --    Flag9                used as  Flag30, Flag51, Flag140, Flag227\n-         --    Flag10               used as  Flag31, Flag52, Flag141, Flag228\n-         --    Flag11               used as  Flag32, Flag53, Flag142, Flag229\n-         --    Flag12               used as  Flag33, Flag54, Flag143, Flag230\n-         --    Flag13               used as  Flag34, Flag55, Flag144, Flag231\n-         --    Flag14               used as  Flag35, Flag56, Flag145, Flag232\n-         --    Flag15               used as  Flag36, Flag57, Flag146, Flag233\n-         --    Flag16               used as  Flag37, Flag58, Flag147, Flag234\n-         --    Flag17               used as  Flag38, Flag59, Flag148, Flag235\n-         --    Flag18               used as  Flag39, Flag60, Flag149, Flag236\n-         --    Pflag1               used as  Flag61, Flag62, Flag150, Flag237\n-         --    Pflag2               used as  Flag63, Flag64, Flag151, Flag238\n+         --    In_List           used as Flag19,Flag40,Flag129,Flag216,Flag287\n+         --    Has_Aspects       used as Flag20,Flag41,Flag130,Flag217,Flag288\n+         --    Rewrite_Ins       used as Flag21,Flag42,Flag131,Flag218,Flag289\n+         --    Analyzed          used as Flag22,Flag43,Flag132,Flag219,Flag290\n+         --    Comes_From_Source used as Flag23,Flag44,Flag133,Flag220,Flag291\n+         --    Error_Posted      used as Flag24,Flag45,Flag134,Flag221,Flag292\n+         --    Flag4             used as Flag25,Flag46,Flag135,Flag222,Flag293\n+         --    Flag5             used as Flag26,Flag47,Flag136,Flag223,Flag294\n+         --    Flag6             used as Flag27,Flag48,Flag137,Flag224,Flag295\n+         --    Flag7             used as Flag28,Flag49,Flag138,Flag225,Flag296\n+         --    Flag8             used as Flag29,Flag50,Flag139,Flag226,Flag297\n+         --    Flag9             used as Flag30,Flag51,Flag140,Flag227,Flag298\n+         --    Flag10            used as Flag31,Flag52,Flag141,Flag228,Flag299\n+         --    Flag11            used as Flag32,Flag53,Flag142,Flag229,Flag300\n+         --    Flag12            used as Flag33,Flag54,Flag143,Flag230,Flag301\n+         --    Flag13            used as Flag34,Flag55,Flag144,Flag231,Flag302\n+         --    Flag14            used as Flag35,Flag56,Flag145,Flag232,Flag303\n+         --    Flag15            used as Flag36,Flag57,Flag146,Flag233,Flag304\n+         --    Flag16            used as Flag37,Flag58,Flag147,Flag234,Flag305\n+         --    Flag17            used as Flag38,Flag59,Flag148,Flag235,Flag306\n+         --    Flag18            used as Flag39,Flag60,Flag149,Flag236,Flag307\n+         --    Pflag1            used as Flag61,Flag62,Flag150,Flag237,Flag308\n+         --    Pflag2            used as Flag63,Flag64,Flag151,Flag238,Flag309\n \n          Nkind : Node_Kind;\n          --  For a non-extended node, or the initial section of an extended\n@@ -3262,6 +3675,7 @@ package Atree is\n          --     Third entry:  holds 8 additional flags (Flag65-Flag72)\n          --     Fourth entry: holds 8 additional flags (Flag239-246)\n          --     Fifth entry:  holds 8 additional flags (Flag247-254)\n+         --     Sixth entry:  holds 8 additional flags (Flag310-317)\n \n          --  Now finally (on an 32-bit boundary!) comes the variant part\n \n@@ -3327,6 +3741,13 @@ package Atree is\n             --    Field6-11      Holds Field24-Field29\n             --    Field12        Holds Flag184-Flag215\n \n+            --  In the sixth component, the extension format as described\n+            --  above is used to hold additional general fields and flags\n+            --  as follows:\n+\n+            --    Field6-11      Holds Field30-Field35\n+            --    Field12        Holds Flag255-Flag286\n+\n          end case;\n       end record;\n \n@@ -3380,10 +3801,10 @@ package Atree is\n          Field5            => Empty_List_Or_Node);\n \n       --  Default value used to initialize node extensions (i.e. the second\n-      --  and third and fourth components of an extended node). Note we are\n-      --  cheating a bit here when it comes to Node12, which really holds\n-      --  flags an (for the third component), the convention. But it works\n-      --  because Empty, False, Convention_Ada, all happen to be all zero bits.\n+      --  through sixth components of an extended node). Note we are cheating\n+      --  a bit here when it comes to Node12, which really holds flags and (for\n+      --  the third component), the convention. But it works because Empty,\n+      --  False, Convention_Ada, all happen to be all zero bits.\n \n       Default_Node_Extension : constant Node_Record := (\n          Is_Extension      => True,"}, {"sha": "a0ca4c61a43c356fbcdf2b334d1d64975cb9b2c7", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=0e564ab485f5db3094a2716fa79e57dcb1d181b8", "patch": "@@ -6239,6 +6239,8 @@ package body Checks is\n \n       declare\n          DRC : constant Boolean := Do_Range_Check (Exp);\n+         PV  : Node_Id;\n+         CE  : Node_Id;\n \n       begin\n          Set_Do_Range_Check (Exp, False);\n@@ -6251,22 +6253,43 @@ package body Checks is\n             Force_Evaluation (Exp, Name_Req => True);\n          end if;\n \n-         --  Insert the validity check. Note that we do this with validity\n-         --  checks turned off, to avoid recursion, we do not want validity\n-         --  checks on the validity checking code itself!\n+         --  Build the prefix for the 'Valid call\n+\n+         PV := Duplicate_Subexpr_No_Checks (Exp, Name_Req => True);\n+\n+         --  A rather specialized kludge. If PV is an analyzed expression\n+         --  which is an indexed component of a packed array that has not\n+         --  been properly expanded, turn off its Analyzed flag to make sure\n+         --  it gets properly reexpanded.\n+\n+         --  The reason this arises is that Duplicate_Subexpr_No_Checks did\n+         --  an analyze with the old parent pointer. This may point e.g. to\n+         --  a subprogram call, which deactivates this expansion.\n+\n+         if Analyzed (PV)\n+           and then Nkind (PV) = N_Indexed_Component\n+           and then Present (Packed_Array_Type (Etype (Prefix (PV))))\n+         then\n+            Set_Analyzed (PV, False);\n+         end if;\n+\n+         --  Build the raise CE node to check for validity\n \n-         Insert_Action\n-           (Expr,\n+         CE :=\n             Make_Raise_Constraint_Error (Loc,\n               Condition =>\n                 Make_Op_Not (Loc,\n                   Right_Opnd =>\n                     Make_Attribute_Reference (Loc,\n-                      Prefix =>\n-                        Duplicate_Subexpr_No_Checks (Exp, Name_Req => True),\n+                      Prefix         => PV,\n                       Attribute_Name => Name_Valid)),\n-              Reason => CE_Invalid_Data),\n-            Suppress => Validity_Check);\n+              Reason => CE_Invalid_Data);\n+\n+         --  Insert the validity check. Note that we do this with validity\n+         --  checks turned off, to avoid recursion, we do not want validity\n+         --  checks on the validity checking code itself!\n+\n+         Insert_Action (Expr, CE, Suppress => Validity_Check);\n \n          --  If the expression is a reference to an element of a bit-packed\n          --  array, then it is rewritten as a renaming declaration. If the"}, {"sha": "ef4f191ffd10686202fbc7bd953e83303ab1a397", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=0e564ab485f5db3094a2716fa79e57dcb1d181b8", "patch": "@@ -244,6 +244,18 @@ package body Einfo is\n \n    --    Subprograms_For_Type            Node29\n \n+   --    (unused)                        Node30\n+\n+   --    (unused)                        Node31\n+\n+   --    (unused)                        Node32\n+\n+   --    (unused)                        Node33\n+\n+   --    (unused)                        Node34\n+\n+   --    (unused)                        Node35\n+\n    ---------------------------------------------\n    -- Usage of Flags in Defining Entity Nodes --\n    ---------------------------------------------\n@@ -253,7 +265,7 @@ package body Einfo is\n    --  sense for them to be set true for certain subsets of entity kinds. See\n    --  the spec of Einfo for further details.\n \n-   --  Note: Flag1-Flag3 are absent from this list, for historical reasons\n+   --  Note: Flag1-Flag3 are not used, for historical reasons\n \n    --    Is_Frozen                       Flag4\n    --    Has_Discriminants               Flag5\n@@ -533,6 +545,76 @@ package body Einfo is\n \n    --    (unused)                        Flag201\n \n+   --    (unused)                        Flag255\n+   --    (unused)                        Flag256\n+   --    (unused)                        Flag257\n+   --    (unused)                        Flag258\n+   --    (unused)                        Flag259\n+   --    (unused)                        Flag260\n+\n+   --    (unused)                        Flag261\n+   --    (unused)                        Flag262\n+   --    (unused)                        Flag263\n+   --    (unused)                        Flag264\n+   --    (unused)                        Flag265\n+   --    (unused)                        Flag266\n+   --    (unused)                        Flag267\n+   --    (unused)                        Flag268\n+   --    (unused)                        Flag269\n+   --    (unused)                        Flag270\n+\n+   --    (unused)                        Flag271\n+   --    (unused)                        Flag272\n+   --    (unused)                        Flag273\n+   --    (unused)                        Flag274\n+   --    (unused)                        Flag275\n+   --    (unused)                        Flag276\n+   --    (unused)                        Flag277\n+   --    (unused)                        Flag278\n+   --    (unused)                        Flag279\n+   --    (unused)                        Flag280\n+\n+   --    (unused)                        Flag281\n+   --    (unused)                        Flag282\n+   --    (unused)                        Flag283\n+   --    (unused)                        Flag284\n+   --    (unused)                        Flag285\n+   --    (unused)                        Flag286\n+   --    (unused)                        Flag287\n+   --    (unused)                        Flag288\n+   --    (unused)                        Flag289\n+   --    (unused)                        Flag290\n+\n+   --    (unused)                        Flag291\n+   --    (unused)                        Flag292\n+   --    (unused)                        Flag293\n+   --    (unused)                        Flag294\n+   --    (unused)                        Flag295\n+   --    (unused)                        Flag296\n+   --    (unused)                        Flag297\n+   --    (unused)                        Flag298\n+   --    (unused)                        Flag299\n+   --    (unused)                        Flag300\n+\n+   --    (unused)                        Flag301\n+   --    (unused)                        Flag302\n+   --    (unused)                        Flag303\n+   --    (unused)                        Flag304\n+   --    (unused)                        Flag305\n+   --    (unused)                        Flag306\n+   --    (unused)                        Flag307\n+   --    (unused)                        Flag308\n+   --    (unused)                        Flag309\n+   --    (unused)                        Flag310\n+\n+   --    (unused)                        Flag311\n+   --    (unused)                        Flag312\n+   --    (unused)                        Flag313\n+   --    (unused)                        Flag314\n+   --    (unused)                        Flag315\n+   --    (unused)                        Flag316\n+   --    (unused)                        Flag317\n+\n    -----------------------\n    -- Local subprograms --\n    -----------------------"}, {"sha": "1147724c91e3624a856f175cf48fcbeaf6c650cb", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=0e564ab485f5db3094a2716fa79e57dcb1d181b8", "patch": "@@ -5404,7 +5404,6 @@ package body Exp_Attr is\n                Ftp : Entity_Id;\n \n             begin\n-\n                case Float_Rep (Btyp) is\n \n                   --  For vax fpt types, call appropriate routine in special"}, {"sha": "70e2fcdf4c963e1761d635d879a71c0343e96a2c", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=0e564ab485f5db3094a2716fa79e57dcb1d181b8", "patch": "@@ -3233,6 +3233,7 @@ package body Exp_Ch4 is\n                    Prefix         =>\n                      Duplicate_Subexpr (Opnd, Name_Req => True),\n                    Attribute_Name => Name_First);\n+               Set_Parent (Opnd_Low_Bound (NN), Opnd);\n \n                --  Capture last operand bounds if result could be null\n \n@@ -3243,13 +3244,15 @@ package body Exp_Ch4 is\n                         Prefix         =>\n                           Duplicate_Subexpr (Opnd, Name_Req => True),\n                         Attribute_Name => Name_First));\n+                  Set_Parent (Last_Opnd_Low_Bound, Opnd);\n \n                   Last_Opnd_High_Bound :=\n                     Convert_To (Ityp,\n                       Make_Attribute_Reference (Loc,\n                         Prefix         =>\n                           Duplicate_Subexpr (Opnd, Name_Req => True),\n                         Attribute_Name => Name_Last));\n+                  Set_Parent (Last_Opnd_High_Bound, Opnd);\n                end if;\n \n                --  Capture length of operand in entity"}, {"sha": "c38ed030fb01b5e2930874f49c601642e7275ec3", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 77, "deletions": 102, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=0e564ab485f5db3094a2716fa79e57dcb1d181b8", "patch": "@@ -444,9 +444,7 @@ package body Exp_Util is\n \n          --  Handle private types\n \n-         if Is_Private_Type (Utyp)\n-           and then Present (Full_View (Utyp))\n-         then\n+         if Is_Private_Type (Utyp) and then Present (Full_View (Utyp)) then\n             Utyp := Full_View (Utyp);\n          end if;\n \n@@ -750,9 +748,7 @@ package body Exp_Util is\n             --  Primitive Finalize_Address is never generated in CodePeer mode\n             --  since it contains an Unchecked_Conversion.\n \n-            if Needs_Finalization (Desig_Typ)\n-              and then not CodePeer_Mode\n-            then\n+            if Needs_Finalization (Desig_Typ) and then not CodePeer_Mode then\n                Fin_Addr_Id := Find_Finalize_Address (Desig_Typ);\n                pragma Assert (Present (Fin_Addr_Id));\n \n@@ -1588,18 +1584,15 @@ package body Exp_Util is\n \n       --  It is only array and record types that cause trouble\n \n-      if not Is_Record_Type (UT)\n-        and then not Is_Array_Type (UT)\n-      then\n+      if not Is_Record_Type (UT) and then not Is_Array_Type (UT) then\n          return False;\n \n       --  If we know that we have a small (64 bits or less) record or small\n       --  bit-packed array, then everything is fine, since the back end can\n       --  handle these cases correctly.\n \n       elsif Esize (Comp) <= 64\n-        and then (Is_Record_Type (UT)\n-                   or else Is_Bit_Packed_Array (UT))\n+        and then (Is_Record_Type (UT) or else Is_Bit_Packed_Array (UT))\n       then\n          return False;\n \n@@ -1740,7 +1733,6 @@ package body Exp_Util is\n       Name_Req : Boolean := False) return Node_Id\n    is\n       New_Exp : Node_Id;\n-\n    begin\n       Remove_Side_Effects (Exp, Name_Req);\n       New_Exp := New_Copy_Tree (Exp);\n@@ -1775,9 +1767,7 @@ package body Exp_Util is\n       --  An itype reference must only be created if this is a local itype, so\n       --  that gigi can elaborate it on the proper objstack.\n \n-      if Is_Itype (Typ)\n-        and then Scope (Typ) = Current_Scope\n-      then\n+      if Is_Itype (Typ) and then Scope (Typ) = Current_Scope then\n          IR := Make_Itype_Reference (Sloc (N));\n          Set_Itype (IR, Typ);\n          Insert_Action (N, IR);\n@@ -1985,8 +1975,7 @@ package body Exp_Util is\n       --  standard string types and more generally arrays of characters.\n \n       if not Expander_Active\n-        and then (No (Etype (Exp))\n-                   or else not Is_String_Type (Etype (Exp)))\n+        and then (No (Etype (Exp)) or else not Is_String_Type (Etype (Exp)))\n       then\n          return;\n       end if;\n@@ -2179,9 +2168,7 @@ package body Exp_Util is\n \n       --  Handle private types\n \n-      if Has_Private_Declaration (Typ)\n-        and then Present (Full_View (Typ))\n-      then\n+      if Has_Private_Declaration (Typ) and then Present (Full_View (Typ)) then\n          Typ := Full_View (Typ);\n       end if;\n \n@@ -2309,9 +2296,7 @@ package body Exp_Util is\n \n       --  Handle private types\n \n-      if Has_Private_Declaration (Typ)\n-        and then Present (Full_View (Typ))\n-      then\n+      if Has_Private_Declaration (Typ) and then Present (Full_View (Typ)) then\n          Typ := Full_View (Typ);\n       end if;\n \n@@ -2374,7 +2359,7 @@ package body Exp_Util is\n          exit when Chars (Op) = Name\n            and then\n              (Name /= Name_Op_Eq\n-                or else Etype (First_Formal (Op)) = Etype (Last_Formal (Op)));\n+               or else Etype (First_Formal (Op)) = Etype (Last_Formal (Op)));\n \n          Next_Elmt (Prim);\n \n@@ -2446,10 +2431,7 @@ package body Exp_Util is\n    begin\n       S := Scop;\n       while Present (S) loop\n-         if (Ekind (S) = E_Entry\n-               or else Ekind (S) = E_Entry_Family\n-               or else Ekind (S) = E_Function\n-               or else Ekind (S) = E_Procedure)\n+         if Ekind_In (S, E_Entry, E_Entry_Family, E_Function, E_Procedure)\n            and then Present (Protection_Object (S))\n          then\n             return Protection_Object (S);\n@@ -2634,9 +2616,8 @@ package body Exp_Util is\n \n          --  Deal with AND THEN and AND cases\n \n-         if Nkind (Cond) = N_And_Then\n-           or else Nkind (Cond) = N_Op_And\n-         then\n+         if Nkind_In (Cond, N_And_Then, N_Op_And) then\n+\n             --  Don't ever try to invert a condition that is of the form of an\n             --  AND or AND THEN (since we are not doing sufficiently general\n             --  processing to allow this).\n@@ -2715,9 +2696,7 @@ package body Exp_Util is\n             --  reference had said var = True.\n \n          else\n-            if Is_Entity_Name (Cond)\n-              and then Ent = Entity (Cond)\n-            then\n+            if Is_Entity_Name (Cond) and then Ent = Entity (Cond) then\n                Val := New_Occurrence_Of (Standard_True, Sloc (Cond));\n \n                if Sens = False then\n@@ -2947,9 +2926,7 @@ package body Exp_Util is\n       T    : constant Entity_Id := Etype (E);\n \n    begin\n-      if Has_Per_Object_Constraint (E)\n-        and then Has_Discriminants (T)\n-      then\n+      if Has_Per_Object_Constraint (E) and then Has_Discriminants (T) then\n          Disc := First_Discriminant (T);\n          while Present (Disc) loop\n             if Is_Access_Type (Etype (Disc)) then\n@@ -3437,9 +3414,7 @@ package body Exp_Util is\n                --  actions should be inserted outside the complete record\n                --  declaration.\n \n-               elsif Nkind (Parent (P)) = N_Variant\n-                 or else Nkind (Parent (P)) = N_Record_Definition\n-               then\n+               elsif Nkind_In (Parent (P), N_Variant, N_Record_Definition) then\n                   null;\n \n                --  Do not insert freeze nodes within the loop generated for\n@@ -3784,9 +3759,7 @@ package body Exp_Util is\n       Ins_Actions : List_Id)\n    is\n    begin\n-      if Scope_Is_Transient\n-        and then Assoc_Node = Node_To_Be_Wrapped\n-      then\n+      if Scope_Is_Transient and then Assoc_Node = Node_To_Be_Wrapped then\n          Store_After_Actions_In_Scope (Ins_Actions);\n       else\n          Insert_List_After_And_Analyze (Assoc_Node, Ins_Actions);\n@@ -3846,9 +3819,7 @@ package body Exp_Util is\n \n    begin\n       S := Current_Scope;\n-      while Present (S)\n-        and then S /= Standard_Standard\n-      loop\n+      while Present (S) and then S /= Standard_Standard loop\n          if Is_Init_Proc (S) then\n             return True;\n          else\n@@ -4139,7 +4110,7 @@ package body Exp_Util is\n                   Next (Param);\n                end loop;\n \n-               return Access_OK and then Alloc_OK;\n+               return Access_OK and Alloc_OK;\n             end;\n          end if;\n \n@@ -4235,9 +4206,7 @@ package body Exp_Util is\n             elsif Nkind (Stmt) = N_Object_Renaming_Declaration then\n                Ren_Obj := Find_Renamed_Object (Stmt);\n \n-               if Present (Ren_Obj)\n-                 and then Ren_Obj = Trans_Id\n-               then\n+               if Present (Ren_Obj) and then Ren_Obj = Trans_Id then\n                   return True;\n                end if;\n             end if;\n@@ -4439,8 +4408,7 @@ package body Exp_Util is\n \n    function Is_Library_Level_Tagged_Type (Typ : Entity_Id) return Boolean is\n    begin\n-      return Is_Tagged_Type (Typ)\n-        and then Is_Library_Level_Entity (Typ);\n+      return Is_Tagged_Type (Typ) and then Is_Library_Level_Entity (Typ);\n    end Is_Library_Level_Tagged_Type;\n \n    --------------------------\n@@ -4700,7 +4668,7 @@ package body Exp_Util is\n \n                if Known_Alignment (Ptyp)\n                  and then (Unknown_Alignment (Styp)\n-                             or else Alignment (Styp) > Alignment (Ptyp))\n+                            or else Alignment (Styp) > Alignment (Ptyp))\n                then\n                   return True;\n                end if;\n@@ -4776,10 +4744,7 @@ package body Exp_Util is\n          return Is_Ref_To_Bit_Packed_Array (Renamed_Object (Entity (N)));\n       end if;\n \n-      if Nkind (N) = N_Indexed_Component\n-           or else\n-         Nkind (N) = N_Selected_Component\n-      then\n+      if Nkind_In (N, N_Indexed_Component, N_Selected_Component) then\n          if Is_Bit_Packed_Array (Etype (Prefix (N))) then\n             Result := True;\n          else\n@@ -4821,10 +4786,7 @@ package body Exp_Util is\n       then\n          return True;\n \n-      elsif Nkind (N) = N_Indexed_Component\n-           or else\n-         Nkind (N) = N_Selected_Component\n-      then\n+      elsif Nkind_In (N, N_Indexed_Component, N_Selected_Component) then\n          return Is_Ref_To_Bit_Packed_Slice (Prefix (N));\n \n       else\n@@ -4971,9 +4933,9 @@ package body Exp_Util is\n \n       elsif Nkind_In (N, N_Indexed_Component, N_Selected_Component) then\n          if (Is_Entity_Name (Prefix (N))\n-               and then Has_Volatile_Components (Entity (Prefix (N))))\n+              and then Has_Volatile_Components (Entity (Prefix (N))))\n            or else (Present (Etype (Prefix (N)))\n-                      and then Has_Volatile_Components (Etype (Prefix (N))))\n+                     and then Has_Volatile_Components (Etype (Prefix (N))))\n          then\n             return True;\n          else\n@@ -4995,9 +4957,9 @@ package body Exp_Util is\n         and then (Nkind (N) = N_Slice\n                     or else\n                       (Nkind (N) = N_Identifier\n-                         and then Present (Renamed_Object (Entity (N)))\n-                         and then Nkind (Renamed_Object (Entity (N)))\n-                                    = N_Slice));\n+                        and then Present (Renamed_Object (Entity (N)))\n+                        and then Nkind (Renamed_Object (Entity (N))) =\n+                                                                 N_Slice));\n    end Is_VM_By_Copy_Actual;\n \n    --------------------\n@@ -5031,7 +4993,7 @@ package body Exp_Util is\n                     and then\n                       (In_Instance\n                         or else (Present (Entity (C))\n-                                   and then Has_Warnings_Off (Entity (C))))\n+                                  and then Has_Warnings_Off (Entity (C))))\n                   then\n                      W := False;\n                   end if;\n@@ -5137,15 +5099,12 @@ package body Exp_Util is\n \n    function Known_Non_Negative (Opnd : Node_Id) return Boolean is\n    begin\n-      if Is_OK_Static_Expression (Opnd)\n-        and then Expr_Value (Opnd) >= 0\n-      then\n+      if Is_OK_Static_Expression (Opnd) and then Expr_Value (Opnd) >= 0 then\n          return True;\n \n       else\n          declare\n             Lo : constant Node_Id := Type_Low_Bound (Etype (Opnd));\n-\n          begin\n             return\n               Is_OK_Static_Expression (Lo) and then Expr_Value (Lo) >= 0;\n@@ -5751,9 +5710,7 @@ package body Exp_Util is\n       elsif Esize (Typ) /= 0 and then Esize (Typ) <= 256 then\n          return False;\n \n-      elsif Is_Array_Type (Typ)\n-        and then Present (Packed_Array_Type (Typ))\n-      then\n+      elsif Is_Array_Type (Typ) and then Present (Packed_Array_Type (Typ)) then\n          return May_Generate_Large_Temp (Packed_Array_Type (Typ));\n \n       --  We could do more here to find other small types ???\n@@ -5842,8 +5799,8 @@ package body Exp_Util is\n              or else Has_Some_Controlled_Component (T)\n              or else\n                (Is_Concurrent_Type (T)\n-                  and then Present (Corresponding_Record_Type (T))\n-                  and then Needs_Finalization (Corresponding_Record_Type (T)));\n+                 and then Present (Corresponding_Record_Type (T))\n+                 and then Needs_Finalization (Corresponding_Record_Type (T)));\n       end if;\n    end Needs_Finalization;\n \n@@ -5885,7 +5842,7 @@ package body Exp_Util is\n         or else Is_Access_Type (Typ)\n         or else\n           (Is_Bit_Packed_Array (Typ)\n-             and then Is_Modular_Integer_Type (Packed_Array_Type (Typ)))\n+            and then Is_Modular_Integer_Type (Packed_Array_Type (Typ)))\n       then\n          return False;\n \n@@ -6519,7 +6476,32 @@ package body Exp_Util is\n            and then Is_Renaming_Of_Object (Entity (Original_Node (N)))\n            and then Ekind (Entity (Original_Node (N))) /= E_Constant\n          then\n-            return False;\n+            declare\n+               RO : constant Node_Id :=\n+                      Renamed_Object (Entity (Original_Node (N)));\n+\n+            begin\n+               --  If the renamed object is an indexed component, or an\n+               --  explicit dereference, then the designated object could\n+               --  be modified by an assignment.\n+\n+               if Nkind_In (RO, N_Indexed_Component,\n+                                N_Explicit_Dereference)\n+               then\n+                  return False;\n+\n+               --  A selected component must have a safe prefix\n+\n+               elsif Nkind (RO) = N_Selected_Component then\n+                  return Safe_Prefixed_Reference (RO);\n+\n+               --  In all other cases, designated object cannot be changed so\n+               --  we are side effect free.\n+\n+               else\n+                  return True;\n+               end if;\n+            end;\n \n          --  Remove_Side_Effects generates an object renaming declaration to\n          --  capture the expression of a class-wide expression. In VM targets\n@@ -6708,9 +6690,7 @@ package body Exp_Util is\n          elsif Is_Entity_Name (N) then\n             return Ekind (Entity (N)) = E_In_Parameter;\n \n-         elsif Nkind (N) = N_Indexed_Component\n-           or else Nkind (N) = N_Selected_Component\n-         then\n+         elsif Nkind_In (N, N_Indexed_Component, N_Selected_Component) then\n             return Within_In_Parameter (Prefix (N));\n \n          else\n@@ -6757,9 +6737,9 @@ package body Exp_Util is\n \n       if Is_Elementary_Type (Exp_Type)\n         and then (Variable_Ref\n-                   or else Nkind (Exp) = N_Function_Call\n-                   or else Nkind (Exp) = N_Attribute_Reference\n-                   or else Nkind (Exp) = N_Allocator\n+                   or else Nkind_In (Exp, N_Function_Call,\n+                                          N_Attribute_Reference,\n+                                          N_Allocator)\n                    or else Nkind (Exp) in N_Op\n                    or else (not Name_Req and then Is_Volatile_Reference (Exp)))\n       then\n@@ -6918,8 +6898,7 @@ package body Exp_Util is\n          --  by the expression it renames, which would defeat the purpose of\n          --  removing the side-effect.\n \n-         if (Nkind (Exp) = N_Selected_Component\n-              or else Nkind (Exp) = N_Indexed_Component)\n+         if Nkind_In (Exp, N_Selected_Component, N_Indexed_Component)\n            and then Has_Non_Standard_Rep (Etype (Prefix (Exp)))\n          then\n             null;\n@@ -6933,9 +6912,7 @@ package body Exp_Util is\n          --  An expression which is in Alfa mode is considered side effect free\n          --  if the resulting value is captured by a variable or a constant.\n \n-         if Alfa_Mode\n-           and then Nkind (Parent (Exp)) = N_Object_Declaration\n-         then\n+         if Alfa_Mode and then Nkind (Parent (Exp)) = N_Object_Declaration then\n             goto Leave;\n          end if;\n \n@@ -7079,7 +7056,7 @@ package body Exp_Util is\n    begin\n       return Is_Scalar_Type (UT)\n         or else (Is_Bit_Packed_Array (UT)\n-                   and then Is_Scalar_Type (Packed_Array_Type (UT)));\n+                  and then Is_Scalar_Type (Packed_Array_Type (UT)));\n    end Represented_As_Scalar;\n \n    ------------------------------\n@@ -7200,7 +7177,7 @@ package body Exp_Util is\n             elsif not Is_Imported (Obj_Id)\n               and then Needs_Finalization (Obj_Typ)\n               and then not (Ekind (Obj_Id) = E_Constant\n-                              and then not Has_Completion (Obj_Id))\n+                             and then not Has_Completion (Obj_Id))\n               and then not Is_Tag_To_Class_Wide_Conversion (Obj_Id)\n             then\n                return True;\n@@ -7241,7 +7218,7 @@ package body Exp_Util is\n             elsif Is_Access_Type (Obj_Typ)\n               and then Present (Status_Flag_Or_Transient_Decl (Obj_Id))\n               and then Nkind (Status_Flag_Or_Transient_Decl (Obj_Id)) =\n-                         N_Defining_Identifier\n+                                                      N_Defining_Identifier\n               and then Present (Expr)\n               and then Nkind (Expr) = N_Null\n             then\n@@ -7319,7 +7296,7 @@ package body Exp_Util is\n                              (Available_View (Designated_Type (Typ))))\n                or else\n                 (Is_Type (Typ)\n-                   and then Needs_Finalization (Typ)))\n+                  and then Needs_Finalization (Typ)))\n               and then Requires_Cleanup_Actions\n                          (Actions (Decl), Lib_Level, Nested_Constructs)\n             then\n@@ -7338,17 +7315,15 @@ package body Exp_Util is\n             end if;\n \n             if Ekind (Pack_Id) /= E_Generic_Package\n-              and then Requires_Cleanup_Actions\n-                         (Specification (Decl), Lib_Level)\n+              and then\n+                Requires_Cleanup_Actions (Specification (Decl), Lib_Level)\n             then\n                return True;\n             end if;\n \n          --  Nested package bodies\n \n-         elsif Nested_Constructs\n-           and then Nkind (Decl) = N_Package_Body\n-         then\n+         elsif Nested_Constructs and then Nkind (Decl) = N_Package_Body then\n             Pack_Id := Corresponding_Spec (Decl);\n \n             if Ekind (Pack_Id) /= E_Generic_Package\n@@ -7391,8 +7366,8 @@ package body Exp_Util is\n \n       if (Nkind (Pexp) = N_Assignment_Statement\n            and then Expression (Pexp) = Exp)\n-        or else Nkind (Pexp) = N_Object_Declaration\n-        or else Nkind (Pexp) = N_Object_Renaming_Declaration\n+        or else Nkind_In (Pexp, N_Object_Declaration,\n+                                N_Object_Renaming_Declaration)\n       then\n          return True;\n \n@@ -7403,7 +7378,7 @@ package body Exp_Util is\n       --  introduce a temporary in this case.\n \n       elsif Nkind (Pexp) = N_Selected_Component\n-         and then Prefix (Pexp) = Exp\n+        and then Prefix (Pexp) = Exp\n       then\n          if No (Etype (Pexp)) then\n             return True;\n@@ -7491,7 +7466,7 @@ package body Exp_Util is\n       elsif Size_Known_At_Compile_Time (Otyp)\n         and then\n           (not Stack_Checking_Enabled\n-             or else not May_Generate_Large_Temp (Otyp))\n+            or else not May_Generate_Large_Temp (Otyp))\n         and then not (Is_Record_Type (Otyp) and then not Is_Constrained (Otyp))\n       then\n          return True;"}, {"sha": "cad64a36033517cea736d76d26702c9c952e93d9", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=0e564ab485f5db3094a2716fa79e57dcb1d181b8", "patch": "@@ -4377,11 +4377,12 @@ ada/validsw.o : ada/ada.ads ada/a-unccon.ads ada/a-uncdea.ads \\\n ada/warnsw.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/debug.ads ada/err_vars.ads \\\n    ada/hostparm.ads ada/namet.ads ada/opt.ads ada/output.ads \\\n-   ada/system.ads ada/s-exctab.ads ada/s-memory.ads ada/s-os_lib.ads \\\n-   ada/s-parame.ads ada/s-stalib.ads ada/s-string.ads ada/s-traent.ads \\\n-   ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n-   ada/tree_io.ads ada/types.ads ada/uintp.ads ada/unchconv.ads \\\n-   ada/unchdeal.ads ada/warnsw.ads ada/warnsw.adb \n+   ada/rident.ads ada/system.ads ada/s-exctab.ads ada/s-memory.ads \\\n+   ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads ada/s-stalib.ads \\\n+   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads \\\n+   ada/table.ads ada/table.adb ada/targparm.ads ada/tree_io.ads \\\n+   ada/types.ads ada/uintp.ads ada/unchconv.ads ada/unchdeal.ads \\\n+   ada/warnsw.ads ada/warnsw.adb \n \n ada/widechar.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/hostparm.ads ada/interfac.ads ada/opt.ads \\"}, {"sha": "a9548bffb604b1f8abcd25a6349c18ae8460ff4b", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=0e564ab485f5db3094a2716fa79e57dcb1d181b8", "patch": "@@ -770,7 +770,7 @@ ifeq ($(strip $(filter-out %86 wrs vxworksae vxworksmils,$(targ))),)\n endif\n \n # Sparc VxWorks\n-ifeq ($(strip $(filter-out sparc% wrs vx%,$(targ))),)\n+ifeq ($(strip $(filter-out sparc% leon% wrs vx%,$(targ))),)\n   LIBGNAT_TARGET_PAIRS = \\\n   a-intnam.ads<a-intnam-vxworks.ads \\\n   a-numaux.ads<a-numaux-vxworks.ads \\\n@@ -797,7 +797,7 @@ ifeq ($(strip $(filter-out sparc% wrs vx%,$(targ))),)\n   mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb \\\n   indepsw.adb<indepsw-gnu.adb\n \n-  ifeq ($(arch),sparc)\n+  ifeq ($(strip $(filter-out sparc erc32 leon leon3, $(arch))),)\n     # 32-bits\n     LIBGNAT_TARGET_PAIRS += \\\n     s-vxwork.ads<s-vxwork-sparc.ads \\\n@@ -1535,6 +1535,7 @@ ifeq ($(strip $(filter-out alpha64 ia64 dec hp vms% openvms% alphavms%,$(targ)))\n       $(ATOMICS_BUILTINS_TARGET_PAIRS)\n \n     EXTRA_LIBGNAT_SRCS+=tb-ivms.c\n+    override GNATRTL_ALTIVEC_OBJS=\n \n     TOOLS_TARGET_PAIRS= \\\n       mlib-tgt-specific.adb<mlib-tgt-specific-vms-ia64.adb \\\n@@ -2357,7 +2358,9 @@ ADA_EXCLUDE_SRCS =\\\n   s-vxwexc.adb s-vxwexc.ads s-vxwext.adb s-vxwext.ads \\\n   s-win32.ads  s-winext.ads \\\n   g-regist.adb g-regist.ads g-sse.ads    g-ssvety.ads \\\n-  i-vxwoio.adb i-vxwoio.ads i-vxwork.ads\n+  i-vxwoio.adb i-vxwoio.ads i-vxwork.ads \\\n+  g-allein.ads g-alleve.ads g-altcon.ads g-alveop.adb g-alvety.ads \\\n+  g-alleve.adb g-altcon.adb g-altive.ads g-alveop.ads g-alvevi.ads\n \n # ADA_EXCLUDE_SRCS without the sources used by the target\n ADA_EXCLUDE_FILES=$(filter-out \\"}, {"sha": "257ee1f170ade1bb1a5d0955000a9f38eaed2b9f", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=0e564ab485f5db3094a2716fa79e57dcb1d181b8", "patch": "@@ -11546,6 +11546,30 @@ The default alignment for the type @code{V} is 4, as a result of the\n Integer field in the record, but it is permissible, as shown, to\n override the default alignment of the record with a smaller value.\n \n+@cindex Alignment, subtypes\n+Note that according to the Ada standard, an alignment clause applies only\n+to the first named subtype. If additional subtypes are declared, then the\n+compiler is allowed to choose any alignment it likes, and there is no way\n+to control this choice. Consider:\n+\n+@smallexample @c ada\n+   type R is range 1 .. 10_000;\n+   for R'Alignment use 1;\n+   subtype RS is R range 1 .. 1000;\n+@end smallexample\n+\n+@noindent\n+The alignment clause specifies an alignment of 1 for the first named subtype\n+@code{R} but this does not necessarily apply to @code{RS}. When writing\n+portable Ada code, you should avoid writing code that explicitly or\n+implicitly relies on the alignment of such subtypes.\n+\n+For the GNAT compiler, if an explicit alignment clause is given, this\n+value is also used for any subsequent subtypes. So for GNAT, in the\n+above example, you can count on the alignment of @code{RS} being 1. But this\n+assumption is non-portable, and other compilers may choose different\n+alignments for the subtype @code{RS}.\n+\n @node Size Clauses\n @section Size Clauses\n @cindex Size Clause"}, {"sha": "87cd97d7fa6ba4c24bc08b3da92d2d84dee5bef3", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=0e564ab485f5db3094a2716fa79e57dcb1d181b8", "patch": "@@ -5214,7 +5214,7 @@ individually controlled.  The warnings that are not turned on by this\n switch are\n @option{-gnatwd} (implicit dereferencing),\n @option{-gnatwh} (hiding),\n-@ifclear VMS\n+@ifclear vms\n @option{-gnatw.d} (tag warnings with -gnatw switch)\n @end ifclear\n @option{-gnatw.h} (holes (gaps) in record layouts)"}, {"sha": "de2254cb222ee448c7e01dc45080574c0d2d8e9d", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=0e564ab485f5db3094a2716fa79e57dcb1d181b8", "patch": "@@ -461,6 +461,11 @@ package body Prj is\n          if Iter.Current = No_Source then\n             Iter.Language := Iter.Language.Next;\n             Language_Changed (Iter);\n+\n+         elsif not Iter.Locally_Removed\n+           and then Iter.Current.Locally_Removed\n+         then\n+            Next (Iter);\n          end if;\n       end if;\n    end Language_Changed;\n@@ -473,7 +478,8 @@ package body Prj is\n      (In_Tree           : Project_Tree_Ref;\n       Project           : Project_Id := No_Project;\n       Language          : Name_Id := No_Name;\n-      Encapsulated_Libs : Boolean := True) return Source_Iterator\n+      Encapsulated_Libs : Boolean := True;\n+      Locally_Removed   : Boolean := True) return Source_Iterator\n    is\n       Iter : Source_Iterator;\n    begin\n@@ -484,7 +490,8 @@ package body Prj is\n          Language_Name     => Language,\n          Language          => No_Language_Index,\n          Current           => No_Source,\n-         Encapsulated_Libs => Encapsulated_Libs);\n+         Encapsulated_Libs => Encapsulated_Libs,\n+         Locally_Removed   => Locally_Removed);\n \n       if Project /= null then\n          while Iter.Project /= null\n@@ -521,7 +528,14 @@ package body Prj is\n \n    procedure Next (Iter : in out Source_Iterator) is\n    begin\n-      Iter.Current := Iter.Current.Next_In_Lang;\n+      loop\n+         Iter.Current := Iter.Current.Next_In_Lang;\n+\n+         exit when Iter.Locally_Removed\n+           or else Iter.Current = No_Source\n+           or else not Iter.Current.Locally_Removed;\n+      end loop;\n+\n       if Iter.Current = No_Source then\n          Iter.Language := Iter.Language.Next;\n          Language_Changed (Iter);"}, {"sha": "449b038e475a2e2f4672f1144487ee02839c0e8e", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=0e564ab485f5db3094a2716fa79e57dcb1d181b8", "patch": "@@ -1466,10 +1466,12 @@ package Prj is\n      (In_Tree           : Project_Tree_Ref;\n       Project           : Project_Id := No_Project;\n       Language          : Name_Id    := No_Name;\n-      Encapsulated_Libs : Boolean    := True) return Source_Iterator;\n+      Encapsulated_Libs : Boolean    := True;\n+      Locally_Removed   : Boolean    := True) return Source_Iterator;\n    --  Returns an iterator for all the sources of a project tree, or a specific\n    --  project, or a specific language. Include sources from aggregated libs if\n-   --  Aggregated_Libs is True.\n+   --  Aggregated_Libs is True. If Locally_Removed is set to False the\n+   --  Locally_Removed files won't be reported.\n \n    function Element (Iter : Source_Iterator) return Source_Id;\n    --  Return the current source (or No_Source if there are no more sources)\n@@ -1923,6 +1925,8 @@ private\n \n       Encapsulated_Libs : Boolean;\n       --  True if we want to include the sources from encapsulated libs\n+\n+      Locally_Removed : Boolean;\n    end record;\n \n    procedure Add_To_Buffer"}, {"sha": "db9ceb214b803bce79cb18e62aecb1f88be832aa", "filename": "gcc/ada/validsw.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fvalidsw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fvalidsw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvalidsw.ads?ref=0e564ab485f5db3094a2716fa79e57dcb1d181b8", "patch": "@@ -78,7 +78,7 @@ package Validsw is\n \n    Validity_Check_In_Params : Boolean := False;\n    --  Controls the validity checking of IN parameters. If this switch is\n-   --  set to True using -gnatVm or an 'i' in the argument of a pragma\n+   --  set to True using -gnatVi or an 'i' in the argument of a pragma\n    --  Validity_Checks, then the initial value of all IN parameters\n    --  will be checked at the point of call of a procedure or function.\n "}, {"sha": "337f4699bd391a4ac79cb921cddfe42fc653eee4", "filename": "gcc/ada/warnsw.adb", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fwarnsw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e564ab485f5db3094a2716fa79e57dcb1d181b8/gcc%2Fada%2Fwarnsw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fwarnsw.adb?ref=0e564ab485f5db3094a2716fa79e57dcb1d181b8", "patch": "@@ -22,9 +22,10 @@\n -- Extensive contributions were provided by Ada Core Technologies Inc.      --\n --                                                                          --\n ------------------------------------------------------------------------------\n+\n with Err_Vars; use Err_Vars;\n with Opt;      use Opt;\n-\n+with Targparm; use Targparm;\n package body Warnsw is\n \n    ----------------------------\n@@ -53,14 +54,14 @@ package body Warnsw is\n             Warn_On_Unrepped_Components         := False;\n \n          when 'd' =>\n-            if Open_VMS_On_Target then\n+            if OpenVMS_On_Target then\n                return False;\n             end if;\n \n             Warning_Doc_Switch                  := True;\n \n          when 'D' =>\n-            if Open_VMS_On_Target then\n+            if OpenVMS_On_Target then\n                return False;\n             end if;\n \n@@ -76,7 +77,11 @@ package body Warnsw is\n             Implementation_Unit_Warnings        := True;\n             Ineffective_Inline_Warnings         := True;\n             List_Inherited_Aspects              := True;\n-            Warning_Doc_Switch                  := True;\n+\n+            if not OpenVMS_On_Target then\n+               Warning_Doc_Switch               := True;\n+            end if;\n+\n             Warn_On_Ada_2005_Compatibility      := True;\n             Warn_On_Ada_2012_Compatibility      := True;\n             Warn_On_All_Unread_Out_Parameters   := True;"}]}