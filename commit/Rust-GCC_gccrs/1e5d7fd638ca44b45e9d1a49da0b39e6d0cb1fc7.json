{"sha": "1e5d7fd638ca44b45e9d1a49da0b39e6d0cb1fc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU1ZDdmZDYzOGNhNDRiNDVlOWQxYTQ5ZGEwYjM5ZTZkMGNiMWZjNw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2015-11-26T21:57:40Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2015-11-26T21:57:40Z"}, "message": "[PR67753] adjust for padding when bypassing memory in assign_parm_setup_block\n\nStoring a register in memory as a full word and then accessing the\nsame memory address under a smaller-than-word mode amounts to\nright-shifting of the register word on big endian machines.  So, if\nBLOCK_REG_PADDING chooses upward padding for BYTES_BIG_ENDIAN, and\nwe're copying from the entry_parm REG directly to a pseudo, bypassing\nany stack slot, perform the shifting explicitly.\n\nThis fixes the miscompile of function_return_val_10 in\ngcc.target/aarch64/aapcs64/func-ret-4.c for target aarch64_be-elf\nintroduced in the first patch for 67753.\n\nfor  gcc/ChangeLog\n\n\tPR rtl-optimization/67753\n\tPR rtl-optimization/64164\n\t* function.c (assign_parm_setup_block): Right-shift\n\tupward-padded big-endian args when bypassing the stack slot.\n\nFrom-SVN: r230985", "tree": {"sha": "5b030f1af1cc3c775d28f45c3afdaf55906e4e93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b030f1af1cc3c775d28f45c3afdaf55906e4e93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e5d7fd638ca44b45e9d1a49da0b39e6d0cb1fc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e5d7fd638ca44b45e9d1a49da0b39e6d0cb1fc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e5d7fd638ca44b45e9d1a49da0b39e6d0cb1fc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e5d7fd638ca44b45e9d1a49da0b39e6d0cb1fc7/comments", "author": null, "committer": null, "parents": [{"sha": "4d6ca95b9a1deb58a5f4ff81d90ee3a0d75ed330", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d6ca95b9a1deb58a5f4ff81d90ee3a0d75ed330", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d6ca95b9a1deb58a5f4ff81d90ee3a0d75ed330"}], "stats": {"total": 51, "additions": 48, "deletions": 3}, "files": [{"sha": "e48613e2ccd55eee11c7c98df6dc28484f7cea0a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5d7fd638ca44b45e9d1a49da0b39e6d0cb1fc7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5d7fd638ca44b45e9d1a49da0b39e6d0cb1fc7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e5d7fd638ca44b45e9d1a49da0b39e6d0cb1fc7", "patch": "@@ -1,3 +1,10 @@\n+2015-11-26  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR rtl-optimization/67753\n+\tPR rtl-optimization/64164\n+\t* function.c (assign_parm_setup_block): Right-shift\n+\tupward-padded big-endian args when bypassing the stack slot.\n+\n 2015-11-26  Maciej W. Rozycki  <macro@imgtec.com>\n \n \t* doc/invoke.texi (Option Summary) <MIPS Options>: Reorder"}, {"sha": "515d7c042203d24f0ee5eb17bb58807eea14a53f", "filename": "gcc/function.c", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5d7fd638ca44b45e9d1a49da0b39e6d0cb1fc7/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5d7fd638ca44b45e9d1a49da0b39e6d0cb1fc7/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=1e5d7fd638ca44b45e9d1a49da0b39e6d0cb1fc7", "patch": "@@ -3002,6 +3002,38 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n \t      emit_move_insn (change_address (mem, mode, 0), reg);\n \t    }\n \n+#ifdef BLOCK_REG_PADDING\n+\t  /* Storing the register in memory as a full word, as\n+\t     move_block_from_reg below would do, and then using the\n+\t     MEM in a smaller mode, has the effect of shifting right\n+\t     if BYTES_BIG_ENDIAN.  If we're bypassing memory, the\n+\t     shifting must be explicit.  */\n+\t  else if (!MEM_P (mem))\n+\t    {\n+\t      rtx x;\n+\n+\t      /* If the assert below fails, we should have taken the\n+\t\t mode != BLKmode path above, unless we have downward\n+\t\t padding of smaller-than-word arguments on a machine\n+\t\t with little-endian bytes, which would likely require\n+\t\t additional changes to work correctly.  */\n+\t      gcc_checking_assert (BYTES_BIG_ENDIAN\n+\t\t\t\t   && (BLOCK_REG_PADDING (mode,\n+\t\t\t\t\t\t\t  data->passed_type, 1)\n+\t\t\t\t       == upward));\n+\n+\t      int by = (UNITS_PER_WORD - size) * BITS_PER_UNIT;\n+\n+\t      x = gen_rtx_REG (word_mode, REGNO (entry_parm));\n+\t      x = expand_shift (RSHIFT_EXPR, word_mode, x, by,\n+\t\t\t\tNULL_RTX, 1);\n+\t      x = force_reg (word_mode, x);\n+\t      x = gen_lowpart_SUBREG (GET_MODE (mem), x);\n+\n+\t      emit_move_insn (mem, x);\n+\t    }\n+#endif\n+\n \t  /* Blocks smaller than a word on a BYTES_BIG_ENDIAN\n \t     machine must be aligned to the left before storing\n \t     to memory.  Note that the previous test doesn't\n@@ -3023,14 +3055,20 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n \t      tem = change_address (mem, word_mode, 0);\n \t      emit_move_insn (tem, x);\n \t    }\n-\t  else if (!MEM_P (mem))\n-\t    emit_move_insn (mem, entry_parm);\n \t  else\n \t    move_block_from_reg (REGNO (entry_parm), mem,\n \t\t\t\t size_stored / UNITS_PER_WORD);\n \t}\n       else if (!MEM_P (mem))\n-\temit_move_insn (mem, entry_parm);\n+\t{\n+\t  gcc_checking_assert (size > UNITS_PER_WORD);\n+#ifdef BLOCK_REG_PADDING\n+\t  gcc_checking_assert (BLOCK_REG_PADDING (GET_MODE (mem),\n+\t\t\t\t\t\t  data->passed_type, 0)\n+\t\t\t       == upward);\n+#endif\n+\t  emit_move_insn (mem, entry_parm);\n+\t}\n       else\n \tmove_block_from_reg (REGNO (entry_parm), mem,\n \t\t\t     size_stored / UNITS_PER_WORD);"}]}