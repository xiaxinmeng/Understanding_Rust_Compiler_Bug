{"sha": "bed6238ce677ba18a672a58bc077cec6de47f8d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVkNjIzOGNlNjc3YmExOGE2NzJhNThiYzA3N2NlYzZkZTQ3ZjhkMw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-10-03T05:03:24Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-10-03T05:03:24Z"}, "message": "compiler: Fix a, b, c := b, a, 1 when a and b already exist.\n\nFrom-SVN: r192022", "tree": {"sha": "ab7c01c445668c3a6b071f77508f899f2162fdb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab7c01c445668c3a6b071f77508f899f2162fdb7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bed6238ce677ba18a672a58bc077cec6de47f8d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bed6238ce677ba18a672a58bc077cec6de47f8d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bed6238ce677ba18a672a58bc077cec6de47f8d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bed6238ce677ba18a672a58bc077cec6de47f8d3/comments", "author": null, "committer": null, "parents": [{"sha": "e1d90a813cad65eaf96f5e09f5e3b2d531ef76dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1d90a813cad65eaf96f5e09f5e3b2d531ef76dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1d90a813cad65eaf96f5e09f5e3b2d531ef76dd"}], "stats": {"total": 76, "additions": 60, "deletions": 16}, "files": [{"sha": "ab2bb7cf29d036a340450c9a0565aefd61d373e3", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 56, "deletions": 15, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bed6238ce677ba18a672a58bc077cec6de47f8d3/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bed6238ce677ba18a672a58bc077cec6de47f8d3/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=bed6238ce677ba18a672a58bc077cec6de47f8d3", "patch": "@@ -1631,27 +1631,32 @@ Parse::init_vars(const Typed_identifier_list* til, Type* type,\n \n   // Note that INIT was already parsed with the old name bindings, so\n   // we don't have to worry that it will accidentally refer to the\n-  // newly declared variables.\n+  // newly declared variables.  But we do have to worry about a mix of\n+  // newly declared variables and old variables if the old variables\n+  // appear in the initializations.\n \n   Expression_list::const_iterator pexpr;\n   if (init != NULL)\n     pexpr = init->begin();\n   bool any_new = false;\n+  Expression_list* vars = new Expression_list();\n+  Expression_list* vals = new Expression_list();\n   for (Typed_identifier_list::const_iterator p = til->begin();\n        p != til->end();\n        ++p)\n     {\n       if (init != NULL)\n \tgo_assert(pexpr != init->end());\n       this->init_var(*p, type, init == NULL ? NULL : *pexpr, is_coloneq,\n-\t\t     false, &any_new);\n+\t\t     false, &any_new, vars, vals);\n       if (init != NULL)\n \t++pexpr;\n     }\n   if (init != NULL)\n     go_assert(pexpr == init->end());\n   if (is_coloneq && !any_new)\n     error_at(location, \"variables redeclared but no variable is new\");\n+  this->finish_init_vars(vars, vals, location);\n }\n \n // See if we need to initialize a list of variables from a function\n@@ -1674,13 +1679,15 @@ Parse::init_vars_from_call(const Typed_identifier_list* vars, Type* type,\n   Named_object* first_var = NULL;\n   unsigned int index = 0;\n   bool any_new = false;\n+  Expression_list* ivars = new Expression_list();\n+  Expression_list* ivals = new Expression_list();\n   for (Typed_identifier_list::const_iterator pv = vars->begin();\n        pv != vars->end();\n        ++pv, ++index)\n     {\n       Expression* init = Expression::make_call_result(call, index);\n       Named_object* no = this->init_var(*pv, type, init, is_coloneq, false,\n-\t\t\t\t\t&any_new);\n+\t\t\t\t\t&any_new, ivars, ivals);\n \n       if (this->gogo_->in_global_scope() && no->is_variable())\n \t{\n@@ -1700,6 +1707,8 @@ Parse::init_vars_from_call(const Typed_identifier_list* vars, Type* type,\n   if (is_coloneq && !any_new)\n     error_at(location, \"variables redeclared but no variable is new\");\n \n+  this->finish_init_vars(ivars, ivals, location);\n+\n   return true;\n }\n \n@@ -1725,7 +1734,7 @@ Parse::init_vars_from_map(const Typed_identifier_list* vars, Type* type,\n   Typed_identifier_list::const_iterator p = vars->begin();\n   Expression* init = type == NULL ? index : NULL;\n   Named_object* val_no = this->init_var(*p, type, init, is_coloneq,\n-\t\t\t\t\ttype == NULL, &any_new);\n+\t\t\t\t\ttype == NULL, &any_new, NULL, NULL);\n   if (type == NULL && any_new && val_no->is_variable())\n     val_no->var_value()->set_type_from_init_tuple();\n   Expression* val_var = Expression::make_var_reference(val_no, location);\n@@ -1735,7 +1744,7 @@ Parse::init_vars_from_map(const Typed_identifier_list* vars, Type* type,\n   if (var_type == NULL)\n     var_type = Type::lookup_bool_type();\n   Named_object* no = this->init_var(*p, var_type, NULL, is_coloneq, false,\n-\t\t\t\t    &any_new);\n+\t\t\t\t    &any_new, NULL, NULL);\n   Expression* present_var = Expression::make_var_reference(no, location);\n \n   if (is_coloneq && !any_new)\n@@ -1790,7 +1799,7 @@ Parse::init_vars_from_receive(const Typed_identifier_list* vars, Type* type,\n   Typed_identifier_list::const_iterator p = vars->begin();\n   Expression* init = type == NULL ? receive : NULL;\n   Named_object* val_no = this->init_var(*p, type, init, is_coloneq,\n-\t\t\t\t\ttype == NULL, &any_new);\n+\t\t\t\t\ttype == NULL, &any_new, NULL, NULL);\n   if (type == NULL && any_new && val_no->is_variable())\n     val_no->var_value()->set_type_from_init_tuple();\n   Expression* val_var = Expression::make_var_reference(val_no, location);\n@@ -1800,7 +1809,7 @@ Parse::init_vars_from_receive(const Typed_identifier_list* vars, Type* type,\n   if (var_type == NULL)\n     var_type = Type::lookup_bool_type();\n   Named_object* no = this->init_var(*p, var_type, NULL, is_coloneq, false,\n-\t\t\t\t    &any_new);\n+\t\t\t\t    &any_new, NULL, NULL);\n   Expression* received_var = Expression::make_var_reference(no, location);\n \n   if (is_coloneq && !any_new)\n@@ -1857,15 +1866,15 @@ Parse::init_vars_from_type_guard(const Typed_identifier_list* vars,\n   if (var_type == NULL)\n     var_type = type_guard->type();\n   Named_object* val_no = this->init_var(*p, var_type, NULL, is_coloneq, false,\n-\t\t\t\t\t&any_new);\n+\t\t\t\t\t&any_new, NULL, NULL);\n   Expression* val_var = Expression::make_var_reference(val_no, location);\n \n   ++p;\n   var_type = type;\n   if (var_type == NULL)\n     var_type = Type::lookup_bool_type();\n   Named_object* no = this->init_var(*p, var_type, NULL, is_coloneq, false,\n-\t\t\t\t    &any_new);\n+\t\t\t\t    &any_new, NULL, NULL);\n   Expression* ok_var = Expression::make_var_reference(no, location);\n \n   Expression* texpr = type_guard->expr();\n@@ -1904,7 +1913,8 @@ Parse::init_vars_from_type_guard(const Typed_identifier_list* vars,\n \n Named_object*\n Parse::init_var(const Typed_identifier& tid, Type* type, Expression* init,\n-\t\tbool is_coloneq, bool type_from_init, bool* is_new)\n+\t\tbool is_coloneq, bool type_from_init, bool* is_new,\n+\t\tExpression_list* vars, Expression_list* vals)\n {\n   Location location = tid.location();\n \n@@ -1946,9 +1956,9 @@ Parse::init_var(const Typed_identifier& tid, Type* type, Expression* init,\n \t  // like v, ok := x.(int).\n \t  if (!type_from_init && init != NULL)\n \t    {\n-\t      Expression *v = Expression::make_var_reference(no, location);\n-\t      Statement *s = Statement::make_assignment(v, init, location);\n-\t      this->gogo_->add_statement(s);\n+\t      go_assert(vars != NULL && vals != NULL);\n+\t      vars->push_back(Expression::make_var_reference(no, location));\n+\t      vals->push_back(init);\n \t    }\n \t  return no;\n \t}\n@@ -1983,6 +1993,36 @@ Parse::create_dummy_global(Type* type, Expression* init,\n   return this->gogo_->add_variable(buf, var);\n }\n \n+// Finish the variable initialization by executing any assignments to\n+// existing variables when using :=.  These must be done as a tuple\n+// assignment in case of something like n, a, b := 1, b, a.\n+\n+void\n+Parse::finish_init_vars(Expression_list* vars, Expression_list* vals,\n+\t\t\tLocation location)\n+{\n+  if (vars->empty())\n+    {\n+      delete vars;\n+      delete vals;\n+    }\n+  else if (vars->size() == 1)\n+    {\n+      go_assert(!this->gogo_->in_global_scope());\n+      this->gogo_->add_statement(Statement::make_assignment(vars->front(),\n+\t\t\t\t\t\t\t    vals->front(),\n+\t\t\t\t\t\t\t    location));\n+      delete vars;\n+      delete vals;\n+    }\n+  else\n+    {\n+      go_assert(!this->gogo_->in_global_scope());\n+      this->gogo_->add_statement(Statement::make_tuple_assignment(vars, vals,\n+\t\t\t\t\t\t\t\t  location));\n+    }\n+}\n+\n // SimpleVarDecl = identifier \":=\" Expression .\n \n // We've already seen the identifier.\n@@ -5113,7 +5153,8 @@ Parse::range_clause_decl(const Typed_identifier_list* til,\n   bool any_new = false;\n \n   const Typed_identifier* pti = &til->front();\n-  Named_object* no = this->init_var(*pti, NULL, expr, true, true, &any_new);\n+  Named_object* no = this->init_var(*pti, NULL, expr, true, true, &any_new,\n+\t\t\t\t    NULL, NULL);\n   if (any_new && no->is_variable())\n     no->var_value()->set_type_from_range_index();\n   p_range_clause->index = Expression::make_var_reference(no, location);\n@@ -5124,7 +5165,7 @@ Parse::range_clause_decl(const Typed_identifier_list* til,\n     {\n       pti = &til->back();\n       bool is_new = false;\n-      no = this->init_var(*pti, NULL, expr, true, true, &is_new);\n+      no = this->init_var(*pti, NULL, expr, true, true, &is_new, NULL, NULL);\n       if (is_new && no->is_variable())\n \tno->var_value()->set_type_from_range_value();\n       if (is_new)"}, {"sha": "a355b7d2b3b016a48e792dd08c3011b62a2e0d96", "filename": "gcc/go/gofrontend/parse.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bed6238ce677ba18a672a58bc077cec6de47f8d3/gcc%2Fgo%2Fgofrontend%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bed6238ce677ba18a672a58bc077cec6de47f8d3/gcc%2Fgo%2Fgofrontend%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.h?ref=bed6238ce677ba18a672a58bc077cec6de47f8d3", "patch": "@@ -206,8 +206,11 @@ class Parse\n \t\t\t\t Expression*, bool is_coloneq,\n \t\t\t\t Location);\n   Named_object* init_var(const Typed_identifier&, Type*, Expression*,\n-\t\t\t bool is_coloneq, bool type_from_init, bool* is_new);\n+\t\t\t bool is_coloneq, bool type_from_init, bool* is_new,\n+\t\t\t Expression_list* vars, Expression_list* vals);\n   Named_object* create_dummy_global(Type*, Expression*, Location);\n+  void finish_init_vars(Expression_list* vars, Expression_list* vals,\n+\t\t\tLocation);\n   void simple_var_decl_or_assignment(const std::string&, Location,\n \t\t\t\t     bool may_be_composite_lit,\n \t\t\t\t     Range_clause*, Type_switch*);"}]}