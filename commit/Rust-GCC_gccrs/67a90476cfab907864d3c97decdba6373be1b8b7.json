{"sha": "67a90476cfab907864d3c97decdba6373be1b8b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdhOTA0NzZjZmFiOTA3ODY0ZDNjOTdkZWNkYmE2MzczYmUxYjhiNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-07-05T10:40:03Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-07-05T10:40:03Z"}, "message": "[multiple changes]\n\n2013-07-05  Claire Dross  <dross@adacore.com>\n\n\t* a-cfdlli.ads: Add preconditions when needed.\n\n2013-07-05  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch8.adb: Minor reformatting.\n\n2013-07-05  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Access_Subprogram_Declaration): Use\n\tGenerate_Reference_To_Formals.\n\t* lib-xref.adb (Generate_Reference_To_Formals): In the case of\n\taccess to subprograms, the formals are found in the designated\n\tsubprogram type.\n\n2013-07-05  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_ugn.texi: Document that comments can be lined up with\n\tprevious non-blank line.\n\t* styleg.adb (Check_Comment): Allow indentation to match previous\n\tnon-blank line (Same_Column_As_Previous_Line): New function\n\nFrom-SVN: r200705", "tree": {"sha": "cca2de79e678fafcd492db9efeafc5e1dc0e79e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cca2de79e678fafcd492db9efeafc5e1dc0e79e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67a90476cfab907864d3c97decdba6373be1b8b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67a90476cfab907864d3c97decdba6373be1b8b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67a90476cfab907864d3c97decdba6373be1b8b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67a90476cfab907864d3c97decdba6373be1b8b7/comments", "author": null, "committer": null, "parents": [{"sha": "6ee07c611ca3dd4f70bd9744cf0342e8ff536c69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ee07c611ca3dd4f70bd9744cf0342e8ff536c69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ee07c611ca3dd4f70bd9744cf0342e8ff536c69"}], "stats": {"total": 171, "additions": 139, "deletions": 32}, "files": [{"sha": "3b1202dfba351f212f32821379940fc7de8d7473", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a90476cfab907864d3c97decdba6373be1b8b7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a90476cfab907864d3c97decdba6373be1b8b7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=67a90476cfab907864d3c97decdba6373be1b8b7", "patch": "@@ -1,3 +1,26 @@\n+2013-07-05  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cfdlli.ads: Add preconditions when needed.\n+\n+2013-07-05  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch8.adb: Minor reformatting.\n+\n+2013-07-05  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Access_Subprogram_Declaration): Use\n+\tGenerate_Reference_To_Formals.\n+\t* lib-xref.adb (Generate_Reference_To_Formals): In the case of\n+\taccess to subprograms, the formals are found in the designated\n+\tsubprogram type.\n+\n+2013-07-05  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_ugn.texi: Document that comments can be lined up with\n+\tprevious non-blank line.\n+\t* styleg.adb (Check_Comment): Allow indentation to match previous\n+\tnon-blank line (Same_Column_As_Previous_Line): New function\n+\n 2013-07-05  Robert Dewar  <dewar@adacore.com>\n \n \t* gnat_rm.texi: Update doc on missing pragmas."}, {"sha": "8340abb2ae450f5c5ad1bff6e21c7f7548aa1696", "filename": "gcc/ada/a-cfdlli.ads", "status": "modified", "additions": 62, "deletions": 27, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a90476cfab907864d3c97decdba6373be1b8b7/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a90476cfab907864d3c97decdba6373be1b8b7/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=67a90476cfab907864d3c97decdba6373be1b8b7", "patch": "@@ -78,112 +78,145 @@ package Ada.Containers.Formal_Doubly_Linked_Lists is\n \n    procedure Clear (Container : in out List);\n \n-   procedure Assign (Target : in out List; Source : List);\n+   procedure Assign (Target : in out List; Source : List)\n+   with Pre => Target.Capacity >= Length (Source);\n \n    function Copy (Source : List; Capacity : Count_Type := 0) return List;\n \n-   function Element (Container : List; Position : Cursor) return Element_Type;\n+   function Element (Container : List; Position : Cursor) return Element_Type\n+   with Pre => Has_Element (Container, Position);\n \n    procedure Replace_Element\n      (Container : in out List;\n       Position  : Cursor;\n-      New_Item  : Element_Type);\n+      New_Item  : Element_Type)\n+   with Pre => Has_Element (Container, Position);\n \n-   procedure Move (Target : in out List; Source : in out List);\n+   procedure Move (Target : in out List; Source : in out List)\n+   with Pre => Target.Capacity >= Length (Source);\n \n    procedure Insert\n      (Container : in out List;\n       Before    : Cursor;\n       New_Item  : Element_Type;\n-      Count     : Count_Type := 1);\n+      Count     : Count_Type := 1)\n+   with Pre => Length (Container) + Count <= Container.Capacity and then\n+     (Has_Element (Container, Before) or else Before = No_Element);\n \n    procedure Insert\n      (Container : in out List;\n       Before    : Cursor;\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n-      Count     : Count_Type := 1);\n+      Count     : Count_Type := 1)\n+   with Pre => Length (Container) + Count <= Container.Capacity and then\n+     (Has_Element (Container, Before) or else Before = No_Element);\n \n    procedure Insert\n      (Container : in out List;\n       Before    : Cursor;\n       Position  : out Cursor;\n-      Count     : Count_Type := 1);\n+      Count     : Count_Type := 1)\n+   with Pre => Length (Container) + Count <= Container.Capacity and then\n+     (Has_Element (Container, Before) or else Before = No_Element);\n \n    procedure Prepend\n      (Container : in out List;\n       New_Item  : Element_Type;\n-      Count     : Count_Type := 1);\n+      Count     : Count_Type := 1)\n+   with Pre => Length (Container) + Count <= Container.Capacity;\n \n    procedure Append\n      (Container : in out List;\n       New_Item  : Element_Type;\n-      Count     : Count_Type := 1);\n+      Count     : Count_Type := 1)\n+   with Pre => Length (Container) + Count <= Container.Capacity;\n \n    procedure Delete\n      (Container : in out List;\n       Position  : in out Cursor;\n-      Count     : Count_Type := 1);\n+      Count     : Count_Type := 1)\n+   with Pre => Has_Element (Container, Position);\n \n    procedure Delete_First\n      (Container : in out List;\n-      Count     : Count_Type := 1);\n+      Count     : Count_Type := 1)\n+   with Pre => not Is_Empty (Container);\n \n    procedure Delete_Last\n      (Container : in out List;\n-      Count     : Count_Type := 1);\n+      Count     : Count_Type := 1)\n+   with Pre => not Is_Empty (Container);\n \n    procedure Reverse_Elements (Container : in out List);\n \n    procedure Swap\n      (Container : in out List;\n-      I, J      : Cursor);\n+      I, J      : Cursor)\n+   with Pre => Has_Element (Container, I) and then Has_Element (Container, J);\n \n    procedure Swap_Links\n      (Container : in out List;\n-      I, J      : Cursor);\n+      I, J      : Cursor)\n+   with Pre => Has_Element (Container, I) and then Has_Element (Container, J);\n \n    procedure Splice\n      (Target : in out List;\n       Before : Cursor;\n-      Source : in out List);\n+      Source : in out List)\n+   with Pre => Length (Source) + Length (Target) <= Target.Capacity and then\n+     (Has_Element (Target, Before) or else Before = No_Element);\n \n    procedure Splice\n      (Target   : in out List;\n       Before   : Cursor;\n       Source   : in out List;\n-      Position : in out Cursor);\n+      Position : in out Cursor)\n+   with Pre => Length (Source) + Length (Target) <= Target.Capacity and then\n+     (Has_Element (Target, Before) or else Before = No_Element) and then\n+     Has_Element (Source, Position);\n \n    procedure Splice\n      (Container : in out List;\n       Before    : Cursor;\n-      Position  : Cursor);\n+      Position  : Cursor)\n+   with Pre => 2 * Length (Container) <= Container.Capacity and then\n+     (Has_Element (Container, Before) or else Before = No_Element) and then\n+     Has_Element (Container, Position);\n \n    function First (Container : List) return Cursor;\n \n-   function First_Element (Container : List) return Element_Type;\n+   function First_Element (Container : List) return Element_Type\n+   with Pre => not Is_Empty (Container);\n \n    function Last (Container : List) return Cursor;\n \n-   function Last_Element (Container : List) return Element_Type;\n+   function Last_Element (Container : List) return Element_Type\n+   with Pre => not Is_Empty (Container);\n \n-   function Next (Container : List; Position : Cursor) return Cursor;\n+   function Next (Container : List; Position : Cursor) return Cursor\n+   with Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n-   procedure Next (Container : List; Position : in out Cursor);\n+   procedure Next (Container : List; Position : in out Cursor)\n+   with Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n-   function Previous (Container : List; Position : Cursor) return Cursor;\n+   function Previous (Container : List; Position : Cursor) return Cursor\n+   with Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n-   procedure Previous (Container : List; Position : in out Cursor);\n+   procedure Previous (Container : List; Position : in out Cursor)\n+   with Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Find\n      (Container : List;\n       Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor;\n+      Position  : Cursor := No_Element) return Cursor\n+   with Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Reverse_Find\n      (Container : List;\n       Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor;\n+      Position  : Cursor := No_Element) return Cursor\n+   with Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Contains\n      (Container : List;\n@@ -208,8 +241,10 @@ package Ada.Containers.Formal_Doubly_Linked_Lists is\n    --  they are structurally equal (function \"=\" returns True) and that they\n    --  have the same set of cursors.\n \n-   function Left  (Container : List; Position : Cursor) return List;\n-   function Right (Container : List; Position : Cursor) return List;\n+   function Left  (Container : List; Position : Cursor) return List\n+   with Pre => Has_Element (Container, Position) or else Position = No_Element;\n+   function Right (Container : List; Position : Cursor) return List\n+   with Pre => Has_Element (Container, Position) or else Position = No_Element;\n    --  Left returns a container containing all elements preceding Position\n    --  (excluded) in Container. Right returns a container containing all\n    --  elements following Position (included) in Container. These two new"}, {"sha": "5a6b6afe56f29906e513034abeda391b1d7fad6d", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a90476cfab907864d3c97decdba6373be1b8b7/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a90476cfab907864d3c97decdba6373be1b8b7/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=67a90476cfab907864d3c97decdba6373be1b8b7", "patch": "@@ -6065,7 +6065,8 @@ the examples in the Ada Reference Manual. Full line comments must be\n aligned with the @code{--} starting on a column that is a multiple of\n the alignment level, or they may be aligned the same way as the following\n non-blank line (this is useful when full line comments appear in the middle\n-of a statement.\n+of a statement, or they may be aligned with the source line on the previous\n+non-blank line.\n \n @item ^a^ATTRIBUTE^\n @emph{Check attribute casing.}"}, {"sha": "182c2b0a97949c626a1c8cf8bba40bd70210806c", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a90476cfab907864d3c97decdba6373be1b8b7/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a90476cfab907864d3c97decdba6373be1b8b7/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=67a90476cfab907864d3c97decdba6373be1b8b7", "patch": "@@ -1079,6 +1079,9 @@ package body Lib.Xref is\n             Next_Entity (Formal);\n          end loop;\n \n+      elsif Ekind (E) in Access_Subprogram_Kind then\n+         Formal := First_Formal (Designated_Type (E));\n+\n       else\n          Formal := First_Formal (E);\n       end if;"}, {"sha": "baa07daade9c3a82f5606ff4c12b28ed7bf5246e", "filename": "gcc/ada/lib-xref.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a90476cfab907864d3c97decdba6373be1b8b7/gcc%2Fada%2Flib-xref.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a90476cfab907864d3c97decdba6373be1b8b7/gcc%2Fada%2Flib-xref.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.ads?ref=67a90476cfab907864d3c97decdba6373be1b8b7", "patch": "@@ -718,7 +718,7 @@ package Lib.Xref is\n \n    procedure Generate_Reference_To_Formals (E : Entity_Id);\n    --  Add a reference to the definition of each formal on the line for\n-   --  a subprogram.\n+   --  a subprogram or an access_to_subprogram type.\n \n    procedure Generate_Reference_To_Generic_Formals (E : Entity_Id);\n    --  Add a reference to the definition of each generic formal on the line"}, {"sha": "7cbb9b92fee84bad66787eeaa6af4582492551a6", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a90476cfab907864d3c97decdba6373be1b8b7/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a90476cfab907864d3c97decdba6373be1b8b7/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=67a90476cfab907864d3c97decdba6373be1b8b7", "patch": "@@ -1283,6 +1283,8 @@ package body Sem_Ch3 is\n       Init_Size_Align              (T_Name);\n       Set_Directly_Designated_Type (T_Name, Desig_Type);\n \n+      Generate_Reference_To_Formals (T_Name);\n+\n       --  Ada 2005 (AI-231): Propagate the null-excluding attribute\n \n       Set_Can_Never_Be_Null (T_Name, Null_Exclusion_Present (T_Def));"}, {"sha": "a8b8491fc0bdb1c3aa0d6fa4be0caedccb742aee", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a90476cfab907864d3c97decdba6373be1b8b7/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a90476cfab907864d3c97decdba6373be1b8b7/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=67a90476cfab907864d3c97decdba6373be1b8b7", "patch": "@@ -2081,7 +2081,7 @@ package body Sem_Ch8 is\n                      else\n                         Error_Msg_NE\n                           (\"type& must be frozen before this point\",\n-                             Instantiation_Node, Etype (F));\n+                           Instantiation_Node, Etype (F));\n                      end if;\n                   end if;\n "}, {"sha": "6e4a44207e60648913bf83227d174820e4d5394b", "filename": "gcc/ada/styleg.adb", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a90476cfab907864d3c97decdba6373be1b8b7/gcc%2Fada%2Fstyleg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a90476cfab907864d3c97decdba6373be1b8b7/gcc%2Fada%2Fstyleg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstyleg.adb?ref=67a90476cfab907864d3c97decdba6373be1b8b7", "patch": "@@ -351,7 +351,9 @@ package body Styleg is\n    --    6. In addition, the comment must be properly indented if comment\n    --       indentation checking is active (Style_Check_Indentation non-zero).\n    --       Either the start column must be a multiple of this indentation,\n-   --       or the indentation must match that of the next non-blank line.\n+   --       or the indentation must match that of the next non-blank line,\n+   --       or must match the indentation of the immediately preciding line\n+   --       if it is non-blank.\n \n    procedure Check_Comment is\n       S : Source_Ptr;\n@@ -369,6 +371,12 @@ package body Styleg is\n       --  matches that of the next non-blank line in the source, then True is\n       --  returned, otherwise False.\n \n+      function Same_Column_As_Previous_Line return Boolean;\n+      --  Called for a full line comment. If the previous line is blank, then\n+      --  returns False. Otherwise, if the indentation of this comment matches\n+      --  that of the previous line in the source, then True is returned,\n+      --  otherwise False.\n+\n       --------------------\n       -- Is_Box_Comment --\n       --------------------\n@@ -429,6 +437,39 @@ package body Styleg is\n          return Get_Column_Number (Scan_Ptr) = Get_Column_Number (P);\n       end Same_Column_As_Next_Non_Blank_Line;\n \n+      ----------------------------------\n+      -- Same_Column_As_Previous_Line --\n+      ----------------------------------\n+\n+      function Same_Column_As_Previous_Line return Boolean is\n+         S, P : Source_Ptr;\n+\n+      begin\n+         --  Point S to start of this line, and P to start of previous line\n+\n+         S := Line_Start (Scan_Ptr);\n+         P := S;\n+         Backup_Line (P);\n+\n+         --  Step P to first non-blank character on line\n+\n+         loop\n+            --  If we get back to start of current line, then the previous line\n+            --  was blank, and we always return False in that situation.\n+\n+            if P = S then\n+               return False;\n+            end if;\n+\n+            exit when Source (P) /= ' ' and then Source (P) /= ASCII.HT;\n+            P := P + 1;\n+         end loop;\n+\n+         --  Compare columns\n+\n+         return Get_Column_Number (Scan_Ptr) = Get_Column_Number (P);\n+      end Same_Column_As_Previous_Line;\n+\n    --  Start of processing for Check_Comment\n \n    begin\n@@ -466,7 +507,9 @@ package body Styleg is\n \n          if Style_Check_Indentation /= 0 then\n             if Start_Column rem Style_Check_Indentation /= 0 then\n-               if not Same_Column_As_Next_Non_Blank_Line then\n+               if not Same_Column_As_Next_Non_Blank_Line\n+                 and then not Same_Column_As_Previous_Line\n+               then\n                   Error_Msg_S -- CODEFIX\n                     (\"(style) bad column\");\n                end if;"}]}