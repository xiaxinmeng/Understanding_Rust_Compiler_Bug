{"sha": "ab0a6b213abf6843b59cdea6399030e828109551", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWIwYTZiMjEzYWJmNjg0M2I1OWNkZWE2Mzk5MDMwZTgyODEwOTU1MQ==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-07-14T13:54:26Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-07-14T13:54:26Z"}, "message": "Vect: Add support for dot-product where the sign for the multiplicant changes.\n\nThis patch adds support for a dot product where the sign of the multiplication\narguments differ. i.e. one is signed and one is unsigned but the precisions are\nthe same.\n\n#define N 480\n#define SIGNEDNESS_1 unsigned\n#define SIGNEDNESS_2 signed\n#define SIGNEDNESS_3 signed\n#define SIGNEDNESS_4 unsigned\n\nSIGNEDNESS_1 int __attribute__ ((noipa))\nf (SIGNEDNESS_1 int res, SIGNEDNESS_3 char *restrict a,\n   SIGNEDNESS_4 char *restrict b)\n{\n  for (__INTPTR_TYPE__ i = 0; i < N; ++i)\n    {\n      int av = a[i];\n      int bv = b[i];\n      SIGNEDNESS_2 short mult = av * bv;\n      res += mult;\n    }\n  return res;\n}\n\nThe operations are performed as if the operands were extended to a 32-bit value.\nAs such this operation isn't valid if there is an intermediate conversion to an\nunsigned value. i.e.  if SIGNEDNESS_2 is unsigned.\n\nmore over if the signs of SIGNEDNESS_3 and SIGNEDNESS_4 are flipped the same\noptab is used but the operands are flipped in the optab expansion.\n\nTo support this the patch extends the dot-product detection to optionally\nignore operands with different signs and stores this information in the optab\nsubtype which is now made a bitfield.\n\nThe subtype can now additionally controls which optab an EXPR can expand to.\n\ngcc/ChangeLog:\n\n\t* optabs.def (usdot_prod_optab): New.\n\t* doc/md.texi: Document it and clarify other dot prod optabs.\n\t* optabs-tree.h (enum optab_subtype): Add optab_vector_mixed_sign.\n\t* optabs-tree.c (optab_for_tree_code): Support usdot_prod_optab.\n\t* optabs.c (expand_widen_pattern_expr): Likewise.\n\t* tree-cfg.c (verify_gimple_assign_ternary): Likewise.\n\t* tree-vect-loop.c (vectorizable_reduction): Query dot-product kind.\n\t* tree-vect-patterns.c (vect_supportable_direct_optab_p): Take optional\n\toptab subtype.\n\t(vect_widened_op_tree): Optionally ignore\n\tmismatch types.\n\t(vect_recog_dot_prod_pattern): Support usdot_prod_optab.", "tree": {"sha": "a351721ec47290ef4a9aed4819bf722fbf31cb98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a351721ec47290ef4a9aed4819bf722fbf31cb98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab0a6b213abf6843b59cdea6399030e828109551", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab0a6b213abf6843b59cdea6399030e828109551", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab0a6b213abf6843b59cdea6399030e828109551", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab0a6b213abf6843b59cdea6399030e828109551/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc11b924bfe7752edbba052ca71653f46a60887a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc11b924bfe7752edbba052ca71653f46a60887a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc11b924bfe7752edbba052ca71653f46a60887a"}], "stats": {"total": 192, "additions": 156, "deletions": 36}, "files": [{"sha": "07681e2ad2926cbf9bae4f7463c37d2830c42dee", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0a6b213abf6843b59cdea6399030e828109551/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0a6b213abf6843b59cdea6399030e828109551/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=ab0a6b213abf6843b59cdea6399030e828109551", "patch": "@@ -5449,13 +5449,53 @@ Like @samp{fold_left_plus_@var{m}}, but takes an additional mask operand\n \n @cindex @code{sdot_prod@var{m}} instruction pattern\n @item @samp{sdot_prod@var{m}}\n+\n+Compute the sum of the products of two signed elements.\n+Operand 1 and operand 2 are of the same mode. Their\n+product, which is of a wider mode, is computed and added to operand 3.\n+Operand 3 is of a mode equal or wider than the mode of the product. The\n+result is placed in operand 0, which is of the same mode as operand 3.\n+\n+Semantically the expressions perform the multiplication in the following signs\n+\n+@smallexample\n+sdot<signed op0, signed op1, signed op2, signed op3> ==\n+   op0 = sign-ext (op1) * sign-ext (op2) + op3\n+@dots{}\n+@end smallexample\n+\n @cindex @code{udot_prod@var{m}} instruction pattern\n-@itemx @samp{udot_prod@var{m}}\n-Compute the sum of the products of two signed/unsigned elements.\n-Operand 1 and operand 2 are of the same mode. Their product, which is of a\n-wider mode, is computed and added to operand 3. Operand 3 is of a mode equal or\n-wider than the mode of the product. The result is placed in operand 0, which\n-is of the same mode as operand 3.\n+@item @samp{udot_prod@var{m}}\n+\n+Compute the sum of the products of two unsigned elements.\n+Operand 1 and operand 2 are of the same mode. Their\n+product, which is of a wider mode, is computed and added to operand 3.\n+Operand 3 is of a mode equal or wider than the mode of the product. The\n+result is placed in operand 0, which is of the same mode as operand 3.\n+\n+Semantically the expressions perform the multiplication in the following signs\n+\n+@smallexample\n+udot<unsigned op0, unsigned op1, unsigned op2, unsigned op3> ==\n+   op0 = zero-ext (op1) * zero-ext (op2) + op3\n+@dots{}\n+@end smallexample\n+\n+@cindex @code{usdot_prod@var{m}} instruction pattern\n+@item @samp{usdot_prod@var{m}}\n+Compute the sum of the products of elements of different signs.\n+Operand 1 must be unsigned and operand 2 signed. Their\n+product, which is of a wider mode, is computed and added to operand 3.\n+Operand 3 is of a mode equal or wider than the mode of the product. The\n+result is placed in operand 0, which is of the same mode as operand 3.\n+\n+Semantically the expressions perform the multiplication in the following signs\n+\n+@smallexample\n+usdot<signed op0, unsigned op1, signed op2, signed op3> ==\n+   op0 = ((signed-conv) zero-ext (op1)) * sign-ext (op2) + op3\n+@dots{}\n+@end smallexample\n \n @cindex @code{ssad@var{m}} instruction pattern\n @item @samp{ssad@var{m}}"}, {"sha": "eeb5aeed3202cc6971b6447994bc5311e9c010bb", "filename": "gcc/optabs-tree.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0a6b213abf6843b59cdea6399030e828109551/gcc%2Foptabs-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0a6b213abf6843b59cdea6399030e828109551/gcc%2Foptabs-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-tree.c?ref=ab0a6b213abf6843b59cdea6399030e828109551", "patch": "@@ -127,7 +127,12 @@ optab_for_tree_code (enum tree_code code, const_tree type,\n       return TYPE_UNSIGNED (type) ? usum_widen_optab : ssum_widen_optab;\n \n     case DOT_PROD_EXPR:\n-      return TYPE_UNSIGNED (type) ? udot_prod_optab : sdot_prod_optab;\n+      {\n+\tif (subtype == optab_vector_mixed_sign)\n+\t  return usdot_prod_optab;\n+\n+\treturn (TYPE_UNSIGNED (type) ? udot_prod_optab : sdot_prod_optab);\n+      }\n \n     case SAD_EXPR:\n       return TYPE_UNSIGNED (type) ? usad_optab : ssad_optab;"}, {"sha": "fbd2b06b8dbfd560dfb66b314830e6b564b37abb", "filename": "gcc/optabs-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0a6b213abf6843b59cdea6399030e828109551/gcc%2Foptabs-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0a6b213abf6843b59cdea6399030e828109551/gcc%2Foptabs-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-tree.h?ref=ab0a6b213abf6843b59cdea6399030e828109551", "patch": "@@ -29,7 +29,8 @@ enum optab_subtype\n {\n   optab_default,\n   optab_scalar,\n-  optab_vector\n+  optab_vector,\n+  optab_vector_mixed_sign\n };\n \n /* Return the optab used for computing the given operation on the type given by"}, {"sha": "14d8ad2f33fd75388435fe912380e177f8f3c54b", "filename": "gcc/optabs.c", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0a6b213abf6843b59cdea6399030e828109551/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0a6b213abf6843b59cdea6399030e828109551/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=ab0a6b213abf6843b59cdea6399030e828109551", "patch": "@@ -262,6 +262,11 @@ expand_widen_pattern_expr (sepops ops, rtx op0, rtx op1, rtx wide_op,\n   bool sbool = false;\n \n   oprnd0 = ops->op0;\n+  if (nops >= 2)\n+    oprnd1 = ops->op1;\n+  if (nops >= 3)\n+    oprnd2 = ops->op2;\n+\n   tmode0 = TYPE_MODE (TREE_TYPE (oprnd0));\n   if (ops->code == VEC_UNPACK_FIX_TRUNC_HI_EXPR\n       || ops->code == VEC_UNPACK_FIX_TRUNC_LO_EXPR)\n@@ -285,6 +290,27 @@ expand_widen_pattern_expr (sepops ops, rtx op0, rtx op1, rtx wide_op,\n \t   ? vec_unpacks_sbool_hi_optab : vec_unpacks_sbool_lo_optab);\n       sbool = true;\n     }\n+  else if (ops->code == DOT_PROD_EXPR)\n+    {\n+      enum optab_subtype subtype = optab_default;\n+      signop sign1 = TYPE_SIGN (TREE_TYPE (oprnd0));\n+      signop sign2 = TYPE_SIGN (TREE_TYPE (oprnd1));\n+      if (sign1 == sign2)\n+\t;\n+      else if (sign1 == SIGNED && sign2 == UNSIGNED)\n+\t{\n+\t  subtype = optab_vector_mixed_sign;\n+\t  /* Same as optab_vector_mixed_sign but flip the operands.  */\n+\t  std::swap (op0, op1);\n+\t}\n+      else if (sign1 == UNSIGNED && sign2 == SIGNED)\n+\tsubtype = optab_vector_mixed_sign;\n+      else\n+\tgcc_unreachable ();\n+\n+      widen_pattern_optab\n+\t= optab_for_tree_code (ops->code, TREE_TYPE (oprnd0), subtype);\n+    }\n   else\n     widen_pattern_optab\n       = optab_for_tree_code (ops->code, TREE_TYPE (oprnd0), optab_default);\n@@ -298,10 +324,7 @@ expand_widen_pattern_expr (sepops ops, rtx op0, rtx op1, rtx wide_op,\n   gcc_assert (icode != CODE_FOR_nothing);\n \n   if (nops >= 2)\n-    {\n-      oprnd1 = ops->op1;\n-      tmode1 = TYPE_MODE (TREE_TYPE (oprnd1));\n-    }\n+    tmode1 = TYPE_MODE (TREE_TYPE (oprnd1));\n   else if (sbool)\n     {\n       nops = 2;\n@@ -316,7 +339,6 @@ expand_widen_pattern_expr (sepops ops, rtx op0, rtx op1, rtx wide_op,\n     {\n       gcc_assert (tmode1 == tmode0);\n       gcc_assert (op1);\n-      oprnd2 = ops->op2;\n       wmode = TYPE_MODE (TREE_TYPE (oprnd2));\n     }\n "}, {"sha": "201b8aae1c03d4e63628a43bce9cf5d25ac0e912", "filename": "gcc/optabs.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0a6b213abf6843b59cdea6399030e828109551/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0a6b213abf6843b59cdea6399030e828109551/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=ab0a6b213abf6843b59cdea6399030e828109551", "patch": "@@ -352,6 +352,7 @@ OPTAB_D (uavg_ceil_optab, \"uavg$a3_ceil\")\n OPTAB_D (sdot_prod_optab, \"sdot_prod$I$a\")\n OPTAB_D (ssum_widen_optab, \"widen_ssum$I$a3\")\n OPTAB_D (udot_prod_optab, \"udot_prod$I$a\")\n+OPTAB_D (usdot_prod_optab, \"usdot_prod$I$a\")\n OPTAB_D (usum_widen_optab, \"widen_usum$I$a3\")\n OPTAB_D (usad_optab, \"usad$I$a\")\n OPTAB_D (ssad_optab, \"ssad$I$a\")"}, {"sha": "28208477b6a25f4bd38ede74884aa8a57c2e3566", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0a6b213abf6843b59cdea6399030e828109551/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0a6b213abf6843b59cdea6399030e828109551/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=ab0a6b213abf6843b59cdea6399030e828109551", "patch": "@@ -4438,7 +4438,8 @@ verify_gimple_assign_ternary (gassign *stmt)\n \t\t  && !SCALAR_FLOAT_TYPE_P (rhs1_type))\n \t\t || (!INTEGRAL_TYPE_P (lhs_type)\n \t\t     && !SCALAR_FLOAT_TYPE_P (lhs_type))))\n-\t    || !types_compatible_p (rhs1_type, rhs2_type)\n+\t    /* rhs1_type and rhs2_type may differ in sign.  */\n+\t    || !tree_nop_conversion_p (rhs1_type, rhs2_type)\n \t    || !useless_type_conversion_p (lhs_type, rhs3_type)\n \t    || maybe_lt (GET_MODE_SIZE (element_mode (rhs3_type)),\n \t\t\t 2 * GET_MODE_SIZE (element_mode (rhs1_type))))"}, {"sha": "fc3dab0d143a18572ebec197893fdf82bffbcabc", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0a6b213abf6843b59cdea6399030e828109551/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0a6b213abf6843b59cdea6399030e828109551/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=ab0a6b213abf6843b59cdea6399030e828109551", "patch": "@@ -6661,6 +6661,12 @@ vectorizable_reduction (loop_vec_info loop_vinfo,\n   bool lane_reduc_code_p\n     = (code == DOT_PROD_EXPR || code == WIDEN_SUM_EXPR || code == SAD_EXPR);\n   int op_type = TREE_CODE_LENGTH (code);\n+  enum optab_subtype optab_query_kind = optab_vector;\n+  if (code == DOT_PROD_EXPR\n+      && TYPE_SIGN (TREE_TYPE (gimple_assign_rhs1 (stmt)))\n+\t   != TYPE_SIGN (TREE_TYPE (gimple_assign_rhs2 (stmt))))\n+    optab_query_kind = optab_vector_mixed_sign;\n+\n \n   scalar_dest = gimple_assign_lhs (stmt);\n   scalar_type = TREE_TYPE (scalar_dest);\n@@ -7189,7 +7195,7 @@ vectorizable_reduction (loop_vec_info loop_vinfo,\n       bool ok = true;\n \n       /* 4.1. check support for the operation in the loop  */\n-      optab optab = optab_for_tree_code (code, vectype_in, optab_vector);\n+      optab optab = optab_for_tree_code (code, vectype_in, optab_query_kind);\n       if (!optab)\n \t{\n \t  if (dump_enabled_p ())"}, {"sha": "71533e61c934c63dd05a33c8f7159185e9b11a1b", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 65, "deletions": 21, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0a6b213abf6843b59cdea6399030e828109551/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0a6b213abf6843b59cdea6399030e828109551/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=ab0a6b213abf6843b59cdea6399030e828109551", "patch": "@@ -191,9 +191,9 @@ vect_get_external_def_edge (vec_info *vinfo, tree var)\n }\n \n /* Return true if the target supports a vector version of CODE,\n-   where CODE is known to map to a direct optab.  ITYPE specifies\n-   the type of (some of) the scalar inputs and OTYPE specifies the\n-   type of the scalar result.\n+   where CODE is known to map to a direct optab with the given SUBTYPE.\n+   ITYPE specifies the type of (some of) the scalar inputs and OTYPE\n+   specifies the type of the scalar result.\n \n    If CODE allows the inputs and outputs to have different type\n    (such as for WIDEN_SUM_EXPR), it is the input mode rather\n@@ -208,7 +208,8 @@ vect_get_external_def_edge (vec_info *vinfo, tree var)\n static bool\n vect_supportable_direct_optab_p (vec_info *vinfo, tree otype, tree_code code,\n \t\t\t\t tree itype, tree *vecotype_out,\n-\t\t\t\t tree *vecitype_out = NULL)\n+\t\t\t\t tree *vecitype_out = NULL,\n+\t\t\t\t enum optab_subtype subtype = optab_default)\n {\n   tree vecitype = get_vectype_for_scalar_type (vinfo, itype);\n   if (!vecitype)\n@@ -218,7 +219,7 @@ vect_supportable_direct_optab_p (vec_info *vinfo, tree otype, tree_code code,\n   if (!vecotype)\n     return false;\n \n-  optab optab = optab_for_tree_code (code, vecitype, optab_default);\n+  optab optab = optab_for_tree_code (code, vecitype, subtype);\n   if (!optab)\n     return false;\n \n@@ -521,6 +522,7 @@ vect_joust_widened_type (tree type, tree new_type, tree *common_type)\n   unsigned int precision = MAX (TYPE_PRECISION (*common_type),\n \t\t\t\tTYPE_PRECISION (new_type));\n   precision *= 2;\n+\n   if (precision * 2 > TYPE_PRECISION (type))\n     return false;\n \n@@ -539,14 +541,19 @@ vect_joust_widened_type (tree type, tree new_type, tree *common_type)\n    to a type that (a) is narrower than the result of STMT_INFO and\n    (b) can hold all leaf operand values.\n \n+   If SUBTYPE then allow that the signs of the operands\n+   may differ in signs but not in precision.  SUBTYPE is updated to reflect\n+   this.\n+\n    Return 0 if STMT_INFO isn't such a tree, or if no such COMMON_TYPE\n    exists.  */\n \n static unsigned int\n vect_widened_op_tree (vec_info *vinfo, stmt_vec_info stmt_info, tree_code code,\n \t\t      tree_code widened_code, bool shift_p,\n \t\t      unsigned int max_nops,\n-\t\t      vect_unpromoted_value *unprom, tree *common_type)\n+\t\t      vect_unpromoted_value *unprom, tree *common_type,\n+\t\t      enum optab_subtype *subtype = NULL)\n {\n   /* Check for an integer operation with the right code.  */\n   gassign *assign = dyn_cast <gassign *> (stmt_info->stmt);\n@@ -607,7 +614,8 @@ vect_widened_op_tree (vec_info *vinfo, stmt_vec_info stmt_info, tree_code code,\n \t\t= vinfo->lookup_def (this_unprom->op);\n \t      nops = vect_widened_op_tree (vinfo, def_stmt_info, code,\n \t\t\t\t\t   widened_code, shift_p, max_nops,\n-\t\t\t\t\t   this_unprom, common_type);\n+\t\t\t\t\t   this_unprom, common_type,\n+\t\t\t\t\t   subtype);\n \t      if (nops == 0)\n \t\treturn 0;\n \n@@ -625,7 +633,18 @@ vect_widened_op_tree (vec_info *vinfo, stmt_vec_info stmt_info, tree_code code,\n \t\t*common_type = this_unprom->type;\n \t      else if (!vect_joust_widened_type (type, this_unprom->type,\n \t\t\t\t\t\t common_type))\n-\t\treturn 0;\n+\t\t{\n+\t\t  if (subtype)\n+\t\t    {\n+\t\t      /* See if we can sign extend the smaller type.  */\n+\t\t      if (TYPE_PRECISION (this_unprom->type)\n+\t\t\t  > TYPE_PRECISION (*common_type))\n+\t\t\t*common_type = this_unprom->type;\n+\t\t      *subtype = optab_vector_mixed_sign;\n+\t\t    }\n+\t\t  else\n+\t\t    return 0;\n+\t\t}\n \t    }\n \t}\n       next_op += nops;\n@@ -725,12 +744,22 @@ vect_split_statement (vec_info *vinfo, stmt_vec_info stmt2_info, tree new_rhs,\n \n /* Convert UNPROM to TYPE and return the result, adding new statements\n    to STMT_INFO's pattern definition statements if no better way is\n-   available.  VECTYPE is the vector form of TYPE.  */\n+   available.  VECTYPE is the vector form of TYPE.\n+\n+   If SUBTYPE then convert the type based on the subtype.  */\n \n static tree\n vect_convert_input (vec_info *vinfo, stmt_vec_info stmt_info, tree type,\n-\t\t    vect_unpromoted_value *unprom, tree vectype)\n+\t\t    vect_unpromoted_value *unprom, tree vectype,\n+\t\t    enum optab_subtype subtype = optab_default)\n {\n+\n+  /* Update the type if the signs differ.  */\n+  if (subtype == optab_vector_mixed_sign\n+      && TYPE_SIGN (type) != TYPE_SIGN (TREE_TYPE (unprom->op)))\n+    type = build_nonstandard_integer_type (TYPE_PRECISION (type),\n+\t\t\t\t\t   TYPE_SIGN (unprom->type));\n+\n   /* Check for a no-op conversion.  */\n   if (types_compatible_p (type, TREE_TYPE (unprom->op)))\n     return unprom->op;\n@@ -806,24 +835,27 @@ vect_convert_input (vec_info *vinfo, stmt_vec_info stmt_info, tree type,\n }\n \n /* Invoke vect_convert_input for N elements of UNPROM and store the\n-   result in the corresponding elements of RESULT.  */\n+   result in the corresponding elements of RESULT.\n+\n+   If SUBTYPE then convert the type based on the subtype.  */\n \n static void\n vect_convert_inputs (vec_info *vinfo, stmt_vec_info stmt_info, unsigned int n,\n \t\t     tree *result, tree type, vect_unpromoted_value *unprom,\n-\t\t     tree vectype)\n+\t\t     tree vectype, enum optab_subtype subtype = optab_default)\n {\n   for (unsigned int i = 0; i < n; ++i)\n     {\n       unsigned int j;\n       for (j = 0; j < i; ++j)\n \tif (unprom[j].op == unprom[i].op)\n \t  break;\n+\n       if (j < i)\n \tresult[i] = result[j];\n       else\n \tresult[i] = vect_convert_input (vinfo, stmt_info,\n-\t\t\t\t\ttype, &unprom[i], vectype);\n+\t\t\t\t\ttype, &unprom[i], vectype, subtype);\n     }\n }\n \n@@ -895,7 +927,8 @@ vect_reassociating_reduction_p (vec_info *vinfo,\n \n    Try to find the following pattern:\n \n-     type x_t, y_t;\n+     type1a x_t\n+     type1b y_t;\n      TYPE1 prod;\n      TYPE2 sum = init;\n    loop:\n@@ -908,9 +941,9 @@ vect_reassociating_reduction_p (vec_info *vinfo,\n      [S6  prod = (TYPE2) prod;  #optional]\n      S7  sum_1 = prod + sum_0;\n \n-   where 'TYPE1' is exactly double the size of type 'type', and 'TYPE2' is the\n-   same size of 'TYPE1' or bigger. This is a special case of a reduction\n-   computation.\n+   where 'TYPE1' is exactly double the size of type 'type1a' and 'type1b',\n+   the sign of 'TYPE1' must be one of 'type1a' or 'type1b' but the sign of\n+   'type1a' and 'type1b' can differ.\n \n    Input:\n \n@@ -953,7 +986,8 @@ vect_recog_dot_prod_pattern (vec_info *vinfo,\n      In which\n      - DX is double the size of X\n      - DY is double the size of Y\n-     - DX, DY, DPROD all have the same type\n+     - DX, DY, DPROD all have the same type but the sign\n+       between X, Y and DPROD can differ.\n      - sum is the same size of DPROD or bigger\n      - sum has been recognized as a reduction variable.\n \n@@ -991,8 +1025,18 @@ vect_recog_dot_prod_pattern (vec_info *vinfo,\n   /* FORNOW.  Can continue analyzing the def-use chain when this stmt in a phi\n      inside the loop (in case we are analyzing an outer-loop).  */\n   vect_unpromoted_value unprom0[2];\n+  enum optab_subtype subtype = optab_vector;\n   if (!vect_widened_op_tree (vinfo, mult_vinfo, MULT_EXPR, WIDEN_MULT_EXPR,\n-\t\t\t     false, 2, unprom0, &half_type))\n+\t\t\t     false, 2, unprom0, &half_type, &subtype))\n+    return NULL;\n+\n+  /* If there are two widening operations, make sure they agree on the sign\n+     of the extension.  The result of an optab_vector_mixed_sign operation\n+     is signed; otherwise, the result has the same sign as the operands.  */\n+  if (TYPE_PRECISION (unprom_mult.type) != TYPE_PRECISION (type)\n+      && (subtype == optab_vector_mixed_sign\n+\t? TYPE_UNSIGNED (unprom_mult.type)\n+\t: TYPE_SIGN (unprom_mult.type) != TYPE_SIGN (half_type)))\n     return NULL;\n \n   /* If there are two widening operations, make sure they agree on\n@@ -1005,13 +1049,13 @@ vect_recog_dot_prod_pattern (vec_info *vinfo,\n \n   tree half_vectype;\n   if (!vect_supportable_direct_optab_p (vinfo, type, DOT_PROD_EXPR, half_type,\n-\t\t\t\t\ttype_out, &half_vectype))\n+\t\t\t\t\ttype_out, &half_vectype, subtype))\n     return NULL;\n \n   /* Get the inputs in the appropriate types.  */\n   tree mult_oprnd[2];\n   vect_convert_inputs (vinfo, stmt_vinfo, 2, mult_oprnd, half_type,\n-\t\t       unprom0, half_vectype);\n+\t\t       unprom0, half_vectype, subtype);\n \n   var = vect_recog_temp_ssa_var (type, NULL);\n   pattern_stmt = gimple_build_assign (var, DOT_PROD_EXPR,"}]}