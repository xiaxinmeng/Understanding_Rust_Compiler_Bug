{"sha": "e7f49d92ca829a0a51c1cb3ae26ebb0cb08f0fed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdmNDlkOTJjYTgyOWEwYTUxYzFjYjNhZTI2ZWJiMGNiMDhmMGZlZA==", "commit": {"author": {"name": "Terry Guo", "email": "terry.guo@arm.com", "date": "2013-01-13T10:12:07Z"}, "committer": {"name": "Xuepeng Guo", "email": "xguo@gcc.gnu.org", "date": "2013-01-13T10:12:07Z"}, "message": "Makefile.in (s-mlib): New argument MULTILIB_REUSE.\n\n2013-01-13  Terry Guo  <terry.guo@arm.com>\n\n        * gcc/Makefile.in (s-mlib): New argument MULTILIB_REUSE.\n        * gcc/doc/fragments.texi: Document MULTILIB_REUSE.\n        * gcc/gcc.c (multilib_reuse): New internal spec.\n        (set_multilib_dir): Also search multilib from multilib_reuse.\n        * gcc/genmultilib (tmpmultilib3): Refactor code.\n        (tmpmultilib4): Ditto.\n        (multilib_reuse): New multilib argument.\n\nFrom-SVN: r195134", "tree": {"sha": "a616ef9bf816a6b420d0becce38f494e52da6fe5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a616ef9bf816a6b420d0becce38f494e52da6fe5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7f49d92ca829a0a51c1cb3ae26ebb0cb08f0fed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f49d92ca829a0a51c1cb3ae26ebb0cb08f0fed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7f49d92ca829a0a51c1cb3ae26ebb0cb08f0fed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f49d92ca829a0a51c1cb3ae26ebb0cb08f0fed/comments", "author": null, "committer": null, "parents": [{"sha": "899d52c6e21ab11ef716816a433c4c583e0052d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/899d52c6e21ab11ef716816a433c4c583e0052d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/899d52c6e21ab11ef716816a433c4c583e0052d1"}], "stats": {"total": 224, "additions": 173, "deletions": 51}, "files": [{"sha": "c4706588ba742b945089359447aa08cc8eea2103", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f49d92ca829a0a51c1cb3ae26ebb0cb08f0fed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f49d92ca829a0a51c1cb3ae26ebb0cb08f0fed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7f49d92ca829a0a51c1cb3ae26ebb0cb08f0fed", "patch": "@@ -1,3 +1,13 @@\n+2013-01-13  Terry Guo  <terry.guo@arm.com>\n+\n+\t* gcc/Makefile.in (s-mlib): New argument MULTILIB_REUSE.\n+\t* gcc/doc/fragments.texi: Document MULTILIB_REUSE.\n+\t* gcc/gcc.c (multilib_reuse): New internal spec.\n+\t(set_multilib_dir): Also search multilib from multilib_reuse.\n+\t* gcc/genmultilib (tmpmultilib3): Refactor code.\n+\t(tmpmultilib4): Ditto.\n+\t(multilib_reuse): New multilib argument.\n+\n 2013-01-13  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* Makefile.in: Update copyright."}, {"sha": "55b4d2dbce90f23f1418a20e903fefcff40eee13", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f49d92ca829a0a51c1cb3ae26ebb0cb08f0fed/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f49d92ca829a0a51c1cb3ae26ebb0cb08f0fed/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e7f49d92ca829a0a51c1cb3ae26ebb0cb08f0fed", "patch": "@@ -1828,10 +1828,12 @@ s-mlib: $(srcdir)/genmultilib Makefile\n \t    \"$(MULTILIB_OSDIRNAMES)\" \\\n \t    \"$(MULTILIB_REQUIRED)\" \\\n \t    \"$(MULTIARCH_DIRNAME)\" \\\n+\t    \"$(MULTILIB_REUSE)\" \\\n \t    \"@enable_multilib@\" \\\n \t    > tmp-mlib.h; \\\n \telse \\\n-\t  $(SHELL) $(srcdir)/genmultilib '' '' '' '' '' '' '' '' \"$(MULTIARCH_DIRNAME)\" no \\\n+\t  $(SHELL) $(srcdir)/genmultilib '' '' '' '' '' '' '' '' \\\n+\t    \"$(MULTIARCH_DIRNAME)\" '' no \\\n \t    > tmp-mlib.h; \\\n \tfi\n \t$(SHELL) $(srcdir)/../move-if-change tmp-mlib.h multilib.h"}, {"sha": "b9a0c34b690c3146863190d1e5f8218308eecdde", "filename": "gcc/doc/fragments.texi", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f49d92ca829a0a51c1cb3ae26ebb0cb08f0fed/gcc%2Fdoc%2Ffragments.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f49d92ca829a0a51c1cb3ae26ebb0cb08f0fed/gcc%2Fdoc%2Ffragments.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ffragments.texi?ref=e7f49d92ca829a0a51c1cb3ae26ebb0cb08f0fed", "patch": "@@ -148,6 +148,35 @@ The @code{MULTILIB_REQUIRED} can be used together with\n @code{MULTILIB_OPTIONS} will be filtered by @code{MULTILIB_EXCEPTIONS}\n and then by @code{MULTILIB_REQUIRED}.\n \n+@findex MULTILIB_REUSE\n+@item MULTILIB_REUSE\n+Sometimes it is desirable to reuse one existing multilib for different\n+sets of options.  Such kind of reuse can minimize the number of multilib\n+variants.  And for some targets it is better to reuse an existing multilib\n+than to fall back to default multilib when there is no corresponding multilib.\n+This can be done by adding reuse rules to @code{MULTILIB_REUSE}.\n+\n+A reuse rule is comprised of two parts connected by equality sign.  The left part\n+is option set used to build multilib and the right part is option set that will\n+reuse this multilib.  The order of options in the left part matters and should be\n+same with those specified in @code{MULTILIB_REQUIRED} or aligned with order in\n+@code{MULTILIB_OPTIONS}.  There is no such limitation for options in right part\n+as we don't build multilib from them.  But the equality sign in both parts should\n+be replaced with period.\n+\n+The @code{MULTILIB_REUSE} is different from @code{MULTILIB_MATCHES} in that it\n+sets up relations between two option sets rather than two options.  Here is an\n+example to demo how we reuse libraries built in Thumb mode for applications built\n+in ARM mode:\n+@smallexample\n+@code{MULTILIB_REUSE} = mthumb/march.armv7-r=marm/march.armv7-r\n+@end smallexample\n+\n+Before the advent of @code{MULTILIB_REUSE}, GCC select multilib by comparing command\n+line options with options used to build multilib.  The @code{MULTILIB_REUSE} is\n+complementary to that way.  Only when the original comparison matches nothing it will\n+work to see if it is OK to reuse some existing multilib.\n+\n @findex MULTILIB_EXTRA_OPTS\n @item MULTILIB_EXTRA_OPTS\n Sometimes it is desirable that when building multiple versions of"}, {"sha": "ff0f5845224ded9eb2b51bcedf17ac673186aace", "filename": "gcc/gcc.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f49d92ca829a0a51c1cb3ae26ebb0cb08f0fed/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f49d92ca829a0a51c1cb3ae26ebb0cb08f0fed/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=e7f49d92ca829a0a51c1cb3ae26ebb0cb08f0fed", "patch": "@@ -855,6 +855,7 @@ static const char *multilib_select;\n static const char *multilib_matches;\n static const char *multilib_defaults;\n static const char *multilib_exclusions;\n+static const char *multilib_reuse;\n \n /* Check whether a particular argument is a default argument.  */\n \n@@ -1248,6 +1249,7 @@ static struct spec_list static_specs[] =\n   INIT_STATIC_SPEC (\"multilib_matches\",\t\t&multilib_matches),\n   INIT_STATIC_SPEC (\"multilib_exclusions\",\t&multilib_exclusions),\n   INIT_STATIC_SPEC (\"multilib_options\",\t\t&multilib_options),\n+  INIT_STATIC_SPEC (\"multilib_reuse\",\t\t&multilib_reuse),\n   INIT_STATIC_SPEC (\"linker\",\t\t\t&linker_name_spec),\n   INIT_STATIC_SPEC (\"linker_plugin_file\",\t&linker_plugin_file_spec),\n   INIT_STATIC_SPEC (\"lto_wrapper\",\t\t&lto_wrapper_spec),\n@@ -6323,6 +6325,13 @@ main (int argc, char **argv)\n     obstack_1grow (&multilib_obstack, 0);\n     multilib_exclusions = XOBFINISH (&multilib_obstack, const char *);\n \n+    q = multilib_reuse_raw;\n+    while ((p = *q++) != (char *) 0)\n+      obstack_grow (&multilib_obstack, p, strlen (p));\n+\n+    obstack_1grow (&multilib_obstack, 0);\n+    multilib_reuse = XOBFINISH (&multilib_obstack, const char *);\n+\n     need_space = FALSE;\n     for (i = 0; i < ARRAY_SIZE (multilib_defaults_raw); i++)\n       {\n@@ -7536,6 +7545,12 @@ set_multilib_dir (void)\n \n   first = 1;\n   p = multilib_select;\n+\n+  /* Append multilib reuse rules if any.  With those rules, we can reuse\n+     one multilib for certain different options sets.  */\n+  if (strlen (multilib_reuse) > 0)\n+    p = concat (p, multilib_reuse, NULL);\n+\n   while (*p != '\\0')\n     {\n       /* Ignore newlines.  */\n@@ -7552,8 +7567,8 @@ set_multilib_dir (void)\n \t  if (*p == '\\0')\n \t    {\n \t    invalid_select:\n-\t      fatal_error (\"multilib select %qs is invalid\",\n-\t\t\t   multilib_select);\n+\t      fatal_error (\"multilib select %qs %qs is invalid\",\n+\t\t\t   multilib_select, multilib_reuse);\n \t    }\n \t  ++p;\n \t}"}, {"sha": "4dca65d68ff35361b69cd47f054e0a0e6cf77b0c", "filename": "gcc/genmultilib", "status": "modified", "additions": 114, "deletions": 48, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f49d92ca829a0a51c1cb3ae26ebb0cb08f0fed/gcc%2Fgenmultilib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f49d92ca829a0a51c1cb3ae26ebb0cb08f0fed/gcc%2Fgenmultilib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmultilib?ref=e7f49d92ca829a0a51c1cb3ae26ebb0cb08f0fed", "patch": "@@ -85,6 +85,9 @@\n \n # The optional ninth argument is the multiarch name.\n \n+# The optional tenth argument specifies how to reuse multilib for different\n+# option sets.\n+\n # The last option should be \"yes\" if multilibs are enabled.  If it is not\n # \"yes\", all GCC multilib dir names will be \".\".\n \n@@ -105,7 +108,7 @@\n #   genmultilib 'm64/m32 mno-app-regs|mcmodel=medany' '64 32 alt'\n #\t\t'mcmodel?medany=mcmodel?medmid' 'm32/mno-app-regs* m32/mcmodel=*'\n #\t\t'' 'm32/!m64/mno-app-regs m32/!m64/mcmodel=medany'\n-#\t\t'../lib64 ../lib32 alt' '' yes\n+#\t\t'../lib64 ../lib32 alt' '' '' '' yes\n # This produces:\n #   \". !m64 !m32 !mno-app-regs !mcmodel=medany;\",\n #   \"64:../lib64 m64 !m32 !mno-app-regs !mcmodel=medany;\",\n@@ -135,7 +138,8 @@ exclusions=$6\n osdirnames=$7\n multilib_required=$8\n multiarch=$9\n-enable_multilib=${10}\n+multilib_reuse=${10}\n+enable_multilib=${11}\n \n echo \"static const char *const multilib_raw[] = {\"\n \n@@ -349,61 +353,94 @@ done\n optout=`echo ${optout} | sed -e 's/^ //'`\n echo \"\\\".${defaultosdirname} ${optout};\\\",\"\n \n+# This part of code convert an option combination to\n+# its corresponding directory names.\n+# The directory names will be deduced from MULTILIB_DIRNAMES,\n+# MULTILIB_OSDIRNAMES or the option combination itself.\n+rm -rf tmpmultilib3\n+cat >tmpmultilib3 <<\\EOF\n+#!/bin/sh\n+\n+dirout=\n+combo=$1\n+todirnames=$2\n+toosdirnames=$3\n+enable_multilib=$4\n+\n+if [ -n \"${todirnames}\" ]; then\n+  dirout=`echo ${combo} | sed ${todirnames}`\n+else\n+  dirout=`echo ${combo} | sed -e 's/=/-/g'`\n+fi\n+# Remove the leading and trailing slashes.\n+dirout=`echo ${dirout} | sed -e 's|^/||' -e 's|/*:/*|:|' -e 's|/$||g'`\n+\n+# Use the OS directory names rather than the option names.\n+if [ -n \"${toosdirnames}\" ]; then\n+  osdirout=`echo ${combo} | sed ${toosdirnames}`\n+  # Remove the leading and trailing slashes.\n+  osdirout=`echo ${osdirout} | sed -e 's|^/||' -e 's|/*:/*|:|' -e 's|/$||g'`\n+  if [ \"x${enable_multilib}\" != xyes ]; then\n+    dirout=\".:${osdirout}\"\n+    disable_multilib=yes\n+  else\n+    case \"${osdirout}\" in\n+      !*)\n+\tdirout=`echo ${osdirout} | sed 's/^!//'`\n+\t;;\n+       *)\n+\tdirout=\"${dirout}:${osdirout}\"\n+\t;;\n+    esac\n+  fi\n+else\n+  if [ \"x${enable_multilib}\" != xyes ]; then\n+    # genmultilib with --disable-multilib should be\n+    # called with '' '' '' '' '' '' '' no\n+    # if MULTILIB_OSDIRNAMES is empty.\n+    exit 1\n+  fi\n+fi\n+echo \"${dirout}\"\n+EOF\n+chmod +x tmpmultilib3\n+\n+# Script to look through the options and output each option that is present,\n+# and negate each option that is not present.\n+rm -rf tmpmultilib4\n+cat > tmpmultilib4 <<\\EOF\n+#!/bin/sh\n+\n+optout=\n+combo=$1\n+options=$2\n+\n+for set in ${options}; do\n+  setopts=`echo ${set} | sed -e 's_[/|]_ _g'`\n+  for opt in ${setopts}; do\n+    if expr \"${combo} \" : \".*/${opt}/.*\" > /dev/null; then\n+      optout=\"${optout} ${opt}\"\n+    else\n+      optout=\"${optout} !${opt}\"\n+    fi\n+  done\n+done\n+optout=`echo ${optout} | sed -e 's/^ //'`\n+echo \"${optout}\"\n+EOF\n+chmod +x tmpmultilib4\n+\n # Work over the list of combinations.  We have to translate each one\n # to use the directory names rather than the option names, we have to\n # include the information in matches, and we have to generate the\n # correct list of options and negations.\n for combo in ${combinations}; do\n   # Use the directory names rather than the option names.\n-  if [ -n \"${todirnames}\" ]; then\n-    dirout=`echo ${combo} | sed ${todirnames}`\n-  else\n-    dirout=`echo ${combo} | sed -e 's/=/-/g'`\n-  fi\n-  # Remove the leading and trailing slashes.\n-  dirout=`echo ${dirout} | sed -e 's|^/||' -e 's|/*:/*|:|' -e 's|/$||g'`\n-\n-  # Use the OS directory names rather than the option names.\n-  if [ -n \"${toosdirnames}\" ]; then\n-    osdirout=`echo ${combo} | sed ${toosdirnames}`\n-    # Remove the leading and trailing slashes.\n-    osdirout=`echo ${osdirout} | sed -e 's|^/||' -e 's|/*:/*|:|' -e 's|/$||g'`\n-    if [ \"x${enable_multilib}\" != xyes ]; then\n-      dirout=\".:${osdirout}\"\n-      disable_multilib=yes\n-    else\n-      case \"${osdirout}\" in\n-        !*)\n-\t  dirout=`echo ${osdirout} | sed 's/^!//'`\n-\t  ;;\n-\t*)\n-\t  dirout=\"${dirout}:${osdirout}\"\n-\t  ;;\n-      esac\n-    fi\n-  else\n-    if [ \"x${enable_multilib}\" != xyes ]; then\n-      # genmultilib with --disable-multilib should be\n-      # called with '' '' '' '' '' '' '' no\n-      # if MULTILIB_OSDIRNAMES is empty.\n-      exit 1\n-    fi\n-  fi\n+  dirout=`./tmpmultilib3 \"${combo}\" \"${todirnames}\" \"${toosdirnames}\" \"${enable_multilib}\"`\n \n   # Look through the options.  We must output each option that is\n   # present, and negate each option that is not present.\n-  optout=\n-  for set in ${options}; do\n-    setopts=`echo ${set} | sed -e 's_[/|]_ _g'`\n-    for opt in ${setopts}; do\n-      if expr \"${combo} \" : \".*/${opt}/.*\" > /dev/null; then\n-\toptout=\"${optout} ${opt}\"\n-      else\n-\toptout=\"${optout} !${opt}\"\n-      fi\n-    done\n-  done\n-  optout=`echo ${optout} | sed -e 's/^ //'`\n+  optout=`./tmpmultilib4 \"${combo}\" \"${options}\"`\n \n   # Output the line with all appropriate matches.\n   dirout=\"${dirout}\" optout=\"${optout}\" ./tmpmultilib2\n@@ -413,6 +450,35 @@ done\n echo \"NULL\"\n echo \"};\"\n \n+# Output rules used for multilib reuse.\n+echo \"\"\n+echo \"static const char *const multilib_reuse_raw[] = {\"\n+for rrule in ${multilib_reuse}; do\n+  # The left part of the rule are the options we used to build multilib.\n+  # The right part of the rule are the options that can reuse this multilib.\n+  combo=`echo ${rrule} | sed -e 's/=.*$//' -e 's/\\./=/g'`\n+  copts=`echo ${rrule} | sed -e 's/^.*=//' -e 's/\\./=/g'`\n+  # The variable ${combinations} are the option combinations we will build\n+  # multilib from.  If the combination in the left part of reuse rule isn't\n+  # in this variable, it means no multilib will be built for current reuse\n+  # rule.  Thus the reuse purpose specified by current rule is meaningless.\n+  if expr \"${combinations} \" : \".*/${combo}/.*\" > /dev/null; then\n+    combo=\"/${combo}/\"\n+    dirout=`./tmpmultilib3 \"${combo}\" \"${todirnames}\" \"${toosdirnames}\" \"${enable_multilib}\"`\n+    copts=\"/${copts}/\"\n+    optout=`./tmpmultilib4 \"${copts}\" \"${options}\"`\n+    # Output the line with all appropriate matches.\n+    dirout=\"${dirout}\" optout=\"${optout}\" ./tmpmultilib2\n+  else\n+    echo \"The rule ${rrule} is trying to reuse nonexistent multilib.\"\n+    exit 1\n+  fi\n+done\n+\n+# Terminate the list of string.\n+echo \"NULL\"\n+echo \"};\"\n+\n # Output all of the matches now as option and that is the same as that, with\n # a semicolon trailer.  Include all of the normal options as well.\n # Note, the format of the matches is reversed compared"}]}