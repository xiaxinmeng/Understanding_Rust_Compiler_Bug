{"sha": "f77f3adebde0547ed734a260f29e5afc85dcbe49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc3ZjNhZGViZGUwNTQ3ZWQ3MzRhMjYwZjI5ZTVhZmM4NWRjYmU0OQ==", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2020-03-02T08:35:58Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-09-09T08:09:05Z"}, "message": "AVX512FP16: Add testcase for vaddph/vsubph/vmulph/vdivph.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/i386/avx512fp16-helper.h: New header file for\n\tFP16 runtime test.\n\t* gcc.target/i386/avx512fp16-vaddph-1a.c: New test.\n\t* gcc.target/i386/avx512fp16-vaddph-1b.c: Ditto.\n\t* gcc.target/i386/avx512fp16-vdivph-1a.c: Ditto.\n\t* gcc.target/i386/avx512fp16-vdivph-1b.c: Ditto.\n\t* gcc.target/i386/avx512fp16-vmulph-1a.c: Ditto.\n\t* gcc.target/i386/avx512fp16-vmulph-1b.c: Ditto.\n\t* gcc.target/i386/avx512fp16-vsubph-1a.c: Ditto.\n\t* gcc.target/i386/avx512fp16-vsubph-1b.c: Ditto.\n\t* gcc.target/i386/avx512fp16vl-vaddph-1a.c: Ditto.\n\t* gcc.target/i386/avx512fp16vl-vaddph-1b.c: Ditto.\n\t* gcc.target/i386/avx512fp16vl-vdivph-1a.c: Ditto.\n\t* gcc.target/i386/avx512fp16vl-vdivph-1b.c: Ditto.\n\t* gcc.target/i386/avx512fp16vl-vmulph-1a.c: Ditto.\n\t* gcc.target/i386/avx512fp16vl-vmulph-1b.c: Ditto.\n\t* gcc.target/i386/avx512fp16vl-vsubph-1a.c: Ditto.\n\t* gcc.target/i386/avx512fp16vl-vsubph-1b.c: Ditto.", "tree": {"sha": "0064497cdb0852a0532924ee3e084fb9fa5b4192", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0064497cdb0852a0532924ee3e084fb9fa5b4192"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f77f3adebde0547ed734a260f29e5afc85dcbe49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f77f3adebde0547ed734a260f29e5afc85dcbe49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f77f3adebde0547ed734a260f29e5afc85dcbe49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f77f3adebde0547ed734a260f29e5afc85dcbe49/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd7a34ef5564f4240c3839c89d7e695c9ef4e49d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd7a34ef5564f4240c3839c89d7e695c9ef4e49d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd7a34ef5564f4240c3839c89d7e695c9ef4e49d"}], "stats": {"total": 865, "additions": 865, "deletions": 0}, "files": [{"sha": "9fde88a4f7bc0519de88589a76d5a4c907c62e54", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-helper.h", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-helper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-helper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-helper.h?ref=f77f3adebde0547ed734a260f29e5afc85dcbe49", "patch": "@@ -0,0 +1,207 @@\n+/* This file is used for emulation of avx512fp16 runtime tests. To\n+   verify the correctness of _Float16 type calculation, the idea is\n+   convert _Float16 to float and do emulation using float instructions. \n+   _Float16 type should not be emulate or check by itself.  */\n+\n+#include \"avx512f-helper.h\"\n+#ifndef AVX512FP16_HELPER_INCLUDED\n+#define AVX512FP16_HELPER_INCLUDED\n+\n+#ifdef DEBUG\n+#include <string.h>\n+#endif\n+#include <math.h>\n+#include <limits.h>\n+#include <float.h>\n+\n+/* Useful macros.  */\n+#define NOINLINE __attribute__((noinline,noclone))\n+#define _ROUND_NINT (_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC)\n+#define AVX512F_MAX_ELEM 512 / 32\n+\n+/* Structure for _Float16 emulation  */\n+typedef union\n+{\n+  __m512          zmm;\n+  __m512h         zmmh;\n+  __m256          ymm[2];\n+  __m256h         ymmh[2];\n+  __m256i         ymmi[2];\n+  __m128h         xmmh[4];\n+  unsigned short  u16[32];\n+  unsigned int    u32[16];\n+  float           f32[16];\n+  _Float16        f16[32];\n+} V512;\n+\n+/* Global variables.  */\n+V512 src1, src2, src3;\n+int n_errs = 0;\n+\n+/* Helper function for packing/unpacking ph operands. */\n+void NOINLINE \n+unpack_ph_2twops(V512 src, V512 *op1, V512 *op2)\n+{\n+    V512 v1;\n+\n+    op1->zmm = _mm512_cvtph_ps(src.ymmi[0]);\n+    v1.ymm[0] = _mm512_extractf32x8_ps(src.zmm, 1);\n+    op2->zmm = _mm512_cvtph_ps(v1.ymmi[0]);\n+}\n+\n+V512 NOINLINE\n+pack_twops_2ph(V512 op1, V512 op2)\n+{\n+    V512 v1, v2, v3;\n+\n+    v1.ymmi[0] = _mm512_cvtps_ph(op1.zmm, _MM_FROUND_TO_NEAREST_INT);\n+    v2.ymmi[0] = _mm512_cvtps_ph(op2.zmm, _MM_FROUND_TO_NEAREST_INT);\n+\n+    v3.zmm = _mm512_insertf32x8(v1.zmm, v2.ymm[0], 1);\n+\n+    return v3;\n+}\n+\n+/* Helper function used for result debugging */\n+#ifdef DEBUG\n+void NOINLINE\n+display_ps(const void *p, const char *banner, int n_elems)\n+{\n+    int i;\n+    V512 *v = (V512*)p;\n+\n+    if (banner) {\n+        printf(\"%s\", banner);\n+    }\n+\n+    for (i = 15; i >= n_elems; i--) {\n+        printf(\" --------\");\n+        if (i == 8) {\n+            printf(\"\\n\");\n+            if (banner) {\n+                printf(\"%*s\", (int)strlen(banner), \"\");\n+            }\n+        }\n+    }\n+\n+    for (; i >= 0; i--) {\n+        printf(\" %x\", v->u32[i]);\n+        if (i == 8) {\n+            printf(\"\\n\");\n+            if (banner) {\n+                printf(\"%*s\", (int)strlen(banner), \"\");\n+            }\n+        }\n+    }\n+    printf(\"\\n\");\n+}\n+#endif\n+\n+/* Functions/macros used for init/result checking.\n+   Only check components within AVX512F_LEN.  */\n+#define TO_STRING(x) #x\n+#define STRINGIFY(x) TO_STRING(x)\n+#define NAME_OF(NAME) STRINGIFY(INTRINSIC (NAME))\n+\n+#define CHECK_RESULT(res, exp, size, intrin) \\\n+  check_results ((void*)res, (void*)exp, size,\\\n+\t\t NAME_OF(intrin))\n+\n+/* To evaluate whether result match _Float16 precision,\n+   only the last bit of real/emulate result could be\n+   different.  */\n+void NOINLINE\n+check_results(void *got, void *exp, int n_elems, char *banner)\n+{\n+    int i;\n+    V512 *v1 = (V512*)got;\n+    V512 *v2 = (V512*)exp;\n+\n+    for (i = 0; i < n_elems; i++) {\n+        if (v1->u16[i] != v2->u16[i] &&\n+            ((v1->u16[i] > (v2->u16[i] + 1)) ||\n+             (v1->u16[i] < (v2->u16[i] - 1)))) {\n+\n+#ifdef DEBUG\n+            printf(\"ERROR: %s failed at %d'th element: %x(%f) != %x(%f)\\n\",\n+                   banner ? banner : \"\", i,\n+                   v1->u16[i], *(float *)(&v1->u16[i]),\n+                   v2->u16[i], *(float *)(&v2->u16[i]));\n+            display_ps(got, \"got:\", n_elems);\n+            display_ps(exp, \"exp:\", n_elems);\n+#endif\n+            n_errs++;\n+            break;\n+        }\n+    }\n+}\n+\n+/* Functions for src/dest initialization */\n+void NOINLINE\n+init_src()\n+{\n+    V512 v1, v2, v3, v4;\n+    int i;\n+\n+    for (i = 0; i < AVX512F_MAX_ELEM; i++) {\n+        v1.f32[i] = -i + 1;\n+        v2.f32[i] = i * 0.5f;\n+        v3.f32[i] = i * 2.5f;\n+        v4.f32[i] = i - 0.5f;\n+\n+        src3.u32[i] = (i + 1) * 10;\n+    }\n+\n+    src1 = pack_twops_2ph(v1, v2);\n+    src2 = pack_twops_2ph(v3, v4);\n+}\n+\n+void NOINLINE\n+init_dest(V512 * res, V512 * exp)\n+{\n+    int i;\n+    V512 v1;\n+\n+    for (i = 0; i < AVX512F_MAX_ELEM; i++) {\n+        v1.f32[i] = 12 + 0.5f * i;\n+    }\n+    *res = *exp = pack_twops_2ph(v1, v1);\n+}\n+\n+#define EMULATE(NAME) EVAL(emulate_, NAME, AVX512F_LEN)\n+\n+#endif /* AVX512FP16_HELPER_INCLUDED */\n+\n+/* Macros for AVX512VL Testing. Include V512 component usage\n+   and mask type for emulation. */\n+\n+#if AVX512F_LEN == 256\n+#undef HF\n+#undef SF\n+#undef NET_MASK \n+#undef MASK_VALUE \n+#undef ZMASK_VALUE \n+#define NET_MASK 0xffff\n+#define MASK_VALUE 0xcccc\n+#define ZMASK_VALUE 0xfcc1\n+#define HF(x) x.ymmh[0]\n+#define SF(x) x.ymm[0]\n+#elif AVX512F_LEN == 128\n+#undef HF\n+#undef SF\n+#undef NET_MASK \n+#undef MASK_VALUE \n+#undef ZMASK_VALUE \n+#define NET_MASK 0xff\n+#define MASK_VALUE 0xcc\n+#define ZMASK_VALUE 0xc1\n+#define HF(x) x.xmmh[0]\n+#define SF(x) x.xmm[0]\n+#else\n+#define NET_MASK 0xffffffff\n+#define MASK_VALUE 0xcccccccc\n+#define ZMASK_VALUE 0xfcc1fcc1\n+#define HF(x) x.zmmh\n+#define SF(x) x.zmm\n+#endif\n+"}, {"sha": "0590c34cebf1cfb471bc75c73bf21b3eaf8d70a9", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-vaddph-1a.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vaddph-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vaddph-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vaddph-1a.c?ref=f77f3adebde0547ed734a260f29e5afc85dcbe49", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512fp16 -O2\" } */\n+/* { dg-final { scan-assembler-times \"vaddph\\[ \\\\t\\]+%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vaddph\\[ \\\\t\\]+%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vaddph\\[ \\\\t\\]+%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vaddph\\[ \\\\t\\]+\\{rn-sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vaddph\\[ \\\\t\\]+\\{rn-sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vaddph\\[ \\\\t\\]+\\{rz-sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+\n+#include <immintrin.h>\n+\n+volatile __m512h res, res1, res2;\n+volatile __m512h x1, x2;\n+volatile __mmask32 m32;\n+\n+void extern\n+avx512f_test (void)\n+{\n+  res = _mm512_add_ph (x1, x2);\n+  res1 = _mm512_mask_add_ph (res1, m32, x1, x2);\n+  res2 = _mm512_maskz_add_ph (m32, x1, x2);\n+\n+  res = _mm512_add_round_ph (x1, x2, 8);\n+  res1 = _mm512_mask_add_round_ph (res1, m32, x1, x2, 8);\n+  res2 = _mm512_maskz_add_round_ph (m32, x1, x2, 11);\n+}"}, {"sha": "1c412b5c10e2ddd5b7d0f715b8df3fdab6974587", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-vaddph-1b.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vaddph-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vaddph-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vaddph-1b.c?ref=f77f3adebde0547ed734a260f29e5afc85dcbe49", "patch": "@@ -0,0 +1,92 @@\n+/* { dg-do run { target avx512fp16 } } */\n+/* { dg-options \"-O2 -mavx512fp16 -mavx512dq\" } */\n+\n+#define AVX512FP16\n+#include \"avx512fp16-helper.h\"\n+\n+#define N_ELEMS (AVX512F_LEN / 16)\n+\n+void NOINLINE\n+EMULATE(add_ph) (V512 * dest, V512 op1, V512 op2,\n+\t\t __mmask32 k, int zero_mask)\n+{\n+    V512 v1, v2, v3, v4, v5, v6, v7, v8;\n+    int i;\n+    __mmask16 m1, m2;\n+\n+    m1 = k & 0xffff;\n+    m2 = (k >> 16) & 0xffff;\n+\n+    unpack_ph_2twops(op1, &v1, &v2);\n+    unpack_ph_2twops(op2, &v3, &v4);\n+    unpack_ph_2twops(*dest, &v7, &v8);\n+\n+    for (i = 0; i < 16; i++) {\n+        if (((1 << i) & m1) == 0) {\n+            if (zero_mask) {\n+               v5.f32[i] = 0;\n+            }\n+            else {\n+               v5.u32[i] = v7.u32[i];\n+            }\n+        }\n+        else {\n+           v5.f32[i] = v1.f32[i] + v3.f32[i];\n+        }\n+\n+        if (((1 << i) & m2) == 0) {\n+            if (zero_mask) {\n+               v6.f32[i] = 0;\n+            }\n+            else {\n+               v6.u32[i] = v8.u32[i];\n+            }\n+        }\n+        else {\n+            v6.f32[i] = v2.f32[i] + v4.f32[i];\n+        }\n+\n+    }\n+    *dest = pack_twops_2ph(v5, v6);\n+}\n+\n+void\n+TEST (void)\n+{\n+  V512 res;\n+  V512 exp;\n+\n+  init_src();\n+  \n+  EMULATE(add_ph) (&exp, src1, src2, NET_MASK, 0);\n+  HF(res) = INTRINSIC (_add_ph) (HF(src1), HF(src2));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _add_ph);\n+\n+  init_dest(&res, &exp);\n+  EMULATE(add_ph) (&exp, src1, src2, MASK_VALUE, 0);\n+  HF(res) = INTRINSIC (_mask_add_ph) (HF(res), MASK_VALUE, HF(src1), HF(src2));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mask_add_ph);\n+\n+  EMULATE(add_ph) (&exp, src1, src2, ZMASK_VALUE, 1);\n+  HF(res) = INTRINSIC (_maskz_add_ph) (ZMASK_VALUE, HF(src1), HF(src2));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _maskz_add_ph);\n+\n+#if AVX512F_LEN == 512\n+  EMULATE(add_ph) (&exp, src1, src2, NET_MASK, 0);\n+  HF(res) = INTRINSIC (_add_round_ph) (HF(src1), HF(src2), _ROUND_NINT);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _add_round_ph);\n+\n+  init_dest(&res, &exp);\n+  EMULATE(add_ph) (&exp, src1, src2, MASK_VALUE, 0);\n+  HF(res) = INTRINSIC (_mask_add_round_ph) (HF(res), MASK_VALUE, HF(src1), HF(src2), _ROUND_NINT);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mask_add_round_ph);\n+\n+  EMULATE(add_ph) (&exp, src1, src2, ZMASK_VALUE, 1);\n+  HF(res) = INTRINSIC (_maskz_add_round_ph) (ZMASK_VALUE, HF(src1), HF(src2), _ROUND_NINT);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _maskz_add_round_ph);\n+#endif\n+\n+  if (n_errs != 0) {\n+      abort ();\n+  }\n+}"}, {"sha": "63f111f31963433c454fcbe1fd54baea9a186f2d", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-vdivph-1a.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vdivph-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vdivph-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vdivph-1a.c?ref=f77f3adebde0547ed734a260f29e5afc85dcbe49", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512fp16 -O2\" } */\n+/* { dg-final { scan-assembler-times \"vdivph\\[ \\\\t\\]+%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vdivph\\[ \\\\t\\]+%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vdivph\\[ \\\\t\\]+%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vdivph\\[ \\\\t\\]+\\{rn-sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vdivph\\[ \\\\t\\]+\\{rn-sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vdivph\\[ \\\\t\\]+\\{rz-sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+\n+#include <immintrin.h>\n+\n+volatile __m512h res, res1, res2;\n+volatile __m512h x1, x2;\n+volatile __mmask32 m32;\n+\n+void extern\n+avx512f_test (void)\n+{\n+  res = _mm512_div_ph (x1, x2);\n+  res1 = _mm512_mask_div_ph (res1, m32, x1, x2);\n+  res2 = _mm512_maskz_div_ph (m32, x1, x2);\n+\n+  res = _mm512_div_round_ph (x1, x2, 8);\n+  res1 = _mm512_mask_div_round_ph (res1, m32, x1, x2, 8);\n+  res2 = _mm512_maskz_div_round_ph (m32, x1, x2, 11);\n+}"}, {"sha": "c8b38210e8781e06de7e145a151df697550ad8c9", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-vdivph-1b.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vdivph-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vdivph-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vdivph-1b.c?ref=f77f3adebde0547ed734a260f29e5afc85dcbe49", "patch": "@@ -0,0 +1,97 @@\n+/* { dg-do run { target avx512fp16 } } */\n+/* { dg-options \"-O2 -mavx512fp16 -mavx512dq\" } */\n+\n+\n+#define AVX512FP16\n+#include \"avx512fp16-helper.h\"\n+\n+#define N_ELEMS (AVX512F_LEN / 16)\n+\n+void NOINLINE\n+EMULATE(div_ph) (V512 * dest, V512 op1, V512 op2,\n+                __mmask32 k, int zero_mask)\n+{\n+    V512 v1, v2, v3, v4, v5, v6, v7, v8;\n+    int i;\n+    __mmask16 m1, m2;\n+\n+    m1 = k & 0xffff;\n+    m2 = (k >> 16) & 0xffff;\n+\n+    unpack_ph_2twops(op1, &v1, &v2);\n+    unpack_ph_2twops(op2, &v3, &v4);\n+    unpack_ph_2twops(*dest, &v7, &v8);\n+\n+    for (i = 0; i < 16; i++) {\n+        if (((1 << i) & m1) == 0) {\n+            if (zero_mask) {\n+               v5.f32[i] = 0;\n+            }\n+            else {\n+               v5.u32[i] = v7.u32[i];\n+            }\n+        }\n+        else {\n+           v5.f32[i] = v1.f32[i] / v3.f32[i];\n+        }\n+\n+        if (((1 << i) & m2) == 0) {\n+            if (zero_mask) {\n+               v6.f32[i] = 0;\n+            }\n+            else {\n+               v6.u32[i] = v8.u32[i];\n+            }\n+        }\n+        else {\n+            v6.f32[i] = v2.f32[i] / v4.f32[i];\n+        }\n+\n+    }\n+    *dest = pack_twops_2ph(v5, v6);\n+}\n+\n+void\n+TEST (void)\n+{\n+  V512 res;\n+  V512 exp;\n+\n+  init_src();\n+\n+  EMULATE(div_ph) (&exp, src1, src2, NET_MASK, 0);\n+  HF(res) = INTRINSIC (_div_ph) (HF(src1), HF(src2));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _div_ph);\n+\n+  init_dest(&res, &exp);\n+  EMULATE(div_ph) (&exp, src1, src2, MASK_VALUE, 0);\n+  HF(res) = INTRINSIC (_mask_div_ph) (HF(res), MASK_VALUE, HF(src1), HF(src2));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mask_div_ph);\n+\n+  EMULATE(div_ph) (&exp, src1, src2, ZMASK_VALUE, 1);\n+  HF(res) = INTRINSIC (_maskz_div_ph) (ZMASK_VALUE, HF(src1), HF(src2));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _maskz_div_ph);\n+\n+#if AVX512F_LEN == 512\n+#if AVX512F_LEN == 512\n+  EMULATE(div_ph) (&exp, src1, src2, NET_MASK, 0);\n+  HF(res) = INTRINSIC (_div_round_ph) (HF(src1), HF(src2), _ROUND_NINT);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _div_ph);\n+\n+  init_dest(&res, &exp);\n+  EMULATE(div_ph) (&exp, src1, src2, MASK_VALUE, 0);\n+  HF(res) = INTRINSIC (_mask_div_round_ph) (HF(res), MASK_VALUE, HF(src1), HF(src2), _ROUND_NINT);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mask_div_ph);\n+  \n+  EMULATE(div_ph) (&exp, src1, src2, ZMASK_VALUE, 1);\n+  HF(res) = INTRINSIC (_maskz_div_round_ph) (ZMASK_VALUE, HF(src1), HF(src2), _ROUND_NINT);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _maskz_div_ph);\n+#endif\n+#endif\n+\n+  if (n_errs != 0) {\n+      abort ();\n+  }\n+}\n+\n+"}, {"sha": "1088e255786f205288090485525988cfdc34e42e", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-vmulph-1a.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vmulph-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vmulph-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vmulph-1a.c?ref=f77f3adebde0547ed734a260f29e5afc85dcbe49", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512fp16 -O2\" } */\n+/* { dg-final { scan-assembler-times \"vmulph\\[ \\\\t\\]+%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmulph\\[ \\\\t\\]+%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmulph\\[ \\\\t\\]+%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmulph\\[ \\\\t\\]+\\{rn-sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmulph\\[ \\\\t\\]+\\{rn-sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmulph\\[ \\\\t\\]+\\{rz-sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+\n+#include <immintrin.h>\n+\n+volatile __m512h res, res1, res2;\n+volatile __m512h x1, x2;\n+volatile __mmask32 m32;\n+\n+void extern\n+avx512f_test (void)\n+{\n+  res = _mm512_mul_ph (x1, x2);\n+  res1 = _mm512_mask_mul_ph (res1, m32, x1, x2);\n+  res2 = _mm512_maskz_mul_ph (m32, x1, x2);\n+\n+  res = _mm512_mul_round_ph (x1, x2, 8);\n+  res1 = _mm512_mask_mul_round_ph (res1, m32, x1, x2, 8);\n+  res2 = _mm512_maskz_mul_round_ph (m32, x1, x2, 11);\n+}"}, {"sha": "0d67e874d53b38747a5242224e990a3d2960ab2a", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-vmulph-1b.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vmulph-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vmulph-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vmulph-1b.c?ref=f77f3adebde0547ed734a260f29e5afc85dcbe49", "patch": "@@ -0,0 +1,92 @@\n+/* { dg-do run { target avx512fp16 } } */\n+/* { dg-options \"-O2 -mavx512fp16 -mavx512dq\" } */\n+\n+#define AVX512FP16\n+#include \"avx512fp16-helper.h\"\n+\n+#define N_ELEMS (AVX512F_LEN / 16)\n+\n+void NOINLINE\n+EMULATE(mul_ph) (V512 * dest, V512 op1, V512 op2, \n+                __mmask32 k, int zero_mask)\n+{\n+    V512 v1, v2, v3, v4, v5, v6, v7, v8;\n+    int i;\n+    __mmask16 m1, m2;\n+\n+    m1 = k & 0xffff;\n+    m2 = (k >> 16) & 0xffff;\n+\n+    unpack_ph_2twops(op1, &v1, &v2);\n+    unpack_ph_2twops(op2, &v3, &v4);\n+    unpack_ph_2twops(*dest, &v7, &v8);\n+\n+    for (i = 0; i < 16; i++) {\n+        if (((1 << i) & m1) == 0) {\n+            if (zero_mask) {\n+               v5.f32[i] = 0;\n+            }\n+            else {\n+               v5.u32[i] = v7.u32[i];\n+            }\n+        }\n+        else {\n+           v5.f32[i] = v1.f32[i] * v3.f32[i];\n+        }\n+\n+        if (((1 << i) & m2) == 0) {\n+            if (zero_mask) {\n+               v6.f32[i] = 0;\n+            }\n+            else {\n+               v6.u32[i] = v8.u32[i];\n+            }\n+        }\n+        else {\n+            v6.f32[i] = v2.f32[i] * v4.f32[i];\n+        }\n+\n+    }\n+    *dest = pack_twops_2ph(v5, v6);\n+}\n+\n+void\n+TEST (void)\n+{\n+  V512 res;\n+  V512 exp;\n+\n+  init_src();\n+\n+  EMULATE(mul_ph) (&exp, src1, src2, NET_MASK, 0);\n+  HF(res) = INTRINSIC (_mul_ph) (HF(src1), HF(src2));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mul_ph);\n+\n+  init_dest(&res, &exp);\n+  EMULATE(mul_ph) (&exp, src1, src2, MASK_VALUE, 0);\n+  HF(res) = INTRINSIC (_mask_mul_ph) (HF(res), MASK_VALUE, HF(src1), HF(src2));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mask_mul_ph);\n+\n+  EMULATE(mul_ph) (&exp, src1, src2, ZMASK_VALUE, 1);\n+  HF(res) = INTRINSIC (_maskz_mul_ph) (ZMASK_VALUE, HF(src1), HF(src2));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _maskz_mul_ph);\n+\n+#if AVX512F_LEN == 512\n+  EMULATE(mul_ph) (&exp, src1, src2, NET_MASK, 0);\n+  HF(res) = INTRINSIC (_mul_round_ph) (HF(src1), HF(src2), _ROUND_NINT);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mul_ph);\n+\n+  init_dest(&res, &exp);\n+  EMULATE(mul_ph) (&exp, src1, src2, MASK_VALUE, 0);\n+  HF(res) = INTRINSIC (_mask_mul_round_ph) (HF(res), MASK_VALUE, HF(src1), HF(src2), _ROUND_NINT);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mask_mul_ph);\n+  \n+  EMULATE(mul_ph) (&exp, src1, src2, ZMASK_VALUE, 1);\n+  HF(res) = INTRINSIC (_maskz_mul_round_ph) (ZMASK_VALUE, HF(src1), HF(src2), _ROUND_NINT);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _maskz_mul_ph);\n+#endif\n+\n+  if (n_errs != 0) {\n+      abort ();\n+  }\n+}"}, {"sha": "bb5eda64e3721828832bb254ff56b81b33721005", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-vsubph-1a.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vsubph-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vsubph-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vsubph-1a.c?ref=f77f3adebde0547ed734a260f29e5afc85dcbe49", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512fp16 -O2\" } */\n+/* { dg-final { scan-assembler-times \"vsubph\\[ \\\\t\\]+%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vsubph\\[ \\\\t\\]+%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vsubph\\[ \\\\t\\]+%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vsubph\\[ \\\\t\\]+\\{rn-sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vsubph\\[ \\\\t\\]+\\{rn-sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vsubph\\[ \\\\t\\]+\\{rz-sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+\n+#include <immintrin.h>\n+\n+volatile __m512h res, res1, res2;\n+volatile __m512h x1, x2;\n+volatile __mmask32 m32;\n+\n+void extern\n+avx512f_test (void)\n+{\n+  res = _mm512_sub_ph (x1, x2);\n+  res1 = _mm512_mask_sub_ph (res1, m32, x1, x2);\n+  res2 = _mm512_maskz_sub_ph (m32, x1, x2);\n+\n+  res = _mm512_sub_round_ph (x1, x2, 8);\n+  res1 = _mm512_mask_sub_round_ph (res1, m32, x1, x2, 8);\n+  res2 = _mm512_maskz_sub_round_ph (m32, x1, x2, 11);\n+}"}, {"sha": "bd31d98f43def902aac6dcd25804428790aa7f1e", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-vsubph-1b.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vsubph-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vsubph-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vsubph-1b.c?ref=f77f3adebde0547ed734a260f29e5afc85dcbe49", "patch": "@@ -0,0 +1,93 @@\n+/* { dg-do run { target avx512fp16 } } */\n+/* { dg-options \"-O2 -mavx512fp16 -mavx512dq\" } */\n+\n+#define AVX512FP16\n+#include \"avx512fp16-helper.h\"\n+\n+#define N_ELEMS (AVX512F_LEN / 16)\n+\n+void NOINLINE\n+EMULATE(sub_ph) (V512 * dest, V512 op1, V512 op2,\n+                __mmask32 k, int zero_mask)\n+{\n+    V512 v1, v2, v3, v4, v5, v6, v7, v8;\n+    int i;\n+    __mmask16 m1, m2;\n+\n+    m1 = k & 0xffff;\n+    m2 = (k >> 16) & 0xffff;\n+\n+    unpack_ph_2twops(op1, &v1, &v2);\n+    unpack_ph_2twops(op2, &v3, &v4);\n+    unpack_ph_2twops(*dest, &v7, &v8);\n+\n+    for (i = 0; i < 16; i++) {\n+        if (((1 << i) & m1) == 0) {\n+            if (zero_mask) {\n+               v5.f32[i] = 0;\n+            }\n+            else {\n+               v5.u32[i] = v7.u32[i];\n+            }\n+        }\n+        else {\n+           v5.f32[i] = v1.f32[i] - v3.f32[i];\n+        }\n+\n+        if (((1 << i) & m2) == 0) {\n+            if (zero_mask) {\n+               v6.f32[i] = 0;\n+            }\n+            else {\n+               v6.u32[i] = v8.u32[i];\n+            }\n+        }\n+        else {\n+            v6.f32[i] = v2.f32[i] - v4.f32[i];\n+        }\n+\n+    }\n+    *dest = pack_twops_2ph(v5, v6);\n+}\n+\n+\n+void\n+TEST (void)\n+{\n+  V512 res;\n+  V512 exp;\n+\n+  init_src();\n+  \n+  EMULATE(sub_ph) (&exp, src1, src2, NET_MASK, 0);\n+  HF(res) = INTRINSIC (_sub_ph) (HF(src1), HF(src2));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _sub_ph);\n+\n+  init_dest(&res, &exp);\n+  EMULATE(sub_ph) (&exp, src1, src2, MASK_VALUE, 0);\n+  HF(res) = INTRINSIC (_mask_sub_ph) (HF(res), MASK_VALUE, HF(src1), HF(src2));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mask_sub_ph);\n+\n+  EMULATE(sub_ph) (&exp, src1, src2, ZMASK_VALUE, 1);\n+  HF(res) = INTRINSIC (_maskz_sub_ph) (ZMASK_VALUE, HF(src1), HF(src2));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _maskz_sub_ph);\n+\n+#if AVX512F_LEN == 512\n+  EMULATE(sub_ph) (&exp, src1, src2, NET_MASK, 0);\n+  HF(res) = INTRINSIC (_sub_round_ph) (HF(src1), HF(src2), _ROUND_NINT);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _sub_ph);\n+\n+  init_dest(&res, &exp);\n+  EMULATE(sub_ph) (&exp, src1, src2, MASK_VALUE, 0);\n+  HF(res) = INTRINSIC (_mask_sub_round_ph) (HF(res), MASK_VALUE, HF(src1), HF(src2), _ROUND_NINT);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mask_sub_ph);\n+\n+  EMULATE(sub_ph) (&exp, src1, src2, ZMASK_VALUE, 1);\n+  HF(res) = INTRINSIC (_maskz_sub_round_ph) (ZMASK_VALUE, HF(src1), HF(src2), _ROUND_NINT);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _maskz_sub_ph);\n+#endif\n+\n+  if (n_errs != 0) {\n+      abort ();\n+  }\n+}"}, {"sha": "354d897dd9e212cd55eb9733df224b74d8031185", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16vl-vaddph-1a.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vaddph-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vaddph-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vaddph-1a.c?ref=f77f3adebde0547ed734a260f29e5afc85dcbe49", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512fp16 -mavx512vl -O2\" } */\n+/* { dg-final { scan-assembler-times \"vaddph\\[ \\\\t\\]+\\[^\\{\\n\\]*%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vaddph\\[ \\\\t\\]+%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vaddph\\[ \\\\t\\]+%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vaddph\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vaddph\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vaddph\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+\n+#include <immintrin.h>\n+\n+volatile __m256h res1;\n+volatile __m128h res2;\n+volatile __m256h x1,x2;\n+volatile __m128h x3, x4;\n+volatile __mmask16 m16;\n+volatile __mmask8 m8;\n+\n+void extern\n+avx512f_test (void)\n+{\n+  res1 = _mm256_add_ph (x1, x2);\n+  res1 = _mm256_mask_add_ph (res1, m16, x1, x2);\n+  res1 = _mm256_maskz_add_ph (m16, x1, x2);\n+\n+  res2 = _mm_add_ph (x3, x4);\n+  res2 = _mm_mask_add_ph (res2, m8, x3, x4);\n+  res2 = _mm_maskz_add_ph (m8, x3, x4);\n+}"}, {"sha": "fcf6a9058f5c97166b3e7fbb4325b4dc9bff2d07", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16vl-vaddph-1b.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vaddph-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vaddph-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vaddph-1b.c?ref=f77f3adebde0547ed734a260f29e5afc85dcbe49", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run { target avx512fp16 } } */\n+/* { dg-options \"-O2 -mavx512fp16 -mavx512vl -mavx512dq\" } */\n+\n+#define DEBUG\n+#define AVX512VL\n+#define AVX512F_LEN 256      \n+#define AVX512F_LEN_HALF 128 \n+#include \"avx512fp16-vaddph-1b.c\"\n+                             \n+#undef AVX512F_LEN           \n+#undef AVX512F_LEN_HALF      \n+                             \n+#define AVX512F_LEN 128      \n+#define AVX512F_LEN_HALF 128 \n+#include \"avx512fp16-vaddph-1b.c\"\n+"}, {"sha": "038d9e42fce9351934914bb4858444beb17a3ec5", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16vl-vdivph-1a.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vdivph-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vdivph-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vdivph-1a.c?ref=f77f3adebde0547ed734a260f29e5afc85dcbe49", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512fp16 -mavx512vl -O2\" } */\n+/* { dg-final { scan-assembler-times \"vdivph\\[ \\\\t\\]+\\[^\\{\\n\\]*%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vdivph\\[ \\\\t\\]+%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vdivph\\[ \\\\t\\]+%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vdivph\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vdivph\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vdivph\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+\n+#include <immintrin.h>\n+\n+volatile __m256h res1;\n+volatile __m128h res2;\n+volatile __m256h x1,x2;\n+volatile __m128h x3, x4;\n+volatile __mmask16 m16;\n+volatile __mmask8 m8;\n+\n+void extern\n+avx512f_test (void)\n+{\n+  res1 = _mm256_div_ph (x1, x2);\n+  res1 = _mm256_mask_div_ph (res1, m16, x1, x2);\n+  res1 = _mm256_maskz_div_ph (m16, x1, x2);\n+\n+  res2 = _mm_div_ph (x3, x4);\n+  res2 = _mm_mask_div_ph (res2, m8, x3, x4);\n+  res2 = _mm_maskz_div_ph (m8, x3, x4);\n+}"}, {"sha": "48965c6cfb880e592947e1dd02ef2908f040cbd2", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16vl-vdivph-1b.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vdivph-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vdivph-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vdivph-1b.c?ref=f77f3adebde0547ed734a260f29e5afc85dcbe49", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run { target avx512fp16 } } */\n+/* { dg-options \"-O2 -mavx512fp16 -mavx512vl -mavx512dq\" } */\n+\n+#define DEBUG\n+#define AVX512VL\n+#define AVX512F_LEN 256      \n+#define AVX512F_LEN_HALF 128 \n+#include \"avx512fp16-vdivph-1b.c\"\n+                             \n+#undef AVX512F_LEN           \n+#undef AVX512F_LEN_HALF      \n+                             \n+#define AVX512F_LEN 128      \n+#define AVX512F_LEN_HALF 128 \n+#include \"avx512fp16-vdivph-1b.c\"\n+"}, {"sha": "26663c5ca8deedb1d9be8664dd982f63a36651f1", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16vl-vmulph-1a.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vmulph-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vmulph-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vmulph-1a.c?ref=f77f3adebde0547ed734a260f29e5afc85dcbe49", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512fp16 -mavx512vl -O2\" } */\n+/* { dg-final { scan-assembler-times \"vmulph\\[ \\\\t\\]+\\[^\\{\\n\\]*%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmulph\\[ \\\\t\\]+%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmulph\\[ \\\\t\\]+%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmulph\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmulph\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmulph\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+\n+#include <immintrin.h>\n+\n+volatile __m256h res1;\n+volatile __m128h res2;\n+volatile __m256h x1,x2;\n+volatile __m128h x3, x4;\n+volatile __mmask16 m16;\n+volatile __mmask8 m8;\n+\n+void extern\n+avx512f_test (void)\n+{\n+  res1 = _mm256_mul_ph (x1, x2);\n+  res1 = _mm256_mask_mul_ph (res1, m16, x1, x2);\n+  res1 = _mm256_maskz_mul_ph (m16, x1, x2);\n+\n+  res2 = _mm_mul_ph (x3, x4);\n+  res2 = _mm_mask_mul_ph (res2, m8, x3, x4);\n+  res2 = _mm_maskz_mul_ph (m8, x3, x4);\n+}"}, {"sha": "2b3ba05053384e2c5cc1ce8f6107526e92eb407f", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16vl-vmulph-1b.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vmulph-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vmulph-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vmulph-1b.c?ref=f77f3adebde0547ed734a260f29e5afc85dcbe49", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run { target avx512fp16 } } */\n+/* { dg-options \"-O2 -mavx512fp16 -mavx512vl -mavx512dq\" } */\n+\n+#define DEBUG\n+#define AVX512VL\n+#define AVX512F_LEN 256      \n+#define AVX512F_LEN_HALF 128 \n+#include \"avx512fp16-vmulph-1b.c\"\n+                             \n+#undef AVX512F_LEN           \n+#undef AVX512F_LEN_HALF      \n+                             \n+#define AVX512F_LEN 128      \n+#define AVX512F_LEN_HALF 128 \n+#include \"avx512fp16-vmulph-1b.c\"\n+"}, {"sha": "10e5cbfed92e4cc28be1c251da402bf170bdad34", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16vl-vsubph-1a.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vsubph-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vsubph-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vsubph-1a.c?ref=f77f3adebde0547ed734a260f29e5afc85dcbe49", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512fp16 -mavx512vl -O2\" } */\n+/* { dg-final { scan-assembler-times \"vsubph\\[ \\\\t\\]+\\[^\\{\\n\\]*%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vsubph\\[ \\\\t\\]+%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vsubph\\[ \\\\t\\]+%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vsubph\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vsubph\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vsubph\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+\n+#include <immintrin.h>\n+\n+volatile __m256h res1;\n+volatile __m128h res2;\n+volatile __m256h x1,x2;\n+volatile __m128h x3, x4;\n+volatile __mmask16 m16;\n+volatile __mmask8 m8;\n+\n+void extern\n+avx512f_test (void)\n+{\n+  res1 = _mm256_sub_ph (x1, x2);\n+  res1 = _mm256_mask_sub_ph (res1, m16, x1, x2);\n+  res1 = _mm256_maskz_sub_ph (m16, x1, x2);\n+\n+  res2 = _mm_sub_ph (x3, x4);\n+  res2 = _mm_mask_sub_ph (res2, m8, x3, x4);\n+  res2 = _mm_maskz_sub_ph (m8, x3, x4);\n+}"}, {"sha": "fa162185e3cdcdd1141cd4d87fa4b1be5b44516b", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16vl-vsubph-1b.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vsubph-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f77f3adebde0547ed734a260f29e5afc85dcbe49/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vsubph-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vsubph-1b.c?ref=f77f3adebde0547ed734a260f29e5afc85dcbe49", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run { target avx512fp16 } } */\n+/* { dg-options \"-O2 -mavx512fp16 -mavx512vl -mavx512dq\" } */\n+\n+#define DEBUG\n+#define AVX512VL\n+#define AVX512F_LEN 256      \n+#define AVX512F_LEN_HALF 128 \n+#include \"avx512fp16-vsubph-1b.c\"\n+                             \n+#undef AVX512F_LEN           \n+#undef AVX512F_LEN_HALF      \n+                             \n+#define AVX512F_LEN 128      \n+#define AVX512F_LEN_HALF 128 \n+#include \"avx512fp16-vsubph-1b.c\"\n+"}]}