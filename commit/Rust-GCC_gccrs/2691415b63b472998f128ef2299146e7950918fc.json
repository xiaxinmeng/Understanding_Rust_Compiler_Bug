{"sha": "2691415b63b472998f128ef2299146e7950918fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY5MTQxNWI2M2I0NzI5OThmMTI4ZWYyMjk5MTQ2ZTc5NTA5MThmYw==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2015-03-21T08:31:17Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2015-03-21T08:31:17Z"}, "message": "2015-03-21  Tobias Burnus  <burnus@net-b.de>\n\n        * gfortran.texi (_gfortran_caf_sync_all,\n        * _gfortran_caf_sync_images,\n        _gfortran_caf_sync_memory, _gfortran_caf_error_stop,\n        _gfortran_caf_error_stop_str, _gfortran_caf_atomic_define,\n        _gfortran_caf_atomic_ref, _gfortran_caf_atomic_cas,\n        _gfortran_caf_atomic_op): New sections.\n\nFrom-SVN: r221550", "tree": {"sha": "0a0eca452178aab2856b9683e7b188941045f3fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a0eca452178aab2856b9683e7b188941045f3fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2691415b63b472998f128ef2299146e7950918fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2691415b63b472998f128ef2299146e7950918fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2691415b63b472998f128ef2299146e7950918fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2691415b63b472998f128ef2299146e7950918fc/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a684fb6488c58f91d57af7cc754ecbfb2806e731", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a684fb6488c58f91d57af7cc754ecbfb2806e731", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a684fb6488c58f91d57af7cc754ecbfb2806e731"}], "stats": {"total": 291, "additions": 286, "deletions": 5}, "files": [{"sha": "a9b9c16543f7bf06130390f7b636e663ad80ea93", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2691415b63b472998f128ef2299146e7950918fc/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2691415b63b472998f128ef2299146e7950918fc/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2691415b63b472998f128ef2299146e7950918fc", "patch": "@@ -1,3 +1,11 @@\n+2015-03-21  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.texi (_gfortran_caf_sync_all, _gfortran_caf_sync_images,\n+\t_gfortran_caf_sync_memory, _gfortran_caf_error_stop,\n+\t_gfortran_caf_error_stop_str, _gfortran_caf_atomic_define,\n+\t_gfortran_caf_atomic_ref, _gfortran_caf_atomic_cas,\n+\t_gfortran_caf_atomic_op): New sections.\n+\n 2015-03-21  Tobias Burnus  <burnus@net-b.de>\n \n \t* trans-expr.c (gfc_get_tree_for_caf_expr): Reject unimplemented"}, {"sha": "fe1c8d2b5a5c12ad19be5c70f1ef2e77cbeb2887", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 278, "deletions": 5, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2691415b63b472998f128ef2299146e7950918fc/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2691415b63b472998f128ef2299146e7950918fc/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=2691415b63b472998f128ef2299146e7950918fc", "patch": "@@ -3314,6 +3314,15 @@ caf_register_t;\n * _gfortran_caf_sendget:: Sending data between remote images\n * _gfortran_caf_lock:: Locking a lock variable\n * _gfortran_caf_unlock:: Unlocking a lock variable\n+* _gfortran_caf_sync_all:: All-image barrier\n+* _gfortran_caf_sync_images:: Barrier for selected images\n+* _gfortran_caf_sync_memory:: Wait for completion of segment-memory operations\n+* _gfortran_caf_error_stop:: Error termination with exit code\n+* _gfortran_caf_error_stop_str:: Error termination with string\n+* _gfortran_caf_atomic_define:: Atomic variable assignment\n+* _gfortran_caf_atomic_ref:: Atomic variable reference\n+* _gfortran_caf_atomic_cas:: Atomic compare and swap\n+* _gfortran_caf_atomic_op:: Atomic operation\n * _gfortran_caf_co_broadcast:: Sending data to all images\n * _gfortran_caf_co_max:: Collective maximum reduction\n * _gfortran_caf_co_min:: Collective minimum reduction\n@@ -3760,6 +3769,270 @@ images for critical-block locking variables.\n @end table\n \n \n+@node _gfortran_caf_sync_all\n+@subsection @code{_gfortran_caf_sync_all} --- All-image barrier\n+@cindex Coarray, _gfortran_caf_sync_all\n+\n+@table @asis\n+@item @emph{Description}:\n+Synchronization of all images in the current team; the program only continues\n+on a given image after this function has been called on all images of the\n+current team.  Additionally, it ensures that all pending data transfers of\n+previous segment have completed.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_sync_all (int *stat, char *errmsg, int errmsg_len)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n+@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n+an error message; may be NULL\n+@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@end multitable\n+@end table\n+\n+\n+\n+@node _gfortran_caf_sync_images\n+@subsection @code{_gfortran_caf_sync_images} --- Barrier for selected images\n+@cindex Coarray, _gfortran_caf_sync_images\n+\n+@table @asis\n+@item @emph{Description}:\n+Synchronization between the specified images; the program only continues on a\n+given image after this function has been called on all images specified for\n+that image. Note that one image can wait for all other images in the current\n+team (e.g. via @code{sync images(*)}) while those only wait for that specific\n+image.  Additionally, @code{sync images} it ensures that all pending data\n+transfers of previous segment have completed.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_sync_images (int count, int images[], int *stat,\n+char *errmsg, int errmsg_len)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{count} @tab the number of images which are provided in the next\n+argument.  For a zero-sized array, the value is zero.  For @code{sync\n+images (*)}, the value is @math{-1}.\n+@item @var{images} @tab intent(in) an array with the images provided by the\n+user. If @var{count} is zero, a NULL pointer is passed.\n+@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n+@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n+an error message; may be NULL\n+@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@end multitable\n+@end table\n+\n+\n+\n+@node _gfortran_caf_sync_memory\n+@subsection @code{_gfortran_caf_sync_memory} --- Wait for completion of segment-memory operations\n+@cindex Coarray, _gfortran_caf_sync_memory\n+\n+@table @asis\n+@item @emph{Description}:\n+Acts as optimization barrier between different segments. It also ensures that\n+all pending memory operations of this image have been completed.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_sync_memory (int *stat, char *errmsg, int errmsg_len)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n+@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n+an error message; may be NULL\n+@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@end multitable\n+\n+@item @emph{NOTE} A simple implementation could be a simple @code{__asm__\n+__volatile__ (\"\":::\"memory)} to prevent code movements.\n+@end table\n+\n+\n+\n+@node _gfortran_caf_error_stop\n+@subsection @code{_gfortran_caf_error_stop} --- Error termination with exit code\n+@cindex Coarray, _gfortran_caf_error_stop\n+\n+@table @asis\n+@item @emph{Description}:\n+Invoked for an @code{ERROR STOP} statement which has an integer argument.  The\n+function should terminate the program with the specified exit code.\n+\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_error_stop (int32_t error)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{error} @tab the exit status to be used.\n+@end multitable\n+@end table\n+\n+\n+\n+@node _gfortran_caf_error_stop_str\n+@subsection @code{_gfortran_caf_error_stop_str} --- Error termination with string\n+@cindex Coarray, _gfortran_caf_error_stop_str\n+\n+@table @asis\n+@item @emph{Description}:\n+Invoked for an @code{ERROR STOP} statement which has a string as argument.  The\n+function should terminate the program with a nonzero-exit code.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_error_stop (const char *string, int32_t len)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{string} @tab the error message (not zero terminated)\n+@item @var{len} @tab the length of the string\n+@end multitable\n+@end table\n+\n+\n+\n+@node _gfortran_caf_atomic_define\n+@subsection @code{_gfortran_caf_atomic_define} --- Atomic variable assignment\n+@cindex Coarray, _gfortran_caf_atomic_define\n+\n+@table @asis\n+@item @emph{Description}:\n+Assign atomically a value to an integer or logical variable.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_atomic_define (caf_token_t token, size_t offset,\n+int image_index, void *value, int *stat, int type, int kind)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{token} @tab intent(in) An opaque pointer identifying the coarray.\n+@item @var{offset} @tab By which amount of bytes the actual data is shifted\n+compared to the base address of the coarray.\n+@item @var{image_index} @tab The ID of the remote image; must be a positive\n+number.\n+@item @var{value} @tab intent(in) the value to be assigned, passed by reference.\n+@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n+@item @var{type} @tab the data type, i.e. @code{BT_INTEGER} (1) or\n+@code{BT_LOGICAL} (2).\n+@item @var{kind} @tab The kind value (only 4; always @code{int})\n+@end multitable\n+@end table\n+\n+\n+\n+@node _gfortran_caf_atomic_ref\n+@subsection @code{_gfortran_caf_atomic_ref} --- Atomic variable reference\n+@cindex Coarray, _gfortran_caf_atomic_ref\n+\n+@table @asis\n+@item @emph{Description}:\n+Reference atomically a value of a kind-4 integer or logical variable.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_atomic_ref (caf_token_t token, size_t offset,\n+int image_index, void *value, int *stat, int type, int kind)}\n+\n+@item @emph{Arguments}:\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{token} @tab intent(in) An opaque pointer identifying the coarray.\n+@item @var{offset} @tab By which amount of bytes the actual data is shifted\n+compared to the base address of the coarray.\n+@item @var{image_index} @tab The ID of the remote image; must be a positive\n+number.\n+@item @var{value} @tab intent(out) The variable assigned the atomically\n+referenced variable.\n+@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n+@item @var{type} @tab the data type, i.e. @code{BT_INTEGER} (1) or\n+@code{BT_LOGICAL} (2).\n+@item @var{kind} @tab The kind value (only 4; always @code{int})\n+@end multitable\n+@end table\n+\n+\n+\n+@node _gfortran_caf_atomic_cas\n+@subsection @code{_gfortran_caf_atomic_cas} --- Atomic compare and swap\n+@cindex Coarray, _gfortran_caf_atomic_cas\n+\n+@table @asis\n+@item @emph{Description}:\n+Atomic compare and swap of a kind-4 integer or logical variable. Assigns\n+atomically the specified value to the atomic variable, if the latter has\n+the value specified by the passed condition value.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_atomic_cas (caf_token_t token, size_t offset,\n+int image_index, void *old, void *compare, void *new_val, int *stat,\n+int type, int kind)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{token} @tab intent(in) An opaque pointer identifying the coarray.\n+@item @var{offset} @tab By which amount of bytes the actual data is shifted\n+compared to the base address of the coarray.\n+@item @var{image_index} @tab The ID of the remote image; must be a positive\n+number.\n+@item @var{old} @tab intent(out) the value which the atomic variable had\n+just before the cas operation.\n+@item @var{compare} @tab intent(in) The value used for comparision.\n+@item @var{new_val} @tab intent(in) The new value for the atomic variable,\n+assigned to the atomic variable, if @code{compare} equals the value of the\n+atomic variable.\n+@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n+@item @var{type} @tab the data type, i.e. @code{BT_INTEGER} (1) or\n+@code{BT_LOGICAL} (2).\n+@item @var{kind} @tab The kind value (only 4; always @code{int})\n+@end multitable\n+@end table\n+\n+\n+\n+@node _gfortran_caf_atomic_op\n+@subsection @code{_gfortran_caf_atomic_op} --- Atomic operation\n+@cindex Coarray, _gfortran_caf_atomic_op\n+\n+@table @asis\n+@item @emph{Description}:\n+Apply an operation atomically to an atomic integer or logical variable.\n+After the operation, @var{old} contains the value just before the operation,\n+which, respectively, adds (GFC_CAF_ATOMIC_ADD) atomically the @code{value} to\n+the atomic integer variable or does a bitwise AND, OR or exclusive OR of the\n+between the atomic variable and @var{value}; the result is then stored in the\n+atomic variable.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_atomic_op (int op, caf_token_t token, size_t offset,\n+int image_index, void *value, void *old, int *stat, int type, int kind)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{op} @tab the operation to be performed; possible values\n+@code{GFC_CAF_ATOMIC_ADD} (1), @code{GFC_CAF_ATOMIC_AND} (2),\n+@code{GFC_CAF_ATOMIC_OR} (3), @code{GFC_CAF_ATOMIC_XOR} (4).\n+@item @var{token} @tab intent(in) An opaque pointer identifying the coarray.\n+@item @var{offset} @tab By which amount of bytes the actual data is shifted\n+compared to the base address of the coarray.\n+@item @var{image_index} @tab The ID of the remote image; must be a positive\n+number.\n+@item @var{old} @tab intent(out) the value which the atomic variable had\n+just before the atomic operation.\n+@item @var{val} @tab intent(in) The new value for the atomic variable,\n+assigned to the atomic variable, if @code{compare} equals the value of the\n+atomic variable.\n+@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n+@item @var{type} @tab the data type, i.e. @code{BT_INTEGER} (1) or\n+@code{BT_LOGICAL} (2).\n+@item @var{kind} @tab The kind value (only 4; always @code{int})\n+@end multitable\n+@end table\n+\n+\n+\n \n @node _gfortran_caf_co_broadcast\n @subsection @code{_gfortran_caf_co_broadcast} --- Sending data to all images\n@@ -3780,7 +4053,7 @@ int source_image, int *stat, char *errmsg, int errmsg_len)}\n breoadcasted (on @var{source_image}) or to be received (other images).\n @item @var{source_image} @tab The ID of the image from which the data should\n be taken.\n-@item @var{stat} @tab intent(out) Stores the status STAT= and my may be NULL.\n+@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n @item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n an error message; may be NULL\n @item @var{errmsg_len} @tab the buffer size of errmsg.\n@@ -3811,7 +4084,7 @@ int *stat, char *errmsg, int a_len, int errmsg_len)}\n breoadcasted (on @var{source_image}) or to be received (other images).\n @item @var{result_image} @tab The ID of the image to which the reduced\n value should be copied to; if zero, it has to be copied to all images.\n-@item @var{stat} @tab intent(out) Stores the status STAT= and my may be NULL.\n+@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n @item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n an error message; may be NULL\n @item @var{a_len} @tab The string length of argument @var{a}.\n@@ -3847,7 +4120,7 @@ int *stat, char *errmsg, int a_len, int errmsg_len)}\n breoadcasted (on @var{source_image}) or to be received (other images).\n @item @var{result_image} @tab The ID of the image to which the reduced\n value should be copied to; if zero, it has to be copied to all images.\n-@item @var{stat} @tab intent(out) Stores the status STAT= and my may be NULL.\n+@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n @item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n an error message; may be NULL\n @item @var{a_len} @tab The string length of argument @var{a}.\n@@ -3882,7 +4155,7 @@ int *stat, char *errmsg, int errmsg_len)}\n breoadcasted (on @var{source_image}) or to be received (other images).\n @item @var{result_image} @tab The ID of the image to which the reduced\n value should be copied to; if zero, it has to be copied to all images.\n-@item @var{stat} @tab intent(out) Stores the status STAT= and my may be NULL.\n+@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n @item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n an error message; may be NULL\n @item @var{errmsg_len} @tab the buffer size of errmsg.\n@@ -3928,7 +4201,7 @@ int *stat, char *errmsg, int a_len, int errmsg_len)}\n breoadcasted (on @var{source_image}) or to be received (other images).\n @item @var{result_image} @tab The ID of the image to which the reduced\n value should be copied to; if zero, it has to be copied to all images.\n-@item @var{stat} @tab intent(out) Stores the status STAT= and my may be NULL.\n+@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n @item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n an error message; may be NULL\n @item @var{a_len} @tab The string length of argument @var{a}."}]}