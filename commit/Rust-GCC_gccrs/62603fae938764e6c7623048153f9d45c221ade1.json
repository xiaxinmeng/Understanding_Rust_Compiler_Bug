{"sha": "62603fae938764e6c7623048153f9d45c221ade1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI2MDNmYWU5Mzg3NjRlNmM3NjIzMDQ4MTUzZjlkNDVjMjIxYWRlMQ==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2012-01-29T17:19:32Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2012-01-29T17:19:32Z"}, "message": "PR 51808 Support arbitrarily long bind(C) binding labels.\n\n2012-01-29  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR fortran/51808\n\t* decl.c (set_binding_label): Move prototype from match.h to here.\n\t(curr_binding_label): Make a pointer rather than static array.\n\t(build_sym): Check sym->binding_label pointer rather than array,\n\tupdate set_binding_label call, handle curr_binding_label changes.\n\t(set_binding_label): Handle new curr_binding_label, dest_label\n\tdouble ptr, and sym->binding_label.\n\t(verify_bind_c_sym): Handle sym->binding_label being a pointer.\n\t(set_verify_bind_c_sym): Check sym->binding_label pointer rather\n\tthan array, update set_binding_label call.\n\t(gfc_match_bind_c_stmt): Handle curr_binding_label change.\n\t(match_procedure_decl): Update set_binding_label call.\n\t(gfc_match_bind_c): Change binding_label to pointer, update\n\tgfc_match_name_C call.\n\t* gfortran.h (GFC_MAX_BINDING_LABEL_LEN): Remove macro.\n\t(gfc_symbol): Make binding_label a pointer.\n\t(gfc_common_head): Likewise.\n\t* match.c (gfc_match_name_C): Heap allocate bind(C) name.\n\t* match.h (gfc_match_name_C): Change prototype argument.\n\t(set_binding_label): Move prototype to decl.c.\n\t* module.c (struct pointer_info): Make binding_label a pointer.\n\t(free_pi_tree): Free unused binding_label.\n\t(mio_read_string): New function.\n\t(mio_write_string): New function.\n\t(load_commons): Redo reading of binding_label.\n\t(read_module): Likewise.\n\t(write_common_0): Change to write empty string instead of name if\n\tno binding_label.\n\t(write_blank_common): Write empty string for binding label.\n\t(write_symbol): Change to write empty string instead of name if no\n\tbinding_label.\n\t* resolve.c (gfc_iso_c_func_interface): Don't set binding_label.\n\t(set_name_and_label): Make binding_label double pointer, use\n\tasprintf.\n\t(gfc_iso_c_sub_interface): Make binding_label a pointer.\n\t(resolve_bind_c_comms): Handle cases if\n\tgfc_common_head->binding_label is NULL.\n\t(gfc_verify_binding_labels): sym->binding_label is a pointer.\n\t* symbol.c (gfc_free_symbol): Free binding_label.\n\t(gfc_new_symbol): Rely on XCNEW zero init for binding_label.\n\t(gen_special_c_interop_ptr): Don't set binding label.\n\t(generate_isocbinding_symbol): Insert binding_label into symbol\n\ttable.\n\t(get_iso_c_sym): Use pointer assignment instead of strcpy.\n\t* trans-common.c (gfc_sym_mangled_common_id): Handle\n\tcom->binding_label being a pointer.\n\t* trans-decl.c (gfc_sym_mangled_identifier): Handle\n\tsym->binding_label being a pointer.\n\t(gfc_sym_mangled_function_id): Likewise.\n\n\ntestsuite ChangeLog\n\n2012-01-29  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR fortran/51808\n\t* gfortran.dg/module_md5_1.f90: Update MD5 sum.\n\nFrom-SVN: r183677", "tree": {"sha": "9cf48d558f50c1053b18c202c9c36d7a8a46c9f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9cf48d558f50c1053b18c202c9c36d7a8a46c9f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62603fae938764e6c7623048153f9d45c221ade1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62603fae938764e6c7623048153f9d45c221ade1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62603fae938764e6c7623048153f9d45c221ade1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62603fae938764e6c7623048153f9d45c221ade1/comments", "author": null, "committer": null, "parents": [{"sha": "9b850dd969cf8394b68743dd5bc115c662f0725a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b850dd969cf8394b68743dd5bc115c662f0725a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b850dd969cf8394b68743dd5bc115c662f0725a"}], "stats": {"total": 300, "additions": 190, "deletions": 110}, "files": [{"sha": "2d40e40ddf8fde7b3aeb6ad86ad11a19744e3fbc", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=62603fae938764e6c7623048153f9d45c221ade1", "patch": "@@ -1,3 +1,55 @@\n+2012-01-29  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR fortran/51808\n+\t* decl.c (set_binding_label): Move prototype from match.h to here.\n+\t(curr_binding_label): Make a pointer rather than static array.\n+\t(build_sym): Check sym->binding_label pointer rather than array,\n+\tupdate set_binding_label call, handle curr_binding_label changes.\n+\t(set_binding_label): Handle new curr_binding_label, dest_label\n+\tdouble ptr, and sym->binding_label.\n+\t(verify_bind_c_sym): Handle sym->binding_label being a pointer.\n+\t(set_verify_bind_c_sym): Check sym->binding_label pointer rather\n+\tthan array, update set_binding_label call.\n+\t(gfc_match_bind_c_stmt): Handle curr_binding_label change.\n+\t(match_procedure_decl): Update set_binding_label call.\n+\t(gfc_match_bind_c): Change binding_label to pointer, update\n+\tgfc_match_name_C call.\n+\t* gfortran.h (GFC_MAX_BINDING_LABEL_LEN): Remove macro.\n+\t(gfc_symbol): Make binding_label a pointer.\n+\t(gfc_common_head): Likewise.\n+\t* match.c (gfc_match_name_C): Heap allocate bind(C) name.\n+\t* match.h (gfc_match_name_C): Change prototype argument.\n+\t(set_binding_label): Move prototype to decl.c.\n+\t* module.c (struct pointer_info): Make binding_label a pointer.\n+\t(free_pi_tree): Free unused binding_label.\n+\t(mio_read_string): New function.\n+\t(mio_write_string): New function.\n+\t(load_commons): Redo reading of binding_label.\n+\t(read_module): Likewise.\n+\t(write_common_0): Change to write empty string instead of name if\n+\tno binding_label.\n+\t(write_blank_common): Write empty string for binding label.\n+\t(write_symbol): Change to write empty string instead of name if no\n+\tbinding_label.\n+\t* resolve.c (gfc_iso_c_func_interface): Don't set binding_label.\n+\t(set_name_and_label): Make binding_label double pointer, use\n+\tasprintf.\n+\t(gfc_iso_c_sub_interface): Make binding_label a pointer.\n+\t(resolve_bind_c_comms): Handle cases if\n+\tgfc_common_head->binding_label is NULL.\n+\t(gfc_verify_binding_labels): sym->binding_label is a pointer.\n+\t* symbol.c (gfc_free_symbol): Free binding_label.\n+\t(gfc_new_symbol): Rely on XCNEW zero init for binding_label.\n+\t(gen_special_c_interop_ptr): Don't set binding label.\n+\t(generate_isocbinding_symbol): Insert binding_label into symbol\n+\ttable.\n+\t(get_iso_c_sym): Use pointer assignment instead of strcpy.\n+\t* trans-common.c (gfc_sym_mangled_common_id): Handle\n+\tcom->binding_label being a pointer.\n+\t* trans-decl.c (gfc_sym_mangled_identifier): Handle\n+\tsym->binding_label being a pointer.\n+\t(gfc_sym_mangled_function_id): Likewise.\n+\n 2012-01-29  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/52038\n@@ -22,7 +74,7 @@\n \t* resolve.c (resolve_formal_arglist): Fix elemental\n \tconstraint checks for polymorphic dummies also for\n \tpointers.\n-\t\n+\n 2012-01-27  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/51970"}, {"sha": "0cfb0ef383179ab027bf4c80476bcd277b3a74a1", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=62603fae938764e6c7623048153f9d45c221ade1", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"parse.h\"\n #include \"flags.h\"\n #include \"constructor.h\"\n+#include \"tree.h\"\n \n /* Macros to access allocate memory for gfc_data_variable,\n    gfc_data_value and gfc_data.  */\n@@ -34,6 +35,9 @@ along with GCC; see the file COPYING3.  If not see\n #define gfc_get_data() XCNEW (gfc_data)\n \n \n+static gfc_try set_binding_label (char **, const char *, int);\n+\n+\n /* This flag is set if an old-style length selector is matched\n    during a type-declaration statement.  */\n \n@@ -51,7 +55,7 @@ static gfc_array_spec *current_as;\n static int colon_seen;\n \n /* The current binding label (if any).  */\n-static char curr_binding_label[GFC_MAX_BINDING_LABEL_LEN + 1];\n+static char* curr_binding_label;\n /* Need to know how many identifiers are on the current data declaration\n    line in case we're given the BIND(C) attribute with a NAME= specifier.  */\n static int num_idents_on_line;\n@@ -1164,11 +1168,11 @@ build_sym (const char *name, gfc_charlen *cl, bool cl_deferred,\n      with a bind(c) and make sure the binding label is set correctly.  */\n   if (sym->attr.is_bind_c == 1)\n     {\n-      if (sym->binding_label[0] == '\\0')\n+      if (!sym->binding_label)\n         {\n \t  /* Set the binding label and verify that if a NAME= was specified\n \t     then only one identifier was in the entity-decl-list.  */\n-\t  if (set_binding_label (sym->binding_label, sym->name,\n+\t  if (set_binding_label (&sym->binding_label, sym->name,\n \t\t\t\t num_idents_on_line) == FAILURE)\n             return FAILURE;\n         }\n@@ -2575,7 +2579,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n     ts->kind = -1;\n \n   /* Clear the current binding label, in case one is given.  */\n-  curr_binding_label[0] = '\\0';\n+  curr_binding_label = NULL;\n \n   if (gfc_match (\" byte\") == MATCH_YES)\n     {\n@@ -3803,8 +3807,8 @@ match_attr_spec (void)\n    (J3/04-007, section 15.4.1).  If a binding label was given and\n    there is more than one argument (num_idents), it is an error.  */\n \n-gfc_try\n-set_binding_label (char *dest_label, const char *sym_name, int num_idents)\n+static gfc_try\n+set_binding_label (char **dest_label, const char *sym_name, int num_idents)\n {\n   if (num_idents > 1 && has_name_equals)\n     {\n@@ -3813,17 +3817,15 @@ set_binding_label (char *dest_label, const char *sym_name, int num_idents)\n       return FAILURE;\n     }\n \n-  if (curr_binding_label[0] != '\\0')\n-    {\n-      /* Binding label given; store in temp holder til have sym.  */\n-      strcpy (dest_label, curr_binding_label);\n-    }\n+  if (curr_binding_label)\n+    /* Binding label given; store in temp holder til have sym.  */\n+    *dest_label = curr_binding_label;\n   else\n     {\n       /* No binding label given, and the NAME= specifier did not exist,\n          which means there was no NAME=\"\".  */\n       if (sym_name != NULL && has_name_equals == 0)\n-        strcpy (dest_label, sym_name);\n+        *dest_label = IDENTIFIER_POINTER (get_identifier (sym_name));\n     }\n    \n   return SUCCESS;\n@@ -4003,7 +4005,7 @@ verify_bind_c_sym (gfc_symbol *tmp_sym, gfc_typespec *ts,\n   /* See if the symbol has been marked as private.  If it has, make sure\n      there is no binding label and warn the user if there is one.  */\n   if (tmp_sym->attr.access == ACCESS_PRIVATE\n-      && tmp_sym->binding_label[0] != '\\0')\n+      && tmp_sym->binding_label)\n       /* Use gfc_warning_now because we won't say that the symbol fails\n \t just because of this.\t*/\n       gfc_warning_now (\"Symbol '%s' at %L is marked PRIVATE but has been \"\n@@ -4029,7 +4031,7 @@ set_verify_bind_c_sym (gfc_symbol *tmp_sym, int num_idents)\n   /* Set the is_bind_c bit in symbol_attribute.  */\n   gfc_add_is_bind_c (&(tmp_sym->attr), tmp_sym->name, &gfc_current_locus, 0);\n \n-  if (set_binding_label (tmp_sym->binding_label, tmp_sym->name, \n+  if (set_binding_label (&tmp_sym->binding_label, tmp_sym->name,\n \t\t\t num_idents) != SUCCESS)\n     return FAILURE;\n \n@@ -4046,7 +4048,8 @@ set_verify_bind_c_com_block (gfc_common_head *com_block, int num_idents)\n   gfc_try retval = SUCCESS;\n   \n   /* destLabel, common name, typespec (which may have binding label).  */\n-  if (set_binding_label (com_block->binding_label, com_block->name, num_idents)\n+  if (set_binding_label (&com_block->binding_label, com_block->name, \n+\t\t\t num_idents)\n       != SUCCESS)\n     return FAILURE;\n \n@@ -4157,7 +4160,7 @@ gfc_match_bind_c_stmt (void)\n   /* This may not be necessary.  */\n   gfc_clear_ts (ts);\n   /* Clear the temporary binding label holder.  */\n-  curr_binding_label[0] = '\\0';\n+  curr_binding_label = NULL;\n \n   /* Look for the bind(c).  */\n   found_match = gfc_match_bind_c (NULL, true);\n@@ -4865,7 +4868,8 @@ match_procedure_decl (void)\n \t      return MATCH_ERROR;\n \t    }\n \t  /* Set binding label for BIND(C).  */\n-\t  if (set_binding_label (sym->binding_label, sym->name, num) != SUCCESS)\n+\t  if (set_binding_label (&sym->binding_label, sym->name, num) \n+\t      != SUCCESS)\n \t    return MATCH_ERROR;\n \t}\n \n@@ -5709,18 +5713,14 @@ match\n gfc_match_bind_c (gfc_symbol *sym, bool allow_binding_name)\n {\n   /* binding label, if exists */   \n-  char binding_label[GFC_MAX_SYMBOL_LEN + 1];\n+  char* binding_label = NULL;\n   match double_quote;\n   match single_quote;\n \n   /* Initialize the flag that specifies whether we encountered a NAME= \n      specifier or not.  */\n   has_name_equals = 0;\n \n-  /* Init the first char to nil so we can catch if we don't have\n-     the label (name attr) or the symbol name yet.  */\n-  binding_label[0] = '\\0';\n-   \n   /* This much we have to be able to match, in this order, if\n      there is a bind(c) label.\t*/\n   if (gfc_match (\" bind ( c \") != MATCH_YES)\n@@ -5755,7 +5755,7 @@ gfc_match_bind_c (gfc_symbol *sym, bool allow_binding_name)\n       \n       /* Grab the binding label, using functions that will not lower\n \t case the names automatically.\t*/\n-      if (gfc_match_name_C (binding_label) != MATCH_YES)\n+      if (gfc_match_name_C (&binding_label) != MATCH_YES)\n \t return MATCH_ERROR;\n       \n       /* Get the closing quotation.  */\n@@ -5803,14 +5803,12 @@ gfc_match_bind_c (gfc_symbol *sym, bool allow_binding_name)\n   /* Save the binding label to the symbol.  If sym is null, we're\n      probably matching the typespec attributes of a declaration and\n      haven't gotten the name yet, and therefore, no symbol yet.\t */\n-  if (binding_label[0] != '\\0')\n+  if (binding_label)\n     {\n       if (sym != NULL)\n-      {\n-\tstrcpy (sym->binding_label, binding_label);\n-      }\n+\tsym->binding_label = binding_label;\n       else\n-\tstrcpy (curr_binding_label, binding_label);\n+\tcurr_binding_label = binding_label;\n     }\n   else if (allow_binding_name)\n     {\n@@ -5819,7 +5817,7 @@ gfc_match_bind_c (gfc_symbol *sym, bool allow_binding_name)\n \t If name=\"\" or allow_binding_name is false, no C binding name is\n \t created. */\n       if (sym != NULL && sym->name != NULL && has_name_equals == 0)\n-\tstrncpy (sym->binding_label, sym->name, strlen (sym->name) + 1);\n+\tsym->binding_label = IDENTIFIER_POINTER (get_identifier (sym->name));\n     }\n \n   if (has_name_equals && gfc_current_state () == COMP_INTERFACE"}, {"sha": "bf9a1f9074bce3061af9588a221d2000cf9b8112", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=62603fae938764e6c7623048153f9d45c221ade1", "patch": "@@ -42,7 +42,6 @@ along with GCC; see the file COPYING3.  If not see\n /* Major control parameters.  */\n \n #define GFC_MAX_SYMBOL_LEN 63   /* Must be at least 63 for F2003.  */\n-#define GFC_MAX_BINDING_LABEL_LEN 126 /* (2 * GFC_MAX_SYMBOL_LEN) */\n #define GFC_MAX_LINE 132\t/* Characters beyond this are not seen.  */\n #define GFC_LETTERS 26\t\t/* Number of letters in the alphabet.  */\n \n@@ -1238,7 +1237,7 @@ typedef struct gfc_symbol\n \n   /* This may be repetitive, since the typespec now has a binding\n      label field.  */\n-  char binding_label[GFC_MAX_BINDING_LABEL_LEN + 1];\n+  char* binding_label;\n   /* Store a reference to the common_block, if this symbol is in one.  */\n   struct gfc_common_head *common_block;\n \n@@ -1255,7 +1254,7 @@ typedef struct gfc_common_head\n   char use_assoc, saved, threadprivate;\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   struct gfc_symbol *head;\n-  char binding_label[GFC_MAX_BINDING_LABEL_LEN + 1];\n+  char* binding_label;\n   int is_bind_c;\n }\n gfc_common_head;"}, {"sha": "3024cc7b9c98ea2c5de3273af269a44a38b511bd", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=62603fae938764e6c7623048153f9d45c221ade1", "patch": "@@ -1,6 +1,6 @@\n /* Matching subroutines in all sizes, shapes and colors.\n    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n-   2009, 2010, 2011\n+   2009, 2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gfortran.h\"\n #include \"match.h\"\n #include \"parse.h\"\n+#include \"tree.h\"\n \n int gfc_matching_ptr_assignment = 0;\n int gfc_matching_procptr_assignment = 0;\n@@ -571,22 +572,22 @@ gfc_match_name (char *buffer)\n /* Match a valid name for C, which is almost the same as for Fortran,\n    except that you can start with an underscore, etc..  It could have\n    been done by modifying the gfc_match_name, but this way other\n-   things C allows can be added, such as no limits on the length.\n-   Right now, the length is limited to the same thing as Fortran..\n+   things C allows can be done, such as no limits on the length.\n    Also, by rewriting it, we use the gfc_next_char_C() to prevent the\n    input characters from being automatically lower cased, since C is\n    case sensitive.  The parameter, buffer, is used to return the name\n-   that is matched.  Return MATCH_ERROR if the name is too long\n-   (though this is a self-imposed limit), MATCH_NO if what we're\n-   seeing isn't a name, and MATCH_YES if we successfully match a C\n-   name.  */\n+   that is matched.  Return MATCH_ERROR if the name is not a valid C\n+   name, MATCH_NO if what we're seeing isn't a name, and MATCH_YES if\n+   we successfully match a C name.  */\n \n match\n-gfc_match_name_C (char *buffer)\n+gfc_match_name_C (char **buffer)\n {\n   locus old_loc;\n-  int i = 0;\n+  size_t i = 0;\n   gfc_char_t c;\n+  char* buf;\n+  size_t cursz = 16; \n \n   old_loc = gfc_current_locus;\n   gfc_gobble_whitespace ();\n@@ -600,7 +601,6 @@ gfc_match_name_C (char *buffer)\n      symbol name, all lowercase.  */\n   if (c == '\"' || c == '\\'')\n     {\n-      buffer[0] = '\\0';\n       gfc_current_locus = old_loc;\n       return MATCH_YES;\n     }\n@@ -611,32 +611,31 @@ gfc_match_name_C (char *buffer)\n       return MATCH_ERROR;\n     }\n \n+  buf = XNEWVEC (char, cursz);\n   /* Continue to read valid variable name characters.  */\n   do\n     {\n       gcc_assert (gfc_wide_fits_in_byte (c));\n \n-      buffer[i++] = (unsigned char) c;\n-      \n-    /* C does not define a maximum length of variable names, to my\n-       knowledge, but the compiler typically places a limit on them.\n-       For now, i'll use the same as the fortran limit for simplicity,\n-       but this may need to be changed to a dynamic buffer that can\n-       be realloc'ed here if necessary, or more likely, a larger\n-       upper-bound set.  */\n-      if (i > gfc_option.max_identifier_length)\n-        {\n-          gfc_error (\"Name at %C is too long\");\n-          return MATCH_ERROR;\n-        }\n+      buf[i++] = (unsigned char) c;\n+\n+      if (i >= cursz)\n+\t{\n+\t  cursz *= 2;\n+\t  buf = XRESIZEVEC (char, buf, cursz);\n+\t}\n       \n       old_loc = gfc_current_locus;\n       \n       /* Get next char; param means we're in a string.  */\n       c = gfc_next_char_literal (INSTRING_WARN);\n     } while (ISALNUM (c) || c == '_');\n \n-  buffer[i] = '\\0';\n+  /* The binding label will be needed later anyway, so just insert it\n+     into the symbol table.  */\n+  buf[i] = '\\0';\n+  *buffer = IDENTIFIER_POINTER (get_identifier (buf));\n+  XDELETEVEC (buf);\n   gfc_current_locus = old_loc;\n \n   /* See if we stopped because of whitespace.  */"}, {"sha": "642c4373ac79f1e0f825dc111431f1658e620898", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=62603fae938764e6c7623048153f9d45c221ade1", "patch": "@@ -52,7 +52,7 @@ match gfc_match_label (void);\n match gfc_match_small_int (int *);\n match gfc_match_small_int_expr (int *, gfc_expr **);\n match gfc_match_name (char *);\n-match gfc_match_name_C (char *buffer);\n+match gfc_match_name_C (char **buffer);\n match gfc_match_symbol (gfc_symbol **, int);\n match gfc_match_sym_tree (gfc_symtree **, int);\n match gfc_match_intrinsic_op (gfc_intrinsic_op *);\n@@ -196,7 +196,6 @@ match gfc_match_volatile (void);\n /* Fortran 2003 c interop.\n    TODO: some of these should be moved to another file rather than decl.c */\n void set_com_block_bind_c (gfc_common_head *, int);\n-gfc_try set_binding_label (char *, const char *, int);\n gfc_try set_verify_bind_c_sym (gfc_symbol *, int);\n gfc_try set_verify_bind_c_com_block (gfc_common_head *, int);\n gfc_try get_bind_c_idents (void);"}, {"sha": "4e6c520bc97ce70d4c18670d48de562a47d5c2c0", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 50, "deletions": 16, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=62603fae938764e6c7623048153f9d45c221ade1", "patch": "@@ -75,6 +75,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"md5.h\"\n #include \"constructor.h\"\n #include \"cpp.h\"\n+#include \"tree.h\"\n \n #define MODULE_EXTENSION \".mod\"\n \n@@ -160,7 +161,7 @@ typedef struct pointer_info\n       module_locus where;\n       fixup_t *stfixup;\n       gfc_symtree *symtree;\n-      char binding_label[GFC_MAX_SYMBOL_LEN + 1];\n+      char* binding_label;\n     }\n     rsym;\n \n@@ -227,6 +228,9 @@ free_pi_tree (pointer_info *p)\n   free_pi_tree (p->left);\n   free_pi_tree (p->right);\n \n+  if (iomode == IO_INPUT)\n+    XDELETEVEC (p->u.rsym.binding_label);\n+\n   free (p);\n }\n \n@@ -1812,6 +1816,27 @@ mio_internal_string (char *string)\n }\n \n \n+/* Read a string. The caller is responsible for freeing.  */\n+\n+static char*\n+mio_read_string (void)\n+{\n+  char* p;\n+  require_atom (ATOM_STRING);\n+  p = atom_string;\n+  atom_string = NULL;\n+  return p;\n+}\n+\n+\n+/* Write a string.  */\n+static void\n+mio_write_string (const char* string)\n+{\n+  write_atom (ATOM_STRING, string);\n+}\n+\n+\n typedef enum\n { AB_ALLOCATABLE, AB_DIMENSION, AB_EXTERNAL, AB_INTRINSIC, AB_OPTIONAL,\n   AB_POINTER, AB_TARGET, AB_DUMMY, AB_RESULT, AB_DATA,\n@@ -4126,6 +4151,7 @@ load_commons (void)\n   while (peek_atom () != ATOM_RPAREN)\n     {\n       int flags;\n+      char* label;\n       mio_lparen ();\n       mio_internal_string (name);\n \n@@ -4142,7 +4168,10 @@ load_commons (void)\n       /* Get whether this was a bind(c) common or not.  */\n       mio_integer (&p->is_bind_c);\n       /* Get the binding label.  */\n-      mio_internal_string (p->binding_label);\n+      label = mio_read_string ();\n+      if (strlen (label))\n+\tp->binding_label = IDENTIFIER_POINTER (get_identifier (label));\n+      XDELETEVEC (label);\n       \n       mio_rparen ();\n     }\n@@ -4344,7 +4373,9 @@ load_needed (pointer_info *p)\n       sym = gfc_new_symbol (p->u.rsym.true_name, ns);\n       sym->name = dt_lower_string (p->u.rsym.true_name);\n       sym->module = gfc_get_string (p->u.rsym.module);\n-      strcpy (sym->binding_label, p->u.rsym.binding_label);\n+      if (p->u.rsym.binding_label)\n+\tsym->binding_label = IDENTIFIER_POINTER (get_identifier \n+\t\t\t\t\t\t (p->u.rsym.binding_label));\n \n       associate_integer_pointer (p, sym);\n     }\n@@ -4493,6 +4524,7 @@ read_module (void)\n \n   while (peek_atom () != ATOM_RPAREN)\n     {\n+      char* bind_label;\n       require_atom (ATOM_INTEGER);\n       info = get_integer (atom_int);\n \n@@ -4501,8 +4533,11 @@ read_module (void)\n \n       mio_internal_string (info->u.rsym.true_name);\n       mio_internal_string (info->u.rsym.module);\n-      mio_internal_string (info->u.rsym.binding_label);\n-\n+      bind_label = mio_read_string ();\n+      if (strlen (bind_label))\n+\tinfo->u.rsym.binding_label = bind_label;\n+      else\n+\tXDELETEVEC (bind_label);\n       \n       require_atom (ATOM_INTEGER);\n       info->u.rsym.ns = atom_int;\n@@ -4634,10 +4669,10 @@ read_module (void)\n \t\t  sym = info->u.rsym.sym;\n \t\t  sym->module = gfc_get_string (info->u.rsym.module);\n \n-\t\t  /* TODO: hmm, can we test this?  Do we know it will be\n-\t\t     initialized to zeros?  */\n-\t\t  if (info->u.rsym.binding_label[0] != '\\0')\n-\t\t    strcpy (sym->binding_label, info->u.rsym.binding_label);\n+\t\t  if (info->u.rsym.binding_label)\n+\t\t    sym->binding_label = \n+\t\t      IDENTIFIER_POINTER (get_identifier \n+\t\t\t\t\t  (info->u.rsym.binding_label));\n \t\t}\n \n \t      st->n.sym = sym;\n@@ -4836,10 +4871,10 @@ write_common_0 (gfc_symtree *st, bool this_module)\n \n   write_common_0 (st->left, this_module);\n \n-  /* We will write out the binding label, or the name if no label given.  */\n+  /* We will write out the binding label, or \"\" if no label given.  */\n   name = st->n.common->name;\n   p = st->n.common;\n-  label = p->is_bind_c ? p->binding_label : p->name;\n+  label = (p->is_bind_c && p->binding_label) ? p->binding_label : \"\";\n \n   /* Check if we've already output this common.  */\n   w = written_commons;\n@@ -4924,9 +4959,8 @@ write_blank_common (void)\n   /* Write out whether the common block is bind(c) or not.  */\n   mio_integer (&is_bind_c);\n \n-  /* Write out the binding label, which is BLANK_COMMON_NAME, though\n-     it doesn't matter because the label isn't used.  */\n-  mio_pool_string (&name);\n+  /* Write out an empty binding label.  */\n+  mio_write_string (\"\");\n \n   mio_rparen ();\n }\n@@ -5024,13 +5058,13 @@ write_symbol (int n, gfc_symbol *sym)\n     mio_pool_string (&sym->name);\n \n   mio_pool_string (&sym->module);\n-  if (sym->attr.is_bind_c || sym->attr.is_iso_c)\n+  if ((sym->attr.is_bind_c || sym->attr.is_iso_c) && sym->binding_label)\n     {\n       label = sym->binding_label;\n       mio_pool_string (&label);\n     }\n   else\n-    mio_pool_string (&sym->name);\n+    mio_write_string (\"\");\n \n   mio_pointer_ref (&sym->ns);\n "}, {"sha": "30980d21b8b002d92bb46be38a34edcd99f5e947", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=62603fae938764e6c7623048153f9d45c221ade1", "patch": "@@ -2722,7 +2722,6 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n                           gfc_symbol **new_sym)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n-  char binding_label[GFC_MAX_BINDING_LABEL_LEN + 1];\n   int optional_arg = 0;\n   gfc_try retval = SUCCESS;\n   gfc_symbol *args_sym;\n@@ -2756,26 +2755,23 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n \t{\n \t  /* two args.  */\n \t  sprintf (name, \"%s_2\", sym->name);\n-\t  sprintf (binding_label, \"%s_2\", sym->binding_label);\n \t  optional_arg = 1;\n \t}\n       else\n \t{\n \t  /* one arg.  */\n \t  sprintf (name, \"%s_1\", sym->name);\n-\t  sprintf (binding_label, \"%s_1\", sym->binding_label);\n \t  optional_arg = 0;\n \t}\n \n       /* Get a new symbol for the version of c_associated that\n \t will get called.  */\n-      *new_sym = get_iso_c_sym (sym, name, binding_label, optional_arg);\n+      *new_sym = get_iso_c_sym (sym, name, NULL, optional_arg);\n     }\n   else if (sym->intmod_sym_id == ISOCBINDING_LOC\n \t   || sym->intmod_sym_id == ISOCBINDING_FUNLOC)\n     {\n       sprintf (name, \"%s\", sym->name);\n-      sprintf (binding_label, \"%s\", sym->binding_label);\n \n       /* Error check the call.  */\n       if (args->next != NULL)\n@@ -3360,7 +3356,7 @@ resolve_generic_s (gfc_code *c)\n \n static void\n set_name_and_label (gfc_code *c, gfc_symbol *sym,\n-                    char *name, char *binding_label)\n+                    char *name, char **binding_label)\n {\n   gfc_expr *arg = NULL;\n   char type;\n@@ -3393,15 +3389,16 @@ set_name_and_label (gfc_code *c, gfc_symbol *sym,\n       sprintf (name, \"%s_%c%d\", sym->name, type, kind);\n       /* Set up the binding label as the given symbol's label plus\n          the type and kind.  */\n-      sprintf (binding_label, \"%s_%c%d\", sym->binding_label, type, kind);\n+      *binding_label = gfc_get_string (\"%s_%c%d\", sym->binding_label, type, \n+\t\t\t\t       kind);\n     }\n   else\n     {\n       /* If the second arg is missing, set the name and label as\n          was, cause it should at least be found, and the missing\n          arg error will be caught by compare_parameters().  */\n       sprintf (name, \"%s\", sym->name);\n-      sprintf (binding_label, \"%s\", sym->binding_label);\n+      *binding_label = sym->binding_label;\n     }\n    \n   return;\n@@ -3423,7 +3420,7 @@ gfc_iso_c_sub_interface (gfc_code *c, gfc_symbol *sym)\n   gfc_symbol *new_sym;\n   /* this is fine, since we know the names won't use the max */\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n-  char binding_label[GFC_MAX_BINDING_LABEL_LEN + 1];\n+  char* binding_label;\n   /* default to success; will override if find error */\n   match m = MATCH_YES;\n \n@@ -3434,7 +3431,7 @@ gfc_iso_c_sub_interface (gfc_code *c, gfc_symbol *sym)\n   if ((sym->intmod_sym_id == ISOCBINDING_F_POINTER) ||\n       (sym->intmod_sym_id == ISOCBINDING_F_PROCPOINTER))\n     {\n-      set_name_and_label (c, sym, name, binding_label);\n+      set_name_and_label (c, sym, name, &binding_label);\n       \n       if (sym->intmod_sym_id == ISOCBINDING_F_POINTER)\n \t{\n@@ -9668,6 +9665,8 @@ resolve_bind_c_comms (gfc_symtree *comm_block_tree)\n     {\n       gfc_gsymbol *binding_label_gsym;\n       gfc_gsymbol *comm_name_gsym;\n+      const char * bind_label = comm_block_tree->n.common->binding_label \n+\t? comm_block_tree->n.common->binding_label : \"\";\n \n       /* See if a global symbol exists by the common block's name.  It may\n          be NULL if the common block is use-associated.  */\n@@ -9676,7 +9675,7 @@ resolve_bind_c_comms (gfc_symtree *comm_block_tree)\n       if (comm_name_gsym != NULL && comm_name_gsym->type != GSYM_COMMON)\n         gfc_error (\"Binding label '%s' for common block '%s' at %L collides \"\n                    \"with the global entity '%s' at %L\",\n-                   comm_block_tree->n.common->binding_label,\n+                   bind_label,\n                    comm_block_tree->n.common->name,\n                    &(comm_block_tree->n.common->where),\n                    comm_name_gsym->name, &(comm_name_gsym->where));\n@@ -9688,17 +9687,14 @@ resolve_bind_c_comms (gfc_symtree *comm_block_tree)\n              as expected.  */\n           if (comm_name_gsym->binding_label == NULL)\n             /* No binding label for common block stored yet; save this one.  */\n-            comm_name_gsym->binding_label =\n-              comm_block_tree->n.common->binding_label;\n-          else\n-            if (strcmp (comm_name_gsym->binding_label,\n-                        comm_block_tree->n.common->binding_label) != 0)\n+            comm_name_gsym->binding_label = bind_label;\n+          else if (strcmp (comm_name_gsym->binding_label, bind_label) != 0)\n               {\n                 /* Common block names match but binding labels do not.  */\n                 gfc_error (\"Binding label '%s' for common block '%s' at %L \"\n                            \"does not match the binding label '%s' for common \"\n                            \"block '%s' at %L\",\n-                           comm_block_tree->n.common->binding_label,\n+                           bind_label,\n                            comm_block_tree->n.common->name,\n                            &(comm_block_tree->n.common->where),\n                            comm_name_gsym->binding_label,\n@@ -9710,7 +9706,7 @@ resolve_bind_c_comms (gfc_symtree *comm_block_tree)\n \n       /* There is no binding label (NAME=\"\") so we have nothing further to\n          check and nothing to add as a global symbol for the label.  */\n-      if (comm_block_tree->n.common->binding_label[0] == '\\0' )\n+      if (!comm_block_tree->n.common->binding_label)\n         return;\n       \n       binding_label_gsym =\n@@ -9777,7 +9773,7 @@ gfc_verify_binding_labels (gfc_symbol *sym)\n   int has_error = 0;\n   \n   if (sym != NULL && sym->attr.is_bind_c && sym->attr.is_iso_c == 0 \n-      && sym->attr.flavor != FL_DERIVED && sym->binding_label[0] != '\\0')\n+      && sym->attr.flavor != FL_DERIVED && sym->binding_label)\n     {\n       gfc_gsymbol *bind_c_sym;\n \n@@ -9828,8 +9824,8 @@ gfc_verify_binding_labels (gfc_symbol *sym)\n               }\n \n           if (has_error != 0)\n-            /* Clear the binding label to prevent checking multiple times.  */\n-            sym->binding_label[0] = '\\0';\n+\t    /* Clear the binding label to prevent checking multiple times.  */\n+\t    sym->binding_label = NULL;\n         }\n       else if (bind_c_sym == NULL)\n \t{"}, {"sha": "e13e1df0d335e32bc7ae947d6a181122b2f36685", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=62603fae938764e6c7623048153f9d45c221ade1", "patch": "@@ -1,6 +1,6 @@\n /* Maintain binary trees of symbols.\n    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n-   2009, 2010, 2011\n+   2009, 2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -2556,8 +2556,6 @@ gfc_new_symbol (const char *name, gfc_namespace *ns)\n   /* Make sure flags for symbol being C bound are clear initially.  */\n   p->attr.is_bind_c = 0;\n   p->attr.is_iso_c = 0;\n-  /* Make sure the binding label field has a Nul char to start.  */\n-  p->binding_label[0] = '\\0';\n \n   /* Clear the ptrs we may need.  */\n   p->common_block = NULL;\n@@ -3805,8 +3803,8 @@ gen_special_c_interop_ptr (int ptr_id, const char *ptr_name,\n   \n   tmp_sym->attr.use_assoc = 1;\n   tmp_sym->attr.is_bind_c = 1;\n-  /* Set the binding_label.  */\n-  sprintf (tmp_sym->binding_label, \"%s_%s\", module_name, tmp_sym->name);\n+  /* Since we never generate a call to this symbol, don't set the\n+     binding_label.  */\n   \n   /* Set the c_address field of c_null_ptr and c_null_funptr to\n      the value of NULL.\t */\n@@ -4588,8 +4586,9 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n \n         /* Use the procedure's name as it is in the iso_c_binding module for\n            setting the binding label in case the user renamed the symbol.  */\n-\tsprintf (tmp_sym->binding_label, \"%s_%s\", mod_name,\n-                 c_interop_kinds_table[s].name);\n+\ttmp_sym->binding_label = \n+\t  gfc_get_string (\"%s_%s\", mod_name, \n+\t\t\t  c_interop_kinds_table[s].name);\n \ttmp_sym->attr.is_iso_c = 1;\n \tif (s == ISOCBINDING_F_POINTER || s == ISOCBINDING_F_PROCPOINTER)\n \t  tmp_sym->attr.subroutine = 1;\n@@ -4702,7 +4701,7 @@ get_iso_c_sym (gfc_symbol *old_sym, char *new_name,\n \t\t\t\"symtree for '%s'\", new_name);\n \n   /* Now fill in the fields of the resolved symbol with the old sym.  */\n-  strcpy (new_symtree->n.sym->binding_label, new_binding_label);\n+  new_symtree->n.sym->binding_label = new_binding_label;\n   new_symtree->n.sym->attr = old_sym->attr;\n   new_symtree->n.sym->ts = old_sym->ts;\n   new_symtree->n.sym->module = gfc_get_string (old_sym->module);"}, {"sha": "dcc2176a246ddcf4d61e8b4d9b84901efcc080c4", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=62603fae938764e6c7623048153f9d45c221ade1", "patch": "@@ -244,7 +244,7 @@ gfc_sym_mangled_common_id (gfc_common_head *com)\n   strcpy (name, com->name);\n \n   /* If we're suppose to do a bind(c).  */\n-  if (com->is_bind_c == 1 && com->binding_label[0] != '\\0')\n+  if (com->is_bind_c == 1 && com->binding_label)\n     return get_identifier (com->binding_label);\n \n   if (strcmp (name, BLANK_COMMON_NAME) == 0)"}, {"sha": "cb8f613813e22baa7f366297074c9cfe7ac61565", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=62603fae938764e6c7623048153f9d45c221ade1", "patch": "@@ -326,9 +326,8 @@ gfc_sym_mangled_identifier (gfc_symbol * sym)\n \n   /* Prevent the mangling of identifiers that have an assigned\n      binding label (mainly those that are bind(c)).  */\n-  if (sym->attr.is_bind_c == 1\n-      && sym->binding_label[0] != '\\0')\n-    return get_identifier(sym->binding_label);\n+  if (sym->attr.is_bind_c == 1 && sym->binding_label)\n+    return get_identifier (sym->binding_label);\n   \n   if (sym->module == NULL)\n     return gfc_sym_identifier (sym);\n@@ -352,7 +351,7 @@ gfc_sym_mangled_function_id (gfc_symbol * sym)\n      provided, and remove the other checks.  Then we could use it\n      for other things if we wished.  */\n   if ((sym->attr.is_bind_c == 1 || sym->attr.is_iso_c == 1) &&\n-      sym->binding_label[0] != '\\0')\n+      sym->binding_label)\n     /* use the binding label rather than the mangled name */\n     return get_identifier (sym->binding_label);\n "}, {"sha": "39dd3a00f07a4537983ffb6e8deeafc6c9a53228", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=62603fae938764e6c7623048153f9d45c221ade1", "patch": "@@ -1,3 +1,8 @@\n+2012-01-29  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR fortran/51808\n+\t* gfortran.dg/module_md5_1.f90: Update MD5 sum.\n+\n 2012-01-28  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/51972"}, {"sha": "0816a7053f50436462381de2f75d4107a147afa6", "filename": "gcc/testsuite/gfortran.dg/module_md5_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_md5_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62603fae938764e6c7623048153f9d45c221ade1/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_md5_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_md5_1.f90?ref=62603fae938764e6c7623048153f9d45c221ade1", "patch": "@@ -10,5 +10,5 @@ program test\n   use foo\n   print *, pi\n end program test\n-! { dg-final { scan-module \"foo\" \"MD5:12a205c48fe46315a609823f15986377\" } }\n+! { dg-final { scan-module \"foo\" \"MD5:510304affe70481794fecdb22fc9ca0c\" } }\n ! { dg-final { cleanup-modules \"foo\" } }"}]}