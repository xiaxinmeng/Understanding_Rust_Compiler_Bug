{"sha": "44c3a8bb733c1ecee2f5fa97d8b16331c30b37de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRjM2E4YmI3MzNjMWVjZWUyZjVmYTk3ZDhiMTYzMzFjMzBiMzdkZQ==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2014-08-17T23:39:53Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2014-08-17T23:39:53Z"}, "message": "constraints.md (\"S\"): Require TARGET_POWERPC64.\n\n2014-08-17  Segher Boessenkool  <segher@kernel.crashing.org>\n\n\t* config/rs6000/constraints.md (\"S\"): Require TARGET_POWERPC64.\n\t* config/rs6000/htm.md (ttest): Remove clobber.\n\t* config/rs6000/predicates.md (any_mask_operand): New predicate.\n\t(and_operand): Reformat.\n\t(and_2rld_operand): New predicate.\n\t* config/rs6000/rs6000-protos.h (rs6000_split_logical): Remove last\n\tparameter.\n\t* config/rs6000/rs6000.c (rs6000_split_logical_inner): Remove last\n\tparameter.  Handle AND directly.\n\t(rs6000_split_logical_di): Remove last parameter.\n\t(rs6000_split_logical): Remove last parameter.  Remove obsolete\n\tcomment.\n\t* config/rs6000/rs6000.md (BOOL_REGS_AND_CR0): Delete.\n\t(one_cmpl<mode>2): Adjust call of rs6000_split_logical.\n\t(ctz<mode>2, ffs<mode>2): Delete clobber.  Reformat.\n\t(andsi3, andsi3_mc, andsi3_nomc, *andsi3_internal2_mc,\n\t*andsi3_internal3_mc, *andsi3_internal4, *andsi3_internal5_mc,\n\tand 5 anonymous splitters):  Delete.\n\t(and<mode>3): New expander.\n\t(*and<mode>3, *and<mode>3_dot, *and<mode>3_dot2): New.\n\t(and<mode>3_imm, *and<mode>3_imm_dot, *and<mode>3_imm_dot2): New.\n\t(*and<mode>3_mask, *and<mode>3_mask_dot, *and<mode>3_mask_dot2): New.\n\t(ior<mode>, xor<mode>3): Adjust call of rs6000_split_logical.\n\t(floatdisf2_internal1): Remove clobbers.\n\t(anddi3, anddi3_mc, anddi3_nomc, anddi3_internal2_mc,\n\t*anddi3_internal3_mc, and 4 anonymous splitters): Delete.\n\t(*anddi3_2rld, *anddi3_2rld_dot, *anddi3_2rld_dot2): New.\n\t(and<mode>3 for BOOL_128): Remove clobber.\n\t(*and<mode>3_internal for BOOL_128): Remove clobber.  Adjust call of\n\trs6000_split_logical.\n\t(*bool<mode>3_internal for BOOL_128): Adjust call of\n\trs6000_split_logical.\n\t(*boolc<mode>3_internal1 for BOOL_128,\n\t*boolc<mode>3_internal2 for BOOL_128,\n\t*boolcc<mode>3_internal1 for BOOL_128,\n\t*boolcc<mode>3_internal2 for BOOL_128,\n\t*eqv<mode>3_internal1 for BOOL_128,\n\t*eqv<mode>3_internal2 for BOOL_128,\n\t*one_cmpl<mode>3_internal for BOOL_128): Ditto.\n\t* config/rs6000/vector.md (*vec_reload_and_plus_<mptrsize): Remove\n\tclobber.\n\t(*vec_reload_and_reg_<mptrsize>): Delete.\n\nFrom-SVN: r214080", "tree": {"sha": "795bbae1c6085ef276b5df925359b82dfd6a9cdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/795bbae1c6085ef276b5df925359b82dfd6a9cdd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44c3a8bb733c1ecee2f5fa97d8b16331c30b37de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44c3a8bb733c1ecee2f5fa97d8b16331c30b37de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44c3a8bb733c1ecee2f5fa97d8b16331c30b37de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44c3a8bb733c1ecee2f5fa97d8b16331c30b37de/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e7ee9a588ee946ab97886c06ac9848373791159d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7ee9a588ee946ab97886c06ac9848373791159d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7ee9a588ee946ab97886c06ac9848373791159d"}], "stats": {"total": 806, "additions": 351, "deletions": 455}, "files": [{"sha": "c70d519bc29457636be168cd9fc899ea98358ccf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c3a8bb733c1ecee2f5fa97d8b16331c30b37de/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c3a8bb733c1ecee2f5fa97d8b16331c30b37de/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44c3a8bb733c1ecee2f5fa97d8b16331c30b37de", "patch": "@@ -1,3 +1,48 @@\n+2014-08-17  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/constraints.md (\"S\"): Require TARGET_POWERPC64.\n+\t* config/rs6000/htm.md (ttest): Remove clobber.\n+\t* config/rs6000/predicates.md (any_mask_operand): New predicate.\n+\t(and_operand): Reformat.\n+\t(and_2rld_operand): New predicate.\n+\t* config/rs6000/rs6000-protos.h (rs6000_split_logical): Remove last\n+\tparameter.\n+\t* config/rs6000/rs6000.c (rs6000_split_logical_inner): Remove last\n+\tparameter.  Handle AND directly.\n+\t(rs6000_split_logical_di): Remove last parameter.\n+\t(rs6000_split_logical): Remove last parameter.  Remove obsolete\n+\tcomment.\n+\t* config/rs6000/rs6000.md (BOOL_REGS_AND_CR0): Delete.\n+\t(one_cmpl<mode>2): Adjust call of rs6000_split_logical.\n+\t(ctz<mode>2, ffs<mode>2): Delete clobber.  Reformat.\n+\t(andsi3, andsi3_mc, andsi3_nomc, *andsi3_internal2_mc,\n+\t*andsi3_internal3_mc, *andsi3_internal4, *andsi3_internal5_mc,\n+\tand 5 anonymous splitters):  Delete.\n+\t(and<mode>3): New expander.\n+\t(*and<mode>3, *and<mode>3_dot, *and<mode>3_dot2): New.\n+\t(and<mode>3_imm, *and<mode>3_imm_dot, *and<mode>3_imm_dot2): New.\n+\t(*and<mode>3_mask, *and<mode>3_mask_dot, *and<mode>3_mask_dot2): New.\n+\t(ior<mode>, xor<mode>3): Adjust call of rs6000_split_logical.\n+\t(floatdisf2_internal1): Remove clobbers.\n+\t(anddi3, anddi3_mc, anddi3_nomc, anddi3_internal2_mc,\n+\t*anddi3_internal3_mc, and 4 anonymous splitters): Delete.\n+\t(*anddi3_2rld, *anddi3_2rld_dot, *anddi3_2rld_dot2): New.\n+\t(and<mode>3 for BOOL_128): Remove clobber.\n+\t(*and<mode>3_internal for BOOL_128): Remove clobber.  Adjust call of\n+\trs6000_split_logical.\n+\t(*bool<mode>3_internal for BOOL_128): Adjust call of\n+\trs6000_split_logical.\n+\t(*boolc<mode>3_internal1 for BOOL_128,\n+\t*boolc<mode>3_internal2 for BOOL_128,\n+\t*boolcc<mode>3_internal1 for BOOL_128,\n+\t*boolcc<mode>3_internal2 for BOOL_128,\n+\t*eqv<mode>3_internal1 for BOOL_128,\n+\t*eqv<mode>3_internal2 for BOOL_128,\n+\t*one_cmpl<mode>3_internal for BOOL_128): Ditto.\n+\t* config/rs6000/vector.md (*vec_reload_and_plus_<mptrsize): Remove\n+\tclobber.\n+\t(*vec_reload_and_reg_<mptrsize>): Delete.\n+\n 2014-08-17  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* config/rs6000/rs6000.md (*boolccsi3_internal1, *boolccsi3_internal2"}, {"sha": "5ac71ac2e996af786acb241b9dd30002a2b75696", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c3a8bb733c1ecee2f5fa97d8b16331c30b37de/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c3a8bb733c1ecee2f5fa97d8b16331c30b37de/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=44c3a8bb733c1ecee2f5fa97d8b16331c30b37de", "patch": "@@ -232,7 +232,8 @@ usually better to use @samp{m} or @samp{es} in @code{asm} statements)\"\n \n (define_constraint \"S\"\n   \"Constant that can be placed into a 64-bit mask operand\"\n-  (match_operand 0 \"mask64_operand\"))\n+  (and (match_test \"TARGET_POWERPC64\")\n+       (match_operand 0 \"mask64_operand\")))\n \n (define_constraint \"T\"\n   \"Constant that can be placed into a 32-bit mask operand\""}, {"sha": "140212b42187ac4b89a005a3cf37014d2b0d620b", "filename": "gcc/config/rs6000/htm.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c3a8bb733c1ecee2f5fa97d8b16331c30b37de/gcc%2Fconfig%2Frs6000%2Fhtm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c3a8bb733c1ecee2f5fa97d8b16331c30b37de/gcc%2Fconfig%2Frs6000%2Fhtm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fhtm.md?ref=44c3a8bb733c1ecee2f5fa97d8b16331c30b37de", "patch": "@@ -180,9 +180,9 @@\n \t\t\t    UNSPECV_HTM_TABORTWCI))\n    (set (subreg:CC (match_dup 2) 0) (match_dup 1))\n    (set (match_dup 3) (lshiftrt:SI (match_dup 2) (const_int 28)))\n-   (parallel [(set (match_operand:SI 0 \"int_reg_operand\" \"\")\n-\t\t   (and:SI (match_dup 3) (const_int 15)))\n-              (clobber (scratch:CC))])]\n+   (set (match_operand:SI 0 \"int_reg_operand\" \"\")\n+\t(and:SI (match_dup 3)\n+\t\t(const_int 15)))]\n   \"TARGET_HTM\"\n {\n   operands[1] = gen_rtx_REG (CCmode, CR0_REGNO);"}, {"sha": "0c5b9961f030def515cdd78a6f14a8d660bb573d", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c3a8bb733c1ecee2f5fa97d8b16331c30b37de/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c3a8bb733c1ecee2f5fa97d8b16331c30b37de/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=44c3a8bb733c1ecee2f5fa97d8b16331c30b37de", "patch": "@@ -940,6 +940,12 @@\n   return c == -lsb;\n })\n \n+;; Match a mask_operand or a mask64_operand.\n+(define_predicate \"any_mask_operand\"\n+  (ior (match_operand 0 \"mask_operand\")\n+       (and (match_test \"TARGET_POWERPC64 && mode == DImode\")\n+\t    (match_operand 0 \"mask64_operand\"))))\n+\n ;; Like and_operand, but also match constants that can be implemented\n ;; with two rldicl or rldicr insns.\n (define_predicate \"and64_2_operand\"\n@@ -952,11 +958,18 @@\n ;; constant that can be used as the operand of a logical AND.\n (define_predicate \"and_operand\"\n   (ior (match_operand 0 \"mask_operand\")\n-       (ior (and (match_test \"TARGET_POWERPC64 && mode == DImode\")\n-\t\t (match_operand 0 \"mask64_operand\"))\n-            (if_then_else (match_test \"fixed_regs[CR0_REGNO]\")\n-\t      (match_operand 0 \"gpc_reg_operand\")\n-\t      (match_operand 0 \"logical_operand\")))))\n+       (and (match_test \"TARGET_POWERPC64 && mode == DImode\")\n+\t    (match_operand 0 \"mask64_operand\"))\n+       (if_then_else (match_test \"fixed_regs[CR0_REGNO]\")\n+\t (match_operand 0 \"gpc_reg_operand\")\n+\t (match_operand 0 \"logical_operand\"))))\n+\n+;; Return 1 if the operand is a constant that can be used as the operand\n+;; of a logical AND, implemented with two rld* insns, and it cannot be done\n+;; using just one insn.\n+(define_predicate \"and_2rld_operand\"\n+  (and (match_operand 0 \"and64_2_operand\")\n+       (not (match_operand 0 \"and_operand\"))))\n \n ;; Return 1 if the operand is either a logical operand or a short cint operand.\n (define_predicate \"scc_eq_operand\""}, {"sha": "abe29d5b1e4dec9fb8209a243003104d71e7211a", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c3a8bb733c1ecee2f5fa97d8b16331c30b37de/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c3a8bb733c1ecee2f5fa97d8b16331c30b37de/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=44c3a8bb733c1ecee2f5fa97d8b16331c30b37de", "patch": "@@ -150,7 +150,7 @@ extern rtx rs6000_address_for_fpconvert (rtx);\n extern rtx rs6000_address_for_altivec (rtx);\n extern rtx rs6000_allocate_stack_temp (enum machine_mode, bool, bool);\n extern int rs6000_loop_align (rtx);\n-extern void rs6000_split_logical (rtx [], enum rtx_code, bool, bool, bool, rtx);\n+extern void rs6000_split_logical (rtx [], enum rtx_code, bool, bool, bool);\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE"}, {"sha": "ec4e16325b0d08a3d2b9ed4762d2c5ae6f45d7b0", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 18, "deletions": 35, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c3a8bb733c1ecee2f5fa97d8b16331c30b37de/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c3a8bb733c1ecee2f5fa97d8b16331c30b37de/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=44c3a8bb733c1ecee2f5fa97d8b16331c30b37de", "patch": "@@ -32795,9 +32795,7 @@ rs6000_set_up_by_prologue (struct hard_reg_set_container *set)\n    MODE is the machine mode.\n    If COMPLEMENT_FINAL_P is true, wrap the whole operation with NOT.\n    If COMPLEMENT_OP1_P is true, wrap operand1 with NOT.\n-   If COMPLEMENT_OP2_P is true, wrap operand2 with NOT.\n-   CLOBBER_REG is either NULL or a scratch register of type CC to allow\n-   formation of the AND instructions.  */\n+   If COMPLEMENT_OP2_P is true, wrap operand2 with NOT.  */\n \n static void\n rs6000_split_logical_inner (rtx dest,\n@@ -32807,11 +32805,9 @@ rs6000_split_logical_inner (rtx dest,\n \t\t\t    enum machine_mode mode,\n \t\t\t    bool complement_final_p,\n \t\t\t    bool complement_op1_p,\n-\t\t\t    bool complement_op2_p,\n-\t\t\t    rtx clobber_reg)\n+\t\t\t    bool complement_op2_p)\n {\n   rtx bool_rtx;\n-  rtx set_rtx;\n \n   /* Optimize AND of 0/0xffffffff and IOR/XOR of 0.  */\n   if (op2 && GET_CODE (op2) == CONST_INT\n@@ -32851,6 +32847,13 @@ rs6000_split_logical_inner (rtx dest,\n \t}\n     }\n \n+  if (code == AND && mode == SImode\n+      && !complement_final_p && !complement_op1_p && !complement_op2_p)\n+    {\n+      emit_insn (gen_andsi3 (dest, op1, op2));\n+      return;\n+    }\n+\n   if (complement_op1_p)\n     op1 = gen_rtx_NOT (mode, op1);\n \n@@ -32864,17 +32867,7 @@ rs6000_split_logical_inner (rtx dest,\n   if (complement_final_p)\n     bool_rtx = gen_rtx_NOT (mode, bool_rtx);\n \n-  set_rtx = gen_rtx_SET (VOIDmode, dest, bool_rtx);\n-\n-  /* Is this AND with an explicit clobber?  */\n-  if (clobber_reg)\n-    {\n-      rtx clobber = gen_rtx_CLOBBER (VOIDmode, clobber_reg);\n-      set_rtx = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set_rtx, clobber));\n-    }\n-\n-  emit_insn (set_rtx);\n-  return;\n+  emit_insn (gen_rtx_SET (VOIDmode, dest, bool_rtx));\n }\n \n /* Split a DImode AND/IOR/XOR with a constant on a 32-bit system.  These\n@@ -32895,8 +32888,7 @@ rs6000_split_logical_di (rtx operands[3],\n \t\t\t enum rtx_code code,\n \t\t\t bool complement_final_p,\n \t\t\t bool complement_op1_p,\n-\t\t\t bool complement_op2_p,\n-\t\t\t rtx clobber_reg)\n+\t\t\t bool complement_op2_p)\n {\n   const HOST_WIDE_INT lower_32bits = HOST_WIDE_INT_C(0xffffffff);\n   const HOST_WIDE_INT upper_32bits = ~ lower_32bits;\n@@ -32957,7 +32949,6 @@ rs6000_split_logical_di (rtx operands[3],\n \t  && !complement_final_p\n \t  && !complement_op1_p\n \t  && !complement_op2_p\n-\t  && clobber_reg == NULL_RTX\n \t  && !logical_const_operand (op2_hi_lo[i], SImode))\n \t{\n \t  HOST_WIDE_INT value = INTVAL (op2_hi_lo[i]);\n@@ -32970,18 +32961,15 @@ rs6000_split_logical_di (rtx operands[3],\n \t    hi_16bits |= upper_32bits;\n \n \t  rs6000_split_logical_inner (tmp, op1_hi_lo[i], GEN_INT (hi_16bits),\n-\t\t\t\t      code, SImode, false, false, false,\n-\t\t\t\t      NULL_RTX);\n+\t\t\t\t      code, SImode, false, false, false);\n \n \t  rs6000_split_logical_inner (op0_hi_lo[i], tmp, GEN_INT (lo_16bits),\n-\t\t\t\t      code, SImode, false, false, false,\n-\t\t\t\t      NULL_RTX);\n+\t\t\t\t      code, SImode, false, false, false);\n \t}\n       else\n \trs6000_split_logical_inner (op0_hi_lo[i], op1_hi_lo[i], op2_hi_lo[i],\n \t\t\t\t    code, SImode, complement_final_p,\n-\t\t\t\t    complement_op1_p, complement_op2_p,\n-\t\t\t\t    clobber_reg);\n+\t\t\t\t    complement_op1_p, complement_op2_p);\n     }\n \n   return;\n@@ -32993,20 +32981,16 @@ rs6000_split_logical_di (rtx operands[3],\n \n    OPERANDS is an array containing the destination and two input operands.\n    CODE is the base operation (AND, IOR, XOR, NOT).\n-   MODE is the machine mode.\n    If COMPLEMENT_FINAL_P is true, wrap the whole operation with NOT.\n    If COMPLEMENT_OP1_P is true, wrap operand1 with NOT.\n-   If COMPLEMENT_OP2_P is true, wrap operand2 with NOT.\n-   CLOBBER_REG is either NULL or a scratch register of type CC to allow\n-   formation of the AND instructions.  */\n+   If COMPLEMENT_OP2_P is true, wrap operand2 with NOT.  */\n \n void\n rs6000_split_logical (rtx operands[3],\n \t\t      enum rtx_code code,\n \t\t      bool complement_final_p,\n \t\t      bool complement_op1_p,\n-\t\t      bool complement_op2_p,\n-\t\t      rtx clobber_reg)\n+\t\t      bool complement_op2_p)\n {\n   enum machine_mode mode = GET_MODE (operands[0]);\n   enum machine_mode sub_mode;\n@@ -33018,8 +33002,7 @@ rs6000_split_logical (rtx operands[3],\n   if (mode == DImode && !TARGET_POWERPC64)\n     {\n       rs6000_split_logical_di (operands, code, complement_final_p,\n-\t\t\t       complement_op1_p, complement_op2_p,\n-\t\t\t       clobber_reg);\n+\t\t\t       complement_op1_p, complement_op2_p);\n       return;\n     }\n \n@@ -33052,7 +33035,7 @@ rs6000_split_logical (rtx operands[3],\n \n       rs6000_split_logical_inner (sub_op0, sub_op1, sub_op2, code, sub_mode,\n \t\t\t\t  complement_final_p, complement_op1_p,\n-\t\t\t\t  complement_op2_p, clobber_reg);\n+\t\t\t\t  complement_op2_p);\n     }\n \n   return;"}, {"sha": "2d1033cbce661c28fbdbceeb025c728747b05bfb", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 261, "deletions": 391, "changes": 652, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c3a8bb733c1ecee2f5fa97d8b16331c30b37de/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c3a8bb733c1ecee2f5fa97d8b16331c30b37de/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=44c3a8bb733c1ecee2f5fa97d8b16331c30b37de", "patch": "@@ -551,19 +551,6 @@\n \t\t\t\t\t (V2DI\t\"wa,v,r,0,0\")\n \t\t\t\t\t (V2DF\t\"wa,v,r,0,0\")\n \t\t\t\t\t (V1TI\t\"wa,v,r,0,0\")])\n-\n-;; Mode attribute for the clobber of CC0 for AND expansion.\n-;; For the 128-bit types, we never do AND immediate, but we need to\n-;; get the correct number of X's for the number of operands.\n-(define_mode_attr BOOL_REGS_AND_CR0\t[(TI\t\"X,X,X,X,X\")\n-\t\t\t\t\t (PTI\t\"X,X,X\")\n-\t\t\t\t\t (V16QI\t\"X,X,X,X,X\")\n-\t\t\t\t\t (V8HI\t\"X,X,X,X,X\")\n-\t\t\t\t\t (V4SI\t\"X,X,X,X,X\")\n-\t\t\t\t\t (V4SF\t\"X,X,X,X,X\")\n-\t\t\t\t\t (V2DI\t\"X,X,X,X,X\")\n-\t\t\t\t\t (V2DF\t\"X,X,X,X,X\")\n-\t\t\t\t\t (V1TI\t\"X,X,X,X,X\")])\n \f\n ;; Start with fixed-point load and store insns.  Here we put only the more\n ;; complex forms.  Basic data transfer is done later.\n@@ -1956,7 +1943,7 @@\n {\n   if (<MODE>mode == DImode && !TARGET_POWERPC64)\n     {\n-      rs6000_split_logical (operands, NOT, false, false, false, NULL_RTX);\n+      rs6000_split_logical (operands, NOT, false, false, false);\n       DONE;\n     }\n })\n@@ -2185,12 +2172,14 @@\n (define_expand \"ctz<mode>2\"\n   [(set (match_dup 2)\n \t(neg:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"\")))\n-   (parallel [(set (match_dup 3) (and:GPR (match_dup 1)\n-\t\t\t\t\t  (match_dup 2)))\n-\t      (clobber (scratch:CC))])\n-   (set (match_dup 4) (clz:GPR (match_dup 3)))\n+   (set (match_dup 3)\n+\t(and:GPR (match_dup 1)\n+\t\t (match_dup 2)))\n+   (set (match_dup 4)\n+\t(clz:GPR (match_dup 3)))\n    (set (match_operand:GPR 0 \"gpc_reg_operand\" \"\")\n-\t(minus:GPR (match_dup 5) (match_dup 4)))]\n+\t(minus:GPR (match_dup 5)\n+\t\t   (match_dup 4)))]\n   \"\"\n   {\n      operands[2] = gen_reg_rtx (<MODE>mode);\n@@ -2202,12 +2191,14 @@\n (define_expand \"ffs<mode>2\"\n   [(set (match_dup 2)\n \t(neg:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"\")))\n-   (parallel [(set (match_dup 3) (and:GPR (match_dup 1)\n-\t\t\t\t\t  (match_dup 2)))\n-\t      (clobber (scratch:CC))])\n-   (set (match_dup 4) (clz:GPR (match_dup 3)))\n+   (set (match_dup 3)\n+\t(and:GPR (match_dup 1)\n+\t\t (match_dup 2)))\n+   (set (match_dup 4)\n+\t(clz:GPR (match_dup 3)))\n    (set (match_operand:GPR 0 \"gpc_reg_operand\" \"\")\n-\t(minus:GPR (match_dup 5) (match_dup 4)))]\n+\t(minus:GPR (match_dup 5)\n+\t\t   (match_dup 4)))]\n   \"\"\n   {\n      operands[2] = gen_reg_rtx (<MODE>mode);\n@@ -2919,221 +2910,226 @@\n ;; plain 'andi' (only 'andi.'), no plain 'andis', and there are all\n ;; those rotate-and-mask operations.  Thus, the AND insns come first.\n \n-(define_expand \"andsi3\"\n-  [(parallel\n-    [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t  (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t  (match_operand:SI 2 \"and_operand\" \"\")))\n-     (clobber (match_scratch:CC 3 \"\"))])]\n+(define_expand \"and<mode>3\"\n+  [(set (match_operand:SDI 0 \"gpc_reg_operand\" \"\")\n+\t(and:SDI (match_operand:SDI 1 \"gpc_reg_operand\" \"\")\n+\t\t (match_operand:SDI 2 \"reg_or_cint_operand\" \"\")))]\n   \"\"\n-  \"\")\n-\n-(define_insn \"andsi3_mc\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r\")\n-\t(and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r\")\n-\t\t(match_operand:SI 2 \"and_operand\" \"?r,T,K,L\")))\n-   (clobber (match_scratch:CC 3 \"=X,X,x,x\"))]\n-  \"rs6000_gen_cell_microcode\"\n-  \"@\n-   and %0,%1,%2\n-   rlwinm %0,%1,0,%m2,%M2\n-   andi. %0,%1,%b2\n-   andis. %0,%1,%u2\"\n-  [(set_attr \"type\" \"*,shift,logical,logical\")\n-   (set_attr \"dot\" \"no,no,yes,yes\")])\n+{\n+  if (<MODE>mode == DImode && !TARGET_POWERPC64)\n+    {\n+      rs6000_split_logical (operands, AND, false, false, false);\n+      DONE;\n+    }\n \n-(define_insn \"andsi3_nomc\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t\t(match_operand:SI 2 \"and_operand\" \"?r,T\")))\n-   (clobber (match_scratch:CC 3 \"=X,X\"))]\n-  \"!rs6000_gen_cell_microcode\"\n-  \"@\n-   and %0,%1,%2\n-   rlwinm %0,%1,0,%m2,%M2\"\n-  [(set_attr \"type\" \"logical,shift\")])\n+  if (logical_const_operand (operands[2], <MODE>mode)\n+      && !any_mask_operand (operands[2], <MODE>mode))\n+    {\n+      emit_insn (gen_and<mode>3_imm (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n \n-(define_insn \"andsi3_internal0_nomc\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-        (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\")\n-                (match_operand:SI 2 \"and_operand\" \"?r,T\")))]\n-  \"!rs6000_gen_cell_microcode\"\n-  \"@\n-   and %0,%1,%2\n-   rlwinm %0,%1,0,%m2,%M2\"\n-  [(set_attr \"type\" \"logical,shift\")])\n+  if ((<MODE>mode == DImode && !and64_2_operand (operands[2], <MODE>mode))\n+      || (<MODE>mode != DImode && !and_operand (operands[2], <MODE>mode)))\n+    operands[2] = force_reg (<MODE>mode, operands[2]);\n+})\n \n \n-;; Note to set cr's other than cr0 we do the and immediate and then\n-;; the test again -- this avoids a mfcr which on the higher end\n-;; machines causes an execution serialization\n+(define_insn \"*and<mode>3\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+\t(and:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n+\t\t (match_operand:GPR 2 \"gpc_reg_operand\" \"r\")))]\n+  \"\"\n+  \"and %0,%1,%2\"\n+  [(set_attr \"type\" \"logical\")])\n \n-(define_insn \"*andsi3_internal2_mc\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x,x,x,?y,??y,??y,?y\")\n-\t(compare:CC (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r\")\n-\t\t\t    (match_operand:SI 2 \"and_operand\" \"r,K,L,T,r,K,L,T\"))\n+(define_insn_and_split \"*and<mode>3_dot\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n+\t(compare:CC (and:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r,r\")\n+\t\t\t     (match_operand:GPR 2 \"gpc_reg_operand\" \"r,r\"))\n \t\t    (const_int 0)))\n-   (clobber (match_scratch:SI 3 \"=r,r,r,r,r,r,r,r\"))\n-   (clobber (match_scratch:CC 4 \"=X,X,X,X,X,x,x,X\"))]\n-  \"TARGET_32BIT && rs6000_gen_cell_microcode\"\n+   (clobber (match_scratch:GPR 0 \"=r,r\"))]\n+  \"<MODE>mode == Pmode && rs6000_gen_cell_microcode\"\n   \"@\n-   and. %3,%1,%2\n-   andi. %3,%1,%b2\n-   andis. %3,%1,%u2\n-   rlwinm. %3,%1,0,%m2,%M2\n-   #\n-   #\n-   #\n+   and. %0,%1,%2\n    #\"\n-  [(set_attr \"type\" \"logical,logical,logical,shift,\\\n-\t\t     compare,compare,compare,compare\")\n+  \"&& reload_completed && cc_reg_not_cr0_operand (operands[3], CCmode)\"\n+  [(set (match_dup 0)\n+\t(and:GPR (match_dup 1)\n+\t\t (match_dup 2)))\n+   (set (match_dup 3)\n+\t(compare:CC (match_dup 0)\n+\t\t    (const_int 0)))]\n+  \"\"\n+  [(set_attr \"type\" \"logical\")\n    (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"4,4,4,4,8,8,8,8\")])\n+   (set_attr \"length\" \"4,8\")])\n \n-(define_insn \"*andsi3_internal3_mc\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x,x,x,?y,??y,??y,?y\")\n-\t(compare:CC (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r\")\n-\t\t\t    (match_operand:SI 2 \"and_operand\" \"r,K,L,T,r,K,L,T\"))\n+(define_insn_and_split \"*and<mode>3_dot2\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n+\t(compare:CC (and:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r,r\")\n+\t\t\t     (match_operand:GPR 2 \"gpc_reg_operand\" \"r,r\"))\n \t\t    (const_int 0)))\n-   (clobber (match_scratch:SI 3 \"=r,r,r,r,r,r,r,r\"))\n-   (clobber (match_scratch:CC 4 \"=X,X,X,X,X,x,x,X\"))]\n-  \"TARGET_64BIT && rs6000_gen_cell_microcode\"\n+   (set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(and:GPR (match_dup 1)\n+\t\t (match_dup 2)))]\n+  \"<MODE>mode == Pmode && rs6000_gen_cell_microcode\"\n   \"@\n-   #\n-   andi. %3,%1,%b2\n-   andis. %3,%1,%u2\n-   rlwinm. %3,%1,0,%m2,%M2\n-   #\n-   #\n-   #\n+   and. %0,%1,%2\n    #\"\n-  [(set_attr \"type\" \"compare,logical,logical,shift,compare,\\\n-\t\t     compare,compare,compare\")\n+  \"&& reload_completed && cc_reg_not_cr0_operand (operands[3], CCmode)\"\n+  [(set (match_dup 0)\n+\t(and:GPR (match_dup 1)\n+\t\t (match_dup 2)))\n+   (set (match_dup 3)\n+\t(compare:CC (match_dup 0)\n+\t\t    (const_int 0)))]\n+  \"\"\n+  [(set_attr \"type\" \"logical\")\n    (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"8,4,4,4,8,8,8,8\")])\n+   (set_attr \"length\" \"4,8\")])\n \n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_micro_cr0_operand\" \"\")\n-\t(compare:CC (and:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"\")\n-\t\t\t     (match_operand:GPR 2 \"and_operand\" \"\"))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:GPR 3 \"\"))\n-   (clobber (match_scratch:CC 4 \"\"))]\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 3)\n-\t\t   (and:<MODE> (match_dup 1)\n-\t\t\t       (match_dup 2)))\n-\t      (clobber (match_dup 4))])\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 3)\n-\t\t    (const_int 0)))]\n-  \"\")\n \n-;; We don't have a 32 bit \"and. rt,ra,rb\" for ppc64.  cr is set from the\n-;; whole 64 bit reg, and we don't know what is in the high 32 bits.\n+(define_insn \"and<mode>3_imm\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+\t(and:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"%r\")\n+\t\t (match_operand:GPR 2 \"logical_const_operand\" \"n\")))\n+   (clobber (match_scratch:CC 3 \"=x\"))]\n+  \"rs6000_gen_cell_microcode\n+   && !any_mask_operand (operands[2], <MODE>mode)\"\n+  \"andi%e2. %0,%1,%u2\"\n+  [(set_attr \"type\" \"logical\")\n+   (set_attr \"dot\" \"yes\")])\n \n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"\")\n-\t(compare:CC (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"\"))\n+(define_insn_and_split \"*and<mode>3_imm_dot\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,??y\")\n+\t(compare:CC (and:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"%r,r\")\n+\t\t\t     (match_operand:GPR 2 \"logical_const_operand\" \"n,n\"))\n \t\t    (const_int 0)))\n-   (clobber (match_scratch:SI 3 \"\"))\n-   (clobber (match_scratch:CC 4 \"\"))]\n-  \"TARGET_POWERPC64 && reload_completed\"\n-  [(parallel [(set (match_dup 3)\n-\t\t   (and:SI (match_dup 1)\n-\t\t\t   (match_dup 2)))\n+   (clobber (match_scratch:GPR 0 \"=r,r\"))\n+   (clobber (match_scratch:CC 4 \"=X,x\"))]\n+  \"(<MODE>mode == Pmode || UINTVAL (operands[2]) <= 0x7fffffff)\n+   && rs6000_gen_cell_microcode\"\n+  \"@\n+   andi%e2. %0,%1,%u2\n+   #\"\n+  \"&& reload_completed && cc_reg_not_cr0_operand (operands[3], CCmode)\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (and:GPR (match_dup 1)\n+\t\t\t    (match_dup 2)))\n \t      (clobber (match_dup 4))])\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 3)\n+   (set (match_dup 3)\n+\t(compare:CC (match_dup 0)\n \t\t    (const_int 0)))]\n-  \"\")\n+  \"\"\n+  [(set_attr \"type\" \"logical\")\n+   (set_attr \"dot\" \"yes\")\n+   (set_attr \"length\" \"4,8\")])\n \n-(define_insn \"*andsi3_internal4\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x,x,x,?y,??y,??y,?y\")\n-\t(compare:CC (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r\")\n-\t\t\t    (match_operand:SI 2 \"and_operand\" \"r,K,L,T,r,K,L,T\"))\n+(define_insn_and_split \"*and<mode>3_imm_dot2\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,??y\")\n+\t(compare:CC (and:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"%r,r\")\n+\t\t\t     (match_operand:GPR 2 \"logical_const_operand\" \"n,n\"))\n \t\t    (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r,r,r,r,r\")\n-\t(and:SI (match_dup 1)\n-\t\t(match_dup 2)))\n-   (clobber (match_scratch:CC 4 \"=X,X,X,X,X,x,x,X\"))]\n-  \"TARGET_32BIT && rs6000_gen_cell_microcode\"\n+   (set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(and:GPR (match_dup 1)\n+\t\t (match_dup 2)))\n+   (clobber (match_scratch:CC 4 \"=X,x\"))]\n+  \"(<MODE>mode == Pmode || UINTVAL (operands[2]) <= 0x7fffffff)\n+   && rs6000_gen_cell_microcode\"\n   \"@\n-   and. %0,%1,%2\n-   andi. %0,%1,%b2\n-   andis. %0,%1,%u2\n-   rlwinm. %0,%1,0,%m2,%M2\n-   #\n-   #\n-   #\n+   andi%e2. %0,%1,%u2\n    #\"\n-  [(set_attr \"type\" \"logical,logical,logical,shift,\\\n-\t\t     compare,compare,compare,compare\")\n+  \"&& reload_completed && cc_reg_not_cr0_operand (operands[3], CCmode)\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (and:GPR (match_dup 1)\n+\t\t\t    (match_dup 2)))\n+\t      (clobber (match_dup 4))])\n+   (set (match_dup 3)\n+\t(compare:CC (match_dup 0)\n+\t\t    (const_int 0)))]\n+  \"\"\n+  [(set_attr \"type\" \"logical\")\n    (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"4,4,4,4,8,8,8,8\")])\n+   (set_attr \"length\" \"4,8\")])\n \n-(define_insn \"*andsi3_internal5_mc\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x,x,x,?y,??y,??y,?y\")\n-\t(compare:CC (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r\")\n-\t\t\t    (match_operand:SI 2 \"and_operand\" \"r,K,L,T,r,K,L,T\"))\n+\n+(define_insn \"*and<mode>3_mask\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(and:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"%r,r\")\n+\t\t (match_operand:GPR 2 \"any_mask_operand\" \"S,T\")))]\n+  \"\"\n+  \"@\n+   rldic%B2 %0,%1,0,%S2\n+   rlwinm %0,%1,0,%m2,%M2\"\n+  [(set_attr \"type\" \"shift\")])\n+\n+(define_insn_and_split \"*and<mode>3_mask_dot\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x,?y,?y\")\n+\t(compare:CC (and:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"%r,r,r,r\")\n+\t\t\t     (match_operand:GPR 2 \"any_mask_operand\" \"S,T,S,T\"))\n \t\t    (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r,r,r,r,r\")\n-\t(and:SI (match_dup 1)\n-\t\t(match_dup 2)))\n-   (clobber (match_scratch:CC 4 \"=X,X,X,X,X,x,x,X\"))]\n-  \"TARGET_64BIT && rs6000_gen_cell_microcode\"\n+   (clobber (match_scratch:GPR 0 \"=r,r,r,r\"))]\n+  \"(<MODE>mode == Pmode || UINTVAL (operands[2]) <= 0x7fffffff)\n+   && rs6000_gen_cell_microcode\n+   && !logical_const_operand (operands[2], <MODE>mode)\"\n   \"@\n-   #\n-   andi. %0,%1,%b2\n-   andis. %0,%1,%u2\n+   rldic%B2. %0,%1,0,%S2\n    rlwinm. %0,%1,0,%m2,%M2\n    #\n-   #\n-   #\n    #\"\n-  [(set_attr \"type\" \"compare,logical,logical,shift,compare,\\\n-\t\t     compare,compare,compare\")\n-   (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"8,4,4,4,8,8,8,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_micro_cr0_operand\" \"\")\n-\t(compare:CC (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:SI 2 \"and_operand\" \"\"))\n-\t\t    (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(and:SI (match_dup 1)\n-\t\t(match_dup 2)))\n-   (clobber (match_scratch:CC 4 \"\"))]\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (and:SI (match_dup 1)\n-\t\t\t   (match_dup 2)))\n-\t      (clobber (match_dup 4))])\n+  \"&& reload_completed && cc_reg_not_cr0_operand (operands[3], CCmode)\"\n+  [(set (match_dup 0)\n+\t(and:GPR (match_dup 1)\n+\t\t (match_dup 2)))\n    (set (match_dup 3)\n \t(compare:CC (match_dup 0)\n \t\t    (const_int 0)))]\n-  \"\")\n+  \"\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"dot\" \"yes\")\n+   (set_attr \"length\" \"4,4,8,8\")])\n \n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"\")\n-\t(compare:CC (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"\"))\n+(define_insn_and_split \"*and<mode>3_mask_dot2\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x,?y,?y\")\n+\t(compare:CC (and:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"%r,r,r,r\")\n+\t\t\t     (match_operand:GPR 2 \"any_mask_operand\" \"S,T,S,T\"))\n \t\t    (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(and:SI (match_dup 1)\n-\t\t(match_dup 2)))\n-   (clobber (match_scratch:CC 4 \"\"))]\n-  \"TARGET_POWERPC64 && reload_completed\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (and:SI (match_dup 1)\n-\t\t\t   (match_dup 2)))\n-\t      (clobber (match_dup 4))])\n+   (set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r,r,r,r\")\n+\t(and:GPR (match_dup 1)\n+\t\t (match_dup 2)))]\n+  \"(<MODE>mode == Pmode || UINTVAL (operands[2]) <= 0x7fffffff)\n+   && rs6000_gen_cell_microcode\n+   && !logical_const_operand (operands[2], <MODE>mode)\"\n+  \"@\n+   rldic%B2. %0,%1,0,%S2\n+   rlwinm. %0,%1,0,%m2,%M2\n+   #\n+   #\"\n+  \"&& reload_completed && cc_reg_not_cr0_operand (operands[3], CCmode)\"\n+  [(set (match_dup 0)\n+\t(and:GPR (match_dup 1)\n+\t\t (match_dup 2)))\n    (set (match_dup 3)\n \t(compare:CC (match_dup 0)\n \t\t    (const_int 0)))]\n-  \"\")\n+  \"\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"dot\" \"yes\")\n+   (set_attr \"length\" \"4,4,8,8\")])\n+\n+\n+\n+(define_insn \"andsi3_internal0_nomc\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n+        (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\")\n+                (match_operand:SI 2 \"and_operand\" \"?r,T\")))]\n+  \"!rs6000_gen_cell_microcode\"\n+  \"@\n+   and %0,%1,%2\n+   rlwinm %0,%1,0,%m2,%M2\"\n+  [(set_attr \"type\" \"logical,shift\")])\n+\n \n ;; Handle the PowerPC64 rlwinm corner case\n \n@@ -3168,7 +3164,7 @@\n {\n   if (<MODE>mode == DImode && !TARGET_POWERPC64)\n     {\n-      rs6000_split_logical (operands, IOR, false, false, false, NULL_RTX);\n+      rs6000_split_logical (operands, IOR, false, false, false);\n       DONE;\n     }\n \n@@ -3198,7 +3194,7 @@\n {\n   if (<MODE>mode == DImode && !TARGET_POWERPC64)\n     {\n-      rs6000_split_logical (operands, XOR, false, false, false, NULL_RTX);\n+      rs6000_split_logical (operands, XOR, false, false, false);\n       DONE;\n     }\n \n@@ -6479,9 +6475,8 @@\n (define_expand \"floatdisf2_internal2\"\n   [(set (match_dup 3) (ashiftrt:DI (match_operand:DI 1 \"\" \"\")\n \t\t\t\t   (const_int 53)))\n-   (parallel [(set (match_operand:DI 0 \"\" \"\") (and:DI (match_dup 1)\n-\t\t\t\t\t\t      (const_int 2047)))\n-\t      (clobber (scratch:CC))])\n+   (set (match_operand:DI 0 \"\" \"\") (and:DI (match_dup 1)\n+\t\t\t\t\t   (const_int 2047)))\n    (set (match_dup 3) (plus:DI (match_dup 3)\n \t\t\t       (const_int 1)))\n    (set (match_dup 0) (plus:DI (match_dup 0)\n@@ -6490,9 +6485,8 @@\n \t\t\t\t     (const_int 2)))\n    (set (match_dup 0) (ior:DI (match_dup 0)\n \t\t\t      (match_dup 1)))\n-   (parallel [(set (match_dup 0) (and:DI (match_dup 0)\n-\t\t\t\t\t (const_int -2048)))\n-\t      (clobber (scratch:CC))])\n+   (set (match_dup 0) (and:DI (match_dup 0)\n+\t\t\t      (const_int -2048)))\n    (set (pc) (if_then_else (geu (match_dup 4) (const_int 0))\n \t\t\t   (label_ref (match_operand:DI 2 \"\" \"\"))\n \t\t\t   (pc)))\n@@ -7627,64 +7621,14 @@\n \t\t    (const_int 0)))]\n   \"\")\n \n-(define_expand \"anddi3\"\n-  [(parallel\n-    [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t  (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t  (match_operand:DI 2 \"reg_or_cint_operand\" \"\")))\n-     (clobber (match_scratch:CC 3 \"\"))])]\n-  \"\"\n-{\n-  if (!TARGET_POWERPC64)\n-    {\n-      rtx cc = gen_rtx_SCRATCH (CCmode);\n-      rs6000_split_logical (operands, AND, false, false, false, cc);\n-      DONE;\n-    }\n-  else if (!and64_2_operand (operands[2], DImode))\n-    operands[2] = force_reg (DImode, operands[2]);\n-})\n-\n-(define_insn \"anddi3_mc\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r,r,r,r\")\n-\t(and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r\")\n-\t\t(match_operand:DI 2 \"and64_2_operand\" \"?r,S,T,K,J,t\")))\n-   (clobber (match_scratch:CC 3 \"=X,X,X,x,x,X\"))]\n-  \"TARGET_POWERPC64 && rs6000_gen_cell_microcode\"\n-  \"@\n-   and %0,%1,%2\n-   rldic%B2 %0,%1,0,%S2\n-   rlwinm %0,%1,0,%m2,%M2\n-   andi. %0,%1,%b2\n-   andis. %0,%1,%u2\n-   #\"\n-  [(set_attr \"type\" \"*,shift,shift,logical,logical,*\")\n-   (set_attr \"dot\" \"no,no,no,yes,yes,no\")\n-   (set_attr \"length\" \"4,4,4,4,4,8\")])\n-\n-(define_insn \"anddi3_nomc\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r,r\")\n-\t(and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r,r\")\n-\t\t(match_operand:DI 2 \"and64_2_operand\" \"?r,S,T,t\")))\n-   (clobber (match_scratch:CC 3 \"=X,X,X,X\"))]\n-  \"TARGET_POWERPC64 && !rs6000_gen_cell_microcode\"\n-  \"@\n-   and %0,%1,%2\n-   rldic%B2 %0,%1,0,%S2\n-   rlwinm %0,%1,0,%m2,%M2\n-   #\"\n-  [(set_attr \"type\" \"*,shift,shift,*\")\n-   (set_attr \"length\" \"4,4,4,8\")])\n \n-(define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t(match_operand:DI 2 \"mask64_2_operand\" \"\")))\n-   (clobber (match_scratch:CC 3 \"\"))]\n-  \"TARGET_POWERPC64\n-    && (fixed_regs[CR0_REGNO] || !logical_operand (operands[2], DImode))\n-    && !mask_operand (operands[2], DImode)\n-    && !mask64_operand (operands[2], DImode)\"\n+(define_insn_and_split \"*anddi3_2rld\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\")\n+\t\t(match_operand:DI 2 \"and_2rld_operand\" \"n\")))]\n+  \"TARGET_POWERPC64\"\n+  \"#\"\n+  \"\"\n   [(set (match_dup 0)\n \t(and:DI (rotate:DI (match_dup 1)\n \t\t\t   (match_dup 4))\n@@ -7695,144 +7639,76 @@\n \t\t(match_dup 7)))]\n {\n   build_mask64_2_operands (operands[2], &operands[4]);\n-})\n+}\n+  [(set_attr \"length\" \"8\")])\n \n-(define_insn \"*anddi3_internal2_mc\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x,x,x,x,x,?y,?y,?y,??y,??y,?y\")\n-\t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r,r,r,r,r\")\n-\t\t\t    (match_operand:DI 2 \"and64_2_operand\" \"r,S,T,K,J,t,r,S,T,K,J,t\"))\n+(define_insn_and_split \"*anddi3_2rld_dot\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n+\t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\")\n+\t\t\t    (match_operand:DI 2 \"and_2rld_operand\" \"n,n\"))\n \t\t    (const_int 0)))\n-   (clobber (match_scratch:DI 3 \"=r,r,r,r,r,r,r,r,r,r,r,r\"))\n-   (clobber (match_scratch:CC 4 \"=X,X,X,X,X,X,X,X,X,x,x,X\"))]\n+   (clobber (match_scratch:DI 0 \"=r,r\"))]\n   \"TARGET_64BIT && rs6000_gen_cell_microcode\"\n   \"@\n-   and. %3,%1,%2\n-   rldic%B2. %3,%1,0,%S2\n-   rlwinm. %3,%1,0,%m2,%M2\n-   andi. %3,%1,%b2\n-   andis. %3,%1,%u2\n-   #\n-   #\n-   #\n-   #\n-   #\n    #\n    #\"\n-  [(set_attr \"type\" \"logical,shift,shift,logical,\\\n-\t\t     logical,compare,compare,compare,compare,compare,\\\n-\t\t     compare,compare\")\n-   (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"4,4,4,4,4,8,8,8,8,8,8,12\")])\n-\n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"\")\n-        (compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-                            (match_operand:DI 2 \"mask64_2_operand\" \"\"))\n-                    (const_int 0)))\n-   (clobber (match_scratch:DI 3 \"\"))\n-   (clobber (match_scratch:CC 4 \"\"))]\n-  \"TARGET_64BIT && reload_completed\n-    && (fixed_regs[CR0_REGNO] || !logical_operand (operands[2], DImode))\n-    && !mask_operand (operands[2], DImode)\n-    && !mask64_operand (operands[2], DImode)\"\n-  [(set (match_dup 3)\n+  \"&& reload_completed\"\n+  [(set (match_dup 0)\n \t(and:DI (rotate:DI (match_dup 1)\n-\t\t\t   (match_dup 5))\n-\t\t(match_dup 6)))\n-   (parallel [(set (match_dup 0)\n-\t\t   (compare:CC (and:DI (rotate:DI (match_dup 3)\n-\t\t\t\t\t\t  (match_dup 7))\n-\t\t\t\t       (match_dup 8))\n+\t\t\t   (match_dup 4))\n+\t\t(match_dup 5)))\n+   (parallel [(set (match_dup 3)\n+\t\t   (compare:CC (and:DI (rotate:DI (match_dup 0)\n+\t\t\t\t\t\t  (match_dup 6))\n+\t\t\t\t       (match_dup 7))\n \t\t\t       (const_int 0)))\n-\t      (clobber (match_dup 3))])]\n-  \"\n+\t      (clobber (match_dup 0))])]\n {\n-  build_mask64_2_operands (operands[2], &operands[5]);\n-}\")\n+  build_mask64_2_operands (operands[2], &operands[4]);\n+}\n+  [(set_attr \"type\" \"compare\")\n+   (set_attr \"dot\" \"yes\")\n+   (set_attr \"length\" \"8,12\")])\n \n-(define_insn \"*anddi3_internal3_mc\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x,x,x,x,x,?y,?y,?y,??y,??y,?y\")\n-\t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r,r,r,r,r\")\n-\t\t\t    (match_operand:DI 2 \"and64_2_operand\" \"r,S,T,K,J,t,r,S,T,K,J,t\"))\n+(define_insn_and_split \"*anddi3_2rld_dot2\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n+\t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\")\n+\t\t\t    (match_operand:DI 2 \"and_2rld_operand\" \"n,n\"))\n \t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r,r,r,r,r,r,r,r,r,r\")\n-\t(and:DI (match_dup 1) (match_dup 2)))\n-   (clobber (match_scratch:CC 4 \"=X,X,X,X,X,X,X,X,X,x,x,X\"))]\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(and:DI (match_dup 1)\n+\t\t(match_dup 2)))]\n   \"TARGET_64BIT && rs6000_gen_cell_microcode\"\n   \"@\n-   and. %0,%1,%2\n-   rldic%B2. %0,%1,0,%S2\n-   rlwinm. %0,%1,0,%m2,%M2\n-   andi. %0,%1,%b2\n-   andis. %0,%1,%u2\n-   #\n-   #\n-   #\n-   #\n-   #\n    #\n    #\"\n-  [(set_attr \"type\" \"logical,shift,shift,logical,\\\n-\t\t     logical,compare,compare,compare,compare,compare,\\\n-\t\t     compare,compare\")\n-   (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"4,4,4,4,4,8,8,8,8,8,8,12\")])\n-\n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_micro_cr0_operand\" \"\")\n-\t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:DI 2 \"and64_2_operand\" \"\"))\n-\t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(and:DI (match_dup 1) (match_dup 2)))\n-   (clobber (match_scratch:CC 4 \"\"))]\n-  \"TARGET_64BIT && reload_completed\"\n-  [(parallel [(set (match_dup 0)\n-\t\t    (and:DI (match_dup 1) (match_dup 2)))\n-\t       (clobber (match_dup 4))])\n-   (set (match_dup 3)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"\")\n-        (compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-                            (match_operand:DI 2 \"mask64_2_operand\" \"\"))\n-                    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(and:DI (match_dup 1) (match_dup 2)))\n-   (clobber (match_scratch:CC 4 \"\"))]\n-  \"TARGET_64BIT && reload_completed\n-    && (fixed_regs[CR0_REGNO] || !logical_operand (operands[2], DImode))\n-    && !mask_operand (operands[2], DImode)\n-    && !mask64_operand (operands[2], DImode)\"\n+  \"&& reload_completed\"\n   [(set (match_dup 0)\n \t(and:DI (rotate:DI (match_dup 1)\n-\t\t\t   (match_dup 5))\n-\t\t(match_dup 6)))\n+\t\t\t   (match_dup 4))\n+\t\t(match_dup 5)))\n    (parallel [(set (match_dup 3)\n \t\t   (compare:CC (and:DI (rotate:DI (match_dup 0)\n-\t\t\t\t\t\t  (match_dup 7))\n-\t\t\t\t       (match_dup 8))\n+\t\t\t\t\t\t  (match_dup 6))\n+\t\t\t\t       (match_dup 7))\n \t\t\t       (const_int 0)))\n \t      (set (match_dup 0)\n \t\t   (and:DI (rotate:DI (match_dup 0)\n-\t\t\t\t      (match_dup 7))\n-\t\t\t   (match_dup 8)))])]\n-  \"\n+\t\t\t\t      (match_dup 6))\n+\t\t\t   (match_dup 7)))])]\n {\n-  build_mask64_2_operands (operands[2], &operands[5]);\n-}\")\n+  build_mask64_2_operands (operands[2], &operands[4]);\n+}\n+  [(set_attr \"type\" \"compare\")\n+   (set_attr \"dot\" \"yes\")\n+   (set_attr \"length\" \"8,12\")])\n \f\n ;; 128-bit logical operations expanders\n \n (define_expand \"and<mode>3\"\n-  [(parallel [(set (match_operand:BOOL_128 0 \"vlogical_operand\" \"\")\n-\t\t   (and:BOOL_128\n-\t\t    (match_operand:BOOL_128 1 \"vlogical_operand\" \"\")\n-\t\t    (match_operand:BOOL_128 2 \"vlogical_operand\" \"\")))\n-\t      (clobber (match_scratch:CC 3 \"\"))])]\n+  [(set (match_operand:BOOL_128 0 \"vlogical_operand\" \"\")\n+\t(and:BOOL_128 (match_operand:BOOL_128 1 \"vlogical_operand\" \"\")\n+\t\t      (match_operand:BOOL_128 2 \"vlogical_operand\" \"\")))]\n   \"\"\n   \"\")\n \n@@ -7905,8 +7781,7 @@\n   [(set (match_operand:BOOL_128 0 \"vlogical_operand\" \"=<BOOL_REGS_OUTPUT>\")\n         (and:BOOL_128\n \t (match_operand:BOOL_128 1 \"vlogical_operand\" \"%<BOOL_REGS_OP1>\")\n-\t (match_operand:BOOL_128 2 \"vlogical_operand\" \"<BOOL_REGS_OP2>\")))\n-   (clobber (match_scratch:CC 3 \"<BOOL_REGS_AND_CR0>\"))]\n+\t (match_operand:BOOL_128 2 \"vlogical_operand\" \"<BOOL_REGS_OP2>\")))]\n   \"\"\n {\n   if (TARGET_VSX && vsx_register_operand (operands[0], <MODE>mode))\n@@ -7920,7 +7795,7 @@\n   \"reload_completed && int_reg_operand (operands[0], <MODE>mode)\"\n   [(const_int 0)]\n {\n-  rs6000_split_logical (operands, AND, false, false, false, operands[3]);\n+  rs6000_split_logical (operands, AND, false, false, false);\n   DONE;\n }\n   [(set (attr \"type\")\n@@ -7956,8 +7831,7 @@\n   \"reload_completed && int_reg_operand (operands[0], <MODE>mode)\"\n   [(const_int 0)]\n {\n-  rs6000_split_logical (operands, GET_CODE (operands[3]), false, false, false,\n-\t\t\tNULL_RTX);\n+  rs6000_split_logical (operands, GET_CODE (operands[3]), false, false, false);\n   DONE;\n }\n   [(set (attr \"type\")\n@@ -7995,8 +7869,7 @@\n    && reload_completed && int_reg_operand (operands[0], <MODE>mode)\"\n   [(const_int 0)]\n {\n-  rs6000_split_logical (operands, GET_CODE (operands[3]), false, true, false,\n-\t\t\tNULL_RTX);\n+  rs6000_split_logical (operands, GET_CODE (operands[3]), false, true, false);\n   DONE;\n }\n   [(set (attr \"type\")\n@@ -8024,8 +7897,7 @@\n   \"reload_completed && !TARGET_P8_VECTOR && (GET_CODE (operands[3]) != AND)\"\n   [(const_int 0)]\n {\n-  rs6000_split_logical (operands, GET_CODE (operands[3]), false, true, false,\n-\t\t\tNULL_RTX);\n+  rs6000_split_logical (operands, GET_CODE (operands[3]), false, true, false);\n   DONE;\n }\n   [(set_attr \"type\" \"integer\")\n@@ -8057,8 +7929,7 @@\n    && reload_completed && int_reg_operand (operands[0], <MODE>mode)\"\n   [(const_int 0)]\n {\n-  rs6000_split_logical (operands, GET_CODE (operands[3]), false, true, true,\n-\t\t\tNULL_RTX);\n+  rs6000_split_logical (operands, GET_CODE (operands[3]), false, true, true);\n   DONE;\n }\n   [(set (attr \"type\")\n@@ -8087,8 +7958,7 @@\n   \"reload_completed && !TARGET_P8_VECTOR && (GET_CODE (operands[3]) != AND)\"\n   [(const_int 0)]\n {\n-  rs6000_split_logical (operands, GET_CODE (operands[3]), false, true, true,\n-\t\t\tNULL_RTX);\n+  rs6000_split_logical (operands, GET_CODE (operands[3]), false, true, true);\n   DONE;\n }\n   [(set_attr \"type\" \"integer\")\n@@ -8117,7 +7987,7 @@\n    && int_reg_operand (operands[0], <MODE>mode)\"\n   [(const_int 0)]\n {\n-  rs6000_split_logical (operands, XOR, true, false, false, NULL_RTX);\n+  rs6000_split_logical (operands, XOR, true, false, false);\n   DONE;\n }\n   [(set (attr \"type\")\n@@ -8145,7 +8015,7 @@\n   \"reload_completed && !TARGET_P8_VECTOR\"\n   [(const_int 0)]\n {\n-  rs6000_split_logical (operands, XOR, true, false, false, NULL_RTX);\n+  rs6000_split_logical (operands, XOR, true, false, false);\n   DONE;\n }\n   [(set_attr \"type\" \"integer\")\n@@ -8173,7 +8043,7 @@\n   \"reload_completed && int_reg_operand (operands[0], <MODE>mode)\"\n   [(const_int 0)]\n {\n-  rs6000_split_logical (operands, NOT, false, false, false, NULL_RTX);\n+  rs6000_split_logical (operands, NOT, false, false, false);\n   DONE;\n }\n   [(set (attr \"type\")"}, {"sha": "bfae244b497c22981cd13f31a0cf03d05504ac57", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c3a8bb733c1ecee2f5fa97d8b16331c30b37de/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c3a8bb733c1ecee2f5fa97d8b16331c30b37de/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=44c3a8bb733c1ecee2f5fa97d8b16331c30b37de", "patch": "@@ -224,25 +224,9 @@\n   [(set (match_dup 0)\n \t(plus:P (match_dup 1)\n \t\t(match_dup 2)))\n-   (parallel [(set (match_dup 0)\n-\t\t   (and:P (match_dup 0)\n-\t\t\t  (const_int -16)))\n-\t      (clobber:CC (scratch:CC))])])\n-\n-;; The normal ANDSI3/ANDDI3 won't match if reload decides to move an AND -16\n-;; address to a register because there is no clobber of a (scratch), so we add\n-;; it here.\n-(define_insn_and_split \"*vec_reload_and_reg_<mptrsize>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n-\t(and:P (match_operand:P 1 \"gpc_reg_operand\" \"r\")\n-\t       (const_int -16)))]\n-  \"(TARGET_ALTIVEC || TARGET_VSX) && (reload_in_progress || reload_completed)\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (and:P (match_dup 1)\n-\t\t\t  (const_int -16)))\n-\t      (clobber:CC (scratch:CC))])])\n+   (set (match_dup 0)\n+\t(and:P (match_dup 0)\n+\t       (const_int -16)))])\n \f\n ;; Generic floating point vector arithmetic support\n (define_expand \"add<mode>3\""}]}