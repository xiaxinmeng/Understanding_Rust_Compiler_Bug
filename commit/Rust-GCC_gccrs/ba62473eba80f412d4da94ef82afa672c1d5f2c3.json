{"sha": "ba62473eba80f412d4da94ef82afa672c1d5f2c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE2MjQ3M2ViYTgwZjQxMmQ0ZGE5NGVmODJhZmE2NzJjMWQ1ZjJjMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2000-07-21T01:01:00Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-07-21T01:01:00Z"}, "message": "atomicity.h (__exchange_and_add): Use extended word instructions to match 64bit _Atomic_word.\n\n\n2000-07-20  Jakub Jelinek  <jakub@redhat.com>\n\n        * config/cpu/sparc/sparc64/bits/atomicity.h (__exchange_and_add):\n        Use extended word instructions to match 64bit _Atomic_word.\n        (__atomic_add): Likewise.\n        * math/clog10l.c (clog10l): Use M_PIl if defined.\n        * math/c_logl.c (c_logl): Likewise.\n        * math/signbitl.c (__signbitl): Adapt for IEEE quad long doubles.\n        * math/mathconf.h (ieee_quad_double_shape_type): New type.\n        (GET_LDOUBLE_MSW64): New define.\n\nFrom-SVN: r35166", "tree": {"sha": "3662d0e2d08da38c706006cfdb12c6c9cc79094c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3662d0e2d08da38c706006cfdb12c6c9cc79094c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba62473eba80f412d4da94ef82afa672c1d5f2c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba62473eba80f412d4da94ef82afa672c1d5f2c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba62473eba80f412d4da94ef82afa672c1d5f2c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba62473eba80f412d4da94ef82afa672c1d5f2c3/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "538befca2c8bb81a347542366d7e99a0e7dcdff0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/538befca2c8bb81a347542366d7e99a0e7dcdff0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/538befca2c8bb81a347542366d7e99a0e7dcdff0"}], "stats": {"total": 72, "additions": 66, "deletions": 6}, "files": [{"sha": "f32201a7a07c4643d4ba6737a79536ec87449311", "filename": "libstdc++-v3/config/cpu/sparc/sparc64/bits/atomicity.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba62473eba80f412d4da94ef82afa672c1d5f2c3/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fsparc%2Fsparc64%2Fbits%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba62473eba80f412d4da94ef82afa672c1d5f2c3/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fsparc%2Fsparc64%2Fbits%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fsparc%2Fsparc64%2Fbits%2Fatomicity.h?ref=ba62473eba80f412d4da94ef82afa672c1d5f2c3", "patch": "@@ -28,9 +28,9 @@ __exchange_and_add (volatile _Atomic_word *__mem, int __val)\n {\n   _Atomic_word __tmp1, __tmp2;\n \n-  __asm__ __volatile__(\"1:\tlduw\t[%2], %0\\n\\t\"\n+  __asm__ __volatile__(\"1:\tldx\t[%2], %0\\n\\t\"\n \t\t       \"\tadd\t%0, %3, %1\\n\\t\"\n-\t\t       \"\tcas\t[%2], %0, %1\\n\\t\"\n+\t\t       \"\tcasx\t[%2], %0, %1\\n\\t\"\n \t\t       \"\tsub\t%0, %1, %0\\n\\t\"\n \t\t       \"\tbrnz,pn\t%0, 1b\\n\\t\"\n \t\t       \"\t nop\"\n@@ -46,9 +46,9 @@ __atomic_add (volatile _Atomic_word* __mem, int __val)\n {\n   _Atomic_word __tmp1, __tmp2;\n \n-  __asm__ __volatile__(\"1:\tlduw\t[%2], %0\\n\\t\"\n+  __asm__ __volatile__(\"1:\tldx\t[%2], %0\\n\\t\"\n \t\t       \"\tadd\t%0, %3, %1\\n\\t\"\n-\t\t       \"\tcas\t[%2], %0, %1\\n\\t\"\n+\t\t       \"\tcasx\t[%2], %0, %1\\n\\t\"\n \t\t       \"\tsub\t%0, %1, %0\\n\\t\"\n \t\t       \"\tbrnz,pn\t%0, 1b\\n\\t\"\n \t\t       \"\t nop\""}, {"sha": "d4075f75992b9a43199521c097aaf3edcb4e360c", "filename": "libstdc++-v3/math/c_logl.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba62473eba80f412d4da94ef82afa672c1d5f2c3/libstdc%2B%2B-v3%2Fmath%2Fc_logl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba62473eba80f412d4da94ef82afa672c1d5f2c3/libstdc%2B%2B-v3%2Fmath%2Fc_logl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fc_logl.c?ref=ba62473eba80f412d4da94ef82afa672c1d5f2c3", "patch": "@@ -28,8 +28,14 @@\n    the GNU General Public License.  */\n \n \n+#ifndef _GNU_SOURCE\n+#define _GNU_SOURCE\n+#endif\n #include <math.h>\n #include \"mathconf.h\"\n+#ifndef M_PIl\n+#define M_PIl M_PI\n+#endif\n \n /* Thanks to SGI we have to trick here.  At least Irix 6.2 provides hypotl,\n    but it has a wrong prototype.  Grrr.  */\n@@ -44,7 +50,7 @@ c_logl (__complex__ long double x)\n   if (x == 0.0)\n     {\n       /* Real and imaginary part are 0.0.  */\n-      __imag__ result = signbit (__real__ x) ? M_PI : 0.0;\n+      __imag__ result = signbit (__real__ x) ? M_PIl : 0.0;\n       __imag__ result = copysignl (__imag__ result, __imag__ x);\n       /* Yes, the following line raises an exception.  */\n       __real__ result = -1.0 / fabsl (__real__ x);"}, {"sha": "9cec8f88ffe8997d806a426bd131fab8a4b15f9e", "filename": "libstdc++-v3/math/clog10l.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba62473eba80f412d4da94ef82afa672c1d5f2c3/libstdc%2B%2B-v3%2Fmath%2Fclog10l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba62473eba80f412d4da94ef82afa672c1d5f2c3/libstdc%2B%2B-v3%2Fmath%2Fclog10l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fclog10l.c?ref=ba62473eba80f412d4da94ef82afa672c1d5f2c3", "patch": "@@ -27,8 +27,14 @@\n    invalidate any other reasons why the executable file might be covered by\n    the GNU General Public License.  */\n \n+#ifndef _GNU_SOURCE\n+#define _GNU_SOURCE\n+#endif\n #include <math.h>\n #include \"mathconf.h\"\n+#ifndef M_PIl\n+#define M_PIl M_PI\n+#endif\n \n /* Thanks to SGI we have to trick here.  At least Irix 6.2 provides hypotl,\n    but it has a wrong prototype.  Grrr.  */\n@@ -43,7 +49,7 @@ clog10l (__complex__ long double x)\n   if (x == 0.0)\n     {\n       /* Real and imaginary part are 0.0.  */\n-      __imag__ result = signbit (__real__ x) ? M_PI : 0.0;\n+      __imag__ result = signbit (__real__ x) ? M_PIl : 0.0;\n       __imag__ result = copysignl (__imag__ result, __imag__ x);\n       /* Yes, the following line raises an exception.  */\n       __real__ result = -1.0 / fabsl (__real__ x);"}, {"sha": "3f4503cc16217412e8340cd6f65d44f19d835241", "filename": "libstdc++-v3/math/mathconf.h", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba62473eba80f412d4da94ef82afa672c1d5f2c3/libstdc%2B%2B-v3%2Fmath%2Fmathconf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba62473eba80f412d4da94ef82afa672c1d5f2c3/libstdc%2B%2B-v3%2Fmath%2Fmathconf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fmathconf.h?ref=ba62473eba80f412d4da94ef82afa672c1d5f2c3", "patch": "@@ -69,6 +69,8 @@\n \n typedef unsigned int U_int32_t __attribute ((mode (SI)));\n typedef int Int32_t __attribute ((mode (SI)));\n+typedef unsigned int U_int64_t __attribute ((mode (DI)));\n+typedef int Uint64_t __attribute ((mode (DI)));\n \n #ifdef _GLIBCPP_HAVE_NAN_H\n # include <nan.h>\n@@ -326,6 +328,44 @@ do {                                                            \\\n   (exp) = ge_u.parts.sign_exponent;                             \\\n } while (0)\n \n+#if BYTE_ORDER == BIG_ENDIAN\n+typedef union\n+{\n+  long double value;\n+  struct\n+  {\n+    U_int64_t msw;\n+    U_int64_t lsw;\n+  } parts64;\n+  struct\n+  {\n+    U_int32_t w0, w1, w2, w3;\n+  } parts32;\n+} ieee_quad_double_shape_type;\n+#endif\n+#if BYTE_ORDER == LITTLE_ENDIAN\n+typedef union\n+{\n+  long double value;\n+  struct\n+  {\n+    U_int64_t lsw;\n+    U_int64_t msw;\n+  } parts64;\n+  struct\n+  {\n+    U_int32_t w3, w2, w1, w0;\n+  } parts32;\n+} ieee_quad_double_shape_type;\n+#endif\n+/* Get most significant 64 bit int from a quad long double.  */\n+#define GET_LDOUBLE_MSW64(msw,d)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  ieee_quad_double_shape_type qw_u;\t\t\t\t\\\n+  qw_u.value = (d);\t\t\t\t\t\t\\\n+  (ix0) = qw_u.parts64.msw;\t\t\t\t\t\\\n+} while (0)\n+        \n \n /* Replacement for non-existing float functions.  */\n #if !defined(_GLIBCPP_HAVE_FABSF) && !defined(_GLIBCPP_HAVE___BUILTIN_FABSF)"}, {"sha": "3516f07339a025af0501f7e3ec84afbe8eb808c2", "filename": "libstdc++-v3/math/signbitl.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba62473eba80f412d4da94ef82afa672c1d5f2c3/libstdc%2B%2B-v3%2Fmath%2Fsignbitl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba62473eba80f412d4da94ef82afa672c1d5f2c3/libstdc%2B%2B-v3%2Fmath%2Fsignbitl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fsignbitl.c?ref=ba62473eba80f412d4da94ef82afa672c1d5f2c3", "patch": "@@ -27,14 +27,22 @@\n    invalidate any other reasons why the executable file might be covered by\n    the GNU General Public License.  */\n \n+#include <float.h>\n #include <math.h>\n #include \"mathconf.h\"\n \n int\n __signbitl (long double x)\n {\n+#if LDBL_MANT_DIG == 113\n+  Int64_t msw;\n+\n+  GET_LDOUBLE_MSW64 (msw, x);\n+  return msw < 0;\n+#else\n   Int32_t e;\n \n   GET_LDOUBLE_EXP (e, x);\n   return e & 0x8000;\n+#endif\n }"}]}