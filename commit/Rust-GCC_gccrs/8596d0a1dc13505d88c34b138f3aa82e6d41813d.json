{"sha": "8596d0a1dc13505d88c34b138f3aa82e6d41813d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODU5NmQwYTFkYzEzNTA1ZDg4YzM0YjEzOGYzYWE4MmU2ZDQxODEzZA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-01-05T17:01:43Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-01-05T17:01:43Z"}, "message": "mn10300.c: Fix comment formatting.\n\n\t* config/mn10300/mn10300.c: Fix comment formatting.\n\t* config/mn10300/mn10300.h: Likewise.\n\nFrom-SVN: r75433", "tree": {"sha": "c5985067f9ac0ea99a51fb0b4912ffb4122e6cc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5985067f9ac0ea99a51fb0b4912ffb4122e6cc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8596d0a1dc13505d88c34b138f3aa82e6d41813d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8596d0a1dc13505d88c34b138f3aa82e6d41813d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8596d0a1dc13505d88c34b138f3aa82e6d41813d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8596d0a1dc13505d88c34b138f3aa82e6d41813d/comments", "author": null, "committer": null, "parents": [{"sha": "91b1417d44eb5b73dcb10ce26ecc779b24e8d00d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91b1417d44eb5b73dcb10ce26ecc779b24e8d00d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91b1417d44eb5b73dcb10ce26ecc779b24e8d00d"}], "stats": {"total": 53, "additions": 29, "deletions": 24}, "files": [{"sha": "04e537bf852debb9e1ab7af290d00b2142b39e77", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8596d0a1dc13505d88c34b138f3aa82e6d41813d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8596d0a1dc13505d88c34b138f3aa82e6d41813d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8596d0a1dc13505d88c34b138f3aa82e6d41813d", "patch": "@@ -1,3 +1,8 @@\n+2004-01-05  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/mn10300/mn10300.c: Fix comment formatting.\n+\t* config/mn10300/mn10300.h: Likewise.\n+\n 2004-01-05  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* tree.h: Update documentation on nothrow_flag."}, {"sha": "74aab427d7143ebbdfc16c1d04decbed4016802c", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8596d0a1dc13505d88c34b138f3aa82e6d41813d/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8596d0a1dc13505d88c34b138f3aa82e6d41813d/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=8596d0a1dc13505d88c34b138f3aa82e6d41813d", "patch": "@@ -490,7 +490,7 @@ fp_regs_to_save (void)\n    Register K is saved if bit K of MASK is set.  The data and address\n    registers can be stored individually, but the extended registers cannot.\n    We assume that the mask alread takes that into account.  For instance,\n-   bits 14 to 17 must have the same value. */\n+   bits 14 to 17 must have the same value.  */\n \n void\n mn10300_print_reg_list (FILE *file, int mask)\n@@ -548,7 +548,7 @@ can_use_return_insn (void)\n \n /* Returns the set of live, callee-saved registers as a bitmask.  The\n    callee-saved extended registers cannot be stored individually, so\n-   all of them will be included in the mask if any one of them is used. */\n+   all of them will be included in the mask if any one of them is used.  */\n \n int\n mn10300_get_live_callee_saved_regs (void)\n@@ -595,25 +595,25 @@ mn10300_gen_multiple_store (int mask)\n       rtx par;\n       int pari;\n \n-      /* Count how many registers need to be saved. */\n+      /* Count how many registers need to be saved.  */\n       count = 0;\n       for (i = 0; i <= LAST_EXTENDED_REGNUM; i++)\n \tif ((mask & (1 << i)) != 0)\n \t  count += 1;\n \n       /* We need one PARALLEL element to update the stack pointer and\n-\t an additional element for each register that is stored. */\n+\t an additional element for each register that is stored.  */\n       par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count + 1));\n \n-      /* Create the instruction that updates the stack pointer. */\n+      /* Create the instruction that updates the stack pointer.  */\n       XVECEXP (par, 0, 0)\n \t= gen_rtx_SET (SImode,\n \t\t       stack_pointer_rtx,\n \t\t       gen_rtx_PLUS (SImode,\n \t\t\t\t     stack_pointer_rtx,\n \t\t\t\t     GEN_INT (-count * 4)));\n \n-      /* Create each store. */\n+      /* Create each store.  */\n       pari = 1;\n       for (i = LAST_EXTENDED_REGNUM; i >= 0; i--)\n \tif ((mask & (1 << i)) != 0)\n@@ -642,7 +642,7 @@ expand_prologue (void)\n   size = get_frame_size () + current_function_outgoing_args_size;\n   size += (current_function_outgoing_args_size ? 4 : 0);\n \n-  /* If we use any of the callee-saved registers, save them now. */\n+  /* If we use any of the callee-saved registers, save them now.  */\n   mn10300_gen_multiple_store (mn10300_get_live_callee_saved_regs ());\n \n   if (TARGET_AM33_2 && fp_regs_to_save ())\n@@ -768,7 +768,7 @@ expand_prologue (void)\n \t}\n \n       /* Consider alternative save_a0_no_merge if the user hasn't\n-\t changed the calling conventions of a0. */\n+\t changed the calling conventions of a0.  */\n       if (call_used_regs[FIRST_ADDRESS_REGNUM]\n \t  && ! fixed_regs[FIRST_ADDRESS_REGNUM])\n \t{\n@@ -816,10 +816,10 @@ expand_prologue (void)\n \t\t\t\t stack_pointer_rtx,\n \t\t\t\t GEN_INT (-(size + 4 * num_regs_to_save))));\n \t  /* We'll have to adjust FP register saves according to the\n-\t     frame size. */\n+\t     frame size.  */\n \t  xsize = size;\n \t  /* Since we've already created the stack frame, don't do it\n-\t     again at the end of the function. */\n+\t     again at the end of the function.  */\n \t  size = 0;\n \t  break;\n \n@@ -969,7 +969,7 @@ expand_epilogue (void)\n \t  /* Insn: fmov (##,sp),fs#, for each fs# to be restored.  */\n \t  this_strategy_size += SIZE_FMOV_SP (0, num_regs_to_save);\n \t  /* We're going to use ret to release the FP registers\n-\t\t save area, so, no savings. */\n+\t\t save area, so, no savings.  */\n \n \t  if (this_strategy_size < strategy_size)\n \t    {\n@@ -992,7 +992,7 @@ expand_epilogue (void)\n \t\t\t\t\t\t  - 4 * num_regs_to_save,\n \t\t\t\t\t\t  num_regs_to_save);\n \t      /* We're going to use ret to release the FP registers\n-\t\t save area, so, no savings. */\n+\t\t save area, so, no savings.  */\n \n \t      if (this_strategy_size < strategy_size)\n \t\t{\n@@ -1080,7 +1080,7 @@ expand_epilogue (void)\n \t    else if (size)\n \t      {\n \t\t/* If we aren't using a post-increment register, use an\n-\t\t   SP offset. */\n+\t\t   SP offset.  */\n \t\taddr = gen_rtx_PLUS (SImode,\n \t\t\t\t     stack_pointer_rtx,\n \t\t\t\t     GEN_INT (size));\n@@ -1233,7 +1233,7 @@ store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   /* Check that A is the stack pointer and B is the expected stack size.\n      For OP to match, each subsequent instruction should push a word onto\n      the stack.  We therefore expect the first instruction to create\n-     COUNT-1 stack slots. */\n+     COUNT-1 stack slots.  */\n   elt = SET_SRC (elt);\n   if (GET_CODE (XEXP (elt, 0)) != REG\n       || REGNO (XEXP (elt, 0)) != STACK_POINTER_REGNUM\n@@ -1247,12 +1247,12 @@ store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n      store a lower-numbered register to the slot below.\n \n      LAST keeps track of the smallest-numbered register stored so far.\n-     MASK is the set of stored registers. */\n+     MASK is the set of stored registers.  */\n   last = LAST_EXTENDED_REGNUM + 1;\n   mask = 0;\n   for (i = 1; i < count; i++)\n     {\n-      /* Check that element i is a (set (mem M) R) and that R is valid. */\n+      /* Check that element i is a (set (mem M) R) and that R is valid.  */\n       elt = XVECEXP (op, 0, i);\n       if (GET_CODE (elt) != SET\n \t  || GET_CODE (SET_DEST (elt)) != MEM\n@@ -1261,7 +1261,7 @@ store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n \treturn 0;\n \n       /* R was OK, so provisionally add it to MASK.  We return 0 in any\n-\t case if the rest of the instruction has a flaw. */\n+\t case if the rest of the instruction has a flaw.  */\n       last = REGNO (SET_SRC (elt));\n       mask |= (1 << last);\n \n@@ -1275,7 +1275,7 @@ store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n \treturn 0;\n     }\n \n-  /* All or none of the callee-saved extended registers must be in the set. */\n+  /* All or none of the callee-saved extended registers must be in the set.  */\n   if ((mask & 0x3c000) != 0\n       && (mask & 0x3c000) != 0x3c000)\n     return 0;\n@@ -1601,7 +1601,7 @@ output_tst (rtx operand, rtx insn)\n \t  continue;\n \t}\n \n-      /* It must be an insn, see if it is a simple set. */\n+      /* It must be an insn, see if it is a simple set.  */\n       set = single_set (temp);\n       if (!set)\n \t{\n@@ -1786,7 +1786,7 @@ legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n }\n \n /* Convert a non-PIC address in `orig' to a PIC address using @GOT or\n-   @GOTOFF in `reg'. */\n+   @GOTOFF in `reg'.  */\n rtx\n legitimize_pic_address (rtx orig, rtx reg)\n {"}, {"sha": "9aa221a68067e25483082bbc77e0e5bb2f76e8c8", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8596d0a1dc13505d88c34b138f3aa82e6d41813d/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8596d0a1dc13505d88c34b138f3aa82e6d41813d/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=8596d0a1dc13505d88c34b138f3aa82e6d41813d", "patch": "@@ -117,7 +117,7 @@ extern GTY(()) int mn10300_unspec_int_label_counter;\n    would improve performance.  */\n #define FUNCTION_BOUNDARY 8\n \n-/* No data type wants to be aligned rounder than this.   */\n+/* No data type wants to be aligned rounder than this.  */\n #define BIGGEST_ALIGNMENT\t32\n \n /* Alignment of field after `int : 0' in a structure.  */\n@@ -281,7 +281,7 @@ enum reg_class {\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n-/* Give names of register classes as strings for dump file.   */\n+/* Give names of register classes as strings for dump file.  */\n \n #define REG_CLASS_NAMES \\\n { \"NO_REGS\", \"DATA_REGS\", \"ADDRESS_REGS\", \\\n@@ -605,7 +605,7 @@ struct cum_arg {int nbytes; };\n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.   */\n+   otherwise, FUNC is 0.  */\n \n #define FUNCTION_VALUE(VALTYPE, FUNC) \\\n   gen_rtx_REG (TYPE_MODE (VALTYPE), POINTER_TYPE_P (VALTYPE) \\\n@@ -823,7 +823,7 @@ struct cum_arg {int nbytes; };\n    GO_IF_LEGITIMATE_ADDRESS.\n \n    It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.   */\n+   opportunities to optimize the output.  */\n \n #define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)  \\\n { rtx orig_x = (X);\t\t\t\t\\"}]}