{"sha": "727d709b73dbf2bcb675e33d8fab34e2b2218133", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI3ZDcwOWI3M2RiZjJiY2I2NzVlMzNkOGZhYjM0ZTJiMjIxODEzMw==", "commit": {"author": {"name": "Pat Haugen", "email": "pthaugen@us.ibm.com", "date": "2004-07-29T14:49:22Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2004-07-29T14:49:22Z"}, "message": "ra.h (single_reg_in_regclass): Declare.\n\n2004-07-29  Pat Haugen  <pthaugen@us.ibm.com>\n\n        * ra.h (single_reg_in_regclass): Declare.\n        * ra.c (single_reg_in_regclass): Define.\n        (first_hard_reg): New.\n        (init_ra): Initialize single_reg_in_regclass.\n        * ra-colorize.c (ok_class): New.\n        (coalesce, aggressive_coalesce, extended_coalesce_2): Use it.\n\nFrom-SVN: r85300", "tree": {"sha": "e47884bc158f810bb28401260833e164be0f927e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e47884bc158f810bb28401260833e164be0f927e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/727d709b73dbf2bcb675e33d8fab34e2b2218133", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/727d709b73dbf2bcb675e33d8fab34e2b2218133", "html_url": "https://github.com/Rust-GCC/gccrs/commit/727d709b73dbf2bcb675e33d8fab34e2b2218133", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/727d709b73dbf2bcb675e33d8fab34e2b2218133/comments", "author": null, "committer": null, "parents": [{"sha": "a639e504d8f710bc95d6f05cf2054636c9789c42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a639e504d8f710bc95d6f05cf2054636c9789c42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a639e504d8f710bc95d6f05cf2054636c9789c42"}], "stats": {"total": 72, "additions": 70, "deletions": 2}, "files": [{"sha": "896e6b0785078108b8677e0327d6c4afa8c5be18", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/727d709b73dbf2bcb675e33d8fab34e2b2218133/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/727d709b73dbf2bcb675e33d8fab34e2b2218133/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=727d709b73dbf2bcb675e33d8fab34e2b2218133", "patch": "@@ -1,3 +1,12 @@\n+2004-07-29  Pat Haugen  <pthaugen@us.ibm.com>\n+\n+\t* ra.h (single_reg_in_regclass): Declare.\n+\t* ra.c (single_reg_in_regclass): Define.\n+\t(first_hard_reg): New.\n+\t(init_ra): Initialize single_reg_in_regclass.\n+\t* ra-colorize.c (ok_class): New.\n+\t(coalesce, aggressive_coalesce, extended_coalesce_2): Use it.\n+\n 2004-07-29  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* gcov-io.h: Allow zero tag as EOF indicator."}, {"sha": "e3118a0cdac3a36d2f2810e8c713a0c637e51e73", "filename": "gcc/ra-colorize.c", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/727d709b73dbf2bcb675e33d8fab34e2b2218133/gcc%2Fra-colorize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/727d709b73dbf2bcb675e33d8fab34e2b2218133/gcc%2Fra-colorize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-colorize.c?ref=727d709b73dbf2bcb675e33d8fab34e2b2218133", "patch": "@@ -92,6 +92,7 @@ static void add_web_pair_cost (struct web *, struct web *,\n \t\t               unsigned HOST_WIDE_INT, unsigned int);\n static int comp_web_pairs (const void *, const void *);\n static void sort_and_combine_web_pairs (int);\n+static int ok_class (struct web *, struct web *);\n static void aggressive_coalesce (void);\n static void extended_coalesce_2 (void);\n static void check_uncoalesced_moves (void);\n@@ -841,7 +842,8 @@ coalesce (void)\n     }\n   else if (target->type == PRECOLORED\n \t   || TEST_BIT (sup_igraph, source->id * num_webs + target->id)\n-\t   || TEST_BIT (sup_igraph, target->id * num_webs + source->id))\n+\t   || TEST_BIT (sup_igraph, target->id * num_webs + source->id)\n+\t   || !ok_class (target, source))\n     {\n       remove_move (source, m);\n       remove_move (target, m);\n@@ -2464,6 +2466,39 @@ sort_and_combine_web_pairs (int for_move)\n   free (sorted);\n }\n \n+/* Returns nonzero if source/target reg classes are ok for coalesce.  */\n+\n+static int\n+ok_class (struct web *target, struct web *source)\n+{\n+  /* Don't coalesce if preferred classes are different and at least one\n+     of them has a size of 1. This was preventing things such as the\n+     branch on count transformation (i.e. DoLoop) since the target, which\n+     prefers the CTR, was being coalesced with a source which preferred\n+     GENERAL_REGS. If only one web has a preferred class with 1 free reg\n+     then set it as the preferred color of the other web.   */\n+  enum reg_class t_class, s_class;\n+  t_class = reg_preferred_class (target->regno);\n+  s_class = reg_preferred_class (source->regno);\n+  if (t_class != s_class)\n+    {\n+      if (num_free_regs[t_class] == 1)\n+\t{\n+\t  if (num_free_regs[s_class] != 1)\n+\t    SET_HARD_REG_BIT (source->prefer_colors,\n+\t\t\t      single_reg_in_regclass[t_class]);\n+\t  return 0;\n+\t}\n+      else if (num_free_regs[s_class] == 1)\n+\t{\n+\t    SET_HARD_REG_BIT (target->prefer_colors,\n+\t\t\t      single_reg_in_regclass[s_class]);\n+\t  return 0;\n+\t}\n+    }\n+  return 1;\n+}\n+\n /* Greedily coalesce all moves possible.  Begin with the web pair\n    giving the most saving if coalesced.  */\n \n@@ -2487,7 +2522,8 @@ aggressive_coalesce (void)\n \tif (s != t\n \t    && t->type != PRECOLORED\n \t    && !TEST_BIT (sup_igraph, s->id * num_webs + t->id)\n-\t    && !TEST_BIT (sup_igraph, t->id * num_webs + s->id))\n+\t    && !TEST_BIT (sup_igraph, t->id * num_webs + s->id)\n+\t    && ok_class (t, s))\n \t  {\n \t    if ((s->type == PRECOLORED && ok (t, s))\n \t\t|| s->type != PRECOLORED)\n@@ -2557,6 +2593,7 @@ extended_coalesce_2 (void)\n \t\t\t\t    dest->id * num_webs + source->id)\n \t\t      && !TEST_BIT (sup_igraph,\n \t\t\t\t    source->id * num_webs + dest->id)\n+\t\t      && ok_class (dest, source)\n \t\t      && hard_regs_intersect_p (&source->usable_regs,\n \t\t\t\t\t\t&dest->usable_regs))\n \t\t    add_web_pair_cost (dest, source,"}, {"sha": "c1098e4c5fcb5a6a15c951e2a385b33f9928106d", "filename": "gcc/ra.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/727d709b73dbf2bcb675e33d8fab34e2b2218133/gcc%2Fra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/727d709b73dbf2bcb675e33d8fab34e2b2218133/gcc%2Fra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra.c?ref=727d709b73dbf2bcb675e33d8fab34e2b2218133", "patch": "@@ -84,6 +84,7 @@\n    * use the constraints from asms\n   */\n \n+static int first_hard_reg (HARD_REG_SET);\n static struct obstack ra_obstack;\n static void create_insn_info (struct df *);\n static void free_insn_info (void);\n@@ -147,6 +148,7 @@ int orig_max_uid;\n HARD_REG_SET never_use_colors;\n HARD_REG_SET usable_regs[N_REG_CLASSES];\n unsigned int num_free_regs[N_REG_CLASSES];\n+int single_reg_in_regclass[N_REG_CLASSES];\n HARD_REG_SET hardregs_for_mode[NUM_MACHINE_MODES];\n HARD_REG_SET invalid_mode_change_regs;\n unsigned char byte2bitcount[256];\n@@ -212,6 +214,19 @@ hard_regs_count (HARD_REG_SET rs)\n   return count;\n }\n \n+/* Returns the first hardreg in HARD_REG_SET RS. Assumes there is at\n+   least one reg in the set.  */\n+\n+static int\n+first_hard_reg (HARD_REG_SET rs)\n+{\n+  int c;\n+  for (c = 0; c < FIRST_PSEUDO_REGISTER && !TEST_HARD_REG_BIT (rs, c); c++)\n+  if (c == FIRST_PSEUDO_REGISTER)\n+    abort();\n+  return c;\n+}\n+\n /* Basically like emit_move_insn (i.e. validifies constants and such),\n    but also handle MODE_CC moves (but then the operands must already\n    be basically valid.  */\n@@ -515,6 +530,10 @@ init_ra (void)\n       size = hard_regs_count (rs);\n       num_free_regs[i] = size;\n       COPY_HARD_REG_SET (usable_regs[i], rs);\n+      if (size == 1)\n+\tsingle_reg_in_regclass[i] = first_hard_reg (rs);\n+      else\n+\tsingle_reg_in_regclass[i] = -1;\n     }\n \n   /* Setup hardregs_for_mode[]."}, {"sha": "9bcc6f54c6a47ad694899fc07abc1b5141b8fc3e", "filename": "gcc/ra.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/727d709b73dbf2bcb675e33d8fab34e2b2218133/gcc%2Fra.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/727d709b73dbf2bcb675e33d8fab34e2b2218133/gcc%2Fra.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra.h?ref=727d709b73dbf2bcb675e33d8fab34e2b2218133", "patch": "@@ -503,6 +503,9 @@ extern HARD_REG_SET never_use_colors;\n extern HARD_REG_SET usable_regs[N_REG_CLASSES];\n /* For each class C the count of hardregs in usable_regs[C].  */\n extern unsigned int num_free_regs[N_REG_CLASSES];\n+/* For each class C which has num_free_regs[C]==1, the color of the\n+   single register in that class, -1 otherwise.  */\n+extern int single_reg_in_regclass[N_REG_CLASSES];\n /* For each mode M the hardregs, which are MODE_OK for M, and have\n    enough space behind them to hold an M value.  Additionally\n    if reg R is OK for mode M, but it needs two hardregs, then R+1 will"}]}