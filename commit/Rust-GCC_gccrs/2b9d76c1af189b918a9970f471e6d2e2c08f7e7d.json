{"sha": "2b9d76c1af189b918a9970f471e6d2e2c08f7e7d", "node_id": "C_kwDOANBUbNoAKDJiOWQ3NmMxYWYxODliOTE4YTk5NzBmNDcxZTZkMmUyYzA4ZjdlN2Q", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-03-27T13:18:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-03-28T13:25:01Z"}, "message": "tree-optimization/107087 - missed CCP after forwprop\n\nWhen forwprop simplifies the CFG the 2nd order opportunities by\nexposed degenerate PHIs are not realized.  The following improves\nthis by properly tracking executable edges and thus handling this\nfor non-cyclic CFGs at least.\n\nThis avoids the bogus diagnostic reported for the testcase in this PR.\n\n\tPR tree-optimization/107087\n\t* tree-ssa-forwprop.cc (pass_forwprop::execute): Track\n\texecutable regions to avoid useless work and to better\n\tpropagate degenerate PHIs.\n\n\t* g++.dg/pr107087.C: New testcase.", "tree": {"sha": "5685f17e15f19ac89f91cd869b89755a267a9717", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5685f17e15f19ac89f91cd869b89755a267a9717"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b9d76c1af189b918a9970f471e6d2e2c08f7e7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b9d76c1af189b918a9970f471e6d2e2c08f7e7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b9d76c1af189b918a9970f471e6d2e2c08f7e7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b9d76c1af189b918a9970f471e6d2e2c08f7e7d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e70e36cbef4f01e7d32bafe17698c3bf3e4624b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e70e36cbef4f01e7d32bafe17698c3bf3e4624b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e70e36cbef4f01e7d32bafe17698c3bf3e4624b8"}], "stats": {"total": 83, "additions": 77, "deletions": 6}, "files": [{"sha": "3ca76b4153cd1bceeb43b0d7cc24b484ca99b57f", "filename": "gcc/testsuite/g++.dg/pr107087.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b9d76c1af189b918a9970f471e6d2e2c08f7e7d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr107087.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b9d76c1af189b918a9970f471e6d2e2c08f7e7d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr107087.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr107087.C?ref=2b9d76c1af189b918a9970f471e6d2e2c08f7e7d", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do compile }\n+// { dg-require-effective-target c++11 }\n+// { dg-options \"-O2\" }\n+\n+#include <vector>\n+\n+void test01()\n+{\n+  std::vector<int> v1, v2{5, 6};\n+  int n = 0;\n+  std::vector<int>::iterator it = v1.insert(v1.cbegin(), n);\n+  it = v1.insert(v1.cbegin(), 1);\n+  it = v1.insert(v1.cbegin(), {2, 3});\n+  it = v1.insert(v1.cbegin(), 1, 4);\n+  it = v1.insert(v1.cbegin(), v2.begin(), v2.end());\n+}"}, {"sha": "5eccc7a89b59eaa288199e5b5c1dff1bd64e0c5a", "filename": "gcc/tree-ssa-forwprop.cc", "status": "modified", "additions": 61, "deletions": 6, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b9d76c1af189b918a9970f471e6d2e2c08f7e7d/gcc%2Ftree-ssa-forwprop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b9d76c1af189b918a9970f471e6d2e2c08f7e7d/gcc%2Ftree-ssa-forwprop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.cc?ref=2b9d76c1af189b918a9970f471e6d2e2c08f7e7d", "patch": "@@ -3462,6 +3462,17 @@ pass_forwprop::execute (function *fun)\n   int *postorder = XNEWVEC (int, n_basic_blocks_for_fn (fun));\n   int postorder_num = pre_and_rev_post_order_compute_fn (fun, NULL,\n \t\t\t\t\t\t\t postorder, false);\n+  int *bb_to_rpo = XNEWVEC (int, last_basic_block_for_fn (fun));\n+  for (int i = 0; i < postorder_num; ++i)\n+    {\n+      bb_to_rpo[postorder[i]] = i;\n+      edge_iterator ei;\n+      edge e;\n+      FOR_EACH_EDGE (e, ei, BASIC_BLOCK_FOR_FN (fun, postorder[i])->succs)\n+\te->flags &= ~EDGE_EXECUTABLE;\n+    }\n+  single_succ_edge (BASIC_BLOCK_FOR_FN (fun, ENTRY_BLOCK))->flags\n+    |= EDGE_EXECUTABLE;\n   auto_vec<gimple *, 4> to_fixup;\n   auto_vec<gimple *, 32> to_remove;\n   to_purge = BITMAP_ALLOC (NULL);\n@@ -3470,6 +3481,30 @@ pass_forwprop::execute (function *fun)\n     {\n       gimple_stmt_iterator gsi;\n       basic_block bb = BASIC_BLOCK_FOR_FN (fun, postorder[i]);\n+      edge_iterator ei;\n+      edge e;\n+\n+      /* Skip processing not executable blocks.  We could improve\n+\t single_use tracking by at least unlinking uses from unreachable\n+\t blocks but since blocks with uses are not processed in a\n+\t meaningful order this is probably not worth it.  */\n+      bool any = false;\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\t{\n+\t  if ((e->flags & EDGE_EXECUTABLE)\n+\t      /* With dominators we could improve backedge handling\n+\t\t when e->src is dominated by bb.  But for irreducible\n+\t\t regions we have to take all backedges conservatively.\n+\t\t We can handle single-block cycles as we know the\n+\t\t dominator relationship here.  */\n+\t      || bb_to_rpo[e->src->index] > i)\n+\t    {\n+\t      any = true;\n+\t      break;\n+\t    }\n+\t}\n+      if (!any)\n+\tcontinue;\n \n       /* Record degenerate PHIs in the lattice.  */\n       for (gphi_iterator si = gsi_start_phis (bb); !gsi_end_p (si);\n@@ -3480,13 +3515,25 @@ pass_forwprop::execute (function *fun)\n \t  if (virtual_operand_p (res))\n \t    continue;\n \n-\t  use_operand_p use_p;\n-\t  ssa_op_iter it;\n \t  tree first = NULL_TREE;\n \t  bool all_same = true;\n-\t  FOR_EACH_PHI_ARG (use_p, phi, it, SSA_OP_USE)\n+\t  edge_iterator ei;\n+\t  edge e;\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    {\n-\t      tree use = USE_FROM_PTR (use_p);\n+\t      /* Ignore not executable forward edges.  */\n+\t      if (!(e->flags & EDGE_EXECUTABLE))\n+\t\t{\n+\t\t  if (bb_to_rpo[e->src->index] < i)\n+\t\t    continue;\n+\t\t  /* Avoid equivalences from backedges - while we might\n+\t\t     be able to make irreducible regions reducible and\n+\t\t     thus turning a back into a forward edge we do not\n+\t\t     want to deal with the intermediate SSA issues that\n+\t\t     exposes.  */\n+\t\t  all_same = false;\n+\t\t}\n+\t      tree use = PHI_ARG_DEF_FROM_EDGE (phi, e);\n \t      if (use == res)\n \t\t/* The PHI result can also appear on a backedge, if so\n \t\t   we can ignore this case for the purpose of determining\n@@ -3981,8 +4028,6 @@ pass_forwprop::execute (function *fun)\n \t}\n \n       /* Substitute in destination PHI arguments.  */\n-      edge_iterator ei;\n-      edge e;\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \tfor (gphi_iterator gsi = gsi_start_phis (e->dest);\n \t     !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -3998,8 +4043,18 @@ pass_forwprop::execute (function *fun)\n \t\t&& may_propagate_copy (arg, val))\n \t      propagate_value (use_p, val);\n \t  }\n+\n+      /* Mark outgoing exectuable edges.  */\n+      if (edge e = find_taken_edge (bb, NULL))\n+\te->flags |= EDGE_EXECUTABLE;\n+      else\n+\t{\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    e->flags |= EDGE_EXECUTABLE;\n+\t}\n     }\n   free (postorder);\n+  free (bb_to_rpo);\n   lattice.release ();\n \n   /* Remove stmts in reverse order to make debug stmt creation possible.  */"}]}