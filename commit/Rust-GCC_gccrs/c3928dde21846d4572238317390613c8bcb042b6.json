{"sha": "c3928dde21846d4572238317390613c8bcb042b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM5MjhkZGUyMTg0NmQ0NTcyMjM4MzE3MzkwNjEzYzhiY2IwNDJiNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2010-11-05T23:45:32Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-11-05T23:45:32Z"}, "message": "re PR target/46084 (gcc.dg/split-4.c failed with -mavx -m32)\n\ngcc/:\n\tPR target/46084\n\t* explow.c (allocate_dynamic_stack_space): If flag_split_stack,\n\trequest enough additional space for alignment, and force\n\talignment.\ntestsuite/:\n\t* gcc.target/i386/pr46084.c: New test.\n\nFrom-SVN: r166383", "tree": {"sha": "9f086d2faa96f90607a0c59d97ffe86a12e067f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f086d2faa96f90607a0c59d97ffe86a12e067f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3928dde21846d4572238317390613c8bcb042b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3928dde21846d4572238317390613c8bcb042b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3928dde21846d4572238317390613c8bcb042b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3928dde21846d4572238317390613c8bcb042b6/comments", "author": null, "committer": null, "parents": [{"sha": "037de943dc054e19f7387c56668fbb6375bee268", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/037de943dc054e19f7387c56668fbb6375bee268", "html_url": "https://github.com/Rust-GCC/gccrs/commit/037de943dc054e19f7387c56668fbb6375bee268"}], "stats": {"total": 94, "additions": 92, "deletions": 2}, "files": [{"sha": "34b3601e938717d82894fb70dc0e353eb767a805", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3928dde21846d4572238317390613c8bcb042b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3928dde21846d4572238317390613c8bcb042b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c3928dde21846d4572238317390613c8bcb042b6", "patch": "@@ -1,3 +1,10 @@\n+2010-11-05  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR target/46084\n+\t* explow.c (allocate_dynamic_stack_space): If flag_split_stack,\n+\trequest enough additional space for alignment, and force\n+\talignment.\n+\n 2010-11-05  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* config/i386/i386.c (legitimate_pic_address_disp_p):"}, {"sha": "1d809bc842626e3c21ff0508a8e695a9e9ee24ac", "filename": "gcc/explow.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3928dde21846d4572238317390613c8bcb042b6/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3928dde21846d4572238317390613c8bcb042b6/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=c3928dde21846d4572238317390613c8bcb042b6", "patch": "@@ -1340,7 +1340,7 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n      least it doesn't cause a stack overflow.  */\n   if (flag_split_stack)\n     {\n-      rtx available_label, space, func;\n+      rtx available_label, ask, space, func;\n \n       available_label = NULL_RTX;\n \n@@ -1355,10 +1355,19 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n \t}\n #endif\n \n+      /* The __morestack_allocate_stack_space function will allocate\n+\t memory using malloc.  We don't know that the alignment of the\n+\t memory returned by malloc will meet REQUIRED_ALIGN.  Increase\n+\t SIZE to make sure we allocate enough space.  */\n+      ask = expand_binop (Pmode, add_optab, size,\n+\t\t\t  GEN_INT (required_align / BITS_PER_UNIT - 1),\n+\t\t\t  NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+      must_align = true;\n+\n       func = init_one_libfunc (\"__morestack_allocate_stack_space\");\n \n       space = emit_library_call_value (func, target, LCT_NORMAL, Pmode,\n-\t\t\t\t       1, size, Pmode);\n+\t\t\t\t       1, ask, Pmode);\n \n       if (available_label == NULL_RTX)\n \treturn space;"}, {"sha": "b2642c1dfc08f9f276b842aa94d301d465f55327", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3928dde21846d4572238317390613c8bcb042b6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3928dde21846d4572238317390613c8bcb042b6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c3928dde21846d4572238317390613c8bcb042b6", "patch": "@@ -1,3 +1,8 @@\n+2010-11-05  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR target/46084\n+\t* gcc.target/i386/pr46084.c: New test.\n+\n 2010-11-05  Steve Ellcey  <sje@cup.hp.com>\n \n \t* lib/target-supports.exp (check_function_available): Use -fno-builtin."}, {"sha": "88bcd1ca5e0a3778022c0908a0be2775666e6eb5", "filename": "gcc/testsuite/gcc.target/i386/pr46084.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3928dde21846d4572238317390613c8bcb042b6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr46084.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3928dde21846d4572238317390613c8bcb042b6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr46084.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr46084.c?ref=c3928dde21846d4572238317390613c8bcb042b6", "patch": "@@ -0,0 +1,69 @@\n+/* This test needs to use setrlimit to set the stack size, so it can\n+   only run on Unix.  */\n+/* { dg-do run { target *-*-linux* *-*-solaris* *-*-darwin* } } */\n+/* { dg-require-effective-target avx } */\n+/* { dg-require-effective-target split_stack } */\n+/* { dg-options \"-fsplit-stack -O2 -mavx\" } */\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/types.h>\n+#include <sys/resource.h>\n+\n+/* Use a noinline function to ensure that the buffer is not removed\n+   from the stack.  */\n+static void use_buffer (char *buf, size_t) __attribute__ ((noinline));\n+static void\n+use_buffer (char *buf, size_t c)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < c; ++i)\n+    buf[i] = (char) i;\n+}\n+\n+/* Each recursive call uses 10 * i bytes.  We call it 1000 times,\n+   using a total of 5,000,000 bytes.  If -fsplit-stack is not working,\n+   that will overflow our stack limit.  */\n+\n+static void\n+down1 (int i)\n+{\n+  char buf[10 * i];\n+\n+  if (i > 0)\n+    {\n+      use_buffer (buf, 10 * i);\n+      down1 (i - 1);\n+    }\n+}\n+\n+/* Same thing, using alloca.  */\n+\n+static void\n+down2 (int i)\n+{\n+  char *buf = alloca (10 * i);\n+\n+  if (i > 0)\n+    {\n+      use_buffer (buf, 10 * i);\n+      down2 (i - 1);\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  struct rlimit r;\n+\n+  /* We set a stack limit because we are usually invoked via make, and\n+     make sets the stack limit to be as large as possible.  */\n+  r.rlim_cur = 8192 * 1024;\n+  r.rlim_max = 8192 * 1024;\n+  if (setrlimit (RLIMIT_STACK, &r) != 0)\n+    abort ();\n+  down1 (1000);\n+  down2 (1000);\n+  return 0;\n+}"}]}