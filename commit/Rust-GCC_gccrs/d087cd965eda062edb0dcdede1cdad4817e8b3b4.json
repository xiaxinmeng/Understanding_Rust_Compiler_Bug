{"sha": "d087cd965eda062edb0dcdede1cdad4817e8b3b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA4N2NkOTY1ZWRhMDYyZWRiMGRjZGVkZTFjZGFkNDgxN2U4YjNiNA==", "commit": {"author": {"name": "Geert Bosch", "email": "bosch@gcc.gnu.org", "date": "2001-12-11T22:25:15Z"}, "committer": {"name": "Geert Bosch", "email": "bosch@gcc.gnu.org", "date": "2001-12-11T22:25:15Z"}, "message": "sem_ch3.adb: Clarify some ???.\n\n\t* sem_ch3.adb: Clarify some ???.\n\n\t* exp_util.adb (Must_Be_Aligned): Removed, replaced by\n\tExp_Pakd.Known_Aligned_Enough\n\n\t* sem_ch13.adb (Check_Address_Alignment): Removed, extended\n\tversion is moved to Exp_Ch13.\n\nFrom-SVN: r47899", "tree": {"sha": "844738a58b7846d7b377fd3594707376a50f0602", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/844738a58b7846d7b377fd3594707376a50f0602"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d087cd965eda062edb0dcdede1cdad4817e8b3b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d087cd965eda062edb0dcdede1cdad4817e8b3b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d087cd965eda062edb0dcdede1cdad4817e8b3b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d087cd965eda062edb0dcdede1cdad4817e8b3b4/comments", "author": null, "committer": null, "parents": [{"sha": "980f237d115e7d58e664c063e0aade7dafd636ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/980f237d115e7d58e664c063e0aade7dafd636ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/980f237d115e7d58e664c063e0aade7dafd636ea"}], "stats": {"total": 203, "additions": 52, "deletions": 151}, "files": [{"sha": "e82eb263a7a3182ab4b03e349ef1f1d6fe37e00b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d087cd965eda062edb0dcdede1cdad4817e8b3b4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d087cd965eda062edb0dcdede1cdad4817e8b3b4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d087cd965eda062edb0dcdede1cdad4817e8b3b4", "patch": "@@ -1,3 +1,45 @@\n+2001-12-11  Ed Schonberg <schonber@gnat.com>\n+\n+\t* sem_ch3.adb: Clarify some ???.\n+\t\n+2001-12-11  Robert Dewar <dewar@gnat.com>\n+\n+\t* exp_util.adb (Must_Be_Aligned): Removed, replaced by \n+\tExp_Pakd.Known_Aligned_Enough\n+\t\n+\t* sem_ch13.adb (Check_Address_Alignment): Removed, extended \n+\tversion is moved to Exp_Ch13.\n+\n+2001-12-11  Robert Dewar <dewar@gnat.com>\n+\n+\t* einfo.ads: Minor reformatting\n+\t\n+\t* exp_ch5.adb: Add comment for previous.change\n+\t\n+\t* ali.adb: New interface for extended typeref stuff.\n+\t\n+\t* ali.ads: New interface for typeref stuff.\n+\t\n+\t* checks.adb (Apply_Alignment_Check): New procedure.\n+\t\n+\t* debug.adb: Add -gnatdM for modified ALI output\n+\t\n+\t* exp_pakd.adb (Known_Aligned_Enough): Replaces Known_Aligned_Enough.\n+\t\n+\t* lib-xref.adb: Extend generation of <..> notation to cover \n+\tsubtype/object types. Note that this is a complete rewrite, \n+\tgetting rid of the very nasty quadratic algorithm previously \n+\tused for derived type output.\n+\t\n+\t* lib-xref.ads: Extend description of <..> notation to cover \n+\tsubtype/object types. Uses {..} for these other cases. \n+\tAlso use (..) for pointer types.\n+\t\n+\t* sem_util.adb (Check_Potentially_Blocking_Operation): Slight cleanup.\n+\t\n+\t* exp_pakd.adb: Minor reformatting.  Note that prevous RH should say: \n+\t(Known_Aligned_Enough): Replaces Must_Be_Aligned.\n+\n 2001-12-11  Vincent Celier <celier@gnat.com>\n \n \t* gnatcmd.adb:"}, {"sha": "f7a52a73a75e9a20f508290869f3207fb5ddf55e", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d087cd965eda062edb0dcdede1cdad4817e8b3b4/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d087cd965eda062edb0dcdede1cdad4817e8b3b4/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=d087cd965eda062edb0dcdede1cdad4817e8b3b4", "patch": "@@ -2488,101 +2488,6 @@ package body Exp_Util is\n       end if;\n    end May_Generate_Large_Temp;\n \n-   ---------------------\n-   -- Must_Be_Aligned --\n-   ---------------------\n-\n-   function Must_Be_Aligned (Obj : Node_Id) return Boolean is\n-      Typ : constant Entity_Id := Etype (Obj);\n-\n-      function In_Partially_Packed_Record (Comp : Entity_Id) return Boolean;\n-      --  If the component is in a record that contains previous packed\n-      --  components, consider it unaligned because the back-end might\n-      --  choose to pack the rest of the record. Lead to less efficient code,\n-      --  but safer vis-a-vis of back-end choices.\n-\n-      -----------------------------\n-      -- Partially_Packed_Record --\n-      -----------------------------\n-\n-      function In_Partially_Packed_Record (Comp : Entity_Id) return Boolean is\n-         Rec_Type  : constant Entity_Id := Scope (Comp);\n-         Prev_Comp : Entity_Id;\n-\n-      begin\n-         Prev_Comp := First_Entity (Rec_Type);\n-         while Present (Prev_Comp) loop\n-            if Is_Packed (Etype (Prev_Comp)) then\n-               return True;\n-\n-            elsif Prev_Comp = Comp then\n-               return False;\n-            end if;\n-\n-            Next_Entity (Prev_Comp);\n-         end loop;\n-\n-         return False;\n-      end  In_Partially_Packed_Record;\n-\n-   --  Start of processing for Must_Be_Aligned\n-\n-   begin\n-      --  If object is strictly aligned, we can quit now\n-\n-      if Strict_Alignment (Typ) then\n-         return True;\n-\n-      --  Case of subscripted array reference\n-\n-      elsif Nkind (Obj) = N_Indexed_Component then\n-\n-         --  If we have a pointer to an array, then this is definitely\n-         --  aligned, because pointers always point to aligned versions.\n-\n-         if Is_Access_Type (Etype (Prefix (Obj))) then\n-            return True;\n-\n-         --  Otherwise, go look at the prefix\n-\n-         else\n-            return Must_Be_Aligned (Prefix (Obj));\n-         end if;\n-\n-      --  Case of record field\n-\n-      elsif Nkind (Obj) = N_Selected_Component then\n-\n-         --  What is significant here is whether the record type is packed\n-\n-         if Is_Record_Type (Etype (Prefix (Obj)))\n-           and then Is_Packed (Etype (Prefix (Obj)))\n-         then\n-            return False;\n-\n-         --  Or the component has a component clause which might cause\n-         --  the component to become unaligned (we can't tell if the\n-         --  backend is doing alignment computations).\n-\n-         elsif Present (Component_Clause (Entity (Selector_Name (Obj)))) then\n-            return False;\n-\n-         elsif In_Partially_Packed_Record (Entity (Selector_Name (Obj))) then\n-            return False;\n-\n-         --  In all other cases, go look at prefix\n-\n-         else\n-            return Must_Be_Aligned (Prefix (Obj));\n-         end if;\n-\n-      --  If not selected or indexed component, must be aligned\n-\n-      else\n-         return True;\n-      end if;\n-   end Must_Be_Aligned;\n-\n    ----------------------------\n    -- New_Class_Wide_Subtype --\n    ----------------------------"}, {"sha": "a4a76ff2cc321fc2fd0bb8ed868b4700d10735e8", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 8, "deletions": 48, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d087cd965eda062edb0dcdede1cdad4817e8b3b4/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d087cd965eda062edb0dcdede1cdad4817e8b3b4/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=d087cd965eda062edb0dcdede1cdad4817e8b3b4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision: 1.1 $\n+--                            $Revision$\n --                                                                          --\n --          Copyright (C) 1992-2001, Free Software Foundation, Inc.         --\n --                                                                          --\n@@ -27,6 +27,7 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n+with Checks;   use Checks;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Exp_Tss;  use Exp_Tss;\n@@ -68,14 +69,6 @@ package body Sem_Ch13 is\n    --  inherited from a derived type that is no longer appropriate for the\n    --  new Esize value. In this case, we reset the Alignment to unknown.\n \n-   procedure Check_Address_Alignment (E : Entity_Id; Expr : Node_Id);\n-   --  Given an object entity E, for which the alignment is known, checks\n-   --  to see if Expr (the expression from an Address clause) is a known\n-   --  at compile time value, and if so posts a warning if the value is\n-   --  not consistent with the known alignment requirement. This is not\n-   --  an error, but rather leads to erroneous behavior, but we certainly\n-   --  may as well give a warning if we detect this situation.\n-\n    procedure Check_Component_Overlap (C1_Ent, C2_Ent : Entity_Id);\n    --  Given two entities for record components or discriminants, checks\n    --  if they hav overlapping component clauses and issues errors if so.\n@@ -315,7 +308,7 @@ package body Sem_Ch13 is\n \n                Check_Constant_Address_Clause (Expr, U_Ent);\n \n-            --  Case of address clause for variable or constant\n+            --  Case of address clause for an object\n \n             elsif\n               Ekind (U_Ent) = E_Variable\n@@ -398,10 +391,12 @@ package body Sem_Ch13 is\n                      Warn_Overlay (Expr, Typ, Nam);\n                   end if;\n \n-                  --  Check for bad alignment\n+                  --  If entity has delayed freeze then we will generate\n+                  --  an alignment check at the freeze point. If there is\n+                  --  no delayed freeze we can do it right now.\n \n-                  if Known_Alignment (U_Ent) then\n-                     Check_Address_Alignment (U_Ent, Expr);\n+                  if not Has_Delayed_Freeze (U_Ent) then\n+                     Apply_Alignment_Check (U_Ent, N);\n                   end if;\n \n                   --  Kill the size check code, since we are not allocating\n@@ -2320,41 +2315,6 @@ package body Sem_Ch13 is\n \n    end Analyze_Record_Representation_Clause;\n \n-   -----------------------------\n-   -- Check_Address_Alignment --\n-   -----------------------------\n-\n-   procedure Check_Address_Alignment (E : Entity_Id; Expr : Node_Id) is\n-      Arg : Node_Id;\n-\n-   begin\n-      if Nkind (Expr) = N_Unchecked_Type_Conversion then\n-         Arg := Expression (Expr);\n-\n-      elsif Nkind (Expr) = N_Function_Call\n-        and then Is_RTE (Entity (Name (Expr)), RE_To_Address)\n-      then\n-         Arg := First (Parameter_Associations (Expr));\n-\n-         if Nkind (Arg) = N_Parameter_Association then\n-            Arg := Explicit_Actual_Parameter (Arg);\n-         end if;\n-\n-      else\n-         return;\n-      end if;\n-\n-      --  Here Arg is the address value\n-\n-      if Compile_Time_Known_Value (Arg) then\n-         if Expr_Value (Arg) mod Alignment (E) /= 0 then\n-            Error_Msg_NE\n-              (\"?specified address for& not consistent with alignment\",\n-               Arg, E);\n-         end if;\n-      end if;\n-   end Check_Address_Alignment;\n-\n    -----------------------------\n    -- Check_Component_Overlap --\n    -----------------------------"}, {"sha": "dcae6f968549ad8e2b7901b0a52c4b6e4acb9cea", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d087cd965eda062edb0dcdede1cdad4817e8b3b4/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d087cd965eda062edb0dcdede1cdad4817e8b3b4/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=d087cd965eda062edb0dcdede1cdad4817e8b3b4", "patch": "@@ -7306,7 +7306,7 @@ package body Sem_Ch3 is\n       Suffix_Index : Nat)\n    is\n       Def_Id     : Entity_Id;\n-      R          : Node_Id;\n+      R          : Node_Id := Empty;\n       Checks_Off : Boolean := False;\n       T          : constant Entity_Id := Etype (Index);\n \n@@ -7408,8 +7408,6 @@ package body Sem_Ch3 is\n       Set_RM_Size        (Def_Id, RM_Size        (T));\n       Set_First_Rep_Item (Def_Id, First_Rep_Item (T));\n \n-      --  ??? ??? is R always initialized, not at all obvious why?\n-\n       Set_Scalar_Range   (Def_Id, R);\n \n       Set_Etype (S, Def_Id);\n@@ -10333,12 +10331,8 @@ package body Sem_Ch3 is\n \n          --  The parser guarantees that the attribute is a RANGE attribute\n \n-         --  Is order critical here (setting T before Resolve). If so,\n-         --  document why, if not use Analyze_And_Resolve and get T after???\n-\n-         Analyze (I);\n+         Analyze_And_Resolve (I);\n          T := Etype (I);\n-         Resolve (I, T);\n          R := I;\n \n       --  If none of the above, must be a subtype. We convert this to a"}]}