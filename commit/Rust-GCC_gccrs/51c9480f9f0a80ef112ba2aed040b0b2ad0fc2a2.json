{"sha": "51c9480f9f0a80ef112ba2aed040b0b2ad0fc2a2", "node_id": "C_kwDOANBUbNoAKDUxYzk0ODBmOWYwYTgwZWYxMTJiYTJhZWQwNDBiMGIyYWQwZmMyYTI", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-08-29T11:27:02Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-09-25T12:44:54Z"}, "message": "fortran: Support clobbering of reference variables [PR41453]\n\nThis adds support for clobbering of variables passed by reference,\nwhen the reference is forwarded to a subroutine as actual argument\nwhose associated dummy has the INTENT(OUT) attribute.\nThis was explicitly disabled by a condition added with\nr9-3032-gee7fb0588c6361b4d77337ab0f7527be64fcdde2 and removing that\ncondition seems to work, as demonstrated by the new testcase.\n\n\tPR fortran/41453\n\tPR fortran/87395\n\ngcc/fortran/ChangeLog:\n\n\t* trans-expr.cc (gfc_conv_procedure_call): Remove condition\n\tdisabling clobber generation for dummy variables.  Remove\n\tobsolete comment.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/intent_optimize_6.f90: New test.", "tree": {"sha": "1e13e73ddf64ef320bdb94fd22581762911882cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e13e73ddf64ef320bdb94fd22581762911882cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51c9480f9f0a80ef112ba2aed040b0b2ad0fc2a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51c9480f9f0a80ef112ba2aed040b0b2ad0fc2a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51c9480f9f0a80ef112ba2aed040b0b2ad0fc2a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51c9480f9f0a80ef112ba2aed040b0b2ad0fc2a2/comments", "author": null, "committer": null, "parents": [{"sha": "20aa1eb6cb84e6a0487b47b28b00109c5f46a7e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20aa1eb6cb84e6a0487b47b28b00109c5f46a7e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20aa1eb6cb84e6a0487b47b28b00109c5f46a7e2"}], "stats": {"total": 38, "additions": 34, "deletions": 4}, "files": [{"sha": "11b7c05929c2ff2209b1296f4e025c0e9bd8dc83", "filename": "gcc/fortran/trans-expr.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c9480f9f0a80ef112ba2aed040b0b2ad0fc2a2/gcc%2Ffortran%2Ftrans-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c9480f9f0a80ef112ba2aed040b0b2ad0fc2a2/gcc%2Ffortran%2Ftrans-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.cc?ref=51c9480f9f0a80ef112ba2aed040b0b2ad0fc2a2", "patch": "@@ -6527,8 +6527,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t  && !e->symtree->n.sym->attr.dimension\n \t\t\t  && !e->symtree->n.sym->attr.pointer\n \t\t\t  && !e->symtree->n.sym->attr.allocatable\n-\t\t\t  /* See PR 41453.  */\n-\t\t\t  && !e->symtree->n.sym->attr.dummy\n \t\t\t  /* FIXME - PR 87395 and PR 41453  */\n \t\t\t  && e->symtree->n.sym->attr.save == SAVE_NONE\n \t\t\t  && !e->symtree->n.sym->attr.associate_var\n@@ -6538,8 +6536,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t  && !sym->attr.elemental)\n \t\t\t{\n \t\t\t  tree var;\n-\t\t\t  /* FIXME: This fails if var is passed by reference, see PR\n-\t\t\t     41453.  */\n \t\t\t  var = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\t\t     parmse.expr);\n \t\t\t  tree clobber = build_clobber (TREE_TYPE (var));"}, {"sha": "72fec3db583660a030613af64ea60afa61d31871", "filename": "gcc/testsuite/gfortran.dg/intent_optimize_6.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c9480f9f0a80ef112ba2aed040b0b2ad0fc2a2/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c9480f9f0a80ef112ba2aed040b0b2ad0fc2a2/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_6.f90?ref=51c9480f9f0a80ef112ba2aed040b0b2ad0fc2a2", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fno-inline -fno-ipa-modref -fdump-tree-optimized -fdump-tree-original\" }\n+!\n+! PR fortran/41453\n+! Check that the INTENT(OUT) attribute causes one clobber to be emitted in\n+! the caller before each call to FOO in the *.original dump, and the\n+! initialization constant to be optimized away in the *.optimized dump,\n+! in the case of an argument passed by reference to the caller.\n+\n+module x\n+implicit none\n+contains\n+  subroutine foo(a)\n+    integer(kind=4), intent(out) :: a\n+    a = 42\n+  end subroutine foo\n+  subroutine bar(b)\n+    integer(kind=4) :: b\n+    b = 123456789\n+    call foo(b)\n+  end subroutine bar\n+end module x\n+\n+program main\n+  use x\n+  implicit none\n+  integer(kind=4) :: c\n+  call bar(c)\n+  if (c /= 42) stop 1\n+end program main\n+\n+! { dg-final { scan-tree-dump-times \"CLOBBER\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump \"\\\\*\\\\\\(integer\\\\\\(kind=4\\\\\\) \\\\*\\\\\\) b = {CLOBBER};\" \"original\" } }\n+! { dg-final { scan-tree-dump-not \"123456789\" \"optimized\" { target __OPTIMIZE__ } } }"}]}