{"sha": "8d9e9a083d629324aec2cab9aacfd37b47fa9b48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ5ZTlhMDgzZDYyOTMyNGFlYzJjYWI5YWFjZmQzN2I0N2ZhOWI0OA==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-12-01T22:01:10Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-12-01T22:01:10Z"}, "message": "cppinit.c (initialize): Forgotten prototype.\n\n        * cppinit.c (initialize): Forgotten prototype.\n        * cpplex.c (_cpp_lex_token): Loop until not skipping.\n        Always clear PREV_WHITE upon meeting a new line.\n        * cpplib.c (end_directive): Set pfile->skipping after\n        skip_rest_of_line.\n        * cpplib.h (cpp_reader): Remove macro_pos.\n        * cppmacro.c (cpp_get_line): Don't do anything special inside\n        macros.\n        (parse_arg): Add PREV_WHITE if a token appears after new lines.\n        (funlike_invocation_p): Save and restore the output position\n        over a successful check for a '('.\n        (enter_macro_context): Delete uses of macro_pos.\n        (cpp_get_token): Don't use pfile->skipping.\n\nFrom-SVN: r37927", "tree": {"sha": "b2d9610f10a0aa663383569503ef2c3432eb0dd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2d9610f10a0aa663383569503ef2c3432eb0dd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d9e9a083d629324aec2cab9aacfd37b47fa9b48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d9e9a083d629324aec2cab9aacfd37b47fa9b48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d9e9a083d629324aec2cab9aacfd37b47fa9b48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d9e9a083d629324aec2cab9aacfd37b47fa9b48/comments", "author": null, "committer": null, "parents": [{"sha": "a717799c527689a0590887bad2d381bf163c29b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a717799c527689a0590887bad2d381bf163c29b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a717799c527689a0590887bad2d381bf163c29b4"}], "stats": {"total": 74, "additions": 45, "deletions": 29}, "files": [{"sha": "e5d730ed69e15947c416d6b54534f3e6d9ae2118", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9e9a083d629324aec2cab9aacfd37b47fa9b48/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9e9a083d629324aec2cab9aacfd37b47fa9b48/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d9e9a083d629324aec2cab9aacfd37b47fa9b48", "patch": "@@ -1,3 +1,19 @@\n+2000-12-01  Neil Booth  <neilb@earthling.net>\n+\n+        * cppinit.c (initialize): Forgotten prototype.\n+        * cpplex.c (_cpp_lex_token): Loop until not skipping.\n+        Always clear PREV_WHITE upon meeting a new line.\n+        * cpplib.c (end_directive): Set pfile->skipping after\n+        skip_rest_of_line.\n+        * cpplib.h (cpp_reader): Remove macro_pos.\n+        * cppmacro.c (cpp_get_line): Don't do anything special inside\n+        macros.  \n+        (parse_arg): Add PREV_WHITE if a token appears after new lines.\n+        (funlike_invocation_p): Save and restore the output position\n+        over a successful check for a '('.\n+        (enter_macro_context): Delete uses of macro_pos.\n+        (cpp_get_token): Don't use pfile->skipping.\n+\n 2000-12-01  Phil Edwards  <pme@sources.redhat.com>\n \n \t* diagnostic.c:  Fix typos in comments."}, {"sha": "e3d12213867ceda43ced81bab3bc39d5a534c2e1", "filename": "gcc/cppinit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9e9a083d629324aec2cab9aacfd37b47fa9b48/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9e9a083d629324aec2cab9aacfd37b47fa9b48/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=8d9e9a083d629324aec2cab9aacfd37b47fa9b48", "patch": "@@ -94,6 +94,7 @@ struct cpp_pending\n static void print_help                  PARAMS ((void));\n static void path_include\t\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t char *, int));\n+static void initialize\t\t\tPARAMS ((void));\n static void initialize_builtins\t\tPARAMS ((cpp_reader *));\n static void append_include_chain\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t char *, int, int));"}, {"sha": "f6818300f3dc7c9642958acbcb6ee00b2c95b3de", "filename": "gcc/cpplex.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9e9a083d629324aec2cab9aacfd37b47fa9b48/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9e9a083d629324aec2cab9aacfd37b47fa9b48/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=8d9e9a083d629324aec2cab9aacfd37b47fa9b48", "patch": "@@ -850,8 +850,10 @@ _cpp_lex_token (pfile, result)\n   cppchar_t c;\n   cpp_buffer *buffer;\n   const unsigned char *comment_start;\n-  unsigned char bol = pfile->state.next_bol;\n+  unsigned char bol;\n \n+ skip:\n+  bol = pfile->state.next_bol;\n  done_directive:\n   buffer = pfile->buffer;\n   pfile->state.next_bol = 0;\n@@ -894,13 +896,10 @@ _cpp_lex_token (pfile, result)\n \t  handle_newline (buffer, c);\n \t  bol = 1;\n \t  pfile->lexer_pos.output_line = buffer->lineno;\n-\n-\t  /* Newlines in arguments are white space (6.10.3.10).\n-             Otherwise, clear any white space flag.  */\n-\t  if (pfile->state.parsing_args)\n-\t    result->flags |= PREV_WHITE;\n-\t  else\n-\t    result->flags &= ~PREV_WHITE;\n+\t  /* This is a new line, so clear any white space flag.\n+\t     Newlines in arguments are white space (6.10.3.10);\n+\t     parse_arg takes care of that.  */\n+\t  result->flags &= ~PREV_WHITE;\n \t  goto next_char;\n \t}\n \n@@ -1276,6 +1275,9 @@ _cpp_lex_token (pfile, result)\n       break;\n     }\n \n+  if (pfile->skipping)\n+    goto skip;\n+\n   /* If not in a directive, this token invalidates controlling macros.  */\n   if (!pfile->state.in_directive)\n     pfile->mi_state = MI_FAILED;"}, {"sha": "2eaf7552b27d1039dcf211e05a1a349bbfa3091b", "filename": "gcc/cpplib.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9e9a083d629324aec2cab9aacfd37b47fa9b48/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9e9a083d629324aec2cab9aacfd37b47fa9b48/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=8d9e9a083d629324aec2cab9aacfd37b47fa9b48", "patch": "@@ -247,14 +247,14 @@ end_directive (pfile, skip_line)\n {\n   cpp_buffer *buffer = pfile->buffer;\n \n-  /* Restore pfile->skipping before skip_rest_of_line.  This avoids\n-     warning about poisoned identifiers in skipped #error lines.  */\n-  pfile->skipping = buffer->was_skipping;\n-\n   /* We don't skip for an assembler #.  */\n   if (skip_line)\n     skip_rest_of_line (pfile);\n \n+  /* Restore pfile->skipping after skip_rest_of_line.  Otherwise the\n+     lexer might not return!  */\n+  pfile->skipping = buffer->was_skipping;\n+\n   /* Restore state.  */\n   pfile->la_write = pfile->la_saved;\n   pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);"}, {"sha": "faccc6a8bf389148fc51ccd50007b6b88be2f81e", "filename": "gcc/cpplib.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9e9a083d629324aec2cab9aacfd37b47fa9b48/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9e9a083d629324aec2cab9aacfd37b47fa9b48/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=8d9e9a083d629324aec2cab9aacfd37b47fa9b48", "patch": "@@ -498,10 +498,8 @@ struct cpp_reader\n   /* Lexer state.  */\n   struct lexer_state state;\n \n-  /* The position of the last lexed token, last lexed directive, and\n-     last macro invocation.  */\n+  /* The position of the last lexed token and last lexed directive.  */\n   cpp_lexer_pos lexer_pos;\n-  cpp_lexer_pos macro_pos;\n   cpp_lexer_pos directive_pos;\n \n   /* Memory pools.  */"}, {"sha": "eed2798fc7b22953f28670a3361437097fba4528", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9e9a083d629324aec2cab9aacfd37b47fa9b48/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9e9a083d629324aec2cab9aacfd37b47fa9b48/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=8d9e9a083d629324aec2cab9aacfd37b47fa9b48", "patch": "@@ -236,10 +236,6 @@ const cpp_lexer_pos *\n cpp_get_line (pfile)\n      cpp_reader *pfile;\n {\n-  /* Within a macro expansion, return the position of the outermost\n-     invocation.  */\n-  if (pfile->context->prev)\n-    return &pfile->macro_pos;\n   return &pfile->lexer_pos;\n }\n \n@@ -489,6 +485,7 @@ parse_arg (pfile, arg, var_args)\n {\n   enum cpp_ttype result;\n   unsigned int paren = 0;\n+  unsigned int line;\n \n   arg->first = (cpp_token *) POOL_FRONT (&pfile->argument_pool);\n   for (;; arg->count++)\n@@ -501,9 +498,13 @@ parse_arg (pfile, arg, var_args)\n \t  token = &arg->first[arg->count];\n \t}\n \n+      /* Newlines in arguments are white space (6.10.3.10).  */\n+      line = pfile->lexer_pos.output_line;\n       cpp_get_token (pfile, token);\n-      result = token->type;\n+      if (line != pfile->lexer_pos.output_line)\n+\ttoken->flags |= PREV_WHITE;\n \n+      result = token->type;\n       if (result == CPP_OPEN_PAREN)\n \tparen++;\n       else if (result == CPP_CLOSE_PAREN && paren-- == 0)\n@@ -608,7 +609,9 @@ funlike_invocation_p (pfile, node, list)\n   cpp_context *orig_context;\n   cpp_token maybe_paren;\n   macro_arg *args = 0;\n+  cpp_lexer_pos macro_pos;\n \n+  macro_pos = pfile->lexer_pos;\n   pfile->state.parsing_args = 1;\n   pfile->state.prevent_expansion++;\n   orig_context = pfile->context;\n@@ -631,6 +634,9 @@ funlike_invocation_p (pfile, node, list)\n \n   if (args)\n     {\n+      /* The macro's expansion appears where the name would have.  */\n+      pfile->lexer_pos = macro_pos;\n+\n       if (node->value.macro->paramc > 0)\n \t{\n \t  /* Don't save tokens during pre-expansion.  */\n@@ -660,10 +666,7 @@ enter_macro_context (pfile, node)\n \n   /* Save the position of the outermost macro invocation.  */\n   if (!pfile->context->prev)\n-    {\n-      pfile->macro_pos = pfile->lexer_pos;\n-      lock_pools (pfile);\n-    }\n+    lock_pools (pfile);\n \n   if (macro->fun_like && !funlike_invocation_p (pfile, node, &list))\n     {\n@@ -924,7 +927,7 @@ cpp_get_token (pfile, token)\n \t  token->flags |= flags;\n \t  flags = 0;\n \t  /* PASTE_LEFT tokens can only appear in macro expansions.  */\n-\t  if (token->flags & PASTE_LEFT && !pfile->skipping)\n+\t  if (token->flags & PASTE_LEFT)\n \t    paste_all_tokens (pfile, token);\n \t}\n       else\n@@ -940,10 +943,6 @@ cpp_get_token (pfile, token)\n \t  return;\n \t}\n \n-      /* Loop until we're not skipping.  */\n-      if (pfile->skipping)\n-\tcontinue;\n-\n       if (token->type != CPP_NAME)\n \tbreak;\n "}]}