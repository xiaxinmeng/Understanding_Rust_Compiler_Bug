{"sha": "dd75c2921d223fe65aef52d829c9184d723818f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ3NWMyOTIxZDIyM2ZlNjVhZWY1MmQ4MjljOTE4NGQ3MjM4MThmNQ==", "commit": {"author": {"name": "Craig Burley", "email": "burley@gnu.org", "date": "1998-07-28T21:33:43Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-07-28T21:33:43Z"}, "message": "gcc.c: Fix commentary describing %g, %u, %U, and %O.\n\nd\n        * gcc.c: Fix commentary describing %g, %u, %U, and %O.\n        * gcc.c (do_spec_1): Fix support for %O so the\n        temporary file name made for it the first time\n        gets reused subsequently.\n\nFrom-SVN: r21450", "tree": {"sha": "879c3f0c7b3ac576e97c6192a22a59d174fef5bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/879c3f0c7b3ac576e97c6192a22a59d174fef5bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd75c2921d223fe65aef52d829c9184d723818f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd75c2921d223fe65aef52d829c9184d723818f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd75c2921d223fe65aef52d829c9184d723818f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd75c2921d223fe65aef52d829c9184d723818f5/comments", "author": null, "committer": null, "parents": [{"sha": "e67ac8e6ee6ad8aa24429e997b61252b19b17330", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e67ac8e6ee6ad8aa24429e997b61252b19b17330", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e67ac8e6ee6ad8aa24429e997b61252b19b17330"}], "stats": {"total": 81, "additions": 54, "deletions": 27}, "files": [{"sha": "1787d0f1c93205fe1410aa474648d1cf340b78f4", "filename": "gcc/gcc.c", "status": "modified", "additions": 54, "deletions": 27, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd75c2921d223fe65aef52d829c9184d723818f5/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd75c2921d223fe65aef52d829c9184d723818f5/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=dd75c2921d223fe65aef52d829c9184d723818f5", "patch": "@@ -281,12 +281,30 @@ or with constant text in a single argument.\n  %b     substitute the basename of the input file being processed.\n \tThis is the substring up to (and not including) the last period\n \tand not including the directory.\n- %g     substitute the temporary-file-name-base.  This is a string chosen\n-\tonce per compilation.  Different temporary file names are made by\n-\tconcatenation of constant strings on the end, as in `%g.s'.\n-\t%g also has the same effect of %d.\n- %u\tlike %g, but make the temporary file name unique.\n- %U\treturns the last file name generated with %u.\n+ %gSUFFIX\n+\tsubstitute a file name that has suffix SUFFIX and is chosen\n+\tonce per compilation, and mark the argument a la %d.  To reduce\n+\texposure to denial-of-service attacks, the file name is now\n+\tchosen in a way that is hard to predict even when previously\n+\tchosen file names are known.  For example, `%g.s ... %g.o ... %g.s'\n+\tmight turn into `ccUVUUAU.s ccXYAXZ12.o ccUVUUAU.s'.  SUFFIX matches\n+\tthe regexp \"[.A-Za-z]*\" or the special string \"%O\", which is\n+\ttreated exactly as if %O had been pre-processed.  Previously, %g\n+\twas simply substituted with a file name chosen once per compilation,\n+\twithout regard to any appended suffix (which was therefore treated\n+\tjust like ordinary text), making such attacks more likely to succeed.\n+ %uSUFFIX\n+\tlike %g, but generates a new temporary file name even if %uSUFFIX\n+\twas already seen.\n+ %USUFFIX\n+\tsubstitutes the last file name generated with %uSUFFIX, generating a\n+\tnew one if there is no such last file name.  In the absence of any\n+\t%uSUFFIX, this is just like %gSUFFIX, except they don't share\n+\tthe same suffix \"space\", so `%g.s ... %U.s ... %g.s ... %U.s'\n+\twould involve the generation of two distinct file names, one\n+\tfor each `%g.s' and another for each `%U.s'.  Previously, %U was\n+\tsimply substituted with a file name chosen for the previous %u,\n+\twithout regard to any appended suffix.\n  %d\tmarks the argument containing or following the %d as a\n \ttemporary file name, so that that file will be deleted if CC exits\n \tsuccessfully.  Unlike %g, this contributes no text to the argument.\n@@ -303,7 +321,13 @@ or with constant text in a single argument.\n \tInput files whose names have no recognized suffix are not compiled\n \tat all, but they are included among the output files, so they will\n \tbe linked.\n- %O\tsubstitutes the suffix for object files.\n+ %O\tsubstitutes the suffix for object files.  Note that this is\n+\thandled specially when it immediately follows %g, %u, or %U,\n+\tbecause of the need for those to form complete file names.  The\n+\thandling is such that %O is treated exactly as if it had already\n+\tbeen substituted, except that %g, %u, and %U do not currently\n+\tsupport additional SUFFIX characters following %O as they would\n+\tfollowing, for example, `.o'.\n  %p\tsubstitutes the standard macro predefinitions for the\n \tcurrent target machine.  Use this when running cpp.\n  %P\tlike %p, but puts `__' before and after the name of each macro.\n@@ -3620,16 +3644,30 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t   That matters for the names of object files.\n \t\t   In 2.4, do something about that.  */\n \t\tstruct temp_name *t;\n+\t\tint suffix_length;\n \t\tchar *suffix = p;\n-\t\twhile (*p == '.' || ISALPHA (*p)\n-\t\t       || (p[0] == '%' && p[1] == 'O'))\n-\t\t  p++;\n+\n+\t\tif (p[0] == '%' && p[1] == 'O')\n+\t\t  {\n+\t\t    /* We don't support extra suffix characters after %O.  */\n+\t\t    if (*p == '.' || ISALPHA (*p))\n+\t\t      abort ();\n+\t\t    suffix = OBJECT_SUFFIX;\n+\t\t    suffix_length = strlen (OBJECT_SUFFIX);\n+\t\t    p += 2;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    while (*p == '.' || ISALPHA (*p))\n+\t\t      p++;\n+\t\t    suffix_length = p - suffix;\n+\t\t  }\n \n \t\t/* See if we already have an association of %g/%u/%U and\n \t\t   suffix.  */\n \t\tfor (t = temp_names; t; t = t->next)\n-\t\t  if (t->length == p - suffix\n-\t\t      && strncmp (t->suffix, suffix, p - suffix) == 0\n+\t\t  if (t->length == suffix_length\n+\t\t      && strncmp (t->suffix, suffix, suffix_length) == 0\n \t\t      && t->unique == (c != 'g'))\n \t\t    break;\n \n@@ -3642,21 +3680,10 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t\tt->next = temp_names;\n \t\t\ttemp_names = t;\n \t\t      }\n-\t\t    if (strncmp (suffix, \"%O\", 2) == 0)\n-\t\t      {\n-\t\t\tt->length = strlen(OBJECT_SUFFIX);\n-\t\t\tt->suffix = save_string (OBJECT_SUFFIX,\n-\t\t\t\t\t\t strlen(OBJECT_SUFFIX));\n-\t\t\tt->unique = (c != 'g');\n-\t\t\ttemp_filename = make_temp_file (OBJECT_SUFFIX);\n-\t\t      }\n-\t\t    else\n-\t\t      {\n-\t\t\tt->length = p - suffix;\n-\t\t\tt->suffix = save_string (suffix, p - suffix);\n-\t\t\tt->unique = (c != 'g');\n-\t\t\ttemp_filename = make_temp_file (t->suffix);\n-\t\t      }\n+\t\t    t->length = suffix_length;\n+\t\t    t->suffix = save_string (suffix, suffix_length);\n+\t\t    t->unique = (c != 'g');\n+\t\t    temp_filename = make_temp_file (t->suffix);\n \t\t    temp_filename_length = strlen (temp_filename);\n \t\t    t->filename = temp_filename;\n \t\t    t->filename_length = temp_filename_length;"}]}