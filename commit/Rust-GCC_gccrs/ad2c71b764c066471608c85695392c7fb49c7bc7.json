{"sha": "ad2c71b764c066471608c85695392c7fb49c7bc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQyYzcxYjc2NGMwNjY0NzE2MDhjODU2OTUzOTJjN2ZiNDljN2JjNw==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-06-29T21:17:27Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-06-29T21:17:27Z"}, "message": "* pa.c, pa.h, pa.md: Convert to gen_rtx_FOO.\n\nFrom-SVN: r20806", "tree": {"sha": "8bfa841c8fdd007293134f81028c2ac0561ad8b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bfa841c8fdd007293134f81028c2ac0561ad8b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad2c71b764c066471608c85695392c7fb49c7bc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad2c71b764c066471608c85695392c7fb49c7bc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad2c71b764c066471608c85695392c7fb49c7bc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad2c71b764c066471608c85695392c7fb49c7bc7/comments", "author": null, "committer": null, "parents": [{"sha": "2880d0aa371f2f8d6cb59baa9759a1399faa1a93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2880d0aa371f2f8d6cb59baa9759a1399faa1a93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2880d0aa371f2f8d6cb59baa9759a1399faa1a93"}], "stats": {"total": 516, "additions": 265, "deletions": 251}, "files": [{"sha": "354de5aa240a30cd828cdc8ccec9b7e6fd59e39a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2c71b764c066471608c85695392c7fb49c7bc7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2c71b764c066471608c85695392c7fb49c7bc7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad2c71b764c066471608c85695392c7fb49c7bc7", "patch": "@@ -1,3 +1,7 @@\n+Mon Jun 29 22:12:06 1998  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* pa.c, pa.h, pa.md: Convert to gen_rtx_FOO.\n+\n Mon Jun 29 20:12:41 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n         * Makefile.in (fix-header): Don't needlessly depend on cpperror.o."}, {"sha": "1100e29dd2acb62384323d274f5f5302ebdcf748", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 219, "deletions": 207, "changes": 426, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2c71b764c066471608c85695392c7fb49c7bc7/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2c71b764c066471608c85695392c7fb49c7bc7/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=ad2c71b764c066471608c85695392c7fb49c7bc7", "patch": "@@ -613,13 +613,17 @@ legitimize_pic_address (orig, mode, reg)\n       if (flag_pic == 2)\n \t{\n \t  emit_insn (gen_pic2_highpart (reg, pic_offset_table_rtx, orig));\n-\t  pic_ref = gen_rtx (MEM, Pmode,\n-\t\t\t     gen_rtx (LO_SUM, Pmode, reg,\n-\t\t\t\t      gen_rtx (UNSPEC, SImode, gen_rtvec (1, orig), 0)));\n+\t  pic_ref\n+\t    = gen_rtx_MEM (Pmode,\n+\t\t\t   gen_rtx_LO_SUM (Pmode, reg,\n+\t\t\t\t\t   gen_rtx_UNSPEC (SImode,\n+\t\t\t\t\t\t\t   gen_rtvec (1, orig),\n+\t\t\t\t\t\t\t   0)));\n \t}\n       else\n-\tpic_ref = gen_rtx (MEM, Pmode,\n-\t\t\t   gen_rtx (PLUS, Pmode, pic_offset_table_rtx, orig));\n+\tpic_ref = gen_rtx_MEM (Pmode,\n+\t\t\t       gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t     pic_offset_table_rtx, orig));\n       current_function_uses_pic_offset_table = 1;\n       RTX_UNCHANGING_P (pic_ref) = 1;\n       emit_move_insn (reg, pic_ref);\n@@ -649,7 +653,7 @@ legitimize_pic_address (orig, mode, reg)\n \t    return plus_constant_for_output (base, INTVAL (orig));\n \t  orig = force_reg (Pmode, orig);\n \t}\n-      pic_ref = gen_rtx (PLUS, Pmode, base, orig);\n+      pic_ref = gen_rtx_PLUS (Pmode, base, orig);\n       /* Likewise, should we set special REG_NOTEs here?  */\n     }\n   return pic_ref;\n@@ -727,7 +731,7 @@ hppa_legitimize_address (x, oldx, mode)\n       && GET_CODE (XEXP (x, 1)) == SYMBOL_REF)\n     {\n       rtx reg = force_reg (SImode, XEXP (x, 1));\n-      return force_reg (SImode, gen_rtx (PLUS, SImode, reg, XEXP (x, 0)));\n+      return force_reg (SImode, gen_rtx_PLUS (SImode, reg, XEXP (x, 0)));\n     }\n \n   /* Note we must reject symbols which represent function addresses\n@@ -759,17 +763,16 @@ hppa_legitimize_address (x, oldx, mode)\n       if (! VAL_14_BITS_P (newoffset)\n \t  && GET_CODE (XEXP (x, 0)) == SYMBOL_REF)\n \t{\n-\t  rtx const_part = gen_rtx (CONST, VOIDmode,\n-\t\t\t\t    gen_rtx (PLUS, Pmode,\n-\t\t\t\t\t     XEXP (x, 0),\n-\t\t\t\t\t     GEN_INT (newoffset)));\n+\t  rtx const_part\n+\t    = gen_rtx_CONST (VOIDmode, gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t     XEXP (x, 0),\n+\t\t\t\t\t\t     GEN_INT (newoffset)));\n \t  rtx tmp_reg\n \t    = force_reg (Pmode,\n-\t\t\t gen_rtx (HIGH, Pmode, const_part));\n+\t\t\t gen_rtx_HIGH (Pmode, const_part));\n \t  ptr_reg\n \t    = force_reg (Pmode,\n-\t\t\t gen_rtx (LO_SUM, Pmode,\n-\t\t\t\t  tmp_reg, const_part));\n+\t\t\t gen_rtx_LO_SUM (Pmode, tmp_reg, const_part));\n \t}\n       else\n \t{\n@@ -779,9 +782,9 @@ hppa_legitimize_address (x, oldx, mode)\n \t    int_part = GEN_INT (newoffset);\n \n \t  ptr_reg = force_reg (Pmode,\n-\t\t\t       gen_rtx (PLUS, Pmode,\n-\t\t\t\t\tforce_reg (Pmode, XEXP (x, 0)),\n-\t\t\t\t\tint_part));\n+\t\t\t       gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t     force_reg (Pmode, XEXP (x, 0)),\n+\t\t\t\t\t     int_part));\n \t}\n       return plus_constant (ptr_reg, offset - newoffset);\n     }\n@@ -806,10 +809,10 @@ hppa_legitimize_address (x, oldx, mode)\n       if (GET_CODE (reg2) != REG)\n         reg2 = force_reg (Pmode, force_operand (reg2, 0));\n \n-      return force_reg (Pmode, gen_rtx (PLUS, Pmode,\n-\t\t\t\t\tgen_rtx (MULT, Pmode,\n-\t\t\t\t\t\t reg2, GEN_INT (val)),\n-\t\t\t\t\treg1));\n+      return force_reg (Pmode, gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t     gen_rtx_MULT (Pmode, reg2,\n+\t\t\t\t\t\t           GEN_INT (val)),\n+\t\t\t\t\t     reg1));\n     }\n \n   /* Similarly for (plus (plus (mult (a) (shadd_constant)) (b)) (c)).\n@@ -848,11 +851,11 @@ hppa_legitimize_address (x, oldx, mode)\n \t{\n \t  base = reg1;\n \t  orig_base = XEXP (XEXP (x, 0), 1);\n-\t  idx = gen_rtx (PLUS, Pmode,\n-\t\t\t gen_rtx (MULT, Pmode,\n-\t\t\t\t  XEXP (XEXP (XEXP (x, 0), 0), 0),\n-\t\t\t\t  XEXP (XEXP (XEXP (x, 0), 0), 1)),\n-\t\t\t XEXP (x, 1));\n+\t  idx = gen_rtx_PLUS (Pmode,\n+\t\t\t      gen_rtx_MULT (Pmode,\n+\t\t\t\t\t    XEXP (XEXP (XEXP (x, 0), 0), 0),\n+\t\t\t\t\t    XEXP (XEXP (XEXP (x, 0), 0), 1)),\n+\t\t\t      XEXP (x, 1));\n \t}\n       else if (GET_CODE (reg2) == REG\n \t       && REGNO_POINTER_FLAG (REGNO (reg2)))\n@@ -880,13 +883,14 @@ hppa_legitimize_address (x, oldx, mode)\n \t  if (GET_CODE (reg1) != REG)\n \t    reg1 = force_reg (Pmode, force_operand (reg1, 0));\n \n-\t  reg1 = force_reg (Pmode, gen_rtx (PLUS, Pmode, reg1, GEN_INT (val)));\n+\t  reg1 = force_reg (Pmode, gen_rtx_PLUS (Pmode, reg1, GEN_INT (val)));\n \n \t  /* We can now generate a simple scaled indexed address.  */\n-\t  return force_reg (Pmode, gen_rtx (PLUS, Pmode,\n-\t\t\t\t\t    gen_rtx (MULT, Pmode, reg1,\n-\t\t\t\t\t\t     XEXP (XEXP (idx, 0), 1)),\n-\t\t\t\t\t    base));\n+\t  return force_reg (Pmode,\n+\t\t\t    gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t  gen_rtx_MULT (Pmode, reg1,\n+\t\t\t\t\t\t        XEXP (XEXP (idx, 0), 1)),\n+\t\t\t\t\t  base));\n \t}\n \n       /* If B + C is still a valid base register, then add them.  */\n@@ -897,16 +901,16 @@ hppa_legitimize_address (x, oldx, mode)\n \t  int val = INTVAL (XEXP (XEXP (idx, 0), 1));\n \t  rtx reg1, reg2;\n \n-\t  reg1 = force_reg (Pmode, gen_rtx (PLUS, Pmode, base, XEXP (idx, 1)));\n+\t  reg1 = force_reg (Pmode, gen_rtx_PLUS (Pmode, base, XEXP (idx, 1)));\n \n \t  reg2 = XEXP (XEXP (idx, 0), 0);\n \t  if (GET_CODE (reg2) != CONST_INT)\n \t    reg2 = force_reg (Pmode, force_operand (reg2, 0));\n \n-\t  return force_reg (Pmode, gen_rtx (PLUS, Pmode,\n-\t\t\t\t\t    gen_rtx (MULT, Pmode,\n-\t\t\t\t\t\t     reg2, GEN_INT (val)),\n-\t\t\t\t\t    reg1));\n+\t  return force_reg (Pmode, gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t         gen_rtx_MULT (Pmode, reg2,\n+\t\t\t\t\t\t\t       GEN_INT (val)),\n+\t\t\t\t\t\t reg1));\n \t}\n \n       /* Get the index into a register, then add the base + index and\n@@ -922,13 +926,14 @@ hppa_legitimize_address (x, oldx, mode)\n       if (GET_CODE (reg2) != REG)\n \treg2 = force_reg (Pmode, force_operand (reg2, 0));\n \n-      reg1 = force_reg (Pmode, gen_rtx (PLUS, Pmode,\n-\t\t\t\t\tgen_rtx (MULT, Pmode, reg1,\n-\t\t\t\t\t\t XEXP (XEXP (idx, 0), 1)),\n-\t\t\t\t\treg2));\n+      reg1 = force_reg (Pmode,\n+\t\t\tgen_rtx_PLUS (Pmode,\n+\t\t\t\t      gen_rtx_MULT (Pmode, reg1,\n+\t\t\t\t\t\t    XEXP (XEXP (idx, 0), 1)),\n+\t\t\t\t      reg2));\n \n       /* Add the result to our base register and return.  */\n-      return force_reg (Pmode, gen_rtx (PLUS, Pmode, base, reg1));\n+      return force_reg (Pmode, gen_rtx_PLUS (Pmode, base, reg1));\n       \n     }\n \n@@ -987,9 +992,10 @@ hppa_legitimize_address (x, oldx, mode)\n \t      if (GET_CODE (reg2) != REG)\n \t        reg2 = force_reg (Pmode, force_operand (reg2, 0));\n \n-\t      return force_reg (Pmode, gen_rtx (PLUS, Pmode,\n-\t\t\t\t\t\tgen_rtx (MULT, Pmode,\n-\t\t\t\t\t\t\t reg2, GEN_INT (val)),\n+\t      return force_reg (Pmode,\n+\t\t\t\tgen_rtx_PLUS (Pmode,\n+\t\t\t\t\t      gen_rtx_MULT (Pmode, reg2,\n+\t\t\t\t\t\t\t    GEN_INT (val)),\n \t\t\t\t\t\treg1));\n \t    }\n \t  else if ((mode == DFmode || mode == SFmode)\n@@ -1006,13 +1012,14 @@ hppa_legitimize_address (x, oldx, mode)\n \t      regx2 = XEXP (XEXP (x, 0), 0);\n \t      if (GET_CODE (regx2) != REG)\n \t\tregx2 = force_reg (Pmode, force_operand (regx2, 0));\n-\t      regx2 = force_reg (Pmode, gen_rtx (GET_CODE (y), Pmode,\n-\t\t\t\t\t\t regx2, regx1));\n+\t      regx2 = force_reg (Pmode, gen_rtx_fmt_ee (GET_CODE (y), Pmode,\n+\t\t\t\t\t\t\tregx2, regx1));\n \t      return force_reg (Pmode,\n-\t\t\t\tgen_rtx (PLUS, Pmode,\n-\t\t\t\t\t gen_rtx (MULT, Pmode, regx2,\n-\t\t\t\t\t\t  XEXP (XEXP (x, 0), 1)),\n-\t\t\t\t\t force_reg (Pmode, XEXP (y, 0))));\n+\t\t\t\tgen_rtx_PLUS (Pmode,\n+\t\t\t\t\t      gen_rtx_MULT (Pmode, regx2,\n+\t\t\t\t\t\t            XEXP (XEXP (x, 0),\n+\t\t\t\t\t\t\t    1)),\n+\t\t\t\t\t      force_reg (Pmode, XEXP (y, 0))));\n \t    }\n \t  else if (GET_CODE (XEXP (y, 1)) == CONST_INT\n \t\t   && INTVAL (XEXP (y, 1)) >= -4096\n@@ -1030,8 +1037,9 @@ hppa_legitimize_address (x, oldx, mode)\n \t      regy1 = force_reg (Pmode, force_operand (XEXP (y, 0), 0));\n \t      regy2 = force_reg (Pmode, force_operand (XEXP (y, 1), 0));\n \t      regx1 = force_reg (Pmode,\n-\t\t\t\t gen_rtx (GET_CODE (y), Pmode, regx1, regy2));\n-\t      return force_reg (Pmode, gen_rtx (PLUS, Pmode, regx1, regy1));\n+\t\t\t\t gen_rtx_fmt_ee (GET_CODE (y), Pmode,\n+\t\t\t\t\t\t regx1, regy2));\n+\t      return force_reg (Pmode, gen_rtx_PLUS (Pmode, regx1, regy1));\n \t    }\n \t}\n     }\n@@ -1100,11 +1108,11 @@ emit_move_sequence (operands, mode, scratch_reg)\n   if (reload_in_progress && GET_CODE (operand0) == MEM\n       && ((tem = find_replacement (&XEXP (operand0, 0)))\n \t  != XEXP (operand0, 0)))\n-    operand0 = gen_rtx (MEM, GET_MODE (operand0), tem);\n+    operand0 = gen_rtx_MEM (GET_MODE (operand0), tem);\n   if (reload_in_progress && GET_CODE (operand1) == MEM\n       && ((tem = find_replacement (&XEXP (operand1, 0)))\n \t  != XEXP (operand1, 0)))\n-    operand1 = gen_rtx (MEM, GET_MODE (operand1), tem);\n+    operand1 = gen_rtx_MEM (GET_MODE (operand1), tem);\n \n   /* Handle secondary reloads for loads/stores of FP registers from\n      REG+D addresses where D does not fit in 5 bits, including \n@@ -1120,22 +1128,22 @@ emit_move_sequence (operands, mode, scratch_reg)\n       if (GET_CODE (operand1) == SUBREG)\n \toperand1 = XEXP (operand1, 0);\n \n-      scratch_reg = gen_rtx (REG, SImode, REGNO (scratch_reg));\n+      scratch_reg = gen_rtx_REG (SImode, REGNO (scratch_reg));\n \n       /* D might not fit in 14 bits either; for such cases load D into\n \t scratch reg.  */\n       if (!memory_address_p (SImode, XEXP (operand1, 0)))\n \t{\n \t  emit_move_insn (scratch_reg, XEXP (XEXP (operand1, 0), 1));\n-\t  emit_move_insn (scratch_reg, gen_rtx (GET_CODE (XEXP (operand1, 0)),\n-\t\t\t\t\t\tSImode,\n-\t\t\t\t\t\tXEXP (XEXP (operand1, 0), 0),\n-\t\t\t\t\t\tscratch_reg));\n+\t  emit_move_insn (scratch_reg, gen_rtx_fmt_ee (GET_CODE (XEXP (operand1, 0)),\n+\t\t\t\t\t\t       SImode,\n+\t\t\t\t\t\t       XEXP (XEXP (operand1, 0), 0),\n+\t\t\t\t\t\t       scratch_reg));\n \t}\n       else\n \temit_move_insn (scratch_reg, XEXP (operand1, 0));\n-      emit_insn (gen_rtx (SET, VOIDmode, operand0, gen_rtx (MEM, mode,\n-\t\t\t\t\t\t\t    scratch_reg)));\n+      emit_insn (gen_rtx_SET (VOIDmode, operand0, gen_rtx_MEM (mode,\n+\t\t\t\t\t\t\t       scratch_reg)));\n       return 1;\n     }\n   else if (fp_reg_operand (operand1, mode)\n@@ -1149,21 +1157,23 @@ emit_move_sequence (operands, mode, scratch_reg)\n       if (GET_CODE (operand0) == SUBREG)\n \toperand0 = XEXP (operand0, 0);\n \n-      scratch_reg = gen_rtx (REG, SImode, REGNO (scratch_reg));\n+      scratch_reg = gen_rtx_REG (SImode, REGNO (scratch_reg));\n       /* D might not fit in 14 bits either; for such cases load D into\n \t scratch reg.  */\n       if (!memory_address_p (SImode, XEXP (operand0, 0)))\n \t{\n \t  emit_move_insn (scratch_reg, XEXP (XEXP (operand0, 0), 1));\n-\t  emit_move_insn (scratch_reg, gen_rtx (GET_CODE (XEXP (operand0, 0)),\n-\t\t\t\t\t\tSImode,\n-\t\t\t\t\t\tXEXP (XEXP (operand0, 0), 0),\n-\t\t\t\t\t\tscratch_reg));\n+\t  emit_move_insn (scratch_reg, gen_rtx_fmt_ee (GET_CODE (XEXP (operand0,\n+\t\t\t\t\t\t\t\t        0)),\n+\t\t\t\t\t\t       SImode,\n+\t\t\t\t\t\t       XEXP (XEXP (operand0, 0),\n+\t\t\t\t\t\t\t\t   0),\n+\t\t\t\t\t\t       scratch_reg));\n \t}\n       else\n \temit_move_insn (scratch_reg, XEXP (operand0, 0));\n-      emit_insn (gen_rtx (SET, VOIDmode, gen_rtx (MEM, mode, scratch_reg),\n-\t\t\t  operand1));\n+      emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_MEM (mode, scratch_reg),\n+\t\t\t      operand1));\n       return 1;\n     }\n   /* Handle secondary reloads for loads of FP registers from constant\n@@ -1188,8 +1198,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n       emit_move_sequence (xoperands, Pmode, 0);\n \n       /* Now load the destination register.  */\n-      emit_insn (gen_rtx (SET, mode, operand0,\n-\t\t\t  gen_rtx (MEM, mode, scratch_reg)));\n+      emit_insn (gen_rtx_SET (mode, operand0, gen_rtx_MEM (mode, scratch_reg)));\n       return 1;\n     }\n   /* Handle secondary reloads for SAR.  These occur when trying to load\n@@ -1208,12 +1217,14 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t  && !memory_address_p (SImode, XEXP (operand1, 0)))\n \t{\n \t  emit_move_insn (scratch_reg, XEXP (XEXP (operand1, 0), 1));\t\n-\t  emit_move_insn (scratch_reg, gen_rtx (GET_CODE (XEXP (operand1, 0)),\n-\t\t\t\t\t\tSImode,\n-\t\t\t\t\t\tXEXP (XEXP (operand1, 0), 0),\n-\t\t\t\t\t\tscratch_reg));\n-\t  emit_move_insn (scratch_reg, gen_rtx (MEM, GET_MODE (operand1),\n-\t\t\t\t\t\tscratch_reg));\n+\t  emit_move_insn (scratch_reg, gen_rtx_fmt_ee (GET_CODE (XEXP (operand1,\n+\t\t\t\t\t\t\t\t        0)),\n+\t\t\t\t\t\t       SImode,\n+\t\t\t\t\t\t       XEXP (XEXP (operand1, 0),\n+\t\t\t\t\t\t       0),\n+\t\t\t\t\t\t       scratch_reg));\n+\t  emit_move_insn (scratch_reg, gen_rtx_MEM (GET_MODE (operand1),\n+\t\t\t\t\t\t    scratch_reg));\n \t}\n       else\n \temit_move_insn (scratch_reg, operand1);\n@@ -1232,7 +1243,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t  || GET_CODE (operand1) == MEM)\n \t{\n \t  /* Run this case quickly.  */\n-\t  emit_insn (gen_rtx (SET, VOIDmode, operand0, operand1));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, operand0, operand1));\n \t  return 1;\n \t}\n     }\n@@ -1243,14 +1254,14 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t{\n \t  rtx temp = gen_reg_rtx (DFmode);\n \n-\t  emit_insn (gen_rtx (SET, VOIDmode, temp, operand1));\n-\t  emit_insn (gen_rtx (SET, VOIDmode, operand0, temp));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, temp, operand1));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, operand0, temp));\n \t  return 1;\n \t}\n       if (register_operand (operand1, mode) || operand1 == CONST0_RTX (mode))\n \t{\n \t  /* Run this case quickly.  */\n-\t  emit_insn (gen_rtx (SET, VOIDmode, operand0, operand1));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, operand0, operand1));\n \t  return 1;\n \t}\n       if (! (reload_in_progress || reload_completed))\n@@ -1329,7 +1340,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n \n \t      /* Now load from the memory location into our destination\n \t\t register.  */\n-\t      operands[1] = gen_rtx (MEM, Pmode, operands[0]);\n+\t      operands[1] = gen_rtx_MEM (Pmode, operands[0]);\n \t      emit_move_sequence (operands, mode, scratch_reg);\n \n \t      /* And add back in the constant part.  */\n@@ -1366,7 +1377,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t      else\n \t\t{\n \t\t  operands[1] = legitimize_pic_address (operand1, mode, temp);\n-\t\t  emit_insn (gen_rtx (SET, VOIDmode, operand0, operands[1]));\n+\t\t  emit_insn (gen_rtx_SET (VOIDmode, operand0, operands[1]));\n \t\t}\n \t    }\n \t  /* On the HPPA, references to data space are supposed to use dp,\n@@ -1391,15 +1402,14 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t      if (REGNO (temp) >= FIRST_PSEUDO_REGISTER)\n \t\tREGNO_POINTER_FLAG (REGNO (temp)) = 1;\n \t      if (ishighonly)\n-\t\tset = gen_rtx (SET, mode, operand0, temp);\n+\t\tset = gen_rtx_SET (mode, operand0, temp);\n \t      else\n-\t\tset = gen_rtx (SET, VOIDmode,\n-\t\t\t       operand0,\n-\t\t\t       gen_rtx (LO_SUM, mode, temp, operand1));\n+\t\tset = gen_rtx_SET (VOIDmode, operand0,\n+\t\t\t\t   gen_rtx_LO_SUM (mode, temp, operand1));\n \n-\t      emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t\t  temp,\n-\t\t\t\t  gen_rtx (HIGH, mode, operand1)));\n+\t      emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t      temp,\n+\t\t\t\t      gen_rtx_HIGH (mode, operand1)));\n \t      emit_insn (set);\n \n \t    }\n@@ -1415,9 +1425,9 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t  else\n \t    temp = gen_reg_rtx (mode);\n \n-\t  emit_insn (gen_rtx (SET, VOIDmode, temp,\n-\t\t\t      gen_rtx (HIGH, mode, operand1)));\n-\t  operands[1] = gen_rtx (LO_SUM, mode, temp, operand1);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, temp,\n+\t\t\t\t  gen_rtx_HIGH (mode, operand1)));\n+\t  operands[1] = gen_rtx_LO_SUM (mode, temp, operand1);\n \t}\n     }\n   /* Now have insn-emit do whatever it normally does.  */\n@@ -1629,7 +1639,7 @@ output_move_double (operands)\n       rtx addr = XEXP (operands[0], 0);\n       if (GET_CODE (addr) == POST_INC || GET_CODE (addr) == POST_DEC)\n \t{\n-\t  rtx high_reg = gen_rtx (SUBREG, SImode, operands[1], 0);\n+\t  rtx high_reg = gen_rtx_SUBREG (SImode, operands[1], 0);\n \n \t  operands[0] = XEXP (addr, 0);\n \t  if (GET_CODE (operands[1]) != REG || GET_CODE (operands[0]) != REG)\n@@ -1649,7 +1659,7 @@ output_move_double (operands)\n \t}\n       else if (GET_CODE (addr) == PRE_INC || GET_CODE (addr) == PRE_DEC)\n \t{\n-\t  rtx high_reg = gen_rtx (SUBREG, SImode, operands[1], 0);\n+\t  rtx high_reg = gen_rtx_SUBREG (SImode, operands[1], 0);\n \n \t  operands[0] = XEXP (addr, 0);\n \t  if (GET_CODE (operands[1]) != REG || GET_CODE (operands[0]) != REG)\n@@ -1676,7 +1686,7 @@ output_move_double (operands)\n       rtx addr = XEXP (operands[1], 0);\n       if (GET_CODE (addr) == POST_INC || GET_CODE (addr) == POST_DEC)\n \t{\n-\t  rtx high_reg = gen_rtx (SUBREG, SImode, operands[0], 0);\n+\t  rtx high_reg = gen_rtx_SUBREG (SImode, operands[0], 0);\n \n \t  operands[1] = XEXP (addr, 0);\n \t  if (GET_CODE (operands[0]) != REG || GET_CODE (operands[1]) != REG)\n@@ -1703,7 +1713,7 @@ output_move_double (operands)\n \t}\n       else if (GET_CODE (addr) == PRE_INC || GET_CODE (addr) == PRE_DEC)\n \t{\n-\t  rtx high_reg = gen_rtx (SUBREG, SImode, operands[0], 0);\n+\t  rtx high_reg = gen_rtx_SUBREG (SImode, operands[0], 0);\n \n \t  operands[1] = XEXP (addr, 0);\n \t  if (GET_CODE (operands[0]) != REG || GET_CODE (operands[1]) != REG)\n@@ -1731,7 +1741,7 @@ output_move_double (operands)\n       else if (GET_CODE (addr) == PLUS\n \t       && GET_CODE (XEXP (addr, 0)) == MULT)\n \t{\n-\t  rtx high_reg = gen_rtx (SUBREG, SImode, operands[0], 0);\n+\t  rtx high_reg = gen_rtx_SUBREG (SImode, operands[0], 0);\n \n \t  if (!reg_overlap_mentioned_p (high_reg, addr))\n \t    {\n@@ -1776,14 +1786,14 @@ output_move_double (operands)\n      operands in OPERANDS to be suitable for the low-numbered word.  */\n \n   if (optype0 == REGOP)\n-    latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+    latehalf[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   else if (optype0 == OFFSOP)\n     latehalf[0] = adj_offsettable_operand (operands[0], 4);\n   else\n     latehalf[0] = operands[0];\n \n   if (optype1 == REGOP)\n-    latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+    latehalf[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n   else if (optype1 == OFFSOP)\n     latehalf[1] = adj_offsettable_operand (operands[1], 4);\n   else if (optype1 == CNSTOP)\n@@ -1874,7 +1884,7 @@ output_fp_move_double (operands)\n       if (GET_CODE (operands[0]) == REG)\n \t{\n \t  rtx xoperands[2];\n-\t  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\t  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n \t  xoperands[0] = operands[0];\n \t  output_asm_insn (\"copy %%r0,%0\\n\\tcopy %%r0,%1\", xoperands);\n \t}\n@@ -2420,22 +2430,22 @@ store_reg (reg, disp, base)\n {\n   if (VAL_14_BITS_P (disp))\n     {\n-      emit_move_insn (gen_rtx (MEM, SImode,\n-\t\t\t       gen_rtx (PLUS, SImode,\n-\t\t\t\t        gen_rtx (REG, SImode, base),\n-\t\t\t\t        GEN_INT (disp))),\n-\t\t      gen_rtx (REG, SImode, reg));\n+      emit_move_insn (gen_rtx_MEM (SImode,\n+\t\t\t\t   gen_rtx_PLUS (SImode,\n+\t\t\t\t\t\t gen_rtx_REG (SImode, base),\n+\t\t\t\t\t\t GEN_INT (disp))),\n+\t\t\t\t   gen_rtx_REG (SImode, reg));\n     }\n   else\n     {\n-      emit_insn (gen_add_high_const (gen_rtx (REG, SImode, 1),\n-\t\t\t\t     gen_rtx (REG, SImode, base),\n+      emit_insn (gen_add_high_const (gen_rtx_REG (SImode, 1),\n+\t\t\t\t     gen_rtx_REG (SImode, base),\n \t\t\t\t     GEN_INT (disp)));\n-      emit_move_insn (gen_rtx (MEM, SImode,\n-\t\t\t       gen_rtx (LO_SUM, SImode,\n-\t\t\t\t\tgen_rtx (REG, SImode, 1),\n-\t\t\t\t\tGEN_INT (disp))),\n-\t\t      gen_rtx (REG, SImode, reg));\n+      emit_move_insn (gen_rtx_MEM (SImode,\n+\t\t\t\t   gen_rtx_LO_SUM (SImode,\n+\t\t\t\t\t\t   gen_rtx_REG (SImode, 1),\n+\t\t\t\t\t\t   GEN_INT (disp))),\n+\t\t      gen_rtx_REG (SImode, reg));\n     }\n }\n \n@@ -2450,22 +2460,22 @@ load_reg (reg, disp, base)\n {\n   if (VAL_14_BITS_P (disp))\n     {\n-      emit_move_insn (gen_rtx (REG, SImode, reg),\n-\t\t      gen_rtx (MEM, SImode,\n-\t\t\t       gen_rtx (PLUS, SImode,\n-\t\t\t\t        gen_rtx (REG, SImode, base),\n-\t\t\t\t        GEN_INT (disp))));\n+      emit_move_insn (gen_rtx_REG (SImode, reg),\n+\t\t      gen_rtx_MEM (SImode,\n+\t\t\t\t   gen_rtx_PLUS (SImode,\n+\t\t\t\t\t\t gen_rtx_REG (SImode, base),\n+\t\t\t\t            GEN_INT (disp))));\n     }\n   else\n     {\n-      emit_insn (gen_add_high_const (gen_rtx (REG, SImode, 1),\n-\t\t\t\t     gen_rtx (REG, SImode, base),\n+      emit_insn (gen_add_high_const (gen_rtx_REG (SImode, 1),\n+\t\t\t\t     gen_rtx_REG (SImode, base),\n \t\t\t\t     GEN_INT (disp)));\n-      emit_move_insn (gen_rtx (REG, SImode, reg),\n-\t\t      gen_rtx (MEM, SImode,\n-\t\t\t       gen_rtx (LO_SUM, SImode,\n-\t\t\t\t\tgen_rtx (REG, SImode, 1),\n-\t\t\t\t\tGEN_INT (disp))));\n+      emit_move_insn (gen_rtx_REG (SImode, reg),\n+\t\t      gen_rtx_MEM (SImode,\n+\t\t\t\t   gen_rtx_LO_SUM (SImode,\n+\t\t\t\t\t\t   gen_rtx_REG (SImode, 1),\n+\t\t\t\t\t\t   GEN_INT (disp))));\n     }\n }\n \n@@ -2480,20 +2490,20 @@ set_reg_plus_d(reg, base, disp)\n {\n   if (VAL_14_BITS_P (disp))\n     {\n-      emit_move_insn (gen_rtx (REG, SImode, reg),\n-\t\t      gen_rtx (PLUS, SImode,\n-\t\t\t       gen_rtx (REG, SImode, base),\n-\t\t\t       GEN_INT (disp)));\n+      emit_move_insn (gen_rtx_REG (SImode, reg),\n+\t\t      gen_rtx_PLUS (SImode,\n+\t\t\t\t    gen_rtx_REG (SImode, base),\n+\t\t\t\t    GEN_INT (disp)));\n     }\n   else\n     {\n-      emit_insn (gen_add_high_const (gen_rtx (REG, SImode, 1),\n-\t\t\t\t     gen_rtx (REG, SImode, base),\n+      emit_insn (gen_add_high_const (gen_rtx_REG (SImode, 1),\n+\t\t\t\t     gen_rtx_REG (SImode, base),\n \t\t\t\t     GEN_INT (disp)));\n-      emit_move_insn (gen_rtx (REG, SImode, reg),\n-\t\t      gen_rtx (LO_SUM, SImode,\n-\t\t\t\t\tgen_rtx (REG, SImode, 1),\n-\t\t\t\t\tGEN_INT (disp)));\n+      emit_move_insn (gen_rtx_REG (SImode, reg),\n+\t\t      gen_rtx_LO_SUM (SImode,\n+\t\t\t\t      gen_rtx_REG (SImode, 1),\n+\t\t\t\t       GEN_INT (disp)));\n     }\n }\n \n@@ -2635,7 +2645,7 @@ hppa_expand_prologue()\n   actual_fsize = compute_frame_size (size, &save_fregs);\n \n   /* Compute a few things we will use often.  */\n-  tmpreg = gen_rtx (REG, SImode, 1);\n+  tmpreg = gen_rtx_REG (SImode, 1);\n   size_rtx = GEN_INT (actual_fsize);\n \n   /* Handle out of line prologues and epilogues.  */\n@@ -2698,16 +2708,16 @@ hppa_expand_prologue()\n       if (inline_insn_count > outline_insn_count)\n \t{\n \t  /* Put the local_fisze into %r19.  */\n-\t  operands[0] = gen_rtx (REG, SImode, 19);\n+\t  operands[0] = gen_rtx_REG (SImode, 19);\n \t  operands[1] = GEN_INT (local_fsize);\n \t  emit_move_insn (operands[0], operands[1]);\n \n \t  /* Put the stack size into %r21.  */\n-\t  operands[0] = gen_rtx (REG, SImode, 21);\n+\t  operands[0] = gen_rtx_REG (SImode, 21);\n \t  operands[1] = size_rtx;\n \t  emit_move_insn (operands[0], operands[1]);\n \n-\t  operands[0] = gen_rtx (REG, SImode, 22);\n+\t  operands[0] = gen_rtx_REG (SImode, 22);\n \t  operands[1] = GEN_INT (saves);\n \t  emit_move_insn (operands[0], operands[1]);\n \n@@ -2814,8 +2824,7 @@ hppa_expand_prologue()\n \t place to get the expected results.   sprintf here is just to\n \t put something in the name.  */\n       sprintf(hp_profile_label_name, \"LP$%04d\", -1);\n-      hp_profile_label_rtx = gen_rtx (SYMBOL_REF, SImode,\n-\t\t\t\t      hp_profile_label_name);\n+      hp_profile_label_rtx = gen_rtx_SYMBOL_REF (SImode, hp_profile_label_name);\n       if (current_function_returns_struct)\n \tstore_reg (STRUCT_VALUE_REGNUM, - 12 - offsetadj, basereg);\n \n@@ -2827,10 +2836,10 @@ hppa_expand_prologue()\n \t    pc_offset += VAL_14_BITS_P (arg_offset) ? 4 : 8;\n \t  }\n \n-      emit_move_insn (gen_rtx (REG, SImode, 26), gen_rtx (REG, SImode, 2));\n-      emit_move_insn (tmpreg, gen_rtx (HIGH, SImode, hp_profile_label_rtx));\n-      emit_move_insn (gen_rtx (REG, SImode, 24),\n-\t\t      gen_rtx (LO_SUM, SImode, tmpreg, hp_profile_label_rtx));\n+      emit_move_insn (gen_rtx_REG (SImode, 26), gen_rtx_REG (SImode, 2));\n+      emit_move_insn (tmpreg, gen_rtx_HIGH (SImode, hp_profile_label_rtx));\n+      emit_move_insn (gen_rtx_REG (SImode, 24),\n+\t\t      gen_rtx_LO_SUM (SImode, tmpreg, hp_profile_label_rtx));\n       /* %r25 is set from within the output pattern.  */\n       emit_insn (gen_call_profiler (GEN_INT (- pc_offset - 20)));\n \n@@ -2872,7 +2881,7 @@ hppa_expand_prologue()\n \t      {\n \t\tmerge_sp_adjust_with_store = 0;\n \t        emit_insn (gen_post_stwm (stack_pointer_rtx,\n-\t\t\t\t\t  gen_rtx (REG, SImode, i),\n+\t\t\t\t\t  gen_rtx_REG (SImode, i),\n \t\t\t\t\t  GEN_INT (-offset)));\n \t      }\n \t    else\n@@ -2907,9 +2916,9 @@ hppa_expand_prologue()\n \t{\n \t  if (regs_ever_live[i] || regs_ever_live[i + 1])\n \t    {\n-\t      emit_move_insn (gen_rtx (MEM, DFmode,\n-\t\t\t\t       gen_rtx (POST_INC, DFmode, tmpreg)),\n-\t\t\t      gen_rtx (REG, DFmode, i));\n+\t      emit_move_insn (gen_rtx_MEM (DFmode,\n+\t\t\t\t           gen_rtx_POST_INC (DFmode, tmpreg)),\n+\t\t\t      gen_rtx_REG (DFmode, i));\n \t      fr_saved++;\n \t    }\n \t}\n@@ -2933,8 +2942,8 @@ hppa_expand_prologue()\n      Avoid this if the callee saved register wasn't used (these are\n      leaf functions).  */\n   if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM_SAVED])\n-    emit_move_insn (gen_rtx (REG, SImode, PIC_OFFSET_TABLE_REGNUM_SAVED),\n-\t\t    gen_rtx (REG, SImode, PIC_OFFSET_TABLE_REGNUM));\n+    emit_move_insn (gen_rtx_REG (SImode, PIC_OFFSET_TABLE_REGNUM_SAVED),\n+\t\t    gen_rtx_REG (SImode, PIC_OFFSET_TABLE_REGNUM));\n }\n \n \n@@ -3006,16 +3015,16 @@ hppa_expand_epilogue ()\n       emit_insn (gen_blockage ());\n \n       /* Put the local_fisze into %r19.  */\n-      operands[0] = gen_rtx (REG, SImode, 19);\n+      operands[0] = gen_rtx_REG (SImode, 19);\n       operands[1] = GEN_INT (local_fsize);\n       emit_move_insn (operands[0], operands[1]);\n \n       /* Put the stack size into %r21.  */\n-      operands[0] = gen_rtx (REG, SImode, 21);\n+      operands[0] = gen_rtx_REG (SImode, 21);\n       operands[1] = GEN_INT (actual_fsize);\n       emit_move_insn (operands[0], operands[1]);\n \n-      operands[0] = gen_rtx (REG, SImode, 22);\n+      operands[0] = gen_rtx_REG (SImode, 22);\n       operands[1] = GEN_INT (saves);\n       emit_move_insn (operands[0], operands[1]);\n \n@@ -3025,7 +3034,7 @@ hppa_expand_epilogue ()\n     }\n \n   /* We will use this often.  */\n-  tmpreg = gen_rtx (REG, SImode, 1);\n+  tmpreg = gen_rtx_REG (SImode, 1);\n \n   /* Try to restore RP early to avoid load/use interlocks when\n      RP gets used in the return (bv) instruction.  This appears to still\n@@ -3087,9 +3096,9 @@ hppa_expand_epilogue ()\n \t{\n \t  if (regs_ever_live[i] || regs_ever_live[i + 1])\n \t    {\n-\t      emit_move_insn (gen_rtx (REG, DFmode, i),\n-\t\t\t      gen_rtx (MEM, DFmode,\n-\t\t\t\t       gen_rtx (POST_INC, DFmode, tmpreg)));\n+\t      emit_move_insn (gen_rtx_REG (DFmode, i),\n+\t\t\t      gen_rtx_MEM (DFmode,\n+\t\t\t\t           gen_rtx_POST_INC (DFmode, tmpreg)));\n \t    }\n \t}\n     }\n@@ -3131,8 +3140,7 @@ hppa_expand_epilogue ()\n     }\n   /* If we were deferring a callee register restore, do it now.  */\n   else if (! frame_pointer_needed  && merge_sp_adjust_with_load)\n-    emit_insn (gen_pre_ldwm (gen_rtx (REG, SImode,\n-\t\t\t\t      merge_sp_adjust_with_load),\n+    emit_insn (gen_pre_ldwm (gen_rtx_REG (SImode, merge_sp_adjust_with_load),\n \t\t\t     stack_pointer_rtx,\n \t\t\t     GEN_INT (- actual_fsize)));\n   else if (actual_fsize != 0)\n@@ -3188,9 +3196,9 @@ return_addr_rtx (count, frameaddr)\n      privilege level from the two low order bits of the return address\n      pointer here so that ins will point to the start of the first\n      instruction that would have been executed if we returned.  */\n-  ins = copy_to_reg (gen_rtx (AND, Pmode,\n-\t\t\t      copy_to_reg (gen_rtx (MEM, Pmode, saved_rp)),\n-\t\t\t      MASK_RETURN_ADDR));\n+  ins = copy_to_reg (gen_rtx_AND (Pmode,\n+\t\t\t\t  copy_to_reg (gen_rtx_MEM (Pmode, saved_rp)),\n+\t\t\t\t  MASK_RETURN_ADDR));\n   label = gen_label_rtx ();\n \n   /* Check the instruction stream at the normal return address for the\n@@ -3204,22 +3212,22 @@ return_addr_rtx (count, frameaddr)\n      If it is an export stub, than our return address is really in\n      -24[frameaddr].  */\n \n-  emit_cmp_insn (gen_rtx (MEM, SImode, ins),\n+  emit_cmp_insn (gen_rtx_MEM (SImode, ins),\n \t\t GEN_INT (0x4bc23fd1),\n \t\t NE, NULL_RTX, SImode, 1, 0);\n   emit_jump_insn (gen_bne (label));\n \n-  emit_cmp_insn (gen_rtx (MEM, SImode, plus_constant (ins, 4)),\n+  emit_cmp_insn (gen_rtx_MEM (SImode, plus_constant (ins, 4)),\n \t\t GEN_INT (0x004010a1),\n \t\t NE, NULL_RTX, SImode, 1, 0);\n   emit_jump_insn (gen_bne (label));\n \n-  emit_cmp_insn (gen_rtx (MEM, SImode, plus_constant (ins, 8)),\n+  emit_cmp_insn (gen_rtx_MEM (SImode, plus_constant (ins, 8)),\n \t\t GEN_INT (0x00011820),\n \t\t NE, NULL_RTX, SImode, 1, 0);\n   emit_jump_insn (gen_bne (label));\n \n-  emit_cmp_insn (gen_rtx (MEM, SImode, plus_constant (ins, 12)),\n+  emit_cmp_insn (gen_rtx_MEM (SImode, plus_constant (ins, 12)),\n \t\t GEN_INT (0xe0400002),\n \t\t NE, NULL_RTX, SImode, 1, 0);\n \n@@ -3236,7 +3244,7 @@ return_addr_rtx (count, frameaddr)\n   emit_move_insn (saved_rp, plus_constant (frameaddr, -6 * UNITS_PER_WORD));\n \n   emit_label (label);\n-  return gen_rtx (MEM, Pmode, memory_address (Pmode, saved_rp));\n+  return gen_rtx_MEM (Pmode, memory_address (Pmode, saved_rp));\n }\n \n /* This is only valid once reload has completed because it depends on\n@@ -3261,13 +3269,14 @@ emit_bcond_fp (code, operand0)\n      enum rtx_code code;\n      rtx operand0;\n {\n-  emit_jump_insn (gen_rtx (SET, VOIDmode, pc_rtx,\n-\t\t\t   gen_rtx (IF_THEN_ELSE, VOIDmode,\n-\t\t\t\t    gen_rtx (code, VOIDmode,\n-\t\t\t\t\t     gen_rtx (REG, CCFPmode, 0),\n-\t\t\t\t\t     const0_rtx),\n-\t\t\t\t    gen_rtx (LABEL_REF, VOIDmode, operand0),\n-\t\t\t\t    pc_rtx)));\n+  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n+\t\t\t       gen_rtx_IF_THEN_ELSE (VOIDmode,\n+\t\t\t\t\t\t     gen_rtx_fmt_ee (code,\n+\t\t\t\t\t\t\t      VOIDmode,\n+\t\t\t\t\t\t\t      gen_rtx_REG (CCFPmode, 0),\n+\t\t\t\t\t\t\t      const0_rtx),\n+\t\t\t\t\t\t     gen_rtx_LABEL_REF (VOIDmode, operand0),\n+\t\t\t\t\t\t     pc_rtx)));\n \n }\n \n@@ -3276,8 +3285,8 @@ gen_cmp_fp (code, operand0, operand1)\n      enum rtx_code code;\n      rtx operand0, operand1;\n {\n-  return gen_rtx (SET, VOIDmode, gen_rtx (REG, CCFPmode, 0),\n-\t\t  gen_rtx (code, CCFPmode, operand0, operand1));\n+  return gen_rtx_SET (VOIDmode, gen_rtx_REG (CCFPmode, 0),\n+\t\t      gen_rtx_fmt_ee (code, CCFPmode, operand0, operand1));\n }\n \n /* Adjust the cost of a scheduling dependency.  Return the new cost of\n@@ -3980,8 +3989,8 @@ output_deferred_plabels (file)\n   for (i = 0; i < n_deferred_plabels; i++)\n     {\n       ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (deferred_plabels[i].internal_label));\n-      assemble_integer (gen_rtx (SYMBOL_REF, VOIDmode,\n-\t\t\t\t deferred_plabels[i].name), 4, 1);\n+      assemble_integer (gen_rtx_SYMBOL_REF (VOIDmode,\n+\t\t\t\t\t    deferred_plabels[i].name), 4, 1);\n     }\n }\n \n@@ -4018,7 +4027,7 @@ output_mul_insn (unsignedp, insn)\n      rtx insn;\n {\n   import_milli (mulI);\n-  return output_millicode_call (insn, gen_rtx (SYMBOL_REF, SImode, \"$$mulI\"));\n+  return output_millicode_call (insn, gen_rtx_SYMBOL_REF (SImode, \"$$mulI\"));\n }\n \n /* Emit the rtl for doing a division by a constant. */\n@@ -4054,19 +4063,20 @@ emit_hpdiv_const (operands, unsignedp)\n       && INTVAL (operands[2]) < 16\n       && magic_milli[INTVAL (operands[2])])\n     {\n-      emit_move_insn ( gen_rtx (REG, SImode, 26), operands[1]);\n+      emit_move_insn (gen_rtx_REG (SImode, 26), operands[1]);\n       emit\n \t(gen_rtx\n \t (PARALLEL, VOIDmode,\n-\t  gen_rtvec (5, gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, 29),\n-\t\t\t\t gen_rtx (unsignedp ? UDIV : DIV, SImode,\n-\t\t\t\t\t  gen_rtx (REG, SImode, 26),\n-\t\t\t\t\t  operands[2])),\n-\t\t     gen_rtx (CLOBBER, VOIDmode, operands[3]),\n-\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 26)),\n-\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 25)),\n-\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 31)))));\n-      emit_move_insn (operands[0], gen_rtx (REG, SImode, 29));\n+\t  gen_rtvec (5, gen_rtx_SET (VOIDmode, gen_rtx_REG (SImode, 29),\n+\t\t\t\t     gen_rtx_fmt_ee (unsignedp ? UDIV : DIV,\n+\t\t\t\t\t\t     SImode,\n+\t\t\t\t\t\t     gen_rtx_REG (SImode, 26),\n+\t\t\t\t\t\t     operands[2])),\n+\t\t     gen_rtx_CLOBBER (VOIDmode, operands[3]),\n+\t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, 26)),\n+\t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, 25)),\n+\t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, 31)))));\n+      emit_move_insn (operands[0], gen_rtx_REG (SImode, 29));\n       return 1;\n     }\n   return 0;\n@@ -4098,13 +4108,13 @@ output_div_insn (operands, unsignedp, insn)\n \t{\n \t  sprintf (buf, \"$$divU_%d\", INTVAL (operands[0]));\n \t  return output_millicode_call (insn,\n-\t\t\t\t\tgen_rtx (SYMBOL_REF, SImode, buf));\n+\t\t\t\t\tgen_rtx_SYMBOL_REF (SImode, buf));\n \t}\n       else\n \t{\n \t  sprintf (buf, \"$$divI_%d\", INTVAL (operands[0]));\n \t  return output_millicode_call (insn,\n-\t\t\t\t\tgen_rtx (SYMBOL_REF, SImode, buf));\n+\t\t\t\t\tgen_rtx_SYMBOL_REF (SImode, buf));\n \t}\n     }\n   /* Divisor isn't a special constant. */\n@@ -4114,13 +4124,13 @@ output_div_insn (operands, unsignedp, insn)\n \t{\n \t  import_milli (divU);\n \t  return output_millicode_call (insn,\n-\t\t\t\t\tgen_rtx (SYMBOL_REF, SImode, \"$$divU\"));\n+\t\t\t\t\tgen_rtx_SYMBOL_REF (SImode, \"$$divU\"));\n \t}\n       else\n \t{\n \t  import_milli (divI);\n \t  return output_millicode_call (insn,\n-\t\t\t\t\tgen_rtx (SYMBOL_REF, SImode, \"$$divI\"));\n+\t\t\t\t\tgen_rtx_SYMBOL_REF (SImode, \"$$divI\"));\n \t}\n     }\n }\n@@ -4136,13 +4146,13 @@ output_mod_insn (unsignedp, insn)\n     {\n       import_milli (remU);\n       return output_millicode_call (insn,\n-\t\t\t\t    gen_rtx (SYMBOL_REF, SImode, \"$$remU\"));\n+\t\t\t\t    gen_rtx_SYMBOL_REF (SImode, \"$$remU\"));\n     }\n   else\n     {\n       import_milli (remI);\n       return output_millicode_call (insn,\n-\t\t\t\t    gen_rtx (SYMBOL_REF, SImode, \"$$remI\"));\n+\t\t\t\t    gen_rtx_SYMBOL_REF (SImode, \"$$remI\"));\n     }\n }\n \n@@ -4358,8 +4368,9 @@ hppa_builtin_saveregs (arglist)\n     offset = current_function_arg_offset_rtx;\n \n   /* Store general registers on the stack. */\n-  dest = gen_rtx (MEM, BLKmode,\n-\t\t  plus_constant (current_function_internal_arg_pointer, -16));\n+  dest = gen_rtx_MEM (BLKmode,\n+\t\t      plus_constant (current_function_internal_arg_pointer,\n+\t\t\t\t     -16));\n   move_block_from_reg (23, dest, 4, 4 * UNITS_PER_WORD);\n \n   /* move_block_from_reg will emit code to store the argument registers\n@@ -5294,14 +5305,14 @@ output_call (insn, call_dest)\n \t      if (arg_mode == SFmode)\n \t\t{\n \t\t  xoperands[0] = XEXP (use, 0);\n-\t\t  xoperands[1] = gen_rtx (REG, SImode, 26 - (regno - 32) / 2);\n+\t\t  xoperands[1] = gen_rtx_REG (SImode, 26 - (regno - 32) / 2);\n \t\t  output_asm_insn (\"fstws %0,-16(%%sr0,%%r30)\", xoperands);\n \t\t  output_asm_insn (\"ldw -16(%%sr0,%%r30),%1\", xoperands);\n \t\t}\n \t      else\n \t\t{\n \t\t  xoperands[0] = XEXP (use, 0);\n-\t\t  xoperands[1] = gen_rtx (REG, DImode, 25 - (regno - 34) / 2);\n+\t\t  xoperands[1] = gen_rtx_REG (DImode, 25 - (regno - 34) / 2);\n \t\t  output_asm_insn (\"fstds %0,-16(%%sr0,%%r30)\", xoperands);\n \t\t  output_asm_insn (\"ldw -12(%%sr0,%%r30),%R1\", xoperands);\n \t\t  output_asm_insn (\"ldw -16(%%sr0,%%r30),%1\", xoperands);\n@@ -6151,7 +6162,7 @@ pa_combine_instructions (insns)\n      may be combined with \"floating\" insns.  As the name implies,\n      \"anchor\" instructions don't move, while \"floating\" insns may\n      move around.  */\n-  new = gen_rtx (PARALLEL, VOIDmode, gen_rtvec (2, NULL_RTX, NULL_RTX));\n+  new = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, NULL_RTX, NULL_RTX));\n   new = make_insn_raw (new);\n \n   for (anchor = get_insns (); anchor; anchor = NEXT_INSN (anchor))\n@@ -6286,17 +6297,18 @@ pa_combine_instructions (insns)\n \t\t  || anchor_attr == PA_COMBINE_TYPE_FMPY))\n \t    {\n \t      /* Emit the new instruction and delete the old anchor.  */\n-\t      emit_insn_before (gen_rtx (PARALLEL, VOIDmode,\n-\t\t\t\t\t gen_rtvec (2, PATTERN (anchor),\n-\t\t\t\t\t\t    PATTERN (floater))),\n-\t\t\t\tanchor);\n+\t      emit_insn_before (gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t\t\t  gen_rtvec (2,\n+\t\t\t\t\t\t\t     PATTERN (anchor),\n+\t\t\t\t\t\t\t     PATTERN (floater))),\n+\t\t\t\t\t\t  anchor);\n \t      PUT_CODE (anchor, NOTE);\n \t      NOTE_LINE_NUMBER (anchor) = NOTE_INSN_DELETED;\n \t      NOTE_SOURCE_FILE (anchor) = 0;\n \n \t      /* Emit a special USE insn for FLOATER, then delete\n \t\t the floating insn.  */\n-\t      emit_insn_before (gen_rtx (USE, VOIDmode, floater), floater);\n+\t      emit_insn_before (gen_rtx_USE (VOIDmode, floater), floater);\n \t      delete_insn (floater);\n \n \t      continue;\n@@ -6306,7 +6318,7 @@ pa_combine_instructions (insns)\n \t    {\n \t      rtx temp;\n \t      /* Emit the new_jump instruction and delete the old anchor.  */\n-\t      temp = emit_jump_insn_before (gen_rtx (PARALLEL, VOIDmode,\n+\t      temp = emit_jump_insn_before (gen_rtx_PARALLEL (VOIDmode,\n \t\t\t\t\t      gen_rtvec (2, PATTERN (anchor),\n \t\t\t\t\t\t\t PATTERN (floater))),\n \t\t\t\tanchor);\n@@ -6317,7 +6329,7 @@ pa_combine_instructions (insns)\n \n \t      /* Emit a special USE insn for FLOATER, then delete\n \t\t the floating insn.  */\n-\t      emit_insn_before (gen_rtx (USE, VOIDmode, floater), floater);\n+\t      emit_insn_before (gen_rtx_USE (VOIDmode, floater), floater);\n \t      delete_insn (floater);\n \t      continue;\n \t    }"}, {"sha": "21d817d483db7ad23c79b50ea738e2115951c333", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2c71b764c066471608c85695392c7fb49c7bc7/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2c71b764c066471608c85695392c7fb49c7bc7/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=ad2c71b764c066471608c85695392c7fb49c7bc7", "patch": "@@ -803,7 +803,7 @@ int zdepi_cint_p ();\n \n /* Return the stack location to use for secondary memory needed reloads.  */\n #define SECONDARY_MEMORY_NEEDED_RTX(MODE) \\\n-  gen_rtx (MEM, MODE, gen_rtx (PLUS, Pmode, stack_pointer_rtx, GEN_INT (-16)))\n+  gen_rtx_MEM (MODE, gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (-16)))\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n@@ -909,18 +909,18 @@ int zdepi_cint_p ();\n \n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), ((! TARGET_SOFT_FLOAT\t\t     \\\n-\t\t\t\t       && (TYPE_MODE (VALTYPE) == SFmode ||  \\\n-\t\t\t\t\t   TYPE_MODE (VALTYPE) == DFmode)) ? \\\n-\t\t\t\t      32 : 28))\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), ((! TARGET_SOFT_FLOAT\t\t     \\\n+\t\t\t\t      && (TYPE_MODE (VALTYPE) == SFmode ||  \\\n+\t\t\t\t\t  TYPE_MODE (VALTYPE) == DFmode)) ? \\\n+\t\t\t\t     32 : 28))\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n #define LIBCALL_VALUE(MODE)\t\\\n-  gen_rtx (REG, MODE,\t\t\t\t\t\t\t\\\n-\t   (! TARGET_SOFT_FLOAT\t\t\t\t\t\t\\\n-\t    && ((MODE) == SFmode || (MODE) == DFmode) ? 32 : 28))\n+  gen_rtx_REG (MODE,\t\t\t\t\t\t\t\\\n+\t       (! TARGET_SOFT_FLOAT\t\t\t\t\t\\\n+\t        && ((MODE) == SFmode || (MODE) == DFmode) ? 32 : 28))\n \n /* 1 if N is a possible register number for a function value\n    as seen by the caller.  */\n@@ -1044,7 +1044,7 @@ struct hppa_args {int words, nargs_prototype, indirect; };\n    ? (!TARGET_PORTABLE_RUNTIME || (TYPE) == 0\t\t\t\t\\\n       || !FLOAT_MODE_P (MODE) || TARGET_SOFT_FLOAT\t\t\t\\\n       || (CUM).nargs_prototype > 0)\t\t\t\t\t\\\n-      ? gen_rtx (REG, (MODE),\t\t\t\t\t\t\\\n+      ? gen_rtx_REG ((MODE),\t\t\t\t\t\t\\\n \t\t (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1\t\t\\\n \t\t  ? (((!(CUM).indirect \t\t\t\t\t\\\n \t\t       || TARGET_PORTABLE_RUNTIME)\t\t\t\\\n@@ -1061,17 +1061,17 @@ struct hppa_args {int words, nargs_prototype, indirect; };\n \t\t\t\t\t\t\t      (TYPE))))))\\\n    /* We are calling a non-prototyped function with floating point\t\\\n       arguments using the portable conventions.  */\t\t\t\\\n-   : gen_rtx (PARALLEL, (MODE),\t\t\t\t\t\t\\\n+   : gen_rtx_PARALLEL ((MODE),\t\t\t\t\t\t\\\n \t      gen_rtvec\t\t\t\t\t\t\t\\\n \t      (2,\t\t\t\t\t\t\t\\\n-\t       gen_rtx (EXPR_LIST, VOIDmode,\t\t\t\t\\\n-\t\t\tgen_rtx (REG, (MODE),\t\t\t\t\\\n+\t       gen_rtx_EXPR_LIST (VOIDmode,\t\t\t\t\\\n+\t\t\tgen_rtx_REG ((MODE),\t\t\t\t\\\n \t\t\t\t (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1 \\\n \t\t\t\t  ? ((CUM).words ? 38 : 34)\t\t\\\n \t\t\t\t  : (32 + 2 * (CUM).words))),\t\t\\\n \t\t\tconst0_rtx),\t\t\t\t\t\\\n-\t       gen_rtx (EXPR_LIST, VOIDmode,\t\t\t\t\\\n-\t\t\tgen_rtx (REG, (MODE),\t\t\t\t\\\n+\t       gen_rtx_EXPR_LIST (VOIDmode,\t\t\t\t\\\n+\t\t\tgen_rtx_REG ((MODE),\t\t\t\t\\\n \t\t\t\t (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1 \\\n \t\t\t\t  ? ((CUM).words ? 23 : 25)\t\t\\\n \t\t\t\t  : (27 - (CUM).words -\t\t\t\\\n@@ -1343,9 +1343,9 @@ extern union tree_node *current_function_decl;\n   rtx start_addr, end_addr;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   start_addr = memory_address (Pmode, plus_constant ((TRAMP), 36));\t\\\n-  emit_move_insn (gen_rtx (MEM, Pmode, start_addr), (FNADDR));\t\t\\\n+  emit_move_insn (gen_rtx_MEM (Pmode, start_addr), (FNADDR));\t\t\\\n   start_addr = memory_address (Pmode, plus_constant ((TRAMP), 40));\t\\\n-  emit_move_insn (gen_rtx (MEM, Pmode, start_addr), (CXT));\t\t\\\n+  emit_move_insn (gen_rtx_MEM (Pmode, start_addr), (CXT));\t\t\\\n   /* fdc and fic only use registers for the address to flush,\t\t\\\n      they do not accept integer displacements.  */ \t\t\t\\\n   start_addr = force_reg (SImode, (TRAMP));\t\t\t\t\\"}, {"sha": "ac3062ac283c9a8b1e38d3bfb9fafcf8f649ddb0", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2c71b764c066471608c85695392c7fb49c7bc7/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2c71b764c066471608c85695392c7fb49c7bc7/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=ad2c71b764c066471608c85695392c7fb49c7bc7", "patch": "@@ -808,7 +808,7 @@\n \n   /* operands[1] is currently the result of compare_from_rtx.  We want to\n      emit a compare of the original operands.  */\n-  operands[1] = gen_rtx (code, SImode, hppa_compare_op0, hppa_compare_op1);\n+  operands[1] = gen_rtx_fmt_ee (code, SImode, hppa_compare_op0, hppa_compare_op1);\n   operands[4] = hppa_compare_op0;\n   operands[5] = hppa_compare_op1;\n }\")\n@@ -1316,7 +1316,7 @@\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n-  emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n   DONE;\n }\")\n \n@@ -1331,7 +1331,7 @@\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n-  emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n   DONE;\n }\")\n \n@@ -2190,7 +2190,7 @@\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n-  emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n   DONE;\n }\")\n \n@@ -2205,7 +2205,7 @@\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n-  emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n   DONE;\n }\")\n \n@@ -2341,7 +2341,7 @@\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n-  emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n   DONE;\n }\")\n \n@@ -2356,7 +2356,7 @@\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n-  emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n   DONE;\n }\")\n \n@@ -2495,7 +2495,7 @@\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n-  emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n   DONE;\n }\")\n \n@@ -2510,7 +2510,7 @@\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n-  emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n   DONE;\n }\")\n \n@@ -2937,7 +2937,7 @@\n     }\n   else if (cint_ok_for_move (-intval))\n     {\n-      emit_insn (gen_rtx (SET, VOIDmode, operands[4], GEN_INT (-intval)));\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[4], GEN_INT (-intval)));\n       emit_insn (gen_subsi3 (operands[0], operands[1], operands[4]));\n       DONE;\n     }\n@@ -3019,9 +3019,9 @@\n       operands[1] = force_reg (SImode, operands[1]);\n       operands[2] = force_reg (SImode, operands[2]);\n       emit_insn (gen_umulsidi3 (scratch, operands[1], operands[2]));\n-      emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t  operands[0],\n-\t\t\t  gen_rtx (SUBREG, SImode, scratch, 1)));\n+      emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t      operands[0],\n+\t\t\t      gen_rtx_SUBREG (SImode, scratch, 1)));\n       DONE;\n     }\n   operands[3] = gen_reg_rtx (SImode);\n@@ -4029,7 +4029,7 @@\n   if (TARGET_BIG_SWITCH)\n     {\n       rtx temp = gen_reg_rtx (SImode);\n-      emit_move_insn (temp, gen_rtx (PLUS, SImode, operands[0], operands[0]));\n+      emit_move_insn (temp, gen_rtx_PLUS (SImode, operands[0], operands[0]));\n       operands[0] = temp;\n     }\n   emit_jump_insn (gen_casesi0 (operands[0], operands[3]));\n@@ -4074,7 +4074,7 @@\n     call_insn = emit_call_insn (gen_call_internal_symref (op, operands[1]));\n   else\n     {\n-      rtx tmpreg = gen_rtx (REG, SImode, 22);\n+      rtx tmpreg = gen_rtx_REG (SImode, 22);\n       emit_move_insn (tmpreg, force_reg (SImode, op));\n       call_insn = emit_call_insn (gen_call_internal_reg (operands[1]));\n     }\n@@ -4089,8 +4089,8 @@\n          This will set regs_ever_live for the callee saved register we\n \t stored the PIC register in.  */\n       emit_move_insn (pic_offset_table_rtx,\n-\t\t      gen_rtx (REG, SImode, PIC_OFFSET_TABLE_REGNUM_SAVED));\n-      emit_insn (gen_rtx (USE, VOIDmode, pic_offset_table_rtx));\n+\t\t      gen_rtx_REG (SImode, PIC_OFFSET_TABLE_REGNUM_SAVED));\n+      emit_insn (gen_rtx_USE (VOIDmode, pic_offset_table_rtx));\n \n       /* Gross.  We have to keep the scheduler from moving the restore\n \t of the PIC register away from the call.  SCHED_GROUP_P is\n@@ -4114,7 +4114,7 @@\n   \"*\n {\n   output_arg_descriptor (insn);\n-  return output_call (insn, operands[0], gen_rtx (REG, SImode, 2));\n+  return output_call (insn, operands[0], gen_rtx_REG (SImode, 2));\n }\"\n   [(set_attr \"type\" \"call\")\n    (set (attr \"length\")\n@@ -4231,7 +4231,7 @@\n \t\t\t\t\t\t\t\toperands[2]));\n   else\n     {\n-      rtx tmpreg = gen_rtx (REG, SImode, 22);\n+      rtx tmpreg = gen_rtx_REG (SImode, 22);\n       emit_move_insn (tmpreg, force_reg (SImode, op));\n       call_insn = emit_call_insn (gen_call_value_internal_reg (operands[0],\n \t\t\t\t\t\t\t       operands[2]));\n@@ -4246,8 +4246,8 @@\n          This will set regs_ever_live for the callee saved register we\n \t stored the PIC register in.  */\n       emit_move_insn (pic_offset_table_rtx,\n-\t\t      gen_rtx (REG, SImode, PIC_OFFSET_TABLE_REGNUM_SAVED));\n-      emit_insn (gen_rtx (USE, VOIDmode, pic_offset_table_rtx));\n+\t\t      gen_rtx_REG (SImode, PIC_OFFSET_TABLE_REGNUM_SAVED));\n+      emit_insn (gen_rtx_USE (VOIDmode, pic_offset_table_rtx));\n \n       /* Gross.  We have to keep the scheduler from moving the restore\n \t of the PIC register away from the call.  SCHED_GROUP_P is\n@@ -4273,7 +4273,7 @@\n   \"*\n {\n   output_arg_descriptor (insn);\n-  return output_call (insn, operands[1], gen_rtx (REG, SImode, 2));\n+  return output_call (insn, operands[1], gen_rtx_REG (SImode, 2));\n }\"\n   [(set_attr \"type\" \"call\")\n    (set (attr \"length\")\n@@ -4508,7 +4508,7 @@\n ;; This insn is used for some loop tests, typically loops reversed when\n ;; strength reduction is used.  It is actually created when the instruction\n ;; combination phase combines the special loop test.  Since this insn\n-;; is both a jump insn and has an output, it must deal with it's own\n+;; is both a jump insn and has an output, it must deal with its own\n ;; reloads, hence the `m' constraints.  The `!' constraints direct reload\n ;; to not choose the register alternatives in the event a reload is needed.\n (define_insn \"decrement_and_branch_until_zero\"\n@@ -5112,8 +5112,7 @@\n \n   /* Else call $$sh_func_adrs to extract the function's real add24.  */\n   return output_millicode_call (insn,\n-\t\t\t\tgen_rtx (SYMBOL_REF, SImode,\n-\t\t\t\t\t \\\"$$sh_func_adrs\\\"));\n+\t\t\t\tgen_rtx_SYMBOL_REF (SImode, \\\"$$sh_func_adrs\\\"));\n }\"\n   [(set_attr \"type\" \"multi\")\n    (set (attr \"length\")\n@@ -5159,9 +5158,8 @@\n   /* Load the PIC register from the stack slot (in our caller's\n      frame).  */\n   emit_move_insn (pic_offset_table_rtx,\n-\t\t  gen_rtx (MEM, SImode,\n-\t\t\t   plus_constant (stack_pointer_rtx, -32)));\n-  emit_insn (gen_rtx (USE, VOIDmode, pic_offset_table_rtx));\n+\t\t  gen_rtx_MEM (SImode, plus_constant (stack_pointer_rtx, -32)));\n+  emit_insn (gen_rtx_USE (VOIDmode, pic_offset_table_rtx));\n   emit_insn (gen_blockage ());\n   DONE;\n }\")"}]}