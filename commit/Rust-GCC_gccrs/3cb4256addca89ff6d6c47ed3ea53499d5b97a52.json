{"sha": "3cb4256addca89ff6d6c47ed3ea53499d5b97a52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NiNDI1NmFkZGNhODlmZjZkNmM0N2VkM2VhNTM0OTlkNWI5N2E1Mg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-12-07T12:47:37Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-04-28T09:37:55Z"}, "message": "[Ada] Remove unused subprograms\n\ngcc/ada/\n\n\t* sem_ch3.adb (Analyze_Object_Declaration): Remove dead code.\n\t* ali.ads, ali.adb (Scan_ALI): Remove unused parameters.\n\tRemove unused code related to Xref lines.\n\t(Get_Typeref): Removed, no longer used.", "tree": {"sha": "552b0bd2ec4ec4abf6c20dfc9060a12253b626df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/552b0bd2ec4ec4abf6c20dfc9060a12253b626df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cb4256addca89ff6d6c47ed3ea53499d5b97a52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cb4256addca89ff6d6c47ed3ea53499d5b97a52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cb4256addca89ff6d6c47ed3ea53499d5b97a52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cb4256addca89ff6d6c47ed3ea53499d5b97a52/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce32ccfc25a1b12ff9f42b1d9b6150ea128a26ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce32ccfc25a1b12ff9f42b1d9b6150ea128a26ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce32ccfc25a1b12ff9f42b1d9b6150ea128a26ec"}], "stats": {"total": 513, "additions": 8, "deletions": 505}, "files": [{"sha": "7093766e8d4816d654907218bb8e661696c3ec58", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 7, "deletions": 467, "changes": 474, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb4256addca89ff6d6c47ed3ea53499d5b97a52/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb4256addca89ff6d6c47ed3ea53499d5b97a52/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=3cb4256addca89ff6d6c47ed3ea53499d5b97a52", "patch": "@@ -894,8 +894,6 @@ package body ALI is\n       T                : Text_Buffer_Ptr;\n       Ignore_ED        : Boolean;\n       Err              : Boolean;\n-      Read_Xref        : Boolean := False;\n-      Read_Lines       : String  := \"\";\n       Ignore_Lines     : String  := \"X\";\n       Ignore_Errors    : Boolean := False;\n       Directly_Scanned : Boolean := False) return ALI_Id\n@@ -907,7 +905,8 @@ package body ALI is\n       NS_Found  : Boolean;\n       First_Arg : Arg_Id;\n \n-      Ignore : array (Character range 'A' .. 'Z') of Boolean;\n+      Ignore : array (Character range 'A' .. 'Z') of Boolean :=\n+                 (others => False);\n       --  Ignore (X) is set to True if lines starting with X are to\n       --  be ignored by Scan_ALI and skipped, and False if the lines\n       --  are to be read and processed.\n@@ -1006,16 +1005,6 @@ package body ALI is\n       function Nextc return Character;\n       --  Return current character without modifying pointer P\n \n-      procedure Get_Typeref\n-        (Current_File_Num : Sdep_Id;\n-         Ref             : out Tref_Kind;\n-         File_Num        : out Sdep_Id;\n-         Line            : out Nat;\n-         Ref_Type        : out Character;\n-         Col             : out Nat;\n-         Standard_Entity : out Name_Id);\n-      --  Parse the definition of a typeref (<...>, {...} or (...))\n-\n       procedure Scan_Invocation_Graph_Line;\n       --  Parse a single line that encodes a piece of the invocation graph\n \n@@ -1423,94 +1412,6 @@ package body ALI is\n          return T;\n       end Get_Stamp;\n \n-      -----------------\n-      -- Get_Typeref --\n-      -----------------\n-\n-      procedure Get_Typeref\n-        (Current_File_Num : Sdep_Id;\n-         Ref              : out Tref_Kind;\n-         File_Num         : out Sdep_Id;\n-         Line             : out Nat;\n-         Ref_Type         : out Character;\n-         Col              : out Nat;\n-         Standard_Entity  : out Name_Id)\n-      is\n-         N : Nat;\n-      begin\n-         case Nextc is\n-            when '<'    => Ref := Tref_Derived;\n-            when '('    => Ref := Tref_Access;\n-            when '{'    => Ref := Tref_Type;\n-            when others => Ref := Tref_None;\n-         end case;\n-\n-         --  Case of typeref field present\n-\n-         if Ref /= Tref_None then\n-            P := P + 1; -- skip opening bracket\n-\n-            if Nextc in 'a' .. 'z' then\n-               File_Num        := No_Sdep_Id;\n-               Line            := 0;\n-               Ref_Type        := ' ';\n-               Col             := 0;\n-               Standard_Entity := Get_Name (Ignore_Spaces => True);\n-            else\n-               N := Get_Nat;\n-\n-               if Nextc = '|' then\n-                  File_Num := Sdep_Id (N + Nat (First_Sdep_Entry) - 1);\n-                  P := P + 1;\n-                  N := Get_Nat;\n-               else\n-                  File_Num := Current_File_Num;\n-               end if;\n-\n-               Line            := N;\n-               Ref_Type        := Getc;\n-               Col             := Get_Nat;\n-               Standard_Entity := No_Name;\n-            end if;\n-\n-            --  ??? Temporary workaround for nested generics case:\n-            --     4i4 Directories{1|4I9[4|6[3|3]]}\n-            --  See C918-002\n-\n-            declare\n-               Nested_Brackets : Natural := 0;\n-\n-            begin\n-               loop\n-                  case Nextc is\n-                     when '[' =>\n-                        Nested_Brackets := Nested_Brackets + 1;\n-                     when ']' =>\n-                        Nested_Brackets := Nested_Brackets - 1;\n-                     when others =>\n-                        if Nested_Brackets = 0 then\n-                           exit;\n-                        end if;\n-                  end case;\n-\n-                  Skipc;\n-               end loop;\n-            end;\n-\n-            P := P + 1; -- skip closing bracket\n-            Skip_Space;\n-\n-         --  No typeref entry present\n-\n-         else\n-            File_Num        := No_Sdep_Id;\n-            Line            := 0;\n-            Ref_Type        := ' ';\n-            Col             := 0;\n-            Standard_Entity := No_Name;\n-         end if;\n-      end Get_Typeref;\n-\n       ----------\n       -- Getc --\n       ----------\n@@ -1836,31 +1737,10 @@ package body ALI is\n    begin\n       First_Sdep_Entry := Sdep.Last + 1;\n \n-      --  Acquire lines to be ignored\n-\n-      if Read_Xref then\n-         Ignore :=\n-           ('T' | 'U' | 'W' | 'Y' | 'Z' | 'D' | 'X' => False, others => True);\n-\n-      --  Read_Lines parameter given\n-\n-      elsif Read_Lines /= \"\" then\n-         Ignore := ('U' => False, others => True);\n-\n-         for J in Read_Lines'Range loop\n-            Ignore (Read_Lines (J)) := False;\n-         end loop;\n-\n-      --  Process Ignore_Lines parameter\n-\n-      else\n-         Ignore := (others => False);\n-\n-         for J in Ignore_Lines'Range loop\n-            pragma Assert (Ignore_Lines (J) /= 'U');\n-            Ignore (Ignore_Lines (J)) := True;\n-         end loop;\n-      end if;\n+      for J in Ignore_Lines'Range loop\n+         pragma Assert (Ignore_Lines (J) /= 'U');\n+         Ignore (Ignore_Lines (J)) := True;\n+      end loop;\n \n       --  Setup ALI Table entry with appropriate defaults\n \n@@ -3465,347 +3345,7 @@ package body ALI is\n          Fatal_Error;\n       end if;\n \n-      --  If we are ignoring Xref sections we are done (we ignore all\n-      --  remaining lines since only xref related lines follow X).\n-\n-      if Ignore ('X') and then not Debug_Flag_X then\n-         return Id;\n-      end if;\n-\n-      --  Loop through Xref sections\n-\n-      X_Loop : loop\n-         Check_Unknown_Line;\n-         exit X_Loop when C /= 'X';\n-\n-         --  Make new entry in section table\n-\n-         Xref_Section.Increment_Last;\n-\n-         Read_Refs_For_One_File : declare\n-            XS : Xref_Section_Record renames\n-                   Xref_Section.Table (Xref_Section.Last);\n-\n-            Current_File_Num : Sdep_Id;\n-            --  Keeps track of the current file number (changed by nn|)\n-\n-         begin\n-            XS.File_Num     := Sdep_Id (Get_Nat + Nat (First_Sdep_Entry) - 1);\n-            XS.File_Name    := Get_File_Name;\n-            XS.First_Entity := Xref_Entity.Last + 1;\n-\n-            Current_File_Num := XS.File_Num;\n-\n-            Skip_Space;\n-\n-            Skip_Eol;\n-            C := Nextc;\n-\n-            --  Loop through Xref entities\n-\n-            while C /= 'X' and then C /= EOF loop\n-               Xref_Entity.Increment_Last;\n-\n-               Read_Refs_For_One_Entity : declare\n-                  XE : Xref_Entity_Record renames\n-                         Xref_Entity.Table (Xref_Entity.Last);\n-                  N  : Nat;\n-\n-                  procedure Read_Instantiation_Reference;\n-                  --  Acquire instantiation reference. Caller has checked\n-                  --  that current character is '[' and on return the cursor\n-                  --  is skipped past the corresponding closing ']'.\n-\n-                  ----------------------------------\n-                  -- Read_Instantiation_Reference --\n-                  ----------------------------------\n-\n-                  procedure Read_Instantiation_Reference is\n-                     Local_File_Num : Sdep_Id := Current_File_Num;\n-\n-                  begin\n-                     Xref.Increment_Last;\n-\n-                     declare\n-                        XR : Xref_Record renames Xref.Table (Xref.Last);\n-\n-                     begin\n-                        P := P + 1; -- skip [\n-                        N := Get_Nat;\n-\n-                        if Nextc = '|' then\n-                           XR.File_Num :=\n-                             Sdep_Id (N + Nat (First_Sdep_Entry) - 1);\n-                           Local_File_Num := XR.File_Num;\n-                           P := P + 1;\n-                           N := Get_Nat;\n-\n-                        else\n-                           XR.File_Num := Local_File_Num;\n-                        end if;\n-\n-                        XR.Line  := N;\n-                        XR.Rtype := ' ';\n-                        XR.Col   := 0;\n-\n-                        --  Recursive call for next reference\n-\n-                        if Nextc = '[' then\n-                           pragma Warnings (Off); -- kill recursion warning\n-                           Read_Instantiation_Reference;\n-                           pragma Warnings (On);\n-                        end if;\n-\n-                        --  Skip closing bracket after recursive call\n-\n-                        P := P + 1;\n-                     end;\n-                  end Read_Instantiation_Reference;\n-\n-               --  Start of processing for Read_Refs_For_One_Entity\n-\n-               begin\n-                  XE.Line  := Get_Nat;\n-                  XE.Etype := Getc;\n-                  XE.Col   := Get_Nat;\n-\n-                  case Getc is\n-                     when '*' =>\n-                        XE.Visibility := Global;\n-                     when '+' =>\n-                        XE.Visibility := Static;\n-                     when others =>\n-                        XE.Visibility := Other;\n-                  end case;\n-\n-                  XE.Entity := Get_Name;\n-\n-                  --  Handle the information about generic instantiations\n-\n-                  if Nextc = '[' then\n-                     Skipc; --  Opening '['\n-                     N := Get_Nat;\n-\n-                     if Nextc /= '|' then\n-                        XE.Iref_File_Num := Current_File_Num;\n-                        XE.Iref_Line     := N;\n-                     else\n-                        XE.Iref_File_Num :=\n-                          Sdep_Id (N + Nat (First_Sdep_Entry) - 1);\n-                        Skipc;\n-                        XE.Iref_Line := Get_Nat;\n-                     end if;\n-\n-                     if Getc /= ']' then\n-                        Fatal_Error;\n-                     end if;\n-\n-                  else\n-                     XE.Iref_File_Num := No_Sdep_Id;\n-                     XE.Iref_Line     := 0;\n-                  end if;\n-\n-                  Current_File_Num := XS.File_Num;\n-\n-                  --  Renaming reference is present\n-\n-                  if Nextc = '=' then\n-                     P := P + 1;\n-                     XE.Rref_Line := Get_Nat;\n-\n-                     if Getc /= ':' then\n-                        Fatal_Error;\n-                     end if;\n-\n-                     XE.Rref_Col := Get_Nat;\n-\n-                  --  No renaming reference present\n-\n-                  else\n-                     XE.Rref_Line := 0;\n-                     XE.Rref_Col  := 0;\n-                  end if;\n-\n-                  Skip_Space;\n-\n-                  XE.Oref_File_Num := No_Sdep_Id;\n-                  XE.Tref_File_Num := No_Sdep_Id;\n-                  XE.Tref          := Tref_None;\n-                  XE.First_Xref    := Xref.Last + 1;\n-\n-                  --  Loop to check for additional info present\n-\n-                  loop\n-                     declare\n-                        Ref  : Tref_Kind;\n-                        File : Sdep_Id;\n-                        Line : Nat;\n-                        Typ  : Character;\n-                        Col  : Nat;\n-                        Std  : Name_Id;\n-\n-                     begin\n-                        Get_Typeref\n-                          (Current_File_Num, Ref, File, Line, Typ, Col, Std);\n-                        exit when Ref = Tref_None;\n-\n-                        --  Do we have an overriding procedure?\n-\n-                        if Ref = Tref_Derived and then Typ = 'p' then\n-                           XE.Oref_File_Num := File;\n-                           XE.Oref_Line     := Line;\n-                           XE.Oref_Col      := Col;\n-\n-                        --  Arrays never override anything, and <> points to\n-                        --  the index types instead\n-\n-                        elsif Ref = Tref_Derived and then XE.Etype = 'A' then\n-\n-                           --  Index types are stored in the list of references\n-\n-                           Xref.Increment_Last;\n-\n-                           declare\n-                              XR : Xref_Record renames Xref.Table (Xref.Last);\n-                           begin\n-                              XR.File_Num := File;\n-                              XR.Line     := Line;\n-                              XR.Rtype    := Array_Index_Reference;\n-                              XR.Col      := Col;\n-                              XR.Name     := Std;\n-                           end;\n-\n-                        --  Interfaces are stored in the list of references,\n-                        --  although the parent type itself is stored in XE.\n-                        --  The first interface (when there are only\n-                        --  interfaces) is stored in XE.Tref*)\n-\n-                        elsif Ref = Tref_Derived\n-                          and then Typ = 'R'\n-                          and then XE.Tref_File_Num /= No_Sdep_Id\n-                        then\n-                           Xref.Increment_Last;\n-\n-                           declare\n-                              XR : Xref_Record renames Xref.Table (Xref.Last);\n-                           begin\n-                              XR.File_Num := File;\n-                              XR.Line     := Line;\n-                              XR.Rtype    := Interface_Reference;\n-                              XR.Col      := Col;\n-                              XR.Name     := Std;\n-                           end;\n-\n-                        else\n-                           XE.Tref                 := Ref;\n-                           XE.Tref_File_Num        := File;\n-                           XE.Tref_Line            := Line;\n-                           XE.Tref_Type            := Typ;\n-                           XE.Tref_Col             := Col;\n-                           XE.Tref_Standard_Entity := Std;\n-                        end if;\n-                     end;\n-                  end loop;\n-\n-                  --  Loop through cross-references for this entity\n-\n-                  loop\n-                     Skip_Space;\n-\n-                     if At_Eol then\n-                        Skip_Eol;\n-                        exit when Nextc /= '.';\n-                        P := P + 1;\n-                     end if;\n-\n-                     Xref.Increment_Last;\n-\n-                     declare\n-                        XR : Xref_Record renames Xref.Table (Xref.Last);\n-\n-                     begin\n-                        N := Get_Nat;\n-\n-                        if Nextc = '|' then\n-                           XR.File_Num :=\n-                             Sdep_Id (N + Nat (First_Sdep_Entry) - 1);\n-                           Current_File_Num := XR.File_Num;\n-                           P := P + 1;\n-                           N := Get_Nat;\n-                        else\n-                           XR.File_Num := Current_File_Num;\n-                        end if;\n-\n-                        XR.Line  := N;\n-                        XR.Rtype := Getc;\n-\n-                        --  Imported entities reference as in:\n-                        --    494b<c,__gnat_copy_attribs>25\n-\n-                        if Nextc = '<' then\n-                           Skipc;\n-                           XR.Imported_Lang := Get_Name;\n-\n-                           pragma Assert (Nextc = ',');\n-                           Skipc;\n-\n-                           XR.Imported_Name := Get_Name;\n-\n-                           pragma Assert (Nextc = '>');\n-                           Skipc;\n-\n-                        else\n-                           XR.Imported_Lang := No_Name;\n-                           XR.Imported_Name := No_Name;\n-                        end if;\n-\n-                        XR.Col   := Get_Nat;\n-\n-                        if Nextc = '[' then\n-                           Read_Instantiation_Reference;\n-                        end if;\n-                     end;\n-                  end loop;\n-\n-                  --  Record last cross-reference\n-\n-                  XE.Last_Xref := Xref.Last;\n-                  C := Nextc;\n-\n-               exception\n-                  when Bad_ALI_Format =>\n-\n-                     --  If ignoring errors, then we skip a line with an\n-                     --  unexpected error, and try to continue subsequent\n-                     --  xref lines.\n-\n-                     if Ignore_Errors then\n-                        Xref_Entity.Decrement_Last;\n-                        Skip_Line;\n-                        C := Nextc;\n-\n-                     --  Otherwise, we reraise the fatal exception\n-\n-                     else\n-                        raise;\n-                     end if;\n-               end Read_Refs_For_One_Entity;\n-            end loop;\n-\n-            --  Record last entity\n-\n-            XS.Last_Entity := Xref_Entity.Last;\n-         end Read_Refs_For_One_File;\n-\n-         C := Getc;\n-      end loop X_Loop;\n-\n-      --  Here after dealing with xref sections\n-\n-      --  Ignore remaining lines, which belong to an additional section of the\n-      --  ALI file not considered here (like SCO or SPARK information).\n-\n-      Check_Unknown_Line;\n+      --  This ALI parser does not care about Xref lines.\n \n       return Id;\n "}, {"sha": "90bc94a0f49f5dae05a6c044ffbc9cb3dd116912", "filename": "gcc/ada/ali.ads", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb4256addca89ff6d6c47ed3ea53499d5b97a52/gcc%2Fada%2Fali.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb4256addca89ff6d6c47ed3ea53499d5b97a52/gcc%2Fada%2Fali.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.ads?ref=3cb4256addca89ff6d6c47ed3ea53499d5b97a52", "patch": "@@ -1391,8 +1391,6 @@ package ALI is\n       T                : Text_Buffer_Ptr;\n       Ignore_ED        : Boolean;\n       Err              : Boolean;\n-      Read_Xref        : Boolean := False;\n-      Read_Lines       : String  := \"\";\n       Ignore_Lines     : String  := \"X\";\n       Ignore_Errors    : Boolean := False;\n       Directly_Scanned : Boolean := False) return ALI_Id;\n@@ -1417,24 +1415,6 @@ package ALI is\n    --    tables will not be filled in this case. It is not possible\n    --    to ignore U (unit) lines, they are always read.\n    --\n-   --    Read_Lines requests that Scan_ALI process only lines that start\n-   --    with one of the given characters. The corresponding data in the\n-   --    ALI file for any characters not given in the list will not be\n-   --    set. The default value of the null string indicates that all\n-   --    lines should be read (unless Ignore_Lines is specified). U\n-   --    (unit) lines are always read regardless of the value of this\n-   --    parameter.\n-   --\n-   --    Note: either Ignore_Lines or Read_Lines should be non-null, but not\n-   --    both. If both are provided then only the Read_Lines value is used,\n-   --    and the Ignore_Lines parameter is ignored.\n-   --\n-   --    Read_Xref is set True to read and acquire the cross-reference\n-   --    information. If Read_XREF is set to True, then the effect is to ignore\n-   --    all lines other than U, W, D and X lines and the Ignore_Lines and\n-   --    Read_Lines parameters are ignored (i.e. the use of True for Read_XREF\n-   --    is equivalent to specifying an argument of \"UWDX\" for Read_Lines.\n-   --\n    --    Ignore_Errors is normally False. If it is set True, then Scan_ALI\n    --    will do its best to scan through a file and extract all information\n    --    it can, even if there are errors. In this case Err is only set if"}, {"sha": "d796c47454c2f44c29824a673f34dcd1fe02cbbd", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb4256addca89ff6d6c47ed3ea53499d5b97a52/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb4256addca89ff6d6c47ed3ea53499d5b97a52/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=3cb4256addca89ff6d6c47ed3ea53499d5b97a52", "patch": "@@ -4164,27 +4164,10 @@ package body Sem_Ch3 is\n          Set_Related_Array_Object (Base_Type (T), Id);\n       end if;\n \n-      --  Special checks for protected objects not at library level\n+      --  Check for protected objects not at library level\n \n       if Has_Protected (T) and then not Is_Library_Level_Entity (Id) then\n          Check_Restriction (No_Local_Protected_Objects, Id);\n-\n-         --  Protected objects with interrupt handlers must be at library level\n-\n-         --  Ada 2005: This test is not needed (and the corresponding clause\n-         --  in the RM is removed) because accessibility checks are sufficient\n-         --  to make handlers not at the library level illegal.\n-\n-         --  AI05-0303: The AI is in fact a binding interpretation, and thus\n-         --  applies to the '95 version of the language as well.\n-\n-         if Is_Protected_Type (T)\n-           and then Has_Interrupt_Handler (T)\n-           and then Ada_Version < Ada_95\n-         then\n-            Error_Msg_N\n-              (\"interrupt object can only be declared at library level\", Id);\n-         end if;\n       end if;\n \n       --  Check for violation of No_Local_Timing_Events"}]}