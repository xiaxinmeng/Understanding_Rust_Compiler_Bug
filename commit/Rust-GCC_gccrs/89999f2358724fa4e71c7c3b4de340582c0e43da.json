{"sha": "89999f2358724fa4e71c7c3b4de340582c0e43da", "node_id": "C_kwDOANBUbNoAKDg5OTk5ZjIzNTg3MjRmYTRlNzFjN2MzYjRkZTM0MDU4MmMwZTQzZGE", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-28T09:03:56Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-28T09:03:56Z"}, "message": "openmp: Allow optional comma after directive-specifier in C/C++\n\nPreviously we've been allowing that comma only in C++ when in attribute\nform (which was the reason why it has been allowed), but 5.1 allows that\neven in pragma form in C/C++ (with clarifications in 5.2) and 5.2\nalso in Fortran (which this patch doesn't implement).\n\nNote, for directives which take an argument (== unnamed clause),\ncomma is not allowed in between the directive name and the argument,\nlike the directive-1.c testcase shows.\n\n2022-10-28  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/c/\n\t* c-parser.cc (c_parser_omp_all_clauses): Allow optional\n\tcomma before the first clause.\n\t(c_parser_omp_allocate, c_parser_omp_atomic, c_parser_omp_depobj,\n\tc_parser_omp_flush, c_parser_omp_scan_loop_body,\n\tc_parser_omp_ordered, c_finish_omp_declare_variant,\n\tc_parser_omp_declare_target, c_parser_omp_declare_reduction,\n\tc_parser_omp_requires, c_parser_omp_error,\n\tc_parser_omp_assumption_clauses): Likewise.\ngcc/cp/\n\t* parser.cc (cp_parser_omp_all_clauses): Allow optional comma\n\tbefore the first clause even in pragma syntax.\n\t(cp_parser_omp_allocate, cp_parser_omp_atomic, cp_parser_omp_depobj,\n\tcp_parser_omp_flush, cp_parser_omp_scan_loop_body,\n\tcp_parser_omp_ordered, cp_parser_omp_assumption_clauses,\n\tcp_finish_omp_declare_variant, cp_parser_omp_declare_target,\n\tcp_parser_omp_declare_reduction_exprs, cp_parser_omp_requires,\n\tcp_parser_omp_error): Likewise.\ngcc/testsuite/\n\t* c-c++-common/gomp/directive-1.c: New test.\n\t* c-c++-common/gomp/clauses-6.c: New test.\n\t* c-c++-common/gomp/declare-variant-2.c (f75a): Declare.\n\t(f75): Use f75a as variant instead of f1 and don't expect error.\n\t* g++.dg/gomp/clause-4.C (foo): Don't expect error on comma\n\tbefore first clause.\n\t* gcc.dg/gomp/clause-2.c (foo): Likewise.", "tree": {"sha": "86a55ecdb10d3428be8409deeace51bb8fd268f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86a55ecdb10d3428be8409deeace51bb8fd268f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89999f2358724fa4e71c7c3b4de340582c0e43da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89999f2358724fa4e71c7c3b4de340582c0e43da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89999f2358724fa4e71c7c3b4de340582c0e43da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89999f2358724fa4e71c7c3b4de340582c0e43da/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "826df6d0cc706bf83cdb228b43f9b4890e8b2fbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/826df6d0cc706bf83cdb228b43f9b4890e8b2fbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/826df6d0cc706bf83cdb228b43f9b4890e8b2fbd"}], "stats": {"total": 776, "additions": 687, "deletions": 89}, "files": [{"sha": "4d1dcb1b15948f492f76aa2c7681f3ec4c3176ca", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89999f2358724fa4e71c7c3b4de340582c0e43da/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89999f2358724fa4e71c7c3b4de340582c0e43da/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=89999f2358724fa4e71c7c3b4de340582c0e43da", "patch": "@@ -17460,7 +17460,7 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n       if (nested && c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n \tbreak;\n \n-      if (!first)\n+      if (!first || nested != 2)\n \t{\n \t  if (c_parser_next_token_is (parser, CPP_COMMA))\n \t    c_parser_consume_token (parser);\n@@ -18547,6 +18547,9 @@ c_parser_omp_allocate (location_t loc, c_parser *parser)\n {\n   tree allocator = NULL_TREE;\n   tree nl = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ALLOCATE, NULL_TREE);\n+  if (c_parser_next_token_is (parser, CPP_COMMA)\n+      && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n+    c_parser_consume_token (parser);\n   if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n       matching_parens parens;\n@@ -18685,7 +18688,6 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n   bool structured_block = false;\n   bool swapped = false;\n   bool non_lvalue_p;\n-  bool first = true;\n   tree clauses = NULL_TREE;\n   bool capture = false;\n   bool compare = false;\n@@ -18696,13 +18698,10 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n \n   while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n     {\n-      if (!first\n-\t  && c_parser_next_token_is (parser, CPP_COMMA)\n+      if (c_parser_next_token_is (parser, CPP_COMMA)\n \t  && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n \tc_parser_consume_token (parser);\n \n-      first = false;\n-\n       if (c_parser_next_token_is (parser, CPP_NAME))\n \t{\n \t  const char *p\n@@ -19646,6 +19645,8 @@ c_parser_omp_depobj (c_parser *parser)\n   parens.skip_until_found_close (parser);\n   tree clause = NULL_TREE;\n   enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_INVALID;\n+  if (c_parser_next_token_is (parser, CPP_COMMA))\n+    c_parser_consume_token (parser);\n   location_t c_loc = c_parser_peek_token (parser)->location;\n   if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n@@ -19722,6 +19723,9 @@ c_parser_omp_flush (c_parser *parser)\n   location_t loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_pragma (parser);\n   enum memmodel mo = MEMMODEL_LAST;\n+  if (c_parser_next_token_is (parser, CPP_COMMA)\n+      && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n+    c_parser_consume_token (parser);\n   if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n       const char *p\n@@ -19814,6 +19818,9 @@ c_parser_omp_scan_loop_body (c_parser *parser, bool open_brace_parsed)\n \n       c_parser_consume_pragma (parser);\n \n+      if (c_parser_next_token_is (parser, CPP_COMMA))\n+\tc_parser_consume_token (parser);\n+\n       if (c_parser_next_token_is (parser, CPP_NAME))\n \t{\n \t  const char *p\n@@ -20597,9 +20604,14 @@ c_parser_omp_ordered (c_parser *parser, enum pragma_context context,\n       return false;\n     }\n \n-  if (c_parser_next_token_is (parser, CPP_NAME))\n+  int n = 1;\n+  if (c_parser_next_token_is (parser, CPP_COMMA))\n+    n = 2;\n+\n+  if (c_parser_peek_nth_token (parser, n)->type == CPP_NAME)\n     {\n-      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+      const char *p\n+\t= IDENTIFIER_POINTER (c_parser_peek_nth_token (parser, n)->value);\n \n       if (!strcmp (\"depend\", p) || !strcmp (\"doacross\", p))\n \t{\n@@ -22472,6 +22484,10 @@ c_finish_omp_declare_variant (c_parser *parser, tree fndecl, tree parms)\n \n   parens.require_close (parser);\n \n+  if (c_parser_next_token_is (parser, CPP_COMMA)\n+      && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n+    c_parser_consume_token (parser);\n+\n   const char *clause = \"\";\n   location_t match_loc = c_parser_peek_token (parser)->location;\n   if (c_parser_next_token_is (parser, CPP_NAME))\n@@ -22641,7 +22657,9 @@ c_parser_omp_declare_target (c_parser *parser)\n   tree clauses = NULL_TREE;\n   int device_type = 0;\n   bool only_device_type = true;\n-  if (c_parser_next_token_is (parser, CPP_NAME))\n+  if (c_parser_next_token_is (parser, CPP_NAME)\n+      || (c_parser_next_token_is (parser, CPP_COMMA)\n+\t  && c_parser_peek_2nd_token (parser)->type == CPP_NAME))\n     clauses = c_parser_omp_all_clauses (parser, OMP_DECLARE_TARGET_CLAUSE_MASK,\n \t\t\t\t\t\"#pragma omp declare target\");\n   else if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n@@ -23062,10 +23080,14 @@ c_parser_omp_declare_reduction (c_parser *parser, enum pragma_context context)\n       initializer.set_error ();\n       if (!c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n \tbad = true;\n-      else if (c_parser_next_token_is (parser, CPP_NAME)\n-\t       && strcmp (IDENTIFIER_POINTER\n+      else if (c_parser_next_token_is (parser, CPP_COMMA)\n+\t       && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n+\tc_parser_consume_token (parser);\n+      if (!bad\n+\t  && (c_parser_next_token_is (parser, CPP_NAME)\n+\t      && strcmp (IDENTIFIER_POINTER\n \t\t\t\t(c_parser_peek_token (parser)->value),\n-\t\t\t  \"initializer\") == 0)\n+\t\t\t  \"initializer\") == 0))\n \t{\n \t  c_parser_consume_token (parser);\n \t  pop_scope ();\n@@ -23258,21 +23280,17 @@ c_parser_omp_declare (c_parser *parser, enum pragma_context context)\n static void\n c_parser_omp_requires (c_parser *parser)\n {\n-  bool first = true;\n   enum omp_requires new_req = (enum omp_requires) 0;\n \n   c_parser_consume_pragma (parser);\n \n   location_t loc = c_parser_peek_token (parser)->location;\n   while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n     {\n-      if (!first\n-\t  && c_parser_next_token_is (parser, CPP_COMMA)\n+      if (c_parser_next_token_is (parser, CPP_COMMA)\n \t  && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n \tc_parser_consume_token (parser);\n \n-      first = false;\n-\n       if (c_parser_next_token_is (parser, CPP_NAME))\n \t{\n \t  const char *p\n@@ -23543,21 +23561,17 @@ c_parser_omp_error (c_parser *parser, enum pragma_context context)\n   int at_compilation = -1;\n   int severity_fatal = -1;\n   tree message = NULL_TREE;\n-  bool first = true;\n   bool bad = false;\n   location_t loc = c_parser_peek_token (parser)->location;\n \n   c_parser_consume_pragma (parser);\n \n   while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n     {\n-      if (!first\n-\t  && c_parser_next_token_is (parser, CPP_COMMA)\n+      if (c_parser_next_token_is (parser, CPP_COMMA)\n \t  && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n \tc_parser_consume_token (parser);\n \n-      first = false;\n-\n       if (!c_parser_next_token_is (parser, CPP_NAME))\n \tbreak;\n \n@@ -23713,7 +23727,6 @@ c_parser_omp_error (c_parser *parser, enum pragma_context context)\n static void\n c_parser_omp_assumption_clauses (c_parser *parser, bool is_assume)\n {\n-  bool first = true;\n   bool no_openmp = false;\n   bool no_openmp_routines = false;\n   bool no_parallelism = false;\n@@ -23729,13 +23742,10 @@ c_parser_omp_assumption_clauses (c_parser *parser, bool is_assume)\n \n   while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n     {\n-      if (!first\n-\t  && c_parser_next_token_is (parser, CPP_COMMA)\n+      if (c_parser_next_token_is (parser, CPP_COMMA)\n \t  && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n \tc_parser_consume_token (parser);\n \n-      first = false;\n-\n       if (!c_parser_next_token_is (parser, CPP_NAME))\n \tbreak;\n "}, {"sha": "9bdc60949f406cd640c7680b8fa4c538d38dba78", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 14, "deletions": 59, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89999f2358724fa4e71c7c3b4de340582c0e43da/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89999f2358724fa4e71c7c3b4de340582c0e43da/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=89999f2358724fa4e71c7c3b4de340582c0e43da", "patch": "@@ -40443,12 +40443,7 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n       if (nested && cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n \tbreak;\n \n-      if (!first\n-\t  /* OpenMP 5.1 allows optional comma in between directive-name and\n-\t     clauses everywhere, but as we aren't done with OpenMP 5.0\n-\t     implementation yet, let's allow it for now only in C++11\n-\t     attributes.  */\n-\t  || (parser->lexer->in_omp_attribute_pragma && nested != 2))\n+      if (!first || nested != 2)\n \t{\n \t  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n \t    cp_lexer_consume_token (parser->lexer);\n@@ -40881,9 +40876,7 @@ cp_parser_omp_allocate (cp_parser *parser, cp_token *pragma_tok)\n   location_t loc = pragma_tok->location;\n   tree nl = cp_parser_omp_var_list (parser, OMP_CLAUSE_ALLOCATE, NULL_TREE);\n \n-  /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n-  if (parser->lexer->in_omp_attribute_pragma\n-      && cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n       && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n     cp_lexer_consume_token (parser->lexer);\n \n@@ -41004,7 +40997,6 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n   enum tree_code code = ERROR_MARK, opcode = NOP_EXPR;\n   enum omp_memory_order memory_order = OMP_MEMORY_ORDER_UNSPECIFIED;\n   bool structured_block = false;\n-  bool first = true;\n   tree clauses = NULL_TREE;\n   bool capture = false;\n   bool compare = false;\n@@ -41015,14 +41007,10 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n \n   while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n     {\n-      /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n-      if ((!first || parser->lexer->in_omp_attribute_pragma)\n-\t  && cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n \t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n \tcp_lexer_consume_token (parser->lexer);\n \n-      first = false;\n-\n       if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n \t{\n \t  tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n@@ -41976,11 +41964,9 @@ cp_parser_omp_depobj (cp_parser *parser, cp_token *pragma_tok)\n \n   tree clause = NULL_TREE;\n   enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_INVALID;\n-  location_t c_loc = cp_lexer_peek_token (parser->lexer)->location;\n-  /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n-  if (parser->lexer->in_omp_attribute_pragma\n-      && cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n     cp_lexer_consume_token (parser->lexer);\n+  location_t c_loc = cp_lexer_peek_token (parser->lexer)->location;\n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n       tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n@@ -42063,9 +42049,7 @@ static void\n cp_parser_omp_flush (cp_parser *parser, cp_token *pragma_tok)\n {\n   enum memmodel mo = MEMMODEL_LAST;\n-  /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n-  if (parser->lexer->in_omp_attribute_pragma\n-      && cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n       && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n     cp_lexer_consume_token (parser->lexer);\n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n@@ -42790,8 +42774,7 @@ cp_parser_omp_scan_loop_body (cp_parser *parser)\n \n       cp_lexer_consume_token (parser->lexer);\n \n-      if (parser->lexer->in_omp_attribute_pragma\n-\t  && cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n \tcp_lexer_consume_token (parser->lexer);\n \n       if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n@@ -43593,9 +43576,7 @@ cp_parser_omp_ordered (cp_parser *parser, cp_token *pragma_tok,\n   location_t loc = pragma_tok->location;\n   int n = 1;\n \n-  /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n-  if (parser->lexer->in_omp_attribute_pragma\n-      && cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n     n = 2;\n \n   if (cp_lexer_nth_token_is (parser->lexer, n, CPP_NAME))\n@@ -45949,7 +45930,6 @@ static void\n cp_parser_omp_assumption_clauses (cp_parser *parser, cp_token *pragma_tok,\n \t\t\t\t  bool is_assume)\n {\n-  bool first = true;\n   bool no_openmp = false;\n   bool no_openmp_routines = false;\n   bool no_parallelism = false;\n@@ -45965,14 +45945,10 @@ cp_parser_omp_assumption_clauses (cp_parser *parser, cp_token *pragma_tok,\n \n   while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n     {\n-      /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n-      if ((!first || parser->lexer->in_omp_attribute_pragma)\n-\t  && cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n \t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n \tcp_lexer_consume_token (parser->lexer);\n \n-      first = false;\n-\n       if (!cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n \tbreak;\n \n@@ -46209,9 +46185,7 @@ cp_finish_omp_declare_variant (cp_parser *parser, cp_token *pragma_tok,\n   location_t finish_loc = get_finish (varid.get_location ());\n   location_t varid_loc = make_location (caret_loc, start_loc, finish_loc);\n \n-  /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n-  if (parser->lexer->in_omp_attribute_pragma\n-      && cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n       && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n     cp_lexer_consume_token (parser->lexer);\n \n@@ -46287,11 +46261,6 @@ cp_parser_late_parsing_omp_declare_simd (cp_parser *parser, tree attrs)\n       cp_lexer_consume_token (parser->lexer);\n       if (strcmp (kind, \"simd\") == 0)\n \t{\n-\t  /* For now only in C++ attributes, do it always for OpenMP 5.1.\n-\t  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n-\t      && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n-\t    cp_lexer_consume_token (parser->lexer);  */\n-\n \t  cl = cp_parser_omp_all_clauses (parser, OMP_DECLARE_SIMD_CLAUSE_MASK,\n \t\t\t\t\t  \"#pragma omp declare simd\",\n \t\t\t\t\t  pragma_tok);\n@@ -46549,9 +46518,7 @@ cp_parser_omp_declare_target (cp_parser *parser, cp_token *pragma_tok)\n   int device_type = 0;\n   bool only_device_type = true;\n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME)\n-      /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n-      || (parser->lexer->in_omp_attribute_pragma\n-\t  && cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+      || (cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n \t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME)))\n     clauses\n       = cp_parser_omp_all_clauses (parser, OMP_DECLARE_TARGET_CLAUSE_MASK,\n@@ -46801,9 +46768,7 @@ cp_parser_omp_declare_reduction_exprs (tree fndecl, cp_parser *parser)\n   if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n     return false;\n \n-  /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n-  if (parser->lexer->in_omp_attribute_pragma\n-      && cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n       && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n     cp_lexer_consume_token (parser->lexer);\n \n@@ -47235,20 +47200,15 @@ cp_parser_omp_declare (cp_parser *parser, cp_token *pragma_tok,\n static bool\n cp_parser_omp_requires (cp_parser *parser, cp_token *pragma_tok)\n {\n-  bool first = true;\n   enum omp_requires new_req = (enum omp_requires) 0;\n \n   location_t loc = pragma_tok->location;\n   while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n     {\n-      /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n-      if ((!first || parser->lexer->in_omp_attribute_pragma)\n-\t  && cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n \t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n \tcp_lexer_consume_token (parser->lexer);\n \n-      first = false;\n-\n       if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n \t{\n \t  tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n@@ -47402,20 +47362,15 @@ cp_parser_omp_error (cp_parser *parser, cp_token *pragma_tok,\n   int at_compilation = -1;\n   int severity_fatal = -1;\n   tree message = NULL_TREE;\n-  bool first = true;\n   bool bad = false;\n   location_t loc = pragma_tok->location;\n \n   while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n     {\n-      /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n-      if ((!first || parser->lexer->in_omp_attribute_pragma)\n-\t  && cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n \t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n \tcp_lexer_consume_token (parser->lexer);\n \n-      first = false;\n-\n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n \tbreak;\n "}, {"sha": "3502647ffb408d0833cb55a9cce30e4b19b3d41a", "filename": "gcc/testsuite/c-c++-common/gomp/clauses-6.c", "status": "added", "additions": 604, "deletions": 0, "changes": 604, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89999f2358724fa4e71c7c3b4de340582c0e43da/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89999f2358724fa4e71c7c3b4de340582c0e43da/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-6.c?ref=89999f2358724fa4e71c7c3b4de340582c0e43da", "patch": "@@ -0,0 +1,604 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99\" { target c } } */\n+\n+typedef enum omp_allocator_handle_t\n+#if __cplusplus >= 201103L\n+: __UINTPTR_TYPE__\n+#endif\n+{\n+  omp_null_allocator = 0,\n+  omp_default_mem_alloc = 1,\n+  omp_large_cap_mem_alloc = 2,\n+  omp_const_mem_alloc = 3,\n+  omp_high_bw_mem_alloc = 4,\n+  omp_low_lat_mem_alloc = 5,\n+  omp_cgroup_mem_alloc = 6,\n+  omp_pteam_mem_alloc = 7,\n+  omp_thread_mem_alloc = 8,\n+  __omp_allocator_handle_t_max__ = __UINTPTR_MAX__\n+} omp_allocator_handle_t;\n+\n+typedef enum omp_sync_hint_t {\n+omp_sync_hint_none = 0x0,\n+omp_lock_hint_none = omp_sync_hint_none,\n+omp_sync_hint_uncontended = 0x1,\n+omp_lock_hint_uncontended = omp_sync_hint_uncontended,\n+omp_sync_hint_contended = 0x2,\n+omp_lock_hint_contended = omp_sync_hint_contended,\n+omp_sync_hint_nonspeculative = 0x4,\n+omp_lock_hint_nonspeculative = omp_sync_hint_nonspeculative,\n+omp_sync_hint_speculative = 0x8,\n+omp_lock_hint_speculative = omp_sync_hint_speculative\n+} omp_sync_hint_t;\n+  \n+typedef struct __attribute__((__aligned__ (sizeof (void *)))) omp_depend_t {\n+  char __omp_depend_t__[2 * sizeof (void *)];\n+} omp_depend_t;\n+\n+int t;\n+#pragma omp threadprivate (t)\n+\n+#pragma omp declare target\n+int f, l, ll, r, r2;\n+\n+void\n+foo (int d, int m, int i1, int i2, int p, int *idp, int s,\n+     int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q, int ntm)\n+{\n+  #pragma omp distribute parallel for, \\\n+    private (p), firstprivate (f), collapse(1), dist_schedule(static, 16), \\\n+    if (parallel: i2), default(shared), shared(s), reduction(+:r), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), schedule(static, 4), order(concurrent), allocate (omp_default_mem_alloc:f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp distribute parallel for simd, \\\n+    private (p), firstprivate (f), collapse(1), dist_schedule(static, 16), \\\n+    if (parallel: i2), if(simd: i1), default(shared), shared(s), reduction(+:r), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), schedule(static, 4), nontemporal(ntm), \\\n+    safelen(8), simdlen(4), aligned(q: 32), order(concurrent), allocate (omp_default_mem_alloc:f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp distribute simd, \\\n+    private (p), firstprivate (f), collapse(1), dist_schedule(static, 16), \\\n+    safelen(8), simdlen(4), aligned(q: 32), reduction(+:r), if(i1), nontemporal(ntm), \\\n+    order(concurrent), allocate (omp_default_mem_alloc:f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+}\n+\n+void\n+qux (int p)\n+{\n+  #pragma omp loop, bind(teams), order(concurrent), \\\n+    private (p), lastprivate (l), collapse(1), reduction(+:r)\n+  for (l = 0; l < 64; ++l)\n+    ll++;\n+}\n+#pragma omp end declare target\n+\n+void\n+baz (int d, int m, int i1, int i2, int p, int *idp, int s,\n+     int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q, int ntm)\n+{\n+  #pragma omp distribute parallel for, \\\n+    private (p), firstprivate (f), collapse(1), dist_schedule(static, 16), \\\n+    if (parallel: i2), default(shared), shared(s), reduction(+:r), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), schedule(static, 4), copyin(t), allocate (p)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp distribute parallel for, \\\n+    private (p), firstprivate (f), collapse(1), dist_schedule(static, 16), \\\n+    if (parallel: i2), default(shared), shared(s), reduction(+:r), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), schedule(static, 4), order(concurrent), allocate (p)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp distribute parallel for simd, \\\n+    private (p), firstprivate (f), collapse(1), dist_schedule(static, 16), \\\n+    if (parallel: i2), if(simd: i1), default(shared), shared(s), reduction(+:r), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), schedule(static, 4), nontemporal(ntm), \\\n+    safelen(8), simdlen(4), aligned(q: 32), copyin(t), allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp distribute parallel for simd, \\\n+    private (p), firstprivate (f), collapse(1), dist_schedule(static, 16), \\\n+    if (parallel: i2), if(simd: i1), default(shared), shared(s), reduction(+:r), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), schedule(static, 4), nontemporal(ntm), \\\n+    safelen(8), simdlen(4), aligned(q: 32), order(concurrent), allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp distribute simd, \\\n+    private (p), firstprivate (f), collapse(1), dist_schedule(static, 16), \\\n+    safelen(8), simdlen(4), aligned(q: 32), reduction(+:r), if(i1), nontemporal(ntm), \\\n+    order(concurrent), allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp loop, bind(parallel), order(concurrent), \\\n+    private (p), lastprivate (l), collapse(1), reduction(+:r)\n+  for (l = 0; l < 64; ++l)\n+    ll++;\n+}\n+\n+void\n+bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int hda, int s,\n+     int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q, int *dd, int ntm,\n+     int n1, int n2)\n+{\n+  #pragma omp for simd, \\\n+    private (p), firstprivate (f), lastprivate (l), linear (ll:1), reduction(+:r), schedule(static, 4), collapse(1), nowait, \\\n+    safelen(8), simdlen(4), aligned(q: 32), nontemporal(ntm), if(i1), order(concurrent), allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp parallel for, \\\n+    private (p), firstprivate (f), if (parallel: i2), default(shared), shared(s), copyin(t), reduction(+:r), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), linear (ll:1), ordered, schedule(static, 4), collapse(1), allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp parallel for, \\\n+    private (p), firstprivate (f), if (parallel: i2), default(shared), shared(s), copyin(t), reduction(+:r), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), linear (ll:1), schedule(static, 4), collapse(1), order(concurrent), allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp parallel for simd, \\\n+    private (p), firstprivate (f), if (i2), default(shared), shared(s), copyin(t), reduction(+:r), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), linear (ll:1), schedule(static, 4), collapse(1), \\\n+    safelen(8), simdlen(4), aligned(q: 32), nontemporal(ntm), order(concurrent), allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp parallel sections, \\\n+    private (p), firstprivate (f), if (parallel: i2), default(shared), shared(s), copyin(t), reduction(+:r), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), allocate (f)\n+  {\n+    #pragma omp section\n+    {}\n+    #pragma omp section\n+    {}\n+  }\n+  #pragma omp target parallel, \\\n+    device(d), map (tofrom: m), if (target: i1), private (p), firstprivate (f), defaultmap(tofrom: scalar), is_device_ptr (idp), \\\n+    if (parallel: i2), default(shared), shared(s), reduction(+:r), num_threads (nth), proc_bind(spread), \\\n+    nowait, depend(inout: dd[0]), allocate (omp_default_mem_alloc:f), in_reduction(+:r2), has_device_addr(hda)\n+    ;\n+  #pragma omp target parallel for, \\\n+    device(d), map (tofrom: m), if (target: i1), private (p), firstprivate (f), defaultmap(tofrom: scalar), is_device_ptr (idp), \\\n+    if (parallel: i2), default(shared), shared(s), reduction(+:r), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), linear (ll:1), ordered, schedule(static, 4), collapse(1), nowait, depend(inout: dd[0]), \\\n+    allocate (omp_default_mem_alloc:f), in_reduction(+:r2), has_device_addr(hda)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp target parallel for, \\\n+    device(d), map (tofrom: m), if (target: i1), private (p), firstprivate (f), defaultmap(tofrom: scalar), is_device_ptr (idp), \\\n+    if (parallel: i2), default(shared), shared(s), reduction(+:r), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), linear (ll:1), schedule(static, 4), collapse(1), nowait, depend(inout: dd[0]), order(concurrent), \\\n+    allocate (omp_default_mem_alloc:f), in_reduction(+:r2), has_device_addr(hda)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp target parallel for simd, \\\n+    device(d), map (tofrom: m), if (target: i1), private (p), firstprivate (f), defaultmap(tofrom: scalar), is_device_ptr (idp), \\\n+    if (parallel: i2), default(shared), shared(s), reduction(+:r), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), linear (ll:1), schedule(static, 4), collapse(1), \\\n+    safelen(8), simdlen(4), aligned(q: 32), nowait, depend(inout: dd[0]), nontemporal(ntm), if (simd: i3), order(concurrent), \\\n+    allocate (omp_default_mem_alloc:f), in_reduction(+:r2), has_device_addr(hda)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp target teams, \\\n+    device(d), map (tofrom: m), if (target: i1), private (p), firstprivate (f), defaultmap(tofrom: scalar), is_device_ptr (idp), \\\n+    shared(s), default(shared), reduction(+:r), num_teams(nte - 1:nte), thread_limit(tl), nowait depend(inout: dd[0]), \\\n+    allocate (omp_default_mem_alloc:f), in_reduction(+:r2), has_device_addr(hda)\n+    ;\n+  #pragma omp target teams distribute, \\\n+    device(d), map (tofrom: m), if (target: i1), private (p), firstprivate (f), defaultmap(tofrom: scalar), is_device_ptr (idp), \\\n+    shared(s), default(shared), reduction(+:r), num_teams(nte), thread_limit(tl), order(concurrent), \\\n+    collapse(1), dist_schedule(static, 16), nowait, depend(inout: dd[0]), allocate (omp_default_mem_alloc:f), in_reduction(+:r2), \\\n+    has_device_addr(hda)\n+  for (int i = 0; i < 64; i++)\n+    ;\n+  #pragma omp target teams distribute parallel for, \\\n+    device(d), map (tofrom: m), if (target: i1), private (p), firstprivate (f), defaultmap(tofrom: scalar), is_device_ptr (idp), \\\n+    shared(s), default(shared), reduction(+:r), num_teams(nte-1:nte), thread_limit(tl), \\\n+    collapse(1), dist_schedule(static, 16), \\\n+    if (parallel: i2), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), schedule(static, 4), nowait, depend(inout: dd[0]), order(concurrent), \\\n+     allocate (omp_default_mem_alloc:f), in_reduction(+:r2), has_device_addr(hda)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp target teams distribute parallel for simd, \\\n+    device(d), map (tofrom: m), if (target: i1), private (p), firstprivate (f), defaultmap(tofrom: scalar), is_device_ptr (idp), \\\n+    shared(s), default(shared), reduction(+:r), num_teams(nte), thread_limit(tl), \\\n+    collapse(1), dist_schedule(static, 16), \\\n+    if (parallel: i2), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), schedule(static, 4), order(concurrent), \\\n+    safelen(8), simdlen(4), aligned(q: 32), nowait, depend(inout: dd[0]), nontemporal(ntm), if (simd: i3), \\\n+    allocate (omp_default_mem_alloc:f), in_reduction(+:r2), has_device_addr(hda)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp target teams distribute simd, \\\n+    device(d), map (tofrom: m), if (i1), private (p), firstprivate (f), defaultmap(tofrom: scalar), is_device_ptr (idp), \\\n+    shared(s), default(shared), reduction(+:r), num_teams(nte-1:nte), thread_limit(tl), \\\n+    collapse(1), dist_schedule(static, 16), order(concurrent), \\\n+    safelen(8), simdlen(4), aligned(q: 32), nowait depend(inout: dd[0]), nontemporal(ntm), \\\n+    allocate (omp_default_mem_alloc:f), in_reduction(+:r2), has_device_addr(hda)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp target simd, \\\n+    device(d), map (tofrom: m), if (target: i1), private (p), firstprivate (f), defaultmap(tofrom: scalar), is_device_ptr (idp), \\\n+    safelen(8), simdlen(4), lastprivate (l), linear(ll: 1), aligned(q: 32), reduction(+:r), \\\n+    nowait depend(inout: dd[0]), nontemporal(ntm), if(simd:i3), order(concurrent), \\\n+    allocate (omp_default_mem_alloc:f), in_reduction(+:r2), has_device_addr(hda)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp taskgroup, task_reduction(+:r2), allocate (r2)\n+  #pragma omp taskloop simd, \\\n+    private (p), firstprivate (f), lastprivate (l), shared (s), default(shared), grainsize (g), collapse(1), untied, if(taskloop: i1), if(simd: i2), final(fi), mergeable, priority (pp), \\\n+    safelen(8), simdlen(4), linear(ll: 1), aligned(q: 32), reduction(default, +:r), in_reduction(+:r2), nontemporal(ntm), \\\n+    order(concurrent), allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp taskgroup, task_reduction(+:r), allocate (r)\n+  #pragma omp taskloop simd, \\\n+    private (p), firstprivate (f), lastprivate (l), shared (s), default(shared), grainsize (g), collapse(1), untied, if(i1), final(fi), mergeable, nogroup, priority (pp), \\\n+    safelen(8), simdlen(4), linear(ll: 1), aligned(q: 32), in_reduction(+:r), nontemporal(ntm), \\\n+    order(concurrent), allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp taskwait\n+  #pragma omp taskloop simd, \\\n+    private (p), firstprivate (f), lastprivate (l), shared (s), default(shared), num_tasks (nta), collapse(1), if(taskloop: i1), final(fi), priority (pp), \\\n+    safelen(8), simdlen(4), linear(ll: 1), aligned(q: 32), reduction(+:r), if (simd: i3), nontemporal(ntm), \\\n+    order(concurrent), allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp target, nowait, depend(inout: dd[0]), in_reduction(+:r2)\n+  #pragma omp teams distribute, \\\n+    private(p), firstprivate (f), shared(s), default(shared), reduction(+:r), num_teams(nte), thread_limit(tl), \\\n+    collapse(1), dist_schedule(static, 16), allocate (omp_default_mem_alloc: f), order(concurrent)\n+  for (int i = 0; i < 64; i++)\n+    ;\n+  #pragma omp target\n+  #pragma omp teams distribute parallel for, \\\n+    private(p), firstprivate (f), shared(s), default(shared), reduction(+:r), num_teams(nte-1:nte), thread_limit(tl), \\\n+    collapse(1), dist_schedule(static, 16), \\\n+    if (parallel: i2), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), schedule(static, 4), order(concurrent), allocate (omp_default_mem_alloc: f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp target\n+  #pragma omp teams distribute parallel for simd, \\\n+    private(p), firstprivate (f), shared(s), default(shared), reduction(+:r), num_teams(nte), thread_limit(tl), \\\n+    collapse(1), dist_schedule(static, 16), \\\n+    if (parallel: i2), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), schedule(static, 4), order(concurrent), \\\n+    safelen(8), simdlen(4), aligned(q: 32), if (simd: i3), nontemporal(ntm), \\\n+    allocate (omp_default_mem_alloc: f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp target\n+  #pragma omp teams distribute simd, \\\n+    private(p), firstprivate (f), shared(s), default(shared), reduction(+:r), num_teams(nte-1:nte), thread_limit(tl), \\\n+    collapse(1), dist_schedule(static, 16), order(concurrent), \\\n+    safelen(8), simdlen(4), aligned(q: 32), if(i3), nontemporal(ntm), \\\n+    allocate (omp_default_mem_alloc: f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp teams distribute parallel for, \\\n+    private(p), firstprivate (f), shared(s), default(shared), reduction(+:r), num_teams(nte), thread_limit(tl), \\\n+    collapse(1), dist_schedule(static, 16), \\\n+    if (parallel: i2), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), schedule(static, 4), copyin(t), allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp teams distribute parallel for, \\\n+    private(p), firstprivate (f), shared(s), default(shared), reduction(+:r), num_teams(nte-1:nte), thread_limit(tl), \\\n+    collapse(1), dist_schedule(static, 16), order(concurrent), \\\n+    if (parallel: i2), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), schedule(static, 4), allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp teams distribute parallel for simd, \\\n+    private(p), firstprivate (f), shared(s), default(shared), reduction(+:r), num_teams(nte), thread_limit(tl), \\\n+    collapse(1), dist_schedule(static, 16), \\\n+    if (parallel: i2), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), schedule(static, 4), \\\n+    safelen(8), simdlen(4), aligned(q: 32), if (simd: i3), nontemporal(ntm), copyin(t), \\\n+    allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp teams distribute parallel for simd, \\\n+    private(p), firstprivate (f), shared(s), default(shared), reduction(+:r), num_teams(nte-1:nte), thread_limit(tl), \\\n+    collapse(1), dist_schedule(static, 16), \\\n+    if (parallel: i2), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), schedule(static, 4), order(concurrent), \\\n+    safelen(8), simdlen(4), aligned(q: 32), if (simd: i3), nontemporal(ntm), \\\n+    allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp teams distribute simd, \\\n+    private(p), firstprivate (f), shared(s), default(shared), reduction(+:r), num_teams(nte), thread_limit(tl), \\\n+    collapse(1), dist_schedule(static, 16), order(concurrent), \\\n+    safelen(8), simdlen(4), aligned(q: 32), if(i3), nontemporal(ntm), allocate(f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp parallel master, \\\n+    private (p), firstprivate (f), if (parallel: i2), default(shared), shared(s), reduction(+:r), \\\n+    num_threads (nth), proc_bind(spread), copyin(t), allocate (f)\n+    ;\n+  #pragma omp parallel masked, \\\n+    private (p), firstprivate (f), if (parallel: i2), default(shared), shared(s), reduction(+:r), \\\n+    num_threads (nth), proc_bind(spread), copyin(t), allocate (f), filter (d)\n+    ;\n+  #pragma omp taskgroup, task_reduction (+:r2), allocate (r2)\n+  #pragma omp master taskloop, \\\n+    private (p), firstprivate (f), lastprivate (l), shared (s), default(shared), grainsize (g), collapse(1), untied, if(taskloop: i1), final(fi), mergeable, priority (pp), \\\n+    reduction(default, +:r), in_reduction(+:r2), allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp taskgroup, task_reduction (+:r2), allocate (r2)\n+  #pragma omp masked taskloop, \\\n+    private (p), firstprivate (f), lastprivate (l), shared (s), default(shared), grainsize (g), collapse(1), untied, if(taskloop: i1), final(fi), mergeable, priority (pp), \\\n+    reduction(default, +:r), in_reduction(+:r2), allocate (f), filter (d)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp taskgroup, task_reduction (+:r2), allocate (r2)\n+  #pragma omp master taskloop simd, \\\n+    private (p), firstprivate (f), lastprivate (l), shared (s), default(shared), grainsize (g), collapse(1), untied, if(taskloop: i1), if(simd: i2), final(fi), mergeable, priority (pp), \\\n+    safelen(8), simdlen(4), linear(ll: 1), aligned(q: 32), reduction(default, +:r), in_reduction(+:r2), nontemporal(ntm), \\\n+    order(concurrent), allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp taskgroup, task_reduction (+:r2), allocate (r2)\n+  #pragma omp masked taskloop simd, \\\n+    private (p), firstprivate (f), lastprivate (l), shared (s), default(shared), grainsize (g), collapse(1), untied, if(taskloop: i1), if(simd: i2), final(fi), mergeable, priority (pp), \\\n+    safelen(8), simdlen(4), linear(ll: 1), aligned(q: 32), reduction(default, +:r), in_reduction(+:r2), nontemporal(ntm), \\\n+    order(concurrent), allocate (f), filter (d)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp parallel master taskloop, \\\n+    private (p), firstprivate (f), lastprivate (l), shared (s), default(shared), grainsize (g), collapse(1), untied, if(taskloop: i1), final(fi), mergeable, priority (pp), \\\n+    reduction(default, +:r), if (parallel: i2), num_threads (nth), proc_bind(spread), copyin(t), allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp parallel masked taskloop, \\\n+    private (p), firstprivate (f), lastprivate (l), shared (s), default(shared), grainsize (g), collapse(1), untied, if(taskloop: i1), final(fi), mergeable, priority (pp), \\\n+    reduction(default, +:r), if (parallel: i2), num_threads (nth), proc_bind(spread), copyin(t), allocate (f), filter (d)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp parallel master taskloop simd, \\\n+    private (p), firstprivate (f), lastprivate (l), shared (s), default(shared), grainsize (g), collapse(1), untied, if(taskloop: i1), if(simd: i2), final(fi), mergeable, priority (pp), \\\n+    safelen(8), simdlen(4), linear(ll: 1), aligned(q: 32), reduction(default, +:r), nontemporal(ntm), if (parallel: i2), num_threads (nth), proc_bind(spread), copyin(t), \\\n+    order(concurrent), allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp parallel masked taskloop simd, \\\n+    private (p), firstprivate (f), lastprivate (l), shared (s), default(shared), grainsize (g), collapse(1), untied, if(taskloop: i1), if(simd: i2), final(fi), mergeable, priority (pp), \\\n+    safelen(8), simdlen(4), linear(ll: 1), aligned(q: 32), reduction(default, +:r), nontemporal(ntm), if (parallel: i2), num_threads (nth), proc_bind(spread), copyin(t), \\\n+    order(concurrent), allocate (f), filter (d)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp taskgroup, task_reduction (+:r2), allocate (r2)\n+  #pragma omp master taskloop, \\\n+    private (p), firstprivate (f), lastprivate (l), shared (s), default(shared), num_tasks (nta), collapse(1), untied, if(i1), final(fi), mergeable, priority (pp), \\\n+    reduction(default, +:r), in_reduction(+:r2)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp taskgroup, task_reduction (+:r2), allocate (r2)\n+  #pragma omp mastked taskloop, \\\n+    private (p), firstprivate (f), lastprivate (l), shared (s), default(shared), num_tasks (nta), collapse(1), untied, if(i1), final(fi), mergeable, priority (pp), \\\n+    reduction(default, +:r), in_reduction(+:r2), filter (d)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp taskgroup, task_reduction (+:r2), allocate (r2)\n+  #pragma omp master taskloop simd, \\\n+    private (p), firstprivate (f), lastprivate (l), shared (s), default(shared), num_tasks (nta), collapse(1), untied, if(i1), final(fi), mergeable, priority (pp), \\\n+    safelen(8), simdlen(4), linear(ll: 1), aligned(q: 32), reduction(default, +:r), in_reduction(+:r2), nontemporal(ntm), \\\n+    order(concurrent), allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp taskgroup, task_reduction (+:r2), allocate (r2)\n+  #pragma omp masked taskloop simd, \\\n+    private (p), firstprivate (f), lastprivate (l), shared (s), default(shared), num_tasks (nta), collapse(1), untied, if(i1), final(fi), mergeable, priority (pp), \\\n+    safelen(8), simdlen(4), linear(ll: 1), aligned(q: 32), reduction(default, +:r), in_reduction(+:r2), nontemporal(ntm), \\\n+    order(concurrent), allocate (f), filter (d)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp parallel master taskloop, \\\n+    private (p), firstprivate (f), lastprivate (l), shared (s), default(shared), num_tasks (nta), collapse(1), untied, if(i1), final(fi), mergeable, priority (pp), \\\n+    reduction(default, +:r), num_threads (nth), proc_bind(spread), copyin(t), allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp parallel masked taskloop, \\\n+    private (p), firstprivate (f), lastprivate (l), shared (s), default(shared), num_tasks (nta), collapse(1), untied, if(i1), final(fi), mergeable, priority (pp), \\\n+    reduction(default, +:r), num_threads (nth), proc_bind(spread), copyin(t), allocate (f), filter (d)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp parallel master taskloop simd, \\\n+    private (p), firstprivate (f), lastprivate (l), shared (s), default(shared), num_tasks (nta), collapse(1), untied, if(i1), final(fi), mergeable, priority (pp), \\\n+    safelen(8), simdlen(4), linear(ll: 1), aligned(q: 32), reduction(default, +:r), nontemporal(ntm), num_threads (nth), proc_bind(spread), copyin(t), \\\n+    order(concurrent), allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp parallel masked taskloop simd, \\\n+    private (p), firstprivate (f), lastprivate (l), shared (s), default(shared), num_tasks (nta), collapse(1), untied, if(i1), final(fi), mergeable, priority (pp), \\\n+    safelen(8), simdlen(4), linear(ll: 1), aligned(q: 32), reduction(default, +:r), nontemporal(ntm), num_threads (nth), proc_bind(spread), copyin(t), \\\n+    order(concurrent), allocate (f), filter (d)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp loop, bind(thread), order(concurrent), \\\n+    private (p), lastprivate (l), collapse(1), reduction(+:r)\n+  for (l = 0; l < 64; ++l)\n+    ll++;\n+  #pragma omp parallel loop, \\\n+    private (p), firstprivate (f), if (parallel: i2), default(shared), shared(s), copyin(t), reduction(+:r), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), collapse(1), bind(parallel), order(concurrent), allocate (f)\n+  for (l = 0; l < 64; l++)\n+    ll++;\n+  #pragma omp parallel loop, \\\n+    private (p), firstprivate (f), if (parallel: i2), default(shared), shared(s), copyin(t), reduction(+:r), num_threads (nth), proc_bind(spread), \\\n+    lastprivate (l), collapse(1), allocate (f)\n+  for (l = 0; l < 64; l++)\n+    ll++;\n+  #pragma omp teams loop, \\\n+    private(p), firstprivate (f), shared(s), default(shared), reduction(+:r), num_teams(nte-1:nte), thread_limit(tl), \\\n+    collapse(1), lastprivate (l), bind(teams), allocate (f)\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  #pragma omp teams loop, \\\n+    private(p), firstprivate (f), shared(s), default(shared), reduction(+:r), num_teams(nte), thread_limit(tl), \\\n+    collapse(1), lastprivate (l), order(concurrent), allocate (f)\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  #pragma omp target parallel loop, \\\n+    device(d), map (tofrom: m), if (target: i1), private (p), firstprivate (f), defaultmap(tofrom: scalar), is_device_ptr (idp), \\\n+    if (parallel: i2), default(shared), shared(s), reduction(+:r), num_threads (nth), proc_bind(spread), \\\n+    nowait depend(inout: dd[0]), lastprivate (l), bind(parallel), order(concurrent), collapse(1), \\\n+    allocate (omp_default_mem_alloc: f), in_reduction(+:r2), has_device_addr(hda)\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  #pragma omp target parallel loop, \\\n+    device(d), map (tofrom: m), if (target: i1), private (p), firstprivate (f), defaultmap(tofrom: scalar), is_device_ptr (idp), \\\n+    if (parallel: i2), default(shared), shared(s), reduction(+:r), num_threads (nth), proc_bind(spread), \\\n+    nowait depend(inout: dd[0]), lastprivate (l), order(concurrent), collapse(1), \\\n+    allocate (omp_default_mem_alloc: f), in_reduction(+:r2), has_device_addr(hda)\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  #pragma omp target teams loop, \\\n+    device(d), map (tofrom: m), if (target: i1), private (p), firstprivate (f), defaultmap(tofrom: scalar), is_device_ptr (idp), \\\n+    shared(s), default(shared), reduction(+:r), num_teams(nte-1:nte), thread_limit(tl), nowait depend(inout: dd[0]), \\\n+    lastprivate (l), bind(teams), collapse(1), \\\n+    allocate (omp_default_mem_alloc: f), in_reduction(+:r2), has_device_addr(hda)\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  #pragma omp target teams loop, \\\n+    device(d), map (tofrom: m), if (target: i1), private (p), firstprivate (f), defaultmap(tofrom: scalar), is_device_ptr (idp), \\\n+    shared(s), default(shared), reduction(+:r), num_teams(nte), thread_limit(tl), nowait depend(inout: dd[0]), \\\n+    lastprivate (l), order(concurrent), collapse(1), \\\n+    allocate (omp_default_mem_alloc: f), in_reduction(+:r2), has_device_addr(hda)\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  #pragma omp critical\n+  ;\n+  #pragma omp critical (foobar),hint(omp_sync_hint_none)\n+  ;\n+  #pragma omp taskwait, depend (inout: dd[0])\n+  ;\n+  #pragma omp taskgroup, task_reduction(+:r2),allocate (r2)\n+  ;\n+  #pragma omp atomic, update,seq_cst,hint(omp_sync_hint_none)\n+  p++;\n+  #pragma omp atomic, read, hint(omp_sync_hint_none),relaxed\n+  f = p;\n+  #pragma omp atomic,write, release hint(omp_sync_hint_none)\n+  p = f;\n+  #pragma omp flush\n+  ;\n+  #pragma omp flush, acq_rel\n+  ;\n+  #pragma omp flush, acquire\n+  ;\n+  #pragma omp flush, release\n+  ;\n+  #pragma omp flush, seq_cst\n+  ;\n+  #pragma omp flush (p, f)\n+  ;\n+  #pragma omp simd, \\\n+    private (p),lastprivate (l),linear (ll:1),reduction(+:r),collapse(1),safelen(8),simdlen(4),aligned(q: 32), \\\n+    nontemporal(ntm),if(i1)\n+  for (int i = 0; i < 64; i++)\n+    #pragma omp ordered, simd\n+      ll++;\n+  #pragma omp for, \\\n+    private (p),firstprivate (f),lastprivate (l),linear (ll:1),reduction(+:r),schedule(static, 4),collapse(1),nowait, \\\n+    ordered, allocate (f)\n+  for (int i = 0; i < 64; i++)\n+    #pragma omp ordered, threads\n+      ll++;\n+  #pragma omp for, ordered (1)\n+  for (l = 0; l < 64; l++)\n+    {\n+      #pragma omp ordered, depend (sink: l - 1)\n+      ;\n+      #pragma omp ordered, depend (source)\n+      ;\n+    }\n+  extern omp_depend_t depobj;\n+  #pragma omp depobj(depobj),depend(in : dd[0])\n+  ;\n+  #pragma omp parallel\n+  {\n+    if (p) {\n+      #pragma omp cancel, parallel\n+      ;\n+    } else {\n+      #pragma omp cancellation point, parallel\n+      ;\n+    }\n+  }\n+  #pragma omp scope, private (p), firstprivate (f), reduction(+:r), nowait, \\\n+    allocate(omp_default_mem_alloc: r)\n+    ;\n+  #pragma omp scope, private (p), firstprivate (f), reduction(task, +:r), \\\n+    allocate (omp_default_mem_alloc: f)\n+    ;\n+  extern int t2;\n+  #pragma omp threadprivate (t2)\n+  extern int t2;\n+  #pragma omp declare reduction (dr: int: omp_out += omp_in),initializer (omp_priv = 0)\n+  #pragma omp assume, no_openmp, no_openmp_routines, no_parallelism, \\\n+\t\t      absent (atomic, barrier, cancel, cancellation point), \\\n+\t\t      absent (critical, depobj), \\\n+\t\t      absent (distribute, flush, loop, masked, master, nothing, ordered), \\\n+\t\t      absent (parallel, scan, scope, section, sections, simd, single, task), \\\n+\t\t      absent (taskgroup, taskloop, taskwait, taskyield), \\\n+\t\t      absent (target, teams, for, error), holds (n1 < n2)\n+  if (0)\n+    ;\n+  #pragma omp assume, contains (simd)\n+  #pragma omp for simd\n+  for (int i = 0; i < 64; i++)\n+    ;\n+}\n+\n+void corge1 ();\n+\n+void\n+corge ()\n+{\n+  #pragma omp declare variant (corge1),match (construct={parallel,for})\n+  extern void corge2 ();\n+  #pragma omp parallel\n+  #pragma omp  for\n+  for (int i = 0; i < 5; i++)\n+    corge2 ();\n+  #pragma omp declare simd, simdlen(4),linear(l),aligned(p:4),uniform(p),inbranch\n+  #pragma omp declare simd,simdlen(8),notinbranch\n+  extern int corge3 (int l, int *p);\n+  #pragma omp declare simd, simdlen(4),linear(l),aligned(p:4),uniform(p),inbranch\n+  #pragma omp declare simd, simdlen(8),notinbranch\n+  extern int corge4 (int l, int *p);\n+  #pragma omp declare simd, simdlen(4),linear(l),aligned(p:4),uniform(p),inbranch\n+  #pragma omp declare simd, simdlen(8),notinbranch\n+  extern int corge5 (int l, int *p);\n+  #pragma omp declare target\n+  extern void corge6 ();\n+  #pragma omp end declare target\n+}\n+\n+int\n+garply (int a, int *c, int *d, int *e, int *f)\n+{\n+  int i;\n+  #pragma omp simd, reduction (inscan, +: a)\n+  for (i = 0; i < 64; i++)\n+    {\n+      d[i] = a;\n+      #pragma omp scan, exclusive (a)\n+      a += c[i];\n+    }\n+  #pragma omp simd, reduction (inscan, +: a)\n+  for (i = 0; i < 64; i++)\n+    {\n+      a += c[i];\n+      #pragma omp scan inclusive (a)\n+      d[i] = a;\n+    }\n+  return a;\n+}"}, {"sha": "3c2c12c9e03cf1dc4f1119ee468424b0532ed7de", "filename": "gcc/testsuite/c-c++-common/gomp/declare-variant-2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89999f2358724fa4e71c7c3b4de340582c0e43da/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89999f2358724fa4e71c7c3b4de340582c0e43da/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-2.c?ref=89999f2358724fa4e71c7c3b4de340582c0e43da", "patch": "@@ -149,7 +149,8 @@ void f72 (void);\n void f73 (void);\n #pragma omp declare variant (f1) match(construct={requires})\t/* { dg-error \"selector 'requires' not allowed for context selector set 'construct'\" } */\n void f74 (void);\n-#pragma omp declare variant (f1),match(construct={parallel})\t/* { dg-error \"expected 'match' before ','\" } */\n+void f75a (void);\n+#pragma omp declare variant (f75a),match(construct={parallel})\n void f75 (void);\n #pragma omp declare variant (f1) match(implementation={atomic_default_mem_order(\"relaxed\")})\t/* { dg-error \"expected identifier before string constant\" } */\n void f76 (void);"}, {"sha": "e1218bd686954d6a6f213460f93aa723c6537344", "filename": "gcc/testsuite/c-c++-common/gomp/directive-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89999f2358724fa4e71c7c3b4de340582c0e43da/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdirective-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89999f2358724fa4e71c7c3b4de340582c0e43da/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdirective-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdirective-1.c?ref=89999f2358724fa4e71c7c3b4de340582c0e43da", "patch": "@@ -0,0 +1,28 @@\n+int thr;\n+#pragma omp threadprivate, (thr)\t\t/* { dg-error \"expected '\\\\\\(' before ',' token\" } */\n+\t\t\t\t\t\t/* { dg-error \"expected end of line before ',' token\" \"\" { target c++ } .-1 } */\n+#pragma omp declare reduction, (foo: int : omp_out += omp_in), initializer (omp_priv = 0)\t/* { dg-error \"expected '\\\\\\(' before ',' token\" } */\n+void f1 (void);\n+#pragma omp declare variant, (f1), match (user={condition(true)})\t/* { dg-error \"expected '\\\\\\(' before ',' token\" } */\n+void f2 (void);\n+int j;\n+#pragma omp declare target, (j)\t\t\t/* { dg-error \"expected end of line before ',' token\" } */\n+\n+typedef struct __attribute__((__aligned__ (sizeof (void *)))) omp_depend_t {\n+  char __omp_depend_t__[2 * sizeof (void *)];\n+} omp_depend_t;\n+extern omp_depend_t d;\n+\n+void\n+foo (void)\n+{\n+  int i, k = 0, l = 0;\n+  #pragma omp allocate, (i)\t\t\t/* { dg-error \"expected '\\\\\\(' before ',' token\" } */\n+\t\t\t\t\t\t/* { dg-error \"expected end of line before ',' token\" \"\" { target c++ } .-1 } */\n+\t\t\t\t\t\t/* { dg-message \"not yet supported\" \"\" { target *-*-* } .-2 } */\n+  #pragma omp critical, (bar)\t\t\t/* { dg-error \"expected '#pragma omp' clause before '\\\\\\(' token\" } */\n+  ;\n+  #pragma omp flush, (k, l)\t\t\t/* { dg-error \"expected '\\\\\\(' or end of line before ',' token\" \"\" { target c } } */\n+\t\t\t\t\t\t/* { dg-error \"expected end of line before ',' token\" \"\" { target c++ } .-1 } */\n+  #pragma omp depobj, (d) depend(in : l)\t/* { dg-error \"expected '\\\\\\(' before ',' token\" } */\n+}"}, {"sha": "db191e2b68934b4419c8be8a90a7fa24ea4971e0", "filename": "gcc/testsuite/g++.dg/gomp/clause-4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89999f2358724fa4e71c7c3b4de340582c0e43da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89999f2358724fa4e71c7c3b4de340582c0e43da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-4.C?ref=89999f2358724fa4e71c7c3b4de340582c0e43da", "patch": "@@ -14,7 +14,7 @@ foo (int x)\n     ;\n #pragma omp p num_threads(4),if(1),private(x)\n     ;\n-#pragma omp p, num_threads (4), if (1), private (x)\t// { dg-error \"clause before\" }\n+#pragma omp p, num_threads (4), if (1), private (x)\n     ;\n #pragma omp p num_threads (4), if (1), private (x),\t// { dg-error \"clause before\" }\n     ;"}, {"sha": "4d37c41cc9f0e4202a2a843cb6f31db27dcbefde", "filename": "gcc/testsuite/gcc.dg/gomp/clause-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89999f2358724fa4e71c7c3b4de340582c0e43da/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89999f2358724fa4e71c7c3b4de340582c0e43da/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-2.c?ref=89999f2358724fa4e71c7c3b4de340582c0e43da", "patch": "@@ -14,7 +14,7 @@ foo (int x)\n     ;\n #pragma omp p num_threads(4),if(1),private(x)\n     ;\n-#pragma omp p, num_threads (4), if (1), private (x)\t/* { dg-error \"clause before\" } */\n+#pragma omp p, num_threads (4), if (1), private (x)\n     ;\n #pragma omp p num_threads (4), if (1), private (x),\t/* { dg-error \"clause before\" } */\n     ;"}]}