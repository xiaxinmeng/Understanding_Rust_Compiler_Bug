{"sha": "79b2746ad73c6159b77a510032162c09ebfb1613", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzliMjc0NmFkNzNjNjE1OWI3N2E1MTAwMzIxNjJjMDllYmZiMTYxMw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-06-06T17:45:16Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-06-06T17:45:16Z"}, "message": "(print_operand): Check for annulled branches.\n\n(output_movedouble): Handle SUBREG addresses.\n(output_branch): Handle annulled branches.\n(sh_expand_prologue): Correct number of saved registers for\nvarargs functions.\n\nFrom-SVN: r9886", "tree": {"sha": "8c56ddb9b063de72e1e8a0150b0cebc3bcd525a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c56ddb9b063de72e1e8a0150b0cebc3bcd525a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79b2746ad73c6159b77a510032162c09ebfb1613", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79b2746ad73c6159b77a510032162c09ebfb1613", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79b2746ad73c6159b77a510032162c09ebfb1613", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79b2746ad73c6159b77a510032162c09ebfb1613/comments", "author": null, "committer": null, "parents": [{"sha": "60715d0bef40ecaebd6753e865173648a20a1306", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60715d0bef40ecaebd6753e865173648a20a1306", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60715d0bef40ecaebd6753e865173648a20a1306"}], "stats": {"total": 42, "additions": 33, "deletions": 9}, "files": [{"sha": "77d44efd2c26124f3be4b00ee6c1f26180e79c54", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79b2746ad73c6159b77a510032162c09ebfb1613/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79b2746ad73c6159b77a510032162c09ebfb1613/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=79b2746ad73c6159b77a510032162c09ebfb1613", "patch": "@@ -163,7 +163,8 @@ print_operand (stream, x, code)\n   switch (code)\n     {\n     case '.':\n-      if (final_sequence)\n+      if (final_sequence\n+\t  && ! INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0)))\n \tfprintf (stream, \".s\");\n       break;\n     case '@':\n@@ -428,6 +429,8 @@ output_movedouble (insn, operands, mode)\n \n       if (GET_CODE (inside) == REG)\n \tptrreg = REGNO (inside);\n+      else if (GET_CODE (inside) == SUBREG)\n+\tptrreg = REGNO (SUBREG_REG (inside)) + SUBREG_WORD (inside);\n       else if (GET_CODE (inside) == PLUS)\n \t{\n \t  ptrreg = REGNO (XEXP (inside, 0));\n@@ -530,18 +533,28 @@ output_branch (logic, insn, operands)\n \t/* The call to print_slot will clobber the operands.  */\n \trtx op0 = operands[0];\n \n+\t/* If the instruction in the delay slot is annulled (true), then\n+\t   there is no delay slot where we can put it now.  The only safe\n+\t   place for it is after the label.  */\n+\n \tif (final_sequence)\n \t  {\n-\t    fprintf (asm_out_file, \"\\tb%c.s\\tLF%d\\n\", logic ? 'f' : 't',\n-\t\t     label);\n-\t    print_slot (final_sequence);\n+\t    fprintf (asm_out_file, \"\\tb%c%s\\tLF%d\\n\", logic ? 'f' : 't',\n+\t\t     INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0))\n+\t\t     ? \"\" : \".s\", label);\n+\t    if (! INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0)))\n+\t      print_slot (final_sequence);\n \t  }\n \telse\n \t  fprintf (asm_out_file, \"\\tb%c\\tLF%d\\n\", logic ? 'f' : 't', label);\n \n \toutput_asm_insn (\"bra\t%l0\", &op0);\n \tfprintf (asm_out_file, \"\\tnop\\n\");\n \tfprintf (asm_out_file, \"LF%d:\\n\", label);\n+\n+\tif (final_sequence\n+\t    && INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0)))\n+\t  print_slot (final_sequence);\n       }\n       return \"\";\n \n@@ -553,19 +566,29 @@ output_branch (logic, insn, operands)\n \t/* The call to print_slot will clobber the operands.  */\n \trtx op0 = operands[0];\n \n+\t/* If the instruction in the delay slot is annulled (true), then\n+\t   there is no delay slot where we can put it now.  The only safe\n+\t   place for it is after the label.  */\n+\n \tif (final_sequence)\n \t  {\n-\t    fprintf (asm_out_file, \"\\tb%c.s\\tLF%d\\n\", logic ? 'f' : 't',\n-\t\t     label);\n-\t    print_slot (final_sequence);\n+\t    fprintf (asm_out_file, \"\\tb%c%s\\tLF%d\\n\", logic ? 'f' : 't',\n+\t\t     INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0))\n+\t\t     ? \"\" : \".s\", label);\n+\t    if (! INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0)))\n+\t      print_slot (final_sequence);\n \t  }\n \telse\n \t  fprintf (asm_out_file, \"\\tb%c\\tLF%d\\n\", logic ? 'f' : 't', label);\n \n \toutput_far_jump (insn, op0);\n \tfprintf (asm_out_file, \"LF%d:\\n\", label);\n-\treturn \"\";\n+\n+\tif (final_sequence\n+\t    && INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0)))\n+\t  print_slot (final_sequence);\n       }\n+      return \"\";\n     }\n   return \"bad\";\n }\n@@ -1520,7 +1543,8 @@ sh_expand_prologue ()\n       for (i = 0; i < NPARM_REGS; i++)\n \t{\n \t  int rn = NPARM_REGS + FIRST_PARM_REG - i - 1;\n-\t  if (i > NPARM_REGS - current_function_args_info)\n+\t  if (i > (NPARM_REGS - current_function_args_info\n+\t\t   - current_function_varargs))\n \t    break;\n \t  push (rn);\n \t  extra_push += 4;"}]}