{"sha": "66edd3b4ca7e6cc9a6d09fc4ba5d890f04c66ead", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZlZGQzYjRjYTdlNmNjOWE2ZDA5ZmM0YmE1ZDg5MGYwNGM2NmVhZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-05-29T01:37:22Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-05-29T01:37:22Z"}, "message": "i386.c (ix86_save_reg): Examine regs_ever_live...\n\n        * config/i386/i386.c (ix86_save_reg): Examine regs_ever_live,\n        not current_function_uses_pic_offset_table and\n        current_function_uses_const_pool; examine current_function_profile.\n        (ix86_expand_prologue): Likewise.  Add pic_offset_table_rtx as\n        input to blockage if needed.\n        (ix86_expand_call): Do not set current_function_uses_pic_offset_table.\n        (legitimize_pic_address): Likewise.  Set regs_ever_live for\n        pic_offset_table_rtx when invoked during reload.\n        * config/i386/i386.h (FINALIZE_PIC): Remove.\n        * config/i386/i386.md (tablejump): Reformat.  Do not set\n        current_function_uses_pic_offset_table.\n        (tls_global_dynamic, tls_local_dynamic_base): Likewise.\n        (blockage): Accept anything as operand 0.\n\nFrom-SVN: r53981", "tree": {"sha": "0ac9200a04b0ae4859b32189c21877c9a830da1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ac9200a04b0ae4859b32189c21877c9a830da1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66edd3b4ca7e6cc9a6d09fc4ba5d890f04c66ead", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66edd3b4ca7e6cc9a6d09fc4ba5d890f04c66ead", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66edd3b4ca7e6cc9a6d09fc4ba5d890f04c66ead", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66edd3b4ca7e6cc9a6d09fc4ba5d890f04c66ead/comments", "author": null, "committer": null, "parents": [{"sha": "52f4fff6829c14f4cdf754751566df0fb28f5ad5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52f4fff6829c14f4cdf754751566df0fb28f5ad5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52f4fff6829c14f4cdf754751566df0fb28f5ad5"}], "stats": {"total": 113, "additions": 61, "deletions": 52}, "files": [{"sha": "f3911224d0cbca5feafffe241d064bb50b4dd5ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66edd3b4ca7e6cc9a6d09fc4ba5d890f04c66ead/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66edd3b4ca7e6cc9a6d09fc4ba5d890f04c66ead/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=66edd3b4ca7e6cc9a6d09fc4ba5d890f04c66ead", "patch": "@@ -1,3 +1,19 @@\n+2002-05-28  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386.c (ix86_save_reg): Examine regs_ever_live,\n+\tnot current_function_uses_pic_offset_table and\n+\tcurrent_function_uses_const_pool; examine current_function_profile.\n+\t(ix86_expand_prologue): Likewise.  Add pic_offset_table_rtx as\n+\tinput to blockage if needed.\n+\t(ix86_expand_call): Do not set current_function_uses_pic_offset_table.\n+\t(legitimize_pic_address): Likewise.  Set regs_ever_live for\n+\tpic_offset_table_rtx when invoked during reload.\n+\t* config/i386/i386.h (FINALIZE_PIC): Remove.\n+\t* config/i386/i386.md (tablejump): Reformat.  Do not set\n+\tcurrent_function_uses_pic_offset_table.\n+\t(tls_global_dynamic, tls_local_dynamic_base): Likewise.\n+\t(blockage): Accept anything as operand 0.\n+\n 2002-05-28  Jason Thorpe  <thorpej@wasabisystems.com>\n \n \t* config/netbsd-aout.h (NETBSD_OS_CPP_BUILTINS_AOUT): Define"}, {"sha": "7e98741868d85ad2b681a1b9e79f142432edfe6a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66edd3b4ca7e6cc9a6d09fc4ba5d890f04c66ead/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66edd3b4ca7e6cc9a6d09fc4ba5d890f04c66ead/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=66edd3b4ca7e6cc9a6d09fc4ba5d890f04c66ead", "patch": "@@ -4012,8 +4012,8 @@ ix86_save_reg (regno, maybe_eh_return)\n      int maybe_eh_return;\n {\n   if (regno == PIC_OFFSET_TABLE_REGNUM\n-      && (current_function_uses_pic_offset_table\n-\t  || current_function_uses_const_pool\n+      && (regs_ever_live[regno]\n+\t  || current_function_profile\n \t  || current_function_calls_eh_return))\n     return 1;\n \n@@ -4235,9 +4235,9 @@ void\n ix86_expand_prologue ()\n {\n   rtx insn;\n-  int pic_reg_used = (flag_pic && (current_function_uses_pic_offset_table\n-\t\t\t\t  || current_function_uses_const_pool)\n-\t\t      && !TARGET_64BIT);\n+  int pic_reg_used = (PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM\n+\t\t      && (regs_ever_live[PIC_OFFSET_TABLE_REGNUM]\n+\t\t\t  || current_function_profile));\n   struct ix86_frame frame;\n   int use_mov = 0;\n   HOST_WIDE_INT allocate;\n@@ -4320,18 +4320,19 @@ ix86_expand_prologue ()\n     {\n       insn = emit_insn (gen_set_got (pic_offset_table_rtx));\n \n-      /* ??? The current_function_uses_pic_offset_table flag is woefully\n-\t inaccurate, as it isn't updated as code gets deleted.  Allow the\n-\t thing to be removed.  A better solution would be to actually get\n-\t proper liveness for ebx, as then we won't save/restore it too.  */\n+      /* Even with accurate pre-reload life analysis, we can wind up\n+\t deleting all references to the pic register after reload.\n+\t Consider if cross-jumping unifies two sides of a branch\n+\t controled by a comparison vs the only read from a global.\n+\t In which case, allow the set_got to be deleted, though we're\n+\t too late to do anything about the ebx save in the prologue.  */\n       REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx, NULL);\n     }\n \n-  /* If we are profiling, make sure no instructions are scheduled before\n-     the call to mcount.  However, if -fpic, the above call will have\n-     done that.  */\n-  if (current_function_profile && ! pic_reg_used)\n-    emit_insn (gen_blockage ());\n+  /* Prevent function calls from be scheduled before the call to mcount.\n+     In the pic_reg_used case, make sure that the got load isn't deleted.  */\n+  if (current_function_profile)\n+    emit_insn (gen_blockage (pic_reg_used ? pic_offset_table_rtx : const0_rtx));\n }\n \n /* Emit code to restore saved registers using MOV insns.  First register\n@@ -5245,7 +5246,8 @@ legitimize_pic_address (orig, reg)\n \t  /* This symbol may be referenced via a displacement from the PIC\n \t     base address (@GOTOFF).  */\n \n-\t  current_function_uses_pic_offset_table = 1;\n+\t  if (reload_in_progress)\n+\t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n \t  new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTOFF);\n \t  new = gen_rtx_CONST (Pmode, new);\n \t  new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n@@ -5261,7 +5263,6 @@ legitimize_pic_address (orig, reg)\n     {\n       if (TARGET_64BIT)\n \t{\n-\t  current_function_uses_pic_offset_table = 1;\n \t  new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTPCREL);\n \t  new = gen_rtx_CONST (Pmode, new);\n \t  new = gen_rtx_MEM (Pmode, new);\n@@ -5281,7 +5282,8 @@ legitimize_pic_address (orig, reg)\n \t  /* This symbol must be referenced via a load from the\n \t     Global Offset Table (@GOT).  */\n \n-\t  current_function_uses_pic_offset_table = 1;\n+\t  if (reload_in_progress)\n+\t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n \t  new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOT);\n \t  new = gen_rtx_CONST (Pmode, new);\n \t  new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n@@ -5322,7 +5324,8 @@ legitimize_pic_address (orig, reg)\n \t    {\n \t      if (!TARGET_64BIT)\n \t\t{\n-\t\t  current_function_uses_pic_offset_table = 1;\n+\t\t  if (reload_in_progress)\n+\t\t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n \t\t  new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op0),\n \t\t\t\t\tUNSPEC_GOTOFF);\n \t\t  new = gen_rtx_PLUS (Pmode, new, op1);\n@@ -5518,7 +5521,8 @@ legitimize_address (x, oldx, mode)\n         case TLS_MODEL_INITIAL_EXEC:\n \t  if (flag_pic)\n \t    {\n-\t      current_function_uses_pic_offset_table = 1;\n+\t      if (reload_in_progress)\n+\t\tregs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n \t      pic = pic_offset_table_rtx;\n \t    }\n \t  else\n@@ -10464,10 +10468,7 @@ ix86_expand_call (retval, fnaddr, callarg1, callarg2, pop)\n   if (! TARGET_64BIT && flag_pic\n       && GET_CODE (XEXP (fnaddr, 0)) == SYMBOL_REF\n       && ! SYMBOL_REF_FLAG (XEXP (fnaddr, 0)))\n-    {\n-      current_function_uses_pic_offset_table = 1;\n-      use_reg (&use, pic_offset_table_rtx);\n-    }\n+    use_reg (&use, pic_offset_table_rtx);\n \n   if (TARGET_64BIT && INTVAL (callarg2) >= 0)\n     {"}, {"sha": "970dfdfdf61608f96cbf18e4671ed4a9b4bfa084", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66edd3b4ca7e6cc9a6d09fc4ba5d890f04c66ead/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66edd3b4ca7e6cc9a6d09fc4ba5d890f04c66ead/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=66edd3b4ca7e6cc9a6d09fc4ba5d890f04c66ead", "patch": "@@ -2406,17 +2406,6 @@ enum ix86_builtins\n       fputs (user_label_prefix, FILE);\t\t\\\n     fputs (xname, FILE);\t\t\t\\\n   } while (0)\n-\n-/* The `FINALIZE_PIC' macro serves as a hook to emit these special\n-   codes once the function is being compiled into assembly code, but\n-   not before.  (It is not done before, because in the case of\n-   compiling an inline function, it would lead to multiple PIC\n-   prologues being included in functions which used inline functions\n-   and were compiled to assembly language.)  */\n-\n-#define FINALIZE_PIC \\\n-  (current_function_uses_pic_offset_table |= current_function_profile)\n-\n \f\n /* Max number of args passed in registers.  If this is more than 3, we will\n    have problems with ebx (register #4), since it is a caller save register and"}, {"sha": "1c99f60ecaec3d868cc34174ba02b43199ff94cf", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66edd3b4ca7e6cc9a6d09fc4ba5d890f04c66ead/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66edd3b4ca7e6cc9a6d09fc4ba5d890f04c66ead/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=66edd3b4ca7e6cc9a6d09fc4ba5d890f04c66ead", "patch": "@@ -12699,29 +12699,34 @@\n \t      (use (label_ref (match_operand 1 \"\" \"\")))])]\n   \"\"\n {\n-  /* In PIC mode, the table entries are stored GOT-relative.  Convert\n-     the relative address to an absolute address.  */\n+  /* In PIC mode, the table entries are stored GOT (32-bit) or PC (64-bit)\n+     relative.  Convert the relative address to an absolute address.  */\n   if (flag_pic)\n     {\n+      rtx op0, op1;\n+      enum rtx_code code;\n+\n       if (TARGET_64BIT)\n-\toperands[0] = expand_simple_binop (Pmode, PLUS, operands[0],\n-\t\t\t\t\t   gen_rtx_LABEL_REF (Pmode, operands[1]),\n-\t\t\t\t\t   NULL_RTX, 0,\n-\t\t\t\t\t   OPTAB_DIRECT);\n+\t{\n+\t  code = PLUS;\n+\t  op0 = operands[0];\n+\t  op1 = gen_rtx_LABEL_REF (Pmode, operands[1]);\n+\t}\n       else if (HAVE_AS_GOTOFF_IN_DATA)\n \t{\n-\t  operands[0] = expand_simple_binop (Pmode, PLUS, operands[0],\n-\t\t\t\t\t     pic_offset_table_rtx, NULL_RTX,\n-\t\t\t\t\t     1, OPTAB_DIRECT);\n-\t  current_function_uses_pic_offset_table = 1;\n+\t  code = PLUS;\n+\t  op0 = operands[0];\n+\t  op1 = pic_offset_table_rtx;\n \t}\n       else\n \t{\n-\t  operands[0] = expand_simple_binop (Pmode, MINUS, pic_offset_table_rtx,\n-\t\t\t\t\t     operands[0], NULL_RTX, 1,\n-\t\t\t\t\t     OPTAB_DIRECT);\n-\t  current_function_uses_pic_offset_table = 1;\n+\t  code = MINUS;\n+\t  op0 = pic_offset_table_rtx;\n+\t  op1 = operands[0];\n \t}\n+\n+      operands[0] = expand_simple_binop (Pmode, code, op0, op1, NULL_RTX, 1,\n+\t\t\t\t\t OPTAB_DIRECT);\n     }\n })\n \n@@ -13061,7 +13066,7 @@\n      registers we stored in the result block.  We avoid problems by\n      claiming that all hard registers are used and clobbered at this\n      point.  */\n-  emit_insn (gen_blockage ());\n+  emit_insn (gen_blockage (const0_rtx));\n \n   DONE;\n })\n@@ -13072,7 +13077,7 @@\n ;; all of memory.  This blocks insns from being moved across this point.\n \n (define_insn \"blockage\"\n-  [(unspec_volatile [(const_int 0)] UNSPECV_BLOCKAGE)]\n+  [(unspec_volatile [(match_operand 0 \"\" \"\")] UNSPECV_BLOCKAGE)]\n   \"\"\n   \"\"\n   [(set_attr \"length\" \"0\")])\n@@ -13391,7 +13396,6 @@\n {\n   if (!flag_pic)\n     abort ();\n-  current_function_uses_pic_offset_table = 1;\n   operands[2] = pic_offset_table_rtx;\n   operands[3] = ix86_tls_get_addr ();\n })\n@@ -13434,7 +13438,6 @@\n {\n   if (!flag_pic)\n     abort ();\n-  current_function_uses_pic_offset_table = 1;\n   operands[1] = pic_offset_table_rtx;\n   operands[2] = ix86_tls_get_addr ();\n })"}]}