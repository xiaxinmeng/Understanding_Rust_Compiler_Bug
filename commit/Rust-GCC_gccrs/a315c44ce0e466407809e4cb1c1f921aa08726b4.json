{"sha": "a315c44ce0e466407809e4cb1c1f921aa08726b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMxNWM0NGNlMGU0NjY0MDc4MDllNGNiMWMxZjkyMWFhMDg3MjZiNA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-07-17T23:17:20Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-07-17T23:17:20Z"}, "message": "dumpfile.h (TDF_COMMENT): New define.\n\n\t* dumpfile.h (TDF_COMMENT): New define.\n\t* basic-block.h (EDGE_FALLTHRU, EDGE_ABNORMAL, EDGE_ABNORMAL_CALL,\n\tEDGE_EH, EDGE_FAKE, EDGE_DFS_BACK, EDGE_CAN_FALLTHRU,\n\tEDGE_IRREDUCIBLE_LOOP, EDGE_SIBCALL, EDGE_LOOP_EXIT, EDGE_TRUE_VALUE,\n\tEDGE_FALSE_VALUE, EDGE_EXECUTABLE, EDGE_CROSSING, EDGE_PRESERVE):\n\tMove to new file cfg-flags.h.\n\t(enum cfg_edge_flags): New enum, using cfg-flags.h.\n\t(EDGE_ALL_FLAGS): Compute value automatically.\n\t(BB_NEW, BB_REACHABLE, BB_IRREDUCIBLE_LOOP, BB_SUPERBLOCK,\n\tBB_DISABLE_SCHEDULE, BB_HOT_PARTITION, BB_COLD_PARTITION,\n\tBB_DUPLICATED, BB_NON_LOCAL_GOTO_TARGET, BB_RTL,\n\tBB_FORWARDER_BLOCK, BB_NONTHREADABLE_BLOCK, BB_MODIFIED, BB_VISITED,\n\tBB_IN_TRANSACTION): Move to new file cfg-flags.h.\n\t(enum bb_flags): Rename to cfg_bb_flags.  Use cfg-flags.h.\n\t(BB_ALL_FLAGS): New, compute value automatically.\n\t(dump_bb_info): Update prototype.\n\t(dump_edge_info): Update prototype.\n\t* cfg-flags.h: New file.\n\t* cfg.c (dump_edge_info): Take flags argument.  Be verbose only if\n\tTDF_DETAILS and not TDF_SLIM.  Include cfg-flags.h for bitnames.\n\tCheck that the edge flags are within the range of EDGE_ALL_FLAGS.\n\t(debug_bb): Update dump_bb call.\n\t(dump_cfg_bb_info): Remove.\n\t(dump_bb_info): New function.  Use cfg-flags.h for bitnames.\n\tAdjust verbosity using TDF_* flags.  Check that the basic block flags\n\tare within the range of BB_ALL_FLAGS.\n\t(brief_dump_cfg): Use dump_bb_info instead of dump_cfg_bb_info.\n\t* cfghooks.h (struct cfghooks): Update dump_bb hook, take a FILE\n\tfirst for consistency with other dump functions.\n\t(dump_bb): Update prototype accordingly.\n\t* cfghooks.c: Include dumpfile.h.\n\t(verify_flow_info): Update dump_edge_info calls.\n\t(dump_bb): Take a flags argument and pass it around.\n\tUse dump_bb_info to dump common information about a basic block.\n\t(dump_flow_info): Moved here from cfgrtl.c.  Make IL agnostic.\n\t(debug_flow_info): Moved here from cfgrtl.c.\n\t* profile.c (is_edge_inconsistent): Update dump_bb calls.\n\t* loop-invariant.c (find_defs): Update print_rtl_with_bb call.\n\t* rtl.h (debug_bb_n_slim, debug_bb_slim, print_rtl_slim,\n\tprint_rtl_slim_with_bb): Remove prototypes.\n\t(dump_insn_slim): Adjust prototype to take a const_rtx.\n\t(print_rtl_with_bb): Adjust prototype.\n\t* sched-rgn.c (debug_region): Use dump_bb instead of debug_bb_n_slim.\n\t* sched-vis.c (dump_insn_slim): Take a const_rtx.\n\t(debug_insn_slim): Prototype here near DEBUG_FUNCTION marker.\n\t(print_rtl_slim_with_bb): Remove.\n\t(print_rtl_slim): Rename to debug_rtl_slim.  Print only insn info,\n\tnot basic block info (print_rtl_with_bb with TDF_SLIM should be used\n\tfor that.  Prototype here near DEBUG_FUNCTION marker.\n\t(debug_bb_slim): Prototype here near DEBUG_FUNCTION marker.\n\tUse dump_bb.\n\t(debug_bb_n_slim): Prototype here near DEBUG_FUNCTION marker.\n\t* tree-cfg.c (gimple_can_merge_blocks_p): Use EDGE_COMPLEX.\n\t(remove_bb): Update dump_bb call.\n\t(gimple_debug_bb): Use dump_bb.\n\t(dump_function_to_file): Update gimple_dump_bb call.\n\t(print_loops_bb): Likewise.\n\t* tree-flow.h (gimple_dump_bb): Update prototype.\n\t* gimple-pretty-print.c (dump_bb_header): Rename to\n\tdump_gimple_bb_header.  Write to a stream instead of a pretty\n\tprinter.  Use dump_bb_info to dump basic block info.\n\t(dump_bb_end): Rename to dump_gimple_bb_footer.  Write to a\n\tstream instead of a pretty printer.  Use dump_bb_info.\n\t(gimple_dump_bb_buff): Do not call dump_bb_header and dump_bb_end.\n\t(gimple_dump_bb): Do it here with dump_gimple_bb_header and\n\tdump_gimple_bb_footer.\n\t* cfgrtl.c (rtl_dump_bb): Update prototype.  Only dump DF if the\n\tdump flags have TDF_DETAILS.  Use dump_insn_slim if TDF_SLIM.\n\t(print_rtl_with_bb): Take a flags argument and pass it around.\n\tUse dump_insn_slim if TDF_SLIM.\n\t(dump_bb_info): Removed and re-incarnated in cfg.c.\n\t(dump_flow_info): Moved to cfghooks.c.\n\t(debug_flow_info): Moved to cfghooks.c.\n\t* passes.c (execute_function_dump): Unconditionally use\n\tprint_rtl_with_bb for RTL dumps, now that it understands TDF_SLIM.\n\t* final.c (dump_basic_block_info): Update dump_edge_info calls.\n\t* tree-vrp.c (dump_asserts_for): Likewise.\n\t* ifcvt.c (if_convert): Unconditionally use print_rtl_with_bb.\n\t* tree-if-conv.c (if_convertible_bb_p): Don't look at\n\tEDGE_ABNORMAL_CALL, it has no meaning in the GIMPLE world.\n\t* trans-mem.c (make_tm_edge): Don't set EDGE_ABNORMAL_CALL,\n\tfor the same reason.\n\t* config/rl78/rl78.c (rl78_reorg): Update print_rtl_with_bb calls.\n\nFrom-SVN: r189590", "tree": {"sha": "9d5c1ea84c526379245c9986d831f4ce16757d79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d5c1ea84c526379245c9986d831f4ce16757d79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a315c44ce0e466407809e4cb1c1f921aa08726b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a315c44ce0e466407809e4cb1c1f921aa08726b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a315c44ce0e466407809e4cb1c1f921aa08726b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a315c44ce0e466407809e4cb1c1f921aa08726b4/comments", "author": null, "committer": null, "parents": [{"sha": "9717f7a145b447c2c3dd00601de66be20d86261e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9717f7a145b447c2c3dd00601de66be20d86261e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9717f7a145b447c2c3dd00601de66be20d86261e"}], "stats": {"total": 996, "additions": 534, "deletions": 462}, "files": [{"sha": "f5242940351c2ac64e837f4fd62a319b2aefd9c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -1,3 +1,89 @@\n+2012-07-18  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* dumpfile.h (TDF_COMMENT): New define.\n+\t* basic-block.h (EDGE_FALLTHRU, EDGE_ABNORMAL, EDGE_ABNORMAL_CALL,\n+\tEDGE_EH, EDGE_FAKE, EDGE_DFS_BACK, EDGE_CAN_FALLTHRU,\n+\tEDGE_IRREDUCIBLE_LOOP, EDGE_SIBCALL, EDGE_LOOP_EXIT, EDGE_TRUE_VALUE,\n+\tEDGE_FALSE_VALUE, EDGE_EXECUTABLE, EDGE_CROSSING, EDGE_PRESERVE):\n+\tMove to new file cfg-flags.h.\n+\t(enum cfg_edge_flags): New enum, using cfg-flags.h.\n+\t(EDGE_ALL_FLAGS): Compute value automatically.\n+\t(BB_NEW, BB_REACHABLE, BB_IRREDUCIBLE_LOOP, BB_SUPERBLOCK,\n+\tBB_DISABLE_SCHEDULE, BB_HOT_PARTITION, BB_COLD_PARTITION,\n+\tBB_DUPLICATED, BB_NON_LOCAL_GOTO_TARGET, BB_RTL,\n+\tBB_FORWARDER_BLOCK, BB_NONTHREADABLE_BLOCK, BB_MODIFIED, BB_VISITED,\n+\tBB_IN_TRANSACTION): Move to new file cfg-flags.h.\n+\t(enum bb_flags): Rename to cfg_bb_flags.  Use cfg-flags.h.\n+\t(BB_ALL_FLAGS): New, compute value automatically.\n+\t(dump_bb_info): Update prototype.\n+\t(dump_edge_info): Update prototype.\n+\t* cfg-flags.h: New file.\n+\t* cfg.c (dump_edge_info): Take flags argument.  Be verbose only if\n+\tTDF_DETAILS and not TDF_SLIM.  Include cfg-flags.h for bitnames.\n+\tCheck that the edge flags are within the range of EDGE_ALL_FLAGS.\n+\t(debug_bb): Update dump_bb call.\n+\t(dump_cfg_bb_info): Remove.\n+\t(dump_bb_info): New function.  Use cfg-flags.h for bitnames.\n+\tAdjust verbosity using TDF_* flags.  Check that the basic block flags\n+\tare within the range of BB_ALL_FLAGS.\n+\t(brief_dump_cfg): Use dump_bb_info instead of dump_cfg_bb_info.\n+\t* cfghooks.h (struct cfghooks): Update dump_bb hook, take a FILE\n+\tfirst for consistency with other dump functions.\n+\t(dump_bb): Update prototype accordingly.\n+\t* cfghooks.c: Include dumpfile.h.\n+\t(verify_flow_info): Update dump_edge_info calls.\n+\t(dump_bb): Take a flags argument and pass it around.\n+\tUse dump_bb_info to dump common information about a basic block.\n+\t(dump_flow_info): Moved here from cfgrtl.c.  Make IL agnostic.\n+\t(debug_flow_info): Moved here from cfgrtl.c.\n+\t* profile.c (is_edge_inconsistent): Update dump_bb calls.\n+\t* loop-invariant.c (find_defs): Update print_rtl_with_bb call.\n+\t* rtl.h (debug_bb_n_slim, debug_bb_slim, print_rtl_slim,\n+\tprint_rtl_slim_with_bb): Remove prototypes.\n+\t(dump_insn_slim): Adjust prototype to take a const_rtx.\n+\t(print_rtl_with_bb): Adjust prototype.\n+\t* sched-rgn.c (debug_region): Use dump_bb instead of debug_bb_n_slim.\n+\t* sched-vis.c (dump_insn_slim): Take a const_rtx.\n+\t(debug_insn_slim): Prototype here near DEBUG_FUNCTION marker.\n+\t(print_rtl_slim_with_bb): Remove.\n+\t(print_rtl_slim): Rename to debug_rtl_slim.  Print only insn info,\n+\tnot basic block info (print_rtl_with_bb with TDF_SLIM should be used\n+\tfor that.  Prototype here near DEBUG_FUNCTION marker.\n+\t(debug_bb_slim): Prototype here near DEBUG_FUNCTION marker.\n+\tUse dump_bb.\n+\t(debug_bb_n_slim): Prototype here near DEBUG_FUNCTION marker.\n+\t* tree-cfg.c (gimple_can_merge_blocks_p): Use EDGE_COMPLEX.\n+\t(remove_bb): Update dump_bb call.\n+\t(gimple_debug_bb): Use dump_bb.\n+\t(dump_function_to_file): Update gimple_dump_bb call.\n+\t(print_loops_bb): Likewise.\n+\t* tree-flow.h (gimple_dump_bb): Update prototype.\n+\t* gimple-pretty-print.c (dump_bb_header): Rename to\n+\tdump_gimple_bb_header.  Write to a stream instead of a pretty\n+\tprinter.  Use dump_bb_info to dump basic block info.\n+\t(dump_bb_end): Rename to dump_gimple_bb_footer.  Write to a\n+\tstream instead of a pretty printer.  Use dump_bb_info.\n+\t(gimple_dump_bb_buff): Do not call dump_bb_header and dump_bb_end.\n+\t(gimple_dump_bb): Do it here with dump_gimple_bb_header and\n+\tdump_gimple_bb_footer.\n+\t* cfgrtl.c (rtl_dump_bb): Update prototype.  Only dump DF if the\n+\tdump flags have TDF_DETAILS.  Use dump_insn_slim if TDF_SLIM.\n+\t(print_rtl_with_bb): Take a flags argument and pass it around.\n+\tUse dump_insn_slim if TDF_SLIM.\n+\t(dump_bb_info): Removed and re-incarnated in cfg.c.\n+\t(dump_flow_info): Moved to cfghooks.c.\n+\t(debug_flow_info): Moved to cfghooks.c.\n+\t* passes.c (execute_function_dump): Unconditionally use\n+\tprint_rtl_with_bb for RTL dumps, now that it understands TDF_SLIM.\n+\t* final.c (dump_basic_block_info): Update dump_edge_info calls.\n+\t* tree-vrp.c (dump_asserts_for): Likewise.\n+\t* ifcvt.c (if_convert): Unconditionally use print_rtl_with_bb.\n+\t* tree-if-conv.c (if_convertible_bb_p): Don't look at\n+\tEDGE_ABNORMAL_CALL, it has no meaning in the GIMPLE world.\n+\t* trans-mem.c (make_tm_edge): Don't set EDGE_ABNORMAL_CALL,\n+\tfor the same reason.\n+\t* config/rl78/rl78.c (rl78_reorg): Update print_rtl_with_bb calls.\n+\n 2012-07-17  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-vect-data-refs.c (vect_get_new_vect_var): Add referenced"}, {"sha": "bf18baef139c99fbd502f5844778b56cd83c56e0", "filename": "gcc/basic-block.h", "status": "modified", "additions": 30, "deletions": 95, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -55,7 +55,7 @@ struct GTY(()) edge_def {\n      dest->preds.  */\n   unsigned int dest_idx;\n \n-  int flags;\t\t\t/* see EDGE_* below  */\n+  int flags;\t\t\t/* see cfg-flags.def */\n   int probability;\t\t/* biased by REG_BR_PROB_BASE */\n   gcov_type count;\t\t/* Expected number of executions calculated\n \t\t\t\t   in profile.c  */\n@@ -65,32 +65,20 @@ DEF_VEC_P(edge);\n DEF_VEC_ALLOC_P(edge,gc);\n DEF_VEC_ALLOC_P(edge,heap);\n \n-/* Always update the table in cfg.c dump_edge_info.  */\n-#define EDGE_FALLTHRU\t\t0x0001\t/* 'Straight line' flow */\n-#define EDGE_ABNORMAL\t\t0x0002\t/* Strange flow, like computed\n-\t\t\t\t\t   label, or eh */\n-#define EDGE_ABNORMAL_CALL\t0x0004\t/* Call with abnormal exit\n-\t\t\t\t\t   like an exception, or sibcall */\n-#define EDGE_EH\t\t\t0x0008\t/* Exception throw */\n-#define EDGE_FAKE\t\t0x0010\t/* Not a real edge (profile.c) */\n-#define EDGE_DFS_BACK\t\t0x0020\t/* A backwards edge */\n-#define EDGE_CAN_FALLTHRU\t0x0040\t/* Candidate for straight line\n-\t\t\t\t\t   flow.  */\n-#define EDGE_IRREDUCIBLE_LOOP\t0x0080\t/* Part of irreducible loop.  */\n-#define EDGE_SIBCALL\t\t0x0100\t/* Edge from sibcall to exit.  */\n-#define EDGE_LOOP_EXIT\t\t0x0200\t/* Exit of a loop.  */\n-#define EDGE_TRUE_VALUE\t\t0x0400\t/* Edge taken when controlling\n-\t\t\t\t\t   predicate is nonzero.  */\n-#define EDGE_FALSE_VALUE\t0x0800\t/* Edge taken when controlling\n-\t\t\t\t\t   predicate is zero.  */\n-#define EDGE_EXECUTABLE\t\t0x1000\t/* Edge is executable.  Only\n-\t\t\t\t\t   valid during SSA-CCP.  */\n-#define EDGE_CROSSING\t\t0x2000\t/* Edge crosses between hot\n-\t\t\t\t\t   and cold sections, when we\n-\t\t\t\t\t   do partitioning.  */\n-#define EDGE_PRESERVE\t\t0x4000\t/* Never merge blocks via this edge. */\n-#define EDGE_ALL_FLAGS\t\t0x7fff\n+/* Masks for edge.flags.  */\n+#define DEF_EDGE_FLAG(NAME,IDX) EDGE_##NAME = 1 << IDX ,\n+enum cfg_edge_flags {\n+#include \"cfg-flags.def\"\n+  LAST_CFG_EDGE_FLAG\t\t/* this is only used for EDGE_ALL_FLAGS */\n+};\n+#undef DEF_EDGE_FLAG\n+\n+/* Bit mask for all edge flags.  */\n+#define EDGE_ALL_FLAGS\t\t((LAST_CFG_EDGE_FLAG - 1) * 2 - 1)\n \n+/* The following four flags all indicate something special about an edge.\n+   Test the edge flags on EDGE_COMPLEX to detect all forms of \"strange\"\n+   control flow transfers.  */\n #define EDGE_COMPLEX \\\n   (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_EH | EDGE_PRESERVE)\n \n@@ -184,10 +172,12 @@ struct GTY((chain_next (\"%h.next_bb\"), chain_prev (\"%h.prev_bb\"))) basic_block_d\n   /* Expected frequency.  Normalized to be in range 0 to BB_FREQ_MAX.  */\n   int frequency;\n \n-  /* The discriminator for this block.  */\n+  /* The discriminator for this block.  The discriminator distinguishes\n+     among several basic blocks that share a common locus, allowing for\n+     more accurate sample-based profiling.  */\n   int discriminator;\n \n-  /* Various flags.  See BB_* below.  */\n+  /* Various flags.  See cfg-flags.def.  */\n   int flags;\n };\n \n@@ -204,74 +194,19 @@ DEF_VEC_ALLOC_P(basic_block,heap);\n \n #define BB_FREQ_MAX 10000\n \n-/* Masks for basic_block.flags.\n-\n-   BB_HOT_PARTITION and BB_COLD_PARTITION should be preserved throughout\n-   the compilation, so they are never cleared.\n-\n-   All other flags may be cleared by clear_bb_flags().  It is generally\n-   a bad idea to rely on any flags being up-to-date.\n-\n-   Always update the table in cfg.c dump_bb_info.  */\n-\n-enum bb_flags\n+/* Masks for basic_block.flags.  */\n+#define DEF_BASIC_BLOCK_FLAG(NAME,IDX) BB_##NAME = 1 << IDX ,\n+enum cfg_bb_flags\n {\n-  /* Only set on blocks that have just been created by create_bb.  */\n-  BB_NEW = 1 << 0,\n-\n-  /* Set by find_unreachable_blocks.  Do not rely on this being set in any\n-     pass.  */\n-  BB_REACHABLE = 1 << 1,\n-\n-  /* Set for blocks in an irreducible loop by loop analysis.  */\n-  BB_IRREDUCIBLE_LOOP = 1 << 2,\n-\n-  /* Set on blocks that may actually not be single-entry single-exit block.  */\n-  BB_SUPERBLOCK = 1 << 3,\n-\n-  /* Set on basic blocks that the scheduler should not touch.  This is used\n-     by SMS to prevent other schedulers from messing with the loop schedule.  */\n-  BB_DISABLE_SCHEDULE = 1 << 4,\n-\n-  /* Set on blocks that should be put in a hot section.  */\n-  BB_HOT_PARTITION = 1 << 5,\n-\n-  /* Set on blocks that should be put in a cold section.  */\n-  BB_COLD_PARTITION = 1 << 6,\n-\n-  /* Set on block that was duplicated.  */\n-  BB_DUPLICATED = 1 << 7,\n-\n-  /* Set if the label at the top of this block is the target of a non-local goto.  */\n-  BB_NON_LOCAL_GOTO_TARGET = 1 << 8,\n-\n-  /* Set on blocks that are in RTL format.  */\n-  BB_RTL = 1 << 9 ,\n-\n-  /* Set on blocks that are forwarder blocks.\n-     Only used in cfgcleanup.c.  */\n-  BB_FORWARDER_BLOCK = 1 << 10,\n-\n-  /* Set on blocks that cannot be threaded through.\n-     Only used in cfgcleanup.c.  */\n-  BB_NONTHREADABLE_BLOCK = 1 << 11,\n-\n-  /* Set on blocks that were modified in some way.  This bit is set in\n-     df_set_bb_dirty, but not cleared by df_analyze, so it can be used\n-     to test whether a block has been modified prior to a df_analyze\n-     call.  */\n-  BB_MODIFIED = 1 << 12,\n-\n-  /* A general visited flag for passes to use.  */\n-  BB_VISITED = 1 << 13,\n-\n-  /* Set on blocks that are in a transaction.  This is calculated on\n-     demand, and is available after calling\n-     compute_transaction_bits().  */\n-  BB_IN_TRANSACTION = 1 << 14\n+#include \"cfg-flags.def\"\n+  LAST_CFG_BB_FLAG\t\t/* this is only used for BB_ALL_FLAGS */\n };\n+#undef DEF_BASIC_BLOCK_FLAG\n+\n+/* Bit mask for all edge flags.  */\n+#define BB_ALL_FLAGS\t\t((LAST_CFG_BB_FLAG - 1) * 2 - 1)\n \n-/* Dummy flag for convenience in the hot/cold partitioning code.  */\n+/* Dummy bitmask for convenience in the hot/cold partitioning code.  */\n #define BB_UNPARTITIONED\t0\n \n /* Partitions, to be used when partitioning hot and cold basic blocks into\n@@ -458,8 +393,8 @@ extern edge redirect_edge_succ_nodup (edge, basic_block);\n extern void redirect_edge_pred (edge, basic_block);\n extern basic_block create_basic_block_structure (rtx, rtx, rtx, basic_block);\n extern void clear_bb_flags (void);\n-extern void dump_bb_info (basic_block, bool, bool, bool, const char *, FILE *);\n-extern void dump_edge_info (FILE *, edge, int);\n+extern void dump_bb_info (FILE *, basic_block, int, int, bool, bool);\n+extern void dump_edge_info (FILE *, edge, int, int);\n extern void brief_dump_cfg (FILE *);\n extern void clear_edges (void);\n extern void scale_bbs_frequencies_int (basic_block *, int, int, int);"}, {"sha": "a9aaf186ec1343d99da470e3b763fbe20262b521", "filename": "gcc/cfg-flags.def", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fcfg-flags.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fcfg-flags.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg-flags.def?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -0,0 +1,179 @@\n+/* Flags on basic blocks and edges.\n+   Copyright (C) 2012  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This file defines flags that may appear on basic blocks or on\n+   edges.  Source files define DEF_BASIC_BLOCK_FLAG or DEF_EDGE_FLAG\n+   appropriately before including this file.  */\n+\n+#if !defined(DEF_BASIC_BLOCK_FLAG) && !defined(DEF_EDGE_FLAG)\n+#error \"You must define DEF_BASIC_BLOCK_FLAG or DEF_EDGE_FLAG\"\n+#endif\n+\n+#ifdef DEF_BASIC_BLOCK_FLAG\n+\n+/* Masks for basic_block.flags.\n+\n+   The format of this file is: DEF_BASIC_BLOCK_FLAG(NAME, IDX).\n+   NAME is the name of the basic block flag.  A flag BB_#NAME will be\n+   created and the name is used in dump_edge_info.\n+   IDX is a sequence number that is used to determine the value\n+   of the flag, which is 1 << IDX).\n+\n+   BB_HOT_PARTITION and BB_COLD_PARTITION should be preserved throughout\n+   the compilation, so they are never cleared.\n+\n+   All other flags may be cleared by clear_bb_flags().  It is generally\n+   a bad idea to rely on any flags being up-to-date.  */\n+\n+/* Only set on blocks that have just been created by create_bb.  */\n+DEF_BASIC_BLOCK_FLAG(NEW, 0)\n+\n+/* Set by find_unreachable_blocks.  Do not rely on this being set in any\n+   pass.  */\n+DEF_BASIC_BLOCK_FLAG(REACHABLE, 1)\n+\n+/* Set for blocks in an irreducible loop by loop analysis.  */\n+DEF_BASIC_BLOCK_FLAG(IRREDUCIBLE_LOOP, 2)\n+\n+/* Set on blocks that may actually not be single-entry single-exit block.  */\n+DEF_BASIC_BLOCK_FLAG(SUPERBLOCK, 3)\n+\n+/* Set on basic blocks that the scheduler should not touch.  This is used\n+   by SMS to prevent other schedulers from messing with the loop schedule.  */\n+DEF_BASIC_BLOCK_FLAG(DISABLE_SCHEDULE, 4)\n+\n+/* Set on blocks that should be put in a hot section.  */\n+DEF_BASIC_BLOCK_FLAG(HOT_PARTITION, 5)\n+\n+/* Set on blocks that should be put in a cold section.  */\n+DEF_BASIC_BLOCK_FLAG(COLD_PARTITION, 6)\n+\n+/* Set on block that was duplicated.  */\n+DEF_BASIC_BLOCK_FLAG(DUPLICATED, 7)\n+\n+/* Set if the label at the top of this block is the target of a non-local goto.  */\n+DEF_BASIC_BLOCK_FLAG(NON_LOCAL_GOTO_TARGET, 8)\n+\n+/* Set on blocks that are in RTL format.  */\n+DEF_BASIC_BLOCK_FLAG(RTL, 9) \n+\n+/* Set on blocks that are forwarder blocks.\n+   Only used in cfgcleanup.c.  */\n+DEF_BASIC_BLOCK_FLAG(FORWARDER_BLOCK, 10)\n+\n+/* Set on blocks that cannot be threaded through.\n+   Only used in cfgcleanup.c.  */\n+DEF_BASIC_BLOCK_FLAG(NONTHREADABLE_BLOCK, 11)\n+\n+/* Set on blocks that were modified in some way.  This bit is set in\n+   df_set_bb_dirty, but not cleared by df_analyze, so it can be used\n+   to test whether a block has been modified prior to a df_analyze call.  */\n+DEF_BASIC_BLOCK_FLAG(MODIFIED, 12)\n+\n+/* A general visited flag for passes to use.  */\n+DEF_BASIC_BLOCK_FLAG(VISITED, 13)\n+\n+/* Set on blocks that are in a transaction.  This is calculated on\n+   demand, and is available after calling\n+   compute_transaction_bits().  */\n+DEF_BASIC_BLOCK_FLAG(IN_TRANSACTION, 14)\n+\n+#endif\n+\n+#ifdef DEF_EDGE_FLAG\n+\n+/* Masks for edge.flags.\n+\n+   The format of this file is: DEF_EDGE_FLAG(NAME, IDX, STRING).\n+   NAME is the name of the edge flag.  A flag EDGE_#NAME will be\n+   created and the name is used in dump_edge_info.\n+   IDX is a sequence number that is used to determine the value\n+   of the flag, which is 1 << IDX).  */\n+\n+/* 'Straight line' flow.  In GIMPLE and in cfglayout mode, all normal\n+   edges are fallthru edges.  In cfgrtl mode, this flag really means\n+   that control flow falls through to the next basic block in the line.  */\n+DEF_EDGE_FLAG(FALLTHRU, 0)\n+\n+/* Strange flow, like a computed jump or exception handling.  Usually\n+   this means that the edge cannot be split.  */\n+DEF_EDGE_FLAG(ABNORMAL, 1)\n+\n+/* Edge out of a basic block that ends with a CALL_INSN with abnormal\n+   exit, like an exception, or a sibcall.\n+   This flag is only used for the RTL CFG.  */\n+DEF_EDGE_FLAG(ABNORMAL_CALL, 2)\n+\n+/* Exception edge.  Exception handling edges represent possible control\n+   transfers from a trapping instruction to an exception handler.  EH\n+   edges also have EDGE_ABNORMAL set.  */\n+DEF_EDGE_FLAG(EH, 3)\n+\n+/* Never merge blocks via this edge.  This is used for exception handling,\n+   to prevent merging away edges to the post-landing-pad basic block.\n+   This flag is only used for the RTL CFG.  */\n+DEF_EDGE_FLAG(PRESERVE, 4)\n+\n+/* Not a real edge.  This is used to connect parts of the CFG that do\n+   not halt, such as infinite loops and noreturn functions, to the\n+   EXIT_BLOCK, so that traversing of the reverse CFG is possible.  */\n+DEF_EDGE_FLAG(FAKE, 5)\n+\n+/* A back edge, marked in a depth-first search of the CFG.  Back edges\n+   are hints that this edge may be part of a loop in the CFG.  */\n+DEF_EDGE_FLAG(DFS_BACK, 6)\n+\n+/* Edge in a part of the CFG that is an irreducible loop.  */\n+DEF_EDGE_FLAG(IRREDUCIBLE_LOOP, 7)\n+\n+/* Edge taken when controlling predicate is nonzero.\n+   This is only used for the GIMPLE CFG.  */\n+DEF_EDGE_FLAG(TRUE_VALUE, 8)\n+\n+/* Edge taken when controlling predicate is zero.\n+   This is only used for the GIMPLE CFG.  */\n+DEF_EDGE_FLAG(FALSE_VALUE, 9)\n+\n+/* Edge is executable.  This is only used in GIMPLE SSA-CCP and VRP.\n+   This is only used for the GIMPLE CFG.  */\n+DEF_EDGE_FLAG(EXECUTABLE, 10)\n+\n+/* Edge crosses between hot and cold sections, when we do partitioning.\n+   This flag is only used for the RTL CFG.  */\n+DEF_EDGE_FLAG(CROSSING, 11)\n+\n+/* Edge from a sibcall CALL_INSN to exit.\n+   This flag is only used for the RTL CFG.  */\n+DEF_EDGE_FLAG(SIBCALL, 12)\n+\n+/* Candidate for straight line flow.  Only used in bb-reorder.c.\n+   This flag is only used for the RTL CFG.  */\n+DEF_EDGE_FLAG(CAN_FALLTHRU, 13)\n+\n+/* Exit of a loop.  This is only used in ifcvt.c.\n+   This flag is only used for the RTL CFG.  */\n+DEF_EDGE_FLAG(LOOP_EXIT, 14)\n+\n+#endif\n+\n+/*\n+Local variables:\n+mode:c\n+End:\n+*/"}, {"sha": "fc16ecd7f7dfa67d05c65468fc5364c2edcc2391", "filename": "gcc/cfg.c", "status": "modified", "additions": 113, "deletions": 50, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -444,9 +444,15 @@ check_bb_profile (basic_block bb, FILE * file)\n }\n \f\n void\n-dump_edge_info (FILE *file, edge e, int do_succ)\n+dump_edge_info (FILE *file, edge e, int flags, int do_succ)\n {\n   basic_block side = (do_succ ? e->dest : e->src);\n+  bool do_details = false;\n+  \n+  if ((flags & TDF_DETAILS) != 0\n+      && (flags & TDF_SLIM) == 0)\n+    do_details = true;\n+\n   /* ENTRY_BLOCK_PTR/EXIT_BLOCK_PTR depend on cfun.\n      Compare against ENTRY_BLOCK/EXIT_BLOCK to avoid that dependency.  */\n   if (side->index == ENTRY_BLOCK)\n@@ -456,25 +462,28 @@ dump_edge_info (FILE *file, edge e, int do_succ)\n   else\n     fprintf (file, \" %d\", side->index);\n \n-  if (e->probability)\n+  if (e->probability && do_details)\n     fprintf (file, \" [%.1f%%] \", e->probability * 100.0 / REG_BR_PROB_BASE);\n \n-  if (e->count)\n+  if (e->count && do_details)\n     {\n       fputs (\" count:\", file);\n       fprintf (file, HOST_WIDEST_INT_PRINT_DEC, e->count);\n     }\n \n-  if (e->flags)\n+  if (e->flags && do_details)\n     {\n-      static const char * const bitnames[] = {\n-\t\"fallthru\", \"ab\", \"abcall\", \"eh\", \"fake\", \"dfs_back\",\n-\t\"can_fallthru\", \"irreducible\", \"sibcall\", \"loop_exit\",\n-\t\"true\", \"false\", \"exec\", \"crossing\", \"preserve\"\n-      };\n-      int comma = 0;\n+      static const char * const bitnames[] =\n+\t{\n+#define DEF_EDGE_FLAG(NAME,IDX) #NAME ,\n+#include \"cfg-flags.def\"\n+\t  NULL\n+#undef DEF_EDGE_FLAG\n+\t};\n+      bool comma = false;\n       int i, flags = e->flags;\n \n+      gcc_assert (e->flags <= EDGE_ALL_FLAGS);\n       fputs (\" (\", file);\n       for (i = 0; flags; i++)\n \tif (flags & (1 << i))\n@@ -483,11 +492,8 @@ dump_edge_info (FILE *file, edge e, int do_succ)\n \n \t    if (comma)\n \t      fputc (',', file);\n-\t    if (i < (int) ARRAY_SIZE (bitnames))\n-\t      fputs (bitnames[i], file);\n-\t    else\n-\t      fprintf (file, \"%d\", i);\n-\t    comma = 1;\n+\t    fputs (bitnames[i], file);\n+\t    comma = true;\n \t  }\n \n       fputc (')', file);\n@@ -641,57 +647,114 @@ free_aux_for_edges (void)\n DEBUG_FUNCTION void\n debug_bb (basic_block bb)\n {\n-  dump_bb (bb, stderr, 0);\n+  dump_bb (stderr, bb, 0, dump_flags | TDF_BLOCKS);\n }\n \n DEBUG_FUNCTION basic_block\n debug_bb_n (int n)\n {\n   basic_block bb = BASIC_BLOCK (n);\n-  dump_bb (bb, stderr, 0);\n+  debug_bb (bb);\n   return bb;\n }\n \n-/* Dumps cfg related information about basic block BB to FILE.  */\n+/* Dumps cfg related information about basic block BB to OUTF.\n+   If HEADER is true, dump things that appear before the instructions\n+   contained in BB.  If FOOTER is true, dump things that appear after.\n+   Flags are the TDF_* masks as documented in dumpfile.h.\n+   NB: With TDF_DETAILS, it is assumed that cfun is available, so\n+   that maybe_hot_bb_p and probably_never_executed_bb_p don't ICE.  */\n \n-static void\n-dump_cfg_bb_info (FILE *file, basic_block bb)\n+void\n+dump_bb_info (FILE *outf, basic_block bb, int indent, int flags,\n+\t      bool do_header, bool do_footer)\n {\n-  unsigned i;\n   edge_iterator ei;\n-  bool first = true;\n+  edge e;\n   static const char * const bb_bitnames[] =\n     {\n-      \"new\", \"reachable\", \"irreducible_loop\", \"superblock\",\n-      \"nosched\", \"hot\", \"cold\", \"dup\", \"xlabel\", \"rtl\",\n-      \"fwdr\", \"nothrd\"\n+#define DEF_BASIC_BLOCK_FLAG(NAME,IDX) #NAME ,\n+#include \"cfg-flags.def\"\n+      NULL\n+#undef DEF_BASIC_BLOCK_FLAG\n     };\n   const unsigned n_bitnames = sizeof (bb_bitnames) / sizeof (char *);\n-  edge e;\n+  char *s_indent = (char *) alloca ((size_t) indent + 1);\n+  memset ((void *) s_indent, ' ', (size_t) indent);\n+  s_indent[indent] = '\\0';\n \n-  fprintf (file, \"Basic block %d\", bb->index);\n-  for (i = 0; i < n_bitnames; i++)\n-    if (bb->flags & (1 << i))\n-      {\n-\tif (first)\n-\t  fputs (\" (\", file);\n-\telse\n-\t  fputs (\", \", file);\n-\tfirst = false;\n-\tfputs (bb_bitnames[i], file);\n-      }\n-  if (!first)\n-    putc (')', file);\n-  putc ('\\n', file);\n-\n-  fputs (\"Predecessors: \", file);\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    dump_edge_info (file, e, 0);\n-\n-  fprintf (file, \"\\nSuccessors: \");\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    dump_edge_info (file, e, 1);\n-  fputs (\"\\n\\n\", file);\n+  gcc_assert (bb->flags <= BB_ALL_FLAGS);\n+\n+  if (do_header)\n+    {\n+      unsigned i;\n+\n+      if (flags & TDF_COMMENT)\n+\tfputs (\";; \", outf);\n+      fprintf (outf, \"%sbasic block %d\", s_indent, bb->index);\n+      if (flags & TDF_DETAILS)\n+\t{\n+\t  fprintf (outf, \", loop depth %d, count \" HOST_WIDEST_INT_PRINT_DEC,\n+\t\t   bb->loop_depth, (HOST_WIDEST_INT) bb->count);\n+\t  fprintf (outf, \", freq %i\", bb->frequency);\n+\t  if (maybe_hot_bb_p (bb))\n+\t    fputs (\", maybe hot\", outf);\n+\t  if (probably_never_executed_bb_p (bb))\n+\t    fputs (\", probably never executed\", outf);\n+\t}\n+      fputc ('\\n', outf);\n+\n+      if (flags & TDF_DETAILS)\n+\t{\n+\t  bool first = true;\n+\n+\t  if (flags & TDF_COMMENT)\n+\t    fputs (\";; \", outf);\n+\t  fprintf (outf, \"%s prev block \", s_indent);\n+\t  if (bb->prev_bb)\n+\t    fprintf (outf, \"%d\", bb->prev_bb->index);\n+\t  else\n+\t    fprintf (outf, \"(nil)\");\n+\t  fprintf (outf, \", next block \");\n+\t  if (bb->next_bb)\n+\t    fprintf (outf, \"%d\", bb->next_bb->index);\n+\t  else\n+\t    fprintf (outf, \"(nil)\");\n+\n+\t  fputs (\", flags:\", outf);\n+\t  for (i = 0; i < n_bitnames; i++)\n+\t    if (bb->flags & (1 << i))\n+\t      {\n+\t\tif (first)\n+\t\t  fputs (\" (\", outf);\n+\t\telse\n+\t\t  fputs (\", \", outf);\n+\t\tfirst = false;\n+\t\tfputs (bb_bitnames[i], outf);\n+\t      }\n+\t  if (!first)\n+\t    fputc (')', outf);\n+\t}\n+      fputc ('\\n', outf);\n+\n+      if (flags & TDF_COMMENT)\n+\tfputs (\";; \", outf);\n+      fprintf (outf, \"%s pred:      \", s_indent);\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tdump_edge_info (outf, e, flags, 0);\n+      fputc ('\\n', outf);\n+    }\n+\n+  if (do_footer)\n+    {\n+      fputc ('\\n', outf);\n+      if (flags & TDF_COMMENT)\n+\tfputs (\";; \", outf);\n+      fprintf (outf, \"%s succ:      \", s_indent);\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tdump_edge_info (outf, e, flags, 1);\n+      fputs (\"\\n\\n\", outf);\n+    }\n }\n \n /* Dumps a brief description of cfg to FILE.  */\n@@ -703,7 +766,7 @@ brief_dump_cfg (FILE *file)\n \n   FOR_EACH_BB (bb)\n     {\n-      dump_cfg_bb_info (file, bb);\n+      dump_bb_info (file, bb, 0, 0, true, true);\n     }\n }\n "}, {"sha": "69655390102f74220b5ac444dcdcd4908ef2acc1", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 37, "deletions": 43, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"dumpfile.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n@@ -183,9 +184,9 @@ verify_flow_info (void)\n \t      error (\"verify_flow_info: Basic block %d succ edge is corrupted\",\n \t\t     bb->index);\n \t      fprintf (stderr, \"Predecessor: \");\n-\t      dump_edge_info (stderr, e, 0);\n+\t      dump_edge_info (stderr, e, TDF_DETAILS, 0);\n \t      fprintf (stderr, \"\\nSuccessor: \");\n-\t      dump_edge_info (stderr, e, 1);\n+\t      dump_edge_info (stderr, e, TDF_DETAILS, 1);\n \t      fprintf (stderr, \"\\n\");\n \t      err = 1;\n \t    }\n@@ -204,9 +205,9 @@ verify_flow_info (void)\n \t    {\n \t      error (\"basic block %d pred edge is corrupted\", bb->index);\n \t      fputs (\"Predecessor: \", stderr);\n-\t      dump_edge_info (stderr, e, 0);\n+\t      dump_edge_info (stderr, e, TDF_DETAILS, 0);\n \t      fputs (\"\\nSuccessor: \", stderr);\n-\t      dump_edge_info (stderr, e, 1);\n+\t      dump_edge_info (stderr, e, TDF_DETAILS, 1);\n \t      fputc ('\\n', stderr);\n \t      err = 1;\n \t    }\n@@ -217,9 +218,9 @@ verify_flow_info (void)\n \t      error (\"its dest_idx should be %d, not %d\",\n \t\t     ei.index, e->dest_idx);\n \t      fputs (\"Predecessor: \", stderr);\n-\t      dump_edge_info (stderr, e, 0);\n+\t      dump_edge_info (stderr, e, TDF_DETAILS, 0);\n \t      fputs (\"\\nSuccessor: \", stderr);\n-\t      dump_edge_info (stderr, e, 1);\n+\t      dump_edge_info (stderr, e, TDF_DETAILS, 1);\n \t      fputc ('\\n', stderr);\n \t      err = 1;\n \t    }\n@@ -260,50 +261,43 @@ verify_flow_info (void)\n   timevar_pop (TV_CFG_VERIFY);\n }\n \n-/* Print out one basic block.  This function takes care of the purely\n-   graph related information.  The cfg hook for the active representation\n-   should dump representation-specific information.  */\n+/* Print out one basic block BB to file OUTF.  INDENT is printed at the\n+   start of each new line.  FLAGS are the TDF_* flags in dumpfile.h.\n+\n+   This function takes care of the purely graph related information.\n+   The cfg hook for the active representation should dump\n+   representation-specific information.  */\n \n void\n-dump_bb (basic_block bb, FILE *outf, int indent)\n+dump_bb (FILE *outf, basic_block bb, int indent, int flags)\n {\n-  edge e;\n-  edge_iterator ei;\n-  char *s_indent;\n-\n-  s_indent = (char *) alloca ((size_t) indent + 1);\n-  memset (s_indent, ' ', (size_t) indent);\n-  s_indent[indent] = '\\0';\n-\n-  fprintf (outf, \";;%s basic block %d, loop depth %d, count \",\n-\t   s_indent, bb->index, bb->loop_depth);\n-  fprintf (outf, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT) bb->count);\n-  putc ('\\n', outf);\n+  dump_bb_info (outf, bb, indent, flags | TDF_COMMENT, true, true);\n+  if (cfg_hooks->dump_bb)\n+    cfg_hooks->dump_bb (outf, bb, indent, flags);\n+}\n \n-  fprintf (outf, \";;%s prev block \", s_indent);\n-  if (bb->prev_bb)\n-    fprintf (outf, \"%d, \", bb->prev_bb->index);\n-  else\n-    fprintf (outf, \"(nil), \");\n-  fprintf (outf, \"next block \");\n-  if (bb->next_bb)\n-    fprintf (outf, \"%d\", bb->next_bb->index);\n-  else\n-    fprintf (outf, \"(nil)\");\n-  putc ('\\n', outf);\n+/* Dump the complete CFG to FILE.  FLAGS are the TDF_* flags in dumpfile.h.  */\n+void\n+dump_flow_info (FILE *file, int flags)\n+{\n+  basic_block bb;\n \n-  fprintf (outf, \";;%s pred:      \", s_indent);\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    dump_edge_info (outf, e, 0);\n-  putc ('\\n', outf);\n+  fprintf (file, \"\\n%d basic blocks, %d edges.\\n\", n_basic_blocks, n_edges);\n+  FOR_ALL_BB (bb)\n+    {\n+      dump_bb (file, bb, 0, flags);\n+      check_bb_profile (bb, file);\n+    }\n \n-  fprintf (outf, \";;%s succ:      \", s_indent);\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    dump_edge_info (outf, e, 1);\n-  putc ('\\n', outf);\n+  putc ('\\n', file);\n+}\n \n-  if (cfg_hooks->dump_bb)\n-    cfg_hooks->dump_bb (bb, outf, indent, 0);\n+/* Like above, but dump to stderr.  To be called from debuggers.  */\n+void debug_flow_info (void);\n+DEBUG_FUNCTION void\n+debug_flow_info (void)\n+{\n+  dump_flow_info (stderr, TDF_DETAILS);\n }\n \n /* Redirect edge E to the given basic block DEST and update underlying program"}, {"sha": "cd4bd4165ec864657bb5629c2473aaf29feb3e3e", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -28,7 +28,7 @@ struct cfg_hooks\n \n   /* Debugging.  */\n   int (*verify_flow_info) (void);\n-  void (*dump_bb) (basic_block, FILE *, int, int);\n+  void (*dump_bb) (FILE *, basic_block, int, int);\n \n   /* Basic CFG manipulation.  */\n \n@@ -141,7 +141,7 @@ struct cfg_hooks\n };\n \n extern void verify_flow_info (void);\n-extern void dump_bb (basic_block, FILE *, int);\n+extern void dump_bb (FILE *, basic_block, int, int);\n extern edge redirect_edge_and_branch (edge, basic_block);\n extern basic_block redirect_edge_and_branch_force (edge, basic_block);\n extern bool can_remove_branch_p (const_edge);"}, {"sha": "e87f06db3a0cb6459b9976897f1e26cba5caf4bf", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 23, "deletions": 123, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -88,7 +88,7 @@ static void rtl_delete_block (basic_block);\n static basic_block rtl_redirect_edge_and_branch_force (edge, basic_block);\n static edge rtl_redirect_edge_and_branch (edge, basic_block);\n static basic_block rtl_split_block (basic_block, void *);\n-static void rtl_dump_bb (basic_block, FILE *, int, int);\n+static void rtl_dump_bb (FILE *, basic_block, int, int);\n static int rtl_verify_flow_info_1 (void);\n static void rtl_make_forwarder_block (edge);\n \f\n@@ -1836,10 +1836,11 @@ commit_edge_insertions (void)\n \f\n \n /* Print out RTL-specific basic block information (live information\n-   at start and end).  */\n+   at start and end with TDF_DETAILS).  FLAGS are the TDF_* masks\n+   documented in dumpfile.h.  */\n \n static void\n-rtl_dump_bb (basic_block bb, FILE *outf, int indent, int flags ATTRIBUTE_UNUSED)\n+rtl_dump_bb (FILE *outf, basic_block bb, int indent, int flags)\n {\n   rtx insn;\n   rtx last;\n@@ -1849,7 +1850,7 @@ rtl_dump_bb (basic_block bb, FILE *outf, int indent, int flags ATTRIBUTE_UNUSED)\n   memset (s_indent, ' ', (size_t) indent);\n   s_indent[indent] = '\\0';\n \n-  if (df)\n+  if (df && (flags & TDF_DETAILS))\n     {\n       df_dump_top (bb, outf);\n       putc ('\\n', outf);\n@@ -1858,9 +1859,15 @@ rtl_dump_bb (basic_block bb, FILE *outf, int indent, int flags ATTRIBUTE_UNUSED)\n   if (bb->index != ENTRY_BLOCK && bb->index != EXIT_BLOCK)\n     for (insn = BB_HEAD (bb), last = NEXT_INSN (BB_END (bb)); insn != last;\n \t insn = NEXT_INSN (insn))\n-      print_rtl_single (outf, insn);\n+      {\n+\tif (! (flags & TDF_SLIM))\n+\t  print_rtl_single (outf, insn);\n+\telse\n+\t  dump_insn_slim (outf, insn);\n+\n+      }\n \n-  if (df)\n+  if (df && (flags & TDF_DETAILS))\n     {\n       df_dump_bottom (bb, outf);\n       putc ('\\n', outf);\n@@ -1869,10 +1876,10 @@ rtl_dump_bb (basic_block bb, FILE *outf, int indent, int flags ATTRIBUTE_UNUSED)\n }\n \f\n /* Like print_rtl, but also print out live information for the start of each\n-   basic block.  */\n+   basic block.  FLAGS are the flags documented in dumpfile.h.  */\n \n void\n-print_rtl_with_bb (FILE *outf, const_rtx rtx_first)\n+print_rtl_with_bb (FILE *outf, const_rtx rtx_first, int flags)\n {\n   const_rtx tmp_rtx;\n   if (rtx_first == 0)\n@@ -1911,12 +1918,9 @@ print_rtl_with_bb (FILE *outf, const_rtx rtx_first)\n \n       for (tmp_rtx = rtx_first; NULL != tmp_rtx; tmp_rtx = NEXT_INSN (tmp_rtx))\n \t{\n-\t  int did_output;\n-\t  bool verbose = ((dump_flags & TDF_DETAILS) != 0);\n-\n \t  bb = start[INSN_UID (tmp_rtx)];\n \t  if (bb != NULL)\n-\t    dump_bb_info (bb, true, false, verbose, \";; \", outf);\n+\t    dump_bb_info (outf, bb, 0, dump_flags | TDF_COMMENT, true, false);\n \n \t  if (in_bb_p[INSN_UID (tmp_rtx)] == NOT_IN_BB\n \t      && !NOTE_P (tmp_rtx)\n@@ -1925,13 +1929,16 @@ print_rtl_with_bb (FILE *outf, const_rtx rtx_first)\n \t  else if (in_bb_p[INSN_UID (tmp_rtx)] == IN_MULTIPLE_BB)\n \t    fprintf (outf, \";; Insn is in multiple basic blocks\\n\");\n \n-\t  did_output = print_rtl_single (outf, tmp_rtx);\n+\t  if (! (flags & TDF_SLIM))\n+\t    print_rtl_single (outf, tmp_rtx);\n+\t  else\n+\t    dump_insn_slim (outf, tmp_rtx);\n \n \t  bb = end[INSN_UID (tmp_rtx)];\n \t  if (bb != NULL)\n-\t    dump_bb_info (bb, false, true, verbose, \";; \", outf);\n-\t  if (did_output)\n-\t    putc ('\\n', outf);\n+\t    dump_bb_info (outf, bb, 0, dump_flags | TDF_COMMENT, false, true);\n+\n+\t  putc ('\\n', outf);\n \t}\n \n       free (start);\n@@ -1948,113 +1955,6 @@ print_rtl_with_bb (FILE *outf, const_rtx rtx_first)\n     }\n }\n \f\n-/* Emit basic block information for BB.  HEADER is true if the user wants\n-   the generic information and the predecessors, FOOTER is true if they want\n-   the successors.  If VERBOSE is true, emit global register liveness\n-   information.  PREFIX is put in front of every line.  The output is emitted\n-   to FILE.  This function should only be called by RTL CFG users.  */\n-/* FIXME: Dumping of the basic block shared info (index, prev, next, etc.)\n-   is done here and also in dump_bb_header (but to a pretty-printer buffer).\n-   This should be re-factored to give similar dumps for RTL and GIMPLE.  */\n-\n-void\n-dump_bb_info (basic_block bb, bool header, bool footer, bool verbose,\n-\t      const char *prefix, FILE *file)\n-{\n-  edge e;\n-  edge_iterator ei;\n-\n-  if (header)\n-    {\n-      fprintf (file, \"\\n%sBasic block %d \", prefix, bb->index);\n-      if (bb->prev_bb)\n-        fprintf (file, \", prev %d\", bb->prev_bb->index);\n-      if (bb->next_bb)\n-        fprintf (file, \", next %d\", bb->next_bb->index);\n-      fprintf (file, \", loop_depth %d, count \", bb->loop_depth);\n-      fprintf (file, HOST_WIDEST_INT_PRINT_DEC, bb->count);\n-      fprintf (file, \", freq %i\", bb->frequency);\n-      if (maybe_hot_bb_p (bb))\n-\tfputs (\", maybe hot\", file);\n-      if (probably_never_executed_bb_p (bb))\n-\tfputs (\", probably never executed\", file);\n-      if (bb->flags)\n-\t{\n-\t  static const char * const bits[] = {\n-\t    \"new\", \"reachable\", \"irr_loop\", \"superblock\", \"disable_sched\",\n-\t    \"hot_partition\", \"cold_partition\", \"duplicated\",\n-\t    \"non_local_goto_target\", \"rtl\", \"forwarder\", \"nonthreadable\",\n-\t    \"modified\"\n-\t  };\n-\t  unsigned int flags;\n-\n-\t  fputs (\", flags:\", file);\n-\t  for (flags = bb->flags; flags ; flags &= flags - 1)\n-\t    {\n-\t      unsigned i = ctz_hwi (flags);\n-\t      if (i < ARRAY_SIZE (bits))\n-\t\tfprintf (file, \" %s\", bits[i]);\n-\t      else\n-\t\tfprintf (file, \" <%d>\", i);\n-\t    }\n-\t}\n-      fputs (\".\\n\", file);\n-\n-      fprintf (file, \"%sPredecessors: \", prefix);\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\tdump_edge_info (file, e, 0);\n-\n-      if (verbose\n-\t  && (bb->flags & BB_RTL)\n-\t  && df)\n-\t{\n-\t  putc ('\\n', file);\n-\t  df_dump_top (bb, file);\n-\t}\n-   }\n-\n-  if (footer)\n-    {\n-      fprintf (file, \"\\n%sSuccessors: \", prefix);\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\tdump_edge_info (file, e, 1);\n-\n-      if (verbose\n-\t  && (bb->flags & BB_RTL)\n-\t  && df)\n-\t{\n-\t  putc ('\\n', file);\n-\t  df_dump_bottom (bb, file);\n-\t}\n-   }\n-\n-  putc ('\\n', file);\n-}\n-\n-\n-void\n-dump_flow_info (FILE *file, int flags)\n-{\n-  basic_block bb;\n-  bool verbose = ((flags & TDF_DETAILS) != 0);\n-\n-  fprintf (file, \"\\n%d basic blocks, %d edges.\\n\", n_basic_blocks, n_edges);\n-  FOR_ALL_BB (bb)\n-    {\n-      dump_bb_info (bb, true, true, verbose, \"\", file);\n-      check_bb_profile (bb, file);\n-    }\n-\n-  putc ('\\n', file);\n-}\n-\n-void debug_flow_info (void);\n-DEBUG_FUNCTION void\n-debug_flow_info (void)\n-{\n-  dump_flow_info (stderr, TDF_DETAILS);\n-}\n-\f\n /* Update the branch probability of BB if a REG_BR_PROB is present.  */\n \n void"}, {"sha": "df41a85278a4ec7605b6c5dcef742a42212a2648", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -2663,7 +2663,7 @@ rl78_reorg (void)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\n================DEVIRT:=AFTER=ALLOC=PHYSICAL=REGISTERS================\\n\");\n-      print_rtl_with_bb (dump_file, get_insns ());\n+      print_rtl_with_bb (dump_file, get_insns (), 0);\n     }\n \n   rl78_propogate_register_origins ();\n@@ -2672,7 +2672,7 @@ rl78_reorg (void)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\n================DEVIRT:=AFTER=PROPOGATION=============================\\n\");\n-      print_rtl_with_bb (dump_file, get_insns ());\n+      print_rtl_with_bb (dump_file, get_insns (), 0);\n       fprintf (dump_file, \"\\n======================================================================\\n\");\n     }\n "}, {"sha": "2ea3901b32e73d2fc88e5fad30807fa6e60a0bd5", "filename": "gcc/dumpfile.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fdumpfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fdumpfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.h?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -81,6 +81,7 @@ enum tree_dump_index\n #define TDF_ENUMERATE_LOCALS (1 << 22)\t/* Enumerate locals by uid.  */\n #define TDF_CSELIB\t(1 << 23)\t/* Dump cselib details.  */\n #define TDF_SCEV\t(1 << 24)\t/* Dump SCEV details.  */\n+#define TDF_COMMENT\t(1 << 25)\t/* Dump lines with prefix \";;\"  */\n \n \n /* In tree-dump.c */"}, {"sha": "7db047104fb0409b918b6d57d129ecf7687d7bf0", "filename": "gcc/final.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -1799,7 +1799,7 @@ dump_basic_block_info (FILE *file, rtx insn, basic_block *start_to_bb,\n       fprintf (file, \"\\n%s PRED:\", ASM_COMMENT_START);\n       FOR_EACH_EDGE (e, ei, bb->preds)\n         {\n-          dump_edge_info (file, e, 0);\n+          dump_edge_info (file, e, TDF_DETAILS, 0);\n         }\n       fprintf (file, \"\\n\");\n     }\n@@ -1812,7 +1812,7 @@ dump_basic_block_info (FILE *file, rtx insn, basic_block *start_to_bb,\n       fprintf (asm_out_file, \"%s SUCC:\", ASM_COMMENT_START);\n       FOR_EACH_EDGE (e, ei, bb->succs)\n        {\n-         dump_edge_info (asm_out_file, e, 1);\n+         dump_edge_info (asm_out_file, e, TDF_DETAILS, 1);\n        }\n       fprintf (file, \"\\n\");\n     }"}, {"sha": "febf1d98dbc16f93bfa6b0f584a1cb7ae9caa963", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 25, "deletions": 75, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -2059,110 +2059,62 @@ dump_gimple_stmt (pretty_printer *buffer, gimple gs, int spc, int flags)\n }\n \n \n-/* Dumps header of basic block BB to buffer BUFFER indented by INDENT\n+/* Dumps header of basic block BB to OUTF indented by INDENT\n    spaces and details described by flags.  */\n \n static void\n-dump_bb_header (pretty_printer *buffer, basic_block bb, int indent, int flags)\n+dump_gimple_bb_header (FILE *outf, basic_block bb, int indent, int flags)\n {\n-  edge e;\n-  gimple stmt;\n-  edge_iterator ei;\n-\n   if (flags & TDF_BLOCKS)\n     {\n-      INDENT (indent);\n-      pp_string (buffer, \"# BLOCK \");\n-      pp_decimal_int (buffer, bb->index);\n-      if (bb->frequency)\n-\t{\n-          pp_string (buffer, \" freq:\");\n-          pp_decimal_int (buffer, bb->frequency);\n-\t}\n-      if (bb->count)\n-\t{\n-          pp_string (buffer, \" count:\");\n-          pp_widest_integer (buffer, bb->count);\n-\t}\n+      dump_bb_info (outf, bb, indent, flags, true, false);\n \n       if (flags & TDF_LINENO)\n \t{\n \t  gimple_stmt_iterator gsi;\n+\t  char *s_indent = (char *) alloca ((size_t) indent + 1);\n+\t  memset (s_indent, ' ', (size_t) indent);\n+\t  s_indent[indent] = '\\0';\n+\n+\t  if (flags & TDF_COMMENT)\n+\t    fputs (\";; \", outf);\n \n \t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t    if (!is_gimple_debug (gsi_stmt (gsi))\n \t\t&& get_lineno (gsi_stmt (gsi)) != UNKNOWN_LOCATION)\n \t      {\n-\t\tpp_string (buffer, \", starting at line \");\n-\t\tpp_decimal_int (buffer, get_lineno (gsi_stmt (gsi)));\n+\t\tfprintf (outf, \"%sstarting at line %d\",\n+\t\t\t s_indent, get_lineno (gsi_stmt (gsi)));\n \t\tbreak;\n \t      }\n-\n-          if (bb->discriminator)\n-            {\n-              pp_string (buffer, \", discriminator \");\n-\t      pp_decimal_int (buffer, bb->discriminator);\n-            }\n+\t  if (bb->discriminator)\n+\t    fprintf (outf, \", discriminator %i\", bb->discriminator);\n+\t  fputc ('\\n', outf);\n \t}\n-      newline_and_indent (buffer, indent);\n-\n-      pp_string (buffer, \"# PRED:\");\n-      pp_write_text_to_stream (buffer);\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\tif (flags & TDF_SLIM)\n-\t  {\n-\t    pp_character (buffer, ' ');\n-\t    if (e->src == ENTRY_BLOCK_PTR)\n-\t      pp_string (buffer, \"ENTRY\");\n-\t    else\n-\t      pp_decimal_int (buffer, e->src->index);\n-\t  }\n-\telse\n-\t  dump_edge_info (buffer->buffer->stream, e, 0);\n-      pp_newline (buffer);\n     }\n   else\n     {\n-      stmt = first_stmt (bb);\n+      gimple stmt = first_stmt (bb);\n       if (!stmt || gimple_code (stmt) != GIMPLE_LABEL)\n \t{\n-\t  INDENT (indent - 2);\n-\t  pp_string (buffer, \"<bb \");\n-\t  pp_decimal_int (buffer, bb->index);\n-\t  pp_string (buffer, \">:\");\n-\t  pp_newline (buffer);\n+\t  char *s_indent = (char *) alloca ((size_t) indent - 2 + 1);\n+\t  memset (s_indent, ' ', (size_t) indent);\n+\t  s_indent[indent] = '\\0';\n+\t  fprintf (outf, \"%s<bb %d>:\\n\", s_indent, bb->index);\n \t}\n     }\n-  pp_write_text_to_stream (buffer);\n   if (cfun)\n-    check_bb_profile (bb, buffer->buffer->stream);\n+    check_bb_profile (bb, outf);\n }\n \n \n /* Dumps end of basic block BB to buffer BUFFER indented by INDENT\n    spaces.  */\n \n static void\n-dump_bb_end (pretty_printer *buffer, basic_block bb, int indent, int flags)\n+dump_gimple_bb_footer (FILE *outf, basic_block bb, int indent, int flags)\n {\n-  edge e;\n-  edge_iterator ei;\n-\n-  INDENT (indent);\n-  pp_string (buffer, \"# SUCC:\");\n-  pp_write_text_to_stream (buffer);\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (flags & TDF_SLIM)\n-      {\n-\tpp_character (buffer, ' ');\n-\tif (e->dest == EXIT_BLOCK_PTR)\n-\t  pp_string (buffer, \"EXIT\");\n-\telse\n-\t  pp_decimal_int (buffer, e->dest->index);\n-      }\n-    else\n-      dump_edge_info (buffer->buffer->stream, e, 1);\n-  pp_newline (buffer);\n+  dump_bb_info (outf, bb, indent, flags, false, true);\n }\n \n \n@@ -2292,7 +2244,6 @@ gimple_dump_bb_buff (pretty_printer *buffer, basic_block bb, int indent,\n   if (label_indent < 0)\n     label_indent = 0;\n \n-  dump_bb_header (buffer, bb, indent, flags);\n   dump_phi_nodes (buffer, bb, indent, flags);\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -2310,19 +2261,18 @@ gimple_dump_bb_buff (pretty_printer *buffer, basic_block bb, int indent,\n     }\n \n   dump_implicit_edges (buffer, bb, indent, flags);\n-\n-  if (flags & TDF_BLOCKS)\n-    dump_bb_end (buffer, bb, indent, flags);\n }\n \n \n /* Dumps basic block BB to FILE with details described by FLAGS and\n    indented by INDENT spaces.  */\n \n void\n-gimple_dump_bb (basic_block bb, FILE *file, int indent, int flags)\n+gimple_dump_bb (FILE *file, basic_block bb, int indent, int flags)\n {\n+  dump_gimple_bb_header (file, bb, indent, flags);\n   maybe_init_pretty_print (file);\n   gimple_dump_bb_buff (&buffer, bb, indent, flags);\n   pp_flush (&buffer);\n+  dump_gimple_bb_footer (file, bb, indent, flags);\n }"}, {"sha": "08a9755649ab410c599dddae2c14c7adfcb2af1b", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -4391,12 +4391,7 @@ if_convert (void)\n \n #ifdef IFCVT_MULTIPLE_DUMPS\n       if (dump_file && cond_exec_changed_p)\n-\t{\n-\t  if (dump_flags & TDF_SLIM)\n-\t    print_rtl_slim_with_bb (dump_file, get_insns (), dump_flags);\n-\t  else\n-\t    print_rtl_with_bb (dump_file, get_insns ());\n-\t}\n+\tprint_rtl_with_bb (dump_file, get_insns (), dump_flags);\n #endif\n     }\n   while (cond_exec_changed_p);"}, {"sha": "14d3e0a67948369c373d961ac127dc9dae24c0c6", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -675,7 +675,7 @@ find_defs (struct loop *loop, basic_block *body)\n     {\n       df_dump_region (dump_file);\n       fprintf (dump_file, \"*****starting processing of loop  ******\\n\");\n-      print_rtl_with_bb (dump_file, get_insns ());\n+      print_rtl_with_bb (dump_file, get_insns (), dump_flags);\n       fprintf (dump_file, \"*****ending processing of loop  ******\\n\");\n     }\n   check_invariant_table_size ();"}, {"sha": "5612a35a867de7b7c4d2625eaee050490ec5af82", "filename": "gcc/passes.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -1725,11 +1725,9 @@ execute_function_dump (void *data ATTRIBUTE_UNUSED)\n         dump_function_to_file (current_function_decl, dump_file, dump_flags);\n       else\n \t{\n-\t  if (dump_flags & TDF_SLIM)\n-\t    print_rtl_slim_with_bb (dump_file, get_insns (), dump_flags);\n-\t  else if ((cfun->curr_properties & PROP_cfg)\n-\t\t   && (dump_flags & TDF_BLOCKS))\n-\t    print_rtl_with_bb (dump_file, get_insns ());\n+\t  if ((cfun->curr_properties & PROP_cfg)\n+\t      && (dump_flags & TDF_BLOCKS))\n+\t    print_rtl_with_bb (dump_file, get_insns (), dump_flags);\n           else\n \t    print_rtl (dump_file, get_insns ());\n "}, {"sha": "99a22f274a89ff5ed9676f2ae03c2691d79d4087", "filename": "gcc/profile.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -276,8 +276,8 @@ is_edge_inconsistent (VEC(edge,gc) *edges)\n \t\t  fprintf (dump_file,\n \t\t  \t   \"Edge %i->%i is inconsistent, count\"HOST_WIDEST_INT_PRINT_DEC,\n \t\t\t   e->src->index, e->dest->index, e->count);\n-\t\t  dump_bb (e->src, dump_file, 0);\n-\t\t  dump_bb (e->dest, dump_file, 0);\n+\t\t  dump_bb (dump_file, e->src, 0, TDF_DETAILS);\n+\t\t  dump_bb (dump_file, e->dest, 0, TDF_DETAILS);\n \t\t}\n               return true;\n \t    }\n@@ -326,7 +326,7 @@ is_inconsistent (void)\n \t\t       HOST_WIDEST_INT_PRINT_DEC,\n \t\t       bb->index,\n \t\t       bb->count);\n-\t      dump_bb (bb, dump_file, 0);\n+\t      dump_bb (dump_file, bb, 0, TDF_DETAILS);\n \t    }\n \t  inconsistent = true;\n \t}\n@@ -339,7 +339,7 @@ is_inconsistent (void)\n \t\t       bb->index,\n \t\t       bb->count,\n \t\t       sum_edge_counts (bb->preds));\n-\t      dump_bb (bb, dump_file, 0);\n+\t      dump_bb (dump_file, bb, 0, TDF_DETAILS);\n \t    }\n \t  inconsistent = true;\n \t}\n@@ -353,7 +353,7 @@ is_inconsistent (void)\n \t\t       bb->index,\n \t\t       bb->count,\n \t\t       sum_edge_counts (bb->succs));\n-\t      dump_bb (bb, dump_file, 0);\n+\t      dump_bb (dump_file, bb, 0, TDF_DETAILS);\n \t    }\n \t  inconsistent = true;\n \t}"}, {"sha": "1b1365974521d61c059f31668e5eb23da605eb34", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -2460,12 +2460,7 @@ extern void dump_combine_total_stats (FILE *);\n extern void delete_dead_jumptables (void);\n \n /* In sched-vis.c.  */\n-extern void debug_bb_n_slim (int);\n-extern void debug_bb_slim (basic_block);\n-extern void print_rtl_slim (FILE *, rtx, rtx, int, int);\n-extern void print_rtl_slim_with_bb (FILE *, rtx, int);\n-extern void dump_insn_slim (FILE *f, rtx x);\n-extern void debug_insn_slim (rtx x);\n+extern void dump_insn_slim (FILE *, const_rtx x);\n \n /* In sched-rgn.c.  */\n extern void schedule_insns (void);\n@@ -2508,7 +2503,7 @@ extern HOST_WIDE_INT find_args_size_adjust (rtx);\n extern int fixup_args_size_notes (rtx, rtx, int);\n \n /* In cfgrtl.c */\n-extern void print_rtl_with_bb (FILE *, const_rtx);\n+extern void print_rtl_with_bb (FILE *, const_rtx, int);\n extern rtx duplicate_insn_chain (rtx, rtx);\n \n /* In expmed.c */"}, {"sha": "69645b4ff49eeffa2643f0a63397e044eddc2d9b", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -396,7 +396,8 @@ debug_region (int rgn)\n \n   for (bb = 0; bb < rgn_table[rgn].rgn_nr_blocks; bb++)\n     {\n-      debug_bb_n_slim (rgn_bb_table[current_blocks + bb]);\n+      dump_bb (stderr, BASIC_BLOCK (rgn_bb_table[current_blocks + bb]),\n+\t       0, TDF_SLIM);\n       fprintf (stderr, \"\\n\");\n     }\n "}, {"sha": "768aa133522483b39b92b26fed9d7573d2d76013", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 11, "deletions": 35, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -761,7 +761,7 @@ print_insn (char *buf, const_rtx x, int verbose)\n /* Emit a slim dump of X (an insn) to the file F, including any register\n    note attached to the instruction.  */\n void\n-dump_insn_slim (FILE *f, rtx x)\n+dump_insn_slim (FILE *f, const_rtx x)\n {\n   char t[BUF_LEN + 32];\n   rtx note;\n@@ -779,65 +779,41 @@ dump_insn_slim (FILE *f, rtx x)\n }\n \n /* Emit a slim dump of X (an insn) to stderr.  */\n+extern void debug_insn_slim (const_rtx);\n DEBUG_FUNCTION void\n-debug_insn_slim (rtx x)\n+debug_insn_slim (const_rtx x)\n {\n   dump_insn_slim (stderr, x);\n }\n \n-/* Provide a slim dump the instruction chain starting at FIRST to F, honoring\n-   the dump flags given in FLAGS.  Currently, TDF_BLOCKS and TDF_DETAILS\n-   include more information on the basic blocks.  */\n-void\n-print_rtl_slim_with_bb (FILE *f, rtx first, int flags)\n-{\n-  print_rtl_slim (f, first, NULL, -1, flags);\n-}\n-\n /* Same as above, but stop at LAST or when COUNT == 0.\n    If COUNT < 0 it will stop only at LAST or NULL rtx.  */\n-void\n-print_rtl_slim (FILE *f, rtx first, rtx last, int count, int flags)\n+extern void debug_rtl_slim (FILE *, const_rtx, const_rtx, int, int);\n+DEBUG_FUNCTION void\n+debug_rtl_slim (FILE *f, const_rtx first, const_rtx last,\n+\t\tint count, int flags ATTRIBUTE_UNUSED)\n {\n-  basic_block current_bb = NULL;\n-  rtx insn, tail;\n+  const_rtx insn, tail;\n \n   tail = last ? NEXT_INSN (last) : NULL_RTX;\n   for (insn = first;\n        (insn != NULL) && (insn != tail) && (count != 0);\n        insn = NEXT_INSN (insn))\n     {\n-      bool verbose = ((flags & TDF_DETAILS) != 0);\n-\n-      if ((flags & TDF_BLOCKS)\n-\t  && (INSN_P (insn) || NOTE_P (insn))\n-\t  && BLOCK_FOR_INSN (insn)\n-\t  && !current_bb)\n-\t{\n-\t  current_bb = BLOCK_FOR_INSN (insn);\n-\t  dump_bb_info (current_bb, true, false, verbose, \";; \", f);\n-\t}\n-\n       dump_insn_slim (f, insn);\n-\n-      if ((flags & TDF_BLOCKS)\n-\t  && current_bb\n-\t  && insn == BB_END (current_bb))\n-\t{\n-\t  dump_bb_info (current_bb, false, true, verbose, \";; \", f);\n-\t  current_bb = NULL;\n-\t}\n       if (count > 0)\n         count--;\n     }\n }\n \n+extern void debug_bb_slim (basic_block);\n DEBUG_FUNCTION void\n debug_bb_slim (basic_block bb)\n {\n-  print_rtl_slim (stderr, BB_HEAD (bb), BB_END (bb), -1, 32);\n+  dump_bb (stderr, bb, 0, TDF_SLIM);\n }\n \n+extern void debug_bb_n_slim (int);\n DEBUG_FUNCTION void\n debug_bb_n_slim (int n)\n {"}, {"sha": "cdb0a8abc10d6f3e64f6dd367d45ee056fe38387", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -2576,7 +2576,7 @@ make_tm_edge (gimple stmt, basic_block bb, struct tm_region *region)\n       n->label_or_list = tree_cons (NULL, dummy.label_or_list, old);\n     }\n \n-  make_edge (bb, region->entry_block, EDGE_ABNORMAL | EDGE_ABNORMAL_CALL);\n+  make_edge (bb, region->entry_block, EDGE_ABNORMAL);\n }\n \n "}, {"sha": "e4cf076f28beb0fdacff55284099c9c2ce903659", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -1448,7 +1448,7 @@ gimple_can_merge_blocks_p (basic_block a, basic_block b)\n   if (!single_succ_p (a))\n     return false;\n \n-  if (single_succ_edge (a)->flags & (EDGE_ABNORMAL | EDGE_EH | EDGE_PRESERVE))\n+  if (single_succ_edge (a)->flags & EDGE_COMPLEX)\n     return false;\n \n   if (single_succ (a) != b)\n@@ -1844,7 +1844,7 @@ remove_bb (basic_block bb)\n       fprintf (dump_file, \"Removing basic block %d\\n\", bb->index);\n       if (dump_flags & TDF_DETAILS)\n \t{\n-\t  dump_bb (bb, dump_file, 0);\n+\t  dump_bb (dump_file, bb, 0, 0);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n     }\n@@ -2063,7 +2063,7 @@ find_case_label_for_value (gimple switch_stmt, tree val)\n void\n gimple_debug_bb (basic_block bb)\n {\n-  gimple_dump_bb (bb, stderr, 0, TDF_VOPS|TDF_MEMSYMS);\n+  dump_bb (stderr, bb, 0, TDF_VOPS|TDF_MEMSYMS);\n }\n \n \n@@ -6695,7 +6695,7 @@ dump_function_to_file (tree fn, FILE *file, int flags)\n \tfprintf (file, \"\\n\");\n \n       FOR_EACH_BB (bb)\n-\tgimple_dump_bb (bb, file, 2, flags);\n+\tgimple_dump_bb (file, bb, 2, flags);\n \n       fprintf (file, \"}\\n\");\n       check_bb_profile (EXIT_BLOCK_PTR, file);\n@@ -6821,7 +6821,7 @@ print_loops_bb (FILE *file, basic_block bb, int indent, int verbosity)\n   if (verbosity >= 3)\n     {\n       fprintf (file, \"%s  {\\n\", s_indent);\n-      gimple_dump_bb (bb, file, indent + 4, TDF_VOPS|TDF_MEMSYMS);\n+      gimple_dump_bb (file, bb, indent + 4, TDF_VOPS|TDF_MEMSYMS);\n       fprintf (file, \"%s  }\\n\", s_indent);\n     }\n }"}, {"sha": "061a3f8dab592e2da8789a1d52edb32b70a40ab5", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -414,7 +414,7 @@ extern bool is_ctrl_altering_stmt (gimple);\n extern bool simple_goto_p (gimple);\n extern bool stmt_can_make_abnormal_goto (gimple);\n extern basic_block single_noncomplex_succ (basic_block bb);\n-extern void gimple_dump_bb (basic_block, FILE *, int, int);\n+extern void gimple_dump_bb (FILE *, basic_block, int, int);\n extern void gimple_debug_bb (basic_block);\n extern basic_block gimple_debug_bb_n (int);\n extern void gimple_dump_cfg (FILE *, int);"}, {"sha": "89747b3a275d91ea01567fd3d968a5b149d47d97", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -819,8 +819,7 @@ if_convertible_bb_p (struct loop *loop, basic_block bb, basic_block exit_bb)\n \n   /* Be less adventurous and handle only normal edges.  */\n   FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (e->flags &\n-\t(EDGE_ABNORMAL_CALL | EDGE_EH | EDGE_ABNORMAL | EDGE_IRREDUCIBLE_LOOP))\n+    if (e->flags & (EDGE_EH | EDGE_ABNORMAL | EDGE_IRREDUCIBLE_LOOP))\n       {\n \tif (dump_file && (dump_flags & TDF_DETAILS))\n \t  fprintf (dump_file, \"Difficult to handle edges\\n\");"}, {"sha": "66cc40668304f8c629f0c24d3b7981178832b88d", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a315c44ce0e466407809e4cb1c1f921aa08726b4/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=a315c44ce0e466407809e4cb1c1f921aa08726b4", "patch": "@@ -4121,7 +4121,7 @@ dump_asserts_for (FILE *file, tree name)\n \t{\n \t  fprintf (file, \"\\n\\tEDGE %d->%d\", loc->e->src->index,\n \t           loc->e->dest->index);\n-\t  dump_edge_info (file, loc->e, 0);\n+\t  dump_edge_info (file, loc->e, dump_flags, 0);\n \t}\n       fprintf (file, \"\\n\\tPREDICATE: \");\n       print_generic_expr (file, name, 0);"}]}