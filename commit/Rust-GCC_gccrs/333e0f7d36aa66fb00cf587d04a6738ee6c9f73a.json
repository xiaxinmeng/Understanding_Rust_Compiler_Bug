{"sha": "333e0f7d36aa66fb00cf587d04a6738ee6c9f73a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzMzZTBmN2QzNmFhNjZmYjAwY2Y1ODdkMDRhNjczOGVlNmM5ZjczYQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-22T03:36:46Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-22T03:36:46Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r562", "tree": {"sha": "5afa8a4ff7b83ce9fc4b920f91acf86fa420ddcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5afa8a4ff7b83ce9fc4b920f91acf86fa420ddcf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/333e0f7d36aa66fb00cf587d04a6738ee6c9f73a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/333e0f7d36aa66fb00cf587d04a6738ee6c9f73a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/333e0f7d36aa66fb00cf587d04a6738ee6c9f73a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/333e0f7d36aa66fb00cf587d04a6738ee6c9f73a/comments", "author": null, "committer": null, "parents": [{"sha": "391b99c9202dfc9b327ecf636a840e2229caf8ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/391b99c9202dfc9b327ecf636a840e2229caf8ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/391b99c9202dfc9b327ecf636a840e2229caf8ee"}], "stats": {"total": 87, "additions": 86, "deletions": 1}, "files": [{"sha": "fca911e247f847f27656066cef0f88b452255f07", "filename": "gcc/global.c", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/333e0f7d36aa66fb00cf587d04a6738ee6c9f73a/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/333e0f7d36aa66fb00cf587d04a6738ee6c9f73a/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=333e0f7d36aa66fb00cf587d04a6738ee6c9f73a", "patch": "@@ -248,6 +248,7 @@ static HARD_REG_SET eliminable_regset;\n static int allocno_compare ();\n static void mark_reg_store ();\n static void mark_reg_clobber ();\n+static void mark_reg_conflicts ();\n static void mark_reg_live_nc ();\n static void mark_reg_death ();\n static void dump_conflicts ();\n@@ -698,6 +699,31 @@ global_conflicts ()\n \t\t  mark_reg_store (XEXP (link, 0), 0);\n #endif\n \n+\t      /* If INSN has multiple outputs, then any reg that dies here\n+\t\t and is used inside of an output\n+\t\t must conflict with the other outputs.  */\n+\n+\t      if (GET_CODE (PATTERN (insn)) == PARALLEL && !single_set (insn))\n+\t\tfor (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+\t\t  if (REG_NOTE_KIND (link) == REG_DEAD)\n+\t\t    {\n+\t\t      int used_in_output = 0;\n+\t\t      int i;\n+\t\t      rtx reg = XEXP (link, 0);\n+\n+\t\t      for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n+\t\t\t{\n+\t\t\t  rtx set = XVECEXP (PATTERN (insn), 0, i);\n+\t\t\t  if (GET_CODE (set) == SET\n+\t\t\t      && GET_CODE (SET_DEST (set)) != REG\n+\t\t\t      && !rtx_equal_p (reg, SET_DEST (set))\n+\t\t\t      && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n+\t\t\t    used_in_output = 1;\n+\t\t\t}\n+\t\t      if (used_in_output)\n+\t\t\tmark_reg_conflicts (reg);\n+\t\t    }\n+\n \t      /* Mark any registers set in INSN and then never used.  */\n \n \t      while (n_regs_set > 0)\n@@ -1334,6 +1360,45 @@ mark_reg_clobber (reg, setter)\n \t}\n     }\n }\n+\n+/* Record that REG has conflicts with all the regs currently live.\n+   Do not mark REG itself as live.  */\n+\n+static void\n+mark_reg_conflicts (reg)\n+     rtx reg;\n+{\n+  register int regno;\n+\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+\n+  if (GET_CODE (reg) != REG)\n+    return;\n+\n+  regno = REGNO (reg);\n+\n+  if (reg_renumber[regno] >= 0)\n+    regno = reg_renumber[regno];\n+\n+  /* Either this is one of the max_allocno pseudo regs not allocated,\n+     or it is or has a hardware reg.  First handle the pseudo-regs.  */\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      if (reg_allocno[regno] >= 0)\n+\trecord_one_conflict (regno);\n+    }\n+  /* Handle hardware regs (and pseudos allocated to hard regs).  */\n+  else if (! fixed_regs[regno])\n+    {\n+      register int last = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      while (regno < last)\n+\t{\n+\t  record_one_conflict (regno);\n+\t  regno++;\n+\t}\n+    }\n+}\n \f\n /* Mark REG as being dead (following the insn being scanned now).\n    Store a 0 in regs_live or allocnos_live for this register.  */"}, {"sha": "fc45217d11aa56667f6070aa8af4700a9bef07cb", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/333e0f7d36aa66fb00cf587d04a6738ee6c9f73a/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/333e0f7d36aa66fb00cf587d04a6738ee6c9f73a/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=333e0f7d36aa66fb00cf587d04a6738ee6c9f73a", "patch": "@@ -1729,7 +1729,8 @@ reg_is_born (reg, birth)\n \n /* Record the death of REG in the current insn.  If OUTPUT_P is non-zero,\n    REG is an output that is dying (i.e., it is never used), otherwise it\n-   is an input (the normal case).  */\n+   is an input (the normal case).\n+   If OUTPUT_P is 1, then we extend the life past the end of this insn.  */\n \n static void\n wipe_dead_reg (reg, output_p)\n@@ -1738,6 +1739,25 @@ wipe_dead_reg (reg, output_p)\n {\n   register int regno = REGNO (reg);\n \n+  /* If this insn has multiple results,\n+     and the dead reg is used in one of the results,\n+     extend its life to after this insn,\n+     so it won't get allocated together with any other result of this insn.  */\n+  if (GET_CODE (PATTERN (this_insn)) == PARALLEL\n+      && !single_set (this_insn))\n+    {\n+      int i;\n+      for (i = XVECLEN (PATTERN (this_insn), 0) - 1; i >= 0; i--)\n+\t{\n+\t  rtx set = XVECEXP (PATTERN (this_insn), 0, i);\n+\t  if (GET_CODE (set) == SET\n+\t      && GET_CODE (SET_DEST (set)) != REG\n+\t      && !rtx_equal_p (reg, SET_DEST (set))\n+\t      && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n+\t    output_p = 1;\n+\t}\n+    }\n+\n   if (regno < FIRST_PSEUDO_REGISTER)\n     {\n       mark_life (regno, GET_MODE (reg), 0);"}]}