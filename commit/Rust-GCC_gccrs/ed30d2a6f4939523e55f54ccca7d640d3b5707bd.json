{"sha": "ed30d2a6f4939523e55f54ccca7d640d3b5707bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQzMGQyYTZmNDkzOTUyM2U1NWY1NGNjY2E3ZDY0MGQzYjU3MDdiZA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2016-09-22T21:28:07Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-09-22T21:28:07Z"}, "message": "PR target/77676 - powerpc64 and powerpc64le stage2 bootstrap fail\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/77676\n\t* gcc.dg/tree-ssa/builtin-sprintf-1.c: Define and use wint_t.\n\t* gcc.dg/tree-ssa/builtin-sprintf-2.c: Fix typo.\n\t* gcc.dg/tree-ssa/builtin-sprintf-3.c: New test.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-5.c: New test.\n\ngcc/ChangeLog:\n\n\tPR target/77676\n\t* gimple-ssa-sprintf.c (target_int_min, target_int_max): Use\n\tHOST_BITS_PER_WIDE_INT, make a static local variable auto.\n\t(target_int_min): Correct computation.\n\t(format_integer): Use long long as the argument for the ll length\n\tmodifier.\n\t(format_floating): Use target_int_max().\n\t(get_string_length): Same.\n\t(format_string): Avoid setting the bounded flag for strings\n\tof unknown length.\n\t(try_substitute_return_value): Avoid setting range info when\n\tthe result isn't bounded.\n\t* varasm.c (assemble_name): Increase buffer size.\n\nFrom-SVN: r240383", "tree": {"sha": "4ed5dab957b3ce288e136d5bfa86e0669b402963", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ed5dab957b3ce288e136d5bfa86e0669b402963"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed30d2a6f4939523e55f54ccca7d640d3b5707bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed30d2a6f4939523e55f54ccca7d640d3b5707bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed30d2a6f4939523e55f54ccca7d640d3b5707bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed30d2a6f4939523e55f54ccca7d640d3b5707bd/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0cb904afbe28927d4efb343558e641e35580d72c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cb904afbe28927d4efb343558e641e35580d72c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cb904afbe28927d4efb343558e641e35580d72c"}], "stats": {"total": 173, "additions": 138, "deletions": 35}, "files": [{"sha": "5d993020d80c5c062be2d2a7460fec7d2649c3cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed30d2a6f4939523e55f54ccca7d640d3b5707bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed30d2a6f4939523e55f54ccca7d640d3b5707bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed30d2a6f4939523e55f54ccca7d640d3b5707bd", "patch": "@@ -1,3 +1,19 @@\n+2016-09-22  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR target/77676\n+\t* gimple-ssa-sprintf.c (target_int_min, target_int_max): Use\n+\tHOST_BITS_PER_WIDE_INT, make a static local variable auto.\n+\t(target_int_min): Correct computation.\n+\t(format_integer): Use long long as the argument for the ll length\n+\tmodifier.\n+\t(format_floating): Use target_int_max().\n+\t(get_string_length): Same.\n+\t(format_string): Avoid setting the bounded flag for strings\n+\tof unknown length.\n+\t(try_substitute_return_value): Avoid setting range info when\n+\tthe result isn't bounded.\n+\t* varasm.c (assemble_name): Increase buffer size.\n+\n 2016-09-22  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n \t    Terry Guo  <terry.guo@arm.com>\n "}, {"sha": "2e15149cda0ede6a436970fa891fb4fd136b2658", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed30d2a6f4939523e55f54ccca7d640d3b5707bd/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed30d2a6f4939523e55f54ccca7d640d3b5707bd/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=ed30d2a6f4939523e55f54ccca7d640d3b5707bd", "patch": "@@ -210,9 +210,9 @@ struct format_result\n static HOST_WIDE_INT\n target_int_min ()\n {\n-  static const unsigned HOST_WIDE_INT int_min\n-    = 1LLU << (sizeof int_min * CHAR_BIT\n-\t       - TYPE_PRECISION (integer_type_node) + 1);\n+  const unsigned HOST_WIDE_INT int_min\n+    = HOST_WIDE_INT_M1U << (TYPE_PRECISION (integer_type_node) - 1);\n+\n   return int_min;\n }\n \n@@ -221,8 +221,8 @@ target_int_min ()\n static unsigned HOST_WIDE_INT\n target_int_max ()\n {\n-  static const unsigned HOST_WIDE_INT int_max\n-    = HOST_WIDE_INT_M1U >> (sizeof int_max * CHAR_BIT\n+  const unsigned HOST_WIDE_INT int_max\n+    = HOST_WIDE_INT_M1U >> (HOST_BITS_PER_WIDE_INT\n \t\t\t    - TYPE_PRECISION (integer_type_node) + 1);\n   return int_max;\n }\n@@ -851,7 +851,9 @@ format_integer (const conversion_spec &spec, tree arg)\n \n     case FMT_LEN_L:\n     case FMT_LEN_ll:\n-      dirtype = sign ? long_integer_type_node : long_unsigned_type_node;\n+      dirtype = (sign\n+\t\t ? long_long_integer_type_node\n+\t\t : long_long_unsigned_type_node);\n       break;\n \n     case FMT_LEN_z:\n@@ -1366,7 +1368,7 @@ format_floating (const conversion_spec &spec, tree arg)\n \t  *minmax[i] = mpfr_snprintf (NULL, 0, fmtstr, mpfrval);\n \t}\n \n-      res.bounded = res.range.min < HOST_WIDE_INT_MAX;\n+      res.bounded = res.range.min < target_int_max ();\n       return res;\n     }\n \n@@ -1420,7 +1422,7 @@ get_string_length (tree str)\n       /* Set RES.BOUNDED to true if and only if all strings referenced\n \t by STR are known to be bounded (though not necessarily by their\n \t actual length but perhaps by their maximum possible length).  */\n-      res.bounded = res.range.max < HOST_WIDE_INT_MAX;\n+      res.bounded = res.range.max < target_int_max ();\n \n       /* Set RES.CONSTANT to false even though that may be overly\n \t conservative in rare cases like: 'x ? a : b' where a and\n@@ -1471,6 +1473,10 @@ format_string (const conversion_spec &spec, tree arg)\n        : 2 == warn_format_length ? 0 <= prec ? prec : 1\n        : HOST_WIDE_INT_MAX);\n \n+  /* The result is bounded unless overriddden for a non-constant string\n+     of an unknown length.  */\n+  bool bounded = true;\n+\n   if (spec.specifier == 'c')\n     {\n       if (spec.modifier == FMT_LEN_l)\n@@ -1550,16 +1556,17 @@ format_string (const conversion_spec &spec, tree arg)\n \t  if (0 <= prec)\n \t    {\n \t      if ((unsigned)prec < slen.range.min\n-\t\t  || slen.range.min >= HOST_WIDE_INT_MAX)\n+\t\t  || slen.range.min >= target_int_max ())\n \t\tslen.range.min = prec;\n \t      if ((unsigned)prec < slen.range.max\n-\t\t  || slen.range.max >= HOST_WIDE_INT_MAX)\n+\t\t  || slen.range.max >= target_int_max ())\n \t\tslen.range.max = prec;\n \t    }\n-\t  else if (slen.range.min >= HOST_WIDE_INT_MAX)\n+\t  else if (slen.range.min >= target_int_max ())\n \t    {\n \t      slen.range.min = max_bytes_for_unknown_str;\n \t      slen.range.max = max_bytes_for_unknown_str;\n+\t      bounded = false;\n \t    }\n \n \t  res.range = slen.range;\n@@ -1580,7 +1587,8 @@ format_string (const conversion_spec &spec, tree arg)\n     res.range.max = width;\n \n   /* Adjust BOUNDED if width happens to make them equal.  */\n-  if (res.range.min == res.range.max && res.range.min < HOST_WIDE_INT_MAX)\n+  if (res.range.min == res.range.max && res.range.min < target_int_max ()\n+      && bounded)\n     res.bounded = true;\n \n   return res;\n@@ -2389,6 +2397,7 @@ try_substitute_return_value (gimple_stmt_iterator gsi,\n       unsigned HOST_WIDE_INT maxbytes;\n \n       if (lhs\n+\t  && res.bounded\n \t  && ((maxbytes = res.number_chars - 1) <= target_int_max ()\n \t      || (res.number_chars_min - 1 <= target_int_max ()\n \t\t  && (maxbytes = res.number_chars_max - 1) <= target_int_max ()))"}, {"sha": "75e7b3e075dc571bcfc2a677f3904b5a8551f38d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed30d2a6f4939523e55f54ccca7d640d3b5707bd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed30d2a6f4939523e55f54ccca7d640d3b5707bd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ed30d2a6f4939523e55f54ccca7d640d3b5707bd", "patch": "@@ -1,3 +1,11 @@\n+2016-09-22  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR target/77676\n+\t* gcc.dg/tree-ssa/builtin-sprintf-1.c: Define and use wint_t.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-2.c: Fix typo.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-3.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-5.c: New test.\n+\n 2016-09-22  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.dg/ifcvt-1.c: Compile also for 64-bit i?86-*-* target."}, {"sha": "d6a0e6bd81d7a887c071b71d2038da7e5fba68bf", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed30d2a6f4939523e55f54ccca7d640d3b5707bd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed30d2a6f4939523e55f54ccca7d640d3b5707bd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-2.c?ref=ed30d2a6f4939523e55f54ccca7d640d3b5707bd", "patch": "@@ -77,7 +77,7 @@ EQL (   4097, sizeof buf8k, \"%.4095f\",     1.0);\n enum { imax2 = (INT_MAX / 2) * 2 };\n EQL (imax2, -1, \"%*c%*c\", INT_MAX / 2, 'x', INT_MAX / 2, 'y');\n \n-/* Verify that range inforation for calls that overflow the destination\n+/* Verify that range information for calls that overflow the destination\n    isn't available.  */\n RNG (0,  0,  0, \"%hhi\", i)\n RNG (0,  0,  1, \"%hhi\", i)"}, {"sha": "207ee7ef3b914b7209d0232fa07d4653b73d394e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-3.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed30d2a6f4939523e55f54ccca7d640d3b5707bd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed30d2a6f4939523e55f54ccca7d640d3b5707bd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-3.c?ref=ed30d2a6f4939523e55f54ccca7d640d3b5707bd", "patch": "@@ -0,0 +1,40 @@\n+/* PR bootstrap/77676 - powerpc64 and powerpc64le stage2 bootstrap fail\n+   Test case derived from the one submitted in the bug.  It verifies\n+   that the sprintf return value (or value range) optimization is not\n+   performed for an unknown string.  */\n+/* { dg-compile } */\n+/* { dg-options \"-O2 -Wall -Werror -fdump-tree-optimized -fprintf-return-value\" } */\n+\n+#define INT_MAX   __INT_MAX__\n+#define INT_MIN   (-INT_MAX - 1)\n+\n+extern void string_eq_min_fail ();\n+extern void string_eq_max_fail ();\n+\n+extern void string_lt_0_fail ();\n+extern void string_eq_0_fail ();\n+extern void string_gt_0_fail ();\n+\n+void test_string (char *d, const char *s)\n+{\n+  int n = __builtin_sprintf (d, \"%-s\", s);\n+\n+  /* Verify that the return value is NOT assumed NOT to be INT_MIN\n+     or INT_MAX.  (This is a white box test based on knowing that\n+     the optimization computes its own values of the two constants.)  */\n+  if (n == INT_MIN) string_eq_min_fail ();\n+  if (n == INT_MAX) string_eq_max_fail ();\n+\n+  /* The return value could be negative when strlen(s) is in excess\n+     of 4095 (the maximum number of bytes a single directive is required\n+     to handle).  */\n+  if (n < 0) string_lt_0_fail ();\n+  if (n == 0) string_eq_0_fail ();\n+  if (n > 0) string_gt_0_fail ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"string_eq_min_fail\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"string_eq_max_fail\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"string_lt_0_fail\"   1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"string_eq_0_fail\"   1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"string_gt_0_fail\"   1 \"optimized\" } } */"}, {"sha": "e098be92bb0377414b1f9cacf5e4d2a3398e74ec", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-1.c", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed30d2a6f4939523e55f54ccca7d640d3b5707bd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed30d2a6f4939523e55f54ccca7d640d3b5707bd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c?ref=ed30d2a6f4939523e55f54ccca7d640d3b5707bd", "patch": "@@ -32,6 +32,8 @@ typedef __SIZE_TYPE__ size_t;\n typedef __WCHAR_TYPE__ wchar_t;\n #endif\n \n+typedef __WINT_TYPE__ wint_t;\n+\n typedef unsigned char UChar;\n \n const char s0[] = \"\";\n@@ -92,7 +94,7 @@ void test_sprintf_p_const (void)\n      format null pointers as 0 or 0x0 and so the following will only be\n      diagnosed on the former targets.  */\n   T (5, \"%p\",     (void*)0);\n-  /* { dg-warning \"nul past the end\" \"(nil)\" { target *-linux-gnu *-*-uclinux } 94 } */\n+  /* { dg-warning \"nul past the end\" \"(nil)\" { target *-linux-gnu *-*-uclinux } 96 } */\n \n   /* The exact output for %p is unspecified by C.  Two formats are known:\n      same as %tx (for example AIX) and same as %#tx (for example Solaris).  */\n@@ -104,8 +106,8 @@ void test_sprintf_p_const (void)\n      as with signed integer conversions (i.e., it prepends a space).  Other\n      known implementations ignore it.  */\n   T (6, \"% p\",    (void*)0x234);  /* { dg-warning \". . flag used with .%p.\" } */\n-  /* { dg-warning \"nul past the end\" \"Glibc %p\" { target *-linux-gnu } 106 } */\n-  /* { dg-warning \"nul past the end\" \"Generic %p\" { target *-*-uclinux } 106 } */\n+  /* { dg-warning \"nul past the end\" \"Glibc %p\" { target *-linux-gnu } 108 } */\n+  /* { dg-warning \"nul past the end\" \"Generic %p\" { target *-*-uclinux } 108 } */\n }\n \n /* Verify that no warning is issued for calls that write into a flexible\n@@ -215,16 +217,16 @@ void test_sprintf_chk_c_const (void)\n   /* The following could result in as few as no bytes and in as many as\n      MB_CUR_MAX, but since the MB_CUR_MAX value is a runtime property\n      the write cannot be reliably diagnosed.  */\n-  T (2, \"%lc\",  L'1');\n-  T (2, \"%1lc\", L'1');\n+  T (2, \"%lc\",  (wint_t)L'1');\n+  T (2, \"%1lc\", (wint_t)L'1');\n   /* Writing some unknown number of bytes into a field two characters wide.  */\n-  T (2, \"%2lc\", L'1');          /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%2lc\", (wint_t)L'1');          /* { dg-warning \"nul past the end\" } */\n \n-  T (3, \"%lc%c\",   L'1', '2');\n+  T (3, \"%lc%c\",   (wint_t)L'1', '2');\n   /* Here in the best case each argument will format as single character,\n      causing the terminating NUL to be written past the end.  */\n-  T (3, \"%lc%c%c\", L'1', '2', '3');   /* { dg-warning \"nul past the end\" } */\n-  T (3, \"%lc%lc%c\", L'1', L'2', '3'); /* { dg-warning \"nul past the end\" } */\n+  T (3, \"%lc%c%c\", (wint_t)L'1', '2', '3');   /* { dg-warning \"nul past the end\" } */\n+  T (3, \"%lc%lc%c\", (wint_t)L'1', (wint_t)L'2', '3'); /* { dg-warning \"nul past the end\" } */\n }\n \n /* Exercise the \"%s\" and \"%ls\" directive with constant arguments.  */\n@@ -1242,17 +1244,17 @@ void test_snprintf_c_const (void)\n   /* The following could result in as few as a single byte and in as many\n      as MB_CUR_MAX, but since the MB_CUR_MAX value is a runtime property\n      the write cannot be reliably diagnosed.  */\n-  T (2, \"%lc\",  L'1');\n-  T (2, \"%1lc\", L'1');\n+  T (2, \"%lc\",  (wint_t)L'1');\n+  T (2, \"%1lc\", (wint_t)L'1');\n   /* Writing at least 1 characted into a field two characters wide.  */\n-  T (2, \"%2lc\", L'1');          /* { dg-warning \"output truncated before the last format character\" } */\n+  T (2, \"%2lc\", (wint_t)L'1');          /* { dg-warning \"output truncated before the last format character\" } */\n \n-  T (3, \"%lc%c\",   L'1', '2');\n+  T (3, \"%lc%c\",   (wint_t)'1', '2');\n   /* Here in the best case each argument will format as single character,\n      causing the output to be truncated just before the terminating NUL\n      (i.e., cutting off the '3').  */\n-  T (3, \"%lc%c%c\", L'1', '2', '3');   /* { dg-warning \"output truncated\" } */\n-  T (3, \"%lc%lc%c\", L'1', L'2', '3'); /* { dg-warning \"output truncated\" } */\n+  T (3, \"%lc%c%c\", (wint_t)'1', '2', '3');   /* { dg-warning \"output truncated\" } */\n+  T (3, \"%lc%lc%c\", (wint_t)'1', (wint_t)'2', '3'); /* { dg-warning \"output truncated\" } */\n }\n \n #undef T\n@@ -1291,17 +1293,17 @@ void test_snprintf_chk_c_const (void)\n   /* The following could result in as few as a single byte and in as many\n      as MB_CUR_MAX, but since the MB_CUR_MAX value is a runtime property\n      the write cannot be reliably diagnosed.  */\n-  T (2, \"%lc\",  L'1');\n-  T (2, \"%1lc\", L'1');\n+  T (2, \"%lc\",  (wint_t)L'1');\n+  T (2, \"%1lc\", (wint_t)L'1');\n   /* Writing at least 1 characted into a field two characters wide.  */\n-  T (2, \"%2lc\", L'1');          /* { dg-warning \"output truncated before the last format character\" } */\n+  T (2, \"%2lc\", (wint_t)'1');          /* { dg-warning \"output truncated before the last format character\" } */\n \n-  T (3, \"%lc%c\",   L'1', '2');\n+  T (3, \"%lc%c\",   (wint_t)'1', '2');\n   /* Here in the best case each argument will format as single character,\n      causing the output to be truncated just before the terminating NUL\n      (i.e., cutting off the '3').  */\n-  T (3, \"%lc%c%c\", L'1', '2', '3');   /* { dg-warning \"output truncated\" } */\n-  T (3, \"%lc%lc%c\", L'1', L'2', '3'); /* { dg-warning \"output truncated\" } */\n+  T (3, \"%lc%c%c\", (wint_t)'1', '2', '3');   /* { dg-warning \"output truncated\" } */\n+  T (3, \"%lc%lc%c\", (wint_t)'1', (wint_t)'2', '3'); /* { dg-warning \"output truncated\" } */\n }\n \n /* Macro to verify that calls to __builtin_vsprintf (i.e., with no size"}, {"sha": "f6f60ccc906d1d866c2034b3e5884450cbe24d41", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-5.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed30d2a6f4939523e55f54ccca7d640d3b5707bd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed30d2a6f4939523e55f54ccca7d640d3b5707bd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-5.c?ref=ed30d2a6f4939523e55f54ccca7d640d3b5707bd", "patch": "@@ -0,0 +1,28 @@\n+/* PR bootstrap/77676 - powerpc64 and powerpc64le stage2 bootstrap fail\n+   Test case from comment 6 on the bug.  */\n+/* { dg-compile } */\n+/* { dg-options \"-Wall -Werror\" } */\n+/* { dg-additional-options \"-m32\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+struct A\n+{\n+  const char *a;\n+  int b;\n+  const char *c;\n+};\n+\n+void bar (char *);\n+\n+void\n+foo (struct A *p)\n+{\n+  char s[4096];\n+  const char *u = p->a;\n+  const char *t;\n+  while ((t = __builtin_strstr (u, \"gcc/\")))\n+    u = t + 4;\n+\n+  /* Verfiy the following doesn't emit a warning.  */\n+  __builtin_sprintf (s, \"%s:%i (%s)\", u, p->b, p->c);\n+  bar (s);\n+}"}, {"sha": "4da9e21b69ce8c0251bda6b882dfd999b313b0ff", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed30d2a6f4939523e55f54ccca7d640d3b5707bd/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed30d2a6f4939523e55f54ccca7d640d3b5707bd/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=ed30d2a6f4939523e55f54ccca7d640d3b5707bd", "patch": "@@ -2545,7 +2545,7 @@ assemble_name (FILE *file, const char *name)\n rtx\n assemble_static_space (unsigned HOST_WIDE_INT size)\n {\n-  char name[12];\n+  char name[16];\n   const char *namestring;\n   rtx x;\n "}]}