{"sha": "16ec267063c8ce60769888d4097bcd158410adc8", "node_id": "C_kwDOANBUbNoAKDE2ZWMyNjcwNjNjOGNlNjA3Njk4ODhkNDA5N2JjZDE1ODQxMGFkYzg", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-14T07:33:23Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-14T07:33:23Z"}, "message": "c++: Excess precision for ? int : float or int == float [PR107097, PR82071, PR87390]\n\nThe following incremental patch implements the C11 behavior (for all C++\nversions) for\ncond ? int : float\ncond ? float : int\nint cmp float\nfloat cmp int\nwhere int is any integral type, float any floating point type with\nexcess precision and cmp ==, !=, >, <, >=, <= and <=>.\n\n2022-10-14  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c/82071\n\tPR c/87390\n\tPR c++/107097\ngcc/cp/\n\t* cp-tree.h (cp_ep_convert_and_check): Remove.\n\t* cvt.cc (cp_ep_convert_and_check): Remove.\n\t* call.cc (build_conditional_expr): Use excess precision for ?: with\n\tone arm floating and another integral.  Don't convert first to\n\tsemantic result type from integral types.\n\t(convert_like_internal): Don't call cp_ep_convert_and_check, instead\n\tjust strip EXCESS_PRECISION_EXPR before calling cp_convert_and_check\n\tor cp_convert.\n\t* typeck.cc (cp_build_binary_op): Set may_need_excess_precision\n\tfor comparisons or SPACESHIP_EXPR with at least one operand integral.\n\tDon't compute semantic_result_type if build_type is non-NULL.  Call\n\tcp_convert_and_check instead of cp_ep_convert_and_check.\ngcc/testsuite/\n\t* gcc.target/i386/excess-precision-8.c: For C++ wrap abort and\n\texit declarations into extern \"C\" block.\n\t* gcc.target/i386/excess-precision-10.c: Likewise.\n\t* g++.target/i386/excess-precision-7.C: Remove.\n\t* g++.target/i386/excess-precision-8.C: New test.\n\t* g++.target/i386/excess-precision-9.C: Remove.\n\t* g++.target/i386/excess-precision-10.C: New test.\n\t* g++.target/i386/excess-precision-12.C: New test.", "tree": {"sha": "372e0a315c682ba28d7c5e3f6347037bfd92a0cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/372e0a315c682ba28d7c5e3f6347037bfd92a0cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16ec267063c8ce60769888d4097bcd158410adc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16ec267063c8ce60769888d4097bcd158410adc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16ec267063c8ce60769888d4097bcd158410adc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16ec267063c8ce60769888d4097bcd158410adc8/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98e341130f87984af07c884fea773c0bb3cc8821", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98e341130f87984af07c884fea773c0bb3cc8821", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98e341130f87984af07c884fea773c0bb3cc8821"}], "stats": {"total": 152, "additions": 99, "deletions": 53}, "files": [{"sha": "6a34e9c2ae1cd729dd3bf0263e05e5d1af5d95e2", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 47, "deletions": 15, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16ec267063c8ce60769888d4097bcd158410adc8/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16ec267063c8ce60769888d4097bcd158410adc8/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=16ec267063c8ce60769888d4097bcd158410adc8", "patch": "@@ -5895,10 +5895,52 @@ build_conditional_expr (const op_location_t &loc,\n \t   && (ARITHMETIC_TYPE_P (arg3_type)\n \t       || UNSCOPED_ENUM_P (arg3_type)))\n     {\n-      /* In this case, there is always a common type.  */\n-      result_type = type_after_usual_arithmetic_conversions (arg2_type,\n-\t\t\t\t\t\t\t     arg3_type);\n+      /* A conditional expression between a floating-point\n+\t type and an integer type should convert the integer type to\n+\t the evaluation format of the floating-point type, with\n+\t possible excess precision.  */\n+      tree eptype2 = arg2_type;\n+      tree eptype3 = arg3_type;\n+      tree eptype;\n+      if (ANY_INTEGRAL_TYPE_P (arg2_type)\n+\t  && (eptype = excess_precision_type (arg3_type)) != NULL_TREE)\n+\t{\n+\t  eptype3 = eptype;\n+\t  if (!semantic_result_type)\n+\t    semantic_result_type\n+\t      = type_after_usual_arithmetic_conversions (arg2_type, arg3_type);\n+\t}\n+      else if (ANY_INTEGRAL_TYPE_P (arg3_type)\n+\t       && (eptype = excess_precision_type (arg2_type)) != NULL_TREE)\n+\t{\n+\t  eptype2 = eptype;\n+\t  if (!semantic_result_type)\n+\t    semantic_result_type\n+\t      = type_after_usual_arithmetic_conversions (arg2_type, arg3_type);\n+\t}\n+      result_type = type_after_usual_arithmetic_conversions (eptype2,\n+\t\t\t\t\t\t\t     eptype3);\n       if (result_type == error_mark_node)\n+\t{\n+\t  tree t1 = eptype2;\n+\t  tree t2 = eptype3;\n+\t  if (TREE_CODE (t1) == COMPLEX_TYPE)\n+\t    t1 = TREE_TYPE (t1);\n+\t  if (TREE_CODE (t2) == COMPLEX_TYPE)\n+\t    t2 = TREE_TYPE (t2);\n+\t  gcc_checking_assert (TREE_CODE (t1) == REAL_TYPE\n+\t\t\t       && TREE_CODE (t2) == REAL_TYPE\n+\t\t\t       && (extended_float_type_p (t1)\n+\t\t\t\t   || extended_float_type_p (t2))\n+\t\t\t       && cp_compare_floating_point_conversion_ranks\n+\t\t\t\t    (t1, t2) == 3);\n+\t  if (complain & tf_error)\n+\t    error_at (loc, \"operands to %<?:%> of types %qT and %qT \"\n+\t\t\t   \"have unordered conversion rank\",\n+\t\t      eptype2, eptype3);\n+\t  return error_mark_node;\n+\t}\n+      if (semantic_result_type == error_mark_node)\n \t{\n \t  tree t1 = arg2_type;\n \t  tree t2 = arg3_type;\n@@ -5976,10 +6018,6 @@ build_conditional_expr (const op_location_t &loc,\n \t    }\n \t}\n \n-      if (semantic_result_type && INTEGRAL_TYPE_P (arg2_type))\n-\targ2 = perform_implicit_conversion (semantic_result_type, arg2, complain);\n-      else if (semantic_result_type && INTEGRAL_TYPE_P (arg3_type))\n-\targ3 = perform_implicit_conversion (semantic_result_type, arg3, complain);\n       arg2 = perform_implicit_conversion (result_type, arg2, complain);\n       arg3 = perform_implicit_conversion (result_type, arg3, complain);\n     }\n@@ -8546,14 +8584,8 @@ convert_like_internal (conversion *convs, tree expr, tree fn, int argnum,\n \n   warning_sentinel w (warn_zero_as_null_pointer_constant);\n   if (TREE_CODE (expr) == EXCESS_PRECISION_EXPR)\n-    {\n-      if (issue_conversion_warnings)\n-\texpr = cp_ep_convert_and_check (totype, TREE_OPERAND (expr, 0),\n-\t\t\t\t\tTREE_TYPE (expr), complain);\n-      else\n-\texpr = cp_convert (totype, TREE_OPERAND (expr, 0), complain);\n-    }\n-  else if (issue_conversion_warnings)\n+    expr = TREE_OPERAND (expr, 0);\n+  if (issue_conversion_warnings)\n     expr = cp_convert_and_check (totype, expr, complain);\n   else\n     expr = cp_convert (totype, expr, complain);"}, {"sha": "1534c875693963bd78d6ea96a948dfeebda03edb", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16ec267063c8ce60769888d4097bcd158410adc8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16ec267063c8ce60769888d4097bcd158410adc8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=16ec267063c8ce60769888d4097bcd158410adc8", "patch": "@@ -6793,8 +6793,6 @@ extern tree ocp_convert\t\t\t\t(tree, tree, int, int,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree cp_convert\t\t\t\t(tree, tree, tsubst_flags_t);\n extern tree cp_convert_and_check                (tree, tree, tsubst_flags_t);\n-extern tree cp_ep_convert_and_check             (tree, tree, tree,\n-\t\t\t\t\t\t tsubst_flags_t);\n extern tree cp_fold_convert\t\t\t(tree, tree);\n extern tree cp_get_callee\t\t\t(tree);\n extern tree cp_get_callee_fndecl\t\t(tree);"}, {"sha": "434d306961f877a67cca92af00c3be94b7a81284", "filename": "gcc/cp/cvt.cc", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16ec267063c8ce60769888d4097bcd158410adc8/gcc%2Fcp%2Fcvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16ec267063c8ce60769888d4097bcd158410adc8/gcc%2Fcp%2Fcvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.cc?ref=16ec267063c8ce60769888d4097bcd158410adc8", "patch": "@@ -684,33 +684,6 @@ cp_convert_and_check (tree type, tree expr, tsubst_flags_t complain)\n   return result;\n }\n \n-/* Similarly, but deal with excess precision.  SEMANTIC_TYPE is the type this\n-   conversion would use without excess precision.  If SEMANTIC_TYPE is NULL,\n-   this function is equivalent to cp_convert_and_check.  This function is\n-   a wrapper that handles conversions that may be different than the usual\n-   ones because of excess precision.  */\n-\n-tree\n-cp_ep_convert_and_check (tree type, tree expr, tree semantic_type,\n-\t\t\t tsubst_flags_t complain)\n-{\n-  if (TREE_TYPE (expr) == type)\n-    return expr;\n-  if (expr == error_mark_node)\n-    return expr;\n-  if (!semantic_type)\n-    return cp_convert_and_check (type, expr, complain);\n-\n-  if (TREE_CODE (TREE_TYPE (expr)) == INTEGER_TYPE\n-      && TREE_TYPE (expr) != semantic_type)\n-    /* For integers, we need to check the real conversion, not\n-       the conversion to the excess precision type.  */\n-    expr = cp_convert_and_check (semantic_type, expr, complain);\n-  /* Result type is the excess precision type, which should be\n-     large enough, so do not check.  */\n-  return cp_convert (type, expr, complain);\n-}\n-\n /* Conversion...\n \n    FLAGS indicates how we should behave.  */"}, {"sha": "634f60c1a9671a04bd4fa6828c4cf75da896edb0", "filename": "gcc/cp/typeck.cc", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16ec267063c8ce60769888d4097bcd158410adc8/gcc%2Fcp%2Ftypeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16ec267063c8ce60769888d4097bcd158410adc8/gcc%2Fcp%2Ftypeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.cc?ref=16ec267063c8ce60769888d4097bcd158410adc8", "patch": "@@ -5229,6 +5229,18 @@ cp_build_binary_op (const op_location_t &location,\n     case EXACT_DIV_EXPR:\n       may_need_excess_precision = true;\n       break;\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case LE_EXPR:\n+    case GE_EXPR:\n+    case LT_EXPR:\n+    case GT_EXPR:\n+    case SPACESHIP_EXPR:\n+      /* Excess precision for implicit conversions of integers to\n+\t floating point.  */\n+      may_need_excess_precision = (ANY_INTEGRAL_TYPE_P (type0)\n+\t\t\t\t   || ANY_INTEGRAL_TYPE_P (type1));\n+      break;\n     default:\n       may_need_excess_precision = false;\n       break;\n@@ -6157,7 +6169,8 @@ cp_build_binary_op (const op_location_t &location,\n \t}\n     }\n   if (may_need_excess_precision\n-      && (orig_type0 != type0 || orig_type1 != type1))\n+      && (orig_type0 != type0 || orig_type1 != type1)\n+      && build_type == NULL_TREE)\n     {\n       gcc_assert (common);\n       semantic_result_type = cp_common_type (orig_type0, orig_type1);\n@@ -6460,11 +6473,9 @@ cp_build_binary_op (const op_location_t &location,\n     {\n       warning_sentinel w (warn_sign_conversion, short_compare);\n       if (!same_type_p (TREE_TYPE (op0), result_type))\n-\top0 = cp_ep_convert_and_check (result_type, op0,\n-\t\t\t\t       semantic_result_type, complain);\n+\top0 = cp_convert_and_check (result_type, op0, complain);\n       if (!same_type_p (TREE_TYPE (op1), result_type))\n-\top1 = cp_ep_convert_and_check (result_type, op1,\n-\t\t\t\t       semantic_result_type, complain);\n+\top1 = cp_convert_and_check (result_type, op1, complain);\n \n       if (op0 == error_mark_node || op1 == error_mark_node)\n \treturn error_mark_node;"}, {"sha": "9dbe25e0934bb251094d08417ed2ec04fe036477", "filename": "gcc/testsuite/g++.target/i386/excess-precision-10.C", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16ec267063c8ce60769888d4097bcd158410adc8/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16ec267063c8ce60769888d4097bcd158410adc8/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-10.C?ref=16ec267063c8ce60769888d4097bcd158410adc8", "patch": "@@ -1,6 +1,6 @@\n // Excess precision tests.  Test implicit conversions in comparisons:\n-// no excess precision in C++.\n+// excess precision in C++.\n // { dg-do run }\n // { dg-options \"-mfpmath=387 -fexcess-precision=standard\" }\n \n-#include \"../../gcc.target/i386/excess-precision-9.c\"\n+#include \"../../gcc.target/i386/excess-precision-10.c\"", "previous_filename": "gcc/testsuite/g++.target/i386/excess-precision-9.C"}, {"sha": "dff48c07c8b7664b8865c35f42006638ce259652", "filename": "gcc/testsuite/g++.target/i386/excess-precision-12.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16ec267063c8ce60769888d4097bcd158410adc8/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16ec267063c8ce60769888d4097bcd158410adc8/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-12.C?ref=16ec267063c8ce60769888d4097bcd158410adc8", "patch": "@@ -0,0 +1,20 @@\n+// Excess precision tests.  Test implicit conversions in 3-way comparisons:\n+// excess precision in C++.\n+// { dg-do run { target c++20 } }\n+// { dg-options \"-mfpmath=387 -fexcess-precision=standard\" }\n+\n+#include <compare>\n+#include <cstdlib>\n+\n+int\n+main (void)\n+{\n+  float f = 0x1p63f;\n+  unsigned long long int u = (1ULL << 63) + 1;\n+\n+  if ((f <=> u) >= 0)\n+    abort ();\n+\n+  if ((u <=> f) <= 0)\n+    abort ();\n+}"}, {"sha": "c170c004b69608687beb7ced3b5604ad2ded3af7", "filename": "gcc/testsuite/g++.target/i386/excess-precision-8.C", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16ec267063c8ce60769888d4097bcd158410adc8/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16ec267063c8ce60769888d4097bcd158410adc8/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-8.C?ref=16ec267063c8ce60769888d4097bcd158410adc8", "patch": "@@ -1,7 +1,7 @@\n-// Excess precision tests.  Test C99 semantics for conversions from\n+// Excess precision tests.  Test C++ semantics for conversions from\n // integers to floating point: no excess precision for either explicit\n // or implicit conversions.\n // { dg-do run }\n // { dg-options \"-mfpmath=387 -fexcess-precision=standard\" }\n \n-#include \"../../gcc.target/i386/excess-precision-7.c\"\n+#include \"../../gcc.target/i386/excess-precision-8.c\"", "previous_filename": "gcc/testsuite/g++.target/i386/excess-precision-7.C"}, {"sha": "1dd3e7a424c494a3e563063bbdc6eedecbdd14c4", "filename": "gcc/testsuite/gcc.target/i386/excess-precision-10.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16ec267063c8ce60769888d4097bcd158410adc8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16ec267063c8ce60769888d4097bcd158410adc8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-10.c?ref=16ec267063c8ce60769888d4097bcd158410adc8", "patch": "@@ -3,8 +3,14 @@\n /* { dg-do run } */\n /* { dg-options \"-std=c11 -mfpmath=387 -fexcess-precision=standard\" } */\n \n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n extern void abort (void);\n extern void exit (int);\n+#ifdef __cplusplus\n+}\n+#endif\n \n int\n main (void)"}, {"sha": "8dd04585180d015fa397bb595e7fed91c29bc6d4", "filename": "gcc/testsuite/gcc.target/i386/excess-precision-8.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16ec267063c8ce60769888d4097bcd158410adc8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16ec267063c8ce60769888d4097bcd158410adc8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-8.c?ref=16ec267063c8ce60769888d4097bcd158410adc8", "patch": "@@ -4,8 +4,14 @@\n /* { dg-do run } */\n /* { dg-options \"-std=c11 -mfpmath=387 -fexcess-precision=standard\" } */\n \n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n extern void abort (void);\n extern void exit (int);\n+#ifdef __cplusplus\n+}\n+#endif\n \n int\n main (void)"}]}