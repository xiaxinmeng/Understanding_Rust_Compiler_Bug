{"sha": "cf85c69b0eb09b47e1e4b28808974039d8e798ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y4NWM2OWIwZWIwOWI0N2UxZTRiMjg4MDg5NzQwMzlkOGU3OThiYQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-11-15T18:20:53Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-11-15T18:20:53Z"}, "message": "(unextend): Rewrite type conversions to avoid overflow.\n\nFrom-SVN: r13165", "tree": {"sha": "e26b4c4b0f2b5950a35777fb94243f2ca8dadb9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e26b4c4b0f2b5950a35777fb94243f2ca8dadb9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf85c69b0eb09b47e1e4b28808974039d8e798ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf85c69b0eb09b47e1e4b28808974039d8e798ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf85c69b0eb09b47e1e4b28808974039d8e798ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf85c69b0eb09b47e1e4b28808974039d8e798ba/comments", "author": null, "committer": null, "parents": [{"sha": "f6beed21692f8885aaf59e843c0809861cf55738", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6beed21692f8885aaf59e843c0809861cf55738", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6beed21692f8885aaf59e843c0809861cf55738"}], "stats": {"total": 16, "additions": 13, "deletions": 3}, "files": [{"sha": "68808e0ede00b0f4cebfe40f51152f47172e3d35", "filename": "gcc/fold-const.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf85c69b0eb09b47e1e4b28808974039d8e798ba/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf85c69b0eb09b47e1e4b28808974039d8e798ba/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=cf85c69b0eb09b47e1e4b28808974039d8e798ba", "patch": "@@ -3127,18 +3127,28 @@ unextend (c, p, unsignedp, mask)\n   if (p == modesize || unsignedp)\n     return c;\n \n-  if (TREE_UNSIGNED (type))\n-    c = convert (signed_type (type), c);\n-\n   /* We work by getting just the sign bit into the low-order bit, then\n      into the high-order bit, then sign-extend.  We then XOR that value\n      with C.  */\n   temp = const_binop (RSHIFT_EXPR, c, size_int (p - 1), 0);\n   temp = const_binop (BIT_AND_EXPR, temp, size_int (1), 0);\n+\n+  /* We must use a signed type in order to get an arithmetic right shift.\n+     However, we must also avoid introducing accidental overflows, so that\n+     a subsequent call to integer_zerop will work.  Hence we must \n+     do the type conversion here.  At this point, the constant is either\n+     zero or one, and the conversion to a signed type can never overflow.\n+     We could get an overflow if this conversion is done anywhere else.  */\n+  if (TREE_UNSIGNED (type))\n+    temp = convert (signed_type (type), temp);\n+\n   temp = const_binop (LSHIFT_EXPR, temp, size_int (modesize - 1), 0);\n   temp = const_binop (RSHIFT_EXPR, temp, size_int (modesize - p - 1), 0);\n   if (mask != 0)\n     temp = const_binop (BIT_AND_EXPR, temp, convert (TREE_TYPE (c), mask), 0);\n+  /* If necessary, convert the type back to match the type of C.  */\n+  if (TREE_UNSIGNED (type))\n+    temp = convert (type, temp);\n \n   return convert (type, const_binop (BIT_XOR_EXPR, c, temp, 0));\n }"}]}