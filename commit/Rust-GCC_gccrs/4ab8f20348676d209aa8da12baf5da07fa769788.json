{"sha": "4ab8f20348676d209aa8da12baf5da07fa769788", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFiOGYyMDM0ODY3NmQyMDlhYThkYTEyYmFmNWRhMDdmYTc2OTc4OA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-06-04T18:25:20Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-06-08T12:40:15Z"}, "message": "Implement a context aware pointer equivalency class for use in evrp.\n\nThe substitute_and_fold_engine which evrp uses is expecting symbolics\nfrom value_of_expr / value_on_edge / etc, which ranger does not provide.\nIn some cases, these provide important folding cues, as in the case of\naliases for pointers.  For example, legacy evrp may return [&foo, &foo]\nfor the value of \"bar\" where bar is on an edge where bar == &foo, or\nwhen bar has been globally set to &foo.  This information is then used\nby the subst & fold engine to propagate the known value of bar.\n\nCurrently this is a major source of discrepancies between evrp and\nranger.  Of the 284 cases legacy evrp is getting over ranger, 237 are\nfor pointer equality as discussed above.\n\nThis patch implements a context aware pointer equivalency class which\nranger-evrp can use to query what an SSA pointer is currently\nequivalent to.  With it, we reduce the 284 cases legacy evrp is getting\nto 47.\n\nThe API for the pointer equivalency analyzer is the following:\n\nclass pointer_equiv_analyzer\n{\npublic:\n  pointer_equiv_analyzer (gimple_ranger *r);\n  ~pointer_equiv_analyzer ();\n  void enter (basic_block);\n  void leave (basic_block);\n  void visit_stmt (gimple *stmt);\n  tree get_equiv (tree ssa) const;\n...\n};\n\nThe enter(), leave(), and visit_stmt() methods are meant to be called\nfrom a DOM walk.   At any point throughout the walk, one can call\nget_equiv() to get whatever an SSA is equivalent to.\n\nTested on x86-64 Linux with a regular bootstrap/tests and by comparing\nEVRP folds over ranger before and after this patch.\n\ngcc/ChangeLog:\n\n\t* gimple-ssa-evrp.c (class ssa_equiv_stack): New.\n\t(ssa_equiv_stack::ssa_equiv_stack): New.\n\t(ssa_equiv_stack::~ssa_equiv_stack): New.\n\t(ssa_equiv_stack::enter): New.\n\t(ssa_equiv_stack::leave): New.\n\t(ssa_equiv_stack::push_replacement): New.\n\t(ssa_equiv_stack::get_replacement): New.\n\t(is_pointer_ssa): New.\n\t(class pointer_equiv_analyzer): New.\n\t(pointer_equiv_analyzer::pointer_equiv_analyzer): New.\n\t(pointer_equiv_analyzer::~pointer_equiv_analyzer): New.\n\t(pointer_equiv_analyzer::set_global_equiv): New.\n\t(pointer_equiv_analyzer::set_cond_equiv): New.\n\t(pointer_equiv_analyzer::get_equiv): New.\n\t(pointer_equiv_analyzer::enter): New.\n\t(pointer_equiv_analyzer::leave): New.\n\t(pointer_equiv_analyzer::get_equiv_expr): New.\n\t(pta_valueize): New.\n\t(pointer_equiv_analyzer::visit_stmt): New.\n\t(pointer_equiv_analyzer::visit_edge): New.\n\t(hybrid_folder::value_of_expr): Call PTA.\n\t(hybrid_folder::value_on_edge): Same.\n\t(hybrid_folder::pre_fold_bb): New.\n\t(hybrid_folder::post_fold_bb): New.\n\t(hybrid_folder::pre_fold_stmt): New.\n\t(rvrp_folder::pre_fold_bb): New.\n\t(rvrp_folder::post_fold_bb): New.\n\t(rvrp_folder::pre_fold_stmt): New.\n\t(rvrp_folder::value_of_expr): Call PTA.\n\t(rvrp_folder::value_on_edge): Same.", "tree": {"sha": "c8d5f0e683bcb80134990c3b0812a965e34e1d5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8d5f0e683bcb80134990c3b0812a965e34e1d5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ab8f20348676d209aa8da12baf5da07fa769788", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ab8f20348676d209aa8da12baf5da07fa769788", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ab8f20348676d209aa8da12baf5da07fa769788", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ab8f20348676d209aa8da12baf5da07fa769788/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30656822b3792712c7a69fe1a0a79739f8f29abc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30656822b3792712c7a69fe1a0a79739f8f29abc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30656822b3792712c7a69fe1a0a79739f8f29abc"}], "stats": {"total": 354, "additions": 352, "deletions": 2}, "files": [{"sha": "7e1cf51239a59620d87528240df849a329fe3d05", "filename": "gcc/gimple-ssa-evrp.c", "status": "modified", "additions": 352, "deletions": 2, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ab8f20348676d209aa8da12baf5da07fa769788/gcc%2Fgimple-ssa-evrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ab8f20348676d209aa8da12baf5da07fa769788/gcc%2Fgimple-ssa-evrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp.c?ref=4ab8f20348676d209aa8da12baf5da07fa769788", "patch": "@@ -42,6 +42,307 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vr-values.h\"\n #include \"gimple-ssa-evrp-analyze.h\"\n #include \"gimple-range.h\"\n+#include \"fold-const.h\"\n+\n+// Unwindable SSA equivalence table for pointers.\n+//\n+// The main query point is get_replacement() which returns what a\n+// given SSA can be replaced with in the current scope.\n+\n+class ssa_equiv_stack\n+{\n+public:\n+  ssa_equiv_stack ();\n+  ~ssa_equiv_stack ();\n+  void enter (basic_block);\n+  void leave (basic_block);\n+  void push_replacement (tree name, tree replacement);\n+  tree get_replacement (tree name) const;\n+\n+private:\n+  auto_vec<std::pair <tree, tree>> m_stack;\n+  tree *m_replacements;\n+  const std::pair <tree, tree> m_marker = std::make_pair (NULL, NULL);\n+};\n+\n+ssa_equiv_stack::ssa_equiv_stack ()\n+{\n+  m_replacements = new tree[num_ssa_names] ();\n+}\n+\n+ssa_equiv_stack::~ssa_equiv_stack ()\n+{\n+  m_stack.release ();\n+  delete m_replacements;\n+}\n+\n+// Pushes a marker at the given point.\n+\n+void\n+ssa_equiv_stack::enter (basic_block)\n+{\n+  m_stack.safe_push (m_marker);\n+}\n+\n+// Pops the stack to the last marker, while performing replacements\n+// along the way.\n+\n+void\n+ssa_equiv_stack::leave (basic_block)\n+{\n+  gcc_checking_assert (!m_stack.is_empty ());\n+  while (m_stack.last () != m_marker)\n+    {\n+      std::pair<tree, tree> e = m_stack.pop ();\n+      m_replacements[SSA_NAME_VERSION (e.first)] = e.second;\n+    }\n+  m_stack.pop ();\n+}\n+\n+// Set the equivalence of NAME to REPLACEMENT.\n+\n+void\n+ssa_equiv_stack::push_replacement (tree name, tree replacement)\n+{\n+  tree old = m_replacements[SSA_NAME_VERSION (name)];\n+  m_replacements[SSA_NAME_VERSION (name)] = replacement;\n+  m_stack.safe_push (std::make_pair (name, old));\n+}\n+\n+// Return the equivalence of NAME.\n+\n+tree\n+ssa_equiv_stack::get_replacement (tree name) const\n+{\n+  return m_replacements[SSA_NAME_VERSION (name)];\n+}\n+\n+// Return TRUE if EXPR is an SSA holding a pointer.\n+\n+static bool inline\n+is_pointer_ssa (tree expr)\n+{\n+  return TREE_CODE (expr) == SSA_NAME && POINTER_TYPE_P (TREE_TYPE (expr));\n+}\n+\n+// Simple context-aware pointer equivalency analyzer that returns what\n+// a pointer SSA name is equivalent to at a given point during a walk\n+// of the IL.\n+//\n+// Note that global equivalency take priority over conditional\n+// equivalency.  That is, p = &q takes priority over a later p == &t.\n+//\n+// This class is meant to be called during a DOM walk.\n+\n+class pointer_equiv_analyzer\n+{\n+public:\n+  pointer_equiv_analyzer (gimple_ranger *r);\n+  ~pointer_equiv_analyzer ();\n+  void enter (basic_block);\n+  void leave (basic_block);\n+  void visit_stmt (gimple *stmt);\n+  tree get_equiv (tree ssa) const;\n+\n+private:\n+  void visit_edge (edge e);\n+  tree get_equiv_expr (tree_code code, tree expr) const;\n+  void set_global_equiv (tree ssa, tree pointee);\n+  void set_cond_equiv (tree ssa, tree pointee);\n+\n+  gimple_ranger *m_ranger;\n+  // Global pointer equivalency indexed by SSA_NAME_VERSION.\n+  tree *m_global_points;\n+  // Conditional pointer equivalency.\n+  ssa_equiv_stack m_cond_points;\n+};\n+\n+pointer_equiv_analyzer::pointer_equiv_analyzer (gimple_ranger *r)\n+{\n+  m_ranger = r;\n+  m_global_points = new tree[num_ssa_names] ();\n+}\n+\n+pointer_equiv_analyzer::~pointer_equiv_analyzer ()\n+{\n+  delete m_global_points;\n+}\n+\n+// Set the global pointer equivalency for SSA to POINTEE.\n+\n+void\n+pointer_equiv_analyzer::set_global_equiv (tree ssa, tree pointee)\n+{\n+  m_global_points[SSA_NAME_VERSION (ssa)] = pointee;\n+}\n+\n+// Set the conditional pointer equivalency for SSA to POINTEE.\n+\n+void\n+pointer_equiv_analyzer::set_cond_equiv (tree ssa, tree pointee)\n+{\n+  m_cond_points.push_replacement (ssa, pointee);\n+}\n+\n+// Return the current pointer equivalency info for SSA, or NULL if\n+// none is available.  Note that global info takes priority over\n+// conditional info.\n+\n+tree\n+pointer_equiv_analyzer::get_equiv (tree ssa) const\n+{\n+  tree ret = m_global_points[SSA_NAME_VERSION (ssa)];\n+  if (ret)\n+    return ret;\n+  return m_cond_points.get_replacement (ssa);\n+}\n+\n+// Method to be called on entry to a BB.\n+\n+void\n+pointer_equiv_analyzer::enter (basic_block bb)\n+{\n+  m_cond_points.enter (bb);\n+\n+  for (gphi_iterator iter = gsi_start_phis (bb);\n+       !gsi_end_p (iter);\n+       gsi_next (&iter))\n+    {\n+      gphi *phi = iter.phi ();\n+      tree lhs = gimple_phi_result (phi);\n+      if (!POINTER_TYPE_P (TREE_TYPE (lhs)))\n+\tcontinue;\n+      tree arg0 = gimple_phi_arg_def (phi, 0);\n+      if (TREE_CODE (arg0) == SSA_NAME && !is_gimple_min_invariant (arg0))\n+\targ0 = get_equiv (arg0);\n+      if (arg0 && is_gimple_min_invariant (arg0))\n+\t{\n+\t  // If all the PHI args point to the same place, set the\n+\t  // pointer equivalency info for the PHI result.  This can\n+\t  // happen for passes that create redundant PHIs like\n+\t  // PHI<&foo, &foo> or PHI<&foo>.\n+\t  for (size_t i = 1; i < gimple_phi_num_args (phi); ++i)\n+\t    {\n+\t      tree argi = gimple_phi_arg_def (phi, i);\n+\t      if (TREE_CODE (argi) == SSA_NAME\n+\t\t  && !is_gimple_min_invariant (argi))\n+\t\targi = get_equiv (argi);\n+\t      if (!argi || !operand_equal_p (arg0, argi))\n+\t\treturn;\n+\t    }\n+\t  set_global_equiv (lhs, arg0);\n+\t}\n+    }\n+\n+  edge pred = single_pred_edge_ignoring_loop_edges (bb, false);\n+  if (pred)\n+    visit_edge (pred);\n+}\n+\n+// Method to be called on exit from a BB.\n+\n+void\n+pointer_equiv_analyzer::leave (basic_block bb)\n+{\n+  m_cond_points.leave (bb);\n+}\n+\n+// Helper function to return the pointer equivalency information for\n+// EXPR from a gimple statement with CODE.  This returns either the\n+// cached pointer equivalency info for an SSA, or an invariant in case\n+// EXPR is one (i.e. &foo).  Returns NULL if EXPR is neither an SSA\n+// nor an invariant.\n+\n+tree\n+pointer_equiv_analyzer::get_equiv_expr (tree_code code, tree expr) const\n+{\n+  if (code == SSA_NAME)\n+    return get_equiv (expr);\n+\n+  if (get_gimple_rhs_class (code) == GIMPLE_SINGLE_RHS\n+      && is_gimple_min_invariant (expr))\n+    return expr;\n+\n+  return NULL;\n+}\n+\n+// Hack to provide context to the gimple fold callback.\n+static struct\n+{\n+  gimple *m_stmt;\n+  gimple_ranger *m_ranger;\n+  pointer_equiv_analyzer *m_pta;\n+} x_fold_context;\n+\n+// Gimple fold callback.\n+static tree\n+pta_valueize (tree name)\n+{\n+  tree ret\n+    = x_fold_context.m_ranger->value_of_expr (name, x_fold_context.m_stmt);\n+\n+  if (!ret && is_pointer_ssa (name))\n+    ret = x_fold_context.m_pta->get_equiv (name);\n+\n+  return ret ? ret : name;\n+}\n+\n+// Method to be called on gimple statements during traversal of the IL.\n+\n+void\n+pointer_equiv_analyzer::visit_stmt (gimple *stmt)\n+{\n+  if (gimple_code (stmt) != GIMPLE_ASSIGN)\n+    return;\n+\n+  tree lhs = gimple_assign_lhs (stmt);\n+  if (!is_pointer_ssa (lhs))\n+    return;\n+\n+  tree rhs = gimple_assign_rhs1 (stmt);\n+  rhs = get_equiv_expr (gimple_assign_rhs_code (stmt), rhs);\n+  if (rhs)\n+    {\n+      set_global_equiv (lhs, rhs);\n+      return;\n+    }\n+\n+  // If we couldn't find anything, try fold.\n+  x_fold_context = { stmt, m_ranger, this};\n+  rhs = gimple_fold_stmt_to_constant_1 (stmt, pta_valueize, pta_valueize);\n+  if (rhs)\n+    {\n+      rhs = get_equiv_expr (TREE_CODE (rhs), rhs);\n+      if (rhs)\n+\t{\n+\t  set_global_equiv (lhs, rhs);\n+\t  return;\n+\t}\n+    }\n+}\n+\n+// If the edge in E is a conditional that sets a pointer equality, set the\n+// conditional pointer equivalency information.\n+\n+void\n+pointer_equiv_analyzer::visit_edge (edge e)\n+{\n+  gimple *stmt = last_stmt (e->src);\n+  tree lhs;\n+  // Recognize: x_13 [==,!=] &foo.\n+  if (stmt\n+      && gimple_code (stmt) == GIMPLE_COND\n+      && (lhs = gimple_cond_lhs (stmt))\n+      && TREE_CODE (lhs) == SSA_NAME\n+      && POINTER_TYPE_P (TREE_TYPE (lhs))\n+      && TREE_CODE (gimple_cond_rhs (stmt)) == ADDR_EXPR)\n+    {\n+      tree_code code = gimple_cond_code (stmt);\n+      if ((code == EQ_EXPR && e->flags & EDGE_TRUE_VALUE)\n+\t  || ((code == NE_EXPR && e->flags & EDGE_FALSE_VALUE)))\n+\tset_cond_equiv (lhs, gimple_cond_rhs (stmt));\n+    }\n+}\n \n // This is the classic EVRP folder which uses a dominator walk and pushes\n // ranges into the next block if it is a single predecessor block.\n@@ -120,6 +421,7 @@ class rvrp_folder : public substitute_and_fold_engine\n   {\n     m_ranger = enable_ranger (cfun);\n     m_simplifier.set_range_query (m_ranger);\n+    m_pta = new pointer_equiv_analyzer (m_ranger);\n   }\n       \n   ~rvrp_folder ()\n@@ -129,23 +431,45 @@ class rvrp_folder : public substitute_and_fold_engine\n \n     m_ranger->export_global_ranges ();\n     disable_ranger (cfun);\n+    delete m_pta;\n   }\n \n   tree value_of_expr (tree name, gimple *s = NULL) OVERRIDE\n   {\n-    return m_ranger->value_of_expr (name, s);\n+    tree ret = m_ranger->value_of_expr (name, s);\n+    if (!ret && is_pointer_ssa (name))\n+      ret = m_pta->get_equiv (name);\n+    return ret;\n   }\n \n   tree value_on_edge (edge e, tree name) OVERRIDE\n   {\n-    return m_ranger->value_on_edge (e, name);\n+    tree ret = m_ranger->value_on_edge (e, name);\n+    if (!ret && is_pointer_ssa (name))\n+      ret = m_pta->get_equiv (name);\n+    return ret;\n   }\n \n   tree value_of_stmt (gimple *s, tree name = NULL) OVERRIDE\n   {\n     return m_ranger->value_of_stmt (s, name);\n   }\n \n+  void pre_fold_bb (basic_block bb) OVERRIDE\n+  {\n+    m_pta->enter (bb);\n+  }\n+\n+  void post_fold_bb (basic_block bb) OVERRIDE\n+  {\n+    m_pta->leave (bb);\n+  }\n+\n+  void pre_fold_stmt (gimple *stmt) OVERRIDE\n+  {\n+    m_pta->visit_stmt (stmt);\n+  }\n+\n   bool fold_stmt (gimple_stmt_iterator *gsi) OVERRIDE\n   {\n     return m_simplifier.simplify (gsi);\n@@ -155,6 +479,7 @@ class rvrp_folder : public substitute_and_fold_engine\n   DISABLE_COPY_AND_ASSIGN (rvrp_folder);\n   gimple_ranger *m_ranger;\n   simplify_using_ranges m_simplifier;\n+  pointer_equiv_analyzer *m_pta;\n };\n \n // In a hybrid folder, start with an EVRP folder, and add the required\n@@ -186,6 +511,7 @@ class hybrid_folder : public evrp_folder\n \tfirst = m_ranger;\n \tsecond = &m_range_analyzer;\n       }\n+    m_pta = new pointer_equiv_analyzer (m_ranger);\n   }\n \n   ~hybrid_folder ()\n@@ -195,6 +521,7 @@ class hybrid_folder : public evrp_folder\n \n     m_ranger->export_global_ranges ();\n     disable_ranger (cfun);\n+    delete m_pta;\n   }\n \n   bool fold_stmt (gimple_stmt_iterator *gsi) OVERRIDE\n@@ -213,6 +540,24 @@ class hybrid_folder : public evrp_folder\n       return false;\n     }\n \n+  void pre_fold_stmt (gimple *stmt) OVERRIDE\n+  {\n+    evrp_folder::pre_fold_stmt (stmt);\n+    m_pta->visit_stmt (stmt);\n+  }\n+\n+  void pre_fold_bb (basic_block bb) OVERRIDE\n+  {\n+    evrp_folder::pre_fold_bb (bb);\n+    m_pta->enter (bb);\n+  }\n+\n+  void post_fold_bb (basic_block bb) OVERRIDE\n+  {\n+    evrp_folder::post_fold_bb (bb);\n+    m_pta->leave (bb);\n+  }\n+\n   tree value_of_expr (tree name, gimple *) OVERRIDE;\n   tree value_on_edge (edge, tree name) OVERRIDE;\n   tree value_of_stmt (gimple *, tree name) OVERRIDE;\n@@ -222,6 +567,7 @@ class hybrid_folder : public evrp_folder\n   gimple_ranger *m_ranger;\n   range_query *first;\n   range_query *second;\n+  pointer_equiv_analyzer *m_pta;\n   tree choose_value (tree evrp_val, tree ranger_val);\n };\n \n@@ -231,6 +577,8 @@ hybrid_folder::value_of_expr (tree op, gimple *stmt)\n {\n   tree evrp_ret = evrp_folder::value_of_expr (op, stmt);\n   tree ranger_ret = m_ranger->value_of_expr (op, stmt);\n+  if (!ranger_ret && is_pointer_ssa (op))\n+    ranger_ret = m_pta->get_equiv (op);\n   return choose_value (evrp_ret, ranger_ret);\n }\n \n@@ -241,6 +589,8 @@ hybrid_folder::value_on_edge (edge e, tree op)\n   // via hybrid_folder::value_of_expr, but without an edge.\n   tree evrp_ret = evrp_folder::value_of_expr (op, NULL);\n   tree ranger_ret = m_ranger->value_on_edge (e, op);\n+  if (!ranger_ret && is_pointer_ssa (op))\n+    ranger_ret = m_pta->get_equiv (op);\n   return choose_value (evrp_ret, ranger_ret);\n }\n "}]}