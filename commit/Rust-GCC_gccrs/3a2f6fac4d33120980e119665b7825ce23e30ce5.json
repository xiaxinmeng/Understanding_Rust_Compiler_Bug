{"sha": "3a2f6fac4d33120980e119665b7825ce23e30ce5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2EyZjZmYWM0ZDMzMTIwOTgwZTExOTY2NWI3ODI1Y2UyM2UzMGNlNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-11-12T23:14:19Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-11-12T23:14:19Z"}, "message": "linux-unwind.h (sparc64_fallback_frame_state): Tidy.\n\n\t* config/sparc/linux-unwind.h (sparc64_fallback_frame_state): Tidy.\n\tDo not schedule an %sp restore.  Compensate for RETURN_ADDR_OFFSET.\n\t(sparc_fallback_frame_state): Tidy.  Compensate for RETURN_ADDR_OFFSET.\nada/\n\t* init.c (GNU/Linux Section): Enable for all architectures.\n\nFrom-SVN: r154132", "tree": {"sha": "d68012b4de0a93c2dcf5308fcb77b23bc99ec693", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d68012b4de0a93c2dcf5308fcb77b23bc99ec693"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a2f6fac4d33120980e119665b7825ce23e30ce5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a2f6fac4d33120980e119665b7825ce23e30ce5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a2f6fac4d33120980e119665b7825ce23e30ce5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a2f6fac4d33120980e119665b7825ce23e30ce5/comments", "author": null, "committer": null, "parents": [{"sha": "7b3ad9f90078038c6bce4b69d07653aec4d446a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b3ad9f90078038c6bce4b69d07653aec4d446a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b3ad9f90078038c6bce4b69d07653aec4d446a6"}], "stats": {"total": 149, "additions": 95, "deletions": 54}, "files": [{"sha": "ca0c28e86b410b74ccc29bd87b042b1a6926fa3f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2f6fac4d33120980e119665b7825ce23e30ce5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2f6fac4d33120980e119665b7825ce23e30ce5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a2f6fac4d33120980e119665b7825ce23e30ce5", "patch": "@@ -1,7 +1,14 @@\n+2009-11-12  Eric Botcazou  <ebotcazou@adacore.com>\n+            Laurent GUERBY  <laurent@guerby.net>\n+\n+\t* config/sparc/linux-unwind.h (sparc64_fallback_frame_state): Tidy.\n+\tDo not schedule an %sp restore.  Compensate for RETURN_ADDR_OFFSET.\n+\t(sparc_fallback_frame_state): Tidy.  Compensate for RETURN_ADDR_OFFSET.\n+\n 2009-11-12  Jan Hubicka  <jh@suse.cz>\n \n-\t* ipa.c (function_and_variable_visibility): Fix my accidentail commit and\n-\tclear DECL_COMMON on localized declarations.\n+\t* ipa.c (function_and_variable_visibility): Fix my accidentail commit\n+\tand clear DECL_COMMON on localized declarations.\n \n 2009-11-12  Bernd Schmidt  <bernd.schmidt@analog.com>\n "}, {"sha": "02f4d8cd0a06bf610040041743cbc9ee0081fd3b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2f6fac4d33120980e119665b7825ce23e30ce5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2f6fac4d33120980e119665b7825ce23e30ce5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3a2f6fac4d33120980e119665b7825ce23e30ce5", "patch": "@@ -1,3 +1,8 @@\n+2009-11-12  Eric Botcazou  <ebotcazou@adacore.com>\n+            Laurent GUERBY  <laurent@guerby.net>\n+\n+\t* init.c (GNU/Linux Section): Enable for all architectures.\n+\n 2009-11-10  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR ada/20548\n@@ -5250,7 +5255,7 @@\n \t* s-oscons-tmplt.c (System.OS_Constants): Do not use special definition\n \tof Msg_Iovlen_T for VMS.\n \n-2009-05-04   Laurent GUERBY  <laurent@guerby.net>\n+2009-05-04  Laurent GUERBY  <laurent@guerby.net>\n \n \tPR ada/38874\n \t* make.adb (Scan_Make_Arg): Pass --param= to compiler and linker."}, {"sha": "a8be23dbb5fb2f711b980d88834414b7805394bc", "filename": "gcc/ada/init.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2f6fac4d33120980e119665b7825ce23e30ce5/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2f6fac4d33120980e119665b7825ce23e30ce5/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=3a2f6fac4d33120980e119665b7825ce23e30ce5", "patch": "@@ -525,8 +525,7 @@ __gnat_install_handler (void)\n /* GNU/Linux Section */\n /*********************/\n \n-#elif defined (linux) && (defined (i386) || defined (__x86_64__) \\\n-                          || defined (__ia64__) || defined (__powerpc__))\n+#elif defined (linux)\n \n #include <signal.h>\n "}, {"sha": "44420663c50e1da24f7454729f75dfe8cac68eac", "filename": "gcc/config/sparc/linux-unwind.h", "status": "modified", "additions": 79, "deletions": 49, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2f6fac4d33120980e119665b7825ce23e30ce5/gcc%2Fconfig%2Fsparc%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2f6fac4d33120980e119665b7825ce23e30ce5/gcc%2Fconfig%2Fsparc%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux-unwind.h?ref=3a2f6fac4d33120980e119665b7825ce23e30ce5", "patch": "@@ -22,11 +22,9 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n-\n /* Do code reading to identify a signal frame, and set the frame\n    state data appropriately.  See unwind-dw2.c for the structs.  */\n \n-/* Handle multilib correctly.  */\n #if defined(__arch64__)\n \n /* 64-bit SPARC version */\n@@ -37,50 +35,66 @@ sparc64_fallback_frame_state (struct _Unwind_Context *context,\n \t\t\t      _Unwind_FrameState *fs)\n {\n   unsigned int *pc = context->ra;\n-  long new_cfa, i;\n+  long this_cfa = (long) context->cfa;\n+  long new_cfa, ra_location, shifted_ra_location;\n   long regs_off, fpu_save_off;\n-  long this_cfa, fpu_save;\n+  long fpu_save;\n+  int i;\n \n-  if (pc[0] != 0x82102065\t\t/* mov NR_rt_sigreturn, %g1 */\n-      || pc[1] != 0x91d0206d)\t\t/* ta 0x6d */\n+  if (pc[0] != 0x82102065\t/* mov NR_rt_sigreturn, %g1 */\n+      || pc[1] != 0x91d0206d)\t/* ta 0x6d */\n     return _URC_END_OF_STACK;\n+\n   regs_off = 192 + 128;\n   fpu_save_off = regs_off + (16 * 8) + (3 * 8) + (2 * 4);\n-  this_cfa = (long) context->cfa;\n-  new_cfa = *(long *)((context->cfa) + (regs_off + (14 * 8)));\n+\n+  new_cfa = *(long *)(this_cfa + regs_off + (14 * 8));\n   new_cfa += 2047; /* Stack bias */\n-  fpu_save = *(long *)((this_cfa) + (fpu_save_off));\n+  fpu_save = *(long *)(this_cfa + fpu_save_off);\n   fs->regs.cfa_how = CFA_REG_OFFSET;\n-  fs->regs.cfa_reg = 14;\n-  fs->regs.cfa_offset = new_cfa - (long) context->cfa;\n-  for (i = 1; i < 16; ++i)\n+  fs->regs.cfa_reg = __builtin_dwarf_sp_column ();\n+  fs->regs.cfa_offset = new_cfa - this_cfa;\n+\n+  for (i = 1; i < 16; i++)\n     {\n+      /* We never restore %sp as everything is purely CFA-based.  */\n+      if ((unsigned int) i == __builtin_dwarf_sp_column ())\n+\tcontinue;\n+\n       fs->regs.reg[i].how = REG_SAVED_OFFSET;\n-      fs->regs.reg[i].loc.offset =\n-\tthis_cfa + (regs_off + (i * 8)) - new_cfa;\n+      fs->regs.reg[i].loc.offset\n+\t= this_cfa + regs_off + (i * 8) - new_cfa;\n     }\n-  for (i = 0; i < 16; ++i)\n+  for (i = 0; i < 16; i++)\n     {\n       fs->regs.reg[i + 16].how = REG_SAVED_OFFSET;\n-      fs->regs.reg[i + 16].loc.offset =\n-\tthis_cfa + (i * 8) - new_cfa;\n+      fs->regs.reg[i + 16].loc.offset\n+\t= this_cfa + (i * 8) - new_cfa;\n     }\n   if (fpu_save)\n     {\n-      for (i = 0; i < 64; ++i)\n+      for (i = 0; i < 64; i++)\n \t{\n \t  if (i > 32 && (i & 0x1))\n \t    continue;\n \t  fs->regs.reg[i + 32].how = REG_SAVED_OFFSET;\n-\t  fs->regs.reg[i + 32].loc.offset =\n-\t    (fpu_save + (i * 4)) - new_cfa;\n+\t  fs->regs.reg[i + 32].loc.offset\n+\t    = fpu_save + (i * 4) - new_cfa;\n \t}\n     }\n-  /* Stick return address into %g0, same trick Alpha uses.  */\n-  fs->regs.reg[0].how = REG_SAVED_OFFSET;\n-  fs->regs.reg[0].loc.offset =\n-    this_cfa + (regs_off + (16 * 8) + 8) - new_cfa;\n+\n+  /* State the rules to find the kernel's code \"return address\", which is\n+     the address of the active instruction when the signal was caught.\n+     On the SPARC, since RETURN_ADDR_OFFSET (essentially 8) is defined, we\n+     need to preventively subtract it from the purported return address.  */\n+  ra_location = this_cfa + regs_off + 17 * 8;\n+  shifted_ra_location = this_cfa + regs_off + 19 * 8; /* Y register */\n+  *(long *)shifted_ra_location = *(long *)ra_location - 8;\n   fs->retaddr_column = 0;\n+  fs->regs.reg[0].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[0].loc.offset = shifted_ra_location - new_cfa;\n+  fs->signal_frame = 1;\n+\n   return _URC_NO_REASON;\n }\n \n@@ -94,19 +108,23 @@ sparc_fallback_frame_state (struct _Unwind_Context *context,\n \t\t\t    _Unwind_FrameState *fs)\n {\n   unsigned int *pc = context->ra;\n-  int new_cfa, i, oldstyle;\n+  int this_cfa = (int) context->cfa;\n+  int new_cfa, ra_location, shifted_ra_location;\n   int regs_off, fpu_save_off;\n-  int fpu_save, this_cfa;\n+  int fpu_save;\n+  int old_style, i;\n \n-  if (pc[1] != 0x91d02010)\t\t/* ta 0x10 */\n+  if (pc[1] != 0x91d02010)\t/* ta 0x10 */\n     return _URC_END_OF_STACK;\n-  if (pc[0] == 0x821020d8)\t\t/* mov NR_sigreturn, %g1 */\n-    oldstyle = 1;\n+\n+  if (pc[0] == 0x821020d8)\t/* mov NR_sigreturn, %g1 */\n+    old_style = 1;\n   else if (pc[0] == 0x82102065)\t/* mov NR_rt_sigreturn, %g1 */\n-    oldstyle = 0;\n+    old_style = 0;\n   else\n     return _URC_END_OF_STACK;\n-  if (oldstyle)\n+\n+  if (old_style)\n     {\n       regs_off = 96;\n       fpu_save_off = regs_off + (4 * 4) + (16 * 4);\n@@ -116,39 +134,51 @@ sparc_fallback_frame_state (struct _Unwind_Context *context,\n       regs_off = 96 + 128;\n       fpu_save_off = regs_off + (4 * 4) + (16 * 4) + (2 * 4);\n     }\n-  this_cfa = (int) context->cfa;\n-  new_cfa = *(int *)((context->cfa) + (regs_off+(4*4)+(14 * 4)));\n-  fpu_save = *(int *)((this_cfa) + (fpu_save_off));\n+\n+  new_cfa = *(int *)(this_cfa + regs_off + (4 * 4) + (14 * 4));\n+  fpu_save = *(int *)(this_cfa + fpu_save_off);\n   fs->regs.cfa_how = CFA_REG_OFFSET;\n-  fs->regs.cfa_reg = 14;\n-  fs->regs.cfa_offset = new_cfa - (int) context->cfa;\n-  for (i = 1; i < 16; ++i)\n+  fs->regs.cfa_reg = __builtin_dwarf_sp_column ();\n+  fs->regs.cfa_offset = new_cfa - this_cfa;\n+\n+  for (i = 1; i < 16; i++)\n     {\n-      if (i == 14)\n+      /* We never restore %sp as everything is purely CFA-based.  */\n+      if ((unsigned int) i == __builtin_dwarf_sp_column ())\n \tcontinue;\n+\n       fs->regs.reg[i].how = REG_SAVED_OFFSET;\n-      fs->regs.reg[i].loc.offset =\n-\tthis_cfa + (regs_off+(4 * 4)+(i * 4)) - new_cfa;\n+      fs->regs.reg[i].loc.offset\n+\t= this_cfa + regs_off + (4 * 4) + (i * 4) - new_cfa;\n     }\n-  for (i = 0; i < 16; ++i)\n+  for (i = 0; i < 16; i++)\n     {\n       fs->regs.reg[i + 16].how = REG_SAVED_OFFSET;\n-      fs->regs.reg[i + 16].loc.offset =\n-\tthis_cfa + (i * 4) - new_cfa;\n+      fs->regs.reg[i + 16].loc.offset\n+\t= this_cfa + (i * 4) - new_cfa;\n     }\n   if (fpu_save)\n     {\n-      for (i = 0; i < 32; ++i)\n+      for (i = 0; i < 32; i++)\n \t{\n \t  fs->regs.reg[i + 32].how = REG_SAVED_OFFSET;\n-\t  fs->regs.reg[i + 32].loc.offset =\n-\t    (fpu_save + (i * 4)) - new_cfa;\n+\t  fs->regs.reg[i + 32].loc.offset\n+\t    = fpu_save + (i * 4) - new_cfa;\n \t}\n     }\n-  /* Stick return address into %g0, same trick Alpha uses.  */\n-  fs->regs.reg[0].how = REG_SAVED_OFFSET;\n-  fs->regs.reg[0].loc.offset = this_cfa+(regs_off+4)-new_cfa;\n+\n+  /* State the rules to find the kernel's code \"return address\", which is\n+     the address of the active instruction when the signal was caught.\n+     On the SPARC, since RETURN_ADDR_OFFSET (essentially 8) is defined, we\n+     need to preventively subtract it from the purported return address.  */\n+  ra_location = this_cfa + regs_off + 4;\n+  shifted_ra_location = this_cfa + regs_off + 3 * 4; /* Y register */\n+  *(int *)shifted_ra_location = *(int *)ra_location - 8;\n   fs->retaddr_column = 0;\n+  fs->regs.reg[0].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[0].loc.offset = shifted_ra_location - new_cfa;\n+  fs->signal_frame = 1;\n+\n   return _URC_NO_REASON;\n }\n "}]}