{"sha": "637c5064e86aa3150c591003ac5e5d57557627ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM3YzUwNjRlODZhYTMxNTBjNTkxMDAzYWM1ZTVkNTc1NTc2MjdhZA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-11-22T21:56:56Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-11-22T21:56:56Z"}, "message": "(expand_inline_function): Use the original declaration of the inlined function...\n\n(expand_inline_function): Use the original declaration of the inlined\nfunction rather than a redeclaration as the BLOCK_ABSTRACT_ORIGIN of the body.\n\nFrom-SVN: r2774", "tree": {"sha": "3aecefbc769535b293d81d9e56c308812f9e4499", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3aecefbc769535b293d81d9e56c308812f9e4499"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/637c5064e86aa3150c591003ac5e5d57557627ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/637c5064e86aa3150c591003ac5e5d57557627ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/637c5064e86aa3150c591003ac5e5d57557627ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/637c5064e86aa3150c591003ac5e5d57557627ad/comments", "author": null, "committer": null, "parents": [{"sha": "4135e766db246d29aba3f8d21feb18bb77d6b7b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4135e766db246d29aba3f8d21feb18bb77d6b7b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4135e766db246d29aba3f8d21feb18bb77d6b7b9"}], "stats": {"total": 52, "additions": 29, "deletions": 23}, "files": [{"sha": "952a6477ccffe01684321aeaa67961c4f018ecdb", "filename": "gcc/integrate.c", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/637c5064e86aa3150c591003ac5e5d57557627ad/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/637c5064e86aa3150c591003ac5e5d57557627ad/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=637c5064e86aa3150c591003ac5e5d57557627ad", "patch": "@@ -1718,7 +1718,8 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n \n   expand_end_bindings (getdecls (), 1, 1);\n   block = poplevel (1, 1, 0);\n-  BLOCK_ABSTRACT_ORIGIN (block) = fndecl;\n+  BLOCK_ABSTRACT_ORIGIN (block) = (DECL_ABSTRACT_ORIGIN (fndecl) == NULL\n+\t\t\t\t   ? fndecl : DECL_ABSTRACT_ORIGIN (fndecl));\n   poplevel (0, 0, 0);\n   emit_line_note (input_filename, lineno);\n \n@@ -2321,33 +2322,38 @@ subst_constants (loc, insn, map)\n       }\n \n     case SUBREG:\n-      /* SUBREG is ordinary, but don't make nested SUBREGs and try to simplify\n-\t constants.  */\n-      {\n-\trtx inner = SUBREG_REG (x);\n-\trtx new = 0;\n+      /* SUBREG applied to something other than a reg\n+\t should be treated as ordinary, since that must\n+\t be a special hack and we don't know how to treat it specially.\n+\t Consider for example mulsidi3 in m68k.md.\n+\t Ordinary SUBREG of a REG needs this special treatment.  */\n+      if (GET_CODE (SUBREG_REG (x)) == REG)\n+\t{\n+\t  rtx inner = SUBREG_REG (x);\n+\t  rtx new = 0;\n \n-\t/* We can't call subst_constants on &SUBREG_REG (x) because any\n-\t   constant or SUBREG wouldn't be valid inside our SUBEG.  Instead,\n-\t   see what is inside, try to form the new SUBREG and see if that is\n-\t   valid.  We handle two cases: extracting a full word in an \n-\t   integral mode and extracting the low part.  */\n-\tsubst_constants (&inner, NULL_RTX, map);\n+\t  /* We can't call subst_constants on &SUBREG_REG (x) because any\n+\t     constant or SUBREG wouldn't be valid inside our SUBEG.  Instead,\n+\t     see what is inside, try to form the new SUBREG and see if that is\n+\t     valid.  We handle two cases: extracting a full word in an \n+\t     integral mode and extracting the low part.  */\n+\t  subst_constants (&inner, NULL_RTX, map);\n \n-\tif (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT\n-\t    && GET_MODE_SIZE (GET_MODE (x)) == UNITS_PER_WORD\n-\t    && GET_MODE (SUBREG_REG (x)) != VOIDmode)\n-\t  new = operand_subword (inner, SUBREG_WORD (x), 0,\n-\t\t\t\t GET_MODE (SUBREG_REG (x)));\n+\t  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT\n+\t      && GET_MODE_SIZE (GET_MODE (x)) == UNITS_PER_WORD\n+\t      && GET_MODE (SUBREG_REG (x)) != VOIDmode)\n+\t    new = operand_subword (inner, SUBREG_WORD (x), 0,\n+\t\t\t\t   GET_MODE (SUBREG_REG (x)));\n \n-\tif (new == 0 && subreg_lowpart_p (x))\n-\t  new = gen_lowpart_common (GET_MODE (x), inner);\n+\t  if (new == 0 && subreg_lowpart_p (x))\n+\t    new = gen_lowpart_common (GET_MODE (x), inner);\n \n-\tif (new)\n-\t  validate_change (insn, loc, new, 1);\n+\t  if (new)\n+\t    validate_change (insn, loc, new, 1);\n \n-\treturn;\n-      }\n+\t  return;\n+\t}\n+      break;\n \n     case MEM:\n       subst_constants (&XEXP (x, 0), insn, map);"}]}