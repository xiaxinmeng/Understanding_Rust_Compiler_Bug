{"sha": "0386609923577e07354ee63754795b2f729e7e00", "node_id": "C_kwDOANBUbNoAKDAzODY2MDk5MjM1NzdlMDczNTRlZTYzNzU0Nzk1YjJmNzI5ZTdlMDA", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-09-07T08:44:33Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-09-07T10:08:59Z"}, "message": "tree-optimization/106860 - fix profile scaling in split_loop\n\nThe following fixes a mistake in loop splitting which assumes loop\nlatches have a single predecessor and that edge is from the exit\ntest.  Instead work from the single exit edge we have to find the\nedge towards the latch.\n\n\tPR tree-optimization/106860\n\t* tree-ssa-loop-split.cc (split_loop): Find the exit to\n\tlatch edge from the loop exit edge instead of from the\n\tlatch.  Verify we're going to find it.\n\n\t* g++.dg/opt/pr106860.C: New testcase.", "tree": {"sha": "93223fdd5fdda888c75e21b0fe9ec617a4be13a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93223fdd5fdda888c75e21b0fe9ec617a4be13a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0386609923577e07354ee63754795b2f729e7e00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0386609923577e07354ee63754795b2f729e7e00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0386609923577e07354ee63754795b2f729e7e00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0386609923577e07354ee63754795b2f729e7e00/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d14514641d7d2052bc2bf1f09018e1f18f19850a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d14514641d7d2052bc2bf1f09018e1f18f19850a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d14514641d7d2052bc2bf1f09018e1f18f19850a"}], "stats": {"total": 39, "additions": 33, "deletions": 6}, "files": [{"sha": "a0209dcf9daba37a0e723c907d4af7b8345a6a70", "filename": "gcc/testsuite/g++.dg/opt/pr106860.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0386609923577e07354ee63754795b2f729e7e00/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr106860.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0386609923577e07354ee63754795b2f729e7e00/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr106860.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr106860.C?ref=0386609923577e07354ee63754795b2f729e7e00", "patch": "@@ -0,0 +1,23 @@\n+// { dg-do compile }\n+// { dg-options \"-Ofast -ftrapv -fnon-call-exceptions -fno-tree-fre\" }\n+\n+static const int N = 12;\n+int nSlip;\n+\n+int main ()\n+{\n+  int i, j, k, fdot = 0;\n+  int a[N][N];\n+\n+  for ( i = 1; i < nSlip; i++)\n+    {\n+      for ( j = i+1; j < nSlip; j++)\n+        {\n+          for ( k = 0; k < i; k++)\n+            fdot += a[i][k] * a[k][j];\n+          a[i][j] = a[i][j] - fdot;\n+        }\n+   }\n+\n+  return 0;\n+}"}, {"sha": "fad4e8361b0e3d02a63e80694a8938f5fef5119d", "filename": "gcc/tree-ssa-loop-split.cc", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0386609923577e07354ee63754795b2f729e7e00/gcc%2Ftree-ssa-loop-split.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0386609923577e07354ee63754795b2f729e7e00/gcc%2Ftree-ssa-loop-split.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-split.cc?ref=0386609923577e07354ee63754795b2f729e7e00", "patch": "@@ -531,16 +531,17 @@ split_loop (class loop *loop1)\n   tree guard_iv;\n   tree border = NULL_TREE;\n   affine_iv iv;\n+  edge exit1;\n \n-  if (!single_exit (loop1)\n+  if (!(exit1 = single_exit (loop1))\n+      || EDGE_COUNT (exit1->src->succs) != 2\n       /* ??? We could handle non-empty latches when we split the latch edge\n \t (not the exit edge), and put the new exit condition in the new block.\n \t OTOH this executes some code unconditionally that might have been\n \t skipped by the original exit before.  */\n       || !empty_block_p (loop1->latch)\n       || !easy_exit_values (loop1)\n-      || !number_of_iterations_exit (loop1, single_exit (loop1), &niter,\n-\t\t\t\t     false, true)\n+      || !number_of_iterations_exit (loop1, exit1, &niter, false, true)\n       || niter.cmp == ERROR_MARK\n       /* We can't yet handle loops controlled by a != predicate.  */\n       || niter.cmp == NE_EXPR)\n@@ -644,10 +645,13 @@ split_loop (class loop *loop1)\n \tfix_loop_bb_probability (loop1, loop2, true_edge, false_edge);\n \n \t/* Fix first loop's exit probability after scaling.  */\n-\tedge exit_to_latch1 = single_pred_edge (loop1->latch);\n+\tedge exit_to_latch1;\n+\tif (EDGE_SUCC (exit1->src, 0) == exit1)\n+\t  exit_to_latch1 = EDGE_SUCC (exit1->src, 1);\n+\telse\n+\t  exit_to_latch1 = EDGE_SUCC (exit1->src, 0);\n \texit_to_latch1->probability *= true_edge->probability;\n-\tsingle_exit (loop1)->probability\n-\t  = exit_to_latch1->probability.invert ();\n+\texit1->probability = exit_to_latch1->probability.invert ();\n \n \t/* Finally patch out the two copies of the condition to be always\n \t   true/false (or opposite).  */"}]}