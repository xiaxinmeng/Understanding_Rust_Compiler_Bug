{"sha": "62e6765158cccdf7ee5f4db36d55c3d009904ced", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJlNjc2NTE1OGNjY2RmN2VlNWY0ZGIzNmQ1NWMzZDAwOTkwNGNlZA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-02-01T11:25:21Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-02-01T11:25:21Z"}, "message": "stl_bvector.h: Wrap overlong lines...\n\n2004-02-01  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/stl_bvector.h: Wrap overlong lines, constify\n\ta few variables, reformat according to the coding standards.\n\t* include/bits/stl_tree.h: Likewise.\n\nFrom-SVN: r77065", "tree": {"sha": "e6dff76fd9dcbc01fa92f877bb767aa374a2eaba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6dff76fd9dcbc01fa92f877bb767aa374a2eaba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62e6765158cccdf7ee5f4db36d55c3d009904ced", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62e6765158cccdf7ee5f4db36d55c3d009904ced", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62e6765158cccdf7ee5f4db36d55c3d009904ced", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62e6765158cccdf7ee5f4db36d55c3d009904ced/comments", "author": null, "committer": null, "parents": [{"sha": "2efe20337fbb258919e0183349c482c03dce94a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2efe20337fbb258919e0183349c482c03dce94a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2efe20337fbb258919e0183349c482c03dce94a0"}], "stats": {"total": 599, "additions": 356, "deletions": 243}, "files": [{"sha": "897134e041db4f53c9d46c130026b5443cbad8af", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e6765158cccdf7ee5f4db36d55c3d009904ced/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e6765158cccdf7ee5f4db36d55c3d009904ced/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=62e6765158cccdf7ee5f4db36d55c3d009904ced", "patch": "@@ -1,3 +1,9 @@\n+2004-02-01  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/stl_bvector.h: Wrap overlong lines, constify\n+\ta few variables, reformat according to the coding standards.\n+\t* include/bits/stl_tree.h: Likewise.\n+\n 2004-01-31  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/bits/stl_algo.h: Minor additional reformat, add"}, {"sha": "c71861378cd690ad037f547cb420ce07e8dd4767", "filename": "libstdc++-v3/include/bits/stl_bvector.h", "status": "modified", "additions": 254, "deletions": 178, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e6765158cccdf7ee5f4db36d55c3d009904ced/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e6765158cccdf7ee5f4db36d55c3d009904ced/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h?ref=62e6765158cccdf7ee5f4db36d55c3d009904ced", "patch": "@@ -154,8 +154,8 @@ namespace __gnu_norm\n     bool \n     operator<(const _Bit_iterator_base& __i) const \n     {\n-      return _M_p < __i._M_p \n-\t|| (_M_p == __i._M_p && _M_offset < __i._M_offset);\n+      return _M_p < __i._M_p\n+\t     || (_M_p == __i._M_p && _M_offset < __i._M_offset);\n     }\n \n     bool \n@@ -181,7 +181,6 @@ namespace __gnu_norm\n     return _S_word_bit * (__x._M_p - __y._M_p) + __x._M_offset - __y._M_offset;\n   }\n \n-\n   struct _Bit_iterator : public _Bit_iterator_base\n   {\n     typedef _Bit_reference  reference;\n@@ -254,7 +253,8 @@ namespace __gnu_norm\n     }\n     \n     reference \n-    operator[](difference_type __i) { return *(*this + __i); }\n+    operator[](difference_type __i)\n+    { return *(*this + __i); }\n   };\n   \n   inline _Bit_iterator \n@@ -347,12 +347,13 @@ namespace __gnu_norm\n     class _Bvector_base\n     : public _Alloc::template rebind<_Bit_type>::other\n     {\n-      typedef typename _Alloc::template rebind<_Bit_type>::other _Bit_alloc_type;\n+      typedef typename _Alloc::template rebind<_Bit_type>::other\n+        _Bit_alloc_type;\n \n     public:\n       typedef _Alloc allocator_type;\n       \n-      allocator_type \n+      allocator_type\n       get_allocator() const \n       { return *static_cast<const _Bit_alloc_type*>(this); }\n       \n@@ -364,7 +365,8 @@ namespace __gnu_norm\n     protected:\n       _Bit_type* \n       _M_bit_alloc(size_t __n) \n-      { return _Bit_alloc_type::allocate((__n + _S_word_bit - 1)/_S_word_bit);}\n+      { return _Bit_alloc_type::allocate((__n + _S_word_bit - 1)\n+\t\t\t\t\t / _S_word_bit); }\n \n       void \n       _M_deallocate() \n@@ -422,9 +424,9 @@ template<typename _Alloc>\n     typedef std::reverse_iterator<iterator> reverse_iterator;\n   \n     typedef typename _Bvector_base<_Alloc>::allocator_type allocator_type;\n-    allocator_type get_allocator() const {\n-      return _Bvector_base<_Alloc>::get_allocator();\n-    }\n+\n+    allocator_type get_allocator() const\n+    { return _Bvector_base<_Alloc>::get_allocator(); }\n   \n   protected:\n     using _Bvector_base<_Alloc>::_M_bit_alloc;\n@@ -434,34 +436,41 @@ template<typename _Alloc>\n     using _Bvector_base<_Alloc>::_M_end_of_storage;\n   \n   protected:\n-    void _M_initialize(size_type __n) {\n-      _Bit_type * __q = this->_M_bit_alloc(__n);\n-      this->_M_end_of_storage = __q + (__n + _S_word_bit - 1)/_S_word_bit;\n+    void _M_initialize(size_type __n)\n+    {\n+      _Bit_type* __q = this->_M_bit_alloc(__n);\n+      this->_M_end_of_storage = __q + (__n + _S_word_bit - 1) / _S_word_bit;\n       this->_M_start = iterator(__q, 0);\n       this->_M_finish = this->_M_start + difference_type(__n);\n     }\n-    void _M_insert_aux(iterator __position, bool __x) {\n-      if (this->_M_finish._M_p != this->_M_end_of_storage) {\n-        std::copy_backward(__position, this->_M_finish, this->_M_finish + 1);\n-        *__position = __x;\n-        ++this->_M_finish;\n-      }\n-      else {\n-        size_type __len = size() \n-\t                  ? 2 * size() : static_cast<size_type>(_S_word_bit);\n-        _Bit_type * __q = this->_M_bit_alloc(__len);\n-        iterator __i = std::copy(begin(), __position, iterator(__q, 0));\n-        *__i++ = __x;\n-        this->_M_finish = std::copy(__position, end(), __i);\n-        this->_M_deallocate();\n-        this->_M_end_of_storage = __q + (__len + _S_word_bit - 1)/_S_word_bit;\n-        this->_M_start = iterator(__q, 0);\n-      }\n+\n+    void _M_insert_aux(iterator __position, bool __x)\n+    {\n+      if (this->_M_finish._M_p != this->_M_end_of_storage)\n+\t{\n+\t  std::copy_backward(__position, this->_M_finish, this->_M_finish + 1);\n+\t  *__position = __x;\n+\t  ++this->_M_finish;\n+\t}\n+      else\n+\t{\n+\t  const size_type __len = size() ? 2 * size()\n+\t                                 : static_cast<size_type>(_S_word_bit);\n+\t  _Bit_type * __q = this->_M_bit_alloc(__len);\n+\t  iterator __i = std::copy(begin(), __position, iterator(__q, 0));\n+\t  *__i++ = __x;\n+\t  this->_M_finish = std::copy(__position, end(), __i);\n+\t  this->_M_deallocate();\n+\t  this->_M_end_of_storage = __q + (__len + _S_word_bit - 1)\n+\t\t\t\t    / _S_word_bit;\n+\t  this->_M_start = iterator(__q, 0);\n+\t}\n     }\n   \n     template<class _InputIterator>\n     void _M_initialize_range(_InputIterator __first, _InputIterator __last,\n-                             input_iterator_tag) {\n+                             input_iterator_tag)\n+    {\n       this->_M_start = iterator();\n       this->_M_finish = iterator();\n       this->_M_end_of_storage = 0;\n@@ -471,90 +480,115 @@ template<typename _Alloc>\n   \n     template<class _ForwardIterator>\n     void _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,\n-                             forward_iterator_tag) {\n-      size_type __n = std::distance(__first, __last);\n+                             forward_iterator_tag)\n+    {\n+      const size_type __n = std::distance(__first, __last);\n       _M_initialize(__n);\n       std::copy(__first, __last, this->_M_start);\n     }\n   \n     template<class _InputIterator>\n     void _M_insert_range(iterator __pos,\n                          _InputIterator __first, _InputIterator __last,\n-                         input_iterator_tag) {\n-      for ( ; __first != __last; ++__first) {\n-        __pos = insert(__pos, *__first);\n-        ++__pos;\n-      }\n+                         input_iterator_tag)\n+    {\n+      for ( ; __first != __last; ++__first)\n+\t{\n+\t  __pos = insert(__pos, *__first);\n+\t  ++__pos;\n+\t}\n     }\n   \n     template<class _ForwardIterator>\n     void _M_insert_range(iterator __position,\n                          _ForwardIterator __first, _ForwardIterator __last,\n-                         forward_iterator_tag) {\n-      if (__first != __last) {\n-        size_type __n = std::distance(__first, __last);\n-        if (capacity() - size() >= __n) {\n-          std::copy_backward(__position, end(),\n-\t\t\t     this->_M_finish + difference_type(__n));\n-          std::copy(__first, __last, __position);\n-          this->_M_finish += difference_type(__n);\n-        }\n-        else {\n-          size_type __len = size() + std::max(size(), __n);\n-          _Bit_type * __q = this->_M_bit_alloc(__len);\n-          iterator __i = std::copy(begin(), __position, iterator(__q, 0));\n-          __i = std::copy(__first, __last, __i);\n-          this->_M_finish = std::copy(__position, end(), __i);\n-          this->_M_deallocate();\n-          this->_M_end_of_storage\n-\t    = __q + (__len + _S_word_bit - 1)/_S_word_bit;\n-          this->_M_start = iterator(__q, 0);\n-        }\n-      }\n-    }      \n+                         forward_iterator_tag)\n+    {\n+      if (__first != __last)\n+\t{\n+\t  size_type __n = std::distance(__first, __last);\n+\t  if (capacity() - size() >= __n)\n+\t    {\n+\t      std::copy_backward(__position, end(),\n+\t\t\t\t this->_M_finish + difference_type(__n));\n+\t      std::copy(__first, __last, __position);\n+\t      this->_M_finish += difference_type(__n);\n+\t    }\n+\t  else\n+\t    {\n+\t      const size_type __len = size() + std::max(size(), __n);\n+\t      _Bit_type * __q = this->_M_bit_alloc(__len);\n+\t      iterator __i = std::copy(begin(), __position, iterator(__q, 0));\n+\t      __i = std::copy(__first, __last, __i);\n+\t      this->_M_finish = std::copy(__position, end(), __i);\n+\t      this->_M_deallocate();\n+\t      this->_M_end_of_storage = __q + (__len + _S_word_bit - 1)\n+\t\t                        / _S_word_bit;\n+\t      this->_M_start = iterator(__q, 0);\n+\t    }\n+\t}\n+    }  \n   \n   public:\n-    iterator begin() { return this->_M_start; }\n-    const_iterator begin() const { return this->_M_start; }\n-    iterator end() { return this->_M_finish; }\n-    const_iterator end() const { return this->_M_finish; }\n+    iterator begin()\n+    { return this->_M_start; }\n+\n+    const_iterator begin() const\n+    { return this->_M_start; }\n+\n+    iterator end()\n+    { return this->_M_finish; }\n+\n+    const_iterator end() const\n+    { return this->_M_finish; }\n   \n-    reverse_iterator rbegin() { return reverse_iterator(end()); }\n-    const_reverse_iterator rbegin() const { \n-      return const_reverse_iterator(end()); \n-    }\n-    reverse_iterator rend() { return reverse_iterator(begin()); }\n-    const_reverse_iterator rend() const { \n-      return const_reverse_iterator(begin()); \n-    }\n+    reverse_iterator rbegin()\n+    { return reverse_iterator(end()); }\n+\n+    const_reverse_iterator rbegin() const\n+    { return const_reverse_iterator(end()); }\n+\n+    reverse_iterator rend()\n+    { return reverse_iterator(begin()); }\n+\n+    const_reverse_iterator rend() const\n+    { return const_reverse_iterator(begin()); }\n   \n-    size_type size() const { return size_type(end() - begin()); }\n-    size_type max_size() const { return size_type(-1); }\n-    size_type capacity() const {\n-      return size_type(const_iterator(this->_M_end_of_storage, 0) - begin());\n-    }\n-    bool empty() const { return begin() == end(); }\n+    size_type size() const\n+    { return size_type(end() - begin()); }\n+\n+    size_type max_size() const\n+    { return size_type(-1); }\n+\n+    size_type capacity() const\n+    { return size_type(const_iterator(this->_M_end_of_storage, 0)\n+\t\t       - begin()); }\n+    bool empty() const\n+    { return begin() == end(); }\n   \n     reference operator[](size_type __n)\n-      { return *(begin() + difference_type(__n)); }\n+    { return *(begin() + difference_type(__n)); }\n+\n     const_reference operator[](size_type __n) const\n-      { return *(begin() + difference_type(__n)); }\n+    { return *(begin() + difference_type(__n)); }\n   \n-    void _M_range_check(size_type __n) const {\n+    void _M_range_check(size_type __n) const\n+    {\n       if (__n >= this->size())\n         __throw_out_of_range(__N(\"vector<bool>::_M_range_check\"));\n     }\n   \n     reference at(size_type __n)\n-      { _M_range_check(__n); return (*this)[__n]; }\n+    { _M_range_check(__n); return (*this)[__n]; }\n+\n     const_reference at(size_type __n) const\n-      { _M_range_check(__n); return (*this)[__n]; }\n+    { _M_range_check(__n); return (*this)[__n]; }\n   \n     explicit vector(const allocator_type& __a = allocator_type())\n       : _Bvector_base<_Alloc>(__a) { }\n   \n     vector(size_type __n, bool __value,\n-              const allocator_type& __a = allocator_type())\n+\t   const allocator_type& __a = allocator_type())\n       : _Bvector_base<_Alloc>(__a)\n     {\n       _M_initialize(__n);\n@@ -568,24 +602,25 @@ template<typename _Alloc>\n       std::fill(this->_M_start._M_p, this->_M_end_of_storage, 0);\n     }\n   \n-    vector(const vector& __x) : _Bvector_base<_Alloc>(__x.get_allocator()) {\n+    vector(const vector& __x) : _Bvector_base<_Alloc>(__x.get_allocator())\n+    {\n       _M_initialize(__x.size());\n       std::copy(__x.begin(), __x.end(), this->_M_start);\n     }\n   \n     // Check whether it's an integral type.  If so, it's not an iterator.\n   \n     template<class _Integer>\n-    void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type) {\n+    void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n+    {\n       _M_initialize(__n);\n       std::fill(this->_M_start._M_p, this->_M_end_of_storage, __x ? ~0 : 0);\n     }\n   \n     template<class _InputIterator>\n     void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n-                                __false_type) {\n-      _M_initialize_range(__first, __last, std::__iterator_category(__first));\n-    }\n+                                __false_type)\n+    { _M_initialize_range(__first, __last, std::__iterator_category(__first)); }\n   \n     template<class _InputIterator>\n     vector(_InputIterator __first, _InputIterator __last,\n@@ -598,12 +633,15 @@ template<typename _Alloc>\n       \n     ~vector() { }\n   \n-    vector& operator=(const vector& __x) {\n-      if (&__x == this) return *this;\n-      if (__x.size() > capacity()) {\n-        this->_M_deallocate();\n-        _M_initialize(__x.size());\n-      }\n+    vector& operator=(const vector& __x)\n+    {\n+      if (&__x == this)\n+\treturn *this;\n+      if (__x.size() > capacity())\n+\t{\n+\t  this->_M_deallocate();\n+\t  _M_initialize(__x.size());\n+\t}\n       std::copy(__x.begin(), __x.end(), begin());\n       this->_M_finish = begin() + difference_type(__x.size());\n       return *this;\n@@ -614,36 +652,43 @@ template<typename _Alloc>\n     // The range version is a member template, so we dispatch on whether\n     // or not the type is an integer.\n   \n-    void _M_fill_assign(size_t __n, bool __x) {\n-      if (__n > size()) {\n-        std::fill(this->_M_start._M_p, this->_M_end_of_storage, __x ? ~0 : 0);\n-        insert(end(), __n - size(), __x);\n-      }\n-      else {\n-        erase(begin() + __n, end());\n-        std::fill(this->_M_start._M_p, this->_M_end_of_storage, __x ? ~0 : 0);\n-      }\n+    void _M_fill_assign(size_t __n, bool __x)\n+    {\n+      if (__n > size())\n+\t{\n+\t  std::fill(this->_M_start._M_p, this->_M_end_of_storage, __x ? ~0 : 0);\n+\t  insert(end(), __n - size(), __x);\n+\t}\n+      else\n+\t{\n+\t  erase(begin() + __n, end());\n+\t  std::fill(this->_M_start._M_p, this->_M_end_of_storage, __x ? ~0 : 0);\n+\t}\n     }\n   \n-    void assign(size_t __n, bool __x) { _M_fill_assign(__n, __x); }\n+    void assign(size_t __n, bool __x)\n+    { _M_fill_assign(__n, __x); }\n   \n     template<class _InputIterator>\n-    void assign(_InputIterator __first, _InputIterator __last) {\n+    void assign(_InputIterator __first, _InputIterator __last)\n+    {\n       typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n       _M_assign_dispatch(__first, __last, _Integral());\n     }\n   \n     template<class _Integer>\n     void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n-      { _M_fill_assign((size_t) __n, (bool) __val); }\n+    { _M_fill_assign((size_t) __n, (bool) __val); }\n   \n     template<class _InputIterator>\n-    void _M_assign_dispatch(_InputIterator __first, _InputIterator __last, __false_type)\n-      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }\n+    void _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n+\t\t\t    __false_type)\n+    { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }\n   \n     template<class _InputIterator>\n     void _M_assign_aux(_InputIterator __first, _InputIterator __last,\n-                       input_iterator_tag) {\n+                       input_iterator_tag)\n+    {\n       iterator __cur = begin();\n       for ( ; __first != __last && __cur != end(); ++__cur, ++__first)\n         *__cur = *__first;\n@@ -655,55 +700,72 @@ template<typename _Alloc>\n   \n     template<class _ForwardIterator>\n     void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n-                       forward_iterator_tag) {\n-      size_type __len = std::distance(__first, __last);\n+                       forward_iterator_tag)\n+    {\n+      const size_type __len = std::distance(__first, __last);\n       if (__len < size())\n         erase(std::copy(__first, __last, begin()), end());\n-      else {\n-        _ForwardIterator __mid = __first;\n-        std::advance(__mid, size());\n-        std::copy(__first, __mid, begin());\n-        insert(end(), __mid, __last);\n-      }\n+      else\n+\t{\n+\t  _ForwardIterator __mid = __first;\n+\t  std::advance(__mid, size());\n+\t  std::copy(__first, __mid, begin());\n+\t  insert(end(), __mid, __last);\n+\t}\n     }    \n   \n-    void reserve(size_type __n) {\n+    void reserve(size_type __n)\n+    {\n       if (__n > this->max_size())\n \t__throw_length_error(__N(\"vector::reserve\"));\n-      if (this->capacity() < __n) {\n-        _Bit_type * __q = this->_M_bit_alloc(__n);\n-        this->_M_finish = std::copy(begin(), end(), iterator(__q, 0));\n-        this->_M_deallocate();\n-        this->_M_start = iterator(__q, 0);\n-        this->_M_end_of_storage = __q + (__n + _S_word_bit - 1)/_S_word_bit;\n-      }\n-    }\n-  \n-    reference front() { return *begin(); }\n-    const_reference front() const { return *begin(); }\n-    reference back() { return *(end() - 1); }\n-    const_reference back() const { return *(end() - 1); }\n-    void push_back(bool __x) {\n+      if (this->capacity() < __n)\n+\t{\n+\t  _Bit_type* __q = this->_M_bit_alloc(__n);\n+\t  this->_M_finish = std::copy(begin(), end(), iterator(__q, 0));\n+\t  this->_M_deallocate();\n+\t  this->_M_start = iterator(__q, 0);\n+\t  this->_M_end_of_storage = __q + (__n + _S_word_bit - 1) / _S_word_bit;\n+\t}\n+    }\n+  \n+    reference front()\n+    { return *begin(); }\n+\n+    const_reference front() const\n+    { return *begin(); }\n+\n+    reference back()\n+    { return *(end() - 1); }\n+\n+    const_reference back() const\n+    { return *(end() - 1); }\n+\n+    void push_back(bool __x)\n+    {\n       if (this->_M_finish._M_p != this->_M_end_of_storage)\n         *this->_M_finish++ = __x;\n       else\n         _M_insert_aux(end(), __x);\n     }\n-    void swap(vector<bool, _Alloc>& __x) {\n+\n+    void swap(vector<bool, _Alloc>& __x)\n+    {\n       std::swap(this->_M_start, __x._M_start);\n       std::swap(this->_M_finish, __x._M_finish);\n       std::swap(this->_M_end_of_storage, __x._M_end_of_storage);\n     }\n \n     // [23.2.5]/1, third-to-last entry in synopsis listing\n-    static void swap(reference __x, reference __y) {\n+    static void swap(reference __x, reference __y)\n+    {\n       bool __tmp = __x;\n       __x = __y;\n       __y = __tmp;\n     }\n \n-    iterator insert(iterator __position, bool __x = bool()) {\n-      difference_type __n = __position - begin();\n+    iterator insert(iterator __position, bool __x = bool())\n+    {\n+      const difference_type __n = __position - begin();\n       if (this->_M_finish._M_p != this->_M_end_of_storage\n \t  && __position == end())\n         *this->_M_finish++ = __x;\n@@ -716,74 +778,88 @@ template<typename _Alloc>\n   \n     template<class _Integer>\n     void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n-                            __true_type) {\n-      _M_fill_insert(__pos, __n, __x);\n-    }\n+                            __true_type)\n+    { _M_fill_insert(__pos, __n, __x); }\n   \n     template<class _InputIterator>\n     void _M_insert_dispatch(iterator __pos,\n                             _InputIterator __first, _InputIterator __last,\n-                            __false_type) {\n-      _M_insert_range(__pos, __first, __last, std::__iterator_category(__first));\n-    }\n+                            __false_type)\n+    { _M_insert_range(__pos, __first, __last,\n+\t\t      std::__iterator_category(__first)); }\n   \n     template<class _InputIterator>\n     void insert(iterator __position,\n-                _InputIterator __first, _InputIterator __last) {\n+                _InputIterator __first, _InputIterator __last)\n+    {\n       typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n       _M_insert_dispatch(__position, __first, __last, _Integral());\n     }\n   \n-    void _M_fill_insert(iterator __position, size_type __n, bool __x) {\n-      if (__n == 0) return;\n-      if (capacity() - size() >= __n) {\n-        std::copy_backward(__position, end(),\n-\t\t\t   this->_M_finish + difference_type(__n));\n-        std::fill(__position, __position + difference_type(__n), __x);\n-        this->_M_finish += difference_type(__n);\n-      }\n-      else {\n-        size_type __len = size() + std::max(size(), __n);\n-        _Bit_type * __q = this->_M_bit_alloc(__len);\n-        iterator __i = std::copy(begin(), __position, iterator(__q, 0));\n-        std::fill_n(__i, __n, __x);\n-        this->_M_finish = std::copy(__position, end(), __i + difference_type(__n));\n-        this->_M_deallocate();\n-        this->_M_end_of_storage = __q + (__len + _S_word_bit - 1)/_S_word_bit;\n-        this->_M_start = iterator(__q, 0);\n-      }\n-    }\n-  \n-    void insert(iterator __position, size_type __n, bool __x) {\n-      _M_fill_insert(__position, __n, __x);\n-    }\n-  \n-    void pop_back() { --this->_M_finish; }\n-    iterator erase(iterator __position) {\n+    void _M_fill_insert(iterator __position, size_type __n, bool __x)\n+    {\n+      if (__n == 0)\n+\treturn;\n+      if (capacity() - size() >= __n)\n+\t{\n+\t  std::copy_backward(__position, end(),\n+\t\t\t     this->_M_finish + difference_type(__n));\n+\t  std::fill(__position, __position + difference_type(__n), __x);\n+\t  this->_M_finish += difference_type(__n);\n+\t}\n+      else\n+\t{\n+\t  const size_type __len = size() + std::max(size(), __n);\n+\t  _Bit_type * __q = this->_M_bit_alloc(__len);\n+\t  iterator __i = std::copy(begin(), __position, iterator(__q, 0));\n+\t  std::fill_n(__i, __n, __x);\n+\t  this->_M_finish = std::copy(__position, end(),\n+\t\t\t\t      __i + difference_type(__n));\n+\t  this->_M_deallocate();\n+\t  this->_M_end_of_storage = __q + (__len + _S_word_bit - 1)\n+\t                            / _S_word_bit;\n+\t  this->_M_start = iterator(__q, 0);\n+\t}\n+    }\n+  \n+    void insert(iterator __position, size_type __n, bool __x)\n+    { _M_fill_insert(__position, __n, __x); }\n+  \n+    void pop_back()\n+    { --this->_M_finish; }\n+\n+    iterator erase(iterator __position)\n+    {\n       if (__position + 1 != end())\n         std::copy(__position + 1, end(), __position);\n-        --this->_M_finish;\n+      --this->_M_finish;\n       return __position;\n     }\n-    iterator erase(iterator __first, iterator __last) {\n+\n+    iterator erase(iterator __first, iterator __last)\n+    {\n       this->_M_finish = std::copy(__last, end(), __first);\n       return __first;\n     }\n-    void resize(size_type __new_size, bool __x = bool()) {\n+\n+    void resize(size_type __new_size, bool __x = bool())\n+    {\n       if (__new_size < size()) \n         erase(begin() + difference_type(__new_size), end());\n       else\n         insert(end(), __new_size - size(), __x);\n     }\n-    void flip() {\n+\n+    void flip()\n+    {\n       for (_Bit_type * __p = this->_M_start._M_p;\n-\t   __p != this->_M_end_of_storage;\n-\t   ++__p)\n+\t   __p != this->_M_end_of_storage; ++__p)\n         *__p = ~*__p;\n     }\n   \n-    void clear() { erase(begin(), end()); }\n+    void clear()\n+    { erase(begin(), end()); }\n   };\n } // namespace __gnu_norm\n \n-#endif \n+#endif"}, {"sha": "9eeccaba0342a6f4e46833f1fc8060f230c0f54e", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 96, "deletions": 65, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e6765158cccdf7ee5f4db36d55c3d009904ced/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e6765158cccdf7ee5f4db36d55c3d009904ced/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=62e6765158cccdf7ee5f4db36d55c3d009904ced", "patch": "@@ -1,6 +1,6 @@\n // RB tree implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -348,16 +348,17 @@ namespace std\n       typedef ptrdiff_t difference_type;\n       \n       typedef _Alloc allocator_type;\n-      allocator_type get_allocator() const {\n-\treturn *static_cast<const _Node_allocator*>(this);\n-      }\n+      allocator_type get_allocator() const\n+      { return *static_cast<const _Node_allocator*>(this); }\n       \n     protected:\n       _Rb_tree_node*\n-      _M_get_node() { return _Node_allocator::allocate(1); }\n+      _M_get_node()\n+      { return _Node_allocator::allocate(1); }\n \n       void \n-      _M_put_node(_Rb_tree_node* __p) { _Node_allocator::deallocate(__p, 1); }\n+      _M_put_node(_Rb_tree_node* __p)\n+      { _Node_allocator::deallocate(__p, 1); }\n       \n       _Link_type\n       _M_create_node(const value_type& __x)\n@@ -367,8 +368,8 @@ namespace std\n \t  { std::_Construct(&__tmp->_M_value_field, __x); }\n \tcatch(...)\n \t  {\n-\t  _M_put_node(__tmp);\n-\t  __throw_exception_again; \n+\t    _M_put_node(__tmp);\n+\t    __throw_exception_again; \n \t  }\n \treturn __tmp;\n       }\n@@ -397,58 +398,76 @@ namespace std\n       \n     protected:\n       _Base_ptr&\n-      _M_root() { return this->_M_header._M_parent; }\n+      _M_root()\n+      { return this->_M_header._M_parent; }\n \n       _Const_Base_ptr\n-      _M_root() const { return this->_M_header._M_parent; }\n+      _M_root() const\n+      { return this->_M_header._M_parent; }\n \n       _Base_ptr&\n-      _M_leftmost() { return this->_M_header._M_left; }\n+      _M_leftmost()\n+      { return this->_M_header._M_left; }\n \n       _Const_Base_ptr\n-      _M_leftmost() const { return this->_M_header._M_left; }\n+      _M_leftmost() const\n+      { return this->_M_header._M_left; }\n \n       _Base_ptr&\n-      _M_rightmost() { return this->_M_header._M_right; }\n+      _M_rightmost()\n+      { return this->_M_header._M_right; }\n \n       _Const_Base_ptr\n-      _M_rightmost() const { return this->_M_header._M_right; }\n+      _M_rightmost() const\n+      { return this->_M_header._M_right; }\n \n       _Link_type\n-      _M_begin() { return static_cast<_Link_type>(this->_M_header._M_parent); }\n+      _M_begin()\n+      { return static_cast<_Link_type>(this->_M_header._M_parent); }\n \n       _Const_Link_type\n-      _M_begin() const { return static_cast<_Const_Link_type>(this->_M_header._M_parent); }\n+      _M_begin() const\n+      { return static_cast<_Const_Link_type>(this->_M_header._M_parent); }\n \n       _Link_type\n-      _M_end() { return static_cast<_Link_type>(&this->_M_header); }\n+      _M_end()\n+      { return static_cast<_Link_type>(&this->_M_header); }\n \n       _Const_Link_type\n-      _M_end() const { return static_cast<_Const_Link_type>(&this->_M_header); }\n+      _M_end() const\n+      { return static_cast<_Const_Link_type>(&this->_M_header); }\n \n       static const_reference \n-      _S_value(_Const_Link_type __x) { return __x->_M_value_field; }\n+      _S_value(_Const_Link_type __x)\n+      { return __x->_M_value_field; }\n \n       static const _Key& \n-      _S_key(_Const_Link_type __x) { return _KeyOfValue()(_S_value(__x)); }\n+      _S_key(_Const_Link_type __x)\n+      { return _KeyOfValue()(_S_value(__x)); }\n \n       static _Link_type\n-      _S_left(_Base_ptr __x) { return static_cast<_Link_type>(__x->_M_left); }\n+      _S_left(_Base_ptr __x)\n+      { return static_cast<_Link_type>(__x->_M_left); }\n \n       static _Const_Link_type\n-      _S_left(_Const_Base_ptr __x) { return static_cast<_Const_Link_type>(__x->_M_left); }\n+      _S_left(_Const_Base_ptr __x)\n+      { return static_cast<_Const_Link_type>(__x->_M_left); }\n \n       static _Link_type\n-      _S_right(_Base_ptr __x) { return static_cast<_Link_type>(__x->_M_right); }\n+      _S_right(_Base_ptr __x)\n+      { return static_cast<_Link_type>(__x->_M_right); }\n \n       static _Const_Link_type\n-      _S_right(_Const_Base_ptr __x) { return static_cast<_Const_Link_type>(__x->_M_right); }\n+      _S_right(_Const_Base_ptr __x)\n+      { return static_cast<_Const_Link_type>(__x->_M_right); }\n \n       static const_reference\n-      _S_value(_Const_Base_ptr __x) { return static_cast<_Const_Link_type>(__x)->_M_value_field; }\n+      _S_value(_Const_Base_ptr __x)\n+      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }\n \n       static const _Key& \n-      _S_key(_Const_Base_ptr __x) { return _KeyOfValue()(_S_value(__x)); }\n+      _S_key(_Const_Base_ptr __x)\n+      { return _KeyOfValue()(_S_value(__x)); }\n \n       static _Base_ptr \n       _S_minimum(_Base_ptr __x) \n@@ -538,40 +557,52 @@ namespace std\n     public:    \n       // Accessors.\n       _Compare \n-      key_comp() const { return _M_key_compare; }\n+      key_comp() const\n+      { return _M_key_compare; }\n \n       iterator \n-      begin() { return static_cast<_Link_type>(this->_M_header._M_left); }\n+      begin()\n+      { return static_cast<_Link_type>(this->_M_header._M_left); }\n \n       const_iterator \n-      begin() const { return static_cast<_Const_Link_type>(this->_M_header._M_left); }\n+      begin() const\n+      { return static_cast<_Const_Link_type>(this->_M_header._M_left); }\n \n       iterator \n-      end() { return static_cast<_Link_type>(&this->_M_header); }\n+      end()\n+      { return static_cast<_Link_type>(&this->_M_header); }\n \n       const_iterator\n-      end() const { return static_cast<_Const_Link_type>(&this->_M_header); }\n+      end() const\n+      { return static_cast<_Const_Link_type>(&this->_M_header); }\n \n       reverse_iterator \n-      rbegin() { return reverse_iterator(end()); }\n+      rbegin()\n+      { return reverse_iterator(end()); }\n \n       const_reverse_iterator \n-      rbegin() const { return const_reverse_iterator(end()); }\n+      rbegin() const\n+      { return const_reverse_iterator(end()); }\n \n       reverse_iterator \n-      rend() { return reverse_iterator(begin()); }\n+      rend()\n+      { return reverse_iterator(begin()); }\n \n       const_reverse_iterator \n-      rend() const { return const_reverse_iterator(begin()); }\n+      rend() const\n+      { return const_reverse_iterator(begin()); }\n  \n       bool \n-      empty() const { return _M_node_count == 0; }\n+      empty() const\n+      { return _M_node_count == 0; }\n \n       size_type \n-      size() const { return _M_node_count; }\n+      size() const\n+      { return _M_node_count; }\n \n       size_type \n-      max_size() const { return size_type(-1); }\n+      max_size() const\n+      { return size_type(-1); }\n \n       void \n       swap(_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __t);\n@@ -658,8 +689,8 @@ namespace std\n     operator==(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, \n \t       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)\n     {\n-      return __x.size() == __y.size() && \n-\tequal(__x.begin(), __x.end(), __y.begin());\n+      return __x.size() == __y.size()\n+\t     && equal(__x.begin(), __x.end(), __y.begin());\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue, \n@@ -738,8 +769,8 @@ namespace std\n       _Link_type __z = _M_create_node(__v);\n       bool __insert_left;\n \n-      __insert_left = __x != 0 || __p == _M_end() ||\n-                      _M_key_compare(_KeyOfValue()(__v), _S_key(__p));\n+      __insert_left = __x != 0 || __p == _M_end()\n+\t              || _M_key_compare(_KeyOfValue()(__v), _S_key(__p));\n \n       _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,  this->_M_header);\n       ++_M_node_count;\n@@ -757,8 +788,8 @@ namespace std\n       while (__x != 0) \n \t{\n \t  __y = __x;\n-\t  __x = _M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ? \n-\t    _S_left(__x) : _S_right(__x);\n+\t  __x = _M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?\n+\t        _S_left(__x) : _S_right(__x);\n \t}\n       return _M_insert(__x, __y, __v);\n     }\n@@ -818,15 +849,15 @@ namespace std\n       _Link_type __x = _M_begin();\n       _Link_type __y = _M_end();\n       bool __comp = true;\n-      while (__x != 0) \n+      while (__x != 0)\n \t{\n \t  __y = __x;\n \t  __comp = _M_key_compare(_KeyOfValue()(__v), _S_key(__x));\n \t  __x = __comp ? _S_left(__x) : _S_right(__x);\n \t}\n-      iterator __j = iterator(__y);   \n+      iterator __j = iterator(__y);\n       if (__comp)\n-\tif (__j == begin())     \n+\tif (__j == begin())\n \t  return pair<iterator,bool>(_M_insert(__x, __y, __v), true);\n \telse\n \t  --__j;\n@@ -835,7 +866,6 @@ namespace std\n       return pair<iterator,bool>(__j, false);\n     }\n   \n-\n   template<typename _Key, typename _Val, typename _KeyOfValue, \n            typename _Compare, typename _Alloc>\n     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator \n@@ -845,8 +875,8 @@ namespace std\n       if (__position._M_node == _M_leftmost())\n \t{ \n \t  // begin()\n-\t  if (size() > 0 && \n-\t      _M_key_compare(_KeyOfValue()(__v), _S_key(__position._M_node)))\n+\t  if (size() > 0\n+\t      && _M_key_compare(_KeyOfValue()(__v), _S_key(__position._M_node)))\n \t    return _M_insert(__position._M_node, __position._M_node, __v);\n \t  // first argument just needs to be non-null \n \t  else\n@@ -887,8 +917,9 @@ namespace std\n       if (__position._M_node == _M_leftmost())\n \t{ \n \t  // begin()\n-\t  if (size() > 0 && \n-\t      !_M_key_compare(_S_key(__position._M_node), _KeyOfValue()(__v)))\n+\t  if (size() > 0\n+\t      && !_M_key_compare(_S_key(__position._M_node),\n+\t\t\t\t _KeyOfValue()(__v)))\n \t    return _M_insert(__position._M_node, __position._M_node, __v);\n \t  // first argument just needs to be non-null \n \t  else\n@@ -1060,7 +1091,7 @@ namespace std\n   \n   template<typename _Key, typename _Val, typename _KeyOfValue, \n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator \n+    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     find(const _Key& __k) const\n     {\n@@ -1086,7 +1117,7 @@ namespace std\n     count(const _Key& __k) const\n     {\n       pair<const_iterator, const_iterator> __p = equal_range(__k);\n-      size_type __n = std::distance(__p.first, __p.second);\n+      const size_type __n = std::distance(__p.first, __p.second);\n       return __n;\n     }\n \n@@ -1165,23 +1196,23 @@ namespace std\n   template<typename _Key, typename _Val, typename _KeyOfValue, \n            typename _Compare, typename _Alloc>\n     inline \n-    pair<typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator,\n-\t\t\t\t\t\t\t\t   typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator>\n+    pair<typename _Rb_tree<_Key,_Val,_KeyOfValue,\n+\t\t\t   _Compare,_Alloc>::iterator,\n+\t typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator>\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     equal_range(const _Key& __k)\n     { return pair<iterator, iterator>(lower_bound(__k), upper_bound(__k)); }\n \n   template<typename _Key, typename _Val, typename _KoV, \n            typename _Compare, typename _Alloc>\n   inline \n-  pair<typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::const_iterator,\n-\t\t\t\t\t\t\t\ttypename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::const_iterator>\n+  pair<typename _Rb_tree<_Key, _Val, _KoV,\n+\t\t\t _Compare, _Alloc>::const_iterator,\n+       typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::const_iterator>\n   _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>\n   ::equal_range(const _Key& __k) const\n-  {\n-    return pair<const_iterator,const_iterator>(lower_bound(__k),\n-\t\t\t\t\t       upper_bound(__k));\n-  }\n+  { return pair<const_iterator, const_iterator>(lower_bound(__k),\n+\t\t\t\t\t\tupper_bound(__k)); }\n \n   unsigned int\n   _Rb_tree_black_count(const _Rb_tree_node_base* __node,\n@@ -1193,9 +1224,9 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const\n     {\n     if (_M_node_count == 0 || begin() == end())\n-      return _M_node_count == 0 && begin() == end() &&\n-\tthis->_M_header._M_left == _M_end() &&\n-\tthis->_M_header._M_right == _M_end();\n+      return _M_node_count == 0 && begin() == end()\n+\t     && this->_M_header._M_left == _M_end()\n+\t     &&\tthis->_M_header._M_right == _M_end();\n   \n     unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());\n     for (const_iterator __it = begin(); __it != end(); ++__it) "}]}