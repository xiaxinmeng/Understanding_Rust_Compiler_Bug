{"sha": "cbc848da46639c42ceaf193ea8dab1cdeea02a6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JjODQ4ZGE0NjYzOWM0MmNlYWYxOTNlYThkYWIxY2RlZWEwMmE2Zg==", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@redhat.com", "date": "2004-02-04T20:43:32Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@gcc.gnu.org", "date": "2004-02-04T20:43:32Z"}, "message": "SwingUtilities.java: Many new functions.\n\n2004-02-02  Graydon Hoare  <graydon@redhat.com>\n\n\t* javax/swing/SwingUtilities.java: Many new functions.\n\t* java/awt/Container.java (LightweightDispatcher): Reimplement.\n\t* javax/swing/basic/BasicGraphicsUtils.java\n\t(getPreferredButtonSize): Start layout from top-left corner.\n\nFrom-SVN: r77271", "tree": {"sha": "5f0aba49c0378ed3fa7fbc0f8e3945f14d78cae9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f0aba49c0378ed3fa7fbc0f8e3945f14d78cae9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbc848da46639c42ceaf193ea8dab1cdeea02a6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbc848da46639c42ceaf193ea8dab1cdeea02a6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbc848da46639c42ceaf193ea8dab1cdeea02a6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbc848da46639c42ceaf193ea8dab1cdeea02a6f/comments", "author": null, "committer": null, "parents": [{"sha": "7e63a64ecec9cbef98c626771e0c4d9ed0ff6347", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e63a64ecec9cbef98c626771e0c4d9ed0ff6347", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e63a64ecec9cbef98c626771e0c4d9ed0ff6347"}], "stats": {"total": 758, "additions": 652, "deletions": 106}, "files": [{"sha": "35e896f1e18bc41a3efb4419187c053a25d1587d", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbc848da46639c42ceaf193ea8dab1cdeea02a6f/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbc848da46639c42ceaf193ea8dab1cdeea02a6f/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=cbc848da46639c42ceaf193ea8dab1cdeea02a6f", "patch": "@@ -1,3 +1,10 @@\n+2004-02-02  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* javax/swing/SwingUtilities.java: Many new functions.\n+\t* java/awt/Container.java (LightweightDispatcher): Reimplement.\n+\t* javax/swing/basic/BasicGraphicsUtils.java \n+\t(getPreferredButtonSize): Start layout from top-left corner.\n+\n 2004-02-04  Olga Rodimina  <rodimina@redhat.com>\n \n \t* java/awt/geom/AffineTransform.java: "}, {"sha": "ff1dde1eae421ad69ac96bf89797bd0caf4d72bc", "filename": "libjava/java/awt/Container.java", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbc848da46639c42ceaf193ea8dab1cdeea02a6f/libjava%2Fjava%2Fawt%2FContainer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbc848da46639c42ceaf193ea8dab1cdeea02a6f/libjava%2Fjava%2Fawt%2FContainer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FContainer.java?ref=cbc848da46639c42ceaf193ea8dab1cdeea02a6f", "patch": "@@ -52,6 +52,7 @@\n import java.util.EventListener;\n import java.util.Set;\n import javax.accessibility.Accessible;\n+import javax.swing.SwingUtilities;\n \n /**\n  * A generic window toolkit object that acts as a container for other objects.\n@@ -1541,80 +1542,82 @@ class LightweightDispatcher implements Serializable\n     nativeContainer = c;\n   }\n \n-  void dispose()\n-  {\n-  }\n-\n   void enableEvents(long l)\n   {\n     eventMask |= l;\n   }\n \n-  void mouseExit (MouseEvent me, int x, int y)\n-  {\n-  }\n-\n-  void acquireComponentForMouseEvent (MouseEvent me)\n+  void acquireComponentForMouseEvent(MouseEvent me)\n   {\n     int x = me.getX ();\n     int y = me.getY ();\n-\n     Component candidate = mouseEventTarget;\n-\n-    boolean candidate_is_container_with_children = \n-      ((candidate != null)\n-       && (candidate instanceof Container)\n-       && (((Container)candidate).getComponentCount () > 0));\n-\n-    boolean candidate_does_not_contain_point =\n-      ((candidate != null)\n-       && (! candidate.contains (x - candidate.getX (),\n-                                 y - candidate.getY ())));\n-\n-    if (candidate == null\n-        || candidate_is_container_with_children\n-        || candidate_does_not_contain_point)\n+    \n+    while(candidate != null)\n       {\n-        // Try to reacquire.\n-        candidate = nativeContainer.findComponentAt (x, y);\n+        if (candidate.isShowing())\n+          {\n+            // Convert our point to the candidate's parent's space.\n+            Point cp = SwingUtilities.convertPoint(nativeContainer, x, y, candidate);\n+            \n+            // If the event lands inside candidate, we have a hit.\n+            if (candidate.contains(cp.x, cp.y))\n+              {\n+                // If candidate has children, we refine the hit.\n+                if (candidate instanceof Container &&\n+                    ((Container)candidate).getComponentCount() > 0)              \n+                  candidate = SwingUtilities.getDeepestComponentAt(candidate, cp.x, cp.y);\n+                break;\n+              }\n+          }        \n+        // If candidate isn't showing or doesn't contain point, we back out a level.\n+        candidate = candidate.getParent();\n+      }\n+    \n+    if (candidate == null)\n+      {\n+        // We either lost, or never had, a candidate; acquire from our native.\n+        candidate = \n+          SwingUtilities.getDeepestComponentAt(nativeContainer, x, y);\n       }\n \n+\n+    // If our candidate is new, inform the old target we're leaving.\n     if (mouseEventTarget != null\n+        && mouseEventTarget.isShowing()\n         && mouseEventTarget != candidate)\n       {\n-        int nx = x - mouseEventTarget.getX ();\n-        int ny = y - mouseEventTarget.getY ();\n+        Point tp = \n+          SwingUtilities.convertPoint(nativeContainer, \n+                                      x, y, mouseEventTarget);\n         MouseEvent exited = new MouseEvent (mouseEventTarget, \n                                             MouseEvent.MOUSE_EXITED,\n                                             me.getWhen (), \n                                             me.getModifiers (), \n-                                            nx, ny,\n+                                            tp.x, tp.y,\n                                             me.getClickCount (),\n                                             me.isPopupTrigger (),\n                                             me.getButton ());\n         mouseEventTarget.dispatchEvent (exited); \n         mouseEventTarget = null;\n       }\n \n+    // If we have a candidate, maybe enter it.\n     if (candidate != null)\n       {\n-        // Possibly set new state.\n         if (candidate.isLightweight() \n+            && candidate.isShowing()\n             && candidate != nativeContainer\n             && candidate != mouseEventTarget)\n-\t  {\n-\t\t\t\n+\t  {\t\t\t\n             mouseEventTarget = candidate;\n-\t\t\t\n-            int nx = x - mouseEventTarget.getX ();\n-            int ny = y - mouseEventTarget.getY ();\n-\t\t\t\n-            // If acquired, enter it.\n+            Point cp = SwingUtilities.convertPoint(nativeContainer, \n+                                                   x, y, candidate);\n             MouseEvent entered = new MouseEvent (mouseEventTarget, \n                                                  MouseEvent.MOUSE_ENTERED,\n                                                  me.getWhen (), \n                                                  me.getModifiers (), \n-                                                 nx, ny,\n+                                                 cp.x, cp.y,\n                                                  me.getClickCount (),\n                                                  me.isPopupTrigger (),\n                                                  me.getButton ());\n@@ -1623,39 +1626,32 @@ void acquireComponentForMouseEvent (MouseEvent me)\n       }\n   }\n \n-  boolean handleEvent (AWTEvent e)\n+  boolean handleEvent(AWTEvent e)\n   {\n-    if ((eventMask & e.getID ()) == 0)\n+    if ((eventMask & e.getID()) == 0)\n       return false;\n \n     if (e instanceof MouseEvent)\n       {\n         MouseEvent me = (MouseEvent) e;\n-        acquireComponentForMouseEvent (me);\n+        acquireComponentForMouseEvent(me);\n \n-        // Avoid dispatching an ENTERED event twice\n+        // Avoid dispatching an ENTERED event twice.\n         if (mouseEventTarget != null\n+            && mouseEventTarget.isShowing()\n             && e.getID() != MouseEvent.MOUSE_ENTERED)\n           {\n-            // Calculate point translation for the event target.\n-            // We use absolute location on screen rather than relative\n-            // location because the event target might be a nested child.\n-            Point parentLocation = nativeContainer.getLocationOnScreen();\n-            Point childLocation = mouseEventTarget.getLocationOnScreen();\n-            me.translatePoint(parentLocation.x - childLocation.x,\n-                              parentLocation.y - childLocation.y);\n-\n-            Component oldSource = (Component) me.getSource ();\n-            me.setSource (mouseEventTarget);\n-            mouseEventTarget.dispatchEvent (me);\n-            me.setSource (oldSource);\n+            MouseEvent newEvt = \n+              SwingUtilities.convertMouseEvent(nativeContainer, me, \n+                                               mouseEventTarget);\n+            mouseEventTarget.dispatchEvent(newEvt);\n           }\n       }\n     else if (e instanceof KeyEvent && focus != null)\n       {\n-        focus.processKeyEvent ((KeyEvent) e);\n+        focus.processKeyEvent((KeyEvent) e);\n       }\n-      \n+    \n     return e.isConsumed();\n   }\n "}, {"sha": "e226919eb3921f7693658a761d272800a059065c", "filename": "libjava/javax/swing/SwingUtilities.java", "status": "modified", "additions": 591, "deletions": 48, "changes": 639, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbc848da46639c42ceaf193ea8dab1cdeea02a6f/libjava%2Fjavax%2Fswing%2FSwingUtilities.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbc848da46639c42ceaf193ea8dab1cdeea02a6f/libjava%2Fjavax%2Fswing%2FSwingUtilities.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FSwingUtilities.java?ref=cbc848da46639c42ceaf193ea8dab1cdeea02a6f", "patch": "@@ -1,4 +1,4 @@\n-/* SwingUtilities.java -- \n+/* SwingUtilities.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -35,10 +35,11 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n+import java.applet.Applet;\n import java.awt.Component;\n+import java.awt.ComponentOrientation;\n import java.awt.Container;\n import java.awt.EventQueue;\n import java.awt.Font;\n@@ -55,81 +56,623 @@\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleStateSet;\n \n+\n+/**\n+ * This class contains a number of static utility functions which are\n+ * useful when drawing swing components, dispatching events, or calculating\n+ * regions which need painting.\n+ *\n+ * @author Graydon Hoare (graydon&064;redhat.com)\n+ */\n public class SwingUtilities implements SwingConstants\n {\n-  public static FontMetrics getFontMetrics (Font font)\n+\n+  /**\n+   * Calculates the portion of the base rectangle which is inside the\n+   * insets.\n+   *\n+   * @param base The rectangle to apply the insets to\n+   * @param insets The insets to apply to the base rectangle\n+   * @param ret A rectangle to use for storing the return value, or\n+   * <code>null</code>\n+   *\n+   * @return The calculated area inside the base rectangle and its insets,\n+   * either stored in ret or a new Rectangle if ret is <code>null</code>\n+   *\n+   * @see #calculateInnerArea\n+   */\n+  public static Rectangle calculateInsetArea(Rectangle base, Insets insets,\n+                                             Rectangle ret)\n+  {\n+    if (ret == null)\n+      ret = new Rectangle();\n+    ret.setBounds(base.x + insets.left, base.y + insets.top,\n+                  base.width - (insets.left + insets.right),\n+                  base.height - (insets.top + insets.bottom));\n+    return ret;\n+  }\n+\n+  /**\n+   * Calculates the portion of the component's bounds which is inside the\n+   * component's border insets. This area is usually the area a component\n+   * should confine its painting to.\n+   *\n+   * @param c The component to measure the bounds of\n+   * @param r A Rectangle to store the return value in, or\n+   * <code>null</code>\n+   *\n+   * @return The calculated area inside the component and its border\n+   * insets\n+   *\n+   * @see #calculateInsetArea\n+   */\n+  public static Rectangle calculateInnerArea(JComponent c, Rectangle r)\n   {\n-    return Toolkit.getDefaultToolkit ().getFontMetrics (font);\n+    return calculateInsetArea(c.getBounds(), c.getInsets(), r);\n   }\n \n-  public static JRootPane getRootPane (Component a)\n+  /**\n+   * Calculates the bounds of a component in the component's own coordinate\n+   * space. The result has the same height and width as the component's\n+   * bounds, but its location is set to (0,0).\n+   *\n+   * @param aComponent The component to measure\n+   *\n+   * @return The component's bounds in its local coordinate space\n+   */\n+  public static Rectangle getLocalBounds(Component aComponent)\n   {\n-    if (a instanceof JRootPane)\n-      return (JRootPane) a;\n-\t\n-    a = a.getParent();\n+    Rectangle bounds = aComponent.getBounds();\n+    return new Rectangle(0, 0, bounds.x, bounds.y);\n+  }\n+\n+  /**\n+   * Returns the font metrics object for a given font. The metrics can be\n+   * used to calculate crude bounding boxes and positioning information,\n+   * for laying out components with textual elements.\n+   *\n+   * @param font The font to get metrics for\n+   *\n+   * @return The font's metrics\n+   *\n+   * @see java.awt.font.GlyphMetrics\n+   */\n+  public static FontMetrics getFontMetrics(Font font)\n+  {\n+    return Toolkit.getDefaultToolkit().getFontMetrics(font);\n+  }\n \n-    if (a != null)\n+  /**\n+   * If <code>comp</code> is a RootPaneContainer, return its JRootPane.\n+   * Otherwise call <code>getAncestorOfClass(JRootPane.class, a)</code>.\n+   *\n+   * @param comp The component to get the JRootPane of\n+   *\n+   * @return a suitable JRootPane for <code>comp</code>, or <code>null</code>\n+   * \n+   * @see javax.swing.RootPaneContainer#getRootPane\n+   * @see #getAncestorOfClass\n+   */\n+  public static JRootPane getRootPane(Component comp)\n+  {\n+    if (comp instanceof RootPaneContainer)\n+      return ((RootPaneContainer)comp).getRootPane();\n+    else\n+      return (JRootPane) getAncestorOfClass(JRootPane.class, comp);\n+  }\n+\n+  /**\n+   * Returns the least ancestor of <code>comp</code> which has the\n+   * specified name.\n+   *\n+   * @param name The name to search for\n+   * @param comp The component to search the ancestors of\n+   *\n+   * @return The nearest ancestor of <code>comp</code> with the given\n+   * name, or <code>null</code> if no such ancestor exists\n+   *\n+   * @see java.awt.Component#getName\n+   * @see #getAncestorOfClass\n+   */\n+  public static Container getAncestorNamed(String name, Component comp)\n+  {\n+    while (comp != null && (comp.getName() != name))\n+      comp = comp.getParent();\n+    return (Container) comp;\n+  }\n+\n+  /**\n+   * Returns the least ancestor of <code>comp</code> which is an instance\n+   * of the specified class.\n+   *\n+   * @param c The class to search for\n+   * @param comp The component to search the ancestors of\n+   *\n+   * @return The nearest ancestor of <code>comp</code> which is an instance\n+   * of the given class, or <code>null</code> if no such ancestor exists\n+   *\n+   * @see #getAncestorOfClass\n+   * @see #windowForComponent\n+   * @see \n+   * \n+   */\n+  public static Container getAncestorOfClass(Class c, Component comp)\n+  {\n+    while (comp != null && (! c.isInstance(comp)))\n+      comp = comp.getParent();\n+    return (Container) comp;\n+  }\n+\n+  /**\n+   * Equivalent to calling <code>getAncestorOfClass(Window, comp)</code>.\n+   *\n+   * @param comp The component to search for an ancestor window \n+   *\n+   * @return An ancestral window, or <code>null</code> if none exists\n+   */\n+  public static Window windowForComponent(Component comp)\n+  {\n+    return (Window) getAncestorOfClass(Window.class, comp);\n+  }\n+\n+  /**\n+   * Returns the \"root\" of the component tree containint <code>comp</code>\n+   * The root is defined as either the <em>least</em> ancestor of\n+   * <code>comp</code> which is a {@link Window}, or the <em>greatest</em>\n+   * ancestor of <code>comp</code> which is a {@link Applet} if no {@link\n+   * Window} ancestors are found.\n+   *\n+   * @param comp The component to search for a root\n+   *\n+   * @return The root of the component's tree, or <code>null</code>\n+   */\n+  public static Component getRoot(Component comp)\n+  {\n+    Applet app = null;\n+    Window win = null;\n+\n+    while (comp != null)\n       {\n-        return getRootPane(a);\n+        if (win == null && comp instanceof Window)\n+          win = (Window) comp;\n+        else if (comp instanceof Applet)\n+          app = (Applet) comp;\n+        comp = comp.getParent();\n       }\n-    \n-    return null;\n+\n+    if (win != null)\n+      return win;\n+    else\n+      return app;\n+  }\n+\n+  /**\n+   * Return true if a descends from b, in other words if b is an\n+   * ancestor of a.\n+   *\n+   * @param a The child to search the ancestry of\n+   * @param b The potential ancestor to search for\n+   *\n+   * @return true if a is a descendent of b, false otherwise\n+   */\n+  public static boolean isDescendingFrom(Component a, Component b)\n+  {\n+    while (true)\n+      {\n+        if (a == null || b == null)\n+          return false;\n+        if (a == b)\n+          return true;\n+        a = a.getParent();\n+      }\n+  }\n+\n+  /**\n+   * Returns the deepest descendent of parent which is both visible and\n+   * contains the point <code>(x,y)</code>. Returns parent when either\n+   * parent is not a container, or has no children which contain\n+   * <code>(x,y)</code>. Returns <code>null</code> when either\n+   * <code>(x,y)</code> is outside the bounds of parent, or parent is\n+   * <code>null</code>.\n+   * \n+   * @param parent The component to search the descendents of\n+   * @param x Horizontal coordinate to search for\n+   * @param y Vertical coordinate to search for\n+   *\n+   * @return A component containing <code>(x,y)</code>, or\n+   * <code>null</code>\n+   *\n+   * @see java.awt.Container#findComponentAt\n+   */\n+  public static Component getDeepestComponentAt(Component parent, int x, int y)\n+  {\n+    if (parent == null || (! parent.contains(x, y)))\n+      return null;\n+\n+    if (! (parent instanceof Container))\n+      return parent;\n+\n+    Container c = (Container) parent;\n+    return c.findComponentAt(x, y);\n+  }\n+\n+  /**\n+   * Converts a point from a component's local coordinate space to \"screen\"\n+   * coordinates (such as the coordinate space mouse events are delivered\n+   * in). This operation is equivalent to translating the point by the\n+   * location of the component (which is the origin of its coordinate\n+   * space).\n+   *\n+   * @param p The point to convert\n+   * @param c The component which the point is expressed in terms of\n+   *\n+   * @see convertPointFromScreen\n+   */\n+  public static void convertPointToScreen(Point p, Component c)\n+  {\n+    Point c0 = c.getLocationOnScreen();\n+    p.translate(c0.x, c0.y);\n+  }\n+\n+  /**\n+   * Converts a point from \"screen\" coordinates (such as the coordinate\n+   * space mouse events are delivered in) to a component's local coordinate\n+   * space. This operation is equivalent to translating the point by the\n+   * negation of the component's location (which is the origin of its\n+   * coordinate space).\n+   *\n+   * @param p The point to convert\n+   * @param c The component which the point should be expressed in terms of\n+   */\n+  public static void convertPointFromScreen(Point p, Component c)\n+  {\n+    Point c0 = c.getLocationOnScreen();\n+    p.translate(-c0.x, -c0.y);\n+  }\n+\n+  /**\n+   * Converts a point <code>(x,y)</code> from the coordinate space of one\n+   * component to another. This is equivalent to converting the point from\n+   * <code>source</code> space to screen space, then back from screen space\n+   * to <code>destination</code> space. If exactly one of the two\n+   * Components is <code>null</code>, it is taken to refer to the root\n+   * ancestor of the other component. If both are <code>null</code>, no\n+   * transformation is done.\n+   *\n+   * @param source The component which the point is expressed in terms of\n+   * @param x Horizontal coordinate of point to transform\n+   * @param y Vertical coordinate of point to transform\n+   * @param destination The component which the return value will be\n+   * expressed in terms of\n+   *\n+   * @return The point <code>(x,y)</code> converted from the coordinate space of the\n+   * source component to the coordinate space of the destination component\n+   *\n+   * @see #convertPointToScreen\n+   * @see #convertPointFromScreen\n+   * @see #convertRectangle\n+   * @see #getRoot\n+   */\n+  public static Point convertPoint(Component source, int x, int y,\n+                                   Component destination)\n+  {\n+    Point pt = new Point(x, y);\n+\n+    if (source == null && destination == null)\n+      return pt;\n+\n+    if (source == null)\n+      source = getRoot(destination);\n+\n+    if (destination == null)\n+      destination = getRoot(source);\n+\n+    convertPointToScreen(pt, source);\n+    convertPointFromScreen(pt, destination);\n+\n+    return pt;\n+  }\n+\n+  \n+  /**\n+   * Converts a rectangle from the coordinate space of one component to\n+   * another. This is equivalent to converting the rectangle from\n+   * <code>source</code> space to screen space, then back from screen space\n+   * to <code>destination</code> space. If exactly one of the two\n+   * Components is <code>null</code>, it is taken to refer to the root\n+   * ancestor of the other component. If both are <code>null</code>, no\n+   * transformation is done.\n+   *\n+   * @param source The component which the rectangle is expressed in terms of\n+   * @param rect The rectangle to convert\n+   * @param destination The component which the return value will be\n+   * expressed in terms of\n+   *\n+   * @return A new rectangle, equal in size to the input rectangle, but\n+   * with its position converted from the coordinate space of the source\n+   * component to the coordinate space of the destination component\n+   *\n+   * @see #convertPointToScreen\n+   * @see #convertPointFromScreen\n+   * @see #convertPoint\n+   * @see #getRoot\n+   */\n+  public static Rectangle convertRectangle(Component source,\n+                                           Rectangle rect,\n+                                           Component destination)\n+  {\n+    Point pt = convertPoint(source, rect.x, rect.y, destination);\n+    return new Rectangle(pt.x, pt.y, rect.width, rect.height);\n   }\n \n-  public static void updateComponentTreeUI(JFrame comp)\n+  /**\n+   * Convert a mouse event which refrers to one component to another.  This\n+   * includes changing the mouse event's coordinate space, as well as the\n+   * source property of the event. If <code>source</code> is\n+   * <code>null</code>, it is taken to refer to <code>destination</code>'s\n+   * root component. If <code>destination</code> is <code>null</code>, the\n+   * new event will remain expressed in <code>source</code>'s coordinate\n+   * system.\n+   *\n+   * @param source The component the mouse event currently refers to\n+   * @param sourceEvent The mouse event to convert\n+   * @param destination The component the new mouse event should refer to\n+   *\n+   * @return A new mouse event expressed in terms of the destination\n+   * component's coordinate space, and with the destination component as\n+   * its source\n+   *\n+   * @see #convertPoint\n+   */\n+  public static MouseEvent convertMouseEvent(Component source,\n+                                             MouseEvent sourceEvent,\n+                                             Component destination)\n   {\n+    Point newpt = convertPoint(source, sourceEvent.getX(), sourceEvent.getY(),\n+                               destination);\n+\n+    return new MouseEvent(destination, sourceEvent.getID(),\n+                          sourceEvent.getWhen(), sourceEvent.getModifiers(),\n+                          newpt.x, newpt.y, sourceEvent.getClickCount(),\n+                          sourceEvent.isPopupTrigger(), sourceEvent.getButton());\n   }\n \n+  /**\n+   * Recursively walk the component tree under <code>comp</code> calling\n+   * <code>updateUI</code> on each {@link JComponent} found. This causes\n+   * the entire tree to re-initialize its UI delegates.\n+   *\n+   * @param comp The component to walk the children of, calling <code>updateUI</code>\n+   */\n+  public static void updateComponentTreeUI(Component comp)\n+  {\n+    if (comp == null)\n+      return;\n+    \n+    if (comp instanceof Container)\n+      {\n+        Component[] children = ((Container)comp).getComponents();\n+        for (int i = 0; i < children.length; ++i)\n+          updateComponentTreeUI(children[i]);\n+      }\n+\n+    if (comp instanceof JComponent)\n+      ((JComponent)comp).updateUI();\n+  }\n+\n+  /**\n+   * <p>Layout a \"compound label\" consisting of a text string and an icon\n+   * which is to be placed near the rendered text. Once the text and icon\n+   * are laid out, the text rectangle and icon rectangle parameters are\n+   * altered to store the calculated positions.</p>\n+   *\n+   * <p>The size of the text is calculated from the provided font metrics\n+   * object.  This object should be the metrics of the font you intend to\n+   * paint the label with.</p>\n+   *\n+   * <p>The position values control where the text is placed relative to\n+   * the icon. The horizontal position value should be one of the constants\n+   * <code>LEFT</code>, <code>RIGHT</code> or <code>CENTER</code>. The\n+   * vertical position value should be one fo the constants\n+   * <code>TOP</code>, <code>BOTTOM</code>, <code>CENTER</code>.</p>\n+   *\n+   * <p>The text-icon gap value controls the number of pixels between the\n+   * icon and the text.</p>\n+   *\n+   * <p>The alignment values control where the text and icon are placed, as\n+   * a combined unit, within the view rectangle. The horizontal alignment\n+   * value should be one of the constants <code>LEADING</code>,\n+   * <code>TRAILING</code>, <code>LEFT</code>, <code>RIGHT</code> or\n+   * <code>CENTER</code>. The vertical alignment valus should be one of the\n+   * constants <code>TOP</code>, <code>BOTTOM</code> or\n+   * <code>CENTER</code>.</p>\n+   *\n+   * <p>If the <code>LEADING</code> or <code>TRAILING</code> constants are\n+   * given for horizontal alignment, they are interpreted relative to the\n+   * provided component's orientation property, a constant in the {@link\n+   * java.awt.ComponentOrientation} class. For example, if the component's\n+   * orientation is <code>LEFT_TO_RIGHT</code>, then the\n+   * <code>LEADING</code> alignment is a synonym for <code>LEFT</code> and\n+   * the <code>TRAILING</code> alignment is a synonym for\n+   * <code>RIGHT</code></p>\n+   *\n+   * <p>If the text and icon are equal to or larger than the view\n+   * rectangle, the horizontal and vertical alignment values have no\n+   * affect.</p>\n+   *\n+   * @param c A component used for its orientation value\n+   * @param fm The font metrics used to measure the text\n+   * @param text The text to place in the compound label\n+   * @param icon The icon to place next to the text\n+   * @param verticalAlignment The vertical alignment of the label relative\n+   * to its component\n+   * @param horizontalAlignment The horizontal alignment of the label\n+   * relative to its component\n+   * @param verticalTextPosition The vertical position of the label's text\n+   * relative to its icon\n+   * @param horizontalTextPosition The horizontal position of the label's\n+   * text relative to its icon\n+   * @param viewR The view rectangle, specifying the area which layout is\n+   * constrained to\n+   * @param iconR A rectangle which is modified to hold the laid-out\n+   * position of the icon\n+   * @param textR A rectangle which is modified to hold the laid-out\n+   * position of the text\n+   * @param textIconGap The distance between text and icon\n+   *\n+   * @return The string of characters, possibly truncated with an elipsis,\n+   * which is laid out in this label\n+   */\n   public static String layoutCompoundLabel(JComponent c, \n                                            FontMetrics fm,\n-                                           String text,\n-                                           Icon i,\n-                                           int vert_a, \n-                                           int hor_i, \n-                                           int vert_text_pos,\n-                                           int hor_text_pos, \n-                                           Rectangle vr,\n-                                           Rectangle ir, \n-                                           Rectangle tr,\n-                                           int gap)\n-  {\n-    // view rect 'vr' already ok, \n-    // we need to compute ir (icon rect) and tr (text-rect)\n-\t\n-    int next_x = vr.x;\n-    int next_y = vr.y;\n-\t\n-    ir.height = ir.width = ir.y = ir.x = 0;\n-\n-    if (i != null)\n+                                           String text, \n+                                           Icon icon, \n+                                           int verticalAlignment,\n+                                           int horizontalAlignment, \n+                                           int verticalTextPosition,\n+                                           int horizontalTextPosition, \n+                                           Rectangle viewR,\n+                                           Rectangle iconR, \n+                                           Rectangle textR, \n+                                           int textIconGap)\n+  {\n+\n+    // Work out basic height and width.\n+\n+    if (icon == null)\n+      {\n+        textIconGap = 0;\n+        iconR.width = 0;\n+        iconR.height = 0;\n+      }\n+      else\n       {\n-        ir.x = vr.x;\n-        ir.y = vr.y;\n-        ir.width = i.getIconWidth();\n-        ir.height = i.getIconWidth();\n+        iconR.width = icon.getIconWidth();\n+        iconR.height = icon.getIconWidth();\n+      }\n+    textR.width = fm.stringWidth(text);\n+    textR.height = fm.getHeight(); \n \n+    // Work out the position of text and icon, assuming the top-left coord\n+    // starts at (0,0). We will fix that up momentarily, after these\n+    // \"position\" decisions are made and we look at alignment.\n \n-        next_x += gap + i.getIconWidth();\n-        next_y += gap + i.getIconHeight();\n+    switch (horizontalTextPosition)\n+      {\n+      case LEFT:\n+        textR.x = 0;\n+        iconR.x = textR.width + textIconGap;\n+        break;\n+      case RIGHT:\n+        iconR.x = 0;\n+        textR.x = iconR.width + textIconGap;\n+        break;\n+      case CENTER:\n+        int centerLine = Math.max(textR.width, iconR.width) / 2;\n+        textR.x = centerLine - textR.width/2;\n+        iconR.x = centerLine - iconR.width/2;\n+        break;\n       }\n-\t\n-    tr.x = next_x;\n-    tr.y = vr.y; // + (vr.height/2);\n \n-    tr.width  = fm.stringWidth(text);\n-    tr.height = fm.getHeight(); // +  fm.getAscent()/2;\n+    switch (verticalTextPosition)\n+      {\n+      case TOP:\n+        textR.y = 0;\n+        iconR.y = textR.height + textIconGap;\n+        break;\n+      case BOTTOM:\n+        iconR.y = 0;\n+        textR.y = iconR.height + textIconGap;\n+        break;\n+      case CENTER:\n+        int centerLine = Math.max(textR.height, iconR.height) / 2;\n+        textR.y = centerLine - textR.height/2;\n+        iconR.y = centerLine - iconR.height/2;\n+        break;\n+      }\n \n-    return text;\n-  }\n+    // Fix up the orientation-based alignments.\n \n-}\n+    if (horizontalAlignment == LEADING)\n+      {\n+        if (c.getComponentOrientation() == ComponentOrientation.LEFT_TO_RIGHT)\n+          horizontalAlignment = LEFT;\n+        else if (c.getComponentOrientation() == ComponentOrientation.RIGHT_TO_LEFT)\n+          horizontalAlignment = RIGHT;\n+      }\n+    else if (horizontalAlignment == TRAILING)\n+      {\n+        if (c.getComponentOrientation() == ComponentOrientation.LEFT_TO_RIGHT)\n+          horizontalAlignment = RIGHT;\n+        else if (c.getComponentOrientation() == ComponentOrientation.RIGHT_TO_LEFT)\n+          horizontalAlignment = LEFT;\n+      }\n \n+    // The two rectangles are laid out correctly now, but only assuming\n+    // that their upper left corner is at (0,0). If we have any alignment other\n+    // than TOP and LEFT, we need to adjust them.\n \n+    Rectangle u = textR.union(iconR);\n+    int horizontalAdjustment = viewR.x;\n+    int verticalAdjustment = viewR.y;\n+    switch (verticalAlignment)\n+      {\n+      case TOP:\n+        break;\n+      case BOTTOM:\n+        verticalAdjustment += (viewR.height - u.height);\n+        break;\n+      case CENTER:\n+        verticalAdjustment += ((viewR.height/2) - (u.height/2));\n+        break;\n+      }\n+    switch (horizontalAlignment)\n+      {\n+      case LEFT:\n+        break;\n+      case RIGHT:\n+        horizontalAdjustment += (viewR.width - u.width);\n+        break;\n+      case CENTER:\n+        horizontalAdjustment += ((viewR.width/2) - (u.width/2));\n+        break;\n+      }\n \n+    iconR.x += horizontalAdjustment;\n+    iconR.y += verticalAdjustment;\n \n+    textR.x += horizontalAdjustment;\n+    textR.y += verticalAdjustment;\n \n+    return text;\n+  }\n \n+  /** \n+   * Calls {@link java.awt.EventQueue.invokeLater} with the\n+   * specified {@link Runnable}. \n+   */\n+  public static void invokeLater(Runnable doRun)\n+  {\n+    java.awt.EventQueue.invokeLater(doRun);\n+  }\n \n+  /** \n+   * Calls {@link java.awt.EventQueue.invokeAndWait} with the\n+   * specified {@link Runnable}. \n+   */\n+  public static void invokeAndWait(Runnable doRun)\n+    throws InterruptedException,\n+    InvocationTargetException\n+  {\n+    java.awt.EventQueue.invokeAndWait(doRun);\n+  }\n \n+  /** \n+   * Calls {@link java.awt.EventQueue.isEventDispatchThread}.\n+   */\n+  public static boolean isEventDispatchThread()\n+  {\n+    return java.awt.EventQueue.isDispatchThread();\n+  }\n \n+}"}, {"sha": "65cc7b9f038cbaba99f58bf77885e32cc3358291", "filename": "libjava/javax/swing/plaf/basic/BasicGraphicsUtils.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbc848da46639c42ceaf193ea8dab1cdeea02a6f/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicGraphicsUtils.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbc848da46639c42ceaf193ea8dab1cdeea02a6f/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicGraphicsUtils.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicGraphicsUtils.java?ref=cbc848da46639c42ceaf193ea8dab1cdeea02a6f", "patch": "@@ -614,8 +614,8 @@ public static Dimension getPreferredButtonSize(AbstractButton b,\n       b.getToolkit().getFontMetrics(b.getFont()), // see comment above\n       b.getText(),\n       b.getIcon(),\n-      b.getVerticalAlignment(),\n-      b.getHorizontalAlignment(),\n+      SwingUtilities.TOP,    // important:\n+      SwingUtilities.LEFT,   // large vrect, stick to the top left\n       b.getVerticalTextPosition(),\n       b.getHorizontalTextPosition(),\n       viewRect, iconRect, textRect,"}]}