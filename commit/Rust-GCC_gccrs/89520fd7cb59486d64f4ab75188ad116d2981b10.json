{"sha": "89520fd7cb59486d64f4ab75188ad116d2981b10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk1MjBmZDdjYjU5NDg2ZDY0ZjRhYjc1MTg4YWQxMTZkMjk4MWIxMA==", "commit": {"author": {"name": "Jason Eckhardt", "email": "jle@rice.edu", "date": "2003-08-23T02:30:35Z"}, "committer": {"name": "Jason Eckhardt", "email": "jle@gcc.gnu.org", "date": "2003-08-23T02:30:35Z"}, "message": "i860-protos.h (output_delay_insn): Remove prototype.\n\n2003-08-22  Jason Eckhardt  <jle@rice.edu>\n\n\t* config/i860/i860-protos.h (output_delay_insn): Remove prototype.\n\t(output_delayed_branch): Remove prototype.\n\t(single_insn_src_p): Remove prototype.\n\t* config/i860/i860.c (single_insn_src_p): Remove function.\n\t(output_delayed_branch): Remove function.\n\t(output_delay_insn): Remove function.\n\t(va_start): Remove unconditional test and dead code, re-format.\n\tFix coding style and spelling problems in various comments.\n\t* config/i860/i860.md (UNSPECV_BLOCKAGE): Define constant...\n\t(blockage pattern): ...and use it here.\n\t(all define_peephole patterns related to delayed branches): Remove.\n\tFix coding style and spelling problems in various comments.\n\nFrom-SVN: r70724", "tree": {"sha": "c9da231b6f195cbb6d4d908b51e62037f68eb02b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9da231b6f195cbb6d4d908b51e62037f68eb02b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89520fd7cb59486d64f4ab75188ad116d2981b10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89520fd7cb59486d64f4ab75188ad116d2981b10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89520fd7cb59486d64f4ab75188ad116d2981b10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89520fd7cb59486d64f4ab75188ad116d2981b10/comments", "author": null, "committer": null, "parents": [{"sha": "8274e603cf58034e223ace062ca103f107cd8206", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8274e603cf58034e223ace062ca103f107cd8206", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8274e603cf58034e223ace062ca103f107cd8206"}], "stats": {"total": 626, "additions": 124, "deletions": 502}, "files": [{"sha": "ae9a8f85b512d2614248b32368fbdb5124b5d801", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89520fd7cb59486d64f4ab75188ad116d2981b10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89520fd7cb59486d64f4ab75188ad116d2981b10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89520fd7cb59486d64f4ab75188ad116d2981b10", "patch": "@@ -1,3 +1,18 @@\n+2003-08-22  Jason Eckhardt  <jle@rice.edu>\n+\n+\t* config/i860/i860-protos.h (output_delay_insn): Remove prototype.\n+\t(output_delayed_branch): Remove prototype.\n+\t(single_insn_src_p): Remove prototype.\n+\t* config/i860/i860.c (single_insn_src_p): Remove function.\n+\t(output_delayed_branch): Remove function.\n+\t(output_delay_insn): Remove function.\n+\t(va_start): Remove unconditional test and dead code, re-format.\n+\tFix coding style and spelling problems in various comments.\n+\t* config/i860/i860.md (UNSPECV_BLOCKAGE): Define constant...\n+\t(blockage pattern): ...and use it here.\n+\t(all define_peephole patterns related to delayed branches): Remove.\n+\tFix coding style and spelling problems in various comments.\n+\n 2003-08-22  Jason Eckhardt  <jle@rice.edu>\n \n \t* config/i860/i860.c: Replace all occurrences of 'GNU CC' with 'GCC'."}, {"sha": "e29a5cd489502b999b7a155963535dad6de2d17b", "filename": "gcc/config/i860/i860-protos.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89520fd7cb59486d64f4ab75188ad116d2981b10/gcc%2Fconfig%2Fi860%2Fi860-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89520fd7cb59486d64f4ab75188ad116d2981b10/gcc%2Fconfig%2Fi860%2Fi860-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860-protos.h?ref=89520fd7cb59486d64f4ab75188ad116d2981b10", "patch": "@@ -30,14 +30,9 @@ extern const char *output_store (rtx *);\n extern const char *output_move_double (rtx *);\n extern const char *output_fp_move_double (rtx *);\n extern const char *output_block_move (rtx *);\n-extern const char *output_delay_insn (rtx);\n-#if 0\n-extern const char *output_delayed_branch (const char *, rtx *, rtx);\n-#endif\n extern void output_load_address (rtx *);\n extern int safe_insn_src_p (rtx, enum machine_mode);\n extern int operand_clobbered_before_used_after (rtx, rtx);\n-extern int single_insn_src_p (rtx, enum machine_mode);\n extern int reg_or_0_operand (rtx, enum machine_mode);\n extern int arith_operand (rtx, enum machine_mode);\n extern int logic_operand (rtx, enum machine_mode);"}, {"sha": "c7e2811162cfb5f57f944a9b885c84fb2e130664", "filename": "gcc/config/i860/i860.c", "status": "modified", "additions": 85, "deletions": 377, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89520fd7cb59486d64f4ab75188ad116d2981b10/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89520fd7cb59486d64f4ab75188ad116d2981b10/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=89520fd7cb59486d64f4ab75188ad116d2981b10", "patch": "@@ -1,4 +1,4 @@\n-/* Subroutines for insn-output.c for Intel 860\n+/* Subroutines for insn-output.c for Intel i860\n    Copyright (C) 1989, 1991, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n    Free Software Foundation, Inc.\n    Derived from sparc.c.\n@@ -67,7 +67,7 @@ safe_insn_src_p (rtx op, enum machine_mode mode)\n {\n   /* Just experimenting.  */\n \n-  /* No floating point src is safe if it contains an arithmetic\n+  /* No floating point source is safe if it contains an arithmetic\n      operation, since that operation may trap.  */\n   switch (GET_CODE (op))\n     {\n@@ -122,7 +122,7 @@ safe_insn_src_p (rtx op, enum machine_mode mode)\n /* Return 1 if REG is clobbered in IN.\n    Return 2 if REG is used in IN. \n    Return 3 if REG is both used and clobbered in IN.\n-   Return 0 if neither.  */\n+   Return 0 if none of the above.  */\n \n static int\n reg_clobbered_p (rtx reg, rtx in)\n@@ -246,110 +246,14 @@ operand_clobbered_before_used_after (rtx op, rtx after)\n     }\n \n   /* In both of these cases, the first insn executed\n-     for this op will be a orh whatever%h,%?r0,%?r31,\n+     for this op will be a orh whatever%h,%r0,%r31,\n      which is tolerable.  */\n   if (GET_CODE (op) == MEM)\n     return (CONSTANT_ADDRESS_P (XEXP (op, 0)));\n \n   return 0;\n }\n \n-/* Return non-zero if this pattern, as a source to a \"SET\",\n-   is known to yield an instruction of unit size.  */\n-int\n-single_insn_src_p (rtx op, enum machine_mode mode)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case CONST_INT:\n-      /* This is not always a single insn src, technically,\n-\t but output_delayed_branch knows how to deal with it.  */\n-      return 1;\n-\n-    case SYMBOL_REF:\n-    case CONST:\n-      /* This is not a single insn src, technically,\n-\t but output_delayed_branch knows how to deal with it.  */\n-      return 1;\n-\n-    case REG:\n-      return 1;\n-\n-    case MEM:\n-      return 1;\n-\n-      /* We never need to negate or complement constants.  */\n-    case NEG:\n-      return (mode != DFmode);\n-    case NOT:\n-    case ZERO_EXTEND:\n-      return 1;\n-\n-    case PLUS:\n-    case MINUS:\n-      /* Detect cases that require multiple instructions.  */\n-      if (CONSTANT_P (XEXP (op, 1))\n-\t  && !(GET_CODE (XEXP (op, 1)) == CONST_INT\n-\t       && SMALL_INT (XEXP (op, 1))))\n-\treturn 0;\n-    case EQ:\n-    case NE:\n-    case LT:\n-    case GT:\n-    case LE:\n-    case GE:\n-    case LTU:\n-    case GTU:\n-    case LEU:\n-    case GEU:\n-      /* Not doing floating point, since they probably\n-\t take longer than the branch slot they might fill.  */\n-      return (mode != SFmode && mode != DFmode);\n-\n-    case AND:\n-      if (GET_CODE (XEXP (op, 1)) == NOT)\n-\t{\n-\t  rtx arg = XEXP (XEXP (op, 1), 0);\n-\t  if (CONSTANT_P (arg)\n-\t      && !(GET_CODE (arg) == CONST_INT\n-\t\t   && (SMALL_INT (arg)\n-\t\t       || (INTVAL (arg) & 0xffff) == 0)))\n-\t    return 0;\n-\t}\n-    case IOR:\n-    case XOR:\n-      /* Both small and round numbers take one instruction;\n-\t others take two.  */\n-      if (CONSTANT_P (XEXP (op, 1))\n-\t  && !(GET_CODE (XEXP (op, 1)) == CONST_INT\n-\t       && (SMALL_INT (XEXP (op, 1))\n-\t\t   || (INTVAL (XEXP (op, 1)) & 0xffff) == 0)))\n-\treturn 0;\n-\n-    case ASHIFT:\n-    case ASHIFTRT:\n-    case LSHIFTRT:\n-      return 1;\n-\n-    case SUBREG:\n-      if (SUBREG_BYTE (op) != 0)\n-\treturn 0;\n-      return single_insn_src_p (SUBREG_REG (op), mode);\n-\n-      /* Not doing floating point, since they probably\n-\t take longer than the branch slot they might fill.  */\n-    case FLOAT_EXTEND:\n-    case FLOAT_TRUNCATE:\n-    case FLOAT:\n-    case FIX:\n-    case UNSIGNED_FLOAT:\n-    case UNSIGNED_FIX:\n-      return 0;\n-\n-    default:\n-      return 0;\n-    }\n-}\n \f\n /* Return non-zero only if OP is a register of mode MODE,\n    or const0_rtx.  */\n@@ -581,7 +485,7 @@ output_move_double (rtx *operands)\n   if (optype0 == RNDOP || optype1 == RNDOP)\n     abort ();\n \n-  /* If an operand is an unoffsettable memory ref, find a register\n+  /* If an operand is an unoffsettable memory reference, find a register\n      we can increment temporarily to make it refer to the second word.  */\n \n   if (optype0 == MEMOP)\n@@ -630,7 +534,7 @@ output_move_double (rtx *operands)\n      such overlap can't happen in memory unless the user explicitly\n      sets it up, and that is an undefined circumstance.\"\n \n-     but it happens on the sparc when loading parameter registers,\n+     But it happens on the sparc when loading parameter registers,\n      so I am going to define that circumstance, and make it work\n      as expected.  */\n \n@@ -811,7 +715,7 @@ find_addr_reg (rtx addr)\n /* Return a template for a load instruction with mode MODE and\n    arguments from the string ARGS.\n \n-   This string is in static storage.   */\n+  This string is in static storage.  */\n \n static const char *\n load_opcode (enum machine_mode mode, const char *args, rtx reg)\n@@ -1289,198 +1193,13 @@ output_block_move (rtx *operands)\n   return \"\";\n }\n \f\n-#if 0\n-/* Output a delayed branch insn with the delay insn in its\n-   branch slot.  The delayed branch insn template is in TEMPLATE,\n-   with operands OPERANDS.  The insn in its delay slot is INSN.\n-\n-   As a special case, since we know that all memory transfers are via\n-   ld/st insns, if we see a (MEM (SYMBOL_REF ...)) we divide the memory\n-   reference around the branch as\n-\n-\torh ha%x,%?r0,%?r31\n-\tb ...\n-\tld/st l%x(%?r31),...\n-\n-   As another special case, we handle loading (SYMBOL_REF ...) and\n-   other large constants around branches as well:\n-\n-\torh h%x,%?r0,%0\n-\tb ...\n-\tor l%x,%0,%1\n-\n-   */\n-/* ??? Disabled because this re-recognition is incomplete and causes\n-   constrain_operands to segfault.  Anyone who cares should fix up\n-   the code to use the DBR pass.  */\n-\n-const char *\n-output_delayed_branch (const char *template, rtx *operands, rtx insn)\n-{\n-  rtx src = XVECEXP (PATTERN (insn), 0, 1);\n-  rtx dest = XVECEXP (PATTERN (insn), 0, 0);\n-\n-  /* See if we are doing some branch together with setting some register\n-     to some 32-bit value which does (or may) have some of the high-order\n-     16 bits set.  If so, we need to set the register in two stages.  One\n-     stage must be done before the branch, and the other one can be done\n-     in the delay slot.  */\n-\n-  if ( (GET_CODE (src) == CONST_INT\n-\t&& ((unsigned) INTVAL (src) & (unsigned) 0xffff0000) != (unsigned) 0)\n-      || (GET_CODE (src) == SYMBOL_REF)\n-      || (GET_CODE (src) == LABEL_REF)\n-      || (GET_CODE (src) == CONST))\n-    {\n-      rtx xoperands[2];\n-      xoperands[0] = dest;\n-      xoperands[1] = src;\n-\n-      CC_STATUS_PARTIAL_INIT;\n-      /* Output the `orh' insn.  */\n-      output_asm_insn (\"orh %H1,%?r0,%0\", xoperands);\n-\n-      /* Output the branch instruction next.  */\n-      output_asm_insn (template, operands);\n-\n-      /* Now output the `or' insn.  */\n-      output_asm_insn (\"or %L1,%0,%0\", xoperands);\n-    }\n-  else if ((GET_CODE (src) == MEM\n-\t    && CONSTANT_ADDRESS_P (XEXP (src, 0)))\n-\t   || (GET_CODE (dest) == MEM\n-\t       && CONSTANT_ADDRESS_P (XEXP (dest, 0))))\n-    {\n-      rtx xoperands[2];\n-      const char *split_template;\n-      xoperands[0] = dest;\n-      xoperands[1] = src;\n-\n-      /* Output the `orh' insn.  */\n-      if (GET_CODE (src) == MEM)\n-\t{\n-\t  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n-\t\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n-\t\t && cc_prev_status.mdep == XEXP (operands[1], 0)))\n-\t    {\n-\t      CC_STATUS_INIT;\n-\t      output_asm_insn (\"orh %h1,%?r0,%?r31\", xoperands);\n-\t    }\n-\t  split_template = load_opcode (GET_MODE (dest),\n-\t\t\t\t\t\"%L1(%?r31),%0\", dest);\n-\t}\n-      else\n-\t{\n-\t  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n-\t\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n-\t\t && cc_prev_status.mdep == XEXP (operands[0], 0)))\n-\t    {\n-\t      CC_STATUS_INIT;\n-\t      output_asm_insn (\"orh %h0,%?r0,%?r31\", xoperands);\n-\t    }\n-\t  split_template = store_opcode (GET_MODE (dest),\n-\t\t\t\t\t \"%r1,%L0(%?r31)\", src);\n-\t}\n-\n-      /* Output the branch instruction next.  */\n-      output_asm_insn (template, operands);\n-\n-      /* Now output the load or store.\n-\t No need to do a CC_STATUS_INIT, because we are branching anyway.  */\n-      output_asm_insn (split_template, xoperands);\n-    }\n-  else\n-    {\n-      int insn_code_number;\n-      rtx pat = gen_rtx_SET (VOIDmode, dest, src);\n-      rtx delay_insn = gen_rtx_INSN (VOIDmode, 0, 0, 0, pat, -1, 0, 0);\n-      int i;\n-\n-      /* Output the branch instruction first.  */\n-      output_asm_insn (template, operands);\n-\n-      /* Now recognize the insn which we put in its delay slot.\n-\t We must do this after outputting the branch insn,\n-\t since operands may just be a pointer to `recog_data.operand'.  */\n-      INSN_CODE (delay_insn) = insn_code_number\n-\t= recog (pat, delay_insn, NULL);\n-      if (insn_code_number == -1)\n-\tabort ();\n-\n-      for (i = 0; i < insn_data[insn_code_number].n_operands; i++)\n-\t{\n-\t  if (GET_CODE (recog_data.operand[i]) == SUBREG)\n-\t    alter_subreg (&recog_data.operand[i]);\n-\t}\n-\n-      insn_extract (delay_insn);\n-      if (! constrain_operands (1))\n-\tfatal_insn_not_found (delay_insn);\n-\n-      template = get_insn_template (insn_code_number, delay_insn);\n-      output_asm_insn (template, recog_data.operand);\n-    }\n-  CC_STATUS_INIT;\n-  return \"\";\n-}\n-\n-/* Output a newly constructed insn DELAY_INSN.  */\n-const char *\n-output_delay_insn (rtx delay_insn)\n-{\n-  const char *template;\n-  int insn_code_number;\n-  int i;\n-\n-  /* Now recognize the insn which we put in its delay slot.\n-     We must do this after outputting the branch insn,\n-     since operands may just be a pointer to `recog_data.operand'.  */\n-  insn_code_number = recog_memoized (delay_insn);\n-  if (insn_code_number == -1)\n-    abort ();\n-\n-  /* Extract the operands of this delay insn.  */\n-  INSN_CODE (delay_insn) = insn_code_number;\n-  insn_extract (delay_insn);\n-\n-  /* It is possible that this insn has not been properly scanned by final\n-     yet.  If this insn's operands don't appear in the peephole's\n-     actual operands, then they won't be fixed up by final, so we\n-     make sure they get fixed up here.  -- This is a kludge.  */\n-  for (i = 0; i < insn_data[insn_code_number].n_operands; i++)\n-    {\n-      if (GET_CODE (recog_data.operand[i]) == SUBREG)\n-\talter_subreg (&recog_data.operand[i]);\n-    }\n-\n-  if (! constrain_operands (1))\n-    abort ();\n-\n-  cc_prev_status = cc_status;\n-\n-  /* Update `cc_status' for this instruction.\n-     The instruction's output routine may change it further.\n-     If the output routine for a jump insn needs to depend\n-     on the cc status, it should look at cc_prev_status.  */\n-\n-  NOTICE_UPDATE_CC (PATTERN (delay_insn), delay_insn);\n-\n-  /* Now get the template for what this insn would\n-     have been, without the branch.  */\n-\n-  template = get_insn_template (insn_code_number, delay_insn);\n-  output_asm_insn (template, recog_data.operand);\n-  return \"\";\n-}\n-#endif\n-\f\n /* Special routine to convert an SFmode value represented as a\n    CONST_DOUBLE into its equivalent unsigned long bit pattern.\n    We convert the value from a double precision floating-point\n    value to single precision first, and thence to a bit-wise\n    equivalent unsigned long value.  This routine is used when\n    generating an immediate move of an SFmode value directly\n-   into a general register because the svr4 assembler doesn't\n+   into a general register because the SVR4 assembler doesn't\n    grok floating literals in instruction operand contexts.  */\n \n unsigned long\n@@ -1515,18 +1234,18 @@ sfmode_constant_to_ulong (rtx x)\n    part of each frame always includes at least 2 words (8 bytes)\n    to hold the saved frame pointer and the saved return address.\n \n-   The svr4 ABI for the i860 now requires that the values of the\n+   The SVR4 ABI for the i860 now requires that the values of the\n    stack pointer and frame pointer registers be kept aligned to\n    16-byte boundaries at all times.  We obey that restriction here.\n \n-   The svr4 ABI for the i860 is entirely vague when it comes to specifying\n+   The SVR4 ABI for the i860 is entirely vague when it comes to specifying\n    exactly where the \"preserved\" registers should be saved.  The native\n-   svr4 C compiler I now have doesn't help to clarify the requirements\n+   SVR4 C compiler I now have doesn't help to clarify the requirements\n    very much because it is plainly out-of-date and non-ABI-compliant\n    (in at least one important way, i.e. how it generates function\n    epilogues).\n \n-   The native svr4 C compiler saves the \"preserved\" registers (i.e.\n+   The native SVR4 C compiler saves the \"preserved\" registers (i.e.\n    r4-r15 and f2-f7) in the lower part of a frame (i.e. at negative\n    offsets from the frame pointer).\n \n@@ -1563,21 +1282,21 @@ sfmode_constant_to_ulong (rtx x)\n    frame, so that we can decide at the very last minute how much (or how\n    little) space we must allocate for this purpose.\n \n-   To satisfy the needs of the svr4 ABI \"tdesc\" scheme, preserved\n+   To satisfy the needs of the SVR4 ABI \"tdesc\" scheme, preserved\n    registers must always be saved so that the saved values of registers\n    with higher numbers are at higher addresses.  We obey that restriction\n    here.\n \n    There are two somewhat different ways that you can generate prologues\n    here... i.e. pedantically ABI-compliant, and the \"other\" way.  The\n    \"other\" way is more consistent with what is currently generated by the\n-   \"native\" svr4 C compiler for the i860.  That's important if you want\n-   to use the current (as of 8/91) incarnation of svr4 SDB for the i860.\n+   \"native\" SVR4 C compiler for the i860.  That's important if you want\n+   to use the current (as of 8/91) incarnation of SVR4 SDB for the i860.\n    The SVR4 SDB for the i860 insists on having function prologues be\n    non-ABI-compliant!\n \n    To get fully ABI-compliant prologues, define I860_STRICT_ABI_PROLOGUES\n-   in the i860svr4.h file.  (By default this is *not* defined).\n+   in the i860/sysv4.h file.  (By default this is *not* defined).\n \n    The differences between the ABI-compliant and non-ABI-compliant prologues\n    are that (a) the ABI version seems to require the use of *signed*\n@@ -1589,8 +1308,7 @@ sfmode_constant_to_ulong (rtx x)\n    thing that is supposed to happen in the prologue is getting the frame\n    pointer set to its new value (but only after everything else has\n    already been properly setup).  We do that here, but only if the symbol\n-   I860_STRICT_ABI_PROLOGUES is defined.\n-*/\n+   I860_STRICT_ABI_PROLOGUES is defined.  */\n \n #ifndef STACK_ALIGNMENT\n #define STACK_ALIGNMENT\t16\n@@ -1623,17 +1341,17 @@ i860_output_function_prologue (FILE *asm_file, HOST_WIDE_INT local_bytes)\n         preserved_reg_bytes += 4;\n     }\n \n-  /* Round-up the frame_lower_bytes so that it's a multiple of 16. */\n+  /* Round-up the frame_lower_bytes so that it's a multiple of 16.  */\n \n   frame_lower_bytes = (local_bytes + STACK_ALIGNMENT - 1) & -STACK_ALIGNMENT;\n \n   /* The upper part of each frame will contain the saved fp,\n      the saved r1, and stack slots for all of the other \"preserved\"\n-     registers that we find we will need to save & restore. */\n+     registers that we find we will need to save & restore.  */\n \n   frame_upper_bytes = must_preserve_bytes + preserved_reg_bytes;\n \n-  /* Round-up the frame_upper_bytes so that it's a multiple of 16. */\n+  /* Round-up the frame_upper_bytes so that it's a multiple of 16.  */\n \n   frame_upper_bytes\n     = (frame_upper_bytes + STACK_ALIGNMENT - 1) & -STACK_ALIGNMENT;\n@@ -1650,8 +1368,8 @@ i860_output_function_prologue (FILE *asm_file, HOST_WIDE_INT local_bytes)\n \n   if (total_fsize > 0x7fff)\n     {\n-      /* Adjust the stack pointer.  The ABI sez to do this using `adds',\n-\t but the native C compiler on svr4 uses `addu'.  */\n+      /* Adjust the stack pointer.  The ABI specifies using `adds' for\n+\t this, but the native C compiler on SVR4 uses `addu'.  */\n \n       fprintf (asm_file, \"\\taddu -\" HOST_WIDE_INT_PRINT_DEC \",%ssp,%ssp\\n\",\n \tframe_upper_bytes, i860_reg_prefix, i860_reg_prefix);\n@@ -1661,9 +1379,9 @@ i860_output_function_prologue (FILE *asm_file, HOST_WIDE_INT local_bytes)\n       fprintf (asm_file, \"\\tst.l %sfp,0(%ssp)\\n\",\n \ti860_reg_prefix, i860_reg_prefix);\n \n-      /* Setup the new frame pointer.  The ABI sez to do this after\n-\t preserving registers (using adds), but that's not what the\n-\t native C compiler on svr4 does.  */\n+      /* Setup the new frame pointer.  The ABI specifies that this is to\n+\t be done after preserving registers (using `adds'), but that's not\n+\t what the native C compiler on SVR4 does.  */\n \n       fprintf (asm_file, \"\\taddu 0,%ssp,%sfp\\n\",\n \ti860_reg_prefix, i860_reg_prefix);\n@@ -1676,14 +1394,15 @@ i860_output_function_prologue (FILE *asm_file, HOST_WIDE_INT local_bytes)\n \tframe_lower_bytes & 0xffff, i860_reg_prefix, i860_reg_prefix);\n \n       /* Now re-adjust the stack pointer using the value in r31.\n-\t The ABI sez to do this with `subs' but SDB may prefer `subu'.  */\n+\t The ABI specifies that this is done with `subs' but SDB may\n+\t prefer `subu'.  */\n \n       fprintf (asm_file, \"\\tsubu %ssp,%sr31,%ssp\\n\",\n \ti860_reg_prefix, i860_reg_prefix, i860_reg_prefix);\n \n-      /* Preserve registers.  The ABI sez to do this before setting\n-\t up the new frame pointer, but that's not what the native\n-\t C compiler on svr4 does.  */\n+      /* Preserve registers.  The ABI specifies that this is to be done\n+\t before setting up the new frame pointer, but that's not what the\n+\t native C compiler on SVR4 does.  */\n \n       for (i = 1; i < 32; i++)\n         if (regs_ever_live[i] && ! call_used_regs[i])\n@@ -1707,8 +1426,8 @@ i860_output_function_prologue (FILE *asm_file, HOST_WIDE_INT local_bytes)\n     }\n   else\n     {\n-      /* Adjust the stack pointer.  The ABI sez to do this using `adds',\n-\t but the native C compiler on svr4 uses `addu'.  */\n+      /* Adjust the stack pointer.  The ABI specifies using `adds' for this,\n+\t but the native C compiler on SVR4 uses `addu'.  */\n \n       fprintf (asm_file, \"\\taddu -\" HOST_WIDE_INT_PRINT_DEC \",%ssp,%ssp\\n\",\n \ttotal_fsize, i860_reg_prefix, i860_reg_prefix);\n@@ -1718,17 +1437,17 @@ i860_output_function_prologue (FILE *asm_file, HOST_WIDE_INT local_bytes)\n       fprintf (asm_file, \"\\tst.l %sfp,\" HOST_WIDE_INT_PRINT_DEC \"(%ssp)\\n\",\n \ti860_reg_prefix, frame_lower_bytes, i860_reg_prefix);\n \n-      /* Setup the new frame pointer.  The ABI sez to do this after\n-\t preserving registers and after saving the return address,\n-\t(and its saz to do this using adds), but that's not what the\n-\t native C compiler on svr4 does.  */\n+      /* Setup the new frame pointer.  The ABI specifies that this is to be\n+\t done after preserving registers and after saving the return address,\n+\t (and to do it using `adds'), but that's not what the native C\n+\t compiler on SVR4 does.  */\n \n       fprintf (asm_file, \"\\taddu \" HOST_WIDE_INT_PRINT_DEC \",%ssp,%sfp\\n\",\n \tframe_lower_bytes, i860_reg_prefix, i860_reg_prefix);\n \n-      /* Preserve registers.  The ABI sez to do this before setting\n-\t up the new frame pointer, but that's not what the native\n-\t compiler on svr4 does.  */\n+      /* Preserve registers.  The ABI specifies that this is to be done\n+\t before setting up the new frame pointer, but that's not what the\n+\t native compiler on SVR4 does.  */\n \n       for (i = 1; i < 32; i++)\n         if (regs_ever_live[i] && ! call_used_regs[i])\n@@ -1744,9 +1463,9 @@ i860_output_function_prologue (FILE *asm_file, HOST_WIDE_INT local_bytes)\n \t    must_preserve_bytes + (4 * preserved_so_far++),\n \t    i860_reg_prefix);\n \n-      /* Save the return address.  The ABI sez to do this earlier,\n-\t and also via an offset from %sp, but the native C compiler\n-\t on svr4 does it later (i.e. now) and uses an offset from\n+      /* Save the return address.  The ABI specifies that this is to be\n+\t done earlier, and also via an offset from %sp, but the native C\n+\t compiler on SVR4 does it later (i.e. now) and uses an offset from\n \t %fp.  */\n \n       if (must_preserve_r1)\n@@ -1896,12 +1615,11 @@ i860_output_function_prologue (FILE *asm_file, HOST_WIDE_INT local_bytes)\n    the frame pointer register is never less than the value in the stack\n    pointer register.  It's not clear why this relationship needs to be\n    maintained at all times, but maintaining it only costs one extra\n-   instruction, so what the hell.\n-*/\n+   instruction, so what the hell.  */\n \n /* This corresponds to a version 4 TDESC structure. Lower numbered\n    versions successively omit the last word of the structure. We\n-   don't try to handle version 5 here. */\n+   don't try to handle version 5 here.  */\n \n typedef struct TDESC_flags {\n \tint version:4;\n@@ -1940,7 +1658,7 @@ i860_output_function_epilogue (FILE *asm_file, HOST_WIDE_INT local_bytes)\n   flags->reg_packing = 1;\n   flags->iregs = 8;\t/* old fp always gets saved */\n \n-  /* Round-up the frame_lower_bytes so that it's a multiple of 16. */\n+  /* Round-up the frame_lower_bytes so that it's a multiple of 16.  */\n \n   frame_lower_bytes = (local_bytes + STACK_ALIGNMENT - 1) & -STACK_ALIGNMENT;\n \n@@ -1955,11 +1673,11 @@ i860_output_function_epilogue (FILE *asm_file, HOST_WIDE_INT local_bytes)\n \n   /* The upper part of each frame will contain only saved fp,\n      the saved r1, and stack slots for all of the other \"preserved\"\n-     registers that we find we will need to save & restore. */\n+     registers that we find we will need to save & restore.  */\n \n   frame_upper_bytes = must_preserve_bytes + preserved_reg_bytes;\n \n-  /* Round-up frame_upper_bytes so that t is a multiple of 16. */\n+  /* Round-up frame_upper_bytes so that t is a multiple of 16.  */\n \n   frame_upper_bytes\n     = (frame_upper_bytes + STACK_ALIGNMENT - 1) & -STACK_ALIGNMENT;\n@@ -2013,12 +1731,12 @@ i860_output_function_epilogue (FILE *asm_file, HOST_WIDE_INT local_bytes)\n   fprintf (asm_file, \"\\tbri %sr1\\n\\tmov %sr31,%ssp\\n\",\n     i860_reg_prefix, i860_reg_prefix, i860_reg_prefix);\n \n-#ifdef\tOUTPUT_TDESC\t/* Output an ABI-compliant TDESC entry */\n+#ifdef\tOUTPUT_TDESC\t/* Output an ABI-compliant TDESC entry.  */\n   if (! frame_lower_bytes) {\n     flags->version--;\n     if (! frame_upper_bytes) {\n       flags->version--;\n-      if (restored_so_far == int_restored)\t/* No FP saves */\n+      if (restored_so_far == int_restored)\t/* No FP saves.  */\n \tflags->version--;\n     }\n   }\n@@ -2110,64 +1828,54 @@ void\n i860_va_start (tree valist, rtx nextarg)\n {\n   tree saveregs, t;\n+  tree field_ireg_used, field_freg_used, field_reg_base, field_mem_ptr;\n+  tree ireg_used, freg_used, reg_base, mem_ptr;\n \n   saveregs = make_tree (build_pointer_type (va_list_type_node),\n \t\t\texpand_builtin_saveregs ());\n   saveregs = build1 (INDIRECT_REF, va_list_type_node, saveregs);\n \n-  if (1 /* stdarg_p */)\n-    {\n-      tree field_ireg_used, field_freg_used, field_reg_base, field_mem_ptr;\n-      tree ireg_used, freg_used, reg_base, mem_ptr;\n-\n #ifdef I860_SVR4_VA_LIST\n-      field_ireg_used = TYPE_FIELDS (va_list_type_node);\n-      field_freg_used = TREE_CHAIN (field_ireg_used);\n-      field_reg_base = TREE_CHAIN (field_freg_used);\n-      field_mem_ptr = TREE_CHAIN (field_reg_base);\n+  field_ireg_used = TYPE_FIELDS (va_list_type_node);\n+  field_freg_used = TREE_CHAIN (field_ireg_used);\n+  field_reg_base = TREE_CHAIN (field_freg_used);\n+  field_mem_ptr = TREE_CHAIN (field_reg_base);\n #else\n-      field_reg_base = TYPE_FIELDS (va_list_type_node);\n-      field_mem_ptr = TREE_CHAIN (field_reg_base);\n-      field_ireg_used = TREE_CHAIN (field_mem_ptr);\n-      field_freg_used = TREE_CHAIN (field_ireg_used);\n+  field_reg_base = TYPE_FIELDS (va_list_type_node);\n+  field_mem_ptr = TREE_CHAIN (field_reg_base);\n+  field_ireg_used = TREE_CHAIN (field_mem_ptr);\n+  field_freg_used = TREE_CHAIN (field_ireg_used);\n #endif\n \n-      ireg_used = build (COMPONENT_REF, TREE_TYPE (field_ireg_used),\n-\t\t\t valist, field_ireg_used);\n-      freg_used = build (COMPONENT_REF, TREE_TYPE (field_freg_used),\n-\t\t\t valist, field_freg_used);\n-      reg_base = build (COMPONENT_REF, TREE_TYPE (field_reg_base),\n-\t\t\tvalist, field_reg_base);\n-      mem_ptr = build (COMPONENT_REF, TREE_TYPE (field_mem_ptr),\n-\t\t       valist, field_mem_ptr);\n-\n-      t = build_int_2 (current_function_args_info.ints / UNITS_PER_WORD, 0);\n-      t = build (MODIFY_EXPR, TREE_TYPE (ireg_used), ireg_used, t);\n-      TREE_SIDE_EFFECTS (t) = 1;\n-      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  ireg_used = build (COMPONENT_REF, TREE_TYPE (field_ireg_used),\n+\t\t     valist, field_ireg_used);\n+  freg_used = build (COMPONENT_REF, TREE_TYPE (field_freg_used),\n+\t\t     valist, field_freg_used);\n+  reg_base = build (COMPONENT_REF, TREE_TYPE (field_reg_base),\n+\t\t    valist, field_reg_base);\n+  mem_ptr = build (COMPONENT_REF, TREE_TYPE (field_mem_ptr),\n+\t\t   valist, field_mem_ptr);\n+\n+  t = build_int_2 (current_function_args_info.ints / UNITS_PER_WORD, 0);\n+  t = build (MODIFY_EXPR, TREE_TYPE (ireg_used), ireg_used, t);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n       \n-      t = build_int_2 (ROUNDUP ((current_function_args_info.floats / UNITS_PER_WORD), 8), 0);\n-      t = build (MODIFY_EXPR, TREE_TYPE (freg_used), freg_used, t);\n-      TREE_SIDE_EFFECTS (t) = 1;\n-      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  t = build_int_2 (ROUNDUP ((current_function_args_info.floats / UNITS_PER_WORD), 8), 0);\n+  t = build (MODIFY_EXPR, TREE_TYPE (freg_used), freg_used, t);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n       \n-      t = build (COMPONENT_REF, TREE_TYPE (field_reg_base),\n-\t\t saveregs, field_reg_base);\n-      t = build (MODIFY_EXPR, TREE_TYPE (reg_base), reg_base, t);\n-      TREE_SIDE_EFFECTS (t) = 1;\n-      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  t = build (COMPONENT_REF, TREE_TYPE (field_reg_base),\n+\t     saveregs, field_reg_base);\n+  t = build (MODIFY_EXPR, TREE_TYPE (reg_base), reg_base, t);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-      t = make_tree (ptr_type_node, nextarg);\n-      t = build (MODIFY_EXPR, TREE_TYPE (mem_ptr), mem_ptr, t);\n-      TREE_SIDE_EFFECTS (t) = 1;\n-      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-    }\n-  else\n-    {\n-      t = build (MODIFY_EXPR, va_list_type_node, valist, saveregs);\n-      TREE_SIDE_EFFECTS (t) = 1;\n-      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-    }\n+  t = make_tree (ptr_type_node, nextarg);\n+  t = build (MODIFY_EXPR, TREE_TYPE (mem_ptr), mem_ptr, t);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n }\n \n #define NUM_PARM_FREGS\t8"}, {"sha": "60c87e4326200f6de28e40573c455f714cb36187", "filename": "gcc/config/i860/i860.md", "status": "modified", "additions": 24, "deletions": 120, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89520fd7cb59486d64f4ab75188ad116d2981b10/gcc%2Fconfig%2Fi860%2Fi860.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89520fd7cb59486d64f4ab75188ad116d2981b10/gcc%2Fconfig%2Fi860%2Fi860.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.md?ref=89520fd7cb59486d64f4ab75188ad116d2981b10", "patch": "@@ -1,4 +1,4 @@\n-;;- Machine description for Intel 860 chip for GNU C compiler\n+;;  GCC Machine description for the Intel i860 microprocessor\n ;;  Copyright (C) 1989, 1990, 1997, 1998, 1999, 2000, 2003\n ;;  Free Software Foundation, Inc.\n \n@@ -25,6 +25,15 @@\n ;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code\n ;;- updates for most instructions.\n \n+;;\n+;; UNSPEC_VOLATILE usage\n+;;\n+\n+(define_constants\n+  [; Blockage\n+   (UNSPECV_BLOCKAGE\t\t0)\n+  ])\n+\n ;;- Operand classes for the register allocator:\n \f\n /* Bit-test instructions.  */\n@@ -307,8 +316,7 @@\n   return \\\"pfgt.ss %r0,%r1,%?f0\\\";\n }\")\n \n-;; NOTE:  The pfle opcode doesn't do what you think it does.  It is\n-;; bass-ackwards.  It *clears* the CC flag if the first operand is\n+;; NOTE:  The pfle opcode *clears* the CC flag if the first operand is\n ;; less than or equal to the second.  Thus, we have to set CC_NEGATED\n ;; for the following two patterns.\n \n@@ -385,8 +393,7 @@\n   return \\\"pfgt.dd %r0,%r1,%?f0\\\";\n }\")\n \n-;; NOTE:  The pfle opcode doesn't do what you think it does.  It is\n-;; bass-ackwards.  It *clears* the CC flag if the first operand is\n+;; NOTE:  The pfle opcode *clears* the CC flag if the first operand is\n ;; less than or equal to the second.  Thus, we have to set CC_NEGATED\n ;; for the following two patterns.\n \n@@ -878,7 +885,7 @@\n ;; Move instructions\n \n ;; Note that source operands for `mov' pseudo-instructions are no longer\n-;; allowed (by the svr4 assembler) to be \"big\" things, i.e. constants that\n+;; allowed (by the SVR4 assembler) to be \"big\" things, i.e. constants that\n ;; won't fit in 16-bits.  (This includes any sort of a relocatable address\n ;; also.)  Thus, we must use an explicit orh/or pair of instructions if\n ;; the source operand is something \"big\".\n@@ -1086,7 +1093,7 @@\n       && CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n     return output_load (operands);\n \n-  /* ??? How can we have a DFmode arg here with DImode above? */\n+  /* ??? How can we have a DFmode arg here with DImode above?  */\n   if (FP_REG_P (operands[0]) && operands[1] == CONST0_RTX (DFmode))\n     return \\\"fmov.dd %?f0,%0\\\";\n \n@@ -1520,9 +1527,9 @@\n   return \\\"and 128,%0,%?r0\\\";\n }\")\n \n-;; next two patterns are good for bitfields coming from memory\n+;; The next two patterns are good for bitfields coming from memory\n ;; (via pseudo-register) or from a register, though this optimization\n-;; is only good for values contained wholly within the bottom 13 bits\n+;; is only good for values contained wholly within the bottom 13 bits.\n (define_insn \"\"\n   [(set (cc0)\n \t(eq \n@@ -1573,7 +1580,7 @@\n ;; Note that among the fix-to-float insns\n ;; the ones that start with SImode come first.\n ;; That is so that an operand that is a CONST_INT\n-;; (and therefore lacks a specific machine mode).\n+;; (and therefore lacks a specific machine mode)\n ;; will be recognized as SImode (which is always valid)\n ;; rather than as QImode or HImode.\n \n@@ -1999,8 +2006,7 @@ fmul.ss %1,%0,%4\\;fmul.ss %3,%4,%0\\\";\n \f\n ;; Shift instructions\n \n-;; Optimized special case of shifting.\n-;; Must precede the general case.\n+;; Optimized special case of shifting, which must precede the general case.\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -2020,7 +2026,7 @@ fmul.ss %1,%0,%4\\;fmul.ss %3,%4,%0\\\";\n }\")\n \n \f\n-;;- arithmetic shift instructions\n+;;- Arithmetic shift instructions.\n (define_insn \"ashlsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -2071,7 +2077,7 @@ fmul.ss %1,%0,%4\\;fmul.ss %3,%4,%0\\\";\n   return \\\"shr %2,%1,%0\\\";\n }\")\n \f\n-;; Unconditional and other jump instructions\n+;; Unconditional and other jump instructions.\n \n (define_insn \"jump\"\n   [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n@@ -2081,41 +2087,12 @@ fmul.ss %1,%0,%4\\;fmul.ss %3,%4,%0\\\";\n   return \\\"br %l0\\;nop\\\";\n }\")\n \n-;; Here are two simple peepholes which fill the delay slot of\n-;; an unconditional branch.\n-;\n-;; ??? All disabled, because output_delayed_branch is a crock\n-;; that will reliably segfault.  This should be using the dbr\n-;; pass in any case.  Anyone who cares is welcome to fix it.\n-;\n-;(define_peephole\n-;  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n-;\t(match_operand:SI 1 \"single_insn_src_p\" \"gfG\"))\n-;   (set (pc) (label_ref (match_operand 2 \"\" \"\")))]\n-;  \"\"\n-;  \"* return output_delayed_branch (\\\"br %l2\\\", operands, insn);\")\n-;\n-;(define_peephole\n-;  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n-;\t(match_operand:SI 1 \"reg_or_0_operand\" \"rfJ\"))\n-;   (set (pc) (label_ref (match_operand 2 \"\" \"\")))]\n-;  \"\"\n-;  \"* return output_delayed_branch (\\\"br %l2\\\", operands, insn);\")\n-\n (define_insn \"tablejump\"\n   [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"\"\n   \"bri %0\\;nop\")\n \n-;(define_peephole\n-;  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n-;\t(match_operand:SI 1 \"reg_or_0_operand\" \"rfJ\"))\n-;   (set (pc) (match_operand:SI 2 \"register_operand\" \"r\"))\n-;   (use (label_ref (match_operand 3 \"\" \"\")))]\n-;  \"\"\n-;  \"* return output_delayed_branch (\\\"bri %2\\\", operands, insn);\")\n-\n ;;- jump to subroutine\n (define_expand \"call\"\n   [(call (match_operand:SI 0 \"memory_operand\" \"m\")\n@@ -2137,7 +2114,7 @@ fmul.ss %1,%0,%4\\;fmul.ss %3,%4,%0\\\";\n     }\n }\")\n \n-;;- jump to subroutine\n+;;- Jump to subroutine.\n (define_insn \"\"\n   [(call (match_operand:SI 0 \"call_insn_operand\" \"m\")\n \t (match_operand 1 \"\" \"i\"))]\n@@ -2153,38 +2130,6 @@ fmul.ss %1,%0,%4\\;fmul.ss %3,%4,%0\\\";\n   return \\\"call %0\\;nop\\\";\n }\")\n \n-;(define_peephole\n-;  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n-;\t(match_operand:SI 1 \"single_insn_src_p\" \"gfG\"))\n-;   (call (match_operand:SI 2 \"memory_operand\" \"m\")\n-;\t (match_operand 3 \"\" \"i\"))]\n-;  ;;- Don't use operand 1 for most machines.\n-;  \"! reg_mentioned_p (operands[0], operands[2])\"\n-;  \"*\n-;{\n-;  /* strip the MEM.  */\n-;  operands[2] = XEXP (operands[2], 0);\n-;  if (GET_CODE (operands[2]) == REG)\n-;    return output_delayed_branch (\\\"calli %2\\\", operands, insn);\n-;  return output_delayed_branch (\\\"call %2\\\", operands, insn);\n-;}\")\n-\n-;(define_peephole\n-;  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n-;\t(match_operand:SI 1 \"reg_or_0_operand\" \"rfJ\"))\n-;   (call (match_operand:SI 2 \"call_insn_operand\" \"m\")\n-;\t (match_operand 3 \"\" \"i\"))]\n-;  ;;- Don't use operand 1 for most machines.\n-;  \"\"\n-;  \"*\n-;{\n-;  /* strip the MEM.  */\n-;  operands[2] = XEXP (operands[2], 0);\n-;  if (GET_CODE (operands[2]) == REG)\n-;    return output_delayed_branch (\\\"calli %2\\\", operands, insn);\n-;  return output_delayed_branch (\\\"call %2\\\", operands, insn);\n-;}\")\n-\n (define_expand \"call_value\"\n   [(set (match_operand 0 \"register_operand\" \"=rf\")\n \t(call (match_operand:SI 1 \"memory_operand\" \"m\")\n@@ -2214,48 +2159,14 @@ fmul.ss %1,%0,%4\\;fmul.ss %3,%4,%0\\\";\n   \"\"\n   \"*\n {\n-  /* strip the MEM.  */\n+  /* Strip the MEM.  */\n   operands[1] = XEXP (operands[1], 0);\n   CC_STATUS_INIT;\n   if (GET_CODE (operands[1]) == REG)\n     return \\\"calli %1\\;nop\\\";\n   return \\\"call %1\\;nop\\\";\n }\")\n \n-;(define_peephole\n-;  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n-;\t(match_operand:SI 1 \"single_insn_src_p\" \"gfG\"))\n-;   (set (match_operand 2 \"\" \"=rf\")\n-;\t(call (match_operand:SI 3 \"call_insn_operand\" \"m\")\n-;\t      (match_operand 4 \"\" \"i\")))]\n-;  ;;- Don't use operand 4 for most machines.\n-;  \"! reg_mentioned_p (operands[0], operands[3])\"\n-;  \"*\n-;{\n-;  /* strip the MEM.  */\n-;  operands[3] = XEXP (operands[3], 0);\n-;  if (GET_CODE (operands[3]) == REG)\n-;    return output_delayed_branch (\\\"calli %3\\\", operands, insn);\n-;  return output_delayed_branch (\\\"call %3\\\", operands, insn);\n-;}\")\n-\n-;(define_peephole\n-;  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n-;\t(match_operand:SI 1 \"reg_or_0_operand\" \"rJf\"))\n-;   (set (match_operand 2 \"\" \"=rf\")\n-;\t(call (match_operand:SI 3 \"call_insn_operand\" \"m\")\n-;\t      (match_operand 4 \"\" \"i\")))]\n-;  ;;- Don't use operand 4 for most machines.\n-;  \"\"\n-;  \"*\n-;{\n-;  /* strip the MEM.  */\n-;  operands[3] = XEXP (operands[3], 0);\n-;  if (GET_CODE (operands[3]) == REG)\n-;    return output_delayed_branch (\\\"calli %3\\\", operands, insn);\n-;  return output_delayed_branch (\\\"call %3\\\", operands, insn);\n-;}\")\n-\n ;; Call subroutine returning any type.\n \n (define_expand \"untyped_call\"\n@@ -2289,7 +2200,7 @@ fmul.ss %1,%0,%4\\;fmul.ss %3,%4,%0\\\";\n ;; all of memory.  This blocks insns from being moved across this point.\n \n (define_insn \"blockage\"\n-  [(unspec_volatile [(const_int 0)] 0)]\n+  [(unspec_volatile [(const_int 0)] UNSPECV_BLOCKAGE)]\n   \"\"\n   \"\")\n \f\n@@ -2317,11 +2228,4 @@ fmul.ss %1,%0,%4\\;fmul.ss %3,%4,%0\\\";\n   CC_STATUS_INIT;\n   return \\\"orh %H2,%?r0,%?r31\\;or %L2,%?r31,%?r31\\;ld.l %?r31(%1),%0\\\";\n }\")\n-  \n-;(define_peephole\n-;  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n-;\t(match_operand:SI 1 \"single_insn_src_p\" \"gfG\"))\n-;   (set (pc) (match_operand:SI 2 \"register_operand\" \"r\"))\n-;   (use (label_ref (match_operand 3 \"\" \"\")))]\n-;  \"REGNO (operands[0]) != REGNO (operands[2])\"\n-;  \"* return output_delayed_branch (\\\"bri %2\\\", operands, insn);\")\n+"}]}