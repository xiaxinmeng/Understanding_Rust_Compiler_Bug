{"sha": "39aa9b2369eff7f2be0712ea7f1ee12f8697ce36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlhYTliMjM2OWVmZjdmMmJlMDcxMmVhN2YxZWUxMmY4Njk3Y2UzNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2018-02-08T14:51:51Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-02-08T14:51:51Z"}, "message": "re PR ipa/81360 (ice in estimate_edge_growth, at ipa-inline.h:86)\n\n\tPR ipa/81360\n\t* cgraph.h (symtab_node::output_to_lto_symbol_table_p): Declare\n\t* symtab.c: Include builtins.h\n\t(symtab_node::output_to_lto_symbol_table_p): Move here\n\tfrom lto-streamer-out.c:output_symbol_p.\n\t* lto-streamer-out.c (write_symbol): Turn early exit to assert.\n\t(output_symbol_p): Move all logic to symtab.c\n\t(produce_symtab): Update.\n\n\t* lto.c (unify_scc): Register prevailing trees, not trees to be freed.\n\t(read_cgraph_and_symbols): Use\n\tsymtab_node::output_to_lto_symbol_table_p.\n\nFrom-SVN: r257490", "tree": {"sha": "09190fc346352b0770f0eab06a1b4031cf5bb35d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09190fc346352b0770f0eab06a1b4031cf5bb35d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39aa9b2369eff7f2be0712ea7f1ee12f8697ce36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39aa9b2369eff7f2be0712ea7f1ee12f8697ce36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39aa9b2369eff7f2be0712ea7f1ee12f8697ce36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39aa9b2369eff7f2be0712ea7f1ee12f8697ce36/comments", "author": null, "committer": null, "parents": [{"sha": "84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84b4c7b593cd4ebb475a08aa4b816c722f716ce6"}], "stats": {"total": 158, "additions": 105, "deletions": 53}, "files": [{"sha": "049cdd154eb35ab17644416f74963a92277d4cdc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39aa9b2369eff7f2be0712ea7f1ee12f8697ce36/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39aa9b2369eff7f2be0712ea7f1ee12f8697ce36/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39aa9b2369eff7f2be0712ea7f1ee12f8697ce36", "patch": "@@ -1,3 +1,14 @@\n+2018-02-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/81360\n+\t* cgraph.h (symtab_node::output_to_lto_symbol_table_p): Declare\n+\t* symtab.c: Include builtins.h\n+\t(symtab_node::output_to_lto_symbol_table_p): Move here\n+\tfrom lto-streamer-out.c:output_symbol_p.\n+\t* lto-streamer-out.c (write_symbol): Turn early exit to assert.\n+\t(output_symbol_p): Move all logic to symtab.c\n+\t(produce_symtab): Update.\n+\n 2018-02-08  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* config/s390/s390-opts.h (enum indirect_branch): Define."}, {"sha": "d1ef840849755eb2049c648336c002d532d138ba", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39aa9b2369eff7f2be0712ea7f1ee12f8697ce36/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39aa9b2369eff7f2be0712ea7f1ee12f8697ce36/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=39aa9b2369eff7f2be0712ea7f1ee12f8697ce36", "patch": "@@ -328,6 +328,9 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n      or abstract function kept for debug info purposes only.  */\n   bool real_symbol_p (void);\n \n+  /* Return true when the symbol needs to be output to the LTO symbol table.  */\n+  bool output_to_lto_symbol_table_p (void);\n+\n   /* Determine if symbol declaration is needed.  That is, visible to something\n      either outside this translation unit, something magic in the system\n      configury. This function is used just during symbol creation.  */"}, {"sha": "1d2ab9757f1a3352f03f03028e59358a4f210683", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 6, "deletions": 48, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39aa9b2369eff7f2be0712ea7f1ee12f8697ce36/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39aa9b2369eff7f2be0712ea7f1ee12f8697ce36/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=39aa9b2369eff7f2be0712ea7f1ee12f8697ce36", "patch": "@@ -2598,13 +2598,10 @@ write_symbol (struct streamer_tree_cache_d *cache,\n   const char *comdat;\n   unsigned char c;\n \n-  /* None of the following kinds of symbols are needed in the\n-     symbol table.  */\n-  if (!TREE_PUBLIC (t)\n-      || is_builtin_fn (t)\n-      || DECL_ABSTRACT_P (t)\n-      || (VAR_P (t) && DECL_HARD_REGISTER (t)))\n-    return;\n+  gcc_checking_assert (TREE_PUBLIC (t)\n+\t\t       && !is_builtin_fn (t)\n+\t\t       && !DECL_ABSTRACT_P (t)\n+\t\t       && (!VAR_P (t) || !DECL_HARD_REGISTER (t)));\n \n   gcc_assert (VAR_OR_FUNCTION_DECL_P (t));\n \n@@ -2692,45 +2689,6 @@ write_symbol (struct streamer_tree_cache_d *cache,\n   lto_write_data (&slot_num, 4);\n }\n \n-/* Return true if NODE should appear in the plugin symbol table.  */\n-\n-bool\n-output_symbol_p (symtab_node *node)\n-{\n-  struct cgraph_node *cnode;\n-  if (!node->real_symbol_p ())\n-    return false;\n-  /* We keep external functions in symtab for sake of inlining\n-     and devirtualization.  We do not want to see them in symbol table as\n-     references unless they are really used.  */\n-  cnode = dyn_cast <cgraph_node *> (node);\n-  if (cnode && (!node->definition || DECL_EXTERNAL (cnode->decl))\n-      && cnode->callers)\n-    return true;\n-\n- /* Ignore all references from external vars initializers - they are not really\n-    part of the compilation unit until they are used by folding.  Some symbols,\n-    like references to external construction vtables can not be referred to at all.\n-    We decide this at can_refer_decl_in_current_unit_p.  */\n- if (!node->definition || DECL_EXTERNAL (node->decl))\n-    {\n-      int i;\n-      struct ipa_ref *ref;\n-      for (i = 0; node->iterate_referring (i, ref); i++)\n-\t{\n-\t  if (ref->use == IPA_REF_ALIAS)\n-\t    continue;\n-          if (is_a <cgraph_node *> (ref->referring))\n-\t    return true;\n-\t  if (!DECL_EXTERNAL (ref->referring->decl))\n-\t    return true;\n-\t}\n-      return false;\n-    }\n-  return true;\n-}\n-\n-\n /* Write an IL symbol table to OB.\n    SET and VSET are cgraph/varpool node sets we are outputting.  */\n \n@@ -2755,7 +2713,7 @@ produce_symtab (struct output_block *ob)\n     {\n       symtab_node *node = lsei_node (lsei);\n \n-      if (!output_symbol_p (node) || DECL_EXTERNAL (node->decl))\n+      if (DECL_EXTERNAL (node->decl) || !node->output_to_lto_symbol_table_p ())\n \tcontinue;\n       write_symbol (cache, node->decl, &seen, false);\n     }\n@@ -2764,7 +2722,7 @@ produce_symtab (struct output_block *ob)\n     {\n       symtab_node *node = lsei_node (lsei);\n \n-      if (!output_symbol_p (node) || !DECL_EXTERNAL (node->decl))\n+      if (!DECL_EXTERNAL (node->decl) || !node->output_to_lto_symbol_table_p ())\n \tcontinue;\n       write_symbol (cache, node->decl, &seen, false);\n     }"}, {"sha": "62fec49838053a33aac14b75dbfd903cd6cf3e0a", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39aa9b2369eff7f2be0712ea7f1ee12f8697ce36/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39aa9b2369eff7f2be0712ea7f1ee12f8697ce36/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=39aa9b2369eff7f2be0712ea7f1ee12f8697ce36", "patch": "@@ -1,3 +1,10 @@\n+2018-02-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/81360\n+\t* lto.c (unify_scc): Register prevailing trees, not trees to be freed.\n+\t(read_cgraph_and_symbols): Use\n+\tsymtab_node::output_to_lto_symbol_table_p.\n+\n 2018-01-30  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto.c (register_resolution): Remove forgotten sanity check."}, {"sha": "97266136aa084b3d15e6832d71571d83b9e6dabd", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39aa9b2369eff7f2be0712ea7f1ee12f8697ce36/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39aa9b2369eff7f2be0712ea7f1ee12f8697ce36/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=39aa9b2369eff7f2be0712ea7f1ee12f8697ce36", "patch": "@@ -1648,13 +1648,16 @@ unify_scc (struct data_in *data_in, unsigned from,\n \t\t{\n \t\t  map2[i*2] = (tree)(uintptr_t)(from + i);\n \t\t  map2[i*2+1] = scc->entries[i];\n-\t\t  lto_maybe_register_decl (data_in, scc->entries[i], from + i);\n \t\t}\n \t      qsort (map2, len, 2 * sizeof (tree), cmp_tree);\n \t      qsort (map, len, 2 * sizeof (tree), cmp_tree);\n \t      for (unsigned i = 0; i < len; ++i)\n-\t\tstreamer_tree_cache_replace_tree (cache, map[2*i],\n-\t\t\t\t\t\t  (uintptr_t)map2[2*i]);\n+\t\t{\n+\t\t  lto_maybe_register_decl (data_in, map[2*i],\n+\t\t\t\t\t   (uintptr_t)map2[2*i]);\n+\t\t  streamer_tree_cache_replace_tree (cache, map[2*i],\n+\t\t\t\t\t\t    (uintptr_t)map2[2*i]);\n+\t\t}\n \t    }\n \n \t  /* Free the tree nodes from the read SCC.  */\n@@ -2901,8 +2904,12 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n \n \tres = snode->lto_file_data->resolution_map->get (snode->decl);\n \tif (!res || *res == LDPR_UNKNOWN)\n-\t  fatal_error (input_location, \"missing resolution data for %s\",\n-\t\t       IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (snode->decl)));\n+\t  {\n+\t    if (snode->output_to_lto_symbol_table_p ())\n+\t      fatal_error (input_location, \"missing resolution data for %s\",\n+\t\t           IDENTIFIER_POINTER\n+\t\t\t     (DECL_ASSEMBLER_NAME (snode->decl)));\n+\t  }\n \telse\n           snode->resolution = *res;\n       }"}, {"sha": "b54183fbd49c22549ea6c03e87ed50fa3434c63c", "filename": "gcc/symtab.c", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39aa9b2369eff7f2be0712ea7f1ee12f8697ce36/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39aa9b2369eff7f2be0712ea7f1ee12f8697ce36/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=39aa9b2369eff7f2be0712ea7f1ee12f8697ce36", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"calls.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include \"builtins.h\"\n \n static const char *ipa_ref_use_name[] = {\"read\",\"write\",\"addr\",\"alias\",\"chkp\"};\n \n@@ -2292,3 +2293,58 @@ symtab_node::binds_to_current_def_p (symtab_node *ref)\n \n   return false;\n }\n+\n+/* Return true if symbol should be output to the symbol table.  */\n+\n+bool\n+symtab_node::output_to_lto_symbol_table_p (void)\n+{\n+  /* Only externally visible symbols matter.  */\n+  if (!TREE_PUBLIC (decl))\n+    return false;\n+  if (!real_symbol_p ())\n+    return false;\n+  /* FIXME: variables probably should not be considered as real symbols at\n+     first place.  */\n+  if (VAR_P (decl) && DECL_HARD_REGISTER (decl))\n+    return false;\n+  /* FIXME: Builtins corresponding to real functions probably should have\n+     symbol table entries.  */\n+  if (is_builtin_fn (decl))\n+    return false;\n+\n+  /* We have real symbol that should be in symbol table.  However try to trim\n+     down the refernces to libraries bit more because linker will otherwise\n+     bring unnecesary object files into the final link.\n+     FIXME: The following checks can easily be confused i.e. by self recursive\n+     function or self-referring variable.  */\n+\n+  /* We keep external functions in symtab for sake of inlining\n+     and devirtualization.  We do not want to see them in symbol table as\n+     references unless they are really used.  */\n+  cgraph_node *cnode = dyn_cast <cgraph_node *> (this);\n+  if (cnode && (!definition || DECL_EXTERNAL (decl))\n+      && cnode->callers)\n+    return true;\n+\n+ /* Ignore all references from external vars initializers - they are not really\n+    part of the compilation unit until they are used by folding.  Some symbols,\n+    like references to external construction vtables can not be referred to at\n+    all.  We decide this at can_refer_decl_in_current_unit_p.  */\n+ if (!definition || DECL_EXTERNAL (decl))\n+    {\n+      int i;\n+      struct ipa_ref *ref;\n+      for (i = 0; iterate_referring (i, ref); i++)\n+\t{\n+\t  if (ref->use == IPA_REF_ALIAS)\n+\t    continue;\n+          if (is_a <cgraph_node *> (ref->referring))\n+\t    return true;\n+\t  if (!DECL_EXTERNAL (ref->referring->decl))\n+\t    return true;\n+\t}\n+      return false;\n+    }\n+  return true;\n+}"}, {"sha": "63a29f4868c4c3f051af9d2ea3bf37e21158873f", "filename": "gcc/tree.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39aa9b2369eff7f2be0712ea7f1ee12f8697ce36/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39aa9b2369eff7f2be0712ea7f1ee12f8697ce36/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=39aa9b2369eff7f2be0712ea7f1ee12f8697ce36", "patch": "@@ -5329,6 +5329,16 @@ free_lang_data_in_decl (tree decl)\n \t At this point, it is not needed anymore.  */\n       DECL_SAVED_TREE (decl) = NULL_TREE;\n \n+      /* Clear the abstract origin if it refers to a method.\n+         Otherwise dwarf2out.c will ICE as we splice functions out of\n+         TYPE_FIELDS and thus the origin will not be output\n+         correctly.  */\n+      if (DECL_ABSTRACT_ORIGIN (decl)\n+\t  && DECL_CONTEXT (DECL_ABSTRACT_ORIGIN (decl))\n+\t  && RECORD_OR_UNION_TYPE_P\n+\t       (DECL_CONTEXT (DECL_ABSTRACT_ORIGIN (decl))))\n+\tDECL_ABSTRACT_ORIGIN (decl) = NULL_TREE;\n+\n       /* Sometimes the C++ frontend doesn't manage to transform a temporary\n          DECL_VINDEX referring to itself into a vtable slot number as it\n \t should.  Happens with functions that are copied and then forgotten"}]}