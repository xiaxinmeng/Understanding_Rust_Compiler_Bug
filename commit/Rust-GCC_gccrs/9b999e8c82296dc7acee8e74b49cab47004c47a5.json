{"sha": "9b999e8c82296dc7acee8e74b49cab47004c47a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI5OTllOGM4MjI5NmRjN2FjZWU4ZTc0YjQ5Y2FiNDcwMDRjNDdhNQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-06-08T12:40:20Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-06-08T12:40:20Z"}, "message": "tree-vect-stmts.c (vectorizable_load): Compute the pointer adjustment for gaps at the end of a SLP load group properly.\n\n2015-06-08  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-stmts.c (vectorizable_load): Compute the pointer\n\tadjustment for gaps at the end of a SLP load group properly.\n\t* tree-vect-slp.c (vect_supported_load_permutation_p): Allow\n\tall permutations we can generate.\n\t(vect_transform_slp_perm_load): Use the correct group-size.\n\n\t* gcc.dg/vect/slp-perm-10.c: New testcase.\n\t* gcc.dg/vect/slp-23.c: Adjust.\n\t* gcc.dg/torture/pr53366-2.c: Also verify cross-iteration\n\tvector pointer update.\n\nFrom-SVN: r224221", "tree": {"sha": "456b16db69b5530668be1975ccba10590686beb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/456b16db69b5530668be1975ccba10590686beb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b999e8c82296dc7acee8e74b49cab47004c47a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b999e8c82296dc7acee8e74b49cab47004c47a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b999e8c82296dc7acee8e74b49cab47004c47a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b999e8c82296dc7acee8e74b49cab47004c47a5/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7026b8dfd18fc18e7110c193b1a41d4bb119c8c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7026b8dfd18fc18e7110c193b1a41d4bb119c8c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7026b8dfd18fc18e7110c193b1a41d4bb119c8c7"}], "stats": {"total": 160, "additions": 101, "deletions": 59}, "files": [{"sha": "b84e325c716298c79f8ea64a19ec1851d7d31cd3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b999e8c82296dc7acee8e74b49cab47004c47a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b999e8c82296dc7acee8e74b49cab47004c47a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b999e8c82296dc7acee8e74b49cab47004c47a5", "patch": "@@ -1,3 +1,11 @@\n+2015-06-08  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-stmts.c (vectorizable_load): Compute the pointer\n+\tadjustment for gaps at the end of a SLP load group properly.\n+\t* tree-vect-slp.c (vect_supported_load_permutation_p): Allow\n+\tall permutations we can generate.\n+\t(vect_transform_slp_perm_load): Use the correct group-size.\n+\n 2015-06-08  Marc Glisse  <marc.glisse@inria.fr>\n \n \t* genmatch.c (expr::gen_transform): For conditions, guess the type"}, {"sha": "46e207bb980c805d5081230b9d0ec69dc35cc3f1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b999e8c82296dc7acee8e74b49cab47004c47a5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b999e8c82296dc7acee8e74b49cab47004c47a5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9b999e8c82296dc7acee8e74b49cab47004c47a5", "patch": "@@ -1,3 +1,10 @@\n+2015-06-08  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/vect/slp-perm-10.c: New testcase.\n+\t* gcc.dg/vect/slp-23.c: Adjust.\n+\t* gcc.dg/torture/pr53366-2.c: Also verify cross-iteration\n+\tvector pointer update.\n+\n 2015-06-08  Marek Polacek  <polacek@redhat.com>\n \n \tPR sanitizer/66452"}, {"sha": "b141b5e717e03befb9220a24239e9792130030cc", "filename": "gcc/testsuite/gcc.dg/torture/pr53366-2.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b999e8c82296dc7acee8e74b49cab47004c47a5/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr53366-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b999e8c82296dc7acee8e74b49cab47004c47a5/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr53366-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr53366-2.c?ref=9b999e8c82296dc7acee8e74b49cab47004c47a5", "patch": "@@ -4,18 +4,18 @@\n extern void abort (void);\n \n struct T { float r[3], i[3]; };\n-struct U { struct T j[2]; };\n+struct U { struct T j[4]; };\n \n void __attribute__ ((noinline))\n foo (struct U *__restrict y, const float _Complex *__restrict x)\n {\n   int i, j;\n-  for (j = 0; j < 2; ++j)\n+  for (j = 0; j < 4; ++j)\n     {\n       float a = __real__ x[j];\n       float b = __imag__ x[j];\n-      float c = __real__ x[j + 2];\n-      float d = __imag__ x[j + 2];\n+      float c = __real__ x[j + 4];\n+      float d = __imag__ x[j + 4];\n       for (i = 0; i < 3; ++i)\n         {\n           y->j[j].r[i] = y->j[j].r[i] + a + c;\n@@ -24,20 +24,23 @@ foo (struct U *__restrict y, const float _Complex *__restrict x)\n     }\n }\n \n-_Complex float x[4];\n+_Complex float x[8];\n struct U y;\n \n int\n main ()\n {\n   int i, j;\n-  for (i = 0; i < 4; ++i)\n-    x[i] = i + 1.0iF * (2 * i);\n+  for (i = 0; i < 8; ++i)\n+    {\n+      x[i] = i + 1.0iF * (2 * i);\n+      __asm__ volatile (\"\");\n+    }\n   foo (&y, x);\n-  for (j = 0; j < 2; ++j)\n+  for (j = 0; j < 4; ++j)\n     for (i = 0; i < 3; ++i)\n-      if (y.j[j].r[i] != __real__ (x[j] + x[j + 2])\n-          || y.j[j].i[i] != __imag__ (x[j] + x[j + 2]))\n+      if (y.j[j].r[i] != __real__ (x[j] + x[j + 4])\n+          || y.j[j].i[i] != __imag__ (x[j] + x[j + 4]))\n         __builtin_abort ();\n   return 0;\n }"}, {"sha": "b1fe6e4272edc919566559a27fa670307292e1be", "filename": "gcc/testsuite/gcc.dg/vect/slp-23.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b999e8c82296dc7acee8e74b49cab47004c47a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b999e8c82296dc7acee8e74b49cab47004c47a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-23.c?ref=9b999e8c82296dc7acee8e74b49cab47004c47a5", "patch": "@@ -108,5 +108,6 @@ int main (void)\n \n /* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { target { vect_strided8 && { ! { vect_no_align} } } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { ! { vect_strided8 || vect_no_align } } } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target { ! vect_perm } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target vect_perm } } } */\n   "}, {"sha": "1c2a8580d3c115160798fd54a024de6cc84d8ad2", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-10.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b999e8c82296dc7acee8e74b49cab47004c47a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b999e8c82296dc7acee8e74b49cab47004c47a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-10.c?ref=9b999e8c82296dc7acee8e74b49cab47004c47a5", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+int a[256], b[256];\n+\n+void __attribute__((noinline))\n+foo (void)\n+{\n+  int i;\n+  for (i = 0; i < 32; ++i)\n+    {\n+      b[i*8+0] = a[i*8+0];\n+      b[i*8+1] = a[i*8+0];\n+      b[i*8+2] = a[i*8+3];\n+      b[i*8+3] = a[i*8+3];\n+      b[i*8+4] = a[i*8+4];\n+      b[i*8+5] = a[i*8+6];\n+      b[i*8+6] = a[i*8+4];\n+      b[i*8+7] = a[i*8+6];\n+    }\n+}\n+\n+int main ()\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < 256; ++i)\n+    {\n+      a[i] = i;\n+      __asm__ volatile (\"\");\n+    }\n+\n+  foo ();\n+\n+  for (i = 0; i < 32; ++i)\n+    if (b[i*8+0] != i*8+0\n+\t|| b[i*8+1] != i*8+0\n+\t|| b[i*8+2] != i*8+3\n+\t|| b[i*8+3] != i*8+3\n+\t|| b[i*8+4] != i*8+4\n+\t|| b[i*8+5] != i*8+6\n+\t|| b[i*8+6] != i*8+4\n+\t|| b[i*8+7] != i*8+6)\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_perm } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target vect_perm } } } */"}, {"sha": "612099878d172a4df09a833ab9a1887422ecd178", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 5, "deletions": 36, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b999e8c82296dc7acee8e74b49cab47004c47a5/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b999e8c82296dc7acee8e74b49cab47004c47a5/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=9b999e8c82296dc7acee8e74b49cab47004c47a5", "patch": "@@ -1497,47 +1497,14 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n       return true;\n     }\n \n-  /* FORNOW: the only supported permutation is 0..01..1.. of length equal to\n-     GROUP_SIZE and where each sequence of same drs is of GROUP_SIZE length as\n-     well (unless it's reduction).  */\n-  if (SLP_INSTANCE_LOADS (slp_instn).length () != group_size)\n-    return false;\n-  FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n-    if (!node->load_permutation.exists ())\n-      return false;\n-\n-  load_index = sbitmap_alloc (group_size);\n-  bitmap_clear (load_index);\n-  FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n-    {\n-      unsigned int lidx = node->load_permutation[0];\n-      if (bitmap_bit_p (load_index, lidx))\n-\t{\n-\t  sbitmap_free (load_index);\n-\t  return false;\n-\t}\n-      bitmap_set_bit (load_index, lidx);\n-      FOR_EACH_VEC_ELT (node->load_permutation, j, k)\n-\tif (k != lidx)\n-\t  {\n-\t    sbitmap_free (load_index);\n-\t    return false;\n-\t  }\n-    }\n-  for (i = 0; i < group_size; i++)\n-    if (!bitmap_bit_p (load_index, i))\n-      {\n-\tsbitmap_free (load_index);\n-\treturn false;\n-      }\n-  sbitmap_free (load_index);\n-\n+  /* For loop vectorization verify we can generate the permutation.  */\n   FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n     if (node->load_permutation.exists ()\n \t&& !vect_transform_slp_perm_load\n \t      (node, vNULL, NULL,\n \t       SLP_INSTANCE_UNROLLING_FACTOR (slp_instn), slp_instn, true))\n       return false;\n+\n   return true;\n }\n \n@@ -3282,6 +3249,8 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n   if (!STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     return false;\n \n+  stmt_info = vinfo_for_stmt (GROUP_FIRST_ELEMENT (stmt_info));\n+\n   /* Generate permutation masks for every NODE. Number of masks for each NODE\n      is equal to GROUP_SIZE.\n      E.g., we have a group of three nodes with three loads from the same\n@@ -3316,7 +3285,7 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n           for (k = 0; k < group_size; k++)\n             {\n \t      i = SLP_TREE_LOAD_PERMUTATION (node)[k];\n-              first_mask_element = i + j * group_size;\n+              first_mask_element = i + j * STMT_VINFO_GROUP_SIZE (stmt_info);\n               if (!vect_get_mask_element (stmt, first_mask_element, 0,\n \t\t\t\t\t  nunits, only_one_vec, index,\n \t\t\t\t\t  mask, &current_mask_element,"}, {"sha": "6f31312e5dc41e6c8179468d83baffc4c6ff2fd7", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b999e8c82296dc7acee8e74b49cab47004c47a5/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b999e8c82296dc7acee8e74b49cab47004c47a5/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=9b999e8c82296dc7acee8e74b49cab47004c47a5", "patch": "@@ -5802,7 +5802,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   gimple ptr_incr = NULL;\n   int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   int ncopies;\n-  int i, j, group_size = -1, group_gap;\n+  int i, j, group_size = -1, group_gap_adj;\n   tree msq = NULL_TREE, lsq;\n   tree offset = NULL_TREE;\n   tree byte_offset = NULL_TREE;\n@@ -6391,26 +6391,24 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t}\n       first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n       group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+      group_gap_adj = 0;\n \n       /* VEC_NUM is the number of vect stmts to be created for this group.  */\n       if (slp)\n \t{\n \t  grouped_load = false;\n \t  vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n-\t  group_gap = GROUP_GAP (vinfo_for_stmt (first_stmt));\n+\t  group_gap_adj = vf * group_size - nunits * vec_num;\n     \t}\n       else\n-\t{\n-\t  vec_num = group_size;\n-\t  group_gap = 0;\n-\t}\n+\tvec_num = group_size;\n     }\n   else\n     {\n       first_stmt = stmt;\n       first_dr = dr;\n       group_size = vec_num = 1;\n-      group_gap = 0;\n+      group_gap_adj = 0;\n     }\n \n   alignment_support_scheme = vect_supportable_dr_alignment (first_dr, false);\n@@ -6826,12 +6824,15 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t      if (slp && !slp_perm)\n \t\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n \t    }\n-\t  /* Bump the vector pointer to account for a gap.  */\n-\t  if (slp && group_gap != 0)\n+\t  /* Bump the vector pointer to account for a gap or for excess\n+\t     elements loaded for a permuted SLP load.  */\n+\t  if (group_gap_adj != 0)\n \t    {\n-\t      tree bump = size_binop (MULT_EXPR,\n-\t\t\t\t      TYPE_SIZE_UNIT (elem_type),\n-\t\t\t\t      size_int (group_gap));\n+\t      bool ovf;\n+\t      tree bump\n+\t\t= wide_int_to_tree (sizetype,\n+\t\t\t\t    wi::smul (TYPE_SIZE_UNIT (elem_type),\n+\t\t\t\t\t      group_gap_adj, &ovf));\n \t      dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi,\n \t\t\t\t\t     stmt, bump);\n \t    }"}]}