{"sha": "e020783cd60ae60a361cd18f1a3763f65f30b0b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAyMDc4M2NkNjBhZTYwYTM2MWNkMThmMWEzNzYzZjY1ZjMwYjBiOA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2017-07-19T15:46:04Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2017-07-19T15:46:04Z"}, "message": "Fix indentation in std::basic_filebuf member functions\n\n\t* include/bits/fstream.tcc (basic_filebuf::xsgetn)\n\t(basic_filebuf::xsputn, basic_filebuf::seekoff): Fix indentation.\n\nFrom-SVN: r250353", "tree": {"sha": "f21ea14f429bc3dc0deb112bcd18d73b7a997dae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f21ea14f429bc3dc0deb112bcd18d73b7a997dae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e020783cd60ae60a361cd18f1a3763f65f30b0b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e020783cd60ae60a361cd18f1a3763f65f30b0b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e020783cd60ae60a361cd18f1a3763f65f30b0b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e020783cd60ae60a361cd18f1a3763f65f30b0b8/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f860bca0072af4f012e6640f1befa9bb02f4ed5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f860bca0072af4f012e6640f1befa9bb02f4ed5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f860bca0072af4f012e6640f1befa9bb02f4ed5"}], "stats": {"total": 113, "additions": 57, "deletions": 56}, "files": [{"sha": "9ac3fcaf79ef479a316d4b5a52d18355513557e4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e020783cd60ae60a361cd18f1a3763f65f30b0b8/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e020783cd60ae60a361cd18f1a3763f65f30b0b8/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e020783cd60ae60a361cd18f1a3763f65f30b0b8", "patch": "@@ -1,5 +1,8 @@\n 2017-07-19  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/bits/fstream.tcc (basic_filebuf::xsgetn)\n+\t(basic_filebuf::xsputn, basic_filebuf::seekoff): Fix indentation.\n+\n \t* testsuite/util/testsuite_iterators.h: Fix indentation.\n \n \t* testsuite/27_io/basic_filebuf/sgetn/char/81395.cc: Add dg-require."}, {"sha": "12ea977b997445cbc954d643c380691527656f59", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "modified", "additions": 54, "deletions": 56, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e020783cd60ae60a361cd18f1a3763f65f30b0b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e020783cd60ae60a361cd18f1a3763f65f30b0b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=e020783cd60ae60a361cd18f1a3763f65f30b0b8", "patch": "@@ -649,11 +649,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n       else if (_M_writing)\n \t{\n- \t  if (overflow() == traits_type::eof())\n- \t    return __ret;\n- \t  _M_set_buffer(-1);\n- \t  _M_writing = false;\n- \t}\n+\t  if (overflow() == traits_type::eof())\n+\t    return __ret;\n+\t  _M_set_buffer(-1);\n+\t  _M_writing = false;\n+\t}\n  \n       // Optimization in the always_noconv() case, to be generalized in the\n       // future: when __n > __buflen we read directly instead of using the\n@@ -662,57 +662,55 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       const streamsize __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;\n  \n       if (__n > __buflen && __check_facet(_M_codecvt).always_noconv()\n- \t   && __testin)\n- \t {\n- \t   // First, copy the chars already present in the buffer.\n- \t   const streamsize __avail = this->egptr() - this->gptr();\n- \t   if (__avail != 0)\n- \t     {\n-\t       traits_type::copy(__s, this->gptr(), __avail);\n- \t       __s += __avail;\n-\t       this->setg(this->eback(), this->gptr() + __avail,\n-\t\t\t  this->egptr());\n-\t       __ret += __avail;\n-\t       __n -= __avail;\n- \t     }\n- \n- \t   // Need to loop in case of short reads (relatively common\n- \t   // with pipes).\n- \t   streamsize __len;\n- \t   for (;;)\n- \t     {\n- \t       __len = _M_file.xsgetn(reinterpret_cast<char*>(__s),\n- \t\t\t\t      __n);\n- \t       if (__len == -1)\n- \t\t __throw_ios_failure(__N(\"basic_filebuf::xsgetn \"\n- \t\t\t\t\t \"error reading the file\"));\n- \t       if (__len == 0)\n- \t\t break;\n- \n- \t       __n -= __len;\n- \t       __ret += __len;\n- \t       if (__n == 0)\n- \t\t break;\n+\t  && __testin)\n+\t{\n+\t  // First, copy the chars already present in the buffer.\n+\t  const streamsize __avail = this->egptr() - this->gptr();\n+\t  if (__avail != 0)\n+\t    {\n+\t      traits_type::copy(__s, this->gptr(), __avail);\n+\t      __s += __avail;\n+\t      this->setg(this->eback(), this->gptr() + __avail, this->egptr());\n+\t      __ret += __avail;\n+\t      __n -= __avail;\n+\t    }\n  \n- \t       __s += __len;\n- \t     }\n+\t  // Need to loop in case of short reads (relatively common\n+\t  // with pipes).\n+\t  streamsize __len;\n+\t  for (;;)\n+\t    {\n+\t      __len = _M_file.xsgetn(reinterpret_cast<char*>(__s), __n);\n+\t      if (__len == -1)\n+\t\t__throw_ios_failure(__N(\"basic_filebuf::xsgetn \"\n+\t\t\t\t\t\"error reading the file\"));\n+\t      if (__len == 0)\n+\t\tbreak;\n  \n- \t   if (__n == 0)\n- \t     {\n-\t       // Set _M_reading. Buffer is already in initial 'read' mode.\n- \t       _M_reading = true;\n- \t     }\n- \t   else if (__len == 0)\n- \t     {\n- \t       // If end of file is reached, set 'uncommitted'\n- \t       // mode, thus allowing an immediate write without\n- \t       // an intervening seek.\n- \t       _M_set_buffer(-1);\n- \t       _M_reading = false;\n- \t     }\n- \t }\n+\t      __n -= __len;\n+\t      __ret += __len;\n+\t      if (__n == 0)\n+\t\tbreak;\n+\n+\t      __s += __len;\n+\t    }\n+\n+\t  if (__n == 0)\n+\t    {\n+\t      // Set _M_reading. Buffer is already in initial 'read' mode.\n+\t      _M_reading = true;\n+\t    }\n+\t  else if (__len == 0)\n+\t    {\n+\t      // If end of file is reached, set 'uncommitted'\n+\t      // mode, thus allowing an immediate write without\n+\t      // an intervening seek.\n+\t      _M_set_buffer(-1);\n+\t      _M_reading = false;\n+\t    }\n+\t}\n       else\n- \t __ret += __streambuf_type::xsgetn(__s, __n);\n+\t__ret += __streambuf_type::xsgetn(__s, __n);\n  \n       return __ret;\n     }\n@@ -729,7 +727,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       const bool __testout = (_M_mode & ios_base::out\n \t\t\t      || _M_mode & ios_base::app);\n       if (__check_facet(_M_codecvt).always_noconv()\n- \t   && __testout && !_M_reading)\n+\t  && __testout && !_M_reading)\n \t{\n \t  // Measurement would reveal the best choice.\n \t  const streamsize __chunk = 1ul << 10;\n@@ -839,8 +837,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      if (_M_writing)\n \t\t__computed_off = this->pptr() - this->pbase();\n \t      \n- \t      off_type __file_off = _M_file.seekoff(0, ios_base::cur);\n- \t      if (__file_off != off_type(-1))\n+\t      off_type __file_off = _M_file.seekoff(0, ios_base::cur);\n+\t      if (__file_off != off_type(-1))\n \t\t{\n \t\t  __ret = __file_off + __computed_off;\n \t\t  __ret.state(__state);"}]}