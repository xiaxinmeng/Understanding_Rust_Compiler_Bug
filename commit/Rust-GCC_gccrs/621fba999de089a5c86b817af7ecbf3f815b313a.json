{"sha": "621fba999de089a5c86b817af7ecbf3f815b313a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjIxZmJhOTk5ZGUwODlhNWM4NmI4MTdhZjdlY2JmM2Y4MTViMzEzYQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-03-10T04:50:21Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-03-10T04:50:21Z"}, "message": "verify.cc (state::NO_STACK): New constant.\n\n\t* verify.cc (state::NO_STACK): New constant.\n\t(state::is_unmerged_ret_state): Handle case where stacktop is\n\tNO_STACK.\n\t(state::merge): Handle NO_STACK merges.\n\t(handle_jsr_insn): Invalidate PC, and use special NO_STACK state\n\tfor instruction following jsr.\n\t(stacktop, stackdepth): Removed unused variables.\n\t(pop_jump): Ignore case where all remaining states are skipped.\n\nFrom-SVN: r50526", "tree": {"sha": "3d84de36381d8c5b7296763dfb90dfd90f8e1a5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d84de36381d8c5b7296763dfb90dfd90f8e1a5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/621fba999de089a5c86b817af7ecbf3f815b313a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/621fba999de089a5c86b817af7ecbf3f815b313a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/621fba999de089a5c86b817af7ecbf3f815b313a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/621fba999de089a5c86b817af7ecbf3f815b313a/comments", "author": null, "committer": null, "parents": [{"sha": "2c59df99351b3830faa898c52f3e639bfb3a9375", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c59df99351b3830faa898c52f3e639bfb3a9375", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c59df99351b3830faa898c52f3e639bfb3a9375"}], "stats": {"total": 86, "additions": 64, "deletions": 22}, "files": [{"sha": "1a36a3c6ec3084c955e8cf111310d689d365b1c3", "filename": "libjava/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/621fba999de089a5c86b817af7ecbf3f815b313a/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/621fba999de089a5c86b817af7ecbf3f815b313a/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=621fba999de089a5c86b817af7ecbf3f815b313a", "patch": "@@ -1,3 +1,14 @@\n+2002-03-09  Tom Tromey  <tromey@redhat.com>\n+\n+\t* verify.cc (state::NO_STACK): New constant.\n+\t(state::is_unmerged_ret_state): Handle case where stacktop is\n+\tNO_STACK.\n+\t(state::merge): Handle NO_STACK merges.\n+\t(handle_jsr_insn): Invalidate PC, and use special NO_STACK state\n+\tfor instruction following jsr.\n+\t(stacktop, stackdepth): Removed unused variables.\n+\t(pop_jump): Ignore case where all remaining states are skipped.\n+\n 2002-03-09  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n \n \t* java/awt/ImageMediaEntry: Removed."}, {"sha": "2fcfb607cc9abeb1fe7c2609ba7a6ee57b827384", "filename": "libjava/verify.cc", "status": "modified", "additions": 53, "deletions": 22, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/621fba999de089a5c86b817af7ecbf3f815b313a/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/621fba999de089a5c86b817af7ecbf3f815b313a/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=621fba999de089a5c86b817af7ecbf3f815b313a", "patch": "@@ -90,12 +90,6 @@ class _Jv_BytecodeVerifier\n   // be many `ret' instructions, so a linked list is ok.\n   subr_entry_info *entry_points;\n \n-  // The current top of the stack, in terms of slots.\n-  int stacktop;\n-  // The current depth of the stack.  This will be larger than\n-  // STACKTOP when wide types are on the stack.\n-  int stackdepth;\n-\n   // The bytecode itself.\n   unsigned char *bytecode;\n   // The exceptions.\n@@ -773,10 +767,10 @@ class _Jv_BytecodeVerifier\n   // location.\n   struct state\n   {\n-    // Current top of stack.\n+    // The current top of the stack, in terms of slots.\n     int stacktop;\n-    // Current stack depth.  This is like the top of stack but it\n-    // includes wide variable information.\n+    // The current depth of the stack.  This will be larger than\n+    // STACKTOP when wide types are on the stack.\n     int stackdepth;\n     // The stack.\n     type *stack;\n@@ -806,6 +800,11 @@ class _Jv_BytecodeVerifier\n     // NO_NEXT marks the state at the end of the reverification list.\n     static const int NO_NEXT = -2;\n \n+    // This is used to mark the stack depth at the instruction just\n+    // after a `jsr' when we haven't yet processed the corresponding\n+    // `ret'.  See handle_jsr_insn for more information.\n+    static const int NO_STACK = -1;\n+\n     state ()\n       : this_type ()\n     {\n@@ -951,13 +950,29 @@ class _Jv_BytecodeVerifier\n \t  changed = true;\n \t}\n \n-      // Merge stacks.\n-      if (state_old->stacktop != stacktop)\n+      // Merge stacks.  Special handling for NO_STACK case.\n+      if (state_old->stacktop == NO_STACK)\n+\t{\n+\t  // Nothing to do in this case; we don't care about modifying\n+\t  // the old state.\n+\t}\n+      else if (stacktop == NO_STACK)\n+\t{\n+\t  stacktop = state_old->stacktop;\n+\t  stackdepth = state_old->stackdepth;\n+\t  for (int i = 0; i < stacktop; ++i)\n+\t    stack[i] = state_old->stack[i];\n+\t  changed = true;\n+\t}\n+      else if (state_old->stacktop != stacktop)\n \tverifier->verify_fail (\"stack sizes differ\");\n-      for (int i = 0; i < state_old->stacktop; ++i)\n+      else\n \t{\n-\t  if (stack[i].merge (state_old->stack[i], false, verifier))\n-\t    changed = true;\n+\t  for (int i = 0; i < state_old->stacktop; ++i)\n+\t    {\n+\t      if (stack[i].merge (state_old->stack[i], false, verifier))\n+\t\tchanged = true;\n+\t    }\n \t}\n \n       // Merge local variables.\n@@ -1048,6 +1063,8 @@ class _Jv_BytecodeVerifier\n     // Return true if this state is the unmerged result of a `ret'.\n     bool is_unmerged_ret_state (int max_locals) const\n     {\n+      if (stacktop == NO_STACK)\n+\treturn true;\n       for (int i = 0; i < max_locals; ++i)\n \t{\n \t  if (locals[i].key == unused_by_subroutine_type)\n@@ -1343,10 +1360,9 @@ class _Jv_BytecodeVerifier\n \tnpc = states[npc]->next;\n       }\n \n-    // If we've skipped states and there is nothing else, that's a\n-    // bug.\n-    if (skipped)\n-      verify_fail (\"pop_jump: can't happen\");\n+    // Note that we might have gotten here even when there are\n+    // remaining states to process.  That can happen if we find a\n+    // `jsr' without a `ret'.\n     return state::NO_NEXT;\n   }\n \n@@ -1450,19 +1466,34 @@ class _Jv_BytecodeVerifier\n       current_state->check_no_uninitialized_objects (current_method->max_locals, this);\n     check_nonrecursive_call (current_state->subroutine, npc);\n \n-    // Create a new state and modify it as appropriate for entry into\n-    // a subroutine.  We're writing this in a weird way because,\n-    // unfortunately, push_type only works on the current state.\n+    // Modify our state as appropriate for entry into a subroutine.\n     push_type (return_address_type);\n     push_jump_merge (npc, current_state);\n-    // Clean up the weirdness.\n+    // Clean up.\n     pop_type (return_address_type);\n \n     // On entry to the subroutine, the subroutine number must be set\n     // and the locals must be marked as cleared.  We do this after\n     // merging state so that we don't erroneously \"notice\" a variable\n     // change merely on entry.\n     states[npc]->enter_subroutine (npc, current_method->max_locals);\n+\n+    // Indicate that we don't know the stack depth of the instruction\n+    // following the `jsr'.  The idea here is that we need to merge\n+    // the local variable state across the jsr, but the subroutine\n+    // might change the stack depth, so we can't make any assumptions\n+    // about it.  So we have yet another special case.  We know that\n+    // at this point PC points to the instruction after the jsr.\n+\n+    // FIXME: what if we have a jsr at the end of the code, but that\n+    // jsr has no corresponding ret?  Is this verifiable, or is it\n+    // not?  If it is then we need a special case here.\n+    if (PC >= current_method->code_length)\n+      verify_fail (\"fell off end\");\n+\n+    current_state->stacktop = state::NO_STACK;\n+    push_jump_merge (PC, current_state);\n+    invalidate_pc ();\n   }\n \n   jclass construct_primitive_array_type (type_val prim)"}]}