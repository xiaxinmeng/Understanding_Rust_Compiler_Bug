{"sha": "aa6ad95c057d748c351fc50cac9f710299e8be07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE2YWQ5NWMwNTdkNzQ4YzM1MWZjNTBjYWM5ZjcxMDI5OWU4YmUwNw==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-04T00:11:39Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-04T00:11:39Z"}, "message": "trans-intrinsic.c (gfc_conv_intrinsic_minmaxval): Set loop's temporary rank to the loop rank.\n\n\t* trans-intrinsic.c (gfc_conv_intrinsic_minmaxval): Set loop's\n\ttemporary rank to the loop rank. Mark ss chains for multiple loop\n\tif necessary.  Use gfc_trans_scalarized_loop_boundary to end one loop\n\tand start another.\n\nFrom-SVN: r180909", "tree": {"sha": "52f466be34e8765b0d22fdcddd8a5850ae55f2a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52f466be34e8765b0d22fdcddd8a5850ae55f2a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa6ad95c057d748c351fc50cac9f710299e8be07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa6ad95c057d748c351fc50cac9f710299e8be07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa6ad95c057d748c351fc50cac9f710299e8be07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa6ad95c057d748c351fc50cac9f710299e8be07/comments", "author": null, "committer": null, "parents": [{"sha": "610f068d4c18d6c732945fb85b0ac519da9451c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/610f068d4c18d6c732945fb85b0ac519da9451c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/610f068d4c18d6c732945fb85b0ac519da9451c6"}], "stats": {"total": 31, "additions": 26, "deletions": 5}, "files": [{"sha": "86551b71b8a73f55c0eea2d813244000c1120da2", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa6ad95c057d748c351fc50cac9f710299e8be07/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa6ad95c057d748c351fc50cac9f710299e8be07/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=aa6ad95c057d748c351fc50cac9f710299e8be07", "patch": "@@ -1,3 +1,10 @@\n+2011-11-04  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_minmaxval): Set loop's\n+\ttemporary rank to the loop rank. Mark ss chains for multiple loop\n+\tif necessary.  Use gfc_trans_scalarized_loop_boundary to end one loop\n+\tand start another.\n+\n 2011-11-04  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* trans-intrinsic.c (gfc_conv_intrinsic_minmaxloc): Set loop's"}, {"sha": "3cdc1e0970aa4f787a60c96e50572a0bb1cb2a6e", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa6ad95c057d748c351fc50cac9f710299e8be07/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa6ad95c057d748c351fc50cac9f710299e8be07/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=aa6ad95c057d748c351fc50cac9f710299e8be07", "patch": "@@ -3522,6 +3522,22 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n   /* Initialize the loop.  */\n   gfc_conv_ss_startstride (&loop);\n+\n+  /* The code generated can have more than one loop in sequence (see the\n+     comment at the function header).  This doesn't work well with the\n+     scalarizer, which changes arrays' offset when the scalarization loops\n+     are generated (see gfc_trans_preloop_setup).  Fortunately, {min,max}val\n+     are  currently inlined in the scalar case only.  As there is no dependency\n+     to care about in that case, there is no temporary, so that we can use the\n+     scalarizer temporary code to handle multiple loops.  Thus, we set temp_dim\n+     here, we call gfc_mark_ss_chain_used with flag=3 later, and we use\n+     gfc_trans_scalarized_loop_boundary even later to restore offset.\n+     TODO: this prevents inlining of rank > 0 minmaxval calls, so this\n+     should eventually go away.  We could either create two loops properly,\n+     or find another way to save/restore the array offsets between the two\n+     loops (without conflicting with temporary management), or use a single\n+     loop minmaxval implementation.  See PR 31067.  */\n+  loop.temp_dim = loop.dimen;\n   gfc_conv_loop_setup (&loop, &expr->where);\n \n   if (nonempty == NULL && maskss == NULL\n@@ -3553,9 +3569,9 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \t}\n     }\n \n-  gfc_mark_ss_chain_used (arrayss, 1);\n+  gfc_mark_ss_chain_used (arrayss, lab ? 3 : 1);\n   if (maskss)\n-    gfc_mark_ss_chain_used (maskss, 1);\n+    gfc_mark_ss_chain_used (maskss, lab ? 3 : 1);\n   /* Generate the loop body.  */\n   gfc_start_scalarized_body (&loop, &body);\n \n@@ -3665,15 +3681,13 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n   if (lab)\n     {\n-      gfc_trans_scalarized_loop_end (&loop, 0, &body);\n+      gfc_trans_scalarized_loop_boundary (&loop, &body);\n \n       tmp = fold_build3_loc (input_location, COND_EXPR, type, nonempty,\n \t\t\t     nan_cst, huge_cst);\n       gfc_add_modify (&loop.code[0], limit, tmp);\n       gfc_add_expr_to_block (&loop.code[0], build1_v (LABEL_EXPR, lab));\n \n-      gfc_start_block (&body);\n-\n       /* If we have a mask, only add this element if the mask is set.  */\n       if (maskss)\n \t{"}]}