{"sha": "b8eaca232b716d78395c3ddacb0484ee6148d141", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhlYWNhMjMyYjcxNmQ3ODM5NWMzZGRhY2IwNDg0ZWU2MTQ4ZDE0MQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-10-15T21:57:21Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-10-15T21:57:21Z"}, "message": "genmodes.c: Include hashtab.h.\n\n\t* genmodes.c: Include hashtab.h.\n\t(modes_by_name, hash_mode, eq_mode, struct mode_adjust)\n\t(adj_bytesize, adj_alignment, adj_format, new_adjust)\n\t(_ADD_ADJUST, ADJUST_BYTESIZE, ADJUST_ALIGNMENT, ADJUST_FORMAT)\n\t(print_maybe_const_decl, emit_mode_adjustments): New.\n\t(known_modes): Rename to modes.\n\t(find_mode): Kill class argument; look up in hash table.\n\t(new_mode): Insert into hash table also.\n\t(new_adjust): New.\n\t(reset_float_format, make_partial_integer_mode)\n\t(make_vector_mode): Tweak error reporting.\n\t(reset_float_format): Correct type of fourth argument.\n\t(emit_insn_modes_h): Add #defines to help make mode_size,\n\tmode_base_align, and real_format_for_mode conditionally const.\n\t(emit_mode_size, emit_mode_base_align): Use print_maybe_const_decl.\n\t(emit_real_format_for_mode): Likewise, but temporarily disabled.\n\t(emit_insn_modes_c): Call emit_mode_adjustments.\n\t(main): Initialize modes_by_name.\n\t* Makefile.in: Update dependencies.\n\t* machmode.def: Document EXPR arguments and new ADJUST_* statements.\n\t* machmode.h: Use CONST_MODE_SIZE and CONST_MODE_BASE_ALIGN in\n\tdeclarations of mode_size and mode_base_align.  Declare\n\tinit_adjust_machine_modes.\n\t* toplev.c (backend_init): Call init_adjust_machine_modes.\n\nFrom-SVN: r72534", "tree": {"sha": "904f83fb53c1f8a9c252a65c246a7ba6a8688cde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/904f83fb53c1f8a9c252a65c246a7ba6a8688cde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8eaca232b716d78395c3ddacb0484ee6148d141", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8eaca232b716d78395c3ddacb0484ee6148d141", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8eaca232b716d78395c3ddacb0484ee6148d141", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8eaca232b716d78395c3ddacb0484ee6148d141/comments", "author": null, "committer": null, "parents": [{"sha": "0f229b22bb0f6b0c24e0ef69e3f45368524748e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f229b22bb0f6b0c24e0ef69e3f45368524748e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f229b22bb0f6b0c24e0ef69e3f45368524748e3"}], "stats": {"total": 313, "additions": 260, "deletions": 53}, "files": [{"sha": "632cc39d1d16bdbe49624d5dd313f4ca183e7644", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8eaca232b716d78395c3ddacb0484ee6148d141/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8eaca232b716d78395c3ddacb0484ee6148d141/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8eaca232b716d78395c3ddacb0484ee6148d141", "patch": "@@ -1,8 +1,35 @@\n+2003-10-15  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* genmodes.c: Include hashtab.h.\n+\t(modes_by_name, hash_mode, eq_mode, struct mode_adjust)\n+\t(adj_bytesize, adj_alignment, adj_format, new_adjust)\n+\t(_ADD_ADJUST, ADJUST_BYTESIZE, ADJUST_ALIGNMENT, ADJUST_FORMAT)\n+\t(print_maybe_const_decl, emit_mode_adjustments): New.\n+\t(known_modes): Rename to modes.\n+\t(find_mode): Kill class argument; look up in hash table.\n+\t(new_mode): Insert into hash table also.\n+\t(new_adjust): New.\n+\t(reset_float_format, make_partial_integer_mode)\n+\t(make_vector_mode): Tweak error reporting.\n+\t(reset_float_format): Correct type of fourth argument.\n+\t(emit_insn_modes_h): Add #defines to help make mode_size,\n+\tmode_base_align, and real_format_for_mode conditionally const.\n+\t(emit_mode_size, emit_mode_base_align): Use print_maybe_const_decl.\n+\t(emit_real_format_for_mode): Likewise, but temporarily disabled.\n+\t(emit_insn_modes_c): Call emit_mode_adjustments.\n+\t(main): Initialize modes_by_name.\n+\t* Makefile.in: Update dependencies.\n+\t* machmode.def: Document EXPR arguments and new ADJUST_* statements.\n+\t* machmode.h: Use CONST_MODE_SIZE and CONST_MODE_BASE_ALIGN in\n+\tdeclarations of mode_size and mode_base_align.  Declare\n+\tinit_adjust_machine_modes.\n+\t* toplev.c (backend_init): Call init_adjust_machine_modes.\n+\n 2003-10-15  Olivier Hainque  <hainque@act-europe.fr>\n \n \t* genmodes.c (calc_wider_mode): Allocate enough room for all the\n \tentries we'll possibly assign in the sort buffer.\n-\t\n+\n 2003-10-15  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config.gcc (s390x-ibm-tpf*): New target.\n@@ -50,13 +77,13 @@\n \tNew functions.\n \t* config/s390/s390.h (PREDICATE_CODES): Add s390_alc_comparison\n \tand s390_slb_comparison.\n-\t* config/s390/s390.md (\"*adddi3_31\", \"*subdi3_31\"): Do not use on \n+\t* config/s390/s390.md (\"*adddi3_31\", \"*subdi3_31\"): Do not use on\n \tzSeries machines.\n \t(\"*adddi3_31z\", \"*subdi3_31z\"): New insns.\n \t(\"*adddi3_alc_cc\", \"*adddi3_alc\", \"*subdi3_slb_cc\", \"*subdi3_slb\",\n \t\"*addsi3_alc_cc\", \"*addsi3_alc\", \"*subsi3_slb_cc\", \"*subsi3_slb\"):\n \tNew insns.\n-\t\n+\n 2003-10-14  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* configure.in: Clean up some feedback echoes.\n@@ -76,7 +103,7 @@\n \n \t* config/s390/s390.md (\"muldf3\", \"*muldf3\", \"*muldf3_ibm\",\n \t\"mulsf3\", \"*mulsf3\", \"*mulsf3_ibm\"): Do not clobber CC.\n-\t(\"divdf3\", \"*divdf3\", \"*divdf3_ibm\", \"divsf3\", \"*divsf3\", \n+\t(\"divdf3\", \"*divdf3\", \"*divdf3_ibm\", \"divsf3\", \"*divsf3\",\n \t\"*divsf3_ibm\"): Likewise.\n \n 2003-10-14  Nathanael Nerode  <neroden@gcc.gnu.org>\n@@ -103,7 +130,7 @@\n \t* fixinc/inclhack.def (alpha_pthread_gcc): New fix.\n \t* fixinc/fixincl.x: Regenerate.\n \t* fixinc/tests/base/pthread.h [ALPHA_PTHREAD_GCC_CHECK]: New\n-\ttestcase. \n+\ttestcase.\n \tFixes PR bootstrap/9330.\n \n 2003-10-13  Eric Christopher  <echristo@redhat.com>"}, {"sha": "a05808d6fae49d7636f3716ff8e10ee0bce95675", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8eaca232b716d78395c3ddacb0484ee6148d141/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8eaca232b716d78395c3ddacb0484ee6148d141/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b8eaca232b716d78395c3ddacb0484ee6148d141", "patch": "@@ -2198,8 +2198,8 @@ genmodes$(build_exeext) : genmodes.o $(BUILD_ERRORS) $(BUILD_LIBDEPS)\n \t$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \\\n \t genmodes.o $(BUILD_ERRORS) $(BUILD_LIBS)\n \n-genmodes.o : genmodes.c $(BCONFIG_H) $(SYSTEM_H) errors.h machmode.def \\\n-\t     $(extra_modes_file)\n+genmodes.o : genmodes.c $(BCONFIG_H) $(SYSTEM_H) errors.h $(HASHTAB_H) \\\n+\t     machmode.def $(extra_modes_file)\n \n genpreds$(build_exeext) : genpreds.o $(BUILD_LIBDEPS)\n \t$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \\"}, {"sha": "6d32d708d629a709f97754ee04217b936fa69ec5", "filename": "gcc/genmodes.c", "status": "modified", "additions": 201, "deletions": 43, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8eaca232b716d78395c3ddacb0484ee6148d141/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8eaca232b716d78395c3ddacb0484ee6148d141/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=b8eaca232b716d78395c3ddacb0484ee6148d141", "patch": "@@ -22,6 +22,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"bconfig.h\"\n #include \"system.h\"\n #include \"errors.h\"\n+#include \"hashtab.h\"\n \n /* enum mode_class is normally defined by machmode.h but we can't\n    include that header here.  */\n@@ -68,7 +69,7 @@ struct mode_data\n   unsigned int line;\t\t/* for error reporting */\n };\n \n-static struct mode_data *known_modes[MAX_MODE_CLASS];\n+static struct mode_data *modes[MAX_MODE_CLASS];\n static unsigned int n_modes[MAX_MODE_CLASS];\n static struct mode_data *void_mode;\n \n@@ -79,6 +80,25 @@ static const struct mode_data blank_mode = {\n   \"<unknown>\", 0\n };\n \n+static htab_t modes_by_name;\n+\n+/* Data structure for recording target-specified runtime adjustments\n+   to a particular mode.  We support varying the byte size, the\n+   alignment, and the floating point format.  */\n+struct mode_adjust\n+{\n+  struct mode_adjust *next;\n+  struct mode_data *mode;\n+  const char *adjustment;\n+\n+  const char *file;\n+  unsigned int line;\n+};\n+\n+static struct mode_adjust *adj_bytesize;\n+static struct mode_adjust *adj_alignment;\n+static struct mode_adjust *adj_format;\n+\n /* Mode class operations.  */\n static enum mode_class\n complex_class (enum mode_class class)\n@@ -106,16 +126,14 @@ vector_class (enum mode_class class)\n     }\n }\n \n-static struct mode_data *\n-find_mode (enum mode_class class, const char *name)\n+/* Utility routines.  */\n+static inline struct mode_data *\n+find_mode (const char *name)\n {\n-  struct mode_data *m;\n+  struct mode_data key;\n \n-  for (m = known_modes[class]; m; m = m->next)\n-    if (!strcmp (name, m->name))\n-      return m;\n-\n-  return 0;\n+  key.name = name;\n+  return htab_find (modes_by_name, &key);\n }\n \n static struct mode_data *\n@@ -124,7 +142,7 @@ new_mode (enum mode_class class, const char *name,\n {\n   struct mode_data *m;\n \n-  m = find_mode (class, name);\n+  m = find_mode (name);\n   if (m)\n     {\n       error (\"%s:%d: duplicate definition of mode \\\"%s\\\"\",\n@@ -141,16 +159,79 @@ new_mode (enum mode_class class, const char *name,\n     m->file = trim_filename (file);\n   m->line = line;\n \n-  m->next = known_modes[class];\n-  known_modes[class] = m;\n+  m->next = modes[class];\n+  modes[class] = m;\n   n_modes[class]++;\n+\n+  *htab_find_slot (modes_by_name, m, INSERT) = m;\n+  \n   return m;\n }\n \n+static hashval_t\n+hash_mode (const void *p)\n+{\n+  const struct mode_data *m = (const struct mode_data *)p;\n+  return htab_hash_string (m->name);\n+}\n+\n+static int\n+eq_mode (const void *p, const void *q)\n+{\n+  const struct mode_data *a = (const struct mode_data *)p;\n+  const struct mode_data *b = (const struct mode_data *)q;\n+\n+  return !strcmp (a->name, b->name);\n+}\n+\n #define for_all_modes(C, M)\t\t\t\\\n   for (C = 0; C < MAX_MODE_CLASS; C++)\t\t\\\n-    for (M = known_modes[C]; M; M = M->next)\n+    for (M = modes[C]; M; M = M->next)\n+\n+static void ATTRIBUTE_UNUSED\n+new_adjust (const char *name,\n+\t    struct mode_adjust **category, const char *catname,\n+\t    const char *adjustment,\n+\t    enum mode_class required_class,\n+\t    const char *file, unsigned int line)\n+{\n+  struct mode_data *mode = find_mode (name);\n+  struct mode_adjust *a;\n+\n+  file = trim_filename (file);\n+\n+  if (!mode)\n+    {\n+      error (\"%s:%d: no mode \\\"%s\\\"\", file, line, name);\n+      return;\n+    }\n+\n+  if (required_class != MODE_RANDOM && mode->class != required_class)\n+    {\n+      error (\"%s:%d: mode \\\"%s\\\" is not class %s\",\n+\t     file, line, name, mode_class_names[required_class] + 5);\n+      return;\n+    }\n+  \n \n+  for (a = *category; a; a = a->next)\n+    if (a->mode == mode)\n+      {\n+\terror (\"%s:%d: mode \\\"%s\\\" already has a %s adjustment\",\n+\t       file, line, name, catname);\n+\terror (\"%s:%d: previous adjustment here\", a->file, a->line);\n+\treturn;\n+      }\n+\n+  a = xmalloc (sizeof (struct mode_adjust));\n+  a->mode = mode;\n+  a->adjustment = adjustment;\n+  a->file = file;\n+  a->line = line;\n+\n+  a->next = *category;\n+  *category = a;\n+}\n \n /* Diagnose failure to meet expectations in a partially filled out\n    mode structure.  */\n@@ -318,7 +399,7 @@ make_complex_modes (enum mode_class class,\n   if (cclass == MODE_RANDOM)\n     return;\n     \n-  for (m = known_modes[class]; m; m = m->next)\n+  for (m = modes[class]; m; m = m->next)\n     {\n       /* Skip BImode.  FIXME: BImode probably shouldn't be MODE_INT.  */\n       if (m->bitsize == 1)\n@@ -372,7 +453,7 @@ make_vector_modes (enum mode_class class, unsigned int width,\n   if (vclass == MODE_RANDOM)\n     return;\n \n-  for (m = known_modes[class]; m; m = m->next)\n+  for (m = modes[class]; m; m = m->next)\n     {\n       /* Do not construct vector modes with only one element, or\n \t vector modes where the element size doesn't divide the full\n@@ -451,12 +532,17 @@ make_float_mode (const char *name,\n   reset_float_format (#N, #F, __FILE__, __LINE__)\n static void ATTRIBUTE_UNUSED\n reset_float_format (const char *name, const char *format,\n-\t\t    const char *file, const char *line)\n+\t\t    const char *file, unsigned int line)\n {\n-  struct mode_data *m = find_mode (MODE_FLOAT, name);\n+  struct mode_data *m = find_mode (name);\n   if (!m)\n     {\n-      error (\"%s:%d: no mode \\\"%s\\\" in class FLOAT\", file, line, name);\n+      error (\"%s:%d: no mode \\\"%s\\\"\", file, line, name);\n+      return;\n+    }\n+  if (m->class != MODE_FLOAT)\n+    {\n+      error (\"%s:%d: mode \\\"%s\\\" is not class FLOAT\", file, line, name);\n       return;\n     }\n   m->format = format;\n@@ -472,10 +558,15 @@ make_partial_integer_mode (const char *base, const char *name,\n \t\t\t   const char *file, unsigned int line)\n {\n   struct mode_data *m;\n-  struct mode_data *component = find_mode (MODE_INT, base);\n+  struct mode_data *component = find_mode (base);\n   if (!component)\n     {\n-      error (\"%s:%d: no mode \\\"%s\\\" in class INT\", file, line, name);\n+      error (\"%s:%d: no mode \\\"%s\\\"\", file, line, name);\n+      return;\n+    }\n+  if (component->class != MODE_INT)\n+    {\n+      error (\"%s:%d: mode \\\"%s\\\" is not class INT\", file, line, name);\n       return;\n     }\n   \n@@ -496,14 +587,19 @@ make_vector_mode (enum mode_class bclass,\n {\n   struct mode_data *v;\n   enum mode_class vclass = vector_class (bclass);\n-  struct mode_data *component = find_mode (bclass, base);\n+  struct mode_data *component = find_mode (base);\n   char namebuf[8];\n \n   if (vclass == MODE_RANDOM)\n     return;\n   if (component == 0)\n     {\n-      error (\"%s:%d: no mode \\\"%s\\\" in class %s\",\n+      error (\"%s:%d: no mode \\\"%s\\\"\", file, line, base);\n+      return;\n+    }\n+  if (component->class != bclass)\n+    {\n+      error (\"%s:%d: mode \\\"%s\\\" is not class %s\",\n \t     file, line, base, mode_class_names[bclass] + 5);\n       return;\n     }\n@@ -520,7 +616,14 @@ make_vector_mode (enum mode_class bclass,\n   v->ncomponents = ncomponents;\n   v->component = component;\n }\n-  \n+\n+/* Adjustability.  */\n+#define _ADD_ADJUST(A, M, X, C) \\\n+  new_adjust (#M, &adj_##A, #A, #X, MODE_##C, __FILE__, __LINE__)\n+\n+#define ADJUST_BYTESIZE(M, X)  _ADD_ADJUST(bytesize, M, X, RANDOM)\n+#define ADJUST_ALIGNMENT(M, X) _ADD_ADJUST(alignment, M, X, RANDOM)\n+#define ADJUST_FLOAT_FORMAT(M, X)    _ADD_ADJUST(format, M, X, FLOAT)\n \n static void\n create_modes (void)\n@@ -600,7 +703,7 @@ calc_wider_mode (void)\n \t{\n \t  struct mode_data *prev, *next;\n \n-\t  for (prev = 0, m = known_modes[c]; m; m = next)\n+\t  for (prev = 0, m = modes[c]; m; m = next)\n \t    {\n \t      m->wider = void_mode;\n \n@@ -609,14 +712,14 @@ calc_wider_mode (void)\n \t      m->next = prev;\n \t      prev = m;\n \t    }\n-\t  known_modes[c] = prev;\n+\t  modes[c] = prev;\n \t}\n       else\n \t{\n-\t  if (!known_modes[c])\n+\t  if (!modes[c])\n \t    continue;\n \n-\t  for (i = 0, m = known_modes[c]; m; i++, m = m->next)\n+\t  for (i = 0, m = modes[c]; m; i++, m = m->next)\n \t    sortbuf[i] = m;\n \n \t  qsort (sortbuf, i, sizeof (struct mode_data *), cmp_modes);\n@@ -626,7 +729,7 @@ calc_wider_mode (void)\n \t    sortbuf[j]->next = sortbuf[j]->wider = sortbuf[j + 1];\n \n \n-\t  known_modes[c] = sortbuf[0];\n+\t  modes[c] = sortbuf[0];\n \t}\n     }\n }\n@@ -640,7 +743,11 @@ calc_wider_mode (void)\n } while (0)\n \n #define print_decl(TYPE, NAME, ASIZE) \\\n-  printf (\"\\nconst %s %s[%s] =\\n{\\n\", TYPE, NAME, ASIZE);\n+  puts (\"\\nconst \" TYPE \" \" NAME \"[\" ASIZE \"] =\\n{\");\n+\n+#define print_maybe_const_decl(TYPE, NAME, ASIZE, CATEGORY)\t\\\n+  printf (\"\\n\" TYPE \" \" NAME \"[\" ASIZE \"] = \\n{\\n\",\t\t\\\n+\t  adj_##CATEGORY ? \"\" : \"const \")\n \n #define print_closer() puts (\"};\")\n \n@@ -663,7 +770,7 @@ emit_insn_modes_h (void)\n enum machine_mode\\n{\");\n \n   for (c = 0; c < MAX_MODE_CLASS; c++)\n-    for (m = known_modes[c]; m; m = m->next)\n+    for (m = modes[c]; m; m = m->next)\n       {\n \tint count_;\n \tprintf (\"  %smode,%n\", m->name, &count_);\n@@ -675,7 +782,7 @@ enum machine_mode\\n{\");\n \n   for (c = 0; c < MAX_MODE_CLASS; c++)\n     {\n-      first = known_modes[c];\n+      first = modes[c];\n       last = 0;\n       for (m = first; m; last = m, m = m->next)\n \t;\n@@ -699,7 +806,15 @@ enum machine_mode\\n{\");\n \n   puts (\"\\\n   NUM_MACHINE_MODES = MAX_MACHINE_MODE\\n\\\n-};\\n\\\n+};\\n\");\n+\n+  /* I can't think of a better idea, can you?  */\n+  printf (\"#define CONST_MODE_SIZE%s\\n\", adj_bytesize ? \"\" : \" const\");\n+  printf (\"#define CONST_MODE_BASE_ALIGN%s\\n\", adj_alignment ? \"\" : \" const\");\n+#if 0 /* disabled for backward compatibility, temporary */\n+  printf (\"#define CONST_REAL_FORMAT_FOR_MODE%s\\n\", adj_format ? \"\" :\" const\");\n+#endif\n+  puts (\"\\\n \\n\\\n #endif /* insn-modes.h */\");\n }\n@@ -788,7 +903,8 @@ emit_mode_size (void)\n   enum mode_class c;\n   struct mode_data *m;\n \n-  print_decl (\"unsigned char\", \"mode_size\", \"NUM_MACHINE_MODES\");\n+  print_maybe_const_decl (\"%sunsigned char\", \"mode_size\",\n+\t\t\t  \"NUM_MACHINE_MODES\", bytesize);\n \n   for_all_modes (c, m)\n     tagged_printf (\"%u\", m->bytesize, m->name);\n@@ -875,7 +991,9 @@ emit_mode_base_align (void)\n   enum mode_class c;\n   struct mode_data *m;\n \n-  print_decl (\"unsigned char\", \"mode_base_align\", \"NUM_MACHINE_MODES\");\n+  print_maybe_const_decl (\"%sunsigned char\",\n+\t\t\t  \"mode_base_align\", \"NUM_MACHINE_MODES\",\n+\t\t\t  alignment);\n \n   for_all_modes (c, m)\n     tagged_printf (\"%u\", m->alignment, m->name);\n@@ -893,11 +1011,11 @@ emit_class_narrowest_mode (void)\n   for (c = 0; c < MAX_MODE_CLASS; c++)\n     /* Bleah, all this to get the comment right for MIN_MODE_INT.  */\n     tagged_printf (\"MIN_%s\", mode_class_names[c],\n-\t\t   known_modes[c]\n-\t\t   ? (known_modes[c]->bitsize != 1\n-\t\t      ? known_modes[c]->name\n-\t\t      : (known_modes[c]->next\n-\t\t\t ? known_modes[c]->next->name\n+\t\t   modes[c]\n+\t\t   ? (modes[c]->bitsize != 1\n+\t\t      ? modes[c]->name\n+\t\t      : (modes[c]->next\n+\t\t\t ? modes[c]->next->name\n \t\t\t : void_mode->name))\n \t\t   : void_mode->name);\n   \n@@ -909,12 +1027,23 @@ emit_real_format_for_mode (void)\n {\n   struct mode_data *m;\n \n-  /* This will produce a table which is not constant, but points to\n-     entities that are constant, which is what we want.  */\n-  print_decl (\"struct real_format *\\n \", \"real_format_for_mode\",\n+  /* The entities pointed to by this table are constant, whether\n+     or not the table itself is constant.\n+\n+     For backward compatibility this table is always writable\n+     (several targets modify it in OVERRIDE_OPTIONS).   FIXME:\n+     convert all said targets to use ADJUST_FORMAT instead.  */\n+#if 0\n+  print_maybe_const_decl (\"const struct real_format *%s\",\n+\t\t\t  \"real_format_for_mode\",\n+\t\t\t  \"MAX_MODE_FLOAT - MIN_MODE_FLOAT + 1\",\n+\t\t\t  format);\n+#else\n+  print_decl (\"struct real_format *\\n\", \"real_format_for_mode\",\n \t      \"MAX_MODE_FLOAT - MIN_MODE_FLOAT + 1\");\n+#endif\n \n-  for (m = known_modes[MODE_FLOAT]; m; m = m->next)\n+  for (m = modes[MODE_FLOAT]; m; m = m->next)\n     if (!strcmp (m->format, \"0\"))\n       tagged_printf (\"%s\", m->format, m->name);\n     else\n@@ -923,6 +1052,32 @@ emit_real_format_for_mode (void)\n   print_closer ();\n }\n \n+static void\n+emit_mode_adjustments (void)\n+{\n+  struct mode_adjust *a;\n+\n+  puts (\"\\nvoid\\ninit_adjust_machine_modes (void)\\n{\");\n+\n+  for (a = adj_bytesize; a; a = a->next)\n+    printf (\"  /* %s:%d */\\n  mode_size[%smode] = %s;\\n\",\n+\t    a->file, a->line, a->mode->name, a->adjustment);\n+  if (adj_bytesize && (adj_alignment || adj_format))\n+    putchar ('\\n');\n+\n+  for (a = adj_alignment; a; a = a->next)\n+    printf (\"  /* %s:%d */\\n  mode_base_align[%smode] = %s;\\n\",\n+\t    a->file, a->line, a->mode->name, a->adjustment);\n+  if (adj_alignment && adj_format)\n+    putchar ('\\n');\n+\n+  for (a = adj_format; a; a = a->next)\n+    printf (\"  /* %s:%d */\\n  REAL_MODE_FORMAT (%smode) = %s;\\n\",\n+\t    a->file, a->line, a->mode->name, a->adjustment);\n+\n+  puts (\"}\");\n+}\n+\n static void\n emit_insn_modes_c (void)\n {\n@@ -938,6 +1093,7 @@ emit_insn_modes_c (void)\n   emit_mode_base_align ();\n   emit_class_narrowest_mode ();\n   emit_real_format_for_mode ();\n+  emit_mode_adjustments ();\n }\n \n static void\n@@ -969,6 +1125,8 @@ main(int argc, char **argv)\n       return FATAL_EXIT_CODE;\n     }\n \n+  modes_by_name = htab_create_alloc (64, hash_mode, eq_mode, 0, xcalloc, free);\n+\n   create_modes ();\n   complete_all_modes ();\n "}, {"sha": "0b762497d0092bd2973baf2e4d724db26aceb061", "filename": "gcc/machmode.def", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8eaca232b716d78395c3ddacb0484ee6148d141/gcc%2Fmachmode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8eaca232b716d78395c3ddacb0484ee6148d141/gcc%2Fmachmode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.def?ref=b8eaca232b716d78395c3ddacb0484ee6148d141", "patch": "@@ -51,7 +51,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    constant.\n \n    A FORMAT argument must be one of the real_mode_format structures\n-   declared in real.h, or else a literal 0.\n+   declared in real.h, or else a literal 0.  Do not put a leading &\n+   on the argument.\n+\n+   An EXPR argument must be a syntactically valid C expression.\n+   If an EXPR contains commas, you may need to write an extra pair of\n+   parentheses around it, so it appears to be a single argument to the\n+   statement.\n \n    This file defines only those modes which are of use on almost all\n    machines.  Other modes can be defined in the target-specific\n@@ -120,6 +126,17 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \terror if there is no 'F'.  For INT modes, the names are\n \tderived by prefixing a C to the name.\n \n+     ADJUST_BYTESIZE (MODE, EXPR);\n+     ADJUST_ALIGNMENT (MODE, EXPR);\n+     ADJUST_FLOAT_FORMAT (MODE, EXPR);\n+        Arrange for the byte size, alignment, or floating point format\n+\tof MODE to be adjustable at run time.  EXPR will be executed\n+\tonce after processing all command line options, and should\n+\tevaluate to the desired byte size, alignment, or format.\n+\n+\tUnlike a FORMAT argument, if you are adjusting a float format\n+\tyou must put an & in front of the name of each format structure.\n+\n    Note: If a mode is ever made which is more than 255 bytes wide,\n    machmode.h and genmodes.c will have to be changed to allocate\n    more space for the mode_size and mode_alignment arrays.  */"}, {"sha": "c8c63c7a9e442e3126fe2b6407413293d3c7eb1b", "filename": "gcc/machmode.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8eaca232b716d78395c3ddacb0484ee6148d141/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8eaca232b716d78395c3ddacb0484ee6148d141/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=b8eaca232b716d78395c3ddacb0484ee6148d141", "patch": "@@ -78,7 +78,7 @@ extern const unsigned char mode_class[NUM_MACHINE_MODES];\n \n /* Get the size in bytes of an object of mode MODE.  */\n \n-extern const unsigned char mode_size[NUM_MACHINE_MODES];\n+extern CONST_MODE_SIZE unsigned char mode_size[NUM_MACHINE_MODES];\n #define GET_MODE_SIZE(MODE)   mode_size[MODE]\n \n /* Get the size in bytes of the basic parts of an object of mode MODE.  */\n@@ -139,7 +139,7 @@ extern enum machine_mode get_best_mode (int, int, unsigned int,\n \n /* Determine alignment, 1<=result<=BIGGEST_ALIGNMENT.  */\n \n-extern const unsigned char mode_base_align[NUM_MACHINE_MODES];\n+extern CONST_MODE_BASE_ALIGN unsigned char mode_base_align[NUM_MACHINE_MODES];\n \n extern unsigned get_mode_alignment (enum machine_mode);\n \n@@ -157,4 +157,7 @@ extern enum machine_mode byte_mode;\n extern enum machine_mode word_mode;\n extern enum machine_mode ptr_mode;\n \n+/* Target-dependent machine mode initialization - in insn-modes.c.  */\n+extern void init_adjust_machine_modes (void);\n+\n #endif /* not HAVE_MACHINE_MODES */"}, {"sha": "e711135476ae96a8b185e842916ea2e68a30f2f9", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8eaca232b716d78395c3ddacb0484ee6148d141/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8eaca232b716d78395c3ddacb0484ee6148d141/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=b8eaca232b716d78395c3ddacb0484ee6148d141", "patch": "@@ -4365,6 +4365,8 @@ process_options (void)\n static void\n backend_init (void)\n {\n+  init_adjust_machine_modes ();\n+\n   init_emit_once (debug_info_level == DINFO_LEVEL_NORMAL\n \t\t  || debug_info_level == DINFO_LEVEL_VERBOSE\n #ifdef VMS_DEBUGGING_INFO"}]}