{"sha": "bd9cc42bb85bef57fb5ae6639599966c3b0468b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ5Y2M0MmJiODViZWY1N2ZiNWFlNjYzOTU5OTk2NmMzYjA0NjhiNg==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-11-15T16:20:21Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-11-15T16:20:21Z"}, "message": "re PR tree-optimization/82726 (ICE in verify_ssa during GIMPLE pass: pcom)\n\n\tPR tree-optimization/82726\n\tPR tree-optimization/70754\n\t* tree-predcom.c (order_drefs_by_pos): New function.\n\t(combine_chains): Move code setting has_max_use_after to...\n\t(try_combine_chains): ...here.  New parameter.  Sort combined chains\n\taccording to position information.\n\t(tree_predictive_commoning_loop): Update call to above function.\n\t(update_pos_for_combined_chains, pcom_stmt_dominates_stmt_p): New.\n\n\tgcc/testsuite\n\t* gcc.dg/tree-ssa/pr82726.c: New test.\n\nFrom-SVN: r254778", "tree": {"sha": "8f38aed8816aca0212a905bb05b8b259d3978ab4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f38aed8816aca0212a905bb05b8b259d3978ab4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd9cc42bb85bef57fb5ae6639599966c3b0468b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd9cc42bb85bef57fb5ae6639599966c3b0468b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd9cc42bb85bef57fb5ae6639599966c3b0468b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd9cc42bb85bef57fb5ae6639599966c3b0468b6/comments", "author": null, "committer": null, "parents": [{"sha": "1ad3d8aa05a6668ddfa70fe5118626413d5087ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ad3d8aa05a6668ddfa70fe5118626413d5087ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ad3d8aa05a6668ddfa70fe5118626413d5087ba"}], "stats": {"total": 181, "additions": 165, "deletions": 16}, "files": [{"sha": "3807073525e65d1bc3b1317ba0176922780dbca1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd9cc42bb85bef57fb5ae6639599966c3b0468b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd9cc42bb85bef57fb5ae6639599966c3b0468b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd9cc42bb85bef57fb5ae6639599966c3b0468b6", "patch": "@@ -1,3 +1,20 @@\n+2017-11-15  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/82726\n+\tPR tree-optimization/70754\n+\t* tree-predcom.c (order_drefs_by_pos): New function.\n+\t(combine_chains): Move code setting has_max_use_after to...\n+\t(try_combine_chains): ...here.  New parameter.  Sort combined chains\n+\taccording to position information.\n+\t(tree_predictive_commoning_loop): Update call to above function.\n+\t(update_pos_for_combined_chains, pcom_stmt_dominates_stmt_p): New.\n+\n+gcc/testsuite\n+2017-11-15  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/82726\n+\t* gcc.dg/tree-ssa/pr82726.c: New test.\n+\n 2017-11-15  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR tree-optimization/82726"}, {"sha": "22bc59dacc8fab653a692f20529f33c0139b83cd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr82726.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd9cc42bb85bef57fb5ae6639599966c3b0468b6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr82726.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd9cc42bb85bef57fb5ae6639599966c3b0468b6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr82726.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr82726.c?ref=bd9cc42bb85bef57fb5ae6639599966c3b0468b6", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 --param tree-reassoc-width=4\" } */\n+/* { dg-additional-options \"-mavx2\" { target { x86_64-*-* i?86-*-* } } } */\n+\n+#define N 40\n+#define M 128\n+unsigned int in[N+M];\n+unsigned short out[N];\n+\n+/* Outer-loop vectorization. */\n+\n+void\n+foo (){\n+  int i,j;\n+  unsigned int diff;\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < M; j+=8) {\n+      diff += in[j+i];\n+    }\n+    out[i]=(unsigned short)diff;\n+  }\n+\n+  return;\n+}"}, {"sha": "747c1b82d3724c284f9dd68328acbc0ec7938db6", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 122, "deletions": 16, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd9cc42bb85bef57fb5ae6639599966c3b0468b6/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd9cc42bb85bef57fb5ae6639599966c3b0468b6/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=bd9cc42bb85bef57fb5ae6639599966c3b0468b6", "patch": "@@ -1020,6 +1020,17 @@ order_drefs (const void *a, const void *b)\n   return (*da)->pos - (*db)->pos;\n }\n \n+/* Compares two drefs A and B by their position.  Callback for qsort.  */\n+\n+static int\n+order_drefs_by_pos (const void *a, const void *b)\n+{\n+  const dref *const da = (const dref *) a;\n+  const dref *const db = (const dref *) b;\n+\n+  return (*da)->pos - (*db)->pos;\n+}\n+\n /* Returns root of the CHAIN.  */\n \n static inline dref\n@@ -2640,7 +2651,6 @@ combine_chains (chain_p ch1, chain_p ch2)\n   bool swap = false;\n   chain_p new_chain;\n   unsigned i;\n-  gimple *root_stmt;\n   tree rslt_type = NULL_TREE;\n \n   if (ch1 == ch2)\n@@ -2682,31 +2692,55 @@ combine_chains (chain_p ch1, chain_p ch2)\n       new_chain->refs.safe_push (nw);\n     }\n \n-  new_chain->has_max_use_after = false;\n-  root_stmt = get_chain_root (new_chain)->stmt;\n-  for (i = 1; new_chain->refs.iterate (i, &nw); i++)\n-    {\n-      if (nw->distance == new_chain->length\n-\t  && !stmt_dominates_stmt_p (nw->stmt, root_stmt))\n-\t{\n-\t  new_chain->has_max_use_after = true;\n-\t  break;\n-\t}\n-    }\n-\n   ch1->combined = true;\n   ch2->combined = true;\n   return new_chain;\n }\n \n-/* Try to combine the CHAINS.  */\n+/* Recursively update position information of all offspring chains to ROOT\n+   chain's position information.  */\n+\n+static void\n+update_pos_for_combined_chains (chain_p root)\n+{\n+  chain_p ch1 = root->ch1, ch2 = root->ch2;\n+  dref ref, ref1, ref2;\n+  for (unsigned j = 0; (root->refs.iterate (j, &ref)\n+\t\t\t&& ch1->refs.iterate (j, &ref1)\n+\t\t\t&& ch2->refs.iterate (j, &ref2)); ++j)\n+    ref1->pos = ref2->pos = ref->pos;\n+\n+  if (ch1->type == CT_COMBINATION)\n+    update_pos_for_combined_chains (ch1);\n+  if (ch2->type == CT_COMBINATION)\n+    update_pos_for_combined_chains (ch2);\n+}\n+\n+/* Returns true if statement S1 dominates statement S2.  */\n+\n+static bool\n+pcom_stmt_dominates_stmt_p (gimple *s1, gimple *s2)\n+{\n+  basic_block bb1 = gimple_bb (s1), bb2 = gimple_bb (s2);\n+\n+  if (!bb1 || s1 == s2)\n+    return true;\n+\n+  if (bb1 == bb2)\n+    return gimple_uid (s1) < gimple_uid (s2);\n+\n+  return dominated_by_p (CDI_DOMINATORS, bb2, bb1);\n+}\n+\n+/* Try to combine the CHAINS in LOOP.  */\n \n static void\n-try_combine_chains (vec<chain_p> *chains)\n+try_combine_chains (struct loop *loop, vec<chain_p> *chains)\n {\n   unsigned i, j;\n   chain_p ch1, ch2, cch;\n   auto_vec<chain_p> worklist;\n+  bool combined_p = false;\n \n   FOR_EACH_VEC_ELT (*chains, i, ch1)\n     if (chain_can_be_combined_p (ch1))\n@@ -2728,6 +2762,78 @@ try_combine_chains (vec<chain_p> *chains)\n \t    {\n \t      worklist.safe_push (cch);\n \t      chains->safe_push (cch);\n+\t      combined_p = true;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  if (!combined_p)\n+    return;\n+\n+  /* Setup UID for all statements in dominance order.  */\n+  basic_block *bbs = get_loop_body (loop);\n+  renumber_gimple_stmt_uids_in_blocks (bbs, loop->num_nodes);\n+  free (bbs);\n+\n+  /* Re-association in combined chains may generate statements different to\n+     order of references of the original chain.  We need to keep references\n+     of combined chain in dominance order so that all uses will be inserted\n+     after definitions.  Note:\n+       A) This is necessary for all combined chains.\n+       B) This is only necessary for ZERO distance references because other\n+\t  references inherit value from loop carried PHIs.\n+\n+     We first update position information for all combined chains.  */\n+  dref ref;\n+  for (i = 0; chains->iterate (i, &ch1); ++i)\n+    {\n+      if (ch1->type != CT_COMBINATION || ch1->combined)\n+\tcontinue;\n+\n+      for (j = 0; ch1->refs.iterate (j, &ref); ++j)\n+\tref->pos = gimple_uid (ref->stmt);\n+\n+      update_pos_for_combined_chains (ch1);\n+    }\n+  /* Then sort references according to newly updated position information.  */\n+  for (i = 0; chains->iterate (i, &ch1); ++i)\n+    {\n+      if (ch1->type != CT_COMBINATION && !ch1->combined)\n+\tcontinue;\n+\n+      /* Find the first reference with non-ZERO distance.  */\n+      if (ch1->length == 0)\n+\tj = ch1->refs.length();\n+      else\n+\t{\n+\t  for (j = 0; ch1->refs.iterate (j, &ref); ++j)\n+\t    if (ref->distance != 0)\n+\t      break;\n+\t}\n+\n+      /* Sort all ZERO distance references by position.  */\n+      qsort (&ch1->refs[0], j, sizeof (ch1->refs[0]), order_drefs_by_pos);\n+\n+      if (ch1->combined)\n+\tcontinue;\n+\n+      /* For ZERO length chain, has_max_use_after must be true since root\n+\t combined stmt must dominates others.  */\n+      if (ch1->length == 0)\n+\t{\n+\t  ch1->has_max_use_after = true;\n+\t  continue;\n+\t}\n+      /* Check if there is use at max distance after root for combined chains\n+\t and set flag accordingly.  */\n+      ch1->has_max_use_after = false;\n+      gimple *root_stmt = get_chain_root (ch1)->stmt;\n+      for (j = 1; ch1->refs.iterate (j, &ref); ++j)\n+\t{\n+\t  if (ref->distance == ch1->length\n+\t      && !pcom_stmt_dominates_stmt_p (ref->stmt, root_stmt))\n+\t    {\n+\t      ch1->has_max_use_after = true;\n \t      break;\n \t    }\n \t}\n@@ -3065,7 +3171,7 @@ tree_predictive_commoning_loop (struct loop *loop)\n   loop_closed_ssa = prepare_finalizers (loop, chains);\n \n   /* Try to combine the chains that are always worked with together.  */\n-  try_combine_chains (&chains);\n+  try_combine_chains (loop, &chains);\n \n   insert_init_seqs (loop, chains);\n "}]}