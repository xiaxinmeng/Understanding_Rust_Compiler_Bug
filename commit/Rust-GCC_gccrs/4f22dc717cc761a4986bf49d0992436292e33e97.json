{"sha": "4f22dc717cc761a4986bf49d0992436292e33e97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGYyMmRjNzE3Y2M3NjFhNDk4NmJmNDlkMDk5MjQzNjI5MmUzM2U5Nw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-15T20:22:24Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-15T20:22:24Z"}, "message": "Initial revision\n\nFrom-SVN: r989", "tree": {"sha": "f75ae73a9fc37a828242e300b13a070c43e1b7f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f75ae73a9fc37a828242e300b13a070c43e1b7f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f22dc717cc761a4986bf49d0992436292e33e97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f22dc717cc761a4986bf49d0992436292e33e97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f22dc717cc761a4986bf49d0992436292e33e97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f22dc717cc761a4986bf49d0992436292e33e97/comments", "author": null, "committer": null, "parents": [{"sha": "7119d10c0468b3c022a258e33405367561279e56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7119d10c0468b3c022a258e33405367561279e56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7119d10c0468b3c022a258e33405367561279e56"}], "stats": {"total": 296, "additions": 296, "deletions": 0}, "files": [{"sha": "d23f2f6b94d976efb699d70d0f8aa634f71e5baa", "filename": "gcc/config/i860/fx2800.h", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f22dc717cc761a4986bf49d0992436292e33e97/gcc%2Fconfig%2Fi860%2Ffx2800.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f22dc717cc761a4986bf49d0992436292e33e97/gcc%2Fconfig%2Fi860%2Ffx2800.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Ffx2800.h?ref=4f22dc717cc761a4986bf49d0992436292e33e97", "patch": "@@ -0,0 +1,296 @@\n+/* Target definitions for GNU compiler for Alliant FX/2800\n+   running Concentrix 2.2\n+\n+   Copyright (C) 1991 Free Software Foundation, Inc.\n+\n+   Written by Howard Chu (hyc@hanauma.jpl.nasa.gov).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"i860v4.h\"\n+\n+/* The Alliant fx2800 running Concentrix 2.x is weird.  This is basically\n+   a BSD 4.3 based operating system, but it uses svr4 ELF format object\n+   files and it somehow puts BSD stabs records into the ELF files for\n+   symbolic debug information.  The assembler is \"mostly an SVR4 assembler\n+   with some Alliant additions. We based it on the `Intel 80860 Assembly\n+   Language Specification' from AT&T.\" */\n+\n+/* This file consists of three sections. The first section establishes\n+   definitions unique to the Alliant FX/2800. The next section reconciles\n+   differences between Alliant and i860v4.h, and the last overrides the\n+   remaining differences with svr4.h */\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (i860 Alliant)\");\n+\n+/* atexit is not present prior to Concentrix 2.2. Uncomment the following\n+   if you're on 2.1 or older. */\n+ \n+/* #undef HAVE_ATEXIT */\n+\n+/* Most of the Alliant-specific definitions here are to get stab info that\n+   Alliant's dbx can understand. */\n+\n+#define DBX_DEBUGGING_INFO\n+#define DEFAULT_GDB_EXTENSIONS 0\n+#define DBX_NO_XREFS\n+#define DBX_NO_EXTRA_TAGS\n+\n+/* Alliant dbx also needs to see the function stab before anything\n+   else in the function. */\n+\n+#define DBX_FUNCTION_FIRST\n+#define DBX_LBRAC_FIRST\n+\n+/* Alliant dbx also needs to see the end of a function somewhere. */\n+\n+#define DBX_OUTPUT_FUNCTION_END(file,decl)\t\\\n+\tfprintf (file, \".stab \\\"\\\",.,0x%x,0,0\\n\", N_EFUN)\n+\n+/* Alliant dbx has predefined types, so they must be emitted with the\n+   proper type numbers. The defined types are:\n+\n+     Type #\tC, Fortran, Pascal Types\n+\t--\t------------------------\n+\t 1\tchar, integer*1\n+\t 2\tshort, \tinteger*2\n+\t 3\tint, long, integer*4, integer\n+\t 4\tlogical*1, byte\n+\t 5\tlogical*2\n+\t 6\tlogical*4, logical\n+\t 7\tfloat, real*4, \treal\n+\t 8\tdouble, real*8,\tdouble\n+\t 9\tsingle complex, complex*8, complex\n+\t10\tdouble complex, doublecomplex\n+\t11\tcharacter\n+\t12\tvoid\n+\t13\tnil\n+\t14\tboolean\n+\t15\tunsigned char, ubyte\n+\t16\tunsigned short, uword\n+\t17\tunsigned, unsigned int, unsigned long, ulong\n+\t18\tquad, logical*8\n+\t19\tlong long, integer*8\n+\t20\tunsigned long long, uquad*8\n+    21-100\treserved for future predefined types\n+\t100\tlong redefine same as 3\n+\t101\tunsigned long same as 17\n+\t--\t--------------------\n+\t102\tFirst user program type\n+\n+   Since long and unsigned long are int references, they must be handled\n+   as special cases. The Alliant compiler doesn't use types 18-20, so it\n+   sets long & unsigned long in 18 & 19, not in 100 & 101 as shown above. */\n+\n+#define DBX_OUTPUT_STANDARD_TYPES(syms)\t\\\n+{ char *dtyps[]={\"\", \"char\", \"short int\", \"int\", \"logical*1\",\t\t\\\n+\t\"logical*2\", \"logical*4\", \"float\", \"double\", \"complex\",\t\t\\\n+\t\"doublecomplex\", \"character\", \"void\", \"nil\", \"boolean\",\t\t\\\n+\t\"unsigned char\", \"short unsigned int\", \"unsigned int\",\t\t\\\n+\t\"logical*8\", \"long long int\", \"long long unsigned int\",\"\"};\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  tree decl;\t\t\t\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  for (i=1;*dtyps[i];i++) {\t\t\t\t\t\t\\\n+\tdecl = IDENTIFIER_GLOBAL_VALUE (get_identifier (dtyps[i]));\t\\\n+\tif (decl) {\t\t\t\t\t\t\t\\\n+\t\tTYPE_SYMTAB_ADDRESS (TREE_TYPE (decl)) = i;\t\t\\\n+\t\ttypevec[i] = TYPE_DEFINED;\t\t\t\t\\\n+\t\tdbxout_symbol (decl, 0);\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  decl = IDENTIFIER_GLOBAL_VALUE (get_identifier (\"long int\"));\t\t\\\n+  TYPE_SYMTAB_ADDRESS (TREE_TYPE (decl)) = i;\t\t\t\t\\\n+  typevec[i] = TYPE_DEFINED;\t\t\t\t\t\t\\\n+  fprintf(asmfile,\".stab \\\"long int:t%d=3\\\",0,0x%x,0,0\\n\",i++,N_LSYM);\t\\\n+  TREE_ASM_WRITTEN (decl) = 1;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  decl = IDENTIFIER_GLOBAL_VALUE (get_identifier (\"long unsigned int\"));\\\n+  TYPE_SYMTAB_ADDRESS (TREE_TYPE (decl)) = i;\t\t\t\t\\\n+  typevec[i] = TYPE_DEFINED;\t\t\t\t\t\t\\\n+  fprintf(asmfile,\".stab \\\"long unsigned int:t%d=17\\\",0,0x%x,0,0\\n\",i++,N_LSYM);\\\n+  TREE_ASM_WRITTEN (decl) = 1;\t\t\t\t\t\t\\\n+  next_type_number = i; };\n+\n+/* Alliant dbx doesn't understand split names... */\n+\n+#define DBX_CONTIN_LENGTH 0\n+\n+/* The syntax for stabs records is also different; there is only a single\n+   \".stab\" directive instead of the 3 directives in BSD, and the order of\n+   arguments is slightly changed. */\n+\n+#define ASM_STABS_OP\t\".stab\"\n+#define ASM_STABN_OP\t\".stab\"\n+#define ASM_STABD_OP\t\".stab\"\n+\n+#define DBX_MEMPARM_STABS_LETTER 'k'\n+#define DBX_REGPARM_STABS_LETTER 'r'\n+\n+#define ASM_OUTPUT_SOURCE_LINE(file,num)\t\t\\\n+\tfprintf (file, \"\\t.stab \\\"\\\",.,0x%x,0,%d\\n\",\t\\\n+\t\tN_SLINE,num)\n+\n+#if 0\t/* Alliant dbx only reads first N_SO, so it\n+\t   ignores the filename if dir is present. */\n+#define DBX_OUTPUT_MAIN_SOURCE_DIRECTORY(file,name)\t\t\\\n+\tfprintf (file, \".stab \\\"%s/\\\",.Ltext0,0x%x,0,0\\n\",\t\\\n+\t\tname, N_SO)\n+#else\n+#define DBX_OUTPUT_MAIN_SOURCE_DIRECTORY(file,name)\n+#endif\n+\n+#define DBX_OUTPUT_MAIN_SOURCE_FILENAME(file,name)\t\t\\\n+\tfprintf (file, \".stab \\\"%s\\\",.Ltext0,0x%x,0,0\\n\",\t\\\n+\t\tname, N_SO);\t\t\t\t\t\\\n+\ttext_section ();\t\t\t\t\t\\\n+\tASM_OUTPUT_INTERNAL_LABEL (file, \"Ltext\", 0)\n+\n+#define DBX_OUTPUT_SOURCE_FILENAME(file,name)\t\t\t\\\n+\tfprintf (file, \".stab \\\"%s\\\",.Ltext0,0x%x,0,0\\n\",\t\\\n+\t\tname, N_SOL);\n+\n+#define DBX_OUTPUT_CONSTANT_SYMBOL(file,name,ival)\t\t\\\n+\tfprintf (file, \".stab \\\"%s:c=i%d\\\",0,0x%x,0,0\\n\",\t\\\n+\t\tname, ival, N_LSYM)\n+\n+#define DBX_FINISH_SYMBOL(decl)\t\\\n+\tint line = 0;\t\t\t\t\t\t\\\n+\tfprintf (asmfile, \"\\\",\");\t\t\t\t\\\n+\tif (current_sym_addr)\t\t\t\t\t\\\n+\t  output_addr_const (asmfile, current_sym_addr);\t\\\n+\telse\t\t\t\t\t\t\t\\\n+\t  fprintf (asmfile, \"%d\", current_sym_value);\t\t\\\n+\tif (decl != 0 && TREE_CODE(decl) == FUNCTION_DECL)\t\\\n+\t  line=DECL_SOURCE_LINE (decl);\t\t\t\t\\\n+\tfprintf (asmfile, \",0x%x,%d,%d\\n\", current_sym_code,\t\\\n+\t  line!=0?64:0,line)\n+\n+#define DBX_OUTPUT_CATCH(file,decl,name)\t\t\\\n+\tfprintf (file, \".stab \\\"%s:C1\\\",\", IDENTIFIER_POINTER (DECL_NAME (decl)));\t\\\n+\tassemble_name (file, name);\t\t\t\\\n+\tfprintf (file, \",0x%x,0,0\\n\", N_CATCH)\n+\n+#define DBX_OUTPUT_LBRAC(file,name)\t\\\n+\tif (depth > 1) {\t\t\\\n+\tfprintf (file, \".stab \\\"\\\",\");\t\\\n+\tassemble_name (file, name);\t\\\n+\tfprintf (file, \",0x%x,0,%d\\n\", N_LBRAC, depth); }\n+\n+#define DBX_OUTPUT_RBRAC(file,name)\t\\\n+\tif (depth > 1) {\t\t\\\n+\tfprintf (file, \".stab \\\"\\\",\");\t\\\n+\tassemble_name (file, name);\t\\\n+\tfprintf (file, \",0x%x,0,%d\\n\", N_RBRAC, depth); }\n+\n+#define DBX_OUTPUT_ENUM(file)\t\\\n+\tfprintf (file, \"e3\");\t\\\n+\tCHARS(2)\n+\n+/* Undefine some things defined in i860.h because the native C compiler\n+   on the FX/2800 emits code to do these operations inline.  For GCC,\n+   we will use the default implementation of these things... i.e.\n+   generating calls to libgcc1 routines.  */\n+\n+#undef DIVSI3_LIBCALL\n+#undef UDIVSI3_LIBCALL\n+#undef REMSI3_LIBCALL\n+#undef UREMSI3_LIBCALL\n+\n+/* The Alliant compiler's mod function gives the wrong result after a\n+   shift operation. This bug typically hits in hash functions. */\n+\n+#define perform_umodsi3(a, b)\ta %= b; if (a == b) a=0; return a\n+#define perform_modsi3(a, b)\ta %= b; if (a == b) a=0; return a\n+\n+/* Global pointer needs to be 8 byte aligned? Link error if not... */\n+\n+#define DATA_ALIGNMENT(dummy,align)\t\\\n+\t((TREE_PUBLIC (decl) &&\t\\\n+\t (TREE_CODE (TREE_TYPE (decl))==POINTER_TYPE)) ? 64:align)\n+\n+#undef FUNCTION_PROFILER\n+#define FUNCTION_PROFILER(FILE, LABELNO)\t\\\n+\tfprintf (FILE, \"\\tcall __mcount_\\n\\tnop\\n\")\n+\n+/* Overrides for i860v4.h begin here */\n+\n+/* Provide a set of pre-definitions and pre-assertions appropriate for\n+   the i860 running Concentrix 2.x.  */\n+\n+#undef CPP_PREDEFINES \n+#define CPP_PREDEFINES \"-Di860 -Dunix -DBSD4_3 -Dalliant -Asystem(unix) -Acpu(i860) -Amachine(i860)\"\n+\n+#undef I860_REG_PREFIX\n+#undef ASM_COMMENT_START\n+#define ASM_COMMENT_START \"//\"\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE)\n+#undef ASM_OUTPUT_FUNCTION_PREFIX\n+#undef ASM_OUTPUT_PROLOGUE_SUFFIX\n+\n+/* Overrides for svr4.h begin here */\n+\n+#undef SVR4\n+\n+#undef SWITCH_TAKES_ARG\n+#undef WORD_SWITCH_TAKES_ARG\n+\n+#undef ASM_SPEC\n+#undef ASM_FINAL_SPEC\n+#undef MD_STARTFILE_PREFIX\n+\n+/* Generate an error message if -p option is selected. Concentrix 2.x\n+   does not support prof format profiling, only gprof is supported. */\n+\n+#define CPP_SPEC\t\"%{p:%e-p option not supported: use -pg instead}\"\n+\n+/* Provide an appropriate LIB_SPEC. The crtend.o file provides part of the\n+   support for getting C++ file-scope static objects constructed before\n+   entering `main'. */\n+\n+#undef LIB_SPEC\n+#define LIB_SPEC \\\n+\t\"%{g*:-lg} %{!pg:-lc}%{pg:-lc_p} crtend.o%s\"\n+\n+/* Tell linker to strip local symbols, since assembler may not. */\n+\n+#undef LINK_SPEC\n+#define LINK_SPEC\t\"-X\"\n+\n+/* Get the correct startup file for regular or profiled code. Also\n+   use the crtbegin.o file for C++ ... */\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC \\\n+\t\"%{!pg:crt0.o%s}%{pg:gcrt0.o%s} crtbegin.o%s\"\n+\n+#undef SCCS_DIRECTIVE\n+#undef NO_DOLLAR_IN_LABEL\n+#undef TARGET_MEM_FUNCTIONS\n+\n+#undef DWARF_DEBUGGING_INFO\n+\n+#undef ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE,NAME) fprintf (FILE, \"_%s\", NAME)\n+#undef ASM_OUTPUT_EXTERNAL_LIBCALL\n+\n+#undef BSS_ASM_OP\n+#define BSS_ASM_OP\t\"\\t.lcomm\""}]}