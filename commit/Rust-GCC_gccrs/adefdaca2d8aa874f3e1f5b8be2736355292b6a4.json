{"sha": "adefdaca2d8aa874f3e1f5b8be2736355292b6a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRlZmRhY2EyZDhhYTg3NGYzZTFmNWI4YmUyNzM2MzU1MjkyYjZhNA==", "commit": {"author": {"name": "Gary Benson", "email": "gbenson@redhat.com", "date": "2006-11-03T10:16:04Z"}, "committer": {"name": "Gary Benson", "email": "gary@gcc.gnu.org", "date": "2006-11-03T10:16:04Z"}, "message": "InetAddress.java: Removed.\n\n2006-11-03  Gary Benson  <gbenson@redhat.com>\n\n\t* java/net/InetAddress.java: Removed.\n\t* java/net/natInetAddressNoNet.cc: Likewise.\n\t* java/net/natInetAddressPosix.cc: Likewise.\n\t* java/net/natInetAddressWin32.cc: Likewise.\n\t* java/net/VMInetAddress.java (getLocalHostname,\n\tlookupInaddrAny, getHostByAddr, getHostByName,\n\taton): Replace glue methods with native ones.\n\t* java/net/natVMInetAddressNoNet.cc: New file.\n\t* java/net/natVMInetAddressPosix.cc: Likewise.\n\t* java/net/natVMInetAddressWin32.cc: Likewise.\n\t* Makefile.am, configure.ac: Reflect the above.\n\t* sources.am, Makefile.in, configure: Rebuilt.\n\n\t* java/net/natVMNetworkInterfaceWin32.cc\n\t(winsock2GetRealNetworkInterfaces): Create InetAddress\n\tobjects using InetAddress.getByAddress.\n\t* gnu/java/net/natPlainSocketImplWin32.cc\n\t(accept, getOption): Likewise.\n\t* gnu/java/net/natPlainDatagramSocketImplWin32.cc\n\t(peekData, receive, getOption): Likewise.\n\nFrom-SVN: r118451", "tree": {"sha": "8a6600d7ecfed57029e5fe6bcacbb895c3ca5b97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a6600d7ecfed57029e5fe6bcacbb895c3ca5b97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/adefdaca2d8aa874f3e1f5b8be2736355292b6a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adefdaca2d8aa874f3e1f5b8be2736355292b6a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adefdaca2d8aa874f3e1f5b8be2736355292b6a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/comments", "author": null, "committer": null, "parents": [{"sha": "5d7de335d797bb22671a929a0b3712fa25aeb4fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d7de335d797bb22671a929a0b3712fa25aeb4fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d7de335d797bb22671a929a0b3712fa25aeb4fe"}], "stats": {"total": 1886, "additions": 506, "deletions": 1380}, "files": [{"sha": "b02e649ae5a5d9ff1d2a8e7d6822f1da83ad4574", "filename": "libjava/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=adefdaca2d8aa874f3e1f5b8be2736355292b6a4", "patch": "@@ -1,3 +1,26 @@\n+2006-11-03  Gary Benson  <gbenson@redhat.com>\n+\n+\t* java/net/InetAddress.java: Removed.\n+\t* java/net/natInetAddressNoNet.cc: Likewise.\n+\t* java/net/natInetAddressPosix.cc: Likewise.\n+\t* java/net/natInetAddressWin32.cc: Likewise.\n+\t* java/net/VMInetAddress.java (getLocalHostname,\n+\tlookupInaddrAny, getHostByAddr, getHostByName,\n+\taton): Replace glue methods with native ones.\n+\t* java/net/natVMInetAddressNoNet.cc: New file.\n+\t* java/net/natVMInetAddressPosix.cc: Likewise.\n+\t* java/net/natVMInetAddressWin32.cc: Likewise.\n+\t* Makefile.am, configure.ac: Reflect the above.\n+\t* sources.am, Makefile.in, configure: Rebuilt.\n+\n+\t* java/net/natVMNetworkInterfaceWin32.cc\n+\t(winsock2GetRealNetworkInterfaces): Create InetAddress\n+\tobjects using InetAddress.getByAddress.\n+\t* gnu/java/net/natPlainSocketImplWin32.cc\n+\t(accept, getOption): Likewise.\n+\t* gnu/java/net/natPlainDatagramSocketImplWin32.cc\n+\t(peekData, receive, getOption): Likewise.\n+\n 2006-11-02  Keith Seitz  <keiths@redhat.com>\n \n \t* gnu/classpath/jdwp/natVMMethod.cc (getLineTable): Implement."}, {"sha": "a0d6a3c963109cbeae724889044bb04fa8dc864d", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=adefdaca2d8aa874f3e1f5b8be2736355292b6a4", "patch": "@@ -858,7 +858,7 @@ java/lang/reflect/natConstructor.cc \\\n java/lang/reflect/natField.cc \\\n java/lang/reflect/natMethod.cc \\\n java/net/natVMNetworkInterface.cc \\\n-java/net/natInetAddress.cc \\\n+java/net/natVMInetAddress.cc \\\n java/net/natURLClassLoader.cc \\\n java/nio/channels/natVMChannels.cc \\\n java/nio/natDirectByteBufferImpl.cc \\"}, {"sha": "ab5b5119b38c41143ca013bf6a6b0aaf106e3455", "filename": "libjava/Makefile.in", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=adefdaca2d8aa874f3e1f5b8be2736355292b6a4", "patch": "@@ -95,7 +95,7 @@ CONFIG_HEADER = $(top_builddir)/include/config.h \\\n \t$(top_builddir)/gcj/libgcj-config.h\n CONFIG_CLEAN_FILES = libgcj.pc libgcj.spec libgcj-test.spec \\\n \tscripts/jar java/io/natFile.cc java/lang/ConcreteProcess.java \\\n-\tjava/lang/natConcreteProcess.cc java/net/natInetAddress.cc \\\n+\tjava/lang/natConcreteProcess.cc java/net/natVMInetAddress.cc \\\n \tjava/net/natVMNetworkInterface.cc \\\n \tgnu/java/net/natPlainSocketImpl.cc \\\n \tgnu/java/net/natPlainDatagramSocketImpl.cc \\\n@@ -300,7 +300,7 @@ am__libgcj_la_SOURCES_DIST = prims.cc jni.cc jvmti.cc exception.cc \\\n \tjava/lang/ref/natReference.cc java/lang/reflect/natArray.cc \\\n \tjava/lang/reflect/natConstructor.cc \\\n \tjava/lang/reflect/natField.cc java/lang/reflect/natMethod.cc \\\n-\tjava/net/natVMNetworkInterface.cc java/net/natInetAddress.cc \\\n+\tjava/net/natVMNetworkInterface.cc java/net/natVMInetAddress.cc \\\n \tjava/net/natURLClassLoader.cc \\\n \tjava/nio/channels/natVMChannels.cc \\\n \tjava/nio/natDirectByteBufferImpl.cc \\\n@@ -348,7 +348,7 @@ am__objects_2 = gnu/classpath/natSystemProperties.lo \\\n \tjava/lang/ref/natReference.lo java/lang/reflect/natArray.lo \\\n \tjava/lang/reflect/natConstructor.lo \\\n \tjava/lang/reflect/natField.lo java/lang/reflect/natMethod.lo \\\n-\tjava/net/natVMNetworkInterface.lo java/net/natInetAddress.lo \\\n+\tjava/net/natVMNetworkInterface.lo java/net/natVMInetAddress.lo \\\n \tjava/net/natURLClassLoader.lo \\\n \tjava/nio/channels/natVMChannels.lo \\\n \tjava/nio/natDirectByteBufferImpl.lo \\\n@@ -4130,7 +4130,7 @@ classpath/java/net/FileNameMap.java \\\n classpath/java/net/HttpURLConnection.java \\\n classpath/java/net/Inet4Address.java \\\n classpath/java/net/Inet6Address.java \\\n-java/net/InetAddress.java \\\n+classpath/java/net/InetAddress.java \\\n classpath/java/net/InetSocketAddress.java \\\n classpath/java/net/JarURLConnection.java \\\n classpath/java/net/MalformedURLException.java \\\n@@ -7431,7 +7431,7 @@ java/lang/reflect/natConstructor.cc \\\n java/lang/reflect/natField.cc \\\n java/lang/reflect/natMethod.cc \\\n java/net/natVMNetworkInterface.cc \\\n-java/net/natInetAddress.cc \\\n+java/net/natVMInetAddress.cc \\\n java/net/natURLClassLoader.cc \\\n java/nio/channels/natVMChannels.cc \\\n java/nio/natDirectByteBufferImpl.cc \\\n@@ -7929,7 +7929,7 @@ java/net/$(DEPDIR)/$(am__dirstamp):\n \t@: > java/net/$(DEPDIR)/$(am__dirstamp)\n java/net/natVMNetworkInterface.lo: java/net/$(am__dirstamp) \\\n \tjava/net/$(DEPDIR)/$(am__dirstamp)\n-java/net/natInetAddress.lo: java/net/$(am__dirstamp) \\\n+java/net/natVMInetAddress.lo: java/net/$(am__dirstamp) \\\n \tjava/net/$(DEPDIR)/$(am__dirstamp)\n java/net/natURLClassLoader.lo: java/net/$(am__dirstamp) \\\n \tjava/net/$(DEPDIR)/$(am__dirstamp)\n@@ -8261,10 +8261,10 @@ mostlyclean-compile:\n \t-rm -f java/lang/reflect/natField.lo\n \t-rm -f java/lang/reflect/natMethod.$(OBJEXT)\n \t-rm -f java/lang/reflect/natMethod.lo\n-\t-rm -f java/net/natInetAddress.$(OBJEXT)\n-\t-rm -f java/net/natInetAddress.lo\n \t-rm -f java/net/natURLClassLoader.$(OBJEXT)\n \t-rm -f java/net/natURLClassLoader.lo\n+\t-rm -f java/net/natVMInetAddress.$(OBJEXT)\n+\t-rm -f java/net/natVMInetAddress.lo\n \t-rm -f java/net/natVMNetworkInterface.$(OBJEXT)\n \t-rm -f java/net/natVMNetworkInterface.lo\n \t-rm -f java/nio/channels/natVMChannels.$(OBJEXT)\n@@ -8392,8 +8392,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/reflect/$(DEPDIR)/natConstructor.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/reflect/$(DEPDIR)/natField.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/reflect/$(DEPDIR)/natMethod.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@java/net/$(DEPDIR)/natInetAddress.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/net/$(DEPDIR)/natURLClassLoader.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@java/net/$(DEPDIR)/natVMInetAddress.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/net/$(DEPDIR)/natVMNetworkInterface.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/nio/$(DEPDIR)/natDirectByteBufferImpl.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/nio/channels/$(DEPDIR)/natVMChannels.Plo@am__quote@"}, {"sha": "cab2891d259c93d2fe375ca57147b583149de348", "filename": "libjava/configure", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure?ref=adefdaca2d8aa874f3e1f5b8be2736355292b6a4", "patch": "@@ -7486,9 +7486,9 @@ test -d java/lang || mkdir java/lang\n           ac_config_links=\"$ac_config_links java/lang/natConcreteProcess.cc:java/lang/nat${PLATFORM}Process.cc\"\n \n \n-# Likewise for natInetAddress.cc and natVMNetworkInterface.cc.\n+# Likewise for natVMInetAddress.cc and natVMNetworkInterface.cc.\n test -d java/net || mkdir java/net\n-          ac_config_links=\"$ac_config_links java/net/natInetAddress.cc:java/net/natInetAddress${PLATFORMNET}.cc\"\n+          ac_config_links=\"$ac_config_links java/net/natVMInetAddress.cc:java/net/natVMInetAddress${PLATFORMNET}.cc\"\n \n           ac_config_links=\"$ac_config_links java/net/natVMNetworkInterface.cc:java/net/natVMNetworkInterface${PLATFORMNET}.cc\"\n \n@@ -17479,7 +17479,7 @@ do\n   \"java/io/natFile.cc\" ) CONFIG_LINKS=\"$CONFIG_LINKS java/io/natFile.cc:java/io/natFile${FILE-${PLATFORM}}.cc\" ;;\n   \"java/lang/ConcreteProcess.java\" ) CONFIG_LINKS=\"$CONFIG_LINKS java/lang/ConcreteProcess.java:java/lang/${PLATFORM}Process.java\" ;;\n   \"java/lang/natConcreteProcess.cc\" ) CONFIG_LINKS=\"$CONFIG_LINKS java/lang/natConcreteProcess.cc:java/lang/nat${PLATFORM}Process.cc\" ;;\n-  \"java/net/natInetAddress.cc\" ) CONFIG_LINKS=\"$CONFIG_LINKS java/net/natInetAddress.cc:java/net/natInetAddress${PLATFORMNET}.cc\" ;;\n+  \"java/net/natVMInetAddress.cc\" ) CONFIG_LINKS=\"$CONFIG_LINKS java/net/natVMInetAddress.cc:java/net/natVMInetAddress${PLATFORMNET}.cc\" ;;\n   \"java/net/natVMNetworkInterface.cc\" ) CONFIG_LINKS=\"$CONFIG_LINKS java/net/natVMNetworkInterface.cc:java/net/natVMNetworkInterface${PLATFORMNET}.cc\" ;;\n   \"gnu/java/net/natPlainSocketImpl.cc\" ) CONFIG_LINKS=\"$CONFIG_LINKS gnu/java/net/natPlainSocketImpl.cc:gnu/java/net/natPlainSocketImpl${PLATFORMNET}.cc\" ;;\n   \"gnu/java/net/natPlainDatagramSocketImpl.cc\" ) CONFIG_LINKS=\"$CONFIG_LINKS gnu/java/net/natPlainDatagramSocketImpl.cc:gnu/java/net/natPlainDatagramSocketImpl${PLATFORMNET}.cc\" ;;"}, {"sha": "a51e923f10ef808c45e487e61a66f84fa81af176", "filename": "libjava/configure.ac", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.ac?ref=adefdaca2d8aa874f3e1f5b8be2736355292b6a4", "patch": "@@ -663,9 +663,9 @@ test -d java/lang || mkdir java/lang\n AC_CONFIG_LINKS(java/lang/ConcreteProcess.java:java/lang/${PLATFORM}Process.java)\n AC_CONFIG_LINKS(java/lang/natConcreteProcess.cc:java/lang/nat${PLATFORM}Process.cc)\n \n-# Likewise for natInetAddress.cc and natVMNetworkInterface.cc.\n+# Likewise for natVMInetAddress.cc and natVMNetworkInterface.cc.\n test -d java/net || mkdir java/net\n-AC_CONFIG_LINKS(java/net/natInetAddress.cc:java/net/natInetAddress${PLATFORMNET}.cc)\n+AC_CONFIG_LINKS(java/net/natVMInetAddress.cc:java/net/natVMInetAddress${PLATFORMNET}.cc)\n AC_CONFIG_LINKS(java/net/natVMNetworkInterface.cc:java/net/natVMNetworkInterface${PLATFORMNET}.cc)\n \n # Likewise for natPlainSocketImpl.cc and natPlainDatagramSocketImpl.cc."}, {"sha": "e410196653de956238d524f2c995e4f50005fea0", "filename": "libjava/gnu/java/net/natPlainDatagramSocketImplWin32.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainDatagramSocketImplWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainDatagramSocketImplWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainDatagramSocketImplWin32.cc?ref=adefdaca2d8aa874f3e1f5b8be2736355292b6a4", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2003  Free Software Foundation\n+/* Copyright (C) 2003, 2006 Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -238,7 +238,7 @@ gnu::java::net::PlainDatagramSocketImpl::peekData(::java::net::DatagramPacket *p\n   else\n     throw new ::java::net::SocketException (JvNewStringUTF (\"invalid family\"));\n \n-  p->setAddress (new ::java::net::InetAddress (raddr, NULL));\n+  p->setAddress (::java::net::InetAddress::getByAddress (raddr));\n   p->setPort (rport);\n   p->length = (jint) retlen;\n   return rport;\n@@ -360,7 +360,7 @@ gnu::java::net::PlainDatagramSocketImpl::receive (::java::net::DatagramPacket *p\n   else\n     throw new ::java::net::SocketException (JvNewStringUTF (\"invalid family\"));\n \n-  p->setAddress (new ::java::net::InetAddress (raddr, NULL));\n+  p->setAddress (::java::net::InetAddress::getByAddress (raddr));\n   p->setPort (rport);\n   p->length = (jint) retlen;\n   return;\n@@ -656,7 +656,7 @@ gnu::java::net::PlainDatagramSocketImpl::getOption (jint optID)\n       else\n         throw new ::java::net::SocketException (\n             JvNewStringUTF (\"invalid family\"));\n-      localAddress = new ::java::net::InetAddress (laddr, NULL);\n+      localAddress = ::java::net::InetAddress::getByAddress (laddr);\n     }\n   return localAddress;\n   break;"}, {"sha": "9377998f5495fe9c15cd7f501afea9603b19198b", "filename": "libjava/gnu/java/net/natPlainSocketImplWin32.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplWin32.cc?ref=adefdaca2d8aa874f3e1f5b8be2736355292b6a4", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2003, 2004, 2005 Free Software Foundation\n+/* Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -328,7 +328,7 @@ gnu::java::net::PlainSocketImpl::accept (gnu::java::net::PlainSocketImpl *s)\n \n   s->native_fd = (jint) hSocket;\n   s->localport = localport;\n-  s->address = new ::java::net::InetAddress (raddr, NULL);\n+  s->address = ::java::net::InetAddress::getByAddress (raddr);\n   s->port = rport;\n   return;\n \n@@ -735,7 +735,7 @@ gnu::java::net::PlainSocketImpl::getOption (jint optID)\n           else\n             throw new ::java::net::SocketException\n               (JvNewStringUTF (\"invalid family\"));\n-          localAddress = new ::java::net::InetAddress (laddr, NULL);\n+          localAddress = ::java::net::InetAddress::getByAddress (laddr);\n         }\n \n       return localAddress;"}, {"sha": "640750d63b16a962a2a702a97dc098ed8a61bf62", "filename": "libjava/java/net/InetAddress.java", "status": "removed", "additions": 0, "deletions": 819, "changes": 819, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d7de335d797bb22671a929a0b3712fa25aeb4fe/libjava%2Fjava%2Fnet%2FInetAddress.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d7de335d797bb22671a929a0b3712fa25aeb4fe/libjava%2Fjava%2Fnet%2FInetAddress.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FInetAddress.java?ref=5d7de335d797bb22671a929a0b3712fa25aeb4fe", "patch": "@@ -1,819 +0,0 @@\n-/* InetAddress.java -- Class to model an Internet address\n-   Copyright (C) 1998, 1999, 2002, 2004, 2005, 2006\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package java.net;\n-\n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.ObjectStreamException;\n-import java.io.Serializable;\n-\n-/**\n- * This class models an Internet address.  It does not have a public\n- * constructor.  Instead, new instances of this objects are created\n- * using the static methods getLocalHost(), getByName(), and\n- * getAllByName().\n- *\n- * <p>This class fulfills the function of the C style functions gethostname(),\n- * gethostbyname(), and gethostbyaddr().  It resolves Internet DNS names\n- * into their corresponding numeric addresses and vice versa.</p>\n- *\n- * @author Aaron M. Renn (arenn@urbanophile.com)\n- * @author Per Bothner\n- * @author Gary Benson (gbenson@redhat.com)\n- *\n- * @specnote This class is not final since JK 1.4\n- */\n-public class InetAddress implements Serializable\n-{\n-  private static final long serialVersionUID = 3286316764910316507L;\n-\n-  /**\n-   * Stores static localhost address object.\n-   */\n-  static InetAddress LOCALHOST;\n-  static\n-  {\n-    try\n-      {\n-\tLOCALHOST = getByAddress(\"localhost\", new byte[] {127, 0, 0, 1});\n-\t// Some soon-to-be-removed native code synchronizes on this.\n-\tloopbackAddress = LOCALHOST;\n-      }\n-    catch (UnknownHostException e)\n-      {\n-\tthrow new RuntimeException(\"should never happen\", e);\n-      }\n-  }    \n-\n-  /**\n-   * Dummy InetAddress, used to bind socket to any (all) network interfaces.\n-   */\n-  static InetAddress ANY_IF;\n-  static\n-  {\n-    byte[] addr;\n-    try\n-      {\n-\taddr = VMInetAddress.lookupInaddrAny();\n-      }\n-    catch (UnknownHostException e)\n-      {\n-\t// Make one up and hope it works.\n-\taddr = new byte[] {0, 0, 0, 0};\n-      }\n-    try\n-      {\n-\tANY_IF = getByAddress(addr);\n-      }\n-    catch (UnknownHostException e)\n-      {\n-\tthrow new RuntimeException(\"should never happen\", e);\n-      }\n-    ANY_IF.hostName = ANY_IF.getHostName();\n-  }\n-  \n-  /**\n-   * The Serialized Form specifies that an int 'address' is saved/restored.\n-   * This class uses a byte array internally so we'll just do the conversion\n-   * at serialization time and leave the rest of the algorithm as is.\n-   */\n-  private int address;\n-\n-  /**\n-   * An array of octets representing an IP address.\n-   */\n-  transient byte[] addr;\n-\n-  /**\n-   * The name of the host for this address.\n-   */\n-  String hostName;\n-\n-  /**\n-   * Needed for serialization.\n-   */\n-  private int family;\n-\n-  /**\n-   * Constructor.  Prior to the introduction of IPv6 support in 1.4,\n-   * methods such as InetAddress.getByName() would return InetAddress\n-   * objects.  From 1.4 such methods returned either Inet4Address or\n-   * Inet6Address objects, but for compatibility Inet4Address objects\n-   * are serialized as InetAddresses.  As such, there are only two\n-   * places where it is appropriate to invoke this constructor: within\n-   * subclasses constructors and within Inet4Address.writeReplace().\n-   *\n-   * @param ipaddr The IP number of this address as an array of bytes\n-   * @param hostname The hostname of this IP address.\n-   * @param family The address family of this IP address.\n-   */\n-  InetAddress(byte[] ipaddr, String hostname, int family)\n-  {\n-    addr = (null == ipaddr) ? null : (byte[]) ipaddr.clone();\n-    hostName = hostname;\n-    this.family = family;\n-  }\n-\n-  /**\n-   * Returns true if this address is a multicast address, false otherwise.\n-   * An address is multicast if the high four bits are \"1110\".  These are\n-   * also known as \"Class D\" addresses.\n-   *\n-   * <p>This method cannot be abstract for backward compatibility reasons. By\n-   * default it always throws {@link UnsupportedOperationException} unless\n-   * overridden.</p>\n-   * \n-   * @return true if mulitcast, false if not\n-   *\n-   * @since 1.1\n-   */\n-  public boolean isMulticastAddress()\n-  {\n-    // This method is masked on Posix systems, where all InetAddress\n-    // objects are created using InetAddress.getByAddress() which \n-    // returns either Inet4Address or Inet6Address objects.  Certain\n-    // native methods on Win32 use \"new InetAddress\" in which case\n-    // this method will be visible.\n-    try\n-      {\n-\treturn getByAddress(hostName, addr).isMulticastAddress();\n-      }\n-    catch (UnknownHostException e)\n-      {\n-\tthrow new RuntimeException(\"should never happen\", e);\n-      }\n-  }\n-\n-  /**\n-   * Utility routine to check if the InetAddress in a wildcard address\n-   *\n-   * <p>This method cannot be abstract for backward compatibility reasons. By\n-   * default it always throws {@link UnsupportedOperationException} unless\n-   * overridden.</p>\n-   * \n-   * @since 1.4\n-   */\n-  public boolean isAnyLocalAddress()\n-  {\n-    // This is inefficient, but certain methods on Win32 create\n-    // InetAddress objects using \"new InetAddress\" rather than\n-    // \"InetAddress.getByAddress\" so we provide a method body.\n-    // This code is never executed on Posix systems.\n-    try\n-      {\n-\treturn getByAddress(hostName, addr).isAnyLocalAddress();\n-      }\n-    catch (UnknownHostException e)\n-      {\n-\tthrow new RuntimeException(\"should never happen\", e);\n-      }\n-  }\n-\n-  /**\n-   * Utility routine to check if the InetAddress is a loopback address\n-   *\n-   * <p>This method cannot be abstract for backward compatibility reasons. By\n-   * default it always throws {@link UnsupportedOperationException} unless\n-   * overridden.</p>\n-   * \n-   * @since 1.4\n-   */\n-  public boolean isLoopbackAddress()\n-  {\n-    // This method is masked on Posix systems, where all InetAddress\n-    // objects are created using InetAddress.getByAddress() which \n-    // returns either Inet4Address or Inet6Address objects.  Certain\n-    // native methods on Win32 use \"new InetAddress\" in which case\n-    // this method will be visible.\n-    try\n-      {\n-\treturn getByAddress(hostName, addr).isLoopbackAddress();\n-      }\n-    catch (UnknownHostException e)\n-      {\n-\tthrow new RuntimeException(\"should never happen\", e);\n-      }\n-  }\n-\n-  /**\n-   * Utility routine to check if InetAddress is a link local address\n-   *\n-   * <p>This method cannot be abstract for backward compatibility reasons. By\n-   * default it always throws {@link UnsupportedOperationException} unless\n-   * overridden.</p>\n-   * \n-   * @since 1.4\n-   */\n-  public boolean isLinkLocalAddress()\n-  {\n-    // This method is masked on Posix systems, where all InetAddress\n-    // objects are created using InetAddress.getByAddress() which \n-    // returns either Inet4Address or Inet6Address objects.  Certain\n-    // native methods on Win32 use \"new InetAddress\" in which case\n-    // this method will be visible.\n-    try\n-      {\n-\treturn getByAddress(hostName, addr).isLinkLocalAddress();\n-      }\n-    catch (UnknownHostException e)\n-      {\n-\tthrow new RuntimeException(\"should never happen\", e);\n-      }\n-  }\n-\n-  /**\n-   * Utility routine to check if InetAddress is a site local address\n-   *\n-   * <p>This method cannot be abstract for backward compatibility reasons. By\n-   * default it always throws {@link UnsupportedOperationException} unless\n-   * overridden.</p>\n-   * \n-   * @since 1.4\n-   */\n-  public boolean isSiteLocalAddress()\n-  {\n-    // This method is masked on Posix systems, where all InetAddress\n-    // objects are created using InetAddress.getByAddress() which \n-    // returns either Inet4Address or Inet6Address objects.  Certain\n-    // native methods on Win32 use \"new InetAddress\" in which case\n-    // this method will be visible.\n-    try\n-      {\n-\treturn getByAddress(hostName, addr).isSiteLocalAddress();\n-      }\n-    catch (UnknownHostException e)\n-      {\n-\tthrow new RuntimeException(\"should never happen\", e);\n-      }\n-  }\n-\n-  /**\n-   * Utility routine to check if InetAddress is a global multicast address\n-   *\n-   * <p>This method cannot be abstract for backward compatibility reasons. By\n-   * default it always throws {@link UnsupportedOperationException} unless\n-   * overridden.</p>\n-   * \n-   * @since 1.4\n-   */\n-  public boolean isMCGlobal()\n-  {\n-    // This method is masked on Posix systems, where all InetAddress\n-    // objects are created using InetAddress.getByAddress() which \n-    // returns either Inet4Address or Inet6Address objects.  Certain\n-    // native methods on Win32 use \"new InetAddress\" in which case\n-    // this method will be visible.\n-    try\n-      {\n-\treturn getByAddress(hostName, addr).isMCGlobal();\n-      }\n-    catch (UnknownHostException e)\n-      {\n-\tthrow new RuntimeException(\"should never happen\", e);\n-      }\n-  }\n-\n-  /**\n-   * Utility routine to check if InetAddress is a node local multicast address.\n-   *\n-   * <p>This method cannot be abstract for backward compatibility reasons. By\n-   * default it always throws {@link UnsupportedOperationException} unless\n-   * overridden.</p>\n-   * \n-   * @since 1.4\n-   */\n-  public boolean isMCNodeLocal()\n-  {\n-    // This method is masked on Posix systems, where all InetAddress\n-    // objects are created using InetAddress.getByAddress() which \n-    // returns either Inet4Address or Inet6Address objects.  Certain\n-    // native methods on Win32 use \"new InetAddress\" in which case\n-    // this method will be visible.\n-    try\n-      {\n-\treturn getByAddress(hostName, addr).isMCNodeLocal();\n-      }\n-    catch (UnknownHostException e)\n-      {\n-\tthrow new RuntimeException(\"should never happen\", e);\n-      }\n-  }\n-\n-  /**\n-   * Utility routine to check if InetAddress is a link local multicast address.\n-   *\n-   * <p>This method cannot be abstract for backward compatibility reasons. By\n-   * default it always throws {@link UnsupportedOperationException} unless\n-   * overridden.</p>\n-   * \n-   * @since 1.4\n-   */\n-  public boolean isMCLinkLocal()\n-  {\n-    // This method is masked on Posix systems, where all InetAddress\n-    // objects are created using InetAddress.getByAddress() which \n-    // returns either Inet4Address or Inet6Address objects.  Certain\n-    // native methods on Win32 use \"new InetAddress\" in which case\n-    // this method will be visible.\n-    try\n-      {\n-\treturn getByAddress(hostName, addr).isMCLinkLocal();\n-      }\n-    catch (UnknownHostException e)\n-      {\n-\tthrow new RuntimeException(\"should never happen\", e);\n-      }\n-  }\n-\n-  /**\n-   * Utility routine to check if InetAddress is a site local multicast address.\n-   *\n-   * <p>This method cannot be abstract for backward compatibility reasons. By\n-   * default it always throws {@link UnsupportedOperationException} unless\n-   * overridden.</p>\n-   * \n-   * @since 1.4\n-   */\n-  public boolean isMCSiteLocal()\n-  {\n-    // This method is masked on Posix systems, where all InetAddress\n-    // objects are created using InetAddress.getByAddress() which \n-    // returns either Inet4Address or Inet6Address objects.  Certain\n-    // native methods on Win32 use \"new InetAddress\" in which case\n-    // this method will be visible.\n-    try\n-      {\n-\treturn getByAddress(hostName, addr).isMCSiteLocal();\n-      }\n-    catch (UnknownHostException e)\n-      {\n-\tthrow new RuntimeException(\"should never happen\", e);\n-      }\n-  }\n-\n-  /**\n-   * Utility routine to check if InetAddress is a organization local\n-   * multicast address.\n-   *\n-   * <p>This method cannot be abstract for backward compatibility reasons. By\n-   * default it always throws {@link UnsupportedOperationException} unless\n-   * overridden.</p>\n-   * \n-   * @since 1.4\n-   */\n-  public boolean isMCOrgLocal()\n-  {\n-    // This method is masked on Posix systems, where all InetAddress\n-    // objects are created using InetAddress.getByAddress() which \n-    // returns either Inet4Address or Inet6Address objects.  Certain\n-    // native methods on Win32 use \"new InetAddress\" in which case\n-    // this method will be visible.\n-    try\n-      {\n-\treturn getByAddress(hostName, addr).isMCOrgLocal();\n-      }\n-    catch (UnknownHostException e)\n-      {\n-\tthrow new RuntimeException(\"should never happen\", e);\n-      }\n-  }\n-\n-  /**\n-   * Returns the hostname for this address.  This will return the IP address\n-   * as a String if there is no hostname available for this address\n-   *\n-   * @return The hostname for this address\n-   */\n-  public String getHostName()\n-  {\n-    if (hostName == null)\n-      hostName = getCanonicalHostName();\n-\n-    return hostName;\n-  }\n-\n-  /**\n-   * Returns the canonical hostname represented by this InetAddress\n-   */\n-  String internalGetCanonicalHostName()\n-  {\n-    try\n-      {\n-\treturn ResolverCache.getHostByAddr(addr);\n-      }\n-    catch (UnknownHostException e)\n-      {\n-\treturn getHostAddress();\n-      }\n-  }\n-\n-  /**\n-   * Returns the canonical hostname represented by this InetAddress\n-   * \n-   * @since 1.4\n-   */\n-  public String getCanonicalHostName()\n-  {\n-    String hostname = internalGetCanonicalHostName();\n-\n-    SecurityManager sm = System.getSecurityManager();\n-    if (sm != null)\n-      {\n-        try\n-\t  {\n-            sm.checkConnect(hostname, -1);\n-\t  }\n-\tcatch (SecurityException e)\n-\t  {\n-\t    return getHostAddress();\n-\t  }\n-      }\n-\n-    return hostname;\n-  }\n-\n-  /**\n-   * Returns the IP address of this object as a byte array.\n-   *\n-   * @return IP address\n-   */\n-  public byte[] getAddress()\n-  {\n-    // An experiment shows that JDK1.2 returns a different byte array each\n-    // time.  This makes sense, in terms of security.\n-    return (byte[]) addr.clone();\n-  }\n-\n-  /**\n-   * Returns the IP address of this object as a String.\n-   *\n-   * <p>This method cannot be abstract for backward compatibility reasons. By\n-   * default it always throws {@link UnsupportedOperationException} unless\n-   * overridden.</p>\n-   * \n-   * @return The IP address of this object in String form\n-   *\n-   * @since 1.0.2\n-   */\n-  public String getHostAddress()\n-  {\n-    // This method is masked on Posix systems, where all InetAddress\n-    // objects are created using InetAddress.getByAddress() which \n-    // returns either Inet4Address or Inet6Address objects.  Certain\n-    // native methods on Win32 use \"new InetAddress\" in which case\n-    // this method will be visible.\n-    try\n-      {\n-\treturn getByAddress(hostName, addr).getHostAddress();\n-      }\n-    catch (UnknownHostException e)\n-      {\n-\tthrow new RuntimeException(\"should never happen\", e);\n-      }\n-  }\n-\n-  /**\n-   * Returns a hash value for this address.  Useful for creating hash\n-   * tables.  Overrides Object.hashCode()\n-   *\n-   * @return A hash value for this address.\n-   */\n-  public int hashCode()\n-  {\n-    // There hashing algorithm is not specified, but a simple experiment\n-    // shows that it is equal to the address, as a 32-bit big-endian integer.\n-    int hash = 0;\n-    int len = addr.length;\n-    int i = len > 4 ? len - 4 : 0;\n-\n-    for (; i < len; i++)\n-      hash = (hash << 8) | (addr[i] & 0xff);\n-\n-    return hash;\n-  }\n-\n-  /**\n-   * Tests this address for equality against another InetAddress.  The two\n-   * addresses are considered equal if they contain the exact same octets.\n-   * This implementation overrides Object.equals()\n-   *\n-   * @param obj The address to test for equality\n-   *\n-   * @return true if the passed in object's address is equal to this one's,\n-   * false otherwise\n-   */\n-  public boolean equals(Object obj)\n-  {\n-    if (! (obj instanceof InetAddress))\n-      return false;\n-\n-    // \"The Java Class Libraries\" 2nd edition says \"If a machine has\n-    // multiple names instances of InetAddress for different name of\n-    // that same machine are not equal.  This is because they have\n-    // different host names.\"  This violates the description in the\n-    // JDK 1.2 API documentation.  A little experimentation\n-    // shows that the latter is correct.\n-    byte[] addr2 = ((InetAddress) obj).addr;\n-\n-    if (addr.length != addr2.length)\n-      return false;\n-\n-    for (int i = 0; i < addr.length; i++)\n-      if (addr[i] != addr2[i])\n-\treturn false;\n-\n-    return true;\n-  }\n-\n-  /**\n-   * Converts this address to a String.  This string contains the IP in\n-   * dotted decimal form. For example: \"127.0.0.1\"  This method is equivalent\n-   * to getHostAddress() and overrides Object.toString()\n-   *\n-   * @return This address in String form\n-   */\n-  public String toString()\n-  {\n-    String addr = getHostAddress();\n-    String host = (hostName != null) ? hostName : \"\";\n-    return host + \"/\" + addr;\n-  }\n-\n-  /**\n-   * Returns an InetAddress object given the raw IP address.\n-   *\n-   * The argument is in network byte order: the highest order byte of the\n-   * address is in getAddress()[0].\n-   *\n-   * @param addr The IP address to create the InetAddress object from\n-   *\n-   * @exception UnknownHostException If IP address has illegal length\n-   *\n-   * @since 1.4\n-   */\n-  public static InetAddress getByAddress(byte[] addr)\n-    throws UnknownHostException\n-  {\n-    return getByAddress(null, addr);\n-  }\n-\n-  /**\n-   * Creates an InetAddress based on the provided host name and IP address.\n-   * No name service is checked for the validity of the address.\n-   *\n-   * @param host The hostname of the InetAddress object to create\n-   * @param addr The IP address to create the InetAddress object from\n-   *\n-   * @exception UnknownHostException If IP address is of illegal length\n-   *\n-   * @since 1.4\n-   */\n-  public static InetAddress getByAddress(String host, byte[] addr)\n-    throws UnknownHostException\n-  {\n-    if (addr.length == 4)\n-      return new Inet4Address(addr, host);\n-\n-    if (addr.length == 16)\n-      {\n-\tfor (int i = 0; i < 12; i++)\n-\t  {\n-\t    if (addr[i] != (i < 10 ? 0 : (byte) 0xFF))\n-\t      return new Inet6Address(addr, host);\n-\t  }\n-\t  \n-\tbyte[] ip4addr = new byte[4];\n-\tip4addr[0] = addr[12];\n-\tip4addr[1] = addr[13];\n-\tip4addr[2] = addr[14];\n-\tip4addr[3] = addr[15];\n-\treturn new Inet4Address(ip4addr, host);\n-      }\n-\n-    throw new UnknownHostException(\"IP address has illegal length\");\n-  }\n-\n-  /**\n-   * Returns an InetAddress object representing the IP address of\n-   * the given literal IP address in dotted decimal format such as\n-   * \"127.0.0.1\".  This is used by SocketPermission.setHostPort()\n-   * to parse literal IP addresses without performing a DNS lookup.\n-   *\n-   * @param literal The literal IP address to create the InetAddress\n-   * object from\n-   *\n-   * @return The address of the host as an InetAddress object, or\n-   * null if the IP address is invalid.\n-   */\n-  static InetAddress getByLiteral(String literal)\n-  {\n-    byte[] address = VMInetAddress.aton(literal);\n-    if (address == null)\n-      return null;\n-    \n-    try\n-      {\n-\treturn getByAddress(address);\n-      }\n-    catch (UnknownHostException e)\n-      {\n-\tthrow new RuntimeException(\"should never happen\", e);\n-      }\n-  }\n-\n-  /**\n-   * Returns an InetAddress object representing the IP address of the given\n-   * hostname.  This name can be either a hostname such as \"www.urbanophile.com\"\n-   * or an IP address in dotted decimal format such as \"127.0.0.1\".  If the\n-   * hostname is null or \"\", the hostname of the local machine is supplied by\n-   * default.  This method is equivalent to returning the first element in\n-   * the InetAddress array returned from GetAllByName.\n-   *\n-   * @param hostname The name of the desired host, or null for the local \n-   * loopback address.\n-   *\n-   * @return The address of the host as an InetAddress object.\n-   *\n-   * @exception UnknownHostException If no IP address for the host could\n-   * be found\n-   * @exception SecurityException If a security manager exists and its\n-   * checkConnect method doesn't allow the operation\n-   */\n-  public static InetAddress getByName(String hostname)\n-    throws UnknownHostException\n-  {\n-    InetAddress[] addresses = getAllByName(hostname);\n-    return addresses[0];\n-  }\n-\n-  /**\n-   * Returns an array of InetAddress objects representing all the host/ip\n-   * addresses of a given host, given the host's name.  This name can be\n-   * either a hostname such as \"www.urbanophile.com\" or an IP address in\n-   * dotted decimal format such as \"127.0.0.1\".  If the value is null, the\n-   * hostname of the local machine is supplied by default.\n-   *\n-   * @param hostname The name of the desired host, or null for the\n-   * local loopback address.\n-   *\n-   * @return All addresses of the host as an array of InetAddress objects.\n-   *\n-   * @exception UnknownHostException If no IP address for the host could\n-   * be found\n-   * @exception SecurityException If a security manager exists and its\n-   * checkConnect method doesn't allow the operation\n-   */\n-  public static InetAddress[] getAllByName(String hostname)\n-    throws UnknownHostException\n-  {\n-    // If null or the empty string is supplied, the loopback address\n-    // is returned.\n-    if (hostname == null || hostname.length() == 0)\n-      return new InetAddress[] {LOCALHOST};\n-\n-    // Check if hostname is an IP address\n-    InetAddress address = getByLiteral(hostname);\n-    if (address != null)\n-      return new InetAddress[] {address};\n-\n-    // Perform security check before resolving\n-    SecurityManager sm = System.getSecurityManager();\n-    if (sm != null)\n-      sm.checkConnect(hostname, -1);\n-\n-    // Resolve the hostname\n-    byte[][] iplist = ResolverCache.getHostByName(hostname);\n-    if (iplist.length == 0)\n-      throw new UnknownHostException(hostname);\n-\n-    InetAddress[] addresses = new InetAddress[iplist.length];\n-    for (int i = 0; i < iplist.length; i++)\n-      addresses[i] = getByAddress(hostname, iplist[i]);\n-\n-    return addresses;\n-  }\n-\n-  /**\n-   * Returns an InetAddress object representing the address of the current\n-   * host.\n-   *\n-   * @return The local host's address\n-   *\n-   * @exception UnknownHostException If no IP address for the host could\n-   * be found\n-   */\n-  public static InetAddress getLocalHost() throws UnknownHostException\n-  {\n-    String hostname = VMInetAddress.getLocalHostname();\n-    try\n-      {\n-\treturn getByName(hostname);\n-      }\n-    catch (SecurityException e)\n-      {\n-\treturn LOCALHOST;\n-      }\n-  }\n-\n-  /**\n-   * Inet4Address objects are serialized as InetAddress objects.\n-   * This deserializes them back into Inet4Address objects.\n-   */\n-  private Object readResolve() throws ObjectStreamException\n-  {\n-    return new Inet4Address(addr, hostName);\n-  }\n-\n-  private void readObject(ObjectInputStream ois)\n-    throws IOException, ClassNotFoundException\n-  {\n-    ois.defaultReadObject();\n-    addr = new byte[4];\n-    addr[3] = (byte) address;\n-\n-    for (int i = 2; i >= 0; --i)\n-      addr[i] = (byte) (address >>= 8);\n-  }\n-\n-  private void writeObject(ObjectOutputStream oos) throws IOException\n-  {\n-    // Build a 32 bit address from the last 4 bytes of a 4 byte IPv4 address\n-    // or a 16 byte IPv6 address.\n-    int len = addr.length;\n-    int i = len - 4;\n-\n-    for (; i < len; i++)\n-      address = address << 8 | (addr[i] & 0xff);\n-\n-    oos.defaultWriteObject();\n-  }\n-\n-  // The native methods remain here for now;\n-  // methods in VMInetAddress map onto them.\n-  static native byte[] aton(String hostname);\n-  static native InetAddress[] lookup (String hostname,\n-\t\t\t\t      InetAddress ipaddr, boolean all);\n-  static native int getFamily (byte[] ipaddr);\n-  static native String getLocalHostname();\n-\n-  // Some soon-to-be-removed native code synchronizes on this.\n-  static InetAddress loopbackAddress;\n-  \n-  // Some soon-to-be-removed code uses this old and broken method.\n-  InetAddress(byte[] ipaddr, String hostname)\n-  {\n-    addr = (null == ipaddr) ? null : (byte[]) ipaddr.clone();\n-    hostName = hostname;\n-\n-    if (ipaddr != null)\n-      family = getFamily(ipaddr);\n-  }\n-\n-  // Some soon-to-be-removed native code uses these old methods.\n-  private static InetAddress[] allocArray (int count)\n-  {\n-    return new InetAddress [count];\n-  }  \n-  private static SecurityException checkConnect (String hostname)\n-  {\n-    return null;\n-  }\n-}"}, {"sha": "a99c216b96ce1bad6d8e3ebd9aaf4c92c6aa99a5", "filename": "libjava/java/net/VMInetAddress.java", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2Fjava%2Fnet%2FVMInetAddress.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2Fjava%2Fnet%2FVMInetAddress.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FVMInetAddress.java?ref=adefdaca2d8aa874f3e1f5b8be2736355292b6a4", "patch": "@@ -58,18 +58,12 @@ class VMInetAddress implements Serializable\n    *\n    * @return The local hostname.\n    */\n-  public static String getLocalHostname()\n-  {\n-    return InetAddress.getLocalHostname();\n-  }\n+  public static native String getLocalHostname();\n \n   /**\n    * Returns the value of the special address INADDR_ANY\n    */\n-  public static byte[] lookupInaddrAny() throws UnknownHostException\n-  {\n-    return new byte[] {0, 0, 0, 0};\n-  }\n+  public static native byte[] lookupInaddrAny() throws UnknownHostException;\n \n   /**\n    * This method returns the hostname for a given IP address.  It will\n@@ -81,26 +75,15 @@ public static byte[] lookupInaddrAny() throws UnknownHostException\n    *\n    * @exception UnknownHostException If the reverse lookup fails\n    */\n-  public static String getHostByAddr(byte[] ip) throws UnknownHostException\n-  {\n-    InetAddress addr = InetAddress.getByAddress(ip);\n-    InetAddress.lookup(null, addr, false);\n-    return addr.getHostName();\n-  }\n+  public static native String getHostByAddr(byte[] ip)\n+    throws UnknownHostException;\n \n   /**\n    * Returns a list of all IP addresses for a given hostname.  Will throw\n    * an UnknownHostException if the hostname cannot be resolved.\n    */\n-  public static byte[][] getHostByName(String hostname)\n-    throws UnknownHostException\n-  {\n-    InetAddress[] iaddrs = InetAddress.lookup(hostname, null, true);\n-    byte[][] addrs = new byte[iaddrs.length][];\n-    for (int i = 0; i < iaddrs.length; i++)\n-      addrs[i] = iaddrs[i].getAddress();\n-    return addrs;\n-  }\n+  public static native byte[][] getHostByName(String hostname)\n+    throws UnknownHostException;\n \n   /**\n    * Return the IP address represented by a literal address.\n@@ -110,8 +93,5 @@ public static byte[][] getHostByName(String hostname)\n    *\n    * @return The IP address as a byte array\n    */\n-  public static byte[] aton(String address)\n-  {\n-    return InetAddress.aton(address);\n-  }\n+  public static native byte[] aton(String address);\n }"}, {"sha": "0374af18f88f8953a852188cda8b58c97c8c2223", "filename": "libjava/java/net/natInetAddressNoNet.cc", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d7de335d797bb22671a929a0b3712fa25aeb4fe/libjava%2Fjava%2Fnet%2FnatInetAddressNoNet.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d7de335d797bb22671a929a0b3712fa25aeb4fe/libjava%2Fjava%2Fnet%2FnatInetAddressNoNet.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatInetAddressNoNet.cc?ref=5d7de335d797bb22671a929a0b3712fa25aeb4fe", "patch": "@@ -1,36 +0,0 @@\n-/* Copyright (C) 2003  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-#include <config.h>\n-#include <stddef.h>\n-\n-#include <java/net/InetAddress.h>\n-\n-jbyteArray\n-java::net::InetAddress::aton (jstring)\n-{\n-  return NULL;\n-}\n-\n-jint\n-java::net::InetAddress::getFamily (jbyteArray bytes)\n-{\n-  return 0;\n-}\n-\n-JArray<java::net::InetAddress*> *\n-java::net::InetAddress::lookup (jstring, java::net::InetAddress *, jboolean)\n-{\n-  return NULL;\n-}\n-\n-jstring\n-java::net::InetAddress::getLocalHostname ()\n-{\n-  return NULL;\n-}"}, {"sha": "d343f23323cc0c7d2f471d257df12c065e8186cb", "filename": "libjava/java/net/natInetAddressPosix.cc", "status": "removed", "additions": 0, "deletions": 304, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d7de335d797bb22671a929a0b3712fa25aeb4fe/libjava%2Fjava%2Fnet%2FnatInetAddressPosix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d7de335d797bb22671a929a0b3712fa25aeb4fe/libjava%2Fjava%2Fnet%2FnatInetAddressPosix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatInetAddressPosix.cc?ref=5d7de335d797bb22671a929a0b3712fa25aeb4fe", "patch": "@@ -1,304 +0,0 @@\n-/* Copyright (C) 2003  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-#include <config.h>\n-\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#endif\n-#include <string.h>\n-#include <errno.h>\n-\n-#include <sys/param.h>\n-#include <sys/types.h>\n-#ifdef HAVE_SYS_SOCKET_H\n-#include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#include <netinet/in.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#include <arpa/inet.h>\n-#endif\n-#ifdef HAVE_NETDB_H\n-#include <netdb.h>\n-#endif\n-\n-#include <gcj/cni.h>\n-#include <jvm.h>\n-#include <java/net/InetAddress.h>\n-#include <java/net/UnknownHostException.h>\n-#include <java/lang/SecurityException.h>\n-\n-#if defined(HAVE_UNAME) && ! defined(HAVE_GETHOSTNAME)\n-#include <sys/utsname.h>\n-#endif\n-\n-#ifndef HAVE_GETHOSTNAME_DECL\n-extern \"C\" int gethostname (char *name, int namelen);\n-#endif\n-\n-jbyteArray\n-java::net::InetAddress::aton (jstring host)\n-{\n-  char *hostname;\n-  char buf[100];\n-  int len = JvGetStringUTFLength(host);\n-  if (len < 100)\n-    hostname = buf;\n-  else\n-    hostname = (char*) _Jv_AllocBytes (len+1);\n-  JvGetStringUTFRegion (host, 0, host->length(), hostname);\n-  buf[len] = '\\0';\n-  char* bytes = NULL;\n-  int blen = 0;\n-#ifdef HAVE_INET_ATON\n-  struct in_addr laddr;\n-  if (inet_aton (hostname, &laddr))\n-    {\n-      bytes = (char*) &laddr;\n-      blen = 4;\n-    }\n-#elif defined(HAVE_INET_ADDR)\n-#if ! HAVE_IN_ADDR_T\n-  typedef jint in_addr_t;\n-#endif\n-  in_addr_t laddr = inet_addr (hostname);\n-  if (laddr != (in_addr_t)(-1))\n-    {\n-      bytes = (char*) &laddr;\n-      blen = 4;\n-    }\n-#endif\n-#if defined (HAVE_INET_PTON) && defined (HAVE_INET6)\n-  char inet6_addr[16];\n-  if (len != 0 && inet_pton (AF_INET6, hostname, inet6_addr) > 0)\n-    {\n-      bytes = inet6_addr;\n-      blen = 16;\n-    }\n-#endif\n-  if (blen == 0)\n-    return NULL;\n-  jbyteArray result = JvNewByteArray (blen);\n-  memcpy (elements (result), bytes, blen);\n-  return result;\n-}\n-\n-jint\n-java::net::InetAddress::getFamily (jbyteArray bytes)\n-{\n-  int len = bytes->length;\n-  if (len == 4)\n-    return AF_INET;\n-#ifdef HAVE_INET6\n-  else if (len == 16)\n-    return AF_INET6;\n-#endif /* HAVE_INET6 */\n-  else\n-    JvFail (\"unrecognized size\");\n-}\n-\n-\n-JArray<java::net::InetAddress*> *\n-java::net::InetAddress::lookup (jstring host, java::net::InetAddress* iaddr,\n-\t\t\t\tjboolean all)\n-{\n-  struct hostent *hptr = NULL;\n-#if defined (HAVE_GETHOSTBYNAME_R) || defined (HAVE_GETHOSTBYADDR_R)\n-  struct hostent hent_r;\n-#if HAVE_STRUCT_HOSTENT_DATA\n-  struct hostent_data fixed_buffer, *buffer_r = &fixed_buffer;\n-#else\n-#if defined (__GLIBC__) \n-  // FIXME: in glibc, gethostbyname_r returns NETDB_INTERNAL to herr and\n-  // ERANGE to errno if the buffer size is too small, rather than what is \n-  // expected here. We work around this by setting a bigger buffer size and \n-  // hoping that it is big enough.\n-  char fixed_buffer[1024];\n-#else\n-  char fixed_buffer[200];\n-#endif\n-  char *buffer_r = fixed_buffer;\n-  int size_r = sizeof (fixed_buffer);\n-#endif\n-#endif\n-\n-  if (host != NULL)\n-    {\n-      char *hostname;\n-      char buf[100];\n-      int len = JvGetStringUTFLength(host);\n-      if (len < 100)\n-\thostname = buf;\n-      else\n-\thostname = (char*) _Jv_AllocBytes (len+1);\n-      JvGetStringUTFRegion (host, 0, host->length(), hostname);\n-      buf[len] = '\\0';\n-#ifdef HAVE_GETHOSTBYNAME_R\n-      while (true)\n-\t{\n-\t  int ok;\n-#if HAVE_STRUCT_HOSTENT_DATA\n-\t  ok = ! gethostbyname_r (hostname, &hent_r, buffer_r);\n-#else\n-\t  int herr = 0;\n-#ifdef GETHOSTBYNAME_R_RETURNS_INT\n-\t  ok = ! gethostbyname_r (hostname, &hent_r, buffer_r, size_r,\n-\t\t\t\t  &hptr, &herr);\n-#else\n-\t  hptr = gethostbyname_r (hostname, &hent_r, buffer_r, size_r, &herr);\n-\t  ok = hptr != NULL;\n-#endif /* GETHOSTNAME_R_RETURNS_INT */\n-\t  if (! ok && herr == ERANGE)\n-\t    {\n-\t      size_r *= 2;\n-\t      buffer_r = (char *) _Jv_AllocBytes (size_r);\n-\t    }\n-\t  else\n-#endif /* HAVE_STRUCT_HOSTENT_DATA */\n-\t    break;\n-\t}\n-#else\n-      // FIXME: this is insufficient if some other piece of code calls\n-      // this gethostbyname.\n-      JvSynchronize sync (java::net::InetAddress::loopbackAddress);\n-      hptr = gethostbyname (hostname);\n-#endif /* HAVE_GETHOSTBYNAME_R */\n-    }\n-  else\n-    {\n-      jbyteArray bytes = iaddr->addr;\n-      char *chars = (char*) elements (bytes);\n-      int len = bytes->length;\n-      int type;\n-      char *val;\n-      if (len == 4)\n-\t{\n-\t  val = chars;\n-\t  type = iaddr->family = AF_INET;\n-\t}\n-#ifdef HAVE_INET6\n-      else if (len == 16)\n-\t{\n-\t  val = (char *) &chars;\n-\t  type = iaddr->family = AF_INET6;\n-\t}\n-#endif /* HAVE_INET6 */\n-      else\n-\tJvFail (\"unrecognized size\");\n-\n-#ifdef HAVE_GETHOSTBYADDR_R\n-      while (true)\n-\t{\n-\t  int ok;\n-#if HAVE_STRUCT_HOSTENT_DATA\n-\t  ok = ! gethostbyaddr_r (val, len, type, &hent_r, buffer_r);\n-#else\n-\t  int herr = 0;\n-#ifdef GETHOSTBYADDR_R_RETURNS_INT\n-\t  ok = ! gethostbyaddr_r (val, len, type, &hent_r,\n-\t\t\t\t  buffer_r, size_r, &hptr, &herr);\n-#else\n-\t  hptr = gethostbyaddr_r (val, len, type, &hent_r,\n-\t\t\t\t  buffer_r, size_r, &herr);\n-\t  ok = hptr != NULL;\n-#endif /* GETHOSTBYADDR_R_RETURNS_INT */\n-\t  if (! ok && herr == ERANGE)\n-\t    {\n-\t      size_r *= 2;\n-\t      buffer_r = (char *) _Jv_AllocBytes (size_r);\n-\t    }\n-\t  else \n-#endif /* HAVE_STRUCT_HOSTENT_DATA */\n-\t    break;\n-\t}\n-#else /* HAVE_GETHOSTBYADDR_R */\n-      // FIXME: this is insufficient if some other piece of code calls\n-      // this gethostbyaddr.\n-      JvSynchronize sync (java::net::InetAddress::loopbackAddress);\n-      hptr = gethostbyaddr (val, len, type);\n-#endif /* HAVE_GETHOSTBYADDR_R */\n-    }\n-  if (hptr != NULL)\n-    {\n-      if (!all)\n-        host = JvNewStringUTF (hptr->h_name);\n-    }\n-  if (hptr == NULL)\n-    {\n-      if (iaddr != NULL && iaddr->addr != NULL)\n-\t{\n-\t  iaddr->hostName = iaddr->getHostAddress();\n-\t  return NULL;\n-\t}\n-      else\n-\tthrow new java::net::UnknownHostException(host);\n-    }\n-  int count;\n-  if (all)\n-    {\n-      char** ptr = hptr->h_addr_list;\n-      count = 0;\n-      while (*ptr++)  count++;\n-    }\n-  else\n-    count = 1;\n-  JArray<java::net::InetAddress*> *result;\n-  java::net::InetAddress** iaddrs;\n-  if (all)\n-    {\n-      result = java::net::InetAddress::allocArray (count);\n-      iaddrs = elements (result);\n-    }\n-  else\n-    {\n-      result = NULL;\n-      iaddrs = &iaddr;\n-    }\n-\n-  for (int i = 0;  i < count;  i++)\n-    {\n-      if (iaddrs[i] == NULL)\n-\tiaddrs[i] = new java::net::InetAddress (NULL, NULL);\n-      if (iaddrs[i]->hostName == NULL)\n-        iaddrs[i]->hostName = host;\n-      if (iaddrs[i]->addr == NULL)\n-\t{\n-\t  char *bytes = hptr->h_addr_list[i];\n-\t  iaddrs[i]->addr = JvNewByteArray (hptr->h_length);\n-\t  iaddrs[i]->family = getFamily (iaddrs[i]->addr);\n-\t  memcpy (elements (iaddrs[i]->addr), bytes, hptr->h_length);\n-\t}\n-    }\n-  return result;\n-}\n-\n-jstring\n-java::net::InetAddress::getLocalHostname ()\n-{\n-  char *chars;\n-#ifdef HAVE_GETHOSTNAME\n-  char buffer[MAXHOSTNAMELEN];\n-  if (gethostname (buffer, MAXHOSTNAMELEN))\n-    return NULL;\n-  chars = buffer;\n-#elif HAVE_UNAME\n-  struct utsname stuff;\n-  if (uname (&stuff) != 0)\n-    return NULL;\n-  chars = stuff.nodename;\n-#else\n-  return NULL;\n-#endif\n-  // It is admittedly non-optimal to convert the hostname to Unicode\n-  // only to convert it back in getByName, but simplicity wins.  Note\n-  // that unless there is a SecurityManager, we only get called once\n-  // anyway, thanks to the InetAddress.localhost cache.\n-  return JvNewStringUTF (chars);\n-}"}, {"sha": "82c1e6f70025a1d8a9e501bc0e3b04057bdd8f6a", "filename": "libjava/java/net/natInetAddressWin32.cc", "status": "removed", "additions": 0, "deletions": 168, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d7de335d797bb22671a929a0b3712fa25aeb4fe/libjava%2Fjava%2Fnet%2FnatInetAddressWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d7de335d797bb22671a929a0b3712fa25aeb4fe/libjava%2Fjava%2Fnet%2FnatInetAddressWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatInetAddressWin32.cc?ref=5d7de335d797bb22671a929a0b3712fa25aeb4fe", "patch": "@@ -1,168 +0,0 @@\n-/* Copyright (C) 2003  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-#include <config.h>\n-#include <platform.h>\n-\n-#undef STRICT\n-\n-#include <java/net/InetAddress.h>\n-#include <java/net/UnknownHostException.h>\n-#include <java/lang/SecurityException.h>\n-\n-jbyteArray\n-java::net::InetAddress::aton (jstring host)\n-{\n-  JV_TEMP_UTF_STRING (hostname, host);\n-  char* bytes = NULL;\n-  int blen = 0;\n-  unsigned long laddr = inet_addr (hostname);\n-  if (laddr != INADDR_NONE)\n-    {\n-      bytes = (char*) &laddr;\n-      blen = 4;\n-    }\n-  if (blen == 0)\n-    return NULL;\n-  jbyteArray result = JvNewByteArray (blen);\n-  memcpy (elements (result), bytes, blen);\n-  return result;\n-}\n-\n-jint\n-java::net::InetAddress::getFamily (jbyteArray bytes)\n-{\n-  int len = bytes->length;\n-  if (len == 4)\n-    return AF_INET;\n-#ifdef HAVE_INET6\n-  else if (len == 16)\n-    return AF_INET6;\n-#endif /* HAVE_INET6 */\n-  else\n-    JvFail (\"unrecognized size\");\n-}\n-\n-\n-JArray<java::net::InetAddress*> *\n-java::net::InetAddress::lookup (jstring host, java::net::InetAddress* iaddr,\n-        jboolean all)\n-{\n-  struct hostent *hptr = NULL;\n-  if (host != NULL)\n-    {\n-      JV_TEMP_UTF_STRING (hostname, host);\n-\n-      // FIXME: this is insufficient if some other piece of code calls\n-      // this gethostbyname.\n-      JvSynchronize sync (java::net::InetAddress::loopbackAddress);\n-      hptr = gethostbyname (hostname);\n-    }\n-  else\n-    {\n-      jbyteArray bytes = iaddr->addr;\n-      char *chars = (char*) elements (bytes);\n-      int len = bytes->length;\n-      int type;\n-      char *val;\n-      if (len == 4)\n-        {\n-          val = chars;\n-          type = iaddr->family = AF_INET;\n-        }\n-#ifdef HAVE_INET6\n-      else if (len == 16)\n-      {\n-        val = (char *) &chars;\n-        type = iaddr->family = AF_INET6;\n-      }\n-#endif /* HAVE_INET6 */\n-      else\n-        JvFail (\"unrecognized size\");\n-\n-      // FIXME: this is insufficient if some other piece of code calls\n-      // this gethostbyaddr.\n-      JvSynchronize sync (java::net::InetAddress::loopbackAddress);\n-      hptr = gethostbyaddr (val, len, type);\n-    }\n-  if (hptr != NULL)\n-    {\n-      if (!all)\n-        host = JvNewStringUTF (hptr->h_name);\n-      java::lang::SecurityException *ex = checkConnect (host);\n-      if (ex != NULL)\n-        {\n-          if (iaddr == NULL || iaddr->addr == NULL)\n-            throw ex;\n-          hptr = NULL;\n-        }\n-    }\n-  if (hptr == NULL)\n-    {\n-      if (iaddr != NULL && iaddr->addr != NULL)\n-        {\n-          iaddr->hostName = iaddr->getHostAddress();\n-          return NULL;\n-        }\n-      else\n-        throw new java::net::UnknownHostException(host);\n-    }\n-\n-  int count;\n-  if (all)\n-    {\n-      char** ptr = hptr->h_addr_list;\n-      count = 0;\n-      while (*ptr++)  count++;\n-    }\n-  else\n-    count = 1;\n-\n-  JArray<java::net::InetAddress*> *result;\n-  java::net::InetAddress** iaddrs;\n-  if (all)\n-    {\n-      result = java::net::InetAddress::allocArray (count);\n-      iaddrs = elements (result);\n-    }\n-  else\n-    {\n-      result = NULL;\n-      iaddrs = &iaddr;\n-    }\n-\n-  for (int i = 0;  i < count;  i++)\n-    {\n-      if (iaddrs[i] == NULL)\n-        iaddrs[i] = new java::net::InetAddress (NULL, NULL);\n-      if (iaddrs[i]->hostName == NULL)\n-        iaddrs[i]->hostName = host;\n-      if (iaddrs[i]->addr == NULL)\n-        {\n-          char *bytes = hptr->h_addr_list[i];\n-          iaddrs[i]->addr = JvNewByteArray (hptr->h_length);\n-          iaddrs[i]->family = getFamily (iaddrs[i]->addr);\n-          memcpy (elements (iaddrs[i]->addr), bytes, hptr->h_length);\n-        }\n-    }\n-    \n-  return result;\n-}\n-\n-jstring\n-java::net::InetAddress::getLocalHostname ()\n-{\n-  char buffer[400];\n-  if (gethostname (buffer, sizeof(buffer)))\n-    return NULL;\n-  // It is admittedly non-optimal to convert the hostname to Unicode\n-  // only to convert it back in getByName, but simplicity wins.  Note\n-  // that unless there is a SecurityManager, we only get called once\n-  // anyway, thanks to the InetAddress.localhost cache.\n-  return JvNewStringUTF (buffer);\n-}"}, {"sha": "fd8303bbe6ce50de56aac48af5fc50b34bf8f0e1", "filename": "libjava/java/net/natVMInetAddressNoNet.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2Fjava%2Fnet%2FnatVMInetAddressNoNet.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2Fjava%2Fnet%2FnatVMInetAddressNoNet.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatVMInetAddressNoNet.cc?ref=adefdaca2d8aa874f3e1f5b8be2736355292b6a4", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2003, 2006  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+#include <stddef.h>\n+\n+jstring\n+java::net::VMInetAddress::getLocalHostname ()\n+{\n+  return NULL;\n+}\n+\n+jbyteArray\n+java::net::VMInetAddress::lookupInaddrAny ()\n+{\n+  return NULL;\n+}\n+\n+jstring\n+java::net::VMInetAddress::getHostByAddr (jbyteArray addr)\n+{\n+  return NULL;\n+}\n+\n+JArray<jbyteArray> *\n+java::net::VMInetAddress::getHostByName (jstring host)\n+{\n+  return NULL;\n+}\n+\n+jbyteArray\n+java::net::VMInetAddress::aton (jstring host)\n+{\n+  return NULL;\n+}"}, {"sha": "7fbe1bb1ff0a220672ddc0098ae45ef7b6708c6d", "filename": "libjava/java/net/natVMInetAddressPosix.cc", "status": "added", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2Fjava%2Fnet%2FnatVMInetAddressPosix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2Fjava%2Fnet%2FnatVMInetAddressPosix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatVMInetAddressPosix.cc?ref=adefdaca2d8aa874f3e1f5b8be2736355292b6a4", "patch": "@@ -0,0 +1,289 @@\n+/* Copyright (C) 2003, 2006  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+#include <string.h>\n+#include <errno.h>\n+\n+#include <sys/param.h>\n+#include <sys/types.h>\n+#ifdef HAVE_SYS_SOCKET_H\n+#include <sys/socket.h>\n+#endif\n+#ifdef HAVE_NETINET_IN_H\n+#include <netinet/in.h>\n+#endif\n+#ifdef HAVE_ARPA_INET_H\n+#include <arpa/inet.h>\n+#endif\n+#ifdef HAVE_NETDB_H\n+#include <netdb.h>\n+#endif\n+\n+#include <gcj/cni.h>\n+#include <jvm.h>\n+#include <java/net/VMInetAddress.h>\n+#include <java/net/UnknownHostException.h>\n+\n+#if defined(HAVE_UNAME) && ! defined(HAVE_GETHOSTNAME)\n+#include <sys/utsname.h>\n+#endif\n+\n+#ifndef HAVE_GETHOSTNAME_DECL\n+extern \"C\" int gethostname (char *name, int namelen);\n+#endif\n+\n+jstring\n+java::net::VMInetAddress::getLocalHostname ()\n+{\n+  char *chars;\n+#ifdef HAVE_GETHOSTNAME\n+  char buffer[MAXHOSTNAMELEN];\n+  if (gethostname (buffer, MAXHOSTNAMELEN))\n+    return NULL;\n+  chars = buffer;\n+#elif HAVE_UNAME\n+  struct utsname stuff;\n+  if (uname (&stuff) != 0)\n+    return NULL;\n+  chars = stuff.nodename;\n+#else\n+  return NULL;\n+#endif\n+  // It is admittedly non-optimal to convert the hostname to Unicode\n+  // only to convert it back in getByName, but simplicity wins.\n+  return JvNewStringUTF (chars);\n+}\n+\n+jbyteArray\n+java::net::VMInetAddress::lookupInaddrAny ()\n+{\n+#if ! HAVE_IN_ADDR_T\n+  typedef jint in_addr_t;\n+#endif\n+  in_addr_t laddr = INADDR_ANY;\n+  char *bytes = (char *) &laddr;\n+  int blen = sizeof (laddr);\n+  jbyteArray result = JvNewByteArray (blen);\n+  memcpy (elements (result), bytes, blen);\n+  return result;\n+}\n+\n+jstring\n+java::net::VMInetAddress::getHostByAddr (jbyteArray addr)\n+{\n+  struct hostent *hptr = NULL;\n+#ifdef HAVE_GETHOSTBYADDR_R\n+  struct hostent hent_r;\n+#if HAVE_STRUCT_HOSTENT_DATA\n+  struct hostent_data fixed_buffer, *buffer_r = &fixed_buffer;\n+#else\n+#ifdef __GLIBC__\n+  // FIXME: in glibc, gethostbyname_r returns NETDB_INTERNAL to herr and\n+  // ERANGE to errno if the buffer size is too small, rather than what is \n+  // expected here. We work around this by setting a bigger buffer size and \n+  // hoping that it is big enough.\n+  char fixed_buffer[1024];\n+#else\n+  char fixed_buffer[200];\n+#endif /* __GLIBC__ */\n+  char *buffer_r = fixed_buffer;\n+  int size_r = sizeof (fixed_buffer);\n+#endif /* HAVE_STRUCT_HOSTENT_DATA */\n+#endif /* HAVE_GETHOSTBYADDR_R */\n+\n+  char *bytes = (char*) elements (addr);\n+  int len = addr->length;\n+  int type;\n+  char *val;\n+  if (len == 4)\n+    {\n+      val = bytes;\n+      type = AF_INET;\n+    }\n+#ifdef HAVE_INET6\n+  else if (len == 16)\n+    {\n+      val = (char *) &bytes;\n+      type = AF_INET6;\n+    }\n+#endif /* HAVE_INET6 */\n+  else\n+    JvFail (\"unrecognized size\");\n+\n+#ifdef HAVE_GETHOSTBYADDR_R\n+  while (true)\n+    {\n+      int ok;\n+#if HAVE_STRUCT_HOSTENT_DATA\n+      ok = ! gethostbyaddr_r (val, len, type, &hent_r, buffer_r);\n+#else\n+      int herr = 0;\n+#ifdef GETHOSTBYADDR_R_RETURNS_INT\n+      ok = ! gethostbyaddr_r (val, len, type, &hent_r,\n+\t\t\t      buffer_r, size_r, &hptr, &herr);\n+#else\n+      hptr = gethostbyaddr_r (val, len, type, &hent_r,\n+\t\t\t      buffer_r, size_r, &herr);\n+      ok = hptr != NULL;\n+#endif /* GETHOSTBYADDR_R_RETURNS_INT */\n+      if (! ok && herr == ERANGE)\n+\t{\n+\t  size_r *= 2;\n+\t  buffer_r = (char *) _Jv_AllocBytes (size_r);\n+\t}\n+      else \n+#endif /* HAVE_STRUCT_HOSTENT_DATA */\n+\tbreak;\n+    }\n+#else /* HAVE_GETHOSTBYADDR_R */\n+  // FIXME: this is insufficient if some other piece of code calls\n+  // this gethostbyaddr.\n+  JvSynchronize sync (&java::net::VMInetAddress::class$);\n+  hptr = gethostbyaddr (val, len, type);\n+#endif /* HAVE_GETHOSTBYADDR_R */\n+\n+  if (hptr == NULL)\n+    throw new java::net::UnknownHostException ();\n+\n+  return JvNewStringUTF (hptr->h_name);\n+}\n+\n+JArray<jbyteArray> *\n+java::net::VMInetAddress::getHostByName (jstring host)\n+{\n+  struct hostent *hptr = NULL;\n+#ifdef HAVE_GETHOSTBYNAME_R\n+  struct hostent hent_r;\n+#if HAVE_STRUCT_HOSTENT_DATA\n+  struct hostent_data fixed_buffer, *buffer_r = &fixed_buffer;\n+#else\n+#ifdef __GLIBC__\n+  // FIXME: in glibc, gethostbyname_r returns NETDB_INTERNAL to herr and\n+  // ERANGE to errno if the buffer size is too small, rather than what is \n+  // expected here. We work around this by setting a bigger buffer size and \n+  // hoping that it is big enough.\n+  char fixed_buffer[1024];\n+#else\n+  char fixed_buffer[200];\n+#endif /* __GLIBC__ */\n+  char *buffer_r = fixed_buffer;\n+  int size_r = sizeof (fixed_buffer);\n+#endif /* HAVE_STRUCT_HOSTENT_DATA */\n+#endif /* HAVE_GETHOSTBYNAME_R */\n+\n+  char *hostname;\n+  char buf[100];\n+  int len = JvGetStringUTFLength(host);\n+  if (len < 100)\n+    hostname = buf;\n+  else\n+    hostname = (char *) _Jv_AllocBytes (len + 1);\n+  JvGetStringUTFRegion (host, 0, host->length(), hostname);\n+  buf[len] = '\\0';\n+#ifdef HAVE_GETHOSTBYNAME_R\n+  while (true)\n+    {\n+      int ok;\n+#if HAVE_STRUCT_HOSTENT_DATA\n+      ok = ! gethostbyname_r (hostname, &hent_r, buffer_r);\n+#else\n+      int herr = 0;\n+#ifdef GETHOSTBYNAME_R_RETURNS_INT\n+      ok = ! gethostbyname_r (hostname, &hent_r, buffer_r, size_r,\n+\t\t\t      &hptr, &herr);\n+#else\n+      hptr = gethostbyname_r (hostname, &hent_r, buffer_r, size_r, &herr);\n+      ok = hptr != NULL;\n+#endif /* GETHOSTNAME_R_RETURNS_INT */\n+      if (! ok && herr == ERANGE)\n+\t{\n+\t  size_r *= 2;\n+\t  buffer_r = (char *) _Jv_AllocBytes (size_r);\n+\t}\n+      else\n+#endif /* HAVE_STRUCT_HOSTENT_DATA */\n+\tbreak;\n+    }\n+#else /* HAVE_GETHOSTBYNAME_R */\n+  // FIXME: this is insufficient if some other piece of code calls\n+  // this gethostbyname.\n+  JvSynchronize sync (&java::net::VMInetAddress::class$);\n+  hptr = gethostbyname (hostname);\n+#endif /* HAVE_GETHOSTBYNAME_R */\n+\n+  if (hptr == NULL)\n+    throw new java::net::UnknownHostException (host);\n+\n+  int count = 0;\n+  char ** ptr = hptr->h_addr_list;\n+  while (*ptr++)  count++;\n+\n+  JArray<jbyteArray> *result =\n+    (JArray<jbyteArray> *) _Jv_NewObjectArray (\n+      count, _Jv_GetArrayClass(JvPrimClass(byte), NULL), NULL);\n+  jbyteArray* addrs = elements (result);\n+\n+  for (int i = 0; i < count; i++)\n+    {\n+      addrs[i] = JvNewByteArray (hptr->h_length);\n+      memcpy (elements (addrs[i]), hptr->h_addr_list[i], hptr->h_length);\n+    }\n+  return result;\n+}\n+\n+jbyteArray\n+java::net::VMInetAddress::aton (jstring host)\n+{\n+  char *hostname;\n+  char buf[100];\n+  int len = JvGetStringUTFLength(host);\n+  if (len < 100)\n+    hostname = buf;\n+  else\n+    hostname = (char *) _Jv_AllocBytes (len+1);\n+  JvGetStringUTFRegion (host, 0, host->length(), hostname);\n+  buf[len] = '\\0';\n+  char *bytes = NULL;\n+  int blen = 0;\n+#ifdef HAVE_INET_ATON\n+  struct in_addr laddr;\n+  if (inet_aton (hostname, &laddr))\n+    {\n+      bytes = (char *) &laddr;\n+      blen = 4;\n+    }\n+#elif defined(HAVE_INET_ADDR)\n+#if ! HAVE_IN_ADDR_T\n+  typedef jint in_addr_t;\n+#endif\n+  in_addr_t laddr = inet_addr (hostname);\n+  if (laddr != (in_addr_t)(-1))\n+    {\n+      bytes = (char *) &laddr;\n+      blen = 4;\n+    }\n+#endif\n+#if defined (HAVE_INET_PTON) && defined (HAVE_INET6)\n+  char inet6_addr[16];\n+  if (len != 0 && inet_pton (AF_INET6, hostname, inet6_addr) > 0)\n+    {\n+      bytes = inet6_addr;\n+      blen = 16;\n+    }\n+#endif\n+  if (blen == 0)\n+    return NULL;\n+  jbyteArray result = JvNewByteArray (blen);\n+  memcpy (elements (result), bytes, blen);\n+  return result;\n+}"}, {"sha": "259480faa96a165beef39eb3cf2055f66f6e8ce7", "filename": "libjava/java/net/natVMInetAddressWin32.cc", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2Fjava%2Fnet%2FnatVMInetAddressWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2Fjava%2Fnet%2FnatVMInetAddressWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatVMInetAddressWin32.cc?ref=adefdaca2d8aa874f3e1f5b8be2736355292b6a4", "patch": "@@ -0,0 +1,121 @@\n+/* Copyright (C) 2003, 2006 Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+#include <platform.h>\n+\n+#undef STRICT\n+\n+#include <java/net/VMInetAddress.h>\n+#include <java/net/UnknownHostException.h>\n+\n+jstring\n+java::net::VMInetAddress::getLocalHostname ()\n+{\n+  char buffer[400];\n+  if (gethostname (buffer, sizeof(buffer)))\n+    return NULL;\n+  // It is admittedly non-optimal to convert the hostname to Unicode\n+  // only to convert it back in getByName, but simplicity wins.\n+  return JvNewStringUTF (buffer);\n+}\n+\n+jbyteArray\n+java::net::VMInetAddress::lookupInaddrAny ()\n+{\n+  unsigned long laddr = INADDR_ANY;\n+  char *bytes = (char *) &laddr;\n+  int blen = sizeof (laddr);\n+  jbyteArray result = JvNewByteArray (blen);\n+  memcpy (elements (result), bytes, blen);\n+  return result;\n+}\n+\n+jstring\n+java::net::VMInetAddress::getHostByAddr (jbyteArray addr)\n+{\n+  struct hostent *hptr = NULL;\n+  char *bytes = (char*) elements (addr);\n+  int len = addr->length;\n+  int type;\n+  char *val;\n+  if (len == 4)\n+    {\n+      val = bytes;\n+      type = AF_INET;\n+    }\n+#ifdef HAVE_INET6\n+  else if (len == 16)\n+    {\n+      val = (char *) &bytes;\n+      type = AF_INET6;\n+    }\n+#endif /* HAVE_INET6 */\n+  else\n+    JvFail (\"unrecognized size\");\n+\n+  // FIXME: this is insufficient if some other piece of code calls\n+  // this gethostbyaddr.\n+  JvSynchronize sync (&java::net::VMInetAddress::class$);\n+  hptr = gethostbyaddr (val, len, type);\n+\n+  if (hptr == NULL)\n+    throw new java::net::UnknownHostException ();\n+\n+  return JvNewStringUTF (hptr->h_name);\n+}\n+\n+JArray<jbyteArray> *\n+java::net::VMInetAddress::getHostByName (jstring host)\n+{\n+  struct hostent *hptr = NULL;\n+  JV_TEMP_UTF_STRING (hostname, host);\n+\n+  // FIXME: this is insufficient if some other piece of code calls\n+  // this gethostbyname.\n+  JvSynchronize sync (&java::net::VMInetAddress::class$);\n+  hptr = gethostbyname (hostname);\n+\n+  if (hptr == NULL)\n+    throw new java::net::UnknownHostException (host);\n+\n+  int count = 0;\n+  char ** ptr = hptr->h_addr_list;\n+  while (*ptr++)  count++;\n+\n+  JArray<jbyteArray> *result =\n+    (JArray<jbyteArray> *) _Jv_NewObjectArray (\n+      count, _Jv_GetArrayClass(JvPrimClass(byte), NULL), NULL);\n+  jbyteArray* addrs = elements (result);\n+\n+  for (int i = 0; i < count; i++)\n+    {\n+      addrs[i] = JvNewByteArray (hptr->h_length);\n+      memcpy (elements (addrs[i]), hptr->h_addr_list[i], hptr->h_length);\n+    }\n+  return result;\n+}\n+\n+jbyteArray\n+java::net::VMInetAddress::aton (jstring host)\n+{\n+  JV_TEMP_UTF_STRING (hostname, host);\n+  char* bytes = NULL;\n+  int blen = 0;\n+  unsigned long laddr = inet_addr (hostname);\n+  if (laddr != INADDR_NONE)\n+    {\n+      bytes = (char *) &laddr;\n+      blen = 4;\n+    }\n+  if (blen == 0)\n+    return NULL;\n+  jbyteArray result = JvNewByteArray (blen);\n+  memcpy (elements (result), bytes, blen);\n+  return result;\n+}"}, {"sha": "c9b14d57da8d4adcf27511e515865d6dd1a9ca35", "filename": "libjava/java/net/natVMNetworkInterfaceWin32.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2Fjava%2Fnet%2FnatVMNetworkInterfaceWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2Fjava%2Fnet%2FnatVMNetworkInterfaceWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatVMNetworkInterfaceWin32.cc?ref=adefdaca2d8aa874f3e1f5b8be2736355292b6a4", "patch": "@@ -12,7 +12,7 @@ details.  */\n #undef STRICT\n \n #include <java/net/NetworkInterface.h>\n-#include <java/net/Inet4Address.h>\n+#include <java/net/InetAddress.h>\n #include <java/net/SocketException.h>\n #include <java/net/VMNetworkInterface.h>\n #include <java/util/Vector.h>\n@@ -83,8 +83,8 @@ winsock2GetRealNetworkInterfaces (jstring* pjstrName,\n         }\n \n       jstring if_name = _Jv_Win32NewString (szName);\n-      java::net::Inet4Address* address =\n-        new java::net::Inet4Address (baddr, JvNewStringLatin1 (\"\"));\n+      java::net::InetAddress* address =\n+        java::net::InetAddress::getByAddress (baddr);\n       pjstrName[i] = if_name;\n       ppAddress[i] = address;\n     }"}, {"sha": "b13633f4664654af62c2e3cc0de449ba35c50a93", "filename": "libjava/sources.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2Fsources.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adefdaca2d8aa874f3e1f5b8be2736355292b6a4/libjava%2Fsources.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsources.am?ref=adefdaca2d8aa874f3e1f5b8be2736355292b6a4", "patch": "@@ -5229,7 +5229,7 @@ classpath/java/net/FileNameMap.java \\\n classpath/java/net/HttpURLConnection.java \\\n classpath/java/net/Inet4Address.java \\\n classpath/java/net/Inet6Address.java \\\n-java/net/InetAddress.java \\\n+classpath/java/net/InetAddress.java \\\n classpath/java/net/InetSocketAddress.java \\\n classpath/java/net/JarURLConnection.java \\\n classpath/java/net/MalformedURLException.java \\"}]}