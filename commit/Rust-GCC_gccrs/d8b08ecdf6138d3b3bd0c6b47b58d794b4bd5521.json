{"sha": "d8b08ecdf6138d3b3bd0c6b47b58d794b4bd5521", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhiMDhlY2RmNjEzOGQzYjNiZDBjNmI0N2I1OGQ3OTRiNGJkNTUyMQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-09-01T12:26:49Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-09-01T12:26:49Z"}, "message": "i386.h (enum ix86_tune_indices): Rename from X86_TUNE_ADD_ESP_4.\n\n\t* config/i386/i386.h (enum ix86_tune_indices) <X86_TUNE_SINGLE_POP>:\n\tRename from X86_TUNE_ADD_ESP_4.\n\t<IX86_TUNE_DOUBLE_POP>: Rename from X86_TUNE_ADD_ESP_8.\n\t<IX86_TUNE_SINGLE_PUSH>: Rename from X86_TUNE_SUB_ESP_4.\n\t<IX86_TUNE_DOUBLE_PUSH>: Rename from X86_TUNE_SUB_ESP_8.\n\t(TARGET_SINGLE_POP): Rename from TARGET_ADD_ESP_4.\n\t(TARGET_DOUBLE_POP): Rename from TARGET_ADD_ESP_8.\n\t(TARGET_SINGLE_PUSH): Rename from TARGET_SUB_ESP_4.\n\t(TARGET_DOUBLE_POP): Rename from TARGET_SUB_ESP_8.\n\t* config/i386/i386.c (initial_ix86_tune_features)\n\t<X86_TUNE_SINGLE_POP>: Invert members.\n\t<X86_TUNE_DOUBLE_POP>: Ditto.\n\t<X86_TUNE_SINGLE_PUSH>: Ditto.\n\t<X86_TUNE_DOUBLE_PUSH>: Ditto.\n\t* config/i386/i386.md (*pop<mode>1): Rename from pop<mode>1.\n\tNo longer exported.\n\t(push peephole2 patterns): Macroize peepholes using P mode iterator.\n\tAdjust for renamed TARGET_{SINGLE,DOUBLE}_PUSH defines.\n\t(pop peephole2 patterns): Macroize peepholes using P mode iterator.\n\tAdjust for renamed TARGET_{SINGLE,DOUBLE}_POP defines.\n\nFrom-SVN: r163732", "tree": {"sha": "3ea0c66d0218c652e027b8de27b13fa5e246d828", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ea0c66d0218c652e027b8de27b13fa5e246d828"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8b08ecdf6138d3b3bd0c6b47b58d794b4bd5521", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8b08ecdf6138d3b3bd0c6b47b58d794b4bd5521", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8b08ecdf6138d3b3bd0c6b47b58d794b4bd5521", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8b08ecdf6138d3b3bd0c6b47b58d794b4bd5521/comments", "author": null, "committer": null, "parents": [{"sha": "558af7ca1ccbaa309e390e871c620574a7446e4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/558af7ca1ccbaa309e390e871c620574a7446e4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/558af7ca1ccbaa309e390e871c620574a7446e4f"}], "stats": {"total": 304, "additions": 127, "deletions": 177}, "files": [{"sha": "970394e60ba2c3d7063d7862656b8a71cf15d0fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8b08ecdf6138d3b3bd0c6b47b58d794b4bd5521/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8b08ecdf6138d3b3bd0c6b47b58d794b4bd5521/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d8b08ecdf6138d3b3bd0c6b47b58d794b4bd5521", "patch": "@@ -1,3 +1,26 @@\n+2010-09-01  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.h (enum ix86_tune_indices) <X86_TUNE_SINGLE_POP>:\n+\tRename from X86_TUNE_ADD_ESP_4.\n+\t<IX86_TUNE_DOUBLE_POP>: Rename from X86_TUNE_ADD_ESP_8.\n+\t<IX86_TUNE_SINGLE_PUSH>: Rename from X86_TUNE_SUB_ESP_4.\n+\t<IX86_TUNE_DOUBLE_PUSH>: Rename from X86_TUNE_SUB_ESP_8.\n+\t(TARGET_SINGLE_POP): Rename from TARGET_ADD_ESP_4.\n+\t(TARGET_DOUBLE_POP): Rename from TARGET_ADD_ESP_8.\n+\t(TARGET_SINGLE_PUSH): Rename from TARGET_SUB_ESP_4.\n+\t(TARGET_DOUBLE_POP): Rename from TARGET_SUB_ESP_8.\n+\t* config/i386/i386.c (initial_ix86_tune_features)\n+\t<X86_TUNE_SINGLE_POP>: Invert members.\n+\t<X86_TUNE_DOUBLE_POP>: Ditto.\n+\t<X86_TUNE_SINGLE_PUSH>: Ditto.\n+\t<X86_TUNE_DOUBLE_PUSH>: Ditto.\n+\t* config/i386/i386.md (*pop<mode>1): Rename from pop<mode>1.\n+\tNo longer exported.\n+\t(push peephole2 patterns): Macroize peepholes using P mode iterator.\n+\tAdjust for renamed TARGET_{SINGLE,DOUBLE}_PUSH defines.\n+\t(pop peephole2 patterns): Macroize peepholes using P mode iterator.\n+\tAdjust for renamed TARGET_{SINGLE,DOUBLE}_POP defines.\n+\n 2010-09-01  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gimplify.c (gimplify_init_constructor): Do not create a temporary for\n@@ -10,21 +33,19 @@\n \t* tree.h (stdarg_p): Likewise.\n \t(function_args_iterator): Remove unused fntype field.\n \t(function_args_iter_init): Do not initialize fntype\n-\tfield.  Make fntype parameter const. \n+\tfield.  Make fntype parameter const.\n \n 2010-09-01  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-vrp.c (adjust_range_with_scev): Use number of iteration\n \testimate.\n-\t(vrp_visit_phi_node): Delay using SCEV till we balloon the\n-\trange.\n+\t(vrp_visit_phi_node): Delay using SCEV till we balloon the range.\n \t(execute_vrp): Compute number of iteration estimates.\n \t* cfgloop.h (estimate_numbers_of_iterations_loop): Adjust prototype.\n \t* tree-flow.h (estimate_numbers_of_iterations): Likewise.\n \t* tree-data-ref.c (estimated_loop_iterations): Adjust.\n \t* tree-ssa-loop-niter.c (estimate_numbers_of_iterations_loop):\n-\tInfer loop bounds from undefined behavior based on a new\n-\tparameter.\n+\tInfer loop bounds from undefined behavior based on a new parameter.\n \t(estimate_numbers_of_iterations): Likewise.\n \t(scev_probably_wraps_p): Adjust.\n \t* tree-ssa-loop.c (tree_ssa_loop_bounds): Likewise."}, {"sha": "b550d8660f0b5134372b9867d27cfd0bace8761a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8b08ecdf6138d3b3bd0c6b47b58d794b4bd5521/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8b08ecdf6138d3b3bd0c6b47b58d794b4bd5521/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d8b08ecdf6138d3b3bd0c6b47b58d794b4bd5521", "patch": "@@ -1480,21 +1480,21 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {\n   /* X86_TUNE_PROMOTE_HI_REGS */\n   m_PPRO,\n \n-  /* X86_TUNE_ADD_ESP_4: Enable if add/sub is preferred over 1/2 push/pop.  */\n-  m_ATOM | m_AMD_MULTIPLE | m_K6_GEODE | m_PENT4 | m_NOCONA\n-  | m_CORE2 | m_GENERIC,\n+  /* X86_TUNE_SINGLE_POP: Enable if single pop insn is preferred\n+     over esp addition.  */\n+  m_386 | m_486 | m_PENT | m_PPRO,\n \n-  /* X86_TUNE_ADD_ESP_8 */\n-  m_AMD_MULTIPLE | m_ATOM | m_PPRO | m_K6_GEODE | m_386\n-  | m_486 | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC,\n+  /* X86_TUNE_DOUBLE_POP: Enable if double pop insn is preferred\n+     over esp addition.  */\n+  m_PENT,\n \n-  /* X86_TUNE_SUB_ESP_4 */\n-  m_AMD_MULTIPLE | m_ATOM | m_PPRO | m_PENT4 | m_NOCONA | m_CORE2\n-  | m_GENERIC,\n+  /* X86_TUNE_SINGLE_PUSH: Enable if single push insn is preferred\n+     over esp subtraction.  */\n+  m_386 | m_486 | m_PENT | m_K6_GEODE,\n \n-  /* X86_TUNE_SUB_ESP_8 */\n-  m_AMD_MULTIPLE | m_ATOM | m_PPRO | m_386 | m_486\n-  | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC,\n+  /* X86_TUNE_DOUBLE_PUSH. Enable if double push insn is preferred\n+     over esp subtraction.  */\n+  m_PENT | m_K6_GEODE,\n \n   /* X86_TUNE_INTEGER_DFMODE_MOVES: Enable if integer moves are preferred\n      for DFmode copies */"}, {"sha": "ea36c112ec2f1c4fd7ff5a14ede04fd41948723d", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8b08ecdf6138d3b3bd0c6b47b58d794b4bd5521/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8b08ecdf6138d3b3bd0c6b47b58d794b4bd5521/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=d8b08ecdf6138d3b3bd0c6b47b58d794b4bd5521", "patch": "@@ -274,10 +274,10 @@ enum ix86_tune_indices {\n   X86_TUNE_HIMODE_MATH,\n   X86_TUNE_PROMOTE_QI_REGS,\n   X86_TUNE_PROMOTE_HI_REGS,\n-  X86_TUNE_ADD_ESP_4,\n-  X86_TUNE_ADD_ESP_8,\n-  X86_TUNE_SUB_ESP_4,\n-  X86_TUNE_SUB_ESP_8,\n+  X86_TUNE_SINGLE_POP,\n+  X86_TUNE_DOUBLE_POP,\n+  X86_TUNE_SINGLE_PUSH,\n+  X86_TUNE_DOUBLE_PUSH,\n   X86_TUNE_INTEGER_DFMODE_MOVES,\n   X86_TUNE_PARTIAL_REG_DEPENDENCY,\n   X86_TUNE_SSE_PARTIAL_REG_DEPENDENCY,\n@@ -348,10 +348,10 @@ extern unsigned char ix86_tune_features[X86_TUNE_LAST];\n #define TARGET_HIMODE_MATH\tix86_tune_features[X86_TUNE_HIMODE_MATH]\n #define TARGET_PROMOTE_QI_REGS\tix86_tune_features[X86_TUNE_PROMOTE_QI_REGS]\n #define TARGET_PROMOTE_HI_REGS\tix86_tune_features[X86_TUNE_PROMOTE_HI_REGS]\n-#define TARGET_ADD_ESP_4\tix86_tune_features[X86_TUNE_ADD_ESP_4]\n-#define TARGET_ADD_ESP_8\tix86_tune_features[X86_TUNE_ADD_ESP_8]\n-#define TARGET_SUB_ESP_4\tix86_tune_features[X86_TUNE_SUB_ESP_4]\n-#define TARGET_SUB_ESP_8\tix86_tune_features[X86_TUNE_SUB_ESP_8]\n+#define TARGET_SINGLE_POP\tix86_tune_features[X86_TUNE_SINGLE_POP]\n+#define TARGET_DOUBLE_POP\tix86_tune_features[X86_TUNE_DOUBLE_POP]\n+#define TARGET_SINGLE_PUSH\tix86_tune_features[X86_TUNE_SINGLE_PUSH]\n+#define TARGET_DOUBLE_PUSH\tix86_tune_features[X86_TUNE_DOUBLE_PUSH]\n #define TARGET_INTEGER_DFMODE_MOVES \\\n \tix86_tune_features[X86_TUNE_INTEGER_DFMODE_MOVES]\n #define TARGET_PARTIAL_REG_DEPENDENCY \\"}, {"sha": "ab3c1aebc6255ea5909e970ab44348d1b00bb447", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 81, "deletions": 152, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8b08ecdf6138d3b3bd0c6b47b58d794b4bd5521/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8b08ecdf6138d3b3bd0c6b47b58d794b4bd5521/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=d8b08ecdf6138d3b3bd0c6b47b58d794b4bd5521", "patch": "@@ -1749,7 +1749,7 @@\n   [(set_attr \"type\" \"push\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"pop<mode>1\"\n+(define_insn \"*pop<mode>1\"\n   [(set (match_operand:P 0 \"nonimmediate_operand\" \"=r*m\")\n \t(match_operand:P 1 \"pop_operand\" \">\"))]\n   \"\"\n@@ -17025,202 +17025,131 @@\n ;; alternative when no register is available later.\n \n (define_peephole2\n-  [(match_scratch:SI 0 \"r\")\n-   (parallel [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int -4)))\n+  [(match_scratch:P 1 \"r\")\n+   (parallel [(set (reg:P SP_REG)\n+\t\t   (plus:P (reg:P SP_REG)\n+\t\t\t   (match_operand:P 0 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))\n \t      (clobber (mem:BLK (scratch)))])]\n-  \"optimize_insn_for_size_p () || !TARGET_SUB_ESP_4\"\n-  [(clobber (match_dup 0))\n-   (parallel [(set (mem:SI (pre_dec:SI (reg:SI SP_REG))) (match_dup 0))\n+  \"(TARGET_SINGLE_PUSH || optimize_insn_for_size_p ())\n+   && INTVAL (operands[0]) == -GET_MODE_SIZE (Pmode)\"\n+  [(clobber (match_dup 1))\n+   (parallel [(set (mem:P (pre_dec:P (reg:P SP_REG))) (match_dup 1))\n \t      (clobber (mem:BLK (scratch)))])])\n \n (define_peephole2\n-  [(match_scratch:SI 0 \"r\")\n-   (parallel [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int -8)))\n+  [(match_scratch:P 1 \"r\")\n+   (parallel [(set (reg:P SP_REG)\n+\t\t   (plus:P (reg:P SP_REG)\n+\t\t\t   (match_operand:P 0 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))\n \t      (clobber (mem:BLK (scratch)))])]\n-  \"optimize_insn_for_size_p () || !TARGET_SUB_ESP_8\"\n-  [(clobber (match_dup 0))\n-   (set (mem:SI (pre_dec:SI (reg:SI SP_REG))) (match_dup 0))\n-   (parallel [(set (mem:SI (pre_dec:SI (reg:SI SP_REG))) (match_dup 0))\n+  \"(TARGET_DOUBLE_PUSH || optimize_insn_for_size_p ())\n+   && INTVAL (operands[0]) == -2*GET_MODE_SIZE (Pmode)\"\n+  [(clobber (match_dup 1))\n+   (set (mem:P (pre_dec:P (reg:P SP_REG))) (match_dup 1))\n+   (parallel [(set (mem:P (pre_dec:P (reg:P SP_REG))) (match_dup 1))\n \t      (clobber (mem:BLK (scratch)))])])\n \n ;; Convert esp subtractions to push.\n (define_peephole2\n-  [(match_scratch:SI 0 \"r\")\n-   (parallel [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int -4)))\n+  [(match_scratch:P 1 \"r\")\n+   (parallel [(set (reg:P SP_REG)\n+\t\t   (plus:P (reg:P SP_REG)\n+\t\t\t   (match_operand:P 0 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"optimize_insn_for_size_p () || !TARGET_SUB_ESP_4\"\n-  [(clobber (match_dup 0))\n-   (set (mem:SI (pre_dec:SI (reg:SI SP_REG))) (match_dup 0))])\n+  \"(TARGET_SINGLE_PUSH || optimize_insn_for_size_p ())\n+   && INTVAL (operands[0]) == -GET_MODE_SIZE (Pmode)\"\n+  [(clobber (match_dup 1))\n+   (set (mem:P (pre_dec:P (reg:P SP_REG))) (match_dup 1))])\n \n (define_peephole2\n-  [(match_scratch:SI 0 \"r\")\n-   (parallel [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int -8)))\n+  [(match_scratch:P 1 \"r\")\n+   (parallel [(set (reg:P SP_REG)\n+\t\t   (plus:P (reg:P SP_REG)\n+\t\t\t   (match_operand:P 0 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"optimize_insn_for_size_p () || !TARGET_SUB_ESP_8\"\n-  [(clobber (match_dup 0))\n-   (set (mem:SI (pre_dec:SI (reg:SI SP_REG))) (match_dup 0))\n-   (set (mem:SI (pre_dec:SI (reg:SI SP_REG))) (match_dup 0))])\n+  \"(TARGET_DOUBLE_PUSH || optimize_insn_for_size_p ())\n+   && INTVAL (operands[0]) == -2*GET_MODE_SIZE (Pmode)\"\n+  [(clobber (match_dup 1))\n+   (set (mem:P (pre_dec:P (reg:P SP_REG))) (match_dup 1))\n+   (set (mem:P (pre_dec:P (reg:P SP_REG))) (match_dup 1))])\n \n ;; Convert epilogue deallocator to pop.\n (define_peephole2\n-  [(match_scratch:SI 0 \"r\")\n-   (parallel [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 4)))\n+  [(match_scratch:P 1 \"r\")\n+   (parallel [(set (reg:P SP_REG)\n+\t\t   (plus:P (reg:P SP_REG)\n+\t\t\t   (match_operand:P 0 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))\n \t      (clobber (mem:BLK (scratch)))])]\n-  \"optimize_insn_for_size_p () || !TARGET_ADD_ESP_4\"\n-  [(parallel [(set (match_dup 0) (mem:SI (post_inc:SI (reg:SI SP_REG))))\n+  \"(TARGET_SINGLE_POP || optimize_insn_for_size_p ())\n+   && INTVAL (operands[0]) == GET_MODE_SIZE (Pmode)\"\n+  [(parallel [(set (match_dup 1) (mem:P (post_inc:P (reg:P SP_REG))))\n \t      (clobber (mem:BLK (scratch)))])])\n \n ;; Two pops case is tricky, since pop causes dependency\n ;; on destination register.  We use two registers if available.\n (define_peephole2\n-  [(match_scratch:SI 0 \"r\")\n-   (match_scratch:SI 1 \"r\")\n-   (parallel [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 8)))\n+  [(match_scratch:P 1 \"r\")\n+   (match_scratch:P 2 \"r\")\n+   (parallel [(set (reg:P SP_REG)\n+\t\t   (plus:P (reg:P SP_REG)\n+\t\t\t   (match_operand:P 0 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))\n \t      (clobber (mem:BLK (scratch)))])]\n-  \"optimize_insn_for_size_p () || !TARGET_ADD_ESP_8\"\n-  [(parallel [(set (match_dup 0) (mem:SI (post_inc:SI (reg:SI SP_REG))))\n+  \"(TARGET_DOUBLE_POP || optimize_insn_for_size_p ())\n+   && INTVAL (operands[0]) == 2*GET_MODE_SIZE (Pmode)\"\n+  [(parallel [(set (match_dup 1) (mem:P (post_inc:P (reg:P SP_REG))))\n \t      (clobber (mem:BLK (scratch)))])\n-   (set (match_dup 1) (mem:SI (post_inc:SI (reg:SI SP_REG))))])\n+   (set (match_dup 2) (mem:P (post_inc:P (reg:P SP_REG))))])\n \n (define_peephole2\n-  [(match_scratch:SI 0 \"r\")\n-   (parallel [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 8)))\n+  [(match_scratch:P 1 \"r\")\n+   (parallel [(set (reg:P SP_REG)\n+\t\t   (plus:P (reg:P SP_REG)\n+\t\t\t   (match_operand:P 0 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))\n \t      (clobber (mem:BLK (scratch)))])]\n-  \"optimize_insn_for_size_p ()\"\n-  [(parallel [(set (match_dup 0) (mem:SI (post_inc:SI (reg:SI SP_REG))))\n+  \"optimize_insn_for_size_p ()\n+   && INTVAL (operands[0]) == 2*GET_MODE_SIZE (Pmode)\"\n+  [(parallel [(set (match_dup 1) (mem:P (post_inc:P (reg:P SP_REG))))\n \t      (clobber (mem:BLK (scratch)))])\n-   (set (match_dup 0) (mem:SI (post_inc:SI (reg:SI SP_REG))))])\n+   (set (match_dup 1) (mem:P (post_inc:P (reg:P SP_REG))))])\n \n ;; Convert esp additions to pop.\n (define_peephole2\n-  [(match_scratch:SI 0 \"r\")\n-   (parallel [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 4)))\n+  [(match_scratch:P 1 \"r\")\n+   (parallel [(set (reg:P SP_REG)\n+\t\t   (plus:P (reg:P SP_REG)\n+\t\t\t   (match_operand:P 0 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\"\n-  [(set (match_dup 0) (mem:SI (post_inc:SI (reg:SI SP_REG))))])\n+  \"INTVAL (operands[0]) == GET_MODE_SIZE (Pmode)\"\n+  [(set (match_dup 1) (mem:P (post_inc:P (reg:P SP_REG))))])\n \n ;; Two pops case is tricky, since pop causes dependency\n ;; on destination register.  We use two registers if available.\n (define_peephole2\n-  [(match_scratch:SI 0 \"r\")\n-   (match_scratch:SI 1 \"r\")\n-   (parallel [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 8)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\"\n-  [(set (match_dup 0) (mem:SI (post_inc:SI (reg:SI SP_REG))))\n-   (set (match_dup 1) (mem:SI (post_inc:SI (reg:SI SP_REG))))])\n-\n-(define_peephole2\n-  [(match_scratch:SI 0 \"r\")\n-   (parallel [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 8)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"optimize_insn_for_size_p ()\"\n-  [(set (match_dup 0) (mem:SI (post_inc:SI (reg:SI SP_REG))))\n-   (set (match_dup 0) (mem:SI (post_inc:SI (reg:SI SP_REG))))])\n-\f\n-(define_peephole2\n-  [(match_scratch:DI 0 \"r\")\n-   (parallel [(set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int -8)))\n-\t      (clobber (reg:CC FLAGS_REG))\n-\t      (clobber (mem:BLK (scratch)))])]\n-  \"optimize_insn_for_size_p () || !TARGET_SUB_ESP_4\"\n-  [(clobber (match_dup 0))\n-   (parallel [(set (mem:DI (pre_dec:DI (reg:DI SP_REG))) (match_dup 0))\n-\t      (clobber (mem:BLK (scratch)))])])\n-\n-(define_peephole2\n-  [(match_scratch:DI 0 \"r\")\n-   (parallel [(set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int -16)))\n-\t      (clobber (reg:CC FLAGS_REG))\n-\t      (clobber (mem:BLK (scratch)))])]\n-  \"optimize_insn_for_size_p () || !TARGET_SUB_ESP_8\"\n-  [(clobber (match_dup 0))\n-   (set (mem:DI (pre_dec:DI (reg:DI SP_REG))) (match_dup 0))\n-   (parallel [(set (mem:DI (pre_dec:DI (reg:DI SP_REG))) (match_dup 0))\n-\t      (clobber (mem:BLK (scratch)))])])\n-\n-;; Convert esp subtractions to push.\n-(define_peephole2\n-  [(match_scratch:DI 0 \"r\")\n-   (parallel [(set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int -8)))\n+  [(match_scratch:P 1 \"r\")\n+   (match_scratch:P 2 \"r\")\n+   (parallel [(set (reg:P SP_REG)\n+\t\t   (plus:P (reg:P SP_REG)\n+\t\t\t   (match_operand:P 0 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"optimize_insn_for_size_p () || !TARGET_SUB_ESP_4\"\n-  [(clobber (match_dup 0))\n-   (set (mem:DI (pre_dec:DI (reg:DI SP_REG))) (match_dup 0))])\n-\n-(define_peephole2\n-  [(match_scratch:DI 0 \"r\")\n-   (parallel [(set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int -16)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"optimize_insn_for_size_p () || !TARGET_SUB_ESP_8\"\n-  [(clobber (match_dup 0))\n-   (set (mem:DI (pre_dec:DI (reg:DI SP_REG))) (match_dup 0))\n-   (set (mem:DI (pre_dec:DI (reg:DI SP_REG))) (match_dup 0))])\n-\n-;; Convert epilogue deallocator to pop.\n-(define_peephole2\n-  [(match_scratch:DI 0 \"r\")\n-   (parallel [(set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int 8)))\n-\t      (clobber (reg:CC FLAGS_REG))\n-\t      (clobber (mem:BLK (scratch)))])]\n-  \"optimize_insn_for_size_p () || !TARGET_ADD_ESP_4\"\n-  [(parallel [(set (match_dup 0) (mem:DI (post_inc:DI (reg:DI SP_REG))))\n-\t      (clobber (mem:BLK (scratch)))])])\n-\n-;; Two pops case is tricky, since pop causes dependency\n-;; on destination register.  We use two registers if available.\n-(define_peephole2\n-  [(match_scratch:DI 0 \"r\")\n-   (match_scratch:DI 1 \"r\")\n-   (parallel [(set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int 16)))\n-\t      (clobber (reg:CC FLAGS_REG))\n-\t      (clobber (mem:BLK (scratch)))])]\n-  \"optimize_insn_for_size_p () || !TARGET_ADD_ESP_8\"\n-  [(parallel [(set (match_dup 0) (mem:DI (post_inc:DI (reg:DI SP_REG))))\n-\t      (clobber (mem:BLK (scratch)))])\n-   (set (match_dup 1) (mem:DI (post_inc:DI (reg:DI SP_REG))))])\n-\n-(define_peephole2\n-  [(match_scratch:DI 0 \"r\")\n-   (parallel [(set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int 16)))\n-\t      (clobber (reg:CC FLAGS_REG))\n-\t      (clobber (mem:BLK (scratch)))])]\n-  \"optimize_insn_for_size_p ()\"\n-  [(parallel [(set (match_dup 0) (mem:DI (post_inc:DI (reg:DI SP_REG))))\n-\t      (clobber (mem:BLK (scratch)))])\n-   (set (match_dup 0) (mem:DI (post_inc:DI (reg:DI SP_REG))))])\n-\n-;; Convert esp additions to pop.\n-(define_peephole2\n-  [(match_scratch:DI 0 \"r\")\n-   (parallel [(set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int 8)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\"\n-  [(set (match_dup 0) (mem:DI (post_inc:DI (reg:DI SP_REG))))])\n-\n-;; Two pops case is tricky, since pop causes dependency\n-;; on destination register.  We use two registers if available.\n-(define_peephole2\n-  [(match_scratch:DI 0 \"r\")\n-   (match_scratch:DI 1 \"r\")\n-   (parallel [(set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int 16)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\"\n-  [(set (match_dup 0) (mem:DI (post_inc:DI (reg:DI SP_REG))))\n-   (set (match_dup 1) (mem:DI (post_inc:DI (reg:DI SP_REG))))])\n+  \"INTVAL (operands[0]) == 2*GET_MODE_SIZE (Pmode)\"\n+  [(set (match_dup 1) (mem:P (post_inc:P (reg:P SP_REG))))\n+   (set (match_dup 2) (mem:P (post_inc:P (reg:P SP_REG))))])\n \n (define_peephole2\n-  [(match_scratch:DI 0 \"r\")\n-   (parallel [(set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int 16)))\n+  [(match_scratch:P 1 \"r\")\n+   (parallel [(set (reg:P SP_REG)\n+\t\t   (plus:P (reg:P SP_REG)\n+\t\t\t   (match_operand:P 0 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"optimize_insn_for_size_p ()\"\n-  [(set (match_dup 0) (mem:DI (post_inc:DI (reg:DI SP_REG))))\n-   (set (match_dup 0) (mem:DI (post_inc:DI (reg:DI SP_REG))))])\n+  \"optimize_insn_for_size_p ()\n+   && INTVAL (operands[0]) == 2*GET_MODE_SIZE (Pmode)\"\n+  [(set (match_dup 1) (mem:P (post_inc:P (reg:P SP_REG))))\n+   (set (match_dup 1) (mem:P (post_inc:P (reg:P SP_REG))))])\n \f\n ;; Convert compares with 1 to shorter inc/dec operations when CF is not\n ;; required and register dies.  Similarly for 128 to -128."}]}