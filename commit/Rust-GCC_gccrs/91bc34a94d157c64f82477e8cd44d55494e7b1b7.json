{"sha": "91bc34a94d157c64f82477e8cd44d55494e7b1b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFiYzM0YTk0ZDE1N2M2NGY4MjQ3N2U4Y2Q0NGQ1NTQ5NGU3YjFiNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-08-02T15:13:41Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-08-02T15:13:41Z"}, "message": "invoke.texi (Wsuggest-final-types, [...]): Document.\n\n\n\t* doc/invoke.texi (Wsuggest-final-types, Wsuggest-final-methods): Document.\n\t* ipa-devirt.c: Include hash-map.h\n\t(struct polymorphic_call_target_d): Add type_warning and decl_warning.\n\t(clear_speculation): Break out of ...\n\t(get_class_context): ... here; speed up handling obviously useless\n\tspeculations.\n\t(odr_type_warn_count, decl_warn_count): New structures.\n\t(final_warning_record): New structure.\n\t(final_warning_records): New static variable.\n\t(possible_polymorphic_call_targets): Cleanup handling of speculative info;\n\tdo not build speculation when user do not care; record info about warnings\n\twhen asked for.\n\t(add_decl_warning): New function.\n\t(type_warning_cmp): New function.\n\t(decl_warning_cmp): New function.\n\t(ipa_devirt): Handle -Wsuggest-final-methods and -Wsuggest-final-types.\n\t(gate): Enable pass when warnings are requested.\n\t* common.opt (Wsuggest-final-types, Wsuggest-final-methods): New options.\n\n\t* g++.dg/warn/Wsuggest-final.C: New testcase.\n\t* g++.dg/ipa/devirt-34.C: Fix.\n\nFrom-SVN: r213518", "tree": {"sha": "363affad7849abba7c8f191cdaf2dbd6f8c056a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/363affad7849abba7c8f191cdaf2dbd6f8c056a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91bc34a94d157c64f82477e8cd44d55494e7b1b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91bc34a94d157c64f82477e8cd44d55494e7b1b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91bc34a94d157c64f82477e8cd44d55494e7b1b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91bc34a94d157c64f82477e8cd44d55494e7b1b7/comments", "author": null, "committer": null, "parents": [{"sha": "b787e7a2c2c9be2f548d4c76ec324b71859851a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b787e7a2c2c9be2f548d4c76ec324b71859851a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b787e7a2c2c9be2f548d4c76ec324b71859851a4"}], "stats": {"total": 373, "additions": 327, "deletions": 46}, "files": [{"sha": "832c89b168486d6b9a7f48dbdc1657395c216cb2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bc34a94d157c64f82477e8cd44d55494e7b1b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bc34a94d157c64f82477e8cd44d55494e7b1b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91bc34a94d157c64f82477e8cd44d55494e7b1b7", "patch": "@@ -1,3 +1,24 @@\n+2014-08-01  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* doc/invoke.texi (Wsuggest-final-types, Wsuggest-final-methods): Document.\n+\t* ipa-devirt.c: Include hash-map.h\n+\t(struct polymorphic_call_target_d): Add type_warning and decl_warning.\n+\t(clear_speculation): Break out of ...\n+\t(get_class_context): ... here; speed up handling obviously useless\n+\tspeculations.\n+\t(odr_type_warn_count, decl_warn_count): New structures.\n+\t(final_warning_record): New structure.\n+\t(final_warning_records): New static variable.\n+\t(possible_polymorphic_call_targets): Cleanup handling of speculative info;\n+\tdo not build speculation when user do not care; record info about warnings\n+\twhen asked for.\n+\t(add_decl_warning): New function.\n+\t(type_warning_cmp): New function.\n+\t(decl_warning_cmp): New function.\n+\t(ipa_devirt): Handle -Wsuggest-final-methods and -Wsuggest-final-types.\n+\t(gate): Enable pass when warnings are requested.\n+\t* common.opt (Wsuggest-final-types, Wsuggest-final-methods): New options.\n+\n 2014-08-02  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* hash-map.h (default_hashmap_traits::mark_key_deleted):"}, {"sha": "0c4f86bb14c94d9b2170c9c9b59a2d15597e1ff0", "filename": "gcc/common.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bc34a94d157c64f82477e8cd44d55494e7b1b7/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bc34a94d157c64f82477e8cd44d55494e7b1b7/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=91bc34a94d157c64f82477e8cd44d55494e7b1b7", "patch": "@@ -651,6 +651,14 @@ Wsuggest-attribute=noreturn\n Common Var(warn_suggest_attribute_noreturn) Warning\n Warn about functions which might be candidates for __attribute__((noreturn))\n \n+Wsuggest-final-types\n+Common Var(warn_suggest_final_types) Warning\n+Warn about C++ polymorphic types where adding final keyword would improve code quality\n+\n+Wsuggest-final-methods\n+Common Var(warn_suggest_final_methods) Warning\n+Warn about C++ virtual methods where adding final keyword would improve code quality\n+\n Wsystem-headers\n Common Var(warn_system_headers) Warning\n Do not suppress warnings from system headers"}, {"sha": "4f327df69ebe8ec153ae1db248c8a83b77182f74", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bc34a94d157c64f82477e8cd44d55494e7b1b7/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bc34a94d157c64f82477e8cd44d55494e7b1b7/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=91bc34a94d157c64f82477e8cd44d55494e7b1b7", "patch": "@@ -271,6 +271,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wstack-protector -Wstack-usage=@var{len} -Wstrict-aliasing @gol\n -Wstrict-aliasing=n @gol -Wstrict-overflow -Wstrict-overflow=@var{n} @gol\n -Wsuggest-attribute=@r{[}pure@r{|}const@r{|}noreturn@r{|}format@r{]} @gol\n+-Wsuggest-final-types @gol -Wsuggest-final-methods @gol\n -Wmissing-format-attribute @gol\n -Wswitch  -Wswitch-default  -Wswitch-enum -Wswitch-bool -Wsync-nand @gol\n -Wsystem-headers  -Wtrampolines  -Wtrigraphs  -Wtype-limits  -Wundef @gol\n@@ -4193,6 +4194,25 @@ case, and some functions for which @code{format} attributes are\n appropriate may not be detected.\n @end table\n \n+@item -Wsuggest-final-types\n+@opindex Wno-suggest-final-types\n+@opindex Wsuggest-final-types\n+Warn about types with virtual methods where code quality would be improved\n+if the type was declared with C++11 final specifier, or, if possible,\n+declared in anonymous namespace. This allows GCC to devritualize more aggressively\n+the polymorphic calls. This warning is more effective with link time optimization,\n+where the information about the class hiearchy graph is more complete.\n+\n+@item -Wsuggest-final-methods\n+@opindex Wno-suggest-final-methods\n+@opindex Wsuggest-final-methods\n+Warn about virtual methods where code quality would be improved if the method\n+was declared with C++11 final specifier, or, if possible, its type was declared\n+in the anonymous namespace or with final specifier. This warning is more\n+effective with link time optimization, where the information about the class\n+hiearchy graph is more complete. It is recommended to first consider suggestins\n+of @option{-Wsuggest-final-types} and then rebuild with new annotations.\n+\n @item -Warray-bounds\n @opindex Wno-array-bounds\n @opindex Warray-bounds\n@@ -9622,7 +9642,7 @@ before applying @option{--param inline-unit-growth}.  The default is 10000.\n @item inline-unit-growth\n Specifies maximal overall growth of the compilation unit caused by inlining.\n The default value is 30 which limits unit growth to 1.3 times the original\n-size. Cold functions (either marked cold via an attribibute or by profile\n+size. Cold functions (either marked cold via an attribute or by profile\n feedback) are not accounted into the unit size.\n \n @item ipcp-unit-growth"}, {"sha": "ca74d3bb4fdbc1c2aa080d6762d8c38d4717c5e6", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 245, "deletions": 43, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bc34a94d157c64f82477e8cd44d55494e7b1b7/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bc34a94d157c64f82477e8cd44d55494e7b1b7/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=91bc34a94d157c64f82477e8cd44d55494e7b1b7", "patch": "@@ -133,6 +133,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbgcnt.h\"\n #include \"stor-layout.h\"\n #include \"intl.h\"\n+#include \"hash-map.h\"\n \n static bool odr_types_equivalent_p (tree, tree, bool, bool *,\n \t\t\t\t    hash_set<tree> *);\n@@ -1616,6 +1617,8 @@ struct polymorphic_call_target_d\n   vec <cgraph_node *> targets;\n   int speculative_targets;\n   bool complete;\n+  int type_warning;\n+  tree decl_warning;\n };\n \n /* Polymorphic call target cache helpers.  */\n@@ -1734,6 +1737,16 @@ contains_polymorphic_type_p (const_tree type)\n   return false;\n }\n \n+/* Clear speculative info from CONTEXT.  */\n+\n+static void\n+clear_speculation (ipa_polymorphic_call_context *context)\n+{\n+  context->speculative_outer_type = NULL;\n+  context->speculative_offset = 0;\n+  context->speculative_maybe_derived_type = false;\n+}\n+\n /* CONTEXT->OUTER_TYPE is a type of memory object where object of EXPECTED_TYPE\n    is contained at CONTEXT->OFFSET.  Walk the memory representation of\n    CONTEXT->OUTER_TYPE and find the outermost class type that match\n@@ -1769,6 +1782,16 @@ get_class_context (ipa_polymorphic_call_context *context,\n      type = context->outer_type = expected_type;\n      context->offset = offset = 0;\n    }\n+\n+ if (context->speculative_outer_type == context->outer_type\n+     && (!context->maybe_derived_type\n+\t || context->speculative_maybe_derived_type))\n+   {\n+      context->speculative_outer_type = NULL;\n+      context->speculative_offset = 0;\n+      context->speculative_maybe_derived_type = false;\n+   }\n+\n   /* See if speculative type seem to be derrived from outer_type.\n      Then speculation is valid only if it really is a derivate and derived types\n      are allowed.  \n@@ -1785,11 +1808,7 @@ get_class_context (ipa_polymorphic_call_context *context,\n \t\t\t  context->outer_type))\n     speculation_valid = context->maybe_derived_type;\n   else\n-    {\n-      context->speculative_outer_type = NULL;\n-      context->speculative_offset = 0;\n-      context->speculative_maybe_derived_type = false;\n-    }\n+    clear_speculation (context);\n \t\t\t       \n   /* Find the sub-object the constant actually refers to and mark whether it is\n      an artificial one (as opposed to a user-defined one).\n@@ -1820,10 +1839,7 @@ get_class_context (ipa_polymorphic_call_context *context,\n \t\t\t\t\t  context->outer_type)\n \t\t      && (context->maybe_derived_type\n \t\t\t  == context->speculative_maybe_derived_type)))\n-\t\t{\n-\t\t  context->speculative_outer_type = NULL;\n-\t\t  context->speculative_offset = 0;\n-\t\t}\n+\t\tclear_speculation (context);\n \t      return true;\n \t    }\n \t  else\n@@ -1841,8 +1857,7 @@ get_class_context (ipa_polymorphic_call_context *context,\n \t      if (!speculation_valid\n \t\t  || !context->maybe_derived_type)\n \t\t{\n-\t\t  context->speculative_outer_type = NULL;\n-\t\t  context->speculative_offset = 0;\n+\t\t  clear_speculation (context);\n \t          return true;\n \t\t}\n \t      /* Otherwise look into speculation now.  */\n@@ -1925,9 +1940,7 @@ get_class_context (ipa_polymorphic_call_context *context,\n   /* If we failed to find subtype we look for, give up and fall back to the\n      most generic query.  */\n give_up:\n-  context->speculative_outer_type = NULL;\n-  context->speculative_offset = 0;\n-  context->speculative_maybe_derived_type = false;\n+  clear_speculation (context);\n   if (valid)\n     return true;\n   context->outer_type = expected_type;\n@@ -2502,6 +2515,30 @@ devirt_variable_node_removal_hook (varpool_node *n,\n     free_polymorphic_call_targets_hash ();\n }\n \n+/* Record about how many calls would benefit from given type to be final.  */\n+struct odr_type_warn_count\n+{\n+  int count;\n+  gcov_type dyn_count;\n+};\n+\n+/* Record about how many calls would benefit from given method to be final.  */\n+struct decl_warn_count\n+{\n+  tree decl;\n+  int count;\n+  gcov_type dyn_count;\n+};\n+\n+/* Information about type and decl warnings.  */\n+struct final_warning_record\n+{\n+  gcov_type dyn_count;\n+  vec<odr_type_warn_count> type_warnings;\n+  hash_map<tree, decl_warn_count> decl_warnings;\n+};\n+struct final_warning_record *final_warning_records;\n+\n /* Return vector containing possible targets of polymorphic call of type\n    OTR_TYPE caling method OTR_TOKEN within type of OTR_OUTER_TYPE and OFFSET.\n    If INCLUDE_BASES is true, walk also base types of OUTER_TYPES containig\n@@ -2573,6 +2610,10 @@ possible_polymorphic_call_targets (tree otr_type,\n       return nodes;\n     }\n \n+  /* Do not bother to compute speculative info when user do not asks for it.  */\n+  if (!speculative_targetsp || !context.speculative_outer_type)\n+    clear_speculation (&context);\n+\n   type = get_odr_type (otr_type, true);\n \n   /* Recording type variants would wast results cache.  */\n@@ -2639,6 +2680,19 @@ possible_polymorphic_call_targets (tree otr_type,\n \t*completep = (*slot)->complete;\n       if (speculative_targetsp)\n \t*speculative_targetsp = (*slot)->speculative_targets;\n+      if ((*slot)->type_warning && final_warning_records)\n+\t{\n+\t  final_warning_records->type_warnings[(*slot)->type_warning - 1].count++;\n+\t  final_warning_records->type_warnings[(*slot)->type_warning - 1].dyn_count\n+\t    += final_warning_records->dyn_count;\n+\t}\n+      if ((*slot)->decl_warning && final_warning_records)\n+\t{\n+\t  struct decl_warn_count *c =\n+\t     final_warning_records->decl_warnings.get ((*slot)->decl_warning);\n+\t  c->count++;\n+\t  c->dyn_count += final_warning_records->dyn_count;\n+\t}\n       return (*slot)->targets;\n     }\n \n@@ -2657,9 +2711,13 @@ possible_polymorphic_call_targets (tree otr_type,\n   hash_set<tree> inserted;\n   hash_set<tree> matched_vtables;\n \n+  /* First insert targets we speculatively identified as likely.  */\n   if (context.speculative_outer_type)\n     {\n       odr_type speculative_outer_type;\n+      bool speculation_complete = true;\n+\n+      /* First insert target from type itself and check if it may have derived types.  */\n       speculative_outer_type = get_odr_type (context.speculative_outer_type, true);\n       if (TYPE_FINAL_P (speculative_outer_type->type))\n \tcontext.speculative_maybe_derived_type = false;\n@@ -2671,35 +2729,27 @@ possible_polymorphic_call_targets (tree otr_type,\n       else\n \ttarget = NULL;\n \n-      if (target)\n-\t{\n-\t  /* In the case we get complete method, we don't need \n-\t     to walk derivations.  */\n-\t  if (DECL_FINAL_P (target))\n-\t    context.speculative_maybe_derived_type = false;\n-\t}\n+      /* In the case we get complete method, we don't need \n+\t to walk derivations.  */\n+      if (target && DECL_FINAL_P (target))\n+\tcontext.speculative_maybe_derived_type = false;\n       if (type_possibly_instantiated_p (speculative_outer_type->type))\n-\tmaybe_record_node (nodes, target, &inserted, can_refer, &complete);\n+\tmaybe_record_node (nodes, target, &inserted, can_refer, &speculation_complete);\n       if (binfo)\n \tmatched_vtables.add (BINFO_VTABLE (binfo));\n+\n       /* Next walk recursively all derived types.  */\n       if (context.speculative_maybe_derived_type)\n-\t{\n-\t  /* For anonymous namespace types we can attempt to build full type.\n-\t     All derivations must be in this unit (unless we see partial unit).  */\n-\t  if (!type->all_derivations_known)\n-\t    complete = false;\n-\t  for (i = 0; i < speculative_outer_type->derived_types.length(); i++)\n-\t    possible_polymorphic_call_targets_1 (nodes, &inserted,\n-\t\t\t\t\t\t &matched_vtables,\n-\t\t\t\t\t\t otr_type,\n-\t\t\t\t\t\t speculative_outer_type->derived_types[i],\n-\t\t\t\t\t\t otr_token, speculative_outer_type->type,\n-\t\t\t\t\t\t context.speculative_offset, &complete,\n-\t\t\t\t\t\t bases_to_consider,\n-\t\t\t\t\t\t false);\n-\t}\n-      /* Finally walk bases, if asked to.  */\n+\tfor (i = 0; i < speculative_outer_type->derived_types.length(); i++)\n+\t  possible_polymorphic_call_targets_1 (nodes, &inserted,\n+\t\t\t\t\t       &matched_vtables,\n+\t\t\t\t\t       otr_type,\n+\t\t\t\t\t       speculative_outer_type->derived_types[i],\n+\t\t\t\t\t       otr_token, speculative_outer_type->type,\n+\t\t\t\t\t       context.speculative_offset,\n+\t\t\t\t\t       &speculation_complete,\n+\t\t\t\t\t       bases_to_consider,\n+\t\t\t\t\t       false);\n       (*slot)->speculative_targets = nodes.length();\n     }\n \n@@ -2743,10 +2793,6 @@ possible_polymorphic_call_targets (tree otr_type,\n   /* Next walk recursively all derived types.  */\n   if (context.maybe_derived_type)\n     {\n-      /* For anonymous namespace types we can attempt to build full type.\n-\t All derivations must be in this unit (unless we see partial unit).  */\n-      if (!type->all_derivations_known)\n-\tcomplete = false;\n       for (i = 0; i < outer_type->derived_types.length(); i++)\n \tpossible_polymorphic_call_targets_1 (nodes, &inserted,\n \t\t\t\t\t     &matched_vtables,\n@@ -2756,6 +2802,51 @@ possible_polymorphic_call_targets (tree otr_type,\n \t\t\t\t\t     context.offset, &complete,\n \t\t\t\t\t     bases_to_consider,\n \t\t\t\t\t     context.maybe_in_construction);\n+\n+      if (!outer_type->all_derivations_known)\n+\t{\n+\t  if (final_warning_records)\n+\t    {\n+\t      if (complete\n+\t\t  && nodes.length () == 1\n+\t\t  && warn_suggest_final_types\n+\t\t  && !outer_type->derived_types.length ())\n+\t\t{\n+\t\t  if (outer_type->id >= (int)final_warning_records->type_warnings.length ())\n+\t            final_warning_records->type_warnings.safe_grow_cleared\n+\t\t      (odr_types.length ());\n+\t\t  final_warning_records->type_warnings[outer_type->id].count++;\n+\t\t  final_warning_records->type_warnings[outer_type->id].dyn_count\n+\t\t    += final_warning_records->dyn_count;\n+\t\t  (*slot)->type_warning = outer_type->id + 1;\n+\t\t}\n+\t      if (complete\n+\t\t  && warn_suggest_final_methods\n+\t\t  && nodes.length () == 1\n+\t\t  && types_same_for_odr (DECL_CONTEXT (nodes[0]->decl),\n+\t\t\t\t\t outer_type->type))\n+\t\t{\n+\t\t  bool existed;\n+\t\t  struct decl_warn_count &c =\n+\t\t     final_warning_records->decl_warnings.get_or_insert\n+\t\t\t(nodes[0]->decl, &existed);\n+\n+\t\t  if (existed)\n+\t\t    {\n+\t\t      c.count++;\n+\t\t      c.dyn_count += final_warning_records->dyn_count;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      c.count = 1;\n+\t\t      c.dyn_count = final_warning_records->dyn_count;\n+\t\t      c.decl = nodes[0]->decl;\n+\t\t    }\n+\t\t  (*slot)->decl_warning = nodes[0]->decl;\n+\t\t}\n+\t    }\n+\t  complete = false;\n+\t}\n     }\n \n   /* Finally walk bases, if asked to.  */\n@@ -2796,6 +2887,14 @@ possible_polymorphic_call_targets (tree otr_type,\n   return nodes;\n }\n \n+bool\n+add_decl_warning (const tree &key ATTRIBUTE_UNUSED, const decl_warn_count &value,\n+\t\t  vec<const decl_warn_count*> *vec)\n+{\n+  vec->safe_push (&value);\n+  return true;\n+}\n+\n /* Dump all possible targets of a polymorphic call.  */\n \n void\n@@ -2946,6 +3045,38 @@ likely_target_p (struct cgraph_node *n)\n   return true;\n }\n \n+/* Compare type warning records P1 and P2 and chose one with larger count;\n+   helper for qsort.  */\n+\n+int\n+type_warning_cmp (const void *p1, const void *p2)\n+{\n+  const odr_type_warn_count *t1 = (const odr_type_warn_count *)p1;\n+  const odr_type_warn_count *t2 = (const odr_type_warn_count *)p2;\n+\n+  if (t1->dyn_count < t2->dyn_count)\n+   return 1;\n+  if (t1->dyn_count > t2->dyn_count)\n+   return -1;\n+  return t2->count - t1->count;\n+}\n+\n+/* Compare decl warning records P1 and P2 and chose one with larger count;\n+   helper for qsort.  */\n+\n+int\n+decl_warning_cmp (const void *p1, const void *p2)\n+{\n+  const decl_warn_count *t1 = *(const decl_warn_count * const *)p1;\n+  const decl_warn_count *t2 = *(const decl_warn_count * const *)p2;\n+\n+  if (t1->dyn_count < t2->dyn_count)\n+   return 1;\n+  if (t1->dyn_count > t2->dyn_count)\n+   return -1;\n+  return t2->count - t1->count;\n+}\n+\n /* The ipa-devirt pass.\n    When polymorphic call has only one likely target in the unit,\n    turn it into speculative call.  */\n@@ -2961,6 +3092,19 @@ ipa_devirt (void)\n   int nmultiple = 0, noverwritable = 0, ndevirtualized = 0, nnotdefined = 0;\n   int nwrong = 0, nok = 0, nexternal = 0, nartificial = 0;\n \n+  /* We can output -Wsuggest-final-methods and -Wsuggest-final-types warnings.\n+     This is implemented by setting up final_warning_records that are updated\n+     by get_polymorphic_call_targets.\n+     We need to clear cache in this case to trigger recomputation of all\n+     entries.  */\n+  if (warn_suggest_final_methods || warn_suggest_final_types)\n+    {\n+      final_warning_records = new (final_warning_record);\n+      final_warning_records->type_warnings = vNULL;\n+      final_warning_records->type_warnings.safe_grow_cleared (odr_types.length ());\n+      free_polymorphic_call_targets_hash ();\n+    }\n+\n   FOR_EACH_DEFINED_FUNCTION (n)\n     {\t\n       bool update = false;\n@@ -2974,6 +3118,10 @@ ipa_devirt (void)\n \t    void *cache_token;\n \t    bool final;\n \t    int speculative_targets;\n+\n+\t    if (final_warning_records)\n+\t      final_warning_records->dyn_count = e->count;\n+\n \t    vec <cgraph_node *>targets\n \t       = possible_polymorphic_call_targets\n \t\t    (e, &final, &cache_token, &speculative_targets);\n@@ -2985,6 +3133,9 @@ ipa_devirt (void)\n \n \t    npolymorphic++;\n \n+\t    if (!flag_devirtualize_speculatively)\n+\t      continue;\n+\n \t    if (!cgraph_maybe_hot_edge_p (e))\n \t      {\n \t\tif (dump_file)\n@@ -3114,6 +3265,55 @@ ipa_devirt (void)\n       if (update)\n \tinline_update_overall_summary (n);\n     }\n+  if (warn_suggest_final_methods || warn_suggest_final_types)\n+    {\n+      if (warn_suggest_final_types)\n+\t{\n+\t  final_warning_records->type_warnings.qsort (type_warning_cmp);\n+\t  for (unsigned int i = 0;\n+\t       i < final_warning_records->type_warnings.length (); i++)\n+\t    if (final_warning_records->type_warnings[i].count)\n+\t      {\n+\t\todr_type type = odr_types[i];\n+\t\twarning_at (DECL_SOURCE_LOCATION (TYPE_NAME (type->type)),\n+\t\t\t    OPT_Wsuggest_final_types,\n+\t\t\t    \"Declaring type %qD final \"\n+\t\t\t    \"would enable devirtualization of %i calls\",\n+\t\t\t    type->type,\n+\t\t\t    final_warning_records->type_warnings[i].count);\n+\t      }\n+\t}\n+\n+      if (warn_suggest_final_methods)\n+\t{\n+\t  vec<const decl_warn_count*> decl_warnings_vec = vNULL;\n+\n+\t  final_warning_records->decl_warnings.traverse\n+\t    <vec<const decl_warn_count *> *, add_decl_warning> (&decl_warnings_vec);\n+\t  decl_warnings_vec.qsort (decl_warning_cmp);\n+\t  for (unsigned int i = 0; i < decl_warnings_vec.length (); i++)\n+\t    {\n+\t      tree decl = decl_warnings_vec[i]->decl;\n+\t      int count = decl_warnings_vec[i]->count;\n+\n+\t      if (DECL_CXX_DESTRUCTOR_P (decl))\n+\t\twarning_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\t    OPT_Wsuggest_final_methods,\n+\t\t\t    \"Declaring virtual destructor of %qD final \"\n+\t\t\t    \"would enable devirtualization of %i calls\",\n+\t\t\t    DECL_CONTEXT (decl), count);\n+\t      else\n+\t\twarning_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\t    OPT_Wsuggest_final_methods,\n+\t\t\t    \"Declaring method %qD final \"\n+\t\t\t    \"would enable devirtualization of %i calls\",\n+\t\t\t    decl, count);\n+\t    }\n+\t}\n+\t\n+      delete (final_warning_records);\n+      final_warning_records = 0;\n+    }\n \n   if (dump_file)\n     fprintf (dump_file,\n@@ -3163,7 +3363,9 @@ class pass_ipa_devirt : public ipa_opt_pass_d\n   virtual bool gate (function *)\n     {\n       return (flag_devirtualize\n-\t      && flag_devirtualize_speculatively\n+\t      && (flag_devirtualize_speculatively\n+\t\t  || (warn_suggest_final_methods\n+\t\t      || warn_suggest_final_types))\n \t      && optimize);\n     }\n "}, {"sha": "aab609706f9654b9896a5c111d1b32e8a94ec3e0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bc34a94d157c64f82477e8cd44d55494e7b1b7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bc34a94d157c64f82477e8cd44d55494e7b1b7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=91bc34a94d157c64f82477e8cd44d55494e7b1b7", "patch": "@@ -1,3 +1,8 @@\n+2014-08-01  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* g++.dg/warn/Wsuggest-final.C: New testcase.\n+\t* g++.dg/ipa/devirt-34.C: Fix.\n+\n 2014-08-02  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/59855"}, {"sha": "5d56e1e0c8b35203f14a049453c495cb31e927dc", "filename": "gcc/testsuite/g++.dg/ipa/devirt-34.C", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bc34a94d157c64f82477e8cd44d55494e7b1b7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-34.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bc34a94d157c64f82477e8cd44d55494e7b1b7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-34.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-34.C?ref=91bc34a94d157c64f82477e8cd44d55494e7b1b7", "patch": "@@ -2,6 +2,9 @@\n /* { dg-options \"-O2 -fdump-ipa-devirt\"  } */\n struct A {virtual int t(){return 42;}};\n struct B:A {virtual int t(){return 1;}};\n+\n+struct A aa;\n+struct B bb;\n int\n t(struct B *b)\n {"}, {"sha": "5371063559d8241a0fe46f56cd8dd780f4123c80", "filename": "gcc/testsuite/g++.dg/warn/Wsuggest-final.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bc34a94d157c64f82477e8cd44d55494e7b1b7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWsuggest-final.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bc34a94d157c64f82477e8cd44d55494e7b1b7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWsuggest-final.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWsuggest-final.C?ref=91bc34a94d157c64f82477e8cd44d55494e7b1b7", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -Wsuggest-final-types -Wsuggest-final-methods\" }\n+struct A { // { dg-warning \"final would enable devirtualization of 4 calls\" }\n+virtual void a() {} // { dg-warning \"final would enable devirtualization of 2 calls\" }\n+ virtual void b() {} // { dg-warning \"final would enable devirtualization of 2 calls\"  }\n+};\n+void\n+t(struct A *a)\n+{\n+  a->a();\n+  a->a();\n+  a->b();\n+  a->b();\n+}"}, {"sha": "8350adb2d87fdecf6a4624acb63be2cc5e658083", "filename": "gcc/varpool.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bc34a94d157c64f82477e8cd44d55494e7b1b7/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bc34a94d157c64f82477e8cd44d55494e7b1b7/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=91bc34a94d157c64f82477e8cd44d55494e7b1b7", "patch": "@@ -340,8 +340,16 @@ varpool_node::ctor_useable_for_folding_p (void)\n \n   /* Variables declared 'const' without an initializer\n      have zero as the initializer if they may not be\n-     overridden at link or run time.  */\n-  if (!DECL_INITIAL (real_node->decl)\n+     overridden at link or run time.\n+\n+     It is actually requirement for C++ compiler to optimize const variables\n+     consistently. As a GNU extension, do not enfore this rule for user defined\n+     weak variables, so we support interposition on:\n+     static const int dummy = 0;\n+     extern const int foo __attribute__((__weak__, __alias__(\"dummy\"))); \n+   */\n+  if ((!DECL_INITIAL (real_node->decl)\n+       || (DECL_WEAK (decl) && !DECL_COMDAT (decl)))\n       && (DECL_EXTERNAL (decl) || decl_replaceable_p (decl)))\n     return false;\n "}]}