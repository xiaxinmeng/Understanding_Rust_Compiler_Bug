{"sha": "f9b36bb32f30e9f39221122f9c7a2d524f316ecf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjliMzZiYjMyZjMwZTlmMzkyMjExMjJmOWM3YTJkNTI0ZjMxNmVjZg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2010-05-12T15:33:10Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-05-12T15:33:10Z"}, "message": "coverage.c (build_fn_info_value): Call build_constructor instead of build_constructor_from_list.\n\n\t* coverage.c (build_fn_info_value): Call build_constructor instead of\n\tbuild_constructor_from_list.\n\t(build_ctr_info_value): Likewise.\n\t(build_gcov_info): Likewise.\n\nCo-Authored-By: Nathan Froyd <froydnj@codesourcery.com>\n\nFrom-SVN: r159326", "tree": {"sha": "ca17df9e0b7113c090a746705386cdbdf61d0e07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca17df9e0b7113c090a746705386cdbdf61d0e07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9b36bb32f30e9f39221122f9c7a2d524f316ecf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9b36bb32f30e9f39221122f9c7a2d524f316ecf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9b36bb32f30e9f39221122f9c7a2d524f316ecf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9b36bb32f30e9f39221122f9c7a2d524f316ecf/comments", "author": null, "committer": null, "parents": [{"sha": "f88203b0110a3f85a5bf4c908dabe7f698653b67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f88203b0110a3f85a5bf4c908dabe7f698653b67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f88203b0110a3f85a5bf4c908dabe7f698653b67"}], "stats": {"total": 126, "additions": 57, "deletions": 69}, "files": [{"sha": "44924d80994f944676b25370084243ec03a3658c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9b36bb32f30e9f39221122f9c7a2d524f316ecf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9b36bb32f30e9f39221122f9c7a2d524f316ecf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9b36bb32f30e9f39221122f9c7a2d524f316ecf", "patch": "@@ -1,3 +1,11 @@\n+2010-05-12  Kazu Hirata  <kazu@codesourcery.com>\n+\t    Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* coverage.c (build_fn_info_value): Call build_constructor instead of\n+\tbuild_constructor_from_list.\n+\t(build_ctr_info_value): Likewise.\n+\t(build_gcov_info): Likewise.\n+\n 2010-05-12  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* tree.c (build_constructor): Compute TREE_CONSTANT for the"}, {"sha": "5ef4dddd81283053cac41994234bfd3fd20057f1", "filename": "gcc/coverage.c", "status": "modified", "additions": 49, "deletions": 69, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9b36bb32f30e9f39221122f9c7a2d524f316ecf/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9b36bb32f30e9f39221122f9c7a2d524f316ecf/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=f9b36bb32f30e9f39221122f9c7a2d524f316ecf", "patch": "@@ -672,40 +672,34 @@ build_fn_info_type (unsigned int counters)\n static tree\n build_fn_info_value (const struct function_list *function, tree type)\n {\n-  tree value = NULL_TREE;\n   tree fields = TYPE_FIELDS (type);\n   unsigned ix;\n-  tree array_value = NULL_TREE;\n+  VEC(constructor_elt,gc) *v1 = NULL;\n+  VEC(constructor_elt,gc) *v2 = NULL;\n \n   /* ident */\n-  value = tree_cons (fields, build_int_cstu (get_gcov_unsigned_t (),\n-\t\t\t\t\t     function->ident), value);\n+  CONSTRUCTOR_APPEND_ELT (v1, fields,\n+\t\t\t  build_int_cstu (get_gcov_unsigned_t (),\n+\t\t\t\t\t  function->ident));\n   fields = TREE_CHAIN (fields);\n \n   /* checksum */\n-  value = tree_cons (fields, build_int_cstu (get_gcov_unsigned_t (),\n-\t\t\t\t\t     function->checksum), value);\n+  CONSTRUCTOR_APPEND_ELT (v1, fields,\n+\t\t\t  build_int_cstu (get_gcov_unsigned_t (),\n+\t\t\t\t\t  function->checksum));\n   fields = TREE_CHAIN (fields);\n \n   /* counters */\n   for (ix = 0; ix != GCOV_COUNTERS; ix++)\n     if (prg_ctr_mask & (1 << ix))\n-      {\n-\ttree counters = build_int_cstu (get_gcov_unsigned_t (),\n-\t\t\t\t\tfunction->n_ctrs[ix]);\n+      CONSTRUCTOR_APPEND_ELT (v2, NULL,\n+\t\t\t      build_int_cstu (get_gcov_unsigned_t (),\n+\t\t\t\t\t      function->n_ctrs[ix]));\n \n-\tarray_value = tree_cons (NULL_TREE, counters, array_value);\n-      }\n+  CONSTRUCTOR_APPEND_ELT (v1, fields,\n+\t\t\t  build_constructor (TREE_TYPE (fields), v2));\n \n-  /* FIXME: use build_constructor directly.  */\n-  array_value = build_constructor_from_list (TREE_TYPE (fields),\n-\t\t\t\t\t     nreverse (array_value));\n-  value = tree_cons (fields, array_value, value);\n-\n-  /* FIXME: use build_constructor directly.  */\n-  value = build_constructor_from_list (type, nreverse (value));\n-\n-  return value;\n+  return build_constructor (type, v1);\n }\n \n /* Creates the gcov_ctr_info RECORD_TYPE.  */\n@@ -753,15 +747,14 @@ build_ctr_info_type (void)\n static tree\n build_ctr_info_value (unsigned int counter, tree type)\n {\n-  tree value = NULL_TREE;\n   tree fields = TYPE_FIELDS (type);\n   tree fn;\n+  VEC(constructor_elt,gc) *v = NULL;\n \n   /* counters */\n-  value = tree_cons (fields,\n-\t\t     build_int_cstu (get_gcov_unsigned_t (),\n-\t\t\t\t     prg_n_ctrs[counter]),\n-\t\t     value);\n+  CONSTRUCTOR_APPEND_ELT (v, fields,\n+\t\t\t  build_int_cstu (get_gcov_unsigned_t (),\n+\t\t\t\t\t  prg_n_ctrs[counter]));\n   fields = TREE_CHAIN (fields);\n \n   if (prg_n_ctrs[counter])\n@@ -779,13 +772,12 @@ build_ctr_info_value (unsigned int counter, tree type)\n       DECL_SIZE_UNIT (tree_ctr_tables[counter]) = TYPE_SIZE_UNIT (array_type);\n       varpool_finalize_decl (tree_ctr_tables[counter]);\n \n-      value = tree_cons (fields,\n-\t\t\t build1 (ADDR_EXPR, TREE_TYPE (fields),\n-\t\t\t\t\t    tree_ctr_tables[counter]),\n-\t\t\t value);\n+      CONSTRUCTOR_APPEND_ELT (v, fields,\n+\t\t\t      build1 (ADDR_EXPR, TREE_TYPE (fields),\n+\t\t\t\t      tree_ctr_tables[counter]));\n     }\n   else\n-    value = tree_cons (fields, null_pointer_node, value);\n+    CONSTRUCTOR_APPEND_ELT (v, fields, null_pointer_node);\n   fields = TREE_CHAIN (fields);\n \n   fn = build_decl (BUILTINS_LOCATION,\n@@ -797,14 +789,9 @@ build_ctr_info_value (unsigned int counter, tree type)\n   DECL_ARTIFICIAL (fn) = 1;\n   TREE_NOTHROW (fn) = 1;\n   DECL_ASSEMBLER_NAME (fn);  /* Initialize assembler name so we can stream out. */\n-  value = tree_cons (fields,\n-\t\t     build1 (ADDR_EXPR, TREE_TYPE (fields), fn),\n-\t\t     value);\n-\n-  /* FIXME: use build_constructor directly.  */\n-  value = build_constructor_from_list (type, nreverse (value));\n+  CONSTRUCTOR_APPEND_ELT (v, fields, build1 (ADDR_EXPR, TREE_TYPE (fields), fn));\n \n-  return value;\n+  return build_constructor (type, v);\n }\n \n /* Creates the gcov_info RECORD_TYPE and initializer for it. Returns a\n@@ -819,12 +806,13 @@ build_gcov_info (void)\n   tree fn_info_ptr_type;\n   tree ctr_info_type, ctr_info_ary_type, ctr_info_value = NULL_TREE;\n   tree field, fields = NULL_TREE;\n-  tree value = NULL_TREE;\n   tree filename_string;\n   int da_file_name_len;\n   unsigned n_fns;\n   const struct function_list *fn;\n   tree string_type;\n+  VEC(constructor_elt,gc) *v1 = NULL;\n+  VEC(constructor_elt,gc) *v2 = NULL;\n \n   /* Count the number of active counters.  */\n   for (n_ctr_types = 0, ix = 0; ix != GCOV_COUNTERS; ix++)\n@@ -839,23 +827,23 @@ build_gcov_info (void)\n \t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n   TREE_CHAIN (field) = fields;\n   fields = field;\n-  value = tree_cons (field, build_int_cstu (TREE_TYPE (field), GCOV_VERSION),\n-\t\t     value);\n+  CONSTRUCTOR_APPEND_ELT (v1, field,\n+\t\t\t  build_int_cstu (TREE_TYPE (field), GCOV_VERSION));\n \n   /* next -- NULL */\n   field = build_decl (BUILTINS_LOCATION,\n \t\t      FIELD_DECL, NULL_TREE, build_pointer_type (const_type));\n   TREE_CHAIN (field) = fields;\n   fields = field;\n-  value = tree_cons (field, null_pointer_node, value);\n+  CONSTRUCTOR_APPEND_ELT (v1, field, null_pointer_node);\n \n   /* stamp */\n   field = build_decl (BUILTINS_LOCATION,\n \t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n   TREE_CHAIN (field) = fields;\n   fields = field;\n-  value = tree_cons (field, build_int_cstu (TREE_TYPE (field), local_tick),\n-\t\t     value);\n+  CONSTRUCTOR_APPEND_ELT (v1, field,\n+\t\t\t  build_int_cstu (TREE_TYPE (field), local_tick));\n \n   /* Filename */\n   string_type = build_pointer_type (build_qualified_type (char_type_node,\n@@ -869,27 +857,25 @@ build_gcov_info (void)\n   TREE_TYPE (filename_string) = build_array_type\n     (char_type_node, build_index_type\n      (build_int_cst (NULL_TREE, da_file_name_len)));\n-  value = tree_cons (field, build1 (ADDR_EXPR, string_type, filename_string),\n-\t\t     value);\n+  CONSTRUCTOR_APPEND_ELT (v1, field,\n+\t\t\t  build1 (ADDR_EXPR, string_type, filename_string));\n \n   /* Build the fn_info type and initializer.  */\n   fn_info_type = build_fn_info_type (n_ctr_types);\n   fn_info_ptr_type = build_pointer_type (build_qualified_type\n \t\t\t\t\t (fn_info_type, TYPE_QUAL_CONST));\n   for (fn = functions_head, n_fns = 0; fn; fn = fn->next, n_fns++)\n-    fn_info_value = tree_cons (NULL_TREE,\n-\t\t\t       build_fn_info_value (fn, fn_info_type),\n-\t\t\t       fn_info_value);\n+    CONSTRUCTOR_APPEND_ELT (v2, NULL_TREE,\n+\t\t\t    build_fn_info_value (fn, fn_info_type));\n+\n   if (n_fns)\n     {\n       tree array_type;\n \n       array_type = build_index_type (build_int_cst (NULL_TREE, n_fns - 1));\n       array_type = build_array_type (fn_info_type, array_type);\n \n-      /* FIXME: use build_constructor directly.  */\n-      fn_info_value = build_constructor_from_list (array_type,\n-\t\t\t\t\t\t   nreverse (fn_info_value));\n+      fn_info_value = build_constructor (array_type, v2);\n       fn_info_value = build1 (ADDR_EXPR, fn_info_ptr_type, fn_info_value);\n     }\n   else\n@@ -900,52 +886,46 @@ build_gcov_info (void)\n \t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n   TREE_CHAIN (field) = fields;\n   fields = field;\n-  value = tree_cons (field,\n-\t\t     build_int_cstu (get_gcov_unsigned_t (), n_fns),\n-\t\t     value);\n+  CONSTRUCTOR_APPEND_ELT (v1, field,\n+\t\t\t  build_int_cstu (get_gcov_unsigned_t (), n_fns));\n \n   /* fn_info table */\n   field = build_decl (BUILTINS_LOCATION,\n \t\t      FIELD_DECL, NULL_TREE, fn_info_ptr_type);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n-  value = tree_cons (field, fn_info_value, value);\n+  CONSTRUCTOR_APPEND_ELT (v1, field, fn_info_value);\n \n   /* counter_mask */\n   field = build_decl (BUILTINS_LOCATION,\n \t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n   TREE_CHAIN (field) = fields;\n   fields = field;\n-  value = tree_cons (field,\n-\t\t     build_int_cstu (get_gcov_unsigned_t (), prg_ctr_mask),\n-\t\t     value);\n+  CONSTRUCTOR_APPEND_ELT (v1, field, \n+\t\t\t  build_int_cstu (get_gcov_unsigned_t (),\n+\t\t\t\t\t  prg_ctr_mask));\n \n   /* counters */\n   ctr_info_type = build_ctr_info_type ();\n   ctr_info_ary_type = build_index_type (build_int_cst (NULL_TREE,\n \t\t\t\t\t\t       n_ctr_types));\n   ctr_info_ary_type = build_array_type (ctr_info_type, ctr_info_ary_type);\n+  v2 = NULL;\n   for (ix = 0; ix != GCOV_COUNTERS; ix++)\n     if (prg_ctr_mask & (1 << ix))\n-      ctr_info_value = tree_cons (NULL_TREE,\n-\t\t\t\t  build_ctr_info_value (ix, ctr_info_type),\n-\t\t\t\t  ctr_info_value);\n-  /* FIXME: use build_constructor directly.  */\n-  ctr_info_value = build_constructor_from_list (ctr_info_ary_type,\n-\t\t\t\t                nreverse (ctr_info_value));\n+      CONSTRUCTOR_APPEND_ELT (v2, NULL_TREE,\n+\t\t\t      build_ctr_info_value (ix, ctr_info_type));\n+  ctr_info_value = build_constructor (ctr_info_ary_type, v2);\n \n   field = build_decl (BUILTINS_LOCATION,\n \t\t      FIELD_DECL, NULL_TREE, ctr_info_ary_type);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n-  value = tree_cons (field, ctr_info_value, value);\n+  CONSTRUCTOR_APPEND_ELT (v1, field, ctr_info_value);\n \n   finish_builtin_struct (type, \"__gcov_info\", fields, NULL_TREE);\n \n-  /* FIXME: use build_constructor directly.  */\n-  value = build_constructor_from_list (type, nreverse (value));\n-\n-  return value;\n+  return build_constructor (type, v1);\n }\n \n /* Write out the structure which libgcov uses to locate all the"}]}