{"sha": "41374e13ac15863e80fff7c4b8731ab34b1921f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDEzNzRlMTNhYzE1ODYzZTgwZmZmN2M0Yjg3MzFhYjM0YjE5MjFmOQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-09-09T17:19:16Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-09-09T17:19:16Z"}, "message": "ra-build.c (copy_insn_p, [...]): Use gcc_assert and gcc_unreachable instead of abort.\n\n\t* ra-build.c (copy_insn_p, remember_move, defuse_overlap_p_1,\n\tlive_out_1, prune_hardregs_for_mode, init_one_web_common,\n\treinit_one_web, add_subweb, add_subweb_2, init_web_parts,\n\trecord_conflict, compare_and_free_webs, init_webs_defs_uses,\n\tparts_to_webs_1, parts_to_webs, reset_conflicts,\n\tcheck_conflict_numbers, remember_web_was_spilled, handle_asm_insn,\n\tra_build_free): Use gcc_assert and gcc_unreachable instead of abort.\n\t* ra-colorize.c (push_list, put_web, reset_lists, put_web_at_end,\n\tput_move, remove_move, combine, select_spill, colorize_one_web,\n\ttry_recolor_web, insert_coalesced_conflicts, check_colors,\n\tbreak_precolored_alias, restore_conflicts_from_coalesce,\n\tsort_and_combine_web_pairs, check_uncoalesced_moves): Likewise.\n\t* ra-rewrite.c (spill_coalescing, slots_overlap_p, emit_loads,\n\treloads_to_loads, rewrite_program2, emit_colors): Likewise.\n\t* ra.c (first_hard_reg, create_insn_info, find_subweb, init_ra,\n\tcheck_df): Likewise.\n\t* real.c (do_add, do_multiply, do_divide, do_compare, do_fix_trunc,\n\treal_arithmetic, real_compare, real_exponent, real_ldexp,\n\treal_identical, real_to_integer, real_to_integer2, real_to_decimal,\n\treal_to_hexadecimal, real_from_integer, ten_to_ptwo, ten_to_mptwo,\n\treal_digit, real_nan, real_maxval, round_for_format, real_convert,\n\treal_to_target, real_from_target, real_hash, encode_ieee_single,\n\tencode_ieee_double, encode_ieee_extended, encode_ieee_quad,\n\tencode_vax_f, encode_vax_d, encode_vax_g, encode_i370_single,\n\tencode_i370_double, encode_c4x_single, encode_c4x_extended): Likewise.\n\t* recog.c (validate_change, validate_replace_rtx_1, asm_operand_ok,\n\textract_insn, peep2_next_insn, peep2_reg_dead_p,\n\tpeep2_find_free_register, peephole2_optimize, store_data_bypass_p,\n\tif_test_bypass_p): Likewise.\n\t* reg-stack.c (record_label_references, get_asm_operand_n_inputs,\n\tstack_result, remove_regno_note, get_hard_regnum, emit_pop_insn,\n\temit_swap_insn, swap_to_top, move_for_stack_reg,\n\tsubst_stack_regs_pat, subst_asm_stack_regs, change_stack,\n\tcompensate_edge, convert_regs_1): Likewise.\n\t* regclass.c (init_reg_sets, init_reg_sets_1,\n\tmemory_move_secondary_cost): Likewise.\n\t* regrename.c (note_sets, clear_dead_regs, scan_rtx_reg, scan_rtx):\n\tLikewise.\n\t* reload.c (push_secondary_reload, find_valid_class, push_reload,\n\toperands_match_p, decompose, immune_p, find_reloads,\n\tfind_reloads_toplev, find_reloads_address_1, subst_reloads,\n\tcopy_replacements, refers_to_regno_for_reload_p,\n\treg_overlap_mentioned_for_reload_p): Likewise.\n\t* reload1.c (compute_use_by_pseudos, replace_pseudos_in, reload,\n\tcount_pseudo, find_reg, eliminate_regs, eliminate_regs_in_insn,\n\tverify_initial_elim_offsets, finish_spills, clear_reload_reg_in_use,\n\treload_reg_free_p, reload_reg_reaches_end_p, reloads_conflict,\n\tchoose_reload_regs, merge_assigned_reloads, emit_input_reload_insns,\n\tdo_output_reload, fixup_abnormal_edges): Likewise.\n\t* reorg.c (stop_search_p, emit_delay_sequence, get_jump_flags,\n\tfill_slots_from_thread, relax_delay_slots): Likewise.\n\t* resource.c (mark_referenced_resources, mark_set_resources):\n\tLikewise.\n\t* rtl.c (copy_rtx, rtx_equal_p): Likewise.\n\t* rtlanal.c (insn_dependent_p, reg_overlap_mentioned_p,\n\tdead_or_set_p, find_reg_fusage, remove_note, replace_rtx,\n\tsubreg_lsb_1, subreg_regno_offset, subreg_offset_representable_p,\n\tfind_first_parameter_load, can_hoist_insn_p, hoist_update_store,\n\thoist_insn_after, hoist_insn_to_edge, nonzero_bits1): Likewise.\n\t* rtlhooks.c (gen_lowpart_general): Likewise.\n\t* sbitmap.c (sbitmap_difference): Likewise.\n\t* sched-deps.c (add_dependence, sched_analyze_1, sched_analyze_2,\n\tsched_analyze, add_forward_dependence): Likewise.\n\t* sched-ebb.c (fix_basic_block_boundaries, schedule_ebb): Likewise.\n\t* sched-rgn.c (debug_regions, compute_trg_info, schedule_region,\n\tschedule_insns): Likewise.\n\t* sched-vis.c (print_pattern): Likewise.\n\t* sdbout.c (sdbout_symbol, sdbout_toplevel_data): Likewise.\n\t* simplify-rtx.c (simplify_unary_operation, simplify_binary_operation,\n\tsimplify_const_relational_operation, simplify_ternary_operation,\n\tsimplify_immed_subreg, simplify_subreg, simplify_gen_subreg):\n\tLikewise.\n\t* sreal.c (copy, sreal_sub, sreal_div): Likewise.\n\t* stmt.c (force_label_rtx, expand_goto, expand_asm_operands,\n\tresolve_operand_name_1, expand_return, expand_decl,\n\texpand_anon_union_decl, emit_case_bit_tests, expand_case): Likewise.\n\t* stor-layout.c (put_pending_size, smallest_mode_for_size,\n\tint_mode_for_mode, layout_decl, finish_builtin_struct, layout_type,\n\tset_sizetype, get_mode_bounds): Likewise.\n\nFrom-SVN: r87244", "tree": {"sha": "4493ed2091b537830e81c4e1100321bb065757b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4493ed2091b537830e81c4e1100321bb065757b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41374e13ac15863e80fff7c4b8731ab34b1921f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41374e13ac15863e80fff7c4b8731ab34b1921f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41374e13ac15863e80fff7c4b8731ab34b1921f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41374e13ac15863e80fff7c4b8731ab34b1921f9/comments", "author": null, "committer": null, "parents": [{"sha": "15072eb1299f2e6f415798e4bbaf054ddc905645", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15072eb1299f2e6f415798e4bbaf054ddc905645", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15072eb1299f2e6f415798e4bbaf054ddc905645"}], "stats": {"total": 2209, "additions": 1031, "deletions": 1178}, "files": [{"sha": "43c658b00abf83bf76a5401a8c99588536875a6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 84, "deletions": 2, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -1,3 +1,85 @@\n+2004-09-09  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n+\n+\t* ra-build.c (copy_insn_p, remember_move, defuse_overlap_p_1,\n+\tlive_out_1, prune_hardregs_for_mode, init_one_web_common,\n+\treinit_one_web, add_subweb, add_subweb_2, init_web_parts,\n+\trecord_conflict, compare_and_free_webs, init_webs_defs_uses,\n+\tparts_to_webs_1, parts_to_webs, reset_conflicts,\n+\tcheck_conflict_numbers, remember_web_was_spilled, handle_asm_insn,\n+\tra_build_free): Use gcc_assert and gcc_unreachable instead of abort.\n+\t* ra-colorize.c (push_list, put_web, reset_lists, put_web_at_end,\n+\tput_move, remove_move, combine, select_spill, colorize_one_web,\n+\ttry_recolor_web, insert_coalesced_conflicts, check_colors,\n+\tbreak_precolored_alias, restore_conflicts_from_coalesce,\n+\tsort_and_combine_web_pairs, check_uncoalesced_moves): Likewise.\n+\t* ra-rewrite.c (spill_coalescing, slots_overlap_p, emit_loads,\n+\treloads_to_loads, rewrite_program2, emit_colors): Likewise.\n+\t* ra.c (first_hard_reg, create_insn_info, find_subweb, init_ra,\n+\tcheck_df): Likewise.\n+\t* real.c (do_add, do_multiply, do_divide, do_compare, do_fix_trunc,\n+\treal_arithmetic, real_compare, real_exponent, real_ldexp,\n+\treal_identical, real_to_integer, real_to_integer2, real_to_decimal,\n+\treal_to_hexadecimal, real_from_integer, ten_to_ptwo, ten_to_mptwo,\n+\treal_digit, real_nan, real_maxval, round_for_format, real_convert,\n+\treal_to_target, real_from_target, real_hash, encode_ieee_single,\n+\tencode_ieee_double, encode_ieee_extended, encode_ieee_quad,\n+\tencode_vax_f, encode_vax_d, encode_vax_g, encode_i370_single,\n+\tencode_i370_double, encode_c4x_single, encode_c4x_extended): Likewise.\n+\t* recog.c (validate_change, validate_replace_rtx_1, asm_operand_ok,\n+\textract_insn, peep2_next_insn, peep2_reg_dead_p,\n+\tpeep2_find_free_register, peephole2_optimize, store_data_bypass_p,\n+\tif_test_bypass_p): Likewise.\n+\t* reg-stack.c (record_label_references, get_asm_operand_n_inputs,\n+\tstack_result, remove_regno_note, get_hard_regnum, emit_pop_insn,\n+\temit_swap_insn, swap_to_top, move_for_stack_reg,\n+\tsubst_stack_regs_pat, subst_asm_stack_regs, change_stack,\n+\tcompensate_edge, convert_regs_1): Likewise.\n+\t* regclass.c (init_reg_sets, init_reg_sets_1,\n+\tmemory_move_secondary_cost): Likewise.\n+\t* regrename.c (note_sets, clear_dead_regs, scan_rtx_reg, scan_rtx):\n+\tLikewise.\n+\t* reload.c (push_secondary_reload, find_valid_class, push_reload,\n+\toperands_match_p, decompose, immune_p, find_reloads,\n+\tfind_reloads_toplev, find_reloads_address_1, subst_reloads,\n+\tcopy_replacements, refers_to_regno_for_reload_p,\n+\treg_overlap_mentioned_for_reload_p): Likewise.\n+\t* reload1.c (compute_use_by_pseudos, replace_pseudos_in, reload,\n+\tcount_pseudo, find_reg, eliminate_regs, eliminate_regs_in_insn,\n+\tverify_initial_elim_offsets, finish_spills, clear_reload_reg_in_use,\n+\treload_reg_free_p, reload_reg_reaches_end_p, reloads_conflict,\n+\tchoose_reload_regs, merge_assigned_reloads, emit_input_reload_insns,\n+\tdo_output_reload, fixup_abnormal_edges): Likewise.\n+\t* reorg.c (stop_search_p, emit_delay_sequence, get_jump_flags,\n+\tfill_slots_from_thread, relax_delay_slots): Likewise.\n+\t* resource.c (mark_referenced_resources, mark_set_resources):\n+\tLikewise.\n+\t* rtl.c (copy_rtx, rtx_equal_p): Likewise.\n+\t* rtlanal.c (insn_dependent_p, reg_overlap_mentioned_p,\n+\tdead_or_set_p, find_reg_fusage, remove_note, replace_rtx,\n+\tsubreg_lsb_1, subreg_regno_offset, subreg_offset_representable_p,\n+\tfind_first_parameter_load, can_hoist_insn_p, hoist_update_store,\n+\thoist_insn_after, hoist_insn_to_edge, nonzero_bits1): Likewise.\n+\t* rtlhooks.c (gen_lowpart_general): Likewise.\n+\t* sbitmap.c (sbitmap_difference): Likewise.\n+\t* sched-deps.c (add_dependence, sched_analyze_1, sched_analyze_2,\n+\tsched_analyze, add_forward_dependence): Likewise.\n+\t* sched-ebb.c (fix_basic_block_boundaries, schedule_ebb): Likewise.\n+\t* sched-rgn.c (debug_regions, compute_trg_info, schedule_region,\n+\tschedule_insns): Likewise.\n+\t* sched-vis.c (print_pattern): Likewise.\n+\t* sdbout.c (sdbout_symbol, sdbout_toplevel_data): Likewise.\n+\t* simplify-rtx.c (simplify_unary_operation, simplify_binary_operation,\n+\tsimplify_const_relational_operation, simplify_ternary_operation,\n+\tsimplify_immed_subreg, simplify_subreg, simplify_gen_subreg):\n+\tLikewise.\n+\t* sreal.c (copy, sreal_sub, sreal_div): Likewise.\n+\t* stmt.c (force_label_rtx, expand_goto, expand_asm_operands,\n+\tresolve_operand_name_1, expand_return, expand_decl,\n+\texpand_anon_union_decl, emit_case_bit_tests, expand_case): Likewise.\n+\t* stor-layout.c (put_pending_size, smallest_mode_for_size,\n+\tint_mode_for_mode, layout_decl, finish_builtin_struct, layout_type,\n+\tset_sizetype, get_mode_bounds): Likewise.\n+\n 2004-09-09  Zack Weinberg  <zack@codesourcery.com>\n \n \t* defaults.h (MULTIPLE_SYMBOL_SPACES): Provide default.\n@@ -16,7 +98,7 @@\n \t* config/ia64/ia64.c (ia64_gimplify_va_arg): Ditto.\n \t* tree.h: Declare new function.\n \n-2004-09-08  Nathan Sidwell  <nathan@codesourcery.com>\n+2004-09-09  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* cgraphunit.c (cgraph_mark_functions_to_output): Renable node\n \tdumping for development builds.\n@@ -27,7 +109,7 @@\n \t* tree.c (iterative_hash_expr): Replace gcc_unreachable with\n \tgcc_assert.\n \n-2004-09-08  Nathan Sidwell  <nathan@codesourcery.com>\n+2004-09-09  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* gcse.c (INSN_CUID, insert_set_in_table, find_avail_set,\n \tcprop_insn, do_local_cprop, local_cprop_pass, find_bypass_set,"}, {"sha": "130b37606a2370efeb197bd13212cffa5978d452", "filename": "gcc/ra-build.c", "status": "modified", "additions": 82, "deletions": 117, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fra-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fra-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-build.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -228,8 +228,7 @@ copy_insn_p (rtx insn, rtx *source, rtx *target)\n   unsigned int d_regno, s_regno;\n   int uid = INSN_UID (insn);\n \n-  if (!INSN_P (insn))\n-    abort ();\n+  gcc_assert (INSN_P (insn));\n \n   /* First look, if we already saw this insn.  */\n   if (copy_cache[uid].seen)\n@@ -541,24 +540,25 @@ remember_move (rtx insn)\n   if (!TEST_BIT (move_handled, INSN_UID (insn)))\n     {\n       rtx s, d;\n+      int ret;\n+      struct df_link *slink = DF_INSN_USES (df, insn);\n+      struct df_link *link = DF_INSN_DEFS (df, insn);\n+      \n       SET_BIT (move_handled, INSN_UID (insn));\n-      if (copy_insn_p (insn, &s, &d))\n-\t{\n-\t  /* Some sanity test for the copy insn.  */\n-\t  struct df_link *slink = DF_INSN_USES (df, insn);\n-\t  struct df_link *link = DF_INSN_DEFS (df, insn);\n-\t  if (!link || !link->ref || !slink || !slink->ref)\n-\t    abort ();\n-\t  /* The following (link->next != 0) happens when a hardreg\n-\t     is used in wider mode (REG:DI %eax).  Then df.* creates\n-\t     a def/use for each hardreg contained therein.  We only\n-\t     allow hardregs here.  */\n-\t  if (link->next\n-\t      && DF_REF_REGNO (link->next->ref) >= FIRST_PSEUDO_REGISTER)\n-\t    abort ();\n-\t}\n-      else\n-\tabort ();\n+      ret = copy_insn_p (insn, &s, &d);\n+      gcc_assert (ret);\n+      \n+      /* Some sanity test for the copy insn.  */\n+      gcc_assert (link && link->ref);\n+      gcc_assert (slink && slink->ref);\n+      /* The following (link->next != 0) happens when a hardreg\n+\t  is used in wider mode (REG:DI %eax).  Then df.* creates\n+\t  a def/use for each hardreg contained therein.  We only\n+\t  allow hardregs here.  */\n+      gcc_assert (!link->next\n+\t\t  || DF_REF_REGNO (link->next->ref)\n+\t\t      < FIRST_PSEUDO_REGISTER);\n+      \n       /* XXX for now we don't remember move insns involving any subregs.\n \t Those would be difficult to coalesce (we would need to implement\n \t handling of all the subwebs in the allocator, including that such\n@@ -669,7 +669,7 @@ defuse_overlap_p_1 (rtx def, struct curr_use *use)\n \t  return (old_u != use->undefined) ? 4 : -1;\n \t}\n       default:\n-        abort ();\n+        gcc_unreachable ();\n     }\n }\n \n@@ -821,8 +821,7 @@ live_out_1 (struct df *df ATTRIBUTE_UNUSED, struct curr_use *use, rtx insn)\n \t{\n \t  /* If this insn doesn't completely define the USE, increment also\n \t     it's spanned deaths count (if this insn contains a death).  */\n-\t  if (uid >= death_insns_max_uid)\n-\t    abort ();\n+\t  gcc_assert (uid < death_insns_max_uid);\n \t  if (TEST_BIT (insns_with_deaths, uid))\n \t    wp->spanned_deaths++;\n \t  use->undefined = final_undef;\n@@ -1206,8 +1205,7 @@ prune_hardregs_for_mode (HARD_REG_SET *s, enum machine_mode mode)\n static void\n init_one_web_common (struct web *web, rtx reg)\n {\n-  if (!REG_P (reg))\n-    abort ();\n+  gcc_assert (REG_P (reg));\n   /* web->id isn't initialized here.  */\n   web->regno = REGNO (reg);\n   web->orig_x = reg;\n@@ -1272,8 +1270,7 @@ init_one_web_common (struct web *web, rtx reg)\n #endif\n       web->num_freedom = hard_regs_count (web->usable_regs);\n       web->num_freedom -= web->add_hardregs;\n-      if (!web->num_freedom)\n-\tabort();\n+      gcc_assert (web->num_freedom);\n     }\n   COPY_HARD_REG_SET (web->orig_usable_regs, web->usable_regs);\n }\n@@ -1324,10 +1321,8 @@ reinit_one_web (struct web *web, rtx reg)\n   web->stack_slot = NULL;\n   web->pattern = NULL;\n   web->alias = NULL;\n-  if (web->moves)\n-    abort ();\n-  if (!web->useless_conflicts)\n-    abort ();\n+  gcc_assert (!web->moves);\n+  gcc_assert (web->useless_conflicts);\n }\n \n /* Insert and returns a subweb corresponding to REG into WEB (which\n@@ -1337,8 +1332,7 @@ static struct web *\n add_subweb (struct web *web, rtx reg)\n {\n   struct web *w;\n-  if (GET_CODE (reg) != SUBREG)\n-    abort ();\n+  gcc_assert (GET_CODE (reg) == SUBREG);\n   w = xmalloc (sizeof (struct web));\n   /* Copy most content from parent-web.  */\n   *w = *web;\n@@ -1376,8 +1370,7 @@ add_subweb_2 (struct web *web, unsigned int  size_word)\n   mode = mode_for_size (size, GET_MODE_CLASS (GET_MODE (ref_rtx)), 0);\n   if (mode == BLKmode)\n     mode = mode_for_size (size, MODE_INT, 0);\n-  if (mode == BLKmode)\n-    abort ();\n+  gcc_assert (mode != BLKmode);\n   web = add_subweb (web, gen_rtx_SUBREG (mode, web->orig_x,\n \t\t\t\t\t BYTE_BEGIN (size_word)));\n   web->artificial = 1;\n@@ -1396,8 +1389,7 @@ init_web_parts (struct df *df)\n     {\n       if (df->defs[no])\n \t{\n-\t  if (no < last_def_id && web_parts[no].ref != df->defs[no])\n-\t    abort ();\n+\t  gcc_assert (no >= last_def_id || web_parts[no].ref == df->defs[no]);\n \t  web_parts[no].ref = df->defs[no];\n \t  /* Uplink might be set from the last iteration.  */\n \t  if (!web_parts[no].uplink)\n@@ -1414,9 +1406,8 @@ init_web_parts (struct df *df)\n     {\n       if (df->uses[no])\n \t{\n-\t  if (no < last_use_id\n-\t      && web_parts[no + df->def_id].ref != df->uses[no])\n-\t    abort ();\n+\t  gcc_assert (no >= last_use_id\n+\t\t      || web_parts[no + df->def_id].ref == df->uses[no]);\n \t  web_parts[no + df->def_id].ref = df->uses[no];\n \t  if (!web_parts[no + df->def_id].uplink)\n \t    num_webs++;\n@@ -1464,8 +1455,8 @@ static void\n copy_conflict_list (struct web *web)\n {\n   struct conflict_link *cl;\n-  if (web->orig_conflict_list || web->have_orig_conflicts)\n-    abort ();\n+  gcc_assert (!web->orig_conflict_list);\n+  gcc_assert (!web->have_orig_conflicts);\n   web->have_orig_conflicts = 1;\n   for (cl = web->conflict_list; cl; cl = cl->next)\n     {\n@@ -1572,8 +1563,7 @@ record_conflict (struct web *web1, struct web *web2)\n   /* Trivial non-conflict or already recorded conflict.  */\n   if (web1 == web2 || TEST_BIT (igraph, index))\n     return;\n-  if (id1 == id2)\n-    abort ();\n+  gcc_assert (id1 != id2);\n   /* As fixed_regs are no targets for allocation, conflicts with them\n      are pointless.  */\n   if ((web1->regno < FIRST_PSEUDO_REGISTER && fixed_regs[web1->regno])\n@@ -1663,32 +1653,27 @@ compare_and_free_webs (struct web_link **link)\n     {\n       struct web *web1 = wl->web;\n       struct web *web2 = ID2WEB (web1->id);\n-      if (web1->regno != web2->regno\n-\t  || web1->mode_changed != web2->mode_changed\n-\t  || !rtx_equal_p (web1->orig_x, web2->orig_x)\n-\t  || web1->type != web2->type\n-\t  /* Only compare num_defs/num_uses with non-hardreg webs.\n-\t     E.g. the number of uses of the framepointer changes due to\n-\t     inserting spill code.  */\n-\t  || (web1->type != PRECOLORED\n-\t      && (web1->num_uses != web2->num_uses\n-\t          || web1->num_defs != web2->num_defs))\n-\t  /* Similarly, if the framepointer was unreferenced originally\n-\t     but we added spills, these fields may not match.  */\n-\t  || (web1->type != PRECOLORED\n-               && web1->crosses_call != web2->crosses_call)\n-\t  || (web1->type != PRECOLORED\n-\t       && web1->live_over_abnormal != web2->live_over_abnormal))\n-\tabort ();\n+      gcc_assert (web1->regno == web2->regno);\n+      gcc_assert (web1->mode_changed == web2->mode_changed);\n+      gcc_assert (rtx_equal_p (web1->orig_x, web2->orig_x));\n+      gcc_assert (web1->type == web2->type);\n       if (web1->type != PRECOLORED)\n \t{\n \t  unsigned int i;\n+\n+\t  /* Only compare num_defs/num_uses with non-hardreg webs.\n+\t      E.g. the number of uses of the framepointer changes due to\n+\t      inserting spill code.  */\n+\t  gcc_assert (web1->num_uses == web2->num_uses);\n+\t  gcc_assert (web1->num_defs == web2->num_defs);\n+\t  /* Similarly, if the framepointer was unreferenced originally\n+\t      but we added spills, these fields may not match.  */\n+\t  gcc_assert (web1->crosses_call == web2->crosses_call);\n+\t  gcc_assert (web1->live_over_abnormal == web2->live_over_abnormal);\n \t  for (i = 0; i < web1->num_defs; i++)\n-\t    if (web1->defs[i] != web2->defs[i])\n-\t      abort ();\n+\t    gcc_assert (web1->defs[i] == web2->defs[i]);\n \t  for (i = 0; i < web1->num_uses; i++)\n-\t    if (web1->uses[i] != web2->uses[i])\n-\t      abort ();\n+\t    gcc_assert (web1->uses[i] == web2->uses[i]);\n \t}\n       if (web1->type == PRECOLORED)\n \t{\n@@ -1733,8 +1718,8 @@ init_webs_defs_uses (void)\n \t    web->uses[use_i++] = link->ref;\n \t}\n       web->temp_refs = NULL;\n-      if (def_i != web->num_defs || use_i != web->num_uses)\n-\tabort ();\n+      gcc_assert (def_i == web->num_defs);\n+      gcc_assert (use_i == web->num_uses);\n     }\n }\n \n@@ -1834,11 +1819,13 @@ parts_to_webs_1 (struct df *df, struct web_link **copy_webs,\n \t  web->id = newid;\n \t  web->temp_refs = NULL;\n \t  webnum++;\n-\t  if (web->regno < FIRST_PSEUDO_REGISTER && !hardreg2web[web->regno])\n-\t    hardreg2web[web->regno] = web;\n-\t  else if (web->regno < FIRST_PSEUDO_REGISTER\n-\t\t   && hardreg2web[web->regno] != web)\n-\t    abort ();\n+\t  if (web->regno < FIRST_PSEUDO_REGISTER)\n+\t    {\n+\t      if (!hardreg2web[web->regno])\n+\t\thardreg2web[web->regno] = web;\n+\t      else\n+\t\tgcc_assert (hardreg2web[web->regno] == web);\n+\t    }\n \t}\n \n       /* If this reference already had a web assigned, we are done.\n@@ -1861,8 +1848,8 @@ parts_to_webs_1 (struct df *df, struct web_link **copy_webs,\n \t    web->live_over_abnormal = 1;\n \t  /* And check, that it's not a newly allocated web.  This would be\n \t     an inconsistency.  */\n-\t  if (!web->old_web || web->type == PRECOLORED)\n-\t    abort ();\n+\t  gcc_assert (web->old_web);\n+\t  gcc_assert (web->type != PRECOLORED);\n \t  continue;\n \t}\n       /* In case this was no web part root, we need to initialize WEB\n@@ -1884,8 +1871,7 @@ parts_to_webs_1 (struct df *df, struct web_link **copy_webs,\n \n       /* And the test, that if def2web[i] was NULL above, that we are _not_\n \t an old web.  */\n-      if (web->old_web && web->type != PRECOLORED)\n-\tabort ();\n+      gcc_assert (!web->old_web || web->type == PRECOLORED);\n \n       /* Possible create a subweb, if this ref was a subreg.  */\n       if (GET_CODE (reg) == SUBREG)\n@@ -1894,8 +1880,7 @@ parts_to_webs_1 (struct df *df, struct web_link **copy_webs,\n \t  if (!subweb)\n \t    {\n \t      subweb = add_subweb (web, reg);\n-\t      if (web->old_web)\n-\t\tabort ();\n+\t      gcc_assert (!web->old_web);\n \t    }\n \t}\n       else\n@@ -1917,14 +1902,9 @@ parts_to_webs_1 (struct df *df, struct web_link **copy_webs,\n \t    {\n \t      struct web *compare = def2web[i];\n \t      if (i < last_def_id)\n-\t\t{\n-\t\t  if (web->old_web && compare != subweb)\n-\t\t    abort ();\n-\t\t}\n-\t      if (!web->old_web && compare)\n-\t\tabort ();\n-\t      if (compare && compare != subweb)\n-\t\tabort ();\n+\t\tgcc_assert (!web->old_web || compare == subweb);\n+\t      gcc_assert (web->old_web || !compare);\n+\t      gcc_assert (!compare || compare == subweb);\n \t    }\n \t  def2web[i] = subweb;\n \t  web->num_defs++;\n@@ -1934,15 +1914,11 @@ parts_to_webs_1 (struct df *df, struct web_link **copy_webs,\n \t  if (ra_pass > 1)\n \t    {\n \t      struct web *compare = use2web[ref_id];\n-\t      if (ref_id < last_use_id)\n-\t\t{\n-\t\t  if (web->old_web && compare != subweb)\n-\t\t    abort ();\n-\t\t}\n-\t      if (!web->old_web && compare)\n-\t\tabort ();\n-\t      if (compare && compare != subweb)\n-\t\tabort ();\n+\t      \n+\t      gcc_assert (ref_id >= last_use_id\n+\t\t\t  || !web->old_web || compare == subweb);\n+\t      gcc_assert (web->old_web || !compare);\n+\t      gcc_assert (!compare || compare == subweb);\n \t    }\n \t  use2web[ref_id] = subweb;\n \t  web->num_uses++;\n@@ -1952,8 +1928,7 @@ parts_to_webs_1 (struct df *df, struct web_link **copy_webs,\n     }\n \n   /* We better now have exactly as many webs as we had web part roots.  */\n-  if (webnum != num_webs)\n-    abort ();\n+  gcc_assert (webnum == num_webs);\n \n   return webnum;\n }\n@@ -2001,8 +1976,7 @@ parts_to_webs (struct df *df)\n       struct web *web;\n       if (wp->uplink || !wp->ref)\n \t{\n-\t  if (wp->sub_conflicts)\n-\t    abort ();\n+\t  gcc_assert (!wp->sub_conflicts);\n \t  continue;\n \t}\n       web = def2web[i];\n@@ -2087,8 +2061,7 @@ reset_conflicts (void)\n \t  web->conflict_list = web->orig_conflict_list;\n \t  web->orig_conflict_list = NULL;\n \t}\n-      if (web->orig_conflict_list)\n-\tabort ();\n+      gcc_assert (!web->orig_conflict_list);\n \n       /* New non-precolored webs, have no conflict list.  */\n       if (web->type != PRECOLORED && !web->old_web)\n@@ -2097,8 +2070,7 @@ reset_conflicts (void)\n \t  /* Useless conflicts will be rebuilt completely.  But check\n \t     for cleanliness, as the web might have come from the\n \t     free list.  */\n-\t  if (bitmap_first_set_bit (web->useless_conflicts) >= 0)\n-\t    abort ();\n+\t  gcc_assert (bitmap_first_set_bit (web->useless_conflicts) < 0);\n \t}\n       else\n \t{\n@@ -2153,8 +2125,7 @@ check_conflict_numbers (void)\n       for (cl = web->conflict_list; cl; cl = cl->next)\n \tif (cl->t->type != SELECT && cl->t->type != COALESCED)\n \t  new_conf += 1 + cl->t->add_hardregs;\n-      if (web->type != PRECOLORED && new_conf != web->num_conflicts)\n-\tabort ();\n+      gcc_assert (web->type == PRECOLORED || new_conf == web->num_conflicts);\n     }\n }\n #endif\n@@ -2316,8 +2287,7 @@ remember_web_was_spilled (struct web *web)\n     AND_COMPL_HARD_REG_SET (web->usable_regs, invalid_mode_change_regs);\n #endif\n   web->num_freedom = hard_regs_count (web->usable_regs);\n-  if (!web->num_freedom)\n-    abort();\n+  gcc_assert (web->num_freedom);\n   COPY_HARD_REG_SET (web->orig_usable_regs, web->usable_regs);\n   /* Now look for a class, which is subset of our constraints, to\n      setup add_hardregs, and regclass for debug output.  */\n@@ -2345,8 +2315,7 @@ remember_web_was_spilled (struct web *web)\n   web->add_hardregs =\n     CLASS_MAX_NREGS (web->regclass, PSEUDO_REGNO_MODE (web->regno)) - 1;\n   web->num_freedom -= web->add_hardregs;\n-  if (!web->num_freedom)\n-    abort();\n+  gcc_assert (web->num_freedom);\n   adjust -= 0 * web->add_hardregs;\n   web->num_conflicts -= adjust;\n }\n@@ -2853,10 +2822,8 @@ handle_asm_insn (struct df *df, rtx insn)\n \t    link = link->next;\n \t  if (!link || !link->ref)\n \t    {\n-\t      if (in_output)\n-\t        in_output = 0;\n-\t      else\n-\t        abort ();\n+\t      gcc_assert (in_output);\n+\t      in_output = 0;\n \t    }\n \t  else\n \t    break;\n@@ -3124,11 +3091,9 @@ ra_build_free (void)\n   for (i = 0; i < num_webs; i++)\n     {\n       struct web *web = ID2WEB (i);\n-      if (!web)\n-\tabort ();\n-      if (i >= num_webs - num_subwebs\n-\t  && (web->conflict_list || web->orig_conflict_list))\n-\tabort ();\n+      gcc_assert (web);\n+      gcc_assert (i < num_webs - num_subwebs\n+\t\t  || (!web->conflict_list && !web->orig_conflict_list));\n       web->moves = NULL;\n     }\n   /* All webs in the free list have no defs or uses anymore.  */"}, {"sha": "0fe848af0f1d04e7bcf12f1931588eedb524aa09", "filename": "gcc/ra-colorize.c", "status": "modified", "additions": 109, "deletions": 99, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fra-colorize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fra-colorize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-colorize.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -105,8 +105,8 @@ static struct dlist *mv_frozen, *mv_active;\n static void\n push_list (struct dlist *x, struct dlist **list)\n {\n-  if (x->next || x->prev)\n-    abort ();\n+  gcc_assert (!x->next);\n+  gcc_assert (!x->prev);\n   x->next = *list;\n   if (*list)\n     (*list)->prev = x;\n@@ -116,8 +116,8 @@ push_list (struct dlist *x, struct dlist **list)\n static void\n push_list_end (struct dlist *x, struct dlist **list)\n {\n-  if (x->prev || x->next)\n-    abort ();\n+  gcc_assert (!x->prev);\n+  gcc_assert (!x->next);\n   if (!*list)\n     {\n       *list = x;\n@@ -195,7 +195,7 @@ put_web (struct web *web, enum ra_node_type type)\n \t  push_list (web->dlink, &WEBS(SIMPLIFY));\n \tbreak;\n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n   web->type = type;\n }\n@@ -211,9 +211,13 @@ reset_lists (void)\n {\n   struct dlist *d;\n   unsigned int i;\n-  if (WEBS(SIMPLIFY) || WEBS(SIMPLIFY_SPILL) || WEBS(SIMPLIFY_FAT)\n-      || WEBS(FREEZE) || WEBS(SPILL) || WEBS(SELECT))\n-    abort ();\n+\n+  gcc_assert (!WEBS(SIMPLIFY));\n+  gcc_assert (!WEBS(SIMPLIFY_SPILL));\n+  gcc_assert (!WEBS(SIMPLIFY_FAT));\n+  gcc_assert (!WEBS(FREEZE));\n+  gcc_assert (!WEBS(SPILL));\n+  gcc_assert (!WEBS(SELECT));\n \n   while ((d = pop_list (&WEBS(COALESCED))) != NULL)\n     {\n@@ -243,13 +247,16 @@ reset_lists (void)\n       web->useless_conflicts = NULL;\n     }\n \n-  /* Sanity check, that we only have free, initial or precolored webs.  */\n+#ifdef ENABLE_CHECKING\n+  /* Sanity check, that we only have free, initial or precolored webs. */\n   for (i = 0; i < num_webs; i++)\n     {\n       struct web *web = ID2WEB (i);\n-      if (web->type != INITIAL && web->type != FREE && web->type != PRECOLORED)\n-\tabort ();\n+      \n+      gcc_assert (web->type == INITIAL || web->type == FREE\n+\t\t  || web->type == PRECOLORED);\n     }\n+#endif\n   free_dlist (&mv_worklist);\n   free_dlist (&mv_coalesced);\n   free_dlist (&mv_constrained);\n@@ -265,8 +272,8 @@ put_web_at_end (struct web *web, enum ra_node_type type)\n {\n   if (type == PRECOLORED)\n     type = INITIAL;\n-  else if (type == SIMPLIFY)\n-    abort ();\n+  else\n+    gcc_assert (type != SIMPLIFY);\n   push_list_end (web->dlink, &WEBS(type));\n   web->type = type;\n }\n@@ -306,7 +313,7 @@ put_move (struct move *move, enum move_type type)\n \tpush_list (move->dlink, &mv_active);\n \tbreak;\n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n   move->type = type;\n }\n@@ -501,8 +508,7 @@ remove_move (struct web *web, struct move *move)\n   struct move_list *ml;\n   remove_move_1 (web, move);\n   for (ml = web->moves; ml; ml = ml->next)\n-    if (ml->move == move)\n-      abort ();\n+    gcc_assert (ml->move != move);\n }\n \n /* Merge the moves for the two webs into the first web's movelist.  */\n@@ -696,10 +702,10 @@ combine (struct web *u, struct web *v)\n {\n   int i;\n   struct conflict_link *wl;\n-  if (u == v || v->type == COALESCED)\n-    abort ();\n-  if ((u->regno >= max_normal_pseudo) != (v->regno >= max_normal_pseudo))\n-    abort ();\n+  gcc_assert (u != v);\n+  gcc_assert (v->type != COALESCED);\n+  gcc_assert ((u->regno >= max_normal_pseudo)\n+\t      == (v->regno >= max_normal_pseudo));\n   remove_web_from_list (v);\n   put_web (v, COALESCED);\n   v->alias = u;\n@@ -793,10 +799,9 @@ combine (struct web *u, struct web *v)\n      conflicts.  */\n   u->num_freedom = hard_regs_count (u->usable_regs);\n   u->num_freedom -= u->add_hardregs;\n-  /* The next would mean an invalid coalesced move (both webs have no\n-     possible hardreg in common), so abort.  */\n-  if (!u->num_freedom)\n-    abort();\n+  /* The next checks for an invalid coalesced move (both webs must have\n+     possible hardregs in common).  */\n+  gcc_assert (u->num_freedom);\n \n   if (u->num_conflicts >= NUM_REGS (u)\n       && (u->type == FREEZE || simplify_p (u->type)))\n@@ -970,8 +975,7 @@ select_spill (void)\n       bestd = bestd2;\n       best = best2;\n     }\n-  if (!bestd)\n-    abort ();\n+  gcc_assert (bestd);\n \n   /* Note the potential spill.  */\n   DLIST_WEB (bestd)->was_spilled = 1;\n@@ -1429,7 +1433,7 @@ colorize_one_web (struct web *web, int hard)\n   if (c < 0)\n     {\n       /* Guard against a simplified node being spilled.  */\n-      /* Don't abort.  This can happen, when e.g. enough registers\n+      /* Don't assert.  This can happen, when e.g. enough registers\n \t are available in colors, but they are not consecutive.  This is a\n \t very serious issue if this web is a short live one, because\n \t even if we spill this one here, the situation won't become better\n@@ -1440,8 +1444,7 @@ colorize_one_web (struct web *web, int hard)\n \t again.  That's why we try to find a neighbor, which spans more\n \t instructions that ourself, and got a color, and try to spill _that_.\n \n-\t if (DLIST_WEB (d)->was_spilled < 0)\n-\t abort (); */\n+\t gcc_assert (DLIST_WEB (d)->was_spilled >= 0);  */\n       if (hard && (!web->was_spilled || web->spill_temp))\n \t{\n \t  unsigned int loop;\n@@ -1536,8 +1539,7 @@ colorize_one_web (struct web *web, int hard)\n \t      int old_c = try->color;\n \t      if (try->type == COALESCED)\n \t\t{\n-\t\t  if (alias (try)->type != PRECOLORED)\n-\t\t    abort ();\n+\t\t  gcc_assert (alias (try)->type == PRECOLORED);\n \t\t  ra_debug_msg (DUMP_COLORIZE, \"  breaking alias %d -> %d\\n\",\n \t\t\t     try->id, alias (try)->id);\n \t\t  break_precolored_alias (try);\n@@ -1800,9 +1802,8 @@ try_recolor_web (struct web *web)\n          above what happens, when wide webs are involved, and why in that\n          case there might actually be some webs spilled although thought to\n          be colorable.  */\n-      if (cost > cost_neighbors[newcol]\n-\t  && nregs == 1 && !TEST_HARD_REG_BIT (wide_seen, newcol))\n-\tabort ();\n+      gcc_assert (cost <= cost_neighbors[newcol]\n+\t\t  || nregs != 1 || TEST_HARD_REG_BIT (wide_seen, newcol));\n       /* But if the new spill-cost is higher than our own, then really loose.\n \t Respill us and recolor neighbors as before.  */\n       if (cost > web->spill_cost)\n@@ -1817,26 +1818,29 @@ try_recolor_web (struct web *web)\n \t      struct web *web2 = alias (wl->t);\n \t      if (old_colors[web2->id])\n \t\t{\n-\t\t  if (web2->type == SPILLED)\n+\t\t  switch (web2->type)\n \t\t    {\n+\t\t    case SPILLED:\n \t\t      remove_list (web2->dlink, &WEBS(SPILLED));\n \t\t      web2->color = old_colors[web2->id] - 1;\n \t\t      put_web (web2, COLORED);\n+\t\t      break;\n+\t\t    case COLORED:\n+\t\t      web2->color = old_colors[web2->id] - 1;\n+\t\t      break;\n+\t\t    case SELECT:\n+\t\t      /* This means, that WEB2 once was a part of a coalesced\n+\t\t\tweb, which got spilled in the above colorize_one_web()\n+\t\t\tcall, and whose parts then got split and put back\n+\t\t\tonto the SELECT stack.  As the cause for that splitting\n+\t\t\t(the coloring of WEB) was worthless, we should again\n+\t\t\tcoalesce the parts, as they were before.  For now we\n+\t\t\tsimply leave them SELECTed, for our caller to take\n+\t\t\tcare.  */\n+\t\t      break;\n+\t\t    default:\n+\t\t      gcc_unreachable ();\n \t\t    }\n-\t\t  else if (web2->type == COLORED)\n-\t\t    web2->color = old_colors[web2->id] - 1;\n-\t\t  else if (web2->type == SELECT)\n-\t\t    /* This means, that WEB2 once was a part of a coalesced\n-\t\t       web, which got spilled in the above colorize_one_web()\n-\t\t       call, and whose parts then got split and put back\n-\t\t       onto the SELECT stack.  As the cause for that splitting\n-\t\t       (the coloring of WEB) was worthless, we should again\n-\t\t       coalesce the parts, as they were before.  For now we\n-\t\t       simply leave them SELECTed, for our caller to take\n-\t\t       care.  */\n-\t\t    ;\n-\t\t  else\n-\t\t    abort ();\n \t\t}\n \t    }\n \t}\n@@ -1878,16 +1882,16 @@ insert_coalesced_conflicts (void)\n \t\t when first some webs were coalesced and conflicts\n \t\t propagated, then some combining narrowed usable_regs and\n \t\t further coalescing ignored those conflicts.  Now there are\n-\t\t some edges to COALESCED webs but not to it's alias.\n-\t\t So abort only when they really should conflict.  */\n-\t      if ((!(tweb->type == PRECOLORED\n-\t\t     || TEST_BIT (sup_igraph, tweb->id * num_webs + wl->t->id))\n-\t\t   || !(wl->t->type == PRECOLORED\n-\t\t        || TEST_BIT (sup_igraph,\n-\t\t\t\t     wl->t->id * num_webs + tweb->id)))\n-\t\t  && hard_regs_intersect_p (&tweb->usable_regs,\n-\t\t\t\t\t    &wl->t->usable_regs))\n-\t\tabort ();\n+\t\t some edges to COALESCED webs but not to its alias.\n+\t\t So assert they really don not conflict.  */\n+\t      gcc_assert (((tweb->type == PRECOLORED\n+\t\t\t    || TEST_BIT (sup_igraph,\n+\t\t\t\t\t tweb->id * num_webs + wl->t->id))\n+\t\t\t   && (wl->t->type == PRECOLORED\n+\t\t\t       || TEST_BIT (sup_igraph,\n+\t\t\t\t\t    wl->t->id * num_webs + tweb->id)))\n+\t\t\t  || !hard_regs_intersect_p (&tweb->usable_regs,\n+\t\t\t\t\t\t     &wl->t->usable_regs));\n \t      /*if (wl->sub == NULL)\n \t\trecord_conflict (tweb, wl->t);\n \t      else\n@@ -1970,18 +1974,32 @@ check_colors (void)\n       struct web *aweb = alias (web);\n       struct conflict_link *wl;\n       int nregs, c;\n-      if (aweb->type == SPILLED || web->regno >= max_normal_pseudo)\n+\n+      if (web->regno >= max_normal_pseudo)\n \tcontinue;\n-      else if (aweb->type == COLORED)\n-\tnregs = hard_regno_nregs[aweb->color][GET_MODE (web->orig_x)];\n-      else if (aweb->type == PRECOLORED)\n-\tnregs = 1;\n-      else\n-\tabort ();\n+      \n+      switch (aweb->type)\n+\t{\n+\tcase SPILLED:\n+\t  continue;\n+\n+\tcase COLORED:\n+\t  nregs = hard_regno_nregs[aweb->color][GET_MODE (web->orig_x)];\n+\t  break;\n+\n+\tcase PRECOLORED:\n+\t  nregs = 1;\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+#ifdef ENABLE_CHECKING\n       /* The color must be valid for the original usable_regs.  */\n       for (c = 0; c < nregs; c++)\n-\tif (!TEST_HARD_REG_BIT (web->usable_regs, aweb->color + c))\n-\t  abort ();\n+\tgcc_assert (TEST_HARD_REG_BIT (web->usable_regs, aweb->color + c));\n+#endif\n       /* Search the original (pre-coalesce) conflict list.  In the current\n \t one some imprecise conflicts may be noted (due to combine() or\n \t insert_coalesced_conflicts() relocating partial conflicts) making\n@@ -2002,10 +2020,9 @@ check_colors (void)\n \t      nregs2 = 1;\n \t    else\n \t      continue;\n-\t    if (aweb->color >= web2->color + nregs2\n-\t        || web2->color >= aweb->color + nregs)\n-\t      continue;\n-\t    abort ();\n+\t    gcc_assert (aweb->color >= web2->color + nregs2\n+\t\t\t|| web2->color >= aweb->color + nregs);\n+\t    continue;\n \t  }\n \telse\n \t  {\n@@ -2026,10 +2043,9 @@ check_colors (void)\n \t\t    && GET_MODE_SIZE (GET_MODE (sl->s->orig_x))\n \t\t       >= UNITS_PER_WORD)\n \t\t  sofs = (SUBREG_BYTE (sl->s->orig_x) / UNITS_PER_WORD);\n-\t\tif ((tcol + tofs >= scol + sofs + ssize)\n-\t\t    || (scol + sofs >= tcol + tofs + tsize))\n-\t\t  continue;\n-\t\tabort ();\n+\t\tgcc_assert ((tcol + tofs >= scol + sofs + ssize)\n+\t\t\t    || (scol + sofs >= tcol + tofs + tsize));\n+\t\tcontinue;\n \t      }\n \t  }\n     }\n@@ -2070,8 +2086,7 @@ static void\n break_aliases_to_web (struct web *web)\n {\n   struct dlist *d, *d_next;\n-  if (web->type != SPILLED)\n-    abort ();\n+  gcc_assert (web->type == SPILLED);\n   for (d = WEBS(COALESCED); d; d = d_next)\n     {\n       struct web *other = DLIST_WEB (d);\n@@ -2115,8 +2130,7 @@ break_precolored_alias (struct web *web)\n   struct conflict_link *wl;\n   unsigned int c = pre->color;\n   unsigned int nregs = hard_regno_nregs[c][GET_MODE (web->orig_x)];\n-  if (pre->type != PRECOLORED)\n-    abort ();\n+  gcc_assert (pre->type == PRECOLORED);\n   unalias_web (web);\n   /* Now we need to look at each conflict X of WEB, if it conflicts\n      with [PRE, PRE+nregs), and remove such conflicts, of X has not other\n@@ -2208,13 +2222,12 @@ restore_conflicts_from_coalesce (struct web *web)\n \t  struct sub_conflict *sl;\n \t  wl = *pcl;\n \t  *pcl = wl->next;\n-\t  if (!other->have_orig_conflicts && other->type != PRECOLORED)\n-\t    abort ();\n+\t  gcc_assert (other->have_orig_conflicts\n+\t\t      || other->type == PRECOLORED);\n \t  for (owl = other->orig_conflict_list; owl; owl = owl->next)\n \t    if (owl->t == web)\n \t      break;\n-\t  if (owl)\n-\t    abort ();\n+\t  gcc_assert (!owl);\n \t  opcl = &(other->conflict_list);\n \t  while (*opcl)\n \t    {\n@@ -2229,8 +2242,7 @@ restore_conflicts_from_coalesce (struct web *web)\n \t\t  opcl = &((*opcl)->next);\n \t\t}\n \t    }\n-\t  if (!owl && other->type != PRECOLORED)\n-\t    abort ();\n+\t  gcc_assert (owl || other->type == PRECOLORED);\n \t  /* wl and owl contain the edge data to be deleted.  */\n \t  RESET_BIT (sup_igraph, web->id * num_webs + other->id);\n \t  RESET_BIT (sup_igraph, other->id * num_webs + web->id);\n@@ -2429,8 +2441,7 @@ sort_and_combine_web_pairs (int for_move)\n   sorted = xmalloc (num_web_pairs * sizeof (sorted[0]));\n   for (p = web_pair_list, i = 0; p; p = p->next_list)\n     sorted[i++] = p;\n-  if (i != num_web_pairs)\n-    abort ();\n+  gcc_assert (i == num_web_pairs);\n   qsort (sorted, num_web_pairs, sizeof (sorted[0]), comp_web_pairs);\n \n   /* After combining one pair, we actually should adjust the savings\n@@ -2624,17 +2635,16 @@ check_uncoalesced_moves (void)\n \t    s = t;\n \t    t = h;\n \t  }\n-\tif (s != t\n-\t    && m->type != CONSTRAINED\n-\t    /* Following can happen when a move was coalesced, but later\n-\t       broken up again.  Then s!=t, but m is still MV_COALESCED.  */\n-\t    && m->type != MV_COALESCED\n-\t    && t->type != PRECOLORED\n-\t    && ((s->type == PRECOLORED && ok (t, s))\n-\t\t|| s->type != PRECOLORED)\n-\t    && !TEST_BIT (sup_igraph, s->id * num_webs + t->id)\n-\t    && !TEST_BIT (sup_igraph, t->id * num_webs + s->id))\n-\t  abort ();\n+\tgcc_assert (s == t\n+\t\t    || m->type == CONSTRAINED\n+\t\t    /* Following can happen when a move was coalesced, but\n+\t\t       later broken up again.  Then s!=t, but m is still\n+\t\t       MV_COALESCED.  */\n+\t\t    || m->type == MV_COALESCED\n+\t\t    || t->type == PRECOLORED\n+\t\t    || (s->type == PRECOLORED && !ok (t, s))\n+\t\t    || TEST_BIT (sup_igraph, s->id * num_webs + t->id)\n+\t\t    || TEST_BIT (sup_igraph, t->id * num_webs + s->id));\n       }\n }\n "}, {"sha": "adc39831686c4b6104190b70c9da3906bf83685d", "filename": "gcc/ra-rewrite.c", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fra-rewrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fra-rewrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-rewrite.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -119,8 +119,8 @@ spill_coalescing (sbitmap coalesce, sbitmap spilled)\n \t       T from the web which was coalesced into T, which at the time\n \t       of combine() were not already on the SELECT stack or were\n \t       itself coalesced to something other.  */\n-\t    if (t->type != SPILLED || s->type != SPILLED)\n-\t      abort ();\n+\t    gcc_assert (t->type == SPILLED\n+\t\t\t&& s->type == SPILLED);\n \t    remove_list (t->dlink, &WEBS(SPILLED));\n \t    put_web (t, COALESCED);\n \t    t->alias = s;\n@@ -570,8 +570,7 @@ slots_overlap_p (rtx s1, rtx s2)\n \treturn 0;\n       return 1;\n     }\n-  if (!MEM_P (s1) || GET_CODE (s2) != MEM)\n-    abort ();\n+  gcc_assert (MEM_P (s1) && GET_CODE (s2) == MEM);\n   s1 = XEXP (s1, 0);\n   s2 = XEXP (s2, 0);\n   if (GET_CODE (s1) != PLUS || !REG_P (XEXP (s1, 0))\n@@ -873,8 +872,7 @@ emit_loads (struct rewrite_info *ri, int nl_first_reload, rtx last_block_insn)\n       if (!web)\n \tcontinue;\n       supweb = find_web_for_subweb (web);\n-      if (supweb->regno >= max_normal_pseudo)\n-\tabort ();\n+      gcc_assert (supweb->regno < max_normal_pseudo);\n       /* Check for web being a spilltemp, if we only want to\n \t load spilltemps.  Also remember, that we emitted that\n \t load, which we don't need to do when we have a death,\n@@ -900,14 +898,12 @@ emit_loads (struct rewrite_info *ri, int nl_first_reload, rtx last_block_insn)\n \t     (at least then disallow spilling them, which we already ensure\n \t     when flag_ra_break_aliases), or not take the pattern but a\n \t     stackslot.  */\n-\t  if (aweb != supweb)\n-\t    abort ();\n+\t  gcc_assert (aweb == supweb);\n \t  slot = copy_rtx (supweb->pattern);\n \t  reg = copy_rtx (supweb->orig_x);\n \t  /* Sanity check.  orig_x should be a REG rtx, which should be\n \t     shared over all RTL, so copy_rtx should have no effect.  */\n-\t  if (reg != supweb->orig_x)\n-\t    abort ();\n+\t  gcc_assert (reg == supweb->orig_x);\n \t}\n       else\n \t{\n@@ -1022,8 +1018,7 @@ reloads_to_loads (struct rewrite_info *ri, struct ref **refs,\n \t    {\n \t      struct web *web2 = ID2WEB (j);\n \t      struct web *aweb2 = alias (find_web_for_subweb (web2));\n-\t      if (spill_is_free (&(ri->colors_in_use), aweb2) == 0)\n-\t\tabort ();\n+\t      gcc_assert (spill_is_free (&(ri->colors_in_use), aweb2) != 0);\n \t      if (spill_same_color_p (supweb, aweb2)\n \t\t  /* && interfere (web, web2) */)\n \t\t{\n@@ -1396,8 +1391,7 @@ rewrite_program2 (bitmap new_deaths)\n \n       ri.need_load = 1;\n       emit_loads (&ri, nl_first_reload, last_block_insn);\n-      if (ri.nl_size != 0 /*|| ri.num_reloads != 0*/)\n-\tabort ();\n+      gcc_assert (ri.nl_size == 0);\n       if (!insn)\n \tbreak;\n     }\n@@ -1677,8 +1671,8 @@ emit_colors (struct df *df)\n \tcontinue;\n       if (web->type == COALESCED && alias (web)->type == COLORED)\n \tcontinue;\n-      if (web->reg_rtx || web->regno < FIRST_PSEUDO_REGISTER)\n-\tabort ();\n+      gcc_assert (!web->reg_rtx);\n+      gcc_assert (web->regno >= FIRST_PSEUDO_REGISTER);\n \n       if (web->regno >= max_normal_pseudo)\n \t{"}, {"sha": "a821623ba529e8a56fab0935d58001a6fd90d448", "filename": "gcc/ra.c", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -221,9 +221,11 @@ static int\n first_hard_reg (HARD_REG_SET rs)\n {\n   int c;\n-  for (c = 0; c < FIRST_PSEUDO_REGISTER && !TEST_HARD_REG_BIT (rs, c); c++)\n-  if (c == FIRST_PSEUDO_REGISTER)\n-    abort();\n+  \n+  for (c = 0; c < FIRST_PSEUDO_REGISTER; c++)\n+    if (TEST_HARD_REG_BIT (rs, c))\n+      break;\n+  gcc_assert (c < FIRST_PSEUDO_REGISTER);\n   return c;\n }\n \n@@ -291,8 +293,7 @@ create_insn_info (struct df *df)\n       act_refs += n;\n       insn_df[uid].num_uses = n;\n     }\n-  if (refs_for_insn_df + (df->def_id + df->use_id) < act_refs)\n-    abort ();\n+  gcc_assert (refs_for_insn_df + (df->def_id + df->use_id) >= act_refs);\n }\n \n /* Free the insn_df structures.  */\n@@ -315,8 +316,7 @@ struct web *\n find_subweb (struct web *web, rtx reg)\n {\n   struct web *w;\n-  if (GET_CODE (reg) != SUBREG)\n-    abort ();\n+  gcc_assert (GET_CODE (reg) == SUBREG);\n   for (w = web->subreg_next; w; w = w->subreg_next)\n     if (GET_MODE (w->orig_x) == GET_MODE (reg)\n \t&& SUBREG_BYTE (w->orig_x) == SUBREG_BYTE (reg))\n@@ -577,8 +577,7 @@ init_ra (void)\n        an_unusable_color++)\n     if (TEST_HARD_REG_BIT (never_use_colors, an_unusable_color))\n       break;\n-  if (an_unusable_color == FIRST_PSEUDO_REGISTER)\n-    abort ();\n+  gcc_assert (an_unusable_color != FIRST_PSEUDO_REGISTER);\n \n   orig_max_uid = get_max_uid ();\n   compute_bb_for_insn ();\n@@ -589,7 +588,7 @@ init_ra (void)\n   gcc_obstack_init (&ra_obstack);\n }\n \n-/* Check the consistency of DF.  This aborts if it violates some\n+/* Check the consistency of DF.  This asserts if it violates some\n    invariances we expect.  */\n \n static void\n@@ -620,39 +619,43 @@ check_df (struct df *df)\n       {\n \tbitmap_clear (b);\n \tfor (link = DF_INSN_DEFS (df, insn); link; link = link->next)\n-\t  if (!link->ref || bitmap_bit_p (empty_defs, DF_REF_ID (link->ref))\n-\t      || bitmap_bit_p (b, DF_REF_ID (link->ref)))\n-\t    abort ();\n-\t  else\n+\t  {\n+\t    gcc_assert (link->ref);\n+\t    gcc_assert (!bitmap_bit_p (empty_defs, DF_REF_ID (link->ref)));\n+\t    gcc_assert (!bitmap_bit_p (b, DF_REF_ID (link->ref)));\n \t    bitmap_set_bit (b, DF_REF_ID (link->ref));\n+\t  }\n \n \tbitmap_clear (b);\n \tfor (link = DF_INSN_USES (df, insn); link; link = link->next)\n-\t  if (!link->ref || bitmap_bit_p (empty_uses, DF_REF_ID (link->ref))\n-\t      || bitmap_bit_p (b, DF_REF_ID (link->ref)))\n-\t    abort ();\n-\t  else\n+\t  {\n+\t    gcc_assert (link->ref);\n+\t    gcc_assert (!bitmap_bit_p (empty_uses, DF_REF_ID (link->ref)));\n+\t    gcc_assert (!bitmap_bit_p (b, DF_REF_ID (link->ref)));\n \t    bitmap_set_bit (b, DF_REF_ID (link->ref));\n+\t  }\n       }\n \n   /* Now the same for the chains per register number.  */\n   for (regno = 0; regno < max_reg_num (); regno++)\n     {\n       bitmap_clear (b);\n       for (link = df->regs[regno].defs; link; link = link->next)\n-\tif (!link->ref || bitmap_bit_p (empty_defs, DF_REF_ID (link->ref))\n-\t    || bitmap_bit_p (b, DF_REF_ID (link->ref)))\n-\t  abort ();\n-\telse\n+\t{\n+\t  gcc_assert (link->ref);\n+\t  gcc_assert (!bitmap_bit_p (empty_defs, DF_REF_ID (link->ref)));\n+\t  gcc_assert (!bitmap_bit_p (b, DF_REF_ID (link->ref)));\n \t  bitmap_set_bit (b, DF_REF_ID (link->ref));\n+\t}\n \n       bitmap_clear (b);\n       for (link = df->regs[regno].uses; link; link = link->next)\n-\tif (!link->ref || bitmap_bit_p (empty_uses, DF_REF_ID (link->ref))\n-\t    || bitmap_bit_p (b, DF_REF_ID (link->ref)))\n-\t  abort ();\n-\telse\n+\t{\n+\t  gcc_assert (link->ref);\n+\t  gcc_assert (!bitmap_bit_p (empty_uses, DF_REF_ID (link->ref)));\n+\t  gcc_assert (!bitmap_bit_p (b, DF_REF_ID (link->ref)));\n \t  bitmap_set_bit (b, DF_REF_ID (link->ref));\n+\t}\n     }\n \n   BITMAP_XFREE (empty_uses);"}, {"sha": "871fae73f34c18686dedfc388a01935fa4a50bd2", "filename": "gcc/real.c", "status": "modified", "additions": 53, "deletions": 64, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -577,7 +577,7 @@ do_add (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* Swap the arguments such that A has the larger exponent.  */\n@@ -708,7 +708,7 @@ do_multiply (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (r == a || r == b)\n@@ -850,7 +850,7 @@ do_divide (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (r == a || r == b)\n@@ -929,7 +929,7 @@ do_compare (const REAL_VALUE_TYPE *a, const REAL_VALUE_TYPE *b,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (a->sign != b->sign)\n@@ -967,7 +967,7 @@ do_fix_trunc (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -1031,7 +1031,7 @@ real_arithmetic (REAL_VALUE_TYPE *r, int icode, const REAL_VALUE_TYPE *op0,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -1084,7 +1084,7 @@ real_compare (int icode, const REAL_VALUE_TYPE *op0,\n       return do_compare (op0, op1, 0) != 0;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -1103,7 +1103,7 @@ real_exponent (const REAL_VALUE_TYPE *r)\n     case rvc_normal:\n       return REAL_EXP (r);\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -1131,7 +1131,7 @@ real_ldexp (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *op0, int exp)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -1199,7 +1199,7 @@ real_identical (const REAL_VALUE_TYPE *a, const REAL_VALUE_TYPE *b)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   for (i = 0; i < SIGSZ; ++i)\n@@ -1279,14 +1279,13 @@ real_to_integer (const REAL_VALUE_TYPE *r)\n \n       if (HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG)\n \ti = r->sig[SIGSZ-1];\n-      else if (HOST_BITS_PER_WIDE_INT == 2*HOST_BITS_PER_LONG)\n+      else \n \t{\n+\t  gcc_assert (HOST_BITS_PER_WIDE_INT == 2 * HOST_BITS_PER_LONG);\n \t  i = r->sig[SIGSZ-1];\n \t  i = i << (HOST_BITS_PER_LONG - 1) << 1;\n \t  i |= r->sig[SIGSZ-2];\n \t}\n-      else\n-\tabort ();\n \n       i >>= HOST_BITS_PER_WIDE_INT - REAL_EXP (r);\n \n@@ -1295,7 +1294,7 @@ real_to_integer (const REAL_VALUE_TYPE *r)\n       return i;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -1346,8 +1345,9 @@ real_to_integer2 (HOST_WIDE_INT *plow, HOST_WIDE_INT *phigh,\n \t  high = t.sig[SIGSZ-1];\n \t  low = t.sig[SIGSZ-2];\n \t}\n-      else if (HOST_BITS_PER_WIDE_INT == 2*HOST_BITS_PER_LONG)\n+      else \n \t{\n+\t  gcc_assert (HOST_BITS_PER_WIDE_INT == 2*HOST_BITS_PER_LONG);\n \t  high = t.sig[SIGSZ-1];\n \t  high = high << (HOST_BITS_PER_LONG - 1) << 1;\n \t  high |= t.sig[SIGSZ-2];\n@@ -1356,8 +1356,6 @@ real_to_integer2 (HOST_WIDE_INT *plow, HOST_WIDE_INT *phigh,\n \t  low = low << (HOST_BITS_PER_LONG - 1) << 1;\n \t  low |= t.sig[SIGSZ-4];\n \t}\n-      else\n-\tabort ();\n \n       if (r->sign)\n \t{\n@@ -1369,7 +1367,7 @@ real_to_integer2 (HOST_WIDE_INT *plow, HOST_WIDE_INT *phigh,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   *plow = low;\n@@ -1446,7 +1444,7 @@ real_to_decimal (char *str, const REAL_VALUE_TYPE *r_orig, size_t buf_size,\n       strcpy (str, (r.sign ? \"-NaN\" : \"+NaN\"));\n       return;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* Bound the number of digits printed by the size of the representation.  */\n@@ -1463,8 +1461,7 @@ real_to_decimal (char *str, const REAL_VALUE_TYPE *r_orig, size_t buf_size,\n \n   /* Bound the number of digits printed by the size of the output buffer.  */\n   max_digits = buf_size - 1 - 1 - 2 - max_digits - 1;\n-  if (max_digits > buf_size)\n-    abort ();\n+  gcc_assert (max_digits <= buf_size);\n   if (digits > max_digits)\n     digits = max_digits;\n \n@@ -1607,8 +1604,7 @@ real_to_decimal (char *str, const REAL_VALUE_TYPE *r_orig, size_t buf_size,\n       do_multiply (&r, &r, ten);\n       digit = rtd_divmod (&r, &pten);\n       dec_exp -= 1;\n-      if (digit == 0)\n-\tabort ();\n+      gcc_assert (digit != 0);\n     }\n \n   /* ... or overflow.  */\n@@ -1619,10 +1615,11 @@ real_to_decimal (char *str, const REAL_VALUE_TYPE *r_orig, size_t buf_size,\n \t*p++ = '0';\n       dec_exp += 1;\n     }\n-  else if (digit > 10)\n-    abort ();\n   else\n-    *p++ = digit + '0';\n+    {\n+      gcc_assert (digit <= 10);\n+      *p++ = digit + '0';\n+    }\n \n   /* Generate subsequent digits.  */\n   while (--digits > 0)\n@@ -1713,7 +1710,7 @@ real_to_hexadecimal (char *str, const REAL_VALUE_TYPE *r, size_t buf_size,\n       strcpy (str, (r->sign ? \"-NaN\" : \"+NaN\"));\n       return;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (digits == 0)\n@@ -1723,8 +1720,7 @@ real_to_hexadecimal (char *str, const REAL_VALUE_TYPE *r, size_t buf_size,\n \n   sprintf (exp_buf, \"p%+d\", exp);\n   max_digits = buf_size - strlen (exp_buf) - r->sign - 4 - 1;\n-  if (max_digits > buf_size)\n-    abort ();\n+  gcc_assert (max_digits <= buf_size);\n   if (digits > max_digits)\n     digits = max_digits;\n \n@@ -1982,17 +1978,16 @@ real_from_integer (REAL_VALUE_TYPE *r, enum machine_mode mode,\n \t  r->sig[SIGSZ-2] = low;\n \t  memset (r->sig, 0, sizeof(long)*(SIGSZ-2));\n \t}\n-      else if (HOST_BITS_PER_LONG*2 == HOST_BITS_PER_WIDE_INT)\n+      else\n \t{\n+\t  gcc_assert (HOST_BITS_PER_LONG*2 == HOST_BITS_PER_WIDE_INT);\n \t  r->sig[SIGSZ-1] = high >> (HOST_BITS_PER_LONG - 1) >> 1;\n \t  r->sig[SIGSZ-2] = high;\n \t  r->sig[SIGSZ-3] = low >> (HOST_BITS_PER_LONG - 1) >> 1;\n \t  r->sig[SIGSZ-4] = low;\n \t  if (SIGSZ > 4)\n \t    memset (r->sig, 0, sizeof(long)*(SIGSZ-4));\n \t}\n-      else\n-\tabort ();\n \n       normalize (r);\n     }\n@@ -2008,8 +2003,8 @@ ten_to_ptwo (int n)\n {\n   static REAL_VALUE_TYPE tens[EXP_BITS];\n \n-  if (n < 0 || n >= EXP_BITS)\n-    abort ();\n+  gcc_assert (n >= 0);\n+  gcc_assert (n < EXP_BITS);\n \n   if (tens[n].cl == rvc_zero)\n     {\n@@ -2040,8 +2035,8 @@ ten_to_mptwo (int n)\n {\n   static REAL_VALUE_TYPE tens[EXP_BITS];\n \n-  if (n < 0 || n >= EXP_BITS)\n-    abort ();\n+  gcc_assert (n >= 0);\n+  gcc_assert (n < EXP_BITS);\n \n   if (tens[n].cl == rvc_zero)\n     do_divide (&tens[n], real_digit (1), ten_to_ptwo (n));\n@@ -2056,8 +2051,8 @@ real_digit (int n)\n {\n   static REAL_VALUE_TYPE num[10];\n \n-  if (n < 0 || n > 9)\n-    abort ();\n+  gcc_assert (n >= 0);\n+  gcc_assert (n <= 9);\n \n   if (n > 0 && num[n].cl == rvc_zero)\n     real_from_integer (&num[n], VOIDmode, n, 0, 1);\n@@ -2111,8 +2106,7 @@ real_nan (REAL_VALUE_TYPE *r, const char *str, int quiet,\n   const struct real_format *fmt;\n \n   fmt = REAL_MODE_FORMAT (mode);\n-  if (fmt == NULL)\n-    abort ();\n+  gcc_assert (fmt);\n \n   if (*str == 0)\n     {\n@@ -2163,7 +2157,7 @@ real_nan (REAL_VALUE_TYPE *r, const char *str, int quiet,\n \t      add_significands (r, r, &u);\n \t      break;\n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \n \t  get_zero (&u, 0);\n@@ -2201,8 +2195,7 @@ real_maxval (REAL_VALUE_TYPE *r, int sign, enum machine_mode mode)\n   int np2;\n \n   fmt = REAL_MODE_FORMAT (mode);\n-  if (fmt == NULL)\n-    abort ();\n+  gcc_assert (fmt);\n \n   r->cl = rvc_normal;\n   r->sign = sign;\n@@ -2271,7 +2264,7 @@ round_for_format (const struct real_format *fmt, REAL_VALUE_TYPE *r)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* If we're not base2, normalize the exponent to a multiple of\n@@ -2375,8 +2368,7 @@ real_convert (REAL_VALUE_TYPE *r, enum machine_mode mode,\n   const struct real_format *fmt;\n \n   fmt = REAL_MODE_FORMAT (mode);\n-  if (fmt == NULL)\n-    abort ();\n+  gcc_assert (fmt);\n \n   *r = *a;\n   round_for_format (fmt, r);\n@@ -2437,8 +2429,7 @@ real_to_target (long *buf, const REAL_VALUE_TYPE *r, enum machine_mode mode)\n   const struct real_format *fmt;\n \n   fmt = REAL_MODE_FORMAT (mode);\n-  if (fmt == NULL)\n-    abort ();\n+  gcc_assert (fmt);\n \n   return real_to_target_fmt (buf, r, fmt);\n }\n@@ -2462,8 +2453,7 @@ real_from_target (REAL_VALUE_TYPE *r, const long *buf, enum machine_mode mode)\n   const struct real_format *fmt;\n \n   fmt = REAL_MODE_FORMAT (mode);\n-  if (fmt == NULL)\n-    abort ();\n+  gcc_assert (fmt);\n \n   (*fmt->decode) (fmt, r, buf);\n }\n@@ -2512,7 +2502,7 @@ real_hash (const REAL_VALUE_TYPE *r)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (sizeof(unsigned long) > sizeof(unsigned int))\n@@ -2596,7 +2586,7 @@ encode_ieee_single (const struct real_format *fmt, long *buf,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   buf[0] = image;\n@@ -2781,7 +2771,7 @@ encode_ieee_double (const struct real_format *fmt, long *buf,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (FLOAT_WORDS_BIG_ENDIAN)\n@@ -3004,8 +2994,7 @@ encode_ieee_extended (const struct real_format *fmt, long *buf,\n \telse\n \t  {\n \t    exp += 16383 - 1;\n-\t    if (exp < 0)\n-\t      abort ();\n+\t    gcc_assert (exp >= 0);\n \t  }\n \timage_hi |= exp;\n \n@@ -3024,7 +3013,7 @@ encode_ieee_extended (const struct real_format *fmt, long *buf,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   buf[0] = sig_lo, buf[1] = sig_hi, buf[2] = image_hi;\n@@ -3521,7 +3510,7 @@ encode_ieee_quad (const struct real_format *fmt, long *buf,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (FLOAT_WORDS_BIG_ENDIAN)\n@@ -3738,7 +3727,7 @@ encode_vax_f (const struct real_format *fmt ATTRIBUTE_UNUSED, long *buf,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   buf[0] = image;\n@@ -3809,7 +3798,7 @@ encode_vax_d (const struct real_format *fmt ATTRIBUTE_UNUSED, long *buf,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (FLOAT_WORDS_BIG_ENDIAN)\n@@ -3909,7 +3898,7 @@ encode_vax_g (const struct real_format *fmt ATTRIBUTE_UNUSED, long *buf,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (FLOAT_WORDS_BIG_ENDIAN)\n@@ -4060,7 +4049,7 @@ encode_i370_single (const struct real_format *fmt ATTRIBUTE_UNUSED,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   buf[0] = image;\n@@ -4129,7 +4118,7 @@ encode_i370_double (const struct real_format *fmt ATTRIBUTE_UNUSED,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (FLOAT_WORDS_BIG_ENDIAN)\n@@ -4272,7 +4261,7 @@ encode_c4x_single (const struct real_format *fmt ATTRIBUTE_UNUSED,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   image = ((exp & 0xff) << 24) | (sig & 0xffffff);\n@@ -4350,7 +4339,7 @@ encode_c4x_extended (const struct real_format *fmt ATTRIBUTE_UNUSED,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   exp = (exp & 0xff) << 24;"}, {"sha": "7d6ce19c943b2007b1d7cd51659114c5186c8baa", "filename": "gcc/recog.c", "status": "modified", "additions": 25, "deletions": 44, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -211,8 +211,7 @@ validate_change (rtx object, rtx *loc, rtx new, int in_group)\n   if (old == new || rtx_equal_p (old, new))\n     return 1;\n \n-  if (in_group == 0 && num_changes != 0)\n-    abort ();\n+  gcc_assert (in_group != 0 || num_changes == 0);\n \n   *loc = new;\n \n@@ -489,9 +488,9 @@ validate_replace_rtx_1 (rtx *loc, rtx from, rtx to, rtx object)\n \t      && GET_CODE (SET_SRC (XVECEXP (x, 0, j))) == ASM_OPERANDS)\n \t    {\n \t      /* Verify that operands are really shared.  */\n-\t      if (ASM_OPERANDS_INPUT_VEC (SET_SRC (XVECEXP (x, 0, 0))) !=\n-\t\t  ASM_OPERANDS_INPUT_VEC (SET_SRC (XVECEXP (x, 0, j))))\n-\t\tabort ();\n+\t      gcc_assert (ASM_OPERANDS_INPUT_VEC (SET_SRC (XVECEXP (x, 0, 0)))\n+\t\t\t  == ASM_OPERANDS_INPUT_VEC (SET_SRC (XVECEXP\n+\t\t\t\t\t\t\t      (x, 0, j))));\n \t      validate_replace_rtx_1 (&SET_DEST (XVECEXP (x, 0, j)),\n \t\t\t\t      from, to, object);\n \t    }\n@@ -1567,8 +1566,7 @@ asm_operand_ok (rtx op, const char *constraint)\n   int result = 0;\n \n   /* Use constrain_operands after reload.  */\n-  if (reload_completed)\n-    abort ();\n+  gcc_assert (!reload_completed);\n \n   while (*constraint)\n     {\n@@ -2008,8 +2006,7 @@ extract_insn (rtx insn)\n \t  /* This insn is an `asm' with operands.  */\n \n \t  /* expand_asm_operands makes sure there aren't too many operands.  */\n-\t  if (noperands > MAX_RECOG_OPERANDS)\n-\t    abort ();\n+\t  gcc_assert (noperands <= MAX_RECOG_OPERANDS);\n \n \t  /* Now get the operand values and constraints out of the insn.  */\n \t  decode_asm_operands (body, recog_data.operand,\n@@ -2057,8 +2054,7 @@ extract_insn (rtx insn)\n \t : recog_data.constraints[i][0] == '+' ? OP_INOUT\n \t : OP_IN);\n \n-  if (recog_data.n_alternatives > MAX_RECOG_ALTERNATIVES)\n-    abort ();\n+  gcc_assert (recog_data.n_alternatives <= MAX_RECOG_ALTERNATIVES);\n }\n \n /* After calling extract_insn, you can use this function to extract some\n@@ -2815,8 +2811,7 @@ static int peep2_current;\n rtx\n peep2_next_insn (int n)\n {\n-  if (n >= MAX_INSNS_PER_PEEP2 + 1)\n-    abort ();\n+  gcc_assert (n < MAX_INSNS_PER_PEEP2 + 1);\n \n   n += peep2_current;\n   if (n >= MAX_INSNS_PER_PEEP2 + 1)\n@@ -2833,15 +2828,13 @@ peep2_next_insn (int n)\n int\n peep2_regno_dead_p (int ofs, int regno)\n {\n-  if (ofs >= MAX_INSNS_PER_PEEP2 + 1)\n-    abort ();\n+  gcc_assert (ofs < MAX_INSNS_PER_PEEP2 + 1);\n \n   ofs += peep2_current;\n   if (ofs >= MAX_INSNS_PER_PEEP2 + 1)\n     ofs -= MAX_INSNS_PER_PEEP2 + 1;\n \n-  if (peep2_insn_data[ofs].insn == NULL_RTX)\n-    abort ();\n+  gcc_assert (peep2_insn_data[ofs].insn != NULL_RTX);\n \n   return ! REGNO_REG_SET_P (peep2_insn_data[ofs].live_before, regno);\n }\n@@ -2853,15 +2846,13 @@ peep2_reg_dead_p (int ofs, rtx reg)\n {\n   int regno, n;\n \n-  if (ofs >= MAX_INSNS_PER_PEEP2 + 1)\n-    abort ();\n+  gcc_assert (ofs < MAX_INSNS_PER_PEEP2 + 1);\n \n   ofs += peep2_current;\n   if (ofs >= MAX_INSNS_PER_PEEP2 + 1)\n     ofs -= MAX_INSNS_PER_PEEP2 + 1;\n \n-  if (peep2_insn_data[ofs].insn == NULL_RTX)\n-    abort ();\n+  gcc_assert (peep2_insn_data[ofs].insn != NULL_RTX);\n \n   regno = REGNO (reg);\n   n = hard_regno_nregs[regno][GET_MODE (reg)];\n@@ -2891,8 +2882,8 @@ peep2_find_free_register (int from, int to, const char *class_str,\n   HARD_REG_SET live;\n   int i;\n \n-  if (from >= MAX_INSNS_PER_PEEP2 + 1 || to >= MAX_INSNS_PER_PEEP2 + 1)\n-    abort ();\n+  gcc_assert (from < MAX_INSNS_PER_PEEP2 + 1);\n+  gcc_assert (to < MAX_INSNS_PER_PEEP2 + 1);\n \n   from += peep2_current;\n   if (from >= MAX_INSNS_PER_PEEP2 + 1)\n@@ -2901,8 +2892,7 @@ peep2_find_free_register (int from, int to, const char *class_str,\n   if (to >= MAX_INSNS_PER_PEEP2 + 1)\n     to -= MAX_INSNS_PER_PEEP2 + 1;\n \n-  if (peep2_insn_data[from].insn == NULL_RTX)\n-    abort ();\n+  gcc_assert (peep2_insn_data[from].insn != NULL_RTX);\n   REG_SET_TO_HARD_REG_SET (live, peep2_insn_data[from].live_before);\n \n   while (from != to)\n@@ -2911,8 +2901,7 @@ peep2_find_free_register (int from, int to, const char *class_str,\n \n       if (++from >= MAX_INSNS_PER_PEEP2 + 1)\n \tfrom = 0;\n-      if (peep2_insn_data[from].insn == NULL_RTX)\n-\tabort ();\n+      gcc_assert (peep2_insn_data[from].insn != NULL_RTX);\n       REG_SET_TO_HARD_REG_SET (this_live, peep2_insn_data[from].live_before);\n       IOR_HARD_REG_SET (live, this_live);\n     }\n@@ -3076,8 +3065,7 @@ peephole2_optimize (FILE *dump_file ATTRIBUTE_UNUSED)\n \t\t\t  new_insn = NEXT_INSN (new_insn);\n \t\t\t}\n \n-\t\t      if (new_insn == NULL_RTX)\n-\t\t\tabort ();\n+\t\t      gcc_assert (new_insn != NULL_RTX);\n \n \t\t      CALL_INSN_FUNCTION_USAGE (new_insn)\n \t\t\t= CALL_INSN_FUNCTION_USAGE (old_insn);\n@@ -3106,8 +3094,7 @@ peephole2_optimize (FILE *dump_file ATTRIBUTE_UNUSED)\n \t\t\t  if (j >= MAX_INSNS_PER_PEEP2 + 1)\n \t\t\t    j -= MAX_INSNS_PER_PEEP2 + 1;\n \t\t\t  old_insn = peep2_insn_data[j].insn;\n-\t\t\t  if (CALL_P (old_insn))\n-\t\t\t    abort ();\n+\t\t\t  gcc_assert (!CALL_P (old_insn));\n \t\t\t}\n \t\t      break;\n \t\t    }\n@@ -3277,8 +3264,7 @@ store_data_bypass_p (rtx out_insn, rtx in_insn)\n   rtx out_set, in_set;\n \n   in_set = single_set (in_insn);\n-  if (! in_set)\n-    abort ();\n+  gcc_assert (in_set);\n \n   if (!MEM_P (SET_DEST (in_set)))\n     return false;\n@@ -3295,8 +3281,7 @@ store_data_bypass_p (rtx out_insn, rtx in_insn)\n       int i;\n \n       out_pat = PATTERN (out_insn);\n-      if (GET_CODE (out_pat) != PARALLEL)\n-\tabort ();\n+      gcc_assert (GET_CODE (out_pat) == PARALLEL);\n \n       for (i = 0; i < XVECLEN (out_pat, 0); i++)\n \t{\n@@ -3305,8 +3290,7 @@ store_data_bypass_p (rtx out_insn, rtx in_insn)\n \t  if (GET_CODE (exp) == CLOBBER)\n \t    continue;\n \n-\t  if (GET_CODE (exp) != SET)\n-\t    abort ();\n+\t  gcc_assert (GET_CODE (exp) == SET);\n \n \t  if (reg_mentioned_p (SET_DEST (exp), SET_DEST (in_set)))\n \t    return false;\n@@ -3329,9 +3313,8 @@ if_test_bypass_p (rtx out_insn, rtx in_insn)\n   in_set = single_set (in_insn);\n   if (! in_set)\n     {\n-      if (JUMP_P (in_insn) || CALL_P (in_insn))\n-\treturn false;\n-      abort ();\n+      gcc_assert (JUMP_P (in_insn) || CALL_P (in_insn));\n+      return false;\n     }\n \n   if (GET_CODE (SET_SRC (in_set)) != IF_THEN_ELSE)\n@@ -3351,8 +3334,7 @@ if_test_bypass_p (rtx out_insn, rtx in_insn)\n       int i;\n \n       out_pat = PATTERN (out_insn);\n-      if (GET_CODE (out_pat) != PARALLEL)\n-\tabort ();\n+      gcc_assert (GET_CODE (out_pat) == PARALLEL);\n \n       for (i = 0; i < XVECLEN (out_pat, 0); i++)\n \t{\n@@ -3361,8 +3343,7 @@ if_test_bypass_p (rtx out_insn, rtx in_insn)\n \t  if (GET_CODE (exp) == CLOBBER)\n \t    continue;\n \n-\t  if (GET_CODE (exp) != SET)\n-\t    abort ();\n+\t  gcc_assert (GET_CODE (exp) == SET);\n \n \t  if (reg_mentioned_p (SET_DEST (out_set), XEXP (in_set, 1))\n \t      || reg_mentioned_p (SET_DEST (out_set), XEXP (in_set, 2)))"}, {"sha": "f8fca7322cd0131b8b996f125c9fff68f8da572b", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 79, "deletions": 117, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -506,8 +506,7 @@ record_label_references (rtx insn, rtx pat)\n       rtx label = XEXP (pat, 0);\n       rtx ref;\n \n-      if (!LABEL_P (label))\n-\tabort ();\n+      gcc_assert (LABEL_P (label));\n \n       /* If this is an undefined label, LABEL_REFS (label) contains\n          garbage.  */\n@@ -782,21 +781,21 @@ check_asm_stack_operands (rtx insn)\n static int\n get_asm_operand_n_inputs (rtx body)\n {\n-  if (GET_CODE (body) == SET && GET_CODE (SET_SRC (body)) == ASM_OPERANDS)\n-    return ASM_OPERANDS_INPUT_LENGTH (SET_SRC (body));\n-\n-  else if (GET_CODE (body) == ASM_OPERANDS)\n-    return ASM_OPERANDS_INPUT_LENGTH (body);\n-\n-  else if (GET_CODE (body) == PARALLEL\n-\t   && GET_CODE (XVECEXP (body, 0, 0)) == SET)\n-    return ASM_OPERANDS_INPUT_LENGTH (SET_SRC (XVECEXP (body, 0, 0)));\n-\n-  else if (GET_CODE (body) == PARALLEL\n-\t   && GET_CODE (XVECEXP (body, 0, 0)) == ASM_OPERANDS)\n-    return ASM_OPERANDS_INPUT_LENGTH (XVECEXP (body, 0, 0));\n-\n-  abort ();\n+  switch (GET_CODE (body))\n+    {\n+    case SET:\n+      gcc_assert (GET_CODE (SET_SRC (body)) == ASM_OPERANDS);\n+      return ASM_OPERANDS_INPUT_LENGTH (SET_SRC (body));\n+      \n+    case ASM_OPERANDS:\n+      return ASM_OPERANDS_INPUT_LENGTH (body);\n+      \n+    case PARALLEL:\n+      return get_asm_operand_n_inputs (XVECEXP (body, 0, 0));\n+      \n+    default:\n+      gcc_unreachable ();\n+    }\n }\n \n /* If current function returns its result in an fp stack register,\n@@ -838,16 +837,12 @@ stack_result (tree decl)\n static void\n replace_reg (rtx *reg, int regno)\n {\n-  if (regno < FIRST_STACK_REG || regno > LAST_STACK_REG\n-      || ! STACK_REG_P (*reg))\n-    abort ();\n+  gcc_assert (regno >= FIRST_STACK_REG);\n+  gcc_assert (regno <= LAST_STACK_REG);\n+  gcc_assert (STACK_REG_P (*reg));\n \n-  switch (GET_MODE_CLASS (GET_MODE (*reg)))\n-    {\n-    default: abort ();\n-    case MODE_FLOAT:\n-    case MODE_COMPLEX_FLOAT:;\n-    }\n+  gcc_assert (GET_MODE_CLASS (GET_MODE (*reg)) == MODE_FLOAT\n+\t      || GET_MODE_CLASS (GET_MODE (*reg)) == MODE_COMPLEX_FLOAT);\n \n   *reg = FP_MODE_REG (regno, GET_MODE (*reg));\n }\n@@ -871,7 +866,7 @@ remove_regno_note (rtx insn, enum reg_note note, unsigned int regno)\n     else\n       note_link = &XEXP (this, 1);\n \n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Find the hard register number of virtual register REG in REGSTACK.\n@@ -883,8 +878,7 @@ get_hard_regnum (stack regstack, rtx reg)\n {\n   int i;\n \n-  if (! STACK_REG_P (reg))\n-    abort ();\n+  gcc_assert (STACK_REG_P (reg));\n \n   for (i = regstack->top; i >= 0; i--)\n     if (regstack->reg[i] == REGNO (reg))\n@@ -918,15 +912,13 @@ emit_pop_insn (rtx insn, stack regstack, rtx reg, enum emit_where where)\n \tpop_insn = emit_pop_insn (insn, regstack, reg1, where);\n       if (get_hard_regnum (regstack, reg2) >= 0)\n \tpop_insn = emit_pop_insn (insn, regstack, reg2, where);\n-      if (!pop_insn)\n-\tabort ();\n+      gcc_assert (pop_insn);\n       return pop_insn;\n     }\n \n   hard_regno = get_hard_regnum (regstack, reg);\n \n-  if (hard_regno < FIRST_STACK_REG)\n-    abort ();\n+  gcc_assert (hard_regno >= FIRST_STACK_REG);\n \n   pop_rtx = gen_rtx_SET (VOIDmode, FP_MODE_REG (hard_regno, DFmode),\n \t\t\t FP_MODE_REG (FIRST_STACK_REG, DFmode));\n@@ -966,8 +958,7 @@ emit_swap_insn (rtx insn, stack regstack, rtx reg)\n \n   hard_regno = get_hard_regnum (regstack, reg);\n \n-  if (hard_regno < FIRST_STACK_REG)\n-    abort ();\n+  gcc_assert (hard_regno >= FIRST_STACK_REG);\n   if (hard_regno == FIRST_STACK_REG)\n     return;\n \n@@ -1055,8 +1046,7 @@ swap_to_top (rtx insn, stack regstack, rtx src1, rtx src2)\n \n   /* Place operand 1 at the top of stack.  */\n   regno = get_hard_regnum (&temp_stack, src1);\n-  if (regno < 0)\n-    abort ();\n+  gcc_assert (regno >= 0);\n   if (regno != FIRST_STACK_REG)\n     {\n       k = temp_stack.top - (regno - FIRST_STACK_REG);\n@@ -1069,8 +1059,7 @@ swap_to_top (rtx insn, stack regstack, rtx src1, rtx src2)\n \n   /* Place operand 2 next on the stack.  */\n   regno = get_hard_regnum (&temp_stack, src2);\n-  if (regno < 0)\n-    abort ();\n+  gcc_assert (regno >= 0);\n   if (regno != FIRST_STACK_REG + 1)\n     {\n       k = temp_stack.top - (regno - FIRST_STACK_REG);\n@@ -1110,16 +1099,15 @@ move_for_stack_reg (rtx insn, stack regstack, rtx pat)\n \t  int i;\n \n \t  /* If this is a no-op move, there must not be a REG_DEAD note.  */\n-\t  if (REGNO (src) == REGNO (dest))\n-\t    abort ();\n+\t  gcc_assert (REGNO (src) != REGNO (dest));\n \n \t  for (i = regstack->top; i >= 0; i--)\n \t    if (regstack->reg[i] == REGNO (src))\n \t      break;\n \n \t  /* The source must be live, and the dest must be dead.  */\n-\t  if (i < 0 || get_hard_regnum (regstack, dest) >= FIRST_STACK_REG)\n-\t    abort ();\n+\t  gcc_assert (i >= 0);\n+\t  gcc_assert (get_hard_regnum (regstack, dest) < FIRST_STACK_REG);\n \n \t  /* It is possible that the dest is unused after this insn.\n \t     If so, just pop the src.  */\n@@ -1156,8 +1144,7 @@ move_for_stack_reg (rtx insn, stack regstack, rtx pat)\n \t}\n \n       /* The destination ought to be dead.  */\n-      if (get_hard_regnum (regstack, dest) >= FIRST_STACK_REG)\n-\tabort ();\n+      gcc_assert (get_hard_regnum (regstack, dest) < FIRST_STACK_REG);\n \n       replace_reg (psrc, get_hard_regnum (regstack, src));\n \n@@ -1201,26 +1188,24 @@ move_for_stack_reg (rtx insn, stack regstack, rtx pat)\n \n       replace_reg (psrc, FIRST_STACK_REG);\n     }\n-  else if (STACK_REG_P (dest))\n+  else\n     {\n+      gcc_assert (STACK_REG_P (dest));\n+\n       /* Load from MEM, or possibly integer REG or constant, into the\n \t stack regs.  The actual target is always the top of the\n \t stack. The stack mapping is changed to reflect that DEST is\n \t now at top of stack.  */\n \n       /* The destination ought to be dead.  */\n-      if (get_hard_regnum (regstack, dest) >= FIRST_STACK_REG)\n-\tabort ();\n+      gcc_assert (get_hard_regnum (regstack, dest) < FIRST_STACK_REG);\n \n-      if (regstack->top >= REG_STACK_SIZE)\n-\tabort ();\n+      gcc_assert (regstack->top < REG_STACK_SIZE);\n \n       regstack->reg[++regstack->top] = REGNO (dest);\n       SET_HARD_REG_BIT (regstack->reg_set, REGNO (dest));\n       replace_reg (pdest, FIRST_STACK_REG);\n     }\n-  else\n-    abort ();\n \n   return control_flow_insn_deleted;\n }\n@@ -1456,8 +1441,8 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t  return control_flow_insn_deleted;\n \t}\n       /* ??? Uninitialized USE should not happen.  */\n-      else if (get_hard_regnum (regstack, *src) == -1)\n-\tabort ();\n+      else\n+\tgcc_assert (get_hard_regnum (regstack, *src) != -1);\n       break;\n \n     case CLOBBER:\n@@ -1483,8 +1468,7 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t\telse\n \t\t  {\n \t\t    note = find_reg_note (insn, REG_UNUSED, *dest);\n-\t\t    if (!note)\n-\t\t      abort ();\n+\t\t    gcc_assert (note);\n \t\t  }\n \t\tremove_note (insn, note);\n \t\treplace_reg (dest, FIRST_STACK_REG + 1);\n@@ -1560,8 +1544,7 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \n \t  case REG:\n \t    /* This is a `tstM2' case.  */\n-\t    if (*dest != cc0_rtx)\n-\t      abort ();\n+\t    gcc_assert (*dest == cc0_rtx);\n \t    src1 = src;\n \n \t    /* Fall through.  */\n@@ -1636,8 +1619,8 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \n \t\tsrc1_hard_regnum = get_hard_regnum (regstack, *src1);\n \t\tsrc2_hard_regnum = get_hard_regnum (regstack, *src2);\n-\t\tif (src1_hard_regnum == -1 || src2_hard_regnum == -1)\n-\t\t  abort ();\n+\t\tgcc_assert (src1_hard_regnum != -1);\n+\t\tgcc_assert (src2_hard_regnum != -1);\n \n \t\tif (src1_hard_regnum != FIRST_STACK_REG\n \t\t    && src2_hard_regnum != FIRST_STACK_REG)\n@@ -1743,8 +1726,7 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t\t/* Input should never die, it is\n \t\t   replaced with output.  */\n \t\tsrc1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n-\t\tif (src1_note)\n-\t\t  abort();\n+\t\tgcc_assert (!src1_note);\n \n \t\tif (STACK_REG_P (*dest))\n \t\t  replace_reg (dest, FIRST_STACK_REG);\n@@ -1800,8 +1782,8 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \n \t\t/* Inputs should never die, they are\n \t\t   replaced with outputs.  */\n-\t\tif ((src1_note) || (src2_note))\n-\t\t  abort();\n+\t\tgcc_assert (!src1_note);\n+\t\tgcc_assert (!src2_note);\n \n \t\tswap_to_top (insn, regstack, *src1, *src2);\n \n@@ -1831,8 +1813,8 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \n \t\t/* Inputs should never die, they are\n \t\t   replaced with outputs.  */\n-\t\tif ((src1_note) || (src2_note))\n-\t\t  abort();\n+\t\tgcc_assert (!src1_note);\n+\t\tgcc_assert (!src2_note);\n \n \t\tswap_to_top (insn, regstack, *src1, *src2);\n \n@@ -1861,8 +1843,7 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t\t/* Input should never die, it is\n \t\t   replaced with output.  */\n \t\tsrc1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n-\t\tif (src1_note)\n-\t\t  abort();\n+\t\tgcc_assert (!src1_note);\n \n \t\t/* Push the result back onto stack. Empty stack slot\n \t\t   will be filled in second part of insn.  */\n@@ -1888,8 +1869,7 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t\t/* Input should never die, it is\n \t\t   replaced with output.  */\n \t\tsrc1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n-\t\tif (src1_note)\n-\t\t  abort();\n+\t\tgcc_assert (!src1_note);\n \n \t\t/* Push the result back onto stack. Fill empty slot from\n \t\t   first part of insn and fix top of stack pointer.  */\n@@ -1909,9 +1889,8 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t\t   The combination matches the PPRO fcomi instruction.  */\n \n \t\tpat_src = XVECEXP (pat_src, 0, 0);\n-\t\tif (GET_CODE (pat_src) != UNSPEC\n-\t\t    || XINT (pat_src, 1) != UNSPEC_FNSTSW)\n-\t\t  abort ();\n+\t\tgcc_assert (GET_CODE (pat_src) == UNSPEC);\n+\t\tgcc_assert (XINT (pat_src, 1) == UNSPEC_FNSTSW);\n \t\t/* Fall through.  */\n \n \t      case UNSPEC_FNSTSW:\n@@ -1920,14 +1899,13 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t\t   up before now.  */\n \n \t\tpat_src = XVECEXP (pat_src, 0, 0);\n-\t\tif (GET_CODE (pat_src) != COMPARE)\n-\t\t  abort ();\n+\t\tgcc_assert (GET_CODE (pat_src) == COMPARE);\n \n \t\tcompare_for_stack_reg (insn, regstack, pat_src);\n \t\tbreak;\n \n \t      default:\n-\t\tabort ();\n+\t\tgcc_unreachable ();\n \t      }\n \t    break;\n \n@@ -1994,17 +1972,13 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t\t    int regno = REGNO (XEXP (src_note[i], 0));\n \n \t\t    /* If the register that dies is not at the top of\n-\t\t       stack, then move the top of stack to the dead reg */\n-\t\t    if (regno != regstack->reg[regstack->top])\n-\t\t      {\n-\t\t\tremove_regno_note (insn, REG_DEAD, regno);\n-\t\t\temit_pop_insn (insn, regstack, XEXP (src_note[i], 0),\n-\t\t\t\t       EMIT_AFTER);\n-\t\t      }\n-\t\t    else\n-\t\t      /* Top of stack never dies, as it is the\n-\t\t\t destination.  */\n-\t\t      abort ();\n+\t\t       stack, then move the top of stack to the dead reg.\n+\t\t       Top of stack should never die, as it is the\n+\t\t       destination.  */\n+\t\t    gcc_assert (regno != regstack->reg[regstack->top]);\n+\t\t    remove_regno_note (insn, REG_DEAD, regno);\n+\t\t    emit_pop_insn (insn, regstack, XEXP (src_note[i], 0),\n+\t\t\t\t    EMIT_AFTER);\n \t\t  }\n \t    }\n \n@@ -2017,7 +1991,7 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t    break;\n \n \t  default:\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t  }\n \tbreak;\n       }\n@@ -2074,8 +2048,7 @@ subst_asm_stack_regs (rtx insn, stack regstack)\n   n_inputs = get_asm_operand_n_inputs (body);\n   n_outputs = recog_data.n_operands - n_inputs;\n \n-  if (alt < 0)\n-    abort ();\n+  gcc_assert (alt >= 0);\n \n   /* Strip SUBREGs here to make the following code simpler.  */\n   for (i = 0; i < recog_data.n_operands; i++)\n@@ -2168,8 +2141,7 @@ subst_asm_stack_regs (rtx insn, stack regstack)\n \n \tint regno = get_hard_regnum (&temp_stack, recog_data.operand[i]);\n \n-\tif (regno < 0)\n-\t  abort ();\n+\tgcc_assert (regno >= 0);\n \n \tif ((unsigned int) regno != REGNO (recog_data.operand[i]))\n \t  {\n@@ -2202,8 +2174,7 @@ subst_asm_stack_regs (rtx insn, stack regstack)\n       {\n \tint regnum = get_hard_regnum (regstack, recog_data.operand[i]);\n \n-\tif (regnum < 0)\n-\t  abort ();\n+\tgcc_assert (regnum >= 0);\n \n \treplace_reg (recog_data.operand_loc[i], regnum);\n       }\n@@ -2213,8 +2184,7 @@ subst_asm_stack_regs (rtx insn, stack regstack)\n       {\n \tint regnum = get_hard_regnum (regstack, note_reg[i]);\n \n-\tif (regnum < 0)\n-\t  abort ();\n+\tgcc_assert (regnum >= 0);\n \n \treplace_reg (note_loc[i], regnum);\n       }\n@@ -2228,7 +2198,7 @@ subst_asm_stack_regs (rtx insn, stack regstack)\n       if (regnum >= 0)\n \t{\n \t  /* Sigh - clobbers always have QImode.  But replace_reg knows\n-\t     that these regs can't be MODE_INT and will abort.  Just put\n+\t     that these regs can't be MODE_INT and will assert.  Just put\n \t     the right reg there without calling replace_reg.  */\n \n \t  *clobber_loc[i] = FP_MODE_REG (regnum, DFmode);\n@@ -2469,10 +2439,9 @@ change_stack (rtx insn, stack old, stack new, enum emit_where where)\n \t not their depth or liveliness.  */\n \n       GO_IF_HARD_REG_EQUAL (old->reg_set, new->reg_set, win);\n-      abort ();\n+      gcc_unreachable ();\n     win:\n-      if (old->top != new->top)\n-\tabort ();\n+      gcc_assert (old->top == new->top);\n \n       /* If the stack is not empty (new->top != -1), loop here emitting\n \t swaps until the stack is correct.\n@@ -2495,8 +2464,7 @@ change_stack (rtx insn, stack old, stack new, enum emit_where where)\n \t\t  if (new->reg[reg] == old->reg[old->top])\n \t\t    break;\n \n-\t\tif (reg == -1)\n-\t\t  abort ();\n+\t\tgcc_assert (reg != -1);\n \n \t\temit_swap_insn (insn, old,\n \t\t\t\tFP_MODE_REG (old->reg[reg], DFmode));\n@@ -2518,8 +2486,7 @@ change_stack (rtx insn, stack old, stack new, enum emit_where where)\n       /* At this point there must be no differences.  */\n \n       for (reg = old->top; reg >= 0; reg--)\n-\tif (old->reg[reg] != new->reg[reg])\n-\t  abort ();\n+\tgcc_assert (old->reg[reg] == new->reg[reg]);\n     }\n \n   if (update_end)\n@@ -2731,7 +2698,7 @@ compensate_edge (edge e, FILE *file)\n \n       CLEAR_HARD_REG_SET (tmp);\n       GO_IF_HARD_REG_EQUAL (target_stack->reg_set, tmp, eh1);\n-      abort ();\n+      gcc_unreachable ();\n     eh1:\n \n       /* We are sure that there is st(0) live, otherwise we won't compensate.\n@@ -2740,7 +2707,7 @@ compensate_edge (edge e, FILE *file)\n       if (TEST_HARD_REG_BIT (regstack.reg_set, FIRST_STACK_REG + 1))\n         SET_HARD_REG_BIT (tmp, FIRST_STACK_REG + 1);\n       GO_IF_HARD_REG_EQUAL (regstack.reg_set, tmp, eh2);\n-      abort ();\n+      gcc_unreachable ();\n     eh2:\n \n       target_stack->top = -1;\n@@ -2766,8 +2733,7 @@ compensate_edge (edge e, FILE *file)\n       /* We don't support abnormal edges.  Global takes care to\n          avoid any live register across them, so we should never\n          have to insert instructions on such edges.  */\n-      if (e->flags & EDGE_ABNORMAL)\n-\tabort ();\n+      gcc_assert (!(e->flags & EDGE_ABNORMAL));\n \n       current_block = NULL;\n       start_sequence ();\n@@ -2870,8 +2836,7 @@ convert_regs_1 (FILE *file, basic_block block)\n       next = NEXT_INSN (insn);\n \n       /* Ensure we have not missed a block boundary.  */\n-      if (next == NULL)\n-\tabort ();\n+      gcc_assert (next);\n       if (insn == BB_END (block))\n \tnext = NULL;\n \n@@ -2953,8 +2918,7 @@ convert_regs_1 (FILE *file, basic_block block)\n      asms, we zapped the instruction itself, but that didn't produce the\n      same pattern of register kills as before.  */\n   GO_IF_HARD_REG_EQUAL (regstack.reg_set, bi->out_reg_set, win);\n-  if (!any_malformed_asm)\n-    abort ();\n+  gcc_assert (any_malformed_asm);\n  win:\n   bi->stack_out = regstack;\n \n@@ -2964,9 +2928,8 @@ convert_regs_1 (FILE *file, basic_block block)\n       if (e->flags & EDGE_DFS_BACK\n \t  || (e->dest == EXIT_BLOCK_PTR))\n \t{\n-\t  if (!BLOCK_INFO (e->dest)->done\n-\t      && e->dest != block)\n-\t    abort ();\n+\t  gcc_assert (BLOCK_INFO (e->dest)->done\n+\t\t      || e->dest == block);\n \t  inserted |= compensate_edge (e, file);\n \t}\n     }\n@@ -2975,8 +2938,7 @@ convert_regs_1 (FILE *file, basic_block block)\n       if (e != beste && !(e->flags & EDGE_DFS_BACK)\n \t  && e->src != ENTRY_BLOCK_PTR)\n \t{\n-\t  if (!BLOCK_INFO (e->src)->done)\n-\t    abort ();\n+\t  gcc_assert (BLOCK_INFO (e->src)->done);\n \t  inserted |= compensate_edge (e, file);\n \t}\n     }"}, {"sha": "a73d8865bac3ba11f0f435918de97c7392513d3c", "filename": "gcc/regclass.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -284,9 +284,8 @@ init_reg_sets (void)\n \n   /* Sanity check: make sure the target macros FIXED_REGISTERS and\n      CALL_USED_REGISTERS had the right number of initializers.  */\n-  if (sizeof fixed_regs != sizeof initial_fixed_regs\n-      || sizeof call_used_regs != sizeof initial_call_used_regs)\n-    abort();\n+  gcc_assert (sizeof fixed_regs == sizeof initial_fixed_regs);\n+  gcc_assert (sizeof call_used_regs == sizeof initial_call_used_regs);\n \n   memcpy (fixed_regs, initial_fixed_regs, sizeof fixed_regs);\n   memcpy (call_used_regs, initial_call_used_regs, sizeof call_used_regs);\n@@ -427,15 +426,11 @@ init_reg_sets_1 (void)\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n-#ifdef ENABLE_CHECKING\n       /* call_used_regs must include fixed_regs.  */\n-      if (fixed_regs[i] && !call_used_regs[i])\n-\tabort ();\n+      gcc_assert (!fixed_regs[i] || call_used_regs[i]);\n #ifdef CALL_REALLY_USED_REGISTERS\n       /* call_used_regs must include call_really_used_regs.  */\n-      if (call_really_used_regs[i] && !call_used_regs[i])\n-\tabort ();\n-#endif\n+      gcc_assert (!call_really_used_regs[i] || call_used_regs[i]);\n #endif\n \n       if (fixed_regs[i])\n@@ -656,7 +651,7 @@ memory_move_secondary_cost (enum machine_mode mode, enum reg_class class, int in\n        what it is, so MEMORY_MOVE_COST really ought not to be calling\n        here in that case.\n \n-       I'm tempted to put in an abort here, but returning this will\n+       I'm tempted to put in an assert here, but returning this will\n        probably only give poor estimates, which is what we would've\n        had before this code anyways.  */\n     return partial_cost;"}, {"sha": "c2e773d875fa16a1cc670a9da33676f5b5e7561b", "filename": "gcc/regrename.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -105,8 +105,7 @@ note_sets (rtx x, rtx set ATTRIBUTE_UNUSED, void *data)\n   nregs = hard_regno_nregs[regno][GET_MODE (x)];\n \n   /* There must not be pseudos at this point.  */\n-  if (regno + nregs > FIRST_PSEUDO_REGISTER)\n-    abort ();\n+  gcc_assert (regno + nregs <= FIRST_PSEUDO_REGISTER);\n \n   while (nregs-- > 0)\n     SET_HARD_REG_BIT (*pset, regno + nregs);\n@@ -127,8 +126,7 @@ clear_dead_regs (HARD_REG_SET *pset, enum machine_mode kind, rtx notes)\n \tint nregs = hard_regno_nregs[regno][GET_MODE (reg)];\n \n \t/* There must not be pseudos at this point.  */\n-\tif (regno + nregs > FIRST_PSEUDO_REGISTER)\n-\t  abort ();\n+\tgcc_assert (regno + nregs <= FIRST_PSEUDO_REGISTER);\n \n \twhile (nregs-- > 0)\n \t  CLEAR_HARD_REG_BIT (*pset, regno + nregs);\n@@ -442,8 +440,7 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl,\n \n \t  if (action == mark_read)\n \t    {\n-\t      if (! exact_match)\n-\t\tabort ();\n+\t      gcc_assert (exact_match);\n \n \t      /* ??? Class NO_REGS can happen if the md file makes use of\n \t\t EXTRA_CONSTRAINTS to match registers.  Which is arguably\n@@ -692,7 +689,7 @@ scan_rtx (rtx insn, rtx *loc, enum reg_class cl,\n     case POST_MODIFY:\n     case PRE_MODIFY:\n       /* Should only happen inside MEM.  */\n-      abort ();\n+      gcc_unreachable ();\n \n     case CLOBBER:\n       scan_rtx (insn, &SET_DEST (x), cl, action, OP_OUT, 1);"}, {"sha": "46b85f7f01fd4ef7bd1d48e3969eede9d7415a9d", "filename": "gcc/reload.c", "status": "modified", "additions": 202, "deletions": 222, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -388,17 +388,15 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \t       : REG_CLASS_FROM_CONSTRAINT ((unsigned char) insn_letter,\n \t\t\t\t\t    insn_constraint));\n \n-          if (insn_class == NO_REGS)\n-\t    abort ();\n-\t  if (in_p\n-\t      && insn_data[(int) icode].operand[!in_p].constraint[0] != '=')\n-\t    abort ();\n+          gcc_assert (insn_class != NO_REGS);\n+\t  gcc_assert (!in_p\n+\t\t      || insn_data[(int) icode].operand[!in_p].constraint[0]\n+\t\t\t == '=');\n \t}\n \n       /* The scratch register's constraint must start with \"=&\".  */\n-      if (insn_data[(int) icode].operand[2].constraint[0] != '='\n-\t  || insn_data[(int) icode].operand[2].constraint[1] != '&')\n-\tabort ();\n+      gcc_assert (insn_data[(int) icode].operand[2].constraint[0] == '='\n+\t\t  && insn_data[(int) icode].operand[2].constraint[1] == '&');\n \n       if (reg_class_subset_p (reload_class, insn_class))\n \tmode = insn_data[(int) icode].operand[2].mode;\n@@ -431,9 +429,8 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n      Allow this when a reload_in/out pattern is being used.  I.e. assume\n      that the generated code handles this case.  */\n \n-  if (in_p && class == reload_class && icode == CODE_FOR_nothing\n-      && t_icode == CODE_FOR_nothing)\n-    abort ();\n+  gcc_assert (!in_p || class != reload_class || icode != CODE_FOR_nothing\n+\t      || t_icode != CODE_FOR_nothing);\n \n   /* If we need a tertiary reload, see if we have one we can reuse or else\n      make a new one.  */\n@@ -706,8 +703,7 @@ find_valid_class (enum machine_mode m1 ATTRIBUTE_UNUSED, int n,\n \t}\n     }\n \n-  if (best_size == 0)\n-    abort ();\n+  gcc_assert (best_size != 0);\n \n   return best_class;\n }\n@@ -1071,8 +1067,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n       if (MEM_P (in))\n \t/* This is supposed to happen only for paradoxical subregs made by\n \t   combine.c.  (SUBREG (MEM)) isn't supposed to occur other ways.  */\n-\tif (GET_MODE_SIZE (GET_MODE (in)) > GET_MODE_SIZE (inmode))\n-\t  abort ();\n+\tgcc_assert (GET_MODE_SIZE (GET_MODE (in)) <= GET_MODE_SIZE (inmode));\n #endif\n       inmode = GET_MODE (in);\n     }\n@@ -1166,9 +1161,9 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n       outloc = &SUBREG_REG (out);\n       out = *outloc;\n #if ! defined (LOAD_EXTEND_OP) && ! defined (WORD_REGISTER_OPERATIONS)\n-      if (MEM_P (out)\n-\t  && GET_MODE_SIZE (GET_MODE (out)) > GET_MODE_SIZE (outmode))\n-\tabort ();\n+      gcc_assert (!MEM_P (out)\n+\t\t  || GET_MODE_SIZE (GET_MODE (out))\n+\t\t     <= GET_MODE_SIZE (outmode));\n #endif\n       outmode = GET_MODE (out);\n     }\n@@ -1289,9 +1284,8 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n   /* Optional output reloads are always OK even if we have no register class,\n      since the function of these reloads is only to have spill_reg_store etc.\n      set, so that the storing insn can be deleted later.  */\n-  if (class == NO_REGS\n-      && (optional == 0 || type != RELOAD_FOR_OUTPUT))\n-    abort ();\n+  gcc_assert (class != NO_REGS\n+\t      || (optional != 0 && type == RELOAD_FOR_OUTPUT));\n \n   i = find_reusable_reload (&in, out, class, type, opnum, dont_share);\n \n@@ -1445,8 +1439,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n       /* If we did not find a nonzero amount-to-increment-by,\n \t that contradicts the belief that IN is being incremented\n \t in an address in this insn.  */\n-      if (rld[i].inc == 0)\n-\tabort ();\n+      gcc_assert (rld[i].inc != 0);\n     }\n #endif\n \n@@ -2246,7 +2239,7 @@ operands_match_p (rtx x, rtx y)\n \t     contain anything but integers and other rtx's,\n \t     except for within LABEL_REFs and SYMBOL_REFs.  */\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   return 1 + success_2;\n@@ -2268,98 +2261,99 @@ decompose (rtx x)\n \n   memset (&val, 0, sizeof (val));\n \n-  if (MEM_P (x))\n-    {\n-      rtx base = NULL_RTX, offset = 0;\n-      rtx addr = XEXP (x, 0);\n-\n-      if (GET_CODE (addr) == PRE_DEC || GET_CODE (addr) == PRE_INC\n-\t  || GET_CODE (addr) == POST_DEC || GET_CODE (addr) == POST_INC)\n-\t{\n-\t  val.base = XEXP (addr, 0);\n-\t  val.start = -GET_MODE_SIZE (GET_MODE (x));\n-\t  val.end = GET_MODE_SIZE (GET_MODE (x));\n-\t  val.safe = REGNO (val.base) == STACK_POINTER_REGNUM;\n-\t  return val;\n-\t}\n-\n-      if (GET_CODE (addr) == PRE_MODIFY || GET_CODE (addr) == POST_MODIFY)\n-\t{\n-\t  if (GET_CODE (XEXP (addr, 1)) == PLUS\n-\t      && XEXP (addr, 0) == XEXP (XEXP (addr, 1), 0)\n-\t      && CONSTANT_P (XEXP (XEXP (addr, 1), 1)))\n-\t    {\n-\t      val.base  = XEXP (addr, 0);\n-\t      val.start = -INTVAL (XEXP (XEXP (addr, 1), 1));\n-\t      val.end   = INTVAL (XEXP (XEXP (addr, 1), 1));\n-\t      val.safe  = REGNO (val.base) == STACK_POINTER_REGNUM;\n-\t      return val;\n-\t    }\n-\t}\n-\n-      if (GET_CODE (addr) == CONST)\n-\t{\n-\t  addr = XEXP (addr, 0);\n-\t  all_const = 1;\n-\t}\n-      if (GET_CODE (addr) == PLUS)\n-\t{\n-\t  if (CONSTANT_P (XEXP (addr, 0)))\n-\t    {\n-\t      base = XEXP (addr, 1);\n-\t      offset = XEXP (addr, 0);\n-\t    }\n-\t  else if (CONSTANT_P (XEXP (addr, 1)))\n-\t    {\n-\t      base = XEXP (addr, 0);\n-\t      offset = XEXP (addr, 1);\n-\t    }\n-\t}\n-\n-      if (offset == 0)\n-\t{\n-\t  base = addr;\n-\t  offset = const0_rtx;\n-\t}\n-      if (GET_CODE (offset) == CONST)\n-\toffset = XEXP (offset, 0);\n-      if (GET_CODE (offset) == PLUS)\n-\t{\n-\t  if (GET_CODE (XEXP (offset, 0)) == CONST_INT)\n-\t    {\n-\t      base = gen_rtx_PLUS (GET_MODE (base), base, XEXP (offset, 1));\n-\t      offset = XEXP (offset, 0);\n-\t    }\n-\t  else if (GET_CODE (XEXP (offset, 1)) == CONST_INT)\n-\t    {\n-\t      base = gen_rtx_PLUS (GET_MODE (base), base, XEXP (offset, 0));\n-\t      offset = XEXP (offset, 1);\n-\t    }\n-\t  else\n-\t    {\n-\t      base = gen_rtx_PLUS (GET_MODE (base), base, offset);\n-\t      offset = const0_rtx;\n-\t    }\n-\t}\n-      else if (GET_CODE (offset) != CONST_INT)\n-\t{\n-\t  base = gen_rtx_PLUS (GET_MODE (base), base, offset);\n-\t  offset = const0_rtx;\n-\t}\n-\n-      if (all_const && GET_CODE (base) == PLUS)\n-\tbase = gen_rtx_CONST (GET_MODE (base), base);\n-\n-      if (GET_CODE (offset) != CONST_INT)\n-\tabort ();\n-\n-      val.start = INTVAL (offset);\n-      val.end = val.start + GET_MODE_SIZE (GET_MODE (x));\n-      val.base = base;\n-      return val;\n-    }\n-  else if (REG_P (x))\n+  switch (GET_CODE (x))\n     {\n+    case MEM:\n+      {\n+\trtx base = NULL_RTX, offset = 0;\n+\trtx addr = XEXP (x, 0);\n+\t\n+\tif (GET_CODE (addr) == PRE_DEC || GET_CODE (addr) == PRE_INC\n+\t    || GET_CODE (addr) == POST_DEC || GET_CODE (addr) == POST_INC)\n+\t  {\n+\t    val.base = XEXP (addr, 0);\n+\t    val.start = -GET_MODE_SIZE (GET_MODE (x));\n+\t    val.end = GET_MODE_SIZE (GET_MODE (x));\n+\t    val.safe = REGNO (val.base) == STACK_POINTER_REGNUM;\n+\t    return val;\n+\t  }\n+\t\n+\tif (GET_CODE (addr) == PRE_MODIFY || GET_CODE (addr) == POST_MODIFY)\n+\t  {\n+\t    if (GET_CODE (XEXP (addr, 1)) == PLUS\n+\t\t&& XEXP (addr, 0) == XEXP (XEXP (addr, 1), 0)\n+\t\t&& CONSTANT_P (XEXP (XEXP (addr, 1), 1)))\n+\t      {\n+\t\tval.base  = XEXP (addr, 0);\n+\t\tval.start = -INTVAL (XEXP (XEXP (addr, 1), 1));\n+\t\tval.end   = INTVAL (XEXP (XEXP (addr, 1), 1));\n+\t\tval.safe  = REGNO (val.base) == STACK_POINTER_REGNUM;\n+\t\treturn val;\n+\t      }\n+\t  }\n+\t\n+\tif (GET_CODE (addr) == CONST)\n+\t  {\n+\t    addr = XEXP (addr, 0);\n+\t    all_const = 1;\n+\t  }\n+\tif (GET_CODE (addr) == PLUS)\n+\t  {\n+\t    if (CONSTANT_P (XEXP (addr, 0)))\n+\t      {\n+\t\tbase = XEXP (addr, 1);\n+\t\toffset = XEXP (addr, 0);\n+\t      }\n+\t    else if (CONSTANT_P (XEXP (addr, 1)))\n+\t      {\n+\t\tbase = XEXP (addr, 0);\n+\t\toffset = XEXP (addr, 1);\n+\t      }\n+\t  }\n+\t\n+\tif (offset == 0)\n+\t  {\n+\t    base = addr;\n+\t    offset = const0_rtx;\n+\t  }\n+\tif (GET_CODE (offset) == CONST)\n+\t  offset = XEXP (offset, 0);\n+\tif (GET_CODE (offset) == PLUS)\n+\t  {\n+\t    if (GET_CODE (XEXP (offset, 0)) == CONST_INT)\n+\t      {\n+\t\tbase = gen_rtx_PLUS (GET_MODE (base), base, XEXP (offset, 1));\n+\t\toffset = XEXP (offset, 0);\n+\t      }\n+\t    else if (GET_CODE (XEXP (offset, 1)) == CONST_INT)\n+\t      {\n+\t\tbase = gen_rtx_PLUS (GET_MODE (base), base, XEXP (offset, 0));\n+\t\toffset = XEXP (offset, 1);\n+\t      }\n+\t    else\n+\t      {\n+\t\tbase = gen_rtx_PLUS (GET_MODE (base), base, offset);\n+\t\toffset = const0_rtx;\n+\t      }\n+\t  }\n+\telse if (GET_CODE (offset) != CONST_INT)\n+\t  {\n+\t    base = gen_rtx_PLUS (GET_MODE (base), base, offset);\n+\t    offset = const0_rtx;\n+\t  }\n+\t\n+\tif (all_const && GET_CODE (base) == PLUS)\n+\t  base = gen_rtx_CONST (GET_MODE (base), base);\n+\t\n+\tgcc_assert (GET_CODE (offset) == CONST_INT);\n+\t\n+\tval.start = INTVAL (offset);\n+\tval.end = val.start + GET_MODE_SIZE (GET_MODE (x));\n+\tval.base = base;\n+      }\n+      break;\n+      \n+    case REG:\n       val.reg_flag = 1;\n       val.start = true_regnum (x);\n       if (val.start < 0)\n@@ -2371,9 +2365,9 @@ decompose (rtx x)\n       else\n \t/* A hard reg.  */\n \tval.end = val.start + hard_regno_nregs[val.start][GET_MODE (x)];\n-    }\n-  else if (GET_CODE (x) == SUBREG)\n-    {\n+      break;\n+\n+    case SUBREG:\n       if (!REG_P (SUBREG_REG (x)))\n \t/* This could be more precise, but it's good enough.  */\n \treturn decompose (SUBREG_REG (x));\n@@ -2384,13 +2378,18 @@ decompose (rtx x)\n       else\n \t/* A hard reg.  */\n \tval.end = val.start + hard_regno_nregs[val.start][GET_MODE (x)];\n+      break;\n+\n+    case SCRATCH:\n+      /* This hasn't been assigned yet, so it can't conflict yet.  */\n+      val.safe = 1;\n+      break;\n+\n+    default:\n+      gcc_assert (CONSTANT_P (x));\n+      val.safe = 1;\n+      break;\n     }\n-  else if (CONSTANT_P (x)\n-\t   /* This hasn't been assigned yet, so it can't conflict yet.  */\n-\t   || GET_CODE (x) == SCRATCH)\n-    val.safe = 1;\n-  else\n-    abort ();\n   return val;\n }\n \n@@ -2407,8 +2406,7 @@ immune_p (rtx x, rtx y, struct decomposition ydata)\n   if (ydata.safe)\n     return 1;\n \n-  if (!MEM_P (y))\n-    abort ();\n+  gcc_assert (MEM_P (y));\n   /* If Y is memory and X is not, Y can't affect X.  */\n   if (!MEM_P (x))\n     return 1;\n@@ -2623,8 +2621,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t    case '%':\n \t      {\n \t\t/* The last operand should not be marked commutative.  */\n-\t\tif (i == noperands - 1)\n-\t\t  abort ();\n+\t\tgcc_assert (i != noperands - 1);\n \n \t\t/* We currently only support one commutative pair of\n \t\t   operands.  Some existing asm code currently uses more\n@@ -2635,8 +2632,8 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t   future we may handle it correctly.  */\n \t\tif (commutative < 0)\n \t\t  commutative = i;\n-\t\telse if (!this_insn_is_asm)\n-\t\t  abort ();\n+\t\telse\n+\t\t  gcc_assert (this_insn_is_asm);\n \t      }\n \t      break;\n \t    /* Use of ISDIGIT is tempting here, but it may get expensive because\n@@ -2651,8 +2648,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t\t\t      recog_data.operand[i]);\n \n \t\t/* An operand may not match itself.  */\n-\t\tif (c == i)\n-\t\t  abort ();\n+\t\tgcc_assert (c != i);\n \n \t\t/* If C can be commuted with C+1, and C might need to match I,\n \t\t   then C+1 might also need to match I.  */\n@@ -3510,17 +3506,14 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \n \t    early_data = decompose (recog_data.operand[i]);\n \n-\t    if (modified[i] == RELOAD_READ)\n-\t      abort ();\n+\t    gcc_assert (modified[i] != RELOAD_READ);\n \n \t    if (this_alternative[i] == NO_REGS)\n \t      {\n \t\tthis_alternative_earlyclobber[i] = 0;\n-\t\tif (this_insn_is_asm)\n-\t\t  error_for_asm (this_insn,\n-\t\t\t\t \"`&' constraint used with no register class\");\n-\t\telse\n-\t\t  abort ();\n+\t\tgcc_assert (this_insn_is_asm);\n+\t\terror_for_asm (this_insn,\n+\t\t\t\t\"`&' constraint used with no register class\");\n \t      }\n \n \t    for (j = 0; j < noperands; j++)\n@@ -3895,10 +3888,9 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t\t     0, 0, i, RELOAD_OTHER);\n \t    operand_reloadnum[i] = output_reloadnum;\n \t  }\n-\telse if (insn_code_number >= 0)\n-\t  abort ();\n \telse\n \t  {\n+\t    gcc_assert (insn_code_number < 0);\n \t    error_for_asm (insn, \"inconsistent operand constraints in an `asm'\");\n \t    /* Avoid further trouble with this insn.  */\n \t    PATTERN (insn) = gen_rtx_USE (VOIDmode, const0_rtx);\n@@ -4354,10 +4346,9 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n      do after the insn (such as for output addresses) are fine.  */\n   if (no_input_reloads)\n     for (i = 0; i < n_reloads; i++)\n-      if (rld[i].in != 0\n-\t  && rld[i].when_needed != RELOAD_FOR_OUTADDR_ADDRESS\n-\t  && rld[i].when_needed != RELOAD_FOR_OUTPUT_ADDRESS)\n-\tabort ();\n+      gcc_assert (rld[i].in == 0\n+\t\t  || rld[i].when_needed == RELOAD_FOR_OUTADDR_ADDRESS\n+\t\t  || rld[i].when_needed == RELOAD_FOR_OUTPUT_ADDRESS);\n #endif\n \n   /* Compute reload_mode and reload_nregs.  */\n@@ -4533,8 +4524,7 @@ find_reloads_toplev (rtx x, int opnum, enum reload_type type,\n \t  tem =\n \t    simplify_gen_subreg (GET_MODE (x), reg_equiv_constant[regno],\n \t\t\t\t GET_MODE (SUBREG_REG (x)), SUBREG_BYTE (x));\n-\t  if (!tem)\n-\t    abort ();\n+\t  gcc_assert (tem);\n \t  return tem;\n \t}\n \n@@ -5392,6 +5382,8 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n       {\n \trtx op0 = XEXP (x, 0);\n \trtx op1 = XEXP (x, 1);\n+\tint regno;\n+\tint reloadnum;\n \n \tif (GET_CODE (op1) != PLUS && GET_CODE (op1) != MINUS)\n \t  return 0;\n@@ -5400,8 +5392,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t   where a base register is {inc,dec}remented by the contents\n \t   of another register or by a constant value.  Thus, these\n \t   operands must match.  */\n-\tif (op0 != XEXP (op1, 0))\n-\t  abort ();\n+\tgcc_assert (op0 == XEXP (op1, 0));\n \n \t/* Require index register (or constant).  Let's just handle the\n \t   register case in the meantime... If the target allows\n@@ -5412,67 +5403,62 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t    find_reloads_address_1 (mode, XEXP (op1, 1), 1, &XEXP (op1, 1),\n \t\t\t\t    opnum, type, ind_levels, insn);\n \n-\tif (REG_P (XEXP (op1, 0)))\n-\t  {\n-\t    int regno = REGNO (XEXP (op1, 0));\n-\t    int reloadnum;\n-\n-\t    /* A register that is incremented cannot be constant!  */\n-\t    if (regno >= FIRST_PSEUDO_REGISTER\n-\t\t&& reg_equiv_constant[regno] != 0)\n-\t      abort ();\n-\n-\t    /* Handle a register that is equivalent to a memory location\n-\t       which cannot be addressed directly.  */\n-\t    if (reg_equiv_memory_loc[regno] != 0\n-\t\t&& (reg_equiv_address[regno] != 0\n-\t\t    || num_not_at_initial_offset))\n-\t      {\n-\t\trtx tem = make_memloc (XEXP (x, 0), regno);\n+\tgcc_assert (REG_P (XEXP (op1, 0)));\n \n-\t\tif (reg_equiv_address[regno]\n-\t\t    || ! rtx_equal_p (tem, reg_equiv_mem[regno]))\n-\t\t  {\n-\t\t    /* First reload the memory location's address.\n-\t\t       We can't use ADDR_TYPE (type) here, because we need to\n-\t\t       write back the value after reading it, hence we actually\n-\t\t       need two registers.  */\n-\t\t    find_reloads_address (GET_MODE (tem), &tem, XEXP (tem, 0),\n-\t\t\t\t\t  &XEXP (tem, 0), opnum,\n-\t\t\t\t\t  RELOAD_OTHER,\n-\t\t\t\t\t  ind_levels, insn);\n-\n-\t\t    /* Then reload the memory location into a base\n-\t\t       register.  */\n-\t\t    reloadnum = push_reload (tem, tem, &XEXP (x, 0),\n-\t\t\t\t\t     &XEXP (op1, 0),\n-\t\t\t\t\t     MODE_BASE_REG_CLASS (mode),\n-\t\t\t\t\t     GET_MODE (x), GET_MODE (x), 0,\n-\t\t\t\t\t     0, opnum, RELOAD_OTHER);\n-\n-\t\t    update_auto_inc_notes (this_insn, regno, reloadnum);\n-\t\t    return 0;\n-\t\t  }\n-\t      }\n+\tregno = REGNO (XEXP (op1, 0));\n+\n+\t/* A register that is incremented cannot be constant!  */\n+\tgcc_assert (regno < FIRST_PSEUDO_REGISTER\n+\t\t    || reg_equiv_constant[regno] == 0);\n \n-\t    if (reg_renumber[regno] >= 0)\n-\t      regno = reg_renumber[regno];\n+\t/* Handle a register that is equivalent to a memory location\n+\t    which cannot be addressed directly.  */\n+\tif (reg_equiv_memory_loc[regno] != 0\n+\t    && (reg_equiv_address[regno] != 0\n+\t\t|| num_not_at_initial_offset))\n+\t  {\n+\t    rtx tem = make_memloc (XEXP (x, 0), regno);\n \n-\t    /* We require a base register here...  */\n-\t    if (!REGNO_MODE_OK_FOR_BASE_P (regno, GET_MODE (x)))\n+\t    if (reg_equiv_address[regno]\n+\t\t|| ! rtx_equal_p (tem, reg_equiv_mem[regno]))\n \t      {\n-\t\treloadnum = push_reload (XEXP (op1, 0), XEXP (x, 0),\n-\t\t\t\t\t &XEXP (op1, 0), &XEXP (x, 0),\n-\t\t\t\t\t MODE_BASE_REG_CLASS (mode),\n-\t\t\t\t\t GET_MODE (x), GET_MODE (x), 0, 0,\n-\t\t\t\t\t opnum, RELOAD_OTHER);\n+\t\t/* First reload the memory location's address.\n+\t\t    We can't use ADDR_TYPE (type) here, because we need to\n+\t\t    write back the value after reading it, hence we actually\n+\t\t    need two registers.  */\n+\t\tfind_reloads_address (GET_MODE (tem), &tem, XEXP (tem, 0),\n+\t\t\t\t      &XEXP (tem, 0), opnum,\n+\t\t\t\t      RELOAD_OTHER,\n+\t\t\t\t      ind_levels, insn);\n+\n+\t\t/* Then reload the memory location into a base\n+\t\t    register.  */\n+\t\treloadnum = push_reload (tem, tem, &XEXP (x, 0),\n+\t\t\t\t\t  &XEXP (op1, 0),\n+\t\t\t\t\t  MODE_BASE_REG_CLASS (mode),\n+\t\t\t\t\t  GET_MODE (x), GET_MODE (x), 0,\n+\t\t\t\t\t  0, opnum, RELOAD_OTHER);\n \n \t\tupdate_auto_inc_notes (this_insn, regno, reloadnum);\n \t\treturn 0;\n \t      }\n \t  }\n-\telse\n-\t  abort ();\n+\n+\tif (reg_renumber[regno] >= 0)\n+\t  regno = reg_renumber[regno];\n+\n+\t/* We require a base register here...  */\n+\tif (!REGNO_MODE_OK_FOR_BASE_P (regno, GET_MODE (x)))\n+\t  {\n+\t    reloadnum = push_reload (XEXP (op1, 0), XEXP (x, 0),\n+\t\t\t\t      &XEXP (op1, 0), &XEXP (x, 0),\n+\t\t\t\t      MODE_BASE_REG_CLASS (mode),\n+\t\t\t\t      GET_MODE (x), GET_MODE (x), 0, 0,\n+\t\t\t\t      opnum, RELOAD_OTHER);\n+\n+\t    update_auto_inc_notes (this_insn, regno, reloadnum);\n+\t    return 0;\n+\t  }\n       }\n       return 0;\n \n@@ -5487,9 +5473,8 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t  rtx x_orig = x;\n \n \t  /* A register that is incremented cannot be constant!  */\n-\t  if (regno >= FIRST_PSEUDO_REGISTER\n-\t      && reg_equiv_constant[regno] != 0)\n-\t    abort ();\n+\t  gcc_assert (regno < FIRST_PSEUDO_REGISTER\n+\t\t      || reg_equiv_constant[regno] == 0);\n \n \t  /* Handle a register that is equivalent to a memory location\n \t     which cannot be addressed directly.  */\n@@ -5953,10 +5938,9 @@ subst_reloads (rtx insn)\n \t  for (check_regno = 0; check_regno < max_regno; check_regno++)\n \t    {\n #define CHECK_MODF(ARRAY)\t\t\t\t\t\t\\\n-\t      if (ARRAY[check_regno]\t\t\t\t\t\\\n-\t\t  && loc_mentioned_in_p (r->where,\t\t\t\\\n-\t\t\t\t\t ARRAY[check_regno]))\t\t\\\n-\t\tabort ()\n+\t      gcc_assert (!ARRAY[check_regno]\t\t\t\t\\\n+\t\t\t  || !loc_mentioned_in_p (r->where,\t\t\\\n+\t\t\t\t\t\t  ARRAY[check_regno]))\n \n \t      CHECK_MODF (reg_equiv_constant);\n \t      CHECK_MODF (reg_equiv_memory_loc);\n@@ -6011,8 +5995,8 @@ subst_reloads (rtx insn)\n \t    *r->where = reloadreg;\n \t}\n       /* If reload got no reg and isn't optional, something's wrong.  */\n-      else if (! rld[r->what].optional)\n-\tabort ();\n+      else\n+\tgcc_assert (rld[r->what].optional);\n     }\n }\n \f\n@@ -6024,8 +6008,7 @@ copy_replacements (rtx x, rtx y)\n {\n   /* We can't support X being a SUBREG because we might then need to know its\n      location if something inside it was replaced.  */\n-  if (GET_CODE (x) == SUBREG)\n-    abort ();\n+  gcc_assert (GET_CODE (x) != SUBREG);\n \n   copy_replacements_1 (&x, &y, n_replacements);\n }\n@@ -6194,10 +6177,8 @@ refers_to_regno_for_reload_p (unsigned int regno, unsigned int endregno,\n \t\t\t\t\t\t reg_equiv_memory_loc[r],\n \t\t\t\t\t\t (rtx*) 0);\n \n-\t  if (reg_equiv_constant[r])\n-\t    return 0;\n-\n-\t  abort ();\n+\t  gcc_assert (reg_equiv_constant[r]);\n+\t  return 0;\n \t}\n \n       return (endregno > r\n@@ -6322,18 +6303,19 @@ reg_overlap_mentioned_for_reload_p (rtx x, rtx in)\n \t{\n \t  if (reg_equiv_memory_loc[regno])\n \t    return refers_to_mem_for_reload_p (in);\n-\t  else if (reg_equiv_constant[regno])\n-\t    return 0;\n-\t  abort ();\n+\t  gcc_assert (reg_equiv_constant[regno]);\n+\t  return 0;\n \t}\n     }\n   else if (MEM_P (x))\n     return refers_to_mem_for_reload_p (in);\n   else if (GET_CODE (x) == SCRATCH || GET_CODE (x) == PC\n \t   || GET_CODE (x) == CC0)\n     return reg_mentioned_p (x, in);\n-  else if (GET_CODE (x) == PLUS)\n+  else \n     {\n+      gcc_assert (GET_CODE (x) == PLUS);\n+\n       /* We actually want to know if X is mentioned somewhere inside IN.\n \t We must not say that (plus (sp) (const_int 124)) is in\n \t (plus (sp) (const_int 64)), since that can lead to incorrect reload\n@@ -6349,8 +6331,6 @@ reg_overlap_mentioned_for_reload_p (rtx x, rtx in)\n       else return (reg_overlap_mentioned_for_reload_p (XEXP (x, 0), in)\n \t\t   || reg_overlap_mentioned_for_reload_p (XEXP (x, 1), in));\n     }\n-  else\n-    abort ();\n \n   endregno = regno + (regno < FIRST_PSEUDO_REGISTER\n \t\t      ? hard_regno_nregs[regno][GET_MODE (x)] : 1);"}, {"sha": "63f829fff775b5387203e7535b556629a667227d", "filename": "gcc/reload1.c", "status": "modified", "additions": 47, "deletions": 58, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -536,8 +536,7 @@ compute_use_by_pseudos (HARD_REG_SET *to, regset from)\n \t      BASIC_BLOCK->global_live_at_start, which might still\n \t      contain registers that have not actually been allocated\n \t      since they have an equivalence.  */\n-\t   if (! reload_completed)\n-\t     abort ();\n+\t   gcc_assert (reload_completed);\n \t }\n        else\n \t {\n@@ -584,11 +583,12 @@ replace_pseudos_in (rtx *loc, enum machine_mode mem_mode, rtx usage)\n \t*loc = reg_equiv_mem[regno];\n       else if (reg_equiv_address[regno])\n \t*loc = gen_rtx_MEM (GET_MODE (x), reg_equiv_address[regno]);\n-      else if (!REG_P (regno_reg_rtx[regno])\n-\t       || REGNO (regno_reg_rtx[regno]) != regno)\n-\t*loc = regno_reg_rtx[regno];\n       else\n-\tabort ();\n+\t{\n+\t  gcc_assert (!REG_P (regno_reg_rtx[regno])\n+\t\t      || REGNO (regno_reg_rtx[regno]) != regno);\n+\t  *loc = regno_reg_rtx[regno];\n+\t}\n \n       return;\n     }\n@@ -1071,8 +1071,7 @@ reload (rtx first, int global)\n \n       reload_as_needed (global);\n \n-      if (old_frame_size != get_frame_size ())\n-\tabort ();\n+      gcc_assert (old_frame_size == get_frame_size ());\n \n       if (num_eliminable)\n \tverify_initial_elim_offsets ();\n@@ -1576,8 +1575,7 @@ count_pseudo (int reg)\n \n   SET_REGNO_REG_SET (&pseudos_counted, reg);\n \n-  if (r < 0)\n-    abort ();\n+  gcc_assert (r >= 0);\n \n   spill_add_cost[r] += freq;\n \n@@ -1750,9 +1748,8 @@ find_reg (struct insn_chain *chain, int order)\n \n   for (i = 0; i < rl->nregs; i++)\n     {\n-      if (spill_cost[best_reg + i] != 0\n-\t  || spill_add_cost[best_reg + i] != 0)\n-\tabort ();\n+      gcc_assert (spill_cost[best_reg + i] == 0);\n+      gcc_assert (spill_add_cost[best_reg + i] == 0);\n       SET_HARD_REG_BIT (used_spill_regs_local, best_reg + i);\n     }\n   return 1;\n@@ -2555,7 +2552,7 @@ eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n     case CLOBBER:\n     case ASM_OPERANDS:\n     case SET:\n-      abort ();\n+      gcc_unreachable ();\n \n     default:\n       break;\n@@ -2867,13 +2864,12 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \n   if (! insn_is_asm && icode < 0)\n     {\n-      if (GET_CODE (PATTERN (insn)) == USE\n-\t  || GET_CODE (PATTERN (insn)) == CLOBBER\n-\t  || GET_CODE (PATTERN (insn)) == ADDR_VEC\n-\t  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n-\t  || GET_CODE (PATTERN (insn)) == ASM_INPUT)\n-\treturn 0;\n-      abort ();\n+      gcc_assert (GET_CODE (PATTERN (insn)) == USE\n+\t\t  || GET_CODE (PATTERN (insn)) == CLOBBER\n+\t\t  || GET_CODE (PATTERN (insn)) == ADDR_VEC\n+\t\t  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n+\t\t  || GET_CODE (PATTERN (insn)) == ASM_INPUT);\n+      return 0;\n     }\n \n   if (old_set != 0 && REG_P (SET_DEST (old_set))\n@@ -3027,8 +3023,7 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t\t    PATTERN (insn) = gen_rtx_PARALLEL (VOIDmode, vec);\n \t\t    add_clobbers (PATTERN (insn), INSN_CODE (insn));\n \t\t  }\n-\t\tif (INSN_CODE (insn) < 0)\n-\t\t  abort ();\n+\t\tgcc_assert (INSN_CODE (insn) >= 0);\n \t      }\n \t    /* If we have a nonzero offset, and the source is already\n \t       a simple REG, the following transformation would\n@@ -3299,13 +3294,11 @@ verify_initial_elim_offsets (void)\n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     {\n       INITIAL_ELIMINATION_OFFSET (ep->from, ep->to, t);\n-      if (t != ep->initial_offset)\n-\tabort ();\n+      gcc_assert (t == ep->initial_offset);\n     }\n #else\n   INITIAL_FRAME_POINTER_OFFSET (t);\n-  if (t != reg_eliminate[0].initial_offset)\n-    abort ();\n+  gcc_assert (t == reg_eliminate[0].initial_offset);\n #endif\n }\n \n@@ -3590,8 +3583,7 @@ finish_spills (int global)\n        /* Record the current hard register the pseudo is allocated to in\n \t  pseudo_previous_regs so we avoid reallocating it to the same\n \t  hard reg in a later pass.  */\n-       if (reg_renumber[i] < 0)\n-\t abort ();\n+       gcc_assert (reg_renumber[i] >= 0);\n \n        SET_HARD_REG_BIT (pseudo_previous_regs[i], reg_renumber[i]);\n        /* Mark it as no longer having a hard register home.  */\n@@ -3670,7 +3662,7 @@ finish_spills (int global)\n \n \t  /* Make sure we only enlarge the set.  */\n \t  GO_IF_HARD_REG_SUBSET (used_by_pseudos2, chain->used_spill_regs, ok);\n-\t  abort ();\n+\t  gcc_unreachable ();\n \tok:;\n \t}\n     }\n@@ -4265,7 +4257,7 @@ clear_reload_reg_in_use (unsigned int regno, int opnum,\n       used_in_set = &reload_reg_used_in_insn;\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   /* We resolve conflicts with remaining reloads of the same type by\n      excluding the intervals of reload registers by them from the\n@@ -4461,8 +4453,10 @@ reload_reg_free_p (unsigned int regno, int opnum, enum reload_type type)\n \n     case RELOAD_FOR_OTHER_ADDRESS:\n       return ! TEST_HARD_REG_BIT (reload_reg_used_in_other_addr, regno);\n+\n+    default:\n+      gcc_unreachable ();\n     }\n-  abort ();\n }\n \n /* Return 1 if the value in reload reg REGNO, as used by a reload\n@@ -4594,9 +4588,10 @@ reload_reg_reaches_end_p (unsigned int regno, int opnum, enum reload_type type)\n \t  return 0;\n \n       return 1;\n-    }\n \n-  abort ();\n+    default:\n+      gcc_unreachable ();\n+    }\n }\n \f\n /* Return 1 if the reloads denoted by R1 and R2 cannot share a register.\n@@ -4671,7 +4666,7 @@ reloads_conflict (int r1, int r2)\n       return 1;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \f\n@@ -5591,17 +5586,16 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t{\n \t\t  if (REG_P (equiv))\n \t\t    regno = REGNO (equiv);\n-\t\t  else if (GET_CODE (equiv) == SUBREG)\n+\t\t  else\n \t\t    {\n \t\t      /* This must be a SUBREG of a hard register.\n \t\t\t Make a new REG since this might be used in an\n \t\t\t address and not all machines support SUBREGs\n \t\t\t there.  */\n+\t\t      gcc_assert (GET_CODE (equiv) == SUBREG);\n \t\t      regno = subreg_regno (equiv);\n \t\t      equiv = gen_rtx_REG (rld[r].mode, regno);\n \t\t    }\n-\t\t  else\n-\t\t    abort ();\n \t\t}\n \n \t      /* If we found a spill reg, reject it unless it is free\n@@ -5805,15 +5799,13 @@ choose_reload_regs (struct insn_chain *chain)\n \n       /* Some sanity tests to verify that the reloads found in the first\n \t pass are identical to the ones we have now.  */\n-      if (chain->n_reloads != n_reloads)\n-\tabort ();\n+      gcc_assert (chain->n_reloads == n_reloads);\n \n       for (i = 0; i < n_reloads; i++)\n \t{\n \t  if (chain->rld[i].regno < 0 || chain->rld[i].reg_rtx != 0)\n \t    continue;\n-\t  if (chain->rld[i].when_needed != rld[i].when_needed)\n-\t    abort ();\n+\t  gcc_assert (chain->rld[i].when_needed == rld[i].when_needed);\n \t  for (j = 0; j < n_spills; j++)\n \t    if (spill_regs[j] == chain->rld[i].regno)\n \t      if (! set_reload_reg (j, i))\n@@ -5926,10 +5918,9 @@ choose_reload_regs (struct insn_chain *chain)\n \t\tSET_HARD_REG_BIT (reg_is_output_reload, i + nr);\n \t    }\n \n-\t  if (rld[r].when_needed != RELOAD_OTHER\n-\t      && rld[r].when_needed != RELOAD_FOR_OUTPUT\n-\t      && rld[r].when_needed != RELOAD_FOR_INSN)\n-\t    abort ();\n+\t  gcc_assert (rld[r].when_needed == RELOAD_OTHER\n+\t\t      || rld[r].when_needed == RELOAD_FOR_OUTPUT\n+\t\t      || rld[r].when_needed == RELOAD_FOR_INSN);\n \t}\n     }\n }\n@@ -6075,11 +6066,12 @@ merge_assigned_reloads (rtx insn)\n \t\t     so abort.  */\n \t\t  if (rld[j].reg_rtx)\n \t\t    for (k = 0; k < j; k++)\n-\t\t      if (rld[k].in != 0 && rld[k].reg_rtx != 0\n-\t\t\t  && rld[k].when_needed == rld[j].when_needed\n-\t\t\t  && rtx_equal_p (rld[k].reg_rtx, rld[j].reg_rtx)\n-\t\t\t  && ! rtx_equal_p (rld[k].in, rld[j].in))\n-\t\t\tabort ();\n+\t\t      gcc_assert (rld[k].in == 0 || rld[k].reg_rtx == 0\n+\t\t\t\t  || rld[k].when_needed != rld[j].when_needed\n+\t\t\t\t  || !rtx_equal_p (rld[k].reg_rtx,\n+\t\t\t\t\t\t   rld[j].reg_rtx)\n+\t\t\t\t  || rtx_equal_p (rld[k].in,\n+\t\t\t\t\t\t  rld[j].in));\n \t\t}\n \t}\n     }\n@@ -6293,7 +6285,7 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n       where = &other_input_address_reload_insns;\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   push_to_sequence (*where);\n@@ -6304,8 +6296,7 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n       /* We are not going to bother supporting the case where a\n \t incremented register can't be copied directly from\n \t OLDEQUIV since this seems highly unlikely.  */\n-      if (rl->secondary_in_reload >= 0)\n-\tabort ();\n+      gcc_assert (rl->secondary_in_reload < 0);\n \n       if (reload_inherited[j])\n \toldequiv = reloadreg;\n@@ -6921,8 +6912,7 @@ do_output_reload (struct insn_chain *chain, struct reload *rl, int j)\n     return;\n \n   /* If is a JUMP_INSN, we can't support output reloads yet.  */\n-  if (JUMP_P (insn))\n-    abort ();\n+  gcc_assert (!JUMP_P (insn));\n \n   emit_output_reload_insns (chain, rld + j, j);\n }\n@@ -8066,8 +8056,7 @@ fixup_abnormal_edges (void)\n \t\t && !can_throw_internal (insn)\n \t\t && insn != BB_HEAD (bb))\n \t    insn = PREV_INSN (insn);\n-\t  if (!CALL_P (insn) && !can_throw_internal (insn))\n-\t    abort ();\n+\t  gcc_assert (CALL_P (insn) || can_throw_internal (insn));\n \t  BB_END (bb) = insn;\n \t  inserted = true;\n \t  insn = NEXT_INSN (insn);"}, {"sha": "fbaf968df73f2fa519504541c65ea347f278b3f1", "filename": "gcc/reorg.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -253,7 +253,7 @@ stop_search_p (rtx insn, int labels_p)\n \t      || asm_noperands (PATTERN (insn)) >= 0);\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \f\n@@ -564,8 +564,7 @@ emit_delay_sequence (rtx insn, rtx list, int length)\n   if (had_barrier)\n     emit_barrier_after (seq_insn);\n \n-  if (i != length + 1)\n-    abort ();\n+  gcc_assert (i == length + 1);\n \n   return seq_insn;\n }\n@@ -887,7 +886,7 @@ get_jump_flags (rtx insn, rtx label)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   else\n@@ -2549,9 +2548,8 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n   int flags;\n \n   /* Validate our arguments.  */\n-  if ((condition == const_true_rtx && ! thread_if_true)\n-      || (! own_thread && ! thread_if_true))\n-    abort ();\n+  gcc_assert(condition != const_true_rtx || thread_if_true);\n+  gcc_assert(own_thread || thread_if_true);\n \n   flags = get_jump_flags (insn, JUMP_LABEL (insn));\n \n@@ -2921,8 +2919,7 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n     {\n       rtx label;\n \n-      if (! thread_if_true)\n-\tabort ();\n+      gcc_assert (thread_if_true);\n \n       if (new_thread && JUMP_P (new_thread)\n \t  && (simplejump_p (new_thread)\n@@ -3228,8 +3225,7 @@ relax_delay_slots (rtx first)\n \n \t  trial = PREV_INSN (insn);\n \t  delete_related_insns (insn);\n-\t  if (GET_CODE (pat) != SEQUENCE)\n-\t    abort ();\n+\t  gcc_assert (GET_CODE (pat) == SEQUENCE);\n \t  after = trial;\n \t  for (i = 0; i < XVECLEN (pat, 0); i++)\n \t    {\n@@ -3347,8 +3343,7 @@ relax_delay_slots (rtx first)\n \n \t  trial = PREV_INSN (insn);\n \t  delete_related_insns (insn);\n-\t  if (GET_CODE (pat) != SEQUENCE)\n-\t    abort ();\n+\t  gcc_assert (GET_CODE (pat) == SEQUENCE);\n \t  after = trial;\n \t  for (i = 0; i < XVECLEN (pat, 0); i++)\n \t    {"}, {"sha": "7d6bbb759c5be8e62c2cbae4686d77b384b441ea", "filename": "gcc/resource.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -233,8 +233,7 @@ mark_referenced_resources (rtx x, struct resources *res,\n \t  unsigned int last_regno\n \t    = regno + hard_regno_nregs[regno][GET_MODE (x)];\n \n-\t  if (last_regno > FIRST_PSEUDO_REGISTER)\n-\t    abort ();\n+\t  gcc_assert (last_regno <= FIRST_PSEUDO_REGISTER);\n \t  for (r = regno; r < last_regno; r++)\n \t    SET_HARD_REG_BIT (res->regs, r);\n \t}\n@@ -246,8 +245,7 @@ mark_referenced_resources (rtx x, struct resources *res,\n \t  unsigned int last_regno\n \t    = regno + hard_regno_nregs[regno][GET_MODE (x)];\n \n-\t  if (last_regno > FIRST_PSEUDO_REGISTER)\n-\t    abort ();\n+\t  gcc_assert (last_regno <= FIRST_PSEUDO_REGISTER);\n \t  for (r = regno; r < last_regno; r++)\n \t    SET_HARD_REG_BIT (res->regs, r);\n \t}\n@@ -340,8 +338,7 @@ mark_referenced_resources (rtx x, struct resources *res,\n \t    {\n \t      sequence = PATTERN (NEXT_INSN (insn));\n \t      seq_size = XVECLEN (sequence, 0);\n-\t      if (GET_CODE (sequence) != SEQUENCE)\n-\t\tabort ();\n+\t      gcc_assert (GET_CODE (sequence) == SEQUENCE);\n \t    }\n \n \t  res->memory = 1;\n@@ -771,8 +768,7 @@ mark_set_resources (rtx x, struct resources *res, int in_dest,\n \t      unsigned int last_regno\n \t\t= regno + hard_regno_nregs[regno][GET_MODE (x)];\n \n-\t      if (last_regno > FIRST_PSEUDO_REGISTER)\n-\t\tabort ();\n+\t      gcc_assert (last_regno <= FIRST_PSEUDO_REGISTER);\n \t      for (r = regno; r < last_regno; r++)\n \t\tSET_HARD_REG_BIT (res->regs, r);\n \t    }\n@@ -786,8 +782,7 @@ mark_set_resources (rtx x, struct resources *res, int in_dest,\n \t  unsigned int last_regno\n \t    = regno + hard_regno_nregs[regno][GET_MODE (x)];\n \n-\t  if (last_regno > FIRST_PSEUDO_REGISTER)\n-\t    abort ();\n+\t  gcc_assert (last_regno <= FIRST_PSEUDO_REGISTER);\n \t  for (r = regno; r < last_regno; r++)\n \t    SET_HARD_REG_BIT (res->regs, r);\n \t}"}, {"sha": "05075dd015aafc27d364e3e15ed79613794da731", "filename": "gcc/rtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -296,7 +296,7 @@ copy_rtx (rtx orig)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   return copy;\n@@ -427,7 +427,7 @@ rtx_equal_p (rtx x, rtx y)\n \t     contain anything but integers and other rtx's,\n \t     except for within LABEL_REFs and SYMBOL_REFs.  */\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   return 1;"}, {"sha": "21879d63684cfdeb149e45ee7047e471dbcc8dc8", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 33, "deletions": 53, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -1123,8 +1123,8 @@ insn_dependent_p (rtx x, rtx y)\n {\n   rtx tmp;\n \n-  if (! INSN_P (x) || ! INSN_P (y))\n-    abort ();\n+  gcc_assert (INSN_P (x));\n+  gcc_assert (INSN_P (y));\n \n   tmp = PATTERN (y);\n   note_stores (PATTERN (x), insn_dependent_p_1, &tmp);\n@@ -1578,11 +1578,7 @@ reg_overlap_mentioned_p (rtx x, rtx in)\n       }\n \n     default:\n-#ifdef ENABLE_CHECKING\n-      if (!CONSTANT_P (x))\n-\tabort ();\n-#endif\n-\n+      gcc_assert (CONSTANT_P (x));\n       return 0;\n     }\n }\n@@ -1744,8 +1740,7 @@ dead_or_set_p (rtx insn, rtx x)\n   if (GET_CODE (x) == CC0)\n     return 1;\n \n-  if (!REG_P (x))\n-    abort ();\n+  gcc_assert (REG_P (x));\n \n   regno = REGNO (x);\n   last_regno = (regno >= FIRST_PSEUDO_REGISTER ? regno\n@@ -1927,8 +1922,7 @@ find_reg_fusage (rtx insn, enum rtx_code code, rtx datum)\n   if (!CALL_P (insn))\n     return 0;\n \n-  if (! datum)\n-    abort ();\n+  gcc_assert (datum);\n \n   if (!REG_P (datum))\n     {\n@@ -2040,7 +2034,7 @@ remove_note (rtx insn, rtx note)\n \treturn;\n       }\n \n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Search LISTP (an EXPR_LIST) for an entry whose first operand is NODE and\n@@ -2520,8 +2514,7 @@ replace_rtx (rtx x, rtx from, rtx to)\n \t  x = simplify_subreg (GET_MODE (x), new,\n \t\t\t       GET_MODE (SUBREG_REG (x)),\n \t\t\t       SUBREG_BYTE (x));\n-\t  if (! x)\n-\t    abort ();\n+\t  gcc_assert (x);\n \t}\n       else\n \tSUBREG_REG (x) = new;\n@@ -2536,8 +2529,7 @@ replace_rtx (rtx x, rtx from, rtx to)\n \t{\n \t  x = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),\n \t\t\t\t\tnew, GET_MODE (XEXP (x, 0)));\n-\t  if (! x)\n-\t    abort ();\n+\t  gcc_assert (x);\n \t}\n       else\n \tXEXP (x, 0) = new;\n@@ -3189,11 +3181,10 @@ subreg_lsb_1 (enum machine_mode outer_mode,\n   if (WORDS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n     /* If the subreg crosses a word boundary ensure that\n        it also begins and ends on a word boundary.  */\n-    if ((subreg_byte % UNITS_PER_WORD\n-\t + GET_MODE_SIZE (outer_mode)) > UNITS_PER_WORD\n-\t&& (subreg_byte % UNITS_PER_WORD\n-\t    || GET_MODE_SIZE (outer_mode) % UNITS_PER_WORD))\n-\tabort ();\n+    gcc_assert (!((subreg_byte % UNITS_PER_WORD\n+\t\t  + GET_MODE_SIZE (outer_mode)) > UNITS_PER_WORD\n+\t\t  && (subreg_byte % UNITS_PER_WORD\n+\t\t      || GET_MODE_SIZE (outer_mode) % UNITS_PER_WORD)));\n \n   if (WORDS_BIG_ENDIAN)\n     word = (GET_MODE_SIZE (inner_mode)\n@@ -3236,8 +3227,7 @@ subreg_regno_offset (unsigned int xregno, enum machine_mode xmode,\n   int mode_multiple, nregs_multiple;\n   int y_offset;\n \n-  if (xregno >= FIRST_PSEUDO_REGISTER)\n-    abort ();\n+  gcc_assert (xregno < FIRST_PSEUDO_REGISTER);\n \n   nregs_xmode = hard_regno_nregs[xregno][xmode];\n   nregs_ymode = hard_regno_nregs[xregno][ymode];\n@@ -3256,8 +3246,7 @@ subreg_regno_offset (unsigned int xregno, enum machine_mode xmode,\n \n   /* size of ymode must not be greater than the size of xmode.  */\n   mode_multiple = GET_MODE_SIZE (xmode) / GET_MODE_SIZE (ymode);\n-  if (mode_multiple == 0)\n-    abort ();\n+  gcc_assert (mode_multiple != 0);\n \n   y_offset = offset / GET_MODE_SIZE (ymode);\n   nregs_multiple =  nregs_xmode / nregs_ymode;\n@@ -3279,8 +3268,7 @@ subreg_offset_representable_p (unsigned int xregno, enum machine_mode xmode,\n   int mode_multiple, nregs_multiple;\n   int y_offset;\n \n-  if (xregno >= FIRST_PSEUDO_REGISTER)\n-    abort ();\n+  gcc_assert (xregno < FIRST_PSEUDO_REGISTER);\n \n   nregs_xmode = hard_regno_nregs[xregno][xmode];\n   nregs_ymode = hard_regno_nregs[xregno][ymode];\n@@ -3296,15 +3284,12 @@ subreg_offset_representable_p (unsigned int xregno, enum machine_mode xmode,\n   if (offset == subreg_lowpart_offset (ymode, xmode))\n     return true;\n \n-#ifdef ENABLE_CHECKING\n   /* This should always pass, otherwise we don't know how to verify the\n      constraint.  These conditions may be relaxed but subreg_offset would\n      need to be redesigned.  */\n-  if (GET_MODE_SIZE (xmode) % GET_MODE_SIZE (ymode)\n-      || GET_MODE_SIZE (ymode) % nregs_ymode\n-      || nregs_xmode % nregs_ymode)\n-    abort ();\n-#endif\n+  gcc_assert ((GET_MODE_SIZE (xmode) % GET_MODE_SIZE (ymode)) == 0);\n+  gcc_assert ((GET_MODE_SIZE (ymode) % nregs_ymode) == 0);\n+  gcc_assert ((nregs_xmode % nregs_ymode) == 0);\n \n   /* The XMODE value can be seen as a vector of NREGS_XMODE\n      values.  The subreg must represent a lowpart of given field.\n@@ -3316,16 +3301,14 @@ subreg_offset_representable_p (unsigned int xregno, enum machine_mode xmode,\n \n   /* size of ymode must not be greater than the size of xmode.  */\n   mode_multiple = GET_MODE_SIZE (xmode) / GET_MODE_SIZE (ymode);\n-  if (mode_multiple == 0)\n-    abort ();\n+  gcc_assert (mode_multiple != 0);\n \n   y_offset = offset / GET_MODE_SIZE (ymode);\n   nregs_multiple =  nregs_xmode / nregs_ymode;\n-#ifdef ENABLE_CHECKING\n-  if (offset % GET_MODE_SIZE (ymode)\n-      || mode_multiple % nregs_multiple)\n-    abort ();\n-#endif\n+\n+  gcc_assert ((offset % GET_MODE_SIZE (ymode)) == 0);\n+  gcc_assert ((mode_multiple % nregs_multiple) == 0);\n+\n   return (!(y_offset % (mode_multiple / nregs_multiple)));\n }\n \n@@ -3380,8 +3363,7 @@ find_first_parameter_load (rtx call_insn, rtx boundary)\n     if (GET_CODE (XEXP (p, 0)) == USE\n \t&& REG_P (XEXP (XEXP (p, 0), 0)))\n       {\n-\tif (REGNO (XEXP (XEXP (p, 0), 0)) >= FIRST_PSEUDO_REGISTER)\n-\t  abort ();\n+\tgcc_assert (REGNO (XEXP (XEXP (p, 0), 0)) < FIRST_PSEUDO_REGISTER);\n \n \t/* We only care about registers which can hold function\n \t   arguments.  */\n@@ -3409,8 +3391,7 @@ find_first_parameter_load (rtx call_insn, rtx boundary)\n          CODE_LABEL.  */\n       if (LABEL_P (before))\n \t{\n-\t  if (before != boundary)\n-\t    abort ();\n+\t  gcc_assert (before == boundary);\n \t  break;\n \t}\n \n@@ -3571,7 +3552,7 @@ can_hoist_insn_p (rtx insn, rtx val, regset live)\n \t}\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   return true;\n }\n@@ -3603,8 +3584,7 @@ hoist_update_store (rtx insn, rtx *xp, rtx val, rtx new)\n       x = *xp;\n     }\n \n-  if (!REG_P (x))\n-    abort ();\n+  gcc_assert (REG_P (x));\n \n   /* We've verified that hard registers are dead, so we may keep the side\n      effect.  Otherwise replace it by new pseudo.  */\n@@ -3623,6 +3603,7 @@ hoist_insn_after (rtx insn, rtx after, rtx val, rtx new)\n   rtx pat;\n   int i;\n   rtx note;\n+  int applied;\n \n   insn = emit_copy_of_insn_after (insn, after);\n   pat = PATTERN (insn);\n@@ -3673,10 +3654,10 @@ hoist_insn_after (rtx insn, rtx after, rtx val, rtx new)\n \t}\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n-  if (!apply_change_group ())\n-    abort ();\n+  applied = apply_change_group ();\n+  gcc_assert (applied);\n \n   return insn;\n }\n@@ -3688,8 +3669,7 @@ hoist_insn_to_edge (rtx insn, edge e, rtx val, rtx new)\n \n   /* We cannot insert instructions on an abnormal critical edge.\n      It will be easier to find the culprit if we die now.  */\n-  if ((e->flags & EDGE_ABNORMAL) && EDGE_CRITICAL_P (e))\n-    abort ();\n+  gcc_assert (!(e->flags & EDGE_ABNORMAL) || !EDGE_CRITICAL_P (e));\n \n   /* Do not use emit_insn_on_edge as we want to preserve notes and similar\n      stuff.  We also emit CALL_INSNS and firends.  */\n@@ -4178,7 +4158,7 @@ nonzero_bits1 (rtx x, enum machine_mode mode, rtx known_x,\n \t    result_low = MIN (low0, low1);\n \t    break;\n \t  default:\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t  }\n \n \tif (result_width < mode_width)"}, {"sha": "49d4cfe7c596ac9eba5c39b433069d73e6635c1f", "filename": "gcc/rtlhooks.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Frtlhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Frtlhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlhooks.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -47,15 +47,16 @@ gen_lowpart_general (enum machine_mode mode, rtx x)\n     {\n       /* Must be a hard reg that's not valid in MODE.  */\n       result = gen_lowpart_common (mode, copy_to_reg (x));\n-      if (result == 0)\n-\tabort ();\n+      gcc_assert (result != 0);\n       return result;\n     }\n-  else if (MEM_P (x))\n+  else\n     {\n-      /* The only additional case we can do is MEM.  */\n       int offset = 0;\n \n+      /* The only additional case we can do is MEM.  */\n+      gcc_assert (MEM_P (x));\n+\n       /* The following exposes the use of \"x\" to CSE.  */\n       if (GET_MODE_SIZE (GET_MODE (x)) <= UNITS_PER_WORD\n \t  && SCALAR_INT_MODE_P (GET_MODE (x))\n@@ -76,8 +77,6 @@ gen_lowpart_general (enum machine_mode mode, rtx x)\n \n       return adjust_address (x, mode, offset);\n     }\n-  else\n-    abort ();\n }\n \n rtx"}, {"sha": "f1d9c86ee302175b15cd16ba4950697f4b1122e2", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -301,8 +301,7 @@ sbitmap_difference (sbitmap dst, sbitmap a, sbitmap b)\n   sbitmap_ptr bp = b->elms;\n \n   /* A should be at least as large as DEST, to have a defined source.  */\n-  if (a->size < dst_size)\n-    abort ();\n+  gcc_assert (a->size >= dst_size);\n   /* If minuend is smaller, we simply pretend it to be zero bits, i.e.\n      only copy the subtrahend into dest.  */\n   if (b->size < min_size)"}, {"sha": "6e68bde56bd7533220e948de0fdab0764b929c99", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -252,8 +252,8 @@ add_dependence (rtx insn, rtx elem, enum reg_note dep_type)\n     {\n       enum reg_note present_dep_type = 0;\n \n-      if (anti_dependency_cache == NULL || output_dependency_cache == NULL)\n-\tabort ();\n+      gcc_assert (anti_dependency_cache);\n+      gcc_assert (output_dependency_cache);\n       if (bitmap_bit_p (&true_dependency_cache[INSN_LUID (insn)],\n \t\t\tINSN_LUID (elem)))\n \t/* Do nothing (present_set_type is already 0).  */\n@@ -281,15 +281,21 @@ add_dependence (rtx insn, rtx elem, enum reg_note dep_type)\n              may be changed.  */\n \t  if (true_dependency_cache != NULL)\n \t    {\n-\t      if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n-\t\tbitmap_clear_bit (&anti_dependency_cache[INSN_LUID (insn)],\n-\t\t\t\t  INSN_LUID (elem));\n-\t      else if (REG_NOTE_KIND (link) == REG_DEP_OUTPUT\n-\t\t       && output_dependency_cache)\n-\t\tbitmap_clear_bit (&output_dependency_cache[INSN_LUID (insn)],\n-\t\t\t\t  INSN_LUID (elem));\n-\t      else\n-\t\tabort ();\n+\t      enum reg_note kind = REG_NOTE_KIND (link);\n+\t      switch (kind)\n+\t\t{\n+\t\tcase REG_DEP_ANTI:\n+\t\t  bitmap_clear_bit (&anti_dependency_cache[INSN_LUID (insn)],\n+\t\t\t\t    INSN_LUID (elem));\n+\t\t  break;\n+\t\tcase REG_DEP_OUTPUT:\n+\t\t  gcc_assert (output_dependency_cache);\n+\t\t  bitmap_clear_bit (&output_dependency_cache[INSN_LUID (insn)],\n+\t\t\t\t    INSN_LUID (elem));\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n \t    }\n #endif\n \n@@ -518,9 +524,8 @@ sched_analyze_1 (struct deps *deps, rtx x, rtx insn)\n \t purpose already.  */\n       else if (regno >= deps->max_reg)\n \t{\n-\t  if (GET_CODE (PATTERN (insn)) != USE\n-\t      && GET_CODE (PATTERN (insn)) != CLOBBER)\n-\t    abort ();\n+\t  gcc_assert (GET_CODE (PATTERN (insn)) == USE\n+\t\t      || GET_CODE (PATTERN (insn)) == CLOBBER);\n \t}\n       else\n \t{\n@@ -659,9 +664,8 @@ sched_analyze_2 (struct deps *deps, rtx x, rtx insn)\n \t   purpose already.  */\n \telse if (regno >= deps->max_reg)\n \t  {\n-\t    if (GET_CODE (PATTERN (insn)) != USE\n-\t\t&& GET_CODE (PATTERN (insn)) != CLOBBER)\n-\t      abort ();\n+\t    gcc_assert (GET_CODE (PATTERN (insn)) == USE\n+\t\t\t|| GET_CODE (PATTERN (insn)) == CLOBBER);\n \t  }\n \telse\n \t  {\n@@ -1363,7 +1367,7 @@ sched_analyze (struct deps *deps, rtx head, rtx tail)\n \t  return;\n \t}\n     }\n-  abort ();\n+  gcc_unreachable ();\n }\n \f\n \n@@ -1382,14 +1386,15 @@ add_forward_dependence (rtx from, rtx to, enum reg_note dep_type)\n \n      However, if we have enabled checking we might as well go\n      ahead and verify that add_dependence worked properly.  */\n-  if (NOTE_P (from)\n-      || INSN_DELETED_P (from)\n-      || (forward_dependency_cache != NULL\n-\t  && bitmap_bit_p (&forward_dependency_cache[INSN_LUID (from)],\n-\t\t\t   INSN_LUID (to)))\n-      || (forward_dependency_cache == NULL\n-\t  && find_insn_list (to, INSN_DEPEND (from))))\n-    abort ();\n+  gcc_assert (!NOTE_P (from));\n+  gcc_assert (!INSN_DELETED_P (from));\n+  if (forward_dependency_cache)\n+    gcc_assert (!bitmap_bit_p (&forward_dependency_cache[INSN_LUID (from)],\n+\t\t\t       INSN_LUID (to)));\n+  else\n+    gcc_assert (!find_insn_list (to, INSN_DEPEND (from)));\n+\n+  /* ??? If bitmap_bit_p is a predicate, what is this supposed to do? */\n   if (forward_dependency_cache != NULL)\n     bitmap_bit_p (&forward_dependency_cache[INSN_LUID (from)],\n \t\t  INSN_LUID (to));"}, {"sha": "2344d1e9de4f98c4b1ccd499a6049482be5063a3", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -240,8 +240,7 @@ fix_basic_block_boundaries (basic_block bb, basic_block last, rtx head,\n \n   for (; insn != aftertail; insn = NEXT_INSN (insn))\n     {\n-      if (LABEL_P (insn))\n-\tabort ();\n+      gcc_assert (!LABEL_P (insn));\n       /* Create new basic blocks just before first insn.  */\n       if (inside_basic_block_p (insn))\n \t{\n@@ -542,8 +541,7 @@ schedule_ebb (rtx head, rtx tail)\n   schedule_block (-1, n_insns);\n \n   /* Sanity check: verify that all region insns were scheduled.  */\n-  if (sched_n_insns != n_insns)\n-    abort ();\n+  gcc_assert (sched_n_insns == n_insns);\n   head = current_sched_info->head;\n   tail = current_sched_info->tail;\n "}, {"sha": "9bd6d527feb22a917a52d4bae04a7ef73ab05f2e", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -517,9 +517,7 @@ debug_regions (void)\n \t{\n \t  current_blocks = RGN_BLOCKS (rgn);\n \n-\t  if (bb != BLOCK_TO_BB (BB_TO_BLOCK (bb)))\n-\t    abort ();\n-\n+\t  gcc_assert (bb == BLOCK_TO_BB (BB_TO_BLOCK (bb)));\n \t  fprintf (sched_dump, \" %d/%d \", bb, BB_TO_BLOCK (bb));\n \t}\n \n@@ -1211,8 +1209,7 @@ compute_trg_info (int trg)\n \t  sp->update_bbs.nr_members = update_idx;\n \n \t  /* Make sure we didn't overrun the end of bblst_table.  */\n-\t  if (bblst_last > bblst_size)\n-\t    abort ();\n+\t  gcc_assert (bblst_last <= bblst_size);\n \t}\n       else\n \t{\n@@ -2501,8 +2498,7 @@ schedule_region (int rgn)\n     }\n \n   /* Sanity check: verify that all region insns were scheduled.  */\n-  if (sched_rgn_n_insns != rgn_n_insns)\n-    abort ();\n+  gcc_assert (sched_rgn_n_insns == rgn_n_insns);\n \n   /* Restore line notes.  */\n   if (write_symbols != NO_DEBUG)\n@@ -2708,9 +2704,8 @@ schedule_insns (FILE *dump_file)\n \t    sbitmap_zero (blocks);\n \t    SET_BIT (blocks, rgn_bb_table[RGN_BLOCKS (rgn)]);\n \n-\t    if (deaths_in_region[rgn]\n-\t\t!= count_or_remove_death_notes (blocks, 0))\n-\t      abort ();\n+\t    gcc_assert (deaths_in_region[rgn]\n+\t\t\t== count_or_remove_death_notes (blocks, 0));\n \t  }\n       free (deaths_in_region);\n     }\n@@ -2733,10 +2728,7 @@ schedule_insns (FILE *dump_file)\n \t\t   nr_inter, nr_spec);\n \t}\n       else\n-\t{\n-\t  if (nr_inter > 0)\n-\t    abort ();\n-\t}\n+\tgcc_assert (nr_inter <= 0);\n       fprintf (sched_dump, \"\\n\\n\");\n     }\n "}, {"sha": "aa228317ba08dfbe241e6a768226a34458eb875a", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -566,8 +566,7 @@ print_pattern (char *buf, rtx x, int verbose)\n       break;\n     case SEQUENCE:\n       /* Should never see SEQUENCE codes until after reorg.  */\n-      abort ();\n-      break;\n+      gcc_unreachable ();\n     case ASM_INPUT:\n       sprintf (buf, \"asm {%s}\", XSTR (x, 0));\n       break;"}, {"sha": "8689cc09be40d80bed37353e33183538962d269c", "filename": "gcc/sdbout.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -758,7 +758,7 @@ sdbout_symbol (tree decl, int local)\n     case PARM_DECL:\n       /* Parm decls go in their own separate chains\n \t and are output by sdbout_reg_parms and sdbout_parms.  */\n-      abort ();\n+      gcc_unreachable ();\n \n     case VAR_DECL:\n       /* Don't mention a variable that is external.\n@@ -942,10 +942,9 @@ sdbout_toplevel_data (tree decl)\n   if (DECL_IGNORED_P (decl))\n     return;\n \n-  if (! (TREE_CODE (decl) == VAR_DECL\n-\t && MEM_P (DECL_RTL (decl))\n-\t && DECL_INITIAL (decl)))\n-    abort ();\n+  gcc_assert (TREE_CODE (decl) == VAR_DECL);\n+  gcc_assert (MEM_P (DECL_RTL (decl)));\n+  gcc_assert (DECL_INITIAL (decl));\n \n   PUT_SDB_DEF (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n   PUT_SDB_VAL (XEXP (DECL_RTL (decl), 0));"}, {"sha": "eec2a5816a3b4783215583fa49d533c8479103b1", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 105, "deletions": 129, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -360,16 +360,15 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n \n   if (code == VEC_DUPLICATE)\n     {\n-      if (!VECTOR_MODE_P (mode))\n-\tabort ();\n-      if (GET_MODE (trueop) != VOIDmode\n-\t  && !VECTOR_MODE_P (GET_MODE (trueop))\n-\t  && GET_MODE_INNER (mode) != GET_MODE (trueop))\n-\tabort ();\n-      if (GET_MODE (trueop) != VOIDmode\n-\t  && VECTOR_MODE_P (GET_MODE (trueop))\n-\t  && GET_MODE_INNER (mode) != GET_MODE_INNER (GET_MODE (trueop)))\n-\tabort ();\n+      gcc_assert (VECTOR_MODE_P (mode));\n+      if (GET_MODE (trueop) != VOIDmode)\n+      {\n+\tif (!VECTOR_MODE_P (GET_MODE (trueop)))\n+\t  gcc_assert (GET_MODE_INNER (mode) == GET_MODE (trueop));\n+\telse\n+\t  gcc_assert (GET_MODE_INNER (mode) == GET_MODE_INNER\n+\t\t\t\t\t\t(GET_MODE (trueop)));\n+      }\n       if (GET_CODE (trueop) == CONST_INT || GET_CODE (trueop) == CONST_DOUBLE\n \t  || GET_CODE (trueop) == CONST_VECTOR)\n \t{\n@@ -387,8 +386,8 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n               int in_elt_size = GET_MODE_SIZE (GET_MODE_INNER (inmode));\n               unsigned in_n_elts = (GET_MODE_SIZE (inmode) / in_elt_size);\n \n-\t      if (in_n_elts >= n_elts || n_elts % in_n_elts)\n-\t\tabort ();\n+\t      gcc_assert (in_n_elts < n_elts);\n+\t      gcc_assert ((n_elts % in_n_elts) == 0);\n \t      for (i = 0; i < n_elts; i++)\n \t        RTVEC_ELT (v, i) = CONST_VECTOR_ELT (trueop, i % in_n_elts);\n \t    }\n@@ -408,9 +407,7 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n       rtvec v = rtvec_alloc (n_elts);\n       unsigned int i;\n \n-      if (op_n_elts != n_elts)\n-\tabort ();\n-\n+      gcc_assert (op_n_elts == n_elts);\n       for (i = 0; i < n_elts; i++)\n \t{\n \t  rtx x = simplify_unary_operation (code, GET_MODE_INNER (mode),\n@@ -541,15 +538,13 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n \tcase ZERO_EXTEND:\n \t  /* When zero-extending a CONST_INT, we need to know its\n              original mode.  */\n-\t  if (op_mode == VOIDmode)\n-\t    abort ();\n+\t  gcc_assert (op_mode != VOIDmode);\n \t  if (GET_MODE_BITSIZE (op_mode) == HOST_BITS_PER_WIDE_INT)\n \t    {\n \t      /* If we were really extending the mode,\n \t\t we would have to distinguish between zero-extension\n \t\t and sign-extension.  */\n-\t      if (width != GET_MODE_BITSIZE (op_mode))\n-\t\tabort ();\n+\t      gcc_assert (width == GET_MODE_BITSIZE (op_mode));\n \t      val = arg0;\n \t    }\n \t  else if (GET_MODE_BITSIZE (op_mode) < HOST_BITS_PER_WIDE_INT)\n@@ -566,8 +561,7 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t      /* If we were really extending the mode,\n \t\t we would have to distinguish between zero-extension\n \t\t and sign-extension.  */\n-\t      if (width != GET_MODE_BITSIZE (op_mode))\n-\t\tabort ();\n+\t      gcc_assert (width == GET_MODE_BITSIZE (op_mode));\n \t      val = arg0;\n \t    }\n \t  else if (GET_MODE_BITSIZE (op_mode) < HOST_BITS_PER_WIDE_INT)\n@@ -590,7 +584,7 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t  return 0;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       val = trunc_int_for_mode (val, mode);\n@@ -690,8 +684,7 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t  break;\n \n \tcase ZERO_EXTEND:\n-\t  if (op_mode == VOIDmode)\n-\t    abort ();\n+\t  gcc_assert (op_mode != VOIDmode);\n \n \t  if (GET_MODE_BITSIZE (op_mode) > HOST_BITS_PER_WIDE_INT)\n \t    return 0;\n@@ -766,7 +759,7 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t    real_from_target (&d, tmp, mode);\n \t  }\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       return CONST_DOUBLE_FROM_REAL_VALUE (d, mode);\n     }\n@@ -864,7 +857,7 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       return immed_double_const (xl, xh, mode);\n     }\n@@ -1175,16 +1168,12 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n   rtx trueop0, trueop1;\n   rtx tem;\n \n-#ifdef ENABLE_CHECKING\n   /* Relational operations don't work here.  We must know the mode\n      of the operands in order to do the comparison correctly.\n      Assuming a full word can give incorrect results.\n      Consider comparing 128 with -128 in QImode.  */\n-\n-  if (GET_RTX_CLASS (code) == RTX_COMPARE\n-      || GET_RTX_CLASS (code) == RTX_COMM_COMPARE)\n-    abort ();\n-#endif\n+  gcc_assert (GET_RTX_CLASS (code) != RTX_COMPARE);\n+  gcc_assert (GET_RTX_CLASS (code) != RTX_COMM_COMPARE);\n \n   /* Make sure the constant is second.  */\n   if (GET_RTX_CLASS (code) == RTX_COMM_ARITH\n@@ -1211,9 +1200,8 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n       rtvec v = rtvec_alloc (n_elts);\n       unsigned int i;\n \n-      if (op0_n_elts != n_elts || op1_n_elts != n_elts)\n-\tabort ();\n-\n+      gcc_assert (op0_n_elts == n_elts);\n+      gcc_assert (op1_n_elts == n_elts);\n       for (i = 0; i < n_elts; i++)\n \t{\n \t  rtx x = simplify_binary_operation (code, GET_MODE_INNER (mode),\n@@ -1247,14 +1235,20 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n \t\t\t  GET_MODE (op1));\n \t  for (i = 0; i < 4; i++)\n \t    {\n-\t      if (code == AND)\n+\t      switch (code)\n+\t      {\n+\t      case AND:\n \t\ttmp0[i] &= tmp1[i];\n-\t      else if (code == IOR)\n+\t\tbreak;\n+\t      case IOR:\n \t\ttmp0[i] |= tmp1[i];\n-\t      else if (code == XOR)\n+\t\tbreak;\n+\t      case XOR:\n \t\ttmp0[i] ^= tmp1[i];\n-\t      else\n-\t\tabort ();\n+\t\tbreak;\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n \t    }\n \t   real_from_target (&r, tmp0, mode);\n \t   return CONST_DOUBLE_FROM_REAL_VALUE (r, mode);\n@@ -2142,24 +2136,22 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n \tcase VEC_SELECT:\n \t  if (!VECTOR_MODE_P (mode))\n \t    {\n-\t      if (!VECTOR_MODE_P (GET_MODE (trueop0))\n-\t\t  || (mode\n-\t\t      != GET_MODE_INNER (GET_MODE (trueop0)))\n-\t\t  || GET_CODE (trueop1) != PARALLEL\n-\t\t  || XVECLEN (trueop1, 0) != 1\n-\t\t  || GET_CODE (XVECEXP (trueop1, 0, 0)) != CONST_INT)\n-\t\tabort ();\n+\t      gcc_assert (VECTOR_MODE_P (GET_MODE (trueop0)));\n+\t      gcc_assert (mode == GET_MODE_INNER (GET_MODE (trueop0)));\n+\t      gcc_assert (GET_CODE (trueop1) == PARALLEL);\n+\t      gcc_assert (XVECLEN (trueop1, 0) == 1);\n+\t      gcc_assert (GET_CODE (XVECEXP (trueop1, 0, 0)) == CONST_INT);\n \n \t      if (GET_CODE (trueop0) == CONST_VECTOR)\n-\t\treturn CONST_VECTOR_ELT (trueop0, INTVAL (XVECEXP (trueop1, 0, 0)));\n+\t\treturn CONST_VECTOR_ELT (trueop0, INTVAL (XVECEXP\n+\t\t\t\t\t\t\t  (trueop1, 0, 0)));\n \t    }\n \t  else\n \t    {\n-\t      if (!VECTOR_MODE_P (GET_MODE (trueop0))\n-\t\t  || (GET_MODE_INNER (mode)\n-\t\t      != GET_MODE_INNER (GET_MODE (trueop0)))\n-\t\t  || GET_CODE (trueop1) != PARALLEL)\n-\t\tabort ();\n+\t      gcc_assert (VECTOR_MODE_P (GET_MODE (trueop0)));\n+\t      gcc_assert (GET_MODE_INNER (mode)\n+\t\t\t  == GET_MODE_INNER (GET_MODE (trueop0)));\n+\t      gcc_assert (GET_CODE (trueop1) == PARALLEL);\n \n \t      if (GET_CODE (trueop0) == CONST_VECTOR)\n \t\t{\n@@ -2168,15 +2160,14 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n \t\t  rtvec v = rtvec_alloc (n_elts);\n \t\t  unsigned int i;\n \n-\t\t  if (XVECLEN (trueop1, 0) != (int) n_elts)\n-\t\t    abort ();\n+\t\t  gcc_assert (XVECLEN (trueop1, 0) == (int) n_elts);\n \t\t  for (i = 0; i < n_elts; i++)\n \t\t    {\n \t\t      rtx x = XVECEXP (trueop1, 0, i);\n \n-\t\t      if (GET_CODE (x) != CONST_INT)\n-\t\t\tabort ();\n-\t\t      RTVEC_ELT (v, i) = CONST_VECTOR_ELT (trueop0, INTVAL (x));\n+\t\t      gcc_assert (GET_CODE (x) == CONST_INT);\n+\t\t      RTVEC_ELT (v, i) = CONST_VECTOR_ELT (trueop0,\n+\t\t\t\t\t\t\t   INTVAL (x));\n \t\t    }\n \n \t\t  return gen_rtx_CONST_VECTOR (mode, v);\n@@ -2192,24 +2183,21 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n \t\t\t\t\t  ? GET_MODE (trueop1)\n \t\t\t\t\t  : GET_MODE_INNER (mode));\n \n-\t    if (!VECTOR_MODE_P (mode)\n-\t\t|| (GET_MODE_SIZE (op0_mode) + GET_MODE_SIZE (op1_mode)\n-\t\t    != GET_MODE_SIZE (mode)))\n-\t      abort ();\n-\n-\t    if ((VECTOR_MODE_P (op0_mode)\n-\t\t && (GET_MODE_INNER (mode)\n-\t\t     != GET_MODE_INNER (op0_mode)))\n-\t\t|| (!VECTOR_MODE_P (op0_mode)\n-\t\t    && GET_MODE_INNER (mode) != op0_mode))\n-\t      abort ();\n-\n-\t    if ((VECTOR_MODE_P (op1_mode)\n-\t\t && (GET_MODE_INNER (mode)\n-\t\t     != GET_MODE_INNER (op1_mode)))\n-\t\t|| (!VECTOR_MODE_P (op1_mode)\n-\t\t    && GET_MODE_INNER (mode) != op1_mode))\n-\t      abort ();\n+\t    gcc_assert (VECTOR_MODE_P (mode));\n+\t    gcc_assert (GET_MODE_SIZE (op0_mode) + GET_MODE_SIZE (op1_mode)\n+\t\t\t== GET_MODE_SIZE (mode));\n+\n+\t    if (VECTOR_MODE_P (op0_mode))\n+\t      gcc_assert (GET_MODE_INNER (mode)\n+\t\t\t  == GET_MODE_INNER (op0_mode));\n+\t    else\n+\t      gcc_assert (GET_MODE_INNER (mode) == op0_mode);\n+\n+\t    if (VECTOR_MODE_P (op1_mode))\n+\t      gcc_assert (GET_MODE_INNER (mode)\n+\t\t\t  == GET_MODE_INNER (op1_mode));\n+\t    else\n+\t      gcc_assert (GET_MODE_INNER (mode) == op1_mode);\n \n \t    if ((GET_CODE (trueop0) == CONST_VECTOR\n \t\t || GET_CODE (trueop0) == CONST_INT\n@@ -2251,7 +2239,7 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n \t  return 0;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       return 0;\n@@ -2413,7 +2401,7 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n       return 0;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   val = trunc_int_for_mode (val, mode);\n@@ -2799,10 +2787,9 @@ simplify_const_relational_operation (enum rtx_code code,\n   rtx trueop0;\n   rtx trueop1;\n \n-  if (mode == VOIDmode\n-      && (GET_MODE (op0) != VOIDmode\n-\t  || GET_MODE (op1) != VOIDmode))\n-    abort ();\n+  gcc_assert (mode != VOIDmode\n+\t      || (GET_MODE (op0) == VOIDmode\n+\t\t  && GET_MODE (op1) == VOIDmode));\n \n   /* If op0 is a compare, extract the comparison arguments from it.  */\n   if (GET_CODE (op0) == COMPARE && op1 == const0_rtx)\n@@ -3101,7 +3088,7 @@ simplify_const_relational_operation (enum rtx_code code,\n     case UNORDERED:\n       return const0_rtx;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \f\n@@ -3240,10 +3227,9 @@ simplify_ternary_operation (enum rtx_code code, enum machine_mode mode,\n       break;\n \n     case VEC_MERGE:\n-      if (GET_MODE (op0) != mode\n-\t  || GET_MODE (op1) != mode\n-\t  || !VECTOR_MODE_P (mode))\n-\tabort ();\n+      gcc_assert (GET_MODE (op0) == mode);\n+      gcc_assert (GET_MODE (op1) == mode);\n+      gcc_assert (VECTOR_MODE_P (mode));\n       op2 = avoid_constant_pool_reference (op2);\n       if (GET_CODE (op2) == CONST_INT)\n \t{\n@@ -3274,7 +3260,7 @@ simplify_ternary_operation (enum rtx_code code, enum machine_mode mode,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return 0;\n@@ -3328,11 +3314,10 @@ simplify_immed_subreg (enum machine_mode outermode, rtx op,\n       elems = &op;\n       elem_bitsize = max_bitsize;\n     }\n-\n-  if (BITS_PER_UNIT % value_bit != 0)\n-    abort ();  /* Too complicated; reducing value_bit may help.  */\n-  if (elem_bitsize % BITS_PER_UNIT != 0)\n-    abort ();  /* I don't know how to handle endianness of sub-units.  */\n+  /* If this asserts, it is too complicated; reducing value_bit may help.  */\n+  gcc_assert (BITS_PER_UNIT % value_bit == 0);\n+  /* I don't know how to handle endianness of sub-units.  */\n+  gcc_assert (elem_bitsize % BITS_PER_UNIT == 0);\n   \n   for (elem = 0; elem < num_elem; elem++)\n     {\n@@ -3369,8 +3354,7 @@ simplify_immed_subreg (enum machine_mode outermode, rtx op,\n \t    {\n \t      /* If this triggers, someone should have generated a\n \t\t CONST_INT instead.  */\n-\t      if (elem_bitsize <= HOST_BITS_PER_WIDE_INT)\n-\t\tabort ();\n+\t      gcc_assert (elem_bitsize > HOST_BITS_PER_WIDE_INT);\n \n \t      for (i = 0; i < HOST_BITS_PER_WIDE_INT; i += value_bit)\n \t\t*vp++ = CONST_DOUBLE_LOW (el) >> i;\n@@ -3385,15 +3369,14 @@ simplify_immed_subreg (enum machine_mode outermode, rtx op,\n \t      for (; i < max_bitsize; i += value_bit)\n \t\t*vp++ = 0;\n \t    }\n-\t  else if (GET_MODE_CLASS (GET_MODE (el)) == MODE_FLOAT)\n+\t  else\n \t    {\n \t      long tmp[max_bitsize / 32];\n \t      int bitsize = GET_MODE_BITSIZE (GET_MODE (el));\n-\t      \n-\t      if (bitsize > elem_bitsize)\n-\t\tabort ();\n-\t      if (bitsize % value_bit != 0)\n-\t\tabort ();\n+\n+\t      gcc_assert (GET_MODE_CLASS (GET_MODE (el)) == MODE_FLOAT);\n+\t      gcc_assert (bitsize <= elem_bitsize);\n+\t      gcc_assert (bitsize % value_bit == 0);\n \n \t      real_to_target (tmp, CONST_DOUBLE_REAL_VALUE (el),\n \t\t\t      GET_MODE (el));\n@@ -3417,12 +3400,10 @@ simplify_immed_subreg (enum machine_mode outermode, rtx op,\n \t      for (; i < elem_bitsize; i += value_bit)\n \t\t*vp++ = 0;\n \t    }\n-\t  else\n-\t    abort ();\n \t  break;\n \t  \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -3442,8 +3423,7 @@ simplify_immed_subreg (enum machine_mode outermode, rtx op,\n \n   /* BYTE should still be inside OP.  (Note that BYTE is unsigned,\n      so if it's become negative it will instead be very large.)  */\n-  if (byte >= GET_MODE_SIZE (innermode))\n-    abort ();\n+  gcc_assert (byte < GET_MODE_SIZE (innermode));\n \n   /* Convert from bytes to chunks of size value_bit.  */\n   value_start = byte * (BITS_PER_UNIT / value_bit);\n@@ -3467,10 +3447,8 @@ simplify_immed_subreg (enum machine_mode outermode, rtx op,\n   outer_class = GET_MODE_CLASS (outer_submode);\n   elem_bitsize = GET_MODE_BITSIZE (outer_submode);\n \n-  if (elem_bitsize % value_bit != 0)\n-    abort ();\n-  if (elem_bitsize + value_start * value_bit > max_bitsize)\n-    abort ();\n+  gcc_assert (elem_bitsize % value_bit == 0);\n+  gcc_assert (elem_bitsize + value_start * value_bit <= max_bitsize);\n \n   for (elem = 0; elem < num_elem; elem++)\n     {\n@@ -3540,7 +3518,7 @@ simplify_immed_subreg (enum machine_mode outermode, rtx op,\n \t  break;\n \t    \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   if (VECTOR_MODE_P (outermode))\n@@ -3556,17 +3534,16 @@ simplify_subreg (enum machine_mode outermode, rtx op,\n \t\t enum machine_mode innermode, unsigned int byte)\n {\n   /* Little bit of sanity checking.  */\n-  if (innermode == VOIDmode || outermode == VOIDmode\n-      || innermode == BLKmode || outermode == BLKmode)\n-    abort ();\n+  gcc_assert (innermode != VOIDmode);\n+  gcc_assert (outermode != VOIDmode);\n+  gcc_assert (innermode != BLKmode);\n+  gcc_assert (outermode != BLKmode);\n \n-  if (GET_MODE (op) != innermode\n-      && GET_MODE (op) != VOIDmode)\n-    abort ();\n+  gcc_assert (GET_MODE (op) == innermode\n+\t      || GET_MODE (op) == VOIDmode);\n \n-  if (byte % GET_MODE_SIZE (outermode)\n-      || byte >= GET_MODE_SIZE (innermode))\n-    abort ();\n+  gcc_assert ((byte % GET_MODE_SIZE (outermode)) == 0);\n+  gcc_assert (byte < GET_MODE_SIZE (innermode));\n \n   if (outermode == innermode && !byte)\n     return op;\n@@ -3772,17 +3749,16 @@ simplify_gen_subreg (enum machine_mode outermode, rtx op,\n {\n   rtx newx;\n   /* Little bit of sanity checking.  */\n-  if (innermode == VOIDmode || outermode == VOIDmode\n-      || innermode == BLKmode || outermode == BLKmode)\n-    abort ();\n+  gcc_assert (innermode != VOIDmode);\n+  gcc_assert (outermode != VOIDmode);\n+  gcc_assert (innermode != BLKmode);\n+  gcc_assert (outermode != BLKmode);\n \n-  if (GET_MODE (op) != innermode\n-      && GET_MODE (op) != VOIDmode)\n-    abort ();\n+  gcc_assert (GET_MODE (op) == innermode\n+\t      || GET_MODE (op) == VOIDmode);\n \n-  if (byte % GET_MODE_SIZE (outermode)\n-      || byte >= GET_MODE_SIZE (innermode))\n-    abort ();\n+  gcc_assert ((byte % GET_MODE_SIZE (outermode)) == 0);\n+  gcc_assert (byte < GET_MODE_SIZE (innermode));\n \n   newx = simplify_subreg (outermode, op, innermode, byte);\n   if (newx)"}, {"sha": "662d27d55488ff32bcd11ec9d2e6779eb9604da4", "filename": "gcc/sreal.c", "status": "modified", "additions": 13, "deletions": 30, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fsreal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fsreal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsreal.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -94,17 +94,12 @@ copy (sreal *r, sreal *a)\n static inline void\n shift_right (sreal *x, int s)\n {\n-#ifdef ENABLE_CHECKING\n-  if (s <= 0 || s > SREAL_BITS)\n-    abort ();\n-  if (x->exp + s > SREAL_MAX_EXP)\n-    {\n-      /* Exponent should never be so large because shift_right is used only by\n-\t sreal_add and sreal_sub ant thus the number cannot be shifted out from\n-\t exponent range.  */\n-      abort ();\n-    }\n-#endif\n+  gcc_assert (s > 0);\n+  gcc_assert (s <= SREAL_BITS);\n+  /* Exponent should never be so large because shift_right is used only by\n+     sreal_add and sreal_sub ant thus the number cannot be shifted out from\n+     exponent range.  */\n+  gcc_assert (x->exp + s <= SREAL_MAX_EXP);\n \n   x->exp += s;\n \n@@ -401,10 +396,7 @@ sreal_sub (sreal *r, sreal *a, sreal *b)\n   sreal tmp;\n   sreal *bb;\n \n-  if (sreal_compare (a, b) < 0)\n-    {\n-      abort ();\n-    }\n+  gcc_assert (sreal_compare (a, b) >= 0);\n \n   dexp = a->exp - b->exp;\n   r->exp = a->exp;\n@@ -509,11 +501,8 @@ sreal_div (sreal *r, sreal *a, sreal *b)\n #if SREAL_PART_BITS < 32\n   unsigned HOST_WIDE_INT tmp, tmp1, tmp2;\n \n-  if (b->sig_hi < SREAL_MIN_SIG)\n-    {\n-      abort ();\n-    }\n-  else if (a->sig_hi < SREAL_MIN_SIG)\n+  gcc_assert (b->sig_hi >= SREAL_MIN_SIG);\n+  if (a->sig_hi < SREAL_MIN_SIG)\n     {\n       r->sig_hi = 0;\n       r->sig_lo = 0;\n@@ -546,16 +535,10 @@ sreal_div (sreal *r, sreal *a, sreal *b)\n       normalize (r);\n     }\n #else\n-  if (b->sig == 0)\n-    {\n-      abort ();\n-    }\n-  else\n-    {\n-      r->sig = (a->sig << SREAL_PART_BITS) / b->sig;\n-      r->exp = a->exp - b->exp - SREAL_PART_BITS;\n-      normalize (r);\n-    }\n+  gcc_assert (b->sig != 0);\n+  r->sig = (a->sig << SREAL_PART_BITS) / b->sig;\n+  r->exp = a->exp - b->exp - SREAL_PART_BITS;\n+  normalize (r);\n #endif\n   return r;\n }"}, {"sha": "dc2ca0d3b1b27e96d74c268f2add5861234591fb", "filename": "gcc/stmt.c", "status": "modified", "additions": 45, "deletions": 57, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -132,8 +132,7 @@ static struct case_node *add_case_node (struct case_node *, tree, tree, tree);\n rtx\n label_rtx (tree label)\n {\n-  if (TREE_CODE (label) != LABEL_DECL)\n-    abort ();\n+  gcc_assert (TREE_CODE (label) == LABEL_DECL);\n \n   if (!DECL_RTL_SET_P (label))\n     {\n@@ -155,8 +154,7 @@ force_label_rtx (tree label)\n   tree function = decl_function_context (label);\n   struct function *p;\n \n-  if (!function)\n-    abort ();\n+  gcc_assert (function);\n \n   if (function != current_function_decl)\n     p = find_function_data (function);\n@@ -241,8 +239,7 @@ expand_goto (tree label)\n   /* Check for a nonlocal goto to a containing function.  Should have\n      gotten translated to __builtin_nonlocal_goto.  */\n   tree context = decl_function_context (label);\n-  if (context != 0 && context != current_function_decl)\n-    abort ();\n+  gcc_assert (!context || context == current_function_decl);\n #endif\n \n   emit_jump (label_rtx (label));\n@@ -785,11 +782,12 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n       bool allows_reg;\n       bool allows_mem;\n       rtx op;\n+      bool ok;\n \n-      if (!parse_output_constraint (&constraints[i], i, ninputs,\n+      ok = parse_output_constraint (&constraints[i], i, ninputs,\n \t\t\t\t    noutputs, &allows_mem, &allows_reg,\n-\t\t\t\t    &is_inout))\n-\tabort ();\n+\t\t\t\t    &is_inout);\n+      gcc_assert (ok);\n \n       /* If an output operand is not a decl or indirect ref and our constraint\n \t allows a register, make a temporary to act as an intermediate.\n@@ -866,11 +864,12 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n       const char *constraint;\n       tree val, type;\n       rtx op;\n+      bool ok;\n \n       constraint = constraints[i + noutputs];\n-      if (! parse_input_constraint (&constraint, i, ninputs, noutputs, ninout,\n-\t\t\t\t    constraints, &allows_mem, &allows_reg))\n-\tabort ();\n+      ok = parse_input_constraint (&constraint, i, ninputs, noutputs, ninout,\n+\t\t\t\t   constraints, &allows_mem, &allows_reg);\n+      gcc_assert (ok);\n \n       generating_concat_p = 0;\n \n@@ -1330,8 +1329,7 @@ resolve_operand_name_1 (char *p, tree outputs, tree inputs)\n   p = strchr (p, '\\0');\n \n   /* Verify the no extra buffer space assumption.  */\n-  if (p > q)\n-    abort ();\n+  gcc_assert (p <= q);\n \n   /* Shift the rest of the buffer down to fill the gap.  */\n   memmove (p, q + 1, strlen (q + 1) + 1);\n@@ -1733,9 +1731,8 @@ expand_return (tree retval)\n \t    if (GET_MODE_SIZE (tmpmode) >= bytes)\n \t      break;\n \n-\t  /* No suitable mode found.  */\n-\t  if (tmpmode == VOIDmode)\n-\t    abort ();\n+\t  /* A suitable mode should have been found.  */\n+\t  gcc_assert (tmpmode != VOIDmode);\n \n \t  PUT_MODE (result_rtl, tmpmode);\n \t}\n@@ -1974,9 +1971,8 @@ expand_decl (tree decl)\n \t to the proper address.  */\n       if (DECL_RTL_SET_P (decl))\n \t{\n-\t  if (!MEM_P (DECL_RTL (decl))\n-\t      || !REG_P (XEXP (DECL_RTL (decl), 0)))\n-\t    abort ();\n+\t  gcc_assert (MEM_P (DECL_RTL (decl)));\n+\t  gcc_assert (REG_P (XEXP (DECL_RTL (decl), 0)));\n \t  oldaddr = XEXP (DECL_RTL (decl), 0);\n \t}\n \n@@ -2122,6 +2118,7 @@ expand_anon_union_decl (tree decl, tree cleanup ATTRIBUTE_UNUSED,\n     {\n       tree decl_elt = TREE_VALUE (t);\n       enum machine_mode mode = TYPE_MODE (TREE_TYPE (decl_elt));\n+      rtx decl_rtl;\n \n       /* If any of the elements are addressable, so is the entire\n \t union.  */\n@@ -2139,24 +2136,18 @@ expand_anon_union_decl (tree decl, tree cleanup ATTRIBUTE_UNUSED,\n \tDECL_MODE (decl_elt) = mode\n \t  = mode_for_size_tree (DECL_SIZE (decl_elt), MODE_INT, 1);\n \n-      /* (SUBREG (MEM ...)) at RTL generation time is invalid, so we\n-         instead create a new MEM rtx with the proper mode.  */\n-      if (MEM_P (x))\n+      if (mode == GET_MODE (x))\n+\tdecl_rtl = x;\n+      else if (MEM_P (x))\n+        /* (SUBREG (MEM ...)) at RTL generation time is invalid, so we\n+           instead create a new MEM rtx with the proper mode.  */\n+\tdecl_rtl = adjust_address_nv (x, mode, 0);\n+      else\n \t{\n-\t  if (mode == GET_MODE (x))\n-\t    SET_DECL_RTL (decl_elt, x);\n-\t  else\n-\t    SET_DECL_RTL (decl_elt, adjust_address_nv (x, mode, 0));\n+\t  gcc_assert (REG_P (x));\n+\t  decl_rtl = gen_lowpart_SUBREG (mode, x);\n \t}\n-      else if (REG_P (x))\n-\t{\n-\t  if (mode == GET_MODE (x))\n-\t    SET_DECL_RTL (decl_elt, x);\n-\t  else\n-\t    SET_DECL_RTL (decl_elt, gen_lowpart_SUBREG (mode, x));\n-\t}\n-      else\n-\tabort ();\n+      SET_DECL_RTL (decl_elt, decl_rtl);\n     }\n }\n \f\n@@ -2280,10 +2271,9 @@ emit_case_bit_tests (tree index_type, tree index_expr, tree minval,\n \n       if (i == count)\n \t{\n-\t  if (count >= MAX_CASE_BIT_TESTS)\n-\t    abort ();\n-          test[i].hi = 0;\n-          test[i].lo = 0;\n+\t  gcc_assert (count < MAX_CASE_BIT_TESTS);\n+\t  test[i].hi = 0;\n+\t  test[i].lo = 0;\n \t  test[i].label = label;\n \t  test[i].bits = 1;\n \t  count++;\n@@ -2378,8 +2368,8 @@ expand_case (tree exp)\n \n   /* The switch body is lowered in gimplify.c, we should never have\n      switches with a non-NULL SWITCH_BODY here.  */\n-  if (SWITCH_BODY (exp) || !SWITCH_LABELS (exp))\n-    abort ();\n+  gcc_assert (!SWITCH_BODY (exp));\n+  gcc_assert (SWITCH_LABELS (exp));\n \n   for (i = TREE_VEC_LENGTH (vec); --i >= 0; )\n     {\n@@ -2388,15 +2378,12 @@ expand_case (tree exp)\n       /* Handle default labels specially.  */\n       if (!CASE_HIGH (elt) && !CASE_LOW (elt))\n \t{\n-#ifdef ENABLE_CHECKING\n-          if (default_label_decl != 0)\n-            abort ();\n-#endif\n-          default_label_decl = CASE_LABEL (elt);\n+\t  gcc_assert (!default_label_decl);\n+\t  default_label_decl = CASE_LABEL (elt);\n         }\n       else\n         case_list = add_case_node (case_list, CASE_LOW (elt), CASE_HIGH (elt),\n-\t\t                   CASE_LABEL (elt));\n+\t\t\t\t   CASE_LABEL (elt));\n     }\n \n   do_pending_stack_adjust ();\n@@ -2411,6 +2398,8 @@ expand_case (tree exp)\n   /* An ERROR_MARK occurs for various reasons including invalid data type.  */\n   if (index_type != error_mark_node)\n     {\n+      int fail;\n+\n       /* If we don't have a default-label, create one here,\n \t after the body of the switch.  */\n       if (default_label_decl == 0)\n@@ -2431,10 +2420,8 @@ expand_case (tree exp)\n       for (n = case_list; n; n = n->right)\n \t{\n \t  /* Check low and high label values are integers.  */\n-\t  if (TREE_CODE (n->low) != INTEGER_CST)\n-\t    abort ();\n-\t  if (TREE_CODE (n->high) != INTEGER_CST)\n-\t    abort ();\n+\t  gcc_assert (TREE_CODE (n->low) == INTEGER_CST);\n+\t  gcc_assert (TREE_CODE (n->high) == INTEGER_CST);\n \n \t  n->low = convert (index_type, n->low);\n \t  n->high = convert (index_type, n->high);\n@@ -2605,6 +2592,7 @@ expand_case (tree exp)\n \t  if (! try_casesi (index_type, index_expr, minval, range,\n \t\t\t    table_label, default_label))\n \t    {\n+\t      bool ok;\n \t      index_type = integer_type_node;\n \n \t      /* Index jumptables from zero for suitable values of\n@@ -2617,9 +2605,9 @@ expand_case (tree exp)\n \t\t  range = maxval;\n \t\t}\n \n-\t      if (! try_tablejump (index_type, index_expr, minval, range,\n-\t\t\t\t   table_label, default_label))\n-\t\tabort ();\n+\t      ok = try_tablejump (index_type, index_expr, minval, range,\n+\t\t\t\t  table_label, default_label);\n+\t      gcc_assert (ok);\n \t    }\n \n \t  /* Get table of labels to jump to, in order of case index.  */\n@@ -2675,8 +2663,8 @@ expand_case (tree exp)\n \n       before_case = NEXT_INSN (before_case);\n       end = get_last_insn ();\n-      if (squeeze_notes (&before_case, &end))\n-\tabort ();\n+      fail = squeeze_notes (&before_case, &end);\n+      gcc_assert (!fail);\n       reorder_insns (before_case, end, start);\n     }\n "}, {"sha": "12d6d484bc3ee0a8d6d38e86db6c464707718ba0", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41374e13ac15863e80fff7c4b8731ab34b1921f9/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=41374e13ac15863e80fff7c4b8731ab34b1921f9", "patch": "@@ -108,9 +108,7 @@ put_pending_size (tree expr)\n void\n put_pending_sizes (tree chain)\n {\n-  if (pending_sizes)\n-    abort ();\n-\n+  gcc_assert (!pending_sizes);\n   pending_sizes = chain;\n }\n \n@@ -220,7 +218,7 @@ smallest_mode_for_size (unsigned int size, enum mode_class class)\n     if (GET_MODE_PRECISION (mode) >= size)\n       return mode;\n \n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Find an integer mode of the exact same size, or BLKmode on failure.  */\n@@ -250,7 +248,7 @@ int_mode_for_mode (enum machine_mode mode)\n \n     case MODE_CC:\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return mode;\n@@ -302,10 +300,10 @@ layout_decl (tree decl, unsigned int known_align)\n \n   if (code == CONST_DECL)\n     return;\n-  else if (code != VAR_DECL && code != PARM_DECL && code != RESULT_DECL\n-\t   && code != TYPE_DECL && code != FIELD_DECL)\n-    abort ();\n-\n+  \n+  gcc_assert (code == VAR_DECL || code == PARM_DECL || code == RESULT_DECL\n+\t      || code == TYPE_DECL ||code == FIELD_DECL);\n+  \n   rtl = DECL_RTL_IF_SET (decl);\n \n   if (type == error_mark_node)\n@@ -1477,8 +1475,7 @@ finish_builtin_struct (tree type, const char *name, tree fields,\n void\n layout_type (tree type)\n {\n-  if (type == 0)\n-    abort ();\n+  gcc_assert (type);\n \n   if (type == error_mark_node)\n     return;\n@@ -1492,7 +1489,7 @@ layout_type (tree type)\n     case LANG_TYPE:\n       /* This kind of type is the responsibility\n \t of the language-specific code.  */\n-      abort ();\n+      gcc_unreachable ();\n \n     case BOOLEAN_TYPE:  /* Used for Java, Pascal, and Chill.  */\n       if (TYPE_PRECISION (type) == 0)\n@@ -1536,8 +1533,7 @@ layout_type (tree type)\n \ttree nunits_tree = build_int_cst (NULL_TREE, nunits);\n \ttree innertype = TREE_TYPE (type);\n \n-\tif (nunits & (nunits - 1))\n-\t  abort ();\n+\tgcc_assert (!(nunits & (nunits - 1)));\n \n \t/* Find an appropriate mode for the vector type.  */\n \tif (TYPE_MODE (type) == VOIDmode)\n@@ -1758,33 +1754,37 @@ layout_type (tree type)\n       break;\n \n     case SET_TYPE:  /* Used by Chill and Pascal.  */\n-      if (TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) != INTEGER_CST\n-\t  || TREE_CODE (TYPE_MIN_VALUE (TYPE_DOMAIN (type))) != INTEGER_CST)\n-\tabort ();\n-      else\n-\t{\n+      {\n+\tunsigned int alignment;\n+\tHOST_WIDE_INT size_in_bits;\n+\tHOST_WIDE_INT rounded_size;\n+\n+\tgcc_assert (TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))\n+\t\t    == INTEGER_CST);\n+\tgcc_assert (TREE_CODE (TYPE_MIN_VALUE (TYPE_DOMAIN (type)))\n+\t\t    == INTEGER_CST);\n+\n #ifndef SET_WORD_SIZE\n #define SET_WORD_SIZE BITS_PER_WORD\n #endif\n-\t  unsigned int alignment\n-\t    = set_alignment ? set_alignment : SET_WORD_SIZE;\n-\t  HOST_WIDE_INT size_in_bits\n-\t    = (tree_low_cst (TYPE_MAX_VALUE (TYPE_DOMAIN (type)), 0)\n-\t       - tree_low_cst (TYPE_MIN_VALUE (TYPE_DOMAIN (type)), 0) + 1);\n-\t  HOST_WIDE_INT rounded_size\n-\t    = ((size_in_bits + alignment - 1) / alignment) * alignment;\n-\n-\t  if (rounded_size > (int) alignment)\n-\t    TYPE_MODE (type) = BLKmode;\n-\t  else\n-\t    TYPE_MODE (type) = mode_for_size (alignment, MODE_INT, 1);\n-\n-\t  TYPE_SIZE (type) = bitsize_int (rounded_size);\n-\t  TYPE_SIZE_UNIT (type) = size_int (rounded_size / BITS_PER_UNIT);\n-\t  TYPE_ALIGN (type) = alignment;\n-\t  TYPE_USER_ALIGN (type) = 0;\n-\t  TYPE_PRECISION (type) = size_in_bits;\n-\t}\n+\talignment = set_alignment ? set_alignment : SET_WORD_SIZE;\n+\tsize_in_bits\n+\t  = (tree_low_cst (TYPE_MAX_VALUE (TYPE_DOMAIN (type)), 0)\n+\t     - tree_low_cst (TYPE_MIN_VALUE (TYPE_DOMAIN (type)), 0) + 1);\n+\trounded_size\n+\t  = ((size_in_bits + alignment - 1) / alignment) * alignment;\n+\n+\tif (rounded_size > (int) alignment)\n+\t  TYPE_MODE (type) = BLKmode;\n+\telse\n+\t  TYPE_MODE (type) = mode_for_size (alignment, MODE_INT, 1);\n+\n+\tTYPE_SIZE (type) = bitsize_int (rounded_size);\n+\tTYPE_SIZE_UNIT (type) = size_int (rounded_size / BITS_PER_UNIT);\n+\tTYPE_ALIGN (type) = alignment;\n+\tTYPE_USER_ALIGN (type) = 0;\n+\tTYPE_PRECISION (type) = size_in_bits;\n+      }\n       break;\n \n     case FILE_TYPE:\n@@ -1796,7 +1796,7 @@ layout_type (tree type)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* Compute the final TYPE_SIZE, TYPE_ALIGN, etc. for TYPE.  For\n@@ -1886,8 +1886,7 @@ set_sizetype (tree type)\n \t\t       2 * HOST_BITS_PER_WIDE_INT);\n   tree t;\n \n-  if (TYPE_UNSIGNED (type) != TYPE_UNSIGNED (sizetype))\n-    abort ();\n+  gcc_assert (TYPE_UNSIGNED (type) == TYPE_UNSIGNED (sizetype));\n \n   t = build_distinct_type_copy (type);\n   /* We do want to use sizetype's cache, as we will be replacing that\n@@ -2109,8 +2108,7 @@ get_mode_bounds (enum machine_mode mode, int sign,\n   unsigned size = GET_MODE_BITSIZE (mode);\n   unsigned HOST_WIDE_INT min_val, max_val;\n \n-  if (size > HOST_BITS_PER_WIDE_INT)\n-    abort ();\n+  gcc_assert (size <= HOST_BITS_PER_WIDE_INT);\n \n   if (sign)\n     {"}]}