{"sha": "62b8a44e2617685f1094b108869f2c71f38f33af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJiOGE0NGUyNjE3Njg1ZjEwOTRiMTA4ODY5ZjJjNzFmMzhmMzNhZg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-01-06T18:40:22Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-01-06T18:40:22Z"}, "message": "re PR c++/9109 (parse ambiguity)\n\ncp:\n\tPR c++/9109\n\t* parser.c (cp_parser_declarator_kind): New enum.\n\t(cp_parser_declarator): Adjust.\n\t(cp_parser_direct_declarator): Adjust. Allow for either named or\n\tabstract declarator. Prefer abstract, if possible. Allow\n\tparenthesized function name.\n\t(cp_parser_condition): Adjust cp_parser_declarator call.\n\t(cp_parser_explicit_instantiation): Likewise.\n\t(cp_parser_init_declarator): Likewise.\n\t(cp_parser_type_id): Likewise.\n\t(cp_parser_function_definition): Likewise.\n\t(cp_parser_member_declaration): Likewise.\n\t(cp_parser_parameter_declaration): Use cp_parser_declarator to do\n\tthe tentative parsing.\n\t(cp_parser_exception_declaration): Likewise.\ntestsuite:\n\t* g++.dg/parse/ambig1.C: New test.\n\t* g++.dg/parse/defarg2.C: New test.\n\nFrom-SVN: r60944", "tree": {"sha": "649fe3bdf8170a387fdf89fd878e30bb2641d027", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/649fe3bdf8170a387fdf89fd878e30bb2641d027"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62b8a44e2617685f1094b108869f2c71f38f33af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62b8a44e2617685f1094b108869f2c71f38f33af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62b8a44e2617685f1094b108869f2c71f38f33af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62b8a44e2617685f1094b108869f2c71f38f33af/comments", "author": null, "committer": null, "parents": [{"sha": "e914a571723bd02ba7236eacbbc97a4c5d80bce0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e914a571723bd02ba7236eacbbc97a4c5d80bce0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e914a571723bd02ba7236eacbbc97a4c5d80bce0"}], "stats": {"total": 541, "additions": 297, "deletions": 244}, "files": [{"sha": "d4284a5f5d3870b7eb19c2e28a558c12636894d9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62b8a44e2617685f1094b108869f2c71f38f33af/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62b8a44e2617685f1094b108869f2c71f38f33af/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=62b8a44e2617685f1094b108869f2c71f38f33af", "patch": "@@ -1,3 +1,21 @@\n+2003-01-06  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/9109\n+\t* parser.c (cp_parser_declarator_kind): New enum.\n+\t(cp_parser_declarator): Adjust.\n+\t(cp_parser_direct_declarator): Adjust. Allow for either named or\n+\tabstract declarator. Prefer abstract, if possible. Allow\n+\tparenthesized function name.\n+\t(cp_parser_condition): Adjust cp_parser_declarator call.\n+\t(cp_parser_explicit_instantiation): Likewise.\n+\t(cp_parser_init_declarator): Likewise.\n+\t(cp_parser_type_id): Likewise.\n+\t(cp_parser_function_definition): Likewise.\n+\t(cp_parser_member_declaration): Likewise.\n+\t(cp_parser_parameter_declaration): Use cp_parser_declarator to do\n+\tthe tentative parsing.\n+\t(cp_parser_exception_declaration): Likewise.\n+\n 2003-01-05  Mark Mitchell  <mark@codesourcery.com>\n \n \t* parser.c (cp_parser_template_parameter): Adjust call to"}, {"sha": "d1c2c30fbec86abad78e8ea43860e8327b2dec15", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 253, "deletions": 244, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62b8a44e2617685f1094b108869f2c71f38f33af/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62b8a44e2617685f1094b108869f2c71f38f33af/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=62b8a44e2617685f1094b108869f2c71f38f33af", "patch": "@@ -1124,6 +1124,18 @@ typedef enum cp_parser_id_kind\n   CP_PARSER_ID_KIND_QUALIFIED\n } cp_parser_id_kind;\n \n+/* The different kinds of declarators we want to parse.  */\n+\n+typedef enum cp_parser_declarator_kind\n+{\n+  /* We want an abstract declartor. */\n+  CP_PARSER_DECLARATOR_ABSTRACT,\n+  /* We want a named declarator.  */\n+  CP_PARSER_DECLARATOR_NAMED,\n+  /* We don't mind.  */\n+  CP_PARSER_DECLARATOR_EITHER\n+} cp_parser_declarator_kind;\n+\n /* A mapping from a token type to a corresponding tree node type.  */\n \n typedef struct cp_parser_token_tree_map_node\n@@ -1540,9 +1552,9 @@ static void cp_parser_linkage_specification\n static tree cp_parser_init_declarator\n   PARAMS ((cp_parser *, tree, tree, tree, bool, bool, bool *));\n static tree cp_parser_declarator\n-  PARAMS ((cp_parser *, bool, bool *));\n+  PARAMS ((cp_parser *, cp_parser_declarator_kind, bool *));\n static tree cp_parser_direct_declarator\n-  PARAMS ((cp_parser *, bool, bool *));\n+  PARAMS ((cp_parser *, cp_parser_declarator_kind, bool *));\n static enum tree_code cp_parser_ptr_operator\n   PARAMS ((cp_parser *, tree *, tree *));\n static tree cp_parser_cv_qualifier_seq_opt\n@@ -6123,8 +6135,7 @@ cp_parser_condition (parser)\n       tree initializer = NULL_TREE;\n       \n       /* Parse the declarator.  */\n-      declarator = cp_parser_declarator (parser, \n-\t\t\t\t\t /*abstract_p=*/false,\n+      declarator = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n \t\t\t\t\t /*ctor_dtor_or_conv_p=*/NULL);\n       /* Parse the attributes.  */\n       attributes = cp_parser_attributes_opt (parser);\n@@ -8506,8 +8517,7 @@ cp_parser_explicit_instantiation (parser)\n \n       /* Parse the declarator.  */\n       declarator \n-\t= cp_parser_declarator (parser, \n-\t\t\t\t/*abstract_p=*/false, \n+\t= cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n \t\t\t\t/*ctor_dtor_or_conv_p=*/NULL);\n       decl = grokdeclarator (declarator, decl_specifiers, \n \t\t\t     NORMAL, 0, NULL);\n@@ -9720,8 +9730,7 @@ cp_parser_init_declarator (parser,\n   cp_parser_start_deferring_access_checks (parser);\n   /* Parse the declarator.  */\n   declarator \n-    = cp_parser_declarator (parser,\n-\t\t\t    /*abstract_p=*/false,\n+    = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n \t\t\t    &ctor_dtor_or_conv_p);\n   /* Gather up the deferred checks.  */\n   declarator_access_checks \n@@ -10020,9 +10029,9 @@ cp_parser_init_declarator (parser,\n    expression, not a declaration.)  */\n \n static tree\n-cp_parser_declarator (parser, abstract_p, ctor_dtor_or_conv_p)\n+cp_parser_declarator (parser, dcl_kind, ctor_dtor_or_conv_p)\n      cp_parser *parser;\n-     bool abstract_p;\n+     cp_parser_declarator_kind dcl_kind;\n      bool *ctor_dtor_or_conv_p;\n {\n   cp_token *token;\n@@ -10054,16 +10063,17 @@ cp_parser_declarator (parser, abstract_p, ctor_dtor_or_conv_p)\n     {\n       /* The dependent declarator is optional if we are parsing an\n \t abstract-declarator.  */\n-      if (abstract_p)\n+      if (dcl_kind != CP_PARSER_DECLARATOR_NAMED)\n \tcp_parser_parse_tentatively (parser);\n \n       /* Parse the dependent declarator.  */\n-      declarator = cp_parser_declarator (parser, abstract_p,\n+      declarator = cp_parser_declarator (parser, dcl_kind,\n \t\t\t\t\t /*ctor_dtor_or_conv_p=*/NULL);\n \n       /* If we are parsing an abstract-declarator, we must handle the\n \t case where the dependent declarator is absent.  */\n-      if (abstract_p && !cp_parser_parse_definitely (parser))\n+      if (dcl_kind != CP_PARSER_DECLARATOR_NAMED\n+\t  && !cp_parser_parse_definitely (parser))\n \tdeclarator = NULL_TREE;\n \t\n       /* Build the representation of the ptr-operator.  */\n@@ -10080,7 +10090,7 @@ cp_parser_declarator (parser, abstract_p, ctor_dtor_or_conv_p)\n   /* Everything else is a direct-declarator.  */\n   else\n     declarator = cp_parser_direct_declarator (parser, \n-\t\t\t\t\t      abstract_p,\n+\t\t\t\t\t      dcl_kind,\n \t\t\t\t\t      ctor_dtor_or_conv_p);\n \n   if (attributes && declarator != error_mark_node)\n@@ -10107,9 +10117,13 @@ cp_parser_declarator (parser, abstract_p, ctor_dtor_or_conv_p)\n      direct-abstract-declarator [opt] [ constant-expression [opt] ]\n      ( abstract-declarator )\n \n-   Returns a representation of the declarator.  ABSTRACT_P is TRUE if\n-   we are parsing a direct-abstract-declarator; FALSE if we are\n-   parsing a direct-declarator.  CTOR_DTOR_OR_CONV_P is as for \n+   Returns a representation of the declarator.  DCL_KIND is\n+   CP_PARSER_DECLARATOR_ABSTRACT, if we are parsing a\n+   direct-abstract-declarator.  It is CP_PARSER_DECLARATOR_NAMED, if\n+   we are parsing a direct-declarator.  It is\n+   CP_PARSER_DECLARATOR_EITHER, if we can accept either - in the case\n+   of ambiguity we prefer an abstract declarator, as per\n+   [dcl.ambig.res].  CTOR_DTOR_OR_CONV_P is as for\n    cp_parser_declarator.\n \n    For the declarator-id production, the representation is as for an\n@@ -10122,164 +10136,147 @@ cp_parser_declarator (parser, abstract_p, ctor_dtor_or_conv_p)\n    indicating the size of the array is the second operand.  */\n \n static tree\n-cp_parser_direct_declarator (parser, abstract_p, ctor_dtor_or_conv_p)\n+cp_parser_direct_declarator (parser, dcl_kind, ctor_dtor_or_conv_p)\n      cp_parser *parser;\n-     bool abstract_p;\n+     cp_parser_declarator_kind dcl_kind;\n      bool *ctor_dtor_or_conv_p;\n {\n   cp_token *token;\n-  tree declarator;\n+  tree declarator = NULL_TREE;\n   tree scope = NULL_TREE;\n   bool saved_default_arg_ok_p = parser->default_arg_ok_p;\n   bool saved_in_declarator_p = parser->in_declarator_p;\n-\n-  /* Peek at the next token.  */\n-  token = cp_lexer_peek_token (parser->lexer);\n-  /* Find the initial direct-declarator.  It might be a parenthesized\n-     declarator.  */\n-  if (token->type == CPP_OPEN_PAREN)\n-    {\n-      bool error_p;\n-\n-      /* For an abstract declarator we do not know whether we are\n-\t looking at the beginning of a parameter-declaration-clause,\n-\t or at a parenthesized abstract declarator.  For example, if\n-\t we see `(int)', we are looking at a\n-\t parameter-declaration-clause, and the\n-\t direct-abstract-declarator has been omitted.  If, on the\n-\t other hand we are looking at `((*))' then we are looking at a\n-\t parenthesized abstract-declarator.  There is no easy way to\n-\t tell which situation we are in.  */\n-      if (abstract_p)\n-\tcp_parser_parse_tentatively (parser);\n-\n-      /* Consume the `('.  */\n-      cp_lexer_consume_token (parser->lexer);\n-      /* Parse the nested declarator.  */\n-      declarator \n-\t= cp_parser_declarator (parser, abstract_p, ctor_dtor_or_conv_p);\n-      /* Expect a `)'.  */\n-      error_p = !cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n-\n-      /* If parsing a parenthesized abstract declarator didn't work,\n-\t try a parameter-declaration-clause.  */\n-      if (abstract_p && !cp_parser_parse_definitely (parser))\n-\tdeclarator = NULL_TREE;\n-      /* If we were not parsing an abstract declarator, but failed to\n-\t find a satisfactory nested declarator, then an error has\n-\t occurred.  */\n-      else if (!abstract_p \n-\t       && (declarator == error_mark_node || error_p))\n-\treturn error_mark_node;\n-      /* Default args cannot appear in an abstract decl.  */\n-      parser->default_arg_ok_p = false;\n-    }\n-  /* Otherwise, for a non-abstract declarator, there should be a\n-     declarator-id.  */\n-  else if (!abstract_p)\n+  bool first = true;\n+  \n+  while (true)\n     {\n-      declarator = cp_parser_declarator_id (parser);\n-      \n-      if (TREE_CODE (declarator) == SCOPE_REF)\n+      /* Peek at the next token.  */\n+      token = cp_lexer_peek_token (parser->lexer);\n+      if (token->type == CPP_OPEN_PAREN)\n \t{\n-\t  scope = TREE_OPERAND (declarator, 0);\n-\t  \n-\t  /* In the declaration of a member of a template class\n-\t     outside of the class itself, the SCOPE will sometimes be\n-\t     a TYPENAME_TYPE.  For example, given:\n+\t  /* This is either a parameter-declaration-clause, or a\n+  \t     parenthesized declarator. When we know we are parsing a\n+  \t     named declaratory, it must be a paranthesized declarator\n+  \t     if FIRST is true. For instance, `(int)' is a\n+  \t     parameter-declaration-clause, with an omitted\n+  \t     direct-abstract-declarator. But `((*))', is a\n+  \t     parenthesized abstract declarator. Finally, when T is a\n+  \t     template parameter `(T)' is a\n+  \t     paremeter-declaration-clause, and not a parenthesized\n+  \t     named declarator.\n \t     \n-               template <typename T>\n-\t       int S<T>::R::i = 3;\n-\n-             the SCOPE will be a TYPENAME_TYPE for `S<T>::R'.  In this\n-\t     context, we must resolve S<T>::R to an ordinary type,\n-\t     rather than a typename type.\n-\n-\t     The reason we normally avoid resolving TYPENAME_TYPEs is\n-\t     that a specialization of `S' might render `S<T>::R' not a\n-\t     type.  However, if `S' is specialized, then this `i' will\n-\t     not be used, so there is no harm in resolving the types\n-\t     here.  */\n-\t  if (TREE_CODE (scope) == TYPENAME_TYPE)\n-\t    {\n-\t      /* Resolve the TYPENAME_TYPE.  */\n-\t      scope = cp_parser_resolve_typename_type (parser, scope);\n-\t      /* If that failed, the declarator is invalid.  */\n-\t      if (scope == error_mark_node)\n-\t\treturn error_mark_node;\n-\t      /* Build a new DECLARATOR.  */\n-\t      declarator = build_nt (SCOPE_REF, \n-\t\t\t\t     scope,\n-\t\t\t\t     TREE_OPERAND (declarator, 1));\n-\t    }\n-\t}\n-      else if (TREE_CODE (declarator) != IDENTIFIER_NODE)\n-\t/* Default args can only appear for a function decl.  */\n-\tparser->default_arg_ok_p = false;\n-      \n-      /* Check to see whether the declarator-id names a constructor, \n-\t destructor, or conversion.  */\n-      if (ctor_dtor_or_conv_p \n-\t  && ((TREE_CODE (declarator) == SCOPE_REF \n-\t       && CLASS_TYPE_P (TREE_OPERAND (declarator, 0)))\n-\t      || (TREE_CODE (declarator) != SCOPE_REF\n-\t\t  && at_class_scope_p ())))\n-\t{\n-\t  tree unqualified_name;\n-\t  tree class_type;\n+\t     We first try and parse a parameter-declaration-clause,\n+\t     and then try a nested declarator (if FIRST is true).\n \n-\t  /* Get the unqualified part of the name.  */\n-\t  if (TREE_CODE (declarator) == SCOPE_REF)\n-\t    {\n-\t      class_type = TREE_OPERAND (declarator, 0);\n-\t      unqualified_name = TREE_OPERAND (declarator, 1);\n-\t    }\n-\t  else\n+\t     It is not an error for it not to be a\n+\t     parameter-declaration-clause, even when FIRST is\n+\t     false. Consider,\n+\n+\t       int i (int);\n+\t       int i (3);\n+\n+\t     The first is the declaration of a function while the\n+\t     second is a the definition of a variable, including its\n+\t     initializer.\n+\n+\t     Having seen only the parenthesis, we cannot know which of\n+\t     these two alternatives should be selected.  Even more\n+\t     complex are examples like:\n+\n+               int i (int (a));\n+\t       int i (int (3));\n+\n+\t     The former is a function-declaration; the latter is a\n+\t     variable initialization.  \n+\n+\t     Thus again, we try a parameter-declation-clause, and if\n+\t     that fails, we back out and return.  */\n+\n+\t  if (!first || dcl_kind != CP_PARSER_DECLARATOR_NAMED)\n \t    {\n-\t      class_type = current_class_type;\n-\t      unqualified_name = declarator;\n-\t    }\n+\t      tree params;\n+\t      \n+\t      cp_parser_parse_tentatively (parser);\n+\n+\t      /* Consume the `('.  */\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      if (first)\n+\t\t{\n+\t\t  /* If this is going to be an abstract declarator, we're\n+\t\t     in a declarator and we can't have default args.  */\n+\t\t  parser->default_arg_ok_p = false;\n+\t\t  parser->in_declarator_p = true;\n+\t\t}\n+\t  \n+\t      /* Parse the parameter-declaration-clause.  */\n+\t      params = cp_parser_parameter_declaration_clause (parser);\n \n-\t  /* See if it names ctor, dtor or conv.  */\n-\t  if (TREE_CODE (unqualified_name) == BIT_NOT_EXPR\n-\t      || IDENTIFIER_TYPENAME_P (unqualified_name)\n-\t      || constructor_name_p (unqualified_name, class_type))\n+\t      /* If all went well, parse the cv-qualifier-seq and the\n+\t     \t exception-specfication.  */\n+\t      if (cp_parser_parse_definitely (parser))\n+\t\t{\n+\t\t  tree cv_qualifiers;\n+\t\t  tree exception_specification;\n+\t\t  \n+\t\t  first = false;\n+\t\t  /* Consume the `)'.  */\n+\t\t  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\n+\t\t  /* Parse the cv-qualifier-seq.  */\n+\t\t  cv_qualifiers = cp_parser_cv_qualifier_seq_opt (parser);\n+\t\t  /* And the exception-specification.  */\n+\t\t  exception_specification \n+\t\t    = cp_parser_exception_specification_opt (parser);\n+\n+\t\t  /* Create the function-declarator.  */\n+\t\t  declarator = make_call_declarator (declarator,\n+\t\t\t\t\t\t     params,\n+\t\t\t\t\t\t     cv_qualifiers,\n+\t\t\t\t\t\t     exception_specification);\n+\t\t  /* Any subsequent parameter lists are to do with\n+\t \t     return type, so are not those of the declared\n+\t \t     function.  */\n+\t\t  parser->default_arg_ok_p = false;\n+\t\t  \n+\t\t  /* Repeat the main loop.  */\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t  \n+\t  /* If this is the first, we can try a parenthesized\n+\t     declarator.  */\n+\t  if (first)\n \t    {\n-\t      *ctor_dtor_or_conv_p = true;\n-\t      /* We would have cleared the default arg flag above, but\n-\t\t they are ok.  */\n \t      parser->default_arg_ok_p = saved_default_arg_ok_p;\n+\t      parser->in_declarator_p = saved_in_declarator_p;\n+\t      \n+\t      /* Consume the `('.  */\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      /* Parse the nested declarator.  */\n+\t      declarator \n+\t\t= cp_parser_declarator (parser, dcl_kind, ctor_dtor_or_conv_p);\n+\t      first = false;\n+\t      /* Expect a `)'.  */\n+\t      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+\t\tdeclarator = error_mark_node;\n+\t      if (declarator == error_mark_node)\n+\t\tbreak;\n+\t      \n+\t      goto handle_declarator;\n \t    }\n+\t  /* Otherwise, we must be done. */\n+\t  else\n+\t    break;\n \t}\n-    }\n-  /* But for an abstract declarator, the initial direct-declarator can\n-     be omitted.  */\n-  else\n-    {\n-      declarator = NULL_TREE;\n-      parser->default_arg_ok_p = false;\n-    }\n-\n-  scope = get_scope_of_declarator (declarator);\n-  if (scope)\n-    /* Any names that appear after the declarator-id for a member\n-       are looked up in the containing scope.  */\n-    push_scope (scope);\n-  else\n-    scope = NULL_TREE;\n-  parser->in_declarator_p = true;\n-\n-  /* Now, parse function-declarators and array-declarators until there\n-     are no more.  */\n-  while (true)\n-    {\n-      /* Peek at the next token.  */\n-      token = cp_lexer_peek_token (parser->lexer);\n-      /* If it's a `[', we're looking at an array-declarator.  */\n-      if (token->type == CPP_OPEN_SQUARE)\n+      else if ((!first || dcl_kind != CP_PARSER_DECLARATOR_NAMED)\n+\t       && token->type == CPP_OPEN_SQUARE)\n \t{\n+\t  /* Parse an array-declarator.  */\n \t  tree bounds;\n \n+\t  first = false;\n+\t  parser->default_arg_ok_p = false;\n+\t  parser->in_declarator_p = true;\n \t  /* Consume the `['.  */\n \t  cp_lexer_consume_token (parser->lexer);\n \t  /* Peek at the next token.  */\n@@ -10291,78 +10288,112 @@ cp_parser_direct_declarator (parser, abstract_p, ctor_dtor_or_conv_p)\n \t  else\n \t    bounds = NULL_TREE;\n \t  /* Look for the closing `]'.  */\n-\t  cp_parser_require (parser, CPP_CLOSE_SQUARE, \"`]'\");\n+\t  if (!cp_parser_require (parser, CPP_CLOSE_SQUARE, \"`]'\"))\n+\t    {\n+\t      declarator = error_mark_node;\n+\t      break;\n+\t    }\n \n \t  declarator = build_nt (ARRAY_REF, declarator, bounds);\n \t}\n-      /* If it's a `(', we're looking at a function-declarator.  */\n-      else if (token->type == CPP_OPEN_PAREN)\n+      else if (first && dcl_kind != CP_PARSER_DECLARATOR_ABSTRACT)\n \t{\n-\t  /* A function-declarator.  Or maybe not.  Consider, for\n-\t     example:\n-\n-\t       int i (int);\n-\t       int i (3);\n-\n-\t     The first is the declaration of a function while the\n-\t     second is a the definition of a variable, including its\n-\t     initializer.\n-\n-\t     Having seen only the parenthesis, we cannot know which of\n-\t     these two alternatives should be selected.  Even more\n-\t     complex are examples like:\n-\n-               int i (int (a));\n-\t       int i (int (3));\n-\n-\t     The former is a function-declaration; the latter is a\n-\t     variable initialization.  \n-\n-\t     First, we attempt to parse a parameter-declaration\n-\t     clause.  If this works, then we continue; otherwise, we\n-\t     replace the tokens consumed in the process and continue.  */\n-\t  tree params;\n-\n-\t  /* We are now parsing tentatively.  */\n-\t  cp_parser_parse_tentatively (parser);\n+\t  /* Parse a declarator_id */\n+\t  if (dcl_kind == CP_PARSER_DECLARATOR_EITHER)\n+\t    cp_parser_parse_tentatively (parser);\n+\t  declarator = cp_parser_declarator_id (parser);\n+\t  if (dcl_kind == CP_PARSER_DECLARATOR_EITHER\n+\t      && !cp_parser_parse_definitely (parser))\n+\t    declarator = error_mark_node;\n+\t  if (declarator == error_mark_node)\n+\t    break;\n \t  \n-\t  /* Consume the `('.  */\n-\t  cp_lexer_consume_token (parser->lexer);\n-\t  /* Parse the parameter-declaration-clause.  */\n-\t  params = cp_parser_parameter_declaration_clause (parser);\n+\t  if (TREE_CODE (declarator) == SCOPE_REF)\n+\t    {\n+\t      tree scope = TREE_OPERAND (declarator, 0);\n \t  \n-\t  /* If all went well, parse the cv-qualifier-seq and the\n-\t     exception-specification.  */\n-\t  if (cp_parser_parse_definitely (parser))\n+\t      /* In the declaration of a member of a template class\n+\t     \t outside of the class itself, the SCOPE will sometimes\n+\t     \t be a TYPENAME_TYPE.  For example, given:\n+\t     \t  \n+               \t template <typename T>\n+\t       \t int S<T>::R::i = 3;\n+\t\t  \n+             \t the SCOPE will be a TYPENAME_TYPE for `S<T>::R'.  In\n+             \t this context, we must resolve S<T>::R to an ordinary\n+             \t type, rather than a typename type.\n+\t\t  \n+\t     \t The reason we normally avoid resolving TYPENAME_TYPEs\n+\t     \t is that a specialization of `S' might render\n+\t     \t `S<T>::R' not a type.  However, if `S' is\n+\t     \t specialized, then this `i' will not be used, so there\n+\t     \t is no harm in resolving the types here.  */\n+\t      if (TREE_CODE (scope) == TYPENAME_TYPE)\n+\t\t{\n+\t\t  /* Resolve the TYPENAME_TYPE.  */\n+\t\t  scope = cp_parser_resolve_typename_type (parser, scope);\n+\t\t  /* If that failed, the declarator is invalid.  */\n+\t\t  if (scope == error_mark_node)\n+\t\t    return error_mark_node;\n+\t\t  /* Build a new DECLARATOR.  */\n+\t\t  declarator = build_nt (SCOPE_REF, \n+\t\t\t\t\t scope,\n+\t\t\t\t\t TREE_OPERAND (declarator, 1));\n+\t\t}\n+\t    }\n+      \n+\t  /* Check to see whether the declarator-id names a constructor, \n+\t     destructor, or conversion.  */\n+\t  if (declarator && ctor_dtor_or_conv_p \n+\t      && ((TREE_CODE (declarator) == SCOPE_REF \n+\t\t   && CLASS_TYPE_P (TREE_OPERAND (declarator, 0)))\n+\t\t  || (TREE_CODE (declarator) != SCOPE_REF\n+\t\t      && at_class_scope_p ())))\n \t    {\n-\t      tree cv_qualifiers;\n-\t      tree exception_specification;\n-\n-\t      /* Consume the `)'.  */\n-\t      cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n-\n-\t      /* Parse the cv-qualifier-seq.  */\n-\t      cv_qualifiers = cp_parser_cv_qualifier_seq_opt (parser);\n-\t      /* And the exception-specification.  */\n-\t      exception_specification \n-\t\t= cp_parser_exception_specification_opt (parser);\n-\n-\t      /* Create the function-declarator.  */\n-\t      declarator = make_call_declarator (declarator,\n-\t\t\t\t\t\t params,\n-\t\t\t\t\t\t cv_qualifiers,\n-\t\t\t\t\t\t exception_specification);\n+\t      tree unqualified_name;\n+\t      tree class_type;\n+\n+\t      /* Get the unqualified part of the name.  */\n+\t      if (TREE_CODE (declarator) == SCOPE_REF)\n+\t\t{\n+\t\t  class_type = TREE_OPERAND (declarator, 0);\n+\t\t  unqualified_name = TREE_OPERAND (declarator, 1);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  class_type = current_class_type;\n+\t\t  unqualified_name = declarator;\n+\t\t}\n+\n+\t      /* See if it names ctor, dtor or conv.  */\n+\t      if (TREE_CODE (unqualified_name) == BIT_NOT_EXPR\n+\t\t  || IDENTIFIER_TYPENAME_P (unqualified_name)\n+\t\t  || constructor_name_p (unqualified_name, class_type))\n+\t\t*ctor_dtor_or_conv_p = true;\n \t    }\n-\t  /* Otherwise, we must be done with the declarator.  */\n+\n+\thandle_declarator:;\n+\t  scope = get_scope_of_declarator (declarator);\n+\t  if (scope)\n+\t    /* Any names that appear after the declarator-id for a member\n+       \t       are looked up in the containing scope.  */\n+\t    push_scope (scope);\n+\t  parser->in_declarator_p = true;\n+\t  if ((ctor_dtor_or_conv_p && *ctor_dtor_or_conv_p)\n+\t      || (declarator\n+\t\t  && (TREE_CODE (declarator) == SCOPE_REF\n+\t\t      || TREE_CODE (declarator) == IDENTIFIER_NODE)))\n+\t    /* Default args are only allowed on function\n+\t       declarations.  */\n+\t    parser->default_arg_ok_p = saved_default_arg_ok_p;\n \t  else\n-\t    break;\n+\t    parser->default_arg_ok_p = false;\n+\n+\t  first = false;\n \t}\n-      /* Otherwise, we're done with the declarator.  */\n+      /* We're done.  */\n       else\n \tbreak;\n-      /* Any subsequent parameter lists are to do with return type, so\n-\t are not those of the declared function.  */\n-      parser->default_arg_ok_p = false;\n     }\n \n   /* For an abstract declarator, we might wind up with nothing at this\n@@ -10610,7 +10641,7 @@ cp_parser_type_id (parser)\n   cp_parser_parse_tentatively (parser);\n   /* Look for the declarator.  */\n   abstract_declarator \n-    = cp_parser_declarator (parser, /*abstract_p=*/true, NULL);\n+    = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_ABSTRACT, NULL);\n   /* Check to see if there really was a declarator.  */\n   if (!cp_parser_parse_definitely (parser))\n     abstract_declarator = NULL_TREE;\n@@ -10911,23 +10942,15 @@ cp_parser_parameter_declaration (cp_parser *parser,\n       bool saved_default_arg_ok_p = parser->default_arg_ok_p;\n       parser->default_arg_ok_p = false;\n   \n-      /* We don't know whether the declarator will be abstract or\n-\t not.  So, first we try an ordinary declarator.  */\n-      cp_parser_parse_tentatively (parser);\n       declarator = cp_parser_declarator (parser,\n-\t\t\t\t\t /*abstract_p=*/false,\n+\t\t\t\t\t CP_PARSER_DECLARATOR_EITHER,\n \t\t\t\t\t /*ctor_dtor_or_conv_p=*/NULL);\n-      /* If that didn't work, look for an abstract declarator.  */\n-      if (!cp_parser_parse_definitely (parser))\n-\tdeclarator = cp_parser_declarator (parser,\n-\t\t\t\t\t   /*abstract_p=*/true,\n-\t\t\t\t\t   /*ctor_dtor_or_conv_p=*/NULL);\n       parser->default_arg_ok_p = saved_default_arg_ok_p;\n       /* After the declarator, allow more attributes.  */\n       attributes = chainon (attributes, cp_parser_attributes_opt (parser));\n     }\n \n-  /* The restriction on definining new types applies only to the type\n+  /* The restriction on defining new types applies only to the type\n      of the parameter, not to the default argument.  */\n   parser->type_definition_forbidden_message = saved_message;\n \n@@ -11140,8 +11163,7 @@ cp_parser_function_definition (parser, friend_p)\n     *friend_p = cp_parser_friend_p (decl_specifiers);\n \n   /* Parse the declarator.  */\n-  declarator = cp_parser_declarator (parser, \n-\t\t\t\t     /*abstract_p=*/false,\n+  declarator = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n \t\t\t\t     /*ctor_dtor_or_conv_p=*/NULL);\n \n   /* Gather up any access checks that occurred.  */\n@@ -12314,8 +12336,7 @@ cp_parser_member_declaration (parser)\n \n \t      /* Parse the declarator.  */\n \t      declarator \n-\t\t= cp_parser_declarator (parser,\n-\t\t\t\t\t/*abstract_p=*/false,\n+\t\t= cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n \t\t\t\t\t&ctor_dtor_or_conv_p);\n \n \t      /* If something went wrong parsing the declarator, make sure\n@@ -12955,20 +12976,8 @@ cp_parser_exception_declaration (parser)\n   if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n     declarator = NULL_TREE;\n   else\n-    {\n-      /* Otherwise, we can't be sure whether we are looking at a\n-\t direct, or an abstract, declarator.  */\n-      cp_parser_parse_tentatively (parser);\n-      /* Try an ordinary declarator.  */\n-      declarator = cp_parser_declarator (parser,\n-\t\t\t\t\t /*abstract_p=*/false,\n-\t\t\t\t\t /*ctor_dtor_or_conv_p=*/NULL);\n-      /* If that didn't work, try an abstract declarator.  */\n-      if (!cp_parser_parse_definitely (parser))\n-\tdeclarator = cp_parser_declarator (parser,\n-\t\t\t\t\t   /*abstract_p=*/true,\n-\t\t\t\t\t   /*ctor_dtor_or_conv_p=*/NULL);\n-    }\n+    declarator = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_EITHER,\n+\t\t\t\t       /*ctor_dtor_or_conv_p=*/NULL);\n \n   /* Restore the saved message.  */\n   parser->type_definition_forbidden_message = saved_message;"}, {"sha": "c6c0cd0c7b920a9911794c0a96a1f911ce618b2b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62b8a44e2617685f1094b108869f2c71f38f33af/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62b8a44e2617685f1094b108869f2c71f38f33af/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=62b8a44e2617685f1094b108869f2c71f38f33af", "patch": "@@ -1,3 +1,8 @@\n+2003-01-06  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.dg/parse/ambig1.C: New test.\n+\t* g++.dg/parse/defarg2.C: New test.\n+\n 2003-01-05  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.dg/template/defarg-1.C: New test."}, {"sha": "2645879b30e287dbfba6bca7b4d3924c52240928", "filename": "gcc/testsuite/g++.dg/parse/ambig1.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62b8a44e2617685f1094b108869f2c71f38f33af/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fambig1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62b8a44e2617685f1094b108869f2c71f38f33af/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fambig1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fambig1.C?ref=62b8a44e2617685f1094b108869f2c71f38f33af", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 4 Jan 2003 <nathan@codesourcery.com>\n+\n+// PR 9109. Ambiguity. [dcl.ambig.res]/7\n+\n+template <typename T> void Foo (int (T))\n+{\n+  try {}\n+  catch (int (T)) {}\n+}"}, {"sha": "571855a3c939c91de55c6f9930dbbff9e68663f6", "filename": "gcc/testsuite/g++.dg/parse/defarg2.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62b8a44e2617685f1094b108869f2c71f38f33af/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdefarg2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62b8a44e2617685f1094b108869f2c71f38f33af/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdefarg2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdefarg2.C?ref=62b8a44e2617685f1094b108869f2c71f38f33af", "patch": "@@ -0,0 +1,9 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 4 Jan 2003 <nathan@codesourcery.com>\n+\n+// We erroneously prohibited default args on parenthesized function\n+// declarations.\n+\n+void (foo)(int i = 0);"}]}