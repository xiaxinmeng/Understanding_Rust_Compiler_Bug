{"sha": "a720f0efffdf29c2f486e3d825446be4aa77b375", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTcyMGYwZWZmZmRmMjljMmY0ODZlM2Q4MjU0NDZiZTRhYTc3YjM3NQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2015-02-04T14:23:33Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2015-02-04T14:23:33Z"}, "message": "Avoid allocating memory when trying but failing to simplify XOR of AND.\n\nfor  gcc/ChangeLog\n\n\tPR debug/64817\n\t* simplify-rtx.c (simplify_binary_operation_1): Rewrite\n\tsimplification of XOR of AND to not allocate new rtx before\n\tcommitting to a simplification.\n\nFrom-SVN: r220404", "tree": {"sha": "12c5c10d4bac82dd0e4f76d8300f90e15e0bab91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12c5c10d4bac82dd0e4f76d8300f90e15e0bab91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a720f0efffdf29c2f486e3d825446be4aa77b375", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a720f0efffdf29c2f486e3d825446be4aa77b375", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a720f0efffdf29c2f486e3d825446be4aa77b375", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a720f0efffdf29c2f486e3d825446be4aa77b375/comments", "author": null, "committer": null, "parents": [{"sha": "a1ac80507d37425ef84fa68431bb2c63d6b27fef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ac80507d37425ef84fa68431bb2c63d6b27fef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1ac80507d37425ef84fa68431bb2c63d6b27fef"}], "stats": {"total": 36, "additions": 31, "deletions": 5}, "files": [{"sha": "685f4b8cfca26275dba020d94bbab045263bc37c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a720f0efffdf29c2f486e3d825446be4aa77b375/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a720f0efffdf29c2f486e3d825446be4aa77b375/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a720f0efffdf29c2f486e3d825446be4aa77b375", "patch": "@@ -1,3 +1,10 @@\n+2015-02-04  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR debug/64817\n+\t* simplify-rtx.c (simplify_binary_operation_1): Rewrite\n+\tsimplification of XOR of AND to not allocate new rtx before\n+\tcommitting to a simplification.\n+\n 2015-02-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/aarch64/aarch64-ldpstp.md: Use std::swap instead of"}, {"sha": "bea9ec353f6dcd7fa587b21aeff37921d3e7a060", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a720f0efffdf29c2f486e3d825446be4aa77b375/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a720f0efffdf29c2f486e3d825446be4aa77b375/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=a720f0efffdf29c2f486e3d825446be4aa77b375", "patch": "@@ -2724,12 +2724,31 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t  HOST_WIDE_INT bval = INTVAL (b);\n \t  HOST_WIDE_INT cval = INTVAL (c);\n \n-\t  rtx na_c\n-\t    = simplify_binary_operation (AND, mode,\n-\t\t\t\t\t simplify_gen_unary (NOT, mode, a, mode),\n-\t\t\t\t\t c);\n+\t  /* Instead of computing ~A&C, we compute its negated value,\n+\t     ~(A|~C).  If it yields -1, ~A&C is zero, so we can\n+\t     optimize for sure.  If it does not simplify, we still try\n+\t     to compute ~A&C below, but since that always allocates\n+\t     RTL, we don't try that before committing to returning a\n+\t     simplified expression.  */\n+\t  rtx n_na_c = simplify_binary_operation (IOR, mode, a,\n+\t\t\t\t\t\t  GEN_INT (~cval));\n+\n \t  if ((~cval & bval) == 0)\n \t    {\n+\t      rtx na_c = NULL_RTX;\n+\t      if (n_na_c)\n+\t\tna_c = simplify_gen_unary (NOT, mode, n_na_c, mode);\n+\t      else\n+\t\t{\n+\t\t  /* If ~A does not simplify, don't bother: we don't\n+\t\t     want to simplify 2 operations into 3, and if na_c\n+\t\t     were to simplify with na, n_na_c would have\n+\t\t     simplified as well.  */\n+\t\t  rtx na = simplify_unary_operation (NOT, mode, a, mode);\n+\t\t  if (na)\n+\t\t    na_c = simplify_gen_binary (AND, mode, na, c);\n+\t\t}\n+\n \t      /* Try to simplify ~A&C | ~B&C.  */\n \t      if (na_c != NULL_RTX)\n \t\treturn simplify_gen_binary (IOR, mode, na_c,\n@@ -2738,7 +2757,7 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t  else\n \t    {\n \t      /* If ~A&C is zero, simplify A&(~C&B) | ~B&C.  */\n-\t      if (na_c == const0_rtx)\n+\t      if (n_na_c == CONSTM1_RTX (mode))\n \t\t{\n \t\t  rtx a_nc_b = simplify_gen_binary (AND, mode, a,\n \t\t\t\t\t\t    gen_int_mode (~cval & bval,"}]}