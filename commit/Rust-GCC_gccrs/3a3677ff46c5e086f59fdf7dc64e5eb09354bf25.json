{"sha": "3a3677ff46c5e086f59fdf7dc64e5eb09354bf25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2EzNjc3ZmY0NmM1ZTA4NmY1OWZkZjdkYzY0ZTVlYjA5MzU0YmYyNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-04-09T20:26:42Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-04-09T20:26:42Z"}, "message": "genrecog.c (pred): Update comparison_operator for the unordered operators.\n\n        * genrecog.c (pred): Update comparison_operator for the unordered\n        operators.\n\n        * config/i386/i386.c (no_comparison_operator): Disallow unordered\n        operators.\n        (fcmov_comparison_operator): Allow UNORDERED/ORDERED.\n        (uno_comparison_operator): New.\n        (put_condition_code): Handle UNORDERED/ORDERED.\n        (unsigned_comparison): Likewise.\n        (ix86_fp_compare_mode): Broken out of ix86_expand_fp_compare.\n        (ix86_use_fcomi_compare, ix86_prepare_fp_compare_args): Likewise.\n        (ix86_expand_fp_compare): Use them.  Take scratch as argument,\n        update all callers.  Handle all 8 unordered operators.\n        (ix86_expand_setcc): Lose the unordered argument, update all callers.\n        (ix86_expand_branch): Likewise.  Don't fully expand fp branches.\n        * config/i386/i386.h (PREDICATE_CODES): Update.\n        * config/i386/i386-protos.h (ix86_expand_fp_compare): Declare.\n        (ix86_expand_branch, ix86_expand_setcc): Update.\n        * config/i386/i386.md (sunordered, sordered): New.\n        (suneq, sunge, sungt, sunle, sunlt, sltgt): New.\n        (bunordered, bordered): New.\n        (buneq, bunge, bungt, bunle, bunlt, bltgt): New.\n        (*fp_jcc_1, *fp_jcc_2, *fp_jcc_3, *fp_jcc_4): New.\n        (*fp_jcc_5, *fp_jcc_6, and splitters): New.\n\nFrom-SVN: r33046", "tree": {"sha": "9ad462c37f855428cf12994c72358c73cc098313", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ad462c37f855428cf12994c72358c73cc098313"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a3677ff46c5e086f59fdf7dc64e5eb09354bf25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a3677ff46c5e086f59fdf7dc64e5eb09354bf25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a3677ff46c5e086f59fdf7dc64e5eb09354bf25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a3677ff46c5e086f59fdf7dc64e5eb09354bf25/comments", "author": null, "committer": null, "parents": [{"sha": "00fdafefd637a8b5e8ca0751a3f2eb4cab5af665", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00fdafefd637a8b5e8ca0751a3f2eb4cab5af665", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00fdafefd637a8b5e8ca0751a3f2eb4cab5af665"}], "stats": {"total": 839, "additions": 656, "deletions": 183}, "files": [{"sha": "952ba80a9bc063cb29047651dc560a630d8f1234", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3677ff46c5e086f59fdf7dc64e5eb09354bf25/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3677ff46c5e086f59fdf7dc64e5eb09354bf25/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a3677ff46c5e086f59fdf7dc64e5eb09354bf25", "patch": "@@ -1,6 +1,33 @@\n+2000-04-09  Richard Henderson  <rth@cygnus.com>\n+\n+\t* genrecog.c (pred): Update comparison_operator for the unordered\n+\toperators.\n+\n+\t* config/i386/i386.c (no_comparison_operator): Disallow unordered\n+\toperators.\n+\t(fcmov_comparison_operator): Allow UNORDERED/ORDERED.\n+\t(uno_comparison_operator): New.\n+\t(put_condition_code): Handle UNORDERED/ORDERED.\n+\t(unsigned_comparison): Likewise.\n+\t(ix86_fp_compare_mode): Broken out of ix86_expand_fp_compare.\n+\t(ix86_use_fcomi_compare, ix86_prepare_fp_compare_args): Likewise.\n+\t(ix86_expand_fp_compare): Use them.  Take scratch as argument,\n+\tupdate all callers.  Handle all 8 unordered operators.\n+\t(ix86_expand_setcc): Lose the unordered argument, update all callers.\n+\t(ix86_expand_branch): Likewise.  Don't fully expand fp branches.\n+\t* config/i386/i386.h (PREDICATE_CODES): Update.\n+\t* config/i386/i386-protos.h (ix86_expand_fp_compare): Declare.\n+\t(ix86_expand_branch, ix86_expand_setcc): Update.\n+\t* config/i386/i386.md (sunordered, sordered): New.\n+\t(suneq, sunge, sungt, sunle, sunlt, sltgt): New.\n+\t(bunordered, bordered): New.\n+\t(buneq, bunge, bungt, bunle, bunlt, bltgt): New.\n+\t(*fp_jcc_1, *fp_jcc_2, *fp_jcc_3, *fp_jcc_4): New.\n+\t(*fp_jcc_5, *fp_jcc_6, and splitters): New.\n+\n 2000-04-09  Philip Blundell  <philb@gnu.org>\n \n-        * config/arm/arm.h (ARM_NAME_ENCODING_LENGTHS): Strip `*' too.\n+\t* config/arm/arm.h (ARM_NAME_ENCODING_LENGTHS): Strip `*' too.\n \t\n Sun Apr  9 15:16:14 EDT 2000  John Wehle  (john@feith.com)\n "}, {"sha": "557d80660c9b50a5da2620be9ae3f38133fd5c9c", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3677ff46c5e086f59fdf7dc64e5eb09354bf25/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3677ff46c5e086f59fdf7dc64e5eb09354bf25/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=3a3677ff46c5e086f59fdf7dc64e5eb09354bf25", "patch": "@@ -97,8 +97,9 @@ extern void ix86_expand_unary_operator PARAMS ((enum rtx_code, enum machine_mode\n extern int ix86_unary_operator_ok PARAMS ((enum rtx_code, enum machine_mode,\n \t\t\t\t\t rtx[]));\n extern int ix86_match_ccmode PARAMS ((rtx, enum machine_mode));\n-extern void ix86_expand_branch PARAMS ((enum rtx_code, int, rtx));\n-extern int ix86_expand_setcc PARAMS ((enum rtx_code, int, rtx));\n+extern rtx ix86_expand_fp_compare PARAMS ((enum rtx_code, rtx, rtx, rtx));\n+extern void ix86_expand_branch PARAMS ((enum rtx_code, rtx));\n+extern int ix86_expand_setcc PARAMS ((enum rtx_code, rtx));\n extern int ix86_expand_int_movcc PARAMS ((rtx[]));\n extern int ix86_expand_fp_movcc PARAMS ((rtx[]));\n extern int ix86_split_long_move PARAMS ((rtx[]));"}, {"sha": "74de03c376a857a66b2767c6751b317fc88cd062", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 349, "deletions": 153, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3677ff46c5e086f59fdf7dc64e5eb09354bf25/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3677ff46c5e086f59fdf7dc64e5eb09354bf25/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3a3677ff46c5e086f59fdf7dc64e5eb09354bf25", "patch": "@@ -384,8 +384,11 @@ static void put_condition_code PARAMS ((enum rtx_code, enum machine_mode,\n \t\t\t\t       int, int, FILE *));\n static enum rtx_code unsigned_comparison PARAMS ((enum rtx_code code));\n static rtx ix86_expand_int_compare PARAMS ((enum rtx_code, rtx, rtx));\n-static rtx ix86_expand_fp_compare PARAMS ((enum rtx_code, rtx, rtx, int));\n-static rtx ix86_expand_compare PARAMS ((enum rtx_code, int));\n+static enum machine_mode ix86_fp_compare_mode PARAMS ((enum rtx_code));\n+static int ix86_use_fcomi_compare PARAMS ((enum rtx_code));\n+static enum rtx_code ix86_prepare_fp_compare_args PARAMS ((enum rtx_code,\n+\t\t\t\t\t\t\t   rtx *, rtx *));\n+static rtx ix86_expand_compare PARAMS ((enum rtx_code));\n static rtx gen_push PARAMS ((rtx));\n static int memory_address_length PARAMS ((rtx addr));\n static int ix86_flags_dependant PARAMS ((rtx, rtx, enum attr_type));\n@@ -1235,10 +1238,19 @@ no_comparison_operator (op, mode)\n     register rtx op;\n     enum machine_mode mode;\n {\n-  return ((mode == VOIDmode || GET_MODE (op) == mode)\n-\t  && GET_RTX_CLASS (GET_CODE (op)) == '<'\n-\t  && GET_CODE (op) != LE\n-\t  && GET_CODE (op) != GT);\n+  if (mode != VOIDmode && GET_MODE (op) != mode)\n+    return 0;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case EQ: case NE:\n+    case LT: case GE:\n+    case LEU: case LTU: case GEU: case GTU:\n+      return 1;\n+\n+    default:\n+      return 0;\n+    }\n }\n \n /* Return 1 if OP is a comparison operator that can be issued by fcmov.  */\n@@ -1248,9 +1260,42 @@ fcmov_comparison_operator (op, mode)\n     register rtx op;\n     enum machine_mode mode;\n {\n-  return ((mode == VOIDmode || GET_MODE (op) == mode)\n-\t  && GET_RTX_CLASS (GET_CODE (op)) == '<'\n-\t  && GET_CODE (op) == unsigned_condition (GET_CODE (op)));\n+  if (mode != VOIDmode && GET_MODE (op) != mode)\n+    return 0;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case EQ: case NE:\n+    case LEU: case LTU: case GEU: case GTU:\n+    case UNORDERED: case ORDERED:\n+      return 1;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Return 1 if OP is any normal comparison operator plus {UN}ORDERED.  */\n+\n+int \n+uno_comparison_operator (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  if (mode != VOIDmode && GET_MODE (op) != mode)\n+    return 0;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case EQ: case NE:\n+    case LE: case LT: case GE: case GT:\n+    case LEU: case LTU: case GEU: case GTU:\n+    case UNORDERED: case ORDERED:\n+      return 1;\n+\n+    default:\n+      return 0;\n+    }\n }\n \n /* Return 1 if OP is a binary operator that can be promoted to wider mode.  */\n@@ -2970,6 +3015,12 @@ put_condition_code (code, mode, reverse, fp, file)\n     case LEU:\n       suffix = \"be\";\n       break;\n+    case UNORDERED:\n+      suffix = \"p\";\n+      break;\n+    case ORDERED:\n+      suffix = \"np\";\n+      break;\n     default:\n       abort ();\n     }\n@@ -4386,6 +4437,8 @@ unsigned_comparison (code)\n     case LTU:\n     case GEU:\n     case GTU:\n+    case UNORDERED:\n+    case ORDERED:\n       break;\n     default:\n       abort ();\n@@ -4416,36 +4469,80 @@ ix86_expand_int_compare (code, op0, op1)\n   return gen_rtx_fmt_ee (code, VOIDmode, flags, const0_rtx);\n }\n \n-/* Generate insn patterns to do a floating point compare of OPERANDS.\n-   If UNORDERED, allow for unordered compares.  */\n+/* Figure out whether to use ordered or unordered fp comparisons.\n+   Return the appropriate mode to use.  */\n \n-static rtx\n-ix86_expand_fp_compare (code, op0, op1, unordered)\n+static enum machine_mode\n+ix86_fp_compare_mode (code)\n      enum rtx_code code;\n-     rtx op0, op1;\n-     int unordered;\n {\n-  enum machine_mode fpcmp_mode;\n-  enum machine_mode intcmp_mode;\n-  rtx tmp;\n+  int unordered;\n \n-  /* When not doing IEEE compliant compares, disable unordered.  */\n-  if (! TARGET_IEEE_FP)\n-    unordered = 0;\n-  fpcmp_mode = unordered ? CCFPUmode : CCFPmode;\n+  switch (code)\n+    {\n+    case NE: case EQ:\n+      /* When not doing IEEE compliant compares, fault on NaNs.  */\n+      unordered = (TARGET_IEEE_FP != 0);\n+      break;\n+\n+    case LT: case LE: case GT: case GE:\n+      unordered = 0;\n+      break;\n+\n+    case UNORDERED: case ORDERED:\n+    case UNEQ: case UNGE: case UNGT: case UNLE: case UNLT: case LTGT:\n+      unordered = 1;\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n \n   /* ??? If we knew whether invalid-operand exceptions were masked,\n      we could rely on fcom to raise an exception and take care of\n-     NaNs.  But we don't.  We could know this from c9x math bits.  */\n+     NaNs.  But we don't.  We could know this from c99 math pragmas.  */\n   if (TARGET_IEEE_FP)\n     unordered = 1;\n \n+  return unordered ? CCFPUmode : CCFPmode;\n+}\n+\n+/* Return true if we should use an FCOMI instruction for this fp comparison.  */\n+\n+static int\n+ix86_use_fcomi_compare (code)\n+     enum rtx_code code;\n+{\n+  return (TARGET_CMOVE\n+\t  && (code == ORDERED || code == UNORDERED\n+\t      /* All other unordered compares require checking\n+\t\t multiple sets of bits.  */\n+\t      || ix86_fp_compare_mode (code) == CCFPmode));\n+}\n+\n+/* Swap, force into registers, or otherwise massage the two operands \n+   to a fp comparison.  The operands are updated in place; the new\n+   comparsion code is returned.  */\n+\n+static enum rtx_code\n+ix86_prepare_fp_compare_args (code, pop0, pop1)\n+     enum rtx_code code;\n+     rtx *pop0, *pop1;\n+{\n+  enum machine_mode fpcmp_mode = ix86_fp_compare_mode (code);\n+  rtx op0 = *pop0, op1 = *pop1;\n+  enum machine_mode op_mode = GET_MODE (op0);\n+\n   /* All of the unordered compare instructions only work on registers.\n-     The same is true of the XFmode compare instructions.  */\n-  if (unordered || GET_MODE (op0) == XFmode)\n+     The same is true of the XFmode compare instructions.  The same is\n+     true of the fcomi compare instructions.  */\n+\n+  if (fpcmp_mode == CCFPUmode\n+      || op_mode == XFmode\n+      || ix86_use_fcomi_compare (code))\n     {\n-      op0 = force_reg (GET_MODE (op0), op0);\n-      op1 = force_reg (GET_MODE (op1), op1);\n+      op0 = force_reg (op_mode, op0);\n+      op1 = force_reg (op_mode, op1);\n     }\n   else\n     {\n@@ -4464,33 +4561,46 @@ ix86_expand_fp_compare (code, op0, op1, unordered)\n \t}\n \n       if (GET_CODE (op0) != REG)\n-\top0 = force_reg (GET_MODE (op0), op0);\n+\top0 = force_reg (op_mode, op0);\n \n       if (CONSTANT_P (op1))\n \t{\n \t  if (standard_80387_constant_p (op1))\n-\t    op1 = force_reg (GET_MODE (op1), op1);\n+\t    op1 = force_reg (op_mode, op1);\n \t  else\n-\t    op1 = validize_mem (force_const_mem (GET_MODE (op1), op1));\n+\t    op1 = validize_mem (force_const_mem (op_mode, op1));\n \t}\n     }\n \n+  *pop0 = op0;\n+  *pop1 = op1;\n+  return code;\n+}\n+\n+/* Generate insn patterns to do a floating point compare of OPERANDS.  */\n+\n+rtx\n+ix86_expand_fp_compare (code, op0, op1, scratch)\n+     enum rtx_code code;\n+     rtx op0, op1, scratch;\n+{\n+  enum machine_mode fpcmp_mode, intcmp_mode;\n+  rtx tmp;\n+\n+  fpcmp_mode = ix86_fp_compare_mode (code);\n+  code = ix86_prepare_fp_compare_args (code, &op0, &op1);\n+\n   /* %%% fcomi is probably always faster, even when dealing with memory,\n      since compare-and-branch would be three insns instead of four.  */\n-  if (TARGET_CMOVE && !unordered)\n+  if (ix86_use_fcomi_compare (code))\n     {\n-      if (GET_CODE (op0) != REG)\n-\top0 = force_reg (GET_MODE (op0), op0);\n-      if (GET_CODE (op1) != REG)\n-\top1 = force_reg (GET_MODE (op1), op1);\n-\n       tmp = gen_rtx_COMPARE (fpcmp_mode, op0, op1);\n       tmp = gen_rtx_SET (VOIDmode, gen_rtx_REG (fpcmp_mode, FLAGS_REG), tmp);\n       emit_insn (tmp);\n \n       /* The FP codes work out to act like unsigned.  */\n       code = unsigned_comparison (code);\n-      intcmp_mode = fpcmp_mode;\n+      intcmp_mode = CCmode;\n     }\n   else\n     {\n@@ -4499,10 +4609,11 @@ ix86_expand_fp_compare (code, op0, op1, unordered)\n       rtx tmp2;\n       tmp = gen_rtx_COMPARE (fpcmp_mode, op0, op1);\n       tmp2 = gen_rtx_UNSPEC (HImode, gen_rtvec (1, tmp), 9);\n-      tmp = gen_reg_rtx (HImode);\n-      emit_insn (gen_rtx_SET (VOIDmode, tmp, tmp2));\n+      emit_insn (gen_rtx_SET (VOIDmode, scratch, tmp2));\n \n-      if (! unordered)\n+      if (fpcmp_mode == CCFPmode\n+\t  || code == ORDERED\n+\t  || code == UNORDERED)\n \t{\n \t  /* We have two options here -- use sahf, or testing bits of ah\n \t     directly.  On PPRO, they are equivalent, sahf being one byte\n@@ -4512,10 +4623,10 @@ ix86_expand_fp_compare (code, op0, op1, unordered)\n \t  if (TARGET_USE_SAHF || optimize_size)\n \t    {\n \t    do_sahf:\n+\t      emit_insn (gen_x86_sahf_1 (scratch));\n \n \t      /* The FP codes work out to act like unsigned.  */\n \t      code = unsigned_comparison (code);\n-\t      emit_insn (gen_x86_sahf_1 (tmp));\n \t      intcmp_mode = CCmode;\n \t    }\n \t  else\n@@ -4559,11 +4670,20 @@ ix86_expand_fp_compare (code, op0, op1, unordered)\n \t\t  mask = 0x40;\n \t\t  code = EQ;\n \t\t  break;\n+\t\tcase UNORDERED:\n+\t\t  mask = 0x04;\n+\t\t  code = NE;\n+\t\t  break;\n+\t\tcase ORDERED:\n+\t\t  mask = 0x04;\n+\t\t  code = EQ;\n+\t\t  break;\n+\n \t\tdefault:\n \t\t  abort ();\n \t\t}\n \n-\t      emit_insn (gen_testqi_ext_ccno_0 (tmp, GEN_INT (mask)));\n+\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (mask)));\n \t      intcmp_mode = CCNOmode;\n \t    }\n \t}\n@@ -4578,37 +4698,74 @@ ix86_expand_fp_compare (code, op0, op1, unordered)\n \t  switch (code)\n \t    {\n \t    case GT:\n-\t      emit_insn (gen_testqi_ext_ccno_0 (tmp, GEN_INT (0x45)));\n+\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x45)));\n \t      code = EQ;\n \t      break;\n \t    case LT:\n-\t      emit_insn (gen_andqi_ext_0 (tmp, tmp, GEN_INT (0x45)));\n-\t      emit_insn (gen_cmpqi_ext_3 (tmp, GEN_INT (0x01)));\n+\t      emit_insn (gen_andqi_ext_0 (scratch, scratch, GEN_INT (0x45)));\n+\t      emit_insn (gen_cmpqi_ext_3 (scratch, GEN_INT (0x01)));\n \t      intcmp_mode = CCmode;\n \t      code = EQ;\n \t      break;\n \t    case GE:\n-\t      emit_insn (gen_testqi_ext_ccno_0 (tmp, GEN_INT (0x05)));\n+\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x05)));\n \t      code = EQ;\n \t      break;\n \t    case LE:\n-\t      emit_insn (gen_andqi_ext_0 (tmp, tmp, GEN_INT (0x45)));\n-\t      emit_insn (gen_addqi_ext_1 (tmp, tmp, constm1_rtx));\n-\t      emit_insn (gen_cmpqi_ext_3 (tmp, GEN_INT (0x40)));\n+\t      emit_insn (gen_andqi_ext_0 (scratch, scratch, GEN_INT (0x45)));\n+\t      emit_insn (gen_addqi_ext_1 (scratch, scratch, constm1_rtx));\n+\t      emit_insn (gen_cmpqi_ext_3 (scratch, GEN_INT (0x40)));\n \t      intcmp_mode = CCmode;\n \t      code = LTU;\n \t      break;\n \t    case EQ:\n-\t      emit_insn (gen_andqi_ext_0 (tmp, tmp, GEN_INT (0x45)));\n-\t      emit_insn (gen_cmpqi_ext_3 (tmp, GEN_INT (0x40)));\n+\t      emit_insn (gen_andqi_ext_0 (scratch, scratch, GEN_INT (0x45)));\n+\t      emit_insn (gen_cmpqi_ext_3 (scratch, GEN_INT (0x40)));\n \t      intcmp_mode = CCmode;\n \t      code = EQ;\n \t      break;\n \t    case NE:\n-\t      emit_insn (gen_andqi_ext_0 (tmp, tmp, GEN_INT (0x45)));\n-\t      emit_insn (gen_xorqi_cc_ext_1 (tmp, tmp, GEN_INT (0x40)));\n+\t      emit_insn (gen_andqi_ext_0 (scratch, scratch, GEN_INT (0x45)));\n+\t      emit_insn (gen_xorqi_cc_ext_1 (scratch, scratch, GEN_INT (0x40)));\n+\t      code = NE;\n+\t      break;\n+\n+\t    case UNORDERED:\n+\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x04)));\n+\t      code = NE;\n+\t      break;\n+\t    case ORDERED:\n+\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x04)));\n+\t      code = EQ;\n+\t      break;\n+\t    case UNEQ:\n+\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x40)));\n+\t      code = NE;\n+\t      break;\n+\t    case UNGE:\n+\t      emit_insn (gen_andqi_ext_0 (scratch, scratch, GEN_INT (0x45)));\n+\t      emit_insn (gen_xorqi_cc_ext_1 (scratch, scratch, GEN_INT (0x01)));\n+\t      code = NE;\n+\t      break;\n+\t    case UNGT:\n+\t      emit_insn (gen_andqi_ext_0 (scratch, scratch, GEN_INT (0x45)));\n+\t      emit_insn (gen_addqi_ext_1 (scratch, scratch, constm1_rtx));\n+\t      emit_insn (gen_cmpqi_ext_3 (scratch, GEN_INT (0x44)));\n+\t      code = GEU;\n+\t      break;\n+\t    case UNLE:\n+\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x45)));\n \t      code = NE;\n \t      break;\n+\t    case UNLT:\n+\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x01)));\n+\t      code = NE;\n+\t      break;\n+\t    case LTGT:\n+\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x40)));\n+\t      code = EQ;\n+\t      break;\n+\n \t    default:\n \t      abort ();\n \t    }\n@@ -4623,151 +4780,189 @@ ix86_expand_fp_compare (code, op0, op1, unordered)\n }\n \n static rtx\n-ix86_expand_compare (code, unordered)\n+ix86_expand_compare (code)\n      enum rtx_code code;\n-     int unordered;\n {\n   rtx op0, op1, ret;\n   op0 = ix86_compare_op0;\n   op1 = ix86_compare_op1;\n \n   if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_FLOAT)\n-    ret = ix86_expand_fp_compare (code, op0, op1, unordered);\n+    ret = ix86_expand_fp_compare (code, op0, op1, gen_reg_rtx (HImode));\n   else\n     ret = ix86_expand_int_compare (code, op0, op1);\n \n   return ret;\n }\n \n void\n-ix86_expand_branch (code, unordered, label)\n+ix86_expand_branch (code, label)\n      enum rtx_code code;\n-     int unordered;\n      rtx label;\n {\n-  rtx tmp, lo[2], hi[2], label2;\n-  enum rtx_code code1, code2, code3;\n+  rtx tmp;\n \n-  if (GET_MODE (ix86_compare_op0) != DImode)\n+  switch (GET_MODE (ix86_compare_op0))\n     {\n-      tmp = ix86_expand_compare (code, unordered);\n+    case QImode:\n+    case HImode:\n+    case SImode:\n+      tmp = ix86_expand_compare (code);\n       tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n \t\t\t\t  gen_rtx_LABEL_REF (VOIDmode, label),\n \t\t\t\t  pc_rtx);\n       emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, tmp));\n       return;\n-    }\n-\n-  /* Expand DImode branch into multiple compare+branch.  */\n \n-  if (CONSTANT_P (ix86_compare_op0) && ! CONSTANT_P (ix86_compare_op1))\n-    {\n-      tmp = ix86_compare_op0;\n-      ix86_compare_op0 = ix86_compare_op1;\n-      ix86_compare_op1 = tmp;\n-      code = swap_condition (code);\n-    }\n-  split_di (&ix86_compare_op0, 1, lo+0, hi+0);\n-  split_di (&ix86_compare_op1, 1, lo+1, hi+1);\n-\n-  /* When comparing for equality, we can use (hi0^hi1)|(lo0^lo1) to avoid\n-     two branches.  This costs one extra insn, so disable when optimizing\n-     for size.  */\n+    case SFmode:\n+    case DFmode:\n+    case XFmode:   \n+      /* Don't expand the comparison early, so that we get better code\n+\t when jump or whoever decides to reverse the comparison.  */\n+      {\n+\trtvec vec;\n+\tint use_fcomi;\n+\n+\tcode = ix86_prepare_fp_compare_args (code, &ix86_compare_op0,\n+\t\t\t\t\t     &ix86_compare_op1);\n+\n+\ttmp = gen_rtx_fmt_ee (code, ix86_fp_compare_mode (code),\n+\t\t\t      ix86_compare_op0, ix86_compare_op1);\n+\ttmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n+\t\t\t\t    gen_rtx_LABEL_REF (VOIDmode, label),\n+\t\t\t\t    pc_rtx);\n+\ttmp = gen_rtx_SET (VOIDmode, pc_rtx, tmp);\n+\n+\tuse_fcomi = ix86_use_fcomi_compare (code);\n+\tvec = rtvec_alloc (3 + !use_fcomi);\n+\tRTVEC_ELT (vec, 0) = tmp;\n+\tRTVEC_ELT (vec, 1)\n+\t  = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCFPmode, 18));\n+\tRTVEC_ELT (vec, 2)\n+\t  = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCFPmode, 17));\n+\tif (! use_fcomi)\n+\t  RTVEC_ELT (vec, 3)\n+\t    = gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (HImode));\n+\n+        emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, vec));\n+\treturn;\n+      }\n \n-  if ((code == EQ || code == NE)\n-      && (!optimize_size\n-\t  || hi[1] == const0_rtx || lo[1] == const0_rtx))\n-    {\n-      rtx xor0, xor1;\n+    case DImode:\n+      /* Expand DImode branch into multiple compare+branch.  */\n+      {\n+\trtx lo[2], hi[2], label2;\n+\tenum rtx_code code1, code2, code3;\n \n-      xor1 = hi[0];\n-      if (hi[1] != const0_rtx)\n-\t{\n-\t  xor1 = expand_binop (SImode, xor_optab, xor1, hi[1],\n-\t\t\t       NULL_RTX, 0, OPTAB_WIDEN);\n-\t}\n+\tif (CONSTANT_P (ix86_compare_op0) && ! CONSTANT_P (ix86_compare_op1))\n+\t  {\n+\t    tmp = ix86_compare_op0;\n+\t    ix86_compare_op0 = ix86_compare_op1;\n+\t    ix86_compare_op1 = tmp;\n+\t    code = swap_condition (code);\n+\t  }\n+\tsplit_di (&ix86_compare_op0, 1, lo+0, hi+0);\n+\tsplit_di (&ix86_compare_op1, 1, lo+1, hi+1);\n \n-      xor0 = lo[0];\n-      if (lo[1] != const0_rtx)\n-\t{\n-\t  xor0 = expand_binop (SImode, xor_optab, xor0, lo[1],\n-\t\t\t       NULL_RTX, 0, OPTAB_WIDEN);\n-\t}\n+\t/* When comparing for equality, we can use (hi0^hi1)|(lo0^lo1) to\n+\t   avoid two branches.  This costs one extra insn, so disable when\n+\t   optimizing for size.  */\n \n-      tmp = expand_binop (SImode, ior_optab, xor1, xor0,\n-\t\t\t  NULL_RTX, 0, OPTAB_WIDEN);\n+\tif ((code == EQ || code == NE)\n+\t    && (!optimize_size\n+\t        || hi[1] == const0_rtx || lo[1] == const0_rtx))\n+\t  {\n+\t    rtx xor0, xor1;\n \n-      ix86_compare_op0 = tmp;\n-      ix86_compare_op1 = const0_rtx;\n-      ix86_expand_branch (code, unordered, label);\n-      return;\n-    }\n+\t    xor1 = hi[0];\n+\t    if (hi[1] != const0_rtx)\n+\t      xor1 = expand_binop (SImode, xor_optab, xor1, hi[1],\n+\t\t\t\t   NULL_RTX, 0, OPTAB_WIDEN);\n \n-  /* Otherwise, if we are doing less-than, op1 is a constant and the\n-     low word is zero, then we can just examine the high word.  */\n+\t    xor0 = lo[0];\n+\t    if (lo[1] != const0_rtx)\n+\t      xor0 = expand_binop (SImode, xor_optab, xor0, lo[1],\n+\t\t\t\t   NULL_RTX, 0, OPTAB_WIDEN);\n \n-  if (GET_CODE (hi[1]) == CONST_INT && lo[1] == const0_rtx\n-      && (code == LT || code == LTU))\n-    {\n-      ix86_compare_op0 = hi[0];\n-      ix86_compare_op1 = hi[1];\n-      ix86_expand_branch (code, unordered, label);\n-      return;\n-    }\n+\t    tmp = expand_binop (SImode, ior_optab, xor1, xor0,\n+\t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n \n-  /* Otherwise, we need two or three jumps.  */\n+\t    ix86_compare_op0 = tmp;\n+\t    ix86_compare_op1 = const0_rtx;\n+\t    ix86_expand_branch (code, label);\n+\t    return;\n+\t  }\n \n-  label2 = gen_label_rtx ();\n+\t/* Otherwise, if we are doing less-than, op1 is a constant and the\n+\t   low word is zero, then we can just examine the high word.  */\n \n-  code1 = code;\n-  code2 = swap_condition (code);\n-  code3 = unsigned_condition (code);\n+\tif (GET_CODE (hi[1]) == CONST_INT && lo[1] == const0_rtx\n+\t    && (code == LT || code == LTU))\n+\t  {\n+\t    ix86_compare_op0 = hi[0];\n+\t    ix86_compare_op1 = hi[1];\n+\t    ix86_expand_branch (code, label);\n+\t    return;\n+\t  }\n \n-  switch (code)\n-    {\n-    case LT: case GT: case LTU: case GTU:\n-      break;\n+\t/* Otherwise, we need two or three jumps.  */\n \n-    case LE:   code1 = LT;  code2 = GT;  break;\n-    case GE:   code1 = GT;  code2 = LT;  break;\n-    case LEU:  code1 = LTU; code2 = GTU; break;\n-    case GEU:  code1 = GTU; code2 = LTU; break;\n+\tlabel2 = gen_label_rtx ();\n \n-    case EQ:   code1 = NIL; code2 = NE;  break;\n-    case NE:   code2 = NIL; break;\n+\tcode1 = code;\n+\tcode2 = swap_condition (code);\n+\tcode3 = unsigned_condition (code);\n \n-    default:\n-      abort ();\n-    }\n+\tswitch (code)\n+\t  {\n+\t  case LT: case GT: case LTU: case GTU:\n+\t    break;\n \n-  /*\n-   * a < b =>\n-   *    if (hi(a) < hi(b)) goto true;\n-   *    if (hi(a) > hi(b)) goto false;\n-   *    if (lo(a) < lo(b)) goto true;\n-   *  false:\n-   */\n+\t  case LE:   code1 = LT;  code2 = GT;  break;\n+\t  case GE:   code1 = GT;  code2 = LT;  break;\n+\t  case LEU:  code1 = LTU; code2 = GTU; break;\n+\t  case GEU:  code1 = GTU; code2 = LTU; break;\n \n-  ix86_compare_op0 = hi[0];\n-  ix86_compare_op1 = hi[1];\n+\t  case EQ:   code1 = NIL; code2 = NE;  break;\n+\t  case NE:   code2 = NIL; break;\n \n-  if (code1 != NIL)\n-    ix86_expand_branch (code1, unordered, label);\n-  if (code2 != NIL)\n-    ix86_expand_branch (code2, unordered, label2);\n+\t  default:\n+\t    abort ();\n+\t  }\n \n-  ix86_compare_op0 = lo[0];\n-  ix86_compare_op1 = lo[1];\n-  ix86_expand_branch (code3, unordered, label);\n+\t/*\n+\t * a < b =>\n+\t *    if (hi(a) < hi(b)) goto true;\n+\t *    if (hi(a) > hi(b)) goto false;\n+\t *    if (lo(a) < lo(b)) goto true;\n+\t *  false:\n+\t */\n+\n+\tix86_compare_op0 = hi[0];\n+\tix86_compare_op1 = hi[1];\n+\n+\tif (code1 != NIL)\n+\t  ix86_expand_branch (code1, label);\n+\tif (code2 != NIL)\n+\t  ix86_expand_branch (code2, label2);\n+\n+\tix86_compare_op0 = lo[0];\n+\tix86_compare_op1 = lo[1];\n+\tix86_expand_branch (code3, label);\n+\n+\tif (code2 != NIL)\n+\t  emit_label (label2);\n+\treturn;\n+      }\n \n-  if (code2 != NIL)\n-    emit_label (label2);\n+    default:\n+      abort ();\n+    }\n }\n \n int\n-ix86_expand_setcc (code, unordered, dest)\n+ix86_expand_setcc (code, dest)\n      enum rtx_code code;\n-     int unordered;\n      rtx dest;\n {\n   rtx ret, tmp;\n@@ -4796,7 +4991,7 @@ ix86_expand_setcc (code, unordered, dest)\n   if (type == 0)\n     emit_move_insn (dest, const0_rtx);\n \n-  ret = ix86_expand_compare (code, unordered);\n+  ret = ix86_expand_compare (code);\n   PUT_MODE (ret, QImode);\n \n   tmp = dest;\n@@ -4853,8 +5048,9 @@ ix86_expand_int_movcc (operands)\n \tcode = GEU;\n       ix86_compare_op1 = GEN_INT (INTVAL (ix86_compare_op1) + 1);\n     }\n+\n   start_sequence ();\n-  compare_op = ix86_expand_compare (code, code == EQ || code == NE);\n+  compare_op = ix86_expand_compare (code);\n   compare_seq = gen_sequence ();\n   end_sequence ();\n \n@@ -5165,7 +5361,7 @@ ix86_expand_fp_movcc (operands)\n     case GE:\n     case GT:\n       tmp = gen_reg_rtx (QImode);\n-      ix86_expand_setcc (code, 0, tmp);\n+      ix86_expand_setcc (code, tmp);\n       code = NE;\n       ix86_compare_op0 = tmp;\n       ix86_compare_op1 = const0_rtx;"}, {"sha": "cde39ceced9c83f0e65e11127de250b13ab866a8", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3677ff46c5e086f59fdf7dc64e5eb09354bf25/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3677ff46c5e086f59fdf7dc64e5eb09354bf25/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=3a3677ff46c5e086f59fdf7dc64e5eb09354bf25", "patch": "@@ -2508,6 +2508,8 @@ do { long l;\t\t\t\t\t\t\\\n   {\"non_q_regs_operand\", {SUBREG, REG}},\t\t\t\t\\\n   {\"no_comparison_operator\", {EQ, NE, LT, GE, LTU, GTU, LEU, GEU}},\t\\\n   {\"fcmov_comparison_operator\", {EQ, NE, LTU, GTU, LEU, GEU}},\t\t\\\n+  {\"uno_comparison_operator\", {EQ, NE, LE, LT, GE, GT, LEU, LTU, GEU,\t\\\n+\t\t\t       GTU, UNORDERED, ORDERED}},\t\t\\\n   {\"cmp_fp_expander_operand\", {CONST_DOUBLE, SUBREG, REG, MEM}},\t\\\n   {\"ext_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n   {\"binary_fp_operator\", {PLUS, MINUS, MULT, DIV}},\t\t\t\\"}, {"sha": "98c761604145b554757ded5c2a5c360b2bbf9c42", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 271, "deletions": 26, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3677ff46c5e086f59fdf7dc64e5eb09354bf25/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3677ff46c5e086f59fdf7dc64e5eb09354bf25/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=3a3677ff46c5e086f59fdf7dc64e5eb09354bf25", "patch": "@@ -6605,61 +6605,109 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n         (eq:SI (reg:CC 17) (const_int 0)))]\n   \"\"\n-  \"if (ix86_expand_setcc (EQ, 1, operands[0])) DONE; else FAIL;\")\n+  \"if (ix86_expand_setcc (EQ, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sne\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n         (ne:SI (reg:CC 17) (const_int 0)))]\n   \"\"\n-  \"if (ix86_expand_setcc (NE, 1, operands[0])) DONE; else FAIL;\")\n+  \"if (ix86_expand_setcc (NE, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sgt\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n         (gt:SI (reg:CC 17) (const_int 0)))]\n   \"\"\n-  \"if (ix86_expand_setcc (GT, 0, operands[0])) DONE; else FAIL;\")\n+  \"if (ix86_expand_setcc (GT, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sgtu\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n         (gtu:SI (reg:CC 17) (const_int 0)))]\n   \"\"\n-  \"if (ix86_expand_setcc (GTU, 0, operands[0])) DONE; else FAIL;\")\n+  \"if (ix86_expand_setcc (GTU, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"slt\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n         (lt:SI (reg:CC 17) (const_int 0)))]\n   \"\"\n-  \"if (ix86_expand_setcc (LT, 0, operands[0])) DONE; else FAIL;\")\n+  \"if (ix86_expand_setcc (LT, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sltu\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n         (ltu:SI (reg:CC 17) (const_int 0)))]\n   \"\"\n-  \"if (ix86_expand_setcc (LTU, 0, operands[0])) DONE; else FAIL;\")\n+  \"if (ix86_expand_setcc (LTU, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sge\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n         (ge:SI (reg:CC 17) (const_int 0)))]\n   \"\"\n-  \"if (ix86_expand_setcc (GE, 0, operands[0])) DONE; else FAIL;\")\n+  \"if (ix86_expand_setcc (GE, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sgeu\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n         (geu:SI (reg:CC 17) (const_int 0)))]\n   \"\"\n-  \"if (ix86_expand_setcc (GEU, 0, operands[0])) DONE; else FAIL;\")\n+  \"if (ix86_expand_setcc (GEU, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sle\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n         (le:SI (reg:CC 17) (const_int 0)))]\n   \"\"\n-  \"if (ix86_expand_setcc (LE, 0, operands[0])) DONE; else FAIL;\")\n+  \"if (ix86_expand_setcc (LE, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sleu\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n         (leu:SI (reg:CC 17) (const_int 0)))]\n   \"\"\n-  \"if (ix86_expand_setcc (LEU, 0, operands[0])) DONE; else FAIL;\")\n+  \"if (ix86_expand_setcc (LEU, operands[0])) DONE; else FAIL;\")\n+\n+(define_expand \"sunordered\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (unordered:SI (reg:CC 17) (const_int 0)))]\n+  \"TARGET_80387\"\n+  \"if (ix86_expand_setcc (UNORDERED, operands[0])) DONE; else FAIL;\")\n+\n+(define_expand \"sordered\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (ordered:SI (reg:CC 17) (const_int 0)))]\n+  \"TARGET_80387\"\n+  \"if (ix86_expand_setcc (ORDERED, operands[0])) DONE; else FAIL;\")\n+\n+(define_expand \"suneq\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (uneq:SI (reg:CC 17) (const_int 0)))]\n+  \"TARGET_80387\"\n+  \"if (ix86_expand_setcc (UNEQ, operands[0])) DONE; else FAIL;\")\n+\n+(define_expand \"sunge\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (unge:SI (reg:CC 17) (const_int 0)))]\n+  \"TARGET_80387\"\n+  \"if (ix86_expand_setcc (UNGE, operands[0])) DONE; else FAIL;\")\n+\n+(define_expand \"sungt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (ungt:SI (reg:CC 17) (const_int 0)))]\n+  \"TARGET_80387\"\n+  \"if (ix86_expand_setcc (UNGT, operands[0])) DONE; else FAIL;\")\n+\n+(define_expand \"sunle\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (unle:SI (reg:CC 17) (const_int 0)))]\n+  \"TARGET_80387\"\n+  \"if (ix86_expand_setcc (UNLE, operands[0])) DONE; else FAIL;\")\n+\n+(define_expand \"sunlt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (unlt:SI (reg:CC 17) (const_int 0)))]\n+  \"TARGET_80387\"\n+  \"if (ix86_expand_setcc (UNLT, operands[0])) DONE; else FAIL;\")\n+\n+(define_expand \"sltgt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (ltgt:SI (reg:CC 17) (const_int 0)))]\n+  \"TARGET_80387\"\n+  \"if (ix86_expand_setcc (LTGT, operands[0])) DONE; else FAIL;\")\n \n (define_insn \"*setcc_1\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm\")\n@@ -6679,15 +6727,15 @@\n \n (define_insn \"*setcc_3\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm\")\n-\t(match_operator:QI 1 \"comparison_operator\"\n+\t(match_operator:QI 1 \"uno_comparison_operator\"\n \t  [(reg:CC 17) (const_int 0)]))]\n   \"\"\n   \"set%C1\\\\t%0\"\n   [(set_attr \"type\" \"setcc\")])\n \n (define_insn \"*setcc_4\"\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm\"))\n-\t(match_operator:QI 1 \"comparison_operator\"\n+\t(match_operator:QI 1 \"uno_comparison_operator\"\n \t  [(reg:CC 17) (const_int 0)]))]\n   \"\"\n   \"set%C1\\\\t%0\"\n@@ -6705,79 +6753,143 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"ix86_expand_branch (EQ, 1, operands[0]); DONE;\")\n+  \"ix86_expand_branch (EQ, operands[0]); DONE;\")\n \n (define_expand \"bne\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"ix86_expand_branch (NE, 1, operands[0]); DONE;\")\n+  \"ix86_expand_branch (NE, operands[0]); DONE;\")\n \n (define_expand \"bgt\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"ix86_expand_branch (GT, 0, operands[0]); DONE;\")\n+  \"ix86_expand_branch (GT, operands[0]); DONE;\")\n \n (define_expand \"bgtu\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"ix86_expand_branch (GTU, 0, operands[0]); DONE;\")\n+  \"ix86_expand_branch (GTU, operands[0]); DONE;\")\n \n (define_expand \"blt\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"ix86_expand_branch (LT, 0, operands[0]); DONE;\")\n+  \"ix86_expand_branch (LT, operands[0]); DONE;\")\n \n (define_expand \"bltu\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"ix86_expand_branch (LTU, 0, operands[0]); DONE;\")\n+  \"ix86_expand_branch (LTU, operands[0]); DONE;\")\n \n (define_expand \"bge\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"ix86_expand_branch (GE, 0, operands[0]); DONE;\")\n+  \"ix86_expand_branch (GE, operands[0]); DONE;\")\n \n (define_expand \"bgeu\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"ix86_expand_branch (GEU, 0, operands[0]); DONE;\")\n+  \"ix86_expand_branch (GEU, operands[0]); DONE;\")\n \n (define_expand \"ble\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"ix86_expand_branch (LE, 0, operands[0]); DONE;\")\n+  \"ix86_expand_branch (LE, operands[0]); DONE;\")\n \n (define_expand \"bleu\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"ix86_expand_branch (LEU, 0, operands[0]); DONE;\")\n+  \"ix86_expand_branch (LEU, operands[0]); DONE;\")\n+\n+(define_expand \"bunordered\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_80387\"\n+  \"ix86_expand_branch (UNORDERED, operands[0]); DONE;\")\n+\n+(define_expand \"bordered\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_80387\"\n+  \"ix86_expand_branch (ORDERED, operands[0]); DONE;\")\n+\n+(define_expand \"buneq\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_80387\"\n+  \"ix86_expand_branch (UNEQ, operands[0]); DONE;\")\n+\n+(define_expand \"bunge\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_80387\"\n+  \"ix86_expand_branch (UNGE, operands[0]); DONE;\")\n+\n+(define_expand \"bungt\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_80387\"\n+  \"ix86_expand_branch (UNGT, operands[0]); DONE;\")\n+\n+(define_expand \"bunle\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_80387\"\n+  \"ix86_expand_branch (UNLE, operands[0]); DONE;\")\n+\n+(define_expand \"bunlt\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_80387\"\n+  \"ix86_expand_branch (UNLT, operands[0]); DONE;\")\n+\n+(define_expand \"bltgt\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_80387\"\n+  \"ix86_expand_branch (LTGT, operands[0]); DONE;\")\n \n (define_insn \"*jcc_1\"\n   [(set (pc)\n@@ -6815,7 +6927,7 @@\n \n (define_insn \"*jcc_3\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t(if_then_else (match_operator 0 \"uno_comparison_operator\"\n \t\t\t\t      [(reg:CC 17) (const_int 0)])\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n@@ -6832,7 +6944,7 @@\n \n (define_insn \"*jcc_4\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t(if_then_else (match_operator 0 \"uno_comparison_operator\"\n \t\t\t\t      [(reg:CC 17) (const_int 0)])\n \t\t      (pc)\n \t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n@@ -6846,6 +6958,139 @@\n \t\t\t       (const_int 124)))\n \t  (const_int 2)\n \t  (const_int 6)))])\n+\n+;; Define combination compare-and-branch fp compare instructions to use\n+;; during early optimization.  Splitting the operation apart early makes\n+;; for bad code when we want to reverse the operation.\n+\n+(define_insn \"*fp_jcc_1\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t[(match_operand 1 \"register_operand\" \"f\")\n+\t\t\t (match_operand 2 \"register_operand\" \"f\")])\n+\t  (label_ref (match_operand 3 \"\" \"\"))\n+\t  (pc)))\n+   (clobber (reg:CCFP 18))\n+   (clobber (reg:CCFP 17))]\n+  \"TARGET_CMOVE && TARGET_80387\n+   && FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n+  \"#\")\n+\n+(define_insn \"*fp_jcc_2\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t[(match_operand 1 \"register_operand\" \"f\")\n+\t\t\t (match_operand 2 \"register_operand\" \"f\")])\n+\t  (pc)\n+\t  (label_ref (match_operand 3 \"\" \"\"))))\n+   (clobber (reg:CCFP 18))\n+   (clobber (reg:CCFP 17))]\n+  \"TARGET_CMOVE && TARGET_80387\n+   && FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n+  \"#\")\n+\n+(define_insn \"*fp_jcc_3\"\n+  [(set (pc)\n+\t(if_then_else (match_operator:CCFP 0 \"comparison_operator\"\n+\t\t\t[(match_operand 1 \"register_operand\" \"f\")\n+\t\t\t (match_operand 2 \"nonimmediate_operand\" \"fm\")])\n+\t  (label_ref (match_operand 3 \"\" \"\"))\n+\t  (pc)))\n+   (clobber (reg:CCFP 18))\n+   (clobber (reg:CCFP 17))\n+   (clobber (match_scratch:HI 4 \"=a\"))]\n+  \"TARGET_80387\n+   && (GET_MODE (operands[1]) == SFmode || GET_MODE (operands[1]) == DFmode)\n+   && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n+  \"#\")\n+\n+(define_insn \"*fp_jcc_4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator:CCFP 0 \"comparison_operator\"\n+\t\t\t[(match_operand 1 \"register_operand\" \"f\")\n+\t\t\t (match_operand 2 \"nonimmediate_operand\" \"fm\")])\n+\t  (pc)\n+\t  (label_ref (match_operand 3 \"\" \"\"))))\n+   (clobber (reg:CCFP 18))\n+   (clobber (reg:CCFP 17))\n+   (clobber (match_scratch:HI 4 \"=a\"))]\n+  \"TARGET_80387\n+   && (GET_MODE (operands[1]) == SFmode || GET_MODE (operands[1]) == DFmode)\n+   && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n+  \"#\")\n+\n+(define_insn \"*fp_jcc_5\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t[(match_operand 1 \"register_operand\" \"f\")\n+\t\t\t (match_operand 2 \"register_operand\" \"f\")])\n+\t  (label_ref (match_operand 3 \"\" \"\"))\n+\t  (pc)))\n+   (clobber (reg:CCFP 18))\n+   (clobber (reg:CCFP 17))\n+   (clobber (match_scratch:HI 4 \"=a\"))]\n+  \"TARGET_80387\n+   && FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n+  \"#\")\n+\n+(define_insn \"*fp_jcc_6\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t[(match_operand 1 \"register_operand\" \"f\")\n+\t\t\t (match_operand 2 \"register_operand\" \"f\")])\n+\t  (pc)\n+\t  (label_ref (match_operand 3 \"\" \"\"))))\n+   (clobber (reg:CCFP 18))\n+   (clobber (reg:CCFP 17))\n+   (clobber (match_scratch:HI 4 \"=a\"))]\n+  \"TARGET_80387\n+   && FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n+  \"#\")\n+\n+(define_split\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t[(match_operand 1 \"register_operand\" \"\")\n+\t\t\t (match_operand 2 \"nonimmediate_operand\" \"\")])\n+\t  (match_operand 3 \"\" \"\")\n+\t  (match_operand 4 \"\" \"\")))\n+   (clobber (reg:CCFP 18))\n+   (clobber (reg:CCFP 17))]\n+  \"reload_completed\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 5)\n+\t  (match_dup 3)\n+\t  (match_dup 4)))]\n+  \"\n+{\n+  operands[5] = ix86_expand_fp_compare (GET_CODE (operands[0]), operands[1],\n+\t\t\t\t\toperands[2], NULL_RTX);\n+}\")\n+\n+(define_split\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t[(match_operand 1 \"register_operand\" \"\")\n+\t\t\t (match_operand 2 \"nonimmediate_operand\" \"\")])\n+\t  (match_operand 3 \"\" \"\")\n+\t  (match_operand 4 \"\" \"\")))\n+   (clobber (reg:CCFP 18))\n+   (clobber (reg:CCFP 17))\n+   (clobber (match_scratch:HI 5 \"=a\"))]\n+  \"reload_completed\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 6)\n+\t  (match_dup 3)\n+\t  (match_dup 4)))]\n+  \"\n+{\n+  operands[6] = ix86_expand_fp_compare (GET_CODE (operands[0]), operands[1],\n+\t\t\t\t\toperands[2], operands[5]);\n+}\")\n \f\n ;; Unconditional and other jump instructions\n \n@@ -8824,7 +9069,7 @@\n \n (define_insn \"*movsicc_c\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(if_then_else:SI (match_operator 1 \"comparison_operator\" \n+\t(if_then_else:SI (match_operator 1 \"uno_comparison_operator\" \n \t\t\t\t[(reg:CC 17) (const_int 0)])\n \t\t      (match_operand:SI 2 \"nonimmediate_operand\" \"rm,0\")\n \t\t      (match_operand:SI 3 \"nonimmediate_operand\" \"0,rm\")))]\n@@ -8858,7 +9103,7 @@\n \n (define_insn \"*movhicc_c\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(if_then_else:HI (match_operator 1 \"comparison_operator\" \n+\t(if_then_else:HI (match_operator 1 \"uno_comparison_operator\" \n \t\t\t\t[(reg:CC 17) (const_int 0)])\n \t\t      (match_operand:HI 2 \"nonimmediate_operand\" \"rm,0\")\n \t\t      (match_operand:HI 3 \"nonimmediate_operand\" \"0,rm\")))]"}, {"sha": "3acf5b1ecface2935b7744663c109849080d57c2", "filename": "gcc/genrecog.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3677ff46c5e086f59fdf7dc64e5eb09354bf25/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3677ff46c5e086f59fdf7dc64e5eb09354bf25/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=3a3677ff46c5e086f59fdf7dc64e5eb09354bf25", "patch": "@@ -211,7 +211,9 @@ static struct pred_table\n   {\"pop_operand\", {MEM}},\n   {\"memory_operand\", {SUBREG, MEM}},\n   {\"indirect_operand\", {SUBREG, MEM}},\n-  {\"comparison_operator\", {EQ, NE, LE, LT, GE, GT, LEU, LTU, GEU, GTU}},\n+  {\"comparison_operator\", {EQ, NE, LE, LT, GE, GT, LEU, LTU, GEU, GTU,\n+\t\t\t   UNORDERED, ORDERED, UNEQ, UNGE, UNGT, UNLE,\n+\t\t\t   UNLT, LTGT}},\n   {\"mode_independent_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\n \t\t\t\tLABEL_REF, SUBREG, REG, MEM}}\n };"}]}