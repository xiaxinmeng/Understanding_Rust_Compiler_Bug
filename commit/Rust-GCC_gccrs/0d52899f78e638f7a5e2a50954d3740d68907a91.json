{"sha": "0d52899f78e638f7a5e2a50954d3740d68907a91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ1Mjg5OWY3OGU2MzhmN2E1ZTJhNTA5NTRkMzc0MGQ2ODkwN2E5MQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2008-07-27T10:45:44Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2008-07-27T10:45:44Z"}, "message": "re PR fortran/36132 (_gfortran_internal_pack on optional arguments)\n\n2008-07-27  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/36132\n        PR fortran/29952\n        PR fortran/36909\n        * trans.c (gfc_trans_runtime_check): Allow run-time warning\n        * besides\n        run-time error.\n        * trans.h (gfc_trans_runtime_check): Update declaration.\n        * trans-array.c\n        * (gfc_trans_array_ctor_element,gfc_trans_array_bound_check,\n        gfc_conv_array_ref,gfc_conv_ss_startstride,gfc_trans_dummy_array_bias):\n        Updated gfc_trans_runtime_check calls.\n        (gfc_conv_array_parameter): Implement flag_check_array_temporaries,\n        fix packing/unpacking for nonpresent optional actuals to optional\n        formals.\n        * trans-array.h (gfc_conv_array_parameter): Update declaration.\n        * trans-expr.c (gfc_conv_substring,gfc_trans_arrayfunc_assign,\n        gfc_conv_function_call): Updated gfc_trans_runtime_check calls.\n        (gfc_conv_function_call): Update gfc_conv_array_parameter calls.\n        * trans-expr.c (gfc_trans_goto): Updated gfc_trans_runtime_check\n        calls.\n        * trans-io.c (set_string,gfc_conv_intrinsic_repeat): Ditto.\n        (gfc_conv_intrinsic_transfer,gfc_conv_intrinsic_loc): Same for\n        gfc_conv_array_parameter.\n        * trans-intrinsics.c (gfc_conv_intrinsic_bound): Ditto.\n        * trans-decl.c (gfc_build_builtin_function_decls): Add\n        gfor_fndecl_runtime_warning_at.\n        * lang.opt: New option fcheck-array-temporaries.\n        * gfortran.h (gfc_options): New flag_check_array_temporaries.\n        * options.c (gfc_init_options, gfc_handle_option): Handle flag.\n        * invoke.texi: New option fcheck-array-temporaries.\n\n2008-07-27  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/36132\n        PR fortran/29952\n        PR fortran/36909\n        * runtime/error.c: New function runtime_error_at.\n        * gfortran.map: Ditto.\n        * libgfortran.h: Ditto.\n\n2008-07-27  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/36132\n        PR fortran/29952\n        PR fortran/36909\n        gfortran.dg/internal_pack_4.f90: New.\n        gfortran.dg/internal_pack_5.f90: New.\n        gfortran.dg/array_temporaries_2.f90: New.\n\nFrom-SVN: r138186", "tree": {"sha": "d3c2ffda8f3516e7c1760aaa7f36971d80e86958", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3c2ffda8f3516e7c1760aaa7f36971d80e86958"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d52899f78e638f7a5e2a50954d3740d68907a91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d52899f78e638f7a5e2a50954d3740d68907a91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d52899f78e638f7a5e2a50954d3740d68907a91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d52899f78e638f7a5e2a50954d3740d68907a91/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5aab248830d3a030530dfa49a9f9b0f97178a74f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aab248830d3a030530dfa49a9f9b0f97178a74f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5aab248830d3a030530dfa49a9f9b0f97178a74f"}], "stats": {"total": 326, "additions": 285, "deletions": 41}, "files": [{"sha": "fd3cff552d39f7bfe96cec4eeabc726dfa82efcf", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -1,3 +1,34 @@\n+2008-07-27  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/36132\n+\tPR fortran/29952\n+\tPR fortran/36909\n+\t* trans.c (gfc_trans_runtime_check): Allow run-time warning besides\n+\trun-time error.\n+\t* trans.h (gfc_trans_runtime_check): Update declaration.\n+\t* trans-array.c (gfc_trans_array_ctor_element,gfc_trans_array_bound_check,\n+\tgfc_conv_array_ref,gfc_conv_ss_startstride,gfc_trans_dummy_array_bias):\n+\tUpdated gfc_trans_runtime_check calls.\n+\t(gfc_conv_array_parameter): Implement flag_check_array_temporaries,\n+\tfix packing/unpacking for nonpresent optional actuals to optional\n+\tformals.\n+\t* trans-array.h (gfc_conv_array_parameter): Update declaration.\n+\t* trans-expr.c (gfc_conv_substring,gfc_trans_arrayfunc_assign,\n+\tgfc_conv_function_call): Updated gfc_trans_runtime_check calls.\n+\t(gfc_conv_function_call): Update gfc_conv_array_parameter calls.\n+\t* trans-expr.c (gfc_trans_goto): Updated gfc_trans_runtime_check\n+\tcalls.\n+\t* trans-io.c (set_string,gfc_conv_intrinsic_repeat): Ditto.\n+\t(gfc_conv_intrinsic_transfer,gfc_conv_intrinsic_loc): Same for\n+\tgfc_conv_array_parameter.\n+\t* trans-intrinsics.c (gfc_conv_intrinsic_bound): Ditto.\n+\t* trans-decl.c (gfc_build_builtin_function_decls): Add\n+\tgfor_fndecl_runtime_warning_at.\n+\t* lang.opt: New option fcheck-array-temporaries.\n+\t* gfortran.h (gfc_options): New flag_check_array_temporaries.\n+\t* options.c (gfc_init_options, gfc_handle_option): Handle flag.\n+\t* invoke.texi: New option fcheck-array-temporaries.\n+\n 2008-07-24  Jan Hubicka  <jh@suse.cz>\n \n \t* fortran/options.c (gfc_post_options): Remove flag_unline_trees code."}, {"sha": "398a9a69acbf27dbf2092f9d8cbabfc26b9d39df", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -1895,6 +1895,7 @@ typedef struct\n   int flag_automatic;\n   int flag_backslash;\n   int flag_backtrace;\n+  int flag_check_array_temporaries;\n   int flag_allow_leading_underscore;\n   int flag_dump_core;\n   int flag_external_blas;"}, {"sha": "f633187a01cbdc2ae67467081dec165ccd97c62b", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -164,7 +164,7 @@ and warnings}.\n @xref{Code Gen Options,,Options for code generation conventions}.\n @gccoptlist{-fno-automatic  -ff2c  -fno-underscoring\n -fsecond-underscore @gol\n--fbounds-check  -fmax-stack-var-size=@var{n} @gol\n+-fbounds-check -fcheck-array-temporaries  -fmax-stack-var-size=@var{n} @gol\n -fpack-derived  -frepack-arrays  -fshort-enums  -fexternal-blas @gol\n -fblas-matmul-limit=@var{n} -frecursive -finit-local-zero @gol\n -finit-integer=@var{n} -finit-real=@var{<zero|inf|-inf|nan>} @gol\n@@ -1168,6 +1168,17 @@ the compilation of the main program.\n In the future this may also include other forms of checking, e.g., checking\n substring references.\n \n+\n+@item fcheck-array-temporaries\n+@opindex @code{fcheck-array-temporaries}\n+@cindex checking array temporaries\n+Warns at run time when for passing an actual argument a temporary array\n+had to be generated. The information generated by this warning is\n+sometimes useful in optimization, in order to avoid such temporaries.\n+\n+Note: The warning is only printed once per location.\n+\n+\n @item -fmax-stack-var-size=@var{n}\n @opindex @code{fmax-stack-var-size}\n This option specifies the size in bytes of the largest array that will be put"}, {"sha": "93211952c12d0479f503e7e14921f2e2e84b52e0", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -156,6 +156,10 @@ fblas-matmul-limit=\n Fortran RejectNegative Joined UInteger\n -fblas-matmul-limit=<n>        Size of the smallest matrix for which matmul will use BLAS\n \n+fcheck-array-temporaries\n+Fortran\n+Produce a warning at runtime if a array temporary has been created for a procedure argument\n+\n fconvert=big-endian\n Fortran RejectNegative\n Use big-endian format for unformatted files"}, {"sha": "1f05f35359ffd6245d944f99caa1cc2217c2364c", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -101,6 +101,7 @@ gfc_init_options (unsigned int argc, const char **argv)\n   gfc_option.flag_backslash = 0;\n   gfc_option.flag_module_private = 0;\n   gfc_option.flag_backtrace = 0;\n+  gfc_option.flag_check_array_temporaries = 0;\n   gfc_option.flag_allow_leading_underscore = 0;\n   gfc_option.flag_dump_core = 0;\n   gfc_option.flag_external_blas = 0;\n@@ -540,6 +541,10 @@ gfc_handle_option (size_t scode, const char *arg, int value)\n       gfc_option.flag_backtrace = value;\n       break;\n       \n+    case OPT_fcheck_array_temporaries:\n+      gfc_option.flag_check_array_temporaries = value;\n+      break;\n+      \n     case OPT_fdump_core:\n       gfc_option.flag_dump_core = value;\n       break;"}, {"sha": "14bab8ead537fecf20795c55ccb80d3cb547e033", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 70, "deletions": 16, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -1022,7 +1022,7 @@ gfc_trans_array_ctor_element (stmtblock_t * pblock, tree desc,\n \t      tree cond = fold_build2 (NE_EXPR, boolean_type_node,\n \t\t\t\t       first_len_val, se->string_length);\n \t      gfc_trans_runtime_check\n-\t\t(cond, &se->pre, &expr->where,\n+\t\t(true, false, cond, &se->pre, &expr->where,\n \t\t \"Different CHARACTER lengths (%ld/%ld) in array constructor\",\n \t\t fold_convert (long_integer_type_node, first_len_val),\n \t\t fold_convert (long_integer_type_node, se->string_length));\n@@ -2235,7 +2235,7 @@ gfc_trans_array_bound_check (gfc_se * se, tree descriptor, tree index, int n,\n   else\n     asprintf (&msg, \"%s, lower bound of dimension %d exceeded (%%ld < %%ld)\",\n \t      gfc_msg_fault, n+1);\n-  gfc_trans_runtime_check (fault, &se->pre, where, msg,\n+  gfc_trans_runtime_check (true, false, fault, &se->pre, where, msg,\n \t\t\t   fold_convert (long_integer_type_node, index),\n \t\t\t   fold_convert (long_integer_type_node, tmp));\n   gfc_free (msg);\n@@ -2251,7 +2251,7 @@ gfc_trans_array_bound_check (gfc_se * se, tree descriptor, tree index, int n,\n       else\n \tasprintf (&msg, \"%s, upper bound of dimension %d exceeded (%%ld > %%ld)\",\n \t\t  gfc_msg_fault, n+1);\n-      gfc_trans_runtime_check (fault, &se->pre, where, msg,\n+      gfc_trans_runtime_check (true, false, fault, &se->pre, where, msg,\n \t\t\t       fold_convert (long_integer_type_node, index),\n \t\t\t       fold_convert (long_integer_type_node, tmp));\n       gfc_free (msg);\n@@ -2445,7 +2445,7 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,\n \t  asprintf (&msg, \"%s for array '%s', \"\n \t            \"lower bound of dimension %d exceeded (%%ld < %%ld)\",\n \t\t    gfc_msg_fault, sym->name, n+1);\n-\t  gfc_trans_runtime_check (cond, &se->pre, where, msg,\n+\t  gfc_trans_runtime_check (true, false, cond, &se->pre, where, msg,\n \t\t\t\t   fold_convert (long_integer_type_node,\n \t\t\t\t\t\t indexse.expr),\n \t\t\t\t   fold_convert (long_integer_type_node, tmp));\n@@ -2462,7 +2462,7 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,\n \t      asprintf (&msg, \"%s for array '%s', \"\n \t\t\t\"upper bound of dimension %d exceeded (%%ld > %%ld)\",\n \t\t\tgfc_msg_fault, sym->name, n+1);\n-\t      gfc_trans_runtime_check (cond, &se->pre, where, msg,\n+\t      gfc_trans_runtime_check (true, false, cond, &se->pre, where, msg,\n \t\t\t\t   fold_convert (long_integer_type_node,\n \t\t\t\t\t\t indexse.expr),\n \t\t\t\t   fold_convert (long_integer_type_node, tmp));\n@@ -3026,7 +3026,8 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      asprintf (&msg, \"Zero stride is not allowed, for dimension %d \"\n \t\t\t\"of array '%s'\", info->dim[n]+1,\n \t\t\tss->expr->symtree->name);\n-\t      gfc_trans_runtime_check (tmp, &inner, &ss->expr->where, msg);\n+\t      gfc_trans_runtime_check (true, false, tmp, &inner,\n+\t\t\t\t       &ss->expr->where, msg);\n \t      gfc_free (msg);\n \n \t      desc = ss->data.info.descriptor;\n@@ -3068,7 +3069,8 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      asprintf (&msg, \"%s, lower bound of dimension %d of array '%s'\"\n \t\t\t\" exceeded (%%ld < %%ld)\", gfc_msg_fault,\n \t\t\tinfo->dim[n]+1, ss->expr->symtree->name);\n-\t      gfc_trans_runtime_check (tmp, &inner, &ss->expr->where, msg,\n+\t      gfc_trans_runtime_check (true, false, tmp, &inner,\n+\t\t\t\t       &ss->expr->where, msg,\n \t\t\t\t       fold_convert (long_integer_type_node,\n \t\t\t\t\t\t     info->start[n]),\n \t\t\t\t       fold_convert (long_integer_type_node,\n@@ -3084,7 +3086,8 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t          asprintf (&msg, \"%s, upper bound of dimension %d of array \"\n \t\t\t    \"'%s' exceeded (%%ld > %%ld)\", gfc_msg_fault,\n \t\t\t    info->dim[n]+1, ss->expr->symtree->name);\n-\t\t  gfc_trans_runtime_check (tmp, &inner, &ss->expr->where, msg,\n+\t\t  gfc_trans_runtime_check (true, false, tmp, &inner,\n+\t\t\t&ss->expr->where, msg,\n \t\t\tfold_convert (long_integer_type_node, info->start[n]),\n \t\t\tfold_convert (long_integer_type_node, ubound));\n \t\t  gfc_free (msg);\n@@ -3106,7 +3109,8 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      asprintf (&msg, \"%s, lower bound of dimension %d of array '%s'\"\n \t\t\t\" exceeded (%%ld < %%ld)\", gfc_msg_fault,\n \t\t\tinfo->dim[n]+1, ss->expr->symtree->name);\n-\t      gfc_trans_runtime_check (tmp, &inner, &ss->expr->where, msg,\n+\t      gfc_trans_runtime_check (true, false, tmp, &inner,\n+\t\t\t\t       &ss->expr->where, msg,\n \t\t\t\t       fold_convert (long_integer_type_node,\n \t\t\t\t\t\t     tmp2),\n \t\t\t\t       fold_convert (long_integer_type_node,\n@@ -3121,7 +3125,8 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t  asprintf (&msg, \"%s, upper bound of dimension %d of array \"\n \t\t\t    \"'%s' exceeded (%%ld > %%ld)\", gfc_msg_fault,\n \t\t\t    info->dim[n]+1, ss->expr->symtree->name);\n-\t\t  gfc_trans_runtime_check (tmp, &inner, &ss->expr->where, msg,\n+\t\t  gfc_trans_runtime_check (true, false, tmp, &inner,\n+\t\t\t&ss->expr->where, msg,\n \t\t\tfold_convert (long_integer_type_node, tmp2),\n \t\t\tfold_convert (long_integer_type_node, ubound));\n \t\t  gfc_free (msg);\n@@ -3144,7 +3149,8 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t  asprintf (&msg, \"%s, size mismatch for dimension %d \"\n \t\t\t    \"of array '%s' (%%ld/%%ld)\", gfc_msg_bounds,\n \t\t\t    info->dim[n]+1, ss->expr->symtree->name);\n-\t\t  gfc_trans_runtime_check (tmp3, &inner, &ss->expr->where, msg,\n+\t\t  gfc_trans_runtime_check (true, false, tmp3, &inner,\n+\t\t\t\t\t   &ss->expr->where, msg,\n \t\t\tfold_convert (long_integer_type_node, tmp),\n \t\t\tfold_convert (long_integer_type_node, size[n]));\n \t\t  gfc_free (msg);\n@@ -4383,7 +4389,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n               tmp = fold_build2 (NE_EXPR, gfc_array_index_type, tmp, stride2);\n \t      asprintf (&msg, \"%s for dimension %d of array '%s'\",\n \t\t\tgfc_msg_bounds, n+1, sym->name);\n-\t      gfc_trans_runtime_check (tmp, &block, &loc, msg);\n+\t      gfc_trans_runtime_check (true, false, tmp, &block, &loc, msg);\n \t      gfc_free (msg);\n \t    }\n \t}\n@@ -5133,7 +5139,8 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n /* TODO: Optimize passing g77 arrays.  */\n \n void\n-gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77)\n+gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77,\n+\t\t\t  const gfc_symbol *fsym, const char *proc_name)\n {\n   tree ptr;\n   tree desc;\n@@ -5230,17 +5237,59 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77)\n       /* Repack the array.  */\n \n       if (gfc_option.warn_array_temp)\n-\tgfc_warning (\"Creating array temporary at %L\", &expr->where);\n+\t{\n+\t  if (fsym)\n+\t    gfc_warning (\"Creating array temporary at %L for argument '%s'\",\n+\t\t\t &expr->where, fsym->name);\n+\t  else\n+\t    gfc_warning (\"Creating array temporary at %L\", &expr->where);\n+\t}\n \n       ptr = build_call_expr (gfor_fndecl_in_pack, 1, desc);\n+\n+      if (fsym && fsym->attr.optional && sym && sym->attr.optional)\n+\t{\n+\t  tmp = gfc_conv_expr_present (sym);\n+\t  ptr = build3 (COND_EXPR, TREE_TYPE (se->expr), tmp, ptr,\n+\t\t\tnull_pointer_node);\n+\t}\n+\n       ptr = gfc_evaluate_now (ptr, &se->pre);\n+\n       se->expr = ptr;\n \n+      if (gfc_option.flag_check_array_temporaries)\n+\t{\n+\t  char * msg;\n+\n+\t  if (fsym && proc_name)\n+\t    asprintf (&msg, \"An array temporary was created for argument \"\n+\t\t      \"'%s' of procedure '%s'\", fsym->name, proc_name);\n+\t  else\n+\t    asprintf (&msg, \"An array temporary was created\");\n+\n+\t  tmp = build_fold_indirect_ref (desc);\n+\t  tmp = gfc_conv_array_data (tmp);\n+\t  tmp = fold_build2 (NE_EXPR, boolean_type_node,\n+\t\t\t     fold_convert (TREE_TYPE (tmp), ptr), tmp);\n+\n+\t  if (fsym && fsym->attr.optional && sym && sym->attr.optional)\n+\t    tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t       gfc_conv_expr_present (sym), tmp);\n+\n+\t  gfc_trans_runtime_check (false, true, tmp, &se->pre,\n+\t\t\t\t   &expr->where, msg);\n+\t  gfc_free (msg);\n+\t}\n+\n       gfc_start_block (&block);\n \n       /* Copy the data back.  */\n-      tmp = build_call_expr (gfor_fndecl_in_unpack, 2, desc, ptr);\n-      gfc_add_expr_to_block (&block, tmp);\n+      if (fsym == NULL || fsym->attr.intent != INTENT_IN)\n+\t{\n+\t  tmp = build_call_expr (gfor_fndecl_in_unpack, 2, desc, ptr);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n \n       /* Free the temporary.  */\n       tmp = gfc_call_free (convert (pvoid_type_node, ptr));\n@@ -5255,6 +5304,11 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77)\n       tmp = gfc_conv_array_data (tmp);\n       tmp = fold_build2 (NE_EXPR, boolean_type_node,\n \t\t\t fold_convert (TREE_TYPE (tmp), ptr), tmp);\n+\n+      if (fsym && fsym->attr.optional && sym && sym->attr.optional)\n+\ttmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t   gfc_conv_expr_present (sym), tmp);\n+\n       tmp = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n \n       gfc_add_expr_to_block (&block, tmp);"}, {"sha": "145f4a825657639d85ef1c62735e21e35d682e1d", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -105,7 +105,8 @@ void gfc_conv_tmp_ref (gfc_se *);\n /* Evaluate an array expression.  */\n void gfc_conv_expr_descriptor (gfc_se *, gfc_expr *, gfc_ss *);\n /* Convert an array for passing as an actual function parameter.  */\n-void gfc_conv_array_parameter (gfc_se *, gfc_expr *, gfc_ss *, int);\n+void gfc_conv_array_parameter (gfc_se *, gfc_expr *, gfc_ss *, int,\n+\t\t\t       const gfc_symbol *, const char *);\n /* Evaluate and transpose a matrix expression.  */\n void gfc_conv_array_transpose (gfc_se *, gfc_expr *);\n "}, {"sha": "d2cb6a319c7c24f21d4e2de125e634e4dfba5c16", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -79,6 +79,7 @@ tree gfor_fndecl_stop_numeric;\n tree gfor_fndecl_stop_string;\n tree gfor_fndecl_runtime_error;\n tree gfor_fndecl_runtime_error_at;\n+tree gfor_fndecl_runtime_warning_at;\n tree gfor_fndecl_os_error;\n tree gfor_fndecl_generate_error;\n tree gfor_fndecl_set_fpe;\n@@ -2455,6 +2456,10 @@ gfc_build_builtin_function_decls (void)\n   /* The runtime_error_at function does not return.  */\n   TREE_THIS_VOLATILE (gfor_fndecl_runtime_error_at) = 1;\n   \n+  gfor_fndecl_runtime_warning_at =\n+    gfc_build_library_function_decl (get_identifier (PREFIX(\"runtime_warning_at\")),\n+\t\t\t\t     void_type_node, -2, pchar_type_node,\n+\t\t\t\t     pchar_type_node);\n   gfor_fndecl_generate_error =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"generate_error\")),\n \t\t\t\t     void_type_node, 3, pvoid_type_node,"}, {"sha": "e145c0ca01c118ce7b818930fd0b16b012987a83", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -328,7 +328,7 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n       else\n \tasprintf (&msg, \"Substring out of bounds: lower bound (%%ld)\"\n \t\t  \"is less than one\");\n-      gfc_trans_runtime_check (fault, &se->pre, where, msg,\n+      gfc_trans_runtime_check (true, false, fault, &se->pre, where, msg,\n \t\t\t       fold_convert (long_integer_type_node,\n \t\t\t\t\t     start.expr));\n       gfc_free (msg);\n@@ -344,7 +344,7 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n       else\n \tasprintf (&msg, \"Substring out of bounds: upper bound (%%ld) \"\n \t\t  \"exceeds string length (%%ld)\");\n-      gfc_trans_runtime_check (fault, &se->pre, where, msg,\n+      gfc_trans_runtime_check (true, false, fault, &se->pre, where, msg,\n \t\t\t       fold_convert (long_integer_type_node, end.expr),\n \t\t\t       fold_convert (long_integer_type_node,\n \t\t\t\t\t     se->string_length));\n@@ -2299,7 +2299,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t      f = f || !sym->attr.always_explicit;\n \t  \n \t      argss = gfc_walk_expr (arg->expr);\n-\t      gfc_conv_array_parameter (se, arg->expr, argss, f);\n+\t      gfc_conv_array_parameter (se, arg->expr, argss, f, NULL, NULL);\n \t    }\n \n \t  /* TODO -- the following two lines shouldn't be necessary, but\n@@ -2535,7 +2535,8 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t\tgfc_conv_subref_array_arg (&parmse, e, f,\n \t\t\tfsym ? fsym->attr.intent : INTENT_INOUT);\n \t      else\n-\t        gfc_conv_array_parameter (&parmse, e, argss, f);\n+\t        gfc_conv_array_parameter (&parmse, e, argss, f, fsym,\n+\t\t\t\t\t  sym->name);\n \n               /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is \n                  allocated on entry, it must be deallocated.  */\n@@ -2836,7 +2837,8 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t\t  tmp = gfc_conv_descriptor_data_get (info->descriptor);\n \t\t  tmp = fold_build2 (NE_EXPR, boolean_type_node,\n \t\t\t\t     tmp, info->data);\n-\t\t  gfc_trans_runtime_check (tmp, &se->pre, NULL, gfc_msg_fault);\n+\t\t  gfc_trans_runtime_check (true, false, tmp, &se->pre, NULL,\n+\t\t\t\t\t   gfc_msg_fault);\n \t\t}\n \t      se->expr = info->descriptor;\n \t      /* Bundle in the string length.  */\n@@ -4143,7 +4145,7 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n   gfc_start_block (&se.pre);\n   se.want_pointer = 1;\n \n-  gfc_conv_array_parameter (&se, expr1, ss, 0);\n+  gfc_conv_array_parameter (&se, expr1, ss, 0, NULL, NULL);\n \n   se.direct_byref = 1;\n   se.ss = gfc_walk_expr (expr2);"}, {"sha": "2dc2d4f7a9857296daff15788610fbbe1b17635d", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -864,7 +864,8 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n           tmp = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (TREE_TYPE (desc))];\n           tmp = fold_build2 (GE_EXPR, boolean_type_node, bound, tmp);\n           cond = fold_build2 (TRUTH_ORIF_EXPR, boolean_type_node, cond, tmp);\n-          gfc_trans_runtime_check (cond, &se->pre, &expr->where, gfc_msg_fault);\n+          gfc_trans_runtime_check (true, false, cond, &se->pre, &expr->where,\n+\t\t\t\t   gfc_msg_fault);\n         }\n     }\n \n@@ -3632,7 +3633,7 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n   if (ss == gfc_ss_terminator)\n     gfc_conv_expr_reference (&argse, arg->expr);\n   else\n-    gfc_conv_array_parameter (&argse, arg->expr, ss, 1);\n+    gfc_conv_array_parameter (&argse, arg->expr, ss, 1, NULL, NULL);\n   gfc_add_block_to_block (&se->pre, &argse.pre);\n   gfc_add_block_to_block (&se->post, &argse.post);\n   ptr = argse.expr;\n@@ -3958,7 +3959,7 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n   /* Check that NCOPIES is not negative.  */\n   cond = fold_build2 (LT_EXPR, boolean_type_node, ncopies,\n \t\t      build_int_cst (ncopies_type, 0));\n-  gfc_trans_runtime_check (cond, &se->pre, &expr->where,\n+  gfc_trans_runtime_check (true, false, cond, &se->pre, &expr->where,\n \t\t\t   \"Argument NCOPIES of REPEAT intrinsic is negative \"\n \t\t\t   \"(its value is %lld)\",\n \t\t\t   fold_convert (long_integer_type_node, ncopies));\n@@ -3990,7 +3991,7 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n \t\t     build_int_cst (size_type_node, 0));\n   cond = fold_build3 (COND_EXPR, boolean_type_node, tmp, boolean_false_node,\n \t\t      cond);\n-  gfc_trans_runtime_check (cond, &se->pre, &expr->where,\n+  gfc_trans_runtime_check (true, false, cond, &se->pre, &expr->where,\n \t\t\t   \"Argument NCOPIES of REPEAT intrinsic is too large\");\n \n   /* Compute the destination length.  */\n@@ -4094,7 +4095,7 @@ gfc_conv_intrinsic_loc (gfc_se * se, gfc_expr * expr)\n   if (ss == gfc_ss_terminator)\n     gfc_conv_expr_reference (se, arg_expr);\n   else\n-    gfc_conv_array_parameter (se, arg_expr, ss, 1); \n+    gfc_conv_array_parameter (se, arg_expr, ss, 1, NULL, NULL); \n   se->expr= convert (gfc_get_int_type (gfc_index_integer_kind), se->expr);\n    \n   /* Create a temporary variable for loc return value.  Without this, "}, {"sha": "3d17a4c77da0bed83a357a284be5739b75f0994d", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -668,7 +668,7 @@ set_string (stmtblock_t * block, stmtblock_t * postblock, tree var,\n \n       asprintf(&msg, \"Label assigned to variable '%s' (%%ld) is not a format \"\n \t       \"label\", e->symtree->name);\n-      gfc_trans_runtime_check (cond, &se.pre, &e->where, msg,\n+      gfc_trans_runtime_check (true, false, cond, &se.pre, &e->where, msg,\n \t\t\t       fold_convert (long_integer_type_node, tmp));\n       gfc_free (msg);\n "}, {"sha": "79a1446ebf1b3c13707b95d110a35d5e25fb0521", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -154,7 +154,7 @@ gfc_trans_goto (gfc_code * code)\n   tmp = GFC_DECL_STRING_LEN (se.expr);\n   tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp,\n \t\t     build_int_cst (TREE_TYPE (tmp), -1));\n-  gfc_trans_runtime_check (tmp, &se.pre, &loc,\n+  gfc_trans_runtime_check (true, false, tmp, &se.pre, &loc,\n \t\t\t   \"Assigned label is not a target label\");\n \n   assigned_goto = GFC_DECL_ASSIGN_ADDR (se.expr);\n@@ -180,7 +180,7 @@ gfc_trans_goto (gfc_code * code)\n       code = code->block;\n     }\n   while (code != NULL);\n-  gfc_trans_runtime_check (boolean_true_node, &se.pre, &loc,\n+  gfc_trans_runtime_check (true, false, boolean_true_node, &se.pre, &loc,\n \t\t\t   \"Assigned label is not in the list\");\n \n   return gfc_finish_block (&se.pre); "}, {"sha": "d6aef8769e7c22fb40b211fe970a627a2f20e08f", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -351,13 +351,14 @@ gfc_build_array_ref (tree base, tree offset, tree decl)\n /* Generate a runtime error if COND is true.  */\n \n void\n-gfc_trans_runtime_check (tree cond, stmtblock_t * pblock, locus * where,\n-\t\t\t const char * msgid, ...)\n+gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n+\t\t     locus * where, const char * msgid, ...)\n {\n   va_list ap;\n   stmtblock_t block;\n   tree body;\n   tree tmp;\n+  tree tmpvar = NULL;\n   tree arg, arg2;\n   tree *argarray;\n   tree fntype;\n@@ -377,6 +378,14 @@ gfc_trans_runtime_check (tree cond, stmtblock_t * pblock, locus * where,\n \t  nargs++;\n       }\n \n+  if (once)\n+    {\n+       tmpvar = gfc_create_var (boolean_type_node, \"print_warning\");\n+       TREE_STATIC (tmpvar) = 1;\n+       DECL_INITIAL (tmpvar) = boolean_true_node;\n+       gfc_add_expr_to_block (pblock, tmpvar);\n+    }\n+\n   /* The code to generate the error.  */\n   gfc_start_block (&block);\n \n@@ -408,16 +417,25 @@ gfc_trans_runtime_check (tree cond, stmtblock_t * pblock, locus * where,\n     argarray[2+i] = va_arg (ap, tree);\n   va_end (ap);\n   \n-  /* Build the function call to runtime_error_at; because of the variable\n-     number of arguments, we can't use build_call_expr directly.  */\n-  fntype = TREE_TYPE (gfor_fndecl_runtime_error_at);\n+  /* Build the function call to runtime_(warning,error)_at; because of the\n+     variable number of arguments, we can't use build_call_expr directly.  */\n+  if (error)\n+    fntype = TREE_TYPE (gfor_fndecl_runtime_error_at);\n+  else\n+    fntype = TREE_TYPE (gfor_fndecl_runtime_warning_at);\n+\n   tmp = fold_builtin_call_array (TREE_TYPE (fntype),\n \t\t\t\t fold_build1 (ADDR_EXPR,\n \t\t\t\t\t      build_pointer_type (fntype),\n-\t\t\t\t\t      gfor_fndecl_runtime_error_at),\n+\t\t\t\t\t      error\n+\t\t\t\t\t      ? gfor_fndecl_runtime_error_at\n+\t\t\t\t\t      : gfor_fndecl_runtime_warning_at),\n \t\t\t\t nargs + 2, argarray);\n   gfc_add_expr_to_block (&block, tmp);\n \n+  if (once)\n+    gfc_add_modify_expr (&block, tmpvar, boolean_false_node);\n+\n   body = gfc_finish_block (&block);\n \n   if (integer_onep (cond))\n@@ -427,7 +445,12 @@ gfc_trans_runtime_check (tree cond, stmtblock_t * pblock, locus * where,\n   else\n     {\n       /* Tell the compiler that this isn't likely.  */\n-      cond = fold_convert (long_integer_type_node, cond);\n+      if (once)\n+\tcond = fold_build2 (TRUTH_AND_EXPR, long_integer_type_node, tmpvar,\n+\t\t\t    cond);\n+      else\n+\tcond = fold_convert (long_integer_type_node, cond);\n+\n       tmp = build_int_cst (long_integer_type_node, 0);\n       cond = build_call_expr (built_in_decls[BUILT_IN_EXPECT], 2, cond, tmp);\n       cond = fold_convert (boolean_type_node, cond);"}, {"sha": "7704748d3050caf9e39b362fbb399de7ca2e68d7", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -444,8 +444,9 @@ void gfc_generate_constructors (void);\n /* Get the string length of an array constructor.  */\n bool get_array_ctor_strlen (stmtblock_t *, gfc_constructor *, tree *);\n \n-/* Generate a runtime error check.  */\n-void gfc_trans_runtime_check (tree, stmtblock_t *, locus *, const char *, ...);\n+/* Generate a runtime warning/error check.  */\n+void gfc_trans_runtime_check (bool, bool, tree, stmtblock_t *, locus *,\n+\t\t\t      const char *, ...);\n \n /* Generate a call to free() after checking that its arg is non-NULL.  */\n tree gfc_call_free (tree);\n@@ -510,6 +511,7 @@ extern GTY(()) tree gfor_fndecl_stop_numeric;\n extern GTY(()) tree gfor_fndecl_stop_string;\n extern GTY(()) tree gfor_fndecl_runtime_error;\n extern GTY(()) tree gfor_fndecl_runtime_error_at;\n+extern GTY(()) tree gfor_fndecl_runtime_warning_at;\n extern GTY(()) tree gfor_fndecl_os_error;\n extern GTY(()) tree gfor_fndecl_generate_error;\n extern GTY(()) tree gfor_fndecl_set_fpe;"}, {"sha": "7bdc31bbeaad21e7dd191df715c3fd0f7ac2b927", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -1,3 +1,12 @@\n+2008-07-27  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/36132\n+\tPR fortran/29952\n+\tPR fortran/36909\n+\tgfortran.dg/internal_pack_4.f90: New.\n+\tgfortran.dg/internal_pack_5.f90: New.\n+\tgfortran.dg/array_temporaries_2.f90: New.\n+\n 2008-07-26  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/36934"}, {"sha": "86e0a45e712b900222e15e083a299434de9131d9", "filename": "gcc/testsuite/gfortran.dg/array_temporaries_2.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_temporaries_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_temporaries_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_temporaries_2.f90?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do run }\n+! { dg-options \"-fcheck-array-temporaries\" }\n+ program test\n+  implicit none\n+  integer :: a(3,3)\n+  call foo(a(:,1))  ! OK, no temporary created\n+  call foo(a(1,:))  ! BAD, temporary var created\n+contains\n+  subroutine foo(x)\n+    integer :: x(3)\n+    x = 5\n+  end subroutine foo\n+end program test\n+\n+! { dg-output \"At line 7 of file .*array_temporaries_2.f90(\\n|\\r\\n|\\r)Fortran runtime warning: An array temporary was created for argument 'x' of procedure 'foo'\" }"}, {"sha": "049931a4f4f824987632234e584c03138ce6a8e1", "filename": "gcc/testsuite/gfortran.dg/internal_pack_4.f90", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_4.f90?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! PR fortran/36132\n+!\n+! Before invalid memory was accessed because an absent, optional\n+! argument was packed before passing it as absent actual.\n+! Getting it to crash is difficult, but valgrind shows the problem.\n+!\n+MODULE M1\n+  INTEGER, PARAMETER :: dp=KIND(0.0D0)\n+CONTAINS\n+  SUBROUTINE S1(a)\n+         REAL(dp), DIMENSION(45), INTENT(OUT), &\n+      OPTIONAL                               :: a\n+      if (present(a)) call abort()\n+  END SUBROUTINE S1\n+  SUBROUTINE S2(a)\n+          REAL(dp), DIMENSION(:, :), INTENT(OUT), &\n+      OPTIONAL                               :: a\n+      CALL S1(a)\n+  END SUBROUTINE\n+END MODULE M1\n+\n+USE M1\n+CALL S2()\n+END\n+\n+! { dg-final { scan-tree-dump-times \"a != 0B \\\\? _gfortran_internal_pack\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"if \\\\(a != 0B &&\" 1 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "87705fa716aa7f37a5d582c3740b019174edca67", "filename": "gcc/testsuite/gfortran.dg/internal_pack_5.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_5.f90?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! PR fortran/36909\n+!\n+! Check that no unneeded internal_unpack is\n+! called (INTENT(IN)!).\n+!\n+program test\n+  implicit none\n+  integer :: a(3,3)\n+  call foo(a(1,:))\n+contains\n+  subroutine foo(x)\n+    integer,intent(in) :: x(3)\n+  end subroutine foo\n+end program test\n+\n+! { dg-final { scan-tree-dump-times \"_gfortran_internal_pack\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_internal_unpack\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "0eb171ce4b0b35a53abdc7041ccf573079897fdf", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -1,3 +1,12 @@\n+2008-07-27  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/36132\n+\tPR fortran/29952\n+\tPR fortran/36909\n+\t* runtime/error.c: New function runtime_error_at.\n+\t* gfortran.map: Ditto.\n+\t* libgfortran.h: Ditto.\n+\n 2008-07-22  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/36852"}, {"sha": "93973d5b338f7cf064f11a5f7a7478b486577b46", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -1072,6 +1072,7 @@ GFORTRAN_1.1 {\n     _gfortran_pack_char4;\n     _gfortran_pack_s_char4;\n     _gfortran_reshape_char4;\n+    _gfortran_runtime_warning_at;\n     _gfortran_selected_char_kind;\n     _gfortran_select_string_char4;\n     _gfortran_spread_char4;"}, {"sha": "7c497004a814db28f7457e45f5d764f208b5faa7", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -643,6 +643,9 @@ extern void runtime_error_at (const char *, const char *, ...)\n      __attribute__ ((noreturn, format (printf, 2, 3)));\n iexport_proto(runtime_error_at);\n \n+extern void runtime_warning_at (const char *, const char *, ...);\n+iexport_proto(runtime_warning_at);\n+\n extern void internal_error (st_parameter_common *, const char *)\n   __attribute__ ((noreturn));\n internal_proto(internal_error);"}, {"sha": "0b9c16705eb5d44c6efd78765f9638a591f24158", "filename": "libgfortran/runtime/error.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52899f78e638f7a5e2a50954d3740d68907a91/libgfortran%2Fruntime%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52899f78e638f7a5e2a50954d3740d68907a91/libgfortran%2Fruntime%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Ferror.c?ref=0d52899f78e638f7a5e2a50954d3740d68907a91", "patch": "@@ -285,6 +285,21 @@ runtime_error_at (const char *where, const char *message, ...)\n iexport(runtime_error_at);\n \n \n+void\n+runtime_warning_at (const char *where, const char *message, ...)\n+{\n+  va_list ap;\n+\n+  st_printf (\"%s\\n\", where);\n+  st_printf (\"Fortran runtime warning: \");\n+  va_start (ap, message);\n+  st_vprintf (message, ap);\n+  va_end (ap);\n+  st_printf (\"\\n\");\n+}\n+iexport(runtime_warning_at);\n+\n+\n /* void internal_error()-- These are this-can't-happen errors\n  * that indicate something deeply wrong. */\n "}]}