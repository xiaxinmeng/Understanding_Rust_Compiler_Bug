{"sha": "60b85c4c0e161c6e2fe58c70454cb46d553dbe83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBiODVjNGMwZTE2MWM2ZTJmZTU4YzcwNDU0Y2I0NmQ1NTNkYmU4Mw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2004-02-03T12:36:23Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2004-02-03T12:36:23Z"}, "message": "invoke.texi (SPARC options): Remove -mflat and all -mxxx (xxx:chip) options.\n\n\t* doc/invoke.texi (SPARC options): Remove -mflat and\n\tall -mxxx (xxx:chip) options.\n\t* config/sparc/aout.h (DBX_REGISTER_NUMBER): Delete.\n\t* config/sparc/litecoff.h (DBX_REGISTER_NUMBER): Likewise.\n\t* config/sparc/netbsd-elf.h (DBX_REGISTER_NUMBER): Likewise.\n\t* config/sparc/sol2.h (DBX_REGISTER_NUMBER): Likewise.\n\t* config/sparc/sparc-protos.h: Delete sparc_flat_* prototypes.\n\t* config/sparc/sparc.c: Likewise.\n\t(sparc_output_function_prologue): Remove TARGET_FLAT handling.\n\t(sparc_nonflat_function_prologue): Rename into sparc_function_prologue.\n\t(sparc_output_function_epilogue): Remove TARGET_FLAT handling.\n\t(sparc_nonflat_function_epilogue): Rename into sparc_function_epilogue.\n\t(struct sparc_frame_info, current_frame_info, zero_frame_info): Delete.\n\t(sparc_flat_must_save_register_p): Likewise.\n\t(sparc_flat_compute_frame_size): Likewise.\n\t(sparc_flat_save_restore): Likewise.\n\t(sparc_flat_function_prologue): Likewise.\n\t(sparc_flat_function_epilogue): Likewise.\n\t(sparc_flat_epilogue_delay_slots): Likewise.\n\t(sparc_flat_eligible_for_epilogue_delay): Likewise.\n\t(sparc_function_ok_for_sibcall): Remove TARGET_FLAT handling.\n\t* config/sparc/sparc.h (MASK_FLAT, TARGET_FLAT): Delete.\n\t(TARGET_SWITCHES): Remove -mflat and all -mxxx (xxx:chip) options.\n\t(SPARC_INCOMING_INT_ARG_FIRST): Remove TARGET_FLAT handling.\n\t(CONDITIONAL_REGISTER_USAGE): Likewise.\n\t(FRAME_POINTER_REQUIRED): Likewise.\n\t(INITIAL_ELIMINATION_OFFSET): Likewise.\n\t(BASE_RETURN_VALUE_REG): Likewise.\n\t(BASE_OUTGOING_VALUE_REG): Likewise.\n\t(BASE_PASSING_ARG_REG): Likewise.\n\t(BASE_INCOMING_ARG_REG): Likewise.\n\t(INCOMING_REGNO): Likewise.\n\t(OUTGOING_REGNO): Likewise.\n\t(LOCAL_REGNO): Likewise.\n\t(DELAY_SLOTS_FOR_EPILOGUE): Likewise.\n\t(ELIGIBLE_FOR_EPILOGUE_DELAY): Likewise.\n\t(EPILOGUE_USES): Likewise.\n\t* config/sparc/sparc.md (\"isa\" attribute): Change \"v6\" into \"v7\".\n\t(\"flat\" attribute): Delete.\n\t(do_builtin_setjmp_setup): Remove TARGET_FLAT and \"flat\" attribute\n\thandling.\n\t(call followed by jump define_peephole's): Delete.\n\t(exception_receiver): Likewise.\n\t(builtin_setjmp_receiver): Likewise.\n\t* config/sparc/t-sparclite (MULTILIB_OPTIONS): Remove -mflat.\n\nFrom-SVN: r77169", "tree": {"sha": "c7cad77d1f7f77fb6749da1af269a50ee4cd6ee6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7cad77d1f7f77fb6749da1af269a50ee4cd6ee6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60b85c4c0e161c6e2fe58c70454cb46d553dbe83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60b85c4c0e161c6e2fe58c70454cb46d553dbe83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60b85c4c0e161c6e2fe58c70454cb46d553dbe83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e57e265ba61a2e07623521dc872a2b7e82e70b37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e57e265ba61a2e07623521dc872a2b7e82e70b37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e57e265ba61a2e07623521dc872a2b7e82e70b37"}], "stats": {"total": 1055, "additions": 97, "deletions": 958}, "files": [{"sha": "934168003ed91f5554ec9a5aec3b02e7bb23919c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=60b85c4c0e161c6e2fe58c70454cb46d553dbe83", "patch": "@@ -1,3 +1,51 @@\n+2004-02-03  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* doc/invoke.texi (SPARC options): Remove -mflat and\n+\tall -mxxx (xxx:chip) options.\n+\t* config/sparc/aout.h (DBX_REGISTER_NUMBER): Delete.\n+\t* config/sparc/litecoff.h (DBX_REGISTER_NUMBER): Likewise.\n+\t* config/sparc/netbsd-elf.h (DBX_REGISTER_NUMBER): Likewise.\n+\t* config/sparc/sol2.h (DBX_REGISTER_NUMBER): Likewise.\n+\t* config/sparc/sparc-protos.h: Delete sparc_flat_* prototypes.\n+\t* config/sparc/sparc.c: Likewise.\n+\t(sparc_output_function_prologue): Remove TARGET_FLAT handling.\n+\t(sparc_nonflat_function_prologue): Rename into sparc_function_prologue.\n+\t(sparc_output_function_epilogue): Remove TARGET_FLAT handling.\n+\t(sparc_nonflat_function_epilogue): Rename into sparc_function_epilogue.\n+\t(struct sparc_frame_info, current_frame_info, zero_frame_info): Delete.\n+\t(sparc_flat_must_save_register_p): Likewise.\n+\t(sparc_flat_compute_frame_size): Likewise.\n+\t(sparc_flat_save_restore): Likewise.\n+\t(sparc_flat_function_prologue): Likewise.\n+\t(sparc_flat_function_epilogue): Likewise.\n+\t(sparc_flat_epilogue_delay_slots): Likewise.\n+\t(sparc_flat_eligible_for_epilogue_delay): Likewise.\n+\t(sparc_function_ok_for_sibcall): Remove TARGET_FLAT handling.\n+\t* config/sparc/sparc.h (MASK_FLAT, TARGET_FLAT): Delete.\n+\t(TARGET_SWITCHES): Remove -mflat and all -mxxx (xxx:chip) options.\n+\t(SPARC_INCOMING_INT_ARG_FIRST): Remove TARGET_FLAT handling.\n+\t(CONDITIONAL_REGISTER_USAGE): Likewise.\n+\t(FRAME_POINTER_REQUIRED): Likewise.\n+\t(INITIAL_ELIMINATION_OFFSET): Likewise.\n+\t(BASE_RETURN_VALUE_REG): Likewise.\n+\t(BASE_OUTGOING_VALUE_REG): Likewise.\n+\t(BASE_PASSING_ARG_REG): Likewise.\n+\t(BASE_INCOMING_ARG_REG): Likewise.\n+\t(INCOMING_REGNO): Likewise.\n+\t(OUTGOING_REGNO): Likewise.\n+\t(LOCAL_REGNO): Likewise.\n+\t(DELAY_SLOTS_FOR_EPILOGUE): Likewise.\n+\t(ELIGIBLE_FOR_EPILOGUE_DELAY): Likewise.\n+\t(EPILOGUE_USES): Likewise.\n+\t* config/sparc/sparc.md (\"isa\" attribute): Change \"v6\" into \"v7\".\n+\t(\"flat\" attribute): Delete.\n+\t(do_builtin_setjmp_setup): Remove TARGET_FLAT and \"flat\" attribute\n+\thandling.\n+\t(call followed by jump define_peephole's): Delete.\n+\t(exception_receiver): Likewise.\n+\t(builtin_setjmp_receiver): Likewise.\n+\t* config/sparc/t-sparclite (MULTILIB_OPTIONS): Remove -mflat.\n+\n 2004-02-03  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR c/11658"}, {"sha": "7639fbd1cbc4ba57b12bb8a6e25edd676e829da2", "filename": "gcc/config/sparc/aout.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Fconfig%2Fsparc%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Fconfig%2Fsparc%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Faout.h?ref=60b85c4c0e161c6e2fe58c70454cb46d553dbe83", "patch": "@@ -48,12 +48,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define DATA_SECTION_ASM_OP \"\\t.data\"\n \n-/* How to renumber registers for dbx and gdb.  In the flat model, the frame\n-   pointer is really %i7.  */\n-\n-#define DBX_REGISTER_NUMBER(REGNO) \\\n-  (TARGET_FLAT && (REGNO) == HARD_FRAME_POINTER_REGNUM ? 31 : REGNO)\n-\n /* This is how to output a note to DBX telling it the line number\n    to which the following sequence of instructions corresponds.\n "}, {"sha": "51a8b848794cefb5653bdec78e98ef4304603b2d", "filename": "gcc/config/sparc/litecoff.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Fconfig%2Fsparc%2Flitecoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Fconfig%2Fsparc%2Flitecoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flitecoff.h?ref=60b85c4c0e161c6e2fe58c70454cb46d553dbe83", "patch": "@@ -61,9 +61,3 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Output before writable data.  */\n \n #define DATA_SECTION_ASM_OP \"\\t.data\"\n-\n-/* How to renumber registers for dbx and gdb.  In the flat model, the frame\n-   pointer is really %i7.  */\n-\n-#define DBX_REGISTER_NUMBER(REGNO) \\\n-  (TARGET_FLAT && (REGNO) == HARD_FRAME_POINTER_REGNUM ? 31 : REGNO)"}, {"sha": "9eb1652b949316d75a27dd98d6ddac626c763a79", "filename": "gcc/config/sparc/netbsd-elf.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Fconfig%2Fsparc%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Fconfig%2Fsparc%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fnetbsd-elf.h?ref=60b85c4c0e161c6e2fe58c70454cb46d553dbe83", "patch": "@@ -59,10 +59,6 @@ Boston, MA 02111-1307, USA.  */\n #undef DBX_CONTIN_CHAR\n #define DBX_CONTIN_CHAR '?'\n \n-#undef DBX_REGISTER_NUMBER\n-#define DBX_REGISTER_NUMBER(REGNO) \\\n-  (TARGET_FLAT && REGNO == HARD_FRAME_POINTER_REGNUM ? 31 : REGNO)\n-\n #undef  LOCAL_LABEL_PREFIX\n #define LOCAL_LABEL_PREFIX  \".\"\n "}, {"sha": "717a5a69a030a90d1473b1d538b0a35b24e57859", "filename": "gcc/config/sparc/sol2.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Fconfig%2Fsparc%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Fconfig%2Fsparc%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2.h?ref=60b85c4c0e161c6e2fe58c70454cb46d553dbe83", "patch": "@@ -57,11 +57,6 @@ Boston, MA 02111-1307, USA.  */\n /* However it appears that Solaris 2.0 uses the same reg numbering as\n    the old BSD-style system did.  */\n \n-/* Same as sparc.h */\n-#undef DBX_REGISTER_NUMBER\n-#define DBX_REGISTER_NUMBER(REGNO) \\\n-  (TARGET_FLAT && (REGNO) == HARD_FRAME_POINTER_REGNUM ? 31 : REGNO)\n-\n /* The Solaris 2 assembler uses .skip, not .zero, so put this back.  */\n #undef ASM_OUTPUT_SKIP\n #define ASM_OUTPUT_SKIP(FILE,SIZE)  \\"}, {"sha": "cc164df2d78b2196730ef74b9579313b65f855e8", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=60b85c4c0e161c6e2fe58c70454cb46d553dbe83", "patch": "@@ -53,8 +53,6 @@ extern void order_regs_for_local_alloc (void);\n extern HOST_WIDE_INT compute_frame_size (HOST_WIDE_INT, int);\n extern int check_pic (int);\n extern int short_branch (int, int);\n-extern int sparc_flat_epilogue_delay_slots (void);\n-extern HOST_WIDE_INT sparc_flat_compute_frame_size (HOST_WIDE_INT);\n extern void sparc_profile_hook (int);\n extern void sparc_override_options (void);\n extern int leaf_return_peephole_ok (void);\n@@ -111,7 +109,6 @@ extern int pic_address_needs_scratch (rtx);\n extern int reg_unused_after (rtx, rtx);\n extern int register_ok_for_ldd (rtx);\n extern int registers_ok_for_ldd_peep (rtx, rtx);\n-extern int sparc_flat_eligible_for_epilogue_delay (rtx, int);\n extern int v9_regcmp_p (enum rtx_code);\n extern char *sparc_v8plus_shift (rtx *, rtx, const char *);\n /* Function used for V8+ code generation.  Returns 1 if the high"}, {"sha": "855fe1d6747eb7bdb2afcfbece5fac39db8d6b67", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 14, "deletions": 748, "changes": 762, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=60b85c4c0e161c6e2fe58c70454cb46d553dbe83", "patch": "@@ -79,7 +79,7 @@ static int num_gfregs;\n rtx sparc_compare_op0, sparc_compare_op1;\n \n /* Coordinate with the md file wrt special insns created by\n-   sparc_nonflat_function_epilogue.  */\n+   sparc_function_epilogue.  */\n bool sparc_emitting_epilogue;\n \n /* Vector to say how input registers are mapped to output registers.\n@@ -155,14 +155,8 @@ static int set_extends (rtx);\n static void output_restore_regs (FILE *, int);\n static void sparc_output_function_prologue (FILE *, HOST_WIDE_INT);\n static void sparc_output_function_epilogue (FILE *, HOST_WIDE_INT);\n-static void sparc_flat_function_epilogue (FILE *, HOST_WIDE_INT);\n-static void sparc_flat_function_prologue (FILE *, HOST_WIDE_INT);\n-static void sparc_flat_save_restore (FILE *, const char *, int,\n-\t\t\t\t     unsigned long, unsigned long,\n-\t\t\t\t     const char *, const char *,\n-\t\t\t\t     HOST_WIDE_INT);\n-static void sparc_nonflat_function_epilogue (FILE *, HOST_WIDE_INT, int);\n-static void sparc_nonflat_function_prologue (FILE *, HOST_WIDE_INT, int);\n+static void sparc_function_epilogue (FILE *, HOST_WIDE_INT, int);\n+static void sparc_function_prologue (FILE *, HOST_WIDE_INT, int);\n #ifdef OBJECT_FORMAT_ELF\n static void sparc_elf_asm_named_section (const char *, unsigned int);\n #endif\n@@ -4333,18 +4327,14 @@ sparc_output_scratch_registers (FILE *file ATTRIBUTE_UNUSED)\n static void\n sparc_output_function_prologue (FILE *file, HOST_WIDE_INT size)\n {\n-  if (TARGET_FLAT)\n-    sparc_flat_function_prologue (file, size);\n-  else\n-    sparc_nonflat_function_prologue (file, size,\n-\t\t\t\t     current_function_uses_only_leaf_regs);\n+  sparc_function_prologue (file, size,\n+\t\t\t   current_function_uses_only_leaf_regs);\n }\n \n /* Output code for the function prologue.  */\n \n static void\n-sparc_nonflat_function_prologue (FILE *file, HOST_WIDE_INT size,\n-\t\t\t\t int leaf_function)\n+sparc_function_prologue (FILE *file, HOST_WIDE_INT size, int leaf_function)\n {\n   sparc_output_scratch_registers (file);\n \n@@ -4498,19 +4488,16 @@ output_restore_regs (FILE *file, int leaf_function ATTRIBUTE_UNUSED)\n static void\n sparc_output_function_epilogue (FILE *file, HOST_WIDE_INT size)\n {\n-  if (TARGET_FLAT)\n-    sparc_flat_function_epilogue (file, size);\n-  else\n-    sparc_nonflat_function_epilogue (file, size,\n-\t\t\t\t     current_function_uses_only_leaf_regs);\n+  sparc_function_epilogue (file, size,\n+\t\t\t   current_function_uses_only_leaf_regs);\n }\n \n /* Output code for the function epilogue.  */\n \n static void\n-sparc_nonflat_function_epilogue (FILE *file,\n-\t\t\t\t HOST_WIDE_INT size ATTRIBUTE_UNUSED,\n-\t\t\t\t int leaf_function)\n+sparc_function_epilogue (FILE *file,\n+\t\t\t HOST_WIDE_INT size ATTRIBUTE_UNUSED,\n+\t\t\t int leaf_function)\n {\n   const char *ret;\n \n@@ -7405,724 +7392,6 @@ sparc64_initialize_trampoline (rtx tramp, rtx fnaddr, rtx cxt)\n #endif\n }\n \f\n-/* Subroutines to support a flat (single) register window calling\n-   convention.  */\n-\n-/* Single-register window sparc stack frames look like:\n-\n-             Before call\t\t        After call\n-        +-----------------------+\t+-----------------------+\n-   high |\t\t        |\t|\t\t\t|\n-   mem  |  caller's temps.    \t|       |  caller's temps.    \t|\n-\t|       \t\t|       |       \t        |\n-        +-----------------------+\t+-----------------------+\n- \t|       \t\t|\t|\t\t        |\n-        |  arguments on stack.  |\t|  arguments on stack.  |\n-\t|       \t\t|      \t|\t\t\t|\n-        +-----------------------+FP+92->+-----------------------+\n- \t|  6 words to save     \t|\t|  6 words to save\t|\n-\t|  arguments passed\t|\t|  arguments passed\t|\n-\t|  in registers, even\t|\t|  in registers, even\t|\n-       \t|  if not passed.       |      \t|  if not passed.\t|\n- SP+68->+-----------------------+FP+68->+-----------------------+\n-        | 1 word struct addr\t|      \t| 1 word struct addr\t|\n-        +-----------------------+FP+64->+-----------------------+\n-        |\t\t\t|\t|\t\t\t|\n-        | 16 word reg save area\t|\t| 16 word reg save area |\n-       \t|                       |      \t|\t\t\t|\n-    SP->+-----------------------+   FP->+-----------------------+\n-\t\t\t\t        | 4 word area for\t|\n-\t\t\t\t       \t| fp/alu reg moves\t|\n-\t\t\t\t FP-16->+-----------------------+\n-\t\t\t\t        |\t\t\t|\n-\t\t\t\t        |  local variables\t|\n-\t\t\t\t        |\t\t\t|\n-\t\t\t\t        +-----------------------+\n-\t\t\t\t        |\t\t        |\n-                                        |  fp register save     |\n-\t\t\t\t        |\t\t\t|\n-\t\t\t\t        +-----------------------+\n-\t\t\t\t        |\t\t        |\n-                                        |  gp register save     |\n-                                        |       \t\t|\n-\t\t\t\t        +-----------------------+\n-\t\t\t\t        |\t\t\t|\n-                                        |  alloca allocations   |\n-        \t\t\t        |\t\t\t|\n-\t\t\t\t        +-----------------------+\n-\t\t\t\t        |\t\t\t|\n-                                        |  arguments on stack   |\n-        \t\t\t       \t|\t\t        |\n-\t\t\t\t SP+92->+-----------------------+\n-                                        |  6 words to save      |\n-\t\t\t\t        |  arguments passed     |\n-                                        |  in registers, even   |\n-   low                                 \t|  if not passed.       |\n-   memory        \t\t SP+68->+-----------------------+\n-\t\t\t\t       \t| 1 word struct addr\t|\n-\t\t\t\t SP+64->+-----------------------+\n-\t\t\t\t        |\t\t\t|\n-\t\t\t\t        I 16 word reg save area |\n-\t\t\t\t       \t|\t\t\t|\n-\t\t\t\t    SP->+-----------------------+  */\n-\n-/* Structure to be filled in by sparc_flat_compute_frame_size with register\n-   save masks, and offsets for the current function.  */\n-\n-struct sparc_frame_info\n-{\n-  HOST_WIDE_INT total_size;\t/* # bytes that the entire frame takes up.  */\n-  HOST_WIDE_INT var_size;\t/* # bytes that variables take up.  */\n-  int           args_size;\t/* # bytes that outgoing arguments take up.  */\n-  int           extra_size;\t/* # bytes of extra gunk.  */\n-  int           gp_reg_size;\t/* # bytes needed to store gp regs.  */\n-  int           fp_reg_size;\t/* # bytes needed to store fp regs.  */\n-  unsigned long gmask;\t\t/* Mask of saved gp registers.  */\n-  unsigned long fmask;\t\t/* Mask of saved fp registers.  */\n-  int           reg_offset;\t/* Offset from new sp to store regs.  */\n-  int           initialized;\t/* Nonzero if frame size already calculated.  */\n-};\n-\n-/* Current frame information calculated by sparc_flat_compute_frame_size.  */\n-struct sparc_frame_info current_frame_info;\n-\n-/* Zero structure to initialize current_frame_info.  */\n-struct sparc_frame_info zero_frame_info;\n-\n-#define RETURN_ADDR_REGNUM 15\n-#define HARD_FRAME_POINTER_MASK (1 << (HARD_FRAME_POINTER_REGNUM))\n-#define RETURN_ADDR_MASK (1 << (RETURN_ADDR_REGNUM))\n-\f\n-/* Tell prologue and epilogue if register REGNO should be saved / restored.  */\n-\n-static bool\n-sparc_flat_must_save_register_p (int regno)\n-{\n-  /* General case: call-saved registers live at some point.  */\n-  if (!call_used_regs[regno] && regs_ever_live[regno])\n-    return true;\n-  \n-  /* Frame pointer register (%i7) if needed.  */\n-  if (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\n-    return true;\n-\n-  /* PIC register (%l7) if needed.  */\n-  if (regno == (int) PIC_OFFSET_TABLE_REGNUM\n-      && flag_pic && current_function_uses_pic_offset_table)\n-    return true;\n-\n-  /* Return address register (%o7) if needed.  */\n-  if (regno == RETURN_ADDR_REGNUM\n-      && (regs_ever_live[RETURN_ADDR_REGNUM]\n-\t  /* When the PIC offset table is used, the PIC register\n-\t     is set by using a bare call that clobbers %o7.  */\n-\t  || (flag_pic && current_function_uses_pic_offset_table)))\n-    return true;\n-\n-  return false;\n-}\n-\f\n-/* Return the bytes needed to compute the frame pointer from the current\n-   stack pointer.  */\n-\n-HOST_WIDE_INT\n-sparc_flat_compute_frame_size (HOST_WIDE_INT size)\n-              \t\t\t/* # of var. bytes allocated.  */\n-{\n-  int regno;\n-  HOST_WIDE_INT total_size;\t/* # bytes that the entire frame takes up.  */\n-  HOST_WIDE_INT var_size;\t/* # bytes that variables take up.  */\n-  int           args_size;\t/* # bytes that outgoing arguments take up.  */\n-  int           extra_size;\t/* # extra bytes.  */\n-  int           gp_reg_size;\t/* # bytes needed to store gp regs.  */\n-  int           fp_reg_size;\t/* # bytes needed to store fp regs.  */\n-  unsigned long gmask;\t\t/* Mask of saved gp registers.  */\n-  unsigned long fmask;\t\t/* Mask of saved fp registers.  */\n-  int           reg_offset;\t/* Offset to register save area.  */\n-  int           need_aligned_p;\t/* 1 if need the save area 8 byte aligned.  */\n-\n-  /* This is the size of the 16 word reg save area, 1 word struct addr\n-     area, and 4 word fp/alu register copy area.  */\n-  extra_size = -STARTING_FRAME_OFFSET + FIRST_PARM_OFFSET(0);\n-  var_size = size;\n-  gp_reg_size = 0;\n-  fp_reg_size = 0;\n-  gmask = 0;\n-  fmask = 0;\n-  reg_offset = 0;\n-  need_aligned_p = 0;\n-\n-  args_size = 0;\n-  if (!leaf_function_p ())\n-    {\n-      /* Also include the size needed for the 6 parameter registers.  */\n-      args_size = current_function_outgoing_args_size + 24;\n-    }\n-  total_size = var_size + args_size;\n-\n-  /* Calculate space needed for gp registers.  */\n-  for (regno = 1; regno <= 31; regno++)\n-    {\n-      if (sparc_flat_must_save_register_p (regno))\n-\t{\n-\t  /* If we need to save two regs in a row, ensure there's room to bump\n-\t     up the address to align it to a doubleword boundary.  */\n-\t  if ((regno & 0x1) == 0 && sparc_flat_must_save_register_p (regno+1))\n-\t    {\n-\t      if (gp_reg_size % 8 != 0)\n-\t\tgp_reg_size += 4;\n-\t      gp_reg_size += 2 * UNITS_PER_WORD;\n-\t      gmask |= 3 << regno;\n-\t      regno++;\n-\t      need_aligned_p = 1;\n-\t    }\n-\t  else\n-\t    {\n-\t      gp_reg_size += UNITS_PER_WORD;\n-\t      gmask |= 1 << regno;\n-\t    }\n-\t}\n-    }\n-\n-  /* Calculate space needed for fp registers.  */\n-  for (regno = 32; regno <= 63; regno++)\n-    {\n-      if (regs_ever_live[regno] && !call_used_regs[regno])\n-\t{\n-\t  fp_reg_size += UNITS_PER_WORD;\n-\t  fmask |= 1 << (regno - 32);\n-\t}\n-    }\n-\n-  if (gmask || fmask)\n-    {\n-      int n;\n-      reg_offset = FIRST_PARM_OFFSET(0) + args_size;\n-      /* Ensure save area is 8 byte aligned if we need it.  */\n-      n = reg_offset % 8;\n-      if (need_aligned_p && n != 0)\n-\t{\n-\t  total_size += 8 - n;\n-\t  reg_offset += 8 - n;\n-\t}\n-      total_size += gp_reg_size + fp_reg_size;\n-    }\n-\n-  /* If we must allocate a stack frame at all, we must also allocate \n-     room for register window spillage, so as to be binary compatible\n-     with libraries and operating systems that do not use -mflat.  */\n-  if (total_size > 0)\n-    total_size += extra_size;\n-  else\n-    extra_size = 0;\n-\n-  total_size = SPARC_STACK_ALIGN (total_size);\n-\n-  /* Save other computed information.  */\n-  current_frame_info.total_size  = total_size;\n-  current_frame_info.var_size    = var_size;\n-  current_frame_info.args_size   = args_size;\n-  current_frame_info.extra_size  = extra_size;\n-  current_frame_info.gp_reg_size = gp_reg_size;\n-  current_frame_info.fp_reg_size = fp_reg_size;\n-  current_frame_info.gmask\t = gmask;\n-  current_frame_info.fmask\t = fmask;\n-  current_frame_info.reg_offset\t = reg_offset;\n-  current_frame_info.initialized = reload_completed;\n-\n-  /* Ok, we're done.  */\n-  return total_size;\n-}\n-\f\n-/* Save/restore registers in GMASK and FMASK at register BASE_REG plus offset\n-   OFFSET.\n-\n-   BASE_REG must be 8 byte aligned.  This allows us to test OFFSET for\n-   appropriate alignment and use DOUBLEWORD_OP when we can.  We assume\n-   [BASE_REG+OFFSET] will always be a valid address.\n-\n-   WORD_OP is either \"st\" for save, \"ld\" for restore.\n-   DOUBLEWORD_OP is either \"std\" for save, \"ldd\" for restore.  */\n-\n-static void\n-sparc_flat_save_restore (FILE *file, const char *base_reg, int offset,\n-\t\t\t unsigned long gmask, unsigned long fmask,\n-\t\t\t const char *word_op, const char *doubleword_op,\n-\t\t\t HOST_WIDE_INT base_offset)\n-{\n-  int regno;\n-\n-  if (gmask == 0 && fmask == 0)\n-    return;\n-\n-  /* Save registers starting from high to low.  We've already saved the\n-     previous frame pointer and previous return address for the debugger's\n-     sake.  The debugger allows us to not need a nop in the epilog if at least\n-     one register is reloaded in addition to return address.  */\n-\n-  if (gmask)\n-    {\n-      for (regno = 1; regno <= 31; regno++)\n-\t{\n-\t  if ((gmask & (1L << regno)) != 0)\n-\t    {\n-\t      if ((regno & 0x1) == 0 && ((gmask & (1L << (regno+1))) != 0))\n-\t\t{\n-\t\t  /* We can save two registers in a row.  If we're not at a\n-\t\t     double word boundary, move to one.\n-\t\t     sparc_flat_compute_frame_size ensures there's room to do\n-\t\t     this.  */\n-\t\t  if (offset % 8 != 0)\n-\t\t    offset += UNITS_PER_WORD;\n-\n-\t\t  if (word_op[0] == 's')\n-\t\t    {\n-\t\t      fprintf (file, \"\\t%s\\t%s, [%s+%d]\\n\",\n-\t\t\t       doubleword_op, reg_names[regno],\n-\t\t\t       base_reg, offset);\n-\t\t      if (dwarf2out_do_frame ())\n-\t\t\t{\n-\t\t\t  char *l = dwarf2out_cfi_label ();\n-\t\t\t  dwarf2out_reg_save (l, regno, offset + base_offset);\n-\t\t\t  dwarf2out_reg_save\n-\t\t\t    (l, regno+1, offset+base_offset + UNITS_PER_WORD);\n-\t\t\t}\n-\t\t    }\n-\t\t  else\n-\t\t    fprintf (file, \"\\t%s\\t[%s+%d], %s\\n\",\n-\t\t\t     doubleword_op, base_reg, offset,\n-\t\t\t     reg_names[regno]);\n-\n-\t\t  offset += 2 * UNITS_PER_WORD;\n-\t\t  regno++;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (word_op[0] == 's')\n-\t\t    {\n-\t\t      fprintf (file, \"\\t%s\\t%s, [%s+%d]\\n\",\n-\t\t\t       word_op, reg_names[regno],\n-\t\t\t       base_reg, offset);\n-\t\t      if (dwarf2out_do_frame ())\n-\t\t\tdwarf2out_reg_save (\"\", regno, offset + base_offset);\n-\t\t    }\n-\t\t  else\n-\t\t    fprintf (file, \"\\t%s\\t[%s+%d], %s\\n\",\n-\t\t\t     word_op, base_reg, offset, reg_names[regno]);\n-\n-\t\t  offset += UNITS_PER_WORD;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  if (fmask)\n-    {\n-      for (regno = 32; regno <= 63; regno++)\n-\t{\n-\t  if ((fmask & (1L << (regno - 32))) != 0)\n-\t    {\n-\t      if (word_op[0] == 's')\n-\t\t{\n-\t\t  fprintf (file, \"\\t%s\\t%s, [%s+%d]\\n\",\n-\t\t\t   word_op, reg_names[regno],\n-\t\t\t   base_reg, offset);\n-\t\t  if (dwarf2out_do_frame ())\n-\t\t    dwarf2out_reg_save (\"\", regno, offset + base_offset);\n-\t\t}\n-\t      else\n-\t\tfprintf (file, \"\\t%s\\t[%s+%d], %s\\n\",\n-\t\t\t word_op, base_reg, offset, reg_names[regno]);\n-\n-\t      offset += UNITS_PER_WORD;\n-\t    }\n-\t}\n-    }\n-}\n-\f\n-/* Set up the stack and frame (if desired) for the function.  */\n-\n-static void\n-sparc_flat_function_prologue (FILE *file, HOST_WIDE_INT size)\n-{\n-  const char *sp_str = reg_names[STACK_POINTER_REGNUM];\n-  unsigned long gmask = current_frame_info.gmask;\n-\n-  sparc_output_scratch_registers (file);\n-\n-  /* This is only for the human reader.  */\n-  fprintf (file, \"\\t%s#PROLOGUE# 0\\n\", ASM_COMMENT_START);\n-  fprintf (file, \"\\t%s# vars= \"HOST_WIDE_INT_PRINT_DEC\", \"\n-\t\t \"regs= %d/%d, args= %d, extra= %d\\n\",\n-\t   ASM_COMMENT_START,\n-\t   current_frame_info.var_size,\n-\t   current_frame_info.gp_reg_size / 4,\n-\t   current_frame_info.fp_reg_size / 4,\n-\t   current_function_outgoing_args_size,\n-\t   current_frame_info.extra_size);\n-\n-  size = SPARC_STACK_ALIGN (size);\n-  size = (! current_frame_info.initialized\n-\t  ? sparc_flat_compute_frame_size (size)\n-\t  : current_frame_info.total_size);\n-\n-  /* These cases shouldn't happen.  Catch them now.  */\n-  if (size == 0 && (gmask || current_frame_info.fmask))\n-    abort ();\n-\n-  /* Allocate our stack frame by decrementing %sp.\n-     At present, the only algorithm gdb can use to determine if this is a\n-     flat frame is if we always set %i7 if we set %sp.  This can be optimized\n-     in the future by putting in some sort of debugging information that says\n-     this is a `flat' function.  However, there is still the case of debugging\n-     code without such debugging information (including cases where most fns\n-     have such info, but there is one that doesn't).  So, always do this now\n-     so we don't get a lot of code out there that gdb can't handle.\n-     If the frame pointer isn't needn't then that's ok - gdb won't be able to\n-     distinguish us from a non-flat function but there won't (and shouldn't)\n-     be any differences anyway.  The return pc is saved (if necessary) right\n-     after %i7 so gdb won't have to look too far to find it.  */\n-  if (size > 0)\n-    {\n-      int reg_offset = current_frame_info.reg_offset;\n-      const char *const fp_str = reg_names[HARD_FRAME_POINTER_REGNUM];\n-      static const char *const t1_str = \"%g1\";\n-\n-      /* Things get a little tricky if local variables take up more than ~4096\n-\t bytes and outgoing arguments take up more than ~4096 bytes.  When that\n-\t happens, the register save area can't be accessed from either end of\n-\t the frame.  Handle this by decrementing %sp to the start of the gp\n-\t register save area, save the regs, update %i7, and then set %sp to its\n-\t final value.  Given that we only have one scratch register to play\n-\t with it is the cheapest solution, and it helps gdb out as it won't\n-\t slow down recognition of flat functions.\n-\t Don't change the order of insns emitted here without checking with\n-\t the gdb folk first.  */\n-\n-      /* Is the entire register save area offsettable from %sp?  */\n-      if (reg_offset < 4096 - 64 * UNITS_PER_WORD)\n-\t{\n-\t  if (size <= 4096)\n-\t    {\n-\t      fprintf (file, \"\\tadd\\t%s, -\"HOST_WIDE_INT_PRINT_DEC\", %s\\n\",\n-\t\t       sp_str, size, sp_str);\n-\t      if (gmask & HARD_FRAME_POINTER_MASK)\n-\t\t{\n-\t\t  fprintf (file, \"\\tst\\t%s, [%s+%d]\\n\",\n-\t\t\t   fp_str, sp_str, reg_offset);\n-\t\t  fprintf (file, \"\\tsub\\t%s, -\"HOST_WIDE_INT_PRINT_DEC\", %s\"\n-\t\t  \t\t \"\\t%s# set up frame pointer\\n\",\n-\t\t\t   sp_str, size, fp_str, ASM_COMMENT_START);\n-\t\t  reg_offset += 4;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      build_big_number (file, size, t1_str);\n-\t      fprintf (file, \"\\tsub\\t%s, %s, %s\\n\", sp_str, t1_str, sp_str);\n-\t      if (gmask & HARD_FRAME_POINTER_MASK)\n-\t\t{\n-\t\t  fprintf (file, \"\\tst\\t%s, [%s+%d]\\n\",\n-\t\t\t   fp_str, sp_str, reg_offset);\n-\t\t  fprintf (file, \"\\tadd\\t%s, %s, %s\\t%s# set up frame pointer\\n\",\n-\t\t\t   sp_str, t1_str, fp_str, ASM_COMMENT_START);\n-\t\t  reg_offset += 4;\n-\t\t}\n-\t    }\n-\t  if (dwarf2out_do_frame ())\n-\t    {\n-\t      char *l = dwarf2out_cfi_label ();\n-\t      if (gmask & HARD_FRAME_POINTER_MASK)\n-\t\t{\n-\t\t  dwarf2out_reg_save (l, HARD_FRAME_POINTER_REGNUM,\n-\t\t\t\t      reg_offset - 4 - size);\n-\t\t  dwarf2out_def_cfa (l, HARD_FRAME_POINTER_REGNUM, 0);\n-\t\t}\n-\t      else\n-\t\tdwarf2out_def_cfa (l, STACK_POINTER_REGNUM, size);\n-\t    }\n-\t  if (gmask & RETURN_ADDR_MASK)\n-\t    {\n-\t      fprintf (file, \"\\tst\\t%s, [%s+%d]\\n\",\n-\t\t       reg_names[RETURN_ADDR_REGNUM], sp_str, reg_offset);\n-\t      if (dwarf2out_do_frame ())\n-\t\tdwarf2out_return_save (\"\", reg_offset - size);\n-\t      reg_offset += 4;\n-\t    }\n-\t  sparc_flat_save_restore (file, sp_str, reg_offset,\n-\t\t\t\t   gmask & ~(HARD_FRAME_POINTER_MASK | RETURN_ADDR_MASK),\n-\t\t\t\t   current_frame_info.fmask,\n-\t\t\t\t   \"st\", \"std\", -size);\n-\t}\n-      else\n-\t{\n-\t  /* Subtract %sp in two steps, but make sure there is always a\n-\t     64-byte register save area, and %sp is properly aligned.  */\n-\n-\t  /* Amount to decrement %sp by, the first time.  */\n-\t  HOST_WIDE_INT size1 = ((size - reg_offset + 64) + 15) & -16;\n-\n-\t  /* Amount to decrement %sp by, the second time.  */\n-\t  HOST_WIDE_INT size2 = size - size1;\n-\n-\t  /* Offset to register save area from %sp after first decrement.  */\n-\t  int offset = (int)(size1 - (size - reg_offset));\n-\t  \n-\t  if (size1 <= 4096)\n-\t    {\n-\t      fprintf (file, \"\\tadd\\t%s, -\"HOST_WIDE_INT_PRINT_DEC\", %s\\n\",\n-\t\t       sp_str, size1, sp_str);\n-\t      if (gmask & HARD_FRAME_POINTER_MASK)\n-\t\t{\n-\t\t  fprintf (file, \"\\tst\\t%s, [%s+%d]\\n\"\n-\t\t\t\t \"\\tsub\\t%s, -\"HOST_WIDE_INT_PRINT_DEC\", %s\"\n-\t\t\t\t \"\\t%s# set up frame pointer\\n\",\n-\t\t\t   fp_str, sp_str, offset, sp_str, size1,\n-\t\t\t   fp_str, ASM_COMMENT_START);\n-\t\t  offset += 4;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      build_big_number (file, size1, t1_str);\n-\t      fprintf (file, \"\\tsub\\t%s, %s, %s\\n\", sp_str, t1_str, sp_str);\n-\t      if (gmask & HARD_FRAME_POINTER_MASK)\n-\t\t{\n-\t\t  fprintf (file, \"\\tst\\t%s, [%s+%d]\\n\"\n-\t\t\t\t \"\\tadd\\t%s, %s, %s\\t%s# set up frame pointer\\n\",\n-\t\t\t   fp_str, sp_str, offset, sp_str, t1_str,\n-\t\t\t   fp_str, ASM_COMMENT_START);\n-\t\t  offset += 4;\n-\t\t}\n-\t    }\n-\t  if (dwarf2out_do_frame ())\n-\t    {\n-\t      char *l = dwarf2out_cfi_label ();\n-\t      if (gmask & HARD_FRAME_POINTER_MASK)\n-\t\t{\n-\t\t  dwarf2out_reg_save (l, HARD_FRAME_POINTER_REGNUM,\n-\t\t\t\t      offset - 4 - size1);\n-\t\t  dwarf2out_def_cfa (l, HARD_FRAME_POINTER_REGNUM, 0);\n-\t\t}\n-\t      else\n-\t\tdwarf2out_def_cfa (l, STACK_POINTER_REGNUM, size1);\n-\t    }\n-\t  if (gmask & RETURN_ADDR_MASK)\n-\t    {\n-\t      fprintf (file, \"\\tst\\t%s, [%s+%d]\\n\",\n-\t\t       reg_names[RETURN_ADDR_REGNUM], sp_str, offset);\n-\t      if (dwarf2out_do_frame ())\n-\t\t/* offset - size1 == reg_offset - size\n-\t\t   if reg_offset were updated above like offset.  */\n-\t\tdwarf2out_return_save (\"\", offset - size1);\n-\t      offset += 4;\n-\t    }\n-\t  sparc_flat_save_restore (file, sp_str, offset,\n-\t\t\t\t   gmask & ~(HARD_FRAME_POINTER_MASK | RETURN_ADDR_MASK),\n-\t\t\t\t   current_frame_info.fmask,\n-\t\t\t\t   \"st\", \"std\", -size1);\n-\t  if (size2 <= 4096)\n-\t    fprintf (file, \"\\tadd\\t%s, -\"HOST_WIDE_INT_PRINT_DEC\", %s\\n\",\n-\t\t     sp_str, size2, sp_str);\n-\t  else\n-\t    {\n-\t      build_big_number (file, size2, t1_str);\n-\t      fprintf (file, \"\\tsub\\t%s, %s, %s\\n\", sp_str, t1_str, sp_str);\n-\t    }\n-\t  if (dwarf2out_do_frame ())\n-\t    if (! (gmask & HARD_FRAME_POINTER_MASK))\n-\t      dwarf2out_def_cfa (\"\", STACK_POINTER_REGNUM, size);\n-\t}\n-    }\n-\n-  fprintf (file, \"\\t%s#PROLOGUE# 1\\n\", ASM_COMMENT_START);\n-}\n-\f\n-/* Do any necessary cleanup after a function to restore stack, frame,\n-   and regs.  */\n-\n-static void\n-sparc_flat_function_epilogue (FILE *file, HOST_WIDE_INT size)\n-{\n-  rtx epilogue_delay = current_function_epilogue_delay_list;\n-  int noepilogue = FALSE;\n-\n-  /* This is only for the human reader.  */\n-  fprintf (file, \"\\t%s#EPILOGUE#\\n\", ASM_COMMENT_START);\n-\n-  /* The epilogue does not depend on any registers, but the stack\n-     registers, so we assume that if we have 1 pending nop, it can be\n-     ignored, and 2 it must be filled (2 nops occur for integer\n-     multiply and divide).  */\n-\n-  size = SPARC_STACK_ALIGN (size);\n-  size = (!current_frame_info.initialized\n-\t   ? sparc_flat_compute_frame_size (size)\n-\t   : current_frame_info.total_size);\n-\n-  if (size == 0 && epilogue_delay == 0)\n-    {\n-      rtx insn = get_last_insn ();\n-\n-      /* If the last insn was a BARRIER, we don't have to write any code\n-\t because a jump (aka return) was put there.  */\n-      if (GET_CODE (insn) == NOTE)\n-\tinsn = prev_nonnote_insn (insn);\n-      if (insn && GET_CODE (insn) == BARRIER)\n-\tnoepilogue = TRUE;\n-    }\n-\n-  if (!noepilogue)\n-    {\n-      int reg_offset = current_frame_info.reg_offset;\n-      int reg_offset1;\n-      const char *const sp_str = reg_names[STACK_POINTER_REGNUM];\n-      const char *const fp_str = reg_names[HARD_FRAME_POINTER_REGNUM];\n-      static const char *const t1_str = \"%g1\";\n-\n-      /* In the reload sequence, we don't need to fill the load delay\n-\t slots for most of the loads, also see if we can fill the final\n-\t delay slot if not otherwise filled by the reload sequence.  */\n-\n-      if (size > 4096)\n-\tbuild_big_number (file, size, t1_str);\n-\n-      if (frame_pointer_needed)\n-\t{\n-\t  if (size > 4096)\n-\t    fprintf (file,\"\\tsub\\t%s, %s, %s\\t\\t%s# sp not trusted here\\n\",\n-\t\t     fp_str, t1_str, sp_str, ASM_COMMENT_START);\n-\t  else\n-\t    fprintf (file,\"\\tadd\\t%s, -\"HOST_WIDE_INT_PRINT_DEC\", %s\"\n-\t\t\t  \"\\t\\t%s# sp not trusted here\\n\",\n-\t\t     fp_str, size, sp_str, ASM_COMMENT_START);\n-\t}\n-\n-      /* Is the entire register save area offsettable from %sp?  */\n-      if (reg_offset < 4096 - 64 * UNITS_PER_WORD)\n-\t{\n-\t  reg_offset1 = 0;\n-\t}\n-      else\n-\t{\n-\t  /* Restore %sp in two steps, but make sure there is always a\n-\t     64-byte register save area, and %sp is properly aligned.  */\n-\n-\t  /* Amount to increment %sp by, the first time.  */\n-\t  reg_offset1 = ((reg_offset - 64 - 16) + 15) & -16;\n-\n-\t  /* Offset to register save area from %sp.  */\n-\t  reg_offset = reg_offset1 - reg_offset;\n-\n-\t  if (reg_offset1 > 4096)\n-\t    {\n-\t      build_big_number (file, reg_offset1, t1_str);\n-\t      fprintf (file, \"\\tadd\\t%s, %s, %s\\n\", sp_str, t1_str, sp_str);\n-\t    }\n-\t  else\n-\t    fprintf (file, \"\\tsub\\t%s, -%d, %s\\n\", sp_str, reg_offset1, sp_str);\n-\t}\n-\n-      /* We must restore the frame pointer and return address reg first\n-\t because they are treated specially by the prologue output code.  */\n-      if (current_frame_info.gmask & HARD_FRAME_POINTER_MASK)\n-\t{\n-\t  fprintf (file, \"\\tld\\t[%s+%d], %s\\n\",\n-\t\t   sp_str, reg_offset, fp_str);\n-\t  reg_offset += 4;\n-\t}\n-      if (current_frame_info.gmask & RETURN_ADDR_MASK)\n-\t{\n-\t  fprintf (file, \"\\tld\\t[%s+%d], %s\\n\",\n-\t\t   sp_str, reg_offset, reg_names[RETURN_ADDR_REGNUM]);\n-\t  reg_offset += 4;\n-\t}\n-\n-      /* Restore any remaining saved registers.  */\n-      sparc_flat_save_restore (file, sp_str, reg_offset,\n-\t\t\t       current_frame_info.gmask & ~(HARD_FRAME_POINTER_MASK | RETURN_ADDR_MASK),\n-\t\t\t       current_frame_info.fmask,\n-\t\t\t       \"ld\", \"ldd\", 0);\n-\n-      /* If we had to increment %sp in two steps, record it so the second\n-\t restoration in the epilogue finishes up.  */\n-      if (reg_offset1 > 0)\n-\t{\n-\t  size -= reg_offset1;\n-\t  if (size > 4096)\n-\t    build_big_number (file, size, t1_str);\n-\t}\n-\n-      if (current_function_returns_struct)\n-\tfprintf (file, \"\\tjmp\\t%%o7+12\\n\");\n-      else\n-\tfprintf (file, \"\\tretl\\n\");\n-\n-      /* If the only register saved is the return address, we need a\n-\t nop, unless we have an instruction to put into it.  Otherwise\n-\t we don't since reloading multiple registers doesn't reference\n-\t the register being loaded.  */\n-\n-      if (epilogue_delay)\n-\t{\n-\t  if (size)\n-\t    abort ();\n-\t  final_scan_insn (XEXP (epilogue_delay, 0), file, 1, -2, 1, NULL);\n-\t}\n-\n-      else if (size > 4096)\n-\tfprintf (file, \"\\tadd\\t%s, %s, %s\\n\", sp_str, t1_str, sp_str);\n-\n-      else if (size > 0)\n-\tfprintf (file, \"\\tsub\\t%s, -\"HOST_WIDE_INT_PRINT_DEC\", %s\\n\",\n-\t\t sp_str, size, sp_str);\n-\n-      else\n-\tfprintf (file, \"\\tnop\\n\");\n-    }\n-\n-  /* Reset state info for each function.  */\n-  current_frame_info = zero_frame_info;\n-\n-  sparc_output_deferred_case_vectors ();\n-}\n-\f\n-/* Define the number of delay slots needed for the function epilogue.\n-\n-   On the sparc, we need a slot if either no stack has been allocated,\n-   or the only register saved is the return register.  */\n-\n-int\n-sparc_flat_epilogue_delay_slots (void)\n-{\n-  if (!current_frame_info.initialized)\n-    (void) sparc_flat_compute_frame_size (get_frame_size ());\n-\n-  if (current_frame_info.total_size == 0)\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Return true if TRIAL is a valid insn for the epilogue delay slot.\n-   Any single length instruction which doesn't reference the stack or frame\n-   pointer is OK.  */\n-\n-int\n-sparc_flat_eligible_for_epilogue_delay (rtx trial, int slot ATTRIBUTE_UNUSED)\n-{\n-  rtx pat = PATTERN (trial);\n-\n-  if (get_attr_length (trial) != 1)\n-    return 0;\n-\n-  if (! reg_mentioned_p (stack_pointer_rtx, pat)\n-      && ! reg_mentioned_p (frame_pointer_rtx, pat))\n-    return 1;\n-\n-  return 0;\n-}\n-\f\n /* Adjust the cost of a scheduling dependency.  Return the new cost of\n    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n \n@@ -8640,10 +7909,9 @@ sparc_elf_asm_named_section (const char *name, unsigned int flags)\n }\n #endif /* OBJECT_FORMAT_ELF */\n \n-/* We do not allow sibling calls if -mflat, nor\n-   we do not allow indirect calls to be optimized into sibling calls.\n+/* We do not allow indirect calls to be optimized into sibling calls.\n    \n-   Also, on sparc 32-bit we cannot emit a sibling call when the\n+   Also, on SPARC 32-bit we cannot emit a sibling call when the\n    current function returns a structure.  This is because the \"unimp\n    after call\" convention would cause the callee to return to the\n    wrong place.  The generic code already disallows cases where the\n@@ -8659,9 +7927,7 @@ sparc_elf_asm_named_section (const char *name, unsigned int flags)\n static bool\n sparc_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n {\n-  return (decl\n-\t  && ! TARGET_FLAT\n-\t  && (TARGET_ARCH64 || ! current_function_returns_struct));\n+  return (decl && (TARGET_ARCH64 || ! current_function_returns_struct));\n }\n \f\n /* libfunc renaming.  */"}, {"sha": "bfe3e32f227dc1d7f7395700739e12fd1ff45e51", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 24, "deletions": 88, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=60b85c4c0e161c6e2fe58c70454cb46d553dbe83", "patch": "@@ -442,12 +442,7 @@ extern int target_flags;\n #define MASK_IMPURE_TEXT 0x100\n #define TARGET_IMPURE_TEXT (target_flags & MASK_IMPURE_TEXT)\n \n-/* Nonzero means that we should generate code using a flat register window\n-   model, i.e. no save/restore instructions are generated, which is\n-   compatible with normal sparc code.\n-   The frame pointer is %i7 instead of %fp.  */\n-#define MASK_FLAT 0x200\n-#define TARGET_FLAT (target_flags & MASK_FLAT)\n+/* 0x200 is unused */\n \n /* Nonzero means use the registers that the SPARC ABI reserves for\n    application software.  This must be the default to coincide with the\n@@ -551,10 +546,6 @@ extern int target_flags;\n      N_(\"Pass -assert pure-text to linker\") }, \t\t\t\t\\\n     {\"no-impure-text\", -MASK_IMPURE_TEXT,\t\t\t\t\\\n      N_(\"Do not pass -assert pure-text to linker\") }, \t\t\t\\\n-    {\"flat\", MASK_FLAT,\t\t\t\t\t\t\t\\\n-     N_(\"Use flat register window model\") }, \t\t\t\t\\\n-    {\"no-flat\", -MASK_FLAT,\t\t\t\t\t\t\\\n-     N_(\"Do not use flat register window model\") }, \t\t\t\\\n     {\"app-regs\", MASK_APP_REGS,\t\t\t\t\t\t\\\n      N_(\"Use ABI reserved registers\") },\t\t\t\t\\\n     {\"no-app-regs\", -MASK_APP_REGS,\t\t\t\t\t\\\n@@ -571,20 +562,6 @@ extern int target_flags;\n      N_(\"Utilize Visual Instruction Set\") }, \t\t\t\t\\\n     {\"no-vis\", -MASK_VIS,\t\t\t\t\t\t\\\n      N_(\"Do not utilize Visual Instruction Set\") }, \t\t\t\\\n-    /* ??? These are deprecated, coerced to -mcpu=.  Delete in 2.9.  */ \\\n-    {\"cypress\", 0,\t\t\t\t\t\t\t\\\n-     N_(\"Optimize for Cypress processors\") }, \t\t\t\t\\\n-    {\"sparclite\", 0,\t\t\t\t\t\t\t\\\n-     N_(\"Optimize for SPARCLite processors\") }, \t\t\t\\\n-    {\"f930\", 0,\t\t\t\t\t\t\t\t\\\n-     N_(\"Optimize for F930 processors\") }, \t\t\t\t\\\n-    {\"f934\", 0,\t\t\t\t\t\t\t\t\\\n-     N_(\"Optimize for F934 processors\") }, \t\t\t\t\\\n-    {\"v8\", 0,\t\t\t\t\t\t\t\t\\\n-     N_(\"Use V8 SPARC ISA\") }, \t\t\t\t\t\t\\\n-    {\"supersparc\", 0,\t\t\t\t\t\t\t\\\n-     N_(\"Optimize for SuperSPARC processors\") }, \t\t\t\\\n-    /* End of deprecated options.  */\t\t\t\t\t\\\n     {\"ptr64\", MASK_PTR64,\t\t\t\t\t\t\\\n      N_(\"Pointers are 64-bit\") }, \t\t\t\t\t\\\n     {\"ptr32\", -MASK_PTR64,\t\t\t\t\t\t\\\n@@ -874,7 +851,7 @@ if (TARGET_ARCH64\t\t\t\t\\\n \n /* Argument passing regs.  */\n #define SPARC_OUTGOING_INT_ARG_FIRST 8\n-#define SPARC_INCOMING_INT_ARG_FIRST (TARGET_FLAT ? 8 : 24)\n+#define SPARC_INCOMING_INT_ARG_FIRST 24\n #define SPARC_FP_ARG_FIRST           32\n \n /* 1 for registers that have pervasive standard uses\n@@ -995,19 +972,6 @@ do\t\t\t\t\t\t\t\t\\\n       fixed_regs[4] = 1;\t\t\t\t\t\\\n     else if (fixed_regs[4] == 2)\t\t\t\t\\\n       fixed_regs[4] = 0;\t\t\t\t\t\\\n-    if (TARGET_FLAT)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tint regno;\t\t\t\t\t\t\\\n-\t/* Let the compiler believe the frame pointer is still\t\\\n-\t   %fp, but output it as %i7.  */\t\t\t\\\n-\tfixed_regs[31] = 1;\t\t\t\t\t\\\n-\treg_names[HARD_FRAME_POINTER_REGNUM] = \"%i7\";\t\t\\\n-\t/* Disable leaf functions */\t\t\t\t\\\n-\tmemset (sparc_leaf_regs, 0, FIRST_PSEUDO_REGISTER);\t\\\n-\t/* Make LEAF_REG_REMAP a noop.  */\t\t\t\\\n-\tfor (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n-\t  leaf_reg_remap [regno] = regno;\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\\\n while (0)\n \n@@ -1100,16 +1064,9 @@ extern int sparc_mode_class[];\n    Zero means the frame pointer need not be set up (and parms\n    may be accessed via the stack pointer) in functions that seem suitable.\n    This is computed in `reload', in reload1.c.\n-   Used in flow.c, global.c, and reload1.c.\n-\n-   Being a non-leaf function does not mean a frame pointer is needed in the\n-   flat window model.  However, the debugger won't be able to backtrace through\n-   us with out it.  */\n-#define FRAME_POINTER_REQUIRED\t\t\t\t\\\n-  (TARGET_FLAT\t\t\t\t\t\t\\\n-   ? (current_function_calls_alloca\t\t\t\\\n-      || !leaf_function_p ())\t\t\t\t\\\n-   : ! (leaf_function_p () && only_leaf_regs_used ()))\n+   Used in flow.c, global.c, and reload1.c.  */\n+#define FRAME_POINTER_REQUIRED\t\\\n+  (! (leaf_function_p () && only_leaf_regs_used ()))\n \n /* Base register for access to arguments of the function.  */\n #define ARG_POINTER_REGNUM FRAME_POINTER_REGNUM\n@@ -1573,7 +1530,6 @@ extern char leaf_reg_remap[];\n #define REG_PARM_STACK_SPACE(DECL) (6 * UNITS_PER_WORD)\n \n /* Definitions for register elimination.  */\n-/* ??? In TARGET_FLAT mode we needn't have a hard frame pointer.  */\n \n #define ELIMINABLE_REGS \\\n   {{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}, \\\n@@ -1590,17 +1546,11 @@ extern char leaf_reg_remap[];\n   do {\t\t\t\t\t\t\t\t\\\n     (OFFSET) = 0;\t\t\t\t\t\t\\\n     if ((TO) == STACK_POINTER_REGNUM)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\t/* Note, we always pretend that this is a leaf function\t\\\n-\t   because if it's not, there's no point in trying to\t\\\n-\t   eliminate the frame pointer.  If it is a leaf\t\\\n-\t   function, we guessed right!  */\t\t\t\\\n-\tif (TARGET_FLAT)\t\t\t\t\t\\\n-\t  (OFFSET) =\t\t\t\t\t\t\\\n-\t    sparc_flat_compute_frame_size (get_frame_size ());\t\\\n-\telse\t\t\t\t\t\t\t\\\n-\t  (OFFSET) = compute_frame_size (get_frame_size (), 1);\t\\\n-      }\t\t\t\t\t\t\t\t\\\n+      /* Note, we always pretend that this is a leaf function\t\\\n+\t because if it's not, there's no point in trying to\t\\\n+\t eliminate the frame pointer.  If it is a leaf\t\t\\\n+\t function, we guessed right!  */\t\t\t\\\n+      (OFFSET) = compute_frame_size (get_frame_size (), 1);\t\\\n     (OFFSET) += SPARC_STACK_BIAS;\t\t\t\t\\\n   } while (0)\n \n@@ -1622,52 +1572,41 @@ extern char leaf_reg_remap[];\n /* Some subroutine macros specific to this machine.\n    When !TARGET_FPU, put float return values in the general registers,\n    since we don't have any fp registers.  */\n-#define BASE_RETURN_VALUE_REG(MODE)\t\t\t\t\t\\\n-  (TARGET_ARCH64\t\t\t\t\t\t\t\\\n-   ? (TARGET_FPU && FLOAT_MODE_P (MODE) ? 32 : 8)\t\t\t\\\n-   : (TARGET_FPU && FLOAT_MODE_P (MODE) && (MODE) != TFmode ? 32 : 8))\n+#define BASE_RETURN_VALUE_REG(MODE)\t\\\n+  (TARGET_FPU && FLOAT_MODE_P (MODE) ? 32 : 8)\n \n-#define BASE_OUTGOING_VALUE_REG(MODE)\t\t\t\t\\\n-  (TARGET_ARCH64\t\t\t\t\t\t\\\n-   ? (TARGET_FPU && FLOAT_MODE_P (MODE) ? 32\t\t\t\\\n-      : TARGET_FLAT ? 8 : 24)\t\t\t\t\t\\\n-   : (TARGET_FPU && FLOAT_MODE_P (MODE) && (MODE) != TFmode ? 32\\\n-      : (TARGET_FLAT ? 8 : 24)))\n+#define BASE_OUTGOING_VALUE_REG(MODE)\t\\\n+  (TARGET_FPU && FLOAT_MODE_P (MODE) ? 32 : 24)\n \n #define BASE_PASSING_ARG_REG(MODE)\t\t\t\t\\\n-  (TARGET_ARCH64\t\t\t\t\t\t\\\n-   ? (TARGET_FPU && FLOAT_MODE_P (MODE) ? 32 : 8)\t\t\\\n-   : 8)\n+  (TARGET_ARCH64 && TARGET_FPU && FLOAT_MODE_P (MODE) ? 32 : 8)\n \n /* ??? FIXME -- seems wrong for v9 structure passing...  */\n #define BASE_INCOMING_ARG_REG(MODE)\t\t\t\t\\\n-  (TARGET_ARCH64\t\t\t\t\t\t\\\n-   ? (TARGET_FPU && FLOAT_MODE_P (MODE) ? 32\t\t\t\\\n-      : TARGET_FLAT ? 8 : 24)\t\t\t\t\t\\\n-   : (TARGET_FLAT ? 8 : 24))\n+  (TARGET_ARCH64 && TARGET_FPU && FLOAT_MODE_P (MODE) ? 32 : 24)\n \n /* Define this macro if the target machine has \"register windows\".  This\n    C expression returns the register number as seen by the called function\n    corresponding to register number OUT as seen by the calling function.\n    Return OUT if register number OUT is not an outbound register.  */\n \n #define INCOMING_REGNO(OUT) \\\n- ((TARGET_FLAT || (OUT) < 8 || (OUT) > 15) ? (OUT) : (OUT) + 16)\n+ (((OUT) < 8 || (OUT) > 15) ? (OUT) : (OUT) + 16)\n \n /* Define this macro if the target machine has \"register windows\".  This\n    C expression returns the register number as seen by the calling function\n    corresponding to register number IN as seen by the called function.\n    Return IN if register number IN is not an inbound register.  */\n \n #define OUTGOING_REGNO(IN) \\\n- ((TARGET_FLAT || (IN) < 24 || (IN) > 31) ? (IN) : (IN) - 16)\n+ (((IN) < 24 || (IN) > 31) ? (IN) : (IN) - 16)\n \n /* Define this macro if the target machine has register windows.  This\n    C expression returns true if the register is call-saved but is in the\n    register window.  */\n \n #define LOCAL_REGNO(REGNO) \\\n-  (TARGET_FLAT ? 0 : (REGNO) >= 16 && (REGNO) <= 31)\n+  ((REGNO) >= 16 && (REGNO) <= 31)\n \n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n@@ -1883,15 +1822,13 @@ do {\t\t\t\t\t\t\t\t\t\\\n  (get_frame_size () != 0\t\\\n   || current_function_calls_alloca || current_function_outgoing_args_size)\n \n-#define DELAY_SLOTS_FOR_EPILOGUE \\\n-  (TARGET_FLAT ? sparc_flat_epilogue_delay_slots () : 1)\n+#define DELAY_SLOTS_FOR_EPILOGUE 1\n+\n #define ELIGIBLE_FOR_EPILOGUE_DELAY(trial, slots_filled) \\\n-  (TARGET_FLAT ? sparc_flat_eligible_for_epilogue_delay (trial, slots_filled) \\\n-   : eligible_for_epilogue_delay (trial, slots_filled))\n+  eligible_for_epilogue_delay (trial, slots_filled)\n \n /* Define registers used by the epilogue and return instruction.  */\n-#define EPILOGUE_USES(REGNO) \\\n-  (!TARGET_FLAT && REGNO == 31)\n+#define EPILOGUE_USES(REGNO) (REGNO == 31)\n \f\n /* Length in units of the trampoline for entering a nested function.  */\n \n@@ -1924,8 +1861,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* Given an rtx for the address of a frame,\n    return an rtx for the address of the word in the frame\n-   that holds the dynamic chain--the previous frame's address.\n-   ??? -mflat support? */\n+   that holds the dynamic chain--the previous frame's address.  */\n #define DYNAMIC_CHAIN_ADDRESS(frame)\t\\\n   plus_constant (frame, 14 * UNITS_PER_WORD + SPARC_STACK_BIAS)\n "}, {"sha": "2a060b85be9cb421209aa922529c23eb7d9934ff", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 4, "deletions": 55, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=60b85c4c0e161c6e2fe58c70454cb46d553dbe83", "patch": "@@ -80,12 +80,12 @@\n ;; Attribute for the instruction set.\n ;; At present we only need to distinguish v9/!v9, but for clarity we\n ;; test TARGET_V8 too.\n-(define_attr \"isa\" \"v6,v8,v9,sparclet\"\n+(define_attr \"isa\" \"v7,v8,v9,sparclet\"\n  (const\n   (cond [(symbol_ref \"TARGET_V9\") (const_string \"v9\")\n \t (symbol_ref \"TARGET_V8\") (const_string \"v8\")\n \t (symbol_ref \"TARGET_SPARCLET\") (const_string \"sparclet\")]\n-\t(const_string \"v6\"))))\n+\t(const_string \"v7\"))))\n \n ;; Architecture size.\n (define_attr \"arch\" \"arch32bit,arch64bit\"\n@@ -124,9 +124,6 @@\n (define_attr \"current_function_calls_alloca\" \"false,true\"\n   (symbol_ref \"current_function_calls_alloca != 0\"))\n \n-(define_attr \"flat\" \"false,true\"\n-  (symbol_ref \"TARGET_FLAT != 0\"))\n-\n ;; Length (in # of insns).\n (define_attr \"length\" \"\"\n   (cond [(eq_attr \"type\" \"uncond_branch,call,sibcall\")\n@@ -7724,7 +7721,6 @@\n   \"jmp\\t%a0%#\"\n   [(set_attr \"type\" \"uncond_branch\")])\n \n-;; ??? Doesn't work with -mflat.\n (define_expand \"nonlocal_goto\"\n   [(match_operand:SI 0 \"general_operand\" \"\")\n    (match_operand:SI 1 \"general_operand\" \"\")\n@@ -7839,7 +7835,7 @@\n {\n   if (! current_function_calls_alloca)\n     return \"\";\n-  if (! TARGET_V9 || TARGET_FLAT)\n+  if (! TARGET_V9)\n     return \"\\tta\\t3\\n\";\n   fputs (\"\\tflushw\\n\", asm_out_file);\n   if (flag_pic)\n@@ -7858,8 +7854,6 @@\n    (set (attr \"length\")\n         (cond [(eq_attr \"current_function_calls_alloca\" \"false\")\n                  (const_int 0)\n-               (eq_attr \"flat\" \"true\")\n-                 (const_int 1)\n                (eq_attr \"isa\" \"!v9\")\n                  (const_int 1)\n                (eq_attr \"pic\" \"true\")\n@@ -8107,7 +8101,7 @@\n \t\t   (compare:CCX (match_dup 1) (const_int 0)))])]\n   \"\")\n \n-;; Return peepholes.  These are generated by sparc_nonflat_function_epilogue\n+;; Return peepholes.  These are generated by sparc_function_epilogue\n ;; who then immediately calls final_scan_insn.\n \n (define_insn \"*return_qi\"\n@@ -8267,31 +8261,6 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"2\")])\n \n-;; Now peepholes to do a call followed by a jump.\n-\n-(define_peephole\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n-\t\t   (call (mem:SI (match_operand:SI 1 \"call_operand_address\" \"ps\"))\n-\t\t\t (match_operand 2 \"\" \"\")))\n-\t      (clobber (reg:SI 15))])\n-   (set (pc) (label_ref (match_operand 3 \"\" \"\")))]\n-  \"short_branch (INSN_UID (insn), INSN_UID (operands[3]))\n-   && (USING_SJLJ_EXCEPTIONS || ! can_throw_internal (ins1))\n-   && sparc_cpu != PROCESSOR_ULTRASPARC\n-   && sparc_cpu != PROCESSOR_ULTRASPARC3\"\n-  \"call\\t%a1, %2\\n\\tadd\\t%%o7, (%l3-.-4), %%o7\")\n-\n-(define_peephole\n-  [(parallel [(call (mem:SI (match_operand:SI 0 \"call_operand_address\" \"ps\"))\n-\t\t    (match_operand 1 \"\" \"\"))\n-\t      (clobber (reg:SI 15))])\n-   (set (pc) (label_ref (match_operand 2 \"\" \"\")))]\n-  \"short_branch (INSN_UID (insn), INSN_UID (operands[2]))\n-   && (USING_SJLJ_EXCEPTIONS || ! can_throw_internal (ins1))\n-   && sparc_cpu != PROCESSOR_ULTRASPARC\n-   && sparc_cpu != PROCESSOR_ULTRASPARC3\"\n-  \"call\\t%a0, %1\\n\\tadd\\t%%o7, (%l2-.-4), %%o7\")\n-\n ;; ??? UltraSPARC-III note: A memory operation loading into the floating point register\n ;; ??? file, if it hits the prefetch cache, has a chance to dual-issue with other memory\n ;; ??? operations.  With DFA we might be able to model this, but it requires a lot of\n@@ -8370,26 +8339,6 @@\n   load_pic_register ();\n   DONE;\n })\n-\n-;; We need to reload %l7 for -mflat -fpic,\n-;; otherwise %l7 should be preserved simply\n-;; by loading the function's register window\n-(define_expand \"exception_receiver\"\n-  [(const_int 0)]\n-  \"TARGET_FLAT && flag_pic\"\n-{\n-  load_pic_register ();\n-  DONE;\n-})\n-\n-;; Likewise\n-(define_expand \"builtin_setjmp_receiver\"\n-  [(label_ref (match_operand 0 \"\" \"\"))]\n-  \"TARGET_FLAT && flag_pic\"\n-{\n-  load_pic_register ();\n-  DONE;\n-})\n \f\n (define_insn \"trap\"\n   [(trap_if (const_int 1) (const_int 5))]"}, {"sha": "27492b91cb89b7917e16b16bfc83a059ec4a74c8", "filename": "gcc/config/sparc/t-sparclite", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Fconfig%2Fsparc%2Ft-sparclite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Fconfig%2Fsparc%2Ft-sparclite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Ft-sparclite?ref=60b85c4c0e161c6e2fe58c70454cb46d553dbe83", "patch": "@@ -15,7 +15,7 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n \techo '#define US_SOFTWARE_GOFAST' >> fp-bit.c\n \tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n \n-MULTILIB_OPTIONS = mfpu mflat\n+MULTILIB_OPTIONS = mfpu\n MULTILIB_DIRNAMES =\n MULTILIB_MATCHES = mfpu=mhard-float mfpu=mcpu?f934\n "}, {"sha": "6ed5e0840e2524baa3d5a7657bfb89844f3798aa", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 41, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=60b85c4c0e161c6e2fe58c70454cb46d553dbe83", "patch": "@@ -359,15 +359,12 @@ in the following sections.\n -mcmodel=@var{code-model} @gol\n -m32  -m64  -mapp-regs  -mno-app-regs @gol\n -mfaster-structs  -mno-faster-structs @gol\n--mflat  -mno-flat  -mfpu  -mno-fpu @gol\n--mhard-float  -msoft-float @gol\n+-mfpu  -mno-fpu  -mhard-float  -msoft-float @gol\n -mhard-quad-float  -msoft-quad-float @gol\n -mimpure-text  -mno-impure-text  -mlittle-endian @gol\n -mstack-bias  -mno-stack-bias @gol\n -munaligned-doubles  -mno-unaligned-doubles @gol\n--mv8plus  -mno-v8plus  -mvis  -mno-vis @gol\n--mcypress  -mf930  -mf934 @gol\n--msparclite  -msupersparc  -mv8}\n+-mv8plus  -mno-v8plus  -mvis  -mno-vis}\n \n @emph{ARM Options}\n @gccoptlist{-mapcs-frame  -mno-apcs-frame @gol\n@@ -6212,22 +6209,6 @@ emulates the effect of the instruction.  Because of the trap handler overhead,\n this is much slower than calling the ABI library routines.  Thus the\n @option{-msoft-quad-float} option is the default.\n \n-@item -mno-flat\n-@itemx -mflat\n-@opindex mno-flat\n-@opindex mflat\n-With @option{-mflat}, the compiler does not generate save/restore instructions\n-and will use a ``flat'' or single register window calling convention.\n-This model uses %i7 as the frame pointer and is compatible with the normal\n-register window model.  Code from either may be intermixed.\n-The local registers and the input registers (0--5) are still treated as\n-``call saved'' registers and will be saved on the stack as necessary.\n-\n-With @option{-mno-flat} (the default), the compiler emits save/restore\n-instructions (except for leaf functions) and is the normal mode of operation.\n-\n-These options are deprecated and will be deleted in a future GCC release.\n-\n @item -mno-unaligned-doubles\n @itemx -munaligned-doubles\n @opindex mno-unaligned-doubles\n@@ -6270,26 +6251,6 @@ using @option{-mimpure-text}, you should compile all source code with\n \n This option is only available on SunOS and Solaris.\n \n-@item -mv8\n-@itemx -msparclite\n-@opindex mv8\n-@opindex msparclite\n-These two options select variations on the SPARC architecture.\n-These options are deprecated and will be deleted in a future GCC release.\n-They have been replaced with @option{-mcpu=xxx}.\n-\n-@item -mcypress\n-@itemx -msupersparc\n-@itemx -mf930\n-@itemx -mf934\n-@opindex mcypress\n-@opindex msupersparc\n-@opindex -mf930\n-@opindex -mf934\n-These four options select the processor for which the code is optimized.\n-These options are deprecated and will be deleted in a future GCC release.\n-They have been replaced with @option{-mcpu=xxx}.\n-\n @item -mcpu=@var{cpu_type}\n @opindex mcpu\n Set the instruction set, register set, and instruction scheduling parameters"}, {"sha": "873e6bbc5f28d8d4ad4cafc4a3a9675ade36d656", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=60b85c4c0e161c6e2fe58c70454cb46d553dbe83", "patch": "@@ -1,3 +1,7 @@\n+2004-02-03  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* gcc.dg/20020503-1.c: Remove -mflat dg-options.\n+\n 2004-02-03  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR c/11658"}, {"sha": "3edc7cf98589fda327bc2ff72768454a31f31559", "filename": "gcc/testsuite/gcc.dg/20020503-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Ftestsuite%2Fgcc.dg%2F20020503-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b85c4c0e161c6e2fe58c70454cb46d553dbe83/gcc%2Ftestsuite%2Fgcc.dg%2F20020503-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20020503-1.c?ref=60b85c4c0e161c6e2fe58c70454cb46d553dbe83", "patch": "@@ -5,7 +5,6 @@\n    returned -1 for some registers (like %o0).  */\n /* { dg-do compile } */\n /* { dg-options \"-O2 -g\" } */\n-/* { dg-options \"-O2 -g -mflat\" { target sparc*-*-* } } */\n \n void foo (char *a, char *b, char *c, char *d)\n {"}]}