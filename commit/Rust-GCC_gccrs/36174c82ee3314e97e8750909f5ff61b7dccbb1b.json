{"sha": "36174c82ee3314e97e8750909f5ff61b7dccbb1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYxNzRjODJlZTMzMTRlOTdlODc1MDkwOWY1ZmY2MWI3ZGNjYmIxYg==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2008-10-15T16:13:33Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2008-10-15T16:13:33Z"}, "message": "re PR tree-optimization/37686 (Building of CPU2000's bzip2 with peak flags with -mcpu=power4 fails with an ICE.)\n\n2008-10-15  Sebastian Pop  <sebastian.pop@amd.com>\n\n\tPR tree-optimization/37686\n\t* testsuite/gcc.dg/tree-ssa/pr37686.c: New.\n\t* tree-loop-linear.c (linear_transform_loops): Build a\n\tloop nest vector.  Pass it to lambda_compute_access_matrices.\n\t* tree-data-ref.h (struct access_matrix): Store the loop nest\n\trelative to which it encodes the information.\n\t(AM_LOOP_NEST_NUM): Renamed AM_LOOP_NEST.\n\t(am_vector_index_for_loop): Reimplemented: iterate over the\n\tloop nest for finding the loop index in the access matrix.\n\t(lambda_compute_access_matrices): Update declaration.\n\t* lambda-code.c (build_access_matrix): Pass the loop nest and\n\trecord it.\n\t(lambda_compute_access_matrices): Same.\n\nFrom-SVN: r141141", "tree": {"sha": "2a696ea15c824e9308e4456e69b42c210b4e281b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a696ea15c824e9308e4456e69b42c210b4e281b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36174c82ee3314e97e8750909f5ff61b7dccbb1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36174c82ee3314e97e8750909f5ff61b7dccbb1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36174c82ee3314e97e8750909f5ff61b7dccbb1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36174c82ee3314e97e8750909f5ff61b7dccbb1b/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb06824788e06fcc4d2ba65724feae2bf5cfed15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb06824788e06fcc4d2ba65724feae2bf5cfed15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb06824788e06fcc4d2ba65724feae2bf5cfed15"}], "stats": {"total": 105, "additions": 91, "deletions": 14}, "files": [{"sha": "1ac849fed6f1d5be6216741abafc5f1afec576cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36174c82ee3314e97e8750909f5ff61b7dccbb1b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36174c82ee3314e97e8750909f5ff61b7dccbb1b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=36174c82ee3314e97e8750909f5ff61b7dccbb1b", "patch": "@@ -1,3 +1,18 @@\n+2008-10-15  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR tree-optimization/37686\n+\t* tree-loop-linear.c (linear_transform_loops): Build a\n+\tloop nest vector.  Pass it to lambda_compute_access_matrices.\n+\t* tree-data-ref.h (struct access_matrix): Store the loop nest\n+\trelative to which it encodes the information.\n+\t(AM_LOOP_NEST_NUM): Renamed AM_LOOP_NEST.\n+\t(am_vector_index_for_loop): Reimplemented: iterate over the\n+\tloop nest for finding the loop index in the access matrix.\n+\t(lambda_compute_access_matrices): Update declaration.\n+\t* lambda-code.c (build_access_matrix): Pass the loop nest and\n+\trecord it.\n+\t(lambda_compute_access_matrices): Same.\n+\n 2008-10-15  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* config/s390/s390.h: (TARGET_DFP): This requires TARGET_HARD_FLOAT."}, {"sha": "1bf9ddfbf9b9456cf1d98fc58f675a0445a89d50", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36174c82ee3314e97e8750909f5ff61b7dccbb1b/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36174c82ee3314e97e8750909f5ff61b7dccbb1b/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=36174c82ee3314e97e8750909f5ff61b7dccbb1b", "patch": "@@ -2786,17 +2786,15 @@ av_for_af (tree access_fun, lambda_vector cy, struct access_matrix *am)\n \n static bool\n build_access_matrix (data_reference_p data_reference,\n-\t\t     VEC (tree, heap) *parameters, int loop_nest_num)\n+\t\t     VEC (tree, heap) *parameters, VEC (loop_p, heap) *nest)\n {\n   struct access_matrix *am = GGC_NEW (struct access_matrix);\n   unsigned i, ndim = DR_NUM_DIMENSIONS (data_reference);\n-  struct loop *loop = gimple_bb (DR_STMT (data_reference))->loop_father;\n-  struct loop *loop_nest = get_loop (loop_nest_num);\n-  unsigned nivs = loop_depth (loop) - loop_depth (loop_nest) + 1;\n+  unsigned nivs = VEC_length (loop_p, nest);\n   unsigned lambda_nb_columns;\n   lambda_vector_vec_p matrix;\n \n-  AM_LOOP_NEST_NUM (am) = loop_nest_num;\n+  AM_LOOP_NEST (am) = nest;\n   AM_NB_INDUCTION_VARS (am) = nivs;\n   AM_PARAMETERS (am) = parameters;\n \n@@ -2824,13 +2822,13 @@ build_access_matrix (data_reference_p data_reference,\n bool\n lambda_compute_access_matrices (VEC (data_reference_p, heap) *datarefs,\n \t\t\t\tVEC (tree, heap) *parameters,\n-\t\t\t\tint loop_nest_num)\n+\t\t\t\tVEC (loop_p, heap) *nest)\n {\n   data_reference_p dataref;\n   unsigned ix;\n \n   for (ix = 0; VEC_iterate (data_reference_p, datarefs, ix, dataref); ix++)\n-    if (!build_access_matrix (dataref, parameters, loop_nest_num))\n+    if (!build_access_matrix (dataref, parameters, nest))\n       return false;\n \n   return true;"}, {"sha": "328a51412b0462b10a53a04bdae42abbba4a1d6c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36174c82ee3314e97e8750909f5ff61b7dccbb1b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36174c82ee3314e97e8750909f5ff61b7dccbb1b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=36174c82ee3314e97e8750909f5ff61b7dccbb1b", "patch": "@@ -1,3 +1,8 @@\n+2008-10-15  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR tree-optimization/37686\n+\t* testsuite/gcc.dg/tree-ssa/pr37686.c: New.\n+\n 2008-10-15  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/36881"}, {"sha": "a5094bf97544560278a794744d13eca05ce31fe0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr37686.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36174c82ee3314e97e8750909f5ff61b7dccbb1b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr37686.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36174c82ee3314e97e8750909f5ff61b7dccbb1b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr37686.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr37686.c?ref=36174c82ee3314e97e8750909f5ff61b7dccbb1b", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile { target powerpc*-*-* } } */\n+/* { dg-options \"-O3 -ftree-loop-linear\" } */\n+\n+unsigned char inUse[256];\n+unsigned char len[6][258];\n+int code[6][258];\n+unsigned int crc32Table[256] = { };\n+  unsigned int getGlobalCRC (void) { }\n+  int bsLive;\n+void bsW (int n, unsigned int v) {\n+ while (bsLive >= 8) {}\n+ }\n+ void hbAssignCodes (int * code,         unsigned char * length, int minLen,\n+int maxLen, int alphaSize) {\n+   int n, vec, i;\n+   for (n = minLen;n <= maxLen;n++)\n+       for (i = 0; i < alphaSize;i++)\n+      code[i] = vec;\n+   }\n+  void sendMTFValues (void) {\n+   int v, t, i, j, gs, ge, totc, bt, bc, iter;\n+   int nSelectors, alphaSize, minLen, maxLen, selCtr;\n+   int nGroups, nBytes;\n+ {\n+    while (1)\n+  {\n+  break;\n+  }\n+       hbAssignCodes (&code[t][0], &len[t][0], minLen, maxLen, alphaSize);\n+     unsigned char inUse16[16];\n+     for (i = 0;i < 16;i++)\n+ if (inUse16[i])\n+  {\n+      for (j = 0;j < 16;j++)\n+   if (inUse[i * 16 + j])    { }\n+    }\n+   }\n+   for (i = 0; i < nSelectors;i++)     { }\n+   for (t = 0; t < nGroups;t++)\n+ {\n+       int curr = len[t][0];\n+       for (i = 0; i < alphaSize;i++)\n+          while (curr < len[t][i])     { }\n+     }\n+   while (1)\n+       for (i = gs; i <= ge;i++)  { }\n+ }\n+"}, {"sha": "bd36d237e7ef37fff8d5625a53a2a45e80495387", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36174c82ee3314e97e8750909f5ff61b7dccbb1b/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36174c82ee3314e97e8750909f5ff61b7dccbb1b/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=36174c82ee3314e97e8750909f5ff61b7dccbb1b", "patch": "@@ -128,13 +128,13 @@ typedef struct scop *scop_p;\n */\n struct access_matrix\n {\n-  int loop_nest_num;\n+  VEC (loop_p, heap) *loop_nest;\n   int nb_induction_vars;\n   VEC (tree, heap) *parameters;\n   VEC (lambda_vector, heap) *matrix;\n };\n \n-#define AM_LOOP_NEST_NUM(M) (M)->loop_nest_num\n+#define AM_LOOP_NEST(M) (M)->loop_nest\n #define AM_NB_INDUCTION_VARS(M) (M)->nb_induction_vars\n #define AM_PARAMETERS(M) (M)->parameters\n #define AM_MATRIX(M) (M)->matrix\n@@ -149,8 +149,14 @@ struct access_matrix\n static inline int\n am_vector_index_for_loop (struct access_matrix *access_matrix, int loop_num)\n {\n-  gcc_assert (loop_num >= AM_LOOP_NEST_NUM (access_matrix));\n-  return loop_num - AM_LOOP_NEST_NUM (access_matrix);\n+  int i;\n+  loop_p l;\n+\n+  for (i = 0; VEC_iterate (loop_p, AM_LOOP_NEST (access_matrix), i, l); i++)\n+    if (l->num == loop_num)\n+      return i;\n+\n+  gcc_unreachable();\n }\n \n int access_matrix_get_index_for_parameter (tree, struct access_matrix *);\n@@ -581,7 +587,7 @@ bool lambda_transform_legal_p (lambda_trans_matrix, int,\n void lambda_collect_parameters (VEC (data_reference_p, heap) *,\n \t\t\t\tVEC (tree, heap) **);\n bool lambda_compute_access_matrices (VEC (data_reference_p, heap) *,\n-\t\t\t\t     VEC (tree, heap) *, int);\n+\t\t\t\t     VEC (tree, heap) *, VEC (loop_p, heap) *);\n \n /* In tree-data-ref.c  */\n void split_constant_offset (tree , tree *, tree *);"}, {"sha": "8b57e2acf10931732b1ce7154a6e39e18bf7a752", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36174c82ee3314e97e8750909f5ff61b7dccbb1b/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36174c82ee3314e97e8750909f5ff61b7dccbb1b/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=36174c82ee3314e97e8750909f5ff61b7dccbb1b", "patch": "@@ -333,11 +333,16 @@ linear_transform_loops (void)\n       lambda_loopnest before, after;\n       lambda_trans_matrix trans;\n       struct obstack lambda_obstack;\n+      struct loop *loop;\n+      VEC(loop_p,heap) *nest = VEC_alloc (loop_p, heap, 3);\n \n       depth = perfect_loop_nest_depth (loop_nest);\n       if (depth == 0)\n \tcontinue;\n \n+      for (loop = loop_nest; loop; loop = loop->inner)\n+\tVEC_safe_push (loop_p, heap, nest, loop);\n+\n       gcc_obstack_init (&lambda_obstack);\n       VEC_truncate (tree, oldivs, 0);\n       VEC_truncate (tree, invariants, 0);\n@@ -350,8 +355,7 @@ linear_transform_loops (void)\n \tgoto free_and_continue;\n       \n       lambda_collect_parameters (datarefs, &lambda_parameters);\n-      if (!lambda_compute_access_matrices (datarefs, lambda_parameters,\n-\t\t\t\t\t   loop_nest->num))\n+      if (!lambda_compute_access_matrices (datarefs, lambda_parameters, nest))\n \tgoto free_and_continue;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -410,6 +414,7 @@ linear_transform_loops (void)\n       obstack_free (&lambda_obstack, NULL);\n       free_dependence_relations (dependence_relations);\n       free_data_refs (datarefs);\n+      VEC_free (loop_p, heap, nest);\n     }\n \n   for (i = 0; VEC_iterate (gimple, remove_ivs, i, oldiv_stmt); i++)"}]}