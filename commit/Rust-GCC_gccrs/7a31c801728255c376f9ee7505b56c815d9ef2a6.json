{"sha": "7a31c801728255c376f9ee7505b56c815d9ef2a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2EzMWM4MDE3MjgyNTVjMzc2ZjllZTc1MDViNTZjODE1ZDllZjJhNg==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2005-07-02T23:06:40Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2005-07-02T23:06:40Z"}, "message": "re PR target/21742 (unrecognized insn for struct-layout-1 tests with complex members)\n\n        PR middle-end/21742\n        * expr.c (write_complex_part): Use adjust_address for MEM.\n        (read_complex_part): Same.\n\nFrom-SVN: r101539", "tree": {"sha": "88e11d66bf721bd40638fb338c82eba312c9bd40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88e11d66bf721bd40638fb338c82eba312c9bd40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a31c801728255c376f9ee7505b56c815d9ef2a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a31c801728255c376f9ee7505b56c815d9ef2a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a31c801728255c376f9ee7505b56c815d9ef2a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a31c801728255c376f9ee7505b56c815d9ef2a6/comments", "author": null, "committer": null, "parents": [{"sha": "5f013fd0e8233d22b74363e22762ba2ac43e11eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f013fd0e8233d22b74363e22762ba2ac43e11eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f013fd0e8233d22b74363e22762ba2ac43e11eb"}], "stats": {"total": 37, "additions": 27, "deletions": 10}, "files": [{"sha": "fc32d271f60f1fb6a65bea52f5ffddfe2279a47e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a31c801728255c376f9ee7505b56c815d9ef2a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a31c801728255c376f9ee7505b56c815d9ef2a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a31c801728255c376f9ee7505b56c815d9ef2a6", "patch": "@@ -1,3 +1,9 @@\n+2005-07-02  David Edelsohn  <edelsohn@gnu.org>\n+\n+\tPR middle-end/21742\n+\t* expr.c (write_complex_part): Use adjust_address for MEM.\n+\t(read_complex_part): Same.\n+\n 2005-07-02  Daniel Berlin  <dberlin@dberlin.org>\n \n \tFix PR tree-optimization/22280"}, {"sha": "a3c1b6ad9174fb1078298d32dfb03bb7413ac3df", "filename": "gcc/expr.c", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a31c801728255c376f9ee7505b56c815d9ef2a6/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a31c801728255c376f9ee7505b56c815d9ef2a6/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=7a31c801728255c376f9ee7505b56c815d9ef2a6", "patch": "@@ -2660,6 +2660,16 @@ write_complex_part (rtx cplx, rtx val, bool imag_p)\n   imode = GET_MODE_INNER (cmode);\n   ibitsize = GET_MODE_BITSIZE (imode);\n \n+  /* For MEMs simplify_gen_subreg may generate an invalid new address\n+     because, e.g., the original address is considered mode-dependent\n+     by the target, which restricts simplify_subreg from invoking\n+     adjust_address_nv.  Instead of preparing fallback support for an\n+     invalid address, we call adjust_address_nv directly.  */\n+  if (MEM_P (cplx))\n+    emit_move_insn (adjust_address_nv (cplx, imode,\n+\t\t\t\t       imag_p ? GET_MODE_SIZE (imode) : 0),\n+\t\t    val);\n+\n   /* If the sub-object is at least word sized, then we know that subregging\n      will work.  This special case is important, since store_bit_field\n      wants to operate on integer modes, and there's rarely an OImode to\n@@ -2671,11 +2681,7 @@ write_complex_part (rtx cplx, rtx val, bool imag_p)\n \t where the natural size of floating-point regs is 32-bit.  */\n       || (REG_P (cplx)\n \t  && REGNO (cplx) < FIRST_PSEUDO_REGISTER\n-\t  && hard_regno_nregs[REGNO (cplx)][cmode] % 2 == 0)\n-      /* For MEMs we always try to make a \"subreg\", that is to adjust\n-\t the MEM, because store_bit_field may generate overly\n-\t convoluted RTL for sub-word fields.  */\n-      || MEM_P (cplx))\n+\t  && hard_regno_nregs[REGNO (cplx)][cmode] % 2 == 0))\n     {\n       rtx part = simplify_gen_subreg (imode, cplx, cmode,\n \t\t\t\t      imag_p ? GET_MODE_SIZE (imode) : 0);\n@@ -2720,6 +2726,15 @@ read_complex_part (rtx cplx, bool imag_p)\n \t}\n     }\n \n+  /* For MEMs simplify_gen_subreg may generate an invalid new address\n+     because, e.g., the original address is considered mode-dependent\n+     by the target, which restricts simplify_subreg from invoking\n+     adjust_address_nv.  Instead of preparing fallback support for an\n+     invalid address, we call adjust_address_nv directly.  */\n+  if (MEM_P (cplx))\n+    return adjust_address_nv (cplx, imode,\n+\t\t\t      imag_p ? GET_MODE_SIZE (imode) : 0);\n+\n   /* If the sub-object is at least word sized, then we know that subregging\n      will work.  This special case is important, since extract_bit_field\n      wants to operate on integer modes, and there's rarely an OImode to\n@@ -2731,11 +2746,7 @@ read_complex_part (rtx cplx, bool imag_p)\n \t where the natural size of floating-point regs is 32-bit.  */\n       || (REG_P (cplx)\n \t  && REGNO (cplx) < FIRST_PSEUDO_REGISTER\n-\t  && hard_regno_nregs[REGNO (cplx)][cmode] % 2 == 0)\n-      /* For MEMs we always try to make a \"subreg\", that is to adjust\n-\t the MEM, because extract_bit_field may generate overly\n-\t convoluted RTL for sub-word fields.  */\n-      || MEM_P (cplx))\n+\t  && hard_regno_nregs[REGNO (cplx)][cmode] % 2 == 0))\n     {\n       rtx ret = simplify_gen_subreg (imode, cplx, cmode,\n \t\t\t\t     imag_p ? GET_MODE_SIZE (imode) : 0);"}]}