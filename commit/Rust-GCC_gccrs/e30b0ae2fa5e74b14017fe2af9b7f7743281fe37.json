{"sha": "e30b0ae2fa5e74b14017fe2af9b7f7743281fe37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTMwYjBhZTJmYTVlNzRiMTQwMTdmZTJhZjliN2Y3NzQzMjgxZmUzNw==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2004-09-10T16:52:45Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2004-09-10T16:52:45Z"}, "message": "Revert\n\n\t2004-09-08  Jie Zhang  <zhangjie@magima.com.cn>\n\n\t    * tree-ssa-alias.c (compute_flow_insensitive_aliasing): If type\n\t    memory tag is call clobbered, so are its aliases.\n\t    (group_aliases): When two memory tags being grouped, if one is\n\t    call clobbered, so are the other and its aliases.\n\t    (add_may_alias): Remove call-clobbering stuff.\n\t    (replace_may_alias): Likewise.\n\t    (merge_pointed_to_info): Merge pt_global_mem\n\nFrom-SVN: r87306", "tree": {"sha": "c79455968b776cc092ef673fed66add305c49749", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c79455968b776cc092ef673fed66add305c49749"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e30b0ae2fa5e74b14017fe2af9b7f7743281fe37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e30b0ae2fa5e74b14017fe2af9b7f7743281fe37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e30b0ae2fa5e74b14017fe2af9b7f7743281fe37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e30b0ae2fa5e74b14017fe2af9b7f7743281fe37/comments", "author": null, "committer": null, "parents": [{"sha": "89dbed81f485455d27b9822c1de921571580fe65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89dbed81f485455d27b9822c1de921571580fe65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89dbed81f485455d27b9822c1de921571580fe65"}], "stats": {"total": 61, "additions": 34, "deletions": 27}, "files": [{"sha": "a6d96d3796744a1dbff8a37bc7e77567665c4efa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e30b0ae2fa5e74b14017fe2af9b7f7743281fe37/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e30b0ae2fa5e74b14017fe2af9b7f7743281fe37/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e30b0ae2fa5e74b14017fe2af9b7f7743281fe37", "patch": "@@ -1,3 +1,17 @@\n+2004-09-10  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tRevert\n+\n+\t2004-09-08  Jie Zhang  <zhangjie@magima.com.cn>\n+\n+\t    * tree-ssa-alias.c (compute_flow_insensitive_aliasing): If type\n+\t    memory tag is call clobbered, so are its aliases.\n+\t    (group_aliases): When two memory tags being grouped, if one is\n+\t    call clobbered, so are the other and its aliases.\n+\t    (add_may_alias): Remove call-clobbering stuff.\n+\t    (replace_may_alias): Likewise.\n+\t    (merge_pointed_to_info): Merge pt_global_mem\n+\n 2004-09-10  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* bb-reorder.c, c-common.c, c-incpath.c, c-typeck.c,"}, {"sha": "cd41fbae49ca631e2479c592e5693a08b236f7c9", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e30b0ae2fa5e74b14017fe2af9b7f7743281fe37/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e30b0ae2fa5e74b14017fe2af9b7f7743281fe37/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=e30b0ae2fa5e74b14017fe2af9b7f7743281fe37", "patch": "@@ -924,10 +924,6 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n \t      num_tag_refs = VARRAY_UINT (ai->num_references, tag_ann->uid);\n \t      num_var_refs = VARRAY_UINT (ai->num_references, v_ann->uid);\n \n-\t      /* If TAG is call clobbered, so is VAR.  */\n-\t      if (is_call_clobbered (tag))\n-\t\tmark_call_clobbered (var);\n-\n \t      /* Add VAR to TAG's may-aliases set.  */\n \t      add_may_alias (tag, var);\n \n@@ -1120,29 +1116,8 @@ group_aliases (struct alias_info *ai)\n \t  sbitmap_a_and_b (res, tag1_aliases, tag2_aliases);\n \t  if (sbitmap_first_set_bit (res) >= 0)\n \t    {\n-\t      size_t k;\n-\n \t      tree tag2 = var_ann (ai->pointers[j]->var)->type_mem_tag;\n \n-\t      if (!is_call_clobbered (tag1) && is_call_clobbered (tag2))\n-\t\t{\n-\t\t  mark_call_clobbered (tag1);\n-\t\t  EXECUTE_IF_SET_IN_SBITMAP (tag1_aliases, 0, k,\n-\t\t    {\n-\t\t      tree var = referenced_var (k);\n-\t\t      mark_call_clobbered (var);\n-\t\t    });\n-\t\t}\n-\t      else if (is_call_clobbered (tag1) && !is_call_clobbered (tag2))\n-\t\t{\n-\t\t  mark_call_clobbered (tag2);\n-\t\t  EXECUTE_IF_SET_IN_SBITMAP (tag2_aliases, 0, k,\n-\t\t    {\n-\t\t      tree var = referenced_var (k);\n-\t\t      mark_call_clobbered (var);\n-\t\t    });\n-\t\t}\n-\n \t      sbitmap_a_or_b (tag1_aliases, tag1_aliases, tag2_aliases);\n \n \t      /* TAG2 does not need its aliases anymore.  */\n@@ -1639,6 +1614,16 @@ add_may_alias (tree var, tree alias)\n     if (alias == VARRAY_TREE (v_ann->may_aliases, i))\n       return;\n \n+  /* If VAR is a call-clobbered variable, so is its new ALIAS.\n+     FIXME, call-clobbering should only depend on whether an address\n+     escapes.  It should be independent of aliasing.  */\n+  if (is_call_clobbered (var))\n+    mark_call_clobbered (alias);\n+\n+  /* Likewise.  If ALIAS is call-clobbered, so is VAR.  */\n+  else if (is_call_clobbered (alias))\n+    mark_call_clobbered (var);\n+\n   VARRAY_PUSH_TREE (v_ann->may_aliases, alias);\n   a_ann->is_alias_tag = 1;\n }\n@@ -1651,6 +1636,16 @@ replace_may_alias (tree var, size_t i, tree new_alias)\n {\n   var_ann_t v_ann = var_ann (var);\n   VARRAY_TREE (v_ann->may_aliases, i) = new_alias;\n+\n+  /* If VAR is a call-clobbered variable, so is NEW_ALIAS.\n+     FIXME, call-clobbering should only depend on whether an address\n+     escapes.  It should be independent of aliasing.  */\n+  if (is_call_clobbered (var))\n+    mark_call_clobbered (new_alias);\n+\n+  /* Likewise.  If NEW_ALIAS is call-clobbered, so is VAR.  */\n+  else if (is_call_clobbered (new_alias))\n+    mark_call_clobbered (var);\n }\n \n \n@@ -1707,8 +1702,6 @@ merge_pointed_to_info (struct alias_info *ai, tree dest, tree orig)\n \n   if (orig_pi)\n     {\n-      dest_pi->pt_global_mem |= orig_pi->pt_global_mem;\n-\n       /* Notice that we never merge PT_MALLOC.  This attribute is only\n \t true if the pointer is the result of a malloc() call.\n \t Otherwise, we can end up in this situation:"}]}