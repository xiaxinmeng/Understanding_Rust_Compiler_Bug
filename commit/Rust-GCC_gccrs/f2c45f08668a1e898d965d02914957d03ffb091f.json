{"sha": "f2c45f08668a1e898d965d02914957d03ffb091f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJjNDVmMDg2NjhhMWU4OThkOTY1ZDAyOTE0OTU3ZDAzZmZiMDkxZg==", "commit": {"author": {"name": "Alexander Monakov", "email": "amonakov@ispras.ru", "date": "2009-04-28T10:01:52Z"}, "committer": {"name": "Alexander Monakov", "email": "amonakov@gcc.gnu.org", "date": "2009-04-28T10:01:52Z"}, "message": "20071210-2.c: New testcase.\n\ngcc/testsuite/Changelog:\n\n2009-04-28  Alexander Monakov  <amonakov@ispras.ru>\n\t* gcc.target/ia64/20071210-2.c: New testcase.\n\ngcc/Changelog:\n\n2009-04-28  Alexander Monakov  <amonakov@ispras.ru>\n\t* sel-sched-ir.c (maybe_tidy_empty_bb): Do not attempt to delete a\n\tblock if there are complex incoming edges.\n\t(sel_merge_blocks): Remove useless assert.\n\t(sel_redirect_edge_and_branch): Check that edge was redirected.\n\t* sel-sched-ir.h (_eligible_successor_edge_p): Remove assert.\n\t(sel_find_rgns): Delete declaration.\n\t* sel-sched.c (purge_empty_blocks): Attempt to remove first block of\n\tthe region when it is not a preheader.\n\nFrom-SVN: r146882", "tree": {"sha": "49f2c287d751ab49352e33fce6814bbe9a083ce9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49f2c287d751ab49352e33fce6814bbe9a083ce9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2c45f08668a1e898d965d02914957d03ffb091f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2c45f08668a1e898d965d02914957d03ffb091f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2c45f08668a1e898d965d02914957d03ffb091f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2c45f08668a1e898d965d02914957d03ffb091f/comments", "author": {"login": "amonakov", "id": 1997391, "node_id": "MDQ6VXNlcjE5OTczOTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1997391?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amonakov", "html_url": "https://github.com/amonakov", "followers_url": "https://api.github.com/users/amonakov/followers", "following_url": "https://api.github.com/users/amonakov/following{/other_user}", "gists_url": "https://api.github.com/users/amonakov/gists{/gist_id}", "starred_url": "https://api.github.com/users/amonakov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amonakov/subscriptions", "organizations_url": "https://api.github.com/users/amonakov/orgs", "repos_url": "https://api.github.com/users/amonakov/repos", "events_url": "https://api.github.com/users/amonakov/events{/privacy}", "received_events_url": "https://api.github.com/users/amonakov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7a00d767b7c149202d3a8d0600e7384940eec14d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a00d767b7c149202d3a8d0600e7384940eec14d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a00d767b7c149202d3a8d0600e7384940eec14d"}], "stats": {"total": 111, "additions": 96, "deletions": 15}, "files": [{"sha": "b7e96d18e056654ad983af6cdded41589285a15c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2c45f08668a1e898d965d02914957d03ffb091f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2c45f08668a1e898d965d02914957d03ffb091f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f2c45f08668a1e898d965d02914957d03ffb091f", "patch": "@@ -1,3 +1,13 @@\n+2009-04-28  Alexander Monakov  <amonakov@ispras.ru>\n+\t* sel-sched-ir.c (maybe_tidy_empty_bb): Do not attempt to delete a\n+\tblock if there are complex incoming edges.\n+\t(sel_merge_blocks): Remove useless assert.\n+\t(sel_redirect_edge_and_branch): Check that edge was redirected.\n+\t* sel-sched-ir.h (_eligible_successor_edge_p): Remove assert.\n+\t(sel_find_rgns): Delete declaration.\n+\t* sel-sched.c (purge_empty_blocks): Attempt to remove first block of\n+\tthe region when it is not a preheader.\n+\n 2009-04-28  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR c/39323"}, {"sha": "d3f35627815ab6287cc5ad7c5407423bf766c332", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2c45f08668a1e898d965d02914957d03ffb091f/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2c45f08668a1e898d965d02914957d03ffb091f/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=f2c45f08668a1e898d965d02914957d03ffb091f", "patch": "@@ -3481,6 +3481,8 @@ bool\n maybe_tidy_empty_bb (basic_block bb)\n {\n   basic_block succ_bb, pred_bb;\n+  edge e;\n+  edge_iterator ei;\n   bool rescan_p;\n \n   /* Keep empty bb only if this block immediately precedes EXIT and\n@@ -3492,6 +3494,11 @@ maybe_tidy_empty_bb (basic_block bb)\n               || !(single_pred_edge (bb)->flags & EDGE_FALLTHRU))))\n     return false;\n \n+  /* Do not attempt to redirect complex edges.  */\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (e->flags & EDGE_COMPLEX)\n+      return false;\n+\n   free_data_sets (bb);\n \n   /* Do not delete BB if it has more than one successor.\n@@ -3510,9 +3517,6 @@ maybe_tidy_empty_bb (basic_block bb)\n   /* Redirect all non-fallthru edges to the next bb.  */\n   while (rescan_p)\n     {\n-      edge e;\n-      edge_iterator ei;\n-\n       rescan_p = false;\n \n       FOR_EACH_EDGE (e, ei, bb->preds)\n@@ -5244,8 +5248,6 @@ sel_create_recovery_block (insn_t orig_insn)\n void\n sel_merge_blocks (basic_block a, basic_block b)\n {\n-  gcc_assert (can_merge_blocks_p (a, b));\n-\n   sel_remove_empty_bb (b, true, false);\n   merge_blocks (a, b);\n \n@@ -5290,16 +5292,18 @@ sel_redirect_edge_and_branch (edge e, basic_block to)\n   basic_block src;\n   int prev_max_uid;\n   rtx jump;\n+  edge redirected;\n \n   latch_edge_p = (pipelining_p\n                   && current_loop_nest\n                   && e == loop_latch_edge (current_loop_nest));\n \n   src = e->src;\n   prev_max_uid = get_max_uid ();\n-  \n-  redirect_edge_and_branch (e, to);\n-  gcc_assert (last_added_blocks == NULL);\n+\n+  redirected = redirect_edge_and_branch (e, to);\n+\n+  gcc_assert (redirected && last_added_blocks == NULL);\n \n   /* When we've redirected a latch edge, update the header.  */\n   if (latch_edge_p)"}, {"sha": "3d219e1568ae106a25c8c70caf9651b13904d0f5", "filename": "gcc/sel-sched-ir.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2c45f08668a1e898d965d02914957d03ffb091f/gcc%2Fsel-sched-ir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2c45f08668a1e898d965d02914957d03ffb091f/gcc%2Fsel-sched-ir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.h?ref=f2c45f08668a1e898d965d02914957d03ffb091f", "patch": "@@ -1358,10 +1358,6 @@ _eligible_successor_edge_p (edge e1, succ_iterator *ip)\n \n       e2 = EDGE_SUCC (bb, 0);\n       bb = e2->dest;\n-      \n-      /* This couldn't happen inside a region.  */\n-      gcc_assert (! in_current_region_p (bb)\n-                  || (flags & SUCCS_OUT));\n     }\n   \n   /* Save the second edge for later checks.  */\n@@ -1584,7 +1580,6 @@ extern void sel_redirect_edge_and_branch_force (edge, basic_block);\n extern void sel_init_pipelining (void);\n extern void sel_finish_pipelining (void);\n extern void sel_sched_region (int);\n-extern void sel_find_rgns (void);\n extern loop_p get_loop_nest_for_rgn (unsigned int);\n extern bool considered_for_pipelining_p (struct loop *);\n extern void make_region_from_loop_preheader (VEC(basic_block, heap) **);"}, {"sha": "b1a33beb7d04c859dee7308285666d239226ca5b", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2c45f08668a1e898d965d02914957d03ffb091f/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2c45f08668a1e898d965d02914957d03ffb091f/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=f2c45f08668a1e898d965d02914957d03ffb091f", "patch": "@@ -6483,9 +6483,10 @@ setup_current_loop_nest (int rgn)\n static void\n purge_empty_blocks (void)\n {\n-  int i ;\n+  /* Do not attempt to delete preheader.  */\n+  int i = sel_is_loop_preheader_p (BASIC_BLOCK (BB_TO_BLOCK (0))) ? 1 : 0;\n \n-  for (i = 1; i < current_nr_blocks; )\n+  while (i < current_nr_blocks)\n     {\n       basic_block b = BASIC_BLOCK (BB_TO_BLOCK (i));\n "}, {"sha": "14086b8381c35fcf92ad444da32c64a55c9ce5a8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2c45f08668a1e898d965d02914957d03ffb091f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2c45f08668a1e898d965d02914957d03ffb091f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f2c45f08668a1e898d965d02914957d03ffb091f", "patch": "@@ -1,3 +1,6 @@\n+2009-04-28  Alexander Monakov  <amonakov@ispras.ru>\n+\t* gcc.target/ia64/20071210-2.c: New testcase.\n+\n 2009-04-28  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR c/39323"}, {"sha": "96a20a73f87779301ed97844d9eceda5187ee023", "filename": "gcc/testsuite/gcc.target/ia64/20071210-2.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2c45f08668a1e898d965d02914957d03ffb091f/gcc%2Ftestsuite%2Fgcc.target%2Fia64%2F20071210-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2c45f08668a1e898d965d02914957d03ffb091f/gcc%2Ftestsuite%2Fgcc.target%2Fia64%2F20071210-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fia64%2F20071210-2.c?ref=f2c45f08668a1e898d965d02914957d03ffb091f", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Os -fselective-scheduling2\" } */\n+\n+extern void abort (void);\n+\n+struct S\n+{\n+  int n1, n2, n3, n4;\n+};\n+\n+__attribute__((noinline)) struct S\n+foo (int x, int y, int z)\n+{\n+  if (x != 10 || y != 9 || z != 8)\n+    abort ();\n+  struct S s = { 1, 2, 3, 4 };\n+  return s;\n+}\n+\n+__attribute__((noinline)) void **\n+bar (void **u, int *v)\n+{\n+  void **w = u;\n+  int *s = v, x, y, z;\n+  void **p, **q;\n+  static void *l[] = { &&lab1, &&lab1, &&lab2, &&lab3, &&lab4 };\n+\n+  if (!u)\n+    return l;\n+\n+  q = *w++;\n+  goto *q;\n+lab2:\n+  p = q;\n+  q = *w++;\n+  x = s[2];\n+  y = s[1];\n+  z = s[0];\n+  s -= 1;\n+  struct S r = foo (x, y, z);\n+  s[3] = r.n1;\n+  s[2] = r.n2;\n+  s[1] = r.n3;\n+  s[0] = r.n4;\n+  goto *q;\n+lab3:\n+  p = q;\n+  q = *w++;\n+  s += 1;\n+  s[0] = 23;\n+lab1:\n+  goto *q;\n+lab4:\n+  return 0;\n+}\n+\n+int\n+main (void)\n+{\n+  void **u = bar ((void **) 0, (int *) 0);\n+  void *t[] = { u[2], u[4] };\n+  int s[] = { 7, 8, 9, 10, 11, 12 };\n+  if (bar (t, &s[1]) != (void **) 0\n+      || s[0] != 4 || s[1] != 3 || s[2] != 2 || s[3] != 1\n+      || s[4] != 11 || s[5] != 12)\n+    abort ();\n+  return 0;\n+}"}]}