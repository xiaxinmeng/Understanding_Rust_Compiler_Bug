{"sha": "e1f28918efd6b999478fa903e355115aa6e2bff8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFmMjg5MThlZmQ2Yjk5OTQ3OGZhOTAzZTM1NTExNWFhNmUyYmZmOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2007-05-01T17:51:56Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2007-05-01T17:51:56Z"}, "message": "re PR tree-optimization/31739 (ICE at tree.c:902 compiling g-regexp.adb)\n\n\tPR tree-optimization/31739\n\t* tree-vrp.c (vrp_val_is_max): New static function.\n\t(vrp_val_is_min): New static function.\n\t(set_value_range_to_value): Use TYPE_{MAX,MIN}_VALUE rather than\n\tcopying the node.\n\t(set_value_range): Use vrp_val_is_{max,min}.\n\t(extract_range_from_assert): Likewise.\n\t(extract_range_from_binary_expr): Likewise.\n\t(extract_range_from_unary_expr): Likewise.\n\t(dump_value_range, vrp_meet): Likewise.\n\t(vrp_visit_phi_node): Likewise.\n\t* tree.c (build_distinct_type_copy): Revert change of 2007-04-27.\n\nFrom-SVN: r124334", "tree": {"sha": "f7a8af69e45e5ad8e7e93f96d73f79730bedcfd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7a8af69e45e5ad8e7e93f96d73f79730bedcfd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1f28918efd6b999478fa903e355115aa6e2bff8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1f28918efd6b999478fa903e355115aa6e2bff8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1f28918efd6b999478fa903e355115aa6e2bff8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1f28918efd6b999478fa903e355115aa6e2bff8/comments", "author": null, "committer": null, "parents": [{"sha": "1d87d70dd03280f2bf8d30a2695a3828152607cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d87d70dd03280f2bf8d30a2695a3828152607cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d87d70dd03280f2bf8d30a2695a3828152607cc"}], "stats": {"total": 139, "additions": 86, "deletions": 53}, "files": [{"sha": "4d52f1959bce56408e2e6ef8a965c023fb319c03", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f28918efd6b999478fa903e355115aa6e2bff8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f28918efd6b999478fa903e355115aa6e2bff8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e1f28918efd6b999478fa903e355115aa6e2bff8", "patch": "@@ -1,3 +1,18 @@\n+2007-05-01  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR tree-optimization/31739\n+\t* tree-vrp.c (vrp_val_is_max): New static function.\n+\t(vrp_val_is_min): New static function.\n+\t(set_value_range_to_value): Use TYPE_{MAX,MIN}_VALUE rather than\n+\tcopying the node.\n+\t(set_value_range): Use vrp_val_is_{max,min}.\n+\t(extract_range_from_assert): Likewise.\n+\t(extract_range_from_binary_expr): Likewise.\n+\t(extract_range_from_unary_expr): Likewise.\n+\t(dump_value_range, vrp_meet): Likewise.\n+\t(vrp_visit_phi_node): Likewise.\n+\t* tree.c (build_distinct_type_copy): Revert change of 2007-04-27.\n+\n 2007-05-01  Mark Mitchell  <mark@codesourcery.com>\n \n \t* config/i386/gmon-sol2.c (size_t): New type."}, {"sha": "a9141d76ed2371b088d16b9eba12a2bbaecda3fd", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 67, "deletions": 44, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f28918efd6b999478fa903e355115aa6e2bff8/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f28918efd6b999478fa903e355115aa6e2bff8/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=e1f28918efd6b999478fa903e355115aa6e2bff8", "patch": "@@ -202,6 +202,36 @@ is_overflow_infinity (tree val)\n }\n \n \n+/* Return whether VAL is equal to the maximum value of its type.  This\n+   will be true for a positive overflow infinity.  We can't do a\n+   simple equality comparison with TYPE_MAX_VALUE because C typedefs\n+   and Ada subtypes can produce types whose TYPE_MAX_VALUE is not ==\n+   to the integer constant with the same value in the type.  */\n+\n+static inline bool\n+vrp_val_is_max (tree val)\n+{\n+  tree type_max = TYPE_MAX_VALUE (TREE_TYPE (val));\n+\n+  return (val == type_max\n+\t  || (type_max != NULL_TREE\n+\t      && operand_equal_p (val, type_max, 0)));\n+}\n+\n+/* Return whether VAL is equal to the minimum value of its type.  This\n+   will be true for a negative overflow infinity.  */\n+\n+static inline bool\n+vrp_val_is_min (tree val)\n+{\n+  tree type_min = TYPE_MIN_VALUE (TREE_TYPE (val));\n+\n+  return (val == type_min\n+\t  || (type_min != NULL_TREE\n+\t      && operand_equal_p (val, type_min, 0)));\n+}\n+\n+\n /* Return true if ARG is marked with the nonnull attribute in the\n    current function signature.  */\n \n@@ -265,10 +295,7 @@ set_value_range (value_range_t *vr, enum value_range_type t, tree min,\n       gcc_assert (min && max);\n \n       if (INTEGRAL_TYPE_P (TREE_TYPE (min)) && t == VR_ANTI_RANGE)\n-\tgcc_assert ((min != TYPE_MIN_VALUE (TREE_TYPE (min))\n-\t\t     && !is_negative_overflow_infinity (min))\n-\t\t    || (max != TYPE_MAX_VALUE (TREE_TYPE (max))\n-\t\t\t&& !is_positive_overflow_infinity (max)));\n+\tgcc_assert (!vrp_val_is_min (min) || !vrp_val_is_max (max));\n \n       cmp = compare_values (min, max);\n       gcc_assert (cmp == 0 || cmp == -1 || cmp == -2);\n@@ -336,8 +363,16 @@ set_value_range_to_value (value_range_t *vr, tree val)\n   gcc_assert (is_gimple_min_invariant (val));\n   if (is_overflow_infinity (val))\n     {\n-      val = copy_node (val);\n-      TREE_OVERFLOW (val) = 0;\n+      if (operand_equal_p (val, TYPE_MAX_VALUE (TREE_TYPE (val)), 0))\n+\tval = TYPE_MAX_VALUE (TREE_TYPE (val));\n+      else\n+\t{\n+#ifdef ENABLE_CHECKING\n+\t  gcc_assert (operand_equal_p (val,\n+\t\t\t\t       TYPE_MIN_VALUE (TREE_TYPE (val)), 0));\n+#endif\n+\t  val = TYPE_MIN_VALUE (TREE_TYPE (val));\n+\t}\n     }\n   set_value_range (vr, VR_RANGE, val, val, NULL);\n }\n@@ -1173,10 +1208,8 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n       /* If MIN and MAX cover the whole range for their type, then\n \t just use the original LIMIT.  */\n       if (INTEGRAL_TYPE_P (type)\n-\t  && (min == TYPE_MIN_VALUE (type)\n-\t      || is_negative_overflow_infinity (min))\n-\t  && (max == TYPE_MAX_VALUE (type)\n-\t      || is_positive_overflow_infinity (max)))\n+\t  && vrp_val_is_min (min)\n+\t  && vrp_val_is_max (max))\n \tmin = max = limit;\n \n       set_value_range (vr_p, VR_ANTI_RANGE, min, max, vr_p->equiv);\n@@ -1411,7 +1444,7 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \t    {\n \t      gcc_assert (!is_positive_overflow_infinity (anti_max));\n \t      if (needs_overflow_infinity (TREE_TYPE (anti_max))\n-\t\t  && anti_max == TYPE_MAX_VALUE (TREE_TYPE (anti_max)))\n+\t\t  && vrp_val_is_max (anti_max))\n \t\t{\n \t\t  if (!supports_overflow_infinity (TREE_TYPE (var_vr->min)))\n \t\t    {\n@@ -1436,7 +1469,7 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \t    {\n \t      gcc_assert (!is_negative_overflow_infinity (anti_min));\n \t      if (needs_overflow_infinity (TREE_TYPE (anti_min))\n-\t\t  && anti_min == TYPE_MIN_VALUE (TREE_TYPE (anti_min)))\n+\t\t  && vrp_val_is_min (anti_min))\n \t\t{\n \t\t  if (!supports_overflow_infinity (TREE_TYPE (var_vr->min)))\n \t\t    {\n@@ -2025,10 +2058,8 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n      We learn nothing when we have INF and INF(OVF) on both sides.\n      Note that we do accept [-INF, -INF] and [+INF, +INF] without\n      overflow.  */\n-  if ((min == TYPE_MIN_VALUE (TREE_TYPE (min))\n-       || is_overflow_infinity (min))\n-      && (max == TYPE_MAX_VALUE (TREE_TYPE (max))\n-\t  || is_overflow_infinity (max)))\n+  if ((vrp_val_is_min (min) || is_overflow_infinity (min))\n+      && (vrp_val_is_max (max) || is_overflow_infinity (max)))\n     {\n       set_value_range_to_varying (vr);\n       return;\n@@ -2204,13 +2235,13 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \tmin = negative_overflow_infinity (TREE_TYPE (expr));\n       else if (is_negative_overflow_infinity (vr0.max))\n \tmin = positive_overflow_infinity (TREE_TYPE (expr));\n-      else if (vr0.max != TYPE_MIN_VALUE (TREE_TYPE (expr)))\n+      else if (!vrp_val_is_min (vr0.max))\n \tmin = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.max);\n       else if (needs_overflow_infinity (TREE_TYPE (expr)))\n \t{\n \t  if (supports_overflow_infinity (TREE_TYPE (expr))\n \t      && !is_overflow_infinity (vr0.min)\n-\t      && vr0.min != TYPE_MIN_VALUE (TREE_TYPE (expr)))\n+\t      && !vrp_val_is_min (vr0.min))\n \t    min = positive_overflow_infinity (TREE_TYPE (expr));\n \t  else\n \t    {\n@@ -2225,7 +2256,7 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \tmax = negative_overflow_infinity (TREE_TYPE (expr));\n       else if (is_negative_overflow_infinity (vr0.min))\n \tmax = positive_overflow_infinity (TREE_TYPE (expr));\n-      else if (vr0.min != TYPE_MIN_VALUE (TREE_TYPE (expr)))\n+      else if (!vrp_val_is_min (vr0.min))\n \tmax = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.min);\n       else if (needs_overflow_infinity (TREE_TYPE (expr)))\n \t{\n@@ -2264,9 +2295,9 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n          useful range.  */\n       if (!TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (expr))\n \t  && ((vr0.type == VR_RANGE\n-\t       && vr0.min == TYPE_MIN_VALUE (TREE_TYPE (expr)))\n+\t       && vrp_val_is_min (vr0.min))\n \t      || (vr0.type == VR_ANTI_RANGE\n-\t          && vr0.min != TYPE_MIN_VALUE (TREE_TYPE (expr))\n+\t\t  && !vrp_val_is_min (vr0.min)\n \t\t  && !range_includes_zero_p (&vr0))))\n \t{\n \t  set_value_range_to_varying (vr);\n@@ -2277,7 +2308,7 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \t included negative values.  */\n       if (is_overflow_infinity (vr0.min))\n \tmin = positive_overflow_infinity (TREE_TYPE (expr));\n-      else if (vr0.min != TYPE_MIN_VALUE (TREE_TYPE (expr)))\n+      else if (!vrp_val_is_min (vr0.min))\n \tmin = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.min);\n       else if (!needs_overflow_infinity (TREE_TYPE (expr)))\n \tmin = TYPE_MAX_VALUE (TREE_TYPE (expr));\n@@ -2291,7 +2322,7 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \n       if (is_overflow_infinity (vr0.max))\n \tmax = positive_overflow_infinity (TREE_TYPE (expr));\n-      else if (vr0.max != TYPE_MIN_VALUE (TREE_TYPE (expr)))\n+      else if (!vrp_val_is_min (vr0.max))\n \tmax = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.max);\n       else if (!needs_overflow_infinity (TREE_TYPE (expr)))\n \tmax = TYPE_MAX_VALUE (TREE_TYPE (expr));\n@@ -2987,24 +3018,22 @@ dump_value_range (FILE *file, value_range_t *vr)\n \n       fprintf (file, \"%s[\", (vr->type == VR_ANTI_RANGE) ? \"~\" : \"\");\n \n-      if (INTEGRAL_TYPE_P (type)\n-\t  && !TYPE_UNSIGNED (type)\n-\t  && vr->min == TYPE_MIN_VALUE (type))\n-\tfprintf (file, \"-INF\");\n-      else if (needs_overflow_infinity (type)\n-\t       && is_negative_overflow_infinity (vr->min))\n+      if (is_negative_overflow_infinity (vr->min))\n \tfprintf (file, \"-INF(OVF)\");\n+      else if (INTEGRAL_TYPE_P (type)\n+\t       && !TYPE_UNSIGNED (type)\n+\t       && vrp_val_is_min (vr->min))\n+\tfprintf (file, \"-INF\");\n       else\n \tprint_generic_expr (file, vr->min, 0);\n \n       fprintf (file, \", \");\n \n-      if (INTEGRAL_TYPE_P (type)\n-\t  && vr->max == TYPE_MAX_VALUE (type))\n-\tfprintf (file, \"+INF\");\n-      else if (needs_overflow_infinity (type)\n-\t       && is_positive_overflow_infinity (vr->max))\n+      if (is_positive_overflow_infinity (vr->max))\n \tfprintf (file, \"+INF(OVF)\");\n+      else if (INTEGRAL_TYPE_P (type)\n+\t       && vrp_val_is_max (vr->max))\n+\tfprintf (file, \"+INF\");\n       else\n \tprint_generic_expr (file, vr->max, 0);\n \n@@ -5157,10 +5186,8 @@ vrp_meet (value_range_t *vr0, value_range_t *vr1)\n \n       /* Check for useless ranges.  */\n       if (INTEGRAL_TYPE_P (TREE_TYPE (min))\n-\t  && ((min == TYPE_MIN_VALUE (TREE_TYPE (min))\n-\t       || is_overflow_infinity (min))\n-\t      && (max == TYPE_MAX_VALUE (TREE_TYPE (max))\n-\t\t  || is_overflow_infinity (max))))\n+\t  && ((vrp_val_is_min (min) || is_overflow_infinity (min))\n+\t      && (vrp_val_is_max (max) || is_overflow_infinity (max))))\n \tgoto give_up;\n \n       /* The resulting set of equivalences is the intersection of\n@@ -5348,9 +5375,7 @@ vrp_visit_phi_node (tree phi)\n \t    {\n \t      /* If we will end up with a (-INF, +INF) range, set it\n \t\t to VARYING.  */\n-\t      if (is_positive_overflow_infinity (vr_result.max)\n-\t\t  || (vr_result.max\n-\t\t      == TYPE_MAX_VALUE (TREE_TYPE (vr_result.max))))\n+\t      if (vrp_val_is_max (vr_result.max))\n \t\tgoto varying;\n \n \t      if (!needs_overflow_infinity (TREE_TYPE (vr_result.min)))\n@@ -5368,9 +5393,7 @@ vrp_visit_phi_node (tree phi)\n \t    {\n \t      /* If we will end up with a (-INF, +INF) range, set it\n \t\t to VARYING.  */\n-\t      if (is_negative_overflow_infinity (vr_result.min)\n-\t\t  || (vr_result.min\n-\t\t      == TYPE_MIN_VALUE (TREE_TYPE (vr_result.min))))\n+\t      if (vrp_val_is_min (vr_result.min))\n \t\tgoto varying;\n \n \t      if (!needs_overflow_infinity (TREE_TYPE (vr_result.max)))"}, {"sha": "b636de61384230173dcd81715e26f4f4c5dd0db9", "filename": "gcc/tree.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f28918efd6b999478fa903e355115aa6e2bff8/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f28918efd6b999478fa903e355115aa6e2bff8/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=e1f28918efd6b999478fa903e355115aa6e2bff8", "patch": "@@ -4173,15 +4173,10 @@ build_distinct_type_copy (tree type)\n   /* Make it its own variant.  */\n   TYPE_MAIN_VARIANT (t) = t;\n   TYPE_NEXT_VARIANT (t) = 0;\n-  \n-  /* VRP assumes that TREE_TYPE (TYPE_MIN_VALUE (type)) == type.  */\n-  if (INTEGRAL_TYPE_P (t) || SCALAR_FLOAT_TYPE_P (t))\n-    {\n-      if (TYPE_MIN_VALUE (t) != NULL_TREE)\n-\tTYPE_MIN_VALUE (t) = fold_convert (t, TYPE_MIN_VALUE (t));\n-      if (TYPE_MAX_VALUE (t) != NULL_TREE)\n-\tTYPE_MAX_VALUE (t) = fold_convert (t, TYPE_MAX_VALUE (t));\n-    }\n+\n+  /* Note that it is now possible for TYPE_MIN_VALUE to be a value\n+     whose TREE_TYPE is not t.  This can also happen in the Ada\n+     frontend when using subtypes.  */\n \n   return t;\n }"}]}