{"sha": "140f6a698b4d7157e6a33cd7b41c27b39ecbf76e", "node_id": "C_kwDOANBUbNoAKDE0MGY2YTY5OGI0ZDcxNTdlNmEzM2NkN2I0MWMyN2IzOWVjYmY3NmU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-05-09T11:09:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-09T11:09:47Z"}, "message": "Merge #1219\n\n1219: Add `Optional<T>` type r=CohenArthur a=CohenArthur\n\nThis adds a tagged union to try and simulate a sum type. This is safer and more ergonomic\r\n than one of the two alternatives we're currently using in the compiler:\r\n \r\n 1. Storing a raw pointer, which can be `nullptr` or valid\r\n \r\n This is wildly unsafe, and usable in conjunction with local references, stack\r\n variables, or pointers managed elsewhere, which can cause crashes, hard to\r\n debug issues or undefined behavior. Likewise, if you do not check for the\r\n pointer's validity, this will cause a crash.\r\n \r\n 2. Storing an extra boolean alongside the object\r\n \r\n This causes implementors to use a \"dummy object\": Either an empty version or\r\n an error version. But what happens if what you really wanted to store was\r\n the empty or error version? You can also easily incorporate logic bugs if you\r\n forget to check for the associated boolean.\r\n \r\n The `Optional<T>` type has the same \"ergonomic\" cost: You need to check\r\n whether your option is valid or not. However, the main advantage is that it\r\n is more restrictive: You can only acess the member it contains \"safely\".\r\n It is similar to storing a value + an associated boolean, but has the\r\n advantage of making up only one member in your class.\r\n You also benefit from some helper methods such as `map()`.\r\n You also get helper functions and operator overloading to \"seamlessly\"\r\n replace raw pointer alternatives.\r\n \r\n  ```c++\r\n MyType *raw_pointer = something_that_can_fail();\r\n if (raw_pointer)\r\n     raw_pointer->method();\r\n  // or\r\n  Optional<MyType> opt = something_that_can_fail2();\r\n  if (opt)\r\n      opt->method();\r\n \r\n  // equivalent to\r\n \r\n  if (opt.is_some())\r\n      opt.get().method();\r\n  ```\r\n  \r\n  This will be very useful for parent modules when resolving `super` paths :)\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "1234b06acf2b168665b79f94ede82c8081c20015", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1234b06acf2b168665b79f94ede82c8081c20015"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/140f6a698b4d7157e6a33cd7b41c27b39ecbf76e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiePZ7CRBK7hj4Ov3rIwAAWu8IAKlwtq7+hvD0/dRcJq1gbF9u\n8vYTAWbB+grVtBFDtsG12Q/Jbjk5fNYan2B3knTbAkxGA8TvzQIn2s8MofBWIspn\nagUt93l0MziCowzXvkb3DsaBfw5omR0zcRsW2SosOc9Xo6ur1R9UtvO5ADiR5jXc\nAKDuJRIJg8wRHVmb9AIzjlujE2NcS+9grO668FxrXDsQhvz6twNAiQ0ntJ2Qpxsw\nfFyYRPxp7UHvEgg1ifXVeNvV2idkNVUZZ2eyzPH9QUJB0gFi3MD6N0GdyZu1KQrz\niHeDWL1iYu5RTXPlvLEXP6FjzDIXCv+ZgJkKLwCsoka+2XQJoSX3dfaNIA7aTfQ=\n=dDHh\n-----END PGP SIGNATURE-----\n", "payload": "tree 1234b06acf2b168665b79f94ede82c8081c20015\nparent dd5a7654d32134d9bfbe25180dad114367e77767\nparent b088d47cdc1514d5f92801481cbb412d1e01aeeb\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1652094587 +0000\ncommitter GitHub <noreply@github.com> 1652094587 +0000\n\nMerge #1219\n\n1219: Add `Optional<T>` type r=CohenArthur a=CohenArthur\n\nThis adds a tagged union to try and simulate a sum type. This is safer and more ergonomic\r\n than one of the two alternatives we're currently using in the compiler:\r\n \r\n 1. Storing a raw pointer, which can be `nullptr` or valid\r\n \r\n This is wildly unsafe, and usable in conjunction with local references, stack\r\n variables, or pointers managed elsewhere, which can cause crashes, hard to\r\n debug issues or undefined behavior. Likewise, if you do not check for the\r\n pointer's validity, this will cause a crash.\r\n \r\n 2. Storing an extra boolean alongside the object\r\n \r\n This causes implementors to use a \"dummy object\": Either an empty version or\r\n an error version. But what happens if what you really wanted to store was\r\n the empty or error version? You can also easily incorporate logic bugs if you\r\n forget to check for the associated boolean.\r\n \r\n The `Optional<T>` type has the same \"ergonomic\" cost: You need to check\r\n whether your option is valid or not. However, the main advantage is that it\r\n is more restrictive: You can only acess the member it contains \"safely\".\r\n It is similar to storing a value + an associated boolean, but has the\r\n advantage of making up only one member in your class.\r\n You also benefit from some helper methods such as `map()`.\r\n You also get helper functions and operator overloading to \"seamlessly\"\r\n replace raw pointer alternatives.\r\n \r\n  ```c++\r\n MyType *raw_pointer = something_that_can_fail();\r\n if (raw_pointer)\r\n     raw_pointer->method();\r\n  // or\r\n  Optional<MyType> opt = something_that_can_fail2();\r\n  if (opt)\r\n      opt->method();\r\n \r\n  // equivalent to\r\n \r\n  if (opt.is_some())\r\n      opt.get().method();\r\n  ```\r\n  \r\n  This will be very useful for parent modules when resolving `super` paths :)\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/140f6a698b4d7157e6a33cd7b41c27b39ecbf76e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/140f6a698b4d7157e6a33cd7b41c27b39ecbf76e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/140f6a698b4d7157e6a33cd7b41c27b39ecbf76e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd5a7654d32134d9bfbe25180dad114367e77767", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd5a7654d32134d9bfbe25180dad114367e77767", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd5a7654d32134d9bfbe25180dad114367e77767"}, {"sha": "b088d47cdc1514d5f92801481cbb412d1e01aeeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b088d47cdc1514d5f92801481cbb412d1e01aeeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b088d47cdc1514d5f92801481cbb412d1e01aeeb"}], "stats": {"total": 268, "additions": 266, "deletions": 2}, "files": [{"sha": "738cfdf20ef8dc10a0b17d8b6f046d8b5a2581c1", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/140f6a698b4d7157e6a33cd7b41c27b39ecbf76e/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/140f6a698b4d7157e6a33cd7b41c27b39ecbf76e/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=140f6a698b4d7157e6a33cd7b41c27b39ecbf76e", "patch": "@@ -291,7 +291,8 @@ RUST_INCLUDES = -I $(srcdir)/rust \\\n \t-I $(srcdir)/rust/util \\\n \t-I $(srcdir)/rust/typecheck \\\n \t-I $(srcdir)/rust/privacy \\\n-\t-I $(srcdir)/rust/lint\n+\t-I $(srcdir)/rust/lint \\\n+\t-I $(srcdir)/rust/util\n \n # add files that require cross-folder includes - currently rust-lang.o, rust-lex.o\n CFLAGS-rust/rust-lang.o += $(RUST_INCLUDES)"}, {"sha": "0641e22eb1c012f1e506ef5a4d992768e0e000d8", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/140f6a698b4d7157e6a33cd7b41c27b39ecbf76e/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/140f6a698b4d7157e6a33cd7b41c27b39ecbf76e/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=140f6a698b4d7157e6a33cd7b41c27b39ecbf76e", "patch": "@@ -22,7 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #define INCLUDE_ALGORITHM\n #include \"rust-diagnostics.h\"\n-#include \"util/rust-make-unique.h\"\n+#include \"rust-make-unique.h\"\n \n namespace Rust {\n // Left binding powers of operations."}, {"sha": "dd8c608789a5908dc83074a446d959394e0d665d", "filename": "gcc/rust/rust-lang.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/140f6a698b4d7157e6a33cd7b41c27b39ecbf76e/gcc%2Frust%2Frust-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/140f6a698b4d7157e6a33cd7b41c27b39ecbf76e/gcc%2Frust%2Frust-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-lang.cc?ref=140f6a698b4d7157e6a33cd7b41c27b39ecbf76e", "patch": "@@ -37,6 +37,7 @@\n #include \"rust-cfg-parser.h\"\n #include \"rust-privacy-ctx.h\"\n #include \"rust-ast-resolve-item.h\"\n+#include \"rust-optional.h\"\n \n #include <mpfr.h>\n // note: header files must be in this order or else forward declarations don't\n@@ -461,6 +462,7 @@ run_rust_tests ()\n   rust_privacy_ctx_test ();\n   rust_crate_name_validation_test ();\n   rust_simple_path_resolve_test ();\n+  rust_optional_test ();\n }\n } // namespace selftest\n "}, {"sha": "f33f9125f8907dbd03b2615d90fd5c3204c5a564", "filename": "gcc/rust/util/rust-make-unique.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/140f6a698b4d7157e6a33cd7b41c27b39ecbf76e/gcc%2Frust%2Futil%2Frust-make-unique.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/140f6a698b4d7157e6a33cd7b41c27b39ecbf76e/gcc%2Frust%2Futil%2Frust-make-unique.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-make-unique.h?ref=140f6a698b4d7157e6a33cd7b41c27b39ecbf76e", "patch": "@@ -1,6 +1,26 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef RUST_MAKE_UNIQUE_H\n #define RUST_MAKE_UNIQUE_H\n \n+#include <memory>\n+\n namespace Rust {\n \n template <typename T, typename... Ts>"}, {"sha": "c1b547a29d68cf6447ac3cd1759c0825c60df227", "filename": "gcc/rust/util/rust-optional.h", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/140f6a698b4d7157e6a33cd7b41c27b39ecbf76e/gcc%2Frust%2Futil%2Frust-optional.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/140f6a698b4d7157e6a33cd7b41c27b39ecbf76e/gcc%2Frust%2Futil%2Frust-optional.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-optional.h?ref=140f6a698b4d7157e6a33cd7b41c27b39ecbf76e", "patch": "@@ -0,0 +1,241 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_OPTIONAL_H\n+#define RUST_OPTIONAL_H\n+\n+#include \"config.h\"\n+#include \"rust-system.h\"\n+\n+#include \"selftest.h\"\n+\n+namespace Rust {\n+\n+/**\n+ * Tagged union to try and simulate a sum type. This is safer and more ergonomic\n+ * than one of the two alternatives we're currently using in the compiler:\n+ *\n+ * 1. Storing a raw pointer, which can be `nullptr` or valid\n+ *\n+ * This is wildly unsafe, and usable in conjunction with local references, stack\n+ * variables, or pointers managed elsewhere, which can cause crashes, hard to\n+ * debug issues or undefined behavior. Likewise, if you do not check for the\n+ * pointer's validity, this will cause a crash.\n+ *\n+ * 2. Storing an extra boolean alongside the object\n+ *\n+ * This causes implementors to use a \"dummy object\": Either an empty version or\n+ * an error version. But what happens if what you really wanted to store was\n+ * the empty or error version? You can also easily incorporate logic bugs if you\n+ * forget to check for the associated boolean.\n+ *\n+ * The `Optional<T>` type has the same \"ergonomic\" cost: You need to check\n+ * whether your option is valid or not. However, the main advantage is that it\n+ * is more restrictive: You can only acess the member it contains \"safely\".\n+ * It is similar to storing a value + an associated boolean, but has the\n+ * advantage of making up only one member in your class.\n+ * You also benefit from some helper methods such as `map()`.\n+ *\n+ * You also get helper functions and operator overloading to \"seamlessly\"\n+ * replace raw pointer alternatives.\n+ *\n+ * ```c++\n+ * MyType *raw_pointer = something_that_can_fail();\n+ * if (raw_pointer)\n+ *     raw_pointer->method();\n+ *\n+ * // or\n+ *\n+ * Optional<MyType> opt = something_that_can_fail2();\n+ * if (opt)\n+ *     opt->method();\n+ *\n+ * // equivalent to\n+ *\n+ * if (opt.is_some())\n+ *     opt.get().method();\n+ * ```\n+ */\n+template <typename T> class Optional\n+{\n+private:\n+  struct Empty\n+  {\n+  };\n+\n+  enum Kind\n+  {\n+    Some,\n+    None\n+  } kind;\n+\n+  union Content\n+  {\n+    Empty empty;\n+    T value;\n+\n+    Content () = default;\n+  } content;\n+\n+  Optional<T> (Kind kind, Content content) : kind (kind), content (content) {}\n+\n+public:\n+  Optional (const Optional &other) = default;\n+  Optional (Optional &&other) = default;\n+\n+  static Optional<T> some (T value)\n+  {\n+    Content content;\n+    content.value = value;\n+\n+    return Optional (Kind::Some, content);\n+  }\n+\n+  static Optional<T> none ()\n+  {\n+    Content content;\n+    content.empty = Empty ();\n+\n+    return Optional (Kind::None, content);\n+  }\n+\n+  bool is_some () const { return kind == Kind::Some; }\n+  bool is_none () const { return !is_some (); }\n+\n+  /**\n+   * Enable boolean-like comparisons.\n+   */\n+  operator bool () { return is_some (); }\n+\n+  /**\n+   * Enables dereferencing to access the contained value\n+   */\n+  T &operator* () { return get (); }\n+  const T &operator* () const { return get (); }\n+  T *operator-> () { return &get (); }\n+  const T *operator-> () const { return &get (); }\n+\n+  const T &get () const\n+  {\n+    rust_assert (is_some ());\n+\n+    return content.value;\n+  }\n+\n+  T &get ()\n+  {\n+    rust_assert (is_some ());\n+\n+    return content.value;\n+  }\n+\n+  T take ()\n+  {\n+    rust_assert (is_some ());\n+\n+    auto to_return = std::move (content.value);\n+\n+    content.empty = Empty ();\n+    kind = Kind::None;\n+\n+    return to_return;\n+  }\n+\n+  template <typename U> Optional<U> map (std::function<U (T)> functor)\n+  {\n+    if (is_none ())\n+      return Optional::none ();\n+\n+    auto value = functor (take ());\n+\n+    return Optional::some (value);\n+  }\n+};\n+\n+} // namespace Rust\n+\n+#ifdef CHECKING_P\n+\n+static void\n+rust_optional_create ()\n+{\n+  auto opt = Rust::Optional<int>::some (15);\n+\n+  ASSERT_TRUE (opt.is_some ());\n+  ASSERT_EQ (opt.get (), 15);\n+\n+  Rust::Optional<int> const_opt = Rust::Optional<int>::some (15);\n+  const int &value = const_opt.get ();\n+\n+  ASSERT_EQ (value, 15);\n+}\n+\n+static void\n+rust_optional_operators ()\n+{\n+  auto opt = Rust::Optional<int>::some (15);\n+\n+  // as bool\n+  ASSERT_TRUE (opt);\n+\n+  // deref\n+  ASSERT_EQ (*opt, 15);\n+\n+  class Methodable\n+  {\n+  public:\n+    int method () { return 15; }\n+  };\n+\n+  auto m_opt = Rust::Optional<Methodable>::some (Methodable ());\n+  ASSERT_EQ (m_opt->method (), 15);\n+}\n+\n+static void\n+rust_optional_take ()\n+{\n+  auto opt = Rust::Optional<int>::some (15);\n+  auto value = opt.take ();\n+\n+  ASSERT_EQ (value, 15);\n+  ASSERT_TRUE (opt.is_none ());\n+}\n+\n+static void\n+rust_optional_map ()\n+{\n+  auto opt = Rust::Optional<int>::some (15);\n+  auto twice = opt.map<int> ([] (int value) { return value * 2; });\n+\n+  ASSERT_FALSE (opt);\n+  ASSERT_TRUE (twice);\n+  ASSERT_EQ (*twice, 30);\n+}\n+\n+static void\n+rust_optional_test ()\n+{\n+  rust_optional_create ();\n+  rust_optional_operators ();\n+  rust_optional_take ();\n+  rust_optional_map ();\n+}\n+\n+#endif // !CHECKING_P\n+\n+#endif // !RUST_OPTIONAL_H"}]}