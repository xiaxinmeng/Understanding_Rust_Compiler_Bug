{"sha": "d7598e110d060f8b7fb6598736f68700b20c400f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc1OThlMTEwZDA2MGY4YjdmYjY1OTg3MzZmNjg3MDBiMjBjNDAwZg==", "commit": {"author": {"name": "Pascal Obry", "email": "obry@adacore.com", "date": "2007-05-02T08:43:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-05-02T08:43:30Z"}, "message": "re PR ada/29856 (broken if..else in gcc/ada/adaint.c)\n\n2007-04-20  Pascal Obry  <obry@adacore.com>\n\n\t* gnatchop.adb (Write_Source_Reference_Pragma): Change implementation\n\tto use Stream_IO.File_Type. This is needed to make use of the UTF-8\n\tencoding support of Stream_IO.\n\t(Write_Unit): Idem.\n\n\t* adaint.h, adaint.c (__gnat_os_filename): New routine. Returns the\n\tfilename and corresponding encoding to match the OS requirement.\n\t(__gnat_file_exists): Do not call __gnat_stat() on Windows as this\n\troutine will fail on specific devices like CON: AUX: ...\n\n\tPR ada/29856: Add missing braces\n\nFrom-SVN: r124347", "tree": {"sha": "a90e9a876adb1767b44b61c579a73fec97fa0c8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a90e9a876adb1767b44b61c579a73fec97fa0c8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7598e110d060f8b7fb6598736f68700b20c400f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7598e110d060f8b7fb6598736f68700b20c400f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7598e110d060f8b7fb6598736f68700b20c400f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7598e110d060f8b7fb6598736f68700b20c400f/comments", "author": {"login": "TurboGit", "id": 467069, "node_id": "MDQ6VXNlcjQ2NzA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/467069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TurboGit", "html_url": "https://github.com/TurboGit", "followers_url": "https://api.github.com/users/TurboGit/followers", "following_url": "https://api.github.com/users/TurboGit/following{/other_user}", "gists_url": "https://api.github.com/users/TurboGit/gists{/gist_id}", "starred_url": "https://api.github.com/users/TurboGit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TurboGit/subscriptions", "organizations_url": "https://api.github.com/users/TurboGit/orgs", "repos_url": "https://api.github.com/users/TurboGit/repos", "events_url": "https://api.github.com/users/TurboGit/events{/privacy}", "received_events_url": "https://api.github.com/users/TurboGit/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9a60b02d977835f3e7c132c529380e89821c0405", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a60b02d977835f3e7c132c529380e89821c0405", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a60b02d977835f3e7c132c529380e89821c0405"}], "stats": {"total": 256, "additions": 173, "deletions": 83}, "files": [{"sha": "e85a5a0d98b9b11ca52d79f795d90abd8357be55", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7598e110d060f8b7fb6598736f68700b20c400f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7598e110d060f8b7fb6598736f68700b20c400f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d7598e110d060f8b7fb6598736f68700b20c400f", "patch": "@@ -1,3 +1,17 @@\n+2007-05-02  Pascal Obry  <obry@adacore.com>\n+\n+\t* gnatchop.adb (Write_Source_Reference_Pragma): Change implementation\n+\tto use Stream_IO.File_Type. This is needed to make use of the UTF-8\n+\tencoding support of Stream_IO.\n+\t(Write_Unit): Idem.\n+\n+\t* adaint.h, adaint.c (__gnat_os_filename): New routine. Returns the\n+\tfilename and corresponding encoding to match the OS requirement.\n+\t(__gnat_file_exists): Do not call __gnat_stat() on Windows as this\n+\troutine will fail on specific devices like CON: AUX: ...\n+\n+\tPR ada/29856: Add missing braces\n+\n 2007-04-22  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \tPR ada/31660"}, {"sha": "ff2d0a4bb011dd2ba26c58375abc514420338dea", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7598e110d060f8b7fb6598736f68700b20c400f/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7598e110d060f8b7fb6598736f68700b20c400f/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=d7598e110d060f8b7fb6598736f68700b20c400f", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2006, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2007, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -619,6 +619,25 @@ __gnat_get_debuggable_suffix_ptr (int *len, const char **value)\n   return;\n }\n \n+/* Returns the OS filename and corresponding encoding.  */\n+\n+void\n+__gnat_os_filename (char *filename, char *w_filename,\n+\t\t    char *os_name, int *o_length,\n+\t\t    char *encoding, int *e_length)\n+{\n+#if defined (_WIN32) && ! defined (__vxworks) && ! defined (CROSS_DIRECTORY_STRUCTURE)\n+  WS2SU (os_name, (TCHAR *)w_filename, o_length);\n+  *o_length = strlen (os_name);\n+  strcpy (encoding, \"encoding=utf8\");\n+  *e_length = strlen (encoding);\n+#else\n+  strcpy (os_name, filename);\n+  *o_length = strlen (filename);\n+  *e_length = 0;\n+#endif\n+}\n+\n FILE *\n __gnat_fopen (char *path, char *mode, int encoding)\n {\n@@ -991,8 +1010,10 @@ __gnat_readdir (DIR *dirp, char *buffer, int *len)\n #elif defined (HAVE_READDIR_R)\n   /* If possible, try to use the thread-safe version.  */\n   if (readdir_r (dirp, buffer) != NULL)\n-    *len = strlen (((struct dirent*) buffer)->d_name);\n-    return ((struct dirent*) buffer)->d_name;\n+    {\n+      *len = strlen (((struct dirent*) buffer)->d_name);\n+      return ((struct dirent*) buffer)->d_name;\n+    }\n   else\n     return NULL;\n \n@@ -1513,9 +1534,19 @@ __gnat_stat (char *name, struct stat *statbuf)\n int\n __gnat_file_exists (char *name)\n {\n+#ifdef __MINGW32__\n+  /*  On Windows do not use __gnat_stat() because a bug in Microsoft\n+  _stat() routine. When the system time-zone is set with a negative\n+  offset the _stat() routine fails on specific files like CON:  */\n+  TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n+\n+  S2WSU (wname, name, GNAT_MAX_PATH_LEN + 2);\n+  return GetFileAttributes (wname) != INVALID_FILE_ATTRIBUTES;\n+#else\n   struct stat statbuf;\n \n   return !__gnat_stat (name, &statbuf);\n+#endif\n }\n \n int"}, {"sha": "131fe1f2dd5c735cf90d70234f81e7cec7df23e6", "filename": "gcc/ada/adaint.h", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7598e110d060f8b7fb6598736f68700b20c400f/gcc%2Fada%2Fadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7598e110d060f8b7fb6598736f68700b20c400f/gcc%2Fada%2Fadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.h?ref=d7598e110d060f8b7fb6598736f68700b20c400f", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2006, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2007, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -47,10 +47,9 @@ typedef long OS_Time; /* Type corresponding to GNAT.OS_Lib.OS_Time */\n \n extern int    __gnat_max_path_len;\n extern OS_Time __gnat_current_time\t\t   (void);\n-extern void   __gnat_to_gm_time\t\t\t   (OS_Time *, int *,\n-\t\t\t\t\t\t    int *, int *,\n-\t\t\t\t\t\t    int *, int *,\n-\t\t\t\t\t\t    int *);\n+extern void   __gnat_to_gm_time\t\t\t   (OS_Time *, int *, int *,\n+\t\t\t\t                    int *, int *,\n+\t\t\t\t                    int *, int *);\n extern int    __gnat_get_maximum_file_name_length  (void);\n extern int    __gnat_get_switches_case_sensitive   (void);\n extern int    __gnat_get_file_names_case_sensitive (void);\n@@ -72,7 +71,8 @@ extern int    __gnat_mkdir\t\t\t   (char *);\n extern int    __gnat_stat\t\t\t   (char *,\n \t\t\t\t\t\t    struct stat *);\n extern FILE  *__gnat_fopen\t\t\t   (char *, char *, int);\n-extern FILE  *__gnat_freopen\t\t\t (char *, char *, FILE *, int);\n+extern FILE  *__gnat_freopen\t\t\t   (char *, char *, FILE *,\n+\t\t\t\t                    int);\n extern int    __gnat_open_read                     (char *, int);\n extern int    __gnat_open_rw                       (char *, int);\n extern int    __gnat_open_create                   (char *, int);\n@@ -165,6 +165,9 @@ extern int    __gnat_set_close_on_exec\t\t   (int, int);\n extern int    __gnat_dup\t\t\t   (int);\n extern int    __gnat_dup2\t\t\t   (int, int);\n \n+extern void   __gnat_os_filename                   (char *, char *, char *,\n+\t\t\t\t\t\t    int *, char *, int *);\n+\n #ifdef __MINGW32__\n extern void   __gnat_plist_init                    (void);\n #endif\n@@ -175,7 +178,7 @@ extern void   __gnat_plist_init                    (void);\n #endif\n \n /* This function returns the version of GCC being used.  Here it's GCC 3.  */\n-extern int get_gcc_version\t\t     (void);\n+extern int    get_gcc_version                      (void);\n \n-extern int __gnat_binder_supports_auto_init (void);\n-extern int __gnat_sals_init_using_constructors (void);\n+extern int    __gnat_binder_supports_auto_init     (void);\n+extern int    __gnat_sals_init_using_constructors  (void);"}, {"sha": "713e830e9b2487283e9bb088fecdcb330dcbf78d", "filename": "gcc/ada/gnatchop.adb", "status": "modified", "additions": 113, "deletions": 71, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7598e110d060f8b7fb6598736f68700b20c400f/gcc%2Fada%2Fgnatchop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7598e110d060f8b7fb6598736f68700b20c400f/gcc%2Fada%2Fgnatchop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatchop.adb?ref=d7598e110d060f8b7fb6598736f68700b20c400f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 1998-2006, AdaCore                     --\n+--                     Copyright (C) 1998-2007, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -24,19 +24,21 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Command_Line;  use Ada.Command_Line;\n-with Ada.Text_IO;       use Ada.Text_IO;\n+with Ada.Characters.Conversions; use Ada.Characters.Conversions;\n+with Ada.Command_Line;           use Ada.Command_Line;\n+with Ada.Directories;            use Ada.Directories;\n+with Ada.Streams.Stream_IO;      use Ada.Streams;\n+with Ada.Text_IO;                use Ada.Text_IO;\n+with System.CRTL;                use System; use System.CRTL;\n \n-with GNAT.Command_Line; use GNAT.Command_Line;\n-with GNAT.OS_Lib;       use GNAT.OS_Lib;\n+with GNAT.Command_Line;          use GNAT.Command_Line;\n+with GNAT.OS_Lib;                use GNAT.OS_Lib;\n with GNAT.Heap_Sort_G;\n with GNAT.Table;\n \n with Gnatvsn;\n with Hostparm;\n \n-with System.CRTL;       use System.CRTL;\n-\n procedure Gnatchop is\n \n    Terminate_Program : exception;\n@@ -155,7 +157,6 @@ procedure Gnatchop is\n       Bufferg : String_Access;\n       --  Pointer to buffer containing configuration pragmas to be\n       --  prepended. Null if no pragmas to be prepended.\n-\n    end record;\n \n    --  The following table stores the unit offset information\n@@ -227,8 +228,7 @@ procedure Gnatchop is\n \n    function Locate_Executable\n      (Program_Name    : String;\n-      Look_For_Prefix : Boolean := True)\n-     return             String_Access;\n+      Look_For_Prefix : Boolean := True) return String_Access;\n    --  Locate executable for given program name. This takes into account\n    --  the target-prefix of the current command, if Look_For_Prefix is True.\n \n@@ -241,8 +241,7 @@ procedure Gnatchop is\n \n    function Get_EOL\n      (Source : not null access String;\n-      Start  : Positive)\n-      return   EOL_String;\n+      Start  : Positive) return EOL_String;\n    --  Return the line terminator used in the passed string\n \n    procedure Parse_EOL\n@@ -307,8 +306,7 @@ procedure Gnatchop is\n \n    function Get_Config_Pragmas\n      (Input : File_Num;\n-      U     : Unit_Num)\n-      return  String_Access;\n+      U     : Unit_Num) return  String_Access;\n    --  Call to read configuration pragmas from given unit entry, and\n    --  return a buffer containing the pragmas to be appended to\n    --  following units. Input is the file number for the chop file and\n@@ -317,7 +315,7 @@ procedure Gnatchop is\n    procedure Write_Source_Reference_Pragma\n      (Info    : Unit_Info;\n       Line    : Line_Num;\n-      FD      : File_Descriptor;\n+      File    : Stream_IO.File_Type;\n       EOL     : EOL_String;\n       Success : in out Boolean);\n    --  If Success is True on entry, writes a source reference pragma using\n@@ -338,7 +336,7 @@ procedure Gnatchop is\n    -- dup --\n    ---------\n \n-   function dup  (handle   : File_Descriptor) return File_Descriptor is\n+   function dup (handle : File_Descriptor) return File_Descriptor is\n    begin\n       return File_Descriptor (System.CRTL.dup (int (handle)));\n    end dup;\n@@ -1461,7 +1459,6 @@ procedure Gnatchop is\n \n       Close (FD);\n       return Success;\n-\n    end Write_Chopped_Files;\n \n    -----------------------\n@@ -1562,11 +1559,11 @@ procedure Gnatchop is\n    procedure Write_Source_Reference_Pragma\n      (Info    : Unit_Info;\n       Line    : Line_Num;\n-      FD      : File_Descriptor;\n+      File    : Stream_IO.File_Type;\n       EOL     : EOL_String;\n       Success : in out Boolean)\n    is\n-      FTE : File_Entry renames File.Table (Info.Chop_File);\n+      FTE : File_Entry renames Gnatchop.File.Table (Info.Chop_File);\n       Nam : String_Access;\n \n    begin\n@@ -1578,7 +1575,7 @@ procedure Gnatchop is\n          end if;\n \n          declare\n-            Reference : aliased String :=\n+            Reference : String :=\n                           \"pragma Source_Reference (000000, \"\"\"\n                             & Nam.all & \"\"\");\" & EOL.Str;\n \n@@ -1601,9 +1598,13 @@ procedure Gnatchop is\n \n             pragma Assert (Lin = 0);\n \n-            Success :=\n-              Write (FD, Reference'Address, Reference'Length)\n-                                                     = Reference'Length;\n+            begin\n+               String'Write (Stream_IO.Stream (File), Reference);\n+               Success := True;\n+            exception\n+               when others =>\n+                  Success := False;\n+            end;\n          end;\n       end if;\n    end Write_Source_Reference_Pragma;\n@@ -1618,12 +1619,36 @@ procedure Gnatchop is\n       TS_Time : OS_Time;\n       Success : out Boolean)\n    is\n-      Info   : Unit_Info renames Unit.Table (Num);\n-      FD     : File_Descriptor;\n-      Name   : aliased constant String := Info.File_Name.all & ASCII.NUL;\n-      Length : File_Offset;\n-      EOL    : constant EOL_String :=\n-                 Get_EOL (Source, Source'First + Info.Offset);\n+\n+      procedure OS_Filename\n+        (Name     : String;\n+         W_Name   : Wide_String;\n+         OS_Name  : Address;\n+         N_Length : access Natural;\n+         Encoding : Address;\n+         E_Length : access Natural);\n+      pragma Import (C, OS_Filename, \"__gnat_os_filename\");\n+      --  Returns in OS_Name the proper name for the OS when used with the\n+      --  returned Encoding value. For example on Windows this will return the\n+      --  UTF-8 encoded name into OS_Name and set Encoding to encoding=utf8\n+      --  (form parameter Stream_IO).\n+      --  Name is the filename and W_Name the same filename in Unicode 16 bits\n+      --  (this corresponds to Win32 Unicode ISO/IEC 10646). N_Length and\n+      --  E_Length are the length returned in OS_Name and Encoding\n+      --  respectively.\n+\n+      Info     : Unit_Info renames Unit.Table (Num);\n+      Name     : aliased constant String := Info.File_Name.all & ASCII.NUL;\n+      W_Name   : aliased constant Wide_String := To_Wide_String (Name);\n+      EOL      : constant EOL_String :=\n+                   Get_EOL (Source, Source'First + Info.Offset);\n+\n+      OS_Name  : aliased String (1 .. Name'Length * 2);\n+      O_Length : aliased Natural := OS_Name'Length;\n+      Encoding : aliased String (1 .. 64);\n+      E_Length : aliased Natural := Encoding'Length;\n+\n+      Length   : File_Offset;\n \n    begin\n       --  Skip duplicated files\n@@ -1634,60 +1659,77 @@ procedure Gnatchop is\n          return;\n       end if;\n \n-      if Overwrite_Files then\n-         FD := Create_File (Name'Address, Binary);\n-      else\n-         FD := Create_New_File (Name'Address, Binary);\n-      end if;\n-\n-      Success := FD /= Invalid_FD;\n+      --  Get OS filename\n \n-      if not Success then\n-         Error_Msg (\"cannot create \" & Info.File_Name.all);\n-         return;\n-      end if;\n+      OS_Filename\n+        (Name, W_Name,\n+         OS_Name'Address, O_Length'Access,\n+         Encoding'Address, E_Length'Access);\n \n-      --  A length of 0 indicates that the rest of the file belongs to\n-      --  this unit. The actual length must be calculated now. Take into\n-      --  account that the last character (EOF) must not be written.\n+      declare\n+         E_Name      : constant String := OS_Name (1 .. O_Length);\n+         C_Name      : aliased constant String := E_Name & ASCII.Nul;\n+         OS_Encoding : constant String := Encoding (1 .. E_Length);\n+         File        : Stream_IO.File_Type;\n+      begin\n+         begin\n+            if not Overwrite_Files and then Exists (E_Name) then\n+               raise Stream_IO.Name_Error;\n+            else\n+               Stream_IO.Create\n+                 (File, Stream_IO.Out_File, E_Name, OS_Encoding);\n+               Success := True;\n+            end if;\n+         exception\n+            when Stream_IO.Name_Error | Stream_IO.Use_Error =>\n+               Error_Msg (\"cannot create \" & Info.File_Name.all);\n+               return;\n+         end;\n \n-      if Info.Length = 0 then\n-         Length := Source'Last - (Source'First + Info.Offset);\n-      else\n-         Length := Info.Length;\n-      end if;\n+         --  A length of 0 indicates that the rest of the file belongs to\n+         --  this unit. The actual length must be calculated now. Take into\n+         --  account that the last character (EOF) must not be written.\n \n-      --  Prepend configuration pragmas if necessary\n+         if Info.Length = 0 then\n+            Length := Source'Last - (Source'First + Info.Offset);\n+         else\n+            Length := Info.Length;\n+         end if;\n \n-      if Success and then Info.Bufferg /= null then\n-         Write_Source_Reference_Pragma (Info, 1, FD, EOL, Success);\n-         Success :=\n-           Write (FD, Info.Bufferg.all'Address, Info.Bufferg'Length) =\n-                                                       Info.Bufferg'Length;\n-      end if;\n+         --  Prepend configuration pragmas if necessary\n \n-      Write_Source_Reference_Pragma (Info, Info.Start_Line, FD, EOL, Success);\n+         if Success and then Info.Bufferg /= null then\n+            Write_Source_Reference_Pragma (Info, 1, File, EOL, Success);\n \n-      if Success then\n-         Success := Write (FD, Source (Source'First + Info.Offset)'Address,\n-                           Length) = Length;\n-      end if;\n+            String'Write (Stream_IO.Stream (File), Info.Bufferg.all);\n+         end if;\n \n-      if not Success then\n-         Error_Msg (\"disk full writing \" & Info.File_Name.all);\n-         return;\n-      end if;\n+         Write_Source_Reference_Pragma\n+           (Info, Info.Start_Line, File, EOL, Success);\n \n-      if not Quiet_Mode then\n-         Put_Line (\"   \" & Info.File_Name.all);\n-      end if;\n+         if Success then\n+            begin\n+               String'Write\n+                 (Stream_IO.Stream (File),\n+                  Source (Source'First + Info.Offset ..\n+                      Source'First + Info.Offset + Length - 1));\n+            exception\n+               when Stream_IO.Use_Error | Stream_IO.Device_Error =>\n+                  Error_Msg (\"disk full writing \" & Info.File_Name.all);\n+                  return;\n+            end;\n+         end if;\n \n-      Close (FD);\n+         if not Quiet_Mode then\n+            Put_Line (\"   \" & Info.File_Name.all);\n+         end if;\n \n-      if Preserve_Mode then\n-         File_Time_Stamp (Name'Address, TS_Time);\n-      end if;\n+         Stream_IO.Close (File);\n \n+         if Preserve_Mode then\n+            File_Time_Stamp (C_Name'Address, TS_Time);\n+         end if;\n+      end;\n    end Write_Unit;\n \n --  Start of processing for gnatchop"}]}