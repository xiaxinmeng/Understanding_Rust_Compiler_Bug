{"sha": "7551270e1b6232a38f772eb9298ddbe0aa970918", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU1MTI3MGUxYjYyMzJhMzhmNzcyZWI5Mjk4ZGRiZTBhYTk3MDkxOA==", "commit": {"author": {"name": "Erik Schnetter", "email": "schnetter@aei.mpg.de", "date": "2004-08-19T15:31:37Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-08-19T15:31:37Z"}, "message": "re PR fortran/16946 (sum (array, mask) is not accepted)\n\nfortran/\nPR fortran/16946\n* check.c (gfc_check_reduction): New function.\n(gfc_check_minval_maxval): Removed.\n(gfc_check_product): Removed.\n(gfc_check_sum): Removed.\n* intrinsic.h: Add/remove declarations for these.\n* gfortran.h: Add field f3red to union gfc_check_f.\n* intrinsic.c (add_sym_3red): New function.\n(add_functions): Register maxval, minval, product, and sum intrinsics\nthrough add_sym_3red.\n(check_specific): Handle f3red union field.\n* iresolve.c: Whitespace change.\n\ntestsuite/\nPR fortran/16946\n* gfortran.dg/reduction.f90: New testcase.\n\nFrom-SVN: r86255", "tree": {"sha": "871485f596b59597d459e94b7923a9f6e469f77b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/871485f596b59597d459e94b7923a9f6e469f77b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7551270e1b6232a38f772eb9298ddbe0aa970918", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7551270e1b6232a38f772eb9298ddbe0aa970918", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7551270e1b6232a38f772eb9298ddbe0aa970918", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7551270e1b6232a38f772eb9298ddbe0aa970918/comments", "author": null, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e281c0f884086d2247f9411f676c1f3f9e3058b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e281c0f884086d2247f9411f676c1f3f9e3058b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e281c0f884086d2247f9411f676c1f3f9e3058b0"}], "stats": {"total": 223, "additions": 154, "deletions": 69}, "files": [{"sha": "aff024a5874f709e04526957c09d44eccd93f20c", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 36, "deletions": 46, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7551270e1b6232a38f772eb9298ddbe0aa970918/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7551270e1b6232a38f772eb9298ddbe0aa970918/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=7551270e1b6232a38f772eb9298ddbe0aa970918", "patch": "@@ -1135,20 +1135,50 @@ gfc_check_minloc_maxloc (gfc_actual_arglist * ap)\n }\n \n \n+/* Similar to minloc/maxloc, the argument list might need to be\n+   reordered for the MINVAL, MAXVAL, PRODUCT, and SUM intrinsics.  The\n+   difference is that MINLOC/MAXLOC take an additional KIND argument.\n+   The possibilities are:\n+\n+         Arg #2     Arg #3\n+         NULL       NULL\n+         DIM        NULL\n+         MASK       NULL\n+         NULL       MASK             minval(array, mask=m)\n+         DIM        MASK\n+\n+   I.e. in the case of minval(array,mask), mask will be in the second\n+   position of the argument list and we'll have to fix that up.  */\n+\n try\n-gfc_check_minval_maxval (gfc_expr * array, gfc_expr * dim, gfc_expr * mask)\n+gfc_check_reduction (gfc_actual_arglist * ap)\n {\n+  gfc_expr *a, *m, *d;\n \n-  if (array_check (array, 0) == FAILURE)\n+  a = ap->expr;\n+  if (int_or_real_check (a, 0) == FAILURE\n+      || array_check (a, 0) == FAILURE)\n     return FAILURE;\n \n-  if (int_or_real_check (array, 0) == FAILURE)\n-    return FAILURE;\n+  d = ap->next->expr;\n+  m = ap->next->next->expr;\n \n-  if (dim_check (dim, 1, 1) == FAILURE)\n+  if (m == NULL && d != NULL && d->ts.type == BT_LOGICAL\n+      && ap->next->name[0] == '\\0')\n+    {\n+      m = d;\n+      d = NULL;\n+\n+      ap->next->expr = NULL;\n+      ap->next->next->expr = m;\n+    }\n+\n+  if (d != NULL\n+      && (scalar_check (d, 1) == FAILURE\n+      || type_check (d, 1, BT_INTEGER) == FAILURE))\n     return FAILURE;\n \n-  if (mask != NULL && logical_array_check (mask, 2) == FAILURE)\n+  if (m != NULL && type_check (m, 2, BT_LOGICAL) == FAILURE)\n     return FAILURE;\n \n   return SUCCESS;\n@@ -1276,26 +1306,6 @@ gfc_check_present (gfc_expr * a)\n }\n \n \n-try\n-gfc_check_product (gfc_expr * array, gfc_expr * dim, gfc_expr * mask)\n-{\n-\n-  if (array_check (array, 0) == FAILURE)\n-    return FAILURE;\n-\n-  if (numeric_check (array, 0) == FAILURE)\n-    return FAILURE;\n-\n-  if (dim_check (dim, 1, 1) == FAILURE)\n-    return FAILURE;\n-\n-  if (mask != NULL && logical_array_check (mask, 2) == FAILURE)\n-    return FAILURE;\n-\n-  return SUCCESS;\n-}\n-\n-\n try\n gfc_check_radix (gfc_expr * x)\n {\n@@ -1552,26 +1562,6 @@ gfc_check_spread (gfc_expr * source, gfc_expr * dim, gfc_expr * ncopies)\n }\n \n \n-try\n-gfc_check_sum (gfc_expr * array, gfc_expr * dim, gfc_expr * mask)\n-{\n-\n-  if (array_check (array, 0) == FAILURE)\n-    return FAILURE;\n-\n-  if (numeric_check (array, 0) == FAILURE)\n-    return FAILURE;\n-\n-  if (dim_check (dim, 1, 1) == FAILURE)\n-    return FAILURE;\n-\n-  if (mask != NULL && logical_array_check (mask, 2) == FAILURE)\n-    return FAILURE;\n-\n-  return SUCCESS;\n-}\n-\n-\n try\n gfc_check_transfer (gfc_expr * source ATTRIBUTE_UNUSED,\n \t\t    gfc_expr * mold ATTRIBUTE_UNUSED,"}, {"sha": "2839b4a995eb80086c1f6a3fc10ae2b24b5442b0", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7551270e1b6232a38f772eb9298ddbe0aa970918/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7551270e1b6232a38f772eb9298ddbe0aa970918/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=7551270e1b6232a38f772eb9298ddbe0aa970918", "patch": "@@ -923,6 +923,7 @@ typedef union\n   try (*f2)(struct gfc_expr *, struct gfc_expr *);\n   try (*f3)(struct gfc_expr *, struct gfc_expr *, struct gfc_expr *);\n   try (*f3ml)(gfc_actual_arglist *);\n+  try (*f3red)(gfc_actual_arglist *);\n   try (*f4)(struct gfc_expr *, struct gfc_expr *, struct gfc_expr *,\n \t    struct gfc_expr *);\n   try (*f5)(struct gfc_expr *, struct gfc_expr *, struct gfc_expr *,"}, {"sha": "00cdecf87da1d27239ea873f0a4f6e626102ccc8", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 52, "deletions": 21, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7551270e1b6232a38f772eb9298ddbe0aa970918/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7551270e1b6232a38f772eb9298ddbe0aa970918/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=7551270e1b6232a38f772eb9298ddbe0aa970918", "patch": "@@ -506,6 +506,33 @@ static void add_sym_3ml (const char *name, int elemental,\n \t   (void*)0);\n }\n \n+/* MINVAL, MAXVAL, PRODUCT, and SUM also get special treatment because\n+   their argument also might have to be reordered.  */\n+\n+static void add_sym_3red (const char *name, int elemental, \n+                          int actual_ok, bt type, int kind,\n+                          try (*check)(gfc_actual_arglist *),\n+                          gfc_expr*(*simplify)(gfc_expr *,gfc_expr *,gfc_expr *),\n+                          void (*resolve)(gfc_expr *,gfc_expr *,gfc_expr *,gfc_expr *),\n+                          const char* a1, bt type1, int kind1, int optional1,\n+                          const char* a2, bt type2, int kind2, int optional2,\n+                          const char* a3, bt type3, int kind3, int optional3\n+                          ) {\n+  gfc_check_f cf;\n+  gfc_simplify_f sf;\n+  gfc_resolve_f rf;\n+\n+  cf.f3red = check;\n+  sf.f3 = simplify;\n+  rf.f3 = resolve;\n+\n+  add_sym (name, elemental, actual_ok, type, kind, cf, sf, rf,\n+\t   a1, type1, kind1, optional1,\n+\t   a2, type2, kind2, optional2,\n+\t   a3, type3, kind3, optional3,\n+\t   (void*)0);\n+}\n+\n /* Add the name of an intrinsic subroutine with three arguments to the list\n    of intrinsic names. */\n \n@@ -1378,10 +1405,10 @@ add_functions (void)\n \n   make_generic (\"maxloc\", GFC_ISYM_MAXLOC);\n \n-  add_sym_3 (\"maxval\", 0, 1, BT_REAL, dr,\n-\t     gfc_check_minval_maxval, NULL, gfc_resolve_maxval,\n-\t     ar, BT_REAL, dr, 0, dm, BT_INTEGER, ii, 1,\n-\t     msk, BT_LOGICAL, dl, 1);\n+  add_sym_3red (\"maxval\", 0, 1, BT_REAL, dr,\n+                gfc_check_reduction, NULL, gfc_resolve_maxval,\n+                ar, BT_REAL, dr, 0, dm, BT_INTEGER, ii, 1,\n+                msk, BT_LOGICAL, dl, 1);\n \n   make_generic (\"maxval\", GFC_ISYM_MAXVAL);\n \n@@ -1433,10 +1460,10 @@ add_functions (void)\n \n   make_generic (\"minloc\", GFC_ISYM_MINLOC);\n \n-  add_sym_3 (\"minval\", 0, 1, BT_REAL, dr,\n-\t     gfc_check_minval_maxval, NULL, gfc_resolve_minval,\n-\t     ar, BT_REAL, dr, 0, dm, BT_INTEGER, ii, 1,\n-\t     msk, BT_LOGICAL, dl, 1);\n+  add_sym_3red (\"minval\", 0, 1, BT_REAL, dr,\n+                gfc_check_reduction, NULL, gfc_resolve_minval,\n+                ar, BT_REAL, dr, 0, dm, BT_INTEGER, ii, 1,\n+                msk, BT_LOGICAL, dl, 1);\n \n   make_generic (\"minval\", GFC_ISYM_MINVAL);\n \n@@ -1506,10 +1533,10 @@ add_functions (void)\n \n   make_generic (\"present\", GFC_ISYM_PRESENT);\n \n-  add_sym_3 (\"product\", 0, 1, BT_REAL, dr,\n-\t     gfc_check_product, NULL, gfc_resolve_product,\n-\t     ar, BT_REAL, dr, 0, dm, BT_INTEGER, ii, 1,\n-\t     msk, BT_LOGICAL, dl, 1);\n+  add_sym_3red (\"product\", 0, 1, BT_REAL, dr,\n+                gfc_check_reduction, NULL, gfc_resolve_product,\n+                ar, BT_REAL, dr, 0, dm, BT_INTEGER, ii, 1,\n+                msk, BT_LOGICAL, dl, 1);\n \n   make_generic (\"product\", GFC_ISYM_PRODUCT);\n \n@@ -1688,10 +1715,10 @@ add_functions (void)\n \n   make_generic (\"sqrt\", GFC_ISYM_SQRT);\n \n-  add_sym_3 (\"sum\", 0, 1, BT_UNKNOWN, 0,\n-\t     gfc_check_sum, NULL, gfc_resolve_sum,\n-\t     ar, BT_REAL, dr, 0, dm, BT_INTEGER, ii, 1,\n-\t     msk, BT_LOGICAL, dl, 1);\n+  add_sym_3red (\"sum\", 0, 1, BT_UNKNOWN, 0,\n+                gfc_check_reduction, NULL, gfc_resolve_sum,\n+                ar, BT_REAL, dr, 0, dm, BT_INTEGER, ii, 1,\n+                msk, BT_LOGICAL, dl, 1);\n \n   make_generic (\"sum\", GFC_ISYM_SUM);\n \n@@ -2462,7 +2489,15 @@ check_specific (gfc_intrinsic_sym * specific, gfc_expr * expr, int error_flag)\n \t\t   &expr->where) == FAILURE)\n     return FAILURE;\n \n-  if (specific->check.f3ml != gfc_check_minloc_maxloc)\n+  if (specific->check.f3ml == gfc_check_minloc_maxloc)\n+    /* This is special because we might have to reorder the argument\n+       list.  */\n+    t = gfc_check_minloc_maxloc (*ap);\n+  else if (specific->check.f3red == gfc_check_reduction)\n+    /* This is also special because we also might have to reorder the\n+       argument list.  */\n+    t = gfc_check_reduction (*ap);\n+  else\n      {\n        if (specific->check.f1 == NULL)\n \t {\n@@ -2473,10 +2508,6 @@ check_specific (gfc_intrinsic_sym * specific, gfc_expr * expr, int error_flag)\n        else\n \t t = do_check (specific, *ap);\n      }\n-  else\n-    /* This is special because we might have to reorder the argument\n-       list.  */\n-    t = gfc_check_minloc_maxloc (*ap);\n \n   /* Check ranks for elemental intrinsics.  */\n   if (t == SUCCESS && specific->elemental)"}, {"sha": "0eeeaf96e852970d4e610722cad04591061cedd5", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7551270e1b6232a38f772eb9298ddbe0aa970918/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7551270e1b6232a38f772eb9298ddbe0aa970918/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=7551270e1b6232a38f772eb9298ddbe0aa970918", "patch": "@@ -70,17 +70,16 @@ try gfc_check_min_max_double (gfc_actual_arglist *);\n try gfc_check_matmul (gfc_expr *, gfc_expr *);\n try gfc_check_merge (gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_minloc_maxloc (gfc_actual_arglist *);\n-try gfc_check_minval_maxval (gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_nearest (gfc_expr *, gfc_expr *);\n try gfc_check_null (gfc_expr *);\n try gfc_check_pack (gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_precision (gfc_expr *);\n try gfc_check_present (gfc_expr *);\n-try gfc_check_product (gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_radix (gfc_expr *);\n try gfc_check_rand (gfc_expr *);\n try gfc_check_range (gfc_expr *);\n try gfc_check_real (gfc_expr *, gfc_expr *);\n+try gfc_check_reduction (gfc_actual_arglist *);\n try gfc_check_repeat (gfc_expr *, gfc_expr *);\n try gfc_check_reshape (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_scale (gfc_expr *, gfc_expr *);"}, {"sha": "bfa51c4ea7cd8fb3552a5976be9db11d52c6b030", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7551270e1b6232a38f772eb9298ddbe0aa970918/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7551270e1b6232a38f772eb9298ddbe0aa970918/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=7551270e1b6232a38f772eb9298ddbe0aa970918", "patch": "@@ -882,6 +882,7 @@ gfc_resolve_minloc (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n                     gfc_type_letter (array->ts.type), array->ts.kind);\n }\n \n+\n void\n gfc_resolve_minval (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n \t\t    gfc_expr * mask)"}, {"sha": "6ec5172ba1d31f60d9b27bb1d186858246bf2b06", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7551270e1b6232a38f772eb9298ddbe0aa970918/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7551270e1b6232a38f772eb9298ddbe0aa970918/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7551270e1b6232a38f772eb9298ddbe0aa970918", "patch": "@@ -1,3 +1,8 @@\n+2004-08-19  Erik Schnetter  <schnetter@aei.mpg.de>\n+\n+\tPR fortran/16946\n+\t* gfortran.dg/reduction.f90: New testcase.\n+\n 2004-08-19  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/16520"}, {"sha": "f98eb29231f6b150074affd3a57d23e358d43752", "filename": "gcc/testsuite/gfortran.dg/reduction.f90", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7551270e1b6232a38f772eb9298ddbe0aa970918/gcc%2Ftestsuite%2Fgfortran.dg%2Freduction.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7551270e1b6232a38f772eb9298ddbe0aa970918/gcc%2Ftestsuite%2Fgfortran.dg%2Freduction.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freduction.f90?ref=7551270e1b6232a38f772eb9298ddbe0aa970918", "patch": "@@ -0,0 +1,58 @@\n+! { dg-do run }\n+! PR 16946\n+! Not all allowed combinations of arguments for MAXVAL, MINVAL,\n+! PRODUCT and SUM were supported.\n+program reduction_mask\n+  implicit none\n+  logical :: equal(3)\n+  \n+  integer, parameter :: res(4*9) = (/ 3, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, &\n+       1, 1, 1, 1, 1, 6, 6, 6, 2, 2, 2, 2, 2, 2, 6, 6, 6, 3, 3, 3, 3, 3, 3 /)\n+  integer :: val(4*9)\n+  \n+  equal = (/ .true., .true., .false. /)\n+  \n+  ! use all combinations of the dim and mask arguments for the\n+  ! reduction intrinsics\n+  val( 1) = maxval((/ 1, 2, 3 /))\n+  val( 2) = maxval((/ 1, 2, 3 /), 1)\n+  val( 3) = maxval((/ 1, 2, 3 /), dim=1)\n+  val( 4) = maxval((/ 1, 2, 3 /), equal)\n+  val( 5) = maxval((/ 1, 2, 3 /), mask=equal)\n+  val( 6) = maxval((/ 1, 2, 3 /), 1, equal)\n+  val( 7) = maxval((/ 1, 2, 3 /), 1, mask=equal)\n+  val( 8) = maxval((/ 1, 2, 3 /), dim=1, mask=equal)\n+  val( 9) = maxval((/ 1, 2, 3 /), mask=equal, dim=1)\n+       \n+  val(10) = minval((/ 1, 2, 3 /))\n+  val(11) = minval((/ 1, 2, 3 /), 1)\n+  val(12) = minval((/ 1, 2, 3 /), dim=1)\n+  val(13) = minval((/ 1, 2, 3 /), equal)\n+  val(14) = minval((/ 1, 2, 3 /), mask=equal)\n+  val(15) = minval((/ 1, 2, 3 /), 1, equal)\n+  val(16) = minval((/ 1, 2, 3 /), 1, mask=equal)\n+  val(17) = minval((/ 1, 2, 3 /), dim=1, mask=equal)\n+  val(18) = minval((/ 1, 2, 3 /), mask=equal, dim=1)\n+       \n+  val(19) = product((/ 1, 2, 3 /))\n+  val(20) = product((/ 1, 2, 3 /), 1)\n+  val(21) = product((/ 1, 2, 3 /), dim=1)\n+  val(22) = product((/ 1, 2, 3 /), equal)\n+  val(23) = product((/ 1, 2, 3 /), mask=equal)\n+  val(24) = product((/ 1, 2, 3 /), 1, equal)\n+  val(25) = product((/ 1, 2, 3 /), 1, mask=equal)\n+  val(26) = product((/ 1, 2, 3 /), dim=1, mask=equal)\n+  val(27) = product((/ 1, 2, 3 /), mask=equal, dim=1)\n+       \n+  val(28) = sum((/ 1, 2, 3 /))\n+  val(29) = sum((/ 1, 2, 3 /), 1)\n+  val(30) = sum((/ 1, 2, 3 /), dim=1)\n+  val(31) = sum((/ 1, 2, 3 /), equal)\n+  val(32) = sum((/ 1, 2, 3 /), mask=equal)\n+  val(33) = sum((/ 1, 2, 3 /), 1, equal)\n+  val(34) = sum((/ 1, 2, 3 /), 1, mask=equal)\n+  val(35) = sum((/ 1, 2, 3 /), dim=1, mask=equal)\n+  val(36) = sum((/ 1, 2, 3 /), mask=equal, dim=1)\n+  \n+  if (any (val /= res)) call abort\n+end program reduction_mask"}]}