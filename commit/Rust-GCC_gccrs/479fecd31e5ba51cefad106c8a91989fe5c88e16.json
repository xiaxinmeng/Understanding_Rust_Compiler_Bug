{"sha": "479fecd31e5ba51cefad106c8a91989fe5c88e16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc5ZmVjZDMxZTViYTUxY2VmYWQxMDZjOGE5MTk4OWZlNWM4OGUxNg==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2011-05-14T15:33:02Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2011-05-14T15:33:02Z"}, "message": "constraint.md (Yd, Yx): New register constraints.\n\n\t* config/i386/constraint.md (Yd, Yx): New register constraints.\n\t* config/i386/i386.md (*pushdf): Merge with *pushdf_nointeger.  Use\n\tYd conditional register constraint.\n\t(*movtf_internal): Use standard_sse_constant_opcode.\n\t(*movxf_internal): Merge with *movxf_internal_nointeger.  Use\n\tYx conditional register constraint.\n\t(*movdf_internal): Merge with *movdf_internal_nointeger.  Use\n\tYd conditional register constraint.  Use standard_sse_constant_p to\n\tcheck for valid SSE constants and call standard_sse_constant_opcode to\n\toutput SSE insn.\n\t(*movsf_internal): Use standard_sse_constant_p to check for valid SSE\n\tconstants and call standard_sse_constant_opcode to output SSE insn.\n\t* config/i386/i386.c (ix86_option_ovverride_internal): Set\n\tTARGET_INTEGER_DFMODE_MOVES for 64bit targets.  Clear it when\n\toptimize_size is set.\n\t(standard_sse_constant_opcode): Output conditional AVX insn templates.\n\nFrom-SVN: r173757", "tree": {"sha": "652e348c7f6403901a3e7207a49a80b401adbb1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/652e348c7f6403901a3e7207a49a80b401adbb1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/479fecd31e5ba51cefad106c8a91989fe5c88e16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/479fecd31e5ba51cefad106c8a91989fe5c88e16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/479fecd31e5ba51cefad106c8a91989fe5c88e16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/479fecd31e5ba51cefad106c8a91989fe5c88e16/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "748f7574e85b092b4e33e8e10e87e2f6d6261f9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/748f7574e85b092b4e33e8e10e87e2f6d6261f9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/748f7574e85b092b4e33e8e10e87e2f6d6261f9a"}], "stats": {"total": 381, "additions": 109, "deletions": 272}, "files": [{"sha": "b5439d5f55f4c4efee6cf9aa1be9599464c11fe3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/479fecd31e5ba51cefad106c8a91989fe5c88e16/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/479fecd31e5ba51cefad106c8a91989fe5c88e16/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=479fecd31e5ba51cefad106c8a91989fe5c88e16", "patch": "@@ -1,3 +1,41 @@\n+2011-05-14  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/constraint.md (Yd, Yx): New register constraints.\n+\t* config/i386/i386.md (*pushdf): Merge with *pushdf_nointeger.  Use\n+\tYd conditional register constraint.\n+\t(*movtf_internal): Use standard_sse_constant_opcode.\n+\t(*movxf_internal): Merge with *movxf_internal_nointeger.  Use\n+\tYx conditional register constraint.\n+\t(*movdf_internal): Merge with *movdf_internal_nointeger.  Use\n+\tYd conditional register constraint.  Use standard_sse_constant_p to\n+\tcheck for valid SSE constants and call standard_sse_constant_opcode to\n+\toutput SSE insn.\n+\t(*movsf_internal): Use standard_sse_constant_p to check for valid SSE\n+\tconstants and call standard_sse_constant_opcode to output SSE insn.\n+\t* config/i386/i386.c (ix86_option_ovverride_internal): Set\n+\tTARGET_INTEGER_DFMODE_MOVES for 64bit targets.  Clear it when\n+\toptimize_size is set.\n+\t(standard_sse_constant_opcode): Output conditional AVX insn templates.\n+\n+2011-05-14  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/constraint.md (Yd, Yx): New register constraints.\n+\t* config/i386/i386.md (*pushdf): Merge with *pushdf_nointeger.  Use\n+\tYd conditional register constraint.\n+\t(*movtf_internal): Use standard_sse_constant_opcode.\n+\t(*movxf_internal): Merge with *movxf_internal_nointeger.  Use\n+\tYx conditional register constraint.\n+\t(*movdf_internal): Merge with *movdf_internal_nointeger.  Use\n+\tYd conditional register constraint.  Use standard_sse_constant_p to\n+\tcheck for valid SSE constants and call standard_sse_constant_opcode to\n+\toutput SSE insn.\n+\t(*movsf_internal): Use standard_sse_constant_p to check for valid SSE\n+\tconstants and call standard_sse_constant_opcode to output SSE insn.\n+\t* config/i386/i386.c (ix86_option_ovverride_internal): Set\n+\tTARGET_INTEGER_DFMODE_MOVES for 64bit targets.  Clear it when\n+\toptimize_size is set.\n+\t(standard_sse_constant_opcode): Output conditional AVX insn templates.\n+\n 2011-05-14  Tobias Burnus  <burnus@net-b.de>\n \n \t* doc/invoke.texi (-Ofast): Also enables -fstack-arrays.\n@@ -243,11 +281,11 @@\n 2011-05-11  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (legitimize_tls_address)\n-\t<TLS_MODEL_GLOBAL_DYNAMIC>: Call gen_tls_dynamic_gnu2_{32,64}\n+\t<case TLS_MODEL_GLOBAL_DYNAMIC>: Call gen_tls_dynamic_gnu2_{32,64}\n \texpanders directly for TARGET_GNU2_TLS.  Determine pic and\n \t__tls_get_addr symbol reference here.  Update call to\n \tgen_tls_global_dynamic_{32,64} for added arguments.\n-\t<TLS_MODEL_LOCAL_DYNAMIC>: Call gen_tls_dynamic_gnu2_{32,64}\n+\t<case TLS_MODEL_LOCAL_DYNAMIC>: Call gen_tls_dynamic_gnu2_{32,64}\n \texpanders directly for TARGET_GNU2_TLS.  Determine\n \t__tls_get_addr symbol reference here.  Update call to\n \tgen_tls_local_dynamic_base_{32,64} for added arguments.  Attach"}, {"sha": "ed558b483124a8336d873c4a0081fb14d77eea1a", "filename": "gcc/config/i386/constraints.md", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/479fecd31e5ba51cefad106c8a91989fe5c88e16/gcc%2Fconfig%2Fi386%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/479fecd31e5ba51cefad106c8a91989fe5c88e16/gcc%2Fconfig%2Fi386%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fconstraints.md?ref=479fecd31e5ba51cefad106c8a91989fe5c88e16", "patch": "@@ -90,6 +90,8 @@\n ;;  2\tSSE2 enabled\n ;;  i\tSSE2 inter-unit moves enabled\n ;;  m\tMMX inter-unit moves enabled\n+;;  d\tInteger register when integer DFmode moves are enabled\n+;;  x\tInteger register when integer XFmode moves are enabled\n \n (define_register_constraint \"Yz\" \"TARGET_SSE ? SSE_FIRST_REG : NO_REGS\"\n  \"First SSE register (@code{%xmm0}).\")\n@@ -105,6 +107,14 @@\n  \"TARGET_MMX && TARGET_INTER_UNIT_MOVES ? MMX_REGS : NO_REGS\"\n  \"@internal Any MMX register, when inter-unit moves are enabled.\")\n \n+(define_register_constraint \"Yd\"\n+ \"TARGET_INTEGER_DFMODE_MOVES ? GENERAL_REGS : NO_REGS\"\n+ \"@internal Any integer register when integer DFmode moves are enabled.\")\n+\n+(define_register_constraint \"Yx\"\n+ \"optimize_function_for_speed_p (cfun) ? GENERAL_REGS : NO_REGS\"\n+ \"@internal Any integer register when integer XFmode moves are enabled.\")\n+\n ;; Integer constant constraints.\n (define_constraint \"I\"\n   \"Integer constant in the range 0 @dots{} 31, for 32-bit shifts.\"\n@@ -149,7 +159,7 @@\n (define_constraint \"G\"\n   \"Standard 80387 floating point constant.\"\n   (and (match_code \"const_double\")\n-       (match_test \"standard_80387_constant_p (op)\")))\n+       (match_test \"standard_80387_constant_p (op) > 0\")))\n \n ;; This can theoretically be any mode's CONST0_RTX.\n (define_constraint \"C\""}, {"sha": "84678061d5e08dc2bd744b7b9ed8784c0d966e63", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/479fecd31e5ba51cefad106c8a91989fe5c88e16/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/479fecd31e5ba51cefad106c8a91989fe5c88e16/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=479fecd31e5ba51cefad106c8a91989fe5c88e16", "patch": "@@ -3933,6 +3933,13 @@ ix86_option_override_internal (bool main_args_p)\n   if (!TARGET_80387)\n     target_flags |= MASK_NO_FANCY_MATH_387;\n \n+  /* On 32bit targets, avoid moving DFmode values in\n+     integer registers when optimizing for size.  */\n+  if (TARGET_64BIT)\n+    target_flags |= TARGET_INTEGER_DFMODE_MOVES;\n+  else if (optimize_size)\n+    target_flags &= ~TARGET_INTEGER_DFMODE_MOVES;\n+\n   /* Turn on MMX builtins for -msse.  */\n   if (TARGET_SSE)\n     {\n@@ -8580,17 +8587,17 @@ standard_sse_constant_opcode (rtx insn, rtx x)\n       switch (get_attr_mode (insn))\n \t{\n \tcase MODE_V4SF:\n-\t  return TARGET_AVX ? \"vxorps\\t%0, %0, %0\" : \"xorps\\t%0, %0\";\n+\t  return \"%vxorps\\t%0, %d0\";\n \tcase MODE_V2DF:\n \t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return TARGET_AVX ? \"vxorps\\t%0, %0, %0\" : \"xorps\\t%0, %0\";\n+\t    return \"%vxorps\\t%0, %d0\";\n \t  else\n-\t    return TARGET_AVX ? \"vxorpd\\t%0, %0, %0\" : \"xorpd\\t%0, %0\";\n+\t    return \"%vxorpd\\t%0, %d0\";\n \tcase MODE_TI:\n \t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return TARGET_AVX ? \"vxorps\\t%0, %0, %0\" : \"xorps\\t%0, %0\";\n+\t    return \"%vxorps\\t%0, %d0\";\n \t  else\n-\t    return TARGET_AVX ? \"vpxor\\t%0, %0, %0\" : \"pxor\\t%0, %0\";\n+\t    return \"%vpxor\\t%0, %d0\";\n \tcase MODE_V8SF:\n \t  return \"vxorps\\t%x0, %x0, %x0\";\n \tcase MODE_V4DF:\n@@ -8607,7 +8614,7 @@ standard_sse_constant_opcode (rtx insn, rtx x)\n \t  break;\n \t}\n     case 2:\n-      return TARGET_AVX ? \"vpcmpeqd\\t%0, %0, %0\" : \"pcmpeqd\\t%0, %0\";\n+      return \"%vpcmpeqd\\t%0, %d0\";\n     default:\n       break;\n     }"}, {"sha": "09c9b7a3d0014fb419c3aab857fbffe79cf35846", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 45, "deletions": 263, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/479fecd31e5ba51cefad106c8a91989fe5c88e16/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/479fecd31e5ba51cefad106c8a91989fe5c88e16/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=479fecd31e5ba51cefad106c8a91989fe5c88e16", "patch": "@@ -2702,10 +2702,14 @@\n   [(const_int 0)]\n   \"ix86_split_long_move (operands); DONE;\")\n \n+;; Size of pushdf is 3 (for sub) + 2 (for fstp) + memory operand size.\n+;; Size of pushdf using integer instructions is 2+2*memory operand size\n+;; On the average, pushdf using integers can be still shorter.\n+\n (define_insn \"*pushdf\"\n   [(set (match_operand:DF 0 \"push_operand\" \"=<,<,<\")\n-\t(match_operand:DF 1 \"general_no_elim_operand\" \"f,rFo,Y2\"))]\n-  \"TARGET_64BIT || TARGET_INTEGER_DFMODE_MOVES\"\n+\t(match_operand:DF 1 \"general_no_elim_operand\" \"f,Yd*rFo,Y2\"))]\n+  \"\"\n {\n   /* This insn should be already split before reg-stack.  */\n   gcc_unreachable ();\n@@ -2714,23 +2718,6 @@\n    (set_attr \"unit\" \"i387,*,*\")\n    (set_attr \"mode\" \"DF,SI,DF\")])\n \n-;; Size of pushdf is 3 (for sub) + 2 (for fstp) + memory operand size.\n-;; Size of pushdf using integer instructions is 2+2*memory operand size\n-;; On the average, pushdf using integers can be still shorter.  Allow this\n-;; pattern for optimize_size too.\n-\n-(define_insn \"*pushdf_nointeger\"\n-  [(set (match_operand:DF 0 \"push_operand\" \"=<,<,<,<\")\n-\t(match_operand:DF 1 \"general_no_elim_operand\" \"f,Fo,*r,Y2\"))]\n-  \"!(TARGET_64BIT || TARGET_INTEGER_DFMODE_MOVES)\"\n-{\n-  /* This insn should be already split before reg-stack.  */\n-  gcc_unreachable ();\n-}\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"unit\" \"i387,*,*,*\")\n-   (set_attr \"mode\" \"DF,SI,SI,DF\")])\n-\n ;; %%% Kill this when call knows how to work this out.\n (define_split\n   [(set (match_operand:DF 0 \"push_operand\" \"\")\n@@ -2822,14 +2809,14 @@\n \treturn \"%vmovaps\\t{%1, %0|%0, %1}\";\n       else\n \treturn \"%vmovdqa\\t{%1, %0|%0, %1}\";\n+\n     case 2:\n-      if (get_attr_mode (insn) == MODE_V4SF)\n-\treturn \"%vxorps\\t%0, %d0\";\n-      else\n-\treturn \"%vpxor\\t%0, %d0\";\n+      return standard_sse_constant_opcode (insn, operands[1]);\n+\n     case 3:\n     case 4:\n \treturn \"#\";\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -2862,42 +2849,14 @@\n   \"ix86_split_long_move (operands); DONE;\")\n \n (define_insn \"*movxf_internal\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,m,f,r,o\")\n-\t(match_operand:XF 1 \"general_operand\" \"fm,f,G,roF,Fr\"))]\n-  \"optimize_function_for_speed_p (cfun)\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n-   && (!can_create_pseudo_p ()\n-       || GET_CODE (operands[1]) != CONST_DOUBLE\n-       || memory_operand (operands[0], XFmode))\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-    case 1:\n-      return output_387_reg_move (insn, operands);\n-\n-    case 2:\n-      return standard_80387_constant_opcode (operands[1]);\n-\n-    case 3: case 4:\n-      return \"#\";\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi\")\n-   (set_attr \"mode\" \"XF,XF,XF,SI,SI\")])\n-\n-;; Do not use integer registers when optimizing for size\n-(define_insn \"*movxf_internal_nointeger\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,m,f,*r,o\")\n-\t(match_operand:XF 1 \"general_operand\" \"fm,f,G,*roF,F*r\"))]\n-  \"optimize_function_for_size_p (cfun)\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n+  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,m,f,Yx*r  ,o\")\n+\t(match_operand:XF 1 \"general_operand\"\t   \"fm,f,G,Yx*roF,FYx*r\"))]\n+  \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n    && (!can_create_pseudo_p ()\n-       || standard_80387_constant_p (operands[1])\n+       || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n+       || (optimize_function_for_size_p (cfun)\n+\t   && standard_80387_constant_p (operands[1]) > 0)\n        || memory_operand (operands[0], XFmode))\"\n {\n   switch (which_alternative)\n@@ -2940,10 +2899,12 @@\n   \"TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n    && (!can_create_pseudo_p ()\n        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n-       || (!(TARGET_SSE2 && TARGET_SSE_MATH)\n-           && optimize_function_for_size_p (cfun)\n-\t   && standard_80387_constant_p (operands[1]))\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n+       || (optimize_function_for_size_p (cfun)\n+\t   && ((!(TARGET_SSE2 && TARGET_SSE_MATH)\n+\t\t&& standard_80387_constant_p (operands[1]) > 0)\n+\t       || (TARGET_SSE2 && TARGET_SSE_MATH\n+\t\t   && standard_sse_constant_p (operands[1]))))\n        || memory_operand (operands[0], DFmode))\"\n {\n   switch (which_alternative)\n@@ -2966,23 +2927,8 @@\n       return \"#\";\n \n     case 7:\n-      switch (get_attr_mode (insn))\n-\t{\n-\tcase MODE_V4SF:\n-\t  return \"%vxorps\\t%0, %d0\";\n-\tcase MODE_V2DF:\n-\t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return \"%vxorps\\t%0, %d0\";\n-\t  else\n-\t    return \"%vxorpd\\t%0, %d0\";\n-\tcase MODE_TI:\n-\t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return \"%vxorps\\t%0, %d0\";\n-\t  else\n-\t    return \"%vpxor\\t%0, %d0\";\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n+      return standard_sse_constant_opcode (insn, operands[1]);\n+\n     case 8:\n     case 9:\n     case 10:\n@@ -3094,21 +3040,26 @@\n \t      ]\n \t      (const_string \"DF\")))])\n \n+;; Possible store forwarding (partial memory) stall in alternative 4.\n (define_insn \"*movdf_internal\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\"\n-\t\t\"=f,m,f,r  ,o ,Y2*x,Y2*x,Y2*x,m   \")\n+\t\t\"=f,m,f,Yd*r  ,o    ,Y2*x,Y2*x,Y2*x,m  \")\n \t(match_operand:DF 1 \"general_operand\"\n-\t\t\"fm,f,G,roF,Fr,C   ,Y2*x,m   ,Y2*x\"))]\n+\t\t\"fm,f,G,Yd*roF,FYd*r,C   ,Y2*x,m   ,Y2*x\"))]\n   \"!TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n-   && optimize_function_for_speed_p (cfun)\n-   && TARGET_INTEGER_DFMODE_MOVES\n    && (!can_create_pseudo_p ()\n        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n-       || (!(TARGET_SSE2 && TARGET_SSE_MATH)\n-           && optimize_function_for_size_p (cfun)\n-\t   && standard_80387_constant_p (operands[1]))\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n-       || memory_operand (operands[0], DFmode))\"\n+       || (optimize_function_for_size_p (cfun)\n+\t   && ((!(TARGET_SSE2 && TARGET_SSE_MATH)\n+\t\t&& standard_80387_constant_p (operands[1]) > 0)\n+\t       || (TARGET_SSE2 && TARGET_SSE_MATH\n+\t\t   && standard_sse_constant_p (operands[1])))\n+\t   && !memory_operand (operands[0], DFmode))\n+       || ((TARGET_INTEGER_DFMODE_MOVES\n+\t    || (optimize_function_for_size_p (cfun)\n+\t        && !TARGET_MEMORY_MISMATCH_STALL))\n+\t   && memory_operand (operands[0], DFmode)))\"\n {\n   switch (which_alternative)\n     {\n@@ -3124,179 +3075,8 @@\n       return \"#\";\n \n     case 5:\n-      switch (get_attr_mode (insn))\n-\t{\n-\tcase MODE_V4SF:\n-\t  return \"%vxorps\\t%0, %d0\";\n-\tcase MODE_V2DF:\n-\t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return \"%vxorps\\t%0, %d0\";\n-\t  else\n-\t    return \"%vxorpd\\t%0, %d0\";\n-\tcase MODE_TI:\n-\t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return \"%vxorps\\t%0, %d0\";\n-\t  else\n-\t    return \"%vpxor\\t%0, %d0\";\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    case 6:\n-    case 7:\n-    case 8:\n-      switch (get_attr_mode (insn))\n-\t{\n-\tcase MODE_V4SF:\n-\t  return \"%vmovaps\\t{%1, %0|%0, %1}\";\n-\tcase MODE_V2DF:\n-\t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return \"%vmovaps\\t{%1, %0|%0, %1}\";\n-\t  else\n-\t    return \"%vmovapd\\t{%1, %0|%0, %1}\";\n-\tcase MODE_TI:\n-\t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return \"%vmovaps\\t{%1, %0|%0, %1}\";\n-\t  else\n-\t    return \"%vmovdqa\\t{%1, %0|%0, %1}\";\n-\tcase MODE_DI:\n-\t  return \"%vmovq\\t{%1, %0|%0, %1}\";\n-\tcase MODE_DF:\n-\t  if (TARGET_AVX && REG_P (operands[0]) && REG_P (operands[1]))\n-\t    return \"vmovsd\\t{%1, %0, %0|%0, %0, %1}\";\n-\t  else\n-\t    return \"%vmovsd\\t{%1, %0|%0, %1}\";\n-\tcase MODE_V1DF:\n-\t  if (TARGET_AVX && REG_P (operands[0]))\n-\t    return \"vmovlpd\\t{%1, %0, %0|%0, %0, %1}\";\n-\t  else\n-\t    return \"%vmovlpd\\t{%1, %0|%0, %1}\";\n-\tcase MODE_V2SF:\n-\t  if (TARGET_AVX && REG_P (operands[0]))\n-\t    return \"vmovlps\\t{%1, %0, %0|%0, %0, %1}\";\n-\t  else\n-\t    return \"%vmovlps\\t{%1, %0|%0, %1}\";\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi,sselog1,ssemov,ssemov,ssemov\")\n-   (set (attr \"prefix\")\n-     (if_then_else (eq_attr \"alternative\" \"0,1,2,3,4\")\n-       (const_string \"orig\")\n-       (const_string \"maybe_vex\")))\n-   (set (attr \"prefix_data16\")\n-     (if_then_else (eq_attr \"mode\" \"V1DF\")\n-       (const_string \"1\")\n-       (const_string \"*\")))\n-   (set (attr \"mode\")\n-        (cond [(eq_attr \"alternative\" \"0,1,2\")\n-\t\t (const_string \"DF\")\n-\t       (eq_attr \"alternative\" \"3,4\")\n-\t\t (const_string \"SI\")\n-\n-\t       /* For SSE1, we have many fewer alternatives.  */\n-\t       (eq (symbol_ref \"TARGET_SSE2\") (const_int 0))\n-\t\t (cond [(eq_attr \"alternative\" \"5,6\")\n-\t\t\t  (const_string \"V4SF\")\n-\t\t       ]\n-\t\t   (const_string \"V2SF\"))\n-\n-\t       /* xorps is one byte shorter.  */\n-\t       (eq_attr \"alternative\" \"5\")\n-\t\t (cond [(ne (symbol_ref \"optimize_function_for_size_p (cfun)\")\n-\t\t\t    (const_int 0))\n-\t\t\t  (const_string \"V4SF\")\n-\t\t\t(ne (symbol_ref \"TARGET_SSE_LOAD0_BY_PXOR\")\n-\t\t\t    (const_int 0))\n-\t\t\t  (const_string \"TI\")\n-\t\t       ]\n-\t\t       (const_string \"V2DF\"))\n+      return standard_sse_constant_opcode (insn, operands[1]);\n \n-\t       /* For architectures resolving dependencies on\n-\t\t  whole SSE registers use APD move to break dependency\n-\t\t  chains, otherwise use short move to avoid extra work.\n-\n-\t\t  movaps encodes one byte shorter.  */\n-\t       (eq_attr \"alternative\" \"6\")\n-\t\t (cond\n-\t\t   [(ne (symbol_ref \"optimize_function_for_size_p (cfun)\")\n-\t\t        (const_int 0))\n-\t\t      (const_string \"V4SF\")\n-\t\t    (ne (symbol_ref \"TARGET_SSE_PARTIAL_REG_DEPENDENCY\")\n-\t\t        (const_int 0))\n-\t\t      (const_string \"V2DF\")\n-\t\t   ]\n-\t\t   (const_string \"DF\"))\n-\t       /* For architectures resolving dependencies on register\n-\t\t  parts we may avoid extra work to zero out upper part\n-\t\t  of register.  */\n-\t       (eq_attr \"alternative\" \"7\")\n-\t\t (if_then_else\n-\t\t   (ne (symbol_ref \"TARGET_SSE_SPLIT_REGS\")\n-\t\t       (const_int 0))\n-\t\t   (const_string \"V1DF\")\n-\t\t   (const_string \"DF\"))\n-\t      ]\n-\t      (const_string \"DF\")))])\n-\n-;; Moving is usually shorter when only FP registers are used. This separate\n-;; movdf pattern avoids the use of integer registers for FP operations\n-;; when optimizing for size.\n-\n-(define_insn \"*movdf_internal_nointeger\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\"\n-\t\t\t\"=f,m,f,*r  ,o  ,Y2*x,Y2*x,Y2*x ,m  \")\n-\t(match_operand:DF 1 \"general_operand\"\n-\t\t\t\"fm,f,G,*roF,F*r,C   ,Y2*x,mY2*x,Y2*x\"))]\n-  \"!TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n-   && (optimize_function_for_size_p (cfun)\n-       || !TARGET_INTEGER_DFMODE_MOVES)\n-   && (!can_create_pseudo_p ()\n-       || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n-       || (!(TARGET_SSE2 && TARGET_SSE_MATH)\n-           && optimize_function_for_size_p (cfun)\n-           && !memory_operand (operands[0], DFmode)\n-\t   && standard_80387_constant_p (operands[1]))\n-       || GET_CODE (operands[1]) != CONST_DOUBLE\n-       || ((optimize_function_for_size_p (cfun)\n-            || !TARGET_MEMORY_MISMATCH_STALL)\n- \t   && memory_operand (operands[0], DFmode)))\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-    case 1:\n-      return output_387_reg_move (insn, operands);\n-\n-    case 2:\n-      return standard_80387_constant_opcode (operands[1]);\n-\n-    case 3:\n-    case 4:\n-      return \"#\";\n-\n-    case 5:\n-      switch (get_attr_mode (insn))\n-\t{\n-\tcase MODE_V4SF:\n-\t  return \"%vxorps\\t%0, %d0\";\n-\tcase MODE_V2DF:\n-\t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return \"%vxorps\\t%0, %d0\";\n-\t  else\n-\t    return \"%vxorpd\\t%0, %d0\";\n-\tcase MODE_TI:\n-\t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return \"%vxorps\\t%0, %d0\";\n-\t  else\n-\t    return \"%vpxor\\t%0, %d0\";\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n     case 6:\n     case 7:\n     case 8:\n@@ -3421,9 +3201,12 @@\n   \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n    && (!can_create_pseudo_p ()\n        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n-       || (!TARGET_SSE_MATH && optimize_function_for_size_p (cfun)\n-\t   && standard_80387_constant_p (operands[1]))\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n+       || (optimize_function_for_size_p (cfun)\n+\t   && ((!TARGET_SSE_MATH\n+\t\t&& standard_80387_constant_p (operands[1]) > 0)\n+\t       || (TARGET_SSE_MATH\n+\t\t   && standard_sse_constant_p (operands[1]))))\n        || memory_operand (operands[0], SFmode))\"\n {\n   switch (which_alternative)\n@@ -3438,11 +3221,10 @@\n     case 3:\n     case 4:\n       return \"mov{l}\\t{%1, %0|%0, %1}\";\n+\n     case 5:\n-      if (get_attr_mode (insn) == MODE_TI)\n-\treturn \"%vpxor\\t%0, %d0\";\n-      else\n-\treturn \"%vxorps\\t%0, %d0\";\n+      return standard_sse_constant_opcode (insn, operands[1]);\n+\n     case 6:\n       if (get_attr_mode (insn) == MODE_V4SF)\n \treturn \"%vmovaps\\t{%1, %0|%0, %1}\";"}]}