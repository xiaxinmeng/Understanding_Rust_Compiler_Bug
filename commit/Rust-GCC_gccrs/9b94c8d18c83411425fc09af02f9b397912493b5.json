{"sha": "9b94c8d18c83411425fc09af02f9b397912493b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI5NGM4ZDE4YzgzNDExNDI1ZmMwOWFmMDJmOWIzOTc5MTI0OTNiNQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-03-03T23:25:52Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-03-03T23:25:52Z"}, "message": "verify.cc (handle_jsr_insn): Don't fail if `jsr' appears at end of bytecode.\n\n\t* verify.cc (handle_jsr_insn): Don't fail if `jsr' appears at end\n\tof bytecode.\n\t(handle_ret_insn): Fail if returning to jsr that appears at end of\n\tbytecode.\n\nFrom-SVN: r63744", "tree": {"sha": "ab7b0c0f257f39479e009961f187e972c645f326", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab7b0c0f257f39479e009961f187e972c645f326"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b94c8d18c83411425fc09af02f9b397912493b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b94c8d18c83411425fc09af02f9b397912493b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b94c8d18c83411425fc09af02f9b397912493b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b94c8d18c83411425fc09af02f9b397912493b5/comments", "author": null, "committer": null, "parents": [{"sha": "b89a3806812e3b0980988d9ae67d9af40116ee5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b89a3806812e3b0980988d9ae67d9af40116ee5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b89a3806812e3b0980988d9ae67d9af40116ee5d"}], "stats": {"total": 32, "additions": 22, "deletions": 10}, "files": [{"sha": "b799649016fdde7f02eac953b0bb0334f8f2c81e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b94c8d18c83411425fc09af02f9b397912493b5/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b94c8d18c83411425fc09af02f9b397912493b5/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=9b94c8d18c83411425fc09af02f9b397912493b5", "patch": "@@ -1,3 +1,10 @@\n+2003-03-03  Tom Tromey  <tromey@redhat.com>\n+\n+\t* verify.cc (handle_jsr_insn): Don't fail if `jsr' appears at end\n+\tof bytecode.\n+\t(handle_ret_insn): Fail if returning to jsr that appears at end of\n+\tbytecode.\n+\n 2003-03-03  Michael Koch  <konqueror@gmx.de>\n \n \t* Makefile.am"}, {"sha": "8f8c1df9eb18782aad568434be5f8db03fb498a4", "filename": "libjava/verify.cc", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b94c8d18c83411425fc09af02f9b397912493b5/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b94c8d18c83411425fc09af02f9b397912493b5/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=9b94c8d18c83411425fc09af02f9b397912493b5", "patch": "@@ -1526,6 +1526,12 @@ class _Jv_BytecodeVerifier\n \n     for (subr_info *subr = jsr_ptrs[csub]; subr != NULL; subr = subr->next)\n       {\n+\t// We might be returning to a `jsr' that is at the end of the\n+\t// bytecode.  This is ok if we never return from the called\n+\t// subroutine, but if we see this here it is an error.\n+\tif (subr->pc >= current_method->code_length)\n+\t  verify_fail (\"fell off end\");\n+\n \t// Temporarily modify the current state so it looks like we're\n \t// in the enclosing context.\n \tcurrent_state->subroutine = get_subroutine (subr->pc);\n@@ -1575,16 +1581,15 @@ class _Jv_BytecodeVerifier\n     // the local variable state across the jsr, but the subroutine\n     // might change the stack depth, so we can't make any assumptions\n     // about it.  So we have yet another special case.  We know that\n-    // at this point PC points to the instruction after the jsr.\n-\n-    // FIXME: what if we have a jsr at the end of the code, but that\n-    // jsr has no corresponding ret?  Is this verifiable, or is it\n-    // not?  If it is then we need a special case here.\n-    if (PC >= current_method->code_length)\n-      verify_fail (\"fell off end\");\n-\n-    current_state->stacktop = state::NO_STACK;\n-    push_jump_merge (PC, current_state);\n+    // at this point PC points to the instruction after the jsr.  Note\n+    // that it is ok to have a `jsr' at the end of the bytecode,\n+    // provided that the called subroutine never returns.  So, we have\n+    // a special case here and another one when we handle the ret.\n+    if (PC < current_method->code_length)\n+      {\n+\tcurrent_state->stacktop = state::NO_STACK;\n+\tpush_jump_merge (PC, current_state);\n+      }\n     invalidate_pc ();\n   }\n "}]}