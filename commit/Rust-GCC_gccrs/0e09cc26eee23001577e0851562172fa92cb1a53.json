{"sha": "0e09cc26eee23001577e0851562172fa92cb1a53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUwOWNjMjZlZWUyMzAwMTU3N2UwODUxNTYyMTcyZmE5MmNiMWE1Mw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-06-08T17:49:13Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-06-08T17:49:13Z"}, "message": "(fixup_var_refs_1, case SIGN_EXTEND): Handle paradoxical SUBREGs as first operand.\n\n(fixup_var_refs_1, case SIGN_EXTEND): Handle paradoxical SUBREGs as first\noperand.\n(fixup_var_regs_1, case SET): Handle paradoxical SUBREGs as first operand of\na ZERO_EXTRACT in SET_DEST.\n\nFrom-SVN: r12243", "tree": {"sha": "479cd63556d7ce770fccffb8e5dd5e186d9e50d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/479cd63556d7ce770fccffb8e5dd5e186d9e50d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e09cc26eee23001577e0851562172fa92cb1a53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e09cc26eee23001577e0851562172fa92cb1a53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e09cc26eee23001577e0851562172fa92cb1a53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e09cc26eee23001577e0851562172fa92cb1a53/comments", "author": null, "committer": null, "parents": [{"sha": "d5a1d1c7584b6b0adb0ba959b61e54693b96bd3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5a1d1c7584b6b0adb0ba959b61e54693b96bd3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5a1d1c7584b6b0adb0ba959b61e54693b96bd3e"}], "stats": {"total": 36, "additions": 32, "deletions": 4}, "files": [{"sha": "27a01c1aea531c491095469896a01ac16a889518", "filename": "gcc/function.c", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e09cc26eee23001577e0851562172fa92cb1a53/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e09cc26eee23001577e0851562172fa92cb1a53/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=0e09cc26eee23001577e0851562172fa92cb1a53", "patch": "@@ -1755,8 +1755,20 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \n \t  tem = XEXP (x, 0);\n \t  if (GET_CODE (tem) == SUBREG)\n-\t    tem = fixup_memory_subreg (tem, insn, 1);\n-\t  tem = fixup_stack_1 (tem, insn);\n+\t    {\n+\t      if (GET_MODE_BITSIZE (GET_MODE (tem))\n+\t\t  > GET_MODE_BITSIZE (GET_MODE (var)))\n+\t\t{\n+\t\t  replacement = find_fixup_replacement (replacements, var);\n+\t\t  if (replacement->new == 0)\n+\t\t    replacement->new = gen_reg_rtx (GET_MODE (var));\n+\t\t  SUBREG_REG (tem) = replacement->new;\n+\t\t}\n+\n+\t      tem = fixup_memory_subreg (tem, insn, 0);\n+\t    }\n+\t  else\n+\t    tem = fixup_stack_1 (tem, insn);\n \n \t  /* Unless we want to load from memory, get TEM into the proper mode\n \t     for an extract from memory.  This can only be done if the\n@@ -1885,6 +1897,22 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t  || GET_CODE (SET_SRC (x)) == ZERO_EXTRACT)\n \toptimize_bit_field (x, insn, NULL_PTR);\n \n+      /* For a paradoxical SUBREG inside a ZERO_EXTRACT, load the object\n+\t into a register and then store it back out.  */\n+      if (GET_CODE (SET_DEST (x)) == ZERO_EXTRACT\n+\t  && GET_CODE (XEXP (SET_DEST (x), 0)) == SUBREG\n+\t  && SUBREG_REG (XEXP (SET_DEST (x), 0)) == var\n+\t  && (GET_MODE_SIZE (GET_MODE (XEXP (SET_DEST (x), 0)))\n+\t      > GET_MODE_SIZE (GET_MODE (var))))\n+\t{\n+\t  replacement = find_fixup_replacement (replacements, var);\n+\t  if (replacement->new == 0)\n+\t    replacement->new = gen_reg_rtx (GET_MODE (var));\n+\n+\t  SUBREG_REG (XEXP (SET_DEST (x), 0)) = replacement->new;\n+\t  emit_insn_after (gen_move_insn (var, replacement->new), insn);\n+\t}\n+\n       /* If SET_DEST is now a paradoxical SUBREG, put the result of this\n \t insn into a pseudo and store the low part of the pseudo into VAR. */\n       if (GET_CODE (SET_DEST (x)) == SUBREG\n@@ -1940,7 +1968,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t       This was legitimate when the MEM was a REG.  */\n \t    if (GET_CODE (tem) == SUBREG\n \t\t&& SUBREG_REG (tem) == var)\n-\t      tem = fixup_memory_subreg (tem, insn, 1);\n+\t      tem = fixup_memory_subreg (tem, insn, 0);\n \t    else\n \t      tem = fixup_stack_1 (tem, insn);\n \n@@ -2158,7 +2186,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n    If any insns must be emitted to compute NEWADDR, put them before INSN.\n \n    UNCRITICAL nonzero means accept paradoxical subregs.\n-   This is used for subregs found inside of ZERO_EXTRACTs and in REG_NOTES. */\n+   This is used for subregs found inside REG_NOTES. */\n \n static rtx\n fixup_memory_subreg (x, insn, uncritical)"}]}