{"sha": "a75f501709fc1562a96064688ca925d48562f131", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc1ZjUwMTcwOWZjMTU2MmE5NjA2NDY4OGNhOTI1ZDQ4NTYyZjEzMQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-06-20T12:00:20Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-06-20T12:00:20Z"}, "message": "re PR tree-optimization/30318 (VRP does not create ANTI_RANGEs on overflow)\n\n2012-06-20  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/30318\n\t* tree-vrp.c (range_int_cst_p): Do not reject overflowed\n\tconstants here.\n\t(range_int_cst_singleton_p): But explicitely here.\n\t(zero_nonzero_bits_from_vr): And here.\n\t(extract_range_from_binary_expr_1): Re-implement PLUS_EXPR\n\tto cover all cases we can perform arbitrary precision\n\tarithmetic with double-ints.\n\t(intersect_ranges): Handle adjacent anti-ranges.\n\n\t* gcc.dg/tree-ssa/vrp69.c: New testcase.\n\nFrom-SVN: r188827", "tree": {"sha": "ae891f75a04882bf1c2ff53acc70ff8098a7b83d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae891f75a04882bf1c2ff53acc70ff8098a7b83d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a75f501709fc1562a96064688ca925d48562f131", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a75f501709fc1562a96064688ca925d48562f131", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a75f501709fc1562a96064688ca925d48562f131", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a75f501709fc1562a96064688ca925d48562f131/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "942ee091499bdbd14e70b501038e739ebb48980b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/942ee091499bdbd14e70b501038e739ebb48980b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/942ee091499bdbd14e70b501038e739ebb48980b"}], "stats": {"total": 263, "additions": 227, "deletions": 36}, "files": [{"sha": "ebcdf5a9664d267cfe9c22a5d012b3bf2272fbd7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a75f501709fc1562a96064688ca925d48562f131/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a75f501709fc1562a96064688ca925d48562f131/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a75f501709fc1562a96064688ca925d48562f131", "patch": "@@ -1,3 +1,15 @@\n+2012-06-20  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/30318\n+\t* tree-vrp.c (range_int_cst_p): Do not reject overflowed\n+\tconstants here.\n+\t(range_int_cst_singleton_p): But explicitely here.\n+\t(zero_nonzero_bits_from_vr): And here.\n+\t(extract_range_from_binary_expr_1): Re-implement PLUS_EXPR\n+\tto cover all cases we can perform arbitrary precision\n+\tarithmetic with double-ints.\n+\t(intersect_ranges): Handle adjacent anti-ranges.\n+\n 2012-06-20  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (rounding_insn): New int attribute."}, {"sha": "60b08280c0419186365496b0a81e59c258dd81f2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a75f501709fc1562a96064688ca925d48562f131/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a75f501709fc1562a96064688ca925d48562f131/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a75f501709fc1562a96064688ca925d48562f131", "patch": "@@ -1,3 +1,8 @@\n+2012-06-20  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/30318\n+\t* gcc.dg/tree-ssa/vrp69.c: New testcase.\n+\n 2012-06-20  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* g++.dg/debug/dwarf2/nested-3.C: Add ARM comment character to regexp."}, {"sha": "d7540c9e2f9226a1e9fba41e2d3691494216b946", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp69.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a75f501709fc1562a96064688ca925d48562f131/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp69.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a75f501709fc1562a96064688ca925d48562f131/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp69.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp69.c?ref=a75f501709fc1562a96064688ca925d48562f131", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do link } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+\n+#include \"vrp.h\"\n+\n+void test1(int i, int j)\n+{\n+  RANGE(i, 1, 5);\n+  RANGE(j, 7, 10);\n+  CHECK_RANGE(i + j, 8, 15);\n+}\n+\n+#define UINT_MAX 2*(unsigned)__INT_MAX__ + 1\n+void test2(unsigned int i)\n+{\n+  RANGE(i, UINT_MAX - 0x4, UINT_MAX - 0x1);\n+  CHECK_ANTI_RANGE(i + 0x2, 0x1, UINT_MAX - 0x3);\n+}\n+void test3(unsigned int i)\n+{\n+  RANGE(i, UINT_MAX - 0x4, UINT_MAX - 0x1);\n+  CHECK_RANGE(i + 0x5, 0x0, 0x3);\n+}\n+void test4(unsigned int i)\n+{\n+  RANGE(i, 2, 4);\n+  CHECK_ANTI_RANGE(i - 4, 1, UINT_MAX - 2);\n+}\n+void test5(unsigned int i)\n+{\n+  RANGE(i, 2, 4);\n+  CHECK_RANGE(i - 8, UINT_MAX - 5, UINT_MAX - 3);\n+}\n+\n+int main() {}\n+\n+/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "32c5afa49c7254ef1d72a35d4a137d213f95c5d1", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 172, "deletions": 36, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a75f501709fc1562a96064688ca925d48562f131/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a75f501709fc1562a96064688ca925d48562f131/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=a75f501709fc1562a96064688ca925d48562f131", "patch": "@@ -844,9 +844,7 @@ range_int_cst_p (value_range_t *vr)\n {\n   return (vr->type == VR_RANGE\n \t  && TREE_CODE (vr->max) == INTEGER_CST\n-\t  && TREE_CODE (vr->min) == INTEGER_CST\n-\t  && !TREE_OVERFLOW (vr->max)\n-\t  && !TREE_OVERFLOW (vr->min));\n+\t  && TREE_CODE (vr->min) == INTEGER_CST);\n }\n \n /* Return true if VR is a INTEGER_CST singleton.  */\n@@ -855,6 +853,8 @@ static inline bool\n range_int_cst_singleton_p (value_range_t *vr)\n {\n   return (range_int_cst_p (vr)\n+\t  && !TREE_OVERFLOW (vr->min)\n+\t  && !TREE_OVERFLOW (vr->max)\n \t  && tree_int_cst_equal (vr->min, vr->max));\n }\n \n@@ -1970,7 +1970,9 @@ zero_nonzero_bits_from_vr (value_range_t *vr,\n {\n   *may_be_nonzero = double_int_minus_one;\n   *must_be_nonzero = double_int_zero;\n-  if (!range_int_cst_p (vr))\n+  if (!range_int_cst_p (vr)\n+      || TREE_OVERFLOW (vr->min)\n+      || TREE_OVERFLOW (vr->max))\n     return false;\n \n   if (range_int_cst_singleton_p (vr))\n@@ -2376,39 +2378,161 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n      range and see what we end up with.  */\n   if (code == PLUS_EXPR)\n     {\n-      /* If we have a PLUS_EXPR with two VR_ANTI_RANGEs, drop to\n-\t VR_VARYING.  It would take more effort to compute a precise\n-\t range for such a case.  For example, if we have op0 == 1 and\n-\t op1 == -1 with their ranges both being ~[0,0], we would have\n-\t op0 + op1 == 0, so we cannot claim that the sum is in ~[0,0].\n-\t Note that we are guaranteed to have vr0.type == vr1.type at\n-\t this point.  */\n-      if (vr0.type == VR_ANTI_RANGE)\n+      /* If we have a PLUS_EXPR with two VR_RANGE integer constant\n+         ranges compute the precise range for such case if possible.  */\n+      if (range_int_cst_p (&vr0)\n+\t  && range_int_cst_p (&vr1)\n+\t  /* We attempt to do infinite precision signed integer arithmetic,\n+\t     thus we need two more bits than the possibly unsigned inputs.  */\n+\t  && TYPE_PRECISION (expr_type) < HOST_BITS_PER_DOUBLE_INT - 1)\n+\t{\n+\t  double_int min0 = tree_to_double_int (vr0.min);\n+\t  double_int max0 = tree_to_double_int (vr0.max);\n+\t  double_int min1 = tree_to_double_int (vr1.min);\n+\t  double_int max1 = tree_to_double_int (vr1.max);\n+\t  bool uns = TYPE_UNSIGNED (expr_type);\n+\t  double_int type_min\n+\t    = double_int_min_value (TYPE_PRECISION (expr_type), uns);\n+\t  double_int type_max\n+\t    = double_int_max_value (TYPE_PRECISION (expr_type), uns);\n+\t  double_int dmin, dmax;\n+\n+\t  dmin = double_int_add (min0, min1);\n+\t  dmax = double_int_add (max0, max1);\n+\n+\t  if (TYPE_OVERFLOW_WRAPS (expr_type))\n+\t    {\n+\t      /* If overflow wraps, truncate the values and adjust the\n+\t\t range kind and bounds appropriately.  */\n+\t      double_int tmin\n+\t\t= double_int_ext (dmin, TYPE_PRECISION (expr_type), uns);\n+\t      double_int tmax\n+\t\t= double_int_ext (dmax, TYPE_PRECISION (expr_type), uns);\n+\t      gcc_assert (double_int_scmp (dmin, dmax) <= 0);\n+\t      if ((double_int_scmp (dmin, type_min) == -1\n+\t\t   && double_int_scmp (dmax, type_min) == -1)\n+\t\t  || (double_int_scmp (dmin, type_max) == 1\n+\t\t      && double_int_scmp (dmax, type_max) == 1)\n+\t\t  || (double_int_scmp (type_min, dmin) <= 0\n+\t\t      && double_int_scmp (dmax, type_max) <= 0))\n+\t\t{\n+\t\t  /* No overflow or both overflow or underflow.  The\n+\t\t     range kind stays VR_RANGE.  */\n+\t\t  min = double_int_to_tree (expr_type, tmin);\n+\t\t  max = double_int_to_tree (expr_type, tmax);\n+\t\t}\n+\t      else if (double_int_scmp (dmin, type_min) == -1\n+\t\t       && double_int_scmp (dmax, type_max) == 1)\n+\t\t{\n+\t\t  /* Underflow and overflow, drop to VR_VARYING.  */\n+\t\t  set_value_range_to_varying (vr);\n+\t\t  return;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Min underflow or max overflow.  The range kind\n+\t\t     changes to VR_ANTI_RANGE.  */\n+\t\t  double_int tem = tmin;\n+\t\t  gcc_assert ((double_int_scmp (dmin, type_min) == -1\n+\t\t\t       && double_int_scmp (dmax, type_min) >= 0\n+\t\t\t       && double_int_scmp (dmax, type_max) <= 0)\n+\t\t\t      || (double_int_scmp (dmax, type_max) == 1\n+\t\t\t\t  && double_int_scmp (dmin, type_min) >= 0\n+\t\t\t\t  && double_int_scmp (dmin, type_max) <= 0));\n+\t\t  type = VR_ANTI_RANGE;\n+\t\t  tmin = double_int_add (tmax, double_int_one);\n+\t\t  tmax = double_int_add (tem, double_int_minus_one);\n+\t\t  /* If the anti-range would cover nothing, drop to varying.\n+\t\t     Likewise if the anti-range bounds are outside of the\n+\t\t     types values.  */\n+\t\t  if (double_int_cmp (tmin, tmax, uns) > 0\n+\t\t      || double_int_cmp (tmin, type_min, uns) < 0\n+\t\t      || double_int_cmp (tmax, type_max, uns) > 0)\n+\t\t    {\n+\t\t      set_value_range_to_varying (vr);\n+\t\t      return;\n+\t\t    }\n+\t\t  min = double_int_to_tree (expr_type, tmin);\n+\t\t  max = double_int_to_tree (expr_type, tmax);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* For non-wrapping arithmetic look at possibly smaller\n+\t\t value-ranges of the type.  */\n+\t      if (vrp_val_min (expr_type))\n+\t\ttype_min = tree_to_double_int (vrp_val_min (expr_type));\n+\t      if (vrp_val_max (expr_type))\n+\t\ttype_max = tree_to_double_int (vrp_val_max (expr_type));\n+\n+\t      /* If overflow does not wrap, saturate to the types min/max\n+\t         value.  */\n+\t      if (double_int_scmp (dmin, type_min) == -1)\n+\t\t{\n+\t\t  if (needs_overflow_infinity (expr_type)\n+\t\t      && supports_overflow_infinity (expr_type))\n+\t\t    min = negative_overflow_infinity (expr_type);\n+\t\t  else\n+\t\t    min = double_int_to_tree (expr_type, type_min);\n+\t\t}\n+\t      else if (double_int_scmp (dmin, type_max) == 1)\n+\t\t{\n+\t\t  if (needs_overflow_infinity (expr_type)\n+\t\t      && supports_overflow_infinity (expr_type))\n+\t\t    min = positive_overflow_infinity (expr_type);\n+\t\t  else\n+\t\t    min = double_int_to_tree (expr_type, type_max);\n+\t\t}\n+\t      else\n+\t\tmin = double_int_to_tree (expr_type, dmin);\n+\n+\t      if (double_int_scmp (dmax, type_min) == -1)\n+\t\t{\n+\t\t  if (needs_overflow_infinity (expr_type)\n+\t\t      && supports_overflow_infinity (expr_type))\n+\t\t    max = negative_overflow_infinity (expr_type);\n+\t\t  else\n+\t\t    max = double_int_to_tree (expr_type, type_min);\n+\t\t}\n+\t      else if (double_int_scmp (dmax, type_max) == 1)\n+\t\t{\n+\t\t  if (needs_overflow_infinity (expr_type)\n+\t\t      && supports_overflow_infinity (expr_type))\n+\t\t    max = positive_overflow_infinity (expr_type);\n+\t\t  else\n+\t\t    max = double_int_to_tree (expr_type, type_max);\n+\t\t}\n+\t      else\n+\t\tmax = double_int_to_tree (expr_type, dmax);\n+\t    }\n+\t  if (needs_overflow_infinity (expr_type)\n+\t      && supports_overflow_infinity (expr_type))\n+\t    {\n+\t      if (is_negative_overflow_infinity (vr0.min)\n+\t\t  || is_negative_overflow_infinity (vr1.min))\n+\t\tmin = negative_overflow_infinity (expr_type);\n+\t      if (is_positive_overflow_infinity (vr0.max)\n+\t\t  || is_positive_overflow_infinity (vr1.max))\n+\t\tmax = positive_overflow_infinity (expr_type);\n+\t    }\n+\t}\n+      else\n \t{\n+\t  /* For other cases, for example if we have a PLUS_EXPR with two\n+\t     VR_ANTI_RANGEs, drop to VR_VARYING.  It would take more effort\n+\t     to compute a precise range for such a case.\n+\t     ???  General even mixed range kind operations can be expressed\n+\t     by for example transforming ~[3, 5] + [1, 2] to range-only\n+\t     operations and a union primitive:\n+\t       [-INF, 2] + [1, 2]  U  [5, +INF] + [1, 2]\n+\t           [-INF+1, 4]     U    [6, +INF(OVF)]\n+\t     though usually the union is not exactly representable with\n+\t     a single range or anti-range as the above is\n+\t\t [-INF+1, +INF(OVF)] intersected with ~[5, 5]\n+\t     but one could use a scheme similar to equivalences for this. */\n \t  set_value_range_to_varying (vr);\n \t  return;\n \t}\n-\n-      /* For operations that make the resulting range directly\n-\t proportional to the original ranges, apply the operation to\n-\t the same end of each range.  */\n-      min = vrp_int_const_binop (code, vr0.min, vr1.min);\n-      max = vrp_int_const_binop (code, vr0.max, vr1.max);\n-\n-      /* If both additions overflowed the range kind is still correct.\n-\t This happens regularly with subtracting something in unsigned\n-\t arithmetic.\n-         ???  See PR30318 for all the cases we do not handle.  */\n-      if ((TREE_OVERFLOW (min) && !is_overflow_infinity (min))\n-\t  && (TREE_OVERFLOW (max) && !is_overflow_infinity (max)))\n-\t{\n-\t  min = build_int_cst_wide (TREE_TYPE (min),\n-\t\t\t\t    TREE_INT_CST_LOW (min),\n-\t\t\t\t    TREE_INT_CST_HIGH (min));\n-\t  max = build_int_cst_wide (TREE_TYPE (max),\n-\t\t\t\t    TREE_INT_CST_LOW (max),\n-\t\t\t\t    TREE_INT_CST_HIGH (max));\n-\t}\n     }\n   else if (code == MIN_EXPR\n \t   || code == MAX_EXPR)\n@@ -7067,8 +7191,7 @@ intersect_ranges (enum value_range_type *vr0type,\n       /* [ ] ( ) or ( ) [ ]\n \t If the ranges have an empty intersection, the result of the\n \t intersect operation is the range for intersecting an\n-\t anti-range with a range or empty when intersecting two ranges.\n-\t For intersecting two anti-ranges simply choose vr0.  */\n+\t anti-range with a range or empty when intersecting two ranges.  */\n       if (*vr0type == VR_RANGE\n \t  && vr1type == VR_ANTI_RANGE)\n \t;\n@@ -7089,7 +7212,20 @@ intersect_ranges (enum value_range_type *vr0type,\n       else if (*vr0type == VR_ANTI_RANGE\n \t       && vr1type == VR_ANTI_RANGE)\n \t{\n-\t  /* Take VR0.  */\n+\t  /* If the anti-ranges are adjacent to each other merge them.  */\n+\t  if (TREE_CODE (*vr0max) == INTEGER_CST\n+\t      && TREE_CODE (vr1min) == INTEGER_CST\n+\t      && operand_less_p (*vr0max, vr1min) == 1\n+\t      && integer_onep (int_const_binop (MINUS_EXPR,\n+\t\t\t\t\t\tvr1min, *vr0max)))\n+\t    *vr0max = vr1max;\n+\t  else if (TREE_CODE (vr1max) == INTEGER_CST\n+\t\t   && TREE_CODE (*vr0min) == INTEGER_CST\n+\t\t   && operand_less_p (vr1max, *vr0min) == 1\n+\t\t   && integer_onep (int_const_binop (MINUS_EXPR,\n+\t\t\t\t\t\t     *vr0min, vr1max)))\n+\t    *vr0min = vr1min;\n+\t  /* Else arbitrarily take VR0.  */\n \t}\n     }\n   else if ((maxeq || operand_less_p (vr1max, *vr0max) == 1)"}]}