{"sha": "e0d321856b3415542f2f13a49e68f1926a71feb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBkMzIxODU2YjM0MTU1NDJmMmYxM2E0OWU2OGYxOTI2YTcxZmViMw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-07-28T21:02:06Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-07-28T21:02:06Z"}, "message": "rs6000-protos.h (rs6000_split_vec_extract_var): New declaration.\n\n[gcc]\n2016-07-28  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000-protos.h (rs6000_split_vec_extract_var):\n\tNew declaration.\n\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):\n\tAdd support for vec_extract of vector double or vector long having\n\ta variable element number on 64-bit ISA 2.07 systems or newer.\n\t* config/rs6000/rs6000.c (rs6000_expand_vector_extract):\n\tLikewise.\n\t(rs6000_split_vec_extract_var): New function to split a\n\tvec_extract built-in function with variable element number.\n\t(rtx_is_swappable_p): Variable vec_extracts and shifts are not\n\tswappable.\n\t* config/rs6000/vsx.md (UNSPEC_VSX_VSLO): New unspec.\n\t(UNSPEC_VSX_EXTRACT): Likewise.\n\t(vsx_extract_<mode>, VSX_D iterator): Fix constraints to allow\n\tdirect move instructions to be generated on 64-bit ISA 2.07\n\tsystems and newer, and to take advantage of the ISA 3.0 MFVSRLD\n\tinstruction.\n\t(vsx_vslo_<mode>): New insn to do VSLO on V2DFmode and V2DImode\n\targuments for vec_extract variable element.\n\t(vsx_extract_<mode>_var, VSX_D iterator): New insn to support\n\tvec_extract with variable element on V2DFmode and V2DImode\n\tvectors.\n\t* config/rs6000/rs6000.h (TARGET_VEXTRACTUB): Remove\n\t-mupper-regs-df requirement, since it isn't needed.\n\t(TARGET_DIRECT_MOVE_64BIT): New macro to say whether we can\n\tdo direct moves on 64-bit systems, which allows optimization of\n\tvec_extract on 64-bit ISA 2.07 systems and newer.\n\n[gcc/testsuite]\n2016-07-28  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/vec-extract-1.c: New test.\n\nFrom-SVN: r238838", "tree": {"sha": "9f3ec03c90e2cdf5132f804278fcdbcf1dc11be9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f3ec03c90e2cdf5132f804278fcdbcf1dc11be9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0d321856b3415542f2f13a49e68f1926a71feb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0d321856b3415542f2f13a49e68f1926a71feb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0d321856b3415542f2f13a49e68f1926a71feb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0d321856b3415542f2f13a49e68f1926a71feb3/comments", "author": null, "committer": null, "parents": [{"sha": "1a2196e484a1b039c07f9afce090e9beb9dac62b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a2196e484a1b039c07f9afce090e9beb9dac62b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a2196e484a1b039c07f9afce090e9beb9dac62b"}], "stats": {"total": 293, "additions": 269, "deletions": 24}, "files": [{"sha": "e51cc011e53e4d395d5ba34774f00872593b5dde", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d321856b3415542f2f13a49e68f1926a71feb3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d321856b3415542f2f13a49e68f1926a71feb3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0d321856b3415542f2f13a49e68f1926a71feb3", "patch": "@@ -1,3 +1,33 @@\n+2016-07-28  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000-protos.h (rs6000_split_vec_extract_var):\n+\tNew declaration.\n+\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):\n+\tAdd support for vec_extract of vector double or vector long having\n+\ta variable element number on 64-bit ISA 2.07 systems or newer.\n+\t* config/rs6000/rs6000.c (rs6000_expand_vector_extract):\n+\tLikewise.\n+\t(rs6000_split_vec_extract_var): New function to split a\n+\tvec_extract built-in function with variable element number.\n+\t(rtx_is_swappable_p): Variable vec_extracts and shifts are not\n+\tswappable.\n+\t* config/rs6000/vsx.md (UNSPEC_VSX_VSLO): New unspec.\n+\t(UNSPEC_VSX_EXTRACT): Likewise.\n+\t(vsx_extract_<mode>, VSX_D iterator): Fix constraints to allow\n+\tdirect move instructions to be generated on 64-bit ISA 2.07\n+\tsystems and newer, and to take advantage of the ISA 3.0 MFVSRLD\n+\tinstruction.\n+\t(vsx_vslo_<mode>): New insn to do VSLO on V2DFmode and V2DImode\n+\targuments for vec_extract variable element.\n+\t(vsx_extract_<mode>_var, VSX_D iterator): New insn to support\n+\tvec_extract with variable element on V2DFmode and V2DImode\n+\tvectors.\n+\t* config/rs6000/rs6000.h (TARGET_VEXTRACTUB): Remove\n+\t-mupper-regs-df requirement, since it isn't needed.\n+\t(TARGET_DIRECT_MOVE_64BIT): New macro to say whether we can\n+\tdo direct moves on 64-bit systems, which allows optimization of\n+\tvec_extract on 64-bit ISA 2.07 systems and newer.\n+\n 2016-07-28  Kristina Martsenko  <kristina.martsenko@arm.com>\n 2016-07-28  Wilco Dijkstra  <wdijkstr@arm.com>\n "}, {"sha": "2a60262f034a24482e86f4fbaa27fa69abba937c", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 47, "deletions": 15, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d321856b3415542f2f13a49e68f1926a71feb3/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d321856b3415542f2f13a49e68f1926a71feb3/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=e0d321856b3415542f2f13a49e68f1926a71feb3", "patch": "@@ -5105,29 +5105,61 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t\t\t\t  arg2);\n \t}\n \n-      /* If we can use the VSX xxpermdi instruction, use that for extract.  */\n+      /* See if we can optimize vec_extracts with the current VSX instruction\n+\t set.  */\n       mode = TYPE_MODE (arg1_type);\n-      if ((mode == V2DFmode || mode == V2DImode) && VECTOR_MEM_VSX_P (mode)\n-\t  && TREE_CODE (arg2) == INTEGER_CST\n-\t  && wi::ltu_p (arg2, 2))\n+      if (VECTOR_MEM_VSX_P (mode))\n+\n \t{\n \t  tree call = NULL_TREE;\n+\t  int nunits = GET_MODE_NUNITS (mode);\n \n-\t  if (mode == V2DFmode)\n-\t    call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V2DF];\n-\t  else if (mode == V2DImode)\n-\t    call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V2DI];\n+\t  /* If the second argument is an integer constant, if the value is in\n+\t     the expected range, generate the built-in code if we can.  We need\n+\t     64-bit and direct move to extract the small integer vectors.  */\n+\t  if (TREE_CODE (arg2) == INTEGER_CST && wi::ltu_p (arg2, nunits))\n+\t    {\n+\t      switch (mode)\n+\t\t{\n+\t\tdefault:\n+\t\t  break;\n+\n+\t\tcase V1TImode:\n+\t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V1TI];\n+\t\t  break;\n+\n+\t\tcase V2DFmode:\n+\t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V2DF];\n+\t\t  break;\n+\n+\t\tcase V2DImode:\n+\t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V2DI];\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  /* If the second argument is variable, we can optimize it if we are\n+\t     generating 64-bit code on a machine with direct move.  */\n+\t  else if (TREE_CODE (arg2) != INTEGER_CST && TARGET_DIRECT_MOVE_64BIT)\n+\t    {\n+\t      switch (mode)\n+\t\t{\n+\t\tdefault:\n+\t\t  break;\n+\n+\t\tcase V2DFmode:\n+\t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V2DF];\n+\t\t  break;\n+\n+\t\tcase V2DImode:\n+\t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V2DI];\n+\t\t  break;\n+\t\t}\n+\t    }\n \n \t  if (call)\n \t    return build_call_expr (call, 2, arg1, arg2);\n \t}\n-      else if (mode == V1TImode && VECTOR_MEM_VSX_P (mode)\n-\t       && TREE_CODE (arg2) == INTEGER_CST\n-\t       && wi::eq_p (arg2, 0))\n-\t{\n-\t  tree call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V1TI];\n-\t  return build_call_expr (call, 2, arg1, arg2);\n-\t}\n \n       /* Build *(((arg1_inner_type*)&(vector type){arg1})+arg2). */\n       arg1_inner_type = TREE_TYPE (arg1_type);"}, {"sha": "fdf5c6885a7de20162adf1e69fad3199886cfee8", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d321856b3415542f2f13a49e68f1926a71feb3/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d321856b3415542f2f13a49e68f1926a71feb3/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=e0d321856b3415542f2f13a49e68f1926a71feb3", "patch": "@@ -62,6 +62,7 @@ extern void rs6000_expand_vector_init (rtx, rtx);\n extern void paired_expand_vector_init (rtx, rtx);\n extern void rs6000_expand_vector_set (rtx, rtx, int);\n extern void rs6000_expand_vector_extract (rtx, rtx, rtx);\n+extern void rs6000_split_vec_extract_var (rtx, rtx, rtx, rtx, rtx);\n extern bool altivec_expand_vec_perm_const (rtx op[4]);\n extern void altivec_expand_vec_perm_le (rtx op[4]);\n extern bool rs6000_expand_vec_perm_const (rtx op[4]);"}, {"sha": "e9447f7a8b9b1831909ad10aa2eb73b262e55d80", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 119, "deletions": 2, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d321856b3415542f2f13a49e68f1926a71feb3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d321856b3415542f2f13a49e68f1926a71feb3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e0d321856b3415542f2f13a49e68f1926a71feb3", "patch": "@@ -6959,8 +6959,31 @@ rs6000_expand_vector_extract (rtx target, rtx vec, rtx elt)\n \t      emit_insn (gen_vsx_extract_v4si (target, vec, elt));\n \t      return;\n \t    }\n-\t  else\n-\t    break;\n+\t  break;\n+\t}\n+    }\n+  else if (VECTOR_MEM_VSX_P (mode) && !CONST_INT_P (elt)\n+\t   && TARGET_DIRECT_MOVE_64BIT)\n+    {\n+      if (GET_MODE (elt) != DImode)\n+\t{\n+\t  rtx tmp = gen_reg_rtx (DImode);\n+\t  convert_move (tmp, elt, 0);\n+\t  elt = tmp;\n+\t}\n+\n+      switch (mode)\n+\t{\n+\tcase V2DFmode:\n+\t  emit_insn (gen_vsx_extract_v2df_var (target, vec, elt));\n+\t  return;\n+\n+\tcase V2DImode:\n+\t  emit_insn (gen_vsx_extract_v2di_var (target, vec, elt));\n+\t  return;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -6978,6 +7001,99 @@ rs6000_expand_vector_extract (rtx target, rtx vec, rtx elt)\n   emit_move_insn (target, adjust_address_nv (mem, inner_mode, 0));\n }\n \n+/* Split a variable vec_extract operation into the component instructions.  */\n+\n+void\n+rs6000_split_vec_extract_var (rtx dest, rtx src, rtx element, rtx tmp_gpr,\n+\t\t\t      rtx tmp_altivec)\n+{\n+  machine_mode mode = GET_MODE (src);\n+  machine_mode scalar_mode = GET_MODE (dest);\n+  unsigned scalar_size = GET_MODE_SIZE (scalar_mode);\n+  int byte_shift = exact_log2 (scalar_size);\n+\n+  gcc_assert (byte_shift >= 0);\n+\n+  if (REG_P (src) || SUBREG_P (src))\n+    {\n+      int bit_shift = byte_shift + 3;\n+      rtx element2;\n+\n+      gcc_assert (REG_P (tmp_gpr) && REG_P (tmp_altivec));\n+\n+      /* For little endian, adjust element ordering.  For V2DI/V2DF, we can use\n+\t an XOR, otherwise we need to subtract.  The shift amount is so VSLO\n+\t will shift the element into the upper position (adding 3 to convert a\n+\t byte shift into a bit shift).  */\n+      if (scalar_size == 8)\n+\t{\n+\t  if (!VECTOR_ELT_ORDER_BIG)\n+\t    {\n+\t      emit_insn (gen_xordi3 (tmp_gpr, element, const1_rtx));\n+\t      element2 = tmp_gpr;\n+\t    }\n+\t  else\n+\t    element2 = element;\n+\n+\t  /* Generate RLDIC directly to shift left 6 bits and retrieve 1\n+\t     bit.  */\n+\t  emit_insn (gen_rtx_SET (tmp_gpr,\n+\t\t\t\t  gen_rtx_AND (DImode,\n+\t\t\t\t\t       gen_rtx_ASHIFT (DImode,\n+\t\t\t\t\t\t\t       element2,\n+\t\t\t\t\t\t\t       GEN_INT (6)),\n+\t\t\t\t\t       GEN_INT (64))));\n+\t}\n+      else\n+\t{\n+\t  if (!VECTOR_ELT_ORDER_BIG)\n+\t    {\n+\t      rtx num_ele_m1 = GEN_INT (GET_MODE_NUNITS (mode) - 1);\n+\n+\t      emit_insn (gen_anddi3 (tmp_gpr, element, num_ele_m1));\n+\t      emit_insn (gen_subdi3 (tmp_gpr, num_ele_m1, tmp_gpr));\n+\t      element2 = tmp_gpr;\n+\t    }\n+\t  else\n+\t    element2 = element;\n+\n+\t  emit_insn (gen_ashldi3 (tmp_gpr, element2, GEN_INT (bit_shift)));\n+\t}\n+\n+      /* Get the value into the lower byte of the Altivec register where VSLO\n+\t expects it.  */\n+      if (TARGET_P9_VECTOR)\n+\temit_insn (gen_vsx_splat_v2di (tmp_altivec, tmp_gpr));\n+      else if (can_create_pseudo_p ())\n+\temit_insn (gen_vsx_concat_v2di (tmp_altivec, tmp_gpr, tmp_gpr));\n+      else\n+\t{\n+\t  rtx tmp_di = gen_rtx_REG (DImode, REGNO (tmp_altivec));\n+\t  emit_move_insn (tmp_di, tmp_gpr);\n+\t  emit_insn (gen_vsx_concat_v2di (tmp_altivec, tmp_di, tmp_di));\n+\t}\n+\n+      /* Do the VSLO to get the value into the final location.  */\n+      switch (mode)\n+\t{\n+\tcase V2DFmode:\n+\t  emit_insn (gen_vsx_vslo_v2df (dest, src, tmp_altivec));\n+\t  return;\n+\n+\tcase V2DImode:\n+\t  emit_insn (gen_vsx_vslo_v2di (dest, src, tmp_altivec));\n+\t  return;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      return;\n+    }\n+  else\n+    gcc_unreachable ();\n+ }\n+\n /* Return TRUE if OP is an invalid SUBREG operation on the e500.  */\n \n bool\n@@ -38640,6 +38756,7 @@ rtx_is_swappable_p (rtx op, unsigned int *special)\n \t  case UNSPEC_VSX_CVDPSPN:\n \t  case UNSPEC_VSX_CVSPDP:\n \t  case UNSPEC_VSX_CVSPDPN:\n+\t  case UNSPEC_VSX_EXTRACT:\n \t    return 0;\n \t  case UNSPEC_VSPLT_DIRECT:\n \t    *special = SH_SPLAT;"}, {"sha": "9b3e83bcd30db83c2ec7c67c1b5f7cbcf37d5932", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d321856b3415542f2f13a49e68f1926a71feb3/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d321856b3415542f2f13a49e68f1926a71feb3/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=e0d321856b3415542f2f13a49e68f1926a71feb3", "patch": "@@ -602,7 +602,6 @@ extern int rs6000_vector_align[];\n #define TARGET_DIRECT_MOVE_128\t(TARGET_P9_VECTOR && TARGET_DIRECT_MOVE \\\n \t\t\t\t && TARGET_POWERPC64)\n #define TARGET_VEXTRACTUB\t(TARGET_P9_VECTOR && TARGET_DIRECT_MOVE \\\n-\t\t\t\t && TARGET_UPPER_REGS_DF \\\n \t\t\t\t && TARGET_UPPER_REGS_DI && TARGET_POWERPC64)\n \n /* Byte/char syncs were added as phased in for ISA 2.06B, but are not present\n@@ -761,6 +760,14 @@ extern int rs6000_vector_align[];\n \t\t\t\t && TARGET_SINGLE_FLOAT\t\t\t\\\n \t\t\t\t && TARGET_DOUBLE_FLOAT)\n \n+/* Macro to say whether we can do optimization where we need to do parts of the\n+   calculation in 64-bit GPRs and then is transfered to the vector\n+   registers.  */\n+#define TARGET_DIRECT_MOVE_64BIT\t(TARGET_DIRECT_MOVE\t\t\\\n+\t\t\t\t\t && TARGET_P8_VECTOR\t\t\\\n+\t\t\t\t\t && TARGET_POWERPC64\t\t\\\n+\t\t\t\t\t && TARGET_UPPER_REGS_DI)\n+\n /* Whether the various reciprocal divide/square root estimate instructions\n    exist, and whether we should automatically generate code for the instruction\n    by default.  */"}, {"sha": "ca569a2cbf1f4c096a894884b0ff0156c265b139", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d321856b3415542f2f13a49e68f1926a71feb3/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d321856b3415542f2f13a49e68f1926a71feb3/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=e0d321856b3415542f2f13a49e68f1926a71feb3", "patch": "@@ -309,6 +309,8 @@\n    UNSPEC_VSX_XVCVDPUXDS\n    UNSPEC_VSX_SIGN_EXTEND\n    UNSPEC_P9_MEMORY\n+   UNSPEC_VSX_VSLO\n+   UNSPEC_VSX_EXTRACT\n   ])\n \n ;; VSX moves\n@@ -2118,16 +2120,13 @@\n ;; register was picked.  Limit the scalar value to FPRs for now.\n \n (define_insn \"vsx_extract_<mode>\"\n-  [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\"\n-            \"=d,     wm,      wo,    d\")\n+  [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\" \"=d,    d,     wr, wr\")\n \n \t(vec_select:<VS_scalar>\n-\t (match_operand:VSX_D 1 \"gpc_reg_operand\"\n-            \"<VSa>, <VSa>,  <VSa>,  <VSa>\")\n+\t (match_operand:VSX_D 1 \"gpc_reg_operand\"      \"<VSa>, <VSa>, wm, wo\")\n \n \t (parallel\n-\t  [(match_operand:QI 2 \"const_0_to_1_operand\"\n-            \"wD,    wD,     wL,     n\")])))]\n+\t  [(match_operand:QI 2 \"const_0_to_1_operand\"  \"wD,    n,     wD, n\")])))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n {\n   int element = INTVAL (operands[2]);\n@@ -2205,6 +2204,34 @@\n   [(set_attr \"type\" \"fpstore\")\n    (set_attr \"length\" \"4\")])\n \n+;; Variable V2DI/V2DF extract shift\n+(define_insn \"vsx_vslo_<mode>\"\n+  [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\" \"=v\")\n+\t(unspec:<VS_scalar> [(match_operand:VSX_D 1 \"gpc_reg_operand\" \"v\")\n+\t\t\t     (match_operand:V2DI 2 \"gpc_reg_operand\" \"v\")]\n+\t\t\t    UNSPEC_VSX_VSLO))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_DIRECT_MOVE_64BIT\"\n+  \"vslo %0,%1,%2\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+;; Variable V2DI/V2DF extract\n+(define_insn_and_split \"vsx_extract_<mode>_var\"\n+  [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\" \"=v\")\n+\t(unspec:<VS_scalar> [(match_operand:VSX_D 1 \"input_operand\" \"v\")\n+\t\t\t     (match_operand:DI 2 \"gpc_reg_operand\" \"r\")]\n+\t\t\t    UNSPEC_VSX_EXTRACT))\n+   (clobber (match_scratch:DI 3 \"=r\"))\n+   (clobber (match_scratch:V2DI 4 \"=&v\"))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_DIRECT_MOVE_64BIT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rs6000_split_vec_extract_var (operands[0], operands[1], operands[2],\n+\t\t\t\toperands[3], operands[4]);\n+  DONE;\n+})\n+\n ;; Extract a SF element from V4SF\n (define_insn_and_split \"vsx_extract_v4sf\"\n   [(set (match_operand:SF 0 \"vsx_register_operand\" \"=f,f\")"}, {"sha": "239cf67c12dc91aa3590acd00d59015d975c178b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d321856b3415542f2f13a49e68f1926a71feb3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d321856b3415542f2f13a49e68f1926a71feb3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e0d321856b3415542f2f13a49e68f1926a71feb3", "patch": "@@ -1,3 +1,7 @@\n+2016-07-28  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/vec-extract-1.c: New test.\n+\n 2016-07-28  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/71799"}, {"sha": "ef34e2bec2c7922aac4d6bb6fad5b3248b57e21a", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d321856b3415542f2f13a49e68f1926a71feb3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d321856b3415542f2f13a49e68f1926a71feb3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-1.c?ref=e0d321856b3415542f2f13a49e68f1926a71feb3", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O2 -mupper-regs-df -mupper-regs-di\" } */\n+\n+#include <altivec.h>\n+\n+double\n+add_double (vector double a, int n)\n+{\n+  return vec_extract (a, n) + 1.0;\n+}\n+\n+long\n+add_long (vector long a, int n)\n+{\n+  return vec_extract (a, n) + 1;\n+}\n+\n+/* { dg-final { scan-assembler     \"vslo\"    } } */\n+/* { dg-final { scan-assembler     \"mtvsrd\"  } } */\n+/* { dg-final { scan-assembler     \"mfvsrd\"  } } */\n+/* { dg-final { scan-assembler-not \"stxvd2x\" } } */\n+/* { dg-final { scan-assembler-not \"stxvx\"   } } */\n+/* { dg-final { scan-assembler-not \"stxv\"    } } */\n+/* { dg-final { scan-assembler-not \"ldx\"     } } */"}]}