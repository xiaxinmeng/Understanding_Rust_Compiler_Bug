{"sha": "f6ae6c51dfff2dc6fd23a2a09c8fe831e8cdcbba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZhZTZjNTFkZmZmMmRjNmZkMjNhMmEwOWM4ZmU4MzFlOGNkY2JiYQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-09-14T22:52:41Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-09-14T22:52:41Z"}, "message": "re PR rtl-optimization/9771 ([x86] wrong ebp optimisation)\n\n\n\tPR rtl-optimization/9771\n\t* regclass.c (CALL_REALLY_USED_REGNO_P): New macro to eliminate\n\tconditional compilation in init_reg_sets_1.\n\t(init_reg_sets_1): Let global_regs[i] take priority over the frame\n\t(but not stack) pointer exceptions to regs_invalidated_by_call.\n\t(globalize_reg): Globalizing a fixed register may need to update\n\tregs_invalidated_by_call.\n\n\t* gcc.dg/pr9771-1.c: New test case.\n\nFrom-SVN: r87516", "tree": {"sha": "3e3217eda3fa7c4321a9da7e4e8d44dc4b9d370c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e3217eda3fa7c4321a9da7e4e8d44dc4b9d370c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6ae6c51dfff2dc6fd23a2a09c8fe831e8cdcbba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6ae6c51dfff2dc6fd23a2a09c8fe831e8cdcbba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6ae6c51dfff2dc6fd23a2a09c8fe831e8cdcbba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6ae6c51dfff2dc6fd23a2a09c8fe831e8cdcbba/comments", "author": null, "committer": null, "parents": [{"sha": "1810f6edaad290e6c4b8003deac8a2be1dd0fb68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1810f6edaad290e6c4b8003deac8a2be1dd0fb68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1810f6edaad290e6c4b8003deac8a2be1dd0fb68"}], "stats": {"total": 86, "additions": 77, "deletions": 9}, "files": [{"sha": "2ce328f08b6e2a21bbd04f6dcb0b09f99ccc1906", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6ae6c51dfff2dc6fd23a2a09c8fe831e8cdcbba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6ae6c51dfff2dc6fd23a2a09c8fe831e8cdcbba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f6ae6c51dfff2dc6fd23a2a09c8fe831e8cdcbba", "patch": "@@ -1,3 +1,13 @@\n+2004-09-14  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR rtl-optimization/9771\n+\t* regclass.c (CALL_REALLY_USED_REGNO_P): New macro to eliminate\n+\tconditional compilation in init_reg_sets_1.\n+\t(init_reg_sets_1): Let global_regs[i] take priority over the frame\n+\t(but not stack) pointer exceptions to regs_invalidated_by_call.\n+\t(globalize_reg): Globalizing a fixed register may need to update\n+\tregs_invalidated_by_call.\n+\n 2004-09-14  Diego Novillo  <dnovillo@redhat.com>\n \n \tPR tree-optimization/15262"}, {"sha": "3d5a5f8dddd92e14b85499c0c9519c11af5c1d97", "filename": "gcc/regclass.c", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6ae6c51dfff2dc6fd23a2a09c8fe831e8cdcbba/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6ae6c51dfff2dc6fd23a2a09c8fe831e8cdcbba/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=f6ae6c51dfff2dc6fd23a2a09c8fe831e8cdcbba", "patch": "@@ -104,6 +104,13 @@ static const char initial_call_used_regs[] = CALL_USED_REGISTERS;\n char call_really_used_regs[] = CALL_REALLY_USED_REGISTERS;\n #endif\n \n+#ifdef CALL_REALLY_USED_REGISTERS\n+#define CALL_REALLY_USED_REGNO_P(X)  call_really_used_regs[X]\n+#else\n+#define CALL_REALLY_USED_REGNO_P(X)  call_used_regs[X]\n+#endif\n+\n+\n /* Indexed by hard register number, contains 1 for registers that are\n    fixed use or call used registers that cannot hold quantities across\n    calls even if we are willing to save and restore them.  call fixed\n@@ -454,7 +461,11 @@ init_reg_sets_1 (void)\n \t If we are generating PIC code, the PIC offset table register is\n \t preserved across calls, though the target can override that.  */\n \n-      if (i == STACK_POINTER_REGNUM || i == FRAME_POINTER_REGNUM)\n+      if (i == STACK_POINTER_REGNUM)\n+\t;\n+      else if (global_regs[i])\n+\tSET_HARD_REG_BIT (regs_invalidated_by_call, i);\n+      else if (i == FRAME_POINTER_REGNUM)\n \t;\n #if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n       else if (i == HARD_FRAME_POINTER_REGNUM)\n@@ -468,13 +479,7 @@ init_reg_sets_1 (void)\n       else if (i == (unsigned) PIC_OFFSET_TABLE_REGNUM && fixed_regs[i])\n \t;\n #endif\n-      else if (0\n-#ifdef CALL_REALLY_USED_REGISTERS\n-\t       || call_really_used_regs[i]\n-#else\n-\t       || call_used_regs[i]\n-#endif\n-\t       || global_regs[i])\n+      else if (CALL_REALLY_USED_REGNO_P (i))\n \tSET_HARD_REG_BIT (regs_invalidated_by_call, i);\n     }\n \n@@ -800,6 +805,12 @@ globalize_reg (int i)\n \n   global_regs[i] = 1;\n \n+  /* If we're globalizing the frame pointer, we need to set the\n+     appropriate regs_invalidated_by_call bit, even if it's already\n+     set in fixed_regs.  */\n+  if (i != STACK_POINTER_REGNUM)\n+    SET_HARD_REG_BIT (regs_invalidated_by_call, i);\n+\n   /* If already fixed, nothing else to do.  */\n   if (fixed_regs[i])\n     return;\n@@ -813,7 +824,6 @@ globalize_reg (int i)\n   SET_HARD_REG_BIT (fixed_reg_set, i);\n   SET_HARD_REG_BIT (call_used_reg_set, i);\n   SET_HARD_REG_BIT (call_fixed_reg_set, i);\n-  SET_HARD_REG_BIT (regs_invalidated_by_call, i);\n }\n \f\n /* Now the data and code for the `regclass' pass, which happens"}, {"sha": "a8f7e5d393e62a2a0d731d7606e161e1594226fd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6ae6c51dfff2dc6fd23a2a09c8fe831e8cdcbba/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6ae6c51dfff2dc6fd23a2a09c8fe831e8cdcbba/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f6ae6c51dfff2dc6fd23a2a09c8fe831e8cdcbba", "patch": "@@ -1,3 +1,8 @@\n+2004-09-14  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR rtl-optimization/9771\n+\t* gcc.dg/pr9771-1.c: New test case.\n+\n 2004-09-14  Diego Novillo  <dnovillo@redhat.com>\n \n \tPR tree-optimization/15262"}, {"sha": "1e3bc036aeee40cdea9f0dfde6c3fcf6ccf9cc2d", "filename": "gcc/testsuite/gcc.dg/pr9771-1.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6ae6c51dfff2dc6fd23a2a09c8fe831e8cdcbba/gcc%2Ftestsuite%2Fgcc.dg%2Fpr9771-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6ae6c51dfff2dc6fd23a2a09c8fe831e8cdcbba/gcc%2Ftestsuite%2Fgcc.dg%2Fpr9771-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr9771-1.c?ref=f6ae6c51dfff2dc6fd23a2a09c8fe831e8cdcbba", "patch": "@@ -0,0 +1,43 @@\n+/* PR rtl-optimization/9771 */\n+/* { dg-do run { target i?86-*-* } } */\n+/* { dg-options \"-O2 -fomit-frame-pointer -ffixed-ebp\" } */\n+\n+extern void abort(void);\n+extern void exit(int);\n+\n+register long *B asm (\"ebp\");\n+\n+long x = 10;\n+long y = 20;\n+\n+void bar(void)\n+{\n+  B = &y;\n+}\n+\n+void foo()\n+{\n+  long *adr = B;\n+  long save = *adr;\n+\n+  *adr = 123;\n+\n+  bar();\n+\n+  *adr = save;\n+}\n+\n+int main()\n+{\n+  B = &x;\n+\n+  foo();\n+\n+  if (x != 10 || y != 20)\n+    abort();\n+\n+  /* We can't return, as our caller may assume %ebp is preserved!  */\n+  /* We could save/restore it (like foo), but its easier to exit.  */\n+  exit(0);\n+}\n+"}]}