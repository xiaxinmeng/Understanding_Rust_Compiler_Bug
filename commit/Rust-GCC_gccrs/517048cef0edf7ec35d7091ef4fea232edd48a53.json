{"sha": "517048cef0edf7ec35d7091ef4fea232edd48a53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE3MDQ4Y2VmMGVkZjdlYzM1ZDcwOTFlZjRmZWEyMzJlZGQ0OGE1Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-11-18T22:55:56Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-11-18T22:55:56Z"}, "message": "cgraphclones.c (cgraph_edge::clone): Rename gcov_count to prof_count.\n\n\n\t* cgraphclones.c (cgraph_edge::clone): Rename gcov_count to prof_count.\n\t(cgraph_edge::clone): Cleanup updating of profile.\n\t* ipa-cp.c (update_profiling_info): Likewise.\n\t* ipa-inline-transform.c (inline_transform): Likewise.\n\t* ipa-inline.c (inline_small_functions): Add missing space to dump.\n\t* ipa-split.c (execute_split_functions): Do not split when function\n\tis cold.\n\t* predict.c (estimate_bb_frequencies): Cleanup updating of profile.\n\t* profile-count.c (profile_count::dump): Add global0.\n\t(profile_count::to_cgraph_frequency): Do not ICE when entry is\n\tundefined.\n\t(profile_count::to_sreal_scale): Likewise.\n\t(profile_count::adjust_for_ipa_scaling): Fix typo in comment.\n\t(profile_count::combine_with_ipa_count): New function.\n\t* profile-count.h (profile_guessed_global0adjusted): New.\n\t(profile_count::adjusted_zero): New.\n\t(profile_count::global0adjusted): New.\n\t(profile_count::combine_with_ipa_count): New.\n\t* tree-inline.c (copy_edges_for_bb): Add NUM/DEN arugment;\n\tcorrect profile of return block of split functions.\n\t(copy_cfg_body): Remove unused profile_count.\n\t(copy_body): Likewise.\n\t(expand_call_inline): Update.\n\t(tree_function_versioning): Update.\n\nFrom-SVN: r254919", "tree": {"sha": "87fb8324893c35156edda2a67cd930e5e58da277", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87fb8324893c35156edda2a67cd930e5e58da277"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/517048cef0edf7ec35d7091ef4fea232edd48a53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/517048cef0edf7ec35d7091ef4fea232edd48a53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/517048cef0edf7ec35d7091ef4fea232edd48a53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/517048cef0edf7ec35d7091ef4fea232edd48a53/comments", "author": null, "committer": null, "parents": [{"sha": "2563a16d3c7a56cd1e0cfe9b4ccb702edfb12312", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2563a16d3c7a56cd1e0cfe9b4ccb702edfb12312", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2563a16d3c7a56cd1e0cfe9b4ccb702edfb12312"}], "stats": {"total": 232, "additions": 144, "deletions": 88}, "files": [{"sha": "60689054d05eab2f641ced023a3381f1c854de61", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/517048cef0edf7ec35d7091ef4fea232edd48a53/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/517048cef0edf7ec35d7091ef4fea232edd48a53/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=517048cef0edf7ec35d7091ef4fea232edd48a53", "patch": "@@ -1,3 +1,30 @@\n+2017-11-18  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cgraphclones.c (cgraph_edge::clone): Rename gcov_count to prof_count.\n+\t(cgraph_edge::clone): Cleanup updating of profile.\n+\t* ipa-cp.c (update_profiling_info): Likewise.\n+\t* ipa-inline-transform.c (inline_transform): Likewise.\n+\t* ipa-inline.c (inline_small_functions): Add missing space to dump.\n+\t* ipa-split.c (execute_split_functions): Do not split when function\n+\tis cold.\n+\t* predict.c (estimate_bb_frequencies): Cleanup updating of profile.\n+\t* profile-count.c (profile_count::dump): Add global0.\n+\t(profile_count::to_cgraph_frequency): Do not ICE when entry is\n+\tundefined.\n+\t(profile_count::to_sreal_scale): Likewise.\n+\t(profile_count::adjust_for_ipa_scaling): Fix typo in comment.\n+\t(profile_count::combine_with_ipa_count): New function.\n+\t* profile-count.h (profile_guessed_global0adjusted): New.\n+\t(profile_count::adjusted_zero): New.\n+\t(profile_count::global0adjusted): New.\n+\t(profile_count::combine_with_ipa_count): New.\n+\t* tree-inline.c (copy_edges_for_bb): Add NUM/DEN arugment;\n+\tcorrect profile of return block of split functions.\n+\t(copy_cfg_body): Remove unused profile_count.\n+\t(copy_body): Likewise.\n+\t(expand_call_inline): Update.\n+\t(tree_function_versioning): Update.\n+\n 2017-11-18  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* hash-set.h (hash_set::empty): New."}, {"sha": "ef39d85e88c1acd88318e345259cdccc01d43c3a", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/517048cef0edf7ec35d7091ef4fea232edd48a53/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/517048cef0edf7ec35d7091ef4fea232edd48a53/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=517048cef0edf7ec35d7091ef4fea232edd48a53", "patch": "@@ -91,7 +91,7 @@ cgraph_edge::clone (cgraph_node *n, gcall *call_stmt, unsigned stmt_uid,\n {\n   cgraph_edge *new_edge;\n   profile_count::adjust_for_ipa_scaling (&num, &den);\n-  profile_count gcov_count = count.apply_scale (num, den);\n+  profile_count prof_count = count.apply_scale (num, den);\n \n   if (indirect_unknown_callee)\n     {\n@@ -104,19 +104,19 @@ cgraph_edge::clone (cgraph_node *n, gcall *call_stmt, unsigned stmt_uid,\n \t{\n \t  cgraph_node *callee = cgraph_node::get (decl);\n \t  gcc_checking_assert (callee);\n-\t  new_edge = n->create_edge (callee, call_stmt, gcov_count);\n+\t  new_edge = n->create_edge (callee, call_stmt, prof_count);\n \t}\n       else\n \t{\n \t  new_edge = n->create_indirect_edge (call_stmt,\n \t\t\t\t\t      indirect_info->ecf_flags,\n-\t\t\t\t\t      gcov_count, false);\n+\t\t\t\t\t      prof_count, false);\n \t  *new_edge->indirect_info = *indirect_info;\n \t}\n     }\n   else\n     {\n-      new_edge = n->create_edge (callee, call_stmt, gcov_count);\n+      new_edge = n->create_edge (callee, call_stmt, prof_count);\n       if (indirect_info)\n \t{\n \t  new_edge->indirect_info\n@@ -135,12 +135,9 @@ cgraph_edge::clone (cgraph_node *n, gcall *call_stmt, unsigned stmt_uid,\n   new_edge->in_polymorphic_cdtor = in_polymorphic_cdtor;\n \n   /* Update IPA profile.  Local profiles need no updating in original.  */\n-  if (update_original\n-      && count.ipa () == count && new_edge->count.ipa () == new_edge->count)\n-    count -= new_edge->count;\n-  else if (caller->count.global0 () == caller->count\n-\t   && !(count == profile_count::zero ()))\n-    count = count.global0 ();\n+  if (update_original)\n+    count = count.combine_with_ipa_count (count.ipa () \n+\t\t\t\t\t  - new_edge->count.ipa ());\n   symtab->call_edge_duplication_hooks (this, new_edge);\n   return new_edge;\n }\n@@ -431,22 +428,12 @@ cgraph_node::create_clone (tree new_decl, profile_count prof_count,\n   if (new_inlined_to)\n     dump_callgraph_transformation (this, new_inlined_to, \"inlining to\");\n \n-  if (prof_count == profile_count::zero ()\n-      && !(count == profile_count::zero ()))\n-    prof_count = count.global0 ();\n-\n+  prof_count = count.combine_with_ipa_count (prof_count);\n   new_node->count = prof_count;\n \n   /* Update IPA profile.  Local profiles need no updating in original.  */\n-  if (update_original && !(count == profile_count::zero ())\n-      && count.ipa () == count && prof_count.ipa () == prof_count)\n-    {\n-      if (count.nonzero_p ()\n-\t  && !(count - prof_count).nonzero_p ())\n-\tcount = count.global0 ();\n-      else\n-        count -= prof_count;\n-    }\n+  if (update_original)\n+    count = count.combine_with_ipa_count (count.ipa () - prof_count.ipa ());\n   new_node->decl = new_decl;\n   new_node->register_symbol ();\n   new_node->origin = origin;"}, {"sha": "05228d0582d90b66d56d6deb7b764800606405f5", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/517048cef0edf7ec35d7091ef4fea232edd48a53/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/517048cef0edf7ec35d7091ef4fea232edd48a53/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=517048cef0edf7ec35d7091ef4fea232edd48a53", "patch": "@@ -3695,18 +3695,9 @@ update_profiling_info (struct cgraph_node *orig_node,\n \t}\n     }\n \n-  if (!new_sum.nonzero_p ())\n-    {\n-      new_sum = new_sum.global0 ();\n-      new_node->count = new_sum;\n-      remainder = orig_node->count;\n-    }\n-  else\n-    {\n-      remainder = orig_node_count - new_sum;\n-      if (!remainder.nonzero_p ())\n-\tremainder = orig_node_count.global0 ();\n-    }\n+  remainder = orig_node_count.combine_with_ipa_count (orig_node_count.ipa ()\n+\t\t\t\t\t\t      - new_sum.ipa ());\n+  new_sum = orig_node_count.combine_with_ipa_count (new_sum);\n   orig_node->count = remainder;\n \n   for (cs = new_node->callees; cs; cs = cs->next_callee)"}, {"sha": "0ed3fbd252581edb528c17e70a21eb0a5af1b284", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/517048cef0edf7ec35d7091ef4fea232edd48a53/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/517048cef0edf7ec35d7091ef4fea232edd48a53/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=517048cef0edf7ec35d7091ef4fea232edd48a53", "patch": "@@ -657,11 +657,10 @@ inline_transform (struct cgraph_node *node)\n     {\n       profile_count num = node->count;\n       profile_count den = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n-      bool scale = num.initialized_p () && den.ipa_p ()\n-\t\t   && (den.nonzero_p () || num == profile_count::zero ())\n-\t\t   && !(num == den.ipa ());\n+      bool scale = num.initialized_p () && !(num == den);\n       if (scale)\n \t{\n+\t  profile_count::adjust_for_ipa_scaling (&num, &den);\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \"Applying count scale \");\n@@ -672,11 +671,12 @@ inline_transform (struct cgraph_node *node)\n \t    }\n \n \t  basic_block bb;\n+\t  cfun->cfg->count_max = profile_count::uninitialized ();\n \t  FOR_ALL_BB_FN (bb, cfun)\n-\t    if (num == profile_count::zero ())\n-\t      bb->count = bb->count.global0 ();\n-\t    else\n+\t    {\n \t      bb->count = bb->count.apply_scale (num, den);\n+\t      cfun->cfg->count_max = cfun->cfg->count_max.max (bb->count);\n+\t    }\n \t  ENTRY_BLOCK_PTR_FOR_FN (cfun)->count = node->count;\n \t}\n       todo = optimize_inline_calls (current_function_decl);"}, {"sha": "f4ce80ae2c6f1114cab9c2e82c53f884d9522ea6", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/517048cef0edf7ec35d7091ef4fea232edd48a53/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/517048cef0edf7ec35d7091ef4fea232edd48a53/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=517048cef0edf7ec35d7091ef4fea232edd48a53", "patch": "@@ -1873,7 +1873,8 @@ inline_small_functions (void)\n       /* Be sure that caches are maintained consistent.\n \t This check is affected by scaling roundoff errors when compiling for\n \t IPA this we skip it in that case.  */\n-      if (!edge->callee->count.ipa_p ())\n+      if (!edge->callee->count.ipa_p ()\n+\t  && (!max_count.initialized_p () || !max_count.nonzero_p ()))\n \t{\n \t  sreal cached_badness = edge_badness (edge, false);\n      \n@@ -1951,7 +1952,7 @@ inline_small_functions (void)\n \t    {\n \t      fprintf (dump_file, \" Called \");\n \t      edge->count.ipa ().dump (dump_file);\n-\t      fprintf (dump_file, \"times\\n\");\n+\t      fprintf (dump_file, \" times\\n\");\n             }\n \t  if (dump_flags & TDF_DETAILS)\n \t    edge_badness (edge, true);"}, {"sha": "7ebd51554e5694c2651c563c99f0f63a0633b389", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/517048cef0edf7ec35d7091ef4fea232edd48a53/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/517048cef0edf7ec35d7091ef4fea232edd48a53/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=517048cef0edf7ec35d7091ef4fea232edd48a53", "patch": "@@ -1752,6 +1752,12 @@ execute_split_functions (void)\n \tfprintf (dump_file, \"Not splitting: main function.\\n\");\n       return 0;\n     }\n+  if (node->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Not splitting: function is unlikely executed.\\n\");\n+      return 0;\n+    }\n   /* This can be relaxed; function might become inlinable after splitting\n      away the uninlinable part.  */\n   if (ipa_fn_summaries"}, {"sha": "0f34956f699e1436a366146d499dcf30e4a948a7", "filename": "gcc/predict.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/517048cef0edf7ec35d7091ef4fea232edd48a53/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/517048cef0edf7ec35d7091ef4fea232edd48a53/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=517048cef0edf7ec35d7091ef4fea232edd48a53", "patch": "@@ -3607,9 +3607,6 @@ estimate_bb_frequencies (bool force)\n          to outermost to examine frequencies for back edges.  */\n       estimate_loops ();\n \n-      bool global0 = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.initialized_p ()\n-\t\t     && ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.ipa_p ();\n-\n       freq_max = 0;\n       FOR_EACH_BB_FN (bb, cfun)\n \tif (freq_max < BLOCK_INFO (bb)->frequency)\n@@ -3618,6 +3615,7 @@ estimate_bb_frequencies (bool force)\n       freq_max = real_bb_freq_max / freq_max;\n       if (freq_max < 16)\n \tfreq_max = 16;\n+      profile_count ipa_count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.ipa ();\n       cfun->cfg->count_max = profile_count::uninitialized ();\n       FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n \t{\n@@ -3626,10 +3624,8 @@ estimate_bb_frequencies (bool force)\n \n \t  /* If we have profile feedback in which this function was never\n \t     executed, then preserve this info.  */\n-\t  if (global0)\n-\t    bb->count = count.global0 ();\n-\t  else if (!(bb->count == profile_count::zero ()))\n-\t    bb->count = count.guessed_local ();\n+\t  if (!(bb->count == profile_count::zero ()))\n+\t    bb->count = count.guessed_local ().combine_with_ipa_count (ipa_count);\n           cfun->cfg->count_max = cfun->cfg->count_max.max (bb->count);\n \t}\n "}, {"sha": "e5d9faefc33c89a4ce88487d8d3867d0561d7b82", "filename": "gcc/profile-count.c", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/517048cef0edf7ec35d7091ef4fea232edd48a53/gcc%2Fprofile-count.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/517048cef0edf7ec35d7091ef4fea232edd48a53/gcc%2Fprofile-count.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.c?ref=517048cef0edf7ec35d7091ef4fea232edd48a53", "patch": "@@ -47,6 +47,8 @@ profile_count::dump (FILE *f) const\n \tfprintf (f, \" (estimated locally)\");\n       else if (m_quality == profile_guessed_global0)\n \tfprintf (f, \" (estimated locally, globally 0)\");\n+      else if (m_quality == profile_guessed_global0adjusted)\n+\tfprintf (f, \" (estimated locally, globally 0 adjusted)\");\n       else if (m_quality == profile_adjusted)\n \tfprintf (f, \" (adjusted)\");\n       else if (m_quality == profile_afdo)\n@@ -245,7 +247,7 @@ profile_count::to_frequency (struct function *fun) const\n int\n profile_count::to_cgraph_frequency (profile_count entry_bb_count) const\n {\n-  if (!initialized_p ())\n+  if (!initialized_p () || !entry_bb_count.initialized_p ())\n     return CGRAPH_FREQ_BASE;\n   if (*this == profile_count::zero ())\n     return 0;\n@@ -262,7 +264,7 @@ profile_count::to_cgraph_frequency (profile_count entry_bb_count) const\n sreal\n profile_count::to_sreal_scale (profile_count in, bool *known) const\n {\n-  if (!initialized_p ())\n+  if (!initialized_p () || !in.initialized_p ())\n     {\n       if (known)\n \t*known = false;\n@@ -272,7 +274,6 @@ profile_count::to_sreal_scale (profile_count in, bool *known) const\n     *known = true;\n   if (*this == profile_count::zero ())\n     return 0;\n-  gcc_checking_assert (in.initialized_p ());\n \n   if (!in.m_val)\n     {\n@@ -297,7 +298,7 @@ profile_count::adjust_for_ipa_scaling (profile_count *num,\n   /* Scaling is no-op if NUM and DEN are the same.  */\n   if (*num == *den)\n     return;\n-  /* Scaling to zero is always zeor.  */\n+  /* Scaling to zero is always zero.  */\n   if (*num == profile_count::zero ())\n     return;\n   /* If den is non-zero we are safe.  */\n@@ -308,3 +309,21 @@ profile_count::adjust_for_ipa_scaling (profile_count *num,\n   *den = den->force_nonzero ();\n   *num = num->force_nonzero ();\n }\n+\n+/* THIS is a count of bb which is known to be executed IPA times.\n+   Combine this information into bb counter.  This means returning IPA\n+   if it is nonzero, not changing anything if IPA is uninitialized\n+   and if IPA is zero, turning THIS into corresponding local profile with\n+   global0.  */\n+profile_count\n+profile_count::combine_with_ipa_count (profile_count ipa)\n+{\n+  ipa = ipa.ipa ();\n+  if (ipa.nonzero_p ())\n+    return ipa;\n+  if (!ipa.initialized_p ())\n+    return *this;\n+  if (ipa == profile_count::zero ())\n+    return this->global0 ();\n+  return this->global0adjusted ();\n+}"}, {"sha": "2ffa33f639c6ad6be9d1285f010b79c349000bb3", "filename": "gcc/profile-count.h", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/517048cef0edf7ec35d7091ef4fea232edd48a53/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/517048cef0edf7ec35d7091ef4fea232edd48a53/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=517048cef0edf7ec35d7091ef4fea232edd48a53", "patch": "@@ -36,22 +36,24 @@ enum profile_quality {\n      Never used by probabilities.  */\n   profile_guessed_global0 = 1,\n \n+  /* Same as profile_guessed_global0 but global count is adjusted 0.  */\n+  profile_guessed_global0adjusted = 2,\n \n   /* Profile is based on static branch prediction heuristics.  It may or may\n      not reflect the reality but it can be compared interprocedurally\n      (for example, we inlined function w/o profile feedback into function\n       with feedback and propagated from that).\n      Never used by probablities.  */\n-  profile_guessed = 2,\n+  profile_guessed = 3,\n   /* Profile was determined by autofdo.  */\n-  profile_afdo = 3,\n+  profile_afdo = 4,\n   /* Profile was originally based on feedback but it was adjusted\n      by code duplicating optimization.  It may not precisely reflect the\n      particular code path.  */\n-  profile_adjusted = 4,\n+  profile_adjusted = 5,\n   /* Profile was read from profile feedback or determined by accurate static\n      method.  */\n-  profile_precise = 5\n+  profile_precise = 7\n };\n \n /* The base value for branch probability notes and edge probabilities.  */\n@@ -637,6 +639,13 @@ class GTY(()) profile_count\n     {\n       return from_gcov_type (0);\n     }\n+  static profile_count adjusted_zero ()\n+    {\n+      profile_count c;\n+      c.m_val = 0;\n+      c.m_quality = profile_adjusted;\n+      return c;\n+    }\n   static profile_count guessed_zero ()\n     {\n       profile_count c;\n@@ -978,7 +987,7 @@ class GTY(()) profile_count\n       return ret;\n     }\n \n-  /* We know that profile is globally0 but keep local profile if present.  */\n+  /* We know that profile is globally 0 but keep local profile if present.  */\n   profile_count global0 () const\n     {\n       profile_count ret = *this;\n@@ -988,6 +997,17 @@ class GTY(()) profile_count\n       return ret;\n     }\n \n+  /* We know that profile is globally adjusted 0 but keep local profile\n+     if present.  */\n+  profile_count global0adjusted () const\n+    {\n+      profile_count ret = *this;\n+      if (!initialized_p ())\n+\treturn *this;\n+      ret.m_quality = profile_guessed_global0adjusted;\n+      return ret;\n+    }\n+\n   /* Return THIS with quality dropped to GUESSED.  */\n   profile_count guessed () const\n     {\n@@ -1000,10 +1020,12 @@ class GTY(()) profile_count\n      acorss functions.  */\n   profile_count ipa () const\n     {\n-      if (m_quality > profile_guessed_global0)\n+      if (m_quality > profile_guessed_global0adjusted)\n \treturn *this;\n       if (m_quality == profile_guessed_global0)\n \treturn profile_count::zero ();\n+      if (m_quality == profile_guessed_global0adjusted)\n+\treturn profile_count::adjusted_zero ();\n       return profile_count::uninitialized ();\n     }\n \n@@ -1054,6 +1076,13 @@ class GTY(()) profile_count\n      kinds.  */\n   static void adjust_for_ipa_scaling (profile_count *num, profile_count *den);\n \n+  /* THIS is a count of bb which is known to be executed IPA times.\n+     Combine this information into bb counter.  This means returning IPA\n+     if it is nonzero, not changing anything if IPA is uninitialized\n+     and if IPA is zero, turning THIS into corresponding local profile with\n+     global0.  */\n+  profile_count combine_with_ipa_count (profile_count ipa);\n+\n   /* LTO streaming support.  */\n   static profile_count stream_in (struct lto_input_block *);\n   void stream_out (struct output_block *);"}, {"sha": "6af2079b8375bfc258144bb294cd79f809290ee3", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/517048cef0edf7ec35d7091ef4fea232edd48a53/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/517048cef0edf7ec35d7091ef4fea232edd48a53/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=517048cef0edf7ec35d7091ef4fea232edd48a53", "patch": "@@ -2173,7 +2173,7 @@ update_ssa_across_abnormal_edges (basic_block bb, basic_block ret_bb,\n    debug stmts are left after a statement that must end the basic block.  */\n \n static bool\n-copy_edges_for_bb (basic_block bb,\n+copy_edges_for_bb (basic_block bb, profile_count num, profile_count den,\n \t\t   basic_block ret_bb, basic_block abnormal_goto_dest)\n {\n   basic_block new_bb = (basic_block) bb->aux;\n@@ -2204,6 +2204,14 @@ copy_edges_for_bb (basic_block bb,\n   if (bb->index == ENTRY_BLOCK || bb->index == EXIT_BLOCK)\n     return false;\n \n+  /* When doing function splitting, we must decreate count of the return block\n+     which was previously reachable by block we did not copy.  */\n+  if (single_succ_p (bb) && single_succ_edge (bb)->dest->index == EXIT_BLOCK)\n+    FOR_EACH_EDGE (old_edge, ei, bb->preds)\n+      if (old_edge->src->index != ENTRY_BLOCK\n+\t  && !old_edge->src->aux)\n+\tnew_bb->count -= old_edge->count ().apply_scale (num, den);\n+\n   for (si = gsi_start_bb (new_bb); !gsi_end_p (si);)\n     {\n       gimple *copy_stmt;\n@@ -2465,23 +2473,16 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, profile_count count)\n \n   profile_status_for_fn (cfun) = profile_status_for_fn (src_cfun);\n \n-  if (ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count.initialized_p ()\n-      && count.ipa ().initialized_p ())\n-    {\n-      ENTRY_BLOCK_PTR_FOR_FN (cfun)->count =\n-\tENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count.apply_scale (count,\n-\t\t\t\t    ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count);\n-      EXIT_BLOCK_PTR_FOR_FN (cfun)->count =\n-\tEXIT_BLOCK_PTR_FOR_FN (src_cfun)->count.apply_scale (count,\n-\t\t\t\t    ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count);\n-    }\n-  else\n-    {\n-      ENTRY_BLOCK_PTR_FOR_FN (cfun)->count\n-\t   = ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count;\n-      EXIT_BLOCK_PTR_FOR_FN (cfun)->count\n-\t   = EXIT_BLOCK_PTR_FOR_FN (src_cfun)->count;\n-    }\n+  profile_count num = count;\n+  profile_count den = ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count;\n+  profile_count::adjust_for_ipa_scaling (&num, &den);\n+\n+  ENTRY_BLOCK_PTR_FOR_FN (cfun)->count =\n+    ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count.apply_scale (count,\n+\t\t\t\tENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count);\n+  EXIT_BLOCK_PTR_FOR_FN (cfun)->count =\n+    EXIT_BLOCK_PTR_FOR_FN (src_cfun)->count.apply_scale (count,\n+\t\t\t\tENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count);\n   if (src_cfun->eh)\n     init_eh_for_function ();\n \n@@ -2642,7 +2643,7 @@ redirect_all_calls (copy_body_data * id, basic_block bb)\n    another function.  Walks FN via CFG, returns new fndecl.  */\n \n static tree\n-copy_cfg_body (copy_body_data * id, profile_count,\n+copy_cfg_body (copy_body_data * id,\n \t       basic_block entry_block_map, basic_block exit_block_map,\n \t       basic_block new_entry)\n {\n@@ -2723,12 +2724,13 @@ copy_cfg_body (copy_body_data * id, profile_count,\n   FOR_ALL_BB_FN (bb, cfun_to_copy)\n     if (!id->blocks_to_copy\n \t|| (bb->index > 0 && bitmap_bit_p (id->blocks_to_copy, bb->index)))\n-      need_debug_cleanup |= copy_edges_for_bb (bb, exit_block_map,\n+      need_debug_cleanup |= copy_edges_for_bb (bb, num, den, exit_block_map,\n \t\t\t\t\t       abnormal_goto_dest);\n \n   if (new_entry)\n     {\n-      edge e = make_edge (entry_block_map, (basic_block)new_entry->aux, EDGE_FALLTHRU);\n+      edge e = make_edge (entry_block_map, (basic_block)new_entry->aux,\n+\t\t\t  EDGE_FALLTHRU);\n       e->probability = profile_probability::always ();\n     }\n \n@@ -2927,7 +2929,7 @@ copy_tree_body (copy_body_data *id)\n    another function.  */\n \n static tree\n-copy_body (copy_body_data *id, profile_count count,\n+copy_body (copy_body_data *id,\n \t   basic_block entry_block_map, basic_block exit_block_map,\n \t   basic_block new_entry)\n {\n@@ -2936,7 +2938,7 @@ copy_body (copy_body_data *id, profile_count count,\n \n   /* If this body has a CFG, walk CFG and copy.  */\n   gcc_assert (ENTRY_BLOCK_PTR_FOR_FN (DECL_STRUCT_FUNCTION (fndecl)));\n-  body = copy_cfg_body (id, count, entry_block_map, exit_block_map,\n+  body = copy_cfg_body (id, entry_block_map, exit_block_map,\n \t\t\tnew_entry);\n   copy_debug_stmts (id);\n \n@@ -4684,8 +4686,7 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n      function in any way before this point, as this CALL_EXPR may be\n      a self-referential call; if we're calling ourselves, we need to\n      duplicate our body before altering anything.  */\n-  copy_body (id, cg_edge->callee->count,\n-\t     bb, return_block, NULL);\n+  copy_body (id, bb, return_block, NULL);\n \n   reset_debug_bindings (id, stmt_gsi);\n \n@@ -5857,7 +5858,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   DECL_RESULT (new_decl) = DECL_RESULT (old_decl);\n   DECL_ARGUMENTS (new_decl) = DECL_ARGUMENTS (old_decl);\n   initialize_cfun (new_decl, old_decl,\n-\t\t   old_entry_block->count);\n+\t\t   new_entry ? new_entry->count : old_entry_block->count);\n   if (DECL_STRUCT_FUNCTION (new_decl)->gimple_df)\n     DECL_STRUCT_FUNCTION (new_decl)->gimple_df->ipa_pta\n       = id.src_cfun->gimple_df->ipa_pta;\n@@ -6004,8 +6005,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n     }\n \n   /* Copy the Function's body.  */\n-  copy_body (&id, old_entry_block->count,\n-\t     ENTRY_BLOCK_PTR_FOR_FN (cfun), EXIT_BLOCK_PTR_FOR_FN (cfun),\n+  copy_body (&id, ENTRY_BLOCK_PTR_FOR_FN (cfun), EXIT_BLOCK_PTR_FOR_FN (cfun),\n \t     new_entry);\n \n   /* Renumber the lexical scoping (non-code) blocks consecutively.  */"}]}