{"sha": "6a49f3c94c266accd6561cc9784cfeaa086fde11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE0OWYzYzk0YzI2NmFjY2Q2NTYxY2M5Nzg0Y2ZlYWEwODZmZGUxMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-08-28T06:51:27Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-08-28T06:51:27Z"}, "message": "lto-partition.c (lto_balanced_map): Always base order on source file order.\n\n\t* lto-partition.c (lto_balanced_map): Always base order on \n\tsource file order.\n\nCo-Authored-By: Martin Liska <marxin.liska@gmail.com>\n\nFrom-SVN: r202041", "tree": {"sha": "4157980b4173ae382b3d91dff57bab88de4a53d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4157980b4173ae382b3d91dff57bab88de4a53d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a49f3c94c266accd6561cc9784cfeaa086fde11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a49f3c94c266accd6561cc9784cfeaa086fde11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a49f3c94c266accd6561cc9784cfeaa086fde11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a49f3c94c266accd6561cc9784cfeaa086fde11/comments", "author": null, "committer": null, "parents": [{"sha": "8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7"}], "stats": {"total": 38, "additions": 19, "deletions": 19}, "files": [{"sha": "3ffc5f660af1142cc38089eec09825860cc3d7fd", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a49f3c94c266accd6561cc9784cfeaa086fde11/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a49f3c94c266accd6561cc9784cfeaa086fde11/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=6a49f3c94c266accd6561cc9784cfeaa086fde11", "patch": "@@ -1,3 +1,9 @@\n+2013-08-06  Jan Hubicka  <jh@suse.cz>\n+\t    Martin Liska  <marxin.liska@gmail.com>\n+\n+\t* lto-partition.c (lto_balanced_map): Always base order on \n+\tsource file order.\n+\n 2013-08-06  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c (lto_materialize_function): Do not read body anymore."}, {"sha": "e05f805fea448d2874d2240ff13eec76786c13ca", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a49f3c94c266accd6561cc9784cfeaa086fde11/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a49f3c94c266accd6561cc9784cfeaa086fde11/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=6a49f3c94c266accd6561cc9784cfeaa086fde11", "patch": "@@ -449,11 +449,9 @@ lto_balanced_map (void)\n {\n   int n_nodes = 0;\n   int n_varpool_nodes = 0, varpool_pos = 0, best_varpool_pos = 0;\n-  struct cgraph_node **postorder =\n-    XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n   struct cgraph_node **order = XNEWVEC (struct cgraph_node *, cgraph_max_uid);\n   struct varpool_node **varpool_order = NULL;\n-  int i, postorder_len;\n+  int i;\n   struct cgraph_node *node;\n   int total_size = 0, best_total_size = 0;\n   int partition_size;\n@@ -468,24 +466,20 @@ lto_balanced_map (void)\n \n   FOR_EACH_VARIABLE (vnode)\n     gcc_assert (!vnode->symbol.aux);\n-  /* Until we have better ordering facility, use toplogical order.\n-     Include only nodes we will partition and compute estimate of program\n-     size.  Note that since nodes that are not partitioned might be put into\n-     multiple partitions, this is just an estimate of real size.  This is why\n-     we keep partition_size updated after every partition is finalized.  */\n-  postorder_len = ipa_reverse_postorder (postorder);\n     \n-  for (i = 0; i < postorder_len; i++)\n-    {\n-      node = postorder[i];\n-      if (get_symbol_class ((symtab_node) node) == SYMBOL_PARTITION)\n-\t{\n-\t  order[n_nodes++] = node;\n-          total_size += inline_summary (node)->size;\n-\t}\n-    }\n-  free (postorder);\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    if (get_symbol_class ((symtab_node) node) == SYMBOL_PARTITION)\n+      {\n+\torder[n_nodes++] = node;\n+\ttotal_size += inline_summary (node)->size;\n+      }\n \n+  /* Streaming works best when the source units do not cross partition\n+     boundaries much.  This is because importing function from a source\n+     unit tends to import a lot of global trees defined there.  We should\n+     get better about minimizing the function bounday, but until that\n+     things works smoother if we order in source order.  */\n+  qsort (order, n_nodes, sizeof (struct cgraph_node *), node_cmp);\n   if (!flag_toplevel_reorder)\n     {\n       qsort (order, n_nodes, sizeof (struct cgraph_node *), node_cmp);"}]}