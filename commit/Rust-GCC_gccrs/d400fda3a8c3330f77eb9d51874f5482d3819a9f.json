{"sha": "d400fda3a8c3330f77eb9d51874f5482d3819a9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQwMGZkYTNhOGMzMzMwZjc3ZWI5ZDUxODc0ZjU0ODJkMzgxOWE5Zg==", "commit": {"author": {"name": "Richard Henderson", "email": "richard.henderson@linaro.org", "date": "2018-10-31T09:42:39Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2018-10-31T09:42:39Z"}, "message": "aarch64: Improve cas generation\n\nDo not zero-extend the input to the cas for subword operations;\ninstead, use the appropriate zero-extending compare insns.\nCorrect the predicates and constraints for immediate expected operand.\n\n\t* config/aarch64/aarch64.c (aarch64_gen_compare_reg_maybe_ze): New.\n\t(aarch64_split_compare_and_swap): Use it.\n\t(aarch64_expand_compare_and_swap): Likewise.  Remove convert_modes;\n\ttest oldval against the proper predicate.\n\t* config/aarch64/atomics.md (@atomic_compare_and_swap<ALLI>):\n\tUse nonmemory_operand for expected.\n\t(cas_short_expected_pred): New.\n\t(@aarch64_compare_and_swap<SHORT>): Use it; use \"rn\" not \"rI\" to match.\n\t(@aarch64_compare_and_swap<GPI>): Use \"rn\" not \"rI\" for expected.\n\t* config/aarch64/predicates.md (aarch64_plushi_immediate): New.\n\t(aarch64_plushi_operand): New.\n\nFrom-SVN: r265657", "tree": {"sha": "08710f98cae30de9be33b762f03784aa1a42c07b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08710f98cae30de9be33b762f03784aa1a42c07b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d400fda3a8c3330f77eb9d51874f5482d3819a9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d400fda3a8c3330f77eb9d51874f5482d3819a9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d400fda3a8c3330f77eb9d51874f5482d3819a9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d400fda3a8c3330f77eb9d51874f5482d3819a9f/comments", "author": {"login": "rth7680", "id": 2529319, "node_id": "MDQ6VXNlcjI1MjkzMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2529319?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rth7680", "html_url": "https://github.com/rth7680", "followers_url": "https://api.github.com/users/rth7680/followers", "following_url": "https://api.github.com/users/rth7680/following{/other_user}", "gists_url": "https://api.github.com/users/rth7680/gists{/gist_id}", "starred_url": "https://api.github.com/users/rth7680/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rth7680/subscriptions", "organizations_url": "https://api.github.com/users/rth7680/orgs", "repos_url": "https://api.github.com/users/rth7680/repos", "events_url": "https://api.github.com/users/rth7680/events{/privacy}", "received_events_url": "https://api.github.com/users/rth7680/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "77f33f44baf24c22848197aa80962c003dd7b3e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77f33f44baf24c22848197aa80962c003dd7b3e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77f33f44baf24c22848197aa80962c003dd7b3e2"}], "stats": {"total": 131, "additions": 87, "deletions": 44}, "files": [{"sha": "09383706ff46370b75db408a58552adb6a9eb57e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d400fda3a8c3330f77eb9d51874f5482d3819a9f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d400fda3a8c3330f77eb9d51874f5482d3819a9f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d400fda3a8c3330f77eb9d51874f5482d3819a9f", "patch": "@@ -1,5 +1,17 @@\n 2018-10-31  Richard Henderson  <richard.henderson@linaro.org>\n \n+\t* config/aarch64/aarch64.c (aarch64_gen_compare_reg_maybe_ze): New.\n+\t(aarch64_split_compare_and_swap): Use it.\n+\t(aarch64_expand_compare_and_swap): Likewise.  Remove convert_modes;\n+\ttest oldval against the proper predicate.\n+\t* config/aarch64/atomics.md (@atomic_compare_and_swap<ALLI>):\n+\tUse nonmemory_operand for expected.\n+\t(cas_short_expected_pred): New.\n+\t(@aarch64_compare_and_swap<SHORT>): Use it; use \"rn\" not \"rI\" to match.\n+\t(@aarch64_compare_and_swap<GPI>): Use \"rn\" not \"rI\" for expected.\n+\t* config/aarch64/predicates.md (aarch64_plushi_immediate): New.\n+\t(aarch64_plushi_operand): New.\n+\n \t* config/aarch64/aarch64.c (aarch64_expand_compare_and_swap):\n \tForce oldval into the rval register for TARGET_LSE; emit the compare\n \tduring initial expansion so that it may be deleted if unused."}, {"sha": "7beda543e1433107ae1c0fa677ab28085af89329", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 52, "deletions": 36, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d400fda3a8c3330f77eb9d51874f5482d3819a9f/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d400fda3a8c3330f77eb9d51874f5482d3819a9f/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=d400fda3a8c3330f77eb9d51874f5482d3819a9f", "patch": "@@ -1614,6 +1614,33 @@ aarch64_gen_compare_reg (RTX_CODE code, rtx x, rtx y)\n   return cc_reg;\n }\n \n+/* Similarly, but maybe zero-extend Y if Y_MODE < SImode.  */\n+\n+static rtx\n+aarch64_gen_compare_reg_maybe_ze (RTX_CODE code, rtx x, rtx y,\n+                                  machine_mode y_mode)\n+{\n+  if (y_mode == E_QImode || y_mode == E_HImode)\n+    {\n+      if (CONST_INT_P (y))\n+\ty = GEN_INT (INTVAL (y) & GET_MODE_MASK (y_mode));\n+      else\n+\t{\n+\t  rtx t, cc_reg;\n+\t  machine_mode cc_mode;\n+\n+\t  t = gen_rtx_ZERO_EXTEND (SImode, y);\n+\t  t = gen_rtx_COMPARE (CC_SWPmode, t, x);\n+\t  cc_mode = CC_SWPmode;\n+\t  cc_reg = gen_rtx_REG (cc_mode, CC_REGNUM);\n+\t  emit_set_insn (cc_reg, t);\n+\t  return cc_reg;\n+\t}\n+    }\n+\n+  return aarch64_gen_compare_reg (code, x, y);\n+}\n+\n /* Build the SYMBOL_REF for __tls_get_addr.  */\n \n static GTY(()) rtx tls_get_addr_libfunc;\n@@ -14575,8 +14602,8 @@ aarch64_emit_unlikely_jump (rtx insn)\n void\n aarch64_expand_compare_and_swap (rtx operands[])\n {\n-  rtx bval, rval, mem, oldval, newval, is_weak, mod_s, mod_f, x;\n-  machine_mode mode, cmp_mode;\n+  rtx bval, rval, mem, oldval, newval, is_weak, mod_s, mod_f, x, cc_reg;\n+  machine_mode mode, r_mode;\n \n   bval = operands[0];\n   rval = operands[1];\n@@ -14587,63 +14614,52 @@ aarch64_expand_compare_and_swap (rtx operands[])\n   mod_s = operands[6];\n   mod_f = operands[7];\n   mode = GET_MODE (mem);\n-  cmp_mode = mode;\n \n   /* Normally the succ memory model must be stronger than fail, but in the\n      unlikely event of fail being ACQUIRE and succ being RELEASE we need to\n      promote succ to ACQ_REL so that we don't lose the acquire semantics.  */\n-\n   if (is_mm_acquire (memmodel_from_int (INTVAL (mod_f)))\n       && is_mm_release (memmodel_from_int (INTVAL (mod_s))))\n     mod_s = GEN_INT (MEMMODEL_ACQ_REL);\n \n-  switch (mode)\n+  r_mode = mode;\n+  if (mode == QImode || mode == HImode)\n     {\n-    case E_QImode:\n-    case E_HImode:\n-      /* For short modes, we're going to perform the comparison in SImode,\n-\t so do the zero-extension now.  */\n-      cmp_mode = SImode;\n-      rval = gen_reg_rtx (SImode);\n-      oldval = convert_modes (SImode, mode, oldval, true);\n-      /* Fall through.  */\n-\n-    case E_SImode:\n-    case E_DImode:\n-      /* Force the value into a register if needed.  */\n-      if (!aarch64_plus_operand (oldval, mode))\n-\toldval = force_reg (cmp_mode, oldval);\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n+      r_mode = SImode;\n+      rval = gen_reg_rtx (r_mode);\n     }\n \n   if (TARGET_LSE)\n     {\n       /* The CAS insn requires oldval and rval overlap, but we need to\n \t have a copy of oldval saved across the operation to tell if\n \t the operation is successful.  */\n-      if (mode == QImode || mode == HImode)\n-\trval = copy_to_mode_reg (SImode, gen_lowpart (SImode, oldval));\n-      else if (reg_overlap_mentioned_p (rval, oldval))\n-        rval = copy_to_mode_reg (mode, oldval);\n+      if (reg_overlap_mentioned_p (rval, oldval))\n+        rval = copy_to_mode_reg (r_mode, oldval);\n       else\n-\temit_move_insn (rval, oldval);\n+\temit_move_insn (rval, gen_lowpart (r_mode, oldval));\n+\n       emit_insn (gen_aarch64_compare_and_swap_lse (mode, rval, mem,\n \t\t\t\t\t\t   newval, mod_s));\n-      aarch64_gen_compare_reg (EQ, rval, oldval);\n+      cc_reg = aarch64_gen_compare_reg_maybe_ze (NE, rval, oldval, mode);\n     }\n   else\n-    emit_insn (gen_aarch64_compare_and_swap (mode, rval, mem, oldval, newval,\n-\t\t\t\t\t     is_weak, mod_s, mod_f));\n+    {\n+      /* The oldval predicate varies by mode.  Test it and force to reg.  */\n+      insn_code code = code_for_aarch64_compare_and_swap (mode);\n+      if (!insn_data[code].operand[2].predicate (oldval, mode))\n+\toldval = force_reg (mode, oldval);\n \n-  if (mode == QImode || mode == HImode)\n+      emit_insn (GEN_FCN (code) (rval, mem, oldval, newval,\n+\t\t\t\t is_weak, mod_s, mod_f));\n+      cc_reg = gen_rtx_REG (CCmode, CC_REGNUM);\n+    }\n+\n+  if (r_mode != mode)\n     rval = gen_lowpart (mode, rval);\n   emit_move_insn (operands[1], rval);\n \n-  x = gen_rtx_REG (CCmode, CC_REGNUM);\n-  x = gen_rtx_EQ (SImode, x, const0_rtx);\n+  x = gen_rtx_EQ (SImode, cc_reg, const0_rtx);\n   emit_insn (gen_rtx_SET (bval, x));\n }\n \n@@ -14758,10 +14774,10 @@ aarch64_split_compare_and_swap (rtx operands[])\n     }\n   else\n     {\n-      cond = aarch64_gen_compare_reg (NE, rval, oldval);\n+      cond = aarch64_gen_compare_reg_maybe_ze (NE, rval, oldval, mode);\n       x = gen_rtx_NE (VOIDmode, cond, const0_rtx);\n       x = gen_rtx_IF_THEN_ELSE (VOIDmode, x,\n-\t\t\t\t gen_rtx_LABEL_REF (Pmode, label2), pc_rtx);\n+\t\t\t\tgen_rtx_LABEL_REF (Pmode, label2), pc_rtx);\n       aarch64_emit_unlikely_jump (gen_rtx_SET (pc_rtx, x));\n     }\n "}, {"sha": "e44301b40c7bcc3993e59df3ca9f18b6679c471f", "filename": "gcc/config/aarch64/atomics.md", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d400fda3a8c3330f77eb9d51874f5482d3819a9f/gcc%2Fconfig%2Faarch64%2Fatomics.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d400fda3a8c3330f77eb9d51874f5482d3819a9f/gcc%2Fconfig%2Faarch64%2Fatomics.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fatomics.md?ref=d400fda3a8c3330f77eb9d51874f5482d3819a9f", "patch": "@@ -24,8 +24,8 @@\n   [(match_operand:SI 0 \"register_operand\" \"\")\t\t\t;; bool out\n    (match_operand:ALLI 1 \"register_operand\" \"\")\t\t\t;; val out\n    (match_operand:ALLI 2 \"aarch64_sync_memory_operand\" \"\")\t;; memory\n-   (match_operand:ALLI 3 \"general_operand\" \"\")\t\t\t;; expected\n-   (match_operand:ALLI 4 \"aarch64_reg_or_zero\" \"\")\t\t\t;; desired\n+   (match_operand:ALLI 3 \"nonmemory_operand\" \"\")\t\t;; expected\n+   (match_operand:ALLI 4 \"aarch64_reg_or_zero\" \"\")\t\t;; desired\n    (match_operand:SI 5 \"const_int_operand\")\t\t\t;; is_weak\n    (match_operand:SI 6 \"const_int_operand\")\t\t\t;; mod_s\n    (match_operand:SI 7 \"const_int_operand\")]\t\t\t;; mod_f\n@@ -36,19 +36,22 @@\n   }\n )\n \n+(define_mode_attr cas_short_expected_pred\n+  [(QI \"aarch64_reg_or_imm\") (HI \"aarch64_plushi_operand\")])\n+\n (define_insn_and_split \"@aarch64_compare_and_swap<mode>\"\n   [(set (reg:CC CC_REGNUM)\t\t\t\t\t;; bool out\n     (unspec_volatile:CC [(const_int 0)] UNSPECV_ATOMIC_CMPSW))\n-   (set (match_operand:SI 0 \"register_operand\" \"=&r\")\t   ;; val out\n+   (set (match_operand:SI 0 \"register_operand\" \"=&r\")\t\t;; val out\n     (zero_extend:SI\n       (match_operand:SHORT 1 \"aarch64_sync_memory_operand\" \"+Q\"))) ;; memory\n    (set (match_dup 1)\n     (unspec_volatile:SHORT\n-      [(match_operand:SI 2 \"aarch64_plus_operand\" \"rI\")\t;; expected\n+      [(match_operand:SHORT 2 \"<cas_short_expected_pred>\" \"rn\")\t;; expected\n        (match_operand:SHORT 3 \"aarch64_reg_or_zero\" \"rZ\")\t;; desired\n-       (match_operand:SI 4 \"const_int_operand\")\t\t;; is_weak\n-       (match_operand:SI 5 \"const_int_operand\")\t\t;; mod_s\n-       (match_operand:SI 6 \"const_int_operand\")]\t;; mod_f\n+       (match_operand:SI 4 \"const_int_operand\")\t\t\t;; is_weak\n+       (match_operand:SI 5 \"const_int_operand\")\t\t\t;; mod_s\n+       (match_operand:SI 6 \"const_int_operand\")]\t\t;; mod_f\n       UNSPECV_ATOMIC_CMPSW))\n    (clobber (match_scratch:SI 7 \"=&r\"))]\n   \"\"\n@@ -68,7 +71,7 @@\n     (match_operand:GPI 1 \"aarch64_sync_memory_operand\" \"+Q\"))   ;; memory\n    (set (match_dup 1)\n     (unspec_volatile:GPI\n-      [(match_operand:GPI 2 \"aarch64_plus_operand\" \"rI\")\t;; expect\n+      [(match_operand:GPI 2 \"aarch64_plus_operand\" \"rn\")\t;; expect\n        (match_operand:GPI 3 \"aarch64_reg_or_zero\" \"rZ\")\t\t;; desired\n        (match_operand:SI 4 \"const_int_operand\")\t\t\t;; is_weak\n        (match_operand:SI 5 \"const_int_operand\")\t\t\t;; mod_s"}, {"sha": "4c75eff3e5a25d5a6f0889669d1823191bf90819", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d400fda3a8c3330f77eb9d51874f5482d3819a9f/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d400fda3a8c3330f77eb9d51874f5482d3819a9f/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=d400fda3a8c3330f77eb9d51874f5482d3819a9f", "patch": "@@ -114,6 +114,18 @@\n   (ior (match_operand 0 \"register_operand\")\n        (match_operand 0 \"aarch64_plus_immediate\")))\n \n+(define_predicate \"aarch64_plushi_immediate\"\n+  (match_code \"const_int\")\n+{\n+  HOST_WIDE_INT val = INTVAL (op);\n+  /* The HImode value must be zero-extendable to an SImode plus_operand.  */\n+  return ((val & 0xfff) == val || sext_hwi (val & 0xf000, 16) == val);\n+})\n+\n+(define_predicate \"aarch64_plushi_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"aarch64_plushi_immediate\")))\n+\n (define_predicate \"aarch64_pluslong_immediate\"\n   (and (match_code \"const_int\")\n        (match_test \"(INTVAL (op) < 0xffffff && INTVAL (op) > -0xffffff)\")))"}]}