{"sha": "a1cd4d52d6ef90b977fb2d80c1cf17f3efa5b01d", "node_id": "C_kwDOANBUbNoAKGExY2Q0ZDUyZDZlZjkwYjk3N2ZiMmQ4MGMxY2YxN2YzZWZhNWIwMWQ", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-19T13:11:14Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-09-29T07:34:00Z"}, "message": "tree-optimization/105646 - re-interpret always executed in uninit diag\n\nThe following fixes PR105646, not diagnosing\n\nint f1();\nint f3(){\n    auto const & a = f1();\n    bool v3{v3};\n    return a;\n}\n\nwith optimization because the early uninit diagnostic pass only\ndiagnoses always executed cases.  The patch does this by\nre-interpreting what always executed means and choosing to\nignore exceptional and abnormal control flow for this.  At the\nsame time it improves things as suggested in a comment - when\nthe value-numbering run done without optimizing figures there's\na fallthru path, consider blocks on it as always executed.\n\n\tPR tree-optimization/105646\n\t* tree-ssa-uninit.cc (warn_uninitialized_vars): Pre-compute\n\tthe set of fallthru reachable blocks from function entry\n\tand use that to determine wlims.always_executed.\n\n\t* g++.dg/uninit-pr105646.C: New testcase.", "tree": {"sha": "67f6b47a8a794aa643f366698bf2ee4e8407d691", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67f6b47a8a794aa643f366698bf2ee4e8407d691"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1cd4d52d6ef90b977fb2d80c1cf17f3efa5b01d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1cd4d52d6ef90b977fb2d80c1cf17f3efa5b01d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1cd4d52d6ef90b977fb2d80c1cf17f3efa5b01d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1cd4d52d6ef90b977fb2d80c1cf17f3efa5b01d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f758d447d7f4699253c9f8ee345ba9b8357cdb22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f758d447d7f4699253c9f8ee345ba9b8357cdb22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f758d447d7f4699253c9f8ee345ba9b8357cdb22"}], "stats": {"total": 27, "additions": 25, "deletions": 2}, "files": [{"sha": "48ceb986ec66557a79a118d1e964925bbd5d7fd8", "filename": "gcc/testsuite/g++.dg/uninit-pr105646.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1cd4d52d6ef90b977fb2d80c1cf17f3efa5b01d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pr105646.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1cd4d52d6ef90b977fb2d80c1cf17f3efa5b01d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pr105646.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pr105646.C?ref=a1cd4d52d6ef90b977fb2d80c1cf17f3efa5b01d", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile }\n+// { dg-require-effective-target c++11 }\n+// { dg-options \"-O2 -Wuninitialized\" }\n+\n+int f1();\n+int f2(){\n+    bool v2{v2}; // { dg-warning \"is used uninitialized\" }\n+    auto const & a = f1();\n+    return a;\n+}\n+int f3(){\n+    auto const & a = f1();\n+    // Diagnose the following when optimizing and as unconditional\n+    // uninitialized use despite f1 possibly throwing\n+    bool v3{v3}; // { dg-warning \"is used uninitialized\" }\n+    return a;\n+}"}, {"sha": "bde23997a0ada2b18403477609c56704ebac4459", "filename": "gcc/tree-ssa-uninit.cc", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1cd4d52d6ef90b977fb2d80c1cf17f3efa5b01d/gcc%2Ftree-ssa-uninit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1cd4d52d6ef90b977fb2d80c1cf17f3efa5b01d/gcc%2Ftree-ssa-uninit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.cc?ref=a1cd4d52d6ef90b977fb2d80c1cf17f3efa5b01d", "patch": "@@ -991,14 +991,20 @@ warn_uninitialized_vars (bool wmaybe_uninit)\n   auto_bb_flag ft_reachable (cfun);\n \n   /* Mark blocks that are always executed when we ignore provably\n-     not executed edges.  */\n+     not executed and EH and abnormal edges.  */\n   basic_block bb = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n   while (!(bb->flags & ft_reachable))\n     {\n       bb->flags |= ft_reachable;\n+      edge e = find_fallthru_edge (bb->succs);\n+      if (e && e->flags & EDGE_EXECUTABLE)\n+\t{\n+\t  bb = e->dest;\n+\t  continue;\n+\t}\n       /* Find a single executable edge.  */\n       edge_iterator ei;\n-      edge e, ee = NULL;\n+      edge ee = NULL;\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (e->flags & EDGE_EXECUTABLE)\n \t  {"}]}