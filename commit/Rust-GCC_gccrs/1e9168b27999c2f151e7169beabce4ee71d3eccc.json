{"sha": "1e9168b27999c2f151e7169beabce4ee71d3eccc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU5MTY4YjI3OTk5YzJmMTUxZTcxNjliZWFiY2U0ZWU3MWQzZWNjYw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-08-10T09:43:06Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-08-10T09:43:06Z"}, "message": "Introduce __builtin_expect_with_probability (PR target/83610).\n\n2018-08-10  Martin Liska  <mliska@suse.cz>\n\n        PR target/83610\n\t* builtin-types.def (BT_FN_LONG_LONG_LONG_DOUBLE): Add new\n        function type.\n\t* builtins.c (expand_builtin_expect_with_probability):\n        New function.\n\t(expand_builtin_expect_with_probability): New function.\n\t(build_builtin_expect_predicate): Add new argumnet probability\n        for BUILT_IN_EXPECT_WITH_PROBABILITY.\n\t(fold_builtin_expect):\n\t(fold_builtin_2):\n\t(fold_builtin_3):\n\t* builtins.def (BUILT_IN_EXPECT_WITH_PROBABILITY):\n\t* builtins.h (fold_builtin_expect): Set new argument.\n\t* doc/extend.texi: Document __builtin_expect_with_probability.\n\t* doc/invoke.texi: Likewise.\n\t* gimple-fold.c (gimple_fold_call): Pass new argument.\n\t* ipa-fnsummary.c (find_foldable_builtin_expect): Handle\n        also BUILT_IN_EXPECT_WITH_PROBABILITY.\n\t* predict.c (get_predictor_value): New function.\n\t(expr_expected_value): Add new argument probability. Assume\n        that predictor and probability are always non-null.\n\t(expr_expected_value_1): Likewise.  For __builtin_expect and\n        __builtin_expect_with_probability set probability.  Handle\n        combination in binary expressions.\n\t(tree_predict_by_opcode): Simplify code by simply calling\n        get_predictor_value.\n\t(pass_strip_predict_hints::execute): Add handling of\n        BUILT_IN_EXPECT_WITH_PROBABILITY.\n\t* predict.def (PRED_BUILTIN_EXPECT_WITH_PROBABILITY): Add\n        new predictor.\n\t* tree.h (DECL_BUILT_IN_P): New function.\n2018-08-10  Martin Liska  <mliska@suse.cz>\n\n        PR target/83610\n\t* gcc.dg/predict-17.c: New test.\n\t* gcc.dg/predict-18.c: New test.\n\t* gcc.dg/predict-19.c: New test.\n\nFrom-SVN: r263466", "tree": {"sha": "a3137d2cf87f2981a38c27770ac4df9f144bb23b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3137d2cf87f2981a38c27770ac4df9f144bb23b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e9168b27999c2f151e7169beabce4ee71d3eccc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e9168b27999c2f151e7169beabce4ee71d3eccc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e9168b27999c2f151e7169beabce4ee71d3eccc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e9168b27999c2f151e7169beabce4ee71d3eccc/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7a096965f668c1d2129c70c92e2398227b97eee6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a096965f668c1d2129c70c92e2398227b97eee6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a096965f668c1d2129c70c92e2398227b97eee6"}], "stats": {"total": 357, "additions": 289, "deletions": 68}, "files": [{"sha": "28e44cf455d774b110fda651ec5d70a6a722fe07", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e9168b27999c2f151e7169beabce4ee71d3eccc", "patch": "@@ -1,3 +1,37 @@\n+2018-08-10  Martin Liska  <mliska@suse.cz>\n+\n+        PR target/83610\n+\t* builtin-types.def (BT_FN_LONG_LONG_LONG_DOUBLE): Add new\n+        function type.\n+\t* builtins.c (expand_builtin_expect_with_probability):\n+        New function.\n+\t(expand_builtin_expect_with_probability): New function.\n+\t(build_builtin_expect_predicate): Add new argumnet probability\n+        for BUILT_IN_EXPECT_WITH_PROBABILITY.\n+\t(fold_builtin_expect):\n+\t(fold_builtin_2):\n+\t(fold_builtin_3):\n+\t* builtins.def (BUILT_IN_EXPECT_WITH_PROBABILITY):\n+\t* builtins.h (fold_builtin_expect): Set new argument.\n+\t* doc/extend.texi: Document __builtin_expect_with_probability.\n+\t* doc/invoke.texi: Likewise.\n+\t* gimple-fold.c (gimple_fold_call): Pass new argument.\n+\t* ipa-fnsummary.c (find_foldable_builtin_expect): Handle\n+        also BUILT_IN_EXPECT_WITH_PROBABILITY.\n+\t* predict.c (get_predictor_value): New function.\n+\t(expr_expected_value): Add new argument probability. Assume\n+        that predictor and probability are always non-null.\n+\t(expr_expected_value_1): Likewise.  For __builtin_expect and\n+        __builtin_expect_with_probability set probability.  Handle\n+        combination in binary expressions.\n+\t(tree_predict_by_opcode): Simplify code by simply calling\n+        get_predictor_value.\n+\t(pass_strip_predict_hints::execute): Add handling of\n+        BUILT_IN_EXPECT_WITH_PROBABILITY.\n+\t* predict.def (PRED_BUILTIN_EXPECT_WITH_PROBABILITY): Add\n+        new predictor.\n+\t* tree.h (DECL_BUILT_IN_P): New function.\n+\n 2018-08-10  Martin Liska  <mliska@suse.cz>\n \n         PR tree-optimization/85799"}, {"sha": "f13da6a188c9c3d4797bb8623b58a830cc928423", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=1e9168b27999c2f151e7169beabce4ee71d3eccc", "patch": "@@ -531,6 +531,8 @@ DEF_FUNCTION_TYPE_3 (BT_FN_ULONG_ULONG_ULONG_ULONG,\n \t\t     BT_ULONG, BT_ULONG, BT_ULONG, BT_ULONG)\n DEF_FUNCTION_TYPE_3 (BT_FN_LONG_LONG_UINT_UINT,\n \t\t     BT_LONG, BT_LONG, BT_UINT, BT_UINT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_LONG_LONG_LONG_DOUBLE,\n+\t\t     BT_LONG, BT_LONG, BT_LONG, BT_DOUBLE)\n DEF_FUNCTION_TYPE_3 (BT_FN_ULONG_ULONG_UINT_UINT,\n \t\t     BT_ULONG, BT_ULONG, BT_UINT, BT_UINT)\n DEF_FUNCTION_TYPE_3 (BT_FN_STRING_CONST_STRING_CONST_STRING_INT,"}, {"sha": "867d153d79880b909dc05bbce83c076405d0b5d7", "filename": "gcc/builtins.c", "status": "modified", "additions": 51, "deletions": 14, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=1e9168b27999c2f151e7169beabce4ee71d3eccc", "patch": "@@ -148,6 +148,7 @@ static rtx expand_builtin_unop (machine_mode, tree, rtx, rtx, optab);\n static rtx expand_builtin_frame_address (tree, tree);\n static tree stabilize_va_list_loc (location_t, tree, int);\n static rtx expand_builtin_expect (tree, rtx);\n+static rtx expand_builtin_expect_with_probability (tree, rtx);\n static tree fold_builtin_constant_p (tree);\n static tree fold_builtin_classify_type (tree);\n static tree fold_builtin_strlen (location_t, tree, tree);\n@@ -5251,6 +5252,27 @@ expand_builtin_expect (tree exp, rtx target)\n   return target;\n }\n \n+/* Expand a call to __builtin_expect_with_probability.  We just return our\n+   argument as the builtin_expect semantic should've been already executed by\n+   tree branch prediction pass.  */\n+\n+static rtx\n+expand_builtin_expect_with_probability (tree exp, rtx target)\n+{\n+  tree arg;\n+\n+  if (call_expr_nargs (exp) < 3)\n+    return const0_rtx;\n+  arg = CALL_EXPR_ARG (exp, 0);\n+\n+  target = expand_expr (arg, target, VOIDmode, EXPAND_NORMAL);\n+  /* When guessing was done, the hints should be already stripped away.  */\n+  gcc_assert (!flag_guess_branch_prob\n+\t      || optimize == 0 || seen_error ());\n+  return target;\n+}\n+\n+\n /* Expand a call to __builtin_assume_aligned.  We just return our first\n    argument as the builtin_assume_aligned semantic should've been already\n    executed by CCP.  */\n@@ -7562,6 +7584,8 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n       return expand_builtin_va_copy (exp);\n     case BUILT_IN_EXPECT:\n       return expand_builtin_expect (exp, target);\n+    case BUILT_IN_EXPECT_WITH_PROBABILITY:\n+      return expand_builtin_expect_with_probability (exp, target);\n     case BUILT_IN_ASSUME_ALIGNED:\n       return expand_builtin_assume_aligned (exp, target);\n     case BUILT_IN_PREFETCH:\n@@ -8213,35 +8237,44 @@ fold_builtin_constant_p (tree arg)\n   return NULL_TREE;\n }\n \n-/* Create builtin_expect with PRED and EXPECTED as its arguments and\n-   return it as a truthvalue.  */\n+/* Create builtin_expect or builtin_expect_with_probability\n+   with PRED and EXPECTED as its arguments and return it as a truthvalue.\n+   Fortran FE can also produce builtin_expect with PREDICTOR as third argument.\n+   builtin_expect_with_probability instead uses third argument as PROBABILITY\n+   value.  */\n \n static tree\n build_builtin_expect_predicate (location_t loc, tree pred, tree expected,\n-\t\t\t\ttree predictor)\n+\t\t\t\ttree predictor, tree probability)\n {\n   tree fn, arg_types, pred_type, expected_type, call_expr, ret_type;\n \n-  fn = builtin_decl_explicit (BUILT_IN_EXPECT);\n+  fn = builtin_decl_explicit (probability == NULL_TREE ? BUILT_IN_EXPECT\n+\t\t\t      : BUILT_IN_EXPECT_WITH_PROBABILITY);\n   arg_types = TYPE_ARG_TYPES (TREE_TYPE (fn));\n   ret_type = TREE_TYPE (TREE_TYPE (fn));\n   pred_type = TREE_VALUE (arg_types);\n   expected_type = TREE_VALUE (TREE_CHAIN (arg_types));\n \n   pred = fold_convert_loc (loc, pred_type, pred);\n   expected = fold_convert_loc (loc, expected_type, expected);\n-  call_expr = build_call_expr_loc (loc, fn, predictor ? 3 : 2, pred, expected,\n-\t\t\t\t   predictor);\n+\n+  if (probability)\n+    call_expr = build_call_expr_loc (loc, fn, 3, pred, expected, probability);\n+  else\n+    call_expr = build_call_expr_loc (loc, fn, predictor ? 3 : 2, pred, expected,\n+\t\t\t\t     predictor);\n \n   return build2 (NE_EXPR, TREE_TYPE (pred), call_expr,\n \t\t build_int_cst (ret_type, 0));\n }\n \n-/* Fold a call to builtin_expect with arguments ARG0 and ARG1.  Return\n+/* Fold a call to builtin_expect with arguments ARG0, ARG1, ARG2, ARG3.  Return\n    NULL_TREE if no simplification is possible.  */\n \n tree\n-fold_builtin_expect (location_t loc, tree arg0, tree arg1, tree arg2)\n+fold_builtin_expect (location_t loc, tree arg0, tree arg1, tree arg2,\n+\t\t     tree arg3)\n {\n   tree inner, fndecl, inner_arg0;\n   enum tree_code code;\n@@ -8265,8 +8298,9 @@ fold_builtin_expect (location_t loc, tree arg0, tree arg1, tree arg2)\n \n   if (TREE_CODE (inner) == CALL_EXPR\n       && (fndecl = get_callee_fndecl (inner))\n-      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n-      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_EXPECT)\n+      && (DECL_BUILT_IN_P (fndecl, BUILT_IN_NORMAL, BUILT_IN_EXPECT)\n+\t  || DECL_BUILT_IN_P (fndecl, BUILT_IN_NORMAL,\n+\t\t\t      BUILT_IN_EXPECT_WITH_PROBABILITY)))\n     return arg0;\n \n   inner = inner_arg0;\n@@ -8277,8 +8311,8 @@ fold_builtin_expect (location_t loc, tree arg0, tree arg1, tree arg2)\n       tree op1 = TREE_OPERAND (inner, 1);\n       arg1 = save_expr (arg1);\n \n-      op0 = build_builtin_expect_predicate (loc, op0, arg1, arg2);\n-      op1 = build_builtin_expect_predicate (loc, op1, arg1, arg2);\n+      op0 = build_builtin_expect_predicate (loc, op0, arg1, arg2, arg3);\n+      op1 = build_builtin_expect_predicate (loc, op1, arg1, arg2, arg3);\n       inner = build2 (code, TREE_TYPE (inner), op0, op1);\n \n       return fold_convert_loc (loc, TREE_TYPE (arg0), inner);\n@@ -9374,7 +9408,7 @@ fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1)\n       return fold_builtin_strpbrk (loc, arg0, arg1, type);\n \n     case BUILT_IN_EXPECT:\n-      return fold_builtin_expect (loc, arg0, arg1, NULL_TREE);\n+      return fold_builtin_expect (loc, arg0, arg1, NULL_TREE, NULL_TREE);\n \n     case BUILT_IN_ISGREATER:\n       return fold_builtin_unordered_cmp (loc, fndecl,\n@@ -9452,7 +9486,10 @@ fold_builtin_3 (location_t loc, tree fndecl,\n       return fold_builtin_memcmp (loc, arg0, arg1, arg2);\n \n     case BUILT_IN_EXPECT:\n-      return fold_builtin_expect (loc, arg0, arg1, arg2);\n+      return fold_builtin_expect (loc, arg0, arg1, arg2, NULL_TREE);\n+\n+    case BUILT_IN_EXPECT_WITH_PROBABILITY:\n+      return fold_builtin_expect (loc, arg0, arg1, NULL_TREE, arg2);\n \n     case BUILT_IN_ADD_OVERFLOW:\n     case BUILT_IN_SUB_OVERFLOW:"}, {"sha": "ef89729fd0c4126b88a149064baa81abee6ed54f", "filename": "gcc/builtins.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=1e9168b27999c2f151e7169beabce4ee71d3eccc", "patch": "@@ -848,6 +848,7 @@ DEF_EXT_LIB_BUILTIN        (BUILT_IN_EXECVP, \"execvp\", BT_FN_INT_CONST_STRING_PT\n DEF_EXT_LIB_BUILTIN        (BUILT_IN_EXECVE, \"execve\", BT_FN_INT_CONST_STRING_PTR_CONST_STRING_PTR_CONST_STRING, ATTR_NOTHROW_LIST)\n DEF_LIB_BUILTIN        (BUILT_IN_EXIT, \"exit\", BT_FN_VOID_INT, ATTR_NORETURN_NOTHROW_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_EXPECT, \"expect\", BT_FN_LONG_LONG_LONG, ATTR_CONST_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_EXPECT_WITH_PROBABILITY, \"expect_with_probability\", BT_FN_LONG_LONG_LONG_DOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_ASSUME_ALIGNED, \"assume_aligned\", BT_FN_PTR_CONST_PTR_SIZE_VAR, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_EXTEND_POINTER, \"extend_pointer\", BT_FN_UNWINDWORD_PTR, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_EXTRACT_RETURN_ADDR, \"extract_return_addr\", BT_FN_PTR_PTR, ATTR_LEAF_LIST)"}, {"sha": "1113bd37f1b44c324ef3a6ffa31968d88bc51ea2", "filename": "gcc/builtins.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=1e9168b27999c2f151e7169beabce4ee71d3eccc", "patch": "@@ -77,7 +77,7 @@ extern void expand_ifn_atomic_compare_exchange (gcall *);\n extern rtx expand_builtin (tree, rtx, rtx, machine_mode, int);\n extern rtx expand_builtin_with_bounds (tree, rtx, rtx, machine_mode, int);\n extern enum built_in_function builtin_mathfn_code (const_tree);\n-extern tree fold_builtin_expect (location_t, tree, tree, tree);\n+extern tree fold_builtin_expect (location_t, tree, tree, tree, tree);\n extern bool avoid_folding_inline_builtin (tree);\n extern tree fold_call_expr (location_t, tree, bool);\n extern tree fold_builtin_call_array (location_t, tree, tree, int, tree *);"}, {"sha": "130f6a671ced6954176fd430b516a151d0207f81", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=1e9168b27999c2f151e7169beabce4ee71d3eccc", "patch": "@@ -11956,6 +11956,15 @@ if (__builtin_expect (ptr != NULL, 1))\n when testing pointer or floating-point values.\n @end deftypefn\n \n+@deftypefn {Built-in Function} long __builtin_expect_with_probability\n+(long @var{exp}, long @var{c}, long @var{probability})\n+\n+The built-in has same semantics as @code{__builtin_expect_with_probability},\n+but user can provide expected probability (in percent) for value of @var{exp}.\n+Last argument @var{probability} is of float type and valid values\n+are in inclusive range 0.0f and 1.0f.\n+@end deftypefn\n+\n @deftypefn {Built-in Function} void __builtin_trap (void)\n This function causes the program to exit abnormally.  GCC implements\n this function by using a target-dependent mechanism (such as"}, {"sha": "d7fd0e175555417e30f005830560735f008b2af3", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1e9168b27999c2f151e7169beabce4ee71d3eccc", "patch": "@@ -9218,6 +9218,9 @@ between the heuristics and @code{__builtin_expect} can be complex, and in\n some cases, it may be useful to disable the heuristics so that the effects\n of @code{__builtin_expect} are easier to understand.\n \n+It is also possible to specify expected probability of the expression\n+with @code{__builtin_expect_with_probability} built-in function.\n+\n The default is @option{-fguess-branch-probability} at levels\n @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.\n "}, {"sha": "42673b5e6c98448b89c683436a14f5b66a6b6060", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=1e9168b27999c2f151e7169beabce4ee71d3eccc", "patch": "@@ -4155,7 +4155,8 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n \t  result = fold_builtin_expect (gimple_location (stmt),\n \t\t\t\t\tgimple_call_arg (stmt, 0),\n \t\t\t\t\tgimple_call_arg (stmt, 1),\n-\t\t\t\t\tgimple_call_arg (stmt, 2));\n+\t\t\t\t\tgimple_call_arg (stmt, 2),\n+\t\t\t\t\tNULL_TREE);\n \t  break;\n \tcase IFN_UBSAN_OBJECT_SIZE:\n \t  {"}, {"sha": "a8fc2c2df9a64744dc03055fe3cf002bf96d0463", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=1e9168b27999c2f151e7169beabce4ee71d3eccc", "patch": "@@ -1851,6 +1851,7 @@ find_foldable_builtin_expect (basic_block bb)\n     {\n       gimple *stmt = gsi_stmt (bsi);\n       if (gimple_call_builtin_p (stmt, BUILT_IN_EXPECT)\n+\t  || gimple_call_builtin_p (stmt, BUILT_IN_EXPECT_WITH_PROBABILITY)\n \t  || gimple_call_internal_p (stmt, IFN_BUILTIN_EXPECT))\n         {\n           tree var = gimple_call_lhs (stmt);"}, {"sha": "3fbe3b704b318f46c8b65add32d19dc478795b7a", "filename": "gcc/predict.c", "status": "modified", "additions": 110, "deletions": 52, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=1e9168b27999c2f151e7169beabce4ee71d3eccc", "patch": "@@ -92,6 +92,7 @@ static void predict_paths_leading_to_edge (edge, enum br_predictor,\n \t\t\t\t\t   enum prediction,\n \t\t\t\t\t   struct loop *in_loop = NULL);\n static bool can_predict_insn_p (const rtx_insn *);\n+static HOST_WIDE_INT get_predictor_value (br_predictor, HOST_WIDE_INT);\n \n /* Information we hold about each branch predictor.\n    Filled using information from predict.def.  */\n@@ -2262,18 +2263,21 @@ guess_outgoing_edge_probabilities (basic_block bb)\n   combine_predictions_for_insn (BB_END (bb), bb);\n }\n \f\n-static tree expr_expected_value (tree, bitmap, enum br_predictor *predictor);\n+static tree expr_expected_value (tree, bitmap, enum br_predictor *predictor,\n+\t\t\t\t HOST_WIDE_INT *probability);\n \n /* Helper function for expr_expected_value.  */\n \n static tree\n expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n-\t\t       tree op1, bitmap visited, enum br_predictor *predictor)\n+\t\t       tree op1, bitmap visited, enum br_predictor *predictor,\n+\t\t       HOST_WIDE_INT *probability)\n {\n   gimple *def;\n \n-  if (predictor)\n-    *predictor = PRED_UNCONDITIONAL;\n+  /* Reset returned probability value.  */\n+  *probability = -1;\n+  *predictor = PRED_UNCONDITIONAL;\n \n   if (get_gimple_rhs_class (code) == GIMPLE_SINGLE_RHS)\n     {\n@@ -2292,8 +2296,7 @@ expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n \t\t{\n \t\t  /* Assume that any given atomic operation has low contention,\n \t\t     and thus the compare-and-swap operation succeeds.  */\n-\t\t  if (predictor)\n-\t\t    *predictor = PRED_COMPARE_AND_SWAP;\n+\t\t  *predictor = PRED_COMPARE_AND_SWAP;\n \t\t  return build_one_cst (TREE_TYPE (op0));\n \t\t}\n \t    }\n@@ -2329,11 +2332,12 @@ expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n \t      if (arg == PHI_RESULT (def))\n \t\tcontinue;\n \n-\t      new_val = expr_expected_value (arg, visited, &predictor2);\n+\t      new_val = expr_expected_value (arg, visited, &predictor2,\n+\t\t\t\t\t     probability);\n \n \t      /* It is difficult to combine value predictors.  Simply assume\n \t\t that later predictor is weaker and take its prediction.  */\n-\t      if (predictor && *predictor < predictor2)\n+\t      if (*predictor < predictor2)\n \t\t*predictor = predictor2;\n \t      if (!new_val)\n \t\treturn NULL;\n@@ -2353,7 +2357,7 @@ expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n \t\t\t\t\tgimple_assign_rhs1 (def),\n \t\t\t\t\tgimple_assign_rhs_code (def),\n \t\t\t\t\tgimple_assign_rhs2 (def),\n-\t\t\t\t\tvisited, predictor);\n+\t\t\t\t\tvisited, predictor, probability);\n \t}\n \n       if (is_gimple_call (def))\n@@ -2368,14 +2372,14 @@ expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n \t\t  tree val = gimple_call_arg (def, 0);\n \t\t  if (TREE_CONSTANT (val))\n \t\t    return val;\n-\t\t  if (predictor)\n-\t\t    {\n-\t\t      tree val2 = gimple_call_arg (def, 2);\n-\t\t      gcc_assert (TREE_CODE (val2) == INTEGER_CST\n-\t\t\t\t  && tree_fits_uhwi_p (val2)\n-\t\t\t\t  && tree_to_uhwi (val2) < END_PREDICTORS);\n-\t\t      *predictor = (enum br_predictor) tree_to_uhwi (val2);\n-\t\t    }\n+\t\t  tree val2 = gimple_call_arg (def, 2);\n+\t\t  gcc_assert (TREE_CODE (val2) == INTEGER_CST\n+\t\t\t      && tree_fits_uhwi_p (val2)\n+\t\t\t      && tree_to_uhwi (val2) < END_PREDICTORS);\n+\t\t  *predictor = (enum br_predictor) tree_to_uhwi (val2);\n+\t\t  if (*predictor == PRED_BUILTIN_EXPECT)\n+\t\t    *probability\n+\t\t      = HITRATE (PARAM_VALUE (BUILTIN_EXPECT_PROBABILITY));\n \t\t  return gimple_call_arg (def, 1);\n \t\t}\n \t      return NULL;\n@@ -2399,8 +2403,34 @@ expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n \t\t  val = gimple_call_arg (def, 0);\n \t\t  if (TREE_CONSTANT (val))\n \t\t    return val;\n-\t\t  if (predictor)\n-\t\t    *predictor = PRED_BUILTIN_EXPECT;\n+\t\t  *predictor = PRED_BUILTIN_EXPECT;\n+\t\t  *probability\n+\t\t    = HITRATE (PARAM_VALUE (BUILTIN_EXPECT_PROBABILITY));\n+\t\t  return gimple_call_arg (def, 1);\n+\t\t}\n+\t      case BUILT_IN_EXPECT_WITH_PROBABILITY:\n+\t\t{\n+\t\t  tree val;\n+\t\t  if (gimple_call_num_args (def) != 3)\n+\t\t    return NULL;\n+\t\t  val = gimple_call_arg (def, 0);\n+\t\t  if (TREE_CONSTANT (val))\n+\t\t    return val;\n+\t\t  /* Compute final probability as:\n+\t\t     probability * REG_BR_PROB_BASE.  */\n+\t\t  tree prob = gimple_call_arg (def, 2);\n+\t\t  tree t = TREE_TYPE (prob);\n+\t\t  tree base = build_int_cst (integer_type_node,\n+\t\t\t\t\t     REG_BR_PROB_BASE);\n+\t\t  base = build_real_from_int_cst (t, base);\n+\t\t  tree r = fold_build2 (MULT_EXPR, t, prob, base);\n+\t\t  HOST_WIDE_INT probi\n+\t\t    = real_to_integer (TREE_REAL_CST_PTR (r));\n+\t\t  if (probi >= 0 && probi <= REG_BR_PROB_BASE)\n+\t\t    {\n+\t\t      *predictor = PRED_BUILTIN_EXPECT_WITH_PROBABILITY;\n+\t\t      *probability = probi;\n+\t\t    }\n \t\t  return gimple_call_arg (def, 1);\n \t\t}\n \n@@ -2419,8 +2449,7 @@ expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n \t      case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_16:\n \t\t/* Assume that any given atomic operation has low contention,\n \t\t   and thus the compare-and-swap operation succeeds.  */\n-\t\tif (predictor)\n-\t\t  *predictor = PRED_COMPARE_AND_SWAP;\n+\t\t*predictor = PRED_COMPARE_AND_SWAP;\n \t\treturn boolean_true_node;\n \t      case BUILT_IN_REALLOC:\n \t\tif (predictor)\n@@ -2438,23 +2467,37 @@ expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n     {\n       tree res;\n       enum br_predictor predictor2;\n-      op0 = expr_expected_value (op0, visited, predictor);\n+      HOST_WIDE_INT probability2;\n+      op0 = expr_expected_value (op0, visited, predictor, probability);\n       if (!op0)\n \treturn NULL;\n-      op1 = expr_expected_value (op1, visited, &predictor2);\n-      if (predictor && *predictor < predictor2)\n-\t*predictor = predictor2;\n+      op1 = expr_expected_value (op1, visited, &predictor2, &probability2);\n       if (!op1)\n \treturn NULL;\n       res = fold_build2 (code, type, op0, op1);\n-      if (TREE_CONSTANT (res))\n-\treturn res;\n+      if (TREE_CODE (res) == INTEGER_CST\n+\t  && TREE_CODE (op0) == INTEGER_CST\n+\t  && TREE_CODE (op1) == INTEGER_CST)\n+\t{\n+\t  /* Combine binary predictions.  */\n+\t  if (*probability != -1 || probability2 != -1)\n+\t    {\n+\t      HOST_WIDE_INT p1 = get_predictor_value (*predictor, *probability);\n+\t      HOST_WIDE_INT p2 = get_predictor_value (predictor2, probability2);\n+\t      *probability = RDIV (p1 * p2, REG_BR_PROB_BASE);\n+\t    }\n+\n+\t  if (*predictor < predictor2)\n+\t    *predictor = predictor2;\n+\n+\t  return res;\n+\t}\n       return NULL;\n     }\n   if (get_gimple_rhs_class (code) == GIMPLE_UNARY_RHS)\n     {\n       tree res;\n-      op0 = expr_expected_value (op0, visited, predictor);\n+      op0 = expr_expected_value (op0, visited, predictor, probability);\n       if (!op0)\n \treturn NULL;\n       res = fold_build1 (code, type, op0);\n@@ -2475,23 +2518,44 @@ expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n \n static tree\n expr_expected_value (tree expr, bitmap visited,\n-\t\t     enum br_predictor *predictor)\n+\t\t     enum br_predictor *predictor,\n+\t\t     HOST_WIDE_INT *probability)\n {\n   enum tree_code code;\n   tree op0, op1;\n \n   if (TREE_CONSTANT (expr))\n     {\n-      if (predictor)\n-\t*predictor = PRED_UNCONDITIONAL;\n+      *predictor = PRED_UNCONDITIONAL;\n+      *probability = -1;\n       return expr;\n     }\n \n   extract_ops_from_tree (expr, &code, &op0, &op1);\n   return expr_expected_value_1 (TREE_TYPE (expr),\n-\t\t\t\top0, code, op1, visited, predictor);\n+\t\t\t\top0, code, op1, visited, predictor,\n+\t\t\t\tprobability);\n }\n \f\n+\n+/* Return probability of a PREDICTOR.  If the predictor has variable\n+   probability return passed PROBABILITY.  */\n+\n+static HOST_WIDE_INT\n+get_predictor_value (br_predictor predictor, HOST_WIDE_INT probability)\n+{\n+  switch (predictor)\n+    {\n+    case PRED_BUILTIN_EXPECT:\n+    case PRED_BUILTIN_EXPECT_WITH_PROBABILITY:\n+      gcc_assert (probability != -1);\n+      return probability;\n+    default:\n+      gcc_assert (probability == -1);\n+      return predictor_info[(int) predictor].hitrate;\n+    }\n+}\n+\n /* Predict using opcode of the last statement in basic block.  */\n static void\n tree_predict_by_opcode (basic_block bb)\n@@ -2504,6 +2568,7 @@ tree_predict_by_opcode (basic_block bb)\n   enum tree_code cmp;\n   edge_iterator ei;\n   enum br_predictor predictor;\n+  HOST_WIDE_INT probability;\n \n   if (!stmt || gimple_code (stmt) != GIMPLE_COND)\n     return;\n@@ -2515,21 +2580,13 @@ tree_predict_by_opcode (basic_block bb)\n   cmp = gimple_cond_code (stmt);\n   type = TREE_TYPE (op0);\n   val = expr_expected_value_1 (boolean_type_node, op0, cmp, op1, auto_bitmap (),\n-\t\t\t       &predictor);\n+\t\t\t       &predictor, &probability);\n   if (val && TREE_CODE (val) == INTEGER_CST)\n     {\n-      if (predictor == PRED_BUILTIN_EXPECT)\n-\t{\n-\t  int percent = PARAM_VALUE (BUILTIN_EXPECT_PROBABILITY);\n-\n-\t  gcc_assert (percent >= 0 && percent <= 100);\n-\t  if (integer_zerop (val))\n-\t    percent = 100 - percent;\n-\t  predict_edge (then_edge, PRED_BUILTIN_EXPECT, HITRATE (percent));\n-\t}\n-      else\n-\tpredict_edge_def (then_edge, predictor,\n-\t\t\t  integer_zerop (val) ? NOT_TAKEN : TAKEN);\n+      HOST_WIDE_INT prob = get_predictor_value (predictor, probability);\n+      if (integer_zerop (val))\n+\tprob = REG_BR_PROB_BASE - prob;\n+      predict_edge (then_edge, predictor, prob);\n     }\n   /* Try \"pointer heuristic.\"\n      A comparison ptr == 0 is predicted as false.\n@@ -3933,13 +3990,14 @@ strip_predict_hints (function *fun, bool early)\n \t    {\n \t      tree fndecl = gimple_call_fndecl (stmt);\n \n-\t      if ((!early\n-\t\t   && fndecl\n-\t\t   && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n-\t\t   && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_EXPECT\n-\t\t   && gimple_call_num_args (stmt) == 2)\n-\t\t  || (gimple_call_internal_p (stmt)\n-\t\t      && gimple_call_internal_fn (stmt) == IFN_BUILTIN_EXPECT))\n+\t      if (!early\n+\t\t  && ((DECL_BUILT_IN_P (fndecl, BUILT_IN_NORMAL, BUILT_IN_EXPECT)\n+\t\t       && gimple_call_num_args (stmt) == 2)\n+\t\t      || (DECL_BUILT_IN_P (fndecl, BUILT_IN_NORMAL,\n+\t\t\t\t\t   BUILT_IN_EXPECT_WITH_PROBABILITY)\n+\t\t\t  && gimple_call_num_args (stmt) == 3)\n+\t\t      || (gimple_call_internal_p (stmt)\n+\t\t\t  && gimple_call_internal_fn (stmt) == IFN_BUILTIN_EXPECT)))\n \t\t{\n \t\t  var = gimple_call_lhs (stmt);\n \t          changed = true;"}, {"sha": "e2a56f9595543b1e728e75a79390ee22a3d80d78", "filename": "gcc/predict.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Fpredict.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Fpredict.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.def?ref=1e9168b27999c2f151e7169beabce4ee71d3eccc", "patch": "@@ -73,6 +73,11 @@ DEF_PREDICTOR (PRED_COMPARE_AND_SWAP, \"compare and swap\", PROB_VERY_LIKELY,\n DEF_PREDICTOR (PRED_BUILTIN_EXPECT, \"__builtin_expect\", PROB_VERY_LIKELY,\n \t       PRED_FLAG_FIRST_MATCH)\n \n+/* Hints provided by user via __builtin_expect_with_probability.  */\n+DEF_PREDICTOR (PRED_BUILTIN_EXPECT_WITH_PROBABILITY,\n+\t       \"__builtin_expect_with_probability\", PROB_UNINITIALIZED,\n+\t       PRED_FLAG_FIRST_MATCH)\n+\n /* Use number of loop iterations guessed by the contents of the loop.  */\n DEF_PREDICTOR (PRED_LOOP_ITERATIONS_GUESSED, \"guessed loop iterations\",\n \t       PROB_UNINITIALIZED, PRED_FLAG_FIRST_MATCH)"}, {"sha": "af9e9c17aa435301b1ae500a527fd8bfc359efe6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1e9168b27999c2f151e7169beabce4ee71d3eccc", "patch": "@@ -1,3 +1,10 @@\n+2018-08-10  Martin Liska  <mliska@suse.cz>\n+\n+        PR target/83610\n+\t* gcc.dg/predict-17.c: New test.\n+\t* gcc.dg/predict-18.c: New test.\n+\t* gcc.dg/predict-19.c: New test.\n+\n 2018-08-10  Martin Liska  <mliska@suse.cz>\n \n         PR tree-optimization/85799"}, {"sha": "5069aa47c8c7df532d87dec5517e990d2cf0cc93", "filename": "gcc/testsuite/gcc.dg/predict-17.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-17.c?ref=1e9168b27999c2f151e7169beabce4ee71d3eccc", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-profile_estimate\" } */\n+\n+extern int global;\n+\n+void foo (int base)\n+{\n+  for (int i = 0; __builtin_expect_with_probability (i < base, 1, 0.05f); i++)\n+    global++;\n+}\n+\n+/* { dg-final { scan-tree-dump \"first match heuristics: 5.00%\" \"profile_estimate\"} } */\n+/* { dg-final { scan-tree-dump \"__builtin_expect_with_probability heuristics of edge .*->.*: 5.00%\" \"profile_estimate\"} } */"}, {"sha": "0c93638a9712f00b7e1f49244220eb36f10fd131", "filename": "gcc/testsuite/gcc.dg/predict-18.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-18.c?ref=1e9168b27999c2f151e7169beabce4ee71d3eccc", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-profile_estimate\" } */\n+\n+extern int global;\n+\n+int x;\n+\n+short v = 0;\n+short expected = 0;\n+short max = ~0;\n+#define STRONG 0\n+\n+void foo (int a, int b)\n+{\n+  if (__builtin_expect_with_probability (a < b, 1, 0.6f) > __builtin_expect (b, 0))\n+    global++;\n+\n+  if (__builtin_expect_with_probability (a < b, 1, 0.777f) > 0)\n+    global++;\n+\n+  if (__builtin_expect_with_probability (a < b, 1, 0.99) == __atomic_compare_exchange_n (&v, &expected, max, STRONG , __ATOMIC_RELAXED, __ATOMIC_RELAXED))\n+    global++;\n+\n+  if (__builtin_expect_with_probability (a < 10, 1, 0.9f) > __builtin_expect_with_probability (b, 0, 0.8f))\n+    global++;\n+}\n+\n+/* { dg-final { scan-tree-dump \"__builtin_expect_with_probability heuristics of edge .*->.*: 54.00%\" \"profile_estimate\"} } */\n+/* { dg-final { scan-tree-dump \"__builtin_expect_with_probability heuristics of edge .*->.*: 77.70%\" \"profile_estimate\"} } */\n+/* { dg-final { scan-tree-dump \"__builtin_expect_with_probability heuristics of edge .*->.*: 98.96%\" \"profile_estimate\"} } */\n+/* { dg-final { scan-tree-dump \"__builtin_expect_with_probability heuristics of edge .*->.*: 71.99%\" \"profile_estimate\"} } */"}, {"sha": "38ca25a16032e55975d092a4eed580fabdcbbc3b", "filename": "gcc/testsuite/gcc.dg/predict-19.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-19.c?ref=1e9168b27999c2f151e7169beabce4ee71d3eccc", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-profile_estimate\" } */\n+\n+extern int global;\n+\n+void foo (int base)\n+{\n+  if (__builtin_expect_with_probability (base == 100, 1, 0.001f))\n+    global++;\n+}\n+\n+/* { dg-final { scan-tree-dump \"first match heuristics: 0.10%\" \"profile_estimate\"} } */\n+/* { dg-final { scan-tree-dump \"__builtin_expect_with_probability heuristics of edge .*->.*: 0.10%\" \"profile_estimate\"} } */"}, {"sha": "648e9e2a3c4d500066b898878f7667b9e84e72b5", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e9168b27999c2f151e7169beabce4ee71d3eccc/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1e9168b27999c2f151e7169beabce4ee71d3eccc", "patch": "@@ -3008,6 +3008,12 @@ extern vec<tree, va_gc> **decl_debug_args_insert (tree);\n #define DECL_BUILT_IN_CLASS(NODE) \\\n    (FUNCTION_DECL_CHECK (NODE)->function_decl.built_in_class)\n \n+/* For a function declaration, return true if NODE is non-null and it is\n+   a builtin of a CLASS with requested NAME.  */\n+#define DECL_BUILT_IN_P(NODE, CLASS, NAME) \\\n+  (NODE != NULL_TREE && DECL_BUILT_IN_CLASS (NODE) == CLASS \\\n+   && DECL_FUNCTION_CODE (NODE) == NAME)\n+\n /* In FUNCTION_DECL, a chain of ..._DECL nodes.  */\n #define DECL_ARGUMENTS(NODE) \\\n    (FUNCTION_DECL_CHECK (NODE)->function_decl.arguments)"}]}