{"sha": "7485a52551d71db2e8bbfc4c484196bcc321a1cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ4NWE1MjU1MWQ3MWRiMmU4YmJmYzRjNDg0MTk2YmNjMzIxYTFjZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-09-08T12:06:10Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-09-08T12:06:10Z"}, "message": "i386: Fix up xorsign for AVX [PR89984]\n\nThinking about it more this morning, while this patch fixes the problems\nrevealed in the testcase, the recent PR89984 change was buggy too, but\nperhaps that can be fixed incrementally.  Because for AVX the new code\ndestructively modifies op1.  If that is different from dest, say on:\nfloat\nfoo (float x, float y)\n{\n  return x * __builtin_copysignf (1.0f, y) + y;\n}\nthen we get after RA:\n(insn 8 7 9 2 (set (reg:SF 20 xmm0 [orig:82 _2 ] [82])\n        (unspec:SF [\n                (reg:SF 20 xmm0 [88])\n                (reg:SF 21 xmm1 [89])\n                (mem/u/c:V4SF (symbol_ref/u:DI (\"*.LC0\") [flags 0x2]) [0  S16 A128])\n            ] UNSPEC_XORSIGN)) \"hohoho.c\":4:12 649 {xorsignsf3_1}\n     (nil))\n(insn 9 8 15 2 (set (reg:SF 20 xmm0 [87])\n        (plus:SF (reg:SF 20 xmm0 [orig:82 _2 ] [82])\n            (reg:SF 21 xmm1 [89]))) \"hohoho.c\":4:44 1021 {*fop_sf_comm}\n     (nil))\nbut split the xorsign into:\n        vandps  .LC0(%rip), %xmm1, %xmm1\n        vxorps  %xmm0, %xmm1, %xmm0\nand then the addition:\n        vaddss  %xmm1, %xmm0, %xmm0\nwhich means we miscompile it - instead of adding y in the end we add\n__builtin_copysignf (0.0f, y).\nSo, wonder if we don't want instead in addition to the &Yv <- Yv, 0\nalternative (enabled for both pre-AVX and AVX as in this patch) the\n&Yv <- Yv, Yv where destination must be different from inputs and another\nYv <- Yv, Yv where it can be the same but then need a match_scratch\n(with X for the other alternatives and =Yv for the last one).\nThat way we'd always have a safe register we can store the op1 & mask\nvalue into, either the destination (in the first alternative known to\nbe equal to op1 which is needed for non-AVX but ok for AVX too), in the\nsecond alternative known to be different from both inputs and in the third\nwhich could be used for those\nfloat bar (float x, float y) { return x * __builtin_copysignf (1.0f, y); }\ncases where op1 is naturally xmm1 and dest == op0 naturally xmm0 we'd use\nsome other register like xmm2.\n\nOn Wed, Sep 08, 2021 at 05:23:40PM +0800, Hongtao Liu wrote:\n> I'm curious why we need the  post_reload splitter @xorsign<mode>3_1\n> for scalar mode, can't we just expand them into and/xor operations in\n> the expander, just like vector modes did.\n\nFollowing seems to work for all the testcases I've tried (and in some\ngenerates better code than the post-reload splitter).\n\n2021-09-08  Jakub Jelinek  <jakub@redhat.com>\n\t    liuhongt  <hongtao.liu@intel.com>\n\n\tPR target/89984\n\t* config/i386/i386.md (@xorsign<mode>3_1): Remove.\n\t* config/i386/i386-expand.c (ix86_expand_xorsign): Expand right away\n\tinto AND with mask and XOR, using paradoxical subregs.\n\t(ix86_split_xorsign): Remove.\n\t* config/i386/i386-protos.h (ix86_split_xorsign): Remove.\n\n\t* gcc.target/i386/avx-pr102224.c: Fix up PR number.\n\t* gcc.dg/pr89984.c: New test.\n\t* gcc.target/i386/avx-pr89984.c: New test.", "tree": {"sha": "6953ba22bfc80b33e9f067c7f5b87aa229d06111", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6953ba22bfc80b33e9f067c7f5b87aa229d06111"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7485a52551d71db2e8bbfc4c484196bcc321a1cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7485a52551d71db2e8bbfc4c484196bcc321a1cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7485a52551d71db2e8bbfc4c484196bcc321a1cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7485a52551d71db2e8bbfc4c484196bcc321a1cd/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6576ad5add7e1891c379783316b85b88346963aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6576ad5add7e1891c379783316b85b88346963aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6576ad5add7e1891c379783316b85b88346963aa"}], "stats": {"total": 119, "additions": 51, "deletions": 68}, "files": [{"sha": "badbacc19d8af59afb54b5e44491ab211a83f2aa", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 7, "deletions": 52, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7485a52551d71db2e8bbfc4c484196bcc321a1cd/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7485a52551d71db2e8bbfc4c484196bcc321a1cd/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=7485a52551d71db2e8bbfc4c484196bcc321a1cd", "patch": "@@ -2270,7 +2270,7 @@ void\n ix86_expand_xorsign (rtx operands[])\n {\n   machine_mode mode, vmode;\n-  rtx dest, op0, op1, mask;\n+  rtx dest, op0, op1, mask, x, temp;\n \n   dest = operands[0];\n   op0 = operands[1];\n@@ -2285,60 +2285,15 @@ ix86_expand_xorsign (rtx operands[])\n   else\n     gcc_unreachable ();\n \n+  temp = gen_reg_rtx (vmode);\n   mask = ix86_build_signbit_mask (vmode, 0, 0);\n \n-  emit_insn (gen_xorsign3_1 (mode, dest, op0, op1, mask));\n-}\n-\n-/* Deconstruct an xorsign operation into bit masks.  */\n-\n-void\n-ix86_split_xorsign (rtx operands[])\n-{\n-  machine_mode mode, vmode;\n-  rtx dest, op0, op1, mask, x;\n-\n-  dest = operands[0];\n-  op0 = operands[1];\n-  op1 = operands[2];\n-  mask = operands[3];\n-\n-  mode = GET_MODE (dest);\n-  vmode = GET_MODE (mask);\n+  op1 = lowpart_subreg (vmode, op1, mode);\n+  x = gen_rtx_AND (vmode, op1, mask);\n+  emit_insn (gen_rtx_SET (temp, x));\n \n-  /* The constraints ensure that for non-AVX dest == op1 is\n-     different from op0, and for AVX that at most two of\n-     dest, op0 and op1 are the same register but the third one\n-     is different.  */\n-  if (rtx_equal_p (op0, op1))\n-    {\n-      gcc_assert (TARGET_AVX && !rtx_equal_p (op0, dest));\n-      if (vmode == V4SFmode)\n-\tvmode = V4SImode;\n-      else\n-\t{\n-\t  gcc_assert (vmode == V2DFmode);\n-\t  vmode = V2DImode;\n-\t}\n-      mask = lowpart_subreg (vmode, mask, GET_MODE (mask));\n-      if (MEM_P (mask))\n-\t{\n-\t  rtx msk = lowpart_subreg (vmode, dest, mode);\n-\t  emit_insn (gen_rtx_SET (msk, mask));\n-\t  mask = msk;\n-\t}\n-      op0 = lowpart_subreg (vmode, op0, mode);\n-      x = gen_rtx_AND (vmode, gen_rtx_NOT (vmode, mask), op0);\n-    }\n-  else\n-    {\n-      op1 = lowpart_subreg (vmode, op1, mode);\n-      x = gen_rtx_AND (vmode, op1, mask);\n-      emit_insn (gen_rtx_SET (op1, x));\n-\n-      op0 = lowpart_subreg (vmode, op0, mode);\n-      x = gen_rtx_XOR (vmode, op1, op0);\n-    }\n+  op0 = lowpart_subreg (vmode, op0, mode);\n+  x = gen_rtx_XOR (vmode, temp, op0);\n \n   dest = lowpart_subreg (vmode, dest, mode);\n   emit_insn (gen_rtx_SET (dest, x));"}, {"sha": "72644e33a92680a99eb051ffcef55be4848dd48b", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7485a52551d71db2e8bbfc4c484196bcc321a1cd/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7485a52551d71db2e8bbfc4c484196bcc321a1cd/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=7485a52551d71db2e8bbfc4c484196bcc321a1cd", "patch": "@@ -138,7 +138,6 @@ extern void ix86_expand_copysign (rtx []);\n extern void ix86_split_copysign_const (rtx []);\n extern void ix86_split_copysign_var (rtx []);\n extern void ix86_expand_xorsign (rtx []);\n-extern void ix86_split_xorsign (rtx []);\n extern bool ix86_unary_operator_ok (enum rtx_code, machine_mode, rtx[]);\n extern bool ix86_match_ccmode (rtx, machine_mode);\n extern void ix86_expand_branch (enum rtx_code, rtx, rtx, rtx);"}, {"sha": "6b4ceb2bce30e6b31b288107071eb0b88ccaed99", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7485a52551d71db2e8bbfc4c484196bcc321a1cd/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7485a52551d71db2e8bbfc4c484196bcc321a1cd/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=7485a52551d71db2e8bbfc4c484196bcc321a1cd", "patch": "@@ -10917,20 +10917,6 @@\n     ix86_expand_xorsign (operands);\n   DONE;\n })\n-\n-(define_insn_and_split \"@xorsign<mode>3_1\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=&Yv,&Yv,&Yv\")\n-\t(unspec:MODEF\n-\t  [(match_operand:MODEF 1 \"register_operand\" \"Yv,0,Yv\")\n-\t   (match_operand:MODEF 2 \"register_operand\" \"0,Yv,Yv\")\n-\t   (match_operand:<ssevecmode> 3 \"nonimmediate_operand\" \"Yvm,Yvm,Yvm\")]\n-\t  UNSPEC_XORSIGN))]\n-  \"SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-  \"ix86_split_xorsign (operands); DONE;\"\n-  [(set_attr \"isa\" \"*,avx,avx\")])\n \f\n ;; One complement instructions\n "}, {"sha": "471fe92bc86ab25622569cec80e71536f7e60ec3", "filename": "gcc/testsuite/gcc.dg/pr89984.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7485a52551d71db2e8bbfc4c484196bcc321a1cd/gcc%2Ftestsuite%2Fgcc.dg%2Fpr89984.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7485a52551d71db2e8bbfc4c484196bcc321a1cd/gcc%2Ftestsuite%2Fgcc.dg%2Fpr89984.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr89984.c?ref=7485a52551d71db2e8bbfc4c484196bcc321a1cd", "patch": "@@ -0,0 +1,20 @@\n+/* PR target/89984 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+__attribute__((noipa)) float\n+foo (float x, float y)\n+{\n+  return x * __builtin_copysignf (1.0f, y) + y;\n+}\n+\n+int\n+main ()\n+{\n+  if (foo (1.25f, 7.25f) != 1.25f + 7.25f\n+      || foo (1.75f, -3.25f) != -1.75f + -3.25f\n+      || foo (-2.25f, 7.5f) != -2.25f + 7.5f\n+      || foo (-3.0f, -4.0f) != 3.0f + -4.0f)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "7cb8b4cdecb2fb45744f9b7cc5e3df24d0332bd1", "filename": "gcc/testsuite/gcc.target/i386/avx-pr102224.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7485a52551d71db2e8bbfc4c484196bcc321a1cd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-pr102224.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7485a52551d71db2e8bbfc4c484196bcc321a1cd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-pr102224.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-pr102224.c?ref=7485a52551d71db2e8bbfc4c484196bcc321a1cd", "patch": "@@ -1,4 +1,4 @@\n-/* PR tree-optimization/51581 */\n+/* PR target/102224 */\n /* { dg-do run } */\n /* { dg-options \"-O2 -mavx\" } */\n /* { dg-require-effective-target avx } */"}, {"sha": "3409adef5b6f7a2f930833b9ddec844726a7a556", "filename": "gcc/testsuite/gcc.target/i386/avx-pr89984.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7485a52551d71db2e8bbfc4c484196bcc321a1cd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-pr89984.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7485a52551d71db2e8bbfc4c484196bcc321a1cd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-pr89984.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-pr89984.c?ref=7485a52551d71db2e8bbfc4c484196bcc321a1cd", "patch": "@@ -0,0 +1,23 @@\n+/* PR target/89984 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -mavx\" } */\n+/* { dg-require-effective-target avx } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"avx-check.h\"\n+#endif\n+#ifndef TEST\n+#define TEST avx_test\n+#endif\n+\n+#define main main1\n+#include \"../../gcc.dg/pr89984.c\"\n+#undef main\n+\n+#include CHECK_H\n+\n+static void\n+TEST (void)\n+{\n+  main1 ();\n+}"}]}