{"sha": "e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThhZTYzYmI2Y2NiYjdlYzNkYzVmYmZiYWY4MjM2YjcxYzU5NjUwZQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-09-17T03:01:03Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-09-17T03:01:03Z"}, "message": "[PATCH] Pass in avail_expr_stack and setup edge_infos earlier\n\n\tPR tree-optimization/47679\n\t* tree-ssa-dom.c (free_edge_info): Factored out of free_all_edge_infos.\n\t(free_all_edge_infos): Use it.\n\t(allocate_edge_info): Free preexisting edge info data.\n\t(pass_dominator::execute): Set up initial edge info structures.\n\t(dom_opt_dom_walker::thread_across_edge): Pass avail_expr_stack to\n\tthread_across_edge.\n\t* tree-ssa-threadedge.c (thread_across_edge): Accept new argument.  If\n\tnon-null, then push/pop markers appropriately.\n\t* tree-ssa-threadedge.h (thread_across_edge): Update prototype.\n\t* tree-vrp.c (identify_jump_threads): Pass NULL for new argument to\n\tthread-across_edge.\n\nFrom-SVN: r227842", "tree": {"sha": "beeb6ae89f5ced6e7def72c713e3e747502a1c12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/beeb6ae89f5ced6e7def72c713e3e747502a1c12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e/comments", "author": null, "committer": null, "parents": [{"sha": "a481f93b12d748610b2ebe947f8532765e4890d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a481f93b12d748610b2ebe947f8532765e4890d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a481f93b12d748610b2ebe947f8532765e4890d0"}], "stats": {"total": 65, "additions": 54, "deletions": 11}, "files": [{"sha": "376b642e8f9c2e1ae71157c03d97c4e4b2598297", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e", "patch": "@@ -1,3 +1,18 @@\n+2015-09-16  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/47679\n+\t* tree-ssa-dom.c (free_edge_info): Factored out of free_all_edge_infos.\n+\t(free_all_edge_infos): Use it.\n+\t(allocate_edge_info): Free preexisting edge info data.\n+\t(pass_dominator::execute): Set up initial edge info structures.\n+\t(dom_opt_dom_walker::thread_across_edge): Pass avail_expr_stack to\n+\tthread_across_edge.\n+\t* tree-ssa-threadedge.c (thread_across_edge): Accept new argument.  If\n+\tnon-null, then push/pop markers appropriately.\n+\t* tree-ssa-threadedge.h (thread_across_edge): Update prototype.\n+\t* tree-vrp.c (identify_jump_threads): Pass NULL for new argument to\n+\tthread-across_edge.\n+\n 2015-09-16  James Bowman  <james.bowman@ftdichip.com>\n \n \t* config/ft32/ft32.c Fix the memory address space predicate."}, {"sha": "1b44bd111af2061727972b6f3bf36ee9ea4602cb", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e", "patch": "@@ -132,6 +132,20 @@ static void eliminate_redundant_computations (gimple_stmt_iterator *);\n static void record_equivalences_from_stmt (gimple, int);\n static edge single_incoming_edge_ignoring_loop_edges (basic_block);\n \n+/* Free the edge_info data attached to E, if it exists.  */\n+\n+static void\n+free_edge_info (edge e)\n+{\n+  struct edge_info *edge_info = (struct edge_info *)e->aux;\n+\n+  if (edge_info)\n+    {\n+      edge_info->cond_equivalences.release ();\n+      free (edge_info);\n+    }\n+}\n+\n /* Allocate an EDGE_INFO for edge E and attach it to E.\n    Return the new EDGE_INFO structure.  */\n \n@@ -140,6 +154,9 @@ allocate_edge_info (edge e)\n {\n   struct edge_info *edge_info;\n \n+  /* Free the old one, if it exists.  */\n+  free_edge_info (e);\n+\n   edge_info = XCNEW (struct edge_info);\n \n   e->aux = edge_info;\n@@ -163,14 +180,8 @@ free_all_edge_infos (void)\n     {\n       FOR_EACH_EDGE (e, ei, bb->preds)\n         {\n-\t struct edge_info *edge_info = (struct edge_info *) e->aux;\n-\n-\t  if (edge_info)\n-\t    {\n-\t      edge_info->cond_equivalences.release ();\n-\t      free (edge_info);\n-\t      e->aux = NULL;\n-\t    }\n+\t  free_edge_info (e);\n+\t  e->aux = NULL;\n \t}\n     }\n }\n@@ -574,6 +585,16 @@ pass_dominator::execute (function *fun)\n      a single loop.  */\n   mark_dfs_back_edges ();\n \n+  /* We want to create the edge info structures before the dominator walk\n+     so that they'll be in place for the jump threader, particularly when\n+     threading through a join block.\n+\n+     The conditions will be lazily updated with global equivalences as\n+     we reach them during the dominator walk.  */\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, fun)\n+    record_edge_info (bb);\n+\n   /* Recursively walk the dominator tree optimizing statements.  */\n   dom_opt_dom_walker (CDI_DOMINATORS).walk (fun->cfg->x_entry_block_ptr);\n \n@@ -873,7 +894,7 @@ dom_opt_dom_walker::thread_across_edge (edge e)\n   /* With all the edge equivalences in the tables, go ahead and attempt\n      to thread through E->dest.  */\n   ::thread_across_edge (m_dummy_cond, e, false,\n-\t\t        const_and_copies,\n+\t\t        const_and_copies, avail_exprs_stack,\n \t\t        simplify_stmt_for_jump_threading);\n \n   /* And restore the various tables to their state before"}, {"sha": "a72edc0daef240d88ee65c96c2f96494dbb13b30", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e", "patch": "@@ -1358,6 +1358,7 @@ thread_across_edge (gcond *dummy_cond,\n \t\t    edge e,\n \t\t    bool handle_dominating_asserts,\n \t\t    const_and_copies *const_and_copies,\n+\t\t    avail_exprs_stack *avail_exprs_stack,\n \t\t    tree (*simplify) (gimple, gimple))\n {\n   bitmap visited = BITMAP_ALLOC (NULL);\n@@ -1442,6 +1443,8 @@ thread_across_edge (gcond *dummy_cond,\n \t/* Push a fresh marker so we can unwind the equivalences created\n \t   for each of E->dest's successors.  */\n \tconst_and_copies->push_marker ();\n+\tif (avail_exprs_stack)\n+\t  avail_exprs_stack->push_marker ();\n      \n \t/* Avoid threading to any block we have already visited.  */\n \tbitmap_clear (visited);\n@@ -1493,6 +1496,8 @@ thread_across_edge (gcond *dummy_cond,\n \t  }\n \n \t/* And unwind the equivalence table.  */\n+\tif (avail_exprs_stack)\n+\t  avail_exprs_stack->pop_to_marker ();\n \tconst_and_copies->pop_to_marker ();\n       }\n     BITMAP_FREE (visited);"}, {"sha": "0def2e0103ff6962b970fca206fc438311ec68a7", "filename": "gcc/tree-ssa-threadedge.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e/gcc%2Ftree-ssa-threadedge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e/gcc%2Ftree-ssa-threadedge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.h?ref=e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e", "patch": "@@ -31,6 +31,8 @@ extern void threadedge_finalize_values (void);\n extern bool potentially_threadable_block (basic_block);\n extern void propagate_threaded_block_debug_into (basic_block, basic_block);\n extern void thread_across_edge (gcond *, edge, bool,\n-\t\t\t\tconst_and_copies *, tree (*) (gimple, gimple));\n+\t\t\t\tconst_and_copies *,\n+\t\t\t\tavail_exprs_stack *,\n+\t\t\t\ttree (*) (gimple, gimple));\n \n #endif /* GCC_TREE_SSA_THREADEDGE_H */"}, {"sha": "a1d8dd8ca5c8b73d151af76e8b15c4123f390dee", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e", "patch": "@@ -10205,7 +10205,7 @@ identify_jump_threads (void)\n \t      if (e->flags & (EDGE_DFS_BACK | EDGE_COMPLEX))\n \t\tcontinue;\n \n-\t      thread_across_edge (dummy, e, true, equiv_stack,\n+\t      thread_across_edge (dummy, e, true, equiv_stack, NULL,\n \t\t\t\t  simplify_stmt_for_jump_threading);\n \t    }\n \t}"}]}