{"sha": "4fb21e9046a7538b383718a87027c97d52b698ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZiMjFlOTA0NmE3NTM4YjM4MzcxOGE4NzAyN2M5N2Q1MmI2OThlYw==", "commit": {"author": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1993-10-03T23:57:15Z"}, "committer": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1993-10-03T23:57:15Z"}, "message": "(tstxf_cc, tstxf, cmpxf, cmpxf_cc, cmpxf_ccfpeq, swapxf, movxf,\n\nextenddfxf2, extendsfxf2, truncxfsf2, truncxfdf2, fixuns_truncxfsi2,\nfix_truncxfdi2, fix_truncxfsi2, floatsixf2, floatdixf2, addxf3, subxf3,\nmulxf3, divxf3, negxf2, absxf2, sqrtxf2): New patterns.\n\nFrom-SVN: r5573", "tree": {"sha": "a5635c111df651a552569f61b543a94ad04d5ed0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5635c111df651a552569f61b543a94ad04d5ed0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fb21e9046a7538b383718a87027c97d52b698ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fb21e9046a7538b383718a87027c97d52b698ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fb21e9046a7538b383718a87027c97d52b698ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fb21e9046a7538b383718a87027c97d52b698ec/comments", "author": null, "committer": null, "parents": [{"sha": "0038aea6483e8378c4aadcac6876c73fc3eeb01d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0038aea6483e8378c4aadcac6876c73fc3eeb01d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0038aea6483e8378c4aadcac6876c73fc3eeb01d"}], "stats": {"total": 617, "additions": 617, "deletions": 0}, "files": [{"sha": "75765545f41f7ee26cc9840bde7ff105773e66c8", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 617, "deletions": 0, "changes": 617, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb21e9046a7538b383718a87027c97d52b698ec/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb21e9046a7538b383718a87027c97d52b698ec/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=4fb21e9046a7538b383718a87027c97d52b698ec", "patch": "@@ -45,6 +45,7 @@\n ;; 'k' Likewise, print the SImode name of the register.\n ;; 'h' Print the QImode name for a \"high\" register, either ah, bh, ch or dh.\n ;; 'y' Print \"st(0)\" instead of \"st\" as a register.\n+;; 'T' Print the opcode suffix for an 80-bit extended real XFmode float opcode.\n \n ;; UNSPEC usage:\n ;; 0  This is a `scas' operation.  The mode of the UNSPEC is always SImode.\n@@ -206,6 +207,39 @@\n   i386_compare_op0 = operands[0];\n   DONE;\n }\")\n+\n+(define_insn \"tstxf_cc\"\n+  [(set (cc0)\n+\t(match_operand:XF 0 \"register_operand\" \"f\"))\n+   (clobber (match_scratch:HI 1 \"=a\"))]\n+  \"TARGET_80387 && ! TARGET_IEEE_FP\"\n+  \"*\n+{\n+  if (! STACK_TOP_P (operands[0]))\n+    abort ();\n+\n+  output_asm_insn (\\\"ftst\\\", operands);\n+\n+  if (find_regno_note (insn, REG_DEAD, FIRST_STACK_REG))\n+    output_asm_insn (AS1 (fstp,%y0), operands);\n+\n+  return (char *) output_fp_cc0_set (insn);\n+}\")\n+\n+;; Don't generate tstdf if generating IEEE code, since the `ftst' opcode\n+;; isn't IEEE compliant.\n+\n+(define_expand \"tstxf\"\n+  [(parallel [(set (cc0)\n+\t\t   (match_operand:XF 0 \"register_operand\" \"\"))\n+\t      (clobber (match_scratch:HI 1 \"\"))])]\n+  \"TARGET_80387 && ! TARGET_IEEE_FP\"\n+  \"\n+{\n+  i386_compare_gen = gen_tstxf_cc;\n+  i386_compare_op0 = operands[0];\n+  DONE;\n+}\")\n \f\n ;;- compare instructions.  See comments above tstM patterns about\n ;;  expansion of these insns.\n@@ -307,6 +341,64 @@\n ;; SFmode, there is the normal insn, and an insn where the second operand\n ;; is converted to the desired mode.\n \n+(define_insn \"\"\n+  [(set (cc0)\n+\t(match_operator 2 \"VOIDmode_compare_op\"\n+\t\t\t[(match_operand:XF 0 \"nonimmediate_operand\" \"f\")\n+\t\t\t (match_operand:XF 1 \"nonimmediate_operand\" \"f\")]))\n+   (clobber (match_scratch:HI 3 \"=a\"))]\n+  \"TARGET_80387\n+   && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n+  \"* return (char *) output_float_compare (insn, operands);\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(match_operator 2 \"VOIDmode_compare_op\"\n+\t\t\t[(match_operand:XF 0 \"register_operand\" \"f\")\n+\t\t\t (float:XF\n+\t\t\t  (match_operand:SI 1 \"nonimmediate_operand\" \"rm\"))]))\n+   (clobber (match_scratch:HI 3 \"=a\"))]\n+  \"TARGET_80387\"\n+  \"* return (char *) output_float_compare (insn, operands);\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(match_operator 2 \"VOIDmode_compare_op\"\n+\t\t\t[(float:XF\n+\t\t\t  (match_operand:SI 0 \"nonimmediate_operand\" \"rm\"))\n+\t\t\t (match_operand:XF 1 \"register_operand\" \"f\")]))\n+   (clobber (match_scratch:HI 3 \"=a\"))]\n+  \"TARGET_80387\"\n+  \"* return (char *) output_float_compare (insn, operands);\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(match_operator 2 \"VOIDmode_compare_op\"\n+\t\t\t[(match_operand:XF 0 \"register_operand\" \"f\")\n+\t\t\t (float_extend:XF\n+\t\t\t  (match_operand:DF 1 \"nonimmediate_operand\" \"fm\"))]))\n+   (clobber (match_scratch:HI 3 \"=a\"))]\n+  \"TARGET_80387\"\n+  \"* return (char *) output_float_compare (insn, operands);\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(match_operator 2 \"VOIDmode_compare_op\"\n+\t\t\t[(match_operand:XF 0 \"register_operand\" \"f\")\n+\t\t\t (float_extend:XF\n+\t\t\t  (match_operand:SF 1 \"nonimmediate_operand\" \"fm\"))]))\n+   (clobber (match_scratch:HI 3 \"=a\"))]\n+  \"TARGET_80387\"\n+  \"* return (char *) output_float_compare (insn, operands);\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare:CCFPEQ (match_operand:XF 0 \"register_operand\" \"f\")\n+\t\t\t(match_operand:XF 1 \"register_operand\" \"f\")))\n+   (clobber (match_scratch:HI 2 \"=a\"))]\n+  \"TARGET_80387\"\n+  \"* return (char *) output_float_compare (insn, operands);\")\n+\n (define_insn \"\"\n   [(set (cc0)\n \t(match_operator 2 \"VOIDmode_compare_op\"\n@@ -423,6 +515,20 @@\n   \"TARGET_80387\"\n   \"* return (char *) output_float_compare (insn, operands);\")\n \n+(define_expand \"cmpxf\"\n+  [(set (cc0)\n+\t(compare (match_operand:XF 0 \"register_operand\" \"\")\n+\t\t (match_operand:XF 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_80387\"\n+  \"\n+{\n+  i386_compare_gen = gen_cmpxf_cc;\n+  i386_compare_gen_eq = gen_cmpxf_ccfpeq;\n+  i386_compare_op0 = operands[0];\n+  i386_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n (define_expand \"cmpdf\"\n   [(set (cc0)\n \t(compare (match_operand:DF 0 \"register_operand\" \"\")\n@@ -451,6 +557,26 @@\n   DONE;\n }\")\n \n+(define_expand \"cmpxf_cc\"\n+  [(parallel [(set (cc0)\n+\t\t   (compare (match_operand:XF 0 \"register_operand\" \"\")\n+\t\t\t    (match_operand:XF 1 \"register_operand\" \"\")))\n+\t      (clobber (match_scratch:HI 2 \"\"))])]\n+  \"TARGET_80387\"\n+  \"\")\n+\n+(define_expand \"cmpxf_ccfpeq\"\n+  [(parallel [(set (cc0)\n+\t\t   (compare:CCFPEQ (match_operand:XF 0 \"register_operand\" \"\")\n+\t\t\t\t   (match_operand:XF 1 \"register_operand\" \"\")))\n+\t      (clobber (match_scratch:HI 2 \"\"))])]\n+  \"TARGET_80387\"\n+  \"\n+{\n+  if (! register_operand (operands[1], XFmode))\n+    operands[1] = copy_to_mode_reg (XFmode, operands[1]);\n+}\")\n+\n (define_expand \"cmpdf_cc\"\n   [(parallel [(set (cc0)\n \t\t   (compare (match_operand:DF 0 \"register_operand\" \"\")\n@@ -1013,6 +1139,113 @@\n   return (char *) output_move_double (operands);\n }\")\n \n+(define_insn \"\"\n+  [(set (match_operand:XF 0 \"push_operand\" \"=<,<\")\n+ \t(match_operand:XF 1 \"general_operand\" \"gF,f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (STACK_REG_P (operands[1]))\n+    {\n+      rtx xops[3];\n+\n+      xops[0] = AT_SP (SFmode);\n+      xops[1] = GEN_INT (12);\n+      xops[2] = stack_pointer_rtx;\n+\n+      output_asm_insn (AS2 (sub%L2,%1,%2), xops);\n+      if (find_regno_note (insn, REG_DEAD, FIRST_STACK_REG))\n+        output_asm_insn (AS1 (fstp%T0,%0), xops);\n+      else\n+        {\n+          output_asm_insn (AS1 (fld,%y1), operands);\n+          output_asm_insn (AS1 (fstp%T0,%y0), xops);\n+         }\n+      RET;\n+    }\n+  else\n+    return (char *) output_move_double (operands);\n+ }\")\n+\n+(define_insn \"swapxf\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"f\")\n+\t(match_operand:XF 1 \"register_operand\" \"f\"))\n+   (set (match_dup 1)\n+\t(match_dup 0))]\n+  \"\"\n+  \"*\n+{\n+  if (STACK_TOP_P (operands[0]))\n+    return AS1 (fxch,%1);\n+  else\n+    return AS1 (fxch,%0);\n+}\")\n+\n+(define_insn \"movxf\"\n+  [(set (match_operand:XF 0 \"general_operand\" \"=f,fm,!*rf,!*rm\")\n+\t(match_operand:XF 1 \"general_operand\" \"fmG,f,*rfm,*rfF\"))]\n+;;  [(set (match_operand:XF 0 \"general_operand\" \"=*rf,*rfm,f,!*rm\")\n+;;\t(match_operand:XF 1 \"general_operand\" \"*rfm,*rf,fG,fF\"))]\n+  \"\"\n+  \"*\n+{\n+  int stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n+\n+  /* First handle a `pop' insn or a `fld %st(0)' */\n+\n+  if (STACK_TOP_P (operands[0]) && STACK_TOP_P (operands[1]))\n+    {\n+      if (stack_top_dies)\n+\treturn AS1 (fstp,%y0);\n+      else\n+        return AS1 (fld,%y0);\n+    }\n+\n+  /* Handle a transfer between the 387 and a 386 register */\n+\n+  if (STACK_TOP_P (operands[0]) && NON_STACK_REG_P (operands[1]))\n+    {\n+      output_op_from_reg (operands[1], AS1 (fld%z0,%y1));\n+      RET;\n+    }\n+\n+  if (STACK_TOP_P (operands[1]) && NON_STACK_REG_P (operands[0]))\n+    {\n+      if (stack_top_dies == 0)\n+\t{\n+\t  output_asm_insn (AS1 (fld,%y1), operands);\n+\t  stack_top_dies = 1;\n+\t}\n+      output_to_reg (operands[0], stack_top_dies);\n+      RET;\n+    }\n+\n+  /* Handle other kinds of writes from the 387 */\n+\n+  if (STACK_TOP_P (operands[1]))\n+    {\n+      if (stack_top_dies)\n+\treturn AS1 (fstp%z0,%y0);\n+      else\n+\t{\n+        output_asm_insn (AS1 (fld,%y1), operands);\n+\treturn AS1 (fstp%z0,%y0);\n+\t}\n+    }\n+\n+  /* Handle other kinds of reads to the 387 */\n+\n+  if (STACK_TOP_P (operands[0]) && GET_CODE (operands[1]) == CONST_DOUBLE)\n+    return (char *) output_move_const_single (operands);\n+\n+  if (STACK_TOP_P (operands[0]))\n+       return AS1 (fld%z1,%y1);\n+\n+  /* Handle all XFmode moves not involving the 387 */\n+\n+  return (char *) output_move_double (operands);\n+}\")\n+\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"push_operand\" \"=<\")\n \t(match_operand:DI 1 \"general_operand\" \"roiF\"))]\n@@ -1241,6 +1474,92 @@\n   abort ();\n }\")\n \n+(define_insn \"extenddfxf2\"\n+  [(set (match_operand:XF 0 \"general_operand\" \"=fm,f,f,!*r\")\n+\t(float_extend:XF\n+\t (match_operand:DF 1 \"general_operand\" \"f,fm,!*r,f\")))]\n+  \"TARGET_80387\"\n+  \"*\n+{\n+  int stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n+\n+  if (NON_STACK_REG_P (operands[1]))\n+    {\n+      output_op_from_reg (operands[1], AS1 (fld%z0,%y1));\n+      RET;\n+    }\n+\n+  if (NON_STACK_REG_P (operands[0]))\n+    {\n+      if (stack_top_dies == 0)\n+\t{\n+\t  output_asm_insn (AS1 (fld,%y1), operands);\n+\t  stack_top_dies = 1;\n+\t}\n+      output_to_reg (operands[0], stack_top_dies);\n+      RET;\n+    }\n+\n+  if (STACK_TOP_P (operands[0]))\n+    return AS1 (fld%z1,%y1);\n+\n+  if (GET_CODE (operands[0]) == MEM)\n+    {\n+      if (stack_top_dies)\n+\treturn AS1 (fstp%z0,%y0);\n+      else\n+\t{\n+\t  output_asm_insn (AS1 (fld,%y1), operands);\n+\t  return AS1 (fstp%z0,%0);\n+\t}\n+    }\n+\n+  abort ();\n+}\")\n+\n+(define_insn \"extendsfxf2\"\n+  [(set (match_operand:XF 0 \"general_operand\" \"=fm,f,f,!*r\")\n+\t(float_extend:XF\n+\t (match_operand:SF 1 \"general_operand\" \"f,fm,!*r,f\")))]\n+  \"TARGET_80387\"\n+  \"*\n+{\n+  int stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n+\n+  if (NON_STACK_REG_P (operands[1]))\n+    {\n+      output_op_from_reg (operands[1], AS1 (fld%z0,%y1));\n+      RET;\n+    }\n+\n+  if (NON_STACK_REG_P (operands[0]))\n+    {\n+      if (stack_top_dies == 0)\n+\t{\n+\t  output_asm_insn (AS1 (fld,%y1), operands);\n+\t  stack_top_dies = 1;\n+\t}\n+      output_to_reg (operands[0], stack_top_dies);\n+      RET;\n+    }\n+\n+  if (STACK_TOP_P (operands[0]))\n+    return AS1 (fld%z1,%y1);\n+\n+  if (GET_CODE (operands[0]) == MEM)\n+    {\n+      if (stack_top_dies)\n+\treturn AS1 (fstp%z0,%y0);\n+      else\n+\t{\n+\t  output_asm_insn (AS1 (fld,%y1), operands);\n+\t  return AS1 (fstp%z0,%0);\n+\t}\n+    }\n+\n+  abort ();\n+}\")\n+\n (define_expand \"truncdfsf2\"\n   [(parallel [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n \t\t   (float_truncate:SF\n@@ -1282,13 +1601,101 @@\n   else\n     abort ();\n }\")\n+\n+(define_insn \"truncxfsf2\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=m,!*r\")\n+\t(float_truncate:SF\n+\t (match_operand:XF 1 \"register_operand\" \"f,f\")))]\n+  \"TARGET_80387\"\n+  \"*\n+{\n+  int stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n+\n+  if (NON_STACK_REG_P (operands[0]))\n+    {\n+      if (stack_top_dies == 0)\n+\t{\n+\t  output_asm_insn (AS1 (fld,%y1), operands);\n+\t  stack_top_dies = 1;\n+\t}\n+      output_to_reg (operands[0], stack_top_dies);\n+      RET;\n+    }\n+  else if (GET_CODE (operands[0]) == MEM)\n+    {\n+      if (stack_top_dies)\n+\treturn AS1 (fstp%z0,%0);\n+      else\n+\t{\n+\t  output_asm_insn (AS1 (fld,%y1), operands);\n+\t  return AS1 (fstp%z0,%0);\n+\t}\n+    }\n+  else\n+    abort ();\n+}\")\n+\n+(define_insn \"truncxfdf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=m,!*r\")\n+\t(float_truncate:DF\n+\t (match_operand:XF 1 \"register_operand\" \"f,f\")))]\n+  \"TARGET_80387\"\n+  \"*\n+{\n+  int stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n+\n+  if (NON_STACK_REG_P (operands[0]))\n+    {\n+      if (stack_top_dies == 0)\n+\t{\n+\t  output_asm_insn (AS1 (fld,%y1), operands);\n+\t  stack_top_dies = 1;\n+\t}\n+      output_to_reg (operands[0], stack_top_dies);\n+      RET;\n+    }\n+  else if (GET_CODE (operands[0]) == MEM)\n+    {\n+      if (stack_top_dies)\n+\treturn AS1 (fstp%z0,%0);\n+      else\n+\t{\n+\t  output_asm_insn (AS1 (fld,%y1), operands);\n+\t  return AS1 (fstp%z0,%0);\n+\t}\n+    }\n+  else\n+    abort ();\n+}\")\n+\n \f\n ;; The 387 requires that the stack top dies after converting to DImode.\n \n ;; Represent an unsigned conversion from SImode to MODE_FLOAT by first\n ;; doing a signed conversion to DImode, and then taking just the low\n ;; part.\n \n+(define_expand \"fixuns_truncxfsi2\"\n+  [(set (match_dup 4)\n+\t(match_operand:XF 1 \"register_operand\" \"\"))\n+   (parallel [(set (match_dup 2)\n+\t\t   (fix:DI (fix:XF (match_dup 4))))\n+\t      (clobber (match_dup 4))\n+\t      (clobber (match_dup 5))\n+\t      (clobber (match_dup 6))\n+\t      (clobber (match_scratch:SI 7 \"\"))])\n+   (set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(match_dup 3))]\n+  \"TARGET_80387\"\n+  \"\n+{\n+  operands[2] = gen_reg_rtx (DImode);\n+  operands[3] = gen_lowpart (SImode, operands[2]);\n+  operands[4] = gen_reg_rtx (XFmode);\n+  operands[5] = (rtx) assign_386_stack_local (SImode, 0);\n+  operands[6] = (rtx) assign_386_stack_local (SImode, 1);\n+}\")\n+\n (define_expand \"fixuns_truncdfsi2\"\n   [(set (match_dup 4)\n \t(match_operand:DF 1 \"register_operand\" \"\"))\n@@ -1333,6 +1740,24 @@\n \n ;; Signed conversion to DImode.\n \n+(define_expand \"fix_truncxfdi2\"\n+  [(set (match_dup 2)\n+\t(match_operand:XF 1 \"register_operand\" \"\"))\n+   (parallel [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t\t   (fix:DI (fix:XF (match_dup 2))))\n+\t      (clobber (match_dup 2))\n+\t      (clobber (match_dup 3))\n+\t      (clobber (match_dup 4))\n+\t      (clobber (match_scratch:SI 5 \"\"))])]\n+  \"TARGET_80387\"\n+  \"\n+{\n+  operands[1] = copy_to_mode_reg (XFmode, operands[1]);\n+  operands[2] = gen_reg_rtx (XFmode);\n+  operands[3] = (rtx) assign_386_stack_local (SImode, 0);\n+  operands[4] = (rtx) assign_386_stack_local (SImode, 1);\n+}\")\n+\n (define_expand \"fix_truncdfdi2\"\n   [(set (match_dup 2)\n \t(match_operand:DF 1 \"register_operand\" \"\"))\n@@ -1371,6 +1796,16 @@\n \n ;; These match a signed conversion of either DFmode or SFmode to DImode.\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=rm\")\n+\t(fix:DI (fix:XF (match_operand:XF 1 \"register_operand\" \"f\"))))\n+   (clobber (match_dup 1))\n+   (clobber (match_operand:SI 2 \"memory_operand\" \"m\"))\n+   (clobber (match_operand:SI 3 \"memory_operand\" \"m\"))\n+   (clobber (match_scratch:SI 4 \"=&q\"))]\n+  \"TARGET_80387\"\n+  \"* return (char *) output_fix_trunc (insn, operands);\")\n+\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=rm\")\n \t(fix:DI (fix:DF (match_operand:DF 1 \"register_operand\" \"f\"))))\n@@ -1393,6 +1828,20 @@\n \n ;; Signed MODE_FLOAT conversion to SImode.\n \n+(define_expand \"fix_truncxfsi2\"\n+  [(parallel [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t\t   (fix:SI\n+\t\t    (fix:XF (match_operand:XF 1 \"register_operand\" \"\"))))\n+\t      (clobber (match_dup 2))\n+\t      (clobber (match_dup 3))\n+\t      (clobber (match_scratch:SI 4 \"\"))])]\n+  \"TARGET_80387\"\n+  \"\n+{\n+  operands[2] = (rtx) assign_386_stack_local (SImode, 0);\n+  operands[3] = (rtx) assign_386_stack_local (SImode, 1);\n+}\")\n+\n (define_expand \"fix_truncdfsi2\"\n   [(parallel [(set (match_operand:SI 0 \"general_operand\" \"\")\n \t\t   (fix:SI\n@@ -1421,6 +1870,15 @@\n   operands[3] = (rtx) assign_386_stack_local (SImode, 1);\n }\")\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(fix:SI (fix:XF (match_operand:XF 1 \"register_operand\" \"f\"))))\n+   (clobber (match_operand:SI 2 \"memory_operand\" \"m\"))\n+   (clobber (match_operand:SI 3 \"memory_operand\" \"m\"))\n+   (clobber (match_scratch:SI 4 \"=&q\"))]\n+  \"TARGET_80387\"\n+  \"* return (char *) output_fix_trunc (insn, operands);\")\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n \t(fix:SI (fix:DF (match_operand:DF 1 \"register_operand\" \"f\"))))\n@@ -1468,8 +1926,37 @@\n   \"TARGET_80387\"\n   \"\")\n \n+(define_expand \"floatsixf2\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"\")\n+\t(float:XF (match_operand:SI 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_80387\"\n+  \"\")\n+\n+(define_expand \"floatdixf2\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"\")\n+\t(float:XF (match_operand:DI 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_80387\"\n+  \"\")\n+\n ;; This will convert from SImode or DImode to MODE_FLOAT.\n \n+(define_insn \"\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n+\t(float:XF (match_operand:DI 1 \"general_operand\" \"rm\")))]\n+  \"TARGET_80387\"\n+  \"*\n+{\n+  if (NON_STACK_REG_P (operands[1]))\n+    {\n+      output_op_from_reg (operands[1], AS1 (fild%z0,%1));\n+      RET;\n+    }\n+  else if (GET_CODE (operands[1]) == MEM)\n+    return AS1 (fild%z1,%1);\n+  else\n+    abort ();\n+}\")\n+\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(float:DF (match_operand:DI 1 \"nonimmediate_operand\" \"rm\")))]\n@@ -1521,6 +2008,23 @@\n     abort ();\n }\")\n \n+(define_insn \"\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f,f\")\n+\t(float:XF (match_operand:SI 1 \"general_operand\" \"m,!*r\")))]\n+  \"TARGET_80387\"\n+  \"*\n+{\n+  if (NON_STACK_REG_P (operands[1]))\n+    {\n+      output_op_from_reg (operands[1], AS1 (fild%z0,%1));\n+      RET;\n+    }\n+  else if (GET_CODE (operands[1]) == MEM)\n+    return AS1 (fild%z1,%1);\n+  else\n+    abort ();\n+}\")\n+\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(float:SF (match_operand:SI 1 \"nonimmediate_operand\" \"rm\")))]\n@@ -1718,6 +2222,13 @@\n \n ;; The patterns that match these are at the end of this file.\n \n+(define_expand \"addxf3\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"\")\n+\t(plus:XF (match_operand:XF 1 \"nonimmediate_operand\" \"\")\n+\t\t (match_operand:XF 2 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_80387\"\n+  \"\")\n+\n (define_expand \"adddf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(plus:DF (match_operand:DF 1 \"nonimmediate_operand\" \"\")\n@@ -1781,6 +2292,13 @@\n \n ;; The patterns that match these are at the end of this file.\n \n+(define_expand \"subxf3\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"\")\n+\t(minus:XF (match_operand:XF 1 \"nonimmediate_operand\" \"\")\n+\t\t  (match_operand:XF 2 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_80387\"\n+  \"\")\n+\n (define_expand \"subdf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(minus:DF (match_operand:DF 1 \"nonimmediate_operand\" \"\")\n@@ -1859,6 +2377,13 @@\n \n ;; The patterns that match these are at the end of this file.\n \n+(define_expand \"mulxf3\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"\")\n+\t(mult:XF (match_operand:XF 1 \"nonimmediate_operand\" \"\")\n+\t\t (match_operand:XF 2 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_80387\"\n+  \"\")\n+\n (define_expand \"muldf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(mult:DF (match_operand:DF 1 \"nonimmediate_operand\" \"\")\n@@ -1891,6 +2416,13 @@\n \n ;; The patterns that match these are at the end of this file.\n \n+(define_expand \"divxf3\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"\")\n+\t(div:XF (match_operand:XF 1 \"nonimmediate_operand\" \"\")\n+\t\t(match_operand:XF 2 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_80387\"\n+  \"\")\n+\n (define_expand \"divdf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(div:DF (match_operand:DF 1 \"nonimmediate_operand\" \"\")\n@@ -2381,6 +2913,18 @@\n \t(neg:DF (float_extend:DF (match_operand:SF 1 \"general_operand\" \"0\"))))]\n   \"TARGET_80387\"\n   \"fchs\")\n+\n+(define_insn \"negxf2\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n+\t(neg:XF (match_operand:XF 1 \"general_operand\" \"0\")))]\n+  \"TARGET_80387\"\n+  \"fchs\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n+\t(neg:XF (float_extend:XF (match_operand:DF 1 \"general_operand\" \"0\"))))]\n+  \"TARGET_80387\"\n+  \"fchs\")\n \f\n ;; Absolute value instructions\n \n@@ -2402,6 +2946,18 @@\n   \"TARGET_80387\"\n   \"fabs\")\n \n+(define_insn \"absxf2\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n+\t(abs:XF (match_operand:XF 1 \"general_operand\" \"0\")))]\n+  \"TARGET_80387\"\n+  \"fabs\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n+\t(abs:XF (float_extend:XF (match_operand:DF 1 \"general_operand\" \"0\"))))]\n+  \"TARGET_80387\"\n+  \"fabs\")\n+\n (define_insn \"sqrtsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(sqrt:SF (match_operand:SF 1 \"general_operand\" \"0\")))]\n@@ -2421,6 +2977,26 @@\n   \"TARGET_80387 && (TARGET_IEEE_FP || flag_fast_math)\"\n   \"fsqrt\")\n \n+(define_insn \"sqrtxf2\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n+\t(sqrt:XF (match_operand:XF 1 \"general_operand\" \"0\")))]\n+  \"TARGET_80387 && (TARGET_IEEE_FP || flag_fast_math)\"\n+  \"fsqrt\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n+\t(sqrt:XF (float_extend:XF\n+\t\t  (match_operand:DF 1 \"general_operand\" \"0\"))))]\n+  \"TARGET_80387 && (TARGET_IEEE_FP || flag_fast_math)\"\n+  \"fsqrt\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n+\t(sqrt:XF (float_extend:XF\n+\t\t  (match_operand:SF 1 \"general_operand\" \"0\"))))]\n+  \"TARGET_80387 && (TARGET_IEEE_FP || flag_fast_math)\"\n+  \"fsqrt\")\n+\n (define_insn \"sindf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(unspec:DF [(match_operand:DF 1 \"register_operand\" \"0\")] 1))]\n@@ -4579,6 +5155,47 @@\n   \"TARGET_80387\"\n   \"* return (char *) output_387_binary_op (insn, operands);\")\n \n+(define_insn \"\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f,f\")\n+\t(match_operator:XF 3 \"binary_387_op\"\n+\t\t\t[(match_operand:XF 1 \"nonimmediate_operand\" \"0,f\")\n+\t\t\t (match_operand:XF 2 \"nonimmediate_operand\" \"f,0\")]))]\n+  \"TARGET_80387\"\n+  \"* return (char *) output_387_binary_op (insn, operands);\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n+\t(match_operator:XF 3 \"binary_387_op\"\n+\t   [(float:XF (match_operand:SI 1 \"general_operand\" \"rm\"))\n+\t    (match_operand:XF 2 \"general_operand\" \"0\")]))]\n+  \"TARGET_80387\"\n+  \"* return (char *) output_387_binary_op (insn, operands);\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f,f\")\n+\t(match_operator:XF 3 \"binary_387_op\"\n+\t   [(float_extend:XF (match_operand:SF 1 \"general_operand\" \"fm,0\"))\n+\t    (match_operand:XF 2 \"general_operand\" \"0,f\")]))]\n+  \"TARGET_80387\"\n+  \"* return (char *) output_387_binary_op (insn, operands);\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n+\t(match_operator:XF 3 \"binary_387_op\"\n+\t  [(match_operand:XF 1 \"general_operand\" \"0\")\n+\t   (float:XF (match_operand:SI 2 \"general_operand\" \"rm\"))]))]\n+  \"TARGET_80387\"\n+  \"* return (char *) output_387_binary_op (insn, operands);\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f,f\")\n+\t(match_operator:XF 3 \"binary_387_op\"\n+\t  [(match_operand:XF 1 \"general_operand\" \"0,f\")\n+\t   (float_extend:XF\n+\t    (match_operand:SF 2 \"general_operand\" \"fm,0\"))]))]\n+  \"TARGET_80387\"\n+  \"* return (char *) output_387_binary_op (insn, operands);\")\n+\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n \t(match_operator:DF 3 \"binary_387_op\""}]}