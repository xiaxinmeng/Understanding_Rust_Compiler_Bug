{"sha": "e0bb17a83f613106571d3b516168d12cf83b10be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBiYjE3YTgzZjYxMzEwNjU3MWQzYjUxNjE2OGQxMmNmODNiMTBiZQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-07-01T12:18:01Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-07-01T12:18:01Z"}, "message": "basic-block.h: Fix comment typos.\n\n\t* basic-block.h: Fix comment typos.\n\t* bb-reorder.c: Likewise.\n\t* c-format.c: Likewise.\n\t* cfgcleanup.c: Likewise.\n\t* cfghooks.h: Likewise.\n\t* cfgloop.c: Likewise.\n\t* cfgloopmanip.c: Likewise.\n\t* cfgrtl.c: Likewise.\n\t* cgraph.h: Likewise.\n\t* cgraphunit.c: Likewise.\n\t* combine.c: Likewise.\n\t* convert.c: Likewise.\n\t* dbxout.c: Likewise.\n\t* df.c: Likewise.\n\t* df.h: Likewise.\n\t* diagnostic.c: Likewise.\n\t* dwarf2out.c: Likewise.\n\t* et-forest.h: Likewise.\n\t* flow.c: Likewise.\n\t* fold-const.c: Likewise.\n\t* function.h: Likewise.\n\t* gcov-io.h: Likewise.\n\t* gcov.c: Likewise.\n\t* gcse.c: Likewise.\n\t* genautomata.c: Likewise.\n\t* ggc-common.c: Likewise.\n\t* ggc-page.c: Likewise.\n\t* loop-unroll.c: Likewise.\n\t* loop-unswitch.c: Likewise.\n\t* loop.c: Likewise.\n\t* mips-tfile.c: Likewise.\n\t* optabs.c: Likewise.\n\t* ra-build.c: Likewise.\n\t* ra-colorize.c: Likewise.\n\t* ra-rewrite.c: Likewise.\n\t* ra.h: Likewise.\n\t* regmove.c: Likewise.\n\t* reload.c: Likewise.\n\t* rtlanal.c: Likewise.\n\t* sched-ebb.c: Likewise.\n\t* sched-int.h: Likewise.\n\t* sched-vis.c: Likewise.\n\t* sreal.c: Likewise.\n\t* ssa-ccp.c: Likewise.\n\t* ssa.c: Likewise.\n\t* toplev.c: Likewise.\n\t* tree-inline.c: Likewise.\n\t* value-prof.c: Likewise.\n\t* value-prof.h: Likewise.\n\nFrom-SVN: r68770", "tree": {"sha": "2e247fb1aad8f72881cfd082e69ebe412ba7989f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e247fb1aad8f72881cfd082e69ebe412ba7989f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0bb17a83f613106571d3b516168d12cf83b10be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0bb17a83f613106571d3b516168d12cf83b10be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0bb17a83f613106571d3b516168d12cf83b10be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0bb17a83f613106571d3b516168d12cf83b10be/comments", "author": null, "committer": null, "parents": [{"sha": "0d0a1710d97a7eff97667caa55f83cc7bbe948de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d0a1710d97a7eff97667caa55f83cc7bbe948de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d0a1710d97a7eff97667caa55f83cc7bbe948de"}], "stats": {"total": 218, "additions": 135, "deletions": 83}, "files": [{"sha": "a4154f631e339a31871495a2229b36df754fbbd7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -1,3 +1,55 @@\n+2003-07-01  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* basic-block.h: Fix comment typos.\n+\t* bb-reorder.c: Likewise.\n+\t* c-format.c: Likewise.\n+\t* cfgcleanup.c: Likewise.\n+\t* cfghooks.h: Likewise.\n+\t* cfgloop.c: Likewise.\n+\t* cfgloopmanip.c: Likewise.\n+\t* cfgrtl.c: Likewise.\n+\t* cgraph.h: Likewise.\n+\t* cgraphunit.c: Likewise.\n+\t* combine.c: Likewise.\n+\t* convert.c: Likewise.\n+\t* dbxout.c: Likewise.\n+\t* df.c: Likewise.\n+\t* df.h: Likewise.\n+\t* diagnostic.c: Likewise.\n+\t* dwarf2out.c: Likewise.\n+\t* et-forest.h: Likewise.\n+\t* flow.c: Likewise.\n+\t* fold-const.c: Likewise.\n+\t* function.h: Likewise.\n+\t* gcov-io.h: Likewise.\n+\t* gcov.c: Likewise.\n+\t* gcse.c: Likewise.\n+\t* genautomata.c: Likewise.\n+\t* ggc-common.c: Likewise.\n+\t* ggc-page.c: Likewise.\n+\t* loop-unroll.c: Likewise.\n+\t* loop-unswitch.c: Likewise.\n+\t* loop.c: Likewise.\n+\t* mips-tfile.c: Likewise.\n+\t* optabs.c: Likewise.\n+\t* ra-build.c: Likewise.\n+\t* ra-colorize.c: Likewise.\n+\t* ra-rewrite.c: Likewise.\n+\t* ra.h: Likewise.\n+\t* regmove.c: Likewise.\n+\t* reload.c: Likewise.\n+\t* rtlanal.c: Likewise.\n+\t* sched-ebb.c: Likewise.\n+\t* sched-int.h: Likewise.\n+\t* sched-vis.c: Likewise.\n+\t* sreal.c: Likewise.\n+\t* ssa-ccp.c: Likewise.\n+\t* ssa.c: Likewise.\n+\t* toplev.c: Likewise.\n+\t* tree-inline.c: Likewise.\n+\t* value-prof.c: Likewise.\n+\t* value-prof.h: Likewise.\n+\n 2003-07-01  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* rtl.h (emit_line_note_after): Remove."}, {"sha": "65e5d827872a0630685f46f0ef2639a0eff964e2", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -487,7 +487,7 @@ enum update_life_extent\n \t\t\t\t | PROP_ALLOW_CFG_CHANGES \\\n \t\t\t\t | PROP_SCAN_DEAD_STORES)\n \n-#define CLEANUP_EXPENSIVE\t1\t/* Do relativly expensive optimizations\n+#define CLEANUP_EXPENSIVE\t1\t/* Do relatively expensive optimizations\n \t\t\t\t\t   except for edge forwarding */\n #define CLEANUP_CROSSJUMP\t2\t/* Do crossjumping.  */\n #define CLEANUP_POST_REGSTACK\t4\t/* We run after reg-stack and need"}, {"sha": "24e6df0b369b7ba70690cfd781470a08035776aa", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -1069,8 +1069,8 @@ reorder_basic_blocks (void)\n   set_edge_can_fallthru_flag ();\n   mark_dfs_back_edges ();\n \n-  /* We are estimating the lenght of uncond jump insn only once since the code\n-     for getting the insn lenght always returns the minimal length now.  */\n+  /* We are estimating the length of uncond jump insn only once since the code\n+     for getting the insn length always returns the minimal length now.  */\n   if (uncond_jump_length == 0)\n     uncond_jump_length = get_uncond_jump_length ();\n "}, {"sha": "0b3fa2f251ce9e7cba54eb7a49e134fe73c2f0fb", "filename": "gcc/c-format.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -2715,7 +2715,7 @@ handle_format_attribute (tree *node, tree name ATTRIBUTE_UNUSED, tree args,\n       if (info.format_type == asm_fprintf_format_type)\n \tinit_dynamic_asm_fprintf_info();\n       /* If this is one of the diagnostic attributes, then we have to\n-         intialize `location_t' and `tree' at runtime.  */\n+         initialize `location_t' and `tree' at runtime.  */\n       else if (info.format_type == gcc_diag_format_type\n \t       || info.format_type == gcc_cdiag_format_type\n \t       || info.format_type == gcc_cxxdiag_format_type)"}, {"sha": "0ad1c6bcd338bd56afc48441b577e294f7707bbc", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -765,7 +765,7 @@ merge_blocks_move_successor_nojumps (basic_block a, basic_block b)\n    Return NULL iff the attempt failed, otherwise return basic block\n    where cleanup_cfg should continue.  Because the merging commonly\n    moves basic block away or introduces another optimization\n-   possiblity, return basic block just before B so cleanup_cfg don't\n+   possibility, return basic block just before B so cleanup_cfg don't\n    need to iterate.\n \n    It may be good idea to return basic block before C in the case\n@@ -1353,7 +1353,7 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n \treturn false;\n     }\n \n-  /* We don't need to match the rest of edges as above checks should be enought\n+  /* We don't need to match the rest of edges as above checks should be enough\n      to ensure that they are equivalent.  */\n   return true;\n }"}, {"sha": "00a98163059b9da3d32ca8be8bd3ed9ef4a448ac", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -32,7 +32,7 @@ struct cfg_hooks\n   /* Basic CFG manipulation.  */\n \n   /* Redirect edge E to the given basic block B and update underlying program\n-     representation.  Returns false when edge is not easilly redirectable for\n+     representation.  Returns false when edge is not easily redirectable for\n      whatever reason.  */\n   bool (*redirect_edge_and_branch) (edge e, basic_block b);\n "}, {"sha": "8b439b9cd3ecf1b732c7b40aaa51259c486f278c", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -1104,8 +1104,8 @@ cancel_loop_tree (struct loops *loops, struct loop *loop)\n   cancel_loop (loops, loop);\n }\n \n-/* Checks that LOOPS are allright:\n-     -- sizes of loops are allright\n+/* Checks that LOOPS are all right:\n+     -- sizes of loops are all right\n      -- results of get_loop_body really belong to the loop\n      -- loop header have just single entry edge and single latch edge\n      -- loop latches have only single successor that is header of their loop"}, {"sha": "5675f71cbf2cf9afd1cd9881e4c57e317cc050a2", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -471,7 +471,7 @@ add_loop (struct loops *loops, struct loop *loop)\n   free (bbs);\n }\n \n-/* Multiply all frequencies of basic blocks in array BBS of lenght NBBS\n+/* Multiply all frequencies of basic blocks in array BBS of length NBBS\n    by NUM/DEN.  */\n static void\n scale_bbs_frequencies (basic_block *bbs, int nbbs, int num, int den)\n@@ -604,7 +604,7 @@ unloop (struct loops *loops, struct loop *loop)\n   edge *edges;\n   unsigned n_edges;\n \n-  /* This is relatively straigtforward.  The dominators are unchanged, as\n+  /* This is relatively straightforward.  The dominators are unchanged, as\n      loop header dominates loop latch, so the only thing we have to care of\n      is the placement of loops and basic blocks inside the loop tree.  We\n      move them all to the loop->outer, and then let fix_bb_placements do\n@@ -831,7 +831,7 @@ loop_delete_branch_edge (edge e, int really_delete)\n    Additionally, we perform following manipulation with edges:\n    We have two special edges given. LATCH_EDGE is the latch edge of the\n    duplicated loop and leads into its header (one of blocks in BBS);\n-   it does not have neccessarily lead from one of the blocks, because\n+   it does not have necessarily lead from one of the blocks, because\n    we may be copying the loop body several times in unrolling.\n    Edge ENTRY leads also leads to header, and it is either latch or entry\n    edge.  Copy of LATCH_EDGE is redirected to header and is stored in"}, {"sha": "1205b4cfa37a8bae9da6c0a065e57ac143582f50", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -905,7 +905,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n   if (e->src != ENTRY_BLOCK_PTR && e->dest != EXIT_BLOCK_PTR\n       && any_condjump_p (e->src->end)\n       /* When called from cfglayout, fallthru edges do not\n-         neccessarily go to the next block.  */\n+         necessarily go to the next block.  */\n       && e->src->next_bb == e->dest\n       && JUMP_LABEL (e->src->end) == e->dest->head)\n     {\n@@ -1331,9 +1331,9 @@ mark_killed_regs (rtx reg, rtx set ATTRIBUTE_UNUSED, void *data)\n \n /* Similar to insert_insn_on_edge, tries to put INSN to edge E.  Additionally\n    it checks whether this will not clobber the registers that are live on the\n-   edge (i.e. it requieres liveness information to be up-to-date) and if there\n+   edge (i.e. it requires liveness information to be up-to-date) and if there\n    are some, then it tries to save and restore them.  Returns true if\n-   succesful.  */\n+   successful.  */\n bool\n safe_insert_insn_on_edge (rtx insn, edge e)\n {"}, {"sha": "91f99bf2e7163843cc17fa55785c97c2e6361321", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -27,10 +27,10 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n struct cgraph_local_info GTY(())\n {\n-  /* Set when function function is visiable in current compilation unit only\n+  /* Set when function function is visible in current compilation unit only\n      and it's address is never taken.  */\n   bool local;\n-  /* Set when function is small enought to be inlinable many times.  */\n+  /* Set when function is small enough to be inlinable many times.  */\n   bool inline_many;\n   /* Set when function can be inlined once (false only for functions calling\n      alloca, using varargs and so on).  */\n@@ -58,7 +58,7 @@ struct cgraph_rtl_info GTY(())\n \n \n /* The cgraph data strutcture.\n-   Each function decl has assigned cgraph_node listing calees and callers.  */\n+   Each function decl has assigned cgraph_node listing callees and callers.  */\n \n struct cgraph_node GTY(())\n {\n@@ -79,7 +79,7 @@ struct cgraph_node GTY(())\n      or it's address is taken.  */\n   bool needed;\n   /* Set when function is reachable by call from other function\n-     that is eighter reachable or needed.  */\n+     that is either reachable or needed.  */\n   bool reachable;\n   /* Set when the frontend has been asked to lower representation of this\n      function into trees.  Callees lists are not available when lowered"}, {"sha": "e7023a4014be4a8226d3f1725e11ab5f6af0801a", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -44,7 +44,7 @@ static void cgraph_mark_functions_to_inline_once PARAMS ((void));\n static void cgraph_optimize_function PARAMS ((struct cgraph_node *));\n \n /* Analyze function once it is parsed.  Set up the local information\n-   available - create cgraph edges for function calles via BODY.  */\n+   available - create cgraph edges for function calls via BODY.  */\n \n void\n cgraph_finalize_function (decl, body)\n@@ -57,7 +57,7 @@ cgraph_finalize_function (decl, body)\n \n   if (/* Externally visible functions must be output.  The exception are\n \t COMDAT functions that must be output only when they are needed.\n-\t Similarly are handled defered functions and\n+\t Similarly are handled deferred functions and\n \t external functions (GCC extension \"extern inline\") */\n       (TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n       /* ??? Constructors and destructors not called otherwise can be inlined\n@@ -294,7 +294,7 @@ cgraph_expand_function (node)\n   \n    Attempt to topologically sort the nodes so function is output when\n    all called functions are already assembled to allow data to be\n-   propagated accross the callgraph.  Use a stack to get smaller distance\n+   propagated across the callgraph.  Use a stack to get smaller distance\n    between a function and it's callees (later we may choose to use a more\n    sophisticated algorithm for function reordering; we will likely want\n    to use subsections to make the output functions appear in top-down"}, {"sha": "1d33071a7b67d85fa07cf5bfcacd690a2148b25f", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -4103,7 +4103,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n \n       /* (float_truncate:SF (float_truncate:DF foo:XF))\n          = (float_truncate:SF foo:XF).\n-\t This may elliminate double rounding, so it is unsafe.\n+\t This may eliminate double rounding, so it is unsafe.\n \n          (float_truncate:SF (float_extend:XF foo:DF))\n          = (float_truncate:SF foo:DF)."}, {"sha": "fc001b6e74e040b9bbb93a9c4d7f672ac4067284", "filename": "gcc/convert.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -152,7 +152,7 @@ convert_to_real (tree type, tree expr)\n       if (TYPE_PRECISION (TREE_TYPE (arg0)) > TYPE_PRECISION (type))\n \tnewtype = TREE_TYPE (arg0);\n \n-      /* Be curefull about integer to fp conversions.\n+      /* Be careful about integer to fp conversions.\n \t These may overflow still.  */\n       if (FLOAT_TYPE_P (TREE_TYPE (arg0))\n \t  && TYPE_PRECISION (newtype) < TYPE_PRECISION (itype)"}, {"sha": "6e561862f902eb81c084c72a07dcf36a7a440007", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -2014,7 +2014,7 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n       || DECL_IGNORED_P (decl))\n     DBXOUT_DECR_NESTING_AND_RETURN (0);\n \n-  /* If we are to generate only the symbols actualy used then such\n+  /* If we are to generate only the symbols actually used then such\n      symbol nodees are flagged with TREE_USED.  Ignore any that\n      aren't flaged as TREE_USED.  */\n "}, {"sha": "ae1896aa9b67e509b7f701efafcea5ec50f49fc9", "filename": "gcc/df.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -860,7 +860,7 @@ df_def_record_1 (struct df *df, rtx x, basic_block bb, rtx insn)\n   rtx dst;\n   enum df_ref_flags flags = 0;\n \n- /* We may recursivly call ourselves on EXPR_LIST when dealing with PARALLEL\n+ /* We may recursively call ourselves on EXPR_LIST when dealing with PARALLEL\n      construct.  */\n   if (GET_CODE (x) == EXPR_LIST || GET_CODE (x) == CLOBBER)\n     loc = &XEXP (x, 0);"}, {"sha": "9838aa834adf352b1af92f20a4ae55a3ca749e68", "filename": "gcc/df.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -92,7 +92,7 @@ struct insn_info\n {\n   struct df_link *defs;\t\t/* Head of insn-def chain.  */\n   struct df_link *uses;\t\t/* Head of insn-use chain.  */\n-  /* ???? The following luid field should be considerd private so that\n+  /* ???? The following luid field should be considered private so that\n      we can change it on the fly to accommodate new insns?  */\n   int luid;\t\t\t/* Logical UID.  */\n };"}, {"sha": "29cfaabe8783eb1618fe5e0e6c959b927b8063d2", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -46,7 +46,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* Format an integer given by va_arg (ARG, type-specifier T) where\n    type-specifier is a precision modifier as indicated by PREC.  F is\n-   a string used to construct the appropciate format-specifier.  */\n+   a string used to construct the appropriate format-specifier.  */\n #define output_integer_with_precision(BUFFER, ARG, PREC, T, F)  \\\n   do                                                            \\\n     switch (PREC)                                               \\\n@@ -332,7 +332,7 @@ output_append_r (output_buffer *buffer, const char *start, int length)\n   output_text_length (buffer) += length;\n }\n \n-/* Append a string deliminated by START and END to BUFFER.  No wrapping is\n+/* Append a string delimited by START and END to BUFFER.  No wrapping is\n    done.  However, if beginning a new line then emit BUFFER->state.prefix\n    and skip any leading whitespace if appropriate.  The caller must ensure\n    that it is safe to do so.  */"}, {"sha": "7537dd1bdac0fe8ccf53f27361e36252dbcdb476", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -3523,7 +3523,7 @@ static int current_function_has_inlines;\n static int comp_unit_has_inlines;\n #endif\n \n-/* Number of file tables emited in maybe_emit_file().  */\n+/* Number of file tables emitted in maybe_emit_file().  */\n static GTY(()) int emitcount = 0;\n \n /* Number of internal labels generated by gen_internal_sym().  */"}, {"sha": "7f734392773b6e4a4e560569c3133e558928de5e", "filename": "gcc/et-forest.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fet-forest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fet-forest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.h?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -41,7 +41,7 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n    the sequence is 1 2 4 2 5 3 1 3 1 4 1.\n \n-   The sequence is stored in a sligtly modified splay tree.\n+   The sequence is stored in a slightly modified splay tree.\n    In order to support various types of node values, a hashtable\n    is used to convert node values to the internal representation.  */\n "}, {"sha": "b70f8c7cffbb5567d7de1d041c495fb646d39066", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -585,7 +585,7 @@ verify_local_live_at_start (regset new_live_at_start, basic_block bb)\n /* Updates life information starting with the basic blocks set in BLOCKS.\n    If BLOCKS is null, consider it to be the universal set.\n \n-   If EXTENT is UPDATE_LIFE_LOCAL, such as after splitting or peepholeing,\n+   If EXTENT is UPDATE_LIFE_LOCAL, such as after splitting or peepholing,\n    we are only expecting local modifications to basic blocks.  If we find\n    extra registers live at the beginning of a block, then we either killed\n    useful data, or we have a broken split that wants data not provided."}, {"sha": "12770f25672a024e43156721b115e9a57f9fdbfe", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -5779,7 +5779,7 @@ fold (expr)\n \t      /* Preserve the MINUS_EXPR if the negative part of the literal is\n \t\t greater than the positive part.  Otherwise, the multiplicative\n \t\t folding code (i.e extract_muldiv) may be fooled in case\n-\t\t unsigned constants are substracted, like in the following\n+\t\t unsigned constants are subtracted, like in the following\n \t\t example: ((X*2 + 4) - 8U)/2.  */\n \t      if (minus_lit0 && lit0)\n \t\t{"}, {"sha": "b1c9d757b969201878af6d154683a0b2e389c9af", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -485,7 +485,7 @@ struct function GTY(())\n   /* Nonzero if the current function needs an lsda for exception handling.  */\n   unsigned int uses_eh_lsda : 1;\n \n-  /* Nonzero if code to initialize arg_pointer_save_area has been emited.  */\n+  /* Nonzero if code to initialize arg_pointer_save_area has been emitted.  */\n   unsigned int arg_pointer_save_area_init : 1;\n \n   /* How commonly executed the function is.  Initialized during branch"}, {"sha": "5d0b716c7f1ea1ae195e54193db1439cfd19552a", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -88,7 +88,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    most significant is allocated first.  Unused levels are zero.\n    Active levels are odd-valued, so that the LSB of the level is one.\n    A sub-level incorporates the values of its superlevels.  This\n-   formatting allows you to determine the tag heirarchy, without\n+   formatting allows you to determine the tag hierarchy, without\n    understanding the tags themselves, and is similar to the standard\n    section numbering used in technical documents.  Level values\n    [1..3f] are used for common tags, values [41..9f] for the graph\n@@ -514,7 +514,7 @@ gcov_is_error (void)\n }\n \n #if IN_LIBGCOV\n-/* Move to beginning of file and intialize for writing.  */\n+/* Move to beginning of file and initialize for writing.  */\n \n static inline void\n gcov_rewrite (void)"}, {"sha": "c671599c88666f7ccc00ec7093ae762338557c04", "filename": "gcc/gcov.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -1147,7 +1147,7 @@ solve_flow_graph (fn)\n \t      {\n \t\tarc->is_unconditional = 1;\n \t\t/* If this block is instrumenting a call, it might be\n-\t\t   an artifical block. It is not artificial if it has\n+\t\t   an artificial block. It is not artificial if it has\n \t\t   a non-fallthrough exit, or the destination of this\n \t\t   arc has more than one entry.  Mark the destination\n \t\t   block as a return site, if none of those conditions"}, {"sha": "2308f870a94e2f54cfc5a97e9525c6d9498732e7", "filename": "gcc/gcse.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -4842,7 +4842,7 @@ reg_killed_on_edge (reg, e)\n    JUMP.  Otherwise, SETCC is NULL, and JUMP is the first insn of BB.\n    Returns nonzero if a change was made.\n \n-   During the jump bypassing pass, we may place copies of SETCC instuctions\n+   During the jump bypassing pass, we may place copies of SETCC instructions\n    on CFG edges.  The following routine must be careful to pay attention to\n    these inserted insns when performing its transformations.  */\n \n@@ -4885,8 +4885,8 @@ bypass_block (bb, setcc, jump)\n \tcontinue;\n \n       /* The irreducible loops created by redirecting of edges entering the\n-\t loop from outside would decrease effectivity of some of the following\n-\t optimalizations, so prevent this.  */\n+\t loop from outside would decrease effectiveness of some of the following\n+\t optimizations, so prevent this.  */\n       if (may_be_loop_header\n \t  && !(e->flags & EDGE_DFS_BACK))\n \tcontinue;\n@@ -5839,7 +5839,7 @@ add_label_notes (x, insn)\n   if (code == LABEL_REF && !LABEL_REF_NONLOCAL_P (x))\n     {\n       /* This code used to ignore labels that referred to dispatch tables to\n-\t avoid flow generating (slighly) worse code.\n+\t avoid flow generating (slightly) worse code.\n \n \t We no longer ignore such label references (see LABEL_REF handling in\n \t mark_jump_label for additional information).  */\n@@ -6448,7 +6448,7 @@ hoist_code ()\n \t\t to avoid any possible code expansion due to register\n \t\t allocation issues; however experiments have shown that\n \t\t the vast majority of hoistable expressions are only movable\n-\t\t from two successors, so raising this threshhold is likely\n+\t\t from two successors, so raising this threshold is likely\n \t\t to nullify any benefit we get from code hoisting.  */\n \t      if (hoistable > 1)\n \t\t{\n@@ -7163,7 +7163,7 @@ extract_mentioned_regs_helper (x, accum)\n \n    The things are complicated a bit by fact that there already may be stores\n    to the same MEM from other blocks; also caller must take care of the\n-   neccessary cleanup of the temporary markers after end of the basic block.\n+   necessary cleanup of the temporary markers after end of the basic block.\n    */\n \n static void\n@@ -7222,7 +7222,7 @@ find_moveable_store (insn, regs_set_before, regs_set_after)\n \t\t\t\t\t\tANTIC_STORE_LIST (ptr));\n     }\n \n-  /* It is not neccessary to check whether store is available if we did\n+  /* It is not necessary to check whether store is available if we did\n      it successfully before; if we failed before, do not bother to check\n      until we reach the insn that caused us to fail.  */\n   check_available = 0;\n@@ -7608,7 +7608,7 @@ build_store_vectors ()\n \t  if (store_killed_after (ptr->pattern, ptr->pattern_regs, bb->head,\n \t\t\t\t  bb, regs_set_in_block, NULL))\n \t    {\n-\t      /* It should not be neccessary to consider the expression\n+\t      /* It should not be necessary to consider the expression\n \t\t killed if it is both anticipatable and available.  */\n \t      if (!TEST_BIT (st_antloc[bb->index], ptr->index)\n \t\t  || !TEST_BIT (ae_gen[bb->index], ptr->index))"}, {"sha": "5ed43a70f7ca6057ed2ba1df8b34643989d4657c", "filename": "gcc/genautomata.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -1616,7 +1616,7 @@ n_sep_els (char *s, int sep, int par_flag)\n    elements in the string and number of elements through els_num.\n    Take parentheses into account if PAREN_P has nonzero value.  The\n    function also inserts the end marker NULL at the end of vector.\n-   Return 0 for the null string, -1 if parantheses are not balanced.  */\n+   Return 0 for the null string, -1 if parentheses are not balanced.  */\n static char **\n get_str_vect (char *str, int *els_num, int sep, int paren_p)\n {"}, {"sha": "12f0fccd780c2b25887c571e574d96d675133e0b", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -484,7 +484,7 @@ gt_pch_save (FILE *f)\n \n   ggc_pch_prepare_write (state.d, state.f);\n \n-  /* Pad the PCH file so that the mmaped area starts on a page boundary.  */\n+  /* Pad the PCH file so that the mmapped area starts on a page boundary.  */\n   {\n     long o;\n     o = ftell (state.f) + sizeof (mmi);"}, {"sha": "5063ccd18bab67104ddcf16bdc686c81d44bf5b3", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -853,8 +853,8 @@ adjust_depth (void)\n     {\n       top = G.by_depth[G.by_depth_in_use-1];\n \n-      /* Peel back indicies in depth that index into by_depth, so that\n-\t as new elements are added to by_depth, we note the indicies\n+      /* Peel back indices in depth that index into by_depth, so that\n+\t as new elements are added to by_depth, we note the indices\n \t of those elements, if they are for new context depths.  */\n       while (G.depth_in_use > (size_t)top->context_depth+1)\n \t--G.depth_in_use;"}, {"sha": "b8c035fbc81c548b79eb92db43c1f62f4a586048", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -32,7 +32,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"expr.h\"\n \n /* This pass performs loop unrolling and peeling.  We only perform these\n-   optimalizations on innermost loops (with single exception) because\n+   optimizations on innermost loops (with single exception) because\n    the impact on performance is greatest here, and we want to avoid\n    unnecessary code size growth.  The gain is caused by greater sequentiality\n    of code, better code to optimize for futher passes and in some cases\n@@ -511,7 +511,7 @@ decide_unroll_constant_iterations (loops, loop, flags)\n \n   /* Success; now compute number of iterations to unroll.  We alter\n      nunroll so that as few as possible copies of loop body are\n-     neccesary, while still not decreasing the number of unrollings\n+     necessary, while still not decreasing the number of unrollings\n      too much (at most by 1).  */\n   best_copies = 2 * nunroll + 10;\n \n@@ -1153,7 +1153,7 @@ decide_unroll_stupid (loops, loop, flags)\n     }\n \n   /* Success.  Now force nunroll to be power of 2, as it seems that this\n-     improves results (partially because of better aligments, partially\n+     improves results (partially because of better alignments, partially\n      because of some dark magic).  */\n   for (i = 1; 2 * i <= nunroll; i *= 2);\n "}, {"sha": "dd8bcbd7af1ac5ec17c57fd4f88f9181497ebf14", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -32,7 +32,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"expr.h\"\n \n /* This pass moves constant conditions out of loops, duplicating the loop\n-   in progres, i.e. this code:\n+   in progress, i.e. this code:\n \n    while (loop_cond)\n      {"}, {"sha": "265bfb40d74360427216a2664cc298288162c535", "filename": "gcc/loop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -71,7 +71,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define gen_prefetch(a,b,c) (abort(), NULL_RTX)\n #endif\n \n-/* Give up the prefetch optimizations once we exceed a given threshhold.\n+/* Give up the prefetch optimizations once we exceed a given threshold.\n    It is unlikely that we would be able to optimize something in a loop\n    with so many detected prefetches.  */\n #define MAX_PREFETCHES 100\n@@ -1774,7 +1774,7 @@ add_label_notes (x, insns)\n   if (code == LABEL_REF && !LABEL_REF_NONLOCAL_P (x))\n     {\n       /* This code used to ignore labels that referred to dispatch tables to\n-         avoid flow generating (slighly) worse code.\n+         avoid flow generating (slightly) worse code.\n \n          We no longer ignore such label references (see LABEL_REF handling in\n          mark_jump_label for additional information).  */\n@@ -10650,7 +10650,7 @@ loop_insn_sink (loop, pattern)\n   return loop_insn_emit_before (loop, 0, loop->sink, pattern);\n }\n \n-/* bl->final_value can be eighter general_operand or PLUS of general_operand\n+/* bl->final_value can be either general_operand or PLUS of general_operand\n    and constant.  Emit sequence of instructions to load it into REG.  */\n static rtx\n gen_load_of_final_value (reg, final_value)"}, {"sha": "fbcef109d153cb3dbc78009d32e08036f9954c60", "filename": "gcc/mips-tfile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fmips-tfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fmips-tfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tfile.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -163,7 +163,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n    Each file table has offsets for where the line numbers, local\n    strings, local symbols, and procedure table starts from within the\n-   global tables, and the indexs are reset to 0 for each of those\n+   global tables, and the indices are reset to 0 for each of those\n    tables for the file.\n \n    The procedure table contains the binary equivalents of the .ent"}, {"sha": "edd4eaeb6d620aacf5e99dc885eac02f3d4e7bc5", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -5123,7 +5123,7 @@ expand_fix (to, from, unsignedp)\n \n      In the other path we know the value is positive in the range 2^63..2^64-1\n      inclusive.  (as for other imput overflow happens and result is undefined)\n-     So we know that the most important bit set in mantisa corresponds to\n+     So we know that the most important bit set in mantissa corresponds to\n      2^63.  The subtraction of 2^63 should not generate any rounding as it\n      simply clears out that bit.  The rest is trivial.  */\n "}, {"sha": "c4cc59a253d17b620b10d60d10250e038702529e", "filename": "gcc/ra-build.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fra-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fra-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-build.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -622,7 +622,7 @@ struct curr_use {\n    4 if both are SUBREG's of different size, but have bytes in common.\n    -1 is a special case, for when DEF and USE refer to the same regno, but\n       have for other reasons no bits in common (can only happen with\n-      subregs refering to different words, or to words which already were\n+      subregs referring to different words, or to words which already were\n       defined for this USE).\n    Furthermore it modifies use->undefined to clear the bits which get defined\n    by DEF (only for cases with partial overlap)."}, {"sha": "121cd1bbca1768f595e687721b3d91e4dd529fec", "filename": "gcc/ra-colorize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fra-colorize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fra-colorize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-colorize.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -1748,7 +1748,7 @@ try_recolor_web (web)\n \t}\n       /* Mark colors for which some wide webs are involved.  For\n \t those the independent sets are not simply one-node graphs, so\n-\t they can't be recolored independ from their neighborhood.  This\n+\t they can't be recolored independent from their neighborhood.  This\n \t means, that our cost calculation can be incorrect (assuming it\n \t can avoid spilling a web because it thinks some colors are available,\n \t although it's neighbors which itself need recoloring might take"}, {"sha": "21ff034f2ba9a1420fc389f7dc6d439abf10f1fc", "filename": "gcc/ra-rewrite.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fra-rewrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fra-rewrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-rewrite.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -1545,7 +1545,7 @@ detect_web_parts_to_rebuild ()\n \n   /* We also recheck unconditionally all uses of any hardregs.  This means\n      we _can_ delete all these uses from the live_at_end[] bitmaps.\n-     And because we sometimes delete insn refering to hardregs (when\n+     And because we sometimes delete insn referring to hardregs (when\n      they became useless because they setup a rematerializable pseudo, which\n      then was rematerialized), some of those uses will go away with the next\n      df_analyse().  This means we even _must_ delete those uses from"}, {"sha": "dd3cb5108e8d582d02d1d5c326e4ca8820cb6879", "filename": "gcc/ra.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fra.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fra.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra.h?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -466,7 +466,7 @@ extern struct dlist *web_lists[(int) LAST_NODE_TYPE];\n \n /* The largest DF_REF_ID of defs resp. uses, as it was in the\n    last pass.  In the first pass this is zero.  Used to distinguish new\n-   from old refrences.  */\n+   from old references.  */\n extern unsigned int last_def_id;\n extern unsigned int last_use_id;\n \n@@ -563,7 +563,7 @@ extern int flag_ra_break_aliases;\n extern int flag_ra_merge_spill_costs;\n \n /* Nonzero if we want to spill at every use, instead of at deaths,\n-   or intereference region borders.  */\n+   or interference region borders.  */\n extern int flag_ra_spill_every_use;\n \n /* Nonzero to output all notes in the debug dumps.  */"}, {"sha": "0c3c25d07264a25c4535d5eb09854c9d1a66a86f", "filename": "gcc/regmove.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -2323,14 +2323,14 @@ record_stack_memrefs (xp, data)\n       return 1;\n     case REG:\n       /* ??? We want be able to handle non-memory stack pointer\n-\t references later.  For now just discard all insns refering to\n+\t references later.  For now just discard all insns referring to\n \t stack pointer outside mem expressions.  We would probably\n \t want to teach validate_replace to simplify expressions first.\n \n \t We can't just compare with STACK_POINTER_RTX because the\n \t reference to the stack pointer might be in some other mode.\n \t In particular, an explicit clobber in an asm statement will\n-\t result in a QImode clober.  */\n+\t result in a QImode clobber.  */\n       if (REGNO (x) == STACK_POINTER_REGNUM)\n \treturn 1;\n       break;"}, {"sha": "6df08c427785fe4219f1cf7800b63113bd9757f4", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -5319,7 +5319,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t\t\t\t\t       GET_MODE (orig_op1))));\n \t  }\n \t/* Plus in the index register may be created only as a result of\n-\t   register remateralization for expresion like &localvar*4.  Reload it.\n+\t   register remateralization for expression like &localvar*4.  Reload it.\n \t   It may be possible to combine the displacement on the outer level,\n \t   but it is probably not worthwhile to do so.  */\n \tif (context)"}, {"sha": "8ad6281aa4d7487395fc4b28a163b1d20d5be163", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -3600,7 +3600,7 @@ hoist_test_store (x, val, live)\n   if (rtx_equal_p (x, val))\n     return true;\n \n-  /* Allow subreg of X in case it is not writting just part of multireg pseudo.\n+  /* Allow subreg of X in case it is not writing just part of multireg pseudo.\n      Then we would need to update all users to care hoisting the store too.\n      Caller may represent that by specifying whole subreg as val.  */\n \n@@ -3621,7 +3621,7 @@ hoist_test_store (x, val, live)\n   if (!REG_P (x))\n     return false;\n \n-  /* Pseudo registers can be allways replaced by another pseudo to avoid\n+  /* Pseudo registers can be always replaced by another pseudo to avoid\n      the side effect, for hard register we must ensure that they are dead.\n      Eventually we may want to add code to try turn pseudos to hards, but it\n      is unlikely useful.  */"}, {"sha": "d27630ead5d17ca30d9f26c62d4ee2af4f601020", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -206,7 +206,7 @@ static struct sched_info ebb_sched_info =\n   0, 1\n };\n \f\n-/* It is possible that ebb scheduling elliminated some blocks.\n+/* It is possible that ebb scheduling eliminated some blocks.\n    Place blocks from FIRST to LAST before BEFORE.  */\n \n static void\n@@ -268,7 +268,7 @@ fix_basic_block_boundaries (bb, last, head, tail)\n \t    last_inside = insn;\n \t}\n       /* Control flow instruction terminate basic block.  It is possible\n-\t that we've elliminated some basic blocks (made them empty).\n+\t that we've eliminated some basic blocks (made them empty).\n \t Find the proper basic block using BLOCK_FOR_INSN and arrange things in\n \t a sensible way by inserting empty basic blocks as needed.  */\n       if (control_flow_insn_p (insn) || (insn == tail && last_inside))\n@@ -303,7 +303,7 @@ fix_basic_block_boundaries (bb, last, head, tail)\n \t\t  h = curr_bb->head;\n \t\t  curr_bb->head = head;\n \t\t  curr_bb->end = insn;\n-\t\t  /* Edge splitting created missplaced BASIC_BLOCK note, kill\n+\t\t  /* Edge splitting created misplaced BASIC_BLOCK note, kill\n \t\t     it.  */\n \t\t  delete_insn (h);\n \t\t}\n@@ -453,7 +453,7 @@ add_deps_for_risky_insns (head, tail)\n \t  case TRAP_RISKY:\n \t  case IRISKY:\n \t  case PRISKY_CANDIDATE:\n-\t    /* ??? We could implement better checking PRISKY_CANDIATEs\n+\t    /* ??? We could implement better checking PRISKY_CANDIDATEs\n \t       analogous to sched-rgn.c.  */\n \t    /* We can not change the mode of the backward\n \t       dependency because REG_DEP_ANTI has the lowest"}, {"sha": "180df157de9c9f6da0d86a7dbc657221f9e91b60", "filename": "gcc/sched-int.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -188,7 +188,7 @@ struct haifa_insn_data\n   int priority;\n \n   /* The number of incoming edges in the forward dependency graph.\n-     As scheduling proceds, counts are decreased.  An insn moves to\n+     As scheduling proceeds, counts are decreased.  An insn moves to\n      the ready queue when its counter reaches zero.  */\n   int dep_count;\n "}, {"sha": "b7bd41d5b283886fe6c0ca172d75b3a4d5bd0cf0", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -544,7 +544,7 @@ print_exp (buf, x, verbose)\n     cur = safe_concat (buf, cur, \")\");\n }\t\t/* print_exp */\n \n-/* Prints rtxes, I customly classified as values.  They're constants,\n+/* Prints rtxes, I customarily classified as values.  They're constants,\n    registers, labels, symbols and memory accesses.  */\n \n static void"}, {"sha": "e27fe914e76a0153f9f0e81488d3e469e0032b0a", "filename": "gcc/sreal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fsreal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fsreal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsreal.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -34,7 +34,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    otherwise two HOST_WIDE_INTs are used for the significant.\n    Only a half of significant bits is used (in normalized sreals) so that we do\n    not have problems with overflow, for example when c->sig = a->sig * b->sig.\n-   So the precission for 64-bit and 32-bit machines is 32-bit.\n+   So the precision for 64-bit and 32-bit machines is 32-bit.\n \t\t\t\n    Invariant: The numbers are normalized before and after each call of sreal_*.\n "}, {"sha": "a5b1c24f377b4d46e68af83f7a2c286dfec5c399", "filename": "gcc/ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-ccp.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -338,7 +338,7 @@ visit_expression (insn, block)\n \t     blocks as executable if they have not already been\n \t     marked.\n \n-\t     One day we may try do better with swtich tables and\n+\t     One day we may try do better with switch tables and\n \t     other computed jumps.  */\n \t  for (curredge = block->succ; curredge;\n \t       curredge = curredge->succ_next)"}, {"sha": "2484582a526df01866dc65f8986a8b53ff410302", "filename": "gcc/ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -499,7 +499,7 @@ find_evaluations (evals, nregs)\n \n /* Computing the Dominance Frontier:\n \n-   As decribed in Morgan, section 3.5, this may be done simply by\n+   As described in Morgan, section 3.5, this may be done simply by\n    walking the dominator tree bottom-up, computing the frontier for\n    the children before the parent.  When considering a block B,\n    there are two cases:"}, {"sha": "da514a2ba8a6b46ce68d3d8b7271cd051e992b1a", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -3280,7 +3280,7 @@ rest_of_handle_loop_optimize (tree decl, rtx insns)\n   ggc_collect ();\n }\n \n-/* Perform loop optimalizations.  It might be better to do them a bit\n+/* Perform loop optimizations.  It might be better to do them a bit\n    sooner, but we want the profile feedback to work more\n    efficiently.  */\n static void\n@@ -3296,7 +3296,7 @@ rest_of_handle_loop2 (tree decl, rtx insns)\n \n   if (loops)\n     {\n-      /* The optimalizations:  */\n+      /* The optimizations:  */\n       if (flag_unswitch_loops)\n \tunswitch_loops (loops);\n "}, {"sha": "a8118f519d675f3b9e213b1a13ab4f0881a31517", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -1017,7 +1017,7 @@ inlinable_function_p (fn, id, nolimit)\n \t   && currfn_insns > max_inline_insns_single)\n     inlinable = 0;\n   /* We can't inline functions that call __builtin_longjmp at all.\n-     The non-local goto machenery really requires the destination\n+     The non-local goto machinery really requires the destination\n      be in a different function.  If we allow the function calling\n      __builtin_longjmp to be inlined into the function calling\n      __builtin_setjmp, Things will Go Awry.  */"}, {"sha": "e843ddbe56b6d9289a5042c9a89bd69dda668ee6", "filename": "gcc/value-prof.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -40,7 +40,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    insn_values_to_profile function.  This function is called from branch_prob\n    in profile.c and the requested values are instrumented by it in the first\n    compilation with -fprofile-arcs.  The optimization may then read the\n-   gathered data in the second compilation with -fbranch-probablities (the\n+   gathered data in the second compilation with -fbranch-probabilities (the\n    description of an exact way how to do it will be added here once the\n    code responsible for reading of the data is merged).  */\n "}, {"sha": "74b754a25d6641236b6c82e2a65327072617a9c2", "filename": "gcc/value-prof.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bb17a83f613106571d3b516168d12cf83b10be/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=e0bb17a83f613106571d3b516168d12cf83b10be", "patch": "@@ -35,10 +35,10 @@ struct histogram_value\n {\n   rtx value;\t\t/* The value to profile.  */\n   enum machine_mode mode; /* And its mode.  */\n-  rtx seq;\t\t/* Insns requiered to count the profiled value.  */\n+  rtx seq;\t\t/* Insns required to count the profiled value.  */\n   rtx insn;\t\t/* Insn before that to measure.  */\n   enum hist_type type;\t/* Type of information to measure.  */\n-  unsigned n_counters;\t/* Number of requiered counters.  */\n+  unsigned n_counters;\t/* Number of required counters.  */\n   union\n     {\n       struct"}]}