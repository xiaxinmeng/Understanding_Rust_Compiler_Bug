{"sha": "9ad6bebe4e297f5dae536f15f74f6516eecb034a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFkNmJlYmU0ZTI5N2Y1ZGFlNTM2ZjE1Zjc0ZjY1MTZlZWNiMDM0YQ==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-10-08T13:10:47Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-10-08T13:10:47Z"}, "message": "tree-ssa-sccvn.c (init_vn_nary_op_from_pieces): New function.\n\n\t* tree-ssa-sccvn.c (init_vn_nary_op_from_pieces): New function.\n\t(init_vn_nary_op_from_op): New function.\n\t(init_vn_nary_op_from_stmt): New function.\n\t(vn_nary_op_lookup_1): New function.\n\t(sizeof_vn_nary_op): New function.\n\t(alloc_vn_nary_op_noinit): New function.\n\t(alloc_vn_nary_op): New function.\n\t(vn_nary_op_insert_into): New function.\n\t(vn_nary_op_lookup_pieces): Rewrite to use new helper functions.\n\t(vn_nary_op_lookup): Likewise.\n\t(vn_nary_op_lookup_stmt): Likewise.\n\t(vn_nary_op_insert_pieces): Likewise.\n\t(vn_nary_op_insert): Likewise.\n\t(vn_nary_op_insert_stmt): Likewise.\n\t(copy_nary): Likewise.\n\t(set_value_id_for_result): New function.\n\t(set_hashtable_value_ids): Call it.\n\nFrom-SVN: r165178", "tree": {"sha": "4e7799dab73e9614f07b2bea6f3e95620fd417a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e7799dab73e9614f07b2bea6f3e95620fd417a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ad6bebe4e297f5dae536f15f74f6516eecb034a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ad6bebe4e297f5dae536f15f74f6516eecb034a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ad6bebe4e297f5dae536f15f74f6516eecb034a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ad6bebe4e297f5dae536f15f74f6516eecb034a/comments", "author": null, "committer": null, "parents": [{"sha": "b878c9389eaf6453f7586f4a8366b28c88240301", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b878c9389eaf6453f7586f4a8366b28c88240301", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b878c9389eaf6453f7586f4a8366b28c88240301"}], "stats": {"total": 345, "additions": 179, "deletions": 166}, "files": [{"sha": "f75bbe4862b3853b1991d95558dc3e8450a6c441", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ad6bebe4e297f5dae536f15f74f6516eecb034a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ad6bebe4e297f5dae536f15f74f6516eecb034a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ad6bebe4e297f5dae536f15f74f6516eecb034a", "patch": "@@ -1,3 +1,23 @@\n+2010-10-08  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* tree-ssa-sccvn.c (init_vn_nary_op_from_pieces): New function.\n+\t(init_vn_nary_op_from_op): New function.\n+\t(init_vn_nary_op_from_stmt): New function.\n+\t(vn_nary_op_lookup_1): New function.\n+\t(sizeof_vn_nary_op): New function.\n+\t(alloc_vn_nary_op_noinit): New function.\n+\t(alloc_vn_nary_op): New function.\n+\t(vn_nary_op_insert_into): New function.\n+\t(vn_nary_op_lookup_pieces): Rewrite to use new helper functions.\n+\t(vn_nary_op_lookup): Likewise.\n+\t(vn_nary_op_lookup_stmt): Likewise.\n+\t(vn_nary_op_insert_pieces): Likewise.\n+\t(vn_nary_op_insert): Likewise.\n+\t(vn_nary_op_insert_stmt): Likewise.\n+\t(copy_nary): Likewise.\n+\t(set_value_id_for_result): New function.\n+\t(set_hashtable_value_ids): Call it.\n+\n 2010-10-08  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* config/fr30/fr30.c (TARGET_EXCEPT_UNWIND_INFO): Define."}, {"sha": "ed56d1de673b61882718bc6d5031048a28fe8f59", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 159, "deletions": 166, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ad6bebe4e297f5dae536f15f74f6516eecb034a/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ad6bebe4e297f5dae536f15f74f6516eecb034a/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=9ad6bebe4e297f5dae536f15f74f6516eecb034a", "patch": "@@ -1698,33 +1698,73 @@ vn_nary_op_eq (const void *p1, const void *p2)\n   return true;\n }\n \n-/* Lookup a n-ary operation by its pieces and return the resulting value\n-   number if it exists in the hash table.  Return NULL_TREE if it does\n-   not exist in the hash table or if the result field of the operation\n-   is NULL. VNRESULT will contain the vn_nary_op_t from the hashtable\n-   if it exists.  */\n+/* Initialize VNO from the pieces provided.  */\n \n-tree\n-vn_nary_op_lookup_pieces (unsigned int length, enum tree_code code,\n-\t\t\t  tree type, tree op0, tree op1, tree op2,\n-\t\t\t  tree op3, vn_nary_op_t *vnresult)\n+static void\n+init_vn_nary_op_from_pieces (vn_nary_op_t vno, unsigned int length,\n+\t\t\t     enum tree_code code, tree type, tree op0,\n+\t\t\t     tree op1, tree op2, tree op3)\n+{\n+  vno->opcode = code;\n+  vno->length = length;\n+  vno->type = type;\n+  vno->op[0] = op0;\n+  vno->op[1] = op1;\n+  vno->op[2] = op2;\n+  vno->op[3] = op3;\n+}\n+\n+/* Initialize VNO from OP.  */\n+\n+static void\n+init_vn_nary_op_from_op (vn_nary_op_t vno, tree op)\n+{\n+  unsigned i;\n+\n+  vno->opcode = TREE_CODE (op);\n+  vno->length = TREE_CODE_LENGTH (TREE_CODE (op));\n+  vno->type = TREE_TYPE (op);\n+  for (i = 0; i < vno->length; ++i)\n+    vno->op[i] = TREE_OPERAND (op, i);\n+}\n+\n+/* Initialize VNO from STMT.  */\n+\n+static void\n+init_vn_nary_op_from_stmt (vn_nary_op_t vno, gimple stmt)\n+{\n+  unsigned i;\n+\n+  vno->opcode = gimple_assign_rhs_code (stmt);\n+  vno->length = gimple_num_ops (stmt) - 1;\n+  vno->type = gimple_expr_type (stmt);\n+  for (i = 0; i < vno->length; ++i)\n+    vno->op[i] = gimple_op (stmt, i + 1);\n+  if (vno->opcode == REALPART_EXPR\n+      || vno->opcode == IMAGPART_EXPR\n+      || vno->opcode == VIEW_CONVERT_EXPR)\n+    vno->op[0] = TREE_OPERAND (vno->op[0], 0);\n+}\n+\n+/* Compute the hashcode for VNO and look for it in the hash table;\n+   return the resulting value number if it exists in the hash table.\n+   Return NULL_TREE if it does not exist in the hash table or if the\n+   result field of the operation is NULL.  VNRESULT will contain the\n+   vn_nary_op_t from the hashtable if it exists.  */\n+\n+static tree\n+vn_nary_op_lookup_1 (vn_nary_op_t vno, vn_nary_op_t *vnresult)\n {\n   void **slot;\n-  struct vn_nary_op_s vno1;\n+\n   if (vnresult)\n     *vnresult = NULL;\n-  vno1.opcode = code;\n-  vno1.length = length;\n-  vno1.type = type;\n-  vno1.op[0] = op0;\n-  vno1.op[1] = op1;\n-  vno1.op[2] = op2;\n-  vno1.op[3] = op3;\n-  vno1.hashcode = vn_nary_op_compute_hash (&vno1);\n-  slot = htab_find_slot_with_hash (current_info->nary, &vno1, vno1.hashcode,\n+\n+  vno->hashcode = vn_nary_op_compute_hash (vno);\n+  slot = htab_find_slot_with_hash (current_info->nary, vno, vno->hashcode,\n \t\t\t\t   NO_INSERT);\n   if (!slot && current_info == optimistic_info)\n-    slot = htab_find_slot_with_hash (valid_info->nary, &vno1, vno1.hashcode,\n+    slot = htab_find_slot_with_hash (valid_info->nary, vno, vno->hashcode,\n \t\t\t\t     NO_INSERT);\n   if (!slot)\n     return NULL_TREE;\n@@ -1733,6 +1773,22 @@ vn_nary_op_lookup_pieces (unsigned int length, enum tree_code code,\n   return ((vn_nary_op_t)*slot)->result;\n }\n \n+/* Lookup a n-ary operation by its pieces and return the resulting value\n+   number if it exists in the hash table.  Return NULL_TREE if it does\n+   not exist in the hash table or if the result field of the operation\n+   is NULL. VNRESULT will contain the vn_nary_op_t from the hashtable\n+   if it exists.  */\n+\n+tree\n+vn_nary_op_lookup_pieces (unsigned int length, enum tree_code code,\n+\t\t\t  tree type, tree op0, tree op1, tree op2,\n+\t\t\t  tree op3, vn_nary_op_t *vnresult)\n+{\n+  struct vn_nary_op_s vno1;\n+  init_vn_nary_op_from_pieces (&vno1, length, code, type, op0, op1, op2, op3);\n+  return vn_nary_op_lookup_1 (&vno1, vnresult);\n+}\n+\n /* Lookup OP in the current hash table, and return the resulting value\n    number if it exists in the hash table.  Return NULL_TREE if it does\n    not exist in the hash table or if the result field of the operation\n@@ -1742,28 +1798,9 @@ vn_nary_op_lookup_pieces (unsigned int length, enum tree_code code,\n tree\n vn_nary_op_lookup (tree op, vn_nary_op_t *vnresult)\n {\n-  void **slot;\n   struct vn_nary_op_s vno1;\n-  unsigned i;\n-\n-  if (vnresult)\n-    *vnresult = NULL;\n-  vno1.opcode = TREE_CODE (op);\n-  vno1.length = TREE_CODE_LENGTH (TREE_CODE (op));\n-  vno1.type = TREE_TYPE (op);\n-  for (i = 0; i < vno1.length; ++i)\n-    vno1.op[i] = TREE_OPERAND (op, i);\n-  vno1.hashcode = vn_nary_op_compute_hash (&vno1);\n-  slot = htab_find_slot_with_hash (current_info->nary, &vno1, vno1.hashcode,\n-\t\t\t\t   NO_INSERT);\n-  if (!slot && current_info == optimistic_info)\n-    slot = htab_find_slot_with_hash (valid_info->nary, &vno1, vno1.hashcode,\n-\t\t\t\t     NO_INSERT);\n-  if (!slot)\n-    return NULL_TREE;\n-  if (vnresult)\n-    *vnresult = (vn_nary_op_t)*slot;\n-  return ((vn_nary_op_t)*slot)->result;\n+  init_vn_nary_op_from_op (&vno1, op);\n+  return vn_nary_op_lookup_1 (&vno1, vnresult);\n }\n \n /* Lookup the rhs of STMT in the current hash table, and return the resulting\n@@ -1774,32 +1811,59 @@ vn_nary_op_lookup (tree op, vn_nary_op_t *vnresult)\n tree\n vn_nary_op_lookup_stmt (gimple stmt, vn_nary_op_t *vnresult)\n {\n-  void **slot;\n   struct vn_nary_op_s vno1;\n-  unsigned i;\n+  init_vn_nary_op_from_stmt (&vno1, stmt);\n+  return vn_nary_op_lookup_1 (&vno1, vnresult);\n+}\n \n-  if (vnresult)\n-    *vnresult = NULL;\n-  vno1.opcode = gimple_assign_rhs_code (stmt);\n-  vno1.length = gimple_num_ops (stmt) - 1;\n-  vno1.type = gimple_expr_type (stmt);\n-  for (i = 0; i < vno1.length; ++i)\n-    vno1.op[i] = gimple_op (stmt, i + 1);\n-  if (vno1.opcode == REALPART_EXPR\n-      || vno1.opcode == IMAGPART_EXPR\n-      || vno1.opcode == VIEW_CONVERT_EXPR)\n-    vno1.op[0] = TREE_OPERAND (vno1.op[0], 0);\n-  vno1.hashcode = vn_nary_op_compute_hash (&vno1);\n-  slot = htab_find_slot_with_hash (current_info->nary, &vno1, vno1.hashcode,\n-\t\t\t\t   NO_INSERT);\n-  if (!slot && current_info == optimistic_info)\n-    slot = htab_find_slot_with_hash (valid_info->nary, &vno1, vno1.hashcode,\n-\t\t\t\t     NO_INSERT);\n-  if (!slot)\n-    return NULL_TREE;\n-  if (vnresult)\n-    *vnresult = (vn_nary_op_t)*slot;\n-  return ((vn_nary_op_t)*slot)->result;\n+/* Return the size of a vn_nary_op_t with LENGTH operands.  */\n+\n+static size_t\n+sizeof_vn_nary_op (unsigned int length)\n+{\n+  return sizeof (struct vn_nary_op_s) - sizeof (tree) * (4 - length);\n+}\n+\n+/* Allocate a vn_nary_op_t with LENGTH operands on STACK.  */\n+\n+static vn_nary_op_t\n+alloc_vn_nary_op_noinit (unsigned int length, struct obstack *stack)\n+{\n+  return (vn_nary_op_t) obstack_alloc (stack, sizeof_vn_nary_op (length));\n+}\n+\n+/* Allocate and initialize a vn_nary_op_t on CURRENT_INFO's\n+   obstack.  */\n+\n+static vn_nary_op_t\n+alloc_vn_nary_op (unsigned int length, tree result, unsigned int value_id)\n+{\n+  vn_nary_op_t vno1 = alloc_vn_nary_op_noinit (length,\n+\t\t\t\t\t       &current_info->nary_obstack);\n+\n+  vno1->value_id = value_id;\n+  vno1->length = length;\n+  vno1->result = result;\n+\n+  return vno1;\n+}\n+\n+/* Insert VNO into TABLE.  If COMPUTE_HASH is true, then compute\n+   VNO->HASHCODE first.  */\n+\n+static vn_nary_op_t\n+vn_nary_op_insert_into (vn_nary_op_t vno, htab_t table, bool compute_hash)\n+{\n+  void **slot;\n+\n+  if (compute_hash)\n+    vno->hashcode = vn_nary_op_compute_hash (vno);\n+\n+  slot = htab_find_slot_with_hash (table, vno, vno->hashcode, INSERT);\n+  gcc_assert (!*slot);\n+\n+  *slot = vno;\n+  return vno;\n }\n \n /* Insert a n-ary operation into the current hash table using it's\n@@ -1813,33 +1877,11 @@ vn_nary_op_insert_pieces (unsigned int length, enum tree_code code,\n \t\t\t  tree result,\n \t\t\t  unsigned int value_id)\n {\n-  void **slot;\n   vn_nary_op_t vno1;\n \n-  vno1 = (vn_nary_op_t) obstack_alloc (&current_info->nary_obstack,\n-\t\t\t\t       (sizeof (struct vn_nary_op_s)\n-\t\t\t\t\t- sizeof (tree) * (4 - length)));\n-  vno1->value_id = value_id;\n-  vno1->opcode = code;\n-  vno1->length = length;\n-  vno1->type = type;\n-  if (length >= 1)\n-    vno1->op[0] = op0;\n-  if (length >= 2)\n-    vno1->op[1] = op1;\n-  if (length >= 3)\n-    vno1->op[2] = op2;\n-  if (length >= 4)\n-    vno1->op[3] = op3;\n-  vno1->result = result;\n-  vno1->hashcode = vn_nary_op_compute_hash (vno1);\n-  slot = htab_find_slot_with_hash (current_info->nary, vno1, vno1->hashcode,\n-\t\t\t\t   INSERT);\n-  gcc_assert (!*slot);\n-\n-  *slot = vno1;\n-  return vno1;\n-\n+  vno1 = alloc_vn_nary_op (length, result, value_id);\n+  init_vn_nary_op_from_pieces (vno1, length, code, type, op0, op1, op2, op3);\n+  return vn_nary_op_insert_into (vno1, current_info->nary, true);\n }\n \n /* Insert OP into the current hash table with a value number of\n@@ -1850,27 +1892,11 @@ vn_nary_op_t\n vn_nary_op_insert (tree op, tree result)\n {\n   unsigned length = TREE_CODE_LENGTH (TREE_CODE (op));\n-  void **slot;\n   vn_nary_op_t vno1;\n-  unsigned i;\n \n-  vno1 = (vn_nary_op_t) obstack_alloc (&current_info->nary_obstack,\n-\t\t\t(sizeof (struct vn_nary_op_s)\n-\t\t\t - sizeof (tree) * (4 - length)));\n-  vno1->value_id = VN_INFO (result)->value_id;\n-  vno1->opcode = TREE_CODE (op);\n-  vno1->length = length;\n-  vno1->type = TREE_TYPE (op);\n-  for (i = 0; i < vno1->length; ++i)\n-    vno1->op[i] = TREE_OPERAND (op, i);\n-  vno1->result = result;\n-  vno1->hashcode = vn_nary_op_compute_hash (vno1);\n-  slot = htab_find_slot_with_hash (current_info->nary, vno1, vno1->hashcode,\n-\t\t\t\t   INSERT);\n-  gcc_assert (!*slot);\n-\n-  *slot = vno1;\n-  return vno1;\n+  vno1 = alloc_vn_nary_op (length, result, VN_INFO (result)->value_id);\n+  init_vn_nary_op_from_op (vno1, op);\n+  return vn_nary_op_insert_into (vno1, current_info->nary, true);\n }\n \n /* Insert the rhs of STMT into the current hash table with a value number of\n@@ -1880,31 +1906,11 @@ vn_nary_op_t\n vn_nary_op_insert_stmt (gimple stmt, tree result)\n {\n   unsigned length = gimple_num_ops (stmt) - 1;\n-  void **slot;\n   vn_nary_op_t vno1;\n-  unsigned i;\n-\n-  vno1 = (vn_nary_op_t) obstack_alloc (&current_info->nary_obstack,\n-\t\t\t\t       (sizeof (struct vn_nary_op_s)\n-\t\t\t\t\t- sizeof (tree) * (4 - length)));\n-  vno1->value_id = VN_INFO (result)->value_id;\n-  vno1->opcode = gimple_assign_rhs_code (stmt);\n-  vno1->length = length;\n-  vno1->type = gimple_expr_type (stmt);\n-  for (i = 0; i < vno1->length; ++i)\n-    vno1->op[i] = gimple_op (stmt, i + 1);\n-  if (vno1->opcode == REALPART_EXPR\n-      || vno1->opcode == IMAGPART_EXPR\n-      || vno1->opcode == VIEW_CONVERT_EXPR)\n-    vno1->op[0] = TREE_OPERAND (vno1->op[0], 0);\n-  vno1->result = result;\n-  vno1->hashcode = vn_nary_op_compute_hash (vno1);\n-  slot = htab_find_slot_with_hash (current_info->nary, vno1, vno1->hashcode,\n-\t\t\t\t   INSERT);\n-  gcc_assert (!*slot);\n \n-  *slot = vno1;\n-  return vno1;\n+  vno1 = alloc_vn_nary_op (length, result, VN_INFO (result)->value_id);\n+  init_vn_nary_op_from_stmt (vno1, stmt);\n+  return vn_nary_op_insert_into (vno1, current_info->nary, true);\n }\n \n /* Compute a hashcode for PHI operation VP1 and return it.  */\n@@ -3043,14 +3049,11 @@ sort_scc (VEC (tree, heap) *scc)\n static void\n copy_nary (vn_nary_op_t onary, vn_tables_t info)\n {\n-  size_t size = (sizeof (struct vn_nary_op_s)\n-\t\t - sizeof (tree) * (4 - onary->length));\n-  vn_nary_op_t nary = (vn_nary_op_t) obstack_alloc (&info->nary_obstack, size);\n-  void **slot;\n+  size_t size = sizeof_vn_nary_op (onary->length);\n+  vn_nary_op_t nary = alloc_vn_nary_op_noinit (onary->length,\n+\t\t\t\t\t       &info->nary_obstack);\n   memcpy (nary, onary, size);\n-  slot = htab_find_slot_with_hash (info->nary, nary, nary->hashcode, INSERT);\n-  gcc_assert (!*slot);\n-  *slot = nary;\n+  vn_nary_op_insert_into (nary, info->nary, false);\n }\n \n /* Insert the no longer used phi OPHI to the hash INFO.  */\n@@ -3414,6 +3417,20 @@ free_scc_vn (void)\n   XDELETE (optimistic_info);\n }\n \n+/* Set *ID if we computed something useful in RESULT.  */\n+\n+static void\n+set_value_id_for_result (tree result, unsigned int *id)\n+{\n+  if (result)\n+    {\n+      if (TREE_CODE (result) == SSA_NAME)\n+\t*id = VN_INFO (result)->value_id;\n+      else if (is_gimple_min_invariant (result))\n+\t*id = get_or_alloc_constant_value_id (result);\n+    }\n+}\n+\n /* Set the value ids in the valid hash tables.  */\n \n static void\n@@ -3429,39 +3446,15 @@ set_hashtable_value_ids (void)\n \n   FOR_EACH_HTAB_ELEMENT (valid_info->nary,\n \t\t\t vno, vn_nary_op_t, hi)\n-    {\n-      if (vno->result)\n-\t{\n-\t  if (TREE_CODE (vno->result) == SSA_NAME)\n-\t    vno->value_id = VN_INFO (vno->result)->value_id;\n-\t  else if (is_gimple_min_invariant (vno->result))\n-\t    vno->value_id = get_or_alloc_constant_value_id (vno->result);\n-\t}\n-    }\n+    set_value_id_for_result (vno->result, &vno->value_id);\n \n   FOR_EACH_HTAB_ELEMENT (valid_info->phis,\n \t\t\t vp, vn_phi_t, hi)\n-    {\n-      if (vp->result)\n-\t{\n-\t  if (TREE_CODE (vp->result) == SSA_NAME)\n-\t    vp->value_id = VN_INFO (vp->result)->value_id;\n-\t  else if (is_gimple_min_invariant (vp->result))\n-\t    vp->value_id = get_or_alloc_constant_value_id (vp->result);\n-\t}\n-    }\n+    set_value_id_for_result (vp->result, &vp->value_id);\n \n   FOR_EACH_HTAB_ELEMENT (valid_info->references,\n \t\t\t vr, vn_reference_t, hi)\n-    {\n-      if (vr->result)\n-\t{\n-\t  if (TREE_CODE (vr->result) == SSA_NAME)\n-\t    vr->value_id = VN_INFO (vr->result)->value_id;\n-\t  else if (is_gimple_min_invariant (vr->result))\n-\t    vr->value_id = get_or_alloc_constant_value_id (vr->result);\n-\t}\n-    }\n+    set_value_id_for_result (vr->result, &vr->value_id);\n }\n \n /* Do SCCVN.  Returns true if it finished, false if we bailed out"}]}