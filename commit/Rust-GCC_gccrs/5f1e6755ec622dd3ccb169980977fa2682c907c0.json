{"sha": "5f1e6755ec622dd3ccb169980977fa2682c907c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYxZTY3NTVlYzYyMmRkM2NjYjE2OTk4MDk3N2ZhMjY4MmM5MDdjMA==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1999-11-21T16:11:20Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1999-11-21T16:11:20Z"}, "message": "Rename -mshort-load-bytes switch to -malignment-traps\n\nFrom-SVN: r30604", "tree": {"sha": "690d15a05b02d82b1562e35855bc88fae3525071", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/690d15a05b02d82b1562e35855bc88fae3525071"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f1e6755ec622dd3ccb169980977fa2682c907c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f1e6755ec622dd3ccb169980977fa2682c907c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f1e6755ec622dd3ccb169980977fa2682c907c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f1e6755ec622dd3ccb169980977fa2682c907c0/comments", "author": null, "committer": null, "parents": [{"sha": "5b8ad699153c674ee3f25170c8fd3f3b6d315094", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b8ad699153c674ee3f25170c8fd3f3b6d315094", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b8ad699153c674ee3f25170c8fd3f3b6d315094"}], "stats": {"total": 135, "additions": 82, "deletions": 53}, "files": [{"sha": "7dd87b9140af3ad8291b0880a2024c0734023975", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f1e6755ec622dd3ccb169980977fa2682c907c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f1e6755ec622dd3ccb169980977fa2682c907c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f1e6755ec622dd3ccb169980977fa2682c907c0", "patch": "@@ -1,4 +1,17 @@\n-Fro Nov 19 05:48:45 CET 1999  Jan Hubicka  <hubicka@freesoft.cz>\n+1999-11-21  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* invoke.texi (ARM Options): Replace -mshort-load-bytes with\n+\t-malignment-traps. \n+\t(arm.h): Replace -mshort-load-bytes with -malignment-traps.\n+\t(arm.c): Replace TARGET_SHORT_BY_BYTES with TARGET_MMU_TRAPS.\n+\t(arm.md): Replace TARGET_SHORT_BY_BYTES with TARGET_MMU_TRAPS.\n+\n+Sun Nov 21 17:11:13 1999  Geoffrey Keating  <geoffk@cygnus.com>\n+\n+\t* varasm.c (output_constructor): Solve problem with long long\n+ \tbitfields, even on BYTES_BIG_ENDIAN machines (testcase 991118-1).\n+\n+Fri Nov 19 05:48:45 CET 1999  Jan Hubicka  <hubicka@freesoft.cz>\n \n \t* global.c (allocno): New structure and static variable.\n \t(allocno_reg): Remove, all references replaced by allocno.\n@@ -25,11 +38,6 @@ Fro Nov 19 05:48:45 CET 1999  Jan Hubicka  <hubicka@freesoft.cz>\n \tpass rtl_dump_file to regclass.\n \t* rtl.h (regclass): Update prototype.\n \n-Sun Nov 21 17:11:13 1999  Geoffrey Keating  <geoffk@cygnus.com>\n-\n-\t* varasm.c (output_constructor): Solve problem with long long\n- \tbitfields, even on BYTES_BIG_ENDIAN machines (testcase 991118-1).\n-\n Fri Nov 19 06:32:19 CET 1999  Jan Hubicka  <hubicka@freesoft.cz>\n \n \t* i386.md (neg, not and abs patterns): Revmap to use"}, {"sha": "fa844cf4d653213e31255a6642b04bb1ad36e53d", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f1e6755ec622dd3ccb169980977fa2682c907c0/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f1e6755ec622dd3ccb169980977fa2682c907c0/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=5f1e6755ec622dd3ccb169980977fa2682c907c0", "patch": "@@ -3483,7 +3483,7 @@ gen_rotated_half_load (memref)\n     }\n \n   /* If we aren't allowed to generate unaligned addresses, then fail.  */\n-  if (TARGET_SHORT_BY_BYTES\n+  if (TARGET_MMU_TRAPS\n       && ((BYTES_BIG_ENDIAN ? 1 : 0) ^ ((offset & 2) == 0)))\n     return NULL;\n "}, {"sha": "be0c7d13baf15b3e27930d2ce53c7028742ada8b", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f1e6755ec622dd3ccb169980977fa2682c907c0/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f1e6755ec622dd3ccb169980977fa2682c907c0/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=5f1e6755ec622dd3ccb169980977fa2682c907c0", "patch": "@@ -285,9 +285,9 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n    This is equivalent to -fpic.  */\n #define ARM_FLAG_APCS_REENT\t(1 << 6)\n \n-/* Nonzero if the MMU will trap unaligned word accesses, so shorts must be\n-   loaded byte-at-a-time.  */\n-#define ARM_FLAG_SHORT_BYTE\t(1 << 7)\n+/* Nonzero if the MMU will trap unaligned word accesses, so shorts must\n+   be loaded using either LDRH or LDRB instructions.  */\n+#define ARM_FLAG_MMU_TRAPS\t(1 << 7)\n \n /* Nonzero if all floating point instructions are missing (and there is no\n    emulator either).  Generate function calls for all ops in this case.  */\n@@ -323,14 +323,7 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n #define TARGET_APCS_STACK\t\t(target_flags & ARM_FLAG_APCS_STACK)\n #define TARGET_APCS_FLOAT\t\t(target_flags & ARM_FLAG_APCS_FLOAT)\n #define TARGET_APCS_REENT\t\t(target_flags & ARM_FLAG_APCS_REENT)\n-/* Note: TARGET_SHORT_BY_BYTES is really a misnomer.  What it means is\n-   that short values should not be accessed using word load instructions\n-   as there is a possibility that they may not be word aligned and this\n-   would generate an MMU fault.  On processors which do not have a 16 bit\n-   load instruction therefore, short values must be loaded by individual\n-   byte accesses rather than loading a word and then shifting the desired\n-   value into place.  */\n-#define TARGET_SHORT_BY_BYTES\t\t(target_flags & ARM_FLAG_SHORT_BYTE)\n+#define TARGET_MMU_TRAPS\t\t(target_flags & ARM_FLAG_MMU_TRAPS)\n #define TARGET_SOFT_FLOAT\t\t(target_flags & ARM_FLAG_SOFT_FLOAT)\n #define TARGET_HARD_FLOAT\t\t(! TARGET_SOFT_FLOAT)\n #define TARGET_BIG_END\t\t\t(target_flags & ARM_FLAG_BIG_END)\n@@ -369,12 +362,13 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n   {\"apcs-reentrant\",\t\tARM_FLAG_APCS_REENT,\t\t\\\n      \"Generate re-entrant, PIC code\" },\t\t\t\t\\\n   {\"no-apcs-reentrant\",\t       -ARM_FLAG_APCS_REENT, \"\" },\t\\\n-  {\"short-load-bytes\",\t\tARM_FLAG_SHORT_BYTE,\t\t\\\n-     \"Load shorts a byte at a time\" },\t\t\t\t\\\n-  {\"no-short-load-bytes\",      -ARM_FLAG_SHORT_BYTE, \"\" },\t\\\n-  {\"short-load-words\",\t       -ARM_FLAG_SHORT_BYTE,\t\t\\\n-     \"Load words a byte at a time\" },\t\t\t\t\\\n-  {\"no-short-load-words\",\tARM_FLAG_SHORT_BYTE, \"\" },\t\\\n+  {\"alignment-traps\",           ARM_FLAG_MMU_TRAPS,\t\t\\\n+     \"The MMU will trap on unaligned accesses\" },\\\n+  {\"no-alignment-traps\",       -ARM_FLAG_MMU_TRAPS, \"\" },\t\\\n+  {\"short-load-bytes\",\t\tARM_FLAG_MMU_TRAPS, \"\" },\t\\\n+  {\"no-short-load-bytes\",      -ARM_FLAG_MMU_TRAPS, \"\" },\t\\\n+  {\"short-load-words\",\t       -ARM_FLAG_MMU_TRAPS, \"\" },\t\\\n+  {\"no-short-load-words\",\tARM_FLAG_MMU_TRAPS, \"\" },\t\\\n   {\"soft-float\",\t\tARM_FLAG_SOFT_FLOAT,\t\t\\\n      \"Use library calls to perform FP operations\" },\t\t\\\n   {\"hard-float\",\t       -ARM_FLAG_SOFT_FLOAT,\t\t\\\n@@ -540,7 +534,7 @@ extern int arm_is_6_or_7;\n       if (MODE == QImode)\t\t\t\\\n \tUNSIGNEDP = 1;\t\t\t\t\\\n       else if (MODE == HImode)\t\t\t\\\n-\tUNSIGNEDP = TARGET_SHORT_BY_BYTES != 0;\t\\\n+\tUNSIGNEDP = TARGET_MMU_TRAPS != 0;\t\\\n       (MODE) = SImode;\t\t\t\t\\\n     }\n \n@@ -1002,7 +996,7 @@ enum reg_class\n \n /* If we need to load shorts byte-at-a-time, then we need a scratch. */\n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS,MODE,X)\t\t\\\n-  (((MODE) == HImode && ! arm_arch4 && TARGET_SHORT_BY_BYTES\t\\\n+  (((MODE) == HImode && ! arm_arch4 && TARGET_MMU_TRAPS\t\t\\\n     && (GET_CODE (X) == MEM\t\t\t\t\t\\\n \t|| ((GET_CODE (X) == REG || GET_CODE (X) == SUBREG)\t\\\n \t    && true_regnum (X) == -1)))\t\t\t\t\\"}, {"sha": "91795c2c4aa19f1a323993c62e4b8dfed50025cc", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f1e6755ec622dd3ccb169980977fa2682c907c0/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f1e6755ec622dd3ccb169980977fa2682c907c0/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=5f1e6755ec622dd3ccb169980977fa2682c907c0", "patch": "@@ -2441,15 +2441,15 @@\n {\n   if (arm_arch4 && GET_CODE (operands[1]) == MEM)\n     {\n-     /* Note: We do not have to worry about TARGET_SHORT_BY_BYTES\n+     /* Note: We do not have to worry about TARGET_MMU_TRAPS\n \there because the insn below will generate an LDRH instruction\n \trather than an LDR instruction, so we cannot get an unaligned\n \tword access.  */\n       emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n \t\t\t      gen_rtx_ZERO_EXTEND (SImode, operands[1])));\n       DONE;\n     }\n-  if (TARGET_SHORT_BY_BYTES && GET_CODE (operands[1]) == MEM)\n+  if (TARGET_MMU_TRAPS && GET_CODE (operands[1]) == MEM)\n     {\n       emit_insn (gen_movhi_bytes (operands[0], operands[1]));\n       DONE;\n@@ -2549,7 +2549,7 @@\n {\n   if (arm_arch4 && GET_CODE (operands[1]) == MEM)\n     {\n-     /* Note: We do not have to worry about TARGET_SHORT_BY_BYTES\n+     /* Note: We do not have to worry about TARGET_MMU_TRAPS\n \there because the insn below will generate an LDRH instruction\n \trather than an LDR instruction, so we cannot get an unaligned\n \tword access.  */\n@@ -2558,7 +2558,7 @@\n       DONE;\n     }\n \n-  if (TARGET_SHORT_BY_BYTES && GET_CODE (operands[1]) == MEM)\n+  if (TARGET_MMU_TRAPS && GET_CODE (operands[1]) == MEM)\n     {\n       emit_insn (gen_extendhisi2_mem (operands[0], operands[1]));\n       DONE;\n@@ -3184,13 +3184,13 @@\n \t}\n       else if (! arm_arch4)\n \t{\n-\t /* Note: We do not have to worry about TARGET_SHORT_BY_BYTES\n+\t /* Note: We do not have to worry about TARGET_MMU_TRAPS\n \t    for v4 and up architectures because LDRH instructions will\n \t    be used to access the HI values, and these cannot generate\n \t    unaligned word access faults in the MMU.  */\n \t  if (GET_CODE (operands[1]) == MEM)\n \t    {\n-\t      if (TARGET_SHORT_BY_BYTES)\n+\t      if (TARGET_MMU_TRAPS)\n \t\t{\n \t\t  rtx base;\n \t\t  rtx offset = const0_rtx;\n@@ -3289,7 +3289,7 @@\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(rotate:SI (match_operand:SI 1 \"offsettable_memory_operand\" \"o\")\n \t\t   (const_int 16)))]\n-  \"! TARGET_SHORT_BY_BYTES\"\n+  \"! TARGET_MMU_TRAPS\"\n   \"*\n {\n   rtx ops[2];\n@@ -3373,7 +3373,7 @@\n \t(match_operand:HI 1 \"general_operand\"  \"rI,K,m\"))]\n   \"! arm_arch4\n    && ! BYTES_BIG_ENDIAN\n-   && ! TARGET_SHORT_BY_BYTES\n+   && ! TARGET_MMU_TRAPS\n    && (GET_CODE (operands[1]) != CONST_INT\n        || const_ok_for_arm (INTVAL (operands[1]))\n        || const_ok_for_arm (~INTVAL (operands[1])))\"\n@@ -3389,7 +3389,7 @@\n \t(match_operand:HI 1 \"general_operand\"  \"rI,K,m\"))]\n   \"! arm_arch4\n    && BYTES_BIG_ENDIAN\n-   && ! TARGET_SHORT_BY_BYTES\n+   && ! TARGET_MMU_TRAPS\n    && (GET_CODE (operands[1]) != CONST_INT\n        || const_ok_for_arm (INTVAL (operands[1]))\n        || const_ok_for_arm (~INTVAL (operands[1])))\"\n@@ -3406,15 +3406,15 @@\n \t(rotate:SI (subreg:SI (match_operand:HI 1 \"memory_operand\" \"m\") 0)\n \t\t   (const_int 16)))]\n   \"BYTES_BIG_ENDIAN\n-   && ! TARGET_SHORT_BY_BYTES\"\n+   && ! TARGET_MMU_TRAPS\"\n   \"ldr%?\\\\t%0, %1\\\\t%@ movhi_bigend\"\n [(set_attr \"type\" \"load\")\n  (set_attr \"pool_range\" \"4096\")])\n \n (define_insn \"*movhi_bytes\"\n   [(set (match_operand:HI 0 \"s_register_operand\" \"=r,r\")\n \t(match_operand:HI 1 \"arm_rhs_operand\"  \"rI,K\"))]\n-  \"TARGET_SHORT_BY_BYTES\"\n+  \"TARGET_MMU_TRAPS\"\n   \"@\n    mov%?\\\\t%0, %1\\\\t%@ movhi\n    mvn%?\\\\t%0, #%B1\\\\t%@ movhi\")\n@@ -3436,7 +3436,7 @@\n   [(parallel [(match_operand:HI 0 \"s_register_operand\" \"=r\")\n \t      (match_operand:HI 1 \"reload_memory_operand\" \"o\")\n \t      (match_operand:DI 2 \"s_register_operand\" \"=&r\")])]\n-  \"TARGET_SHORT_BY_BYTES\"\n+  \"TARGET_MMU_TRAPS\"\n   \"\n   arm_reload_in_hi (operands);\n   DONE;\n@@ -5932,7 +5932,7 @@\n    (set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n   \"(! BYTES_BIG_ENDIAN)\n-   && ! TARGET_SHORT_BY_BYTES\n+   && ! TARGET_MMU_TRAPS\n    && REGNO (operands[0]) != FRAME_POINTER_REGNUM\n    && REGNO (operands[1]) != FRAME_POINTER_REGNUM\n    && (GET_CODE (operands[2]) != REG\n@@ -5947,7 +5947,7 @@\n    (set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(minus:SI (match_dup 1) (match_dup 2)))]\n   \"(!BYTES_BIG_ENDIAN)\n-   && ! TARGET_SHORT_BY_BYTES\n+   && ! TARGET_MMU_TRAPS\n    && REGNO (operands[0]) != FRAME_POINTER_REGNUM\n    && REGNO (operands[1]) != FRAME_POINTER_REGNUM\n    && (GET_CODE (operands[2]) != REG\n@@ -6085,7 +6085,7 @@\n \t(plus:SI (match_op_dup 2 [(match_dup 3)\t(match_dup 4)])\n \t\t (match_dup 1)))]\n   \"(! BYTES_BIG_ENDIAN)\n-   && ! TARGET_SHORT_BY_BYTES\n+   && ! TARGET_MMU_TRAPS\n    && REGNO (operands[0]) != FRAME_POINTER_REGNUM\n    && REGNO (operands[1]) != FRAME_POINTER_REGNUM\n    && REGNO (operands[3]) != FRAME_POINTER_REGNUM\"\n@@ -6102,7 +6102,7 @@\n \t(minus:SI (match_dup 1) (match_op_dup 2 [(match_dup 3)\n \t\t\t\t\t\t (match_dup 4)])))]\n   \"(! BYTES_BIG_ENDIAN)\n-   && ! TARGET_SHORT_BY_BYTES\n+   && ! TARGET_MMU_TRAPS\n    && REGNO (operands[0]) != FRAME_POINTER_REGNUM\n    && REGNO (operands[1]) != FRAME_POINTER_REGNUM\n    && REGNO (operands[3]) != FRAME_POINTER_REGNUM\"\n@@ -6149,7 +6149,7 @@\n    (set (match_dup 1)\n \t(plus:SI (match_dup 1) (match_operand:SI 2 \"index_operand\" \"rJ\")))]\n   \"(! BYTES_BIG_ENDIAN)\n-   && ! TARGET_SHORT_BY_BYTES\n+   && ! TARGET_MMU_TRAPS\n    && REGNO(operands[0]) != REGNO(operands[1])\n    && (GET_CODE (operands[2]) != REG\n        || REGNO(operands[0]) != REGNO (operands[2]))\""}, {"sha": "c87a82bd9f5368b3bfc468d72074252205ac8886", "filename": "gcc/invoke.texi", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f1e6755ec622dd3ccb169980977fa2682c907c0/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f1e6755ec622dd3ccb169980977fa2682c907c0/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=5f1e6755ec622dd3ccb169980977fa2682c907c0", "patch": "@@ -261,7 +261,7 @@ in the following sections.\n -mapcs-reentrant -mno-apcs-reentrant\n -msched-prolog -mno-sched-prolog\n -mlittle-endian -mbig-endian -mwords-little-endian\n--mshort-load-bytes -mno-short-load-bytes -mshort-load-words -mno-short-load-words\n+-malignment-traps\n -msoft-float -mhard-float -mfpe\n -mthumb-interwork -mno-thumb-interwork\n -mcpu= -march= -mfpe= \n@@ -4372,26 +4372,53 @@ option should only be used if you require compatibility with code for\n big-endian ARM processors generated by versions of the compiler prior to\n 2.8.\n \n+@item -malignment-traps\n+@kindex -malignment-traps\n+Generate code that will not trap if the MMU has alignment traps enabled.\n+On ARM architectures prior to ARMv4, there were no instructions to\n+access half-word objects stored in memory.  However, when reading from\n+memory a feature of the ARM architecture allows a word load to be used,\n+even if the address is unaligned, and the processor core will rotate the\n+data as it is being loaded.  This option tells the compiler that such\n+misaligned accesses will cause a MMU trap and that it should instead\n+synthesise the access as a series of byte accesses.  The compiler can\n+still use word accesses to load half-word data if it knows that the\n+address is aligned to a word boundary.\n+\n+This option is ignored when compiling for ARM architecture 4 or later,\n+since these processors have instructions to directly access half-word\n+objects in memory. \n+        \n+@item -mno-alignment-traps\n+@kindex -mno-alignment-traps\n+Generate code that assumes that the MMU will not trap unaligned\n+accesses.  This produces better code when the target instruction set\n+does not have half-word memory operations (implementations prior to\n+ARMv4). \n+\n+Note that you cannot use this option to access unaligned word objects,\n+since the processor will only fetch one 32-bit aligned object from\n+memory. \n+\n+The default setting for most targets is -mno-alignment-traps, since\n+this produces better code when there are no half-word memory\n+instructions available. \n+\n @item -mshort-load-bytes\n @kindex -mshort-load-bytes\n-Do not try to load half-words (eg @samp{short}s) by loading a word from\n-an unaligned address.  For some targets the MMU is configured to trap\n-unaligned loads; use this option to generate code that is safe in these\n-environments.\n+This is a depreciated alias for @samp{-malignment-traps}.\n \n @item -mno-short-load-bytes\n @kindex -mno-short-load-bytes\n-Use unaligned word loads to load half-words (eg @samp{short}s).  This\n-option produces more efficient code, but the MMU is sometimes configured\n-to trap these instructions.\n+This is a depreciated alias for @samp{-mno-alignment-traps}.\n \n @item -mshort-load-words\n @kindex -mshort-load-words\n-This is a synonym for @samp{-mno-short-load-bytes}.\n+This is a depreciated alias for @samp{-mno-alignment-traps}.\n \n @item -mno-short-load-words\n @kindex -mno-short-load-words\n-This is a synonym for @samp{-mshort-load-bytes}.\n+This is a depreciated alias for @samp{-malignment-traps}.\n \n @item -mbsd\n @kindex -mbsd"}]}