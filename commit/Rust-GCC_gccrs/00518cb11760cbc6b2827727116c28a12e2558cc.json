{"sha": "00518cb11760cbc6b2827727116c28a12e2558cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA1MThjYjExNzYwY2JjNmIyODI3NzI3MTE2YzI4YTEyZTI1NThjYw==", "commit": {"author": {"name": "Devang Patel", "email": "dpatel@apple.com", "date": "2005-07-06T02:25:08Z"}, "committer": {"name": "Devang Patel", "email": "dpatel@gcc.gnu.org", "date": "2005-07-06T02:25:08Z"}, "message": "tree-vectorizer.h (struct _loop_vec_info): Remove loop_line_number.\n\n        * tree-vectorizer.h (struct _loop_vec_info): Remove loop_line_number.\n        (LOOP_VINFO_LOC, LOOP_LOC): Remove.\n        * tree-vectorizer.c (vect_loop_location): New.\n        (vect_print_dump_info): Use vect_loop_location.\n        (new_loop_vec_info): Do not set LOOP_VINFO_LOC.\n        (vectorize_loops): Set vect_loop_location.\n        * tree-vect-analyze.c (vect_analyze_offset_expr,\n        vect_determin_vectorization_factor, vect_analyze_operations,\n        vect_analyze_scalar_cycles, vect_analyze_data_ref_dependence,\n        vect_analyze_data_ref_dependences, vect_compute_data_ref_alignment,\n        vect_analyze_data_refs_alignment, vect_analyze_data_ref_access,\n        vect_analyze_data_ref_accesses, vect_analyze_pointer_ref_access,\n        vect_object_analysis, vect_analyze_data_refs, vect_mark_relevant,\n        vect_stmt_relevant_p, vect_mark_stmts_to_be_vectorized,\n        vect_can_advance_ivs_p, vect_get_loop_niters, vect_analyze_loop_form,\n        vect_analyze_loop): Adjust vect_print_dump_info API.\n        * tree-vect-transform.c (vect_create_addr_base_for_vector_ref,\n        vect_create_data_ref_ptr, vect_init_vector, vect_get_vec_def_for_operand,\n        vect_finish_stmt_generation, vectorizable_assignment,\n        vectorizable_operation, vectorizable_store, vectorizable_load,\n        vectorizable_live_operation, vectorizable_condition, vect_transform_stmt,\n        vect_update_ivs_after_vectorizer, vect_do_peeling_for_loop_bound,\n        vect_gen_ninters_for_prolog_loop, vect_do_peeling_for_alignment,\n        vect_transform_loop): Same.\n        * tree-vectorizer.c (get_vectype_for_scalar_type, vect_is_simple_use,\n        vect_is_simple_reduction, vect_is_simple_iv_evolution, vectorize_loops):\n        Same.\n\nFrom-SVN: r101649", "tree": {"sha": "874a2a62d26727eb826bc1a7e13e221fb23d3a00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/874a2a62d26727eb826bc1a7e13e221fb23d3a00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00518cb11760cbc6b2827727116c28a12e2558cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00518cb11760cbc6b2827727116c28a12e2558cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00518cb11760cbc6b2827727116c28a12e2558cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00518cb11760cbc6b2827727116c28a12e2558cc/comments", "author": null, "committer": null, "parents": [{"sha": "51076f9604483f4f1b4dc16a90871384c1fd15cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51076f9604483f4f1b4dc16a90871384c1fd15cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51076f9604483f4f1b4dc16a90871384c1fd15cc"}], "stats": {"total": 500, "additions": 246, "deletions": 254}, "files": [{"sha": "f78cfdb6707a88959da4bde5ced786887dc14975", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00518cb11760cbc6b2827727116c28a12e2558cc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00518cb11760cbc6b2827727116c28a12e2558cc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00518cb11760cbc6b2827727116c28a12e2558cc", "patch": "@@ -1,3 +1,33 @@\n+2005-07-05  Devang Patel  <dpatel@apple.com>\n+\n+\t* tree-vectorizer.h (struct _loop_vec_info): Remove loop_line_number.\n+\t(LOOP_VINFO_LOC, LOOP_LOC): Remove.\n+\t* tree-vectorizer.c (vect_loop_location): New.\n+\t(vect_print_dump_info): Use vect_loop_location.\n+\t(new_loop_vec_info): Do not set LOOP_VINFO_LOC.\n+\t(vectorize_loops): Set vect_loop_location.\n+\t* tree-vect-analyze.c (vect_analyze_offset_expr, \n+\tvect_determin_vectorization_factor, vect_analyze_operations,\n+\tvect_analyze_scalar_cycles, vect_analyze_data_ref_dependence,\n+\tvect_analyze_data_ref_dependences, vect_compute_data_ref_alignment,\n+\tvect_analyze_data_refs_alignment, vect_analyze_data_ref_access,\n+\tvect_analyze_data_ref_accesses, vect_analyze_pointer_ref_access,\n+\tvect_object_analysis, vect_analyze_data_refs, vect_mark_relevant,\n+\tvect_stmt_relevant_p, vect_mark_stmts_to_be_vectorized,\n+\tvect_can_advance_ivs_p, vect_get_loop_niters, vect_analyze_loop_form,\n+\tvect_analyze_loop): Adjust vect_print_dump_info API.\n+\t* tree-vect-transform.c (vect_create_addr_base_for_vector_ref,\n+\tvect_create_data_ref_ptr, vect_init_vector, vect_get_vec_def_for_operand,\n+\tvect_finish_stmt_generation, vectorizable_assignment, \n+\tvectorizable_operation, vectorizable_store, vectorizable_load, \n+\tvectorizable_live_operation, vectorizable_condition, vect_transform_stmt,\n+\tvect_update_ivs_after_vectorizer, vect_do_peeling_for_loop_bound,\n+\tvect_gen_ninters_for_prolog_loop, vect_do_peeling_for_alignment,\n+\tvect_transform_loop): Same.\n+\t* tree-vectorizer.c (get_vectype_for_scalar_type, vect_is_simple_use,\n+\tvect_is_simple_reduction, vect_is_simple_iv_evolution, vectorize_loops):\n+\tSame.\n+\n 2005-07-05  Randolph Chung  <tausq@debian.org>\n \n \t* configure.ac (hppa*-*-linux*: Check for a TLS capable gas."}, {"sha": "267a6ffdde515650be59c81b60b8c9034bec87c0", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 120, "deletions": 158, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00518cb11760cbc6b2827727116c28a12e2558cc/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00518cb11760cbc6b2827727116c28a12e2558cc/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=00518cb11760cbc6b2827727116c28a12e2558cc", "patch": "@@ -200,7 +200,7 @@ vect_analyze_offset_expr (tree expr,\n   if (!BINARY_CLASS_P (expr))\n     {\n       /* We expect to get binary expressions (PLUS/MINUS and MULT).  */\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         {\n \t  fprintf (vect_dump, \"Not binary expression \");\n           print_generic_expr (vect_dump, expr, TDF_SLIM);\n@@ -322,7 +322,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n   int i;\n   tree scalar_type;\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_determine_vectorization_factor ===\");\n \n   for (i = 0; i < nbbs; i++)\n@@ -336,7 +336,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n           stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n           tree vectype;\n \n-          if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+          if (vect_print_dump_info (REPORT_DETAILS))\n             {\n               fprintf (vect_dump, \"==> examining statement: \");\n               print_generic_expr (vect_dump, stmt, TDF_SLIM);\n@@ -347,15 +347,14 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n           if (!STMT_VINFO_RELEVANT_P (stmt_info)\n \t      && !STMT_VINFO_LIVE_P (stmt_info))\n             {\n-              if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+              if (vect_print_dump_info (REPORT_DETAILS))\n                 fprintf (vect_dump, \"skip.\");\n               continue;\n             }\n \n           if (VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (stmt))))\n             {\n-              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-                                        LOOP_LOC (loop_vinfo)))\n+              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n                 {\n                   fprintf (vect_dump, \"not vectorized: vector stmt in loop:\");\n                   print_generic_expr (vect_dump, stmt, TDF_SLIM);\n@@ -370,7 +369,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n           else\n             scalar_type = TREE_TYPE (stmt);\n \n-          if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+          if (vect_print_dump_info (REPORT_DETAILS))\n             {\n               fprintf (vect_dump, \"get vectype for scalar type:  \");\n               print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n@@ -379,23 +378,22 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n           vectype = get_vectype_for_scalar_type (scalar_type);\n           if (!vectype)\n             {\n-              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-                                        LOOP_LOC (loop_vinfo)))\n+              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n                 {\n                   fprintf (vect_dump, \"not vectorized: unsupported data-type \");\n                   print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n                 }\n               return false;\n             }\n-          if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+          if (vect_print_dump_info (REPORT_DETAILS))\n             {\n               fprintf (vect_dump, \"vectype: \");\n               print_generic_expr (vect_dump, vectype, TDF_SLIM);\n             }\n           STMT_VINFO_VECTYPE (stmt_info) = vectype;\n \n           nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-          if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+          if (vect_print_dump_info (REPORT_DETAILS))\n             fprintf (vect_dump, \"nunits = %d\", nunits);\n \n           if (vectorization_factor)\n@@ -404,8 +402,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n                  This restriction will be relaxed in the future.  */\n               if (nunits != vectorization_factor) \n                 {\n-                  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-                                            LOOP_LOC (loop_vinfo)))\n+                  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n                     fprintf (vect_dump, \"not vectorized: mixed data-types\");\n                   return false;\n                 }\n@@ -422,8 +419,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \n   if (vectorization_factor <= 1)\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-                                LOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n         fprintf (vect_dump, \"not vectorized: unsupported data-type\");\n       return false;\n     }\n@@ -451,7 +447,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n   stmt_vec_info stmt_info;\n   bool need_to_vectorize = false;\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_operations ===\");\n \n   gcc_assert (LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n@@ -464,7 +460,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n       for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n         {\n \t  stmt_info = vinfo_for_stmt (phi);\n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    {\n \t      fprintf (vect_dump, \"examining phi: \");\n \t      print_generic_expr (vect_dump, phi, TDF_SLIM);\n@@ -475,8 +471,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t  if (STMT_VINFO_LIVE_P (stmt_info))\n \t    {\n \t      /* FORNOW: not yet supported.  */\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\t\tLOOP_LOC (loop_vinfo)))\n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \t\tfprintf (vect_dump, \"not vectorized: value used after loop.\");\n \t    return false;\n \t  }\n@@ -485,8 +480,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t    {\n \t      /* Most likely a reduction-like computation that is used\n \t         in the loop.  */\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t                                LOOP_LOC (loop_vinfo)))\n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \t        fprintf (vect_dump, \"not vectorized: unsupported pattern.\");\n  \t     return false;\n \t    }\n@@ -497,7 +491,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t  tree stmt = bsi_stmt (si);\n \t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n \n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    {\n \t      fprintf (vect_dump, \"==> examining statement: \");\n \t      print_generic_expr (vect_dump, stmt, TDF_SLIM);\n@@ -515,7 +509,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t  if (!STMT_VINFO_RELEVANT_P (stmt_info)\n \t      && !STMT_VINFO_LIVE_P (stmt_info))\n \t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n \t        fprintf (vect_dump, \"irrelevant.\");\n \t      continue;\n \t    }\n@@ -533,8 +527,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \n \t      if (!ok)\n \t\t{\n-\t\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\t\t    LOOP_LOC (loop_vinfo)))\n+\t\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \t\t    {\n \t\t      fprintf (vect_dump, \n \t\t\t       \"not vectorized: relevant stmt not supported: \");\n@@ -556,8 +549,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \n \t      if (!ok)\n \t\t{\n-\t\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\t\t    LOOP_LOC (loop_vinfo)))\n+\t\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \t\t    {\n \t\t      fprintf (vect_dump, \n \t\t\t       \"not vectorized: live stmt not supported: \");\n@@ -578,48 +570,44 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n      touching this loop.  */\n   if (!need_to_vectorize)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \n \t\t \"All the computation can be taken out of the loop.\");\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-                                LOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n         fprintf (vect_dump, \n \t\t \"not vectorized: redundant loop. no profit to vectorize.\");\n       return false;\n     }\n \n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      && vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      && vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump,\n         \"vectorization_factor = %d, niters = \" HOST_WIDE_INT_PRINT_DEC,\n         vectorization_factor, LOOP_VINFO_INT_NITERS (loop_vinfo));\n \n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       && LOOP_VINFO_INT_NITERS (loop_vinfo) < vectorization_factor)\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-                                 LOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \tfprintf (vect_dump, \"not vectorized: iteration count too small.\");\n       return false;\n     }\n \n   if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       || LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"epilog loop required.\");\n       if (!vect_can_advance_ivs_p (loop_vinfo))\n         {\n-          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-                                     LOOP_LOC (loop_vinfo)))\n+          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n             fprintf (vect_dump,\n                      \"not vectorized: can't create epilog loop 1.\");\n           return false;\n         }\n       if (!slpeel_can_duplicate_loop_p (loop, loop->single_exit))\n         {\n-          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-                                     LOOP_LOC (loop_vinfo)))\n+          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n             fprintf (vect_dump,\n                      \"not vectorized: can't create epilog loop 2.\");\n           return false;\n@@ -722,7 +710,7 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n   basic_block bb = loop->header;\n   tree dummy;\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_scalar_cycles ===\");\n \n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n@@ -732,7 +720,7 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n       stmt_vec_info stmt_vinfo = vinfo_for_stmt (phi);\n       tree reduc_stmt;\n \n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \t{\n           fprintf (vect_dump, \"Analyze phi: \");\n           print_generic_expr (vect_dump, phi, TDF_SLIM);\n@@ -743,7 +731,7 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n \n       if (!is_gimple_reg (SSA_NAME_VAR (def)))\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"virtual phi. skip.\");\n \t  continue;\n \t}\n@@ -757,16 +745,15 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n       if (!access_fn)\n \tcontinue;\n \n-      if (vect_print_dump_info (REPORT_DETAILS,\n-\t\t\t\tLOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         {\n            fprintf (vect_dump, \"Access function of PHI: \");\n            print_generic_expr (vect_dump, access_fn, TDF_SLIM);\n         }\n \n       if (vect_is_simple_iv_evolution (loop->num, access_fn, &dummy, &dummy))\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS,LOOP_LOC (loop_vinfo)))\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"Detected induction.\");\n \t  STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_induction_def;\n           continue;\n@@ -777,14 +764,14 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n       reduc_stmt = vect_is_simple_reduction (loop, phi);\n       if (reduc_stmt)\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+          if (vect_print_dump_info (REPORT_DETAILS))\n             fprintf (vect_dump, \"Detected reduction.\");\n           STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_reduction_def;\n           STMT_VINFO_DEF_TYPE (vinfo_for_stmt (reduc_stmt)) =\n                                                         vect_reduction_def;\n         }\n       else\n-        if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+        if (vect_print_dump_info (REPORT_DETAILS))\n           fprintf (vect_dump, \"Unknown def-use cycle pattern.\");\n \n     }\n@@ -869,8 +856,7 @@ vect_analyze_data_ref_dependence (struct data_reference *dra,\n   \n   if (!vect_base_addr_differ_p (dra, drb, &differ_p))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\tLOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n         {\n           fprintf (vect_dump,\n                 \"not vectorized: can't determine dependence between: \");\n@@ -892,8 +878,7 @@ vect_analyze_data_ref_dependence (struct data_reference *dra,\n \n   if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-                                LOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n         {\n           fprintf (vect_dump, \n                    \"not vectorized: can't determine dependence between \"); \n@@ -922,8 +907,7 @@ vect_analyze_data_ref_dependence (struct data_reference *dra,\n \n   if (!DDR_DIST_VECT (ddr))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\tLOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \t{\n \t  fprintf (vect_dump, \"not vectorized: bad dist vector for \");\n \t  print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n@@ -941,7 +925,7 @@ vect_analyze_data_ref_dependence (struct data_reference *dra,\n       /* Two references with distance zero have the same alignment.  */\n       VEC_safe_push (dr_p, heap, STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_a), drb);\n       VEC_safe_push (dr_p, heap, STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_b), dra);\n-      if (vect_print_dump_info (REPORT_ALIGNMENT, LOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_ALIGNMENT))\n \tfprintf (vect_dump, \"accesses have the same alignment.\");\n       return false;\n     }\n@@ -951,8 +935,7 @@ vect_analyze_data_ref_dependence (struct data_reference *dra,\n        is concerned, in this case.  */\n     return false;\n     \n-  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t    LOOP_LOC (loop_vinfo)))\n+  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n     {\n       fprintf (vect_dump,\n \t\"not vectorized: possible dependence between data-refs \");\n@@ -979,10 +962,10 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo)\n \n   /* Examine store-store (output) dependences.  */\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_dependences ===\");\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"compare all store-store pairs.\");\n \n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_refs); i++)\n@@ -1000,7 +983,7 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo)\n \n   /* Examine load-store (true/anti) dependences.  */\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"compare all load-store pairs.\");\n \n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_read_refs); i++)\n@@ -1042,7 +1025,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   bool base_aligned_p;\n   tree misalign;\n    \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"vect_compute_data_ref_alignment:\");\n \n   /* Initialize misalignment to unknown.  */\n@@ -1055,7 +1038,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \n   if (!misalign)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC)) \n+      if (vect_print_dump_info (REPORT_DETAILS))\n \t{\n \t  fprintf (vect_dump, \"Unknown alignment for access: \");\n \t  print_generic_expr (vect_dump, base, TDF_SLIM);\n@@ -1067,7 +1050,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n     {\n       if (!vect_can_force_dr_alignment_p (base, TYPE_ALIGN (vectype)))\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    {\n \t      fprintf (vect_dump, \"can't force alignment of ref: \");\n \t      print_generic_expr (vect_dump, ref, TDF_SLIM);\n@@ -1078,7 +1061,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n       /* Force the alignment of the decl.\n \t NOTE: This is the only change to the code we make during\n \t the analysis phase, before deciding to vectorize the loop.  */\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"force alignment\");\n       DECL_ALIGN (base) = TYPE_ALIGN (vectype);\n       DECL_USER_ALIGN (base) = 1;\n@@ -1097,14 +1080,14 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   if (tree_int_cst_sgn (misalign) < 0)\n     {\n       /* Negative misalignment value.  */\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"unexpected misalign value\");\n       return false;\n     }\n \n   DR_MISALIGNMENT (dr) = tree_low_cst (misalign, 1);\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"misalign = %d bytes\", DR_MISALIGNMENT (dr));\n \n   return true;\n@@ -1356,7 +1339,7 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n   enum dr_alignment_support supportable_dr_alignment;\n   unsigned int i;\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_data_refs_alignment ===\");\n \n \n@@ -1365,8 +1348,7 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n \n   if (!vect_compute_data_refs_alignment (loop_vinfo))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\tLOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \tfprintf (vect_dump, \n \t\t \"not vectorized: can't calculate alignment for data ref.\");\n       return false;\n@@ -1388,13 +1370,12 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n       supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n       if (!supportable_dr_alignment)\n \t{\n-\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\t    LOOP_LOC (loop_vinfo)))\n+\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \t    fprintf (vect_dump, \"not vectorized: unsupported unaligned load.\");\n \t  return false;\n \t}\n       if (supportable_dr_alignment != dr_aligned \n-\t  && (vect_print_dump_info (REPORT_ALIGNMENT, LOOP_LOC (loop_vinfo))))\n+\t  && (vect_print_dump_info (REPORT_ALIGNMENT)))\n \tfprintf (vect_dump, \"Vectorizing an unaligned access.\");\n     }\n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n@@ -1403,17 +1384,16 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n       supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n       if (!supportable_dr_alignment)\n \t{\n-\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\t    LOOP_LOC (loop_vinfo)))\n+\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \t    fprintf (vect_dump, \"not vectorized: unsupported unaligned store.\");\n \t  return false;\n \t}\n       if (supportable_dr_alignment != dr_aligned \n-\t  && (vect_print_dump_info (REPORT_ALIGNMENT, LOOP_LOC (loop_vinfo))))\n+\t  && (vect_print_dump_info (REPORT_ALIGNMENT)))\n \tfprintf (vect_dump, \"Vectorizing an unaligned access.\");\n     }\n   if (LOOP_VINFO_UNALIGNED_DR (loop_vinfo)\n-      && vect_print_dump_info (REPORT_ALIGNMENT, LOOP_LOC (loop_vinfo)))\n+      && vect_print_dump_info (REPORT_ALIGNMENT))\n     fprintf (vect_dump, \"Alignment of access forced using peeling.\");\n \n   return true;\n@@ -1435,7 +1415,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n \n   if (!step || tree_int_cst_compare (step, TYPE_SIZE_UNIT (scalar_type)))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"not consecutive access\");\n       return false;\n     }\n@@ -1459,7 +1439,7 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo)\n   varray_type loop_write_datarefs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n   varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_data_ref_accesses ===\");\n \n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n@@ -1468,8 +1448,7 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo)\n       bool ok = vect_analyze_data_ref_access (dr);\n       if (!ok)\n \t{\n-\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-                                      LOOP_LOC (loop_vinfo)))\n+\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \t    fprintf (vect_dump, \"not vectorized: complicated access pattern.\");\n \t  return false;\n \t}\n@@ -1481,8 +1460,7 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo)\n       bool ok = vect_analyze_data_ref_access (dr);\n       if (!ok)\n \t{\n-\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\t    LOOP_LOC (loop_vinfo)))\n+\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \t    fprintf (vect_dump, \"not vectorized: complicated access pattern.\");\n \t  return false;\n \t}\n@@ -1521,8 +1499,7 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read,\n \n   if (!vect_is_simple_iv_evolution (loopnum, access_fn, &init, &step))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS, \n-\t\t\t\tLOOP_LOC (loop_vinfo))) \n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \tfprintf (vect_dump, \"not vectorized: pointer access is not simple.\");\t\n       return NULL;\n     }\n@@ -1531,17 +1508,15 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read,\n \n   if (!expr_invariant_in_loop_p (loop, init))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\tLOOP_LOC (loop_vinfo))) \n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \tfprintf (vect_dump, \n \t\t \"not vectorized: initial condition is not loop invariant.\");\t\n       return NULL;\n     }\n \n   if (TREE_CODE (step) != INTEGER_CST)\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\tLOOP_LOC (loop_vinfo))) \n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \tfprintf (vect_dump, \n \t\t\"not vectorized: non constant step for pointer access.\");\t\n       return NULL;\n@@ -1550,16 +1525,14 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read,\n   reftype = TREE_TYPE (TREE_OPERAND (memref, 0));\n   if (!POINTER_TYPE_P (reftype)) \n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\tLOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \tfprintf (vect_dump, \"not vectorized: unexpected pointer access form.\");\t\n       return NULL;\n     }\n \n   if (!POINTER_TYPE_P (TREE_TYPE (init))) \n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\tLOOP_LOC (loop_vinfo))) \n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \tfprintf (vect_dump, \"not vectorized: unexpected pointer access form.\");\n       return NULL;\n     }\n@@ -1568,25 +1541,23 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read,\n   innertype = TREE_TYPE (reftype);\n   if (!COMPLETE_TYPE_P (innertype))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-                              LOOP_LOC (loop_vinfo)))\n-      fprintf (vect_dump, \"not vectorized: pointer to incomplete type.\");\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+\tfprintf (vect_dump, \"not vectorized: pointer to incomplete type.\");\n       return NULL;\n     }\n    \n   /* Check that STEP is a multiple of type size.  */\n   if (!integer_zerop (size_binop (TRUNC_MOD_EXPR, *ptr_step, \n  \t\t        fold_convert (ssizetype, TYPE_SIZE_UNIT (innertype)))))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\tLOOP_LOC (loop_vinfo))) \n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \tfprintf (vect_dump, \"not vectorized: non consecutive access.\");\t\n       return NULL;\n     }\n    \n   indx_access_fn = \n \tbuild_polynomial_chrec (loopnum, integer_zero_node, integer_one_node);\n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       fprintf (vect_dump, \"Access function of ptr indx: \");\n       print_generic_expr (vect_dump, indx_access_fn, TDF_SLIM);\n@@ -1810,7 +1781,7 @@ vect_object_analysis (tree memref, tree stmt, bool is_read,\n \t  && !vect_analyze_offset_expr (poffset, loop, TYPE_SIZE_UNIT (vectype), \n \t\t\t\t&object_offset, &object_misalign, &object_step))\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    {\n \t      fprintf (vect_dump, \"failed to compute offset or step for \");\n \t      print_generic_expr (vect_dump, memref, TDF_SLIM);\n@@ -1824,7 +1795,7 @@ vect_object_analysis (tree memref, tree stmt, bool is_read,\n       /* Check that there is no remainder in bits.  */\n       if (pbitpos%BITS_PER_UNIT)\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"bit offset alignment.\");\n \t  return NULL_TREE;\n \t}\n@@ -1852,7 +1823,7 @@ vect_object_analysis (tree memref, tree stmt, bool is_read,\n       /* We expect to get a decl only if we already have a DR.  */\n       if (!(*dr))\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    {\n \t      fprintf (vect_dump, \"unhandled decl \");\n \t      print_generic_expr (vect_dump, memref, TDF_SLIM);\n@@ -1889,12 +1860,11 @@ vect_object_analysis (tree memref, tree stmt, bool is_read,\n       access_fn = analyze_scalar_evolution (loop, ptr_ref);\n       if (!access_fn)\n \t{\n-\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\t    LOOP_LOC (loop_vinfo)))\n+\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \t    fprintf (vect_dump, \"not vectorized: complicated pointer access.\");\t\n \t  return NULL_TREE;\n \t}\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \t{\n \t  fprintf (vect_dump, \"Access function of ptr: \");\n \t  print_generic_expr (vect_dump, access_fn, TDF_SLIM);\n@@ -1916,8 +1886,7 @@ vect_object_analysis (tree memref, tree stmt, bool is_read,\n \t{\n \t  if (!(*dr))\n \t    {\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\t\tLOOP_LOC (loop_vinfo))) \n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \t\tfprintf (vect_dump, \"not vectorized: ptr is loop invariant.\");\t\n \t      return NULL_TREE;\n \t    }\n@@ -1951,8 +1920,7 @@ vect_object_analysis (tree memref, tree stmt, bool is_read,\n \t  *memtag = TREE_OPERAND (base_address, 0);\n \t  break;\n \tdefault:\n-\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\t    LOOP_LOC (loop_vinfo)))\n+\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \t    {\n \t      fprintf (vect_dump, \"not vectorized: no memtag ref: \"); \n \t      print_generic_expr (vect_dump, memref, TDF_SLIM);\n@@ -1978,7 +1946,7 @@ vect_object_analysis (tree memref, tree stmt, bool is_read,\n   *step = size_binop (PLUS_EXPR, object_step, address_step); \n   *base_aligned = object_base_aligned && address_base_aligned;\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       fprintf (vect_dump, \"Results of object analysis for: \");\n       print_generic_expr (vect_dump, memref, TDF_SLIM);\n@@ -2030,7 +1998,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n   int j;\n   struct data_reference *dr;\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_data_refs ===\");\n \n   for (j = 0; j < nbbs; j++)\n@@ -2061,7 +2029,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \n \t  if (!no_vuse && !no_vmaymust)\n \t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n \t\t{\n \t\t  fprintf (vect_dump, \"unexpected vdefs and vuses in stmt: \");\n \t\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n@@ -2071,7 +2039,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \n \t  if (TREE_CODE (stmt) != MODIFY_EXPR)\n \t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n \t\t{\n \t\t  fprintf (vect_dump, \"unexpected vops in stmt: \");\n \t\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n@@ -2096,7 +2064,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t  vectype = get_vectype_for_scalar_type (scalar_type);\n \t  if (!vectype)\n \t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n \t\t{\n \t\t  fprintf (vect_dump, \"no vectype for stmt: \");\n \t\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n@@ -2115,8 +2083,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t\t\t\t       &subvars);\n \t  if (!base)\n \t    {\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\t\tLOOP_LOC (loop_vinfo)))\n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \t\t{\n \t\t  fprintf (vect_dump, \"not vectorized: unhandled data ref: \"); \n \t\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n@@ -2155,7 +2122,7 @@ vect_mark_relevant (VEC(tree,heap) **worklist, tree stmt,\n   bool save_relevant_p = STMT_VINFO_RELEVANT_P (stmt_info);\n   bool save_live_p = STMT_VINFO_LIVE_P (stmt_info);\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"mark relevant %d, live %d.\",relevant_p, live_p);\n \n   STMT_VINFO_LIVE_P (stmt_info) |= live_p;\n@@ -2169,7 +2136,7 @@ vect_mark_relevant (VEC(tree,heap) **worklist, tree stmt,\n   if (STMT_VINFO_RELEVANT_P (stmt_info) == save_relevant_p\n       && STMT_VINFO_LIVE_P (stmt_info) == save_live_p)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"already marked relevant/live.\");\n       return;\n     }\n@@ -2211,7 +2178,7 @@ vect_stmt_relevant_p (tree stmt, loop_vec_info loop_vinfo,\n   if (TREE_CODE (stmt) != PHI_NODE)\n     if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_DEFS))\n       {\n-\tif (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\tif (vect_print_dump_info (REPORT_DETAILS))\n \t  fprintf (vect_dump, \"vec_stmt_relevant_p: stmt has vdefs.\");\n \t*relevant_p = true;\n       }\n@@ -2224,7 +2191,7 @@ vect_stmt_relevant_p (tree stmt, loop_vec_info loop_vinfo,\n \t  basic_block bb = bb_for_stmt (USE_STMT (use_p));\n \t  if (!flow_bb_inside_loop_p (loop, bb))\n \t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n \t\tfprintf (vect_dump, \"vec_stmt_relevant_p: used out of loop.\");\n \n \t      /* We expect all such uses to be in the loop exit phis\n@@ -2276,7 +2243,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n   tree def, def_stmt;\n   enum vect_def_type dt;\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_mark_stmts_to_be_vectorized ===\");\n \n   worklist = VEC_alloc (tree, heap, 64);\n@@ -2286,7 +2253,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n   bb = loop->header;\n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         {\n           fprintf (vect_dump, \"init: phi relevant? \");\n           print_generic_expr (vect_dump, phi, TDF_SLIM);\n@@ -2303,7 +2270,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t{\n \t  stmt = bsi_stmt (si);\n \n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    {\n \t      fprintf (vect_dump, \"init: stmt relevant? \");\n \t      print_generic_expr (vect_dump, stmt, TDF_SLIM);\n@@ -2321,7 +2288,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n     {\n       stmt = VEC_pop (tree, worklist);\n \n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \t{\n           fprintf (vect_dump, \"worklist: examine stmt: \");\n           print_generic_expr (vect_dump, stmt, TDF_SLIM);\n@@ -2393,8 +2360,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \n \t  if (!vect_is_simple_use (use, loop_vinfo, &def_stmt, &def, &dt))\n             {\n-              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t    \t\tLOOP_LOC (loop_vinfo)))\n+              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n                 fprintf (vect_dump, \"not vectorized: unsupported use in stmt.\");\n \t      VEC_free (tree, heap, worklist);\n               return false;\n@@ -2403,7 +2369,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t  if (!def_stmt || IS_EMPTY_STMT (def_stmt))\n \t    continue;\n \n-          if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+          if (vect_print_dump_info (REPORT_DETAILS))\n             {\n               fprintf (vect_dump, \"worklist: examine use %d: \", i);\n               print_generic_expr (vect_dump, use, TDF_SLIM);\n@@ -2446,15 +2412,15 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n \n   /* Analyze phi functions of the loop header.  */\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_can_advance_ivs_p ===\");\n \n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n     {\n       tree access_fn = NULL;\n       tree evolution_part;\n \n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \t{\n           fprintf (vect_dump, \"Analyze phi: \");\n           print_generic_expr (vect_dump, phi, TDF_SLIM);\n@@ -2465,7 +2431,7 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n \n       if (!is_gimple_reg (SSA_NAME_VAR (PHI_RESULT (phi))))\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"virtual phi. skip.\");\n \t  continue;\n \t}\n@@ -2474,7 +2440,7 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n \n       if (STMT_VINFO_DEF_TYPE (vinfo_for_stmt (phi)) == vect_reduction_def)\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+          if (vect_print_dump_info (REPORT_DETAILS))\n             fprintf (vect_dump, \"reduc phi. skip.\");\n           continue;\n         }\n@@ -2486,12 +2452,12 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n \n       if (!access_fn)\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"No Access function.\");\n \t  return false;\n \t}\n \n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         {\n \t  fprintf (vect_dump, \"Access function of PHI: \");\n \t  print_generic_expr (vect_dump, access_fn, TDF_SLIM);\n@@ -2501,7 +2467,7 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n       \n       if (evolution_part == NULL_TREE)\n         {\n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"No evolution.\");\n \t  return false;\n         }\n@@ -2529,7 +2495,7 @@ vect_get_loop_niters (struct loop *loop, tree *number_of_iterations)\n {\n   tree niters;\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== get_loop_niters ===\");\n \n   niters = number_of_iterations_in_loop (loop);\n@@ -2539,7 +2505,7 @@ vect_get_loop_niters (struct loop *loop, tree *number_of_iterations)\n     {\n       *number_of_iterations = niters;\n \n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \t{\n \t  fprintf (vect_dump, \"==> get_loop_niters:\" );\n \t  print_generic_expr (vect_dump, *number_of_iterations, TDF_SLIM);\n@@ -2566,16 +2532,13 @@ vect_analyze_loop_form (struct loop *loop)\n   loop_vec_info loop_vinfo;\n   tree loop_cond;\n   tree number_of_iterations = NULL;\n-  LOC loop_loc;\n \n-  loop_loc = find_loop_location (loop);\n-\n-  if (vect_print_dump_info (REPORT_DETAILS, loop_loc))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_loop_form ===\");\n \n   if (loop->inner)\n     {\n-      if (vect_print_dump_info (REPORT_OUTER_LOOPS, loop_loc))\n+      if (vect_print_dump_info (REPORT_OUTER_LOOPS))\n         fprintf (vect_dump, \"not vectorized: nested loop.\");\n       return NULL;\n     }\n@@ -2584,7 +2547,7 @@ vect_analyze_loop_form (struct loop *loop)\n       || loop->num_nodes != 2\n       || EDGE_COUNT (loop->header->preds) != 2)\n     {\n-      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS, loop_loc))\n+      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n         {\n           if (!loop->single_exit)\n             fprintf (vect_dump, \"not vectorized: multiple exits.\");\n@@ -2603,7 +2566,7 @@ vect_analyze_loop_form (struct loop *loop)\n      executable statements, and the latch is empty.  */\n   if (!empty_block_p (loop->latch))\n     {\n-      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS, loop_loc))\n+      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n         fprintf (vect_dump, \"not vectorized: unexpected loop form.\");\n       return NULL;\n     }\n@@ -2615,43 +2578,43 @@ vect_analyze_loop_form (struct loop *loop)\n       if (!(e->flags & EDGE_ABNORMAL))\n \t{\n \t  split_loop_exit_edge (e);\n-\t  if (vect_print_dump_info (REPORT_DETAILS, loop_loc))\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"split exit edge.\");\n \t}\n       else\n \t{\n-\t  if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS, loop_loc))\n+\t  if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n \t    fprintf (vect_dump, \"not vectorized: abnormal loop exit edge.\");\n \t  return NULL;\n \t}\n     }\n \n   if (empty_block_p (loop->header))\n     {\n-      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS, loop_loc))\n+      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n         fprintf (vect_dump, \"not vectorized: empty loop.\");\n       return NULL;\n     }\n \n   loop_cond = vect_get_loop_niters (loop, &number_of_iterations);\n   if (!loop_cond)\n     {\n-      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS, loop_loc))\n+      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n \tfprintf (vect_dump, \"not vectorized: complicated exit condition.\");\n       return NULL;\n     }\n   \n   if (!number_of_iterations) \n     {\n-      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS, loop_loc))\n+      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n \tfprintf (vect_dump, \n \t\t \"not vectorized: number of iterations cannot be computed.\");\n       return NULL;\n     }\n \n   if (chrec_contains_undetermined (number_of_iterations))\n     {\n-      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS, loop_loc))\n+      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n         fprintf (vect_dump, \"Infinite number of iterations.\");\n       return false;\n     }\n@@ -2661,7 +2624,7 @@ vect_analyze_loop_form (struct loop *loop)\n \n   if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, loop_loc))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         {\n           fprintf (vect_dump, \"Symbolic number of iterations is \");\n           print_generic_expr (vect_dump, number_of_iterations, TDF_DETAILS);\n@@ -2670,13 +2633,12 @@ vect_analyze_loop_form (struct loop *loop)\n   else\n   if (LOOP_VINFO_INT_NITERS (loop_vinfo) == 0)\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS, loop_loc))\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n         fprintf (vect_dump, \"not vectorized: number of iterations = 0.\");\n       return NULL;\n     }\n \n   LOOP_VINFO_EXIT_COND (loop_vinfo) = loop_cond;\n-  LOOP_VINFO_LOC (loop_vinfo) = loop_loc;\n \n   return loop_vinfo;\n }\n@@ -2693,15 +2655,15 @@ vect_analyze_loop (struct loop *loop)\n   bool ok;\n   loop_vec_info loop_vinfo;\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"===== analyze_loop_nest =====\");\n \n   /* Check the CFG characteristics of the loop (nesting, entry/exit, etc.  */\n \n   loop_vinfo = vect_analyze_loop_form (loop);\n   if (!loop_vinfo)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"bad loop form.\");\n       return NULL;\n     }\n@@ -2715,7 +2677,7 @@ vect_analyze_loop (struct loop *loop)\n   ok = vect_analyze_data_refs (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"bad data references.\");\n       destroy_loop_vec_info (loop_vinfo);\n       return NULL;\n@@ -2731,7 +2693,7 @@ vect_analyze_loop (struct loop *loop)\n   ok = vect_mark_stmts_to_be_vectorized (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"unexpected pattern.\");\n       destroy_loop_vec_info (loop_vinfo);\n       return NULL;\n@@ -2740,7 +2702,7 @@ vect_analyze_loop (struct loop *loop)\n   ok = vect_determine_vectorization_factor (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"can't determine vectorization factor.\");\n       destroy_loop_vec_info (loop_vinfo);\n       return NULL;\n@@ -2752,7 +2714,7 @@ vect_analyze_loop (struct loop *loop)\n   ok = vect_analyze_data_ref_dependences (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"bad data dependence.\");\n       destroy_loop_vec_info (loop_vinfo);\n       return NULL;\n@@ -2764,7 +2726,7 @@ vect_analyze_loop (struct loop *loop)\n   ok = vect_analyze_data_ref_accesses (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"bad data access.\");\n       destroy_loop_vec_info (loop_vinfo);\n       return NULL;\n@@ -2776,7 +2738,7 @@ vect_analyze_loop (struct loop *loop)\n   ok = vect_analyze_data_refs_alignment (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"bad data alignment.\");\n       destroy_loop_vec_info (loop_vinfo);\n       return NULL;\n@@ -2788,7 +2750,7 @@ vect_analyze_loop (struct loop *loop)\n   ok = vect_analyze_operations (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"bad operation or unsupported loop bound.\");\n       destroy_loop_vec_info (loop_vinfo);\n       return NULL;"}, {"sha": "4d1a3e0c11eea9fade97d51080f49ac0c19dbf21", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00518cb11760cbc6b2827727116c28a12e2558cc/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00518cb11760cbc6b2827727116c28a12e2558cc/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=00518cb11760cbc6b2827727116c28a12e2558cc", "patch": "@@ -232,7 +232,7 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n   TREE_OPERAND (vec_stmt, 0) = new_temp;\n   append_to_statement_list_force (vec_stmt, new_stmt_list);\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       fprintf (vect_dump, \"created \");\n       print_generic_expr (vect_dump, vec_stmt, TDF_SLIM);\n@@ -332,7 +332,7 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   base_name =  build_fold_indirect_ref (unshare_expr (\n \t\t      STMT_VINFO_VECT_DR_BASE_ADDRESS (stmt_info)));\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       tree data_ref_base = base_name;\n       fprintf (vect_dump, \"create array_ref of type: \");\n@@ -497,7 +497,7 @@ vect_init_vector (tree stmt, tree vector_var)\n   new_bb = bsi_insert_on_edge_immediate (pe, init_stmt);\n   gcc_assert (!new_bb);\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       fprintf (vect_dump, \"created new init_stmt: \");\n       print_generic_expr (vect_dump, init_stmt, TDF_SLIM);\n@@ -539,15 +539,15 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n   enum vect_def_type dt;\n   bool is_simple_use;\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       fprintf (vect_dump, \"vect_get_vec_def_for_operand: \");\n       print_generic_expr (vect_dump, op, TDF_SLIM);\n     }\n \n   is_simple_use = vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt);\n   gcc_assert (is_simple_use);\n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       if (def)\n         {\n@@ -570,7 +570,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n \t  *scalar_def = op;\n \n         /* Create 'vect_cst_ = {cst,cst,...,cst}'  */\n-        if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        if (vect_print_dump_info (REPORT_DETAILS))\n           fprintf (vect_dump, \"Create vector_cst. nunits = %d\", nunits);\n \n         for (i = nunits - 1; i >= 0; --i)\n@@ -588,7 +588,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n \t  *scalar_def = def;\n \n         /* Create 'vec_inv = {inv,inv,..,inv}'  */\n-        if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        if (vect_print_dump_info (REPORT_DETAILS))\n           fprintf (vect_dump, \"Create vector_inv.\");\n \n         for (i = nunits - 1; i >= 0; --i)\n@@ -627,7 +627,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n     /* Case 5: operand is defined by loop-header phi - induction.  */\n     case vect_induction_def:\n       {\n-        if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        if (vect_print_dump_info (REPORT_DETAILS))\n           fprintf (vect_dump, \"induction - unsupported.\");\n         internal_error (\"no support for induction\"); /* FORNOW */\n       }\n@@ -647,7 +647,7 @@ vect_finish_stmt_generation (tree stmt, tree vec_stmt, block_stmt_iterator *bsi)\n {\n   bsi_insert_before (bsi, vec_stmt, BSI_SAME_STMT);\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       fprintf (vect_dump, \"add new stmt: \");\n       print_generic_expr (vect_dump, vec_stmt, TDF_SLIM);\n@@ -877,7 +877,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n   /* 1.2 set the loop-latch arg for the reduction-phi:  */\n   add_phi_arg (reduction_phi, vect_def, loop_latch_edge (loop));\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       fprintf (vect_dump, \"transform reduction: created def-use cycle:\");\n       print_generic_expr (vect_dump, reduction_phi, TDF_SLIM);\n@@ -909,7 +909,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n       /*** Case 1:  Create:\n \t   v_out2 = reduc_expr <v_out1>  */\n \n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"Reduce using direct vector reduction.\");\n \n       vec_dest = vect_create_destination_var (scalar_dest, vectype);\n@@ -965,7 +965,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n \t          Create:  va = vop <va, va'>\n \t        }  */\n \n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"Reduce using vector shifts\");\n \n \t  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n@@ -982,7 +982,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n \t      new_name = make_ssa_name (vec_dest, epilog_stmt);\n \t      TREE_OPERAND (epilog_stmt, 0) = new_name;\n \t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n-\t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n \t\tprint_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n \n \n@@ -991,7 +991,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n \t      new_temp = make_ssa_name (vec_dest, epilog_stmt);\n \t      TREE_OPERAND (epilog_stmt, 0) = new_temp;\n \t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n-\t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n \t\tprint_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n \t    }\n \n@@ -1008,7 +1008,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n \t         Create:  s = op <s, s'>\n \t       }  */\n \n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"Reduce using scalar code. \");\n \n \t  vec_temp = PHI_RESULT (new_phi);\n@@ -1026,7 +1026,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n               new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n               TREE_OPERAND (epilog_stmt, 0) = new_temp;\n               bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n-              if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+              if (vect_print_dump_info (REPORT_DETAILS))\n                 print_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n \t      \n \t      bit_offset = element_bitsize;\n@@ -1049,7 +1049,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n \t      new_name = make_ssa_name (new_scalar_dest, epilog_stmt);\n \t      TREE_OPERAND (epilog_stmt, 0) = new_name;\n \t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n-\t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n \t\tprint_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n \n \n@@ -1058,7 +1058,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n \t      new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n \t      TREE_OPERAND (epilog_stmt, 0) = new_temp;\n \t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n-\t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n \t\tprint_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n \t    }\n \n@@ -1073,7 +1073,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n   \n   if (extract_scalar_result)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"extract scalar result\");\n \n       /* The result is in the low order bits.  */\n@@ -1090,7 +1090,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n       new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n       TREE_OPERAND (epilog_stmt, 0) = new_temp; \n       bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tprint_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n     }\n \n@@ -1110,7 +1110,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n       TREE_OPERAND (epilog_stmt, 0) = new_temp;\n       bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n \n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         print_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n     }\n \n@@ -1218,20 +1218,20 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   optab = optab_for_tree_code (code, vectype);\n   if (!optab)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"no optab.\");\n       return false;\n     }\n   vec_mode = TYPE_MODE (vectype);\n   if (optab->handlers[(int) vec_mode].insn_code == CODE_FOR_nothing)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"op not supported by target.\");\n       if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n           || LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n \t     < vect_min_worthwhile_factor (code))\n         return false;\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"proceeding using word mode.\");\n     }\n \n@@ -1240,7 +1240,7 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       && LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n \t < vect_min_worthwhile_factor (code))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"not worthwhile without SIMD support.\");\n       return false;\n     }\n@@ -1251,13 +1251,13 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   reduc_optab = optab_for_tree_code (reduc_code, vectype);\n   if (!reduc_optab)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"no optab for reduction.\");\n       reduc_code = NUM_TREE_CODES;\n     }\n   if (reduc_optab->handlers[(int) vec_mode].insn_code == CODE_FOR_nothing)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"reduc op not supported by target.\");\n       reduc_code = NUM_TREE_CODES;\n     }\n@@ -1270,7 +1270,7 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   /** Transform.  **/\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"transform reduction.\");\n \n   /* Create the destination vector  */\n@@ -1338,7 +1338,7 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   op = TREE_OPERAND (stmt, 1);\n   if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"use not simple.\");\n       return false;\n     }\n@@ -1350,7 +1350,7 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     }\n \n   /** Transform.  **/\n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"transform assignment.\");\n \n   /* Handle def.  */\n@@ -1434,7 +1434,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (STMT_VINFO_LIVE_P (stmt_info))\n     {\n       /* FORNOW: not yet supported.  */\n-      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"value used after loop.\");\n       return false;\n     }\n@@ -1453,7 +1453,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   op_type = TREE_CODE_LENGTH (code);\n   if (op_type != unary_op && op_type != binary_op)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"num. args = %d (not unary/binary op).\", op_type);\n       return false;\n     }\n@@ -1463,7 +1463,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       op = TREE_OPERAND (operation, i);\n       if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt))\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"use not simple.\");\n \t  return false;\n \t}\t\n@@ -1472,20 +1472,20 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   /* Supportable by target?  */\n   if (!optab)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"no optab.\");\n       return false;\n     }\n   vec_mode = TYPE_MODE (vectype);\n   if (optab->handlers[(int) vec_mode].insn_code == CODE_FOR_nothing)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"op not supported by target.\");\n       if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n           || LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n \t     < vect_min_worthwhile_factor (code))\n         return false;\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"proceeding using word mode.\");\n     }\n \n@@ -1494,7 +1494,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       && LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n \t < vect_min_worthwhile_factor (code))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"not worthwhile without SIMD support.\");\n       return false;\n     }\n@@ -1507,7 +1507,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   /** Transform.  **/\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"transform binary/unary operation.\");\n \n   /* Handle def.  */\n@@ -1579,7 +1579,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   op = TREE_OPERAND (stmt, 1);\n   if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"use not simple.\");\n       return false;\n     }\n@@ -1602,7 +1602,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   /** Transform.  **/\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"transform store\");\n \n   alignment_support_cheme = vect_supportable_dr_alignment (dr);\n@@ -1680,7 +1680,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (STMT_VINFO_LIVE_P (stmt_info))\n     {\n       /* FORNOW: not yet supported.  */\n-      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"value used after loop.\");\n       return false;\n     }\n@@ -1705,7 +1705,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     (e.g. - data copies).  */\n   if (mov_optab->handlers[mode].insn_code == CODE_FOR_nothing)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"Aligned load, but unsupported type.\");\n       return false;\n     }\n@@ -1718,7 +1718,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   /** Transform.  **/\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"transform load.\");\n \n   alignment_support_cheme = vect_supportable_dr_alignment (dr);\n@@ -1907,7 +1907,7 @@ vectorizable_live_operation (tree stmt,\n       op = TREE_OPERAND (operation, i);\n       if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt))\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+          if (vect_print_dump_info (REPORT_DETAILS))\n             fprintf (vect_dump, \"use not simple.\");\n           return false;\n         }\n@@ -1998,7 +1998,7 @@ vectorizable_condition (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (STMT_VINFO_LIVE_P (stmt_info))\n     {\n       /* FORNOW: not yet supported.  */\n-      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"value used after loop.\");\n       return false;\n     }\n@@ -2120,7 +2120,7 @@ vect_transform_stmt (tree stmt, block_stmt_iterator *bsi)\n \tbreak;\n \n       default:\n-\tif (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\tif (vect_print_dump_info (REPORT_DETAILS))\n \t  fprintf (vect_dump, \"stmt not supported.\");\n \tgcc_unreachable ();\n       }\n@@ -2388,7 +2388,7 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n       tree var, stmt, ni, ni_name;\n       block_stmt_iterator last_bsi;\n \n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         {\n           fprintf (vect_dump, \"vect_update_ivs_after_vectorizer: phi: \");\n           print_generic_expr (vect_dump, phi, TDF_SLIM);\n@@ -2397,15 +2397,15 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n       /* Skip virtual phi's.  */\n       if (!is_gimple_reg (SSA_NAME_VAR (PHI_RESULT (phi))))\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"virtual phi. skip.\");\n \t  continue;\n \t}\n \n       /* Skip reduction phis.  */\n       if (STMT_VINFO_DEF_TYPE (vinfo_for_stmt (phi)) == vect_reduction_def)\n         { \n-          if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+          if (vect_print_dump_info (REPORT_DETAILS))\n             fprintf (vect_dump, \"reduc phi. skip.\");\n           continue;\n         } \n@@ -2465,7 +2465,7 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n   basic_block preheader;\n   int loop_num;\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_do_peeling_for_loop_bound ===\");\n \n   initialize_original_copy_tables ();\n@@ -2555,7 +2555,7 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n       int element_size = vectype_align/vf;\n       int elem_misalign = byte_misalign / element_size;\n \n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"known alignment = %d.\", byte_misalign);\n       iters = build_int_cst (niters_type, (vf - elem_misalign)&(vf-1));\n     }\n@@ -2598,7 +2598,7 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n   if (TREE_CODE (loop_niters) != INTEGER_CST)\n     iters = build2 (MIN_EXPR, niters_type, iters, loop_niters);\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       fprintf (vect_dump, \"niters for prolog loop: \");\n       print_generic_expr (vect_dump, iters, TDF_SLIM);\n@@ -2687,7 +2687,7 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, struct loops *loops)\n   tree n_iters;\n   struct loop *new_loop;\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_do_peeling_for_alignment ===\");\n \n   initialize_original_copy_tables ();\n@@ -2737,7 +2737,7 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n   tree ratio = NULL;\n   int vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vec_transform_loop ===\");\n \n   /* Peel the loop if there are data refs with unknown alignment.\n@@ -2785,7 +2785,7 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n \t  stmt_vec_info stmt_info;\n \t  bool is_store;\n \n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    {\n \t      fprintf (vect_dump, \"------>vectorizing statement: \");\n \t      print_generic_expr (vect_dump, stmt, TDF_SLIM);\n@@ -2805,7 +2805,7 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n \t\t == (unsigned HOST_WIDE_INT) vectorization_factor);\n \n \t  /* -------- vectorize statement ------------ */\n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"transform statement.\");\n \n \t  is_store = vect_transform_stmt (stmt, &si);\n@@ -2830,6 +2830,6 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n      until all the loops have been transformed?  */\n   update_ssa (TODO_update_ssa);\n \n-  if (vect_print_dump_info (REPORT_VECTORIZED_LOOPS, LOOP_LOC (loop_vinfo)))\n+  if (vect_print_dump_info (REPORT_VECTORIZED_LOOPS))\n     fprintf (vect_dump, \"LOOP VECTORIZED.\");\n }"}, {"sha": "ae389c6ce8c8d9a510739f0748ee0fa7e6afb674", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00518cb11760cbc6b2827727116c28a12e2558cc/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00518cb11760cbc6b2827727116c28a12e2558cc/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=00518cb11760cbc6b2827727116c28a12e2558cc", "patch": "@@ -176,6 +176,9 @@ enum verbosity_levels vect_verbosity_level = MAX_VERBOSITY_LEVEL;\n \n /* Number of loops, at the beginning of vectorization.  */\n unsigned int vect_loops_num;\n+\n+/* Loop location.  */\n+static LOC vect_loop_location;\n \f\n /*************************************************************************\n   Simple Loop Peeling Utilities\n@@ -1299,17 +1302,18 @@ vect_set_dump_settings (void)\n    For vectorization debug dumps.  */\n \n bool\n-vect_print_dump_info (enum verbosity_levels vl, LOC loc)\n+vect_print_dump_info (enum verbosity_levels vl)\n {\n   if (vl > vect_verbosity_level)\n     return false;\n \n-  if (loc == UNKNOWN_LOC)\n+  if (vect_loop_location == UNKNOWN_LOC)\n     fprintf (vect_dump, \"\\n%s:%d: note: \",\n \t\t DECL_SOURCE_FILE (current_function_decl),\n \t\t DECL_SOURCE_LINE (current_function_decl));\n   else\n-    fprintf (vect_dump, \"\\n%s:%d: note: \", LOC_FILE (loc), LOC_LINE (loc));\n+    fprintf (vect_dump, \"\\n%s:%d: note: \", \n+\t     LOC_FILE (vect_loop_location), LOC_LINE (vect_loop_location));\n \n \n   return true;\n@@ -1407,7 +1411,6 @@ new_loop_vec_info (struct loop *loop)\n   VARRAY_GENERIC_PTR_INIT (LOOP_VINFO_DATAREF_READS (res), 20,\n \t\t\t   \"loop_read_datarefs\");\n   LOOP_VINFO_UNALIGNED_DR (res) = NULL;\n-  LOOP_VINFO_LOC (res) = UNKNOWN_LOC;\n \n   return res;\n }\n@@ -1549,7 +1552,7 @@ get_vectype_for_scalar_type (tree scalar_type)\n   nunits = UNITS_PER_SIMD_WORD / nbytes;\n \n   vectype = build_vector_type (scalar_type, nunits);\n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       fprintf (vect_dump, \"get vectype with %d units of type \", nunits);\n       print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n@@ -1558,7 +1561,7 @@ get_vectype_for_scalar_type (tree scalar_type)\n   if (!vectype)\n     return NULL_TREE;\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       fprintf (vect_dump, \"vectype: \");\n       print_generic_expr (vect_dump, vectype, TDF_SLIM);\n@@ -1567,7 +1570,7 @@ get_vectype_for_scalar_type (tree scalar_type)\n   if (!VECTOR_MODE_P (TYPE_MODE (vectype))\n       && !INTEGRAL_MODE_P (TYPE_MODE (vectype)))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"mode not supported by target.\");\n       return NULL_TREE;\n     }\n@@ -1633,7 +1636,7 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def_stmt,\n   *def_stmt = NULL_TREE;\n   *def = NULL_TREE;\n   \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       fprintf (vect_dump, \"vect_is_simple_use: operand \");\n       print_generic_expr (vect_dump, operand, TDF_SLIM);\n@@ -1647,20 +1650,20 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def_stmt,\n     \n   if (TREE_CODE (operand) != SSA_NAME)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"not ssa-name.\");\n       return false;\n     }\n     \n   *def_stmt = SSA_NAME_DEF_STMT (operand);\n   if (*def_stmt == NULL_TREE )\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"no def_stmt.\");\n       return false;\n     }\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       fprintf (vect_dump, \"def_stmt: \");\n       print_generic_expr (vect_dump, *def_stmt, TDF_SLIM);\n@@ -1678,7 +1681,7 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def_stmt,\n           return true;\n         }\n \n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"Unexpected empty stmt.\");\n       return false;\n     }\n@@ -1694,7 +1697,7 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def_stmt,\n \n   if (*dt == vect_unknown_def_type)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"Unsupported pattern.\");\n       return false;\n     }\n@@ -1703,12 +1706,12 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def_stmt,\n      a reduction operation cannot have uses in the loop.  */\n   if (*dt == vect_reduction_def && TREE_CODE (*def_stmt) != PHI_NODE)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"reduction used in loop.\");\n       return false;\n     }\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"type of def: %d.\",*dt);\n \n   switch (TREE_CODE (*def_stmt))\n@@ -1725,14 +1728,14 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def_stmt,\n       break;\n \n     default:\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"unsupported defining stmt: \");\n       return false;\n     }\n \n   if (*dt == vect_induction_def)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"induction not supported.\");\n       return false;\n     }\n@@ -1810,7 +1813,7 @@ vect_is_simple_reduction (struct loop *loop ATTRIBUTE_UNUSED,\n \n   if (TREE_CODE (loop_arg) != SSA_NAME)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         {\n           fprintf (vect_dump, \"reduction: not ssa_name: \");\n           print_generic_expr (vect_dump, loop_arg, TDF_SLIM);\n@@ -1821,14 +1824,14 @@ vect_is_simple_reduction (struct loop *loop ATTRIBUTE_UNUSED,\n   def_stmt = SSA_NAME_DEF_STMT (loop_arg);\n   if (!def_stmt)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"reduction: no def_stmt.\");\n       return NULL_TREE;\n     }\n \n   if (TREE_CODE (def_stmt) != MODIFY_EXPR)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         {\n           print_generic_expr (vect_dump, def_stmt, TDF_SLIM);\n         }\n@@ -1839,7 +1842,7 @@ vect_is_simple_reduction (struct loop *loop ATTRIBUTE_UNUSED,\n   code = TREE_CODE (operation);\n   if (!commutative_tree_code (code) || !associative_tree_code (code))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         {\n           fprintf (vect_dump, \"reduction: not commutative/associative: \");\n           print_generic_expr (vect_dump, operation, TDF_SLIM);\n@@ -1850,7 +1853,7 @@ vect_is_simple_reduction (struct loop *loop ATTRIBUTE_UNUSED,\n   op_type = TREE_CODE_LENGTH (code);\n   if (op_type != binary_op)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         {\n           fprintf (vect_dump, \"reduction: not binary operation: \");\n           print_generic_expr (vect_dump, operation, TDF_SLIM);\n@@ -1862,7 +1865,7 @@ vect_is_simple_reduction (struct loop *loop ATTRIBUTE_UNUSED,\n   op2 = TREE_OPERAND (operation, 1);\n   if (TREE_CODE (op1) != SSA_NAME || TREE_CODE (op2) != SSA_NAME)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         {\n           fprintf (vect_dump, \"reduction: uses not ssa_names: \");\n           print_generic_expr (vect_dump, operation, TDF_SLIM);\n@@ -1875,7 +1878,7 @@ vect_is_simple_reduction (struct loop *loop ATTRIBUTE_UNUSED,\n   if (TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (TREE_TYPE (op1))\n       || TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (TREE_TYPE (op2)))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         {\n           fprintf (vect_dump, \"reduction: multiple types: operation type: \");\n           print_generic_expr (vect_dump, type, TDF_SLIM);\n@@ -1891,7 +1894,7 @@ vect_is_simple_reduction (struct loop *loop ATTRIBUTE_UNUSED,\n   if (SCALAR_FLOAT_TYPE_P (type) && !flag_unsafe_math_optimizations)\n     {\n       /* Changing the order of operations changes the sematics.  */\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         {\n           fprintf (vect_dump, \"reduction: unsafe fp math optimization: \");\n           print_generic_expr (vect_dump, operation, TDF_SLIM);\n@@ -1901,7 +1904,7 @@ vect_is_simple_reduction (struct loop *loop ATTRIBUTE_UNUSED,\n   else if (INTEGRAL_TYPE_P (type) && !TYPE_UNSIGNED (type) && flag_trapv)\n     {\n       /* Changing the order of operations changes the sematics.  */\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         {\n           fprintf (vect_dump, \"reduction: unsafe int math optimization: \");\n           print_generic_expr (vect_dump, operation, TDF_SLIM);\n@@ -1917,7 +1920,7 @@ vect_is_simple_reduction (struct loop *loop ATTRIBUTE_UNUSED,\n   def2 = SSA_NAME_DEF_STMT (op2);\n   if (!def1 || !def2)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         {\n           fprintf (vect_dump, \"reduction: no defs for operands: \");\n           print_generic_expr (vect_dump, operation, TDF_SLIM);\n@@ -1929,7 +1932,7 @@ vect_is_simple_reduction (struct loop *loop ATTRIBUTE_UNUSED,\n       && flow_bb_inside_loop_p (loop, bb_for_stmt (def1))\n       && def2 == phi)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         {\n           fprintf (vect_dump, \"detected reduction:\");\n           print_generic_expr (vect_dump, operation, TDF_SLIM);\n@@ -1946,7 +1949,7 @@ vect_is_simple_reduction (struct loop *loop ATTRIBUTE_UNUSED,\n       /* Swap operands (just for simplicity - so that the rest of the code\n \t can assume that the reduction variable is always the last (second)\n \t argument).  */\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         {\n           fprintf (vect_dump, \"detected reduction: need to swap operands:\");\n           print_generic_expr (vect_dump, operation, TDF_SLIM);\n@@ -1965,7 +1968,7 @@ vect_is_simple_reduction (struct loop *loop ATTRIBUTE_UNUSED,\n     }\n   else\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         {\n           fprintf (vect_dump, \"reduction: unknown pattern.\");\n           print_generic_expr (vect_dump, operation, TDF_SLIM);\n@@ -2003,7 +2006,7 @@ vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init,\n   init_expr = unshare_expr (initial_condition_in_loop_num (access_fn,\n                                                            loop_nb));\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       fprintf (vect_dump, \"step: \");\n       print_generic_expr (vect_dump, step_expr, TDF_SLIM);\n@@ -2016,7 +2019,7 @@ vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init,\n \n   if (TREE_CODE (step_expr) != INTEGER_CST)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"step unknown.\");\n       return false;\n     }\n@@ -2052,6 +2055,7 @@ vectorize_loops (struct loops *loops)\n       if (!loop)\n         continue;\n \n+      vect_loop_location = find_loop_location (loop);\n       loop_vinfo = vect_analyze_loop (loop);\n       loop->aux = loop_vinfo;\n \n@@ -2062,7 +2066,7 @@ vectorize_loops (struct loops *loops)\n       num_vectorized_loops++;\n     }\n \n-  if (vect_print_dump_info (REPORT_VECTORIZED_LOOPS, UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_VECTORIZED_LOOPS))\n     fprintf (vect_dump, \"vectorized %u loops in function.\\n\",\n \t     num_vectorized_loops);\n "}, {"sha": "87d3138bcaa0efd69ca410843b2c6dc4c341731f", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00518cb11760cbc6b2827727116c28a12e2558cc/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00518cb11760cbc6b2827727116c28a12e2558cc/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=00518cb11760cbc6b2827727116c28a12e2558cc", "patch": "@@ -122,8 +122,6 @@ typedef struct _loop_vec_info {\n   /* All data references in the loop that are being read from.  */\n   varray_type data_ref_reads;\n \n-  /* The loop location in the source.  */\n-  LOC loop_line_number;\n } *loop_vec_info;\n \n /* Access Functions.  */\n@@ -138,9 +136,6 @@ typedef struct _loop_vec_info {\n #define LOOP_VINFO_INT_NITERS(L) (TREE_INT_CST_LOW ((L)->num_iters))\n #define LOOP_PEELING_FOR_ALIGNMENT(L) (L)->peeling_for_alignment\n #define LOOP_VINFO_UNALIGNED_DR(L) (L)->unaligned_dr\n-#define LOOP_VINFO_LOC(L)          (L)->loop_line_number\n-\n-#define LOOP_LOC(L)    LOOP_VINFO_LOC(L)\n \n \n #define LOOP_VINFO_NITERS_KNOWN_P(L)                     \\\n@@ -311,6 +306,7 @@ extern enum verbosity_levels vect_verbosity_level;\n \n /* Number of loops, at the beginning of vectorization.  */\n extern unsigned int vect_loops_num;\n+\n /*-----------------------------------------------------------------*/\n /* Function prototypes.                                            */\n /*-----------------------------------------------------------------*/\n@@ -374,7 +370,7 @@ extern void vect_transform_loop (loop_vec_info, struct loops *);\n /*************************************************************************\n   Vectorization Debug Information - in tree-vectorizer.c\n  *************************************************************************/\n-extern bool vect_print_dump_info (enum verbosity_levels, LOC);\n+extern bool vect_print_dump_info (enum verbosity_levels);\n extern void vect_set_verbosity_level (const char *);\n extern LOC find_loop_location (struct loop *);\n "}]}