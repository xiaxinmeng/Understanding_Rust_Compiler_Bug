{"sha": "79e1251b642db038df276153c9f2ec6b82e56162", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzllMTI1MWI2NDJkYjAzOGRmMjc2MTUzYzlmMmVjNmI4MmU1NjE2Mg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-01-20T14:43:48Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-01-20T14:43:48Z"}, "message": "c++: Defer access checking when processing bases [PR82613]\n\nWhen parsing the base-clause of a class declaration, we need to defer\naccess checking until the entire base-clause has been seen, so that\naccess can be properly checked relative to the scope of the class with\nall its bases attached.  This allows us to accept the declaration of\nstruct D from Example 2 of [class.access.general] (access12.C below).\n\nSimilarly when substituting into the base-clause of a class template,\nwhich is the subject of PR82613.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/82613\n\t* parser.c (cp_parser_class_head): Defer access checking when\n\tparsing the base-clause until all bases are seen and attached\n\tto the class type.\n\t* pt.c (instantiate_class_template): Likewise when substituting\n\tinto dependent bases.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/82613\n\t* g++.dg/parse/access12.C: New test.\n\t* g++.dg/template/access35.C: New test.", "tree": {"sha": "ec8ef4360954f0164fe7800a45e3b85d96079c81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec8ef4360954f0164fe7800a45e3b85d96079c81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79e1251b642db038df276153c9f2ec6b82e56162", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79e1251b642db038df276153c9f2ec6b82e56162", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79e1251b642db038df276153c9f2ec6b82e56162", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79e1251b642db038df276153c9f2ec6b82e56162/comments", "author": null, "committer": null, "parents": [{"sha": "ea74a3f548eb321429c371e327e778e63d9128a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea74a3f548eb321429c371e327e778e63d9128a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea74a3f548eb321429c371e327e778e63d9128a0"}], "stats": {"total": 89, "additions": 68, "deletions": 21}, "files": [{"sha": "4b2bca3fd1178bc92b256ff23683903a01af6a6e", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79e1251b642db038df276153c9f2ec6b82e56162/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79e1251b642db038df276153c9f2ec6b82e56162/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=79e1251b642db038df276153c9f2ec6b82e56162", "patch": "@@ -25576,19 +25576,11 @@ cp_parser_class_head (cp_parser* parser,\n \n      is valid.  */\n \n-  /* Get the list of base-classes, if there is one.  */\n+  /* Get the list of base-classes, if there is one.  Defer access checking\n+     until the entire list has been seen, as per [class.access.general].  */\n+  push_deferring_access_checks (dk_deferred);\n   if (cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n-    {\n-      /* PR59482: enter the class scope so that base-specifiers are looked\n-\t up correctly.  */\n-      if (type)\n-\tpushclass (type);\n-      bases = cp_parser_base_clause (parser);\n-      /* PR59482: get out of the previously pushed class scope so that the\n-\t subsequent pops pop the right thing.  */\n-      if (type)\n-\tpopclass ();\n-    }\n+    bases = cp_parser_base_clause (parser);\n   else\n     bases = NULL_TREE;\n \n@@ -25597,6 +25589,20 @@ cp_parser_class_head (cp_parser* parser,\n   if (type && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n     xref_basetypes (type, bases);\n \n+  /* Now that all bases have been seen and attached to the class, check\n+     accessibility of the types named in the base-clause.  This must be\n+     done relative to the class scope, so that we accept e.g.\n+\n+       struct A { protected: struct B {}; };\n+       struct C : A::B, A {}; // OK: A::B is accessible via base A\n+\n+     as per [class.access.general].  */\n+  if (type)\n+    pushclass (type);\n+  pop_to_parent_deferring_access_checks ();\n+  if (type)\n+    popclass ();\n+\n  done:\n   /* Leave the scope given by the nested-name-specifier.  We will\n      enter the class scope itself while processing the members.  */"}, {"sha": "bcf4c6efe1195505585b4d9249898dc89ab8137a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79e1251b642db038df276153c9f2ec6b82e56162/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79e1251b642db038df276153c9f2ec6b82e56162/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=79e1251b642db038df276153c9f2ec6b82e56162", "patch": "@@ -11825,17 +11825,14 @@ instantiate_class_template_1 (tree type)\n \t      || COMPLETE_OR_OPEN_TYPE_P (TYPE_CONTEXT (type)));\n \n   base_list = NULL_TREE;\n+  /* Defer access checking while we substitute into the types named in\n+     the base-clause.  */\n+  push_deferring_access_checks (dk_deferred);\n   if (BINFO_N_BASE_BINFOS (pbinfo))\n     {\n       tree pbase_binfo;\n-      tree pushed_scope;\n       int i;\n \n-      /* We must enter the scope containing the type, as that is where\n-\t the accessibility of types named in dependent bases are\n-\t looked up from.  */\n-      pushed_scope = push_scope (CP_TYPE_CONTEXT (type));\n-\n       /* Substitute into each of the bases to determine the actual\n \t basetypes.  */\n       for (i = 0; BINFO_BASE_ITERATE (pbinfo, i, pbase_binfo); i++)\n@@ -11877,9 +11874,6 @@ instantiate_class_template_1 (tree type)\n \n       /* The list is now in reverse order; correct that.  */\n       base_list = nreverse (base_list);\n-\n-      if (pushed_scope)\n-\tpop_scope (pushed_scope);\n     }\n   /* Now call xref_basetypes to set up all the base-class\n      information.  */\n@@ -11897,6 +11891,10 @@ instantiate_class_template_1 (tree type)\n      class, except we also need to push the enclosing classes.  */\n   push_nested_class (type);\n \n+  /* Now check accessibility of the types named in its base-clause,\n+     relative to the scope of the class.  */\n+  pop_to_parent_deferring_access_checks ();\n+\n   /* Now members are processed in the order of declaration.  */\n   for (member = CLASSTYPE_DECL_LIST (pattern);\n        member; member = TREE_CHAIN (member))"}, {"sha": "6963e0eb08993483baad2ab90d8c89d168bc8ece", "filename": "gcc/testsuite/g++.dg/parse/access12.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79e1251b642db038df276153c9f2ec6b82e56162/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Faccess12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79e1251b642db038df276153c9f2ec6b82e56162/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Faccess12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Faccess12.C?ref=79e1251b642db038df276153c9f2ec6b82e56162", "patch": "@@ -0,0 +1,24 @@\n+// Example 2 of [class.access.general]\n+// { dg-do compile }\n+\n+class A {\n+  typedef int I;    // private member\n+  I f();\n+  friend I g(I);\n+  static I x;\n+  template<int> struct Q;\n+  template<int> friend struct R;\n+protected:\n+    struct B { };\n+};\n+\n+A::I A::f() { return 0; }\n+A::I g(A::I p = A::x);\n+A::I g(A::I p) { return 0; }\n+A::I A::x = 0;\n+// FIXME: We reject these two declarations because access checking of A::I\n+// is not performed in the scope of the class being declared.\n+// template<A::I> struct A::Q { };\n+// template<A::I> struct R { };\n+\n+struct D: A::B, A { };"}, {"sha": "70197eb052c50020e5fe003539d2ca5d0b3b36ea", "filename": "gcc/testsuite/g++.dg/template/access35.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79e1251b642db038df276153c9f2ec6b82e56162/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess35.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79e1251b642db038df276153c9f2ec6b82e56162/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess35.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess35.C?ref=79e1251b642db038df276153c9f2ec6b82e56162", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/82613\n+// { dg-do compile }\n+\n+template <typename T> class B;\n+\n+class A {\n+  friend class B<A>;\n+  class Type {};\n+};\n+\n+template <typename T>\n+class B : T::Type { protected: class Type {}; };\n+\n+B<A> b;\n+\n+template <typename T>\n+class C : B<T>::Type, B<T> {};\n+\n+C<A> c;"}]}