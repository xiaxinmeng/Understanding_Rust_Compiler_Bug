{"sha": "41a34e22f899765652988c53f708143089510461", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFhMzRlMjJmODk5NzY1NjUyOTg4YzUzZjcwODE0MzA4OTUxMDQ2MQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-09-17T15:06:22Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-09-17T15:53:45Z"}, "message": "rs6000: Handle gimple folding of target built-ins\n\nThis is another patch that looks bigger than it really is.  Because we\nhave a new namespace for the builtins, allowing us to have both the old\nand new builtin infrastructure supported at once, we need versions of\nthese functions that use the new builtin namespace.  Otherwise the code is\nunchanged.\n\n2021-09-17  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000-call.c (rs6000_gimple_fold_new_builtin): New\n\tforward decl.\n\t(rs6000_gimple_fold_builtin): Call rs6000_gimple_fold_new_builtin.\n\t(rs6000_new_builtin_valid_without_lhs): New function.\n\t(rs6000_gimple_fold_new_mma_builtin): Likewise.\n\t(rs6000_gimple_fold_new_builtin): Likewise.", "tree": {"sha": "cbf54a5b65ad5306806583f436153bb9585ec9fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbf54a5b65ad5306806583f436153bb9585ec9fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41a34e22f899765652988c53f708143089510461", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41a34e22f899765652988c53f708143089510461", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41a34e22f899765652988c53f708143089510461", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41a34e22f899765652988c53f708143089510461/comments", "author": null, "committer": null, "parents": [{"sha": "89be17a1b231ade643f28fbe616d53377e069da8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89be17a1b231ade643f28fbe616d53377e069da8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89be17a1b231ade643f28fbe616d53377e069da8"}], "stats": {"total": 1165, "additions": 1165, "deletions": 0}, "files": [{"sha": "b4d4aa86934efaad6adaf09b1394cc7a873f184e", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 1165, "deletions": 0, "changes": 1165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41a34e22f899765652988c53f708143089510461/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41a34e22f899765652988c53f708143089510461/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=41a34e22f899765652988c53f708143089510461", "patch": "@@ -190,6 +190,7 @@ static tree builtin_function_type (machine_mode, machine_mode,\n static void rs6000_common_init_builtins (void);\n static void htm_init_builtins (void);\n static void mma_init_builtins (void);\n+static bool rs6000_gimple_fold_new_builtin (gimple_stmt_iterator *gsi);\n \n \n /* Hash table to keep track of the argument types for builtin functions.  */\n@@ -12024,6 +12025,9 @@ rs6000_gimple_fold_mma_builtin (gimple_stmt_iterator *gsi)\n bool\n rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n {\n+  if (new_builtins_are_live)\n+    return rs6000_gimple_fold_new_builtin (gsi);\n+\n   gimple *stmt = gsi_stmt (*gsi);\n   tree fndecl = gimple_call_fndecl (stmt);\n   gcc_checking_assert (fndecl && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD);\n@@ -12971,6 +12975,35 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n   return false;\n }\n \n+/*  Helper function to sort out which built-ins may be valid without having\n+    a LHS.  */\n+static bool\n+rs6000_new_builtin_valid_without_lhs (enum rs6000_gen_builtins fn_code,\n+\t\t\t\t      tree fndecl)\n+{\n+  if (TREE_TYPE (TREE_TYPE (fndecl)) == void_type_node)\n+    return true;\n+\n+  switch (fn_code)\n+    {\n+    case RS6000_BIF_STVX_V16QI:\n+    case RS6000_BIF_STVX_V8HI:\n+    case RS6000_BIF_STVX_V4SI:\n+    case RS6000_BIF_STVX_V4SF:\n+    case RS6000_BIF_STVX_V2DI:\n+    case RS6000_BIF_STVX_V2DF:\n+    case RS6000_BIF_STXVW4X_V16QI:\n+    case RS6000_BIF_STXVW4X_V8HI:\n+    case RS6000_BIF_STXVW4X_V4SF:\n+    case RS6000_BIF_STXVW4X_V4SI:\n+    case RS6000_BIF_STXVD2X_V2DF:\n+    case RS6000_BIF_STXVD2X_V2DI:\n+      return true;\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Check whether a builtin function is supported in this target\n    configuration.  */\n bool\n@@ -13024,6 +13057,1138 @@ rs6000_new_builtin_is_supported (enum rs6000_gen_builtins fncode)\n   gcc_unreachable ();\n }\n \n+/* Expand the MMA built-ins early, so that we can convert the pass-by-reference\n+   __vector_quad arguments into pass-by-value arguments, leading to more\n+   efficient code generation.  */\n+static bool\n+rs6000_gimple_fold_new_mma_builtin (gimple_stmt_iterator *gsi,\n+\t\t\t\t    rs6000_gen_builtins fn_code)\n+{\n+  gimple *stmt = gsi_stmt (*gsi);\n+  size_t fncode = (size_t) fn_code;\n+\n+  if (!bif_is_mma (rs6000_builtin_info_x[fncode]))\n+    return false;\n+\n+  /* Each call that can be gimple-expanded has an associated built-in\n+     function that it will expand into.  If this one doesn't, we have\n+     already expanded it!  */\n+  if (rs6000_builtin_info_x[fncode].assoc_bif == RS6000_BIF_NONE)\n+    return false;\n+\n+  bifdata *bd = &rs6000_builtin_info_x[fncode];\n+  unsigned nopnds = bd->nargs;\n+  gimple_seq new_seq = NULL;\n+  gimple *new_call;\n+  tree new_decl;\n+\n+  /* Compatibility built-ins; we used to call these\n+     __builtin_mma_{dis,}assemble_pair, but now we call them\n+     __builtin_vsx_{dis,}assemble_pair.  Handle the old versions.  */\n+  if (fncode == RS6000_BIF_ASSEMBLE_PAIR)\n+    fncode = RS6000_BIF_ASSEMBLE_PAIR_V;\n+  else if (fncode == RS6000_BIF_DISASSEMBLE_PAIR)\n+    fncode = RS6000_BIF_DISASSEMBLE_PAIR_V;\n+\n+  if (fncode == RS6000_BIF_DISASSEMBLE_ACC\n+      || fncode == RS6000_BIF_DISASSEMBLE_PAIR_V)\n+    {\n+      /* This is an MMA disassemble built-in function.  */\n+      push_gimplify_context (true);\n+      unsigned nvec = (fncode == RS6000_BIF_DISASSEMBLE_ACC) ? 4 : 2;\n+      tree dst_ptr = gimple_call_arg (stmt, 0);\n+      tree src_ptr = gimple_call_arg (stmt, 1);\n+      tree src_type = TREE_TYPE (src_ptr);\n+      tree src = create_tmp_reg_or_ssa_name (TREE_TYPE (src_type));\n+      gimplify_assign (src, build_simple_mem_ref (src_ptr), &new_seq);\n+\n+      /* If we are not disassembling an accumulator/pair or our destination is\n+\t another accumulator/pair, then just copy the entire thing as is.  */\n+      if ((fncode == RS6000_BIF_DISASSEMBLE_ACC\n+\t   && TREE_TYPE (TREE_TYPE (dst_ptr)) == vector_quad_type_node)\n+\t  || (fncode == RS6000_BIF_DISASSEMBLE_PAIR_V\n+\t      && TREE_TYPE (TREE_TYPE (dst_ptr)) == vector_pair_type_node))\n+\t{\n+\t  tree dst = build_simple_mem_ref (build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t   src_type, dst_ptr));\n+\t  gimplify_assign (dst, src, &new_seq);\n+\t  pop_gimplify_context (NULL);\n+\t  gsi_replace_with_seq (gsi, new_seq, true);\n+\t  return true;\n+\t}\n+\n+      /* If we're disassembling an accumulator into a different type, we need\n+\t to emit a xxmfacc instruction now, since we cannot do it later.  */\n+      if (fncode == RS6000_BIF_DISASSEMBLE_ACC)\n+\t{\n+\t  new_decl = rs6000_builtin_decls_x[RS6000_BIF_XXMFACC_INTERNAL];\n+\t  new_call = gimple_build_call (new_decl, 1, src);\n+\t  src = create_tmp_reg_or_ssa_name (vector_quad_type_node);\n+\t  gimple_call_set_lhs (new_call, src);\n+\t  gimple_seq_add_stmt (&new_seq, new_call);\n+\t}\n+\n+      /* Copy the accumulator/pair vector by vector.  */\n+      new_decl\n+\t= rs6000_builtin_decls_x[rs6000_builtin_info_x[fncode].assoc_bif];\n+      tree dst_type = build_pointer_type_for_mode (unsigned_V16QI_type_node,\n+\t\t\t\t\t\t   ptr_mode, true);\n+      tree dst_base = build1 (VIEW_CONVERT_EXPR, dst_type, dst_ptr);\n+      for (unsigned i = 0; i < nvec; i++)\n+\t{\n+\t  unsigned index = WORDS_BIG_ENDIAN ? i : nvec - 1 - i;\n+\t  tree dst = build2 (MEM_REF, unsigned_V16QI_type_node, dst_base,\n+\t\t\t     build_int_cst (dst_type, index * 16));\n+\t  tree dstssa = create_tmp_reg_or_ssa_name (unsigned_V16QI_type_node);\n+\t  new_call = gimple_build_call (new_decl, 2, src,\n+\t\t\t\t\tbuild_int_cstu (uint16_type_node, i));\n+\t  gimple_call_set_lhs (new_call, dstssa);\n+\t  gimple_seq_add_stmt (&new_seq, new_call);\n+\t  gimplify_assign (dst, dstssa, &new_seq);\n+\t}\n+      pop_gimplify_context (NULL);\n+      gsi_replace_with_seq (gsi, new_seq, true);\n+      return true;\n+    }\n+\n+  /* Convert this built-in into an internal version that uses pass-by-value\n+     arguments.  The internal built-in is found in the assoc_bif field.  */\n+  new_decl = rs6000_builtin_decls_x[rs6000_builtin_info_x[fncode].assoc_bif];\n+  tree lhs, op[MAX_MMA_OPERANDS];\n+  tree acc = gimple_call_arg (stmt, 0);\n+  push_gimplify_context (true);\n+\n+  if (bif_is_quad (*bd))\n+    {\n+      /* This built-in has a pass-by-reference accumulator input, so load it\n+\t into a temporary accumulator for use as a pass-by-value input.  */\n+      op[0] = create_tmp_reg_or_ssa_name (vector_quad_type_node);\n+      for (unsigned i = 1; i < nopnds; i++)\n+\top[i] = gimple_call_arg (stmt, i);\n+      gimplify_assign (op[0], build_simple_mem_ref (acc), &new_seq);\n+    }\n+  else\n+    {\n+      /* This built-in does not use its pass-by-reference accumulator argument\n+\t as an input argument, so remove it from the input list.  */\n+      nopnds--;\n+      for (unsigned i = 0; i < nopnds; i++)\n+\top[i] = gimple_call_arg (stmt, i + 1);\n+    }\n+\n+  switch (nopnds)\n+    {\n+    case 0:\n+      new_call = gimple_build_call (new_decl, 0);\n+      break;\n+    case 1:\n+      new_call = gimple_build_call (new_decl, 1, op[0]);\n+      break;\n+    case 2:\n+      new_call = gimple_build_call (new_decl, 2, op[0], op[1]);\n+      break;\n+    case 3:\n+      new_call = gimple_build_call (new_decl, 3, op[0], op[1], op[2]);\n+      break;\n+    case 4:\n+      new_call = gimple_build_call (new_decl, 4, op[0], op[1], op[2], op[3]);\n+      break;\n+    case 5:\n+      new_call = gimple_build_call (new_decl, 5, op[0], op[1], op[2], op[3],\n+\t\t\t\t    op[4]);\n+      break;\n+    case 6:\n+      new_call = gimple_build_call (new_decl, 6, op[0], op[1], op[2], op[3],\n+\t\t\t\t    op[4], op[5]);\n+      break;\n+    case 7:\n+      new_call = gimple_build_call (new_decl, 7, op[0], op[1], op[2], op[3],\n+\t\t\t\t    op[4], op[5], op[6]);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (fncode == RS6000_BIF_BUILD_PAIR || fncode == RS6000_BIF_ASSEMBLE_PAIR_V)\n+    lhs = create_tmp_reg_or_ssa_name (vector_pair_type_node);\n+  else\n+    lhs = create_tmp_reg_or_ssa_name (vector_quad_type_node);\n+  gimple_call_set_lhs (new_call, lhs);\n+  gimple_seq_add_stmt (&new_seq, new_call);\n+  gimplify_assign (build_simple_mem_ref (acc), lhs, &new_seq);\n+  pop_gimplify_context (NULL);\n+  gsi_replace_with_seq (gsi, new_seq, true);\n+\n+  return true;\n+}\n+\n+/* Fold a machine-dependent built-in in GIMPLE.  (For folding into\n+   a constant, use rs6000_fold_builtin.)  */\n+static bool\n+rs6000_gimple_fold_new_builtin (gimple_stmt_iterator *gsi)\n+{\n+  gimple *stmt = gsi_stmt (*gsi);\n+  tree fndecl = gimple_call_fndecl (stmt);\n+  gcc_checking_assert (fndecl && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD);\n+  enum rs6000_gen_builtins fn_code\n+    = (enum rs6000_gen_builtins) DECL_MD_FUNCTION_CODE (fndecl);\n+  tree arg0, arg1, lhs, temp;\n+  enum tree_code bcode;\n+  gimple *g;\n+\n+  size_t uns_fncode = (size_t) fn_code;\n+  enum insn_code icode = rs6000_builtin_info_x[uns_fncode].icode;\n+  const char *fn_name1 = rs6000_builtin_info_x[uns_fncode].bifname;\n+  const char *fn_name2 = (icode != CODE_FOR_nothing)\n+\t\t\t  ? get_insn_name ((int) icode)\n+\t\t\t  : \"nothing\";\n+\n+  if (TARGET_DEBUG_BUILTIN)\n+      fprintf (stderr, \"rs6000_gimple_fold_new_builtin %d %s %s\\n\",\n+\t       fn_code, fn_name1, fn_name2);\n+\n+  if (!rs6000_fold_gimple)\n+    return false;\n+\n+  /* Prevent gimple folding for code that does not have a LHS, unless it is\n+     allowed per the rs6000_new_builtin_valid_without_lhs helper function.  */\n+  if (!gimple_call_lhs (stmt)\n+      && !rs6000_new_builtin_valid_without_lhs (fn_code, fndecl))\n+    return false;\n+\n+  /* Don't fold invalid builtins, let rs6000_expand_builtin diagnose it.  */\n+  if (!rs6000_new_builtin_is_supported (fn_code))\n+    return false;\n+\n+  if (rs6000_gimple_fold_new_mma_builtin (gsi, fn_code))\n+    return true;\n+\n+  switch (fn_code)\n+    {\n+    /* Flavors of vec_add.  We deliberately don't expand\n+       RS6000_BIF_VADDUQM as it gets lowered from V1TImode to\n+       TImode, resulting in much poorer code generation.  */\n+    case RS6000_BIF_VADDUBM:\n+    case RS6000_BIF_VADDUHM:\n+    case RS6000_BIF_VADDUWM:\n+    case RS6000_BIF_VADDUDM:\n+    case RS6000_BIF_VADDFP:\n+    case RS6000_BIF_XVADDDP:\n+    case RS6000_BIF_XVADDSP:\n+      bcode = PLUS_EXPR;\n+    do_binary:\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (lhs)))\n+\t  && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (TREE_TYPE (lhs))))\n+\t{\n+\t  /* Ensure the binary operation is performed in a type\n+\t     that wraps if it is integral type.  */\n+\t  gimple_seq stmts = NULL;\n+\t  tree type = unsigned_type_for (TREE_TYPE (lhs));\n+\t  tree uarg0 = gimple_build (&stmts, VIEW_CONVERT_EXPR,\n+\t\t\t\t     type, arg0);\n+\t  tree uarg1 = gimple_build (&stmts, VIEW_CONVERT_EXPR,\n+\t\t\t\t     type, arg1);\n+\t  tree res = gimple_build (&stmts, gimple_location (stmt), bcode,\n+\t\t\t\t   type, uarg0, uarg1);\n+\t  gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\t  g = gimple_build_assign (lhs, VIEW_CONVERT_EXPR,\n+\t\t\t\t   build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t   TREE_TYPE (lhs), res));\n+\t  gsi_replace (gsi, g, true);\n+\t  return true;\n+\t}\n+      g = gimple_build_assign (lhs, bcode, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n+    /* Flavors of vec_sub.  We deliberately don't expand\n+       RS6000_BIF_VSUBUQM. */\n+    case RS6000_BIF_VSUBUBM:\n+    case RS6000_BIF_VSUBUHM:\n+    case RS6000_BIF_VSUBUWM:\n+    case RS6000_BIF_VSUBUDM:\n+    case RS6000_BIF_VSUBFP:\n+    case RS6000_BIF_XVSUBDP:\n+    case RS6000_BIF_XVSUBSP:\n+      bcode = MINUS_EXPR;\n+      goto do_binary;\n+    case RS6000_BIF_XVMULSP:\n+    case RS6000_BIF_XVMULDP:\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, MULT_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n+    /* Even element flavors of vec_mul (signed). */\n+    case RS6000_BIF_VMULESB:\n+    case RS6000_BIF_VMULESH:\n+    case RS6000_BIF_VMULESW:\n+    /* Even element flavors of vec_mul (unsigned).  */\n+    case RS6000_BIF_VMULEUB:\n+    case RS6000_BIF_VMULEUH:\n+    case RS6000_BIF_VMULEUW:\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, VEC_WIDEN_MULT_EVEN_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n+    /* Odd element flavors of vec_mul (signed).  */\n+    case RS6000_BIF_VMULOSB:\n+    case RS6000_BIF_VMULOSH:\n+    case RS6000_BIF_VMULOSW:\n+    /* Odd element flavors of vec_mul (unsigned). */\n+    case RS6000_BIF_VMULOUB:\n+    case RS6000_BIF_VMULOUH:\n+    case RS6000_BIF_VMULOUW:\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, VEC_WIDEN_MULT_ODD_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n+    /* Flavors of vec_div (Integer).  */\n+    case RS6000_BIF_DIV_V2DI:\n+    case RS6000_BIF_UDIV_V2DI:\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, TRUNC_DIV_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n+    /* Flavors of vec_div (Float).  */\n+    case RS6000_BIF_XVDIVSP:\n+    case RS6000_BIF_XVDIVDP:\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, RDIV_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n+    /* Flavors of vec_and.  */\n+    case RS6000_BIF_VAND_V16QI_UNS:\n+    case RS6000_BIF_VAND_V16QI:\n+    case RS6000_BIF_VAND_V8HI_UNS:\n+    case RS6000_BIF_VAND_V8HI:\n+    case RS6000_BIF_VAND_V4SI_UNS:\n+    case RS6000_BIF_VAND_V4SI:\n+    case RS6000_BIF_VAND_V2DI_UNS:\n+    case RS6000_BIF_VAND_V2DI:\n+    case RS6000_BIF_VAND_V4SF:\n+    case RS6000_BIF_VAND_V2DF:\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, BIT_AND_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n+    /* Flavors of vec_andc.  */\n+    case RS6000_BIF_VANDC_V16QI_UNS:\n+    case RS6000_BIF_VANDC_V16QI:\n+    case RS6000_BIF_VANDC_V8HI_UNS:\n+    case RS6000_BIF_VANDC_V8HI:\n+    case RS6000_BIF_VANDC_V4SI_UNS:\n+    case RS6000_BIF_VANDC_V4SI:\n+    case RS6000_BIF_VANDC_V2DI_UNS:\n+    case RS6000_BIF_VANDC_V2DI:\n+    case RS6000_BIF_VANDC_V4SF:\n+    case RS6000_BIF_VANDC_V2DF:\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      temp = create_tmp_reg_or_ssa_name (TREE_TYPE (arg1));\n+      g = gimple_build_assign (temp, BIT_NOT_EXPR, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+      g = gimple_build_assign (lhs, BIT_AND_EXPR, arg0, temp);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n+    /* Flavors of vec_nand.  */\n+    case RS6000_BIF_NAND_V16QI_UNS:\n+    case RS6000_BIF_NAND_V16QI:\n+    case RS6000_BIF_NAND_V8HI_UNS:\n+    case RS6000_BIF_NAND_V8HI:\n+    case RS6000_BIF_NAND_V4SI_UNS:\n+    case RS6000_BIF_NAND_V4SI:\n+    case RS6000_BIF_NAND_V2DI_UNS:\n+    case RS6000_BIF_NAND_V2DI:\n+    case RS6000_BIF_NAND_V4SF:\n+    case RS6000_BIF_NAND_V2DF:\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      temp = create_tmp_reg_or_ssa_name (TREE_TYPE (arg1));\n+      g = gimple_build_assign (temp, BIT_AND_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+      g = gimple_build_assign (lhs, BIT_NOT_EXPR, temp);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n+    /* Flavors of vec_or.  */\n+    case RS6000_BIF_VOR_V16QI_UNS:\n+    case RS6000_BIF_VOR_V16QI:\n+    case RS6000_BIF_VOR_V8HI_UNS:\n+    case RS6000_BIF_VOR_V8HI:\n+    case RS6000_BIF_VOR_V4SI_UNS:\n+    case RS6000_BIF_VOR_V4SI:\n+    case RS6000_BIF_VOR_V2DI_UNS:\n+    case RS6000_BIF_VOR_V2DI:\n+    case RS6000_BIF_VOR_V4SF:\n+    case RS6000_BIF_VOR_V2DF:\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, BIT_IOR_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n+    /* flavors of vec_orc.  */\n+    case RS6000_BIF_ORC_V16QI_UNS:\n+    case RS6000_BIF_ORC_V16QI:\n+    case RS6000_BIF_ORC_V8HI_UNS:\n+    case RS6000_BIF_ORC_V8HI:\n+    case RS6000_BIF_ORC_V4SI_UNS:\n+    case RS6000_BIF_ORC_V4SI:\n+    case RS6000_BIF_ORC_V2DI_UNS:\n+    case RS6000_BIF_ORC_V2DI:\n+    case RS6000_BIF_ORC_V4SF:\n+    case RS6000_BIF_ORC_V2DF:\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      temp = create_tmp_reg_or_ssa_name (TREE_TYPE (arg1));\n+      g = gimple_build_assign (temp, BIT_NOT_EXPR, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+      g = gimple_build_assign (lhs, BIT_IOR_EXPR, arg0, temp);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n+    /* Flavors of vec_xor.  */\n+    case RS6000_BIF_VXOR_V16QI_UNS:\n+    case RS6000_BIF_VXOR_V16QI:\n+    case RS6000_BIF_VXOR_V8HI_UNS:\n+    case RS6000_BIF_VXOR_V8HI:\n+    case RS6000_BIF_VXOR_V4SI_UNS:\n+    case RS6000_BIF_VXOR_V4SI:\n+    case RS6000_BIF_VXOR_V2DI_UNS:\n+    case RS6000_BIF_VXOR_V2DI:\n+    case RS6000_BIF_VXOR_V4SF:\n+    case RS6000_BIF_VXOR_V2DF:\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, BIT_XOR_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n+    /* Flavors of vec_nor.  */\n+    case RS6000_BIF_VNOR_V16QI_UNS:\n+    case RS6000_BIF_VNOR_V16QI:\n+    case RS6000_BIF_VNOR_V8HI_UNS:\n+    case RS6000_BIF_VNOR_V8HI:\n+    case RS6000_BIF_VNOR_V4SI_UNS:\n+    case RS6000_BIF_VNOR_V4SI:\n+    case RS6000_BIF_VNOR_V2DI_UNS:\n+    case RS6000_BIF_VNOR_V2DI:\n+    case RS6000_BIF_VNOR_V4SF:\n+    case RS6000_BIF_VNOR_V2DF:\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      temp = create_tmp_reg_or_ssa_name (TREE_TYPE (arg1));\n+      g = gimple_build_assign (temp, BIT_IOR_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+      g = gimple_build_assign (lhs, BIT_NOT_EXPR, temp);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n+    /* flavors of vec_abs.  */\n+    case RS6000_BIF_ABS_V16QI:\n+    case RS6000_BIF_ABS_V8HI:\n+    case RS6000_BIF_ABS_V4SI:\n+    case RS6000_BIF_ABS_V4SF:\n+    case RS6000_BIF_ABS_V2DI:\n+    case RS6000_BIF_XVABSDP:\n+    case RS6000_BIF_XVABSSP:\n+      arg0 = gimple_call_arg (stmt, 0);\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (arg0)))\n+\t  && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (TREE_TYPE (arg0))))\n+\treturn false;\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, ABS_EXPR, arg0);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n+    /* flavors of vec_min.  */\n+    case RS6000_BIF_XVMINDP:\n+    case RS6000_BIF_XVMINSP:\n+    case RS6000_BIF_VMINSD:\n+    case RS6000_BIF_VMINUD:\n+    case RS6000_BIF_VMINSB:\n+    case RS6000_BIF_VMINSH:\n+    case RS6000_BIF_VMINSW:\n+    case RS6000_BIF_VMINUB:\n+    case RS6000_BIF_VMINUH:\n+    case RS6000_BIF_VMINUW:\n+    case RS6000_BIF_VMINFP:\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, MIN_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n+    /* flavors of vec_max.  */\n+    case RS6000_BIF_XVMAXDP:\n+    case RS6000_BIF_XVMAXSP:\n+    case RS6000_BIF_VMAXSD:\n+    case RS6000_BIF_VMAXUD:\n+    case RS6000_BIF_VMAXSB:\n+    case RS6000_BIF_VMAXSH:\n+    case RS6000_BIF_VMAXSW:\n+    case RS6000_BIF_VMAXUB:\n+    case RS6000_BIF_VMAXUH:\n+    case RS6000_BIF_VMAXUW:\n+    case RS6000_BIF_VMAXFP:\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, MAX_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n+    /* Flavors of vec_eqv.  */\n+    case RS6000_BIF_EQV_V16QI:\n+    case RS6000_BIF_EQV_V8HI:\n+    case RS6000_BIF_EQV_V4SI:\n+    case RS6000_BIF_EQV_V4SF:\n+    case RS6000_BIF_EQV_V2DF:\n+    case RS6000_BIF_EQV_V2DI:\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      temp = create_tmp_reg_or_ssa_name (TREE_TYPE (arg1));\n+      g = gimple_build_assign (temp, BIT_XOR_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+      g = gimple_build_assign (lhs, BIT_NOT_EXPR, temp);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n+    /* Flavors of vec_rotate_left.  */\n+    case RS6000_BIF_VRLB:\n+    case RS6000_BIF_VRLH:\n+    case RS6000_BIF_VRLW:\n+    case RS6000_BIF_VRLD:\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, LROTATE_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n+  /* Flavors of vector shift right algebraic.\n+     vec_sra{b,h,w} -> vsra{b,h,w}.  */\n+    case RS6000_BIF_VSRAB:\n+    case RS6000_BIF_VSRAH:\n+    case RS6000_BIF_VSRAW:\n+    case RS6000_BIF_VSRAD:\n+      {\n+\targ0 = gimple_call_arg (stmt, 0);\n+\targ1 = gimple_call_arg (stmt, 1);\n+\tlhs = gimple_call_lhs (stmt);\n+\ttree arg1_type = TREE_TYPE (arg1);\n+\ttree unsigned_arg1_type = unsigned_type_for (TREE_TYPE (arg1));\n+\ttree unsigned_element_type = unsigned_type_for (TREE_TYPE (arg1_type));\n+\tlocation_t loc = gimple_location (stmt);\n+\t/* Force arg1 into the range valid matching the arg0 type.  */\n+\t/* Build a vector consisting of the max valid bit-size values.  */\n+\tint n_elts = VECTOR_CST_NELTS (arg1);\n+\ttree element_size = build_int_cst (unsigned_element_type,\n+\t\t\t\t\t   128 / n_elts);\n+\ttree_vector_builder elts (unsigned_arg1_type, n_elts, 1);\n+\tfor (int i = 0; i < n_elts; i++)\n+\t  elts.safe_push (element_size);\n+\ttree modulo_tree = elts.build ();\n+\t/* Modulo the provided shift value against that vector.  */\n+\tgimple_seq stmts = NULL;\n+\ttree unsigned_arg1 = gimple_build (&stmts, VIEW_CONVERT_EXPR,\n+\t\t\t\t\t   unsigned_arg1_type, arg1);\n+\ttree new_arg1 = gimple_build (&stmts, loc, TRUNC_MOD_EXPR,\n+\t\t\t\t      unsigned_arg1_type, unsigned_arg1,\n+\t\t\t\t      modulo_tree);\n+\tgsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\t/* And finally, do the shift.  */\n+\tg = gimple_build_assign (lhs, RSHIFT_EXPR, arg0, new_arg1);\n+\tgimple_set_location (g, loc);\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n+   /* Flavors of vector shift left.\n+      builtin_altivec_vsl{b,h,w} -> vsl{b,h,w}.  */\n+    case RS6000_BIF_VSLB:\n+    case RS6000_BIF_VSLH:\n+    case RS6000_BIF_VSLW:\n+    case RS6000_BIF_VSLD:\n+      {\n+\tlocation_t loc;\n+\tgimple_seq stmts = NULL;\n+\targ0 = gimple_call_arg (stmt, 0);\n+\ttree arg0_type = TREE_TYPE (arg0);\n+\tif (INTEGRAL_TYPE_P (TREE_TYPE (arg0_type))\n+\t    && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg0_type)))\n+\t  return false;\n+\targ1 = gimple_call_arg (stmt, 1);\n+\ttree arg1_type = TREE_TYPE (arg1);\n+\ttree unsigned_arg1_type = unsigned_type_for (TREE_TYPE (arg1));\n+\ttree unsigned_element_type = unsigned_type_for (TREE_TYPE (arg1_type));\n+\tloc = gimple_location (stmt);\n+\tlhs = gimple_call_lhs (stmt);\n+\t/* Force arg1 into the range valid matching the arg0 type.  */\n+\t/* Build a vector consisting of the max valid bit-size values.  */\n+\tint n_elts = VECTOR_CST_NELTS (arg1);\n+\tint tree_size_in_bits = TREE_INT_CST_LOW (size_in_bytes (arg1_type))\n+\t\t\t\t* BITS_PER_UNIT;\n+\ttree element_size = build_int_cst (unsigned_element_type,\n+\t\t\t\t\t   tree_size_in_bits / n_elts);\n+\ttree_vector_builder elts (unsigned_type_for (arg1_type), n_elts, 1);\n+\tfor (int i = 0; i < n_elts; i++)\n+\t  elts.safe_push (element_size);\n+\ttree modulo_tree = elts.build ();\n+\t/* Modulo the provided shift value against that vector.  */\n+\ttree unsigned_arg1 = gimple_build (&stmts, VIEW_CONVERT_EXPR,\n+\t\t\t\t\t   unsigned_arg1_type, arg1);\n+\ttree new_arg1 = gimple_build (&stmts, loc, TRUNC_MOD_EXPR,\n+\t\t\t\t      unsigned_arg1_type, unsigned_arg1,\n+\t\t\t\t      modulo_tree);\n+\tgsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\t/* And finally, do the shift.  */\n+\tg = gimple_build_assign (lhs, LSHIFT_EXPR, arg0, new_arg1);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n+    /* Flavors of vector shift right.  */\n+    case RS6000_BIF_VSRB:\n+    case RS6000_BIF_VSRH:\n+    case RS6000_BIF_VSRW:\n+    case RS6000_BIF_VSRD:\n+      {\n+\targ0 = gimple_call_arg (stmt, 0);\n+\targ1 = gimple_call_arg (stmt, 1);\n+\tlhs = gimple_call_lhs (stmt);\n+\ttree arg1_type = TREE_TYPE (arg1);\n+\ttree unsigned_arg1_type = unsigned_type_for (TREE_TYPE (arg1));\n+\ttree unsigned_element_type = unsigned_type_for (TREE_TYPE (arg1_type));\n+\tlocation_t loc = gimple_location (stmt);\n+\tgimple_seq stmts = NULL;\n+\t/* Convert arg0 to unsigned.  */\n+\ttree arg0_unsigned\n+\t  = gimple_build (&stmts, VIEW_CONVERT_EXPR,\n+\t\t\t  unsigned_type_for (TREE_TYPE (arg0)), arg0);\n+\t/* Force arg1 into the range valid matching the arg0 type.  */\n+\t/* Build a vector consisting of the max valid bit-size values.  */\n+\tint n_elts = VECTOR_CST_NELTS (arg1);\n+\ttree element_size = build_int_cst (unsigned_element_type,\n+\t\t\t\t\t   128 / n_elts);\n+\ttree_vector_builder elts (unsigned_arg1_type, n_elts, 1);\n+\tfor (int i = 0; i < n_elts; i++)\n+\t  elts.safe_push (element_size);\n+\ttree modulo_tree = elts.build ();\n+\t/* Modulo the provided shift value against that vector.  */\n+\ttree unsigned_arg1 = gimple_build (&stmts, VIEW_CONVERT_EXPR,\n+\t\t\t\t\t   unsigned_arg1_type, arg1);\n+\ttree new_arg1 = gimple_build (&stmts, loc, TRUNC_MOD_EXPR,\n+\t\t\t\t      unsigned_arg1_type, unsigned_arg1,\n+\t\t\t\t      modulo_tree);\n+\t/* Do the shift.  */\n+\ttree res\n+\t  = gimple_build (&stmts, RSHIFT_EXPR,\n+\t\t\t  TREE_TYPE (arg0_unsigned), arg0_unsigned, new_arg1);\n+\t/* Convert result back to the lhs type.  */\n+\tres = gimple_build (&stmts, VIEW_CONVERT_EXPR, TREE_TYPE (lhs), res);\n+\tgsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\treplace_call_with_value (gsi, res);\n+\treturn true;\n+      }\n+    /* Vector loads.  */\n+    case RS6000_BIF_LVX_V16QI:\n+    case RS6000_BIF_LVX_V8HI:\n+    case RS6000_BIF_LVX_V4SI:\n+    case RS6000_BIF_LVX_V4SF:\n+    case RS6000_BIF_LVX_V2DI:\n+    case RS6000_BIF_LVX_V2DF:\n+    case RS6000_BIF_LVX_V1TI:\n+      {\n+\targ0 = gimple_call_arg (stmt, 0);  // offset\n+\targ1 = gimple_call_arg (stmt, 1);  // address\n+\tlhs = gimple_call_lhs (stmt);\n+\tlocation_t loc = gimple_location (stmt);\n+\t/* Since arg1 may be cast to a different type, just use ptr_type_node\n+\t   here instead of trying to enforce TBAA on pointer types.  */\n+\ttree arg1_type = ptr_type_node;\n+\ttree lhs_type = TREE_TYPE (lhs);\n+\t/* POINTER_PLUS_EXPR wants the offset to be of type 'sizetype'.  Create\n+\t   the tree using the value from arg0.  The resulting type will match\n+\t   the type of arg1.  */\n+\tgimple_seq stmts = NULL;\n+\ttree temp_offset = gimple_convert (&stmts, loc, sizetype, arg0);\n+\ttree temp_addr = gimple_build (&stmts, loc, POINTER_PLUS_EXPR,\n+\t\t\t\t       arg1_type, arg1, temp_offset);\n+\t/* Mask off any lower bits from the address.  */\n+\ttree aligned_addr = gimple_build (&stmts, loc, BIT_AND_EXPR,\n+\t\t\t\t\t  arg1_type, temp_addr,\n+\t\t\t\t\t  build_int_cst (arg1_type, -16));\n+\tgsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\tif (!is_gimple_mem_ref_addr (aligned_addr))\n+\t  {\n+\t    tree t = make_ssa_name (TREE_TYPE (aligned_addr));\n+\t    gimple *g = gimple_build_assign (t, aligned_addr);\n+\t    gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+\t    aligned_addr = t;\n+\t  }\n+\t/* Use the build2 helper to set up the mem_ref.  The MEM_REF could also\n+\t   take an offset, but since we've already incorporated the offset\n+\t   above, here we just pass in a zero.  */\n+\tgimple *g\n+\t  = gimple_build_assign (lhs, build2 (MEM_REF, lhs_type, aligned_addr,\n+\t\t\t\t\t      build_int_cst (arg1_type, 0)));\n+\tgimple_set_location (g, loc);\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n+    /* Vector stores.  */\n+    case RS6000_BIF_STVX_V16QI:\n+    case RS6000_BIF_STVX_V8HI:\n+    case RS6000_BIF_STVX_V4SI:\n+    case RS6000_BIF_STVX_V4SF:\n+    case RS6000_BIF_STVX_V2DI:\n+    case RS6000_BIF_STVX_V2DF:\n+      {\n+\targ0 = gimple_call_arg (stmt, 0); /* Value to be stored.  */\n+\targ1 = gimple_call_arg (stmt, 1); /* Offset.  */\n+\ttree arg2 = gimple_call_arg (stmt, 2); /* Store-to address.  */\n+\tlocation_t loc = gimple_location (stmt);\n+\ttree arg0_type = TREE_TYPE (arg0);\n+\t/* Use ptr_type_node (no TBAA) for the arg2_type.\n+\t   FIXME: (Richard)  \"A proper fix would be to transition this type as\n+\t   seen from the frontend to GIMPLE, for example in a similar way we\n+\t   do for MEM_REFs by piggy-backing that on an extra argument, a\n+\t   constant zero pointer of the alias pointer type to use (which would\n+\t   also serve as a type indicator of the store itself).  I'd use a\n+\t   target specific internal function for this (not sure if we can have\n+\t   those target specific, but I guess if it's folded away then that's\n+\t   fine) and get away with the overload set.\"  */\n+\ttree arg2_type = ptr_type_node;\n+\t/* POINTER_PLUS_EXPR wants the offset to be of type 'sizetype'.  Create\n+\t   the tree using the value from arg0.  The resulting type will match\n+\t   the type of arg2.  */\n+\tgimple_seq stmts = NULL;\n+\ttree temp_offset = gimple_convert (&stmts, loc, sizetype, arg1);\n+\ttree temp_addr = gimple_build (&stmts, loc, POINTER_PLUS_EXPR,\n+\t\t\t\t       arg2_type, arg2, temp_offset);\n+\t/* Mask off any lower bits from the address.  */\n+\ttree aligned_addr = gimple_build (&stmts, loc, BIT_AND_EXPR,\n+\t\t\t\t\t  arg2_type, temp_addr,\n+\t\t\t\t\t  build_int_cst (arg2_type, -16));\n+\tgsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\tif (!is_gimple_mem_ref_addr (aligned_addr))\n+\t  {\n+\t    tree t = make_ssa_name (TREE_TYPE (aligned_addr));\n+\t    gimple *g = gimple_build_assign (t, aligned_addr);\n+\t    gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+\t    aligned_addr = t;\n+\t  }\n+\t/* The desired gimple result should be similar to:\n+\t   MEM[(__vector floatD.1407 *)_1] = vf1D.2697;  */\n+\tgimple *g\n+\t  = gimple_build_assign (build2 (MEM_REF, arg0_type, aligned_addr,\n+\t\t\t\t\t build_int_cst (arg2_type, 0)), arg0);\n+\tgimple_set_location (g, loc);\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n+\n+    /* unaligned Vector loads.  */\n+    case RS6000_BIF_LXVW4X_V16QI:\n+    case RS6000_BIF_LXVW4X_V8HI:\n+    case RS6000_BIF_LXVW4X_V4SF:\n+    case RS6000_BIF_LXVW4X_V4SI:\n+    case RS6000_BIF_LXVD2X_V2DF:\n+    case RS6000_BIF_LXVD2X_V2DI:\n+      {\n+\targ0 = gimple_call_arg (stmt, 0);  // offset\n+\targ1 = gimple_call_arg (stmt, 1);  // address\n+\tlhs = gimple_call_lhs (stmt);\n+\tlocation_t loc = gimple_location (stmt);\n+\t/* Since arg1 may be cast to a different type, just use ptr_type_node\n+\t   here instead of trying to enforce TBAA on pointer types.  */\n+\ttree arg1_type = ptr_type_node;\n+\ttree lhs_type = TREE_TYPE (lhs);\n+\t/* In GIMPLE the type of the MEM_REF specifies the alignment.  The\n+\t  required alignment (power) is 4 bytes regardless of data type.  */\n+\ttree align_ltype = build_aligned_type (lhs_type, 4);\n+\t/* POINTER_PLUS_EXPR wants the offset to be of type 'sizetype'.  Create\n+\t   the tree using the value from arg0.  The resulting type will match\n+\t   the type of arg1.  */\n+\tgimple_seq stmts = NULL;\n+\ttree temp_offset = gimple_convert (&stmts, loc, sizetype, arg0);\n+\ttree temp_addr = gimple_build (&stmts, loc, POINTER_PLUS_EXPR,\n+\t\t\t\t       arg1_type, arg1, temp_offset);\n+\tgsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\tif (!is_gimple_mem_ref_addr (temp_addr))\n+\t  {\n+\t    tree t = make_ssa_name (TREE_TYPE (temp_addr));\n+\t    gimple *g = gimple_build_assign (t, temp_addr);\n+\t    gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+\t    temp_addr = t;\n+\t  }\n+\t/* Use the build2 helper to set up the mem_ref.  The MEM_REF could also\n+\t   take an offset, but since we've already incorporated the offset\n+\t   above, here we just pass in a zero.  */\n+\tgimple *g;\n+\tg = gimple_build_assign (lhs, build2 (MEM_REF, align_ltype, temp_addr,\n+\t\t\t\t\t      build_int_cst (arg1_type, 0)));\n+\tgimple_set_location (g, loc);\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n+\n+    /* unaligned Vector stores.  */\n+    case RS6000_BIF_STXVW4X_V16QI:\n+    case RS6000_BIF_STXVW4X_V8HI:\n+    case RS6000_BIF_STXVW4X_V4SF:\n+    case RS6000_BIF_STXVW4X_V4SI:\n+    case RS6000_BIF_STXVD2X_V2DF:\n+    case RS6000_BIF_STXVD2X_V2DI:\n+      {\n+\targ0 = gimple_call_arg (stmt, 0); /* Value to be stored.  */\n+\targ1 = gimple_call_arg (stmt, 1); /* Offset.  */\n+\ttree arg2 = gimple_call_arg (stmt, 2); /* Store-to address.  */\n+\tlocation_t loc = gimple_location (stmt);\n+\ttree arg0_type = TREE_TYPE (arg0);\n+\t/* Use ptr_type_node (no TBAA) for the arg2_type.  */\n+\ttree arg2_type = ptr_type_node;\n+\t/* In GIMPLE the type of the MEM_REF specifies the alignment.  The\n+\t   required alignment (power) is 4 bytes regardless of data type.  */\n+\ttree align_stype = build_aligned_type (arg0_type, 4);\n+\t/* POINTER_PLUS_EXPR wants the offset to be of type 'sizetype'.  Create\n+\t   the tree using the value from arg1.  */\n+\tgimple_seq stmts = NULL;\n+\ttree temp_offset = gimple_convert (&stmts, loc, sizetype, arg1);\n+\ttree temp_addr = gimple_build (&stmts, loc, POINTER_PLUS_EXPR,\n+\t\t\t\t       arg2_type, arg2, temp_offset);\n+\tgsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\tif (!is_gimple_mem_ref_addr (temp_addr))\n+\t  {\n+\t    tree t = make_ssa_name (TREE_TYPE (temp_addr));\n+\t    gimple *g = gimple_build_assign (t, temp_addr);\n+\t    gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+\t    temp_addr = t;\n+\t  }\n+\tgimple *g;\n+\tg = gimple_build_assign (build2 (MEM_REF, align_stype, temp_addr,\n+\t\t\t\t\t build_int_cst (arg2_type, 0)), arg0);\n+\tgimple_set_location (g, loc);\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n+\n+    /* Vector Fused multiply-add (fma).  */\n+    case RS6000_BIF_VMADDFP:\n+    case RS6000_BIF_XVMADDDP:\n+    case RS6000_BIF_XVMADDSP:\n+    case RS6000_BIF_VMLADDUHM:\n+      {\n+\targ0 = gimple_call_arg (stmt, 0);\n+\targ1 = gimple_call_arg (stmt, 1);\n+\ttree arg2 = gimple_call_arg (stmt, 2);\n+\tlhs = gimple_call_lhs (stmt);\n+\tgcall *g = gimple_build_call_internal (IFN_FMA, 3, arg0, arg1, arg2);\n+\tgimple_call_set_lhs (g, lhs);\n+\tgimple_call_set_nothrow (g, true);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n+\n+    /* Vector compares; EQ, NE, GE, GT, LE.  */\n+    case RS6000_BIF_VCMPEQUB:\n+    case RS6000_BIF_VCMPEQUH:\n+    case RS6000_BIF_VCMPEQUW:\n+    case RS6000_BIF_VCMPEQUD:\n+    /* We deliberately omit RS6000_BIF_VCMPEQUT for now, because gimple\n+       folding produces worse code for 128-bit compares.  */\n+      fold_compare_helper (gsi, EQ_EXPR, stmt);\n+      return true;\n+\n+    case RS6000_BIF_VCMPNEB:\n+    case RS6000_BIF_VCMPNEH:\n+    case RS6000_BIF_VCMPNEW:\n+    /* We deliberately omit RS6000_BIF_VCMPNET for now, because gimple\n+       folding produces worse code for 128-bit compares.  */\n+      fold_compare_helper (gsi, NE_EXPR, stmt);\n+      return true;\n+\n+    case RS6000_BIF_CMPGE_16QI:\n+    case RS6000_BIF_CMPGE_U16QI:\n+    case RS6000_BIF_CMPGE_8HI:\n+    case RS6000_BIF_CMPGE_U8HI:\n+    case RS6000_BIF_CMPGE_4SI:\n+    case RS6000_BIF_CMPGE_U4SI:\n+    case RS6000_BIF_CMPGE_2DI:\n+    case RS6000_BIF_CMPGE_U2DI:\n+    /* We deliberately omit RS6000_BIF_CMPGE_1TI and RS6000_BIF_CMPGE_U1TI\n+       for now, because gimple folding produces worse code for 128-bit\n+       compares.  */\n+      fold_compare_helper (gsi, GE_EXPR, stmt);\n+      return true;\n+\n+    case RS6000_BIF_VCMPGTSB:\n+    case RS6000_BIF_VCMPGTUB:\n+    case RS6000_BIF_VCMPGTSH:\n+    case RS6000_BIF_VCMPGTUH:\n+    case RS6000_BIF_VCMPGTSW:\n+    case RS6000_BIF_VCMPGTUW:\n+    case RS6000_BIF_VCMPGTUD:\n+    case RS6000_BIF_VCMPGTSD:\n+    /* We deliberately omit RS6000_BIF_VCMPGTUT and RS6000_BIF_VCMPGTST\n+       for now, because gimple folding produces worse code for 128-bit\n+       compares.  */\n+      fold_compare_helper (gsi, GT_EXPR, stmt);\n+      return true;\n+\n+    case RS6000_BIF_CMPLE_16QI:\n+    case RS6000_BIF_CMPLE_U16QI:\n+    case RS6000_BIF_CMPLE_8HI:\n+    case RS6000_BIF_CMPLE_U8HI:\n+    case RS6000_BIF_CMPLE_4SI:\n+    case RS6000_BIF_CMPLE_U4SI:\n+    case RS6000_BIF_CMPLE_2DI:\n+    case RS6000_BIF_CMPLE_U2DI:\n+    /* We deliberately omit RS6000_BIF_CMPLE_1TI and RS6000_BIF_CMPLE_U1TI\n+       for now, because gimple folding produces worse code for 128-bit\n+       compares.  */\n+      fold_compare_helper (gsi, LE_EXPR, stmt);\n+      return true;\n+\n+    /* flavors of vec_splat_[us]{8,16,32}.  */\n+    case RS6000_BIF_VSPLTISB:\n+    case RS6000_BIF_VSPLTISH:\n+    case RS6000_BIF_VSPLTISW:\n+      {\n+\targ0 = gimple_call_arg (stmt, 0);\n+\tlhs = gimple_call_lhs (stmt);\n+\n+\t/* Only fold the vec_splat_*() if the lower bits of arg 0 is a\n+\t   5-bit signed constant in range -16 to +15.  */\n+\tif (TREE_CODE (arg0) != INTEGER_CST\n+\t    || !IN_RANGE (TREE_INT_CST_LOW (arg0), -16, 15))\n+\t  return false;\n+\tgimple_seq stmts = NULL;\n+\tlocation_t loc = gimple_location (stmt);\n+\ttree splat_value = gimple_convert (&stmts, loc,\n+\t\t\t\t\t   TREE_TYPE (TREE_TYPE (lhs)), arg0);\n+\tgsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\ttree splat_tree = build_vector_from_val (TREE_TYPE (lhs), splat_value);\n+\tg = gimple_build_assign (lhs, splat_tree);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n+\n+    /* Flavors of vec_splat.  */\n+    /* a = vec_splat (b, 0x3) becomes a = { b[3],b[3],b[3],...};  */\n+    case RS6000_BIF_VSPLTB:\n+    case RS6000_BIF_VSPLTH:\n+    case RS6000_BIF_VSPLTW:\n+    case RS6000_BIF_XXSPLTD_V2DI:\n+    case RS6000_BIF_XXSPLTD_V2DF:\n+      {\n+\targ0 = gimple_call_arg (stmt, 0); /* input vector.  */\n+\targ1 = gimple_call_arg (stmt, 1); /* index into arg0.  */\n+\t/* Only fold the vec_splat_*() if arg1 is both a constant value and\n+\t   is a valid index into the arg0 vector.  */\n+\tunsigned int n_elts = VECTOR_CST_NELTS (arg0);\n+\tif (TREE_CODE (arg1) != INTEGER_CST\n+\t    || TREE_INT_CST_LOW (arg1) > (n_elts -1))\n+\t  return false;\n+\tlhs = gimple_call_lhs (stmt);\n+\ttree lhs_type = TREE_TYPE (lhs);\n+\ttree arg0_type = TREE_TYPE (arg0);\n+\ttree splat;\n+\tif (TREE_CODE (arg0) == VECTOR_CST)\n+\t  splat = VECTOR_CST_ELT (arg0, TREE_INT_CST_LOW (arg1));\n+\telse\n+\t  {\n+\t    /* Determine (in bits) the length and start location of the\n+\t       splat value for a call to the tree_vec_extract helper.  */\n+\t    int splat_elem_size = TREE_INT_CST_LOW (size_in_bytes (arg0_type))\n+\t\t\t\t  * BITS_PER_UNIT / n_elts;\n+\t    int splat_start_bit = TREE_INT_CST_LOW (arg1) * splat_elem_size;\n+\t    tree len = build_int_cst (bitsizetype, splat_elem_size);\n+\t    tree start = build_int_cst (bitsizetype, splat_start_bit);\n+\t    splat = tree_vec_extract (gsi, TREE_TYPE (lhs_type), arg0,\n+\t\t\t\t      len, start);\n+\t  }\n+\t/* And finally, build the new vector.  */\n+\ttree splat_tree = build_vector_from_val (lhs_type, splat);\n+\tg = gimple_build_assign (lhs, splat_tree);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n+\n+    /* vec_mergel (integrals).  */\n+    case RS6000_BIF_VMRGLH:\n+    case RS6000_BIF_VMRGLW:\n+    case RS6000_BIF_XXMRGLW_4SI:\n+    case RS6000_BIF_VMRGLB:\n+    case RS6000_BIF_VEC_MERGEL_V2DI:\n+    case RS6000_BIF_XXMRGLW_4SF:\n+    case RS6000_BIF_VEC_MERGEL_V2DF:\n+      fold_mergehl_helper (gsi, stmt, 1);\n+      return true;\n+    /* vec_mergeh (integrals).  */\n+    case RS6000_BIF_VMRGHH:\n+    case RS6000_BIF_VMRGHW:\n+    case RS6000_BIF_XXMRGHW_4SI:\n+    case RS6000_BIF_VMRGHB:\n+    case RS6000_BIF_VEC_MERGEH_V2DI:\n+    case RS6000_BIF_XXMRGHW_4SF:\n+    case RS6000_BIF_VEC_MERGEH_V2DF:\n+      fold_mergehl_helper (gsi, stmt, 0);\n+      return true;\n+\n+    /* Flavors of vec_mergee.  */\n+    case RS6000_BIF_VMRGEW_V4SI:\n+    case RS6000_BIF_VMRGEW_V2DI:\n+    case RS6000_BIF_VMRGEW_V4SF:\n+    case RS6000_BIF_VMRGEW_V2DF:\n+      fold_mergeeo_helper (gsi, stmt, 0);\n+      return true;\n+    /* Flavors of vec_mergeo.  */\n+    case RS6000_BIF_VMRGOW_V4SI:\n+    case RS6000_BIF_VMRGOW_V2DI:\n+    case RS6000_BIF_VMRGOW_V4SF:\n+    case RS6000_BIF_VMRGOW_V2DF:\n+      fold_mergeeo_helper (gsi, stmt, 1);\n+      return true;\n+\n+    /* d = vec_pack (a, b) */\n+    case RS6000_BIF_VPKUDUM:\n+    case RS6000_BIF_VPKUHUM:\n+    case RS6000_BIF_VPKUWUM:\n+      {\n+\targ0 = gimple_call_arg (stmt, 0);\n+\targ1 = gimple_call_arg (stmt, 1);\n+\tlhs = gimple_call_lhs (stmt);\n+\tgimple *g = gimple_build_assign (lhs, VEC_PACK_TRUNC_EXPR, arg0, arg1);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n+\n+    /* d = vec_unpackh (a) */\n+    /* Note that the UNPACK_{HI,LO}_EXPR used in the gimple_build_assign call\n+       in this code is sensitive to endian-ness, and needs to be inverted to\n+       handle both LE and BE targets.  */\n+    case RS6000_BIF_VUPKHSB:\n+    case RS6000_BIF_VUPKHSH:\n+    case RS6000_BIF_VUPKHSW:\n+      {\n+\targ0 = gimple_call_arg (stmt, 0);\n+\tlhs = gimple_call_lhs (stmt);\n+\tif (BYTES_BIG_ENDIAN)\n+\t  g = gimple_build_assign (lhs, VEC_UNPACK_HI_EXPR, arg0);\n+\telse\n+\t  g = gimple_build_assign (lhs, VEC_UNPACK_LO_EXPR, arg0);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n+    /* d = vec_unpackl (a) */\n+    case RS6000_BIF_VUPKLSB:\n+    case RS6000_BIF_VUPKLSH:\n+    case RS6000_BIF_VUPKLSW:\n+      {\n+\targ0 = gimple_call_arg (stmt, 0);\n+\tlhs = gimple_call_lhs (stmt);\n+\tif (BYTES_BIG_ENDIAN)\n+\t  g = gimple_build_assign (lhs, VEC_UNPACK_LO_EXPR, arg0);\n+\telse\n+\t  g = gimple_build_assign (lhs, VEC_UNPACK_HI_EXPR, arg0);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n+    /* There is no gimple type corresponding with pixel, so just return.  */\n+    case RS6000_BIF_VUPKHPX:\n+    case RS6000_BIF_VUPKLPX:\n+      return false;\n+\n+    /* vec_perm.  */\n+    case RS6000_BIF_VPERM_16QI:\n+    case RS6000_BIF_VPERM_8HI:\n+    case RS6000_BIF_VPERM_4SI:\n+    case RS6000_BIF_VPERM_2DI:\n+    case RS6000_BIF_VPERM_4SF:\n+    case RS6000_BIF_VPERM_2DF:\n+    case RS6000_BIF_VPERM_16QI_UNS:\n+    case RS6000_BIF_VPERM_8HI_UNS:\n+    case RS6000_BIF_VPERM_4SI_UNS:\n+    case RS6000_BIF_VPERM_2DI_UNS:\n+      {\n+\targ0 = gimple_call_arg (stmt, 0);\n+\targ1 = gimple_call_arg (stmt, 1);\n+\ttree permute = gimple_call_arg (stmt, 2);\n+\tlhs = gimple_call_lhs (stmt);\n+\tlocation_t loc = gimple_location (stmt);\n+\tgimple_seq stmts = NULL;\n+\t// convert arg0 and arg1 to match the type of the permute\n+\t// for the VEC_PERM_EXPR operation.\n+\ttree permute_type = (TREE_TYPE (permute));\n+\ttree arg0_ptype = gimple_build (&stmts, loc, VIEW_CONVERT_EXPR,\n+\t\t\t\t\tpermute_type, arg0);\n+\ttree arg1_ptype = gimple_build (&stmts, loc, VIEW_CONVERT_EXPR,\n+\t\t\t\t\tpermute_type, arg1);\n+\ttree lhs_ptype = gimple_build (&stmts, loc, VEC_PERM_EXPR,\n+\t\t\t\t      permute_type, arg0_ptype, arg1_ptype,\n+\t\t\t\t      permute);\n+\t// Convert the result back to the desired lhs type upon completion.\n+\ttree temp = gimple_build (&stmts, loc, VIEW_CONVERT_EXPR,\n+\t\t\t\t  TREE_TYPE (lhs), lhs_ptype);\n+\tgsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\tg = gimple_build_assign (lhs, temp);\n+\tgimple_set_location (g, loc);\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n+\n+    default:\n+      if (TARGET_DEBUG_BUILTIN)\n+\tfprintf (stderr, \"gimple builtin intrinsic not matched:%d %s %s\\n\",\n+\t\t fn_code, fn_name1, fn_name2);\n+      break;\n+    }\n+\n+  return false;\n+}\n+\n /* Expand an expression EXP that calls a built-in function,\n    with result going to TARGET if that's convenient\n    (and in mode MODE if that's convenient)."}]}