{"sha": "749aa96dabbb0fef0d81b382a49849186f907d95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ5YWE5NmRhYmJiMGZlZjBkODFiMzgyYTQ5ODQ5MTg2ZjkwN2Q5NQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2010-05-19T11:49:36Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2010-05-19T11:49:36Z"}, "message": "ipa-prop.c (ipa_print_node_jump_functions): Print jump functions also for indirect edges.\n\n2010-05-19  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.c (ipa_print_node_jump_functions): Print jump functions\n\talso for indirect edges.  Actual printing moved...\n\t(ipa_print_node_jump_functions_for_edge): ...here.\n\t(ipa_compute_jump_functions): Renamed to\n\tipa_compute_jump_functions_for_edge and made static.\n\t(ipa_compute_jump_functions): New function.\n\t(make_edge_direct_to_target): Check if the number of arguments on\n\tthe newly direct edge is the same as the number of parametrs of\n\tthe callee.\n\t* ipa-cp.c (ipcp_init_stage): Most functionality moved to new\n\tipa_compute_jump_functions.  Call ipa_analyze_params_uses.\n\t* ipa-inline.c (inline_indirect_intraprocedural_analysis): Call\n\tanalysis functions unconditionally, call the new\n\tipa_analyze_params_uses on the node instead of every edge.\n\n\t* testsuite/g++.dg/ipa/ivinline-8.C: New test.\n\t* testsuite/gcc.dg/ipa/iinline-2.c: New test.\n\nFrom-SVN: r159559", "tree": {"sha": "0bf93b58c18ebebe3ec5631fc8ca7271c6f036c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bf93b58c18ebebe3ec5631fc8ca7271c6f036c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/749aa96dabbb0fef0d81b382a49849186f907d95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/749aa96dabbb0fef0d81b382a49849186f907d95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/749aa96dabbb0fef0d81b382a49849186f907d95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/749aa96dabbb0fef0d81b382a49849186f907d95/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c9018c71d3cbb2929ab53fa7a762ba43934785f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9018c71d3cbb2929ab53fa7a762ba43934785f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9018c71d3cbb2929ab53fa7a762ba43934785f5"}], "stats": {"total": 366, "additions": 273, "deletions": 93}, "files": [{"sha": "c725ab9bc9b10d4f844576319ebeca3adcce73ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749aa96dabbb0fef0d81b382a49849186f907d95/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749aa96dabbb0fef0d81b382a49849186f907d95/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=749aa96dabbb0fef0d81b382a49849186f907d95", "patch": "@@ -1,3 +1,20 @@\n+2010-05-19  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.c (ipa_print_node_jump_functions): Print jump functions\n+\talso for indirect edges.  Actual printing moved...\n+\t(ipa_print_node_jump_functions_for_edge): ...here.\n+\t(ipa_compute_jump_functions): Renamed to\n+\tipa_compute_jump_functions_for_edge and made static.\n+\t(ipa_compute_jump_functions): New function.\n+\t(make_edge_direct_to_target): Check if the number of arguments on\n+\tthe newly direct edge is the same as the number of parametrs of\n+\tthe callee.\n+\t* ipa-cp.c (ipcp_init_stage): Most functionality moved to new\n+\tipa_compute_jump_functions.  Call ipa_analyze_params_uses.\n+\t* ipa-inline.c (inline_indirect_intraprocedural_analysis): Call\n+\tanalysis functions unconditionally, call the new\n+\tipa_analyze_params_uses on the node instead of every edge.\n+\n 2010-05-19  Christian Borntraeger  <borntraeger@de.ibm.com>\n \n         * tree-ssa-loop-prefetch.c (mem_ref_group, ar_data): Change step"}, {"sha": "a1bfe0e87013e07f5780801886b2503a5e344bcb", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749aa96dabbb0fef0d81b382a49849186f907d95/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749aa96dabbb0fef0d81b382a49849186f907d95/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=749aa96dabbb0fef0d81b382a49849186f907d95", "patch": "@@ -614,7 +614,6 @@ static void\n ipcp_init_stage (void)\n {\n   struct cgraph_node *node;\n-  struct cgraph_edge *cs;\n \n   for (node = cgraph_nodes; node; node = node->next)\n     if (node->analyzed)\n@@ -623,19 +622,10 @@ ipcp_init_stage (void)\n     {\n       if (!node->analyzed)\n \tcontinue;\n+\n+      ipa_analyze_params_uses (node);\n       /* building jump functions  */\n-      for (cs = node->callees; cs; cs = cs->next_callee)\n-\t{\n-\t  /* We do not need to bother analyzing calls to unknown\n-\t     functions unless they may become known during lto/whopr.  */\n-\t  if (!cs->callee->analyzed && !flag_lto && !flag_whopr)\n-\t    continue;\n-\t  ipa_count_arguments (cs);\n-\t  if (ipa_get_cs_argument_count (IPA_EDGE_REF (cs))\n-\t      != ipa_get_param_count (IPA_NODE_REF (cs->callee)))\n-\t    ipa_set_called_with_variable_arg (IPA_NODE_REF (cs->callee));\n-\t  ipa_compute_jump_functions (cs);\n-\t}\n+      ipa_compute_jump_functions (node);\n     }\n }\n "}, {"sha": "12757f7a2a3940012f272a38383cbed7c898b46d", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749aa96dabbb0fef0d81b382a49849186f907d95/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749aa96dabbb0fef0d81b382a49849186f907d95/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=749aa96dabbb0fef0d81b382a49849186f907d95", "patch": "@@ -1971,21 +1971,10 @@ struct gimple_opt_pass pass_inline_parameters =\n static void\n inline_indirect_intraprocedural_analysis (struct cgraph_node *node)\n {\n-  struct cgraph_edge *cs;\n-\n-  if (!flag_ipa_cp)\n-    {\n-      ipa_initialize_node_params (node);\n-      ipa_detect_param_modifications (node);\n-    }\n+  ipa_initialize_node_params (node);\n+  ipa_detect_param_modifications (node);\n   ipa_analyze_params_uses (node);\n-\n-  if (!flag_ipa_cp)\n-    for (cs = node->callees; cs; cs = cs->next_callee)\n-      {\n-\tipa_count_arguments (cs);\n-\tipa_compute_jump_functions (cs);\n-      }\n+  ipa_compute_jump_functions (node);\n \n   if (dump_file)\n     {"}, {"sha": "d977242b5f0d2d32b625aa717115ae4b63f5e013", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 126, "deletions": 65, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749aa96dabbb0fef0d81b382a49849186f907d95/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749aa96dabbb0fef0d81b382a49849186f907d95/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=749aa96dabbb0fef0d81b382a49849186f907d95", "patch": "@@ -304,86 +304,114 @@ ipa_count_arguments (struct cgraph_edge *cs)\n   ipa_set_cs_argument_count (IPA_EDGE_REF (cs), arg_num);\n }\n \n+/* Print the jump functions associated with call graph edge CS to file F.  */\n+\n+static void\n+ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n+{\n+  int i, count;\n+\n+  count = ipa_get_cs_argument_count (IPA_EDGE_REF (cs));\n+  for (i = 0; i < count; i++)\n+    {\n+      struct ipa_jump_func *jump_func;\n+      enum jump_func_type type;\n+\n+      jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n+      type = jump_func->type;\n+\n+      fprintf (f, \"       param %d: \", i);\n+      if (type == IPA_JF_UNKNOWN)\n+\tfprintf (f, \"UNKNOWN\\n\");\n+      else if (type == IPA_JF_KNOWN_TYPE)\n+\t{\n+\t  tree binfo_type = TREE_TYPE (jump_func->value.base_binfo);\n+\t  fprintf (f, \"KNOWN TYPE, type in binfo is: \");\n+\t  print_generic_expr (f, binfo_type, 0);\n+\t  fprintf (f, \" (%u)\\n\", TYPE_UID (binfo_type));\n+\t}\n+      else if (type == IPA_JF_CONST)\n+\t{\n+\t  tree val = jump_func->value.constant;\n+\t  fprintf (f, \"CONST: \");\n+\t  print_generic_expr (f, val, 0);\n+\t  if (TREE_CODE (val) == ADDR_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (val, 0)) == CONST_DECL)\n+\t    {\n+\t      fprintf (f, \" -> \");\n+\t      print_generic_expr (f, DECL_INITIAL (TREE_OPERAND (val, 0)),\n+\t\t\t\t  0);\n+\t    }\n+\t  fprintf (f, \"\\n\");\n+\t}\n+      else if (type == IPA_JF_CONST_MEMBER_PTR)\n+\t{\n+\t  fprintf (f, \"CONST MEMBER PTR: \");\n+\t  print_generic_expr (f, jump_func->value.member_cst.pfn, 0);\n+\t  fprintf (f, \", \");\n+\t  print_generic_expr (f, jump_func->value.member_cst.delta, 0);\n+\t  fprintf (f, \"\\n\");\n+\t}\n+      else if (type == IPA_JF_PASS_THROUGH)\n+\t{\n+\t  fprintf (f, \"PASS THROUGH: \");\n+\t  fprintf (f, \"%d, op %s \",\n+\t\t   jump_func->value.pass_through.formal_id,\n+\t\t   tree_code_name[(int)\n+\t\t\t\t  jump_func->value.pass_through.operation]);\n+\t  if (jump_func->value.pass_through.operation != NOP_EXPR)\n+\t    print_generic_expr (dump_file,\n+\t\t\t\tjump_func->value.pass_through.operand, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      else if (type == IPA_JF_ANCESTOR)\n+\t{\n+\t  fprintf (f, \"ANCESTOR: \");\n+\t  fprintf (f, \"%d, offset \"HOST_WIDE_INT_PRINT_DEC\", \",\n+\t\t   jump_func->value.ancestor.formal_id,\n+\t\t   jump_func->value.ancestor.offset);\n+\t  print_generic_expr (f, jump_func->value.ancestor.type, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+    }\n+}\n+\n+\n /* Print the jump functions of all arguments on all call graph edges going from\n    NODE to file F.  */\n \n void\n ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node)\n {\n-  int i, count;\n   struct cgraph_edge *cs;\n-  struct ipa_jump_func *jump_func;\n-  enum jump_func_type type;\n+  int i;\n \n   fprintf (f, \"  Jump functions of caller  %s:\\n\", cgraph_node_name (node));\n   for (cs = node->callees; cs; cs = cs->next_callee)\n     {\n       if (!ipa_edge_args_info_available_for_edge_p (cs))\n \tcontinue;\n \n-      fprintf (f, \"    callsite  %s \", cgraph_node_name (node));\n-      fprintf (f, \"-> %s :: \\n\", cgraph_node_name (cs->callee));\n+      fprintf (f, \"    callsite  %s/%i -> %s/%i : \\n\",\n+\t       cgraph_node_name (node), node->uid,\n+\t       cgraph_node_name (cs->callee), cs->callee->uid);\n+      ipa_print_node_jump_functions_for_edge (f, cs);\n+    }\n \n-      count = ipa_get_cs_argument_count (IPA_EDGE_REF (cs));\n-      for (i = 0; i < count; i++)\n-\t{\n-\t  jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n-\t  type = jump_func->type;\n+  for (cs = node->indirect_calls, i = 0; cs; cs = cs->next_callee, i++)\n+    {\n+      if (!ipa_edge_args_info_available_for_edge_p (cs))\n+\tcontinue;\n \n-\t  fprintf (f, \"       param %d: \", i);\n-\t  if (type == IPA_JF_UNKNOWN)\n-\t    fprintf (f, \"UNKNOWN\\n\");\n-\t  else if (type == IPA_JF_KNOWN_TYPE)\n-\t    {\n-\t      tree binfo_type = TREE_TYPE (jump_func->value.base_binfo);\n-\t      fprintf (f, \"KNOWN TYPE, type in binfo is: \");\n-\t      print_generic_expr (f, binfo_type, 0);\n-\t      fprintf (f, \" (%u)\\n\", TYPE_UID (binfo_type));\n-\t    }\n-\t  else if (type == IPA_JF_CONST)\n- \t    {\n-\t      tree val = jump_func->value.constant;\n-\t      fprintf (f, \"CONST: \");\n-\t      print_generic_expr (f, val, 0);\n-\t      if (TREE_CODE (val) == ADDR_EXPR\n-\t\t  && TREE_CODE (TREE_OPERAND (val, 0)) == CONST_DECL)\n-\t\t{\n-\t\t  fprintf (f, \" -> \");\n-\t\t  print_generic_expr (f, DECL_INITIAL (TREE_OPERAND (val, 0)),\n-\t\t\t\t\t\t       0);\n-\t\t}\n-\t      fprintf (f, \"\\n\");\n-\t    }\n-\t  else if (type == IPA_JF_CONST_MEMBER_PTR)\n-\t    {\n-\t      fprintf (f, \"CONST MEMBER PTR: \");\n-\t      print_generic_expr (f, jump_func->value.member_cst.pfn, 0);\n-\t      fprintf (f, \", \");\n-\t      print_generic_expr (f, jump_func->value.member_cst.delta, 0);\n-\t      fprintf (f, \"\\n\");\n-\t    }\n-\t  else if (type == IPA_JF_PASS_THROUGH)\n- \t    {\n-\t      fprintf (f, \"PASS THROUGH: \");\n-\t      fprintf (f, \"%d, op %s \",\n-\t\t       jump_func->value.pass_through.formal_id,\n-\t\t       tree_code_name[(int)\n-\t\t\t\t      jump_func->value.pass_through.operation]);\n-\t      if (jump_func->value.pass_through.operation != NOP_EXPR)\n-\t\tprint_generic_expr (dump_file,\n-\t\t\t\t    jump_func->value.pass_through.operand, 0);\n-\t      fprintf (dump_file, \"\\n\");\n- \t    }\n-\t  else if (type == IPA_JF_ANCESTOR)\n-\t    {\n-\t      fprintf (f, \"ANCESTOR: \");\n-\t      fprintf (f, \"%d, offset \"HOST_WIDE_INT_PRINT_DEC\", \",\n-\t\t       jump_func->value.ancestor.formal_id,\n-\t\t       jump_func->value.ancestor.offset);\n-\t      print_generic_expr (f, jump_func->value.ancestor.type, 0);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n+      if (cs->call_stmt)\n+\t{\n+\t  fprintf (f, \"    indirect callsite %d for stmt \", i);\n+\t  print_gimple_stmt (f, cs->call_stmt, 0, TDF_SLIM);\n \t}\n+      else\n+\tfprintf (f, \"    indirect callsite %d :\\n\", i);\n+      ipa_print_node_jump_functions_for_edge (f, cs);\n+\n     }\n }\n \n@@ -852,8 +880,8 @@ compute_cst_member_ptr_arguments (struct ipa_jump_func *functions,\n    information in the jump_functions array in the ipa_edge_args corresponding\n    to this callsite.  */\n \n-void\n-ipa_compute_jump_functions (struct cgraph_edge *cs)\n+static void\n+ipa_compute_jump_functions_for_edge (struct cgraph_edge *cs)\n {\n   struct ipa_node_params *info = IPA_NODE_REF (cs->caller);\n   struct ipa_edge_args *arguments = IPA_EDGE_REF (cs);\n@@ -880,6 +908,34 @@ ipa_compute_jump_functions (struct cgraph_edge *cs)\n   compute_cst_member_ptr_arguments (arguments->jump_functions, call);\n }\n \n+/* Compute jump functions for all edges - both direct and indirect - outgoing\n+   from NODE.  Also count the actual arguments in the process.  */\n+\n+void\n+ipa_compute_jump_functions (struct cgraph_node *node)\n+{\n+  struct cgraph_edge *cs;\n+\n+  for (cs = node->callees; cs; cs = cs->next_callee)\n+    {\n+      /* We do not need to bother analyzing calls to unknown\n+\t functions unless they may become known during lto/whopr.  */\n+      if (!cs->callee->analyzed && !flag_lto && !flag_whopr)\n+\tcontinue;\n+      ipa_count_arguments (cs);\n+      if (ipa_get_cs_argument_count (IPA_EDGE_REF (cs))\n+\t  != ipa_get_param_count (IPA_NODE_REF (cs->callee)))\n+\tipa_set_called_with_variable_arg (IPA_NODE_REF (cs->callee));\n+      ipa_compute_jump_functions_for_edge (cs);\n+    }\n+\n+  for (cs = node->indirect_calls; cs; cs = cs->next_callee)\n+    {\n+      ipa_count_arguments (cs);\n+      ipa_compute_jump_functions_for_edge (cs);\n+    }\n+}\n+\n /* If RHS looks like a rhs of a statement loading pfn from a member\n    pointer formal parameter, return the parameter, otherwise return\n    NULL.  If USE_DELTA, then we look for a use of the delta field\n@@ -1345,6 +1401,11 @@ make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n       else\n \tfprintf (dump_file, \"with uid %i\\n\", ie->lto_stmt_uid);\n     }\n+\n+  if (ipa_get_cs_argument_count (IPA_EDGE_REF (ie))\n+      != ipa_get_param_count (IPA_NODE_REF (callee)))\n+    ipa_set_called_with_variable_arg (IPA_NODE_REF (callee));\n+\n   return ie;\n }\n "}, {"sha": "110044e4da4568c4bcdfe2431712dc9b02a2195c", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749aa96dabbb0fef0d81b382a49849186f907d95/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749aa96dabbb0fef0d81b382a49849186f907d95/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=749aa96dabbb0fef0d81b382a49849186f907d95", "patch": "@@ -413,7 +413,7 @@ ipa_push_func_to_list (struct ipa_func_list **wl, struct cgraph_node *node)\n }\n \n /* Callsite related calculations.  */\n-void ipa_compute_jump_functions (struct cgraph_edge *);\n+void ipa_compute_jump_functions (struct cgraph_node *);\n void ipa_count_arguments (struct cgraph_edge *);\n \n /* Function formal parameters related computations.  */"}, {"sha": "237b3c18be12e89bcee3dd9b8e312b4d5c7f8b1f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749aa96dabbb0fef0d81b382a49849186f907d95/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749aa96dabbb0fef0d81b382a49849186f907d95/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=749aa96dabbb0fef0d81b382a49849186f907d95", "patch": "@@ -1,3 +1,8 @@\n+2010-05-19  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* g++.dg/ipa/ivinline-8.C: New test.\n+\t* gcc.dg/ipa/iinline-2.c: Likewise.\n+\n 2010-05-19  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR fortran/34505"}, {"sha": "3bdf4c15b2d26c04c32ea75d425ad5314097d5df", "filename": "gcc/testsuite/g++.dg/ipa/ivinline-8.C", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749aa96dabbb0fef0d81b382a49849186f907d95/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749aa96dabbb0fef0d81b382a49849186f907d95/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-8.C?ref=749aa96dabbb0fef0d81b382a49849186f907d95", "patch": "@@ -0,0 +1,77 @@\n+/* Verify that virtual calls are inlined (ithout early inlining) even\n+   when their caller is itself indirectly inlined.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fdump-ipa-inline -fno-early-inlining -fno-ipa-cp\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class A\n+{\n+public:\n+  int data;\n+  virtual int bar (int i);\n+  virtual int foo (int i);\n+};\n+\n+class B : public A\n+{\n+public:\n+  virtual int bar (int i);\n+  virtual int foo (int i);\n+};\n+\n+class C : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+int A::bar (int i)\n+{\n+  return i + 100 * i;\n+}\n+\n+int A::foo (int i)\n+{\n+  return bar (i) + 1;\n+}\n+\n+int B::bar (int i)\n+{\n+  return i + 100 * (i + 2);\n+}\n+\n+int B::foo (int i)\n+{\n+  return bar (i) + 2;\n+}\n+\n+int C::foo (int i)\n+{\n+  return i + 3;\n+}\n+\n+int middleman (class A *obj, int i)\n+{\n+  return obj->foo (i);\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  class B b;\n+  int i;\n+\n+  for (i = 0; i < get_input (); i++)\n+    if (middleman (&b, get_input ()) != 303)\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"B::foo\\[^\\\\n\\]*inline copy in int main\" \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump \"B::bar\\[^\\\\n\\]*inline copy in int main\" \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "117818d164597cc64ba7f6d59dd4aac1caffdb9a", "filename": "gcc/testsuite/gcc.dg/ipa/iinline-2.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749aa96dabbb0fef0d81b382a49849186f907d95/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749aa96dabbb0fef0d81b382a49849186f907d95/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-2.c?ref=749aa96dabbb0fef0d81b382a49849186f907d95", "patch": "@@ -0,0 +1,41 @@\n+/* Verify that simple indirect calls are inlined even without early\n+   inlining..  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -c -fdump-ipa-inline -fno-early-inlining -fno-ipa-cp\"  } */\n+\n+extern void non_existent(int);\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+static void hooray ()\n+{\n+  non_existent (1);\n+}\n+\n+static void hip2 (void (*g)())\n+{\n+  non_existent (2);\n+  g ();\n+}\n+\n+static void hip1 (void (*f)(void (*)()), void (*g)())\n+{\n+  non_existent (2);\n+  f (g);\n+}\n+\n+int main (int argc, int *argv[])\n+{\n+  int i;\n+\n+  for (i = 0; i < get_input (); i++)\n+    hip1 (hip2, hooray);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"hooray\\[^\\\\n\\]*inline copy in main\" \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump \"hip2\\[^\\\\n\\]*inline copy in main\" \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}]}