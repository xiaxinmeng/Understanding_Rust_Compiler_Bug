{"sha": "fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "node_id": "C_kwDOANBUbNoAKGZiZDJlZGExMmM3ZmM2NmQ1ZjI0YjIwODk4NTQzMGZjYmU2ZjVhYjU", "commit": {"author": {"name": "Gaius Mulley", "email": "gaiusmod2@gmail.com", "date": "2023-03-04T13:11:05Z"}, "committer": {"name": "Gaius Mulley", "email": "gaiusmod2@gmail.com", "date": "2023-03-04T13:11:05Z"}, "message": "Fix modula-2 rename autogenerated .c files to .cc\n\nThis patch adds the replacement .cc files for the\nautogenerated tools.\n\ngcc/m2/ChangeLog:\n\n\t* mc-boot-ch/GBuiltins.cc: New file.\n\t* mc-boot-ch/Gdtoa.cc: New file.\n\t* mc-boot-ch/Gerrno.cc: New file.\n\t* mc-boot-ch/Gldtoa.cc: New file.\n\t* mc-boot-ch/Gm2rtsdummy.cc: New file.\n\t* mc-boot/GASCII.cc: New file.\n\t* mc-boot/GArgs.cc: New file.\n\t* mc-boot/GAssertion.cc: New file.\n\t* mc-boot/GBreak.cc: New file.\n\t* mc-boot/GCmdArgs.cc: New file.\n\t* mc-boot/GDebug.cc: New file.\n\t* mc-boot/GDynamicStrings.cc: New file.\n\t* mc-boot/GEnvironment.cc: New file.\n\t* mc-boot/GFIO.cc: New file.\n\t* mc-boot/GFormatStrings.cc: New file.\n\t* mc-boot/GFpuIO.cc: New file.\n\t* mc-boot/GIO.cc: New file.\n\t* mc-boot/GIndexing.cc: New file.\n\t* mc-boot/GM2Dependent.cc: New file.\n\t* mc-boot/GM2EXCEPTION.cc: New file.\n\t* mc-boot/GM2RTS.cc: New file.\n\t* mc-boot/GMemUtils.cc: New file.\n\t* mc-boot/GNumberIO.cc: New file.\n\t* mc-boot/GPushBackInput.cc: New file.\n\t* mc-boot/GRTExceptions.cc: New file.\n\t* mc-boot/GRTint.cc: New file.\n\t* mc-boot/GSArgs.cc: New file.\n\t* mc-boot/GSFIO.cc: New file.\n\t* mc-boot/GStdIO.cc: New file.\n\t* mc-boot/GStorage.cc: New file.\n\t* mc-boot/GStrCase.cc: New file.\n\t* mc-boot/GStrIO.cc: New file.\n\t* mc-boot/GStrLib.cc: New file.\n\t* mc-boot/GStringConvert.cc: New file.\n\t* mc-boot/GSysStorage.cc: New file.\n\t* mc-boot/GTimeString.cc: New file.\n\t* mc-boot/Galists.cc: New file.\n\t* mc-boot/Gdecl.cc: New file.\n\t* mc-boot/Gkeyc.cc: New file.\n\t* mc-boot/Glists.cc: New file.\n\t* mc-boot/GmcComment.cc: New file.\n\t* mc-boot/GmcComp.cc: New file.\n\t* mc-boot/GmcDebug.cc: New file.\n\t* mc-boot/GmcError.cc: New file.\n\t* mc-boot/GmcFileName.cc: New file.\n\t* mc-boot/GmcLexBuf.cc: New file.\n\t* mc-boot/GmcMetaError.cc: New file.\n\t* mc-boot/GmcOptions.cc: New file.\n\t* mc-boot/GmcPreprocess.cc: New file.\n\t* mc-boot/GmcPretty.cc: New file.\n\t* mc-boot/GmcPrintf.cc: New file.\n\t* mc-boot/GmcQuiet.cc: New file.\n\t* mc-boot/GmcReserved.cc: New file.\n\t* mc-boot/GmcSearch.cc: New file.\n\t* mc-boot/GmcStack.cc: New file.\n\t* mc-boot/GmcStream.cc: New file.\n\t* mc-boot/Gmcp1.cc: New file.\n\t* mc-boot/Gmcp2.cc: New file.\n\t* mc-boot/Gmcp3.cc: New file.\n\t* mc-boot/Gmcp4.cc: New file.\n\t* mc-boot/Gmcp5.cc: New file.\n\t* mc-boot/GnameKey.cc: New file.\n\t* mc-boot/GsymbolKey.cc: New file.\n\t* mc-boot/Gtop.cc: New file.\n\t* mc-boot/Gvarargs.cc: New file.\n\t* mc-boot/Gwlists.cc: New file.\n\t* pge-boot/GASCII.cc: New file.\n\t* pge-boot/GArgs.cc: New file.\n\t* pge-boot/GAssertion.cc: New file.\n\t* pge-boot/GBuiltins.cc: New file.\n\t* pge-boot/GDebug.cc: New file.\n\t* pge-boot/GDynamicStrings.cc: New file.\n\t* pge-boot/GFIO.cc: New file.\n\t* pge-boot/GIO.cc: New file.\n\t* pge-boot/GIndexing.cc: New file.\n\t* pge-boot/GLists.cc: New file.\n\t* pge-boot/GM2Dependent.cc: New file.\n\t* pge-boot/GM2EXCEPTION.cc: New file.\n\t* pge-boot/GM2LINK.cc: New file.\n\t* pge-boot/GM2RTS.cc: New file.\n\t* pge-boot/GNameKey.cc: New file.\n\t* pge-boot/GNumberIO.cc: New file.\n\t* pge-boot/GOutput.cc: New file.\n\t* pge-boot/GPushBackInput.cc: New file.\n\t* pge-boot/GRTExceptions.cc: New file.\n\t* pge-boot/GRTco.cc: New file.\n\t* pge-boot/GSFIO.cc: New file.\n\t* pge-boot/GSYSTEM.cc: New file.\n\t* pge-boot/GSelective.cc: New file.\n\t* pge-boot/GStdIO.cc: New file.\n\t* pge-boot/GStorage.cc: New file.\n\t* pge-boot/GStrCase.cc: New file.\n\t* pge-boot/GStrIO.cc: New file.\n\t* pge-boot/GStrLib.cc: New file.\n\t* pge-boot/GSymbolKey.cc: New file.\n\t* pge-boot/GSysExceptions.cc: New file.\n\t* pge-boot/GSysStorage.cc: New file.\n\t* pge-boot/Gabort.cc: New file.\n\t* pge-boot/Gbnflex.cc: New file.\n\t* pge-boot/Gcbuiltin.cc: New file.\n\t* pge-boot/Gdtoa.cc: New file.\n\t* pge-boot/Gerrno.cc: New file.\n\t* pge-boot/Gldtoa.cc: New file.\n\t* pge-boot/Glibc.cc: New file.\n\t* pge-boot/Glibm.cc: New file.\n\t* pge-boot/Gmcrts.cc: New file.\n\t* pge-boot/Gpge.cc: New file.\n\t* pge-boot/Gwrapc.cc: New file.\n\t* pge-boot/main.cc: New file.\n\t* pge-boot/network.cc: New file.\n\nSigned-off-by: Gaius Mulley <gaiusmod2@gmail.com>", "tree": {"sha": "58a7078ebe57ec0c1a5a7e1565b1f6eaeaf02150", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58a7078ebe57ec0c1a5a7e1565b1f6eaeaf02150"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/comments", "author": null, "committer": null, "parents": [{"sha": "ab61100f4f00776e30bf92caac0d7b9963183cfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab61100f4f00776e30bf92caac0d7b9963183cfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab61100f4f00776e30bf92caac0d7b9963183cfd"}], "stats": {"total": 125948, "additions": 125948, "deletions": 0}, "files": [{"sha": "a762635d54469bb95d5ca0d64f82c4f59fa1be68", "filename": "gcc/m2/mc-boot-ch/GBuiltins.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot-ch%2FGBuiltins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot-ch%2FGBuiltins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot-ch%2FGBuiltins.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,43 @@\n+/* GBuiltins.cc dummy module to aid linking mc projects.\n+\n+Copyright (C) 2016-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius@glam.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Modula-2; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#if defined(__cplusplus)\n+#define EXTERN extern \"C\"\n+#else\n+#define EXTERN\n+#endif\n+\n+\n+/* init module constructor.  */\n+\n+EXTERN\n+void\n+_M2_Builtins_init (void)\n+{\n+}\n+\n+/* finish module deconstructor.  */\n+\n+EXTERN\n+void\n+_M2_Builtins_fini (void)\n+{\n+}"}, {"sha": "e64fe5ad3074ee86d98bc27753dadbf1a028913e", "filename": "gcc/m2/mc-boot-ch/Gdtoa.cc", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot-ch%2FGdtoa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot-ch%2FGdtoa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot-ch%2FGdtoa.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,184 @@\n+/* Gdtoa.cc provides access to double string conversion.\n+\n+Copyright (C) 2016-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius@glam.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Modula-2; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#define GM2\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#define MAX_FP_DIGITS 500\n+\n+typedef enum Mode { maxsignicant, decimaldigits } Mode;\n+\n+/* maxsignicant: return a string containing max(1,ndigits)\n+   significant digits.  The return string contains the string\n+   produced by ecvt.  decimaldigits: return a string produced by\n+   fcvt.  The string will contain ndigits past the decimal point\n+   (ndigits may be negative).  */\n+\n+double\n+dtoa_strtod (const char *s, int *error)\n+{\n+  char *endp;\n+  double d;\n+\n+  errno = 0;\n+  d = strtod (s, &endp);\n+  if (endp != NULL && (*endp == '\\0'))\n+    *error = (errno != 0);\n+  else\n+    *error = TRUE;\n+  return d;\n+}\n+\n+/* dtoa_calcmaxsig - calculates the position of the decimal point it\n+   also removes the decimal point and exponent from string, p.  */\n+\n+int\n+dtoa_calcmaxsig (char *p, int ndigits)\n+{\n+  char *e;\n+  char *o;\n+  int x;\n+\n+  e = index (p, 'E');\n+  if (e == NULL)\n+    x = 0;\n+  else\n+    {\n+      *e = (char)0;\n+      x = atoi (e + 1);\n+    }\n+\n+  o = index (p, '.');\n+  if (o == NULL)\n+    return strlen (p) + x;\n+  else\n+    {\n+      memmove (o, o + 1, ndigits - (o - p));\n+      return o - p + x;\n+    }\n+}\n+\n+/* dtoa_calcdecimal - calculates the position of the decimal point it\n+   also removes the decimal point and exponent from string, p.  It\n+   truncates the digits in p accordingly to ndigits.  Ie ndigits is\n+   the number of digits after the '.' */\n+\n+int\n+dtoa_calcdecimal (char *p, int str_size, int ndigits)\n+{\n+  char *e;\n+  char *o;\n+  int x;\n+  int l;\n+\n+  e = index (p, 'E');\n+  if (e == NULL)\n+    x = 0;\n+  else\n+    {\n+      *e = (char)0;\n+      x = atoi (e + 1);\n+    }\n+\n+  l = strlen (p);\n+  o = index (p, '.');\n+  if (o == NULL)\n+    x += strlen (p);\n+  else\n+    {\n+      int m = strlen (o);\n+      memmove (o, o + 1, l - (o - p));\n+      if (m > 0)\n+        o[m - 1] = '0';\n+      x += o - p;\n+    }\n+  if ((x + ndigits >= 0) && (x + ndigits < str_size))\n+    p[x + ndigits] = (char)0;\n+  return x;\n+}\n+\n+\n+int\n+dtoa_calcsign (char *p, int str_size)\n+{\n+  if (p[0] == '-')\n+    {\n+      memmove (p, p + 1, str_size - 1);\n+      return TRUE;\n+    }\n+  else\n+    return FALSE;\n+}\n+\n+\n+char *\n+dtoa_dtoa (double d, int mode, int ndigits, int *decpt, int *sign)\n+{\n+  char format[50];\n+  char *p;\n+  int r;\n+  switch (mode)\n+    {\n+\n+    case maxsignicant:\n+      ndigits += 20; /* enough for exponent.  */\n+      p = (char *) malloc (ndigits);\n+      snprintf (format, 50, \"%s%d%s\", \"%.\", ndigits - 20, \"E\");\n+      snprintf (p, ndigits, format, d);\n+      *sign = dtoa_calcsign (p, ndigits);\n+      *decpt = dtoa_calcmaxsig (p, ndigits);\n+      return p;\n+    case decimaldigits:\n+      p = (char *) malloc (MAX_FP_DIGITS + 20);\n+      snprintf (format, 50, \"%s%d%s\", \"%.\", MAX_FP_DIGITS, \"E\");\n+      snprintf (p, MAX_FP_DIGITS + 20, format, d);\n+      *sign = dtoa_calcsign (p, MAX_FP_DIGITS + 20);\n+      *decpt = dtoa_calcdecimal (p, MAX_FP_DIGITS + 20, ndigits);\n+      return p;\n+    default:\n+      abort ();\n+    }\n+}\n+\n+#if defined(GM2)\n+/* GNU Modula-2 hooks */\n+\n+void\n+_M2_dtoa_init (void)\n+{\n+}\n+\n+void\n+_M2_dtoa_fini (void)\n+{\n+}\n+#endif\n+\n+#ifdef __cplusplus\n+}\n+#endif"}, {"sha": "f8832329ec1bfea60b1e90d30474fff429c241be", "filename": "gcc/m2/mc-boot-ch/Gerrno.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot-ch%2FGerrno.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot-ch%2FGerrno.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot-ch%2FGerrno.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,54 @@\n+/* Gerrno.cc provides access to errno for Modula-2.\n+\n+Copyright (C) 2016-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius@glam.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Modula-2; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"ansidecl.h\"\n+\n+#   ifdef __cplusplus\n+extern \"C\" {\n+#   endif\n+\n+/* geterrno returns errno.  */\n+\n+int\n+errno_geterrno (void)\n+{\n+  return errno;\n+}\n+\n+/* init constructor for the module.  */\n+\n+void\n+_M2_errno_init (int argc, char *p)\n+{\n+}\n+\n+/* finish deconstructor for the module.  */\n+\n+void\n+_M2_errno_fini (int argc, char *p)\n+{\n+}\n+\n+#   ifdef __cplusplus\n+}\n+#   endif"}, {"sha": "73f3d1806e550c24bd5f91dc211e528c3a981721", "filename": "gcc/m2/mc-boot-ch/Gldtoa.cc", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot-ch%2FGldtoa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot-ch%2FGldtoa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot-ch%2FGldtoa.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,107 @@\n+/* Gldtoa.cc provides access to long double string conversion.\n+\n+Copyright (C) 2016-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius@glam.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Modula-2; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+\n+#include \"gm2-libs-host.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#define MAX_FP_DIGITS 500\n+\n+typedef enum Mode { maxsignicant, decimaldigits } Mode;\n+\n+extern int dtoa_calcmaxsig (char *p, int ndigits);\n+extern int dtoa_calcdecimal (char *p, int str_size, int ndigits);\n+extern int dtoa_calcsign (char *p, int str_size);\n+\n+/* maxsignicant: return a string containing max(1,ndigits)\n+   significant digits.  The return string contains the string\n+   produced by snprintf.  decimaldigits: return a string produced by\n+   fcvt.  The string will contain ndigits past the decimal point\n+   (ndigits may be negative).  */\n+\n+long double\n+ldtoa_strtold (const char *s, int *error)\n+{\n+  char *endp;\n+  long double d;\n+\n+  errno = 0;\n+#if defined(HAVE_STRTOLD)\n+  d = strtold (s, &endp);\n+#else\n+  /* fall back to using strtod.  */\n+  d = (long double)strtod (s, &endp);\n+#endif\n+  if (endp != NULL && (*endp == '\\0'))\n+    *error = (errno != 0);\n+  else\n+    *error = TRUE;\n+  return d;\n+}\n+\n+char *\n+ldtoa_ldtoa (long double d, int mode, int ndigits, int *decpt, int *sign)\n+{\n+  char format[50];\n+  char *p;\n+  int r;\n+  switch (mode)\n+    {\n+\n+    case maxsignicant:\n+      ndigits += 20; /* enough for exponent.  */\n+      p = (char *)malloc (ndigits);\n+      snprintf (format, 50, \"%s%d%s\", \"%.\", ndigits - 20, \"LE\");\n+      snprintf (p, ndigits, format, d);\n+      *sign = dtoa_calcsign (p, ndigits);\n+      *decpt = dtoa_calcmaxsig (p, ndigits);\n+      return p;\n+    case decimaldigits:\n+      p = (char *)malloc (MAX_FP_DIGITS + 20);\n+      snprintf (format, 50, \"%s%d%s\", \"%.\", MAX_FP_DIGITS, \"LE\");\n+      snprintf (p, MAX_FP_DIGITS + 20, format, d);\n+      *sign = dtoa_calcsign (p, MAX_FP_DIGITS + 20);\n+      *decpt = dtoa_calcdecimal (p, MAX_FP_DIGITS + 20, ndigits);\n+      return p;\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* GNU Modula-2 hooks */\n+\n+void\n+_M2_ldtoa_init (void)\n+{\n+}\n+\n+void\n+_M2_ldtoa_fini (void)\n+{\n+}\n+#   ifdef __cplusplus\n+}\n+#   endif"}, {"sha": "c0ae97959486e41001370924d53c8d7d98c3cd53", "filename": "gcc/m2/mc-boot-ch/Gm2rtsdummy.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot-ch%2FGm2rtsdummy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot-ch%2FGm2rtsdummy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot-ch%2FGm2rtsdummy.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,62 @@\n+/* m2rts.cc provides a C interface to M2RTS.mod.\n+\n+Copyright (C) 2019-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This is a minimal wrapper for M2RTS.c which allows mc to be built with\n+   a nul pathname \"m2pim\" library and then to link against an installed\n+   m2pim library.  */\n+\n+typedef void (*proc_con) (int, char **, char **);\n+typedef void (*proc_dep) (void);\n+\n+#if 0\n+/* Used if -fscaffold-dynamic were selected.  */\n+extern \"C\" void M2RTS_RequestDependant (const char *modulename, const char *libname,\n+\t\t\t\t\tconst char *dependancy, const char *deplib);\n+#endif\n+\n+extern \"C\" void m2pim_M2RTS_RegisterModule (const char *modulename, const char *libname,\n+\t\t\t\t\t    proc_con init, proc_con fini, proc_dep dependencies);\n+\n+/* Fixup references, the code will not be used though, as it is only used if\n+   -fscaffold-dynamic is selected (and mc uses -fscaffold-static).  */\n+\n+extern \"C\"\n+void M2RTS_RegisterModule (const char *modulename, const char *libname,\n+\t\t\t   proc_con init, proc_con fini, proc_dep dependencies)\n+{\n+  m2pim_M2RTS_RegisterModule (modulename, libname, init, fini, dependencies);\n+}\n+\n+#if 0\n+extern \"C\" void _M2_M2RTS_init (void);\n+\n+extern \"C\" void M2RTS_ConstructModules (const char *,\n+\t\t\t\t\tint argc, char *argv[], char *envp[]);\n+extern \"C\" void M2RTS_Terminate (void);\n+extern \"C\" void M2RTS_DeconstructModules (void);\n+\n+extern \"C\" void M2RTS_Halt (const char *, int, const char *, const char *) __attribute__ ((noreturn));\n+#endif"}, {"sha": "2f768ce24c816040e6031ce9b5d39d772e1b52cb", "filename": "gcc/m2/mc-boot/GASCII.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGASCII.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGASCII.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGASCII.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,86 @@\n+/* do not edit automatically generated by mc from ASCII.  */\n+/* ASCII.mod dummy companion module for the definition.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#define _ASCII_H\n+#define _ASCII_C\n+\n+\n+#   define ASCII_nul (char) 000\n+#   define ASCII_soh (char) 001\n+#   define ASCII_stx (char) 002\n+#   define ASCII_etx (char) 003\n+#   define ASCII_eot (char) 004\n+#   define ASCII_enq (char) 005\n+#   define ASCII_ack (char) 006\n+#   define ASCII_bel (char) 007\n+#   define ASCII_bs (char) 010\n+#   define ASCII_ht (char) 011\n+#   define ASCII_nl (char) 012\n+#   define ASCII_vt (char) 013\n+#   define ASCII_np (char) 014\n+#   define ASCII_cr (char) 015\n+#   define ASCII_so (char) 016\n+#   define ASCII_si (char) 017\n+#   define ASCII_dle (char) 020\n+#   define ASCII_dc1 (char) 021\n+#   define ASCII_dc2 (char) 022\n+#   define ASCII_dc3 (char) 023\n+#   define ASCII_dc4 (char) 024\n+#   define ASCII_nak (char) 025\n+#   define ASCII_syn (char) 026\n+#   define ASCII_etb (char) 027\n+#   define ASCII_can (char) 030\n+#   define ASCII_em (char) 031\n+#   define ASCII_sub (char) 032\n+#   define ASCII_esc (char) 033\n+#   define ASCII_fs (char) 034\n+#   define ASCII_gs (char) 035\n+#   define ASCII_rs (char) 036\n+#   define ASCII_us (char) 037\n+#   define ASCII_sp (char) 040\n+#   define ASCII_lf ASCII_nl\n+#   define ASCII_ff ASCII_np\n+#   define ASCII_eof ASCII_eot\n+#   define ASCII_tab ASCII_ht\n+#   define ASCII_del (char) 0177\n+#   define ASCII_EOL ASCII_nl\n+\n+extern \"C\" void _M2_ASCII_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}\n+\n+extern \"C\" void _M2_ASCII_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "106ddfd30c6e2671b123ffb7a39ca9f6c61469a1", "filename": "gcc/m2/mc-boot/GArgs.cc", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGArgs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGArgs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGArgs.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,120 @@\n+/* do not edit automatically generated by mc from Args.  */\n+/* Args.mod provide access to command line arguments.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius@glam.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#define _Args_H\n+#define _Args_C\n+\n+#   include \"GUnixArgs.h\"\n+#   include \"GASCII.h\"\n+\n+#   define MaxArgs 255\n+#   define MaxString 4096\n+typedef struct Args__T2_a Args__T2;\n+\n+typedef Args__T2 *Args__T1;\n+\n+typedef struct Args__T3_a Args__T3;\n+\n+struct Args__T2_a { Args__T3 * array[MaxArgs+1]; };\n+struct Args__T3_a { char array[MaxString+1]; };\n+static Args__T1 Source;\n+\n+/*\n+   GetArg - returns the nth argument from the command line.\n+            The success of the operation is returned.\n+*/\n+\n+extern \"C\" unsigned int Args_GetArg (char *a, unsigned int _a_high, unsigned int n);\n+\n+/*\n+   Narg - returns the number of arguments available from\n+          command line.\n+*/\n+\n+extern \"C\" unsigned int Args_Narg (void);\n+\n+\n+/*\n+   GetArg - returns the nth argument from the command line.\n+            The success of the operation is returned.\n+*/\n+\n+extern \"C\" unsigned int Args_GetArg (char *a, unsigned int _a_high, unsigned int n)\n+{\n+  int i;\n+  unsigned int High;\n+  unsigned int j;\n+\n+  i = (int ) (n);\n+  j = 0;\n+  High = _a_high;\n+  if (i < (UnixArgs_GetArgC ()))\n+    {\n+      Source = static_cast<Args__T1> (UnixArgs_GetArgV ());\n+      while ((j < High) && ((*(*Source).array[i]).array[j] != ASCII_nul))\n+        {\n+          a[j] = (*(*Source).array[i]).array[j];\n+          j += 1;\n+        }\n+    }\n+  if (j <= High)\n+    {\n+      a[j] = ASCII_nul;\n+    }\n+  return i < (UnixArgs_GetArgC ());\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Narg - returns the number of arguments available from\n+          command line.\n+*/\n+\n+extern \"C\" unsigned int Args_Narg (void)\n+{\n+  return UnixArgs_GetArgC ();\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" void _M2_Args_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}\n+\n+extern \"C\" void _M2_Args_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "21ee6c0b2f24c9cc489b802c6590a14cdb3332af", "filename": "gcc/m2/mc-boot/GAssertion.cc", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGAssertion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGAssertion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGAssertion.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,71 @@\n+/* do not edit automatically generated by mc from Assertion.  */\n+/* Assertion.mod provides an assert procedure.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#define _Assertion_H\n+#define _Assertion_C\n+\n+#   include \"GStrIO.h\"\n+#   include \"GM2RTS.h\"\n+\n+\n+/*\n+   Assert - tests the boolean Condition, if it fails then HALT is called.\n+*/\n+\n+extern \"C\" void Assertion_Assert (unsigned int Condition);\n+\n+\n+/*\n+   Assert - tests the boolean Condition, if it fails then HALT is called.\n+*/\n+\n+extern \"C\" void Assertion_Assert (unsigned int Condition)\n+{\n+  if (! Condition)\n+    {\n+      StrIO_WriteString ((const char *) \"assert failed - halting system\", 30);\n+      StrIO_WriteLn ();\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n+    }\n+}\n+\n+extern \"C\" void _M2_Assertion_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}\n+\n+extern \"C\" void _M2_Assertion_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "9be003bd619cf505cb4958b45f195e10c20e19b1", "filename": "gcc/m2/mc-boot/GBreak.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGBreak.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGBreak.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGBreak.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,47 @@\n+/* do not edit automatically generated by mc from Break.  */\n+/* Break.mod provides a dummy compatibility library for legacy systems.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#define _Break_H\n+#define _Break_C\n+\n+\n+\n+extern \"C\" void _M2_Break_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}\n+\n+extern \"C\" void _M2_Break_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "c304a4071825e8dd508c62108f47dc6d3d80824b", "filename": "gcc/m2/mc-boot/GCmdArgs.cc", "status": "added", "additions": 322, "deletions": 0, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGCmdArgs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGCmdArgs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGCmdArgs.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,322 @@\n+/* do not edit automatically generated by mc from CmdArgs.  */\n+/* CmdArgs.mod provides procedures to retrieve arguments from strings.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#define _CmdArgs_H\n+#define _CmdArgs_C\n+\n+#   include \"GASCII.h\"\n+#   include \"GStrLib.h\"\n+\n+#   define esc '\\\\'\n+#   define space ' '\n+#   define squote '\\''\n+#   define dquote '\"'\n+#   define tab ' '\n+\n+/*\n+   GetArg - takes a command line and attempts to extract argument, n,\n+            from CmdLine. The resulting argument is placed into, a.\n+            The result of the operation is returned.\n+*/\n+\n+extern \"C\" unsigned int CmdArgs_GetArg (const char *CmdLine_, unsigned int _CmdLine_high, unsigned int n, char *Argi, unsigned int _Argi_high);\n+\n+/*\n+   Narg - returns the number of arguments available from\n+          command line, CmdLine.\n+*/\n+\n+extern \"C\" unsigned int CmdArgs_Narg (const char *CmdLine_, unsigned int _CmdLine_high);\n+\n+/*\n+   GetNextArg - Returns true if another argument may be found.\n+                The argument is taken from CmdLine at position Index,\n+                Arg is filled with the found argument.\n+*/\n+\n+static unsigned int GetNextArg (const char *CmdLine_, unsigned int _CmdLine_high, unsigned int *CmdIndex, char *Arg, unsigned int _Arg_high);\n+\n+/*\n+   CopyUntilSpace - copies characters until a Space character is found.\n+*/\n+\n+static void CopyUntilSpace (const char *From_, unsigned int _From_high, unsigned int *FromIndex, unsigned int FromHigh, char *To, unsigned int _To_high, unsigned int *ToIndex, unsigned int ToHigh);\n+\n+/*\n+   CopyUntil - copies characters until the UntilChar is found.\n+*/\n+\n+static void CopyUntil (const char *From_, unsigned int _From_high, unsigned int *FromIndex, unsigned int FromHigh, char *To, unsigned int _To_high, unsigned int *ToIndex, unsigned int ToHigh, char UntilChar);\n+\n+/*\n+   CopyChar - copies a character from string From to string To and\n+              takes into consideration escape characters. ie \\x\n+              Where x is any character.\n+*/\n+\n+static void CopyChar (const char *From_, unsigned int _From_high, unsigned int *FromIndex, unsigned int FromHigh, char *To, unsigned int _To_high, unsigned int *ToIndex, unsigned int ToHigh);\n+static unsigned int Escape (char ch);\n+static unsigned int Space (char ch);\n+static unsigned int DoubleQuote (char ch);\n+static unsigned int SingleQuote (char ch);\n+\n+\n+/*\n+   GetNextArg - Returns true if another argument may be found.\n+                The argument is taken from CmdLine at position Index,\n+                Arg is filled with the found argument.\n+*/\n+\n+static unsigned int GetNextArg (const char *CmdLine_, unsigned int _CmdLine_high, unsigned int *CmdIndex, char *Arg, unsigned int _Arg_high)\n+{\n+  unsigned int ArgIndex;\n+  unsigned int HighA;\n+  unsigned int HighC;\n+  char CmdLine[_CmdLine_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (CmdLine, CmdLine_, _CmdLine_high+1);\n+\n+  HighA = _Arg_high;  /* Index into Arg  */\n+  HighC = StrLib_StrLen ((const char *) CmdLine, _CmdLine_high);\n+  ArgIndex = 0;\n+  /* Skip spaces  */\n+  while (((*CmdIndex) < HighC) && (Space (CmdLine[(*CmdIndex)])))\n+    {\n+      (*CmdIndex) += 1;\n+    }\n+  if ((*CmdIndex) < HighC)\n+    {\n+      /* avoid gcc warning by using compound statement even if not strictly necessary.  */\n+      if (SingleQuote (CmdLine[(*CmdIndex)]))\n+        {\n+          /* Skip over the single quote  */\n+          (*CmdIndex) += 1;\n+          CopyUntil ((const char *) CmdLine, _CmdLine_high, CmdIndex, HighC, (char *) Arg, _Arg_high, &ArgIndex, HighA, squote);\n+          (*CmdIndex) += 1;\n+        }\n+      else if (DoubleQuote (CmdLine[(*CmdIndex)]))\n+        {\n+          /* avoid dangling else.  */\n+          /* Skip over the double quote  */\n+          (*CmdIndex) += 1;\n+          CopyUntil ((const char *) CmdLine, _CmdLine_high, CmdIndex, HighC, (char *) Arg, _Arg_high, &ArgIndex, HighA, dquote);\n+          (*CmdIndex) += 1;\n+        }\n+      else\n+        {\n+          /* avoid dangling else.  */\n+          CopyUntilSpace ((const char *) CmdLine, _CmdLine_high, CmdIndex, HighC, (char *) Arg, _Arg_high, &ArgIndex, HighA);\n+        }\n+    }\n+  /* Skip spaces  */\n+  while (((*CmdIndex) < HighC) && (Space (CmdLine[(*CmdIndex)])))\n+    {\n+      (*CmdIndex) += 1;\n+    }\n+  if (ArgIndex < HighA)\n+    {\n+      Arg[ArgIndex] = ASCII_nul;\n+    }\n+  return (*CmdIndex) < HighC;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   CopyUntilSpace - copies characters until a Space character is found.\n+*/\n+\n+static void CopyUntilSpace (const char *From_, unsigned int _From_high, unsigned int *FromIndex, unsigned int FromHigh, char *To, unsigned int _To_high, unsigned int *ToIndex, unsigned int ToHigh)\n+{\n+  char From[_From_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (From, From_, _From_high+1);\n+\n+  while ((((*FromIndex) < FromHigh) && ((*ToIndex) < ToHigh)) && (! (Space (From[(*FromIndex)]))))\n+    {\n+      CopyChar ((const char *) From, _From_high, FromIndex, FromHigh, (char *) To, _To_high, ToIndex, ToHigh);\n+    }\n+}\n+\n+\n+/*\n+   CopyUntil - copies characters until the UntilChar is found.\n+*/\n+\n+static void CopyUntil (const char *From_, unsigned int _From_high, unsigned int *FromIndex, unsigned int FromHigh, char *To, unsigned int _To_high, unsigned int *ToIndex, unsigned int ToHigh, char UntilChar)\n+{\n+  char From[_From_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (From, From_, _From_high+1);\n+\n+  while ((((*FromIndex) < FromHigh) && ((*ToIndex) < ToHigh)) && (From[(*FromIndex)] != UntilChar))\n+    {\n+      CopyChar ((const char *) From, _From_high, FromIndex, FromHigh, (char *) To, _To_high, ToIndex, ToHigh);\n+    }\n+}\n+\n+\n+/*\n+   CopyChar - copies a character from string From to string To and\n+              takes into consideration escape characters. ie \\x\n+              Where x is any character.\n+*/\n+\n+static void CopyChar (const char *From_, unsigned int _From_high, unsigned int *FromIndex, unsigned int FromHigh, char *To, unsigned int _To_high, unsigned int *ToIndex, unsigned int ToHigh)\n+{\n+  char From[_From_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (From, From_, _From_high+1);\n+\n+  if (((*FromIndex) < FromHigh) && ((*ToIndex) < ToHigh))\n+    {\n+      if (Escape (From[(*FromIndex)]))\n+        {\n+          /* Skip over Escape Character  */\n+          (*FromIndex) += 1;\n+        }\n+      if ((*FromIndex) < FromHigh)\n+        {\n+          /* Copy Normal Character  */\n+          To[(*ToIndex)] = From[(*FromIndex)];\n+          (*ToIndex) += 1;\n+          (*FromIndex) += 1;\n+        }\n+    }\n+}\n+\n+static unsigned int Escape (char ch)\n+{\n+  return ch == esc;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+static unsigned int Space (char ch)\n+{\n+  return (ch == space) || (ch == tab);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+static unsigned int DoubleQuote (char ch)\n+{\n+  return ch == dquote;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+static unsigned int SingleQuote (char ch)\n+{\n+  return ch == squote;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   GetArg - takes a command line and attempts to extract argument, n,\n+            from CmdLine. The resulting argument is placed into, a.\n+            The result of the operation is returned.\n+*/\n+\n+extern \"C\" unsigned int CmdArgs_GetArg (const char *CmdLine_, unsigned int _CmdLine_high, unsigned int n, char *Argi, unsigned int _Argi_high)\n+{\n+  unsigned int Index;\n+  unsigned int i;\n+  unsigned int Another;\n+  char CmdLine[_CmdLine_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (CmdLine, CmdLine_, _CmdLine_high+1);\n+\n+  Index = 0;\n+  /* Continually retrieve an argument until we get the n th argument.  */\n+  i = 0;\n+  do {\n+    Another = GetNextArg ((const char *) CmdLine, _CmdLine_high, &Index, (char *) Argi, _Argi_high);\n+    i += 1;\n+  } while (! ((i > n) || ! Another));\n+  return i > n;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Narg - returns the number of arguments available from\n+          command line, CmdLine.\n+*/\n+\n+extern \"C\" unsigned int CmdArgs_Narg (const char *CmdLine_, unsigned int _CmdLine_high)\n+{\n+  typedef struct Narg__T1_a Narg__T1;\n+\n+  struct Narg__T1_a { char array[1000+1]; };\n+  Narg__T1 a;\n+  unsigned int ArgNo;\n+  char CmdLine[_CmdLine_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (CmdLine, CmdLine_, _CmdLine_high+1);\n+\n+  ArgNo = 0;\n+  while (CmdArgs_GetArg ((const char *) CmdLine, _CmdLine_high, ArgNo, (char *) &a.array[0], 1000))\n+    {\n+      ArgNo += 1;\n+    }\n+  /* \n+   IF ArgNo>0\n+   THEN\n+      DEC(ArgNo)\n+   END ;\n+  */\n+  return ArgNo;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" void _M2_CmdArgs_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}\n+\n+extern \"C\" void _M2_CmdArgs_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "6329abb11b1665a1043c38f838d927169e6259e8", "filename": "gcc/m2/mc-boot/GDebug.cc", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGDebug.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGDebug.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGDebug.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,168 @@\n+/* do not edit automatically generated by mc from Debug.  */\n+/* Debug.mod provides some simple debugging routines.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#define _Debug_H\n+#define _Debug_C\n+\n+#   include \"GASCII.h\"\n+#   include \"GNumberIO.h\"\n+#   include \"GStdIO.h\"\n+#   include \"Glibc.h\"\n+#   include \"GM2RTS.h\"\n+\n+#   define MaxNoOfDigits 12\n+\n+/*\n+   Halt - writes a message in the format:\n+          Module:Line:Message\n+\n+          It then terminates by calling HALT.\n+*/\n+\n+extern \"C\" void Debug_Halt (const char *Message_, unsigned int _Message_high, unsigned int LineNo, const char *Module_, unsigned int _Module_high);\n+\n+/*\n+   DebugString - writes a string to the debugging device (Scn.Write).\n+                 It interprets \n+ as carriage return, linefeed.\n+*/\n+\n+extern \"C\" void Debug_DebugString (const char *a_, unsigned int _a_high);\n+\n+/*\n+   WriteLn - writes a carriage return and a newline\n+             character.\n+*/\n+\n+static void WriteLn (void);\n+\n+\n+/*\n+   WriteLn - writes a carriage return and a newline\n+             character.\n+*/\n+\n+static void WriteLn (void)\n+{\n+  StdIO_Write (ASCII_cr);\n+  StdIO_Write (ASCII_lf);\n+}\n+\n+\n+/*\n+   Halt - writes a message in the format:\n+          Module:Line:Message\n+\n+          It then terminates by calling HALT.\n+*/\n+\n+extern \"C\" void Debug_Halt (const char *Message_, unsigned int _Message_high, unsigned int LineNo, const char *Module_, unsigned int _Module_high)\n+{\n+  typedef struct Halt__T1_a Halt__T1;\n+\n+  struct Halt__T1_a { char array[MaxNoOfDigits+1]; };\n+  Halt__T1 No;\n+  char Message[_Message_high+1];\n+  char Module[_Module_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (Message, Message_, _Message_high+1);\n+  memcpy (Module, Module_, _Module_high+1);\n+\n+  Debug_DebugString ((const char *) Module, _Module_high);  /* should be large enough for most source files..  */\n+  NumberIO_CardToStr (LineNo, 0, (char *) &No.array[0], MaxNoOfDigits);\n+  Debug_DebugString ((const char *) \":\", 1);\n+  Debug_DebugString ((const char *) &No.array[0], MaxNoOfDigits);\n+  Debug_DebugString ((const char *) \":\", 1);\n+  Debug_DebugString ((const char *) Message, _Message_high);\n+  Debug_DebugString ((const char *) \"\\\\n\", 2);\n+  M2RTS_HALT (-1);\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   DebugString - writes a string to the debugging device (Scn.Write).\n+                 It interprets \n+ as carriage return, linefeed.\n+*/\n+\n+extern \"C\" void Debug_DebugString (const char *a_, unsigned int _a_high)\n+{\n+  unsigned int n;\n+  unsigned int high;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  high = _a_high;\n+  n = 0;\n+  while ((n <= high) && (a[n] != ASCII_nul))\n+    {\n+      if (a[n] == '\\\\')\n+        {\n+          /* avoid dangling else.  */\n+          if ((n+1) <= high)\n+            {\n+              /* avoid gcc warning by using compound statement even if not strictly necessary.  */\n+              if (a[n+1] == 'n')\n+                {\n+                  WriteLn ();\n+                  n += 1;\n+                }\n+              else if (a[n+1] == '\\\\')\n+                {\n+                  /* avoid dangling else.  */\n+                  StdIO_Write ('\\\\');\n+                  n += 1;\n+                }\n+            }\n+        }\n+      else\n+        {\n+          StdIO_Write (a[n]);\n+        }\n+      n += 1;\n+    }\n+}\n+\n+extern \"C\" void _M2_Debug_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}\n+\n+extern \"C\" void _M2_Debug_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "dfc163646bb212794a0fc48e51b3f5666410b52d", "filename": "gcc/m2/mc-boot/GDynamicStrings.cc", "status": "added", "additions": 2676, "deletions": 0, "changes": 2676, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGDynamicStrings.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGDynamicStrings.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGDynamicStrings.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,2676 @@\n+/* do not edit automatically generated by mc from DynamicStrings.  */\n+/* DynamicStrings.mod provides a dynamic string type and procedures.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#   if !defined (TRUE)\n+#      define TRUE (1==1)\n+#   endif\n+\n+#   if !defined (FALSE)\n+#      define FALSE (1==0)\n+#   endif\n+\n+#   include \"GStorage.h\"\n+#if defined(__cplusplus)\n+#   undef NULL\n+#   define NULL 0\n+#endif\n+#define _DynamicStrings_H\n+#define _DynamicStrings_C\n+\n+#   include \"Glibc.h\"\n+#   include \"GStrLib.h\"\n+#   include \"GStorage.h\"\n+#   include \"GAssertion.h\"\n+#   include \"GSYSTEM.h\"\n+#   include \"GASCII.h\"\n+#   include \"GM2RTS.h\"\n+\n+#   define MaxBuf 127\n+#   define PoisonOn FALSE\n+#   define DebugOn FALSE\n+#   define CheckOn FALSE\n+#   define TraceOn FALSE\n+typedef struct DynamicStrings_Contents_r DynamicStrings_Contents;\n+\n+typedef struct DynamicStrings_DebugInfo_r DynamicStrings_DebugInfo;\n+\n+typedef struct DynamicStrings_stringRecord_r DynamicStrings_stringRecord;\n+\n+typedef struct DynamicStrings_descriptor_r DynamicStrings_descriptor;\n+\n+typedef DynamicStrings_descriptor *DynamicStrings_Descriptor;\n+\n+typedef struct DynamicStrings_frameRec_r DynamicStrings_frameRec;\n+\n+typedef DynamicStrings_frameRec *DynamicStrings_frame;\n+\n+typedef struct DynamicStrings__T3_a DynamicStrings__T3;\n+\n+typedef enum {DynamicStrings_inuse, DynamicStrings_marked, DynamicStrings_onlist, DynamicStrings_poisoned} DynamicStrings_desState;\n+\n+typedef DynamicStrings_stringRecord *DynamicStrings_String;\n+\n+struct DynamicStrings_DebugInfo_r {\n+                                    DynamicStrings_String next;\n+                                    void *file;\n+                                    unsigned int line;\n+                                    void *proc;\n+                                  };\n+\n+struct DynamicStrings_descriptor_r {\n+                                     unsigned int charStarUsed;\n+                                     void *charStar;\n+                                     unsigned int charStarSize;\n+                                     unsigned int charStarValid;\n+                                     DynamicStrings_desState state;\n+                                     DynamicStrings_String garbage;\n+                                   };\n+\n+struct DynamicStrings_frameRec_r {\n+                                   DynamicStrings_String alloc;\n+                                   DynamicStrings_String dealloc;\n+                                   DynamicStrings_frame next;\n+                                 };\n+\n+struct DynamicStrings__T3_a { char array[(MaxBuf-1)+1]; };\n+struct DynamicStrings_Contents_r {\n+                                   DynamicStrings__T3 buf;\n+                                   unsigned int len;\n+                                   DynamicStrings_String next;\n+                                 };\n+\n+struct DynamicStrings_stringRecord_r {\n+                                       DynamicStrings_Contents contents;\n+                                       DynamicStrings_Descriptor head;\n+                                       DynamicStrings_DebugInfo debug;\n+                                     };\n+\n+static unsigned int Initialized;\n+static DynamicStrings_frame frameHead;\n+static DynamicStrings_String captured;\n+\n+/*\n+   InitString - creates and returns a String type object.\n+                Initial contents are, a.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_InitString (const char *a_, unsigned int _a_high);\n+\n+/*\n+   KillString - frees String, s, and its contents.\n+                NIL is returned.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_KillString (DynamicStrings_String s);\n+\n+/*\n+   Fin - finishes with a string, it calls KillString with, s.\n+         The purpose of the procedure is to provide a short cut\n+         to calling KillString and then testing the return result.\n+*/\n+\n+extern \"C\" void DynamicStrings_Fin (DynamicStrings_String s);\n+\n+/*\n+   InitStringCharStar - initializes and returns a String to contain the C string.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_InitStringCharStar (void * a);\n+\n+/*\n+   InitStringChar - initializes and returns a String to contain the single character, ch.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_InitStringChar (char ch);\n+\n+/*\n+   Mark - marks String, s, ready for garbage collection.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_Mark (DynamicStrings_String s);\n+\n+/*\n+   Length - returns the length of the String, s.\n+*/\n+\n+extern \"C\" unsigned int DynamicStrings_Length (DynamicStrings_String s);\n+\n+/*\n+   ConCat - returns String, a, after the contents of, b, have been appended.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_ConCat (DynamicStrings_String a, DynamicStrings_String b);\n+\n+/*\n+   ConCatChar - returns String, a, after character, ch, has been appended.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_ConCatChar (DynamicStrings_String a, char ch);\n+\n+/*\n+   Assign - assigns the contents of, b, into, a.\n+            String, a, is returned.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_Assign (DynamicStrings_String a, DynamicStrings_String b);\n+\n+/*\n+   Dup - duplicate a String, s, returning the copy of s.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_Dup (DynamicStrings_String s);\n+\n+/*\n+   Add - returns a new String which contains the contents of a and b.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_Add (DynamicStrings_String a, DynamicStrings_String b);\n+\n+/*\n+   Equal - returns TRUE if String, a, and, b, are equal.\n+*/\n+\n+extern \"C\" unsigned int DynamicStrings_Equal (DynamicStrings_String a, DynamicStrings_String b);\n+\n+/*\n+   EqualCharStar - returns TRUE if contents of String, s, is the same as the\n+                   string, a.\n+*/\n+\n+extern \"C\" unsigned int DynamicStrings_EqualCharStar (DynamicStrings_String s, void * a);\n+\n+/*\n+   EqualArray - returns TRUE if contents of String, s, is the same as the\n+                string, a.\n+*/\n+\n+extern \"C\" unsigned int DynamicStrings_EqualArray (DynamicStrings_String s, const char *a_, unsigned int _a_high);\n+\n+/*\n+   Mult - returns a new string which is n concatenations of String, s.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_Mult (DynamicStrings_String s, unsigned int n);\n+\n+/*\n+   Slice - returns a new string which contains the elements\n+           low..high-1\n+\n+           strings start at element 0\n+           Slice(s, 0, 2)  will return elements 0, 1 but not 2\n+           Slice(s, 1, 3)  will return elements 1, 2 but not 3\n+           Slice(s, 2, 0)  will return elements 2..max\n+           Slice(s, 3, -1) will return elements 3..max-1\n+           Slice(s, 4, -2) will return elements 4..max-2\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_Slice (DynamicStrings_String s, int low, int high);\n+\n+/*\n+   Index - returns the indice of the first occurance of, ch, in\n+           String, s. -1 is returned if, ch, does not exist.\n+           The search starts at position, o.\n+*/\n+\n+extern \"C\" int DynamicStrings_Index (DynamicStrings_String s, char ch, unsigned int o);\n+\n+/*\n+   RIndex - returns the indice of the last occurance of, ch,\n+            in String, s. The search starts at position, o.\n+            -1 is returned if, ch, is not found.\n+*/\n+\n+extern \"C\" int DynamicStrings_RIndex (DynamicStrings_String s, char ch, unsigned int o);\n+\n+/*\n+   RemoveComment - assuming that, comment, is a comment delimiter\n+                   which indicates anything to its right is a comment\n+                   then strip off the comment and also any white space\n+                   on the remaining right hand side.\n+                   It leaves any white space on the left hand side alone.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_RemoveComment (DynamicStrings_String s, char comment);\n+\n+/*\n+   RemoveWhitePrefix - removes any leading white space from String, s.\n+                       A new string is returned.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_RemoveWhitePrefix (DynamicStrings_String s);\n+\n+/*\n+   RemoveWhitePostfix - removes any leading white space from String, s.\n+                        A new string is returned.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_RemoveWhitePostfix (DynamicStrings_String s);\n+\n+/*\n+   ToUpper - returns string, s, after it has had its lower case characters\n+             replaced by upper case characters.\n+             The string, s, is not duplicated.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_ToUpper (DynamicStrings_String s);\n+\n+/*\n+   ToLower - returns string, s, after it has had its upper case characters\n+             replaced by lower case characters.\n+             The string, s, is not duplicated.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_ToLower (DynamicStrings_String s);\n+\n+/*\n+   CopyOut - copies string, s, to a.\n+*/\n+\n+extern \"C\" void DynamicStrings_CopyOut (char *a, unsigned int _a_high, DynamicStrings_String s);\n+\n+/*\n+   char - returns the character, ch, at position, i, in String, s.\n+*/\n+\n+extern \"C\" char DynamicStrings_char (DynamicStrings_String s, int i);\n+\n+/*\n+   string - returns the C style char * of String, s.\n+*/\n+\n+extern \"C\" void * DynamicStrings_string (DynamicStrings_String s);\n+\n+/*\n+   InitStringDB - the debug version of InitString.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_InitStringDB (const char *a_, unsigned int _a_high, const char *file_, unsigned int _file_high, unsigned int line);\n+\n+/*\n+   InitStringCharStarDB - the debug version of InitStringCharStar.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_InitStringCharStarDB (void * a, const char *file_, unsigned int _file_high, unsigned int line);\n+\n+/*\n+   InitStringCharDB - the debug version of InitStringChar.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_InitStringCharDB (char ch, const char *file_, unsigned int _file_high, unsigned int line);\n+\n+/*\n+   MultDB - the debug version of MultDB.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_MultDB (DynamicStrings_String s, unsigned int n, const char *file_, unsigned int _file_high, unsigned int line);\n+\n+/*\n+   DupDB - the debug version of Dup.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_DupDB (DynamicStrings_String s, const char *file_, unsigned int _file_high, unsigned int line);\n+\n+/*\n+   SliceDB - debug version of Slice.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_SliceDB (DynamicStrings_String s, int low, int high, const char *file_, unsigned int _file_high, unsigned int line);\n+\n+/*\n+   PushAllocation - pushes the current allocation/deallocation lists.\n+*/\n+\n+extern \"C\" void DynamicStrings_PushAllocation (void);\n+\n+/*\n+   PopAllocation - test to see that all strings are deallocated since\n+                   the last push.  Then it pops to the previous\n+                   allocation/deallocation lists.\n+\n+                   If halt is true then the application terminates\n+                   with an exit code of 1.\n+*/\n+\n+extern \"C\" void DynamicStrings_PopAllocation (unsigned int halt);\n+\n+/*\n+   PopAllocationExemption - test to see that all strings are deallocated, except\n+                            string, e, since the last push.\n+                            Then it pops to the previous allocation/deallocation\n+                            lists.\n+\n+                            If halt is true then the application terminates\n+                            with an exit code of 1.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_PopAllocationExemption (unsigned int halt, DynamicStrings_String e);\n+\n+/*\n+ writeStringDesc write out debugging information about string, s.  */\n+\n+static void writeStringDesc (DynamicStrings_String s);\n+\n+/*\n+   writeNspace -\n+*/\n+\n+static void writeNspace (unsigned int n);\n+\n+/*\n+   DumpStringInfo -\n+*/\n+\n+static void DumpStringInfo (DynamicStrings_String s, unsigned int i);\n+\n+/*\n+   DumpStringInfo -\n+*/\n+\n+static void stop (void);\n+\n+/*\n+   doDSdbEnter -\n+*/\n+\n+static void doDSdbEnter (void);\n+\n+/*\n+   doDSdbExit -\n+*/\n+\n+static void doDSdbExit (DynamicStrings_String s);\n+\n+/*\n+   DSdbEnter -\n+*/\n+\n+static void DSdbEnter (void);\n+\n+/*\n+   DSdbExit -\n+*/\n+\n+static void DSdbExit (DynamicStrings_String s);\n+static unsigned int Capture (DynamicStrings_String s);\n+\n+/*\n+   Min -\n+*/\n+\n+static unsigned int Min (unsigned int a, unsigned int b);\n+\n+/*\n+   Max -\n+*/\n+\n+static unsigned int Max (unsigned int a, unsigned int b);\n+\n+/*\n+   writeString - writes a string to stdout.\n+*/\n+\n+static void writeString (const char *a_, unsigned int _a_high);\n+\n+/*\n+   writeCstring - writes a C string to stdout.\n+*/\n+\n+static void writeCstring (void * a);\n+\n+/*\n+   writeCard -\n+*/\n+\n+static void writeCard (unsigned int c);\n+\n+/*\n+   writeLongcard -\n+*/\n+\n+static void writeLongcard (long unsigned int l);\n+\n+/*\n+   writeAddress -\n+*/\n+\n+static void writeAddress (void * a);\n+\n+/*\n+   writeLn - writes a newline.\n+*/\n+\n+static void writeLn (void);\n+\n+/*\n+   AssignDebug - assigns, file, and, line, information to string, s.\n+*/\n+\n+static DynamicStrings_String AssignDebug (DynamicStrings_String s, const char *file_, unsigned int _file_high, unsigned int line, const char *proc_, unsigned int _proc_high);\n+\n+/*\n+   IsOn - returns TRUE if, s, is on one of the debug lists.\n+*/\n+\n+static unsigned int IsOn (DynamicStrings_String list, DynamicStrings_String s);\n+\n+/*\n+   AddTo - adds string, s, to, list.\n+*/\n+\n+static void AddTo (DynamicStrings_String *list, DynamicStrings_String s);\n+\n+/*\n+   SubFrom - removes string, s, from, list.\n+*/\n+\n+static void SubFrom (DynamicStrings_String *list, DynamicStrings_String s);\n+\n+/*\n+   AddAllocated - adds string, s, to the head of the allocated list.\n+*/\n+\n+static void AddAllocated (DynamicStrings_String s);\n+\n+/*\n+   AddDeallocated - adds string, s, to the head of the deallocated list.\n+*/\n+\n+static void AddDeallocated (DynamicStrings_String s);\n+\n+/*\n+   IsOnAllocated - returns TRUE if the string, s, has ever been allocated.\n+*/\n+\n+static unsigned int IsOnAllocated (DynamicStrings_String s);\n+\n+/*\n+   IsOnDeallocated - returns TRUE if the string, s, has ever been deallocated.\n+*/\n+\n+static unsigned int IsOnDeallocated (DynamicStrings_String s);\n+\n+/*\n+   SubAllocated - removes string, s, from the list of allocated strings.\n+*/\n+\n+static void SubAllocated (DynamicStrings_String s);\n+\n+/*\n+   SubDeallocated - removes string, s, from the list of deallocated strings.\n+*/\n+\n+static void SubDeallocated (DynamicStrings_String s);\n+\n+/*\n+   SubDebugInfo - removes string, s, from the list of allocated strings.\n+*/\n+\n+static void SubDebugInfo (DynamicStrings_String s);\n+\n+/*\n+   AddDebugInfo - adds string, s, to the list of allocated strings.\n+*/\n+\n+static void AddDebugInfo (DynamicStrings_String s);\n+\n+/*\n+   ConcatContents - add the contents of string, a, where, h, is the\n+                    total length of, a. The offset is in, o.\n+*/\n+\n+static void ConcatContents (DynamicStrings_Contents *c, const char *a_, unsigned int _a_high, unsigned int h, unsigned int o);\n+\n+/*\n+   DeallocateCharStar - deallocates any charStar.\n+*/\n+\n+static void DeallocateCharStar (DynamicStrings_String s);\n+\n+/*\n+   CheckPoisoned - checks for a poisoned string, s.\n+*/\n+\n+static DynamicStrings_String CheckPoisoned (DynamicStrings_String s);\n+\n+/*\n+   MarkInvalid - marks the char * version of String, s, as invalid.\n+*/\n+\n+static void MarkInvalid (DynamicStrings_String s);\n+\n+/*\n+   ConcatContentsAddress - concatenate the string, a, where, h, is the\n+                           total length of, a.\n+*/\n+\n+static void ConcatContentsAddress (DynamicStrings_Contents *c, void * a, unsigned int h);\n+\n+/*\n+   AddToGarbage - adds String, b, onto the garbage list of, a.  Providing\n+                  the state of b is marked.  The state is then altered to\n+                  onlist.  String, a, is returned.\n+*/\n+\n+static DynamicStrings_String AddToGarbage (DynamicStrings_String a, DynamicStrings_String b);\n+\n+/*\n+   IsOnGarbage - returns TRUE if, s, is on string, e, garbage list.\n+*/\n+\n+static unsigned int IsOnGarbage (DynamicStrings_String e, DynamicStrings_String s);\n+\n+/*\n+   IsWhite - returns TRUE if, ch, is a space or a tab.\n+*/\n+\n+static unsigned int IsWhite (char ch);\n+\n+/*\n+   DumpState -\n+*/\n+\n+static void DumpState (DynamicStrings_String s);\n+\n+/*\n+   DumpStringSynopsis -\n+*/\n+\n+static void DumpStringSynopsis (DynamicStrings_String s);\n+\n+/*\n+   DumpString - displays the contents of string, s.\n+*/\n+\n+static void DumpString (DynamicStrings_String s);\n+\n+/*\n+   Init - initialize the module.\n+*/\n+\n+static void Init (void);\n+\n+\n+/*\n+ writeStringDesc write out debugging information about string, s.  */\n+\n+static void writeStringDesc (DynamicStrings_String s)\n+{\n+  writeCstring (s->debug.file);\n+  writeString ((const char *) \":\", 1);\n+  writeCard (s->debug.line);\n+  writeString ((const char *) \":\", 1);\n+  writeCstring (s->debug.proc);\n+  writeString ((const char *) \" \", 1);\n+  writeAddress (reinterpret_cast<void *> (s));\n+  writeString ((const char *) \" \", 1);\n+  switch (s->head->state)\n+    {\n+      case DynamicStrings_inuse:\n+        writeString ((const char *) \"still in use (\", 14);\n+        writeCard (s->contents.len);\n+        writeString ((const char *) \") characters\", 12);\n+        break;\n+\n+      case DynamicStrings_marked:\n+        writeString ((const char *) \"marked\", 6);\n+        break;\n+\n+      case DynamicStrings_onlist:\n+        writeString ((const char *) \"on a (lost) garbage list\", 24);\n+        break;\n+\n+      case DynamicStrings_poisoned:\n+        writeString ((const char *) \"poisoned\", 8);\n+        break;\n+\n+\n+      default:\n+        writeString ((const char *) \"unknown state\", 13);\n+        break;\n+    }\n+}\n+\n+\n+/*\n+   writeNspace -\n+*/\n+\n+static void writeNspace (unsigned int n)\n+{\n+  while (n > 0)\n+    {\n+      writeString ((const char *) \" \", 1);\n+      n -= 1;\n+    }\n+}\n+\n+\n+/*\n+   DumpStringInfo -\n+*/\n+\n+static void DumpStringInfo (DynamicStrings_String s, unsigned int i)\n+{\n+  DynamicStrings_String t;\n+\n+  if (s != NULL)\n+    {\n+      writeNspace (i);\n+      writeStringDesc (s);\n+      writeLn ();\n+      if (s->head->garbage != NULL)\n+        {\n+          writeNspace (i);\n+          writeString ((const char *) \"garbage list:\", 13);\n+          writeLn ();\n+          do {\n+            s = s->head->garbage;\n+            DumpStringInfo (s, i+1);\n+            writeLn ();\n+          } while (! (s == NULL));\n+        }\n+    }\n+}\n+\n+\n+/*\n+   DumpStringInfo -\n+*/\n+\n+static void stop (void)\n+{\n+}\n+\n+\n+/*\n+   doDSdbEnter -\n+*/\n+\n+static void doDSdbEnter (void)\n+{\n+  if (CheckOn)\n+    {\n+      DynamicStrings_PushAllocation ();\n+    }\n+}\n+\n+\n+/*\n+   doDSdbExit -\n+*/\n+\n+static void doDSdbExit (DynamicStrings_String s)\n+{\n+  if (CheckOn)\n+    {\n+      s = DynamicStrings_PopAllocationExemption (TRUE, s);\n+    }\n+}\n+\n+\n+/*\n+   DSdbEnter -\n+*/\n+\n+static void DSdbEnter (void)\n+{\n+}\n+\n+\n+/*\n+   DSdbExit -\n+*/\n+\n+static void DSdbExit (DynamicStrings_String s)\n+{\n+}\n+\n+static unsigned int Capture (DynamicStrings_String s)\n+{\n+  /* \n+ *   #undef GM2_DEBUG_DYNAMICSTINGS\n+ *   #if defined(GM2_DEBUG_DYNAMICSTINGS)\n+ *   #  define DSdbEnter doDSdbEnter\n+ *   #  define DSdbExit  doDSdbExit\n+ *   #  define CheckOn   TRUE\n+ *   #  define TraceOn   TRUE\n+ *   #endif\n+  */\n+  captured = s;\n+  return 1;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Min -\n+*/\n+\n+static unsigned int Min (unsigned int a, unsigned int b)\n+{\n+  if (a < b)\n+    {\n+      return a;\n+    }\n+  else\n+    {\n+      return b;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Max -\n+*/\n+\n+static unsigned int Max (unsigned int a, unsigned int b)\n+{\n+  if (a > b)\n+    {\n+      return a;\n+    }\n+  else\n+    {\n+      return b;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   writeString - writes a string to stdout.\n+*/\n+\n+static void writeString (const char *a_, unsigned int _a_high)\n+{\n+  int i;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  i = static_cast<int> (libc_write (1, &a, static_cast<size_t> (StrLib_StrLen ((const char *) a, _a_high))));\n+}\n+\n+\n+/*\n+   writeCstring - writes a C string to stdout.\n+*/\n+\n+static void writeCstring (void * a)\n+{\n+  int i;\n+\n+  if (a == NULL)\n+    {\n+      writeString ((const char *) \"(null)\", 6);\n+    }\n+  else\n+    {\n+      i = static_cast<int> (libc_write (1, a, libc_strlen (a)));\n+    }\n+}\n+\n+\n+/*\n+   writeCard -\n+*/\n+\n+static void writeCard (unsigned int c)\n+{\n+  char ch;\n+  int i;\n+\n+  if (c > 9)\n+    {\n+      writeCard (c / 10);\n+      writeCard (c % 10);\n+    }\n+  else\n+    {\n+      ch = ((char) ( ((unsigned int) ('0'))+c));\n+      i = static_cast<int> (libc_write (1, &ch, static_cast<size_t> (1)));\n+    }\n+}\n+\n+\n+/*\n+   writeLongcard -\n+*/\n+\n+static void writeLongcard (long unsigned int l)\n+{\n+  char ch;\n+  int i;\n+\n+  if (l > 16)\n+    {\n+      writeLongcard (l / 16);\n+      writeLongcard (l % 16);\n+    }\n+  else if (l < 10)\n+    {\n+      /* avoid dangling else.  */\n+      ch = ((char) ( ((unsigned int) ('0'))+((unsigned int ) (l))));\n+      i = static_cast<int> (libc_write (1, &ch, static_cast<size_t> (1)));\n+    }\n+  else if (l < 16)\n+    {\n+      /* avoid dangling else.  */\n+      ch = ((char) (( ((unsigned int) ('a'))+((unsigned int ) (l)))-10));\n+      i = static_cast<int> (libc_write (1, &ch, static_cast<size_t> (1)));\n+    }\n+}\n+\n+\n+/*\n+   writeAddress -\n+*/\n+\n+static void writeAddress (void * a)\n+{\n+  writeLongcard ((long unsigned int ) (a));\n+}\n+\n+\n+/*\n+   writeLn - writes a newline.\n+*/\n+\n+static void writeLn (void)\n+{\n+  char ch;\n+  int i;\n+\n+  ch = ASCII_lf;\n+  i = static_cast<int> (libc_write (1, &ch, static_cast<size_t> (1)));\n+}\n+\n+\n+/*\n+   AssignDebug - assigns, file, and, line, information to string, s.\n+*/\n+\n+static DynamicStrings_String AssignDebug (DynamicStrings_String s, const char *file_, unsigned int _file_high, unsigned int line, const char *proc_, unsigned int _proc_high)\n+{\n+  void * f;\n+  void * p;\n+  char file[_file_high+1];\n+  char proc[_proc_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (file, file_, _file_high+1);\n+  memcpy (proc, proc_, _proc_high+1);\n+\n+  f = &file;\n+  p = &proc;\n+  Storage_ALLOCATE (&s->debug.file, (StrLib_StrLen ((const char *) file, _file_high))+1);\n+  if ((libc_strncpy (s->debug.file, f, (StrLib_StrLen ((const char *) file, _file_high))+1)) == NULL)\n+    {}  /* empty.  */\n+  s->debug.line = line;\n+  Storage_ALLOCATE (&s->debug.proc, (StrLib_StrLen ((const char *) proc, _proc_high))+1);\n+  if ((libc_strncpy (s->debug.proc, p, (StrLib_StrLen ((const char *) proc, _proc_high))+1)) == NULL)\n+    {}  /* empty.  */\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   IsOn - returns TRUE if, s, is on one of the debug lists.\n+*/\n+\n+static unsigned int IsOn (DynamicStrings_String list, DynamicStrings_String s)\n+{\n+  while ((list != s) && (list != NULL))\n+    {\n+      list = list->debug.next;\n+    }\n+  return list == s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   AddTo - adds string, s, to, list.\n+*/\n+\n+static void AddTo (DynamicStrings_String *list, DynamicStrings_String s)\n+{\n+  if ((*list) == NULL)\n+    {\n+      (*list) = s;\n+      s->debug.next = NULL;\n+    }\n+  else\n+    {\n+      s->debug.next = (*list);\n+      (*list) = s;\n+    }\n+}\n+\n+\n+/*\n+   SubFrom - removes string, s, from, list.\n+*/\n+\n+static void SubFrom (DynamicStrings_String *list, DynamicStrings_String s)\n+{\n+  DynamicStrings_String p;\n+\n+  if ((*list) == s)\n+    {\n+      (*list) = s->debug.next;\n+    }\n+  else\n+    {\n+      p = (*list);\n+      while ((p->debug.next != NULL) && (p->debug.next != s))\n+        {\n+          p = p->debug.next;\n+        }\n+      if (p->debug.next == s)\n+        {\n+          p->debug.next = s->debug.next;\n+        }\n+      else\n+        {\n+          /* not found, quit  */\n+          return ;\n+        }\n+    }\n+  s->debug.next = NULL;\n+}\n+\n+\n+/*\n+   AddAllocated - adds string, s, to the head of the allocated list.\n+*/\n+\n+static void AddAllocated (DynamicStrings_String s)\n+{\n+  Init ();\n+  AddTo (&frameHead->alloc, s);\n+}\n+\n+\n+/*\n+   AddDeallocated - adds string, s, to the head of the deallocated list.\n+*/\n+\n+static void AddDeallocated (DynamicStrings_String s)\n+{\n+  Init ();\n+  AddTo (&frameHead->dealloc, s);\n+}\n+\n+\n+/*\n+   IsOnAllocated - returns TRUE if the string, s, has ever been allocated.\n+*/\n+\n+static unsigned int IsOnAllocated (DynamicStrings_String s)\n+{\n+  DynamicStrings_frame f;\n+\n+  Init ();\n+  f = frameHead;\n+  do {\n+    if (IsOn (f->alloc, s))\n+      {\n+        return TRUE;\n+      }\n+    else\n+      {\n+        f = f->next;\n+      }\n+  } while (! (f == NULL));\n+  return FALSE;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   IsOnDeallocated - returns TRUE if the string, s, has ever been deallocated.\n+*/\n+\n+static unsigned int IsOnDeallocated (DynamicStrings_String s)\n+{\n+  DynamicStrings_frame f;\n+\n+  Init ();\n+  f = frameHead;\n+  do {\n+    if (IsOn (f->dealloc, s))\n+      {\n+        return TRUE;\n+      }\n+    else\n+      {\n+        f = f->next;\n+      }\n+  } while (! (f == NULL));\n+  return FALSE;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   SubAllocated - removes string, s, from the list of allocated strings.\n+*/\n+\n+static void SubAllocated (DynamicStrings_String s)\n+{\n+  DynamicStrings_frame f;\n+\n+  Init ();\n+  f = frameHead;\n+  do {\n+    if (IsOn (f->alloc, s))\n+      {\n+        SubFrom (&f->alloc, s);\n+        return ;\n+      }\n+    else\n+      {\n+        f = f->next;\n+      }\n+  } while (! (f == NULL));\n+}\n+\n+\n+/*\n+   SubDeallocated - removes string, s, from the list of deallocated strings.\n+*/\n+\n+static void SubDeallocated (DynamicStrings_String s)\n+{\n+  DynamicStrings_frame f;\n+\n+  Init ();\n+  f = frameHead;\n+  do {\n+    if (IsOn (f->dealloc, s))\n+      {\n+        SubFrom (&f->dealloc, s);\n+        return ;\n+      }\n+    else\n+      {\n+        f = f->next;\n+      }\n+  } while (! (f == NULL));\n+}\n+\n+\n+/*\n+   SubDebugInfo - removes string, s, from the list of allocated strings.\n+*/\n+\n+static void SubDebugInfo (DynamicStrings_String s)\n+{\n+  if (IsOnDeallocated (s))\n+    {\n+      Assertion_Assert (! DebugOn);\n+      /* string has already been deallocated  */\n+      return ;\n+    }\n+  if (IsOnAllocated (s))\n+    {\n+      SubAllocated (s);\n+      AddDeallocated (s);\n+    }\n+  else\n+    {\n+      /* string has not been allocated  */\n+      Assertion_Assert (! DebugOn);\n+    }\n+}\n+\n+\n+/*\n+   AddDebugInfo - adds string, s, to the list of allocated strings.\n+*/\n+\n+static void AddDebugInfo (DynamicStrings_String s)\n+{\n+  s->debug.next = NULL;\n+  s->debug.file = NULL;\n+  s->debug.line = 0;\n+  s->debug.proc = NULL;\n+  if (CheckOn)\n+    {\n+      AddAllocated (s);\n+    }\n+}\n+\n+\n+/*\n+   ConcatContents - add the contents of string, a, where, h, is the\n+                    total length of, a. The offset is in, o.\n+*/\n+\n+static void ConcatContents (DynamicStrings_Contents *c, const char *a_, unsigned int _a_high, unsigned int h, unsigned int o)\n+{\n+  unsigned int i;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  i = (*c).len;\n+  while ((o < h) && (i < MaxBuf))\n+    {\n+      (*c).buf.array[i] = a[o];\n+      o += 1;\n+      i += 1;\n+    }\n+  if (o < h)\n+    {\n+      (*c).len = MaxBuf;\n+      Storage_ALLOCATE ((void **) &(*c).next, sizeof (DynamicStrings_stringRecord));\n+      (*c).next->head = NULL;\n+      (*c).next->contents.len = 0;\n+      (*c).next->contents.next = NULL;\n+      ConcatContents (&(*c).next->contents, (const char *) a, _a_high, h, o);\n+      AddDebugInfo ((*c).next);\n+      (*c).next = AssignDebug ((*c).next, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 722, (const char *) \"ConcatContents\", 14);\n+    }\n+  else\n+    {\n+      (*c).len = i;\n+    }\n+}\n+\n+\n+/*\n+   DeallocateCharStar - deallocates any charStar.\n+*/\n+\n+static void DeallocateCharStar (DynamicStrings_String s)\n+{\n+  if ((s != NULL) && (s->head != NULL))\n+    {\n+      if (s->head->charStarUsed && (s->head->charStar != NULL))\n+        {\n+          Storage_DEALLOCATE (&s->head->charStar, s->head->charStarSize);\n+        }\n+      s->head->charStarUsed = FALSE;\n+      s->head->charStar = NULL;\n+      s->head->charStarSize = 0;\n+      s->head->charStarValid = FALSE;\n+    }\n+}\n+\n+\n+/*\n+   CheckPoisoned - checks for a poisoned string, s.\n+*/\n+\n+static DynamicStrings_String CheckPoisoned (DynamicStrings_String s)\n+{\n+  if (((PoisonOn && (s != NULL)) && (s->head != NULL)) && (s->head->state == DynamicStrings_poisoned))\n+    {\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   MarkInvalid - marks the char * version of String, s, as invalid.\n+*/\n+\n+static void MarkInvalid (DynamicStrings_String s)\n+{\n+  if (PoisonOn)\n+    {\n+      s = CheckPoisoned (s);\n+    }\n+  if (s->head != NULL)\n+    {\n+      s->head->charStarValid = FALSE;\n+    }\n+}\n+\n+\n+/*\n+   ConcatContentsAddress - concatenate the string, a, where, h, is the\n+                           total length of, a.\n+*/\n+\n+static void ConcatContentsAddress (DynamicStrings_Contents *c, void * a, unsigned int h)\n+{\n+  typedef char *ConcatContentsAddress__T1;\n+\n+  ConcatContentsAddress__T1 p;\n+  unsigned int i;\n+  unsigned int j;\n+\n+  j = 0;\n+  i = (*c).len;\n+  p = static_cast<ConcatContentsAddress__T1> (a);\n+  while ((j < h) && (i < MaxBuf))\n+    {\n+      (*c).buf.array[i] = (*p);\n+      i += 1;\n+      j += 1;\n+      p += 1;\n+    }\n+  if (j < h)\n+    {\n+      /* avoid dangling else.  */\n+      (*c).len = MaxBuf;\n+      Storage_ALLOCATE ((void **) &(*c).next, sizeof (DynamicStrings_stringRecord));\n+      (*c).next->head = NULL;\n+      (*c).next->contents.len = 0;\n+      (*c).next->contents.next = NULL;\n+      ConcatContentsAddress (&(*c).next->contents, reinterpret_cast<void *> (p), h-j);\n+      AddDebugInfo ((*c).next);\n+      if (TraceOn)\n+        {\n+          (*c).next = AssignDebug ((*c).next, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 917, (const char *) \"ConcatContentsAddress\", 21);\n+        }\n+    }\n+  else\n+    {\n+      (*c).len = i;\n+      (*c).next = NULL;\n+    }\n+}\n+\n+\n+/*\n+   AddToGarbage - adds String, b, onto the garbage list of, a.  Providing\n+                  the state of b is marked.  The state is then altered to\n+                  onlist.  String, a, is returned.\n+*/\n+\n+static DynamicStrings_String AddToGarbage (DynamicStrings_String a, DynamicStrings_String b)\n+{\n+  DynamicStrings_String c;\n+\n+  if (PoisonOn)\n+    {\n+      a = CheckPoisoned (a);\n+      b = CheckPoisoned (b);\n+    }\n+  /* \n+   IF (a#NIL) AND (a#b) AND (a^.head^.state=marked)\n+   THEN\n+      writeString('warning trying to add to a marked string') ; writeLn\n+   END ;\n+  */\n+  if (((((a != b) && (a != NULL)) && (b != NULL)) && (b->head->state == DynamicStrings_marked)) && (a->head->state == DynamicStrings_inuse))\n+    {\n+      c = a;\n+      while (c->head->garbage != NULL)\n+        {\n+          c = c->head->garbage;\n+        }\n+      c->head->garbage = b;\n+      b->head->state = DynamicStrings_onlist;\n+      if (CheckOn)\n+        {\n+          SubDebugInfo (b);\n+        }\n+    }\n+  return a;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   IsOnGarbage - returns TRUE if, s, is on string, e, garbage list.\n+*/\n+\n+static unsigned int IsOnGarbage (DynamicStrings_String e, DynamicStrings_String s)\n+{\n+  if ((e != NULL) && (s != NULL))\n+    {\n+      while (e->head->garbage != NULL)\n+        {\n+          if (e->head->garbage == s)\n+            {\n+              return TRUE;\n+            }\n+          else\n+            {\n+              e = e->head->garbage;\n+            }\n+        }\n+    }\n+  return FALSE;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   IsWhite - returns TRUE if, ch, is a space or a tab.\n+*/\n+\n+static unsigned int IsWhite (char ch)\n+{\n+  return (ch == ' ') || (ch == ASCII_tab);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   DumpState -\n+*/\n+\n+static void DumpState (DynamicStrings_String s)\n+{\n+  switch (s->head->state)\n+    {\n+      case DynamicStrings_inuse:\n+        writeString ((const char *) \"still in use (\", 14);\n+        writeCard (s->contents.len);\n+        writeString ((const char *) \") characters\", 12);\n+        break;\n+\n+      case DynamicStrings_marked:\n+        writeString ((const char *) \"marked\", 6);\n+        break;\n+\n+      case DynamicStrings_onlist:\n+        writeString ((const char *) \"on a garbage list\", 17);\n+        break;\n+\n+      case DynamicStrings_poisoned:\n+        writeString ((const char *) \"poisoned\", 8);\n+        break;\n+\n+\n+      default:\n+        writeString ((const char *) \"unknown state\", 13);\n+        break;\n+    }\n+}\n+\n+\n+/*\n+   DumpStringSynopsis -\n+*/\n+\n+static void DumpStringSynopsis (DynamicStrings_String s)\n+{\n+  writeCstring (s->debug.file);\n+  writeString ((const char *) \":\", 1);\n+  writeCard (s->debug.line);\n+  writeString ((const char *) \":\", 1);\n+  writeCstring (s->debug.proc);\n+  writeString ((const char *) \" string \", 8);\n+  writeAddress (reinterpret_cast<void *> (s));\n+  writeString ((const char *) \" \", 1);\n+  DumpState (s);\n+  if (IsOnAllocated (s))\n+    {\n+      writeString ((const char *) \" globally allocated\", 19);\n+    }\n+  else if (IsOnDeallocated (s))\n+    {\n+      /* avoid dangling else.  */\n+      writeString ((const char *) \" globally deallocated\", 21);\n+    }\n+  else\n+    {\n+      /* avoid dangling else.  */\n+      writeString ((const char *) \" globally unknown\", 17);\n+    }\n+  writeLn ();\n+}\n+\n+\n+/*\n+   DumpString - displays the contents of string, s.\n+*/\n+\n+static void DumpString (DynamicStrings_String s)\n+{\n+  DynamicStrings_String t;\n+\n+  if (s != NULL)\n+    {\n+      DumpStringSynopsis (s);\n+      if ((s->head != NULL) && (s->head->garbage != NULL))\n+        {\n+          writeString ((const char *) \"display chained strings on the garbage list\", 43);\n+          writeLn ();\n+          t = s->head->garbage;\n+          while (t != NULL)\n+            {\n+              DumpStringSynopsis (t);\n+              t = t->head->garbage;\n+            }\n+        }\n+    }\n+}\n+\n+\n+/*\n+   Init - initialize the module.\n+*/\n+\n+static void Init (void)\n+{\n+  if (! Initialized)\n+    {\n+      Initialized = TRUE;\n+      frameHead = NULL;\n+      DynamicStrings_PushAllocation ();\n+    }\n+}\n+\n+\n+/*\n+   InitString - creates and returns a String type object.\n+                Initial contents are, a.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_InitString (const char *a_, unsigned int _a_high)\n+{\n+  DynamicStrings_String s;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  Storage_ALLOCATE ((void **) &s, sizeof (DynamicStrings_stringRecord));\n+  s->contents.len = 0;\n+  s->contents.next = NULL;\n+  ConcatContents (&s->contents, (const char *) a, _a_high, StrLib_StrLen ((const char *) a, _a_high), 0);\n+  Storage_ALLOCATE ((void **) &s->head, sizeof (DynamicStrings_descriptor));\n+  s->head->charStarUsed = FALSE;\n+  s->head->charStar = NULL;\n+  s->head->charStarSize = 0;\n+  s->head->charStarValid = FALSE;\n+  s->head->garbage = NULL;\n+  s->head->state = DynamicStrings_inuse;\n+  AddDebugInfo (s);\n+  if (TraceOn)\n+    {\n+      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 758, (const char *) \"InitString\", 10);\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   KillString - frees String, s, and its contents.\n+                NIL is returned.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_KillString (DynamicStrings_String s)\n+{\n+  DynamicStrings_String t;\n+\n+  if (PoisonOn)\n+    {\n+      s = CheckPoisoned (s);\n+    }\n+  if (s != NULL)\n+    {\n+      if (CheckOn)\n+        {\n+          /* avoid gcc warning by using compound statement even if not strictly necessary.  */\n+          if (IsOnAllocated (s))\n+            {\n+              SubAllocated (s);\n+            }\n+          else if (IsOnDeallocated (s))\n+            {\n+              /* avoid dangling else.  */\n+              SubDeallocated (s);\n+            }\n+        }\n+      if (s->head != NULL)\n+        {\n+          s->head->state = DynamicStrings_poisoned;\n+          s->head->garbage = DynamicStrings_KillString (s->head->garbage);\n+          if (! PoisonOn)\n+            {\n+              DeallocateCharStar (s);\n+            }\n+          if (! PoisonOn)\n+            {\n+              Storage_DEALLOCATE ((void **) &s->head, sizeof (DynamicStrings_descriptor));\n+              s->head = NULL;\n+            }\n+        }\n+      t = DynamicStrings_KillString (s->contents.next);\n+      if (! PoisonOn)\n+        {\n+          Storage_DEALLOCATE ((void **) &s, sizeof (DynamicStrings_stringRecord));\n+        }\n+    }\n+  return NULL;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Fin - finishes with a string, it calls KillString with, s.\n+         The purpose of the procedure is to provide a short cut\n+         to calling KillString and then testing the return result.\n+*/\n+\n+extern \"C\" void DynamicStrings_Fin (DynamicStrings_String s)\n+{\n+  if ((DynamicStrings_KillString (s)) != NULL)\n+    {\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n+    }\n+}\n+\n+\n+/*\n+   InitStringCharStar - initializes and returns a String to contain the C string.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_InitStringCharStar (void * a)\n+{\n+  DynamicStrings_String s;\n+\n+  Storage_ALLOCATE ((void **) &s, sizeof (DynamicStrings_stringRecord));\n+  s->contents.len = 0;\n+  s->contents.next = NULL;\n+  if (a != NULL)\n+    {\n+      ConcatContentsAddress (&s->contents, a, static_cast<unsigned int> (libc_strlen (a)));\n+    }\n+  Storage_ALLOCATE ((void **) &s->head, sizeof (DynamicStrings_descriptor));\n+  s->head->charStarUsed = FALSE;\n+  s->head->charStar = NULL;\n+  s->head->charStarSize = 0;\n+  s->head->charStarValid = FALSE;\n+  s->head->garbage = NULL;\n+  s->head->state = DynamicStrings_inuse;\n+  AddDebugInfo (s);\n+  if (TraceOn)\n+    {\n+      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 957, (const char *) \"InitStringCharStar\", 18);\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   InitStringChar - initializes and returns a String to contain the single character, ch.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_InitStringChar (char ch)\n+{\n+  typedef struct InitStringChar__T4_a InitStringChar__T4;\n+\n+  struct InitStringChar__T4_a { char array[1+1]; };\n+  InitStringChar__T4 a;\n+  DynamicStrings_String s;\n+\n+  a.array[0] = ch;\n+  a.array[1] = ASCII_nul;\n+  s = DynamicStrings_InitString ((const char *) &a.array[0], 1);\n+  if (TraceOn)\n+    {\n+      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 977, (const char *) \"InitStringChar\", 14);\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Mark - marks String, s, ready for garbage collection.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_Mark (DynamicStrings_String s)\n+{\n+  if (PoisonOn)\n+    {\n+      s = CheckPoisoned (s);\n+    }\n+  if ((s != NULL) && (s->head->state == DynamicStrings_inuse))\n+    {\n+      s->head->state = DynamicStrings_marked;\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Length - returns the length of the String, s.\n+*/\n+\n+extern \"C\" unsigned int DynamicStrings_Length (DynamicStrings_String s)\n+{\n+  if (s == NULL)\n+    {\n+      return 0;\n+    }\n+  else\n+    {\n+      return s->contents.len+(DynamicStrings_Length (s->contents.next));\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   ConCat - returns String, a, after the contents of, b, have been appended.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_ConCat (DynamicStrings_String a, DynamicStrings_String b)\n+{\n+  DynamicStrings_String t;\n+\n+  if (PoisonOn)\n+    {\n+      a = CheckPoisoned (a);\n+      b = CheckPoisoned (b);\n+    }\n+  if (a == b)\n+    {\n+      return DynamicStrings_ConCat (a, DynamicStrings_Mark (DynamicStrings_Dup (b)));\n+    }\n+  else if (a != NULL)\n+    {\n+      /* avoid dangling else.  */\n+      a = AddToGarbage (a, b);\n+      MarkInvalid (a);\n+      t = a;\n+      while (b != NULL)\n+        {\n+          while ((t->contents.len == MaxBuf) && (t->contents.next != NULL))\n+            {\n+              t = t->contents.next;\n+            }\n+          ConcatContents (&t->contents, (const char *) &b->contents.buf.array[0], (MaxBuf-1), b->contents.len, 0);\n+          b = b->contents.next;\n+        }\n+    }\n+  if ((a == NULL) && (b != NULL))\n+    {\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n+    }\n+  return a;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   ConCatChar - returns String, a, after character, ch, has been appended.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_ConCatChar (DynamicStrings_String a, char ch)\n+{\n+  typedef struct ConCatChar__T5_a ConCatChar__T5;\n+\n+  struct ConCatChar__T5_a { char array[1+1]; };\n+  ConCatChar__T5 b;\n+  DynamicStrings_String t;\n+\n+  if (PoisonOn)\n+    {\n+      a = CheckPoisoned (a);\n+    }\n+  b.array[0] = ch;\n+  b.array[1] = ASCII_nul;\n+  t = a;\n+  MarkInvalid (a);\n+  while ((t->contents.len == MaxBuf) && (t->contents.next != NULL))\n+    {\n+      t = t->contents.next;\n+    }\n+  ConcatContents (&t->contents, (const char *) &b.array[0], 1, 1, 0);\n+  return a;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Assign - assigns the contents of, b, into, a.\n+            String, a, is returned.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_Assign (DynamicStrings_String a, DynamicStrings_String b)\n+{\n+  if (PoisonOn)\n+    {\n+      a = CheckPoisoned (a);\n+      b = CheckPoisoned (b);\n+    }\n+  if ((a != NULL) && (b != NULL))\n+    {\n+      a->contents.next = DynamicStrings_KillString (a->contents.next);\n+      a->contents.len = 0;\n+    }\n+  return DynamicStrings_ConCat (a, b);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Dup - duplicate a String, s, returning the copy of s.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_Dup (DynamicStrings_String s)\n+{\n+  if (PoisonOn)\n+    {\n+      s = CheckPoisoned (s);\n+    }\n+  s = DynamicStrings_Assign (DynamicStrings_InitString ((const char *) \"\", 0), s);\n+  if (TraceOn)\n+    {\n+      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1173, (const char *) \"Dup\", 3);\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Add - returns a new String which contains the contents of a and b.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_Add (DynamicStrings_String a, DynamicStrings_String b)\n+{\n+  if (PoisonOn)\n+    {\n+      a = CheckPoisoned (a);\n+      b = CheckPoisoned (b);\n+    }\n+  a = DynamicStrings_ConCat (DynamicStrings_ConCat (DynamicStrings_InitString ((const char *) \"\", 0), a), b);\n+  if (TraceOn)\n+    {\n+      a = AssignDebug (a, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1193, (const char *) \"Add\", 3);\n+    }\n+  return a;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Equal - returns TRUE if String, a, and, b, are equal.\n+*/\n+\n+extern \"C\" unsigned int DynamicStrings_Equal (DynamicStrings_String a, DynamicStrings_String b)\n+{\n+  unsigned int i;\n+\n+  if (PoisonOn)\n+    {\n+      a = CheckPoisoned (a);\n+      b = CheckPoisoned (b);\n+    }\n+  if ((DynamicStrings_Length (a)) == (DynamicStrings_Length (b)))\n+    {\n+      while ((a != NULL) && (b != NULL))\n+        {\n+          i = 0;\n+          Assertion_Assert (a->contents.len == b->contents.len);\n+          while (i < a->contents.len)\n+            {\n+              if (a->contents.buf.array[i] != b->contents.buf.array[i])\n+                {\n+                  return FALSE;\n+                }\n+              i += 1;\n+            }\n+          a = a->contents.next;\n+          b = b->contents.next;\n+        }\n+      return TRUE;\n+    }\n+  else\n+    {\n+      return FALSE;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   EqualCharStar - returns TRUE if contents of String, s, is the same as the\n+                   string, a.\n+*/\n+\n+extern \"C\" unsigned int DynamicStrings_EqualCharStar (DynamicStrings_String s, void * a)\n+{\n+  DynamicStrings_String t;\n+\n+  if (PoisonOn)\n+    {\n+      s = CheckPoisoned (s);\n+    }\n+  t = DynamicStrings_InitStringCharStar (a);\n+  if (TraceOn)\n+    {\n+      t = AssignDebug (t, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1250, (const char *) \"EqualCharStar\", 13);\n+    }\n+  t = AddToGarbage (t, s);\n+  if (DynamicStrings_Equal (t, s))\n+    {\n+      t = DynamicStrings_KillString (t);\n+      return TRUE;\n+    }\n+  else\n+    {\n+      t = DynamicStrings_KillString (t);\n+      return FALSE;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   EqualArray - returns TRUE if contents of String, s, is the same as the\n+                string, a.\n+*/\n+\n+extern \"C\" unsigned int DynamicStrings_EqualArray (DynamicStrings_String s, const char *a_, unsigned int _a_high)\n+{\n+  DynamicStrings_String t;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  if (PoisonOn)\n+    {\n+      s = CheckPoisoned (s);\n+    }\n+  t = DynamicStrings_InitString ((const char *) a, _a_high);\n+  if (TraceOn)\n+    {\n+      t = AssignDebug (t, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1280, (const char *) \"EqualArray\", 10);\n+    }\n+  t = AddToGarbage (t, s);\n+  if (DynamicStrings_Equal (t, s))\n+    {\n+      t = DynamicStrings_KillString (t);\n+      return TRUE;\n+    }\n+  else\n+    {\n+      t = DynamicStrings_KillString (t);\n+      return FALSE;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Mult - returns a new string which is n concatenations of String, s.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_Mult (DynamicStrings_String s, unsigned int n)\n+{\n+  if (PoisonOn)\n+    {\n+      s = CheckPoisoned (s);\n+    }\n+  if (n <= 0)\n+    {\n+      s = AddToGarbage (DynamicStrings_InitString ((const char *) \"\", 0), s);\n+    }\n+  else\n+    {\n+      s = DynamicStrings_ConCat (DynamicStrings_Mult (s, n-1), s);\n+    }\n+  if (TraceOn)\n+    {\n+      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1312, (const char *) \"Mult\", 4);\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Slice - returns a new string which contains the elements\n+           low..high-1\n+\n+           strings start at element 0\n+           Slice(s, 0, 2)  will return elements 0, 1 but not 2\n+           Slice(s, 1, 3)  will return elements 1, 2 but not 3\n+           Slice(s, 2, 0)  will return elements 2..max\n+           Slice(s, 3, -1) will return elements 3..max-1\n+           Slice(s, 4, -2) will return elements 4..max-2\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_Slice (DynamicStrings_String s, int low, int high)\n+{\n+  DynamicStrings_String d;\n+  DynamicStrings_String t;\n+  int start;\n+  int end;\n+  int o;\n+\n+  if (PoisonOn)\n+    {\n+      s = CheckPoisoned (s);\n+    }\n+  if (low < 0)\n+    {\n+      low = ((int ) (DynamicStrings_Length (s)))+low;\n+    }\n+  if (high <= 0)\n+    {\n+      high = ((int ) (DynamicStrings_Length (s)))+high;\n+    }\n+  else\n+    {\n+      /* make sure high is <= Length (s)  */\n+      high = Min (DynamicStrings_Length (s), static_cast<unsigned int> (high));\n+    }\n+  d = DynamicStrings_InitString ((const char *) \"\", 0);\n+  d = AddToGarbage (d, s);\n+  o = 0;\n+  t = d;\n+  while (s != NULL)\n+    {\n+      if (low < (o+((int ) (s->contents.len))))\n+        {\n+          if (o > high)\n+            {\n+              s = NULL;\n+            }\n+          else\n+            {\n+              /* found sliceable unit  */\n+              if (low < o)\n+                {\n+                  start = 0;\n+                }\n+              else\n+                {\n+                  start = low-o;\n+                }\n+              end = Max (Min (MaxBuf, static_cast<unsigned int> (high-o)), 0);\n+              while (t->contents.len == MaxBuf)\n+                {\n+                  if (t->contents.next == NULL)\n+                    {\n+                      Storage_ALLOCATE ((void **) &t->contents.next, sizeof (DynamicStrings_stringRecord));\n+                      t->contents.next->head = NULL;\n+                      t->contents.next->contents.len = 0;\n+                      AddDebugInfo (t->contents.next);\n+                      if (TraceOn)\n+                        {\n+                          t->contents.next = AssignDebug (t->contents.next, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1380, (const char *) \"Slice\", 5);\n+                        }\n+                    }\n+                  t = t->contents.next;\n+                }\n+              ConcatContentsAddress (&t->contents, &s->contents.buf.array[start], static_cast<unsigned int> (end-start));\n+              o += s->contents.len;\n+              s = s->contents.next;\n+            }\n+        }\n+      else\n+        {\n+          o += s->contents.len;\n+          s = s->contents.next;\n+        }\n+    }\n+  if (TraceOn)\n+    {\n+      d = AssignDebug (d, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1397, (const char *) \"Slice\", 5);\n+    }\n+  return d;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Index - returns the indice of the first occurance of, ch, in\n+           String, s. -1 is returned if, ch, does not exist.\n+           The search starts at position, o.\n+*/\n+\n+extern \"C\" int DynamicStrings_Index (DynamicStrings_String s, char ch, unsigned int o)\n+{\n+  unsigned int i;\n+  unsigned int k;\n+\n+  if (PoisonOn)\n+    {\n+      s = CheckPoisoned (s);\n+    }\n+  k = 0;\n+  while (s != NULL)\n+    {\n+      if ((k+s->contents.len) < o)\n+        {\n+          k += s->contents.len;\n+        }\n+      else\n+        {\n+          i = o-k;\n+          while (i < s->contents.len)\n+            {\n+              if (s->contents.buf.array[i] == ch)\n+                {\n+                  return k+i;\n+                }\n+              i += 1;\n+            }\n+          k += i;\n+          o = k;\n+        }\n+      s = s->contents.next;\n+    }\n+  return -1;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   RIndex - returns the indice of the last occurance of, ch,\n+            in String, s. The search starts at position, o.\n+            -1 is returned if, ch, is not found.\n+*/\n+\n+extern \"C\" int DynamicStrings_RIndex (DynamicStrings_String s, char ch, unsigned int o)\n+{\n+  unsigned int i;\n+  unsigned int k;\n+  int j;\n+\n+  if (PoisonOn)\n+    {\n+      s = CheckPoisoned (s);\n+    }\n+  j = -1;\n+  k = 0;\n+  while (s != NULL)\n+    {\n+      if ((k+s->contents.len) < o)\n+        {\n+          k += s->contents.len;\n+        }\n+      else\n+        {\n+          if (o < k)\n+            {\n+              i = 0;\n+            }\n+          else\n+            {\n+              i = o-k;\n+            }\n+          while (i < s->contents.len)\n+            {\n+              if (s->contents.buf.array[i] == ch)\n+                {\n+                  j = k;\n+                }\n+              k += 1;\n+              i += 1;\n+            }\n+        }\n+      s = s->contents.next;\n+    }\n+  return j;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   RemoveComment - assuming that, comment, is a comment delimiter\n+                   which indicates anything to its right is a comment\n+                   then strip off the comment and also any white space\n+                   on the remaining right hand side.\n+                   It leaves any white space on the left hand side alone.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_RemoveComment (DynamicStrings_String s, char comment)\n+{\n+  int i;\n+\n+  i = DynamicStrings_Index (s, comment, 0);\n+  if (i == 0)\n+    {\n+      s = DynamicStrings_InitString ((const char *) \"\", 0);\n+    }\n+  else if (i > 0)\n+    {\n+      /* avoid dangling else.  */\n+      s = DynamicStrings_RemoveWhitePostfix (DynamicStrings_Slice (DynamicStrings_Mark (s), 0, i));\n+    }\n+  if (TraceOn)\n+    {\n+      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1509, (const char *) \"RemoveComment\", 13);\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   RemoveWhitePrefix - removes any leading white space from String, s.\n+                       A new string is returned.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_RemoveWhitePrefix (DynamicStrings_String s)\n+{\n+  unsigned int i;\n+\n+  i = 0;\n+  while (IsWhite (DynamicStrings_char (s, static_cast<int> (i))))\n+    {\n+      i += 1;\n+    }\n+  s = DynamicStrings_Slice (s, (int ) (i), 0);\n+  if (TraceOn)\n+    {\n+      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1621, (const char *) \"RemoveWhitePrefix\", 17);\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   RemoveWhitePostfix - removes any leading white space from String, s.\n+                        A new string is returned.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_RemoveWhitePostfix (DynamicStrings_String s)\n+{\n+  int i;\n+\n+  i = ((int ) (DynamicStrings_Length (s)))-1;\n+  while ((i >= 0) && (IsWhite (DynamicStrings_char (s, i))))\n+    {\n+      i -= 1;\n+    }\n+  s = DynamicStrings_Slice (s, 0, i+1);\n+  if (TraceOn)\n+    {\n+      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1643, (const char *) \"RemoveWhitePostfix\", 18);\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   ToUpper - returns string, s, after it has had its lower case characters\n+             replaced by upper case characters.\n+             The string, s, is not duplicated.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_ToUpper (DynamicStrings_String s)\n+{\n+  char ch;\n+  unsigned int i;\n+  DynamicStrings_String t;\n+\n+  if (s != NULL)\n+    {\n+      MarkInvalid (s);\n+      t = s;\n+      while (t != NULL)\n+        {\n+          i = 0;\n+          while (i < t->contents.len)\n+            {\n+              ch = t->contents.buf.array[i];\n+              if ((ch >= 'a') && (ch <= 'z'))\n+                {\n+                  t->contents.buf.array[i] = ((char) (( ((unsigned int) (ch))- ((unsigned int) ('a')))+ ((unsigned int) ('A'))));\n+                }\n+              i += 1;\n+            }\n+          t = t->contents.next;\n+        }\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   ToLower - returns string, s, after it has had its upper case characters\n+             replaced by lower case characters.\n+             The string, s, is not duplicated.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_ToLower (DynamicStrings_String s)\n+{\n+  char ch;\n+  unsigned int i;\n+  DynamicStrings_String t;\n+\n+  if (s != NULL)\n+    {\n+      MarkInvalid (s);\n+      t = s;\n+      while (t != NULL)\n+        {\n+          i = 0;\n+          while (i < t->contents.len)\n+            {\n+              ch = t->contents.buf.array[i];\n+              if ((ch >= 'A') && (ch <= 'Z'))\n+                {\n+                  t->contents.buf.array[i] = ((char) (( ((unsigned int) (ch))- ((unsigned int) ('A')))+ ((unsigned int) ('a'))));\n+                }\n+              i += 1;\n+            }\n+          t = t->contents.next;\n+        }\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   CopyOut - copies string, s, to a.\n+*/\n+\n+extern \"C\" void DynamicStrings_CopyOut (char *a, unsigned int _a_high, DynamicStrings_String s)\n+{\n+  unsigned int i;\n+  unsigned int l;\n+\n+  l = Min (_a_high+1, DynamicStrings_Length (s));\n+  i = 0;\n+  while (i < l)\n+    {\n+      a[i] = DynamicStrings_char (s, static_cast<int> (i));\n+      i += 1;\n+    }\n+  if (i <= _a_high)\n+    {\n+      a[i] = ASCII_nul;\n+    }\n+}\n+\n+\n+/*\n+   char - returns the character, ch, at position, i, in String, s.\n+*/\n+\n+extern \"C\" char DynamicStrings_char (DynamicStrings_String s, int i)\n+{\n+  unsigned int c;\n+\n+  if (PoisonOn)\n+    {\n+      s = CheckPoisoned (s);\n+    }\n+  if (i < 0)\n+    {\n+      c = (unsigned int ) (((int ) (DynamicStrings_Length (s)))+i);\n+    }\n+  else\n+    {\n+      c = i;\n+    }\n+  while ((s != NULL) && (c >= s->contents.len))\n+    {\n+      c -= s->contents.len;\n+      s = s->contents.next;\n+    }\n+  if ((s == NULL) || (c >= s->contents.len))\n+    {\n+      return ASCII_nul;\n+    }\n+  else\n+    {\n+      return s->contents.buf.array[c];\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   string - returns the C style char * of String, s.\n+*/\n+\n+extern \"C\" void * DynamicStrings_string (DynamicStrings_String s)\n+{\n+  typedef char *string__T2;\n+\n+  DynamicStrings_String a;\n+  unsigned int l;\n+  unsigned int i;\n+  string__T2 p;\n+\n+  if (PoisonOn)\n+    {\n+      s = CheckPoisoned (s);\n+    }\n+  if (s == NULL)\n+    {\n+      return NULL;\n+    }\n+  else\n+    {\n+      if (! s->head->charStarValid)\n+        {\n+          l = DynamicStrings_Length (s);\n+          if (! (s->head->charStarUsed && (s->head->charStarSize > l)))\n+            {\n+              DeallocateCharStar (s);\n+              Storage_ALLOCATE (&s->head->charStar, l+1);\n+              s->head->charStarSize = l+1;\n+              s->head->charStarUsed = TRUE;\n+            }\n+          p = static_cast<string__T2> (s->head->charStar);\n+          a = s;\n+          while (a != NULL)\n+            {\n+              i = 0;\n+              while (i < a->contents.len)\n+                {\n+                  (*p) = a->contents.buf.array[i];\n+                  i += 1;\n+                  p += 1;\n+                }\n+              a = a->contents.next;\n+            }\n+          (*p) = ASCII_nul;\n+          s->head->charStarValid = TRUE;\n+        }\n+      return s->head->charStar;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   InitStringDB - the debug version of InitString.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_InitStringDB (const char *a_, unsigned int _a_high, const char *file_, unsigned int _file_high, unsigned int line)\n+{\n+  char a[_a_high+1];\n+  char file[_file_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+  memcpy (file, file_, _file_high+1);\n+\n+  return AssignDebug (DynamicStrings_InitString ((const char *) a, _a_high), (const char *) file, _file_high, line, (const char *) \"InitString\", 10);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   InitStringCharStarDB - the debug version of InitStringCharStar.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_InitStringCharStarDB (void * a, const char *file_, unsigned int _file_high, unsigned int line)\n+{\n+  char file[_file_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (file, file_, _file_high+1);\n+\n+  return AssignDebug (DynamicStrings_InitStringCharStar (a), (const char *) file, _file_high, line, (const char *) \"InitStringCharStar\", 18);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   InitStringCharDB - the debug version of InitStringChar.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_InitStringCharDB (char ch, const char *file_, unsigned int _file_high, unsigned int line)\n+{\n+  char file[_file_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (file, file_, _file_high+1);\n+\n+  return AssignDebug (DynamicStrings_InitStringChar (ch), (const char *) file, _file_high, line, (const char *) \"InitStringChar\", 14);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   MultDB - the debug version of MultDB.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_MultDB (DynamicStrings_String s, unsigned int n, const char *file_, unsigned int _file_high, unsigned int line)\n+{\n+  char file[_file_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (file, file_, _file_high+1);\n+\n+  return AssignDebug (DynamicStrings_Mult (s, n), (const char *) file, _file_high, line, (const char *) \"Mult\", 4);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   DupDB - the debug version of Dup.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_DupDB (DynamicStrings_String s, const char *file_, unsigned int _file_high, unsigned int line)\n+{\n+  char file[_file_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (file, file_, _file_high+1);\n+\n+  return AssignDebug (DynamicStrings_Dup (s), (const char *) file, _file_high, line, (const char *) \"Dup\", 3);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   SliceDB - debug version of Slice.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_SliceDB (DynamicStrings_String s, int low, int high, const char *file_, unsigned int _file_high, unsigned int line)\n+{\n+  char file[_file_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (file, file_, _file_high+1);\n+\n+  DSdbEnter ();\n+  s = AssignDebug (DynamicStrings_Slice (s, low, high), (const char *) file, _file_high, line, (const char *) \"Slice\", 5);\n+  DSdbExit (s);\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   PushAllocation - pushes the current allocation/deallocation lists.\n+*/\n+\n+extern \"C\" void DynamicStrings_PushAllocation (void)\n+{\n+  DynamicStrings_frame f;\n+\n+  if (CheckOn)\n+    {\n+      Init ();\n+      Storage_ALLOCATE ((void **) &f, sizeof (DynamicStrings_frameRec));\n+      f->next = frameHead;\n+      f->alloc = NULL;\n+      f->dealloc = NULL;\n+      frameHead = f;\n+    }\n+}\n+\n+\n+/*\n+   PopAllocation - test to see that all strings are deallocated since\n+                   the last push.  Then it pops to the previous\n+                   allocation/deallocation lists.\n+\n+                   If halt is true then the application terminates\n+                   with an exit code of 1.\n+*/\n+\n+extern \"C\" void DynamicStrings_PopAllocation (unsigned int halt)\n+{\n+  if (CheckOn)\n+    {\n+      if ((DynamicStrings_PopAllocationExemption (halt, NULL)) == NULL)\n+        {}  /* empty.  */\n+    }\n+}\n+\n+\n+/*\n+   PopAllocationExemption - test to see that all strings are deallocated, except\n+                            string, e, since the last push.\n+                            Then it pops to the previous allocation/deallocation\n+                            lists.\n+\n+                            If halt is true then the application terminates\n+                            with an exit code of 1.\n+*/\n+\n+extern \"C\" DynamicStrings_String DynamicStrings_PopAllocationExemption (unsigned int halt, DynamicStrings_String e)\n+{\n+  DynamicStrings_String s;\n+  DynamicStrings_frame f;\n+  unsigned int b;\n+\n+  Init ();\n+  if (CheckOn)\n+    {\n+      /* avoid gcc warning by using compound statement even if not strictly necessary.  */\n+      if (frameHead == NULL)\n+        {\n+          stop ();\n+          /* writeString (\"mismatched number of PopAllocation's compared to PushAllocation's\")  */\n+          M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 176, (const char *) \"PopAllocationExemption\", 22, (const char *) \"mismatched number of PopAllocation's compared to PushAllocation's\", 65);\n+        }\n+      else\n+        {\n+          if (frameHead->alloc != NULL)\n+            {\n+              b = FALSE;\n+              s = frameHead->alloc;\n+              while (s != NULL)\n+                {\n+                  if (! (((e == s) || (IsOnGarbage (e, s))) || (IsOnGarbage (s, e))))\n+                    {\n+                      if (! b)\n+                        {\n+                          writeString ((const char *) \"the following strings have been lost\", 36);\n+                          writeLn ();\n+                          b = TRUE;\n+                        }\n+                      DumpStringInfo (s, 0);\n+                    }\n+                  s = s->debug.next;\n+                }\n+              if (b && halt)\n+                {\n+                  libc_exit (1);\n+                }\n+            }\n+          frameHead = frameHead->next;\n+        }\n+    }\n+  return e;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" void _M2_DynamicStrings_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+  Initialized = FALSE;\n+  Init ();\n+}\n+\n+extern \"C\" void _M2_DynamicStrings_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "aa5e76628730125f277762e90c2646cbcb28de44", "filename": "gcc/m2/mc-boot/GEnvironment.cc", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGEnvironment.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGEnvironment.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGEnvironment.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,129 @@\n+/* do not edit automatically generated by mc from Environment.  */\n+/* Environment.mod provides access to the environment settings of a process.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#if defined(__cplusplus)\n+#   undef NULL\n+#   define NULL 0\n+#endif\n+#define _Environment_H\n+#define _Environment_C\n+\n+#   include \"GSYSTEM.h\"\n+#   include \"Glibc.h\"\n+#   include \"GASCII.h\"\n+#   include \"GStrLib.h\"\n+\n+\n+/*\n+   GetEnvironment - gets the environment variable Env and places\n+      \t       \t    a copy of its value into string, dest.\n+                    It returns TRUE if the string Env was found in\n+                    the processes environment.\n+*/\n+\n+extern \"C\" unsigned int Environment_GetEnvironment (const char *Env_, unsigned int _Env_high, char *dest, unsigned int _dest_high);\n+\n+/*\n+   PutEnvironment - change or add an environment variable definition EnvDef.\n+                    TRUE is returned if the environment variable was\n+                    set or changed successfully.\n+*/\n+\n+extern \"C\" unsigned int Environment_PutEnvironment (const char *EnvDef_, unsigned int _EnvDef_high);\n+\n+\n+/*\n+   GetEnvironment - gets the environment variable Env and places\n+      \t       \t    a copy of its value into string, dest.\n+                    It returns TRUE if the string Env was found in\n+                    the processes environment.\n+*/\n+\n+extern \"C\" unsigned int Environment_GetEnvironment (const char *Env_, unsigned int _Env_high, char *dest, unsigned int _dest_high)\n+{\n+  typedef char *GetEnvironment__T1;\n+\n+  unsigned int High;\n+  unsigned int i;\n+  GetEnvironment__T1 Addr;\n+  char Env[_Env_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (Env, Env_, _Env_high+1);\n+\n+  i = 0;\n+  High = _dest_high;\n+  Addr = static_cast<GetEnvironment__T1> (libc_getenv (&Env));\n+  while (((i < High) && (Addr != NULL)) && ((*Addr) != ASCII_nul))\n+    {\n+      dest[i] = (*Addr);\n+      Addr += 1;\n+      i += 1;\n+    }\n+  if (i < High)\n+    {\n+      dest[i] = ASCII_nul;\n+    }\n+  return Addr != NULL;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   PutEnvironment - change or add an environment variable definition EnvDef.\n+                    TRUE is returned if the environment variable was\n+                    set or changed successfully.\n+*/\n+\n+extern \"C\" unsigned int Environment_PutEnvironment (const char *EnvDef_, unsigned int _EnvDef_high)\n+{\n+  char EnvDef[_EnvDef_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (EnvDef, EnvDef_, _EnvDef_high+1);\n+\n+  return (libc_putenv (&EnvDef)) == 0;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" void _M2_Environment_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}\n+\n+extern \"C\" void _M2_Environment_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "65819a10a4b8b5cf8a3b4c39f768787ff970ec0c", "filename": "gcc/m2/mc-boot/GFIO.cc", "status": "added", "additions": 2322, "deletions": 0, "changes": 2322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGFIO.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGFIO.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGFIO.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,2322 @@\n+/* do not edit automatically generated by mc from FIO.  */\n+/* FIO.mod provides a simple buffered file input/output library.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#   if !defined (TRUE)\n+#      define TRUE (1==1)\n+#   endif\n+\n+#   if !defined (FALSE)\n+#      define FALSE (1==0)\n+#   endif\n+\n+#   include \"GStorage.h\"\n+#   include \"Gmcrts.h\"\n+#if defined(__cplusplus)\n+#   undef NULL\n+#   define NULL 0\n+#endif\n+#define _FIO_H\n+#define _FIO_C\n+\n+#   include \"GSYSTEM.h\"\n+#   include \"GASCII.h\"\n+#   include \"GStrLib.h\"\n+#   include \"GStorage.h\"\n+#   include \"GNumberIO.h\"\n+#   include \"Glibc.h\"\n+#   include \"GIndexing.h\"\n+#   include \"GM2RTS.h\"\n+\n+typedef unsigned int FIO_File;\n+\n+FIO_File FIO_StdErr;\n+FIO_File FIO_StdOut;\n+FIO_File FIO_StdIn;\n+#   define SEEK_SET 0\n+#   define SEEK_END 2\n+#   define UNIXREADONLY 0\n+#   define UNIXWRITEONLY 1\n+#   define CreatePermissions 0666\n+#   define MaxBufferLength (1024*16)\n+#   define MaxErrorString (1024*8)\n+typedef struct FIO_NameInfo_r FIO_NameInfo;\n+\n+typedef struct FIO_buf_r FIO_buf;\n+\n+typedef FIO_buf *FIO_Buffer;\n+\n+typedef struct FIO_fds_r FIO_fds;\n+\n+typedef FIO_fds *FIO_FileDescriptor;\n+\n+typedef struct FIO__T7_a FIO__T7;\n+\n+typedef char *FIO_PtrToChar;\n+\n+typedef enum {FIO_successful, FIO_outofmemory, FIO_toomanyfilesopen, FIO_failed, FIO_connectionfailure, FIO_endofline, FIO_endoffile} FIO_FileStatus;\n+\n+typedef enum {FIO_unused, FIO_openedforread, FIO_openedforwrite, FIO_openedforrandom} FIO_FileUsage;\n+\n+struct FIO_NameInfo_r {\n+                        void *address;\n+                        unsigned int size;\n+                      };\n+\n+struct FIO_buf_r {\n+                   unsigned int valid;\n+                   long int bufstart;\n+                   unsigned int position;\n+                   void *address;\n+                   unsigned int filled;\n+                   unsigned int size;\n+                   unsigned int left;\n+                   FIO__T7 *contents;\n+                 };\n+\n+struct FIO__T7_a { char array[MaxBufferLength+1]; };\n+struct FIO_fds_r {\n+                   int unixfd;\n+                   FIO_NameInfo name;\n+                   FIO_FileStatus state;\n+                   FIO_FileUsage usage;\n+                   unsigned int output;\n+                   FIO_Buffer buffer;\n+                   long int abspos;\n+                 };\n+\n+static Indexing_Index FileInfo;\n+static FIO_File Error;\n+\n+/*\n+   IsNoError - returns a TRUE if no error has occured on file, f.\n+*/\n+\n+extern \"C\" unsigned int FIO_IsNoError (FIO_File f);\n+\n+/*\n+   IsActive - returns TRUE if the file, f, is still active.\n+*/\n+\n+extern \"C\" unsigned int FIO_IsActive (FIO_File f);\n+extern \"C\" unsigned int FIO_Exists (const char *fname_, unsigned int _fname_high);\n+extern \"C\" FIO_File FIO_OpenToRead (const char *fname_, unsigned int _fname_high);\n+extern \"C\" FIO_File FIO_OpenToWrite (const char *fname_, unsigned int _fname_high);\n+extern \"C\" FIO_File FIO_OpenForRandom (const char *fname_, unsigned int _fname_high, unsigned int towrite, unsigned int newfile);\n+\n+/*\n+   Close - close a file which has been previously opened using:\n+           OpenToRead, OpenToWrite, OpenForRandom.\n+           It is correct to close a file which has an error status.\n+*/\n+\n+extern \"C\" void FIO_Close (FIO_File f);\n+\n+/*\n+   exists - returns TRUE if a file named, fname exists for reading.\n+*/\n+\n+extern \"C\" unsigned int FIO_exists (void * fname, unsigned int flength);\n+\n+/*\n+   openToRead - attempts to open a file, fname, for reading and\n+                it returns this file.\n+                The success of this operation can be checked by\n+                calling IsNoError.\n+*/\n+\n+extern \"C\" FIO_File FIO_openToRead (void * fname, unsigned int flength);\n+\n+/*\n+   openToWrite - attempts to open a file, fname, for write and\n+                 it returns this file.\n+                 The success of this operation can be checked by\n+                 calling IsNoError.\n+*/\n+\n+extern \"C\" FIO_File FIO_openToWrite (void * fname, unsigned int flength);\n+\n+/*\n+   openForRandom - attempts to open a file, fname, for random access\n+                   read or write and it returns this file.\n+                   The success of this operation can be checked by\n+                   calling IsNoError.\n+                   towrite, determines whether the file should be\n+                   opened for writing or reading.\n+*/\n+\n+extern \"C\" FIO_File FIO_openForRandom (void * fname, unsigned int flength, unsigned int towrite, unsigned int newfile);\n+\n+/*\n+   FlushBuffer - flush contents of file, f.\n+*/\n+\n+extern \"C\" void FIO_FlushBuffer (FIO_File f);\n+\n+/*\n+   ReadNBytes - reads nBytes of a file into memory area, dest, returning\n+                the number of bytes actually read.\n+                This function will consume from the buffer and then\n+                perform direct libc reads. It is ideal for large reads.\n+*/\n+\n+extern \"C\" unsigned int FIO_ReadNBytes (FIO_File f, unsigned int nBytes, void * dest);\n+\n+/*\n+   ReadAny - reads HIGH(a) bytes into, a. All input\n+             is fully buffered, unlike ReadNBytes and thus is more\n+             suited to small reads.\n+*/\n+\n+extern \"C\" void FIO_ReadAny (FIO_File f, unsigned char *a, unsigned int _a_high);\n+\n+/*\n+   WriteNBytes - writes nBytes from memory area src to a file\n+                 returning the number of bytes actually written.\n+                 This function will flush the buffer and then\n+                 write the nBytes using a direct write from libc.\n+                 It is ideal for large writes.\n+*/\n+\n+extern \"C\" unsigned int FIO_WriteNBytes (FIO_File f, unsigned int nBytes, void * src);\n+\n+/*\n+   WriteAny - writes HIGH(a) bytes onto, file, f. All output\n+              is fully buffered, unlike WriteNBytes and thus is more\n+              suited to small writes.\n+*/\n+\n+extern \"C\" void FIO_WriteAny (FIO_File f, unsigned char *a, unsigned int _a_high);\n+\n+/*\n+   WriteChar - writes a single character to file, f.\n+*/\n+\n+extern \"C\" void FIO_WriteChar (FIO_File f, char ch);\n+\n+/*\n+   EOF - tests to see whether a file, f, has reached end of file.\n+*/\n+\n+extern \"C\" unsigned int FIO_EOF (FIO_File f);\n+\n+/*\n+   EOLN - tests to see whether a file, f, is upon a newline.\n+          It does NOT consume the newline.\n+*/\n+\n+extern \"C\" unsigned int FIO_EOLN (FIO_File f);\n+\n+/*\n+   WasEOLN - tests to see whether a file, f, has just seen a newline.\n+*/\n+\n+extern \"C\" unsigned int FIO_WasEOLN (FIO_File f);\n+\n+/*\n+   ReadChar - returns a character read from file f.\n+              Sensible to check with IsNoError or EOF after calling\n+              this function.\n+*/\n+\n+extern \"C\" char FIO_ReadChar (FIO_File f);\n+\n+/*\n+   UnReadChar - replaces a character, ch, back into file f.\n+                This character must have been read by ReadChar\n+                and it does not allow successive calls.  It may\n+                only be called if the previous read was successful\n+                or end of file was seen.\n+                If the state was previously endoffile then it\n+                is altered to successful.\n+                Otherwise it is left alone.\n+*/\n+\n+extern \"C\" void FIO_UnReadChar (FIO_File f, char ch);\n+\n+/*\n+   WriteLine - writes out a linefeed to file, f.\n+*/\n+\n+extern \"C\" void FIO_WriteLine (FIO_File f);\n+\n+/*\n+   WriteString - writes a string to file, f.\n+*/\n+\n+extern \"C\" void FIO_WriteString (FIO_File f, const char *a_, unsigned int _a_high);\n+\n+/*\n+   ReadString - reads a string from file, f, into string, a.\n+                It terminates the string if HIGH is reached or\n+                if a newline is seen or an error occurs.\n+*/\n+\n+extern \"C\" void FIO_ReadString (FIO_File f, char *a, unsigned int _a_high);\n+\n+/*\n+   WriteCardinal - writes a CARDINAL to file, f.\n+                   It writes the binary image of the cardinal\n+                   to file, f.\n+*/\n+\n+extern \"C\" void FIO_WriteCardinal (FIO_File f, unsigned int c);\n+\n+/*\n+   ReadCardinal - reads a CARDINAL from file, f.\n+                  It reads a binary image of a CARDINAL\n+                  from a file, f.\n+*/\n+\n+extern \"C\" unsigned int FIO_ReadCardinal (FIO_File f);\n+\n+/*\n+   GetUnixFileDescriptor - returns the UNIX file descriptor of a file.\n+*/\n+\n+extern \"C\" int FIO_GetUnixFileDescriptor (FIO_File f);\n+\n+/*\n+   SetPositionFromBeginning - sets the position from the beginning of the file.\n+*/\n+\n+extern \"C\" void FIO_SetPositionFromBeginning (FIO_File f, long int pos);\n+\n+/*\n+   SetPositionFromEnd - sets the position from the end of the file.\n+*/\n+\n+extern \"C\" void FIO_SetPositionFromEnd (FIO_File f, long int pos);\n+\n+/*\n+   FindPosition - returns the current absolute position in file, f.\n+*/\n+\n+extern \"C\" long int FIO_FindPosition (FIO_File f);\n+\n+/*\n+   GetFileName - assigns, a, with the filename associated with, f.\n+*/\n+\n+extern \"C\" void FIO_GetFileName (FIO_File f, char *a, unsigned int _a_high);\n+\n+/*\n+   getFileName - returns the address of the filename associated with, f.\n+*/\n+\n+extern \"C\" void * FIO_getFileName (FIO_File f);\n+\n+/*\n+   getFileNameLength - returns the number of characters associated with filename, f.\n+*/\n+\n+extern \"C\" unsigned int FIO_getFileNameLength (FIO_File f);\n+\n+/*\n+   FlushOutErr - flushes, StdOut, and, StdErr.\n+                 It is also called when the application calls M2RTS.Terminate.\n+                 (which is automatically placed in program modules by the GM2\n+                 scaffold).\n+*/\n+\n+extern \"C\" void FIO_FlushOutErr (void);\n+\n+/*\n+   Max - returns the maximum of two values.\n+*/\n+\n+static unsigned int Max (unsigned int a, unsigned int b);\n+\n+/*\n+   Min - returns the minimum of two values.\n+*/\n+\n+static unsigned int Min (unsigned int a, unsigned int b);\n+\n+/*\n+   GetNextFreeDescriptor - returns the index to the FileInfo array indicating\n+                           the next free slot.\n+*/\n+\n+static FIO_File GetNextFreeDescriptor (void);\n+\n+/*\n+   SetState - sets the field, state, of file, f, to, s.\n+*/\n+\n+static void SetState (FIO_File f, FIO_FileStatus s);\n+\n+/*\n+   InitializeFile - initialize a file descriptor\n+*/\n+\n+static FIO_File InitializeFile (FIO_File f, void * fname, unsigned int flength, FIO_FileStatus fstate, FIO_FileUsage use, unsigned int towrite, unsigned int buflength);\n+\n+/*\n+   ConnectToUnix - connects a FIO file to a UNIX file descriptor.\n+*/\n+\n+static void ConnectToUnix (FIO_File f, unsigned int towrite, unsigned int newfile);\n+\n+/*\n+   ReadFromBuffer - attempts to read, nBytes, from file, f.\n+                    It firstly consumes the buffer and then performs\n+                    direct unbuffered reads. This should only be used\n+                    when wishing to read large files.\n+\n+                    The actual number of bytes read is returned.\n+                    -1 is returned if EOF is reached.\n+*/\n+\n+static int ReadFromBuffer (FIO_File f, void * a, unsigned int nBytes);\n+\n+/*\n+   BufferedRead - will read, nBytes, through the buffer.\n+                  Similar to ReadFromBuffer, but this function will always\n+                  read into the buffer before copying into memory.\n+\n+                  Useful when performing small reads.\n+*/\n+\n+static int BufferedRead (FIO_File f, unsigned int nBytes, void * a);\n+\n+/*\n+   HandleEscape - translates \n+ and \\t into their respective ascii codes.\n+*/\n+\n+static void HandleEscape (char *dest, unsigned int _dest_high, const char *src_, unsigned int _src_high, unsigned int *i, unsigned int *j, unsigned int HighSrc, unsigned int HighDest);\n+\n+/*\n+   Cast - casts a := b\n+*/\n+\n+static void Cast (unsigned char *a, unsigned int _a_high, const unsigned char *b_, unsigned int _b_high);\n+\n+/*\n+   StringFormat1 - converts string, src, into, dest, together with encapsulated\n+                   entity, w. It only formats the first %s or %d with n.\n+*/\n+\n+static void StringFormat1 (char *dest, unsigned int _dest_high, const char *src_, unsigned int _src_high, const unsigned char *w_, unsigned int _w_high);\n+\n+/*\n+   FormatError - provides a orthoganal counterpart to the procedure below.\n+*/\n+\n+static void FormatError (const char *a_, unsigned int _a_high);\n+\n+/*\n+   FormatError1 - generic error procedure taking standard format string\n+                  and single parameter.\n+*/\n+\n+static void FormatError1 (const char *a_, unsigned int _a_high, const unsigned char *w_, unsigned int _w_high);\n+\n+/*\n+   FormatError2 - generic error procedure taking standard format string\n+                  and two parameters.\n+*/\n+\n+static void FormatError2 (const char *a_, unsigned int _a_high, const unsigned char *w1_, unsigned int _w1_high, const unsigned char *w2_, unsigned int _w2_high);\n+\n+/*\n+   CheckAccess - checks to see whether a file f has been\n+                 opened for read/write.\n+*/\n+\n+static void CheckAccess (FIO_File f, FIO_FileUsage use, unsigned int towrite);\n+\n+/*\n+   SetEndOfLine -\n+*/\n+\n+static void SetEndOfLine (FIO_File f, char ch);\n+\n+/*\n+   BufferedWrite - will write, nBytes, through the buffer.\n+                   Similar to WriteNBytes, but this function will always\n+                   write into the buffer before copying into memory.\n+\n+                   Useful when performing small writes.\n+*/\n+\n+static int BufferedWrite (FIO_File f, unsigned int nBytes, void * a);\n+\n+/*\n+   PreInitialize - preinitialize the file descriptor.\n+*/\n+\n+static void PreInitialize (FIO_File f, const char *fname_, unsigned int _fname_high, FIO_FileStatus state, FIO_FileUsage use, unsigned int towrite, int osfd, unsigned int bufsize);\n+\n+/*\n+   Init - initialize the modules, global variables.\n+*/\n+\n+static void Init (void);\n+\n+\n+/*\n+   Max - returns the maximum of two values.\n+*/\n+\n+static unsigned int Max (unsigned int a, unsigned int b)\n+{\n+  if (a > b)\n+    {\n+      return a;\n+    }\n+  else\n+    {\n+      return b;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Min - returns the minimum of two values.\n+*/\n+\n+static unsigned int Min (unsigned int a, unsigned int b)\n+{\n+  if (a < b)\n+    {\n+      return a;\n+    }\n+  else\n+    {\n+      return b;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   GetNextFreeDescriptor - returns the index to the FileInfo array indicating\n+                           the next free slot.\n+*/\n+\n+static FIO_File GetNextFreeDescriptor (void)\n+{\n+  FIO_File f;\n+  FIO_File h;\n+  FIO_FileDescriptor fd;\n+\n+  f = Error+1;\n+  h = Indexing_HighIndice (FileInfo);\n+  for (;;)\n+  {\n+    if (f <= h)\n+      {\n+        fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+        if (fd == NULL)\n+          {\n+            return f;\n+          }\n+      }\n+    f += 1;\n+    if (f > h)\n+      {\n+        Indexing_PutIndice (FileInfo, f, NULL);  /* create new slot  */\n+        return f;  /* create new slot  */\n+      }\n+  }\n+  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/FIO.def\", 25, 1);\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   SetState - sets the field, state, of file, f, to, s.\n+*/\n+\n+static void SetState (FIO_File f, FIO_FileStatus s)\n+{\n+  FIO_FileDescriptor fd;\n+\n+  fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+  fd->state = s;\n+}\n+\n+\n+/*\n+   InitializeFile - initialize a file descriptor\n+*/\n+\n+static FIO_File InitializeFile (FIO_File f, void * fname, unsigned int flength, FIO_FileStatus fstate, FIO_FileUsage use, unsigned int towrite, unsigned int buflength)\n+{\n+  FIO_PtrToChar p;\n+  FIO_FileDescriptor fd;\n+\n+  Storage_ALLOCATE ((void **) &fd, sizeof (FIO_fds));\n+  if (fd == NULL)\n+    {\n+      SetState (Error, FIO_outofmemory);\n+      return Error;\n+    }\n+  else\n+    {\n+      Indexing_PutIndice (FileInfo, f, reinterpret_cast<void *> (fd));\n+      fd->name.size = flength+1;  /* need to guarantee the nul for C  */\n+      fd->usage = use;  /* need to guarantee the nul for C  */\n+      fd->output = towrite;\n+      Storage_ALLOCATE (&fd->name.address, fd->name.size);\n+      if (fd->name.address == NULL)\n+        {\n+          fd->state = FIO_outofmemory;\n+          return f;\n+        }\n+      fd->name.address = libc_strncpy (fd->name.address, fname, flength);\n+      /* and assign nul to the last byte  */\n+      p = static_cast<FIO_PtrToChar> (fd->name.address);\n+      p += flength;\n+      (*p) = ASCII_nul;\n+      fd->abspos = 0;\n+      /* now for the buffer  */\n+      Storage_ALLOCATE ((void **) &fd->buffer, sizeof (FIO_buf));\n+      if (fd->buffer == NULL)\n+        {\n+          SetState (Error, FIO_outofmemory);\n+          return Error;\n+        }\n+      else\n+        {\n+          fd->buffer->valid = FALSE;\n+          fd->buffer->bufstart = 0;\n+          fd->buffer->size = buflength;\n+          fd->buffer->position = 0;\n+          fd->buffer->filled = 0;\n+          if (fd->buffer->size == 0)\n+            {\n+              fd->buffer->address = NULL;\n+            }\n+          else\n+            {\n+              Storage_ALLOCATE (&fd->buffer->address, fd->buffer->size);\n+              if (fd->buffer->address == NULL)\n+                {\n+                  fd->state = FIO_outofmemory;\n+                  return f;\n+                }\n+            }\n+          if (towrite)\n+            {\n+              fd->buffer->left = fd->buffer->size;\n+            }\n+          else\n+            {\n+              fd->buffer->left = 0;\n+            }\n+          fd->buffer->contents = reinterpret_cast<FIO__T7 *> (fd->buffer->address);  /* provides easy access for reading characters  */\n+          fd->state = fstate;  /* provides easy access for reading characters  */\n+        }\n+    }\n+  return f;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   ConnectToUnix - connects a FIO file to a UNIX file descriptor.\n+*/\n+\n+static void ConnectToUnix (FIO_File f, unsigned int towrite, unsigned int newfile)\n+{\n+  FIO_FileDescriptor fd;\n+\n+  if (f != Error)\n+    {\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+      if (fd != NULL)\n+        {\n+          if (towrite)\n+            {\n+              if (newfile)\n+                {\n+                  fd->unixfd = libc_creat (fd->name.address, CreatePermissions);\n+                }\n+              else\n+                {\n+                  fd->unixfd = libc_open (fd->name.address, UNIXWRITEONLY, 0);\n+                }\n+            }\n+          else\n+            {\n+              fd->unixfd = libc_open (fd->name.address, UNIXREADONLY, 0);\n+            }\n+          if (fd->unixfd < 0)\n+            {\n+              fd->state = FIO_connectionfailure;\n+            }\n+        }\n+    }\n+}\n+\n+\n+/*\n+   ReadFromBuffer - attempts to read, nBytes, from file, f.\n+                    It firstly consumes the buffer and then performs\n+                    direct unbuffered reads. This should only be used\n+                    when wishing to read large files.\n+\n+                    The actual number of bytes read is returned.\n+                    -1 is returned if EOF is reached.\n+*/\n+\n+static int ReadFromBuffer (FIO_File f, void * a, unsigned int nBytes)\n+{\n+  typedef unsigned char *ReadFromBuffer__T1;\n+\n+  void * t;\n+  int result;\n+  unsigned int total;\n+  unsigned int n;\n+  ReadFromBuffer__T1 p;\n+  FIO_FileDescriptor fd;\n+\n+  if (f != Error)\n+    {\n+      total = 0;  /* how many bytes have we read  */\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));  /* how many bytes have we read  */\n+      /* extract from the buffer first  */\n+      if ((fd->buffer != NULL) && fd->buffer->valid)\n+        {\n+          if (fd->buffer->left > 0)\n+            {\n+              /* avoid gcc warning by using compound statement even if not strictly necessary.  */\n+              if (nBytes == 1)\n+                {\n+                  /* too expensive to call memcpy for 1 character  */\n+                  p = static_cast<ReadFromBuffer__T1> (a);\n+                  (*p) = static_cast<unsigned char> ((*fd->buffer->contents).array[fd->buffer->position]);\n+                  fd->buffer->left -= 1;  /* remove consumed bytes  */\n+                  fd->buffer->position += 1;  /* move onwards n bytes  */\n+                  nBytes = 0;\n+                  /* read  */\n+                  return 1;\n+                }\n+              else\n+                {\n+                  n = Min (fd->buffer->left, nBytes);\n+                  t = fd->buffer->address;\n+                  t = reinterpret_cast<void *> (reinterpret_cast<char *> (t)+fd->buffer->position);\n+                  p = static_cast<ReadFromBuffer__T1> (libc_memcpy (a, t, static_cast<size_t> (n)));\n+                  fd->buffer->left -= n;  /* remove consumed bytes  */\n+                  fd->buffer->position += n;  /* move onwards n bytes  */\n+                  /* move onwards ready for direct reads  */\n+                  a = reinterpret_cast<void *> (reinterpret_cast<char *> (a)+n);\n+                  nBytes -= n;  /* reduce the amount for future direct  */\n+                  /* read  */\n+                  total += n;\n+                  return total;  /* much cleaner to return now,  */\n+                }\n+               /* difficult to record an error if  */\n+            }\n+           /* the read below returns -1  */\n+        }\n+      if (nBytes > 0)\n+        {\n+          /* still more to read  */\n+          result = static_cast<int> (libc_read (fd->unixfd, a, static_cast<size_t> ((int ) (nBytes))));\n+          if (result > 0)\n+            {\n+              /* avoid dangling else.  */\n+              total += result;\n+              fd->abspos += result;\n+              /* now disable the buffer as we read directly into, a.  */\n+              if (fd->buffer != NULL)\n+                {\n+                  fd->buffer->valid = FALSE;\n+                }\n+            }\n+          else\n+            {\n+              if (result == 0)\n+                {\n+                  /* eof reached  */\n+                  fd->state = FIO_endoffile;\n+                }\n+              else\n+                {\n+                  fd->state = FIO_failed;\n+                }\n+              /* indicate buffer is empty  */\n+              if (fd->buffer != NULL)\n+                {\n+                  fd->buffer->valid = FALSE;\n+                  fd->buffer->left = 0;\n+                  fd->buffer->position = 0;\n+                  if (fd->buffer->address != NULL)\n+                    {\n+                      (*fd->buffer->contents).array[fd->buffer->position] = ASCII_nul;\n+                    }\n+                }\n+              return -1;\n+            }\n+        }\n+      return total;\n+    }\n+  else\n+    {\n+      return -1;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   BufferedRead - will read, nBytes, through the buffer.\n+                  Similar to ReadFromBuffer, but this function will always\n+                  read into the buffer before copying into memory.\n+\n+                  Useful when performing small reads.\n+*/\n+\n+static int BufferedRead (FIO_File f, unsigned int nBytes, void * a)\n+{\n+  typedef unsigned char *BufferedRead__T3;\n+\n+  void * t;\n+  int result;\n+  int total;\n+  int n;\n+  BufferedRead__T3 p;\n+  FIO_FileDescriptor fd;\n+\n+  if (f != Error)\n+    {\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+      total = 0;  /* how many bytes have we read  */\n+      if (fd != NULL)  /* how many bytes have we read  */\n+        {\n+          /* extract from the buffer first  */\n+          if (fd->buffer != NULL)\n+            {\n+              while (nBytes > 0)\n+                {\n+                  if ((fd->buffer->left > 0) && fd->buffer->valid)\n+                    {\n+                      if (nBytes == 1)\n+                        {\n+                          /* too expensive to call memcpy for 1 character  */\n+                          p = static_cast<BufferedRead__T3> (a);\n+                          (*p) = static_cast<unsigned char> ((*fd->buffer->contents).array[fd->buffer->position]);\n+                          fd->buffer->left -= 1;  /* remove consumed byte  */\n+                          fd->buffer->position += 1;  /* move onwards n byte  */\n+                          total += 1;  /* move onwards n byte  */\n+                          return total;\n+                        }\n+                      else\n+                        {\n+                          n = Min (fd->buffer->left, nBytes);\n+                          t = fd->buffer->address;\n+                          t = reinterpret_cast<void *> (reinterpret_cast<char *> (t)+fd->buffer->position);\n+                          p = static_cast<BufferedRead__T3> (libc_memcpy (a, t, static_cast<size_t> (n)));\n+                          fd->buffer->left -= n;  /* remove consumed bytes  */\n+                          fd->buffer->position += n;  /* move onwards n bytes  */\n+                          /* move onwards ready for direct reads  */\n+                          a = reinterpret_cast<void *> (reinterpret_cast<char *> (a)+n);\n+                          nBytes -= n;  /* reduce the amount for future direct  */\n+                          /* read  */\n+                          total += n;\n+                        }\n+                    }\n+                  else\n+                    {\n+                      /* refill buffer  */\n+                      n = static_cast<int> (libc_read (fd->unixfd, fd->buffer->address, static_cast<size_t> (fd->buffer->size)));\n+                      if (n >= 0)\n+                        {\n+                          /* avoid dangling else.  */\n+                          fd->buffer->valid = TRUE;\n+                          fd->buffer->position = 0;\n+                          fd->buffer->left = n;\n+                          fd->buffer->filled = n;\n+                          fd->buffer->bufstart = fd->abspos;\n+                          fd->abspos += n;\n+                          if (n == 0)\n+                            {\n+                              /* eof reached  */\n+                              fd->state = FIO_endoffile;\n+                              return -1;\n+                            }\n+                        }\n+                      else\n+                        {\n+                          fd->buffer->valid = FALSE;\n+                          fd->buffer->position = 0;\n+                          fd->buffer->left = 0;\n+                          fd->buffer->filled = 0;\n+                          fd->state = FIO_failed;\n+                          return total;\n+                        }\n+                    }\n+                }\n+              return total;\n+            }\n+        }\n+    }\n+  return -1;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   HandleEscape - translates \n+ and \\t into their respective ascii codes.\n+*/\n+\n+static void HandleEscape (char *dest, unsigned int _dest_high, const char *src_, unsigned int _src_high, unsigned int *i, unsigned int *j, unsigned int HighSrc, unsigned int HighDest)\n+{\n+  char src[_src_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (src, src_, _src_high+1);\n+\n+  if (((((*i)+1) < HighSrc) && (src[(*i)] == '\\\\')) && ((*j) < HighDest))\n+    {\n+      /* avoid gcc warning by using compound statement even if not strictly necessary.  */\n+      if (src[(*i)+1] == 'n')\n+        {\n+          /* requires a newline  */\n+          dest[(*j)] = ASCII_nl;\n+          (*j) += 1;\n+          (*i) += 2;\n+        }\n+      else if (src[(*i)+1] == 't')\n+        {\n+          /* avoid dangling else.  */\n+          /* requires a tab (yuck) tempted to fake this but I better not..  */\n+          dest[(*j)] = ASCII_tab;\n+          (*j) += 1;\n+          (*i) += 2;\n+        }\n+      else\n+        {\n+          /* avoid dangling else.  */\n+          /* copy escaped character  */\n+          (*i) += 1;\n+          dest[(*j)] = src[(*i)];\n+          (*j) += 1;\n+          (*i) += 1;\n+        }\n+    }\n+}\n+\n+\n+/*\n+   Cast - casts a := b\n+*/\n+\n+static void Cast (unsigned char *a, unsigned int _a_high, const unsigned char *b_, unsigned int _b_high)\n+{\n+  unsigned int i;\n+  unsigned char b[_b_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (b, b_, _b_high+1);\n+\n+  if (_a_high == _b_high)\n+    {\n+      for (i=0; i<=_a_high; i++)\n+        {\n+          a[i] = b[i];\n+        }\n+    }\n+  else\n+    {\n+      FormatError ((const char *) \"cast failed\", 11);\n+    }\n+}\n+\n+\n+/*\n+   StringFormat1 - converts string, src, into, dest, together with encapsulated\n+                   entity, w. It only formats the first %s or %d with n.\n+*/\n+\n+static void StringFormat1 (char *dest, unsigned int _dest_high, const char *src_, unsigned int _src_high, const unsigned char *w_, unsigned int _w_high)\n+{\n+  typedef struct StringFormat1__T8_a StringFormat1__T8;\n+\n+  typedef char *StringFormat1__T4;\n+\n+  struct StringFormat1__T8_a { char array[MaxErrorString+1]; };\n+  unsigned int HighSrc;\n+  unsigned int HighDest;\n+  unsigned int c;\n+  unsigned int i;\n+  unsigned int j;\n+  StringFormat1__T8 str;\n+  StringFormat1__T4 p;\n+  char src[_src_high+1];\n+  unsigned char w[_w_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (src, src_, _src_high+1);\n+  memcpy (w, w_, _w_high+1);\n+\n+  HighSrc = StrLib_StrLen ((const char *) src, _src_high);\n+  HighDest = _dest_high;\n+  p = NULL;\n+  c = 0;\n+  i = 0;\n+  j = 0;\n+  while ((((i < HighSrc) && (src[i] != ASCII_nul)) && (j < HighDest)) && (src[i] != '%'))\n+    {\n+      if (src[i] == '\\\\')\n+        {\n+          HandleEscape ((char *) dest, _dest_high, (const char *) src, _src_high, &i, &j, HighSrc, HighDest);\n+        }\n+      else\n+        {\n+          dest[j] = src[i];\n+          i += 1;\n+          j += 1;\n+        }\n+    }\n+  if ((((i+1) < HighSrc) && (src[i] == '%')) && (j < HighDest))\n+    {\n+      /* avoid gcc warning by using compound statement even if not strictly necessary.  */\n+      if (src[i+1] == 's')\n+        {\n+          Cast ((unsigned char *) &p, (sizeof (p)-1), (const unsigned char *) w, _w_high);\n+          while ((j < HighDest) && ((*p) != ASCII_nul))\n+            {\n+              dest[j] = (*p);\n+              j += 1;\n+              p += 1;\n+            }\n+          if (j < HighDest)\n+            {\n+              dest[j] = ASCII_nul;\n+            }\n+          j = StrLib_StrLen ((const char *) dest, _dest_high);\n+          i += 2;\n+        }\n+      else if (src[i+1] == 'd')\n+        {\n+          /* avoid dangling else.  */\n+          dest[j] = ASCII_nul;\n+          Cast ((unsigned char *) &c, (sizeof (c)-1), (const unsigned char *) w, _w_high);\n+          NumberIO_CardToStr (c, 0, (char *) &str.array[0], MaxErrorString);\n+          StrLib_StrConCat ((const char *) dest, _dest_high, (const char *) &str.array[0], MaxErrorString, (char *) dest, _dest_high);\n+          j = StrLib_StrLen ((const char *) dest, _dest_high);\n+          i += 2;\n+        }\n+      else\n+        {\n+          /* avoid dangling else.  */\n+          dest[j] = src[i];\n+          i += 1;\n+          j += 1;\n+        }\n+    }\n+  /* and finish off copying src into dest  */\n+  while (((i < HighSrc) && (src[i] != ASCII_nul)) && (j < HighDest))\n+    {\n+      if (src[i] == '\\\\')\n+        {\n+          HandleEscape ((char *) dest, _dest_high, (const char *) src, _src_high, &i, &j, HighSrc, HighDest);\n+        }\n+      else\n+        {\n+          dest[j] = src[i];\n+          i += 1;\n+          j += 1;\n+        }\n+    }\n+  if (j < HighDest)\n+    {\n+      dest[j] = ASCII_nul;\n+    }\n+}\n+\n+\n+/*\n+   FormatError - provides a orthoganal counterpart to the procedure below.\n+*/\n+\n+static void FormatError (const char *a_, unsigned int _a_high)\n+{\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  FIO_WriteString (FIO_StdErr, (const char *) a, _a_high);\n+}\n+\n+\n+/*\n+   FormatError1 - generic error procedure taking standard format string\n+                  and single parameter.\n+*/\n+\n+static void FormatError1 (const char *a_, unsigned int _a_high, const unsigned char *w_, unsigned int _w_high)\n+{\n+  typedef struct FormatError1__T9_a FormatError1__T9;\n+\n+  struct FormatError1__T9_a { char array[MaxErrorString+1]; };\n+  FormatError1__T9 s;\n+  char a[_a_high+1];\n+  unsigned char w[_w_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+  memcpy (w, w_, _w_high+1);\n+\n+  StringFormat1 ((char *) &s.array[0], MaxErrorString, (const char *) a, _a_high, (const unsigned char *) w, _w_high);\n+  FormatError ((const char *) &s.array[0], MaxErrorString);\n+}\n+\n+\n+/*\n+   FormatError2 - generic error procedure taking standard format string\n+                  and two parameters.\n+*/\n+\n+static void FormatError2 (const char *a_, unsigned int _a_high, const unsigned char *w1_, unsigned int _w1_high, const unsigned char *w2_, unsigned int _w2_high)\n+{\n+  typedef struct FormatError2__T10_a FormatError2__T10;\n+\n+  struct FormatError2__T10_a { char array[MaxErrorString+1]; };\n+  FormatError2__T10 s;\n+  char a[_a_high+1];\n+  unsigned char w1[_w1_high+1];\n+  unsigned char w2[_w2_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+  memcpy (w1, w1_, _w1_high+1);\n+  memcpy (w2, w2_, _w2_high+1);\n+\n+  StringFormat1 ((char *) &s.array[0], MaxErrorString, (const char *) a, _a_high, (const unsigned char *) w1, _w1_high);\n+  FormatError1 ((const char *) &s.array[0], MaxErrorString, (const unsigned char *) w2, _w2_high);\n+}\n+\n+\n+/*\n+   CheckAccess - checks to see whether a file f has been\n+                 opened for read/write.\n+*/\n+\n+static void CheckAccess (FIO_File f, FIO_FileUsage use, unsigned int towrite)\n+{\n+  FIO_FileDescriptor fd;\n+\n+  if (f != Error)\n+    {\n+      /* avoid dangling else.  */\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+      if (fd == NULL)\n+        {\n+          if (f != FIO_StdErr)\n+            {\n+              FormatError ((const char *) \"this file has probably been closed and not reopened successfully or alternatively never opened\\\\n\", 96);\n+            }\n+          M2RTS_HALT (-1);\n+          __builtin_unreachable ();\n+        }\n+      else\n+        {\n+          if ((use == FIO_openedforwrite) && (fd->usage == FIO_openedforread))\n+            {\n+              FormatError1 ((const char *) \"this file (%s) has been opened for reading but is now being written\\\\n\", 69, (const unsigned char *) &fd->name.address, (sizeof (fd->name.address)-1));\n+              M2RTS_HALT (-1);\n+              __builtin_unreachable ();\n+            }\n+          else if ((use == FIO_openedforread) && (fd->usage == FIO_openedforwrite))\n+            {\n+              /* avoid dangling else.  */\n+              FormatError1 ((const char *) \"this file (%s) has been opened for writing but is now being read\\\\n\", 66, (const unsigned char *) &fd->name.address, (sizeof (fd->name.address)-1));\n+              M2RTS_HALT (-1);\n+              __builtin_unreachable ();\n+            }\n+          else if (fd->state == FIO_connectionfailure)\n+            {\n+              /* avoid dangling else.  */\n+              FormatError1 ((const char *) \"this file (%s) was not successfully opened\\\\n\", 44, (const unsigned char *) &fd->name.address, (sizeof (fd->name.address)-1));\n+              M2RTS_HALT (-1);\n+              __builtin_unreachable ();\n+            }\n+          else if (towrite != fd->output)\n+            {\n+              /* avoid dangling else.  */\n+              if (fd->output)\n+                {\n+                  FormatError1 ((const char *) \"this file (%s) was opened for writing but is now being read\\\\n\", 61, (const unsigned char *) &fd->name.address, (sizeof (fd->name.address)-1));\n+                  M2RTS_HALT (-1);\n+                  __builtin_unreachable ();\n+                }\n+              else\n+                {\n+                  FormatError1 ((const char *) \"this file (%s) was opened for reading but is now being written\\\\n\", 64, (const unsigned char *) &fd->name.address, (sizeof (fd->name.address)-1));\n+                  M2RTS_HALT (-1);\n+                  __builtin_unreachable ();\n+                }\n+            }\n+        }\n+    }\n+  else\n+    {\n+      FormatError ((const char *) \"this file has not been opened successfully\\\\n\", 44);\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n+    }\n+}\n+\n+\n+/*\n+   SetEndOfLine -\n+*/\n+\n+static void SetEndOfLine (FIO_File f, char ch)\n+{\n+  FIO_FileDescriptor fd;\n+\n+  CheckAccess (f, FIO_openedforread, FALSE);\n+  if (f != Error)\n+    {\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+      if (ch == ASCII_nl)\n+        {\n+          fd->state = FIO_endofline;\n+        }\n+      else\n+        {\n+          fd->state = FIO_successful;\n+        }\n+    }\n+}\n+\n+\n+/*\n+   BufferedWrite - will write, nBytes, through the buffer.\n+                   Similar to WriteNBytes, but this function will always\n+                   write into the buffer before copying into memory.\n+\n+                   Useful when performing small writes.\n+*/\n+\n+static int BufferedWrite (FIO_File f, unsigned int nBytes, void * a)\n+{\n+  typedef unsigned char *BufferedWrite__T5;\n+\n+  void * t;\n+  int result;\n+  int total;\n+  int n;\n+  BufferedWrite__T5 p;\n+  FIO_FileDescriptor fd;\n+\n+  if (f != Error)\n+    {\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+      if (fd != NULL)\n+        {\n+          total = 0;  /* how many bytes have we read  */\n+          if (fd->buffer != NULL)  /* how many bytes have we read  */\n+            {\n+              /* place into the buffer first  */\n+              while (nBytes > 0)\n+                {\n+                  if (fd->buffer->left > 0)\n+                    {\n+                      if (nBytes == 1)\n+                        {\n+                          /* too expensive to call memcpy for 1 character  */\n+                          p = static_cast<BufferedWrite__T5> (a);\n+                          (*fd->buffer->contents).array[fd->buffer->position] = static_cast<char> ((*p));\n+                          fd->buffer->left -= 1;  /* reduce space  */\n+                          fd->buffer->position += 1;  /* move onwards n byte  */\n+                          total += 1;  /* move onwards n byte  */\n+                          return total;\n+                        }\n+                      else\n+                        {\n+                          n = Min (fd->buffer->left, nBytes);\n+                          t = fd->buffer->address;\n+                          t = reinterpret_cast<void *> (reinterpret_cast<char *> (t)+fd->buffer->position);\n+                          p = static_cast<BufferedWrite__T5> (libc_memcpy (a, t, static_cast<size_t> ((unsigned int ) (n))));\n+                          fd->buffer->left -= n;  /* remove consumed bytes  */\n+                          fd->buffer->position += n;  /* move onwards n bytes  */\n+                          /* move ready for further writes  */\n+                          a = reinterpret_cast<void *> (reinterpret_cast<char *> (a)+n);\n+                          nBytes -= n;  /* reduce the amount for future writes  */\n+                          total += n;  /* reduce the amount for future writes  */\n+                        }\n+                    }\n+                  else\n+                    {\n+                      FIO_FlushBuffer (f);\n+                      if ((fd->state != FIO_successful) && (fd->state != FIO_endofline))\n+                        {\n+                          nBytes = 0;\n+                        }\n+                    }\n+                }\n+              return total;\n+            }\n+        }\n+    }\n+  return -1;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   PreInitialize - preinitialize the file descriptor.\n+*/\n+\n+static void PreInitialize (FIO_File f, const char *fname_, unsigned int _fname_high, FIO_FileStatus state, FIO_FileUsage use, unsigned int towrite, int osfd, unsigned int bufsize)\n+{\n+  FIO_FileDescriptor fd;\n+  FIO_FileDescriptor fe;\n+  char fname[_fname_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (fname, fname_, _fname_high+1);\n+\n+  if ((InitializeFile (f, &fname, StrLib_StrLen ((const char *) fname, _fname_high), state, use, towrite, bufsize)) == f)\n+    {\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+      if (f == Error)\n+        {\n+          fe = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, FIO_StdErr));\n+          if (fe == NULL)\n+            {\n+              M2RTS_HALT (-1);\n+              __builtin_unreachable ();\n+            }\n+          else\n+            {\n+              fd->unixfd = fe->unixfd;  /* the error channel  */\n+            }\n+        }\n+      else\n+        {\n+          fd->unixfd = osfd;\n+        }\n+    }\n+  else\n+    {\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n+    }\n+}\n+\n+\n+/*\n+   Init - initialize the modules, global variables.\n+*/\n+\n+static void Init (void)\n+{\n+  FileInfo = Indexing_InitIndex (0);\n+  Error = 0;\n+  PreInitialize (Error, (const char *) \"error\", 5, FIO_toomanyfilesopen, FIO_unused, FALSE, -1, 0);\n+  FIO_StdIn = 1;\n+  PreInitialize (FIO_StdIn, (const char *) \"<stdin>\", 7, FIO_successful, FIO_openedforread, FALSE, 0, MaxBufferLength);\n+  FIO_StdOut = 2;\n+  PreInitialize (FIO_StdOut, (const char *) \"<stdout>\", 8, FIO_successful, FIO_openedforwrite, TRUE, 1, MaxBufferLength);\n+  FIO_StdErr = 3;\n+  PreInitialize (FIO_StdErr, (const char *) \"<stderr>\", 8, FIO_successful, FIO_openedforwrite, TRUE, 2, MaxBufferLength);\n+  if (! (M2RTS_InstallTerminationProcedure ((PROC ) {(PROC_t) FIO_FlushOutErr})))\n+    {\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n+    }\n+}\n+\n+\n+/*\n+   IsNoError - returns a TRUE if no error has occured on file, f.\n+*/\n+\n+extern \"C\" unsigned int FIO_IsNoError (FIO_File f)\n+{\n+  FIO_FileDescriptor fd;\n+\n+  if (f == Error)\n+    {\n+      return FALSE;\n+    }\n+  else\n+    {\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+      return (fd != NULL) && (((fd->state == FIO_successful) || (fd->state == FIO_endoffile)) || (fd->state == FIO_endofline));\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   IsActive - returns TRUE if the file, f, is still active.\n+*/\n+\n+extern \"C\" unsigned int FIO_IsActive (FIO_File f)\n+{\n+  if (f == Error)\n+    {\n+      return FALSE;\n+    }\n+  else\n+    {\n+      return (Indexing_GetIndice (FileInfo, f)) != NULL;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" unsigned int FIO_Exists (const char *fname_, unsigned int _fname_high)\n+{\n+  char fname[_fname_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (fname, fname_, _fname_high+1);\n+\n+  /* \n+   The following functions are wrappers for the above.\n+  */\n+  return FIO_exists (&fname, StrLib_StrLen ((const char *) fname, _fname_high));\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" FIO_File FIO_OpenToRead (const char *fname_, unsigned int _fname_high)\n+{\n+  char fname[_fname_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (fname, fname_, _fname_high+1);\n+\n+  return FIO_openToRead (&fname, StrLib_StrLen ((const char *) fname, _fname_high));\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" FIO_File FIO_OpenToWrite (const char *fname_, unsigned int _fname_high)\n+{\n+  char fname[_fname_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (fname, fname_, _fname_high+1);\n+\n+  return FIO_openToWrite (&fname, StrLib_StrLen ((const char *) fname, _fname_high));\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" FIO_File FIO_OpenForRandom (const char *fname_, unsigned int _fname_high, unsigned int towrite, unsigned int newfile)\n+{\n+  char fname[_fname_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (fname, fname_, _fname_high+1);\n+\n+  return FIO_openForRandom (&fname, StrLib_StrLen ((const char *) fname, _fname_high), towrite, newfile);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Close - close a file which has been previously opened using:\n+           OpenToRead, OpenToWrite, OpenForRandom.\n+           It is correct to close a file which has an error status.\n+*/\n+\n+extern \"C\" void FIO_Close (FIO_File f)\n+{\n+  FIO_FileDescriptor fd;\n+\n+  if (f != Error)\n+    {\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+      /* \n+         we allow users to close files which have an error status\n+  */\n+      if (fd != NULL)\n+        {\n+          FIO_FlushBuffer (f);\n+          if (fd->unixfd >= 0)\n+            {\n+              if ((libc_close (fd->unixfd)) != 0)\n+                {\n+                  FormatError1 ((const char *) \"failed to close file (%s)\\\\n\", 27, (const unsigned char *) &fd->name.address, (sizeof (fd->name.address)-1));\n+                  fd->state = FIO_failed;  /* --fixme-- too late to notify user (unless we return a BOOLEAN)  */\n+                }\n+            }\n+          if (fd->name.address != NULL)\n+            {\n+              Storage_DEALLOCATE (&fd->name.address, fd->name.size);\n+            }\n+          if (fd->buffer != NULL)\n+            {\n+              if (fd->buffer->address != NULL)\n+                {\n+                  Storage_DEALLOCATE (&fd->buffer->address, fd->buffer->size);\n+                }\n+              Storage_DEALLOCATE ((void **) &fd->buffer, sizeof (FIO_buf));\n+              fd->buffer = NULL;\n+            }\n+          Storage_DEALLOCATE ((void **) &fd, sizeof (FIO_fds));\n+          Indexing_PutIndice (FileInfo, f, NULL);\n+        }\n+    }\n+}\n+\n+\n+/*\n+   exists - returns TRUE if a file named, fname exists for reading.\n+*/\n+\n+extern \"C\" unsigned int FIO_exists (void * fname, unsigned int flength)\n+{\n+  FIO_File f;\n+\n+  f = FIO_openToRead (fname, flength);\n+  if (FIO_IsNoError (f))\n+    {\n+      FIO_Close (f);\n+      return TRUE;\n+    }\n+  else\n+    {\n+      FIO_Close (f);\n+      return FALSE;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   openToRead - attempts to open a file, fname, for reading and\n+                it returns this file.\n+                The success of this operation can be checked by\n+                calling IsNoError.\n+*/\n+\n+extern \"C\" FIO_File FIO_openToRead (void * fname, unsigned int flength)\n+{\n+  FIO_File f;\n+\n+  f = GetNextFreeDescriptor ();\n+  if (f == Error)\n+    {\n+      SetState (f, FIO_toomanyfilesopen);\n+    }\n+  else\n+    {\n+      f = InitializeFile (f, fname, flength, FIO_successful, FIO_openedforread, FALSE, MaxBufferLength);\n+      ConnectToUnix (f, FALSE, FALSE);\n+    }\n+  return f;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   openToWrite - attempts to open a file, fname, for write and\n+                 it returns this file.\n+                 The success of this operation can be checked by\n+                 calling IsNoError.\n+*/\n+\n+extern \"C\" FIO_File FIO_openToWrite (void * fname, unsigned int flength)\n+{\n+  FIO_File f;\n+\n+  f = GetNextFreeDescriptor ();\n+  if (f == Error)\n+    {\n+      SetState (f, FIO_toomanyfilesopen);\n+    }\n+  else\n+    {\n+      f = InitializeFile (f, fname, flength, FIO_successful, FIO_openedforwrite, TRUE, MaxBufferLength);\n+      ConnectToUnix (f, TRUE, TRUE);\n+    }\n+  return f;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   openForRandom - attempts to open a file, fname, for random access\n+                   read or write and it returns this file.\n+                   The success of this operation can be checked by\n+                   calling IsNoError.\n+                   towrite, determines whether the file should be\n+                   opened for writing or reading.\n+*/\n+\n+extern \"C\" FIO_File FIO_openForRandom (void * fname, unsigned int flength, unsigned int towrite, unsigned int newfile)\n+{\n+  FIO_File f;\n+\n+  f = GetNextFreeDescriptor ();\n+  if (f == Error)\n+    {\n+      SetState (f, FIO_toomanyfilesopen);\n+    }\n+  else\n+    {\n+      f = InitializeFile (f, fname, flength, FIO_successful, FIO_openedforrandom, towrite, MaxBufferLength);\n+      ConnectToUnix (f, towrite, newfile);\n+    }\n+  return f;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   FlushBuffer - flush contents of file, f.\n+*/\n+\n+extern \"C\" void FIO_FlushBuffer (FIO_File f)\n+{\n+  FIO_FileDescriptor fd;\n+\n+  if (f != Error)\n+    {\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+      if (fd != NULL)\n+        {\n+          if (fd->output && (fd->buffer != NULL))\n+            {\n+              if ((fd->buffer->position == 0) || ((libc_write (fd->unixfd, fd->buffer->address, static_cast<size_t> (fd->buffer->position))) == ((int ) (fd->buffer->position))))\n+                {\n+                  fd->abspos += fd->buffer->position;\n+                  fd->buffer->bufstart = fd->abspos;\n+                  fd->buffer->position = 0;\n+                  fd->buffer->filled = 0;\n+                  fd->buffer->left = fd->buffer->size;\n+                }\n+              else\n+                {\n+                  fd->state = FIO_failed;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\n+/*\n+   ReadNBytes - reads nBytes of a file into memory area, dest, returning\n+                the number of bytes actually read.\n+                This function will consume from the buffer and then\n+                perform direct libc reads. It is ideal for large reads.\n+*/\n+\n+extern \"C\" unsigned int FIO_ReadNBytes (FIO_File f, unsigned int nBytes, void * dest)\n+{\n+  typedef char *ReadNBytes__T2;\n+\n+  int n;\n+  ReadNBytes__T2 p;\n+\n+  if (f != Error)\n+    {\n+      CheckAccess (f, FIO_openedforread, FALSE);\n+      n = ReadFromBuffer (f, dest, nBytes);\n+      if (n <= 0)\n+        {\n+          return 0;\n+        }\n+      else\n+        {\n+          p = static_cast<ReadNBytes__T2> (dest);\n+          p += n-1;\n+          SetEndOfLine (f, (*p));\n+          return n;\n+        }\n+    }\n+  else\n+    {\n+      return 0;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   ReadAny - reads HIGH(a) bytes into, a. All input\n+             is fully buffered, unlike ReadNBytes and thus is more\n+             suited to small reads.\n+*/\n+\n+extern \"C\" void FIO_ReadAny (FIO_File f, unsigned char *a, unsigned int _a_high)\n+{\n+  CheckAccess (f, FIO_openedforread, FALSE);\n+  if ((BufferedRead (f, _a_high, a)) == ((int ) (_a_high)))\n+    {\n+      SetEndOfLine (f, static_cast<char> (a[_a_high]));\n+    }\n+}\n+\n+\n+/*\n+   WriteNBytes - writes nBytes from memory area src to a file\n+                 returning the number of bytes actually written.\n+                 This function will flush the buffer and then\n+                 write the nBytes using a direct write from libc.\n+                 It is ideal for large writes.\n+*/\n+\n+extern \"C\" unsigned int FIO_WriteNBytes (FIO_File f, unsigned int nBytes, void * src)\n+{\n+  int total;\n+  FIO_FileDescriptor fd;\n+\n+  CheckAccess (f, FIO_openedforwrite, TRUE);\n+  FIO_FlushBuffer (f);\n+  if (f != Error)\n+    {\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+      if (fd != NULL)\n+        {\n+          total = static_cast<int> (libc_write (fd->unixfd, src, static_cast<size_t> ((int ) (nBytes))));\n+          if (total < 0)\n+            {\n+              fd->state = FIO_failed;\n+              return 0;\n+            }\n+          else\n+            {\n+              fd->abspos += (unsigned int ) (total);\n+              if (fd->buffer != NULL)\n+                {\n+                  fd->buffer->bufstart = fd->abspos;\n+                }\n+              return (unsigned int ) (total);\n+            }\n+        }\n+    }\n+  return 0;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   WriteAny - writes HIGH(a) bytes onto, file, f. All output\n+              is fully buffered, unlike WriteNBytes and thus is more\n+              suited to small writes.\n+*/\n+\n+extern \"C\" void FIO_WriteAny (FIO_File f, unsigned char *a, unsigned int _a_high)\n+{\n+  CheckAccess (f, FIO_openedforwrite, TRUE);\n+  if ((BufferedWrite (f, _a_high, a)) == ((int ) (_a_high)))\n+    {}  /* empty.  */\n+}\n+\n+\n+/*\n+   WriteChar - writes a single character to file, f.\n+*/\n+\n+extern \"C\" void FIO_WriteChar (FIO_File f, char ch)\n+{\n+  CheckAccess (f, FIO_openedforwrite, TRUE);\n+  if ((BufferedWrite (f, sizeof (ch), &ch)) == ((int ) (sizeof (ch))))\n+    {}  /* empty.  */\n+}\n+\n+\n+/*\n+   EOF - tests to see whether a file, f, has reached end of file.\n+*/\n+\n+extern \"C\" unsigned int FIO_EOF (FIO_File f)\n+{\n+  FIO_FileDescriptor fd;\n+\n+  CheckAccess (f, FIO_openedforread, FALSE);\n+  if (f != Error)\n+    {\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+      if (fd != NULL)\n+        {\n+          return fd->state == FIO_endoffile;\n+        }\n+    }\n+  return TRUE;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   EOLN - tests to see whether a file, f, is upon a newline.\n+          It does NOT consume the newline.\n+*/\n+\n+extern \"C\" unsigned int FIO_EOLN (FIO_File f)\n+{\n+  char ch;\n+  FIO_FileDescriptor fd;\n+\n+  CheckAccess (f, FIO_openedforread, FALSE);\n+  /* \n+      we will read a character and then push it back onto the input stream,\n+      having noted the file status, we also reset the status.\n+  */\n+  if (f != Error)\n+    {\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+      if (fd != NULL)\n+        {\n+          if ((fd->state == FIO_successful) || (fd->state == FIO_endofline))\n+            {\n+              ch = FIO_ReadChar (f);\n+              if ((fd->state == FIO_successful) || (fd->state == FIO_endofline))\n+                {\n+                  FIO_UnReadChar (f, ch);\n+                }\n+              return ch == ASCII_nl;\n+            }\n+        }\n+    }\n+  return FALSE;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   WasEOLN - tests to see whether a file, f, has just seen a newline.\n+*/\n+\n+extern \"C\" unsigned int FIO_WasEOLN (FIO_File f)\n+{\n+  FIO_FileDescriptor fd;\n+\n+  CheckAccess (f, FIO_openedforread, FALSE);\n+  if (f == Error)\n+    {\n+      return FALSE;\n+    }\n+  else\n+    {\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+      return (fd != NULL) && (fd->state == FIO_endofline);\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   ReadChar - returns a character read from file f.\n+              Sensible to check with IsNoError or EOF after calling\n+              this function.\n+*/\n+\n+extern \"C\" char FIO_ReadChar (FIO_File f)\n+{\n+  char ch;\n+\n+  CheckAccess (f, FIO_openedforread, FALSE);\n+  if ((BufferedRead (f, sizeof (ch), &ch)) == ((int ) (sizeof (ch))))\n+    {\n+      SetEndOfLine (f, ch);\n+      return ch;\n+    }\n+  else\n+    {\n+      return ASCII_nul;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   UnReadChar - replaces a character, ch, back into file f.\n+                This character must have been read by ReadChar\n+                and it does not allow successive calls.  It may\n+                only be called if the previous read was successful\n+                or end of file was seen.\n+                If the state was previously endoffile then it\n+                is altered to successful.\n+                Otherwise it is left alone.\n+*/\n+\n+extern \"C\" void FIO_UnReadChar (FIO_File f, char ch)\n+{\n+  FIO_FileDescriptor fd;\n+  unsigned int n;\n+  void * a;\n+  void * b;\n+\n+  CheckAccess (f, FIO_openedforread, FALSE);\n+  if (f != Error)\n+    {\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+      if (((fd->state == FIO_successful) || (fd->state == FIO_endoffile)) || (fd->state == FIO_endofline))\n+        {\n+          /* avoid dangling else.  */\n+          if ((fd->buffer != NULL) && fd->buffer->valid)\n+            {\n+              /* we assume that a ReadChar has occurred, we will check just in case.  */\n+              if (fd->state == FIO_endoffile)\n+                {\n+                  fd->buffer->position = MaxBufferLength;\n+                  fd->buffer->left = 0;\n+                  fd->buffer->filled = 0;\n+                  fd->state = FIO_successful;\n+                }\n+              if (fd->buffer->position > 0)\n+                {\n+                  fd->buffer->position -= 1;\n+                  fd->buffer->left += 1;\n+                  (*fd->buffer->contents).array[fd->buffer->position] = ch;\n+                }\n+              else\n+                {\n+                  /* if possible make room and store ch  */\n+                  if (fd->buffer->filled == fd->buffer->size)\n+                    {\n+                      FormatError1 ((const char *) \"performing too many UnReadChar calls on file (%d)\\\\n\", 51, (const unsigned char *) &f, (sizeof (f)-1));\n+                    }\n+                  else\n+                    {\n+                      n = fd->buffer->filled-fd->buffer->position;\n+                      b = &(*fd->buffer->contents).array[fd->buffer->position];\n+                      a = &(*fd->buffer->contents).array[fd->buffer->position+1];\n+                      a = libc_memcpy (a, b, static_cast<size_t> (n));\n+                      fd->buffer->filled += 1;\n+                      (*fd->buffer->contents).array[fd->buffer->position] = ch;\n+                    }\n+                }\n+            }\n+        }\n+      else\n+        {\n+          FormatError1 ((const char *) \"UnReadChar can only be called if the previous read was successful or end of file, error on file (%d)\\\\n\", 102, (const unsigned char *) &f, (sizeof (f)-1));\n+        }\n+    }\n+}\n+\n+\n+/*\n+   WriteLine - writes out a linefeed to file, f.\n+*/\n+\n+extern \"C\" void FIO_WriteLine (FIO_File f)\n+{\n+  FIO_WriteChar (f, ASCII_nl);\n+}\n+\n+\n+/*\n+   WriteString - writes a string to file, f.\n+*/\n+\n+extern \"C\" void FIO_WriteString (FIO_File f, const char *a_, unsigned int _a_high)\n+{\n+  unsigned int l;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  l = StrLib_StrLen ((const char *) a, _a_high);\n+  if ((FIO_WriteNBytes (f, l, &a)) != l)\n+    {}  /* empty.  */\n+}\n+\n+\n+/*\n+   ReadString - reads a string from file, f, into string, a.\n+                It terminates the string if HIGH is reached or\n+                if a newline is seen or an error occurs.\n+*/\n+\n+extern \"C\" void FIO_ReadString (FIO_File f, char *a, unsigned int _a_high)\n+{\n+  unsigned int high;\n+  unsigned int i;\n+  char ch;\n+\n+  CheckAccess (f, FIO_openedforread, FALSE);\n+  high = _a_high;\n+  i = 0;\n+  do {\n+    ch = FIO_ReadChar (f);\n+    if (i <= high)\n+      {\n+        /* avoid gcc warning by using compound statement even if not strictly necessary.  */\n+        if (((ch == ASCII_nl) || (! (FIO_IsNoError (f)))) || (FIO_EOF (f)))\n+          {\n+            a[i] = ASCII_nul;\n+            i += 1;\n+          }\n+        else\n+          {\n+            a[i] = ch;\n+            i += 1;\n+          }\n+      }\n+  } while (! ((((ch == ASCII_nl) || (i > high)) || (! (FIO_IsNoError (f)))) || (FIO_EOF (f))));\n+}\n+\n+\n+/*\n+   WriteCardinal - writes a CARDINAL to file, f.\n+                   It writes the binary image of the cardinal\n+                   to file, f.\n+*/\n+\n+extern \"C\" void FIO_WriteCardinal (FIO_File f, unsigned int c)\n+{\n+  FIO_WriteAny (f, (unsigned char *) &c, (sizeof (c)-1));\n+}\n+\n+\n+/*\n+   ReadCardinal - reads a CARDINAL from file, f.\n+                  It reads a binary image of a CARDINAL\n+                  from a file, f.\n+*/\n+\n+extern \"C\" unsigned int FIO_ReadCardinal (FIO_File f)\n+{\n+  unsigned int c;\n+\n+  FIO_ReadAny (f, (unsigned char *) &c, (sizeof (c)-1));\n+  return c;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   GetUnixFileDescriptor - returns the UNIX file descriptor of a file.\n+*/\n+\n+extern \"C\" int FIO_GetUnixFileDescriptor (FIO_File f)\n+{\n+  FIO_FileDescriptor fd;\n+\n+  if (f != Error)\n+    {\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+      if (fd != NULL)\n+        {\n+          return fd->unixfd;\n+        }\n+    }\n+  FormatError1 ((const char *) \"file %d has not been opened or is out of range\\\\n\", 48, (const unsigned char *) &f, (sizeof (f)-1));\n+  return -1;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   SetPositionFromBeginning - sets the position from the beginning of the file.\n+*/\n+\n+extern \"C\" void FIO_SetPositionFromBeginning (FIO_File f, long int pos)\n+{\n+  long int offset;\n+  FIO_FileDescriptor fd;\n+\n+  if (f != Error)\n+    {\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+      if (fd != NULL)\n+        {\n+          /* always force the lseek, until we are confident that abspos is always correct,\n+               basically it needs some hard testing before we should remove the OR TRUE.  */\n+          if ((fd->abspos != pos) || TRUE)\n+            {\n+              FIO_FlushBuffer (f);\n+              if (fd->buffer != NULL)\n+                {\n+                  if (fd->output)\n+                    {\n+                      fd->buffer->left = fd->buffer->size;\n+                    }\n+                  else\n+                    {\n+                      fd->buffer->left = 0;\n+                    }\n+                  fd->buffer->position = 0;\n+                  fd->buffer->filled = 0;\n+                }\n+              offset = libc_lseek (fd->unixfd, pos, SEEK_SET);\n+              if ((offset >= 0) && (pos == offset))\n+                {\n+                  fd->abspos = pos;\n+                }\n+              else\n+                {\n+                  fd->state = FIO_failed;\n+                  fd->abspos = 0;\n+                }\n+              if (fd->buffer != NULL)\n+                {\n+                  fd->buffer->valid = FALSE;\n+                  fd->buffer->bufstart = fd->abspos;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\n+/*\n+   SetPositionFromEnd - sets the position from the end of the file.\n+*/\n+\n+extern \"C\" void FIO_SetPositionFromEnd (FIO_File f, long int pos)\n+{\n+  long int offset;\n+  FIO_FileDescriptor fd;\n+\n+  if (f != Error)\n+    {\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+      if (fd != NULL)\n+        {\n+          FIO_FlushBuffer (f);\n+          if (fd->buffer != NULL)\n+            {\n+              if (fd->output)\n+                {\n+                  fd->buffer->left = fd->buffer->size;\n+                }\n+              else\n+                {\n+                  fd->buffer->left = 0;\n+                }\n+              fd->buffer->position = 0;\n+              fd->buffer->filled = 0;\n+            }\n+          offset = libc_lseek (fd->unixfd, pos, SEEK_END);\n+          if (offset >= 0)\n+            {\n+              fd->abspos = offset;\n+            }\n+          else\n+            {\n+              fd->state = FIO_failed;\n+              fd->abspos = 0;\n+              offset = 0;\n+            }\n+          if (fd->buffer != NULL)\n+            {\n+              fd->buffer->valid = FALSE;\n+              fd->buffer->bufstart = offset;\n+            }\n+        }\n+    }\n+}\n+\n+\n+/*\n+   FindPosition - returns the current absolute position in file, f.\n+*/\n+\n+extern \"C\" long int FIO_FindPosition (FIO_File f)\n+{\n+  FIO_FileDescriptor fd;\n+\n+  if (f != Error)\n+    {\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+      if (fd != NULL)\n+        {\n+          if ((fd->buffer == NULL) || ! fd->buffer->valid)\n+            {\n+              return fd->abspos;\n+            }\n+          else\n+            {\n+              return fd->buffer->bufstart+((long int ) (fd->buffer->position));\n+            }\n+        }\n+    }\n+  return 0;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   GetFileName - assigns, a, with the filename associated with, f.\n+*/\n+\n+extern \"C\" void FIO_GetFileName (FIO_File f, char *a, unsigned int _a_high)\n+{\n+  typedef char *GetFileName__T6;\n+\n+  unsigned int i;\n+  GetFileName__T6 p;\n+  FIO_FileDescriptor fd;\n+\n+  if (f != Error)\n+    {\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+      if (fd == NULL)\n+        {\n+          FormatError ((const char *) \"this file has probably been closed and not reopened successfully or alternatively never opened\\\\n\", 96);\n+          M2RTS_HALT (-1);\n+          __builtin_unreachable ();\n+        }\n+      else\n+        {\n+          if (fd->name.address == NULL)\n+            {\n+              StrLib_StrCopy ((const char *) \"\", 0, (char *) a, _a_high);\n+            }\n+          else\n+            {\n+              p = static_cast<GetFileName__T6> (fd->name.address);\n+              i = 0;\n+              while (((*p) != ASCII_nul) && (i <= _a_high))\n+                {\n+                  a[i] = (*p);\n+                  p += 1;\n+                  i += 1;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\n+/*\n+   getFileName - returns the address of the filename associated with, f.\n+*/\n+\n+extern \"C\" void * FIO_getFileName (FIO_File f)\n+{\n+  FIO_FileDescriptor fd;\n+\n+  if (f != Error)\n+    {\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+      if (fd == NULL)\n+        {\n+          FormatError ((const char *) \"this file has probably been closed and not reopened successfully or alternatively never opened\\\\n\", 96);\n+          M2RTS_HALT (-1);\n+          __builtin_unreachable ();\n+        }\n+      else\n+        {\n+          return fd->name.address;\n+        }\n+    }\n+  return NULL;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   getFileNameLength - returns the number of characters associated with filename, f.\n+*/\n+\n+extern \"C\" unsigned int FIO_getFileNameLength (FIO_File f)\n+{\n+  FIO_FileDescriptor fd;\n+\n+  if (f != Error)\n+    {\n+      fd = static_cast<FIO_FileDescriptor> (Indexing_GetIndice (FileInfo, f));\n+      if (fd == NULL)\n+        {\n+          FormatError ((const char *) \"this file has probably been closed and not reopened successfully or alternatively never opened\\\\n\", 96);\n+          M2RTS_HALT (-1);\n+          __builtin_unreachable ();\n+        }\n+      else\n+        {\n+          return fd->name.size;\n+        }\n+    }\n+  return 0;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   FlushOutErr - flushes, StdOut, and, StdErr.\n+                 It is also called when the application calls M2RTS.Terminate.\n+                 (which is automatically placed in program modules by the GM2\n+                 scaffold).\n+*/\n+\n+extern \"C\" void FIO_FlushOutErr (void)\n+{\n+  if (FIO_IsNoError (FIO_StdOut))\n+    {\n+      FIO_FlushBuffer (FIO_StdOut);\n+    }\n+  if (FIO_IsNoError (FIO_StdErr))\n+    {\n+      FIO_FlushBuffer (FIO_StdErr);\n+    }\n+}\n+\n+extern \"C\" void _M2_FIO_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+  Init ();\n+}\n+\n+extern \"C\" void _M2_FIO_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+  FIO_FlushOutErr ();\n+}"}, {"sha": "78e7a5a559c52b2036cee839a5e134bdf4322d76", "filename": "gcc/m2/mc-boot/GFormatStrings.cc", "status": "added", "additions": 845, "deletions": 0, "changes": 845, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGFormatStrings.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGFormatStrings.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGFormatStrings.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,845 @@\n+/* do not edit automatically generated by mc from FormatStrings.  */\n+/* FormatStrings.mod provides a pseudo printf capability.\n+\n+Copyright (C) 2005-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#   if !defined (TRUE)\n+#      define TRUE (1==1)\n+#   endif\n+\n+#   if !defined (FALSE)\n+#      define FALSE (1==0)\n+#   endif\n+\n+#if defined(__cplusplus)\n+#   undef NULL\n+#   define NULL 0\n+#endif\n+#define _FormatStrings_H\n+#define _FormatStrings_C\n+\n+#   include \"GDynamicStrings.h\"\n+#   include \"GStringConvert.h\"\n+#   include \"GSYSTEM.h\"\n+#   include \"GASCII.h\"\n+#   include \"GM2RTS.h\"\n+\n+\n+/*\n+   Sprintf0 - returns a String containing, s, after it has had its\n+              escape sequences translated.\n+*/\n+\n+extern \"C\" DynamicStrings_String FormatStrings_Sprintf0 (DynamicStrings_String fmt);\n+\n+/*\n+   Sprintf1 - returns a String containing, s, together with encapsulated\n+              entity, w. It only formats the first %s or %d with n.\n+*/\n+\n+extern \"C\" DynamicStrings_String FormatStrings_Sprintf1 (DynamicStrings_String fmt, const unsigned char *w_, unsigned int _w_high);\n+\n+/*\n+   Sprintf2 - returns a string, s, which has been formatted.\n+*/\n+\n+extern \"C\" DynamicStrings_String FormatStrings_Sprintf2 (DynamicStrings_String fmt, const unsigned char *w1_, unsigned int _w1_high, const unsigned char *w2_, unsigned int _w2_high);\n+\n+/*\n+   Sprintf3 - returns a string, s, which has been formatted.\n+*/\n+\n+extern \"C\" DynamicStrings_String FormatStrings_Sprintf3 (DynamicStrings_String fmt, const unsigned char *w1_, unsigned int _w1_high, const unsigned char *w2_, unsigned int _w2_high, const unsigned char *w3_, unsigned int _w3_high);\n+\n+/*\n+   Sprintf4 - returns a string, s, which has been formatted.\n+*/\n+\n+extern \"C\" DynamicStrings_String FormatStrings_Sprintf4 (DynamicStrings_String fmt, const unsigned char *w1_, unsigned int _w1_high, const unsigned char *w2_, unsigned int _w2_high, const unsigned char *w3_, unsigned int _w3_high, const unsigned char *w4_, unsigned int _w4_high);\n+\n+/*\n+   HandleEscape - translates \\a, \\b, \\e, \\f, \n+, \\r, \\x[hex] \\[octal] into\n+                  their respective ascii codes.  It also converts \\[any] into\n+                  a single [any] character.\n+*/\n+\n+extern \"C\" DynamicStrings_String FormatStrings_HandleEscape (DynamicStrings_String s);\n+\n+/*\n+   doDSdbEnter -\n+*/\n+\n+static void doDSdbEnter (void);\n+\n+/*\n+   doDSdbExit -\n+*/\n+\n+static void doDSdbExit (DynamicStrings_String s);\n+\n+/*\n+   DSdbEnter -\n+*/\n+\n+static void DSdbEnter (void);\n+\n+/*\n+   DSdbExit -\n+*/\n+\n+static void DSdbExit (DynamicStrings_String s);\n+\n+/*\n+   IsDigit - returns TRUE if ch lies in the range: 0..9\n+*/\n+\n+static unsigned int IsDigit (char ch);\n+\n+/*\n+   Cast - casts a := b\n+*/\n+\n+static void Cast (unsigned char *a, unsigned int _a_high, const unsigned char *b_, unsigned int _b_high);\n+\n+/*\n+   isHex -\n+*/\n+\n+static unsigned int isHex (char ch);\n+\n+/*\n+   toHex -\n+*/\n+\n+static unsigned int toHex (char ch);\n+\n+/*\n+   toOct -\n+*/\n+\n+static unsigned int toOct (char ch);\n+\n+/*\n+   isOct -\n+*/\n+\n+static unsigned int isOct (char ch);\n+\n+/*\n+   FormatString - returns a String containing, s, together with encapsulated\n+                  entity, w. It only formats the first %s or %d or %u with n.\n+                  A new string is returned.\n+*/\n+\n+static DynamicStrings_String FormatString (DynamicStrings_String fmt, int *startpos, DynamicStrings_String in, const unsigned char *w_, unsigned int _w_high);\n+\n+/*\n+   FormatString - returns a String containing, s, together with encapsulated\n+                  entity, w. It only formats the first %s or %d or %u with n.\n+                  A new string is returned.\n+*/\n+\n+static DynamicStrings_String PerformFormatString (DynamicStrings_String fmt, int *startpos, DynamicStrings_String in, const unsigned char *w_, unsigned int _w_high);\n+\n+/*\n+   Copy - copies, fmt[start:end] -> in and returns in.  Providing that start >= 0.\n+*/\n+\n+static DynamicStrings_String Copy (DynamicStrings_String fmt, DynamicStrings_String in, int start, int end);\n+\n+/*\n+   HandlePercent - pre-condition:  s, is a string.\n+                   Post-condition:  a new string is returned which is a copy of,\n+                   s, except %% is transformed into %.\n+*/\n+\n+static DynamicStrings_String HandlePercent (DynamicStrings_String fmt, DynamicStrings_String s, int startpos);\n+\n+\n+/*\n+   doDSdbEnter -\n+*/\n+\n+static void doDSdbEnter (void)\n+{\n+  DynamicStrings_PushAllocation ();\n+}\n+\n+\n+/*\n+   doDSdbExit -\n+*/\n+\n+static void doDSdbExit (DynamicStrings_String s)\n+{\n+  s = DynamicStrings_PopAllocationExemption (TRUE, s);\n+}\n+\n+\n+/*\n+   DSdbEnter -\n+*/\n+\n+static void DSdbEnter (void)\n+{\n+}\n+\n+\n+/*\n+   DSdbExit -\n+*/\n+\n+static void DSdbExit (DynamicStrings_String s)\n+{\n+}\n+\n+\n+/*\n+   IsDigit - returns TRUE if ch lies in the range: 0..9\n+*/\n+\n+static unsigned int IsDigit (char ch)\n+{\n+  return (ch >= '0') && (ch <= '9');\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Cast - casts a := b\n+*/\n+\n+static void Cast (unsigned char *a, unsigned int _a_high, const unsigned char *b_, unsigned int _b_high)\n+{\n+  unsigned int i;\n+  unsigned char b[_b_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (b, b_, _b_high+1);\n+\n+  if (_a_high == _b_high)\n+    {\n+      for (i=0; i<=_a_high; i++)\n+        {\n+          a[i] = b[i];\n+        }\n+    }\n+  else\n+    {\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n+    }\n+}\n+\n+\n+/*\n+   isHex -\n+*/\n+\n+static unsigned int isHex (char ch)\n+{\n+  return (((ch >= '0') && (ch <= '9')) || ((ch >= 'A') && (ch <= 'F'))) || ((ch >= 'a') && (ch <= 'f'));\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   toHex -\n+*/\n+\n+static unsigned int toHex (char ch)\n+{\n+  if ((ch >= '0') && (ch <= '9'))\n+    {\n+      return ((unsigned int) (ch))- ((unsigned int) ('0'));\n+    }\n+  else if ((ch >= 'A') && (ch <= 'F'))\n+    {\n+      /* avoid dangling else.  */\n+      return ( ((unsigned int) (ch))- ((unsigned int) ('A')))+10;\n+    }\n+  else\n+    {\n+      /* avoid dangling else.  */\n+      return ( ((unsigned int) (ch))- ((unsigned int) ('a')))+10;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   toOct -\n+*/\n+\n+static unsigned int toOct (char ch)\n+{\n+  return ((unsigned int) (ch))- ((unsigned int) ('0'));\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   isOct -\n+*/\n+\n+static unsigned int isOct (char ch)\n+{\n+  return (ch >= '0') && (ch <= '8');\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   FormatString - returns a String containing, s, together with encapsulated\n+                  entity, w. It only formats the first %s or %d or %u with n.\n+                  A new string is returned.\n+*/\n+\n+static DynamicStrings_String FormatString (DynamicStrings_String fmt, int *startpos, DynamicStrings_String in, const unsigned char *w_, unsigned int _w_high)\n+{\n+  DynamicStrings_String s;\n+  unsigned char w[_w_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (w, w_, _w_high+1);\n+\n+  DSdbEnter ();\n+  if ((*startpos) >= 0)\n+    {\n+      s = PerformFormatString (fmt, startpos, in, (const unsigned char *) w, _w_high);\n+    }\n+  else\n+    {\n+      s = DynamicStrings_Dup (in);\n+    }\n+  DSdbExit (s);\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   FormatString - returns a String containing, s, together with encapsulated\n+                  entity, w. It only formats the first %s or %d or %u with n.\n+                  A new string is returned.\n+*/\n+\n+static DynamicStrings_String PerformFormatString (DynamicStrings_String fmt, int *startpos, DynamicStrings_String in, const unsigned char *w_, unsigned int _w_high)\n+{\n+  unsigned int left;\n+  unsigned int u;\n+  int c;\n+  int width;\n+  int nextperc;\n+  int afterperc;\n+  int endpos;\n+  char leader;\n+  char ch;\n+  char ch2;\n+  DynamicStrings_String p;\n+  unsigned char w[_w_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (w, w_, _w_high+1);\n+\n+  while ((*startpos) >= 0)\n+    {\n+      nextperc = DynamicStrings_Index (fmt, '%', static_cast<unsigned int> ((*startpos)));\n+      afterperc = nextperc;\n+      if (nextperc >= 0)\n+        {\n+          afterperc += 1;\n+          if ((DynamicStrings_char (fmt, afterperc)) == '-')\n+            {\n+              left = TRUE;\n+              afterperc += 1;\n+            }\n+          else\n+            {\n+              left = FALSE;\n+            }\n+          ch = DynamicStrings_char (fmt, afterperc);\n+          if (ch == '0')\n+            {\n+              leader = '0';\n+            }\n+          else\n+            {\n+              leader = ' ';\n+            }\n+          width = 0;\n+          while (IsDigit (ch))\n+            {\n+              width = (width*10)+((int ) ( ((unsigned int) (ch))- ((unsigned int) ('0'))));\n+              afterperc += 1;\n+              ch = DynamicStrings_char (fmt, afterperc);\n+            }\n+          if ((ch == 'c') || (ch == 's'))\n+            {\n+              afterperc += 1;\n+              if (ch == 'c')\n+                {\n+                  ch2 = static_cast<char> (w[0]);\n+                  p = DynamicStrings_ConCatChar (DynamicStrings_InitString ((const char *) \"\", 0), ch2);\n+                }\n+              else\n+                {\n+                  Cast ((unsigned char *) &p, (sizeof (p)-1), (const unsigned char *) w, _w_high);\n+                  p = DynamicStrings_Dup (p);\n+                }\n+              if ((width > 0) && (((int ) (DynamicStrings_Length (p))) < width))\n+                {\n+                  /* avoid gcc warning by using compound statement even if not strictly necessary.  */\n+                  if (left)\n+                    {\n+                      /* place trailing spaces after, p.  */\n+                      p = DynamicStrings_ConCat (p, DynamicStrings_Mark (DynamicStrings_Mult (DynamicStrings_Mark (DynamicStrings_InitString ((const char *) \" \", 1)), static_cast<unsigned int> (width-((int ) (DynamicStrings_Length (p)))))));\n+                    }\n+                  else\n+                    {\n+                      /* padd string, p, with leading spaces.  */\n+                      p = DynamicStrings_ConCat (DynamicStrings_Mult (DynamicStrings_Mark (DynamicStrings_InitString ((const char *) \" \", 1)), static_cast<unsigned int> (width-((int ) (DynamicStrings_Length (p))))), DynamicStrings_Mark (p));\n+                    }\n+                }\n+              /* include string, p, into, in.  */\n+              if (nextperc > 0)\n+                {\n+                  in = DynamicStrings_ConCat (in, DynamicStrings_Slice (fmt, (*startpos), nextperc));\n+                }\n+              in = DynamicStrings_ConCat (in, p);\n+              (*startpos) = afterperc;\n+              DSdbExit (static_cast<DynamicStrings_String> (NULL));\n+              return in;\n+            }\n+          else if (ch == 'd')\n+            {\n+              /* avoid dangling else.  */\n+              afterperc += 1;\n+              Cast ((unsigned char *) &c, (sizeof (c)-1), (const unsigned char *) w, _w_high);\n+              in = Copy (fmt, in, (*startpos), nextperc);\n+              in = DynamicStrings_ConCat (in, StringConvert_IntegerToString (c, static_cast<unsigned int> (width), leader, FALSE, 10, FALSE));\n+              (*startpos) = afterperc;\n+              DSdbExit (static_cast<DynamicStrings_String> (NULL));\n+              return in;\n+            }\n+          else if (ch == 'x')\n+            {\n+              /* avoid dangling else.  */\n+              afterperc += 1;\n+              Cast ((unsigned char *) &u, (sizeof (u)-1), (const unsigned char *) w, _w_high);\n+              in = DynamicStrings_ConCat (in, DynamicStrings_Slice (fmt, (*startpos), nextperc));\n+              in = DynamicStrings_ConCat (in, StringConvert_CardinalToString (u, static_cast<unsigned int> (width), leader, 16, TRUE));\n+              (*startpos) = afterperc;\n+              DSdbExit (static_cast<DynamicStrings_String> (NULL));\n+              return in;\n+            }\n+          else if (ch == 'u')\n+            {\n+              /* avoid dangling else.  */\n+              afterperc += 1;\n+              Cast ((unsigned char *) &u, (sizeof (u)-1), (const unsigned char *) w, _w_high);\n+              in = DynamicStrings_ConCat (in, DynamicStrings_Slice (fmt, (*startpos), nextperc));\n+              in = DynamicStrings_ConCat (in, StringConvert_CardinalToString (u, static_cast<unsigned int> (width), leader, 10, FALSE));\n+              (*startpos) = afterperc;\n+              DSdbExit (static_cast<DynamicStrings_String> (NULL));\n+              return in;\n+            }\n+          else\n+            {\n+              /* avoid dangling else.  */\n+              afterperc += 1;\n+              /* copy format string.  */\n+              if (nextperc > 0)\n+                {\n+                  in = DynamicStrings_ConCat (in, DynamicStrings_Slice (fmt, (*startpos), nextperc));\n+                }\n+              /* and the character after the %.  */\n+              in = DynamicStrings_ConCat (in, DynamicStrings_Mark (DynamicStrings_InitStringChar (ch)));\n+            }\n+          (*startpos) = afterperc;\n+        }\n+      else\n+        {\n+          /* nothing to do.  */\n+          DSdbExit (static_cast<DynamicStrings_String> (NULL));\n+          return in;\n+        }\n+    }\n+  DSdbExit (static_cast<DynamicStrings_String> (NULL));\n+  return in;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Copy - copies, fmt[start:end] -> in and returns in.  Providing that start >= 0.\n+*/\n+\n+static DynamicStrings_String Copy (DynamicStrings_String fmt, DynamicStrings_String in, int start, int end)\n+{\n+  if (start >= 0)\n+    {\n+      /* avoid gcc warning by using compound statement even if not strictly necessary.  */\n+      if (end > 0)\n+        {\n+          in = DynamicStrings_ConCat (in, DynamicStrings_Mark (DynamicStrings_Slice (fmt, start, end)));\n+        }\n+      else if (end < 0)\n+        {\n+          /* avoid dangling else.  */\n+          in = DynamicStrings_ConCat (in, DynamicStrings_Mark (DynamicStrings_Slice (fmt, start, 0)));\n+        }\n+    }\n+  return in;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   HandlePercent - pre-condition:  s, is a string.\n+                   Post-condition:  a new string is returned which is a copy of,\n+                   s, except %% is transformed into %.\n+*/\n+\n+static DynamicStrings_String HandlePercent (DynamicStrings_String fmt, DynamicStrings_String s, int startpos)\n+{\n+  int prevpos;\n+  DynamicStrings_String result;\n+\n+  if ((startpos == ((int ) (DynamicStrings_Length (fmt)))) || (startpos < 0))\n+    {\n+      return s;\n+    }\n+  else\n+    {\n+      prevpos = startpos;\n+      while ((startpos >= 0) && (prevpos < ((int ) (DynamicStrings_Length (fmt)))))\n+        {\n+          startpos = DynamicStrings_Index (fmt, '%', static_cast<unsigned int> (startpos));\n+          if (startpos >= prevpos)\n+            {\n+              if (startpos > 0)\n+                {\n+                  s = DynamicStrings_ConCat (s, DynamicStrings_Mark (DynamicStrings_Slice (fmt, prevpos, startpos)));\n+                }\n+              startpos += 1;\n+              if ((DynamicStrings_char (fmt, startpos)) == '%')\n+                {\n+                  s = DynamicStrings_ConCatChar (s, '%');\n+                  startpos += 1;\n+                }\n+              prevpos = startpos;\n+            }\n+        }\n+      if (prevpos < ((int ) (DynamicStrings_Length (fmt))))\n+        {\n+          s = DynamicStrings_ConCat (s, DynamicStrings_Mark (DynamicStrings_Slice (fmt, prevpos, 0)));\n+        }\n+      return s;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Sprintf0 - returns a String containing, s, after it has had its\n+              escape sequences translated.\n+*/\n+\n+extern \"C\" DynamicStrings_String FormatStrings_Sprintf0 (DynamicStrings_String fmt)\n+{\n+  DynamicStrings_String s;\n+\n+  DSdbEnter ();\n+  fmt = FormatStrings_HandleEscape (fmt);\n+  s = HandlePercent (fmt, DynamicStrings_InitString ((const char *) \"\", 0), 0);\n+  DSdbExit (s);\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Sprintf1 - returns a String containing, s, together with encapsulated\n+              entity, w. It only formats the first %s or %d with n.\n+*/\n+\n+extern \"C\" DynamicStrings_String FormatStrings_Sprintf1 (DynamicStrings_String fmt, const unsigned char *w_, unsigned int _w_high)\n+{\n+  int i;\n+  DynamicStrings_String s;\n+  unsigned char w[_w_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (w, w_, _w_high+1);\n+\n+  DSdbEnter ();\n+  fmt = FormatStrings_HandleEscape (fmt);\n+  i = 0;\n+  s = FormatString (fmt, &i, DynamicStrings_InitString ((const char *) \"\", 0), (const unsigned char *) w, _w_high);\n+  s = HandlePercent (fmt, s, i);\n+  DSdbExit (s);\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Sprintf2 - returns a string, s, which has been formatted.\n+*/\n+\n+extern \"C\" DynamicStrings_String FormatStrings_Sprintf2 (DynamicStrings_String fmt, const unsigned char *w1_, unsigned int _w1_high, const unsigned char *w2_, unsigned int _w2_high)\n+{\n+  int i;\n+  DynamicStrings_String s;\n+  unsigned char w1[_w1_high+1];\n+  unsigned char w2[_w2_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (w1, w1_, _w1_high+1);\n+  memcpy (w2, w2_, _w2_high+1);\n+\n+  DSdbEnter ();\n+  fmt = FormatStrings_HandleEscape (fmt);\n+  i = 0;\n+  s = FormatString (fmt, &i, DynamicStrings_InitString ((const char *) \"\", 0), (const unsigned char *) w1, _w1_high);\n+  s = FormatString (fmt, &i, s, (const unsigned char *) w2, _w2_high);\n+  s = HandlePercent (fmt, s, i);\n+  DSdbExit (s);\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Sprintf3 - returns a string, s, which has been formatted.\n+*/\n+\n+extern \"C\" DynamicStrings_String FormatStrings_Sprintf3 (DynamicStrings_String fmt, const unsigned char *w1_, unsigned int _w1_high, const unsigned char *w2_, unsigned int _w2_high, const unsigned char *w3_, unsigned int _w3_high)\n+{\n+  int i;\n+  DynamicStrings_String s;\n+  unsigned char w1[_w1_high+1];\n+  unsigned char w2[_w2_high+1];\n+  unsigned char w3[_w3_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (w1, w1_, _w1_high+1);\n+  memcpy (w2, w2_, _w2_high+1);\n+  memcpy (w3, w3_, _w3_high+1);\n+\n+  DSdbEnter ();\n+  fmt = FormatStrings_HandleEscape (fmt);\n+  i = 0;\n+  s = FormatString (fmt, &i, DynamicStrings_InitString ((const char *) \"\", 0), (const unsigned char *) w1, _w1_high);\n+  s = FormatString (fmt, &i, s, (const unsigned char *) w2, _w2_high);\n+  s = FormatString (fmt, &i, s, (const unsigned char *) w3, _w3_high);\n+  s = HandlePercent (fmt, s, i);\n+  DSdbExit (s);\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Sprintf4 - returns a string, s, which has been formatted.\n+*/\n+\n+extern \"C\" DynamicStrings_String FormatStrings_Sprintf4 (DynamicStrings_String fmt, const unsigned char *w1_, unsigned int _w1_high, const unsigned char *w2_, unsigned int _w2_high, const unsigned char *w3_, unsigned int _w3_high, const unsigned char *w4_, unsigned int _w4_high)\n+{\n+  int i;\n+  DynamicStrings_String s;\n+  unsigned char w1[_w1_high+1];\n+  unsigned char w2[_w2_high+1];\n+  unsigned char w3[_w3_high+1];\n+  unsigned char w4[_w4_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (w1, w1_, _w1_high+1);\n+  memcpy (w2, w2_, _w2_high+1);\n+  memcpy (w3, w3_, _w3_high+1);\n+  memcpy (w4, w4_, _w4_high+1);\n+\n+  DSdbEnter ();\n+  fmt = FormatStrings_HandleEscape (fmt);\n+  i = 0;\n+  s = FormatString (fmt, &i, DynamicStrings_InitString ((const char *) \"\", 0), (const unsigned char *) w1, _w1_high);\n+  s = FormatString (fmt, &i, s, (const unsigned char *) w2, _w2_high);\n+  s = FormatString (fmt, &i, s, (const unsigned char *) w3, _w3_high);\n+  s = FormatString (fmt, &i, s, (const unsigned char *) w4, _w4_high);\n+  s = HandlePercent (fmt, s, i);\n+  DSdbExit (s);\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   HandleEscape - translates \\a, \\b, \\e, \\f, \n+, \\r, \\x[hex] \\[octal] into\n+                  their respective ascii codes.  It also converts \\[any] into\n+                  a single [any] character.\n+*/\n+\n+extern \"C\" DynamicStrings_String FormatStrings_HandleEscape (DynamicStrings_String s)\n+{\n+  DynamicStrings_String d;\n+  int i;\n+  int j;\n+  char ch;\n+  unsigned char b;\n+\n+  DSdbEnter ();\n+  d = DynamicStrings_InitString ((const char *) \"\", 0);\n+  i = DynamicStrings_Index (s, '\\\\', 0);\n+  j = 0;\n+  while (i >= 0)\n+    {\n+      if (i > 0)\n+        {\n+          /* initially i might be zero which means the end of the string, which is not what we want.  */\n+          d = DynamicStrings_ConCat (d, DynamicStrings_Slice (s, j, i));\n+        }\n+      ch = DynamicStrings_char (s, i+1);\n+      if (ch == 'a')\n+        {\n+          /* requires a bell.  */\n+          d = DynamicStrings_ConCat (d, DynamicStrings_Mark (DynamicStrings_InitStringChar (ASCII_bel)));\n+        }\n+      else if (ch == 'b')\n+        {\n+          /* avoid dangling else.  */\n+          /* requires a backspace.  */\n+          d = DynamicStrings_ConCat (d, DynamicStrings_Mark (DynamicStrings_InitStringChar (ASCII_bs)));\n+        }\n+      else if (ch == 'e')\n+        {\n+          /* avoid dangling else.  */\n+          /* requires a escape.  */\n+          d = DynamicStrings_ConCat (d, DynamicStrings_Mark (DynamicStrings_InitStringChar (ASCII_esc)));\n+        }\n+      else if (ch == 'f')\n+        {\n+          /* avoid dangling else.  */\n+          /* requires a formfeed.  */\n+          d = DynamicStrings_ConCat (d, DynamicStrings_Mark (DynamicStrings_InitStringChar (ASCII_ff)));\n+        }\n+      else if (ch == 'n')\n+        {\n+          /* avoid dangling else.  */\n+          /* requires a newline.  */\n+          d = DynamicStrings_ConCat (d, DynamicStrings_Mark (DynamicStrings_InitStringChar (ASCII_nl)));\n+        }\n+      else if (ch == 'r')\n+        {\n+          /* avoid dangling else.  */\n+          /* requires a carriage return.  */\n+          d = DynamicStrings_ConCat (d, DynamicStrings_Mark (DynamicStrings_InitStringChar (ASCII_cr)));\n+        }\n+      else if (ch == 't')\n+        {\n+          /* avoid dangling else.  */\n+          /* requires a tab.  */\n+          d = DynamicStrings_ConCat (d, DynamicStrings_Mark (DynamicStrings_InitStringChar (ASCII_tab)));\n+        }\n+      else if (ch == 'x')\n+        {\n+          /* avoid dangling else.  */\n+          i += 1;\n+          if (isHex (DynamicStrings_char (s, i+1)))\n+            {\n+              b = (unsigned char ) (toHex (DynamicStrings_char (s, i+1)));\n+              i += 1;\n+              if (isHex (DynamicStrings_char (s, i+1)))\n+                {\n+                  b = (unsigned char ) ((((unsigned int ) (b))*0x010)+(toHex (DynamicStrings_char (s, i+1))));\n+                  d = DynamicStrings_ConCat (d, DynamicStrings_Mark (DynamicStrings_InitStringChar ((char ) (b))));\n+                }\n+            }\n+        }\n+      else if (isOct (ch))\n+        {\n+          /* avoid dangling else.  */\n+          b = (unsigned char ) (toOct (ch));\n+          i += 1;\n+          if (isOct (DynamicStrings_char (s, i+1)))\n+            {\n+              b = (unsigned char ) ((((unsigned int ) (b))*8)+(toOct (DynamicStrings_char (s, i+1))));\n+              i += 1;\n+              if (isOct (DynamicStrings_char (s, i+1)))\n+                {\n+                  b = (unsigned char ) ((((unsigned int ) (b))*8)+(toOct (DynamicStrings_char (s, i+1))));\n+                }\n+            }\n+          d = DynamicStrings_ConCat (d, DynamicStrings_Mark (DynamicStrings_InitStringChar ((char ) (b))));\n+        }\n+      else\n+        {\n+          /* avoid dangling else.  */\n+          /* copy escaped character.  */\n+          d = DynamicStrings_ConCat (d, DynamicStrings_Mark (DynamicStrings_InitStringChar (ch)));\n+        }\n+      i += 2;\n+      j = i;\n+      i = DynamicStrings_Index (s, '\\\\', (unsigned int ) (i));\n+    }\n+  /* s := Assign(s, Mark(ConCat(d, Mark(Slice(s, j, 0))))) ;    dont Mark(s) in the Slice as we Assign contents  */\n+  s = DynamicStrings_ConCat (d, DynamicStrings_Mark (DynamicStrings_Slice (DynamicStrings_Mark (s), j, 0)));\n+  DSdbExit (s);\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" void _M2_FormatStrings_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}\n+\n+extern \"C\" void _M2_FormatStrings_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "205c27b811e146dd74d061788a942bca71849207", "filename": "gcc/m2/mc-boot/GFpuIO.cc", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGFpuIO.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGFpuIO.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGFpuIO.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,336 @@\n+/* do not edit automatically generated by mc from FpuIO.  */\n+/* FpuIO.mod implements a fixed format input/output for REAL/LONGREAL.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#   if !defined (TRUE)\n+#      define TRUE (1==1)\n+#   endif\n+\n+#   if !defined (FALSE)\n+#      define FALSE (1==0)\n+#   endif\n+\n+#define _FpuIO_H\n+#define _FpuIO_C\n+\n+#   include \"GStrIO.h\"\n+#   include \"GStrLib.h\"\n+#   include \"GASCII.h\"\n+#   include \"GDynamicStrings.h\"\n+#   include \"GStringConvert.h\"\n+\n+#   define MaxLineLength 100\n+extern \"C\" void FpuIO_ReadReal (double *x);\n+\n+/*\n+   WriteReal - converts a REAL number, x, which has a, TotalWidth, and\n+               FractionWidth into, string, a.\n+*/\n+\n+extern \"C\" void FpuIO_WriteReal (double x, unsigned int TotalWidth, unsigned int FractionWidth);\n+\n+/*\n+   WriteReal - converts a REAL number, x, which has a, TotalWidth, and\n+               FractionWidth into, string, a.\n+*/\n+\n+extern \"C\" void FpuIO_StrToReal (const char *a_, unsigned int _a_high, double *x);\n+\n+/*\n+   RealToStr - converts a LONGREAL number, Real, which has, TotalWidth, and\n+               FractionWidth into a string.\n+*/\n+\n+extern \"C\" void FpuIO_RealToStr (double x, unsigned int TotalWidth, unsigned int FractionWidth, char *a, unsigned int _a_high);\n+extern \"C\" void FpuIO_ReadLongReal (long double *x);\n+\n+/*\n+   WriteLongReal - converts a LONGREAL number, x, which has a, TotalWidth, and\n+                   FractionWidth into a string.\n+*/\n+\n+extern \"C\" void FpuIO_WriteLongReal (long double x, unsigned int TotalWidth, unsigned int FractionWidth);\n+\n+/*\n+   WriteLongReal - converts a LONGREAL number, x, which has a, TotalWidth, and\n+                   FractionWidth into a string.\n+*/\n+\n+extern \"C\" void FpuIO_StrToLongReal (const char *a_, unsigned int _a_high, long double *x);\n+\n+/*\n+   LongRealToStr - converts a LONGREAL number, Real, which has, TotalWidth, and\n+                   FractionWidth into a string.\n+*/\n+\n+extern \"C\" void FpuIO_LongRealToStr (long double x, unsigned int TotalWidth, unsigned int FractionWidth, char *a, unsigned int _a_high);\n+\n+/*\n+   LongRealToStr - converts a LONGREAL number, Real, which has, TotalWidth, and\n+                   FractionWidth into a string.\n+*/\n+\n+extern \"C\" void FpuIO_ReadLongInt (long int *x);\n+\n+/*\n+   LongRealToStr - converts a LONGREAL number, Real, which has, TotalWidth, and\n+                   FractionWidth into a string.\n+*/\n+\n+extern \"C\" void FpuIO_WriteLongInt (long int x, unsigned int n);\n+\n+/*\n+   LongRealToStr - converts a LONGREAL number, Real, which has, TotalWidth, and\n+                   FractionWidth into a string.\n+*/\n+\n+extern \"C\" void FpuIO_StrToLongInt (const char *a_, unsigned int _a_high, long int *x);\n+\n+/*\n+   LongRealToStr - converts a LONGREAL number, Real, which has, TotalWidth, and\n+                   FractionWidth into a string.\n+*/\n+\n+extern \"C\" void FpuIO_LongIntToStr (long int x, unsigned int n, char *a, unsigned int _a_high);\n+\n+extern \"C\" void FpuIO_ReadReal (double *x)\n+{\n+  typedef struct ReadReal__T1_a ReadReal__T1;\n+\n+  struct ReadReal__T1_a { char array[MaxLineLength+1]; };\n+  ReadReal__T1 a;\n+\n+  /* \n+#undef GM2_DEBUG_FPUIO\n+if defined(GM2_DEBUG_FPUIO)\n+#  define InitString(X) InitStringDB(X, __FILE__, __LINE__)\n+#  define InitStringCharStar(X) InitStringCharStarDB(X, __FILE__, __LINE__)\n+#  define InitStringChar(X) InitStringCharDB(X, __FILE__, __LINE__)\n+#  define Mult(X,Y) MultDB(X, Y, __FILE__, __LINE__)\n+#  define Dup(X) DupDB(X, __FILE__, __LINE__)\n+#  define Slice(X,Y,Z) SliceDB(X, Y, Z, __FILE__, __LINE__)\n+#endif\n+  */\n+  StrIO_ReadString ((char *) &a.array[0], MaxLineLength);\n+  FpuIO_StrToReal ((const char *) &a.array[0], MaxLineLength, x);\n+}\n+\n+\n+/*\n+   WriteReal - converts a REAL number, x, which has a, TotalWidth, and\n+               FractionWidth into, string, a.\n+*/\n+\n+extern \"C\" void FpuIO_WriteReal (double x, unsigned int TotalWidth, unsigned int FractionWidth)\n+{\n+  typedef struct WriteReal__T2_a WriteReal__T2;\n+\n+  struct WriteReal__T2_a { char array[MaxLineLength+1]; };\n+  WriteReal__T2 a;\n+\n+  FpuIO_RealToStr (x, TotalWidth, FractionWidth, (char *) &a.array[0], MaxLineLength);\n+  StrIO_WriteString ((const char *) &a.array[0], MaxLineLength);\n+}\n+\n+\n+/*\n+   WriteReal - converts a REAL number, x, which has a, TotalWidth, and\n+               FractionWidth into, string, a.\n+*/\n+\n+extern \"C\" void FpuIO_StrToReal (const char *a_, unsigned int _a_high, double *x)\n+{\n+  long double lr;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  FpuIO_StrToLongReal ((const char *) a, _a_high, &lr);  /* let StrToLongReal do the work and we convert the result back to REAL  */\n+  (*x) = (double ) (lr);  /* let StrToLongReal do the work and we convert the result back to REAL  */\n+}\n+\n+\n+/*\n+   RealToStr - converts a LONGREAL number, Real, which has, TotalWidth, and\n+               FractionWidth into a string.\n+*/\n+\n+extern \"C\" void FpuIO_RealToStr (double x, unsigned int TotalWidth, unsigned int FractionWidth, char *a, unsigned int _a_high)\n+{\n+  long double lr;\n+\n+  lr = (long double ) (x);\n+  FpuIO_LongRealToStr (lr, TotalWidth, FractionWidth, (char *) a, _a_high);\n+}\n+\n+extern \"C\" void FpuIO_ReadLongReal (long double *x)\n+{\n+  typedef struct ReadLongReal__T3_a ReadLongReal__T3;\n+\n+  struct ReadLongReal__T3_a { char array[MaxLineLength+1]; };\n+  ReadLongReal__T3 a;\n+\n+  StrIO_ReadString ((char *) &a.array[0], MaxLineLength);\n+  FpuIO_StrToLongReal ((const char *) &a.array[0], MaxLineLength, x);\n+}\n+\n+\n+/*\n+   WriteLongReal - converts a LONGREAL number, x, which has a, TotalWidth, and\n+                   FractionWidth into a string.\n+*/\n+\n+extern \"C\" void FpuIO_WriteLongReal (long double x, unsigned int TotalWidth, unsigned int FractionWidth)\n+{\n+  typedef struct WriteLongReal__T4_a WriteLongReal__T4;\n+\n+  struct WriteLongReal__T4_a { char array[MaxLineLength+1]; };\n+  WriteLongReal__T4 a;\n+\n+  FpuIO_LongRealToStr (x, TotalWidth, FractionWidth, (char *) &a.array[0], MaxLineLength);\n+  StrIO_WriteString ((const char *) &a.array[0], MaxLineLength);\n+}\n+\n+\n+/*\n+   WriteLongReal - converts a LONGREAL number, x, which has a, TotalWidth, and\n+                   FractionWidth into a string.\n+*/\n+\n+extern \"C\" void FpuIO_StrToLongReal (const char *a_, unsigned int _a_high, long double *x)\n+{\n+  unsigned int found;\n+  DynamicStrings_String s;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  s = DynamicStrings_InitString ((const char *) a, _a_high);\n+  (*x) = StringConvert_StringToLongreal (s, &found);\n+  s = DynamicStrings_KillString (s);\n+}\n+\n+\n+/*\n+   LongRealToStr - converts a LONGREAL number, Real, which has, TotalWidth, and\n+                   FractionWidth into a string.\n+*/\n+\n+extern \"C\" void FpuIO_LongRealToStr (long double x, unsigned int TotalWidth, unsigned int FractionWidth, char *a, unsigned int _a_high)\n+{\n+  DynamicStrings_String s;\n+\n+  s = StringConvert_LongrealToString (x, TotalWidth, FractionWidth);\n+  DynamicStrings_CopyOut ((char *) a, _a_high, s);\n+  s = DynamicStrings_KillString (s);\n+}\n+\n+\n+/*\n+   LongRealToStr - converts a LONGREAL number, Real, which has, TotalWidth, and\n+                   FractionWidth into a string.\n+*/\n+\n+extern \"C\" void FpuIO_ReadLongInt (long int *x)\n+{\n+  typedef struct ReadLongInt__T5_a ReadLongInt__T5;\n+\n+  struct ReadLongInt__T5_a { char array[MaxLineLength+1]; };\n+  ReadLongInt__T5 a;\n+\n+  StrIO_ReadString ((char *) &a.array[0], MaxLineLength);\n+  FpuIO_StrToLongInt ((const char *) &a.array[0], MaxLineLength, x);\n+}\n+\n+\n+/*\n+   LongRealToStr - converts a LONGREAL number, Real, which has, TotalWidth, and\n+                   FractionWidth into a string.\n+*/\n+\n+extern \"C\" void FpuIO_WriteLongInt (long int x, unsigned int n)\n+{\n+  typedef struct WriteLongInt__T6_a WriteLongInt__T6;\n+\n+  struct WriteLongInt__T6_a { char array[MaxLineLength+1]; };\n+  WriteLongInt__T6 a;\n+\n+  FpuIO_LongIntToStr (x, n, (char *) &a.array[0], MaxLineLength);\n+  StrIO_WriteString ((const char *) &a.array[0], MaxLineLength);\n+}\n+\n+\n+/*\n+   LongRealToStr - converts a LONGREAL number, Real, which has, TotalWidth, and\n+                   FractionWidth into a string.\n+*/\n+\n+extern \"C\" void FpuIO_StrToLongInt (const char *a_, unsigned int _a_high, long int *x)\n+{\n+  DynamicStrings_String s;\n+  unsigned int found;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  s = DynamicStrings_InitString ((const char *) a, _a_high);\n+  (*x) = StringConvert_StringToLongInteger (s, 10, &found);\n+  s = DynamicStrings_KillString (s);\n+}\n+\n+\n+/*\n+   LongRealToStr - converts a LONGREAL number, Real, which has, TotalWidth, and\n+                   FractionWidth into a string.\n+*/\n+\n+extern \"C\" void FpuIO_LongIntToStr (long int x, unsigned int n, char *a, unsigned int _a_high)\n+{\n+  DynamicStrings_String s;\n+\n+  s = StringConvert_LongIntegerToString (x, n, ' ', FALSE, 10, TRUE);\n+  DynamicStrings_CopyOut ((char *) a, _a_high, s);\n+  s = DynamicStrings_KillString (s);\n+}\n+\n+extern \"C\" void _M2_FpuIO_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}\n+\n+extern \"C\" void _M2_FpuIO_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "e56c74382f535ae09885161c77f412eb26483cef", "filename": "gcc/m2/mc-boot/GIO.cc", "status": "added", "additions": 479, "deletions": 0, "changes": 479, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGIO.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGIO.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGIO.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,479 @@\n+/* do not edit automatically generated by mc from IO.  */\n+/* IO.mod provides Read, Write, Errors procedures mapping onto 0, 1 and 2.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#   if !defined (TRUE)\n+#      define TRUE (1==1)\n+#   endif\n+\n+#   if !defined (FALSE)\n+#      define FALSE (1==0)\n+#   endif\n+\n+#define _IO_H\n+#define _IO_C\n+\n+#   include \"GStrLib.h\"\n+#   include \"GSYSTEM.h\"\n+#   include \"Glibc.h\"\n+#   include \"GFIO.h\"\n+#   include \"Gerrno.h\"\n+#   include \"GASCII.h\"\n+#   include \"Gtermios.h\"\n+\n+#   define MaxDefaultFd 2\n+typedef struct IO_BasicFds_r IO_BasicFds;\n+\n+typedef struct IO__T1_a IO__T1;\n+\n+struct IO_BasicFds_r {\n+                       unsigned int IsEof;\n+                       unsigned int IsRaw;\n+                     };\n+\n+struct IO__T1_a { IO_BasicFds array[MaxDefaultFd+1]; };\n+static IO__T1 fdState;\n+\n+/*\n+   IsDefaultFd - returns TRUE if, fd, is 0, 1 or 2.\n+*/\n+\n+extern \"C\" void IO_Read (char *ch);\n+\n+/*\n+   doWrite - performs the write of a single character, ch,\n+             onto fd or f.\n+*/\n+\n+extern \"C\" void IO_Write (char ch);\n+\n+/*\n+   doWrite - performs the write of a single character, ch,\n+             onto fd or f.\n+*/\n+\n+extern \"C\" void IO_Error (char ch);\n+extern \"C\" void IO_UnBufferedMode (int fd, unsigned int input);\n+extern \"C\" void IO_BufferedMode (int fd, unsigned int input);\n+\n+/*\n+   EchoOn - turns on echoing for file descriptor, fd.  This\n+            only really makes sence for a file descriptor opened\n+            for terminal input or maybe some specific file descriptor\n+            which is attached to a particular piece of hardware.\n+*/\n+\n+extern \"C\" void IO_EchoOn (int fd, unsigned int input);\n+\n+/*\n+   EchoOff - turns off echoing for file descriptor, fd.  This\n+             only really makes sence for a file descriptor opened\n+             for terminal input or maybe some specific file descriptor\n+             which is attached to a particular piece of hardware.\n+*/\n+\n+extern \"C\" void IO_EchoOff (int fd, unsigned int input);\n+\n+/*\n+   IsDefaultFd - returns TRUE if, fd, is 0, 1 or 2.\n+*/\n+\n+static unsigned int IsDefaultFd (int fd);\n+\n+/*\n+   doWrite - performs the write of a single character, ch,\n+             onto fd or f.\n+*/\n+\n+static void doWrite (int fd, FIO_File f, char ch);\n+\n+/*\n+   setFlag - sets or unsets the appropriate flag in, t.\n+*/\n+\n+static void setFlag (termios_TERMIOS t, termios_Flag f, unsigned int b);\n+\n+/*\n+   doraw - sets all the flags associated with making this\n+           file descriptor into raw input/output.\n+*/\n+\n+static void doraw (termios_TERMIOS term);\n+\n+/*\n+   dononraw - sets all the flags associated with making this\n+              file descriptor into non raw input/output.\n+*/\n+\n+static void dononraw (termios_TERMIOS term);\n+\n+/*\n+   Init -\n+*/\n+\n+static void Init (void);\n+\n+\n+/*\n+   IsDefaultFd - returns TRUE if, fd, is 0, 1 or 2.\n+*/\n+\n+static unsigned int IsDefaultFd (int fd)\n+{\n+  return (fd <= MaxDefaultFd) && (fd >= 0);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   doWrite - performs the write of a single character, ch,\n+             onto fd or f.\n+*/\n+\n+static void doWrite (int fd, FIO_File f, char ch)\n+{\n+  int r;\n+\n+  if (fdState.array[fd].IsRaw)\n+    {\n+      /* avoid dangling else.  */\n+      if (! fdState.array[fd].IsEof)\n+        {\n+          for (;;)\n+          {\n+            r = static_cast<int> (libc_write (FIO_GetUnixFileDescriptor (f), &ch, static_cast<size_t> (1)));\n+            if (r == 1)\n+              {\n+                return ;\n+              }\n+            else if (r == -1)\n+              {\n+                /* avoid dangling else.  */\n+                r = errno_geterrno ();\n+                if ((r != errno_EAGAIN) && (r != errno_EINTR))\n+                  {\n+                    fdState.array[fd].IsEof = TRUE;\n+                    return ;\n+                  }\n+              }\n+          }\n+        }\n+    }\n+  else\n+    {\n+      FIO_WriteChar (f, ch);\n+    }\n+}\n+\n+\n+/*\n+   setFlag - sets or unsets the appropriate flag in, t.\n+*/\n+\n+static void setFlag (termios_TERMIOS t, termios_Flag f, unsigned int b)\n+{\n+  if (termios_SetFlag (t, f, b))\n+    {}  /* empty.  */\n+}\n+\n+\n+/*\n+   doraw - sets all the flags associated with making this\n+           file descriptor into raw input/output.\n+*/\n+\n+static void doraw (termios_TERMIOS term)\n+{\n+  /* \n+    * from man 3 termios\n+    *           termios_p->c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP\n+    *                                   | INLCR | IGNCR | ICRNL | IXON);\n+    *           termios_p->c_oflag &= ~OPOST;\n+    *           termios_p->c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);\n+    *           termios_p->c_cflag &= ~(CSIZE | PARENB);\n+    *           termios_p->c_cflag |= CS8;\n+  */\n+  setFlag (term, termios_ignbrk, FALSE);\n+  setFlag (term, termios_ibrkint, FALSE);\n+  setFlag (term, termios_iparmrk, FALSE);\n+  setFlag (term, termios_istrip, FALSE);\n+  setFlag (term, termios_inlcr, FALSE);\n+  setFlag (term, termios_igncr, FALSE);\n+  setFlag (term, termios_icrnl, FALSE);\n+  setFlag (term, termios_ixon, FALSE);\n+  setFlag (term, termios_opost, FALSE);\n+  setFlag (term, termios_lecho, FALSE);\n+  setFlag (term, termios_lechonl, FALSE);\n+  setFlag (term, termios_licanon, FALSE);\n+  setFlag (term, termios_lisig, FALSE);\n+  setFlag (term, termios_liexten, FALSE);\n+  setFlag (term, termios_parenb, FALSE);\n+  setFlag (term, termios_cs8, TRUE);\n+}\n+\n+\n+/*\n+   dononraw - sets all the flags associated with making this\n+              file descriptor into non raw input/output.\n+*/\n+\n+static void dononraw (termios_TERMIOS term)\n+{\n+  /* \n+    * we undo these settings, (although we leave the character size alone)\n+    *\n+    * from man 3 termios\n+    *           termios_p->c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP\n+    *                                   | INLCR | IGNCR | ICRNL | IXON);\n+    *           termios_p->c_oflag &= ~OPOST;\n+    *           termios_p->c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);\n+    *           termios_p->c_cflag &= ~(CSIZE | PARENB);\n+    *           termios_p->c_cflag |= CS8;\n+  */\n+  setFlag (term, termios_ignbrk, TRUE);\n+  setFlag (term, termios_ibrkint, TRUE);\n+  setFlag (term, termios_iparmrk, TRUE);\n+  setFlag (term, termios_istrip, TRUE);\n+  setFlag (term, termios_inlcr, TRUE);\n+  setFlag (term, termios_igncr, TRUE);\n+  setFlag (term, termios_icrnl, TRUE);\n+  setFlag (term, termios_ixon, TRUE);\n+  setFlag (term, termios_opost, TRUE);\n+  setFlag (term, termios_lecho, TRUE);\n+  setFlag (term, termios_lechonl, TRUE);\n+  setFlag (term, termios_licanon, TRUE);\n+  setFlag (term, termios_lisig, TRUE);\n+  setFlag (term, termios_liexten, TRUE);\n+}\n+\n+\n+/*\n+   Init -\n+*/\n+\n+static void Init (void)\n+{\n+  fdState.array[0].IsEof = FALSE;\n+  fdState.array[0].IsRaw = FALSE;\n+  fdState.array[1].IsEof = FALSE;\n+  fdState.array[1].IsRaw = FALSE;\n+  fdState.array[2].IsEof = FALSE;\n+  fdState.array[2].IsRaw = FALSE;\n+}\n+\n+\n+/*\n+   IsDefaultFd - returns TRUE if, fd, is 0, 1 or 2.\n+*/\n+\n+extern \"C\" void IO_Read (char *ch)\n+{\n+  int r;\n+\n+  FIO_FlushBuffer (FIO_StdOut);\n+  FIO_FlushBuffer (FIO_StdErr);\n+  if (fdState.array[0].IsRaw)\n+    {\n+      if (fdState.array[0].IsEof)\n+        {\n+          (*ch) = ASCII_eof;\n+        }\n+      else\n+        {\n+          for (;;)\n+          {\n+            r = static_cast<int> (libc_read (FIO_GetUnixFileDescriptor (FIO_StdIn), ch, static_cast<size_t> (1)));\n+            if (r == 1)\n+              {\n+                return ;\n+              }\n+            else if (r == -1)\n+              {\n+                /* avoid dangling else.  */\n+                r = errno_geterrno ();\n+                if (r != errno_EAGAIN)\n+                  {\n+                    fdState.array[0].IsEof = TRUE;\n+                    (*ch) = ASCII_eof;\n+                    return ;\n+                  }\n+              }\n+          }\n+        }\n+    }\n+  else\n+    {\n+      (*ch) = FIO_ReadChar (FIO_StdIn);\n+    }\n+}\n+\n+\n+/*\n+   doWrite - performs the write of a single character, ch,\n+             onto fd or f.\n+*/\n+\n+extern \"C\" void IO_Write (char ch)\n+{\n+  doWrite (1, FIO_StdOut, ch);\n+}\n+\n+\n+/*\n+   doWrite - performs the write of a single character, ch,\n+             onto fd or f.\n+*/\n+\n+extern \"C\" void IO_Error (char ch)\n+{\n+  doWrite (2, FIO_StdErr, ch);\n+}\n+\n+extern \"C\" void IO_UnBufferedMode (int fd, unsigned int input)\n+{\n+  termios_TERMIOS term;\n+  int result;\n+\n+  if (IsDefaultFd (fd))\n+    {\n+      fdState.array[fd].IsRaw = TRUE;\n+    }\n+  term = termios_InitTermios ();\n+  if ((termios_tcgetattr (fd, term)) == 0)\n+    {\n+      doraw (term);\n+      if (input)\n+        {\n+          result = termios_tcsetattr (fd, termios_tcsflush (), term);\n+        }\n+      else\n+        {\n+          result = termios_tcsetattr (fd, termios_tcsdrain (), term);\n+        }\n+    }\n+  term = termios_KillTermios (term);\n+}\n+\n+extern \"C\" void IO_BufferedMode (int fd, unsigned int input)\n+{\n+  termios_TERMIOS term;\n+  int r;\n+\n+  if (IsDefaultFd (fd))\n+    {\n+      fdState.array[fd].IsRaw = FALSE;\n+    }\n+  term = termios_InitTermios ();\n+  if ((termios_tcgetattr (fd, term)) == 0)\n+    {\n+      dononraw (term);\n+      if (input)\n+        {\n+          r = termios_tcsetattr (fd, termios_tcsflush (), term);\n+        }\n+      else\n+        {\n+          r = termios_tcsetattr (fd, termios_tcsdrain (), term);\n+        }\n+    }\n+  term = termios_KillTermios (term);\n+}\n+\n+\n+/*\n+   EchoOn - turns on echoing for file descriptor, fd.  This\n+            only really makes sence for a file descriptor opened\n+            for terminal input or maybe some specific file descriptor\n+            which is attached to a particular piece of hardware.\n+*/\n+\n+extern \"C\" void IO_EchoOn (int fd, unsigned int input)\n+{\n+  termios_TERMIOS term;\n+  int result;\n+\n+  term = termios_InitTermios ();\n+  if ((termios_tcgetattr (fd, term)) == 0)\n+    {\n+      setFlag (term, termios_lecho, TRUE);\n+      if (input)\n+        {\n+          result = termios_tcsetattr (fd, termios_tcsflush (), term);\n+        }\n+      else\n+        {\n+          result = termios_tcsetattr (fd, termios_tcsdrain (), term);\n+        }\n+    }\n+  term = termios_KillTermios (term);\n+}\n+\n+\n+/*\n+   EchoOff - turns off echoing for file descriptor, fd.  This\n+             only really makes sence for a file descriptor opened\n+             for terminal input or maybe some specific file descriptor\n+             which is attached to a particular piece of hardware.\n+*/\n+\n+extern \"C\" void IO_EchoOff (int fd, unsigned int input)\n+{\n+  termios_TERMIOS term;\n+  int result;\n+\n+  term = termios_InitTermios ();\n+  if ((termios_tcgetattr (fd, term)) == 0)\n+    {\n+      setFlag (term, termios_lecho, FALSE);\n+      if (input)\n+        {\n+          result = termios_tcsetattr (fd, termios_tcsflush (), term);\n+        }\n+      else\n+        {\n+          result = termios_tcsetattr (fd, termios_tcsdrain (), term);\n+        }\n+    }\n+  term = termios_KillTermios (term);\n+}\n+\n+extern \"C\" void _M2_IO_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+  Init ();\n+}\n+\n+extern \"C\" void _M2_IO_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "0817ff36ca258e57ffb27a8edf5e2dcf04628fcc", "filename": "gcc/m2/mc-boot/GIndexing.cc", "status": "added", "additions": 491, "deletions": 0, "changes": 491, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGIndexing.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGIndexing.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGIndexing.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,491 @@\n+/* do not edit automatically generated by mc from Indexing.  */\n+/* Indexing provides a dynamic array of pointers.\n+   Copyright (C) 2015-2023 Free Software Foundation, Inc.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License along\n+with gm2; see the file COPYING.  If not, write to the Free Software\n+Foundation, 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#   if !defined (TRUE)\n+#      define TRUE (1==1)\n+#   endif\n+\n+#   if !defined (FALSE)\n+#      define FALSE (1==0)\n+#   endif\n+\n+#   include \"GStorage.h\"\n+#   include \"Gmcrts.h\"\n+#if defined(__cplusplus)\n+#   undef NULL\n+#   define NULL 0\n+#endif\n+#define _Indexing_H\n+#define _Indexing_C\n+\n+#   include \"Glibc.h\"\n+#   include \"GStorage.h\"\n+#   include \"GSYSTEM.h\"\n+#   include \"GmcDebug.h\"\n+#   include \"GM2RTS.h\"\n+\n+typedef struct Indexing_IndexProcedure_p Indexing_IndexProcedure;\n+\n+#   define MinSize 128\n+typedef struct Indexing__T2_r Indexing__T2;\n+\n+typedef void * *Indexing_PtrToAddress;\n+\n+typedef Indexing__T2 *Indexing_Index;\n+\n+typedef unsigned char *Indexing_PtrToByte;\n+\n+typedef void (*Indexing_IndexProcedure_t) (void *);\n+struct Indexing_IndexProcedure_p { Indexing_IndexProcedure_t proc; };\n+\n+struct Indexing__T2_r {\n+                        void *ArrayStart;\n+                        unsigned int ArraySize;\n+                        unsigned int Used;\n+                        unsigned int Low;\n+                        unsigned int High;\n+                        unsigned int Debug;\n+                        unsigned int Map;\n+                      };\n+\n+\n+/*\n+   InitIndex - creates and returns an Index.\n+*/\n+\n+extern \"C\" Indexing_Index Indexing_InitIndex (unsigned int low);\n+\n+/*\n+   KillIndex - returns Index to free storage.\n+*/\n+\n+extern \"C\" Indexing_Index Indexing_KillIndex (Indexing_Index i);\n+\n+/*\n+   DebugIndex - turns on debugging within an index.\n+*/\n+\n+extern \"C\" Indexing_Index Indexing_DebugIndex (Indexing_Index i);\n+\n+/*\n+   InBounds - returns TRUE if indice, n, is within the bounds\n+              of the dynamic array.\n+*/\n+\n+extern \"C\" unsigned int Indexing_InBounds (Indexing_Index i, unsigned int n);\n+\n+/*\n+   HighIndice - returns the last legally accessible indice of this array.\n+*/\n+\n+extern \"C\" unsigned int Indexing_HighIndice (Indexing_Index i);\n+\n+/*\n+   LowIndice - returns the first legally accessible indice of this array.\n+*/\n+\n+extern \"C\" unsigned int Indexing_LowIndice (Indexing_Index i);\n+\n+/*\n+   PutIndice - places, a, into the dynamic array at position i[n]\n+*/\n+\n+extern \"C\" void Indexing_PutIndice (Indexing_Index i, unsigned int n, void * a);\n+\n+/*\n+   GetIndice - retrieves, element i[n] from the dynamic array.\n+*/\n+\n+extern \"C\" void * Indexing_GetIndice (Indexing_Index i, unsigned int n);\n+\n+/*\n+   IsIndiceInIndex - returns TRUE if, a, is in the index, i.\n+*/\n+\n+extern \"C\" unsigned int Indexing_IsIndiceInIndex (Indexing_Index i, void * a);\n+\n+/*\n+   RemoveIndiceFromIndex - removes, a, from Index, i.\n+*/\n+\n+extern \"C\" void Indexing_RemoveIndiceFromIndex (Indexing_Index i, void * a);\n+\n+/*\n+   DeleteIndice - delete i[j] from the array.\n+*/\n+\n+extern \"C\" void Indexing_DeleteIndice (Indexing_Index i, unsigned int j);\n+\n+/*\n+   IncludeIndiceIntoIndex - if the indice is not in the index, then\n+                            add it at the end.\n+*/\n+\n+extern \"C\" void Indexing_IncludeIndiceIntoIndex (Indexing_Index i, void * a);\n+\n+/*\n+   ForeachIndiceInIndexDo - for each j indice of i, call procedure p(i[j])\n+*/\n+\n+extern \"C\" void Indexing_ForeachIndiceInIndexDo (Indexing_Index i, Indexing_IndexProcedure p);\n+\n+\n+/*\n+   InitIndex - creates and returns an Index.\n+*/\n+\n+extern \"C\" Indexing_Index Indexing_InitIndex (unsigned int low)\n+{\n+  Indexing_Index i;\n+\n+  Storage_ALLOCATE ((void **) &i, sizeof (Indexing__T2));\n+  i->Low = low;\n+  i->High = 0;\n+  i->ArraySize = MinSize;\n+  Storage_ALLOCATE (&i->ArrayStart, MinSize);\n+  i->ArrayStart = libc_memset (i->ArrayStart, 0, static_cast<size_t> (i->ArraySize));\n+  i->Debug = FALSE;\n+  i->Used = 0;\n+  i->Map = (unsigned int) 0;\n+  return i;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   KillIndex - returns Index to free storage.\n+*/\n+\n+extern \"C\" Indexing_Index Indexing_KillIndex (Indexing_Index i)\n+{\n+  Storage_DEALLOCATE (&i->ArrayStart, i->ArraySize);\n+  Storage_DEALLOCATE ((void **) &i, sizeof (Indexing__T2));\n+  return NULL;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   DebugIndex - turns on debugging within an index.\n+*/\n+\n+extern \"C\" Indexing_Index Indexing_DebugIndex (Indexing_Index i)\n+{\n+  i->Debug = TRUE;\n+  return i;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   InBounds - returns TRUE if indice, n, is within the bounds\n+              of the dynamic array.\n+*/\n+\n+extern \"C\" unsigned int Indexing_InBounds (Indexing_Index i, unsigned int n)\n+{\n+  if (i == NULL)\n+    {\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n+    }\n+  else\n+    {\n+      return (n >= i->Low) && (n <= i->High);\n+    }\n+  ReturnException (\"../../gcc-read-write/gcc/m2/mc/Indexing.def\", 20, 1);\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   HighIndice - returns the last legally accessible indice of this array.\n+*/\n+\n+extern \"C\" unsigned int Indexing_HighIndice (Indexing_Index i)\n+{\n+  if (i == NULL)\n+    {\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n+    }\n+  else\n+    {\n+      return i->High;\n+    }\n+  ReturnException (\"../../gcc-read-write/gcc/m2/mc/Indexing.def\", 20, 1);\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   LowIndice - returns the first legally accessible indice of this array.\n+*/\n+\n+extern \"C\" unsigned int Indexing_LowIndice (Indexing_Index i)\n+{\n+  if (i == NULL)\n+    {\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n+    }\n+  else\n+    {\n+      return i->Low;\n+    }\n+  ReturnException (\"../../gcc-read-write/gcc/m2/mc/Indexing.def\", 20, 1);\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   PutIndice - places, a, into the dynamic array at position i[n]\n+*/\n+\n+extern \"C\" void Indexing_PutIndice (Indexing_Index i, unsigned int n, void * a)\n+{\n+  typedef unsigned int * *PutIndice__T1;\n+\n+  unsigned int oldSize;\n+  void * b;\n+  PutIndice__T1 p;\n+\n+  if (! (Indexing_InBounds (i, n)))\n+    {\n+      /* avoid gcc warning by using compound statement even if not strictly necessary.  */\n+      if (n < i->Low)\n+        {\n+          M2RTS_HALT (-1);\n+          __builtin_unreachable ();\n+        }\n+      else\n+        {\n+          oldSize = i->ArraySize;\n+          while (((n-i->Low)*sizeof (void *)) >= i->ArraySize)\n+            {\n+              i->ArraySize = i->ArraySize*2;\n+            }\n+          if (oldSize != i->ArraySize)\n+            {\n+              /* \n+               IF Debug\n+               THEN\n+                  printf2('increasing memory hunk from %d to %d\n+              ',\n+                          oldSize, ArraySize)\n+               END ;\n+  */\n+              Storage_REALLOCATE (&i->ArrayStart, i->ArraySize);\n+              /* and initialize the remainder of the array to NIL  */\n+              b = i->ArrayStart;\n+              b = reinterpret_cast<void *> (reinterpret_cast<char *> (b)+oldSize);\n+              b = libc_memset (b, 0, static_cast<size_t> (i->ArraySize-oldSize));\n+            }\n+          i->High = n;\n+        }\n+    }\n+  b = i->ArrayStart;\n+  b = reinterpret_cast<void *> (reinterpret_cast<char *> (b)+(n-i->Low)*sizeof (void *));\n+  p = static_cast<PutIndice__T1> (b);\n+  (*p) = reinterpret_cast<unsigned int *> (a);\n+  i->Used += 1;\n+  if (i->Debug)\n+    {\n+      if (n < 32)\n+        {\n+          i->Map |= (1 << (n ));\n+        }\n+    }\n+}\n+\n+\n+/*\n+   GetIndice - retrieves, element i[n] from the dynamic array.\n+*/\n+\n+extern \"C\" void * Indexing_GetIndice (Indexing_Index i, unsigned int n)\n+{\n+  Indexing_PtrToByte b;\n+  Indexing_PtrToAddress p;\n+\n+  if (! (Indexing_InBounds (i, n)))\n+    {\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n+    }\n+  b = static_cast<Indexing_PtrToByte> (i->ArrayStart);\n+  b += (n-i->Low)*sizeof (void *);\n+  p = (Indexing_PtrToAddress) (b);\n+  if (i->Debug)\n+    {\n+      if (((n < 32) && (! ((((1 << (n)) & (i->Map)) != 0)))) && ((*p) != NULL))\n+        {\n+          M2RTS_HALT (-1);\n+          __builtin_unreachable ();\n+        }\n+    }\n+  return (*p);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   IsIndiceInIndex - returns TRUE if, a, is in the index, i.\n+*/\n+\n+extern \"C\" unsigned int Indexing_IsIndiceInIndex (Indexing_Index i, void * a)\n+{\n+  unsigned int j;\n+  Indexing_PtrToByte b;\n+  Indexing_PtrToAddress p;\n+\n+  j = i->Low;\n+  b = static_cast<Indexing_PtrToByte> (i->ArrayStart);\n+  while (j <= i->High)\n+    {\n+      p = (Indexing_PtrToAddress) (b);\n+      if ((*p) == a)\n+        {\n+          return TRUE;\n+        }\n+      /* we must not INC(p, ..) as p2c gets confused  */\n+      b += sizeof (void *);\n+      j += 1;\n+    }\n+  return FALSE;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   RemoveIndiceFromIndex - removes, a, from Index, i.\n+*/\n+\n+extern \"C\" void Indexing_RemoveIndiceFromIndex (Indexing_Index i, void * a)\n+{\n+  unsigned int j;\n+  unsigned int k;\n+  Indexing_PtrToAddress p;\n+  Indexing_PtrToByte b;\n+\n+  j = i->Low;\n+  b = static_cast<Indexing_PtrToByte> (i->ArrayStart);\n+  while (j <= i->High)\n+    {\n+      p = (Indexing_PtrToAddress) (b);\n+      b += sizeof (void *);\n+      if ((*p) == a)\n+        {\n+          Indexing_DeleteIndice (i, j);\n+        }\n+      j += 1;\n+    }\n+}\n+\n+\n+/*\n+   DeleteIndice - delete i[j] from the array.\n+*/\n+\n+extern \"C\" void Indexing_DeleteIndice (Indexing_Index i, unsigned int j)\n+{\n+  Indexing_PtrToAddress p;\n+  Indexing_PtrToByte b;\n+\n+  if (Indexing_InBounds (i, j))\n+    {\n+      b = static_cast<Indexing_PtrToByte> (i->ArrayStart);\n+      b += sizeof (void *)*(j-i->Low);\n+      p = (Indexing_PtrToAddress) (b);\n+      b += sizeof (void *);\n+      p = static_cast<Indexing_PtrToAddress> (libc_memmove (reinterpret_cast<void *> (p), reinterpret_cast<void *> (b), static_cast<size_t> ((i->High-j)*sizeof (void *))));\n+      i->High -= 1;\n+      i->Used -= 1;\n+    }\n+  else\n+    {\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n+    }\n+}\n+\n+\n+/*\n+   IncludeIndiceIntoIndex - if the indice is not in the index, then\n+                            add it at the end.\n+*/\n+\n+extern \"C\" void Indexing_IncludeIndiceIntoIndex (Indexing_Index i, void * a)\n+{\n+  if (! (Indexing_IsIndiceInIndex (i, a)))\n+    {\n+      /* avoid gcc warning by using compound statement even if not strictly necessary.  */\n+      if (i->Used == 0)\n+        {\n+          Indexing_PutIndice (i, Indexing_LowIndice (i), a);\n+        }\n+      else\n+        {\n+          Indexing_PutIndice (i, (Indexing_HighIndice (i))+1, a);\n+        }\n+    }\n+}\n+\n+\n+/*\n+   ForeachIndiceInIndexDo - for each j indice of i, call procedure p(i[j])\n+*/\n+\n+extern \"C\" void Indexing_ForeachIndiceInIndexDo (Indexing_Index i, Indexing_IndexProcedure p)\n+{\n+  unsigned int j;\n+  Indexing_IndexProcedure q;\n+\n+  j = Indexing_LowIndice (i);\n+  q = p;\n+  while (j <= (Indexing_HighIndice (i)))\n+    {\n+      mcDebug_assert (q.proc == p.proc);\n+      (*p.proc) (Indexing_GetIndice (i, j));\n+      j += 1;\n+    }\n+}\n+\n+extern \"C\" void _M2_Indexing_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}\n+\n+extern \"C\" void _M2_Indexing_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "64441fff6429e31566956946208c10c3cbd62784", "filename": "gcc/m2/mc-boot/GM2Dependent.cc", "status": "added", "additions": 1407, "deletions": 0, "changes": 1407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGM2Dependent.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGM2Dependent.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGM2Dependent.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,1407 @@\n+/* do not edit automatically generated by mc from M2Dependent.  */\n+/* M2Dependent.mod implements the run time module dependencies.\n+\n+Copyright (C) 2022-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#   if !defined (TRUE)\n+#      define TRUE (1==1)\n+#   endif\n+\n+#   if !defined (FALSE)\n+#      define FALSE (1==0)\n+#   endif\n+\n+#   include \"GStorage.h\"\n+#if defined(__cplusplus)\n+#   undef NULL\n+#   define NULL 0\n+#endif\n+#define _M2Dependent_H\n+#define _M2Dependent_C\n+\n+#   include \"Glibc.h\"\n+#   include \"GM2LINK.h\"\n+#   include \"GASCII.h\"\n+#   include \"GSYSTEM.h\"\n+#   include \"GStorage.h\"\n+#   include \"GStrLib.h\"\n+#   include \"GM2RTS.h\"\n+\n+typedef struct M2Dependent_ArgCVEnvP_p M2Dependent_ArgCVEnvP;\n+\n+typedef struct M2Dependent_DependencyList_r M2Dependent_DependencyList;\n+\n+typedef struct M2Dependent__T2_r M2Dependent__T2;\n+\n+typedef M2Dependent__T2 *M2Dependent_ModuleChain;\n+\n+typedef struct M2Dependent__T3_a M2Dependent__T3;\n+\n+typedef enum {M2Dependent_unregistered, M2Dependent_unordered, M2Dependent_started, M2Dependent_ordered, M2Dependent_user} M2Dependent_DependencyState;\n+\n+typedef void (*M2Dependent_ArgCVEnvP_t) (int, void *, void *);\n+struct M2Dependent_ArgCVEnvP_p { M2Dependent_ArgCVEnvP_t proc; };\n+\n+struct M2Dependent_DependencyList_r {\n+                                      PROC proc;\n+                                      unsigned int forced;\n+                                      unsigned int forc;\n+                                      unsigned int appl;\n+                                      M2Dependent_DependencyState state;\n+                                    };\n+\n+struct M2Dependent__T3_a { M2Dependent_ModuleChain array[M2Dependent_user-M2Dependent_unregistered+1]; };\n+struct M2Dependent__T2_r {\n+                           void *name;\n+                           void *libname;\n+                           M2Dependent_ArgCVEnvP init;\n+                           M2Dependent_ArgCVEnvP fini;\n+                           M2Dependent_DependencyList dependency;\n+                           M2Dependent_ModuleChain prev;\n+                           M2Dependent_ModuleChain next;\n+                         };\n+\n+static M2Dependent__T3 Modules;\n+static unsigned int Initialized;\n+static unsigned int WarningTrace;\n+static unsigned int ModuleTrace;\n+static unsigned int HexTrace;\n+static unsigned int DependencyTrace;\n+static unsigned int PreTrace;\n+static unsigned int PostTrace;\n+static unsigned int ForceTrace;\n+\n+/*\n+   ConstructModules - resolve dependencies and then call each\n+                      module constructor in turn.\n+*/\n+\n+extern \"C\" void M2Dependent_ConstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n+\n+/*\n+   DeconstructModules - resolve dependencies and then call each\n+                        module constructor in turn.\n+*/\n+\n+extern \"C\" void M2Dependent_DeconstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n+\n+/*\n+   RegisterModule - adds module name to the list of outstanding\n+                    modules which need to have their dependencies\n+                    explored to determine initialization order.\n+*/\n+\n+extern \"C\" void M2Dependent_RegisterModule (void * modulename, void * libname, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies);\n+\n+/*\n+   RequestDependant - used to specify that modulename is dependant upon\n+                      module dependantmodule.  It only takes effect\n+                      if we are not using StaticInitialization.\n+*/\n+\n+extern \"C\" void M2Dependent_RequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname);\n+\n+/*\n+   CreateModule - creates a new module entry and returns the\n+                  ModuleChain.\n+*/\n+\n+static M2Dependent_ModuleChain CreateModule (void * name, void * libname, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies);\n+\n+/*\n+   AppendModule - append chain to end of the list.\n+*/\n+\n+static void AppendModule (M2Dependent_ModuleChain *head, M2Dependent_ModuleChain chain);\n+\n+/*\n+   RemoveModule - remove chain from double linked list head.\n+*/\n+\n+static void RemoveModule (M2Dependent_ModuleChain *head, M2Dependent_ModuleChain chain);\n+\n+/*\n+   onChain - returns TRUE if mptr is on the Modules[state] list.\n+*/\n+\n+static unsigned int onChain (M2Dependent_DependencyState state, M2Dependent_ModuleChain mptr);\n+\n+/*\n+   max -\n+*/\n+\n+static unsigned int max (unsigned int a, unsigned int b);\n+\n+/*\n+   min -\n+*/\n+\n+static unsigned int min (unsigned int a, unsigned int b);\n+\n+/*\n+   LookupModuleN - lookup module from the state list.\n+                   The strings lengths are known.\n+*/\n+\n+static M2Dependent_ModuleChain LookupModuleN (M2Dependent_DependencyState state, void * name, unsigned int namelen, void * libname, unsigned int libnamelen);\n+\n+/*\n+   LookupModule - lookup and return the ModuleChain pointer containing\n+                  module name from a particular list.\n+*/\n+\n+static M2Dependent_ModuleChain LookupModule (M2Dependent_DependencyState state, void * name, void * libname);\n+\n+/*\n+   toCString - replace any character sequence \n+ into a newline.\n+*/\n+\n+static void toCString (char *str, unsigned int _str_high);\n+\n+/*\n+   strcmp - return 0 if both strings are equal.\n+            We cannot use Builtins.def during bootstrap.\n+*/\n+\n+static int strcmp (M2LINK_PtrToChar a, M2LINK_PtrToChar b);\n+\n+/*\n+   strncmp - return 0 if both strings are equal.\n+             We cannot use Builtins.def during bootstrap.\n+*/\n+\n+static int strncmp (M2LINK_PtrToChar a, M2LINK_PtrToChar b, unsigned int n);\n+\n+/*\n+   strlen - returns the length of string.\n+*/\n+\n+static int strlen_ (M2LINK_PtrToChar string);\n+\n+/*\n+   traceprintf - wrap printf with a boolean flag.\n+*/\n+\n+static void traceprintf (unsigned int flag, const char *str_, unsigned int _str_high);\n+\n+/*\n+   traceprintf2 - wrap printf with a boolean flag.\n+*/\n+\n+static void traceprintf2 (unsigned int flag, const char *str_, unsigned int _str_high, void * arg);\n+\n+/*\n+   traceprintf3 - wrap printf with a boolean flag.\n+*/\n+\n+static void traceprintf3 (unsigned int flag, const char *str_, unsigned int _str_high, void * arg1, void * arg2);\n+\n+/*\n+   moveTo - moves mptr to the new list determined by newstate.\n+            It updates the mptr state appropriately.\n+*/\n+\n+static void moveTo (M2Dependent_DependencyState newstate, M2Dependent_ModuleChain mptr);\n+\n+/*\n+   ResolveDependant -\n+*/\n+\n+static void ResolveDependant (M2Dependent_ModuleChain mptr, void * currentmodule, void * libname);\n+\n+/*\n+   PerformRequestDependant - the current modulename has a dependancy upon\n+                             dependantmodule.  If dependantmodule is NIL then\n+                             modulename has no further dependants and it can be\n+                             resolved.\n+*/\n+\n+static void PerformRequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname);\n+\n+/*\n+   ResolveDependencies - resolve dependencies for currentmodule, libname.\n+*/\n+\n+static void ResolveDependencies (void * currentmodule, void * libname);\n+\n+/*\n+   DisplayModuleInfo - displays all module in the state.\n+*/\n+\n+static void DisplayModuleInfo (M2Dependent_DependencyState state, const char *desc_, unsigned int _desc_high);\n+\n+/*\n+   DumpModuleData -\n+*/\n+\n+static void DumpModuleData (unsigned int flag);\n+\n+/*\n+   combine - dest := src + dest.  Places src at the front of list dest.\n+             Pre condition:  src, dest are lists.\n+             Post condition : dest := src + dest\n+                              src := NIL.\n+*/\n+\n+static void combine (M2Dependent_DependencyState src, M2Dependent_DependencyState dest);\n+\n+/*\n+   tracemodule -\n+*/\n+\n+static void tracemodule (unsigned int flag, void * modname, unsigned int modlen, void * libname, unsigned int liblen);\n+\n+/*\n+   ForceModule -\n+*/\n+\n+static void ForceModule (void * modname, unsigned int modlen, void * libname, unsigned int liblen);\n+\n+/*\n+   ForceDependencies - if the user has specified a forced order then we override\n+                       the dynamic ordering with the preference.\n+*/\n+\n+static void ForceDependencies (void);\n+\n+/*\n+   CheckApplication - check to see that the application is the last entry in the list.\n+                      This might happen if the application only imports FOR C modules.\n+*/\n+\n+static void CheckApplication (void);\n+\n+/*\n+   warning3 - write format arg1 arg2 to stderr.\n+*/\n+\n+static void warning3 (const char *format_, unsigned int _format_high, void * arg1, void * arg2);\n+\n+/*\n+   equal - return TRUE if C string cstr is equal to str.\n+*/\n+\n+static unsigned int equal (void * cstr, const char *str_, unsigned int _str_high);\n+\n+/*\n+   SetupDebugFlags - By default assigns ModuleTrace, DependencyTrace,\n+                     DumpPostInit to FALSE.  It checks the environment\n+                     GCC_M2LINK_RTFLAG which can contain\n+                     \"all,module,hex,pre,post,dep,force\".  all turns them all on.\n+                     The flag meanings are as follows and flags the are in\n+                     execution order.\n+\n+                     module   generate trace info as the modules are registered.\n+                     hex      dump the modules ctor functions address in hex.\n+                     pre      generate a list of all modules seen prior to having\n+                              their dependancies resolved.\n+                     dep      display a trace as the modules are resolved.\n+                     post     generate a list of all modules seen after having\n+                              their dependancies resolved dynamically.\n+                     force    generate a list of all modules seen after having\n+                              their dependancies resolved and forced.\n+*/\n+\n+static void SetupDebugFlags (void);\n+\n+/*\n+   Init - initialize the debug flags and set all lists to NIL.\n+*/\n+\n+static void Init (void);\n+\n+/*\n+   CheckInitialized - checks to see if this module has been initialized\n+                      and if it has not it calls Init.  We need this\n+                      approach as this module is called by module ctors\n+                      before we reach main.\n+*/\n+\n+static void CheckInitialized (void);\n+\n+\n+/*\n+   CreateModule - creates a new module entry and returns the\n+                  ModuleChain.\n+*/\n+\n+static M2Dependent_ModuleChain CreateModule (void * name, void * libname, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies)\n+{\n+  M2Dependent_ModuleChain mptr;\n+  void * p0;\n+  void * p1;\n+\n+  Storage_ALLOCATE ((void **) &mptr, sizeof (M2Dependent__T2));\n+  mptr->name = name;\n+  mptr->libname = libname;\n+  mptr->init = init;\n+  mptr->fini = fini;\n+  mptr->dependency.proc = dependencies;\n+  mptr->dependency.state = M2Dependent_unregistered;\n+  mptr->prev = NULL;\n+  mptr->next = NULL;\n+  if (HexTrace)\n+    {\n+      libc_printf ((const char *) \"   (init: %p  fini: %p\", 22, init, fini);\n+      libc_printf ((const char *) \"  dep: %p)\", 10, dependencies);\n+    }\n+  return mptr;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   AppendModule - append chain to end of the list.\n+*/\n+\n+static void AppendModule (M2Dependent_ModuleChain *head, M2Dependent_ModuleChain chain)\n+{\n+  if ((*head) == NULL)\n+    {\n+      (*head) = chain;\n+      chain->prev = chain;\n+      chain->next = chain;\n+    }\n+  else\n+    {\n+      chain->next = (*head);  /* Add Item to the end of list.  */\n+      chain->prev = (*head)->prev;  /* Add Item to the end of list.  */\n+      (*head)->prev->next = chain;\n+      (*head)->prev = chain;\n+    }\n+}\n+\n+\n+/*\n+   RemoveModule - remove chain from double linked list head.\n+*/\n+\n+static void RemoveModule (M2Dependent_ModuleChain *head, M2Dependent_ModuleChain chain)\n+{\n+  if ((chain->next == (*head)) && (chain == (*head)))\n+    {\n+      (*head) = NULL;\n+    }\n+  else\n+    {\n+      if ((*head) == chain)\n+        {\n+          (*head) = (*head)->next;\n+        }\n+      chain->prev->next = chain->next;\n+      chain->next->prev = chain->prev;\n+    }\n+}\n+\n+\n+/*\n+   onChain - returns TRUE if mptr is on the Modules[state] list.\n+*/\n+\n+static unsigned int onChain (M2Dependent_DependencyState state, M2Dependent_ModuleChain mptr)\n+{\n+  M2Dependent_ModuleChain ptr;\n+\n+  if (Modules.array[state-M2Dependent_unregistered] != NULL)\n+    {\n+      ptr = Modules.array[state-M2Dependent_unregistered];\n+      do {\n+        if (ptr == mptr)\n+          {\n+            return TRUE;\n+          }\n+        ptr = ptr->next;\n+      } while (! (ptr == Modules.array[state-M2Dependent_unregistered]));\n+    }\n+  return FALSE;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   max -\n+*/\n+\n+static unsigned int max (unsigned int a, unsigned int b)\n+{\n+  if (a > b)\n+    {\n+      return a;\n+    }\n+  else\n+    {\n+      return b;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   min -\n+*/\n+\n+static unsigned int min (unsigned int a, unsigned int b)\n+{\n+  if (a < b)\n+    {\n+      return a;\n+    }\n+  else\n+    {\n+      return b;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   LookupModuleN - lookup module from the state list.\n+                   The strings lengths are known.\n+*/\n+\n+static M2Dependent_ModuleChain LookupModuleN (M2Dependent_DependencyState state, void * name, unsigned int namelen, void * libname, unsigned int libnamelen)\n+{\n+  M2Dependent_ModuleChain ptr;\n+\n+  if (Modules.array[state-M2Dependent_unregistered] != NULL)\n+    {\n+      ptr = Modules.array[state-M2Dependent_unregistered];\n+      do {\n+        if (((strncmp (reinterpret_cast<M2LINK_PtrToChar> (ptr->name), reinterpret_cast<M2LINK_PtrToChar> (name), max (namelen, static_cast<unsigned int> (strlen_ (reinterpret_cast<M2LINK_PtrToChar> (ptr->name)))))) == 0) && ((strncmp (reinterpret_cast<M2LINK_PtrToChar> (ptr->libname), reinterpret_cast<M2LINK_PtrToChar> (libname), max (libnamelen, static_cast<unsigned int> (strlen_ (reinterpret_cast<M2LINK_PtrToChar> (ptr->libname)))))) == 0))\n+          {\n+            return ptr;\n+          }\n+        ptr = ptr->next;\n+      } while (! (ptr == Modules.array[state-M2Dependent_unregistered]));\n+    }\n+  return NULL;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   LookupModule - lookup and return the ModuleChain pointer containing\n+                  module name from a particular list.\n+*/\n+\n+static M2Dependent_ModuleChain LookupModule (M2Dependent_DependencyState state, void * name, void * libname)\n+{\n+  return LookupModuleN (state, name, static_cast<unsigned int> (strlen_ (reinterpret_cast<M2LINK_PtrToChar> (name))), libname, static_cast<unsigned int> (strlen_ (reinterpret_cast<M2LINK_PtrToChar> (libname))));\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   toCString - replace any character sequence \n+ into a newline.\n+*/\n+\n+static void toCString (char *str, unsigned int _str_high)\n+{\n+  unsigned int high;\n+  unsigned int i;\n+  unsigned int j;\n+\n+  i = 0;\n+  high = _str_high;\n+  while (i < high)\n+    {\n+      if ((i < high) && (str[i] == '\\\\'))\n+        {\n+          if (str[i+1] == 'n')\n+            {\n+              str[i] = ASCII_nl;\n+              j = i+1;\n+              while (j < high)\n+                {\n+                  str[j] = str[j+1];\n+                  j += 1;\n+                }\n+            }\n+        }\n+      i += 1;\n+    }\n+}\n+\n+\n+/*\n+   strcmp - return 0 if both strings are equal.\n+            We cannot use Builtins.def during bootstrap.\n+*/\n+\n+static int strcmp (M2LINK_PtrToChar a, M2LINK_PtrToChar b)\n+{\n+  if ((a != NULL) && (b != NULL))\n+    {\n+      /* avoid gcc warning by using compound statement even if not strictly necessary.  */\n+      if (a == b)\n+        {\n+          return 0;\n+        }\n+      else\n+        {\n+          while ((*a) == (*b))\n+            {\n+              if ((*a) == ASCII_nul)\n+                {\n+                  return 0;\n+                }\n+              a += 1;\n+              b += 1;\n+            }\n+        }\n+    }\n+  return 1;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   strncmp - return 0 if both strings are equal.\n+             We cannot use Builtins.def during bootstrap.\n+*/\n+\n+static int strncmp (M2LINK_PtrToChar a, M2LINK_PtrToChar b, unsigned int n)\n+{\n+  if (n == 0)\n+    {\n+      return 0;\n+    }\n+  else if ((a != NULL) && (b != NULL))\n+    {\n+      /* avoid dangling else.  */\n+      if (a == b)\n+        {\n+          return 0;\n+        }\n+      else\n+        {\n+          while (((*a) == (*b)) && (n > 0))\n+            {\n+              if (((*a) == ASCII_nul) || (n == 1))\n+                {\n+                  return 0;\n+                }\n+              a += 1;\n+              b += 1;\n+              n -= 1;\n+            }\n+        }\n+    }\n+  return 1;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   strlen - returns the length of string.\n+*/\n+\n+static int strlen_ (M2LINK_PtrToChar string)\n+{\n+  int count;\n+\n+  if (string == NULL)\n+    {\n+      return 0;\n+    }\n+  else\n+    {\n+      count = 0;\n+      while ((*string) != ASCII_nul)\n+        {\n+          string += 1;\n+          count += 1;\n+        }\n+      return count;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   traceprintf - wrap printf with a boolean flag.\n+*/\n+\n+static void traceprintf (unsigned int flag, const char *str_, unsigned int _str_high)\n+{\n+  char str[_str_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (str, str_, _str_high+1);\n+\n+  if (flag)\n+    {\n+      toCString ((char *) str, _str_high);\n+      libc_printf ((const char *) str, _str_high);\n+    }\n+}\n+\n+\n+/*\n+   traceprintf2 - wrap printf with a boolean flag.\n+*/\n+\n+static void traceprintf2 (unsigned int flag, const char *str_, unsigned int _str_high, void * arg)\n+{\n+  char ch;\n+  char str[_str_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (str, str_, _str_high+1);\n+\n+  if (flag)\n+    {\n+      toCString ((char *) str, _str_high);\n+      if (arg == NULL)\n+        {\n+          ch = (char) 0;\n+          arg = &ch;\n+        }\n+      libc_printf ((const char *) str, _str_high, arg);\n+    }\n+}\n+\n+\n+/*\n+   traceprintf3 - wrap printf with a boolean flag.\n+*/\n+\n+static void traceprintf3 (unsigned int flag, const char *str_, unsigned int _str_high, void * arg1, void * arg2)\n+{\n+  char ch;\n+  char str[_str_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (str, str_, _str_high+1);\n+\n+  if (flag)\n+    {\n+      toCString ((char *) str, _str_high);\n+      if (arg1 == NULL)\n+        {\n+          ch = (char) 0;\n+          arg1 = &ch;\n+        }\n+      if (arg2 == NULL)\n+        {\n+          ch = (char) 0;\n+          arg2 = &ch;\n+        }\n+      libc_printf ((const char *) str, _str_high, arg1, arg2);\n+    }\n+}\n+\n+\n+/*\n+   moveTo - moves mptr to the new list determined by newstate.\n+            It updates the mptr state appropriately.\n+*/\n+\n+static void moveTo (M2Dependent_DependencyState newstate, M2Dependent_ModuleChain mptr)\n+{\n+  if (onChain (mptr->dependency.state, mptr))\n+    {\n+      RemoveModule (&Modules.array[mptr->dependency.state-M2Dependent_unregistered], mptr);\n+    }\n+  mptr->dependency.state = newstate;\n+  AppendModule (&Modules.array[mptr->dependency.state-M2Dependent_unregistered], mptr);\n+}\n+\n+\n+/*\n+   ResolveDependant -\n+*/\n+\n+static void ResolveDependant (M2Dependent_ModuleChain mptr, void * currentmodule, void * libname)\n+{\n+  if (mptr == NULL)\n+    {\n+      traceprintf3 (DependencyTrace, (const char *) \"   module %s [%s] has not been registered via a global constructor\\\\n\", 68, currentmodule, libname);\n+    }\n+  else\n+    {\n+      if (onChain (M2Dependent_started, mptr))\n+        {\n+          traceprintf (DependencyTrace, (const char *) \"   processing...\\\\n\", 18);\n+        }\n+      else\n+        {\n+          moveTo (M2Dependent_started, mptr);\n+          traceprintf3 (DependencyTrace, (const char *) \"   starting: %s [%s]\\\\n\", 22, currentmodule, libname);\n+          (*mptr->dependency.proc.proc) ();  /* Invoke and process the dependency graph.  */\n+          traceprintf3 (DependencyTrace, (const char *) \"   finished: %s [%s]\\\\n\", 22, currentmodule, libname);  /* Invoke and process the dependency graph.  */\n+          moveTo (M2Dependent_ordered, mptr);\n+        }\n+    }\n+}\n+\n+\n+/*\n+   PerformRequestDependant - the current modulename has a dependancy upon\n+                             dependantmodule.  If dependantmodule is NIL then\n+                             modulename has no further dependants and it can be\n+                             resolved.\n+*/\n+\n+static void PerformRequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname)\n+{\n+  M2Dependent_ModuleChain mptr;\n+\n+  traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s]\", 16, modulename, libname);\n+  if (dependantmodule == NULL)\n+    {\n+      /* avoid dangling else.  */\n+      traceprintf (DependencyTrace, (const char *) \" has finished its import graph\\\\n\", 32);\n+      mptr = LookupModule (M2Dependent_unordered, modulename, libname);\n+      if (mptr != NULL)\n+        {\n+          traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s] is now ordered\\\\n\", 33, modulename, libname);\n+          moveTo (M2Dependent_ordered, mptr);\n+        }\n+    }\n+  else\n+    {\n+      traceprintf3 (DependencyTrace, (const char *) \" imports from %s [%s]\\\\n\", 23, dependantmodule, dependantlibname);\n+      mptr = LookupModule (M2Dependent_ordered, dependantmodule, dependantlibname);\n+      if (mptr == NULL)\n+        {\n+          traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s] is not ordered\\\\n\", 33, dependantmodule, dependantlibname);\n+          mptr = LookupModule (M2Dependent_unordered, dependantmodule, dependantlibname);\n+          if (mptr == NULL)\n+            {\n+              traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s] is not unordered\\\\n\", 35, dependantmodule, dependantlibname);\n+              mptr = LookupModule (M2Dependent_started, dependantmodule, dependantlibname);\n+              if (mptr == NULL)\n+                {\n+                  traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s] has not started\\\\n\", 34, dependantmodule, dependantlibname);\n+                  traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s] attempting to import from\", 42, modulename, libname);\n+                  traceprintf3 (DependencyTrace, (const char *) \" %s [%s] which has not registered itself via a constructor\\\\n\", 60, dependantmodule, dependantlibname);\n+                }\n+              else\n+                {\n+                  traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s] has registered itself and has started\\\\n\", 56, dependantmodule, dependantlibname);\n+                }\n+            }\n+          else\n+            {\n+              traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s] resolving\\\\n\", 28, dependantmodule, dependantlibname);\n+              ResolveDependant (mptr, dependantmodule, dependantlibname);\n+            }\n+        }\n+      else\n+        {\n+          traceprintf3 (DependencyTrace, (const char *) \"  module %s [%s]\", 16, modulename, libname);\n+          traceprintf3 (DependencyTrace, (const char *) \" dependant %s [%s] is ordered\\\\n\", 31, dependantmodule, dependantlibname);\n+        }\n+    }\n+}\n+\n+\n+/*\n+   ResolveDependencies - resolve dependencies for currentmodule, libname.\n+*/\n+\n+static void ResolveDependencies (void * currentmodule, void * libname)\n+{\n+  M2Dependent_ModuleChain mptr;\n+\n+  mptr = LookupModule (M2Dependent_unordered, currentmodule, libname);\n+  while (mptr != NULL)\n+    {\n+      traceprintf3 (DependencyTrace, (const char *) \"   attempting to resolve the dependants for %s [%s]\\\\n\", 53, currentmodule, libname);\n+      ResolveDependant (mptr, currentmodule, libname);\n+      mptr = Modules.array[M2Dependent_unordered-M2Dependent_unregistered];\n+    }\n+}\n+\n+\n+/*\n+   DisplayModuleInfo - displays all module in the state.\n+*/\n+\n+static void DisplayModuleInfo (M2Dependent_DependencyState state, const char *desc_, unsigned int _desc_high)\n+{\n+  M2Dependent_ModuleChain mptr;\n+  unsigned int count;\n+  char desc[_desc_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (desc, desc_, _desc_high+1);\n+\n+  if (Modules.array[state-M2Dependent_unregistered] != NULL)\n+    {\n+      libc_printf ((const char *) \"%s modules\\\\n\", 12, &desc);\n+      mptr = Modules.array[state-M2Dependent_unregistered];\n+      count = 0;\n+      do {\n+        if (mptr->name == NULL)\n+          {\n+            libc_printf ((const char *) \"  %d  %s []\", 11, count, mptr->name);\n+          }\n+        else\n+          {\n+            libc_printf ((const char *) \"  %d  %s [%s]\", 13, count, mptr->name, mptr->libname);\n+          }\n+        count += 1;\n+        if (mptr->dependency.appl)\n+          {\n+            libc_printf ((const char *) \" application\", 12);\n+          }\n+        if (mptr->dependency.forc)\n+          {\n+            libc_printf ((const char *) \" for C\", 6);\n+          }\n+        if (mptr->dependency.forced)\n+          {\n+            libc_printf ((const char *) \" forced ordering\", 16);\n+          }\n+        libc_printf ((const char *) \"\\\\n\", 2);\n+        mptr = mptr->next;\n+      } while (! (mptr == Modules.array[state-M2Dependent_unregistered]));\n+    }\n+}\n+\n+\n+/*\n+   DumpModuleData -\n+*/\n+\n+static void DumpModuleData (unsigned int flag)\n+{\n+  M2Dependent_ModuleChain mptr;\n+\n+  if (flag)\n+    {\n+      DisplayModuleInfo (M2Dependent_unregistered, (const char *) \"unregistered\", 12);\n+      DisplayModuleInfo (M2Dependent_unordered, (const char *) \"unordered\", 9);\n+      DisplayModuleInfo (M2Dependent_started, (const char *) \"started\", 7);\n+      DisplayModuleInfo (M2Dependent_ordered, (const char *) \"ordered\", 7);\n+    }\n+}\n+\n+\n+/*\n+   combine - dest := src + dest.  Places src at the front of list dest.\n+             Pre condition:  src, dest are lists.\n+             Post condition : dest := src + dest\n+                              src := NIL.\n+*/\n+\n+static void combine (M2Dependent_DependencyState src, M2Dependent_DependencyState dest)\n+{\n+  M2Dependent_ModuleChain last;\n+\n+  while (Modules.array[src-M2Dependent_unregistered] != NULL)\n+    {\n+      last = Modules.array[src-M2Dependent_unregistered]->prev;\n+      moveTo (M2Dependent_ordered, last);\n+      Modules.array[dest-M2Dependent_unregistered] = last;  /* New item is at the head.  */\n+    }\n+}\n+\n+\n+/*\n+   tracemodule -\n+*/\n+\n+static void tracemodule (unsigned int flag, void * modname, unsigned int modlen, void * libname, unsigned int liblen)\n+{\n+  typedef struct tracemodule__T4_a tracemodule__T4;\n+\n+  struct tracemodule__T4_a { char array[100+1]; };\n+  tracemodule__T4 buffer;\n+  unsigned int len;\n+\n+  if (flag)\n+    {\n+      len = min (modlen, sizeof (buffer)-1);\n+      libc_strncpy (&buffer, modname, len);\n+      buffer.array[len] = (char) 0;\n+      libc_printf ((const char *) \"%s \", 3, &buffer);\n+      len = min (liblen, sizeof (buffer)-1);\n+      libc_strncpy (&buffer, libname, len);\n+      buffer.array[len] = (char) 0;\n+      libc_printf ((const char *) \" [%s]\", 5, &buffer);\n+    }\n+}\n+\n+\n+/*\n+   ForceModule -\n+*/\n+\n+static void ForceModule (void * modname, unsigned int modlen, void * libname, unsigned int liblen)\n+{\n+  M2Dependent_ModuleChain mptr;\n+\n+  traceprintf (ForceTrace, (const char *) \"forcing module: \", 16);\n+  tracemodule (ForceTrace, modname, modlen, libname, liblen);\n+  traceprintf (ForceTrace, (const char *) \"\\\\n\", 2);\n+  mptr = LookupModuleN (M2Dependent_ordered, modname, modlen, libname, liblen);\n+  if (mptr != NULL)\n+    {\n+      mptr->dependency.forced = TRUE;\n+      moveTo (M2Dependent_user, mptr);\n+    }\n+}\n+\n+\n+/*\n+   ForceDependencies - if the user has specified a forced order then we override\n+                       the dynamic ordering with the preference.\n+*/\n+\n+static void ForceDependencies (void)\n+{\n+  unsigned int len;\n+  unsigned int modlen;\n+  unsigned int liblen;\n+  M2LINK_PtrToChar modname;\n+  M2LINK_PtrToChar libname;\n+  M2LINK_PtrToChar pc;\n+  M2LINK_PtrToChar start;\n+\n+  if (M2LINK_ForcedModuleInitOrder != NULL)\n+    {\n+      traceprintf2 (ForceTrace, (const char *) \"user forcing order: %s\\\\n\", 24, reinterpret_cast<void *> (M2LINK_ForcedModuleInitOrder));\n+      pc = M2LINK_ForcedModuleInitOrder;\n+      start = pc;\n+      len = 0;\n+      modname = NULL;\n+      modlen = 0;\n+      libname = NULL;\n+      liblen = 0;\n+      while ((*pc) != ASCII_nul)\n+        {\n+          switch ((*pc))\n+            {\n+              case ':':\n+                libname = start;\n+                liblen = len;\n+                len = 0;\n+                pc += 1;\n+                start = pc;\n+                break;\n+\n+              case ',':\n+                modname = start;\n+                modlen = len;\n+                ForceModule (reinterpret_cast<void *> (modname), modlen, reinterpret_cast<void *> (libname), liblen);\n+                libname = NULL;\n+                liblen = 0;\n+                modlen = 0;\n+                len = 0;\n+                pc += 1;\n+                start = pc;\n+                break;\n+\n+\n+              default:\n+                pc += 1;\n+                len += 1;\n+                break;\n+            }\n+        }\n+      if (start != pc)\n+        {\n+          ForceModule (reinterpret_cast<void *> (start), len, reinterpret_cast<void *> (libname), liblen);\n+        }\n+      combine (M2Dependent_user, M2Dependent_ordered);\n+    }\n+}\n+\n+\n+/*\n+   CheckApplication - check to see that the application is the last entry in the list.\n+                      This might happen if the application only imports FOR C modules.\n+*/\n+\n+static void CheckApplication (void)\n+{\n+  M2Dependent_ModuleChain mptr;\n+  M2Dependent_ModuleChain appl;\n+\n+  mptr = Modules.array[M2Dependent_ordered-M2Dependent_unregistered];\n+  if (mptr != NULL)\n+    {\n+      appl = NULL;\n+      do {\n+        if (mptr->dependency.appl)\n+          {\n+            appl = mptr;\n+          }\n+        else\n+          {\n+            mptr = mptr->next;\n+          }\n+      } while (! ((appl != NULL) || (mptr == Modules.array[M2Dependent_ordered-M2Dependent_unregistered])));\n+      if (appl != NULL)\n+        {\n+          RemoveModule (&Modules.array[M2Dependent_ordered-M2Dependent_unregistered], appl);\n+          AppendModule (&Modules.array[M2Dependent_ordered-M2Dependent_unregistered], appl);\n+        }\n+    }\n+}\n+\n+\n+/*\n+   warning3 - write format arg1 arg2 to stderr.\n+*/\n+\n+static void warning3 (const char *format_, unsigned int _format_high, void * arg1, void * arg2)\n+{\n+  typedef struct warning3__T5_a warning3__T5;\n+\n+  struct warning3__T5_a { char array[4096+1]; };\n+  warning3__T5 buffer;\n+  int len;\n+  char format[_format_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (format, format_, _format_high+1);\n+\n+  if (WarningTrace)\n+    {\n+      len = libc_snprintf (&buffer, static_cast<size_t> (sizeof (buffer)), (const char *) \"warning: \", 9);\n+      libc_write (2, &buffer, static_cast<size_t> (len));\n+      len = libc_snprintf (&buffer, static_cast<size_t> (sizeof (buffer)), (const char *) format, _format_high, arg1, arg2);\n+      libc_write (2, &buffer, static_cast<size_t> (len));\n+    }\n+}\n+\n+\n+/*\n+   equal - return TRUE if C string cstr is equal to str.\n+*/\n+\n+static unsigned int equal (void * cstr, const char *str_, unsigned int _str_high)\n+{\n+  char str[_str_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (str, str_, _str_high+1);\n+\n+  return (strncmp (reinterpret_cast<M2LINK_PtrToChar> (cstr), reinterpret_cast<M2LINK_PtrToChar> (&str), StrLib_StrLen ((const char *) str, _str_high))) == 0;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   SetupDebugFlags - By default assigns ModuleTrace, DependencyTrace,\n+                     DumpPostInit to FALSE.  It checks the environment\n+                     GCC_M2LINK_RTFLAG which can contain\n+                     \"all,module,hex,pre,post,dep,force\".  all turns them all on.\n+                     The flag meanings are as follows and flags the are in\n+                     execution order.\n+\n+                     module   generate trace info as the modules are registered.\n+                     hex      dump the modules ctor functions address in hex.\n+                     pre      generate a list of all modules seen prior to having\n+                              their dependancies resolved.\n+                     dep      display a trace as the modules are resolved.\n+                     post     generate a list of all modules seen after having\n+                              their dependancies resolved dynamically.\n+                     force    generate a list of all modules seen after having\n+                              their dependancies resolved and forced.\n+*/\n+\n+static void SetupDebugFlags (void)\n+{\n+  typedef char *SetupDebugFlags__T1;\n+\n+  SetupDebugFlags__T1 pc;\n+\n+  ModuleTrace = FALSE;\n+  DependencyTrace = FALSE;\n+  PostTrace = FALSE;\n+  PreTrace = FALSE;\n+  ForceTrace = FALSE;\n+  HexTrace = FALSE;\n+  WarningTrace = FALSE;\n+  pc = static_cast<SetupDebugFlags__T1> (libc_getenv (const_cast<void*> (reinterpret_cast<const void*>(\"GCC_M2LINK_RTFLAG\"))));\n+  while ((pc != NULL) && ((*pc) != ASCII_nul))\n+    {\n+      if (equal (reinterpret_cast<void *> (pc), (const char *) \"all\", 3))\n+        {\n+          ModuleTrace = TRUE;\n+          DependencyTrace = TRUE;\n+          PreTrace = TRUE;\n+          PostTrace = TRUE;\n+          ForceTrace = TRUE;\n+          HexTrace = TRUE;\n+          WarningTrace = TRUE;\n+          pc += 3;\n+        }\n+      else if (equal (reinterpret_cast<void *> (pc), (const char *) \"module\", 6))\n+        {\n+          /* avoid dangling else.  */\n+          ModuleTrace = TRUE;\n+          pc += 6;\n+        }\n+      else if (equal (reinterpret_cast<void *> (pc), (const char *) \"warning\", 7))\n+        {\n+          /* avoid dangling else.  */\n+          WarningTrace = TRUE;\n+          pc += 7;\n+        }\n+      else if (equal (reinterpret_cast<void *> (pc), (const char *) \"hex\", 3))\n+        {\n+          /* avoid dangling else.  */\n+          HexTrace = TRUE;\n+          pc += 3;\n+        }\n+      else if (equal (reinterpret_cast<void *> (pc), (const char *) \"dep\", 3))\n+        {\n+          /* avoid dangling else.  */\n+          DependencyTrace = TRUE;\n+          pc += 3;\n+        }\n+      else if (equal (reinterpret_cast<void *> (pc), (const char *) \"pre\", 3))\n+        {\n+          /* avoid dangling else.  */\n+          PreTrace = TRUE;\n+          pc += 3;\n+        }\n+      else if (equal (reinterpret_cast<void *> (pc), (const char *) \"post\", 4))\n+        {\n+          /* avoid dangling else.  */\n+          PostTrace = TRUE;\n+          pc += 4;\n+        }\n+      else if (equal (reinterpret_cast<void *> (pc), (const char *) \"force\", 5))\n+        {\n+          /* avoid dangling else.  */\n+          ForceTrace = TRUE;\n+          pc += 5;\n+        }\n+      else\n+        {\n+          /* avoid dangling else.  */\n+          pc += 1;\n+        }\n+    }\n+}\n+\n+\n+/*\n+   Init - initialize the debug flags and set all lists to NIL.\n+*/\n+\n+static void Init (void)\n+{\n+  M2Dependent_DependencyState state;\n+\n+  SetupDebugFlags ();\n+  for (state=M2Dependent_unregistered; state<=M2Dependent_user; state= static_cast<M2Dependent_DependencyState>(static_cast<int>(state+1)))\n+    {\n+      Modules.array[state-M2Dependent_unregistered] = NULL;\n+    }\n+}\n+\n+\n+/*\n+   CheckInitialized - checks to see if this module has been initialized\n+                      and if it has not it calls Init.  We need this\n+                      approach as this module is called by module ctors\n+                      before we reach main.\n+*/\n+\n+static void CheckInitialized (void)\n+{\n+  if (! Initialized)\n+    {\n+      Initialized = TRUE;\n+      Init ();\n+    }\n+}\n+\n+\n+/*\n+   ConstructModules - resolve dependencies and then call each\n+                      module constructor in turn.\n+*/\n+\n+extern \"C\" void M2Dependent_ConstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp)\n+{\n+  M2Dependent_ModuleChain mptr;\n+  M2Dependent_ArgCVEnvP nulp;\n+\n+  CheckInitialized ();\n+  traceprintf3 (ModuleTrace, (const char *) \"application module: %s [%s]\\\\n\", 29, applicationmodule, libname);\n+  mptr = LookupModule (M2Dependent_unordered, applicationmodule, libname);\n+  if (mptr != NULL)\n+    {\n+      mptr->dependency.appl = TRUE;\n+    }\n+  traceprintf (PreTrace, (const char *) \"Pre resolving dependents\\\\n\", 26);\n+  DumpModuleData (PreTrace);\n+  ResolveDependencies (applicationmodule, libname);\n+  traceprintf (PreTrace, (const char *) \"Post resolving dependents\\\\n\", 27);\n+  DumpModuleData (PostTrace);\n+  ForceDependencies ();\n+  traceprintf (ForceTrace, (const char *) \"After user forcing ordering\\\\n\", 29);\n+  DumpModuleData (ForceTrace);\n+  CheckApplication ();\n+  traceprintf (ForceTrace, (const char *) \"After runtime forces application to the end\\\\n\", 45);\n+  DumpModuleData (ForceTrace);\n+  if (Modules.array[M2Dependent_ordered-M2Dependent_unregistered] == NULL)\n+    {\n+      traceprintf3 (ModuleTrace, (const char *) \"  module: %s [%s] has not registered itself using a global constructor\\\\n\", 72, applicationmodule, libname);\n+      traceprintf2 (ModuleTrace, (const char *) \"  hint try compile and linking using: gm2 %s.mod\\\\n\", 50, applicationmodule);\n+      traceprintf2 (ModuleTrace, (const char *) \"  or try using: gm2 -fscaffold-static %s.mod\\\\n\", 46, applicationmodule);\n+    }\n+  else\n+    {\n+      mptr = Modules.array[M2Dependent_ordered-M2Dependent_unregistered];\n+      do {\n+        if (mptr->dependency.forc)\n+          {\n+            traceprintf3 (ModuleTrace, (const char *) \"initializing module: %s [%s] for C\\\\n\", 36, mptr->name, mptr->libname);\n+          }\n+        else\n+          {\n+            traceprintf3 (ModuleTrace, (const char *) \"initializing module: %s [%s]\\\\n\", 30, mptr->name, mptr->libname);\n+          }\n+        if (mptr->dependency.appl)\n+          {\n+            traceprintf3 (ModuleTrace, (const char *) \"application module: %s [%s]\\\\n\", 29, mptr->name, mptr->libname);\n+            traceprintf (ModuleTrace, (const char *) \"  calling M2RTS_ExecuteInitialProcedures\\\\n\", 42);\n+            M2RTS_ExecuteInitialProcedures ();\n+            traceprintf (ModuleTrace, (const char *) \"  calling application module\\\\n\", 30);\n+          }\n+        (*mptr->init.proc) (argc, argv, envp);\n+        mptr = mptr->next;\n+      } while (! (mptr == Modules.array[M2Dependent_ordered-M2Dependent_unregistered]));\n+    }\n+}\n+\n+\n+/*\n+   DeconstructModules - resolve dependencies and then call each\n+                        module constructor in turn.\n+*/\n+\n+extern \"C\" void M2Dependent_DeconstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp)\n+{\n+  M2Dependent_ModuleChain mptr;\n+\n+  traceprintf3 (ModuleTrace, (const char *) \"application module finishing: %s [%s]\\\\n\", 39, applicationmodule, libname);\n+  if (Modules.array[M2Dependent_ordered-M2Dependent_unregistered] == NULL)\n+    {\n+      traceprintf (ModuleTrace, (const char *) \"  no ordered modules found during finishing\\\\n\", 45);\n+    }\n+  else\n+    {\n+      traceprintf (ModuleTrace, (const char *) \"ExecuteTerminationProcedures\\\\n\", 30);\n+      M2RTS_ExecuteTerminationProcedures ();\n+      traceprintf (ModuleTrace, (const char *) \"terminating modules in sequence\\\\n\", 33);\n+      mptr = Modules.array[M2Dependent_ordered-M2Dependent_unregistered]->prev;\n+      do {\n+        if (mptr->dependency.forc)\n+          {\n+            traceprintf3 (ModuleTrace, (const char *) \"finalizing module: %s [%s] for C\\\\n\", 34, mptr->name, mptr->libname);\n+          }\n+        else\n+          {\n+            traceprintf3 (ModuleTrace, (const char *) \"finalizing module: %s [%s]\\\\n\", 28, mptr->name, mptr->libname);\n+          }\n+        (*mptr->fini.proc) (argc, argv, envp);\n+        mptr = mptr->prev;\n+      } while (! (mptr == Modules.array[M2Dependent_ordered-M2Dependent_unregistered]->prev));\n+    }\n+}\n+\n+\n+/*\n+   RegisterModule - adds module name to the list of outstanding\n+                    modules which need to have their dependencies\n+                    explored to determine initialization order.\n+*/\n+\n+extern \"C\" void M2Dependent_RegisterModule (void * modulename, void * libname, M2Dependent_ArgCVEnvP init, M2Dependent_ArgCVEnvP fini, PROC dependencies)\n+{\n+  M2Dependent_ModuleChain mptr;\n+\n+  CheckInitialized ();\n+  if (! M2LINK_StaticInitialization)\n+    {\n+      mptr = LookupModule (M2Dependent_unordered, modulename, libname);\n+      if (mptr == NULL)\n+        {\n+          traceprintf3 (ModuleTrace, (const char *) \"module: %s [%s] registering\", 27, modulename, libname);\n+          moveTo (M2Dependent_unordered, CreateModule (modulename, libname, init, fini, dependencies));\n+          traceprintf (ModuleTrace, (const char *) \"\\\\n\", 2);\n+        }\n+      else\n+        {\n+          warning3 ((const char *) \"module: %s [%s] (ignoring duplicate registration)\\\\n\", 51, modulename, libname);\n+        }\n+    }\n+}\n+\n+\n+/*\n+   RequestDependant - used to specify that modulename is dependant upon\n+                      module dependantmodule.  It only takes effect\n+                      if we are not using StaticInitialization.\n+*/\n+\n+extern \"C\" void M2Dependent_RequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname)\n+{\n+  CheckInitialized ();\n+  if (! M2LINK_StaticInitialization)\n+    {\n+      PerformRequestDependant (modulename, libname, dependantmodule, dependantlibname);\n+    }\n+}\n+\n+extern \"C\" void _M2_M2Dependent_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+  CheckInitialized ();\n+}\n+\n+extern \"C\" void _M2_M2Dependent_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "387b04764624d6e8cfe4f1ade5ff4c79cc9024cb", "filename": "gcc/m2/mc-boot/GM2EXCEPTION.cc", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGM2EXCEPTION.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGM2EXCEPTION.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGM2EXCEPTION.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,89 @@\n+/* do not edit automatically generated by mc from M2EXCEPTION.  */\n+/* M2EXCEPTION.mod implement M2Exception and IsM2Exception.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#   include \"Gmcrts.h\"\n+#define _M2EXCEPTION_H\n+#define _M2EXCEPTION_C\n+\n+#   include \"GSYSTEM.h\"\n+#   include \"GRTExceptions.h\"\n+\n+typedef enum {M2EXCEPTION_indexException, M2EXCEPTION_rangeException, M2EXCEPTION_caseSelectException, M2EXCEPTION_invalidLocation, M2EXCEPTION_functionException, M2EXCEPTION_wholeValueException, M2EXCEPTION_wholeDivException, M2EXCEPTION_realValueException, M2EXCEPTION_realDivException, M2EXCEPTION_complexValueException, M2EXCEPTION_complexDivException, M2EXCEPTION_protException, M2EXCEPTION_sysException, M2EXCEPTION_coException, M2EXCEPTION_exException} M2EXCEPTION_M2Exceptions;\n+\n+extern \"C\" M2EXCEPTION_M2Exceptions M2EXCEPTION_M2Exception (void);\n+extern \"C\" unsigned int M2EXCEPTION_IsM2Exception (void);\n+\n+extern \"C\" M2EXCEPTION_M2Exceptions M2EXCEPTION_M2Exception (void)\n+{\n+  RTExceptions_EHBlock e;\n+  unsigned int n;\n+\n+  /* If the program or coroutine is in the exception state then return the enumeration\n+   value representing the exception cause.  If it is not in the exception state then\n+   raises and exception (exException).  */\n+  e = RTExceptions_GetExceptionBlock ();\n+  n = RTExceptions_GetNumber (e);\n+  if (n == (UINT_MAX))\n+    {\n+      RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_exException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/M2EXCEPTION.mod\")), 47, 6, const_cast<void*> (reinterpret_cast<const void*>(\"M2Exception\")), const_cast<void*> (reinterpret_cast<const void*>(\"current coroutine is not in the exceptional execution state\")));\n+    }\n+  else\n+    {\n+      return (M2EXCEPTION_M2Exceptions) (n);\n+    }\n+  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/M2EXCEPTION.def\", 25, 1);\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" unsigned int M2EXCEPTION_IsM2Exception (void)\n+{\n+  RTExceptions_EHBlock e;\n+\n+  /* Returns TRUE if the program or coroutine is in the exception state.\n+   Returns FALSE if the program or coroutine is not in the exception state.  */\n+  e = RTExceptions_GetExceptionBlock ();\n+  return (RTExceptions_GetNumber (e)) != (UINT_MAX);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" void _M2_M2EXCEPTION_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+  RTExceptions_SetExceptionBlock (RTExceptions_InitExceptionBlock ());\n+}\n+\n+extern \"C\" void _M2_M2EXCEPTION_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "2e8680ccb960e79b164e0e54fa761256ac7618c1", "filename": "gcc/m2/mc-boot/GM2RTS.cc", "status": "added", "additions": 819, "deletions": 0, "changes": 819, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGM2RTS.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGM2RTS.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGM2RTS.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,819 @@\n+/* do not edit automatically generated by mc from M2RTS.  */\n+/* M2RTS.mod Implements the run time system facilities of Modula-2.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#   if !defined (TRUE)\n+#      define TRUE (1==1)\n+#   endif\n+\n+#   if !defined (FALSE)\n+#      define FALSE (1==0)\n+#   endif\n+\n+#   include \"GStorage.h\"\n+#if defined(__cplusplus)\n+#   undef NULL\n+#   define NULL 0\n+#endif\n+#define _M2RTS_H\n+#define _M2RTS_C\n+\n+#   include \"Glibc.h\"\n+#   include \"GNumberIO.h\"\n+#   include \"GStrLib.h\"\n+#   include \"GSYSTEM.h\"\n+#   include \"GASCII.h\"\n+#   include \"GStorage.h\"\n+#   include \"GRTExceptions.h\"\n+#   include \"GM2EXCEPTION.h\"\n+#   include \"GM2Dependent.h\"\n+\n+typedef struct M2RTS_ArgCVEnvP_p M2RTS_ArgCVEnvP;\n+\n+#   define stderrFd 2\n+typedef struct M2RTS_ProcedureList_r M2RTS_ProcedureList;\n+\n+typedef char *M2RTS_PtrToChar;\n+\n+typedef struct M2RTS__T1_r M2RTS__T1;\n+\n+typedef M2RTS__T1 *M2RTS_ProcedureChain;\n+\n+typedef void (*M2RTS_ArgCVEnvP_t) (int, void *, void *);\n+struct M2RTS_ArgCVEnvP_p { M2RTS_ArgCVEnvP_t proc; };\n+\n+struct M2RTS_ProcedureList_r {\n+                               M2RTS_ProcedureChain head;\n+                               M2RTS_ProcedureChain tail;\n+                             };\n+\n+struct M2RTS__T1_r {\n+                     PROC p;\n+                     M2RTS_ProcedureChain prev;\n+                     M2RTS_ProcedureChain next;\n+                   };\n+\n+static M2RTS_ProcedureList InitialProc;\n+static M2RTS_ProcedureList TerminateProc;\n+static int ExitValue;\n+static unsigned int isHalting;\n+static unsigned int CallExit;\n+static unsigned int Initialized;\n+\n+/*\n+   ConstructModules - resolve dependencies and then call each\n+                      module constructor in turn.\n+*/\n+\n+extern \"C\" void M2RTS_ConstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n+\n+/*\n+   DeconstructModules - resolve dependencies and then call each\n+                        module constructor in turn.\n+*/\n+\n+extern \"C\" void M2RTS_DeconstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp);\n+\n+/*\n+   RegisterModule - adds module name to the list of outstanding\n+                    modules which need to have their dependencies\n+                    explored to determine initialization order.\n+*/\n+\n+extern \"C\" void M2RTS_RegisterModule (void * name, void * libname, M2RTS_ArgCVEnvP init, M2RTS_ArgCVEnvP fini, PROC dependencies);\n+\n+/*\n+   RequestDependant - used to specify that modulename is dependant upon\n+                      module dependantmodule.\n+*/\n+\n+extern \"C\" void M2RTS_RequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname);\n+\n+/*\n+   InstallTerminationProcedure - installs a procedure, p, which will\n+                                 be called when the procedure\n+                                 ExecuteTerminationProcedures\n+                                 is invoked.  It returns TRUE if the\n+                                 procedure is installed.\n+*/\n+\n+extern \"C\" unsigned int M2RTS_InstallTerminationProcedure (PROC p);\n+\n+/*\n+   ExecuteInitialProcedures - executes the initial procedures installed by\n+                              InstallInitialProcedure.\n+*/\n+\n+extern \"C\" void M2RTS_ExecuteInitialProcedures (void);\n+\n+/*\n+   InstallInitialProcedure - installs a procedure to be executed just\n+                             before the BEGIN code section of the\n+                             main program module.\n+*/\n+\n+extern \"C\" unsigned int M2RTS_InstallInitialProcedure (PROC p);\n+\n+/*\n+   ExecuteTerminationProcedures - calls each installed termination procedure\n+                                  in reverse order.\n+*/\n+\n+extern \"C\" void M2RTS_ExecuteTerminationProcedures (void);\n+\n+/*\n+   Terminate - provides compatibility for pim.  It calls exit with\n+               the exitcode provided in a prior call to ExitOnHalt\n+               (or zero if ExitOnHalt was never called).  It does\n+               not call ExecuteTerminationProcedures.\n+*/\n+\n+extern \"C\" void M2RTS_Terminate (void) __attribute__ ((noreturn));\n+\n+/*\n+   HALT - terminate the current program.  The procedure\n+          ExecuteTerminationProcedures\n+          is called before the program is stopped.  The parameter\n+          exitcode is optional.  If the parameter is not supplied\n+          HALT will call libc 'abort', otherwise it will exit with\n+          the code supplied.  Supplying a parameter to HALT has the\n+          same effect as calling ExitOnHalt with the same code and\n+          then calling HALT with no parameter.\n+*/\n+\n+extern \"C\" void M2RTS_HALT (int exitcode) __attribute__ ((noreturn));\n+\n+/*\n+   Halt - provides a more user friendly version of HALT, which takes\n+          four parameters to aid debugging.  It writes an error message\n+          to stderr and calls exit (1).\n+*/\n+\n+extern \"C\" void M2RTS_Halt (const char *filename_, unsigned int _filename_high, unsigned int line, const char *function_, unsigned int _function_high, const char *description_, unsigned int _description_high) __attribute__ ((noreturn));\n+\n+/*\n+   HaltC - provides a more user friendly version of HALT, which takes\n+           four parameters to aid debugging.  It writes an error message\n+           to stderr and calls exit (1).\n+*/\n+\n+extern \"C\" void M2RTS_HaltC (void * filename, unsigned int line, void * function, void * description) __attribute__ ((noreturn));\n+\n+/*\n+   ExitOnHalt - if HALT is executed then call exit with the exit code, e.\n+*/\n+\n+extern \"C\" void M2RTS_ExitOnHalt (int e);\n+\n+/*\n+   ErrorMessage - emits an error message to stderr and then calls exit (1).\n+*/\n+\n+extern \"C\" void M2RTS_ErrorMessage (const char *message_, unsigned int _message_high, const char *filename_, unsigned int _filename_high, unsigned int line, const char *function_, unsigned int _function_high) __attribute__ ((noreturn));\n+\n+/*\n+   Length - returns the length of a string, a. This is called whenever\n+            the user calls LENGTH and the parameter cannot be calculated\n+            at compile time.\n+*/\n+\n+extern \"C\" unsigned int M2RTS_Length (const char *a_, unsigned int _a_high);\n+extern \"C\" void M2RTS_AssignmentException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_ReturnException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_IncException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_DecException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_InclException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_ExclException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_ShiftException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_RotateException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_StaticArraySubscriptException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_DynamicArraySubscriptException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_ForLoopBeginException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_ForLoopToException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_ForLoopEndException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_PointerNilException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_NoReturnException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_CaseException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_WholeNonPosDivException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_WholeNonPosModException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_WholeZeroDivException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_WholeZeroRemException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_WholeValueException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_RealValueException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_ParameterException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_NoException (void * filename, unsigned int line, unsigned int column, void * scope, void * message) __attribute__ ((noreturn));\n+\n+/*\n+   ExecuteReverse - execute the procedure associated with procptr\n+                    and then proceed to try and execute all previous\n+                    procedures in the chain.\n+*/\n+\n+static void ExecuteReverse (M2RTS_ProcedureChain procptr);\n+\n+/*\n+   AppendProc - append proc to the end of the procedure list\n+                defined by proclist.\n+*/\n+\n+static unsigned int AppendProc (M2RTS_ProcedureList *proclist, PROC proc);\n+\n+/*\n+   ErrorString - writes a string to stderr.\n+*/\n+\n+static void ErrorString (const char *a_, unsigned int _a_high);\n+\n+/*\n+   ErrorStringC - writes a string to stderr.\n+*/\n+\n+static void ErrorStringC (void * str);\n+\n+/*\n+   ErrorMessageC - emits an error message to stderr and then calls exit (1).\n+*/\n+\n+static void ErrorMessageC (void * message, void * filename, unsigned int line, void * function) __attribute__ ((noreturn));\n+\n+/*\n+   InitProcList - initialize the head and tail pointers to NIL.\n+*/\n+\n+static void InitProcList (M2RTS_ProcedureList *p);\n+\n+/*\n+   Init - initialize the initial, terminate procedure lists and booleans.\n+*/\n+\n+static void Init (void);\n+\n+/*\n+   CheckInitialized - checks to see if this module has been initialized\n+                      and if it has not it calls Init.  We need this\n+                      approach as this module is called by module ctors\n+                      before we reach main.\n+*/\n+\n+static void CheckInitialized (void);\n+\n+\n+/*\n+   ExecuteReverse - execute the procedure associated with procptr\n+                    and then proceed to try and execute all previous\n+                    procedures in the chain.\n+*/\n+\n+static void ExecuteReverse (M2RTS_ProcedureChain procptr)\n+{\n+  while (procptr != NULL)\n+    {\n+      (*procptr->p.proc) ();  /* Invoke the procedure.  */\n+      procptr = procptr->prev;  /* Invoke the procedure.  */\n+    }\n+}\n+\n+\n+/*\n+   AppendProc - append proc to the end of the procedure list\n+                defined by proclist.\n+*/\n+\n+static unsigned int AppendProc (M2RTS_ProcedureList *proclist, PROC proc)\n+{\n+  M2RTS_ProcedureChain pdes;\n+\n+  Storage_ALLOCATE ((void **) &pdes, sizeof (M2RTS__T1));\n+  pdes->p = proc;\n+  pdes->prev = (*proclist).tail;\n+  pdes->next = NULL;\n+  if ((*proclist).head == NULL)\n+    {\n+      (*proclist).head = pdes;\n+    }\n+  (*proclist).tail = pdes;\n+  return TRUE;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   ErrorString - writes a string to stderr.\n+*/\n+\n+static void ErrorString (const char *a_, unsigned int _a_high)\n+{\n+  int n;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  n = static_cast<int> (libc_write (stderrFd, &a, static_cast<size_t> (StrLib_StrLen ((const char *) a, _a_high))));\n+}\n+\n+\n+/*\n+   ErrorStringC - writes a string to stderr.\n+*/\n+\n+static void ErrorStringC (void * str)\n+{\n+  int len;\n+\n+  len = static_cast<int> (libc_write (stderrFd, str, libc_strlen (str)));\n+}\n+\n+\n+/*\n+   ErrorMessageC - emits an error message to stderr and then calls exit (1).\n+*/\n+\n+static void ErrorMessageC (void * message, void * filename, unsigned int line, void * function)\n+{\n+  typedef struct ErrorMessageC__T2_a ErrorMessageC__T2;\n+\n+  struct ErrorMessageC__T2_a { char array[10+1]; };\n+  ErrorMessageC__T2 buffer;\n+\n+  ErrorStringC (filename);\n+  ErrorString ((const char *) \":\", 1);\n+  NumberIO_CardToStr (line, 0, (char *) &buffer.array[0], 10);\n+  ErrorString ((const char *) &buffer.array[0], 10);\n+  ErrorString ((const char *) \":\", 1);\n+  if ((libc_strlen (function)) > 0)\n+    {\n+      ErrorString ((const char *) \"in \", 3);\n+      ErrorStringC (function);\n+      ErrorString ((const char *) \" has caused \", 12);\n+    }\n+  ErrorStringC (message);\n+  buffer.array[0] = ASCII_nl;\n+  buffer.array[1] = ASCII_nul;\n+  ErrorString ((const char *) &buffer.array[0], 10);\n+  libc_exit (1);\n+}\n+\n+\n+/*\n+   InitProcList - initialize the head and tail pointers to NIL.\n+*/\n+\n+static void InitProcList (M2RTS_ProcedureList *p)\n+{\n+  (*p).head = NULL;\n+  (*p).tail = NULL;\n+}\n+\n+\n+/*\n+   Init - initialize the initial, terminate procedure lists and booleans.\n+*/\n+\n+static void Init (void)\n+{\n+  InitProcList (&InitialProc);\n+  InitProcList (&TerminateProc);\n+  ExitValue = 0;\n+  isHalting = FALSE;\n+  CallExit = FALSE;  /* default by calling abort  */\n+}\n+\n+\n+/*\n+   CheckInitialized - checks to see if this module has been initialized\n+                      and if it has not it calls Init.  We need this\n+                      approach as this module is called by module ctors\n+                      before we reach main.\n+*/\n+\n+static void CheckInitialized (void)\n+{\n+  if (! Initialized)\n+    {\n+      Initialized = TRUE;\n+      Init ();\n+    }\n+}\n+\n+\n+/*\n+   ConstructModules - resolve dependencies and then call each\n+                      module constructor in turn.\n+*/\n+\n+extern \"C\" void M2RTS_ConstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp)\n+{\n+  M2Dependent_ConstructModules (applicationmodule, libname, argc, argv, envp);\n+}\n+\n+\n+/*\n+   DeconstructModules - resolve dependencies and then call each\n+                        module constructor in turn.\n+*/\n+\n+extern \"C\" void M2RTS_DeconstructModules (void * applicationmodule, void * libname, int argc, void * argv, void * envp)\n+{\n+  M2Dependent_DeconstructModules (applicationmodule, libname, argc, argv, envp);\n+}\n+\n+\n+/*\n+   RegisterModule - adds module name to the list of outstanding\n+                    modules which need to have their dependencies\n+                    explored to determine initialization order.\n+*/\n+\n+extern \"C\" void M2RTS_RegisterModule (void * name, void * libname, M2RTS_ArgCVEnvP init, M2RTS_ArgCVEnvP fini, PROC dependencies)\n+{\n+  M2Dependent_RegisterModule (name, libname, (M2Dependent_ArgCVEnvP) {(M2Dependent_ArgCVEnvP_t) init.proc}, (M2Dependent_ArgCVEnvP) {(M2Dependent_ArgCVEnvP_t) fini.proc}, dependencies);\n+}\n+\n+\n+/*\n+   RequestDependant - used to specify that modulename is dependant upon\n+                      module dependantmodule.\n+*/\n+\n+extern \"C\" void M2RTS_RequestDependant (void * modulename, void * libname, void * dependantmodule, void * dependantlibname)\n+{\n+  M2Dependent_RequestDependant (modulename, libname, dependantmodule, dependantlibname);\n+}\n+\n+\n+/*\n+   InstallTerminationProcedure - installs a procedure, p, which will\n+                                 be called when the procedure\n+                                 ExecuteTerminationProcedures\n+                                 is invoked.  It returns TRUE if the\n+                                 procedure is installed.\n+*/\n+\n+extern \"C\" unsigned int M2RTS_InstallTerminationProcedure (PROC p)\n+{\n+  return AppendProc (&TerminateProc, p);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   ExecuteInitialProcedures - executes the initial procedures installed by\n+                              InstallInitialProcedure.\n+*/\n+\n+extern \"C\" void M2RTS_ExecuteInitialProcedures (void)\n+{\n+  ExecuteReverse (InitialProc.tail);\n+}\n+\n+\n+/*\n+   InstallInitialProcedure - installs a procedure to be executed just\n+                             before the BEGIN code section of the\n+                             main program module.\n+*/\n+\n+extern \"C\" unsigned int M2RTS_InstallInitialProcedure (PROC p)\n+{\n+  return AppendProc (&InitialProc, p);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   ExecuteTerminationProcedures - calls each installed termination procedure\n+                                  in reverse order.\n+*/\n+\n+extern \"C\" void M2RTS_ExecuteTerminationProcedures (void)\n+{\n+  ExecuteReverse (TerminateProc.tail);\n+}\n+\n+\n+/*\n+   Terminate - provides compatibility for pim.  It calls exit with\n+               the exitcode provided in a prior call to ExitOnHalt\n+               (or zero if ExitOnHalt was never called).  It does\n+               not call ExecuteTerminationProcedures.\n+*/\n+\n+extern \"C\" void M2RTS_Terminate (void)\n+{\n+  libc_exit (ExitValue);\n+}\n+\n+\n+/*\n+   HALT - terminate the current program.  The procedure\n+          ExecuteTerminationProcedures\n+          is called before the program is stopped.  The parameter\n+          exitcode is optional.  If the parameter is not supplied\n+          HALT will call libc 'abort', otherwise it will exit with\n+          the code supplied.  Supplying a parameter to HALT has the\n+          same effect as calling ExitOnHalt with the same code and\n+          then calling HALT with no parameter.\n+*/\n+\n+extern \"C\" void M2RTS_HALT (int exitcode)\n+{\n+  if (exitcode != -1)\n+    {\n+      CallExit = TRUE;\n+      ExitValue = exitcode;\n+    }\n+  if (isHalting)\n+    {\n+      /* double HALT found  */\n+      libc_exit (-1);\n+    }\n+  else\n+    {\n+      isHalting = TRUE;\n+      M2RTS_ExecuteTerminationProcedures ();\n+    }\n+  if (CallExit)\n+    {\n+      libc_exit (ExitValue);\n+    }\n+  else\n+    {\n+      libc_abort ();\n+    }\n+}\n+\n+\n+/*\n+   Halt - provides a more user friendly version of HALT, which takes\n+          four parameters to aid debugging.  It writes an error message\n+          to stderr and calls exit (1).\n+*/\n+\n+extern \"C\" void M2RTS_Halt (const char *filename_, unsigned int _filename_high, unsigned int line, const char *function_, unsigned int _function_high, const char *description_, unsigned int _description_high)\n+{\n+  char filename[_filename_high+1];\n+  char function[_function_high+1];\n+  char description[_description_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (filename, filename_, _filename_high+1);\n+  memcpy (function, function_, _function_high+1);\n+  memcpy (description, description_, _description_high+1);\n+\n+  M2RTS_ErrorMessage ((const char *) description, _description_high, (const char *) filename, _filename_high, line, (const char *) function, _function_high);\n+}\n+\n+\n+/*\n+   HaltC - provides a more user friendly version of HALT, which takes\n+           four parameters to aid debugging.  It writes an error message\n+           to stderr and calls exit (1).\n+*/\n+\n+extern \"C\" void M2RTS_HaltC (void * filename, unsigned int line, void * function, void * description)\n+{\n+  ErrorMessageC (description, filename, line, function);\n+}\n+\n+\n+/*\n+   ExitOnHalt - if HALT is executed then call exit with the exit code, e.\n+*/\n+\n+extern \"C\" void M2RTS_ExitOnHalt (int e)\n+{\n+  ExitValue = e;\n+  CallExit = TRUE;\n+}\n+\n+\n+/*\n+   ErrorMessage - emits an error message to stderr and then calls exit (1).\n+*/\n+\n+extern \"C\" void M2RTS_ErrorMessage (const char *message_, unsigned int _message_high, const char *filename_, unsigned int _filename_high, unsigned int line, const char *function_, unsigned int _function_high)\n+{\n+  typedef struct ErrorMessage__T3_a ErrorMessage__T3;\n+\n+  struct ErrorMessage__T3_a { char array[10+1]; };\n+  ErrorMessage__T3 buffer;\n+  char message[_message_high+1];\n+  char filename[_filename_high+1];\n+  char function[_function_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (message, message_, _message_high+1);\n+  memcpy (filename, filename_, _filename_high+1);\n+  memcpy (function, function_, _function_high+1);\n+\n+  ErrorString ((const char *) filename, _filename_high);\n+  ErrorString ((const char *) \":\", 1);\n+  NumberIO_CardToStr (line, 0, (char *) &buffer.array[0], 10);\n+  ErrorString ((const char *) &buffer.array[0], 10);\n+  ErrorString ((const char *) \":\", 1);\n+  if (! (StrLib_StrEqual ((const char *) function, _function_high, (const char *) \"\", 0)))\n+    {\n+      ErrorString ((const char *) \"in \", 3);\n+      ErrorString ((const char *) function, _function_high);\n+      ErrorString ((const char *) \" has caused \", 12);\n+    }\n+  ErrorString ((const char *) message, _message_high);\n+  buffer.array[0] = ASCII_nl;\n+  buffer.array[1] = ASCII_nul;\n+  ErrorString ((const char *) &buffer.array[0], 10);\n+  libc_exit (1);\n+}\n+\n+\n+/*\n+   Length - returns the length of a string, a. This is called whenever\n+            the user calls LENGTH and the parameter cannot be calculated\n+            at compile time.\n+*/\n+\n+extern \"C\" unsigned int M2RTS_Length (const char *a_, unsigned int _a_high)\n+{\n+  unsigned int l;\n+  unsigned int h;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  l = 0;\n+  h = _a_high;\n+  while ((l <= h) && (a[l] != ASCII_nul))\n+    {\n+      l += 1;\n+    }\n+  return l;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" void M2RTS_AssignmentException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  /* \n+   The following are the runtime exception handler routines.\n+  */\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_rangeException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_ReturnException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_rangeException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_IncException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_rangeException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_DecException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_rangeException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_InclException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_rangeException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_ExclException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_rangeException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_ShiftException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_rangeException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_RotateException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_rangeException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_StaticArraySubscriptException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_indexException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_DynamicArraySubscriptException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_indexException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_ForLoopBeginException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_rangeException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_ForLoopToException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_rangeException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_ForLoopEndException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_rangeException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_PointerNilException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_invalidLocation)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_NoReturnException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_functionException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_CaseException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_caseSelectException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_WholeNonPosDivException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_wholeDivException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_WholeNonPosModException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_wholeDivException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_WholeZeroDivException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_wholeDivException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_WholeZeroRemException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_wholeDivException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_WholeValueException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_wholeValueException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_RealValueException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_realValueException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_ParameterException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_rangeException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void M2RTS_NoException (void * filename, unsigned int line, unsigned int column, void * scope, void * message)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_exException)), filename, line, column, scope, message);\n+}\n+\n+extern \"C\" void _M2_M2RTS_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+  CheckInitialized ();\n+}\n+\n+extern \"C\" void _M2_M2RTS_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "a80e00ecec8535f4ec7dacc69045576b3e014a64", "filename": "gcc/m2/mc-boot/GMemUtils.cc", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGMemUtils.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGMemUtils.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGMemUtils.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,126 @@\n+/* do not edit automatically generated by mc from MemUtils.  */\n+/* MemUtils.mod provides some basic memory utilities.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#define _MemUtils_H\n+#define _MemUtils_C\n+\n+#   include \"GSYSTEM.h\"\n+\n+\n+/*\n+   MemCopy - copys a region of memory to the required destination.\n+*/\n+\n+extern \"C\" void MemUtils_MemCopy (void * from, unsigned int length, void * to);\n+\n+/*\n+   MemZero - sets a region of memory: a..a+length to zero.\n+*/\n+\n+extern \"C\" void MemUtils_MemZero (void * a, unsigned int length);\n+\n+\n+/*\n+   MemCopy - copys a region of memory to the required destination.\n+*/\n+\n+extern \"C\" void MemUtils_MemCopy (void * from, unsigned int length, void * to)\n+{\n+  typedef unsigned int *MemCopy__T1;\n+\n+  typedef unsigned char *MemCopy__T2;\n+\n+  MemCopy__T1 pwb;\n+  MemCopy__T1 pwa;\n+  MemCopy__T2 pbb;\n+  MemCopy__T2 pba;\n+\n+  while (length >= sizeof (unsigned int ))\n+    {\n+      pwa = static_cast<MemCopy__T1> (from);\n+      pwb = static_cast<MemCopy__T1> (to);\n+      (*pwb) = (*pwa);\n+      from = reinterpret_cast<void *> (reinterpret_cast<char *> (from)+sizeof (unsigned int ));\n+      to = reinterpret_cast<void *> (reinterpret_cast<char *> (to)+sizeof (unsigned int ));\n+      length -= sizeof (unsigned int );\n+    }\n+  while (length > 0)\n+    {\n+      pba = static_cast<MemCopy__T2> (from);\n+      pbb = static_cast<MemCopy__T2> (to);\n+      (*pbb) = (*pba);\n+      from = reinterpret_cast<void *> (reinterpret_cast<char *> (from)+sizeof (unsigned char ));\n+      to = reinterpret_cast<void *> (reinterpret_cast<char *> (to)+sizeof (unsigned char ));\n+      length -= sizeof (unsigned char );\n+    }\n+}\n+\n+\n+/*\n+   MemZero - sets a region of memory: a..a+length to zero.\n+*/\n+\n+extern \"C\" void MemUtils_MemZero (void * a, unsigned int length)\n+{\n+  typedef unsigned int *MemZero__T3;\n+\n+  typedef unsigned char *MemZero__T4;\n+\n+  MemZero__T3 pwa;\n+  MemZero__T4 pba;\n+\n+  pwa = static_cast<MemZero__T3> (a);\n+  while (length >= sizeof (unsigned int ))\n+    {\n+      (*pwa) = (unsigned int ) (0);\n+      pwa += sizeof (unsigned int );\n+      length -= sizeof (unsigned int );\n+    }\n+  pba = static_cast<MemZero__T4> ((void *) (pwa));\n+  while (length >= sizeof (unsigned char ))\n+    {\n+      (*pba) = (unsigned char ) (0);\n+      pba += sizeof (unsigned char );\n+      length -= sizeof (unsigned char );\n+    }\n+}\n+\n+extern \"C\" void _M2_MemUtils_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}\n+\n+extern \"C\" void _M2_MemUtils_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "53bac45552c01eb1b16f8e141e9c85e8b0222ca6", "filename": "gcc/m2/mc-boot/GNumberIO.cc", "status": "added", "additions": 776, "deletions": 0, "changes": 776, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGNumberIO.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGNumberIO.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGNumberIO.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,776 @@\n+/* do not edit automatically generated by mc from NumberIO.  */\n+/* NumberIO.mod provides conversion of ordinal numbers.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#   if !defined (TRUE)\n+#      define TRUE (1==1)\n+#   endif\n+\n+#   if !defined (FALSE)\n+#      define FALSE (1==0)\n+#   endif\n+\n+#define _NumberIO_H\n+#define _NumberIO_C\n+\n+#   include \"GASCII.h\"\n+#   include \"GStrIO.h\"\n+#   include \"GStrLib.h\"\n+#   include \"GM2RTS.h\"\n+\n+#   define MaxLineLength 79\n+#   define MaxDigits 20\n+#   define MaxHexDigits 20\n+#   define MaxOctDigits 40\n+#   define MaxBits 64\n+extern \"C\" void NumberIO_ReadCard (unsigned int *x);\n+extern \"C\" void NumberIO_WriteCard (unsigned int x, unsigned int n);\n+extern \"C\" void NumberIO_ReadHex (unsigned int *x);\n+extern \"C\" void NumberIO_WriteHex (unsigned int x, unsigned int n);\n+extern \"C\" void NumberIO_ReadInt (int *x);\n+extern \"C\" void NumberIO_WriteInt (int x, unsigned int n);\n+extern \"C\" void NumberIO_CardToStr (unsigned int x, unsigned int n, char *a, unsigned int _a_high);\n+extern \"C\" void NumberIO_StrToCard (const char *a_, unsigned int _a_high, unsigned int *x);\n+extern \"C\" void NumberIO_HexToStr (unsigned int x, unsigned int n, char *a, unsigned int _a_high);\n+extern \"C\" void NumberIO_StrToHex (const char *a_, unsigned int _a_high, unsigned int *x);\n+extern \"C\" void NumberIO_IntToStr (int x, unsigned int n, char *a, unsigned int _a_high);\n+extern \"C\" void NumberIO_StrToInt (const char *a_, unsigned int _a_high, int *x);\n+extern \"C\" void NumberIO_ReadOct (unsigned int *x);\n+extern \"C\" void NumberIO_WriteOct (unsigned int x, unsigned int n);\n+extern \"C\" void NumberIO_OctToStr (unsigned int x, unsigned int n, char *a, unsigned int _a_high);\n+extern \"C\" void NumberIO_StrToOct (const char *a_, unsigned int _a_high, unsigned int *x);\n+extern \"C\" void NumberIO_ReadBin (unsigned int *x);\n+extern \"C\" void NumberIO_WriteBin (unsigned int x, unsigned int n);\n+extern \"C\" void NumberIO_BinToStr (unsigned int x, unsigned int n, char *a, unsigned int _a_high);\n+extern \"C\" void NumberIO_StrToBin (const char *a_, unsigned int _a_high, unsigned int *x);\n+extern \"C\" void NumberIO_StrToBinInt (const char *a_, unsigned int _a_high, int *x);\n+extern \"C\" void NumberIO_StrToHexInt (const char *a_, unsigned int _a_high, int *x);\n+extern \"C\" void NumberIO_StrToOctInt (const char *a_, unsigned int _a_high, int *x);\n+\n+extern \"C\" void NumberIO_ReadCard (unsigned int *x)\n+{\n+  typedef struct ReadCard__T1_a ReadCard__T1;\n+\n+  struct ReadCard__T1_a { char array[MaxLineLength+1]; };\n+  ReadCard__T1 a;\n+\n+  StrIO_ReadString ((char *) &a.array[0], MaxLineLength);\n+  NumberIO_StrToCard ((const char *) &a.array[0], MaxLineLength, x);\n+}\n+\n+extern \"C\" void NumberIO_WriteCard (unsigned int x, unsigned int n)\n+{\n+  typedef struct WriteCard__T2_a WriteCard__T2;\n+\n+  struct WriteCard__T2_a { char array[MaxLineLength+1]; };\n+  WriteCard__T2 a;\n+\n+  NumberIO_CardToStr (x, n, (char *) &a.array[0], MaxLineLength);\n+  StrIO_WriteString ((const char *) &a.array[0], MaxLineLength);\n+}\n+\n+extern \"C\" void NumberIO_ReadHex (unsigned int *x)\n+{\n+  typedef struct ReadHex__T3_a ReadHex__T3;\n+\n+  struct ReadHex__T3_a { char array[MaxLineLength+1]; };\n+  ReadHex__T3 a;\n+\n+  StrIO_ReadString ((char *) &a.array[0], MaxLineLength);\n+  NumberIO_StrToHex ((const char *) &a.array[0], MaxLineLength, x);\n+}\n+\n+extern \"C\" void NumberIO_WriteHex (unsigned int x, unsigned int n)\n+{\n+  typedef struct WriteHex__T4_a WriteHex__T4;\n+\n+  struct WriteHex__T4_a { char array[MaxLineLength+1]; };\n+  WriteHex__T4 a;\n+\n+  NumberIO_HexToStr (x, n, (char *) &a.array[0], MaxLineLength);\n+  StrIO_WriteString ((const char *) &a.array[0], MaxLineLength);\n+}\n+\n+extern \"C\" void NumberIO_ReadInt (int *x)\n+{\n+  typedef struct ReadInt__T5_a ReadInt__T5;\n+\n+  struct ReadInt__T5_a { char array[MaxLineLength+1]; };\n+  ReadInt__T5 a;\n+\n+  StrIO_ReadString ((char *) &a.array[0], MaxLineLength);\n+  NumberIO_StrToInt ((const char *) &a.array[0], MaxLineLength, x);\n+}\n+\n+extern \"C\" void NumberIO_WriteInt (int x, unsigned int n)\n+{\n+  typedef struct WriteInt__T6_a WriteInt__T6;\n+\n+  struct WriteInt__T6_a { char array[MaxLineLength+1]; };\n+  WriteInt__T6 a;\n+\n+  NumberIO_IntToStr (x, n, (char *) &a.array[0], MaxLineLength);\n+  StrIO_WriteString ((const char *) &a.array[0], MaxLineLength);\n+}\n+\n+extern \"C\" void NumberIO_CardToStr (unsigned int x, unsigned int n, char *a, unsigned int _a_high)\n+{\n+  typedef struct CardToStr__T7_a CardToStr__T7;\n+\n+  struct CardToStr__T7_a { unsigned int array[MaxDigits-1+1]; };\n+  unsigned int i;\n+  unsigned int j;\n+  unsigned int Higha;\n+  CardToStr__T7 buf;\n+\n+  i = 0;\n+  do {\n+    i += 1;\n+    if (i > MaxDigits)\n+      {\n+        StrIO_WriteString ((const char *) \"NumberIO - increase MaxDigits\", 29);\n+        StrIO_WriteLn ();\n+        M2RTS_HALT (-1);\n+        __builtin_unreachable ();\n+      }\n+    buf.array[i-1] = x % 10;\n+    x = x / 10;\n+  } while (! (x == 0));\n+  j = 0;\n+  Higha = _a_high;\n+  while ((n > i) && (j <= Higha))\n+    {\n+      a[j] = ' ';\n+      j += 1;\n+      n -= 1;\n+    }\n+  while ((i > 0) && (j <= Higha))\n+    {\n+      a[j] = ((char) (buf.array[i-1]+ ((unsigned int) ('0'))));\n+      j += 1;\n+      i -= 1;\n+    }\n+  if (j <= Higha)\n+    {\n+      a[j] = ASCII_nul;\n+    }\n+}\n+\n+extern \"C\" void NumberIO_StrToCard (const char *a_, unsigned int _a_high, unsigned int *x)\n+{\n+  unsigned int i;\n+  unsigned int ok;\n+  unsigned int higha;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  StrLib_StrRemoveWhitePrefix ((const char *) a, _a_high, (char *) a, _a_high);\n+  higha = StrLib_StrLen ((const char *) a, _a_high);\n+  i = 0;\n+  ok = TRUE;\n+  while (ok)\n+    {\n+      if (i < higha)\n+        {\n+          if ((a[i] < '0') || (a[i] > '9'))\n+            {\n+              i += 1;\n+            }\n+          else\n+            {\n+              ok = FALSE;\n+            }\n+        }\n+      else\n+        {\n+          ok = FALSE;\n+        }\n+    }\n+  (*x) = 0;\n+  if (i < higha)\n+    {\n+      ok = TRUE;\n+      do {\n+        (*x) = (10*(*x))+( ((unsigned int) (a[i]))- ((unsigned int) ('0')));\n+        if (i < higha)\n+          {\n+            /* avoid dangling else.  */\n+            i += 1;\n+            if ((a[i] < '0') || (a[i] > '9'))\n+              {\n+                ok = FALSE;\n+              }\n+          }\n+        else\n+          {\n+            ok = FALSE;\n+          }\n+      } while (! (! ok));\n+    }\n+}\n+\n+extern \"C\" void NumberIO_HexToStr (unsigned int x, unsigned int n, char *a, unsigned int _a_high)\n+{\n+  typedef struct HexToStr__T8_a HexToStr__T8;\n+\n+  struct HexToStr__T8_a { unsigned int array[MaxHexDigits-1+1]; };\n+  unsigned int i;\n+  unsigned int j;\n+  unsigned int Higha;\n+  HexToStr__T8 buf;\n+\n+  i = 0;\n+  do {\n+    i += 1;\n+    if (i > MaxHexDigits)\n+      {\n+        StrIO_WriteString ((const char *) \"NumberIO - increase MaxDigits\", 29);\n+        StrIO_WriteLn ();\n+        M2RTS_HALT (-1);\n+        __builtin_unreachable ();\n+      }\n+    buf.array[i-1] = x % 0x010;\n+    x = x / 0x010;\n+  } while (! (x == 0));\n+  j = 0;\n+  Higha = _a_high;\n+  while ((n > i) && (j <= Higha))\n+    {\n+      a[j] = '0';\n+      j += 1;\n+      n -= 1;\n+    }\n+  while ((i != 0) && (j <= Higha))\n+    {\n+      if (buf.array[i-1] < 10)\n+        {\n+          a[j] = ((char) (buf.array[i-1]+ ((unsigned int) ('0'))));\n+        }\n+      else\n+        {\n+          a[j] = ((char) ((buf.array[i-1]+ ((unsigned int) ('A')))-10));\n+        }\n+      j += 1;\n+      i -= 1;\n+    }\n+  if (j <= Higha)\n+    {\n+      a[j] = ASCII_nul;\n+    }\n+}\n+\n+extern \"C\" void NumberIO_StrToHex (const char *a_, unsigned int _a_high, unsigned int *x)\n+{\n+  int i;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  NumberIO_StrToHexInt ((const char *) a, _a_high, &i);\n+  (*x) = (unsigned int ) (i);\n+}\n+\n+extern \"C\" void NumberIO_IntToStr (int x, unsigned int n, char *a, unsigned int _a_high)\n+{\n+  typedef struct IntToStr__T9_a IntToStr__T9;\n+\n+  struct IntToStr__T9_a { unsigned int array[MaxDigits-1+1]; };\n+  unsigned int i;\n+  unsigned int j;\n+  unsigned int c;\n+  unsigned int Higha;\n+  IntToStr__T9 buf;\n+  unsigned int Negative;\n+\n+  if (x < 0)\n+    {\n+      /* avoid dangling else.  */\n+      Negative = TRUE;\n+      c = ((unsigned int ) (abs (x+1)))+1;\n+      if (n > 0)\n+        {\n+          n -= 1;\n+        }\n+    }\n+  else\n+    {\n+      c = x;\n+      Negative = FALSE;\n+    }\n+  i = 0;\n+  do {\n+    i += 1;\n+    if (i > MaxDigits)\n+      {\n+        StrIO_WriteString ((const char *) \"NumberIO - increase MaxDigits\", 29);\n+        StrIO_WriteLn ();\n+        M2RTS_HALT (-1);\n+        __builtin_unreachable ();\n+      }\n+    buf.array[i-1] = c % 10;\n+    c = c / 10;\n+  } while (! (c == 0));\n+  j = 0;\n+  Higha = _a_high;\n+  while ((n > i) && (j <= Higha))\n+    {\n+      a[j] = ' ';\n+      j += 1;\n+      n -= 1;\n+    }\n+  if (Negative)\n+    {\n+      a[j] = '-';\n+      j += 1;\n+    }\n+  while ((i != 0) && (j <= Higha))\n+    {\n+      a[j] = ((char) (buf.array[i-1]+ ((unsigned int) ('0'))));\n+      j += 1;\n+      i -= 1;\n+    }\n+  if (j <= Higha)\n+    {\n+      a[j] = ASCII_nul;\n+    }\n+}\n+\n+extern \"C\" void NumberIO_StrToInt (const char *a_, unsigned int _a_high, int *x)\n+{\n+  unsigned int i;\n+  unsigned int ok;\n+  unsigned int Negative;\n+  unsigned int higha;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  StrLib_StrRemoveWhitePrefix ((const char *) a, _a_high, (char *) a, _a_high);\n+  higha = StrLib_StrLen ((const char *) a, _a_high);\n+  i = 0;\n+  Negative = FALSE;\n+  ok = TRUE;\n+  while (ok)\n+    {\n+      if (i < higha)\n+        {\n+          if (a[i] == '-')\n+            {\n+              i += 1;\n+              Negative = ! Negative;\n+            }\n+          else if ((a[i] < '0') || (a[i] > '9'))\n+            {\n+              /* avoid dangling else.  */\n+              i += 1;\n+            }\n+          else\n+            {\n+              /* avoid dangling else.  */\n+              ok = FALSE;\n+            }\n+        }\n+      else\n+        {\n+          ok = FALSE;\n+        }\n+    }\n+  (*x) = 0;\n+  if (i < higha)\n+    {\n+      ok = TRUE;\n+      do {\n+        if (Negative)\n+          {\n+            (*x) = (10*(*x))-((int ) ( ((unsigned int) (a[i]))- ((unsigned int) ('0'))));\n+          }\n+        else\n+          {\n+            (*x) = (10*(*x))+((int ) ( ((unsigned int) (a[i]))- ((unsigned int) ('0'))));\n+          }\n+        if (i < higha)\n+          {\n+            /* avoid dangling else.  */\n+            i += 1;\n+            if ((a[i] < '0') || (a[i] > '9'))\n+              {\n+                ok = FALSE;\n+              }\n+          }\n+        else\n+          {\n+            ok = FALSE;\n+          }\n+      } while (! (! ok));\n+    }\n+}\n+\n+extern \"C\" void NumberIO_ReadOct (unsigned int *x)\n+{\n+  typedef struct ReadOct__T10_a ReadOct__T10;\n+\n+  struct ReadOct__T10_a { char array[MaxLineLength+1]; };\n+  ReadOct__T10 a;\n+\n+  StrIO_ReadString ((char *) &a.array[0], MaxLineLength);\n+  NumberIO_StrToOct ((const char *) &a.array[0], MaxLineLength, x);\n+}\n+\n+extern \"C\" void NumberIO_WriteOct (unsigned int x, unsigned int n)\n+{\n+  typedef struct WriteOct__T11_a WriteOct__T11;\n+\n+  struct WriteOct__T11_a { char array[MaxLineLength+1]; };\n+  WriteOct__T11 a;\n+\n+  NumberIO_OctToStr (x, n, (char *) &a.array[0], MaxLineLength);\n+  StrIO_WriteString ((const char *) &a.array[0], MaxLineLength);\n+}\n+\n+extern \"C\" void NumberIO_OctToStr (unsigned int x, unsigned int n, char *a, unsigned int _a_high)\n+{\n+  typedef struct OctToStr__T12_a OctToStr__T12;\n+\n+  struct OctToStr__T12_a { unsigned int array[MaxOctDigits-1+1]; };\n+  unsigned int i;\n+  unsigned int j;\n+  unsigned int Higha;\n+  OctToStr__T12 buf;\n+\n+  i = 0;\n+  do {\n+    i += 1;\n+    if (i > MaxOctDigits)\n+      {\n+        StrIO_WriteString ((const char *) \"NumberIO - increase MaxDigits\", 29);\n+        StrIO_WriteLn ();\n+        M2RTS_HALT (-1);\n+        __builtin_unreachable ();\n+      }\n+    buf.array[i-1] = x % 8;\n+    x = x / 8;\n+  } while (! (x == 0));\n+  j = 0;\n+  Higha = _a_high;\n+  while ((n > i) && (j <= Higha))\n+    {\n+      a[j] = ' ';\n+      j += 1;\n+      n -= 1;\n+    }\n+  while ((i > 0) && (j <= Higha))\n+    {\n+      a[j] = ((char) (buf.array[i-1]+ ((unsigned int) ('0'))));\n+      j += 1;\n+      i -= 1;\n+    }\n+  if (j <= Higha)\n+    {\n+      a[j] = ASCII_nul;\n+    }\n+}\n+\n+extern \"C\" void NumberIO_StrToOct (const char *a_, unsigned int _a_high, unsigned int *x)\n+{\n+  int i;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  NumberIO_StrToOctInt ((const char *) a, _a_high, &i);\n+  (*x) = (unsigned int ) (i);\n+}\n+\n+extern \"C\" void NumberIO_ReadBin (unsigned int *x)\n+{\n+  typedef struct ReadBin__T13_a ReadBin__T13;\n+\n+  struct ReadBin__T13_a { char array[MaxLineLength+1]; };\n+  ReadBin__T13 a;\n+\n+  StrIO_ReadString ((char *) &a.array[0], MaxLineLength);\n+  NumberIO_StrToBin ((const char *) &a.array[0], MaxLineLength, x);\n+}\n+\n+extern \"C\" void NumberIO_WriteBin (unsigned int x, unsigned int n)\n+{\n+  typedef struct WriteBin__T14_a WriteBin__T14;\n+\n+  struct WriteBin__T14_a { char array[MaxLineLength+1]; };\n+  WriteBin__T14 a;\n+\n+  NumberIO_BinToStr (x, n, (char *) &a.array[0], MaxLineLength);\n+  StrIO_WriteString ((const char *) &a.array[0], MaxLineLength);\n+}\n+\n+extern \"C\" void NumberIO_BinToStr (unsigned int x, unsigned int n, char *a, unsigned int _a_high)\n+{\n+  typedef struct BinToStr__T15_a BinToStr__T15;\n+\n+  struct BinToStr__T15_a { unsigned int array[MaxBits-1+1]; };\n+  unsigned int i;\n+  unsigned int j;\n+  unsigned int Higha;\n+  BinToStr__T15 buf;\n+\n+  i = 0;\n+  do {\n+    i += 1;\n+    if (i > MaxBits)\n+      {\n+        StrIO_WriteString ((const char *) \"NumberIO - increase MaxBits\", 27);\n+        StrIO_WriteLn ();\n+        M2RTS_HALT (-1);\n+        __builtin_unreachable ();\n+      }\n+    buf.array[i-1] = x % 2;\n+    x = x / 2;\n+  } while (! (x == 0));\n+  j = 0;\n+  Higha = _a_high;\n+  while ((n > i) && (j <= Higha))\n+    {\n+      a[j] = ' ';\n+      j += 1;\n+      n -= 1;\n+    }\n+  while ((i > 0) && (j <= Higha))\n+    {\n+      a[j] = ((char) (buf.array[i-1]+ ((unsigned int) ('0'))));\n+      j += 1;\n+      i -= 1;\n+    }\n+  if (j <= Higha)\n+    {\n+      a[j] = ASCII_nul;\n+    }\n+}\n+\n+extern \"C\" void NumberIO_StrToBin (const char *a_, unsigned int _a_high, unsigned int *x)\n+{\n+  int i;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  NumberIO_StrToBinInt ((const char *) a, _a_high, &i);\n+  (*x) = (unsigned int ) (i);\n+}\n+\n+extern \"C\" void NumberIO_StrToBinInt (const char *a_, unsigned int _a_high, int *x)\n+{\n+  unsigned int i;\n+  unsigned int ok;\n+  unsigned int higha;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  StrLib_StrRemoveWhitePrefix ((const char *) a, _a_high, (char *) a, _a_high);\n+  higha = StrLib_StrLen ((const char *) a, _a_high);\n+  i = 0;\n+  ok = TRUE;\n+  while (ok)\n+    {\n+      if (i < higha)\n+        {\n+          if ((a[i] < '0') || (a[i] > '1'))\n+            {\n+              i += 1;\n+            }\n+          else\n+            {\n+              ok = FALSE;\n+            }\n+        }\n+      else\n+        {\n+          ok = FALSE;\n+        }\n+    }\n+  (*x) = 0;\n+  if (i < higha)\n+    {\n+      ok = TRUE;\n+      do {\n+        (*x) = (2*(*x))+((int ) ( ((unsigned int) (a[i]))- ((unsigned int) ('0'))));\n+        if (i < higha)\n+          {\n+            /* avoid dangling else.  */\n+            i += 1;\n+            if ((a[i] < '0') || (a[i] > '1'))\n+              {\n+                ok = FALSE;\n+              }\n+          }\n+        else\n+          {\n+            ok = FALSE;\n+          }\n+      } while (! (! ok));\n+    }\n+}\n+\n+extern \"C\" void NumberIO_StrToHexInt (const char *a_, unsigned int _a_high, int *x)\n+{\n+  unsigned int i;\n+  unsigned int ok;\n+  unsigned int higha;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  StrLib_StrRemoveWhitePrefix ((const char *) a, _a_high, (char *) a, _a_high);\n+  higha = StrLib_StrLen ((const char *) a, _a_high);\n+  i = 0;\n+  ok = TRUE;\n+  while (ok)\n+    {\n+      if (i < higha)\n+        {\n+          if (((a[i] >= '0') && (a[i] <= '9')) || ((a[i] >= 'A') && (a[i] <= 'F')))\n+            {\n+              ok = FALSE;\n+            }\n+          else\n+            {\n+              i += 1;\n+            }\n+        }\n+      else\n+        {\n+          ok = FALSE;\n+        }\n+    }\n+  (*x) = 0;\n+  if (i < higha)\n+    {\n+      ok = TRUE;\n+      do {\n+        if ((a[i] >= '0') && (a[i] <= '9'))\n+          {\n+            (*x) = (0x010*(*x))+((int ) ( ((unsigned int) (a[i]))- ((unsigned int) ('0'))));\n+          }\n+        else if ((a[i] >= 'A') && (a[i] <= 'F'))\n+          {\n+            /* avoid dangling else.  */\n+            (*x) = (0x010*(*x))+((int ) (( ((unsigned int) (a[i]))- ((unsigned int) ('A')))+10));\n+          }\n+        if (i < higha)\n+          {\n+            /* avoid dangling else.  */\n+            i += 1;\n+            if (((a[i] < '0') || (a[i] > '9')) && ((a[i] < 'A') || (a[i] > 'F')))\n+              {\n+                ok = FALSE;\n+              }\n+          }\n+        else\n+          {\n+            ok = FALSE;\n+          }\n+      } while (! (! ok));\n+    }\n+}\n+\n+extern \"C\" void NumberIO_StrToOctInt (const char *a_, unsigned int _a_high, int *x)\n+{\n+  unsigned int i;\n+  unsigned int ok;\n+  unsigned int higha;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  StrLib_StrRemoveWhitePrefix ((const char *) a, _a_high, (char *) a, _a_high);\n+  higha = StrLib_StrLen ((const char *) a, _a_high);\n+  i = 0;\n+  ok = TRUE;\n+  while (ok)\n+    {\n+      if (i < higha)\n+        {\n+          if ((a[i] < '0') || (a[i] > '7'))\n+            {\n+              i += 1;\n+            }\n+          else\n+            {\n+              ok = FALSE;\n+            }\n+        }\n+      else\n+        {\n+          ok = FALSE;\n+        }\n+    }\n+  (*x) = 0;\n+  if (i < higha)\n+    {\n+      ok = TRUE;\n+      do {\n+        (*x) = (8*(*x))+((int ) ( ((unsigned int) (a[i]))- ((unsigned int) ('0'))));\n+        if (i < higha)\n+          {\n+            /* avoid dangling else.  */\n+            i += 1;\n+            if ((a[i] < '0') || (a[i] > '7'))\n+              {\n+                ok = FALSE;\n+              }\n+          }\n+        else\n+          {\n+            ok = FALSE;\n+          }\n+      } while (! (! ok));\n+    }\n+}\n+\n+extern \"C\" void _M2_NumberIO_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}\n+\n+extern \"C\" void _M2_NumberIO_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "e15b3eb9007926e9cbf6380eaca84f82445dc86c", "filename": "gcc/m2/mc-boot/GPushBackInput.cc", "status": "added", "additions": 488, "deletions": 0, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGPushBackInput.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGPushBackInput.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGPushBackInput.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,488 @@\n+/* do not edit automatically generated by mc from PushBackInput.  */\n+/* PushBackInput.mod provides a method for pushing back and consuming input.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#   if !defined (FALSE)\n+#      define FALSE (1==0)\n+#   endif\n+\n+#if defined(__cplusplus)\n+#   undef NULL\n+#   define NULL 0\n+#endif\n+#define _PushBackInput_H\n+#define _PushBackInput_C\n+\n+#   include \"GFIO.h\"\n+#   include \"GDynamicStrings.h\"\n+#   include \"GASCII.h\"\n+#   include \"GDebug.h\"\n+#   include \"GStrLib.h\"\n+#   include \"GNumberIO.h\"\n+#   include \"GStrIO.h\"\n+#   include \"GStdIO.h\"\n+#   include \"Glibc.h\"\n+\n+#   define MaxPushBackStack 8192\n+#   define MaxFileName 4096\n+typedef struct PushBackInput__T2_a PushBackInput__T2;\n+\n+typedef struct PushBackInput__T3_a PushBackInput__T3;\n+\n+struct PushBackInput__T2_a { char array[MaxFileName+1]; };\n+struct PushBackInput__T3_a { char array[MaxPushBackStack+1]; };\n+static PushBackInput__T2 FileName;\n+static PushBackInput__T3 CharStack;\n+static unsigned int ExitStatus;\n+static unsigned int Column;\n+static unsigned int StackPtr;\n+static unsigned int LineNo;\n+static unsigned int Debugging;\n+\n+/*\n+   Open - opens a file for reading.\n+*/\n+\n+extern \"C\" FIO_File PushBackInput_Open (const char *a_, unsigned int _a_high);\n+\n+/*\n+   GetCh - gets a character from either the push back stack or\n+           from file, f.\n+*/\n+\n+extern \"C\" char PushBackInput_GetCh (FIO_File f);\n+\n+/*\n+   PutCh - pushes a character onto the push back stack, it also\n+           returns the character which has been pushed.\n+*/\n+\n+extern \"C\" char PushBackInput_PutCh (char ch);\n+\n+/*\n+   PutString - pushes a string onto the push back stack.\n+*/\n+\n+extern \"C\" void PushBackInput_PutString (const char *a_, unsigned int _a_high);\n+\n+/*\n+   PutStr - pushes a dynamic string onto the push back stack.\n+            The string, s, is not deallocated.\n+*/\n+\n+extern \"C\" void PushBackInput_PutStr (DynamicStrings_String s);\n+\n+/*\n+   Error - emits an error message with the appropriate file, line combination.\n+*/\n+\n+extern \"C\" void PushBackInput_Error (const char *a_, unsigned int _a_high);\n+\n+/*\n+   WarnError - emits an error message with the appropriate file, line combination.\n+               It does not terminate but when the program finishes an exit status of\n+               1 will be issued.\n+*/\n+\n+extern \"C\" void PushBackInput_WarnError (const char *a_, unsigned int _a_high);\n+\n+/*\n+   WarnString - emits an error message with the appropriate file, line combination.\n+                It does not terminate but when the program finishes an exit status of\n+                1 will be issued.\n+*/\n+\n+extern \"C\" void PushBackInput_WarnString (DynamicStrings_String s);\n+\n+/*\n+   Close - closes the opened file.\n+*/\n+\n+extern \"C\" void PushBackInput_Close (FIO_File f);\n+\n+/*\n+   GetExitStatus - returns the exit status which will be 1 if any warnings were issued.\n+*/\n+\n+extern \"C\" unsigned int PushBackInput_GetExitStatus (void);\n+\n+/*\n+   SetDebug - sets the debug flag on or off.\n+*/\n+\n+extern \"C\" void PushBackInput_SetDebug (unsigned int d);\n+\n+/*\n+   GetColumnPosition - returns the column position of the current character.\n+*/\n+\n+extern \"C\" unsigned int PushBackInput_GetColumnPosition (void);\n+\n+/*\n+   GetCurrentLine - returns the current line number.\n+*/\n+\n+extern \"C\" unsigned int PushBackInput_GetCurrentLine (void);\n+\n+/*\n+   ErrChar - writes a char, ch, to stderr.\n+*/\n+\n+static void ErrChar (char ch);\n+\n+/*\n+   Init - initialize global variables.\n+*/\n+\n+static void Init (void);\n+\n+\n+/*\n+   ErrChar - writes a char, ch, to stderr.\n+*/\n+\n+static void ErrChar (char ch)\n+{\n+  FIO_WriteChar (FIO_StdErr, ch);\n+}\n+\n+\n+/*\n+   Init - initialize global variables.\n+*/\n+\n+static void Init (void)\n+{\n+  ExitStatus = 0;\n+  StackPtr = 0;\n+  LineNo = 1;\n+  Column = 0;\n+}\n+\n+\n+/*\n+   Open - opens a file for reading.\n+*/\n+\n+extern \"C\" FIO_File PushBackInput_Open (const char *a_, unsigned int _a_high)\n+{\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  Init ();\n+  StrLib_StrCopy ((const char *) a, _a_high, (char *) &FileName.array[0], MaxFileName);\n+  return FIO_OpenToRead ((const char *) a, _a_high);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   GetCh - gets a character from either the push back stack or\n+           from file, f.\n+*/\n+\n+extern \"C\" char PushBackInput_GetCh (FIO_File f)\n+{\n+  char ch;\n+\n+  if (StackPtr > 0)\n+    {\n+      StackPtr -= 1;\n+      if (Debugging)\n+        {\n+          StdIO_Write (CharStack.array[StackPtr]);\n+        }\n+      return CharStack.array[StackPtr];\n+    }\n+  else\n+    {\n+      if ((FIO_EOF (f)) || (! (FIO_IsNoError (f))))\n+        {\n+          ch = ASCII_nul;\n+        }\n+      else\n+        {\n+          do {\n+            ch = FIO_ReadChar (f);\n+          } while (! (((ch != ASCII_cr) || (FIO_EOF (f))) || (! (FIO_IsNoError (f)))));\n+          if (ch == ASCII_lf)\n+            {\n+              Column = 0;\n+              LineNo += 1;\n+            }\n+          else\n+            {\n+              Column += 1;\n+            }\n+        }\n+      if (Debugging)\n+        {\n+          StdIO_Write (ch);\n+        }\n+      return ch;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   PutCh - pushes a character onto the push back stack, it also\n+           returns the character which has been pushed.\n+*/\n+\n+extern \"C\" char PushBackInput_PutCh (char ch)\n+{\n+  if (StackPtr < MaxPushBackStack)\n+    {\n+      CharStack.array[StackPtr] = ch;\n+      StackPtr += 1;\n+    }\n+  else\n+    {\n+      Debug_Halt ((const char *) \"max push back stack exceeded, increase MaxPushBackStack\", 55, 150, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/PushBackInput.mod\", 54);\n+    }\n+  return ch;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   PutString - pushes a string onto the push back stack.\n+*/\n+\n+extern \"C\" void PushBackInput_PutString (const char *a_, unsigned int _a_high)\n+{\n+  unsigned int l;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  l = StrLib_StrLen ((const char *) a, _a_high);\n+  while (l > 0)\n+    {\n+      l -= 1;\n+      if ((PushBackInput_PutCh (a[l])) != a[l])\n+        {\n+          Debug_Halt ((const char *) \"assert failed\", 13, 132, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/PushBackInput.mod\", 54);\n+        }\n+    }\n+}\n+\n+\n+/*\n+   PutStr - pushes a dynamic string onto the push back stack.\n+            The string, s, is not deallocated.\n+*/\n+\n+extern \"C\" void PushBackInput_PutStr (DynamicStrings_String s)\n+{\n+  unsigned int i;\n+\n+  i = DynamicStrings_Length (s);\n+  while (i > 0)\n+    {\n+      i -= 1;\n+      if ((PushBackInput_PutCh (DynamicStrings_char (s, static_cast<int> (i)))) != (DynamicStrings_char (s, static_cast<int> (i))))\n+        {\n+          Debug_Halt ((const char *) \"assert failed\", 13, 113, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/PushBackInput.mod\", 54);\n+        }\n+    }\n+}\n+\n+\n+/*\n+   Error - emits an error message with the appropriate file, line combination.\n+*/\n+\n+extern \"C\" void PushBackInput_Error (const char *a_, unsigned int _a_high)\n+{\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  StdIO_PushOutput ((StdIO_ProcWrite) {(StdIO_ProcWrite_t) ErrChar});\n+  StrIO_WriteString ((const char *) &FileName.array[0], MaxFileName);\n+  StdIO_Write (':');\n+  NumberIO_WriteCard (LineNo, 0);\n+  StdIO_Write (':');\n+  StrIO_WriteString ((const char *) a, _a_high);\n+  StrIO_WriteLn ();\n+  StdIO_PopOutput ();\n+  FIO_Close (FIO_StdErr);\n+  libc_exit (1);\n+}\n+\n+\n+/*\n+   WarnError - emits an error message with the appropriate file, line combination.\n+               It does not terminate but when the program finishes an exit status of\n+               1 will be issued.\n+*/\n+\n+extern \"C\" void PushBackInput_WarnError (const char *a_, unsigned int _a_high)\n+{\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  StdIO_PushOutput ((StdIO_ProcWrite) {(StdIO_ProcWrite_t) ErrChar});\n+  StrIO_WriteString ((const char *) &FileName.array[0], MaxFileName);\n+  StdIO_Write (':');\n+  NumberIO_WriteCard (LineNo, 0);\n+  StdIO_Write (':');\n+  StrIO_WriteString ((const char *) a, _a_high);\n+  StrIO_WriteLn ();\n+  StdIO_PopOutput ();\n+  ExitStatus = 1;\n+}\n+\n+\n+/*\n+   WarnString - emits an error message with the appropriate file, line combination.\n+                It does not terminate but when the program finishes an exit status of\n+                1 will be issued.\n+*/\n+\n+extern \"C\" void PushBackInput_WarnString (DynamicStrings_String s)\n+{\n+  typedef char *WarnString__T1;\n+\n+  WarnString__T1 p;\n+\n+  p = static_cast<WarnString__T1> (DynamicStrings_string (s));\n+  StrIO_WriteString ((const char *) &FileName.array[0], MaxFileName);\n+  StdIO_Write (':');\n+  NumberIO_WriteCard (LineNo, 0);\n+  StdIO_Write (':');\n+  do {\n+    if (p != NULL)\n+      {\n+        if ((*p) == ASCII_lf)\n+          {\n+            StrIO_WriteLn ();\n+            StrIO_WriteString ((const char *) &FileName.array[0], MaxFileName);\n+            StdIO_Write (':');\n+            NumberIO_WriteCard (LineNo, 0);\n+            StdIO_Write (':');\n+          }\n+        else\n+          {\n+            StdIO_Write ((*p));\n+          }\n+        p += 1;\n+      }\n+  } while (! ((p == NULL) || ((*p) == ASCII_nul)));\n+  ExitStatus = 1;\n+}\n+\n+\n+/*\n+   Close - closes the opened file.\n+*/\n+\n+extern \"C\" void PushBackInput_Close (FIO_File f)\n+{\n+  FIO_Close (f);\n+}\n+\n+\n+/*\n+   GetExitStatus - returns the exit status which will be 1 if any warnings were issued.\n+*/\n+\n+extern \"C\" unsigned int PushBackInput_GetExitStatus (void)\n+{\n+  return ExitStatus;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   SetDebug - sets the debug flag on or off.\n+*/\n+\n+extern \"C\" void PushBackInput_SetDebug (unsigned int d)\n+{\n+  Debugging = d;\n+}\n+\n+\n+/*\n+   GetColumnPosition - returns the column position of the current character.\n+*/\n+\n+extern \"C\" unsigned int PushBackInput_GetColumnPosition (void)\n+{\n+  if (StackPtr > Column)\n+    {\n+      return 0;\n+    }\n+  else\n+    {\n+      return Column-StackPtr;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   GetCurrentLine - returns the current line number.\n+*/\n+\n+extern \"C\" unsigned int PushBackInput_GetCurrentLine (void)\n+{\n+  return LineNo;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" void _M2_PushBackInput_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+  PushBackInput_SetDebug (FALSE);\n+  Init ();\n+}\n+\n+extern \"C\" void _M2_PushBackInput_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "23f8fede117bc6ab07278b8922e944adc2adddbc", "filename": "gcc/m2/mc-boot/GRTExceptions.cc", "status": "added", "additions": 1223, "deletions": 0, "changes": 1223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGRTExceptions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGRTExceptions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGRTExceptions.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,1223 @@\n+/* do not edit automatically generated by mc from RTExceptions.  */\n+/* RTExceptions.mod runtime exception handler routines.\n+\n+Copyright (C) 2008-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#   if !defined (FALSE)\n+#      define FALSE (1==0)\n+#   endif\n+\n+#   include \"GStorage.h\"\n+#   include \"Gmcrts.h\"\n+#ifndef __cplusplus\n+extern void throw (unsigned int);\n+#endif\n+#if defined(__cplusplus)\n+#   undef NULL\n+#   define NULL 0\n+#endif\n+#define _RTExceptions_H\n+#define _RTExceptions_C\n+\n+#   include \"GASCII.h\"\n+#   include \"GStrLib.h\"\n+#   include \"GStorage.h\"\n+#   include \"GSYSTEM.h\"\n+#   include \"Glibc.h\"\n+#   include \"GM2RTS.h\"\n+#   include \"GSysExceptions.h\"\n+#   include \"GM2EXCEPTION.h\"\n+\n+typedef struct RTExceptions_ProcedureHandler_p RTExceptions_ProcedureHandler;\n+\n+#   define MaxBuffer 4096\n+typedef struct RTExceptions__T1_r RTExceptions__T1;\n+\n+typedef char *RTExceptions_PtrToChar;\n+\n+typedef struct RTExceptions__T2_a RTExceptions__T2;\n+\n+typedef struct RTExceptions__T3_r RTExceptions__T3;\n+\n+typedef RTExceptions__T3 *RTExceptions_Handler;\n+\n+typedef RTExceptions__T1 *RTExceptions_EHBlock;\n+\n+typedef void (*RTExceptions_ProcedureHandler_t) (void);\n+struct RTExceptions_ProcedureHandler_p { RTExceptions_ProcedureHandler_t proc; };\n+\n+struct RTExceptions__T2_a { char array[MaxBuffer+1]; };\n+struct RTExceptions__T1_r {\n+                            RTExceptions__T2 buffer;\n+                            unsigned int number;\n+                            RTExceptions_Handler handlers;\n+                            RTExceptions_EHBlock right;\n+                          };\n+\n+struct RTExceptions__T3_r {\n+                            RTExceptions_ProcedureHandler p;\n+                            unsigned int n;\n+                            RTExceptions_Handler right;\n+                            RTExceptions_Handler left;\n+                            RTExceptions_Handler stack;\n+                          };\n+\n+static unsigned int inException;\n+static RTExceptions_Handler freeHandler;\n+static RTExceptions_EHBlock freeEHB;\n+static RTExceptions_EHBlock currentEHB;\n+static void * currentSource;\n+\n+/*\n+   Raise - invoke the exception handler associated with, number,\n+           in the active EHBlock.  It keeps a record of the number\n+           and message in the EHBlock for later use.\n+*/\n+\n+extern \"C\" void RTExceptions_Raise (unsigned int number, void * file, unsigned int line, unsigned int column, void * function, void * message) __attribute__ ((noreturn));\n+\n+/*\n+   SetExceptionBlock - sets, source, as the active EHB.\n+*/\n+\n+extern \"C\" void RTExceptions_SetExceptionBlock (RTExceptions_EHBlock source);\n+\n+/*\n+   GetExceptionBlock - returns the active EHB.\n+*/\n+\n+extern \"C\" RTExceptions_EHBlock RTExceptions_GetExceptionBlock (void);\n+\n+/*\n+   GetTextBuffer - returns the address of the EHB buffer.\n+*/\n+\n+extern \"C\" void * RTExceptions_GetTextBuffer (RTExceptions_EHBlock e);\n+\n+/*\n+   GetTextBufferSize - return the size of the EHB text buffer.\n+*/\n+\n+extern \"C\" unsigned int RTExceptions_GetTextBufferSize (RTExceptions_EHBlock e);\n+\n+/*\n+   GetNumber - return the exception number associated with,\n+               source.\n+*/\n+\n+extern \"C\" unsigned int RTExceptions_GetNumber (RTExceptions_EHBlock source);\n+\n+/*\n+   InitExceptionBlock - creates and returns a new exception block.\n+*/\n+\n+extern \"C\" RTExceptions_EHBlock RTExceptions_InitExceptionBlock (void);\n+\n+/*\n+   KillExceptionBlock - destroys the EHB, e, and all its handlers.\n+*/\n+\n+extern \"C\" RTExceptions_EHBlock RTExceptions_KillExceptionBlock (RTExceptions_EHBlock e);\n+\n+/*\n+   PushHandler - install a handler in EHB, e.\n+*/\n+\n+extern \"C\" void RTExceptions_PushHandler (RTExceptions_EHBlock e, unsigned int number, RTExceptions_ProcedureHandler p);\n+\n+/*\n+   PopHandler - removes the handler associated with, number, from\n+                EHB, e.\n+*/\n+\n+extern \"C\" void RTExceptions_PopHandler (RTExceptions_EHBlock e, unsigned int number);\n+\n+/*\n+   DefaultErrorCatch - displays the current error message in\n+                       the current exception block and then\n+                       calls HALT.\n+*/\n+\n+extern \"C\" void RTExceptions_DefaultErrorCatch (void);\n+\n+/*\n+   BaseExceptionsThrow - configures the Modula-2 exceptions to call\n+                         THROW which in turn can be caught by an\n+                         exception block.  If this is not called then\n+                         a Modula-2 exception will simply call an\n+                         error message routine and then HALT.\n+*/\n+\n+extern \"C\" void RTExceptions_BaseExceptionsThrow (void);\n+\n+/*\n+   IsInExceptionState - returns TRUE if the program is currently\n+                        in the exception state.\n+*/\n+\n+extern \"C\" unsigned int RTExceptions_IsInExceptionState (void);\n+\n+/*\n+   SetExceptionState - returns the current exception state and\n+                       then sets the current exception state to,\n+                       to.\n+*/\n+\n+extern \"C\" unsigned int RTExceptions_SetExceptionState (unsigned int to);\n+\n+/*\n+   SwitchExceptionState - assigns, from, with the current exception\n+                          state and then assigns the current exception\n+                          to, to.\n+*/\n+\n+extern \"C\" void RTExceptions_SwitchExceptionState (unsigned int *from, unsigned int to);\n+\n+/*\n+   GetBaseExceptionBlock - returns the initial language exception block\n+                           created.\n+*/\n+\n+extern \"C\" RTExceptions_EHBlock RTExceptions_GetBaseExceptionBlock (void);\n+\n+/*\n+   SetExceptionSource - sets the current exception source to, source.\n+*/\n+\n+extern \"C\" void RTExceptions_SetExceptionSource (void * source);\n+\n+/*\n+   GetExceptionSource - returns the current exception source.\n+*/\n+\n+extern \"C\" void * RTExceptions_GetExceptionSource (void);\n+\n+/*\n+   ErrorString - writes a string to stderr.\n+*/\n+\n+static void ErrorString (const char *a_, unsigned int _a_high);\n+\n+/*\n+   findHandler -\n+*/\n+\n+static RTExceptions_Handler findHandler (RTExceptions_EHBlock e, unsigned int number);\n+\n+/*\n+   InvokeHandler - invokes the associated handler for the current\n+                   exception in the active EHB.\n+*/\n+\n+static void InvokeHandler (void) __attribute__ ((noreturn));\n+\n+/*\n+   DoThrow - throw the exception number in the exception block.\n+*/\n+\n+static void DoThrow (void);\n+\n+/*\n+   addChar - adds, ch, to the current exception handler text buffer\n+             at index, i.  The index in then incremented.\n+*/\n+\n+static void addChar (char ch, unsigned int *i);\n+\n+/*\n+   stripPath - returns the filename from the path.\n+*/\n+\n+static void * stripPath (void * s);\n+\n+/*\n+   addFile - adds the filename determined by, s, however it strips\n+             any preceeding path.\n+*/\n+\n+static void addFile (void * s, unsigned int *i);\n+\n+/*\n+   addStr - adds a C string from address, s, into the current\n+            handler text buffer.\n+*/\n+\n+static void addStr (void * s, unsigned int *i);\n+\n+/*\n+   addNum - adds a number, n, to the current handler\n+            text buffer.\n+*/\n+\n+static void addNum (unsigned int n, unsigned int *i);\n+\n+/*\n+   New - returns a new EHBlock.\n+*/\n+\n+static RTExceptions_EHBlock New (void);\n+\n+/*\n+   NewHandler - returns a new handler.\n+*/\n+\n+static RTExceptions_Handler NewHandler (void);\n+\n+/*\n+   KillHandler - returns, NIL, and places, h, onto the free list.\n+*/\n+\n+static RTExceptions_Handler KillHandler (RTExceptions_Handler h);\n+\n+/*\n+   KillHandlers - kills all handlers in the list.\n+*/\n+\n+static RTExceptions_Handler KillHandlers (RTExceptions_Handler h);\n+\n+/*\n+   InitHandler -\n+*/\n+\n+static RTExceptions_Handler InitHandler (RTExceptions_Handler h, RTExceptions_Handler l, RTExceptions_Handler r, RTExceptions_Handler s, unsigned int number, RTExceptions_ProcedureHandler proc);\n+\n+/*\n+   SubHandler -\n+*/\n+\n+static void SubHandler (RTExceptions_Handler h);\n+\n+/*\n+   AddHandler - add, e, to the end of the list of handlers.\n+*/\n+\n+static void AddHandler (RTExceptions_EHBlock e, RTExceptions_Handler h);\n+\n+/*\n+   indexf - raise an index out of bounds exception.\n+*/\n+\n+static void indexf (void * a);\n+\n+/*\n+   range - raise an assignment out of range exception.\n+*/\n+\n+static void range (void * a);\n+\n+/*\n+   casef - raise a case selector out of range exception.\n+*/\n+\n+static void casef (void * a);\n+\n+/*\n+   invalidloc - raise an invalid location exception.\n+*/\n+\n+static void invalidloc (void * a);\n+\n+/*\n+   function - raise a ... function ... exception.  --fixme-- what does this exception catch?\n+*/\n+\n+static void function (void * a);\n+\n+/*\n+   wholevalue - raise an illegal whole value exception.\n+*/\n+\n+static void wholevalue (void * a);\n+\n+/*\n+   wholediv - raise a division by zero exception.\n+*/\n+\n+static void wholediv (void * a);\n+\n+/*\n+   realvalue - raise an illegal real value exception.\n+*/\n+\n+static void realvalue (void * a);\n+\n+/*\n+   realdiv - raise a division by zero in a real number exception.\n+*/\n+\n+static void realdiv (void * a);\n+\n+/*\n+   complexvalue - raise an illegal complex value exception.\n+*/\n+\n+static void complexvalue (void * a);\n+\n+/*\n+   complexdiv - raise a division by zero in a complex number exception.\n+*/\n+\n+static void complexdiv (void * a);\n+\n+/*\n+   protection - raise a protection exception.\n+*/\n+\n+static void protection (void * a);\n+\n+/*\n+   systemf - raise a system exception.\n+*/\n+\n+static void systemf (void * a);\n+\n+/*\n+   coroutine - raise a coroutine exception.\n+*/\n+\n+static void coroutine (void * a);\n+\n+/*\n+   exception - raise a exception exception.\n+*/\n+\n+static void exception (void * a);\n+\n+/*\n+   Init - initialises this module.\n+*/\n+\n+static void Init (void);\n+\n+/*\n+   TidyUp - deallocate memory used by this module.\n+*/\n+\n+static void TidyUp (void);\n+\n+\n+/*\n+   ErrorString - writes a string to stderr.\n+*/\n+\n+static void ErrorString (const char *a_, unsigned int _a_high)\n+{\n+  int n;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  n = static_cast<int> (libc_write (2, &a, static_cast<size_t> (StrLib_StrLen ((const char *) a, _a_high))));\n+}\n+\n+\n+/*\n+   findHandler -\n+*/\n+\n+static RTExceptions_Handler findHandler (RTExceptions_EHBlock e, unsigned int number)\n+{\n+  RTExceptions_Handler h;\n+\n+  h = e->handlers->right;\n+  while ((h != e->handlers) && (number != h->n))\n+    {\n+      h = h->right;\n+    }\n+  if (h == e->handlers)\n+    {\n+      return NULL;\n+    }\n+  else\n+    {\n+      return h;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   InvokeHandler - invokes the associated handler for the current\n+                   exception in the active EHB.\n+*/\n+\n+static void InvokeHandler (void)\n+{\n+  RTExceptions_Handler h;\n+\n+  h = findHandler (currentEHB, currentEHB->number);\n+  if (h == NULL)\n+    {\n+      throw (RTExceptions_GetNumber (RTExceptions_GetExceptionBlock ()));\n+    }\n+  else\n+    {\n+      (*h->p.proc) ();\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n+    }\n+}\n+\n+\n+/*\n+   DoThrow - throw the exception number in the exception block.\n+*/\n+\n+static void DoThrow (void)\n+{\n+  throw (RTExceptions_GetNumber (RTExceptions_GetExceptionBlock ()));\n+}\n+\n+\n+/*\n+   addChar - adds, ch, to the current exception handler text buffer\n+             at index, i.  The index in then incremented.\n+*/\n+\n+static void addChar (char ch, unsigned int *i)\n+{\n+  if (((*i) <= MaxBuffer) && (currentEHB != NULL))\n+    {\n+      currentEHB->buffer.array[(*i)] = ch;\n+      (*i) += 1;\n+    }\n+}\n+\n+\n+/*\n+   stripPath - returns the filename from the path.\n+*/\n+\n+static void * stripPath (void * s)\n+{\n+  RTExceptions_PtrToChar f;\n+  RTExceptions_PtrToChar p;\n+\n+  p = static_cast<RTExceptions_PtrToChar> (s);\n+  f = static_cast<RTExceptions_PtrToChar> (s);\n+  while ((*p) != ASCII_nul)\n+    {\n+      if ((*p) == '/')\n+        {\n+          p += 1;\n+          f = p;\n+        }\n+      else\n+        {\n+          p += 1;\n+        }\n+    }\n+  return reinterpret_cast<void *> (f);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   addFile - adds the filename determined by, s, however it strips\n+             any preceeding path.\n+*/\n+\n+static void addFile (void * s, unsigned int *i)\n+{\n+  RTExceptions_PtrToChar p;\n+\n+  p = static_cast<RTExceptions_PtrToChar> (stripPath (s));\n+  while ((p != NULL) && ((*p) != ASCII_nul))\n+    {\n+      addChar ((*p), i);\n+      p += 1;\n+    }\n+}\n+\n+\n+/*\n+   addStr - adds a C string from address, s, into the current\n+            handler text buffer.\n+*/\n+\n+static void addStr (void * s, unsigned int *i)\n+{\n+  RTExceptions_PtrToChar p;\n+\n+  p = static_cast<RTExceptions_PtrToChar> (s);\n+  while ((p != NULL) && ((*p) != ASCII_nul))\n+    {\n+      addChar ((*p), i);\n+      p += 1;\n+    }\n+}\n+\n+\n+/*\n+   addNum - adds a number, n, to the current handler\n+            text buffer.\n+*/\n+\n+static void addNum (unsigned int n, unsigned int *i)\n+{\n+  if (n < 10)\n+    {\n+      addChar ( ((char) ((n % 10)+ ((unsigned int) ('0')))), i);\n+    }\n+  else\n+    {\n+      addNum (n / 10, i);\n+      addNum (n % 10, i);\n+    }\n+}\n+\n+\n+/*\n+   New - returns a new EHBlock.\n+*/\n+\n+static RTExceptions_EHBlock New (void)\n+{\n+  RTExceptions_EHBlock e;\n+\n+  if (freeEHB == NULL)\n+    {\n+      Storage_ALLOCATE ((void **) &e, sizeof (RTExceptions__T1));\n+    }\n+  else\n+    {\n+      e = freeEHB;\n+      freeEHB = freeEHB->right;\n+    }\n+  return e;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   NewHandler - returns a new handler.\n+*/\n+\n+static RTExceptions_Handler NewHandler (void)\n+{\n+  RTExceptions_Handler h;\n+\n+  if (freeHandler == NULL)\n+    {\n+      Storage_ALLOCATE ((void **) &h, sizeof (RTExceptions__T3));\n+    }\n+  else\n+    {\n+      h = freeHandler;\n+      freeHandler = freeHandler->right;\n+    }\n+  return h;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   KillHandler - returns, NIL, and places, h, onto the free list.\n+*/\n+\n+static RTExceptions_Handler KillHandler (RTExceptions_Handler h)\n+{\n+  h->right = freeHandler;\n+  freeHandler = h;\n+  return NULL;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   KillHandlers - kills all handlers in the list.\n+*/\n+\n+static RTExceptions_Handler KillHandlers (RTExceptions_Handler h)\n+{\n+  h->left->right = freeHandler;\n+  freeHandler = h;\n+  return NULL;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   InitHandler -\n+*/\n+\n+static RTExceptions_Handler InitHandler (RTExceptions_Handler h, RTExceptions_Handler l, RTExceptions_Handler r, RTExceptions_Handler s, unsigned int number, RTExceptions_ProcedureHandler proc)\n+{\n+  h->p = proc;\n+  h->n = number;\n+  h->right = r;\n+  h->left = l;\n+  h->stack = s;\n+  return h;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   SubHandler -\n+*/\n+\n+static void SubHandler (RTExceptions_Handler h)\n+{\n+  h->right->left = h->left;\n+  h->left->right = h->right;\n+}\n+\n+\n+/*\n+   AddHandler - add, e, to the end of the list of handlers.\n+*/\n+\n+static void AddHandler (RTExceptions_EHBlock e, RTExceptions_Handler h)\n+{\n+  h->right = e->handlers;\n+  h->left = e->handlers->left;\n+  e->handlers->left->right = h;\n+  e->handlers->left = h;\n+}\n+\n+\n+/*\n+   indexf - raise an index out of bounds exception.\n+*/\n+\n+static void indexf (void * a)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_indexException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 613, 9, const_cast<void*> (reinterpret_cast<const void*>(\"indexf\")), const_cast<void*> (reinterpret_cast<const void*>(\"array index out of bounds\")));\n+}\n+\n+\n+/*\n+   range - raise an assignment out of range exception.\n+*/\n+\n+static void range (void * a)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_rangeException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 625, 9, const_cast<void*> (reinterpret_cast<const void*>(\"range\")), const_cast<void*> (reinterpret_cast<const void*>(\"assignment out of range\")));\n+}\n+\n+\n+/*\n+   casef - raise a case selector out of range exception.\n+*/\n+\n+static void casef (void * a)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_caseSelectException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 637, 9, const_cast<void*> (reinterpret_cast<const void*>(\"casef\")), const_cast<void*> (reinterpret_cast<const void*>(\"case selector out of range\")));\n+}\n+\n+\n+/*\n+   invalidloc - raise an invalid location exception.\n+*/\n+\n+static void invalidloc (void * a)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_invalidLocation)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 649, 9, const_cast<void*> (reinterpret_cast<const void*>(\"invalidloc\")), const_cast<void*> (reinterpret_cast<const void*>(\"invalid address referenced\")));\n+}\n+\n+\n+/*\n+   function - raise a ... function ... exception.  --fixme-- what does this exception catch?\n+*/\n+\n+static void function (void * a)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_functionException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 661, 9, const_cast<void*> (reinterpret_cast<const void*>(\"function\")), const_cast<void*> (reinterpret_cast<const void*>(\"... function ... \")));  /* --fixme-- what has happened ?  */\n+}\n+\n+\n+/*\n+   wholevalue - raise an illegal whole value exception.\n+*/\n+\n+static void wholevalue (void * a)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_wholeValueException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 673, 9, const_cast<void*> (reinterpret_cast<const void*>(\"wholevalue\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal whole value exception\")));\n+}\n+\n+\n+/*\n+   wholediv - raise a division by zero exception.\n+*/\n+\n+static void wholediv (void * a)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_wholeDivException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 685, 9, const_cast<void*> (reinterpret_cast<const void*>(\"wholediv\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal whole value exception\")));\n+}\n+\n+\n+/*\n+   realvalue - raise an illegal real value exception.\n+*/\n+\n+static void realvalue (void * a)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_realValueException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 697, 9, const_cast<void*> (reinterpret_cast<const void*>(\"realvalue\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal real value exception\")));\n+}\n+\n+\n+/*\n+   realdiv - raise a division by zero in a real number exception.\n+*/\n+\n+static void realdiv (void * a)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_realDivException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 709, 9, const_cast<void*> (reinterpret_cast<const void*>(\"realdiv\")), const_cast<void*> (reinterpret_cast<const void*>(\"real number division by zero exception\")));\n+}\n+\n+\n+/*\n+   complexvalue - raise an illegal complex value exception.\n+*/\n+\n+static void complexvalue (void * a)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_complexValueException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 721, 9, const_cast<void*> (reinterpret_cast<const void*>(\"complexvalue\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal complex value exception\")));\n+}\n+\n+\n+/*\n+   complexdiv - raise a division by zero in a complex number exception.\n+*/\n+\n+static void complexdiv (void * a)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_complexDivException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 733, 9, const_cast<void*> (reinterpret_cast<const void*>(\"complexdiv\")), const_cast<void*> (reinterpret_cast<const void*>(\"complex number division by zero exception\")));\n+}\n+\n+\n+/*\n+   protection - raise a protection exception.\n+*/\n+\n+static void protection (void * a)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_protException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 745, 9, const_cast<void*> (reinterpret_cast<const void*>(\"protection\")), const_cast<void*> (reinterpret_cast<const void*>(\"protection exception\")));\n+}\n+\n+\n+/*\n+   systemf - raise a system exception.\n+*/\n+\n+static void systemf (void * a)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_sysException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 757, 9, const_cast<void*> (reinterpret_cast<const void*>(\"systemf\")), const_cast<void*> (reinterpret_cast<const void*>(\"system exception\")));\n+}\n+\n+\n+/*\n+   coroutine - raise a coroutine exception.\n+*/\n+\n+static void coroutine (void * a)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_coException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 769, 9, const_cast<void*> (reinterpret_cast<const void*>(\"coroutine\")), const_cast<void*> (reinterpret_cast<const void*>(\"coroutine exception\")));\n+}\n+\n+\n+/*\n+   exception - raise a exception exception.\n+*/\n+\n+static void exception (void * a)\n+{\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_exException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 781, 9, const_cast<void*> (reinterpret_cast<const void*>(\"exception\")), const_cast<void*> (reinterpret_cast<const void*>(\"exception exception\")));\n+}\n+\n+\n+/*\n+   Init - initialises this module.\n+*/\n+\n+static void Init (void)\n+{\n+  inException = FALSE;\n+  freeHandler = NULL;\n+  freeEHB = NULL;\n+  currentEHB = RTExceptions_InitExceptionBlock ();\n+  currentSource = NULL;\n+  RTExceptions_BaseExceptionsThrow ();\n+  SysExceptions_InitExceptionHandlers ((SysExceptions_PROCEXCEPTION) {(SysExceptions_PROCEXCEPTION_t) indexf}, (SysExceptions_PROCEXCEPTION) {(SysExceptions_PROCEXCEPTION_t) range}, (SysExceptions_PROCEXCEPTION) {(SysExceptions_PROCEXCEPTION_t) casef}, (SysExceptions_PROCEXCEPTION) {(SysExceptions_PROCEXCEPTION_t) invalidloc}, (SysExceptions_PROCEXCEPTION) {(SysExceptions_PROCEXCEPTION_t) function}, (SysExceptions_PROCEXCEPTION) {(SysExceptions_PROCEXCEPTION_t) wholevalue}, (SysExceptions_PROCEXCEPTION) {(SysExceptions_PROCEXCEPTION_t) wholediv}, (SysExceptions_PROCEXCEPTION) {(SysExceptions_PROCEXCEPTION_t) realvalue}, (SysExceptions_PROCEXCEPTION) {(SysExceptions_PROCEXCEPTION_t) realdiv}, (SysExceptions_PROCEXCEPTION) {(SysExceptions_PROCEXCEPTION_t) complexvalue}, (SysExceptions_PROCEXCEPTION) {(SysExceptions_PROCEXCEPTION_t) complexdiv}, (SysExceptions_PROCEXCEPTION) {(SysExceptions_PROCEXCEPTION_t) protection}, (SysExceptions_PROCEXCEPTION) {(SysExceptions_PROCEXCEPTION_t) systemf}, (SysExceptions_PROCEXCEPTION) {(SysExceptions_PROCEXCEPTION_t) coroutine}, (SysExceptions_PROCEXCEPTION) {(SysExceptions_PROCEXCEPTION_t) exception});\n+}\n+\n+\n+/*\n+   TidyUp - deallocate memory used by this module.\n+*/\n+\n+static void TidyUp (void)\n+{\n+  RTExceptions_Handler f;\n+  RTExceptions_EHBlock e;\n+\n+  if (currentEHB != NULL)\n+    {\n+      currentEHB = RTExceptions_KillExceptionBlock (currentEHB);\n+    }\n+  while (freeHandler != NULL)\n+    {\n+      f = freeHandler;\n+      freeHandler = freeHandler->right;\n+      Storage_DEALLOCATE ((void **) &f, sizeof (RTExceptions__T3));\n+    }\n+  while (freeEHB != NULL)\n+    {\n+      e = freeEHB;\n+      freeEHB = freeEHB->right;\n+      Storage_DEALLOCATE ((void **) &e, sizeof (RTExceptions__T1));\n+    }\n+}\n+\n+\n+/*\n+   Raise - invoke the exception handler associated with, number,\n+           in the active EHBlock.  It keeps a record of the number\n+           and message in the EHBlock for later use.\n+*/\n+\n+extern \"C\" void RTExceptions_Raise (unsigned int number, void * file, unsigned int line, unsigned int column, void * function, void * message)\n+{\n+  unsigned int i;\n+\n+  currentEHB->number = number;\n+  i = 0;\n+  addFile (file, &i);\n+  addChar (':', &i);\n+  addNum (line, &i);\n+  addChar (':', &i);\n+  addNum (column, &i);\n+  addChar (':', &i);\n+  addChar (' ', &i);\n+  addChar ('I', &i);\n+  addChar ('n', &i);\n+  addChar (' ', &i);\n+  addStr (function, &i);\n+  addChar (ASCII_nl, &i);\n+  addFile (file, &i);\n+  addChar (':', &i);\n+  addNum (line, &i);\n+  addChar (':', &i);\n+  addNum (column, &i);\n+  addChar (':', &i);\n+  addStr (message, &i);\n+  addChar (ASCII_nl, &i);\n+  addChar (ASCII_nul, &i);\n+  InvokeHandler ();\n+}\n+\n+\n+/*\n+   SetExceptionBlock - sets, source, as the active EHB.\n+*/\n+\n+extern \"C\" void RTExceptions_SetExceptionBlock (RTExceptions_EHBlock source)\n+{\n+  currentEHB = source;\n+}\n+\n+\n+/*\n+   GetExceptionBlock - returns the active EHB.\n+*/\n+\n+extern \"C\" RTExceptions_EHBlock RTExceptions_GetExceptionBlock (void)\n+{\n+  return currentEHB;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   GetTextBuffer - returns the address of the EHB buffer.\n+*/\n+\n+extern \"C\" void * RTExceptions_GetTextBuffer (RTExceptions_EHBlock e)\n+{\n+  return &e->buffer;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   GetTextBufferSize - return the size of the EHB text buffer.\n+*/\n+\n+extern \"C\" unsigned int RTExceptions_GetTextBufferSize (RTExceptions_EHBlock e)\n+{\n+  return sizeof (e->buffer);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   GetNumber - return the exception number associated with,\n+               source.\n+*/\n+\n+extern \"C\" unsigned int RTExceptions_GetNumber (RTExceptions_EHBlock source)\n+{\n+  return source->number;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   InitExceptionBlock - creates and returns a new exception block.\n+*/\n+\n+extern \"C\" RTExceptions_EHBlock RTExceptions_InitExceptionBlock (void)\n+{\n+  RTExceptions_EHBlock e;\n+\n+  e = New ();\n+  e->number = UINT_MAX;\n+  e->handlers = NewHandler ();  /* add the dummy onto the head  */\n+  e->handlers->right = e->handlers;  /* add the dummy onto the head  */\n+  e->handlers->left = e->handlers;\n+  e->right = e;\n+  return e;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   KillExceptionBlock - destroys the EHB, e, and all its handlers.\n+*/\n+\n+extern \"C\" RTExceptions_EHBlock RTExceptions_KillExceptionBlock (RTExceptions_EHBlock e)\n+{\n+  e->handlers = KillHandlers (e->handlers);\n+  e->right = freeEHB;\n+  freeEHB = e;\n+  return NULL;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   PushHandler - install a handler in EHB, e.\n+*/\n+\n+extern \"C\" void RTExceptions_PushHandler (RTExceptions_EHBlock e, unsigned int number, RTExceptions_ProcedureHandler p)\n+{\n+  RTExceptions_Handler h;\n+  RTExceptions_Handler i;\n+\n+  h = findHandler (e, number);\n+  if (h == NULL)\n+    {\n+      i = InitHandler (NewHandler (), NULL, NULL, NULL, number, p);\n+    }\n+  else\n+    {\n+      /* remove, h,  */\n+      SubHandler (h);\n+      /* stack it onto a new handler  */\n+      i = InitHandler (NewHandler (), NULL, NULL, h, number, p);\n+    }\n+  /* add new handler  */\n+  AddHandler (e, i);\n+}\n+\n+\n+/*\n+   PopHandler - removes the handler associated with, number, from\n+                EHB, e.\n+*/\n+\n+extern \"C\" void RTExceptions_PopHandler (RTExceptions_EHBlock e, unsigned int number)\n+{\n+  RTExceptions_Handler h;\n+  RTExceptions_Handler i;\n+\n+  h = findHandler (e, number);\n+  if (h != NULL)\n+    {\n+      /* remove, h,  */\n+      SubHandler (h);\n+      if (h->stack != NULL)\n+        {\n+          AddHandler (e, h->stack);\n+        }\n+      h = KillHandler (h);\n+    }\n+}\n+\n+\n+/*\n+   DefaultErrorCatch - displays the current error message in\n+                       the current exception block and then\n+                       calls HALT.\n+*/\n+\n+extern \"C\" void RTExceptions_DefaultErrorCatch (void)\n+{\n+  RTExceptions_EHBlock e;\n+  int n;\n+\n+  e = RTExceptions_GetExceptionBlock ();\n+  n = static_cast<int> (libc_write (2, RTExceptions_GetTextBuffer (e), libc_strlen (RTExceptions_GetTextBuffer (e))));\n+  M2RTS_HALT (-1);\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   BaseExceptionsThrow - configures the Modula-2 exceptions to call\n+                         THROW which in turn can be caught by an\n+                         exception block.  If this is not called then\n+                         a Modula-2 exception will simply call an\n+                         error message routine and then HALT.\n+*/\n+\n+extern \"C\" void RTExceptions_BaseExceptionsThrow (void)\n+{\n+  M2EXCEPTION_M2Exceptions i;\n+\n+  for (i=M2EXCEPTION_indexException; i<=M2EXCEPTION_exException; i= static_cast<M2EXCEPTION_M2Exceptions>(static_cast<int>(i+1)))\n+    {\n+      RTExceptions_PushHandler (RTExceptions_GetExceptionBlock (), (unsigned int ) (i), (RTExceptions_ProcedureHandler) {(RTExceptions_ProcedureHandler_t) DoThrow});\n+    }\n+}\n+\n+\n+/*\n+   IsInExceptionState - returns TRUE if the program is currently\n+                        in the exception state.\n+*/\n+\n+extern \"C\" unsigned int RTExceptions_IsInExceptionState (void)\n+{\n+  return inException;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   SetExceptionState - returns the current exception state and\n+                       then sets the current exception state to,\n+                       to.\n+*/\n+\n+extern \"C\" unsigned int RTExceptions_SetExceptionState (unsigned int to)\n+{\n+  unsigned int old;\n+\n+  old = inException;\n+  inException = to;\n+  return old;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   SwitchExceptionState - assigns, from, with the current exception\n+                          state and then assigns the current exception\n+                          to, to.\n+*/\n+\n+extern \"C\" void RTExceptions_SwitchExceptionState (unsigned int *from, unsigned int to)\n+{\n+  (*from) = inException;\n+  inException = to;\n+}\n+\n+\n+/*\n+   GetBaseExceptionBlock - returns the initial language exception block\n+                           created.\n+*/\n+\n+extern \"C\" RTExceptions_EHBlock RTExceptions_GetBaseExceptionBlock (void)\n+{\n+  if (currentEHB == NULL)\n+    {\n+      M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\", 53, 599, (const char *) \"GetBaseExceptionBlock\", 21, (const char *) \"currentEHB has not been initialized yet\", 39);\n+    }\n+  else\n+    {\n+      return currentEHB;\n+    }\n+  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.def\", 25, 1);\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   SetExceptionSource - sets the current exception source to, source.\n+*/\n+\n+extern \"C\" void RTExceptions_SetExceptionSource (void * source)\n+{\n+  currentSource = source;\n+}\n+\n+\n+/*\n+   GetExceptionSource - returns the current exception source.\n+*/\n+\n+extern \"C\" void * RTExceptions_GetExceptionSource (void)\n+{\n+  return currentSource;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" void _M2_RTExceptions_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+  Init ();\n+}\n+\n+extern \"C\" void _M2_RTExceptions_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+  TidyUp ();\n+}"}, {"sha": "a3030f2d9a147fdda34b36d9690d86a418b4e67b", "filename": "gcc/m2/mc-boot/GRTint.cc", "status": "added", "additions": 1106, "deletions": 0, "changes": 1106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGRTint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGRTint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGRTint.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,1106 @@\n+/* do not edit automatically generated by mc from RTint.  */\n+/* RTint.mod provides users of the COROUTINES library with the.\n+\n+Copyright (C) 2009-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#   if !defined (TRUE)\n+#      define TRUE (1==1)\n+#   endif\n+\n+#   if !defined (FALSE)\n+#      define FALSE (1==0)\n+#   endif\n+\n+#   include \"GStorage.h\"\n+#   include \"Gmcrts.h\"\n+#if defined(__cplusplus)\n+#   undef NULL\n+#   define NULL 0\n+#endif\n+#define _RTint_H\n+#define _RTint_C\n+\n+#   include \"GM2RTS.h\"\n+#   include \"GStorage.h\"\n+#   include \"GRTco.h\"\n+#   include \"GCOROUTINES.h\"\n+#   include \"Glibc.h\"\n+#   include \"GAssertion.h\"\n+#   include \"GSelective.h\"\n+\n+typedef struct RTint_DispatchVector_p RTint_DispatchVector;\n+\n+#   define Microseconds 1000000\n+#   define DebugTime 0\n+#   define Debugging FALSE\n+typedef struct RTint__T1_r RTint__T1;\n+\n+typedef RTint__T1 *RTint_Vector;\n+\n+typedef struct RTint__T2_a RTint__T2;\n+\n+typedef enum {RTint_input, RTint_output, RTint_time} RTint_VectorType;\n+\n+typedef void (*RTint_DispatchVector_t) (unsigned int, unsigned int, void *);\n+struct RTint_DispatchVector_p { RTint_DispatchVector_t proc; };\n+\n+struct RTint__T1_r {\n+                     RTint_VectorType type;\n+                     unsigned int priority;\n+                     void *arg;\n+                     RTint_Vector pending;\n+                     RTint_Vector exists;\n+                     unsigned int no;\n+                     int File;\n+                     Selective_Timeval rel;\n+                     Selective_Timeval abs_;\n+                     unsigned int queued;\n+                   };\n+\n+struct RTint__T2_a { RTint_Vector array[(7)-(COROUTINES_UnassignedPriority)+1]; };\n+static unsigned int VecNo;\n+static RTint_Vector Exists;\n+static RTint__T2 Pending;\n+static int lock;\n+static unsigned int initialized;\n+\n+/*\n+   InitInputVector - returns an interrupt vector which is associated\n+                     with the file descriptor, fd.\n+*/\n+\n+extern \"C\" unsigned int RTint_InitInputVector (int fd, unsigned int pri);\n+\n+/*\n+   InitOutputVector - returns an interrupt vector which is associated\n+                      with the file descriptor, fd.\n+*/\n+\n+extern \"C\" unsigned int RTint_InitOutputVector (int fd, unsigned int pri);\n+\n+/*\n+   InitTimeVector - returns an interrupt vector associated with\n+                    the relative time.\n+*/\n+\n+extern \"C\" unsigned int RTint_InitTimeVector (unsigned int micro, unsigned int secs, unsigned int pri);\n+\n+/*\n+   ReArmTimeVector - reprimes the vector, vec, to deliver an interrupt\n+                     at the new relative time.\n+*/\n+\n+extern \"C\" void RTint_ReArmTimeVector (unsigned int vec, unsigned int micro, unsigned int secs);\n+\n+/*\n+   GetTimeVector - assigns, micro, and, secs, with the remaining\n+                   time before this interrupt will expire.\n+                   This value is only updated when a Listen\n+                   occurs.\n+*/\n+\n+extern \"C\" void RTint_GetTimeVector (unsigned int vec, unsigned int *micro, unsigned int *secs);\n+\n+/*\n+   AttachVector - adds the pointer ptr to be associated with the interrupt\n+                  vector. It returns the previous value attached to this\n+                  vector.\n+*/\n+\n+extern \"C\" void * RTint_AttachVector (unsigned int vec, void * ptr);\n+\n+/*\n+   IncludeVector - includes, vec, into the dispatcher list of\n+                   possible interrupt causes.\n+*/\n+\n+extern \"C\" void RTint_IncludeVector (unsigned int vec);\n+\n+/*\n+   ExcludeVector - excludes, vec, from the dispatcher list of\n+                   possible interrupt causes.\n+*/\n+\n+extern \"C\" void RTint_ExcludeVector (unsigned int vec);\n+\n+/*\n+   Listen - will either block indefinitely (until an interrupt)\n+            or alteratively will test to see whether any interrupts\n+            are pending.\n+            If a pending interrupt was found then, call, is called\n+            and then this procedure returns.\n+            It only listens for interrupts > pri.\n+*/\n+\n+extern \"C\" void RTint_Listen (unsigned int untilInterrupt, RTint_DispatchVector call, unsigned int pri);\n+\n+/*\n+   Init -\n+*/\n+\n+extern \"C\" void RTint_Init (void);\n+\n+/*\n+   Max - returns the maximum: i or j.\n+*/\n+\n+static int Max (int i, int j);\n+static int Min (int i, int j);\n+\n+/*\n+   FindVector - searches the exists list for a vector of type\n+                which is associated with file descriptor, fd.\n+*/\n+\n+static RTint_Vector FindVector (int fd, RTint_VectorType type);\n+\n+/*\n+   FindVectorNo - searches the Exists list for vector vec.\n+*/\n+\n+static RTint_Vector FindVectorNo (unsigned int vec);\n+\n+/*\n+   FindPendingVector - searches the pending list for vector, vec.\n+*/\n+\n+static RTint_Vector FindPendingVector (unsigned int vec);\n+\n+/*\n+   AddFd - adds the file descriptor fd to set updating max.\n+*/\n+\n+static void AddFd (Selective_SetOfFd *set, int *max, int fd);\n+\n+/*\n+   DumpPendingQueue - displays the pending queue.\n+*/\n+\n+static void DumpPendingQueue (void);\n+\n+/*\n+   AddTime - t1 := t1 + t2\n+*/\n+\n+static void AddTime (Selective_Timeval t1, Selective_Timeval t2);\n+\n+/*\n+   IsGreaterEqual - returns TRUE if, a>=b\n+*/\n+\n+static unsigned int IsGreaterEqual (Selective_Timeval a, Selective_Timeval b);\n+\n+/*\n+   SubTime - assigns, s and m, to a - b.\n+*/\n+\n+static void SubTime (unsigned int *s, unsigned int *m, Selective_Timeval a, Selective_Timeval b);\n+\n+/*\n+   activatePending - activates the first interrupt pending and clears it.\n+*/\n+\n+static unsigned int activatePending (unsigned int untilInterrupt, RTint_DispatchVector call, unsigned int pri, int maxFd, Selective_SetOfFd *inSet, Selective_SetOfFd *outSet, Selective_Timeval *timeval, Selective_Timeval b4, Selective_Timeval after);\n+\n+/*\n+   init -\n+*/\n+\n+static void init (void);\n+\n+\n+/*\n+   Max - returns the maximum: i or j.\n+*/\n+\n+static int Max (int i, int j)\n+{\n+  if (i > j)\n+    {\n+      return i;\n+    }\n+  else\n+    {\n+      return j;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+static int Min (int i, int j)\n+{\n+  /* \n+   Max - returns the minimum: i or j.\n+  */\n+  if (i < j)\n+    {\n+      return i;\n+    }\n+  else\n+    {\n+      return j;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   FindVector - searches the exists list for a vector of type\n+                which is associated with file descriptor, fd.\n+*/\n+\n+static RTint_Vector FindVector (int fd, RTint_VectorType type)\n+{\n+  RTint_Vector vec;\n+\n+  vec = Exists;\n+  while (vec != NULL)\n+    {\n+      if ((vec->type == type) && (vec->File == fd))\n+        {\n+          return vec;\n+        }\n+      vec = vec->exists;\n+    }\n+  return NULL;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   FindVectorNo - searches the Exists list for vector vec.\n+*/\n+\n+static RTint_Vector FindVectorNo (unsigned int vec)\n+{\n+  RTint_Vector vptr;\n+\n+  vptr = Exists;\n+  while ((vptr != NULL) && (vptr->no != vec))\n+    {\n+      vptr = vptr->exists;\n+    }\n+  return vptr;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   FindPendingVector - searches the pending list for vector, vec.\n+*/\n+\n+static RTint_Vector FindPendingVector (unsigned int vec)\n+{\n+  unsigned int pri;\n+  RTint_Vector vptr;\n+\n+  for (pri=COROUTINES_UnassignedPriority; pri<=7; pri++)\n+    {\n+      vptr = Pending.array[pri-(COROUTINES_UnassignedPriority)];\n+      while ((vptr != NULL) && (vptr->no != vec))\n+        {\n+          vptr = vptr->pending;\n+        }\n+      if ((vptr != NULL) && (vptr->no == vec))\n+        {\n+          return vptr;\n+        }\n+    }\n+  return NULL;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   AddFd - adds the file descriptor fd to set updating max.\n+*/\n+\n+static void AddFd (Selective_SetOfFd *set, int *max, int fd)\n+{\n+  (*max) = Max (fd, (*max));\n+  if ((*set) == NULL)\n+    {\n+      (*set) = Selective_InitSet ();\n+      Selective_FdZero ((*set));\n+    }\n+  /* printf('%d, ', fd)  */\n+  Selective_FdSet (fd, (*set));\n+}\n+\n+\n+/*\n+   DumpPendingQueue - displays the pending queue.\n+*/\n+\n+static void DumpPendingQueue (void)\n+{\n+  COROUTINES_PROTECTION pri;\n+  RTint_Vector vptr;\n+  unsigned int sec;\n+  unsigned int micro;\n+\n+  libc_printf ((const char *) \"Pending queue\\\\n\", 15);\n+  for (pri=COROUTINES_UnassignedPriority; pri<=7; pri++)\n+    {\n+      libc_printf ((const char *) \"[%d]  \", 6, pri);\n+      vptr = Pending.array[pri-(COROUTINES_UnassignedPriority)];\n+      while (vptr != NULL)\n+        {\n+          if ((vptr->type == RTint_input) || (vptr->type == RTint_output))\n+            {\n+              libc_printf ((const char *) \"(fd=%d) (vec=%d)\", 16, vptr->File, vptr->no);\n+            }\n+          else if (vptr->type == RTint_time)\n+            {\n+              /* avoid dangling else.  */\n+              Selective_GetTime (vptr->rel, &sec, &micro);\n+              Assertion_Assert (micro < Microseconds);\n+              libc_printf ((const char *) \"time (%u.%06u secs) (arg = %p)\\\\n\", 32, sec, micro, vptr->arg);\n+            }\n+          vptr = vptr->pending;\n+        }\n+      libc_printf ((const char *) \" \\\\n\", 3);\n+    }\n+}\n+\n+\n+/*\n+   AddTime - t1 := t1 + t2\n+*/\n+\n+static void AddTime (Selective_Timeval t1, Selective_Timeval t2)\n+{\n+  unsigned int a;\n+  unsigned int b;\n+  unsigned int s;\n+  unsigned int m;\n+\n+  Selective_GetTime (t1, &s, &m);\n+  Assertion_Assert (m < Microseconds);\n+  Selective_GetTime (t2, &a, &b);\n+  Assertion_Assert (b < Microseconds);\n+  a += s;\n+  b += m;\n+  if (b >= Microseconds)\n+    {\n+      b -= Microseconds;\n+      a += 1;\n+    }\n+  Selective_SetTime (t1, a, b);\n+}\n+\n+\n+/*\n+   IsGreaterEqual - returns TRUE if, a>=b\n+*/\n+\n+static unsigned int IsGreaterEqual (Selective_Timeval a, Selective_Timeval b)\n+{\n+  unsigned int as;\n+  unsigned int am;\n+  unsigned int bs;\n+  unsigned int bm;\n+\n+  Selective_GetTime (a, &as, &am);\n+  Assertion_Assert (am < Microseconds);\n+  Selective_GetTime (b, &bs, &bm);\n+  Assertion_Assert (bm < Microseconds);\n+  return (as > bs) || ((as == bs) && (am >= bm));\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   SubTime - assigns, s and m, to a - b.\n+*/\n+\n+static void SubTime (unsigned int *s, unsigned int *m, Selective_Timeval a, Selective_Timeval b)\n+{\n+  unsigned int as;\n+  unsigned int am;\n+  unsigned int bs;\n+  unsigned int bm;\n+\n+  Selective_GetTime (a, &as, &am);\n+  Assertion_Assert (am < Microseconds);\n+  Selective_GetTime (b, &bs, &bm);\n+  Assertion_Assert (bm < Microseconds);\n+  if (IsGreaterEqual (a, b))\n+    {\n+      (*s) = as-bs;\n+      if (am >= bm)\n+        {\n+          (*m) = am-bm;\n+          Assertion_Assert ((*m) < Microseconds);\n+        }\n+      else\n+        {\n+          Assertion_Assert ((*s) > 0);\n+          (*s) -= 1;\n+          (*m) = (Microseconds+am)-bm;\n+          Assertion_Assert ((*m) < Microseconds);\n+        }\n+    }\n+  else\n+    {\n+      (*s) = 0;\n+      (*m) = 0;\n+    }\n+}\n+\n+\n+/*\n+   activatePending - activates the first interrupt pending and clears it.\n+*/\n+\n+static unsigned int activatePending (unsigned int untilInterrupt, RTint_DispatchVector call, unsigned int pri, int maxFd, Selective_SetOfFd *inSet, Selective_SetOfFd *outSet, Selective_Timeval *timeval, Selective_Timeval b4, Selective_Timeval after)\n+{\n+  int result;\n+  unsigned int p;\n+  RTint_Vector vec;\n+  unsigned int b4s;\n+  unsigned int b4m;\n+  unsigned int afs;\n+  unsigned int afm;\n+  unsigned int sec;\n+  unsigned int micro;\n+\n+  RTco_wait (lock);\n+  p = static_cast<unsigned int> (7);\n+  while (p > pri)\n+    {\n+      vec = Pending.array[p-(COROUTINES_UnassignedPriority)];\n+      while (vec != NULL)\n+        {\n+          switch (vec->type)\n+            {\n+              case RTint_input:\n+                if (((vec->File < maxFd) && ((*inSet) != NULL)) && (Selective_FdIsSet (vec->File, (*inSet))))\n+                  {\n+                    if (Debugging)\n+                      {\n+                        libc_printf ((const char *) \"read (fd=%d) is ready (vec=%d)\\\\n\", 32, vec->File, vec->no);\n+                        DumpPendingQueue ();\n+                      }\n+                    Selective_FdClr (vec->File, (*inSet));  /* so we dont activate this again from our select.  */\n+                    RTco_signal (lock);  /* so we dont activate this again from our select.  */\n+                    (*call.proc) (vec->no, vec->priority, vec->arg);\n+                    return TRUE;\n+                  }\n+                break;\n+\n+              case RTint_output:\n+                if (((vec->File < maxFd) && ((*outSet) != NULL)) && (Selective_FdIsSet (vec->File, (*outSet))))\n+                  {\n+                    if (Debugging)\n+                      {\n+                        libc_printf ((const char *) \"write (fd=%d) is ready (vec=%d)\\\\n\", 33, vec->File, vec->no);\n+                        DumpPendingQueue ();\n+                      }\n+                    Selective_FdClr (vec->File, (*outSet));  /* so we dont activate this again from our select.  */\n+                    RTco_signal (lock);  /* so we dont activate this again from our select.  */\n+                    (*call.proc) (vec->no, vec->priority, vec->arg);\n+                    return TRUE;\n+                  }\n+                break;\n+\n+              case RTint_time:\n+                if (untilInterrupt && ((*timeval) != NULL))\n+                  {\n+                    result = Selective_GetTimeOfDay (after);\n+                    Assertion_Assert (result == 0);\n+                    if (Debugging)\n+                      {\n+                        Selective_GetTime ((*timeval), &sec, &micro);\n+                        Assertion_Assert (micro < Microseconds);\n+                        Selective_GetTime (after, &afs, &afm);\n+                        Assertion_Assert (afm < Microseconds);\n+                        Selective_GetTime (b4, &b4s, &b4m);\n+                        Assertion_Assert (b4m < Microseconds);\n+                        libc_printf ((const char *) \"waited %u.%06u + %u.%06u now is %u.%06u\\\\n\", 41, sec, micro, b4s, b4m, afs, afm);\n+                      }\n+                    if (IsGreaterEqual (after, vec->abs_))\n+                      {\n+                        if (Debugging)\n+                          {\n+                            DumpPendingQueue ();\n+                            libc_printf ((const char *) \"time has expired calling dispatcher\\\\n\", 37);\n+                          }\n+                        (*timeval) = Selective_KillTime ((*timeval));  /* so we dont activate this again from our select.  */\n+                        RTco_signal (lock);  /* so we dont activate this again from our select.  */\n+                        if (Debugging)\n+                          {\n+                            libc_printf ((const char *) \"call (%d, %d, 0x%x)\\\\n\", 21, vec->no, vec->priority, vec->arg);\n+                          }\n+                        (*call.proc) (vec->no, vec->priority, vec->arg);\n+                        return TRUE;\n+                      }\n+                    else if (Debugging)\n+                      {\n+                        /* avoid dangling else.  */\n+                        libc_printf ((const char *) \"must wait longer as time has not expired\\\\n\", 42);\n+                      }\n+                  }\n+                break;\n+\n+\n+              default:\n+                CaseException (\"../../gcc-read-write/gcc/m2/gm2-libs/RTint.def\", 25, 1);\n+                __builtin_unreachable ();\n+            }\n+          vec = vec->pending;\n+        }\n+      p -= 1;\n+    }\n+  RTco_signal (lock);\n+  return FALSE;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   init -\n+*/\n+\n+static void init (void)\n+{\n+  COROUTINES_PROTECTION p;\n+\n+  lock = RTco_initSemaphore (1);\n+  RTco_wait (lock);\n+  Exists = NULL;\n+  for (p=COROUTINES_UnassignedPriority; p<=7; p++)\n+    {\n+      Pending.array[p-(COROUTINES_UnassignedPriority)] = NULL;\n+    }\n+  initialized = TRUE;\n+  RTco_signal (lock);\n+}\n+\n+\n+/*\n+   InitInputVector - returns an interrupt vector which is associated\n+                     with the file descriptor, fd.\n+*/\n+\n+extern \"C\" unsigned int RTint_InitInputVector (int fd, unsigned int pri)\n+{\n+  RTint_Vector vptr;\n+\n+  if (Debugging)\n+    {\n+      libc_printf ((const char *) \"InitInputVector fd = %d priority = %d\\\\n\", 39, fd, pri);\n+    }\n+  RTco_wait (lock);\n+  vptr = FindVector (fd, RTint_input);\n+  if (vptr == NULL)\n+    {\n+      Storage_ALLOCATE ((void **) &vptr, sizeof (RTint__T1));\n+      VecNo += 1;\n+      vptr->type = RTint_input;\n+      vptr->priority = pri;\n+      vptr->arg = NULL;\n+      vptr->pending = NULL;\n+      vptr->exists = Exists;\n+      vptr->no = VecNo;\n+      vptr->File = fd;\n+      Exists = vptr;\n+      RTco_signal (lock);\n+      return VecNo;\n+    }\n+  else\n+    {\n+      RTco_signal (lock);\n+      return vptr->no;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   InitOutputVector - returns an interrupt vector which is associated\n+                      with the file descriptor, fd.\n+*/\n+\n+extern \"C\" unsigned int RTint_InitOutputVector (int fd, unsigned int pri)\n+{\n+  RTint_Vector vptr;\n+\n+  RTco_wait (lock);\n+  vptr = FindVector (fd, RTint_output);\n+  if (vptr == NULL)\n+    {\n+      Storage_ALLOCATE ((void **) &vptr, sizeof (RTint__T1));\n+      if (vptr == NULL)\n+        {\n+          M2RTS_HALT (-1);\n+          __builtin_unreachable ();\n+        }\n+      else\n+        {\n+          VecNo += 1;\n+          vptr->type = RTint_output;\n+          vptr->priority = pri;\n+          vptr->arg = NULL;\n+          vptr->pending = NULL;\n+          vptr->exists = Exists;\n+          vptr->no = VecNo;\n+          vptr->File = fd;\n+          Exists = vptr;\n+          RTco_signal (lock);\n+          return VecNo;\n+        }\n+    }\n+  else\n+    {\n+      RTco_signal (lock);\n+      return vptr->no;\n+    }\n+  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/RTint.def\", 25, 1);\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   InitTimeVector - returns an interrupt vector associated with\n+                    the relative time.\n+*/\n+\n+extern \"C\" unsigned int RTint_InitTimeVector (unsigned int micro, unsigned int secs, unsigned int pri)\n+{\n+  RTint_Vector vptr;\n+\n+  RTco_wait (lock);\n+  Storage_ALLOCATE ((void **) &vptr, sizeof (RTint__T1));\n+  if (vptr == NULL)\n+    {\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n+    }\n+  else\n+    {\n+      VecNo += 1;\n+      Assertion_Assert (micro < Microseconds);\n+      vptr->type = RTint_time;\n+      vptr->priority = pri;\n+      vptr->arg = NULL;\n+      vptr->pending = NULL;\n+      vptr->exists = Exists;\n+      vptr->no = VecNo;\n+      vptr->rel = Selective_InitTime (secs+DebugTime, micro);\n+      vptr->abs_ = Selective_InitTime (0, 0);\n+      vptr->queued = FALSE;\n+      Exists = vptr;\n+    }\n+  RTco_signal (lock);\n+  return VecNo;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   ReArmTimeVector - reprimes the vector, vec, to deliver an interrupt\n+                     at the new relative time.\n+*/\n+\n+extern \"C\" void RTint_ReArmTimeVector (unsigned int vec, unsigned int micro, unsigned int secs)\n+{\n+  RTint_Vector vptr;\n+\n+  Assertion_Assert (micro < Microseconds);\n+  RTco_wait (lock);\n+  vptr = FindVectorNo (vec);\n+  if (vptr == NULL)\n+    {\n+      M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTint.mod\", 46, 286, (const char *) \"ReArmTimeVector\", 15, (const char *) \"cannot find vector supplied\", 27);\n+    }\n+  else\n+    {\n+      Selective_SetTime (vptr->rel, secs+DebugTime, micro);\n+    }\n+  RTco_signal (lock);\n+}\n+\n+\n+/*\n+   GetTimeVector - assigns, micro, and, secs, with the remaining\n+                   time before this interrupt will expire.\n+                   This value is only updated when a Listen\n+                   occurs.\n+*/\n+\n+extern \"C\" void RTint_GetTimeVector (unsigned int vec, unsigned int *micro, unsigned int *secs)\n+{\n+  RTint_Vector vptr;\n+\n+  RTco_wait (lock);\n+  vptr = FindVectorNo (vec);\n+  if (vptr == NULL)\n+    {\n+      M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTint.mod\", 46, 312, (const char *) \"GetTimeVector\", 13, (const char *) \"cannot find vector supplied\", 27);\n+    }\n+  else\n+    {\n+      Selective_GetTime (vptr->rel, secs, micro);\n+      Assertion_Assert ((*micro) < Microseconds);\n+    }\n+  RTco_signal (lock);\n+}\n+\n+\n+/*\n+   AttachVector - adds the pointer ptr to be associated with the interrupt\n+                  vector. It returns the previous value attached to this\n+                  vector.\n+*/\n+\n+extern \"C\" void * RTint_AttachVector (unsigned int vec, void * ptr)\n+{\n+  RTint_Vector vptr;\n+  void * prevArg;\n+\n+  RTco_wait (lock);\n+  vptr = FindVectorNo (vec);\n+  if (vptr == NULL)\n+    {\n+      M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTint.mod\", 46, 339, (const char *) \"AttachVector\", 12, (const char *) \"cannot find vector supplied\", 27);\n+    }\n+  else\n+    {\n+      prevArg = vptr->arg;\n+      vptr->arg = ptr;\n+      if (Debugging)\n+        {\n+          libc_printf ((const char *) \"AttachVector %d with %p\\\\n\", 25, vec, ptr);\n+          DumpPendingQueue ();\n+        }\n+      RTco_signal (lock);\n+      return prevArg;\n+    }\n+  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/RTint.def\", 25, 1);\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   IncludeVector - includes, vec, into the dispatcher list of\n+                   possible interrupt causes.\n+*/\n+\n+extern \"C\" void RTint_IncludeVector (unsigned int vec)\n+{\n+  RTint_Vector vptr;\n+  unsigned int micro;\n+  unsigned int sec;\n+  int result;\n+\n+  RTco_wait (lock);\n+  vptr = FindPendingVector (vec);\n+  if (vptr == NULL)\n+    {\n+      /* avoid dangling else.  */\n+      vptr = FindVectorNo (vec);\n+      if (vptr == NULL)\n+        {\n+          M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTint.mod\", 46, 372, (const char *) \"IncludeVector\", 13, (const char *) \"cannot find vector supplied\", 27);\n+        }\n+      else\n+        {\n+          /* printf('including vector %d  (fd = %d)\n+          ', vec, v^.File) ;  */\n+          vptr->pending = Pending.array[vptr->priority-(COROUTINES_UnassignedPriority)];\n+          Pending.array[vptr->priority-(COROUTINES_UnassignedPriority)] = vptr;\n+          if ((vptr->type == RTint_time) && ! vptr->queued)\n+            {\n+              vptr->queued = TRUE;\n+              result = Selective_GetTimeOfDay (vptr->abs_);\n+              Assertion_Assert (result == 0);\n+              Selective_GetTime (vptr->abs_, &sec, &micro);\n+              Assertion_Assert (micro < Microseconds);\n+              AddTime (vptr->abs_, vptr->rel);\n+              Selective_GetTime (vptr->abs_, &sec, &micro);\n+              Assertion_Assert (micro < Microseconds);\n+            }\n+        }\n+    }\n+  else\n+    {\n+      if (Debugging)\n+        {\n+          libc_printf ((const char *) \"odd vector (%d) type (%d) arg (%p) is already attached to the pending queue\\\\n\", 77, vec, vptr->type, vptr->arg);\n+        }\n+    }\n+  RTco_signal (lock);\n+}\n+\n+\n+/*\n+   ExcludeVector - excludes, vec, from the dispatcher list of\n+                   possible interrupt causes.\n+*/\n+\n+extern \"C\" void RTint_ExcludeVector (unsigned int vec)\n+{\n+  RTint_Vector vptr;\n+  RTint_Vector uptr;\n+\n+  RTco_wait (lock);\n+  vptr = FindPendingVector (vec);\n+  if (vptr == NULL)\n+    {\n+      M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTint.mod\", 46, 414, (const char *) \"ExcludeVector\", 13, (const char *) \"cannot find pending vector supplied\", 35);\n+    }\n+  else\n+    {\n+      /* printf('excluding vector %d\n+      ', vec) ;  */\n+      if (Pending.array[vptr->priority-(COROUTINES_UnassignedPriority)] == vptr)\n+        {\n+          Pending.array[vptr->priority-(COROUTINES_UnassignedPriority)] = Pending.array[vptr->priority-(COROUTINES_UnassignedPriority)]->pending;\n+        }\n+      else\n+        {\n+          uptr = Pending.array[vptr->priority-(COROUTINES_UnassignedPriority)];\n+          while (uptr->pending != vptr)\n+            {\n+              uptr = uptr->pending;\n+            }\n+          uptr->pending = vptr->pending;\n+        }\n+      if (vptr->type == RTint_time)\n+        {\n+          vptr->queued = FALSE;\n+        }\n+    }\n+  RTco_signal (lock);\n+}\n+\n+\n+/*\n+   Listen - will either block indefinitely (until an interrupt)\n+            or alteratively will test to see whether any interrupts\n+            are pending.\n+            If a pending interrupt was found then, call, is called\n+            and then this procedure returns.\n+            It only listens for interrupts > pri.\n+*/\n+\n+extern \"C\" void RTint_Listen (unsigned int untilInterrupt, RTint_DispatchVector call, unsigned int pri)\n+{\n+  unsigned int found;\n+  int result;\n+  Selective_Timeval after;\n+  Selective_Timeval b4;\n+  Selective_Timeval timeval;\n+  RTint_Vector vec;\n+  Selective_SetOfFd inSet;\n+  Selective_SetOfFd outSet;\n+  unsigned int b4s;\n+  unsigned int b4m;\n+  unsigned int afs;\n+  unsigned int afm;\n+  unsigned int sec;\n+  unsigned int micro;\n+  int maxFd;\n+  unsigned int p;\n+\n+  RTco_wait (lock);\n+  if (pri < (7))\n+    {\n+      if (Debugging)\n+        {\n+          DumpPendingQueue ();\n+        }\n+      maxFd = -1;\n+      timeval = NULL;\n+      inSet = NULL;\n+      outSet = NULL;\n+      timeval = Selective_InitTime (static_cast<unsigned int> (INT_MAX), 0);\n+      p = static_cast<unsigned int> (7);\n+      found = FALSE;\n+      while (p > pri)\n+        {\n+          vec = Pending.array[p-(COROUTINES_UnassignedPriority)];\n+          while (vec != NULL)\n+            {\n+              switch (vec->type)\n+                {\n+                  case RTint_input:\n+                    AddFd (&inSet, &maxFd, vec->File);\n+                    break;\n+\n+                  case RTint_output:\n+                    AddFd (&outSet, &maxFd, vec->File);\n+                    break;\n+\n+                  case RTint_time:\n+                    if (IsGreaterEqual (timeval, vec->abs_))\n+                      {\n+                        Selective_GetTime (vec->abs_, &sec, &micro);\n+                        Assertion_Assert (micro < Microseconds);\n+                        if (Debugging)\n+                          {\n+                            libc_printf ((const char *) \"shortest delay is %u.%06u\\\\n\", 27, sec, micro);\n+                          }\n+                        Selective_SetTime (timeval, sec, micro);\n+                        found = TRUE;\n+                      }\n+                    break;\n+\n+\n+                  default:\n+                    CaseException (\"../../gcc-read-write/gcc/m2/gm2-libs/RTint.def\", 25, 1);\n+                    __builtin_unreachable ();\n+                }\n+              vec = vec->pending;\n+            }\n+          p -= 1;\n+        }\n+      if (! untilInterrupt)\n+        {\n+          Selective_SetTime (timeval, 0, 0);\n+        }\n+      if (((untilInterrupt && (inSet == NULL)) && (outSet == NULL)) && ! found)\n+        {\n+          M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTint.mod\", 46, 730, (const char *) \"Listen\", 6, (const char *) \"deadlock found, no more processes to run and no interrupts active\", 65);\n+        }\n+      /* printf('}\n+      ') ;  */\n+      if (((! found && (maxFd == -1)) && (inSet == NULL)) && (outSet == NULL))\n+        {\n+          /* no file descriptors to be selected upon.  */\n+          timeval = Selective_KillTime (timeval);\n+          RTco_signal (lock);\n+          return ;\n+        }\n+      else\n+        {\n+          Selective_GetTime (timeval, &sec, &micro);\n+          Assertion_Assert (micro < Microseconds);\n+          b4 = Selective_InitTime (0, 0);\n+          after = Selective_InitTime (0, 0);\n+          result = Selective_GetTimeOfDay (b4);\n+          Assertion_Assert (result == 0);\n+          SubTime (&sec, &micro, timeval, b4);\n+          Selective_SetTime (timeval, sec, micro);\n+          if (Debugging)\n+            {\n+              libc_printf ((const char *) \"select waiting for %u.%06u seconds\\\\n\", 36, sec, micro);\n+            }\n+          RTco_signal (lock);\n+          do {\n+            if (Debugging)\n+              {\n+                libc_printf ((const char *) \"select (.., .., .., %u.%06u)\\\\n\", 30, sec, micro);\n+              }\n+            result = RTco_select (maxFd+1, inSet, outSet, NULL, timeval);\n+            if (result == -1)\n+              {\n+                libc_perror ((const char *) \"select\", 6);\n+                result = RTco_select (maxFd+1, inSet, outSet, NULL, NULL);\n+                if (result == -1)\n+                  {\n+                    libc_perror ((const char *) \"select timeout argument is faulty\", 33);\n+                  }\n+                result = RTco_select (maxFd+1, inSet, NULL, NULL, timeval);\n+                if (result == -1)\n+                  {\n+                    libc_perror ((const char *) \"select output fd argument is faulty\", 35);\n+                  }\n+                result = RTco_select (maxFd+1, NULL, outSet, NULL, timeval);\n+                if (result == -1)\n+                  {\n+                    libc_perror ((const char *) \"select input fd argument is faulty\", 34);\n+                  }\n+                else\n+                  {\n+                    libc_perror ((const char *) \"select maxFD+1 argument is faulty\", 33);\n+                  }\n+              }\n+          } while (! (result != -1));\n+        }\n+      while (activatePending (untilInterrupt, call, pri, maxFd+1, &inSet, &outSet, &timeval, b4, after))\n+        {}  /* empty.  */\n+      if (timeval != NULL)\n+        {\n+          timeval = Selective_KillTime (timeval);\n+        }\n+      if (after != NULL)\n+        {\n+          after = Selective_KillTime (after);\n+        }\n+      if (b4 != NULL)\n+        {\n+          b4 = Selective_KillTime (b4);\n+        }\n+      if (inSet != NULL)\n+        {\n+          inSet = Selective_KillSet (inSet);\n+        }\n+      if (outSet != NULL)\n+        {\n+          outSet = Selective_KillSet (outSet);\n+        }\n+    }\n+  RTco_signal (lock);\n+}\n+\n+\n+/*\n+   Init -\n+*/\n+\n+extern \"C\" void RTint_Init (void)\n+{\n+  if (! initialized)\n+    {\n+      init ();\n+    }\n+}\n+\n+extern \"C\" void _M2_RTint_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+  RTint_Init ();\n+}\n+\n+extern \"C\" void _M2_RTint_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "143d2783c16e18091b22a37e39580cbfe23360e4", "filename": "gcc/m2/mc-boot/GSArgs.cc", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGSArgs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGSArgs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGSArgs.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,125 @@\n+/* do not edit automatically generated by mc from SArgs.  */\n+/* SArgs.mod provides a String interface to the command line arguments.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#   if !defined (TRUE)\n+#      define TRUE (1==1)\n+#   endif\n+\n+#   if !defined (FALSE)\n+#      define FALSE (1==0)\n+#   endif\n+\n+#if defined(__cplusplus)\n+#   undef NULL\n+#   define NULL 0\n+#endif\n+#define _SArgs_H\n+#define _SArgs_C\n+\n+#   include \"GSYSTEM.h\"\n+#   include \"GUnixArgs.h\"\n+#   include \"GDynamicStrings.h\"\n+\n+typedef char *SArgs_PtrToChar;\n+\n+typedef SArgs_PtrToChar *SArgs_PtrToPtrToChar;\n+\n+\n+/*\n+   GetArg - returns the nth argument from the command line.\n+            The success of the operation is returned.\n+            If TRUE is returned then the string, s, contains a\n+            new string, otherwise s is set to NIL.\n+*/\n+\n+extern \"C\" unsigned int SArgs_GetArg (DynamicStrings_String *s, unsigned int n);\n+\n+/*\n+   Narg - returns the number of arguments available from\n+          command line.\n+*/\n+\n+extern \"C\" unsigned int SArgs_Narg (void);\n+\n+\n+/*\n+   GetArg - returns the nth argument from the command line.\n+            The success of the operation is returned.\n+            If TRUE is returned then the string, s, contains a\n+            new string, otherwise s is set to NIL.\n+*/\n+\n+extern \"C\" unsigned int SArgs_GetArg (DynamicStrings_String *s, unsigned int n)\n+{\n+  int i;\n+  SArgs_PtrToPtrToChar ppc;\n+\n+  i = (int ) (n);\n+  if (i < (UnixArgs_GetArgC ()))\n+    {\n+      /* ppc := ADDRESS (VAL (PtrToPtrToChar, ArgV) + (i * CARDINAL (TSIZE(PtrToChar)))) ;  */\n+      ppc = static_cast<SArgs_PtrToPtrToChar> ((void *) (((SArgs_PtrToChar) (UnixArgs_GetArgV ()))+(n*sizeof (SArgs_PtrToChar))));\n+      (*s) = DynamicStrings_InitStringCharStar (reinterpret_cast<void *> ((*ppc)));\n+      return TRUE;\n+    }\n+  else\n+    {\n+      (*s) = static_cast<DynamicStrings_String> (NULL);\n+      return FALSE;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Narg - returns the number of arguments available from\n+          command line.\n+*/\n+\n+extern \"C\" unsigned int SArgs_Narg (void)\n+{\n+  return UnixArgs_GetArgC ();\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" void _M2_SArgs_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}\n+\n+extern \"C\" void _M2_SArgs_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "1a800138812c9895dee4a0d5a5d7a1072da13d81", "filename": "gcc/m2/mc-boot/GSFIO.cc", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGSFIO.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGSFIO.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGSFIO.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,216 @@\n+/* do not edit automatically generated by mc from SFIO.  */\n+/* SFIO.mod provides a String interface to the opening routines of FIO.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#if defined(__cplusplus)\n+#   undef NULL\n+#   define NULL 0\n+#endif\n+#define _SFIO_H\n+#define _SFIO_C\n+\n+#   include \"GASCII.h\"\n+#   include \"GDynamicStrings.h\"\n+#   include \"GFIO.h\"\n+\n+\n+/*\n+   Exists - returns TRUE if a file named, fname exists for reading.\n+*/\n+\n+extern \"C\" unsigned int SFIO_Exists (DynamicStrings_String fname);\n+\n+/*\n+   OpenToRead - attempts to open a file, fname, for reading and\n+                it returns this file.\n+                The success of this operation can be checked by\n+                calling IsNoError.\n+*/\n+\n+extern \"C\" FIO_File SFIO_OpenToRead (DynamicStrings_String fname);\n+\n+/*\n+   OpenToWrite - attempts to open a file, fname, for write and\n+                 it returns this file.\n+                 The success of this operation can be checked by\n+                 calling IsNoError.\n+*/\n+\n+extern \"C\" FIO_File SFIO_OpenToWrite (DynamicStrings_String fname);\n+\n+/*\n+   OpenForRandom - attempts to open a file, fname, for random access\n+                   read or write and it returns this file.\n+                   The success of this operation can be checked by\n+                   calling IsNoError.\n+                   towrite, determines whether the file should be\n+                   opened for writing or reading.\n+                   if towrite is TRUE or whether the previous file should\n+                   be left alone, allowing this descriptor to seek\n+                   and modify an existing file.\n+*/\n+\n+extern \"C\" FIO_File SFIO_OpenForRandom (DynamicStrings_String fname, unsigned int towrite, unsigned int newfile);\n+\n+/*\n+   WriteS - writes a string, s, to, file. It returns the String, s.\n+*/\n+\n+extern \"C\" DynamicStrings_String SFIO_WriteS (FIO_File file, DynamicStrings_String s);\n+\n+/*\n+   ReadS - reads and returns a string from, file.\n+           It stops reading the string at the end of line or end of file.\n+           It consumes the newline at the end of line but does not place\n+           this into the returned string.\n+*/\n+\n+extern \"C\" DynamicStrings_String SFIO_ReadS (FIO_File file);\n+\n+\n+/*\n+   Exists - returns TRUE if a file named, fname exists for reading.\n+*/\n+\n+extern \"C\" unsigned int SFIO_Exists (DynamicStrings_String fname)\n+{\n+  return FIO_exists (DynamicStrings_string (fname), DynamicStrings_Length (fname));\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   OpenToRead - attempts to open a file, fname, for reading and\n+                it returns this file.\n+                The success of this operation can be checked by\n+                calling IsNoError.\n+*/\n+\n+extern \"C\" FIO_File SFIO_OpenToRead (DynamicStrings_String fname)\n+{\n+  return FIO_openToRead (DynamicStrings_string (fname), DynamicStrings_Length (fname));\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   OpenToWrite - attempts to open a file, fname, for write and\n+                 it returns this file.\n+                 The success of this operation can be checked by\n+                 calling IsNoError.\n+*/\n+\n+extern \"C\" FIO_File SFIO_OpenToWrite (DynamicStrings_String fname)\n+{\n+  return FIO_openToWrite (DynamicStrings_string (fname), DynamicStrings_Length (fname));\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   OpenForRandom - attempts to open a file, fname, for random access\n+                   read or write and it returns this file.\n+                   The success of this operation can be checked by\n+                   calling IsNoError.\n+                   towrite, determines whether the file should be\n+                   opened for writing or reading.\n+                   if towrite is TRUE or whether the previous file should\n+                   be left alone, allowing this descriptor to seek\n+                   and modify an existing file.\n+*/\n+\n+extern \"C\" FIO_File SFIO_OpenForRandom (DynamicStrings_String fname, unsigned int towrite, unsigned int newfile)\n+{\n+  return FIO_openForRandom (DynamicStrings_string (fname), DynamicStrings_Length (fname), towrite, newfile);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   WriteS - writes a string, s, to, file. It returns the String, s.\n+*/\n+\n+extern \"C\" DynamicStrings_String SFIO_WriteS (FIO_File file, DynamicStrings_String s)\n+{\n+  unsigned int nBytes;\n+\n+  if (s != NULL)\n+    {\n+      nBytes = FIO_WriteNBytes (file, DynamicStrings_Length (s), DynamicStrings_string (s));\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   ReadS - reads and returns a string from, file.\n+           It stops reading the string at the end of line or end of file.\n+           It consumes the newline at the end of line but does not place\n+           this into the returned string.\n+*/\n+\n+extern \"C\" DynamicStrings_String SFIO_ReadS (FIO_File file)\n+{\n+  DynamicStrings_String s;\n+  unsigned int c;\n+\n+  s = DynamicStrings_InitString ((const char *) \"\", 0);\n+  while (((! (FIO_EOLN (file))) && (! (FIO_EOF (file)))) && (FIO_IsNoError (file)))\n+    {\n+      s = DynamicStrings_ConCatChar (s, FIO_ReadChar (file));\n+    }\n+  if (FIO_EOLN (file))\n+    {\n+      /* consume nl  */\n+      if ((FIO_ReadChar (file)) == ASCII_nul)\n+        {}  /* empty.  */\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" void _M2_SFIO_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}\n+\n+extern \"C\" void _M2_SFIO_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "41affe2a054d55d0590c1ce55cabb91f57be6fa4", "filename": "gcc/m2/mc-boot/GStdIO.cc", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGStdIO.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGStdIO.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGStdIO.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,269 @@\n+/* do not edit automatically generated by mc from StdIO.  */\n+/* StdIO.mod provides general Read and Write procedures.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#   include \"Gmcrts.h\"\n+#define _StdIO_H\n+#define _StdIO_C\n+\n+#   include \"GIO.h\"\n+#   include \"GM2RTS.h\"\n+\n+typedef struct StdIO_ProcWrite_p StdIO_ProcWrite;\n+\n+typedef struct StdIO_ProcRead_p StdIO_ProcRead;\n+\n+#   define MaxStack 40\n+typedef struct StdIO__T1_a StdIO__T1;\n+\n+typedef struct StdIO__T2_a StdIO__T2;\n+\n+typedef void (*StdIO_ProcWrite_t) (char);\n+struct StdIO_ProcWrite_p { StdIO_ProcWrite_t proc; };\n+\n+typedef void (*StdIO_ProcRead_t) (char *);\n+struct StdIO_ProcRead_p { StdIO_ProcRead_t proc; };\n+\n+struct StdIO__T1_a { StdIO_ProcWrite array[MaxStack+1]; };\n+struct StdIO__T2_a { StdIO_ProcRead array[MaxStack+1]; };\n+static StdIO__T1 StackW;\n+static unsigned int StackWPtr;\n+static StdIO__T2 StackR;\n+static unsigned int StackRPtr;\n+\n+/*\n+   Read - is the generic procedure that all higher application layers\n+          should use to receive a character.\n+*/\n+\n+extern \"C\" void StdIO_Read (char *ch);\n+\n+/*\n+   Write - is the generic procedure that all higher application layers\n+           should use to emit a character.\n+*/\n+\n+extern \"C\" void StdIO_Write (char ch);\n+\n+/*\n+   PushOutput - pushes the current Write procedure onto a stack,\n+                any future references to Write will actually invoke\n+                procedure, p.\n+*/\n+\n+extern \"C\" void StdIO_PushOutput (StdIO_ProcWrite p);\n+\n+/*\n+   PopOutput - restores Write to use the previous output procedure.\n+*/\n+\n+extern \"C\" void StdIO_PopOutput (void);\n+\n+/*\n+   GetCurrentOutput - returns the current output procedure.\n+*/\n+\n+extern \"C\" StdIO_ProcWrite StdIO_GetCurrentOutput (void);\n+\n+/*\n+   PushInput - pushes the current Read procedure onto a stack,\n+               any future references to Read will actually invoke\n+               procedure, p.\n+*/\n+\n+extern \"C\" void StdIO_PushInput (StdIO_ProcRead p);\n+\n+/*\n+   PopInput - restores Write to use the previous output procedure.\n+*/\n+\n+extern \"C\" void StdIO_PopInput (void);\n+\n+/*\n+   GetCurrentInput - returns the current input procedure.\n+*/\n+\n+extern \"C\" StdIO_ProcRead StdIO_GetCurrentInput (void);\n+\n+\n+/*\n+   Read - is the generic procedure that all higher application layers\n+          should use to receive a character.\n+*/\n+\n+extern \"C\" void StdIO_Read (char *ch)\n+{\n+  (*StackR.array[StackRPtr].proc) (ch);\n+}\n+\n+\n+/*\n+   Write - is the generic procedure that all higher application layers\n+           should use to emit a character.\n+*/\n+\n+extern \"C\" void StdIO_Write (char ch)\n+{\n+  (*StackW.array[StackWPtr].proc) (ch);\n+}\n+\n+\n+/*\n+   PushOutput - pushes the current Write procedure onto a stack,\n+                any future references to Write will actually invoke\n+                procedure, p.\n+*/\n+\n+extern \"C\" void StdIO_PushOutput (StdIO_ProcWrite p)\n+{\n+  if (StackWPtr == MaxStack)\n+    {\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n+    }\n+  else\n+    {\n+      StackWPtr += 1;\n+      StackW.array[StackWPtr] = p;\n+    }\n+}\n+\n+\n+/*\n+   PopOutput - restores Write to use the previous output procedure.\n+*/\n+\n+extern \"C\" void StdIO_PopOutput (void)\n+{\n+  if (StackWPtr == 1)\n+    {\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n+    }\n+  else\n+    {\n+      StackWPtr -= 1;\n+    }\n+}\n+\n+\n+/*\n+   GetCurrentOutput - returns the current output procedure.\n+*/\n+\n+extern \"C\" StdIO_ProcWrite StdIO_GetCurrentOutput (void)\n+{\n+  if (StackWPtr > 0)\n+    {\n+      return StackW.array[StackWPtr];\n+    }\n+  else\n+    {\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n+    }\n+  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/StdIO.def\", 25, 1);\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   PushInput - pushes the current Read procedure onto a stack,\n+               any future references to Read will actually invoke\n+               procedure, p.\n+*/\n+\n+extern \"C\" void StdIO_PushInput (StdIO_ProcRead p)\n+{\n+  if (StackRPtr == MaxStack)\n+    {\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n+    }\n+  else\n+    {\n+      StackRPtr += 1;\n+      StackR.array[StackRPtr] = p;\n+    }\n+}\n+\n+\n+/*\n+   PopInput - restores Write to use the previous output procedure.\n+*/\n+\n+extern \"C\" void StdIO_PopInput (void)\n+{\n+  if (StackRPtr == 1)\n+    {\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n+    }\n+  else\n+    {\n+      StackRPtr -= 1;\n+    }\n+}\n+\n+\n+/*\n+   GetCurrentInput - returns the current input procedure.\n+*/\n+\n+extern \"C\" StdIO_ProcRead StdIO_GetCurrentInput (void)\n+{\n+  if (StackRPtr > 0)\n+    {\n+      return StackR.array[StackRPtr];\n+    }\n+  else\n+    {\n+      M2RTS_HALT (-1);\n+      __builtin_unreachable ();\n+    }\n+  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/StdIO.def\", 25, 1);\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" void _M2_StdIO_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+  StackWPtr = 0;\n+  StackRPtr = 0;\n+  StdIO_PushOutput ((StdIO_ProcWrite) {(StdIO_ProcWrite_t) IO_Write});\n+  StdIO_PushInput ((StdIO_ProcRead) {(StdIO_ProcRead_t) IO_Read});\n+}\n+\n+extern \"C\" void _M2_StdIO_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "5dac021d8665af0cd09e4787e70e75d776ae2202", "filename": "gcc/m2/mc-boot/GStorage.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGStorage.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGStorage.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGStorage.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,74 @@\n+/* do not edit automatically generated by mc from Storage.  */\n+/* Storage.mod provides access to the dynamic Storage handler.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#define _Storage_H\n+#define _Storage_C\n+\n+#   include \"GSysStorage.h\"\n+\n+extern \"C\" void Storage_ALLOCATE (void * *a, unsigned int Size);\n+extern \"C\" void Storage_DEALLOCATE (void * *a, unsigned int Size);\n+extern \"C\" void Storage_REALLOCATE (void * *a, unsigned int Size);\n+extern \"C\" unsigned int Storage_Available (unsigned int Size);\n+\n+extern \"C\" void Storage_ALLOCATE (void * *a, unsigned int Size)\n+{\n+  SysStorage_ALLOCATE (a, Size);\n+}\n+\n+extern \"C\" void Storage_DEALLOCATE (void * *a, unsigned int Size)\n+{\n+  SysStorage_DEALLOCATE (a, Size);\n+}\n+\n+extern \"C\" void Storage_REALLOCATE (void * *a, unsigned int Size)\n+{\n+  SysStorage_REALLOCATE (a, Size);\n+}\n+\n+extern \"C\" unsigned int Storage_Available (unsigned int Size)\n+{\n+  return SysStorage_Available (Size);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" void _M2_Storage_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}\n+\n+extern \"C\" void _M2_Storage_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "e3491b6d75b1656f269a4fb663d1ab65f46b63ea", "filename": "gcc/m2/mc-boot/GStrCase.cc", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGStrCase.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGStrCase.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGStrCase.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,175 @@\n+/* do not edit automatically generated by mc from StrCase.  */\n+/* StrCase.mod provides procedure to convert between text case.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#define _StrCase_H\n+#define _StrCase_C\n+\n+#   include \"GASCII.h\"\n+#   include \"GStrLib.h\"\n+\n+\n+/*\n+   StrToUpperCase - converts string, a, to uppercase returning the\n+                    result in, b.\n+*/\n+\n+extern \"C\" void StrCase_StrToUpperCase (const char *a_, unsigned int _a_high, char *b, unsigned int _b_high);\n+\n+/*\n+   StrToLowerCase - converts string, a, to lowercase returning the\n+                    result in, b.\n+*/\n+\n+extern \"C\" void StrCase_StrToLowerCase (const char *a_, unsigned int _a_high, char *b, unsigned int _b_high);\n+\n+/*\n+   Cap - converts a lower case character into a capital character.\n+         If the character is not a lower case character 'a'..'z'\n+         then the character is simply returned unaltered.\n+*/\n+\n+extern \"C\" char StrCase_Cap (char ch);\n+\n+/*\n+   Lower - converts an upper case character into a lower case character.\n+           If the character is not an upper case character 'A'..'Z'\n+           then the character is simply returned unaltered.\n+*/\n+\n+extern \"C\" char StrCase_Lower (char ch);\n+\n+\n+/*\n+   StrToUpperCase - converts string, a, to uppercase returning the\n+                    result in, b.\n+*/\n+\n+extern \"C\" void StrCase_StrToUpperCase (const char *a_, unsigned int _a_high, char *b, unsigned int _b_high)\n+{\n+  unsigned int higha;\n+  unsigned int highb;\n+  unsigned int i;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  higha = StrLib_StrLen ((const char *) a, _a_high);\n+  highb = _b_high;\n+  i = 0;\n+  while (((i < higha) && (a[i] != ASCII_nul)) && (i < highb))\n+    {\n+      b[i] = StrCase_Cap (a[i]);\n+      i += 1;\n+    }\n+  if (i < highb)\n+    {\n+      b[i] = ASCII_nul;\n+    }\n+}\n+\n+\n+/*\n+   StrToLowerCase - converts string, a, to lowercase returning the\n+                    result in, b.\n+*/\n+\n+extern \"C\" void StrCase_StrToLowerCase (const char *a_, unsigned int _a_high, char *b, unsigned int _b_high)\n+{\n+  unsigned int higha;\n+  unsigned int highb;\n+  unsigned int i;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  higha = StrLib_StrLen ((const char *) a, _a_high);\n+  highb = _b_high;\n+  i = 0;\n+  while (((i < higha) && (a[i] != ASCII_nul)) && (i < highb))\n+    {\n+      b[i] = StrCase_Lower (a[i]);\n+      i += 1;\n+    }\n+  if (i < highb)\n+    {\n+      b[i] = ASCII_nul;\n+    }\n+}\n+\n+\n+/*\n+   Cap - converts a lower case character into a capital character.\n+         If the character is not a lower case character 'a'..'z'\n+         then the character is simply returned unaltered.\n+*/\n+\n+extern \"C\" char StrCase_Cap (char ch)\n+{\n+  if ((ch >= 'a') && (ch <= 'z'))\n+    {\n+      ch = ((char) (( ((unsigned int) (ch))- ((unsigned int) ('a')))+ ((unsigned int) ('A'))));\n+    }\n+  return ch;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Lower - converts an upper case character into a lower case character.\n+           If the character is not an upper case character 'A'..'Z'\n+           then the character is simply returned unaltered.\n+*/\n+\n+extern \"C\" char StrCase_Lower (char ch)\n+{\n+  if ((ch >= 'A') && (ch <= 'Z'))\n+    {\n+      ch = ((char) (( ((unsigned int) (ch))- ((unsigned int) ('A')))+ ((unsigned int) ('a'))));\n+    }\n+  return ch;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" void _M2_StrCase_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}\n+\n+extern \"C\" void _M2_StrCase_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "1e091bce54564e3ccf80b3e03ecbbefe3f94b394", "filename": "gcc/m2/mc-boot/GStrIO.cc", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGStrIO.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGStrIO.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGStrIO.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,277 @@\n+/* do not edit automatically generated by mc from StrIO.  */\n+/* StrIO.mod provides simple string input output routines.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#   if !defined (FALSE)\n+#      define FALSE (1==0)\n+#   endif\n+\n+#define _StrIO_H\n+#define _StrIO_C\n+\n+#   include \"GASCII.h\"\n+#   include \"GStdIO.h\"\n+#   include \"Glibc.h\"\n+\n+static unsigned int IsATTY;\n+\n+/*\n+   WriteLn - writes a carriage return and a newline\n+             character.\n+*/\n+\n+extern \"C\" void StrIO_WriteLn (void);\n+\n+/*\n+   ReadString - reads a sequence of characters into a string.\n+                Line editing accepts Del, Ctrl H, Ctrl W and\n+                Ctrl U.\n+*/\n+\n+extern \"C\" void StrIO_ReadString (char *a, unsigned int _a_high);\n+\n+/*\n+   WriteString - writes a string to the default output.\n+*/\n+\n+extern \"C\" void StrIO_WriteString (const char *a_, unsigned int _a_high);\n+\n+/*\n+   Erase - writes a backspace, space and backspace to remove the\n+           last character displayed.\n+*/\n+\n+static void Erase (void);\n+\n+/*\n+   Echo - echos the character, ch, onto the output channel if IsATTY\n+          is true.\n+*/\n+\n+static void Echo (char ch);\n+\n+/*\n+   AlphaNum- returns true if character, ch, is an alphanumeric character.\n+*/\n+\n+static unsigned int AlphaNum (char ch);\n+\n+\n+/*\n+   Erase - writes a backspace, space and backspace to remove the\n+           last character displayed.\n+*/\n+\n+static void Erase (void)\n+{\n+  Echo (ASCII_bs);\n+  Echo (' ');\n+  Echo (ASCII_bs);\n+}\n+\n+\n+/*\n+   Echo - echos the character, ch, onto the output channel if IsATTY\n+          is true.\n+*/\n+\n+static void Echo (char ch)\n+{\n+  if (IsATTY)\n+    {\n+      StdIO_Write (ch);\n+    }\n+}\n+\n+\n+/*\n+   AlphaNum- returns true if character, ch, is an alphanumeric character.\n+*/\n+\n+static unsigned int AlphaNum (char ch)\n+{\n+  return (((ch >= 'a') && (ch <= 'z')) || ((ch >= 'A') && (ch <= 'Z'))) || ((ch >= '0') && (ch <= '9'));\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   WriteLn - writes a carriage return and a newline\n+             character.\n+*/\n+\n+extern \"C\" void StrIO_WriteLn (void)\n+{\n+  Echo (ASCII_cr);\n+  StdIO_Write (ASCII_lf);\n+}\n+\n+\n+/*\n+   ReadString - reads a sequence of characters into a string.\n+                Line editing accepts Del, Ctrl H, Ctrl W and\n+                Ctrl U.\n+*/\n+\n+extern \"C\" void StrIO_ReadString (char *a, unsigned int _a_high)\n+{\n+  unsigned int n;\n+  unsigned int high;\n+  char ch;\n+\n+  high = _a_high;\n+  n = 0;\n+  do {\n+    StdIO_Read (&ch);\n+    if ((ch == ASCII_del) || (ch == ASCII_bs))\n+      {\n+        if (n == 0)\n+          {\n+            StdIO_Write (ASCII_bel);\n+          }\n+        else\n+          {\n+            Erase ();\n+            n -= 1;\n+          }\n+      }\n+    else if (ch == ASCII_nak)\n+      {\n+        /* avoid dangling else.  */\n+        while (n > 0)\n+          {\n+            Erase ();\n+            n -= 1;\n+          }\n+      }\n+    else if (ch == ASCII_etb)\n+      {\n+        /* avoid dangling else.  */\n+        if (n == 0)\n+          {\n+            Echo (ASCII_bel);\n+          }\n+        else if (AlphaNum (a[n-1]))\n+          {\n+            /* avoid dangling else.  */\n+            do {\n+              Erase ();\n+              n -= 1;\n+            } while (! ((n == 0) || (! (AlphaNum (a[n-1])))));\n+          }\n+        else\n+          {\n+            /* avoid dangling else.  */\n+            Erase ();\n+            n -= 1;\n+          }\n+      }\n+    else if (n <= high)\n+      {\n+        /* avoid dangling else.  */\n+        if ((ch == ASCII_cr) || (ch == ASCII_lf))\n+          {\n+            a[n] = ASCII_nul;\n+            n += 1;\n+          }\n+        else if (ch == ASCII_ff)\n+          {\n+            /* avoid dangling else.  */\n+            a[0] = ch;\n+            if (high > 0)\n+              {\n+                a[1] = ASCII_nul;\n+              }\n+            ch = ASCII_cr;\n+          }\n+        else if (ch >= ' ')\n+          {\n+            /* avoid dangling else.  */\n+            Echo (ch);\n+            a[n] = ch;\n+            n += 1;\n+          }\n+        else if (ch == ASCII_eof)\n+          {\n+            /* avoid dangling else.  */\n+            a[n] = ch;\n+            n += 1;\n+            ch = ASCII_cr;\n+            if (n <= high)\n+              {\n+                a[n] = ASCII_nul;\n+              }\n+          }\n+      }\n+    else if (ch != ASCII_cr)\n+      {\n+        /* avoid dangling else.  */\n+        Echo (ASCII_bel);\n+      }\n+  } while (! ((ch == ASCII_cr) || (ch == ASCII_lf)));\n+}\n+\n+\n+/*\n+   WriteString - writes a string to the default output.\n+*/\n+\n+extern \"C\" void StrIO_WriteString (const char *a_, unsigned int _a_high)\n+{\n+  unsigned int n;\n+  unsigned int high;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  high = _a_high;\n+  n = 0;\n+  while ((n <= high) && (a[n] != ASCII_nul))\n+    {\n+      StdIO_Write (a[n]);\n+      n += 1;\n+    }\n+}\n+\n+extern \"C\" void _M2_StrIO_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+  /* IsATTY := isatty()  */\n+  IsATTY = FALSE;\n+}\n+\n+extern \"C\" void _M2_StrIO_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "537eeb963567733a0769ed237dfe1656112d6870", "filename": "gcc/m2/mc-boot/GStrLib.cc", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGStrLib.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGStrLib.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGStrLib.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,346 @@\n+/* do not edit automatically generated by mc from StrLib.  */\n+/* StrLib.mod provides string manipulation procedures.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#   if !defined (TRUE)\n+#      define TRUE (1==1)\n+#   endif\n+\n+#   if !defined (FALSE)\n+#      define FALSE (1==0)\n+#   endif\n+\n+#define _StrLib_H\n+#define _StrLib_C\n+\n+#   include \"GASCII.h\"\n+\n+\n+/*\n+   StrConCat - combines a and b into c.\n+*/\n+\n+extern \"C\" void StrLib_StrConCat (const char *a_, unsigned int _a_high, const char *b_, unsigned int _b_high, char *c, unsigned int _c_high);\n+\n+/*\n+   StrLess - returns TRUE if string, a, alphabetically occurs before\n+             string, b.\n+*/\n+\n+extern \"C\" unsigned int StrLib_StrLess (const char *a_, unsigned int _a_high, const char *b_, unsigned int _b_high);\n+extern \"C\" unsigned int StrLib_StrEqual (const char *a_, unsigned int _a_high, const char *b_, unsigned int _b_high);\n+extern \"C\" unsigned int StrLib_StrLen (const char *a_, unsigned int _a_high);\n+\n+/*\n+   StrCopy - copy string src into string dest providing dest is large enough.\n+             If dest is smaller than a then src then the string is truncated when\n+             dest is full.  Add a nul character if there is room in dest.\n+*/\n+\n+extern \"C\" void StrLib_StrCopy (const char *src_, unsigned int _src_high, char *dest, unsigned int _dest_high);\n+\n+/*\n+   IsSubString - returns true if b is a subcomponent of a.\n+*/\n+\n+extern \"C\" unsigned int StrLib_IsSubString (const char *a_, unsigned int _a_high, const char *b_, unsigned int _b_high);\n+\n+/*\n+   StrRemoveWhitePrefix - copies string, into string, b, excluding any white\n+                          space infront of a.\n+*/\n+\n+extern \"C\" void StrLib_StrRemoveWhitePrefix (const char *a_, unsigned int _a_high, char *b, unsigned int _b_high);\n+\n+/*\n+   IsWhite - returns TRUE if, ch, is a space or a tab.\n+*/\n+\n+static unsigned int IsWhite (char ch);\n+\n+\n+/*\n+   IsWhite - returns TRUE if, ch, is a space or a tab.\n+*/\n+\n+static unsigned int IsWhite (char ch)\n+{\n+  return (ch == ' ') || (ch == ASCII_tab);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   StrConCat - combines a and b into c.\n+*/\n+\n+extern \"C\" void StrLib_StrConCat (const char *a_, unsigned int _a_high, const char *b_, unsigned int _b_high, char *c, unsigned int _c_high)\n+{\n+  unsigned int Highb;\n+  unsigned int Highc;\n+  unsigned int i;\n+  unsigned int j;\n+  char a[_a_high+1];\n+  char b[_b_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+  memcpy (b, b_, _b_high+1);\n+\n+  Highb = StrLib_StrLen ((const char *) b, _b_high);\n+  Highc = _c_high;\n+  StrLib_StrCopy ((const char *) a, _a_high, (char *) c, _c_high);\n+  i = StrLib_StrLen ((const char *) c, _c_high);\n+  j = 0;\n+  while ((j < Highb) && (i <= Highc))\n+    {\n+      c[i] = b[j];\n+      i += 1;\n+      j += 1;\n+    }\n+  if (i <= Highc)\n+    {\n+      c[i] = ASCII_nul;\n+    }\n+}\n+\n+\n+/*\n+   StrLess - returns TRUE if string, a, alphabetically occurs before\n+             string, b.\n+*/\n+\n+extern \"C\" unsigned int StrLib_StrLess (const char *a_, unsigned int _a_high, const char *b_, unsigned int _b_high)\n+{\n+  unsigned int Higha;\n+  unsigned int Highb;\n+  unsigned int i;\n+  char a[_a_high+1];\n+  char b[_b_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+  memcpy (b, b_, _b_high+1);\n+\n+  Higha = StrLib_StrLen ((const char *) a, _a_high);\n+  Highb = StrLib_StrLen ((const char *) b, _b_high);\n+  i = 0;\n+  while ((i < Higha) && (i < Highb))\n+    {\n+      if (a[i] < b[i])\n+        {\n+          return TRUE;\n+        }\n+      else if (a[i] > b[i])\n+        {\n+          /* avoid dangling else.  */\n+          return FALSE;\n+        }\n+      /* must be equal, move on to next character  */\n+      i += 1;\n+    }\n+  return Higha < Highb;  /* substrings are equal so we go on length  */\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" unsigned int StrLib_StrEqual (const char *a_, unsigned int _a_high, const char *b_, unsigned int _b_high)\n+{\n+  unsigned int i;\n+  unsigned int higha;\n+  unsigned int highb;\n+  char a[_a_high+1];\n+  char b[_b_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+  memcpy (b, b_, _b_high+1);\n+\n+  higha = _a_high;\n+  highb = _b_high;\n+  i = 0;\n+  while ((((i <= higha) && (i <= highb)) && (a[i] != ASCII_nul)) && (b[i] != ASCII_nul))\n+    {\n+      if (a[i] != b[i])\n+        {\n+          return FALSE;\n+        }\n+      i += 1;\n+    }\n+  return ! (((i <= higha) && (a[i] != ASCII_nul)) || ((i <= highb) && (b[i] != ASCII_nul)));\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" unsigned int StrLib_StrLen (const char *a_, unsigned int _a_high)\n+{\n+  unsigned int High;\n+  unsigned int Len;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  Len = 0;\n+  High = _a_high;\n+  while ((Len <= High) && (a[Len] != ASCII_nul))\n+    {\n+      Len += 1;\n+    }\n+  return Len;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   StrCopy - copy string src into string dest providing dest is large enough.\n+             If dest is smaller than a then src then the string is truncated when\n+             dest is full.  Add a nul character if there is room in dest.\n+*/\n+\n+extern \"C\" void StrLib_StrCopy (const char *src_, unsigned int _src_high, char *dest, unsigned int _dest_high)\n+{\n+  unsigned int HighSrc;\n+  unsigned int HighDest;\n+  unsigned int n;\n+  char src[_src_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (src, src_, _src_high+1);\n+\n+  n = 0;\n+  HighSrc = StrLib_StrLen ((const char *) src, _src_high);\n+  HighDest = _dest_high;\n+  while ((n < HighSrc) && (n <= HighDest))\n+    {\n+      dest[n] = src[n];\n+      n += 1;\n+    }\n+  if (n <= HighDest)\n+    {\n+      dest[n] = ASCII_nul;\n+    }\n+}\n+\n+\n+/*\n+   IsSubString - returns true if b is a subcomponent of a.\n+*/\n+\n+extern \"C\" unsigned int StrLib_IsSubString (const char *a_, unsigned int _a_high, const char *b_, unsigned int _b_high)\n+{\n+  unsigned int i;\n+  unsigned int j;\n+  unsigned int LengthA;\n+  unsigned int LengthB;\n+  char a[_a_high+1];\n+  char b[_b_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+  memcpy (b, b_, _b_high+1);\n+\n+  LengthA = StrLib_StrLen ((const char *) a, _a_high);\n+  LengthB = StrLib_StrLen ((const char *) b, _b_high);\n+  i = 0;\n+  if (LengthA > LengthB)\n+    {\n+      while (i <= (LengthA-LengthB))\n+        {\n+          j = 0;\n+          while ((j < LengthB) && (a[i+j] == b[j]))\n+            {\n+              j += 1;\n+            }\n+          if (j == LengthB)\n+            {\n+              return TRUE;\n+            }\n+          else\n+            {\n+              i += 1;\n+            }\n+        }\n+    }\n+  return FALSE;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   StrRemoveWhitePrefix - copies string, into string, b, excluding any white\n+                          space infront of a.\n+*/\n+\n+extern \"C\" void StrLib_StrRemoveWhitePrefix (const char *a_, unsigned int _a_high, char *b, unsigned int _b_high)\n+{\n+  unsigned int i;\n+  unsigned int j;\n+  unsigned int higha;\n+  unsigned int highb;\n+  char a[_a_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (a, a_, _a_high+1);\n+\n+  i = 0;\n+  j = 0;\n+  higha = StrLib_StrLen ((const char *) a, _a_high);\n+  highb = _b_high;\n+  while ((i < higha) && (IsWhite (a[i])))\n+    {\n+      i += 1;\n+    }\n+  while ((i < higha) && (j <= highb))\n+    {\n+      b[j] = a[i];\n+      i += 1;\n+      j += 1;\n+    }\n+  if (j <= highb)\n+    {\n+      b[j] = ASCII_nul;\n+    }\n+}\n+\n+extern \"C\" void _M2_StrLib_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}\n+\n+extern \"C\" void _M2_StrLib_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "faa5e34459ecbe654fa9defc9b898357cf2bb021", "filename": "gcc/m2/mc-boot/GStringConvert.cc", "status": "added", "additions": 2005, "deletions": 0, "changes": 2005, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGStringConvert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGStringConvert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGStringConvert.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,2005 @@\n+/* do not edit automatically generated by mc from StringConvert.  */\n+/* StringConvert.mod provides functions to convert numbers to and from strings.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#   if !defined (TRUE)\n+#      define TRUE (1==1)\n+#   endif\n+\n+#   if !defined (FALSE)\n+#      define FALSE (1==0)\n+#   endif\n+\n+#if defined(__cplusplus)\n+#   undef NULL\n+#   define NULL 0\n+#endif\n+#define _StringConvert_H\n+#define _StringConvert_C\n+\n+#   include \"GSYSTEM.h\"\n+#   include \"Glibc.h\"\n+#   include \"Glibm.h\"\n+#   include \"GM2RTS.h\"\n+#   include \"GDynamicStrings.h\"\n+#   include \"Gldtoa.h\"\n+#   include \"Gdtoa.h\"\n+\n+\n+/*\n+   IntegerToString - converts INTEGER, i, into a String. The field with can be specified\n+                     if non zero. Leading characters are defined by padding and this\n+                     function will prepend a + if sign is set to TRUE.\n+                     The base allows the caller to generate binary, octal, decimal, hexidecimal\n+                     numbers. The value of lower is only used when hexidecimal numbers are\n+                     generated and if TRUE then digits abcdef are used, and if FALSE then ABCDEF\n+                     are used.\n+*/\n+\n+extern \"C\" DynamicStrings_String StringConvert_IntegerToString (int i, unsigned int width, char padding, unsigned int sign, unsigned int base, unsigned int lower);\n+\n+/*\n+   CardinalToString - converts CARDINAL, c, into a String. The field with can be specified\n+                      if non zero. Leading characters are defined by padding.\n+                      The base allows the caller to generate binary, octal, decimal, hexidecimal\n+                      numbers. The value of lower is only used when hexidecimal numbers are\n+                      generated and if TRUE then digits abcdef are used, and if FALSE then ABCDEF\n+                      are used.\n+*/\n+\n+extern \"C\" DynamicStrings_String StringConvert_CardinalToString (unsigned int c, unsigned int width, char padding, unsigned int base, unsigned int lower);\n+\n+/*\n+   StringToInteger - converts a string, s, of, base, into an INTEGER.\n+                     Leading white space is ignored. It stops converting\n+                     when either the string is exhausted or if an illegal\n+                     numeral is found.\n+                     The parameter found is set TRUE if a number was found.\n+*/\n+\n+extern \"C\" int StringConvert_StringToInteger (DynamicStrings_String s, unsigned int base, unsigned int *found);\n+\n+/*\n+   StringToCardinal - converts a string, s, of, base, into a CARDINAL.\n+                      Leading white space is ignored. It stops converting\n+                      when either the string is exhausted or if an illegal\n+                      numeral is found.\n+                      The parameter found is set TRUE if a number was found.\n+*/\n+\n+extern \"C\" unsigned int StringConvert_StringToCardinal (DynamicStrings_String s, unsigned int base, unsigned int *found);\n+\n+/*\n+   LongIntegerToString - converts LONGINT, i, into a String. The field with\n+                         can be specified if non zero. Leading characters\n+                         are defined by padding and this function will\n+                         prepend a + if sign is set to TRUE.\n+                         The base allows the caller to generate binary,\n+                         octal, decimal, hexidecimal numbers.\n+                         The value of lower is only used when hexidecimal\n+                         numbers are generated and if TRUE then digits\n+                         abcdef are used, and if FALSE then ABCDEF are used.\n+*/\n+\n+extern \"C\" DynamicStrings_String StringConvert_LongIntegerToString (long int i, unsigned int width, char padding, unsigned int sign, unsigned int base, unsigned int lower);\n+\n+/*\n+   StringToLongInteger - converts a string, s, of, base, into an LONGINT.\n+                         Leading white space is ignored. It stops converting\n+                         when either the string is exhausted or if an illegal\n+                         numeral is found.\n+                         The parameter found is set TRUE if a number was found.\n+*/\n+\n+extern \"C\" long int StringConvert_StringToLongInteger (DynamicStrings_String s, unsigned int base, unsigned int *found);\n+\n+/*\n+   LongCardinalToString - converts LONGCARD, c, into a String. The field\n+                          width can be specified if non zero. Leading\n+                          characters are defined by padding.\n+                          The base allows the caller to generate binary,\n+                          octal, decimal, hexidecimal numbers.\n+                          The value of lower is only used when hexidecimal\n+                          numbers are generated and if TRUE then digits\n+                          abcdef are used, and if FALSE then ABCDEF are used.\n+*/\n+\n+extern \"C\" DynamicStrings_String StringConvert_LongCardinalToString (long unsigned int c, unsigned int width, char padding, unsigned int base, unsigned int lower);\n+\n+/*\n+   StringToLongCardinal - converts a string, s, of, base, into a LONGCARD.\n+                          Leading white space is ignored. It stops converting\n+                          when either the string is exhausted or if an illegal\n+                          numeral is found.\n+                          The parameter found is set TRUE if a number was found.\n+*/\n+\n+extern \"C\" long unsigned int StringConvert_StringToLongCardinal (DynamicStrings_String s, unsigned int base, unsigned int *found);\n+\n+/*\n+   ShortCardinalToString - converts SHORTCARD, c, into a String. The field\n+                          width can be specified if non zero. Leading\n+                          characters are defined by padding.\n+                          The base allows the caller to generate binary,\n+                          octal, decimal, hexidecimal numbers.\n+                          The value of lower is only used when hexidecimal\n+                          numbers are generated and if TRUE then digits\n+                          abcdef are used, and if FALSE then ABCDEF are used.\n+*/\n+\n+extern \"C\" DynamicStrings_String StringConvert_ShortCardinalToString (short unsigned int c, unsigned int width, char padding, unsigned int base, unsigned int lower);\n+\n+/*\n+   StringToShortCardinal - converts a string, s, of, base, into a SHORTCARD.\n+                           Leading white space is ignored. It stops converting\n+                           when either the string is exhausted or if an illegal\n+                           numeral is found.\n+                           The parameter found is set TRUE if a number was found.\n+*/\n+\n+extern \"C\" short unsigned int StringConvert_StringToShortCardinal (DynamicStrings_String s, unsigned int base, unsigned int *found);\n+\n+/*\n+   stoi - decimal string to INTEGER\n+*/\n+\n+extern \"C\" int StringConvert_stoi (DynamicStrings_String s);\n+\n+/*\n+   itos - integer to decimal string.\n+*/\n+\n+extern \"C\" DynamicStrings_String StringConvert_itos (int i, unsigned int width, char padding, unsigned int sign);\n+\n+/*\n+   ctos - cardinal to decimal string.\n+*/\n+\n+extern \"C\" DynamicStrings_String StringConvert_ctos (unsigned int c, unsigned int width, char padding);\n+\n+/*\n+   stoc - decimal string to CARDINAL\n+*/\n+\n+extern \"C\" unsigned int StringConvert_stoc (DynamicStrings_String s);\n+\n+/*\n+   hstoi - hexidecimal string to INTEGER\n+*/\n+\n+extern \"C\" int StringConvert_hstoi (DynamicStrings_String s);\n+\n+/*\n+   ostoi - octal string to INTEGER\n+*/\n+\n+extern \"C\" int StringConvert_ostoi (DynamicStrings_String s);\n+\n+/*\n+   bstoi - binary string to INTEGER\n+*/\n+\n+extern \"C\" int StringConvert_bstoi (DynamicStrings_String s);\n+\n+/*\n+   hstoc - hexidecimal string to CARDINAL\n+*/\n+\n+extern \"C\" unsigned int StringConvert_hstoc (DynamicStrings_String s);\n+\n+/*\n+   ostoc - octal string to CARDINAL\n+*/\n+\n+extern \"C\" unsigned int StringConvert_ostoc (DynamicStrings_String s);\n+\n+/*\n+   bstoc - binary string to CARDINAL\n+*/\n+\n+extern \"C\" unsigned int StringConvert_bstoc (DynamicStrings_String s);\n+\n+/*\n+   StringToLongreal - returns a LONGREAL and sets found to TRUE if a legal number is seen.\n+*/\n+\n+extern \"C\" long double StringConvert_StringToLongreal (DynamicStrings_String s, unsigned int *found);\n+\n+/*\n+   LongrealToString - converts a LONGREAL number, Real, which has,\n+                      TotalWidth, and FractionWidth into a string.\n+                      It uses decimal notation.\n+\n+                      So for example:\n+\n+                      LongrealToString(1.0, 4, 2)  -> '1.00'\n+                      LongrealToString(12.3, 5, 2) -> '12.30'\n+                      LongrealToString(12.3, 6, 2) -> ' 12.30'\n+                      LongrealToString(12.3, 6, 3) -> '12.300'\n+\n+                      if total width is too small then the fraction\n+                      becomes truncated.\n+\n+                      LongrealToString(12.3, 5, 3) -> '12.30'\n+\n+                      Positive numbers do not have a '+' prepended.\n+                      Negative numbers will have a '-' prepended and\n+                      the TotalWidth will need to be large enough\n+                      to contain the sign, whole number, '.' and\n+                      fractional components.\n+*/\n+\n+extern \"C\" DynamicStrings_String StringConvert_LongrealToString (long double x, unsigned int TotalWidth, unsigned int FractionWidth);\n+\n+/*\n+   stor - returns a REAL given a string.\n+*/\n+\n+extern \"C\" double StringConvert_stor (DynamicStrings_String s);\n+\n+/*\n+   stolr - returns a LONGREAL given a string.\n+*/\n+\n+extern \"C\" long double StringConvert_stolr (DynamicStrings_String s);\n+\n+/*\n+   ToSigFig - returns a floating point or base 10 integer\n+              string which is accurate to, n, significant\n+              figures.  It will return a new String\n+              and, s, will be destroyed.\n+\n+\n+              So:  12.345\n+\n+              rounded to the following significant figures yields\n+\n+              5      12.345\n+              4      12.34\n+              3      12.3\n+              2      12\n+              1      10\n+*/\n+\n+extern \"C\" DynamicStrings_String StringConvert_ToSigFig (DynamicStrings_String s, unsigned int n);\n+\n+/*\n+   ToDecimalPlaces - returns a floating point or base 10 integer\n+                     string which is accurate to, n, decimal\n+                     places.  It will return a new String\n+                     and, s, will be destroyed.\n+                     Decimal places yields, n, digits after\n+                     the .\n+\n+                     So:  12.345\n+\n+                     rounded to the following decimal places yields\n+\n+                     5      12.34500\n+                     4      12.3450\n+                     3      12.345\n+                     2      12.34\n+                     1      12.3\n+*/\n+\n+extern \"C\" DynamicStrings_String StringConvert_ToDecimalPlaces (DynamicStrings_String s, unsigned int n);\n+\n+/*\n+   Assert - implement a simple assert.\n+*/\n+\n+static void Assert (unsigned int b, const char *file_, unsigned int _file_high, unsigned int line, const char *func_, unsigned int _func_high);\n+\n+/*\n+   Max -\n+*/\n+\n+static unsigned int Max (unsigned int a, unsigned int b);\n+\n+/*\n+   Min -\n+*/\n+\n+static unsigned int Min (unsigned int a, unsigned int b);\n+\n+/*\n+   LongMin - returns the smallest LONGCARD\n+*/\n+\n+static long unsigned int LongMin (long unsigned int a, long unsigned int b);\n+\n+/*\n+   IsDigit - returns TRUE if, ch, lies between '0'..'9'.\n+*/\n+\n+static unsigned int IsDigit (char ch);\n+\n+/*\n+   IsDecimalDigitValid - returns the TRUE if, ch, is a base legal decimal digit.\n+                         If legal then the value is appended numerically onto, c.\n+*/\n+\n+static unsigned int IsDecimalDigitValid (char ch, unsigned int base, unsigned int *c);\n+\n+/*\n+   IsHexidecimalDigitValid - returns the TRUE if, ch, is a base legal hexidecimal digit.\n+                             If legal then the value is appended numerically onto, c.\n+*/\n+\n+static unsigned int IsHexidecimalDigitValid (char ch, unsigned int base, unsigned int *c);\n+\n+/*\n+   IsDecimalDigitValidLong - returns the TRUE if, ch, is a base legal decimal digit.\n+                             If legal then the value is appended numerically onto, c.\n+*/\n+\n+static unsigned int IsDecimalDigitValidLong (char ch, unsigned int base, long unsigned int *c);\n+\n+/*\n+   IsHexidecimalDigitValidLong - returns the TRUE if, ch, is a base legal hexidecimal digit.\n+                                 If legal then the value is appended numerically onto, c.\n+*/\n+\n+static unsigned int IsHexidecimalDigitValidLong (char ch, unsigned int base, long unsigned int *c);\n+\n+/*\n+   IsDecimalDigitValidShort - returns the TRUE if, ch, is a base legal decimal digit.\n+                              If legal then the value is appended numerically onto, c.\n+*/\n+\n+static unsigned int IsDecimalDigitValidShort (char ch, unsigned int base, short unsigned int *c);\n+\n+/*\n+   IsHexidecimalDigitValidShort - returns the TRUE if, ch, is a base legal hexidecimal digit.\n+                                  If legal then the value is appended numerically onto, c.\n+*/\n+\n+static unsigned int IsHexidecimalDigitValidShort (char ch, unsigned int base, short unsigned int *c);\n+\n+/*\n+   ToThePower10 - returns a LONGREAL containing the value of v * 10^power.\n+*/\n+\n+static long double ToThePower10 (long double v, int power);\n+\n+/*\n+   DetermineSafeTruncation - we wish to use TRUNC when converting REAL/LONGREAL\n+                             into a string for the non fractional component.\n+                             However we need a simple method to\n+                             determine the maximum safe truncation value.\n+*/\n+\n+static unsigned int DetermineSafeTruncation (void);\n+\n+/*\n+   rtos -\n+*/\n+\n+static DynamicStrings_String rtos (double r, unsigned int TotalWidth, unsigned int FractionWidth);\n+\n+/*\n+   lrtos -\n+*/\n+\n+static DynamicStrings_String lrtos (long double r, unsigned int TotalWidth, unsigned int FractionWidth);\n+\n+/*\n+   doDecimalPlaces - returns a string which is accurate to\n+                     n decimal places.  It returns a new String\n+                     and, s, will be destroyed.\n+*/\n+\n+static DynamicStrings_String doDecimalPlaces (DynamicStrings_String s, unsigned int n);\n+\n+/*\n+   doSigFig - returns a string which is accurate to\n+              n decimal places.  It returns a new String\n+              and, s, will be destroyed.\n+*/\n+\n+static DynamicStrings_String doSigFig (DynamicStrings_String s, unsigned int n);\n+\n+/*\n+   carryOne - add a carry at position, i.\n+*/\n+\n+static DynamicStrings_String carryOne (DynamicStrings_String s, unsigned int i);\n+\n+\n+/*\n+   Assert - implement a simple assert.\n+*/\n+\n+static void Assert (unsigned int b, const char *file_, unsigned int _file_high, unsigned int line, const char *func_, unsigned int _func_high)\n+{\n+  char file[_file_high+1];\n+  char func[_func_high+1];\n+\n+  /* make a local copy of each unbounded array.  */\n+  memcpy (file, file_, _file_high+1);\n+  memcpy (func, func_, _func_high+1);\n+\n+  if (! b)\n+    {\n+      M2RTS_ErrorMessage ((const char *) \"assert failed\", 13, (const char *) file, _file_high, line, (const char *) func, _func_high);\n+    }\n+}\n+\n+\n+/*\n+   Max -\n+*/\n+\n+static unsigned int Max (unsigned int a, unsigned int b)\n+{\n+  if (a > b)\n+    {\n+      return a;\n+    }\n+  else\n+    {\n+      return b;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Min -\n+*/\n+\n+static unsigned int Min (unsigned int a, unsigned int b)\n+{\n+  if (a < b)\n+    {\n+      return a;\n+    }\n+  else\n+    {\n+      return b;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   LongMin - returns the smallest LONGCARD\n+*/\n+\n+static long unsigned int LongMin (long unsigned int a, long unsigned int b)\n+{\n+  if (a < b)\n+    {\n+      return a;\n+    }\n+  else\n+    {\n+      return b;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   IsDigit - returns TRUE if, ch, lies between '0'..'9'.\n+*/\n+\n+static unsigned int IsDigit (char ch)\n+{\n+  return (ch >= '0') && (ch <= '9');\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   IsDecimalDigitValid - returns the TRUE if, ch, is a base legal decimal digit.\n+                         If legal then the value is appended numerically onto, c.\n+*/\n+\n+static unsigned int IsDecimalDigitValid (char ch, unsigned int base, unsigned int *c)\n+{\n+  if ((IsDigit (ch)) && (( ((unsigned int) (ch))- ((unsigned int) ('0'))) < base))\n+    {\n+      (*c) = ((*c)*base)+( ((unsigned int) (ch))- ((unsigned int) ('0')));\n+      return TRUE;\n+    }\n+  else\n+    {\n+      return FALSE;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   IsHexidecimalDigitValid - returns the TRUE if, ch, is a base legal hexidecimal digit.\n+                             If legal then the value is appended numerically onto, c.\n+*/\n+\n+static unsigned int IsHexidecimalDigitValid (char ch, unsigned int base, unsigned int *c)\n+{\n+  if (((ch >= 'a') && (ch <= 'f')) && ((( ((unsigned int) (ch))- ((unsigned int) ('a')))+10) < base))\n+    {\n+      (*c) = ((*c)*base)+(( ((unsigned int) (ch))- ((unsigned int) ('a')))+10);\n+      return TRUE;\n+    }\n+  else if (((ch >= 'A') && (ch <= 'F')) && ((( ((unsigned int) (ch))- ((unsigned int) ('F')))+10) < base))\n+    {\n+      /* avoid dangling else.  */\n+      (*c) = ((*c)*base)+(( ((unsigned int) (ch))- ((unsigned int) ('A')))+10);\n+      return TRUE;\n+    }\n+  else\n+    {\n+      /* avoid dangling else.  */\n+      return FALSE;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   IsDecimalDigitValidLong - returns the TRUE if, ch, is a base legal decimal digit.\n+                             If legal then the value is appended numerically onto, c.\n+*/\n+\n+static unsigned int IsDecimalDigitValidLong (char ch, unsigned int base, long unsigned int *c)\n+{\n+  if ((IsDigit (ch)) && (( ((unsigned int) (ch))- ((unsigned int) ('0'))) < base))\n+    {\n+      (*c) = (*c)*((long unsigned int ) (base+( ((unsigned int) (ch))- ((unsigned int) ('0')))));\n+      return TRUE;\n+    }\n+  else\n+    {\n+      return FALSE;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   IsHexidecimalDigitValidLong - returns the TRUE if, ch, is a base legal hexidecimal digit.\n+                                 If legal then the value is appended numerically onto, c.\n+*/\n+\n+static unsigned int IsHexidecimalDigitValidLong (char ch, unsigned int base, long unsigned int *c)\n+{\n+  if (((ch >= 'a') && (ch <= 'f')) && ((( ((unsigned int) (ch))- ((unsigned int) ('a')))+10) < base))\n+    {\n+      (*c) = (*c)*((long unsigned int ) (base+(( ((unsigned int) (ch))- ((unsigned int) ('a')))+10)));\n+      return TRUE;\n+    }\n+  else if (((ch >= 'A') && (ch <= 'F')) && ((( ((unsigned int) (ch))- ((unsigned int) ('F')))+10) < base))\n+    {\n+      /* avoid dangling else.  */\n+      (*c) = (*c)*((long unsigned int ) (base+(( ((unsigned int) (ch))- ((unsigned int) ('A')))+10)));\n+      return TRUE;\n+    }\n+  else\n+    {\n+      /* avoid dangling else.  */\n+      return FALSE;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   IsDecimalDigitValidShort - returns the TRUE if, ch, is a base legal decimal digit.\n+                              If legal then the value is appended numerically onto, c.\n+*/\n+\n+static unsigned int IsDecimalDigitValidShort (char ch, unsigned int base, short unsigned int *c)\n+{\n+  if ((IsDigit (ch)) && (( ((unsigned int) (ch))- ((unsigned int) ('0'))) < base))\n+    {\n+      (*c) = (*c)*((short unsigned int ) (base+( ((unsigned int) (ch))- ((unsigned int) ('0')))));\n+      return TRUE;\n+    }\n+  else\n+    {\n+      return FALSE;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   IsHexidecimalDigitValidShort - returns the TRUE if, ch, is a base legal hexidecimal digit.\n+                                  If legal then the value is appended numerically onto, c.\n+*/\n+\n+static unsigned int IsHexidecimalDigitValidShort (char ch, unsigned int base, short unsigned int *c)\n+{\n+  if (((ch >= 'a') && (ch <= 'f')) && ((( ((unsigned int) (ch))- ((unsigned int) ('a')))+10) < base))\n+    {\n+      (*c) = (*c)*((short unsigned int ) (base+(( ((unsigned int) (ch))- ((unsigned int) ('a')))+10)));\n+      return TRUE;\n+    }\n+  else if (((ch >= 'A') && (ch <= 'F')) && ((( ((unsigned int) (ch))- ((unsigned int) ('F')))+10) < base))\n+    {\n+      /* avoid dangling else.  */\n+      (*c) = (*c)*((short unsigned int ) (base+(( ((unsigned int) (ch))- ((unsigned int) ('A')))+10)));\n+      return TRUE;\n+    }\n+  else\n+    {\n+      /* avoid dangling else.  */\n+      return FALSE;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   ToThePower10 - returns a LONGREAL containing the value of v * 10^power.\n+*/\n+\n+static long double ToThePower10 (long double v, int power)\n+{\n+  int i;\n+\n+  i = 0;\n+  if (power > 0)\n+    {\n+      while (i < power)\n+        {\n+          v = v*10.0;\n+          i += 1;\n+        }\n+    }\n+  else\n+    {\n+      while (i > power)\n+        {\n+          v = v/10.0;\n+          i -= 1;\n+        }\n+    }\n+  return v;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   DetermineSafeTruncation - we wish to use TRUNC when converting REAL/LONGREAL\n+                             into a string for the non fractional component.\n+                             However we need a simple method to\n+                             determine the maximum safe truncation value.\n+*/\n+\n+static unsigned int DetermineSafeTruncation (void)\n+{\n+  double MaxPowerOfTen;\n+  unsigned int LogPower;\n+\n+  MaxPowerOfTen = static_cast<double> (1.0);\n+  LogPower = 0;\n+  while ((MaxPowerOfTen*10.0) < ((double) ((INT_MAX) / 10)))\n+    {\n+      MaxPowerOfTen = MaxPowerOfTen*10.0;\n+      LogPower += 1;\n+    }\n+  return LogPower;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   rtos -\n+*/\n+\n+static DynamicStrings_String rtos (double r, unsigned int TotalWidth, unsigned int FractionWidth)\n+{\n+  M2RTS_HALT (-1);\n+  __builtin_unreachable ();\n+  return static_cast<DynamicStrings_String> (NULL);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   lrtos -\n+*/\n+\n+static DynamicStrings_String lrtos (long double r, unsigned int TotalWidth, unsigned int FractionWidth)\n+{\n+  M2RTS_HALT (-1);\n+  __builtin_unreachable ();\n+  return static_cast<DynamicStrings_String> (NULL);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   doDecimalPlaces - returns a string which is accurate to\n+                     n decimal places.  It returns a new String\n+                     and, s, will be destroyed.\n+*/\n+\n+static DynamicStrings_String doDecimalPlaces (DynamicStrings_String s, unsigned int n)\n+{\n+  int i;\n+  int l;\n+  int point;\n+  DynamicStrings_String t;\n+  DynamicStrings_String whole;\n+  DynamicStrings_String fraction;\n+  DynamicStrings_String tenths;\n+  DynamicStrings_String hundreths;\n+\n+  l = DynamicStrings_Length (s);\n+  i = 0;\n+  /* remove '.'  */\n+  point = DynamicStrings_Index (s, '.', 0);\n+  if (point == 0)\n+    {\n+      s = DynamicStrings_Slice (DynamicStrings_Mark (s), 1, 0);\n+    }\n+  else if (point < l)\n+    {\n+      /* avoid dangling else.  */\n+      s = DynamicStrings_ConCat (DynamicStrings_Slice (DynamicStrings_Mark (s), 0, point), DynamicStrings_Mark (DynamicStrings_Slice (DynamicStrings_Mark (s), point+1, 0)));\n+    }\n+  else\n+    {\n+      /* avoid dangling else.  */\n+      s = DynamicStrings_Slice (DynamicStrings_Mark (s), 0, point);\n+    }\n+  l = DynamicStrings_Length (s);\n+  i = 0;\n+  if (l > 0)\n+    {\n+      /* skip over leading zeros  */\n+      while ((i < l) && ((DynamicStrings_char (s, i)) == '0'))\n+        {\n+          i += 1;\n+        }\n+      /* was the string full of zeros?  */\n+      if ((i == l) && ((DynamicStrings_char (s, i-1)) == '0'))\n+        {\n+          s = DynamicStrings_KillString (s);\n+          s = DynamicStrings_ConCat (DynamicStrings_InitString ((const char *) \"0.\", 2), DynamicStrings_Mark (DynamicStrings_Mult (DynamicStrings_Mark (DynamicStrings_InitStringChar ('0')), n)));\n+          return s;\n+        }\n+    }\n+  /* insert leading zero  */\n+  s = DynamicStrings_ConCat (DynamicStrings_InitStringChar ('0'), DynamicStrings_Mark (s));\n+  point += 1;  /* and move point position to correct place  */\n+  l = DynamicStrings_Length (s);  /* update new length  */\n+  i = point;  /* update new length  */\n+  while ((n > 1) && (i < l))\n+    {\n+      n -= 1;\n+      i += 1;\n+    }\n+  if ((i+3) <= l)\n+    {\n+      t = DynamicStrings_Dup (s);\n+      hundreths = DynamicStrings_Slice (DynamicStrings_Mark (s), i+1, i+3);\n+      s = t;\n+      if ((StringConvert_stoc (hundreths)) >= 50)\n+        {\n+          s = carryOne (DynamicStrings_Mark (s), static_cast<unsigned int> (i));\n+        }\n+      hundreths = DynamicStrings_KillString (hundreths);\n+    }\n+  else if ((i+2) <= l)\n+    {\n+      /* avoid dangling else.  */\n+      t = DynamicStrings_Dup (s);\n+      tenths = DynamicStrings_Slice (DynamicStrings_Mark (s), i+1, i+2);\n+      s = t;\n+      if ((StringConvert_stoc (tenths)) >= 5)\n+        {\n+          s = carryOne (DynamicStrings_Mark (s), static_cast<unsigned int> (i));\n+        }\n+      tenths = DynamicStrings_KillString (tenths);\n+    }\n+  /* check whether we need to remove the leading zero  */\n+  if ((DynamicStrings_char (s, 0)) == '0')\n+    {\n+      s = DynamicStrings_Slice (DynamicStrings_Mark (s), 1, 0);\n+      l -= 1;\n+      point -= 1;\n+    }\n+  if (i < l)\n+    {\n+      s = DynamicStrings_Slice (DynamicStrings_Mark (s), 0, i);\n+      l = DynamicStrings_Length (s);\n+      if (l < point)\n+        {\n+          s = DynamicStrings_ConCat (s, DynamicStrings_Mult (DynamicStrings_Mark (DynamicStrings_InitStringChar ('0')), static_cast<unsigned int> (point-l)));\n+        }\n+    }\n+  /* re-insert the point  */\n+  if (point >= 0)\n+    {\n+      /* avoid gcc warning by using compound statement even if not strictly necessary.  */\n+      if (point == 0)\n+        {\n+          s = DynamicStrings_ConCat (DynamicStrings_InitStringChar ('.'), DynamicStrings_Mark (s));\n+        }\n+      else\n+        {\n+          s = DynamicStrings_ConCat (DynamicStrings_ConCatChar (DynamicStrings_Slice (DynamicStrings_Mark (s), 0, point), '.'), DynamicStrings_Mark (DynamicStrings_Slice (DynamicStrings_Mark (s), point, 0)));\n+        }\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   doSigFig - returns a string which is accurate to\n+              n decimal places.  It returns a new String\n+              and, s, will be destroyed.\n+*/\n+\n+static DynamicStrings_String doSigFig (DynamicStrings_String s, unsigned int n)\n+{\n+  int i;\n+  int l;\n+  int z;\n+  int point;\n+  DynamicStrings_String t;\n+  DynamicStrings_String tenths;\n+  DynamicStrings_String hundreths;\n+\n+  l = DynamicStrings_Length (s);\n+  i = 0;\n+  /* remove '.'  */\n+  point = DynamicStrings_Index (s, '.', 0);\n+  if (point >= 0)\n+    {\n+      if (point == 0)\n+        {\n+          s = DynamicStrings_Slice (DynamicStrings_Mark (s), 1, 0);\n+        }\n+      else if (point < l)\n+        {\n+          /* avoid dangling else.  */\n+          s = DynamicStrings_ConCat (DynamicStrings_Slice (DynamicStrings_Mark (s), 0, point), DynamicStrings_Mark (DynamicStrings_Slice (DynamicStrings_Mark (s), point+1, 0)));\n+        }\n+      else\n+        {\n+          /* avoid dangling else.  */\n+          s = DynamicStrings_Slice (DynamicStrings_Mark (s), 0, point);\n+        }\n+    }\n+  else\n+    {\n+      s = DynamicStrings_Dup (DynamicStrings_Mark (s));\n+    }\n+  l = DynamicStrings_Length (s);\n+  i = 0;\n+  if (l > 0)\n+    {\n+      /* skip over leading zeros  */\n+      while ((i < l) && ((DynamicStrings_char (s, i)) == '0'))\n+        {\n+          i += 1;\n+        }\n+      /* was the string full of zeros?  */\n+      if ((i == l) && ((DynamicStrings_char (s, i-1)) == '0'))\n+        {\n+          /* truncate string  */\n+          s = DynamicStrings_Slice (DynamicStrings_Mark (s), 0, static_cast<int> (n));\n+          i = n;\n+        }\n+    }\n+  /* add a leading zero in case we need to overflow the carry  */\n+  z = i;  /* remember where we inserted zero  */\n+  if (z == 0)  /* remember where we inserted zero  */\n+    {\n+      s = DynamicStrings_ConCat (DynamicStrings_InitStringChar ('0'), DynamicStrings_Mark (s));\n+    }\n+  else\n+    {\n+      s = DynamicStrings_ConCat (DynamicStrings_ConCatChar (DynamicStrings_Slice (DynamicStrings_Mark (s), 0, i), '0'), DynamicStrings_Mark (DynamicStrings_Slice (DynamicStrings_Mark (s), i, 0)));\n+    }\n+  n += 1;  /* and increase the number of sig figs needed  */\n+  l = DynamicStrings_Length (s);  /* and increase the number of sig figs needed  */\n+  while ((n > 1) && (i < l))\n+    {\n+      n -= 1;\n+      i += 1;\n+    }\n+  if ((i+3) <= l)\n+    {\n+      t = DynamicStrings_Dup (s);\n+      hundreths = DynamicStrings_Slice (DynamicStrings_Mark (s), i+1, i+3);\n+      s = t;\n+      if ((StringConvert_stoc (hundreths)) >= 50)\n+        {\n+          s = carryOne (DynamicStrings_Mark (s), static_cast<unsigned int> (i));\n+        }\n+      hundreths = DynamicStrings_KillString (hundreths);\n+    }\n+  else if ((i+2) <= l)\n+    {\n+      /* avoid dangling else.  */\n+      t = DynamicStrings_Dup (s);\n+      tenths = DynamicStrings_Slice (DynamicStrings_Mark (s), i+1, i+2);\n+      s = t;\n+      if ((StringConvert_stoc (tenths)) >= 5)\n+        {\n+          s = carryOne (DynamicStrings_Mark (s), static_cast<unsigned int> (i));\n+        }\n+      tenths = DynamicStrings_KillString (tenths);\n+    }\n+  /* check whether we need to remove the leading zero  */\n+  if ((DynamicStrings_char (s, z)) == '0')\n+    {\n+      if (z == 0)\n+        {\n+          s = DynamicStrings_Slice (DynamicStrings_Mark (s), z+1, 0);\n+        }\n+      else\n+        {\n+          s = DynamicStrings_ConCat (DynamicStrings_Slice (DynamicStrings_Mark (s), 0, z), DynamicStrings_Mark (DynamicStrings_Slice (DynamicStrings_Mark (s), z+1, 0)));\n+        }\n+      l = DynamicStrings_Length (s);\n+    }\n+  else\n+    {\n+      point += 1;\n+    }\n+  if (i < l)\n+    {\n+      s = DynamicStrings_Slice (DynamicStrings_Mark (s), 0, i);\n+      l = DynamicStrings_Length (s);\n+      if (l < point)\n+        {\n+          s = DynamicStrings_ConCat (s, DynamicStrings_Mult (DynamicStrings_Mark (DynamicStrings_InitStringChar ('0')), static_cast<unsigned int> (point-l)));\n+        }\n+    }\n+  /* re-insert the point  */\n+  if (point >= 0)\n+    {\n+      /* avoid gcc warning by using compound statement even if not strictly necessary.  */\n+      if (point == 0)\n+        {\n+          s = DynamicStrings_ConCat (DynamicStrings_InitStringChar ('.'), DynamicStrings_Mark (s));\n+        }\n+      else\n+        {\n+          s = DynamicStrings_ConCat (DynamicStrings_ConCatChar (DynamicStrings_Slice (DynamicStrings_Mark (s), 0, point), '.'), DynamicStrings_Mark (DynamicStrings_Slice (DynamicStrings_Mark (s), point, 0)));\n+        }\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   carryOne - add a carry at position, i.\n+*/\n+\n+static DynamicStrings_String carryOne (DynamicStrings_String s, unsigned int i)\n+{\n+  if (i >= 0)\n+    {\n+      if (IsDigit (DynamicStrings_char (s, static_cast<int> (i))))\n+        {\n+          /* avoid gcc warning by using compound statement even if not strictly necessary.  */\n+          if ((DynamicStrings_char (s, static_cast<int> (i))) == '9')\n+            {\n+              if (i == 0)\n+                {\n+                  s = DynamicStrings_ConCat (DynamicStrings_InitStringChar ('1'), DynamicStrings_Mark (s));\n+                  return s;\n+                }\n+              else\n+                {\n+                  s = DynamicStrings_ConCat (DynamicStrings_ConCatChar (DynamicStrings_Slice (DynamicStrings_Mark (s), 0, static_cast<int> (i)), '0'), DynamicStrings_Mark (DynamicStrings_Slice (DynamicStrings_Mark (s), static_cast<int> (i+1), 0)));\n+                  return carryOne (s, i-1);\n+                }\n+            }\n+          else\n+            {\n+              if (i == 0)\n+                {\n+                  s = DynamicStrings_ConCat (DynamicStrings_InitStringChar ( ((char) ( ((unsigned int) (DynamicStrings_char (s, static_cast<int> (i))))+1))), DynamicStrings_Mark (DynamicStrings_Slice (DynamicStrings_Mark (s), static_cast<int> (i+1), 0)));\n+                }\n+              else\n+                {\n+                  s = DynamicStrings_ConCat (DynamicStrings_ConCatChar (DynamicStrings_Slice (DynamicStrings_Mark (s), 0, static_cast<int> (i)), ((char) ( ((unsigned int) (DynamicStrings_char (s, static_cast<int> (i))))+1))), DynamicStrings_Mark (DynamicStrings_Slice (DynamicStrings_Mark (s), static_cast<int> (i+1), 0)));\n+                }\n+            }\n+        }\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   IntegerToString - converts INTEGER, i, into a String. The field with can be specified\n+                     if non zero. Leading characters are defined by padding and this\n+                     function will prepend a + if sign is set to TRUE.\n+                     The base allows the caller to generate binary, octal, decimal, hexidecimal\n+                     numbers. The value of lower is only used when hexidecimal numbers are\n+                     generated and if TRUE then digits abcdef are used, and if FALSE then ABCDEF\n+                     are used.\n+*/\n+\n+extern \"C\" DynamicStrings_String StringConvert_IntegerToString (int i, unsigned int width, char padding, unsigned int sign, unsigned int base, unsigned int lower)\n+{\n+  DynamicStrings_String s;\n+  unsigned int c;\n+\n+  if (i < 0)\n+    {\n+      if (i == (INT_MIN))\n+        {\n+          /* remember that -15 MOD 4 = 1 in Modula-2  */\n+          c = ((unsigned int ) (abs (i+1)))+1;\n+          if (width > 0)\n+            {\n+              return DynamicStrings_ConCat (StringConvert_IntegerToString (-((int ) (c / base)), width-1, padding, sign, base, lower), DynamicStrings_Mark (StringConvert_IntegerToString (static_cast<int> (c % base), 0, ' ', FALSE, base, lower)));\n+            }\n+          else\n+            {\n+              return DynamicStrings_ConCat (StringConvert_IntegerToString (-((int ) (c / base)), 0, padding, sign, base, lower), DynamicStrings_Mark (StringConvert_IntegerToString (static_cast<int> (c % base), 0, ' ', FALSE, base, lower)));\n+            }\n+        }\n+      else\n+        {\n+          s = DynamicStrings_InitString ((const char *) \"-\", 1);\n+        }\n+      i = -i;\n+    }\n+  else\n+    {\n+      if (sign)\n+        {\n+          s = DynamicStrings_InitString ((const char *) \"+\", 1);\n+        }\n+      else\n+        {\n+          s = DynamicStrings_InitString ((const char *) \"\", 0);\n+        }\n+    }\n+  if (i > (((int ) (base))-1))\n+    {\n+      s = DynamicStrings_ConCat (DynamicStrings_ConCat (s, DynamicStrings_Mark (StringConvert_IntegerToString (static_cast<int> (((unsigned int ) (i)) / base), 0, ' ', FALSE, base, lower))), DynamicStrings_Mark (StringConvert_IntegerToString (static_cast<int> (((unsigned int ) (i)) % base), 0, ' ', FALSE, base, lower)));\n+    }\n+  else\n+    {\n+      if (i <= 9)\n+        {\n+          s = DynamicStrings_ConCat (s, DynamicStrings_Mark (DynamicStrings_InitStringChar ( ((char) (((unsigned int ) (i))+ ((unsigned int) ('0')))))));\n+        }\n+      else\n+        {\n+          if (lower)\n+            {\n+              s = DynamicStrings_ConCat (s, DynamicStrings_Mark (DynamicStrings_InitStringChar ( ((char) ((((unsigned int ) (i))+ ((unsigned int) ('a')))-10)))));\n+            }\n+          else\n+            {\n+              s = DynamicStrings_ConCat (s, DynamicStrings_Mark (DynamicStrings_InitStringChar ( ((char) ((((unsigned int ) (i))+ ((unsigned int) ('A')))-10)))));\n+            }\n+        }\n+    }\n+  if (width > (DynamicStrings_Length (s)))\n+    {\n+      return DynamicStrings_ConCat (DynamicStrings_Mult (DynamicStrings_Mark (DynamicStrings_InitStringChar (padding)), width-(DynamicStrings_Length (s))), DynamicStrings_Mark (s));\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   CardinalToString - converts CARDINAL, c, into a String. The field with can be specified\n+                      if non zero. Leading characters are defined by padding.\n+                      The base allows the caller to generate binary, octal, decimal, hexidecimal\n+                      numbers. The value of lower is only used when hexidecimal numbers are\n+                      generated and if TRUE then digits abcdef are used, and if FALSE then ABCDEF\n+                      are used.\n+*/\n+\n+extern \"C\" DynamicStrings_String StringConvert_CardinalToString (unsigned int c, unsigned int width, char padding, unsigned int base, unsigned int lower)\n+{\n+  DynamicStrings_String s;\n+\n+  s = DynamicStrings_InitString ((const char *) \"\", 0);\n+  if (c > (base-1))\n+    {\n+      s = DynamicStrings_ConCat (DynamicStrings_ConCat (s, DynamicStrings_Mark (StringConvert_CardinalToString (c / base, 0, ' ', base, lower))), DynamicStrings_Mark (StringConvert_CardinalToString (c % base, 0, ' ', base, lower)));\n+    }\n+  else\n+    {\n+      if (c <= 9)\n+        {\n+          s = DynamicStrings_ConCat (s, DynamicStrings_Mark (DynamicStrings_InitStringChar ( ((char) (c+ ((unsigned int) ('0')))))));\n+        }\n+      else\n+        {\n+          if (lower)\n+            {\n+              s = DynamicStrings_ConCat (s, DynamicStrings_Mark (DynamicStrings_InitStringChar ( ((char) ((c+ ((unsigned int) ('a')))-10)))));\n+            }\n+          else\n+            {\n+              s = DynamicStrings_ConCat (s, DynamicStrings_Mark (DynamicStrings_InitStringChar ( ((char) ((c+ ((unsigned int) ('A')))-10)))));\n+            }\n+        }\n+    }\n+  if (width > (DynamicStrings_Length (s)))\n+    {\n+      return DynamicStrings_ConCat (DynamicStrings_Mult (DynamicStrings_Mark (DynamicStrings_InitStringChar (padding)), width-(DynamicStrings_Length (s))), s);\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   StringToInteger - converts a string, s, of, base, into an INTEGER.\n+                     Leading white space is ignored. It stops converting\n+                     when either the string is exhausted or if an illegal\n+                     numeral is found.\n+                     The parameter found is set TRUE if a number was found.\n+*/\n+\n+extern \"C\" int StringConvert_StringToInteger (DynamicStrings_String s, unsigned int base, unsigned int *found)\n+{\n+  unsigned int n;\n+  unsigned int l;\n+  unsigned int c;\n+  unsigned int negative;\n+\n+  s = DynamicStrings_RemoveWhitePrefix (s);  /* returns a new string, s  */\n+  l = DynamicStrings_Length (s);  /* returns a new string, s  */\n+  c = 0;\n+  n = 0;\n+  negative = FALSE;\n+  if (n < l)\n+    {\n+      /* parse leading + and -  */\n+      while (((DynamicStrings_char (s, static_cast<int> (n))) == '-') || ((DynamicStrings_char (s, static_cast<int> (n))) == '+'))\n+        {\n+          if ((DynamicStrings_char (s, static_cast<int> (n))) == '-')\n+            {\n+              negative = ! negative;\n+            }\n+          n += 1;\n+        }\n+      while ((n < l) && ((IsDecimalDigitValid (DynamicStrings_char (s, static_cast<int> (n)), base, &c)) || (IsHexidecimalDigitValid (DynamicStrings_char (s, static_cast<int> (n)), base, &c))))\n+        {\n+          (*found) = TRUE;\n+          n += 1;\n+        }\n+    }\n+  s = DynamicStrings_KillString (s);\n+  if (negative)\n+    {\n+      return -((int ) (Min (((unsigned int ) (INT_MAX))+1, c)));\n+    }\n+  else\n+    {\n+      return (int ) (Min (static_cast<unsigned int> (INT_MAX), c));\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   StringToCardinal - converts a string, s, of, base, into a CARDINAL.\n+                      Leading white space is ignored. It stops converting\n+                      when either the string is exhausted or if an illegal\n+                      numeral is found.\n+                      The parameter found is set TRUE if a number was found.\n+*/\n+\n+extern \"C\" unsigned int StringConvert_StringToCardinal (DynamicStrings_String s, unsigned int base, unsigned int *found)\n+{\n+  unsigned int n;\n+  unsigned int l;\n+  unsigned int c;\n+\n+  s = DynamicStrings_RemoveWhitePrefix (s);  /* returns a new string, s  */\n+  l = DynamicStrings_Length (s);  /* returns a new string, s  */\n+  c = 0;\n+  n = 0;\n+  if (n < l)\n+    {\n+      /* parse leading +  */\n+      while ((DynamicStrings_char (s, static_cast<int> (n))) == '+')\n+        {\n+          n += 1;\n+        }\n+      while ((n < l) && ((IsDecimalDigitValid (DynamicStrings_char (s, static_cast<int> (n)), base, &c)) || (IsHexidecimalDigitValid (DynamicStrings_char (s, static_cast<int> (n)), base, &c))))\n+        {\n+          (*found) = TRUE;\n+          n += 1;\n+        }\n+    }\n+  s = DynamicStrings_KillString (s);\n+  return c;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   LongIntegerToString - converts LONGINT, i, into a String. The field with\n+                         can be specified if non zero. Leading characters\n+                         are defined by padding and this function will\n+                         prepend a + if sign is set to TRUE.\n+                         The base allows the caller to generate binary,\n+                         octal, decimal, hexidecimal numbers.\n+                         The value of lower is only used when hexidecimal\n+                         numbers are generated and if TRUE then digits\n+                         abcdef are used, and if FALSE then ABCDEF are used.\n+*/\n+\n+extern \"C\" DynamicStrings_String StringConvert_LongIntegerToString (long int i, unsigned int width, char padding, unsigned int sign, unsigned int base, unsigned int lower)\n+{\n+  DynamicStrings_String s;\n+  long unsigned int c;\n+\n+  if (i < 0)\n+    {\n+      if (i == (LONG_MIN))\n+        {\n+          /* remember that -15 MOD 4 is 1 in Modula-2, and although ABS(MIN(LONGINT)+1)\n+            is very likely MAX(LONGINT), it is safer not to assume this is the case  */\n+          c = ((long unsigned int ) (labs (i+1)))+1;\n+          if (width > 0)\n+            {\n+              return DynamicStrings_ConCat (StringConvert_LongIntegerToString (-((long int ) (c / ((long unsigned int ) (base)))), width-1, padding, sign, base, lower), DynamicStrings_Mark (StringConvert_LongIntegerToString (static_cast<long int> (c % ((long unsigned int ) (base))), 0, ' ', FALSE, base, lower)));\n+            }\n+          else\n+            {\n+              return DynamicStrings_ConCat (StringConvert_LongIntegerToString (-((long int ) (c / ((long unsigned int ) (base)))), 0, padding, sign, base, lower), DynamicStrings_Mark (StringConvert_LongIntegerToString (static_cast<long int> (c % ((long unsigned int ) (base))), 0, ' ', FALSE, base, lower)));\n+            }\n+        }\n+      else\n+        {\n+          s = DynamicStrings_InitString ((const char *) \"-\", 1);\n+        }\n+      i = -i;\n+    }\n+  else\n+    {\n+      if (sign)\n+        {\n+          s = DynamicStrings_InitString ((const char *) \"+\", 1);\n+        }\n+      else\n+        {\n+          s = DynamicStrings_InitString ((const char *) \"\", 0);\n+        }\n+    }\n+  if (i > ((long int ) (base-1)))\n+    {\n+      s = DynamicStrings_ConCat (DynamicStrings_ConCat (s, DynamicStrings_Mark (StringConvert_LongIntegerToString (i / ((long int ) (base)), 0, ' ', FALSE, base, lower))), DynamicStrings_Mark (StringConvert_LongIntegerToString (i % ((long int ) (base)), 0, ' ', FALSE, base, lower)));\n+    }\n+  else\n+    {\n+      if (i <= 9)\n+        {\n+          s = DynamicStrings_ConCat (s, DynamicStrings_Mark (DynamicStrings_InitStringChar ( ((char) (((unsigned int ) (i))+ ((unsigned int) ('0')))))));\n+        }\n+      else\n+        {\n+          if (lower)\n+            {\n+              s = DynamicStrings_ConCat (s, DynamicStrings_Mark (DynamicStrings_InitStringChar ( ((char) ((((unsigned int ) (i))+ ((unsigned int) ('a')))-10)))));\n+            }\n+          else\n+            {\n+              s = DynamicStrings_ConCat (s, DynamicStrings_Mark (DynamicStrings_InitStringChar ( ((char) ((((unsigned int ) (i))+ ((unsigned int) ('A')))-10)))));\n+            }\n+        }\n+    }\n+  if (width > (DynamicStrings_Length (s)))\n+    {\n+      return DynamicStrings_ConCat (DynamicStrings_Mult (DynamicStrings_Mark (DynamicStrings_InitStringChar (padding)), width-(DynamicStrings_Length (s))), s);\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   StringToLongInteger - converts a string, s, of, base, into an LONGINT.\n+                         Leading white space is ignored. It stops converting\n+                         when either the string is exhausted or if an illegal\n+                         numeral is found.\n+                         The parameter found is set TRUE if a number was found.\n+*/\n+\n+extern \"C\" long int StringConvert_StringToLongInteger (DynamicStrings_String s, unsigned int base, unsigned int *found)\n+{\n+  unsigned int n;\n+  unsigned int l;\n+  long unsigned int c;\n+  unsigned int negative;\n+\n+  s = DynamicStrings_RemoveWhitePrefix (s);  /* returns a new string, s  */\n+  l = DynamicStrings_Length (s);  /* returns a new string, s  */\n+  c = 0;\n+  n = 0;\n+  negative = FALSE;\n+  if (n < l)\n+    {\n+      /* parse leading + and -  */\n+      while (((DynamicStrings_char (s, static_cast<int> (n))) == '-') || ((DynamicStrings_char (s, static_cast<int> (n))) == '+'))\n+        {\n+          if ((DynamicStrings_char (s, static_cast<int> (n))) == '-')\n+            {\n+              negative = ! negative;\n+            }\n+          n += 1;\n+        }\n+      while ((n < l) && ((IsDecimalDigitValidLong (DynamicStrings_char (s, static_cast<int> (n)), base, &c)) || (IsHexidecimalDigitValidLong (DynamicStrings_char (s, static_cast<int> (n)), base, &c))))\n+        {\n+          (*found) = TRUE;\n+          n += 1;\n+        }\n+    }\n+  s = DynamicStrings_KillString (s);\n+  if (negative)\n+    {\n+      return -((long int ) (LongMin (((long unsigned int ) (LONG_MAX))+1, c)));\n+    }\n+  else\n+    {\n+      return (long int ) (LongMin (static_cast<long unsigned int> (LONG_MAX), c));\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   LongCardinalToString - converts LONGCARD, c, into a String. The field\n+                          width can be specified if non zero. Leading\n+                          characters are defined by padding.\n+                          The base allows the caller to generate binary,\n+                          octal, decimal, hexidecimal numbers.\n+                          The value of lower is only used when hexidecimal\n+                          numbers are generated and if TRUE then digits\n+                          abcdef are used, and if FALSE then ABCDEF are used.\n+*/\n+\n+extern \"C\" DynamicStrings_String StringConvert_LongCardinalToString (long unsigned int c, unsigned int width, char padding, unsigned int base, unsigned int lower)\n+{\n+  DynamicStrings_String s;\n+\n+  s = DynamicStrings_InitString ((const char *) \"\", 0);\n+  if (c > ((long unsigned int ) (base-1)))\n+    {\n+      s = DynamicStrings_ConCat (DynamicStrings_ConCat (s, StringConvert_LongCardinalToString (c / ((long unsigned int ) (base)), 0, ' ', base, lower)), StringConvert_LongCardinalToString (c % ((long unsigned int ) (base)), 0, ' ', base, lower));\n+    }\n+  else\n+    {\n+      if (c <= 9)\n+        {\n+          s = DynamicStrings_ConCat (s, DynamicStrings_InitStringChar ( ((char) (((unsigned int ) (c))+ ((unsigned int) ('0'))))));\n+        }\n+      else\n+        {\n+          if (lower)\n+            {\n+              s = DynamicStrings_ConCat (s, DynamicStrings_InitStringChar ( ((char) ((((unsigned int ) (c))+ ((unsigned int) ('a')))-10))));\n+            }\n+          else\n+            {\n+              s = DynamicStrings_ConCat (s, DynamicStrings_InitStringChar ( ((char) ((((unsigned int ) (c))+ ((unsigned int) ('A')))-10))));\n+            }\n+        }\n+    }\n+  if (width > (DynamicStrings_Length (s)))\n+    {\n+      return DynamicStrings_ConCat (DynamicStrings_Mult (DynamicStrings_Mark (DynamicStrings_InitStringChar (padding)), width-(DynamicStrings_Length (s))), s);\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   StringToLongCardinal - converts a string, s, of, base, into a LONGCARD.\n+                          Leading white space is ignored. It stops converting\n+                          when either the string is exhausted or if an illegal\n+                          numeral is found.\n+                          The parameter found is set TRUE if a number was found.\n+*/\n+\n+extern \"C\" long unsigned int StringConvert_StringToLongCardinal (DynamicStrings_String s, unsigned int base, unsigned int *found)\n+{\n+  unsigned int n;\n+  unsigned int l;\n+  long unsigned int c;\n+\n+  s = DynamicStrings_RemoveWhitePrefix (s);  /* returns a new string, s  */\n+  l = DynamicStrings_Length (s);  /* returns a new string, s  */\n+  c = 0;\n+  n = 0;\n+  if (n < l)\n+    {\n+      /* parse leading +  */\n+      while ((DynamicStrings_char (s, static_cast<int> (n))) == '+')\n+        {\n+          n += 1;\n+        }\n+      while ((n < l) && ((IsDecimalDigitValidLong (DynamicStrings_char (s, static_cast<int> (n)), base, &c)) || (IsHexidecimalDigitValidLong (DynamicStrings_char (s, static_cast<int> (n)), base, &c))))\n+        {\n+          (*found) = TRUE;\n+          n += 1;\n+        }\n+    }\n+  s = DynamicStrings_KillString (s);\n+  return c;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   ShortCardinalToString - converts SHORTCARD, c, into a String. The field\n+                          width can be specified if non zero. Leading\n+                          characters are defined by padding.\n+                          The base allows the caller to generate binary,\n+                          octal, decimal, hexidecimal numbers.\n+                          The value of lower is only used when hexidecimal\n+                          numbers are generated and if TRUE then digits\n+                          abcdef are used, and if FALSE then ABCDEF are used.\n+*/\n+\n+extern \"C\" DynamicStrings_String StringConvert_ShortCardinalToString (short unsigned int c, unsigned int width, char padding, unsigned int base, unsigned int lower)\n+{\n+  DynamicStrings_String s;\n+\n+  s = DynamicStrings_InitString ((const char *) \"\", 0);\n+  if (((unsigned int ) (c)) > (base-1))\n+    {\n+      s = DynamicStrings_ConCat (DynamicStrings_ConCat (s, StringConvert_ShortCardinalToString (c / ((short unsigned int ) (base)), 0, ' ', base, lower)), StringConvert_ShortCardinalToString (c % ((short unsigned int ) (base)), 0, ' ', base, lower));\n+    }\n+  else\n+    {\n+      if (c <= 9)\n+        {\n+          s = DynamicStrings_ConCat (s, DynamicStrings_InitStringChar ( ((char) (((unsigned int ) (c))+ ((unsigned int) ('0'))))));\n+        }\n+      else\n+        {\n+          if (lower)\n+            {\n+              s = DynamicStrings_ConCat (s, DynamicStrings_InitStringChar ( ((char) ((((unsigned int ) (c))+ ((unsigned int) ('a')))-10))));\n+            }\n+          else\n+            {\n+              s = DynamicStrings_ConCat (s, DynamicStrings_InitStringChar ( ((char) ((((unsigned int ) (c))+ ((unsigned int) ('A')))-10))));\n+            }\n+        }\n+    }\n+  if (width > (DynamicStrings_Length (s)))\n+    {\n+      return DynamicStrings_ConCat (DynamicStrings_Mult (DynamicStrings_Mark (DynamicStrings_InitStringChar (padding)), width-(DynamicStrings_Length (s))), s);\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   StringToShortCardinal - converts a string, s, of, base, into a SHORTCARD.\n+                           Leading white space is ignored. It stops converting\n+                           when either the string is exhausted or if an illegal\n+                           numeral is found.\n+                           The parameter found is set TRUE if a number was found.\n+*/\n+\n+extern \"C\" short unsigned int StringConvert_StringToShortCardinal (DynamicStrings_String s, unsigned int base, unsigned int *found)\n+{\n+  unsigned int n;\n+  unsigned int l;\n+  short unsigned int c;\n+\n+  s = DynamicStrings_RemoveWhitePrefix (s);  /* returns a new string, s  */\n+  l = DynamicStrings_Length (s);  /* returns a new string, s  */\n+  c = 0;\n+  n = 0;\n+  if (n < l)\n+    {\n+      /* parse leading +  */\n+      while ((DynamicStrings_char (s, static_cast<int> (n))) == '+')\n+        {\n+          n += 1;\n+        }\n+      while ((n < l) && ((IsDecimalDigitValidShort (DynamicStrings_char (s, static_cast<int> (n)), base, &c)) || (IsHexidecimalDigitValidShort (DynamicStrings_char (s, static_cast<int> (n)), base, &c))))\n+        {\n+          (*found) = TRUE;\n+          n += 1;\n+        }\n+    }\n+  s = DynamicStrings_KillString (s);\n+  return c;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   stoi - decimal string to INTEGER\n+*/\n+\n+extern \"C\" int StringConvert_stoi (DynamicStrings_String s)\n+{\n+  unsigned int found;\n+\n+  return StringConvert_StringToInteger (s, 10, &found);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   itos - integer to decimal string.\n+*/\n+\n+extern \"C\" DynamicStrings_String StringConvert_itos (int i, unsigned int width, char padding, unsigned int sign)\n+{\n+  return StringConvert_IntegerToString (i, width, padding, sign, 10, FALSE);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   ctos - cardinal to decimal string.\n+*/\n+\n+extern \"C\" DynamicStrings_String StringConvert_ctos (unsigned int c, unsigned int width, char padding)\n+{\n+  return StringConvert_CardinalToString (c, width, padding, 10, FALSE);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   stoc - decimal string to CARDINAL\n+*/\n+\n+extern \"C\" unsigned int StringConvert_stoc (DynamicStrings_String s)\n+{\n+  unsigned int found;\n+\n+  return StringConvert_StringToCardinal (s, 10, &found);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   hstoi - hexidecimal string to INTEGER\n+*/\n+\n+extern \"C\" int StringConvert_hstoi (DynamicStrings_String s)\n+{\n+  unsigned int found;\n+\n+  return StringConvert_StringToInteger (s, 16, &found);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   ostoi - octal string to INTEGER\n+*/\n+\n+extern \"C\" int StringConvert_ostoi (DynamicStrings_String s)\n+{\n+  unsigned int found;\n+\n+  return StringConvert_StringToInteger (s, 8, &found);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   bstoi - binary string to INTEGER\n+*/\n+\n+extern \"C\" int StringConvert_bstoi (DynamicStrings_String s)\n+{\n+  unsigned int found;\n+\n+  return StringConvert_StringToInteger (s, 2, &found);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   hstoc - hexidecimal string to CARDINAL\n+*/\n+\n+extern \"C\" unsigned int StringConvert_hstoc (DynamicStrings_String s)\n+{\n+  unsigned int found;\n+\n+  return StringConvert_StringToCardinal (s, 16, &found);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   ostoc - octal string to CARDINAL\n+*/\n+\n+extern \"C\" unsigned int StringConvert_ostoc (DynamicStrings_String s)\n+{\n+  unsigned int found;\n+\n+  return StringConvert_StringToCardinal (s, 8, &found);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   bstoc - binary string to CARDINAL\n+*/\n+\n+extern \"C\" unsigned int StringConvert_bstoc (DynamicStrings_String s)\n+{\n+  unsigned int found;\n+\n+  return StringConvert_StringToCardinal (s, 2, &found);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   StringToLongreal - returns a LONGREAL and sets found to TRUE if a legal number is seen.\n+*/\n+\n+extern \"C\" long double StringConvert_StringToLongreal (DynamicStrings_String s, unsigned int *found)\n+{\n+  unsigned int error;\n+  long double value;\n+\n+  s = DynamicStrings_RemoveWhitePrefix (s);  /* new string is created  */\n+  value = ldtoa_strtold (DynamicStrings_string (s), &error);  /* new string is created  */\n+  s = DynamicStrings_KillString (s);\n+  (*found) = ! error;\n+  return value;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   LongrealToString - converts a LONGREAL number, Real, which has,\n+                      TotalWidth, and FractionWidth into a string.\n+                      It uses decimal notation.\n+\n+                      So for example:\n+\n+                      LongrealToString(1.0, 4, 2)  -> '1.00'\n+                      LongrealToString(12.3, 5, 2) -> '12.30'\n+                      LongrealToString(12.3, 6, 2) -> ' 12.30'\n+                      LongrealToString(12.3, 6, 3) -> '12.300'\n+\n+                      if total width is too small then the fraction\n+                      becomes truncated.\n+\n+                      LongrealToString(12.3, 5, 3) -> '12.30'\n+\n+                      Positive numbers do not have a '+' prepended.\n+                      Negative numbers will have a '-' prepended and\n+                      the TotalWidth will need to be large enough\n+                      to contain the sign, whole number, '.' and\n+                      fractional components.\n+*/\n+\n+extern \"C\" DynamicStrings_String StringConvert_LongrealToString (long double x, unsigned int TotalWidth, unsigned int FractionWidth)\n+{\n+  unsigned int maxprecision;\n+  DynamicStrings_String s;\n+  void * r;\n+  int point;\n+  unsigned int sign;\n+  int l;\n+\n+  if (TotalWidth == 0)\n+    {\n+      maxprecision = TRUE;\n+      r = ldtoa_ldtoa (x, ldtoa_decimaldigits, 100, &point, &sign);\n+    }\n+  else\n+    {\n+      r = ldtoa_ldtoa (x, ldtoa_decimaldigits, 100, &point, &sign);\n+    }\n+  s = DynamicStrings_InitStringCharStar (r);\n+  libc_free (r);\n+  l = DynamicStrings_Length (s);\n+  if (point > l)\n+    {\n+      /* avoid dangling else.  */\n+      s = DynamicStrings_ConCat (s, DynamicStrings_Mark (DynamicStrings_Mult (DynamicStrings_Mark (DynamicStrings_InitStringChar ('0')), static_cast<unsigned int> (point-l))));\n+      s = DynamicStrings_ConCat (s, DynamicStrings_Mark (DynamicStrings_InitString ((const char *) \".0\", 2)));\n+      if (! maxprecision && (FractionWidth > 0))\n+        {\n+          FractionWidth -= 1;\n+          if (((int ) (FractionWidth)) > (point-l))\n+            {\n+              s = DynamicStrings_ConCat (s, DynamicStrings_Mark (DynamicStrings_Mult (DynamicStrings_Mark (DynamicStrings_InitString ((const char *) \"0\", 1)), FractionWidth)));\n+            }\n+        }\n+    }\n+  else if (point < 0)\n+    {\n+      /* avoid dangling else.  */\n+      s = DynamicStrings_ConCat (DynamicStrings_Mult (DynamicStrings_Mark (DynamicStrings_InitStringChar ('0')), static_cast<unsigned int> (-point)), DynamicStrings_Mark (s));\n+      l = DynamicStrings_Length (s);\n+      s = DynamicStrings_ConCat (DynamicStrings_InitString ((const char *) \"0.\", 2), DynamicStrings_Mark (s));\n+      if (! maxprecision && (l < ((int ) (FractionWidth))))\n+        {\n+          s = DynamicStrings_ConCat (s, DynamicStrings_Mark (DynamicStrings_Mult (DynamicStrings_Mark (DynamicStrings_InitString ((const char *) \"0\", 1)), static_cast<unsigned int> (((int ) (FractionWidth))-l))));\n+        }\n+    }\n+  else\n+    {\n+      /* avoid dangling else.  */\n+      if (point == 0)\n+        {\n+          s = DynamicStrings_ConCat (DynamicStrings_InitString ((const char *) \"0.\", 2), DynamicStrings_Mark (DynamicStrings_Slice (DynamicStrings_Mark (s), point, 0)));\n+        }\n+      else\n+        {\n+          s = DynamicStrings_ConCat (DynamicStrings_ConCatChar (DynamicStrings_Slice (DynamicStrings_Mark (s), 0, point), '.'), DynamicStrings_Mark (DynamicStrings_Slice (DynamicStrings_Mark (s), point, 0)));\n+        }\n+      if (! maxprecision && ((l-point) < ((int ) (FractionWidth))))\n+        {\n+          s = DynamicStrings_ConCat (s, DynamicStrings_Mark (DynamicStrings_Mult (DynamicStrings_Mark (DynamicStrings_InitString ((const char *) \"0\", 1)), static_cast<unsigned int> (((int ) (FractionWidth))-(l-point)))));\n+        }\n+    }\n+  if ((DynamicStrings_Length (s)) > TotalWidth)\n+    {\n+      /* avoid gcc warning by using compound statement even if not strictly necessary.  */\n+      if (TotalWidth > 0)\n+        {\n+          if (sign)\n+            {\n+              s = DynamicStrings_Slice (DynamicStrings_Mark (StringConvert_ToDecimalPlaces (s, FractionWidth)), 0, static_cast<int> (TotalWidth-1));\n+              s = DynamicStrings_ConCat (DynamicStrings_InitStringChar ('-'), DynamicStrings_Mark (s));\n+              sign = FALSE;\n+            }\n+          else\n+            {\n+              /* minus 1 because all results will include a '.'  */\n+              s = DynamicStrings_Slice (DynamicStrings_Mark (StringConvert_ToDecimalPlaces (s, FractionWidth)), 0, static_cast<int> (TotalWidth));\n+            }\n+        }\n+      else\n+        {\n+          if (sign)\n+            {\n+              s = StringConvert_ToDecimalPlaces (s, FractionWidth);\n+              s = DynamicStrings_ConCat (DynamicStrings_InitStringChar ('-'), DynamicStrings_Mark (s));\n+              sign = FALSE;\n+            }\n+          else\n+            {\n+              /* minus 1 because all results will include a '.'  */\n+              s = StringConvert_ToDecimalPlaces (s, FractionWidth);\n+            }\n+        }\n+    }\n+  if ((DynamicStrings_Length (s)) < TotalWidth)\n+    {\n+      s = DynamicStrings_ConCat (DynamicStrings_Mult (DynamicStrings_Mark (DynamicStrings_InitStringChar (' ')), TotalWidth-(DynamicStrings_Length (s))), DynamicStrings_Mark (s));\n+    }\n+  return s;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   stor - returns a REAL given a string.\n+*/\n+\n+extern \"C\" double StringConvert_stor (DynamicStrings_String s)\n+{\n+  unsigned int found;\n+\n+  return (double ) (StringConvert_StringToLongreal (s, &found));\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   stolr - returns a LONGREAL given a string.\n+*/\n+\n+extern \"C\" long double StringConvert_stolr (DynamicStrings_String s)\n+{\n+  unsigned int found;\n+\n+  return StringConvert_StringToLongreal (s, &found);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   ToSigFig - returns a floating point or base 10 integer\n+              string which is accurate to, n, significant\n+              figures.  It will return a new String\n+              and, s, will be destroyed.\n+\n+\n+              So:  12.345\n+\n+              rounded to the following significant figures yields\n+\n+              5      12.345\n+              4      12.34\n+              3      12.3\n+              2      12\n+              1      10\n+*/\n+\n+extern \"C\" DynamicStrings_String StringConvert_ToSigFig (DynamicStrings_String s, unsigned int n)\n+{\n+  int point;\n+  unsigned int poTen;\n+\n+  Assert ((IsDigit (DynamicStrings_char (s, 0))) || ((DynamicStrings_char (s, 0)) == '.'), (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/StringConvert.mod\", 54, 1222, (const char *) \"ToSigFig\", 8);\n+  point = DynamicStrings_Index (s, '.', 0);\n+  if (point < 0)\n+    {\n+      poTen = DynamicStrings_Length (s);\n+    }\n+  else\n+    {\n+      poTen = point;\n+    }\n+  s = doSigFig (s, n);\n+  /* if the last character is '.' remove it  */\n+  if (((DynamicStrings_Length (s)) > 0) && ((DynamicStrings_char (s, -1)) == '.'))\n+    {\n+      return DynamicStrings_Slice (DynamicStrings_Mark (s), 0, -1);\n+    }\n+  else\n+    {\n+      if (poTen > (DynamicStrings_Length (s)))\n+        {\n+          s = DynamicStrings_ConCat (s, DynamicStrings_Mark (DynamicStrings_Mult (DynamicStrings_Mark (DynamicStrings_InitStringChar ('0')), poTen-(DynamicStrings_Length (s)))));\n+        }\n+      return s;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   ToDecimalPlaces - returns a floating point or base 10 integer\n+                     string which is accurate to, n, decimal\n+                     places.  It will return a new String\n+                     and, s, will be destroyed.\n+                     Decimal places yields, n, digits after\n+                     the .\n+\n+                     So:  12.345\n+\n+                     rounded to the following decimal places yields\n+\n+                     5      12.34500\n+                     4      12.3450\n+                     3      12.345\n+                     2      12.34\n+                     1      12.3\n+*/\n+\n+extern \"C\" DynamicStrings_String StringConvert_ToDecimalPlaces (DynamicStrings_String s, unsigned int n)\n+{\n+  int point;\n+\n+  Assert ((IsDigit (DynamicStrings_char (s, 0))) || ((DynamicStrings_char (s, 0)) == '.'), (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/StringConvert.mod\", 54, 1069, (const char *) \"ToDecimalPlaces\", 15);\n+  point = DynamicStrings_Index (s, '.', 0);\n+  if (point < 0)\n+    {\n+      /* avoid gcc warning by using compound statement even if not strictly necessary.  */\n+      if (n > 0)\n+        {\n+          return DynamicStrings_ConCat (DynamicStrings_ConCat (s, DynamicStrings_Mark (DynamicStrings_InitStringChar ('.'))), DynamicStrings_Mult (DynamicStrings_Mark (DynamicStrings_InitStringChar ('0')), n));\n+        }\n+      else\n+        {\n+          return s;\n+        }\n+    }\n+  s = doDecimalPlaces (s, n);\n+  /* if the last character is '.' remove it  */\n+  if (((DynamicStrings_Length (s)) > 0) && ((DynamicStrings_char (s, -1)) == '.'))\n+    {\n+      return DynamicStrings_Slice (DynamicStrings_Mark (s), 0, -1);\n+    }\n+  else\n+    {\n+      return s;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" void _M2_StringConvert_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}\n+\n+extern \"C\" void _M2_StringConvert_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "98c03f66c358a38149f154fab251348c49339263", "filename": "gcc/m2/mc-boot/GSysStorage.cc", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGSysStorage.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGSysStorage.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGSysStorage.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,249 @@\n+/* do not edit automatically generated by mc from SysStorage.  */\n+/* SysStorage.mod provides dynamic allocation for the system components.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#   if !defined (TRUE)\n+#      define TRUE (1==1)\n+#   endif\n+\n+#   if !defined (FALSE)\n+#      define FALSE (1==0)\n+#   endif\n+\n+#if defined(__cplusplus)\n+#   undef NULL\n+#   define NULL 0\n+#endif\n+#define _SysStorage_H\n+#define _SysStorage_C\n+\n+#   include \"Glibc.h\"\n+#   include \"GDebug.h\"\n+#   include \"GSYSTEM.h\"\n+\n+#   define enableDeallocation TRUE\n+#   define enableZero FALSE\n+#   define enableTrace FALSE\n+static unsigned int callno;\n+static unsigned int zero;\n+static unsigned int trace;\n+extern \"C\" void SysStorage_ALLOCATE (void * *a, unsigned int size);\n+extern \"C\" void SysStorage_DEALLOCATE (void * *a, unsigned int size);\n+\n+/*\n+   REALLOCATE - attempts to reallocate storage. The address,\n+                a, should either be NIL in which case ALLOCATE\n+                is called, or alternatively it should have already\n+                been initialized by ALLOCATE. The allocated storage\n+                is resized accordingly.\n+*/\n+\n+extern \"C\" void SysStorage_REALLOCATE (void * *a, unsigned int size);\n+\n+/*\n+   REALLOCATE - attempts to reallocate storage. The address,\n+                a, should either be NIL in which case ALLOCATE\n+                is called, or alternatively it should have already\n+                been initialized by ALLOCATE. The allocated storage\n+                is resized accordingly.\n+*/\n+\n+extern \"C\" unsigned int SysStorage_Available (unsigned int size);\n+\n+/*\n+   Init - initializes the heap.  This does nothing on a GNU/Linux system.\n+          But it remains here since it might be used in an embedded system.\n+*/\n+\n+extern \"C\" void SysStorage_Init (void);\n+\n+extern \"C\" void SysStorage_ALLOCATE (void * *a, unsigned int size)\n+{\n+  (*a) = libc_malloc (static_cast<size_t> (size));\n+  if ((*a) == NULL)\n+    {\n+      Debug_Halt ((const char *) \"out of memory error\", 19, 50, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/SysStorage.mod\", 51);\n+    }\n+  if (enableTrace && trace)\n+    {\n+      libc_printf ((const char *) \"<DEBUG-CALL> %d SysStorage.ALLOCATE (0x%x, %d bytes)\\\\n\", 54, callno, (*a), size);\n+      libc_printf ((const char *) \"<MEM-ALLOC> %ld %d\\\\n\", 20, (*a), size);\n+      callno += 1;\n+    }\n+}\n+\n+extern \"C\" void SysStorage_DEALLOCATE (void * *a, unsigned int size)\n+{\n+  if (enableTrace && trace)\n+    {\n+      libc_printf ((const char *) \"<DEBUG-CALL> %d SysStorage.DEALLOCATE (0x%x, %d bytes)\\\\n\", 56, callno, (*a), size);\n+      callno += 1;\n+    }\n+  if (enableZero && zero)\n+    {\n+      if (enableTrace && trace)\n+        {\n+          libc_printf ((const char *) \"  memset (0x%x, 0, %d bytes)\\\\n\", 30, (*a), size);\n+        }\n+      if ((libc_memset ((*a), 0, static_cast<size_t> (size))) != (*a))\n+        {\n+          Debug_Halt ((const char *) \"memset should have returned the first parameter\", 47, 76, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/SysStorage.mod\", 51);\n+        }\n+    }\n+  if (enableDeallocation)\n+    {\n+      if (enableTrace && trace)\n+        {\n+          libc_printf ((const char *) \"  free (0x%x)   %d bytes\\\\n\", 26, (*a), size);\n+          libc_printf ((const char *) \"<MEM-FREE> %ld %d\\\\n\", 19, (*a), size);\n+        }\n+      libc_free ((*a));\n+    }\n+  (*a) = NULL;\n+}\n+\n+\n+/*\n+   REALLOCATE - attempts to reallocate storage. The address,\n+                a, should either be NIL in which case ALLOCATE\n+                is called, or alternatively it should have already\n+                been initialized by ALLOCATE. The allocated storage\n+                is resized accordingly.\n+*/\n+\n+extern \"C\" void SysStorage_REALLOCATE (void * *a, unsigned int size)\n+{\n+  if ((*a) == NULL)\n+    {\n+      SysStorage_ALLOCATE (a, size);\n+    }\n+  else\n+    {\n+      if (enableTrace && trace)\n+        {\n+          libc_printf ((const char *) \"<DEBUG-CALL> %d SysStorage.REALLOCATE (0x%x, %d bytes)\\\\n\", 56, callno, (*a), size);\n+          callno += 1;\n+        }\n+      if (enableTrace && trace)\n+        {\n+          libc_printf ((const char *) \"  realloc (0x%x, %d bytes)  ->  \", 32, (*a), size);\n+          libc_printf ((const char *) \"<MEM-FREE> %ld %d\\\\n\", 19, (*a), size);\n+        }\n+      (*a) = libc_realloc ((*a), static_cast<size_t> (size));\n+      if ((*a) == NULL)\n+        {\n+          Debug_Halt ((const char *) \"out of memory error\", 19, 119, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/SysStorage.mod\", 51);\n+        }\n+      if (enableTrace && trace)\n+        {\n+          libc_printf ((const char *) \"<MEM-ALLOC> %ld %d\\\\n\", 20, (*a), size);\n+          libc_printf ((const char *) \"  0x%x  %d bytes\\\\n\", 18, (*a), size);\n+        }\n+    }\n+}\n+\n+\n+/*\n+   REALLOCATE - attempts to reallocate storage. The address,\n+                a, should either be NIL in which case ALLOCATE\n+                is called, or alternatively it should have already\n+                been initialized by ALLOCATE. The allocated storage\n+                is resized accordingly.\n+*/\n+\n+extern \"C\" unsigned int SysStorage_Available (unsigned int size)\n+{\n+  void * a;\n+\n+  if (enableTrace && trace)\n+    {\n+      libc_printf ((const char *) \"<DEBUG-CALL> %d SysStorage.Available (%d bytes)\\\\n\", 49, callno, size);\n+      callno += 1;\n+    }\n+  a = libc_malloc (static_cast<size_t> (size));\n+  if (a == NULL)\n+    {\n+      if (enableTrace && trace)\n+        {\n+          libc_printf ((const char *) \"   no\\\\n\", 7, size);\n+        }\n+      return FALSE;\n+    }\n+  else\n+    {\n+      if (enableTrace && trace)\n+        {\n+          libc_printf ((const char *) \"   yes\\\\n\", 8, size);\n+        }\n+      libc_free (a);\n+      return TRUE;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   Init - initializes the heap.  This does nothing on a GNU/Linux system.\n+          But it remains here since it might be used in an embedded system.\n+*/\n+\n+extern \"C\" void SysStorage_Init (void)\n+{\n+}\n+\n+extern \"C\" void _M2_SysStorage_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+  callno = 0;\n+  if (enableTrace)\n+    {\n+      trace = (libc_getenv (const_cast<void*> (reinterpret_cast<const void*>(\"M2DEBUG_SYSSTORAGE_trace\")))) != NULL;\n+    }\n+  else\n+    {\n+      trace = FALSE;\n+    }\n+  if (enableZero)\n+    {\n+      zero = (libc_getenv (const_cast<void*> (reinterpret_cast<const void*>(\"M2DEBUG_SYSSTORAGE_zero\")))) != NULL;\n+    }\n+  else\n+    {\n+      zero = FALSE;\n+    }\n+}\n+\n+extern \"C\" void _M2_SysStorage_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "7e50f4b755187c290795d1b2c8dcd0417ddde218", "filename": "gcc/m2/mc-boot/GTimeString.cc", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGTimeString.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGTimeString.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGTimeString.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,91 @@\n+/* do not edit automatically generated by mc from TimeString.  */\n+/* TimeString.mod provides time related string manipulation procedures.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#if defined(__cplusplus)\n+#   undef NULL\n+#   define NULL 0\n+#endif\n+#define _TimeString_H\n+#define _TimeString_C\n+\n+#   include \"Gwrapc.h\"\n+#   include \"GASCII.h\"\n+#   include \"GSYSTEM.h\"\n+\n+\n+/*\n+   GetTimeString - places the time in ascii format into array, a.\n+\n+*/\n+\n+extern \"C\" void TimeString_GetTimeString (char *a, unsigned int _a_high);\n+\n+\n+/*\n+   GetTimeString - places the time in ascii format into array, a.\n+\n+*/\n+\n+extern \"C\" void TimeString_GetTimeString (char *a, unsigned int _a_high)\n+{\n+  typedef char *GetTimeString__T1;\n+\n+  GetTimeString__T1 Addr;\n+  unsigned int i;\n+\n+  Addr = static_cast<GetTimeString__T1> (wrapc_strtime ());\n+  i = 0;\n+  if (Addr != NULL)\n+    {\n+      while ((i < _a_high) && ((*Addr) != ASCII_nul))\n+        {\n+          a[i] = (*Addr);\n+          i += 1;\n+          Addr += 1;\n+        }\n+    }\n+  if (i < _a_high)\n+    {\n+      a[i] = ASCII_nul;\n+    }\n+}\n+\n+extern \"C\" void _M2_TimeString_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}\n+\n+extern \"C\" void _M2_TimeString_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "3e84a5003377fe995f41aa7da808e111a6c2e739", "filename": "gcc/m2/mc-boot/Galists.cc", "status": "added", "additions": 440, "deletions": 0, "changes": 440, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGalists.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGalists.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGalists.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5", "patch": "@@ -0,0 +1,440 @@\n+/* do not edit automatically generated by mc from alists.  */\n+/* alists.mod address lists module.\n+\n+Copyright (C) 2015-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius@glam.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Modula-2; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#   if !defined (PROC_D)\n+#      define PROC_D\n+       typedef void (*PROC_t) (void);\n+       typedef struct { PROC_t proc; } PROC;\n+#   endif\n+\n+#   if !defined (TRUE)\n+#      define TRUE (1==1)\n+#   endif\n+\n+#   if !defined (FALSE)\n+#      define FALSE (1==0)\n+#   endif\n+\n+#   include \"GStorage.h\"\n+#if defined(__cplusplus)\n+#   undef NULL\n+#   define NULL 0\n+#endif\n+#define _alists_H\n+#define _alists_C\n+\n+#   include \"GStorage.h\"\n+\n+typedef struct alists_performOperation_p alists_performOperation;\n+\n+#   define MaxnoOfelements 5\n+typedef struct alists__T1_r alists__T1;\n+\n+typedef struct alists__T2_a alists__T2;\n+\n+typedef alists__T1 *alists_alist;\n+\n+typedef void (*alists_performOperation_t) (void *);\n+struct alists_performOperation_p { alists_performOperation_t proc; };\n+\n+struct alists__T2_a { void * array[MaxnoOfelements-1+1]; };\n+struct alists__T1_r {\n+                      unsigned int noOfelements;\n+                      alists__T2 elements;\n+                      alists_alist next;\n+                    };\n+\n+\n+/*\n+   initList - creates a new alist, l.\n+*/\n+\n+extern \"C\" alists_alist alists_initList (void);\n+\n+/*\n+   killList - deletes the complete alist, l.\n+*/\n+\n+extern \"C\" void alists_killList (alists_alist *l);\n+\n+/*\n+   putItemIntoList - places an ADDRESS, c, into alist, l.\n+*/\n+\n+extern \"C\" void alists_putItemIntoList (alists_alist l, void * c);\n+\n+/*\n+   getItemFromList - retrieves the nth WORD from alist, l.\n+*/\n+\n+extern \"C\" void * alists_getItemFromList (alists_alist l, unsigned int n);\n+\n+/*\n+   getIndexOfList - returns the index for WORD, c, in alist, l.\n+                    If more than one WORD, c, exists the index\n+                    for the first is returned.\n+*/\n+\n+extern \"C\" unsigned int alists_getIndexOfList (alists_alist l, void * c);\n+\n+/*\n+   noOfItemsInList - returns the number of items in alist, l.\n+*/\n+\n+extern \"C\" unsigned int alists_noOfItemsInList (alists_alist l);\n+\n+/*\n+   includeItemIntoList - adds an ADDRESS, c, into a alist providing\n+                         the value does not already exist.\n+*/\n+\n+extern \"C\" void alists_includeItemIntoList (alists_alist l, void * c);\n+\n+/*\n+   removeItemFromList - removes a ADDRESS, c, from a alist.\n+                        It assumes that this value only appears once.\n+*/\n+\n+extern \"C\" void alists_removeItemFromList (alists_alist l, void * c);\n+\n+/*\n+   isItemInList - returns true if a ADDRESS, c, was found in alist, l.\n+*/\n+\n+extern \"C\" unsigned int alists_isItemInList (alists_alist l, void * c);\n+\n+/*\n+   foreachItemInListDo - calls procedure, P, foreach item in alist, l.\n+*/\n+\n+extern \"C\" void alists_foreachItemInListDo (alists_alist l, alists_performOperation p);\n+\n+/*\n+   duplicateList - returns a duplicate alist derived from, l.\n+*/\n+\n+extern \"C\" alists_alist alists_duplicateList (alists_alist l);\n+\n+/*\n+   removeItem - remove an element at index, i, from the alist data type.\n+*/\n+\n+static void removeItem (alists_alist p, alists_alist l, unsigned int i);\n+\n+\n+/*\n+   removeItem - remove an element at index, i, from the alist data type.\n+*/\n+\n+static void removeItem (alists_alist p, alists_alist l, unsigned int i)\n+{\n+  l->noOfelements -= 1;\n+  while (i <= l->noOfelements)\n+    {\n+      l->elements.array[i-1] = l->elements.array[i+1-1];\n+      i += 1;\n+    }\n+  if ((l->noOfelements == 0) && (p != NULL))\n+    {\n+      p->next = l->next;\n+      Storage_DEALLOCATE ((void **) &l, sizeof (alists__T1));\n+    }\n+}\n+\n+\n+/*\n+   initList - creates a new alist, l.\n+*/\n+\n+extern \"C\" alists_alist alists_initList (void)\n+{\n+  alists_alist l;\n+\n+  Storage_ALLOCATE ((void **) &l, sizeof (alists__T1));\n+  l->noOfelements = 0;\n+  l->next = NULL;\n+  return l;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   killList - deletes the complete alist, l.\n+*/\n+\n+extern \"C\" void alists_killList (alists_alist *l)\n+{\n+  if ((*l) != NULL)\n+    {\n+      if ((*l)->next != NULL)\n+        {\n+          alists_killList (&(*l)->next);\n+        }\n+      Storage_DEALLOCATE ((void **) &(*l), sizeof (alists__T1));\n+    }\n+}\n+\n+\n+/*\n+   putItemIntoList - places an ADDRESS, c, into alist, l.\n+*/\n+\n+extern \"C\" void alists_putItemIntoList (alists_alist l, void * c)\n+{\n+  if (l->noOfelements < MaxnoOfelements)\n+    {\n+      l->noOfelements += 1;\n+      l->elements.array[l->noOfelements-1] = c;\n+    }\n+  else if (l->next != NULL)\n+    {\n+      /* avoid dangling else.  */\n+      alists_putItemIntoList (l->next, c);\n+    }\n+  else\n+    {\n+      /* avoid dangling else.  */\n+      l->next = alists_initList ();\n+      alists_putItemIntoList (l->next, c);\n+    }\n+}\n+\n+\n+/*\n+   getItemFromList - retrieves the nth WORD from alist, l.\n+*/\n+\n+extern \"C\" void * alists_getItemFromList (alists_alist l, unsigned int n)\n+{\n+  while (l != NULL)\n+    {\n+      if (n <= l->noOfelements)\n+        {\n+          return l->elements.array[n-1];\n+        }\n+      else\n+        {\n+          n -= l->noOfelements;\n+        }\n+      l = l->next;\n+    }\n+  return reinterpret_cast<void *> (0);\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   getIndexOfList - returns the index for WORD, c, in alist, l.\n+                    If more than one WORD, c, exists the index\n+                    for the first is returned.\n+*/\n+\n+extern \"C\" unsigned int alists_getIndexOfList (alists_alist l, void * c)\n+{\n+  unsigned int i;\n+\n+  if (l == NULL)\n+    {\n+      return 0;\n+    }\n+  else\n+    {\n+      i = 1;\n+      while (i <= l->noOfelements)\n+        {\n+          if (l->elements.array[i-1] == c)\n+            {\n+              return i;\n+            }\n+          else\n+            {\n+              i += 1;\n+            }\n+        }\n+      return l->noOfelements+(alists_getIndexOfList (l->next, c));\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   noOfItemsInList - returns the number of items in alist, l.\n+*/\n+\n+extern \"C\" unsigned int alists_noOfItemsInList (alists_alist l)\n+{\n+  unsigned int t;\n+\n+  if (l == NULL)\n+    {\n+      return 0;\n+    }\n+  else\n+    {\n+      t = 0;\n+      do {\n+        t += l->noOfelements;\n+        l = l->next;\n+      } while (! (l == NULL));\n+      return t;\n+    }\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   includeItemIntoList - adds an ADDRESS, c, into a alist providing\n+                         the value does not already exist.\n+*/\n+\n+extern \"C\" void alists_includeItemIntoList (alists_alist l, void * c)\n+{\n+  if (! (alists_isItemInList (l, c)))\n+    {\n+      alists_putItemIntoList (l, c);\n+    }\n+}\n+\n+\n+/*\n+   removeItemFromList - removes a ADDRESS, c, from a alist.\n+                        It assumes that this value only appears once.\n+*/\n+\n+extern \"C\" void alists_removeItemFromList (alists_alist l, void * c)\n+{\n+  alists_alist p;\n+  unsigned int i;\n+  unsigned int found;\n+\n+  if (l != NULL)\n+    {\n+      found = FALSE;\n+      p = NULL;\n+      do {\n+        i = 1;\n+        while ((i <= l->noOfelements) && (l->elements.array[i-1] != c))\n+          {\n+            i += 1;\n+          }\n+        if ((i <= l->noOfelements) && (l->elements.array[i-1] == c))\n+          {\n+            found = TRUE;\n+          }\n+        else\n+          {\n+            p = l;\n+            l = l->next;\n+          }\n+      } while (! ((l == NULL) || found));\n+      if (found)\n+        {\n+          removeItem (p, l, i);\n+        }\n+    }\n+}\n+\n+\n+/*\n+   isItemInList - returns true if a ADDRESS, c, was found in alist, l.\n+*/\n+\n+extern \"C\" unsigned int alists_isItemInList (alists_alist l, void * c)\n+{\n+  unsigned int i;\n+\n+  do {\n+    i = 1;\n+    while (i <= l->noOfelements)\n+      {\n+        if (l->elements.array[i-1] == c)\n+          {\n+            return TRUE;\n+          }\n+        else\n+          {\n+            i += 1;\n+          }\n+      }\n+    l = l->next;\n+  } while (! (l == NULL));\n+  return FALSE;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+\n+/*\n+   foreachItemInListDo - calls procedure, P, foreach item in alist, l.\n+*/\n+\n+extern \"C\" void alists_foreachItemInListDo (alists_alist l, alists_performOperation p)\n+{\n+  unsigned int i;\n+  unsigned int n;\n+\n+  n = alists_noOfItemsInList (l);\n+  i = 1;\n+  while (i <= n)\n+    {\n+      (*p.proc) (alists_getItemFromList (l, i));\n+      i += 1;\n+    }\n+}\n+\n+\n+/*\n+   duplicateList - returns a duplicate alist derived from, l.\n+*/\n+\n+extern \"C\" alists_alist alists_duplicateList (alists_alist l)\n+{\n+  alists_alist m;\n+  unsigned int n;\n+  unsigned int i;\n+\n+  m = alists_initList ();\n+  n = alists_noOfItemsInList (l);\n+  i = 1;\n+  while (i <= n)\n+    {\n+      alists_putItemIntoList (m, alists_getItemFromList (l, i));\n+      i += 1;\n+    }\n+  return m;\n+  /* static analysis guarentees a RETURN statement will be used before here.  */\n+  __builtin_unreachable ();\n+}\n+\n+extern \"C\" void _M2_alists_init (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}\n+\n+extern \"C\" void _M2_alists_fini (__attribute__((unused)) int argc,__attribute__((unused)) char *argv[],__attribute__((unused)) char *envp[])\n+{\n+}"}, {"sha": "4a851638d391bd4bed8fc78eca4e407389523e16", "filename": "gcc/m2/mc-boot/Gdecl.cc", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGdecl.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "e089ac9525017d6710bbe6cdd0507866f4ac6d21", "filename": "gcc/m2/mc-boot/Gkeyc.cc", "status": "added", "additions": 1619, "deletions": 0, "changes": 1619, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGkeyc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGkeyc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGkeyc.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "63bced70ffdafd1d96eb8b9b9df24561aef562be", "filename": "gcc/m2/mc-boot/Glists.cc", "status": "added", "additions": 439, "deletions": 0, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGlists.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGlists.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGlists.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "2e60c7aa567bc7ad5db88c0f1028a4c7b0b355c2", "filename": "gcc/m2/mc-boot/GmcComment.cc", "status": "added", "additions": 468, "deletions": 0, "changes": 468, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcComment.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcComment.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcComment.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "8a79413add4e28754c279738d96c74ca151e55f7", "filename": "gcc/m2/mc-boot/GmcComp.cc", "status": "added", "additions": 660, "deletions": 0, "changes": 660, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcComp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcComp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcComp.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "db45ae8ac87c55214cbc74b2c287097b9dc6ddf9", "filename": "gcc/m2/mc-boot/GmcDebug.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcDebug.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcDebug.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcDebug.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "cf96ceb79bda0ca6dfc8aef4ea999daf2f55caba", "filename": "gcc/m2/mc-boot/GmcError.cc", "status": "added", "additions": 1197, "deletions": 0, "changes": 1197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcError.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcError.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcError.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "3413d8949d37dd174d46d7fc458cb6e42e33ae9c", "filename": "gcc/m2/mc-boot/GmcFileName.cc", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcFileName.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcFileName.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcFileName.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "d310e87929df51df2226937e024e6ec82fe86e4a", "filename": "gcc/m2/mc-boot/GmcLexBuf.cc", "status": "added", "additions": 1849, "deletions": 0, "changes": 1849, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcLexBuf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcLexBuf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcLexBuf.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "4d406851d0bead784029297713bf2acea949f220", "filename": "gcc/m2/mc-boot/GmcMetaError.cc", "status": "added", "additions": 1880, "deletions": 0, "changes": 1880, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcMetaError.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcMetaError.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcMetaError.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "5d4e31be5a7aff28efe4bbbef9771f76732be4d1", "filename": "gcc/m2/mc-boot/GmcOptions.cc", "status": "added", "additions": 1122, "deletions": 0, "changes": 1122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcOptions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcOptions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcOptions.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "91a50939d800f08c7a6e43cd6029f739630847f9", "filename": "gcc/m2/mc-boot/GmcPreprocess.cc", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcPreprocess.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcPreprocess.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcPreprocess.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "1184514fd252c7c7eeb62675e6a26e739c6fd312", "filename": "gcc/m2/mc-boot/GmcPretty.cc", "status": "added", "additions": 468, "deletions": 0, "changes": 468, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcPretty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcPretty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcPretty.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "a8660a50f4c89856f6969de5fdf004adfad098ed", "filename": "gcc/m2/mc-boot/GmcPrintf.cc", "status": "added", "additions": 655, "deletions": 0, "changes": 655, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcPrintf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcPrintf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcPrintf.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "bcf1026001a559ace1e94da671847ee4e0d0581f", "filename": "gcc/m2/mc-boot/GmcQuiet.cc", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcQuiet.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcQuiet.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcQuiet.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "60b879630bbce97ffb38f9a1e2118045f8fd98f8", "filename": "gcc/m2/mc-boot/GmcReserved.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcReserved.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcReserved.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcReserved.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "a4541fa0d370e335e65b3b471d8b7785561c2514", "filename": "gcc/m2/mc-boot/GmcSearch.cc", "status": "added", "additions": 408, "deletions": 0, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcSearch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcSearch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcSearch.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "95d31a5037b1ece6f8aac6078952df478a95729b", "filename": "gcc/m2/mc-boot/GmcStack.cc", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcStack.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcStack.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcStack.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "e4ce0528cf5cdc7bb4cd21a2d7557db985b074ca", "filename": "gcc/m2/mc-boot/GmcStream.cc", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcStream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcStream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcStream.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "97bedb257140c10ed6a779c77f0c2a9c2291d6d0", "filename": "gcc/m2/mc-boot/Gmcp1.cc", "status": "added", "additions": 7265, "deletions": 0, "changes": 7265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcp1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcp1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcp1.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "85fd19326df4c9f794de072de2688d2816466543", "filename": "gcc/m2/mc-boot/Gmcp2.cc", "status": "added", "additions": 7637, "deletions": 0, "changes": 7637, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcp2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcp2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcp2.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "4ff8d80307ab65ee29b07ffe7ac03ff5ede2e946", "filename": "gcc/m2/mc-boot/Gmcp3.cc", "status": "added", "additions": 7854, "deletions": 0, "changes": 7854, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcp3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcp3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcp3.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "5eab5ae58edfb4648f9880fcd95d81ea7c169426", "filename": "gcc/m2/mc-boot/Gmcp4.cc", "status": "added", "additions": 7717, "deletions": 0, "changes": 7717, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcp4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcp4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcp4.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "9af8aac9dd511a95cc3d9004eeef1a7670aae1ab", "filename": "gcc/m2/mc-boot/Gmcp5.cc", "status": "added", "additions": 8576, "deletions": 0, "changes": 8576, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcp5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGmcp5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGmcp5.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "b00a59868e4cc4e9a56c62bcb9c63fb1781a059b", "filename": "gcc/m2/mc-boot/GnameKey.cc", "status": "added", "additions": 584, "deletions": 0, "changes": 584, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGnameKey.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGnameKey.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGnameKey.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "8c16a63474e5ad5e2fc591a395b50ddc4e749a42", "filename": "gcc/m2/mc-boot/GsymbolKey.cc", "status": "added", "additions": 406, "deletions": 0, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGsymbolKey.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGsymbolKey.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGsymbolKey.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "20c96133c20c12525f30c0041f77e1d1f1d5a064", "filename": "gcc/m2/mc-boot/Gtop.cc", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGtop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGtop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGtop.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "faf7f7703d87a0a755ff116fa1c5270455856bb8", "filename": "gcc/m2/mc-boot/Gvarargs.cc", "status": "added", "additions": 431, "deletions": 0, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGvarargs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGvarargs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGvarargs.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "c8daafd4ff8f55cd24b0257063a0b1f7cfcce9e8", "filename": "gcc/m2/mc-boot/Gwlists.cc", "status": "added", "additions": 471, "deletions": 0, "changes": 471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGwlists.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fmc-boot%2FGwlists.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGwlists.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "077cdffb61363729ef991547c61b8b35440a0b62", "filename": "gcc/m2/pge-boot/GASCII.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGASCII.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGASCII.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGASCII.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "819a46f2806228f53762f413f4bc2bccf27e5bbc", "filename": "gcc/m2/pge-boot/GArgs.cc", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGArgs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGArgs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGArgs.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "5088db4068da248b9acf2a84deaa44f1dc17c07b", "filename": "gcc/m2/pge-boot/GAssertion.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGAssertion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGAssertion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGAssertion.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "30b07e3a9c26de23eda8950f6b96658ae9773413", "filename": "gcc/m2/pge-boot/GBuiltins.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGBuiltins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGBuiltins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGBuiltins.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "431068492ee4a6b41b5b7d1cd6b9887b8cfd651b", "filename": "gcc/m2/pge-boot/GDebug.cc", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGDebug.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGDebug.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGDebug.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "2dd4985b47edc3e444af526f7403b227c6bffd08", "filename": "gcc/m2/pge-boot/GDynamicStrings.cc", "status": "added", "additions": 2679, "deletions": 0, "changes": 2679, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGDynamicStrings.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGDynamicStrings.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGDynamicStrings.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "848860781aae9457619031f2b49113434661429b", "filename": "gcc/m2/pge-boot/GFIO.cc", "status": "added", "additions": 2325, "deletions": 0, "changes": 2325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGFIO.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGFIO.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGFIO.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "1d670569c2a7857a49e971660ad630db58426ec4", "filename": "gcc/m2/pge-boot/GIO.cc", "status": "added", "additions": 479, "deletions": 0, "changes": 479, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGIO.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGIO.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGIO.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "630feb7c69430ceae844906929c1bd682e6c115c", "filename": "gcc/m2/pge-boot/GIndexing.cc", "status": "added", "additions": 493, "deletions": 0, "changes": 493, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGIndexing.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGIndexing.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGIndexing.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "45f0ffcb3d3294d60e06bd11a6c31084e8537a9d", "filename": "gcc/m2/pge-boot/GLists.cc", "status": "added", "additions": 427, "deletions": 0, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGLists.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGLists.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGLists.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "0e0e3eadcc3d027cfa92f323444a1a5c370da6bd", "filename": "gcc/m2/pge-boot/GM2Dependent.cc", "status": "added", "additions": 1410, "deletions": 0, "changes": 1410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGM2Dependent.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGM2Dependent.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGM2Dependent.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "cf19a4e18b7fb5e159a51c656e5fc40079efa9cd", "filename": "gcc/m2/pge-boot/GM2EXCEPTION.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGM2EXCEPTION.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGM2EXCEPTION.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGM2EXCEPTION.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "a934d6ada1cc4022e4e61e3bd1adcde73fe52862", "filename": "gcc/m2/pge-boot/GM2LINK.cc", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGM2LINK.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGM2LINK.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGM2LINK.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "d283f3f7f79356ddf4ab9721c4ce98861368ae5a", "filename": "gcc/m2/pge-boot/GM2RTS.cc", "status": "added", "additions": 822, "deletions": 0, "changes": 822, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGM2RTS.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGM2RTS.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGM2RTS.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "ff8621f959d47173dad06cad762f30999ee6a24b", "filename": "gcc/m2/pge-boot/GNameKey.cc", "status": "added", "additions": 612, "deletions": 0, "changes": 612, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGNameKey.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGNameKey.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGNameKey.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "0e058df5d647a1219ee59b72dc5335020f365310", "filename": "gcc/m2/pge-boot/GNumberIO.cc", "status": "added", "additions": 777, "deletions": 0, "changes": 777, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGNumberIO.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGNumberIO.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGNumberIO.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "22ec0e7b8cf72ca059d26f13f50a7999e805e0d5", "filename": "gcc/m2/pge-boot/GOutput.cc", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGOutput.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGOutput.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGOutput.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "3165ce12be43b4df4c7d603a053fc59202b9afd5", "filename": "gcc/m2/pge-boot/GPushBackInput.cc", "status": "added", "additions": 489, "deletions": 0, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGPushBackInput.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGPushBackInput.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGPushBackInput.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "5c2eccc2eac587178a791e62de01adedb9c04051", "filename": "gcc/m2/pge-boot/GRTExceptions.cc", "status": "added", "additions": 1226, "deletions": 0, "changes": 1226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGRTExceptions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGRTExceptions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGRTExceptions.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "6365d5ee0b145b3ee7dc619fdca03c8ba805e6f0", "filename": "gcc/m2/pge-boot/GRTco.cc", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGRTco.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGRTco.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGRTco.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "4ecfec8e9d2e2a578f5559dbee3c41edc8331b6b", "filename": "gcc/m2/pge-boot/GSFIO.cc", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGSFIO.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGSFIO.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGSFIO.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "8b42999fea5f9eba23f903dc13159ce3c5b9932e", "filename": "gcc/m2/pge-boot/GSYSTEM.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGSYSTEM.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGSYSTEM.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGSYSTEM.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "cf8b541ec40912cc9818cd6600aaff7ad4d2042f", "filename": "gcc/m2/pge-boot/GSelective.cc", "status": "added", "additions": 275, "deletions": 0, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGSelective.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGSelective.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGSelective.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "d918673c9acbdeae5d874011ed7f475ff63356f8", "filename": "gcc/m2/pge-boot/GStdIO.cc", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGStdIO.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGStdIO.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGStdIO.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "d3b8776d5250ef63e7f91bcad6c6bf8d005751d4", "filename": "gcc/m2/pge-boot/GStorage.cc", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGStorage.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGStorage.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGStorage.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "0e6b5bee012c60ed83e8b8f5b2f21eba3317f58a", "filename": "gcc/m2/pge-boot/GStrCase.cc", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGStrCase.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGStrCase.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGStrCase.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "b8c42ac162a368014684268569fa71609e49adfa", "filename": "gcc/m2/pge-boot/GStrIO.cc", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGStrIO.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGStrIO.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGStrIO.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "d5ae7249d893f68ece73559beb275c95d0f685a8", "filename": "gcc/m2/pge-boot/GStrLib.cc", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGStrLib.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGStrLib.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGStrLib.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "699b70a5c626b2df5298720a3d68d4b1e8909414", "filename": "gcc/m2/pge-boot/GSymbolKey.cc", "status": "added", "additions": 556, "deletions": 0, "changes": 556, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGSymbolKey.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGSymbolKey.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGSymbolKey.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "4e600565fe8799ce8ab8ee251d706ababa42eef1", "filename": "gcc/m2/pge-boot/GSysExceptions.cc", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGSysExceptions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGSysExceptions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGSysExceptions.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "d9cd60bd9fc917a93aa0ae95c23e952f102a46d0", "filename": "gcc/m2/pge-boot/GSysStorage.cc", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGSysStorage.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGSysStorage.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGSysStorage.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "5bb34f72d57f599278143dc38224be9b57b29234", "filename": "gcc/m2/pge-boot/Gabort.cc", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGabort.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGabort.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGabort.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "7f78b5d250baeee2b62f8fa2b029ef7d502fd716", "filename": "gcc/m2/pge-boot/Gbnflex.cc", "status": "added", "additions": 602, "deletions": 0, "changes": 602, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGbnflex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGbnflex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGbnflex.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "498774ea3d0533363a2b74e45c66bebdf42008bb", "filename": "gcc/m2/pge-boot/Gcbuiltin.cc", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGcbuiltin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGcbuiltin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGcbuiltin.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "a400bf80f7bba7aa2d4cf04f44272fd3d1d0f1b8", "filename": "gcc/m2/pge-boot/Gdtoa.cc", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGdtoa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGdtoa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGdtoa.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "c65c48630afce3e388aab42999dacef69c833094", "filename": "gcc/m2/pge-boot/Gerrno.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGerrno.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGerrno.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGerrno.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "7c69535f38f655f6ccdcae471d58c3fa4c79492c", "filename": "gcc/m2/pge-boot/Gldtoa.cc", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGldtoa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGldtoa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGldtoa.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "e9395651e90815e75cb5d78f3aec84f1b9b261a2", "filename": "gcc/m2/pge-boot/Glibc.cc", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGlibc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGlibc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGlibc.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "595ac4461604b78f8eb832b27f5d74d8df43a204", "filename": "gcc/m2/pge-boot/Glibm.cc", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGlibm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGlibm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGlibm.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "97c9be1e1e51d8ee9facebb546b0324e48113b16", "filename": "gcc/m2/pge-boot/Gmcrts.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGmcrts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGmcrts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGmcrts.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "e889236b9483de2c64d7a3a8dd1f85d73499829b", "filename": "gcc/m2/pge-boot/Gpge.cc", "status": "added", "additions": 9753, "deletions": 0, "changes": 9753, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGpge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGpge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGpge.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "7c3a431f856c15a5a568fa603c2db0bb1e763169", "filename": "gcc/m2/pge-boot/Gwrapc.cc", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGwrapc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2FGwrapc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2FGwrapc.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "b6f29f628f740e8d25a5dfa531c12a686d9bd09d", "filename": "gcc/m2/pge-boot/main.cc", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2Fmain.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2Fmain.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2Fmain.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}, {"sha": "c2873f9de140e1f936c8c28d20a715c9f6174ad0", "filename": "gcc/m2/pge-boot/network.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2Fnetwork.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5/gcc%2Fm2%2Fpge-boot%2Fnetwork.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fpge-boot%2Fnetwork.cc?ref=fbd2eda12c7fc66d5f24b208985430fcbe6f5ab5"}]}