{"sha": "dcf59c5c0100d0649d64ec948dbe24018d48b6a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGNmNTljNWMwMTAwZDA2NDlkNjRlYzk0OGRiZTI0MDE4ZDQ4YjZhNQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-08-22T16:40:20Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-10-10T15:45:32Z"}, "message": "Darwin : Begin rework of zero-fill sections.\n\nMuch of the existing work in the Darwin BSS and common sections\nwas to accommodate the PowerPC section anchors.  We want to segregate\nthis, since it might become desirable to support section anchors for\narm64.\n\nFirst revision (here) is to use the same section conventions as the Xcode\ntoochains for BSS and COMMON.\n\nWe also drop the constraint about putting small items into data/static data\nthat was a work-around for Java issues (irrelevant for several editions).\n\ngcc/ChangeLog:\n\n\t* config/darwin.c (darwin_emit_local_bss): Amend section names to\n\tmatch system tools. (darwin_output_aligned_bss): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/darwin-sections.c: Adjust test for renamed BSS and common\n\tsections.  Cater for 64 and 128 bit long doubles.", "tree": {"sha": "a026cc273bec13a3ce87557458d048c976d325bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a026cc273bec13a3ce87557458d048c976d325bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dcf59c5c0100d0649d64ec948dbe24018d48b6a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcf59c5c0100d0649d64ec948dbe24018d48b6a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcf59c5c0100d0649d64ec948dbe24018d48b6a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcf59c5c0100d0649d64ec948dbe24018d48b6a5/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16664e6e4fb4281be6477c13989740d44c963c77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16664e6e4fb4281be6477c13989740d44c963c77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16664e6e4fb4281be6477c13989740d44c963c77"}], "stats": {"total": 84, "additions": 33, "deletions": 51}, "files": [{"sha": "23116484724dbbf3bfa79fc82cc1fa9096e7a973", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcf59c5c0100d0649d64ec948dbe24018d48b6a5/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcf59c5c0100d0649d64ec948dbe24018d48b6a5/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=dcf59c5c0100d0649d64ec948dbe24018d48b6a5", "patch": "@@ -2384,11 +2384,7 @@ darwin_emit_local_bss (FILE *fp, tree decl, const char *name,\n \t\t\tunsigned HOST_WIDE_INT size,\n \t\t\tunsigned int l2align)\n {\n-   /* FIXME: We have a fudge to make this work with Java even when the target does\n-   not use sections anchors -- Java seems to need at least one small item in a\n-   non-zerofill segment.   */\n-   if ((DARWIN_SECTION_ANCHORS && flag_section_anchors && size < BYTES_ZFILL)\n-       || (size && size <= 2))\n+   if (DARWIN_SECTION_ANCHORS && flag_section_anchors && size < BYTES_ZFILL)\n     {\n       /* Put smaller objects in _static_data, where the section anchors system\n \t can get them.\n@@ -2414,16 +2410,13 @@ darwin_emit_local_bss (FILE *fp, tree decl, const char *name,\n     }\n   else\n     {\n-      /* When we are on a non-section anchor target, we can get zero-sized\n-\t items here.  However, all we need to do is to bump them to one byte\n-\t and the section alignment will take care of the rest.  */\n+      /* When we are on a non-section anchor target (or not using section\n+\t anchors, we can get zero-sized items here.  However, all we need to\n+\t do is to bump them to one byte and the section alignment will take\n+\t care of the rest.  */\n       char secnam[64];\n-      unsigned int flags ;\n-      snprintf (secnam, 64, \"__DATA,__%sbss%u\", ((size)?\"\":\"zo_\"),\n-\t\t\t\t\t\t(unsigned) l2align);\n-      /* We can't anchor (yet, if ever) in zerofill sections, because we can't\n-\t switch to them and emit a label.  */\n-      flags = SECTION_BSS|SECTION_WRITE|SECTION_NO_ANCHOR;\n+      snprintf (secnam, 64, \"__DATA,__bss\");\n+      unsigned int flags = SECTION_BSS|SECTION_WRITE|SECTION_NO_ANCHOR;\n       in_section = get_section (secnam, flags, NULL);\n       fprintf (fp, \"\\t.zerofill %s,\", secnam);\n       assemble_name (fp, name);\n@@ -2434,7 +2427,7 @@ darwin_emit_local_bss (FILE *fp, tree decl, const char *name,\n \tfprintf (fp, \",\" HOST_WIDE_INT_PRINT_UNSIGNED\",%u\\n\",\n \t\t size, (unsigned) l2align);\n       else\n-\tfprintf (fp, \",\" HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", size);\n+\tfprintf (fp, \",\" HOST_WIDE_INT_PRINT_UNSIGNED\",0\\n\", size);\n     }\n \n   (*targetm.encode_section_info) (decl, DECL_RTL (decl), false);\n@@ -2559,9 +2552,8 @@ fprintf (fp, \"# albss: %s (%lld,%d) ro %d cst %d stat %d com %d\"\n       return;\n     }\n \n-  /* So we have a public symbol (small item fudge for Java, see above).  */\n-  if ((DARWIN_SECTION_ANCHORS && flag_section_anchors && size < BYTES_ZFILL)\n-       || (size && size <= 2))\n+  /* So we have a public symbol.  */\n+  if (DARWIN_SECTION_ANCHORS && flag_section_anchors && size < BYTES_ZFILL)\n     {\n       /* Put smaller objects in data, where the section anchors system can get\n \t them.  However, if they are zero-sized punt them to yet a different\n@@ -2586,16 +2578,10 @@ fprintf (fp, \"# albss: %s (%lld,%d) ro %d cst %d stat %d com %d\"\n     }\n   else\n     {\n+      /* Section anchors not in use.  */\n+      unsigned int flags = SECTION_BSS|SECTION_WRITE|SECTION_NO_ANCHOR;\n       char secnam[64];\n-      unsigned int flags ;\n-      /* When we are on a non-section anchor target, we can get zero-sized\n-\t items here.  However, all we need to do is to bump them to one byte\n-\t and the section alignment will take care of the rest.  */\n-      snprintf (secnam, 64, \"__DATA,__%spu_bss%u\", ((size)?\"\":\"zo_\"), l2align);\n-\n-      /* We can't anchor in zerofill sections, because we can't switch\n-\t to them and emit a label.  */\n-      flags = SECTION_BSS|SECTION_WRITE|SECTION_NO_ANCHOR;\n+      snprintf (secnam, 64, \"__DATA,__common\");\n       in_section = get_section (secnam, flags, NULL);\n       fprintf (fp, \"\\t.zerofill %s,\", secnam);\n       assemble_name (fp, name);\n@@ -2605,7 +2591,7 @@ fprintf (fp, \"# albss: %s (%lld,%d) ro %d cst %d stat %d com %d\"\n       if (l2align)\n \tfprintf (fp, \",\" HOST_WIDE_INT_PRINT_UNSIGNED\",%u\\n\", size, l2align);\n       else\n-\tfprintf (fp, \",\" HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", size);\n+\tfprintf (fp, \",\" HOST_WIDE_INT_PRINT_UNSIGNED\",0\\n\", size);\n     }\n   (* targetm.encode_section_info) (decl, DECL_RTL (decl), false);\n }"}, {"sha": "dbe37027f89f7d648cdc0626d0e20f41d55a663b", "filename": "gcc/testsuite/gcc.dg/darwin-sections.c", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcf59c5c0100d0649d64ec948dbe24018d48b6a5/gcc%2Ftestsuite%2Fgcc.dg%2Fdarwin-sections.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcf59c5c0100d0649d64ec948dbe24018d48b6a5/gcc%2Ftestsuite%2Fgcc.dg%2Fdarwin-sections.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdarwin-sections.c?ref=dcf59c5c0100d0649d64ec948dbe24018d48b6a5", "patch": "@@ -13,45 +13,41 @@ e_s ea;\n /* { dg-final { scan-assembler \".comm\\[\\t \\]_ub,1\" } } */\n /* { dg-final { scan-assembler \".comm\\[\\t \\]_ea,1\" } } */\n \n-/* These should go into .data */\n+/* These should go into __DATA,__common */\n char a = 0;\n short b = 0;\n-/* { dg-final { scan-assembler \".globl _a.*.data.*.space\\[\\t \\]1\" } } */\n-/* { dg-final { scan-assembler \".globl _b.*.data.*.space\\[\\t \\]2\" } } */\n-\n-/* These should go into __pu_bssN */\n long long d = 0;\n float e = 0;\n double f = 0;\n long double g = 0.L;\n long long al_256 __attribute__((aligned (256))) = 0;\n-/* { dg-final { scan-assembler \".zerofill __DATA,__pu_bss3,_d,8,3\" } } */\n-/* { dg-final { scan-assembler \".zerofill __DATA,__pu_bss2,_e,4,2\" } } */\n-/* { dg-final { scan-assembler \".zerofill __DATA,__pu_bss3,_f,8,3\" } } */\n-/* { dg-final { scan-assembler \".zerofill __DATA,__pu_bss4,_g,16,4\" } } */\n-/* { dg-final { scan-assembler \".zerofill __DATA,__pu_bss8,_al_256,8,8\" } } */\n+/* { dg-final { scan-assembler {.zerofill __DATA,__common,_a,1,0} } } */\n+/* { dg-final { scan-assembler {.zerofill __DATA,__common,_b,2,1} } } */\n+/* { dg-final { scan-assembler {.zerofill __DATA,__common,_d,8,3} } } */\n+/* { dg-final { scan-assembler {.zerofill __DATA,__common,_e,4,2} } } */\n+/* { dg-final { scan-assembler {.zerofill __DATA,__common,_f,8,3} } } */\n+/* long double can be 64 or 128 bits depending on the Darwin subtarget.  */\n+/* { dg-final { scan-assembler {.zerofill __DATA,__common,_g,(16,4|8,3)} } } */\n+/* { dg-final { scan-assembler {.zerofill __DATA,__common,_al_256,8,8} } } */\n \n-/* This should go into __zo_bss0 */\n+/* These should go into __DATA,__bss */\n static e_s sea;\n-/* { dg-final { scan-assembler \".zerofill __DATA,__zo_bss0,_sea,1\" } } */\n-\n-/* These should go into .static_data */\n static char sa ;\n static short sb ;\n-/* { dg-final { scan-assembler \".static_data.*_sa:.*.space\\[\\t \\]1\" } } */\n-/* { dg-final { scan-assembler \".static_data.*_sb:.*.space\\[\\t \\]2\" } } */\n-\n-/* These should go into _bssN */\n static long long sd;\n static float se ;\n static double sf ;\n static long double sg;\n static long long sal_256 __attribute__((aligned (2048)));\n-/* { dg-final { scan-assembler \".zerofill __DATA,__bss3,_sd,8,3\" } } */\n-/* { dg-final { scan-assembler \".zerofill __DATA,__bss2,_se,4,2\" } } */\n-/* { dg-final { scan-assembler \".zerofill __DATA,__bss3,_sf,8,3\" } } */\n-/* { dg-final { scan-assembler \".zerofill __DATA,__bss4,_sg,16,4\" } } */\n-/* { dg-final { scan-assembler \".zerofill __DATA,__bss11,_sal_256,8,11\" } } */\n+/* { dg-final { scan-assembler {.zerofill __DATA,__bss,_sea,1,0} } } */\n+/* { dg-final { scan-assembler {.zerofill __DATA,__bss,_sa,1,0} } } */\n+/* { dg-final { scan-assembler {.zerofill __DATA,__bss,_sb,2,1} } } */\n+/* { dg-final { scan-assembler {.zerofill __DATA,__bss,_sd,8,3} } } */\n+/* { dg-final { scan-assembler {.zerofill __DATA,__bss,_se,4,2} } } */\n+/* { dg-final { scan-assembler {.zerofill __DATA,__bss,_sf,8,3} } } */\n+/* long double can be 64 or 128 bits depending on the Darwin subtarget.  */\n+/* { dg-final { scan-assembler {.zerofill __DATA,__bss,_sg,(16,4|8,3)} } } */\n+/* { dg-final { scan-assembler {.zerofill __DATA,__bss,_sal_256,8,11} } } */\n \n long long foo (int x)\n {"}]}