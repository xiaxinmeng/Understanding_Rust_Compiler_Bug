{"sha": "b67d701b4ff899f1e677f00fa9b579fee7be5557", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY3ZDcwMWI0ZmY4OTlmMWU2NzdmMDBmYTliNTc5ZmVlN2JlNTU1Nw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-10-12T12:43:51Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-10-12T12:43:51Z"}, "message": "Merge from Cygnus internal source tree.\n\nFrom-SVN: r23023", "tree": {"sha": "bc61e5725467d62f7ffa5244b21f98a46c6fb375", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc61e5725467d62f7ffa5244b21f98a46c6fb375"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b67d701b4ff899f1e677f00fa9b579fee7be5557", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b67d701b4ff899f1e677f00fa9b579fee7be5557", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b67d701b4ff899f1e677f00fa9b579fee7be5557", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b67d701b4ff899f1e677f00fa9b579fee7be5557/comments", "author": null, "committer": null, "parents": [{"sha": "7e673abaccd2b7b6211313774a0812ed0a151c30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e673abaccd2b7b6211313774a0812ed0a151c30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e673abaccd2b7b6211313774a0812ed0a151c30"}], "stats": {"total": 1664, "additions": 1284, "deletions": 380}, "files": [{"sha": "9dd9e587ed2d6e01099c042d70c087aa4c46ef06", "filename": "gcc/java/parse.y", "status": "modified", "additions": 1284, "deletions": 380, "changes": 1664, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b67d701b4ff899f1e677f00fa9b579fee7be5557/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b67d701b4ff899f1e677f00fa9b579fee7be5557/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=b67d701b4ff899f1e677f00fa9b579fee7be5557", "patch": "@@ -98,7 +98,16 @@ static enum tree_code binop_lookup[19] =\n static tree wfl_operator = NULL_TREE;\n \n /* The \"$L\" identifier we use to create labels.  */\n-static tree label_id;\n+static tree label_id = NULL_TREE;\n+\n+/* The \"StringBuffer\" identifier used for the String `+' operator. */\n+static tree wfl_string_buffer = NULL_TREE; \n+\n+/* The \"append\" identifier used for String `+' operator.  */\n+static tree wfl_append = NULL_TREE;\n+\n+/* The \"toString\" identifier used for String `+' operator. */\n+static tree wfl_to_string = NULL_TREE;\n %}\n \n %union {\n@@ -219,6 +228,12 @@ static tree label_id;\n \t\t\tconditional_expression assignment_expression\n \t\t\tleft_hand_side assignment for_header for_begin\n \t\t\tconstant_expression do_statement_begin empty_statement\n+\t\t\tswitch_statement synchronized_statement throw_statement\n+\t\t\ttry_statement switch_expression switch_block\n+\t\t\tswitch_block_statement_groups switch_labels\n+\t\t\tswitch_block_statement_group switch_label\n+\t\t\tgroup_of_labels catches catch_clause \n+\t\t\tcatch_clause_parameter finally\n %type    <node>         return_statement break_statement continue_statement\n \n %type    <operator>     ASSIGN_TK      MULT_ASSIGN_TK  DIV_ASSIGN_TK  \n@@ -231,7 +246,7 @@ static tree label_id;\n %token   <operator>     DECR_TK MINUS_TK MULT_TK DIV_TK XOR_TK REM_TK NEQ_TK\n %token   <operator>     NEG_TK REL_QM_TK REL_CL_TK NOT_TK LT_TK\n %token   <operator>     OP_TK OSB_TK DOT_TK\n-%type    <operator>\tTHIS_TK SUPER_TK RETURN_TK BREAK_TK CONTINUE_TK\n+%type    <operator>\tTHIS_TK SUPER_TK RETURN_TK BREAK_TK CONTINUE_TK CASE_TK%type\t<operator>     DEFAULT_TK TRY_TK CATCH_TK\n \n %type\t <node>\t\tmethod_body \n \t\n@@ -539,13 +554,16 @@ class_body_declaration:\n |\tstatic_initializer\n |\tconstructor_declaration\n |\tblock\t\t\t/* Added, JDK1.1, instance initializer */\n+\t\t{ $$ = parse_jdk1_1_error (\"instance initializer\"); }\n ;\n \n class_member_declaration:\n \tfield_declaration\n |\tmethod_declaration\n |\tclass_declaration\t/* Added, JDK1.1 inner classes */\n+\t\t{ $$ = parse_jdk1_1_error (\"inner classe declaration\"); }\n |\tinterface_declaration\t/* Added, JDK1.1 inner classes */\n+\t\t{ $$ = parse_jdk1_1_error (\"inner interface declaration\"); }\n ;\n \n /* 19.8.2 Productions from 8.3: Field Declarations  */\n@@ -701,10 +719,7 @@ formal_parameter:\n \t\t  $$ = build_tree_list ($2, $1);\n \t\t}\n |\tmodifiers type variable_declarator_id /* Added, JDK1.1 final locals */\n-\t\t{\n-\t\t  SOURCE_FRONTEND_DEBUG ((\"Modifiers: %d\", $1));\n-\t\t  $$ = NULL;\t/* FIXME */\n-\t\t}\n+\t\t{ $$ = parse_jdk1_1_error (\"final local\"); }\n |\ttype error\n \t\t{yyerror (\"Missing identifier\"); RECOVER;}\n |\tmodifiers type error\n@@ -802,20 +817,23 @@ explicit_constructor_invocation:\n         /* Added, JDK1.1 inner classes. Modified because the rule\n \t   'primary' couldn't work.  */\n |\tname DOT_TK SUPER_TK OP_TK argument_list CP_TK SC_TK\n+\t\t{$$ = parse_jdk1_1_error (\"explicit constructor invocation\"); }\n |\tname DOT_TK SUPER_TK OP_TK CP_TK SC_TK\n-\t\t{RULE (\"explicit_constructor_invocation (X.super)\");}\n+\t\t{$$ = parse_jdk1_1_error (\"explicit constructor invocation\"); }\n ;\n \n this_or_super:\t\t\t/* Added, simplifies error diagnostics */\n \tTHIS_TK\n \t\t{\n-\t\t  tree wfl = build_wfl_node (this_identifier_node, input_filename, 0, 0);\n+\t\t  tree wfl = build_wfl_node (this_identifier_node, \n+\t\t\t\t\t     input_filename, 0, 0);\n \t\t  EXPR_WFL_LINECOL (wfl) = $1.location;\n \t\t  $$ = wfl;\n \t\t}\n |\tSUPER_TK\n \t\t{\n-\t\t  tree wfl = build_wfl_node (super_identifier_node, input_filename, 0, 0);\n+\t\t  tree wfl = build_wfl_node (super_identifier_node,\n+\t\t\t\t\t     input_filename, 0, 0);\n \t\t  EXPR_WFL_LINECOL (wfl) = $1.location;\n \t\t  $$ = wfl;\n \t\t}\n@@ -887,7 +905,9 @@ interface_member_declaration:\n \tconstant_declaration\n |\tabstract_method_declaration\n |\tclass_declaration\t/* Added, JDK1.1 inner classes */\n+\t\t{ $$ = parse_jdk1_1_error (\"inner class declaration\"); }\n |\tinterface_declaration\t/* Added, JDK1.1 inner classes */\n+\t\t{ $$ = parse_jdk1_1_error (\"inner interface declaration\"); }\n ;\n \n constant_declaration:\n@@ -955,6 +975,7 @@ block_statement:\n |\tstatement\n \t\t{ $$ = java_method_add_stmt (current_function_decl, $1); }\n |\tclass_declaration\t/* Added, JDK1.1 inner classes */\n+\t\t{ $$ = parse_jdk1_1_error (\"inner class declaration\"); }\n ;\n \n local_variable_declaration_statement:\n@@ -971,13 +992,9 @@ local_variable_declaration:\n statement:\n \tstatement_without_trailing_substatement\n |\tlabeled_statement\n-\t\t{ RULE (\"STATEMENT (labeled)\"); }\n |\tif_then_statement\n-\t\t{ RULE (\"STATEMENT (if-then)\"); }\n |\tif_then_else_statement\n-\t\t{ RULE (\"STATEMENT (if-then-else)\"); }\n |\twhile_statement\n-\t\t{ RULE (\"STATEMENT (while)\"); }\n |\tfor_statement\n \t\t{ \n \t\t  /* If the for loop is unlabeled, we must return the\n@@ -991,37 +1008,23 @@ statement:\n statement_nsi:\n \tstatement_without_trailing_substatement\n |\tlabeled_statement_nsi\n-\t\t{ RULE (\"NSI STATEMENT (labeled)\"); }\n |\tif_then_else_statement_nsi\n-\t\t{ RULE (\"NSI STATEMENT (if-then-else)\"); }\n |\twhile_statement_nsi\n-\t\t{ RULE (\"NSI STATEMENT (while)\"); }\n |\tfor_statement_nsi\n-\t\t{ RULE (\"NSI STATEMENT (for)\"); }\n ;\n \n statement_without_trailing_substatement:\n \tblock\n-\t\t{ RULE (\"STATEMENT (block)\"); }\n |\tempty_statement\n-\t\t{ RULE (\"STATEMENT (empty)\"); }\n |\texpression_statement\n-\t\t{ RULE (\"STATEMENT (expression)\"); }\n |\tswitch_statement\n-\t\t{ RULE (\"STATEMENT (switch)\"); }\n |\tdo_statement\n-\t\t{ RULE (\"STATEMENT (do)\"); }\n |\tbreak_statement\n-\t\t{ RULE (\"STATEMENT (break)\"); }\n |\tcontinue_statement\n-\t\t{ RULE (\"STATEMENT (continue)\"); }\n |\treturn_statement\n |\tsynchronized_statement\n-\t\t{ RULE (\"STATEMENT (synchronized)\"); }\n |\tthrow_statement\n-\t\t{ RULE (\"STATEMENT (throw)\"); }\n |\ttry_statement\n-\t\t{ RULE (\"STATEMENT (try)\"); }\n ;\n \n empty_statement:\n@@ -1113,26 +1116,11 @@ expression_statement:\n statement_expression: \n \tassignment\n |\tpre_increment_expression\n-\t\t{\n-\t\t  RULE (\"++INCREMENT\");\n-\t\t}\n |\tpre_decrement_expression\n-\t\t{\n-\t\t  RULE (\"--DECREMENT\");\n-\t\t}\n |\tpost_increment_expression\n-\t\t{\n-\t\t  RULE (\"INCREMENT++\");\n-\t\t}\n |\tpost_decrement_expression\n-\t\t{\n-\t\t  RULE (\"DECREMENT--\");\n-\t\t}\n |\tmethod_invocation\n |\tclass_instance_creation_expression\n-\t\t{\n-\t\t  RULE (\"INSTANCE CREATION\");\n-\t\t}\n ;\n \n if_then_statement:\n@@ -1157,7 +1145,19 @@ if_then_else_statement_nsi:\n ;\n \n switch_statement:\n-\tSWITCH_TK OP_TK expression CP_TK switch_block\n+\tswitch_expression switch_block\n+\t\t{ \n+\t\t  TREE_OPERAND ($1, 1) = $2;\n+\t\t  $$ = build_debugable_stmt (EXPR_WFL_LINECOL ($1), $1);\n+\t\t}\n+;\n+\n+switch_expression:\n+\tSWITCH_TK OP_TK expression CP_TK\n+\t\t{ \n+\t\t  $$ = build (SWITCH_EXPR, NULL_TREE, $3, NULL_TREE);\n+\t\t  EXPR_WFL_LINECOL ($$) = $2.location;\n+\t\t}\n |\tSWITCH_TK error\n \t\t{yyerror (\"'(' expected\"); RECOVER;}\n |\tSWITCH_TK OP_TK error\n@@ -1168,29 +1168,63 @@ switch_statement:\n \n switch_block:\n \tOCB_TK CCB_TK\n+\t\t{ $$ = NULL_TREE; }\n |\tOCB_TK switch_labels CCB_TK\n+\t\t{ $$ = build_tree_list ($2, NULL_TREE); }\n |\tOCB_TK switch_block_statement_groups CCB_TK\n+\t\t{ $$ = $2; }\n |\tOCB_TK switch_block_statement_groups switch_labels CCB_TK\n+\t\t{ \n+\t\t  /* Switch labels alone are empty switch statements */\n+\t\t  tree sl = build_tree_list ($3, NULL_TREE);\n+\t\t  TREE_CHAIN (sl) = $2;\n+\t\t  $$ = sl;\n+\t\t}\n ;\n \n switch_block_statement_groups: \n \tswitch_block_statement_group\n |\tswitch_block_statement_groups switch_block_statement_group\n+\t\t{ \n+\t\t  TREE_CHAIN ($2) = $1;\n+\t\t  $$ = $2;\n+\t\t}\n ;\n \n switch_block_statement_group:\n-\tswitch_labels block_statements\n+\tgroup_of_labels block_statements\n+\t\t{ $$ = build_tree_list ($1, exit_block ()); }\n ;\n \n+group_of_labels:\n+\tswitch_labels\n+\t\t{ \n+\t\t  /* All statements attached to this group of cases\n+\t\t     will be stored in a block */\n+\t\t  enter_block ();\n+\t\t  $$ = $1;\n+\t\t}\n \n switch_labels:\n \tswitch_label\n |\tswitch_labels switch_label\n+\t\t{\n+\t\t  TREE_CHAIN ($2) = $1;\n+\t\t  $$ = $2;\n+\t\t}\n ;\n \n switch_label:\n \tCASE_TK constant_expression REL_CL_TK\n+\t\t{ \n+\t\t  $$ = build1 (CASE_EXPR, NULL_TREE, $2);\n+\t\t  EXPR_WFL_LINECOL ($$) = $1.location;\n+\t\t}\n |\tDEFAULT_TK REL_CL_TK\n+\t\t{ \n+\t\t  $$ = build1 (DEFAULT_EXPR, NULL_TREE, NULL_TREE);\n+\t\t  EXPR_WFL_LINECOL ($$) = $1.location;\n+\t\t}\n |\tCASE_TK error\n \t\t{yyerror (\"Missing or invalid constant expression\"); RECOVER;}\n |\tCASE_TK constant_expression error\n@@ -1361,6 +1395,7 @@ return_statement:\n \n throw_statement:\n \tTHROW_TK expression SC_TK\n+\t\t{ $$ = NULL_TREE;\t\t/* FIXME */ }\n |\tTHROW_TK error\n \t\t{yyerror (\"Missing term\"); RECOVER;}\n |\tTHROW_TK expression error\n@@ -1369,6 +1404,7 @@ throw_statement:\n \n synchronized_statement:\n \tsynchronized OP_TK expression CP_TK block\n+\t\t{ $$ = NULL_TREE;\t\t/* FIXME */ }\n |\tsynchronized OP_TK expression CP_TK error\n \t\t{yyerror (\"'{' expected\"); RECOVER;}\n |\tsynchronized error\n@@ -1388,29 +1424,63 @@ synchronized:\t\t\t/* Test lval.sub_token here */\n \n try_statement:\n \tTRY_TK block catches\n+\t\t{ $$ = build_try_statement ($1.location, $2, $3, NULL_TREE); }\n |\tTRY_TK block finally\n+\t\t{ $$ = build_try_statement ($1.location, $2, NULL_TREE, $3); }\n |\tTRY_TK block catches finally\n+\t\t{ $$ = build_try_statement ($1.location, $2, $3, $4); }\n |\tTRY_TK error\n \t\t{yyerror (\"'{' expected\"); DRECOVER (try_statement);}\n ;\n \n catches:\n \tcatch_clause\n |\tcatches catch_clause\n+\t\t{ \n+\t\t  TREE_CHAIN ($2) = $1;\n+\t\t  $$ = $2;\n+\t\t}\n ;\n \n catch_clause:\n-\tCATCH_TK OP_TK formal_parameter CP_TK block\n+\tcatch_clause_parameter block\n+\t\t{ \n+\t\t  java_method_add_stmt (current_function_decl, $2);\n+\t\t  exit_block ();\n+\t\t  $$ = $1;\n+\t\t}\n+\n+catch_clause_parameter:\n+\tCATCH_TK OP_TK formal_parameter CP_TK\n+\t\t{ \n+\t\t  /* We add a block to define a scope for\n+\t\t     formal_parameter (CCBP). The formal parameter is\n+\t\t     declared initialized by the appropriate function\n+\t\t     call */\n+\t\t  tree ccpb = enter_block ();\n+\t\t  tree init = build_assignment (ASSIGN_TK, $2.location, \n+\t\t\t\t\t\tTREE_PURPOSE ($3), \n+\t\t\t\t\t\tsoft_exceptioninfo_call_node);\n+\t\t  declare_local_variables (0, TREE_VALUE ($3),\n+\t\t\t\t\t   build_tree_list (TREE_PURPOSE ($3),\n+\t\t\t\t\t\t\t    init));\n+\t\t  $$ = build1 (CATCH_EXPR, NULL_TREE, ccpb);\n+\t\t  EXPR_WFL_LINECOL ($$) = $1.location;\n+\t\t}\n |\tCATCH_TK error\n \t\t{yyerror (\"'(' expected\"); RECOVER;}\n-|\tCATCH_TK OP_TK error CP_TK /* That's for () */\n-\t\t{yyerror (\"Missing term\"); DRECOVER (1);}\n |\tCATCH_TK OP_TK error \n-\t\t{yyerror (\"Missing term\"); DRECOVER (2);}\n+\t\t{yyerror (\"Missing term or ')' expected\"); DRECOVER (2);}\n+|\tCATCH_TK OP_TK error CP_TK /* That's for () */\n+\t\t{yyerror (\"')' expected\"); DRECOVER (1);}\n ;\n \n finally:\n \tFINALLY_TK block\n+\t\t{ \n+\t\t  $$ = build (FINALLY_EXPR, NULL_TREE,\n+\t\t\t      create_label_decl (generate_name ()), $2);\n+\t\t}\n |\tFINALLY_TK error\n \t\t{yyerror (\"'{' expected\"); RECOVER; }\n ;\n@@ -1435,12 +1505,16 @@ primary_no_new_array:\n \t   'type' into its components. Missing is something for array,\n \t   which will complete the reference_type part. FIXME */\n |\tname DOT_TK CLASS_TK\t       /* Added, JDK1.1 class literals */\n+\t\t{ $$ = parse_jdk1_1_error (\"class literals\"); }\n |\tprimitive_type DOT_TK CLASS_TK /* Added, JDK1.1 class literals */\n+\t\t{ $$ = parse_jdk1_1_error (\"class literals\"); }\n |\tVOID_TK DOT_TK CLASS_TK\t       /* Added, JDK1.1 class literals */\n+\t\t{ $$ = parse_jdk1_1_error (\"class literals\"); }\n         /* Added, JDK1.1 inner classes. Documentation is wrong\n            refering to a 'ClassName' (class_name) rule that doesn't\n            exist. Used name instead.  */\n |\tname DOT_TK THIS_TK\n+\t\t{ $$ = parse_jdk1_1_error (\"class literals\"); }\n |\tOP_TK expression error \n \t\t{yyerror (\"')' expected\"); RECOVER;}\n |\tname DOT_TK error\n@@ -1453,22 +1527,16 @@ primary_no_new_array:\n \n class_instance_creation_expression:\n \tNEW_TK class_type OP_TK argument_list CP_TK\n-\t\t{\n-\t\t  $$ = build_method_invocation ($2, $4);\n-\t\t  TREE_SET_CODE ($$, JAVA_NEW_CLASS_EXPR);\n-\t\t}\n+\t\t{ $$ = build_new_invocation ($2, $4); }\n |\tNEW_TK class_type OP_TK CP_TK\n-\t\t{\n-\t\t  $$ = build_method_invocation ($2, NULL_TREE);\n-\t\t  TREE_SET_CODE ($$, JAVA_NEW_CLASS_EXPR);\n-\t\t}\n+\t\t{ $$ = build_new_invocation ($2, NULL_TREE); }\n         /* Added, JDK1.1 inner classes but modified to use\n            'class_type' instead of 'TypeName' (type_name) mentionned\n            in the documentation but doesn't exist. */\n |\tNEW_TK class_type OP_TK argument_list CP_TK class_body\n-{$$ = $2;}\n+\t\t{ $$ = parse_jdk1_1_error (\"inner class instance creation\"); }\n |\tNEW_TK class_type OP_TK CP_TK class_body         \n-{$$ = $2;}\n+\t\t{ $$ = parse_jdk1_1_error (\"inner class instance creation\"); }\n         /* Added, JDK1.1 inner classes, modified to use name or\n \t   primary instead of primary solely which couldn't work in\n \t   all situations.  */\n@@ -1522,9 +1590,9 @@ array_creation_expression:\n         /* Added, JDK1.1 anonymous array. Initial documentation rule\n            modified */\n |\tNEW_TK class_or_interface_type dims array_initializer\n-{$$ = $2;}\n+\t\t{ $$ = parse_jdk1_1_error (\"anonymous array\"); }\n |\tNEW_TK primitive_type dims array_initializer\n-{$$ = $2;}\n+\t\t{ $$ = parse_jdk1_1_error (\"anonymous array\"); }\n |\tNEW_TK error CSB_TK\n \t\t{yyerror (\"'[' expected\"); DRECOVER (\"]\");}\n |\tNEW_TK error OSB_TK\n@@ -1569,7 +1637,8 @@ field_access:\n |\tSUPER_TK DOT_TK identifier\n \t\t{\n \t\t  tree super_wfl = \n-\t\t    build_wfl_node (super_identifier_node, input_filename, 0, 0);\n+\t\t    build_wfl_node (super_identifier_node, \n+\t\t\t\t    input_filename, 0, 0);\n \t\t  EXPR_WFL_LINECOL (super_wfl) = $1.location;\n \t\t  $$ = make_qualified_name (super_wfl, $3, $2.location);\n \t\t}\n@@ -1595,15 +1664,17 @@ method_invocation:\n |\tSUPER_TK DOT_TK identifier OP_TK CP_TK\n \t\t{\n \t\t  tree invok;\n-\t\t  tree wfl = build_wfl_node (super_identifier_node, input_filename, 0, 0);\n+\t\t  tree wfl = build_wfl_node (super_identifier_node, \n+\t\t\t\t\t     input_filename, 0, 0);\n \t\t  EXPR_WFL_LINECOL (wfl) = $1.location;\n \t\t  invok = build_method_invocation ($3, NULL_TREE);\n \t\t  $$ = make_qualified_primary (wfl, invok, $2.location);\n \t\t}\n |\tSUPER_TK DOT_TK identifier OP_TK argument_list CP_TK\n \t\t{\n \t\t  tree invok;\n-\t\t  tree wfl = build_wfl_node (super_identifier_node, input_filename, 0, 0);\n+\t\t  tree wfl = build_wfl_node (super_identifier_node, \n+\t\t\t\t\t     input_filename, 0, 0);\n \t\t  EXPR_WFL_LINECOL (wfl) = $1.location;\n \t\t  invok = build_method_invocation ($3, $5);\n \t\t  $$ = make_qualified_primary (wfl, invok, $2.location);\n@@ -2043,6 +2114,17 @@ java_pop_parser_context ()\n   free (toFree);\n }\n \n+/* Reporting JDK1.1 features not implemented */\n+\n+static tree\n+parse_jdk1_1_error (msg)\n+    char *msg;\n+{\n+  sorry (\": `%s' JDK1.1(TM) feature\", msg);\n+  java_error_count++;\n+  return size_zero_node;\n+}\n+\n static int do_warning = 0;\n \n void\n@@ -2212,8 +2294,11 @@ java_accstring_lookup (flags)\n #undef COPY_RETURN\n }\n \n+/* Issuing error messages upon redefinition of classes, interfaces or\n+   variables. */\n+\n static void\n-redefinition_error (context, id, decl, cl)\n+classitf_redefinition_error (context, id, decl, cl)\n      char *context;\n      tree id, decl, cl;\n {\n@@ -2223,6 +2308,26 @@ redefinition_error (context, id, decl, cl)\n   /* Here we should point out where its redefined. It's a unicode. FIXME */\n }\n \n+static void\n+variable_redefinition_error (context, name, type, line)\n+     tree context, name, type;\n+     int line;\n+{\n+  char *type_name;\n+\n+  /* Figure a proper name for type. We might haven't resolved it */\n+  if (TREE_CODE (type) == TREE_LIST)\n+    type_name = IDENTIFIER_POINTER (TYPE_NAME (TREE_PURPOSE (type)));\n+  else\n+    type_name = (char *)lang_printable_name (type);\n+\n+  parse_error_context (context,\n+\t\t       \"Variable `%s' is already defined in this method and \"\n+\t\t       \"was declared `%s %s' at line %d\", \n+\t\t       IDENTIFIER_POINTER (name),\n+\t\t       type_name, IDENTIFIER_POINTER (name), line);\n+}\n+\n /* Build something that the type identifier resolver will identify as\n    being an array to an unresolved type. TYPE_WFL is a WFL on a\n    identifier. */\n@@ -2311,8 +2416,8 @@ check_class_interface_creation (is_interface, flags, raw_name, qualified_name, d\n     }\n   if (decl && CLASS_COMPLETE_P (decl))\n     {\n-      redefinition_error ((is_interface ? \"Interface\" : \"Class\"), \n-\t\t\t  qualified_name, decl, cl);\n+      classitf_redefinition_error ((is_interface ? \"Interface\" : \"Class\"), \n+\t\t\t\t   qualified_name, decl, cl);\n       return 1;\n     }\n \n@@ -2617,6 +2722,8 @@ register_fields (flags, type, variable_list)\n \t  must_chain = 1;\n \t}\n     }\n+  if (!must_chain && TREE_CODE (type) == RECORD_TYPE)\n+    type = promote_type (type);\n \n   for (current = variable_list; current; current = TREE_CHAIN (current))\n     {\n@@ -3235,6 +3342,7 @@ java_complete_class ()\n   tree cclass;\n   jdeplist *cclassd;\n   int error_found;\n+  tree type;\n \n   push_obstacks (&permanent_obstack, &permanent_obstack);\n \n@@ -3276,9 +3384,7 @@ java_complete_class ()\n \t\ttree field_decl = JDEP_DECL (dep);\n \t\ttree field_type = TREE_TYPE (decl);\n \t\tpush_obstacks (&permanent_obstack, &permanent_obstack);\n-#if ! JAVA_PROMOTE_TO_INT\n \t\tif (TREE_CODE (field_type) == RECORD_TYPE)\n-#endif\n \t\t  field_type = promote_type (field_type);\n \t\tpop_obstacks ();\n \t\tTREE_TYPE (field_decl) = field_type;\n@@ -3295,7 +3401,9 @@ java_complete_class ()\n \t\t{\n \t\t  if (decl)\n \t\t    {\n-\t\t      tree type = promote_type (TREE_TYPE(decl));\n+\t\t      type = TREE_TYPE(decl);\n+\t\t      if (TREE_CODE (type) == RECORD_TYPE)\n+\t\t\ttype = promote_type (type);\n \t\t      JDEP_APPLY_PATCH (dep, type);\n \t\t      SOURCE_FRONTEND_DEBUG \n \t\t\t(((JDEP_KIND (dep) == JDEP_METHOD_RETURN ?\n@@ -3333,14 +3441,12 @@ java_complete_class ()\n \t      parser_add_interface (JDEP_DECL (dep), decl, JDEP_WFL (dep));\n \t      break;\n \n+\t    case JDEP_PARM:\n \t    case JDEP_VARIABLE:\n-\t      JDEP_APPLY_PATCH (dep, promote_type (TREE_TYPE (decl)));\n-\t      SOURCE_FRONTEND_DEBUG \n-\t\t((\"Completing variable `%s' with type `%s'\",\n-\t\t  (TREE_CODE (JDEP_DECL_WFL (dep)) == EXPR_WITH_FILE_LOCATION ?\n-\t\t   IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_DECL_WFL (dep))) :\n-\t\t   IDENTIFIER_POINTER (DECL_NAME (JDEP_DECL_WFL (dep)))),\n-\t\t  IDENTIFIER_POINTER (DECL_NAME (decl))));\n+\t      type = TREE_TYPE(decl);\n+\t      if (TREE_CODE (type) == RECORD_TYPE)\n+\t\ttype = promote_type (type);\n+\t      JDEP_APPLY_PATCH (dep, type);\n \t      break;\n \n \t    case JDEP_TYPE:\n@@ -3350,14 +3456,6 @@ java_complete_class ()\n \t\t  tree_code_name [TREE_CODE (JDEP_DECL (dep))]));\n \t      break;\n \n-\t    case JDEP_PARM:\n-\t      JDEP_APPLY_PATCH (dep, promote_type (TREE_TYPE (decl)));\n-\t      SOURCE_FRONTEND_DEBUG \n-\t\t((\"Completing parameter `%s' with type `%s'\",\n-\t\t  IDENTIFIER_POINTER (JDEP_MISC (dep)),\n-\t\t  IDENTIFIER_POINTER (DECL_NAME (decl))));\n-\t      break;\n-\n \t    default:\n \t      fatal (\"incomplete switch - java_complete_class\");\n \t    }\n@@ -3562,7 +3660,8 @@ complete_class_report_errors (dep)\n       parse_error_context\n \t(JDEP_WFL (dep), \"Type `%s' not found in the declaration of the \"\n \t \"local variable `%s'\", \n-\t purify_type_name (IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep)))),\n+\t purify_type_name (IDENTIFIER_POINTER \n+\t\t\t   (EXPR_WFL_NODE (JDEP_WFL (dep)))),\n \t IDENTIFIER_POINTER (DECL_NAME (JDEP_DECL (dep))));\n       break;\n     }\n@@ -4268,6 +4367,8 @@ declare_local_variables (modifier, type, vlist)\n \t  must_chain = 1;\n \t}\n     }\n+  if (!must_chain && TREE_CODE (type) == RECORD_TYPE)\n+    type = promote_type (type);\n   \n   for (current = vlist; current; current = TREE_CHAIN (current))\n     {\n@@ -4281,15 +4382,10 @@ declare_local_variables (modifier, type, vlist)\n \tinit = NULL_TREE;\n \n       if (other)\n-\tparse_error_context \n-\t  (wfl, \"Variable `%s' is already defined in this method and was \"\n-\t   \"declared `%s %s' in line %d\", \n-\t   IDENTIFIER_POINTER (name), lang_printable_name (TREE_TYPE (other)),\n-\t   IDENTIFIER_POINTER (name), DECL_SOURCE_LINE (other));\n+\tvariable_redefinition_error (wfl, name, TREE_TYPE (other),\n+\t\t\t\t     DECL_SOURCE_LINE (other));\n       else\n \t{\n-\t  if (!must_chain && TREE_CODE (type) == RECORD_TYPE)\n-\t    type = promote_type (type);\n \t  /* Never layout this decl. This will be done when its scope\n              will be entered */\n \t  decl = build_decl_no_layout (VAR_DECL, name, type);\n@@ -4382,7 +4478,13 @@ expand_start_java_method (fndecl)\n   while (tem)\n     {\n       tree next = TREE_CHAIN (tem);\n-      DECL_ARG_TYPE (tem) = TREE_TYPE (tem);\n+      tree type = TREE_TYPE (tem);\n+#ifdef PROMOTE_PROTOTYPES\n+      if (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)\n+\t  && INTEGRAL_TYPE_P (type))\n+\ttype = integer_type_node;\n+#endif\n+      DECL_ARG_TYPE (tem) = type;\n       layout_decl (tem, 0);\n       pushdecl (tem);\n       INITIALIZED_P (tem) = 1;\t/* Parms are initialized */\n@@ -4406,6 +4508,9 @@ source_end_java_method ()\n   java_parser_context_save_global ();\n   lineno = ctxp->last_ccb_indent1;\n \n+  /* Set EH language codes */\n+  java_set_exception_lang_code ();\n+\n   /* Generate function's code */\n   if (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (fndecl))\n       && ! flag_emit_class_files)\n@@ -4420,6 +4525,8 @@ source_end_java_method ()\n   if (! flag_emit_class_files)\n     {\n       lineno = DECL_SOURCE_LINE_LAST (fndecl);\n+      /* Emit catch-finally clauses */\n+      emit_handlers ();\n       expand_function_end (input_filename, lineno, 0);\n \n       /* Run the optimizers and output assembler code for this function. */\n@@ -4438,17 +4545,24 @@ tree\n java_method_add_stmt (fndecl, expr)\n      tree fndecl, expr;\n {\n-  tree body = BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (fndecl));\n-  tree node;\n+  return add_stmt_to_block (DECL_FUNCTION_BODY (fndecl), NULL_TREE, expr);\n+}\n \n+static tree\n+add_stmt_to_block (b, type, stmt)\n+     tree b, type, stmt;\n+{\n+  tree body = BLOCK_EXPR_BODY (b), c;\n+  \n   if (java_error_count)\n     return body;\n-  if ((node = add_stmt_to_compound (body, NULL_TREE, expr)) == body)\n+    \n+  if ((c = add_stmt_to_compound (body, type, stmt)) == body)\n     return body;\n \n-  BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (fndecl)) = node;\n-  TREE_SIDE_EFFECTS (node) = 1;\n-  return node;\n+  BLOCK_EXPR_BODY (b) = c;\n+  TREE_SIDE_EFFECTS (c) = 1;\n+  return c;\n }\n \n /* Add STMT to EXISTING if possible, otherwise create a new\n@@ -4637,7 +4751,7 @@ make_qualified_primary (primary, right, location)\n   /* We want to process THIS . xxx symbolicaly, to keep it consistent\n      with the way we're processing SUPER. A THIS from a primary as a\n      different form than a SUPER. Turn THIS into something symbolic */\n-  if (TREE_CODE (primary) == JAVA_THIS_EXPR)\n+  if (TREE_CODE (primary) == THIS_EXPR)\n     {\n       wfl = build_wfl_node (this_identifier_node, input_filename, 0, 0);\n       EXPR_WFL_LINECOL (wfl) = EXPR_WFL_LINECOL (primary);\n@@ -4880,7 +4994,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n       switch (TREE_CODE (qual_wfl))\n \t{\n \tcase CALL_EXPR:\n-\tcase JAVA_NEW_CLASS_EXPR:\n+\tcase NEW_CLASS_EXPR:\n \t  /* If the access to the function call is a non static field,\n \t     build the code to access it. */\n \t  if (DECL_P (decl) && !FIELD_STATIC (decl))\n@@ -5027,7 +5141,10 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t     come. Don't do that when processing something after SUPER\n \t     (we need more thing to be put in place below */\n \t  if (!from_super && QUAL_RESOLUTION (q))\n-\t    decl = QUAL_RESOLUTION (q);\n+\t    {\n+\t      decl = QUAL_RESOLUTION (q);\n+\t      *type_found = type;\n+\t    }\n \n \t  /* We have to search for a field, knowing the type of its\n              container. The flag FROM_TYPE indicates that we resolved\n@@ -5108,7 +5225,6 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t\t search from */\n \t      decl = field_decl;\n \t    }\n-\n \t  from_type = 0;\n \t  type = QUAL_DECL_TYPE (decl);\n \t}\n@@ -5403,11 +5519,11 @@ patch_method_invocation_stmt (patch, primary, where, is_static)\n \n       class_type = class_to_search;\n     }\n-  \n+\n   /* Merge point of all resolution schemes. If we have nothing, this\n      is an error, already signaled */\n   if (!list) return error_mark_node;\n-  \n+\n   /* Check accessibility, position the is_static flag, build and\n      return the call */\n   if (not_accessible_p (class_type, list, 0))\n@@ -5540,7 +5656,8 @@ invocation_mode (method, super)\n   return INVOKE_VIRTUAL;\n }\n \n-/* Retrieve a refined list of matching methods. */\n+/* Retrieve a refined list of matching methods. It covers the step\n+   15.11.2 (Compile-Time Step 2) */\n \n static tree\n lookup_method_invoke (lc, cl, class, name, arg_list)\n@@ -5551,22 +5668,22 @@ lookup_method_invoke (lc, cl, class, name, arg_list)\n   tree method = make_node (FUNCTION_TYPE);\n   tree arg_type_list = NULL_TREE;\n   tree signature, list, node, scratch;\n+  char *candidates;\t\t/* Used for error report */\n \n   for (node = arg_list; node; node = TREE_CHAIN (node))\n     {\n-      tree current_arg;\n-      current_arg = \n-\tbuild_tree_list (NULL_TREE,\n-\t\t\t promote_type (TREE_TYPE (TREE_VALUE (node))));\n-      arg_type_list = chainon (current_arg, arg_type_list);\n+      tree current_arg = TREE_TYPE (TREE_VALUE (node));\n+      if (TREE_CODE (current_arg) == RECORD_TYPE)\n+\tcurrent_arg = promote_type (current_arg);\n+      arg_type_list = tree_cons (NULL_TREE, current_arg, arg_type_list);\n     }\n   TYPE_ARG_TYPES (method) = arg_type_list;\n \n   if (!lc)\n     {\n-      signature = build_java_argument_signature (method);\n-      list = match_java_method (class, name, signature);\n-      list = refine_accessible_methods_list (lc, list);\n+      list = find_applicable_accessible_methods_list (class, name, \n+\t\t\t\t\t\t      arg_type_list);\n+      list = find_most_specific_methods_list (list);\n     }\n   else\n     {\n@@ -5575,132 +5692,181 @@ lookup_method_invoke (lc, cl, class, name, arg_list)\n       list = lookup_java_constructor (class, signature);\n     }\n \n-  if (!list)\n-    {\n-      parse_error_context (cl, \"Can't find method `%s(%s)' in class `%s'\",\n-\t\t\t   IDENTIFIER_POINTER (name),\n-\t\t\t   IDENTIFIER_POINTER (signature),\n-\t\t\t   IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (class))));\n-      return NULL_TREE;\n-    }\n-\n-  if (lc)\n+  if (lc && list)\n     return list;\n+  if (list && !TREE_CHAIN (list))\n+    return TREE_VALUE (list);\n \n-  if (TREE_CHAIN (list))\n+  /* Issue an error. List candidates if any. Candidates are listed\n+     only if accessible (non accessible methods may end-up here for\n+     the sake of a better error report). */\n+  candidates = NULL;\n+  if (list)\n     {\n-      tree most_specific_list = NULL_TREE;\n       tree current;\n-      /* 15.11.2.2 Choose the Most Specific Method */\n+      obstack_grow (&temporary_obstack, \". Candidates are:\\n\", 18);\n       for (current = list; current; current = TREE_CHAIN (current))\n \t{\n-\t  tree rest;\n-\t  tree method = TREE_VALUE (list);\n-\t  tree class_from = DECL_CONTEXT (method);\n-\t  for (rest = TREE_CHAIN (current); rest; rest = TREE_CHAIN (rest))\n+\t  tree cm = TREE_VALUE (current);\n+\t  char string [4096];\n+\t  if (!cm || not_accessible_p (class, cm, 0))\n+\t    continue;\n+\t  signature = build_java_argument_signature (TREE_TYPE (cm));\n+\t  sprintf \n+\t    (string, \"  `%s(%s)' in `%s'%s\",\n+\t     IDENTIFIER_POINTER (name), \n+\t     IDENTIFIER_POINTER (signature),\n+\t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (DECL_CONTEXT (cm)))),\n+\t     (TREE_CHAIN (current) ? \"\\n\" : \"\"));\n+\t  obstack_grow (&temporary_obstack, string, strlen (string));\n+\t}\n+      obstack_1grow (&temporary_obstack, '\\0');\n+      candidates = obstack_finish (&temporary_obstack);\n+    }\n+  /* Issue the error message */\n+  signature = build_java_argument_signature (method);\n+  parse_error_context (cl, \"Can't find method `%s(%s)' in class `%s'%s\",\n+\t\t       IDENTIFIER_POINTER (name),\n+\t\t       IDENTIFIER_POINTER (signature),\n+\t\t       IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (class))),\n+\t\t       (candidates ? candidates : \"\"));\n+  return NULL_TREE;\n+}\n+\n+/* 15.11.2.1: Find Methods that are Applicable and Accessible */\n+\n+static tree\n+find_applicable_accessible_methods_list (class, name, arglist)\n+     tree class, name, arglist;\n+{\n+  tree method;\n+  tree list = NULL_TREE, all_list = NULL_TREE;\n+\n+  while (class != NULL_TREE)\n+    {\n+      for (method = TYPE_METHODS (class);\n+\t   method != NULL_TREE;  method = TREE_CHAIN (method))\n+\t{\n+\t  /* Names have to match and we're not looking for constructor */\n+\t  if (DECL_NAME (method) != name\n+\t      || DECL_CONSTRUCTOR_P (method))\n+\t    continue;\n+\n+\t  if (argument_types_convertible (method, arglist))\n \t    {\n-\t      tree other = TREE_VALUE (rest);\n-\n-\t      /* METHOD can be declared more specific with regard to OTHER iif:\n-\t\t\n-\t\t - The class METHOD belongs can be converted to the\n-\t\t   class OTHER belongs by method invocation conversion\n-\t\t   (5.3).  Since we're dealing with classes here, it is\n-\t\t   covered by the identity conversion or the windening\n-\t\t   primitive conversion.\n-\t\t\n-\t\t - The types of the arguments of METHOD can be\n-\t\t   converted to the types of the arguments of OTHER by\n-\t\t   method invocation conversion (5.3). */\n-\n-\t      if (valid_ref_assignconv_cast_p (class_from, \n-\t\t\t\t\t       DECL_CONTEXT (other), 0)\n-\t\t  && 1)\t\t/* Test on args non implemented */\n-\t\tmost_specific_list = tree_cons (NULL_TREE, method, \n-\t\t\t\t\t\tmost_specific_list);\n+\t      /* Retain accessible methods only */\n+\t      if (!not_accessible_p (class, method, 0))\n+\t\tlist = tree_cons (NULL_TREE, method, list);\n+\t      else\n+\t      /* Also retain all selected method here */\n+\t\tall_list = tree_cons (NULL_TREE, method, list);\n \t    }\n \t}\n-      list = most_specific_list;\n+      class = CLASSTYPE_SUPER (class);\n     }\n+  /* Either return the list obtained or all selected (but\n+     inaccessible) methods for better error report. */\n+  return (!list ? all_list : list);\n+}\n \n-  if (!list || TREE_CHAIN (list))\n+/* 15.11.2.2 Choose the Most Specific Method */\n+\n+static tree\n+find_most_specific_methods_list (list)\n+     tree list;\n+{\n+  int max = 0;\n+  tree current, new_list = NULL_TREE;\n+  for (current = list; current; current = TREE_CHAIN (current))\n     {\n-      parse_error_context (cl, \"Can't find method `%s(%s)' in class `%s'\",\n-\t\t\t   IDENTIFIER_POINTER (name),\n-\t\t\t   IDENTIFIER_POINTER (signature),\n-\t\t\t   IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (class))));\n-      return NULL_TREE;\n+      tree method;\n+      DECL_SPECIFIC_COUNT (TREE_VALUE (current)) = 0;\n+\n+      for (method = list; method; method = TREE_CHAIN (method))\n+\t{\n+\t  /* Don't test a method against itself */\n+\t  if (method == current)\n+\t    continue;\n+\n+\t  /* Compare arguments and location where method where declared */\n+\t  if (argument_types_convertible (TREE_VALUE (method), \n+\t\t\t\t\t  TREE_VALUE (current))\n+\t      && valid_method_invocation_conversion_p \n+\t           (DECL_CONTEXT (TREE_VALUE (method)), \n+\t\t    DECL_CONTEXT (TREE_VALUE (current))))\n+\t    {\n+\t      int v = ++DECL_SPECIFIC_COUNT (TREE_VALUE (current));\n+\t      max = (v > max ? v : max);\n+\t    }\n+\t}\n     }\n \n-  /* 15.11.3 Is the Chosen Method Appropriate ? */\n-  else\n-    return TREE_VALUE (list);\n+  /* Review the list and select the maximally specific methods */\n+  for (current = list; current; current = TREE_CHAIN (current))\n+    if (DECL_SPECIFIC_COUNT (TREE_VALUE (current)) == max)\n+      new_list = tree_cons (NULL_TREE, TREE_VALUE (current), new_list);\n+\n+  /* If we can't find one, lower expectations and try to gather multiple\n+     maximally specific methods */\n+  while (!new_list)\n+    {\n+      while (--max > 0)\n+\t{\n+\t  if (DECL_SPECIFIC_COUNT (TREE_VALUE (current)) == max)\n+\t    new_list = tree_cons (NULL_TREE, TREE_VALUE (current), new_list);\n+\t}\n+      return new_list;\n+    }\n+\n+  return new_list;\n }\n \n-/* Refine accessible methods from the raw matching method list, as\n-   specified in 15.11.4.3. Return a (possibly empty) new method\n-   list.  */\n+/* Make sure that the type of each M2_OR_ARGLIST arguments can be\n+   converted by method invocation conversion (5.3) to the type of the\n+   corresponding parameter of M1. Implementation expects M2_OR_ARGLIST\n+   to change less often than M1. */\n \n-static tree\n-refine_accessible_methods_list (lc, list)\n-     int lc;\t\t\t/* Looking for Constructor */\n-     tree list;\n+static int\n+argument_types_convertible (m1, m2_or_arglist)\n+    tree m1, m2_or_arglist;\n {\n-#define ADD_TO_LIST_AND_CONTINUE\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\\\n-    refined_list = tree_cons (NULL_TREE, method, refined_list);\t\\\n-    continue;\t\t\t\t\t\t\t\\\n-  }\n-  tree node, refined_list = NULL_TREE;\n-  tree current_class_name = DECL_NAME (TYPE_NAME (current_class));\n+  static tree m2_arg_value = NULL_TREE;\n+  static tree m2_arg_cache = NULL_TREE;\n \n-  for (node = list; node; node = TREE_CHAIN (node))\n-    {\n-      int access, identical;\n-      tree class_from, method, class_from_name;\n-      \n-      method = TREE_VALUE (node);\n+  register tree m1_arg, m2_arg;\n \n-      /* Constructor not retained here, unless were specifically\n-       looking for them. */\n-      if (lc && DECL_CONSTRUCTOR_P (method))\n-\tADD_TO_LIST_AND_CONTINUE;\n+  m1_arg = TYPE_ARG_TYPES (TREE_TYPE (m1));\n+  if (!METHOD_STATIC (m1))\n+    m1_arg = TREE_CHAIN (m1_arg);\n \n-      access = get_access_flags_from_decl (method);\n-      class_from = DECL_CONTEXT (method);\n-      class_from_name = DECL_NAME (TYPE_NAME (class_from));\n-      \n-      identical = identical_subpath_p (current_class_name, class_from_name);\n-\n-      /* Check accessibility of class_from from the current one: This\n-\t test has been already carried out when qualify_ambiguous_name\n-\t tried to resolve a type found in an other package. It is not\n-\t necessary to retest things here, the error has been already\n-\t reported. */\n-\t\t  \n-      /* Public method are always OK */\n-      if (access & ACC_PUBLIC)\n-\tADD_TO_LIST_AND_CONTINUE;\n-      \n-      /* Protected method access is OK if classes are from the\n-\t same package or part of the same inheritance lineage */\n-      if ((access & ACC_PROTECTED)\n-\t  && (inherits_from_p (current_class, class_from) || identical))\n-\tADD_TO_LIST_AND_CONTINUE;\n+  if (m2_arg_value == m2_or_arglist)\n+    m2_arg = m2_arg_cache;\n+  else\n+    {\n+      /* M2_OR_ARGLIST can be a function DECL or a raw list of\n+         argument types */\n+      if (m2_or_arglist && TREE_CODE (m2_or_arglist) == FUNCTION_DECL)\n+\t{\n+\t  m2_arg = TYPE_ARG_TYPES (TREE_TYPE (m2_or_arglist));\n+\t  if (!METHOD_STATIC (m2_or_arglist))\n+\t    m2_arg = TREE_CHAIN (m2_arg);\n+\t}\n+      else\n+\tm2_arg = m2_or_arglist;\n \n-      /* Methods with default (package) access are OK if classes are\n-\t from the same default package. */\n-      if (identical || \n-\t  (!QUALIFIED_P (class_from_name) && !QUALIFIED_P (current_class_name)))\n-\tADD_TO_LIST_AND_CONTINUE;\n+      m2_arg_value = m2_or_arglist;\n+      m2_arg_cache = m2_arg;\n+    }\n \n-      /* Private method accessible iff current class is the node where\n-\t the method is defined */\n-      if ((access & ACC_PRIVATE) && (class_from == current_class))\n-\tADD_TO_LIST_AND_CONTINUE;\n+  while (m1_arg && m2_arg)\n+    {\n+      if (!valid_method_invocation_conversion_p (TREE_VALUE (m1_arg),\n+\t\t\t\t\t\t TREE_VALUE (m2_arg)))\n+\tbreak;\n+      m1_arg = TREE_CHAIN (m1_arg);\n+      m2_arg = TREE_CHAIN (m2_arg);\n     }\n-#undef ADD_TO_LIST_AND_CONTINUE\n-  return refined_list;\n+  return (!m1_arg && !m2_arg ? 1 : 0);\n }\n \n /* Qualification routines */\n@@ -5738,7 +5904,7 @@ qualify_ambiguous_name (id)\n \t    qual_wfl = QUAL_WFL (qual);\n \t  }\n \tbreak;\n-      case JAVA_NEW_CLASS_EXPR:\n+      case NEW_CLASS_EXPR:\n       case CONVERT_EXPR:\n       case ARRAY_REF:\n \tqual_wfl = TREE_OPERAND (qual_wfl, 0);\n@@ -5908,10 +6074,10 @@ java_complete_tree (node)\n      tree node;\n {\n   tree nn, cn, wfl_op1, wfl_op2;\n-  int flag, location;\n+  int flag;\n \n   /* CONVERT_EXPR always has its type set, even though it needs to be\n-     worked out */\n+     worked out. */\n   if (TREE_TYPE (node) && TREE_CODE (node) != CONVERT_EXPR)\n     return node;\n \n@@ -5946,6 +6112,10 @@ java_complete_tree (node)\n       break;\n \n       /* 2- They are expressions but ultimately deal with statements */\n+\n+    case TRY_EXPR:\n+      return patch_try_statement (node);\n+\n     case LABELED_BLOCK_EXPR:\n       PUSH_LABELED_BLOCK (node);\n       if (LABELED_BLOCK_BODY (node))\n@@ -5959,14 +6129,21 @@ java_complete_tree (node)\n          the EXIT_BLOCK_EXPR which doesn't exist it Java */\n       return patch_bc_statement (node);\n \n+    case SWITCH_EXPR:\n     case LOOP_EXPR:\n       PUSH_LOOP (node);\n       /* Check whether the loop was enclosed in a labeled\n          statement. If not, create one, insert the loop in it and\n          return the node */\n       nn = patch_loop_statement (node);\n+\n       /* Anyways, walk the body of the loop */\n-      TREE_OPERAND (node, 0) = java_complete_tree (TREE_OPERAND (node, 0));\n+      if (TREE_CODE (node) == LOOP_EXPR)\n+\tTREE_OPERAND (node, 0) = java_complete_tree (TREE_OPERAND (node, 0));\n+      /* Switch statement: walk the switch expression and the cases */\n+      else\n+\tnode = patch_switch_statement (node);\n+\n       if (TREE_OPERAND (node, 0) == error_mark_node)\n \treturn error_mark_node;\n       TREE_TYPE (nn) = TREE_TYPE (node) = void_type_node;\n@@ -6028,7 +6205,7 @@ java_complete_tree (node)\n \t}\n       break;\n \n-    case JAVA_NEW_ARRAY_EXPR:\n+    case NEW_ARRAY_EXPR:\n       /* Patch all the dimensions */\n       flag = 0;\n       for (cn = TREE_OPERAND (node, 1); cn; cn = TREE_CHAIN (cn))\n@@ -6054,9 +6231,9 @@ java_complete_tree (node)\n          were found. */\n       return (flag ? error_mark_node : patch_newarray (node));\n \n-    case JAVA_NEW_CLASS_EXPR:\n+    case NEW_CLASS_EXPR:\n     case CALL_EXPR:\n-      /* Complete function's argument first */\n+      /* Complete function's argument(s) first */\n       if (complete_function_arguments (node))\n \treturn error_mark_node;\n       else\n@@ -6102,6 +6279,12 @@ java_complete_tree (node)\n \t  return error_mark_node;\n \t}\n       TREE_OPERAND (node, 1) = nn;\n+\n+      /* In case we're handling = with a String as a RHS, we need to\n+\t produce a String out of the RHS (it might still be a\n+\t STRING_CST or a StringBuffer at this stage */\n+      if ((nn = patch_string (TREE_OPERAND (node, 1))))\n+\tTREE_OPERAND (node, 1) = nn;\n       return patch_assignment (node, wfl_op1, wfl_op2);\n \n     case MULT_EXPR:\n@@ -6127,15 +6310,23 @@ java_complete_tree (node)\n \t knows how to handle those cases. */\n       wfl_op1 = TREE_OPERAND (node, 0);\n       wfl_op2 = TREE_OPERAND (node, 1);\n-      TREE_OPERAND (node, 0) = java_complete_tree (wfl_op1);\n-      if (TREE_OPERAND (node, 0) == error_mark_node)\n-        return error_mark_node;\n-      TREE_OPERAND (node, 1) = java_complete_tree (wfl_op2);\n-      if (TREE_OPERAND (node, 1) == error_mark_node)\n-\treturn error_mark_node;\n+\n+      /* Don't complete string nodes if dealing with the PLUS operand. */\n+      if (TREE_CODE (node) != PLUS_EXPR || !JSTRING_P (wfl_op1))\n+\t{\n+\t  TREE_OPERAND (node, 0) = java_complete_tree (wfl_op1);\n+\t  if (TREE_OPERAND (node, 0) == error_mark_node)\n+\t    return error_mark_node;\n+\t}\n+      if (TREE_CODE (node) != PLUS_EXPR || !JSTRING_P (wfl_op2))\n+\t{\n+\t  TREE_OPERAND (node, 1) = java_complete_tree (wfl_op2);\n+\t  if (TREE_OPERAND (node, 1) == error_mark_node)\n+\t    return error_mark_node;\n+\t}\n       return patch_binop (node, wfl_op1, wfl_op2);\n \n-    case JAVA_UNARY_PLUS_EXPR:\n+    case UNARY_PLUS_EXPR:\n     case NEGATE_EXPR:\n     case TRUTH_NOT_EXPR:\n     case BIT_NOT_EXPR:\n@@ -6159,14 +6350,17 @@ java_complete_tree (node)\n       TREE_OPERAND (node, 0) = java_complete_tree (wfl_op1);\n       if (TREE_OPERAND (node, 0) == error_mark_node)\n \treturn error_mark_node;\n+      if (!flag_emit_class_files)\n+\tTREE_OPERAND (node, 0) = save_expr (TREE_OPERAND (node, 0));\n       /* The same applies to wfl_op2 */\n       wfl_op2 = TREE_OPERAND (node, 1);\n       TREE_OPERAND (node, 1) = java_complete_tree (wfl_op2);\n       if (TREE_OPERAND (node, 1) == error_mark_node)\n \treturn error_mark_node;\n+      TREE_OPERAND (node, 1) = save_expr (TREE_OPERAND (node, 1));\n       return patch_array_ref (node, wfl_op1, wfl_op2);\n \n-    case JAVA_THIS_EXPR:\n+    case THIS_EXPR:\n       /* Can't use THIS in a static environment */\n       if (!current_this)\n \t{\n@@ -6178,16 +6372,12 @@ java_complete_tree (node)\n \t}\n       return current_this;\n \n-    case STRING_CST:\n-      /* Build the internal string representation */\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n-      node = get_identifier (TREE_STRING_POINTER (node));\n-      location = alloc_name_constant (CONSTANT_String, node);\n-      node = build_ref_from_constant_pool (location);\n-      TREE_TYPE (node) = promote_type (string_type_node);\n-      return node;\n-\n     default:\n+      /* Ok: may be we have a STRING_CST or a crafted `StringBuffer'\n+\t and it's time to turn it into the appropriate String object\n+\t */\n+      if ((node = patch_string (node)))\n+\treturn node;\n       fatal (\"No case for tree code `%s' - java_complete_tree\\n\",\n \t     tree_code_name [TREE_CODE (node)]);\n     }\n@@ -6206,13 +6396,19 @@ complete_function_arguments (node)\n \n   for (cn = TREE_OPERAND (node, 1); cn; cn = TREE_CHAIN (cn))\n     {\n-      tree wfl = TREE_VALUE (cn), parm;\n+      tree wfl = TREE_VALUE (cn), parm, temp;\n       parm = java_complete_tree (wfl);\n       if (parm == error_mark_node)\n \t{\n \t  flag = 1;\n \t  continue;\n \t}\n+      /* If have a string literal that we haven't transformed yet or a\n+\t crafted string buffer, as a result of use of the the String\n+\t `+' operator. Build `parm.toString()' and expand it. */\n+      if ((temp = patch_string (parm)))\n+\tparm = TREE_VALUE (cn) = temp;\n+      \n       if (TREE_CODE (TREE_TYPE (parm)) == RECORD_TYPE)\n \tTREE_VALUE (cn) = convert (promote_type (TREE_TYPE (parm)), parm);\n       else\n@@ -6250,25 +6446,31 @@ build_expr_block (body, decls)\n {\n   tree node = make_node (BLOCK);\n   BLOCK_EXPR_DECLS (node) = decls;\n-  BLOCK_EXPR_BODY (body);\n+  BLOCK_EXPR_BODY (node) = body;\n   if (body)\n     TREE_TYPE (node) = TREE_TYPE (body);\n   TREE_SIDE_EFFECTS (node) = 1;\n   return node;\n }\n \n-/* Create a new function block and link its supercontext to the\n-   previous block. The current function DECL is used as supercontext\n-   when enter_block is called for the first time for a given\n-   function. The current function body (DECL_FUNCTION_BODY) is set to\n-   the newly created block.  */\n-\n-static block_level = 0;\n+/* Create a new function block and link it approriately to current\n+   function block chain */\n \n static tree\n enter_block ()\n {\n-  tree b = build_expr_block (NULL_TREE, NULL_TREE);\n+  return (enter_a_block (build_expr_block (NULL_TREE, NULL_TREE)));\n+}\n+\n+/* Link block B supercontext to the previous block. The current\n+   function DECL is used as supercontext when enter_a_block is called\n+   for the first time for a given function. The current function body\n+   (DECL_FUNCTION_BODY) is set to be block B.  */\n+\n+static tree\n+enter_a_block (b)\n+     tree b;\n+{\n   tree fndecl = current_function_decl; \n \n   if (!DECL_FUNCTION_BODY (fndecl))\n@@ -6342,7 +6544,7 @@ maybe_absorb_scoping_blocks ()\n    are building incomplete tree nodes and the patch_* functions that\n    are completing them.  */\n \n-/* Build an incomplete CALL_EXPR node. Encapsulate it within a WFL */\n+/* Build an incomplete CALL_EXPR node. */\n \n static tree\n build_method_invocation (name, args)\n@@ -6351,7 +6553,18 @@ build_method_invocation (name, args)\n {\n   tree call = build (CALL_EXPR, NULL_TREE, name, args, NULL_TREE);\n   TREE_SIDE_EFFECTS (call) = 1;\n-  /* Check on cases where NAME isn't a WFL. FIXME */\n+  EXPR_WFL_LINECOL (call) = EXPR_WFL_LINECOL (name);\n+  return call;\n+}\n+\n+/* Build an incomplete new xxx(...) node. */\n+\n+static tree\n+build_new_invocation (name, args)\n+    tree name, args;\n+{\n+  tree call = build (NEW_CLASS_EXPR, NULL_TREE, name, args, NULL_TREE);\n+  TREE_SIDE_EFFECTS (call) = 1;\n   EXPR_WFL_LINECOL (call) = EXPR_WFL_LINECOL (name);\n   return call;\n }\n@@ -6413,7 +6626,7 @@ patch_assignment (node, wfl_op1, wfl_op2)\n      tree wfl_op1;\n      tree wfl_op2;\n {\n-  tree rhs = TREE_OPERAND (node, 1);\n+  tree rhs = TREE_OPERAND (node, 1), temp;\n   tree lvalue = TREE_OPERAND (node, 0);\n   tree lhs_type, rhs_type, new_rhs = NULL_TREE;\n   int all_primitive;\n@@ -6458,56 +6671,14 @@ patch_assignment (node, wfl_op1, wfl_op2)\n     }\n \n   rhs_type = TREE_TYPE (rhs);\n+  /* 5.1 Try the assignment conversion for builtin type. */\n+  if ((new_rhs = try_builtin_assignconv (wfl_op1, lhs_type, rhs)))\n+    ;\n \n-  /* 5.2 Begin Assignment conversion */\n-\n-  /* 5.1.1 Try Identity Conversion */\n-  if (lhs_type == rhs_type) \n-    new_rhs = rhs;\n-  \n-  /* 5.1.2 Try Widening Primitive Conversion */\n-  all_primitive = JPRIMITIVE_TYPE_P (lhs_type) && JPRIMITIVE_TYPE_P (rhs_type);\n-  if (all_primitive && JINTEGRAL_TYPE_P (rhs_type)\n-      && ((TYPE_PRECISION (rhs_type) < TYPE_PRECISION (lhs_type))\n-\t  || (JFLOAT_TYPE_P (lhs_type) &&\n-\t      TYPE_PRECISION (rhs_type) == TYPE_PRECISION (lhs_type))))\n-    new_rhs = convert (lhs_type, rhs);\n-  else if (all_primitive && JFLOAT_TYPE_P (rhs_type)\n-\t   && (TYPE_PRECISION (rhs_type) < TYPE_PRECISION (lhs_type)))\n-    new_rhs = convert (lhs_type, rhs);\n-\n-  /* Try a narrowing primitive conversion: \n-       - expression is a constant expression of type int AND\n-       - variable is byte, short or char AND\n-       - The value of the expression is representable in the type of the \n-         variable */\n-  else if (rhs_type == int_type_node && TREE_CONSTANT (rhs)\n-\t   && (lhs_type == byte_type_node || lhs_type == char_type_node\n-\t       || lhs_type == short_type_node))\n-    {\n-      if (int_fits_type_p (rhs, lhs_type))\n-        new_rhs = convert (lhs_type, rhs);\n-      else\n-\tparse_warning_context \n-\t  (wfl_op1, \"Constant expression `%s' to wide for narrowing \"\n-\t   \"primitive conversion to `%s'\", \n-\t   print_int_node (rhs), lang_printable_name (lhs_type));\n-      /* Reported a warning that will turn into an error further\n-\t down, so we don't return */\n-    }\n-\n-  /* 5.2 Try a reference conversion */\n-  else if (!JPRIMITIVE_TYPE_P (rhs_type) && JREFERENCE_TYPE_P (lhs_type))\n-    {\n-      /* `null' may be assigned to any reference type */\n-      if (rhs == null_pointer_node)\n-        new_rhs = null_pointer_node;\n-      /* Try the reference assignment conversion */\n-      else if (valid_ref_assignconv_cast_p (rhs_type, lhs_type, 0))\n-\tnew_rhs = rhs;\n-      if (new_rhs)\n-\tlhs_type = promote_type (rhs_type);\n-    }\n+  /* 5.2 If it failed, try a reference conversion */\n+  if (!new_rhs &&\n+      (new_rhs = try_reference_assignconv (lhs_type, rhs)))\n+    lhs_type = promote_type (rhs_type);\n \n   /* 15.25.2 If we have a compound assignment, convert RHS into the\n      type of the LHS */\n@@ -6546,7 +6717,7 @@ patch_assignment (node, wfl_op1, wfl_op2)\n \t}\n \n       parse_error_context \n-\t(wfl, (!can_cast_to_p (rhs_type, lhs_type) ?\n+\t(wfl, (!valid_cast_to_p (rhs_type, lhs_type) ?\n \t       \"Incompatible type for %s. Can't convert `%s' to `%s'\" :\n \t       \"Incompatible type for %s. Explicit cast \"\n \t       \"needed to convert `%s' to `%s'\"), operation, t1, t2);\n@@ -6576,28 +6747,106 @@ patch_assignment (node, wfl_op1, wfl_op2)\n   return node;\n }\n \n-/* Check that SOURCE can be converted into DEST, at least with a\n-   cast. If the convertion can't occur at all, return 0 otherwise\n-   1. This function is used to produce accurate error messages on the\n-   reasons why an assignment failed. */\n+/* Check that type SOURCE can be cast into type DEST. If the cast\n+   can't occur at all, return 0 otherwise 1. This function is used to\n+   produce accurate error messages on the reasons why an assignment\n+   failed. */\n \n-static int\n-can_cast_to_p (source, dest)\n-     tree source;\n-     tree dest;\n+static tree\n+try_reference_assignconv (lhs_type, rhs)\n+     tree lhs_type, rhs;\n {\n-  if (TREE_CODE (source) == POINTER_TYPE)\n-    source = TREE_TYPE (source);\n-  if (TREE_CODE (dest) == POINTER_TYPE)\n-    dest = TREE_TYPE (dest);\n+  tree new_rhs = NULL_TREE;\n+  tree rhs_type = TREE_TYPE (rhs);\n \n-  if (TREE_CODE (source) == RECORD_TYPE && TREE_CODE (dest) == RECORD_TYPE)\n-    return valid_ref_assignconv_cast_p (source, dest, 1);\n-\n-  else if (JNUMERIC_TYPE_P (source) && JNUMERIC_TYPE_P (dest))\n-    return 1;\n-\n-  return 0;\n+  if (!JPRIMITIVE_TYPE_P (rhs_type) && JREFERENCE_TYPE_P (lhs_type))\n+    {\n+      /* `null' may be assigned to any reference type */\n+      if (rhs == null_pointer_node)\n+        new_rhs = null_pointer_node;\n+      /* Try the reference assignment conversion */\n+      else if (valid_ref_assignconv_cast_p (rhs_type, lhs_type, 0))\n+\tnew_rhs = rhs;\n+      /* This is a magic assignment that we process differently */\n+      else if (rhs == soft_exceptioninfo_call_node)\n+\tnew_rhs = rhs;\n+    }\n+  return new_rhs;\n+}\n+\n+/* Check that RHS can be converted into LHS_TYPE by the assignment\n+   conversion (5.2), for the cases of RHS being a builtin type. Return\n+   NULL_TREE if the conversion fails or if because RHS isn't of a\n+   builtin type. Return a converted RHS if the conversion is possible.  */\n+\n+static tree\n+try_builtin_assignconv (wfl_op1, lhs_type, rhs)\n+     tree wfl_op1, lhs_type, rhs;\n+{\n+  tree new_rhs = NULL_TREE;\n+  tree rhs_type = TREE_TYPE (rhs);\n+\n+  /* 5.1.1 Try Identity Conversion,\n+     5.1.2 Try Widening Primitive Conversion */\n+  if (valid_builtin_assignconv_identity_widening_p (lhs_type, rhs_type))\n+    new_rhs = convert (lhs_type, rhs);\n+\n+  /* Try a narrowing primitive conversion (5.1.3): \n+       - expression is a constant expression of type int AND\n+       - variable is byte, short or char AND\n+       - The value of the expression is representable in the type of the \n+         variable */\n+  else if (rhs_type == int_type_node && TREE_CONSTANT (rhs)\n+\t   && (lhs_type == byte_type_node || lhs_type == char_type_node\n+\t       || lhs_type == short_type_node))\n+    {\n+      if (int_fits_type_p (rhs, lhs_type))\n+        new_rhs = convert (lhs_type, rhs);\n+      else if (wfl_op1)\t\t/* Might be called with a NULL */\n+\tparse_warning_context \n+\t  (wfl_op1, \"Constant expression `%s' to wide for narrowing \"\n+\t   \"primitive conversion to `%s'\", \n+\t   print_int_node (rhs), lang_printable_name (lhs_type));\n+      /* Reported a warning that will turn into an error further\n+\t down, so we don't return */\n+    }\n+\n+  return new_rhs;\n+}\n+\n+/* Return 1 if RHS_TYPE can be converted to LHS_TYPE by identity\n+   conversion (5.1.1) or widening primitve conversion (5.1.2).  Return\n+   0 is the conversion test fails.  This implements parts the method\n+   invocation convertion (5.3).  */\n+\n+static int\n+valid_builtin_assignconv_identity_widening_p (lhs_type, rhs_type)\n+     tree lhs_type, rhs_type;\n+{\n+  int all_primitive = \n+    JPRIMITIVE_TYPE_P (lhs_type) && JPRIMITIVE_TYPE_P (rhs_type);\n+\n+  if (!all_primitive)\n+    return 0;\n+\n+  if (lhs_type == rhs_type)\n+    return 1;\n+\n+  /* byte, even if it's smaller than a char can't be converted into a\n+     char. Short can't too, but the < test below takes care of that */\n+  if (lhs_type == char_type_node && rhs_type == byte_type_node)\n+    return 0;\n+\n+  if (JINTEGRAL_TYPE_P (rhs_type)\n+      && ((TYPE_PRECISION (rhs_type) < TYPE_PRECISION (lhs_type))\n+\t  || (JFLOAT_TYPE_P (lhs_type) &&\n+\t      TYPE_PRECISION (rhs_type) == TYPE_PRECISION (lhs_type))))\n+    return 1;\n+  else if (JFLOAT_TYPE_P (rhs_type)\n+\t   && (TYPE_PRECISION (rhs_type) < TYPE_PRECISION (lhs_type)))\n+    return 1;\n+\n+  return 0;\n }\n \n /* Check that something of SOURCE type can be assigned or cast to\n@@ -6644,7 +6893,7 @@ valid_ref_assignconv_cast_p (source, dest, cast)\n \t    return dest == object_type_node;\n \t  /* We're doing a cast. The cast is always valid is class\n \t     DEST is not final, otherwise, DEST must implement SOURCE */\n-\t  else if (!CLASS_FINAL (TYPE_NAME (source)))\n+\t  else if (!CLASS_FINAL (TYPE_NAME (dest)))\n \t    return 1;\n \t  else\n \t    return interface_of_p (source, dest);\n@@ -6704,6 +6953,41 @@ valid_ref_assignconv_cast_p (source, dest, cast)\n   return 0;\n }\n \n+static int\n+valid_cast_to_p (source, dest)\n+     tree source;\n+     tree dest;\n+{\n+  if (TREE_CODE (source) == POINTER_TYPE)\n+    source = TREE_TYPE (source);\n+  if (TREE_CODE (dest) == POINTER_TYPE)\n+    dest = TREE_TYPE (dest);\n+\n+  if (TREE_CODE (source) == RECORD_TYPE && TREE_CODE (dest) == RECORD_TYPE)\n+    return valid_ref_assignconv_cast_p (source, dest, 1);\n+\n+  else if (JNUMERIC_TYPE_P (source) && JNUMERIC_TYPE_P (dest))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Method invocation conversion test. Return 1 if type SOURCE can be\n+   converted to type DEST through the methond invocation conversion\n+   process (5.3) */\n+\n+static int\n+valid_method_invocation_conversion_p (dest, source)\n+     tree dest, source;\n+{\n+  return ((JPRIMITIVE_TYPE_P (source) \n+\t    && JPRIMITIVE_TYPE_P (dest)\n+\t    && valid_builtin_assignconv_identity_widening_p (dest, source))\n+\t   || (JREFERENCE_TYPE_P (source) \n+\t       && JREFERENCE_TYPE_P (dest)\n+\t       && valid_ref_assignconv_cast_p (source, dest, 0)));\n+}\n+\n /* Build an incomplete binop expression. */\n \n static tree\n@@ -6712,15 +6996,9 @@ build_binop (op, op_location, op1, op2)\n      int op_location;\n      tree op1, op2;\n {\n-  tree wfl;\n-\n-  /* URSHIFT_EXPR is not part of what GCC understands, we can't directly build\n-     a node with it */\n-  tree binop = \n-    build ((op == URSHIFT_EXPR ? RSHIFT_EXPR : op), NULL_TREE, op1, op2);\n-  if (op == URSHIFT_EXPR)\n-    TREE_SET_CODE (binop, op);\n+  tree wfl, binop, merge;\n \n+  binop = build (op, NULL_TREE, op1, op2);\n   TREE_SIDE_EFFECTS (binop) = 1;\n   /* Store the location of the operator, for better error report. The\n      string of the operator will be rebuild based on the OP value. */\n@@ -6766,7 +7044,7 @@ operator_string (node)\n     case GE_EXPR: BUILD_OPERATOR_STRING (\">=\");\n     case LT_EXPR: BUILD_OPERATOR_STRING (\"<\");\n     case LE_EXPR: BUILD_OPERATOR_STRING (\"<=\");\n-    case JAVA_UNARY_PLUS_EXPR: BUILD_OPERATOR_STRING (\"+\");\n+    case UNARY_PLUS_EXPR: BUILD_OPERATOR_STRING (\"+\");\n     case NEGATE_EXPR: BUILD_OPERATOR_STRING (\"-\");\n     case TRUTH_NOT_EXPR: BUILD_OPERATOR_STRING (\"!\");\n     case BIT_NOT_EXPR: BUILD_OPERATOR_STRING (\"~\");\n@@ -6800,6 +7078,7 @@ patch_binop (node, wfl_op1, wfl_op2)\n   tree op2_type = TREE_TYPE (op2);\n   tree prom_type;\n   int code = TREE_CODE (node);\n+\n   /* If 1, tell the routine that we have to return error_mark_node\n      after checking for the initialization of the RHS */\n   int error_found = 0;\n@@ -6850,8 +7129,20 @@ patch_binop (node, wfl_op1, wfl_op2)\n \n     /* 15.17 Additive Operators */\n     case PLUS_EXPR:\t\t/* 15.17.1 String Concatenation Operator + */\n-      if (JSTRING_TYPE_P (op1_type) || JSTRING_TYPE_P (op2_type))\n-\tfatal (\"operator `+' non implemented on String - patch_binop\");\n+\n+      /* Operation is valid if either one argument is a string\n+\t constant, a String object or a StringBuffer crafted for the\n+\t purpose of the a previous usage of the String concatenation\n+\t operator */\n+\n+      if (TREE_CODE (op1) == STRING_CST \n+\t  || TREE_CODE (op2) == STRING_CST\n+\t  || JSTRING_TYPE_P (op1_type)\n+\t  || JSTRING_TYPE_P (op2_type)\n+\t  || IS_CRAFTED_STRING_BUFFER_P (op1)\n+\t  || IS_CRAFTED_STRING_BUFFER_P (op2))\n+\treturn build_string_concatenation (op1, op2);\n+\n     case MINUS_EXPR:\t\t/* 15.17.2 Additive Operators (+ and -) for\n \t\t\t\t   Numeric Types */\n       if (!JPRIMITIVE_TYPE_P (op1_type) || !JPRIMITIVE_TYPE_P (op2_type))\n@@ -7002,7 +7293,7 @@ patch_binop (node, wfl_op1, wfl_op2)\n \t\t|| JREFERENCE_TYPE_P (op1_type) \n \t\t|| JREFERENCE_TYPE_P (op2_type))\n \t       && ((op1_type == op2_type)\n-\t\t   /* The should use a can_cast_to_p() */\n+\t\t   /* There should use a valid_cast_to_p() */\n \t\t   ))\n \t;\t\t\t/* Nothing to do here */\n \t  \n@@ -7044,10 +7335,195 @@ patch_binop (node, wfl_op1, wfl_op2)\n   return fold (node);\n }\n \n-/* Build an incomplete unary operator expression. Unary `+' node is\n-   build as a CONV_EXPR, even though its tree code is overridden by a\n-   JAVA_UNARY_PLUS_EXPR that isn't a tree code, to differentiate it during\n-   the walk. */\n+/* Concatenate the STRING_CST CSTE and STRING. When AFTER is a non\n+   zero value, the value of CSTE comes after the valude of STRING */\n+\n+static tree\n+do_merge_string_cste (cste, string, string_len, after)\n+     tree cste;\n+     char *string;\n+     int string_len, after;\n+{\n+  int len = TREE_STRING_LENGTH (cste) + string_len;\n+  char *old = TREE_STRING_POINTER (cste);\n+  TREE_STRING_LENGTH (cste) = len;\n+  TREE_STRING_POINTER (cste) = obstack_alloc (expression_obstack, len+1);\n+  if (after)\n+    {\n+      strcpy (TREE_STRING_POINTER (cste), string);\n+      strcat (TREE_STRING_POINTER (cste), old);\n+    }\n+  else\n+    {\n+      strcpy (TREE_STRING_POINTER (cste), old);\n+      strcat (TREE_STRING_POINTER (cste), string);\n+    }\n+  return cste;\n+}\n+\n+/* Tries to merge OP1 (a STRING_CST) and OP2 (if suitable). Return a\n+   new STRING_CST on success, NULL_TREE on failure */\n+\n+static tree\n+merge_string_cste (op1, op2, after)\n+     tree op1, op2;\n+     int after;\n+{\n+  /* Handle two string constants right away */\n+  if (TREE_CODE (op2) == STRING_CST)\n+    return do_merge_string_cste (op1, TREE_STRING_POINTER (op2), \n+\t\t\t\t TREE_STRING_LENGTH (op2), after);\n+  \n+  /* Reasonable integer constant can be treated right away */\n+  if (TREE_CODE (op2) == INTEGER_CST && !TREE_CONSTANT_OVERFLOW (op2))\n+    {\n+      static char *boolean_true = \"true\";\n+      static char *boolean_false = \"false\";\n+      static char *null_pointer = \"null\";\n+      char ch[3];\n+      char *string;\n+      \n+      if (op2 == boolean_true_node)\n+\tstring = boolean_true;\n+      else if (op2 == boolean_false_node)\n+\tstring = boolean_false;\n+      else if (op2 == null_pointer_node)\n+\tstring = null_pointer;\n+      else if (TREE_TYPE (op2) == char_type_node)\n+\t{\n+\t  ch[0] = (char )TREE_INT_CST_LOW (op2);\n+\t  ch[1] = '\\0';\n+\t  string = ch;\n+\t}\n+      else\n+\t  string = print_int_node (op2);\n+      \n+      return do_merge_string_cste (op1, string, strlen (string), after);\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Tries to statically concatenate OP1 and OP2 if possible. Either one\n+   has to be a STRING_CST and the other part must be a STRING_CST or a\n+   INTEGRAL constant. Return a new STRING_CST if the operation\n+   succeed, NULL_TREE otherwise.\n+\n+   If the case we want to optimize for space, we might want to return\n+   NULL_TREE for each invocation of this routine. FIXME */\n+\n+static tree\n+string_constant_concatenation (op1, op2)\n+     tree op1, op2;\n+{\n+  if (TREE_CODE (op1) == STRING_CST || (TREE_CODE (op2) == STRING_CST))\n+    {\n+      tree string, rest, result;\n+      int invert;\n+      \n+      string = (TREE_CODE (op1) == STRING_CST ? op1 : op2);\n+      rest   = (string == op1 ? op2 : op1);\n+      invert = (string == op1 ? 0 : 1 );\n+      \n+      /* Walk REST, only if it looks reasonable */\n+      if (TREE_CODE (rest) != STRING_CST\n+\t  && !IS_CRAFTED_STRING_BUFFER_P (rest)\n+\t  && !JSTRING_TYPE_P (TREE_TYPE (rest))\n+\t  && TREE_CODE (rest) == EXPR_WITH_FILE_LOCATION)\n+\t{\n+\t  rest = java_complete_tree (rest);\n+\t  if (rest == error_mark_node)\n+\t    return error_mark_node;\n+\t  rest = fold (rest);\n+\t}\n+      return merge_string_cste (string, rest, invert);\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Implement the `+' operator. Does static optimization if possible,\n+   otherwise create (if necessary) and append elements to a\n+   StringBuffer. The StringBuffer will be carried around until it is\n+   used for a function call or an assignment. Then toString() will be\n+   called on it to turn it into a String object. */\n+\n+static tree\n+build_string_concatenation (op1, op2)\n+     tree op1, op2;\n+{\n+  tree result;\n+  \n+  /* Try to do some static optimization */\n+  if ((result = string_constant_concatenation (op1, op2)))\n+    return result;\n+\n+  /* If operands are string constant, turn then into object references */\n+\n+  if (TREE_CODE (op1) == STRING_CST)\n+    op1 = patch_string_cst (op1);\n+  if (TREE_CODE (op2) == STRING_CST)\n+    op2 = patch_string_cst (op2);\n+\n+  /* If OP1 isn't already a StringBuffer, create and\n+     initialize a new one */\n+  if (!IS_CRAFTED_STRING_BUFFER_P (op1))\n+    {\n+      /* Two solutions here: \n+\t 1) OP1 is a string reference, we call new StringBuffer(OP1)\n+\t 2) Op2 is something else, we call new StringBuffer().append(OP1). */\n+      if (JSTRING_TYPE_P (TREE_TYPE (op1)))\n+\top1 = BUILD_STRING_BUFFER (op1);\n+      else\n+\t{\n+\t  tree aNew = BUILD_STRING_BUFFER (NULL_TREE);\n+\t  op1 = make_qualified_primary (aNew, BUILD_APPEND (op1), 0);\n+\t}\n+    }\n+\n+  /* No longer the last node holding a crafted StringBuffer */\n+  IS_CRAFTED_STRING_BUFFER_P (op1) = 0;\n+  /* Create a node for `{new...,xxx}.append (op2)' */\n+  op1 = make_qualified_primary (op1, BUILD_APPEND (op2), 0);\n+  /* Mark the last node holding a crafted StringBuffer */\n+  IS_CRAFTED_STRING_BUFFER_P (op1) = 1;\n+  \n+  return op1;\n+}\n+\n+/* Patch the string node NODE. NODE can be a STRING_CST of a crafted\n+   StringBuffer. If no string were found to be patched, return\n+   NULL. */\n+\n+static tree\n+patch_string (node)\n+    tree node;\n+{\n+  if (TREE_CODE (node) == STRING_CST)\n+    return patch_string_cst (node);\n+  else if (IS_CRAFTED_STRING_BUFFER_P (node))\n+    {\n+      tree invoke = build_method_invocation (wfl_to_string, NULL_TREE);\n+      return java_complete_tree (make_qualified_primary (node, invoke, 0));\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Build the internal representation of a string constant.  */\n+\n+static tree\n+patch_string_cst (node)\n+     tree node;\n+{\n+  int location;\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+  node = get_identifier (TREE_STRING_POINTER (node));\n+  location = alloc_name_constant (CONSTANT_String, node);\n+  node = build_ref_from_constant_pool (location);\n+  TREE_TYPE (node) = promote_type (string_type_node);\n+  TREE_CONSTANT (node) = 1;\n+  return node;\n+}\n+\n+/* Build an incomplete unary operator expression. */\n \n static tree\n build_unaryop (op_token, op_location, op1)\n@@ -7058,7 +7534,7 @@ build_unaryop (op_token, op_location, op1)\n   tree unaryop;\n   switch (op_token)\n     {\n-    case PLUS_TK: op = CONVERT_EXPR; break;\n+    case PLUS_TK: op = UNARY_PLUS_EXPR; break;\n     case MINUS_TK: op = NEGATE_EXPR; break;\n     case NEG_TK: op = TRUTH_NOT_EXPR; break;\n     case NOT_TK: op = BIT_NOT_EXPR; break;\n@@ -7067,9 +7543,6 @@ build_unaryop (op_token, op_location, op1)\n     }\n \n   unaryop = build1 (op, NULL_TREE, op1);\n-  if (op_token == PLUS_TK)\n-    TREE_SET_CODE (unaryop, JAVA_UNARY_PLUS_EXPR);\n-\n   TREE_SIDE_EFFECTS (unaryop) = 1;\n   /* Store the location of the operator, for better error report. The\n      string of the operator will be rebuild based on the OP value. */\n@@ -7142,7 +7615,8 @@ patch_unaryop (node, wfl_op)\n     case PREINCREMENT_EXPR:\n       /* 15.14.2 Prefix Decrement Operator -- */\n     case PREDECREMENT_EXPR:\n-      if (!DECL_P (op))\n+      if (!DECL_P (op) && !(TREE_CODE (op) == INDIRECT_REF \n+\t\t\t    && JPRIMITIVE_TYPE_P (TREE_TYPE (op))))\n \t{\n \t  parse_error_context (wfl_operator, \"Invalid argument to `%s'\",\n \t\t\t       operator_string (node));\n@@ -7181,7 +7655,7 @@ patch_unaryop (node, wfl_op)\n       break;\n \n       /* 15.14.3 Unary Plus Operator + */\n-    case JAVA_UNARY_PLUS_EXPR:\n+    case UNARY_PLUS_EXPR:\n       /* 15.14.4 Unary Minus Operator - */\n     case NEGATE_EXPR:\n       if (!JNUMERIC_TYPE_P (op_type))\n@@ -7195,7 +7669,7 @@ patch_unaryop (node, wfl_op)\n \t{\n \t  prom_type = promote_type (op_type);\n \t  op = convert (prom_type, op);\n-\t  if (code == JAVA_UNARY_PLUS_EXPR)\n+\t  if (code == UNARY_PLUS_EXPR)\n \t    node = op;\n \t}\n       break;\n@@ -7249,8 +7723,8 @@ patch_unaryop (node, wfl_op)\n   \n   if (error_found)\n     return error_mark_node;\n-  /* In the case of JAVA_UNARY_PLUS_EXPR, we replaced NODE by a new one */\n-  else if (code != JAVA_UNARY_PLUS_EXPR && code != CONVERT_EXPR)\n+  /* In the case of UNARY_PLUS_EXPR, we replaced NODE by a new one */\n+  else if (code != UNARY_PLUS_EXPR && code != CONVERT_EXPR)\n     {\n       TREE_OPERAND (node, 0) = op;\n       TREE_TYPE (node) = prom_type;\n@@ -7316,7 +7790,7 @@ patch_cast (node, wfl_op, wfl_operator)\n   /* The remaining legal casts involve conversion between reference\n      types. Check for their compile time correctness. */\n   if (JREFERENCE_TYPE_P (op_type) && JREFERENCE_TYPE_P (cast_type) \n-      && valid_ref_assignconv_cast_p (op_type, cast_type, 1))\n+      && valid_ref_assignconv_cast_p (cast_type, op_type, 1))\n     {\n       TREE_TYPE (node) = promote_type (cast_type);\n       /* Now, the case can be determined correct at compile time if\n@@ -7374,8 +7848,6 @@ patch_array_ref (node, wfl_array, wfl_index)\n       ERROR_VARIABLE_NOT_INITIALIZED (wfl_array, DECL_NAME (array));\n       INITIALIZED_P (array) = 1;\n     }\n-  if (! flag_emit_class_files)\n-    array = save_expr (array);\n \n   if (TREE_CODE (array_type) == POINTER_TYPE)\n     array_type = TREE_TYPE (array_type);\n@@ -7395,7 +7867,7 @@ patch_array_ref (node, wfl_array, wfl_index)\n   promoted_index_type = promote_type (index_type);\n   if (promoted_index_type != int_type_node)\n     {\n-      int could_cast = can_cast_to_p (index_type, int_type_node);\n+      int could_cast = valid_cast_to_p (index_type, int_type_node);\n       parse_error_context \n \t(wfl_operator, \n \t (could_cast ? \"Incompatible type for `[]'. Explicit cast needed to \"\n@@ -7439,9 +7911,8 @@ build_newarray_node (type, dims, extra_dims)\n      int extra_dims;\n {\n   tree node =\n-    build (CALL_EXPR, NULL_TREE, type, nreverse (dims), \n+    build (NEW_ARRAY_EXPR, NULL_TREE, type, nreverse (dims), \n \t   build_int_2 (extra_dims, 0));\n-  TREE_SET_CODE (node, JAVA_NEW_ARRAY_EXPR);\n   return node;\n }\n \n@@ -7487,7 +7958,7 @@ patch_newarray (node)\n \t    (TREE_PURPOSE (cdim), \n \t     \"Incompatible type for dimension in array creation expression. \"\n \t     \"%s convert `%s' to `int'\", \n-\t     (can_cast_to_p (TREE_TYPE (dim), int_type_node) ?\n+\t     (valid_cast_to_p (TREE_TYPE (dim), int_type_node) ?\n \t      \"Explicit cast needed to\" : \"Can't\"),\n \t     lang_printable_name (TREE_TYPE (dim)));\n \t  error_found = 1;\n@@ -7578,7 +8049,7 @@ build_this (location)\n      int location;\n {\n   tree node = build_wfl_node (this_identifier_node, input_filename, 0, 0);\n-  TREE_SET_CODE (node, JAVA_THIS_EXPR);\n+  TREE_SET_CODE (node, THIS_EXPR);\n   EXPR_WFL_LINECOL (node) = location;\n   return node;\n }\n@@ -7594,6 +8065,7 @@ build_return (location, op)\n {\n   tree node = build1 (RETURN_EXPR, NULL_TREE, op);\n   EXPR_WFL_LINECOL (node) = location;\n+  node = build_debugable_stmt (location, node);\n   return node;\n }\n \n@@ -7663,6 +8135,7 @@ build_if_else_statement (location, expression, if_body, else_body)\n     else_body = build (COMPOUND_EXPR, void_type_node, NULL_TREE, NULL_TREE);\n   node = build (COND_EXPR, NULL_TREE, expression, if_body, else_body);\n   EXPR_WFL_LINECOL (node) = location;\n+  node = build_debugable_stmt (location, node);\n   return node;\n }\n \n@@ -7676,7 +8149,8 @@ patch_if_else_statement (node)\n   EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n \n   /* The type of expression must be boolean */\n-  if (TREE_TYPE (expression) != boolean_type_node)\n+  if (TREE_TYPE (expression) != boolean_type_node\n+      && TREE_TYPE (expression) != promoted_boolean_type_node)\n     {\n       parse_error_context \n \t(wfl_operator, \n@@ -7734,17 +8208,10 @@ build_labeled_block (location, label, wfl)\n static tree\n generate_labeled_block ()\n {\n-  static int l_number = 0;\n-  char buf [20];\n-  tree label_name;\n-  \n-  sprintf (buf, \"$a%d\", l_number++);\n-  return build_labeled_block (0, get_identifier (buf), NULL_TREE);\n+  return build_labeled_block (0, generate_name (), NULL_TREE);\n }\n \n-/* A labeled statement LBE is attached a statement. If the statement\n-   happens to be a loop, a link from the loop back to the label is\n-   installed.  */\n+/* A labeled statement LBE is attached a statement.  */\n \n static tree\n complete_labeled_statement (lbe, statement)\n@@ -7791,7 +8258,15 @@ build_new_loop (loop_body)\n        INCREMENT\t\t(if any)\n \n   REVERSED, if non zero, tells that the loop condition expr comes\n-  after the body, like in the do-while loop.  */\n+  after the body, like in the do-while loop.\n+\n+  To obtain a loop, the loop body structure described above is\n+  encapsulated within a LOOP_EXPR surrounded by a LABELED_BLOCK_EXPR:\n+\n+   LABELED_BLOCK_EXPR\n+     LABEL_DECL                   (use this label to exit the loop)\n+     LOOP_EXPR\n+       <structure described above> */\n \n static tree\n build_loop_body (location, condition, reversed)\n@@ -7912,6 +8387,7 @@ build_bc_statement (location, is_break, name)\n   IS_BREAK_STMT_P (break_continue) = is_break;\n   TREE_SIDE_EFFECTS (break_continue) = 1;\n   EXPR_WFL_LINECOL (break_continue) = location;\n+  break_continue = build_debugable_stmt (location, break_continue);\n   return break_continue;\n }\n \n@@ -7923,24 +8399,30 @@ patch_bc_statement (node)\n {\n   tree bc_label = EXIT_BLOCK_LABELED_BLOCK (node), target_stmt;\n   int is_unlabeled = 0;\n- EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n+  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n  \n   /* Not having a target means that the break/continue statement is\n-     unlabeled. We try to find a descent label for it */\n+     unlabeled. We try to find a decent label for it */\n   if (!bc_label)\n     {\n       is_unlabeled = 1;\n-      /* There should be a loop to branch to */\n+      /* There should be a loop/switch to branch to */\n       if (ctxp->current_loop)\n \t{\n-\t  /* At that stage, we're in the loop body, which is\n-\t     encapsulated around a LABELED_BLOCK_EXPR. So searching\n-\t     the current loop label requires us to consider the\n-\t     labeled block before the current one. */\n-\t  if (!LOOP_HAS_LABEL_SKIP_P (ctxp->current_loop))\n-\t    fatal (\"unlabeled loop has not installed label -- \"\n-\t\t   \"patch_bc_statement\");\n-\t  bc_label = TREE_CHAIN (ctxp->current_labeled_block);\n+\t  if (TREE_CODE (ctxp->current_loop) == LOOP_EXPR)\n+\t    {\n+\t      /* At that stage, we're in the loop body, which is\n+\t\t encapsulated around a LABELED_BLOCK_EXPR. So searching\n+\t\t the current loop label requires us to consider the\n+\t\t labeled block before the current one. */\n+\t      if (!LOOP_HAS_LABEL_SKIP_P (ctxp->current_loop))\n+\t\tfatal (\"unlabeled loop has no installed label -- \"\n+\t\t       \"patch_bc_statement\");\n+\t      bc_label = TREE_CHAIN (ctxp->current_labeled_block);\n+\t    }\n+\t  /* For a SWITCH statement, this is the current one */\n+\t  else\n+\t    bc_label = ctxp->current_labeled_block;\n \t}\n       /* Not having a loop to break/continue to is an error */\n       else\n@@ -7969,8 +8451,8 @@ patch_bc_statement (node)\n          (already verified). Anonymous break need to target\n          while/do/for/switch */\n       if (is_unlabeled &&\n-\t  !(TREE_CODE (target_stmt) == LOOP_EXPR   /* do/while/for */\n-\t    || 0))\t\t                   /* switch FIXME */\n+\t  !(TREE_CODE (target_stmt) == LOOP_EXPR        /* do/while/for */\n+\t    || TREE_CODE (target_stmt) == SWITCH_EXPR)) /* switch FIXME */\n \t{\n \t  parse_error_context (wfl_operator, \n \t\t\t       \"`break' must be in loop or switch\");\n@@ -8033,3 +8515,425 @@ patch_exit_expr (node)\n   TREE_TYPE (node) = void_type_node;\n   return node;\n }\n+\n+/* 14.9 Switch statement */\n+\n+static tree\n+patch_switch_statement (node)\n+     tree node;\n+{\n+  int error_found = 0;\n+  tree se = TREE_OPERAND (node, 0), se_type, sb;\n+  tree default_found = NULL_TREE;\n+\n+  /* Complete the switch expression */\n+  se = TREE_OPERAND (node, 0) = java_complete_tree (se);\n+  se_type = TREE_TYPE (se);\n+  /* The type of the switch expression must be char, byte, short or\n+     int */\n+  if (!JINTEGRAL_TYPE_P (se_type))\n+    {\n+      EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n+      parse_error_context (wfl_operator, \"Incompatible type for `switch'. \"\n+\t\t\t   \"Can't convert `%s' to `int'\",\n+\t\t\t   lang_printable_name (se_type));\n+      /* This is what java_complete_tree will check */\n+      TREE_OPERAND (node, 0) = error_mark_node;\n+      return error_mark_node;\n+    }\n+\n+  /* Process the switch body. We should have a list of TREE_LIST. The\n+     PURPOSE of each node should be a list of case values, VALUE\n+     should be the associated block. We try to process all cases and\n+     defaults before returning, possibly finding errors.  */\n+  TREE_OPERAND (node, 1) = nreverse (TREE_OPERAND (node, 1));\n+  for (sb = TREE_OPERAND (node, 1); sb; sb = TREE_CHAIN (sb))\n+    {\n+      tree label;\n+\n+      /* If we don't have a TREE_LIST here, we have a statement inside\n+\t the switch that isn't tied to a label. This error is caught\n+\t by the parser and we don't have to report it here. */\n+\n+      TREE_PURPOSE (sb) = nreverse (TREE_PURPOSE (sb));\n+      for (label = TREE_PURPOSE (sb); label; label = TREE_CHAIN (label))\n+\t{\n+\t  tree case_expr;\n+\t  \n+\t  /* Verification of the default label */\n+\t  if (TREE_CODE (label) == DEFAULT_EXPR)\n+\t    {\n+\t      /* Only one default label is allowed per switch\n+                 statement */\n+\t      if (default_found)\n+\t\t{\n+\t\t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (label);\n+\t\t  parse_error_context (wfl_operator, \n+\t\t\t\t       \"Duplicate case label: `default'\");\n+\t\t  error_found = 1;\n+\t\t}\n+\t      else\n+\t\tdefault_found = label;\n+\t      continue;\n+\t    }\n+\t  /* Verification of case labels */\n+\t  else\n+\t    {\n+\t      case_expr = java_complete_tree (TREE_OPERAND (label, 0));\n+\t      if (case_expr == error_mark_node)\n+\t\tcontinue;\n+\n+\t      /* First, the case expression must be constant */\n+\t      case_expr = fold (case_expr);\n+\t      if (!TREE_CONSTANT (case_expr))\n+\t\t{\n+\t\t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (label);\n+\t\t  parse_error_context (label, \"Constant expression required\");\n+\t\t  error_found = 1;\n+\t\t  break;\n+\t\t}\n+\t      \n+\t      /* It must be assignable to the type of the switch\n+\t\t expression. */\n+\t      if (!try_builtin_assignconv (NULL_TREE, se_type, case_expr))\n+\t\t{\n+\t\t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (label);\n+\t\t  parse_error_context \n+\t\t    (wfl_operator,\n+\t\t     \"Incompatible type for case. Can't convert `%s' to `int'\",\n+\t\t     lang_printable_name (TREE_TYPE (case_expr)));\n+\t\t  error_found = 1;\n+\t\t  break;\n+\t\t}\n+\n+\t      /* Multiple instance of a case label bearing the same\n+                 value is checked during code generation. The case\n+                 expression is allright so far. */\n+\t      TREE_OPERAND (label, 0) = case_expr;\n+\t    }\n+\t}\n+\n+      /* First TREE_VALUE should be the block tied to this list of\n+         cases. Check that this block exists and the walk it */\n+      if (TREE_VALUE (sb))\n+\t{\n+\t  TREE_VALUE (sb) = java_complete_tree (TREE_VALUE (sb));\n+\t  if (TREE_VALUE (sb) == error_mark_node)\n+\t    error_found = 1;\n+\t}\n+    }\n+\n+  /* Ready to return */\n+  if (error_found)\n+    {\n+      TREE_TYPE (node) = error_mark_node;\n+      return error_mark_node;\n+    }\n+  TREE_TYPE (node) = void_type_node;\n+  TREE_SIDE_EFFECTS (node) = 1;\n+  return node;\n+}\n+\n+/* Do the expansion of a Java switch. With Gcc, switches are front-end\n+   dependant things, but they rely on gcc routines. This function is\n+   placed here because it uses things defined locally in parse.y. */\n+\n+static tree\n+case_identity (t, v)\n+     tree t, v;\n+{\n+  return v;\n+}\n+\n+void\n+java_expand_switch (exp)\n+     tree exp;\n+{\n+  tree sb;\n+  expand_start_case (0, TREE_OPERAND (exp, 0), int_type_node, \"switch\");\n+\n+  for (sb = TREE_OPERAND (exp, 1); sb; sb = TREE_CHAIN (sb))\n+    {\n+      /* We have a list of TREE_LIST. PURPOSE is the case value, and\n+\t when it exists, VALUE is the associated block */\n+      \n+      /* The first CASE element should contain the associated block,\n+\t if any. All other should be case statements related to the\n+\t same block */\n+      tree label;\n+      for (label = TREE_PURPOSE (sb); label; label = TREE_CHAIN (label))\n+\t{\n+\t  tree label_decl = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+\t  if (TREE_CODE (label) == CASE_EXPR)\n+\t    {\n+\t      tree duplicate;\n+\t      if (pushcase (TREE_OPERAND (label, 0), case_identity,\n+\t\t\t    label_decl, &duplicate) == 2)\n+\t\t{\n+\t\t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (label);\n+\t\t  parse_error_context\n+\t\t    (wfl_operator, \"Duplicate case label: `%s'\",\n+\t\t     print_int_node (TREE_OPERAND (label, 0)));\n+\t\t}\n+\t    }\n+\t  else\n+\t    pushcase (NULL_TREE, 0, label_decl, NULL);\n+\t}\n+      /* Expand the associated block, if any */\n+      if (TREE_VALUE (sb))\n+\texpand_expr_stmt (TREE_VALUE (sb));\n+    } \n+  expand_end_case (TREE_OPERAND (exp, 0));\n+}\n+\n+/* 14.18 The try statement */\n+\n+/* Wrap BLOCK around a LABELED_BLOCK, set DECL to the newly generated\n+   exit labeld and issue a jump to FINALLY_LABEL:\n+     \n+   LABELED_BLOCK\n+     BLOCK\n+       <orignal_statments>\n+       DECL = &LABEL_DECL\n+       GOTO_EXPR\n+         FINALLY_LABEL\n+     LABEL_DECL */\n+\n+static tree\n+build_jump_to_finally (block, decl, finally_label, type)\n+     tree block, decl, finally_label, type;\n+{\n+  tree stmt;\n+  tree new_block = build (LABELED_BLOCK_EXPR, type,\n+\t\t\t  create_label_decl (generate_name ()), block);\n+\n+  stmt = build (MODIFY_EXPR, void_type_node, decl,\n+\t\tbuild_address_of (LABELED_BLOCK_LABEL (new_block)));\n+  TREE_SIDE_EFFECTS (stmt) = 1;\n+  add_stmt_to_block (block, type, stmt);\n+  stmt = build (GOTO_EXPR, void_type_node, finally_label);\n+  TREE_SIDE_EFFECTS (stmt) = 1;\n+  add_stmt_to_block (block, type, stmt);\n+  return new_block;\n+}\n+\n+static tree\n+build_try_statement (location, try_block, catches, finally)\n+     int location;\n+     tree try_block, catches, finally;\n+{\n+  tree node, rff;\n+\n+  if (finally)\n+    {\n+      /* This block defines a scope for the entire try[-catch]-finally\n+\t sequence. It hold a local variable used to return from the\n+\t finally using a computed goto. We call it\n+\t return_from_finally (RFF). */\n+      rff = build_decl_no_layout (VAR_DECL, generate_name (),\n+\t\t\t\t   return_address_type_node);\n+\n+      /* Modification of the try block. */\n+      try_block = build_jump_to_finally (try_block, rff, \n+\t\t\t\t\t FINALLY_EXPR_LABEL (finally), \n+\t\t\t\t\t NULL_TREE);\n+\n+      /* To the finally block: add the computed goto */\n+      add_stmt_to_block (FINALLY_EXPR_BLOCK (finally), NULL_TREE,\n+\t\t\t build (GOTO_EXPR, void_type_node, rff));\n+\n+      /* Modification of each catch blocks, if any */\n+      if (catches)\n+\t{\n+\t  tree catch, catch_decl, catch_block, stmt;\n+\n+\t  for (catch = catches; catch; catch = TREE_CHAIN (catch))\n+\t    TREE_OPERAND (catch, 0) = \n+\t      build_jump_to_finally (TREE_OPERAND (catch, 0), rff,\n+\t\t\t\t     FINALLY_EXPR_LABEL (finally),\n+\t\t\t\t     NULL_TREE);\n+\n+\t  /* Plus, at the end of the list, we add the catch clause that\n+\t     will catch an uncaught exception, call finally and rethrow it:\n+\t       BLOCK\n+\t         void *exception_parameter; (catch_decl)\n+\t\t LABELED_BLOCK\n+\t\t   BLOCK\n+\t\t     exception_parameter = _Jv_exception_info ();\n+\t\t     RFF = &LABEL_DECL;\n+\t\t     goto finally;\n+\t\t LABEL_DECL;\n+\t\t CALL_EXPR\n+\t\t   Jv_ReThrow\n+\t\t   exception_parameter */\n+\t  catch_decl = build_decl_no_layout (VAR_DECL, generate_name (),\n+\t\t\t\t\t     ptr_type_node);\n+\t  stmt = build (MODIFY_EXPR, void_type_node, catch_decl,\n+\t\t\tsoft_exceptioninfo_call_node);\n+\t  TREE_SIDE_EFFECTS (stmt) = 1;\n+\t  catch_block = build_expr_block (stmt, NULL_TREE);\n+\t  catch_block = build_jump_to_finally (catch_block, rff, \n+\t\t\t\t\t       FINALLY_EXPR_LABEL (finally), \n+\t\t\t\t\t       void_type_node);\n+\t  stmt = build (CALL_EXPR, void_type_node,\n+\t\t\tbuild_address_of (throw_node),\n+\t\t\tbuild_tree_list (NULL_TREE, catch_decl), NULL_TREE);\n+\t  catch_block = build_expr_block (catch_block, catch_decl);\n+\t  TREE_SIDE_EFFECTS (stmt) = 1;\n+\t  add_stmt_to_block (catch_block, void_type_node, stmt);\n+\n+\t  /* Link the new handler to the existing list as the first\n+\t     entry. It will be the last one to be generated. */\n+\t  catch = build1 (CATCH_EXPR, void_type_node, catch_block);\n+\t  TREE_CHAIN (catch) = catches;\n+\t  catches = catch;\n+\t}\n+    }\n+\n+  node = build (TRY_EXPR, NULL_TREE, try_block, catches, finally);\n+  EXPR_WFL_LINECOL (node) = location;\n+  \n+  /* If we have a finally, surround this whole thing by a block where\n+     the RFF local variable is defined. */\n+\n+  return (finally ? build_expr_block (node, rff) : node);\n+}\n+\n+/* Get the catch clause block from an element of the catch clause\n+   list. If depends on whether a finally clause exists or node (in\n+   which case the original catch clause was surrounded by a\n+   LABELED_BLOCK_EXPR. */\n+\n+tree\n+java_get_catch_block (node, finally_present_p)\n+     tree node;\n+     int finally_present_p;\n+{\n+  return (CATCH_EXPR_GET_EXPR (TREE_OPERAND (node, 0), finally_present_p));\n+}\n+\n+static tree\n+patch_try_statement (node)\n+     tree node;\n+{\n+  int error_found = 0;\n+  tree try = TREE_OPERAND (node, 0);\n+  /* Exception handlers are considered in left to right order */\n+  tree catch = nreverse (TREE_OPERAND (node, 1));\n+  tree finally = TREE_OPERAND (node, 2);\n+  int finally_p = (finally ? 1 : 0);\n+  tree current;\n+\n+  /* Walk the try block */\n+  if ((try = java_complete_tree (try)) == error_mark_node)\n+    error_found = 1;\n+\n+  /* Check catch clauses, if any. Every time we find an error, we try\n+     to process the next catch clause. */\n+  for (current = catch; current; current = TREE_CHAIN (current))\n+    {\n+      tree carg_decl, carg_type;\n+      tree sub_current, catch_block, catch_clause;\n+      int unreachable;\n+\n+      /* Always detect the last catch clause if a finally is\n+         present. This is the catch-all handler and it just needs to\n+         be walked. */\n+      if (!TREE_CHAIN (current) && finally)\n+\t{\n+\t  TREE_OPERAND (current, 0) = \n+\t    java_complete_tree (TREE_OPERAND (current, 0));\n+\t  continue;\n+\t}\n+\n+      /* At this point, the structure of the catch clause is\n+         LABELED_BLOCK_EXPR \t(if we have a finally)\n+\t   CATCH_EXPR\t\t(catch node)\n+\t     BLOCK\t        (with the decl of the parameter)\n+               COMPOUND_EXPR\n+                 MODIFIY_EXPR   (assignemnt of the catch parameter)\n+\t\t BLOCK\t        (catch clause block)\n+           LABEL_DECL\t\t(where to return after finally (if any))\n+\n+\t Since the structure of the catch clause depends on the\n+\t presence of a finally, we use a function call to get to the\n+\t cath clause */\n+      catch_clause = java_get_catch_block (current, finally_p);\n+      carg_decl = BLOCK_EXPR_DECLS (catch_clause);\n+      carg_type = TREE_TYPE (TREE_TYPE (carg_decl));\n+\n+      /* Catch clauses can't have more than one parameter declared,\n+\t but it's already enforced by the grammar. Make sure that the\n+\t only parameter of the clause statement in of class Throwable\n+\t or a subclass of Throwable, but that was done earlier. The\n+\t catch clause parameter type has also been resolved. */\n+      \n+      /* Just make sure that the catch clause parameter type inherits\n+\t from java.lang.Throwable */\n+      if (!inherits_from_p (carg_type, throwable_type_node))\n+\t{\n+\t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (current);\n+\t  parse_error_context (wfl_operator,\n+\t\t\t       \"Can't catch class `%s'. Catch clause \"\n+\t\t\t       \"parameter type must be a subclass of \"\n+\t\t\t       \"class `java.lang.Throwable'\",\n+\t\t\t       lang_printable_name (carg_type));\n+\t  error_found = 1;\n+\t  continue;\n+\t}\n+      \n+      /* Partial check for unreachable catch statement: The catch\n+\t clause is reachable iff is no earlier catch block A in\n+\t the try statement such that the type of the catch\n+\t clause's parameter is the same as or a subclass of the\n+\t type of A's parameter */\n+      unreachable = 0;\n+      for (sub_current = catch;\n+\t   sub_current != current; sub_current = TREE_CHAIN (sub_current))\n+\t{\n+\t  tree sub_catch_clause, decl;\n+\t  sub_catch_clause = java_get_catch_block (sub_current, finally_p);\n+\t  decl = BLOCK_EXPR_DECLS (sub_catch_clause);\n+\n+\t  if (inherits_from_p (carg_type, TREE_TYPE (TREE_TYPE (decl))))\n+\t    {\n+\t      EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (current);\n+\t      parse_error_context \n+\t\t(wfl_operator, \"`catch' not reached because of the catch \"\n+\t\t \"clause at line %d\", EXPR_WFL_LINENO (sub_current));\n+\t      unreachable = error_found = 1;\n+\t      break;\n+\t    }\n+\t}\n+      if (unreachable)\n+\tcontinue;\n+\n+      /* Complete the catch clause block */\n+      catch_block = java_complete_tree (TREE_OPERAND (current, 0));\n+      if (catch_block == error_mark_node)\n+\t{\n+\t  error_found = 1;\n+\t  continue;\n+\t}\n+      TREE_OPERAND (current, 0) = catch_block;\n+    }\n+\n+  /* Process finally */\n+  if (finally)\n+    {\n+      FINALLY_EXPR_BLOCK (finally) = \n+\tjava_complete_tree (FINALLY_EXPR_BLOCK (finally));\n+      if (FINALLY_EXPR_BLOCK (finally) == error_mark_node)\n+\terror_found = 1;\n+    }\n+\n+  /* Verification ends here */\n+  if (error_found) \n+    return error_mark_node;\n+\n+  TREE_OPERAND (node, 0) = try;\n+  TREE_OPERAND (node, 1) = catch;\n+  TREE_OPERAND (node, 2) = finally;\n+  TREE_TYPE (node) = void_type_node;\n+  return node;\n+}"}]}