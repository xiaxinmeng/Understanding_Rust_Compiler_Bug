{"sha": "c9f265c94502ff2a751e9dfb78b718975c0cac0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzlmMjY1Yzk0NTAyZmYyYTc1MWU5ZGZiNzhiNzE4OTc1YzBjYWMwYw==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2015-11-09T04:26:32Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2015-11-09T04:26:32Z"}, "message": "Copy gnulib obstack files\n\nThis copies obstack.[ch] from gnulib, and updates the docs.  The next\npatch should be applied if someone repeats the import at a later date.\n\ninclude/\n\t* obstack.h: Import current gnulib file.\nlibiberty/\n\t* obstack.c: Import current gnulib file.\n\t* obstacks.texi: Updated doc, from glibc's manual/memory.texi.\n\nFrom-SVN: r229987", "tree": {"sha": "83de3b9a9e579175811f6875ec4203a3df8a1b22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83de3b9a9e579175811f6875ec4203a3df8a1b22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9f265c94502ff2a751e9dfb78b718975c0cac0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9f265c94502ff2a751e9dfb78b718975c0cac0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9f265c94502ff2a751e9dfb78b718975c0cac0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9f265c94502ff2a751e9dfb78b718975c0cac0c/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "62c0f0a637378ce3e08280855c78e07f52455d38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62c0f0a637378ce3e08280855c78e07f52455d38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62c0f0a637378ce3e08280855c78e07f52455d38"}], "stats": {"total": 1733, "additions": 794, "deletions": 939}, "files": [{"sha": "e7b137ed24f004ddf2e90c3b23271e60ba43ae6a", "filename": "include/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f265c94502ff2a751e9dfb78b718975c0cac0c/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f265c94502ff2a751e9dfb78b718975c0cac0c/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=c9f265c94502ff2a751e9dfb78b718975c0cac0c", "patch": "@@ -1,3 +1,8 @@\n+2015-11-09  Alan Modra  <amodra@gmail.com>\n+\n+\tPR gdb/17133\n+\t* obstack.h: Import current gnulib file.\n+\n 2015-11-05  Jakub Jelinek  <jakub@redhat.com>\n \t    Ilya Verbin  <ilya.verbin@intel.com>\n "}, {"sha": "0ff33098443053aefb98518ca367d1f217f069ec", "filename": "include/obstack.h", "status": "modified", "additions": 449, "deletions": 461, "changes": 910, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f265c94502ff2a751e9dfb78b718975c0cac0c/include%2Fobstack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f265c94502ff2a751e9dfb78b718975c0cac0c/include%2Fobstack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fobstack.h?ref=c9f265c94502ff2a751e9dfb78b718975c0cac0c", "patch": "@@ -1,543 +1,531 @@\n /* obstack.h - object stack macros\n    Copyright (C) 1988-2015 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n \n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n \n-   NOTE: The canonical source of this file is maintained with the GNU C Library.\n-   Bugs can be reported to bug-glibc@gnu.org.\n-\n-   This program is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by the\n-   Free Software Foundation; either version 2, or (at your option) any\n-   later version.\n-\n-   This program is distributed in the hope that it will be useful,\n+   The GNU C Library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n \n-   You should have received a copy of the GNU General Public License\n-   along with this program; if not, write to the Free Software\n-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,\n-   USA.  */\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n \n /* Summary:\n \n-All the apparent functions defined here are macros. The idea\n-is that you would use these pre-tested macros to solve a\n-very specific set of problems, and they would run fast.\n-Caution: no side-effects in arguments please!! They may be\n-evaluated MANY times!!\n-\n-These macros operate a stack of objects.  Each object starts life\n-small, and may grow to maturity.  (Consider building a word syllable\n-by syllable.)  An object can move while it is growing.  Once it has\n-been \"finished\" it never changes address again.  So the \"top of the\n-stack\" is typically an immature growing object, while the rest of the\n-stack is of mature, fixed size and fixed address objects.\n-\n-These routines grab large chunks of memory, using a function you\n-supply, called `obstack_chunk_alloc'.  On occasion, they free chunks,\n-by calling `obstack_chunk_free'.  You must define them and declare\n-them before using any obstack macros.\n-\n-Each independent stack is represented by a `struct obstack'.\n-Each of the obstack macros expects a pointer to such a structure\n-as the first argument.\n-\n-One motivation for this package is the problem of growing char strings\n-in symbol tables.  Unless you are \"fascist pig with a read-only mind\"\n---Gosper's immortal quote from HAKMEM item 154, out of context--you\n-would not like to put any arbitrary upper limit on the length of your\n-symbols.\n-\n-In practice this often means you will build many short symbols and a\n-few long symbols.  At the time you are reading a symbol you don't know\n-how long it is.  One traditional method is to read a symbol into a\n-buffer, realloc()ating the buffer every time you try to read a symbol\n-that is longer than the buffer.  This is beaut, but you still will\n-want to copy the symbol from the buffer to a more permanent\n-symbol-table entry say about half the time.\n-\n-With obstacks, you can work differently.  Use one obstack for all symbol\n-names.  As you read a symbol, grow the name in the obstack gradually.\n-When the name is complete, finalize it.  Then, if the symbol exists already,\n-free the newly read name.\n-\n-The way we do this is to take a large chunk, allocating memory from\n-low addresses.  When you want to build a symbol in the chunk you just\n-add chars above the current \"high water mark\" in the chunk.  When you\n-have finished adding chars, because you got to the end of the symbol,\n-you know how long the chars are, and you can create a new object.\n-Mostly the chars will not burst over the highest address of the chunk,\n-because you would typically expect a chunk to be (say) 100 times as\n-long as an average object.\n-\n-In case that isn't clear, when we have enough chars to make up\n-the object, THEY ARE ALREADY CONTIGUOUS IN THE CHUNK (guaranteed)\n-so we just point to it where it lies.  No moving of chars is\n-needed and this is the second win: potentially long strings need\n-never be explicitly shuffled. Once an object is formed, it does not\n-change its address during its lifetime.\n-\n-When the chars burst over a chunk boundary, we allocate a larger\n-chunk, and then copy the partly formed object from the end of the old\n-chunk to the beginning of the new larger chunk.  We then carry on\n-accreting characters to the end of the object as we normally would.\n-\n-A special macro is provided to add a single char at a time to a\n-growing object.  This allows the use of register variables, which\n-break the ordinary 'growth' macro.\n-\n-Summary:\n-\tWe allocate large chunks.\n-\tWe carve out one object at a time from the current chunk.\n-\tOnce carved, an object never moves.\n-\tWe are free to append data of any size to the currently\n-\t  growing object.\n-\tExactly one object is growing in an obstack at any one time.\n-\tYou can run one obstack per control block.\n-\tYou may have as many control blocks as you dare.\n-\tBecause of the way we do it, you can `unwind' an obstack\n-\t  back to a previous state. (You may remove objects much\n-\t  as you would with a stack.)\n-*/\n+   All the apparent functions defined here are macros. The idea\n+   is that you would use these pre-tested macros to solve a\n+   very specific set of problems, and they would run fast.\n+   Caution: no side-effects in arguments please!! They may be\n+   evaluated MANY times!!\n+\n+   These macros operate a stack of objects.  Each object starts life\n+   small, and may grow to maturity.  (Consider building a word syllable\n+   by syllable.)  An object can move while it is growing.  Once it has\n+   been \"finished\" it never changes address again.  So the \"top of the\n+   stack\" is typically an immature growing object, while the rest of the\n+   stack is of mature, fixed size and fixed address objects.\n+\n+   These routines grab large chunks of memory, using a function you\n+   supply, called 'obstack_chunk_alloc'.  On occasion, they free chunks,\n+   by calling 'obstack_chunk_free'.  You must define them and declare\n+   them before using any obstack macros.\n+\n+   Each independent stack is represented by a 'struct obstack'.\n+   Each of the obstack macros expects a pointer to such a structure\n+   as the first argument.\n+\n+   One motivation for this package is the problem of growing char strings\n+   in symbol tables.  Unless you are \"fascist pig with a read-only mind\"\n+   --Gosper's immortal quote from HAKMEM item 154, out of context--you\n+   would not like to put any arbitrary upper limit on the length of your\n+   symbols.\n+\n+   In practice this often means you will build many short symbols and a\n+   few long symbols.  At the time you are reading a symbol you don't know\n+   how long it is.  One traditional method is to read a symbol into a\n+   buffer, realloc()ating the buffer every time you try to read a symbol\n+   that is longer than the buffer.  This is beaut, but you still will\n+   want to copy the symbol from the buffer to a more permanent\n+   symbol-table entry say about half the time.\n+\n+   With obstacks, you can work differently.  Use one obstack for all symbol\n+   names.  As you read a symbol, grow the name in the obstack gradually.\n+   When the name is complete, finalize it.  Then, if the symbol exists already,\n+   free the newly read name.\n+\n+   The way we do this is to take a large chunk, allocating memory from\n+   low addresses.  When you want to build a symbol in the chunk you just\n+   add chars above the current \"high water mark\" in the chunk.  When you\n+   have finished adding chars, because you got to the end of the symbol,\n+   you know how long the chars are, and you can create a new object.\n+   Mostly the chars will not burst over the highest address of the chunk,\n+   because you would typically expect a chunk to be (say) 100 times as\n+   long as an average object.\n+\n+   In case that isn't clear, when we have enough chars to make up\n+   the object, THEY ARE ALREADY CONTIGUOUS IN THE CHUNK (guaranteed)\n+   so we just point to it where it lies.  No moving of chars is\n+   needed and this is the second win: potentially long strings need\n+   never be explicitly shuffled. Once an object is formed, it does not\n+   change its address during its lifetime.\n+\n+   When the chars burst over a chunk boundary, we allocate a larger\n+   chunk, and then copy the partly formed object from the end of the old\n+   chunk to the beginning of the new larger chunk.  We then carry on\n+   accreting characters to the end of the object as we normally would.\n+\n+   A special macro is provided to add a single char at a time to a\n+   growing object.  This allows the use of register variables, which\n+   break the ordinary 'growth' macro.\n+\n+   Summary:\n+        We allocate large chunks.\n+        We carve out one object at a time from the current chunk.\n+        Once carved, an object never moves.\n+        We are free to append data of any size to the currently\n+          growing object.\n+        Exactly one object is growing in an obstack at any one time.\n+        You can run one obstack per control block.\n+        You may have as many control blocks as you dare.\n+        Because of the way we do it, you can \"unwind\" an obstack\n+          back to a previous state. (You may remove objects much\n+          as you would with a stack.)\n+ */\n \n \n /* Don't do the contents of this file more than once.  */\n \n #ifndef _OBSTACK_H\n #define _OBSTACK_H 1\n \n-#ifdef __cplusplus\n-extern \"C\" {\n+#ifndef _OBSTACK_INTERFACE_VERSION\n+# define _OBSTACK_INTERFACE_VERSION 2\n #endif\n-\f\n-/* We use subtraction of (char *) 0 instead of casting to int\n-   because on word-addressable machines a simple cast to int\n-   may ignore the byte-within-word field of the pointer.  */\n \n-#ifndef __PTR_TO_INT\n-# define __PTR_TO_INT(P) ((P) - (char *) 0)\n-#endif\n+#include <stddef.h>             /* For size_t and ptrdiff_t.  */\n+#include <string.h>             /* For __GNU_LIBRARY__, and memcpy.  */\n \n-#ifndef __INT_TO_PTR\n-# define __INT_TO_PTR(P) ((P) + (char *) 0)\n+#if _OBSTACK_INTERFACE_VERSION == 1\n+/* For binary compatibility with obstack version 1, which used \"int\"\n+   and \"long\" for these two types.  */\n+# define _OBSTACK_SIZE_T unsigned int\n+# define _CHUNK_SIZE_T unsigned long\n+# define _OBSTACK_CAST(type, expr) ((type) (expr))\n+#else\n+/* Version 2 with sane types, especially for 64-bit hosts.  */\n+# define _OBSTACK_SIZE_T size_t\n+# define _CHUNK_SIZE_T size_t\n+# define _OBSTACK_CAST(type, expr) (expr)\n #endif\n \n-/* We need the type of the resulting object.  If __PTRDIFF_TYPE__ is\n-   defined, as with GNU C, use that; that way we don't pollute the\n-   namespace with <stddef.h>'s symbols.  Otherwise, if <stddef.h> is\n-   available, include it and use ptrdiff_t.  In traditional C, long is\n-   the best that we can do.  */\n+/* If B is the base of an object addressed by P, return the result of\n+   aligning P to the next multiple of A + 1.  B and P must be of type\n+   char *.  A + 1 must be a power of 2.  */\n \n-#ifdef __PTRDIFF_TYPE__\n-# define PTR_INT_TYPE __PTRDIFF_TYPE__\n-#else\n-# ifdef HAVE_STDDEF_H\n-#  include <stddef.h>\n-#  define PTR_INT_TYPE ptrdiff_t\n-# else\n-#  define PTR_INT_TYPE long\n-# endif\n+#define __BPTR_ALIGN(B, P, A) ((B) + (((P) - (B) + (A)) & ~(A)))\n+\n+/* Similar to __BPTR_ALIGN (B, P, A), except optimize the common case\n+   where pointers can be converted to integers, aligned as integers,\n+   and converted back again.  If ptrdiff_t is narrower than a\n+   pointer (e.g., the AS/400), play it safe and compute the alignment\n+   relative to B.  Otherwise, use the faster strategy of computing the\n+   alignment relative to 0.  */\n+\n+#define __PTR_ALIGN(B, P, A)\t\t\t\t\t\t      \\\n+  __BPTR_ALIGN (sizeof (ptrdiff_t) < sizeof (void *) ? (B) : (char *) 0,      \\\n+                P, A)\n+\n+#ifndef __attribute_pure__\n+# define __attribute_pure__ _GL_ATTRIBUTE_PURE\n #endif\n \n-#if defined _LIBC || defined HAVE_STRING_H\n-# include <string.h>\n-# define _obstack_memcpy(To, From, N) memcpy ((To), (From), (N))\n-#else\n-# ifdef memcpy\n-#  define _obstack_memcpy(To, From, N) memcpy ((To), (char *)(From), (N))\n-# else\n-#  define _obstack_memcpy(To, From, N) bcopy ((char *)(From), (To), (N))\n-# endif\n+#ifdef __cplusplus\n+extern \"C\" {\n #endif\n \n-struct _obstack_chunk\t\t/* Lives at front of each chunk. */\n+struct _obstack_chunk           /* Lives at front of each chunk. */\n {\n-  char  *limit;\t\t\t/* 1 past end of this chunk */\n-  struct _obstack_chunk *prev;\t/* address of prior chunk or NULL */\n-  char\tcontents[4];\t\t/* objects begin here */\n+  char *limit;                  /* 1 past end of this chunk */\n+  struct _obstack_chunk *prev;  /* address of prior chunk or NULL */\n+  char contents[4];             /* objects begin here */\n };\n \n-struct obstack\t\t/* control current object in current chunk */\n+struct obstack          /* control current object in current chunk */\n {\n-  long\tchunk_size;\t\t/* preferred size to allocate chunks in */\n-  struct _obstack_chunk *chunk;\t/* address of current struct obstack_chunk */\n-  char\t*object_base;\t\t/* address of object we are building */\n-  char\t*next_free;\t\t/* where to add next char to current object */\n-  char\t*chunk_limit;\t\t/* address of char after current chunk */\n-  PTR_INT_TYPE temp;\t\t/* Temporary for some macros.  */\n-  int   alignment_mask;\t\t/* Mask of alignment for each object. */\n-  /* These prototypes vary based on `use_extra_arg', and we use\n-     casts to the prototypeless function type in all assignments,\n-     but having prototypes here quiets -Wstrict-prototypes.  */\n-  struct _obstack_chunk *(*chunkfun) (void *, long);\n-  void (*freefun) (void *, struct _obstack_chunk *);\n-  void *extra_arg;\t\t/* first arg for chunk alloc/dealloc funcs */\n-  unsigned use_extra_arg:1;\t/* chunk alloc/dealloc funcs take extra arg */\n-  unsigned maybe_empty_object:1;/* There is a possibility that the current\n-\t\t\t\t   chunk contains a zero-length object.  This\n-\t\t\t\t   prevents freeing the chunk if we allocate\n-\t\t\t\t   a bigger chunk to replace it. */\n-  unsigned alloc_failed:1;\t/* No longer used, as we now call the failed\n-\t\t\t\t   handler on error, but retained for binary\n-\t\t\t\t   compatibility.  */\n+  _CHUNK_SIZE_T chunk_size;     /* preferred size to allocate chunks in */\n+  struct _obstack_chunk *chunk; /* address of current struct obstack_chunk */\n+  char *object_base;            /* address of object we are building */\n+  char *next_free;              /* where to add next char to current object */\n+  char *chunk_limit;            /* address of char after current chunk */\n+  union\n+  {\n+    _OBSTACK_SIZE_T i;\n+    void *p;\n+  } temp;                       /* Temporary for some macros.  */\n+  _OBSTACK_SIZE_T alignment_mask;  /* Mask of alignment for each object. */\n+\n+  /* These prototypes vary based on 'use_extra_arg'.  */\n+  union\n+  {\n+    void *(*plain) (size_t);\n+    void *(*extra) (void *, size_t);\n+  } chunkfun;\n+  union\n+  {\n+    void (*plain) (void *);\n+    void (*extra) (void *, void *);\n+  } freefun;\n+\n+  void *extra_arg;              /* first arg for chunk alloc/dealloc funcs */\n+  unsigned use_extra_arg : 1;     /* chunk alloc/dealloc funcs take extra arg */\n+  unsigned maybe_empty_object : 1; /* There is a possibility that the current\n+                                      chunk contains a zero-length object.  This\n+                                      prevents freeing the chunk if we allocate\n+                                      a bigger chunk to replace it. */\n+  unsigned alloc_failed : 1;      /* No longer used, as we now call the failed\n+                                     handler on error, but retained for binary\n+                                     compatibility.  */\n };\n \n /* Declare the external functions we use; they are in obstack.c.  */\n \n-extern void _obstack_newchunk (struct obstack *, int);\n+extern void _obstack_newchunk (struct obstack *, _OBSTACK_SIZE_T);\n extern void _obstack_free (struct obstack *, void *);\n-extern int _obstack_begin (struct obstack *, int, int,\n-\t\t\t    void *(*) (long), void (*) (void *));\n-extern int _obstack_begin_1 (struct obstack *, int, int,\n-\t\t\t     void *(*) (void *, long),\n-\t\t\t     void (*) (void *, void *), void *);\n-extern int _obstack_memory_used (struct obstack *);\n-\f\n-/* Do the function-declarations after the structs\n-   but before defining the macros.  */\n-\n-void obstack_init (struct obstack *obstack);\n-\n-void * obstack_alloc (struct obstack *obstack, int size);\n-\n-void * obstack_copy (struct obstack *obstack, void *address, int size);\n-void * obstack_copy0 (struct obstack *obstack, void *address, int size);\n-\n-void obstack_free (struct obstack *obstack, void *block);\n-\n-void obstack_blank (struct obstack *obstack, int size);\n-\n-void obstack_grow (struct obstack *obstack, void *data, int size);\n-void obstack_grow0 (struct obstack *obstack, void *data, int size);\n-\n-void obstack_1grow (struct obstack *obstack, int data_char);\n-void obstack_ptr_grow (struct obstack *obstack, void *data);\n-void obstack_int_grow (struct obstack *obstack, int data);\n-\n-void * obstack_finish (struct obstack *obstack);\n-\n-int obstack_object_size (struct obstack *obstack);\n-\n-int obstack_room (struct obstack *obstack);\n-void obstack_make_room (struct obstack *obstack, int size);\n-void obstack_1grow_fast (struct obstack *obstack, int data_char);\n-void obstack_ptr_grow_fast (struct obstack *obstack, void *data);\n-void obstack_int_grow_fast (struct obstack *obstack, int data);\n-void obstack_blank_fast (struct obstack *obstack, int size);\n-\n-void * obstack_base (struct obstack *obstack);\n-void * obstack_next_free (struct obstack *obstack);\n-int obstack_alignment_mask (struct obstack *obstack);\n-int obstack_chunk_size (struct obstack *obstack);\n-int obstack_memory_used (struct obstack *obstack);\n-\n-/* Error handler called when `obstack_chunk_alloc' failed to allocate\n-   more memory.  This can be set to a user defined function.  The\n-   default action is to print a message and abort.  */\n+extern int _obstack_begin (struct obstack *,\n+                           _OBSTACK_SIZE_T, _OBSTACK_SIZE_T,\n+                           void *(*) (size_t), void (*) (void *));\n+extern int _obstack_begin_1 (struct obstack *,\n+                             _OBSTACK_SIZE_T, _OBSTACK_SIZE_T,\n+                             void *(*) (void *, size_t),\n+                             void (*) (void *, void *), void *);\n+extern _OBSTACK_SIZE_T _obstack_memory_used (struct obstack *)\n+  __attribute_pure__;\n+\n+\n+/* Error handler called when 'obstack_chunk_alloc' failed to allocate\n+   more memory.  This can be set to a user defined function which\n+   should either abort gracefully or use longjump - but shouldn't\n+   return.  The default action is to print a message and abort.  */\n extern void (*obstack_alloc_failed_handler) (void);\n \n-/* Exit value used when `print_and_abort' is used.  */\n+/* Exit value used when 'print_and_abort' is used.  */\n extern int obstack_exit_failure;\n-\f\n+\n /* Pointer to beginning of object being allocated or to be allocated next.\n    Note that this might not be the final address of the object\n    because a new chunk might be needed to hold the final size.  */\n \n-#define obstack_base(h) ((h)->object_base)\n+#define obstack_base(h) ((void *) (h)->object_base)\n \n /* Size for allocating ordinary chunks.  */\n \n #define obstack_chunk_size(h) ((h)->chunk_size)\n \n /* Pointer to next byte not yet allocated in current chunk.  */\n \n-#define obstack_next_free(h)\t((h)->next_free)\n+#define obstack_next_free(h) ((void *) (h)->next_free)\n \n /* Mask specifying low bits that should be clear in address of an object.  */\n \n #define obstack_alignment_mask(h) ((h)->alignment_mask)\n \n-/* To prevent prototype warnings provide complete argument list in\n-   standard C version.  */\n-# define obstack_init(h) \\\n-  _obstack_begin ((h), 0, 0, \\\n-\t\t  (void *(*) (long)) obstack_chunk_alloc, (void (*) (void *)) obstack_chunk_free)\n+/* To prevent prototype warnings provide complete argument list.  */\n+#define obstack_init(h)\t\t\t\t\t\t\t      \\\n+  _obstack_begin ((h), 0, 0,\t\t\t\t\t\t      \\\n+                  _OBSTACK_CAST (void *(*) (size_t), obstack_chunk_alloc),    \\\n+                  _OBSTACK_CAST (void (*) (void *), obstack_chunk_free))\n \n-# define obstack_begin(h, size) \\\n-  _obstack_begin ((h), (size), 0, \\\n-\t\t  (void *(*) (long)) obstack_chunk_alloc, (void (*) (void *)) obstack_chunk_free)\n+#define obstack_begin(h, size)\t\t\t\t\t\t      \\\n+  _obstack_begin ((h), (size), 0,\t\t\t\t\t      \\\n+                  _OBSTACK_CAST (void *(*) (size_t), obstack_chunk_alloc), \\\n+                  _OBSTACK_CAST (void (*) (void *), obstack_chunk_free))\n \n-# define obstack_specify_allocation(h, size, alignment, chunkfun, freefun) \\\n-  _obstack_begin ((h), (size), (alignment), \\\n-\t\t    (void *(*) (long)) (chunkfun), (void (*) (void *)) (freefun))\n+#define obstack_specify_allocation(h, size, alignment, chunkfun, freefun)     \\\n+  _obstack_begin ((h), (size), (alignment),\t\t\t\t      \\\n+                  _OBSTACK_CAST (void *(*) (size_t), chunkfun),\t\t      \\\n+                  _OBSTACK_CAST (void (*) (void *), freefun))\n \n-# define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \\\n-  _obstack_begin_1 ((h), (size), (alignment), \\\n-\t\t    (void *(*) (void *, long)) (chunkfun), \\\n-\t\t    (void (*) (void *, void *)) (freefun), (arg))\n+#define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \\\n+  _obstack_begin_1 ((h), (size), (alignment),\t\t\t\t      \\\n+                    _OBSTACK_CAST (void *(*) (void *, size_t), chunkfun),     \\\n+                    _OBSTACK_CAST (void (*) (void *, void *), freefun), arg)\n \n-# define obstack_chunkfun(h, newchunkfun) \\\n-  ((h) -> chunkfun = (struct _obstack_chunk *(*)(void *, long)) (newchunkfun))\n+#define obstack_chunkfun(h, newchunkfun)\t\t\t\t      \\\n+  ((void) ((h)->chunkfun.extra = (void *(*) (void *, size_t)) (newchunkfun)))\n \n-# define obstack_freefun(h, newfreefun) \\\n-  ((h) -> freefun = (void (*)(void *, struct _obstack_chunk *)) (newfreefun))\n+#define obstack_freefun(h, newfreefun)\t\t\t\t\t      \\\n+  ((void) ((h)->freefun.extra = (void *(*) (void *, void *)) (newfreefun)))\n \n-#define obstack_1grow_fast(h,achar) (*((h)->next_free)++ = (achar))\n+#define obstack_1grow_fast(h, achar) ((void) (*((h)->next_free)++ = (achar)))\n \n-#define obstack_blank_fast(h,n) ((h)->next_free += (n))\n+#define obstack_blank_fast(h, n) ((void) ((h)->next_free += (n)))\n \n #define obstack_memory_used(h) _obstack_memory_used (h)\n-\f\n-#if defined __GNUC__ && defined __STDC__ && __STDC__\n-/* NextStep 2.0 cc is really gcc 1.93 but it defines __GNUC__ = 2 and\n-   does not implement __extension__.  But that compiler doesn't define\n-   __GNUC_MINOR__.  */\n-# if __GNUC__ < 2 || (__NeXT__ && !__GNUC_MINOR__)\n+\n+#if defined __GNUC__\n+# if !defined __GNUC_MINOR__ || __GNUC__ * 1000 + __GNUC_MINOR__ < 2008\n #  define __extension__\n # endif\n \n /* For GNU C, if not -traditional,\n    we can define these macros to compute all args only once\n    without using a global variable.\n-   Also, we can avoid using the `temp' slot, to make faster code.  */\n-\n-# define obstack_object_size(OBSTACK)\t\t\t\t\t\\\n-  __extension__\t\t\t\t\t\t\t\t\\\n-  ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-     (unsigned) (__o->next_free - __o->object_base); })\n-\n-# define obstack_room(OBSTACK)\t\t\t\t\t\t\\\n-  __extension__\t\t\t\t\t\t\t\t\\\n-  ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-     (unsigned) (__o->chunk_limit - __o->next_free); })\n-\n-# define obstack_make_room(OBSTACK,length)\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-   int __len = (length);\t\t\t\t\t\t\\\n-   if (__o->chunk_limit - __o->next_free < __len)\t\t\t\\\n-     _obstack_newchunk (__o, __len);\t\t\t\t\t\\\n-   (void) 0; })\n-\n-# define obstack_empty_p(OBSTACK)\t\t\t\t\t\\\n-  __extension__\t\t\t\t\t\t\t\t\\\n-  ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-     (__o->chunk->prev == 0 && __o->next_free - __o->chunk->contents == 0); })\n-\n-# define obstack_grow(OBSTACK,where,length)\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-   int __len = (length);\t\t\t\t\t\t\\\n-   if (__o->next_free + __len > __o->chunk_limit)\t\t\t\\\n-     _obstack_newchunk (__o, __len);\t\t\t\t\t\\\n-   _obstack_memcpy (__o->next_free, (where), __len);\t\t\t\\\n-   __o->next_free += __len;\t\t\t\t\t\t\\\n-   (void) 0; })\n-\n-# define obstack_grow0(OBSTACK,where,length)\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-   int __len = (length);\t\t\t\t\t\t\\\n-   if (__o->next_free + __len + 1 > __o->chunk_limit)\t\t\t\\\n-     _obstack_newchunk (__o, __len + 1);\t\t\t\t\\\n-   _obstack_memcpy (__o->next_free, (where), __len);\t\t\t\\\n-   __o->next_free += __len;\t\t\t\t\t\t\\\n-   *(__o->next_free)++ = 0;\t\t\t\t\t\t\\\n-   (void) 0; })\n-\n-# define obstack_1grow(OBSTACK,datum)\t\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-   if (__o->next_free + 1 > __o->chunk_limit)\t\t\t\t\\\n-     _obstack_newchunk (__o, 1);\t\t\t\t\t\\\n-   obstack_1grow_fast (__o, datum);\t\t\t\t\t\\\n-   (void) 0; })\n-\n-/* These assume that the obstack alignment is good enough for pointers or ints,\n-   and that the data added so far to the current object\n+   Also, we can avoid using the 'temp' slot, to make faster code.  */\n+\n+# define obstack_object_size(OBSTACK)\t\t\t\t\t      \\\n+  __extension__\t\t\t\t\t\t\t\t      \\\n+    ({ struct obstack const *__o = (OBSTACK);\t\t\t\t      \\\n+       (_OBSTACK_SIZE_T) (__o->next_free - __o->object_base); })\n+\n+/* The local variable is named __o1 to avoid a shadowed variable\n+   warning when invoked from other obstack macros.  */\n+# define obstack_room(OBSTACK)\t\t\t\t\t\t      \\\n+  __extension__\t\t\t\t\t\t\t\t      \\\n+    ({ struct obstack const *__o1 = (OBSTACK);\t\t\t\t      \\\n+       (_OBSTACK_SIZE_T) (__o1->chunk_limit - __o1->next_free); })\n+\n+# define obstack_make_room(OBSTACK, length)\t\t\t\t      \\\n+  __extension__\t\t\t\t\t\t\t\t      \\\n+    ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t      \\\n+       _OBSTACK_SIZE_T __len = (length);\t\t\t\t      \\\n+       if (obstack_room (__o) < __len)\t\t\t\t\t      \\\n+         _obstack_newchunk (__o, __len);\t\t\t\t      \\\n+       (void) 0; })\n+\n+# define obstack_empty_p(OBSTACK)\t\t\t\t\t      \\\n+  __extension__\t\t\t\t\t\t\t\t      \\\n+    ({ struct obstack const *__o = (OBSTACK);\t\t\t\t      \\\n+       (__o->chunk->prev == 0\t\t\t\t\t\t      \\\n+        && __o->next_free == __PTR_ALIGN ((char *) __o->chunk,\t\t      \\\n+                                          __o->chunk->contents,\t\t      \\\n+                                          __o->alignment_mask)); })\n+\n+# define obstack_grow(OBSTACK, where, length)\t\t\t\t      \\\n+  __extension__\t\t\t\t\t\t\t\t      \\\n+    ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t      \\\n+       _OBSTACK_SIZE_T __len = (length);\t\t\t\t      \\\n+       if (obstack_room (__o) < __len)\t\t\t\t\t      \\\n+         _obstack_newchunk (__o, __len);\t\t\t\t      \\\n+       memcpy (__o->next_free, where, __len);\t\t\t\t      \\\n+       __o->next_free += __len;\t\t\t\t\t\t      \\\n+       (void) 0; })\n+\n+# define obstack_grow0(OBSTACK, where, length)\t\t\t\t      \\\n+  __extension__\t\t\t\t\t\t\t\t      \\\n+    ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t      \\\n+       _OBSTACK_SIZE_T __len = (length);\t\t\t\t      \\\n+       if (obstack_room (__o) < __len + 1)\t\t\t\t      \\\n+         _obstack_newchunk (__o, __len + 1);\t\t\t\t      \\\n+       memcpy (__o->next_free, where, __len);\t\t\t\t      \\\n+       __o->next_free += __len;\t\t\t\t\t\t      \\\n+       *(__o->next_free)++ = 0;\t\t\t\t\t\t      \\\n+       (void) 0; })\n+\n+# define obstack_1grow(OBSTACK, datum)\t\t\t\t\t      \\\n+  __extension__\t\t\t\t\t\t\t\t      \\\n+    ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t      \\\n+       if (obstack_room (__o) < 1)\t\t\t\t\t      \\\n+         _obstack_newchunk (__o, 1);\t\t\t\t\t      \\\n+       obstack_1grow_fast (__o, datum); })\n+\n+/* These assume that the obstack alignment is good enough for pointers\n+   or ints, and that the data added so far to the current object\n    shares that much alignment.  */\n \n-# define obstack_ptr_grow(OBSTACK,datum)\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-   if (__o->next_free + sizeof (void *) > __o->chunk_limit)\t\t\\\n-     _obstack_newchunk (__o, sizeof (void *));\t\t\t\t\\\n-   obstack_ptr_grow_fast (__o, datum); })\n-\n-# define obstack_int_grow(OBSTACK,datum)\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-   if (__o->next_free + sizeof (int) > __o->chunk_limit)\t\t\\\n-     _obstack_newchunk (__o, sizeof (int));\t\t\t\t\\\n-   obstack_int_grow_fast (__o, datum); })\n-\n-# define obstack_ptr_grow_fast(OBSTACK,aptr)\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__o1 = (OBSTACK);\t\t\t\t\t\\\n-   *(const void **) __o1->next_free = (aptr);\t\t\t\t\\\n-   __o1->next_free += sizeof (const void *);\t\t\t\t\\\n-   (void) 0; })\n-\n-# define obstack_int_grow_fast(OBSTACK,aint)\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__o1 = (OBSTACK);\t\t\t\t\t\\\n-   *(int *) __o1->next_free = (aint);\t\t\t\t\t\\\n-   __o1->next_free += sizeof (int);\t\t\t\t\t\\\n-   (void) 0; })\n-\n-# define obstack_blank(OBSTACK,length)\t\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-   int __len = (length);\t\t\t\t\t\t\\\n-   if (__o->chunk_limit - __o->next_free < __len)\t\t\t\\\n-     _obstack_newchunk (__o, __len);\t\t\t\t\t\\\n-   obstack_blank_fast (__o, __len);\t\t\t\t\t\\\n-   (void) 0; })\n-\n-# define obstack_alloc(OBSTACK,length)\t\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__h = (OBSTACK);\t\t\t\t\t\\\n-   obstack_blank (__h, (length));\t\t\t\t\t\\\n-   obstack_finish (__h); })\n-\n-# define obstack_copy(OBSTACK,where,length)\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__h = (OBSTACK);\t\t\t\t\t\\\n-   obstack_grow (__h, (where), (length));\t\t\t\t\\\n-   obstack_finish (__h); })\n-\n-# define obstack_copy0(OBSTACK,where,length)\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__h = (OBSTACK);\t\t\t\t\t\\\n-   obstack_grow0 (__h, (where), (length));\t\t\t\t\\\n-   obstack_finish (__h); })\n-\n-/* The local variable is named __o1 to avoid a name conflict\n-   when obstack_blank is called.  */\n-# define obstack_finish(OBSTACK)  \t\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__o1 = (OBSTACK);\t\t\t\t\t\\\n-   void *value;\t\t\t\t\t\t\t\t\\\n-   value = (void *) __o1->object_base;\t\t\t\t\t\\\n-   if (__o1->next_free == value)\t\t\t\t\t\\\n-     __o1->maybe_empty_object = 1;\t\t\t\t\t\\\n-   __o1->next_free\t\t\t\t\t\t\t\\\n-     = __INT_TO_PTR ((__PTR_TO_INT (__o1->next_free)+__o1->alignment_mask)\\\n-\t\t     & ~ (__o1->alignment_mask));\t\t\t\\\n-   if (__o1->next_free - (char *)__o1->chunk\t\t\t\t\\\n-       > __o1->chunk_limit - (char *)__o1->chunk)\t\t\t\\\n-     __o1->next_free = __o1->chunk_limit;\t\t\t\t\\\n-   __o1->object_base = __o1->next_free;\t\t\t\t\t\\\n-   value; })\n-\n-# define obstack_free(OBSTACK, OBJ)\t\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-   void *__obj = (void *) (OBJ);\t\t\t\t\t\\\n-   if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit)  \\\n-     __o->next_free = __o->object_base = (char *) __obj;\t\t\\\n-   else (obstack_free) (__o, __obj); })\n-\f\n-#else /* not __GNUC__ or not __STDC__ */\n-\n-# define obstack_object_size(h) \\\n- (unsigned) ((h)->next_free - (h)->object_base)\n-\n-# define obstack_room(h)\t\t\\\n- (unsigned) ((h)->chunk_limit - (h)->next_free)\n-\n-# define obstack_empty_p(h) \\\n- ((h)->chunk->prev == 0 && (h)->next_free - (h)->chunk->contents == 0)\n+# define obstack_ptr_grow(OBSTACK, datum)\t\t\t\t      \\\n+  __extension__\t\t\t\t\t\t\t\t      \\\n+    ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t      \\\n+       if (obstack_room (__o) < sizeof (void *))\t\t\t      \\\n+         _obstack_newchunk (__o, sizeof (void *));\t\t\t      \\\n+       obstack_ptr_grow_fast (__o, datum); })\n+\n+# define obstack_int_grow(OBSTACK, datum)\t\t\t\t      \\\n+  __extension__\t\t\t\t\t\t\t\t      \\\n+    ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t      \\\n+       if (obstack_room (__o) < sizeof (int))\t\t\t\t      \\\n+         _obstack_newchunk (__o, sizeof (int));\t\t\t\t      \\\n+       obstack_int_grow_fast (__o, datum); })\n+\n+# define obstack_ptr_grow_fast(OBSTACK, aptr)\t\t\t\t      \\\n+  __extension__\t\t\t\t\t\t\t\t      \\\n+    ({ struct obstack *__o1 = (OBSTACK);\t\t\t\t      \\\n+       void *__p1 = __o1->next_free;\t\t\t\t\t      \\\n+       *(const void **) __p1 = (aptr);\t\t\t\t\t      \\\n+       __o1->next_free += sizeof (const void *);\t\t\t      \\\n+       (void) 0; })\n+\n+# define obstack_int_grow_fast(OBSTACK, aint)\t\t\t\t      \\\n+  __extension__\t\t\t\t\t\t\t\t      \\\n+    ({ struct obstack *__o1 = (OBSTACK);\t\t\t\t      \\\n+       void *__p1 = __o1->next_free;\t\t\t\t\t      \\\n+       *(int *) __p1 = (aint);\t\t\t\t\t\t      \\\n+       __o1->next_free += sizeof (int);\t\t\t\t\t      \\\n+       (void) 0; })\n+\n+# define obstack_blank(OBSTACK, length)\t\t\t\t\t      \\\n+  __extension__\t\t\t\t\t\t\t\t      \\\n+    ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t      \\\n+       _OBSTACK_SIZE_T __len = (length);\t\t\t\t      \\\n+       if (obstack_room (__o) < __len)\t\t\t\t\t      \\\n+         _obstack_newchunk (__o, __len);\t\t\t\t      \\\n+       obstack_blank_fast (__o, __len); })\n+\n+# define obstack_alloc(OBSTACK, length)\t\t\t\t\t      \\\n+  __extension__\t\t\t\t\t\t\t\t      \\\n+    ({ struct obstack *__h = (OBSTACK);\t\t\t\t\t      \\\n+       obstack_blank (__h, (length));\t\t\t\t\t      \\\n+       obstack_finish (__h); })\n+\n+# define obstack_copy(OBSTACK, where, length)\t\t\t\t      \\\n+  __extension__\t\t\t\t\t\t\t\t      \\\n+    ({ struct obstack *__h = (OBSTACK);\t\t\t\t\t      \\\n+       obstack_grow (__h, (where), (length));\t\t\t\t      \\\n+       obstack_finish (__h); })\n+\n+# define obstack_copy0(OBSTACK, where, length)\t\t\t\t      \\\n+  __extension__\t\t\t\t\t\t\t\t      \\\n+    ({ struct obstack *__h = (OBSTACK);\t\t\t\t\t      \\\n+       obstack_grow0 (__h, (where), (length));\t\t\t\t      \\\n+       obstack_finish (__h); })\n+\n+/* The local variable is named __o1 to avoid a shadowed variable\n+   warning when invoked from other obstack macros, typically obstack_free.  */\n+# define obstack_finish(OBSTACK)\t\t\t\t\t      \\\n+  __extension__\t\t\t\t\t\t\t\t      \\\n+    ({ struct obstack *__o1 = (OBSTACK);\t\t\t\t      \\\n+       void *__value = (void *) __o1->object_base;\t\t\t      \\\n+       if (__o1->next_free == __value)\t\t\t\t\t      \\\n+         __o1->maybe_empty_object = 1;\t\t\t\t\t      \\\n+       __o1->next_free\t\t\t\t\t\t\t      \\\n+         = __PTR_ALIGN (__o1->object_base, __o1->next_free,\t\t      \\\n+                        __o1->alignment_mask);\t\t\t\t      \\\n+       if ((size_t) (__o1->next_free - (char *) __o1->chunk)\t\t      \\\n+           > (size_t) (__o1->chunk_limit - (char *) __o1->chunk))\t      \\\n+         __o1->next_free = __o1->chunk_limit;\t\t\t\t      \\\n+       __o1->object_base = __o1->next_free;\t\t\t\t      \\\n+       __value; })\n+\n+# define obstack_free(OBSTACK, OBJ)\t\t\t\t\t      \\\n+  __extension__\t\t\t\t\t\t\t\t      \\\n+    ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t      \\\n+       void *__obj = (void *) (OBJ);\t\t\t\t\t      \\\n+       if (__obj > (void *) __o->chunk && __obj < (void *) __o->chunk_limit)  \\\n+         __o->next_free = __o->object_base = (char *) __obj;\t\t      \\\n+       else\t\t\t\t\t\t\t\t      \\\n+         _obstack_free (__o, __obj); })\n+\n+#else /* not __GNUC__ */\n+\n+# define obstack_object_size(h)\t\t\t\t\t\t      \\\n+  ((_OBSTACK_SIZE_T) ((h)->next_free - (h)->object_base))\n+\n+# define obstack_room(h)\t\t\t\t\t\t      \\\n+  ((_OBSTACK_SIZE_T) ((h)->chunk_limit - (h)->next_free))\n+\n+# define obstack_empty_p(h)\t\t\t\t\t\t      \\\n+  ((h)->chunk->prev == 0\t\t\t\t\t\t      \\\n+   && (h)->next_free == __PTR_ALIGN ((char *) (h)->chunk,\t\t      \\\n+                                     (h)->chunk->contents,\t\t      \\\n+                                     (h)->alignment_mask))\n \n /* Note that the call to _obstack_newchunk is enclosed in (..., 0)\n    so that we can avoid having void expressions\n    in the arms of the conditional expression.\n    Casting the third operand to void was tried before,\n    but some compilers won't accept it.  */\n \n-# define obstack_make_room(h,length)\t\t\t\t\t\\\n-( (h)->temp = (length),\t\t\t\t\t\t\t\\\n-  (((h)->next_free + (h)->temp > (h)->chunk_limit)\t\t\t\\\n-   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0))\n-\n-# define obstack_grow(h,where,length)\t\t\t\t\t\\\n-( (h)->temp = (length),\t\t\t\t\t\t\t\\\n-  (((h)->next_free + (h)->temp > (h)->chunk_limit)\t\t\t\\\n-   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),\t\t\t\\\n-  _obstack_memcpy ((h)->next_free, (where), (h)->temp),\t\t\t\\\n-  (h)->next_free += (h)->temp)\n-\n-# define obstack_grow0(h,where,length)\t\t\t\t\t\\\n-( (h)->temp = (length),\t\t\t\t\t\t\t\\\n-  (((h)->next_free + (h)->temp + 1 > (h)->chunk_limit)\t\t\t\\\n-   ? (_obstack_newchunk ((h), (h)->temp + 1), 0) : 0),\t\t\t\\\n-  _obstack_memcpy ((h)->next_free, (where), (h)->temp),\t\t\t\\\n-  (h)->next_free += (h)->temp,\t\t\t\t\t\t\\\n-  *((h)->next_free)++ = 0)\n-\n-# define obstack_1grow(h,datum)\t\t\t\t\t\t\\\n-( (((h)->next_free + 1 > (h)->chunk_limit)\t\t\t\t\\\n-   ? (_obstack_newchunk ((h), 1), 0) : 0),\t\t\t\t\\\n-  obstack_1grow_fast (h, datum))\n-\n-# define obstack_ptr_grow(h,datum)\t\t\t\t\t\\\n-( (((h)->next_free + sizeof (char *) > (h)->chunk_limit)\t\t\\\n-   ? (_obstack_newchunk ((h), sizeof (char *)), 0) : 0),\t\t\\\n-  obstack_ptr_grow_fast (h, datum))\n-\n-# define obstack_int_grow(h,datum)\t\t\t\t\t\\\n-( (((h)->next_free + sizeof (int) > (h)->chunk_limit)\t\t\t\\\n-   ? (_obstack_newchunk ((h), sizeof (int)), 0) : 0),\t\t\t\\\n-  obstack_int_grow_fast (h, datum))\n-\n-# define obstack_ptr_grow_fast(h,aptr)\t\t\t\t\t\\\n-  (((const void **) ((h)->next_free += sizeof (void *)))[-1] = (aptr))\n-\n-# define obstack_int_grow_fast(h,aint)\t\t\t\t\t\\\n-  (((int *) ((h)->next_free += sizeof (int)))[-1] = (aptr))\n-\n-# define obstack_blank(h,length)\t\t\t\t\t\\\n-( (h)->temp = (length),\t\t\t\t\t\t\t\\\n-  (((h)->chunk_limit - (h)->next_free < (h)->temp)\t\t\t\\\n-   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),\t\t\t\\\n-  obstack_blank_fast (h, (h)->temp))\n-\n-# define obstack_alloc(h,length)\t\t\t\t\t\\\n- (obstack_blank ((h), (length)), obstack_finish ((h)))\n-\n-# define obstack_copy(h,where,length)\t\t\t\t\t\\\n- (obstack_grow ((h), (where), (length)), obstack_finish ((h)))\n-\n-# define obstack_copy0(h,where,length)\t\t\t\t\t\\\n- (obstack_grow0 ((h), (where), (length)), obstack_finish ((h)))\n-\n-# define obstack_finish(h)  \t\t\t\t\t\t\\\n-( ((h)->next_free == (h)->object_base\t\t\t\t\t\\\n-   ? (((h)->maybe_empty_object = 1), 0)\t\t\t\t\t\\\n-   : 0),\t\t\t\t\t\t\t\t\\\n-  (h)->temp = __PTR_TO_INT ((h)->object_base),\t\t\t\t\\\n-  (h)->next_free\t\t\t\t\t\t\t\\\n-    = __INT_TO_PTR ((__PTR_TO_INT ((h)->next_free)+(h)->alignment_mask)\t\\\n-\t\t    & ~ ((h)->alignment_mask)),\t\t\t\t\\\n-  (((h)->next_free - (char *) (h)->chunk\t\t\t\t\\\n-    > (h)->chunk_limit - (char *) (h)->chunk)\t\t\t\t\\\n-   ? ((h)->next_free = (h)->chunk_limit) : 0),\t\t\t\t\\\n-  (h)->object_base = (h)->next_free,\t\t\t\t\t\\\n-  (void *) __INT_TO_PTR ((h)->temp))\n-\n-# define obstack_free(h,obj)\t\t\t\t\t\t\\\n-( (h)->temp = (char *) (obj) - (char *) (h)->chunk,\t\t\t\\\n-  (((h)->temp > 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\\\n-   ? (((h)->next_free = (h)->object_base\t\t\t\t\\\n-\t    = (h)->temp + (char *) (h)->chunk), 0)\t\t\t\\\n-   : ((obstack_free) ((h), (h)->temp + (char *) (h)->chunk), 0)))\n-\n-#endif /* not __GNUC__ or not __STDC__ */\n+# define obstack_make_room(h, length)\t\t\t\t\t      \\\n+  ((h)->temp.i = (length),\t\t\t\t\t\t      \\\n+   ((obstack_room (h) < (h)->temp.i)\t\t\t\t\t      \\\n+    ? (_obstack_newchunk (h, (h)->temp.i), 0) : 0),\t\t\t      \\\n+   (void) 0)\n+\n+# define obstack_grow(h, where, length)\t\t\t\t\t      \\\n+  ((h)->temp.i = (length),\t\t\t\t\t\t      \\\n+   ((obstack_room (h) < (h)->temp.i)\t\t\t\t\t      \\\n+   ? (_obstack_newchunk ((h), (h)->temp.i), 0) : 0),\t\t\t      \\\n+   memcpy ((h)->next_free, where, (h)->temp.i),\t\t\t\t      \\\n+   (h)->next_free += (h)->temp.i,\t\t\t\t\t      \\\n+   (void) 0)\n+\n+# define obstack_grow0(h, where, length)\t\t\t\t      \\\n+  ((h)->temp.i = (length),\t\t\t\t\t\t      \\\n+   ((obstack_room (h) < (h)->temp.i + 1)\t\t\t\t      \\\n+   ? (_obstack_newchunk ((h), (h)->temp.i + 1), 0) : 0),\t\t      \\\n+   memcpy ((h)->next_free, where, (h)->temp.i),\t\t\t\t      \\\n+   (h)->next_free += (h)->temp.i,\t\t\t\t\t      \\\n+   *((h)->next_free)++ = 0,\t\t\t\t\t\t      \\\n+   (void) 0)\n+\n+# define obstack_1grow(h, datum)\t\t\t\t\t      \\\n+  (((obstack_room (h) < 1)\t\t\t\t\t\t      \\\n+    ? (_obstack_newchunk ((h), 1), 0) : 0),\t\t\t\t      \\\n+   obstack_1grow_fast (h, datum))\n+\n+# define obstack_ptr_grow(h, datum)\t\t\t\t\t      \\\n+  (((obstack_room (h) < sizeof (char *))\t\t\t\t      \\\n+    ? (_obstack_newchunk ((h), sizeof (char *)), 0) : 0),\t\t      \\\n+   obstack_ptr_grow_fast (h, datum))\n+\n+# define obstack_int_grow(h, datum)\t\t\t\t\t      \\\n+  (((obstack_room (h) < sizeof (int))\t\t\t\t\t      \\\n+    ? (_obstack_newchunk ((h), sizeof (int)), 0) : 0),\t\t\t      \\\n+   obstack_int_grow_fast (h, datum))\n+\n+# define obstack_ptr_grow_fast(h, aptr)\t\t\t\t\t      \\\n+  (((const void **) ((h)->next_free += sizeof (void *)))[-1] = (aptr),\t      \\\n+   (void) 0)\n+\n+# define obstack_int_grow_fast(h, aint)\t\t\t\t\t      \\\n+  (((int *) ((h)->next_free += sizeof (int)))[-1] = (aint),\t\t      \\\n+   (void) 0)\n+\n+# define obstack_blank(h, length)\t\t\t\t\t      \\\n+  ((h)->temp.i = (length),\t\t\t\t\t\t      \\\n+   ((obstack_room (h) < (h)->temp.i)\t\t\t\t\t      \\\n+   ? (_obstack_newchunk ((h), (h)->temp.i), 0) : 0),\t\t\t      \\\n+   obstack_blank_fast (h, (h)->temp.i))\n+\n+# define obstack_alloc(h, length)\t\t\t\t\t      \\\n+  (obstack_blank ((h), (length)), obstack_finish ((h)))\n+\n+# define obstack_copy(h, where, length)\t\t\t\t\t      \\\n+  (obstack_grow ((h), (where), (length)), obstack_finish ((h)))\n+\n+# define obstack_copy0(h, where, length)\t\t\t\t      \\\n+  (obstack_grow0 ((h), (where), (length)), obstack_finish ((h)))\n+\n+# define obstack_finish(h)\t\t\t\t\t\t      \\\n+  (((h)->next_free == (h)->object_base\t\t\t\t\t      \\\n+    ? (((h)->maybe_empty_object = 1), 0)\t\t\t\t      \\\n+    : 0),\t\t\t\t\t\t\t\t      \\\n+   (h)->temp.p = (h)->object_base,\t\t\t\t\t      \\\n+   (h)->next_free\t\t\t\t\t\t\t      \\\n+     = __PTR_ALIGN ((h)->object_base, (h)->next_free,\t\t\t      \\\n+                    (h)->alignment_mask),\t\t\t\t      \\\n+   (((size_t) ((h)->next_free - (char *) (h)->chunk)\t\t\t      \\\n+     > (size_t) ((h)->chunk_limit - (char *) (h)->chunk))\t\t      \\\n+   ? ((h)->next_free = (h)->chunk_limit) : 0),\t\t\t\t      \\\n+   (h)->object_base = (h)->next_free,\t\t\t\t\t      \\\n+   (h)->temp.p)\n+\n+# define obstack_free(h, obj)\t\t\t\t\t\t      \\\n+  ((h)->temp.p = (void *) (obj),\t\t\t\t\t      \\\n+   (((h)->temp.p > (void *) (h)->chunk\t\t\t\t\t      \\\n+     && (h)->temp.p < (void *) (h)->chunk_limit)\t\t\t      \\\n+    ? (void) ((h)->next_free = (h)->object_base = (char *) (h)->temp.p)       \\\n+    : _obstack_free ((h), (h)->temp.p)))\n+\n+#endif /* not __GNUC__ */\n \n #ifdef __cplusplus\n-}\t/* C++ */\n+}       /* C++ */\n #endif\n \n-#endif /* obstack.h */\n+#endif /* _OBSTACK_H */"}, {"sha": "03f9d8d82a246726b1d2e70f68c5bae39f654c28", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f265c94502ff2a751e9dfb78b718975c0cac0c/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f265c94502ff2a751e9dfb78b718975c0cac0c/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=c9f265c94502ff2a751e9dfb78b718975c0cac0c", "patch": "@@ -1,3 +1,9 @@\n+2015-11-09  Alan Modra  <amodra@gmail.com>\n+\n+\tPR gdb/17133\n+\t* obstack.c: Import current gnulib file.\n+\t* obstacks.texi: Updated doc, from glibc's manual/memory.texi.\n+\n 2015-11-06  Joel Brobecker  <brobecker@adacore.com>\n \n \t* configure.ac: Set AC_CV_FUNC_GETPAGESIZE to \"yes\" on"}, {"sha": "3b99dfadef67012940d72f454a1a38727751f064", "filename": "libiberty/obstack.c", "status": "modified", "additions": 195, "deletions": 352, "changes": 547, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f265c94502ff2a751e9dfb78b718975c0cac0c/libiberty%2Fobstack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f265c94502ff2a751e9dfb78b718975c0cac0c/libiberty%2Fobstack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fobstack.c?ref=c9f265c94502ff2a751e9dfb78b718975c0cac0c", "patch": "@@ -1,180 +1,144 @@\n /* obstack.c - subroutines used implicitly by object stack macros\n-   Copyright (C) 1988,89,90,91,92,93,94,96,97 Free Software Foundation, Inc.\n+   Copyright (C) 1988-2015 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n \n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n \n-   NOTE: This source is derived from an old version taken from the GNU C\n-   Library (glibc).\n-\n-   This program is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by the\n-   Free Software Foundation; either version 2, or (at your option) any\n-   later version.\n-\n-   This program is distributed in the hope that it will be useful,\n+   The GNU C Library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n \n-   You should have received a copy of the GNU General Public License\n-   along with this program; if not, write to the Free Software\n-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,\n-   USA.  */\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n \n-#ifdef HAVE_CONFIG_H\n-#include <config.h>\n-#endif\n \n-#include \"obstack.h\"\n+#ifdef _LIBC\n+# include <obstack.h>\n+#else\n+# include <config.h>\n+# include \"obstack.h\"\n+#endif\n \n-/* NOTE BEFORE MODIFYING THIS FILE: This version number must be\n-   incremented whenever callers compiled using an old obstack.h can no\n-   longer properly call the functions in this obstack.c.  */\n-#define OBSTACK_INTERFACE_VERSION 1\n+/* NOTE BEFORE MODIFYING THIS FILE: _OBSTACK_INTERFACE_VERSION in\n+   obstack.h must be incremented whenever callers compiled using an old\n+   obstack.h can no longer properly call the functions in this file.  */\n \n /* Comment out all this code if we are using the GNU C Library, and are not\n    actually compiling the library itself, and the installed library\n    supports the same library interface we do.  This code is part of the GNU\n    C Library, but also included in many other GNU distributions.  Compiling\n    and linking in this code is a waste when using the GNU C library\n    (especially if it is a shared library).  Rather than having every GNU\n-   program understand `configure --with-gnu-libc' and omit the object\n+   program understand 'configure --with-gnu-libc' and omit the object\n    files, it is simpler to just do this in the source for each such file.  */\n-\n-#include <stdio.h>\t\t/* Random thing to get __GNU_LIBRARY__.  */\n-#if !defined (_LIBC) && defined (__GNU_LIBRARY__) && __GNU_LIBRARY__ > 1\n-#include <gnu-versions.h>\n-#if _GNU_OBSTACK_INTERFACE_VERSION == OBSTACK_INTERFACE_VERSION\n-#define ELIDE_CODE\n-#endif\n+#if !defined _LIBC && defined __GNU_LIBRARY__ && __GNU_LIBRARY__ > 1\n+# include <gnu-versions.h>\n+# if (_GNU_OBSTACK_INTERFACE_VERSION == _OBSTACK_INTERFACE_VERSION\t      \\\n+      || (_GNU_OBSTACK_INTERFACE_VERSION == 1\t\t\t\t      \\\n+          && _OBSTACK_INTERFACE_VERSION == 2\t\t\t\t      \\\n+          && defined SIZEOF_INT && defined SIZEOF_SIZE_T\t\t      \\\n+          && SIZEOF_INT == SIZEOF_SIZE_T))\n+#  define _OBSTACK_ELIDE_CODE\n+# endif\n #endif\n \n+#ifndef _OBSTACK_ELIDE_CODE\n+/* If GCC, or if an oddball (testing?) host that #defines __alignof__,\n+   use the already-supplied __alignof__.  Otherwise, this must be Gnulib\n+   (as glibc assumes GCC); defer to Gnulib's alignof_type.  */\n+# if !defined __GNUC__ && !defined __alignof__\n+#  include <alignof.h>\n+#  define __alignof__(type) alignof_type (type)\n+# endif\n+# include <stdlib.h>\n+# include <stdint.h>\n \n-#ifndef ELIDE_CODE\n-\n-\n-#define POINTER void *\n+# ifndef MAX\n+#  define MAX(a,b) ((a) > (b) ? (a) : (b))\n+# endif\n \n /* Determine default alignment.  */\n-struct fooalign {char x; double d;};\n-#define DEFAULT_ALIGNMENT  \\\n-  ((PTR_INT_TYPE) ((char *) &((struct fooalign *) 0)->d - (char *) 0))\n+\n /* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.\n    But in fact it might be less smart and round addresses to as much as\n-   DEFAULT_ROUNDING.  So we prepare for it to do that.  */\n-union fooround {long x; double d;};\n-#define DEFAULT_ROUNDING (sizeof (union fooround))\n-\n-/* When we copy a long block of data, this is the unit to do it with.\n-   On some machines, copying successive ints does not work;\n-   in such a case, redefine COPYING_UNIT to `long' (if that works)\n-   or `char' as a last resort.  */\n-#ifndef COPYING_UNIT\n-#define COPYING_UNIT int\n-#endif\n-\n-\n-/* The functions allocating more room by calling `obstack_chunk_alloc'\n-   jump to the handler pointed to by `obstack_alloc_failed_handler'.\n-   This variable by default points to the internal function\n-   `print_and_abort'.  */\n-static void print_and_abort (void);\n-void (*obstack_alloc_failed_handler) (void) = print_and_abort;\n+   DEFAULT_ROUNDING.  So we prepare for it to do that.\n+\n+   DEFAULT_ALIGNMENT cannot be an enum constant; see gnulib's alignof.h.  */\n+#define DEFAULT_ALIGNMENT MAX (__alignof__ (long double),\t\t      \\\n+                               MAX (__alignof__ (uintmax_t),\t\t      \\\n+                                    __alignof__ (void *)))\n+#define DEFAULT_ROUNDING MAX (sizeof (long double),\t\t\t      \\\n+                               MAX (sizeof (uintmax_t),\t\t\t      \\\n+                                    sizeof (void *)))\n+\n+/* Call functions with either the traditional malloc/free calling\n+   interface, or the mmalloc/mfree interface (that adds an extra first\n+   argument), based on the value of use_extra_arg.  */\n+\n+static void *\n+call_chunkfun (struct obstack *h, size_t size)\n+{\n+  if (h->use_extra_arg)\n+    return h->chunkfun.extra (h->extra_arg, size);\n+  else\n+    return h->chunkfun.plain (size);\n+}\n \n-/* Exit value used when `print_and_abort' is used.  */\n-#if defined __GNU_LIBRARY__ || defined HAVE_STDLIB_H\n-#include <stdlib.h>\n-#endif\n-#ifndef EXIT_FAILURE\n-#define EXIT_FAILURE 1\n-#endif\n-int obstack_exit_failure = EXIT_FAILURE;\n+static void\n+call_freefun (struct obstack *h, void *old_chunk)\n+{\n+  if (h->use_extra_arg)\n+    h->freefun.extra (h->extra_arg, old_chunk);\n+  else\n+    h->freefun.plain (old_chunk);\n+}\n \n-/* The non-GNU-C macros copy the obstack into this global variable\n-   to avoid multiple evaluation.  */\n-\n-struct obstack *_obstack;\n-\n-/* Define a macro that either calls functions with the traditional malloc/free\n-   calling interface, or calls functions with the mmalloc/mfree interface\n-   (that adds an extra first argument), based on the state of use_extra_arg.\n-   For free, do not use ?:, since some compilers, like the MIPS compilers,\n-   do not allow (expr) ? void : void.  */\n-\n-#if defined (__STDC__) && __STDC__\n-#define CALL_CHUNKFUN(h, size) \\\n-  (((h) -> use_extra_arg) \\\n-   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \\\n-   : (*(struct _obstack_chunk *(*) (long)) (h)->chunkfun) ((size)))\n-\n-#define CALL_FREEFUN(h, old_chunk) \\\n-  do { \\\n-    if ((h) -> use_extra_arg) \\\n-      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \\\n-    else \\\n-      (*(void (*) (void *)) (h)->freefun) ((old_chunk)); \\\n-  } while (0)\n-#else\n-#define CALL_CHUNKFUN(h, size) \\\n-  (((h) -> use_extra_arg) \\\n-   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \\\n-   : (*(struct _obstack_chunk *(*) ()) (h)->chunkfun) ((size)))\n-\n-#define CALL_FREEFUN(h, old_chunk) \\\n-  do { \\\n-    if ((h) -> use_extra_arg) \\\n-      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \\\n-    else \\\n-      (*(void (*) ()) (h)->freefun) ((old_chunk)); \\\n-  } while (0)\n-#endif\n \n-\f\n /* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).\n    Objects start on multiples of ALIGNMENT (0 means use default).\n-   CHUNKFUN is the function to use to allocate chunks,\n-   and FREEFUN the function to free them.\n \n-   Return nonzero if successful, zero if out of memory.\n-   To recover from an out of memory error,\n-   free up some memory, then call this again.  */\n+   Return nonzero if successful, calls obstack_alloc_failed_handler if\n+   allocation fails.  */\n \n-int\n-_obstack_begin (struct obstack *h, int size, int alignment,\n-                POINTER (*chunkfun) (long), void (*freefun) (void *))\n+static int\n+_obstack_begin_worker (struct obstack *h,\n+                       _OBSTACK_SIZE_T size, _OBSTACK_SIZE_T alignment)\n {\n-  register struct _obstack_chunk *chunk; /* points to new chunk */\n+  struct _obstack_chunk *chunk; /* points to new chunk */\n \n   if (alignment == 0)\n-    alignment = (int) DEFAULT_ALIGNMENT;\n+    alignment = DEFAULT_ALIGNMENT;\n   if (size == 0)\n     /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n     {\n       /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.\n-\t Use the values for range checking, because if range checking is off,\n-\t the extra bytes won't be missed terribly, but if range checking is on\n-\t and we used a larger request, a whole extra 4096 bytes would be\n-\t allocated.\n+         Use the values for range checking, because if range checking is off,\n+         the extra bytes won't be missed terribly, but if range checking is on\n+         and we used a larger request, a whole extra 4096 bytes would be\n+         allocated.\n \n-\t These number are irrelevant to the new GNU malloc.  I suspect it is\n-\t less sensitive to the size of the request.  */\n+         These number are irrelevant to the new GNU malloc.  I suspect it is\n+         less sensitive to the size of the request.  */\n       int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))\n-\t\t    + 4 + DEFAULT_ROUNDING - 1)\n-\t\t   & ~(DEFAULT_ROUNDING - 1));\n+                    + 4 + DEFAULT_ROUNDING - 1)\n+                   & ~(DEFAULT_ROUNDING - 1));\n       size = 4096 - extra;\n     }\n \n-  h->chunkfun = (struct _obstack_chunk * (*)(void *, long)) chunkfun;\n-  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;\n   h->chunk_size = size;\n   h->alignment_mask = alignment - 1;\n-  h->use_extra_arg = 0;\n \n-  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);\n+  chunk = h->chunk = call_chunkfun (h, h->chunk_size);\n   if (!chunk)\n     (*obstack_alloc_failed_handler) ();\n-  h->next_free = h->object_base = chunk->contents;\n-  h->chunk_limit = chunk->limit\n-    = (char *) chunk + h->chunk_size;\n+  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,\n+                                               alignment - 1);\n+  h->chunk_limit = chunk->limit = (char *) chunk + h->chunk_size;\n   chunk->prev = 0;\n   /* The initial chunk now contains no empty object.  */\n   h->maybe_empty_object = 0;\n@@ -183,49 +147,29 @@ _obstack_begin (struct obstack *h, int size, int alignment,\n }\n \n int\n-_obstack_begin_1 (struct obstack *h, int size, int alignment,\n-                  POINTER (*chunkfun) (POINTER, long),\n-                  void (*freefun) (POINTER, POINTER), POINTER arg)\n+_obstack_begin (struct obstack *h,\n+                _OBSTACK_SIZE_T size, _OBSTACK_SIZE_T alignment,\n+                void *(*chunkfun) (size_t),\n+                void (*freefun) (void *))\n {\n-  register struct _obstack_chunk *chunk; /* points to new chunk */\n-\n-  if (alignment == 0)\n-    alignment = (int) DEFAULT_ALIGNMENT;\n-  if (size == 0)\n-    /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n-    {\n-      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.\n-\t Use the values for range checking, because if range checking is off,\n-\t the extra bytes won't be missed terribly, but if range checking is on\n-\t and we used a larger request, a whole extra 4096 bytes would be\n-\t allocated.\n-\n-\t These number are irrelevant to the new GNU malloc.  I suspect it is\n-\t less sensitive to the size of the request.  */\n-      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))\n-\t\t    + 4 + DEFAULT_ROUNDING - 1)\n-\t\t   & ~(DEFAULT_ROUNDING - 1));\n-      size = 4096 - extra;\n-    }\n+  h->chunkfun.plain = chunkfun;\n+  h->freefun.plain = freefun;\n+  h->use_extra_arg = 0;\n+  return _obstack_begin_worker (h, size, alignment);\n+}\n \n-  h->chunkfun = (struct _obstack_chunk * (*)(void *,long)) chunkfun;\n-  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;\n-  h->chunk_size = size;\n-  h->alignment_mask = alignment - 1;\n+int\n+_obstack_begin_1 (struct obstack *h,\n+                  _OBSTACK_SIZE_T size, _OBSTACK_SIZE_T alignment,\n+                  void *(*chunkfun) (void *, size_t),\n+                  void (*freefun) (void *, void *),\n+                  void *arg)\n+{\n+  h->chunkfun.extra = chunkfun;\n+  h->freefun.extra = freefun;\n   h->extra_arg = arg;\n   h->use_extra_arg = 1;\n-\n-  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);\n-  if (!chunk)\n-    (*obstack_alloc_failed_handler) ();\n-  h->next_free = h->object_base = chunk->contents;\n-  h->chunk_limit = chunk->limit\n-    = (char *) chunk + h->chunk_size;\n-  chunk->prev = 0;\n-  /* The initial chunk now contains no empty object.  */\n-  h->maybe_empty_object = 0;\n-  h->alloc_failed = 0;\n-  return 1;\n+  return _obstack_begin_worker (h, size, alignment);\n }\n \n /* Allocate a new current chunk for the obstack *H\n@@ -235,58 +179,51 @@ _obstack_begin_1 (struct obstack *h, int size, int alignment,\n    to the beginning of the new one.  */\n \n void\n-_obstack_newchunk (struct obstack *h, int length)\n+_obstack_newchunk (struct obstack *h, _OBSTACK_SIZE_T length)\n {\n-  register struct _obstack_chunk *old_chunk = h->chunk;\n-  register struct _obstack_chunk *new_chunk;\n-  register long\tnew_size;\n-  register long obj_size = h->next_free - h->object_base;\n-  register long i;\n-  long already;\n+  struct _obstack_chunk *old_chunk = h->chunk;\n+  struct _obstack_chunk *new_chunk = 0;\n+  size_t obj_size = h->next_free - h->object_base;\n+  char *object_base;\n \n   /* Compute size for new chunk.  */\n-  new_size = (obj_size + length) + (obj_size >> 3) + 100;\n+  size_t sum1 = obj_size + length;\n+  size_t sum2 = sum1 + h->alignment_mask;\n+  size_t new_size = sum2 + (obj_size >> 3) + 100;\n+  if (new_size < sum2)\n+    new_size = sum2;\n   if (new_size < h->chunk_size)\n     new_size = h->chunk_size;\n \n   /* Allocate and initialize the new chunk.  */\n-  new_chunk = CALL_CHUNKFUN (h, new_size);\n+  if (obj_size <= sum1 && sum1 <= sum2)\n+    new_chunk = call_chunkfun (h, new_size);\n   if (!new_chunk)\n-    (*obstack_alloc_failed_handler) ();\n+    (*obstack_alloc_failed_handler)();\n   h->chunk = new_chunk;\n   new_chunk->prev = old_chunk;\n   new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;\n \n-  /* Move the existing object to the new chunk.\n-     Word at a time is fast and is safe if the object\n-     is sufficiently aligned.  */\n-  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)\n-    {\n-      for (i = obj_size / sizeof (COPYING_UNIT) - 1;\n-\t   i >= 0; i--)\n-\t((COPYING_UNIT *)new_chunk->contents)[i]\n-\t  = ((COPYING_UNIT *)h->object_base)[i];\n-      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,\n-\t but that can cross a page boundary on a machine\n-\t which does not do strict alignment for COPYING_UNITS.  */\n-      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);\n-    }\n-  else\n-    already = 0;\n-  /* Copy remaining bytes one by one.  */\n-  for (i = already; i < obj_size; i++)\n-    new_chunk->contents[i] = h->object_base[i];\n+  /* Compute an aligned object_base in the new chunk */\n+  object_base =\n+    __PTR_ALIGN ((char *) new_chunk, new_chunk->contents, h->alignment_mask);\n+\n+  /* Move the existing object to the new chunk.  */\n+  memcpy (object_base, h->object_base, obj_size);\n \n   /* If the object just copied was the only data in OLD_CHUNK,\n      free that chunk and remove it from the chain.\n      But not if that chunk might contain an empty object.  */\n-  if (h->object_base == old_chunk->contents && ! h->maybe_empty_object)\n+  if (!h->maybe_empty_object\n+      && (h->object_base\n+          == __PTR_ALIGN ((char *) old_chunk, old_chunk->contents,\n+                          h->alignment_mask)))\n     {\n       new_chunk->prev = old_chunk->prev;\n-      CALL_FREEFUN (h, old_chunk);\n+      call_freefun (h, old_chunk);\n     }\n \n-  h->object_base = new_chunk->contents;\n+  h->object_base = object_base;\n   h->next_free = h->object_base + obj_size;\n   /* The new chunk certainly contains no empty object yet.  */\n   h->maybe_empty_object = 0;\n@@ -298,51 +235,46 @@ _obstack_newchunk (struct obstack *h, int length)\n \n /* Suppress -Wmissing-prototypes warning.  We don't want to declare this in\n    obstack.h because it is just for debugging.  */\n-int _obstack_allocated_p (struct obstack *h, POINTER obj);\n+int _obstack_allocated_p (struct obstack *h, void *obj) __attribute_pure__;\n \n int\n-_obstack_allocated_p (struct obstack *h, POINTER obj)\n+_obstack_allocated_p (struct obstack *h, void *obj)\n {\n-  register struct _obstack_chunk *lp;\t/* below addr of any objects in this chunk */\n-  register struct _obstack_chunk *plp;\t/* point to previous chunk if any */\n+  struct _obstack_chunk *lp;    /* below addr of any objects in this chunk */\n+  struct _obstack_chunk *plp;   /* point to previous chunk if any */\n \n   lp = (h)->chunk;\n   /* We use >= rather than > since the object cannot be exactly at\n      the beginning of the chunk but might be an empty object exactly\n      at the end of an adjacent chunk.  */\n-  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))\n+  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))\n     {\n       plp = lp->prev;\n       lp = plp;\n     }\n   return lp != 0;\n }\n-\f\n+\n /* Free objects in obstack H, including OBJ and everything allocate\n    more recently than OBJ.  If OBJ is zero, free everything in H.  */\n \n-#undef obstack_free\n-\n-/* This function has two names with identical definitions.\n-   This is the first one, called from non-ANSI code.  */\n-\n void\n-_obstack_free (struct obstack *h, POINTER obj)\n+_obstack_free (struct obstack *h, void *obj)\n {\n-  register struct _obstack_chunk *lp;\t/* below addr of any objects in this chunk */\n-  register struct _obstack_chunk *plp;\t/* point to previous chunk if any */\n+  struct _obstack_chunk *lp;    /* below addr of any objects in this chunk */\n+  struct _obstack_chunk *plp;   /* point to previous chunk if any */\n \n   lp = h->chunk;\n   /* We use >= because there cannot be an object at the beginning of a chunk.\n      But there can be an empty object at that address\n      at the end of another chunk.  */\n-  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))\n+  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))\n     {\n       plp = lp->prev;\n-      CALL_FREEFUN (h, lp);\n+      call_freefun (h, lp);\n       lp = plp;\n       /* If we switch chunks, we can't tell whether the new current\n-\t chunk contains an empty object, so assume that it may.  */\n+         chunk contains an empty object, so assume that it may.  */\n       h->maybe_empty_object = 1;\n     }\n   if (lp)\n@@ -356,155 +288,66 @@ _obstack_free (struct obstack *h, POINTER obj)\n     abort ();\n }\n \n-/* This function is used from ANSI code.  */\n-\n-void\n-obstack_free (struct obstack *h, POINTER obj)\n-{\n-  register struct _obstack_chunk *lp;\t/* below addr of any objects in this chunk */\n-  register struct _obstack_chunk *plp;\t/* point to previous chunk if any */\n-\n-  lp = h->chunk;\n-  /* We use >= because there cannot be an object at the beginning of a chunk.\n-     But there can be an empty object at that address\n-     at the end of another chunk.  */\n-  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))\n-    {\n-      plp = lp->prev;\n-      CALL_FREEFUN (h, lp);\n-      lp = plp;\n-      /* If we switch chunks, we can't tell whether the new current\n-\t chunk contains an empty object, so assume that it may.  */\n-      h->maybe_empty_object = 1;\n-    }\n-  if (lp)\n-    {\n-      h->object_base = h->next_free = (char *) (obj);\n-      h->chunk_limit = lp->limit;\n-      h->chunk = lp;\n-    }\n-  else if (obj != 0)\n-    /* obj is not in any of the chunks! */\n-    abort ();\n-}\n-\f\n-int\n+_OBSTACK_SIZE_T\n _obstack_memory_used (struct obstack *h)\n {\n-  register struct _obstack_chunk* lp;\n-  register int nbytes = 0;\n+  struct _obstack_chunk *lp;\n+  _OBSTACK_SIZE_T nbytes = 0;\n \n   for (lp = h->chunk; lp != 0; lp = lp->prev)\n     {\n       nbytes += lp->limit - (char *) lp;\n     }\n   return nbytes;\n }\n-\f\n+\n+# ifndef _OBSTACK_NO_ERROR_HANDLER\n /* Define the error handler.  */\n-#ifndef _\n-# if (HAVE_LIBINTL_H && ENABLE_NLS) || defined _LIBC\n-#  include <libintl.h>\n+#  include <stdio.h>\n+\n+/* Exit value used when 'print_and_abort' is used.  */\n+#  ifdef _LIBC\n+int obstack_exit_failure = EXIT_FAILURE;\n+#  else\n+#   include \"exitfail.h\"\n+#   define obstack_exit_failure exit_failure\n+#  endif\n+\n+#  ifdef _LIBC\n+#   include <libintl.h>\n+#  else\n+#   include \"gettext.h\"\n+#  endif\n #  ifndef _\n-#   define _(Str) gettext (Str)\n+#   define _(msgid) gettext (msgid)\n #  endif\n-# else\n-#  define _(Str) (Str)\n-# endif\n-#endif\n \n-static void\n+#  ifdef _LIBC\n+#   include <libio/iolibio.h>\n+#  endif\n+\n+static _Noreturn void\n print_and_abort (void)\n {\n-  fputs (_(\"memory exhausted\\n\"), stderr);\n+  /* Don't change any of these strings.  Yes, it would be possible to add\n+     the newline to the string and use fputs or so.  But this must not\n+     happen because the \"memory exhausted\" message appears in other places\n+     like this and the translation should be reused instead of creating\n+     a very similar string which requires a separate translation.  */\n+#  ifdef _LIBC\n+  (void) __fxprintf (NULL, \"%s\\n\", _(\"memory exhausted\"));\n+#  else\n+  fprintf (stderr, \"%s\\n\", _(\"memory exhausted\"));\n+#  endif\n   exit (obstack_exit_failure);\n }\n-\f\n-#if 0\n-/* These are now turned off because the applications do not use it\n-   and it uses bcopy via obstack_grow, which causes trouble on sysV.  */\n-\n-/* Now define the functional versions of the obstack macros.\n-   Define them to simply use the corresponding macros to do the job.  */\n-\n-/* The function names appear in parentheses in order to prevent\n-   the macro-definitions of the names from being expanded there.  */\n-\n-POINTER (obstack_base) (struct obstack *obstack)\n-{\n-  return obstack_base (obstack);\n-}\n-\n-POINTER (obstack_next_free) (struct obstack *obstack)\n-{\n-  return obstack_next_free (obstack);\n-}\n-\n-int (obstack_object_size) (struct obstack *obstack)\n-{\n-  return obstack_object_size (obstack);\n-}\n-\n-int (obstack_room) (struct obstack *obstack)\n-{\n-  return obstack_room (obstack);\n-}\n-\n-int (obstack_make_room) (struct obstack *obstack, int length)\n-{\n-  return obstack_make_room (obstack, length);\n-}\n \n-void (obstack_grow) (struct obstack *obstack, POINTER pointer, int length)\n-{\n-  obstack_grow (obstack, pointer, length);\n-}\n-\n-void (obstack_grow0) (struct obstack *obstack, POINTER pointer, int length)\n-{\n-  obstack_grow0 (obstack, pointer, length);\n-}\n-\n-void (obstack_1grow) (struct obstack *obstack, int character)\n-{\n-  obstack_1grow (obstack, character);\n-}\n-\n-void (obstack_blank) (struct obstack *obstack, int length)\n-{\n-  obstack_blank (obstack, length);\n-}\n-\n-void (obstack_1grow_fast) (struct obstack *obstack, int character)\n-{\n-  obstack_1grow_fast (obstack, character);\n-}\n-\n-void (obstack_blank_fast) (struct obstack *obstack, int length)\n-{\n-  obstack_blank_fast (obstack, length);\n-}\n-\n-POINTER (obstack_finish) (struct obstack *obstack)\n-{\n-  return obstack_finish (obstack);\n-}\n-\n-POINTER (obstack_alloc) (struct obstack *obstack, int length)\n-{\n-  return obstack_alloc (obstack, length);\n-}\n-\n-POINTER (obstack_copy) (struct obstack *obstack, POINTER pointer, int length)\n-{\n-  return obstack_copy (obstack, pointer, length);\n-}\n-\n-POINTER (obstack_copy0) (struct obstack *obstack, POINTER pointer, int length)\n-{\n-  return obstack_copy0 (obstack, pointer, length);\n-}\n-\n-#endif /* 0 */\n-\n-#endif\t/* !ELIDE_CODE */\n+/* The functions allocating more room by calling 'obstack_chunk_alloc'\n+   jump to the handler pointed to by 'obstack_alloc_failed_handler'.\n+   This can be set to a user defined function which should either\n+   abort gracefully or use longjump - but shouldn't return.  This\n+   variable by default points to the internal function\n+   'print_and_abort'.  */\n+void (*obstack_alloc_failed_handler) (void) = print_and_abort;\n+# endif /* !_OBSTACK_NO_ERROR_HANDLER */\n+#endif /* !_OBSTACK_ELIDE_CODE */"}, {"sha": "1bfc878e7778176a9eaa10e2b9f14f3dded24eaf", "filename": "libiberty/obstacks.texi", "status": "modified", "additions": 139, "deletions": 126, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f265c94502ff2a751e9dfb78b718975c0cac0c/libiberty%2Fobstacks.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f265c94502ff2a751e9dfb78b718975c0cac0c/libiberty%2Fobstacks.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fobstacks.texi?ref=c9f265c94502ff2a751e9dfb78b718975c0cac0c", "patch": "@@ -20,8 +20,7 @@ the padding needed to start each object on a suitable boundary.\n \t\t\t\t use obstacks.\n * Allocation in an Obstack::    Allocating objects in an obstack.\n * Freeing Obstack Objects::     Freeing objects in an obstack.\n-* Obstack Functions::\t\tThe obstack functions are both\n-\t\t\t\t functions and macros.\n+* Obstack Functions::\t\tThe obstack functions are really macros.\n * Growing Objects::             Making an object bigger by stages.\n * Extra Fast Growing::\t\tExtra-high-efficiency (though more\n \t\t\t\t complicated) growing objects.\n@@ -46,7 +45,7 @@ An obstack is represented by a data structure of type @code{struct\n obstack}.  This structure has a small fixed size; it records the status\n of the obstack and how to find the space in which objects are allocated.\n It does not contain any of the objects themselves.  You should not try\n-to access the contents of the structure directly; use only the functions\n+to access the contents of the structure directly; use only the macros\n described in this chapter.\n @end deftp\n \n@@ -56,7 +55,7 @@ of object.  Dynamic allocation of obstacks allows your program to have a\n variable number of different stacks.  (You can even allocate an\n obstack structure in another obstack, but this is rarely useful.)\n \n-All the functions that work with obstacks require you to specify which\n+All the macros that work with obstacks require you to specify which\n obstack to use.  You do this with a pointer of type @code{struct obstack\n *}.  In the following, we often say ``an obstack'' when strictly\n speaking the object at hand is such a pointer.\n@@ -76,7 +75,7 @@ These matters are described in the following section.\n @node Preparing for Obstacks\n @subsubsection Preparing for Using Obstacks\n \n-Each source file in which you plan to use the obstack functions\n+Each source file in which you plan to use obstacks\n must include the header file @file{obstack.h}, like this:\n \n @smallexample\n@@ -86,15 +85,15 @@ must include the header file @file{obstack.h}, like this:\n @findex obstack_chunk_alloc\n @findex obstack_chunk_free\n Also, if the source file uses the macro @code{obstack_init}, it must\n-declare or define two functions or macros that will be called by the\n+declare or define two macros that will be called by the\n obstack library.  One, @code{obstack_chunk_alloc}, is used to allocate\n the chunks of memory into which objects are packed.  The other,\n @code{obstack_chunk_free}, is used to return chunks when the objects in\n them are freed.  These macros should appear before any use of obstacks\n in the source file.\n \n Usually these are defined to use @code{malloc} via the intermediary\n-@code{xmalloc} (@pxref{Unconstrained Allocation, , , libc, The GNU C Library Reference Manual}).  This is done with\n+@code{xmalloc} (@pxref{Unconstrained Allocation}).  This is done with\n the following pair of macro definitions:\n \n @smallexample\n@@ -109,16 +108,18 @@ larger blocks of memory.  @xref{Obstack Chunks}, for full details.\n \n At run time, before the program can use a @code{struct obstack} object\n as an obstack, it must initialize the obstack by calling\n-@code{obstack_init}.\n+@code{obstack_init} or one of its variants, @code{obstack_begin},\n+@code{obstack_specify_allocation}, or\n+@code{obstack_specify_allocation_with_arg}.\n \n @comment obstack.h\n @comment GNU\n @deftypefun int obstack_init (struct obstack *@var{obstack-ptr})\n Initialize obstack @var{obstack-ptr} for allocation of objects.  This\n-function calls the obstack's @code{obstack_chunk_alloc} function.  If\n+macro calls the obstack's @code{obstack_chunk_alloc} function.  If\n allocation of memory fails, the function pointed to by\n @code{obstack_alloc_failed_handler} is called.  The @code{obstack_init}\n-function always returns 1 (Compatibility notice: Former versions of\n+macro always returns 1 (Compatibility notice: Former versions of\n obstack returned 0 if allocation failed).\n @end deftypefun\n \n@@ -141,15 +142,38 @@ struct obstack *myobstack_ptr\n obstack_init (myobstack_ptr);\n @end smallexample\n \n+@comment obstack.h\n+@comment GNU\n+@deftypefun int obstack_begin (struct obstack *@var{obstack-ptr}, size_t chunk_size)\n+Like @code{obstack_init}, but specify chunks to be at least\n+@var{chunk_size} bytes in size.\n+@end deftypefun\n+\n+@comment obstack.h\n+@comment GNU\n+@deftypefun int obstack_specify_allocation (struct obstack *@var{obstack-ptr}, size_t chunk_size, size_t alignment, void *(*chunkfun) (size_t), void (*freefun) (void *))\n+Like @code{obstack_init}, specifying chunk size, chunk\n+alignment, and memory allocation functions.  A @var{chunk_size} or\n+@var{alignment} of zero results in the default size or alignment\n+respectively being used.\n+@end deftypefun\n+\n+@comment obstack.h\n+@comment GNU\n+@deftypefun int obstack_specify_allocation_with_arg (struct obstack *@var{obstack-ptr}, size_t chunk_size, size_t alignment, void *(*chunkfun) (void *, size_t), void (*freefun) (void *, void *), void *arg)\n+Like @code{obstack_specify_allocation}, but specifying memory\n+allocation functions that take an extra first argument, @var{arg}.\n+@end deftypefun\n+\n @comment obstack.h\n @comment GNU\n @defvar obstack_alloc_failed_handler\n The value of this variable is a pointer to a function that\n @code{obstack} uses when @code{obstack_chunk_alloc} fails to allocate\n memory.  The default action is to print a message and abort.\n You should supply a function that either calls @code{exit}\n-(@pxref{Program Termination, , , libc, The GNU C Library Reference Manual}) or @code{longjmp} (@pxref{Non-Local\n-Exits, , , libc, The GNU C Library Reference Manual}) and doesn't return.\n+(@pxref{Program Termination}) or @code{longjmp} (@pxref{Non-Local\n+Exits}) and doesn't return.\n \n @smallexample\n void my_obstack_alloc_failed (void)\n@@ -168,14 +192,14 @@ The most direct way to allocate an object in an obstack is with\n \n @comment obstack.h\n @comment GNU\n-@deftypefun {void *} obstack_alloc (struct obstack *@var{obstack-ptr}, int @var{size})\n+@deftypefun {void *} obstack_alloc (struct obstack *@var{obstack-ptr}, size_t @var{size})\n This allocates an uninitialized block of @var{size} bytes in an obstack\n and returns its address.  Here @var{obstack-ptr} specifies which obstack\n to allocate the block in; it is the address of the @code{struct obstack}\n-object which represents the obstack.  Each obstack function or macro\n+object which represents the obstack.  Each obstack macro\n requires you to specify an @var{obstack-ptr} as the first argument.\n \n-This function calls the obstack's @code{obstack_chunk_alloc} function if\n+This macro calls the obstack's @code{obstack_chunk_alloc} function if\n it needs to allocate a new chunk of memory; it calls\n @code{obstack_alloc_failed_handler} if allocation of memory by\n @code{obstack_chunk_alloc} failed.\n@@ -197,12 +221,11 @@ copystring (char *string)\n @}\n @end smallexample\n \n-To allocate a block with specified contents, use the function\n-@code{obstack_copy}, declared like this:\n+To allocate a block with specified contents, use the macro @code{obstack_copy}.\n \n @comment obstack.h\n @comment GNU\n-@deftypefun {void *} obstack_copy (struct obstack *@var{obstack-ptr}, void *@var{address}, int @var{size})\n+@deftypefun {void *} obstack_copy (struct obstack *@var{obstack-ptr}, void *@var{address}, size_t @var{size})\n This allocates a block and initializes it by copying @var{size}\n bytes of data starting at @var{address}.  It calls\n @code{obstack_alloc_failed_handler} if allocation of memory by\n@@ -211,32 +234,32 @@ bytes of data starting at @var{address}.  It calls\n \n @comment obstack.h\n @comment GNU\n-@deftypefun {void *} obstack_copy0 (struct obstack *@var{obstack-ptr}, void *@var{address}, int @var{size})\n+@deftypefun {void *} obstack_copy0 (struct obstack *@var{obstack-ptr}, void *@var{address}, size_t @var{size})\n Like @code{obstack_copy}, but appends an extra byte containing a null\n character.  This extra byte is not counted in the argument @var{size}.\n @end deftypefun\n \n-The @code{obstack_copy0} function is convenient for copying a sequence\n+The @code{obstack_copy0} macro is convenient for copying a sequence\n of characters into an obstack as a null-terminated string.  Here is an\n example of its use:\n \n @smallexample\n char *\n-obstack_savestring (char *addr, int size)\n+obstack_savestring (char *addr, size_t size)\n @{\n   return obstack_copy0 (&myobstack, addr, size);\n @}\n @end smallexample\n \n @noindent\n Contrast this with the previous example of @code{savestring} using\n-@code{malloc} (@pxref{Basic Allocation, , , libc, The GNU C Library Reference Manual}).\n+@code{malloc} (@pxref{Basic Allocation}).\n \n @node Freeing Obstack Objects\n @subsubsection Freeing Objects in an Obstack\n @cindex freeing (obstacks)\n \n-To free an object allocated in an obstack, use the function\n+To free an object allocated in an obstack, use the macro\n @code{obstack_free}.  Since the obstack is a stack of objects, freeing\n one object automatically frees all other objects allocated more recently\n in the same obstack.\n@@ -268,15 +291,12 @@ obstacks, or non-obstack allocation, can reuse the space of the chunk.\n @subsubsection Obstack Functions and Macros\n @cindex macros\n \n-The interfaces for using obstacks may be defined either as functions or\n-as macros, depending on the compiler.  The obstack facility works with\n-all C compilers, including both @w{ISO C} and traditional C, but there are\n-precautions you must take if you plan to use compilers other than GNU C.\n-\n-If you are using an old-fashioned @w{non-ISO C} compiler, all the obstack\n-``functions'' are actually defined only as macros.  You can call these\n-macros like functions, but you cannot use them in any other way (for\n-example, you cannot take their address).\n+The interfaces for using obstacks are shown here as functions to\n+specify the return type and argument types, but they are really\n+defined as macros.  This means that the arguments don't actually have\n+types, but they generally behave as if they have the types shown.\n+You can call these macros like functions, but you cannot use them in\n+any other way (for example, you cannot take their address).\n \n Calling the macros requires a special precaution: namely, the first\n operand (the obstack pointer) may not contain any side effects, because\n@@ -292,34 +312,18 @@ If you use @code{*obstack_list_ptr++} as the obstack pointer argument,\n you will get very strange results since the incrementation may occur\n several times.\n \n-In @w{ISO C}, each function has both a macro definition and a function\n-definition.  The function definition is used if you take the address of the\n-function without calling it.  An ordinary call uses the macro definition by\n-default, but you can request the function definition instead by writing the\n-function name in parentheses, as shown here:\n-\n-@smallexample\n-char *x;\n-void *(*funcp) ();\n-/* @r{Use the macro}.  */\n-x = (char *) obstack_alloc (obptr, size);\n-/* @r{Call the function}.  */\n-x = (char *) (obstack_alloc) (obptr, size);\n-/* @r{Take the address of the function}.  */\n-funcp = obstack_alloc;\n-@end smallexample\n-\n-@noindent\n-This is the same situation that exists in @w{ISO C} for the standard library\n-functions.  @xref{Macro Definitions, , , libc, The GNU C Library Reference Manual}.\n-\n-@strong{Warning:} When you do use the macros, you must observe the\n-precaution of avoiding side effects in the first operand, even in @w{ISO C}.\n-\n If you use the GNU C compiler, this precaution is not necessary, because\n various language extensions in GNU C permit defining the macros so as to\n compute each argument only once.\n \n+Note that arguments other than the first will only be evaluated once,\n+even when not using GNU C.\n+\n+@code{obstack.h} does declare a number of functions,\n+@code{_obstack_begin}, @code{_obstack_begin_1},\n+@code{_obstack_newchunk}, @code{_obstack_free}, and\n+@code{_obstack_memory_used}.  You should not call these directly.\n+\n @node Growing Objects\n @subsubsection Growing Objects\n @cindex growing objects (in obstacks)\n@@ -329,13 +333,13 @@ Because memory in obstack chunks is used sequentially, it is possible to\n build up an object step by step, adding one or more bytes at a time to the\n end of the object.  With this technique, you do not need to know how much\n data you will put in the object until you come to the end of it.  We call\n-this the technique of @dfn{growing objects}.  The special functions\n+this the technique of @dfn{growing objects}.  The special macros\n for adding data to the growing object are described in this section.\n \n You don't need to do anything special when you start to grow an object.\n-Using one of the functions to add data to the object automatically\n+Using one of the macros to add data to the object automatically\n starts it.  However, it is necessary to say explicitly when the object is\n-finished.  This is done with the function @code{obstack_finish}.\n+finished.  This is done with @code{obstack_finish}.\n \n The actual address of the object thus built up is not known until the\n object is finished.  Until then, it always remains possible that you will\n@@ -347,14 +351,14 @@ already added to the growing object will become part of the other object.\n \n @comment obstack.h\n @comment GNU\n-@deftypefun void obstack_blank (struct obstack *@var{obstack-ptr}, int @var{size})\n-The most basic function for adding to a growing object is\n+@deftypefun void obstack_blank (struct obstack *@var{obstack-ptr}, size_t @var{size})\n+The most basic macro for adding to a growing object is\n @code{obstack_blank}, which adds space without initializing it.\n @end deftypefun\n \n @comment obstack.h\n @comment GNU\n-@deftypefun void obstack_grow (struct obstack *@var{obstack-ptr}, void *@var{data}, int @var{size})\n+@deftypefun void obstack_grow (struct obstack *@var{obstack-ptr}, void *@var{data}, size_t @var{size})\n To add a block of initialized space, use @code{obstack_grow}, which is\n the growing-object analogue of @code{obstack_copy}.  It adds @var{size}\n bytes of data to the growing object, copying the contents from\n@@ -363,7 +367,7 @@ bytes of data to the growing object, copying the contents from\n \n @comment obstack.h\n @comment GNU\n-@deftypefun void obstack_grow0 (struct obstack *@var{obstack-ptr}, void *@var{data}, int @var{size})\n+@deftypefun void obstack_grow0 (struct obstack *@var{obstack-ptr}, void *@var{data}, size_t @var{size})\n This is the growing-object analogue of @code{obstack_copy0}.  It adds\n @var{size} bytes copied from @var{data}, followed by an additional null\n character.\n@@ -372,50 +376,46 @@ character.\n @comment obstack.h\n @comment GNU\n @deftypefun void obstack_1grow (struct obstack *@var{obstack-ptr}, char @var{c})\n-To add one character at a time, use the function @code{obstack_1grow}.\n+To add one character at a time, use @code{obstack_1grow}.\n It adds a single byte containing @var{c} to the growing object.\n @end deftypefun\n \n @comment obstack.h\n @comment GNU\n @deftypefun void obstack_ptr_grow (struct obstack *@var{obstack-ptr}, void *@var{data})\n-Adding the value of a pointer one can use the function\n+Adding the value of a pointer one can use\n @code{obstack_ptr_grow}.  It adds @code{sizeof (void *)} bytes\n containing the value of @var{data}.\n @end deftypefun\n \n @comment obstack.h\n @comment GNU\n @deftypefun void obstack_int_grow (struct obstack *@var{obstack-ptr}, int @var{data})\n-A single value of type @code{int} can be added by using the\n-@code{obstack_int_grow} function.  It adds @code{sizeof (int)} bytes to\n+A single value of type @code{int} can be added by using\n+@code{obstack_int_grow}.  It adds @code{sizeof (int)} bytes to\n the growing object and initializes them with the value of @var{data}.\n @end deftypefun\n \n @comment obstack.h\n @comment GNU\n @deftypefun {void *} obstack_finish (struct obstack *@var{obstack-ptr})\n-When you are finished growing the object, use the function\n+When you are finished growing the object, use\n @code{obstack_finish} to close it off and return its final address.\n \n Once you have finished the object, the obstack is available for ordinary\n allocation or for growing another object.\n-\n-This function can return a null pointer under the same conditions as\n-@code{obstack_alloc} (@pxref{Allocation in an Obstack}).\n @end deftypefun\n \n When you build an object by growing it, you will probably need to know\n afterward how long it became.  You need not keep track of this as you grow\n-the object, because you can find out the length from the obstack just\n-before finishing the object with the function @code{obstack_object_size},\n-declared as follows:\n+the object, because you can find out the length from the obstack\n+with @code{obstack_object_size}, before finishing the object.\n \n @comment obstack.h\n @comment GNU\n-@deftypefun int obstack_object_size (struct obstack *@var{obstack-ptr})\n-This function returns the current size of the growing object, in bytes.\n-Remember to call this function @emph{before} finishing the object.\n+@deftypefun size_t obstack_object_size (struct obstack *@var{obstack-ptr})\n+This macro returns the current size of the growing object, in bytes.\n+Remember to call @code{obstack_object_size} @emph{before} finishing the object.\n After it is finished, @code{obstack_object_size} will return zero.\n @end deftypefun\n \n@@ -429,96 +429,91 @@ obstack_free (obstack_ptr, obstack_finish (obstack_ptr));\n @noindent\n This has no effect if no object was growing.\n \n-@cindex shrinking objects\n-You can use @code{obstack_blank} with a negative size argument to make\n-the current object smaller.  Just don't try to shrink it beyond zero\n-length---there's no telling what will happen if you do that.\n-\n @node Extra Fast Growing\n @subsubsection Extra Fast Growing Objects\n @cindex efficiency and obstacks\n \n-The usual functions for growing objects incur overhead for checking\n+The usual macros for growing objects incur overhead for checking\n whether there is room for the new growth in the current chunk.  If you\n are frequently constructing objects in small steps of growth, this\n overhead can be significant.\n \n You can reduce the overhead by using special ``fast growth''\n-functions that grow the object without checking.  In order to have a\n+macros that grow the object without checking.  In order to have a\n robust program, you must do the checking yourself.  If you do this checking\n in the simplest way each time you are about to add data to the object, you\n have not saved anything, because that is what the ordinary growth\n-functions do.  But if you can arrange to check less often, or check\n+macros do.  But if you can arrange to check less often, or check\n more efficiently, then you make the program faster.\n \n-The function @code{obstack_room} returns the amount of room available\n-in the current chunk.  It is declared as follows:\n+@code{obstack_room} returns the amount of room available\n+in the current chunk.\n \n @comment obstack.h\n @comment GNU\n-@deftypefun int obstack_room (struct obstack *@var{obstack-ptr})\n+@deftypefun size_t obstack_room (struct obstack *@var{obstack-ptr})\n This returns the number of bytes that can be added safely to the current\n growing object (or to an object about to be started) in obstack\n-@var{obstack} using the fast growth functions.\n+@var{obstack} using the fast growth macros.\n @end deftypefun\n \n-While you know there is room, you can use these fast growth functions\n+While you know there is room, you can use these fast growth macros\n for adding data to a growing object:\n \n @comment obstack.h\n @comment GNU\n @deftypefun void obstack_1grow_fast (struct obstack *@var{obstack-ptr}, char @var{c})\n-The function @code{obstack_1grow_fast} adds one byte containing the\n+@code{obstack_1grow_fast} adds one byte containing the\n character @var{c} to the growing object in obstack @var{obstack-ptr}.\n @end deftypefun\n \n @comment obstack.h\n @comment GNU\n @deftypefun void obstack_ptr_grow_fast (struct obstack *@var{obstack-ptr}, void *@var{data})\n-The function @code{obstack_ptr_grow_fast} adds @code{sizeof (void *)}\n+@code{obstack_ptr_grow_fast} adds @code{sizeof (void *)}\n bytes containing the value of @var{data} to the growing object in\n obstack @var{obstack-ptr}.\n @end deftypefun\n \n @comment obstack.h\n @comment GNU\n @deftypefun void obstack_int_grow_fast (struct obstack *@var{obstack-ptr}, int @var{data})\n-The function @code{obstack_int_grow_fast} adds @code{sizeof (int)} bytes\n+@code{obstack_int_grow_fast} adds @code{sizeof (int)} bytes\n containing the value of @var{data} to the growing object in obstack\n @var{obstack-ptr}.\n @end deftypefun\n \n @comment obstack.h\n @comment GNU\n-@deftypefun void obstack_blank_fast (struct obstack *@var{obstack-ptr}, int @var{size})\n-The function @code{obstack_blank_fast} adds @var{size} bytes to the\n+@deftypefun void obstack_blank_fast (struct obstack *@var{obstack-ptr}, size_t @var{size})\n+@code{obstack_blank_fast} adds @var{size} bytes to the\n growing object in obstack @var{obstack-ptr} without initializing them.\n @end deftypefun\n \n When you check for space using @code{obstack_room} and there is not\n-enough room for what you want to add, the fast growth functions\n+enough room for what you want to add, the fast growth macros\n are not safe.  In this case, simply use the corresponding ordinary\n-growth function instead.  Very soon this will copy the object to a\n+growth macro instead.  Very soon this will copy the object to a\n new chunk; then there will be lots of room available again.\n \n-So, each time you use an ordinary growth function, check afterward for\n+So, each time you use an ordinary growth macro, check afterward for\n sufficient space using @code{obstack_room}.  Once the object is copied\n to a new chunk, there will be plenty of space again, so the program will\n-start using the fast growth functions again.\n+start using the fast growth macros again.\n \n Here is an example:\n \n @smallexample\n @group\n void\n-add_string (struct obstack *obstack, const char *ptr, int len)\n+add_string (struct obstack *obstack, const char *ptr, size_t len)\n @{\n   while (len > 0)\n     @{\n-      int room = obstack_room (obstack);\n+      size_t room = obstack_room (obstack);\n       if (room == 0)\n         @{\n-          /* @r{Not enough room. Add one character slowly,}\n+          /* @r{Not enough room.  Add one character slowly,}\n              @r{which may copy to a new chunk and make room.}  */\n           obstack_1grow (obstack, *ptr++);\n           len--;\n@@ -537,19 +532,26 @@ add_string (struct obstack *obstack, const char *ptr, int len)\n @end group\n @end smallexample\n \n+@cindex shrinking objects\n+You can use @code{obstack_blank_fast} with a ``negative'' size\n+argument to make the current object smaller.  Just don't try to shrink\n+it beyond zero length---there's no telling what will happen if you do\n+that.  Earlier versions of obstacks allowed you to use\n+@code{obstack_blank} to shrink objects.  This will no longer work.\n+\n @node Status of an Obstack\n @subsubsection Status of an Obstack\n @cindex obstack status\n @cindex status of obstack\n \n-Here are functions that provide information on the current status of\n+Here are macros that provide information on the current status of\n allocation in an obstack.  You can use them to learn about an object while\n still growing it.\n \n @comment obstack.h\n @comment GNU\n @deftypefun {void *} obstack_base (struct obstack *@var{obstack-ptr})\n-This function returns the tentative address of the beginning of the\n+This macro returns the tentative address of the beginning of the\n currently growing object in @var{obstack-ptr}.  If you finish the object\n immediately, it will have that address.  If you make it larger first, it\n may outgrow the current chunk---then its address will change!\n@@ -562,20 +564,20 @@ chunk).\n @comment obstack.h\n @comment GNU\n @deftypefun {void *} obstack_next_free (struct obstack *@var{obstack-ptr})\n-This function returns the address of the first free byte in the current\n+This macro returns the address of the first free byte in the current\n chunk of obstack @var{obstack-ptr}.  This is the end of the currently\n growing object.  If no object is growing, @code{obstack_next_free}\n returns the same value as @code{obstack_base}.\n @end deftypefun\n \n @comment obstack.h\n @comment GNU\n-@deftypefun int obstack_object_size (struct obstack *@var{obstack-ptr})\n-This function returns the size in bytes of the currently growing object.\n+@deftypefun size_t obstack_object_size (struct obstack *@var{obstack-ptr})\n+This macro returns the size in bytes of the currently growing object.\n This is equivalent to\n \n @smallexample\n-obstack_next_free (@var{obstack-ptr}) - obstack_base (@var{obstack-ptr})\n+((size_t) (obstack_next_free (@var{obstack-ptr}) - obstack_base (@var{obstack-ptr})))\n @end smallexample\n @end deftypefun\n \n@@ -589,12 +591,11 @@ specified boundary.  By default, this boundary is aligned so that\n the object can hold any type of data.\n \n To access an obstack's alignment boundary, use the macro\n-@code{obstack_alignment_mask}, whose function prototype looks like\n-this:\n+@code{obstack_alignment_mask}.\n \n @comment obstack.h\n @comment GNU\n-@deftypefn Macro int obstack_alignment_mask (struct obstack *@var{obstack-ptr})\n+@deftypefn Macro size_t obstack_alignment_mask (struct obstack *@var{obstack-ptr})\n The value is a bit mask; a bit that is 1 indicates that the corresponding\n bit in the address of an object should be 0.  The mask value should be one\n less than a power of 2; the effect is that all object addresses are\n@@ -661,7 +662,7 @@ not to waste too much memory in the portion of the last chunk not yet used.\n \n @comment obstack.h\n @comment GNU\n-@deftypefn Macro int obstack_chunk_size (struct obstack *@var{obstack-ptr})\n+@deftypefn Macro size_t obstack_chunk_size (struct obstack *@var{obstack-ptr})\n This returns the chunk size of the given obstack.\n @end deftypefn\n \n@@ -679,25 +680,37 @@ if (obstack_chunk_size (obstack_ptr) < @var{new-chunk-size})\n @end smallexample\n \n @node Summary of Obstacks\n-@subsubsection Summary of Obstack Functions\n+@subsubsection Summary of Obstack Macros\n \n-Here is a summary of all the functions associated with obstacks.  Each\n+Here is a summary of all the macros associated with obstacks.  Each\n takes the address of an obstack (@code{struct obstack *}) as its first\n argument.\n \n @table @code\n-@item void obstack_init (struct obstack *@var{obstack-ptr})\n+@item int obstack_init (struct obstack *@var{obstack-ptr})\n Initialize use of an obstack.  @xref{Creating Obstacks}.\n \n-@item void *obstack_alloc (struct obstack *@var{obstack-ptr}, int @var{size})\n+@item int obstack_begin (struct obstack *@var{obstack-ptr}, size_t chunk_size)\n+Initialize use of an obstack, with an initial chunk of\n+@var{chunk_size} bytes.\n+\n+@item int obstack_specify_allocation (struct obstack *@var{obstack-ptr}, size_t chunk_size, size_t alignment, void *(*chunkfun) (size_t), void (*freefun) (void *))\n+Initialize use of an obstack, specifying intial chunk size, chunk\n+alignment, and memory allocation functions.\n+\n+@item int obstack_specify_allocation_with_arg (struct obstack *@var{obstack-ptr}, size_t chunk_size, size_t alignment, void *(*chunkfun) (void *, size_t), void (*freefun) (void *, void *), void *arg)\n+Like @code{obstack_specify_allocation}, but specifying memory\n+allocation functions that take an extra first argument, @var{arg}.\n+\n+@item void *obstack_alloc (struct obstack *@var{obstack-ptr}, size_t @var{size})\n Allocate an object of @var{size} uninitialized bytes.\n @xref{Allocation in an Obstack}.\n \n-@item void *obstack_copy (struct obstack *@var{obstack-ptr}, void *@var{address}, int @var{size})\n+@item void *obstack_copy (struct obstack *@var{obstack-ptr}, void *@var{address}, size_t @var{size})\n Allocate an object of @var{size} bytes, with contents copied from\n @var{address}.  @xref{Allocation in an Obstack}.\n \n-@item void *obstack_copy0 (struct obstack *@var{obstack-ptr}, void *@var{address}, int @var{size})\n+@item void *obstack_copy0 (struct obstack *@var{obstack-ptr}, void *@var{address}, size_t @var{size})\n Allocate an object of @var{size}+1 bytes, with @var{size} of them copied\n from @var{address}, followed by a null character at the end.\n @xref{Allocation in an Obstack}.\n@@ -706,15 +719,15 @@ from @var{address}, followed by a null character at the end.\n Free @var{object} (and everything allocated in the specified obstack\n more recently than @var{object}).  @xref{Freeing Obstack Objects}.\n \n-@item void obstack_blank (struct obstack *@var{obstack-ptr}, int @var{size})\n+@item void obstack_blank (struct obstack *@var{obstack-ptr}, size_t @var{size})\n Add @var{size} uninitialized bytes to a growing object.\n @xref{Growing Objects}.\n \n-@item void obstack_grow (struct obstack *@var{obstack-ptr}, void *@var{address}, int @var{size})\n+@item void obstack_grow (struct obstack *@var{obstack-ptr}, void *@var{address}, size_t @var{size})\n Add @var{size} bytes, copied from @var{address}, to a growing object.\n @xref{Growing Objects}.\n \n-@item void obstack_grow0 (struct obstack *@var{obstack-ptr}, void *@var{address}, int @var{size})\n+@item void obstack_grow0 (struct obstack *@var{obstack-ptr}, void *@var{address}, size_t @var{size})\n Add @var{size} bytes, copied from @var{address}, to a growing object,\n and then add another byte containing a null character.  @xref{Growing\n Objects}.\n@@ -727,27 +740,27 @@ Add one byte containing @var{data-char} to a growing object.\n Finalize the object that is growing and return its permanent address.\n @xref{Growing Objects}.\n \n-@item int obstack_object_size (struct obstack *@var{obstack-ptr})\n+@item size_t obstack_object_size (struct obstack *@var{obstack-ptr})\n Get the current size of the currently growing object.  @xref{Growing\n Objects}.\n \n-@item void obstack_blank_fast (struct obstack *@var{obstack-ptr}, int @var{size})\n+@item void obstack_blank_fast (struct obstack *@var{obstack-ptr}, size_t @var{size})\n Add @var{size} uninitialized bytes to a growing object without checking\n that there is enough room.  @xref{Extra Fast Growing}.\n \n @item void obstack_1grow_fast (struct obstack *@var{obstack-ptr}, char @var{data-char})\n Add one byte containing @var{data-char} to a growing object without\n checking that there is enough room.  @xref{Extra Fast Growing}.\n \n-@item int obstack_room (struct obstack *@var{obstack-ptr})\n+@item size_t obstack_room (struct obstack *@var{obstack-ptr})\n Get the amount of room now available for growing the current object.\n @xref{Extra Fast Growing}.\n \n-@item int obstack_alignment_mask (struct obstack *@var{obstack-ptr})\n+@item size_t obstack_alignment_mask (struct obstack *@var{obstack-ptr})\n The mask used for aligning the beginning of an object.  This is an\n lvalue.  @xref{Obstacks Data Alignment}.\n \n-@item int obstack_chunk_size (struct obstack *@var{obstack-ptr})\n+@item size_t obstack_chunk_size (struct obstack *@var{obstack-ptr})\n The size for allocating chunks.  This is an lvalue.  @xref{Obstack Chunks}.\n \n @item void *obstack_base (struct obstack *@var{obstack-ptr})"}]}