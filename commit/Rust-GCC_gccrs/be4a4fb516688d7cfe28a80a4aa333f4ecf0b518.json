{"sha": "be4a4fb516688d7cfe28a80a4aa333f4ecf0b518", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU0YTRmYjUxNjY4OGQ3Y2ZlMjhhODBhNGFhMzMzZjRlY2YwYjUxOA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-08-18T12:37:45Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-08-18T12:37:45Z"}, "message": "c++: aggregate CTAD and brace elision [PR101344]\n\nHere the problem is ultimately that collect_ctor_idx_types always\nrecurses into an eligible sub-CONSTRUCTOR regardless of whether the\ncorresponding pair of braces was elided in the original initializer.\nThis causes us to reject some completely-braced forms of aggregate\nCTAD as in the first testcase below, because collect_ctor_idx_types\neffectively assumes that the original initializer is always minimally\nbraced (and so the aggregate deduction candidate is given a function\ntype that's incompatible with the original completely-braced initializer).\n\nIn order to fix this, collect_ctor_idx_types needs to somehow know the\nshape of the original initializer when iterating over the reshaped\ninitializer.  To that end this patch makes reshape_init flag sub-ctors\nthat were built to undo brace elision in the original ctor, so that\ncollect_ctor_idx_types that determine whether to recurse into a sub-ctor\nby simply inspecting this flag.\n\nThis happens to also fix PR101820, which is about aggregate CTAD using\ndesignated initializers, for much the same reasons.\n\nA curious case is the \"intermediately-braced\" initialization of 'e3'\n(which we reject) in the first testcase below.  It seems to me we're\nbehaving as specified here (according to [over.match.class.deduct]/1)\nbecause the initializer element x_1={1, 2, 3, 4} corresponds to the\nsubobject e_1=E::t, hence the type T_1 of the first function parameter\nof the aggregate deduction candidate is T(&&)[2][2], but T can't be\ndeduced from x_1 using this parameter type (as opposed to say T(&&)[4]).\n\n\tPR c++/101344\n\tPR c++/101820\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (CONSTRUCTOR_BRACES_ELIDED_P): Define.\n\t* decl.c (reshape_init_r): Set it.\n\t* pt.c (collect_ctor_idx_types): Recurse into a sub-CONSTRUCTOR\n\tiff CONSTRUCTOR_BRACES_ELIDED_P.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/class-deduction-aggr11.C: New test.\n\t* g++.dg/cpp2a/class-deduction-aggr12.C: New test.", "tree": {"sha": "40bd7e48f685156136613ae9e09ddb5f805609e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40bd7e48f685156136613ae9e09ddb5f805609e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be4a4fb516688d7cfe28a80a4aa333f4ecf0b518", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be4a4fb516688d7cfe28a80a4aa333f4ecf0b518", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be4a4fb516688d7cfe28a80a4aa333f4ecf0b518", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be4a4fb516688d7cfe28a80a4aa333f4ecf0b518/comments", "author": null, "committer": null, "parents": [{"sha": "a6b3db3e8625a3cba1240f0b5e1a29bd6c68b8ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6b3db3e8625a3cba1240f0b5e1a29bd6c68b8ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6b3db3e8625a3cba1240f0b5e1a29bd6c68b8ca"}], "stats": {"total": 75, "additions": 65, "deletions": 10}, "files": [{"sha": "7ba02bed0fb7bc41367c18ea7bf729b9bce9eeb8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4a4fb516688d7cfe28a80a4aa333f4ecf0b518/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4a4fb516688d7cfe28a80a4aa333f4ecf0b518/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=be4a4fb516688d7cfe28a80a4aa333f4ecf0b518", "patch": "@@ -4503,6 +4503,12 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define CONSTRUCTOR_IS_PAREN_INIT(NODE) \\\n   (CONSTRUCTOR_CHECK(NODE)->base.private_flag)\n \n+/* True if reshape_init built this CONSTRUCTOR to undo the brace elision\n+   of another CONSTRUCTOR.  This flag is used during C++20 aggregate\n+   CTAD.  */\n+#define CONSTRUCTOR_BRACES_ELIDED_P(NODE) \\\n+  (CONSTRUCTOR_CHECK (NODE)->base.protected_flag)\n+\n /* True if NODE represents a conversion for direct-initialization in a\n    template.  Set by perform_implicit_conversion_flags.  */\n #define IMPLICIT_CONV_EXPR_DIRECT_INIT(NODE) \\"}, {"sha": "3414cbdc876086c07942fe63488eb7567da047fc", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4a4fb516688d7cfe28a80a4aa333f4ecf0b518/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4a4fb516688d7cfe28a80a4aa333f4ecf0b518/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=be4a4fb516688d7cfe28a80a4aa333f4ecf0b518", "patch": "@@ -6657,7 +6657,8 @@ reshape_init_r (tree type, reshape_iter *d, tree first_initializer_p,\n   /* A non-aggregate type is always initialized with a single\n      initializer.  */\n   if (!CP_AGGREGATE_TYPE_P (type)\n-      /* As is an array with dependent bound.  */\n+      /* As is an array with dependent bound, which we can see\n+\t during C++20 aggregate CTAD.  */\n       || (cxx_dialect >= cxx20\n \t  && TREE_CODE (type) == ARRAY_TYPE\n \t  && uses_template_parms (TYPE_DOMAIN (type))))\n@@ -6774,6 +6775,7 @@ reshape_init_r (tree type, reshape_iter *d, tree first_initializer_p,\n      initializer already, and there is not a CONSTRUCTOR, it means that there\n      is a missing set of braces (that is, we are processing the case for\n      which reshape_init exists).  */\n+  bool braces_elided_p = false;\n   if (!first_initializer_p)\n     {\n       if (TREE_CODE (stripped_init) == CONSTRUCTOR)\n@@ -6809,17 +6811,25 @@ reshape_init_r (tree type, reshape_iter *d, tree first_initializer_p,\n \twarning (OPT_Wmissing_braces,\n \t\t \"missing braces around initializer for %qT\",\n \t\t type);\n+      braces_elided_p = true;\n     }\n \n   /* Dispatch to specialized routines.  */\n+  tree new_init;\n   if (CLASS_TYPE_P (type))\n-    return reshape_init_class (type, d, first_initializer_p, complain);\n+    new_init = reshape_init_class (type, d, first_initializer_p, complain);\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n-    return reshape_init_array (type, d, first_initializer_p, complain);\n+    new_init = reshape_init_array (type, d, first_initializer_p, complain);\n   else if (VECTOR_TYPE_P (type))\n-    return reshape_init_vector (type, d, complain);\n+    new_init = reshape_init_vector (type, d, complain);\n   else\n     gcc_unreachable();\n+\n+  if (braces_elided_p\n+      && TREE_CODE (new_init) == CONSTRUCTOR)\n+    CONSTRUCTOR_BRACES_ELIDED_P (new_init) = true;\n+\n+  return new_init;\n }\n \n /* Undo the brace-elision allowed by [dcl.init.aggr] in a"}, {"sha": "020a4bf2f6d620ca91e4400de9f291e781a750e7", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4a4fb516688d7cfe28a80a4aa333f4ecf0b518/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4a4fb516688d7cfe28a80a4aa333f4ecf0b518/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=be4a4fb516688d7cfe28a80a4aa333f4ecf0b518", "patch": "@@ -28837,12 +28837,7 @@ collect_ctor_idx_types (tree ctor, tree list, tree elt = NULL_TREE)\n     {\n       tree ftype = elt ? elt : TREE_TYPE (idx);\n       if (BRACE_ENCLOSED_INITIALIZER_P (val)\n-\t  && CONSTRUCTOR_NELTS (val)\n-\t  /* As in reshape_init_r, a non-aggregate or array-of-dependent-bound\n-\t     type gets a single initializer.  */\n-\t  && CP_AGGREGATE_TYPE_P (ftype)\n-\t  && !(TREE_CODE (ftype) == ARRAY_TYPE\n-\t       && uses_template_parms (TYPE_DOMAIN (ftype))))\n+\t  && CONSTRUCTOR_BRACES_ELIDED_P (val))\n \t{\n \t  tree subelt = NULL_TREE;\n \t  if (TREE_CODE (ftype) == ARRAY_TYPE)"}, {"sha": "c4806de56af85b1910510ca19d36e17e37095fdb", "filename": "gcc/testsuite/g++.dg/cpp2a/class-deduction-aggr11.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4a4fb516688d7cfe28a80a4aa333f4ecf0b518/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-aggr11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4a4fb516688d7cfe28a80a4aa333f4ecf0b518/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-aggr11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-aggr11.C?ref=be4a4fb516688d7cfe28a80a4aa333f4ecf0b518", "patch": "@@ -0,0 +1,29 @@\n+// PR c++/101344\n+// { dg-do compile { target c++20 } }\n+\n+template<class T=void>\n+struct A { int m; int t[2]; };\n+\n+A a1{1, {2, 3}}; // previously rejected\n+A a2{1, 2, 3};\n+\n+struct B { int x, y; };\n+\n+template<class T=void>\n+struct C { int m; struct { int x, y; } t; };\n+\n+A b1{1, {2, 3}}; // previously rejected\n+A b2{1, 2, 3};\n+\n+template<class T>\n+struct D { T t[2]; };\n+\n+D d1{1, 2};\n+D d2{{1, 2}}; // previously rejected\n+\n+template<class T>\n+struct E { T t[2][2]; };\n+\n+E e1{1, 2, 3, 4};\n+E e2{{{1, 2}, {3, 4}}}; // previously rejected\n+E e3{{1, 2, 3, 4}}; // { dg-error \"deduction|no match\" }"}, {"sha": "ebe73c1d81724019e60debbba2961b524879a754", "filename": "gcc/testsuite/g++.dg/cpp2a/class-deduction-aggr12.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4a4fb516688d7cfe28a80a4aa333f4ecf0b518/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-aggr12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4a4fb516688d7cfe28a80a4aa333f4ecf0b518/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-aggr12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-aggr12.C?ref=be4a4fb516688d7cfe28a80a4aa333f4ecf0b518", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/101820\n+// { dg-do compile { target c++20 } }\n+\n+struct Inner { int i = 0; };\n+\n+template <typename T = void>\n+struct Outer { Inner s{}; };\n+\n+Outer o1{ .s = {} };                // works\n+Outer o2{ .s = Inner{ .i = 1} };    // works\n+Outer o3{ .s = { .i = 1} };         // does not\n+\n+Outer o4{ .s{} };                   // works\n+Outer o5{ .s{Inner{ .i = 1} } };    // works\n+Outer o6{ .s{ .i = 1} };            // does not"}]}