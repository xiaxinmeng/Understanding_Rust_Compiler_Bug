{"sha": "0256a844ad94bf507b3baac9399f5e1ac68f6151", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI1NmE4NDRhZDk0YmY1MDdiM2JhYWM5Mzk5ZjVlMWFjNjhmNjE1MQ==", "commit": {"author": {"name": "Matthew Fortune", "email": "matthew.fortune@imgtec.com", "date": "2015-07-15T11:42:50Z"}, "committer": {"name": "Robert Suchanek", "email": "rts@gcc.gnu.org", "date": "2015-07-15T11:42:50Z"}, "message": "Support new interrupt handler options.\n\ngcc/\n\t* config/mips/mips.c (mips_int_mask): New enum.\n\t(mips_shadow_set): Likewise.\n\t(int_mask): New variable.\n\t(use_shadow_register_set_p): Change type to enum mips_shadow_set.\n\t(machine_function): Add int_mask and use_shadow_register_set.\n\t(mips_attribute_table): Add attribute handlers for interrupt and\n\tuse_shadow_register_set.\n\t(mips_interrupt_mask): New static function.\n\t(mips_handle_interrupt_attr): Likewise.\n\t(mips_handle_use_shadow_register_set_attr): Likewise.\n\t(mips_use_shadow_register_set): Change return type to enum\n\tmips_shadow_set.  Add argument handling for use_shadow_register_set\n\tattribute.\n\t(mips_interrupt_extra_called_saved_reg_p): Update the conditional to\n\tcompare with mips_shadow_set enum.\n\t(mips_compute_frame_info): Add interrupt mask and\n\tuse_shadow_register_set to per-function information structure.\n\tAdd a stack slot for EPC unconditionally.\n\t(mips_expand_prologue): Compare use_shadow_register_set value\n\twith mips_shadow_set enum.  Save EPC always in K1, clobber only K1 for\n\tmasked interrupt register but in EIC mode use K0 and save Cause in K0.\n\tEPC saved and restored unconditionally.  Use PMODE_INSN macro when\n\tcopying the stack pointer from the shadow register set.\n\t* config/mips/mips.h (SR_IM0): New define.\n\t* config/mips/mips.md (mips_rdpgpr): Rename to...\n\t(mips_rdpgpr_<mode>): ...this.  Use the Pmode iterator.\n\t* doc/extend.texi (Declaring Attributes of Functions): Document\n\toptional arguments for interrupt and use_shadow_register_set\n\tattributes.\n\ngcc/testsuite/\n\t* gcc.target/mips/interrupt_handler-4.c: New test.\n\nCo-Authored-By: Robert Suchanek <robert.suchanek@imgtec.com>\n\nFrom-SVN: r225819", "tree": {"sha": "e9b7d753550000d760f1fb0ec005461f7e7839c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9b7d753550000d760f1fb0ec005461f7e7839c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0256a844ad94bf507b3baac9399f5e1ac68f6151", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0256a844ad94bf507b3baac9399f5e1ac68f6151", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0256a844ad94bf507b3baac9399f5e1ac68f6151", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0256a844ad94bf507b3baac9399f5e1ac68f6151/comments", "author": {"login": "mfortune", "id": 10220247, "node_id": "MDQ6VXNlcjEwMjIwMjQ3", "avatar_url": "https://avatars.githubusercontent.com/u/10220247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mfortune", "html_url": "https://github.com/mfortune", "followers_url": "https://api.github.com/users/mfortune/followers", "following_url": "https://api.github.com/users/mfortune/following{/other_user}", "gists_url": "https://api.github.com/users/mfortune/gists{/gist_id}", "starred_url": "https://api.github.com/users/mfortune/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mfortune/subscriptions", "organizations_url": "https://api.github.com/users/mfortune/orgs", "repos_url": "https://api.github.com/users/mfortune/repos", "events_url": "https://api.github.com/users/mfortune/events{/privacy}", "received_events_url": "https://api.github.com/users/mfortune/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6a2b848b31c45cc2e5d3371a4ed3e7b49ee7ae7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a2b848b31c45cc2e5d3371a4ed3e7b49ee7ae7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a2b848b31c45cc2e5d3371a4ed3e7b49ee7ae7e"}], "stats": {"total": 390, "additions": 328, "deletions": 62}, "files": [{"sha": "64208db51a2f9088b06fa4f6dd2bc32e255629dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0256a844ad94bf507b3baac9399f5e1ac68f6151/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0256a844ad94bf507b3baac9399f5e1ac68f6151/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0256a844ad94bf507b3baac9399f5e1ac68f6151", "patch": "@@ -1,3 +1,36 @@\n+2015-07-15  Matthew Fortune  <matthew.fortune@imgtec.com>\n+\t    Robert Suchanek  <robert.suchanek@imgtec.com>\n+\n+\t* config/mips/mips.c (mips_int_mask): New enum.\n+\t(mips_shadow_set): Likewise.\n+\t(int_mask): New variable.\n+\t(use_shadow_register_set_p): Change type to enum mips_shadow_set.\n+\t(machine_function): Add int_mask and use_shadow_register_set.\n+\t(mips_attribute_table): Add attribute handlers for interrupt and\n+\tuse_shadow_register_set.\n+\t(mips_interrupt_mask): New static function.\n+\t(mips_handle_interrupt_attr): Likewise.\n+\t(mips_handle_use_shadow_register_set_attr): Likewise.\n+\t(mips_use_shadow_register_set): Change return type to enum\n+\tmips_shadow_set.  Add argument handling for use_shadow_register_set\n+\tattribute.\n+\t(mips_interrupt_extra_called_saved_reg_p): Update the conditional to\n+\tcompare with mips_shadow_set enum.\n+\t(mips_compute_frame_info): Add interrupt mask and\n+\tuse_shadow_register_set to per-function information structure.\n+\tAdd a stack slot for EPC unconditionally.\n+\t(mips_expand_prologue): Compare use_shadow_register_set value\n+\twith mips_shadow_set enum.  Save EPC always in K1, clobber only K1 for\n+\tmasked interrupt register but in EIC mode use K0 and save Cause in K0.\n+\tEPC saved and restored unconditionally.  Use PMODE_INSN macro when\n+\tcopying the stack pointer from the shadow register set.\n+\t* config/mips/mips.h (SR_IM0): New define.\n+\t* config/mips/mips.md (mips_rdpgpr): Rename to...\n+\t(mips_rdpgpr_<mode>): ...this.  Use the Pmode iterator.\n+\t* doc/extend.texi (Declaring Attributes of Functions): Document\n+\toptional arguments for interrupt and use_shadow_register_set\n+\tattributes.\n+\n 2015-07-15  Robert Suchanek  <robert.suchanek@imgtec.com>\n \n \t* config/mips/mips.c (mips_compute_frame_info): Allow -mhard-float in"}, {"sha": "70240f7bf68f959c17f658b96d85798299e07975", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 234, "deletions": 52, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0256a844ad94bf507b3baac9399f5e1ac68f6151/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0256a844ad94bf507b3baac9399f5e1ac68f6151/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=0256a844ad94bf507b3baac9399f5e1ac68f6151", "patch": "@@ -382,6 +382,30 @@ struct GTY(())  mips_frame_info {\n   HOST_WIDE_INT hard_frame_pointer_offset;\n };\n \n+/* Enumeration for masked vectored (VI) and non-masked (EIC) interrupts.  */\n+enum mips_int_mask\n+{\n+  INT_MASK_EIC = -1,\n+  INT_MASK_SW0 = 0,\n+  INT_MASK_SW1 = 1,\n+  INT_MASK_HW0 = 2,\n+  INT_MASK_HW1 = 3,\n+  INT_MASK_HW2 = 4,\n+  INT_MASK_HW3 = 5,\n+  INT_MASK_HW4 = 6,\n+  INT_MASK_HW5 = 7\n+};\n+\n+/* Enumeration to mark the existence of the shadow register set.\n+   SHADOW_SET_INTSTACK indicates a shadow register set with a valid stack\n+   pointer.  */\n+enum mips_shadow_set\n+{\n+  SHADOW_SET_NO,\n+  SHADOW_SET_YES,\n+  SHADOW_SET_INTSTACK\n+};\n+\n struct GTY(())  machine_function {\n   /* The next floating-point condition-code register to allocate\n      for ISA_HAS_8CC targets, relative to ST_REG_FIRST.  */\n@@ -434,8 +458,12 @@ struct GTY(())  machine_function {\n   /* True if this is an interrupt handler.  */\n   bool interrupt_handler_p;\n \n-  /* True if this is an interrupt handler that uses shadow registers.  */\n-  bool use_shadow_register_set_p;\n+  /* Records the way in which interrupts should be masked.  Only used if\n+     interrupts are not kept masked.  */\n+  enum mips_int_mask int_mask;\n+\n+  /* Records if this is an interrupt handler that uses shadow registers.  */\n+  enum mips_shadow_set use_shadow_register_set;\n \n   /* True if this is an interrupt handler that should keep interrupts\n      masked.  */\n@@ -717,6 +745,10 @@ const enum reg_class mips_regno_to_class[FIRST_PSEUDO_REGISTER] = {\n   ALL_REGS,\tALL_REGS,\tALL_REGS,\tALL_REGS\n };\n \n+static tree mips_handle_interrupt_attr (tree *, tree, tree, int, bool *);\n+static tree mips_handle_use_shadow_register_set_attr (tree *, tree, tree, int,\n+\t\t\t\t\t\t      bool *);\n+\n /* The value of TARGET_ATTRIBUTE_TABLE.  */\n static const struct attribute_spec mips_attribute_table[] = {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n@@ -734,8 +766,10 @@ static const struct attribute_spec mips_attribute_table[] = {\n   { \"nomicromips\", 0, 0, true,  false, false, NULL, false },\n   { \"nocompression\", 0, 0, true,  false, false, NULL, false },\n   /* Allow functions to be specified as interrupt handlers */\n-  { \"interrupt\",   0, 0, false, true,  true, NULL, false },\n-  { \"use_shadow_register_set\",\t0, 0, false, true,  true, NULL, false },\n+  { \"interrupt\",   0, 1, false, true,  true, mips_handle_interrupt_attr,\n+    false },\n+  { \"use_shadow_register_set\",\t0, 1, false, true,  true,\n+    mips_handle_use_shadow_register_set_attr, false },\n   { \"keep_interrupts_masked\",\t0, 0, false, true,  true, NULL, false },\n   { \"use_debug_exception_return\", 0, 0, false, true,  true, NULL, false },\n   { NULL,\t   0, 0, false, false, false, NULL, false }\n@@ -1317,13 +1351,65 @@ mips_interrupt_type_p (tree type)\n   return lookup_attribute (\"interrupt\", TYPE_ATTRIBUTES (type)) != NULL;\n }\n \n-/* Check if the attribute to use shadow register set is set for a function.  */\n+/* Return the mask for the \"interrupt\" attribute.  */\n \n-static bool\n-mips_use_shadow_register_set_p (tree type)\n+static enum mips_int_mask\n+mips_interrupt_mask (tree type)\n {\n-  return lookup_attribute (\"use_shadow_register_set\",\n-\t\t\t   TYPE_ATTRIBUTES (type)) != NULL;\n+  tree attr = lookup_attribute (\"interrupt\", TYPE_ATTRIBUTES (type));\n+  tree args, cst;\n+  const char *str;\n+\n+  /* For missing attributes or no arguments then return 'eic' as a safe\n+     fallback.  */\n+  if (attr == NULL)\n+    return INT_MASK_EIC;\n+\n+  args = TREE_VALUE (attr);\n+\n+  if (args == NULL)\n+    return INT_MASK_EIC;\n+\n+  cst = TREE_VALUE (args);\n+\n+  if (strcmp (TREE_STRING_POINTER (cst), \"eic\") == 0)\n+    return INT_MASK_EIC;\n+\n+  /* The validation code in mips_handle_interrupt_attr guarantees that the\n+     argument is now in the form:\n+     vector=(sw0|sw1|hw0|hw1|hw2|hw3|hw4|hw5).  */\n+  str = TREE_STRING_POINTER (cst);\n+\n+  gcc_assert (strlen (str) == strlen (\"vector=sw0\"));\n+\n+  if (str[7] == 's')\n+    return (enum mips_int_mask) (INT_MASK_SW0 + (str[9] - '0'));\n+\n+  return (enum mips_int_mask) (INT_MASK_HW0 + (str[9] - '0'));\n+}\n+\n+/* Return the mips_shadow_set if the \"use_shadow_register_set\" attribute is\n+   set for a function.  */\n+\n+static enum mips_shadow_set\n+mips_use_shadow_register_set (tree type)\n+{\n+  tree attr = lookup_attribute (\"use_shadow_register_set\",\n+\t\t\t\tTYPE_ATTRIBUTES (type));\n+  tree args;\n+\n+  /* The validation code in mips_handle_use_shadow_register_set_attr guarantees\n+     that if an argument is present then it means: Assume the shadow register\n+     set has a valid stack pointer in it.  */\n+  if (attr == NULL)\n+    return SHADOW_SET_NO;\n+\n+  args = TREE_VALUE (attr);\n+\n+  if (args == NULL)\n+    return SHADOW_SET_YES;\n+\n+  return SHADOW_SET_INTSTACK;\n }\n \n /* Check if the attribute to keep interrupts masked is set for a function.  */\n@@ -1529,6 +1615,92 @@ mips_can_inline_p (tree caller, tree callee)\n     return false;\n   return default_target_can_inline_p (caller, callee);\n }\n+\n+/* Handle an \"interrupt\" attribute with an optional argument.  */\n+\n+static tree\n+mips_handle_interrupt_attr (tree *node ATTRIBUTE_UNUSED, tree name, tree args,\n+\t\t\t    int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)\n+{\n+  /* Check for an argument.  */\n+  if (is_attribute_p (\"interrupt\", name) && args != NULL)\n+    {\n+      tree cst;\n+\n+      cst = TREE_VALUE (args);\n+      if (TREE_CODE (cst) != STRING_CST)\n+\t{\n+\t  warning (OPT_Wattributes,\n+\t\t   \"%qE attribute requires a string argument\",\n+\t\t   name);\n+\t  *no_add_attrs = true;\n+\t}\n+      else if (strcmp (TREE_STRING_POINTER (cst), \"eic\") != 0\n+\t       && strncmp (TREE_STRING_POINTER (cst), \"vector=\", 7) != 0)\n+\t{\n+\t  warning (OPT_Wattributes,\n+\t\t   \"argument to %qE attribute is neither eic, nor \"\n+\t\t   \"vector=<line>\", name);\n+\t  *no_add_attrs = true;\n+\t}\n+      else if (strncmp (TREE_STRING_POINTER (cst), \"vector=\", 7) == 0)\n+\t{\n+\t  const char *arg = TREE_STRING_POINTER (cst) + 7;\n+\n+\t  /* Acceptable names are: sw0,sw1,hw0,hw1,hw2,hw3,hw4,hw5.  */\n+\t  if (strlen (arg) != 3\n+\t      || (arg[0] != 's' && arg[0] != 'h')\n+\t      || arg[1] != 'w'\n+\t      || (arg[0] == 's' && arg[2] != '0' && arg[2] != '1')\n+\t      || (arg[0] == 'h' && (arg[2] < '0' || arg[2] > '5')))\n+\t    {\n+\t      warning (OPT_Wattributes,\n+\t\t       \"interrupt vector to %qE attribute is not \"\n+\t\t       \"vector=(sw0|sw1|hw0|hw1|hw2|hw3|hw4|hw5)\",\n+\t\t       name);\n+\t      *no_add_attrs = true;\n+\t    }\n+\t}\n+\n+      return NULL_TREE;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"use_shadow_register_set\" attribute with an optional argument.  */\n+\n+static tree\n+mips_handle_use_shadow_register_set_attr (tree *node ATTRIBUTE_UNUSED,\n+\t\t\t\t\t  tree name, tree args,\n+\t\t\t\t\t  int flags ATTRIBUTE_UNUSED,\n+\t\t\t\t\t  bool *no_add_attrs)\n+{\n+  /* Check for an argument.  */\n+  if (is_attribute_p (\"use_shadow_register_set\", name) && args != NULL)\n+    {\n+      tree cst;\n+\n+      cst = TREE_VALUE (args);\n+      if (TREE_CODE (cst) != STRING_CST)\n+\t{\n+\t  warning (OPT_Wattributes,\n+\t\t   \"%qE attribute requires a string argument\",\n+\t\t   name);\n+\t  *no_add_attrs = true;\n+\t}\n+      else if (strcmp (TREE_STRING_POINTER (cst), \"intstack\") != 0)\n+\t{\n+\t  warning (OPT_Wattributes,\n+\t\t   \"argument to %qE attribute is not intstack\", name);\n+\t  *no_add_attrs = true;\n+\t}\n+\n+      return NULL_TREE;\n+    }\n+\n+  return NULL_TREE;\n+}\n \f\n /* If X is a PLUS of a CONST_INT, return the two terms in *BASE_PTR\n    and *OFFSET_PTR.  Return X in *BASE_PTR and 0 in *OFFSET_PTR otherwise.  */\n@@ -10047,7 +10219,8 @@ mips_interrupt_extra_call_saved_reg_p (unsigned int regno)\n   if (TARGET_DSP && DSP_ACC_REG_P (regno))\n     return true;\n \n-  if (GP_REG_P (regno) && !cfun->machine->use_shadow_register_set_p)\n+  if (GP_REG_P (regno)\n+      && cfun->machine->use_shadow_register_set == SHADOW_SET_NO)\n     {\n       /* $0 is hard-wired.  */\n       if (regno == GP_REG_FIRST)\n@@ -10259,8 +10432,10 @@ mips_compute_frame_info (void)\n       else\n \t{\n \t  cfun->machine->interrupt_handler_p = true;\n-\t  cfun->machine->use_shadow_register_set_p =\n-\t    mips_use_shadow_register_set_p (TREE_TYPE (current_function_decl));\n+\t  cfun->machine->int_mask =\n+\t    mips_interrupt_mask (TREE_TYPE (current_function_decl));\n+\t  cfun->machine->use_shadow_register_set =\n+\t    mips_use_shadow_register_set (TREE_TYPE (current_function_decl));\n \t  cfun->machine->keep_interrupts_masked_p =\n \t    mips_keep_interrupts_masked_p (TREE_TYPE (current_function_decl));\n \t  cfun->machine->use_debug_exception_return_p =\n@@ -10375,9 +10550,9 @@ mips_compute_frame_info (void)\n       /* All interrupt context functions need space to preserve STATUS.  */\n       frame->num_cop0_regs++;\n \n-      /* If we don't keep interrupts masked, we need to save EPC.  */\n-      if (!cfun->machine->keep_interrupts_masked_p)\n-\tframe->num_cop0_regs++;\n+      /* We need to save EPC regardless of whether interrupts remain masked\n+\t as exceptions will corrupt EPC.  */\n+      frame->num_cop0_regs++;\n     }\n \n   /* Move above the accumulator save area.  */\n@@ -11418,21 +11593,21 @@ mips_expand_prologue (void)\n \n \t      /* If this interrupt is using a shadow register set, we need to\n \t\t get the stack pointer from the previous register set.  */\n-\t      if (cfun->machine->use_shadow_register_set_p)\n-\t\temit_insn (gen_mips_rdpgpr (stack_pointer_rtx,\n-\t\t\t\t\t    stack_pointer_rtx));\n+\t      if (cfun->machine->use_shadow_register_set == SHADOW_SET_YES)\n+\t\temit_insn (PMODE_INSN (gen_mips_rdpgpr, (stack_pointer_rtx,\n+\t\t\t\t\t\t\t stack_pointer_rtx)));\n \n \t      if (!cfun->machine->keep_interrupts_masked_p)\n \t\t{\n-\t\t  /* Move from COP0 Cause to K0.  */\n-\t\t  emit_insn (gen_cop0_move (gen_rtx_REG (SImode, K0_REG_NUM),\n-\t\t\t\t\t    gen_rtx_REG (SImode,\n-\t\t\t\t\t\t\t COP0_CAUSE_REG_NUM)));\n-\t\t  /* Move from COP0 EPC to K1.  */\n-\t\t  emit_insn (gen_cop0_move (gen_rtx_REG (SImode, K1_REG_NUM),\n-\t\t\t\t\t    gen_rtx_REG (SImode,\n-\t\t\t\t\t\t\t COP0_EPC_REG_NUM)));\n+\t\t  if (cfun->machine->int_mask == INT_MASK_EIC)\n+\t\t    /* Move from COP0 Cause to K0.  */\n+\t\t    emit_insn (gen_cop0_move (gen_rtx_REG (SImode, K0_REG_NUM),\n+\t\t\tgen_rtx_REG (SImode, COP0_CAUSE_REG_NUM)));\n \t\t}\n+\t      /* Move from COP0 EPC to K1.  */\n+\t      emit_insn (gen_cop0_move (gen_rtx_REG (SImode, K1_REG_NUM),\n+\t\t\t\t\tgen_rtx_REG (SImode,\n+\t\t\t\t\t\t     COP0_EPC_REG_NUM)));\n \n \t      /* Allocate the first part of the frame.  */\n \t      rtx insn = gen_add3_insn (stack_pointer_rtx, stack_pointer_rtx,\n@@ -11443,23 +11618,22 @@ mips_expand_prologue (void)\n \n \t      /* Start at the uppermost location for saving.  */\n \t      offset = frame->cop0_sp_offset - size;\n-\t      if (!cfun->machine->keep_interrupts_masked_p)\n-\t\t{\n-\t\t  /* Push EPC into its stack slot.  */\n-\t\t  mem = gen_frame_mem (word_mode,\n-\t\t\t\t       plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t      offset));\n-\t\t  mips_emit_move (mem, gen_rtx_REG (word_mode, K1_REG_NUM));\n-\t\t  offset -= UNITS_PER_WORD;\n-\t\t}\n+\n+\t      /* Push EPC into its stack slot.  */\n+\t      mem = gen_frame_mem (word_mode,\n+\t\t\t\t   plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t  offset));\n+\t      mips_emit_move (mem, gen_rtx_REG (word_mode, K1_REG_NUM));\n+\t      offset -= UNITS_PER_WORD;\n \n \t      /* Move from COP0 Status to K1.  */\n \t      emit_insn (gen_cop0_move (gen_rtx_REG (SImode, K1_REG_NUM),\n \t\t\t\t\tgen_rtx_REG (SImode,\n \t\t\t\t\t\t     COP0_STATUS_REG_NUM)));\n \n \t      /* Right justify the RIPL in k0.  */\n-\t      if (!cfun->machine->keep_interrupts_masked_p)\n+\t      if (!cfun->machine->keep_interrupts_masked_p\n+\t\t  && cfun->machine->int_mask == INT_MASK_EIC)\n \t\temit_insn (gen_lshrsi3 (gen_rtx_REG (SImode, K0_REG_NUM),\n \t\t\t\t\tgen_rtx_REG (SImode, K0_REG_NUM),\n \t\t\t\t\tGEN_INT (CAUSE_IPL)));\n@@ -11472,12 +11646,22 @@ mips_expand_prologue (void)\n \t      offset -= UNITS_PER_WORD;\n \n \t      /* Insert the RIPL into our copy of SR (k1) as the new IPL.  */\n-\t      if (!cfun->machine->keep_interrupts_masked_p)\n+\t      if (!cfun->machine->keep_interrupts_masked_p\n+\t\t  && cfun->machine->int_mask == INT_MASK_EIC)\n \t\temit_insn (gen_insvsi (gen_rtx_REG (SImode, K1_REG_NUM),\n \t\t\t\t       GEN_INT (6),\n \t\t\t\t       GEN_INT (SR_IPL),\n \t\t\t\t       gen_rtx_REG (SImode, K0_REG_NUM)));\n \n+\t      /* Clear all interrupt mask bits up to and including the\n+\t\t handler's interrupt line.  */\n+\t      if (!cfun->machine->keep_interrupts_masked_p\n+\t\t  && cfun->machine->int_mask != INT_MASK_EIC)\n+\t\temit_insn (gen_insvsi (gen_rtx_REG (SImode, K1_REG_NUM),\n+\t\t\t\t       GEN_INT (cfun->machine->int_mask + 1),\n+\t\t\t\t       GEN_INT (SR_IM0),\n+\t\t\t\t       gen_rtx_REG (SImode, GP_REG_FIRST)));\n+\n \t      if (!cfun->machine->keep_interrupts_masked_p)\n \t\t/* Enable interrupts by clearing the KSU ERL and EXL bits.\n \t\t   IE is already the correct value, so we don't have to do\n@@ -11846,37 +12030,35 @@ mips_expand_epilogue (bool sibcall_p)\n \t  rtx mem;\n \n \t  offset = frame->cop0_sp_offset - (frame->total_size - step2);\n-\t  if (!cfun->machine->keep_interrupts_masked_p)\n-\t    {\n-\t      /* Restore the original EPC.  */\n-\t      mem = gen_frame_mem (word_mode,\n-\t\t\t\t   plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t  offset));\n-\t      mips_emit_move (gen_rtx_REG (word_mode, K0_REG_NUM), mem);\n-\t      offset -= UNITS_PER_WORD;\n \n-\t      /* Move to COP0 EPC.  */\n-\t      emit_insn (gen_cop0_move (gen_rtx_REG (SImode, COP0_EPC_REG_NUM),\n-\t\t\t\t\tgen_rtx_REG (SImode, K0_REG_NUM)));\n-\t    }\n+\t  /* Restore the original EPC.  */\n+\t  mem = gen_frame_mem (word_mode,\n+\t\t\t       plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t      offset));\n+\t  mips_emit_move (gen_rtx_REG (word_mode, K1_REG_NUM), mem);\n+\t  offset -= UNITS_PER_WORD;\n+\n+\t  /* Move to COP0 EPC.  */\n+\t  emit_insn (gen_cop0_move (gen_rtx_REG (SImode, COP0_EPC_REG_NUM),\n+\t\t\t\t    gen_rtx_REG (SImode, K1_REG_NUM)));\n \n \t  /* Restore the original Status.  */\n \t  mem = gen_frame_mem (word_mode,\n \t\t\t       plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t      offset));\n-\t  mips_emit_move (gen_rtx_REG (word_mode, K0_REG_NUM), mem);\n+\t  mips_emit_move (gen_rtx_REG (word_mode, K1_REG_NUM), mem);\n \t  offset -= UNITS_PER_WORD;\n \n \t  /* If we don't use shadow register set, we need to update SP.  */\n-\t  if (!cfun->machine->use_shadow_register_set_p)\n+\t  if (cfun->machine->use_shadow_register_set == SHADOW_SET_NO)\n \t    mips_deallocate_stack (stack_pointer_rtx, GEN_INT (step2), 0);\n \t  else\n \t    /* The choice of position is somewhat arbitrary in this case.  */\n \t    mips_epilogue_emit_cfa_restores ();\n \n \t  /* Move to COP0 Status.  */\n \t  emit_insn (gen_cop0_move (gen_rtx_REG (SImode, COP0_STATUS_REG_NUM),\n-\t\t\t\t    gen_rtx_REG (SImode, K0_REG_NUM)));\n+\t\t\t\t    gen_rtx_REG (SImode, K1_REG_NUM)));\n \t}\n       else if (TARGET_MICROMIPS\n \t       && !crtl->calls_eh_return"}, {"sha": "37f5b54c8b1f3113966bf54d0caf68d99f814976", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0256a844ad94bf507b3baac9399f5e1ac68f6151/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0256a844ad94bf507b3baac9399f5e1ac68f6151/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=0256a844ad94bf507b3baac9399f5e1ac68f6151", "patch": "@@ -1811,6 +1811,9 @@ FP_ASM_SPEC \"\\\n #define SR_COP1         29\n /* Interrupt Priority Level is from bit 10 to bit 15 of the status register.  */\n #define SR_IPL\t\t10\n+/* Interrupt masks start with IM0 at bit 8 to IM7 at bit 15 of the status\n+   register.  */\n+#define SR_IM0\t\t8\n /* Exception Level is at bit 1 of the status register.  */\n #define SR_EXL\t\t1\n /* Interrupt Enable is at bit 0 of the status register.  */"}, {"sha": "ad8ad9fff72354dbd75e2d4f306c415fc4b27b74", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0256a844ad94bf507b3baac9399f5e1ac68f6151/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0256a844ad94bf507b3baac9399f5e1ac68f6151/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=0256a844ad94bf507b3baac9399f5e1ac68f6151", "patch": "@@ -6564,14 +6564,14 @@\n    (set_attr \"mode\"\t\"none\")])\n \n ;; Read GPR from previous shadow register set.\n-(define_insn \"mips_rdpgpr\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(unspec_volatile:SI [(match_operand:SI 1 \"register_operand\" \"d\")]\n-\t\t\t    UNSPEC_RDPGPR))]\n+(define_insn \"mips_rdpgpr_<mode>\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=d\")\n+\t(unspec_volatile:P [(match_operand:P 1 \"register_operand\" \"d\")]\n+\t\t\t   UNSPEC_RDPGPR))]\n   \"\"\n   \"rdpgpr\\t%0,%1\"\n   [(set_attr \"type\"\t\"move\")\n-   (set_attr \"mode\"\t\"SI\")])\n+   (set_attr \"mode\"\t\"<MODE>\")])\n \n ;; Move involving COP0 registers.\n (define_insn \"cop0_move\""}, {"sha": "b18d8fb11e034d32379c9a90910d2f71f90c99e8", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0256a844ad94bf507b3baac9399f5e1ac68f6151/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0256a844ad94bf507b3baac9399f5e1ac68f6151/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=0256a844ad94bf507b3baac9399f5e1ac68f6151", "patch": "@@ -4090,18 +4090,28 @@ These function attributes are supported by the MIPS back end:\n @table @code\n @item interrupt\n @cindex @code{interrupt} function attribute, MIPS\n-Use this attribute to indicate\n-that the specified function is an interrupt handler.  The compiler generates\n-function entry and exit sequences suitable for use in an interrupt handler\n-when this attribute is present.\n+Use this attribute to indicate that the specified function is an interrupt\n+handler.  The compiler generates function entry and exit sequences suitable\n+for use in an interrupt handler when this attribute is present.\n+An optional argument is supported for the interrupt attribute which allows\n+the interrupt mode to be described.  By default GCC assumes the external\n+interrupt controller (EIC) mode is in use, this can be explicitly set using\n+@code{eic}.  When interrupts are non-masked then the requested Interrupt\n+Priority Level (IPL) is copied to the current IPL which has the effect of only\n+enabling higher priority interrupts.  To use vectored interrupt mode use\n+the argument @code{vector=[sw0|sw1|hw0|hw1|hw2|hw3|hw4|hw5]}, this will change\n+the behaviour of the non-masked interrupt support and GCC will arrange to mask\n+all interrupts from sw0 up to and including the specified interrupt vector.\n \n You can use the following attributes to modify the behavior\n of an interrupt handler:\n @table @code\n @item use_shadow_register_set\n @cindex @code{use_shadow_register_set} function attribute, MIPS\n Assume that the handler uses a shadow register set, instead of\n-the main general-purpose registers.\n+the main general-purpose registers.  An optional argument @code{intstack} is\n+supported to indicate that the shadow register set contains a valid stack\n+pointer.\n \n @item keep_interrupts_masked\n @cindex @code{keep_interrupts_masked} function attribute, MIPS\n@@ -4129,6 +4139,8 @@ void __attribute__ ((interrupt, keep_interrupts_masked,\n void __attribute__ ((interrupt, use_shadow_register_set,\n                      keep_interrupts_masked,\n                      use_debug_exception_return)) v7 ();\n+void __attribute__ ((interrupt(\"eic\"))) v8 ();\n+void __attribute__ ((interrupt(\"vector=hw3\"))) v9 ();\n @end smallexample\n \n @item long_call"}, {"sha": "7b021537c823bfd46145edbf47294b9fc625089f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0256a844ad94bf507b3baac9399f5e1ac68f6151/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0256a844ad94bf507b3baac9399f5e1ac68f6151/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0256a844ad94bf507b3baac9399f5e1ac68f6151", "patch": "@@ -1,3 +1,8 @@\n+2015-07-15  Matthew Fortune  <matthew.fortune@imgtec.com>\n+\t    Robert Suchanek  <robert.suchanek@imgtec.com>\n+\n+\t* gcc.target/mips/interrupt_handler-4.c: New test.\n+\n 2015-07-15  Ilya Enkovich  <enkovich.gnu@gmail.com>\n \n \tPR testsuite/66734"}, {"sha": "6e7c45c5d9c9b83e4b636a33d7557d28d9d57bfa", "filename": "gcc/testsuite/gcc.target/mips/interrupt_handler-4.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0256a844ad94bf507b3baac9399f5e1ac68f6151/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finterrupt_handler-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0256a844ad94bf507b3baac9399f5e1ac68f6151/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finterrupt_handler-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finterrupt_handler-4.c?ref=0256a844ad94bf507b3baac9399f5e1ac68f6151", "patch": "@@ -0,0 +1,31 @@\n+/* Test optional argument for interrupt and use_shadow_register_set\n+   attributes.  */\n+/* { dg-do compile } */\n+/* { dg-options \"isa_rev>=2\" } */\n+/* { dg-final { scan-assembler \"e0:.*ins\\t\\\\\\$27,\\\\\\$26,10,6.*\\.end\\te0\" } } */\n+/* { dg-final { scan-assembler-times \"mfc0\\t\\\\\\$26,\\\\\\$13\" 3 } } */\n+/* { dg-final { scan-assembler-times \"mfc0\\t\\\\\\$27,\\\\\\$14\" 11 } } */\n+/* { dg-final { scan-assembler \"v0:.*ins\\t\\\\\\$27,\\\\\\$0,8,1.*\\.end\\tv0\" } } */\n+/* { dg-final { scan-assembler \"v1:.*ins\\t\\\\\\$27,\\\\\\$0,8,2.*\\.end\\tv1\" } } */\n+/* { dg-final { scan-assembler \"v2:.*ins\\t\\\\\\$27,\\\\\\$0,8,3.*\\.end\\tv2\" } } */\n+/* { dg-final { scan-assembler \"v3:.*ins\\t\\\\\\$27,\\\\\\$0,8,4.*\\.end\\tv3\" } } */\n+/* { dg-final { scan-assembler \"v4:.*ins\\t\\\\\\$27,\\\\\\$0,8,5.*\\.end\\tv4\" } } */\n+/* { dg-final { scan-assembler \"v5:.*ins\\t\\\\\\$27,\\\\\\$0,8,6.*\\.end\\tv5\" } } */\n+/* { dg-final { scan-assembler \"v6:.*ins\\t\\\\\\$27,\\\\\\$0,8,7.*\\.end\\tv6\" } } */\n+/* { dg-final { scan-assembler \"v7:.*ins\\t\\\\\\$27,\\\\\\$0,8,8.*\\.end\\tv7\" } } */\n+\n+/* { dg-final { scan-assembler-times \"rdpgpr\\t\\\\\\$sp,\\\\\\$sp\" 1 } } */\n+/* { dg-final { scan-assembler-not \"s1:.*rdpgpr\\t\\\\\\$sp,\\\\\\$sp.*\\.end\\ts1\" } } */\n+\n+NOMIPS16 void __attribute__ ((interrupt(\"eic\"))) e0 () { }\n+NOMIPS16 void __attribute__ ((interrupt(\"vector=sw0\"))) v0 () { }\n+NOMIPS16 void __attribute__ ((interrupt(\"vector=sw1\"))) v1 () { }\n+NOMIPS16 void __attribute__ ((interrupt(\"vector=hw0\"))) v2 () { }\n+NOMIPS16 void __attribute__ ((interrupt(\"vector=hw1\"))) v3 () { }\n+NOMIPS16 void __attribute__ ((interrupt(\"vector=hw2\"))) v4 () { }\n+NOMIPS16 void __attribute__ ((interrupt(\"vector=hw3\"))) v5 () { }\n+NOMIPS16 void __attribute__ ((interrupt(\"vector=hw4\"))) v6 () { }\n+NOMIPS16 void __attribute__ ((interrupt(\"vector=hw5\"))) v7 () { }\n+\n+NOMIPS16 void __attribute__ ((interrupt, use_shadow_register_set)) s0 () { }\n+NOMIPS16 void __attribute__ ((interrupt, use_shadow_register_set(\"intstack\"))) s1 () { }"}]}