{"sha": "3d0af0c997fe42a7f0963d970a9c495b81041206", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2QwYWYwYzk5N2ZlNDJhN2YwOTYzZDk3MGE5YzQ5NWI4MTA0MTIwNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-09-10T09:25:02Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-09-10T09:25:02Z"}, "message": "lto: Stream current working directory for first streamed relative filename and adjust relative paths [PR93865]\n\nIf the gcc -c -flto ... commands to compile some or all objects are run in a\ndifferent directory (or in different directories) from the directory in\nwhich the gcc -flto link line is invoked, then the .debug_line will be\nincorrect if there are any relative filenames, it will use those relative\nfilenames while .debug_info will contain a different DW_AT_comp_dir.\n\nThe following patch streams (at most once after each clear_line_info)\nthe current working directory (what we record in DW_AT_comp_dir) when\nencountering the first relative pathname, and when reading the location info\nreads it back and if the current working directory at that point is\ndifferent from the saved one, adjusts relative paths by adding a relative\nprefix how to go from the current working directory to the previously saved\npath (with a fallback e.g. for DOS e:\\\\foo vs. d:\\\\bar change to use\nabsolute directory).\n\n2020-09-10  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR debug/93865\n\t* lto-streamer.h (struct output_block): Add emit_pwd member.\n\t* lto-streamer-out.c: Include toplev.h.\n\t(clear_line_info): Set emit_pwd.\n\t(lto_output_location_1): Encode the ob->current_file != xloc.file\n\tbit directly into the location number.  If changing file, emit\n\tadditionally a bit whether pwd is emitted and emit it before the\n\tfirst relative pathname since clear_line_info.\n\t(output_function, output_constructor): Don't call clear_line_info\n\there.\n\t* lto-streamer-in.c (struct string_pair_map): New type.\n\t(struct string_pair_map_hasher): New type.\n\t(string_pair_map_hasher::hash): New method.\n\t(string_pair_map_hasher::equal): New method.\n\t(path_name_pair_hash_table, string_pair_map_allocator): New variables.\n\t(relative_path_prefix, canon_relative_path_prefix,\n\tcanon_relative_file_name): New functions.\n\t(canon_file_name): Add relative_prefix argument, if non-NULL\n\tand string is a relative path, return canon_relative_file_name.\n\t(lto_location_cache::input_location_and_block): Decode file change\n\tbit from the location number.  If changing file, unpack bit whether\n\tpwd is streamed and stream in pwd.  Adjust canon_file_name caller.\n\t(lto_free_file_name_hash): Delete path_name_pair_hash_table\n\tand string_pair_map_allocator.", "tree": {"sha": "8f5a07c519e81d791ee3f7cdc65f452afb045c6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f5a07c519e81d791ee3f7cdc65f452afb045c6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d0af0c997fe42a7f0963d970a9c495b81041206", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d0af0c997fe42a7f0963d970a9c495b81041206", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d0af0c997fe42a7f0963d970a9c495b81041206", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d0af0c997fe42a7f0963d970a9c495b81041206/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47ddf4c7b1d4471cb9534f27844ab5e4279c2168", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47ddf4c7b1d4471cb9534f27844ab5e4279c2168", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47ddf4c7b1d4471cb9534f27844ab5e4279c2168"}], "stats": {"total": 312, "additions": 299, "deletions": 13}, "files": [{"sha": "a7837c4441ece0491665acdc714447ebad1f56eb", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 275, "deletions": 6, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d0af0c997fe42a7f0963d970a9c495b81041206/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d0af0c997fe42a7f0963d970a9c495b81041206/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=3d0af0c997fe42a7f0963d970a9c495b81041206", "patch": "@@ -43,18 +43,66 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"debug.h\"\n #include \"alloc-pool.h\"\n+#include \"toplev.h\"\n \n /* Allocator used to hold string slot entries for line map streaming.  */\n static struct object_allocator<struct string_slot> *string_slot_allocator;\n \n /* The table to hold the file names.  */\n static hash_table<string_slot_hasher> *file_name_hash_table;\n \n+/* The table to hold the relative pathname prefixes.  */\n+\n /* This obstack holds file names used in locators. Line map datastructures\n    points here and thus it needs to be kept allocated as long as linemaps\n    exists.  */\n static struct obstack file_name_obstack;\n \n+/* Map a pair of nul terminated strings where the first one can be\n+   pointer compared, but the second can't, to another string.  */\n+struct string_pair_map\n+{\n+  const char *str1;\n+  const char *str2;\n+  const char *str3;\n+  hashval_t hash;\n+  bool prefix;\n+};\n+\n+/* Allocator used to hold string pair map entries for line map streaming.  */\n+static struct object_allocator<struct string_pair_map>\n+  *string_pair_map_allocator;\n+\n+struct string_pair_map_hasher : nofree_ptr_hash <string_pair_map>\n+{\n+  static inline hashval_t hash (const string_pair_map *);\n+  static inline bool equal (const string_pair_map *, const string_pair_map *);\n+};\n+\n+inline hashval_t\n+string_pair_map_hasher::hash (const string_pair_map *spm)\n+{\n+  return spm->hash;\n+}\n+\n+inline bool\n+string_pair_map_hasher::equal (const string_pair_map *spm1,\n+\t\t\t       const string_pair_map *spm2)\n+{\n+  return (spm1->hash == spm2->hash\n+\t  && spm1->str1 == spm2->str1\n+\t  && spm1->prefix == spm2->prefix\n+\t  && strcmp (spm1->str2, spm2->str2) == 0);\n+}\n+\n+/* The table to hold the pairs of pathnames and corresponding\n+   resulting pathname.  Used for both mapping of get_src_pwd ()\n+   and recorded source working directory to relative path prefix\n+   from current working directory to the recorded one, and for\n+   mapping of that relative path prefix and some relative path\n+   to those concatenated.  */\n+static hash_table<string_pair_map_hasher> *path_name_pair_hash_table;\n+\n \n /* Check that tag ACTUAL has one of the given values.  NUM_TAGS is the\n    number of valid tag values to check.  */\n@@ -90,13 +138,216 @@ lto_input_data_block (class lto_input_block *ib, void *addr, size_t length)\n     buffer[i] = streamer_read_uchar (ib);\n }\n \n+/* Compute the relative path to get to DATA_WD (absolute directory name)\n+   from CWD (another absolute directory name).  E.g. for\n+   DATA_WD of \"/tmp/foo/bar\" and CWD of \"/tmp/baz/qux\" return\n+   \"../../foo/bar\".  Returned string should be freed by the caller.\n+   Return NULL if absolute file name needs to be used.  */\n+\n+static char *\n+relative_path_prefix (const char *data_wd, const char *cwd)\n+{\n+  const char *d = data_wd;\n+  const char *c = cwd;\n+#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n+  if (d[1] == ':')\n+    {\n+      if (!IS_DIR_SEPARATOR (d[2]))\n+\treturn NULL;\n+      if (c[0] == d[0] && c[1] == ':' && IS_DIR_SEPARATOR (c[2]))\n+\t{\n+\t  c += 3;\n+\t  d += 3;\n+\t}\n+      else\n+\treturn NULL;\n+    }\n+  else if (c[1] == ':')\n+    return NULL;\n+#endif\n+  do\n+    {\n+      while (IS_DIR_SEPARATOR (*d))\n+\td++;\n+      while (IS_DIR_SEPARATOR (*c))\n+\tc++;\n+      size_t i;\n+      for (i = 0; c[i] && !IS_DIR_SEPARATOR (c[i]) && c[i] == d[i]; i++)\n+\t;\n+      if ((c[i] == '\\0' || IS_DIR_SEPARATOR (c[i]))\n+\t  && (d[i] == '\\0' || IS_DIR_SEPARATOR (d[i])))\n+\t{\n+\t  c += i;\n+\t  d += i;\n+\t  if (*c == '\\0' || *d == '\\0')\n+\t    break;\n+\t}\n+      else\n+\tbreak;\n+    }\n+  while (1);\n+  size_t num_up = 0;\n+  do\n+    {\n+      while (IS_DIR_SEPARATOR (*c))\n+\tc++;\n+      if (*c == '\\0')\n+\tbreak;\n+      num_up++;\n+      while (*c && !IS_DIR_SEPARATOR (*c))\n+\tc++;\n+    }\n+  while (1);\n+  while (IS_DIR_SEPARATOR (*d))\n+    d++;\n+  size_t len = strlen (d);\n+  if (len == 0 && num_up == 0)\n+    return xstrdup (\".\");\n+  char *ret = XNEWVEC (char, num_up * 3 + len + 1);\n+  char *p = ret;\n+  for (; num_up; num_up--)\n+    {\n+      const char dir_up[3] = { '.', '.', DIR_SEPARATOR };\n+      memcpy (p, dir_up, 3);\n+      p += 3;\n+    }\n+  memcpy (p, d, len + 1);\n+  return ret;\n+}\n+\n+/* Look up DATA_WD in hash table of relative prefixes.  If found,\n+   return relative path from CWD to DATA_WD from the hash table,\n+   otherwise create it.  */\n+\n+static const char *\n+canon_relative_path_prefix (const char *data_wd, const char *cwd)\n+{\n+  if (!IS_ABSOLUTE_PATH (data_wd) || !IS_ABSOLUTE_PATH (cwd))\n+    return NULL;\n+\n+  if (!path_name_pair_hash_table)\n+    {\n+      path_name_pair_hash_table\n+\t= new hash_table<string_pair_map_hasher> (37);\n+      string_pair_map_allocator\n+\t= new object_allocator <struct string_pair_map>\n+\t\t(\"line map string pair map hash\");\n+    }\n+\n+  inchash::hash h;\n+  h.add_ptr (cwd);\n+  h.merge_hash (htab_hash_string (data_wd));\n+  h.add_int (true);\n+\n+  string_pair_map s_slot;\n+  s_slot.str1 = cwd;\n+  s_slot.str2 = data_wd;\n+  s_slot.str3 = NULL;\n+  s_slot.hash = h.end ();\n+  s_slot.prefix = true;\n+\n+  string_pair_map **slot\n+    = path_name_pair_hash_table->find_slot (&s_slot, INSERT);\n+  if (*slot == NULL)\n+    {\n+      /* Compute relative path from cwd directory to data_wd directory.\n+\t E.g. if cwd is /tmp/foo/bar and data_wd is /tmp/baz/qux ,\n+\t it will return ../../baz/qux .  */\n+      char *relative_path = relative_path_prefix (data_wd, cwd);\n+      const char *relative = relative_path ? relative_path : data_wd;\n+      size_t relative_len = strlen (relative);\n+      gcc_assert (relative_len);\n+\n+      size_t data_wd_len = strlen (data_wd);\n+      bool add_separator = false;\n+      if (!IS_DIR_SEPARATOR (relative[relative_len - 1]))\n+\tadd_separator = true;\n+\n+      size_t len = relative_len + 1 + data_wd_len + 1 + add_separator;\n+\n+      char *saved_string = XOBNEWVEC (&file_name_obstack, char, len);\n+      struct string_pair_map *new_slot\n+\t= string_pair_map_allocator->allocate ();\n+      memcpy (saved_string, data_wd, data_wd_len + 1);\n+      memcpy (saved_string + data_wd_len + 1, relative, relative_len);\n+      if (add_separator)\n+\tsaved_string[len - 2] = DIR_SEPARATOR;\n+      saved_string[len - 1] = '\\0';\n+      new_slot->str1 = cwd;\n+      new_slot->str2 = saved_string;\n+      new_slot->str3 = saved_string + data_wd_len + 1;\n+      if (relative_len == 1 && relative[0] == '.')\n+\tnew_slot->str3 = NULL;\n+      new_slot->hash = s_slot.hash;\n+      new_slot->prefix = true;\n+      *slot = new_slot;\n+      free (relative_path);\n+      return new_slot->str3;\n+    }\n+  else\n+    {\n+      string_pair_map *old_slot = *slot;\n+      return old_slot->str3;\n+    }\n+}\n+\n+/* Look up the pair of RELATIVE_PREFIX and STRING strings in a hash table.\n+   If found, return the concatenation of those from the hash table,\n+   otherwise concatenate them.  */\n+\n+static const char *\n+canon_relative_file_name (const char *relative_prefix, const char *string)\n+{\n+  inchash::hash h;\n+  h.add_ptr (relative_prefix);\n+  h.merge_hash (htab_hash_string (string));\n+\n+  string_pair_map s_slot;\n+  s_slot.str1 = relative_prefix;\n+  s_slot.str2 = string;\n+  s_slot.str3 = NULL;\n+  s_slot.hash = h.end ();\n+  s_slot.prefix = false;\n+\n+  string_pair_map **slot\n+    = path_name_pair_hash_table->find_slot (&s_slot, INSERT);\n+  if (*slot == NULL)\n+    {\n+      size_t relative_prefix_len = strlen (relative_prefix);\n+      size_t string_len = strlen (string);\n+      size_t len = relative_prefix_len + string_len + 1;\n+\n+      char *saved_string = XOBNEWVEC (&file_name_obstack, char, len);\n+      struct string_pair_map *new_slot\n+\t= string_pair_map_allocator->allocate ();\n+      memcpy (saved_string, relative_prefix, relative_prefix_len);\n+      memcpy (saved_string + relative_prefix_len, string, string_len + 1);\n+      new_slot->str1 = relative_prefix;\n+      new_slot->str2 = saved_string + relative_prefix_len;\n+      new_slot->str3 = saved_string;\n+      new_slot->hash = s_slot.hash;\n+      new_slot->prefix = false;\n+      *slot = new_slot;\n+      return new_slot->str3;\n+    }\n+  else\n+    {\n+      string_pair_map *old_slot = *slot;\n+      return old_slot->str3;\n+    }\n+}\n \n /* Lookup STRING in file_name_hash_table.  If found, return the existing\n-   string, otherwise insert STRING as the canonical version.  */\n+   string, otherwise insert STRING as the canonical version.\n+   If STRING is a relative pathname and RELATIVE_PREFIX is non-NULL, use\n+   canon_relative_file_name instead.  */\n \n static const char *\n-canon_file_name (const char *string)\n+canon_file_name (const char *relative_prefix, const char *string)\n {\n+  if (relative_prefix && !IS_ABSOLUTE_PATH (string))\n+    return canon_relative_file_name (relative_prefix, string);\n+\n   string_slot **slot;\n   struct string_slot s_slot;\n   size_t len = strlen (string);\n@@ -261,10 +512,12 @@ lto_location_cache::input_location_and_block (location_t *loc,\n   static int stream_col;\n   static bool stream_sysp;\n   static tree stream_block;\n+  static const char *stream_relative_path_prefix;\n \n   gcc_assert (current_cache == this);\n \n-  *loc = bp_unpack_int_in_range (bp, \"location\", 0, RESERVED_LOCATION_COUNT);\n+  *loc = bp_unpack_int_in_range (bp, \"location\", 0,\n+\t\t\t\t RESERVED_LOCATION_COUNT + 1);\n \n   if (*loc < RESERVED_LOCATION_COUNT)\n     {\n@@ -279,16 +532,28 @@ lto_location_cache::input_location_and_block (location_t *loc,\n       return;\n     }\n \n+  bool file_change = (*loc == RESERVED_LOCATION_COUNT + 1);\n   /* Keep value RESERVED_LOCATION_COUNT in *loc as linemap lookups will\n      ICE on it.  */\n-\n-  bool file_change = bp_unpack_value (bp, 1);\n+  *loc = RESERVED_LOCATION_COUNT;\n   bool line_change = bp_unpack_value (bp, 1);\n   bool column_change = bp_unpack_value (bp, 1);\n \n   if (file_change)\n     {\n-      stream_file = canon_file_name (bp_unpack_string (data_in, bp));\n+      bool pwd_change = bp_unpack_value (bp, 1);\n+      if (pwd_change)\n+\t{\n+\t  const char *pwd = bp_unpack_string (data_in, bp);\n+\t  const char *src_pwd = get_src_pwd ();\n+\t  if (strcmp (pwd, src_pwd) == 0)\n+\t    stream_relative_path_prefix = NULL;\n+\t  else\n+\t    stream_relative_path_prefix\n+\t      = canon_relative_path_prefix (pwd, src_pwd);\n+\t}\n+      stream_file = canon_file_name (stream_relative_path_prefix,\n+\t\t\t\t     bp_unpack_string (data_in, bp));\n       stream_sysp = bp_unpack_value (bp, 1);\n     }\n \n@@ -1857,6 +2122,10 @@ lto_free_file_name_hash (void)\n   file_name_hash_table = NULL;\n   delete string_slot_allocator;\n   string_slot_allocator = NULL;\n+  delete path_name_pair_hash_table;\n+  path_name_pair_hash_table = NULL;\n+  delete string_pair_map_allocator;\n+  string_pair_map_allocator = NULL;\n   /* file_name_obstack must stay allocated since it is referred to by\n      line map table.  */\n }"}, {"sha": "354ba01b59723be8fed6d1d4faa369fced125f11", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d0af0c997fe42a7f0963d970a9c495b81041206/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d0af0c997fe42a7f0963d970a9c495b81041206/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=3d0af0c997fe42a7f0963d970a9c495b81041206", "patch": "@@ -47,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"file-prefix-map.h\" /* remap_debug_filename()  */\n #include \"output.h\"\n #include \"ipa-utils.h\"\n+#include \"toplev.h\"\n \n \n static void lto_write_tree (struct output_block*, tree, bool);\n@@ -61,6 +62,7 @@ clear_line_info (struct output_block *ob)\n   ob->current_col = 0;\n   ob->current_sysp = false;\n   ob->reset_locus = true;\n+  ob->emit_pwd = true;\n   /* Initialize to something that will never appear as block,\n      so that the first location with block in a function etc.\n      always streams a change_block bit and the first block.  */\n@@ -189,9 +191,6 @@ lto_output_location_1 (struct output_block *ob, struct bitpack_d *bp,\n {\n   location_t loc = LOCATION_LOCUS (orig_loc);\n \n-  bp_pack_int_in_range (bp, 0, RESERVED_LOCATION_COUNT,\n-\t\t        loc < RESERVED_LOCATION_COUNT\n-\t\t\t? loc : RESERVED_LOCATION_COUNT);\n   if (loc >= RESERVED_LOCATION_COUNT)\n     {\n       expanded_location xloc = expand_location (loc);\n@@ -207,13 +206,30 @@ lto_output_location_1 (struct output_block *ob, struct bitpack_d *bp,\n \t  ob->reset_locus = false;\n \t}\n \n-      bp_pack_value (bp, ob->current_file != xloc.file, 1);\n+      /* As RESERVED_LOCATION_COUNT is 2, we can use the spare value of\n+\t 3 without wasting additional bits to signalize file change.\n+\t If RESERVED_LOCATION_COUNT changes, reconsider this.  */\n+      gcc_checking_assert (RESERVED_LOCATION_COUNT == 2);\n+      bp_pack_int_in_range (bp, 0, RESERVED_LOCATION_COUNT + 1,\n+\t\t\t    RESERVED_LOCATION_COUNT\n+\t\t\t    + (ob->current_file != xloc.file));\n+\n       bp_pack_value (bp, ob->current_line != xloc.line, 1);\n       bp_pack_value (bp, ob->current_col != xloc.column, 1);\n \n       if (ob->current_file != xloc.file)\n \t{\n-\t  bp_pack_string (ob, bp, remap_debug_filename (xloc.file), true);\n+\t  bool stream_pwd = false;\n+\t  const char *remapped = remap_debug_filename (xloc.file);\n+\t  if (ob->emit_pwd && remapped && !IS_ABSOLUTE_PATH (remapped))\n+\t    {\n+\t      stream_pwd = true;\n+\t      ob->emit_pwd = false;\n+\t    }\n+\t  bp_pack_value (bp, stream_pwd, 1);\n+\t  if (stream_pwd)\n+\t    bp_pack_string (ob, bp, get_src_pwd (), true);\n+\t  bp_pack_string (ob, bp, remapped, true);\n \t  bp_pack_value (bp, xloc.sysp, 1);\n \t}\n       ob->current_file = xloc.file;\n@@ -227,6 +243,8 @@ lto_output_location_1 (struct output_block *ob, struct bitpack_d *bp,\n \tbp_pack_var_len_unsigned (bp, xloc.column);\n       ob->current_col = xloc.column;\n     }\n+  else\n+    bp_pack_int_in_range (bp, 0, RESERVED_LOCATION_COUNT + 1, loc);\n \n   if (block_p)\n     {\n@@ -2376,7 +2394,6 @@ output_function (struct cgraph_node *node)\n   fn = DECL_STRUCT_FUNCTION (function);\n   ob = create_output_block (LTO_section_function_body);\n \n-  clear_line_info (ob);\n   ob->symbol = node;\n \n   gcc_assert (current_function_decl == NULL_TREE && cfun == NULL);\n@@ -2462,7 +2479,6 @@ output_constructor (struct varpool_node *node)\n   timevar_push (TV_IPA_LTO_CTORS_OUT);\n   ob = create_output_block (LTO_section_function_body);\n \n-  clear_line_info (ob);\n   ob->symbol = node;\n \n   /* Make string 0 be a NULL string.  */"}, {"sha": "8c98c96e3682c4a8d2d7749f7c7b4de0070cf76c", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d0af0c997fe42a7f0963d970a9c495b81041206/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d0af0c997fe42a7f0963d970a9c495b81041206/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=3d0af0c997fe42a7f0963d970a9c495b81041206", "patch": "@@ -718,6 +718,7 @@ struct output_block\n   int current_col;\n   bool current_sysp;\n   bool reset_locus;\n+  bool emit_pwd;\n   tree current_block;\n \n   /* Cache of nodes written in this section.  */"}]}