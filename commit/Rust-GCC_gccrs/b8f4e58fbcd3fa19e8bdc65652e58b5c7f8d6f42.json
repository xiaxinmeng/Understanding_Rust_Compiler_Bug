{"sha": "b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhmNGU1OGZiY2QzZmExOWU4YmRjNjU2NTJlNThiNWM3ZjhkNmY0Mg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-09-11T11:39:27Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-09-11T11:39:27Z"}, "message": "gimple.h (gimple_register_type): Remove.\n\n2012-09-11  Richard Guenther  <rguenther@suse.de>\n\n\t* gimple.h (gimple_register_type): Remove.\n\t(print_gimple_types_stats): Adjust prototype.\n\t* lto-streamer.h (print_lto_report): Likewise.\n\t* lto-streamer.c (print_lto_report): Adjust.\n\t* gimple.c (gimple_types, type_hash_cache, enum gtc_mode,\n\tstruct type_pair_d, lookup_type_pair, struct sccs,\n\tnext_dfs_num, gtc_next_dfs_num, struct gimple_type_leader_entry_s,\n\tgimple_type_leader, gimple_lookup_type_leader, compare_type_names_p,\n\tgtc_visit, gimple_types_compatible_p_1, gimple_types_compatible_p,\n\tvisit, iterative_hash_name, struct type_hash_pair,\n\ttype_hash_pair_compare, iterative_hash_gimple_type, gimple_type_hash,\n\tgimple_type_eq, gimple_register_type_1, gimple_register_type):\n\tMove to lto/lto.c.\n\t(print_gimple_types_stats): Adjust.\n\t(free_gimple_type_tables): Likewise.\n\n\tlto/\n\t* lto.c (gimple_types, type_hash_cache, enum gtc_mode,\n\tstruct type_pair_d, lookup_type_pair, struct sccs,\n\tnext_dfs_num, gtc_next_dfs_num, struct gimple_type_leader_entry_s,\n\tgimple_type_leader, gimple_lookup_type_leader, compare_type_names_p,\n\tgtc_visit, gimple_types_compatible_p_1, gimple_types_compatible_p,\n\tvisit, iterative_hash_name, struct type_hash_pair,\n\ttype_hash_pair_compare, iterative_hash_gimple_type, gimple_type_hash,\n\tgimple_type_eq, gimple_register_type_1, gimple_register_type):\n\tMove here from gimple.c\n\t(read_cgraph_and_symbols): Free hash tables here.\n\t(print_lto_report_1): New function wrapping print_lto_report.\n\t(do_whole_program_analysis): Call it.\n\t(lto_main): Likewise.\n\nFrom-SVN: r191177", "tree": {"sha": "60891e0f2664c6adf4a5260fbe20326ef39ef539", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60891e0f2664c6adf4a5260fbe20326ef39ef539"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2cbd94afd37c888ec80ec7ad3c902c9afaae4321", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cbd94afd37c888ec80ec7ad3c902c9afaae4321", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cbd94afd37c888ec80ec7ad3c902c9afaae4321"}], "stats": {"total": 2415, "additions": 1229, "deletions": 1186}, "files": [{"sha": "77f65bd62c18606058291d462d452ba60df1df79", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42", "patch": "@@ -1,3 +1,21 @@\n+2012-09-11  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gimple.h (gimple_register_type): Remove.\n+\t(print_gimple_types_stats): Adjust prototype.\n+\t* lto-streamer.h (print_lto_report): Likewise.\n+\t* lto-streamer.c (print_lto_report): Adjust.\n+\t* gimple.c (gimple_types, type_hash_cache, enum gtc_mode,\n+\tstruct type_pair_d, lookup_type_pair, struct sccs,\n+\tnext_dfs_num, gtc_next_dfs_num, struct gimple_type_leader_entry_s,\n+\tgimple_type_leader, gimple_lookup_type_leader, compare_type_names_p,\n+\tgtc_visit, gimple_types_compatible_p_1, gimple_types_compatible_p,\n+\tvisit, iterative_hash_name, struct type_hash_pair,\n+\ttype_hash_pair_compare, iterative_hash_gimple_type, gimple_type_hash,\n+\tgimple_type_eq, gimple_register_type_1, gimple_register_type):\n+\tMove to lto/lto.c.\n+\t(print_gimple_types_stats): Adjust.\n+\t(free_gimple_type_tables): Likewise.\n+\n 2012-09-11  Richard Guenther  <rguenther@suse.de>\n \n \t* graphite-scop-detection.c (move_sd_regions): Adjust for VEC"}, {"sha": "7c702cad71a883b79e32efb4cd1f07cd8e7ea088", "filename": "gcc/gimple.c", "status": "modified", "additions": 9, "deletions": 1172, "changes": 1181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42", "patch": "@@ -37,16 +37,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"demangle.h\"\n #include \"langhooks.h\"\n \n-/* Global type table.  FIXME lto, it should be possible to re-use some\n-   of the type hashing routines in tree.c (type_hash_canon, type_hash_lookup,\n-   etc), but those assume that types were built with the various\n-   build_*_type routines which is not the case with the streamer.  */\n-static GTY((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n-  htab_t gimple_types;\n+/* Global canonical type table.  */\n static GTY((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n   htab_t gimple_canonical_types;\n-static GTY((if_marked (\"tree_int_map_marked_p\"), param_is (struct tree_int_map)))\n-  htab_t type_hash_cache;\n static GTY((if_marked (\"tree_int_map_marked_p\"), param_is (struct tree_int_map)))\n   htab_t canonical_type_hash_cache;\n \n@@ -3014,159 +3007,6 @@ gimple_call_copy_skip_args (gimple stmt, bitmap args_to_skip)\n }\n \n \n-enum gtc_mode { GTC_MERGE = 0, GTC_DIAG = 1 };\n-\n-static hashval_t gimple_type_hash (const void *);\n-\n-/* Structure used to maintain a cache of some type pairs compared by\n-   gimple_types_compatible_p when comparing aggregate types.  There are\n-   three possible values for SAME_P:\n-\n-   \t-2: The pair (T1, T2) has just been inserted in the table.\n-\t 0: T1 and T2 are different types.\n-\t 1: T1 and T2 are the same type.\n-\n-   The two elements in the SAME_P array are indexed by the comparison\n-   mode gtc_mode.  */\n-\n-struct type_pair_d\n-{\n-  unsigned int uid1;\n-  unsigned int uid2;\n-  signed char same_p[2];\n-};\n-typedef struct type_pair_d *type_pair_t;\n-DEF_VEC_P(type_pair_t);\n-DEF_VEC_ALLOC_P(type_pair_t,heap);\n-\n-#define GIMPLE_TYPE_PAIR_SIZE 16381\n-struct type_pair_d *type_pair_cache;\n-\n-\n-/* Lookup the pair of types T1 and T2 in *VISITED_P.  Insert a new\n-   entry if none existed.  */\n-\n-static inline type_pair_t\n-lookup_type_pair (tree t1, tree t2)\n-{\n-  unsigned int index;\n-  unsigned int uid1, uid2;\n-\n-  if (type_pair_cache == NULL)\n-    type_pair_cache = XCNEWVEC (struct type_pair_d, GIMPLE_TYPE_PAIR_SIZE);\n-\n-  if (TYPE_UID (t1) < TYPE_UID (t2))\n-    {\n-      uid1 = TYPE_UID (t1);\n-      uid2 = TYPE_UID (t2);\n-    }\n-  else\n-    {\n-      uid1 = TYPE_UID (t2);\n-      uid2 = TYPE_UID (t1);\n-    }\n-  gcc_checking_assert (uid1 != uid2);\n-\n-  /* iterative_hash_hashval_t imply an function calls.\n-     We know that UIDS are in limited range.  */\n-  index = ((((unsigned HOST_WIDE_INT)uid1 << HOST_BITS_PER_WIDE_INT / 2) + uid2)\n-\t   % GIMPLE_TYPE_PAIR_SIZE);\n-  if (type_pair_cache [index].uid1 == uid1\n-      && type_pair_cache [index].uid2 == uid2)\n-    return &type_pair_cache[index];\n-\n-  type_pair_cache [index].uid1 = uid1;\n-  type_pair_cache [index].uid2 = uid2;\n-  type_pair_cache [index].same_p[0] = -2;\n-  type_pair_cache [index].same_p[1] = -2;\n-\n-  return &type_pair_cache[index];\n-}\n-\n-/* Per pointer state for the SCC finding.  The on_sccstack flag\n-   is not strictly required, it is true when there is no hash value\n-   recorded for the type and false otherwise.  But querying that\n-   is slower.  */\n-\n-struct sccs\n-{\n-  unsigned int dfsnum;\n-  unsigned int low;\n-  bool on_sccstack;\n-  union {\n-    hashval_t hash;\n-    signed char same_p;\n-  } u;\n-};\n-\n-static unsigned int next_dfs_num;\n-static unsigned int gtc_next_dfs_num;\n-\n-\n-/* GIMPLE type merging cache.  A direct-mapped cache based on TYPE_UID.  */\n-\n-typedef struct GTY(()) gimple_type_leader_entry_s {\n-  tree type;\n-  tree leader;\n-} gimple_type_leader_entry;\n-\n-#define GIMPLE_TYPE_LEADER_SIZE 16381\n-static GTY((deletable, length(\"GIMPLE_TYPE_LEADER_SIZE\")))\n-  gimple_type_leader_entry *gimple_type_leader;\n-\n-/* Lookup an existing leader for T and return it or NULL_TREE, if\n-   there is none in the cache.  */\n-\n-static inline tree\n-gimple_lookup_type_leader (tree t)\n-{\n-  gimple_type_leader_entry *leader;\n-\n-  if (!gimple_type_leader)\n-    return NULL_TREE;\n-\n-  leader = &gimple_type_leader[TYPE_UID (t) % GIMPLE_TYPE_LEADER_SIZE];\n-  if (leader->type != t)\n-    return NULL_TREE;\n-\n-  return leader->leader;\n-}\n-\n-/* Return true if T1 and T2 have the same name.  If FOR_COMPLETION_P is\n-   true then if any type has no name return false, otherwise return\n-   true if both types have no names.  */\n-\n-static bool\n-compare_type_names_p (tree t1, tree t2)\n-{\n-  tree name1 = TYPE_NAME (t1);\n-  tree name2 = TYPE_NAME (t2);\n-\n-  if ((name1 != NULL_TREE) != (name2 != NULL_TREE))\n-    return false;\n-\n-  if (name1 == NULL_TREE)\n-    return true;\n-\n-  /* Either both should be a TYPE_DECL or both an IDENTIFIER_NODE.  */\n-  if (TREE_CODE (name1) != TREE_CODE (name2))\n-    return false;\n-\n-  if (TREE_CODE (name1) == TYPE_DECL)\n-    name1 = DECL_NAME (name1);\n-  gcc_checking_assert (!name1 || TREE_CODE (name1) == IDENTIFIER_NODE);\n-\n-  if (TREE_CODE (name2) == TYPE_DECL)\n-    name2 = DECL_NAME (name2);\n-  gcc_checking_assert (!name2 || TREE_CODE (name2) == IDENTIFIER_NODE);\n-\n-  /* Identifiers can be compared with pointer equality rather\n-     than a string comparison.  */\n-  if (name1 == name2)\n-    return true;\n-\n-  return false;\n-}\n \n /* Return true if the field decls F1 and F2 are at the same offset.\n \n@@ -3219,892 +3059,6 @@ gimple_compare_field_offset (tree f1, tree f2)\n   return false;\n }\n \n-static bool\n-gimple_types_compatible_p_1 (tree, tree, type_pair_t,\n-\t\t\t     VEC(type_pair_t, heap) **,\n-\t\t\t     struct pointer_map_t *, struct obstack *);\n-\n-/* DFS visit the edge from the callers type pair with state *STATE to\n-   the pair T1, T2 while operating in FOR_MERGING_P mode.\n-   Update the merging status if it is not part of the SCC containing the\n-   callers pair and return it.\n-   SCCSTACK, SCCSTATE and SCCSTATE_OBSTACK are state for the DFS walk done.  */\n-\n-static bool\n-gtc_visit (tree t1, tree t2,\n-\t   struct sccs *state,\n-\t   VEC(type_pair_t, heap) **sccstack,\n-\t   struct pointer_map_t *sccstate,\n-\t   struct obstack *sccstate_obstack)\n-{\n-  struct sccs *cstate = NULL;\n-  type_pair_t p;\n-  void **slot;\n-  tree leader1, leader2;\n-\n-  /* Check first for the obvious case of pointer identity.  */\n-  if (t1 == t2)\n-    return true;\n-\n-  /* Check that we have two types to compare.  */\n-  if (t1 == NULL_TREE || t2 == NULL_TREE)\n-    return false;\n-\n-  /* Can't be the same type if the types don't have the same code.  */\n-  if (TREE_CODE (t1) != TREE_CODE (t2))\n-    return false;\n-\n-  /* Can't be the same type if they have different CV qualifiers.  */\n-  if (TYPE_QUALS (t1) != TYPE_QUALS (t2))\n-    return false;\n-\n-  if (TREE_ADDRESSABLE (t1) != TREE_ADDRESSABLE (t2))\n-    return false;\n-\n-  /* Void types and nullptr types are always the same.  */\n-  if (TREE_CODE (t1) == VOID_TYPE\n-      || TREE_CODE (t1) == NULLPTR_TYPE)\n-    return true;\n-\n-  /* Can't be the same type if they have different alignment or mode.  */\n-  if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n-      || TYPE_MODE (t1) != TYPE_MODE (t2))\n-    return false;\n-\n-  /* Do some simple checks before doing three hashtable queries.  */\n-  if (INTEGRAL_TYPE_P (t1)\n-      || SCALAR_FLOAT_TYPE_P (t1)\n-      || FIXED_POINT_TYPE_P (t1)\n-      || TREE_CODE (t1) == VECTOR_TYPE\n-      || TREE_CODE (t1) == COMPLEX_TYPE\n-      || TREE_CODE (t1) == OFFSET_TYPE\n-      || POINTER_TYPE_P (t1))\n-    {\n-      /* Can't be the same type if they have different sign or precision.  */\n-      if (TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n-\t  || TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2))\n-\treturn false;\n-\n-      if (TREE_CODE (t1) == INTEGER_TYPE\n-\t  && TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2))\n-\treturn false;\n-\n-      /* That's all we need to check for float and fixed-point types.  */\n-      if (SCALAR_FLOAT_TYPE_P (t1)\n-\t  || FIXED_POINT_TYPE_P (t1))\n-\treturn true;\n-\n-      /* For other types fall through to more complex checks.  */\n-    }\n-\n-  /* If the types have been previously registered and found equal\n-     they still are.  */\n-  leader1 = gimple_lookup_type_leader (t1);\n-  leader2 = gimple_lookup_type_leader (t2);\n-  if (leader1 == t2\n-      || t1 == leader2\n-      || (leader1 && leader1 == leader2))\n-    return true;\n-\n-  /* If the hash values of t1 and t2 are different the types can't\n-     possibly be the same.  This helps keeping the type-pair hashtable\n-     small, only tracking comparisons for hash collisions.  */\n-  if (gimple_type_hash (t1) != gimple_type_hash (t2))\n-    return false;\n-\n-  /* Allocate a new cache entry for this comparison.  */\n-  p = lookup_type_pair (t1, t2);\n-  if (p->same_p[GTC_MERGE] == 0 || p->same_p[GTC_MERGE] == 1)\n-    {\n-      /* We have already decided whether T1 and T2 are the\n-\t same, return the cached result.  */\n-      return p->same_p[GTC_MERGE] == 1;\n-    }\n-\n-  if ((slot = pointer_map_contains (sccstate, p)) != NULL)\n-    cstate = (struct sccs *)*slot;\n-  /* Not yet visited.  DFS recurse.  */\n-  if (!cstate)\n-    {\n-      gimple_types_compatible_p_1 (t1, t2, p,\n-\t\t\t\t   sccstack, sccstate, sccstate_obstack);\n-      cstate = (struct sccs *)* pointer_map_contains (sccstate, p);\n-      state->low = MIN (state->low, cstate->low);\n-    }\n-  /* If the type is still on the SCC stack adjust the parents low.  */\n-  if (cstate->dfsnum < state->dfsnum\n-      && cstate->on_sccstack)\n-    state->low = MIN (cstate->dfsnum, state->low);\n-\n-  /* Return the current lattice value.  We start with an equality\n-     assumption so types part of a SCC will be optimistically\n-     treated equal unless proven otherwise.  */\n-  return cstate->u.same_p;\n-}\n-\n-/* Worker for gimple_types_compatible.\n-   SCCSTACK, SCCSTATE and SCCSTATE_OBSTACK are state for the DFS walk done.  */\n-\n-static bool\n-gimple_types_compatible_p_1 (tree t1, tree t2, type_pair_t p,\n-\t\t\t     VEC(type_pair_t, heap) **sccstack,\n-\t\t\t     struct pointer_map_t *sccstate,\n-\t\t\t     struct obstack *sccstate_obstack)\n-{\n-  struct sccs *state;\n-\n-  gcc_assert (p->same_p[GTC_MERGE] == -2);\n-\n-  state = XOBNEW (sccstate_obstack, struct sccs);\n-  *pointer_map_insert (sccstate, p) = state;\n-\n-  VEC_safe_push (type_pair_t, heap, *sccstack, p);\n-  state->dfsnum = gtc_next_dfs_num++;\n-  state->low = state->dfsnum;\n-  state->on_sccstack = true;\n-  /* Start with an equality assumption.  As we DFS recurse into child\n-     SCCs this assumption may get revisited.  */\n-  state->u.same_p = 1;\n-\n-  /* The struct tags shall compare equal.  */\n-  if (!compare_type_names_p (t1, t2))\n-    goto different_types;\n-\n-  /* We may not merge typedef types to the same type in different\n-     contexts.  */\n-  if (TYPE_NAME (t1)\n-      && TREE_CODE (TYPE_NAME (t1)) == TYPE_DECL\n-      && DECL_CONTEXT (TYPE_NAME (t1))\n-      && TYPE_P (DECL_CONTEXT (TYPE_NAME (t1))))\n-    {\n-      if (!gtc_visit (DECL_CONTEXT (TYPE_NAME (t1)),\n-\t\t      DECL_CONTEXT (TYPE_NAME (t2)),\n-\t\t      state, sccstack, sccstate, sccstate_obstack))\n-\tgoto different_types;\n-    }\n-\n-  /* If their attributes are not the same they can't be the same type.  */\n-  if (!attribute_list_equal (TYPE_ATTRIBUTES (t1), TYPE_ATTRIBUTES (t2)))\n-    goto different_types;\n-\n-  /* Do type-specific comparisons.  */\n-  switch (TREE_CODE (t1))\n-    {\n-    case VECTOR_TYPE:\n-    case COMPLEX_TYPE:\n-      if (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t      state, sccstack, sccstate, sccstate_obstack))\n-\tgoto different_types;\n-      goto same_types;\n-\n-    case ARRAY_TYPE:\n-      /* Array types are the same if the element types are the same and\n-\t the number of elements are the same.  */\n-      if (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t      state, sccstack, sccstate, sccstate_obstack)\n-\t  || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)\n-\t  || TYPE_NONALIASED_COMPONENT (t1) != TYPE_NONALIASED_COMPONENT (t2))\n-\tgoto different_types;\n-      else\n-\t{\n-\t  tree i1 = TYPE_DOMAIN (t1);\n-\t  tree i2 = TYPE_DOMAIN (t2);\n-\n-\t  /* For an incomplete external array, the type domain can be\n- \t     NULL_TREE.  Check this condition also.  */\n-\t  if (i1 == NULL_TREE && i2 == NULL_TREE)\n-\t    goto same_types;\n-\t  else if (i1 == NULL_TREE || i2 == NULL_TREE)\n-\t    goto different_types;\n-\t  else\n-\t    {\n-\t      tree min1 = TYPE_MIN_VALUE (i1);\n-\t      tree min2 = TYPE_MIN_VALUE (i2);\n-\t      tree max1 = TYPE_MAX_VALUE (i1);\n-\t      tree max2 = TYPE_MAX_VALUE (i2);\n-\n-\t      /* The minimum/maximum values have to be the same.  */\n-\t      if ((min1 == min2\n-\t\t   || (min1 && min2\n-\t\t       && ((TREE_CODE (min1) == PLACEHOLDER_EXPR\n-\t\t\t    && TREE_CODE (min2) == PLACEHOLDER_EXPR)\n-\t\t           || operand_equal_p (min1, min2, 0))))\n-\t\t  && (max1 == max2\n-\t\t      || (max1 && max2\n-\t\t\t  && ((TREE_CODE (max1) == PLACEHOLDER_EXPR\n-\t\t\t       && TREE_CODE (max2) == PLACEHOLDER_EXPR)\n-\t\t\t      || operand_equal_p (max1, max2, 0)))))\n-\t\tgoto same_types;\n-\t      else\n-\t\tgoto different_types;\n-\t    }\n-\t}\n-\n-    case METHOD_TYPE:\n-      /* Method types should belong to the same class.  */\n-      if (!gtc_visit (TYPE_METHOD_BASETYPE (t1), TYPE_METHOD_BASETYPE (t2),\n-\t\t      state, sccstack, sccstate, sccstate_obstack))\n-\tgoto different_types;\n-\n-      /* Fallthru  */\n-\n-    case FUNCTION_TYPE:\n-      /* Function types are the same if the return type and arguments types\n-\t are the same.  */\n-      if (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t      state, sccstack, sccstate, sccstate_obstack))\n-\tgoto different_types;\n-\n-      if (!comp_type_attributes (t1, t2))\n-\tgoto different_types;\n-\n-      if (TYPE_ARG_TYPES (t1) == TYPE_ARG_TYPES (t2))\n-\tgoto same_types;\n-      else\n-\t{\n-\t  tree parms1, parms2;\n-\n-\t  for (parms1 = TYPE_ARG_TYPES (t1), parms2 = TYPE_ARG_TYPES (t2);\n-\t       parms1 && parms2;\n-\t       parms1 = TREE_CHAIN (parms1), parms2 = TREE_CHAIN (parms2))\n-\t    {\n-\t      if (!gtc_visit (TREE_VALUE (parms1), TREE_VALUE (parms2),\n-\t\t\t      state, sccstack, sccstate, sccstate_obstack))\n-\t\tgoto different_types;\n-\t    }\n-\n-\t  if (parms1 || parms2)\n-\t    goto different_types;\n-\n-\t  goto same_types;\n-\t}\n-\n-    case OFFSET_TYPE:\n-      {\n-\tif (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\tstate, sccstack, sccstate, sccstate_obstack)\n-\t    || !gtc_visit (TYPE_OFFSET_BASETYPE (t1),\n-\t\t\t   TYPE_OFFSET_BASETYPE (t2),\n-\t\t\t   state, sccstack, sccstate, sccstate_obstack))\n-\t  goto different_types;\n-\n-\tgoto same_types;\n-      }\n-\n-    case POINTER_TYPE:\n-    case REFERENCE_TYPE:\n-      {\n-\t/* If the two pointers have different ref-all attributes,\n-\t   they can't be the same type.  */\n-\tif (TYPE_REF_CAN_ALIAS_ALL (t1) != TYPE_REF_CAN_ALIAS_ALL (t2))\n-\t  goto different_types;\n-\n-\t/* Otherwise, pointer and reference types are the same if the\n-\t   pointed-to types are the same.  */\n-\tif (gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t       state, sccstack, sccstate, sccstate_obstack))\n-\t  goto same_types;\n-\n-\tgoto different_types;\n-      }\n-\n-    case INTEGER_TYPE:\n-    case BOOLEAN_TYPE:\n-      {\n-\ttree min1 = TYPE_MIN_VALUE (t1);\n-\ttree max1 = TYPE_MAX_VALUE (t1);\n-\ttree min2 = TYPE_MIN_VALUE (t2);\n-\ttree max2 = TYPE_MAX_VALUE (t2);\n-\tbool min_equal_p = false;\n-\tbool max_equal_p = false;\n-\n-\t/* If either type has a minimum value, the other type must\n-\t   have the same.  */\n-\tif (min1 == NULL_TREE && min2 == NULL_TREE)\n-\t  min_equal_p = true;\n-\telse if (min1 && min2 && operand_equal_p (min1, min2, 0))\n-\t  min_equal_p = true;\n-\n-\t/* Likewise, if either type has a maximum value, the other\n-\t   type must have the same.  */\n-\tif (max1 == NULL_TREE && max2 == NULL_TREE)\n-\t  max_equal_p = true;\n-\telse if (max1 && max2 && operand_equal_p (max1, max2, 0))\n-\t  max_equal_p = true;\n-\n-\tif (!min_equal_p || !max_equal_p)\n-\t  goto different_types;\n-\n-\tgoto same_types;\n-      }\n-\n-    case ENUMERAL_TYPE:\n-      {\n-\t/* FIXME lto, we cannot check bounds on enumeral types because\n-\t   different front ends will produce different values.\n-\t   In C, enumeral types are integers, while in C++ each element\n-\t   will have its own symbolic value.  We should decide how enums\n-\t   are to be represented in GIMPLE and have each front end lower\n-\t   to that.  */\n-\ttree v1, v2;\n-\n-\t/* For enumeral types, all the values must be the same.  */\n-\tif (TYPE_VALUES (t1) == TYPE_VALUES (t2))\n-\t  goto same_types;\n-\n-\tfor (v1 = TYPE_VALUES (t1), v2 = TYPE_VALUES (t2);\n-\t     v1 && v2;\n-\t     v1 = TREE_CHAIN (v1), v2 = TREE_CHAIN (v2))\n-\t  {\n-\t    tree c1 = TREE_VALUE (v1);\n-\t    tree c2 = TREE_VALUE (v2);\n-\n-\t    if (TREE_CODE (c1) == CONST_DECL)\n-\t      c1 = DECL_INITIAL (c1);\n-\n-\t    if (TREE_CODE (c2) == CONST_DECL)\n-\t      c2 = DECL_INITIAL (c2);\n-\n-\t    if (tree_int_cst_equal (c1, c2) != 1)\n-\t      goto different_types;\n-\n-\t    if (TREE_PURPOSE (v1) != TREE_PURPOSE (v2))\n-\t      goto different_types;\n-\t  }\n-\n-\t/* If one enumeration has more values than the other, they\n-\t   are not the same.  */\n-\tif (v1 || v2)\n-\t  goto different_types;\n-\n-\tgoto same_types;\n-      }\n-\n-    case RECORD_TYPE:\n-    case UNION_TYPE:\n-    case QUAL_UNION_TYPE:\n-      {\n-\ttree f1, f2;\n-\n-\t/* For aggregate types, all the fields must be the same.  */\n-\tfor (f1 = TYPE_FIELDS (t1), f2 = TYPE_FIELDS (t2);\n-\t     f1 && f2;\n-\t     f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n-\t  {\n-\t    /* Different field kinds are not compatible.  */\n-\t    if (TREE_CODE (f1) != TREE_CODE (f2))\n-\t      goto different_types;\n-\t    /* Field decls must have the same name and offset.  */\n-\t    if (TREE_CODE (f1) == FIELD_DECL\n-\t\t&& (DECL_NONADDRESSABLE_P (f1) != DECL_NONADDRESSABLE_P (f2)\n-\t\t    || !gimple_compare_field_offset (f1, f2)))\n-\t      goto different_types;\n-\t    /* All entities should have the same name and type.  */\n-\t    if (DECL_NAME (f1) != DECL_NAME (f2)\n-\t\t|| !gtc_visit (TREE_TYPE (f1), TREE_TYPE (f2),\n-\t\t\t       state, sccstack, sccstate, sccstate_obstack))\n-\t      goto different_types;\n-\t  }\n-\n-\t/* If one aggregate has more fields than the other, they\n-\t   are not the same.  */\n-\tif (f1 || f2)\n-\t  goto different_types;\n-\n-\tgoto same_types;\n-      }\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  /* Common exit path for types that are not compatible.  */\n-different_types:\n-  state->u.same_p = 0;\n-  goto pop;\n-\n-  /* Common exit path for types that are compatible.  */\n-same_types:\n-  gcc_assert (state->u.same_p == 1);\n-\n-pop:\n-  if (state->low == state->dfsnum)\n-    {\n-      type_pair_t x;\n-\n-      /* Pop off the SCC and set its cache values to the final\n-         comparison result.  */\n-      do\n-\t{\n-\t  struct sccs *cstate;\n-\t  x = VEC_pop (type_pair_t, *sccstack);\n-\t  cstate = (struct sccs *)*pointer_map_contains (sccstate, x);\n-\t  cstate->on_sccstack = false;\n-\t  x->same_p[GTC_MERGE] = state->u.same_p;\n-\t}\n-      while (x != p);\n-    }\n-\n-  return state->u.same_p;\n-}\n-\n-/* Return true iff T1 and T2 are structurally identical.  When\n-   FOR_MERGING_P is true the an incomplete type and a complete type\n-   are considered different, otherwise they are considered compatible.  */\n-\n-static bool\n-gimple_types_compatible_p (tree t1, tree t2)\n-{\n-  VEC(type_pair_t, heap) *sccstack = NULL;\n-  struct pointer_map_t *sccstate;\n-  struct obstack sccstate_obstack;\n-  type_pair_t p = NULL;\n-  bool res;\n-  tree leader1, leader2;\n-\n-  /* Before starting to set up the SCC machinery handle simple cases.  */\n-\n-  /* Check first for the obvious case of pointer identity.  */\n-  if (t1 == t2)\n-    return true;\n-\n-  /* Check that we have two types to compare.  */\n-  if (t1 == NULL_TREE || t2 == NULL_TREE)\n-    return false;\n-\n-  /* Can't be the same type if the types don't have the same code.  */\n-  if (TREE_CODE (t1) != TREE_CODE (t2))\n-    return false;\n-\n-  /* Can't be the same type if they have different CV qualifiers.  */\n-  if (TYPE_QUALS (t1) != TYPE_QUALS (t2))\n-    return false;\n-\n-  if (TREE_ADDRESSABLE (t1) != TREE_ADDRESSABLE (t2))\n-    return false;\n-\n-  /* Void types and nullptr types are always the same.  */\n-  if (TREE_CODE (t1) == VOID_TYPE\n-      || TREE_CODE (t1) == NULLPTR_TYPE)\n-    return true;\n-\n-  /* Can't be the same type if they have different alignment or mode.  */\n-  if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n-      || TYPE_MODE (t1) != TYPE_MODE (t2))\n-    return false;\n-\n-  /* Do some simple checks before doing three hashtable queries.  */\n-  if (INTEGRAL_TYPE_P (t1)\n-      || SCALAR_FLOAT_TYPE_P (t1)\n-      || FIXED_POINT_TYPE_P (t1)\n-      || TREE_CODE (t1) == VECTOR_TYPE\n-      || TREE_CODE (t1) == COMPLEX_TYPE\n-      || TREE_CODE (t1) == OFFSET_TYPE\n-      || POINTER_TYPE_P (t1))\n-    {\n-      /* Can't be the same type if they have different sign or precision.  */\n-      if (TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n-\t  || TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2))\n-\treturn false;\n-\n-      if (TREE_CODE (t1) == INTEGER_TYPE\n-\t  && TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2))\n-\treturn false;\n-\n-      /* That's all we need to check for float and fixed-point types.  */\n-      if (SCALAR_FLOAT_TYPE_P (t1)\n-\t  || FIXED_POINT_TYPE_P (t1))\n-\treturn true;\n-\n-      /* For other types fall through to more complex checks.  */\n-    }\n-\n-  /* If the types have been previously registered and found equal\n-     they still are.  */\n-  leader1 = gimple_lookup_type_leader (t1);\n-  leader2 = gimple_lookup_type_leader (t2);\n-  if (leader1 == t2\n-      || t1 == leader2\n-      || (leader1 && leader1 == leader2))\n-    return true;\n-\n-  /* If the hash values of t1 and t2 are different the types can't\n-     possibly be the same.  This helps keeping the type-pair hashtable\n-     small, only tracking comparisons for hash collisions.  */\n-  if (gimple_type_hash (t1) != gimple_type_hash (t2))\n-    return false;\n-\n-  /* If we've visited this type pair before (in the case of aggregates\n-     with self-referential types), and we made a decision, return it.  */\n-  p = lookup_type_pair (t1, t2);\n-  if (p->same_p[GTC_MERGE] == 0 || p->same_p[GTC_MERGE] == 1)\n-    {\n-      /* We have already decided whether T1 and T2 are the\n-\t same, return the cached result.  */\n-      return p->same_p[GTC_MERGE] == 1;\n-    }\n-\n-  /* Now set up the SCC machinery for the comparison.  */\n-  gtc_next_dfs_num = 1;\n-  sccstate = pointer_map_create ();\n-  gcc_obstack_init (&sccstate_obstack);\n-  res = gimple_types_compatible_p_1 (t1, t2, p,\n-\t\t\t\t     &sccstack, sccstate, &sccstate_obstack);\n-  VEC_free (type_pair_t, heap, sccstack);\n-  pointer_map_destroy (sccstate);\n-  obstack_free (&sccstate_obstack, NULL);\n-\n-  return res;\n-}\n-\n-\n-static hashval_t\n-iterative_hash_gimple_type (tree, hashval_t, VEC(tree, heap) **,\n-\t\t\t    struct pointer_map_t *, struct obstack *);\n-\n-/* DFS visit the edge from the callers type with state *STATE to T.\n-   Update the callers type hash V with the hash for T if it is not part\n-   of the SCC containing the callers type and return it.\n-   SCCSTACK, SCCSTATE and SCCSTATE_OBSTACK are state for the DFS walk done.  */\n-\n-static hashval_t\n-visit (tree t, struct sccs *state, hashval_t v,\n-       VEC (tree, heap) **sccstack,\n-       struct pointer_map_t *sccstate,\n-       struct obstack *sccstate_obstack)\n-{\n-  struct sccs *cstate = NULL;\n-  struct tree_int_map m;\n-  void **slot;\n-\n-  /* If there is a hash value recorded for this type then it can't\n-     possibly be part of our parent SCC.  Simply mix in its hash.  */\n-  m.base.from = t;\n-  if ((slot = htab_find_slot (type_hash_cache, &m, NO_INSERT))\n-      && *slot)\n-    return iterative_hash_hashval_t (((struct tree_int_map *) *slot)->to, v);\n-\n-  if ((slot = pointer_map_contains (sccstate, t)) != NULL)\n-    cstate = (struct sccs *)*slot;\n-  if (!cstate)\n-    {\n-      hashval_t tem;\n-      /* Not yet visited.  DFS recurse.  */\n-      tem = iterative_hash_gimple_type (t, v,\n-\t\t\t\t\tsccstack, sccstate, sccstate_obstack);\n-      if (!cstate)\n-\tcstate = (struct sccs *)* pointer_map_contains (sccstate, t);\n-      state->low = MIN (state->low, cstate->low);\n-      /* If the type is no longer on the SCC stack and thus is not part\n-         of the parents SCC mix in its hash value.  Otherwise we will\n-\t ignore the type for hashing purposes and return the unaltered\n-\t hash value.  */\n-      if (!cstate->on_sccstack)\n-\treturn tem;\n-    }\n-  if (cstate->dfsnum < state->dfsnum\n-      && cstate->on_sccstack)\n-    state->low = MIN (cstate->dfsnum, state->low);\n-\n-  /* We are part of our parents SCC, skip this type during hashing\n-     and return the unaltered hash value.  */\n-  return v;\n-}\n-\n-/* Hash NAME with the previous hash value V and return it.  */\n-\n-static hashval_t\n-iterative_hash_name (tree name, hashval_t v)\n-{\n-  if (!name)\n-    return v;\n-  v = iterative_hash_hashval_t (TREE_CODE (name), v);\n-  if (TREE_CODE (name) == TYPE_DECL)\n-    name = DECL_NAME (name);\n-  if (!name)\n-    return v;\n-  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n-  return iterative_hash_object (IDENTIFIER_HASH_VALUE (name), v);\n-}\n-\n-/* A type, hashvalue pair for sorting SCC members.  */\n-\n-struct type_hash_pair {\n-  tree type;\n-  hashval_t hash;\n-};\n-\n-/* Compare two type, hashvalue pairs.  */\n-\n-static int\n-type_hash_pair_compare (const void *p1_, const void *p2_)\n-{\n-  const struct type_hash_pair *p1 = (const struct type_hash_pair *) p1_;\n-  const struct type_hash_pair *p2 = (const struct type_hash_pair *) p2_;\n-  if (p1->hash < p2->hash)\n-    return -1;\n-  else if (p1->hash > p2->hash)\n-    return 1;\n-  return 0;\n-}\n-\n-/* Returning a hash value for gimple type TYPE combined with VAL.\n-   SCCSTACK, SCCSTATE and SCCSTATE_OBSTACK are state for the DFS walk done.\n-\n-   To hash a type we end up hashing in types that are reachable.\n-   Through pointers we can end up with cycles which messes up the\n-   required property that we need to compute the same hash value\n-   for structurally equivalent types.  To avoid this we have to\n-   hash all types in a cycle (the SCC) in a commutative way.  The\n-   easiest way is to not mix in the hashes of the SCC members at\n-   all.  To make this work we have to delay setting the hash\n-   values of the SCC until it is complete.  */\n-\n-static hashval_t\n-iterative_hash_gimple_type (tree type, hashval_t val,\n-\t\t\t    VEC(tree, heap) **sccstack,\n-\t\t\t    struct pointer_map_t *sccstate,\n-\t\t\t    struct obstack *sccstate_obstack)\n-{\n-  hashval_t v;\n-  void **slot;\n-  struct sccs *state;\n-\n-  /* Not visited during this DFS walk.  */\n-  gcc_checking_assert (!pointer_map_contains (sccstate, type));\n-  state = XOBNEW (sccstate_obstack, struct sccs);\n-  *pointer_map_insert (sccstate, type) = state;\n-\n-  VEC_safe_push (tree, heap, *sccstack, type);\n-  state->dfsnum = next_dfs_num++;\n-  state->low = state->dfsnum;\n-  state->on_sccstack = true;\n-\n-  /* Combine a few common features of types so that types are grouped into\n-     smaller sets; when searching for existing matching types to merge,\n-     only existing types having the same features as the new type will be\n-     checked.  */\n-  v = iterative_hash_name (TYPE_NAME (type), 0);\n-  if (TYPE_NAME (type)\n-      && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-      && DECL_CONTEXT (TYPE_NAME (type))\n-      && TYPE_P (DECL_CONTEXT (TYPE_NAME (type))))\n-    v = visit (DECL_CONTEXT (TYPE_NAME (type)), state, v,\n-\t       sccstack, sccstate, sccstate_obstack);\n-  v = iterative_hash_hashval_t (TREE_CODE (type), v);\n-  v = iterative_hash_hashval_t (TYPE_QUALS (type), v);\n-  v = iterative_hash_hashval_t (TREE_ADDRESSABLE (type), v);\n-\n-  /* Do not hash the types size as this will cause differences in\n-     hash values for the complete vs. the incomplete type variant.  */\n-\n-  /* Incorporate common features of numerical types.  */\n-  if (INTEGRAL_TYPE_P (type)\n-      || SCALAR_FLOAT_TYPE_P (type)\n-      || FIXED_POINT_TYPE_P (type))\n-    {\n-      v = iterative_hash_hashval_t (TYPE_PRECISION (type), v);\n-      v = iterative_hash_hashval_t (TYPE_MODE (type), v);\n-      v = iterative_hash_hashval_t (TYPE_UNSIGNED (type), v);\n-    }\n-\n-  /* For pointer and reference types, fold in information about the type\n-     pointed to.  */\n-  if (POINTER_TYPE_P (type))\n-    v = visit (TREE_TYPE (type), state, v,\n-\t       sccstack, sccstate, sccstate_obstack);\n-\n-  /* For integer types hash the types min/max values and the string flag.  */\n-  if (TREE_CODE (type) == INTEGER_TYPE)\n-    {\n-      /* OMP lowering can introduce error_mark_node in place of\n-\t random local decls in types.  */\n-      if (TYPE_MIN_VALUE (type) != error_mark_node)\n-\tv = iterative_hash_expr (TYPE_MIN_VALUE (type), v);\n-      if (TYPE_MAX_VALUE (type) != error_mark_node)\n-\tv = iterative_hash_expr (TYPE_MAX_VALUE (type), v);\n-      v = iterative_hash_hashval_t (TYPE_STRING_FLAG (type), v);\n-    }\n-\n-  /* For array types hash the domain and the string flag.  */\n-  if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type))\n-    {\n-      v = iterative_hash_hashval_t (TYPE_STRING_FLAG (type), v);\n-      v = visit (TYPE_DOMAIN (type), state, v,\n-\t\t sccstack, sccstate, sccstate_obstack);\n-    }\n-\n-  /* Recurse for aggregates with a single element type.  */\n-  if (TREE_CODE (type) == ARRAY_TYPE\n-      || TREE_CODE (type) == COMPLEX_TYPE\n-      || TREE_CODE (type) == VECTOR_TYPE)\n-    v = visit (TREE_TYPE (type), state, v,\n-\t       sccstack, sccstate, sccstate_obstack);\n-\n-  /* Incorporate function return and argument types.  */\n-  if (TREE_CODE (type) == FUNCTION_TYPE || TREE_CODE (type) == METHOD_TYPE)\n-    {\n-      unsigned na;\n-      tree p;\n-\n-      /* For method types also incorporate their parent class.  */\n-      if (TREE_CODE (type) == METHOD_TYPE)\n-\tv = visit (TYPE_METHOD_BASETYPE (type), state, v,\n-\t\t   sccstack, sccstate, sccstate_obstack);\n-\n-      /* Check result and argument types.  */\n-      v = visit (TREE_TYPE (type), state, v,\n-\t\t sccstack, sccstate, sccstate_obstack);\n-      for (p = TYPE_ARG_TYPES (type), na = 0; p; p = TREE_CHAIN (p))\n-\t{\n-\t  v = visit (TREE_VALUE (p), state, v,\n-\t\t     sccstack, sccstate, sccstate_obstack);\n-\t  na++;\n-\t}\n-\n-      v = iterative_hash_hashval_t (na, v);\n-    }\n-\n-  if (RECORD_OR_UNION_TYPE_P (type))\n-    {\n-      unsigned nf;\n-      tree f;\n-\n-      for (f = TYPE_FIELDS (type), nf = 0; f; f = TREE_CHAIN (f))\n-\t{\n-\t  v = iterative_hash_name (DECL_NAME (f), v);\n-\t  v = visit (TREE_TYPE (f), state, v,\n-\t\t     sccstack, sccstate, sccstate_obstack);\n-\t  nf++;\n-\t}\n-\n-      v = iterative_hash_hashval_t (nf, v);\n-    }\n-\n-  /* Record hash for us.  */\n-  state->u.hash = v;\n-\n-  /* See if we found an SCC.  */\n-  if (state->low == state->dfsnum)\n-    {\n-      tree x;\n-      struct tree_int_map *m;\n-\n-      /* Pop off the SCC and set its hash values.  */\n-      x = VEC_pop (tree, *sccstack);\n-      /* Optimize SCC size one.  */\n-      if (x == type)\n-\t{\n-\t  state->on_sccstack = false;\n-\t  m = ggc_alloc_cleared_tree_int_map ();\n-\t  m->base.from = x;\n-\t  m->to = v;\n-\t  slot = htab_find_slot (type_hash_cache, m, INSERT);\n-\t  gcc_assert (!*slot);\n-\t  *slot = (void *) m;\n-\t}\n-      else\n-\t{\n-\t  struct sccs *cstate;\n-\t  unsigned first, i, size, j;\n-\t  struct type_hash_pair *pairs;\n-\t  /* Pop off the SCC and build an array of type, hash pairs.  */\n-\t  first = VEC_length (tree, *sccstack) - 1;\n-\t  while (VEC_index (tree, *sccstack, first) != type)\n-\t    --first;\n-\t  size = VEC_length (tree, *sccstack) - first + 1;\n-\t  pairs = XALLOCAVEC (struct type_hash_pair, size);\n-\t  i = 0;\n-\t  cstate = (struct sccs *)*pointer_map_contains (sccstate, x);\n-\t  cstate->on_sccstack = false;\n-\t  pairs[i].type = x;\n-\t  pairs[i].hash = cstate->u.hash;\n-\t  do\n-\t    {\n-\t      x = VEC_pop (tree, *sccstack);\n-\t      cstate = (struct sccs *)*pointer_map_contains (sccstate, x);\n-\t      cstate->on_sccstack = false;\n-\t      ++i;\n-\t      pairs[i].type = x;\n-\t      pairs[i].hash = cstate->u.hash;\n-\t    }\n-\t  while (x != type);\n-\t  gcc_assert (i + 1 == size);\n-\t  /* Sort the arrays of type, hash pairs so that when we mix in\n-\t     all members of the SCC the hash value becomes independent on\n-\t     the order we visited the SCC.  Disregard hashes equal to\n-\t     the hash of the type we mix into because we cannot guarantee\n-\t     a stable sort for those across different TUs.  */\n-\t  qsort (pairs, size, sizeof (struct type_hash_pair),\n-\t\t type_hash_pair_compare);\n-\t  for (i = 0; i < size; ++i)\n-\t    {\n-\t      hashval_t hash;\n-\t      m = ggc_alloc_cleared_tree_int_map ();\n-\t      m->base.from = pairs[i].type;\n-\t      hash = pairs[i].hash;\n-\t      /* Skip same hashes.  */\n-\t      for (j = i + 1; j < size && pairs[j].hash == pairs[i].hash; ++j)\n-\t\t;\n-\t      for (; j < size; ++j)\n-\t\thash = iterative_hash_hashval_t (pairs[j].hash, hash);\n-\t      for (j = 0; pairs[j].hash != pairs[i].hash; ++j)\n-\t\thash = iterative_hash_hashval_t (pairs[j].hash, hash);\n-\t      m->to = hash;\n-\t      if (pairs[i].type == type)\n-\t\tv = hash;\n-\t      slot = htab_find_slot (type_hash_cache, m, INSERT);\n-\t      gcc_assert (!*slot);\n-\t      *slot = (void *) m;\n-\t    }\n-\t}\n-    }\n-\n-  return iterative_hash_hashval_t (v, val);\n-}\n-\n-\n-/* Returns a hash value for P (assumed to be a type).  The hash value\n-   is computed using some distinguishing features of the type.  Note\n-   that we cannot use pointer hashing here as we may be dealing with\n-   two distinct instances of the same type.\n-\n-   This function should produce the same hash value for two compatible\n-   types according to gimple_types_compatible_p.  */\n-\n-static hashval_t\n-gimple_type_hash (const void *p)\n-{\n-  const_tree t = (const_tree) p;\n-  VEC(tree, heap) *sccstack = NULL;\n-  struct pointer_map_t *sccstate;\n-  struct obstack sccstate_obstack;\n-  hashval_t val;\n-  void **slot;\n-  struct tree_int_map m;\n-\n-  if (type_hash_cache == NULL)\n-    type_hash_cache = htab_create_ggc (512, tree_int_map_hash,\n-\t\t\t\t       tree_int_map_eq, NULL);\n-\n-  m.base.from = CONST_CAST_TREE (t);\n-  if ((slot = htab_find_slot (type_hash_cache, &m, NO_INSERT))\n-      && *slot)\n-    return iterative_hash_hashval_t (((struct tree_int_map *) *slot)->to, 0);\n-\n-  /* Perform a DFS walk and pre-hash all reachable types.  */\n-  next_dfs_num = 1;\n-  sccstate = pointer_map_create ();\n-  gcc_obstack_init (&sccstate_obstack);\n-  val = iterative_hash_gimple_type (CONST_CAST_TREE (t), 0,\n-\t\t\t\t    &sccstack, sccstate, &sccstate_obstack);\n-  VEC_free (tree, heap, sccstack);\n-  pointer_map_destroy (sccstate);\n-  obstack_free (&sccstate_obstack, NULL);\n-\n-  return val;\n-}\n-\n /* Returning a hash value for gimple type TYPE combined with VAL.\n \n    The hash value returned is equal for types considered compatible\n@@ -4232,84 +3186,7 @@ gimple_canonical_type_hash (const void *p)\n }\n \n \n-/* Returns nonzero if P1 and P2 are equal.  */\n-\n-static int\n-gimple_type_eq (const void *p1, const void *p2)\n-{\n-  const_tree t1 = (const_tree) p1;\n-  const_tree t2 = (const_tree) p2;\n-  return gimple_types_compatible_p (CONST_CAST_TREE (t1),\n-\t\t\t\t    CONST_CAST_TREE (t2));\n-}\n-\n-\n-/* Worker for gimple_register_type.\n-   Register type T in the global type table gimple_types.\n-   When REGISTERING_MV is false first recurse for the main variant of T.  */\n-\n-static tree\n-gimple_register_type_1 (tree t, bool registering_mv)\n-{\n-  void **slot;\n-  gimple_type_leader_entry *leader;\n-\n-  /* If we registered this type before return the cached result.  */\n-  leader = &gimple_type_leader[TYPE_UID (t) % GIMPLE_TYPE_LEADER_SIZE];\n-  if (leader->type == t)\n-    return leader->leader;\n-\n-  /* Always register the main variant first.  This is important so we\n-     pick up the non-typedef variants as canonical, otherwise we'll end\n-     up taking typedef ids for structure tags during comparison.\n-     It also makes sure that main variants will be merged to main variants.\n-     As we are operating on a possibly partially fixed up type graph\n-     do not bother to recurse more than once, otherwise we may end up\n-     walking in circles.\n-     If we are registering a main variant it will either remain its\n-     own main variant or it will be merged to something else in which\n-     case we do not care for the main variant leader.  */\n-  if (!registering_mv\n-      && TYPE_MAIN_VARIANT (t) != t)\n-    gimple_register_type_1 (TYPE_MAIN_VARIANT (t), true);\n-\n-  /* See if we already have an equivalent type registered.  */\n-  slot = htab_find_slot (gimple_types, t, INSERT);\n-  if (*slot\n-      && *(tree *)slot != t)\n-    {\n-      tree new_type = (tree) *((tree *) slot);\n-      leader->type = t;\n-      leader->leader = new_type;\n-      return new_type;\n-    }\n-\n-  /* If not, insert it to the cache and the hash.  */\n-  leader->type = t;\n-  leader->leader = t;\n-  *slot = (void *) t;\n-  return t;\n-}\n-\n-/* Register type T in the global type table gimple_types.\n-   If another type T', compatible with T, already existed in\n-   gimple_types then return T', otherwise return T.  This is used by\n-   LTO to merge identical types read from different TUs.  */\n-\n-tree\n-gimple_register_type (tree t)\n-{\n-  gcc_assert (TYPE_P (t));\n-\n-  if (!gimple_type_leader)\n-    gimple_type_leader = ggc_alloc_cleared_vec_gimple_type_leader_entry_s\n-\t\t\t\t(GIMPLE_TYPE_LEADER_SIZE);\n-\n-  if (gimple_types == NULL)\n-    gimple_types = htab_create_ggc (16381, gimple_type_hash, gimple_type_eq, 0);\n \n-  return gimple_register_type_1 (t, false);\n-}\n \n /* The TYPE_CANONICAL merging machinery.  It should closely resemble\n    the middle-end types_compatible_p function.  It needs to avoid\n@@ -4583,85 +3460,45 @@ gimple_register_canonical_type (tree t)\n /* Show statistics on references to the global type table gimple_types.  */\n \n void\n-print_gimple_types_stats (void)\n-{\n-  if (gimple_types)\n-    fprintf (stderr, \"GIMPLE type table: size %ld, %ld elements, \"\n-\t     \"%ld searches, %ld collisions (ratio: %f)\\n\",\n-\t     (long) htab_size (gimple_types),\n-\t     (long) htab_elements (gimple_types),\n-\t     (long) gimple_types->searches,\n-\t     (long) gimple_types->collisions,\n-\t     htab_collisions (gimple_types));\n-  else\n-    fprintf (stderr, \"GIMPLE type table is empty\\n\");\n-  if (type_hash_cache)\n-    fprintf (stderr, \"GIMPLE type hash table: size %ld, %ld elements, \"\n-\t     \"%ld searches, %ld collisions (ratio: %f)\\n\",\n-\t     (long) htab_size (type_hash_cache),\n-\t     (long) htab_elements (type_hash_cache),\n-\t     (long) type_hash_cache->searches,\n-\t     (long) type_hash_cache->collisions,\n-\t     htab_collisions (type_hash_cache));\n-  else\n-    fprintf (stderr, \"GIMPLE type hash table is empty\\n\");\n+print_gimple_types_stats (const char *pfx)\n+{\n   if (gimple_canonical_types)\n-    fprintf (stderr, \"GIMPLE canonical type table: size %ld, %ld elements, \"\n-\t     \"%ld searches, %ld collisions (ratio: %f)\\n\",\n+    fprintf (stderr, \"[%s] GIMPLE canonical type table: size %ld, \"\n+\t     \"%ld elements, %ld searches, %ld collisions (ratio: %f)\\n\", pfx,\n \t     (long) htab_size (gimple_canonical_types),\n \t     (long) htab_elements (gimple_canonical_types),\n \t     (long) gimple_canonical_types->searches,\n \t     (long) gimple_canonical_types->collisions,\n \t     htab_collisions (gimple_canonical_types));\n   else\n-    fprintf (stderr, \"GIMPLE canonical type table is empty\\n\");\n+    fprintf (stderr, \"[%s] GIMPLE canonical type table is empty\\n\", pfx);\n   if (canonical_type_hash_cache)\n-    fprintf (stderr, \"GIMPLE canonical type hash table: size %ld, %ld elements, \"\n-\t     \"%ld searches, %ld collisions (ratio: %f)\\n\",\n+    fprintf (stderr, \"[%s] GIMPLE canonical type hash table: size %ld, \"\n+\t     \"%ld elements, %ld searches, %ld collisions (ratio: %f)\\n\", pfx,\n \t     (long) htab_size (canonical_type_hash_cache),\n \t     (long) htab_elements (canonical_type_hash_cache),\n \t     (long) canonical_type_hash_cache->searches,\n \t     (long) canonical_type_hash_cache->collisions,\n \t     htab_collisions (canonical_type_hash_cache));\n   else\n-    fprintf (stderr, \"GIMPLE canonical type hash table is empty\\n\");\n+    fprintf (stderr, \"[%s] GIMPLE canonical type hash table is empty\\n\", pfx);\n }\n \n /* Free the gimple type hashtables used for LTO type merging.  */\n \n void\n free_gimple_type_tables (void)\n {\n-  /* Last chance to print stats for the tables.  */\n-  if (flag_lto_report)\n-    print_gimple_types_stats ();\n-\n-  if (gimple_types)\n-    {\n-      htab_delete (gimple_types);\n-      gimple_types = NULL;\n-    }\n   if (gimple_canonical_types)\n     {\n       htab_delete (gimple_canonical_types);\n       gimple_canonical_types = NULL;\n     }\n-  if (type_hash_cache)\n-    {\n-      htab_delete (type_hash_cache);\n-      type_hash_cache = NULL;\n-    }\n   if (canonical_type_hash_cache)\n     {\n       htab_delete (canonical_type_hash_cache);\n       canonical_type_hash_cache = NULL;\n     }\n-  if (type_pair_cache)\n-    {\n-      free (type_pair_cache);\n-      type_pair_cache = NULL;\n-    }\n-  gimple_type_leader = NULL;\n }\n \n "}, {"sha": "797cd944450848f9b551e13142cbdb02076dcf25", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42", "patch": "@@ -882,9 +882,8 @@ extern bool is_gimple_call_addr (tree);\n \n extern void recalculate_side_effects (tree);\n extern bool gimple_compare_field_offset (tree, tree);\n-extern tree gimple_register_type (tree);\n extern tree gimple_register_canonical_type (tree);\n-extern void print_gimple_types_stats (void);\n+extern void print_gimple_types_stats (const char *);\n extern void free_gimple_type_tables (void);\n extern tree gimple_unsigned_type (tree);\n extern tree gimple_signed_type (tree);"}, {"sha": "51c6658ec92acbbe7e17f854eb331476b5d4054f", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42", "patch": "@@ -180,12 +180,10 @@ lto_get_section_name (int section_type, const char *name, struct lto_file_decl_d\n /* Show various memory usage statistics related to LTO.  */\n \n void\n-print_lto_report (void)\n+print_lto_report (const char *s)\n {\n-  const char *s = (flag_lto) ? \"LTO\" : (flag_wpa) ? \"WPA\" : \"LTRANS\";\n   unsigned i;\n \n-  fprintf (stderr, \"%s statistics\\n\", s);\n   fprintf (stderr, \"[%s] # of input files: \"\n \t   HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\", s, lto_stats.num_input_files);\n \n@@ -197,9 +195,6 @@ print_lto_report (void)\n \t   HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\", s,\n \t   lto_stats.num_function_bodies);\n \n-  fprintf (stderr, \"[%s] \", s);\n-  print_gimple_types_stats ();\n-\n   for (i = 0; i < NUM_TREE_CODES; i++)\n     if (lto_stats.num_trees[i])\n       fprintf (stderr, \"[%s] # of '%s' objects read: \""}, {"sha": "abeaa4b2417bd6eaf8499a1a076cee28064e6961", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42", "patch": "@@ -785,7 +785,7 @@ extern const char *lto_tag_name (enum LTO_tags);\n extern bitmap lto_bitmap_alloc (void);\n extern void lto_bitmap_free (bitmap);\n extern char *lto_get_section_name (int, const char *, struct lto_file_decl_data *);\n-extern void print_lto_report (void);\n+extern void print_lto_report (const char *);\n extern void lto_streamer_init (void);\n extern bool gate_lto_out (void);\n #ifdef LTO_STREAMER_DEBUG"}, {"sha": "26ca636de19232dab5c17228a855761ab2e41aa1", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42", "patch": "@@ -1,3 +1,19 @@\n+2012-09-11  Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto.c (gimple_types, type_hash_cache, enum gtc_mode,\n+\tstruct type_pair_d, lookup_type_pair, struct sccs,\n+\tnext_dfs_num, gtc_next_dfs_num, struct gimple_type_leader_entry_s,\n+\tgimple_type_leader, gimple_lookup_type_leader, compare_type_names_p,\n+\tgtc_visit, gimple_types_compatible_p_1, gimple_types_compatible_p,\n+\tvisit, iterative_hash_name, struct type_hash_pair,\n+\ttype_hash_pair_compare, iterative_hash_gimple_type, gimple_type_hash,\n+\tgimple_type_eq, gimple_register_type_1, gimple_register_type):\n+\tMove here from gimple.c\n+\t(read_cgraph_and_symbols): Free hash tables here.\n+\t(print_lto_report_1): New function wrapping print_lto_report.\n+\t(do_whole_program_analysis): Call it.\n+\t(lto_main): Likewise.\n+\n 2012-09-10  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-partition.c (partition_symbol_p): Forward declare."}, {"sha": "11f008d8dd57bedca3771bd02dd4a073f86f398c", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 1183, "deletions": 5, "changes": 1188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=b8f4e58fbcd3fa19e8bdc65652e58b5c7f8d6f42", "patch": "@@ -276,6 +276,1139 @@ lto_read_in_decl_state (struct data_in *data_in, const uint32_t *data,\n   return data;\n }\n \n+/* Global type table.  FIXME, it should be possible to re-use some\n+   of the type hashing routines in tree.c (type_hash_canon, type_hash_lookup,\n+   etc), but those assume that types were built with the various\n+   build_*_type routines which is not the case with the streamer.  */\n+static GTY((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n+  htab_t gimple_types;\n+static GTY((if_marked (\"tree_int_map_marked_p\"), param_is (struct tree_int_map)))\n+  htab_t type_hash_cache;\n+\n+enum gtc_mode { GTC_MERGE = 0, GTC_DIAG = 1 };\n+\n+static hashval_t gimple_type_hash (const void *);\n+\n+/* Structure used to maintain a cache of some type pairs compared by\n+   gimple_types_compatible_p when comparing aggregate types.  There are\n+   three possible values for SAME_P:\n+\n+   \t-2: The pair (T1, T2) has just been inserted in the table.\n+\t 0: T1 and T2 are different types.\n+\t 1: T1 and T2 are the same type.\n+\n+   The two elements in the SAME_P array are indexed by the comparison\n+   mode gtc_mode.  */\n+\n+struct type_pair_d\n+{\n+  unsigned int uid1;\n+  unsigned int uid2;\n+  signed char same_p[2];\n+};\n+typedef struct type_pair_d *type_pair_t;\n+DEF_VEC_P(type_pair_t);\n+DEF_VEC_ALLOC_P(type_pair_t,heap);\n+\n+#define GIMPLE_TYPE_PAIR_SIZE 16381\n+struct type_pair_d *type_pair_cache;\n+\n+\n+/* Lookup the pair of types T1 and T2 in *VISITED_P.  Insert a new\n+   entry if none existed.  */\n+\n+static inline type_pair_t\n+lookup_type_pair (tree t1, tree t2)\n+{\n+  unsigned int index;\n+  unsigned int uid1, uid2;\n+\n+  if (type_pair_cache == NULL)\n+    type_pair_cache = XCNEWVEC (struct type_pair_d, GIMPLE_TYPE_PAIR_SIZE);\n+\n+  if (TYPE_UID (t1) < TYPE_UID (t2))\n+    {\n+      uid1 = TYPE_UID (t1);\n+      uid2 = TYPE_UID (t2);\n+    }\n+  else\n+    {\n+      uid1 = TYPE_UID (t2);\n+      uid2 = TYPE_UID (t1);\n+    }\n+  gcc_checking_assert (uid1 != uid2);\n+\n+  /* iterative_hash_hashval_t imply an function calls.\n+     We know that UIDS are in limited range.  */\n+  index = ((((unsigned HOST_WIDE_INT)uid1 << HOST_BITS_PER_WIDE_INT / 2) + uid2)\n+\t   % GIMPLE_TYPE_PAIR_SIZE);\n+  if (type_pair_cache [index].uid1 == uid1\n+      && type_pair_cache [index].uid2 == uid2)\n+    return &type_pair_cache[index];\n+\n+  type_pair_cache [index].uid1 = uid1;\n+  type_pair_cache [index].uid2 = uid2;\n+  type_pair_cache [index].same_p[0] = -2;\n+  type_pair_cache [index].same_p[1] = -2;\n+\n+  return &type_pair_cache[index];\n+}\n+\n+/* Per pointer state for the SCC finding.  The on_sccstack flag\n+   is not strictly required, it is true when there is no hash value\n+   recorded for the type and false otherwise.  But querying that\n+   is slower.  */\n+\n+struct sccs\n+{\n+  unsigned int dfsnum;\n+  unsigned int low;\n+  bool on_sccstack;\n+  union {\n+    hashval_t hash;\n+    signed char same_p;\n+  } u;\n+};\n+\n+static unsigned int next_dfs_num;\n+static unsigned int gtc_next_dfs_num;\n+\n+/* GIMPLE type merging cache.  A direct-mapped cache based on TYPE_UID.  */\n+\n+typedef struct GTY(()) gimple_type_leader_entry_s {\n+  tree type;\n+  tree leader;\n+} gimple_type_leader_entry;\n+\n+#define GIMPLE_TYPE_LEADER_SIZE 16381\n+static GTY((deletable, length(\"GIMPLE_TYPE_LEADER_SIZE\")))\n+  gimple_type_leader_entry *gimple_type_leader;\n+\n+/* Lookup an existing leader for T and return it or NULL_TREE, if\n+   there is none in the cache.  */\n+\n+static inline tree\n+gimple_lookup_type_leader (tree t)\n+{\n+  gimple_type_leader_entry *leader;\n+\n+  if (!gimple_type_leader)\n+    return NULL_TREE;\n+\n+  leader = &gimple_type_leader[TYPE_UID (t) % GIMPLE_TYPE_LEADER_SIZE];\n+  if (leader->type != t)\n+    return NULL_TREE;\n+\n+  return leader->leader;\n+}\n+\n+\n+\n+/* Return true if T1 and T2 have the same name.  If FOR_COMPLETION_P is\n+   true then if any type has no name return false, otherwise return\n+   true if both types have no names.  */\n+\n+static bool\n+compare_type_names_p (tree t1, tree t2)\n+{\n+  tree name1 = TYPE_NAME (t1);\n+  tree name2 = TYPE_NAME (t2);\n+\n+  if ((name1 != NULL_TREE) != (name2 != NULL_TREE))\n+    return false;\n+\n+  if (name1 == NULL_TREE)\n+    return true;\n+\n+  /* Either both should be a TYPE_DECL or both an IDENTIFIER_NODE.  */\n+  if (TREE_CODE (name1) != TREE_CODE (name2))\n+    return false;\n+\n+  if (TREE_CODE (name1) == TYPE_DECL)\n+    name1 = DECL_NAME (name1);\n+  gcc_checking_assert (!name1 || TREE_CODE (name1) == IDENTIFIER_NODE);\n+\n+  if (TREE_CODE (name2) == TYPE_DECL)\n+    name2 = DECL_NAME (name2);\n+  gcc_checking_assert (!name2 || TREE_CODE (name2) == IDENTIFIER_NODE);\n+\n+  /* Identifiers can be compared with pointer equality rather\n+     than a string comparison.  */\n+  if (name1 == name2)\n+    return true;\n+\n+  return false;\n+}\n+\n+static bool\n+gimple_types_compatible_p_1 (tree, tree, type_pair_t,\n+\t\t\t     VEC(type_pair_t, heap) **,\n+\t\t\t     struct pointer_map_t *, struct obstack *);\n+\n+/* DFS visit the edge from the callers type pair with state *STATE to\n+   the pair T1, T2 while operating in FOR_MERGING_P mode.\n+   Update the merging status if it is not part of the SCC containing the\n+   callers pair and return it.\n+   SCCSTACK, SCCSTATE and SCCSTATE_OBSTACK are state for the DFS walk done.  */\n+\n+static bool\n+gtc_visit (tree t1, tree t2,\n+\t   struct sccs *state,\n+\t   VEC(type_pair_t, heap) **sccstack,\n+\t   struct pointer_map_t *sccstate,\n+\t   struct obstack *sccstate_obstack)\n+{\n+  struct sccs *cstate = NULL;\n+  type_pair_t p;\n+  void **slot;\n+  tree leader1, leader2;\n+\n+  /* Check first for the obvious case of pointer identity.  */\n+  if (t1 == t2)\n+    return true;\n+\n+  /* Check that we have two types to compare.  */\n+  if (t1 == NULL_TREE || t2 == NULL_TREE)\n+    return false;\n+\n+  /* Can't be the same type if the types don't have the same code.  */\n+  if (TREE_CODE (t1) != TREE_CODE (t2))\n+    return false;\n+\n+  /* Can't be the same type if they have different CV qualifiers.  */\n+  if (TYPE_QUALS (t1) != TYPE_QUALS (t2))\n+    return false;\n+\n+  if (TREE_ADDRESSABLE (t1) != TREE_ADDRESSABLE (t2))\n+    return false;\n+\n+  /* Void types and nullptr types are always the same.  */\n+  if (TREE_CODE (t1) == VOID_TYPE\n+      || TREE_CODE (t1) == NULLPTR_TYPE)\n+    return true;\n+\n+  /* Can't be the same type if they have different alignment or mode.  */\n+  if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n+      || TYPE_MODE (t1) != TYPE_MODE (t2))\n+    return false;\n+\n+  /* Do some simple checks before doing three hashtable queries.  */\n+  if (INTEGRAL_TYPE_P (t1)\n+      || SCALAR_FLOAT_TYPE_P (t1)\n+      || FIXED_POINT_TYPE_P (t1)\n+      || TREE_CODE (t1) == VECTOR_TYPE\n+      || TREE_CODE (t1) == COMPLEX_TYPE\n+      || TREE_CODE (t1) == OFFSET_TYPE\n+      || POINTER_TYPE_P (t1))\n+    {\n+      /* Can't be the same type if they have different sign or precision.  */\n+      if (TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n+\t  || TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2))\n+\treturn false;\n+\n+      if (TREE_CODE (t1) == INTEGER_TYPE\n+\t  && TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2))\n+\treturn false;\n+\n+      /* That's all we need to check for float and fixed-point types.  */\n+      if (SCALAR_FLOAT_TYPE_P (t1)\n+\t  || FIXED_POINT_TYPE_P (t1))\n+\treturn true;\n+\n+      /* For other types fall through to more complex checks.  */\n+    }\n+\n+  /* If the types have been previously registered and found equal\n+     they still are.  */\n+  leader1 = gimple_lookup_type_leader (t1);\n+  leader2 = gimple_lookup_type_leader (t2);\n+  if (leader1 == t2\n+      || t1 == leader2\n+      || (leader1 && leader1 == leader2))\n+    return true;\n+\n+  /* If the hash values of t1 and t2 are different the types can't\n+     possibly be the same.  This helps keeping the type-pair hashtable\n+     small, only tracking comparisons for hash collisions.  */\n+  if (gimple_type_hash (t1) != gimple_type_hash (t2))\n+    return false;\n+\n+  /* Allocate a new cache entry for this comparison.  */\n+  p = lookup_type_pair (t1, t2);\n+  if (p->same_p[GTC_MERGE] == 0 || p->same_p[GTC_MERGE] == 1)\n+    {\n+      /* We have already decided whether T1 and T2 are the\n+\t same, return the cached result.  */\n+      return p->same_p[GTC_MERGE] == 1;\n+    }\n+\n+  if ((slot = pointer_map_contains (sccstate, p)) != NULL)\n+    cstate = (struct sccs *)*slot;\n+  /* Not yet visited.  DFS recurse.  */\n+  if (!cstate)\n+    {\n+      gimple_types_compatible_p_1 (t1, t2, p,\n+\t\t\t\t   sccstack, sccstate, sccstate_obstack);\n+      cstate = (struct sccs *)* pointer_map_contains (sccstate, p);\n+      state->low = MIN (state->low, cstate->low);\n+    }\n+  /* If the type is still on the SCC stack adjust the parents low.  */\n+  if (cstate->dfsnum < state->dfsnum\n+      && cstate->on_sccstack)\n+    state->low = MIN (cstate->dfsnum, state->low);\n+\n+  /* Return the current lattice value.  We start with an equality\n+     assumption so types part of a SCC will be optimistically\n+     treated equal unless proven otherwise.  */\n+  return cstate->u.same_p;\n+}\n+\n+/* Worker for gimple_types_compatible.\n+   SCCSTACK, SCCSTATE and SCCSTATE_OBSTACK are state for the DFS walk done.  */\n+\n+static bool\n+gimple_types_compatible_p_1 (tree t1, tree t2, type_pair_t p,\n+\t\t\t     VEC(type_pair_t, heap) **sccstack,\n+\t\t\t     struct pointer_map_t *sccstate,\n+\t\t\t     struct obstack *sccstate_obstack)\n+{\n+  struct sccs *state;\n+\n+  gcc_assert (p->same_p[GTC_MERGE] == -2);\n+\n+  state = XOBNEW (sccstate_obstack, struct sccs);\n+  *pointer_map_insert (sccstate, p) = state;\n+\n+  VEC_safe_push (type_pair_t, heap, *sccstack, p);\n+  state->dfsnum = gtc_next_dfs_num++;\n+  state->low = state->dfsnum;\n+  state->on_sccstack = true;\n+  /* Start with an equality assumption.  As we DFS recurse into child\n+     SCCs this assumption may get revisited.  */\n+  state->u.same_p = 1;\n+\n+  /* The struct tags shall compare equal.  */\n+  if (!compare_type_names_p (t1, t2))\n+    goto different_types;\n+\n+  /* We may not merge typedef types to the same type in different\n+     contexts.  */\n+  if (TYPE_NAME (t1)\n+      && TREE_CODE (TYPE_NAME (t1)) == TYPE_DECL\n+      && DECL_CONTEXT (TYPE_NAME (t1))\n+      && TYPE_P (DECL_CONTEXT (TYPE_NAME (t1))))\n+    {\n+      if (!gtc_visit (DECL_CONTEXT (TYPE_NAME (t1)),\n+\t\t      DECL_CONTEXT (TYPE_NAME (t2)),\n+\t\t      state, sccstack, sccstate, sccstate_obstack))\n+\tgoto different_types;\n+    }\n+\n+  /* If their attributes are not the same they can't be the same type.  */\n+  if (!attribute_list_equal (TYPE_ATTRIBUTES (t1), TYPE_ATTRIBUTES (t2)))\n+    goto different_types;\n+\n+  /* Do type-specific comparisons.  */\n+  switch (TREE_CODE (t1))\n+    {\n+    case VECTOR_TYPE:\n+    case COMPLEX_TYPE:\n+      if (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t      state, sccstack, sccstate, sccstate_obstack))\n+\tgoto different_types;\n+      goto same_types;\n+\n+    case ARRAY_TYPE:\n+      /* Array types are the same if the element types are the same and\n+\t the number of elements are the same.  */\n+      if (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t      state, sccstack, sccstate, sccstate_obstack)\n+\t  || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)\n+\t  || TYPE_NONALIASED_COMPONENT (t1) != TYPE_NONALIASED_COMPONENT (t2))\n+\tgoto different_types;\n+      else\n+\t{\n+\t  tree i1 = TYPE_DOMAIN (t1);\n+\t  tree i2 = TYPE_DOMAIN (t2);\n+\n+\t  /* For an incomplete external array, the type domain can be\n+ \t     NULL_TREE.  Check this condition also.  */\n+\t  if (i1 == NULL_TREE && i2 == NULL_TREE)\n+\t    goto same_types;\n+\t  else if (i1 == NULL_TREE || i2 == NULL_TREE)\n+\t    goto different_types;\n+\t  else\n+\t    {\n+\t      tree min1 = TYPE_MIN_VALUE (i1);\n+\t      tree min2 = TYPE_MIN_VALUE (i2);\n+\t      tree max1 = TYPE_MAX_VALUE (i1);\n+\t      tree max2 = TYPE_MAX_VALUE (i2);\n+\n+\t      /* The minimum/maximum values have to be the same.  */\n+\t      if ((min1 == min2\n+\t\t   || (min1 && min2\n+\t\t       && ((TREE_CODE (min1) == PLACEHOLDER_EXPR\n+\t\t\t    && TREE_CODE (min2) == PLACEHOLDER_EXPR)\n+\t\t           || operand_equal_p (min1, min2, 0))))\n+\t\t  && (max1 == max2\n+\t\t      || (max1 && max2\n+\t\t\t  && ((TREE_CODE (max1) == PLACEHOLDER_EXPR\n+\t\t\t       && TREE_CODE (max2) == PLACEHOLDER_EXPR)\n+\t\t\t      || operand_equal_p (max1, max2, 0)))))\n+\t\tgoto same_types;\n+\t      else\n+\t\tgoto different_types;\n+\t    }\n+\t}\n+\n+    case METHOD_TYPE:\n+      /* Method types should belong to the same class.  */\n+      if (!gtc_visit (TYPE_METHOD_BASETYPE (t1), TYPE_METHOD_BASETYPE (t2),\n+\t\t      state, sccstack, sccstate, sccstate_obstack))\n+\tgoto different_types;\n+\n+      /* Fallthru  */\n+\n+    case FUNCTION_TYPE:\n+      /* Function types are the same if the return type and arguments types\n+\t are the same.  */\n+      if (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t      state, sccstack, sccstate, sccstate_obstack))\n+\tgoto different_types;\n+\n+      if (!comp_type_attributes (t1, t2))\n+\tgoto different_types;\n+\n+      if (TYPE_ARG_TYPES (t1) == TYPE_ARG_TYPES (t2))\n+\tgoto same_types;\n+      else\n+\t{\n+\t  tree parms1, parms2;\n+\n+\t  for (parms1 = TYPE_ARG_TYPES (t1), parms2 = TYPE_ARG_TYPES (t2);\n+\t       parms1 && parms2;\n+\t       parms1 = TREE_CHAIN (parms1), parms2 = TREE_CHAIN (parms2))\n+\t    {\n+\t      if (!gtc_visit (TREE_VALUE (parms1), TREE_VALUE (parms2),\n+\t\t\t      state, sccstack, sccstate, sccstate_obstack))\n+\t\tgoto different_types;\n+\t    }\n+\n+\t  if (parms1 || parms2)\n+\t    goto different_types;\n+\n+\t  goto same_types;\n+\t}\n+\n+    case OFFSET_TYPE:\n+      {\n+\tif (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\tstate, sccstack, sccstate, sccstate_obstack)\n+\t    || !gtc_visit (TYPE_OFFSET_BASETYPE (t1),\n+\t\t\t   TYPE_OFFSET_BASETYPE (t2),\n+\t\t\t   state, sccstack, sccstate, sccstate_obstack))\n+\t  goto different_types;\n+\n+\tgoto same_types;\n+      }\n+\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+      {\n+\t/* If the two pointers have different ref-all attributes,\n+\t   they can't be the same type.  */\n+\tif (TYPE_REF_CAN_ALIAS_ALL (t1) != TYPE_REF_CAN_ALIAS_ALL (t2))\n+\t  goto different_types;\n+\n+\t/* Otherwise, pointer and reference types are the same if the\n+\t   pointed-to types are the same.  */\n+\tif (gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t       state, sccstack, sccstate, sccstate_obstack))\n+\t  goto same_types;\n+\n+\tgoto different_types;\n+      }\n+\n+    case INTEGER_TYPE:\n+    case BOOLEAN_TYPE:\n+      {\n+\ttree min1 = TYPE_MIN_VALUE (t1);\n+\ttree max1 = TYPE_MAX_VALUE (t1);\n+\ttree min2 = TYPE_MIN_VALUE (t2);\n+\ttree max2 = TYPE_MAX_VALUE (t2);\n+\tbool min_equal_p = false;\n+\tbool max_equal_p = false;\n+\n+\t/* If either type has a minimum value, the other type must\n+\t   have the same.  */\n+\tif (min1 == NULL_TREE && min2 == NULL_TREE)\n+\t  min_equal_p = true;\n+\telse if (min1 && min2 && operand_equal_p (min1, min2, 0))\n+\t  min_equal_p = true;\n+\n+\t/* Likewise, if either type has a maximum value, the other\n+\t   type must have the same.  */\n+\tif (max1 == NULL_TREE && max2 == NULL_TREE)\n+\t  max_equal_p = true;\n+\telse if (max1 && max2 && operand_equal_p (max1, max2, 0))\n+\t  max_equal_p = true;\n+\n+\tif (!min_equal_p || !max_equal_p)\n+\t  goto different_types;\n+\n+\tgoto same_types;\n+      }\n+\n+    case ENUMERAL_TYPE:\n+      {\n+\t/* FIXME lto, we cannot check bounds on enumeral types because\n+\t   different front ends will produce different values.\n+\t   In C, enumeral types are integers, while in C++ each element\n+\t   will have its own symbolic value.  We should decide how enums\n+\t   are to be represented in GIMPLE and have each front end lower\n+\t   to that.  */\n+\ttree v1, v2;\n+\n+\t/* For enumeral types, all the values must be the same.  */\n+\tif (TYPE_VALUES (t1) == TYPE_VALUES (t2))\n+\t  goto same_types;\n+\n+\tfor (v1 = TYPE_VALUES (t1), v2 = TYPE_VALUES (t2);\n+\t     v1 && v2;\n+\t     v1 = TREE_CHAIN (v1), v2 = TREE_CHAIN (v2))\n+\t  {\n+\t    tree c1 = TREE_VALUE (v1);\n+\t    tree c2 = TREE_VALUE (v2);\n+\n+\t    if (TREE_CODE (c1) == CONST_DECL)\n+\t      c1 = DECL_INITIAL (c1);\n+\n+\t    if (TREE_CODE (c2) == CONST_DECL)\n+\t      c2 = DECL_INITIAL (c2);\n+\n+\t    if (tree_int_cst_equal (c1, c2) != 1)\n+\t      goto different_types;\n+\n+\t    if (TREE_PURPOSE (v1) != TREE_PURPOSE (v2))\n+\t      goto different_types;\n+\t  }\n+\n+\t/* If one enumeration has more values than the other, they\n+\t   are not the same.  */\n+\tif (v1 || v2)\n+\t  goto different_types;\n+\n+\tgoto same_types;\n+      }\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n+      {\n+\ttree f1, f2;\n+\n+\t/* For aggregate types, all the fields must be the same.  */\n+\tfor (f1 = TYPE_FIELDS (t1), f2 = TYPE_FIELDS (t2);\n+\t     f1 && f2;\n+\t     f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n+\t  {\n+\t    /* Different field kinds are not compatible.  */\n+\t    if (TREE_CODE (f1) != TREE_CODE (f2))\n+\t      goto different_types;\n+\t    /* Field decls must have the same name and offset.  */\n+\t    if (TREE_CODE (f1) == FIELD_DECL\n+\t\t&& (DECL_NONADDRESSABLE_P (f1) != DECL_NONADDRESSABLE_P (f2)\n+\t\t    || !gimple_compare_field_offset (f1, f2)))\n+\t      goto different_types;\n+\t    /* All entities should have the same name and type.  */\n+\t    if (DECL_NAME (f1) != DECL_NAME (f2)\n+\t\t|| !gtc_visit (TREE_TYPE (f1), TREE_TYPE (f2),\n+\t\t\t       state, sccstack, sccstate, sccstate_obstack))\n+\t      goto different_types;\n+\t  }\n+\n+\t/* If one aggregate has more fields than the other, they\n+\t   are not the same.  */\n+\tif (f1 || f2)\n+\t  goto different_types;\n+\n+\tgoto same_types;\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* Common exit path for types that are not compatible.  */\n+different_types:\n+  state->u.same_p = 0;\n+  goto pop;\n+\n+  /* Common exit path for types that are compatible.  */\n+same_types:\n+  gcc_assert (state->u.same_p == 1);\n+\n+pop:\n+  if (state->low == state->dfsnum)\n+    {\n+      type_pair_t x;\n+\n+      /* Pop off the SCC and set its cache values to the final\n+         comparison result.  */\n+      do\n+\t{\n+\t  struct sccs *cstate;\n+\t  x = VEC_pop (type_pair_t, *sccstack);\n+\t  cstate = (struct sccs *)*pointer_map_contains (sccstate, x);\n+\t  cstate->on_sccstack = false;\n+\t  x->same_p[GTC_MERGE] = state->u.same_p;\n+\t}\n+      while (x != p);\n+    }\n+\n+  return state->u.same_p;\n+}\n+\n+/* Return true iff T1 and T2 are structurally identical.  When\n+   FOR_MERGING_P is true the an incomplete type and a complete type\n+   are considered different, otherwise they are considered compatible.  */\n+\n+static bool\n+gimple_types_compatible_p (tree t1, tree t2)\n+{\n+  VEC(type_pair_t, heap) *sccstack = NULL;\n+  struct pointer_map_t *sccstate;\n+  struct obstack sccstate_obstack;\n+  type_pair_t p = NULL;\n+  bool res;\n+  tree leader1, leader2;\n+\n+  /* Before starting to set up the SCC machinery handle simple cases.  */\n+\n+  /* Check first for the obvious case of pointer identity.  */\n+  if (t1 == t2)\n+    return true;\n+\n+  /* Check that we have two types to compare.  */\n+  if (t1 == NULL_TREE || t2 == NULL_TREE)\n+    return false;\n+\n+  /* Can't be the same type if the types don't have the same code.  */\n+  if (TREE_CODE (t1) != TREE_CODE (t2))\n+    return false;\n+\n+  /* Can't be the same type if they have different CV qualifiers.  */\n+  if (TYPE_QUALS (t1) != TYPE_QUALS (t2))\n+    return false;\n+\n+  if (TREE_ADDRESSABLE (t1) != TREE_ADDRESSABLE (t2))\n+    return false;\n+\n+  /* Void types and nullptr types are always the same.  */\n+  if (TREE_CODE (t1) == VOID_TYPE\n+      || TREE_CODE (t1) == NULLPTR_TYPE)\n+    return true;\n+\n+  /* Can't be the same type if they have different alignment or mode.  */\n+  if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n+      || TYPE_MODE (t1) != TYPE_MODE (t2))\n+    return false;\n+\n+  /* Do some simple checks before doing three hashtable queries.  */\n+  if (INTEGRAL_TYPE_P (t1)\n+      || SCALAR_FLOAT_TYPE_P (t1)\n+      || FIXED_POINT_TYPE_P (t1)\n+      || TREE_CODE (t1) == VECTOR_TYPE\n+      || TREE_CODE (t1) == COMPLEX_TYPE\n+      || TREE_CODE (t1) == OFFSET_TYPE\n+      || POINTER_TYPE_P (t1))\n+    {\n+      /* Can't be the same type if they have different sign or precision.  */\n+      if (TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n+\t  || TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2))\n+\treturn false;\n+\n+      if (TREE_CODE (t1) == INTEGER_TYPE\n+\t  && TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2))\n+\treturn false;\n+\n+      /* That's all we need to check for float and fixed-point types.  */\n+      if (SCALAR_FLOAT_TYPE_P (t1)\n+\t  || FIXED_POINT_TYPE_P (t1))\n+\treturn true;\n+\n+      /* For other types fall through to more complex checks.  */\n+    }\n+\n+  /* If the types have been previously registered and found equal\n+     they still are.  */\n+  leader1 = gimple_lookup_type_leader (t1);\n+  leader2 = gimple_lookup_type_leader (t2);\n+  if (leader1 == t2\n+      || t1 == leader2\n+      || (leader1 && leader1 == leader2))\n+    return true;\n+\n+  /* If the hash values of t1 and t2 are different the types can't\n+     possibly be the same.  This helps keeping the type-pair hashtable\n+     small, only tracking comparisons for hash collisions.  */\n+  if (gimple_type_hash (t1) != gimple_type_hash (t2))\n+    return false;\n+\n+  /* If we've visited this type pair before (in the case of aggregates\n+     with self-referential types), and we made a decision, return it.  */\n+  p = lookup_type_pair (t1, t2);\n+  if (p->same_p[GTC_MERGE] == 0 || p->same_p[GTC_MERGE] == 1)\n+    {\n+      /* We have already decided whether T1 and T2 are the\n+\t same, return the cached result.  */\n+      return p->same_p[GTC_MERGE] == 1;\n+    }\n+\n+  /* Now set up the SCC machinery for the comparison.  */\n+  gtc_next_dfs_num = 1;\n+  sccstate = pointer_map_create ();\n+  gcc_obstack_init (&sccstate_obstack);\n+  res = gimple_types_compatible_p_1 (t1, t2, p,\n+\t\t\t\t     &sccstack, sccstate, &sccstate_obstack);\n+  VEC_free (type_pair_t, heap, sccstack);\n+  pointer_map_destroy (sccstate);\n+  obstack_free (&sccstate_obstack, NULL);\n+\n+  return res;\n+}\n+\n+static hashval_t\n+iterative_hash_gimple_type (tree, hashval_t, VEC(tree, heap) **,\n+\t\t\t    struct pointer_map_t *, struct obstack *);\n+\n+/* DFS visit the edge from the callers type with state *STATE to T.\n+   Update the callers type hash V with the hash for T if it is not part\n+   of the SCC containing the callers type and return it.\n+   SCCSTACK, SCCSTATE and SCCSTATE_OBSTACK are state for the DFS walk done.  */\n+\n+static hashval_t\n+visit (tree t, struct sccs *state, hashval_t v,\n+       VEC (tree, heap) **sccstack,\n+       struct pointer_map_t *sccstate,\n+       struct obstack *sccstate_obstack)\n+{\n+  struct sccs *cstate = NULL;\n+  struct tree_int_map m;\n+  void **slot;\n+\n+  /* If there is a hash value recorded for this type then it can't\n+     possibly be part of our parent SCC.  Simply mix in its hash.  */\n+  m.base.from = t;\n+  if ((slot = htab_find_slot (type_hash_cache, &m, NO_INSERT))\n+      && *slot)\n+    return iterative_hash_hashval_t (((struct tree_int_map *) *slot)->to, v);\n+\n+  if ((slot = pointer_map_contains (sccstate, t)) != NULL)\n+    cstate = (struct sccs *)*slot;\n+  if (!cstate)\n+    {\n+      hashval_t tem;\n+      /* Not yet visited.  DFS recurse.  */\n+      tem = iterative_hash_gimple_type (t, v,\n+\t\t\t\t\tsccstack, sccstate, sccstate_obstack);\n+      if (!cstate)\n+\tcstate = (struct sccs *)* pointer_map_contains (sccstate, t);\n+      state->low = MIN (state->low, cstate->low);\n+      /* If the type is no longer on the SCC stack and thus is not part\n+         of the parents SCC mix in its hash value.  Otherwise we will\n+\t ignore the type for hashing purposes and return the unaltered\n+\t hash value.  */\n+      if (!cstate->on_sccstack)\n+\treturn tem;\n+    }\n+  if (cstate->dfsnum < state->dfsnum\n+      && cstate->on_sccstack)\n+    state->low = MIN (cstate->dfsnum, state->low);\n+\n+  /* We are part of our parents SCC, skip this type during hashing\n+     and return the unaltered hash value.  */\n+  return v;\n+}\n+\n+\n+\n+/* Hash NAME with the previous hash value V and return it.  */\n+\n+static hashval_t\n+iterative_hash_name (tree name, hashval_t v)\n+{\n+  if (!name)\n+    return v;\n+  v = iterative_hash_hashval_t (TREE_CODE (name), v);\n+  if (TREE_CODE (name) == TYPE_DECL)\n+    name = DECL_NAME (name);\n+  if (!name)\n+    return v;\n+  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n+  return iterative_hash_object (IDENTIFIER_HASH_VALUE (name), v);\n+}\n+\n+/* A type, hashvalue pair for sorting SCC members.  */\n+\n+struct type_hash_pair {\n+  tree type;\n+  hashval_t hash;\n+};\n+\n+/* Compare two type, hashvalue pairs.  */\n+\n+static int\n+type_hash_pair_compare (const void *p1_, const void *p2_)\n+{\n+  const struct type_hash_pair *p1 = (const struct type_hash_pair *) p1_;\n+  const struct type_hash_pair *p2 = (const struct type_hash_pair *) p2_;\n+  if (p1->hash < p2->hash)\n+    return -1;\n+  else if (p1->hash > p2->hash)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Returning a hash value for gimple type TYPE combined with VAL.\n+   SCCSTACK, SCCSTATE and SCCSTATE_OBSTACK are state for the DFS walk done.\n+\n+   To hash a type we end up hashing in types that are reachable.\n+   Through pointers we can end up with cycles which messes up the\n+   required property that we need to compute the same hash value\n+   for structurally equivalent types.  To avoid this we have to\n+   hash all types in a cycle (the SCC) in a commutative way.  The\n+   easiest way is to not mix in the hashes of the SCC members at\n+   all.  To make this work we have to delay setting the hash\n+   values of the SCC until it is complete.  */\n+\n+static hashval_t\n+iterative_hash_gimple_type (tree type, hashval_t val,\n+\t\t\t    VEC(tree, heap) **sccstack,\n+\t\t\t    struct pointer_map_t *sccstate,\n+\t\t\t    struct obstack *sccstate_obstack)\n+{\n+  hashval_t v;\n+  void **slot;\n+  struct sccs *state;\n+\n+  /* Not visited during this DFS walk.  */\n+  gcc_checking_assert (!pointer_map_contains (sccstate, type));\n+  state = XOBNEW (sccstate_obstack, struct sccs);\n+  *pointer_map_insert (sccstate, type) = state;\n+\n+  VEC_safe_push (tree, heap, *sccstack, type);\n+  state->dfsnum = next_dfs_num++;\n+  state->low = state->dfsnum;\n+  state->on_sccstack = true;\n+\n+  /* Combine a few common features of types so that types are grouped into\n+     smaller sets; when searching for existing matching types to merge,\n+     only existing types having the same features as the new type will be\n+     checked.  */\n+  v = iterative_hash_name (TYPE_NAME (type), 0);\n+  if (TYPE_NAME (type)\n+      && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+      && DECL_CONTEXT (TYPE_NAME (type))\n+      && TYPE_P (DECL_CONTEXT (TYPE_NAME (type))))\n+    v = visit (DECL_CONTEXT (TYPE_NAME (type)), state, v,\n+\t       sccstack, sccstate, sccstate_obstack);\n+  v = iterative_hash_hashval_t (TREE_CODE (type), v);\n+  v = iterative_hash_hashval_t (TYPE_QUALS (type), v);\n+  v = iterative_hash_hashval_t (TREE_ADDRESSABLE (type), v);\n+\n+  /* Do not hash the types size as this will cause differences in\n+     hash values for the complete vs. the incomplete type variant.  */\n+\n+  /* Incorporate common features of numerical types.  */\n+  if (INTEGRAL_TYPE_P (type)\n+      || SCALAR_FLOAT_TYPE_P (type)\n+      || FIXED_POINT_TYPE_P (type))\n+    {\n+      v = iterative_hash_hashval_t (TYPE_PRECISION (type), v);\n+      v = iterative_hash_hashval_t (TYPE_MODE (type), v);\n+      v = iterative_hash_hashval_t (TYPE_UNSIGNED (type), v);\n+    }\n+\n+  /* For pointer and reference types, fold in information about the type\n+     pointed to.  */\n+  if (POINTER_TYPE_P (type))\n+    v = visit (TREE_TYPE (type), state, v,\n+\t       sccstack, sccstate, sccstate_obstack);\n+\n+  /* For integer types hash the types min/max values and the string flag.  */\n+  if (TREE_CODE (type) == INTEGER_TYPE)\n+    {\n+      /* OMP lowering can introduce error_mark_node in place of\n+\t random local decls in types.  */\n+      if (TYPE_MIN_VALUE (type) != error_mark_node)\n+\tv = iterative_hash_expr (TYPE_MIN_VALUE (type), v);\n+      if (TYPE_MAX_VALUE (type) != error_mark_node)\n+\tv = iterative_hash_expr (TYPE_MAX_VALUE (type), v);\n+      v = iterative_hash_hashval_t (TYPE_STRING_FLAG (type), v);\n+    }\n+\n+  /* For array types hash the domain and the string flag.  */\n+  if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type))\n+    {\n+      v = iterative_hash_hashval_t (TYPE_STRING_FLAG (type), v);\n+      v = visit (TYPE_DOMAIN (type), state, v,\n+\t\t sccstack, sccstate, sccstate_obstack);\n+    }\n+\n+  /* Recurse for aggregates with a single element type.  */\n+  if (TREE_CODE (type) == ARRAY_TYPE\n+      || TREE_CODE (type) == COMPLEX_TYPE\n+      || TREE_CODE (type) == VECTOR_TYPE)\n+    v = visit (TREE_TYPE (type), state, v,\n+\t       sccstack, sccstate, sccstate_obstack);\n+\n+  /* Incorporate function return and argument types.  */\n+  if (TREE_CODE (type) == FUNCTION_TYPE || TREE_CODE (type) == METHOD_TYPE)\n+    {\n+      unsigned na;\n+      tree p;\n+\n+      /* For method types also incorporate their parent class.  */\n+      if (TREE_CODE (type) == METHOD_TYPE)\n+\tv = visit (TYPE_METHOD_BASETYPE (type), state, v,\n+\t\t   sccstack, sccstate, sccstate_obstack);\n+\n+      /* Check result and argument types.  */\n+      v = visit (TREE_TYPE (type), state, v,\n+\t\t sccstack, sccstate, sccstate_obstack);\n+      for (p = TYPE_ARG_TYPES (type), na = 0; p; p = TREE_CHAIN (p))\n+\t{\n+\t  v = visit (TREE_VALUE (p), state, v,\n+\t\t     sccstack, sccstate, sccstate_obstack);\n+\t  na++;\n+\t}\n+\n+      v = iterative_hash_hashval_t (na, v);\n+    }\n+\n+  if (RECORD_OR_UNION_TYPE_P (type))\n+    {\n+      unsigned nf;\n+      tree f;\n+\n+      for (f = TYPE_FIELDS (type), nf = 0; f; f = TREE_CHAIN (f))\n+\t{\n+\t  v = iterative_hash_name (DECL_NAME (f), v);\n+\t  v = visit (TREE_TYPE (f), state, v,\n+\t\t     sccstack, sccstate, sccstate_obstack);\n+\t  nf++;\n+\t}\n+\n+      v = iterative_hash_hashval_t (nf, v);\n+    }\n+\n+  /* Record hash for us.  */\n+  state->u.hash = v;\n+\n+  /* See if we found an SCC.  */\n+  if (state->low == state->dfsnum)\n+    {\n+      tree x;\n+      struct tree_int_map *m;\n+\n+      /* Pop off the SCC and set its hash values.  */\n+      x = VEC_pop (tree, *sccstack);\n+      /* Optimize SCC size one.  */\n+      if (x == type)\n+\t{\n+\t  state->on_sccstack = false;\n+\t  m = ggc_alloc_cleared_tree_int_map ();\n+\t  m->base.from = x;\n+\t  m->to = v;\n+\t  slot = htab_find_slot (type_hash_cache, m, INSERT);\n+\t  gcc_assert (!*slot);\n+\t  *slot = (void *) m;\n+\t}\n+      else\n+\t{\n+\t  struct sccs *cstate;\n+\t  unsigned first, i, size, j;\n+\t  struct type_hash_pair *pairs;\n+\t  /* Pop off the SCC and build an array of type, hash pairs.  */\n+\t  first = VEC_length (tree, *sccstack) - 1;\n+\t  while (VEC_index (tree, *sccstack, first) != type)\n+\t    --first;\n+\t  size = VEC_length (tree, *sccstack) - first + 1;\n+\t  pairs = XALLOCAVEC (struct type_hash_pair, size);\n+\t  i = 0;\n+\t  cstate = (struct sccs *)*pointer_map_contains (sccstate, x);\n+\t  cstate->on_sccstack = false;\n+\t  pairs[i].type = x;\n+\t  pairs[i].hash = cstate->u.hash;\n+\t  do\n+\t    {\n+\t      x = VEC_pop (tree, *sccstack);\n+\t      cstate = (struct sccs *)*pointer_map_contains (sccstate, x);\n+\t      cstate->on_sccstack = false;\n+\t      ++i;\n+\t      pairs[i].type = x;\n+\t      pairs[i].hash = cstate->u.hash;\n+\t    }\n+\t  while (x != type);\n+\t  gcc_assert (i + 1 == size);\n+\t  /* Sort the arrays of type, hash pairs so that when we mix in\n+\t     all members of the SCC the hash value becomes independent on\n+\t     the order we visited the SCC.  Disregard hashes equal to\n+\t     the hash of the type we mix into because we cannot guarantee\n+\t     a stable sort for those across different TUs.  */\n+\t  qsort (pairs, size, sizeof (struct type_hash_pair),\n+\t\t type_hash_pair_compare);\n+\t  for (i = 0; i < size; ++i)\n+\t    {\n+\t      hashval_t hash;\n+\t      m = ggc_alloc_cleared_tree_int_map ();\n+\t      m->base.from = pairs[i].type;\n+\t      hash = pairs[i].hash;\n+\t      /* Skip same hashes.  */\n+\t      for (j = i + 1; j < size && pairs[j].hash == pairs[i].hash; ++j)\n+\t\t;\n+\t      for (; j < size; ++j)\n+\t\thash = iterative_hash_hashval_t (pairs[j].hash, hash);\n+\t      for (j = 0; pairs[j].hash != pairs[i].hash; ++j)\n+\t\thash = iterative_hash_hashval_t (pairs[j].hash, hash);\n+\t      m->to = hash;\n+\t      if (pairs[i].type == type)\n+\t\tv = hash;\n+\t      slot = htab_find_slot (type_hash_cache, m, INSERT);\n+\t      gcc_assert (!*slot);\n+\t      *slot = (void *) m;\n+\t    }\n+\t}\n+    }\n+\n+  return iterative_hash_hashval_t (v, val);\n+}\n+\n+/* Returns a hash value for P (assumed to be a type).  The hash value\n+   is computed using some distinguishing features of the type.  Note\n+   that we cannot use pointer hashing here as we may be dealing with\n+   two distinct instances of the same type.\n+\n+   This function should produce the same hash value for two compatible\n+   types according to gimple_types_compatible_p.  */\n+\n+static hashval_t\n+gimple_type_hash (const void *p)\n+{\n+  const_tree t = (const_tree) p;\n+  VEC(tree, heap) *sccstack = NULL;\n+  struct pointer_map_t *sccstate;\n+  struct obstack sccstate_obstack;\n+  hashval_t val;\n+  void **slot;\n+  struct tree_int_map m;\n+\n+  if (type_hash_cache == NULL)\n+    type_hash_cache = htab_create_ggc (512, tree_int_map_hash,\n+\t\t\t\t       tree_int_map_eq, NULL);\n+\n+  m.base.from = CONST_CAST_TREE (t);\n+  if ((slot = htab_find_slot (type_hash_cache, &m, NO_INSERT))\n+      && *slot)\n+    return iterative_hash_hashval_t (((struct tree_int_map *) *slot)->to, 0);\n+\n+  /* Perform a DFS walk and pre-hash all reachable types.  */\n+  next_dfs_num = 1;\n+  sccstate = pointer_map_create ();\n+  gcc_obstack_init (&sccstate_obstack);\n+  val = iterative_hash_gimple_type (CONST_CAST_TREE (t), 0,\n+\t\t\t\t    &sccstack, sccstate, &sccstate_obstack);\n+  VEC_free (tree, heap, sccstack);\n+  pointer_map_destroy (sccstate);\n+  obstack_free (&sccstate_obstack, NULL);\n+\n+  return val;\n+}\n+/* Returns nonzero if P1 and P2 are equal.  */\n+\n+static int\n+gimple_type_eq (const void *p1, const void *p2)\n+{\n+  const_tree t1 = (const_tree) p1;\n+  const_tree t2 = (const_tree) p2;\n+  return gimple_types_compatible_p (CONST_CAST_TREE (t1),\n+\t\t\t\t    CONST_CAST_TREE (t2));\n+}\n+\n+\n+/* Worker for gimple_register_type.\n+   Register type T in the global type table gimple_types.\n+   When REGISTERING_MV is false first recurse for the main variant of T.  */\n+\n+static tree\n+gimple_register_type_1 (tree t, bool registering_mv)\n+{\n+  void **slot;\n+  gimple_type_leader_entry *leader;\n+\n+  /* If we registered this type before return the cached result.  */\n+  leader = &gimple_type_leader[TYPE_UID (t) % GIMPLE_TYPE_LEADER_SIZE];\n+  if (leader->type == t)\n+    return leader->leader;\n+\n+  /* Always register the main variant first.  This is important so we\n+     pick up the non-typedef variants as canonical, otherwise we'll end\n+     up taking typedef ids for structure tags during comparison.\n+     It also makes sure that main variants will be merged to main variants.\n+     As we are operating on a possibly partially fixed up type graph\n+     do not bother to recurse more than once, otherwise we may end up\n+     walking in circles.\n+     If we are registering a main variant it will either remain its\n+     own main variant or it will be merged to something else in which\n+     case we do not care for the main variant leader.  */\n+  if (!registering_mv\n+      && TYPE_MAIN_VARIANT (t) != t)\n+    gimple_register_type_1 (TYPE_MAIN_VARIANT (t), true);\n+\n+  /* See if we already have an equivalent type registered.  */\n+  slot = htab_find_slot (gimple_types, t, INSERT);\n+  if (*slot\n+      && *(tree *)slot != t)\n+    {\n+      tree new_type = (tree) *((tree *) slot);\n+      leader->type = t;\n+      leader->leader = new_type;\n+      return new_type;\n+    }\n+\n+  /* If not, insert it to the cache and the hash.  */\n+  leader->type = t;\n+  leader->leader = t;\n+  *slot = (void *) t;\n+  return t;\n+}\n+\n+/* Register type T in the global type table gimple_types.\n+   If another type T', compatible with T, already existed in\n+   gimple_types then return T', otherwise return T.  This is used by\n+   LTO to merge identical types read from different TUs.  */\n+\n+static tree\n+gimple_register_type (tree t)\n+{\n+  gcc_assert (TYPE_P (t));\n+\n+  if (!gimple_type_leader)\n+    gimple_type_leader = ggc_alloc_cleared_vec_gimple_type_leader_entry_s\n+\t\t\t\t(GIMPLE_TYPE_LEADER_SIZE);\n+\n+  if (gimple_types == NULL)\n+    gimple_types = htab_create_ggc (16381, gimple_type_hash, gimple_type_eq, 0);\n+\n+  return gimple_register_type_1 (t, false);\n+}\n+\n+#define GIMPLE_REGISTER_TYPE(tt) \\\n+   (TREE_VISITED (tt) ? gimple_register_type (tt) : tt)\n+\n+\n+\n /* A hashtable of trees that potentially refer to variables or functions\n    that must be replaced with their prevailing variant.  */\n static GTY((if_marked (\"ggc_marked_p\"), param_is (union tree_node))) htab_t\n@@ -289,9 +1422,6 @@ remember_with_vars (tree t)\n   *(tree *) htab_find_slot (tree_with_vars, t, INSERT) = t;\n }\n \n-#define GIMPLE_REGISTER_TYPE(tt) \\\n-   (TREE_VISITED (tt) ? gimple_register_type (tt) : tt)\n-\n #define LTO_FIXUP_TREE(tt) \\\n   do \\\n     { \\\n@@ -1835,6 +2965,22 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   lto_fixup_decls (all_file_decl_data);\n   htab_delete (tree_with_vars);\n   tree_with_vars = NULL;\n+  if (gimple_types)\n+    {\n+      htab_delete (gimple_types);\n+      gimple_types = NULL;\n+    }\n+  if (type_hash_cache)\n+    {\n+      htab_delete (type_hash_cache);\n+      type_hash_cache = NULL;\n+    }\n+  if (type_pair_cache)\n+    {\n+      free (type_pair_cache);\n+      type_pair_cache = NULL;\n+    }\n+  gimple_type_leader = NULL;\n   free_gimple_type_tables ();\n   ggc_collect ();\n \n@@ -1936,6 +3082,38 @@ materialize_cgraph (void)\n }\n \n \n+/* Show various memory usage statistics related to LTO.  */\n+static void\n+print_lto_report_1 (void)\n+{\n+  const char *pfx = (flag_lto) ? \"LTO\" : (flag_wpa) ? \"WPA\" : \"LTRANS\";\n+  fprintf (stderr, \"%s statistics\\n\", pfx);\n+\n+  if (gimple_types)\n+    fprintf (stderr, \"[%s] GIMPLE type table: size %ld, %ld elements, \"\n+\t     \"%ld searches, %ld collisions (ratio: %f)\\n\", pfx,\n+\t     (long) htab_size (gimple_types),\n+\t     (long) htab_elements (gimple_types),\n+\t     (long) gimple_types->searches,\n+\t     (long) gimple_types->collisions,\n+\t     htab_collisions (gimple_types));\n+  else\n+    fprintf (stderr, \"[%s] GIMPLE type table is empty\\n\", pfx);\n+  if (type_hash_cache)\n+    fprintf (stderr, \"[%s] GIMPLE type hash table: size %ld, %ld elements, \"\n+\t     \"%ld searches, %ld collisions (ratio: %f)\\n\", pfx,\n+\t     (long) htab_size (type_hash_cache),\n+\t     (long) htab_elements (type_hash_cache),\n+\t     (long) type_hash_cache->searches,\n+\t     (long) type_hash_cache->collisions,\n+\t     htab_collisions (type_hash_cache));\n+  else\n+    fprintf (stderr, \"[%s] GIMPLE type hash table is empty\\n\", pfx);\n+\n+  print_gimple_types_stats (pfx);\n+  print_lto_report (pfx);\n+}\n+\n /* Perform whole program analysis (WPA) on the callgraph and write out the\n    optimization plan.  */\n \n@@ -2010,7 +3188,7 @@ do_whole_program_analysis (void)\n \n   /* Show the LTO report before launching LTRANS.  */\n   if (flag_lto_report)\n-    print_lto_report ();\n+    print_lto_report_1 ();\n   if (mem_report_wpa)\n     dump_memory_report (true);\n }\n@@ -2136,7 +3314,7 @@ lto_main (void)\n \t     launched directly by the driver we would not need to do\n \t     this.  */\n \t  if (flag_lto_report)\n-\t    print_lto_report ();\n+\t    print_lto_report_1 ();\n \t}\n     }\n "}]}