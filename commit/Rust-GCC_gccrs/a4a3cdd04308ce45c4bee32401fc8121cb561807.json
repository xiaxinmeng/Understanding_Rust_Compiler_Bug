{"sha": "a4a3cdd04308ce45c4bee32401fc8121cb561807", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRhM2NkZDA0MzA4Y2U0NWM0YmVlMzI0MDFmYzgxMjFjYjU2MTgwNw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-05-10T14:24:08Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-05-10T14:24:08Z"}, "message": "ipa: Get rid of IPA_NODE_REF and IPA_EDGE_REF\n\nThe node and edge summaries defined in ipa-prop.h are probably the\noldest in GCC and so it happened that they are the only ones using\nmacros to look them up and create them.  With Honza and Martin we\nagreed it is ugly and the macros should be removed and the ipa-prop\nsummaries should be accessed like all the other ones but somehow I\nnever got to it until now.\n\nThe patch is mostly mechanical.  Because the lookup machinery was much\nsimpler in the old times (something like the fast summaries we have\ntoday), a lot of code queried for the summary multiple times for no\ngood reasons and I fixed that in places where it was easy.\n\nAlso, before we switched to hash based summaries, new summary pointers\nhad to be obtained whenever the underlying array could be reallocated\nbecause of new cgraph nodes/edges.  This is no longer necessary and so\nI removed the instances which I found.\n\nBoth kinds of these non-mechanical changes should be specifically called\nout in the ChangeLog.\n\nI also removed the IS_VALID_JUMP_FUNC_INDEX macro because it not used\nanywhere.\n\ngcc/ChangeLog:\n\n2021-05-07  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.h (IPA_NODE_REF): Removed.\n\t(IPA_NODE_REF_GET_CREATE): Likewise.\n\t(IPA_EDGE_REF): Likewise.\n\t(IPA_EDGE_REF_GET_CREATE): Likewise.\n\t(IS_VALID_JUMP_FUNC_INDEX): Likewise.\n\t* ipa-cp.c (print_all_lattices): Replaced IPA_NODE_REF with a direct\n\tuse of ipa_node_params_sum.\n\t(ipcp_versionable_function_p): Likewise.\n\t(push_node_to_stack): Likewise.\n\t(pop_node_from_stack): Likewise.\n\t(set_single_call_flag): Replaced two IPA_NODE_REF with one single\n\tdirect use of ipa_node_params_sum.\n\t(initialize_node_lattices): Replaced IPA_NODE_REF with a direct use of\n\tipa_node_params_sum.\n\t(ipa_context_from_jfunc): Replaced IPA_EDGE_REF with a direct use of\n\tipa_edge_args_sum.\n\t(ipcp_verify_propagated_values): Replaced IPA_NODE_REF with a direct\n\tuse of ipa_node_params_sum.\n\t(self_recursively_generated_p): Likewise.\n\t(propagate_scalar_across_jump_function): Likewise.\n\t(propagate_context_across_jump_function): Replaced IPA_EDGE_REF with a\n\tdirect use of ipa_edge_args_sum, moved the lookup after the early\n\texit.  Replaced IPA_NODE_REF with a direct use of ipa_node_params_sum.\n\t(propagate_bits_across_jump_function): Replaced IPA_NODE_REF with\n\tdirect uses of ipa_node_params_sum.\n\t(propagate_vr_across_jump_function): Likewise.\n\t(propagate_aggregate_lattice): Likewise.\n\t(propagate_aggs_across_jump_function): Likewise.\n\t(propagate_constants_across_call): Likewise, also replaced\n\tIPA_EDGE_REF with a direct use of ipa_edge_args_sum.\n\t(good_cloning_opportunity_p): Replaced IPA_NODE_REF with a direct use\n\tof ipa_node_params_sum.\n\t(estimate_local_effects): Likewise.\n\t(add_all_node_vals_to_toposort): Likewise.\n\t(propagate_constants_topo): Likewise.\n\t(ipcp_propagate_stage): Likewise.\n\t(ipcp_discover_new_direct_edges): Likewise.\n\t(calls_same_node_or_its_all_contexts_clone_p): Likewise.\n\t(cgraph_edge_brings_value_p): Likewise (in both overloaded functions).\n\t(get_info_about_necessary_edges): Likewise.\n\t(want_remove_some_param_p): Likewise.\n\t(create_specialized_node): Likewise.\n\t(self_recursive_pass_through_p): Likewise.\n\t(self_recursive_agg_pass_through_p): Likewise.\n\t(find_more_scalar_values_for_callers_subset): Likewise and also\n\treplaced IPA_EDGE_REF with direct uses of ipa_edge_args_sum, in one\n\tcase replacing two of those with a single query.\n\t(find_more_contexts_for_caller_subset): Likewise for the\n\tipa_polymorphic_call_context overload.\n\t(intersect_aggregates_with_edge): Replaced IPA_EDGE_REF with a direct\n\tuse of ipa_edge_args_sum.  Replaced IPA_NODE_REF with direct uses of\n\tipa_node_params_sum.\n\t(find_aggregate_values_for_callers_subset): Likewise, also reusing\n\tresults of ipa_edge_args_sum->get.\n\t(cgraph_edge_brings_all_scalars_for_node): Replaced IPA_NODE_REF with\n\tdirect uses of ipa_node_params_sum, replaced IPA_EDGE_REF with a\n\tdirect use of ipa_edge_args_sum.\n\t(cgraph_edge_brings_all_agg_vals_for_node): Likewise, moved node\n\tsummary query after the early exit and reused the result later.\n\t(decide_about_value): Replaced IPA_NODE_REF with a direct use of\n\tipa_node_params_sum.\n\t(decide_whether_version_node): Likewise.  Removed re-querying for\n\tsummaries after cloning.\n\t(spread_undeadness): Replaced IPA_NODE_REF with a direct use of\n\tipa_node_params_sum.\n\t(has_undead_caller_from_outside_scc_p): Likewise, reusing results of\n\tsome queries.\n\t(identify_dead_nodes): Likewise.\n\t(ipcp_store_bits_results): Replaced IPA_NODE_REF with direct uses of\n\tipa_node_params_sum.\n\t(ipcp_store_vr_results): Likewise.\n\t* ipa-fnsummary.c (evaluate_properties_for_edge): Likewise.\n\t(ipa_fn_summary_t::duplicate): Likewise.\n\t(analyze_function_body): Likewise.\n\t(estimate_calls_size_and_time): Likewise.\n\t(ipa_cached_call_context::duplicate_from): Likewise.\n\t(ipa_call_context::equal_to): Likewise.\n\t(remap_edge_params): Likewise.\n\t(ipa_merge_fn_summary_after_inlining): Likewise.\n\t(inline_read_section): Likewise.\n\t* ipa-icf.c (sem_function::param_used_p): Likewise.\n\t* ipa-modref.c (compute_parm_map): Likewise.\n\t(compute_parm_map): Replaced IPA_EDGE_REF with a direct use of\n\tipa_edge_args_sum.\n\t(get_access_for_fnspec): Replaced IPA_NODE_REF with a direct use of\n\tipa_node_params_sum and replaced IPA_EDGE_REF with a direct use of\n\tipa_edge_args_sum.\n\t* ipa-profile.c (check_argument_count): Likewise.\n\t* ipa-prop.c (ipa_alloc_node_params): Replaced IPA_NODE_REF_GET_CREATE\n\twith a direct use of ipa_node_params_sum.\n\t(ipa_initialize_node_params): Likewise.\n\t(ipa_print_node_jump_functions_for_edge): Replaced IPA_EDGE_REF with a\n\tdirect use of ipa_edge_args_sum and reused the query result.\n\t(ipa_compute_jump_functions_for_edge): Replaced IPA_NODE_REF with a\n\tdirect use of ipa_node_params_sum and replaced IPA_EDGE_REF with a\n\tdirect use of ipa_edge_args_sum.\n\t(ipa_note_param_call): Replaced IPA_NODE_REF with a direct use of\n\tipa_node_params_sum and reused the result of the query.\n\t(ipa_analyze_node): Likewise.\n\t(ipa_analyze_controlled_uses): Replaced IPA_NODE_REF with a direct use\n\tof ipa_node_params_sum.\n\t(update_jump_functions_after_inlining): Replaced IPA_EDGE_REF with\n\tdirect uses of ipa_edge_args_sum.\n\t(update_indirect_edges_after_inlining): Replaced IPA_NODE_REF with\n\tdirect uses of ipa_node_params_sum and replaced IPA_EDGE_REF with a\n\tdirect use of ipa_edge_args_sum.  Removed superficial re-querying the\n\ttop edge summary.\n\t(propagate_controlled_uses): Replaced IPA_NODE_REF with direct uses of\n\tipa_node_params_sum and replaced IPA_EDGE_REF with a direct use of\n\tipa_edge_args_sum.\n\t(ipa_propagate_indirect_call_infos): Replaced IPA_EDGE_REF with a\n\tdirect use of ipa_edge_args_sum.\n\t(ipa_edge_args_sum_t::duplicate): Replaced IPA_NODE_REF with a direct\n\tuse of ipa_node_params_sum.\n\t(ipa_print_node_params): Likewise.\n\t(ipa_write_node_info): Likewise and also replaced IPA_EDGE_REF with\n\tdirect uses of ipa_edge_args_sum.\n\t(ipa_read_edge_info): Replaced IPA_EDGE_REF with a direct use of\n\tipa_edge_args_sum.\n\t(ipa_read_node_info): Replaced IPA_NODE_REF with a direct use of\n\tipa_node_params_sum.\n\t(ipa_prop_write_jump_functions): Likewise.  Move variable node to the\n\tscopes where it is used.", "tree": {"sha": "444dcf6a26e9b547434042e375220d0a201b9f5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/444dcf6a26e9b547434042e375220d0a201b9f5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4a3cdd04308ce45c4bee32401fc8121cb561807", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4a3cdd04308ce45c4bee32401fc8121cb561807", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4a3cdd04308ce45c4bee32401fc8121cb561807", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4a3cdd04308ce45c4bee32401fc8121cb561807/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0498d2d09a2364aae1e6b5e085c8ebb8fc517684", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0498d2d09a2364aae1e6b5e085c8ebb8fc517684", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0498d2d09a2364aae1e6b5e085c8ebb8fc517684"}], "stats": {"total": 342, "additions": 172, "deletions": 170}, "files": [{"sha": "2cae69e5a1b6216225c8b633da99e90151359e14", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 108, "deletions": 95, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a3cdd04308ce45c4bee32401fc8121cb561807/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a3cdd04308ce45c4bee32401fc8121cb561807/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=a4a3cdd04308ce45c4bee32401fc8121cb561807", "patch": "@@ -550,7 +550,7 @@ print_all_lattices (FILE * f, bool dump_sources, bool dump_benefits)\n     {\n       class ipa_node_params *info;\n \n-      info = IPA_NODE_REF (node);\n+      info = ipa_node_params_sum->get (node);\n       /* Skip unoptimized functions and constprop clones since we don't make\n \t lattices for them.  */\n       if (!info || info->ipcp_orig_node)\n@@ -666,7 +666,8 @@ determine_versionability (struct cgraph_node *node,\n static bool\n ipcp_versionable_function_p (struct cgraph_node *node)\n {\n-  return IPA_NODE_REF (node) && IPA_NODE_REF (node)->versionable;\n+  ipa_node_params *info = ipa_node_params_sum->get (node);\n+  return info && info->versionable;\n }\n \n /* Structure holding accumulated information about callers of a node.  */\n@@ -861,7 +862,7 @@ free_toporder_info (class ipa_topo_info *topo)\n static inline void\n push_node_to_stack (class ipa_topo_info *topo, struct cgraph_node *node)\n {\n-  class ipa_node_params *info = IPA_NODE_REF (node);\n+  ipa_node_params *info = ipa_node_params_sum->get (node);\n   if (info->node_enqueued)\n     return;\n   info->node_enqueued = 1;\n@@ -879,7 +880,7 @@ pop_node_from_stack (class ipa_topo_info *topo)\n       struct cgraph_node *node;\n       topo->stack_top--;\n       node = topo->stack[topo->stack_top];\n-      IPA_NODE_REF (node)->node_enqueued = 0;\n+      ipa_node_params_sum->get (node)->node_enqueued = 0;\n       return node;\n     }\n   else\n@@ -1178,11 +1179,12 @@ set_single_call_flag (cgraph_node *node, void *)\n   /* Local thunks can be handled transparently, skip them.  */\n   while (cs && cs->caller->thunk && cs->caller->local)\n     cs = cs->next_caller;\n-  if (cs && IPA_NODE_REF (cs->caller))\n-    {\n-      IPA_NODE_REF (cs->caller)->node_calling_single_call = true;\n-      return true;\n-    }\n+  if (cs)\n+    if (ipa_node_params* info = ipa_node_params_sum->get (cs->caller))\n+      {\n+\tinfo->node_calling_single_call = true;\n+\treturn true;\n+      }\n   return false;\n }\n \n@@ -1191,7 +1193,7 @@ set_single_call_flag (cgraph_node *node, void *)\n static void\n initialize_node_lattices (struct cgraph_node *node)\n {\n-  class ipa_node_params *info = IPA_NODE_REF (node);\n+  ipa_node_params *info = ipa_node_params_sum->get (node);\n   struct cgraph_edge *ie;\n   bool disable = false, variable = false;\n   int i;\n@@ -1482,7 +1484,7 @@ ipa_polymorphic_call_context\n ipa_context_from_jfunc (ipa_node_params *info, cgraph_edge *cs, int csidx,\n \t\t\tipa_jump_func *jfunc)\n {\n-  ipa_edge_args *args = IPA_EDGE_REF (cs);\n+  ipa_edge_args *args = ipa_edge_args_sum->get (cs);\n   ipa_polymorphic_call_context ctx;\n   ipa_polymorphic_call_context *edge_ctx\n     = cs ? ipa_get_ith_polymorhic_call_context (args, csidx) : NULL;\n@@ -1769,7 +1771,7 @@ ipcp_verify_propagated_values (void)\n \n   FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n     {\n-      class ipa_node_params *info = IPA_NODE_REF (node);\n+      ipa_node_params *info = ipa_node_params_sum->get (node);\n       if (!opt_for_fn (node->decl, flag_ipa_cp)\n \t  || !opt_for_fn (node->decl, optimize))\n \tcontinue;\n@@ -1957,7 +1959,7 @@ self_recursively_generated_p (ipcp_value<tree> *val)\n \tcontinue;\n \n       if (!info)\n-\tinfo = IPA_NODE_REF (cs->caller);\n+\tinfo = ipa_node_params_sum->get (cs->caller);\n \n       class ipcp_param_lattices *plats = ipa_get_parm_lattices (info,\n \t\t\t\t\t\t\t\tsrc->index);\n@@ -2196,7 +2198,7 @@ propagate_scalar_across_jump_function (struct cgraph_edge *cs,\n   else if (jfunc->type == IPA_JF_PASS_THROUGH\n \t   || jfunc->type == IPA_JF_ANCESTOR)\n     {\n-      class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      ipa_node_params *caller_info = ipa_node_params_sum->get (cs->caller);\n       ipcp_lattice<tree> *src_lat;\n       int src_idx;\n       bool ret;\n@@ -2243,9 +2245,9 @@ propagate_context_across_jump_function (cgraph_edge *cs,\n \t\t\t  ipa_jump_func *jfunc, int idx,\n \t\t\t  ipcp_lattice<ipa_polymorphic_call_context> *dest_lat)\n {\n-  ipa_edge_args *args = IPA_EDGE_REF (cs);\n   if (dest_lat->bottom)\n     return false;\n+  ipa_edge_args *args = ipa_edge_args_sum->get (cs);\n   bool ret = false;\n   bool added_sth = false;\n   bool type_preserved = true;\n@@ -2259,7 +2261,7 @@ propagate_context_across_jump_function (cgraph_edge *cs,\n   if (jfunc->type == IPA_JF_PASS_THROUGH\n       || jfunc->type == IPA_JF_ANCESTOR)\n     {\n-      class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      ipa_node_params *caller_info = ipa_node_params_sum->get (cs->caller);\n       int src_idx;\n       ipcp_lattice<ipa_polymorphic_call_context> *src_lat;\n \n@@ -2334,7 +2336,7 @@ propagate_bits_across_jump_function (cgraph_edge *cs, int idx,\n \n   enum availability availability;\n   cgraph_node *callee = cs->callee->function_symbol (&availability);\n-  class ipa_node_params *callee_info = IPA_NODE_REF (callee);\n+  ipa_node_params *callee_info = ipa_node_params_sum->get (callee);\n   tree parm_type = ipa_get_type (callee_info, idx);\n \n   /* For K&R C programs, ipa_get_type() could return NULL_TREE.  Avoid the\n@@ -2357,7 +2359,7 @@ propagate_bits_across_jump_function (cgraph_edge *cs, int idx,\n   if (jfunc->type == IPA_JF_PASS_THROUGH\n       || jfunc->type == IPA_JF_ANCESTOR)\n     {\n-      class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      ipa_node_params *caller_info = ipa_node_params_sum->get (cs->caller);\n       tree operand = NULL_TREE;\n       enum tree_code code;\n       unsigned src_idx;\n@@ -2430,7 +2432,7 @@ propagate_vr_across_jump_function (cgraph_edge *cs, ipa_jump_func *jfunc,\n   if (jfunc->type == IPA_JF_PASS_THROUGH)\n     {\n       enum tree_code operation = ipa_get_jf_pass_through_operation (jfunc);\n-      class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      ipa_node_params *caller_info = ipa_node_params_sum->get (cs->caller);\n       int src_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n       class ipcp_param_lattices *src_lats\n \t= ipa_get_parm_lattices (caller_info, src_idx);\n@@ -2702,7 +2704,7 @@ propagate_aggregate_lattice (struct cgraph_edge *cs,\n   gcc_checking_assert (item->jftype == IPA_JF_PASS_THROUGH\n \t\t       || item->jftype == IPA_JF_LOAD_AGG);\n \n-  caller_info = IPA_NODE_REF (cs->caller);\n+  caller_info = ipa_node_params_sum->get (cs->caller);\n   src_idx = item->value.pass_through.formal_id;\n   src_plats = ipa_get_parm_lattices (caller_info, src_idx);\n \n@@ -2768,7 +2770,7 @@ propagate_aggs_across_jump_function (struct cgraph_edge *cs,\n   if (jfunc->type == IPA_JF_PASS_THROUGH\n       && ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n     {\n-      class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      ipa_node_params *caller_info = ipa_node_params_sum->get (cs->caller);\n       int src_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n       class ipcp_param_lattices *src_plats;\n \n@@ -2786,7 +2788,7 @@ propagate_aggs_across_jump_function (struct cgraph_edge *cs,\n   else if (jfunc->type == IPA_JF_ANCESTOR\n \t   && ipa_get_jf_ancestor_agg_preserved (jfunc))\n     {\n-      class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      ipa_node_params *caller_info = ipa_node_params_sum->get (cs->caller);\n       int src_idx = ipa_get_jf_ancestor_formal_id (jfunc);\n       class ipcp_param_lattices *src_plats;\n \n@@ -2873,11 +2875,11 @@ propagate_constants_across_call (struct cgraph_edge *cs)\n   if (!callee->definition)\n     return false;\n   gcc_checking_assert (callee->has_gimple_body_p ());\n-  callee_info = IPA_NODE_REF (callee);\n+  callee_info = ipa_node_params_sum->get (callee);\n   if (!callee_info)\n     return false;\n \n-  args = IPA_EDGE_REF (cs);\n+  args = ipa_edge_args_sum->get (cs);\n   parms_count = ipa_get_param_count (callee_info);\n   if (parms_count == 0)\n     return false;\n@@ -3296,7 +3298,7 @@ good_cloning_opportunity_p (struct cgraph_node *node, sreal time_benefit,\n \n   gcc_assert (size_cost > 0);\n \n-  class ipa_node_params *info = IPA_NODE_REF (node);\n+  ipa_node_params *info = ipa_node_params_sum->get (node);\n   int eval_threshold = opt_for_fn (node->decl, param_ipa_cp_eval_threshold);\n   if (max_count > profile_count::zero ())\n     {\n@@ -3501,7 +3503,7 @@ get_max_overall_size (cgraph_node *node)\n static void\n estimate_local_effects (struct cgraph_node *node)\n {\n-  class ipa_node_params *info = IPA_NODE_REF (node);\n+  ipa_node_params *info = ipa_node_params_sum->get (node);\n   int i, count = ipa_get_param_count (info);\n   bool always_const;\n   int removable_params_cost;\n@@ -3746,7 +3748,7 @@ value_topo_info<valtype>::add_val (ipcp_value<valtype> *cur_val)\n static void\n add_all_node_vals_to_toposort (cgraph_node *node, ipa_topo_info *topo)\n {\n-  class ipa_node_params *info = IPA_NODE_REF (node);\n+  ipa_node_params *info = ipa_node_params_sum->get (node);\n   int i, count = ipa_get_param_count (info);\n \n   for (i = 0; i < count; i++)\n@@ -3830,7 +3832,7 @@ propagate_constants_topo (class ipa_topo_info *topo)\n \n \t\tif (!info)\n \t\t  {\n-\t\t    info = IPA_NODE_REF (v);\n+\t\t    info = ipa_node_params_sum->get (v);\n \t\t    info->node_within_scc = true;\n \t\t  }\n \n@@ -3940,7 +3942,7 @@ ipcp_propagate_stage (class ipa_topo_info *topo)\n \t&& opt_for_fn (node->decl, flag_ipa_cp)\n \t&& opt_for_fn (node->decl, optimize))\n       {\n-        class ipa_node_params *info = IPA_NODE_REF (node);\n+        ipa_node_params *info = ipa_node_params_sum->get (node);\n         determine_versionability (node, info);\n \n \tunsigned nlattices = ipa_get_param_count (info);\n@@ -4004,7 +4006,7 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node,\n \n \t  if (cs && !agg_contents && !polymorphic)\n \t    {\n-\t      class ipa_node_params *info = IPA_NODE_REF (node);\n+\t      ipa_node_params *info = ipa_node_params_sum->get (node);\n \t      int c = ipa_get_controlled_uses (info, param_index);\n \t      if (c != IPA_UNDESCRIBED_USE)\n \t\t{\n@@ -4103,7 +4105,7 @@ calls_same_node_or_its_all_contexts_clone_p (cgraph_edge *cs, cgraph_node *dest,\n   if (!allow_recursion_to_clone && cs->caller == callee)\n     return false;\n \n-  class ipa_node_params *info = IPA_NODE_REF (callee);\n+  ipa_node_params *info = ipa_node_params_sum->get (callee);\n   return info->is_all_contexts_clone && info->ipcp_orig_node == dest;\n }\n \n@@ -4114,7 +4116,7 @@ static bool\n cgraph_edge_brings_value_p (cgraph_edge *cs, ipcp_value_source<tree> *src,\n \t\t\t    cgraph_node *dest, ipcp_value<tree> *dest_val)\n {\n-  class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+  ipa_node_params *caller_info = ipa_node_params_sum->get (cs->caller);\n \n   if (!calls_same_node_or_its_all_contexts_clone_p (cs, dest, !src->val)\n       || caller_info->node_dead)\n@@ -4168,7 +4170,7 @@ cgraph_edge_brings_value_p (cgraph_edge *cs,\n \t\t\t    cgraph_node *dest,\n \t\t\t    ipcp_value<ipa_polymorphic_call_context> *)\n {\n-  class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+  ipa_node_params *caller_info = ipa_node_params_sum->get (cs->caller);\n \n   if (!calls_same_node_or_its_all_contexts_clone_p (cs, dest, true)\n       || caller_info->node_dead)\n@@ -4243,7 +4245,7 @@ get_info_about_necessary_edges (ipcp_value<valtype> *val, cgraph_node *dest,\n   *count_sum = cnt;\n   *caller_count = count;\n \n-  if (!hot && IPA_NODE_REF (dest)->node_within_scc)\n+  if (!hot && ipa_node_params_sum->get (dest)->node_within_scc)\n     {\n       struct cgraph_edge *cs;\n \n@@ -4494,7 +4496,7 @@ want_remove_some_param_p (cgraph_node *node, vec<tree> known_csts)\n {\n   auto_vec<bool, 16> surviving;\n   bool filled_vec = false;\n-  ipa_node_params *info = IPA_NODE_REF (node);\n+  ipa_node_params *info = ipa_node_params_sum->get (node);\n   int i, count = ipa_get_param_count (info);\n \n   for (i = 0; i < count; i++)\n@@ -4527,7 +4529,7 @@ create_specialized_node (struct cgraph_node *node,\n \t\t\t struct ipa_agg_replacement_value *aggvals,\n \t\t\t vec<cgraph_edge *> callers)\n {\n-  class ipa_node_params *new_info, *info = IPA_NODE_REF (node);\n+  ipa_node_params *new_info, *info = ipa_node_params_sum->get (node);\n   vec<ipa_replace_map *, va_gc> *replace_trees = NULL;\n   vec<ipa_adjusted_param, va_gc> *new_params = NULL;\n   struct ipa_agg_replacement_value *av;\n@@ -4662,7 +4664,7 @@ create_specialized_node (struct cgraph_node *node,\n     }\n   ipa_check_create_node_params ();\n   update_profiling_info (node, new_node);\n-  new_info = IPA_NODE_REF (new_node);\n+  new_info = ipa_node_params_sum->get (new_node);\n   new_info->ipcp_orig_node = node;\n   new_node->ipcp_clone = true;\n   new_info->known_csts = known_csts;\n@@ -4689,8 +4691,8 @@ self_recursive_pass_through_p (cgraph_edge *cs, ipa_jump_func *jfunc, int i,\n       && jfunc->type == IPA_JF_PASS_THROUGH\n       && (!simple || ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n       && ipa_get_jf_pass_through_formal_id (jfunc) == i\n-      && IPA_NODE_REF (cs->caller)\n-      && !IPA_NODE_REF (cs->caller)->ipcp_orig_node)\n+      && ipa_node_params_sum->get (cs->caller)\n+      && !ipa_node_params_sum->get (cs->caller)->ipcp_orig_node)\n     return true;\n   return false;\n }\n@@ -4713,8 +4715,8 @@ self_recursive_agg_pass_through_p (cgraph_edge *cs, ipa_agg_jf_item *jfunc,\n       && (!simple || jfunc->value.pass_through.operation == NOP_EXPR)\n       && jfunc->value.pass_through.formal_id == i\n       && useless_type_conversion_p (jfunc->value.load_agg.type, jfunc->type)\n-      && IPA_NODE_REF (cs->caller)\n-      && !IPA_NODE_REF (cs->caller)->ipcp_orig_node)\n+      && ipa_node_params_sum->get (cs->caller)\n+      && !ipa_node_params_sum->get (cs->caller)->ipcp_orig_node)\n     return true;\n   return false;\n }\n@@ -4727,7 +4729,7 @@ find_more_scalar_values_for_callers_subset (struct cgraph_node *node,\n \t\t\t\t\t    vec<tree> known_csts,\n \t\t\t\t\t    vec<cgraph_edge *> callers)\n {\n-  class ipa_node_params *info = IPA_NODE_REF (node);\n+  ipa_node_params *info = ipa_node_params_sum->get (node);\n   int i, count = ipa_get_param_count (info);\n \n   for (i = 0; i < count; i++)\n@@ -4746,15 +4748,16 @@ find_more_scalar_values_for_callers_subset (struct cgraph_node *node,\n \t  struct ipa_jump_func *jump_func;\n \t  tree t;\n \n-\t  if (!IPA_EDGE_REF (cs)\n-\t      || i >= ipa_get_cs_argument_count (IPA_EDGE_REF (cs))\n+\t  ipa_edge_args *args = ipa_edge_args_sum->get (cs);\n+\t  if (!args\n+\t      || i >= ipa_get_cs_argument_count (args)\n \t      || (i == 0\n \t\t  && call_passes_through_thunk (cs)))\n \t    {\n \t      newval = NULL_TREE;\n \t      break;\n \t    }\n-\t  jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n+\t  jump_func = ipa_get_ith_jump_func (args, i);\n \n \t  /* Besides simple pass-through jump function, arithmetic jump\n \t     function could also introduce argument-direct-pass-through for\n@@ -4777,8 +4780,8 @@ find_more_scalar_values_for_callers_subset (struct cgraph_node *node,\n \t\t\t\ttype);\n \t    }\n \t  else\n-\t    t = ipa_value_from_jfunc (IPA_NODE_REF (cs->caller), jump_func,\n-\t\t\t\t      type);\n+\t    t = ipa_value_from_jfunc (ipa_node_params_sum->get (cs->caller),\n+\t\t\t\t      jump_func, type);\n \t  if (!t\n \t      || (newval\n \t\t  && !values_equal_for_ipcp_p (t, newval))\n@@ -4818,7 +4821,7 @@ find_more_contexts_for_caller_subset (cgraph_node *node,\n \t\t\t\t      *known_contexts,\n \t\t\t\t      vec<cgraph_edge *> callers)\n {\n-  ipa_node_params *info = IPA_NODE_REF (node);\n+  ipa_node_params *info = ipa_node_params_sum->get (node);\n   int i, count = ipa_get_param_count (info);\n \n   for (i = 0; i < count; i++)\n@@ -4836,14 +4839,14 @@ find_more_contexts_for_caller_subset (cgraph_node *node,\n \n       FOR_EACH_VEC_ELT (callers, j, cs)\n \t{\n-\t  if (!IPA_EDGE_REF (cs)\n-\t      || i >= ipa_get_cs_argument_count (IPA_EDGE_REF (cs)))\n+\t  ipa_edge_args *args = ipa_edge_args_sum->get (cs);\n+\t  if (!args\n+\t      || i >= ipa_get_cs_argument_count (args))\n \t    return;\n-\t  ipa_jump_func *jfunc = ipa_get_ith_jump_func (IPA_EDGE_REF (cs),\n-\t\t\t\t\t\t\t    i);\n+\t  ipa_jump_func *jfunc = ipa_get_ith_jump_func (args, i);\n \t  ipa_polymorphic_call_context ctx;\n-\t  ctx = ipa_context_from_jfunc (IPA_NODE_REF (cs->caller), cs, i,\n-\t\t\t\t\tjfunc);\n+\t  ctx = ipa_context_from_jfunc (ipa_node_params_sum->get (cs->caller),\n+\t\t\t\t\tcs, i, jfunc);\n \t  if (first)\n \t    {\n \t      newval = ctx;\n@@ -5020,19 +5023,19 @@ intersect_aggregates_with_edge (struct cgraph_edge *cs, int index,\n \t\t\t\tvec<ipa_agg_value> inter)\n {\n   struct ipa_jump_func *jfunc;\n-  jfunc = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), index);\n+  jfunc = ipa_get_ith_jump_func (ipa_edge_args_sum->get (cs), index);\n   if (jfunc->type == IPA_JF_PASS_THROUGH\n       && ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n     {\n-      class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      ipa_node_params *caller_info = ipa_node_params_sum->get (cs->caller);\n       int src_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n \n       if (caller_info->ipcp_orig_node)\n \t{\n \t  struct cgraph_node *orig_node = caller_info->ipcp_orig_node;\n \t  class ipcp_param_lattices *orig_plats;\n-\t  orig_plats = ipa_get_parm_lattices (IPA_NODE_REF (orig_node),\n-\t\t\t\t\t      src_idx);\n+\t  ipa_node_params *orig_info = ipa_node_params_sum->get (orig_node);\n+\t  orig_plats = ipa_get_parm_lattices (orig_info, src_idx);\n \t  if (agg_pass_through_permissible_p (orig_plats, jfunc))\n \t    {\n \t      if (!inter.exists ())\n@@ -5063,7 +5066,7 @@ intersect_aggregates_with_edge (struct cgraph_edge *cs, int index,\n   else if (jfunc->type == IPA_JF_ANCESTOR\n \t   && ipa_get_jf_ancestor_agg_preserved (jfunc))\n     {\n-      class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      ipa_node_params *caller_info = ipa_node_params_sum->get (cs->caller);\n       int src_idx = ipa_get_jf_ancestor_formal_id (jfunc);\n       class ipcp_param_lattices *src_plats;\n       HOST_WIDE_INT delta = ipa_get_jf_ancestor_offset (jfunc);\n@@ -5092,7 +5095,7 @@ intersect_aggregates_with_edge (struct cgraph_edge *cs, int index,\n \n   if (jfunc->agg.items)\n     {\n-      class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      ipa_node_params *caller_info = ipa_node_params_sum->get (cs->caller);\n       struct ipa_agg_value *item;\n       int k;\n \n@@ -5179,20 +5182,21 @@ static struct ipa_agg_replacement_value *\n find_aggregate_values_for_callers_subset (struct cgraph_node *node,\n \t\t\t\t\t  vec<cgraph_edge *> callers)\n {\n-  class ipa_node_params *dest_info = IPA_NODE_REF (node);\n+  ipa_node_params *dest_info = ipa_node_params_sum->get (node);\n   struct ipa_agg_replacement_value *res;\n   struct ipa_agg_replacement_value **tail = &res;\n   struct cgraph_edge *cs;\n   int i, j, count = ipa_get_param_count (dest_info);\n \n   FOR_EACH_VEC_ELT (callers, j, cs)\n     {\n-      if (!IPA_EDGE_REF (cs))\n+      ipa_edge_args *args = ipa_edge_args_sum->get (cs);\n+      if (!args)\n \t{\n \t  count = 0;\n \t  break;\n \t}\n-      int c = ipa_get_cs_argument_count (IPA_EDGE_REF (cs));\n+      int c = ipa_get_cs_argument_count (args);\n       if (c < count)\n \tcount = c;\n     }\n@@ -5213,7 +5217,7 @@ find_aggregate_values_for_callers_subset (struct cgraph_node *node,\n       FOR_EACH_VEC_ELT (callers, j, cs)\n \t{\n \t  struct ipa_jump_func *jfunc\n-\t    = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n+\t    = ipa_get_ith_jump_func (ipa_edge_args_sum->get (cs), i);\n \t  if (self_recursive_pass_through_p (cs, jfunc, i)\n \t      && (!plats->aggs_by_ref\n \t\t  || ipa_get_jf_pass_through_agg_preserved (jfunc)))\n@@ -5255,14 +5259,14 @@ static bool\n cgraph_edge_brings_all_scalars_for_node (struct cgraph_edge *cs,\n \t\t\t\t\t struct cgraph_node *node)\n {\n-  class ipa_node_params *dest_info = IPA_NODE_REF (node);\n+  ipa_node_params *dest_info = ipa_node_params_sum->get (node);\n   int count = ipa_get_param_count (dest_info);\n   class ipa_node_params *caller_info;\n   class ipa_edge_args *args;\n   int i;\n \n-  caller_info = IPA_NODE_REF (cs->caller);\n-  args = IPA_EDGE_REF (cs);\n+  caller_info = ipa_node_params_sum->get (cs->caller);\n+  args = ipa_edge_args_sum->get (cs);\n   for (i = 0; i < count; i++)\n     {\n       struct ipa_jump_func *jump_func;\n@@ -5289,22 +5293,23 @@ static bool\n cgraph_edge_brings_all_agg_vals_for_node (struct cgraph_edge *cs,\n \t\t\t\t\t  struct cgraph_node *node)\n {\n-  class ipa_node_params *orig_node_info;\n   struct ipa_agg_replacement_value *aggval;\n   int i, ec, count;\n \n   aggval = ipa_get_agg_replacements_for_node (node);\n   if (!aggval)\n     return true;\n \n-  count = ipa_get_param_count (IPA_NODE_REF (node));\n-  ec = ipa_get_cs_argument_count (IPA_EDGE_REF (cs));\n+  ipa_node_params *clone_node_info = ipa_node_params_sum->get (node);\n+  count = ipa_get_param_count (clone_node_info);\n+  ec = ipa_get_cs_argument_count (ipa_edge_args_sum->get (cs));\n   if (ec < count)\n     for (struct ipa_agg_replacement_value *av = aggval; av; av = av->next)\n       if (aggval->index >= ec)\n \treturn false;\n \n-  orig_node_info = IPA_NODE_REF (IPA_NODE_REF (node)->ipcp_orig_node);\n+  ipa_node_params *orig_node_info\n+    = ipa_node_params_sum->get (clone_node_info->ipcp_orig_node);\n \n   for (i = 0; i < count; i++)\n     {\n@@ -5522,7 +5527,7 @@ decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n       fprintf (dump_file, \" - considering value \");\n       print_ipcp_constant_value (dump_file, val->value);\n       fprintf (dump_file, \" for \");\n-      ipa_dump_param (dump_file, IPA_NODE_REF (node), index);\n+      ipa_dump_param (dump_file, ipa_node_params_sum->get (node), index);\n       if (offset != -1)\n \tfprintf (dump_file, \", offset: \" HOST_WIDE_INT_PRINT_DEC, offset);\n       fprintf (dump_file, \" (caller_count: %i)\\n\", caller_count);\n@@ -5573,7 +5578,7 @@ decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n static bool\n decide_whether_version_node (struct cgraph_node *node)\n {\n-  class ipa_node_params *info = IPA_NODE_REF (node);\n+  ipa_node_params *info = ipa_node_params_sum->get (node);\n   int i, count = ipa_get_param_count (info);\n   bool ret = false;\n \n@@ -5622,8 +5627,6 @@ decide_whether_version_node (struct cgraph_node *node)\n \t  for (val = ctxlat->values; val; val = val->next)\n \t    ret |= decide_about_value (node, i, -1, val, &avals);\n \t}\n-\n-\tinfo = IPA_NODE_REF (node);\n     }\n \n   if (info->do_clone_for_all_contexts)\n@@ -5640,7 +5643,7 @@ decide_whether_version_node (struct cgraph_node *node)\n       for (int i = callers.length () - 1; i >= 0; i--)\n \t{\n \t  cgraph_edge *cs = callers[i];\n-\t  class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+\t  ipa_node_params *caller_info = ipa_node_params_sum->get (cs->caller);\n \n \t  if (caller_info && caller_info->node_dead)\n \t    callers.unordered_remove (i);\n@@ -5675,9 +5678,8 @@ decide_whether_version_node (struct cgraph_node *node)\n \t}\n       clone = create_specialized_node (node, known_csts, known_contexts,\n \t\t\t\t       aggvals, callers);\n-      info = IPA_NODE_REF (node);\n       info->do_clone_for_all_contexts = false;\n-      IPA_NODE_REF (clone)->is_all_contexts_clone = true;\n+      ipa_node_params_sum->get (clone)->is_all_contexts_clone = true;\n       ret = true;\n     }\n \n@@ -5698,7 +5700,7 @@ spread_undeadness (struct cgraph_node *node)\n \tclass ipa_node_params *info;\n \n \tcallee = cs->callee->function_symbol (NULL);\n-\tinfo = IPA_NODE_REF (callee);\n+\tinfo = ipa_node_params_sum->get (callee);\n \n \tif (info && info->node_dead)\n \t  {\n@@ -5722,10 +5724,13 @@ has_undead_caller_from_outside_scc_p (struct cgraph_node *node,\n \t&& cs->caller->call_for_symbol_thunks_and_aliases\n \t  (has_undead_caller_from_outside_scc_p, NULL, true))\n       return true;\n-    else if (!ipa_edge_within_scc (cs)\n-\t     && (!IPA_NODE_REF (cs->caller) /* Unoptimized caller.  */\n-\t\t || !IPA_NODE_REF (cs->caller)->node_dead))\n+    else if (!ipa_edge_within_scc (cs))\n+      {\n+\tipa_node_params *caller_info = ipa_node_params_sum->get (cs->caller);\n+\tif (!caller_info /* Unoptimized caller are like dead ones.  */\n+\t    || !caller_info->node_dead)\n \t  return true;\n+      }\n   return false;\n }\n \n@@ -5738,21 +5743,29 @@ identify_dead_nodes (struct cgraph_node *node)\n {\n   struct cgraph_node *v;\n   for (v = node; v; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n-    if (v->local\n-\t&& IPA_NODE_REF (v)\n-\t&& !v->call_for_symbol_thunks_and_aliases\n-\t     (has_undead_caller_from_outside_scc_p, NULL, true))\n-      IPA_NODE_REF (v)->node_dead = 1;\n+    if (v->local)\n+      {\n+\tipa_node_params *info = ipa_node_params_sum->get (v);\n+\tif (info\n+\t    && !v->call_for_symbol_thunks_and_aliases\n+\t      (has_undead_caller_from_outside_scc_p, NULL, true))\n+\t  info->node_dead = 1;\n+      }\n \n   for (v = node; v; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n-    if (IPA_NODE_REF (v) && !IPA_NODE_REF (v)->node_dead)\n-      spread_undeadness (v);\n+    {\n+      ipa_node_params *info = ipa_node_params_sum->get (v);\n+      if (info && !info->node_dead)\n+\tspread_undeadness (v);\n+    }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       for (v = node; v; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n-\tif (IPA_NODE_REF (v) && IPA_NODE_REF (v)->node_dead)\n-\t  fprintf (dump_file, \"  Marking node as dead: %s.\\n\", v->dump_name ());\n+\tif (ipa_node_params_sum->get (v)\n+\t    && ipa_node_params_sum->get (v)->node_dead)\n+\t  fprintf (dump_file, \"  Marking node as dead: %s.\\n\",\n+\t\t   v->dump_name ());\n     }\n }\n \n@@ -5798,7 +5811,7 @@ ipcp_store_bits_results (void)\n \n   FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n     {\n-      ipa_node_params *info = IPA_NODE_REF (node);\n+      ipa_node_params *info = ipa_node_params_sum->get (node);\n       bool dumped_sth = false;\n       bool found_useful_result = false;\n \n@@ -5812,7 +5825,7 @@ ipcp_store_bits_results (void)\n \t}\n \n       if (info->ipcp_orig_node)\n-\tinfo = IPA_NODE_REF (info->ipcp_orig_node);\n+\tinfo = ipa_node_params_sum->get (info->ipcp_orig_node);\n       if (!info->lattices)\n \t/* Newly expanded artificial thunks do not have lattices.  */\n \tcontinue;\n@@ -5879,7 +5892,7 @@ ipcp_store_vr_results (void)\n \n   FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n     {\n-      ipa_node_params *info = IPA_NODE_REF (node);\n+      ipa_node_params *info = ipa_node_params_sum->get (node);\n       bool found_useful_result = false;\n \n       if (!info || !opt_for_fn (node->decl, flag_ipa_vrp))\n@@ -5892,7 +5905,7 @@ ipcp_store_vr_results (void)\n \t}\n \n       if (info->ipcp_orig_node)\n-\tinfo = IPA_NODE_REF (info->ipcp_orig_node);\n+\tinfo = ipa_node_params_sum->get (info->ipcp_orig_node);\n       if (!info->lattices)\n \t/* Newly expanded artificial thunks do not have lattices.  */\n \tcontinue;"}, {"sha": "4e5be812734ba371a03973dc9d1894081d32690d", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a3cdd04308ce45c4bee32401fc8121cb561807/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a3cdd04308ce45c4bee32401fc8121cb561807/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=a4a3cdd04308ce45c4bee32401fc8121cb561807", "patch": "@@ -590,7 +590,7 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n   if (ipa_node_params_sum\n       && !e->call_stmt_cannot_inline_p\n       && (info->conds || compute_contexts)\n-      && (args = IPA_EDGE_REF (e)) != NULL)\n+      && (args = ipa_edge_args_sum->get (e)) != NULL)\n     {\n       struct cgraph_node *caller;\n       class ipa_node_params *caller_parms_info, *callee_pi = NULL;\n@@ -603,8 +603,8 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t    caller = e->caller->inlined_to;\n \t  else\n \t    caller = e->caller;\n-\t  caller_parms_info = IPA_NODE_REF (caller);\n-          callee_pi = IPA_NODE_REF (callee);\n+\t  caller_parms_info = ipa_node_params_sum->get (caller);\n+          callee_pi = ipa_node_params_sum->get (callee);\n \n \t  /* Watch for thunks.  */\n \t  if (callee_pi)\n@@ -816,7 +816,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n   if (ipa_node_params_sum && cinfo && cinfo->tree_map)\n     {\n       /* Use SRC parm info since it may not be copied yet.  */\n-      class ipa_node_params *parms_info = IPA_NODE_REF (src);\n+      ipa_node_params *parms_info = ipa_node_params_sum->get (src);\n       ipa_auto_call_arg_values avals;\n       int count = ipa_get_param_count (parms_info);\n       int i, j;\n@@ -2584,7 +2584,8 @@ analyze_function_body (struct cgraph_node *node, bool early)\n   struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);\n   sreal freq;\n   class ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n-  class ipa_node_params *params_summary = early ? NULL : IPA_NODE_REF (node);\n+  ipa_node_params *params_summary\n+    = early ? NULL : ipa_node_params_sum->get (node);\n   predicate bb_predicate;\n   struct ipa_func_body_info fbi;\n   vec<predicate> nonconstant_names = vNULL;\n@@ -2622,7 +2623,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n       if (ipa_node_params_sum)\n \t{\n \t  fbi.node = node;\n-\t  fbi.info = IPA_NODE_REF (node);\n+\t  fbi.info = ipa_node_params_sum->get (node);\n \t  fbi.bb_infos = vNULL;\n \t  fbi.bb_infos.safe_grow_cleared (last_basic_block_for_fn (cfun), true);\n \t  fbi.param_count = count_formal_params (node->decl);\n@@ -3368,7 +3369,7 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n \t       || avals->m_known_contexts.length ()\n \t       || avals->m_known_aggs.length ()))\n     {\n-      class ipa_node_params *params_summary = IPA_NODE_REF (node);\n+      ipa_node_params *params_summary = ipa_node_params_sum->get (node);\n       unsigned int nargs = params_summary\n \t\t\t   ? ipa_get_param_count (params_summary) : 0;\n \n@@ -3463,7 +3464,7 @@ ipa_cached_call_context::duplicate_from (const ipa_call_context &ctx)\n   m_node = ctx.m_node;\n   m_possible_truths = ctx.m_possible_truths;\n   m_nonspec_possible_truths = ctx.m_nonspec_possible_truths;\n-  class ipa_node_params *params_summary = IPA_NODE_REF (m_node);\n+  ipa_node_params *params_summary = ipa_node_params_sum->get (m_node);\n   unsigned int nargs = params_summary\n \t\t       ? ipa_get_param_count (params_summary) : 0;\n \n@@ -3553,7 +3554,7 @@ ipa_call_context::equal_to (const ipa_call_context &ctx)\n       || m_nonspec_possible_truths != ctx.m_nonspec_possible_truths)\n     return false;\n \n-  class ipa_node_params *params_summary = IPA_NODE_REF (m_node);\n+  ipa_node_params *params_summary = ipa_node_params_sum->get (m_node);\n   unsigned int nargs = params_summary\n \t\t       ? ipa_get_param_count (params_summary) : 0;\n \n@@ -3902,7 +3903,7 @@ remap_edge_params (struct cgraph_edge *inlined_edge,\n   if (ipa_node_params_sum)\n     {\n       int i;\n-      class ipa_edge_args *args = IPA_EDGE_REF (edge);\n+      ipa_edge_args *args = ipa_edge_args_sum->get (edge);\n       if (!args)\n \treturn;\n       class ipa_call_summary *es = ipa_call_summaries->get (edge);\n@@ -4055,8 +4056,8 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n   int i;\n   predicate toplev_predicate;\n   class ipa_call_summary *es = ipa_call_summaries->get (edge);\n-  class ipa_node_params *params_summary = (ipa_node_params_sum\n-\t\t \t\t\t   ? IPA_NODE_REF (to) : NULL);\n+  ipa_node_params *params_summary = (ipa_node_params_sum\n+\t\t\t\t     ? ipa_node_params_sum->get (to) : NULL);\n \n   if (es->predicate)\n     toplev_predicate = *es->predicate;\n@@ -4072,7 +4073,7 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n     }\n   if (ipa_node_params_sum && callee_info->conds)\n     {\n-      class ipa_edge_args *args = IPA_EDGE_REF (edge);\n+      ipa_edge_args *args = ipa_edge_args_sum->get (edge);\n       int count = args ? ipa_get_cs_argument_count (args) : 0;\n       int i;\n \n@@ -4384,7 +4385,8 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       node = dyn_cast<cgraph_node *> (lto_symtab_encoder_deref (encoder,\n \t\t\t\t\t\t\t\tindex));\n       info = node->prevailing_p () ? ipa_fn_summaries->get_create (node) : NULL;\n-      params_summary = node->prevailing_p () ? IPA_NODE_REF (node) : NULL;\n+      params_summary = node->prevailing_p ()\n+\t               ? ipa_node_params_sum->get (node) : NULL;\n       size_info = node->prevailing_p ()\n \t\t  ? ipa_size_summaries->get_create (node) : NULL;\n "}, {"sha": "4c1f25d08348e24bbc2fc6ce5f29b287ee045d5b", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a3cdd04308ce45c4bee32401fc8121cb561807/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a3cdd04308ce45c4bee32401fc8121cb561807/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=a4a3cdd04308ce45c4bee32401fc8121cb561807", "patch": "@@ -496,12 +496,12 @@ sem_function::param_used_p (unsigned int i)\n   if (ipa_node_params_sum == NULL)\n     return true;\n \n-  class ipa_node_params *parms_info = IPA_NODE_REF (get_node ());\n+  ipa_node_params *parms_info = ipa_node_params_sum->get (get_node ());\n \n   if (!parms_info || vec_safe_length (parms_info->descriptors) <= i)\n     return true;\n \n-  return ipa_is_param_used (IPA_NODE_REF (get_node ()), i);\n+  return ipa_is_param_used (parms_info, i);\n }\n \n /* Perform additional check needed to match types function parameters that are"}, {"sha": "d5a8332fb5559a304aa6c263d77e473e131d8299", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a3cdd04308ce45c4bee32401fc8121cb561807/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a3cdd04308ce45c4bee32401fc8121cb561807/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=a4a3cdd04308ce45c4bee32401fc8121cb561807", "patch": "@@ -2899,7 +2899,7 @@ compute_parm_map (cgraph_edge *callee_edge, vec<modref_parm_map> *parm_map)\n   class ipa_edge_args *args;\n   if (ipa_node_params_sum\n       && !callee_edge->call_stmt_cannot_inline_p\n-      && (args = IPA_EDGE_REF (callee_edge)) != NULL)\n+      && (args = ipa_edge_args_sum->get (callee_edge)) != NULL)\n     {\n       int i, count = ipa_get_cs_argument_count (args);\n       class ipa_node_params *caller_parms_info, *callee_pi;\n@@ -2909,10 +2909,11 @@ compute_parm_map (cgraph_edge *callee_edge, vec<modref_parm_map> *parm_map)\n \t = callee_edge->callee->function_or_virtual_thunk_symbol\n \t\t\t      (NULL, callee_edge->caller);\n \n-      caller_parms_info = IPA_NODE_REF (callee_edge->caller->inlined_to\n-\t\t\t\t\t? callee_edge->caller->inlined_to\n-\t\t\t\t\t: callee_edge->caller);\n-      callee_pi = IPA_NODE_REF (callee);\n+      caller_parms_info\n+\t= ipa_node_params_sum->get (callee_edge->caller->inlined_to\n+\t\t\t\t    ? callee_edge->caller->inlined_to\n+\t\t\t\t    : callee_edge->caller);\n+      callee_pi = ipa_node_params_sum->get (callee);\n \n       (*parm_map).safe_grow_cleared (count, true);\n \n@@ -3240,8 +3241,8 @@ get_access_for_fnspec (cgraph_edge *e, attr_fnspec &fnspec,\n     {\n       cgraph_node *node = e->caller->inlined_to\n \t\t\t  ? e->caller->inlined_to : e->caller;\n-      class ipa_node_params *caller_parms_info = IPA_NODE_REF (node);\n-      class ipa_edge_args *args = IPA_EDGE_REF (e);\n+      ipa_node_params *caller_parms_info = ipa_node_params_sum->get (node);\n+      ipa_edge_args *args = ipa_edge_args_sum->get (e);\n       struct ipa_jump_func *jf = ipa_get_ith_jump_func (args, size_arg);\n \n       if (jf)"}, {"sha": "ce32b538976d2a12a83d41691bbfe0a18918c6e9", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a3cdd04308ce45c4bee32401fc8121cb561807/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a3cdd04308ce45c4bee32401fc8121cb561807/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=a4a3cdd04308ce45c4bee32401fc8121cb561807", "patch": "@@ -740,10 +740,10 @@ check_argument_count (struct cgraph_node *n, struct cgraph_edge *e)\n {\n   if (!ipa_node_params_sum || !ipa_edge_args_sum)\n     return true;\n-  class ipa_node_params *info = IPA_NODE_REF (n->function_symbol ());\n+  ipa_node_params *info = ipa_node_params_sum->get (n->function_symbol ());\n   if (!info)\n     return true;\n-  ipa_edge_args *e_info = IPA_EDGE_REF (e);\n+  ipa_edge_args *e_info = ipa_edge_args_sum->get (e);\n   if (!e_info)\n     return true;\n   if (ipa_get_param_count (info) != ipa_get_cs_argument_count (e_info)"}, {"sha": "0591ef1b569e3a77c9e7f5c58ceb082509f99818", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a3cdd04308ce45c4bee32401fc8121cb561807/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a3cdd04308ce45c4bee32401fc8121cb561807/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=a4a3cdd04308ce45c4bee32401fc8121cb561807", "patch": "@@ -276,7 +276,7 @@ ipa_dump_param (FILE *file, class ipa_node_params *info, int i)\n static bool\n ipa_alloc_node_params (struct cgraph_node *node, int param_count)\n {\n-  class ipa_node_params *info = IPA_NODE_REF_GET_CREATE (node);\n+  ipa_node_params *info = ipa_node_params_sum->get_create (node);\n \n   if (!info->descriptors && param_count)\n     {\n@@ -294,7 +294,7 @@ ipa_alloc_node_params (struct cgraph_node *node, int param_count)\n void\n ipa_initialize_node_params (struct cgraph_node *node)\n {\n-  class ipa_node_params *info = IPA_NODE_REF_GET_CREATE (node);\n+  ipa_node_params *info = ipa_node_params_sum->get_create (node);\n \n   if (!info->descriptors\n       && ipa_alloc_node_params (node, count_formal_params (node->decl)))\n@@ -306,15 +306,15 @@ ipa_initialize_node_params (struct cgraph_node *node)\n static void\n ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n {\n-  int i, count;\n+  ipa_edge_args *args = ipa_edge_args_sum->get (cs);\n+  int count = ipa_get_cs_argument_count (args);\n \n-  count = ipa_get_cs_argument_count (IPA_EDGE_REF (cs));\n-  for (i = 0; i < count; i++)\n+  for (int i = 0; i < count; i++)\n     {\n       struct ipa_jump_func *jump_func;\n       enum jump_func_type type;\n \n-      jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n+      jump_func = ipa_get_ith_jump_func (args, i);\n       type = jump_func->type;\n \n       fprintf (f, \"       param %d: \", i);\n@@ -410,7 +410,7 @@ ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n \t}\n \n       class ipa_polymorphic_call_context *ctx\n-\t= ipa_get_ith_polymorhic_call_context (IPA_EDGE_REF (cs), i);\n+\t= ipa_get_ith_polymorhic_call_context (args, i);\n       if (ctx && !ctx->useless_p ())\n \t{\n \t  fprintf (f, \"         Context: \");\n@@ -2232,8 +2232,8 @@ static void\n ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n \t\t\t\t     struct cgraph_edge *cs)\n {\n-  class ipa_node_params *info = IPA_NODE_REF (cs->caller);\n-  class ipa_edge_args *args = IPA_EDGE_REF_GET_CREATE (cs);\n+  ipa_node_params *info = ipa_node_params_sum->get (cs->caller);\n+  ipa_edge_args *args = ipa_edge_args_sum->get_create (cs);\n   gcall *call = cs->call_stmt;\n   int n, arg_num = gimple_call_num_args (call);\n   bool useful_context = false;\n@@ -2509,11 +2509,10 @@ ipa_note_param_call (struct cgraph_node *node, int param_index,\n   cs->indirect_info->agg_contents = 0;\n   cs->indirect_info->member_ptr = 0;\n   cs->indirect_info->guaranteed_unmodified = 0;\n-  ipa_set_param_used_by_indirect_call (IPA_NODE_REF (node),\n-\t\t\t\t\t  param_index, true);\n+  ipa_node_params *info = ipa_node_params_sum->get (node);\n+  ipa_set_param_used_by_indirect_call (info, param_index, true);\n   if (cs->indirect_info->polymorphic || polymorphic)\n-    ipa_set_param_used_by_polymorphic_call\n-\t    (IPA_NODE_REF (node), param_index, true);\n+    ipa_set_param_used_by_polymorphic_call (info, param_index, true);\n   return cs;\n }\n \n@@ -2884,7 +2883,7 @@ ipa_analyze_params_uses_in_bb (struct ipa_func_body_info *fbi, basic_block bb)\n static void\n ipa_analyze_controlled_uses (struct cgraph_node *node)\n {\n-  class ipa_node_params *info = IPA_NODE_REF (node);\n+  ipa_node_params *info = ipa_node_params_sum->get (node);\n \n   for (int i = 0; i < ipa_get_param_count (info); i++)\n     {\n@@ -2980,7 +2979,7 @@ ipa_analyze_node (struct cgraph_node *node)\n \n   ipa_check_create_node_params ();\n   ipa_check_create_edge_args ();\n-  info = IPA_NODE_REF_GET_CREATE (node);\n+  info = ipa_node_params_sum->get_create (node);\n \n   if (info->analysis_done)\n     return;\n@@ -3003,7 +3002,7 @@ ipa_analyze_node (struct cgraph_node *node)\n   ipa_analyze_controlled_uses (node);\n \n   fbi.node = node;\n-  fbi.info = IPA_NODE_REF (node);\n+  fbi.info = info;\n   fbi.bb_infos = vNULL;\n   fbi.bb_infos.safe_grow_cleared (last_basic_block_for_fn (cfun), true);\n   fbi.param_count = ipa_get_param_count (info);\n@@ -3036,8 +3035,8 @@ static void\n update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t\t\t\t      struct cgraph_edge *e)\n {\n-  class ipa_edge_args *top = IPA_EDGE_REF (cs);\n-  class ipa_edge_args *args = IPA_EDGE_REF (e);\n+  ipa_edge_args *top = ipa_edge_args_sum->get (cs);\n+  ipa_edge_args *args = ipa_edge_args_sum->get (e);\n   if (!args)\n     return;\n   int count = ipa_get_cs_argument_count (args);\n@@ -3889,11 +3888,11 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n   bool res = false;\n \n   ipa_check_create_edge_args ();\n-  top = IPA_EDGE_REF (cs);\n+  top = ipa_edge_args_sum->get (cs);\n   new_root = cs->caller->inlined_to\n \t\t? cs->caller->inlined_to : cs->caller;\n-  new_root_info = IPA_NODE_REF (new_root);\n-  inlined_node_info = IPA_NODE_REF (cs->callee->function_symbol ());\n+  new_root_info = ipa_node_params_sum->get (new_root);\n+  inlined_node_info = ipa_node_params_sum->get (cs->callee->function_symbol ());\n \n   for (ie = node->indirect_calls; ie; ie = next_ie)\n     {\n@@ -3947,7 +3946,6 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \t  && spec_targets.contains (new_direct_edge->callee))\n \t{\n \t  new_direct_edge->indirect_inlining_edge = 1;\n-\t  top = IPA_EDGE_REF (cs);\n \t  res = true;\n \t  if (!new_direct_edge->speculative)\n \t    continue;\n@@ -3960,7 +3958,6 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \t      new_edges->safe_push (new_direct_edge);\n \t      res = true;\n \t    }\n-\t  top = IPA_EDGE_REF (cs);\n \t  /* If speculative edge was introduced we still need to update\n \t     call info of the indirect edge.  */\n \t  if (!new_direct_edge->speculative)\n@@ -4060,13 +4057,13 @@ combine_controlled_uses_counters (int c, int d)\n static void\n propagate_controlled_uses (struct cgraph_edge *cs)\n {\n-  class ipa_edge_args *args = IPA_EDGE_REF (cs);\n+  ipa_edge_args *args = ipa_edge_args_sum->get (cs);\n   if (!args)\n     return;\n   struct cgraph_node *new_root = cs->caller->inlined_to\n     ? cs->caller->inlined_to : cs->caller;\n-  class ipa_node_params *new_root_info = IPA_NODE_REF (new_root);\n-  class ipa_node_params *old_root_info = IPA_NODE_REF (cs->callee);\n+  ipa_node_params *new_root_info = ipa_node_params_sum->get (new_root);\n+  ipa_node_params *old_root_info = ipa_node_params_sum->get (cs->callee);\n   int count, i;\n \n   if (!old_root_info)\n@@ -4195,7 +4192,7 @@ ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n   changed = propagate_info_to_inlined_callees (cs, cs->callee, new_edges);\n   ipa_node_params_sum->remove (cs->callee);\n \n-  class ipa_edge_args *args = IPA_EDGE_REF (cs);\n+  ipa_edge_args *args = ipa_edge_args_sum->get (cs);\n   if (args)\n     {\n       bool ok = true;\n@@ -4403,7 +4400,7 @@ ipa_edge_args_sum_t::duplicate (cgraph_edge *src, cgraph_edge *dst,\n \t{\n \t  struct cgraph_node *inline_root = dst->caller->inlined_to\n \t    ? dst->caller->inlined_to : dst->caller;\n-\t  class ipa_node_params *root_info = IPA_NODE_REF (inline_root);\n+\t  ipa_node_params *root_info = ipa_node_params_sum->get (inline_root);\n \t  int idx = ipa_get_jf_pass_through_formal_id (dst_jf);\n \n \t  int c = ipa_get_controlled_uses (root_info, idx);\n@@ -4553,7 +4550,7 @@ ipa_print_node_params (FILE *f, struct cgraph_node *node)\n \n   if (!node->definition)\n     return;\n-  info = IPA_NODE_REF (node);\n+  info = ipa_node_params_sum->get (node);\n   fprintf (f, \"  function  %s parameter descriptors:\\n\", node->dump_name ());\n   if (!info)\n     {\n@@ -4956,7 +4953,7 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n {\n   int node_ref;\n   lto_symtab_encoder_t encoder;\n-  class ipa_node_params *info = IPA_NODE_REF (node);\n+  ipa_node_params *info = ipa_node_params_sum->get (node);\n   int j;\n   struct cgraph_edge *e;\n   struct bitpack_d bp;\n@@ -4983,7 +4980,7 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n     }\n   for (e = node->callees; e; e = e->next_callee)\n     {\n-      class ipa_edge_args *args = IPA_EDGE_REF (e);\n+      ipa_edge_args *args = ipa_edge_args_sum->get (e);\n \n       if (!args)\n \t{\n@@ -5003,7 +5000,7 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n     {\n-      class ipa_edge_args *args = IPA_EDGE_REF (e);\n+      ipa_edge_args *args = ipa_edge_args_sum->get (e);\n       if (!args)\n \tstreamer_write_uhwi (ob, 0);\n       else\n@@ -5041,7 +5038,7 @@ ipa_read_edge_info (class lto_input_block *ib,\n \t     will get fnspecs.  */\n \t  || fndecl_built_in_p (e->callee->decl, BUILT_IN_NORMAL)))\n     {\n-      class ipa_edge_args *args = IPA_EDGE_REF_GET_CREATE (e);\n+      ipa_edge_args *args = ipa_edge_args_sum->get_create (e);\n       vec_safe_grow_cleared (args->jump_functions, count, true);\n       if (contexts_computed)\n \tvec_safe_grow_cleared (args->polymorphic_call_contexts, count, true);\n@@ -5080,8 +5077,8 @@ ipa_read_node_info (class lto_input_block *ib, struct cgraph_node *node,\n   struct cgraph_edge *e;\n   struct bitpack_d bp;\n   bool prevails = node->prevailing_p ();\n-  class ipa_node_params *info = prevails\n-\t\t\t\t? IPA_NODE_REF_GET_CREATE (node) : NULL;\n+  ipa_node_params *info\n+    = prevails ? ipa_node_params_sum->get_create (node) : NULL;\n \n   int param_count = streamer_read_uhwi (ib);\n   if (prevails)\n@@ -5130,7 +5127,6 @@ ipa_read_node_info (class lto_input_block *ib, struct cgraph_node *node,\n void\n ipa_prop_write_jump_functions (void)\n {\n-  struct cgraph_node *node;\n   struct output_block *ob;\n   unsigned int count = 0;\n   lto_symtab_encoder_iterator lsei;\n@@ -5145,9 +5141,9 @@ ipa_prop_write_jump_functions (void)\n   for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);\n        lsei_next_function_in_partition (&lsei))\n     {\n-      node = lsei_cgraph_node (lsei);\n+      cgraph_node *node = lsei_cgraph_node (lsei);\n       if (node->has_gimple_body_p ()\n-\t  && IPA_NODE_REF (node) != NULL)\n+\t  && ipa_node_params_sum->get (node) != NULL)\n \tcount++;\n     }\n \n@@ -5157,9 +5153,9 @@ ipa_prop_write_jump_functions (void)\n   for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);\n        lsei_next_function_in_partition (&lsei))\n     {\n-      node = lsei_cgraph_node (lsei);\n+      cgraph_node *node = lsei_cgraph_node (lsei);\n       if (node->has_gimple_body_p ()\n-\t  && IPA_NODE_REF (node) != NULL)\n+\t  && ipa_node_params_sum->get (node) != NULL)\n         ipa_write_node_info (ob, node);\n     }\n   streamer_write_char_stream (ob->main_stream, 0);"}, {"sha": "3d28a6e8640d7b8b870ab30538146e2c419d9ed4", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a3cdd04308ce45c4bee32401fc8121cb561807/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a3cdd04308ce45c4bee32401fc8121cb561807/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=a4a3cdd04308ce45c4bee32401fc8121cb561807", "patch": "@@ -1017,16 +1017,6 @@ class ipcp_transformation_t\n /* Function summary where the IPA CP transformations are actually stored.  */\n extern GTY(()) function_summary <ipcp_transformation *> *ipcp_transformation_sum;\n \n-/* Return the associated parameter/argument info corresponding to the given\n-   node/edge.  */\n-#define IPA_NODE_REF(NODE) (ipa_node_params_sum->get (NODE))\n-#define IPA_NODE_REF_GET_CREATE(NODE) (ipa_node_params_sum->get_create (NODE))\n-#define IPA_EDGE_REF(EDGE) (ipa_edge_args_sum->get (EDGE))\n-#define IPA_EDGE_REF_GET_CREATE(EDGE) (ipa_edge_args_sum->get_create (EDGE))\n-/* This macro checks validity of index returned by\n-   ipa_get_param_decl_index function.  */\n-#define IS_VALID_JUMP_FUNC_INDEX(I) ((I) != -1)\n-\n /* Creating and freeing ipa_node_params and ipa_edge_args.  */\n void ipa_create_all_node_params (void);\n void ipa_create_all_edge_args (void);"}]}