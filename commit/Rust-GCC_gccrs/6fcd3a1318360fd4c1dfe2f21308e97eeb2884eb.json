{"sha": "6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZjZDNhMTMxODM2MGZkNGMxZGZlMmYyMTMwOGU5N2VlYjI4ODRlYg==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2013-09-20T22:42:26Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2013-09-20T22:42:26Z"}, "message": "rl78.c: Various whitespace and comment tweaks.\n\n* config/rl78/rl78.c: Various whitespace and comment tweaks.\n(need_to_save): Save bank 0 on interrupts.\n(characterize_address): Strip far address wrappers.\n(rl78_as_legitimate_address): Likewise.\n(transcode_memory_rtx): Likewise.\n(rl78_peep_movhi_p): Disable this peephole after devirt.\n(rl78_propogate_register_origins): Forget all origins when a\nCLOBBER is seen.\n* config/rl78/rl78-virt.md: Various whitespace tweaks.\n* config/rl78/rl78-real.md: Various whitespace tweaks.  Additional\npeephole2's.\n* config/rl78/rl78.md (sel_rb): Disable for G10 just in case.\n* config/rl78/rl78-expand.md (movqi): Check for subregs of consts.\n* config/rl78/rl78.h (LINK_SPEC): Pass -gc-sections unless\nrelocating.\n* config/rl78/constraints.md: Various whitespace and paren tweaks.\n\nCo-Authored-By: Nick Clifton <nickc@redhat.com>\n\nFrom-SVN: r202801", "tree": {"sha": "2e7945b8746f0470695be66abc48e948a64325c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e7945b8746f0470695be66abc48e948a64325c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb/comments", "author": null, "committer": null, "parents": [{"sha": "4a08db337677d9e9ad22213e47fee02e9f2a97f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a08db337677d9e9ad22213e47fee02e9f2a97f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a08db337677d9e9ad22213e47fee02e9f2a97f0"}], "stats": {"total": 276, "additions": 179, "deletions": 97}, "files": [{"sha": "62576af4c6e6472d3e635bba0946449a67417067", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb", "patch": "@@ -1,3 +1,23 @@\n+2013-09-20  DJ Delorie  <dj@redhat.com>\n+            Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/rl78/rl78.c: Various whitespace and comment tweaks.\n+\t(need_to_save): Save bank 0 on interrupts.\n+\t(characterize_address): Strip far address wrappers.\n+\t(rl78_as_legitimate_address): Likewise.\n+\t(transcode_memory_rtx): Likewise.\n+\t(rl78_peep_movhi_p): Disable this peephole after devirt.\n+\t(rl78_propogate_register_origins): Forget all origins when a\n+\tCLOBBER is seen.\n+\t* config/rl78/rl78-virt.md: Various whitespace tweaks.\n+\t* config/rl78/rl78-real.md: Various whitespace tweaks.  Additional\n+\tpeephole2's.\n+\t* config/rl78/rl78.md (sel_rb): Disable for G10 just in case.\n+\t* config/rl78/rl78-expand.md (movqi): Check for subregs of consts.\n+\t* config/rl78/rl78.h (LINK_SPEC): Pass -gc-sections unless\n+\trelocating.\n+\t* config/rl78/constraints.md: Various whitespace and paren tweaks.\n+\n 2013-09-20  John David Anglin  <danglin@gcc.gnu.org>\n \n \t* config/pa/pa.md: In \"scc\" insn patterns, change output template to"}, {"sha": "1785c666cb353ae05844d49a8b0d1a9f725f0302", "filename": "gcc/config/rl78/constraints.md", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb/gcc%2Fconfig%2Frl78%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb/gcc%2Fconfig%2Frl78%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Fconstraints.md?ref=6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb", "patch": "@@ -62,11 +62,13 @@\n    Integer constant equal to 8.\"\n   (and (match_code \"const_int\")\n        (match_test \"IN_RANGE (ival, 8, 8)\")))\n+\n (define_constraint \"Iv16\"\n   \"@internal\n    Integer constant equal to 16.\"\n   (and (match_code \"const_int\")\n        (match_test \"IN_RANGE (ival, 16, 16)\")))\n+\n (define_constraint \"Iv24\"\n   \"@internal\n    Integer constant equal to 24.\"\n@@ -78,11 +80,13 @@\n    Integer constant in the range 9 @dots{} 15 (for shifts).\"\n   (and (match_code \"const_int\")\n        (match_test \"IN_RANGE (ival, 9, 15)\")))\n+\n (define_constraint \"Is17\"\n   \"@internal\n    Integer constant in the range 17 @dots{} 23 (for shifts).\"\n   (and (match_code \"const_int\")\n        (match_test \"IN_RANGE (ival, 17, 23)\")))\n+\n (define_constraint \"Is25\"\n   \"@internal\n    Integer constant in the range 25 @dots{} 31 (for shifts).\"\n@@ -216,7 +220,7 @@\n   )\n (define_memory_constraint \"Wab\"\n   \"es:[addr]\"\n-  (match_test \"rl78_es_addr (op) && satisfies_constraint_Cab (rl78_es_base (op))\n+  (match_test \"(rl78_es_addr (op) && satisfies_constraint_Cab (rl78_es_base (op)))\n                || satisfies_constraint_Cab (op)\")\n   )\n \n@@ -234,7 +238,7 @@\n   )\n (define_memory_constraint \"Wbc\"\n   \"es:word16[BC]\"\n-  (match_test \"rl78_es_addr (op) && satisfies_constraint_Cbc (rl78_es_base (op))\n+  (match_test \"(rl78_es_addr (op) && satisfies_constraint_Cbc (rl78_es_base (op)))\n                || satisfies_constraint_Cbc (op)\")\n   )\n \n@@ -246,7 +250,7 @@\n   )\n (define_memory_constraint \"Wde\"\n   \"es:[DE]\"\n-  (match_test \"rl78_es_addr (op) && satisfies_constraint_Cde (rl78_es_base (op))\n+  (match_test \"(rl78_es_addr (op) && satisfies_constraint_Cde (rl78_es_base (op)))\n                || satisfies_constraint_Cde (op)\")\n   )\n \n@@ -258,19 +262,19 @@\n   )\n (define_memory_constraint \"Wca\"\n   \"es:[AX..HL] for calls\"\n-  (match_test \"rl78_es_addr (op) && satisfies_constraint_Cca (rl78_es_base (op))\n+  (match_test \"(rl78_es_addr (op) && satisfies_constraint_Cca (rl78_es_base (op)))\n                || satisfies_constraint_Cca (op)\")\n   )\n \n (define_memory_constraint \"Ccv\"\n   \"[AX..HL,r8-r31] for calls\"\n   (and (match_code \"mem\")\n        (and (match_code \"reg\" \"0\")\n-\t    (match_test \"REGNO (XEXP (op, 0)) < 31\")))\n+\t    (match_test \"REGNO (XEXP (op, 0)) < 32\")))\n   )\n (define_memory_constraint \"Wcv\"\n-  \"es:[AX..HL,r8-r23] for calls\"\n-  (match_test \"rl78_es_addr (op) && satisfies_constraint_Ccv (rl78_es_base (op))\n+  \"es:[AX..HL,r8-r31] for calls\"\n+  (match_test \"(rl78_es_addr (op) && satisfies_constraint_Ccv (rl78_es_base (op)))\n                || satisfies_constraint_Ccv (op)\")\n   )\n \n@@ -288,7 +292,7 @@\n   )\n (define_memory_constraint \"Wd2\"\n   \"es:word16[DE]\"\n-  (match_test \"rl78_es_addr (op) && satisfies_constraint_Cd2 (rl78_es_base (op))\n+  (match_test \"(rl78_es_addr (op) && satisfies_constraint_Cd2 (rl78_es_base (op)))\n                || satisfies_constraint_Cd2 (op)\")\n   )\n \n@@ -300,7 +304,7 @@\n   )\n (define_memory_constraint \"Whl\"\n   \"es:[HL]\"\n-  (match_test \"rl78_es_addr (op) && satisfies_constraint_Chl (rl78_es_base (op))\n+  (match_test \"(rl78_es_addr (op) && satisfies_constraint_Chl (rl78_es_base (op)))\n                || satisfies_constraint_Chl (op)\")\n   )\n \n@@ -314,7 +318,7 @@\n   )\n (define_memory_constraint \"Wh1\"\n   \"es:byte8[HL]\"\n-  (match_test \"rl78_es_addr (op) && satisfies_constraint_Ch1 (rl78_es_base (op))\n+  (match_test \"(rl78_es_addr (op) && satisfies_constraint_Ch1 (rl78_es_base (op)))\n                || satisfies_constraint_Ch1 (op)\")\n   )\n \n@@ -325,7 +329,7 @@\n   )\n (define_memory_constraint \"Whb\"\n   \"es:[HL+B]\"\n-  (match_test \"rl78_es_addr (op) && satisfies_constraint_Chb (rl78_es_base (op))\n+  (match_test \"(rl78_es_addr (op) && satisfies_constraint_Chb (rl78_es_base (op)))\n                || satisfies_constraint_Chb (op)\")\n   )\n \n@@ -343,7 +347,7 @@\n   )\n (define_memory_constraint \"Ws1\"\n   \"es:word8[SP]\"\n-  (match_test \"rl78_es_addr (op) && satisfies_constraint_Cs1 (rl78_es_base (op))\n+  (match_test \"(rl78_es_addr (op) && satisfies_constraint_Cs1 (rl78_es_base (op)))\n                || satisfies_constraint_Cs1 (op)\")\n   )\n "}, {"sha": "fa5857ca69a4f79855f3464db227114dc2e395a7", "filename": "gcc/config/rl78/rl78-expand.md", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb/gcc%2Fconfig%2Frl78%2Frl78-expand.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb/gcc%2Fconfig%2Frl78%2Frl78-expand.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-expand.md?ref=6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb", "patch": "@@ -43,14 +43,6 @@\n         && GET_CODE (XEXP (XEXP (XEXP (operand1, 0), 0), 0)) == SYMBOL_REF)\n       FAIL;\n \n-    /* Similarly for (SUBREG (CONST (PLUS (SYMBOL_REF)))).\n-       cf. g++.dg/abi/packed.C.  */\n-    if (GET_CODE (operand1) == SUBREG\n-\t&& GET_CODE (XEXP (operand1, 0)) == CONST\n-        && GET_CODE (XEXP (XEXP (operand1, 0), 0)) == PLUS\n-        && GET_CODE (XEXP (XEXP (XEXP (operand1, 0), 0), 0)) == SYMBOL_REF)\n-      FAIL;\n-\n     if (CONST_INT_P (operand1) && ! IN_RANGE (INTVAL (operand1), (-1 << 8) + 1, (1 << 8) - 1))\n       FAIL;\n   }"}, {"sha": "a16d3524f080fedcba707f2a3d5706066c61ab1a", "filename": "gcc/config/rl78/rl78-real.md", "status": "modified", "additions": 58, "deletions": 23, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb/gcc%2Fconfig%2Frl78%2Frl78-real.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb/gcc%2Fconfig%2Frl78%2Frl78-real.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-real.md?ref=6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb", "patch": "@@ -312,7 +312,7 @@\n    call\\t%A1\"\n   )\n \n-(define_insn \"cbranchqi4_real_signed\"\n+(define_insn \"*cbranchqi4_real_signed\"\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"rl78_cmp_operator_signed\"\n \t\t\t      [(match_operand:QI 1 \"general_operand\" \"A,A,A\")\n@@ -326,7 +326,6 @@\n    cmp\\t%1, %2 \\;xor1 CY,%1.7\\;xor1 CY,%2.7\\;sk%c0 \\;br\\t!!%3\"\n   )\n \n-\n (define_insn \"*cbranchqi4_real\"\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"rl78_cmp_operator_real\"\n@@ -342,7 +341,7 @@\n    cmp\\t%1, %2 \\;sk%c0 \\;br\\t!!%3\"\n   )\n \n-(define_insn \"cbranchhi4_real_signed\"\n+(define_insn \"*cbranchhi4_real_signed\"\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"rl78_cmp_operator_signed\"\n \t\t\t      [(match_operand:HI 1 \"general_operand\" \"A,A,A,vR\")\n@@ -381,7 +380,7 @@\n   \"cmpw\\t%1, %2 \\;sk%c0 \\;br\\t!!%3\"\n   )\n \n-(define_insn \"cbranchsi4_real_lt\"\n+(define_insn \"*cbranchsi4_real_lt\"\n   [(set (pc) (if_then_else\n \t      (lt (match_operand:SI 0 \"general_operand\" \"U,vWabWhlWh1\")\n \t\t  (const_int 0))\n@@ -395,7 +394,7 @@\n    mov1 CY,%E0.7 \\;sknc \\;br\\t!!%1\"\n   )\n \n-(define_insn \"cbranchsi4_real_ge\"\n+(define_insn \"*cbranchsi4_real_ge\"\n   [(set (pc) (if_then_else\n \t      (ge (match_operand:SI 0 \"general_operand\" \"U,vWabWhlWh1\")\n \t\t  (const_int 0))\n@@ -409,7 +408,7 @@\n    mov1 CY,%E0.7 \\;skc \\;br\\t!!%1\"\n   )\n \n-(define_insn \"cbranchsi4_real_signed\"\n+(define_insn \"*cbranchsi4_real_signed\"\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"rl78_cmp_operator_signed\"\n \t\t\t      [(match_operand:SI 1 \"nonimmediate_operand\" \"vU,vU,vU\")\n@@ -425,7 +424,7 @@\n    movw ax,%H1 \\;cmpw  ax, %H2 \\;xor1 CY,a.7\\;xor1 CY,%E2.7\\;movw ax,%h1 \\;sknz \\;cmpw  ax, %h2 \\;sk%c0 \\;br\\t!!%3\"\n   )\n \n-(define_insn \"cbranchsi4_real\"\n+(define_insn \"*cbranchsi4_real\"\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"rl78_cmp_operator_real\"\n \t\t\t      [(match_operand:SI 1 \"general_operand\" \"vUi\")\n@@ -491,26 +490,62 @@\n ;; in the peephole not matching and the optimization being missed.\n \n (define_peephole2\n-  [(set (match_operand:QI 1 \"register_operand\") (reg:QI A_REG))\n-   (set (match_dup 1) (and:QI (match_dup 1) (match_operand 2 \"immediate_operand\")))\n-   (set (pc) (if_then_else (eq (match_dup 1) (const_int 0))\n-\t\t\t   (label_ref (match_operand 3 \"\"))\n+  [(set (match_operand:QI 0 \"register_operand\") (reg:QI A_REG))\n+   (set (match_dup 0) (and:QI (match_dup 0) (match_operand 1 \"immediate_operand\")))\n+   (set (pc) (if_then_else (eq (match_dup 0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 2 \"\"))\n+\t\t\t   (pc)))]\n+  \"peep2_regno_dead_p (3, REGNO (operands[0]))\n+   && exact_log2 (INTVAL (operands[1])) >= 0\"\n+  [(set (pc) (if_then_else (eq (and (reg:QI A_REG) (match_dup 1)) (const_int 0))\n+\t\t\t   (label_ref (match_dup 2))\n \t\t\t   (pc)))]\n-  \"peep2_regno_dead_p (3, REGNO (operands[1]))\n-   && exact_log2 (INTVAL (operands[2])) >= 0\"\n-  [(set (pc) (if_then_else (eq (and (reg:QI A_REG) (match_dup 2)) (const_int 0))\n-\t\t\t   (label_ref (match_dup 3)) (pc)))]\n   )\n \n (define_peephole2\n-  [(set (match_operand:QI 1 \"register_operand\") (reg:QI A_REG))\n-   (set (match_dup 1) (and:QI (match_dup 1) (match_operand 2 \"immediate_operand\")))\n-   (set (pc) (if_then_else (ne (match_dup 1) (const_int 0))\n-\t\t\t   (label_ref (match_operand 3 \"\"))\n+  [(set (match_operand:QI 0 \"register_operand\") (reg:QI A_REG))\n+   (set (match_dup 0) (and:QI (match_dup 0) (match_operand 1 \"immediate_operand\")))\n+   (set (pc) (if_then_else (ne (match_dup 0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 2 \"\"))\n \t\t\t   (pc)))]\n-  \"peep2_regno_dead_p (3, REGNO (operands[1]))\n-   && exact_log2 (INTVAL (operands[2])) >= 0\"\n-  [(set (pc) (if_then_else (ne (and (reg:QI A_REG) (match_dup 2)) (const_int 0))\n-\t\t\t   (label_ref (match_dup 3)) (pc)))]\n+  \"peep2_regno_dead_p (3, REGNO (operands[0]))\n+   && exact_log2 (INTVAL (operands[1])) >= 0\"\n+  [(set (pc) (if_then_else (ne (and (reg:QI A_REG) (match_dup 1)) (const_int 0))\n+\t\t\t   (label_ref (match_dup 2))\n+\t\t\t   (pc)))]\n+  )\n+\n+;; Eliminate needless register copies.\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"register_operand\") (match_operand:HI 1 \"register_operand\"))\n+   (set (match_operand:HI 2 \"register_operand\") (match_dup 0))]\n+  \"peep2_regno_dead_p (2, REGNO (operands[0]))\n+   && (REGNO (operands[1]) < 8 || REGNO (operands[2]) < 8)\"\n+  [(set (match_dup 2) (match_dup 1))]\n+  )\n+\n+;; Eliminate needless register copying when performing bit manipulations.\n+(define_peephole2\n+  [(set (match_operand:QI 0 \"register_operand\") (reg:QI A_REG))\n+   (set (match_dup 0) (ior:QI (match_dup 0) (match_operand 1 \"immediate_operand\")))\n+   (set (reg:QI A_REG) (match_dup 0))]\n+  \"peep2_regno_dead_p (3, REGNO (operands[0]))\"\n+  [(set (reg:QI A_REG) (ior:QI (reg:QI A_REG) (match_dup 1)))]\n+  )\n+\n+(define_peephole2\n+  [(set (match_operand:QI 0 \"register_operand\") (reg:QI A_REG))\n+   (set (match_dup 0) (xor:QI (match_dup 0) (match_operand 1 \"immediate_operand\")))\n+   (set (reg:QI A_REG) (match_dup 0))]\n+  \"peep2_regno_dead_p (3, REGNO (operands[0]))\"\n+  [(set (reg:QI A_REG) (xor:QI (reg:QI A_REG) (match_dup 1)))]\n+  )\n+\n+(define_peephole2\n+  [(set (match_operand:QI 0 \"register_operand\") (reg:QI A_REG))\n+   (set (match_dup 0) (and:QI (match_dup 0) (match_operand 1 \"immediate_operand\")))\n+   (set (reg:QI A_REG) (match_dup 0))]\n+  \"peep2_regno_dead_p (3, REGNO (operands[0]))\"\n+  [(set (reg:QI A_REG) (and:QI (reg:QI A_REG) (match_dup 1)))]\n   )\n "}, {"sha": "170d14a261ddb9a8bce6f77673fafc67d78698b5", "filename": "gcc/config/rl78/rl78-virt.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb/gcc%2Fconfig%2Frl78%2Frl78-virt.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb/gcc%2Fconfig%2Frl78%2Frl78-virt.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-virt.md?ref=6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb", "patch": "@@ -312,7 +312,7 @@\n   [(set_attr \"valloc\" \"op1\")]\n   )\n \n-(define_insn \"cbranchqi4_virt_signed\"\n+(define_insn \"*cbranchqi4_virt_signed\"\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"rl78_cmp_operator_signed\"\n \t\t\t      [(match_operand:QI 1 \"general_operand\" \"vim\")\n@@ -336,7 +336,7 @@\n   [(set_attr \"valloc\" \"cmp\")]\n   )\n \n-(define_insn \"cbranchhi4_virt_signed\"\n+(define_insn \"*cbranchhi4_virt_signed\"\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"rl78_cmp_operator_signed\"\n \t\t\t      [(match_operand:HI 1 \"general_operand\" \"vim\")\n@@ -360,7 +360,7 @@\n   [(set_attr \"valloc\" \"cmp\")]\n   )\n \n-(define_insn \"cbranchsi4_virt\"\n+(define_insn \"*cbranchsi4_virt\"\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"rl78_cmp_operator\"\n \t\t\t      [(match_operand:SI 1 \"general_operand\" \"vim\")"}, {"sha": "fb987b2eae9bdbcdc291a5f9856b4f8432d5ade5", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 80, "deletions": 50, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb", "patch": "@@ -170,6 +170,9 @@ make_pass_rl78_devirt (gcc::context *ctxt)\n   return new pass_rl78_devirt (ctxt);\n }\n \n+/* Redundant move elimination pass.  Must be run after the basic block\n+   reordering pass for the best effect.  */\n+\n static unsigned int\n move_elim_pass (void)\n {\n@@ -314,7 +317,8 @@ rl78_option_override (void)\n   if (TARGET_ALLREGS)\n     {\n       int i;\n-      for (i=24; i<32; i++)\n+\n+      for (i = 24; i < 32; i++)\n \tfixed_regs[i] = 0;\n     }\n }\n@@ -442,13 +446,15 @@ rl78_expand_movsi (rtx *operands)\n     }\n }\n \n+/* Generate code to move an SImode value.  */\n void\n rl78_split_movsi (rtx *operands)\n {\n   rtx op00, op02, op10, op12;\n \n   op00 = rl78_subreg (HImode, operands[0], SImode, 0);\n   op02 = rl78_subreg (HImode, operands[0], SImode, 2);\n+\n   if (GET_CODE (operands[1]) == CONST\n       || GET_CODE (operands[1]) == SYMBOL_REF)\n     {\n@@ -481,7 +487,6 @@ rl78_split_movsi (rtx *operands)\n     }\n }\n \n-\n /* Used by various two-operand expanders which cannot accept all\n    operands in the \"far\" namespace.  Force some such operands into\n    registers so that each pattern has at most one far operand.  */\n@@ -555,6 +560,10 @@ need_to_save (unsigned int regno)\n {\n   if (is_interrupt_func (cfun->decl))\n     {\n+      /* We don't know what devirt will need */\n+      if (regno < 8)\n+\treturn true;\n+\n        /* We don't need to save registers that have\n \t  been reserved for interrupt handlers.  */\n       if (regno > 23)\n@@ -696,6 +705,10 @@ characterize_address (rtx x, rtx *base, rtx *index, rtx *addend)\n   *index = NULL_RTX;\n   *addend = NULL_RTX;\n \n+  if (GET_CODE (x) == UNSPEC\n+      && XINT (x, 1) == UNS_ES_ADDR)\n+    x = XVECEXP (x, 0, 1);\n+\n   if (GET_CODE (x) == REG)\n     {\n       *base = x;\n@@ -870,13 +883,17 @@ rl78_as_legitimate_address (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x,\n \t\t\t    bool strict ATTRIBUTE_UNUSED, addr_space_t as ATTRIBUTE_UNUSED)\n {\n   rtx base, index, addend;\n+  bool is_far_addr = false;\n \n   if (GET_CODE (x) == UNSPEC\n       && XINT (x, 1) == UNS_ES_ADDR)\n-    x = XVECEXP (x, 0, 1);\n+    {\n+      x = XVECEXP (x, 0, 1);\n+      is_far_addr = true;\n+    }\n \n   if (as == ADDR_SPACE_GENERIC\n-      && GET_MODE (x) == SImode)\n+      && (GET_MODE (x) == SImode || is_far_addr))\n     return false;\n \n   if (! characterize_address (x, &base, &index, &addend))\n@@ -1062,16 +1079,19 @@ rl78_expand_prologue (void)\n \t    emit_move_insn (gen_rtx_REG (HImode, 0), gen_rtx_REG (HImode, i*2));\n \t    F (emit_insn (gen_push (gen_rtx_REG (HImode, 0))));\n \t  }\n-\telse {\n-\t  int need_bank = i/4;\n-\t  if (need_bank != rb)\n-\t    {\n-\t      emit_insn (gen_sel_rb (GEN_INT (need_bank)));\n-\t      rb = need_bank;\n-\t    }\n-\t  F (emit_insn (gen_push (gen_rtx_REG (HImode, i*2))));\n-\t}\n+\telse\n+\t  {\n+\t    int need_bank = i/4;\n+\n+\t    if (need_bank != rb)\n+\t      {\n+\t\temit_insn (gen_sel_rb (GEN_INT (need_bank)));\n+\t\trb = need_bank;\n+\t      }\n+\t    F (emit_insn (gen_push (gen_rtx_REG (HImode, i*2))));\n+\t  }\n       }\n+\n   if (rb != 0)\n     emit_insn (gen_sel_rb (GEN_INT (0)));\n \n@@ -1675,6 +1695,9 @@ rl78_peep_movhi_p (rtx *operands)\n   /* (set (op0) (op1))\n      (set (op2) (op3)) */\n \n+  if (! rl78_virt_insns_ok ())\n+    return false;\n+\n #if DEBUG_PEEP\n   fprintf (stderr, \"\\033[33m\");\n   debug_rtx (operands[0]);\n@@ -1947,7 +1970,6 @@ get_content_index (rtx loc)\n \n /* Return a string describing content INDEX in mode MODE.\n    WARNING: Can return a pointer to a static buffer.  */\n-\n static const char *\n get_content_name (unsigned char index, enum machine_mode mode)\n {\n@@ -2155,9 +2177,9 @@ insn_ok_now (rtx insn)\n \t  /* We need to detect far addresses that haven't been\n \t     converted to es/lo16 format.  */\n \t  for (i=0; i<recog_data.n_operands; i++)\n-\t    if (GET_CODE (OP(i)) == MEM\n-\t\t&& GET_MODE (XEXP (OP(i), 0)) == SImode\n-\t\t&& GET_CODE (XEXP (OP(i), 0)) != UNSPEC)\n+\t    if (GET_CODE (OP (i)) == MEM\n+\t\t&& GET_MODE (XEXP (OP (i), 0)) == SImode\n+\t\t&& GET_CODE (XEXP (OP (i), 0)) != UNSPEC)\n \t      return false;\n \n \t  return true;\n@@ -2166,7 +2188,7 @@ insn_ok_now (rtx insn)\n   else\n     {\n       /* We need to re-recog the insn with virtual registers to get\n-\t the operands */\n+\t the operands.  */\n       cfun->machine->virt_insns_ok = 1;\n       if (recog (pattern, insn, 0) > -1)\n \t{\n@@ -2206,22 +2228,22 @@ insn_ok_now (rtx insn)\n #endif\n \n /* Registers into which we move the contents of virtual registers.  */\n-#define X gen_rtx_REG (QImode, 0)\n-#define A gen_rtx_REG (QImode, 1)\n-#define C gen_rtx_REG (QImode, 2)\n-#define B gen_rtx_REG (QImode, 3)\n-#define E gen_rtx_REG (QImode, 4)\n-#define D gen_rtx_REG (QImode, 5)\n-#define L gen_rtx_REG (QImode, 6)\n-#define H gen_rtx_REG (QImode, 7)\n-\n-#define AX gen_rtx_REG (HImode, 0)\n-#define BC gen_rtx_REG (HImode, 2)\n-#define DE gen_rtx_REG (HImode, 4)\n-#define HL gen_rtx_REG (HImode, 6)\n+#define X gen_rtx_REG (QImode, X_REG)\n+#define A gen_rtx_REG (QImode, A_REG)\n+#define C gen_rtx_REG (QImode, C_REG)\n+#define B gen_rtx_REG (QImode, B_REG)\n+#define E gen_rtx_REG (QImode, E_REG)\n+#define D gen_rtx_REG (QImode, D_REG)\n+#define L gen_rtx_REG (QImode, L_REG)\n+#define H gen_rtx_REG (QImode, H_REG)\n+\n+#define AX gen_rtx_REG (HImode, AX_REG)\n+#define BC gen_rtx_REG (HImode, BC_REG)\n+#define DE gen_rtx_REG (HImode, DE_REG)\n+#define HL gen_rtx_REG (HImode, HL_REG)\n \n /* Returns TRUE if R is a virtual register.  */\n-static bool\n+static inline bool\n is_virtual_register (rtx r)\n {\n   return (GET_CODE (r) == REG\n@@ -2364,6 +2386,7 @@ gen_and_emit_move (rtx to, rtx from, rtx where, bool before)\n       else\n \tadd_postponed_content_update (to, from);\n     }\n+\n   return before ? to : from;\n }\n \n@@ -2382,7 +2405,9 @@ transcode_memory_rtx (rtx m, rtx newbase, rtx before)\n \n   if (GET_MODE (XEXP (m, 0)) == SImode)\n     {\n+      rtx new_m;\n       rtx seg = rl78_hi8 (XEXP (m, 0));\n+\n #if DEBUG_ALLOC\n       fprintf (stderr, \"setting ES:\\n\");\n       debug_rtx(seg);\n@@ -2391,7 +2416,9 @@ transcode_memory_rtx (rtx m, rtx newbase, rtx before)\n       emit_insn_before (EM (gen_movqi_es (A)), before);\n       record_content (A, NULL_RTX);\n \n-      m = change_address (m, GET_MODE (m), rl78_lo16 (XEXP (m, 0)));\n+      new_m = gen_rtx_MEM (GET_MODE (m), rl78_lo16 (XEXP (m, 0)));\n+      MEM_COPY_ATTRIBUTES (new_m, m);\n+      m = new_m;\n       need_es = 1;\n     }\n \n@@ -2465,7 +2492,6 @@ transcode_memory_rtx (rtx m, rtx newbase, rtx before)\n \n /* Copy SRC to accumulator (A or AX), placing any generated insns\n    before BEFORE.  Returns accumulator RTX.  */\n-\n static rtx\n move_to_acc (int opno, rtx before)\n {\n@@ -2500,7 +2526,6 @@ force_into_acc (rtx src, rtx before)\n \n /* Copy accumulator (A or AX) to DEST, placing any generated insns\n    after AFTER.  Returns accumulator RTX.  */\n-\n static rtx\n move_from_acc (unsigned int opno, rtx after)\n {\n@@ -2515,7 +2540,6 @@ move_from_acc (unsigned int opno, rtx after)\n \n /* Copy accumulator (A or AX) to REGNO, placing any generated insns\n    before BEFORE.  Returns reg RTX.  */\n-\n static rtx\n move_acc_to_reg (rtx acc, int regno, rtx before)\n {\n@@ -2529,7 +2553,6 @@ move_acc_to_reg (rtx acc, int regno, rtx before)\n \n /* Copy SRC to X, placing any generated insns before BEFORE.\n    Returns X RTX.  */\n-\n static rtx\n move_to_x (int opno, rtx before)\n {\n@@ -2544,16 +2567,15 @@ move_to_x (int opno, rtx before)\n   if (mode == QImode || ! is_virtual_register (OP (opno)))\n     {\n       OP (opno) = move_to_acc (opno, before);\n-      OP (opno) = move_acc_to_reg (OP(opno), X_REG, before);\n+      OP (opno) = move_acc_to_reg (OP (opno), X_REG, before);\n       return reg;\n     }\n \n   return gen_and_emit_move (reg, src, before, true);\n }\n \n-/* Copy OP(opno) to H or HL, placing any generated insns before BEFORE.\n+/* Copy OP (opno) to H or HL, placing any generated insns before BEFORE.\n    Returns H/HL RTX.  */\n-\n static rtx\n move_to_hl (int opno, rtx before)\n {\n@@ -2575,9 +2597,8 @@ move_to_hl (int opno, rtx before)\n   return gen_and_emit_move (reg, src, before, true);\n }\n \n-/* Copy OP(opno) to E or DE, placing any generated insns before BEFORE.\n+/* Copy OP (opno) to E or DE, placing any generated insns before BEFORE.\n    Returns E/DE RTX.  */\n-\n static rtx\n move_to_de (int opno, rtx before)\n {\n@@ -2802,7 +2823,6 @@ rl78_alloc_physical_registers_op2 (rtx insn)\n \t}\n     }\n \n-\n   OP (0) = move_from_acc (0, insn);\n \n   tmp_id = get_max_insn_count ();\n@@ -2838,7 +2858,6 @@ rl78_alloc_physical_registers_op2 (rtx insn)\n }\n \n /* Devirtualize an insn of the form SET (PC) (MEM/REG).  */\n-\n static void\n rl78_alloc_physical_registers_ro1 (rtx insn)\n {\n@@ -2852,7 +2871,6 @@ rl78_alloc_physical_registers_ro1 (rtx insn)\n }\n \n /* Devirtualize a compare insn.  */\n-\n static void\n rl78_alloc_physical_registers_cmp (rtx insn)\n {\n@@ -2864,13 +2882,13 @@ rl78_alloc_physical_registers_cmp (rtx insn)\n   OP (1) = transcode_memory_rtx (OP (1), DE, insn);\n   OP (2) = transcode_memory_rtx (OP (2), HL, insn);\n \n-  /* HI compares have to have OP(1) in AX, but QI\n+  /* HI compares have to have OP (1) in AX, but QI\n      compares do not, so it is worth checking here.  */\n   MAYBE_OK (insn);\n \n-  /* For an HImode compare, OP(1) must always be in AX.\n-     But if OP(1) is a REG (and not AX), then we can avoid\n-     a reload of OP(1) if we reload OP(2) into AX and invert\n+  /* For an HImode compare, OP (1) must always be in AX.\n+     But if OP (1) is a REG (and not AX), then we can avoid\n+     a reload of OP (1) if we reload OP (2) into AX and invert\n      the comparison.  */\n   if (REG_P (OP (1))\n       && REGNO (OP (1)) != AX_REG\n@@ -2946,7 +2964,6 @@ rl78_alloc_physical_registers_cmp (rtx insn)\n }\n \n /* Like op2, but AX = A op X.  */\n-\n static void\n rl78_alloc_physical_registers_umul (rtx insn)\n {\n@@ -3054,6 +3071,7 @@ rl78_alloc_address_registers_macax (rtx insn)\n \t  which ++;\n \t}\n     }\n+\n   MUST_BE_OK (insn);\n }\n \n@@ -3176,6 +3194,7 @@ rl78_alloc_physical_registers (void)\n       else\n \tprocess_postponed_content_update ();\n     }\n+\n #if DEBUG_ALLOC\n   fprintf (stderr, \"\\033[0m\");\n #endif\n@@ -3544,6 +3563,16 @@ rl78_propogate_register_origins (void)\n \t\t    }\n \t\t}\n \t    }\n+\t  else if (GET_CODE (pat) == CLOBBER)\n+\t    {\n+\t      if (REG_P (XEXP (pat, 0)))\n+\t\t{\n+\t\t  unsigned int reg = REGNO (XEXP (pat, 0));\n+\n+\t\t  origins[reg] = reg;\n+\t\t  age[reg] = 0;\n+\t\t}\n+\t    }\n \t}\n     }\n }\n@@ -3693,6 +3722,7 @@ rl78_unwind_word_mode (void)\n   return HImode;\n }\n \n+\f\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-rl78.h\""}, {"sha": "3a656de626c1b6cafdf219aa4b7911dea7dbb746", "filename": "gcc/config/rl78/rl78.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb/gcc%2Fconfig%2Frl78%2Frl78.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb/gcc%2Fconfig%2Frl78%2Frl78.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.h?ref=6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb", "patch": "@@ -52,6 +52,7 @@\n #undef  LINK_SPEC\n #define LINK_SPEC \"\\\n %{mrelax:-relax} \\\n+%{!r:--gc-sections} \\\n \"\n \n #undef  LIB_SPEC"}, {"sha": "a43b41b472f9a61e18473e4700686db194c61b13", "filename": "gcc/config/rl78/rl78.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb/gcc%2Fconfig%2Frl78%2Frl78.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb/gcc%2Fconfig%2Frl78%2Frl78.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.md?ref=6fcd3a1318360fd4c1dfe2f21308e97eeb2884eb", "patch": "@@ -142,7 +142,7 @@\n \n (define_insn \"sel_rb\"\n   [(unspec_volatile [(match_operand 0 \"immediate_operand\" \"\")] UNS_SET_RB)]\n-  \"\"\n+  \"!TARGET_G10\"\n   \"sel\\trb%u0\"\n   )\n "}]}