{"sha": "0d8f38d33736f6cc7fbd8322e1ec8b67184ce454", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ4ZjM4ZDMzNzM2ZjZjYzdmYmQ4MzIyZTFlYzhiNjcxODRjZTQ1NA==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2009-11-26T10:44:28Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2009-11-26T10:44:28Z"}, "message": "rx.c (rx_expand_epilogue): Add checks for sibcalls being used incorrectly.\n\n        * config/rx/rx.c (rx_expand_epilogue): Add checks for sibcalls\n        being used incorrectly.\n        (rx_function_ok_for_sibcall): New function.  Do not allow indirect\n        sibcalls, or sibcalls from interrupt functions.\n        (TARGET_FUNCTION_OK_FOR_SIBCALL): Define.\n        * config/rx/rx.md (sibcall): Convert to a define_expand.  Check\n        for a MEM inside a MEM.\n        (sibcall_value): Likewise.\n        (sibcall_internal): New pattern containing old sibcall pattern.\n        (sibcall_value_internal): Likewise.\n\nFrom-SVN: r154671", "tree": {"sha": "5e7ee5d5da5e4e095ba98a11720f3e4caa104352", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e7ee5d5da5e4e095ba98a11720f3e4caa104352"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d8f38d33736f6cc7fbd8322e1ec8b67184ce454", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d8f38d33736f6cc7fbd8322e1ec8b67184ce454", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d8f38d33736f6cc7fbd8322e1ec8b67184ce454", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d8f38d33736f6cc7fbd8322e1ec8b67184ce454/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5d6b1baca04732559753fbd217aaf40b0463c4a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d6b1baca04732559753fbd217aaf40b0463c4a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d6b1baca04732559753fbd217aaf40b0463c4a0"}], "stats": {"total": 118, "additions": 103, "deletions": 15}, "files": [{"sha": "f49328301948ae0672b5993298e728c3baded274", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d8f38d33736f6cc7fbd8322e1ec8b67184ce454/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d8f38d33736f6cc7fbd8322e1ec8b67184ce454/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d8f38d33736f6cc7fbd8322e1ec8b67184ce454", "patch": "@@ -1,3 +1,16 @@\n+2009-11-26  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/rx/rx.c (rx_expand_epilogue): Add checks for sibcalls\n+\tbeing used incorrectly.\n+\t(rx_function_ok_for_sibcall): New function.  Do not allow indirect\n+\tsibcalls, or sibcalls from interrupt functions.\n+\t(TARGET_FUNCTION_OK_FOR_SIBCALL): Define.\n+\t* config/rx/rx.md (sibcall): Convert to a define_expand.  Check\n+\tfor a MEM inside a MEM.\n+\t(sibcall_value): Likewise.\n+\t(sibcall_internal): New pattern containing old sibcall pattern.\n+\t(sibcall_value_internal): Likewise.\n+\n 2009-11-25  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386-builtin-types.awk (DEF_VECTOR_TYPE): Allow an"}, {"sha": "14cf09b6f42031756fa199133b34e57a23c14f0b", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d8f38d33736f6cc7fbd8322e1ec8b67184ce454/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d8f38d33736f6cc7fbd8322e1ec8b67184ce454/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=0d8f38d33736f6cc7fbd8322e1ec8b67184ce454", "patch": "@@ -1190,7 +1190,7 @@ mark_frame_related (rtx insn)\n     {\n       unsigned int i;\n \n-      for (i = 0; i < XVECLEN (insn, 0); i++)\n+      for (i = 0; i < (unsigned) XVECLEN (insn, 0); i++)\n \tRTX_FRAME_RELATED_P (XVECEXP (insn, 0, i)) = 1;\n     }\n }\n@@ -1454,8 +1454,26 @@ rx_expand_epilogue (bool is_sibcall)\n   unsigned int reg;\n   unsigned HOST_WIDE_INT total_size;\n \n+  /* FIXME: We do not support indirect sibcalls at the moment becaause we\n+     cannot guarantee that the register holding the function address is a\n+     call-used register.  If it is a call-saved register then the stack\n+     pop instructions generated in the epilogue will corrupt the address\n+     before it is used.\n+\n+     Creating a new call-used-only register class works but then the\n+     reload pass gets stuck because it cannot always find a call-used\n+     register for spilling sibcalls.\n+\n+     The other possible solution is for this pass to scan forward for the\n+     sibcall instruction (if it has been generated) and work out if it\n+     is an indirect sibcall using a call-saved register.  If it is then\n+     the address can copied into a call-used register in this epilogue\n+     code and the sibcall instruction modified to use that register.  */\n+\n   if (is_naked_func (NULL_TREE))\n     {\n+      gcc_assert (! is_sibcall);\n+\n       /* Naked functions use their own, programmer provided epilogues.\n \t But, in order to keep gcc happy we have to generate some kind of\n \t epilogue RTL.  */\n@@ -1547,9 +1565,15 @@ rx_expand_epilogue (bool is_sibcall)\n \t}\n \n       if (is_fast_interrupt_func (NULL_TREE))\n-\temit_jump_insn (gen_fast_interrupt_return ());\n+\t{\n+\t  gcc_assert (! is_sibcall);\n+\t  emit_jump_insn (gen_fast_interrupt_return ());\n+\t}\n       else if (is_interrupt_func (NULL_TREE))\n-\temit_jump_insn (gen_exception_return ());\n+\t{\n+\t  gcc_assert (! is_sibcall);\n+\t  emit_jump_insn (gen_exception_return ());\n+\t}\n       else if (! is_sibcall)\n \temit_jump_insn (gen_simple_return ());\n \n@@ -2107,6 +2131,26 @@ rx_func_attr_inlinable (const_tree decl)\n     &&   ! is_naked_func (decl);  \n }\n \n+/* Return nonzero if it is ok to make a tail-call to DECL,\n+   a function_decl or NULL if this is an indirect call, using EXP  */\n+\n+static bool\n+rx_function_ok_for_sibcall (tree decl, tree exp)\n+{\n+  /* Do not allow indirect tailcalls.  The\n+     sibcall patterns do not support them.  */\n+  if (decl == NULL)\n+    return false;\n+\n+  /* Never tailcall from inside interrupt handlers or naked functions.  */\n+  if (is_fast_interrupt_func (NULL_TREE)\n+      || is_interrupt_func (NULL_TREE)\n+      || is_naked_func (NULL_TREE))\n+    return false;\n+\n+  return true;\n+}\n+\n static void\n rx_file_start (void)\n {\n@@ -2485,6 +2529,9 @@ rx_trampoline_init (rtx tramp, tree fndecl, rtx chain)\n #undef  TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P\n #define TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P \trx_func_attr_inlinable\n \n+#undef  TARGET_FUNCTION_OK_FOR_SIBCALL\n+#define TARGET_FUNCTION_OK_FOR_SIBCALL\t\trx_function_ok_for_sibcall\n+\n #undef  TARGET_SET_CURRENT_FUNCTION\n #define TARGET_SET_CURRENT_FUNCTION\t\trx_set_current_function\n "}, {"sha": "a2c1c7c67ed34dfc7e12e0d23496d39b7f6e5a64", "filename": "gcc/config/rx/rx.md", "status": "modified", "additions": 40, "deletions": 12, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d8f38d33736f6cc7fbd8322e1ec8b67184ce454/gcc%2Fconfig%2Frx%2Frx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d8f38d33736f6cc7fbd8322e1ec8b67184ce454/gcc%2Fconfig%2Frx%2Frx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.md?ref=0d8f38d33736f6cc7fbd8322e1ec8b67184ce454", "patch": "@@ -388,7 +388,7 @@\n \t (match_operand:SI         1 \"general_operand\" \"g,g\"))]\n   \"\"\n   \"@\n-  jsr\\t%A0\n+  jsr\\t%0\n   bsr\\t%A0\"\n   [(set_attr \"length\" \"2,4\")\n    (set_attr \"timings\" \"33\")]\n@@ -415,32 +415,60 @@\n \t      (match_operand:SI         2 \"general_operand\"   \"g,g\")))]\n   \"\"\n   \"@\n-  jsr\\t%A1\n+  jsr\\t%1\n   bsr\\t%A1\"\n   [(set_attr \"length\" \"2,4\")\n    (set_attr \"timings\" \"33\")]\n )\n \n-(define_insn \"sibcall\"\n- [(call (mem:QI (match_operand:SI 0 \"rx_symbolic_call_operand\" \"Symbol\"))\n-\t(match_operand:SI         1 \"general_operand\"          \"g\"))\n-  (return)\n-  (use (match_operand             2 \"\" \"\"))]\n+;; Note - we do not allow indirect sibcalls (with the address\n+;; held in a register) because we cannot guarantee that the register\n+;; chosen will be a call-used one.  If it is a call-saved register,\n+;; then the epilogue code will corrupt it by popping the saved value\n+;; off of the stack.\n+(define_expand \"sibcall\"\n+  [(parallel\n+    [(call (mem:QI (match_operand:SI 0 \"rx_symbolic_call_operand\"))\n+\t   (match_operand:SI         1 \"general_operand\"))\n+     (return)])]\n+  \"\"\n+  {\n+    if (MEM_P (operands[0]))\n+      operands[0] = XEXP (operands[0], 0);\n+  }\n+)\n+\n+(define_insn \"sibcall_internal\"\n+  [(call (mem:QI (match_operand:SI 0 \"rx_symbolic_call_operand\" \"Symbol\"))\n+\t (match_operand:SI         1 \"general_operand\"          \"g\"))\n+   (return)]\n   \"\"\n   \"bra\\t%A0\"\n-  [(set_attr \"length\" \"4\")\n+  [(set_attr \"length\"  \"4\")\n    (set_attr \"timings\" \"33\")]\n )\n \n-(define_insn \"sibcall_value\"\n+(define_expand \"sibcall_value\"\n+ [(parallel\n+   [(set (match_operand                  0 \"register_operand\")\n+\t (call (mem:QI (match_operand:SI 1 \"rx_symbolic_call_operand\"))\n+\t       (match_operand:SI         2 \"general_operand\")))\n+    (return)])]\n+  \"\"\n+  {\n+    if (MEM_P (operands[1]))\n+      operands[1] = XEXP (operands[1], 0);\n+  }\n+)\n+\n+(define_insn \"sibcall_value_internal\"\n  [(set (match_operand                  0 \"register_operand\"         \"=r\")\n        (call (mem:QI (match_operand:SI 1 \"rx_symbolic_call_operand\" \"Symbol\"))\n \t     (match_operand:SI         2 \"general_operand\"          \"g\")))\n-  (return)\n-  (use (match_operand                  3 \"\" \"\"))]\n+  (return)]\n   \"\"\n   \"bra\\t%A1\"\n-  [(set_attr \"length\" \"4\")\n+  [(set_attr \"length\"  \"4\")\n    (set_attr \"timings\" \"33\")]\n )\n "}]}