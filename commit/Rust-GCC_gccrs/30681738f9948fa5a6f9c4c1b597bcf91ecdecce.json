{"sha": "30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA2ODE3MzhmOTk0OGZhNWE2ZjljNGMxYjU5N2JjZjkxZWNkZWNjZQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-06-06T10:14:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:14:14Z"}, "message": "g-string.adb, [...]: Replace GNAT.xxx by System.xxx when appropriate.\n\n2007-04-20  Robert Dewar  <dewar@adacore.com>\n\n\t* g-string.adb, s-proinf-irix-athread.adb, s-gloloc-mingw.adb,\n\ts-tfsetr-default.adb, gnatfind.adb, gnatxref.adb, gprep.adb,\n\tg-regexp.adb, g-regexp.ads, g-regpat.ads, g-tasloc.adb, g-tasloc.ads,\n\toutput.adb, switch-m.ads, tree_in.ads, tree_io.ads, indepsw.ads,\n\tg-utf_32.adb, g-utf_32.ads, a-wichun.adb, a-wichun.ads, a-zchuni.adb,\n\ta-zchuni.ads: Replace GNAT.xxx by System.xxx when appropriate.\n\n\t* s-utf_32.adb, s-utf_32.ads, s-os_lib.adb, s-os_lib.ads, s-regexp.adb,\n\ts-regexp.ads, s-regpat.adb, s-regpat.ads, s-string.adb, s-string.ads,\n\ts-tasloc.adb, s-tasloc.ads: New files.\n\nFrom-SVN: r125360", "tree": {"sha": "b51440baca1000109ade68e8810c96e54d706828", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b51440baca1000109ade68e8810c96e54d706828"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/comments", "author": null, "committer": null, "parents": [{"sha": "cecaf88a61b4a50d074990c29afb8cb1792b727e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cecaf88a61b4a50d074990c29afb8cb1792b727e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cecaf88a61b4a50d074990c29afb8cb1792b727e"}], "stats": {"total": 21376, "additions": 15134, "deletions": 6242}, "files": [{"sha": "6d1daf59817c2cd45fb82de16be6bab60a522950", "filename": "gcc/ada/a-wichun.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fa-wichun.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fa-wichun.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wichun.adb?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---            Copyright (C) 2005, Free Software Foundation, Inc.            --\n+--          Copyright (C) 2005-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,7 +33,7 @@\n \n package body Ada.Wide_Characters.Unicode is\n \n-   package G renames GNAT.UTF_32;\n+   package G renames System.UTF_32;\n \n    ------------------\n    -- Get_Category --"}, {"sha": "eb30fc7e5e667fdaf225cd7b48916b7b06021922", "filename": "gcc/ada/a-wichun.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fa-wichun.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fa-wichun.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wichun.ads?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 2005, Free Software Foundation, Inc.            --\n+--          Copyright (C) 2005-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,15 +36,15 @@\n --  Ada 2005 unit), but we make it available in Ada 95 mode, since it\n --  only deals with wide characters.\n \n-with GNAT.UTF_32;\n+with System.UTF_32;\n \n package Ada.Wide_Characters.Unicode is\n \n    --  The following type defines the categories from the unicode definitions.\n    --  The one addition we make is Fe, which represents the characters FFFE\n    --  and FFFF in any of the planes.\n \n-   type Category is new GNAT.UTF_32.Category;\n+   type Category is new System.UTF_32.Category;\n    --  Cc   Other, Control\n    --  Cf   Other, Format\n    --  Cn   Other, Not Assigned"}, {"sha": "5d8facdff0a74f9503dd076bae22954f6b9c1128", "filename": "gcc/ada/a-zchuni.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fa-zchuni.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fa-zchuni.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-zchuni.adb?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---            Copyright (C) 2005, Free Software Foundation, Inc.            --\n+--          Copyright (C) 2005-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,7 +33,7 @@\n \n package body Ada.Wide_Wide_Characters.Unicode is\n \n-   package G renames GNAT.UTF_32;\n+   package G renames System.UTF_32;\n \n    ------------------\n    -- Get_Category --"}, {"sha": "ab5114470088c2e01dac8af6c1e91e06b7961d20", "filename": "gcc/ada/a-zchuni.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fa-zchuni.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fa-zchuni.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-zchuni.ads?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 2005, Free Software Foundation, Inc.            --\n+--          Copyright (C) 2005-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,15 +33,15 @@\n \n --  Unicode categorization routines for Wide_Wide_Character\n \n-with GNAT.UTF_32;\n+with System.UTF_32;\n \n package Ada.Wide_Wide_Characters.Unicode is\n \n    --  The following type defines the categories from the unicode definitions.\n    --  The one addition we make is Fe, which represents the characters FFFE\n    --  and FFFF in any of the planes.\n \n-   type Category is new GNAT.UTF_32.Category;\n+   type Category is new System.UTF_32.Category;\n    --  Cc   Other, Control\n    --  Cf   Other, Format\n    --  Cn   Other, Not Assigned"}, {"sha": "e26d0c61365c65907230a12a692eeacf83246df5", "filename": "gcc/ada/g-regexp.ads", "status": "modified", "additions": 7, "deletions": 98, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fg-regexp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fg-regexp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-regexp.ads?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 1998-2005, AdaCore                     --\n+--                     Copyright (C) 1998-2007, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,6 +37,8 @@\n --  pattern matching algorithm, using a subset of the syntax of regular\n --  expressions copied from familiar Unix style utilities.\n \n+--  See file s-regexp.ads for full documentation of the interface\n+\n ------------------------------------------------------------\n -- Summary of Pattern Matching Packages in GNAT Hierarchy --\n ------------------------------------------------------------\n@@ -45,14 +47,14 @@\n --  the following is an outline of these packages, to help you determine\n --  which is best for your needs.\n \n---     GNAT.Regexp (files g-regexp.ads/g-regexp.adb)\n+--     GNAT.Regexp (files g-regexp.ads/s-regexp.ads/s-regexp.adb)\n --       This is a simple package providing Unix-style regular expression\n --       matching with the restriction that it matches entire strings. It\n --       is particularly useful for file name matching, and in particular\n --       it provides \"globbing patterns\" that are useful in implementing\n --       unix or DOS style wild card matching for file names.\n \n---     GNAT.Regpat (files g-regpat.ads/g-regpat.adb)\n+--     GNAT.Regpat (files g-regpat.ads/s-regpat.ads/g-regpat.adb)\n --       This is a more complete implementation of Unix-style regular\n --       expressions, copied from the original V7 style regular expression\n --       library written in C by Henry Spencer. It is functionally the\n@@ -65,99 +67,6 @@\n --       language is modeled on context free grammars, with context sensitive\n --       extensions that provide full (type 0) computational capabilities.\n \n-with Ada.Finalization;\n-\n-package GNAT.Regexp is\n-\n-   --  The regular expression must first be compiled, using the Compile\n-   --  function, which creates a finite state matching table, allowing\n-   --  very fast matching once the expression has been compiled.\n-\n-   --  The following is the form of a regular expression, expressed in Ada\n-   --  reference manual style BNF is as follows\n-\n-   --     regexp ::= term\n-\n-   --     regexp ::= term | term          -- alternation (term or term ...)\n-\n-   --     term ::= item\n-\n-   --     term ::= item item ...          -- concatenation (item then item)\n-\n-   --     item ::= elmt                   -- match elmt\n-   --     item ::= elmt *                 -- zero or more elmt's\n-   --     item ::= elmt +                 -- one or more elmt's\n-   --     item ::= elmt ?                 -- matches elmt or nothing\n-\n-   --     elmt ::= nchr                   -- matches given character\n-   --     elmt ::= [nchr nchr ...]        -- matches any character listed\n-   --     elmt ::= [^ nchr nchr ...]      -- matches any character not listed\n-   --     elmt ::= [char - char]          -- matches chars in given range\n-   --     elmt ::= .                      -- matches any single character\n-   --     elmt ::= ( regexp )             -- parens used for grouping\n-\n-   --     char ::= any character, including special characters\n-   --     nchr ::= any character except \\()[].*+?^ or \\char to match char\n-   --     ... is used to indication repetition (one or more terms)\n-\n-   --  See also regexp(1) man page on Unix systems for further details\n-\n-   --  A second kind of regular expressions is provided. This one is more\n-   --  like the wild card patterns used in file names by the Unix shell (or\n-   --  DOS prompt) command lines. The grammar is the following:\n-\n-   --     regexp ::= term\n-\n-   --     term   ::= elmt\n-\n-   --     term   ::= elmt elmt ...     -- concatenation (elmt then elmt)\n-   --     term   ::= *                 -- any string of 0 or more characters\n-   --     term   ::= ?                 -- matches any character\n-   --     term   ::= [char char ...]   -- matches any character listed\n-   --     term   ::= [char - char]     -- matches any character in given range\n-   --     term   ::= {elmt, elmt, ...} -- alternation (matches any of elmt)\n-\n-   --  Important note : This package was mainly intended to match regular\n-   --  expressions against file names. The whole string has to match the\n-   --  regular expression. If only a substring matches, then the function\n-   --  Match will return False.\n-\n-   type Regexp is private;\n-   --  Private type used to represent a regular expression\n-\n-   Error_In_Regexp : exception;\n-   --  Exception raised when an error is found in the regular expression\n-\n-   function Compile\n-     (Pattern        : String;\n-      Glob           : Boolean := False;\n-      Case_Sensitive : Boolean := True) return Regexp;\n-   --  Compiles a regular expression S. If the syntax of the given\n-   --  expression is invalid (does not match above grammar, Error_In_Regexp\n-   --  is raised. If Glob is True, the pattern is considered as a 'globbing\n-   --  pattern', that is a pattern as given by the second grammar above.\n-   --  As a special case, if Pattern is the empty string it will always\n-   --  match.\n-\n-   function Match (S : String; R : Regexp) return Boolean;\n-   --  True if S matches R, otherwise False. Raises Constraint_Error if\n-   --  R is an uninitialized regular expression value.\n-\n-private\n-   type Regexp_Value;\n-\n-   type Regexp_Access is access Regexp_Value;\n-\n-   type Regexp is new Ada.Finalization.Controlled with record\n-      R : Regexp_Access := null;\n-   end record;\n-\n-   pragma Finalize_Storage_Only (Regexp);\n-\n-   procedure Finalize (R : in out Regexp);\n-   --  Free the memory occupied by R\n-\n-   procedure Adjust (R : in out Regexp);\n-   --  Called after an assignment (do a copy of the Regexp_Access.all)\n+with System.Regexp;\n \n-end GNAT.Regexp;\n+package GNAT.Regexp renames System.Regexp;"}, {"sha": "46b46f40289d1526cea24a661399c94f054ac2f3", "filename": "gcc/ada/g-regpat.ads", "status": "modified", "additions": 7, "deletions": 590, "changes": 597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fg-regpat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fg-regpat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-regpat.ads?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -7,7 +7,7 @@\n --                                 S p e c                                  --\n --                                                                          --\n --               Copyright (C) 1986 by University of Toronto.               --\n---                     Copyright (C) 1996-2006, AdaCore                     --\n+--                     Copyright (C) 1996-2007, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,6 +40,8 @@\n --  interface has been considerably changed to use the Ada String type\n --  instead of C-style nul-terminated strings.\n \n+--  See file s-regpat.ads for full documentation of the interface\n+\n ------------------------------------------------------------\n -- Summary of Pattern Matching Packages in GNAT Hierarchy --\n ------------------------------------------------------------\n@@ -48,14 +50,14 @@\n --  the following is an outline of these packages, to help you determine\n --  which is best for your needs.\n \n---     GNAT.Regexp (files g-regexp.ads/g-regexp.adb)\n+--     GNAT.Regexp (files g-regexp.ads/s-regexp.ads/s-regexp.adb)\n --       This is a simple package providing Unix-style regular expression\n --       matching with the restriction that it matches entire strings. It\n --       is particularly useful for file name matching, and in particular\n --       it provides \"globbing patterns\" that are useful in implementing\n --       unix or DOS style wild card matching for file names.\n \n---     GNAT.Regpat (files g-regpat.ads/g-regpat.adb)\n+--     GNAT.Regpat (files g-regpat.ads/s-regpat.ads/s-regpat.adb)\n --       This is a more complete implementation of Unix-style regular\n --       expressions, copied from the Perl regular expression engine,\n --       written originally in C by Henry Spencer. It is functionally the\n@@ -67,591 +69,6 @@\n --       language is modeled on context free grammars, with context sensitive\n --       extensions that provide full (type 0) computational capabilities.\n \n-package GNAT.Regpat is\n-   pragma Preelaborate;\n-\n-   --  The grammar is the following:\n-\n-   --     regexp ::= expr\n-   --            ::= ^ expr               -- anchor at the beginning of string\n-   --            ::= expr $               -- anchor at the end of string\n-\n-   --     expr   ::= term\n-   --            ::= term | term          -- alternation (term or term ...)\n-\n-   --     term   ::= item\n-   --            ::= item item ...        -- concatenation (item then item)\n-\n-   --     item   ::= elmt                 -- match elmt\n-   --            ::= elmt *               -- zero or more elmt's\n-   --            ::= elmt +               -- one or more elmt's\n-   --            ::= elmt ?               -- matches elmt or nothing\n-   --            ::= elmt *?              -- zero or more times, minimum number\n-   --            ::= elmt +?              -- one or more times, minimum number\n-   --            ::= elmt ??              -- zero or one time, minimum number\n-   --            ::= elmt { num }         -- matches elmt exactly num times\n-   --            ::= elmt { num , }       -- matches elmt at least num times\n-   --            ::= elmt { num , num2 }  -- matches between num and num2 times\n-   --            ::= elmt { num }?        -- matches elmt exactly num times\n-   --            ::= elmt { num , }?      -- matches elmt at least num times\n-   --                                        non-greedy version\n-   --            ::= elmt { num , num2 }? -- matches between num and num2 times\n-   --                                        non-greedy version\n-\n-   --     elmt   ::= nchr                 -- matches given character\n-   --            ::= [range range ...]    -- matches any character listed\n-   --            ::= [^ range range ...]  -- matches any character not listed\n-   --            ::= .                    -- matches any single character\n-   --                                     -- except newlines\n-   --            ::= ( expr )             -- parens used for grouping\n-   --            ::= \\ num                -- reference to num-th parenthesis\n-\n-   --     range  ::= char - char          -- matches chars in given range\n-   --            ::= nchr\n-   --            ::= [: posix :]          -- any character in the POSIX range\n-   --            ::= [:^ posix :]         -- not in the POSIX range\n-\n-   --     posix  ::= alnum                -- alphanumeric characters\n-   --            ::= alpha                -- alphabetic characters\n-   --            ::= ascii                -- ascii characters (0 .. 127)\n-   --            ::= cntrl                -- control chars (0..31, 127..159)\n-   --            ::= digit                -- digits ('0' .. '9')\n-   --            ::= graph                -- graphic chars (32..126, 160..255)\n-   --            ::= lower                -- lower case characters\n-   --            ::= print                -- printable characters (32..127)\n-   --            ::= punct                -- printable, except alphanumeric\n-   --            ::= space                -- space characters\n-   --            ::= upper                -- upper case characters\n-   --            ::= word                 -- alphanumeric characters\n-   --            ::= xdigit               -- hexadecimal chars (0..9, a..f)\n-\n-   --     char   ::= any character, including special characters\n-   --                ASCII.NUL is not supported.\n-\n-   --     nchr   ::= any character except \\()[].*+?^ or \\char to match char\n-   --                \\n means a newline (ASCII.LF)\n-   --                \\t means a tab (ASCII.HT)\n-   --                \\r means a return (ASCII.CR)\n-   --                \\b matches the empty string at the beginning or end of a\n-   --                   word. A word is defined as a set of alphanumerical\n-   --                   characters (see \\w below).\n-   --                \\B matches the empty string only when *not* at the\n-   --                   beginning or end of a word.\n-   --                \\d matches any digit character ([0-9])\n-   --                \\D matches any non digit character ([^0-9])\n-   --                \\s matches any white space character. This is equivalent\n-   --                   to [ \\t\\n\\r\\f\\v]  (tab, form-feed, vertical-tab,...\n-   --                \\S matches any non-white space character.\n-   --                \\w matches any alphanumeric character or underscore.\n-   --                   This include accented letters, as defined in the\n-   --                   package Ada.Characters.Handling.\n-   --                \\W matches any non-alphanumeric character.\n-   --                \\A match the empty string only at the beginning of the\n-   --                   string, whatever flags are used for Compile (the\n-   --                   behavior of ^ can change, see Regexp_Flags below).\n-   --                \\G match the empty string only at the end of the\n-   --                   string, whatever flags are used for Compile (the\n-   --                   behavior of $ can change, see Regexp_Flags below).\n-   --     ...    ::= is used to indication repetition (one or more terms)\n-\n-   --  Embedded newlines are not matched by the ^ operator.\n-   --  It is possible to retrieve the substring matched a parenthesis\n-   --  expression. Although the depth of parenthesis is not limited in the\n-   --  regexp, only the first 9 substrings can be retrieved.\n-\n-   --  The highest value possible for the arguments to the curly operator ({})\n-   --  are given by the constant Max_Curly_Repeat below.\n-\n-   --  The operators '*', '+', '?' and '{}' always match the longest possible\n-   --  substring. They all have a non-greedy version (with an extra ? after the\n-   --  operator), which matches the shortest possible substring.\n-\n-   --  For instance:\n-   --      regexp=\"<.*>\"   string=\"<h1>title</h1>\"   matches=\"<h1>title</h1>\"\n-   --      regexp=\"<.*?>\"  string=\"<h1>title</h1>\"   matches=\"<h1>\"\n-   --\n-   --  '{' and '}' are only considered as special characters if they appear\n-   --  in a substring that looks exactly like '{n}', '{n,m}' or '{n,}', where\n-   --  n and m are digits. No space is allowed. In other contexts, the curly\n-   --  braces will simply be treated as normal characters.\n-\n-   --  Compiling Regular Expressions\n-   --  =============================\n-\n-   --  To use this package, you first need to compile the regular expression\n-   --  (a string) into a byte-code program, in a Pattern_Matcher structure.\n-   --  This first step checks that the regexp is valid, and optimizes the\n-   --  matching algorithms of the second step.\n-\n-   --  Two versions of the Compile subprogram are given: one in which this\n-   --  package will compute itself the best possible size to allocate for the\n-   --  byte code; the other where you must allocate enough memory yourself. An\n-   --  exception is raised if there is not enough memory.\n-\n-   --     declare\n-   --        Regexp : String := \"a|b\";\n-\n-   --        Matcher : Pattern_Matcher := Compile (Regexp);\n-   --        --  The size for matcher is automatically allocated\n-\n-   --        Matcher2 : Pattern_Matcher (1000);\n-   --        --  Some space is allocated directly.\n-\n-   --     begin\n-   --        Compile (Matcher2, Regexp);\n-   --        ...\n-   --     end;\n-\n-   --  Note that the second version is significantly faster, since with the\n-   --  first version the regular expression has in fact to be compiled twice\n-   --  (first to compute the size, then to generate the byte code).\n-\n-   --  Note also that you cannot use the function version of Compile if you\n-   --  specify the size of the Pattern_Matcher, since the discriminants will\n-   --  most probably be different and you will get a Constraint_Error\n-\n-   --  Matching Strings\n-   --  ================\n-\n-   --  Once the regular expression has been compiled, you can use it as often\n-   --  as needed to match strings.\n-\n-   --  Several versions of the Match subprogram are provided, with different\n-   --  parameters and return results.\n-\n-   --  See the description under each of these subprograms\n-\n-   --  Here is a short example showing how to get the substring matched by\n-   --  the first parenthesis pair.\n-\n-   --     declare\n-   --        Matches : Match_Array (0 .. 1);\n-   --        Regexp  : String := \"a(b|c)d\";\n-   --        Str     : String := \"gacdg\";\n-\n-   --     begin\n-   --        Match (Compile (Regexp), Str, Matches);\n-   --        return Str (Matches (1).First .. Matches (1).Last);\n-   --        --  returns 'c'\n-   --     end;\n-\n-   --  Finding all occurrences\n-   --  =======================\n-\n-   --  Finding all the occurrences of a regular expression in a string cannot\n-   --  be done by simply passing a slice of the string. This wouldn't work for\n-   --  anchored regular expressions (the ones starting with \"^\" or ending with\n-   --  \"$\").\n-   --  Instead, you need to use the last parameter to Match (Data_First), as in\n-   --  the following loop:\n-\n-   --     declare\n-   --        Str     : String :=\n-   --           \"-- first line\" & ASCII.LF & \"-- second line\";\n-   --        Matches : Match_array (0 .. 0);\n-   --        Regexp  : Pattern_Matcher := Compile (\"^--\", Multiple_Lines);\n-   --        Current : Natural := Str'First;\n-   --     begin\n-   --        loop\n-   --           Match (Regexp, Str, Matches, Current);\n-   --           exit when Matches (0) = No_Match;\n-   --\n-   --           --  Process the match at position Matches (0).First\n-   --\n-   --           Current := Matches (0).Last + 1;\n-   --        end loop;\n-   --     end;\n-\n-   --  String Substitution\n-   --  ===================\n-\n-   --  No subprogram is currently provided for string substitution.\n-   --  However, this is easy to simulate with the parenthesis groups, as\n-   --  shown below.\n-\n-   --  This example swaps the first two words of the string:\n-\n-   --     declare\n-   --        Regexp  : String := \"([a-z]+) +([a-z]+)\";\n-   --        Str     : String := \" first   second third \";\n-   --        Matches : Match_Array (0 .. 2);\n-\n-   --     begin\n-   --        Match (Compile (Regexp), Str, Matches);\n-   --        return Str (Str'First .. Matches (1).First - 1)\n-   --               & Str (Matches (2).First .. Matches (2).Last)\n-   --               & \" \"\n-   --               & Str (Matches (1).First .. Matches (1).Last)\n-   --               & Str (Matches (2).Last + 1 .. Str'Last);\n-   --        --  returns \" second first third \"\n-   --     end;\n-\n-   ---------------\n-   -- Constants --\n-   ---------------\n-\n-   Expression_Error : exception;\n-   --  This exception is raised when trying to compile an invalid regular\n-   --  expression. All subprograms taking an expression as parameter may raise\n-   --  Expression_Error.\n-\n-   Max_Paren_Count : constant := 255;\n-   --  Maximum number of parenthesis in a regular expression. This is limited\n-   --  by the size of a Character, as found in the byte-compiled version of\n-   --  regular expressions.\n-\n-   Max_Curly_Repeat : constant := 32767;\n-   --  Maximum number of repetition for the curly operator. The digits in the\n-   --  {n}, {n,} and {n,m } operators cannot be higher than this constant,\n-   --  since they have to fit on two characters in the byte-compiled version of\n-   --  regular expressions.\n-\n-   Max_Program_Size : constant := 2**15 - 1;\n-   --  Maximum size that can be allocated for a program\n-\n-   type Program_Size is range 0 .. Max_Program_Size;\n-   for Program_Size'Size use 16;\n-   --  Number of bytes allocated for the byte-compiled version of a regular\n-   --  expression. The size required depends on the complexity of the regular\n-   --  expression in a complex manner that is undocumented (other than in the\n-   --  body of the Compile procedure). Normally the size is automatically set\n-   --  and the programmer need not be concerned about it. There are two\n-   --  exceptions to this. First in the calls to Match, it is possible to\n-   --  specify a non-zero size that is known to be large enough. This can\n-   --  slightly increase the efficiency by avoiding a copy. Second, in the case\n-   --  of calling compile, it is possible using the procedural form of Compile\n-   --  to use a single Pattern_Matcher variable for several different\n-   --  expressions by setting its size sufficiently large.\n-\n-   Auto_Size : constant := 0;\n-   --  Used in calls to Match to indicate that the Size should be set to\n-   --  a value appropriate to the expression being used automatically.\n-\n-   type Regexp_Flags is mod 256;\n-   for Regexp_Flags'Size use 8;\n-   --  Flags that can be given at compile time to specify default\n-   --  properties for the regular expression.\n-\n-   No_Flags         : constant Regexp_Flags;\n-   Case_Insensitive : constant Regexp_Flags;\n-   --  The automaton is optimized so that the matching is done in a case\n-   --  insensitive manner (upper case characters and lower case characters\n-   --  are all treated the same way).\n-\n-   Single_Line      : constant Regexp_Flags;\n-   --  Treat the Data we are matching as a single line. This means that\n-   --  ^ and $ will ignore \\n (unless Multiple_Lines is also specified),\n-   --  and that '.' will match \\n.\n-\n-   Multiple_Lines   : constant Regexp_Flags;\n-   --  Treat the Data as multiple lines. This means that ^ and $ will also\n-   --  match on internal newlines (ASCII.LF), in addition to the beginning\n-   --  and end of the string.\n-   --\n-   --  This can be combined with Single_Line.\n-\n-   -----------------\n-   -- Match_Array --\n-   -----------------\n-\n-   subtype Match_Count is Natural range 0 .. Max_Paren_Count;\n-\n-   type Match_Location is record\n-      First : Natural := 0;\n-      Last  : Natural := 0;\n-   end record;\n-\n-   type Match_Array is array (Match_Count range <>) of Match_Location;\n-   --  The substring matching a given pair of parenthesis. Index 0 is the whole\n-   --  substring that matched the full regular expression.\n-   --\n-   --  For instance, if your regular expression is something like: \"a(b*)(c+)\",\n-   --  then Match_Array(1) will be the indexes of the substring that matched\n-   --  \"b*\" and Match_Array(2) will be the substring that matched \"c+\".\n-   --\n-   --  The number of parenthesis groups that can be retrieved is unlimited, and\n-   --  all the Match subprograms below can use a Match_Array of any size.\n-   --  Indexes that do not have any matching parenthesis are set to No_Match.\n-\n-   No_Match : constant Match_Location := (First => 0, Last => 0);\n-   --  The No_Match constant is (0, 0) to differentiate between matching a null\n-   --  string at position 1, which uses (1, 0) and no match at all.\n-\n-   ---------------------------------\n-   -- Pattern_Matcher Compilation --\n-   ---------------------------------\n-\n-   --  The subprograms here are used to precompile regular expressions for use\n-   --  in subsequent Match calls. Precompilation improves efficiency if the\n-   --  same regular expression is to be used in more than one Match call.\n-\n-   type Pattern_Matcher (Size : Program_Size) is private;\n-   --  Type used to represent a regular expression compiled into byte code\n-\n-   Never_Match : constant Pattern_Matcher;\n-   --  A regular expression that never matches anything\n-\n-   function Compile\n-     (Expression : String;\n-      Flags      : Regexp_Flags := No_Flags) return Pattern_Matcher;\n-   --  Compile a regular expression into internal code\n-   --\n-   --  Raises Expression_Error if Expression is not a legal regular expression\n-   --\n-   --  The appropriate size is calculated automatically to correspond to the\n-   --  provided expression. This is the normal default method of compilation.\n-   --  Note that it is generally not possible to assign the result of two\n-   --  different calls to this Compile function to the same Pattern_Matcher\n-   --  variable, since the sizes will differ.\n-   --\n-   --  Flags is the default value to use to set properties for Expression\n-   --  (e.g. case sensitivity,...).\n-\n-   procedure Compile\n-     (Matcher         : out Pattern_Matcher;\n-      Expression      : String;\n-      Final_Code_Size : out Program_Size;\n-      Flags           : Regexp_Flags := No_Flags);\n-   --  Compile a regular expression into into internal code\n-\n-   --  This procedure is significantly faster than the Compile function since\n-   --  it avoids the extra step of precomputing the required size.\n-   --\n-   --  However, it requires the user to provide a Pattern_Matcher variable\n-   --  whose size is preset to a large enough value. One advantage of this\n-   --  approach, in addition to the improved efficiency, is that the same\n-   --  Pattern_Matcher variable can be used to hold the compiled code for\n-   --  several different regular expressions by setting a size that is large\n-   --  enough to accomodate all possibilities.\n-   --\n-   --  In this version of the procedure call, the actual required code size is\n-   --  returned. Also if Matcher.Size is zero on entry, then the resulting code\n-   --  is not stored. A call with Matcher.Size set to Auto_Size can thus be\n-   --  used to determine the space required for compiling the given regular\n-   --  expression.\n-   --\n-   --  This function raises Storage_Error if Matcher is too small to hold\n-   --  the resulting code (i.e. Matcher.Size has too small a value).\n-   --\n-   --  Expression_Error is raised if the string Expression does not contain\n-   --  a valid regular expression.\n-   --\n-   --  Flags is the default value to use to set properties for Expression (case\n-   --  sensitivity,...).\n-\n-   procedure Compile\n-     (Matcher    : out Pattern_Matcher;\n-      Expression : String;\n-      Flags      : Regexp_Flags := No_Flags);\n---     --  Same procedure as above, expect it does not return the final\n---     --  program size, and Matcher.Size cannot be Auto_Size.\n-\n-   function Paren_Count (Regexp : Pattern_Matcher) return Match_Count;\n-   pragma Inline (Paren_Count);\n-   --  Return the number of parenthesis pairs in Regexp.\n-   --\n-   --  This is the maximum index that will be filled if a Match_Array is\n-   --  used as an argument to Match.\n-   --\n-   --  Thus, if you want to be sure to get all the parenthesis, you should\n-   --  do something like:\n-   --\n-   --     declare\n-   --        Regexp  : Pattern_Matcher := Compile (\"a(b*)(c+)\");\n-   --        Matched : Match_Array (0 .. Paren_Count (Regexp));\n-   --     begin\n-   --        Match (Regexp, \"a string\", Matched);\n-   --     end;\n-\n-   -------------\n-   -- Quoting --\n-   -------------\n-\n-   function Quote (Str : String) return String;\n-   --  Return a version of Str so that every special character is quoted.\n-   --  The resulting string can be used in a regular expression to match\n-   --  exactly Str, whatever character was present in Str.\n-\n-   --------------\n-   -- Matching --\n-   --------------\n-\n-   --  The Match subprograms are given a regular expression in string\n-   --  form, and perform the corresponding match. The following parameters\n-   --  are present in all forms of the Match call.\n-\n-   --    Expression contains the regular expression to be matched as a string\n-\n-   --    Data contains the string to be matched\n-\n-   --    Data_First is the lower bound for the match, i.e. Data (Data_First)\n-   --    will be the first character to be examined. If Data_First is set to\n-   --    the special value of -1 (the default), then the first character to\n-   --    be examined is Data (Data_First). However, the regular expression\n-   --    character ^ (start of string) still refers to the first character\n-   --    of the full string (Data (Data'First)), which is why there is a\n-   --    separate mechanism for specifying Data_First.\n-\n-   --    Data_Last is the upper bound for the match, i.e. Data (Data_Last)\n-   --    will be the last character to be examined. If Data_Last is set to\n-   --    the special value of Positive'Last (the default), then the last\n-   --    character to be examined is Data (Data_Last). However, the regular\n-   --    expression character $ (end of string) still refers to the last\n-   --    character of the full string (Data (Data'Last)), which is why there\n-   --    is a separate mechanism for specifying Data_Last.\n-\n-   --    Note: the use of Data_First and Data_Last is not equivalent to\n-   --    simply passing a slice as Expression because of the handling of\n-   --    regular expression characters ^ and $.\n-\n-   --    Size is the size allocated for the compiled byte code. Normally\n-   --    this is defaulted to Auto_Size which means that the appropriate\n-   --    size is allocated automatically. It is possible to specify an\n-   --    explicit size, which must be sufficiently large. This slightly\n-   --    increases the efficiency by avoiding the extra step of computing\n-   --    the appropriate size.\n-\n-   --  The following exceptions can be raised in calls to Match\n-   --\n-   --    Storage_Error is raised if a non-zero value is given for Size\n-   --    and it is too small to hold the compiled byte code.\n-   --\n-   --    Expression_Error is raised if the given expression is not a legal\n-   --    regular expression.\n-\n-   procedure Match\n-     (Expression : String;\n-      Data       : String;\n-      Matches    : out Match_Array;\n-      Size       : Program_Size := Auto_Size;\n-      Data_First : Integer      := -1;\n-      Data_Last  : Positive     := Positive'Last);\n-   --  This version returns the result of the match stored in Match_Array.\n-   --  At most Matches'Length parenthesis are returned.\n-\n-   function Match\n-     (Expression : String;\n-      Data       : String;\n-      Size       : Program_Size := Auto_Size;\n-      Data_First : Integer      := -1;\n-      Data_Last  : Positive     := Positive'Last) return Natural;\n-   --  This version returns the position where Data matches, or if there is\n-   --  no match, then the value Data'First - 1.\n-\n-   function Match\n-     (Expression : String;\n-      Data       : String;\n-      Size       : Program_Size := Auto_Size;\n-      Data_First : Integer      := -1;\n-      Data_Last  : Positive     := Positive'Last) return Boolean;\n-   --  This version returns True if the match succeeds, False otherwise\n-\n-   ------------------------------------------------\n-   -- Matching a Pre-Compiled Regular Expression --\n-   ------------------------------------------------\n-\n-   --  The following functions are significantly faster if you need to reuse\n-   --  the same regular expression multiple times, since you only have to\n-   --  compile it once. For these functions you must first compile the\n-   --  expression with a call to Compile as previously described.\n-\n-   --  The parameters Data, Data_First and Data_Last are as described\n-   --  in the previous section.\n-\n-   function  Match\n-     (Self       : Pattern_Matcher;\n-      Data       : String;\n-      Data_First : Integer  := -1;\n-      Data_Last  : Positive := Positive'Last) return Natural;\n-   --  Match Data using the given pattern matcher. Returns the position\n-   --  where Data matches, or (Data'First - 1) if there is no match.\n-\n-   function  Match\n-     (Self       : Pattern_Matcher;\n-      Data       : String;\n-      Data_First : Integer  := -1;\n-      Data_Last  : Positive := Positive'Last) return Boolean;\n-   --  Return True if Data matches using the given pattern matcher\n-\n-   pragma Inline (Match);\n-   --  All except the last one below\n-\n-   procedure Match\n-     (Self       : Pattern_Matcher;\n-      Data       : String;\n-      Matches    : out Match_Array;\n-      Data_First : Integer  := -1;\n-      Data_Last  : Positive := Positive'Last);\n-   --  Match Data using the given pattern matcher and store result in Matches.\n-   --  The expression matches if Matches (0) /= No_Match. The lower bound of\n-   --  Matches is required to be zero.\n-   --\n-   --  At most Matches'Length parenthesis are returned\n-\n-   -----------\n-   -- Debug --\n-   -----------\n-\n-   procedure Dump (Self : Pattern_Matcher);\n-   --  Dump the compiled version of the regular expression matched by Self\n-\n---------------------------\n--- Private Declarations --\n---------------------------\n-\n-private\n-\n-   subtype Pointer is Program_Size;\n-   --  The Pointer type is used to point into Program_Data\n-\n-   --  Note that the pointer type is not necessarily 2 bytes\n-   --  although it is stored in the program using 2 bytes\n-\n-   type Program_Data is array (Pointer range <>) of Character;\n-\n-   Program_First : constant := 1;\n-\n-   --  The \"internal use only\" fields in regexp are present to pass info from\n-   --  compile to execute that permits the execute phase to run lots faster on\n-   --  simple cases. They are:\n-\n-   --     First              character that must begin a match or ASCII.Nul\n-   --     Anchored           true iff match must start at beginning of line\n-   --     Must_Have          pointer to string that match must include or null\n-   --     Must_Have_Length   length of Must_Have string\n-\n-   --  First and Anchored permit very fast decisions on suitable starting\n-   --  points for a match, cutting down the work a lot. Must_Have permits fast\n-   --  rejection of lines that cannot possibly match.\n-\n-   --  The Must_Have tests are costly enough that Optimize supplies a Must_Have\n-   --  only if the r.e. contains something potentially expensive (at present,\n-   --  the only such thing detected is * or at the start of the r.e., which can\n-   --  involve a lot of backup). The length is supplied because the test in\n-   --  Execute needs it and Optimize is computing it anyway.\n-\n-   --  The initialization is meant to fail-safe in case the user of this\n-   --  package tries to use an uninitialized matcher. This takes advantage\n-   --  of the knowledge that ASCII.Nul translates to the end-of-program (EOP)\n-   --  instruction code of the state machine.\n-\n-   No_Flags         : constant Regexp_Flags := 0;\n-   Case_Insensitive : constant Regexp_Flags := 1;\n-   Single_Line      : constant Regexp_Flags := 2;\n-   Multiple_Lines   : constant Regexp_Flags := 4;\n-\n-   type Pattern_Matcher (Size : Pointer) is record\n-      First            : Character    := ASCII.NUL;  --  internal use only\n-      Anchored         : Boolean      := False;      --  internal use only\n-      Must_Have        : Pointer      := 0;          --  internal use only\n-      Must_Have_Length : Natural      := 0;          --  internal use only\n-      Paren_Count      : Natural      := 0;          --  # paren groups\n-      Flags            : Regexp_Flags := No_Flags;\n-      Program          : Program_Data (Program_First .. Size) :=\n-                           (others => ASCII.NUL);\n-   end record;\n-\n-   Never_Match : constant Pattern_Matcher :=\n-      (0, ASCII.NUL, False, 0, 0, 0, No_Flags, (others => ASCII.NUL));\n+with System.Regpat;\n \n-end GNAT.Regpat;\n+package GNAT.Regpat renames System.Regpat;"}, {"sha": "cd4fa8c6161122ff6143425bd7cc18316ffadf86", "filename": "gcc/ada/g-tasloc.adb", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fg-tasloc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fg-tasloc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-tasloc.adb?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 1997-2005, AdaCore                     --\n+--                     Copyright (C) 1997-2007, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,27 +31,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Soft_Links;\n---  used for Lock_Task, Unlock_Task\n+--  This package does not require a body, since it is a package renaming. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not intefere.\n \n-package body GNAT.Task_Lock is\n-\n-   ----------\n-   -- Lock --\n-   ----------\n-\n-   procedure Lock is\n-   begin\n-      System.Soft_Links.Lock_Task.all;\n-   end Lock;\n-\n-   ------------\n-   -- Unlock --\n-   ------------\n-\n-   procedure Unlock is\n-   begin\n-      System.Soft_Links.Unlock_Task.all;\n-   end Unlock;\n-\n-end GNAT.Task_Lock;\n+pragma No_Body;"}, {"sha": "ce49667c8b161365fa896293053b57f208a74936", "filename": "gcc/ada/g-tasloc.ads", "status": "modified", "additions": 4, "deletions": 52, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fg-tasloc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fg-tasloc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-tasloc.ads?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 1998-2005, AdaCore                     --\n+--                     Copyright (C) 1998-2007, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,56 +41,8 @@\n --  These routines may be used in a non-tasking program, and in that case\n --  they have no effect (they do NOT cause the tasking runtime to be loaded).\n \n-package GNAT.Task_Lock is\n-   pragma Elaborate_Body;\n+--  See file s-tasloc.ads for full documentation of the interface\n \n-   procedure Lock;\n-   pragma Inline (Lock);\n-   --  Acquires the global lock, starts the execution of a critical region\n-   --  which no other task can enter until the locking task calls Unlock\n+with System.Task_Lock;\n \n-   procedure Unlock;\n-   pragma Inline (Unlock);\n-   --  Releases the global lock, allowing another task to successfully\n-   --  complete a Lock operation. Terminates the critical region.\n-   --\n-   --  The recommended protocol for using these two procedures is as\n-   --  follows:\n-   --\n-   --    Locked_Processing : begin\n-   --       Lock;\n-   --       ...\n-   --       TSL.Unlock;\n-   --\n-   --    exception\n-   --       when others =>\n-   --          Unlock;\n-   --          raise;\n-   --    end Locked_Processing;\n-   --\n-   --  This ensures that the lock is not left set if an exception is raised\n-   --  explicitly or implicitly during the critical locked region.\n-   --\n-   --  Note on multiple calls to Lock: It is permissible to call Lock\n-   --  more than once with no intervening Unlock from a single task,\n-   --  and the lock will not be released until the corresponding number\n-   --  of Unlock operations has been performed. For example:\n-   --\n-   --    GNAT.Task_Lock.Lock;     -- acquires lock\n-   --    GNAT.Task_Lock.Lock;     -- no effect\n-   --    GNAT.Task_Lock.Lock;     -- no effect\n-   --    GNAT.Task_Lock.Unlock;   -- no effect\n-   --    GNAT.Task_Lock.Unlock;   -- no effect\n-   --    GNAT.Task_Lock.Unlock;   -- releases lock\n-   --\n-   --  However, as previously noted, the Task_Lock facility should only\n-   --  be used for very local locks where the probability of conflict is\n-   --  low, so usually this kind of nesting is not a good idea in any case.\n-   --  In more complex locking situations, it is more appropriate to define\n-   --  an appropriate protected type to provide the required locking.\n-   --\n-   --  It is an error to call Unlock when there has been no prior call to\n-   --  Lock. The effect of such an erroneous call is undefined, and may\n-   --  result in deadlock, or other malfunction of the run-time system.\n-\n-end GNAT.Task_Lock;\n+package GNAT.Task_Lock renames System.Task_Lock;"}, {"sha": "5731c04fdc9753328dee7a97997b249a1ac80cb0", "filename": "gcc/ada/g-utf_32.adb", "status": "modified", "additions": 5, "deletions": 5273, "changes": 5278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fg-utf_32.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fg-utf_32.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-utf_32.adb?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce"}, {"sha": "f926f48cce1ef04db39ef895daac19f80a6a653d", "filename": "gcc/ada/g-utf_32.ads", "status": "modified", "additions": 4, "deletions": 151, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fg-utf_32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fg-utf_32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-utf_32.ads?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2005 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2005-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,155 +42,8 @@\n --  and also serves as the basis for Ada.Wide_Wide_Characters.Unicode and\n --  Ada.Wide_Characters.Unicode, which can also be used directly.\n \n-package GNAT.UTF_32 is\n+--  See file s-utf_32.ads for full documentation of the interface\n \n-   type UTF_32 is range 0 .. 16#7FFF_FFFF#;\n-   --  So far, the only defined character codes are in 0 .. 16#01_FFFF#\n+with System.UTF_32;\n \n-   --  The following type defines the categories from the unicode definitions.\n-   --  The one addition we make is Fe, which represents the characters FFFE\n-   --  and FFFF in any of the planes.\n-\n-   type Category is (\n-     Cc,   --  Other, Control\n-     Cf,   --  Other, Format\n-     Cn,   --  Other, Not Assigned\n-     Co,   --  Other, Private Use\n-     Cs,   --  Other, Surrogate\n-     Ll,   --  Letter, Lowercase\n-     Lm,   --  Letter, Modifier\n-     Lo,   --  Letter, Other\n-     Lt,   --  Letter, Titlecase\n-     Lu,   --  Letter, Uppercase\n-     Mc,   --  Mark, Spacing Combining\n-     Me,   --  Mark, Enclosing\n-     Mn,   --  Mark, Nonspacing\n-     Nd,   --  Number, Decimal Digit\n-     Nl,   --  Number, Letter\n-     No,   --  Number, Other\n-     Pc,   --  Punctuation, Connector\n-     Pd,   --  Punctuation, Dash\n-     Pe,   --  Punctuation, Close\n-     Pf,   --  Punctuation, Final quote\n-     Pi,   --  Punctuation, Initial quote\n-     Po,   --  Punctuation, Other\n-     Ps,   --  Punctuation, Open\n-     Sc,   --  Symbol, Currency\n-     Sk,   --  Symbol, Modifier\n-     Sm,   --  Symbol, Math\n-     So,   --  Symbol, Other\n-     Zl,   --  Separator, Line\n-     Zp,   --  Separator, Paragraph\n-     Zs,   --  Separator, Space\n-     Fe);  --  relative position FFFE/FFFF in any plane\n-\n-   function Get_Category (U : UTF_32) return Category;\n-   --  Given a UTF32 code, returns corresponding Category, or Cn if\n-   --  the code does not have an assigned unicode category.\n-\n-   --  The following functions perform category tests corresponding to lexical\n-   --  classes defined in the Ada standard. There are two interfaces for each\n-   --  function. The second takes a Category (e.g. returned by Get_Category).\n-   --  The first takes a UTF_32 code. The form taking the UTF_32 code is\n-   --  typically more efficient than calling Get_Category, but if several\n-   --  different tests are to be performed on the same code, it is more\n-   --  efficient to use Get_Category to get the category, then test the\n-   --  resulting category.\n-\n-   function Is_UTF_32_Letter (U : UTF_32)   return Boolean;\n-   function Is_UTF_32_Letter (C : Category) return Boolean;\n-   pragma Inline (Is_UTF_32_Letter);\n-   --  Returns true iff U is a letter that can be used to start an identifier,\n-   --  or if C is one of the corresponding categories, which are the following:\n-   --    Letter, Uppercase (Lu)\n-   --    Letter, Lowercase (Ll)\n-   --    Letter, Titlecase (Lt)\n-   --    Letter, Modifier  (Lm)\n-   --    Letter, Other     (Lo)\n-   --    Number, Letter    (Nl)\n-\n-   function Is_UTF_32_Digit (U : UTF_32)   return Boolean;\n-   function Is_UTF_32_Digit (C : Category) return Boolean;\n-   pragma Inline (Is_UTF_32_Digit);\n-   --  Returns true iff U is a digit that can be used to extend an identifer,\n-   --  or if C is one of the corresponding categories, which are the following:\n-   --    Number, Decimal_Digit (Nd)\n-\n-   function Is_UTF_32_Line_Terminator (U : UTF_32)   return Boolean;\n-   pragma Inline (Is_UTF_32_Line_Terminator);\n-   --  Returns true iff U is an allowed line terminator for source programs,\n-   --  if U is in the category Zp (Separator, Paragaph), or Zs (Separator,\n-   --  Line), or if U is a conventional line terminator (CR, LF, VT, FF).\n-   --  There is no category version for this function, since the set of\n-   --  characters does not correspond to a set of Unicode categories.\n-\n-   function Is_UTF_32_Mark (U : UTF_32)   return Boolean;\n-   function Is_UTF_32_Mark (C : Category) return Boolean;\n-   pragma Inline (Is_UTF_32_Mark);\n-   --  Returns true iff U is a mark character which can be used to extend an\n-   --  identifier, or if C is one of the corresponding categories, which are\n-   --  the following:\n-   --    Mark, Non-Spacing (Mn)\n-   --    Mark, Spacing Combining (Mc)\n-\n-   function Is_UTF_32_Other (U : UTF_32)   return Boolean;\n-   function Is_UTF_32_Other (C : Category) return Boolean;\n-   pragma Inline (Is_UTF_32_Other);\n-   --  Returns true iff U is an other format character, which means that it\n-   --  can be used to extend an identifier, but is ignored for the purposes of\n-   --  matching of identiers, or if C is one of the corresponding categories,\n-   --  which are the following:\n-   --    Other, Format (Cf)\n-\n-   function Is_UTF_32_Punctuation (U : UTF_32)   return Boolean;\n-   function Is_UTF_32_Punctuation (C : Category) return Boolean;\n-   pragma Inline (Is_UTF_32_Punctuation);\n-   --  Returns true iff U is a punctuation character that can be used to\n-   --  separate pices of an identifier, or if C is one of the corresponding\n-   --  categories, which are the following:\n-   --    Punctuation, Connector (Pc)\n-\n-   function Is_UTF_32_Space (U : UTF_32)   return Boolean;\n-   function Is_UTF_32_Space (C : Category) return Boolean;\n-   pragma Inline (Is_UTF_32_Space);\n-   --  Returns true iff U is considered a space to be ignored, or if C is one\n-   --  of the corresponding categories, which are the following:\n-   --    Separator, Space (Zs)\n-\n-   function Is_UTF_32_Non_Graphic (U : UTF_32)   return Boolean;\n-   function Is_UTF_32_Non_Graphic (C : Category) return Boolean;\n-   pragma Inline (Is_UTF_32_Non_Graphic);\n-   --  Returns true iff U is considered to be a non-graphic character, or if C\n-   --  is one of the corresponding categories, which are the following:\n-   --    Other, Control (Cc)\n-   --    Other, Private Use (Co)\n-   --    Other, Surrogate (Cs)\n-   --    Separator, Line (Zl)\n-   --    Separator, Paragraph (Zp)\n-   --    FFFE or FFFF positions in any plane (Fe)\n-   --\n-   --  Note that the Ada category format effector is subsumed by the above\n-   --  list of Unicode categories.\n-   --\n-   --  Note that Other, Unassiged (Cn) is quite deliberately not included\n-   --  in the list of categories above. This means that should any of these\n-   --  code positions be defined in future with graphic characters they will\n-   --  be allowed without a need to change implementations or the standard.\n-   --\n-   --  Note that Other, Format (Cf) is also quite deliberately not included\n-   --  in the list of categories above. This means that these characters can\n-   --  be included in character and string literals.\n-\n-   --  The following function is used to fold to upper case, as required by\n-   --  the Ada 2005 standard rules for identifier case folding. Two\n-   --  identifiers are equivalent if they are identical after folding all\n-   --  letters to upper case using this routine.\n-\n-   function UTF_32_To_Upper_Case (U : UTF_32) return UTF_32;\n-   pragma Inline (UTF_32_To_Upper_Case);\n-   --  If U represents a lower case letter, returns the corresponding upper\n-   --  case letter, otherwise U is returned unchanged. The folding is locale\n-   --  independent as defined by documents referenced in the note in section\n-   --  1 of ISO/IEC 10646:2003\n-\n-end GNAT.UTF_32;\n+package GNAT.UTF_32 renames System.UTF_32;"}, {"sha": "3becc8809000c8e69be69d8ed78aa40915b5c85f", "filename": "gcc/ada/gnatfind.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fgnatfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fgnatfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatfind.adb?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---         Copyright (C) 1998-2005 Free Software Foundation, Inc.           --\n+--          Copyright (C) 1998-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,8 +34,10 @@ with Opt;\n \n with Ada.Strings.Fixed; use Ada.Strings.Fixed;\n with Ada.Text_IO;       use Ada.Text_IO;\n+\n with GNAT.Command_Line; use GNAT.Command_Line;\n-with GNAT.Strings;      use GNAT.Strings;\n+\n+with System.Strings;    use System.Strings;\n \n --------------\n -- Gnatfind --"}, {"sha": "840587dfd28d927ddd4cce56510c633144b0c5df", "filename": "gcc/ada/gnatxref.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fgnatxref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fgnatxref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatxref.adb?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1998-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,8 +34,10 @@ with Opt;\n \n with Ada.Strings.Fixed; use Ada.Strings.Fixed;\n with Ada.Text_IO;       use Ada.Text_IO;\n+\n with GNAT.Command_Line; use GNAT.Command_Line;\n-with GNAT.Strings;      use GNAT.Strings;\n+\n+with System.Strings;    use System.Strings;\n \n procedure Gnatxref is\n    Search_Unused   : Boolean := False;"}, {"sha": "a951b5a5a54414d8cc397f926abb88a6ce12f541", "filename": "gcc/ada/gprep.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fgprep.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fgprep.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgprep.adb?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2002-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2002-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,10 +40,12 @@ with Stringt;  use Stringt;\n with Types;    use Types;\n \n with Ada.Text_IO;               use Ada.Text_IO;\n+\n with GNAT.Case_Util;            use GNAT.Case_Util;\n with GNAT.Command_Line;\n with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n-with GNAT.OS_Lib;               use GNAT.OS_Lib;\n+\n+with System.OS_Lib;             use System.OS_Lib;\n \n package body GPrep is\n "}, {"sha": "a67f87ba9df41ba265e1ac6a8aaa66cbaec63da1", "filename": "gcc/ada/indepsw.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Findepsw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Findepsw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Findepsw.ads?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,7 +36,7 @@\n --  Used to convert GNAT switches to their platform-dependent switch\n --  equivalent for the underlying linker.\n \n-with GNAT.OS_Lib; use GNAT.OS_Lib;\n+with System.OS_Lib; use System.OS_Lib;\n \n package Indepsw is\n "}, {"sha": "b606ccc8a8b2d7a77dbb1941c5b9a62a942545ad", "filename": "gcc/ada/output.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Foutput.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Foutput.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Foutput.adb?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,7 +31,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with GNAT.OS_Lib; use GNAT.OS_Lib;\n+with System.OS_Lib; use System.OS_Lib;\n \n package body Output is\n "}, {"sha": "e30a9b8de308571a58dafa10b909235787261513", "filename": "gcc/ada/s-gloloc-mingw.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-gloloc-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-gloloc-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gloloc-mingw.adb?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 1999-2006, AdaCore                     --\n+--                     Copyright (C) 1999-2007, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,14 +33,14 @@\n \n --  This implementation is specific to NT\n \n-with GNAT.Task_Lock;\n+with System.Task_Lock;\n \n with Interfaces.C.Strings;\n with System.OS_Interface;\n \n package body System.Global_Locks is\n \n-   package TSL renames GNAT.Task_Lock;\n+   package TSL renames System.Task_Lock;\n    package OSI renames System.OS_Interface;\n    package ICS renames Interfaces.C.Strings;\n "}, {"sha": "9649e1f63c32a024b3a860a19caa2a79bbe47328", "filename": "gcc/ada/s-os_lib.adb", "status": "added", "additions": 2574, "deletions": 0, "changes": 2574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-os_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-os_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-os_lib.adb?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -0,0 +1,2574 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                        S Y S T E M . O S _ L I B                         --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 1995-2007, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Case_Util;\n+with System.CRTL;\n+with System.Soft_Links;\n+with Ada.Unchecked_Conversion;\n+with Ada.Unchecked_Deallocation;\n+with System; use System;\n+\n+package body System.OS_Lib is\n+\n+   --  Imported procedures Dup and Dup2 are used in procedures Spawn and\n+   --  Non_Blocking_Spawn.\n+\n+   function Dup (Fd : File_Descriptor) return File_Descriptor;\n+   pragma Import (C, Dup, \"__gnat_dup\");\n+\n+   procedure Dup2 (Old_Fd, New_Fd : File_Descriptor);\n+   pragma Import (C, Dup2, \"__gnat_dup2\");\n+\n+   On_Windows : constant Boolean := Directory_Separator = '\\';\n+   --  An indication that we are on Windows. Used in Normalize_Pathname, to\n+   --  deal with drive letters in the beginning of absolute paths.\n+\n+   package SSL renames System.Soft_Links;\n+\n+   --  The following are used by Create_Temp_File\n+\n+   First_Temp_File_Name : constant String := \"GNAT-TEMP-000000.TMP\";\n+   --  Used to initialize Current_Temp_File_Name and Temp_File_Name_Last_Digit\n+\n+   Current_Temp_File_Name : String := First_Temp_File_Name;\n+   --  Name of the temp file last created\n+\n+   Temp_File_Name_Last_Digit : constant Positive :=\n+                                 First_Temp_File_Name'Last - 4;\n+   --  Position of the last digit in Current_Temp_File_Name\n+\n+   Max_Attempts : constant := 100;\n+   --  The maximum number of attempts to create a new temp file\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Args_Length (Args : Argument_List) return Natural;\n+   --  Returns total number of characters needed to create a string\n+   --  of all Args terminated by ASCII.NUL characters\n+\n+   function C_String_Length (S : Address) return Integer;\n+   --  Returns the length of a C string. Does check for null address\n+   --  (returns 0).\n+\n+   procedure Spawn_Internal\n+     (Program_Name : String;\n+      Args         : Argument_List;\n+      Result       : out Integer;\n+      Pid          : out Process_Id;\n+      Blocking     : Boolean);\n+   --  Internal routine to implement the two Spawn (blocking/non blocking)\n+   --  routines. If Blocking is set to True then the spawn is blocking\n+   --  otherwise it is non blocking. In this latter case the Pid contains the\n+   --  process id number. The first three parameters are as in Spawn. Note that\n+   --  Spawn_Internal normalizes the argument list before calling the low level\n+   --  system spawn routines (see Normalize_Arguments).\n+   --\n+   --  Note: Normalize_Arguments is designed to do nothing if it is called more\n+   --  than once, so calling Normalize_Arguments before calling one of the\n+   --  spawn routines is fine.\n+\n+   function To_Path_String_Access\n+     (Path_Addr : Address;\n+      Path_Len  : Integer) return String_Access;\n+   --  Converts a C String to an Ada String. We could do this making use of\n+   --  Interfaces.C.Strings but we prefer not to import that entire package\n+\n+   ---------\n+   -- \"<\" --\n+   ---------\n+\n+   function \"<\"  (X, Y : OS_Time) return Boolean is\n+   begin\n+      return Long_Integer (X) < Long_Integer (Y);\n+   end \"<\";\n+\n+   ----------\n+   -- \"<=\" --\n+   ----------\n+\n+   function \"<=\"  (X, Y : OS_Time) return Boolean is\n+   begin\n+      return Long_Integer (X) <= Long_Integer (Y);\n+   end \"<=\";\n+\n+   ---------\n+   -- \">\" --\n+   ---------\n+\n+   function \">\"  (X, Y : OS_Time) return Boolean is\n+   begin\n+      return Long_Integer (X) > Long_Integer (Y);\n+   end \">\";\n+\n+   ----------\n+   -- \">=\" --\n+   ----------\n+\n+   function \">=\"  (X, Y : OS_Time) return Boolean is\n+   begin\n+      return Long_Integer (X) >= Long_Integer (Y);\n+   end \">=\";\n+\n+   -----------------\n+   -- Args_Length --\n+   -----------------\n+\n+   function Args_Length (Args : Argument_List) return Natural is\n+      Len : Natural := 0;\n+\n+   begin\n+      for J in Args'Range loop\n+         Len := Len + Args (J)'Length + 1; --  One extra for ASCII.NUL\n+      end loop;\n+\n+      return Len;\n+   end Args_Length;\n+\n+   -----------------------------\n+   -- Argument_String_To_List --\n+   -----------------------------\n+\n+   function Argument_String_To_List\n+     (Arg_String : String) return Argument_List_Access\n+   is\n+      Max_Args : constant Integer := Arg_String'Length;\n+      New_Argv : Argument_List (1 .. Max_Args);\n+      New_Argc : Natural := 0;\n+      Idx      : Integer;\n+\n+   begin\n+      Idx := Arg_String'First;\n+\n+      loop\n+         exit when Idx > Arg_String'Last;\n+\n+         declare\n+            Quoted  : Boolean := False;\n+            Backqd  : Boolean := False;\n+            Old_Idx : Integer;\n+\n+         begin\n+            Old_Idx := Idx;\n+\n+            loop\n+               --  An unquoted space is the end of an argument\n+\n+               if not (Backqd or Quoted)\n+                 and then Arg_String (Idx) = ' '\n+               then\n+                  exit;\n+\n+               --  Start of a quoted string\n+\n+               elsif not (Backqd or Quoted)\n+                 and then Arg_String (Idx) = '\"'\n+               then\n+                  Quoted := True;\n+\n+               --  End of a quoted string and end of an argument\n+\n+               elsif (Quoted and not Backqd)\n+                 and then Arg_String (Idx) = '\"'\n+               then\n+                  Idx := Idx + 1;\n+                  exit;\n+\n+               --  Following character is backquoted\n+\n+               elsif Arg_String (Idx) = '\\' then\n+                  Backqd := True;\n+\n+               --  Turn off backquoting after advancing one character\n+\n+               elsif Backqd then\n+                  Backqd := False;\n+\n+               end if;\n+\n+               Idx := Idx + 1;\n+               exit when Idx > Arg_String'Last;\n+            end loop;\n+\n+            --  Found an argument\n+\n+            New_Argc := New_Argc + 1;\n+            New_Argv (New_Argc) :=\n+              new String'(Arg_String (Old_Idx .. Idx - 1));\n+\n+            --  Skip extraneous spaces\n+\n+            while Idx <= Arg_String'Last and then Arg_String (Idx) = ' ' loop\n+               Idx := Idx + 1;\n+            end loop;\n+         end;\n+      end loop;\n+\n+      return new Argument_List'(New_Argv (1 .. New_Argc));\n+   end Argument_String_To_List;\n+\n+   ---------------------\n+   -- C_String_Length --\n+   ---------------------\n+\n+   function C_String_Length (S : Address) return Integer is\n+      function Strlen (S : Address) return Integer;\n+      pragma Import (C, Strlen, \"strlen\");\n+   begin\n+      if S = Null_Address then\n+         return 0;\n+      else\n+         return Strlen (S);\n+      end if;\n+   end C_String_Length;\n+\n+   -----------\n+   -- Close --\n+   -----------\n+\n+   procedure Close (FD : File_Descriptor) is\n+      procedure C_Close (FD : File_Descriptor);\n+      pragma Import (C, C_Close, \"close\");\n+   begin\n+      C_Close (FD);\n+   end Close;\n+\n+   procedure Close (FD : File_Descriptor; Status : out Boolean) is\n+      function C_Close (FD : File_Descriptor) return Integer;\n+      pragma Import (C, C_Close, \"close\");\n+   begin\n+      Status := (C_Close (FD) = 0);\n+   end Close;\n+\n+   ---------------\n+   -- Copy_File --\n+   ---------------\n+\n+   procedure Copy_File\n+     (Name     : String;\n+      Pathname : String;\n+      Success  : out Boolean;\n+      Mode     : Copy_Mode := Copy;\n+      Preserve : Attribute := Time_Stamps)\n+   is\n+      From : File_Descriptor;\n+      To   : File_Descriptor;\n+\n+      Copy_Error : exception;\n+      --  Internal exception raised to signal error in copy\n+\n+      function Build_Path (Dir : String; File : String) return String;\n+      --  Returns pathname Dir catenated with File adding the directory\n+      --  separator only if needed.\n+\n+      procedure Copy (From, To : File_Descriptor);\n+      --  Read data from From and place them into To. In both cases the\n+      --  operations uses the current file position. Raises Constraint_Error\n+      --  if a problem occurs during the copy.\n+\n+      procedure Copy_To (To_Name : String);\n+      --  Does a straight copy from source to designated destination file\n+\n+      ----------------\n+      -- Build_Path --\n+      ----------------\n+\n+      function Build_Path (Dir : String; File : String) return String is\n+         Res : String (1 .. Dir'Length + File'Length + 1);\n+\n+         Base_File_Ptr : Integer;\n+         --  The base file name is File (Base_File_Ptr + 1 .. File'Last)\n+\n+         function Is_Dirsep (C : Character) return Boolean;\n+         pragma Inline (Is_Dirsep);\n+         --  Returns True if C is a directory separator. On Windows we\n+         --  handle both styles of directory separator.\n+\n+         ---------------\n+         -- Is_Dirsep --\n+         ---------------\n+\n+         function Is_Dirsep (C : Character) return Boolean is\n+         begin\n+            return C = Directory_Separator or else C = '/';\n+         end Is_Dirsep;\n+\n+      --  Start of processing for Build_Path\n+\n+      begin\n+         --  Find base file name\n+\n+         Base_File_Ptr := File'Last;\n+         while Base_File_Ptr >= File'First loop\n+            exit when Is_Dirsep (File (Base_File_Ptr));\n+            Base_File_Ptr := Base_File_Ptr - 1;\n+         end loop;\n+\n+         declare\n+            Base_File : String renames\n+                          File (Base_File_Ptr + 1 .. File'Last);\n+\n+         begin\n+            Res (1 .. Dir'Length) := Dir;\n+\n+            if Is_Dirsep (Dir (Dir'Last)) then\n+               Res (Dir'Length + 1 .. Dir'Length + Base_File'Length) :=\n+                 Base_File;\n+               return Res (1 .. Dir'Length + Base_File'Length);\n+\n+            else\n+               Res (Dir'Length + 1) := Directory_Separator;\n+               Res (Dir'Length + 2 .. Dir'Length + 1 + Base_File'Length) :=\n+                 Base_File;\n+               return Res (1 .. Dir'Length + 1 + Base_File'Length);\n+            end if;\n+         end;\n+      end Build_Path;\n+\n+      ----------\n+      -- Copy --\n+      ----------\n+\n+      procedure Copy (From, To : File_Descriptor) is\n+         Buf_Size : constant := 200_000;\n+         type Buf is array (1 .. Buf_Size) of Character;\n+         type Buf_Ptr is access Buf;\n+\n+         Buffer : Buf_Ptr;\n+         R      : Integer;\n+         W      : Integer;\n+\n+         Status_From : Boolean;\n+         Status_To   : Boolean;\n+         --  Statuses for the calls to Close\n+\n+         procedure Free is new Ada.Unchecked_Deallocation (Buf, Buf_Ptr);\n+\n+      begin\n+         --  Check for invalid descriptors, making sure that we do not\n+         --  accidentally leave an open file descriptor around.\n+\n+         if From = Invalid_FD then\n+            if To /= Invalid_FD then\n+               Close (To, Status_To);\n+            end if;\n+\n+            raise Copy_Error;\n+\n+         elsif To = Invalid_FD then\n+            Close (From, Status_From);\n+            raise Copy_Error;\n+         end if;\n+\n+         --  Allocate the buffer on the heap\n+\n+         Buffer := new Buf;\n+\n+         loop\n+            R := Read (From, Buffer (1)'Address, Buf_Size);\n+\n+            --  For VMS, the buffer may not be full. So, we need to try again\n+            --  until there is nothing to read.\n+\n+            exit when R = 0;\n+\n+            W := Write (To, Buffer (1)'Address, R);\n+\n+            if W < R then\n+\n+               --  Problem writing data, could be a disk full. Close files\n+               --  without worrying about status, since we are raising a\n+               --  Copy_Error exception in any case.\n+\n+               Close (From, Status_From);\n+               Close (To, Status_To);\n+\n+               Free (Buffer);\n+\n+               raise Copy_Error;\n+            end if;\n+         end loop;\n+\n+         Close (From, Status_From);\n+         Close (To, Status_To);\n+\n+         Free (Buffer);\n+\n+         if not (Status_From and Status_To) then\n+            raise Copy_Error;\n+         end if;\n+      end Copy;\n+\n+      -------------\n+      -- Copy_To --\n+      -------------\n+\n+      procedure Copy_To (To_Name : String) is\n+\n+         function Copy_Attributes\n+           (From, To : System.Address;\n+            Mode     : Integer) return Integer;\n+         pragma Import (C, Copy_Attributes, \"__gnat_copy_attribs\");\n+         --  Mode = 0 - copy only time stamps.\n+         --  Mode = 1 - copy time stamps and read/write/execute attributes\n+\n+         C_From : String (1 .. Name'Length + 1);\n+         C_To   : String (1 .. To_Name'Length + 1);\n+\n+      begin\n+         From := Open_Read (Name, Binary);\n+         To   := Create_File (To_Name, Binary);\n+         Copy (From, To);\n+\n+         --  Copy attributes\n+\n+         C_From (1 .. Name'Length) := Name;\n+         C_From (C_From'Last) := ASCII.Nul;\n+\n+         C_To (1 .. To_Name'Length) := To_Name;\n+         C_To (C_To'Last) := ASCII.Nul;\n+\n+         case Preserve is\n+\n+            when Time_Stamps =>\n+               if Copy_Attributes (C_From'Address, C_To'Address, 0) = -1 then\n+                  raise Copy_Error;\n+               end if;\n+\n+            when Full =>\n+               if Copy_Attributes (C_From'Address, C_To'Address, 1) = -1 then\n+                  raise Copy_Error;\n+               end if;\n+\n+            when None =>\n+               null;\n+         end case;\n+\n+      end Copy_To;\n+\n+   --  Start of processing for Copy_File\n+\n+   begin\n+      Success := True;\n+\n+      --  The source file must exist\n+\n+      if not Is_Regular_File (Name) then\n+         raise Copy_Error;\n+      end if;\n+\n+      --  The source file exists\n+\n+      case Mode is\n+\n+         --  Copy case, target file must not exist\n+\n+         when Copy =>\n+\n+            --  If the target file exists, we have an error\n+\n+            if Is_Regular_File (Pathname) then\n+               raise Copy_Error;\n+\n+            --  Case of target is a directory\n+\n+            elsif Is_Directory (Pathname) then\n+               declare\n+                  Dest : constant String := Build_Path (Pathname, Name);\n+\n+               begin\n+                  --  If target file exists, we have an error, else do copy\n+\n+                  if Is_Regular_File (Dest) then\n+                     raise Copy_Error;\n+                  else\n+                     Copy_To (Dest);\n+                  end if;\n+               end;\n+\n+            --  Case of normal copy to file (destination does not exist)\n+\n+            else\n+               Copy_To (Pathname);\n+            end if;\n+\n+         --  Overwrite case (destination file may or may not exist)\n+\n+         when Overwrite =>\n+            if Is_Directory (Pathname) then\n+               Copy_To (Build_Path (Pathname, Name));\n+            else\n+               Copy_To (Pathname);\n+            end if;\n+\n+         --  Append case (destination file may or may not exist)\n+\n+         when Append =>\n+\n+            --  Appending to existing file\n+\n+            if Is_Regular_File (Pathname) then\n+\n+               --  Append mode and destination file exists, append data at the\n+               --  end of Pathname.\n+\n+               From := Open_Read (Name, Binary);\n+               To   := Open_Read_Write (Pathname, Binary);\n+               Lseek (To, 0, Seek_End);\n+\n+               Copy (From, To);\n+\n+            --  Appending to directory, not allowed\n+\n+            elsif Is_Directory (Pathname) then\n+               raise Copy_Error;\n+\n+            --  Appending when target file does not exist\n+\n+            else\n+               Copy_To (Pathname);\n+            end if;\n+      end case;\n+\n+   --  All error cases are caught here\n+\n+   exception\n+      when Copy_Error =>\n+         Success := False;\n+   end Copy_File;\n+\n+   procedure Copy_File\n+     (Name     : C_File_Name;\n+      Pathname : C_File_Name;\n+      Success  : out Boolean;\n+      Mode     : Copy_Mode := Copy;\n+      Preserve : Attribute := Time_Stamps)\n+   is\n+      Ada_Name : String_Access :=\n+                   To_Path_String_Access\n+                     (Name, C_String_Length (Name));\n+\n+      Ada_Pathname : String_Access :=\n+                       To_Path_String_Access\n+                         (Pathname, C_String_Length (Pathname));\n+\n+   begin\n+      Copy_File (Ada_Name.all, Ada_Pathname.all, Success, Mode, Preserve);\n+      Free (Ada_Name);\n+      Free (Ada_Pathname);\n+   end Copy_File;\n+\n+   ----------------------\n+   -- Copy_Time_Stamps --\n+   ----------------------\n+\n+   procedure Copy_Time_Stamps (Source, Dest : String; Success : out Boolean) is\n+\n+      function Copy_Attributes\n+        (From, To : System.Address;\n+         Mode     : Integer) return Integer;\n+      pragma Import (C, Copy_Attributes, \"__gnat_copy_attribs\");\n+      --  Mode = 0 - copy only time stamps.\n+      --  Mode = 1 - copy time stamps and read/write/execute attributes\n+\n+   begin\n+      if Is_Regular_File (Source) and then Is_Writable_File (Dest) then\n+         declare\n+            C_Source : String (1 .. Source'Length + 1);\n+            C_Dest   : String (1 .. Dest'Length + 1);\n+         begin\n+            C_Source (1 .. Source'Length) := Source;\n+            C_Source (C_Source'Last)      := ASCII.NUL;\n+\n+            C_Dest (1 .. Dest'Length) := Dest;\n+            C_Dest (C_Dest'Last)      := ASCII.NUL;\n+\n+            if Copy_Attributes (C_Source'Address, C_Dest'Address, 0) = -1 then\n+               Success := False;\n+            else\n+               Success := True;\n+            end if;\n+         end;\n+\n+      else\n+         Success := False;\n+      end if;\n+   end Copy_Time_Stamps;\n+\n+   procedure Copy_Time_Stamps\n+     (Source, Dest : C_File_Name;\n+      Success      : out Boolean)\n+   is\n+      Ada_Source : String_Access :=\n+                     To_Path_String_Access\n+                       (Source, C_String_Length (Source));\n+\n+      Ada_Dest : String_Access :=\n+                   To_Path_String_Access\n+                     (Dest, C_String_Length (Dest));\n+   begin\n+      Copy_Time_Stamps (Ada_Source.all, Ada_Dest.all, Success);\n+      Free (Ada_Source);\n+      Free (Ada_Dest);\n+   end Copy_Time_Stamps;\n+\n+   -----------------\n+   -- Create_File --\n+   -----------------\n+\n+   function Create_File\n+     (Name  : C_File_Name;\n+      Fmode : Mode) return File_Descriptor\n+   is\n+      function C_Create_File\n+        (Name  : C_File_Name;\n+         Fmode : Mode) return File_Descriptor;\n+      pragma Import (C, C_Create_File, \"__gnat_open_create\");\n+\n+   begin\n+      return C_Create_File (Name, Fmode);\n+   end Create_File;\n+\n+   function Create_File\n+     (Name  : String;\n+      Fmode : Mode) return File_Descriptor\n+   is\n+      C_Name : String (1 .. Name'Length + 1);\n+\n+   begin\n+      C_Name (1 .. Name'Length) := Name;\n+      C_Name (C_Name'Last)      := ASCII.NUL;\n+      return Create_File (C_Name (C_Name'First)'Address, Fmode);\n+   end Create_File;\n+\n+   ---------------------\n+   -- Create_New_File --\n+   ---------------------\n+\n+   function Create_New_File\n+     (Name  : C_File_Name;\n+      Fmode : Mode) return File_Descriptor\n+   is\n+      function C_Create_New_File\n+        (Name  : C_File_Name;\n+         Fmode : Mode) return File_Descriptor;\n+      pragma Import (C, C_Create_New_File, \"__gnat_open_new\");\n+\n+   begin\n+      return C_Create_New_File (Name, Fmode);\n+   end Create_New_File;\n+\n+   function Create_New_File\n+     (Name  : String;\n+      Fmode : Mode) return File_Descriptor\n+   is\n+      C_Name : String (1 .. Name'Length + 1);\n+\n+   begin\n+      C_Name (1 .. Name'Length) := Name;\n+      C_Name (C_Name'Last)      := ASCII.NUL;\n+      return Create_New_File (C_Name (C_Name'First)'Address, Fmode);\n+   end Create_New_File;\n+\n+   -----------------------------\n+   -- Create_Output_Text_File --\n+   -----------------------------\n+\n+   function Create_Output_Text_File (Name : String) return File_Descriptor is\n+      function C_Create_File\n+        (Name : C_File_Name) return File_Descriptor;\n+      pragma Import (C, C_Create_File, \"__gnat_create_output_file\");\n+\n+      C_Name : String (1 .. Name'Length + 1);\n+\n+   begin\n+      C_Name (1 .. Name'Length) := Name;\n+      C_Name (C_Name'Last)      := ASCII.NUL;\n+      return C_Create_File (C_Name (C_Name'First)'Address);\n+   end Create_Output_Text_File;\n+\n+   ----------------------\n+   -- Create_Temp_File --\n+   ----------------------\n+\n+   procedure Create_Temp_File\n+     (FD   : out File_Descriptor;\n+      Name : out Temp_File_Name)\n+   is\n+      function Open_New_Temp\n+        (Name  : System.Address;\n+         Fmode : Mode) return File_Descriptor;\n+      pragma Import (C, Open_New_Temp, \"__gnat_open_new_temp\");\n+\n+   begin\n+      FD := Open_New_Temp (Name'Address, Binary);\n+   end Create_Temp_File;\n+\n+   procedure Create_Temp_File\n+     (FD   : out File_Descriptor;\n+      Name : out String_Access)\n+   is\n+      Pos      : Positive;\n+      Attempts : Natural := 0;\n+      Current  : String (Current_Temp_File_Name'Range);\n+\n+   begin\n+      --  Loop until a new temp file can be created\n+\n+      File_Loop : loop\n+         Locked : begin\n+            --  We need to protect global variable Current_Temp_File_Name\n+            --  against concurrent access by different tasks.\n+\n+            SSL.Lock_Task.all;\n+\n+            --  Start at the last digit\n+\n+            Pos := Temp_File_Name_Last_Digit;\n+\n+            Digit_Loop :\n+            loop\n+               --  Increment the digit by one\n+\n+               case Current_Temp_File_Name (Pos) is\n+                  when '0' .. '8' =>\n+                     Current_Temp_File_Name (Pos) :=\n+                       Character'Succ (Current_Temp_File_Name (Pos));\n+                     exit Digit_Loop;\n+\n+                  when '9' =>\n+\n+                     --  For 9, set the digit to 0 and go to the previous digit\n+\n+                     Current_Temp_File_Name (Pos) := '0';\n+                     Pos := Pos - 1;\n+\n+                  when others =>\n+\n+                     --  If it is not a digit, then there are no available\n+                     --  temp file names. Return Invalid_FD. There is almost\n+                     --  no that this code will be ever be executed, since\n+                     --  it would mean that there are one million temp files\n+                     --  in the same directory!\n+\n+                     SSL.Unlock_Task.all;\n+                     FD := Invalid_FD;\n+                     Name := null;\n+                     exit File_Loop;\n+               end case;\n+            end loop Digit_Loop;\n+\n+            Current := Current_Temp_File_Name;\n+\n+            --  We can now release the lock, because we are no longer\n+            --  accessing Current_Temp_File_Name.\n+\n+            SSL.Unlock_Task.all;\n+\n+         exception\n+            when others =>\n+               SSL.Unlock_Task.all;\n+               raise;\n+         end Locked;\n+\n+         --  Attempt to create the file\n+\n+         FD := Create_New_File (Current, Binary);\n+\n+         if FD /= Invalid_FD then\n+            Name := new String'(Current);\n+            exit File_Loop;\n+         end if;\n+\n+         if not Is_Regular_File (Current) then\n+\n+            --  If the file does not already exist and we are unable to create\n+            --  it, we give up after Max_Attempts. Otherwise, we try again with\n+            --  the next available file name.\n+\n+            Attempts := Attempts + 1;\n+\n+            if Attempts >= Max_Attempts then\n+               FD := Invalid_FD;\n+               Name := null;\n+               exit File_Loop;\n+            end if;\n+         end if;\n+      end loop File_Loop;\n+   end Create_Temp_File;\n+\n+   -----------------\n+   -- Delete_File --\n+   -----------------\n+\n+   procedure Delete_File (Name : Address; Success : out Boolean) is\n+      R : Integer;\n+\n+      function unlink (A : Address) return Integer;\n+      pragma Import (C, unlink, \"unlink\");\n+\n+   begin\n+      R := unlink (Name);\n+      Success := (R = 0);\n+   end Delete_File;\n+\n+   procedure Delete_File (Name : String; Success : out Boolean) is\n+      C_Name : String (1 .. Name'Length + 1);\n+\n+   begin\n+      C_Name (1 .. Name'Length) := Name;\n+      C_Name (C_Name'Last)      := ASCII.NUL;\n+\n+      Delete_File (C_Name'Address, Success);\n+   end Delete_File;\n+\n+   ---------------------\n+   -- File_Time_Stamp --\n+   ---------------------\n+\n+   function File_Time_Stamp (FD : File_Descriptor) return OS_Time is\n+      function File_Time (FD    : File_Descriptor) return OS_Time;\n+      pragma Import (C, File_Time, \"__gnat_file_time_fd\");\n+   begin\n+      return File_Time (FD);\n+   end File_Time_Stamp;\n+\n+   function File_Time_Stamp (Name : C_File_Name) return OS_Time is\n+      function File_Time (Name : Address) return OS_Time;\n+      pragma Import (C, File_Time, \"__gnat_file_time_name\");\n+   begin\n+      return File_Time (Name);\n+   end File_Time_Stamp;\n+\n+   function File_Time_Stamp (Name : String) return OS_Time is\n+      F_Name : String (1 .. Name'Length + 1);\n+   begin\n+      F_Name (1 .. Name'Length) := Name;\n+      F_Name (F_Name'Last)      := ASCII.NUL;\n+      return File_Time_Stamp (F_Name'Address);\n+   end File_Time_Stamp;\n+\n+   ---------------------------\n+   -- Get_Debuggable_Suffix --\n+   ---------------------------\n+\n+   function Get_Debuggable_Suffix return String_Access is\n+      procedure Get_Suffix_Ptr (Length, Ptr : Address);\n+      pragma Import (C, Get_Suffix_Ptr, \"__gnat_get_debuggable_suffix_ptr\");\n+\n+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n+      pragma Import (C, Strncpy, \"strncpy\");\n+\n+      Suffix_Ptr    : Address;\n+      Suffix_Length : Integer;\n+      Result        : String_Access;\n+\n+   begin\n+      Get_Suffix_Ptr (Suffix_Length'Address, Suffix_Ptr'Address);\n+\n+      Result := new String (1 .. Suffix_Length);\n+\n+      if Suffix_Length > 0 then\n+         Strncpy (Result.all'Address, Suffix_Ptr, Suffix_Length);\n+      end if;\n+\n+      return Result;\n+   end Get_Debuggable_Suffix;\n+\n+   ---------------------------\n+   -- Get_Executable_Suffix --\n+   ---------------------------\n+\n+   function Get_Executable_Suffix return String_Access is\n+      procedure Get_Suffix_Ptr (Length, Ptr : Address);\n+      pragma Import (C, Get_Suffix_Ptr, \"__gnat_get_executable_suffix_ptr\");\n+\n+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n+      pragma Import (C, Strncpy, \"strncpy\");\n+\n+      Suffix_Ptr    : Address;\n+      Suffix_Length : Integer;\n+      Result        : String_Access;\n+\n+   begin\n+      Get_Suffix_Ptr (Suffix_Length'Address, Suffix_Ptr'Address);\n+\n+      Result := new String (1 .. Suffix_Length);\n+\n+      if Suffix_Length > 0 then\n+         Strncpy (Result.all'Address, Suffix_Ptr, Suffix_Length);\n+      end if;\n+\n+      return Result;\n+   end Get_Executable_Suffix;\n+\n+   -----------------------\n+   -- Get_Object_Suffix --\n+   -----------------------\n+\n+   function Get_Object_Suffix return String_Access is\n+      procedure Get_Suffix_Ptr (Length, Ptr : Address);\n+      pragma Import (C, Get_Suffix_Ptr, \"__gnat_get_object_suffix_ptr\");\n+\n+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n+      pragma Import (C, Strncpy, \"strncpy\");\n+\n+      Suffix_Ptr    : Address;\n+      Suffix_Length : Integer;\n+      Result        : String_Access;\n+\n+   begin\n+      Get_Suffix_Ptr (Suffix_Length'Address, Suffix_Ptr'Address);\n+\n+      Result := new String (1 .. Suffix_Length);\n+\n+      if Suffix_Length > 0 then\n+         Strncpy (Result.all'Address, Suffix_Ptr, Suffix_Length);\n+      end if;\n+\n+      return Result;\n+   end Get_Object_Suffix;\n+\n+   ----------------------------------\n+   -- Get_Target_Debuggable_Suffix --\n+   ----------------------------------\n+\n+   function Get_Target_Debuggable_Suffix return String_Access is\n+      Target_Exec_Ext_Ptr : Address;\n+      pragma Import\n+        (C, Target_Exec_Ext_Ptr, \"__gnat_target_debuggable_extension\");\n+\n+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n+      pragma Import (C, Strncpy, \"strncpy\");\n+\n+      function Strlen (Cstring : Address) return Integer;\n+      pragma Import (C, Strlen, \"strlen\");\n+\n+      Suffix_Length : Integer;\n+      Result        : String_Access;\n+\n+   begin\n+      Suffix_Length := Strlen (Target_Exec_Ext_Ptr);\n+\n+      Result := new String (1 .. Suffix_Length);\n+\n+      if Suffix_Length > 0 then\n+         Strncpy (Result.all'Address, Target_Exec_Ext_Ptr, Suffix_Length);\n+      end if;\n+\n+      return Result;\n+   end Get_Target_Debuggable_Suffix;\n+\n+   ----------------------------------\n+   -- Get_Target_Executable_Suffix --\n+   ----------------------------------\n+\n+   function Get_Target_Executable_Suffix return String_Access is\n+      Target_Exec_Ext_Ptr : Address;\n+      pragma Import\n+        (C, Target_Exec_Ext_Ptr, \"__gnat_target_executable_extension\");\n+\n+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n+      pragma Import (C, Strncpy, \"strncpy\");\n+\n+      function Strlen (Cstring : Address) return Integer;\n+      pragma Import (C, Strlen, \"strlen\");\n+\n+      Suffix_Length : Integer;\n+      Result        : String_Access;\n+\n+   begin\n+      Suffix_Length := Strlen (Target_Exec_Ext_Ptr);\n+\n+      Result := new String (1 .. Suffix_Length);\n+\n+      if Suffix_Length > 0 then\n+         Strncpy (Result.all'Address, Target_Exec_Ext_Ptr, Suffix_Length);\n+      end if;\n+\n+      return Result;\n+   end Get_Target_Executable_Suffix;\n+\n+   ------------------------------\n+   -- Get_Target_Object_Suffix --\n+   ------------------------------\n+\n+   function Get_Target_Object_Suffix return String_Access is\n+      Target_Object_Ext_Ptr : Address;\n+      pragma Import\n+        (C, Target_Object_Ext_Ptr, \"__gnat_target_object_extension\");\n+\n+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n+      pragma Import (C, Strncpy, \"strncpy\");\n+\n+      function Strlen (Cstring : Address) return Integer;\n+      pragma Import (C, Strlen, \"strlen\");\n+\n+      Suffix_Length : Integer;\n+      Result        : String_Access;\n+\n+   begin\n+      Suffix_Length := Strlen (Target_Object_Ext_Ptr);\n+\n+      Result := new String (1 .. Suffix_Length);\n+\n+      if Suffix_Length > 0 then\n+         Strncpy (Result.all'Address, Target_Object_Ext_Ptr, Suffix_Length);\n+      end if;\n+\n+      return Result;\n+   end Get_Target_Object_Suffix;\n+\n+   ------------\n+   -- Getenv --\n+   ------------\n+\n+   function Getenv (Name : String) return String_Access is\n+      procedure Get_Env_Value_Ptr (Name, Length, Ptr : Address);\n+      pragma Import (C, Get_Env_Value_Ptr, \"__gnat_getenv\");\n+\n+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n+      pragma Import (C, Strncpy, \"strncpy\");\n+\n+      Env_Value_Ptr    : aliased Address;\n+      Env_Value_Length : aliased Integer;\n+      F_Name           : aliased String (1 .. Name'Length + 1);\n+      Result           : String_Access;\n+\n+   begin\n+      F_Name (1 .. Name'Length) := Name;\n+      F_Name (F_Name'Last)      := ASCII.NUL;\n+\n+      Get_Env_Value_Ptr\n+        (F_Name'Address, Env_Value_Length'Address, Env_Value_Ptr'Address);\n+\n+      Result := new String (1 .. Env_Value_Length);\n+\n+      if Env_Value_Length > 0 then\n+         Strncpy (Result.all'Address, Env_Value_Ptr, Env_Value_Length);\n+      end if;\n+\n+      return Result;\n+   end Getenv;\n+\n+   ------------\n+   -- GM_Day --\n+   ------------\n+\n+   function GM_Day (Date : OS_Time) return Day_Type is\n+      Y  : Year_Type;\n+      Mo : Month_Type;\n+      D  : Day_Type;\n+      H  : Hour_Type;\n+      Mn : Minute_Type;\n+      S  : Second_Type;\n+\n+   begin\n+      GM_Split (Date, Y, Mo, D, H, Mn, S);\n+      return D;\n+   end GM_Day;\n+\n+   -------------\n+   -- GM_Hour --\n+   -------------\n+\n+   function GM_Hour (Date : OS_Time) return Hour_Type is\n+      Y  : Year_Type;\n+      Mo : Month_Type;\n+      D  : Day_Type;\n+      H  : Hour_Type;\n+      Mn : Minute_Type;\n+      S  : Second_Type;\n+\n+   begin\n+      GM_Split (Date, Y, Mo, D, H, Mn, S);\n+      return H;\n+   end GM_Hour;\n+\n+   ---------------\n+   -- GM_Minute --\n+   ---------------\n+\n+   function GM_Minute (Date : OS_Time) return Minute_Type is\n+      Y  : Year_Type;\n+      Mo : Month_Type;\n+      D  : Day_Type;\n+      H  : Hour_Type;\n+      Mn : Minute_Type;\n+      S  : Second_Type;\n+\n+   begin\n+      GM_Split (Date, Y, Mo, D, H, Mn, S);\n+      return Mn;\n+   end GM_Minute;\n+\n+   --------------\n+   -- GM_Month --\n+   --------------\n+\n+   function GM_Month (Date : OS_Time) return Month_Type is\n+      Y  : Year_Type;\n+      Mo : Month_Type;\n+      D  : Day_Type;\n+      H  : Hour_Type;\n+      Mn : Minute_Type;\n+      S  : Second_Type;\n+\n+   begin\n+      GM_Split (Date, Y, Mo, D, H, Mn, S);\n+      return Mo;\n+   end GM_Month;\n+\n+   ---------------\n+   -- GM_Second --\n+   ---------------\n+\n+   function GM_Second (Date : OS_Time) return Second_Type is\n+      Y  : Year_Type;\n+      Mo : Month_Type;\n+      D  : Day_Type;\n+      H  : Hour_Type;\n+      Mn : Minute_Type;\n+      S  : Second_Type;\n+\n+   begin\n+      GM_Split (Date, Y, Mo, D, H, Mn, S);\n+      return S;\n+   end GM_Second;\n+\n+   --------------\n+   -- GM_Split --\n+   --------------\n+\n+   procedure GM_Split\n+     (Date   : OS_Time;\n+      Year   : out Year_Type;\n+      Month  : out Month_Type;\n+      Day    : out Day_Type;\n+      Hour   : out Hour_Type;\n+      Minute : out Minute_Type;\n+      Second : out Second_Type)\n+   is\n+      procedure To_GM_Time\n+        (P_Time_T, P_Year, P_Month, P_Day, P_Hours, P_Mins, P_Secs : Address);\n+      pragma Import (C, To_GM_Time, \"__gnat_to_gm_time\");\n+\n+      T  : OS_Time := Date;\n+      Y  : Integer;\n+      Mo : Integer;\n+      D  : Integer;\n+      H  : Integer;\n+      Mn : Integer;\n+      S  : Integer;\n+\n+   begin\n+      --  Use the global lock because To_GM_Time is not thread safe\n+\n+      Locked_Processing : begin\n+         SSL.Lock_Task.all;\n+         To_GM_Time\n+           (T'Address, Y'Address, Mo'Address, D'Address,\n+            H'Address, Mn'Address, S'Address);\n+         SSL.Unlock_Task.all;\n+\n+      exception\n+         when others =>\n+            SSL.Unlock_Task.all;\n+            raise;\n+      end Locked_Processing;\n+\n+      Year   := Y + 1900;\n+      Month  := Mo + 1;\n+      Day    := D;\n+      Hour   := H;\n+      Minute := Mn;\n+      Second := S;\n+   end GM_Split;\n+\n+   -------------\n+   -- GM_Year --\n+   -------------\n+\n+   function GM_Year (Date : OS_Time) return Year_Type is\n+      Y  : Year_Type;\n+      Mo : Month_Type;\n+      D  : Day_Type;\n+      H  : Hour_Type;\n+      Mn : Minute_Type;\n+      S  : Second_Type;\n+\n+   begin\n+      GM_Split (Date, Y, Mo, D, H, Mn, S);\n+      return Y;\n+   end GM_Year;\n+\n+   ----------------------\n+   -- Is_Absolute_Path --\n+   ----------------------\n+\n+   function Is_Absolute_Path (Name : String) return Boolean is\n+      function Is_Absolute_Path\n+        (Name   : Address;\n+         Length : Integer) return Integer;\n+      pragma Import (C, Is_Absolute_Path, \"__gnat_is_absolute_path\");\n+   begin\n+      return Is_Absolute_Path (Name'Address, Name'Length) /= 0;\n+   end Is_Absolute_Path;\n+\n+   ------------------\n+   -- Is_Directory --\n+   ------------------\n+\n+   function Is_Directory (Name : C_File_Name) return Boolean is\n+      function Is_Directory (Name : Address) return Integer;\n+      pragma Import (C, Is_Directory, \"__gnat_is_directory\");\n+   begin\n+      return Is_Directory (Name) /= 0;\n+   end Is_Directory;\n+\n+   function Is_Directory (Name : String) return Boolean is\n+      F_Name : String (1 .. Name'Length + 1);\n+   begin\n+      F_Name (1 .. Name'Length) := Name;\n+      F_Name (F_Name'Last)      := ASCII.NUL;\n+      return Is_Directory (F_Name'Address);\n+   end Is_Directory;\n+\n+   ----------------------\n+   -- Is_Readable_File --\n+   ----------------------\n+\n+   function Is_Readable_File (Name : C_File_Name) return Boolean is\n+      function Is_Readable_File (Name : Address) return Integer;\n+      pragma Import (C, Is_Readable_File, \"__gnat_is_readable_file\");\n+   begin\n+      return Is_Readable_File (Name) /= 0;\n+   end Is_Readable_File;\n+\n+   function Is_Readable_File (Name : String) return Boolean is\n+      F_Name : String (1 .. Name'Length + 1);\n+   begin\n+      F_Name (1 .. Name'Length) := Name;\n+      F_Name (F_Name'Last)      := ASCII.NUL;\n+      return Is_Readable_File (F_Name'Address);\n+   end Is_Readable_File;\n+\n+   ---------------------\n+   -- Is_Regular_File --\n+   ---------------------\n+\n+   function Is_Regular_File (Name : C_File_Name) return Boolean is\n+      function Is_Regular_File (Name : Address) return Integer;\n+      pragma Import (C, Is_Regular_File, \"__gnat_is_regular_file\");\n+   begin\n+      return Is_Regular_File (Name) /= 0;\n+   end Is_Regular_File;\n+\n+   function Is_Regular_File (Name : String) return Boolean is\n+      F_Name : String (1 .. Name'Length + 1);\n+   begin\n+      F_Name (1 .. Name'Length) := Name;\n+      F_Name (F_Name'Last)      := ASCII.NUL;\n+      return Is_Regular_File (F_Name'Address);\n+   end Is_Regular_File;\n+\n+   ----------------------\n+   -- Is_Symbolic_Link --\n+   ----------------------\n+\n+   function Is_Symbolic_Link (Name : C_File_Name) return Boolean is\n+      function Is_Symbolic_Link (Name : Address) return Integer;\n+      pragma Import (C, Is_Symbolic_Link, \"__gnat_is_symbolic_link\");\n+   begin\n+      return Is_Symbolic_Link (Name) /= 0;\n+   end Is_Symbolic_Link;\n+\n+   function Is_Symbolic_Link (Name : String) return Boolean is\n+      F_Name : String (1 .. Name'Length + 1);\n+   begin\n+      F_Name (1 .. Name'Length) := Name;\n+      F_Name (F_Name'Last)      := ASCII.NUL;\n+      return Is_Symbolic_Link (F_Name'Address);\n+   end Is_Symbolic_Link;\n+\n+   ----------------------\n+   -- Is_Writable_File --\n+   ----------------------\n+\n+   function Is_Writable_File (Name : C_File_Name) return Boolean is\n+      function Is_Writable_File (Name : Address) return Integer;\n+      pragma Import (C, Is_Writable_File, \"__gnat_is_writable_file\");\n+   begin\n+      return Is_Writable_File (Name) /= 0;\n+   end Is_Writable_File;\n+\n+   function Is_Writable_File (Name : String) return Boolean is\n+      F_Name : String (1 .. Name'Length + 1);\n+   begin\n+      F_Name (1 .. Name'Length) := Name;\n+      F_Name (F_Name'Last)      := ASCII.NUL;\n+      return Is_Writable_File (F_Name'Address);\n+   end Is_Writable_File;\n+\n+   -------------------------\n+   -- Locate_Exec_On_Path --\n+   -------------------------\n+\n+   function Locate_Exec_On_Path\n+     (Exec_Name : String) return String_Access\n+   is\n+      function Locate_Exec_On_Path (C_Exec_Name : Address) return Address;\n+      pragma Import (C, Locate_Exec_On_Path, \"__gnat_locate_exec_on_path\");\n+\n+      procedure Free (Ptr : System.Address);\n+      pragma Import (C, Free, \"free\");\n+\n+      C_Exec_Name  : String (1 .. Exec_Name'Length + 1);\n+      Path_Addr    : Address;\n+      Path_Len     : Integer;\n+      Result       : String_Access;\n+\n+   begin\n+      C_Exec_Name (1 .. Exec_Name'Length)   := Exec_Name;\n+      C_Exec_Name (C_Exec_Name'Last)        := ASCII.NUL;\n+\n+      Path_Addr := Locate_Exec_On_Path (C_Exec_Name'Address);\n+      Path_Len  := C_String_Length (Path_Addr);\n+\n+      if Path_Len = 0 then\n+         return null;\n+\n+      else\n+         Result := To_Path_String_Access (Path_Addr, Path_Len);\n+         Free (Path_Addr);\n+\n+         --  Always return an absolute path name\n+\n+         if not Is_Absolute_Path (Result.all) then\n+            declare\n+               Absolute_Path : constant String :=\n+                                 Normalize_Pathname (Result.all);\n+            begin\n+               Free (Result);\n+               Result := new String'(Absolute_Path);\n+            end;\n+         end if;\n+\n+         return Result;\n+      end if;\n+   end Locate_Exec_On_Path;\n+\n+   -------------------------\n+   -- Locate_Regular_File --\n+   -------------------------\n+\n+   function Locate_Regular_File\n+     (File_Name : C_File_Name;\n+      Path      : C_File_Name) return String_Access\n+   is\n+      function Locate_Regular_File\n+        (C_File_Name, Path_Val : Address) return Address;\n+      pragma Import (C, Locate_Regular_File, \"__gnat_locate_regular_file\");\n+\n+      procedure Free (Ptr : System.Address);\n+      pragma Import (C, Free, \"free\");\n+\n+      Path_Addr    : Address;\n+      Path_Len     : Integer;\n+      Result       : String_Access;\n+\n+   begin\n+      Path_Addr := Locate_Regular_File (File_Name, Path);\n+      Path_Len  := C_String_Length (Path_Addr);\n+\n+      if Path_Len = 0 then\n+         return null;\n+      else\n+         Result := To_Path_String_Access (Path_Addr, Path_Len);\n+         Free (Path_Addr);\n+         return Result;\n+      end if;\n+   end Locate_Regular_File;\n+\n+   function Locate_Regular_File\n+     (File_Name : String;\n+      Path      : String) return String_Access\n+   is\n+      C_File_Name : String (1 .. File_Name'Length + 1);\n+      C_Path      : String (1 .. Path'Length + 1);\n+      Result      : String_Access;\n+\n+   begin\n+      C_File_Name (1 .. File_Name'Length)   := File_Name;\n+      C_File_Name (C_File_Name'Last)        := ASCII.NUL;\n+\n+      C_Path    (1 .. Path'Length)          := Path;\n+      C_Path    (C_Path'Last)               := ASCII.NUL;\n+\n+      Result := Locate_Regular_File (C_File_Name'Address, C_Path'Address);\n+\n+      --  Always return an absolute path name\n+\n+      if Result /= null and then not Is_Absolute_Path (Result.all) then\n+         declare\n+            Absolute_Path : constant String := Normalize_Pathname (Result.all);\n+         begin\n+            Free (Result);\n+            Result := new String'(Absolute_Path);\n+         end;\n+      end if;\n+\n+      return Result;\n+   end Locate_Regular_File;\n+\n+   ------------------------\n+   -- Non_Blocking_Spawn --\n+   ------------------------\n+\n+   function Non_Blocking_Spawn\n+     (Program_Name : String;\n+      Args         : Argument_List) return Process_Id\n+   is\n+      Junk : Integer;\n+      Pid  : Process_Id;\n+\n+   begin\n+      Spawn_Internal (Program_Name, Args, Junk, Pid, Blocking => False);\n+      return Pid;\n+   end Non_Blocking_Spawn;\n+\n+   function Non_Blocking_Spawn\n+     (Program_Name           : String;\n+      Args                   : Argument_List;\n+      Output_File_Descriptor : File_Descriptor;\n+      Err_To_Out             : Boolean := True) return Process_Id\n+   is\n+      Saved_Output : File_Descriptor;\n+      Saved_Error  : File_Descriptor := Invalid_FD; -- prevent warning\n+      Pid          : Process_Id;\n+\n+   begin\n+      if Output_File_Descriptor = Invalid_FD then\n+         return Invalid_Pid;\n+      end if;\n+\n+      --  Set standard output and, if specified, error to the temporary file\n+\n+      Saved_Output := Dup (Standout);\n+      Dup2 (Output_File_Descriptor, Standout);\n+\n+      if Err_To_Out then\n+         Saved_Error  := Dup (Standerr);\n+         Dup2 (Output_File_Descriptor, Standerr);\n+      end if;\n+\n+      --  Spawn the program\n+\n+      Pid := Non_Blocking_Spawn (Program_Name, Args);\n+\n+      --  Restore the standard output and error\n+\n+      Dup2 (Saved_Output, Standout);\n+\n+      if Err_To_Out then\n+         Dup2 (Saved_Error, Standerr);\n+      end if;\n+\n+      --  And close the saved standard output and error file descriptors\n+\n+      Close (Saved_Output);\n+\n+      if Err_To_Out then\n+         Close (Saved_Error);\n+      end if;\n+\n+      return Pid;\n+   end Non_Blocking_Spawn;\n+\n+   function Non_Blocking_Spawn\n+     (Program_Name : String;\n+      Args         : Argument_List;\n+      Output_File  : String;\n+      Err_To_Out   : Boolean := True) return Process_Id\n+   is\n+      Output_File_Descriptor : constant File_Descriptor :=\n+                                 Create_Output_Text_File (Output_File);\n+      Result : Process_Id;\n+\n+   begin\n+      --  Do not attempt to spawn if the output file could not be created\n+\n+      if Output_File_Descriptor = Invalid_FD then\n+         return Invalid_Pid;\n+\n+      else\n+         Result := Non_Blocking_Spawn\n+                     (Program_Name, Args, Output_File_Descriptor, Err_To_Out);\n+\n+         --  Close the file just created for the output, as the file descriptor\n+         --  cannot be used anywhere, being a local value. It is safe to do\n+         --  that, as the file descriptor has been duplicated to form\n+         --  standard output and error of the spawned process.\n+\n+         Close (Output_File_Descriptor);\n+\n+         return Result;\n+      end if;\n+   end Non_Blocking_Spawn;\n+\n+   -------------------------\n+   -- Normalize_Arguments --\n+   -------------------------\n+\n+   procedure Normalize_Arguments (Args : in out Argument_List) is\n+\n+      procedure Quote_Argument (Arg : in out String_Access);\n+      --  Add quote around argument if it contains spaces\n+\n+      C_Argument_Needs_Quote : Integer;\n+      pragma Import (C, C_Argument_Needs_Quote, \"__gnat_argument_needs_quote\");\n+      Argument_Needs_Quote : constant Boolean := C_Argument_Needs_Quote /= 0;\n+\n+      --------------------\n+      -- Quote_Argument --\n+      --------------------\n+\n+      procedure Quote_Argument (Arg : in out String_Access) is\n+         Res          : String (1 .. Arg'Length * 2);\n+         J            : Positive := 1;\n+         Quote_Needed : Boolean  := False;\n+\n+      begin\n+         if Arg (Arg'First) /= '\"' or else Arg (Arg'Last) /= '\"' then\n+\n+            --  Starting quote\n+\n+            Res (J) := '\"';\n+\n+            for K in Arg'Range loop\n+\n+               J := J + 1;\n+\n+               if Arg (K) = '\"' then\n+                  Res (J) := '\\';\n+                  J := J + 1;\n+                  Res (J) := '\"';\n+                  Quote_Needed := True;\n+\n+               elsif Arg (K) = ' ' then\n+                  Res (J) := Arg (K);\n+                  Quote_Needed := True;\n+\n+               else\n+                  Res (J) := Arg (K);\n+               end if;\n+\n+            end loop;\n+\n+            if Quote_Needed then\n+\n+               --  If null terminated string, put the quote before\n+\n+               if Res (J) = ASCII.Nul then\n+                  Res (J) := '\"';\n+                  J := J + 1;\n+                  Res (J) := ASCII.Nul;\n+\n+               --  If argument is terminated by '\\', then double it. Otherwise\n+               --  the ending quote will be taken as-is. This is quite strange\n+               --  spawn behavior from Windows, but this is what we see!\n+\n+               else\n+                  if Res (J) = '\\' then\n+                     J := J + 1;\n+                     Res (J) := '\\';\n+                  end if;\n+\n+                  --  Ending quote\n+\n+                  J := J + 1;\n+                  Res (J) := '\"';\n+               end if;\n+\n+               declare\n+                  Old : String_Access := Arg;\n+\n+               begin\n+                  Arg := new String'(Res (1 .. J));\n+                  Free (Old);\n+               end;\n+            end if;\n+\n+         end if;\n+      end Quote_Argument;\n+\n+   --  Start of processing for Normalize_Arguments\n+\n+   begin\n+      if Argument_Needs_Quote then\n+         for K in Args'Range loop\n+            if Args (K) /= null and then Args (K)'Length /= 0 then\n+               Quote_Argument (Args (K));\n+            end if;\n+         end loop;\n+      end if;\n+   end Normalize_Arguments;\n+\n+   ------------------------\n+   -- Normalize_Pathname --\n+   ------------------------\n+\n+   function Normalize_Pathname\n+     (Name           : String;\n+      Directory      : String  := \"\";\n+      Resolve_Links  : Boolean := True;\n+      Case_Sensitive : Boolean := True) return String\n+   is\n+      Max_Path : Integer;\n+      pragma Import (C, Max_Path, \"__gnat_max_path_len\");\n+      --  Maximum length of a path name\n+\n+      procedure Get_Current_Dir\n+        (Dir    : System.Address;\n+         Length : System.Address);\n+      pragma Import (C, Get_Current_Dir, \"__gnat_get_current_dir\");\n+\n+      Path_Buffer : String (1 .. Max_Path + Max_Path + 2);\n+      End_Path    : Natural := 0;\n+      Link_Buffer : String (1 .. Max_Path + 2);\n+      Status      : Integer;\n+      Last        : Positive;\n+      Start       : Natural;\n+      Finish      : Positive;\n+\n+      Max_Iterations : constant := 500;\n+\n+      function Get_File_Names_Case_Sensitive return Integer;\n+      pragma Import\n+        (C, Get_File_Names_Case_Sensitive,\n+         \"__gnat_get_file_names_case_sensitive\");\n+\n+      Fold_To_Lower_Case : constant Boolean :=\n+                             not Case_Sensitive\n+                               and then Get_File_Names_Case_Sensitive = 0;\n+\n+      function Readlink\n+        (Path   : System.Address;\n+         Buf    : System.Address;\n+         Bufsiz : Integer) return Integer;\n+      pragma Import (C, Readlink, \"__gnat_readlink\");\n+\n+      function To_Canonical_File_Spec\n+        (Host_File : System.Address) return System.Address;\n+      pragma Import\n+        (C, To_Canonical_File_Spec, \"__gnat_to_canonical_file_spec\");\n+\n+      The_Name : String (1 .. Name'Length + 1);\n+      Canonical_File_Addr : System.Address;\n+      Canonical_File_Len  : Integer;\n+\n+      Need_To_Check_Drive_Letter : Boolean := False;\n+      --  Set to true if Name is an absolute path that starts with \"//\"\n+\n+      function Strlen (S : System.Address) return Integer;\n+      pragma Import (C, Strlen, \"strlen\");\n+\n+      function Final_Value (S : String) return String;\n+      --  Make final adjustment to the returned string.\n+      --  To compensate for non standard path name in Interix,\n+      --  if S is \"/x\" or starts with \"/x\", where x is a capital\n+      --  letter 'A' to 'Z', add an additional '/' at the beginning\n+      --  so that the returned value starts with \"//x\".\n+\n+      function Get_Directory  (Dir : String) return String;\n+      --  If Dir is not empty, return it, adding a directory separator\n+      --  if not already present, otherwise return current working directory\n+      --  with terminating directory separator.\n+\n+      -----------------\n+      -- Final_Value --\n+      -----------------\n+\n+      function Final_Value (S : String) return String is\n+         S1 : String := S;\n+         --  We may need to fold S to lower case, so we need a variable\n+\n+         Last : Natural;\n+\n+      begin\n+         --  Interix has the non standard notion of disk drive\n+         --  indicated by two '/' followed by a capital letter\n+         --  'A' .. 'Z'. One of the two '/' may have been removed\n+         --  by Normalize_Pathname. It has to be added again.\n+         --  For other OSes, this should not make no difference.\n+\n+         if Need_To_Check_Drive_Letter\n+           and then S'Length >= 2\n+           and then S (S'First) = '/'\n+           and then S (S'First + 1) in 'A' .. 'Z'\n+           and then (S'Length = 2 or else S (S'First + 2) = '/')\n+         then\n+            declare\n+               Result : String (1 .. S'Length + 1);\n+\n+            begin\n+               Result (1) := '/';\n+               Result (2 .. Result'Last) := S;\n+               Last := Result'Last;\n+\n+               if Fold_To_Lower_Case then\n+                  System.Case_Util.To_Lower (Result);\n+               end if;\n+\n+               --  Remove trailing directory separator, if any\n+\n+               if Last > 1 and then\n+                 (Result (Last) = '/' or else\n+                  Result (Last) = Directory_Separator)\n+               then\n+                  Last := Last - 1;\n+               end if;\n+\n+               return Result (1 .. Last);\n+            end;\n+\n+         else\n+            if Fold_To_Lower_Case then\n+               System.Case_Util.To_Lower (S1);\n+            end if;\n+\n+            --  Remove trailing directory separator, if any\n+\n+            Last := S1'Last;\n+\n+            if Last > 1\n+              and then (S1 (Last) = '/'\n+                          or else\n+                        S1 (Last) = Directory_Separator)\n+            then\n+               --  Special case for Windows: C:\\\n+\n+               if Last = 3\n+                 and then S1 (1) /= Directory_Separator\n+                 and then S1 (2) = ':'\n+               then\n+                  null;\n+\n+               else\n+                  Last := Last - 1;\n+               end if;\n+            end if;\n+\n+            return S1 (1 .. Last);\n+         end if;\n+      end Final_Value;\n+\n+      -------------------\n+      -- Get_Directory --\n+      -------------------\n+\n+      function Get_Directory (Dir : String) return String is\n+      begin\n+         --  Directory given, add directory separator if needed\n+\n+         if Dir'Length > 0 then\n+            if Dir (Dir'Last) = Directory_Separator then\n+               return Dir;\n+            else\n+               declare\n+                  Result : String (1 .. Dir'Length + 1);\n+               begin\n+                  Result (1 .. Dir'Length) := Dir;\n+                  Result (Result'Length) := Directory_Separator;\n+                  return Result;\n+               end;\n+            end if;\n+\n+         --  Directory name not given, get current directory\n+\n+         else\n+            declare\n+               Buffer   : String (1 .. Max_Path + 2);\n+               Path_Len : Natural := Max_Path;\n+\n+            begin\n+               Get_Current_Dir (Buffer'Address, Path_Len'Address);\n+\n+               if Buffer (Path_Len) /= Directory_Separator then\n+                  Path_Len := Path_Len + 1;\n+                  Buffer (Path_Len) := Directory_Separator;\n+               end if;\n+\n+               --  By default, the drive letter on Windows is in upper case\n+\n+               if On_Windows and then Path_Len >= 2 and then\n+                 Buffer (2) = ':'\n+               then\n+                  System.Case_Util.To_Upper (Buffer (1 .. 1));\n+               end if;\n+\n+               return Buffer (1 .. Path_Len);\n+            end;\n+         end if;\n+      end Get_Directory;\n+\n+      Reference_Dir : constant String := Get_Directory (Directory);\n+      --  Current directory name specified\n+\n+   --  Start of processing for Normalize_Pathname\n+\n+   begin\n+      --  Special case, if name is null, then return null\n+\n+      if Name'Length = 0 then\n+         return \"\";\n+      end if;\n+\n+      --  First, convert VMS file spec to Unix file spec.\n+      --  If Name is not in VMS syntax, then this is equivalent\n+      --  to put Name at the begining of Path_Buffer.\n+\n+      VMS_Conversion : begin\n+         The_Name (1 .. Name'Length) := Name;\n+         The_Name (The_Name'Last) := ASCII.NUL;\n+\n+         Canonical_File_Addr := To_Canonical_File_Spec (The_Name'Address);\n+         Canonical_File_Len  := Strlen (Canonical_File_Addr);\n+\n+         --  If VMS syntax conversion has failed, return an empty string\n+         --  to indicate the failure.\n+\n+         if Canonical_File_Len = 0 then\n+            return \"\";\n+         end if;\n+\n+         declare\n+            subtype Path_String is String (1 .. Canonical_File_Len);\n+            type    Path_String_Access is access Path_String;\n+\n+            function Address_To_Access is new\n+               Ada.Unchecked_Conversion (Source => Address,\n+                                     Target => Path_String_Access);\n+\n+            Path_Access : constant Path_String_Access :=\n+                            Address_To_Access (Canonical_File_Addr);\n+\n+         begin\n+            Path_Buffer (1 .. Canonical_File_Len) := Path_Access.all;\n+            End_Path := Canonical_File_Len;\n+            Last := 1;\n+         end;\n+      end VMS_Conversion;\n+\n+      --  Replace all '/' by Directory Separators (this is for Windows)\n+\n+      if Directory_Separator /= '/' then\n+         for Index in 1 .. End_Path loop\n+            if Path_Buffer (Index) = '/' then\n+               Path_Buffer (Index) := Directory_Separator;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      --  Resolve directory names for Windows (formerly also VMS)\n+\n+      --  On VMS, if we have a Unix path such as /temp/..., and TEMP is a\n+      --  logical name, we must not try to resolve this logical name, because\n+      --  it may have multiple equivalences and if resolved we will only\n+      --  get the first one.\n+\n+      --  On Windows, if we have an absolute path starting with a directory\n+      --  separator, we need to have the drive letter appended in front.\n+\n+      --  On Windows, Get_Current_Dir will return a suitable directory\n+      --  name (path starting with a drive letter on Windows). So we take this\n+      --  drive letter and prepend it to the current path.\n+\n+      if On_Windows\n+        and then Path_Buffer (1) = Directory_Separator\n+        and then Path_Buffer (2) /= Directory_Separator\n+      then\n+         declare\n+            Cur_Dir : String := Get_Directory (\"\");\n+            --  Get the current directory to get the drive letter\n+\n+         begin\n+            if Cur_Dir'Length > 2\n+              and then Cur_Dir (Cur_Dir'First + 1) = ':'\n+            then\n+               Path_Buffer (3 .. End_Path + 2) := Path_Buffer (1 .. End_Path);\n+               Path_Buffer (1 .. 2) :=\n+                 Cur_Dir (Cur_Dir'First .. Cur_Dir'First + 1);\n+               End_Path := End_Path + 2;\n+            end if;\n+         end;\n+      end if;\n+\n+      --  Start the conversions\n+\n+      --  If this is not finished after Max_Iterations, give up and return an\n+      --  empty string.\n+\n+      for J in 1 .. Max_Iterations loop\n+\n+         --  If we don't have an absolute pathname, prepend the directory\n+         --  Reference_Dir.\n+\n+         if Last = 1\n+           and then not Is_Absolute_Path (Path_Buffer (1 .. End_Path))\n+         then\n+            Path_Buffer\n+              (Reference_Dir'Length + 1 .. Reference_Dir'Length + End_Path) :=\n+                 Path_Buffer (1 .. End_Path);\n+            End_Path := Reference_Dir'Length + End_Path;\n+            Path_Buffer (1 .. Reference_Dir'Length) := Reference_Dir;\n+            Last := Reference_Dir'Length;\n+         end if;\n+\n+         --  If name starts with \"//\", we may have a drive letter on Interix\n+\n+         if Last = 1 and then End_Path >= 3 then\n+            Need_To_Check_Drive_Letter := (Path_Buffer (1 .. 2)) = \"//\";\n+         end if;\n+\n+         Start  := Last + 1;\n+         Finish := Last;\n+\n+         --  Ensure that Windows network drives are kept, e.g: \\\\server\\drive-c\n+\n+         if Start = 2\n+           and then Directory_Separator = '\\'\n+           and then Path_Buffer (1 .. 2) = \"\\\\\"\n+         then\n+            Start := 3;\n+         end if;\n+\n+         --  If we have traversed the full pathname, return it\n+\n+         if Start > End_Path then\n+            return Final_Value (Path_Buffer (1 .. End_Path));\n+         end if;\n+\n+         --  Remove duplicate directory separators\n+\n+         while Path_Buffer (Start) = Directory_Separator loop\n+            if Start = End_Path then\n+               return Final_Value (Path_Buffer (1 .. End_Path - 1));\n+\n+            else\n+               Path_Buffer (Start .. End_Path - 1) :=\n+                 Path_Buffer (Start + 1 .. End_Path);\n+               End_Path := End_Path - 1;\n+            end if;\n+         end loop;\n+\n+         --  Find the end of the current field: last character or the one\n+         --  preceding the next directory separator.\n+\n+         while Finish < End_Path\n+           and then Path_Buffer (Finish + 1) /= Directory_Separator\n+         loop\n+            Finish := Finish + 1;\n+         end loop;\n+\n+         --  Remove \".\" field\n+\n+         if Start = Finish and then Path_Buffer (Start) = '.' then\n+            if Start = End_Path then\n+               if Last = 1 then\n+                  return (1 => Directory_Separator);\n+               else\n+\n+                  if Fold_To_Lower_Case then\n+                     System.Case_Util.To_Lower (Path_Buffer (1 .. Last - 1));\n+                  end if;\n+\n+                  return Path_Buffer (1 .. Last - 1);\n+\n+               end if;\n+\n+            else\n+               Path_Buffer (Last + 1 .. End_Path - 2) :=\n+                 Path_Buffer (Last + 3 .. End_Path);\n+               End_Path := End_Path - 2;\n+            end if;\n+\n+         --  Remove \"..\" fields\n+\n+         elsif Finish = Start + 1\n+           and then Path_Buffer (Start .. Finish) = \"..\"\n+         then\n+            Start := Last;\n+            loop\n+               Start := Start - 1;\n+               exit when Start < 1 or else\n+                 Path_Buffer (Start) = Directory_Separator;\n+            end loop;\n+\n+            if Start <= 1 then\n+               if Finish = End_Path then\n+                  return (1 => Directory_Separator);\n+\n+               else\n+                  Path_Buffer (1 .. End_Path - Finish) :=\n+                    Path_Buffer (Finish + 1 .. End_Path);\n+                  End_Path := End_Path - Finish;\n+                  Last := 1;\n+               end if;\n+\n+            else\n+               if Finish = End_Path then\n+                  return Final_Value (Path_Buffer (1 .. Start - 1));\n+\n+               else\n+                  Path_Buffer (Start + 1 .. Start + End_Path - Finish - 1) :=\n+                    Path_Buffer (Finish + 2 .. End_Path);\n+                  End_Path := Start + End_Path - Finish - 1;\n+                  Last := Start;\n+               end if;\n+            end if;\n+\n+         --  Check if current field is a symbolic link\n+\n+         elsif Resolve_Links then\n+            declare\n+               Saved : constant Character := Path_Buffer (Finish + 1);\n+\n+            begin\n+               Path_Buffer (Finish + 1) := ASCII.NUL;\n+               Status := Readlink (Path_Buffer'Address,\n+                                   Link_Buffer'Address,\n+                                   Link_Buffer'Length);\n+               Path_Buffer (Finish + 1) := Saved;\n+            end;\n+\n+            --  Not a symbolic link, move to the next field, if any\n+\n+            if Status <= 0 then\n+               Last := Finish + 1;\n+\n+            --  Replace symbolic link with its value\n+\n+            else\n+               if Is_Absolute_Path (Link_Buffer (1 .. Status)) then\n+                  Path_Buffer (Status + 1 .. End_Path - (Finish - Status)) :=\n+                  Path_Buffer (Finish + 1 .. End_Path);\n+                  End_Path := End_Path - (Finish - Status);\n+                  Path_Buffer (1 .. Status) := Link_Buffer (1 .. Status);\n+                  Last := 1;\n+\n+               else\n+                  Path_Buffer\n+                    (Last + Status + 1 .. End_Path - Finish + Last + Status) :=\n+                    Path_Buffer (Finish + 1 .. End_Path);\n+                  End_Path := End_Path - Finish + Last + Status;\n+                  Path_Buffer (Last + 1 .. Last + Status) :=\n+                    Link_Buffer (1 .. Status);\n+               end if;\n+            end if;\n+\n+         else\n+            Last := Finish + 1;\n+         end if;\n+      end loop;\n+\n+      --  Too many iterations: give up\n+\n+      --  This can happen when there is a circularity in the symbolic links: A\n+      --  is a symbolic link for B, which itself is a symbolic link, and the\n+      --  target of B or of another symbolic link target of B is A. In this\n+      --  case, we return an empty string to indicate failure to resolve.\n+\n+      return \"\";\n+   end Normalize_Pathname;\n+\n+   ---------------\n+   -- Open_Read --\n+   ---------------\n+\n+   function Open_Read\n+     (Name  : C_File_Name;\n+      Fmode : Mode) return File_Descriptor\n+   is\n+      function C_Open_Read\n+        (Name  : C_File_Name;\n+         Fmode : Mode) return File_Descriptor;\n+      pragma Import (C, C_Open_Read, \"__gnat_open_read\");\n+   begin\n+      return C_Open_Read (Name, Fmode);\n+   end Open_Read;\n+\n+   function Open_Read\n+     (Name  : String;\n+      Fmode : Mode) return File_Descriptor\n+   is\n+      C_Name : String (1 .. Name'Length + 1);\n+   begin\n+      C_Name (1 .. Name'Length) := Name;\n+      C_Name (C_Name'Last)      := ASCII.NUL;\n+      return Open_Read (C_Name (C_Name'First)'Address, Fmode);\n+   end Open_Read;\n+\n+   ---------------------\n+   -- Open_Read_Write --\n+   ---------------------\n+\n+   function Open_Read_Write\n+     (Name  : C_File_Name;\n+      Fmode : Mode) return File_Descriptor\n+   is\n+      function C_Open_Read_Write\n+        (Name  : C_File_Name;\n+         Fmode : Mode) return File_Descriptor;\n+      pragma Import (C, C_Open_Read_Write, \"__gnat_open_rw\");\n+   begin\n+      return C_Open_Read_Write (Name, Fmode);\n+   end Open_Read_Write;\n+\n+   function Open_Read_Write\n+     (Name  : String;\n+      Fmode : Mode) return File_Descriptor\n+   is\n+      C_Name : String (1 .. Name'Length + 1);\n+   begin\n+      C_Name (1 .. Name'Length) := Name;\n+      C_Name (C_Name'Last)      := ASCII.NUL;\n+      return Open_Read_Write (C_Name (C_Name'First)'Address, Fmode);\n+   end Open_Read_Write;\n+\n+   --------------------\n+   -- Pid_To_Integer --\n+   --------------------\n+\n+   function Pid_To_Integer (Pid : Process_Id) return Integer is\n+   begin\n+      return Integer (Pid);\n+   end Pid_To_Integer;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   function Read\n+     (FD : File_Descriptor;\n+      A  : System.Address;\n+      N  : Integer) return Integer\n+   is\n+   begin\n+      return Integer (System.CRTL.read\n+        (System.CRTL.int (FD), System.CRTL.chars (A), System.CRTL.int (N)));\n+   end Read;\n+\n+   -----------------\n+   -- Rename_File --\n+   -----------------\n+\n+   procedure Rename_File\n+     (Old_Name : C_File_Name;\n+      New_Name : C_File_Name;\n+      Success  : out Boolean)\n+   is\n+      function rename (From, To : Address) return Integer;\n+      pragma Import (C, rename, \"rename\");\n+      R : Integer;\n+   begin\n+      R := rename (Old_Name, New_Name);\n+      Success := (R = 0);\n+   end Rename_File;\n+\n+   procedure Rename_File\n+     (Old_Name : String;\n+      New_Name : String;\n+      Success  : out Boolean)\n+   is\n+      C_Old_Name : String (1 .. Old_Name'Length + 1);\n+      C_New_Name : String (1 .. New_Name'Length + 1);\n+   begin\n+      C_Old_Name (1 .. Old_Name'Length) := Old_Name;\n+      C_Old_Name (C_Old_Name'Last)      := ASCII.NUL;\n+      C_New_Name (1 .. New_Name'Length) := New_Name;\n+      C_New_Name (C_New_Name'Last)      := ASCII.NUL;\n+      Rename_File (C_Old_Name'Address, C_New_Name'Address, Success);\n+   end Rename_File;\n+\n+   -----------------------\n+   -- Set_Close_On_Exec --\n+   -----------------------\n+\n+   procedure Set_Close_On_Exec\n+     (FD            : File_Descriptor;\n+      Close_On_Exec : Boolean;\n+      Status        : out Boolean)\n+   is\n+      function C_Set_Close_On_Exec\n+        (FD : File_Descriptor; Close_On_Exec : System.CRTL.int)\n+         return System.CRTL.int;\n+      pragma Import (C, C_Set_Close_On_Exec, \"__gnat_set_close_on_exec\");\n+   begin\n+      Status := C_Set_Close_On_Exec (FD, Boolean'Pos (Close_On_Exec)) = 0;\n+   end Set_Close_On_Exec;\n+\n+   --------------------\n+   -- Set_Executable --\n+   --------------------\n+\n+   procedure Set_Executable (Name : String) is\n+      procedure C_Set_Executable (Name : C_File_Name);\n+      pragma Import (C, C_Set_Executable, \"__gnat_set_executable\");\n+      C_Name : aliased String (Name'First .. Name'Last + 1);\n+   begin\n+      C_Name (Name'Range)  := Name;\n+      C_Name (C_Name'Last) := ASCII.NUL;\n+      C_Set_Executable (C_Name (C_Name'First)'Address);\n+   end Set_Executable;\n+\n+   --------------------\n+   -- Set_Read_Only --\n+   --------------------\n+\n+   procedure Set_Read_Only (Name : String) is\n+      procedure C_Set_Read_Only (Name : C_File_Name);\n+      pragma Import (C, C_Set_Read_Only, \"__gnat_set_readonly\");\n+      C_Name : aliased String (Name'First .. Name'Last + 1);\n+   begin\n+      C_Name (Name'Range)  := Name;\n+      C_Name (C_Name'Last) := ASCII.NUL;\n+      C_Set_Read_Only (C_Name (C_Name'First)'Address);\n+   end Set_Read_Only;\n+\n+   --------------------\n+   -- Set_Writable --\n+   --------------------\n+\n+   procedure Set_Writable (Name : String) is\n+      procedure C_Set_Writable (Name : C_File_Name);\n+      pragma Import (C, C_Set_Writable, \"__gnat_set_writable\");\n+      C_Name : aliased String (Name'First .. Name'Last + 1);\n+   begin\n+      C_Name (Name'Range)  := Name;\n+      C_Name (C_Name'Last) := ASCII.NUL;\n+      C_Set_Writable (C_Name (C_Name'First)'Address);\n+   end Set_Writable;\n+\n+   ------------\n+   -- Setenv --\n+   ------------\n+\n+   procedure Setenv (Name : String; Value : String) is\n+      F_Name  : String (1 .. Name'Length + 1);\n+      F_Value : String (1 .. Value'Length + 1);\n+\n+      procedure Set_Env_Value (Name, Value : System.Address);\n+      pragma Import (C, Set_Env_Value, \"__gnat_setenv\");\n+\n+   begin\n+      F_Name (1 .. Name'Length) := Name;\n+      F_Name (F_Name'Last)      := ASCII.NUL;\n+\n+      F_Value (1 .. Value'Length) := Value;\n+      F_Value (F_Value'Last)      := ASCII.NUL;\n+\n+      Set_Env_Value (F_Name'Address, F_Value'Address);\n+   end Setenv;\n+\n+   -----------\n+   -- Spawn --\n+   -----------\n+\n+   function Spawn\n+     (Program_Name : String;\n+      Args         : Argument_List) return Integer\n+   is\n+      Junk   : Process_Id;\n+      Result : Integer;\n+   begin\n+      Spawn_Internal (Program_Name, Args, Result, Junk, Blocking => True);\n+      return Result;\n+   end Spawn;\n+\n+   procedure Spawn\n+     (Program_Name : String;\n+      Args         : Argument_List;\n+      Success      : out Boolean)\n+   is\n+   begin\n+      Success := (Spawn (Program_Name, Args) = 0);\n+   end Spawn;\n+\n+   procedure Spawn\n+     (Program_Name           : String;\n+      Args                   : Argument_List;\n+      Output_File_Descriptor : File_Descriptor;\n+      Return_Code            : out Integer;\n+      Err_To_Out             : Boolean := True)\n+   is\n+      Saved_Output : File_Descriptor;\n+      Saved_Error  : File_Descriptor := Invalid_FD; -- prevent compiler warning\n+\n+   begin\n+      --  Set standard output and error to the temporary file\n+\n+      Saved_Output := Dup (Standout);\n+      Dup2 (Output_File_Descriptor, Standout);\n+\n+      if Err_To_Out then\n+         Saved_Error  := Dup (Standerr);\n+         Dup2 (Output_File_Descriptor, Standerr);\n+      end if;\n+\n+      --  Spawn the program\n+\n+      Return_Code := Spawn (Program_Name, Args);\n+\n+      --  Restore the standard output and error\n+\n+      Dup2 (Saved_Output, Standout);\n+\n+      if Err_To_Out then\n+         Dup2 (Saved_Error, Standerr);\n+      end if;\n+\n+      --  And close the saved standard output and error file descriptors\n+\n+      Close (Saved_Output);\n+\n+      if Err_To_Out then\n+         Close (Saved_Error);\n+      end if;\n+   end Spawn;\n+\n+   procedure Spawn\n+     (Program_Name  : String;\n+      Args          : Argument_List;\n+      Output_File   : String;\n+      Success       : out Boolean;\n+      Return_Code   : out Integer;\n+      Err_To_Out    : Boolean := True)\n+   is\n+      FD : File_Descriptor;\n+\n+   begin\n+      Success := True;\n+      Return_Code := 0;\n+\n+      FD := Create_Output_Text_File (Output_File);\n+\n+      if FD = Invalid_FD then\n+         Success := False;\n+         return;\n+      end if;\n+\n+      Spawn (Program_Name, Args, FD, Return_Code, Err_To_Out);\n+\n+      Close (FD, Success);\n+   end Spawn;\n+\n+   --------------------\n+   -- Spawn_Internal --\n+   --------------------\n+\n+   procedure Spawn_Internal\n+     (Program_Name : String;\n+      Args         : Argument_List;\n+      Result       : out Integer;\n+      Pid          : out Process_Id;\n+      Blocking     : Boolean)\n+   is\n+\n+      procedure Spawn (Args : Argument_List);\n+      --  Call Spawn with given argument list\n+\n+      N_Args : Argument_List (Args'Range);\n+      --  Normalized arguments\n+\n+      -----------\n+      -- Spawn --\n+      -----------\n+\n+      procedure Spawn (Args : Argument_List) is\n+         type Chars is array (Positive range <>) of aliased Character;\n+         type Char_Ptr is access constant Character;\n+\n+         Command_Len : constant Positive := Program_Name'Length + 1\n+                                              + Args_Length (Args);\n+         Command_Last : Natural := 0;\n+         Command : aliased Chars (1 .. Command_Len);\n+         --  Command contains all characters of the Program_Name and Args, all\n+         --  terminated by ASCII.NUL characters\n+\n+         Arg_List_Len : constant Positive := Args'Length + 2;\n+         Arg_List_Last : Natural := 0;\n+         Arg_List : aliased array (1 .. Arg_List_Len) of Char_Ptr;\n+         --  List with pointers to NUL-terminated strings of the Program_Name\n+         --  and the Args and terminated with a null pointer. We rely on the\n+         --  default initialization for the last null pointer.\n+\n+         procedure Add_To_Command (S : String);\n+         --  Add S and a NUL character to Command, updating Last\n+\n+         function Portable_Spawn (Args : Address) return Integer;\n+         pragma Import (C, Portable_Spawn, \"__gnat_portable_spawn\");\n+\n+         function Portable_No_Block_Spawn (Args : Address) return Process_Id;\n+         pragma Import\n+           (C, Portable_No_Block_Spawn, \"__gnat_portable_no_block_spawn\");\n+\n+         --------------------\n+         -- Add_To_Command --\n+         --------------------\n+\n+         procedure Add_To_Command (S : String) is\n+            First : constant Natural := Command_Last + 1;\n+\n+         begin\n+            Command_Last := Command_Last + S'Length;\n+\n+            --  Move characters one at a time, because Command has aliased\n+            --  components.\n+\n+            --  But not volatile, so why is this necessary ???\n+\n+            for J in S'Range loop\n+               Command (First + J - S'First) := S (J);\n+            end loop;\n+\n+            Command_Last := Command_Last + 1;\n+            Command (Command_Last) := ASCII.NUL;\n+\n+            Arg_List_Last := Arg_List_Last + 1;\n+            Arg_List (Arg_List_Last) := Command (First)'Access;\n+         end Add_To_Command;\n+\n+      --  Start of processing for Spawn\n+\n+      begin\n+         Add_To_Command (Program_Name);\n+\n+         for J in Args'Range loop\n+            Add_To_Command (Args (J).all);\n+         end loop;\n+\n+         if Blocking then\n+            Pid     := Invalid_Pid;\n+            Result  := Portable_Spawn (Arg_List'Address);\n+         else\n+            Pid     := Portable_No_Block_Spawn (Arg_List'Address);\n+            Result  := Boolean'Pos (Pid /= Invalid_Pid);\n+         end if;\n+      end Spawn;\n+\n+   --  Start of processing for Spawn_Internal\n+\n+   begin\n+      --  Copy arguments into a local structure\n+\n+      for K in N_Args'Range loop\n+         N_Args (K) := new String'(Args (K).all);\n+      end loop;\n+\n+      --  Normalize those arguments\n+\n+      Normalize_Arguments (N_Args);\n+\n+      --  Call spawn using the normalized arguments\n+\n+      Spawn (N_Args);\n+\n+      --  Free arguments list\n+\n+      for K in N_Args'Range loop\n+         Free (N_Args (K));\n+      end loop;\n+   end Spawn_Internal;\n+\n+   ---------------------------\n+   -- To_Path_String_Access --\n+   ---------------------------\n+\n+   function To_Path_String_Access\n+     (Path_Addr : Address;\n+      Path_Len  : Integer) return String_Access\n+   is\n+      subtype Path_String is String (1 .. Path_Len);\n+      type    Path_String_Access is access Path_String;\n+\n+      function Address_To_Access is new\n+        Ada.Unchecked_Conversion (Source => Address,\n+                              Target => Path_String_Access);\n+\n+      Path_Access : constant Path_String_Access :=\n+                      Address_To_Access (Path_Addr);\n+\n+      Return_Val  : String_Access;\n+\n+   begin\n+      Return_Val := new String (1 .. Path_Len);\n+\n+      for J in 1 .. Path_Len loop\n+         Return_Val (J) := Path_Access (J);\n+      end loop;\n+\n+      return Return_Val;\n+   end To_Path_String_Access;\n+\n+   ------------------\n+   -- Wait_Process --\n+   ------------------\n+\n+   procedure Wait_Process (Pid : out Process_Id; Success : out Boolean) is\n+      Status : Integer;\n+\n+      function Portable_Wait (S : Address) return Process_Id;\n+      pragma Import (C, Portable_Wait, \"__gnat_portable_wait\");\n+\n+   begin\n+      Pid := Portable_Wait (Status'Address);\n+      Success := (Status = 0);\n+   end Wait_Process;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   function Write\n+     (FD : File_Descriptor;\n+      A  : System.Address;\n+      N  : Integer) return Integer\n+   is\n+   begin\n+      return Integer (System.CRTL.write\n+        (System.CRTL.int (FD), System.CRTL.chars (A), System.CRTL.int (N)));\n+   end Write;\n+\n+end System.OS_Lib;"}, {"sha": "2d624cfc73322da4743a251e1dd0ce9f091e2c29", "filename": "gcc/ada/s-os_lib.ads", "status": "added", "additions": 871, "deletions": 0, "changes": 871, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-os_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-os_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-os_lib.ads?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -0,0 +1,871 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                        S Y S T E M . O S _ L I B                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1995-2007, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Operating system interface facilities\n+\n+--  This package contains types and procedures for interfacing to the\n+--  underlying OS. It is used by the GNAT compiler and by tools associated\n+--  with the GNAT compiler, and therefore works for the various operating\n+--  systems to which GNAT has been ported. This package will undoubtedly grow\n+--  as new services are needed by various tools.\n+\n+--  This package tends to use fairly low-level Ada in order to not bring in\n+--  large portions of the RTL. For example, functions return access to string\n+--  as part of avoiding functions returning unconstrained types.\n+\n+--  Except where specifically noted, these routines are portable across all\n+--  GNAT implementations on all supported operating systems.\n+\n+--  Note: this package is in the System hierarchy so that it can be directly\n+--  be used by other predefined packages. User access to this package is via\n+--  a renaming of this package in GNAT.OS_Lib (file g-os_lib.ads).\n+\n+with System;\n+with System.Strings;\n+\n+package System.OS_Lib is\n+   pragma Elaborate_Body (OS_Lib);\n+\n+   -----------------------\n+   -- String Operations --\n+   -----------------------\n+\n+   --  These are reexported from package Strings (which was introduced to\n+   --  avoid different packages declarting different types unnecessarily).\n+   --  See package System.Strings for details.\n+\n+   subtype String_Access is Strings.String_Access;\n+\n+   function \"=\" (Left, Right : String_Access) return Boolean\n+     renames Strings.\"=\";\n+\n+   procedure Free (X : in out String_Access) renames Strings.Free;\n+\n+   subtype String_List is Strings.String_List;\n+\n+   function \"=\" (Left, Right : String_List) return Boolean\n+     renames Strings.\"=\";\n+\n+   function \"&\" (Left : String_Access; Right : String_Access)\n+     return String_List renames Strings.\"&\";\n+   function \"&\" (Left : String_Access; Right : String_List)\n+     return String_List renames Strings.\"&\";\n+   function \"&\" (Left : String_List; Right : String_Access)\n+     return String_List renames Strings.\"&\";\n+   function \"&\" (Left : String_List; Right : String_List)\n+     return String_List renames Strings.\"&\";\n+\n+   subtype String_List_Access is Strings.String_List_Access;\n+\n+   function \"=\" (Left, Right : String_List_Access) return Boolean\n+     renames Strings.\"=\";\n+\n+   procedure Free (Arg : in out String_List_Access)\n+     renames Strings.Free;\n+\n+   ---------------------\n+   -- Time/Date Stuff --\n+   ---------------------\n+\n+   type OS_Time is private;\n+   --  The OS's notion of time is represented by the private type OS_Time.\n+   --  This is the type returned by the File_Time_Stamp functions to obtain\n+   --  the time stamp of a specified file. Functions and a procedure (modeled\n+   --  after the similar subprograms in package Calendar) are provided for\n+   --  extracting information from a value of this type. Although these are\n+   --  called GM, the intention is not that they provide GMT times in all\n+   --  cases but rather the actual (time-zone independent) time stamp of the\n+   --  file (of course in Unix systems, this *is* in GMT form).\n+\n+   Invalid_Time : constant OS_Time;\n+   --  A special unique value used to flag an invalid time stamp value\n+\n+   subtype Year_Type   is Integer range 1900 .. 2099;\n+   subtype Month_Type  is Integer range    1 ..   12;\n+   subtype Day_Type    is Integer range    1 ..   31;\n+   subtype Hour_Type   is Integer range    0 ..   23;\n+   subtype Minute_Type is Integer range    0 ..   59;\n+   subtype Second_Type is Integer range    0 ..   59;\n+   --  Declarations similar to those in Calendar, breaking down the time\n+\n+   function Current_Time return OS_Time;\n+   --  Return the system clock value as OS_Time\n+\n+   function GM_Year    (Date : OS_Time) return Year_Type;\n+   function GM_Month   (Date : OS_Time) return Month_Type;\n+   function GM_Day     (Date : OS_Time) return Day_Type;\n+   function GM_Hour    (Date : OS_Time) return Hour_Type;\n+   function GM_Minute  (Date : OS_Time) return Minute_Type;\n+   function GM_Second  (Date : OS_Time) return Second_Type;\n+   --  Functions to extract information from OS_Time value\n+\n+   function \"<\"  (X, Y : OS_Time) return Boolean;\n+   function \">\"  (X, Y : OS_Time) return Boolean;\n+   function \">=\" (X, Y : OS_Time) return Boolean;\n+   function \"<=\" (X, Y : OS_Time) return Boolean;\n+   --  Basic comparison operators on OS_Time with obvious meanings. Note that\n+   --  these have Intrinsic convention, so for example it is not permissible\n+   --  to create accesses to any of these functions.\n+\n+   procedure GM_Split\n+     (Date   : OS_Time;\n+      Year   : out Year_Type;\n+      Month  : out Month_Type;\n+      Day    : out Day_Type;\n+      Hour   : out Hour_Type;\n+      Minute : out Minute_Type;\n+      Second : out Second_Type);\n+   --  Analogous to the Split routine in Ada.Calendar, takes an OS_Time\n+   --  and provides a representation of it as a set of component parts,\n+   --  to be interpreted as a date point in UTC.\n+\n+   ----------------\n+   -- File Stuff --\n+   ----------------\n+\n+   --  These routines give access to the open/creat/close/read/write level of\n+   --  I/O routines in the typical C library (these functions are not part of\n+   --  the ANSI C standard, but are typically available in all systems). See\n+   --  also package Interfaces.C_Streams for access to the stream level\n+   --  routines.\n+\n+   --  Note on file names. If a file name is passed as type String in any of\n+   --  the following specifications, then the name is a normal Ada string and\n+   --  need not be NUL-terminated. However, a trailing NUL character is\n+   --  permitted, and will be ignored (more accurately, the NUL and any\n+   --  characters that follow it will be ignored).\n+\n+   type File_Descriptor is new Integer;\n+   --  Corresponds to the int file handle values used in the C routines\n+\n+   Standin  : constant File_Descriptor := 0;\n+   Standout : constant File_Descriptor := 1;\n+   Standerr : constant File_Descriptor := 2;\n+   --  File descriptors for standard input output files\n+\n+   Invalid_FD : constant File_Descriptor := -1;\n+   --  File descriptor returned when error in opening/creating file;\n+\n+   type Mode is (Binary, Text);\n+   for Mode'Size use Integer'Size;\n+   for Mode use (Binary => 0, Text => 1);\n+   --  Used in all the Open and Create calls to specify if the file is to be\n+   --  opened in binary mode or text mode. In systems like Unix, this has no\n+   --  effect, but in systems capable of text mode translation, the use of\n+   --  Text as the mode parameter causes the system to do CR/LF translation\n+   --  and also to recognize the DOS end of file character on input. The use\n+   --  of Text where appropriate allows programs to take a portable Unix view\n+   --  of DOS-format files and process them appropriately.\n+\n+   function Open_Read\n+     (Name  : String;\n+      Fmode : Mode) return File_Descriptor;\n+   --  Open file Name for reading, returning file descriptor File descriptor\n+   --  returned is Invalid_FD if file cannot be opened.\n+\n+   function Open_Read_Write\n+     (Name  : String;\n+      Fmode : Mode) return File_Descriptor;\n+   --  Open file Name for both reading and writing, returning file descriptor.\n+   --  File descriptor returned is Invalid_FD if file cannot be opened.\n+\n+   function Create_File\n+     (Name  : String;\n+      Fmode : Mode) return File_Descriptor;\n+   --  Creates new file with given name for writing, returning file descriptor\n+   --  for subsequent use in Write calls. File descriptor returned is\n+   --  Invalid_FD if file cannot be successfully created.\n+\n+   function Create_Output_Text_File (Name : String) return File_Descriptor;\n+   --  Creates new text file with given name suitable to redirect standard\n+   --  output, returning file descriptor. File descriptor returned is\n+   --  Invalid_FD if file cannot be successfully created.\n+\n+   function Create_New_File\n+     (Name  : String;\n+      Fmode : Mode) return File_Descriptor;\n+   --  Create new file with given name for writing, returning file descriptor\n+   --  for subsequent use in Write calls. This differs from Create_File in\n+   --  that it fails if the file already exists. File descriptor returned is\n+   --  Invalid_FD if the file exists or cannot be created.\n+\n+   Temp_File_Len : constant Integer := 12;\n+   --  Length of name returned by Create_Temp_File call (GNAT-XXXXXX & NUL)\n+\n+   subtype Temp_File_Name is String (1 .. Temp_File_Len);\n+   --  String subtype set by Create_Temp_File\n+\n+   procedure Create_Temp_File\n+     (FD   : out File_Descriptor;\n+      Name : out Temp_File_Name);\n+   --  Create and open for writing a temporary file in the current working\n+   --  directory. The name of the file and the File Descriptor are returned.\n+   --  The File Descriptor returned is Invalid_FD in the case of failure. No\n+   --  mode parameter is provided. Since this is a temporary file, there is no\n+   --  point in doing text translation on it.\n+   --\n+   --  On some OSes, the maximum number of temp files that can be created with\n+   --  this procedure may be limited. When the maximum is reached, this\n+   --  procedure returns Invalid_FD. On some OSes, there may be a race\n+   --  condition between processes trying to create temp files at the same\n+   --  time in the same directory using this procedure.\n+\n+   procedure Create_Temp_File\n+     (FD   : out File_Descriptor;\n+      Name : out String_Access);\n+   --  Create and open for writing a temporary file in the current working\n+   --  directory. The name of the file and the File Descriptor are returned.\n+   --  No mode parameter is provided. Since this is a temporary file, there is\n+   --  no point in doing text translation on it. It is the responsibility of\n+   --  the caller to deallocate the access value returned in Name.\n+   --\n+   --  This procedure will always succeed if the current working directory is\n+   --  writable. If the current working directory is not writable, then\n+   --  Invalid_FD is returned for the file descriptor and null for the Name.\n+   --  There is no race condition problem between processes trying to create\n+   --  temp files at the same time in the same directory.\n+\n+   procedure Close (FD : File_Descriptor; Status : out Boolean);\n+   --  Close file referenced by FD. Status is False if the underlying service\n+   --  failed. Reasons for failure include: disk full, disk quotas exceeded\n+   --  and invalid file descriptor (the file may have been closed twice).\n+\n+   procedure Close (FD : File_Descriptor);\n+   --  Close file referenced by FD. This form is used when the caller wants to\n+   --  ignore any possible error (see above for error cases).\n+\n+   procedure Set_Close_On_Exec\n+     (FD            : File_Descriptor;\n+      Close_On_Exec : Boolean;\n+      Status        : out Boolean);\n+   --  When Close_On_Exec is True, mark FD to be closed automatically when new\n+   --  program is executed by the calling process (i.e. prevent FD from being\n+   --  inherited by child processes). When Close_On_Exec is False, mark FD to\n+   --  not be closed on exec (i.e. allow it to be inherited). Status is False\n+   --  if the operation could not be performed.\n+\n+   procedure Delete_File (Name : String; Success : out Boolean);\n+   --  Deletes file. Success is set True or False indicating if the delete is\n+   --  successful.\n+\n+   procedure Rename_File\n+     (Old_Name : String;\n+      New_Name : String;\n+      Success  : out Boolean);\n+   --  Rename a file. Success is set True or False indicating if the rename is\n+   --  successful or not.\n+\n+   --  The following defines the mode for the Copy_File procedure below. Note\n+   --  that \"time stamps and other file attributes\" in the descriptions below\n+   --  refers to the creation and last modification times, and also the file\n+   --  access (read/write/execute) status flags.\n+\n+   type Copy_Mode is\n+     (Copy,\n+      --  Copy the file. It is an error if the target file already exists. The\n+      --  time stamps and other file attributes are preserved in the copy.\n+\n+      Overwrite,\n+      --  If the target file exists, the file is replaced otherwise the file\n+      --  is just copied. The time stamps and other file attributes are\n+      --  preserved in the copy.\n+\n+      Append);\n+      --  If the target file exists, the contents of the source file is\n+      --  appended at the end. Otherwise the source file is just copied. The\n+      --  time stamps and other file attributes are are preserved if the\n+      --  destination file does not exist.\n+\n+   type Attribute is\n+     (Time_Stamps,\n+      --  Copy time stamps from source file to target file. All other\n+      --  attributes are set to normal default values for file creation.\n+\n+      Full,\n+      --  All attributes are copied from the source file to the target file.\n+      --  This includes the timestamps, and for example also includes\n+      --  read/write/execute attributes in Unix systems.\n+\n+      None);\n+      --  No attributes are copied. All attributes including the time stamp\n+      --  values are set to normal default values for file creation.\n+\n+   --  Note: The default is Time_Stamps, which corresponds to the normal\n+   --  default on Windows style systems. Full corresponds to the typical\n+   --  effect of \"cp -p\" on Unix systems, and None corresponds to the typical\n+   --  effect of \"cp\" on Unix systems.\n+\n+   --  Note: Time_Stamps and Full are not supported on VMS and VxWorks\n+\n+   procedure Copy_File\n+     (Name     : String;\n+      Pathname : String;\n+      Success  : out Boolean;\n+      Mode     : Copy_Mode := Copy;\n+      Preserve : Attribute := Time_Stamps);\n+   --  Copy a file. Name must designate a single file (no wild cards allowed).\n+   --  Pathname can be a filename or directory name. In the latter case Name\n+   --  is copied into the directory preserving the same file name. Mode\n+   --  defines the kind of copy, see above with the default being a normal\n+   --  copy in which the target file must not already exist. Success is set to\n+   --  True or False indicating if the copy is successful (depending on the\n+   --  specified Mode).\n+   --\n+   --  Note: this procedure is only supported to a very limited extent on VMS.\n+   --  The only supported mode is Overwrite, and the only supported value for\n+   --  Preserve is None, resulting in the default action which for Overwrite\n+   --  is to leave attributes unchanged. Furthermore, the copy only works for\n+   --  simple text files.\n+\n+   procedure Copy_Time_Stamps (Source, Dest : String; Success : out Boolean);\n+   --  Copy Source file time stamps (last modification and last access time\n+   --  stamps) to Dest file. Source and Dest must be valid filenames,\n+   --  furthermore Dest must be writable. Success will be set to True if the\n+   --  operation was successful and False otherwise.\n+   --\n+   --  Note: this procedure is not supported on VMS and VxWorks. On these\n+   --  platforms, Success is always set to False.\n+\n+   function Read\n+     (FD : File_Descriptor;\n+      A  : System.Address;\n+      N  : Integer) return Integer;\n+   --  Read N bytes to address A from file referenced by FD. Returned value is\n+   --  count of bytes actually read, which can be less than N at EOF.\n+\n+   function Write\n+     (FD : File_Descriptor;\n+      A  : System.Address;\n+      N  : Integer) return Integer;\n+   --  Write N bytes from address A to file referenced by FD. The returned\n+   --  value is the number of bytes written, which can be less than N if a\n+   --  disk full condition was detected.\n+\n+   Seek_Cur : constant := 1;\n+   Seek_End : constant := 2;\n+   Seek_Set : constant := 0;\n+   --  Used to indicate origin for Lseek call\n+\n+   procedure Lseek\n+     (FD     : File_Descriptor;\n+      offset : Long_Integer;\n+      origin : Integer);\n+   pragma Import (C, Lseek, \"__gnat_lseek\");\n+   --  Sets the current file pointer to the indicated offset value, relative\n+   --  to the current position (origin = SEEK_CUR), end of file (origin =\n+   --  SEEK_END), or start of file (origin = SEEK_SET).\n+\n+   function File_Length (FD : File_Descriptor) return Long_Integer;\n+   pragma Import (C, File_Length, \"__gnat_file_length\");\n+   --  Get length of file from file descriptor FD\n+\n+   function File_Time_Stamp (Name : String) return OS_Time;\n+   --  Given the name of a file or directory, Name, obtains and returns the\n+   --  time stamp. This function can be used for an unopened file. Returns\n+   --  Invalid_Time is Name doesn't correspond to an existing file.\n+\n+   function File_Time_Stamp (FD : File_Descriptor) return OS_Time;\n+   --  Get time stamp of file from file descriptor FD Returns Invalid_Time is\n+   --  FD doesn't correspond to an existing file.\n+\n+   function Normalize_Pathname\n+     (Name           : String;\n+      Directory      : String  := \"\";\n+      Resolve_Links  : Boolean := True;\n+      Case_Sensitive : Boolean := True) return String;\n+   --  Returns a file name as an absolute path name, resolving all relative\n+   --  directories, and symbolic links. The parameter Directory is a fully\n+   --  resolved path name for a directory, or the empty string (the default).\n+   --  Name is the name of a file, which is either relative to the given\n+   --  directory name, if Directory is non-null, or to the current working\n+   --  directory if Directory is null. The result returned is the normalized\n+   --  name of the file. For most cases, if two file names designate the same\n+   --  file through different paths, Normalize_Pathname will return the same\n+   --  canonical name in both cases. However, there are cases when this is not\n+   --  true; for example, this is not true in Unix for two hard links\n+   --  designating the same file.\n+   --\n+   --  On Windows, the returned path will start with a drive letter except\n+   --  when Directory is not empty and does not include a drive letter. If\n+   --  Directory is empty (the default) and Name is a relative path or an\n+   --  absolute path without drive letter, the letter of the current drive\n+   --  will start the returned path. If Case_Sensitive is True (the default),\n+   --  then this drive letter will be forced to upper case (\"C:\\...\").\n+   --\n+   --  If Resolve_Links is set to True, then the symbolic links, on systems\n+   --  that support them, will be fully converted to the name of the file or\n+   --  directory pointed to. This is slightly less efficient, since it\n+   --  requires system calls.\n+   --\n+   --  If Name cannot be resolved or is null on entry (for example if there is\n+   --  symbolic link circularity, e.g. A is a symbolic link for B, and B is a\n+   --  symbolic link for A), then Normalize_Pathname returns an empty  string.\n+   --\n+   --  In VMS, if Name follows the VMS syntax file specification, it is first\n+   --  converted into Unix syntax. If the conversion fails, Normalize_Pathname\n+   --  returns an empty string.\n+   --\n+   --  For case-sensitive file systems, the value of Case_Sensitive parameter\n+   --  is ignored. For file systems that are not case-sensitive, such as\n+   --  Windows and OpenVMS, if this parameter is set to False, then the file\n+   --  and directory names are folded to lower case. This allows checking\n+   --  whether two files are the same by applying this function to their names\n+   --  and comparing the results. If Case_Sensitive is set to True, this\n+   --  function does not change the casing of file and directory names.\n+\n+   function Is_Absolute_Path (Name : String) return Boolean;\n+   --  Returns True if Name is an absolute path name, i.e. it designates a\n+   --  file or directory absolutely rather than relative to another directory.\n+\n+   function Is_Regular_File (Name : String) return Boolean;\n+   --  Determines if the given string, Name, is the name of an existing\n+   --  regular file. Returns True if so, False otherwise. Name may be an\n+   --  absolute path name or a relative path name, including a simple file\n+   --  name. If it is a relative path name, it is relative to the current\n+   --  working directory.\n+\n+   function Is_Directory (Name : String) return Boolean;\n+   --  Determines if the given string, Name, is the name of a directory.\n+   --  Returns True if so, False otherwise. Name may be an absolute path\n+   --  name or a relative path name, including a simple file name. If it is\n+   --  a relative path name, it is relative to the current working directory.\n+\n+   function Is_Readable_File (Name : String) return Boolean;\n+   --  Determines if the given string, Name, is the name of an existing file\n+   --  that is readable. Returns True if so, False otherwise. Note that this\n+   --  function simply interrogates the file attributes (e.g. using the C\n+   --  function stat), so it does not indicate a situation in which a file may\n+   --  not actually be readable due to some other process having exclusive\n+   --  access.\n+\n+   function Is_Writable_File (Name : String) return Boolean;\n+   --  Determines if the given string, Name, is the name of an existing file\n+   --  that is writable. Returns True if so, False otherwise. Note that this\n+   --  function simply interrogates the file attributes (e.g. using the C\n+   --  function stat), so it does not indicate a situation in which a file may\n+   --  not actually be writeable due to some other process having exclusive\n+   --  access.\n+\n+   function Is_Symbolic_Link (Name : String) return Boolean;\n+   --  Determines if the given string, Name, is the path of a symbolic link on\n+   --  systems that support it. Returns True if so, False if the path is not a\n+   --  symbolic link or if the system does not support symbolic links.\n+   --\n+   --  A symbolic link is an indirect pointer to a file; its directory entry\n+   --  contains the name of the file to which it is linked. Symbolic links may\n+   --  span file systems and may refer to directories.\n+\n+   procedure Set_Writable (Name : String);\n+   --  Change the permissions on the named file to make it writable\n+   --  for its owner.\n+\n+   procedure Set_Read_Only (Name : String);\n+   --  Change the permissions on the named file to make it non-writable\n+   --  for its owner.\n+\n+   procedure Set_Executable (Name : String);\n+   --  Change the permissions on the named file to make it executable\n+   --  for its owner.\n+\n+   function Locate_Exec_On_Path\n+     (Exec_Name : String) return String_Access;\n+   --  Try to locate an executable whose name is given by Exec_Name in the\n+   --  directories listed in the environment Path. If the Exec_Name doesn't\n+   --  have the executable suffix, it will be appended before the search.\n+   --  Otherwise works like Locate_Regular_File below.\n+   --\n+   --  Note that this function allocates some memory for the returned value.\n+   --  This memory needs to be deallocated after use.\n+\n+   function Locate_Regular_File\n+     (File_Name : String;\n+      Path      : String) return String_Access;\n+   --  Try to locate a regular file whose name is given by File_Name in the\n+   --  directories listed in Path. If a file is found, its full pathname is\n+   --  returned; otherwise, a null pointer is returned. If the File_Name given\n+   --  is an absolute pathname, then Locate_Regular_File just checks that the\n+   --  file exists and is a regular file. Otherwise, if the File_Name given\n+   --  includes directory information, Locate_Regular_File first checks if the\n+   --  file exists relative to the current directory. If it does not, or if\n+   --  the File_Name given is a simple file name, the Path argument is parsed\n+   --  according to OS conventions, and for each directory in the Path a check\n+   --  is made if File_Name is a relative pathname of a regular file from that\n+   --  directory.\n+   --\n+   --  Note that this function allocates some memory for the returned value.\n+   --  This memory needs to be deallocated after use.\n+\n+   function Get_Debuggable_Suffix return String_Access;\n+   --  Return the debuggable suffix convention. Usually this is the same as\n+   --  the convention for Get_Executable_Suffix. The result is allocated on\n+   --  the heap and should be freed after use to avoid storage leaks.\n+\n+   function Get_Target_Debuggable_Suffix return String_Access;\n+   --  Return the target debuggable suffix convention. Usually this is the\n+   --  same as the convention for Get_Executable_Suffix. The result is\n+   --  allocated on the heap and should be freed after use to avoid storage\n+   --  leaks.\n+\n+   function Get_Executable_Suffix return String_Access;\n+   --  Return the executable suffix convention. The result is allocated on the\n+   --  heap and should be freed after use to avoid storage leaks.\n+\n+   function Get_Object_Suffix return String_Access;\n+   --  Return the object suffix convention. The result is allocated on the heap\n+   --  and should be freed after use to avoid storage leaks.\n+\n+   function Get_Target_Executable_Suffix return String_Access;\n+   --  Return the target executable suffix convention. The result is allocated\n+   --  on the heap and should be freed after use to avoid storage leaks.\n+\n+   function Get_Target_Object_Suffix return String_Access;\n+   --  Return the target object suffix convention. The result is allocated on\n+   --  the heap and should be freed after use to avoid storage leaks.\n+\n+   --  The following section contains low-level routines using addresses to\n+   --  pass file name and executable name. In each routine the name must be\n+   --  Nul-Terminated. For complete documentation refer to the equivalent\n+   --  routine (using String in place of C_File_Name) defined above.\n+\n+   subtype C_File_Name is System.Address;\n+   --  This subtype is used to document that a parameter is the address of a\n+   --  null-terminated string containing the name of a file.\n+\n+   --  All the following functions need comments ???\n+\n+   function Open_Read\n+     (Name  : C_File_Name;\n+      Fmode : Mode) return File_Descriptor;\n+\n+   function Open_Read_Write\n+     (Name  : C_File_Name;\n+      Fmode : Mode) return File_Descriptor;\n+\n+   function Create_File\n+     (Name  : C_File_Name;\n+      Fmode : Mode) return File_Descriptor;\n+\n+   function Create_New_File\n+     (Name  : C_File_Name;\n+      Fmode : Mode) return File_Descriptor;\n+\n+   procedure Delete_File (Name : C_File_Name; Success : out Boolean);\n+\n+   procedure Rename_File\n+     (Old_Name : C_File_Name;\n+      New_Name : C_File_Name;\n+      Success  : out Boolean);\n+\n+   procedure Copy_File\n+     (Name     : C_File_Name;\n+      Pathname : C_File_Name;\n+      Success  : out Boolean;\n+      Mode     : Copy_Mode := Copy;\n+      Preserve : Attribute := Time_Stamps);\n+\n+   procedure Copy_Time_Stamps\n+     (Source, Dest : C_File_Name;\n+      Success      : out Boolean);\n+\n+   function File_Time_Stamp (Name : C_File_Name) return OS_Time;\n+   --  Returns Invalid_Time is Name doesn't correspond to an existing file\n+\n+   function Is_Regular_File (Name : C_File_Name) return Boolean;\n+   function Is_Directory (Name : C_File_Name) return Boolean;\n+   function Is_Readable_File (Name : C_File_Name) return Boolean;\n+   function Is_Writable_File (Name : C_File_Name) return Boolean;\n+   function Is_Symbolic_Link (Name : C_File_Name) return Boolean;\n+\n+   function Locate_Regular_File\n+     (File_Name : C_File_Name;\n+      Path      : C_File_Name) return String_Access;\n+\n+   ------------------\n+   -- Subprocesses --\n+   ------------------\n+\n+   subtype Argument_List is String_List;\n+   --  Type used for argument list in call to Spawn. The lower bound of the\n+   --  array should be 1, and the length of the array indicates the number of\n+   --  arguments.\n+\n+   subtype Argument_List_Access is String_List_Access;\n+   --  Type used to return Argument_List without dragging in secondary stack.\n+   --  Note that there is a Free procedure declared for this subtype which\n+   --  frees the array and all referenced strings.\n+\n+   procedure Normalize_Arguments (Args : in out Argument_List);\n+   --  Normalize all arguments in the list. This ensure that the argument list\n+   --  is compatible with the running OS and will works fine with Spawn and\n+   --  Non_Blocking_Spawn for example. If Normalize_Arguments is called twice\n+   --  on the same list it will do nothing the second time. Note that Spawn\n+   --  and Non_Blocking_Spawn call Normalize_Arguments automatically, but\n+   --  since there is a guarantee that a second call does nothing, this\n+   --  internal call will have no effect if Normalize_Arguments is called\n+   --  before calling Spawn. The call to Normalize_Arguments assumes that the\n+   --  individual referenced arguments in Argument_List are on the heap, and\n+   --  may free them and reallocate if they are modified.\n+\n+   procedure Spawn\n+     (Program_Name : String;\n+      Args         : Argument_List;\n+      Success      : out Boolean);\n+   --  This procedure spawns a program with a given list of arguments. The\n+   --  first parameter of is the name of the executable. The second parameter\n+   --  contains the arguments to be passed to this program. Success is False\n+   --  if the named program could not be spawned or its execution completed\n+   --  unsuccessfully. Note that the caller will be blocked until the\n+   --  execution of the spawned program is complete. For maximum portability,\n+   --  use a full path name for the Program_Name argument. On some systems\n+   --  (notably Unix systems) a simple file name may also work (if the\n+   --  executable can be located in the path).\n+   --\n+   --  \"Spawn\" should not be used in tasking applications. Why not??? More\n+   --  documentation would be helpful here ??? Is it really tasking programs,\n+   --  or tasking activity that cause trouble ???\n+   --\n+   --  Note: Arguments in Args that contain spaces and/or quotes such as\n+   --  \"--GCC=gcc -v\" or \"--GCC=\"\"gcc -v\"\"\" are not portable across all\n+   --  operating systems, and would not have the desired effect if they were\n+   --  passed directly to the operating system. To avoid this problem, Spawn\n+   --  makes an internal call to Normalize_Arguments, which ensures that such\n+   --  arguments are modified in a manner that ensures that the desired effect\n+   --  is obtained on all operating systems. The caller may call\n+   --  Normalize_Arguments explicitly before the call (e.g. to print out the\n+   --  exact form of arguments passed to the operating system). In this case\n+   --  the guarantee a second call to Normalize_Arguments has no effect\n+   --  ensures that the internal call will not affect the result. Note that\n+   --  the implicit call to Normalize_Arguments may free and reallocate some\n+   --  of the individual arguments.\n+   --\n+   --  This function will always set Success to False under VxWorks and other\n+   --  similar operating systems which have no notion of the concept of\n+   --  dynamically executable file.\n+\n+   function Spawn\n+     (Program_Name : String;\n+      Args         : Argument_List) return Integer;\n+   --  Similar to the above procedure, but returns the actual status returned\n+   --  by the operating system, or -1 under VxWorks and any other similar\n+   --  operating systems which have no notion of separately spawnable programs.\n+   --\n+   --  \"Spawn\" should not be used in tasking applications.\n+\n+   procedure Spawn\n+     (Program_Name           : String;\n+      Args                   : Argument_List;\n+      Output_File_Descriptor : File_Descriptor;\n+      Return_Code            : out Integer;\n+      Err_To_Out             : Boolean := True);\n+   --  Similar to the procedure above, but redirects the output to the file\n+   --  designated by Output_File_Descriptor. If Err_To_Out is True, then the\n+   --  Standard Error output is also redirected.\n+   --  Return_Code is set to the status code returned by the operating system\n+   --\n+   --  \"Spawn\" should not be used in tasking applications.\n+\n+   procedure Spawn\n+     (Program_Name  : String;\n+      Args          : Argument_List;\n+      Output_File   : String;\n+      Success       : out Boolean;\n+      Return_Code   : out Integer;\n+      Err_To_Out    : Boolean := True);\n+   --  Similar to the procedure above, but saves the output of the command to\n+   --  a file with the name Output_File.\n+   --\n+   --  Success is set to True if the command is executed and its output\n+   --  successfully written to the file. If Success is True, then Return_Code\n+   --  will be set to the status code returned by the operating system.\n+   --  Otherwise, Return_Code is undefined.\n+   --\n+   --  \"Spawn\" should not be used in tasking applications.\n+\n+   type Process_Id is private;\n+   --  A private type used to identify a process activated by the following\n+   --  non-blocking calls. The only meaningful operation on this type is a\n+   --  comparison for equality.\n+\n+   Invalid_Pid : constant Process_Id;\n+   --  A special value used to indicate errors, as described below\n+\n+   function Pid_To_Integer (Pid : Process_Id) return Integer;\n+   --  Convert a process id to an Integer. Useful for writing hash functions\n+   --  for type Process_Id or to compare two Process_Id (e.g. for sorting).\n+\n+   function Non_Blocking_Spawn\n+     (Program_Name : String;\n+      Args         : Argument_List) return Process_Id;\n+   --  This is a non blocking call. The Process_Id of the spawned process is\n+   --  returned. Parameters are to be used as in Spawn. If Invalid_Pid is\n+   --  returned the program could not be spawned.\n+   --\n+   --  \"Non_Blocking_Spawn\" should not be used in tasking applications.\n+   --\n+   --  This function will always return Invalid_Pid under VxWorks, since there\n+   --  is no notion of executables under this OS.\n+\n+   function Non_Blocking_Spawn\n+     (Program_Name           : String;\n+      Args                   : Argument_List;\n+      Output_File_Descriptor : File_Descriptor;\n+      Err_To_Out             : Boolean := True) return Process_Id;\n+   --  Similar to the procedure above, but redirects the output to the file\n+   --  designated by Output_File_Descriptor. If Err_To_Out is True, then the\n+   --  Standard Error output is also redirected. Invalid_Pid is returned\n+   --  if the program could not be spawned successfully.\n+   --\n+   --  \"Non_Blocking_Spawn\" should not be used in tasking applications.\n+   --\n+   --  This function will always return Invalid_Pid under VxWorks, since there\n+   --  is no notion of executables under this OS.\n+\n+   function Non_Blocking_Spawn\n+     (Program_Name : String;\n+      Args         : Argument_List;\n+      Output_File  : String;\n+      Err_To_Out   : Boolean := True) return Process_Id;\n+   --  Similar to the procedure above, but saves the output of the command to\n+   --  a file with the name Output_File.\n+   --\n+   --  Success is set to True if the command is executed and its output\n+   --  successfully written to the file. Invalid_Pid is returned if the output\n+   --  file could not be created or if the program could not be spawned\n+   --  successfully.\n+   --\n+   --  \"Non_Blocking_Spawn\" should not be used in tasking applications.\n+   --\n+   --  This function will always return Invalid_Pid under VxWorks, since there\n+   --  is no notion of executables under this OS.\n+\n+   procedure Wait_Process (Pid : out Process_Id; Success : out Boolean);\n+   --  Wait for the completion of any of the processes created by previous\n+   --  calls to Non_Blocking_Spawn. The caller will be suspended until one of\n+   --  these processes terminates (normally or abnormally). If any of these\n+   --  subprocesses terminates prior to the call to Wait_Process (and has not\n+   --  been returned by a previous call to Wait_Process), then the call to\n+   --  Wait_Process is immediate. Pid identifies the process that has\n+   --  terminated (matching the value returned from Non_Blocking_Spawn).\n+   --  Success is set to True if this sub-process terminated successfully. If\n+   --  Pid = Invalid_Pid, there were no subprocesses left to wait on.\n+   --\n+   --  This function will always set success to False under VxWorks, since\n+   --  there is no notion of executables under this OS.\n+\n+   function Argument_String_To_List\n+     (Arg_String : String) return Argument_List_Access;\n+   --  Take a string that is a program and its arguments and parse it into an\n+   --  Argument_List. Note that the result is allocated on the heap, and must\n+   --  be freed by the programmer (when it is no longer needed) to avoid\n+   --  memory leaks.\n+\n+   -------------------\n+   -- Miscellaneous --\n+   -------------------\n+\n+   function Getenv (Name : String) return String_Access;\n+   --  Get the value of the environment variable. Returns an access to the\n+   --  empty string if the environment variable does not exist or has an\n+   --  explicit null value (in some operating systems these are distinct\n+   --  cases, in others they are not; this interface abstracts away that\n+   --  difference. The argument is allocated on the heap (even in the null\n+   --  case), and needs to be freed explicitly when no longer needed to avoid\n+   --  memory leaks.\n+\n+   procedure Setenv (Name : String; Value : String);\n+   --  Set the value of the environment variable Name to Value. This call\n+   --  modifies the current environment, but does not modify the parent\n+   --  process environment. After a call to Setenv, Getenv (Name) will always\n+   --  return a String_Access referencing the same String as Value. This is\n+   --  true also for the null string case (the actual effect may be to either\n+   --  set an explicit null as the value, or to remove the entry, this is\n+   --  operating system dependent). Note that any following calls to Spawn\n+   --  will pass an environment to the spawned process that includes the\n+   --  changes made by Setenv calls. This procedure is not available on VMS.\n+\n+   procedure OS_Exit (Status : Integer);\n+   pragma Import (C, OS_Exit, \"__gnat_os_exit\");\n+   pragma No_Return (OS_Exit);\n+   --  Exit to OS with given status code (program is terminated). Note that\n+   --  this is abrupt termination. All tasks are immediately terminated. There\n+   --  are no finalization or other Ada-specific cleanup actions performed. On\n+   --  systems with atexit handlers (such as Unix and Windows) are performed.\n+\n+   procedure OS_Abort;\n+   pragma Import (C, OS_Abort, \"abort\");\n+   pragma No_Return (OS_Abort);\n+   --  Exit to OS signalling an abort (traceback or other appropriate\n+   --  diagnostic information should be given if possible, or entry made to\n+   --  the debugger if that is possible).\n+\n+   function Errno return Integer;\n+   pragma Import (C, Errno, \"__get_errno\");\n+   --  Return the task-safe last error number\n+\n+   procedure Set_Errno (Errno : Integer);\n+   pragma Import (C, Set_Errno, \"__set_errno\");\n+   --  Set the task-safe error number\n+\n+   Directory_Separator : constant Character;\n+   --  The character that is used to separate parts of a pathname\n+\n+   Path_Separator : constant Character;\n+   --  The character to separate paths in an environment variable value\n+\n+private\n+   pragma Import (C, Path_Separator, \"__gnat_path_separator\");\n+   pragma Import (C, Directory_Separator, \"__gnat_dir_separator\");\n+   pragma Import (C, Current_Time, \"__gnat_current_time\");\n+\n+   type OS_Time is new Long_Integer;\n+   --  Type used for timestamps in the compiler. This type is used to hold\n+   --  time stamps, but may have a different representation than C's time_t.\n+   --  This type needs to match the declaration of OS_Time in adaint.h.\n+\n+   --  Add pragma Inline statements for comparison operations on OS_Time. It\n+   --  would actually be nice to use pragma Import (Intrinsic) here, but this\n+   --  was not properly supported till GNAT 3.15a, so that would cause\n+   --  bootstrap path problems. To be changed later ???\n+\n+   Invalid_Time : constant OS_Time := -1;\n+   --  This value should match the return valud by __gnat_file_time_*\n+\n+   pragma Inline (\"<\");\n+   pragma Inline (\">\");\n+   pragma Inline (\"<=\");\n+   pragma Inline (\">=\");\n+\n+   type Process_Id is new Integer;\n+   Invalid_Pid : constant Process_Id := -1;\n+\n+end System.OS_Lib;"}, {"sha": "a5c81c1de850ef2847dae1a70cdc8c9cfb0a6074", "filename": "gcc/ada/s-proinf-irix-athread.adb", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-proinf-irix-athread.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-proinf-irix-athread.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-proinf-irix-athread.adb?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1997-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1997-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,10 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is an Irix (old pthread library) version of this package.\n+--  This is an Irix (old pthread library) version of this package\n \n---  This package   contains the parameters  used by   the run-time system at\n---  program startup.  These parameters are  isolated in this package body to\n+--  This package contains the parameters used by the run-time system at\n+--  program startup. These parameters are isolated in this package body to\n --  facilitate replacement by the end user.\n --\n --  To replace the default values, copy this source file into your build\n@@ -44,10 +44,9 @@\n --     % gcc -c -O2 -gnatpg s-proinf.adb\n --\n --  then relink your application as usual.\n---\n \n-pragma Warnings (Off);\n-with GNAT.OS_Lib;\n+pragma Warnings (Off); -- why???\n+with System.OS_Lib;\n pragma Warnings (On);\n \n package body System.Program_Info is\n@@ -75,8 +74,8 @@ package body System.Program_Info is\n \n       MP_NPROCS : constant := 1; --   # processor in complex\n \n-      Pthread_Sproc_Count : constant GNAT.OS_Lib.String_Access :=\n-        GNAT.OS_Lib.Getenv (\"PTHREAD_SPROC_COUNT\");\n+      Pthread_Sproc_Count : constant System.OS_Lib.String_Access :=\n+        System.OS_Lib.Getenv (\"PTHREAD_SPROC_COUNT\");\n \n    begin\n       if Pthread_Sproc_Count.all'Length = 0 then\n@@ -88,6 +87,7 @@ package body System.Program_Info is\n       else\n          return Integer'Value (Pthread_Sproc_Count.all);\n       end if;\n+\n    exception\n       when others =>\n          return Default_Initial_Sproc_Count;\n@@ -98,8 +98,8 @@ package body System.Program_Info is\n    ---------------------\n \n    function Max_Sproc_Count return Integer is\n-      Pthread_Max_Sproc_Count : constant GNAT.OS_Lib.String_Access :=\n-        GNAT.OS_Lib.Getenv (\"PTHREAD_MAX_SPROC_COUNT\");\n+      Pthread_Max_Sproc_Count : constant System.OS_Lib.String_Access :=\n+        System.OS_Lib.Getenv (\"PTHREAD_MAX_SPROC_COUNT\");\n \n    begin\n       if Pthread_Max_Sproc_Count.all'Length = 0 then\n@@ -126,10 +126,12 @@ package body System.Program_Info is\n    ------------------------\n \n    function Default_Time_Slice return Duration is\n-      Pthread_Time_Slice_Sec : constant GNAT.OS_Lib.String_Access :=\n-        GNAT.OS_Lib.Getenv (\"PTHREAD_TIME_SLICE_SEC\");\n-      Pthread_Time_Slice_Usec : constant GNAT.OS_Lib.String_Access :=\n-        GNAT.OS_Lib.Getenv (\"PTHREAD_TIME_SLICE_USEC\");\n+      Pthread_Time_Slice_Sec : constant System.OS_Lib.String_Access :=\n+                                 System.OS_Lib.Getenv\n+                                   (\"PTHREAD_TIME_SLICE_SEC\");\n+      Pthread_Time_Slice_Usec : constant System.OS_Lib.String_Access :=\n+                                  System.OS_Lib.Getenv\n+                                    (\"PTHREAD_TIME_SLICE_USEC\");\n \n       Val_Sec, Val_Usec : Integer := 0;\n \n@@ -169,9 +171,9 @@ package body System.Program_Info is\n    -----------------------\n \n    function Stack_Guard_Pages return Integer is\n-      Pthread_Stack_Guard_Pages : constant GNAT.OS_Lib.String_Access :=\n-        GNAT.OS_Lib.Getenv (\"PTHREAD_STACK_GUARD_PAGES\");\n-\n+      Pthread_Stack_Guard_Pages : constant System.OS_Lib.String_Access :=\n+                                    System.OS_Lib.Getenv\n+                                      (\"PTHREAD_STACK_GUARD_PAGES\");\n    begin\n       if Pthread_Stack_Guard_Pages.all'Length /= 0 then\n          return Integer'Value (Pthread_Stack_Guard_Pages.all);\n@@ -197,15 +199,17 @@ package body System.Program_Info is\n    ------------------------\n \n    function Pthread_Arena_Size  return Integer is\n-      Pthread_Arena_Size : constant GNAT.OS_Lib.String_Access :=\n-        GNAT.OS_Lib.Getenv (\"PTHREAD_ARENA_SIZE\");\n+      Pthread_Arena_Size : constant System.OS_Lib.String_Access :=\n+                             System.OS_Lib.Getenv\n+                               (\"PTHREAD_ARENA_SIZE\");\n \n    begin\n       if Pthread_Arena_Size.all'Length = 0 then\n          return Default_Pthread_Arena_Size;\n       else\n          return Integer'Value (Pthread_Arena_Size.all);\n       end if;\n+\n    exception\n       when others =>\n          return Default_Pthread_Arena_Size;"}, {"sha": "ab7480756505da7f16d4e3d3787771d0a5859e6b", "filename": "gcc/ada/s-regexp.adb", "status": "added", "additions": 1388, "deletions": 0, "changes": 1388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-regexp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-regexp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-regexp.adb?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -0,0 +1,1388 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                          G N A T . R E G E X P                           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 1999-2007, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Deallocation;\n+with Ada.Exceptions;\n+\n+with System.Case_Util;\n+\n+package body System.Regexp is\n+\n+   Open_Paren    : constant Character := '(';\n+   Close_Paren   : constant Character := ')';\n+   Open_Bracket  : constant Character := '[';\n+   Close_Bracket : constant Character := ']';\n+\n+   type State_Index is new Natural;\n+   type Column_Index is new Natural;\n+\n+   type Regexp_Array is array\n+     (State_Index range <>, Column_Index range <>) of State_Index;\n+   --  First index is for the state number\n+   --  Second index is for the character type\n+   --  Contents is the new State\n+\n+   type Regexp_Array_Access is access Regexp_Array;\n+   --  Use this type through the functions Set below, so that it\n+   --  can grow dynamically depending on the needs.\n+\n+   type Mapping is array (Character'Range) of Column_Index;\n+   --  Mapping between characters and column in the Regexp_Array\n+\n+   type Boolean_Array is array (State_Index range <>) of Boolean;\n+\n+   type Regexp_Value\n+     (Alphabet_Size : Column_Index;\n+      Num_States    : State_Index) is\n+   record\n+      Map            : Mapping;\n+      States         : Regexp_Array (1 .. Num_States, 0 .. Alphabet_Size);\n+      Is_Final       : Boolean_Array (1 .. Num_States);\n+      Case_Sensitive : Boolean;\n+   end record;\n+   --  Deterministic finite-state machine\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Set\n+     (Table  : in out Regexp_Array_Access;\n+      State  : State_Index;\n+      Column : Column_Index;\n+      Value  : State_Index);\n+   --  Sets a value in the table. If the table is too small, reallocate it\n+   --  dynamically so that (State, Column) is a valid index in it.\n+\n+   function Get\n+     (Table  : Regexp_Array_Access;\n+      State  : State_Index;\n+      Column : Column_Index)\n+      return   State_Index;\n+   --  Returns the value in the table at (State, Column).\n+   --  If this index does not exist in the table, returns 0\n+\n+   procedure Free is new Ada.Unchecked_Deallocation\n+     (Regexp_Array, Regexp_Array_Access);\n+\n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   procedure Adjust (R : in out Regexp) is\n+      Tmp : Regexp_Access;\n+\n+   begin\n+      Tmp := new Regexp_Value (Alphabet_Size => R.R.Alphabet_Size,\n+                               Num_States    => R.R.Num_States);\n+      Tmp.all := R.R.all;\n+      R.R := Tmp;\n+   end Adjust;\n+\n+   -------------\n+   -- Compile --\n+   -------------\n+\n+   function Compile\n+     (Pattern        : String;\n+      Glob           : Boolean := False;\n+      Case_Sensitive : Boolean := True)\n+      return           Regexp\n+   is\n+      S : String := Pattern;\n+      --  The pattern which is really compiled (when the pattern is case\n+      --  insensitive, we convert this string to lower-cases\n+\n+      Map : Mapping := (others => 0);\n+      --  Mapping between characters and columns in the tables\n+\n+      Alphabet_Size : Column_Index := 0;\n+      --  Number of significant characters in the regular expression.\n+      --  This total does not include special operators, such as *, (, ...\n+\n+      procedure Create_Mapping;\n+      --  Creates a mapping between characters in the regexp and columns\n+      --  in the tables representing the regexp. Test that the regexp is\n+      --  well-formed Modifies Alphabet_Size and Map\n+\n+      procedure Create_Primary_Table\n+        (Table       : out Regexp_Array_Access;\n+         Num_States  : out State_Index;\n+         Start_State : out State_Index;\n+         End_State   : out State_Index);\n+      --  Creates the first version of the regexp (this is a non determinist\n+      --  finite state machine, which is unadapted for a fast pattern\n+      --  matching algorithm). We use a recursive algorithm to process the\n+      --  parenthesis sub-expressions.\n+      --\n+      --  Table : at the end of the procedure : Column 0 is for any character\n+      --  ('.') and the last columns are for no character (closure)\n+      --  Num_States is set to the number of states in the table\n+      --  Start_State is the number of the starting state in the regexp\n+      --  End_State is the number of the final state when the regexp matches\n+\n+      procedure Create_Primary_Table_Glob\n+        (Table       : out Regexp_Array_Access;\n+         Num_States  : out State_Index;\n+         Start_State : out State_Index;\n+         End_State   : out State_Index);\n+      --  Same function as above, but it deals with the second possible\n+      --  grammar for 'globbing pattern', which is a kind of subset of the\n+      --  whole regular expression grammar.\n+\n+      function Create_Secondary_Table\n+        (First_Table : Regexp_Array_Access;\n+         Num_States  : State_Index;\n+         Start_State : State_Index;\n+         End_State   : State_Index)\n+         return        Regexp;\n+      --  Creates the definitive table representing the regular expression\n+      --  This is actually a transformation of the primary table First_Table,\n+      --  where every state is grouped with the states in its 'no-character'\n+      --  columns. The transitions between the new states are then recalculated\n+      --  and if necessary some new states are created.\n+      --\n+      --  Note that the resulting finite-state machine is not optimized in\n+      --  terms of the number of states : it would be more time-consuming to\n+      --  add a third pass to reduce the number of states in the machine, with\n+      --  no speed improvement...\n+\n+      procedure Raise_Exception\n+        (M     : String;\n+         Index : Integer);\n+      pragma No_Return (Raise_Exception);\n+      --  Raise an exception, indicating an error at character Index in S\n+\n+      --------------------\n+      -- Create_Mapping --\n+      --------------------\n+\n+      procedure Create_Mapping is\n+\n+         procedure Add_In_Map (C : Character);\n+         --  Add a character in the mapping, if it is not already defined\n+\n+         ----------------\n+         -- Add_In_Map --\n+         ----------------\n+\n+         procedure Add_In_Map (C : Character) is\n+         begin\n+            if Map (C) = 0 then\n+               Alphabet_Size := Alphabet_Size + 1;\n+               Map (C) := Alphabet_Size;\n+            end if;\n+         end Add_In_Map;\n+\n+         J                 : Integer := S'First;\n+         Parenthesis_Level : Integer := 0;\n+         Curly_Level       : Integer := 0;\n+\n+      --  Start of processing for Create_Mapping\n+\n+      begin\n+         while J <= S'Last loop\n+            case S (J) is\n+               when Open_Bracket =>\n+                  J := J + 1;\n+\n+                  if S (J) = '^' then\n+                     J := J + 1;\n+                  end if;\n+\n+                  if S (J) = ']' or S (J) = '-' then\n+                     J := J + 1;\n+                  end if;\n+\n+                  --  The first character never has a special meaning\n+\n+                  loop\n+                     if J > S'Last then\n+                        Raise_Exception\n+                          (\"Ran out of characters while parsing \", J);\n+                     end if;\n+\n+                     exit when S (J) = Close_Bracket;\n+\n+                     if S (J) = '-'\n+                       and then S (J + 1) /= Close_Bracket\n+                     then\n+                        declare\n+                           Start : constant Integer := J - 1;\n+\n+                        begin\n+                           J := J + 1;\n+\n+                           if S (J) = '\\' then\n+                              J := J + 1;\n+                           end if;\n+\n+                           for Char in S (Start) .. S (J) loop\n+                              Add_In_Map (Char);\n+                           end loop;\n+                        end;\n+                     else\n+                        if S (J) = '\\' then\n+                           J := J + 1;\n+                        end if;\n+\n+                        Add_In_Map (S (J));\n+                     end if;\n+\n+                     J := J + 1;\n+                  end loop;\n+\n+                  --  A close bracket must follow a open_bracket,\n+                  --  and cannot be found alone on the line\n+\n+               when Close_Bracket =>\n+                  Raise_Exception\n+                    (\"Incorrect character ']' in regular expression\", J);\n+\n+               when '\\' =>\n+                  if J < S'Last  then\n+                     J := J + 1;\n+                     Add_In_Map (S (J));\n+\n+                  else\n+                     --  \\ not allowed at the end of the regexp\n+\n+                     Raise_Exception\n+                       (\"Incorrect character '\\' in regular expression\", J);\n+                  end if;\n+\n+               when Open_Paren =>\n+                  if not Glob then\n+                     Parenthesis_Level := Parenthesis_Level + 1;\n+                  else\n+                     Add_In_Map (Open_Paren);\n+                  end if;\n+\n+               when Close_Paren =>\n+                  if not Glob then\n+                     Parenthesis_Level := Parenthesis_Level - 1;\n+\n+                     if Parenthesis_Level < 0 then\n+                        Raise_Exception\n+                          (\"')' is not associated with '(' in regular \"\n+                           & \"expression\", J);\n+                     end if;\n+\n+                     if S (J - 1) = Open_Paren then\n+                        Raise_Exception\n+                          (\"Empty parenthesis not allowed in regular \"\n+                           & \"expression\", J);\n+                     end if;\n+\n+                  else\n+                     Add_In_Map (Close_Paren);\n+                  end if;\n+\n+               when '.' =>\n+                  if Glob then\n+                     Add_In_Map ('.');\n+                  end if;\n+\n+               when '{' =>\n+                  if not Glob then\n+                     Add_In_Map (S (J));\n+                  else\n+                     Curly_Level := Curly_Level + 1;\n+                  end if;\n+\n+               when '}' =>\n+                  if not Glob then\n+                     Add_In_Map (S (J));\n+                  else\n+                     Curly_Level := Curly_Level - 1;\n+                  end if;\n+\n+               when '*' | '?' =>\n+                  if not Glob then\n+                     if J = S'First then\n+                        Raise_Exception\n+                          (\"'*', '+', '?' and '|' operators cannot be in \"\n+                           & \"first position in regular expression\", J);\n+                     end if;\n+                  end if;\n+\n+               when '|' | '+' =>\n+                  if not Glob then\n+                     if J = S'First then\n+\n+                        --  These operators must apply to a sub-expression,\n+                        --  and cannot be found at the beginning of the line\n+\n+                        Raise_Exception\n+                          (\"'*', '+', '?' and '|' operators cannot be in \"\n+                           & \"first position in regular expression\", J);\n+                     end if;\n+\n+                  else\n+                     Add_In_Map (S (J));\n+                  end if;\n+\n+               when others =>\n+                  Add_In_Map (S (J));\n+            end case;\n+\n+            J := J + 1;\n+         end loop;\n+\n+         --  A closing parenthesis must follow an open parenthesis\n+\n+         if Parenthesis_Level /= 0 then\n+            Raise_Exception\n+              (\"'(' must always be associated with a ')'\", J);\n+         end if;\n+\n+         if Curly_Level /= 0 then\n+            Raise_Exception\n+              (\"'{' must always be associated with a '}'\", J);\n+         end if;\n+      end Create_Mapping;\n+\n+      --------------------------\n+      -- Create_Primary_Table --\n+      --------------------------\n+\n+      procedure Create_Primary_Table\n+        (Table       : out Regexp_Array_Access;\n+         Num_States  : out State_Index;\n+         Start_State : out State_Index;\n+         End_State   : out State_Index)\n+      is\n+         Empty_Char : constant Column_Index := Alphabet_Size + 1;\n+\n+         Current_State : State_Index := 0;\n+         --  Index of the last created state\n+\n+         procedure Add_Empty_Char\n+           (State    : State_Index;\n+            To_State : State_Index);\n+         --  Add a empty-character transition from State to To_State\n+\n+         procedure Create_Repetition\n+           (Repetition : Character;\n+            Start_Prev : State_Index;\n+            End_Prev   : State_Index;\n+            New_Start  : out State_Index;\n+            New_End    : in out State_Index);\n+         --  Create the table in case we have a '*', '+' or '?'.\n+         --  Start_Prev .. End_Prev should indicate respectively the start and\n+         --  end index of the previous expression, to which '*', '+' or '?' is\n+         --  applied.\n+\n+         procedure Create_Simple\n+           (Start_Index : Integer;\n+            End_Index   : Integer;\n+            Start_State : out State_Index;\n+            End_State   : out State_Index);\n+         --  Fill the table for the regexp Simple.\n+         --  This is the recursive procedure called to handle () expressions\n+         --  If End_State = 0, then the call to Create_Simple creates an\n+         --  independent regexp, not a concatenation\n+         --  Start_Index .. End_Index is the starting index in the string S.\n+         --\n+         --  Warning: it may look like we are creating too many empty-string\n+         --  transitions, but they are needed to get the correct regexp.\n+         --  The table is filled as follow ( s means start-state, e means\n+         --  end-state) :\n+         --\n+         --  regexp   state_num | a b * empty_string\n+         --  -------  ------------------------------\n+         --    a          1 (s) | 2 - - -\n+         --               2 (e) | - - - -\n+         --\n+         --    ab         1 (s) | 2 - - -\n+         --               2     | - - - 3\n+         --               3     | - 4 - -\n+         --               4 (e) | - - - -\n+         --\n+         --    a|b        1     | 2 - - -\n+         --               2     | - - - 6\n+         --               3     | - 4 - -\n+         --               4     | - - - 6\n+         --               5 (s) | - - - 1,3\n+         --               6 (e) | - - - -\n+         --\n+         --    a*         1     | 2 - - -\n+         --               2     | - - - 4\n+         --               3 (s) | - - - 1,4\n+         --               4 (e) | - - - 3\n+         --\n+         --    (a)        1 (s) | 2 - - -\n+         --               2 (e) | - - - -\n+         --\n+         --    a+         1     | 2 - - -\n+         --               2     | - - - 4\n+         --               3 (s) | - - - 1\n+         --               4 (e) | - - - 3\n+         --\n+         --    a?         1     | 2 - - -\n+         --               2     | - - - 4\n+         --               3 (s) | - - - 1,4\n+         --               4 (e) | - - - -\n+         --\n+         --    .          1 (s) | 2 2 2 -\n+         --               2 (e) | - - - -\n+\n+         function Next_Sub_Expression\n+           (Start_Index : Integer;\n+            End_Index   : Integer)\n+            return        Integer;\n+         --  Returns the index of the last character of the next sub-expression\n+         --  in Simple. Index cannot be greater than End_Index.\n+\n+         --------------------\n+         -- Add_Empty_Char --\n+         --------------------\n+\n+         procedure Add_Empty_Char\n+           (State    : State_Index;\n+            To_State : State_Index)\n+         is\n+            J : Column_Index := Empty_Char;\n+\n+         begin\n+            while Get (Table, State, J) /= 0 loop\n+               J := J + 1;\n+            end loop;\n+\n+            Set (Table, State, J, To_State);\n+         end Add_Empty_Char;\n+\n+         -----------------------\n+         -- Create_Repetition --\n+         -----------------------\n+\n+         procedure Create_Repetition\n+           (Repetition : Character;\n+            Start_Prev : State_Index;\n+            End_Prev   : State_Index;\n+            New_Start  : out State_Index;\n+            New_End    : in out State_Index)\n+         is\n+         begin\n+            New_Start := Current_State + 1;\n+\n+            if New_End /= 0 then\n+               Add_Empty_Char (New_End, New_Start);\n+            end if;\n+\n+            Current_State := Current_State + 2;\n+            New_End   := Current_State;\n+\n+            Add_Empty_Char (End_Prev, New_End);\n+            Add_Empty_Char (New_Start, Start_Prev);\n+\n+            if Repetition /= '+' then\n+               Add_Empty_Char (New_Start, New_End);\n+            end if;\n+\n+            if Repetition /= '?' then\n+               Add_Empty_Char (New_End, New_Start);\n+            end if;\n+         end Create_Repetition;\n+\n+         -------------------\n+         -- Create_Simple --\n+         -------------------\n+\n+         procedure Create_Simple\n+           (Start_Index : Integer;\n+            End_Index   : Integer;\n+            Start_State : out State_Index;\n+            End_State   : out State_Index)\n+         is\n+            J          : Integer := Start_Index;\n+            Last_Start : State_Index := 0;\n+\n+         begin\n+            Start_State := 0;\n+            End_State   := 0;\n+            while J <= End_Index loop\n+               case S (J) is\n+                  when Open_Paren =>\n+                     declare\n+                        J_Start    : constant Integer := J + 1;\n+                        Next_Start : State_Index;\n+                        Next_End   : State_Index;\n+\n+                     begin\n+                        J := Next_Sub_Expression (J, End_Index);\n+                        Create_Simple (J_Start, J - 1, Next_Start, Next_End);\n+\n+                        if J < End_Index\n+                          and then (S (J + 1) = '*' or else\n+                                    S (J + 1) = '+' or else\n+                                    S (J + 1) = '?')\n+                        then\n+                           J := J + 1;\n+                           Create_Repetition\n+                             (S (J),\n+                              Next_Start,\n+                              Next_End,\n+                              Last_Start,\n+                              End_State);\n+\n+                        else\n+                           Last_Start := Next_Start;\n+\n+                           if End_State /= 0 then\n+                              Add_Empty_Char (End_State, Last_Start);\n+                           end if;\n+\n+                           End_State := Next_End;\n+                        end if;\n+                     end;\n+\n+                  when '|' =>\n+                     declare\n+                        Start_Prev : constant State_Index := Start_State;\n+                        End_Prev   : constant State_Index := End_State;\n+                        Start_J    : constant Integer     := J + 1;\n+                        Start_Next : State_Index := 0;\n+                        End_Next   : State_Index := 0;\n+\n+                     begin\n+                        J := Next_Sub_Expression (J, End_Index);\n+\n+                        --  Create a new state for the start of the alternative\n+\n+                        Current_State := Current_State + 1;\n+                        Last_Start := Current_State;\n+                        Start_State := Last_Start;\n+\n+                        --  Create the tree for the second part of alternative\n+\n+                        Create_Simple (Start_J, J, Start_Next, End_Next);\n+\n+                        --  Create the end state\n+\n+                        Add_Empty_Char (Last_Start, Start_Next);\n+                        Add_Empty_Char (Last_Start, Start_Prev);\n+                        Current_State := Current_State + 1;\n+                        End_State := Current_State;\n+                        Add_Empty_Char (End_Prev, End_State);\n+                        Add_Empty_Char (End_Next, End_State);\n+                     end;\n+\n+                  when Open_Bracket =>\n+                     Current_State := Current_State + 1;\n+\n+                     declare\n+                        Next_State : State_Index := Current_State + 1;\n+\n+                     begin\n+                        J := J + 1;\n+\n+                        if S (J) = '^' then\n+                           J := J + 1;\n+\n+                           Next_State := 0;\n+\n+                           for Column in 0 .. Alphabet_Size loop\n+                              Set (Table, Current_State, Column,\n+                                   Value => Current_State + 1);\n+                           end loop;\n+                        end if;\n+\n+                        --  Automatically add the first character\n+\n+                        if S (J) = '-' or S (J) = ']' then\n+                           Set (Table, Current_State, Map (S (J)),\n+                                Value => Next_State);\n+                           J := J + 1;\n+                        end if;\n+\n+                        --  Loop till closing bracket found\n+\n+                        loop\n+                           exit when S (J) = Close_Bracket;\n+\n+                           if S (J) = '-'\n+                             and then S (J + 1) /= ']'\n+                           then\n+                              declare\n+                                 Start : constant Integer := J - 1;\n+\n+                              begin\n+                                 J := J + 1;\n+\n+                                 if S (J) = '\\' then\n+                                    J := J + 1;\n+                                 end if;\n+\n+                                 for Char in S (Start) .. S (J) loop\n+                                    Set (Table, Current_State, Map (Char),\n+                                         Value => Next_State);\n+                                 end loop;\n+                              end;\n+\n+                           else\n+                              if S (J) = '\\' then\n+                                 J := J + 1;\n+                              end if;\n+\n+                              Set (Table, Current_State, Map (S (J)),\n+                                   Value => Next_State);\n+                           end if;\n+                           J := J + 1;\n+                        end loop;\n+                     end;\n+\n+                     Current_State := Current_State + 1;\n+\n+                     --  If the next symbol is a special symbol\n+\n+                     if J < End_Index\n+                       and then (S (J + 1) = '*' or else\n+                                 S (J + 1) = '+' or else\n+                                 S (J + 1) = '?')\n+                     then\n+                        J := J + 1;\n+                        Create_Repetition\n+                          (S (J),\n+                           Current_State - 1,\n+                           Current_State,\n+                           Last_Start,\n+                           End_State);\n+\n+                     else\n+                        Last_Start := Current_State - 1;\n+\n+                        if End_State /= 0 then\n+                           Add_Empty_Char (End_State, Last_Start);\n+                        end if;\n+\n+                        End_State := Current_State;\n+                     end if;\n+\n+                  when '*' | '+' | '?' | Close_Paren | Close_Bracket =>\n+                     Raise_Exception\n+                       (\"Incorrect character in regular expression :\", J);\n+\n+                  when others =>\n+                     Current_State := Current_State + 1;\n+\n+                     --  Create the state for the symbol S (J)\n+\n+                     if S (J) = '.' then\n+                        for K in 0 .. Alphabet_Size loop\n+                           Set (Table, Current_State, K,\n+                                Value => Current_State + 1);\n+                        end loop;\n+\n+                     else\n+                        if S (J) = '\\' then\n+                           J := J + 1;\n+                        end if;\n+\n+                        Set (Table, Current_State, Map (S (J)),\n+                             Value => Current_State + 1);\n+                     end if;\n+\n+                     Current_State := Current_State + 1;\n+\n+                     --  If the next symbol is a special symbol\n+\n+                     if J < End_Index\n+                       and then (S (J + 1) = '*' or else\n+                                 S (J + 1) = '+' or else\n+                                 S (J + 1) = '?')\n+                     then\n+                        J := J + 1;\n+                        Create_Repetition\n+                          (S (J),\n+                           Current_State - 1,\n+                           Current_State,\n+                           Last_Start,\n+                           End_State);\n+\n+                     else\n+                        Last_Start := Current_State - 1;\n+\n+                        if End_State /= 0 then\n+                           Add_Empty_Char (End_State, Last_Start);\n+                        end if;\n+\n+                        End_State := Current_State;\n+                     end if;\n+\n+               end case;\n+\n+               if Start_State = 0 then\n+                  Start_State := Last_Start;\n+               end if;\n+\n+               J := J + 1;\n+            end loop;\n+         end Create_Simple;\n+\n+         -------------------------\n+         -- Next_Sub_Expression --\n+         -------------------------\n+\n+         function Next_Sub_Expression\n+           (Start_Index : Integer;\n+            End_Index   : Integer)\n+            return        Integer\n+         is\n+            J              : Integer := Start_Index;\n+            Start_On_Alter : Boolean := False;\n+\n+         begin\n+            if S (J) = '|' then\n+               Start_On_Alter := True;\n+            end if;\n+\n+            loop\n+               exit when J = End_Index;\n+               J := J + 1;\n+\n+               case S (J) is\n+                  when '\\' =>\n+                     J := J + 1;\n+\n+                  when Open_Bracket =>\n+                     loop\n+                        J := J + 1;\n+                        exit when S (J) = Close_Bracket;\n+\n+                        if S (J) = '\\' then\n+                           J := J + 1;\n+                        end if;\n+                     end loop;\n+\n+                  when Open_Paren =>\n+                     J := Next_Sub_Expression (J, End_Index);\n+\n+                  when Close_Paren =>\n+                     return J;\n+\n+                  when '|' =>\n+                     if Start_On_Alter then\n+                        return J - 1;\n+                     end if;\n+\n+                  when others =>\n+                     null;\n+               end case;\n+            end loop;\n+\n+            return J;\n+         end Next_Sub_Expression;\n+\n+      --  Start of Create_Primary_Table\n+\n+      begin\n+         Table.all := (others => (others => 0));\n+         Create_Simple (S'First, S'Last, Start_State, End_State);\n+         Num_States := Current_State;\n+      end Create_Primary_Table;\n+\n+      -------------------------------\n+      -- Create_Primary_Table_Glob --\n+      -------------------------------\n+\n+      procedure Create_Primary_Table_Glob\n+        (Table       : out Regexp_Array_Access;\n+         Num_States  : out State_Index;\n+         Start_State : out State_Index;\n+         End_State   : out State_Index)\n+      is\n+         Empty_Char : constant Column_Index := Alphabet_Size + 1;\n+\n+         Current_State : State_Index := 0;\n+         --  Index of the last created state\n+\n+         procedure Add_Empty_Char\n+           (State    : State_Index;\n+            To_State : State_Index);\n+         --  Add a empty-character transition from State to To_State\n+\n+         procedure Create_Simple\n+           (Start_Index : Integer;\n+            End_Index   : Integer;\n+            Start_State : out State_Index;\n+            End_State   : out State_Index);\n+         --  Fill the table for the S (Start_Index .. End_Index).\n+         --  This is the recursive procedure called to handle () expressions\n+\n+         --------------------\n+         -- Add_Empty_Char --\n+         --------------------\n+\n+         procedure Add_Empty_Char\n+           (State    : State_Index;\n+            To_State : State_Index)\n+         is\n+            J : Column_Index := Empty_Char;\n+\n+         begin\n+            while Get (Table, State, J) /= 0 loop\n+               J := J + 1;\n+            end loop;\n+\n+            Set (Table, State, J,\n+                 Value => To_State);\n+         end Add_Empty_Char;\n+\n+         -------------------\n+         -- Create_Simple --\n+         -------------------\n+\n+         procedure Create_Simple\n+           (Start_Index : Integer;\n+            End_Index   : Integer;\n+            Start_State : out State_Index;\n+            End_State   : out State_Index)\n+         is\n+            J          : Integer := Start_Index;\n+            Last_Start : State_Index := 0;\n+\n+         begin\n+            Start_State := 0;\n+            End_State   := 0;\n+\n+            while J <= End_Index loop\n+               case S (J) is\n+\n+                  when Open_Bracket =>\n+                     Current_State := Current_State + 1;\n+\n+                     declare\n+                        Next_State : State_Index := Current_State + 1;\n+\n+                     begin\n+                        J := J + 1;\n+\n+                        if S (J) = '^' then\n+                           J := J + 1;\n+                           Next_State := 0;\n+\n+                           for Column in 0 .. Alphabet_Size loop\n+                              Set (Table, Current_State, Column,\n+                                   Value => Current_State + 1);\n+                           end loop;\n+                        end if;\n+\n+                        --  Automatically add the first character\n+\n+                        if S (J) = '-' or S (J) = ']' then\n+                           Set (Table, Current_State, Map (S (J)),\n+                                Value => Current_State);\n+                           J := J + 1;\n+                        end if;\n+\n+                        --  Loop till closing bracket found\n+\n+                        loop\n+                           exit when S (J) = Close_Bracket;\n+\n+                           if S (J) = '-'\n+                             and then S (J + 1) /= ']'\n+                           then\n+                              declare\n+                                 Start : constant Integer := J - 1;\n+                              begin\n+                                 J := J + 1;\n+\n+                                 if S (J) = '\\' then\n+                                    J := J + 1;\n+                                 end if;\n+\n+                                 for Char in S (Start) .. S (J) loop\n+                                    Set (Table, Current_State, Map (Char),\n+                                         Value => Next_State);\n+                                 end loop;\n+                              end;\n+\n+                           else\n+                              if S (J) = '\\' then\n+                                 J := J + 1;\n+                              end if;\n+\n+                              Set (Table, Current_State, Map (S (J)),\n+                                   Value => Next_State);\n+                           end if;\n+                           J := J + 1;\n+                        end loop;\n+                     end;\n+\n+                     Last_Start := Current_State;\n+                     Current_State := Current_State + 1;\n+\n+                     if End_State /= 0 then\n+                        Add_Empty_Char (End_State, Last_Start);\n+                     end if;\n+\n+                     End_State := Current_State;\n+\n+                  when '{' =>\n+                     declare\n+                        End_Sub          : Integer;\n+                        Start_Regexp_Sub : State_Index;\n+                        End_Regexp_Sub   : State_Index;\n+                        Create_Start     : State_Index := 0;\n+\n+                        Create_End : State_Index := 0;\n+                        --  Initialized to avoid junk warning\n+\n+                     begin\n+                        while S (J) /= '}' loop\n+\n+                           --  First step : find sub pattern\n+\n+                           End_Sub := J + 1;\n+                           while S (End_Sub) /= ','\n+                             and then S (End_Sub) /= '}'\n+                           loop\n+                              End_Sub := End_Sub + 1;\n+                           end loop;\n+\n+                           --  Second step : create a sub pattern\n+\n+                           Create_Simple\n+                             (J + 1,\n+                              End_Sub - 1,\n+                              Start_Regexp_Sub,\n+                              End_Regexp_Sub);\n+\n+                           J := End_Sub;\n+\n+                           --  Third step : create an alternative\n+\n+                           if Create_Start = 0 then\n+                              Current_State := Current_State + 1;\n+                              Create_Start := Current_State;\n+                              Add_Empty_Char (Create_Start, Start_Regexp_Sub);\n+                              Current_State := Current_State + 1;\n+                              Create_End := Current_State;\n+                              Add_Empty_Char (End_Regexp_Sub, Create_End);\n+\n+                           else\n+                              Current_State := Current_State + 1;\n+                              Add_Empty_Char (Current_State, Create_Start);\n+                              Create_Start := Current_State;\n+                              Add_Empty_Char (Create_Start, Start_Regexp_Sub);\n+                              Add_Empty_Char (End_Regexp_Sub, Create_End);\n+                           end if;\n+                        end loop;\n+\n+                        if End_State /= 0 then\n+                           Add_Empty_Char (End_State, Create_Start);\n+                        end if;\n+\n+                        End_State := Create_End;\n+                        Last_Start := Create_Start;\n+                     end;\n+\n+                  when '*' =>\n+                     Current_State := Current_State + 1;\n+\n+                     if End_State /= 0 then\n+                        Add_Empty_Char (End_State, Current_State);\n+                     end if;\n+\n+                     Add_Empty_Char (Current_State, Current_State + 1);\n+                     Add_Empty_Char (Current_State, Current_State + 3);\n+                     Last_Start := Current_State;\n+\n+                     Current_State := Current_State + 1;\n+\n+                     for K in 0 .. Alphabet_Size loop\n+                        Set (Table, Current_State, K,\n+                             Value => Current_State + 1);\n+                     end loop;\n+\n+                     Current_State := Current_State + 1;\n+                     Add_Empty_Char (Current_State, Current_State + 1);\n+\n+                     Current_State := Current_State + 1;\n+                     Add_Empty_Char (Current_State,  Last_Start);\n+                     End_State := Current_State;\n+\n+                  when others =>\n+                     Current_State := Current_State + 1;\n+\n+                     if S (J) = '?' then\n+                        for K in 0 .. Alphabet_Size loop\n+                           Set (Table, Current_State, K,\n+                                Value => Current_State + 1);\n+                        end loop;\n+\n+                     else\n+                        if S (J) = '\\' then\n+                           J := J + 1;\n+                        end if;\n+\n+                        --  Create the state for the symbol S (J)\n+\n+                        Set (Table, Current_State, Map (S (J)),\n+                             Value => Current_State + 1);\n+                     end if;\n+\n+                     Last_Start := Current_State;\n+                     Current_State := Current_State + 1;\n+\n+                     if End_State /= 0 then\n+                        Add_Empty_Char (End_State, Last_Start);\n+                     end if;\n+\n+                     End_State := Current_State;\n+\n+               end case;\n+\n+               if Start_State = 0 then\n+                  Start_State := Last_Start;\n+               end if;\n+\n+               J := J + 1;\n+            end loop;\n+         end Create_Simple;\n+\n+      --  Start of processing for Create_Primary_Table_Glob\n+\n+      begin\n+         Table.all := (others => (others => 0));\n+         Create_Simple (S'First, S'Last, Start_State, End_State);\n+         Num_States := Current_State;\n+      end Create_Primary_Table_Glob;\n+\n+      ----------------------------\n+      -- Create_Secondary_Table --\n+      ----------------------------\n+\n+      function Create_Secondary_Table\n+        (First_Table : Regexp_Array_Access;\n+         Num_States  : State_Index;\n+         Start_State : State_Index;\n+         End_State   : State_Index) return Regexp\n+      is\n+         pragma Warnings (Off, Num_States);\n+\n+         Last_Index : constant State_Index := First_Table'Last (1);\n+         type Meta_State is array (1 .. Last_Index) of Boolean;\n+\n+         Table : Regexp_Array (1 .. Last_Index, 0 .. Alphabet_Size) :=\n+                   (others => (others => 0));\n+\n+         Meta_States : array (1 .. Last_Index + 1) of Meta_State :=\n+                         (others => (others => False));\n+\n+         Temp_State_Not_Null : Boolean;\n+\n+         Is_Final : Boolean_Array (1 .. Last_Index) := (others => False);\n+\n+         Current_State       : State_Index := 1;\n+         Nb_State            : State_Index := 1;\n+\n+         procedure Closure\n+           (State : in out Meta_State;\n+            Item  :        State_Index);\n+         --  Compute the closure of the state (that is every other state which\n+         --  has a empty-character transition) and add it to the state\n+\n+         -------------\n+         -- Closure --\n+         -------------\n+\n+         procedure Closure\n+           (State : in out Meta_State;\n+            Item  : State_Index)\n+         is\n+         begin\n+            if State (Item) then\n+               return;\n+            end if;\n+\n+            State (Item) := True;\n+\n+            for Column in Alphabet_Size + 1 .. First_Table'Last (2) loop\n+               if First_Table (Item, Column) = 0 then\n+                  return;\n+               end if;\n+\n+               Closure (State, First_Table (Item, Column));\n+            end loop;\n+         end Closure;\n+\n+      --  Start of procesing for Create_Secondary_Table\n+\n+      begin\n+         --  Create a new state\n+\n+         Closure (Meta_States (Current_State), Start_State);\n+\n+         while Current_State <= Nb_State loop\n+\n+            --  If this new meta-state includes the primary table end state,\n+            --  then this meta-state will be a final state in the regexp\n+\n+            if Meta_States (Current_State)(End_State) then\n+               Is_Final (Current_State) := True;\n+            end if;\n+\n+            --  For every character in the regexp, calculate the possible\n+            --  transitions from Current_State\n+\n+            for Column in 0 .. Alphabet_Size loop\n+               Meta_States (Nb_State + 1) := (others => False);\n+               Temp_State_Not_Null := False;\n+\n+               for K in Meta_States (Current_State)'Range loop\n+                  if Meta_States (Current_State)(K)\n+                    and then First_Table (K, Column) /= 0\n+                  then\n+                     Closure\n+                       (Meta_States (Nb_State + 1), First_Table (K, Column));\n+                     Temp_State_Not_Null := True;\n+                  end if;\n+               end loop;\n+\n+               --  If at least one transition existed\n+\n+               if Temp_State_Not_Null then\n+\n+                  --  Check if this new state corresponds to an old one\n+\n+                  for K in 1 .. Nb_State loop\n+                     if Meta_States (K) = Meta_States (Nb_State + 1) then\n+                        Table (Current_State, Column) := K;\n+                        exit;\n+                     end if;\n+                  end loop;\n+\n+                  --  If not, create a new state\n+\n+                  if Table (Current_State, Column) = 0 then\n+                     Nb_State := Nb_State + 1;\n+                     Table (Current_State, Column) := Nb_State;\n+                  end if;\n+               end if;\n+            end loop;\n+\n+            Current_State := Current_State + 1;\n+         end loop;\n+\n+         --  Returns the regexp\n+\n+         declare\n+            R : Regexp_Access;\n+\n+         begin\n+            R := new Regexp_Value (Alphabet_Size => Alphabet_Size,\n+                                   Num_States    => Nb_State);\n+            R.Map            := Map;\n+            R.Is_Final       := Is_Final (1 .. Nb_State);\n+            R.Case_Sensitive := Case_Sensitive;\n+\n+            for State in 1 .. Nb_State loop\n+               for K in 0 .. Alphabet_Size loop\n+                  R.States (State, K) := Table (State, K);\n+               end loop;\n+            end loop;\n+\n+            return (Ada.Finalization.Controlled with R => R);\n+         end;\n+      end Create_Secondary_Table;\n+\n+      ---------------------\n+      -- Raise_Exception --\n+      ---------------------\n+\n+      procedure Raise_Exception\n+        (M     : String;\n+         Index : Integer)\n+      is\n+      begin\n+         Ada.Exceptions.Raise_Exception\n+           (Error_In_Regexp'Identity, M & \" at offset \" & Index'Img);\n+      end Raise_Exception;\n+\n+   --  Start of processing for Compile\n+\n+   begin\n+      --  Special case for the empty string: it always matches, and the\n+      --  following processing would fail on it.\n+      if S = \"\" then\n+         return (Ada.Finalization.Controlled with\n+                 R => new Regexp_Value'\n+                      (Alphabet_Size => 0,\n+                       Num_States    => 1,\n+                       Map           => (others => 0),\n+                       States        => (others => (others => 1)),\n+                       Is_Final      => (others => True),\n+                       Case_Sensitive => True));\n+      end if;\n+\n+      if not Case_Sensitive then\n+         System.Case_Util.To_Lower (S);\n+      end if;\n+\n+      Create_Mapping;\n+\n+      --  Creates the primary table\n+\n+      declare\n+         Table : Regexp_Array_Access;\n+         Num_States  : State_Index;\n+         Start_State : State_Index;\n+         End_State   : State_Index;\n+         R           : Regexp;\n+\n+      begin\n+         Table := new Regexp_Array (1 .. 100,\n+                                    0 .. Alphabet_Size + 10);\n+         if not Glob then\n+            Create_Primary_Table (Table, Num_States, Start_State, End_State);\n+         else\n+            Create_Primary_Table_Glob\n+              (Table, Num_States, Start_State, End_State);\n+         end if;\n+\n+         --  Creates the secondary table\n+\n+         R := Create_Secondary_Table\n+           (Table, Num_States, Start_State, End_State);\n+         Free (Table);\n+         return R;\n+      end;\n+   end Compile;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (R : in out Regexp) is\n+      procedure Free is new\n+        Ada.Unchecked_Deallocation (Regexp_Value, Regexp_Access);\n+\n+   begin\n+      Free (R.R);\n+   end Finalize;\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   function Get\n+     (Table  : Regexp_Array_Access;\n+      State  : State_Index;\n+      Column : Column_Index) return State_Index\n+   is\n+   begin\n+      if State <= Table'Last (1)\n+        and then Column <= Table'Last (2)\n+      then\n+         return Table (State, Column);\n+      else\n+         return 0;\n+      end if;\n+   end Get;\n+\n+   -----------\n+   -- Match --\n+   -----------\n+\n+   function Match (S : String; R : Regexp) return Boolean is\n+      Current_State : State_Index := 1;\n+\n+   begin\n+      if R.R = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      for Char in S'Range loop\n+\n+         if R.R.Case_Sensitive then\n+            Current_State := R.R.States (Current_State, R.R.Map (S (Char)));\n+         else\n+            Current_State :=\n+              R.R.States (Current_State,\n+                          R.R.Map (System.Case_Util.To_Lower (S (Char))));\n+         end if;\n+\n+         if Current_State = 0 then\n+            return False;\n+         end if;\n+\n+      end loop;\n+\n+      return R.R.Is_Final (Current_State);\n+   end Match;\n+\n+   ---------\n+   -- Set --\n+   ---------\n+\n+   procedure Set\n+     (Table  : in out Regexp_Array_Access;\n+      State  : State_Index;\n+      Column : Column_Index;\n+      Value  : State_Index)\n+   is\n+      New_Lines   : State_Index;\n+      New_Columns : Column_Index;\n+      New_Table   : Regexp_Array_Access;\n+\n+   begin\n+      if State <= Table'Last (1)\n+        and then Column <= Table'Last (2)\n+      then\n+         Table (State, Column) := Value;\n+      else\n+         --  Doubles the size of the table until it is big enough that\n+         --  (State, Column) is a valid index\n+\n+         New_Lines := Table'Last (1) * (State / Table'Last (1) + 1);\n+         New_Columns := Table'Last (2) * (Column / Table'Last (2) + 1);\n+         New_Table := new Regexp_Array (Table'First (1) .. New_Lines,\n+                                        Table'First (2) .. New_Columns);\n+         New_Table.all := (others => (others => 0));\n+\n+         for J in Table'Range (1) loop\n+            for K in Table'Range (2) loop\n+               New_Table (J, K) := Table (J, K);\n+            end loop;\n+         end loop;\n+\n+         Free (Table);\n+         Table := New_Table;\n+         Table (State, Column) := Value;\n+      end if;\n+   end Set;\n+\n+end System.Regexp;"}, {"sha": "d114f0d0ae66a452fd75b7bff19ed08fa3b0eb3e", "filename": "gcc/ada/s-regexp.ads", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-regexp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-regexp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-regexp.ads?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -0,0 +1,139 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                        S Y S T E M . R E G E X P                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                     Copyright (C) 1998-2007, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Simple Regular expression matching\n+\n+--  This package provides a simple implementation of a regular expression\n+--  pattern matching algorithm, using a subset of the syntax of regular\n+--  expressions copied from familiar Unix style utilities.\n+\n+--  Note: this package is in the System hierarchy so that it can be directly\n+--  be used by other predefined packages. User access to this package is via\n+--  a renaming of this package in GNAT.Regexp (file g-regexp.ads).\n+\n+with Ada.Finalization;\n+\n+package System.Regexp is\n+\n+   --  The regular expression must first be compiled, using the Compile\n+   --  function, which creates a finite state matching table, allowing\n+   --  very fast matching once the expression has been compiled.\n+\n+   --  The following is the form of a regular expression, expressed in Ada\n+   --  reference manual style BNF is as follows\n+\n+   --     regexp ::= term\n+\n+   --     regexp ::= term | term          -- alternation (term or term ...)\n+\n+   --     term ::= item\n+\n+   --     term ::= item item ...          -- concatenation (item then item)\n+\n+   --     item ::= elmt                   -- match elmt\n+   --     item ::= elmt *                 -- zero or more elmt's\n+   --     item ::= elmt +                 -- one or more elmt's\n+   --     item ::= elmt ?                 -- matches elmt or nothing\n+\n+   --     elmt ::= nchr                   -- matches given character\n+   --     elmt ::= [nchr nchr ...]        -- matches any character listed\n+   --     elmt ::= [^ nchr nchr ...]      -- matches any character not listed\n+   --     elmt ::= [char - char]          -- matches chars in given range\n+   --     elmt ::= .                      -- matches any single character\n+   --     elmt ::= ( regexp )             -- parens used for grouping\n+\n+   --     char ::= any character, including special characters\n+   --     nchr ::= any character except \\()[].*+?^ or \\char to match char\n+   --     ... is used to indication repetition (one or more terms)\n+\n+   --  See also regexp(1) man page on Unix systems for further details\n+\n+   --  A second kind of regular expressions is provided. This one is more\n+   --  like the wild card patterns used in file names by the Unix shell (or\n+   --  DOS prompt) command lines. The grammar is the following:\n+\n+   --     regexp ::= term\n+\n+   --     term   ::= elmt\n+\n+   --     term   ::= elmt elmt ...     -- concatenation (elmt then elmt)\n+   --     term   ::= *                 -- any string of 0 or more characters\n+   --     term   ::= ?                 -- matches any character\n+   --     term   ::= [char char ...]   -- matches any character listed\n+   --     term   ::= [char - char]     -- matches any character in given range\n+   --     term   ::= {elmt, elmt, ...} -- alternation (matches any of elmt)\n+\n+   --  Important note : This package was mainly intended to match regular\n+   --  expressions against file names. The whole string has to match the\n+   --  regular expression. If only a substring matches, then the function\n+   --  Match will return False.\n+\n+   type Regexp is private;\n+   --  Private type used to represent a regular expression\n+\n+   Error_In_Regexp : exception;\n+   --  Exception raised when an error is found in the regular expression\n+\n+   function Compile\n+     (Pattern        : String;\n+      Glob           : Boolean := False;\n+      Case_Sensitive : Boolean := True) return Regexp;\n+   --  Compiles a regular expression S. If the syntax of the given\n+   --  expression is invalid (does not match above grammar, Error_In_Regexp\n+   --  is raised. If Glob is True, the pattern is considered as a 'globbing\n+   --  pattern', that is a pattern as given by the second grammar above.\n+   --  As a special case, if Pattern is the empty string it will always\n+   --  match.\n+\n+   function Match (S : String; R : Regexp) return Boolean;\n+   --  True if S matches R, otherwise False. Raises Constraint_Error if\n+   --  R is an uninitialized regular expression value.\n+\n+private\n+   type Regexp_Value;\n+\n+   type Regexp_Access is access Regexp_Value;\n+\n+   type Regexp is new Ada.Finalization.Controlled with record\n+      R : Regexp_Access := null;\n+   end record;\n+\n+   pragma Finalize_Storage_Only (Regexp);\n+\n+   procedure Finalize (R : in out Regexp);\n+   --  Free the memory occupied by R\n+\n+   procedure Adjust (R : in out Regexp);\n+   --  Called after an assignment (do a copy of the Regexp_Access.all)\n+\n+end System.Regexp;"}, {"sha": "c1e924797ebc826656512df961a8f9f3548bc427", "filename": "gcc/ada/s-regpat.adb", "status": "added", "additions": 3635, "deletions": 0, "changes": 3635, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-regpat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-regpat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-regpat.adb?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce"}, {"sha": "0425a2eb983e92939d92feb0e9f6950d7612649a", "filename": "gcc/ada/s-regpat.ads", "status": "added", "additions": 646, "deletions": 0, "changes": 646, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-regpat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-regpat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-regpat.ads?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -0,0 +1,646 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                        S Y S T E M . R E G P A T                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--               Copyright (C) 1986 by University of Toronto.               --\n+--                     Copyright (C) 1996-2007, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package implements roughly the same set of regular expressions as\n+--  are available in the Perl or Python programming languages.\n+\n+--  This is an extension of the original V7 style regular expression library\n+--  written in C by Henry Spencer. Apart from the translation to Ada, the\n+--  interface has been considerably changed to use the Ada String type\n+--  instead of C-style nul-terminated strings.\n+\n+--  Note: this package is in the System hierarchy so that it can be directly\n+--  be used by other predefined packages. User access to this package is via\n+--  a renaming of this package in GNAT.Regpat (file g-regpat.ads).\n+\n+package System.Regpat is\n+   pragma Preelaborate;\n+\n+   --  The grammar is the following:\n+\n+   --     regexp ::= expr\n+   --            ::= ^ expr               -- anchor at the beginning of string\n+   --            ::= expr $               -- anchor at the end of string\n+\n+   --     expr   ::= term\n+   --            ::= term | term          -- alternation (term or term ...)\n+\n+   --     term   ::= item\n+   --            ::= item item ...        -- concatenation (item then item)\n+\n+   --     item   ::= elmt                 -- match elmt\n+   --            ::= elmt *               -- zero or more elmt's\n+   --            ::= elmt +               -- one or more elmt's\n+   --            ::= elmt ?               -- matches elmt or nothing\n+   --            ::= elmt *?              -- zero or more times, minimum number\n+   --            ::= elmt +?              -- one or more times, minimum number\n+   --            ::= elmt ??              -- zero or one time, minimum number\n+   --            ::= elmt { num }         -- matches elmt exactly num times\n+   --            ::= elmt { num , }       -- matches elmt at least num times\n+   --            ::= elmt { num , num2 }  -- matches between num and num2 times\n+   --            ::= elmt { num }?        -- matches elmt exactly num times\n+   --            ::= elmt { num , }?      -- matches elmt at least num times\n+   --                                        non-greedy version\n+   --            ::= elmt { num , num2 }? -- matches between num and num2 times\n+   --                                        non-greedy version\n+\n+   --     elmt   ::= nchr                 -- matches given character\n+   --            ::= [range range ...]    -- matches any character listed\n+   --            ::= [^ range range ...]  -- matches any character not listed\n+   --            ::= .                    -- matches any single character\n+   --                                     -- except newlines\n+   --            ::= ( expr )             -- parens used for grouping\n+   --            ::= \\ num                -- reference to num-th parenthesis\n+\n+   --     range  ::= char - char          -- matches chars in given range\n+   --            ::= nchr\n+   --            ::= [: posix :]          -- any character in the POSIX range\n+   --            ::= [:^ posix :]         -- not in the POSIX range\n+\n+   --     posix  ::= alnum                -- alphanumeric characters\n+   --            ::= alpha                -- alphabetic characters\n+   --            ::= ascii                -- ascii characters (0 .. 127)\n+   --            ::= cntrl                -- control chars (0..31, 127..159)\n+   --            ::= digit                -- digits ('0' .. '9')\n+   --            ::= graph                -- graphic chars (32..126, 160..255)\n+   --            ::= lower                -- lower case characters\n+   --            ::= print                -- printable characters (32..127)\n+   --                                     -- and whitespaces (9 .. 13)\n+   --            ::= punct                -- printable, except alphanumeric\n+   --            ::= space                -- space characters\n+   --            ::= upper                -- upper case characters\n+   --            ::= word                 -- alphanumeric characters\n+   --            ::= xdigit               -- hexadecimal chars (0..9, a..f)\n+\n+   --     char   ::= any character, including special characters\n+   --                ASCII.NUL is not supported.\n+\n+   --     nchr   ::= any character except \\()[].*+?^ or \\char to match char\n+   --                \\n means a newline (ASCII.LF)\n+   --                \\t means a tab (ASCII.HT)\n+   --                \\r means a return (ASCII.CR)\n+   --                \\b matches the empty string at the beginning or end of a\n+   --                   word. A word is defined as a set of alphanumerical\n+   --                   characters (see \\w below).\n+   --                \\B matches the empty string only when *not* at the\n+   --                   beginning or end of a word.\n+   --                \\d matches any digit character ([0-9])\n+   --                \\D matches any non digit character ([^0-9])\n+   --                \\s matches any white space character. This is equivalent\n+   --                   to [ \\t\\n\\r\\f\\v]  (tab, form-feed, vertical-tab,...\n+   --                \\S matches any non-white space character.\n+   --                \\w matches any alphanumeric character or underscore.\n+   --                   This include accented letters, as defined in the\n+   --                   package Ada.Characters.Handling.\n+   --                \\W matches any non-alphanumeric character.\n+   --                \\A match the empty string only at the beginning of the\n+   --                   string, whatever flags are used for Compile (the\n+   --                   behavior of ^ can change, see Regexp_Flags below).\n+   --                \\G match the empty string only at the end of the\n+   --                   string, whatever flags are used for Compile (the\n+   --                   behavior of $ can change, see Regexp_Flags below).\n+   --     ...    ::= is used to indication repetition (one or more terms)\n+\n+   --  Embedded newlines are not matched by the ^ operator.\n+   --  It is possible to retrieve the substring matched a parenthesis\n+   --  expression. Although the depth of parenthesis is not limited in the\n+   --  regexp, only the first 9 substrings can be retrieved.\n+\n+   --  The highest value possible for the arguments to the curly operator ({})\n+   --  are given by the constant Max_Curly_Repeat below.\n+\n+   --  The operators '*', '+', '?' and '{}' always match the longest possible\n+   --  substring. They all have a non-greedy version (with an extra ? after the\n+   --  operator), which matches the shortest possible substring.\n+\n+   --  For instance:\n+   --      regexp=\"<.*>\"   string=\"<h1>title</h1>\"   matches=\"<h1>title</h1>\"\n+   --      regexp=\"<.*?>\"  string=\"<h1>title</h1>\"   matches=\"<h1>\"\n+   --\n+   --  '{' and '}' are only considered as special characters if they appear\n+   --  in a substring that looks exactly like '{n}', '{n,m}' or '{n,}', where\n+   --  n and m are digits. No space is allowed. In other contexts, the curly\n+   --  braces will simply be treated as normal characters.\n+\n+   --  Compiling Regular Expressions\n+   --  =============================\n+\n+   --  To use this package, you first need to compile the regular expression\n+   --  (a string) into a byte-code program, in a Pattern_Matcher structure.\n+   --  This first step checks that the regexp is valid, and optimizes the\n+   --  matching algorithms of the second step.\n+\n+   --  Two versions of the Compile subprogram are given: one in which this\n+   --  package will compute itself the best possible size to allocate for the\n+   --  byte code; the other where you must allocate enough memory yourself. An\n+   --  exception is raised if there is not enough memory.\n+\n+   --     declare\n+   --        Regexp : String := \"a|b\";\n+\n+   --        Matcher : Pattern_Matcher := Compile (Regexp);\n+   --        --  The size for matcher is automatically allocated\n+\n+   --        Matcher2 : Pattern_Matcher (1000);\n+   --        --  Some space is allocated directly.\n+\n+   --     begin\n+   --        Compile (Matcher2, Regexp);\n+   --        ...\n+   --     end;\n+\n+   --  Note that the second version is significantly faster, since with the\n+   --  first version the regular expression has in fact to be compiled twice\n+   --  (first to compute the size, then to generate the byte code).\n+\n+   --  Note also that you cannot use the function version of Compile if you\n+   --  specify the size of the Pattern_Matcher, since the discriminants will\n+   --  most probably be different and you will get a Constraint_Error\n+\n+   --  Matching Strings\n+   --  ================\n+\n+   --  Once the regular expression has been compiled, you can use it as often\n+   --  as needed to match strings.\n+\n+   --  Several versions of the Match subprogram are provided, with different\n+   --  parameters and return results.\n+\n+   --  See the description under each of these subprograms\n+\n+   --  Here is a short example showing how to get the substring matched by\n+   --  the first parenthesis pair.\n+\n+   --     declare\n+   --        Matches : Match_Array (0 .. 1);\n+   --        Regexp  : String := \"a(b|c)d\";\n+   --        Str     : String := \"gacdg\";\n+\n+   --     begin\n+   --        Match (Compile (Regexp), Str, Matches);\n+   --        return Str (Matches (1).First .. Matches (1).Last);\n+   --        --  returns 'c'\n+   --     end;\n+\n+   --  Finding all occurrences\n+   --  =======================\n+\n+   --  Finding all the occurrences of a regular expression in a string cannot\n+   --  be done by simply passing a slice of the string. This wouldn't work for\n+   --  anchored regular expressions (the ones starting with \"^\" or ending with\n+   --  \"$\").\n+   --  Instead, you need to use the last parameter to Match (Data_First), as in\n+   --  the following loop:\n+\n+   --     declare\n+   --        Str     : String :=\n+   --           \"-- first line\" & ASCII.LF & \"-- second line\";\n+   --        Matches : Match_Array (0 .. 0);\n+   --        Regexp  : Pattern_Matcher := Compile (\"^--\", Multiple_Lines);\n+   --        Current : Natural := Str'First;\n+   --     begin\n+   --        loop\n+   --           Match (Regexp, Str, Matches, Current);\n+   --           exit when Matches (0) = No_Match;\n+   --\n+   --           --  Process the match at position Matches (0).First\n+   --\n+   --           Current := Matches (0).Last + 1;\n+   --        end loop;\n+   --     end;\n+\n+   --  String Substitution\n+   --  ===================\n+\n+   --  No subprogram is currently provided for string substitution.\n+   --  However, this is easy to simulate with the parenthesis groups, as\n+   --  shown below.\n+\n+   --  This example swaps the first two words of the string:\n+\n+   --     declare\n+   --        Regexp  : String := \"([a-z]+) +([a-z]+)\";\n+   --        Str     : String := \" first   second third \";\n+   --        Matches : Match_Array (0 .. 2);\n+\n+   --     begin\n+   --        Match (Compile (Regexp), Str, Matches);\n+   --        return Str (Str'First .. Matches (1).First - 1)\n+   --               & Str (Matches (2).First .. Matches (2).Last)\n+   --               & \" \"\n+   --               & Str (Matches (1).First .. Matches (1).Last)\n+   --               & Str (Matches (2).Last + 1 .. Str'Last);\n+   --        --  returns \" second first third \"\n+   --     end;\n+\n+   ---------------\n+   -- Constants --\n+   ---------------\n+\n+   Expression_Error : exception;\n+   --  This exception is raised when trying to compile an invalid regular\n+   --  expression. All subprograms taking an expression as parameter may raise\n+   --  Expression_Error.\n+\n+   Max_Paren_Count : constant := 255;\n+   --  Maximum number of parenthesis in a regular expression. This is limited\n+   --  by the size of a Character, as found in the byte-compiled version of\n+   --  regular expressions.\n+\n+   Max_Curly_Repeat : constant := 32767;\n+   --  Maximum number of repetition for the curly operator. The digits in the\n+   --  {n}, {n,} and {n,m } operators cannot be higher than this constant,\n+   --  since they have to fit on two characters in the byte-compiled version of\n+   --  regular expressions.\n+\n+   Max_Program_Size : constant := 2**15 - 1;\n+   --  Maximum size that can be allocated for a program\n+\n+   type Program_Size is range 0 .. Max_Program_Size;\n+   for Program_Size'Size use 16;\n+   --  Number of bytes allocated for the byte-compiled version of a regular\n+   --  expression. The size required depends on the complexity of the regular\n+   --  expression in a complex manner that is undocumented (other than in the\n+   --  body of the Compile procedure). Normally the size is automatically set\n+   --  and the programmer need not be concerned about it. There are two\n+   --  exceptions to this. First in the calls to Match, it is possible to\n+   --  specify a non-zero size that is known to be large enough. This can\n+   --  slightly increase the efficiency by avoiding a copy. Second, in the case\n+   --  of calling compile, it is possible using the procedural form of Compile\n+   --  to use a single Pattern_Matcher variable for several different\n+   --  expressions by setting its size sufficiently large.\n+\n+   Auto_Size : constant := 0;\n+   --  Used in calls to Match to indicate that the Size should be set to\n+   --  a value appropriate to the expression being used automatically.\n+\n+   type Regexp_Flags is mod 256;\n+   for Regexp_Flags'Size use 8;\n+   --  Flags that can be given at compile time to specify default\n+   --  properties for the regular expression.\n+\n+   No_Flags         : constant Regexp_Flags;\n+   Case_Insensitive : constant Regexp_Flags;\n+   --  The automaton is optimized so that the matching is done in a case\n+   --  insensitive manner (upper case characters and lower case characters\n+   --  are all treated the same way).\n+\n+   Single_Line      : constant Regexp_Flags;\n+   --  Treat the Data we are matching as a single line. This means that\n+   --  ^ and $ will ignore \\n (unless Multiple_Lines is also specified),\n+   --  and that '.' will match \\n.\n+\n+   Multiple_Lines   : constant Regexp_Flags;\n+   --  Treat the Data as multiple lines. This means that ^ and $ will also\n+   --  match on internal newlines (ASCII.LF), in addition to the beginning\n+   --  and end of the string.\n+   --\n+   --  This can be combined with Single_Line.\n+\n+   -----------------\n+   -- Match_Array --\n+   -----------------\n+\n+   subtype Match_Count is Natural range 0 .. Max_Paren_Count;\n+\n+   type Match_Location is record\n+      First : Natural := 0;\n+      Last  : Natural := 0;\n+   end record;\n+\n+   type Match_Array is array (Match_Count range <>) of Match_Location;\n+   --  Used for regular expressions that can contain parenthesized\n+   --  subexpressions. Certain Match subprograms below produce Matches of type\n+   --  Match_Array. Each component of Matches is set to the subrange of the\n+   --  matches substring, or to No_Match if no match. Matches (N) is for the\n+   --  N'th parenthesized subexpressions; Matches (0) is for the whole\n+   --  expression.\n+   --\n+   --  For instance, if your regular expression is: \"a((b*)c+)(d+)\", then\n+   --                                                 12      3\n+   --     Matches (0) is for \"a((b*)c+)(d+)\" (the entire expression)\n+   --     Matches (1) is for \"(b*)c+\"\n+   --     Matches (2) is for \"c+\"\n+   --     Matches (3) is for \"d+\"\n+   --\n+   --  The number of parenthesis groups that can be retrieved is limited only\n+   --  by Max_Paren_Count.\n+   --\n+   --  Normally, the bounds of the Matches actual parameter will be\n+   --  0 .. Paren_Count (Regexp), to get all the matches. However, it is fine\n+   --  if Matches is shorter than that on either end; missing components will\n+   --  be ignored. Thus, in the above example, you could use 2 .. 2 if all you\n+   --  care about it the second parenthesis pair \"b*\". Likewise, if\n+   --  Matches'Last > Paren_Count (Regexp), the extra components will be set to\n+   --  No_Match.\n+\n+   No_Match : constant Match_Location := (First => 0, Last => 0);\n+   --  The No_Match constant is (0, 0) to differentiate between matching a null\n+   --  string at position 1, which uses (1, 0) and no match at all.\n+\n+   ---------------------------------\n+   -- Pattern_Matcher Compilation --\n+   ---------------------------------\n+\n+   --  The subprograms here are used to precompile regular expressions for use\n+   --  in subsequent Match calls. Precompilation improves efficiency if the\n+   --  same regular expression is to be used in more than one Match call.\n+\n+   type Pattern_Matcher (Size : Program_Size) is private;\n+   --  Type used to represent a regular expression compiled into byte code\n+\n+   Never_Match : constant Pattern_Matcher;\n+   --  A regular expression that never matches anything\n+\n+   function Compile\n+     (Expression : String;\n+      Flags      : Regexp_Flags := No_Flags) return Pattern_Matcher;\n+   --  Compile a regular expression into internal code\n+   --\n+   --  Raises Expression_Error if Expression is not a legal regular expression\n+   --\n+   --  The appropriate size is calculated automatically to correspond to the\n+   --  provided expression. This is the normal default method of compilation.\n+   --  Note that it is generally not possible to assign the result of two\n+   --  different calls to this Compile function to the same Pattern_Matcher\n+   --  variable, since the sizes will differ.\n+   --\n+   --  Flags is the default value to use to set properties for Expression\n+   --  (e.g. case sensitivity,...).\n+\n+   procedure Compile\n+     (Matcher         : out Pattern_Matcher;\n+      Expression      : String;\n+      Final_Code_Size : out Program_Size;\n+      Flags           : Regexp_Flags := No_Flags);\n+   --  Compile a regular expression into into internal code\n+\n+   --  This procedure is significantly faster than the Compile function since\n+   --  it avoids the extra step of precomputing the required size.\n+   --\n+   --  However, it requires the user to provide a Pattern_Matcher variable\n+   --  whose size is preset to a large enough value. One advantage of this\n+   --  approach, in addition to the improved efficiency, is that the same\n+   --  Pattern_Matcher variable can be used to hold the compiled code for\n+   --  several different regular expressions by setting a size that is large\n+   --  enough to accomodate all possibilities.\n+   --\n+   --  In this version of the procedure call, the actual required code size is\n+   --  returned. Also if Matcher.Size is zero on entry, then the resulting code\n+   --  is not stored. A call with Matcher.Size set to Auto_Size can thus be\n+   --  used to determine the space required for compiling the given regular\n+   --  expression.\n+   --\n+   --  This function raises Storage_Error if Matcher is too small to hold\n+   --  the resulting code (i.e. Matcher.Size has too small a value).\n+   --\n+   --  Expression_Error is raised if the string Expression does not contain\n+   --  a valid regular expression.\n+   --\n+   --  Flags is the default value to use to set properties for Expression (case\n+   --  sensitivity,...).\n+\n+   procedure Compile\n+     (Matcher    : out Pattern_Matcher;\n+      Expression : String;\n+      Flags      : Regexp_Flags := No_Flags);\n+   --  Same procedure as above, expect it does not return the final\n+   --  program size, and Matcher.Size cannot be Auto_Size.\n+\n+   function Paren_Count (Regexp : Pattern_Matcher) return Match_Count;\n+   pragma Inline (Paren_Count);\n+   --  Return the number of parenthesis pairs in Regexp.\n+   --\n+   --  This is the maximum index that will be filled if a Match_Array is\n+   --  used as an argument to Match.\n+   --\n+   --  Thus, if you want to be sure to get all the parenthesis, you should\n+   --  do something like:\n+   --\n+   --     declare\n+   --        Regexp  : Pattern_Matcher := Compile (\"a(b*)(c+)\");\n+   --        Matched : Match_Array (0 .. Paren_Count (Regexp));\n+   --     begin\n+   --        Match (Regexp, \"a string\", Matched);\n+   --     end;\n+\n+   -------------\n+   -- Quoting --\n+   -------------\n+\n+   function Quote (Str : String) return String;\n+   --  Return a version of Str so that every special character is quoted.\n+   --  The resulting string can be used in a regular expression to match\n+   --  exactly Str, whatever character was present in Str.\n+\n+   --------------\n+   -- Matching --\n+   --------------\n+\n+   --  The Match subprograms are given a regular expression in string\n+   --  form, and perform the corresponding match. The following parameters\n+   --  are present in all forms of the Match call.\n+\n+   --    Expression contains the regular expression to be matched as a string\n+\n+   --    Data contains the string to be matched\n+\n+   --    Data_First is the lower bound for the match, i.e. Data (Data_First)\n+   --    will be the first character to be examined. If Data_First is set to\n+   --    the special value of -1 (the default), then the first character to\n+   --    be examined is Data (Data_First). However, the regular expression\n+   --    character ^ (start of string) still refers to the first character\n+   --    of the full string (Data (Data'First)), which is why there is a\n+   --    separate mechanism for specifying Data_First.\n+\n+   --    Data_Last is the upper bound for the match, i.e. Data (Data_Last)\n+   --    will be the last character to be examined. If Data_Last is set to\n+   --    the special value of Positive'Last (the default), then the last\n+   --    character to be examined is Data (Data_Last). However, the regular\n+   --    expression character $ (end of string) still refers to the last\n+   --    character of the full string (Data (Data'Last)), which is why there\n+   --    is a separate mechanism for specifying Data_Last.\n+\n+   --    Note: the use of Data_First and Data_Last is not equivalent to\n+   --    simply passing a slice as Expression because of the handling of\n+   --    regular expression characters ^ and $.\n+\n+   --    Size is the size allocated for the compiled byte code. Normally\n+   --    this is defaulted to Auto_Size which means that the appropriate\n+   --    size is allocated automatically. It is possible to specify an\n+   --    explicit size, which must be sufficiently large. This slightly\n+   --    increases the efficiency by avoiding the extra step of computing\n+   --    the appropriate size.\n+\n+   --  The following exceptions can be raised in calls to Match\n+   --\n+   --    Storage_Error is raised if a non-zero value is given for Size\n+   --    and it is too small to hold the compiled byte code.\n+   --\n+   --    Expression_Error is raised if the given expression is not a legal\n+   --    regular expression.\n+\n+   procedure Match\n+     (Expression : String;\n+      Data       : String;\n+      Matches    : out Match_Array;\n+      Size       : Program_Size := Auto_Size;\n+      Data_First : Integer      := -1;\n+      Data_Last  : Positive     := Positive'Last);\n+   --  This version returns the result of the match stored in Match_Array;\n+   --  see comments under Match_Array above for details.\n+\n+   function Match\n+     (Expression : String;\n+      Data       : String;\n+      Size       : Program_Size := Auto_Size;\n+      Data_First : Integer      := -1;\n+      Data_Last  : Positive     := Positive'Last) return Natural;\n+   --  This version returns the position where Data matches, or if there is\n+   --  no match, then the value Data'First - 1.\n+\n+   function Match\n+     (Expression : String;\n+      Data       : String;\n+      Size       : Program_Size := Auto_Size;\n+      Data_First : Integer      := -1;\n+      Data_Last  : Positive     := Positive'Last) return Boolean;\n+   --  This version returns True if the match succeeds, False otherwise\n+\n+   ------------------------------------------------\n+   -- Matching a Pre-Compiled Regular Expression --\n+   ------------------------------------------------\n+\n+   --  The following functions are significantly faster if you need to reuse\n+   --  the same regular expression multiple times, since you only have to\n+   --  compile it once. For these functions you must first compile the\n+   --  expression with a call to Compile as previously described.\n+\n+   --  The parameters Data, Data_First and Data_Last are as described\n+   --  in the previous section.\n+\n+   function  Match\n+     (Self       : Pattern_Matcher;\n+      Data       : String;\n+      Data_First : Integer  := -1;\n+      Data_Last  : Positive := Positive'Last) return Natural;\n+   --  Match Data using the given pattern matcher. Returns the position\n+   --  where Data matches, or (Data'First - 1) if there is no match.\n+\n+   function  Match\n+     (Self       : Pattern_Matcher;\n+      Data       : String;\n+      Data_First : Integer  := -1;\n+      Data_Last  : Positive := Positive'Last) return Boolean;\n+   --  Return True if Data matches using the given pattern matcher\n+\n+   pragma Inline (Match);\n+   --  All except the last one below\n+\n+   procedure Match\n+     (Self       : Pattern_Matcher;\n+      Data       : String;\n+      Matches    : out Match_Array;\n+      Data_First : Integer  := -1;\n+      Data_Last  : Positive := Positive'Last);\n+   --  Match Data using the given pattern matcher and store result in Matches;\n+   --  see comments under Match_Array above for details.\n+\n+   -----------\n+   -- Debug --\n+   -----------\n+\n+   procedure Dump (Self : Pattern_Matcher);\n+   --  Dump the compiled version of the regular expression matched by Self\n+\n+--------------------------\n+-- Private Declarations --\n+--------------------------\n+\n+private\n+\n+   subtype Pointer is Program_Size;\n+   --  The Pointer type is used to point into Program_Data\n+\n+   --  Note that the pointer type is not necessarily 2 bytes\n+   --  although it is stored in the program using 2 bytes\n+\n+   type Program_Data is array (Pointer range <>) of Character;\n+\n+   Program_First : constant := 1;\n+\n+   --  The \"internal use only\" fields in regexp are present to pass info from\n+   --  compile to execute that permits the execute phase to run lots faster on\n+   --  simple cases. They are:\n+\n+   --     First              character that must begin a match or ASCII.Nul\n+   --     Anchored           true iff match must start at beginning of line\n+   --     Must_Have          pointer to string that match must include or null\n+   --     Must_Have_Length   length of Must_Have string\n+\n+   --  First and Anchored permit very fast decisions on suitable starting\n+   --  points for a match, cutting down the work a lot. Must_Have permits fast\n+   --  rejection of lines that cannot possibly match.\n+\n+   --  The Must_Have tests are costly enough that Optimize supplies a Must_Have\n+   --  only if the r.e. contains something potentially expensive (at present,\n+   --  the only such thing detected is * or at the start of the r.e., which can\n+   --  involve a lot of backup). The length is supplied because the test in\n+   --  Execute needs it and Optimize is computing it anyway.\n+\n+   --  The initialization is meant to fail-safe in case the user of this\n+   --  package tries to use an uninitialized matcher. This takes advantage\n+   --  of the knowledge that ASCII.Nul translates to the end-of-program (EOP)\n+   --  instruction code of the state machine.\n+\n+   No_Flags         : constant Regexp_Flags := 0;\n+   Case_Insensitive : constant Regexp_Flags := 1;\n+   Single_Line      : constant Regexp_Flags := 2;\n+   Multiple_Lines   : constant Regexp_Flags := 4;\n+\n+   type Pattern_Matcher (Size : Pointer) is record\n+      First            : Character    := ASCII.NUL;  --  internal use only\n+      Anchored         : Boolean      := False;      --  internal use only\n+      Must_Have        : Pointer      := 0;          --  internal use only\n+      Must_Have_Length : Natural      := 0;          --  internal use only\n+      Paren_Count      : Natural      := 0;          --  # paren groups\n+      Flags            : Regexp_Flags := No_Flags;\n+      Program          : Program_Data (Program_First .. Size) :=\n+                           (others => ASCII.NUL);\n+   end record;\n+\n+   Never_Match : constant Pattern_Matcher :=\n+      (0, ASCII.NUL, False, 0, 0, 0, No_Flags, (others => ASCII.NUL));\n+\n+end System.Regpat;"}, {"sha": "e374b0cced3eb622d78c1642f8b297a9613eee86", "filename": "gcc/ada/s-string.adb", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-string.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-string.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-string.adb?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -0,0 +1,61 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . S T R I N G S                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1995-2007, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body System.Strings is\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (Arg : in out String_List_Access) is\n+      X : String_Access;\n+\n+      procedure Free_Array is new Ada.Unchecked_Deallocation\n+        (Object => String_List, Name => String_List_Access);\n+\n+   begin\n+      --  First free all the String_Access components if any\n+\n+      if Arg /= null then\n+         for J in Arg'Range loop\n+            X := Arg (J);\n+            Free (X);\n+         end loop;\n+      end if;\n+\n+      --  Now free the allocated array\n+\n+      Free_Array (Arg);\n+   end Free;\n+\n+end System.Strings;"}, {"sha": "6b32cbf9aeb8fb61c0c73cd311fe9b4ff8fa1939", "filename": "gcc/ada/s-string.ads", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-string.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-string.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-string.ads?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -0,0 +1,63 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . S T R I N G S                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1995-2007, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Common String access types and related subprograms\n+\n+--  Note: this package is in the System hierarchy so that it can be directly\n+--  be used by other predefined packages. User access to this package is via\n+--  a renaming of this package in GNAT.String (file g-string.ads).\n+\n+with Ada.Unchecked_Deallocation;\n+\n+package System.Strings is\n+   pragma Preelaborate;\n+\n+   type String_Access is access all String;\n+   --  General purpose string access type. Note that the caller is\n+   --  responsible for freeing allocated strings to avoid memory leaks.\n+\n+   procedure Free is new Ada.Unchecked_Deallocation\n+     (Object => String, Name => String_Access);\n+   --  This procedure is provided for freeing allocated values of type\n+   --  String_Access.\n+\n+   type String_List is array (Positive range <>) of String_Access;\n+   type String_List_Access is access all String_List;\n+   --  General purpose array and pointer for list of string accesses\n+\n+   procedure Free (Arg : in out String_List_Access);\n+   --  Frees the given array and all strings that its elements reference,\n+   --  and then sets the argument to null. Provided for freeing allocated\n+   --  values of this type.\n+\n+end System.Strings;"}, {"sha": "71a8fce635a9f10f32b87ae6d14b7a38b320f6fd", "filename": "gcc/ada/s-tasloc.adb", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-tasloc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-tasloc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasloc.adb?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -0,0 +1,57 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                     S Y S T E M . T A S K _ L O C K                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 1997-2007, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Soft_Links;\n+--  used for Lock_Task, Unlock_Task\n+\n+package body System.Task_Lock is\n+\n+   ----------\n+   -- Lock --\n+   ----------\n+\n+   procedure Lock is\n+   begin\n+      System.Soft_Links.Lock_Task.all;\n+   end Lock;\n+\n+   ------------\n+   -- Unlock --\n+   ------------\n+\n+   procedure Unlock is\n+   begin\n+      System.Soft_Links.Unlock_Task.all;\n+   end Unlock;\n+\n+end System.Task_Lock;"}, {"sha": "804eca0a7fec89ae110c1dac1e314cdefb84315b", "filename": "gcc/ada/s-tasloc.ads", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-tasloc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-tasloc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasloc.ads?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -0,0 +1,100 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                     S Y S T E M . T A S K _ L O C K                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                     Copyright (C) 1998-2007, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Simple task lock and unlock routines\n+\n+--  A small package containing a task lock and unlock routines for creating\n+--  a critical region. The lock involved is a global lock, shared by all\n+--  tasks, and by all calls to these routines, so these routines should be\n+--  used with care to avoid unnecessary reduction of concurrency.\n+\n+--  These routines may be used in a non-tasking program, and in that case\n+--  they have no effect (they do NOT cause the tasking runtime to be loaded).\n+\n+--  Note: this package is in the System hierarchy so that it can be directly\n+--  be used by other predefined packages. User access to this package is via\n+--  a renaming of this package in GNAT.Task_Lock (file g-tasloc.ads).\n+\n+package System.Task_Lock is\n+   pragma Elaborate_Body;\n+\n+   procedure Lock;\n+   pragma Inline (Lock);\n+   --  Acquires the global lock, starts the execution of a critical region\n+   --  which no other task can enter until the locking task calls Unlock\n+\n+   procedure Unlock;\n+   pragma Inline (Unlock);\n+   --  Releases the global lock, allowing another task to successfully\n+   --  complete a Lock operation. Terminates the critical region.\n+   --\n+   --  The recommended protocol for using these two procedures is as\n+   --  follows:\n+   --\n+   --    Locked_Processing : begin\n+   --       Lock;\n+   --       ...\n+   --       TSL.Unlock;\n+   --\n+   --    exception\n+   --       when others =>\n+   --          Unlock;\n+   --          raise;\n+   --    end Locked_Processing;\n+   --\n+   --  This ensures that the lock is not left set if an exception is raised\n+   --  explicitly or implicitly during the critical locked region.\n+   --\n+   --  Note on multiple calls to Lock: It is permissible to call Lock\n+   --  more than once with no intervening Unlock from a single task,\n+   --  and the lock will not be released until the corresponding number\n+   --  of Unlock operations has been performed. For example:\n+   --\n+   --    System.Task_Lock.Lock;     -- acquires lock\n+   --    System.Task_Lock.Lock;     -- no effect\n+   --    System.Task_Lock.Lock;     -- no effect\n+   --    System.Task_Lock.Unlock;   -- no effect\n+   --    System.Task_Lock.Unlock;   -- no effect\n+   --    System.Task_Lock.Unlock;   -- releases lock\n+   --\n+   --  However, as previously noted, the Task_Lock facility should only\n+   --  be used for very local locks where the probability of conflict is\n+   --  low, so usually this kind of nesting is not a good idea in any case.\n+   --  In more complex locking situations, it is more appropriate to define\n+   --  an appropriate protected type to provide the required locking.\n+   --\n+   --  It is an error to call Unlock when there has been no prior call to\n+   --  Lock. The effect of such an erroneous call is undefined, and may\n+   --  result in deadlock, or other malfunction of the run-time system.\n+\n+end System.Task_Lock;"}, {"sha": "b19adcbc1812c4a2ec0ee5778b08a3e1a96bb38d", "filename": "gcc/ada/s-tfsetr-default.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-tfsetr-default.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-tfsetr-default.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tfsetr-default.adb?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 2001-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2001-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,8 +34,8 @@\n --  This version is for all targets, provided that System.IO.Put_Line is\n --  functional. It prints debug information to Standard Output\n \n-with System.IO;   use System.IO;\n-with GNAT.Regpat; use GNAT.Regpat;\n+with System.IO;     use System.IO;\n+with System.Regpat; use System.Regpat;\n \n ----------------\n -- Send_Trace --"}, {"sha": "d879d206754fa248bd098e8c4b991da0fc4a4c38", "filename": "gcc/ada/s-utf_32.adb", "status": "added", "additions": 5306, "deletions": 0, "changes": 5306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-utf_32.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-utf_32.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-utf_32.adb?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce"}, {"sha": "b3a756fb44490e78183213d1c80e2ef8373275d8", "filename": "gcc/ada/s-utf_32.ads", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-utf_32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fs-utf_32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-utf_32.ads?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -0,0 +1,197 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                        S Y S T E M . U T F _ 3 2                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2005-2007, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package is an internal package that provides basic character\n+--  classification capabilities needed by the compiler for handling full\n+--  32-bit wide wide characters. We avoid the use of the actual type\n+--  Wide_Wide_Character, since we want to use these routines in the compiler\n+--  itself, and we want to be able to compile the compiler with old versions\n+--  of GNAT that did not implement Wide_Wide_Character.\n+\n+--  System.UTF_32 should not be directly used from an application program, but\n+--  an equivalent package GNAT.UTF_32 can be used directly and provides exactly\n+--  the same services. The reason this package is in System is so that it can\n+--  with'ed by other packages in the Ada and System hierarchies.\n+\n+package System.UTF_32 is\n+\n+   type UTF_32 is range 0 .. 16#7FFF_FFFF#;\n+   --  So far, the only defined character codes are in 0 .. 16#01_FFFF#\n+\n+   --  The following type defines the categories from the unicode definitions.\n+   --  The one addition we make is Fe, which represents the characters FFFE\n+   --  and FFFF in any of the planes.\n+\n+   type Category is (\n+     Cc,   --  Other, Control\n+     Cf,   --  Other, Format\n+     Cn,   --  Other, Not Assigned\n+     Co,   --  Other, Private Use\n+     Cs,   --  Other, Surrogate\n+     Ll,   --  Letter, Lowercase\n+     Lm,   --  Letter, Modifier\n+     Lo,   --  Letter, Other\n+     Lt,   --  Letter, Titlecase\n+     Lu,   --  Letter, Uppercase\n+     Mc,   --  Mark, Spacing Combining\n+     Me,   --  Mark, Enclosing\n+     Mn,   --  Mark, Nonspacing\n+     Nd,   --  Number, Decimal Digit\n+     Nl,   --  Number, Letter\n+     No,   --  Number, Other\n+     Pc,   --  Punctuation, Connector\n+     Pd,   --  Punctuation, Dash\n+     Pe,   --  Punctuation, Close\n+     Pf,   --  Punctuation, Final quote\n+     Pi,   --  Punctuation, Initial quote\n+     Po,   --  Punctuation, Other\n+     Ps,   --  Punctuation, Open\n+     Sc,   --  Symbol, Currency\n+     Sk,   --  Symbol, Modifier\n+     Sm,   --  Symbol, Math\n+     So,   --  Symbol, Other\n+     Zl,   --  Separator, Line\n+     Zp,   --  Separator, Paragraph\n+     Zs,   --  Separator, Space\n+     Fe);  --  relative position FFFE/FFFF in any plane\n+\n+   function Get_Category (U : UTF_32) return Category;\n+   --  Given a UTF32 code, returns corresponding Category, or Cn if\n+   --  the code does not have an assigned unicode category.\n+\n+   --  The following functions perform category tests corresponding to lexical\n+   --  classes defined in the Ada standard. There are two interfaces for each\n+   --  function. The second takes a Category (e.g. returned by Get_Category).\n+   --  The first takes a UTF_32 code. The form taking the UTF_32 code is\n+   --  typically more efficient than calling Get_Category, but if several\n+   --  different tests are to be performed on the same code, it is more\n+   --  efficient to use Get_Category to get the category, then test the\n+   --  resulting category.\n+\n+   function Is_UTF_32_Letter (U : UTF_32)   return Boolean;\n+   function Is_UTF_32_Letter (C : Category) return Boolean;\n+   pragma Inline (Is_UTF_32_Letter);\n+   --  Returns true iff U is a letter that can be used to start an identifier,\n+   --  or if C is one of the corresponding categories, which are the following:\n+   --    Letter, Uppercase (Lu)\n+   --    Letter, Lowercase (Ll)\n+   --    Letter, Titlecase (Lt)\n+   --    Letter, Modifier  (Lm)\n+   --    Letter, Other     (Lo)\n+   --    Number, Letter    (Nl)\n+\n+   function Is_UTF_32_Digit (U : UTF_32)   return Boolean;\n+   function Is_UTF_32_Digit (C : Category) return Boolean;\n+   pragma Inline (Is_UTF_32_Digit);\n+   --  Returns true iff U is a digit that can be used to extend an identifer,\n+   --  or if C is one of the corresponding categories, which are the following:\n+   --    Number, Decimal_Digit (Nd)\n+\n+   function Is_UTF_32_Line_Terminator (U : UTF_32) return Boolean;\n+   pragma Inline (Is_UTF_32_Line_Terminator);\n+   --  Returns true iff U is an allowed line terminator for source programs,\n+   --  if U is in the category Zp (Separator, Paragaph), or Zs (Separator,\n+   --  Line), or if U is a conventional line terminator (CR, LF, VT, FF).\n+   --  There is no category version for this function, since the set of\n+   --  characters does not correspond to a set of Unicode categories.\n+\n+   function Is_UTF_32_Mark (U : UTF_32)   return Boolean;\n+   function Is_UTF_32_Mark (C : Category) return Boolean;\n+   pragma Inline (Is_UTF_32_Mark);\n+   --  Returns true iff U is a mark character which can be used to extend an\n+   --  identifier, or if C is one of the corresponding categories, which are\n+   --  the following:\n+   --    Mark, Non-Spacing (Mn)\n+   --    Mark, Spacing Combining (Mc)\n+\n+   function Is_UTF_32_Other (U : UTF_32)   return Boolean;\n+   function Is_UTF_32_Other (C : Category) return Boolean;\n+   pragma Inline (Is_UTF_32_Other);\n+   --  Returns true iff U is an other format character, which means that it\n+   --  can be used to extend an identifier, but is ignored for the purposes of\n+   --  matching of identiers, or if C is one of the corresponding categories,\n+   --  which are the following:\n+   --    Other, Format (Cf)\n+\n+   function Is_UTF_32_Punctuation (U : UTF_32)   return Boolean;\n+   function Is_UTF_32_Punctuation (C : Category) return Boolean;\n+   pragma Inline (Is_UTF_32_Punctuation);\n+   --  Returns true iff U is a punctuation character that can be used to\n+   --  separate pices of an identifier, or if C is one of the corresponding\n+   --  categories, which are the following:\n+   --    Punctuation, Connector (Pc)\n+\n+   function Is_UTF_32_Space (U : UTF_32)   return Boolean;\n+   function Is_UTF_32_Space (C : Category) return Boolean;\n+   pragma Inline (Is_UTF_32_Space);\n+   --  Returns true iff U is considered a space to be ignored, or if C is one\n+   --  of the corresponding categories, which are the following:\n+   --    Separator, Space (Zs)\n+\n+   function Is_UTF_32_Non_Graphic (U : UTF_32)   return Boolean;\n+   function Is_UTF_32_Non_Graphic (C : Category) return Boolean;\n+   pragma Inline (Is_UTF_32_Non_Graphic);\n+   --  Returns true iff U is considered to be a non-graphic character, or if C\n+   --  is one of the corresponding categories, which are the following:\n+   --    Other, Control (Cc)\n+   --    Other, Private Use (Co)\n+   --    Other, Surrogate (Cs)\n+   --    Separator, Line (Zl)\n+   --    Separator, Paragraph (Zp)\n+   --    FFFE or FFFF positions in any plane (Fe)\n+   --\n+   --  Note that the Ada category format effector is subsumed by the above\n+   --  list of Unicode categories.\n+   --\n+   --  Note that Other, Unassiged (Cn) is quite deliberately not included\n+   --  in the list of categories above. This means that should any of these\n+   --  code positions be defined in future with graphic characters they will\n+   --  be allowed without a need to change implementations or the standard.\n+   --\n+   --  Note that Other, Format (Cf) is also quite deliberately not included\n+   --  in the list of categories above. This means that these characters can\n+   --  be included in character and string literals.\n+\n+   --  The following function is used to fold to upper case, as required by\n+   --  the Ada 2005 standard rules for identifier case folding. Two\n+   --  identifiers are equivalent if they are identical after folding all\n+   --  letters to upper case using this routine.\n+\n+   function UTF_32_To_Upper_Case (U : UTF_32) return UTF_32;\n+   pragma Inline (UTF_32_To_Upper_Case);\n+   --  If U represents a lower case letter, returns the corresponding upper\n+   --  case letter, otherwise U is returned unchanged. The folding is locale\n+   --  independent as defined by documents referenced in the note in section\n+   --  1 of ISO/IEC 10646:2003\n+\n+end System.UTF_32;"}, {"sha": "82117389c2e84d0cefab07cac12cab9e1ccdac29", "filename": "gcc/ada/switch-m.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fswitch-m.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Fswitch-m.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-m.ads?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2001-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,7 +30,7 @@\n --  switches that are recognized. In addition, package Debug documents\n --  the otherwise undocumented debug switches that are also recognized.\n \n-with GNAT.OS_Lib; use GNAT.OS_Lib;\n+with System.OS_Lib; use System.OS_Lib;\n \n package Switch.M is\n "}, {"sha": "06de84a747e7cc4d3e9e46a79c34871992e9da7c", "filename": "gcc/ada/tree_in.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Ftree_in.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Ftree_in.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftree_in.ads?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---     Copyright (C) 1992,1993,1994,1995 Free Software Foundation, Inc.     --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,7 +36,7 @@\n --  tools that need to read the tree to the tree reading routines, and is\n --  thus bound as part of such tools.\n \n-with GNAT.OS_Lib; use GNAT.OS_Lib;\n+with System.OS_Lib; use System.OS_Lib;\n \n procedure Tree_In (Desc : File_Descriptor);\n --  Desc is the file descriptor for the file containing the tree, as written"}, {"sha": "64f883a619820ecedd43161f372a0194c7437196", "filename": "gcc/ada/tree_io.ads", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Ftree_io.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30681738f9948fa5a6f9c4c1b597bcf91ecdecce/gcc%2Fada%2Ftree_io.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftree_io.ads?ref=30681738f9948fa5a6f9c4c1b597bcf91ecdecce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,9 +36,10 @@\n --  create and close routines are elsewhere (in Osint in the compiler, and in\n --  the tree read driver for the tree read interface).\n \n-with GNAT.OS_Lib; use GNAT.OS_Lib;\n-with System;      use System;\n-with Types;       use Types;\n+with Types; use Types;\n+\n+with System;        use System;\n+with System.OS_Lib; use System.OS_Lib;\n \n package Tree_IO is\n "}]}