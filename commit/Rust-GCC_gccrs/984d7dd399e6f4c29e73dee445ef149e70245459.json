{"sha": "984d7dd399e6f4c29e73dee445ef149e70245459", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg0ZDdkZDM5OWU2ZjRjMjllNzNkZWU0NDVlZjE0OWU3MDI0NTQ1OQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2007-06-06T10:14:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:14:46Z"}, "message": "2007-04-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* a-calend.ads, a-calend.adb, a-calend-vms.ads, a-calend-vms.adb (\"-\"\n\t(Time, Time)): Use To_Relative_Time rather than manual calculation to\n\texpress the bounds of Duration as Time. Raise Time_Error when the\n\tresult is greater or equal to the higher bound of Duration (on the\n\tmargin case).\n\t(\"+\" (Time, Duration)): Reorder code. Remove the declaration of constant\n\tAda_High_And_Leaps.\n\t(\"-\" (Time, Duration)): Reorder code. Remove the declaration of constant\n\tAda_High_And_Leaps.\n\t(\"-\" (Time, Time)): Reorder code.\n\t(All_Leap_Seconds): Removed.\n\t(Arithmetic_Operations.Add): Remove sign related kludge.\n\t(Arithmetic_Operations.Difference): Control the leaps seconds processing\n\twith flag Leap_Support.\n\t(Arithmetic_Operations.Subtract): Remove sign related kludge.\n\t(Check_Within_Time_Bounds): New procedure.\n\t(Clock): Control the leap seconds processing with flag Leap_Support.\n\t(Cumulative_Leap_Seconds): Assert that the target supports leap seconds.\n\t(Formatting_Operations.Split): Control the leap seconds processing with\n\tflag Leap_Support.\n\t(Formatting_Operations.Time_Of): Control the leaps seconds processing\n\twith flag Leap_Support. Adjust the year, month and day (if applicable)\n\twhen the value of day seconds designates a new day.\n\t(Split): Use parameter associations for better readability. Integrate\n\tflag Is_Ada_05.\n\t(Time_Of): Use parameter associations for better readability. Integrate\n\tflag Is_Ada_05.\n\n\t* a-calfor.adb (Split): Use parameter associations for better\n\treadability. Integrate flag Is_Ada_05.\n\t(Time_Of): Remove flag Leap_Checks. Use parameter associations for\n\tbetter readability. Integrate flag Is_Ada_05.\n\nFrom-SVN: r125363", "tree": {"sha": "82b6ae097e3527bf05464afd6655618c004ec21e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82b6ae097e3527bf05464afd6655618c004ec21e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/984d7dd399e6f4c29e73dee445ef149e70245459", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/984d7dd399e6f4c29e73dee445ef149e70245459", "html_url": "https://github.com/Rust-GCC/gccrs/commit/984d7dd399e6f4c29e73dee445ef149e70245459", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/984d7dd399e6f4c29e73dee445ef149e70245459/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f936abf3bd4ddf1631fd4169a9295a0a135b8748", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f936abf3bd4ddf1631fd4169a9295a0a135b8748", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f936abf3bd4ddf1631fd4169a9295a0a135b8748"}], "stats": {"total": 2066, "additions": 1053, "deletions": 1013}, "files": [{"sha": "4707e133e5affa10d69be1073e54fbb9dc96419f", "filename": "gcc/ada/a-calend-vms.adb", "status": "modified", "additions": 382, "deletions": 264, "changes": 646, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/984d7dd399e6f4c29e73dee445ef149e70245459/gcc%2Fada%2Fa-calend-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/984d7dd399e6f4c29e73dee445ef149e70245459/gcc%2Fada%2Fa-calend-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend-vms.adb?ref=984d7dd399e6f4c29e73dee445ef149e70245459", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -46,12 +46,40 @@ package body Ada.Calendar is\n    --  Variables of type Ada.Calendar.Time have suffix _S or _M to denote\n    --  units of seconds or milis.\n \n+   --  Because time is measured in different units and from different origins\n+   --  on various targets, a system independent model is incorporated into\n+   --  Ada.Calendar. The idea behing the design is to encapsulate all target\n+   --  dependent machinery in a single package, thus providing a uniform\n+   --  interface to all existing and any potential children.\n+\n+   --     package Ada.Calendar\n+   --        procedure Split (5 parameters) -------+\n+   --                                              | Call from local routine\n+   --     private                                  |\n+   --        package Formatting_Operations         |\n+   --           procedure Split (11 parameters) <--+\n+   --        end Formatting_Operations             |\n+   --     end Ada.Calendar                         |\n+   --                                              |\n+   --     package Ada.Calendar.Formatting          | Call from child routine\n+   --        procedure Split (9 or 10 parameters) -+\n+   --     end Ada.Calendar.Formatting\n+\n+   --  The behaviour of the interfacing routines is controlled via various\n+   --  flags. All new Ada 2005 types from children of Ada.Calendar are\n+   --  emulated by a similar type. For instance, type Day_Number is replaced\n+   --  by Integer in various routines. One ramification of this model is that\n+   --  the caller site must perform validity checks on returned results.\n+   --  The end result of this model is the lack of target specific files per\n+   --  child of Ada.Calendar (a-calfor, a-calfor-vms, a-calfor-vxwors, etc).\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n-   function All_Leap_Seconds return Natural;\n-   --  Return the number of all leap seconds allocated so far\n+   procedure Check_Within_Time_Bounds (T : Time);\n+   --  Ensure that a time representation value falls withing the bounds of Ada\n+   --  time. Leap seconds support is taken into account.\n \n    procedure Cumulative_Leap_Seconds\n      (Start_Date    : Time;\n@@ -60,10 +88,10 @@ package body Ada.Calendar is\n       Next_Leap_Sec : out Time);\n    --  Elapsed_Leaps is the sum of the leap seconds that have occured on or\n    --  after Start_Date and before (strictly before) End_Date. Next_Leap_Sec\n-   --  represents the next leap second occurence on or after End_Date. If there\n-   --  are no leaps seconds after End_Date, After_Last_Leap is returned.\n-   --  After_Last_Leap can be used as End_Date to count all the leap seconds\n-   --  that have occured on or after Start_Date.\n+   --  represents the next leap second occurence on or after End_Date. If\n+   --  there are no leaps seconds after End_Date, End_Of_Time is returned.\n+   --  End_Of_Time can be used as End_Date to count all the leap seconds that\n+   --  have occured on or after Start_Date.\n    --\n    --  Note: Any sub seconds of Start_Date and End_Date are discarded before\n    --  the calculations are done. For instance: if 113 seconds is a leap\n@@ -88,14 +116,36 @@ package body Ada.Calendar is\n    -- Local Constants --\n    ---------------------\n \n-   After_Last_Leap : constant Time := Time'Last;\n-   N_Leap_Seconds  : constant Natural := 23;\n+   --  Currently none of the GNAT targets support leap seconds. At some point\n+   --  it might be necessary to query a C function to determine if the target\n+   --  supports leap seconds, but for now this is deemed unnecessary.\n+\n+   Leap_Support       : constant Boolean := False;\n+   Leap_Seconds_Count : constant Natural := 23;\n+\n+   --  The range of Ada time expressed as milis since the VMS Epoch\n+\n+   Ada_Low  : constant Time :=  (10 * 366 +  32 * 365 + 45) * Milis_In_Day;\n+   Ada_High : constant Time := (131 * 366 + 410 * 365 + 45) * Milis_In_Day;\n+\n+   --  Even though the upper bound of time is 2399-12-31 23:59:59.9999999\n+   --  UTC, it must be increased to include all leap seconds.\n+\n+   Ada_High_And_Leaps : constant Time :=\n+                          Ada_High + Time (Leap_Seconds_Count) * Mili;\n+\n+   --  Two constants used in the calculations of elapsed leap seconds.\n+   --  End_Of_Time is later than Ada_High in time zone -28. Start_Of_Time\n+   --  is earlier than Ada_Low in time zone +28.\n+\n+   End_Of_Time   : constant Time := Ada_High + Time (3) * Milis_In_Day;\n+   Start_Of_Time : constant Time := Ada_Low  - Time (3) * Milis_In_Day;\n \n    Cumulative_Days_Before_Month :\n      constant array (Month_Number) of Natural :=\n        (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334);\n \n-   Leap_Second_Times : array (1 .. N_Leap_Seconds) of Time;\n+   Leap_Second_Times : array (1 .. Leap_Seconds_Count) of Time;\n    --  Each value represents a time value which is one second before a leap\n    --  second occurence. This table is populated during the elaboration of\n    --  Ada.Calendar.\n@@ -107,18 +157,21 @@ package body Ada.Calendar is\n    function \"+\" (Left : Time; Right : Duration) return Time is\n       pragma Unsuppress (Overflow_Check);\n \n-      Ada_High_And_Leaps : constant Time :=\n-                             Ada_High + Time (All_Leap_Seconds) * Mili;\n-      Result             : constant Time := Left + To_Relative_Time (Right);\n+      Res_M : Time;\n \n    begin\n-      if Result < Ada_Low\n-        or else Result >= Ada_High_And_Leaps\n-      then\n-         raise Time_Error;\n+      --  Trivial case\n+\n+      if Right = Duration (0.0) then\n+         return Left;\n       end if;\n \n-      return Result;\n+      Res_M := Left + To_Relative_Time (Right);\n+\n+      Check_Within_Time_Bounds (Res_M);\n+\n+      return Res_M;\n+\n    exception\n       when Constraint_Error =>\n          raise Time_Error;\n@@ -140,18 +193,20 @@ package body Ada.Calendar is\n    function \"-\" (Left : Time; Right : Duration) return Time is\n       pragma Unsuppress (Overflow_Check);\n \n-      Ada_High_And_Leaps : constant Time :=\n-                             Ada_High + Time (All_Leap_Seconds) * Mili;\n-      Result             : constant Time := Left - To_Relative_Time (Right);\n+      Res_M : Time;\n \n    begin\n-      if Result < Ada_Low\n-        or else Result >= Ada_High_And_Leaps\n-      then\n-         raise Time_Error;\n+      --  Trivial case\n+\n+      if Right = Duration (0.0) then\n+         return Left;\n       end if;\n \n-      return Result;\n+      Res_M := Left - To_Relative_Time (Right);\n+\n+      Check_Within_Time_Bounds (Res_M);\n+\n+      return Res_M;\n \n    exception\n       when Constraint_Error =>\n@@ -161,19 +216,25 @@ package body Ada.Calendar is\n    function \"-\" (Left : Time; Right : Time) return Duration is\n       pragma Unsuppress (Overflow_Check);\n \n-      Diff     : constant Time := Left - Right;\n-      Dur_High : constant Time := Time (Duration'Last) * 100;\n-      Dur_Low  : constant Time := Time (Duration'First) * 100;\n+      --  The bound of type Duration expressed as time\n+\n+      Dur_High : constant Time := To_Relative_Time (Duration'Last);\n+      Dur_Low  : constant Time := To_Relative_Time (Duration'First);\n+\n+      Res_M : Time;\n \n    begin\n-      if Diff < Dur_Low\n-        or else Diff > Dur_High\n+      Res_M := Left - Right;\n+\n+      --  The result does not fit in a duration value\n+\n+      if Res_M < Dur_Low\n+        or else Res_M >= Dur_High\n       then\n          raise Time_Error;\n       end if;\n \n-      return To_Duration (Diff);\n-\n+      return To_Duration (Res_M);\n    exception\n       when Constraint_Error =>\n          raise Time_Error;\n@@ -215,42 +276,58 @@ package body Ada.Calendar is\n       return Long_Integer (Left) >= Long_Integer (Right);\n    end \">=\";\n \n-   ----------------------\n-   -- All_Leap_Seconds --\n-   ----------------------\n+   ------------------------------\n+   -- Check_Within_Time_Bounds --\n+   ------------------------------\n \n-   function All_Leap_Seconds return Natural is\n+   procedure Check_Within_Time_Bounds (T : Time) is\n    begin\n-      return N_Leap_Seconds;\n-   end All_Leap_Seconds;\n+      if Leap_Support then\n+         if T < Ada_Low or else T > Ada_High_And_Leaps then\n+            raise Time_Error;\n+         end if;\n+      else\n+         if T < Ada_Low or else T > Ada_High then\n+            raise Time_Error;\n+         end if;\n+      end if;\n+   end Check_Within_Time_Bounds;\n \n    -----------\n    -- Clock --\n    -----------\n \n    function Clock return Time is\n       Elapsed_Leaps : Natural;\n-      Next_Leap     : Time;\n-      Now           : constant Time := Time (OSP.OS_Clock);\n-      Rounded_Now   : constant Time := Now - (Now mod Mili);\n+      Next_Leap_M   : Time;\n+      Res_M         : constant Time := Time (OSP.OS_Clock);\n \n    begin\n       --  Note that on other targets a soft-link is used to get a different\n       --  clock depending whether tasking is used or not. On VMS this isn't\n       --  needed since all clock calls end up using SYS$GETTIM, so call the\n       --  OS_Primitives version for efficiency.\n \n-      --  Determine the number of leap seconds elapsed until this moment\n+      --  If the target supports leap seconds, determine the number of leap\n+      --  seconds elapsed until this moment.\n+\n+      if Leap_Support then\n+         Cumulative_Leap_Seconds\n+           (Start_Of_Time, Res_M, Elapsed_Leaps, Next_Leap_M);\n+\n+         --  The system clock may fall exactly on a leap second\n \n-      Cumulative_Leap_Seconds (Ada_Low, Now, Elapsed_Leaps, Next_Leap);\n+         if Res_M >= Next_Leap_M then\n+            Elapsed_Leaps := Elapsed_Leaps + 1;\n+         end if;\n \n-      --  It is possible that OS_Clock falls exactly on a leap second\n+      --  The target does not support leap seconds\n \n-      if Rounded_Now = Next_Leap then\n-         return Now + Time (Elapsed_Leaps + 1) * Mili;\n       else\n-         return Now + Time (Elapsed_Leaps) * Mili;\n+         Elapsed_Leaps := 0;\n       end if;\n+\n+      return Res_M + Time (Elapsed_Leaps) * Mili;\n    end Clock;\n \n    -----------------------------\n@@ -269,9 +346,9 @@ package body Ada.Calendar is\n       Start_T     : Time := Start_Date;\n \n    begin\n-      pragma Assert (Start_Date >= End_Date);\n+      pragma Assert (Leap_Support and then End_Date >= Start_Date);\n \n-      Next_Leap_Sec := After_Last_Leap;\n+      Next_Leap_Sec := End_Of_Time;\n \n       --  Make sure that the end date does not excede the upper bound\n       --  of Ada time.\n@@ -285,23 +362,26 @@ package body Ada.Calendar is\n       Start_T := Start_T - (Start_T mod Mili);\n       End_T   := End_T   - (End_T   mod Mili);\n \n-      --  Some trivial cases\n+      --  Some trivial cases:\n+      --                     Leap 1 . . . Leap N\n+      --  ---+========+------+############+-------+========+-----\n+      --     Start_T  End_T                       Start_T  End_T\n \n       if End_T < Leap_Second_Times (1) then\n          Elapsed_Leaps := 0;\n          Next_Leap_Sec := Leap_Second_Times (1);\n          return;\n \n-      elsif Start_T > Leap_Second_Times (N_Leap_Seconds) then\n+      elsif Start_T > Leap_Second_Times (Leap_Seconds_Count) then\n          Elapsed_Leaps := 0;\n-         Next_Leap_Sec := After_Last_Leap;\n+         Next_Leap_Sec := End_Of_Time;\n          return;\n       end if;\n \n       --  Perform the calculations only if the start date is within the leap\n       --  second occurences table.\n \n-      if Start_T <= Leap_Second_Times (N_Leap_Seconds) then\n+      if Start_T <= Leap_Second_Times (Leap_Seconds_Count) then\n \n          --    1    2                  N - 1   N\n          --  +----+----+--  . . .  --+-------+---+\n@@ -313,8 +393,8 @@ package body Ada.Calendar is\n          --             Leaps_Between\n \n          --  The idea behind the algorithm is to iterate and find two closest\n-         --  dates which are after Start_T and End_T. Their corresponding index\n-         --  difference denotes the number of leap seconds elapsed.\n+         --  dates which are after Start_T and End_T. Their corresponding\n+         --  index difference denotes the number of leap seconds elapsed.\n \n          Start_Index := 1;\n          loop\n@@ -324,12 +404,12 @@ package body Ada.Calendar is\n \n          End_Index := Start_Index;\n          loop\n-            exit when End_Index > N_Leap_Seconds\n+            exit when End_Index > Leap_Seconds_Count\n               or else Leap_Second_Times (End_Index) >= End_T;\n             End_Index := End_Index + 1;\n          end loop;\n \n-         if End_Index <= N_Leap_Seconds then\n+         if End_Index <= Leap_Seconds_Count then\n             Next_Leap_Sec := Leap_Second_Times (End_Index);\n          end if;\n \n@@ -423,8 +503,22 @@ package body Ada.Calendar is\n       Le : Boolean;\n \n    begin\n+      --  Use UTC as the local time zone on VMS, the status of flag Is_Ada_05\n+      --  is irrelevant in this case.\n+\n       Formatting_Operations.Split\n-        (Date, Year, Month, Day, Seconds, H, M, Se, Ss, Le, 0);\n+        (Date      => Date,\n+         Year      => Year,\n+         Month     => Month,\n+         Day       => Day,\n+         Day_Secs  => Seconds,\n+         Hour      => H,\n+         Minute    => M,\n+         Second    => Se,\n+         Sub_Sec   => Ss,\n+         Leap_Sec  => Le,\n+         Is_Ada_05 => False,\n+         Time_Zone => 0);\n \n       --  Validity checks\n \n@@ -465,12 +559,22 @@ package body Ada.Calendar is\n          raise Time_Error;\n       end if;\n \n+      --  Use UTC as the local time zone on VMS, the status of flag Is_Ada_05\n+      --  is irrelevant in this case.\n+\n       return\n         Formatting_Operations.Time_Of\n-          (Year, Month, Day, Seconds, H, M, Se, Ss,\n+          (Year         => Year,\n+           Month        => Month,\n+           Day          => Day,\n+           Day_Secs     => Seconds,\n+           Hour         => H,\n+           Minute       => M,\n+           Second       => Se,\n+           Sub_Sec      => Ss,\n            Leap_Sec     => False,\n-           Leap_Checks  => False,\n            Use_Day_Secs => True,\n+           Is_Ada_05    => False,\n            Time_Zone    => 0);\n    end Time_Of;\n \n@@ -524,29 +628,22 @@ package body Ada.Calendar is\n       ---------\n \n       function Add (Date : Time; Days : Long_Integer) return Time is\n-         Ada_High_And_Leaps : constant Time :=\n-                                Ada_High + Time (All_Leap_Seconds) * Mili;\n+         pragma Unsuppress (Overflow_Check);\n+\n+         Res_M : Time;\n+\n       begin\n+         --  Trivial case\n+\n          if Days = 0 then\n             return Date;\n+         end if;\n \n-         elsif Days < 0 then\n-            return Subtract (Date, abs (Days));\n+         Res_M := Date + Time (Days) * Milis_In_Day;\n \n-         else\n-            declare\n-               Result : constant Time := Date + Time (Days) * Milis_In_Day;\n+         Check_Within_Time_Bounds (Res_M);\n \n-            begin\n-               --  The result excedes the upper bound of Ada time\n-\n-               if Result >= Ada_High_And_Leaps then\n-                  raise Time_Error;\n-               end if;\n-\n-               return Result;\n-            end;\n-         end if;\n+         return Res_M;\n \n       exception\n          when Constraint_Error =>\n@@ -571,7 +668,7 @@ package body Ada.Calendar is\n          Earlier       : Time;\n          Elapsed_Leaps : Natural;\n          Later         : Time;\n-         Negate        : Boolean;\n+         Negate        : Boolean := False;\n          Next_Leap     : Time;\n          Sub_Seconds   : Duration;\n \n@@ -582,19 +679,26 @@ package body Ada.Calendar is\n          if Left >= Right then\n             Later   := Left;\n             Earlier := Right;\n-            Negate  := False;\n          else\n             Later   := Right;\n             Earlier := Left;\n             Negate  := True;\n          end if;\n \n-         --  First process the leap seconds\n+         --  If the target supports leap seconds, process them\n \n-         Cumulative_Leap_Seconds (Earlier, Later, Elapsed_Leaps, Next_Leap);\n+         if Leap_Support then\n+            Cumulative_Leap_Seconds\n+              (Earlier, Later, Elapsed_Leaps, Next_Leap);\n \n-         if Later >= Next_Leap then\n-            Elapsed_Leaps := Elapsed_Leaps + 1;\n+            if Later >= Next_Leap then\n+               Elapsed_Leaps := Elapsed_Leaps + 1;\n+            end if;\n+\n+         --  The target does not support leap seconds\n+\n+         else\n+            Elapsed_Leaps := 0;\n          end if;\n \n          Diff_M := Later - Earlier - Time (Elapsed_Leaps) * Mili;\n@@ -613,9 +717,12 @@ package body Ada.Calendar is\n          Leap_Seconds := Integer (Elapsed_Leaps);\n \n          if Negate then\n-            Days         := -Days;\n-            Seconds      := -Seconds;\n-            Leap_Seconds := -Leap_Seconds;\n+            Days    := -Days;\n+            Seconds := -Seconds;\n+\n+            if Leap_Seconds /= 0 then\n+               Leap_Seconds := -Leap_Seconds;\n+            end if;\n          end if;\n       end Difference;\n \n@@ -624,32 +731,22 @@ package body Ada.Calendar is\n       --------------\n \n       function Subtract (Date : Time; Days : Long_Integer) return Time is\n+         pragma Unsuppress (Overflow_Check);\n+\n+         Res_M : Time;\n+\n       begin\n+         --  Trivial case\n+\n          if Days = 0 then\n             return Date;\n+         end if;\n \n-         elsif Days < 0 then\n-            return Add (Date, abs (Days));\n+         Res_M := Date - Time (Days) * Milis_In_Day;\n \n-         else\n-            declare\n-               Days_T : constant Time := Time (Days) * Milis_In_Day;\n-               Result : constant Time := Date - Days_T;\n-\n-            begin\n-               --  Subtracting a larger number of days from a smaller time\n-               --  value will cause wrap around since time is a modular type.\n-               --  Also the result may be lower than the start of Ada time.\n-\n-               if Date < Days_T\n-                 or Result < Ada_Low\n-               then\n-                  raise Time_Error;\n-               end if;\n+         Check_Within_Time_Bounds (Res_M);\n \n-               return Date - Days_T;\n-            end;\n-         end if;\n+         return Res_M;\n       exception\n          when Constraint_Error =>\n             raise Time_Error;\n@@ -696,18 +793,23 @@ package body Ada.Calendar is\n       -----------\n \n       procedure Split\n-        (Date         : Time;\n-         Year         : out Year_Number;\n-         Month        : out Month_Number;\n-         Day          : out Day_Number;\n-         Day_Secs     : out Day_Duration;\n-         Hour         : out Integer;\n-         Minute       : out Integer;\n-         Second       : out Integer;\n-         Sub_Sec      : out Duration;\n-         Leap_Sec     : out Boolean;\n-         Time_Zone    : Long_Integer)\n+        (Date      : Time;\n+         Year      : out Year_Number;\n+         Month     : out Month_Number;\n+         Day       : out Day_Number;\n+         Day_Secs  : out Day_Duration;\n+         Hour      : out Integer;\n+         Minute    : out Integer;\n+         Second    : out Integer;\n+         Sub_Sec   : out Duration;\n+         Leap_Sec  : out Boolean;\n+         Is_Ada_05 : Boolean;\n+         Time_Zone : Long_Integer)\n       is\n+         --  The flag Is_Ada_05 is present for interfacing purposes\n+\n+         pragma Unreferenced (Is_Ada_05);\n+\n          procedure Numtim\n            (Status : out Unsigned_Longword;\n             Timbuf : out Unsigned_Word_Array;\n@@ -727,59 +829,60 @@ package body Ada.Calendar is\n          Ada_Max_Year : constant := 2399;\n          Mili_F       : constant Duration := 10_000_000.0;\n \n-         Abs_Time_Zone   : Time;\n-         Elapsed_Leaps   : Natural;\n-         Modified_Date_M : Time;\n-         Next_Leap_M     : Time;\n-         Rounded_Date_M  : Time;\n+         Date_M        : Time;\n+         Elapsed_Leaps : Natural;\n+         Next_Leap_M   : Time;\n \n       begin\n-         Modified_Date_M := Date;\n+         Date_M := Date;\n \n          --  Step 1: Leap seconds processing\n \n-         Cumulative_Leap_Seconds (Ada_Low, Date, Elapsed_Leaps, Next_Leap_M);\n+         if Leap_Support then\n+            Cumulative_Leap_Seconds\n+              (Start_Of_Time, Date, Elapsed_Leaps, Next_Leap_M);\n+\n+            Leap_Sec := Date_M >= Next_Leap_M;\n+\n+            if Leap_Sec then\n+               Elapsed_Leaps := Elapsed_Leaps + 1;\n+            end if;\n \n-         Rounded_Date_M  := Modified_Date_M - (Modified_Date_M mod Mili);\n-         Leap_Sec        := Rounded_Date_M = Next_Leap_M;\n-         Modified_Date_M := Modified_Date_M - Time (Elapsed_Leaps) * Mili;\n+         --  The target does not support leap seconds\n \n-         if Leap_Sec then\n-            Modified_Date_M := Modified_Date_M - Time (1) * Mili;\n+         else\n+            Elapsed_Leaps := 0;\n+            Leap_Sec      := False;\n          end if;\n \n+         Date_M := Date_M - Time (Elapsed_Leaps) * Mili;\n+\n          --  Step 2: Time zone processing\n \n          if Time_Zone /= 0 then\n-            Abs_Time_Zone := Time (abs (Time_Zone)) * 60 * Mili;\n-\n-            if Time_Zone < 0 then\n-               Modified_Date_M := Modified_Date_M - Abs_Time_Zone;\n-            else\n-               Modified_Date_M := Modified_Date_M + Abs_Time_Zone;\n-            end if;\n+            Date_M := Date_M + Time (Time_Zone) * 60 * Mili;\n          end if;\n \n          --  After the leap seconds and time zone have been accounted for,\n          --  the date should be within the bounds of Ada time.\n \n-         if Modified_Date_M < Ada_Low\n-           or else Modified_Date_M >= Ada_High\n+         if Date_M < Ada_Low\n+           or else Date_M > Ada_High\n          then\n             raise Time_Error;\n          end if;\n \n          --  Step 3: Sub second processing\n \n-         Sub_Sec := Duration (Modified_Date_M mod Mili) / Mili_F;\n+         Sub_Sec := Duration (Date_M mod Mili) / Mili_F;\n \n          --  Drop the sub seconds\n \n-         Modified_Date_M := Modified_Date_M - (Modified_Date_M mod Mili);\n+         Date_M := Date_M - (Date_M mod Mili);\n \n          --  Step 4: VMS system call\n \n-         Numtim (Status, Timbuf, Modified_Date_M);\n+         Numtim (Status, Timbuf, Date_M);\n \n          if Status mod 2 /= 1\n            or else Timbuf (1) not in Ada_Min_Year .. Ada_Max_Year\n@@ -816,8 +919,8 @@ package body Ada.Calendar is\n          Second       : Integer;\n          Sub_Sec      : Duration;\n          Leap_Sec     : Boolean;\n-         Leap_Checks  : Boolean;\n          Use_Day_Secs : Boolean;\n+         Is_Ada_05    : Boolean;\n          Time_Zone    : Long_Integer) return Time\n       is\n          procedure Cvt_Vectim\n@@ -837,21 +940,19 @@ package body Ada.Calendar is\n \n          Mili_F : constant := 10_000_000.0;\n \n-         Ada_High_And_Leaps : constant Time :=\n-                                Ada_High + Time (All_Leap_Seconds) * Mili;\n-\n-         H  : Integer  := Hour;\n-         Mi : Integer  := Minute;\n-         Se : Integer  := Second;\n-         Su : Duration := Sub_Sec;\n+         Y  : Year_Number  := Year;\n+         Mo : Month_Number := Month;\n+         D  : Day_Number   := Day;\n+         H  : Integer      := Hour;\n+         Mi : Integer      := Minute;\n+         Se : Integer      := Second;\n+         Su : Duration     := Sub_Sec;\n \n-         Abs_Time_Zone    : Time;\n-         Adjust_Day       : Boolean := False;\n-         Elapsed_Leaps    : Natural;\n-         Int_Day_Secs     : Integer;\n-         Next_Leap_M      : Time;\n-         Result_M         : Time;\n-         Rounded_Result_M : Time;\n+         Elapsed_Leaps : Natural;\n+         Int_Day_Secs  : Integer;\n+         Next_Leap_M   : Time;\n+         Res_M         : Time;\n+         Rounded_Res_M : Time;\n \n       begin\n          --  No validity checks are performed on the input values since it is\n@@ -861,15 +962,47 @@ package body Ada.Calendar is\n \n          if Use_Day_Secs then\n \n-            --  A day seconds value of 86_400 designates a new day. The time\n-            --  components are reset to zero, but an additional day will be\n-            --  added after the system call.\n+            --  A day seconds value of 86_400 designates a new day\n \n             if Day_Secs = 86_400.0 then\n-               Adjust_Day := True;\n-               H  := 0;\n-               Mi := 0;\n-               Se := 0;\n+               declare\n+                  Adj_Year  : Year_Number := Year;\n+                  Adj_Month : Month_Number := Month;\n+                  Adj_Day   : Day_Number   := Day;\n+\n+               begin\n+                  if Day < Days_In_Month (Month)\n+                    or else (Month = 2\n+                               and then Is_Leap (Year))\n+                  then\n+                     Adj_Day := Day + 1;\n+\n+                  --  The day adjustment moves the date to a new month\n+\n+                  else\n+                     Adj_Day := 1;\n+\n+                     if Month < 12 then\n+                        Adj_Month := Month + 1;\n+\n+                     --  The month adjustment moves the date to a new year\n+\n+                     else\n+                        Adj_Month := 1;\n+                        Adj_Year  := Year + 1;\n+                     end if;\n+                  end if;\n+\n+                  Y  := Adj_Year;\n+                  Mo := Adj_Month;\n+                  D  := Adj_Day;\n+                  H  := 0;\n+                  Mi := 0;\n+                  Se := 0;\n+                  Su := 0.0;\n+               end;\n+\n+            --  Normal case (not exactly one day)\n \n             else\n                --  Sub second extraction\n@@ -889,81 +1022,64 @@ package body Ada.Calendar is\n \n          --  Step 2: System call to VMS\n \n-         Timbuf (1) := Unsigned_Word (Year);\n-         Timbuf (2) := Unsigned_Word (Month);\n-         Timbuf (3) := Unsigned_Word (Day);\n+         Timbuf (1) := Unsigned_Word (Y);\n+         Timbuf (2) := Unsigned_Word (Mo);\n+         Timbuf (3) := Unsigned_Word (D);\n          Timbuf (4) := Unsigned_Word (H);\n          Timbuf (5) := Unsigned_Word (Mi);\n          Timbuf (6) := Unsigned_Word (Se);\n          Timbuf (7) := 0;\n \n-         Cvt_Vectim (Status, Timbuf, Result_M);\n+         Cvt_Vectim (Status, Timbuf, Res_M);\n \n          if Status mod 2 /= 1 then\n             raise Time_Error;\n          end if;\n \n-         --  Step 3: Potential day adjustment\n+         --  Step 3: Sub second adjustment\n \n-         if Use_Day_Secs\n-           and then Adjust_Day\n-         then\n-            Result_M := Result_M + Milis_In_Day;\n-         end if;\n+         Res_M := Res_M + Time (Su * Mili_F);\n \n-         --  Step 4: Sub second adjustment\n+         --  Step 4: Bounds check\n \n-         Result_M := Result_M + Time (Su * Mili_F);\n+         Check_Within_Time_Bounds (Res_M);\n \n          --  Step 5: Time zone processing\n \n          if Time_Zone /= 0 then\n-            Abs_Time_Zone := Time (abs (Time_Zone)) * 60 * Mili;\n-\n-            if Time_Zone < 0 then\n-               Result_M := Result_M + Abs_Time_Zone;\n-            else\n-               Result_M := Result_M - Abs_Time_Zone;\n-            end if;\n+            Res_M := Res_M - Time (Time_Zone) * 60 * Mili;\n          end if;\n \n          --  Step 6: Leap seconds processing\n \n-         Cumulative_Leap_Seconds\n-           (Ada_Low, Result_M, Elapsed_Leaps, Next_Leap_M);\n+         if Leap_Support then\n+            Cumulative_Leap_Seconds\n+              (Start_Of_Time, Res_M, Elapsed_Leaps, Next_Leap_M);\n \n-         Result_M := Result_M + Time (Elapsed_Leaps) * Mili;\n+            Res_M := Res_M + Time (Elapsed_Leaps) * Mili;\n \n-         --  An Ada 2005 caller requesting an explicit leap second or an Ada\n-         --  95 caller accounting for an invisible leap second.\n+            --  An Ada 2005 caller requesting an explicit leap second or an\n+            --  Ada 95 caller accounting for an invisible leap second.\n \n-         Rounded_Result_M := Result_M - (Result_M mod Mili);\n+            if Leap_Sec\n+              or else Res_M >= Next_Leap_M\n+            then\n+               Res_M := Res_M + Time (1) * Mili;\n+            end if;\n \n-         if Leap_Sec\n-           or else Rounded_Result_M = Next_Leap_M\n-         then\n-            Result_M := Result_M + Time (1) * Mili;\n-            Rounded_Result_M := Rounded_Result_M + Time (1) * Mili;\n-         end if;\n+            --  Leap second validity check\n \n-         --  Leap second validity check\n+            Rounded_Res_M := Res_M - (Res_M mod Mili);\n \n-         if Leap_Checks\n-           and then Leap_Sec\n-           and then Rounded_Result_M /= Next_Leap_M\n-         then\n-            raise Time_Error;\n-         end if;\n-\n-         --  Bounds check\n-\n-         if Result_M < Ada_Low\n-           or else Result_M >= Ada_High_And_Leaps\n-         then\n-            raise Time_Error;\n+            if Is_Ada_05\n+              and then Leap_Sec\n+              and then Rounded_Res_M /= Next_Leap_M\n+            then\n+               raise Time_Error;\n+            end if;\n          end if;\n \n-         return Result_M;\n+         return Res_M;\n       end Time_Of;\n    end Formatting_Operations;\n \n@@ -1000,71 +1116,73 @@ package body Ada.Calendar is\n begin\n    --  Population of the leap seconds table\n \n-   declare\n-      type Leap_Second_Date is record\n-         Year  : Year_Number;\n-         Month : Month_Number;\n-         Day   : Day_Number;\n-      end record;\n-\n-      Leap_Second_Dates :\n-        constant array (1 .. N_Leap_Seconds) of Leap_Second_Date :=\n-          ((1972,  6, 30), (1972, 12, 31), (1973, 12, 31), (1974, 12, 31),\n-           (1975, 12, 31), (1976, 12, 31), (1977, 12, 31), (1978, 12, 31),\n-           (1979, 12, 31), (1981,  6, 30), (1982,  6, 30), (1983,  6, 30),\n-           (1985,  6, 30), (1987, 12, 31), (1989, 12, 31), (1990, 12, 31),\n-           (1992,  6, 30), (1993,  6, 30), (1994,  6, 30), (1995, 12, 31),\n-           (1997,  6, 30), (1998, 12, 31), (2005, 12, 31));\n-\n-      Ada_Min_Year       : constant Year_Number := Year_Number'First;\n-      Days_In_Four_Years : constant := 365 * 3 + 366;\n-      VMS_Days           : constant := 10 * 366 + 32 * 365 + 45;\n-\n-      Days  : Natural;\n-      Leap  : Leap_Second_Date;\n-      Years : Natural;\n+   if Leap_Support then\n+      declare\n+         type Leap_Second_Date is record\n+            Year  : Year_Number;\n+            Month : Month_Number;\n+            Day   : Day_Number;\n+         end record;\n+\n+         Leap_Second_Dates :\n+           constant array (1 .. Leap_Seconds_Count) of Leap_Second_Date :=\n+             ((1972,  6, 30), (1972, 12, 31), (1973, 12, 31), (1974, 12, 31),\n+              (1975, 12, 31), (1976, 12, 31), (1977, 12, 31), (1978, 12, 31),\n+              (1979, 12, 31), (1981,  6, 30), (1982,  6, 30), (1983,  6, 30),\n+              (1985,  6, 30), (1987, 12, 31), (1989, 12, 31), (1990, 12, 31),\n+              (1992,  6, 30), (1993,  6, 30), (1994,  6, 30), (1995, 12, 31),\n+              (1997,  6, 30), (1998, 12, 31), (2005, 12, 31));\n+\n+         Ada_Min_Year       : constant Year_Number := Year_Number'First;\n+         Days_In_Four_Years : constant := 365 * 3 + 366;\n+         VMS_Days           : constant := 10 * 366 + 32 * 365 + 45;\n+\n+         Days  : Natural;\n+         Leap  : Leap_Second_Date;\n+         Years : Natural;\n \n-   begin\n-      for Index in 1 .. N_Leap_Seconds loop\n-         Leap := Leap_Second_Dates (Index);\n+      begin\n+         for Index in 1 .. Leap_Seconds_Count loop\n+            Leap := Leap_Second_Dates (Index);\n \n-         --  Calculate the number of days from the start of Ada time until\n-         --  the current leap second occurence. Non-leap centenial years\n-         --  are not accounted for in these calculations since there are\n-         --  no leap seconds after 2100 yet.\n+            --  Calculate the number of days from the start of Ada time until\n+            --  the current leap second occurence. Non-leap centenial years\n+            --  are not accounted for in these calculations since there are\n+            --  no leap seconds after 2100 yet.\n \n-         Years := Leap.Year - Ada_Min_Year;\n-         Days  := (Years / 4) * Days_In_Four_Years;\n-         Years := Years mod 4;\n+            Years := Leap.Year - Ada_Min_Year;\n+            Days  := (Years / 4) * Days_In_Four_Years;\n+            Years := Years mod 4;\n \n-         if Years = 1 then\n-            Days := Days + 365;\n+            if Years = 1 then\n+               Days := Days + 365;\n \n-         elsif Years = 2 then\n-            Days := Days + 365 * 2;\n+            elsif Years = 2 then\n+               Days := Days + 365 * 2;\n \n-         elsif Years = 3 then\n-            Days := Days + 365 * 3;\n-         end if;\n+            elsif Years = 3 then\n+               Days := Days + 365 * 3;\n+            end if;\n \n-         Days := Days + Cumulative_Days_Before_Month (Leap.Month);\n+            Days := Days + Cumulative_Days_Before_Month (Leap.Month);\n \n-         if Is_Leap (Leap.Year)\n-           and then Leap.Month > 2\n-         then\n-            Days := Days + 1;\n-         end if;\n+            if Is_Leap (Leap.Year)\n+              and then Leap.Month > 2\n+            then\n+               Days := Days + 1;\n+            end if;\n \n-         --  Add the number of days since the start of VMS time till the\n-         --  start of Ada time.\n+            --  Add the number of days since the start of VMS time till the\n+            --  start of Ada time.\n \n-         Days := Days + Leap.Day + VMS_Days;\n+            Days := Days + Leap.Day + VMS_Days;\n \n-         --  Index - 1 previous leap seconds are added to Time (Index)\n+            --  Index - 1 previous leap seconds are added to Time (Index)\n \n-         Leap_Second_Times (Index) :=\n-           (Time (Days) * Secs_In_Day + Time (Index - 1)) * Mili;\n-      end loop;\n-   end;\n+            Leap_Second_Times (Index) :=\n+              (Time (Days) * Secs_In_Day + Time (Index - 1)) * Mili;\n+         end loop;\n+      end;\n+   end if;\n \n end Ada.Calendar;"}, {"sha": "f0c974927326b091ba93215d5cde70179ad28719", "filename": "gcc/ada/a-calend-vms.ads", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/984d7dd399e6f4c29e73dee445ef149e70245459/gcc%2Fada%2Fa-calend-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/984d7dd399e6f4c29e73dee445ef149e70245459/gcc%2Fada%2Fa-calend-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend-vms.ads?ref=984d7dd399e6f4c29e73dee445ef149e70245459", "patch": "@@ -113,7 +113,7 @@ private\n    --  system base date and time 1858-11-17 0.0 (the Smithsonian base date and\n    --  time for the astronomic calendar).\n \n-   --  The time value stored is typically a GMT value, as provided in standard\n+   --  The time value stored is typically a UTC value, as provided in standard\n    --  Unix environments. If this is the case then Split and Time_Of perform\n    --  required conversions to and from local times.\n \n@@ -123,11 +123,6 @@ private\n \n    type Time is new OSP.OS_Time;\n \n-   --  The range of Ada time expressed as milis since the VMS Epoch\n-\n-   Ada_Low  : constant Time :=  (10 * 366 +  32 * 365 + 45) * Milis_In_Day;\n-   Ada_High : constant Time := (131 * 366 + 410 * 365 + 45) * Milis_In_Day;\n-\n    Days_In_Month : constant array (Month_Number) of Day_Number :=\n                      (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);\n \n@@ -145,7 +140,7 @@ private\n \n    package Arithmetic_Operations is\n       function Add (Date : Time; Days : Long_Integer) return Time;\n-      --  Add X number of days to a time value\n+      --  Add a certain number of days to a time value\n \n       procedure Difference\n         (Left         : Time;\n@@ -159,7 +154,7 @@ private\n       --  values are positive, negative otherwise.\n \n       function Subtract (Date : Time; Days : Long_Integer) return Time;\n-      --  Subtract X number of days from a time value\n+      --  Subtract a certain number of days from a time value\n    end Arithmetic_Operations;\n \n    package Formatting_Operations is\n@@ -168,18 +163,21 @@ private\n       --  within the range of 0 .. 6 (Monday .. Sunday).\n \n       procedure Split\n-        (Date       : Time;\n-         Year       : out Year_Number;\n-         Month      : out Month_Number;\n-         Day        : out Day_Number;\n-         Day_Secs   : out Day_Duration;\n-         Hour       : out Integer;\n-         Minute     : out Integer;\n-         Second     : out Integer;\n-         Sub_Sec    : out Duration;\n-         Leap_Sec   : out Boolean;\n-         Time_Zone  : Long_Integer);\n-      --  Split a time value into its components\n+        (Date      : Time;\n+         Year      : out Year_Number;\n+         Month     : out Month_Number;\n+         Day       : out Day_Number;\n+         Day_Secs  : out Day_Duration;\n+         Hour      : out Integer;\n+         Minute    : out Integer;\n+         Second    : out Integer;\n+         Sub_Sec   : out Duration;\n+         Leap_Sec  : out Boolean;\n+         Is_Ada_05 : Boolean;\n+         Time_Zone : Long_Integer);\n+      --  Split a time value into its components. Set Is_Ada_05 to use the\n+      --  local time zone (the value in Time_Zone is ignored) when splitting\n+      --  a time value.\n \n       function Time_Of\n         (Year         : Year_Number;\n@@ -191,18 +189,20 @@ private\n          Second       : Integer;\n          Sub_Sec      : Duration;\n          Leap_Sec     : Boolean;\n-         Leap_Checks  : Boolean;\n          Use_Day_Secs : Boolean;\n+         Is_Ada_05    : Boolean;\n          Time_Zone    : Long_Integer) return Time;\n       --  Given all the components of a date, return the corresponding time\n       --  value. Set Use_Day_Secs to use the value in Day_Secs, otherwise the\n       --  day duration will be calculated from Hour, Minute, Second and Sub_\n-      --  Sec. Set flag Leap_Checks to verify the validity of a leap second.\n+      --  Sec. Set Is_Ada_05 to use the local time zone (the value in formal\n+      --  Time_Zone is ignored) when building a time value and to verify the\n+      --  validity of a requested leap second.\n    end Formatting_Operations;\n \n    package Time_Zones_Operations is\n       function UTC_Time_Offset (Date : Time) return Long_Integer;\n-      --  Return the offset in seconds from GMT\n+      --  Return the offset in seconds from UTC\n    end Time_Zones_Operations;\n \n end Ada.Calendar;"}, {"sha": "c2dc77c76519e2af02bccbb1945f9a8eafd283b0", "filename": "gcc/ada/a-calend.adb", "status": "modified", "additions": 544, "deletions": 646, "changes": 1190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/984d7dd399e6f4c29e73dee445ef149e70245459/gcc%2Fada%2Fa-calend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/984d7dd399e6f4c29e73dee445ef149e70245459/gcc%2Fada%2Fa-calend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend.adb?ref=984d7dd399e6f4c29e73dee445ef149e70245459", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -47,9 +47,9 @@ package body Ada.Calendar is\n    --\n    --  Because time is measured in different units and from different origins\n    --  on various targets, a system independent model is incorporated into\n-   --  Ada.Calendar. The idea behing the design is to encapsulate all target\n+   --  Ada.Calendar. The idea behind the design is to encapsulate all target\n    --  dependent machinery in a single package, thus providing a uniform\n-   --  interface to any existing and potential children.\n+   --  interface to all existing and any potential children.\n \n    --     package Ada.Calendar\n    --        procedure Split (5 parameters) -------+\n@@ -76,17 +76,21 @@ package body Ada.Calendar is\n    -- Local Subprograms --\n    -----------------------\n \n+   procedure Check_Within_Time_Bounds (T : Time_Rep);\n+   --  Ensure that a time representation value falls withing the bounds of Ada\n+   --  time. Leap seconds support is taken into account.\n+\n    procedure Cumulative_Leap_Seconds\n-     (Start_Date    : Time;\n-      End_Date      : Time;\n+     (Start_Date    : Time_Rep;\n+      End_Date      : Time_Rep;\n       Elapsed_Leaps : out Natural;\n-      Next_Leap_Sec : out Time);\n+      Next_Leap     : out Time_Rep);\n    --  Elapsed_Leaps is the sum of the leap seconds that have occured on or\n    --  after Start_Date and before (strictly before) End_Date. Next_Leap_Sec\n    --  represents the next leap second occurence on or after End_Date. If\n-   --  there are no leaps seconds after End_Date, After_Last_Leap is returned.\n-   --  After_Last_Leap can be used as End_Date to count all the leap seconds\n-   --  that have occured on or after Start_Date.\n+   --  there are no leaps seconds after End_Date, End_Of_Time is returned.\n+   --  End_Of_Time can be used as End_Date to count all the leap seconds that\n+   --  have occured on or after Start_Date.\n    --\n    --  Note: Any sub seconds of Start_Date and End_Date are discarded before\n    --  the calculations are done. For instance: if 113 seconds is a leap\n@@ -100,46 +104,77 @@ package body Ada.Calendar is\n    --  After_Last_Leap is designed so that this comparison works without\n    --  having to first check if Next_Leap_Sec is a valid leap second.\n \n-   function To_Abs_Duration (T : Time) return Duration;\n-   --  Convert a time value into a duration value. Note that the returned\n-   --  duration is always positive.\n+   function Duration_To_Time_Rep is\n+     new Ada.Unchecked_Conversion (Duration, Time_Rep);\n+   --  Convert a duration value into a time representation value\n+\n+   function Time_Rep_To_Duration is\n+     new Ada.Unchecked_Conversion (Time_Rep, Duration);\n+   --  Convert a time representation value into a duration value\n+\n+   -----------------\n+   -- Local Types --\n+   -----------------\n+\n+   --  An integer time duration. The type is used whenever a positive elapsed\n+   --  duration is needed, for instance when splitting a time value. Here is\n+   --  how Time_Rep and Time_Dur are related:\n+\n+   --            'First  Ada_Low                  Ada_High  'Last\n+   --  Time_Rep: +-------+------------------------+---------+\n+   --  Time_Dur:         +------------------------+---------+\n+   --                    0                                  'Last\n \n-   function To_Abs_Time (D : Duration) return Time;\n-   --  Return the time equivalent of a duration value. Since time cannot be\n-   --  negative, the absolute value of D is used. It is upto the called to\n-   --  decide how to handle negative durations converted into time.\n+   type Time_Dur is range 0 .. 2 ** 63 - 1;\n \n    ---------------------\n    -- Local Constants --\n    ---------------------\n \n+   --  Currently none of the GNAT targets support leap seconds. At some point\n+   --  it might be necessary to query a C function to determine if the target\n+   --  supports leap seconds, but for now this is deemed unnecessary.\n+\n+   Leap_Support       : constant Boolean := False;\n+   Leap_Seconds_Count : constant Natural := 23;\n+\n    Ada_Min_Year          : constant Year_Number := Year_Number'First;\n-   After_Last_Leap       : constant Time := Time'Last;\n-   Leap_Seconds_Count    : constant Natural := 23;\n    Secs_In_Four_Years    : constant := (3 * 365 + 366) * Secs_In_Day;\n    Secs_In_Non_Leap_Year : constant := 365 * Secs_In_Day;\n-   Time_Zero             : constant Time := Time'First;\n \n-   --  Even though the upper bound of Ada time is 2399-12-31 86_399.999999999\n-   --  GMT, it must be shifted to include all leap seconds.\n+   --  Lower and upper bound of Ada time. The zero (0) value of type Time is\n+   --  positioned at year 2150. Note that the lower and upper bound account\n+   --  for the non-leap centenial years.\n+\n+   Ada_Low  : constant Time_Rep := -(61 * 366 + 188 * 365) * Nanos_In_Day;\n+   Ada_High : constant Time_Rep :=  (60 * 366 + 190 * 365) * Nanos_In_Day;\n+\n+   --  Even though the upper bound of time is 2399-12-31 23:59:59.999999999\n+   --  UTC, it must be increased to include all leap seconds.\n \n-   Ada_High_And_Leaps : constant Time :=\n-                          Ada_High + Time (Leap_Seconds_Count) * Nano;\n+   Ada_High_And_Leaps : constant Time_Rep :=\n+                          Ada_High + Time_Rep (Leap_Seconds_Count) * Nano;\n \n-   Hard_Ada_High_And_Leaps : constant Time :=\n-                               Hard_Ada_High +\n-                               Time (Leap_Seconds_Count) * Nano;\n+   --  Two constants used in the calculations of elapsed leap seconds.\n+   --  End_Of_Time is later than Ada_High in time zone -28. Start_Of_Time\n+   --  is earlier than Ada_Low in time zone +28.\n+\n+   End_Of_Time   : constant Time_Rep :=\n+                     Ada_High + Time_Rep (3) * Nanos_In_Day;\n+   Start_Of_Time : constant Time_Rep :=\n+                     Ada_Low - Time_Rep (3) * Nanos_In_Day;\n \n    --  The Unix lower time bound expressed as nanoseconds since the\n-   --  start of Ada time in GMT.\n+   --  start of Ada time in UTC.\n \n-   Unix_Min : constant Time := (17 * 366 + 52 * 365) * Nanos_In_Day;\n+   Unix_Min : constant Time_Rep :=\n+                Ada_Low + Time_Rep (17 * 366 + 52 * 365) * Nanos_In_Day;\n \n    Cumulative_Days_Before_Month :\n      constant array (Month_Number) of Natural :=\n        (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334);\n \n-   Leap_Second_Times : array (1 .. Leap_Seconds_Count) of Time;\n+   Leap_Second_Times : array (1 .. Leap_Seconds_Count) of Time_Rep;\n    --  Each value represents a time value which is one second before a leap\n    --  second occurence. This table is populated during the elaboration of\n    --  Ada.Calendar.\n@@ -151,46 +186,21 @@ package body Ada.Calendar is\n    function \"+\" (Left : Time; Right : Duration) return Time is\n       pragma Unsuppress (Overflow_Check);\n \n-   begin\n-      if Right = 0.0 then\n-         return Left;\n+      Left_N : constant Time_Rep := Time_Rep (Left);\n+      Res_N  : Time_Rep;\n \n-      elsif Right < 0.0 then\n-\n-         --  Type Duration has one additional number in its negative subrange,\n-         --  which is Duration'First. The subsequent invocation of \"-\" will\n-         --  perform among other things an Unchecked_Conversion on that\n-         --  particular value, causing overflow. If not properly handled,\n-         --  the erroneous value will cause an infinite recursion between \"+\"\n-         --  and \"-\". To properly handle this boundary case, we make a small\n-         --  adjustment of one second to Duration'First.\n-\n-         if Right = Duration'First then\n-            return Left - abs (Right + 1.0) - 1.0;\n-         else\n-            return Left - abs (Right);\n-         end if;\n-\n-      else\n-         declare\n-            --  The input time value has been normalized to GMT\n+   begin\n+      --  Trivial case\n \n-            Result : constant Time := Left + To_Abs_Time (Right);\n+      if Right = Duration (0.0) then\n+         return Left;\n+      end if;\n \n-         begin\n-            --  The end result may excede the upper bound of Ada time. Note\n-            --  that the comparison operator is \">=\" rather than \">\" since\n-            --  the smallest increment of 0.000000001 to the legal end of\n-            --  time (2399-12-31 86_399.999999999) will render the result\n-            --  equal to Ada_High (2400-1-1 0.0).\n+      Res_N := Left_N + Duration_To_Time_Rep (Right);\n \n-            if Result >= Ada_High_And_Leaps then\n-               raise Time_Error;\n-            end if;\n+      Check_Within_Time_Bounds (Res_N);\n \n-            return Result;\n-         end;\n-      end if;\n+      return Time (Res_N);\n \n    exception\n       when Constraint_Error =>\n@@ -209,38 +219,21 @@ package body Ada.Calendar is\n    function \"-\" (Left : Time; Right : Duration) return Time is\n       pragma Unsuppress (Overflow_Check);\n \n-   begin\n-      if Right = 0.0 then\n-         return Left;\n-\n-      elsif Right < 0.0 then\n-         return Left + abs (Right);\n-\n-      else\n-         declare\n-            Result  : Time;\n-            Right_T : constant Time := To_Abs_Time (Right);\n+      Left_N : constant Time_Rep := Time_Rep (Left);\n+      Res_N  : Time_Rep;\n \n-         begin\n-            --  Subtracting a larger time value from a smaller time value\n-            --  will cause a wrap around since Time is a modular type. Note\n-            --  that the time value has been normalized to GMT.\n+   begin\n+      --  Trivial case\n \n-            if Left < Right_T then\n-               raise Time_Error;\n-            end if;\n+      if Right = Duration (0.0) then\n+         return Left;\n+      end if;\n \n-            Result := Left - Right_T;\n+      Res_N := Left_N - Duration_To_Time_Rep (Right);\n \n-            if Result < Ada_Low\n-              or else Result > Ada_High_And_Leaps\n-            then\n-               raise Time_Error;\n-            end if;\n+      Check_Within_Time_Bounds (Res_N);\n \n-            return Result;\n-         end;\n-      end if;\n+      return Time (Res_N);\n \n    exception\n       when Constraint_Error =>\n@@ -250,54 +243,25 @@ package body Ada.Calendar is\n    function \"-\" (Left : Time; Right : Time) return Duration is\n       pragma Unsuppress (Overflow_Check);\n \n-      function To_Time is new Ada.Unchecked_Conversion (Duration, Time);\n+      --  The bounds of type Duration expressed as time representations\n \n-      --  Since the absolute values of the upper and lower bound of duration\n-      --  are denoted by the same number, it is sufficend to use Duration'Last\n-      --  when performing out of range checks.\n+      Dur_Low  : constant Time_Rep := Duration_To_Time_Rep (Duration'First);\n+      Dur_High : constant Time_Rep := Duration_To_Time_Rep (Duration'Last);\n \n-      Duration_Bound : constant Time := To_Time (Duration'Last);\n-\n-      Earlier  : Time;\n-      Later    : Time;\n-      Negate   : Boolean := False;\n-      Result   : Time;\n-      Result_D : Duration;\n+      Res_N : Time_Rep;\n \n    begin\n-      --  This routine becomes a little tricky since time cannot be negative,\n-      --  but the subtraction of two time values can produce a negative value.\n-\n-      if Left > Right then\n-         Later   := Left;\n-         Earlier := Right;\n-      else\n-         Later   := Right;\n-         Earlier := Left;\n-         Negate  := True;\n-      end if;\n+      Res_N := Time_Rep (Left) - Time_Rep (Right);\n \n-      Result := Later - Earlier;\n+      --  The result does not fit in a duration value\n \n-      --  Check whether the resulting difference is within the range of type\n-      --  Duration. The following two conditions are examined with the same\n-      --  piece of code:\n-      --\n-      --     positive result > positive upper bound of duration\n-      --\n-      --     negative (negative result) > abs (negative bound of duration)\n-\n-      if Result > Duration_Bound then\n+      if Res_N < Dur_Low\n+        or else Res_N > Dur_High\n+      then\n          raise Time_Error;\n       end if;\n \n-      Result_D := To_Abs_Duration (Result);\n-\n-      if Negate then\n-         Result_D := -Result_D;\n-      end if;\n-\n-      return Result_D;\n+      return Time_Rep_To_Duration (Res_N);\n    exception\n       when Constraint_Error =>\n          raise Time_Error;\n@@ -339,63 +303,85 @@ package body Ada.Calendar is\n       return Time_Rep (Left) >= Time_Rep (Right);\n    end \">=\";\n \n+   ------------------------------\n+   -- Check_Within_Time_Bounds --\n+   ------------------------------\n+\n+   procedure Check_Within_Time_Bounds (T : Time_Rep) is\n+   begin\n+      if Leap_Support then\n+         if T < Ada_Low or else T > Ada_High_And_Leaps then\n+            raise Time_Error;\n+         end if;\n+      else\n+         if T < Ada_Low or else T > Ada_High then\n+            raise Time_Error;\n+         end if;\n+      end if;\n+   end Check_Within_Time_Bounds;\n+\n    -----------\n    -- Clock --\n    -----------\n \n    function Clock return Time is\n       Elapsed_Leaps : Natural;\n-      Next_Leap     : Time;\n-\n-      --  The system clock returns the time in GMT since the Unix Epoch of\n-      --  1970-1-1 0.0. We perform an origin shift to the Ada Epoch by adding\n-      --  the number of nanoseconds between the two origins.\n+      Next_Leap_N   : Time_Rep;\n \n-      Now : Time := To_Abs_Time (System.OS_Primitives.Clock) + Unix_Min;\n+      --  The system clock returns the time in UTC since the Unix Epoch of\n+      --  1970-01-01 00:00:00.0. We perform an origin shift to the Ada Epoch\n+      --  by adding the number of nanoseconds between the two origins.\n \n-      Rounded_Now : constant Time := Now - (Now mod Nano);\n+      Res_N : Time_Rep :=\n+                Duration_To_Time_Rep (System.OS_Primitives.Clock) +\n+                  Unix_Min;\n \n    begin\n-      --  Determine how many leap seconds have elapsed until this moment\n+      --  If the target supports leap seconds, determine the number of leap\n+      --  seconds elapsed until this moment.\n+\n+      if Leap_Support then\n+         Cumulative_Leap_Seconds\n+           (Start_Of_Time, Res_N, Elapsed_Leaps, Next_Leap_N);\n \n-      Cumulative_Leap_Seconds (Time_Zero, Now, Elapsed_Leaps, Next_Leap);\n+         --  The system clock may fall exactly on a leap second\n \n-      Now := Now + Time (Elapsed_Leaps) * Nano;\n+         if Res_N >= Next_Leap_N then\n+            Elapsed_Leaps := Elapsed_Leaps + 1;\n+         end if;\n \n-      --  The system clock may fall exactly on a leap second occurence\n+      --  The target does not support leap seconds\n \n-      if Rounded_Now = Next_Leap then\n-         Now := Now + Time (1) * Nano;\n+      else\n+         Elapsed_Leaps := 0;\n       end if;\n \n-      --  Add the buffer set aside for time zone processing since Split in\n-      --  Ada.Calendar.Formatting_Operations expects it to be there.\n+      Res_N := Res_N + Time_Rep (Elapsed_Leaps) * Nano;\n \n-      return Now + Buffer_N;\n+      return Time (Res_N);\n    end Clock;\n \n    -----------------------------\n    -- Cumulative_Leap_Seconds --\n    -----------------------------\n \n    procedure Cumulative_Leap_Seconds\n-     (Start_Date    : Time;\n-      End_Date      : Time;\n+     (Start_Date    : Time_Rep;\n+      End_Date      : Time_Rep;\n       Elapsed_Leaps : out Natural;\n-      Next_Leap_Sec : out Time)\n+      Next_Leap     : out Time_Rep)\n    is\n       End_Index   : Positive;\n-      End_T       : Time := End_Date;\n+      End_T       : Time_Rep := End_Date;\n       Start_Index : Positive;\n-      Start_T     : Time := Start_Date;\n+      Start_T     : Time_Rep := Start_Date;\n \n    begin\n-      --  Both input dates need to be normalized to GMT in order for this\n-      --  routine to work properly.\n+      --  Both input dates must be normalized to UTC\n \n-      pragma Assert (End_Date >= Start_Date);\n+      pragma Assert (Leap_Support and then End_Date >= Start_Date);\n \n-      Next_Leap_Sec := After_Last_Leap;\n+      Next_Leap := End_Of_Time;\n \n       --  Make sure that the end date does not excede the upper bound\n       --  of Ada time.\n@@ -416,12 +402,12 @@ package body Ada.Calendar is\n \n       if End_T < Leap_Second_Times (1) then\n          Elapsed_Leaps := 0;\n-         Next_Leap_Sec := Leap_Second_Times (1);\n+         Next_Leap     := Leap_Second_Times (1);\n          return;\n \n       elsif Start_T > Leap_Second_Times (Leap_Seconds_Count) then\n          Elapsed_Leaps := 0;\n-         Next_Leap_Sec := After_Last_Leap;\n+         Next_Leap     := End_Of_Time;\n          return;\n       end if;\n \n@@ -458,7 +444,7 @@ package body Ada.Calendar is\n          end loop;\n \n          if End_Index <= Leap_Seconds_Count then\n-            Next_Leap_Sec := Leap_Second_Times (End_Index);\n+            Next_Leap := Leap_Second_Times (End_Index);\n          end if;\n \n          Elapsed_Leaps := End_Index - Start_Index;\n@@ -549,12 +535,24 @@ package body Ada.Calendar is\n       Se : Integer;\n       Ss : Duration;\n       Le : Boolean;\n-      Tz : constant Long_Integer :=\n-             Time_Zones_Operations.UTC_Time_Offset (Date) / 60;\n \n    begin\n+      --  Even though the input time zone is UTC (0), the flag Is_Ada_05 will\n+      --  ensure that Split picks up the local time zone.\n+\n       Formatting_Operations.Split\n-        (Date, Year, Month, Day, Seconds, H, M, Se, Ss, Le, Tz);\n+        (Date      => Date,\n+         Year      => Year,\n+         Month     => Month,\n+         Day       => Day,\n+         Day_Secs  => Seconds,\n+         Hour      => H,\n+         Minute    => M,\n+         Second    => Se,\n+         Sub_Sec   => Ss,\n+         Leap_Sec  => Le,\n+         Is_Ada_05 => False,\n+         Time_Zone => 0);\n \n       --  Validity checks\n \n@@ -586,11 +584,9 @@ package body Ada.Calendar is\n       Se : constant Integer := 1;\n       Ss : constant Duration := 0.1;\n \n-      Mid_Offset : Long_Integer;\n-      Mid_Result : Time;\n-      Offset     : Long_Integer;\n-\n    begin\n+      --  Validity checks\n+\n       if not Year'Valid\n         or else not Month'Valid\n         or else not Day'Valid\n@@ -599,96 +595,25 @@ package body Ada.Calendar is\n          raise Time_Error;\n       end if;\n \n-      --  Building a time value in a local time zone is tricky since the\n-      --  local time zone offset at the point of creation may not be the\n-      --  same as the actual time zone offset designated by the input\n-      --  values. The following example is relevant to New York, USA.\n-      --\n-      --     Creation date: 2006-10-10 0.0  Offset -240 mins (in DST)\n-      --     Actual date  : 1901-01-01 0.0  Offset -300 mins (no DST)\n-\n-      --  We first start by obtaining the current local time zone offset\n-      --  using Ada.Calendar.Clock, then building an intermediate time\n-      --  value using that offset.\n-\n-      Mid_Offset := Time_Zones_Operations.UTC_Time_Offset (Clock) / 60;\n-      Mid_Result := Formatting_Operations.Time_Of\n-                      (Year, Month, Day, Seconds, H, M, Se, Ss,\n-                       Leap_Sec     => False,\n-                       Leap_Checks  => False,\n-                       Use_Day_Secs => True,\n-                       Time_Zone    => Mid_Offset);\n-\n-      --  This is the true local time zone offset of the input time values\n-\n-      Offset := Time_Zones_Operations.UTC_Time_Offset (Mid_Result) / 60;\n-\n-      --  It is possible that at the point of invocation of Time_Of, both\n-      --  the current local time zone offset and the one designated by the\n-      --  input values are in the same DST mode.\n-\n-      if Offset = Mid_Offset then\n-         return Mid_Result;\n-\n-      --  In this case we must calculate the new time with the new offset. It\n-      --  is no sufficient to just take the relative difference between the\n-      --  two offsets and adjust the intermediate result, because this does not\n-      --  work around leap second times.\n-\n-      else\n-         declare\n-            Result : constant Time :=\n-                       Formatting_Operations.Time_Of\n-                         (Year, Month, Day, Seconds, H, M, Se, Ss,\n-                         Leap_Sec     => False,\n-                         Leap_Checks  => False,\n-                         Use_Day_Secs => True,\n-                         Time_Zone    => Offset);\n-\n-         begin\n-            return Result;\n-         end;\n-      end if;\n+      --  Even though the input time zone is UTC (0), the flag Is_Ada_05 will\n+      --  ensure that Split picks up the local time zone.\n+\n+      return\n+        Formatting_Operations.Time_Of\n+          (Year         => Year,\n+           Month        => Month,\n+           Day          => Day,\n+           Day_Secs     => Seconds,\n+           Hour         => H,\n+           Minute       => M,\n+           Second       => Se,\n+           Sub_Sec      => Ss,\n+           Leap_Sec     => False,\n+           Use_Day_Secs => True,\n+           Is_Ada_05    => False,\n+           Time_Zone    => 0);\n    end Time_Of;\n \n-   ---------------------\n-   -- To_Abs_Duration --\n-   ---------------------\n-\n-   function To_Abs_Duration (T : Time) return Duration is\n-      pragma Unsuppress (Overflow_Check);\n-      function To_Duration is new Ada.Unchecked_Conversion (Time, Duration);\n-\n-   begin\n-      return To_Duration (T);\n-\n-   exception\n-      when Constraint_Error =>\n-         raise Time_Error;\n-   end To_Abs_Duration;\n-\n-   -----------------\n-   -- To_Abs_Time --\n-   -----------------\n-\n-   function To_Abs_Time (D : Duration) return Time is\n-      pragma Unsuppress (Overflow_Check);\n-      function To_Time is new Ada.Unchecked_Conversion (Duration, Time);\n-\n-   begin\n-      --  This operation assumes that D is positive\n-\n-      if D < 0.0 then\n-         raise Constraint_Error;\n-      end if;\n-\n-      return To_Time (D);\n-\n-   exception\n-      when Constraint_Error =>\n-         raise Time_Error;\n-   end To_Abs_Time;\n-\n    ----------\n    -- Year --\n    ----------\n@@ -703,9 +628,9 @@ package body Ada.Calendar is\n       return Y;\n    end Year;\n \n-   --  The following packages assume that Time is a modular 64 bit integer\n+   --  The following packages assume that Time is a signed 64 bit integer\n    --  type, the units are nanoseconds and the origin is the start of Ada\n-   --  time (1901-1-1 0.0).\n+   --  time (1901-01-01 00:00:00.0 UTC).\n \n    ---------------------------\n    -- Arithmetic_Operations --\n@@ -718,27 +643,23 @@ package body Ada.Calendar is\n       ---------\n \n       function Add (Date : Time; Days : Long_Integer) return Time is\n+         pragma Unsuppress (Overflow_Check);\n+\n+         Date_N : constant Time_Rep := Time_Rep (Date);\n+         Res_N  : Time_Rep;\n+\n       begin\n+         --  Trivial case\n+\n          if Days = 0 then\n             return Date;\n+         end if;\n \n-         elsif Days < 0 then\n-            return Subtract (Date, abs (Days));\n-\n-         else\n-            declare\n-               Result : constant Time := Date + Time (Days) * Nanos_In_Day;\n-\n-            begin\n-               --  The result excedes the upper bound of Ada time\n+         Res_N := Date_N + Time_Rep (Days) * Nanos_In_Day;\n \n-               if Result > Ada_High_And_Leaps then\n-                  raise Time_Error;\n-               end if;\n+         Check_Within_Time_Bounds (Res_N);\n \n-               return Result;\n-            end;\n-         end if;\n+         return Time (Res_N);\n \n       exception\n          when Constraint_Error =>\n@@ -756,54 +677,70 @@ package body Ada.Calendar is\n          Seconds      : out Duration;\n          Leap_Seconds : out Integer)\n       is\n-         Diff_N        : Time;\n-         Diff_S        : Time;\n-         Earlier       : Time;\n+         Res_Dur       : Time_Dur;\n+         Earlier       : Time_Rep;\n+         Earlier_Sub   : Time_Rep;\n          Elapsed_Leaps : Natural;\n-         Later         : Time;\n+         Later         : Time_Rep;\n+         Later_Sub     : Time_Rep;\n          Negate        : Boolean := False;\n-         Next_Leap     : Time;\n+         Next_Leap_N   : Time_Rep;\n          Sub_Seconds   : Duration;\n \n       begin\n-         --  Both input time values are assumed to be in GMT\n+         --  Both input time values are assumed to be in UTC\n \n          if Left >= Right then\n-            Later   := Left;\n-            Earlier := Right;\n+            Later   := Time_Rep (Left);\n+            Earlier := Time_Rep (Right);\n          else\n-            Later   := Right;\n-            Earlier := Left;\n+            Later   := Time_Rep (Right);\n+            Earlier := Time_Rep (Left);\n             Negate  := True;\n          end if;\n \n-         --  First process the leap seconds\n+         --  If the target supports leap seconds, process them\n \n-         Cumulative_Leap_Seconds (Earlier, Later, Elapsed_Leaps, Next_Leap);\n+         if Leap_Support then\n+            Cumulative_Leap_Seconds\n+              (Earlier, Later, Elapsed_Leaps, Next_Leap_N);\n \n-         if Later >= Next_Leap then\n-            Elapsed_Leaps := Elapsed_Leaps + 1;\n+            if Later >= Next_Leap_N then\n+               Elapsed_Leaps := Elapsed_Leaps + 1;\n+            end if;\n+\n+         --  The target does not support leap seconds\n+\n+         else\n+            Elapsed_Leaps := 0;\n          end if;\n \n-         Diff_N := Later - Earlier - Time (Elapsed_Leaps) * Nano;\n+         --  Sub seconds\n \n-         --  Sub second processing\n+         Earlier_Sub := Earlier mod Nano;\n+         Later_Sub   := Later mod Nano;\n \n-         Sub_Seconds := Duration (Diff_N mod Nano) / Nano_F;\n+         if Later_Sub < Earlier_Sub then\n+            Later_Sub := Later_Sub + Time_Rep (1) * Nano;\n+            Later     := Later - Time_Rep (1) * Nano;\n+         end if;\n \n-         --  Convert to seconds. Note that his action eliminates the sub\n-         --  seconds automatically.\n+         Sub_Seconds := Duration (Later_Sub - Earlier_Sub) / Nano_F;\n \n-         Diff_S := Diff_N / Nano;\n+         Res_Dur := Time_Dur (Later / Nano - Earlier / Nano) -\n+                    Time_Dur (Elapsed_Leaps);\n \n-         Days := Long_Integer (Diff_S / Secs_In_Day);\n-         Seconds := Duration (Diff_S mod Secs_In_Day) + Sub_Seconds;\n+         Days := Long_Integer (Res_Dur / Secs_In_Day);\n+         Seconds := Duration (Res_Dur mod Secs_In_Day) + Sub_Seconds;\n          Leap_Seconds := Integer (Elapsed_Leaps);\n \n          if Negate then\n-            Days         := -Days;\n-            Seconds      := -Seconds;\n-            Leap_Seconds := -Leap_Seconds;\n+            Days    := -Days;\n+            Seconds := -Seconds;\n+\n+            if Leap_Seconds /= 0 then\n+               Leap_Seconds := -Leap_Seconds;\n+            end if;\n          end if;\n       end Difference;\n \n@@ -812,37 +749,23 @@ package body Ada.Calendar is\n       --------------\n \n       function Subtract (Date : Time; Days : Long_Integer) return Time is\n-      begin\n-         if Days = 0 then\n-            return Date;\n+         pragma Unsuppress (Overflow_Check);\n \n-         elsif Days < 0 then\n-            return Add (Date, abs (Days));\n+         Date_N : constant Time_Rep := Time_Rep (Date);\n+         Res_N  : Time_Rep;\n \n-         else\n-            declare\n-               Days_T : constant Time := Time (Days) * Nanos_In_Day;\n-               Result : Time;\n-\n-            begin\n-               --  Subtracting a larger number of days from a smaller time\n-               --  value will cause wrap around since time is a modular type.\n+      begin\n+         --  Trivial case\n \n-               if Date < Days_T then\n-                  raise Time_Error;\n-               end if;\n+         if Days = 0 then\n+            return Date;\n+         end if;\n \n-               Result := Date - Days_T;\n+         Res_N := Date_N - Time_Rep (Days) * Nanos_In_Day;\n \n-               if Result < Ada_Low\n-                 or else Result > Ada_High_And_Leaps\n-               then\n-                  raise Time_Error;\n-               end if;\n+         Check_Within_Time_Bounds (Res_N);\n \n-               return Result;\n-            end;\n-         end if;\n+         return Time (Res_N);\n \n       exception\n          when Constraint_Error =>\n@@ -860,37 +783,39 @@ package body Ada.Calendar is\n       -- To_Duration --\n       -----------------\n \n-      function To_Duration (Ada_Time : Time) return Duration is\n+      function To_Duration (Date : Time) return Duration is\n          Elapsed_Leaps : Natural;\n-         Modified_Time : Time;\n-         Next_Leap     : Time;\n-         Result        : Duration;\n-         Rounded_Time  : Time;\n+         Next_Leap_N   : Time_Rep;\n+         Res_N         : Time_Rep;\n \n       begin\n-         Modified_Time := Ada_Time;\n-         Rounded_Time  := Modified_Time - (Modified_Time mod Nano);\n+         Res_N := Time_Rep (Date);\n \n-         --  Remove all leap seconds\n+         --  If the target supports leap seconds, remove any leap seconds\n+         --  elapsed upto the input date.\n \n-         Cumulative_Leap_Seconds\n-           (Time_Zero, Modified_Time, Elapsed_Leaps, Next_Leap);\n+         if Leap_Support then\n+            Cumulative_Leap_Seconds\n+              (Start_Of_Time, Res_N, Elapsed_Leaps, Next_Leap_N);\n \n-         Modified_Time := Modified_Time - Time (Elapsed_Leaps) * Nano;\n+            --  The input time value may fall on a leap second occurence\n \n-         --  The input time value may fall on a leap second occurence\n+            if Res_N >= Next_Leap_N then\n+               Elapsed_Leaps := Elapsed_Leaps + 1;\n+            end if;\n \n-         if Rounded_Time = Next_Leap then\n-            Modified_Time := Modified_Time - Time (1) * Nano;\n-         end if;\n+         --  The target does not support leap seconds\n \n-         --  Perform a shift in origins\n+         else\n+            Elapsed_Leaps := 0;\n+         end if;\n \n-         Result := Modified_Time - Unix_Min;\n+         Res_N := Res_N - Time_Rep (Elapsed_Leaps) * Nano;\n \n-         --  Remove the buffer period used in time zone processing\n+         --  Perform a shift in origins, note that enforcing type Time on\n+         --  both operands will invoke Ada.Calendar.\"-\".\n \n-         return Result - Buffer_D;\n+         return Time (Res_N) - Time (Unix_Min);\n       end To_Duration;\n    end Delays_Operations;\n \n@@ -908,34 +833,58 @@ package body Ada.Calendar is\n          Y  : Year_Number;\n          Mo : Month_Number;\n          D  : Day_Number;\n-         Dd : Day_Duration;\n+         Ds : Day_Duration;\n          H  : Integer;\n          Mi : Integer;\n          Se : Integer;\n          Su : Duration;\n          Le : Boolean;\n \n-         Day_Count     : Long_Integer;\n-         Midday_Date_S : Time;\n+         Day_Count : Long_Integer;\n+         Res_Dur   : Time_Dur;\n+         Res_N     : Time_Rep;\n \n       begin\n          Formatting_Operations.Split\n-           (Date, Y, Mo, D, Dd, H, Mi, Se, Su, Le, 0);\n-\n-         --  Build a time value in the middle of the same day, remove the\n-         --  lower buffer and convert the time value to seconds.\n-\n-         Midday_Date_S := (Formatting_Operations.Time_Of\n-                             (Y, Mo, D, 0.0, 12, 0, 0, 0.0,\n-                              Leap_Sec     => False,\n-                              Leap_Checks  => False,\n-                              Use_Day_Secs => False,\n-                              Time_Zone    => 0) - Buffer_N) / Nano;\n+           (Date      => Date,\n+            Year      => Y,\n+            Month     => Mo,\n+            Day       => D,\n+            Day_Secs  => Ds,\n+            Hour      => H,\n+            Minute    => Mi,\n+            Second    => Se,\n+            Sub_Sec   => Su,\n+            Leap_Sec  => Le,\n+            Is_Ada_05 => True,\n+            Time_Zone => 0);\n+\n+         --  Build a time value in the middle of the same day\n+\n+         Res_N :=\n+           Time_Rep\n+             (Formatting_Operations.Time_Of\n+               (Year         => Y,\n+                Month        => Mo,\n+                Day          => D,\n+                Day_Secs     => 0.0,\n+                Hour         => 12,\n+                Minute       => 0,\n+                Second       => 0,\n+                Sub_Sec      => 0.0,\n+                Leap_Sec     => False,\n+                Use_Day_Secs => False,\n+                Is_Ada_05    => True,\n+                Time_Zone    => 0));\n+\n+         --  Determine the elapsed seconds since the start of Ada time\n+\n+         Res_Dur := Time_Dur (Res_N / Nano - Ada_Low / Nano);\n \n          --  Count the number of days since the start of Ada time. 1901-1-1\n          --  GMT was a Tuesday.\n \n-         Day_Count := Long_Integer (Midday_Date_S / Secs_In_Day) + 1;\n+         Day_Count := Long_Integer (Res_Dur / Secs_In_Day) + 1;\n \n          return Integer (Day_Count mod 7);\n       end Day_Of_Week;\n@@ -945,180 +894,139 @@ package body Ada.Calendar is\n       -----------\n \n       procedure Split\n-        (Date         : Time;\n-         Year         : out Year_Number;\n-         Month        : out Month_Number;\n-         Day          : out Day_Number;\n-         Day_Secs     : out Day_Duration;\n-         Hour         : out Integer;\n-         Minute       : out Integer;\n-         Second       : out Integer;\n-         Sub_Sec      : out Duration;\n-         Leap_Sec     : out Boolean;\n-         Time_Zone    : Long_Integer)\n+        (Date      : Time;\n+         Year      : out Year_Number;\n+         Month     : out Month_Number;\n+         Day       : out Day_Number;\n+         Day_Secs  : out Day_Duration;\n+         Hour      : out Integer;\n+         Minute    : out Integer;\n+         Second    : out Integer;\n+         Sub_Sec   : out Duration;\n+         Leap_Sec  : out Boolean;\n+         Is_Ada_05 : Boolean;\n+         Time_Zone : Long_Integer)\n       is\n          --  The following constants represent the number of nanoseconds\n          --  elapsed since the start of Ada time to and including the non\n          --  leap centenial years.\n \n-         Year_2101 : constant Time := (49 * 366 + 151 * 365) * Nanos_In_Day;\n-         Year_2201 : constant Time := (73 * 366 + 227 * 365) * Nanos_In_Day;\n-         Year_2301 : constant Time := (97 * 366 + 303 * 365) * Nanos_In_Day;\n-\n-         Abs_Time_Zone   : Time;\n-         Day_Seconds     : Natural;\n-         Elapsed_Leaps   : Natural;\n-         Four_Year_Segs  : Natural;\n-         Hour_Seconds    : Natural;\n-         Is_Leap_Year    : Boolean;\n-         Modified_Date_N : Time;\n-         Modified_Date_S : Time;\n-         Next_Leap_N     : Time;\n-         Rem_Years       : Natural;\n-         Rounded_Date_N  : Time;\n-         Year_Day        : Natural;\n+         Year_2101 : constant Time_Rep := Ada_Low +\n+                       Time_Rep (49 * 366 + 151 * 365) * Nanos_In_Day;\n+         Year_2201 : constant Time_Rep := Ada_Low +\n+                       Time_Rep (73 * 366 + 227 * 365) * Nanos_In_Day;\n+         Year_2301 : constant Time_Rep := Ada_Low +\n+                       Time_Rep (97 * 366 + 303 * 365) * Nanos_In_Day;\n+\n+         Date_Dur       : Time_Dur;\n+         Date_N         : Time_Rep;\n+         Day_Seconds    : Natural;\n+         Elapsed_Leaps  : Natural;\n+         Four_Year_Segs : Natural;\n+         Hour_Seconds   : Natural;\n+         Is_Leap_Year   : Boolean;\n+         Next_Leap_N    : Time_Rep;\n+         Rem_Years      : Natural;\n+         Sub_Sec_N      : Time_Rep;\n+         Year_Day       : Natural;\n \n       begin\n-         Modified_Date_N := Date;\n+         Date_N := Time_Rep (Date);\n \n-         if Modified_Date_N < Hard_Ada_Low\n-           or else Modified_Date_N > Hard_Ada_High_And_Leaps\n-         then\n-            raise Time_Error;\n-         end if;\n+         --  Step 1: Leap seconds processing in UTC\n \n-         --  Step 1: Leap seconds processing in GMT\n-\n-         --  Day_Duration:    86_398  86_399  X (86_400) 0 (1)  1 (2)\n-         --  Time        :  --+-------+-------+----------+------+-->\n-         --  Seconds     :    58      59      60 (Leap)  1      2\n-\n-         --   o Modified_Date_N falls between 86_399 and X (86_400)\n-         --       Elapsed_Leaps  = X - 1 leaps\n-         --       Rounded_Date_N = 86_399\n-         --       Next_Leap_N    = X (86_400)\n-         --       Leap_Sec       = False\n-\n-         --   o Modified_Date_N falls exactly on X (86_400)\n-         --       Elapsed_Leaps  = X - 1 leaps\n-         --       Rounded_Date_N = X (86_400)\n-         --       Next_Leap_N    = X (86_400)\n-         --       Leap_Sec       = True\n-         --     An invisible leap second will be added.\n-\n-         --   o Modified_Date_N falls between X (86_400) and 0 (1)\n-         --       Elapsed_Leaps  = X - 1 leaps\n-         --       Rounded_Date_N = X (86_400)\n-         --       Next_Leap_N    = X (86_400)\n-         --       Leap_Sec       = True\n-         --     An invisible leap second will be added.\n-\n-         --   o Modified_Date_N falls on 0 (1)\n-         --       Elapsed_Leaps  = X\n-         --       Rounded_Date_N = 0 (1)\n-         --       Next_Leap_N    = X + 1\n-         --       Leap_Sec       = False\n-         --     The invisible leap second has already been accounted for in\n-         --     Elapsed_Leaps.\n+         if Leap_Support then\n+            Cumulative_Leap_Seconds\n+              (Start_Of_Time, Date_N, Elapsed_Leaps, Next_Leap_N);\n \n-         Cumulative_Leap_Seconds\n-           (Time_Zero, Modified_Date_N, Elapsed_Leaps, Next_Leap_N);\n+            Leap_Sec := Date_N >= Next_Leap_N;\n \n-         Rounded_Date_N  := Modified_Date_N - (Modified_Date_N mod Nano);\n-         Leap_Sec        := Rounded_Date_N = Next_Leap_N;\n-         Modified_Date_N := Modified_Date_N - Time (Elapsed_Leaps) * Nano;\n+            if Leap_Sec then\n+               Elapsed_Leaps := Elapsed_Leaps + 1;\n+            end if;\n+\n+         --  The target does not support leap seconds\n \n-         if Leap_Sec then\n-            Modified_Date_N := Modified_Date_N - Time (1) * Nano;\n+         else\n+            Elapsed_Leaps := 0;\n+            Leap_Sec      := False;\n          end if;\n \n+         Date_N := Date_N - Time_Rep (Elapsed_Leaps) * Nano;\n+\n          --  Step 2: Time zone processing. This action converts the input date\n          --  from GMT to the requested time zone.\n \n-         if Time_Zone /= 0 then\n-            Abs_Time_Zone := Time (abs (Time_Zone)) * 60 * Nano;\n-\n-            if Time_Zone < 0 then\n-               --  The following test is obsolete since the date already\n-               --  contains the dedicated buffer for time zones, thus no\n-               --  error will be raised. However it is a good idea to keep\n-               --  it should the representation of time change.\n-\n-               Modified_Date_N := Modified_Date_N - Abs_Time_Zone;\n-            else\n-               Modified_Date_N := Modified_Date_N + Abs_Time_Zone;\n+         if Is_Ada_05 then\n+            if Time_Zone /= 0 then\n+               Date_N := Date_N + Time_Rep (Time_Zone) * 60 * Nano;\n             end if;\n-         end if;\n \n-         --  After the elapsed leap seconds have been removed and the date\n-         --  has been normalized, it should fall withing the soft bounds of\n-         --  Ada time.\n+         --  Ada 83 and 95\n \n-         if Modified_Date_N < Ada_Low\n-           or else Modified_Date_N > Ada_High\n-         then\n-            raise Time_Error;\n+         else\n+            declare\n+               Off : constant Long_Integer :=\n+                       Time_Zones_Operations.UTC_Time_Offset (Time (Date_N));\n+            begin\n+               Date_N := Date_N + Time_Rep (Off) * Nano;\n+            end;\n          end if;\n \n-         --  Before any additional arithmetic is performed we must remove the\n-         --  lower buffer period since it will be accounted as few additional\n-         --  days.\n-\n-         Modified_Date_N := Modified_Date_N - Buffer_N;\n-\n          --  Step 3: Non-leap centenial year adjustment in local time zone\n \n          --  In order for all divisions to work properly and to avoid more\n          --  complicated arithmetic, we add fake Febriary 29s to dates which\n          --  occur after a non-leap centenial year.\n \n-         if Modified_Date_N >= Year_2301 then\n-            Modified_Date_N := Modified_Date_N + Time (3) * Nanos_In_Day;\n+         if Date_N >= Year_2301 then\n+            Date_N := Date_N + Time_Rep (3) * Nanos_In_Day;\n \n-         elsif Modified_Date_N >= Year_2201 then\n-            Modified_Date_N := Modified_Date_N + Time (2) * Nanos_In_Day;\n+         elsif Date_N >= Year_2201 then\n+            Date_N := Date_N + Time_Rep (2) * Nanos_In_Day;\n \n-         elsif Modified_Date_N >= Year_2101 then\n-            Modified_Date_N := Modified_Date_N + Time (1) * Nanos_In_Day;\n+         elsif Date_N >= Year_2101 then\n+            Date_N := Date_N + Time_Rep (1) * Nanos_In_Day;\n          end if;\n \n          --  Step 4: Sub second processing in local time zone\n \n-         Sub_Sec := Duration (Modified_Date_N mod Nano) / Nano_F;\n+         Sub_Sec_N := Date_N mod Nano;\n+         Sub_Sec   := Duration (Sub_Sec_N) / Nano_F;\n+         Date_N    := Date_N - Sub_Sec_N;\n \n-         --  Convert the date into seconds, the sub seconds are automatically\n-         --  dropped.\n+         --  Convert Date_N into a time duration value, changing the units\n+         --  to seconds.\n \n-         Modified_Date_S := Modified_Date_N / Nano;\n+         Date_Dur := Time_Dur (Date_N / Nano - Ada_Low / Nano);\n \n          --  Step 5: Year processing in local time zone. Determine the number\n          --  of four year segments since the start of Ada time and the input\n          --  date.\n \n-         Four_Year_Segs := Natural (Modified_Date_S / Secs_In_Four_Years);\n+         Four_Year_Segs := Natural (Date_Dur / Secs_In_Four_Years);\n \n          if Four_Year_Segs > 0 then\n-            Modified_Date_S := Modified_Date_S - Time (Four_Year_Segs) *\n-                                                 Secs_In_Four_Years;\n+            Date_Dur := Date_Dur - Time_Dur (Four_Year_Segs) *\n+                                   Secs_In_Four_Years;\n          end if;\n \n          --  Calculate the remaining non-leap years\n \n-         Rem_Years := Natural (Modified_Date_S / Secs_In_Non_Leap_Year);\n+         Rem_Years := Natural (Date_Dur / Secs_In_Non_Leap_Year);\n \n          if Rem_Years > 3 then\n             Rem_Years := 3;\n          end if;\n \n-         Modified_Date_S := Modified_Date_S - Time (Rem_Years) *\n-                                              Secs_In_Non_Leap_Year;\n+         Date_Dur := Date_Dur - Time_Dur (Rem_Years) * Secs_In_Non_Leap_Year;\n \n          Year := Ada_Min_Year + Natural (4 * Four_Year_Segs + Rem_Years);\n          Is_Leap_Year := Is_Leap (Year);\n \n          --  Step 6: Month and day processing in local time zone\n \n-         Year_Day := Natural (Modified_Date_S / Secs_In_Day) + 1;\n+         Year_Day := Natural (Date_Dur / Secs_In_Day) + 1;\n \n          Month := 1;\n \n@@ -1131,8 +1039,7 @@ package body Ada.Calendar is\n             --  Processing for a new month or a leap February\n \n             if Year_Day > 28\n-              and then (not Is_Leap_Year\n-                          or else Year_Day > 29)\n+              and then (not Is_Leap_Year or else Year_Day > 29)\n             then\n                Month    := 3;\n                Year_Day := Year_Day - 28;\n@@ -1154,7 +1061,7 @@ package body Ada.Calendar is\n          --  time zone.\n \n          Day          := Day_Number (Year_Day);\n-         Day_Seconds  := Integer (Modified_Date_S mod Secs_In_Day);\n+         Day_Seconds  := Integer (Date_Dur mod Secs_In_Day);\n          Day_Secs     := Duration (Day_Seconds) + Sub_Sec;\n          Hour         := Day_Seconds / 3_600;\n          Hour_Seconds := Day_Seconds mod 3_600;\n@@ -1176,16 +1083,15 @@ package body Ada.Calendar is\n          Second       : Integer;\n          Sub_Sec      : Duration;\n          Leap_Sec     : Boolean;\n-         Leap_Checks  : Boolean;\n          Use_Day_Secs : Boolean;\n+         Is_Ada_05    : Boolean;\n          Time_Zone    : Long_Integer) return Time\n       is\n-         Abs_Time_Zone    : Time;\n-         Count            : Integer;\n-         Elapsed_Leaps    : Natural;\n-         Next_Leap_N      : Time;\n-         Result_N         : Time;\n-         Rounded_Result_N : Time;\n+         Count         : Integer;\n+         Elapsed_Leaps : Natural;\n+         Next_Leap_N   : Time_Rep;\n+         Res_N         : Time_Rep;\n+         Rounded_Res_N : Time_Rep;\n \n       begin\n          --  Step 1: Check whether the day, month and year form a valid date\n@@ -1196,37 +1102,35 @@ package body Ada.Calendar is\n             raise Time_Error;\n          end if;\n \n-         --  Start accumulating nanoseconds from the low bound of Ada time.\n-         --  Note: This starting point includes the lower buffer dedicated\n-         --  to time zones.\n+         --  Start accumulating nanoseconds from the low bound of Ada time\n \n-         Result_N := Ada_Low;\n+         Res_N := Ada_Low;\n \n          --  Step 2: Year processing and centenial year adjustment. Determine\n          --  the number of four year segments since the start of Ada time and\n          --  the input date.\n \n-         Count    := (Year - Year_Number'First) / 4;\n-         Result_N := Result_N + Time (Count) * Secs_In_Four_Years * Nano;\n+         Count := (Year - Year_Number'First) / 4;\n+         Res_N := Res_N + Time_Rep (Count) * Secs_In_Four_Years * Nano;\n \n          --  Note that non-leap centenial years are automatically considered\n          --  leap in the operation above. An adjustment of several days is\n          --  required to compensate for this.\n \n          if Year > 2300 then\n-            Result_N := Result_N - Time (3) * Nanos_In_Day;\n+            Res_N := Res_N - Time_Rep (3) * Nanos_In_Day;\n \n          elsif Year > 2200 then\n-            Result_N := Result_N - Time (2) * Nanos_In_Day;\n+            Res_N := Res_N - Time_Rep (2) * Nanos_In_Day;\n \n          elsif Year > 2100 then\n-            Result_N := Result_N - Time (1) * Nanos_In_Day;\n+            Res_N := Res_N - Time_Rep (1) * Nanos_In_Day;\n          end if;\n \n          --  Add the remaining non-leap years\n \n-         Count    := (Year - Year_Number'First) mod 4;\n-         Result_N := Result_N + Time (Count) * Secs_In_Non_Leap_Year * Nano;\n+         Count := (Year - Year_Number'First) mod 4;\n+         Res_N := Res_N + Time_Rep (Count) * Secs_In_Non_Leap_Year * Nano;\n \n          --  Step 3: Day of month processing. Determine the number of days\n          --  since the start of the current year. Do not add the current\n@@ -1242,92 +1146,87 @@ package body Ada.Calendar is\n             Count := Count + 1;\n          end if;\n \n-         Result_N := Result_N + Time (Count) * Nanos_In_Day;\n+         Res_N := Res_N + Time_Rep (Count) * Nanos_In_Day;\n \n          --  Step 4: Hour, minute, second and sub second processing\n \n          if Use_Day_Secs then\n-            Result_N := Result_N + To_Abs_Time (Day_Secs);\n+            Res_N := Res_N + Duration_To_Time_Rep (Day_Secs);\n \n          else\n-            Result_N := Result_N +\n-              Time (Hour * 3_600 + Minute * 60 + Second) * Nano;\n+            Res_N := Res_N +\n+              Time_Rep (Hour * 3_600 + Minute * 60 + Second) * Nano;\n \n             if Sub_Sec = 1.0 then\n-               Result_N := Result_N + Time (1) * Nano;\n+               Res_N := Res_N + Time_Rep (1) * Nano;\n             else\n-               Result_N := Result_N + To_Abs_Time (Sub_Sec);\n+               Res_N := Res_N + Duration_To_Time_Rep (Sub_Sec);\n             end if;\n          end if;\n \n+         --  At this point, the generated time value should be withing the\n+         --  bounds of Ada time.\n+\n+         Check_Within_Time_Bounds (Res_N);\n+\n          --  Step 4: Time zone processing. At this point we have built an\n          --  arbitrary time value which is not related to any time zone.\n          --  For simplicity, the time value is normalized to GMT, producing\n          --  a uniform representation which can be treated by arithmetic\n          --  operations for instance without any additional corrections.\n \n-         if Result_N < Ada_Low\n-           or else Result_N > Ada_High\n-         then\n-            raise Time_Error;\n-         end if;\n-\n-         if Time_Zone /= 0 then\n-            Abs_Time_Zone := Time (abs (Time_Zone)) * 60 * Nano;\n-\n-            if Time_Zone < 0 then\n-               Result_N := Result_N + Abs_Time_Zone;\n-            else\n-               --  The following test is obsolete since the result already\n-               --  contains the dedicated buffer for time zones, thus no\n-               --  error will be raised. However it is a good idea to keep\n-               --  this comparison should the representation of time change.\n+         if Is_Ada_05 then\n+            if Time_Zone /= 0 then\n+               Res_N := Res_N - Time_Rep (Time_Zone) * 60 * Nano;\n+            end if;\n \n-               if Result_N < Abs_Time_Zone then\n-                  raise Time_Error;\n-               end if;\n+         --  Ada 83 and 95\n \n-               Result_N := Result_N - Abs_Time_Zone;\n-            end if;\n+         else\n+            declare\n+               Current_Off   : constant Long_Integer :=\n+                                 Time_Zones_Operations.UTC_Time_Offset\n+                                   (Time (Res_N));\n+               Current_Res_N : constant Time_Rep :=\n+                                 Res_N - Time_Rep (Current_Off) * Nano;\n+               Off           : constant Long_Integer :=\n+                                 Time_Zones_Operations.UTC_Time_Offset\n+                                   (Time (Current_Res_N));\n+            begin\n+               Res_N := Res_N - Time_Rep (Off) * Nano;\n+            end;\n          end if;\n \n          --  Step 5: Leap seconds processing in GMT\n \n-         Cumulative_Leap_Seconds\n-           (Time_Zero, Result_N, Elapsed_Leaps, Next_Leap_N);\n-\n-         Result_N := Result_N + Time (Elapsed_Leaps) * Nano;\n+         if Leap_Support then\n+            Cumulative_Leap_Seconds\n+              (Start_Of_Time, Res_N, Elapsed_Leaps, Next_Leap_N);\n \n-         --  An Ada 2005 caller requesting an explicit leap second or an Ada\n-         --  95 caller accounting for an invisible leap second.\n+            Res_N := Res_N + Time_Rep (Elapsed_Leaps) * Nano;\n \n-         Rounded_Result_N := Result_N - (Result_N mod Nano);\n+            --  An Ada 2005 caller requesting an explicit leap second or an\n+            --  Ada 95 caller accounting for an invisible leap second.\n \n-         if Leap_Sec\n-           or else Rounded_Result_N = Next_Leap_N\n-         then\n-            Result_N := Result_N + Time (1) * Nano;\n-            Rounded_Result_N := Rounded_Result_N + Time (1) * Nano;\n-         end if;\n+            if Leap_Sec\n+              or else Res_N >= Next_Leap_N\n+            then\n+               Res_N := Res_N + Time_Rep (1) * Nano;\n+            end if;\n \n-         --  Leap second validity check\n+            --  Leap second validity check\n \n-         if Leap_Checks\n-           and then Leap_Sec\n-           and then Rounded_Result_N /= Next_Leap_N\n-         then\n-            raise Time_Error;\n-         end if;\n-\n-         --  Final bounds check\n+            Rounded_Res_N := Res_N - (Res_N mod Nano);\n \n-         if Result_N < Hard_Ada_Low\n-           or else Result_N > Hard_Ada_High_And_Leaps\n-         then\n-            raise Time_Error;\n+            if Is_Ada_05\n+              and then Leap_Sec\n+              and then Rounded_Res_N /= Next_Leap_N\n+            then\n+               raise Time_Error;\n+            end if;\n          end if;\n \n-         return Result_N;\n+         return Time (Res_N);\n       end Time_Of;\n    end Formatting_Operations;\n \n@@ -1337,35 +1236,33 @@ package body Ada.Calendar is\n \n    package body Time_Zones_Operations is\n \n-      --  The Unix time bounds in seconds: 1970/1/1 .. 2037/1/1\n+      --  The Unix time bounds in nanoseconds: 1970/1/1 .. 2037/1/1\n \n-      Unix_Min : constant Time :=\n-                   Time (17 * 366 + 52 * 365 + 2) * Secs_In_Day;\n-      --  1970/1/1\n+      Unix_Min : constant Time_Rep := Ada_Low +\n+                   Time_Rep (17 * 366 +  52 * 365) * Nanos_In_Day;\n \n-      Unix_Max : constant Time :=\n-                   Time (34 * 366 + 102 * 365 + 2) * Secs_In_Day +\n-                   Time (Leap_Seconds_Count);\n-      --  2037/1/1\n+      Unix_Max : constant Time_Rep := Ada_Low +\n+                   Time_Rep (34 * 366 + 102 * 365) * Nanos_In_Day +\n+                   Time_Rep (Leap_Seconds_Count) * Nano;\n \n       --  The following constants denote February 28 during non-leap\n       --  centenial years, the units are nanoseconds.\n \n-      T_2100_2_28 : constant Time :=\n-                      (Time (49 * 366 + 150 * 365 + 59 + 2) * Secs_In_Day +\n-                         Time (Leap_Seconds_Count)) * Nano;\n+      T_2100_2_28 : constant Time_Rep := Ada_Low +\n+                      (Time_Rep (49 * 366 + 150 * 365 + 59) * Secs_In_Day +\n+                       Time_Rep (Leap_Seconds_Count)) * Nano;\n \n-      T_2200_2_28 : constant Time :=\n-                      (Time (73 * 366 + 226 * 365 + 59 + 2) * Secs_In_Day +\n-                         Time (Leap_Seconds_Count)) * Nano;\n+      T_2200_2_28 : constant Time_Rep := Ada_Low +\n+                      (Time_Rep (73 * 366 + 226 * 365 + 59) * Secs_In_Day +\n+                       Time_Rep (Leap_Seconds_Count)) * Nano;\n \n-      T_2300_2_28 : constant Time :=\n-                      (Time (97 * 366 + 302 * 365 + 59 + 2) * Secs_In_Day +\n-                         Time (Leap_Seconds_Count)) * Nano;\n+      T_2300_2_28 : constant Time_Rep := Ada_Low +\n+                      (Time_Rep (97 * 366 + 302 * 365 + 59) * Secs_In_Day +\n+                       Time_Rep (Leap_Seconds_Count)) * Nano;\n \n-      --  56 years (14 leap years + 42 non leap years) in seconds:\n+      --  56 years (14 leap years + 42 non leap years) in nanoseconds:\n \n-      Secs_In_56_Years : constant := (14 * 366 + 42 * 365) * Secs_In_Day;\n+      Nanos_In_56_Years : constant := (14 * 366 + 42 * 365) * Nanos_In_Day;\n \n       --  Base C types. There is no point dragging in Interfaces.C just for\n       --  these four types.\n@@ -1378,17 +1275,17 @@ package body Ada.Calendar is\n       --  The Ada equivalent of struct tm and type time_t\n \n       type tm is record\n-         tm_sec    : int;           -- seconds after the minute (0 .. 60)\n-         tm_min    : int;           -- minutes after the hour (0 .. 59)\n-         tm_hour   : int;           -- hours since midnight (0 .. 24)\n-         tm_mday   : int;           -- day of the month (1 .. 31)\n-         tm_mon    : int;           -- months since January (0 .. 11)\n-         tm_year   : int;           -- years since 1900\n-         tm_wday   : int;           -- days since Sunday (0 .. 6)\n-         tm_yday   : int;           -- days since January 1 (0 .. 365)\n-         tm_isdst  : int;           -- Daylight Savings Time flag (-1 .. 1)\n-         tm_gmtoff : long;          -- offset from UTC in seconds\n-         tm_zone   : char_Pointer;  -- timezone abbreviation\n+         tm_sec    : int;           --  seconds after the minute (0 .. 60)\n+         tm_min    : int;           --  minutes after the hour (0 .. 59)\n+         tm_hour   : int;           --  hours since midnight (0 .. 24)\n+         tm_mday   : int;           --  day of the month (1 .. 31)\n+         tm_mon    : int;           --  months since January (0 .. 11)\n+         tm_year   : int;           --  years since 1900\n+         tm_wday   : int;           --  days since Sunday (0 .. 6)\n+         tm_yday   : int;           --  days since January 1 (0 .. 365)\n+         tm_isdst  : int;           --  Daylight Savings Time flag (-1 .. 1)\n+         tm_gmtoff : long;          --  offset from UTC in seconds\n+         tm_zone   : char_Pointer;  --  timezone abbreviation\n       end record;\n \n       type tm_Pointer is access all tm;\n@@ -1411,24 +1308,22 @@ package body Ada.Calendar is\n       ---------------------\n \n       function UTC_Time_Offset (Date : Time) return Long_Integer is\n-\n-         Adj_Cent   : Integer := 0;\n-         Adj_Date_N : Time;\n-         Adj_Date_S : Time;\n-         Offset     : aliased long;\n-         Secs_T     : aliased time_t;\n-         Secs_TM    : aliased tm;\n+         Adj_Cent : Integer := 0;\n+         Date_N   : Time_Rep;\n+         Offset   : aliased long;\n+         Secs_T   : aliased time_t;\n+         Secs_TM  : aliased tm;\n \n       begin\n-         Adj_Date_N := Date;\n+         Date_N := Time_Rep (Date);\n \n          --  Dates which are 56 years appart fall on the same day, day light\n          --  saving and so on. Non-leap centenial years violate this rule by\n          --  one day and as a consequence, special adjustment is needed.\n \n-         if Adj_Date_N > T_2100_2_28 then\n-            if Adj_Date_N > T_2200_2_28 then\n-               if Adj_Date_N > T_2300_2_28 then\n+         if Date_N > T_2100_2_28 then\n+            if Date_N > T_2200_2_28 then\n+               if Date_N > T_2300_2_28 then\n                   Adj_Cent := 3;\n                else\n                   Adj_Cent := 2;\n@@ -1440,25 +1335,26 @@ package body Ada.Calendar is\n          end if;\n \n          if Adj_Cent > 0 then\n-            Adj_Date_N := Adj_Date_N - Time (Adj_Cent) * Nanos_In_Day;\n+            Date_N := Date_N - Time_Rep (Adj_Cent) * Nanos_In_Day;\n          end if;\n \n-         --  Convert to seconds and shift date within bounds of Unix time\n+         --  Shift the date within bounds of Unix time\n \n-         Adj_Date_S := Adj_Date_N / Nano;\n-         while Adj_Date_S < Unix_Min loop\n-            Adj_Date_S := Adj_Date_S + Secs_In_56_Years;\n+         while Date_N < Unix_Min loop\n+            Date_N := Date_N + Nanos_In_56_Years;\n          end loop;\n \n-         while Adj_Date_S >= Unix_Max loop\n-            Adj_Date_S := Adj_Date_S - Secs_In_56_Years;\n+         while Date_N >= Unix_Max loop\n+            Date_N := Date_N - Nanos_In_56_Years;\n          end loop;\n \n          --  Perform a shift in origins from Ada to Unix\n \n-         Adj_Date_S := Adj_Date_S - Unix_Min;\n+         Date_N := Date_N - Unix_Min;\n+\n+         --  Convert the date into seconds\n \n-         Secs_T := time_t (Adj_Date_S);\n+         Secs_T := time_t (Date_N / Nano);\n \n          localtime_tzoff\n            (Secs_T'Unchecked_Access,\n@@ -1476,67 +1372,69 @@ begin\n \n    --  Population of the leap seconds table\n \n-   declare\n-      type Leap_Second_Date is record\n-         Year  : Year_Number;\n-         Month : Month_Number;\n-         Day   : Day_Number;\n-      end record;\n-\n-      Leap_Second_Dates :\n-        constant array (1 .. Leap_Seconds_Count) of Leap_Second_Date :=\n-          ((1972,  6, 30), (1972, 12, 31), (1973, 12, 31), (1974, 12, 31),\n-           (1975, 12, 31), (1976, 12, 31), (1977, 12, 31), (1978, 12, 31),\n-           (1979, 12, 31), (1981,  6, 30), (1982,  6, 30), (1983,  6, 30),\n-           (1985,  6, 30), (1987, 12, 31), (1989, 12, 31), (1990, 12, 31),\n-           (1992,  6, 30), (1993,  6, 30), (1994,  6, 30), (1995, 12, 31),\n-           (1997,  6, 30), (1998, 12, 31), (2005, 12, 31));\n-\n-      Days_In_Four_Years : constant := 365 * 3 + 366;\n-\n-      Days  : Natural;\n-      Leap  : Leap_Second_Date;\n-      Years : Natural;\n+   if Leap_Support then\n+      declare\n+         type Leap_Second_Date is record\n+            Year  : Year_Number;\n+            Month : Month_Number;\n+            Day   : Day_Number;\n+         end record;\n+\n+         Leap_Second_Dates :\n+           constant array (1 .. Leap_Seconds_Count) of Leap_Second_Date :=\n+             ((1972,  6, 30), (1972, 12, 31), (1973, 12, 31), (1974, 12, 31),\n+              (1975, 12, 31), (1976, 12, 31), (1977, 12, 31), (1978, 12, 31),\n+              (1979, 12, 31), (1981,  6, 30), (1982,  6, 30), (1983,  6, 30),\n+              (1985,  6, 30), (1987, 12, 31), (1989, 12, 31), (1990, 12, 31),\n+              (1992,  6, 30), (1993,  6, 30), (1994,  6, 30), (1995, 12, 31),\n+              (1997,  6, 30), (1998, 12, 31), (2005, 12, 31));\n+\n+         Days_In_Four_Years : constant := 365 * 3 + 366;\n+\n+         Days  : Natural;\n+         Leap  : Leap_Second_Date;\n+         Years : Natural;\n \n-   begin\n-      for Index in 1 .. Leap_Seconds_Count loop\n-         Leap := Leap_Second_Dates (Index);\n+      begin\n+         for Index in 1 .. Leap_Seconds_Count loop\n+            Leap := Leap_Second_Dates (Index);\n \n-         --  Calculate the number of days from the start of Ada time until\n-         --  the current leap second occurence. Non-leap centenial years\n-         --  are not accounted for in these calculations since there are\n-         --  no leap seconds after 2100 yet.\n+            --  Calculate the number of days from the start of Ada time until\n+            --  the current leap second occurence. Non-leap centenial years\n+            --  are not accounted for in these calculations since there are\n+            --  no leap seconds after 2100 yet.\n \n-         Years := Leap.Year - Ada_Min_Year;\n-         Days  := (Years / 4) * Days_In_Four_Years;\n-         Years := Years mod 4;\n+            Years := Leap.Year - Ada_Min_Year;\n+            Days  := (Years / 4) * Days_In_Four_Years;\n+            Years := Years mod 4;\n \n-         if Years = 1 then\n-            Days := Days + 365;\n+            if Years = 1 then\n+               Days := Days + 365;\n \n-         elsif Years = 2 then\n-            Days := Days + 365 * 2;\n+            elsif Years = 2 then\n+               Days := Days + 365 * 2;\n \n-         elsif Years = 3 then\n-            Days := Days + 365 * 3;\n-         end if;\n+            elsif Years = 3 then\n+               Days := Days + 365 * 3;\n+            end if;\n \n-         Days := Days + Cumulative_Days_Before_Month (Leap.Month);\n+            Days := Days + Cumulative_Days_Before_Month (Leap.Month);\n \n-         if Is_Leap (Leap.Year)\n-           and then Leap.Month > 2\n-         then\n-            Days := Days + 1;\n-         end if;\n+            if Is_Leap (Leap.Year)\n+              and then Leap.Month > 2\n+            then\n+               Days := Days + 1;\n+            end if;\n \n-         Days := Days + Leap.Day;\n+            Days := Days + Leap.Day;\n \n-         --  Index - 1 previous leap seconds are added to Time (Index) as\n-         --  well as the lower buffer for time zones.\n+            --  Index - 1 previous leap seconds are added to Time (Index) as\n+            --  well as the lower buffer for time zones.\n \n-         Leap_Second_Times (Index) := Ada_Low +\n-           (Time (Days) * Secs_In_Day + Time (Index - 1)) * Nano;\n-      end loop;\n-   end;\n+            Leap_Second_Times (Index) := Ada_Low +\n+              (Time_Rep (Days) * Secs_In_Day + Time_Rep (Index - 1)) * Nano;\n+         end loop;\n+      end;\n+   end if;\n \n end Ada.Calendar;"}, {"sha": "711cd22af7e2171d771d9b25303e7941e6b869e3", "filename": "gcc/ada/a-calend.ads", "status": "modified", "additions": 50, "deletions": 71, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/984d7dd399e6f4c29e73dee445ef149e70245459/gcc%2Fada%2Fa-calend.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/984d7dd399e6f4c29e73dee445ef149e70245459/gcc%2Fada%2Fa-calend.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend.ads?ref=984d7dd399e6f4c29e73dee445ef149e70245459", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -53,7 +53,7 @@ package Ada.Calendar is\n \n    function Clock return Time;\n    --  The returned time value is the number of nanoseconds since the start\n-   --  of Ada time (1901-1-1 0.0 GMT).\n+   --  of Ada time (1901-01-01 00:00:00.0 UTC).\n \n    function Year    (Date : Time) return Year_Number;\n    function Month   (Date : Time) return Month_Number;\n@@ -68,8 +68,8 @@ package Ada.Calendar is\n       Seconds : out Day_Duration);\n    --  Break down a time value into its date components set in the current\n    --  time zone. If Split is called on a time value created using Ada 2005\n-   --  Time_Of in some arbitrary time zone, the input value always will be\n-   --  interpreted as some point in time relative to the local time zone.\n+   --  Time_Of in some arbitrary time zone, the input value will always be\n+   --  interpreted as relative to the local time zone.\n \n    function Time_Of\n      (Year    : Year_Number;\n@@ -96,8 +96,8 @@ package Ada.Calendar is\n    function \"-\" (Left : Time;     Right : Duration) return Time;\n    function \"-\" (Left : Time;     Right : Time)     return Duration;\n    --  The first three functions will raise Time_Error if the resulting time\n-   --  value is less than the start of Ada time in GMT or greater than the\n-   --  end of Ada time in GMT. The last function will raise Time_Error if the\n+   --  value is less than the start of Ada time in UTC or greater than the\n+   --  end of Ada time in UTC. The last function will raise Time_Error if the\n    --  resulting difference cannot fit into a duration value.\n \n    function \"<\"  (Left, Right : Time) return Boolean;\n@@ -135,16 +135,16 @@ private\n    -- Implementation of Time --\n    ----------------------------\n \n-   --  Time is represented as an unsigned 64 bit integer count of nanoseconds\n-   --  since the start of Ada time (1901-1-1 0.0 GMT). Time values produced\n-   --  by Time_Of are internaly normalized to GMT regardless of their local\n-   --  time zone. This representation ensures correct handling of leap seconds\n-   --  as well as performing arithmetic. In Ada 95, Split will treat a time\n-   --  value as being in the local time zone and break it down accordingly.\n-   --  In Ada 2005, Split will treat a time value as being in the designated\n-   --  time zone by the corresponding formal parameter or in GMT by default.\n-   --  The size of the type is large enough to cover the Ada 2005 range of\n-   --  time (1901-1-1 0.0 GMT - 2399-12-31-86_399.999999999 GMT).\n+   --  Time is represented as a signed 64 bit integer count of nanoseconds\n+   --  since the start of Ada time (1901-01-01 00:00:00.0 UTC). Time values\n+   --  produced by Time_Of are internaly normalized to UTC regardless of their\n+   --  local time zone. This representation ensures correct handling of leap\n+   --  seconds as well as performing arithmetic. In Ada 95, Split and Time_Of\n+   --  will treat a time value as being in the local time zone, in Ada 2005,\n+   --  Split and Time_Of will treat a time value as being in the designated\n+   --  time zone by the formal parameter or in UTC by default. The size of the\n+   --  type is large enough to cover the Ada 2005 range of time (1901-01-01\n+   --  00:00:00.0 UTC - 2399-12-31-23:59:59.999999999 UTC).\n \n    ------------------\n    -- Leap seconds --\n@@ -155,17 +155,19 @@ private\n    --  leap second is added after the last day of June or December. The count\n    --  of seconds during those occurences becomes:\n \n-   --    ... 58, 59, leap second 60, 1, 2 ...\n+   --    ... 58, 59, leap second 60, 0, 1, 2 ...\n \n    --  Unlike leap days, leap seconds occur simultaneously around the world.\n-   --  In other words, if a leap second occurs at 23:59:60 GMT, it also occurs\n-   --  on 18:59:60 -5 or 2:59:60 +2 on the next day.\n+   --  In other words, if a leap second occurs at 23:59:60 UTC, it also occurs\n+   --  on 18:59:60 -5 the same day or 2:59:60 +2 on the next day.\n+\n    --  Leap seconds do not follow a formula. The International Earth Rotation\n    --  and Reference System Service decides when to add one. Leap seconds are\n    --  included in the representation of time in Ada 95 mode. As a result,\n-   --  the following two time values will conceptually differ by two seconds:\n+   --  the following two time values will differ by two seconds:\n \n-   --    Time_Of (1972, 7, 1, 0.0) - Time_Of (1972, 6, 30, 86_399.0) = 2 secs\n+   --    1972-06-30 23:59:59.0\n+   --    1972-07-01 00:00:00.0\n \n    --  When a new leap second is added, the following steps must be carried\n    --  out:\n@@ -185,41 +187,14 @@ private\n    --  non-leap. As a consequence, seven non-leap years occur over the period\n    --  of year - 4 to year + 4. Internaly, routines Split and Time_Of add or\n    --  subtract a \"fake\" February 29 to facilitate the arithmetic involved.\n-   --  This small \"cheat\" remains hidden and the following calculations do\n-   --  produce the correct difference.\n \n-   --    Time_Of (2100, 3, 1, 0.0) - Time_Of (2100,  2, 28, 0.0) = 1 day\n-   --    Time_Of (2101, 1, 1, 0.0) - Time_Of (2100, 12, 31, 0.0) = 1 day\n+   --  The underlying type of Time has been chosen to be a 64 bit signed\n+   --  integer number since it allows for easier processing of sub seconds\n+   --  and arithmetic.\n \n-   type Time_Rep is mod 2 ** 64;\n+   type Time_Rep is range -2 ** 63 .. +2 ** 63 - 1;\n    type Time is new Time_Rep;\n \n-   --  Due to boundary time values and time zones, two days of buffer space\n-   --  are set aside at both end points of Ada time:\n-\n-   --    Abs zero  Hard low     Soft low          Soft high    Hard high\n-   --    +---------+============+#################+============+----------->\n-   --                 Buffer 1     Real Ada time     Buffer 2\n-\n-   --  A time value in a any time zone may not excede the hard bounds of Ada\n-   --  time, while a value in GMT may not go over the soft bounds.\n-\n-   Buffer_D : constant Duration := 2.0 * Secs_In_Day;\n-   Buffer_N : constant Time     := 2   * Nanos_In_Day;\n-\n-   --  Lower and upper bound of Ada time shifted by two days from the absolute\n-   --  zero. Note that the upper bound includes the non-leap centenial years.\n-\n-   Ada_Low  : constant Time := Buffer_N;\n-   Ada_High : constant Time := (121 * 366 + 378 * 365) * Nanos_In_Day +\n-                                  Buffer_N;\n-\n-   --  Both of these hard bounds are 28 hours before and after their regular\n-   --  counterpart. The value of 28 is taken from Ada.Calendar.Time_Zones.\n-\n-   Hard_Ada_Low  : constant Time := Ada_Low  - 100_800 * Nano;\n-   Hard_Ada_High : constant Time := Ada_High + 100_800 * Nano;\n-\n    Days_In_Month : constant array (Month_Number) of Day_Number :=\n                      (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);\n \n@@ -234,7 +209,7 @@ private\n \n    package Arithmetic_Operations is\n       function Add (Date : Time; Days : Long_Integer) return Time;\n-      --  Add X number of days to a time value\n+      --  Add a certain number of days to a time value\n \n       procedure Difference\n         (Left         : Time;\n@@ -248,11 +223,11 @@ private\n       --  values are positive, negative otherwise.\n \n       function Subtract (Date : Time; Days : Long_Integer) return Time;\n-      --  Subtract X number of days from a time value\n+      --  Subtract a certain number of days from a time value\n    end Arithmetic_Operations;\n \n    package Delays_Operations is\n-      function To_Duration (Ada_Time : Time) return Duration;\n+      function To_Duration (Date : Time) return Duration;\n       --  Given a time value in nanoseconds since 1901, convert it into a\n       --  duration value giving the number of nanoseconds since the Unix Epoch.\n    end Delays_Operations;\n@@ -263,18 +238,21 @@ private\n       --  within the range of 0 .. 6 (Monday .. Sunday).\n \n       procedure Split\n-        (Date       : Time;\n-         Year       : out Year_Number;\n-         Month      : out Month_Number;\n-         Day        : out Day_Number;\n-         Day_Secs   : out Day_Duration;\n-         Hour       : out Integer;\n-         Minute     : out Integer;\n-         Second     : out Integer;\n-         Sub_Sec    : out Duration;\n-         Leap_Sec   : out Boolean;\n-         Time_Zone  : Long_Integer);\n-      --  Split a time value into its components\n+        (Date      : Time;\n+         Year      : out Year_Number;\n+         Month     : out Month_Number;\n+         Day       : out Day_Number;\n+         Day_Secs  : out Day_Duration;\n+         Hour      : out Integer;\n+         Minute    : out Integer;\n+         Second    : out Integer;\n+         Sub_Sec   : out Duration;\n+         Leap_Sec  : out Boolean;\n+         Is_Ada_05 : Boolean;\n+         Time_Zone : Long_Integer);\n+      --  Split a time value into its components. Set Is_Ada_05 to use the\n+      --  local time zone (the value in Time_Zone is ignored) when splitting\n+      --  a time value.\n \n       function Time_Of\n         (Year         : Year_Number;\n@@ -286,19 +264,20 @@ private\n          Second       : Integer;\n          Sub_Sec      : Duration;\n          Leap_Sec     : Boolean;\n-         Leap_Checks  : Boolean;\n          Use_Day_Secs : Boolean;\n+         Is_Ada_05    : Boolean;\n          Time_Zone    : Long_Integer) return Time;\n       --  Given all the components of a date, return the corresponding time\n       --  value. Set Use_Day_Secs to use the value in Day_Secs, otherwise the\n       --  day duration will be calculated from Hour, Minute, Second and Sub_\n-      --  Sec. Set flag Leap_Checks to verify the validity of a leap second.\n-\n+      --  Sec. Set Is_Ada_05 to use the local time zone (the value in formal\n+      --  Time_Zone is ignored) when building a time value and to verify the\n+      --  validity of a requested leap second.\n    end Formatting_Operations;\n \n    package Time_Zones_Operations is\n       function UTC_Time_Offset (Date : Time) return Long_Integer;\n-      --  Return the offset in seconds from GMT\n+      --  Return the offset in seconds from UTC\n    end Time_Zones_Operations;\n \n end Ada.Calendar;"}, {"sha": "b8a8c01e7b666414496c192a8fed7fbfd44db8a7", "filename": "gcc/ada/a-calfor.adb", "status": "modified", "additions": 54, "deletions": 9, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/984d7dd399e6f4c29e73dee445ef149e70245459/gcc%2Fada%2Fa-calfor.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/984d7dd399e6f4c29e73dee445ef149e70245459/gcc%2Fada%2Fa-calfor.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calfor.adb?ref=984d7dd399e6f4c29e73dee445ef149e70245459", "patch": "@@ -457,7 +457,18 @@ package body Ada.Calendar.Formatting is\n \n    begin\n       Formatting_Operations.Split\n-        (Date, Year, Month, Day, Seconds, H, M, Se, Su, Leap_Second, Tz);\n+        (Date      => Date,\n+         Year      => Year,\n+         Month     => Month,\n+         Day       => Day,\n+         Day_Secs  => Seconds,\n+         Hour      => H,\n+         Minute    => M,\n+         Second    => Se,\n+         Sub_Sec   => Su,\n+         Leap_Sec  => Leap_Second,\n+         Time_Zone => Tz,\n+         Is_Ada_05 => True);\n \n       --  Validity checks\n \n@@ -491,8 +502,18 @@ package body Ada.Calendar.Formatting is\n \n    begin\n       Formatting_Operations.Split\n-        (Date, Year, Month, Day, Dd,\n-         Hour, Minute, Second, Sub_Second, Le, Tz);\n+        (Date      => Date,\n+         Year      => Year,\n+         Month     => Month,\n+         Day       => Day,\n+         Day_Secs  => Dd,\n+         Hour      => Hour,\n+         Minute    => Minute,\n+         Second    => Second,\n+         Sub_Sec   => Sub_Second,\n+         Leap_Sec  => Le,\n+         Time_Zone => Tz,\n+         Is_Ada_05 => True);\n \n       --  Validity checks\n \n@@ -529,8 +550,18 @@ package body Ada.Calendar.Formatting is\n \n    begin\n       Formatting_Operations.Split\n-       (Date, Year, Month, Day, Dd,\n-        Hour, Minute, Second, Sub_Second, Leap_Second, Tz);\n+       (Date      => Date,\n+        Year      => Year,\n+        Month     => Month,\n+        Day       => Day,\n+        Day_Secs  => Dd,\n+        Hour      => Hour,\n+        Minute    => Minute,\n+        Second    => Second,\n+        Sub_Sec   => Sub_Second,\n+        Leap_Sec  => Leap_Second,\n+        Time_Zone => Tz,\n+        Is_Ada_05 => True);\n \n       --  Validity checks\n \n@@ -621,10 +652,17 @@ package body Ada.Calendar.Formatting is\n \n       return\n         Formatting_Operations.Time_Of\n-          (Adj_Year, Adj_Month, Adj_Day, Seconds, H, M, Se, Ss,\n+          (Year         => Adj_Year,\n+           Month        => Adj_Month,\n+           Day          => Adj_Day,\n+           Day_Secs     => Seconds,\n+           Hour         => H,\n+           Minute       => M,\n+           Second       => Se,\n+           Sub_Sec      => Ss,\n            Leap_Sec     => Leap_Second,\n-           Leap_Checks  => True,\n            Use_Day_Secs => True,\n+           Is_Ada_05    => True,\n            Time_Zone    => Tz);\n    end Time_Of;\n \n@@ -663,10 +701,17 @@ package body Ada.Calendar.Formatting is\n \n       return\n         Formatting_Operations.Time_Of\n-          (Year, Month, Day, Dd, Hour, Minute, Second, Sub_Second,\n+          (Year         => Year,\n+           Month        => Month,\n+           Day          => Day,\n+           Day_Secs     => Dd,\n+           Hour         => Hour,\n+           Minute       => Minute,\n+           Second       => Second,\n+           Sub_Sec      => Sub_Second,\n            Leap_Sec     => Leap_Second,\n-           Leap_Checks  => True,\n            Use_Day_Secs => False,\n+           Is_Ada_05    => True,\n            Time_Zone    => Tz);\n    end Time_Of;\n "}]}