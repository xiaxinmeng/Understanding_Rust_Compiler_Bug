{"sha": "06bbab1ba0850f448e35c5a18661ba8d4f4925cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZiYmFiMWJhMDg1MGY0NDhlMzVjNWExODY2MWJhOGQ0ZjQ5MjVjZg==", "commit": {"author": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "1998-10-16T07:30:53Z"}, "committer": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "1998-10-16T07:30:53Z"}, "message": "The generated files\n\nFrom-SVN: r23127", "tree": {"sha": "cf1256435faea3bedd2cae799d21845562af0fd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf1256435faea3bedd2cae799d21845562af0fd7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06bbab1ba0850f448e35c5a18661ba8d4f4925cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06bbab1ba0850f448e35c5a18661ba8d4f4925cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06bbab1ba0850f448e35c5a18661ba8d4f4925cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06bbab1ba0850f448e35c5a18661ba8d4f4925cf/comments", "author": null, "committer": null, "parents": [{"sha": "f4ed83edca83441a7c3bbdf37fc8ca4fdf2841fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4ed83edca83441a7c3bbdf37fc8ca4fdf2841fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4ed83edca83441a7c3bbdf37fc8ca4fdf2841fc"}], "stats": {"total": 7770, "additions": 7770, "deletions": 0}, "files": [{"sha": "b6c8484bb4ba6a554258b53b9036b94f571c436c", "filename": "gcc/fixinc/fixincl.sh", "status": "added", "additions": 389, "deletions": 0, "changes": 389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06bbab1ba0850f448e35c5a18661ba8d4f4925cf/gcc%2Ffixinc%2Ffixincl.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06bbab1ba0850f448e35c5a18661ba8d4f4925cf/gcc%2Ffixinc%2Ffixincl.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.sh?ref=06bbab1ba0850f448e35c5a18661ba8d4f4925cf", "patch": "@@ -0,0 +1,389 @@\n+#!/bin/sh\n+#\n+# DO NOT EDIT THIS FILE   (fixincl.sh)\n+# \n+# It has been autogen-ed  Friday October 16, 1998 at 07:29:49 AM PDT\n+# From the definitions    inclhack.def\n+# and the template file   inclhack.tpl\n+#\n+# Install modified versions of certain ANSI-incompatible system header\n+# files which are fixed to work correctly with ANSI C and placed in a\n+# directory that GNU C will search.\n+#\n+# This script contains 104 fixup scripts.\n+#\n+# See README-fixinc for more information.\n+#\n+# fixincludes is free software.\n+# \n+# You may redistribute it and/or modify it under the terms of the\n+# GNU General Public License, as published by the Free Software\n+# Foundation; either version 2, or (at your option) any later version.\n+# \n+# fixincludes is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+# See the GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with fixincludes.  See the file \"COPYING\".  If not,\n+# write to:  The Free Software Foundation, Inc.,\n+#            59 Temple Place - Suite 330,\n+#            Boston,  MA  02111-1307, USA.\n+#\n+# # # # # # # # # # # # # # # # # # # # #\n+#\n+# Directory in which to store the results.\n+# Fail if no arg to specify a directory for the output.\n+if [ \"x$1\" = \"x\" ]\n+then echo fixincludes: no output directory specified\n+exit 1\n+fi\n+\n+LIB=${1}\n+shift\n+\n+# Make sure it exists.\n+if [ ! -d $LIB ]; then\n+  mkdir $LIB || {\n+    echo fixincludes:  output dir '`'$LIB\"' cannot be created\"\n+    exit 1\n+  }\n+else\n+  ( \\cd $LIB && touch DONE && rm DONE ) || {\n+    echo fixincludes:  output dir '`'$LIB\"' is an invalid directory\"\n+    exit 1\n+  }\n+fi\n+\n+# Define what target system we're fixing.\n+#\n+if test -r ./Makefile; then\n+  target_canonical=\"`sed -n -e 's,^target[ \t]*=[ \t]*\\(.*\\)$,\\1,p' < Makefile`\"\n+fi\n+\n+# If not from the Makefile, then try config.guess\n+#\n+if test -z \"${target_canonical}\" ; then\n+  if test -x ./config.guess ; then\n+    target_canonical=\"`config.guess`\" ; fi\n+  test -z \"${target_canonical}\" && target_canonical=unknown\n+fi\n+export target_canonical\n+\n+# # # # # # # # # # # # # # # # # # # # #\n+#\n+# Define PWDCMD as a command to use to get the working dir\n+# in the form that we want.\n+PWDCMD=pwd\n+\n+case \"`$PWDCMD`\" in\n+//*)\n+    # On an Apollo, discard everything before `/usr'.\n+    PWDCMD=\"eval pwd | sed -e 's,.*/usr/,/usr/,'\"\n+    ;;\n+esac\n+\n+# Original directory.\n+ORIGDIR=`${PWDCMD}`\n+FIXINCL=${ORIGDIR}/fixincl\n+export FIXINCL\n+\n+# Make LIB absolute only if needed to avoid problems with the amd.\n+case $LIB in\n+/*)\n+    ;;\n+*)\n+    cd $LIB; LIB=`${PWDCMD}`\n+    ;;\n+esac\n+\n+echo Fixing headers into ${LIB} for ${target_canonical} target\n+ \n+# Determine whether this system has symbolic links.\n+if ln -s X $LIB/ShouldNotExist 2>/dev/null; then\n+  rm -f $LIB/ShouldNotExist\n+  LINKS=true\n+elif ln -s X /tmp/ShouldNotExist 2>/dev/null; then\n+  rm -f /tmp/ShouldNotExist\n+  LINKS=true\n+else\n+  LINKS=false\n+fi\n+ \n+# # # # # # # # # # # # # # # # # # # # #\n+#\n+#  Search each input directory for broken header files.\n+#  This loop ends near the end of the file.\n+#\n+if test $# -eq 0\n+then\n+    INPUTLIST=\"/usr/include\"\n+else\n+    INPUTLIST=\"$@\"\n+fi\n+\n+for INPUT in ${INPUTLIST} ; do\n+\n+cd ${ORIGDIR}\n+\n+cd ${INPUT} || {\n+  echo 'fixincludes:  input dir `'$INPUT\"' is an invalid directory\"\n+  exit 1\n+}\n+\n+#\n+# # # # # # # # # # # # # # # # # # # # #\n+#\n+echo Finding directories and links to directories\n+\n+# Find all directories and all symlinks that point to directories.\n+# Put the list in $files.\n+# Each time we find a symlink, add it to newdirs\n+# so that we do another find within the dir the link points to.\n+# Note that $files may have duplicates in it;\n+# later parts of this file are supposed to ignore them.\n+dirs=\".\"\n+levels=2\n+while [ -n \"$dirs\" ] && [ $levels -gt 0 ]\n+do\n+    levels=`expr $levels - 1`\n+    newdirs=\n+    for d in $dirs\n+    do\n+    echo \" Searching $INPUT/$d\"\n+ \n+    # Find all directories under $d, relative to $d, excluding $d itself.\n+    # (The /. is needed after $d in case $d is a symlink.)\n+    files=\"$files `find $d/. -type d -print | \\\n+               sed -e '/\\/\\.$/d' -e 's@/./@/@g'`\"\n+    # Find all links to directories.\n+    # Using `-exec test -d' in find fails on some systems,\n+    # and trying to run test via sh fails on others,\n+    # so this is the simplest alternative left.\n+    # First find all the links, then test each one.\n+    theselinks=\n+    $LINKS && \\\n+      theselinks=`find $d/. -type l -print | sed -e 's@/./@/@g'`\n+    for d1 in $theselinks --dummy--\n+    do\n+        # If the link points to a directory,\n+        # add that dir to $newdirs\n+        if [ -d $d1 ]\n+        then\n+        files=\"$files $d1\"\n+        if [ \"`ls -ld $d1 | sed -n 's/.*-> //p'`\" != \".\" ]\n+        then\n+            newdirs=\"$newdirs $d1\"\n+        fi\n+        fi\n+    done\n+    done\n+ \n+    dirs=\"$newdirs\"\n+done\n+ \n+# # # # # # # # # # # # # # # # # # # # #\n+#\n+dirs=\n+echo \"All directories (including links to directories):\"\n+echo $files\n+ \n+for file in $files; do\n+  rm -rf $LIB/$file\n+  if [ ! -d $LIB/$file ]\n+  then mkdir $LIB/$file\n+  fi\n+done\n+mkdir $LIB/root\n+ \n+# # # # # # # # # # # # # # # # # # # # #\n+#\n+# treetops gets an alternating list\n+# of old directories to copy\n+# and the new directories to copy to.\n+treetops=\"${INPUT} ${LIB}\"\n+ \n+if $LINKS; then\n+  echo 'Making symbolic directory links'\n+  for file in $files; do\n+    dest=`ls -ld $file | sed -n 's/.*-> //p'`\n+    if [ \"$dest\" ]; then\n+      cwd=`${PWDCMD}`\n+      # In case $dest is relative, get to $file's dir first.\n+      cd ${INPUT}\n+      cd `echo ./$file | sed -n 's&[^/]*$&&p'`\n+      # Check that the target directory exists.\n+      # Redirections changed to avoid bug in sh on Ultrix.\n+      (cd $dest) > /dev/null 2>&1\n+      if [ $? = 0 ]; then\n+    cd $dest\n+    # X gets the dir that the link actually leads to.\n+    x=`${PWDCMD}`\n+    # Canonicalize ${INPUT} now to minimize the time an\n+    # automounter has to change the result of ${PWDCMD}.\n+    cinput=`cd ${INPUT}; ${PWDCMD}`\n+    # If a link points to ., make a similar link to .\n+    if [ $x = ${cinput} ]; then\n+      echo $file '->' . ': Making link'\n+      rm -fr ${LIB}/$file > /dev/null 2>&1\n+      ln -s . ${LIB}/$file > /dev/null 2>&1\n+    # If link leads back into ${INPUT},\n+    # make a similar link here.\n+    elif expr $x : \"${cinput}/.*\" > /dev/null; then\n+      # Y gets the actual target dir name, relative to ${INPUT}.\n+      y=`echo $x | sed -n \"s&${cinput}/&&p\"`\n+      # DOTS is the relative path from ${LIB}/$file's dir back to ${LIB}.\n+      dots=`echo \"$file\" |\n+        sed -e 's@^./@@' -e 's@/./@/@g' -e 's@[^/][^/]*@..@g' -e 's@..$@@'`\n+      echo $file '->' $dots$y ': Making link'\n+      rm -fr ${LIB}/$file > /dev/null 2>&1\n+      ln -s $dots$y ${LIB}/$file > /dev/null 2>&1\n+    else\n+      # If the link is to a dir $target outside ${INPUT},\n+      # repoint the link at ${INPUT}/root$target\n+      # and process $target into ${INPUT}/root$target\n+      # treat this directory as if it actually contained the files.\n+      echo $file '->' root$x ': Making link'\n+      if [ -d $LIB/root$x ]\n+      then true\n+      else\n+        dirname=root$x/\n+        dirmade=.\n+        cd $LIB\n+        while [ x$dirname != x ]; do\n+          component=`echo $dirname | sed -e 's|/.*$||'`\n+          mkdir $component >/dev/null 2>&1\n+          cd $component\n+          dirmade=$dirmade/$component\n+          dirname=`echo $dirname | sed -e 's|[^/]*/||'`\n+        done\n+      fi\n+      # Duplicate directory structure created in ${LIB}/$file in new\n+      # root area.\n+      for file2 in $files; do\n+        case $file2 in\n+          $file/*)\n+        dupdir=${LIB}/root$x/`echo $file2 | sed -n \"s|^${file}/||p\"`\n+        echo \"Duplicating ${file}'s ${dupdir}\"\n+        if [ -d ${dupdir} ]\n+        then true\n+        else\n+          mkdir ${dupdir}\n+        fi\n+        ;;\n+          *)\n+        ;;\n+        esac\n+          done\n+      # Get the path from ${LIB} to $file, accounting for symlinks.\n+      parent=`echo \"$file\" | sed -e 's@/[^/]*$@@'`\n+      libabs=`cd ${LIB}; ${PWDCMD}`\n+      file2=`cd ${LIB}; cd $parent; ${PWDCMD} | sed -e \"s@^${libabs}@@\"`\n+      # DOTS is the relative path from ${LIB}/$file's dir back to ${LIB}.\n+      dots=`echo \"$file2\" | sed -e 's@/[^/]*@../@g'`\n+      rm -fr ${LIB}/$file > /dev/null 2>&1\n+      ln -s ${dots}root$x ${LIB}/$file > /dev/null 2>&1\n+      treetops=\"$treetops $x ${LIB}/root$x\"\n+    fi\n+      fi\n+      cd $cwd\n+    fi\n+  done\n+fi\n+ \n+# # # # # # # # # # # # # # # # # # # # #\n+#\n+required=\n+set x $treetops\n+shift\n+while [ $# != 0 ]; do\n+  # $1 is an old directory to copy, and $2 is the new directory to copy to.\n+  #\n+  SRCDIR=`cd ${INPUT} ; cd $1 ; ${PWDCMD}`\n+  export SRCDIR\n+  shift\n+\n+  DESTDIR=`cd $1;${PWDCMD}`\n+  export DESTDIR\n+  shift\n+\n+  # The same dir can appear more than once in treetops.\n+  # There's no need to scan it more than once.\n+  #\n+  if [ -f ${DESTDIR}/DONE ]\n+  then continue ; fi\n+\n+  touch ${DESTDIR}/DONE\n+  echo Fixing directory ${SRCDIR} into ${DESTDIR}\n+\n+  # Check .h files which are symlinks as well as those which are files.\n+  # A link to a header file will not be processed by anything but this.\n+  #\n+  cd ${SRCDIR}\n+\n+  required=\"$required `if $LINKS; then\n+    find . -name '*.h' \\( -type f -o -type l \\) -print\n+  else\n+    find . -name '*.h' -type f -print\n+  fi | ${FIXINCL}`\"\n+done\n+\n+## Make sure that any include files referenced using double quotes\n+## exist in the fixed directory.  This comes last since otherwise\n+## we might end up deleting some of these files \"because they don't\n+## need any change.\"\n+set x `echo $required`\n+shift\n+while [ $# != 0 ]; do\n+  newreq=\n+  while [ $# != 0 ]; do\n+    # $1 is the directory to copy from,\n+    # $2 is the unfixed file,\n+    # $3 is the fixed file name.\n+    #\n+    cd ${INPUT}\n+    cd $1\n+    if [ -r $2 ] && [ ! -r $3 ]; then\n+      cp $2 $3 >/dev/null 2>&1 || echo \"Can't copy $2\" >&2\n+      chmod +w $3 2>/dev/null\n+      chmod a+r $3 2>/dev/null\n+      echo Copied $2\n+      for include in `egrep '^[ \t]*#[ \t]*include[ \t]*\"[^/]' $3 |\n+             sed -e 's/^[ \t]*#[ \t]*include[ \t]*\"\\([^\"]*\\)\".*$/\\1/'`\n+      do\n+\tdir=`echo $2 | sed -e s'|/[^/]*$||'`\n+\tdir2=`echo $3 | sed -e s'|/[^/]*$||'`\n+\tnewreq=\"$newreq $1 $dir/$include $dir2/$include\"\n+      done\n+    fi\n+    shift; shift; shift\n+  done\n+  set x $newreq\n+  shift\n+done\n+\n+echo 'Cleaning up DONE files.'\n+cd $LIB\n+find . -name DONE -exec rm -f '{}' ';'\n+\n+echo 'Removing unneeded directories:'\n+cd $LIB\n+files=`find . -type d -print | sort -r`\n+for file in $files; do\n+  rmdir $LIB/$file > /dev/null 2>&1 | :\n+done\n+\n+# # # # # # # # # # # # # # # # # # # # #\n+#\n+# End of for INPUT directories\n+#\n+done\n+#\n+# # # # # # # # # # # # # # # # # # # # #\n+\n+cd $ORIGDIR\n+rm -f include/assert.h\n+cp ${EGCS_SRCDIR}/assert.h include/assert.h\n+chmod a+r include/assert.h\n+"}, {"sha": "a26e3fe99cee54c29d6cf102b9e00dd2ddd99da7", "filename": "gcc/fixinc/fixincl.x", "status": "added", "additions": 4295, "deletions": 0, "changes": 4295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06bbab1ba0850f448e35c5a18661ba8d4f4925cf/gcc%2Ffixinc%2Ffixincl.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06bbab1ba0850f448e35c5a18661ba8d4f4925cf/gcc%2Ffixinc%2Ffixincl.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.x?ref=06bbab1ba0850f448e35c5a18661ba8d4f4925cf"}, {"sha": "9e993eaf65fdb1e68b9ca0ce4c4e2646107f9c49", "filename": "gcc/fixinc/inclhack.sh", "status": "added", "additions": 3086, "deletions": 0, "changes": 3086, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06bbab1ba0850f448e35c5a18661ba8d4f4925cf/gcc%2Ffixinc%2Finclhack.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06bbab1ba0850f448e35c5a18661ba8d4f4925cf/gcc%2Ffixinc%2Finclhack.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Finclhack.sh?ref=06bbab1ba0850f448e35c5a18661ba8d4f4925cf"}]}