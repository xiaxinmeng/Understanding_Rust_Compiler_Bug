{"sha": "847d950d3a26b03229a289bfaa5163a5352ed7f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ3ZDk1MGQzYTI2YjAzMjI5YTI4OWJmYWE1MTYzYTUzNTJlZDdmNA==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2015-10-20T10:43:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-20T10:43:21Z"}, "message": "2015-10-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.adb Add aspect Volatile_Function to table\n\tCanonical_Aspect.\n\t* aspect.ads Add aspect Volatile_Function to tables\n\tAspect_Argument, Aspect_Delay, Aspect_Id, Aspect_Names\n\tand Implementation_Defined_Aspect.  Aspects Async_Readers,\n\tAsync_Writers, Effective_Reads and Effective_Writes are no\n\tlonger Boolean.\n\t* einfo.adb (Get_Pragma): Add an entry for pragma\n\tVolatile_Function.\n\t* par-prag.adb (Prag): Pragma Volatile_Function does not need\n\tspecial processing by the parser.\n\t* rtsfind.ads Add an entry for Ada.Synchronous_Task_Control in\n\ttable RTU_Id. Add an entry for Suspension_Object in table RE_Id.\n\t* sem_ch3.adb Fix SPARK RM references.\n\t(Analyze_Object_Contract): Update the error guard.\n\t* sem_ch5.adb Fix SPARK RM references.\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Contract): Ensure\n\tthat a non-volatile function does not contain an effectively\n\tvolatile parameter.\n\t(Analyze_Subprogram_Contract): Ensure\n\tthat a non-volatile function does not contain an effectively\n\tvolatile parameter.\n\t* sem_ch12.adb (Instantiate_Object): Remove the reference to\n\tthe SPARK RM from the error message.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add\n\tprocessing for aspects Async_Readers, Async_Writers,\n\tEffective_Reads, Effective_Writes and Volatile_Function.\n\t(Check_Aspect_At_Freeze_Point): Aspects Async_Readers,\n\tAsync_Writers, Effective_Reads, Effective_Writes and\n\tVolatile_Function do not need special processing at the freeze\n\tpoint.\n\t* sem_prag.adb Add an entry for pragma Volatile_Function in\n\ttable Sig_Flags.\n\t(Analyze_External_Property_In_Decl_Part):\n\tReimplemented as Async_Readers, Async_Writers, Effective_Reads\n\tand Effective_Writes are no longer Boolean pragmas.\n\t(Analyze_Global_Item): An external state or effectively\n\tvolatile object cannot appear as an item in pragma\n\t[Refined_]Global.\n\t(Analyze_Pragma): Change the implementation\n\tof Async_Readers, Async_Writers, Effective_Reads and\n\tEffective_Writes as these are no longer Boolean pragmas.\n\tUse routine Check_Static_Boolean_Expression to verify the\n\toptional Boolean expression of Async_Readers, Async_Writers,\n\tConstant_After_Elaboration, Effective_Reads, Effective_Writes,\n\tExtensions_Visible and Volatile_Function.  Add processing for\n\tpragma Volatile_Function.\n\t(Check_Static_Boolean_Expression): New routine.\n\t(Find_Related_Context): Update the comment on usage.\n\t(Is_Enabled_Pragma): New routine.\n\t* sem_prag.ads (Is_Enabled_Pragma): New routine.\n\t* sem_res.adb Fix SPARK RM references.\n\t(Is_OK_Volatile_Context): Add detection for return statements.\n\t(Resolve_Actuals): Remove the check concerning an effectively volatile\n\tOUT actual parameter as this is now done by the SPARK flow analyzer.\n\t(Resolve_Entity_Name): Remove the check concerning an effectively\n\tvolatile OUT formal parameter as this is now done by the SPARK\n\tflow analyzer.\t(Within_Volatile_Function): New routine.\n\t* sem_util.adb (Add_Contract_Item): Add processing for pragma\n\tVolatile_Function.\n\t(Check_Nonvolatile_Function_Profile): New routine.\n\t(Is_Descendant_Of_Suspension_Object): New routine.\n\t(Is_Effectively_Volatile): Protected types and descendants of\n\tSuspension_Object are now treated as effectively volatile.\n\t(Is_Enabled): The optional Boolean expression of pragmas\n\tAsync_Readers, Async_Writers, Effective_Reads and Effective_Writes\n\tnow appears as the first argument.\n\t(Is_Volatile_Function): New routine.\n\t* sem_util.ads Add SPARK RM references.\n\t(Add_Contract_Item): Update the comment on usage.\n\t(Check_Nonvolatile_Function_Profile): New routine.\n\t(Is_Effectively_Volatile): Update the comment on usage.\n\t(Is_Volatile_Function): New routine.\n\t* snames.ads-tmpl Add a predefined name and pragma id for\n\tVolatile_Function.\n\nFrom-SVN: r229047", "tree": {"sha": "587d6e17c6aaca334c98dbdcda61607840f87327", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/587d6e17c6aaca334c98dbdcda61607840f87327"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/847d950d3a26b03229a289bfaa5163a5352ed7f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/847d950d3a26b03229a289bfaa5163a5352ed7f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/847d950d3a26b03229a289bfaa5163a5352ed7f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/847d950d3a26b03229a289bfaa5163a5352ed7f4/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e42d2186bdf3c9de8316e718b330f0c3c3701e58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e42d2186bdf3c9de8316e718b330f0c3c3701e58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e42d2186bdf3c9de8316e718b330f0c3c3701e58"}], "stats": {"total": 960, "additions": 717, "deletions": 243}, "files": [{"sha": "1278c0a9cc8ff60654e1c34039060c9f8089a0b8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=847d950d3a26b03229a289bfaa5163a5352ed7f4", "patch": "@@ -1,3 +1,81 @@\n+2015-10-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.adb Add aspect Volatile_Function to table\n+\tCanonical_Aspect.\n+\t* aspect.ads Add aspect Volatile_Function to tables\n+\tAspect_Argument, Aspect_Delay, Aspect_Id, Aspect_Names\n+\tand Implementation_Defined_Aspect.  Aspects Async_Readers,\n+\tAsync_Writers, Effective_Reads and Effective_Writes are no\n+\tlonger Boolean.\n+\t* einfo.adb (Get_Pragma): Add an entry for pragma\n+\tVolatile_Function.\n+\t* par-prag.adb (Prag): Pragma Volatile_Function does not need\n+\tspecial processing by the parser.\n+\t* rtsfind.ads Add an entry for Ada.Synchronous_Task_Control in\n+\ttable RTU_Id. Add an entry for Suspension_Object in table RE_Id.\n+\t* sem_ch3.adb Fix SPARK RM references.\n+\t(Analyze_Object_Contract): Update the error guard.\n+\t* sem_ch5.adb Fix SPARK RM references.\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Contract): Ensure\n+\tthat a non-volatile function does not contain an effectively\n+\tvolatile parameter.\n+\t(Analyze_Subprogram_Contract): Ensure\n+\tthat a non-volatile function does not contain an effectively\n+\tvolatile parameter.\n+\t* sem_ch12.adb (Instantiate_Object): Remove the reference to\n+\tthe SPARK RM from the error message.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add\n+\tprocessing for aspects Async_Readers, Async_Writers,\n+\tEffective_Reads, Effective_Writes and Volatile_Function.\n+\t(Check_Aspect_At_Freeze_Point): Aspects Async_Readers,\n+\tAsync_Writers, Effective_Reads, Effective_Writes and\n+\tVolatile_Function do not need special processing at the freeze\n+\tpoint.\n+\t* sem_prag.adb Add an entry for pragma Volatile_Function in\n+\ttable Sig_Flags.\n+\t(Analyze_External_Property_In_Decl_Part):\n+\tReimplemented as Async_Readers, Async_Writers, Effective_Reads\n+\tand Effective_Writes are no longer Boolean pragmas.\n+\t(Analyze_Global_Item): An external state or effectively\n+\tvolatile object cannot appear as an item in pragma\n+\t[Refined_]Global.\n+\t(Analyze_Pragma): Change the implementation\n+\tof Async_Readers, Async_Writers, Effective_Reads and\n+\tEffective_Writes as these are no longer Boolean pragmas.\n+\tUse routine Check_Static_Boolean_Expression to verify the\n+\toptional Boolean expression of Async_Readers, Async_Writers,\n+\tConstant_After_Elaboration, Effective_Reads, Effective_Writes,\n+\tExtensions_Visible and Volatile_Function.  Add processing for\n+\tpragma Volatile_Function.\n+\t(Check_Static_Boolean_Expression): New routine.\n+\t(Find_Related_Context): Update the comment on usage.\n+\t(Is_Enabled_Pragma): New routine.\n+\t* sem_prag.ads (Is_Enabled_Pragma): New routine.\n+\t* sem_res.adb Fix SPARK RM references.\n+\t(Is_OK_Volatile_Context): Add detection for return statements.\n+\t(Resolve_Actuals): Remove the check concerning an effectively volatile\n+\tOUT actual parameter as this is now done by the SPARK flow analyzer.\n+\t(Resolve_Entity_Name): Remove the check concerning an effectively\n+\tvolatile OUT formal parameter as this is now done by the SPARK\n+\tflow analyzer.\t(Within_Volatile_Function): New routine.\n+\t* sem_util.adb (Add_Contract_Item): Add processing for pragma\n+\tVolatile_Function.\n+\t(Check_Nonvolatile_Function_Profile): New routine.\n+\t(Is_Descendant_Of_Suspension_Object): New routine.\n+\t(Is_Effectively_Volatile): Protected types and descendants of\n+\tSuspension_Object are now treated as effectively volatile.\n+\t(Is_Enabled): The optional Boolean expression of pragmas\n+\tAsync_Readers, Async_Writers, Effective_Reads and Effective_Writes\n+\tnow appears as the first argument.\n+\t(Is_Volatile_Function): New routine.\n+\t* sem_util.ads Add SPARK RM references.\n+\t(Add_Contract_Item): Update the comment on usage.\n+\t(Check_Nonvolatile_Function_Profile): New routine.\n+\t(Is_Effectively_Volatile): Update the comment on usage.\n+\t(Is_Volatile_Function): New routine.\n+\t* snames.ads-tmpl Add a predefined name and pragma id for\n+\tVolatile_Function.\n+\n 2015-10-20  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gnat_ugn.texi, gnat_rm.texi: Regenerate."}, {"sha": "3fc20498fc10d58f47cd6a7b336c1b2f1c654a46", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=847d950d3a26b03229a289bfaa5163a5352ed7f4", "patch": "@@ -610,6 +610,7 @@ package body Aspects is\n     Aspect_Volatile                     => Aspect_Volatile,\n     Aspect_Volatile_Components          => Aspect_Volatile_Components,\n     Aspect_Volatile_Full_Access         => Aspect_Volatile_Full_Access,\n+    Aspect_Volatile_Function            => Aspect_Volatile_Function,\n     Aspect_Warnings                     => Aspect_Warnings,\n     Aspect_Write                        => Aspect_Write);\n "}, {"sha": "8b7fca89b6e360b0af183cb9ea6d02bfe787e8a0", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=847d950d3a26b03229a289bfaa5163a5352ed7f4", "patch": "@@ -78,6 +78,8 @@ package Aspects is\n       Aspect_Address,\n       Aspect_Alignment,\n       Aspect_Annotate,                      -- GNAT\n+      Aspect_Async_Readers,                 -- GNAT\n+      Aspect_Async_Writers,                 -- GNAT\n       Aspect_Attach_Handler,\n       Aspect_Bit_Order,\n       Aspect_Component_Size,\n@@ -96,6 +98,8 @@ package Aspects is\n       Aspect_Dimension_System,              -- GNAT\n       Aspect_Dispatching_Domain,\n       Aspect_Dynamic_Predicate,\n+      Aspect_Effective_Reads,               -- GNAT\n+      Aspect_Effective_Writes,              -- GNAT\n       Aspect_Extensions_Visible,            -- GNAT\n       Aspect_External_Name,\n       Aspect_External_Tag,\n@@ -145,6 +149,7 @@ package Aspects is\n       Aspect_Unsuppress,\n       Aspect_Value_Size,                    -- GNAT\n       Aspect_Variable_Indexing,\n+      Aspect_Volatile_Function,             -- GNAT\n       Aspect_Warnings,                      -- GNAT\n       Aspect_Write,\n \n@@ -167,15 +172,11 @@ package Aspects is\n       --  the aspect value is inherited from the parent, in which case, we do\n       --  not allow False if we inherit a True value from the parent.\n \n-      Aspect_Async_Readers,                 -- GNAT\n-      Aspect_Async_Writers,                 -- GNAT\n       Aspect_Asynchronous,\n       Aspect_Atomic,\n       Aspect_Atomic_Components,\n       Aspect_Disable_Controlled,            -- GNAT\n       Aspect_Discard_Names,\n-      Aspect_Effective_Reads,               -- GNAT\n-      Aspect_Effective_Writes,              -- GNAT\n       Aspect_Export,\n       Aspect_Favor_Top_Level,               -- GNAT\n       Aspect_Independent,\n@@ -264,6 +265,7 @@ package Aspects is\n       Aspect_Unreferenced               => True,\n       Aspect_Unreferenced_Objects       => True,\n       Aspect_Value_Size                 => True,\n+      Aspect_Volatile_Function          => True,\n       Aspect_Warnings                   => True,\n       others                            => False);\n \n@@ -291,7 +293,7 @@ package Aspects is\n    --  aspect is enabled. If it is False, the aspect is disabled.\n \n    subtype Boolean_Aspects is\n-     Aspect_Id range Aspect_Async_Readers .. Aspect_Id'Last;\n+     Aspect_Id range Aspect_Asynchronous .. Aspect_Id'Last;\n \n    subtype Pre_Post_Aspects is\n      Aspect_Id range Aspect_Post .. Aspect_Precondition;\n@@ -312,6 +314,8 @@ package Aspects is\n       Aspect_Address                    => Expression,\n       Aspect_Alignment                  => Expression,\n       Aspect_Annotate                   => Expression,\n+      Aspect_Async_Readers              => Optional_Expression,\n+      Aspect_Async_Writers              => Optional_Expression,\n       Aspect_Attach_Handler             => Expression,\n       Aspect_Bit_Order                  => Expression,\n       Aspect_Component_Size             => Expression,\n@@ -330,6 +334,8 @@ package Aspects is\n       Aspect_Dimension_System           => Expression,\n       Aspect_Dispatching_Domain         => Expression,\n       Aspect_Dynamic_Predicate          => Expression,\n+      Aspect_Effective_Reads            => Optional_Expression,\n+      Aspect_Effective_Writes           => Optional_Expression,\n       Aspect_Extensions_Visible         => Optional_Expression,\n       Aspect_External_Name              => Expression,\n       Aspect_External_Tag               => Expression,\n@@ -379,6 +385,7 @@ package Aspects is\n       Aspect_Unsuppress                 => Name,\n       Aspect_Value_Size                 => Expression,\n       Aspect_Variable_Indexing          => Name,\n+      Aspect_Volatile_Function          => Optional_Expression,\n       Aspect_Warnings                   => Name,\n       Aspect_Write                      => Name,\n \n@@ -511,6 +518,7 @@ package Aspects is\n       Aspect_Volatile                     => Name_Volatile,\n       Aspect_Volatile_Components          => Name_Volatile_Components,\n       Aspect_Volatile_Full_Access         => Name_Volatile_Full_Access,\n+      Aspect_Volatile_Function            => Name_Volatile_Function,\n       Aspect_Warnings                     => Name_Warnings,\n       Aspect_Write                        => Name_Write);\n \n@@ -731,6 +739,7 @@ package Aspects is\n       Aspect_Synchronization              => Never_Delay,\n       Aspect_Test_Case                    => Never_Delay,\n       Aspect_Unimplemented                => Never_Delay,\n+      Aspect_Volatile_Function            => Never_Delay,\n       Aspect_Warnings                     => Never_Delay,\n \n       Aspect_Alignment                    => Rep_Aspect,"}, {"sha": "5adc28f3652ef51afebdd8f65ab80f3c5a817be9", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=847d950d3a26b03229a289bfaa5163a5352ed7f4", "patch": "@@ -7000,7 +7000,8 @@ package body Einfo is\n                  Id = Pragma_Part_Of                    or else\n                  Id = Pragma_Refined_Depends            or else\n                  Id = Pragma_Refined_Global             or else\n-                 Id = Pragma_Refined_State;\n+                 Id = Pragma_Refined_State              or else\n+                 Id = Pragma_Volatile_Function;\n \n       --  Contract / test case pragmas\n "}, {"sha": "a3ed732995bfcbffc2bbc32d5c5a6a6b24d50194", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=847d950d3a26b03229a289bfaa5163a5352ed7f4", "patch": "@@ -1486,6 +1486,7 @@ begin\n            Pragma_Volatile                       |\n            Pragma_Volatile_Components            |\n            Pragma_Volatile_Full_Access           |\n+           Pragma_Volatile_Function              |\n            Pragma_Warning_As_Error               |\n            Pragma_Weak_External                  |\n            Pragma_Validity_Checks                =>"}, {"sha": "22f93901e0cf484a2c7bfb4e24e7410365b635e4", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=847d950d3a26b03229a289bfaa5163a5352ed7f4", "patch": "@@ -23,15 +23,15 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Types; use Types;\n-\n-package Rtsfind is\n-\n --  This package contains the routine that is used to obtain runtime library\n --  entities, loading in the required runtime library packages on demand. It\n --  is also used for such purposes as finding System.Address when System has\n --  not been explicitly With'ed.\n \n+with Types; use Types;\n+\n+package Rtsfind is\n+\n    ------------------------\n    -- Runtime Unit Table --\n    ------------------------\n@@ -131,6 +131,7 @@ package Rtsfind is\n       Ada_Real_Time,\n       Ada_Streams,\n       Ada_Strings,\n+      Ada_Synchronous_Task_Control,\n       Ada_Tags,\n       Ada_Task_Identification,\n       Ada_Task_Termination,\n@@ -606,6 +607,8 @@ package Rtsfind is\n \n      RE_Unbounded_String,                -- Ada.Strings.Unbounded\n \n+     RE_Suspension_Object,               -- Ada.Synchronous_Task_Control\n+\n      RE_Access_Level,                    -- Ada.Tags\n      RE_Alignment,                       -- Ada.Tags\n      RE_Address_Array,                   -- Ada.Tags\n@@ -1837,6 +1840,8 @@ package Rtsfind is\n \n      RE_Unbounded_String                 => Ada_Strings_Unbounded,\n \n+     RE_Suspension_Object                => Ada_Synchronous_Task_Control,\n+\n      RE_Access_Level                     => Ada_Tags,\n      RE_Alignment                        => Ada_Tags,\n      RE_Address_Array                    => Ada_Tags,"}, {"sha": "beb67574629e59fdc915b3725fd3d9827335de8e", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=847d950d3a26b03229a289bfaa5163a5352ed7f4", "patch": "@@ -5318,28 +5318,24 @@ package body Sem_Ch12 is\n             if Need_Subprogram_Instance_Body (N, Act_Decl_Id) then\n                Check_Forward_Instantiation (Gen_Decl);\n \n-               --  The wrapper package is always delayed, because it does not\n-               --  constitute a freeze point, but to insure that the freeze\n-               --  node is placed properly, it is created directly when\n-               --  instantiating the body (otherwise the freeze node might\n-               --  appear to early for nested instantiations).\n+            --  The wrapper package is always delayed, because it does not\n+            --  constitute a freeze point, but to insure that the freeze node\n+            --  is placed properly, it is created directly when instantiating\n+            --  the body (otherwise the freeze node might appear to early for\n+            --  nested instantiations). For ASIS purposes, indicate that the\n+            --  wrapper package has replaced the instantiation node.\n \n             elsif Nkind (Parent (N)) = N_Compilation_Unit then\n-\n-               --  For ASIS purposes, indicate that the wrapper package has\n-               --  replaced the instantiation node.\n-\n                Rewrite (N, Unit (Parent (N)));\n                Set_Unit (Parent (N), N);\n             end if;\n \n-         elsif Nkind (Parent (N)) = N_Compilation_Unit then\n+         --  Replace instance node for library-level instantiations of\n+         --  intrinsic subprograms, for ASIS use.\n \n-               --  Replace instance node for library-level instantiations of\n-               --  intrinsic subprograms, for ASIS use.\n-\n-               Rewrite (N, Unit (Parent (N)));\n-               Set_Unit (Parent (N), N);\n+         elsif Nkind (Parent (N)) = N_Compilation_Unit then\n+            Rewrite (N, Unit (Parent (N)));\n+            Set_Unit (Parent (N), N);\n          end if;\n \n          if Parent_Installed then\n@@ -5359,7 +5355,6 @@ package body Sem_Ch12 is\n          if SPARK_Mode = On then\n             Dynamic_Elaboration_Checks := False;\n          end if;\n-\n       end if;\n \n    <<Leave>>\n@@ -10663,17 +10658,18 @@ package body Sem_Ch12 is\n            (\"actual must exclude null to match generic formal#\", Actual);\n       end if;\n \n-      --  An effectively volatile object cannot be used as an actual in\n-      --  a generic instance. The following check is only relevant when\n-      --  SPARK_Mode is on as it is not a standard Ada legality rule.\n+      --  An effectively volatile object cannot be used as an actual in a\n+      --  generic instantiation (SPARK RM 7.1.3(7)). The following check is\n+      --  relevant only when SPARK_Mode is on as it is not a standard Ada\n+      --  legality rule.\n \n       if SPARK_Mode = On\n         and then Present (Actual)\n         and then Is_Effectively_Volatile_Object (Actual)\n       then\n          Error_Msg_N\n-           (\"volatile object cannot act as actual in generic instantiation \"\n-            & \"(SPARK RM 7.1.3(8))\", Actual);\n+           (\"volatile object cannot act as actual in generic instantiation\",\n+            Actual);\n       end if;\n \n       return List;"}, {"sha": "820a2d1cb4ccea627ccd145309a14646a7102ac4", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 82, "deletions": 39, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=847d950d3a26b03229a289bfaa5163a5352ed7f4", "patch": "@@ -2284,6 +2284,36 @@ package body Sem_Ch13 is\n                   goto Continue;\n                end Abstract_State;\n \n+               --  Aspect Async_Readers is never delayed because it is\n+               --  equivalent to a source pragma which appears after the\n+               --  related object declaration.\n+\n+               when Aspect_Async_Readers =>\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Name_Async_Readers);\n+\n+                  Decorate (Aspect, Aitem);\n+                  Insert_Pragma (Aitem);\n+                  goto Continue;\n+\n+               --  Aspect Async_Writers is never delayed because it is\n+               --  equivalent to a source pragma which appears after the\n+               --  related object declaration.\n+\n+               when Aspect_Async_Writers =>\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Name_Async_Writers);\n+\n+                  Decorate (Aspect, Aitem);\n+                  Insert_Pragma (Aitem);\n+                  goto Continue;\n+\n                --  Aspect Constant_After_Elaboration is never delayed because\n                --  it is equivalent to a source pragma which appears after the\n                --  related object declaration.\n@@ -2354,6 +2384,36 @@ package body Sem_Ch13 is\n                   Insert_Pragma (Aitem);\n                   goto Continue;\n \n+               --  Aspect Effecitve_Reads is never delayed because it is\n+               --  equivalent to a source pragma which appears after the\n+               --  related object declaration.\n+\n+               when Aspect_Effective_Reads =>\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Name_Effective_Reads);\n+\n+                  Decorate (Aspect, Aitem);\n+                  Insert_Pragma (Aitem);\n+                  goto Continue;\n+\n+               --  Aspect Effective_Writes is never delayed because it is\n+               --  equivalent to a source pragma which appears after the\n+               --  related object declaration.\n+\n+               when Aspect_Effective_Writes =>\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Name_Effective_Writes);\n+\n+                  Decorate (Aspect, Aitem);\n+                  Insert_Pragma (Aitem);\n+                  goto Continue;\n+\n                --  Aspect Extensions_Visible is never delayed because it is\n                --  equivalent to a source pragma which appears after the\n                --  related subprogram.\n@@ -2779,6 +2839,21 @@ package body Sem_Ch13 is\n                      end;\n                   end if;\n \n+               --  Aspect Volatile_Function is never delayed because it is\n+               --  equivalent to a source pragma which appears after the\n+               --  related subprogram.\n+\n+               when Aspect_Volatile_Function =>\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Name_Volatile_Function);\n+\n+                  Decorate (Aspect, Aitem);\n+                  Insert_Pragma (Aitem);\n+                  goto Continue;\n+\n                --  Case 2e: Annotate aspect\n \n                when Aspect_Annotate =>\n@@ -3234,47 +3309,10 @@ package body Sem_Ch13 is\n                      goto Continue;\n                   end if;\n \n-                  --  External property aspects are Boolean by nature, but\n-                  --  their pragmas must contain two arguments, the second\n-                  --  being the optional Boolean expression.\n-\n-                  if A_Id = Aspect_Async_Readers   or else\n-                     A_Id = Aspect_Async_Writers   or else\n-                     A_Id = Aspect_Effective_Reads or else\n-                     A_Id = Aspect_Effective_Writes\n-                  then\n-                     declare\n-                        Args : List_Id;\n-\n-                     begin\n-                        --  The first argument of the external property pragma\n-                        --  is the related object.\n-\n-                        Args :=\n-                          New_List (\n-                            Make_Pragma_Argument_Association (Sloc (Ent),\n-                              Expression => Ent));\n-\n-                        --  The second argument is the optional Boolean\n-                        --  expression which must be propagated even if it\n-                        --  evaluates to False as this has special semantic\n-                        --  meaning.\n-\n-                        if Present (Expr) then\n-                           Append_To (Args,\n-                             Make_Pragma_Argument_Association (Loc,\n-                               Expression => Relocate_Node (Expr)));\n-                        end if;\n-\n-                        Make_Aitem_Pragma\n-                          (Pragma_Argument_Associations => Args,\n-                           Pragma_Name                  => Nam);\n-                     end;\n-\n                   --  Cases where we do not delay, includes all cases where the\n                   --  expression is missing other than the above cases.\n \n-                  elsif not Delay_Required or else No (Expr) then\n+                  if not Delay_Required or else No (Expr) then\n                      Make_Aitem_Pragma\n                        (Pragma_Argument_Associations => New_List (\n                           Make_Pragma_Argument_Association (Sloc (Ent),\n@@ -9285,12 +9323,16 @@ package body Sem_Ch13 is\n \n          when Aspect_Abstract_State             |\n               Aspect_Annotate                   |\n+              Aspect_Async_Readers              |\n+              Aspect_Async_Writers              |\n               Aspect_Constant_After_Elaboration |\n               Aspect_Contract_Cases             |\n               Aspect_Default_Initial_Condition  |\n               Aspect_Depends                    |\n               Aspect_Dimension                  |\n               Aspect_Dimension_System           |\n+              Aspect_Effective_Reads            |\n+              Aspect_Effective_Writes           |\n               Aspect_Extensions_Visible         |\n               Aspect_Ghost                      |\n               Aspect_Global                     |\n@@ -9309,7 +9351,8 @@ package body Sem_Ch13 is\n               Aspect_Refined_State              |\n               Aspect_SPARK_Mode                 |\n               Aspect_Test_Case                  |\n-              Aspect_Unimplemented              =>\n+              Aspect_Unimplemented              |\n+              Aspect_Volatile_Function          =>\n             raise Program_Error;\n \n       end case;"}, {"sha": "555c361b1d377fd31b3596e2bf45f4f5d2f5e740", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=847d950d3a26b03229a289bfaa5163a5352ed7f4", "patch": "@@ -3313,19 +3313,16 @@ package body Sem_Ch3 is\n \n       if Ekind (Obj_Id) = E_Constant then\n \n-         --  A constant cannot be effectively volatile. This check is only\n-         --  relevant with SPARK_Mode on as it is not a standard Ada legality\n-         --  rule. Do not flag internally-generated constants that map generic\n-         --  formals to actuals in instantiations (SPARK RM 7.1.3(6)).\n+         --  A constant cannot be effectively volatile (SPARK RM 7.1.3(4)).\n+         --  This check is relevant only when SPARK_Mode is on as it is not a\n+         --  standard Ada legality rule. Internally-generated constants that\n+         --  map generic formals to actuals in instantiations are allowed to\n+         --  be volatile.\n \n          if SPARK_Mode = On\n+           and then Comes_From_Source (Obj_Id)\n            and then Is_Effectively_Volatile (Obj_Id)\n            and then No (Corresponding_Generic_Association (Parent (Obj_Id)))\n-\n-           --  Don't give this for internally generated entities (such as the\n-           --  FIRST and LAST temporaries generated for bounds).\n-\n-           and then Comes_From_Source (Obj_Id)\n          then\n             Error_Msg_N (\"constant cannot be volatile\", Obj_Id);\n          end if;\n@@ -3334,15 +3331,15 @@ package body Sem_Ch3 is\n \n       else pragma Assert (Ekind (Obj_Id) = E_Variable);\n \n-         --  The following checks are only relevant when SPARK_Mode is on as\n+         --  The following checks are relevant only when SPARK_Mode is on as\n          --  they are not standard Ada legality rules. Internally generated\n          --  temporaries are ignored.\n \n          if SPARK_Mode = On and then Comes_From_Source (Obj_Id) then\n             if Is_Effectively_Volatile (Obj_Id) then\n \n                --  The declaration of an effectively volatile object must\n-               --  appear at the library level (SPARK RM 7.1.3(7), C.6(6)).\n+               --  appear at the library level (SPARK RM 7.1.3(3), C.6(6)).\n \n                if not Is_Library_Level_Entity (Obj_Id) then\n                   Error_Msg_N\n@@ -3367,7 +3364,7 @@ package body Sem_Ch3 is\n \n             else\n                --  A non-effectively volatile object cannot have effectively\n-               --  volatile components (SPARK RM 7.1.3(7)).\n+               --  volatile components (SPARK RM 7.1.3(6)).\n \n                if not Is_Effectively_Volatile (Obj_Id)\n                  and then Has_Volatile_Component (Obj_Typ)\n@@ -19282,9 +19279,9 @@ package body Sem_Ch3 is\n             end if;\n          end if;\n \n-         --  A discriminant cannot be effectively volatile. This check is only\n-         --  relevant when SPARK_Mode is on as it is not standard Ada legality\n-         --  rule (SPARK RM 7.1.3(6)).\n+         --  A discriminant cannot be effectively volatile (SPARK RM 7.1.3(6)).\n+         --  This check is relevant only when SPARK_Mode is on as it is not a\n+         --  standard Ada legality rule.\n \n          if SPARK_Mode = On\n            and then Is_Effectively_Volatile (Defining_Identifier (Discr))"}, {"sha": "3e2e26b620b67df941dd7a440a1543d7f2b12489", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=847d950d3a26b03229a289bfaa5163a5352ed7f4", "patch": "@@ -2279,9 +2279,9 @@ package body Sem_Ch5 is\n          end if;\n       end if;\n \n-      --  A loop parameter cannot be effectively volatile. This check is\n-      --  peformed only when SPARK_Mode is on as it is not a standard Ada\n-      --  legality check (SPARK RM 7.1.3(6)).\n+      --  A loop parameter cannot be effectively volatile (SPARK RM 7.1.3(4)).\n+      --  This check is relevant only when SPARK_Mode is on as it is not a\n+      --  standard Ada legality check.\n \n       --  Not clear whether this applies to element iterators, where the\n       --  cursor is not an explicit entity ???\n@@ -3037,9 +3037,9 @@ package body Sem_Ch5 is\n          end;\n       end if;\n \n-      --  A loop parameter cannot be effectively volatile. This check is\n-      --  peformed only when SPARK_Mode is on as it is not a standard Ada\n-      --  legality check (SPARK RM 7.1.3(6)).\n+      --  A loop parameter cannot be effectively volatile (SPARK RM 7.1.3(4)).\n+      --  This check is relevant only when SPARK_Mode is on as it is not a\n+      --  standard Ada legality check.\n \n       if SPARK_Mode = On and then Is_Effectively_Volatile (Id) then\n          Error_Msg_N (\"loop parameter cannot be volatile\", Id);"}, {"sha": "5e1ddf5d16764c6d1442bb6f1771b90c5823d1d5", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 48, "deletions": 27, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=847d950d3a26b03229a289bfaa5163a5352ed7f4", "patch": "@@ -2228,6 +2228,19 @@ package body Sem_Ch6 is\n \n       Check_Result_And_Post_State (Body_Id);\n \n+      --  A stand alone non-volatile function body cannot have an effectively\n+      --  volatile formal parameter or return type (SPARK RM 7.1.3(9)). This\n+      --  check is relevant only when SPARK_Mode is on as it is not a standard\n+      --  legality rule. The check is performed here because Volatile_Function\n+      --  is processed after the analysis of the related subprogram body.\n+\n+      if SPARK_Mode = On\n+        and then Ekind_In (Body_Id, E_Function, E_Generic_Function)\n+        and then not Is_Volatile_Function (Body_Id)\n+      then\n+         Check_Nonvolatile_Function_Profile (Body_Id);\n+      end if;\n+\n       --  Restore the SPARK_Mode of the enclosing context after all delayed\n       --  pragmas have been analyzed.\n \n@@ -4086,6 +4099,19 @@ package body Sem_Ch6 is\n          Check_Result_And_Post_State (Subp_Id);\n       end if;\n \n+      --  A non-volatile function cannot have an effectively volatile formal\n+      --  parameter or return type (SPARK RM 7.1.3(9)). This check is relevant\n+      --  only when SPARK_Mode is on as it is not a standard legality rule. The\n+      --  check is performed here because pragma Volatile_Function is processed\n+      --  after the analysis of the related subprogram declaration.\n+\n+      if SPARK_Mode = On\n+        and then Ekind_In (Subp_Id, E_Function, E_Generic_Function)\n+        and then not Is_Volatile_Function (Subp_Id)\n+      then\n+         Check_Nonvolatile_Function_Profile (Subp_Id);\n+      end if;\n+\n       --  Restore the SPARK_Mode of the enclosing context after all delayed\n       --  pragmas have been analyzed.\n \n@@ -4451,9 +4477,9 @@ package body Sem_Ch6 is\n          --  the check is applied later (see Analyze_Subprogram_Declaration).\n \n          if not Nkind_In (Original_Node (Parent (N)),\n-                          N_Subprogram_Renaming_Declaration,\n                           N_Abstract_Subprogram_Declaration,\n-                          N_Formal_Abstract_Subprogram_Declaration)\n+                          N_Formal_Abstract_Subprogram_Declaration,\n+                          N_Subprogram_Renaming_Declaration)\n          then\n             if Is_Abstract_Type (Etype (Designator))\n               and then not Is_Interface (Etype (Designator))\n@@ -4464,14 +4490,15 @@ package body Sem_Ch6 is\n             --  Ada 2012 (AI-0073): Extend this test to subprograms with an\n             --  access result whose designated type is abstract.\n \n-            elsif Nkind (Result_Definition (N)) = N_Access_Definition\n+            elsif Ada_Version >= Ada_2012\n+              and then Nkind (Result_Definition (N)) = N_Access_Definition\n               and then\n                 not Is_Class_Wide_Type (Designated_Type (Etype (Designator)))\n               and then Is_Abstract_Type (Designated_Type (Etype (Designator)))\n-              and then Ada_Version >= Ada_2012\n             then\n-               Error_Msg_N (\"function whose access result designates \"\n-                            & \"abstract type must be abstract\", N);\n+               Error_Msg_N\n+                 (\"function whose access result designates abstract type \"\n+                  & \"must be abstract\", N);\n             end if;\n          end if;\n       end if;\n@@ -9933,17 +9960,6 @@ package body Sem_Ch6 is\n      (T           : List_Id;\n       Related_Nod : Node_Id)\n    is\n-      Context     : constant Node_Id := Parent (Parent (T));\n-      Param_Spec  : Node_Id;\n-      Formal      : Entity_Id;\n-      Formal_Type : Entity_Id;\n-      Default     : Node_Id;\n-      Ptype       : Entity_Id;\n-\n-      Num_Out_Params  : Nat       := 0;\n-      First_Out_Param : Entity_Id := Empty;\n-      --  Used for setting Is_Only_Out_Parameter\n-\n       function Designates_From_Limited_With (Typ : Entity_Id) return Boolean;\n       --  Determine whether an access type designates a type coming from a\n       --  limited view.\n@@ -9986,6 +10002,19 @@ package body Sem_Ch6 is\n                      and then Is_Class_Wide_Type (Etype (Prefix (D))));\n       end Is_Class_Wide_Default;\n \n+      --  Local variables\n+\n+      Context     : constant Node_Id := Parent (Parent (T));\n+      Default     : Node_Id;\n+      Formal      : Entity_Id;\n+      Formal_Type : Entity_Id;\n+      Param_Spec  : Node_Id;\n+      Ptype       : Entity_Id;\n+\n+      Num_Out_Params  : Nat       := 0;\n+      First_Out_Param : Entity_Id := Empty;\n+      --  Used for setting Is_Only_Out_Parameter\n+\n    --  Start of processing for Process_Formals\n \n    begin\n@@ -10269,8 +10298,8 @@ package body Sem_Ch6 is\n             Null_Exclusion_Static_Checks (Param_Spec);\n          end if;\n \n-         --  The following checks are relevant when SPARK_Mode is on as these\n-         --  are not standard Ada legality rules.\n+         --  The following checks are relevant only when SPARK_Mode is on as\n+         --  these are not standard Ada legality rules.\n \n          if SPARK_Mode = On then\n             if Ekind_In (Scope (Formal), E_Function, E_Generic_Function) then\n@@ -10282,14 +10311,6 @@ package body Sem_Ch6 is\n                   Error_Msg_N\n                     (\"function cannot have parameter of mode `OUT` or \"\n                      & \"`IN OUT`\", Formal);\n-\n-               --  A function cannot have an effectively volatile formal\n-               --  parameter (SPARK RM 7.1.3(10)).\n-\n-               elsif Is_Effectively_Volatile (Formal) then\n-                  Error_Msg_N\n-                    (\"function cannot have a volatile formal parameter\",\n-                     Formal);\n                end if;\n \n             --  A procedure cannot have an effectively volatile formal"}, {"sha": "2733dc39bd2f1d393e1d2c4c178a5794cba2e017", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 206, "deletions": 85, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=847d950d3a26b03229a289bfaa5163a5352ed7f4", "patch": "@@ -206,7 +206,8 @@ package body Sem_Prag is\n    function Find_Related_Context\n      (Prag      : Node_Id;\n       Do_Checks : Boolean := False) return Node_Id;\n-   --  Subsidiaty to the analysis of pragmas Constant_After_Elaboration and\n+   --  Subsidiaty to the analysis of pragmas Async_Readers, Async_Writers,\n+   --  Constant_After_Elaboration, Effective_Reads, Effective_Writers and\n    --  Part_Of. Find the first source declaration or statement found while\n    --  traversing the previous node chain starting from pragma Prag. If flag\n    --  Do_Checks is set, the routine reports duplicate pragmas. The routine\n@@ -1720,19 +1721,12 @@ package body Sem_Prag is\n      (N        : Node_Id;\n       Expr_Val : out Boolean)\n    is\n-      Arg1   : constant Node_Id   := First (Pragma_Argument_Associations (N));\n-      Expr   : constant Node_Id   := Get_Pragma_Arg (Next (Arg1));\n-      Obj_Id : constant Entity_Id := Entity (Get_Pragma_Arg (Arg1));\n-\n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n+      Arg1     : constant Node_Id := First (Pragma_Argument_Associations (N));\n+      Obj_Decl : constant Node_Id := Find_Related_Context (N);\n+      Obj_Id   : constant Entity_Id := Defining_Entity (Obj_Decl);\n+      Expr     : Node_Id;\n \n    begin\n-      --  Set the Ghost mode in effect from the pragma. Due to the delayed\n-      --  analysis of the pragma, the Ghost mode at point of declaration and\n-      --  point of analysis may not necessarely be the same. Use the mode in\n-      --  effect at the point of declaration.\n-\n-      Set_Ghost_Mode (N);\n       Error_Msg_Name_1 := Pragma_Name (N);\n \n       --  An external property pragma must apply to an effectively volatile\n@@ -1754,17 +1748,13 @@ package body Sem_Prag is\n \n       Expr_Val := True;\n \n-      if Present (Expr) then\n-         Analyze_And_Resolve (Expr, Standard_Boolean);\n+      if Present (Arg1) then\n+         Expr := Get_Pragma_Arg (Arg1);\n \n          if Is_OK_Static_Expression (Expr) then\n             Expr_Val := Is_True (Expr_Value (Expr));\n-         else\n-            SPARK_Msg_N (\"expression of % must be static\", Expr);\n          end if;\n       end if;\n-\n-      Ghost_Mode := Save_Ghost_Mode;\n    end Analyze_External_Property_In_Decl_Part;\n \n    ---------------------------------\n@@ -1924,6 +1914,18 @@ package body Sem_Prag is\n                      SPARK_Msg_N (\"\\use its constituents instead\", Item);\n                      return;\n \n+                  --  An external state cannot appear as a global item of a\n+                  --  nonvolatile function (SPARK RM 7.1.3(8)).\n+\n+                  elsif Is_External_State (Item_Id)\n+                    and then Ekind_In (Spec_Id, E_Function, E_Generic_Function)\n+                    and then not Is_Volatile_Function (Spec_Id)\n+                  then\n+                     SPARK_Msg_NE\n+                       (\"external state & cannot act as global item of \"\n+                        & \"nonvolatile function\", Item, Item_Id);\n+                     return;\n+\n                   --  If the reference to the abstract state appears in an\n                   --  enclosing package body that will eventually refine the\n                   --  state, record the reference for future checks.\n@@ -1956,9 +1958,11 @@ package body Sem_Prag is\n                  and then Is_Effectively_Volatile (Item_Id)\n                then\n                   --  An effectively volatile object cannot appear as a global\n-                  --  item of a function (SPARK RM 7.1.3(9)).\n+                  --  item of a nonvolatile function (SPARK RM 7.1.3(8)).\n \n-                  if Ekind_In (Spec_Id, E_Function, E_Generic_Function) then\n+                  if Ekind_In (Spec_Id, E_Function, E_Generic_Function)\n+                    and then not Is_Volatile_Function (Spec_Id)\n+                  then\n                      Error_Msg_NE\n                        (\"volatile object & cannot act as global item of a \"\n                         & \"function\", Item, Item_Id);\n@@ -2936,6 +2940,13 @@ package body Sem_Prag is\n       --  In this version of the procedure, the identifier name is given as\n       --  a string with lower case letters.\n \n+      procedure Check_Static_Boolean_Expression (Expr : Node_Id);\n+      --  Subsidiary to the analysis of pragmas Async_Readers, Async_Writers,\n+      --  Constant_After_Elaboration, Effective_Reads, Effective_Writes,\n+      --  Extensions_Visible and Volatile_Function. Ensure that expression Expr\n+      --  is an OK static boolean expression. Emit an error if this is not the\n+      --  case.\n+\n       procedure Check_Static_Constraint (Constr : Node_Id);\n       --  Constr is a constraint from an N_Subtype_Indication node from a\n       --  component constraint in an Unchecked_Union type. This routine checks\n@@ -5070,6 +5081,22 @@ package body Sem_Prag is\n          Check_Optional_Identifier (Arg, Name_Find);\n       end Check_Optional_Identifier;\n \n+      -------------------------------------\n+      -- Check_Static_Boolean_Expression --\n+      -------------------------------------\n+\n+      procedure Check_Static_Boolean_Expression (Expr : Node_Id) is\n+      begin\n+         if Present (Expr) then\n+            Analyze_And_Resolve (Expr, Standard_Boolean);\n+\n+            if not Is_OK_Static_Expression (Expr) then\n+               Error_Pragma_Arg\n+                 (\"expression of pragma % must be static\", Expr);\n+            end if;\n+         end if;\n+      end Check_Static_Boolean_Expression;\n+\n       -----------------------------\n       -- Check_Static_Constraint --\n       -----------------------------\n@@ -11079,74 +11106,65 @@ package body Sem_Prag is\n          -- Async_Readers/Async_Writers/Effective_Reads/Effective_Writes --\n          ------------------------------------------------------------------\n \n-         --  pragma Asynch_Readers   ( object_LOCAL_NAME [, FLAG] );\n-         --  pragma Asynch_Writers   ( object_LOCAL_NAME [, FLAG] );\n-         --  pragma Effective_Reads  ( object_LOCAL_NAME [, FLAG] );\n-         --  pragma Effective_Writes ( object_LOCAL_NAME [, FLAG] );\n-\n-         --  FLAG ::= boolean_EXPRESSION\n+         --  pragma Asynch_Readers   [ (boolean_EXPRESSION) ];\n+         --  pragma Asynch_Writers   [ (boolean_EXPRESSION) ];\n+         --  pragma Effective_Reads  [ (boolean_EXPRESSION) ];\n+         --  pragma Effective_Writes [ (boolean_EXPRESSION) ];\n \n          when Pragma_Async_Readers    |\n               Pragma_Async_Writers    |\n               Pragma_Effective_Reads  |\n               Pragma_Effective_Writes =>\n          Async_Effective : declare\n-            Duplic : Node_Id;\n-            Expr   : Node_Id;\n-            Obj    : Node_Id;\n-            Obj_Id : Entity_Id;\n+            Obj_Decl : Node_Id;\n+            Obj_Id   : Entity_Id;\n \n          begin\n             GNAT_Pragma;\n             Check_No_Identifiers;\n-            Check_At_Least_N_Arguments (1);\n-            Check_At_Most_N_Arguments  (2);\n-            Check_Arg_Is_Local_Name (Arg1);\n-            Error_Msg_Name_1 := Pname;\n+            Check_At_Most_N_Arguments  (1);\n \n-            Obj  := Get_Pragma_Arg (Arg1);\n-            Expr := Get_Pragma_Arg (Arg2);\n+            Obj_Decl := Find_Related_Context (N, Do_Checks => True);\n+\n+            --  Object declaration\n+\n+            if Nkind (Obj_Decl) = N_Object_Declaration then\n+               null;\n+\n+            --  Otherwise the pragma is associated with an illegal construact\n+\n+            else\n+               Pragma_Misplaced;\n+               return;\n+            end if;\n+\n+            Obj_Id := Defining_Entity (Obj_Decl);\n \n             --  Perform minimal verification to ensure that the argument is at\n             --  least a variable. Subsequent finer grained checks will be done\n             --  at the end of the declarative region the contains the pragma.\n \n-            if Is_Entity_Name (Obj)\n-              and then Present (Entity (Obj))\n-              and then Ekind (Entity (Obj)) = E_Variable\n-            then\n-               Obj_Id := Entity (Obj);\n+            if Ekind (Obj_Id) = E_Variable then\n \n                --  A pragma that applies to a Ghost entity becomes Ghost for\n                --  the purposes of legality checks and removal of ignored Ghost\n                --  code.\n \n                Mark_Pragma_As_Ghost (N, Obj_Id);\n \n-               --  Detect a duplicate pragma. Note that it is not efficient to\n-               --  examine preceding statements as Boolean aspects may appear\n-               --  anywhere between the related object declaration and its\n-               --  freeze point. As an alternative, inspect the contents of the\n-               --  variable contract.\n-\n-               Duplic := Get_Pragma (Obj_Id, Prag_Id);\n+               --  Analyze the Boolean expression (if any)\n \n-               if Present (Duplic) then\n-                  Error_Msg_Sloc := Sloc (Duplic);\n-                  Error_Msg_N (\"pragma % duplicates pragma declared #\", N);\n+               if Present (Arg1) then\n+                  Check_Static_Boolean_Expression (Get_Pragma_Arg (Arg1));\n+               end if;\n \n-               --  No duplicate detected\n+               --  Chain the pragma on the contract for further processing by\n+               --  Analyze_External_Property_In_Decl_Part.\n \n-               else\n-                  if Present (Expr) then\n-                     Preanalyze_And_Resolve (Expr, Standard_Boolean);\n-                  end if;\n+               Add_Contract_Item (N, Obj_Id);\n \n-                  --  Chain the pragma on the contract for further processing\n-                  --  by Analyze_External_Property_In_Decl_Part.\n+            --  Otherwise the external property applies to a constant\n \n-                  Add_Contract_Item (N, Obj_Id);\n-               end if;\n             else\n                Error_Pragma (\"pragma % must apply to a volatile object\");\n             end if;\n@@ -12150,7 +12168,6 @@ package body Sem_Prag is\n \n          when Pragma_Constant_After_Elaboration => Constant_After_Elaboration :\n          declare\n-            Expr     : Node_Id;\n             Obj_Decl : Node_Id;\n             Obj_Id   : Entity_Id;\n \n@@ -12208,15 +12225,7 @@ package body Sem_Prag is\n             --  Analyze the Boolean expression (if any)\n \n             if Present (Arg1) then\n-               Expr := Get_Pragma_Arg (Arg1);\n-\n-               Analyze_And_Resolve (Expr, Standard_Boolean);\n-\n-               if not Is_OK_Static_Expression (Expr) then\n-                  Error_Pragma_Arg\n-                    (\"expression of pragma % must be static\", Expr);\n-                  return;\n-               end if;\n+               Check_Static_Boolean_Expression (Get_Pragma_Arg (Arg1));\n             end if;\n \n             --  Chain the pragma on the contract for completeness\n@@ -13950,7 +13959,6 @@ package body Sem_Prag is\n          --    the annotation must instantiate itself.\n \n          when Pragma_Extensions_Visible => Extensions_Visible : declare\n-            Expr          : Node_Id;\n             Formal        : Entity_Id;\n             Has_OK_Formal : Boolean := False;\n             Spec_Id       : Entity_Id;\n@@ -14043,15 +14051,8 @@ package body Sem_Prag is\n             --  Analyze the Boolean expression (if any)\n \n             if Present (Arg1) then\n-               Expr := Expression (Get_Argument (N, Spec_Id));\n-\n-               Analyze_And_Resolve (Expr, Standard_Boolean);\n-\n-               if not Is_OK_Static_Expression (Expr) then\n-                  Error_Pragma_Arg\n-                    (\"expression of pragma % must be static\", Expr);\n-                  return;\n-               end if;\n+               Check_Static_Boolean_Expression\n+                 (Expression (Get_Argument (N, Spec_Id)));\n             end if;\n \n             --  Chain the pragma on the contract for completeness\n@@ -21486,6 +21487,14 @@ package body Sem_Prag is\n          when Pragma_Volatile =>\n             Process_Atomic_Independent_Shared_Volatile;\n \n+         -------------------------\n+         -- Volatile_Components --\n+         -------------------------\n+\n+         --  pragma Volatile_Components (array_LOCAL_NAME);\n+\n+         --  Volatile is handled by the same circuit as Atomic_Components\n+\n          --------------------------\n          -- Volatile_Full_Access --\n          --------------------------\n@@ -21496,13 +21505,97 @@ package body Sem_Prag is\n             GNAT_Pragma;\n             Process_Atomic_Independent_Shared_Volatile;\n \n-         -------------------------\n-         -- Volatile_Components --\n-         -------------------------\n+         -----------------------\n+         -- Volatile_Function --\n+         -----------------------\n \n-         --  pragma Volatile_Components (array_LOCAL_NAME);\n+         --  pragma Volatile_Function [ (boolean_EXPRESSION) ];\n \n-         --  Volatile is handled by the same circuit as Atomic_Components\n+         when Pragma_Volatile_Function => Volatile_Function : declare\n+            Over_Id   : Entity_Id;\n+            Spec_Id   : Entity_Id;\n+            Subp_Decl : Node_Id;\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_No_Identifiers;\n+            Check_At_Most_N_Arguments (1);\n+\n+            Subp_Decl :=\n+              Find_Related_Subprogram_Or_Body (N, Do_Checks => True);\n+\n+            --  Function instantiation\n+\n+            if Nkind (Subp_Decl) = N_Function_Instantiation then\n+               null;\n+\n+            --  Generic subprogram\n+\n+            elsif Nkind (Subp_Decl) = N_Generic_Subprogram_Declaration then\n+               null;\n+\n+            --  Body acts as spec\n+\n+            elsif Nkind (Subp_Decl) = N_Subprogram_Body\n+              and then No (Corresponding_Spec (Subp_Decl))\n+            then\n+               null;\n+\n+            --  Body stub acts as spec\n+\n+            elsif Nkind (Subp_Decl) = N_Subprogram_Body_Stub\n+              and then No (Corresponding_Spec_Of_Stub (Subp_Decl))\n+            then\n+               null;\n+\n+            --  Subprogram\n+\n+            elsif Nkind (Subp_Decl) = N_Subprogram_Declaration then\n+               null;\n+\n+            else\n+               Pragma_Misplaced;\n+               return;\n+            end if;\n+\n+            Spec_Id := Corresponding_Spec_Of (Subp_Decl);\n+            Over_Id := Overridden_Operation (Spec_Id);\n+\n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Spec_Id);\n+\n+            --  A volatile function cannot override a non-volatile function\n+            --  (SPARK RM 7.1.2(15)). Overriding checks are usually performed\n+            --  in New_Overloaded_Entity, however at that point the pragma has\n+            --  not been processed yet.\n+\n+            if Present (Over_Id)\n+              and then not Is_Volatile_Function (Over_Id)\n+            then\n+               Error_Msg_N\n+                 (\"incompatible volatile function values in effect\", Spec_Id);\n+\n+               Error_Msg_Sloc := Sloc (Over_Id);\n+               Error_Msg_N\n+                 (\"\\& declared # with Volatile_Function value `False`\",\n+                  Spec_Id);\n+\n+               Error_Msg_Sloc := Sloc (Spec_Id);\n+               Error_Msg_N\n+                 (\"\\overridden # with Volatile_Function value `True`\",\n+                  Spec_Id);\n+            end if;\n+\n+            --  Analyze the Boolean expression (if any)\n+\n+            if Present (Arg1) then\n+               Check_Static_Boolean_Expression (Get_Pragma_Arg (Arg1));\n+            end if;\n+\n+            Add_Contract_Item (N, Spec_Id);\n+         end Volatile_Function;\n \n          ----------------------\n          -- Warning_As_Error --\n@@ -26278,6 +26371,33 @@ package body Sem_Prag is\n            and then Nkind (Parent (Parent (N))) = N_Package_Body;\n    end Is_Elaboration_SPARK_Mode;\n \n+   -----------------------\n+   -- Is_Enabled_Pragma --\n+   -----------------------\n+\n+   function Is_Enabled_Pragma (Prag : Node_Id) return Boolean is\n+      Arg : Node_Id;\n+\n+   begin\n+      if Present (Prag) then\n+         Arg := First (Pragma_Argument_Associations (Prag));\n+\n+         if Present (Arg) then\n+            return Is_True (Expr_Value (Get_Pragma_Arg (Arg)));\n+\n+         --  The lack of a Boolean argument automatically enables the pragma\n+\n+         else\n+            return True;\n+         end if;\n+\n+      --  The pragma is missing, therefore it is not enabled\n+\n+      else\n+         return False;\n+      end if;\n+   end Is_Enabled_Pragma;\n+\n    -----------------------------------------\n    -- Is_Non_Significant_Pragma_Reference --\n    -----------------------------------------\n@@ -26519,6 +26639,7 @@ package body Sem_Prag is\n       Pragma_Volatile                       =>  0,\n       Pragma_Volatile_Components            =>  0,\n       Pragma_Volatile_Full_Access           =>  0,\n+      Pragma_Volatile_Function              =>  0,\n       Pragma_Warning_As_Error               =>  0,\n       Pragma_Warnings                       =>  0,\n       Pragma_Weak_External                  =>  0,"}, {"sha": "cdd3657dfdf21095cf2c75deabcde58acfea9046", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=847d950d3a26b03229a289bfaa5163a5352ed7f4", "patch": "@@ -364,6 +364,23 @@ package Sem_Prag is\n    --  Determine whether pragma SPARK_Mode appears in the statement part of a\n    --  package body.\n \n+   function Is_Enabled_Pragma (Prag : Node_Id) return Boolean;\n+   --  Determine whether a Boolean-like SPARK pragma Prag is enabled. To be\n+   --  considered enabled, the pragma must either:\n+   --    * Appear without its Boolean expression\n+   --    * The Boolean expression evaluates to \"True\"\n+   --\n+   --  Boolean-like SPARK pragmas differ from pure Boolean Ada pragmas in that\n+   --  their optional Boolean expression must be static and cannot benefit from\n+   --  forward references. The following are Boolean-like SPARK pragmas:\n+   --    Async_Readers\n+   --    Async_Writers\n+   --    Constant_After_Elaboration\n+   --    Effective_Reads\n+   --    Effective_Writes\n+   --    Extensions_Visible\n+   --    Volatile_Function\n+\n    function Is_Non_Significant_Pragma_Reference (N : Node_Id) return Boolean;\n    --  The node N is a node for an entity and the issue is whether the\n    --  occurrence is a reference for the purposes of giving warnings about"}, {"sha": "5b62aed1ad9fbf6dca75da140fe7cba635949dce", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 61, "deletions": 29, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=847d950d3a26b03229a289bfaa5163a5352ed7f4", "patch": "@@ -4105,22 +4105,11 @@ package body Sem_Res is\n                --  actual to a nested call, since this constitutes a reading of\n                --  the parameter, which is not allowed.\n \n-               if Is_Entity_Name (A)\n+               if Ada_Version = Ada_83\n+                 and then Is_Entity_Name (A)\n                  and then Ekind (Entity (A)) = E_Out_Parameter\n                then\n-                  if Ada_Version = Ada_83 then\n-                     Error_Msg_N\n-                       (\"(Ada 83) illegal reading of out parameter\", A);\n-\n-                  --  An effectively volatile OUT parameter cannot act as IN or\n-                  --  IN OUT actual in a call (SPARK RM 7.1.3(11)).\n-\n-                  elsif SPARK_Mode = On\n-                    and then Is_Effectively_Volatile (Entity (A))\n-                  then\n-                     Error_Msg_N\n-                       (\"illegal reading of volatile OUT parameter\", A);\n-                  end if;\n+                  Error_Msg_N (\"(Ada 83) illegal reading of out parameter\", A);\n                end if;\n             end if;\n \n@@ -4472,8 +4461,8 @@ package body Sem_Res is\n             --  temporaries are ignored.\n \n             if SPARK_Mode = On\n-              and then Is_Effectively_Volatile_Object (A)\n               and then Comes_From_Source (A)\n+              and then Is_Effectively_Volatile_Object (A)\n             then\n                --  An effectively volatile object may act as an actual\n                --  parameter when the corresponding formal is of a non-scalar\n@@ -6792,7 +6781,7 @@ package body Sem_Res is\n         (Context : Node_Id;\n          Obj_Ref : Node_Id) return Boolean;\n       --  Determine whether node Context denotes a \"non-interfering context\"\n-      --  (as defined in SPARK RM 7.1.3(13)) where volatile reference Obj_Ref\n+      --  (as defined in SPARK RM 7.1.3(12)) where volatile reference Obj_Ref\n       --  can safely reside.\n \n       ----------------------------------------\n@@ -6851,6 +6840,10 @@ package body Sem_Res is\n          function Within_Procedure_Call (Nod : Node_Id) return Boolean;\n          --  Determine whether an arbitrary node appears in a procedure call\n \n+         function Within_Volatile_Function (Id : Entity_Id) return Boolean;\n+         --  Determine whether an arbitrary entity appears in a volatile\n+         --  function.\n+\n          ------------------\n          -- Within_Check --\n          ------------------\n@@ -6905,6 +6898,32 @@ package body Sem_Res is\n             return False;\n          end Within_Procedure_Call;\n \n+         ------------------------------\n+         -- Within_Volatile_Function --\n+         ------------------------------\n+\n+         function Within_Volatile_Function (Id : Entity_Id) return Boolean is\n+            Func_Id : Entity_Id;\n+\n+         begin\n+            --  Traverse the scope stack looking for a [generic] function\n+\n+            Func_Id := Id;\n+            while Present (Func_Id) and then Func_Id /= Standard_Standard loop\n+               if Ekind_In (Func_Id, E_Function, E_Generic_Function) then\n+                  return Is_Volatile_Function (Func_Id);\n+               end if;\n+\n+               Func_Id := Scope (Func_Id);\n+            end loop;\n+\n+            return False;\n+         end Within_Volatile_Function;\n+\n+         --  Local variables\n+\n+         Obj_Id : Entity_Id;\n+\n       --  Start of processing for Is_OK_Volatile_Context\n \n       begin\n@@ -6914,14 +6933,26 @@ package body Sem_Res is\n             return True;\n \n          --  The volatile object is part of the initialization expression of\n-         --  another object. Ensure that the climb of the parent chain came\n-         --  from the expression side and not from the name side.\n+         --  another object.\n \n          elsif Nkind (Context) = N_Object_Declaration\n            and then Present (Expression (Context))\n            and then Expression (Context) = Obj_Ref\n          then\n-            return True;\n+            Obj_Id := Defining_Entity (Context);\n+\n+            --  The volatile object acts as the initialization expression of an\n+            --  extended return statement. This is valid context as long as the\n+            --  function is volatile.\n+\n+            if Is_Return_Object (Obj_Id) then\n+               return Within_Volatile_Function (Obj_Id);\n+\n+            --  Otherwise this is a normal object initialization\n+\n+            else\n+               return True;\n+            end if;\n \n          --  The volatile object appears as an actual parameter in a call to an\n          --  instance of Unchecked_Conversion whose result is renamed.\n@@ -6932,6 +6963,15 @@ package body Sem_Res is\n          then\n             return True;\n \n+         --  The volatile object appears as the expression of a simple return\n+         --  statement that applies to a volatile function.\n+\n+         elsif Nkind (Context) = N_Simple_Return_Statement\n+           and then Expression (Context) = Obj_Ref\n+         then\n+            return\n+              Within_Volatile_Function (Return_Statement_Entity (Context));\n+\n          --  The volatile object appears as the prefix of a name occurring\n          --  in a non-interfering context.\n \n@@ -7057,14 +7097,6 @@ package body Sem_Res is\n       then\n          if Ada_Version = Ada_83 then\n             Error_Msg_N (\"(Ada 83) illegal reading of out parameter\", N);\n-\n-         --  An effectively volatile OUT parameter cannot be read\n-         --  (SPARK RM 7.1.3(11)).\n-\n-         elsif SPARK_Mode = On\n-           and then Is_Effectively_Volatile (E)\n-         then\n-            Error_Msg_N (\"illegal reading of volatile OUT parameter\", N);\n          end if;\n \n       --  In all other cases, just do the possible static evaluation\n@@ -7117,7 +7149,7 @@ package body Sem_Res is\n         and then Comes_From_Source (N)\n       then\n          --  The effectively volatile objects appears in a \"non-interfering\n-         --  context\" as defined in SPARK RM 7.1.3(13).\n+         --  context\" as defined in SPARK RM 7.1.3(12).\n \n          if Is_OK_Volatile_Context (Par, N) then\n             null;\n@@ -7128,7 +7160,7 @@ package body Sem_Res is\n          else\n             SPARK_Msg_N\n               (\"volatile object cannot appear in this context \"\n-               & \"(SPARK RM 7.1.3(13))\", N);\n+               & \"(SPARK RM 7.1.3(12))\", N);\n          end if;\n       end if;\n "}, {"sha": "27b8f9e5e74d72d3dd5518c8a8946ca9deaffd03", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 140, "deletions": 4, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=847d950d3a26b03229a289bfaa5163a5352ed7f4", "patch": "@@ -375,6 +375,7 @@ package body Sem_Util is\n       --    Postcondition\n       --    Precondition\n       --    Test_Case\n+      --    Volatile_Function\n \n       elsif Ekind_In (Id, E_Entry, E_Entry_Family)\n         or else Is_Generic_Subprogram (Id)\n@@ -392,6 +393,11 @@ package body Sem_Util is\n          then\n             Add_Classification;\n \n+         elsif Prag_Nam = Name_Volatile_Function\n+           and then Ekind_In (Id, E_Function, E_Generic_Function)\n+         then\n+            Add_Classification;\n+\n          --  The pragma is not a proper contract item\n \n          else\n@@ -3146,6 +3152,36 @@ package body Sem_Util is\n       end if;\n    end Check_No_Hidden_State;\n \n+   ----------------------------------------\n+   -- Check_Nonvolatile_Function_Profile --\n+   ----------------------------------------\n+\n+   procedure Check_Nonvolatile_Function_Profile (Func_Id : Entity_Id) is\n+      Formal : Entity_Id;\n+\n+   begin\n+      --  Inspect all formal parameters\n+\n+      Formal := First_Formal (Func_Id);\n+      while Present (Formal) loop\n+         if Is_Effectively_Volatile (Etype (Formal)) then\n+            Error_Msg_NE\n+              (\"nonvolatile function & cannot have a volatile parameter\",\n+               Formal, Func_Id);\n+         end if;\n+\n+         Next_Formal (Formal);\n+      end loop;\n+\n+      --  Inspect the return type\n+\n+      if Is_Effectively_Volatile (Etype (Func_Id)) then\n+         Error_Msg_N\n+           (\"nonvolatile function & cannot have a volatile return type\",\n+            Func_Id);\n+      end if;\n+   end Check_Nonvolatile_Function_Profile;\n+\n    ------------------------------------------\n    -- Check_Potentially_Blocking_Operation --\n    ------------------------------------------\n@@ -8577,18 +8613,18 @@ package body Sem_Util is\n          ----------------\n \n          function Is_Enabled (Prag : Node_Id) return Boolean is\n-            Arg2 : Node_Id;\n+            Arg1 : Node_Id;\n \n          begin\n             if Present (Prag) then\n-               Arg2 := Next (First (Pragma_Argument_Associations (Prag)));\n+               Arg1 := First (Pragma_Argument_Associations (Prag));\n \n                --  The pragma has an optional Boolean expression, the related\n                --  property is enabled only when the expression evaluates to\n                --  True.\n \n-               if Present (Arg2) then\n-                  return Is_True (Expr_Value (Get_Pragma_Arg (Arg2)));\n+               if Present (Arg1) then\n+                  return Is_True (Expr_Value (Get_Pragma_Arg (Arg1)));\n \n                --  Otherwise the lack of expression enables the property by\n                --  default.\n@@ -11358,6 +11394,66 @@ package body Sem_Util is\n    -----------------------------\n \n    function Is_Effectively_Volatile (Id : Entity_Id) return Boolean is\n+      function Is_Descendant_Of_Suspension_Object\n+        (Typ : Entity_Id) return Boolean;\n+      --  Determine whether type Typ is a descendant of type Suspension_Object\n+      --  defined in Ada.Synchronous_Task_Control. This routine is similar to\n+      --  Sem_Util.Is_Descendent_Of, however this version does not load unit\n+      --  Ada.Synchronous_Task_Control.\n+\n+      ----------------------------------------\n+      -- Is_Descendant_Of_Suspension_Object --\n+      ----------------------------------------\n+\n+      function Is_Descendant_Of_Suspension_Object\n+        (Typ : Entity_Id) return Boolean\n+      is\n+         Cur_Typ : Entity_Id;\n+         Par_Typ : Entity_Id;\n+\n+      begin\n+         --  Do not attempt to load Ada.Synchronous_Task_Control in No_Run_Time\n+         --  mode. The unit contains tagged types and those are not allowed in\n+         --  this mode.\n+\n+         if No_Run_Time_Mode then\n+            return False;\n+\n+         --  Unit Ada.Synchronous_Task_Control is not available, the type\n+         --  cannot possibly be a descendant of Suspension_Object.\n+\n+         elsif not RTE_Available (RE_Suspension_Object) then\n+            return False;\n+         end if;\n+\n+         --  Climb the type derivation chain checking each parent type against\n+         --  Suspension_Object.\n+\n+         Cur_Typ := Base_Type (Typ);\n+         while Present (Cur_Typ) loop\n+            Par_Typ := Etype (Cur_Typ);\n+\n+            --  The current type is a match\n+\n+            if Is_RTE (Cur_Typ, RE_Suspension_Object) then\n+               return True;\n+\n+            --  Stop the traversal once the root of the derivation chain has\n+            --  been reached. In that case the current type is its own base\n+            --  type.\n+\n+            elsif Cur_Typ = Par_Typ then\n+               exit;\n+            end if;\n+\n+            Cur_Typ := Base_Type (Par_Typ);\n+         end loop;\n+\n+         return False;\n+      end Is_Descendant_Of_Suspension_Object;\n+\n+   --  Start of processing for Is_Effectively_Volatile\n+\n    begin\n       if Is_Type (Id) then\n \n@@ -11377,6 +11473,19 @@ package body Sem_Util is\n                 or else\n               Is_Effectively_Volatile (Component_Type (Base_Type (Id)));\n \n+         --  A protected type is always volatile\n+\n+         elsif Is_Protected_Type (Id) then\n+            return True;\n+\n+         --  A descendant of Ada.Synchronous_Task_Control.Suspension_Object is\n+         --  automatically volatile.\n+\n+         elsif Is_Descendant_Of_Suspension_Object (Id) then\n+            return True;\n+\n+         --  Otherwise the type is not effectively volatile\n+\n          else\n             return False;\n          end if;\n@@ -13510,6 +13619,33 @@ package body Sem_Util is\n         and then Scope (Scope (Scope (Root))) = Standard_Standard;\n    end Is_Visibly_Controlled;\n \n+   --------------------------\n+   -- Is_Volatile_Function --\n+   --------------------------\n+\n+   function Is_Volatile_Function (Func_Id : Entity_Id) return Boolean is\n+   begin\n+      --  The caller must ensure that Func_Id denotes a function\n+\n+      pragma Assert (Ekind_In (Func_Id, E_Function, E_Generic_Function));\n+\n+      --  A protected function is automatically volatile\n+\n+      if Is_Primitive (Func_Id)\n+        and then Present (First_Formal (Func_Id))\n+        and then Is_Protected_Type (Etype (First_Formal (Func_Id)))\n+      then\n+         return True;\n+\n+      --  Otherwise the function is treated as volatile if it is subject to\n+      --  enabled pragma Volatile_Function.\n+\n+      else\n+         return\n+           Is_Enabled_Pragma (Get_Pragma (Func_Id, Pragma_Volatile_Function));\n+      end if;\n+   end Is_Volatile_Function;\n+\n    ------------------------\n    -- Is_Volatile_Object --\n    ------------------------"}, {"sha": "5583aa001daa8a5f00b7e560eac4bb6b44e0b081", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=847d950d3a26b03229a289bfaa5163a5352ed7f4", "patch": "@@ -73,6 +73,7 @@ package Sem_Util is\n    --    Refined_Post\n    --    Refined_States\n    --    Test_Case\n+   --    Volatile_Function\n \n    procedure Add_Global_Declaration (N : Node_Id);\n    --  These procedures adds a declaration N at the library level, to be\n@@ -313,6 +314,10 @@ package Sem_Util is\n    --  Determine whether object or state Id introduces a hidden state. If this\n    --  is the case, emit an error.\n \n+   procedure Check_Nonvolatile_Function_Profile (Func_Id : Entity_Id);\n+   --  Verify that the profile of nonvolatile function Func_Id does not contain\n+   --  effectively volatile parameters or return type.\n+\n    procedure Check_Potentially_Blocking_Operation (N : Node_Id);\n    --  N is one of the statement forms that is a potentially blocking\n    --  operation. If it appears within a protected action, emit warning.\n@@ -533,7 +538,7 @@ package Sem_Util is\n \n    function Enclosing_Declaration (N : Node_Id) return Node_Id;\n    --  Returns the declaration node enclosing N (including possibly N itself),\n-   --  if any, or Empty otherwise\n+   --  if any, or Empty otherwise.\n \n    function Enclosing_Generic_Body\n      (N : Node_Id) return Node_Id;\n@@ -1285,13 +1290,17 @@ package Sem_Util is\n    --  . machine_emin = 3 - machine_emax\n \n    function Is_Effectively_Volatile (Id : Entity_Id) return Boolean;\n-   --  The SPARK property \"effectively volatile\" applies to both types and\n-   --  objects. To qualify as such, an entity must be either volatile or be\n-   --  (of) an array type subject to aspect Volatile_Components.\n+   --  Determine whether a type or object denoted by entity Id is effectively\n+   --  volatile (SPARK RM 7.1.2). To qualify as such, the entity must be either\n+   --    * Volatile\n+   --    * An array type subject to aspect Volatile_Components\n+   --    * An array type whose component type is effectively volatile\n+   --    * A protected type\n+   --    * Descendant of type Ada.Synchronous_Task_Control.Suspension_Object\n \n    function Is_Effectively_Volatile_Object (N : Node_Id) return Boolean;\n    --  Determine whether an arbitrary node denotes an effectively volatile\n-   --  object.\n+   --  object (SPARK RM 7.1.2).\n \n    function Is_Expression_Function (Subp : Entity_Id) return Boolean;\n    --  Predicate to determine whether a scope entity comes from a rewritten\n@@ -1301,8 +1310,8 @@ package Sem_Util is\n    function Is_EVF_Expression (N : Node_Id) return Boolean;\n    --  Determine whether node N denotes a reference to a formal parameter of\n    --  a specific tagged type whose related subprogram is subject to pragma\n-   --  Extensions_Visible with value \"False\". Several other constructs fall\n-   --  under this category:\n+   --  Extensions_Visible with value \"False\" (SPARK RM 6.1.7). Several other\n+   --  constructs fall under this category:\n    --    1) A qualified expression whose operand is EVF\n    --    2) A type conversion whose operand is EVF\n    --    3) An if expression with at least one EVF dependent_expression\n@@ -1550,6 +1559,11 @@ package Sem_Util is\n    --  Initialize/Adjust/Finalize subprogram does not override the inherited\n    --  one.\n \n+   function Is_Volatile_Function (Func_Id : Entity_Id) return Boolean;\n+   --  Determine whether [generic] function Func_Id is subject to enabled\n+   --  pragma Volatile_Function. Protected functions are treated as volatile\n+   --  (SPARK RM 7.1.2).\n+\n    function Is_Volatile_Object (N : Node_Id) return Boolean;\n    --  Determines if the given node denotes an volatile object in the sense of\n    --  the legality checks described in RM C.6(12). Note that the test here is"}, {"sha": "d5b06a8677b3da6b27aa6bd37ff13a005eef7ffb", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/847d950d3a26b03229a289bfaa5163a5352ed7f4/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=847d950d3a26b03229a289bfaa5163a5352ed7f4", "patch": "@@ -632,6 +632,7 @@ package Snames is\n    Name_Volatile                       : constant Name_Id := N + $;\n    Name_Volatile_Components            : constant Name_Id := N + $;\n    Name_Volatile_Full_Access           : constant Name_Id := N + $; -- GNAT\n+   Name_Volatile_Function              : constant Name_Id := N + $; -- GNAT\n    Name_Weak_External                  : constant Name_Id := N + $; -- GNAT\n    Last_Pragma_Name                    : constant Name_Id := N + $;\n \n@@ -1937,6 +1938,7 @@ package Snames is\n       Pragma_Volatile,\n       Pragma_Volatile_Components,\n       Pragma_Volatile_Full_Access,\n+      Pragma_Volatile_Function,\n       Pragma_Weak_External,\n \n       --  The following pragmas are on their own, out of order, because of the"}]}