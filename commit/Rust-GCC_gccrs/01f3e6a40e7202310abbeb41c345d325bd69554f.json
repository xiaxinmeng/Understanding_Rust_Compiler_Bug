{"sha": "01f3e6a40e7202310abbeb41c345d325bd69554f", "node_id": "C_kwDOANBUbNoAKDAxZjNlNmE0MGU3MjAyMzEwYWJiZWI0MWMzNDVkMzI1YmQ2OTU1NGY", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-01-10T14:47:08Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-01-10T14:47:08Z"}, "message": "ira: Consider modelling caller-save allocations as loop spills\n\nIf an allocno A in an inner loop L spans a call, a parent allocno AP\ncan choose to handle a call-clobbered/caller-saved hard register R\nin one of two ways:\n\n(1) save R before each call in L and restore R after each call\n(2) spill R to memory throughout L\n\n(2) can be cheaper than (1) in some cases, particularly if L does\nnot reference A.\n\nBefore the patch we always did (1).  The patch adds support for\npicking (2) instead, when it seems cheaper.  It builds on the\nearlier support for not propagating conflicts to parent allocnos.\n\ngcc/\n\tPR rtl-optimization/98782\n\t* ira-int.h (ira_caller_save_cost): New function.\n\t(ira_caller_save_loop_spill_p): Likewise.\n\t* ira-build.c (ira_propagate_hard_reg_costs): Test whether it is\n\tcheaper to spill a call-clobbered register throughout a loop rather\n\tthan spill it around each individual call.  If so, treat all\n\tcall-clobbered registers as conflicts and...\n\t(propagate_allocno_info): ...do not propagate call information\n\tfrom the child to the parent.\n\t* ira-color.c (move_spill_restore): Update accordingly.\n\t* ira-costs.c (ira_tune_allocno_costs): Use ira_caller_save_cost.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/reg-alloc-3.c: New test.", "tree": {"sha": "6d8f6b63a55b2760ea02c3cb0eccc5cf6fc86d58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d8f6b63a55b2760ea02c3cb0eccc5cf6fc86d58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01f3e6a40e7202310abbeb41c345d325bd69554f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01f3e6a40e7202310abbeb41c345d325bd69554f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01f3e6a40e7202310abbeb41c345d325bd69554f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01f3e6a40e7202310abbeb41c345d325bd69554f/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e7a23728f66d2da88b47e34224410457fdefbf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e7a23728f66d2da88b47e34224410457fdefbf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e7a23728f66d2da88b47e34224410457fdefbf5"}], "stats": {"total": 147, "additions": 129, "deletions": 18}, "files": [{"sha": "ab3e87164e10fa72f4b1af4c74a8fc9a405bbb40", "filename": "gcc/ira-build.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01f3e6a40e7202310abbeb41c345d325bd69554f/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01f3e6a40e7202310abbeb41c345d325bd69554f/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=01f3e6a40e7202310abbeb41c345d325bd69554f", "patch": "@@ -2000,6 +2000,8 @@ ira_propagate_hard_reg_costs (ira_allocno_t parent_a, ira_allocno_t a,\n \t\t\t      int spill_cost)\n {\n   HARD_REG_SET conflicts = ira_total_conflict_hard_regs (a);\n+  if (ira_caller_save_loop_spill_p (parent_a, a, spill_cost))\n+    conflicts |= ira_need_caller_save_regs (a);\n   conflicts &= ~ira_total_conflict_hard_regs (parent_a);\n \n   auto costs = ALLOCNO_HARD_REG_COSTS (a);\n@@ -2069,15 +2071,18 @@ propagate_allocno_info (void)\n \t  if (!ira_subloop_allocnos_can_differ_p (parent_a))\n \t    merge_hard_reg_conflicts (a, parent_a, true);\n \n-\t  ALLOCNO_CALL_FREQ (parent_a) += ALLOCNO_CALL_FREQ (a);\n-\t  ALLOCNO_CALLS_CROSSED_NUM (parent_a)\n-\t    += ALLOCNO_CALLS_CROSSED_NUM (a);\n-\t  ALLOCNO_CHEAP_CALLS_CROSSED_NUM (parent_a)\n-\t    += ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a);\n-\t  ALLOCNO_CROSSED_CALLS_ABIS (parent_a)\n-\t    |= ALLOCNO_CROSSED_CALLS_ABIS (a);\n-\t  ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (parent_a)\n-\t    |= ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a);\n+\t  if (!ira_caller_save_loop_spill_p (parent_a, a, spill_cost))\n+\t    {\n+\t      ALLOCNO_CALL_FREQ (parent_a) += ALLOCNO_CALL_FREQ (a);\n+\t      ALLOCNO_CALLS_CROSSED_NUM (parent_a)\n+\t\t+= ALLOCNO_CALLS_CROSSED_NUM (a);\n+\t      ALLOCNO_CHEAP_CALLS_CROSSED_NUM (parent_a)\n+\t\t+= ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a);\n+\t      ALLOCNO_CROSSED_CALLS_ABIS (parent_a)\n+\t\t|= ALLOCNO_CROSSED_CALLS_ABIS (a);\n+\t      ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (parent_a)\n+\t\t|= ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a);\n+\t    }\n \t  ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (parent_a)\n \t    += ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);\n \t  aclass = ALLOCNO_CLASS (a);"}, {"sha": "1487afc5ef16bc7dd26e58387d26714e2e5a8be7", "filename": "gcc/ira-color.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01f3e6a40e7202310abbeb41c345d325bd69554f/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01f3e6a40e7202310abbeb41c345d325bd69554f/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=01f3e6a40e7202310abbeb41c345d325bd69554f", "patch": "@@ -3597,11 +3597,16 @@ move_spill_restore (void)\n \t\t propagate_allocno_info will have propagated\n \t\t the cost of spilling HARD_REGNO in SUBLOOP_NODE.\n \t\t (ira_subloop_allocnos_can_differ_p must be true\n-\t\t in that case.)  Otherwise, SPILL_COST acted as\n-\t\t a cap on the propagated register cost, in cases\n-\t\t where the allocations can differ.  */\n+\t\t in that case.)  If HARD_REGNO is a caller-saved\n+\t\t register, we might have modelled it in the same way.\n+\n+\t\t Otherwise, SPILL_COST acted as a cap on the propagated\n+\t\t register cost, in cases where the allocations can differ.  */\n \t      auto conflicts = ira_total_conflict_hard_regs (subloop_allocno);\n-\t      if (TEST_HARD_REG_BIT (conflicts, hard_regno))\n+\t      if (TEST_HARD_REG_BIT (conflicts, hard_regno)\n+\t\t  || (ira_need_caller_save_p (subloop_allocno, hard_regno)\n+\t\t      && ira_caller_save_loop_spill_p (a, subloop_allocno,\n+\t\t\t\t\t\t       spill_cost)))\n \t\treg_cost = spill_cost;\n \t      else if (ira_subloop_allocnos_can_differ_p (a))\n \t\treg_cost = MIN (reg_cost, spill_cost);"}, {"sha": "cbb58d32be81196f97bd7f5fd2eff261184e21ea", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01f3e6a40e7202310abbeb41c345d325bd69554f/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01f3e6a40e7202310abbeb41c345d325bd69554f/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=01f3e6a40e7202310abbeb41c345d325bd69554f", "patch": "@@ -2308,7 +2308,7 @@ ira_tune_allocno_costs (void)\n {\n   int j, n, regno;\n   int cost, min_cost, *reg_costs;\n-  enum reg_class aclass, rclass;\n+  enum reg_class aclass;\n   machine_mode mode;\n   ira_allocno_t a;\n   ira_allocno_iterator ai;\n@@ -2347,12 +2347,9 @@ ira_tune_allocno_costs (void)\n \t\t}\n \t      if (skip_p)\n \t\tcontinue;\n-\t      rclass = REGNO_REG_CLASS (regno);\n \t      cost = 0;\n \t      if (ira_need_caller_save_p (a, regno))\n-\t\tcost += (ALLOCNO_CALL_FREQ (a)\n-\t\t\t * (ira_memory_move_cost[mode][rclass][0]\n-\t\t\t    + ira_memory_move_cost[mode][rclass][1]));\n+\t\tcost += ira_caller_save_cost (a);\n #ifdef IRA_HARD_REGNO_ADD_COST_MULTIPLIER\n \t      cost += ((ira_memory_move_cost[mode][rclass][0]\n \t\t\t+ ira_memory_move_cost[mode][rclass][1])"}, {"sha": "a78811eb416b50c84d5e3a90ee00e3904c33447a", "filename": "gcc/ira-int.h", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01f3e6a40e7202310abbeb41c345d325bd69554f/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01f3e6a40e7202310abbeb41c345d325bd69554f/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=01f3e6a40e7202310abbeb41c345d325bd69554f", "patch": "@@ -1660,4 +1660,43 @@ ira_total_conflict_hard_regs (ira_allocno_t a)\n   return conflicts;\n }\n \n+/* Return the cost of saving a caller-saved register before each call\n+   in A's live range and restoring the same register after each call.  */\n+inline int\n+ira_caller_save_cost (ira_allocno_t a)\n+{\n+  auto mode = ALLOCNO_MODE (a);\n+  auto rclass = ALLOCNO_CLASS (a);\n+  return (ALLOCNO_CALL_FREQ (a)\n+\t  * (ira_memory_move_cost[mode][rclass][0]\n+\t     + ira_memory_move_cost[mode][rclass][1]));\n+}\n+\n+/* A and SUBLOOP_A are allocnos for the same pseudo register, with A's\n+   loop immediately enclosing SUBLOOP_A's loop.  If we allocate to A a\n+   hard register R that is clobbered by a call in SUBLOOP_A, decide\n+   which of the following approaches should be used for handling the\n+   conflict:\n+\n+   (1) Spill R on entry to SUBLOOP_A's loop, assign memory to SUBLOOP_A,\n+       and restore R on exit from SUBLOOP_A's loop.\n+\n+   (2) Spill R before each necessary call in SUBLOOP_A's live range and\n+       restore R after each such call.\n+\n+   Return true if (1) is better than (2).  SPILL_COST is the cost of\n+   doing (1).  */\n+inline bool\n+ira_caller_save_loop_spill_p (ira_allocno_t a, ira_allocno_t subloop_a,\n+\t\t\t      int spill_cost)\n+{\n+  if (!ira_subloop_allocnos_can_differ_p (a))\n+    return false;\n+\n+  /* Calculate the cost of saving a call-clobbered register\n+     before each call and restoring it afterwards.  */\n+  int call_cost = ira_caller_save_cost (subloop_a);\n+  return call_cost && call_cost >= spill_cost;\n+}\n+\n #endif /* GCC_IRA_INT_H */"}, {"sha": "7acdc432b0c28a17b91fc292471d777449d98004", "filename": "gcc/testsuite/gcc.target/aarch64/reg-alloc-3.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01f3e6a40e7202310abbeb41c345d325bd69554f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Freg-alloc-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01f3e6a40e7202310abbeb41c345d325bd69554f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Freg-alloc-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Freg-alloc-3.c?ref=01f3e6a40e7202310abbeb41c345d325bd69554f", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-options \"-O2 -fno-schedule-insns -fno-schedule-insns2\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" { target lp64 } } } */\n+\n+#define PROB 0.1\n+\n+struct L\n+{\n+  int data;\n+  volatile struct L *next;\n+  volatile struct L *inner;\n+};\n+\n+void ext();\n+\n+/* The thing we're testing here is that the !head->inner path of the outer loop\n+   body has no stack accesses.  It's possible that we'll need to update this\n+   pattern for unrelated code changes. but the test should be XFAILed rather\n+   than changed if any new stack accesses creep into the !head->inner path.  */\n+/*\n+** foo:\n+**\t...\n+**\tldr\t(w[0-9]+), \\[(x[0-9]+)\\]\n+**\tadd\t(w[0-9]+), (?:\\3, \\1|\\1, \\3)\n+**\tldr\t(x[0-9]+), \\[\\2, #?16\\]\n+**\tstr\t\\3, \\[\\2\\]\n+**\tldr\t\\2, \\[\\2, #?8\\]\n+**\tcbn?z\t\\4, .*\n+**\t...\n+**\tret\n+*/\n+void\n+foo (volatile struct L *head, int inc, double *ptr)\n+{\n+  double d = *ptr;\n+  while (head)\n+    {\n+      /* Clobber all call-preserved GPRs, so that the loop has to use\n+\t call-clobbered GPRs if it is to avoid spilling.  */\n+      asm volatile (\"\" :::\n+\t\t    \"x19\", \"x20\", \"x21\", \"x22\", \"x23\",\n+\t\t    \"x24\", \"x25\", \"x26\", \"x27\", \"x28\");\n+      inc = head->data + inc;\n+      volatile struct L *inner = head->inner;\n+      head->data = inc;\n+      head = head->next;\n+      if (__builtin_expect_with_probability (inner != 0, 0, PROB))\n+\tfor (int i = 0; i < 1000; ++i)\n+\t  {\n+\t    ext ();\n+\t    /* Hack to create high register pressure, so that IRA doesn't\n+\t       collapse this loop into the parent loop.  */\n+\t    d += 1;\n+\t    asm volatile (\"// foo\" :::\n+\t\t\t  \"d0\", \"d1\", \"d2\", \"d3\",\n+\t\t\t  \"d4\", \"d5\", \"d6\", \"d7\",\n+\t\t\t  \"d8\", \"d9\", \"d10\", \"d11\",\n+\t\t\t  \"d12\", \"d13\", \"d14\", \"d15\",\n+\t\t\t  \"d16\", \"d17\", \"d18\", \"d19\",\n+\t\t\t  \"d20\", \"d21\", \"d22\", \"d23\",\n+\t\t\t  \"d24\", \"d25\", \"d26\", \"d27\",\n+\t\t\t  \"d28\", \"d29\", \"d30\", \"d31\");\n+\t  }\n+    }\n+  *ptr = d;\n+}"}]}