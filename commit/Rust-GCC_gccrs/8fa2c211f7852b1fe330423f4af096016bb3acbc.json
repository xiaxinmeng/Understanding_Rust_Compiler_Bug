{"sha": "8fa2c211f7852b1fe330423f4af096016bb3acbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZhMmMyMTFmNzg1MmIxZmUzMzA0MjNmNGFmMDk2MDE2YmIzYWNiYw==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@synopsys.com", "date": "2018-11-13T12:06:58Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gcc.gnu.org", "date": "2018-11-13T12:06:58Z"}, "message": "[ARC] Add peephole rules to combine store/loads into double store/loads\n\nSimple peephole rules which combines multiple ld/st instructions into\n64-bit load/store instructions. It only works for architectures which\nare having double load/store option on.\n\ngcc/\n\tClaudiu Zissulescu  <claziss@synopsys.com>\n\n\t* config/arc/arc-protos.h (gen_operands_ldd_std): Add.\n\t* config/arc/arc.c (operands_ok_ldd_std): New function.\n\t(mem_ok_for_ldd_std): Likewise.\n\t(gen_operands_ldd_std): Likewise.\n\t* config/arc/arc.md: Add peephole2 rules for std/ldd.\n\nFrom-SVN: r266064", "tree": {"sha": "e71b93ba94c6071da4257549369e6fe6141fd287", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e71b93ba94c6071da4257549369e6fe6141fd287"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fa2c211f7852b1fe330423f4af096016bb3acbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fa2c211f7852b1fe330423f4af096016bb3acbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fa2c211f7852b1fe330423f4af096016bb3acbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fa2c211f7852b1fe330423f4af096016bb3acbc/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2cc2582cf823912f2cd87aaf9c0aed0ccc989e48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cc2582cf823912f2cd87aaf9c0aed0ccc989e48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cc2582cf823912f2cd87aaf9c0aed0ccc989e48"}], "stats": {"total": 240, "additions": 240, "deletions": 0}, "files": [{"sha": "cc2ac29b3be53beb39087333d7e851e6a336f66b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fa2c211f7852b1fe330423f4af096016bb3acbc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fa2c211f7852b1fe330423f4af096016bb3acbc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8fa2c211f7852b1fe330423f4af096016bb3acbc", "patch": "@@ -1,3 +1,11 @@\n+2018-11-13  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* config/arc/arc-protos.h (gen_operands_ldd_std): Add.\n+\t* config/arc/arc.c (operands_ok_ldd_std): New function.\n+\t(mem_ok_for_ldd_std): Likewise.\n+\t(gen_operands_ldd_std): Likewise.\n+\t* config/arc/arc.md: Add peephole2 rules for std/ldd.\n+\n 2018-11-13  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* toplev.c (output_stack_usage): Turn test on flag_stack_usage into"}, {"sha": "55f8ed4c6439688a483a368ab07c9d3777a3244c", "filename": "gcc/config/arc/arc-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fa2c211f7852b1fe330423f4af096016bb3acbc/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fa2c211f7852b1fe330423f4af096016bb3acbc/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=8fa2c211f7852b1fe330423f4af096016bb3acbc", "patch": "@@ -45,6 +45,8 @@ extern bool compact_memory_operand_p (rtx, machine_mode, bool, bool);\n extern int arc_return_address_register (unsigned int);\n extern unsigned int arc_compute_function_type (struct function *);\n extern bool arc_is_uncached_mem_p (rtx);\n+extern bool arc_lra_p (void);\n+extern bool gen_operands_ldd_std (rtx *operands, bool load, bool commute);\n #endif /* RTX_CODE */\n \n extern unsigned int arc_compute_frame_size (int);"}, {"sha": "41157d41c4d69d4067008358a308992f45ea72e2", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fa2c211f7852b1fe330423f4af096016bb3acbc/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fa2c211f7852b1fe330423f4af096016bb3acbc/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=8fa2c211f7852b1fe330423f4af096016bb3acbc", "patch": "@@ -10880,6 +10880,167 @@ arc_cannot_substitute_mem_equiv_p (rtx)\n   return true;\n }\n \n+/* Checks whether the operands are valid for use in an LDD/STD\n+   instruction.  Assumes that RT, and RT2 are REG.  This is guaranteed\n+   by the patterns.  Assumes that the address in the base register RN\n+   is word aligned.  Pattern guarantees that both memory accesses use\n+   the same base register, the offsets are constants within the range,\n+   and the gap between the offsets is 4.  If reload complete then\n+   check that registers are legal.  */\n+\n+static bool\n+operands_ok_ldd_std (rtx rt, rtx rt2, HOST_WIDE_INT offset)\n+{\n+  unsigned int t, t2;\n+\n+  if (!reload_completed)\n+    return true;\n+\n+  if (!(SMALL_INT_RANGE (offset, (GET_MODE_SIZE (DImode) - 1) & (~0x03),\n+\t\t\t (offset & (GET_MODE_SIZE (DImode) - 1) & 3\n+\t\t\t  ? 0 : -(-GET_MODE_SIZE (DImode) | (~0x03)) >> 1))))\n+    return false;\n+\n+  t = REGNO (rt);\n+  t2 = REGNO (rt2);\n+\n+  if ((t2 == PROGRAM_COUNTER_REGNO)\n+      || (t % 2 != 0)\t/* First destination register is not even.  */\n+      || (t2 != t + 1))\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Helper for gen_operands_ldd_std.  Returns true iff the memory\n+   operand MEM's address contains an immediate offset from the base\n+   register and has no side effects, in which case it sets BASE and\n+   OFFSET accordingly.  */\n+\n+static bool\n+mem_ok_for_ldd_std (rtx mem, rtx *base, rtx *offset)\n+{\n+  rtx addr;\n+\n+  gcc_assert (base != NULL && offset != NULL);\n+\n+  /* TODO: Handle more general memory operand patterns, such as\n+     PRE_DEC and PRE_INC.  */\n+\n+  if (side_effects_p (mem))\n+    return false;\n+\n+  /* Can't deal with subregs.  */\n+  if (GET_CODE (mem) == SUBREG)\n+    return false;\n+\n+  gcc_assert (MEM_P (mem));\n+\n+  *offset = const0_rtx;\n+\n+  addr = XEXP (mem, 0);\n+\n+  /* If addr isn't valid for DImode, then we can't handle it.  */\n+  if (!arc_legitimate_address_p (DImode, addr,\n+\t\t\t\treload_in_progress || reload_completed))\n+    return false;\n+\n+  if (REG_P (addr))\n+    {\n+      *base = addr;\n+      return true;\n+    }\n+  else if (GET_CODE (addr) == PLUS || GET_CODE (addr) == MINUS)\n+    {\n+      *base = XEXP (addr, 0);\n+      *offset = XEXP (addr, 1);\n+      return (REG_P (*base) && CONST_INT_P (*offset));\n+    }\n+\n+  return false;\n+}\n+\n+/* Called from peephole2 to replace two word-size accesses with a\n+   single LDD/STD instruction.  Returns true iff we can generate a new\n+   instruction sequence.  That is, both accesses use the same base\n+   register and the gap between constant offsets is 4.  OPERANDS are\n+   the operands found by the peephole matcher; OPERANDS[0,1] are\n+   register operands, and OPERANDS[2,3] are the corresponding memory\n+   operands.  LOAD indicates whether the access is load or store.  */\n+\n+bool\n+gen_operands_ldd_std (rtx *operands, bool load, bool commute)\n+{\n+  int i, gap;\n+  HOST_WIDE_INT offsets[2], offset;\n+  int nops = 2;\n+  rtx cur_base, cur_offset, tmp;\n+  rtx base = NULL_RTX;\n+\n+  /* Check that the memory references are immediate offsets from the\n+     same base register.  Extract the base register, the destination\n+     registers, and the corresponding memory offsets.  */\n+  for (i = 0; i < nops; i++)\n+    {\n+      if (!mem_ok_for_ldd_std (operands[nops+i], &cur_base, &cur_offset))\n+\treturn false;\n+\n+      if (i == 0)\n+\tbase = cur_base;\n+      else if (REGNO (base) != REGNO (cur_base))\n+\treturn false;\n+\n+      offsets[i] = INTVAL (cur_offset);\n+      if (GET_CODE (operands[i]) == SUBREG)\n+\t{\n+\t  tmp = SUBREG_REG (operands[i]);\n+\t  gcc_assert (GET_MODE (operands[i]) == GET_MODE (tmp));\n+\t  operands[i] = tmp;\n+\t}\n+    }\n+\n+  /* Make sure there is no dependency between the individual loads.  */\n+  if (load && REGNO (operands[0]) == REGNO (base))\n+    return false; /* RAW.  */\n+\n+  if (load && REGNO (operands[0]) == REGNO (operands[1]))\n+    return false; /* WAW.  */\n+\n+  /* Make sure the instructions are ordered with lower memory access first.  */\n+  if (offsets[0] > offsets[1])\n+    {\n+      gap = offsets[0] - offsets[1];\n+      offset = offsets[1];\n+\n+      /* Swap the instructions such that lower memory is accessed first.  */\n+      std::swap (operands[0], operands[1]);\n+      std::swap (operands[2], operands[3]);\n+    }\n+  else\n+    {\n+      gap = offsets[1] - offsets[0];\n+      offset = offsets[0];\n+    }\n+\n+  /* Make sure accesses are to consecutive memory locations.  */\n+  if (gap != 4)\n+    return false;\n+\n+  /* Make sure we generate legal instructions.  */\n+  if (operands_ok_ldd_std (operands[0], operands[1], offset))\n+    return true;\n+\n+  if (load && commute)\n+    {\n+      /* Try reordering registers.  */\n+      std::swap (operands[0], operands[1]);\n+      if (operands_ok_ldd_std (operands[0], operands[1], offset))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n #undef TARGET_USE_ANCHORS_FOR_SYMBOL_P\n #define TARGET_USE_ANCHORS_FOR_SYMBOL_P arc_use_anchors_for_symbol_p\n "}, {"sha": "24fcf6e510805a6a0258a4507cf39dda08842f26", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fa2c211f7852b1fe330423f4af096016bb3acbc/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fa2c211f7852b1fe330423f4af096016bb3acbc/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=8fa2c211f7852b1fe330423f4af096016bb3acbc", "patch": "@@ -6363,6 +6363,75 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n   [(set (reg:CC CC_REG) (compare:CC (match_dup 3)\n \t\t\t\t    (ashift:SI (match_dup 1) (match_dup 2))))])\n \n+(define_peephole2 ; std\n+  [(set (match_operand:SI 2 \"memory_operand\" \"\")\n+\t(match_operand:SI 0 \"register_operand\" \"\"))\n+   (set (match_operand:SI 3 \"memory_operand\" \"\")\n+\t(match_operand:SI 1 \"register_operand\" \"\"))]\n+  \"TARGET_LL64\"\n+  [(const_int 0)]\n+{\n+  if (!gen_operands_ldd_std (operands, false, false))\n+    FAIL;\n+  operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n+  operands[2] = adjust_address (operands[2], DImode, 0);\n+  emit_insn (gen_rtx_SET (operands[2], operands[0]));\n+  DONE;\n+})\n+\n+(define_peephole2 ; ldd\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 2 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 1 \"register_operand\" \"\")\n+\t(match_operand:SI 3 \"memory_operand\" \"\"))]\n+  \"TARGET_LL64\"\n+  [(const_int 0)]\n+{\n+  if (!gen_operands_ldd_std (operands, true, false))\n+    FAIL;\n+  operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n+  operands[2] = adjust_address (operands[2], DImode, 0);\n+  emit_insn (gen_rtx_SET (operands[0], operands[2]));\n+  DONE;\n+})\n+\n+;; We require consecutive registers for LDD instruction.  Check if we\n+;; can reorder them and use an LDD.\n+\n+(define_peephole2 ; swap the destination registers of two loads\n+\t\t  ; before a commutative operation.\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 2 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 1 \"register_operand\" \"\")\n+\t(match_operand:SI 3 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 4 \"register_operand\" \"\")\n+\t(match_operator:SI 5 \"commutative_operator\"\n+\t\t\t   [(match_operand 6 \"register_operand\" \"\")\n+\t\t\t    (match_operand 7 \"register_operand\" \"\") ]))]\n+  \"TARGET_LL64\n+   && (((rtx_equal_p (operands[0], operands[6]))\n+\t && (rtx_equal_p (operands[1], operands[7])))\n+\t|| ((rtx_equal_p (operands[0], operands[7]))\n+\t     && (rtx_equal_p (operands[1], operands[6]))))\n+   && (peep2_reg_dead_p (3, operands[0])\n+       || rtx_equal_p (operands[0], operands[4]))\n+   && (peep2_reg_dead_p (3, operands[1])\n+       || rtx_equal_p (operands[1], operands[4]))\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 4) (match_op_dup 5 [(match_dup 6) (match_dup 7)]))]\n+  {\n+    if (!gen_operands_ldd_std (operands, true, true))\n+     {\n+\tFAIL;\n+     }\n+    else\n+     {\n+\toperands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n+\toperands[2] = adjust_address (operands[2], DImode, 0);\n+     }\n+   }\n+)\n+\n ;; include the arc-FPX instructions\n (include \"fpx.md\")\n "}]}