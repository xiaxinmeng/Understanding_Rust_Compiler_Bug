{"sha": "e85ddd991a921f3d0ef10ee2922ad460e04abe01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg1ZGRkOTkxYTkyMWYzZDBlZjEwZWUyOTIyYWQ0NjBlMDRhYmUwMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-05-24T20:57:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-05-24T20:57:23Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1075", "tree": {"sha": "b3e19c010c4f71cf4c3751514b94a782e28fe1dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3e19c010c4f71cf4c3751514b94a782e28fe1dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e85ddd991a921f3d0ef10ee2922ad460e04abe01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e85ddd991a921f3d0ef10ee2922ad460e04abe01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e85ddd991a921f3d0ef10ee2922ad460e04abe01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e85ddd991a921f3d0ef10ee2922ad460e04abe01/comments", "author": null, "committer": null, "parents": [{"sha": "f780d21b21452c0c33c5de633163cb3204a3a1f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f780d21b21452c0c33c5de633163cb3204a3a1f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f780d21b21452c0c33c5de633163cb3204a3a1f8"}], "stats": {"total": 43, "additions": 22, "deletions": 21}, "files": [{"sha": "ae809f13fc2bcf8ec20fbfb5bb787596624a5ed8", "filename": "gcc/reload1.c", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e85ddd991a921f3d0ef10ee2922ad460e04abe01/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e85ddd991a921f3d0ef10ee2922ad460e04abe01/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=e85ddd991a921f3d0ef10ee2922ad460e04abe01", "patch": "@@ -1048,6 +1048,7 @@ reload (first, global, dumpfile)\n \t      for (i = 0; i < n_reloads; i++)\n \t\t{\n \t\t  register enum reg_class *p;\n+\t\t  enum reg_class class = reload_reg_class[i];\n \t\t  int size;\n \t\t  enum machine_mode mode;\n \t\t  int *this_groups;\n@@ -1064,6 +1065,16 @@ reload (first, global, dumpfile)\n \t\t\t  && ! reload_secondary_p[i]))\n   \t\t    continue;\n \n+\t\t  /* Show that a reload register of this class is needed\n+\t\t     in this basic block.  We do not use insn_needs and\n+\t\t     insn_groups because they are overly conservative for\n+\t\t     this purpose.  */\n+\t\t  if (global && ! basic_block_needs[(int) class][this_block])\n+\t\t    {\n+\t\t      basic_block_needs[(int) class][this_block] = 1;\n+\t\t      new_basic_block_needs = 1;\n+\t\t    }\n+\n \t\t  /* Decide which time-of-use to count this reload for.  */\n \t\t  switch (reload_when_needed[i])\n \t\t    {\n@@ -1097,34 +1108,34 @@ reload (first, global, dumpfile)\n \t\t  mode = reload_inmode[i];\n \t\t  if (GET_MODE_SIZE (reload_outmode[i]) > GET_MODE_SIZE (mode))\n \t\t    mode = reload_outmode[i];\n-\t\t  size = CLASS_MAX_NREGS (reload_reg_class[i], mode);\n+\t\t  size = CLASS_MAX_NREGS (class, mode);\n \t\t  if (size > 1)\n \t\t    {\n \t\t      enum machine_mode other_mode, allocate_mode;\n \n \t\t      /* Count number of groups needed separately from\n \t\t\t number of individual regs needed.  */\n-\t\t      this_groups[(int) reload_reg_class[i]]++;\n-\t\t      p = reg_class_superclasses[(int) reload_reg_class[i]];\n+\t\t      this_groups[(int) class]++;\n+\t\t      p = reg_class_superclasses[(int) class];\n \t\t      while (*p != LIM_REG_CLASSES)\n \t\t\tthis_groups[(int) *p++]++;\n \t\t      (*this_total_groups)++;\n \n \t\t      /* Record size and mode of a group of this class.  */\n \t\t      /* If more than one size group is needed,\n \t\t\t make all groups the largest needed size.  */\n-\t\t      if (group_size[(int) reload_reg_class[i]] < size)\n+\t\t      if (group_size[(int) class] < size)\n \t\t\t{\n-\t\t\t  other_mode = group_mode[(int) reload_reg_class[i]];\n+\t\t\t  other_mode = group_mode[(int) class];\n \t\t\t  allocate_mode = mode;\n \n-\t\t\t  group_size[(int) reload_reg_class[i]] = size;\n-\t\t\t  group_mode[(int) reload_reg_class[i]] = mode;\n+\t\t\t  group_size[(int) class] = size;\n+\t\t\t  group_mode[(int) class] = mode;\n \t\t\t}\n \t\t      else\n \t\t\t{\n \t\t\t  other_mode = mode;\n-\t\t\t  allocate_mode = group_mode[(int) reload_reg_class[i]];\n+\t\t\t  allocate_mode = group_mode[(int) class];\n \t\t\t}\n \n \t\t      /* Crash if two dissimilar machine modes both need\n@@ -1134,13 +1145,13 @@ reload (first, global, dumpfile)\n \t\t\t  && other_mode != allocate_mode\n \t\t\t  && ! modes_equiv_for_class_p (allocate_mode,\n \t\t\t\t\t\t\tother_mode,\n-\t\t\t\t\t\t\treload_reg_class[i]))\n+\t\t\t\t\t\t\tclass))\n \t\t\tabort ();\n \t\t    }\n \t\t  else if (size == 1)\n \t\t    {\n-\t\t      this_needs[(int) reload_reg_class[i]] += 1;\n-\t\t      p = reg_class_superclasses[(int) reload_reg_class[i]];\n+\t\t      this_needs[(int) class] += 1;\n+\t\t      p = reg_class_superclasses[(int) class];\n \t\t      while (*p != LIM_REG_CLASSES)\n \t\t\tthis_needs[(int) *p++] += 1;\n \t\t    }\n@@ -1211,16 +1222,6 @@ reload (first, global, dumpfile)\n \t\t    insn_total_groups = MAX (insn_total_groups, 1);\n \t\t}\n \n-\t      /* Update the basic block needs.  */\n-\n-\t      for (i = 0; i < N_REG_CLASSES; i++)\n-\t\tif (global && (insn_needs[i] || insn_groups[i])\n-\t\t    && ! basic_block_needs[i][this_block])\n-\t\t  {\n-\t\t    new_basic_block_needs = 1;\n-\t\t    basic_block_needs[i][this_block] = 1;\n-\t\t  }\n-\n #ifdef SMALL_REGISTER_CLASSES\n \t      /* If this insn stores the value of a function call,\n \t\t and that value is in a register that has been spilled,"}]}