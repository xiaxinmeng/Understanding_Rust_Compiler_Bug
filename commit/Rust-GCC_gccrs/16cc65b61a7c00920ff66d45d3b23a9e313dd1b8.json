{"sha": "16cc65b61a7c00920ff66d45d3b23a9e313dd1b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZjYzY1YjYxYTdjMDA5MjBmZjY2ZDQ1ZDNiMjNhOWUzMTNkZDFiOA==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2019-07-09T07:54:29Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-09T07:54:29Z"}, "message": "[Ada] Elaboration order v4.0 activation\n\nThis patch enables the elaboration order v4.0 as the default elaboration\norder in GNATbind. The previous v3.0 elaboration order is now referred\nto as the \"legacy elaboration order mechanism\" and is available using\nbinder switch -H.\n\n2019-07-09  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* bindo.adb: Remove with and use clauses for Debug.  Add with\n\tand use clauses for Opt.\n\t(Find_Elaboration_Order): Enable the v4.0 elaboration order. The\n\tv3.0 mechanism is now available under binder switch -H.\n\t* bindusg.adb (Display): Enable switch -H.\n\t* debug.adb: Free compiler switch -gnatd_G.  Free binder switch\n\t-d_N.\n\t* sem_elab.adb: Update the section on switches to remove\n\t-gnatd_G.\n\t(Invocation_Graph_Recording_OK): The invocation graph is now\n\tunconditionally recorded in ALI files.\n\t* switch-b.adb (Scan_Binder_Switches): Scan switch -H.\n\t* doc/gnat_ugn/building_executable_programs_with_gnat.rst:\n\tUpdate the documentation on compiler switches related to\n\telaboration.  Update the documentation on binder switches to\n\tinclude switch -H.\n\t* doc/gnat_ugn/elaboration_order_handling_in_gnat.rst: Update\n\tthe documentation on elaboration order handling in GNAT.\n\t* gnat_ugn.texi: Regenerate.\n\nFrom-SVN: r273280", "tree": {"sha": "f81c44045c09863a44e70504872ec7c148f000f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f81c44045c09863a44e70504872ec7c148f000f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fb95bfcc8138378d4e5786c67f5eb49b84a54683", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb95bfcc8138378d4e5786c67f5eb49b84a54683", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb95bfcc8138378d4e5786c67f5eb49b84a54683"}], "stats": {"total": 2888, "additions": 1150, "deletions": 1738}, "files": [{"sha": "738be6128a65adc8aaec8f2d3fba8baa1da2423c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=16cc65b61a7c00920ff66d45d3b23a9e313dd1b8", "patch": "@@ -1,3 +1,25 @@\n+2019-07-09  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* bindo.adb: Remove with and use clauses for Debug.  Add with\n+\tand use clauses for Opt.\n+\t(Find_Elaboration_Order): Enable the v4.0 elaboration order. The\n+\tv3.0 mechanism is now available under binder switch -H.\n+\t* bindusg.adb (Display): Enable switch -H.\n+\t* debug.adb: Free compiler switch -gnatd_G.  Free binder switch\n+\t-d_N.\n+\t* sem_elab.adb: Update the section on switches to remove\n+\t-gnatd_G.\n+\t(Invocation_Graph_Recording_OK): The invocation graph is now\n+\tunconditionally recorded in ALI files.\n+\t* switch-b.adb (Scan_Binder_Switches): Scan switch -H.\n+\t* doc/gnat_ugn/building_executable_programs_with_gnat.rst:\n+\tUpdate the documentation on compiler switches related to\n+\telaboration.  Update the documentation on binder switches to\n+\tinclude switch -H.\n+\t* doc/gnat_ugn/elaboration_order_handling_in_gnat.rst: Update\n+\tthe documentation on elaboration order handling in GNAT.\n+\t* gnat_ugn.texi: Regenerate.\n+\n 2019-07-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* repinfo.adb (List_Entities): Disregard formals altogether."}, {"sha": "519887d130d49fd46df079803cc6e25f7e56e8a5", "filename": "gcc/ada/bindo.adb", "status": "modified", "additions": 5, "deletions": 28, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8/gcc%2Fada%2Fbindo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8/gcc%2Fada%2Fbindo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo.adb?ref=16cc65b61a7c00920ff66d45d3b23a9e313dd1b8", "patch": "@@ -24,7 +24,7 @@\n ------------------------------------------------------------------------------\n \n with Binde;\n-with Debug; use Debug;\n+with Opt;   use Opt;\n \n with Bindo.Elaborators;\n use  Bindo.Elaborators;\n@@ -426,9 +426,7 @@ package body Bindo is\n    --    Units and routines of interest:\n    --      Bindo.Elaborators\n    --      Elaborate_Library_Graph\n-   --      Elaborate_Units_Common\n-   --      Elaborate_Units_Dynamic\n-   --      Elaborate_Units_Static\n+   --      Elaborate_Units\n    --\n    --  * Invalid invocation graph\n    --\n@@ -490,40 +488,19 @@ package body Bindo is\n       Main_Lib_File : File_Name_Type)\n    is\n    begin\n-      --  ??? Enable the following code when switching from the old to the new\n-      --  elaboration-order mechanism.\n-\n       --  Use the library graph and heuristic-based elaboration order when\n       --  switch -H (legacy elaboration-order mode enabled).\n \n-      --  if Legacy_Elaboration_Order then\n-      --     Binde.Find_Elab_Order (Order, Main_Lib_File);\n+      if Legacy_Elaboration_Order then\n+         Binde.Find_Elab_Order (Order, Main_Lib_File);\n \n       --  Otherwise use the invocation and library-graph-based elaboration\n       --  order.\n \n-      --  else\n-      --     Invocation_And_Library_Graph_Elaborators.Elaborate_Units\n-      --       (Order         => Order,\n-      --        Main_Lib_File => Main_Lib_File);\n-      --  end if;\n-\n-      --  ??? Remove the following code when switching from the old to the new\n-      --  elaboration-order mechanism.\n-\n-      --  Use the invocation and library-graph-based elaboration order when\n-      --  switch -d_N (new bindo order) is in effect.\n-\n-      if Debug_Flag_Underscore_NN then\n+      else\n          Invocation_And_Library_Graph_Elaborators.Elaborate_Units\n            (Order         => Order,\n             Main_Lib_File => Main_Lib_File);\n-\n-      --  Otherwise use the library-graph and heuristic-based elaboration\n-      --  order.\n-\n-      else\n-         Binde.Find_Elab_Order (Order, Main_Lib_File);\n       end if;\n    end Find_Elaboration_Order;\n "}, {"sha": "0207479c03bb0a3a9fc37eda9e23b6a5cececdb5", "filename": "gcc/ada/bindusg.adb", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8/gcc%2Fada%2Fbindusg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8/gcc%2Fada%2Fbindusg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindusg.adb?ref=16cc65b61a7c00920ff66d45d3b23a9e313dd1b8", "patch": "@@ -143,13 +143,10 @@ package body Bindusg is\n       Write_Line\n         (\"  -h        Output this usage (help) information\");\n \n-      --  ??? Enable the following code when switching from the old to the new\n-      --  elaboration-order mechanism.\n-\n       --  Line for -H switch\n \n-      --  Write_Line\n-      --    (\"  -H        Legacy elaboration-order model enabled\");\n+      Write_Line\n+        (\"  -H        Legacy elaboration order model enabled\");\n \n       --  Lines for -I switch\n "}, {"sha": "a4ff1768bfc566f596f22e9f8bbf40f96b424d17", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=16cc65b61a7c00920ff66d45d3b23a9e313dd1b8", "patch": "@@ -178,7 +178,7 @@ package body Debug is\n    --  d_D\n    --  d_E\n    --  d_F  Encode full invocation paths in ALI files\n-   --  d_G  Encode invocation graph in ALI files\n+   --  d_G\n    --  d_H\n    --  d_I\n    --  d_J\n@@ -388,7 +388,7 @@ package body Debug is\n    --  d_K\n    --  d_L  Output library graph\n    --  d_M\n-   --  d_N  New bindo order\n+   --  d_N\n    --  d_O\n    --  d_P  Output cycle paths\n    --  d_Q\n@@ -1001,9 +1001,6 @@ package body Debug is\n    --       an external target, offering additional information to GNATBIND for\n    --       purposes of error diagnostics.\n \n-   --  d_G  The compiler encodes the invocation graph of a unit in its ALI\n-   --       file.\n-\n    --  d_L  Output trace information on elaboration checking. This debug switch\n    --       causes output to be generated showing each call or instantiation as\n    --       it is checked, and the progress of the recursive trace through\n@@ -1164,8 +1161,6 @@ package body Debug is\n    --  d_L  GNATBIND outputs the contents of the library graph in textual\n    --       format to standard output.\n \n-   --  d_N  GNATBIND utilizes the elaboration order provided by bindo\n-\n    --  d_P  GNATBIND outputs the cycle paths to standard output\n \n    --  d_T  GNATBIND outputs trace information of elaboration order and cycle"}, {"sha": "98c3e165ba251d9520d793f813fcfbc26615f13b", "filename": "gcc/ada/doc/gnat_ugn/building_executable_programs_with_gnat.rst", "status": "modified", "additions": 41, "deletions": 25, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst?ref=16cc65b61a7c00920ff66d45d3b23a9e313dd1b8", "patch": "@@ -1836,7 +1836,8 @@ Alphabetical List of All Switches\n .. index:: -gnatE  (gcc)\n \n :switch:`-gnatE`\n-  Full dynamic elaboration checks.\n+  Dynamic elaboration checking mode enabled. For further details see\n+  :ref:`Elaboration_Order_Handling_in_GNAT`.\n \n \n .. index:: -gnatf  (gcc)\n@@ -1878,8 +1879,9 @@ Alphabetical List of All Switches\n .. index:: -gnatH  (gcc)\n \n :switch:`-gnatH`\n-  Legacy elaboration-checking mode enabled. When this switch is in effect, the\n-  pre-18.x access-before-elaboration model becomes the de facto model.\n+  Legacy elaboration-checking mode enabled. When this switch is in effect,\n+  the pre-18.x access-before-elaboration model becomes the de facto model.\n+  For further details see :ref:`Elaboration_Order_Handling_in_GNAT`.\n \n \n .. index:: -gnati  (gcc)\n@@ -1935,7 +1937,8 @@ Alphabetical List of All Switches\n   - Select statements\n   - Synchronous task suspension\n \n-  and does not emit compile-time diagnostics or run-time checks.\n+  and does not emit compile-time diagnostics or run-time checks. For further\n+  details see :ref:`Elaboration_Order_Handling_in_GNAT`.\n \n \n .. index:: -gnatk  (gcc)\n@@ -6368,7 +6371,9 @@ be presented in subsequent sections.\n .. index:: -f  (gnatbind)\n \n :switch:`-f{elab-order}`\n-  Force elaboration order.\n+  Force elaboration order. For further details see :ref:`Elaboration_Control`\n+  and :ref:`Elaboration_Order_Handling_in_GNAT`.\n+\n \n .. index:: -F  (gnatbind)\n \n@@ -6388,15 +6393,22 @@ be presented in subsequent sections.\n   Output usage (help) information.\n \n \n-  .. index:: -H32  (gnatbind)\n+.. index:: -H  (gnatbind)\n+\n+:switch:`-H`\n+  Legacy elaboration order model enabled. For further details see\n+  :ref:`Elaboration_Order_Handling_in_GNAT`.\n+\n+\n+.. index:: -H32  (gnatbind)\n \n :switch:`-H32`\n   Use 32-bit allocations for ``__gnat_malloc`` (and thus for access types).\n   For further details see :ref:`Dynamic_Allocation_Control`.\n \n \n-  .. index:: -H64  (gnatbind)\n-  .. index:: __gnat_malloc\n+.. index:: -H64  (gnatbind)\n+.. index:: __gnat_malloc\n \n :switch:`-H64`\n   Use 64-bit allocations for ``__gnat_malloc`` (and thus for access types).\n@@ -6816,7 +6828,7 @@ Elaboration Control\n ^^^^^^^^^^^^^^^^^^^\n \n The following switches provide additional control over the elaboration\n-order. For full details see :ref:`Elaboration_Order_Handling_in_GNAT`.\n+order. For further details see :ref:`Elaboration_Order_Handling_in_GNAT`.\n \n \n .. index:: -f  (gnatbind)\n@@ -6860,28 +6872,32 @@ order. For full details see :ref:`Elaboration_Order_Handling_in_GNAT`.\n   ignored.\n \n \n-  .. index:: -p  (gnatbind)\n+.. index:: -p  (gnatbind)\n \n :switch:`-p`\n-  Normally the binder attempts to choose an elaboration order that is\n-  likely to minimize the likelihood of an elaboration order error resulting\n-  in raising a ``Program_Error`` exception. This switch reverses the\n-  action of the binder, and requests that it deliberately choose an order\n-  that is likely to maximize the likelihood of an elaboration error.\n-  This is useful in ensuring portability and avoiding dependence on\n-  accidental fortuitous elaboration ordering.\n-\n-  Normally it only makes sense to use the :switch:`-p`\n-  switch if dynamic\n+  Pessimistic elaboration order\n+\n+  This switch is only applicable to the pre-20.x legacy elaboration models.\n+  The post-20.x elaboration model uses a more informed approach of ordering\n+  the units.\n+\n+  Normally the binder attempts to choose an elaboration order that is likely to\n+  minimize the likelihood of an elaboration order error resulting in raising a\n+  ``Program_Error`` exception. This switch reverses the action of the binder,\n+  and requests that it deliberately choose an order that is likely to maximize\n+  the likelihood of an elaboration error. This is useful in ensuring\n+  portability and avoiding dependence on accidental fortuitous elaboration\n+  ordering.\n+\n+  Normally it only makes sense to use the :switch:`-p` switch if dynamic\n   elaboration checking is used (:switch:`-gnatE` switch used for compilation).\n   This is because in the default static elaboration mode, all necessary\n   ``Elaborate`` and ``Elaborate_All`` pragmas are implicitly inserted.\n-  These implicit pragmas are still respected by the binder in\n-  :switch:`-p` mode, so a\n-  safe elaboration order is assured.\n+  These implicit pragmas are still respected by the binder in :switch:`-p`\n+  mode, so a safe elaboration order is assured.\n \n-  Note that :switch:`-p` is not intended for\n-  production use; it is more for debugging/experimental use.\n+  Note that :switch:`-p` is not intended for production use; it is more for\n+  debugging/experimental use.\n \n .. _Output_Control:\n "}, {"sha": "160dbdf5ebfa182c10e8f4328dff43453d2b89ad", "filename": "gcc/ada/doc/gnat_ugn/elaboration_order_handling_in_gnat.rst", "status": "modified", "additions": 533, "deletions": 872, "changes": 1405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Felaboration_order_handling_in_gnat.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Felaboration_order_handling_in_gnat.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Felaboration_order_handling_in_gnat.rst?ref=16cc65b61a7c00920ff66d45d3b23a9e313dd1b8", "patch": "@@ -50,9 +50,14 @@ Elaboration code is executed as follows:\n \n In addition to the Ada terminology, this appendix defines the following terms:\n \n+* *Invocation*\n+\n+  The act of calling a subprogram, instantiating a generic, or activating a\n+  task.\n+\n * *Scenario*\n \n-  A construct that is elaborated or executed by elaboration code is referred to\n+  A construct that is elaborated or invoked by elaboration code is referred to\n   as an *elaboration scenario* or simply a **scenario**. GNAT recognizes the\n   following scenarios:\n \n@@ -102,7 +107,7 @@ Elaboration code may appear in two distinct contexts:\n   In the example above, the call to ``Server.Func`` is an elaboration scenario\n   because it appears at the library level of package ``Client``. Note that the\n   declaration of package ``Nested`` is ignored according to the definition\n-  given above. As a result, the call to ``Server.Func`` will be executed when\n+  given above. As a result, the call to ``Server.Func`` will be invoked when\n   the spec of unit ``Client`` is elaborated.\n \n * *Package body statements*\n@@ -124,7 +129,7 @@ Elaboration code may appear in two distinct contexts:\n \n   In the example above, the call to ``Proc`` is an elaboration scenario because\n   it appears within the statement sequence of package body ``Client``. As a\n-  result, the call to ``Proc`` will be executed when the body of ``Client`` is\n+  result, the call to ``Proc`` will be invoked when the body of ``Client`` is\n   elaborated.\n \n .. _Elaboration_Order:\n@@ -137,19 +142,19 @@ executed is referred to as **elaboration order**.\n \n Within a single unit, elaboration code is executed in sequential order.\n \n-::\n+  ::\n \n-   package body Client is\n-      Result : ... := Server.Func;\n+     package body Client is\n+        Result : ... := Server.Func;\n \n-      procedure Proc is\n-         package Inst is new Server.Gen;\n-      begin\n-         Inst.Eval (Result);\n-      end Proc;\n-   begin\n-      Proc;\n-   end Client;\n+        procedure Proc is\n+           package Inst is new Server.Gen;\n+        begin\n+           Inst.Eval (Result);\n+        end Proc;\n+     begin\n+        Proc;\n+     end Client;\n \n In the example above, the elaboration order within package body ``Client`` is\n as follows:\n@@ -173,52 +178,56 @@ factors:\n \n * |withed| units\n \n+* parent units\n+\n * purity of units\n \n * preelaborability of units\n \n * presence of elaboration control pragmas\n \n+* invocations performed in elaboration code\n+\n A program may have several elaboration orders depending on its structure.\n \n-::\n+  ::\n \n-   package Server is\n-      function Func (Index : Integer) return Integer;\n-   end Server;\n+     package Server is\n+        function Func (Index : Integer) return Integer;\n+     end Server;\n \n-::\n+  ::\n \n-   package body Server is\n-      Results : array (1 .. 5) of Integer := (1, 2, 3, 4, 5);\n+     package body Server is\n+        Results : array (1 .. 5) of Integer := (1, 2, 3, 4, 5);\n \n-      function Func (Index : Integer) return Integer is\n-      begin\n-         return Results (Index);\n-      end Func;\n-   end Server;\n+        function Func (Index : Integer) return Integer is\n+        begin\n+           return Results (Index);\n+        end Func;\n+     end Server;\n \n-::\n+  ::\n \n-   with Server;\n-   package Client is\n-      Val : constant Integer := Server.Func (3);\n-   end Client;\n+     with Server;\n+     package Client is\n+        Val : constant Integer := Server.Func (3);\n+     end Client;\n \n-::\n+  ::\n \n-   with Client;\n-   procedure Main is begin null; end Main;\n+     with Client;\n+     procedure Main is begin null; end Main;\n \n The following elaboration order exhibits a fundamental problem referred to as\n *access-before-elaboration* or simply **ABE**.\n \n-::\n+  ::\n \n-   spec of Server\n-   spec of Client\n-   body of Server\n-   body of Main\n+     spec of Server\n+     spec of Client\n+     body of Server\n+     body of Main\n \n The elaboration of ``Server``'s spec materializes function ``Func``, making it\n callable. The elaboration of ``Client``'s spec elaborates the declaration of\n@@ -236,19 +245,20 @@ vein as index or null exclusion checks. A failed ABE check raises exception\n The following elaboration order avoids the ABE problem and the program can be\n successfully elaborated.\n \n-::\n+  ::\n \n-   spec of Server\n-   body of Server\n-   spec of Client\n-   body of Main\n+     spec of Server\n+     body of Server\n+     spec of Client\n+     body of Main\n \n Ada states that a total elaboration order must exist, but it does not define\n what this order is. A compiler is thus tasked with choosing a suitable\n elaboration order which satisfies the dependencies imposed by |with| clauses,\n-unit categorization, and elaboration control pragmas. Ideally an order which\n-avoids ABE problems should be chosen, however a compiler may not always find\n-such an order due to complications with respect to control and data flow.\n+unit categorization, elaboration control pragmas, and invocations performed in\n+elaboration code. Ideally an order that avoids ABE problems should be chosen,\n+however a compiler may not always find such an order due to complications with\n+respect to control and data flow.\n \n .. _Checking_the_Elaboration_Order:\n \n@@ -268,7 +278,7 @@ provides three lines of defense:\n * *Dynamic semantics*\n \n   Dynamic checks are performed at run time, to ensure that a target is\n-  elaborated prior to a scenario that executes it, thus avoiding ABE problems.\n+  elaborated prior to a scenario that invokes it, thus avoiding ABE problems.\n   A failed run-time check raises exception ``Program_Error``. The following\n   restrictions apply:\n \n@@ -290,8 +300,7 @@ provides three lines of defense:\n   The restrictions above can be summarized by the following rule:\n \n   *If a target has a body, then this body must be elaborated prior to the\n-  execution of the scenario that invokes, instantiates, or activates the\n-  target.*\n+  scenario that invokes the target.*\n \n * *Elaboration control*\n \n@@ -346,7 +355,7 @@ the desired elaboration order and avoiding ABE problems altogether.\n \n   Pragma ``Elaborate_Body`` requires that the body of a unit is elaborated\n   immediately after its spec. This restriction guarantees that no client\n-  scenario can execute a server target before the target body has been\n+  scenario can invoke a server target before the target body has been\n   elaborated because the spec and body are effectively \"glued\" together.\n \n   ::\n@@ -601,24 +610,53 @@ elaboration order and to diagnose elaboration problems.\n \n * *Dynamic elaboration model*\n \n-  This is the most permissive of the three elaboration models. When the\n-  dynamic model is in effect, GNAT assumes that all code within all units in\n-  a partition is elaboration code. GNAT performs very few diagnostics and\n-  generates run-time checks to verify the elaboration order of a program. This\n-  behavior is identical to that specified by the Ada Reference Manual. The\n-  dynamic model is enabled with compiler switch :switch:`-gnatE`.\n+  This is the most permissive of the three elaboration models and emulates the\n+  behavior specified by the Ada Reference Manual. When the dynamic model is in\n+  effect, GNAT makes the following assumptions:\n+\n+  - All code within all units in a partition is considered to be elaboration\n+    code.\n+\n+  - Some of the invocations in elaboration code may not take place at runtime\n+    due to conditional execution.\n+\n+  GNAT performs extensive diagnostics on a unit-by-unit basis for all scenarios\n+  that invoke internal targets. In addition, GNAT generates run-time checks for\n+  all external targets and for all scenarios that may exhibit ABE problems.\n+\n+  The elaboration order is obtained by honoring all |with| clauses, purity and\n+  preelaborability of units, and elaboration control pragmas. The dynamic model\n+  attempts to take all invocations in elaboration code into account. If an\n+  invocation leads to a circularity, GNAT ignores the invocation based on the\n+  assumptions stated above. An order obtained using the dynamic model may fail\n+  an ABE check at runtime when GNAT ignored an invocation.\n+\n+  The dynamic model is enabled with compiler switch :switch:`-gnatE`.\n \n .. index:: Static elaboration model\n \n * *Static elaboration model*\n \n   This is the middle ground of the three models. When the static model is in\n-  effect, GNAT performs extensive diagnostics on a unit-by-unit basis for all\n-  scenarios that elaborate or execute internal targets. GNAT also generates\n-  run-time checks for all external targets and for all scenarios that may\n-  exhibit ABE problems. Finally, GNAT installs implicit ``Elaborate`` and\n-  ``Elaborate_All`` pragmas for server units based on the dependencies of\n-  client units. The static model is the default model in GNAT.\n+  effect, GNAT makes the following assumptions:\n+\n+  - Only code at the library level and in package body statements within all\n+    units in a partition is considered to be elaboration code.\n+\n+  - All invocations in elaboration will take place at runtime, regardless of\n+    conditional execution.\n+\n+  GNAT performs extensive diagnostics on a unit-by-unit basis for all scenarios\n+  that invoke internal targets. In addition, GNAT generates run-time checks for\n+  all external targets and for all scenarios that may exhibit ABE problems.\n+\n+  The elaboration order is obtained by honoring all |with| clauses, purity and\n+  preelaborability of units, presence of elaboration control pragmas, and all\n+  invocations in elaboration code. An order obtained using the static model is\n+  guaranteed to be ABE problem-free, excluding dispatching calls and\n+  access-to-subprogram types.\n+\n+  The static model is the default model in GNAT.\n \n .. index:: SPARK elaboration model\n \n@@ -627,830 +665,454 @@ elaboration order and to diagnose elaboration problems.\n   This is the most conservative of the three models and enforces the SPARK\n   rules of elaboration as defined in the SPARK Reference Manual, section 7.7.\n   The SPARK model is in effect only when a scenario and a target reside in a\n-  region subject to SPARK_Mode On, otherwise the dynamic or static model is in\n-  effect.\n+  region subject to ``SPARK_Mode On``, otherwise the dynamic or static model\n+  is in effect.\n \n-.. index:: Legacy elaboration model\n+  The SPARK model is enabled with compiler switch :switch:`-gnatd.v`.\n \n-* *Legacy elaboration model*\n+.. index:: Legacy elaboration models\n+\n+* *Legacy elaboration models*\n \n   In addition to the three elaboration models outlined above, GNAT provides the\n-  elaboration model of pre-18.x versions referred to as `legacy elaboration\n-  model`. The legacy elaboration model is enabled with compiler switch\n-  :switch:`-gnatH`.\n+  following legacy models:\n+\n+  - `Legacy elaboration-checking model` available in pre-18.x versions of GNAT.\n+    This model is enabled with compiler switch :switch:`-gnatH`.\n+\n+  - `Legacy elaboration-order model` available in pre-20.x versions of GNAT.\n+    This model is enabled with binder switch :switch:`-H`.\n \n .. index:: Relaxed elaboration mode\n \n The dynamic, legacy, and static models can be relaxed using compiler switch\n :switch:`-gnatJ`, making them more permissive. Note that in this mode, GNAT\n may not diagnose certain elaboration issues or install run-time checks.\n \n-.. _Common_Elaboration_Model_Traits\":\n+.. _Mixing_Elaboration_Models:\n \n-Common Elaboration-model Traits\n-===============================\n+Mixing Elaboration Models\n+=========================\n \n-All three GNAT models are able to detect elaboration problems related to\n-dispatching calls and a particular kind of ABE referred to as *guaranteed ABE*.\n+It is possible to mix units compiled with a different elaboration model,\n+however the following rules must be observed:\n \n-* *Dispatching calls*\n+* A client unit compiled with the dynamic model can only |with| a server unit\n+  that meets at least one of the following criteria:\n \n-  GNAT installs run-time checks for each primitive subprogram of each tagged\n-  type defined in a partition on the assumption that a dispatching call\n-  invoked at elaboration time will execute one of these primitives. As a\n-  result, a dispatching call that executes a primitive whose body has not\n-  been elaborated yet will raise exception ``Program_Error`` at run time. The\n-  checks can be suppressed using pragma ``Suppress (Elaboration_Check)``.\n+  - The server unit is compiled with the dynamic model.\n \n-* *Guaranteed ABE*\n+  - The server unit is a GNAT implementation unit from the ``Ada``, ``GNAT``,\n+    ``Interfaces``, or ``System`` hierarchies.\n \n-  A guaranteed ABE arises when the body of a target is not elaborated early\n-  enough, and causes all scenarios that directly execute the target to fail.\n+  - The server unit has pragma ``Pure`` or ``Preelaborate``.\n \n-  ::\n+  - The client unit has an explicit ``Elaborate_All`` pragma for the server\n+    unit.\n \n-     package body Guaranteed_ABE is\n-        function ABE return Integer;\n+These rules ensure that elaboration checks are not omitted. If the rules are\n+violated, the binder emits a warning:\n \n-        Val : constant Integer := ABE;\n+  ::\n \n-        function ABE return Integer is\n-        begin\n-           ...\n-        end ABE;\n-     end Guaranteed_ABE;\n+     warning: \"x.ads\" has dynamic elaboration checks and with's\n+     warning:   \"y.ads\" which has static elaboration checks\n \n-  In the example above, the elaboration of ``Guaranteed_ABE``'s body elaborates\n-  the declaration of ``Val``. This invokes function ``ABE``, however the body\n-  of ``ABE`` has not been elaborated yet. GNAT emits similar diagnostics in all\n-  three models:\n+The warnings can be suppressed by binder switch :switch:`-ws`.\n \n-  ::\n+.. _ABE_Diagnostics:\n \n-      1. package body Guaranteed_ABE is\n-      2.    function ABE return Integer;\n-      3.\n-      4.    Val : constant Integer := ABE;\n-                                      |\n-         >>> warning: cannot call \"ABE\" before body seen\n-         >>> warning: Program_Error will be raised at run time\n+ABE Diagnostics\n+===============\n \n-      5.\n-      6.    function ABE return Integer is\n-      7.    begin\n-      8.       ...\n-      9.    end ABE;\n-      10. end Guaranteed_ABE;\n+GNAT performs extensive diagnostics on a unit-by-unit basis for all scenarios\n+that invoke internal targets, regardless of whether the dynamic, SPARK, or\n+static model is in effect.\n \n Note that GNAT emits warnings rather than hard errors whenever it encounters an\n elaboration problem. This is because the elaboration model in effect may be too\n-conservative, or a particular scenario may not be elaborated or executed due to\n-data and control flow. The warnings can be suppressed selectively with ``pragma\n-Warnigns (Off)`` or globally with compiler switch :switch:`-gnatwL`.\n-\n-.. _Dynamic_Elaboration_Model_in_GNAT:\n-\n-Dynamic Elaboration Model in GNAT\n-=================================\n-\n-The dynamic model assumes that all code within all units in a partition is\n-elaboration code. As a result, run-time checks are installed for each scenario\n-regardless of whether the target is internal or external. The checks can be\n-suppressed using pragma ``Suppress (Elaboration_Check)``. This behavior is\n-identical to that specified by the Ada Reference Manual. The following example\n-showcases run-time checks installed by GNAT to verify the elaboration state of\n-package ``Dynamic_Model``.\n-\n-::\n-\n-   with Server;\n-   package body Dynamic_Model is\n-      procedure API is\n-      begin\n-         ...\n-      end API;\n-\n-      <check that the body of Server.Gen is elaborated>\n-      package Inst is new Server.Gen;\n+conservative, or a particular scenario may not be invoked due conditional\n+execution. The warnings can be suppressed selectively with ``pragma Warnings\n+(Off)`` or globally with compiler switch :switch:`-gnatwL`.\n \n-      T : Server.Task_Type;\n+A *guaranteed ABE* arises when the body of a target is not elaborated early\n+enough, and causes *all* scenarios that directly invoke the target to fail.\n \n-   begin\n-      <check that the body of Server.Task_Type is elaborated>\n-\n-      <check that the body of Server.Proc is elaborated>\n-      Server.Proc;\n-   end Dynamic_Model;\n-\n-The checks verify that the body of a target has been successfully elaborated\n-before a scenario activates, calls, or instantiates a target.\n-\n-Note that no scenario within package ``Dynamic_Model`` calls procedure ``API``.\n-In fact, procedure ``API`` may not be invoked by elaboration code within the\n-partition, however the dynamic model assumes that this can happen.\n+  ::\n \n-The dynamic model emits very few diagnostics, but can make suggestions on\n-missing ``Elaborate`` and ``Elaborate_All`` pragmas for library-level\n-scenarios. This information is available when compiler switch :switch:`-gnatel`\n-is in effect.\n+     package body Guaranteed_ABE is\n+        function ABE return Integer;\n \n-::\n+        Val : constant Integer := ABE;\n \n-   1. with Server;\n-   2. package body Dynamic_Model is\n-   3.    Val : constant Integer := Server.Func;\n-                                         |\n-      >>> info: call to \"Func\" during elaboration\n-      >>> info: missing pragma \"Elaborate_All\" for unit \"Server\"\n+        function ABE return Integer is\n+        begin\n+          ...\n+        end ABE;\n+     end Guaranteed_ABE;\n \n-   4. end Dynamic_Model;\n+In the example above, the elaboration of ``Guaranteed_ABE``'s body elaborates\n+the declaration of ``Val``. This invokes function ``ABE``, however the body of\n+``ABE`` has not been elaborated yet. GNAT emits the following diagnostic:\n \n-.. _Static_Elaboration_Model_in_GNAT:\n+  ::\n \n-Static Elaboration Model in GNAT\n-================================\n+     4.    Val : constant Integer := ABE;\n+                                     |\n+        >>> warning: cannot call \"ABE\" before body seen\n+        >>> warning: Program_Error will be raised at run time\n \n-In contrast to the dynamic model, the static model is more precise in its\n-analysis of elaboration code. The model makes a clear distinction between\n-internal and external targets, and resorts to different diagnostics and\n-run-time checks based on the nature of the target.\n+A *conditional ABE* arises when the body of a target is not elaborated early\n+enough, and causes *some* scenarios that directly invoke the target to fail.\n \n-* *Internal targets*\n+  ::\n \n-  The static model performs extensive diagnostics on scenarios which elaborate\n-  or execute internal targets. The warnings resulting from these diagnostics\n-  are enabled by default, but can be suppressed selectively with ``pragma\n-  Warnings (Off)`` or globally with compiler switch :switch:`-gnatwL`.\n+      1. package body Conditional_ABE is\n+      2.    procedure Force_Body is null;\n+      3.\n+      4.    generic\n+      5.       with function Func return Integer;\n+      6.    package Gen is\n+      7.       Val : constant Integer := Func;\n+      8.    end Gen;\n+      9.\n+     10.    function ABE return Integer;\n+     11.\n+     12.    function Cause_ABE return Boolean is\n+     13.       package Inst is new Gen (ABE);\n+     14.    begin\n+     15.       ...\n+     16.    end Cause_ABE;\n+     17.\n+     18.    Val : constant Boolean := Cause_ABE;\n+     19.\n+     20.    function ABE return Integer is\n+     21.    begin\n+     22.       ...\n+     23.    end ABE;\n+     24.\n+     25.    Safe : constant Boolean := Cause_ABE;\n+     26. end Conditional_ABE;\n+\n+In the example above, the elaboration of package body ``Conditional_ABE``\n+elaborates the declaration of ``Val``. This invokes function ``Cause_ABE``,\n+which instantiates generic unit ``Gen`` as ``Inst``. The elaboration of\n+``Inst`` invokes function ``ABE``, however the body of ``ABE`` has not been\n+elaborated yet. GNAT emits the following diagnostic:\n \n   ::\n \n-      1. package body Static_Model is\n-      2.    generic\n-      3.       with function Func return Integer;\n-      4.    package Gen is\n-      5.       Val : constant Integer := Func;\n-      6.    end Gen;\n-      7.\n-      8.    function ABE return Integer;\n-      9.\n-     10.    function Cause_ABE return Boolean is\n-     11.       package Inst is new Gen (ABE);\n+     13.       package Inst is new Gen (ABE);\n                |\n-         >>> warning: in instantiation at line 5\n+         >>> warning: in instantiation at line 7\n          >>> warning: cannot call \"ABE\" before body seen\n          >>> warning: Program_Error may be raised at run time\n-         >>> warning:   body of unit \"Static_Model\" elaborated\n-         >>> warning:   function \"Cause_ABE\" called at line 16\n-         >>> warning:   function \"ABE\" called at line 5, instance at line 11\n-\n-     12.    begin\n-     13.       ...\n-     14.    end Cause_ABE;\n-     15.\n-     16.    Val : constant Boolean := Cause_ABE;\n-     17.\n-     18.    function ABE return Integer is\n-     19.    begin\n-     20.       ...\n-     21.    end ABE;\n-     22. end Static_Model;\n-\n-  The example above illustrates an ABE problem within package ``Static_Model``,\n-  which is hidden by several layers of indirection. The elaboration of package\n-  body ``Static_Model`` elaborates the declaration of ``Val``. This invokes\n-  function ``Cause_ABE``, which instantiates generic unit ``Gen`` as ``Inst``.\n-  The elaboration of ``Inst`` invokes function ``ABE``, however the body of\n-  ``ABE`` has not been elaborated yet.\n-\n-* *External targets*\n-\n-  The static model installs run-time checks to verify the elaboration status\n-  of server targets only when the scenario that elaborates or executes that\n-  target is part of the elaboration code of the client unit. The checks can be\n-  suppressed using pragma ``Suppress (Elaboration_Check)``.\n+         >>> warning:   body of unit \"Conditional_ABE\" elaborated\n+         >>> warning:   function \"Cause_ABE\" called at line 18\n+         >>> warning:   function \"ABE\" called at line 7, instance at line 13\n \n-  ::\n+Note that the same ABE problem does not occur with the elaboration of\n+declaration ``Safe`` because the body of function ``ABE`` has already been\n+elaborated at that point.\n \n-     with Server;\n-     package body Static_Model is\n-        generic\n-           with function Func return Integer;\n-        package Gen is\n-           Val : constant Integer := Func;\n-        end Gen;\n-\n-        function Call_Func return Boolean is\n-           <check that the body of Server.Func is elaborated>\n-           package Inst is new Gen (Server.Func);\n-        begin\n-           ...\n-        end Call_Func;\n-\n-        Val : constant Boolean := Call_Func;\n-     end Static_Model;\n+.. _SPARK_Diagnostics:\n \n-  In the example above, the elaboration of package body ``Static_Model``\n-  elaborates the declaration of ``Val``. This invokes function ``Call_Func``,\n-  which instantiates generic unit ``Gen`` as ``Inst``. The elaboration of\n-  ``Inst`` invokes function ``Server.Func``. Since ``Server.Func`` is an\n-  external target, GNAT installs a run-time check to verify that its body has\n-  been elaborated.\n+SPARK Diagnostics\n+=================\n \n-  In addition to checks, the static model installs implicit ``Elaborate`` and\n-  ``Elaborate_All`` pragmas to guarantee safe elaboration use of server units.\n-  This information is available when compiler switch :switch:`-gnatel` is in\n-  effect.\n+GNAT enforces the SPARK rules of elaboration as defined in the SPARK Reference\n+Manual section 7.7 when compiler switch :switch:`-gnatd.v` is in effect. Note\n+that GNAT emits hard errors whenever it encounters a violation of the SPARK\n+rules.\n \n   ::\n \n-      1. with Server;\n-      2. package body Static_Model is\n-      3.    generic\n-      4.       with function Func return Integer;\n-      5.    package Gen is\n-      6.       Val : constant Integer := Func;\n-      7.    end Gen;\n-      8.\n-      9.    function Call_Func return Boolean is\n-     10.       package Inst is new Gen (Server.Func);\n-               |\n-         >>> info: instantiation of \"Gen\" during elaboration\n-         >>> info: in instantiation at line 6\n-         >>> info: call to \"Func\" during elaboration\n-         >>> info: in instantiation at line 6\n-         >>> info: implicit pragma \"Elaborate_All\" generated for unit \"Server\"\n-         >>> info:   body of unit \"Static_Model\" elaborated\n-         >>> info:   function \"Call_Func\" called at line 15\n-         >>> info:   function \"Func\" called at line 6, instance at line 10\n-\n-     11.    begin\n-     12.       ...\n-     13.    end Call_Func;\n-     14.\n-     15.    Val : constant Boolean := Call_Func;\n-                                      |\n-         >>> info: call to \"Call_Func\" during elaboration\n-\n-     16. end Static_Model;\n-\n-  In the example above, the elaboration of package body ``Static_Model``\n-  elaborates the declaration of ``Val``. This invokes function ``Call_Func``,\n-  which instantiates generic unit ``Gen`` as ``Inst``. The elaboration of\n-  ``Inst`` invokes function ``Server.Func``. Since ``Server.Func`` is an\n-  external target, GNAT installs an implicit ``Elaborate_All`` pragma for unit\n-  ``Server``. The pragma guarantees that both the spec and body of ``Server``,\n-  along with any additional dependencies that ``Server`` may require, are\n-  elaborated prior to the body of ``Static_Model``.\n-\n-.. _SPARK_Elaboration_Model_in_GNAT:\n-\n-SPARK Elaboration Model in GNAT\n-===============================\n-\n-The SPARK model is identical to the static model in its handling of internal\n-targets. The SPARK model, however, requires explicit ``Elaborate`` or\n-``Elaborate_All`` pragmas to be present in the program when a target is\n-external, and compiler switch :switch:`-gnatd.v` is in effect.\n-\n-::\n-\n-   1. with Server;\n-   2. package body SPARK_Model with SPARK_Mode is\n-   3.    Val : constant Integer := Server.Func;\n-                                         |\n-      >>> call to \"Func\" during elaboration in SPARK\n-      >>> unit \"SPARK_Model\" requires pragma \"Elaborate_All\" for \"Server\"\n-      >>>   body of unit \"SPARK_Model\" elaborated\n-      >>>   function \"Func\" called at line 3\n-\n-   4. end SPARK_Model;\n-\n-Legacy Elaboration Model in GNAT\n-================================\n-\n-The legacy elaboration model is provided for compatibility with code bases\n-developed with pre-18.x versions of GNAT. It is similar in functionality to\n-the dynamic and static models of post-18.x version of GNAT, but may differ\n-in terms of diagnostics and run-time checks. The legacy elaboration model is\n-enabled with compiler switch :switch:`-gnatH`.\n+     1. with Server;\n+     2. package body SPARK_Diagnostics with SPARK_Mode is\n+     3.    Val : constant Integer := Server.Func;\n+                                           |\n+        >>> call to \"Func\" during elaboration in SPARK\n+        >>> unit \"SPARK_Diagnostics\" requires pragma \"Elaborate_All\" for \"Server\"\n+        >>>   body of unit \"SPARK_Model\" elaborated\n+        >>>   function \"Func\" called at line 3\n \n-.. _Mixing_Elaboration_Models:\n+     4. end SPARK_Diagnostics;\n \n-Mixing Elaboration Models\n-=========================\n+.. _Elaboration_Circularities:\n \n-It is possible to mix units compiled with a different elaboration model,\n-however the following rules must be observed:\n+Elaboration Circularities\n+=========================\n \n-* A client unit compiled with the dynamic model can only |with| a server unit\n-  that meets at least one of the following criteria:\n+An **elaboration circularity** occurs whenever the elaboration of a set of\n+units enters a deadlocked state, where each unit is waiting for another unit\n+to be elaborated. This situation may be the result of improper use of |with|\n+clauses, elaboration control pragmas, or invocations in elaboration code.\n \n-  - The server unit is compiled with the dynamic model.\n+The following example showcases an elaboration circularity.\n \n-  - The server unit is a GNAT implementation unit from the Ada, GNAT,\n-    Interfaces, or System hierarchies.\n+  ::\n \n-  - The server unit has pragma ``Pure`` or ``Preelaborate``.\n+     with B; pragma Elaborate (B);\n+     package A is\n+     end A;\n \n-  - The client unit has an explicit ``Elaborate_All`` pragma for the server\n-    unit.\n+  ::\n \n-These rules ensure that elaboration checks are not omitted. If the rules are\n-violated, the binder emits a warning:\n+     package B is\n+        procedure Force_Body;\n+     end B;\n \n-::\n+  ::\n \n-   warning: \"x.ads\" has dynamic elaboration checks and with's\n-   warning:   \"y.ads\" which has static elaboration checks\n+     with C;\n+     package body B is\n+        procedure Force_Body is null;\n \n-The warnings can be suppressed by binder switch :switch:`-ws`.\n+        Elab : constant Integer := C.Func;\n+     end B;\n \n-.. _Elaboration_Circularities:\n+  ::\n \n-Elaboration Circularities\n-=========================\n+     package C is\n+        function Func return Integer;\n+     end C;\n \n-If the binder cannot find an acceptable elaboration order, it outputs detailed\n-diagnostics describing an **elaboration circularity**.\n+  ::\n \n-::\n+     with A;\n+     package body C is\n+        function Func return Integer is\n+        begin\n+           ...\n+        end Func;\n+     end C;\n \n-   package Server is\n-      function Func return Integer;\n-   end Server;\n+The binder emits the following diagnostic:\n \n-::\n+  ::\n \n-   with Client;\n-   package body Server is\n-      function Func return Integer is\n-      begin\n-         ...\n-      end Func;\n-   end Server;\n+     error: Elaboration circularity detected\n+     info:\n+     info:    Reason:\n+     info:\n+     info:      unit \"a (spec)\" depends on its own elaboration\n+     info:\n+     info:    Circularity:\n+     info:\n+     info:      unit \"a (spec)\" has with clause and pragma Elaborate for unit \"b (spec)\"\n+     info:      unit \"b (body)\" is in the closure of pragma Elaborate\n+     info:      unit \"b (body)\" invokes a construct of unit \"c (body)\" at elaboration time\n+     info:      unit \"c (body)\" has with clause for unit \"a (spec)\"\n+     info:\n+     info:    Suggestions:\n+     info:\n+     info:      remove pragma Elaborate for unit \"b (body)\" in unit \"a (spec)\"\n+     info:      use the dynamic elaboration model (compiler switch -gnatE)\n \n-::\n+The diagnostic consist of the following sections:\n \n-   with Server;\n-   package Client is\n-      Val : constant Integer := Server.Func;\n-   end Client;\n+* Reason\n \n-::\n+  This section provides a short explanation describing why the set of units\n+  could not be ordered.\n \n-   with Client;\n-   procedure Main is begin null; end Main;\n+* Circularity\n \n-::\n+  This section enumerates the units comprising the deadlocked set, along with\n+  their interdependencies.\n \n-   error: elaboration circularity detected\n-   info:    \"server (body)\" must be elaborated before \"client (spec)\"\n-   info:       reason: implicit Elaborate_All in unit \"client (spec)\"\n-   info:       recompile \"client (spec)\" with -gnatel for full details\n-   info:          \"server (body)\"\n-   info:             must be elaborated along with its spec:\n-   info:          \"server (spec)\"\n-   info:             which is withed by:\n-   info:          \"client (spec)\"\n-   info:    \"client (spec)\" must be elaborated before \"server (body)\"\n-   info:       reason: with clause\n+* Suggestions\n \n-In the example above, ``Client`` must be elaborated prior to ``Main`` by virtue\n-of a |with| clause. The elaboration of ``Client`` invokes ``Server.Func``, and\n-static model generates an implicit ``Elaborate_All`` pragma for ``Server``. The\n-pragma implies that both the spec and body of ``Server``, along with any units\n-they |with|, must be elaborated prior to ``Client``. However, ``Server``'s body\n-|withs| ``Client``, implying that ``Client`` must be elaborated prior to\n-``Server``. The end result is that ``Client`` must be elaborated prior to\n-``Client``, and this leads to a circularity.\n+  This section enumerates various tactics for eliminating the circularity.\n \n .. _Resolving_Elaboration_Circularities:\n \n Resolving Elaboration Circularities\n ===================================\n \n-When faced with an elaboration circularity, a programmer has several options\n-available.\n-\n-* *Fix the program*\n-\n-  The most desirable option from the point of view of long-term maintenance\n-  is to rearrange the program so that the elaboration problems are avoided.\n-  One useful technique is to place the elaboration code into separate child\n-  packages. Another is to move some of the initialization code to explicitly\n-  invoked subprograms, where the program controls the order of initialization\n-  explicitly. Although this is the most desirable option, it may be impractical\n-  and involve too much modification, especially in the case of complex legacy\n-  code.\n-\n-* *Switch to more permissive elaboration model*\n-\n-  If the compilation was performed using the static model, enable the dynamic\n-  model with compiler switch :switch:`-gnatE`. GNAT will no longer generate\n-  implicit ``Elaborate`` and ``Elaborate_All`` pragmas, resulting in a behavior\n-  identical to that specified by the Ada Reference Manual. The binder will\n-  generate an executable program that may or may not raise ``Program_Error``,\n-  and it is the programmer's responsibility to ensure that it does not raise\n-  ``Program_Error``.\n+The most desirable option from the point of view of long-term maintenance is to\n+rearrange the program so that the elaboration problems are avoided. One useful \n+technique is to place the elaboration code into separate child packages. \n+Another is to move some of the initialization code to explicitly invoked \n+subprograms, where the program controls the order of initialization explicitly.\n+Although this is the most desirable option, it may be impractical and involve\n+too much modification, especially in the case of complex legacy code.\n \n-  If the compilation was performed using a post-18.x version of GNAT, consider\n-  using the legacy elaboration model, in the following order:\n+When faced with an elaboration circularity, the programmer should also consider\n+the tactics given in the suggestions section of the circularity diagnostic.\n+Depending on the units involved in the circularity, their |with| clauses,\n+purity, preelaborability, presence of elaboration control pragmas and\n+invocations at elaboration time, the binder may suggest one or more of the\n+following tactics to eliminate the circularity:\n \n-  - Use the relaxed static elaboration model, with compiler switch\n-    :switch:`-gnatJ`.\n+* Pragma Elaborate elimination\n \n-  - Use the relaxed dynamic elaboration model, with compiler switches\n-    :switch:`-gnatE` :switch:`-gnatJ`.\n-\n-  - Use the legacy static elaboration model, with compiler switch\n-    :switch:`-gnatH`.\n+  ::\n \n-  - Use the legacy dynamic elaboration model, with compiler switches\n-    :switch:`-gnatE` :switch:`-gnatH`.\n+     remove pragma Elaborate for unit \"...\" in unit \"...\"\n \n-* *Suppress all elaboration checks*\n+  This tactic is suggested when the binder has determine that pragma\n+  ``Elaborate``\n \n-  The drawback of run-time checks is that they generate overhead at run time,\n-  both in space and time. If the programmer is absolutely sure that a program\n-  will not raise an elaboration-related ``Program_Error``, then using the\n-  pragma ``Suppress (Elaboration_Check)`` globally (as a configuration pragma)\n-  will eliminate all run-time checks.\n+  - Prevents a set of units from being elaborated.\n \n-* *Suppress elaboration checks selectively*\n+  - The removal of the pragma will not eliminate the semantic effects of the\n+    pragma. In other words, the argument of the pragma will still be elaborated\n+    prior to the unit containing the pragma.\n \n-  If a scenario cannot possibly lead to an elaboration ``Program_Error``,\n-  and the binder nevertheless complains about implicit ``Elaborate`` and\n-  ``Elaborate_All`` pragmas that lead to elaboration circularities, it\n-  is possible to suppress the generation of implicit ``Elaborate`` and\n-  ``Elaborate_All`` pragmas, as well as run-time checks. Clearly this can\n-  be unsafe, and it is the responsibility of the programmer to make sure\n-  that the resulting program has no elaboration anomalies. Pragma\n-  ``Suppress (Elaboration_Check)`` can be used with different levels of\n-  granularity to achieve these effects.\n+  - The removal of the pragma will enable the successful ordering of the units.\n \n-  - *Target suppression*\n+  The programmer should remove the pragma as advised, and rebuild the program.\n \n-    When the pragma is placed in a declarative part, without a second argument\n-    naming an entity, it will suppress implicit ``Elaborate`` and\n-    ``Elaborate_All`` pragma generation, as well as run-time checks, on all\n-    targets within the region.\n+* Pragma Elaborate_All elimination\n \n-    ::\n+  ::\n \n-       package Range_Suppress is\n-          pragma Suppress (Elaboration_Check);\n+     remove pragma Elaborate_All for unit \"...\" in unit \"...\"\n \n-          function Func return Integer;\n+  This tactic is suggested when the binder has determined that pragma\n+  ``Elaborate_All``\n \n-          generic\n-          procedure Gen;\n+  - Prevents a set of units from being elaborated.\n \n-          pragma Unsuppress (Elaboration_Check);\n+  - The removal of the pragma will not eliminate the semantic effects of the\n+    pragma. In other words, the argument of the pragma along with its |with|\n+    closure will still be elaborated prior to the unit containing the pragma.\n \n-          task type Tsk;\n-       end Range_Suppress;\n+  - The removal of the pragma will enable the successful ordering of the units.\n \n-    In the example above, a pair of Suppress/Unsuppress pragmas define a region\n-    of suppression within package ``Range_Suppress``. As a result, no implicit\n-    ``Elaborate`` and ``Elaborate_All`` pragmas, nor any run-time checks, will\n-    be generated by callers of ``Func`` and instantiators of ``Gen``. Note that\n-    task type ``Tsk`` is not within this region.\n+  The programmer should remove the pragma as advised, and rebuild the program.\n \n-    An alternative to the region-based suppression is to use multiple\n-    ``Suppress`` pragmas with arguments naming specific entities for which\n-    elaboration checks should be suppressed:\n+* Pragma Elaborate_All downgrade\n \n-    ::\n-\n-       package Range_Suppress is\n-          function Func return Integer;\n-          pragma Suppress (Elaboration_Check, Func);\n+  ::\n \n-          generic\n-          procedure Gen;\n-          pragma Suppress (Elaboration_Check, Gen);\n+     change pragma Elaborate_All for unit \"...\" to Elaborate in unit \"...\"\n \n-          task type Tsk;\n-       end Range_Suppress;\n+  This tactic is always suggested with the pragma ``Elaborate_All`` elimination\n+  tactic. It offers a different alernative of guaranteeing that the argument of\n+  the pragma will still be elaborated prior to the unit containing the pragma.\n \n-  - *Scenario suppression*\n+  The programmer should update the pragma as advised, and rebuild the program.\n \n-    When the pragma ``Suppress`` is placed in a declarative or statement\n-    part, without an entity argument, it will suppress implicit ``Elaborate``\n-    and ``Elaborate_All`` pragma generation, as well as run-time checks, on\n-    all scenarios within the region.\n+* Pragma Elaborate_Body elimination\n \n-    ::\n+  ::\n \n-       with Server;\n-       package body Range_Suppress is\n-          pragma Suppress (Elaboration_Check);\n+     remove pragma Elaborate_Body in unit \"...\"\n \n-          function Func return Integer is\n-          begin\n-             return Server.Func;\n-          end Func;\n+  This tactic is suggested when the binder has determined that pragma\n+  ``Elaborate_Body``\n \n-          procedure Gen is\n-          begin\n-             Server.Proc;\n-          end Gen;\n+  - Prevents a set of units from being elaborated.\n \n-          pragma Unsuppress (Elaboration_Check);\n+  - The removal of the pragma will enable the successful ordering of the units.\n \n-          task body Tsk is\n-          begin\n-             Server.Proc;\n-          end Tsk;\n-       end Range_Suppress;\n-\n-    In the example above, a pair of Suppress/Unsuppress pragmas define a region\n-    of suppression within package body ``Range_Suppress``. As a result, the\n-    calls to ``Server.Func`` in ``Func`` and ``Server.Proc`` in ``Gen`` will\n-    not generate any implicit ``Elaborate`` and ``Elaborate_All`` pragmas or\n-    run-time checks.\n-\n-.. _Resolving_Task_Issues:\n-\n-Resolving Task Issues\n-=====================\n-\n-The model of execution in Ada dictates that elaboration must first take place,\n-and only then can the main program be started. Tasks which are activated during\n-elaboration violate this model and may lead to serious concurrent problems at\n-elaboration time.\n-\n-A task can be activated in two different ways:\n-\n-* The task is created by an allocator in which case it is activated immediately\n-  after the allocator is evaluated.\n-\n-* The task is declared at the library level or within some nested master in\n-  which case it is activated before starting execution of the statement\n-  sequence of the master defining the task.\n-\n-Since the elaboration of a partition is performed by the environment task\n-servicing that partition, any tasks activated during elaboration may be in\n-a race with the environment task, and lead to unpredictable state and behavior.\n-The static model seeks to avoid such interactions by assuming that all code in\n-the task body is executed at elaboration time, if the task was activated by\n-elaboration code.\n-\n-::\n-\n-   package Decls is\n-      task Lib_Task is\n-         entry Start;\n-      end Lib_Task;\n-\n-      type My_Int is new Integer;\n-\n-      function Ident (M : My_Int) return My_Int;\n-   end Decls;\n-\n-::\n-\n-   with Utils;\n-   package body Decls is\n-      task body Lib_Task is\n-      begin\n-         accept Start;\n-         Utils.Put_Val (2);\n-      end Lib_Task;\n-\n-      function Ident (M : My_Int) return My_Int is\n-      begin\n-         return M;\n-      end Ident;\n-   end Decls;\n-\n-::\n-\n-   with Decls;\n-   package Utils is\n-      procedure Put_Val (Arg : Decls.My_Int);\n-   end Utils;\n-\n-::\n-\n-   with Ada.Text_IO; use Ada.Text_IO;\n-   package body Utils is\n-      procedure Put_Val (Arg : Decls.My_Int) is\n-      begin\n-         Put_Line (Arg'Img);\n-      end Put_Val;\n-   end Utils;\n-\n-::\n-\n-   with Decls;\n-   procedure Main is\n-   begin\n-      Decls.Lib_Task.Start;\n-   end Main;\n-\n-When the above example is compiled with the static model, an elaboration\n-circularity arises:\n-\n-::\n-\n-   error: elaboration circularity detected\n-   info:    \"decls (body)\" must be elaborated before \"decls (body)\"\n-   info:       reason: implicit Elaborate_All in unit \"decls (body)\"\n-   info:       recompile \"decls (body)\" with -gnatel for full details\n-   info:          \"decls (body)\"\n-   info:             must be elaborated along with its spec:\n-   info:          \"decls (spec)\"\n-   info:             which is withed by:\n-   info:          \"utils (spec)\"\n-   info:             which is withed by:\n-   info:          \"decls (body)\"\n-\n-In the above example, ``Decls`` must be elaborated prior to ``Main`` by virtue\n-of a with clause. The elaboration of ``Decls`` activates task ``Lib_Task``. The\n-static model conservatibely assumes that all code within the body of\n-``Lib_Task`` is executed, and generates an implicit ``Elaborate_All`` pragma\n-for ``Units`` due to the call to ``Utils.Put_Val``. The pragma implies that\n-both the spec and body of ``Utils``, along with any units they |with|,\n-must be elaborated prior to ``Decls``. However, ``Utils``'s spec |withs|\n-``Decls``, implying that ``Decls`` must be elaborated before ``Utils``. The end\n-result is that ``Utils`` must be elaborated prior to ``Utils``, and this\n-leads to a circularity.\n-\n-In reality, the example above will not exhibit an ABE problem at run time.\n-When the body of task ``Lib_Task`` is activated, execution will wait for entry\n-``Start`` to be accepted, and the call to ``Utils.Put_Val`` will not take place\n-at elaboration time. Task ``Lib_Task`` will resume its execution after the main\n-program is executed because ``Main`` performs a rendezvous with\n-``Lib_Task.Start``, and at that point all units have already been elaborated.\n-As a result, the static model may seem overly conservative, partly because it\n-does not take control and data flow into account.\n-\n-When faced with a task elaboration circularity, a programmer has several\n-options available:\n-\n-* *Use the dynamic model*\n-\n-  The dynamic model does not generate implicit ``Elaborate`` and\n-  ``Elaborate_All`` pragmas. Instead, it will install checks prior to every\n-  call in the example above, thus verifying the successful elaboration of\n-  ``Utils.Put_Val`` in case the call to it takes place at elaboration time.\n-  The dynamic model is enabled with compiler switch :switch:`-gnatE`.\n+  Note that the binder cannot determine whether the pragma is required for\n+  other purposes, such as guaranteeing the initialization of a variable\n+  declared in the spec by elaboration code in the body.\n \n-* *Isolate the tasks*\n+  The programmer should remove the pragma as advised, and rebuild the program.\n \n-  Relocating tasks in their own separate package could decouple them from\n-  dependencies that would otherwise cause an elaboration circularity. The\n-  example above can be rewritten as follows:\n+* Use of dynamic elaboration model\n \n   ::\n \n-     package Decls1 is                --  new\n-        task Lib_Task is\n-           entry Start;\n-        end Lib_Task;\n-     end Decls1;\n+     use the dynamic elaboration model (compiler switch -gnatE)\n \n-  ::\n+  This tactic is suggested when the binder has determined that an invocation at\n+  elaboration time\n \n-     with Utils;\n-     package body Decls1 is           --  new\n-        task body Lib_Task is\n-        begin\n-           accept Start;\n-           Utils.Put_Val (2);\n-        end Lib_Task;\n-     end Decls1;\n+  - Prevents a set of units from being elaborated.\n \n-  ::\n+  - The use of the dynamic model will enable the successful ordering of the\n+    units.\n \n-     package Decls2 is                --  new\n-        type My_Int is new Integer;\n-        function Ident (M : My_Int) return My_Int;\n-     end Decls2;\n+  The programmer has two options:\n \n-  ::\n+  - Determine the units involved in the invocation using the detailed\n+    invocation information, and add compiler switch :switch:`-gnatE` to the\n+    compilation arguments of selected files only. This approach will yield\n+    safer elaboration orders compared to the other option because it will\n+    minimize the opportunities presented to the dynamic model for ignoring\n+    invocations.\n \n-     with Utils;\n-     package body Decls2 is           --  new\n-        function Ident (M : My_Int) return My_Int is\n-        begin\n-           return M;\n-        end Ident;\n-     end Decls2;\n+  - Add compiler switch :switch:`-gnatE` to the general compilation arguments.\n \n-  ::\n-\n-     with Decls2;\n-     package Utils is\n-        procedure Put_Val (Arg : Decls2.My_Int);\n-     end Utils;\n+* Use of detailed invocation information\n \n   ::\n \n-     with Ada.Text_IO; use Ada.Text_IO;\n-     package body Utils is\n-        procedure Put_Val (Arg : Decls2.My_Int) is\n-        begin\n-           Put_Line (Arg'Img);\n-        end Put_Val;\n-     end Utils;\n+     use detailed invocation information (compiler switch -gnatd_F)\n \n-  ::\n+  This tactic is always suggested with the use of the dynamic model tactic. It\n+  causes the circularity section of the circularity diagnostic to describe the\n+  flow of elaboration code from a unit to a unit, enumerating all such paths in\n+  the process.\n \n-     with Decls1;\n-     procedure Main is\n-     begin\n-        Decls1.Lib_Task.Start;\n-     end Main;\n-   \n-* *Declare the tasks*\n+  The programmer should analyze this information to determine which units\n+  should be compiled with the dynamic model.\n \n-  The original example uses a single task declaration for ``Lib_Task``. An\n-  explicit task type declaration and a properly placed task object could avoid\n-  the dependencies that would otherwise cause an elaboration circularity. The\n-  example can be rewritten as follows:\n+* Forced dependency elimination\n \n   ::\n \n-     package Decls is\n-        task type Lib_Task is         --  new\n-           entry Start;\n-        end Lib_Task;\n+     remove the dependency of unit \"...\" on unit \"...\" from the argument of switch -f\n \n-        type My_Int is new Integer;\n+  This tactic is suggested when the binder has determined that a dependency\n+  present in the forced delboration order file indicated by binder switch\n+  :switch:`-f`\n \n-        function Ident (M : My_Int) return My_Int;\n-     end Decls;\n+  - Prevents a set of units from being elaborated.\n \n-  ::\n+  - The removal of the dependency will enable the successful ordering of the\n+    units.\n \n-     with Utils;\n-     package body Decls is\n-        task body Lib_Task is\n-        begin\n-           accept Start;\n-           Utils.Put_Val (2);\n-        end Lib_Task;\n+  The programmer should edit the forced elaboration order file, remove the\n+  dependency, and rebind the program.\n \n-        function Ident (M : My_Int) return My_Int is\n-        begin\n-           return M;\n-        end Ident;\n-     end Decls;\n+* All forced dependency elimination\n \n   ::\n \n-     with Decls;\n-     package Utils is\n-        procedure Put_Val (Arg : Decls.My_Int);\n-     end Utils;\n+     remove switch -f\n \n-  ::\n+  This tactic is suggested in case editing the forced elaboration order file is\n+  not an option.\n \n-     with Ada.Text_IO; use Ada.Text_IO;\n-     package body Utils is\n-        procedure Put_Val (Arg : Decls.My_Int) is\n-        begin\n-           Put_Line (Arg'Img);\n-        end Put_Val;\n-     end Utils;\n-\n-  ::\n+  The programmer should remove binder switch :switch:`-f` from the binder\n+  arguments, and rebind.\n \n-     with Decls;\n-     package Obj_Decls is             --  new\n-        Task_Obj : Decls.Lib_Task;\n-     end Obj_Decls;\n+* Multiple circularities diagnostic\n \n   ::\n \n-     with Obj_Decls;\n-     procedure Main is\n-     begin\n-        Obj_Decls.Task_Obj.Start;     --  new\n-     end Main;\n+     diagnose all circularities (binder switch -d_C)\n \n-* *Use restriction No_Entry_Calls_In_Elaboration_Code*\n+  By default, the binder will diagnose only the highest precedence circularity.\n+  If the program contains multiple circularities, the binder will suggest the\n+  use of binder switch :switch:`-d_C` in order to obtain the diagnostics of all\n+  circularities.\n \n-  The issue exhibited in the original example under this section revolves\n-  around the body of ``Lib_Task`` blocking on an accept statement. There is\n-  no rule to prevent elaboration code from performing entry calls, however in\n-  practice this is highly unusual. In addition, the pattern of starting tasks\n-  at elaboration time and then immediately blocking on accept or select\n-  statements is quite common.\n+  The programmer should add binder switch :switch:`-d_C` to the binder\n+  arguments, and rebind.\n \n-  If a programmer knows that elaboration code will not perform any entry\n-  calls, then the programmer can indicate that the static model should not\n-  process the remainder of a task body once an accept or select statement has\n-  been encountered. This behavior can be specified by a configuration pragma:\n+If none of the tactics suggested by the binder eliminate the elaboration\n+circularity, the programmer should consider using one of the legacy elaboration\n+models, in the following order:\n \n-  ::\n+* Use the pre-20.x legacy elaboration order model, with binder switch\n+  :switch:`-H`.\n+\n+* Use both pre-18.x and pre-20.x legacy elaboration models, with compiler\n+  switch :switch:`-gnatH` and binder switch :switch:`-H`.\n \n-     pragma Restrictions (No_Entry_Calls_In_Elaboration_Code);\n+* Use the relaxed static elaboration model, with compiler switches\n+  :switch:`-gnatH` :switch:`-gnatJ` and binder switch :switch:`-H`.\n \n-  In addition to the change in behavior with respect to task bodies, the\n-  static model will verify that no entry calls take place at elaboration time.\n+* Use the relaxed dynamic elaboration model, with compiler switches\n+  :switch:`-gnatH` :switch:`-gnatJ` :switch:`-gnatE` and binder switch\n+  :switch:`-H`.\n \n .. _Elaboration_Related_Compiler_Switches:\n \n@@ -1465,13 +1127,17 @@ the elaboration order chosen by the binder.\n :switch:`-gnatE`\n   Dynamic elaboration checking mode enabled\n \n-  When this switch is in effect, GNAT activates the dynamic elaboration model.\n+  When this switch is in effect, GNAT activates the dynamic model.\n \n .. index:: -gnatel  (gnat)\n \n :switch:`-gnatel`\n   Turn on info messages on generated Elaborate[_All] pragmas\n \n+  This switch is only applicable to the pre-20.x legacy elaboration models.\n+  The post-20.x elaboration model no longer relies on implicitly generated\n+  ``Elaborate`` and ``Elaborate_All`` pragmas to order units.\n+\n   When this switch is in effect, GNAT will emit the following supplementary\n   information depending on the elaboration model in effect.\n \n@@ -1482,7 +1148,7 @@ the elaboration order chosen by the binder.\n \n   - *Static model*\n \n-    GNAT will indicate all scenarios executed during elaboration. In addition,\n+    GNAT will indicate all scenarios invoked during elaboration. In addition,\n     it will provide detailed traceback when an implicit ``Elaborate`` or\n     ``Elaborate_All`` pragma is generated.\n \n@@ -1615,29 +1281,24 @@ options:\n   as their origins. Elaboration warnings are enabled with compiler switch\n   :switch:`-gnatwl`.\n \n-* Use switch :switch:`-gnatel` to obtain messages on generated implicit\n-  ``Elaborate`` and ``Elaborate_All`` pragmas. The trace information could\n-  indicate why a server unit must be elaborated prior to a client unit.\n-\n-* If the warnings produced by the static model indicate that a task is\n-  involved, consider the options in section `Resolving Task Issues`_.\n+* Cosider the tactics given in the suggestions section of the circularity\n+  diagnostic.\n \n * If none of the steps outlined above resolve the circularity, use a more\n   permissive elaboration model, in the following order:\n \n-  - Use the dynamic elaboration model, with compiler switch :switch:`-gnatE`.\n-\n-  - Use the legacy static elaboration model, with compiler switch\n-    :switch:`-gnatH`.\n+  - Use the pre-20.x legacy elaboration order model, with binder switch\n+    :switch:`-H`.\n \n-  - Use the legacy dynamic elaboration model, with compiler switches\n-    :switch:`-gnatH` :switch:`-gnatE`.\n+  - Use both pre-18.x and pre-20.x legacy elaboration models, with compiler\n+    switch :switch:`-gnatH` and binder switch :switch:`-H`.\n \n-  - Use the relaxed legacy static elaboration model, with compiler switches\n-    :switch:`-gnatH` :switch:`-gnatJ`.\n+  - Use the relaxed static elaboration model, with compiler switches\n+    :switch:`-gnatH` :switch:`-gnatJ` and binder switch :switch:`-H`.\n \n-  - Use the relaxed legacy dynamic elaboration model, with compiler switches\n-    :switch:`-gnatH` :switch:`-gnatJ` :switch:`-gnatE`.\n+  - Use the relaxed dynamic elaboration model, with compiler switches\n+    :switch:`-gnatH` :switch:`-gnatJ` :switch:`-gnatE` and binder switch\n+    :switch:`-H`.\n \n .. _Inspecting_the_Chosen_Elaboration_Order:\n \n@@ -1650,128 +1311,128 @@ elaboration order appears as a sequence of calls to ``Elab_Body`` and\n ``Elab_Spec``, interspersed with assignments to `Exxx` which indicates that a\n particular unit is elaborated. For example:\n \n-::\n-\n-   System.Soft_Links'Elab_Body;\n-   E14 := True;\n-   System.Secondary_Stack'Elab_Body;\n-   E18 := True;\n-   System.Exception_Table'Elab_Body;\n-   E24 := True;\n-   Ada.Io_Exceptions'Elab_Spec;\n-   E67 := True;\n-   Ada.Tags'Elab_Spec;\n-   Ada.Streams'Elab_Spec;\n-   E43 := True;\n-   Interfaces.C'Elab_Spec;\n-   E69 := True;\n-   System.Finalization_Root'Elab_Spec;\n-   E60 := True;\n-   System.Os_Lib'Elab_Body;\n-   E71 := True;\n-   System.Finalization_Implementation'Elab_Spec;\n-   System.Finalization_Implementation'Elab_Body;\n-   E62 := True;\n-   Ada.Finalization'Elab_Spec;\n-   E58 := True;\n-   Ada.Finalization.List_Controller'Elab_Spec;\n-   E76 := True;\n-   System.File_Control_Block'Elab_Spec;\n-   E74 := True;\n-   System.File_Io'Elab_Body;\n-   E56 := True;\n-   Ada.Tags'Elab_Body;\n-   E45 := True;\n-   Ada.Text_Io'Elab_Spec;\n-   Ada.Text_Io'Elab_Body;\n-   E07 := True;\n+  ::\n+\n+     System.Soft_Links'Elab_Body;\n+     E14 := True;\n+     System.Secondary_Stack'Elab_Body;\n+     E18 := True;\n+     System.Exception_Table'Elab_Body;\n+     E24 := True;\n+     Ada.Io_Exceptions'Elab_Spec;\n+     E67 := True;\n+     Ada.Tags'Elab_Spec;\n+     Ada.Streams'Elab_Spec;\n+     E43 := True;\n+     Interfaces.C'Elab_Spec;\n+     E69 := True;\n+     System.Finalization_Root'Elab_Spec;\n+     E60 := True;\n+     System.Os_Lib'Elab_Body;\n+     E71 := True;\n+     System.Finalization_Implementation'Elab_Spec;\n+     System.Finalization_Implementation'Elab_Body;\n+     E62 := True;\n+     Ada.Finalization'Elab_Spec;\n+     E58 := True;\n+     Ada.Finalization.List_Controller'Elab_Spec;\n+     E76 := True;\n+     System.File_Control_Block'Elab_Spec;\n+     E74 := True;\n+     System.File_Io'Elab_Body;\n+     E56 := True;\n+     Ada.Tags'Elab_Body;\n+     E45 := True;\n+     Ada.Text_Io'Elab_Spec;\n+     Ada.Text_Io'Elab_Body;\n+     E07 := True;\n \n Note also binder switch :switch:`-l`, which outputs the chosen elaboration\n order and provides a more readable form of the above:\n \n-::\n-\n-   ada (spec)\n-   interfaces (spec)\n-   system (spec)\n-   system.case_util (spec)\n-   system.case_util (body)\n-   system.concat_2 (spec)\n-   system.concat_2 (body)\n-   system.concat_3 (spec)\n-   system.concat_3 (body)\n-   system.htable (spec)\n-   system.parameters (spec)\n-   system.parameters (body)\n-   system.crtl (spec)\n-   interfaces.c_streams (spec)\n-   interfaces.c_streams (body)\n-   system.restrictions (spec)\n-   system.restrictions (body)\n-   system.standard_library (spec)\n-   system.exceptions (spec)\n-   system.exceptions (body)\n-   system.storage_elements (spec)\n-   system.storage_elements (body)\n-   system.secondary_stack (spec)\n-   system.stack_checking (spec)\n-   system.stack_checking (body)\n-   system.string_hash (spec)\n-   system.string_hash (body)\n-   system.htable (body)\n-   system.strings (spec)\n-   system.strings (body)\n-   system.traceback (spec)\n-   system.traceback (body)\n-   system.traceback_entries (spec)\n-   system.traceback_entries (body)\n-   ada.exceptions (spec)\n-   ada.exceptions.last_chance_handler (spec)\n-   system.soft_links (spec)\n-   system.soft_links (body)\n-   ada.exceptions.last_chance_handler (body)\n-   system.secondary_stack (body)\n-   system.exception_table (spec)\n-   system.exception_table (body)\n-   ada.io_exceptions (spec)\n-   ada.tags (spec)\n-   ada.streams (spec)\n-   interfaces.c (spec)\n-   interfaces.c (body)\n-   system.finalization_root (spec)\n-   system.finalization_root (body)\n-   system.memory (spec)\n-   system.memory (body)\n-   system.standard_library (body)\n-   system.os_lib (spec)\n-   system.os_lib (body)\n-   system.unsigned_types (spec)\n-   system.stream_attributes (spec)\n-   system.stream_attributes (body)\n-   system.finalization_implementation (spec)\n-   system.finalization_implementation (body)\n-   ada.finalization (spec)\n-   ada.finalization (body)\n-   ada.finalization.list_controller (spec)\n-   ada.finalization.list_controller (body)\n-   system.file_control_block (spec)\n-   system.file_io (spec)\n-   system.file_io (body)\n-   system.val_uns (spec)\n-   system.val_util (spec)\n-   system.val_util (body)\n-   system.val_uns (body)\n-   system.wch_con (spec)\n-   system.wch_con (body)\n-   system.wch_cnv (spec)\n-   system.wch_jis (spec)\n-   system.wch_jis (body)\n-   system.wch_cnv (body)\n-   system.wch_stw (spec)\n-   system.wch_stw (body)\n-   ada.tags (body)\n-   ada.exceptions (body)\n-   ada.text_io (spec)\n-   ada.text_io (body)\n-   text_io (spec)\n-   gdbstr (body)\n+  ::\n+\n+     ada (spec)\n+     interfaces (spec)\n+     system (spec)\n+     system.case_util (spec)\n+     system.case_util (body)\n+     system.concat_2 (spec)\n+     system.concat_2 (body)\n+     system.concat_3 (spec)\n+     system.concat_3 (body)\n+     system.htable (spec)\n+     system.parameters (spec)\n+     system.parameters (body)\n+     system.crtl (spec)\n+     interfaces.c_streams (spec)\n+     interfaces.c_streams (body)\n+     system.restrictions (spec)\n+     system.restrictions (body)\n+     system.standard_library (spec)\n+     system.exceptions (spec)\n+     system.exceptions (body)\n+     system.storage_elements (spec)\n+     system.storage_elements (body)\n+     system.secondary_stack (spec)\n+     system.stack_checking (spec)\n+     system.stack_checking (body)\n+     system.string_hash (spec)\n+     system.string_hash (body)\n+     system.htable (body)\n+     system.strings (spec)\n+     system.strings (body)\n+     system.traceback (spec)\n+     system.traceback (body)\n+     system.traceback_entries (spec)\n+     system.traceback_entries (body)\n+     ada.exceptions (spec)\n+     ada.exceptions.last_chance_handler (spec)\n+     system.soft_links (spec)\n+     system.soft_links (body)\n+     ada.exceptions.last_chance_handler (body)\n+     system.secondary_stack (body)\n+     system.exception_table (spec)\n+     system.exception_table (body)\n+     ada.io_exceptions (spec)\n+     ada.tags (spec)\n+     ada.streams (spec)\n+     interfaces.c (spec)\n+     interfaces.c (body)\n+     system.finalization_root (spec)\n+     system.finalization_root (body)\n+     system.memory (spec)\n+     system.memory (body)\n+     system.standard_library (body)\n+     system.os_lib (spec)\n+     system.os_lib (body)\n+     system.unsigned_types (spec)\n+     system.stream_attributes (spec)\n+     system.stream_attributes (body)\n+     system.finalization_implementation (spec)\n+     system.finalization_implementation (body)\n+     ada.finalization (spec)\n+     ada.finalization (body)\n+     ada.finalization.list_controller (spec)\n+     ada.finalization.list_controller (body)\n+     system.file_control_block (spec)\n+     system.file_io (spec)\n+     system.file_io (body)\n+     system.val_uns (spec)\n+     system.val_util (spec)\n+     system.val_util (body)\n+     system.val_uns (body)\n+     system.wch_con (spec)\n+     system.wch_con (body)\n+     system.wch_cnv (spec)\n+     system.wch_jis (spec)\n+     system.wch_jis (body)\n+     system.wch_cnv (body)\n+     system.wch_stw (spec)\n+     system.wch_stw (body)\n+     ada.tags (body)\n+     ada.exceptions (body)\n+     ada.text_io (spec)\n+     ada.text_io (body)\n+     text_io (spec)\n+     gdbstr (body)"}, {"sha": "b0b3bdd15182fdcfbc0c55027ea93c8e25395ab3", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 541, "deletions": 779, "changes": 1320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=16cc65b61a7c00920ff66d45d3b23a9e313dd1b8", "patch": "@@ -533,15 +533,11 @@ Elaboration Order Handling in GNAT\n * Checking the Elaboration Order:: \n * Controlling the Elaboration Order in Ada:: \n * Controlling the Elaboration Order in GNAT:: \n-* Common Elaboration-model Traits:: \n-* Dynamic Elaboration Model in GNAT:: \n-* Static Elaboration Model in GNAT:: \n-* SPARK Elaboration Model in GNAT:: \n-* Legacy Elaboration Model in GNAT:: \n * Mixing Elaboration Models:: \n+* ABE Diagnostics:: \n+* SPARK Diagnostics:: \n * Elaboration Circularities:: \n * Resolving Elaboration Circularities:: \n-* Resolving Task Issues:: \n * Elaboration-related Compiler Switches:: \n * Summary of Procedures for Elaboration Control:: \n * Inspecting the Chosen Elaboration Order:: \n@@ -9585,7 +9581,8 @@ checking options to be controlled from the command line.\n \n @item @code{-gnatE}\n \n-Full dynamic elaboration checks.\n+Dynamic elaboration checking mode enabled. For further details see\n+@ref{f,,Elaboration Order Handling in GNAT}.\n @end table\n \n @geindex -gnatf (gcc)\n@@ -9651,8 +9648,9 @@ Output usage information. The output is written to @code{stdout}.\n \n @item @code{-gnatH}\n \n-Legacy elaboration-checking mode enabled. When this switch is in effect, the\n-pre-18.x access-before-elaboration model becomes the de facto model.\n+Legacy elaboration-checking mode enabled. When this switch is in effect,\n+the pre-18.x access-before-elaboration model becomes the de facto model.\n+For further details see @ref{f,,Elaboration Order Handling in GNAT}.\n @end table\n \n @geindex -gnati (gcc)\n@@ -9749,7 +9747,8 @@ Select statements\n Synchronous task suspension\n @end itemize\n \n-and does not emit compile-time diagnostics or run-time checks.\n+and does not emit compile-time diagnostics or run-time checks. For further\n+details see @ref{f,,Elaboration Order Handling in GNAT}.\n @end table\n \n @geindex -gnatk (gcc)\n@@ -15747,7 +15746,8 @@ Currently the same as @code{-Ea}.\n \n @item @code{-f@emph{elab-order}}\n \n-Force elaboration order.\n+Force elaboration order. For further details see @ref{120,,Elaboration Control}\n+and @ref{f,,Elaboration Order Handling in GNAT}.\n @end table\n \n @geindex -F (gnatbind)\n@@ -15774,22 +15774,41 @@ flag checks are generated.\n @item @code{-h}\n \n Output usage (help) information.\n+@end table\n+\n+@geindex -H (gnatbind)\n+\n+\n+@table @asis\n+\n+@item @code{-H}\n+\n+Legacy elaboration order model enabled. For further details see\n+@ref{f,,Elaboration Order Handling in GNAT}.\n+@end table\n \n @geindex -H32 (gnatbind)\n \n+\n+@table @asis\n+\n @item @code{-H32}\n \n Use 32-bit allocations for @code{__gnat_malloc} (and thus for access types).\n-For further details see @ref{120,,Dynamic Allocation Control}.\n+For further details see @ref{121,,Dynamic Allocation Control}.\n+@end table\n \n @geindex -H64 (gnatbind)\n \n @geindex __gnat_malloc\n \n+\n+@table @asis\n+\n @item @code{-H64}\n \n Use 64-bit allocations for @code{__gnat_malloc} (and thus for access types).\n-For further details see @ref{120,,Dynamic Allocation Control}.\n+For further details see @ref{121,,Dynamic Allocation Control}.\n \n @geindex -I (gnatbind)\n \n@@ -16019,7 +16038,7 @@ Enable dynamic stack usage, with @code{n} results stored and displayed\n at program termination. A result is generated when a task\n terminates. Results that can't be stored are displayed on the fly, at\n task termination. This option is currently not supported on Itanium\n-platforms. (See @ref{121,,Dynamic Stack Usage Analysis} for details.)\n+platforms. (See @ref{122,,Dynamic Stack Usage Analysis} for details.)\n \n @geindex -v (gnatbind)\n \n@@ -16088,7 +16107,7 @@ no arguments.\n @end menu\n \n @node Consistency-Checking Modes,Binder Error Message Control,,Switches for gnatbind\n-@anchor{gnat_ugn/building_executable_programs_with_gnat consistency-checking-modes}@anchor{122}@anchor{gnat_ugn/building_executable_programs_with_gnat id35}@anchor{123}\n+@anchor{gnat_ugn/building_executable_programs_with_gnat consistency-checking-modes}@anchor{123}@anchor{gnat_ugn/building_executable_programs_with_gnat id35}@anchor{124}\n @subsubsection Consistency-Checking Modes\n \n \n@@ -16142,7 +16161,7 @@ case the checking against sources has already been performed by\n @end table\n \n @node Binder Error Message Control,Elaboration Control,Consistency-Checking Modes,Switches for gnatbind\n-@anchor{gnat_ugn/building_executable_programs_with_gnat id36}@anchor{124}@anchor{gnat_ugn/building_executable_programs_with_gnat binder-error-message-control}@anchor{125}\n+@anchor{gnat_ugn/building_executable_programs_with_gnat id36}@anchor{125}@anchor{gnat_ugn/building_executable_programs_with_gnat binder-error-message-control}@anchor{126}\n @subsubsection Binder Error Message Control\n \n \n@@ -16252,12 +16271,12 @@ with extreme care.\n @end table\n \n @node Elaboration Control,Output Control,Binder Error Message Control,Switches for gnatbind\n-@anchor{gnat_ugn/building_executable_programs_with_gnat id37}@anchor{126}@anchor{gnat_ugn/building_executable_programs_with_gnat elaboration-control}@anchor{127}\n+@anchor{gnat_ugn/building_executable_programs_with_gnat id37}@anchor{127}@anchor{gnat_ugn/building_executable_programs_with_gnat elaboration-control}@anchor{120}\n @subsubsection Elaboration Control\n \n \n The following switches provide additional control over the elaboration\n-order. For full details see @ref{f,,Elaboration Order Handling in GNAT}.\n+order. For further details see @ref{f,,Elaboration Order Handling in GNAT}.\n \n @geindex -f (gnatbind)\n \n@@ -16302,30 +16321,38 @@ above forced elaboration order file.\n Blank lines and Ada-style comments are ignored. Unit names that do not exist\n in the program are ignored. Units in the GNAT predefined library are also\n ignored.\n+@end table\n \n @geindex -p (gnatbind)\n \n+\n+@table @asis\n+\n @item @code{-p}\n \n-Normally the binder attempts to choose an elaboration order that is\n-likely to minimize the likelihood of an elaboration order error resulting\n-in raising a @code{Program_Error} exception. This switch reverses the\n-action of the binder, and requests that it deliberately choose an order\n-that is likely to maximize the likelihood of an elaboration error.\n-This is useful in ensuring portability and avoiding dependence on\n-accidental fortuitous elaboration ordering.\n+Pessimistic elaboration order\n \n-Normally it only makes sense to use the @code{-p}\n-switch if dynamic\n+This switch is only applicable to the pre-20.x legacy elaboration models.\n+The post-20.x elaboration model uses a more informed approach of ordering\n+the units.\n+\n+Normally the binder attempts to choose an elaboration order that is likely to\n+minimize the likelihood of an elaboration order error resulting in raising a\n+@code{Program_Error} exception. This switch reverses the action of the binder,\n+and requests that it deliberately choose an order that is likely to maximize\n+the likelihood of an elaboration error. This is useful in ensuring\n+portability and avoiding dependence on accidental fortuitous elaboration\n+ordering.\n+\n+Normally it only makes sense to use the @code{-p} switch if dynamic\n elaboration checking is used (@code{-gnatE} switch used for compilation).\n This is because in the default static elaboration mode, all necessary\n @code{Elaborate} and @code{Elaborate_All} pragmas are implicitly inserted.\n-These implicit pragmas are still respected by the binder in\n-@code{-p} mode, so a\n-safe elaboration order is assured.\n+These implicit pragmas are still respected by the binder in @code{-p}\n+mode, so a safe elaboration order is assured.\n \n-Note that @code{-p} is not intended for\n-production use; it is more for debugging/experimental use.\n+Note that @code{-p} is not intended for production use; it is more for\n+debugging/experimental use.\n @end table\n \n @node Output Control,Dynamic Allocation Control,Elaboration Control,Switches for gnatbind\n@@ -16410,7 +16437,7 @@ be used to improve code generation in some cases.\n @end table\n \n @node Dynamic Allocation Control,Binding with Non-Ada Main Programs,Output Control,Switches for gnatbind\n-@anchor{gnat_ugn/building_executable_programs_with_gnat dynamic-allocation-control}@anchor{120}@anchor{gnat_ugn/building_executable_programs_with_gnat id39}@anchor{12a}\n+@anchor{gnat_ugn/building_executable_programs_with_gnat dynamic-allocation-control}@anchor{121}@anchor{gnat_ugn/building_executable_programs_with_gnat id39}@anchor{12a}\n @subsubsection Dynamic Allocation Control\n \n \n@@ -23169,7 +23196,7 @@ subprogram whose stack usage might be larger than the specified amount of\n bytes.  The wording is in keeping with the qualifier documented above.\n \n @node Dynamic Stack Usage Analysis,,Static Stack Usage Analysis,Stack Related Facilities\n-@anchor{gnat_ugn/gnat_and_program_execution dynamic-stack-usage-analysis}@anchor{121}@anchor{gnat_ugn/gnat_and_program_execution id60}@anchor{1c6}\n+@anchor{gnat_ugn/gnat_and_program_execution dynamic-stack-usage-analysis}@anchor{122}@anchor{gnat_ugn/gnat_and_program_execution id60}@anchor{1c6}\n @subsection Dynamic Stack Usage Analysis\n \n \n@@ -27187,15 +27214,11 @@ GNAT, either automatically or with explicit programming features.\n * Checking the Elaboration Order:: \n * Controlling the Elaboration Order in Ada:: \n * Controlling the Elaboration Order in GNAT:: \n-* Common Elaboration-model Traits:: \n-* Dynamic Elaboration Model in GNAT:: \n-* Static Elaboration Model in GNAT:: \n-* SPARK Elaboration Model in GNAT:: \n-* Legacy Elaboration Model in GNAT:: \n * Mixing Elaboration Models:: \n+* ABE Diagnostics:: \n+* SPARK Diagnostics:: \n * Elaboration Circularities:: \n * Resolving Elaboration Circularities:: \n-* Resolving Task Issues:: \n * Elaboration-related Compiler Switches:: \n * Summary of Procedures for Elaboration Control:: \n * Inspecting the Chosen Elaboration Order:: \n@@ -27242,10 +27265,16 @@ In addition to the Ada terminology, this appendix defines the following terms:\n \n @itemize *\n \n+@item \n+@emph{Invocation}\n+\n+The act of calling a subprogram, instantiating a generic, or activating a\n+task.\n+\n @item \n @emph{Scenario}\n \n-A construct that is elaborated or executed by elaboration code is referred to\n+A construct that is elaborated or invoked by elaboration code is referred to\n as an @emph{elaboration scenario} or simply a @strong{scenario}. GNAT recognizes the\n following scenarios:\n \n@@ -27317,7 +27346,7 @@ end Client;\n In the example above, the call to @code{Server.Func} is an elaboration scenario\n because it appears at the library level of package @code{Client}. Note that the\n declaration of package @code{Nested} is ignored according to the definition\n-given above. As a result, the call to @code{Server.Func} will be executed when\n+given above. As a result, the call to @code{Server.Func} will be invoked when\n the spec of unit @code{Client} is elaborated.\n \n @item \n@@ -27340,7 +27369,7 @@ end Client;\n \n In the example above, the call to @code{Proc} is an elaboration scenario because\n it appears within the statement sequence of package body @code{Client}. As a\n-result, the call to @code{Proc} will be executed when the body of @code{Client} is\n+result, the call to @code{Proc} will be invoked when the body of @code{Client} is\n elaborated.\n @end itemize\n \n@@ -27354,6 +27383,8 @@ executed is referred to as @strong{elaboration order}.\n \n Within a single unit, elaboration code is executed in sequential order.\n \n+@quotation\n+\n @example\n package body Client is\n    Result : ... := Server.Func;\n@@ -27367,6 +27398,7 @@ begin\n    Proc;\n end Client;\n @end example\n+@end quotation\n \n In the example above, the elaboration order within package body @code{Client} is\n as follows:\n@@ -27413,6 +27445,9 @@ factors:\n @item \n @emph{with}ed units\n \n+@item \n+parent units\n+\n @item \n purity of units\n \n@@ -27421,10 +27456,15 @@ preelaborability of units\n \n @item \n presence of elaboration control pragmas\n+\n+@item \n+invocations performed in elaboration code\n @end itemize\n \n A program may have several elaboration orders depending on its structure.\n \n+@quotation\n+\n @example\n package Server is\n    function Func (Index : Integer) return Integer;\n@@ -27453,16 +27493,20 @@ end Client;\n with Client;\n procedure Main is begin null; end Main;\n @end example\n+@end quotation\n \n The following elaboration order exhibits a fundamental problem referred to as\n @emph{access-before-elaboration} or simply @strong{ABE}.\n \n+@quotation\n+\n @example\n spec of Server\n spec of Client\n body of Server\n body of Main\n @end example\n+@end quotation\n \n The elaboration of @code{Server}'s spec materializes function @code{Func}, making it\n callable. The elaboration of @code{Client}'s spec elaborates the declaration of\n@@ -27480,19 +27524,23 @@ vein as index or null exclusion checks. A failed ABE check raises exception\n The following elaboration order avoids the ABE problem and the program can be\n successfully elaborated.\n \n+@quotation\n+\n @example\n spec of Server\n body of Server\n spec of Client\n body of Main\n @end example\n+@end quotation\n \n Ada states that a total elaboration order must exist, but it does not define\n what this order is. A compiler is thus tasked with choosing a suitable\n elaboration order which satisfies the dependencies imposed by @emph{with} clauses,\n-unit categorization, and elaboration control pragmas. Ideally an order which\n-avoids ABE problems should be chosen, however a compiler may not always find\n-such an order due to complications with respect to control and data flow.\n+unit categorization, elaboration control pragmas, and invocations performed in\n+elaboration code. Ideally an order that avoids ABE problems should be chosen,\n+however a compiler may not always find such an order due to complications with\n+respect to control and data flow.\n \n @node Checking the Elaboration Order,Controlling the Elaboration Order in Ada,Elaboration Order,Elaboration Order Handling in GNAT\n @anchor{gnat_ugn/elaboration_order_handling_in_gnat id4}@anchor{231}@anchor{gnat_ugn/elaboration_order_handling_in_gnat checking-the-elaboration-order}@anchor{232}\n@@ -27517,7 +27565,7 @@ always elaborated prior to Client. The same principle applies to child units\n @emph{Dynamic semantics}\n \n Dynamic checks are performed at run time, to ensure that a target is\n-elaborated prior to a scenario that executes it, thus avoiding ABE problems.\n+elaborated prior to a scenario that invokes it, thus avoiding ABE problems.\n A failed run-time check raises exception @code{Program_Error}. The following\n restrictions apply:\n \n@@ -27546,8 +27594,7 @@ associated task type has been elaborated.\n The restrictions above can be summarized by the following rule:\n \n @emph{If a target has a body, then this body must be elaborated prior to the\n-execution of the scenario that invokes, instantiates, or activates the\n-target.}\n+scenario that invokes the target.}\n \n @item \n @emph{Elaboration control}\n@@ -27623,7 +27670,7 @@ but still strong enough to prevent ABE problems within a unit.\n \n Pragma @code{Elaborate_Body} requires that the body of a unit is elaborated\n immediately after its spec. This restriction guarantees that no client\n-scenario can execute a server target before the target body has been\n+scenario can invoke a server target before the target body has been\n elaborated because the spec and body are effectively \"glued\" together.\n \n @example\n@@ -27884,7 +27931,7 @@ Note that one additional advantage of using @code{Elaborate} and @code{Elaborate\n is that the program continues to stay in the last state (one or more correct\n orders exist) even if maintenance changes the bodies of targets.\n \n-@node Controlling the Elaboration Order in GNAT,Common Elaboration-model Traits,Controlling the Elaboration Order in Ada,Elaboration Order Handling in GNAT\n+@node Controlling the Elaboration Order in GNAT,Mixing Elaboration Models,Controlling the Elaboration Order in Ada,Elaboration Order Handling in GNAT\n @anchor{gnat_ugn/elaboration_order_handling_in_gnat id6}@anchor{235}@anchor{gnat_ugn/elaboration_order_handling_in_gnat controlling-the-elaboration-order-in-gnat}@anchor{236}\n @section Controlling the Elaboration Order in GNAT\n \n@@ -27901,12 +27948,34 @@ elaboration order and to diagnose elaboration problems.\n @item \n @emph{Dynamic elaboration model}\n \n-This is the most permissive of the three elaboration models. When the\n-dynamic model is in effect, GNAT assumes that all code within all units in\n-a partition is elaboration code. GNAT performs very few diagnostics and\n-generates run-time checks to verify the elaboration order of a program. This\n-behavior is identical to that specified by the Ada Reference Manual. The\n-dynamic model is enabled with compiler switch @code{-gnatE}.\n+This is the most permissive of the three elaboration models and emulates the\n+behavior specified by the Ada Reference Manual. When the dynamic model is in\n+effect, GNAT makes the following assumptions:\n+\n+\n+@itemize -\n+\n+@item \n+All code within all units in a partition is considered to be elaboration\n+code.\n+\n+@item \n+Some of the invocations in elaboration code may not take place at runtime\n+due to conditional execution.\n+@end itemize\n+\n+GNAT performs extensive diagnostics on a unit-by-unit basis for all scenarios\n+that invoke internal targets. In addition, GNAT generates run-time checks for\n+all external targets and for all scenarios that may exhibit ABE problems.\n+\n+The elaboration order is obtained by honoring all @emph{with} clauses, purity and\n+preelaborability of units, and elaboration control pragmas. The dynamic model\n+attempts to take all invocations in elaboration code into account. If an\n+invocation leads to a circularity, GNAT ignores the invocation based on the\n+assumptions stated above. An order obtained using the dynamic model may fail\n+an ABE check at runtime when GNAT ignored an invocation.\n+\n+The dynamic model is enabled with compiler switch @code{-gnatE}.\n @end itemize\n \n @geindex Static elaboration model\n@@ -27918,12 +27987,31 @@ dynamic model is enabled with compiler switch @code{-gnatE}.\n @emph{Static elaboration model}\n \n This is the middle ground of the three models. When the static model is in\n-effect, GNAT performs extensive diagnostics on a unit-by-unit basis for all\n-scenarios that elaborate or execute internal targets. GNAT also generates\n-run-time checks for all external targets and for all scenarios that may\n-exhibit ABE problems. Finally, GNAT installs implicit @code{Elaborate} and\n-@code{Elaborate_All} pragmas for server units based on the dependencies of\n-client units. The static model is the default model in GNAT.\n+effect, GNAT makes the following assumptions:\n+\n+\n+@itemize -\n+\n+@item \n+Only code at the library level and in package body statements within all\n+units in a partition is considered to be elaboration code.\n+\n+@item \n+All invocations in elaboration will take place at runtime, regardless of\n+conditional execution.\n+@end itemize\n+\n+GNAT performs extensive diagnostics on a unit-by-unit basis for all scenarios\n+that invoke internal targets. In addition, GNAT generates run-time checks for\n+all external targets and for all scenarios that may exhibit ABE problems.\n+\n+The elaboration order is obtained by honoring all @emph{with} clauses, purity and\n+preelaborability of units, presence of elaboration control pragmas, and all\n+invocations in elaboration code. An order obtained using the static model is\n+guaranteed to be ABE problem-free, excluding dispatching calls and\n+access-to-subprogram types.\n+\n+The static model is the default model in GNAT.\n @end itemize\n \n @geindex SPARK elaboration model\n@@ -27937,21 +28025,34 @@ client units. The static model is the default model in GNAT.\n This is the most conservative of the three models and enforces the SPARK\n rules of elaboration as defined in the SPARK Reference Manual, section 7.7.\n The SPARK model is in effect only when a scenario and a target reside in a\n-region subject to SPARK_Mode On, otherwise the dynamic or static model is in\n-effect.\n+region subject to @code{SPARK_Mode On}, otherwise the dynamic or static model\n+is in effect.\n+\n+The SPARK model is enabled with compiler switch @code{-gnatd.v}.\n @end itemize\n \n-@geindex Legacy elaboration model\n+@geindex Legacy elaboration models\n \n \n @itemize *\n \n @item \n-@emph{Legacy elaboration model}\n+@emph{Legacy elaboration models}\n \n In addition to the three elaboration models outlined above, GNAT provides the\n-elaboration model of pre-18.x versions referred to as @cite{legacy elaboration model}. The legacy elaboration model is enabled with compiler switch\n-@code{-gnatH}.\n+following legacy models:\n+\n+\n+@itemize -\n+\n+@item \n+@cite{Legacy elaboration-checking model} available in pre-18.x versions of GNAT.\n+This model is enabled with compiler switch @code{-gnatH}.\n+\n+@item \n+@cite{Legacy elaboration-order model} available in pre-20.x versions of GNAT.\n+This model is enabled with binder switch @code{-H}.\n+@end itemize\n @end itemize\n \n @geindex Relaxed elaboration mode\n@@ -27960,878 +28061,536 @@ The dynamic, legacy, and static models can be relaxed using compiler switch\n @code{-gnatJ}, making them more permissive. Note that in this mode, GNAT\n may not diagnose certain elaboration issues or install run-time checks.\n \n-@node Common Elaboration-model Traits,Dynamic Elaboration Model in GNAT,Controlling the Elaboration Order in GNAT,Elaboration Order Handling in GNAT\n-@anchor{gnat_ugn/elaboration_order_handling_in_gnat common-elaboration-model-traits}@anchor{237}@anchor{gnat_ugn/elaboration_order_handling_in_gnat id7}@anchor{238}\n-@section Common Elaboration-model Traits\n+@node Mixing Elaboration Models,ABE Diagnostics,Controlling the Elaboration Order in GNAT,Elaboration Order Handling in GNAT\n+@anchor{gnat_ugn/elaboration_order_handling_in_gnat mixing-elaboration-models}@anchor{237}@anchor{gnat_ugn/elaboration_order_handling_in_gnat id7}@anchor{238}\n+@section Mixing Elaboration Models\n \n \n-All three GNAT models are able to detect elaboration problems related to\n-dispatching calls and a particular kind of ABE referred to as @emph{guaranteed ABE}.\n+It is possible to mix units compiled with a different elaboration model,\n+however the following rules must be observed:\n \n \n @itemize *\n \n @item \n-@emph{Dispatching calls}\n+A client unit compiled with the dynamic model can only @emph{with} a server unit\n+that meets at least one of the following criteria:\n \n-GNAT installs run-time checks for each primitive subprogram of each tagged\n-type defined in a partition on the assumption that a dispatching call\n-invoked at elaboration time will execute one of these primitives. As a\n-result, a dispatching call that executes a primitive whose body has not\n-been elaborated yet will raise exception @code{Program_Error} at run time. The\n-checks can be suppressed using pragma @code{Suppress (Elaboration_Check)}.\n+\n+@itemize -\n \n @item \n-@emph{Guaranteed ABE}\n+The server unit is compiled with the dynamic model.\n \n-A guaranteed ABE arises when the body of a target is not elaborated early\n-enough, and causes all scenarios that directly execute the target to fail.\n+@item \n+The server unit is a GNAT implementation unit from the @code{Ada}, @code{GNAT},\n+@code{Interfaces}, or @code{System} hierarchies.\n \n-@example\n-package body Guaranteed_ABE is\n-   function ABE return Integer;\n+@item \n+The server unit has pragma @code{Pure} or @code{Preelaborate}.\n \n-   Val : constant Integer := ABE;\n+@item \n+The client unit has an explicit @code{Elaborate_All} pragma for the server\n+unit.\n+@end itemize\n+@end itemize\n \n-   function ABE return Integer is\n-   begin\n-      ...\n-   end ABE;\n-end Guaranteed_ABE;\n-@end example\n+These rules ensure that elaboration checks are not omitted. If the rules are\n+violated, the binder emits a warning:\n \n-In the example above, the elaboration of @code{Guaranteed_ABE}'s body elaborates\n-the declaration of @code{Val}. This invokes function @code{ABE}, however the body\n-of @code{ABE} has not been elaborated yet. GNAT emits similar diagnostics in all\n-three models:\n+@quotation\n \n @example\n-1. package body Guaranteed_ABE is\n-2.    function ABE return Integer;\n-3.\n-4.    Val : constant Integer := ABE;\n-                                |\n-   >>> warning: cannot call \"ABE\" before body seen\n-   >>> warning: Program_Error will be raised at run time\n-\n-5.\n-6.    function ABE return Integer is\n-7.    begin\n-8.       ...\n-9.    end ABE;\n-10. end Guaranteed_ABE;\n+warning: \"x.ads\" has dynamic elaboration checks and with's\n+warning:   \"y.ads\" which has static elaboration checks\n @end example\n-@end itemize\n+@end quotation\n \n-Note that GNAT emits warnings rather than hard errors whenever it encounters an\n-elaboration problem. This is because the elaboration model in effect may be too\n-conservative, or a particular scenario may not be elaborated or executed due to\n-data and control flow. The warnings can be suppressed selectively with @code{pragma\n-Warnigns (Off)} or globally with compiler switch @code{-gnatwL}.\n+The warnings can be suppressed by binder switch @code{-ws}.\n \n-@node Dynamic Elaboration Model in GNAT,Static Elaboration Model in GNAT,Common Elaboration-model Traits,Elaboration Order Handling in GNAT\n-@anchor{gnat_ugn/elaboration_order_handling_in_gnat dynamic-elaboration-model-in-gnat}@anchor{239}@anchor{gnat_ugn/elaboration_order_handling_in_gnat id8}@anchor{23a}\n-@section Dynamic Elaboration Model in GNAT\n+@node ABE Diagnostics,SPARK Diagnostics,Mixing Elaboration Models,Elaboration Order Handling in GNAT\n+@anchor{gnat_ugn/elaboration_order_handling_in_gnat abe-diagnostics}@anchor{239}@anchor{gnat_ugn/elaboration_order_handling_in_gnat id8}@anchor{23a}\n+@section ABE Diagnostics\n \n \n-The dynamic model assumes that all code within all units in a partition is\n-elaboration code. As a result, run-time checks are installed for each scenario\n-regardless of whether the target is internal or external. The checks can be\n-suppressed using pragma @code{Suppress (Elaboration_Check)}. This behavior is\n-identical to that specified by the Ada Reference Manual. The following example\n-showcases run-time checks installed by GNAT to verify the elaboration state of\n-package @code{Dynamic_Model}.\n+GNAT performs extensive diagnostics on a unit-by-unit basis for all scenarios\n+that invoke internal targets, regardless of whether the dynamic, SPARK, or\n+static model is in effect.\n \n-@example\n-with Server;\n-package body Dynamic_Model is\n-   procedure API is\n-   begin\n-      ...\n-   end API;\n+Note that GNAT emits warnings rather than hard errors whenever it encounters an\n+elaboration problem. This is because the elaboration model in effect may be too\n+conservative, or a particular scenario may not be invoked due conditional\n+execution. The warnings can be suppressed selectively with @code{pragma Warnings\n+(Off)} or globally with compiler switch @code{-gnatwL}.\n \n-   <check that the body of Server.Gen is elaborated>\n-   package Inst is new Server.Gen;\n+A @emph{guaranteed ABE} arises when the body of a target is not elaborated early\n+enough, and causes @emph{all} scenarios that directly invoke the target to fail.\n \n-   T : Server.Task_Type;\n+@quotation\n \n-begin\n-   <check that the body of Server.Task_Type is elaborated>\n+@example\n+package body Guaranteed_ABE is\n+   function ABE return Integer;\n \n-   <check that the body of Server.Proc is elaborated>\n-   Server.Proc;\n-end Dynamic_Model;\n-@end example\n+   Val : constant Integer := ABE;\n \n-The checks verify that the body of a target has been successfully elaborated\n-before a scenario activates, calls, or instantiates a target.\n+   function ABE return Integer is\n+   begin\n+     ...\n+   end ABE;\n+end Guaranteed_ABE;\n+@end example\n+@end quotation\n \n-Note that no scenario within package @code{Dynamic_Model} calls procedure @code{API}.\n-In fact, procedure @code{API} may not be invoked by elaboration code within the\n-partition, however the dynamic model assumes that this can happen.\n+In the example above, the elaboration of @code{Guaranteed_ABE}'s body elaborates\n+the declaration of @code{Val}. This invokes function @code{ABE}, however the body of\n+@code{ABE} has not been elaborated yet. GNAT emits the following diagnostic:\n \n-The dynamic model emits very few diagnostics, but can make suggestions on\n-missing @code{Elaborate} and @code{Elaborate_All} pragmas for library-level\n-scenarios. This information is available when compiler switch @code{-gnatel}\n-is in effect.\n+@quotation\n \n @example\n-1. with Server;\n-2. package body Dynamic_Model is\n-3.    Val : constant Integer := Server.Func;\n-                                      |\n-   >>> info: call to \"Func\" during elaboration\n-   >>> info: missing pragma \"Elaborate_All\" for unit \"Server\"\n-\n-4. end Dynamic_Model;\n+4.    Val : constant Integer := ABE;\n+                                |\n+   >>> warning: cannot call \"ABE\" before body seen\n+   >>> warning: Program_Error will be raised at run time\n @end example\n+@end quotation\n \n-@node Static Elaboration Model in GNAT,SPARK Elaboration Model in GNAT,Dynamic Elaboration Model in GNAT,Elaboration Order Handling in GNAT\n-@anchor{gnat_ugn/elaboration_order_handling_in_gnat static-elaboration-model-in-gnat}@anchor{23b}@anchor{gnat_ugn/elaboration_order_handling_in_gnat id9}@anchor{23c}\n-@section Static Elaboration Model in GNAT\n-\n-\n-In contrast to the dynamic model, the static model is more precise in its\n-analysis of elaboration code. The model makes a clear distinction between\n-internal and external targets, and resorts to different diagnostics and\n-run-time checks based on the nature of the target.\n-\n-\n-@itemize *\n-\n-@item \n-@emph{Internal targets}\n+A @emph{conditional ABE} arises when the body of a target is not elaborated early\n+enough, and causes @emph{some} scenarios that directly invoke the target to fail.\n \n-The static model performs extensive diagnostics on scenarios which elaborate\n-or execute internal targets. The warnings resulting from these diagnostics\n-are enabled by default, but can be suppressed selectively with @code{pragma\n-Warnings (Off)} or globally with compiler switch @code{-gnatwL}.\n+@quotation\n \n @example\n- 1. package body Static_Model is\n- 2.    generic\n- 3.       with function Func return Integer;\n- 4.    package Gen is\n- 5.       Val : constant Integer := Func;\n- 6.    end Gen;\n- 7.\n- 8.    function ABE return Integer;\n+ 1. package body Conditional_ABE is\n+ 2.    procedure Force_Body is null;\n+ 3.\n+ 4.    generic\n+ 5.       with function Func return Integer;\n+ 6.    package Gen is\n+ 7.       Val : constant Integer := Func;\n+ 8.    end Gen;\n  9.\n-10.    function Cause_ABE return Boolean is\n-11.       package Inst is new Gen (ABE);\n-          |\n-    >>> warning: in instantiation at line 5\n-    >>> warning: cannot call \"ABE\" before body seen\n-    >>> warning: Program_Error may be raised at run time\n-    >>> warning:   body of unit \"Static_Model\" elaborated\n-    >>> warning:   function \"Cause_ABE\" called at line 16\n-    >>> warning:   function \"ABE\" called at line 5, instance at line 11\n-\n-12.    begin\n-13.       ...\n-14.    end Cause_ABE;\n-15.\n-16.    Val : constant Boolean := Cause_ABE;\n+10.    function ABE return Integer;\n+11.\n+12.    function Cause_ABE return Boolean is\n+13.       package Inst is new Gen (ABE);\n+14.    begin\n+15.       ...\n+16.    end Cause_ABE;\n 17.\n-18.    function ABE return Integer is\n-19.    begin\n-20.       ...\n-21.    end ABE;\n-22. end Static_Model;\n+18.    Val : constant Boolean := Cause_ABE;\n+19.\n+20.    function ABE return Integer is\n+21.    begin\n+22.       ...\n+23.    end ABE;\n+24.\n+25.    Safe : constant Boolean := Cause_ABE;\n+26. end Conditional_ABE;\n @end example\n+@end quotation\n \n-The example above illustrates an ABE problem within package @code{Static_Model},\n-which is hidden by several layers of indirection. The elaboration of package\n-body @code{Static_Model} elaborates the declaration of @code{Val}. This invokes\n-function @code{Cause_ABE}, which instantiates generic unit @code{Gen} as @code{Inst}.\n-The elaboration of @code{Inst} invokes function @code{ABE}, however the body of\n-@code{ABE} has not been elaborated yet.\n-\n-@item \n-@emph{External targets}\n+In the example above, the elaboration of package body @code{Conditional_ABE}\n+elaborates the declaration of @code{Val}. This invokes function @code{Cause_ABE},\n+which instantiates generic unit @code{Gen} as @code{Inst}. The elaboration of\n+@code{Inst} invokes function @code{ABE}, however the body of @code{ABE} has not been\n+elaborated yet. GNAT emits the following diagnostic:\n \n-The static model installs run-time checks to verify the elaboration status\n-of server targets only when the scenario that elaborates or executes that\n-target is part of the elaboration code of the client unit. The checks can be\n-suppressed using pragma @code{Suppress (Elaboration_Check)}.\n+@quotation\n \n @example\n-with Server;\n-package body Static_Model is\n-   generic\n-      with function Func return Integer;\n-   package Gen is\n-      Val : constant Integer := Func;\n-   end Gen;\n-\n-   function Call_Func return Boolean is\n-      <check that the body of Server.Func is elaborated>\n-      package Inst is new Gen (Server.Func);\n-   begin\n-      ...\n-   end Call_Func;\n-\n-   Val : constant Boolean := Call_Func;\n-end Static_Model;\n-@end example\n-\n-In the example above, the elaboration of package body @code{Static_Model}\n-elaborates the declaration of @code{Val}. This invokes function @code{Call_Func},\n-which instantiates generic unit @code{Gen} as @code{Inst}. The elaboration of\n-@code{Inst} invokes function @code{Server.Func}. Since @code{Server.Func} is an\n-external target, GNAT installs a run-time check to verify that its body has\n-been elaborated.\n-\n-In addition to checks, the static model installs implicit @code{Elaborate} and\n-@code{Elaborate_All} pragmas to guarantee safe elaboration use of server units.\n-This information is available when compiler switch @code{-gnatel} is in\n-effect.\n-\n-@example\n- 1. with Server;\n- 2. package body Static_Model is\n- 3.    generic\n- 4.       with function Func return Integer;\n- 5.    package Gen is\n- 6.       Val : constant Integer := Func;\n- 7.    end Gen;\n- 8.\n- 9.    function Call_Func return Boolean is\n-10.       package Inst is new Gen (Server.Func);\n+13.       package Inst is new Gen (ABE);\n           |\n-    >>> info: instantiation of \"Gen\" during elaboration\n-    >>> info: in instantiation at line 6\n-    >>> info: call to \"Func\" during elaboration\n-    >>> info: in instantiation at line 6\n-    >>> info: implicit pragma \"Elaborate_All\" generated for unit \"Server\"\n-    >>> info:   body of unit \"Static_Model\" elaborated\n-    >>> info:   function \"Call_Func\" called at line 15\n-    >>> info:   function \"Func\" called at line 6, instance at line 10\n-\n-11.    begin\n-12.       ...\n-13.    end Call_Func;\n-14.\n-15.    Val : constant Boolean := Call_Func;\n-                                 |\n-    >>> info: call to \"Call_Func\" during elaboration\n-\n-16. end Static_Model;\n+    >>> warning: in instantiation at line 7\n+    >>> warning: cannot call \"ABE\" before body seen\n+    >>> warning: Program_Error may be raised at run time\n+    >>> warning:   body of unit \"Conditional_ABE\" elaborated\n+    >>> warning:   function \"Cause_ABE\" called at line 18\n+    >>> warning:   function \"ABE\" called at line 7, instance at line 13\n @end example\n+@end quotation\n \n-In the example above, the elaboration of package body @code{Static_Model}\n-elaborates the declaration of @code{Val}. This invokes function @code{Call_Func},\n-which instantiates generic unit @code{Gen} as @code{Inst}. The elaboration of\n-@code{Inst} invokes function @code{Server.Func}. Since @code{Server.Func} is an\n-external target, GNAT installs an implicit @code{Elaborate_All} pragma for unit\n-@code{Server}. The pragma guarantees that both the spec and body of @code{Server},\n-along with any additional dependencies that @code{Server} may require, are\n-elaborated prior to the body of @code{Static_Model}.\n-@end itemize\n+Note that the same ABE problem does not occur with the elaboration of\n+declaration @code{Safe} because the body of function @code{ABE} has already been\n+elaborated at that point.\n \n-@node SPARK Elaboration Model in GNAT,Legacy Elaboration Model in GNAT,Static Elaboration Model in GNAT,Elaboration Order Handling in GNAT\n-@anchor{gnat_ugn/elaboration_order_handling_in_gnat id10}@anchor{23d}@anchor{gnat_ugn/elaboration_order_handling_in_gnat spark-elaboration-model-in-gnat}@anchor{23e}\n-@section SPARK Elaboration Model in GNAT\n+@node SPARK Diagnostics,Elaboration Circularities,ABE Diagnostics,Elaboration Order Handling in GNAT\n+@anchor{gnat_ugn/elaboration_order_handling_in_gnat spark-diagnostics}@anchor{23b}@anchor{gnat_ugn/elaboration_order_handling_in_gnat id9}@anchor{23c}\n+@section SPARK Diagnostics\n \n \n-The SPARK model is identical to the static model in its handling of internal\n-targets. The SPARK model, however, requires explicit @code{Elaborate} or\n-@code{Elaborate_All} pragmas to be present in the program when a target is\n-external, and compiler switch @code{-gnatd.v} is in effect.\n+GNAT enforces the SPARK rules of elaboration as defined in the SPARK Reference\n+Manual section 7.7 when compiler switch @code{-gnatd.v} is in effect. Note\n+that GNAT emits hard errors whenever it encounters a violation of the SPARK\n+rules.\n+\n+@quotation\n \n @example\n 1. with Server;\n-2. package body SPARK_Model with SPARK_Mode is\n+2. package body SPARK_Diagnostics with SPARK_Mode is\n 3.    Val : constant Integer := Server.Func;\n                                       |\n    >>> call to \"Func\" during elaboration in SPARK\n-   >>> unit \"SPARK_Model\" requires pragma \"Elaborate_All\" for \"Server\"\n+   >>> unit \"SPARK_Diagnostics\" requires pragma \"Elaborate_All\" for \"Server\"\n    >>>   body of unit \"SPARK_Model\" elaborated\n    >>>   function \"Func\" called at line 3\n \n-4. end SPARK_Model;\n+4. end SPARK_Diagnostics;\n @end example\n+@end quotation\n \n-@node Legacy Elaboration Model in GNAT,Mixing Elaboration Models,SPARK Elaboration Model in GNAT,Elaboration Order Handling in GNAT\n-@anchor{gnat_ugn/elaboration_order_handling_in_gnat legacy-elaboration-model-in-gnat}@anchor{23f}\n-@section Legacy Elaboration Model in GNAT\n-\n-\n-The legacy elaboration model is provided for compatibility with code bases\n-developed with pre-18.x versions of GNAT. It is similar in functionality to\n-the dynamic and static models of post-18.x version of GNAT, but may differ\n-in terms of diagnostics and run-time checks. The legacy elaboration model is\n-enabled with compiler switch @code{-gnatH}.\n-\n-@node Mixing Elaboration Models,Elaboration Circularities,Legacy Elaboration Model in GNAT,Elaboration Order Handling in GNAT\n-@anchor{gnat_ugn/elaboration_order_handling_in_gnat mixing-elaboration-models}@anchor{240}@anchor{gnat_ugn/elaboration_order_handling_in_gnat id11}@anchor{241}\n-@section Mixing Elaboration Models\n-\n-\n-It is possible to mix units compiled with a different elaboration model,\n-however the following rules must be observed:\n-\n-\n-@itemize *\n-\n-@item \n-A client unit compiled with the dynamic model can only @emph{with} a server unit\n-that meets at least one of the following criteria:\n-\n+@node Elaboration Circularities,Resolving Elaboration Circularities,SPARK Diagnostics,Elaboration Order Handling in GNAT\n+@anchor{gnat_ugn/elaboration_order_handling_in_gnat id10}@anchor{23d}@anchor{gnat_ugn/elaboration_order_handling_in_gnat elaboration-circularities}@anchor{23e}\n+@section Elaboration Circularities\n \n-@itemize -\n \n-@item \n-The server unit is compiled with the dynamic model.\n-\n-@item \n-The server unit is a GNAT implementation unit from the Ada, GNAT,\n-Interfaces, or System hierarchies.\n+An @strong{elaboration circularity} occurs whenever the elaboration of a set of\n+units enters a deadlocked state, where each unit is waiting for another unit\n+to be elaborated. This situation may be the result of improper use of @emph{with}\n+clauses, elaboration control pragmas, or invocations in elaboration code.\n \n-@item \n-The server unit has pragma @code{Pure} or @code{Preelaborate}.\n-\n-@item \n-The client unit has an explicit @code{Elaborate_All} pragma for the server\n-unit.\n-@end itemize\n-@end itemize\n+The following example showcases an elaboration circularity.\n \n-These rules ensure that elaboration checks are not omitted. If the rules are\n-violated, the binder emits a warning:\n+@quotation\n \n @example\n-warning: \"x.ads\" has dynamic elaboration checks and with's\n-warning:   \"y.ads\" which has static elaboration checks\n+with B; pragma Elaborate (B);\n+package A is\n+end A;\n @end example\n \n-The warnings can be suppressed by binder switch @code{-ws}.\n-\n-@node Elaboration Circularities,Resolving Elaboration Circularities,Mixing Elaboration Models,Elaboration Order Handling in GNAT\n-@anchor{gnat_ugn/elaboration_order_handling_in_gnat id12}@anchor{242}@anchor{gnat_ugn/elaboration_order_handling_in_gnat elaboration-circularities}@anchor{243}\n-@section Elaboration Circularities\n+@example\n+package B is\n+   procedure Force_Body;\n+end B;\n+@end example\n \n+@example\n+with C;\n+package body B is\n+   procedure Force_Body is null;\n \n-If the binder cannot find an acceptable elaboration order, it outputs detailed\n-diagnostics describing an @strong{elaboration circularity}.\n+   Elab : constant Integer := C.Func;\n+end B;\n+@end example\n \n @example\n-package Server is\n+package C is\n    function Func return Integer;\n-end Server;\n+end C;\n @end example\n \n @example\n-with Client;\n-package body Server is\n+with A;\n+package body C is\n    function Func return Integer is\n    begin\n       ...\n    end Func;\n-end Server;\n+end C;\n @end example\n+@end quotation\n \n-@example\n-with Server;\n-package Client is\n-   Val : constant Integer := Server.Func;\n-end Client;\n-@end example\n+The binder emits the following diagnostic:\n \n-@example\n-with Client;\n-procedure Main is begin null; end Main;\n-@end example\n+@quotation\n \n @example\n-error: elaboration circularity detected\n-info:    \"server (body)\" must be elaborated before \"client (spec)\"\n-info:       reason: implicit Elaborate_All in unit \"client (spec)\"\n-info:       recompile \"client (spec)\" with -gnatel for full details\n-info:          \"server (body)\"\n-info:             must be elaborated along with its spec:\n-info:          \"server (spec)\"\n-info:             which is withed by:\n-info:          \"client (spec)\"\n-info:    \"client (spec)\" must be elaborated before \"server (body)\"\n-info:       reason: with clause\n+error: Elaboration circularity detected\n+info:\n+info:    Reason:\n+info:\n+info:      unit \"a (spec)\" depends on its own elaboration\n+info:\n+info:    Circularity:\n+info:\n+info:      unit \"a (spec)\" has with clause and pragma Elaborate for unit \"b (spec)\"\n+info:      unit \"b (body)\" is in the closure of pragma Elaborate\n+info:      unit \"b (body)\" invokes a construct of unit \"c (body)\" at elaboration time\n+info:      unit \"c (body)\" has with clause for unit \"a (spec)\"\n+info:\n+info:    Suggestions:\n+info:\n+info:      remove pragma Elaborate for unit \"b (body)\" in unit \"a (spec)\"\n+info:      use the dynamic elaboration model (compiler switch -gnatE)\n @end example\n+@end quotation\n \n-In the example above, @code{Client} must be elaborated prior to @code{Main} by virtue\n-of a @emph{with} clause. The elaboration of @code{Client} invokes @code{Server.Func}, and\n-static model generates an implicit @code{Elaborate_All} pragma for @code{Server}. The\n-pragma implies that both the spec and body of @code{Server}, along with any units\n-they @emph{with}, must be elaborated prior to @code{Client}. However, @code{Server}'s body\n-@emph{with}s @code{Client}, implying that @code{Client} must be elaborated prior to\n-@code{Server}. The end result is that @code{Client} must be elaborated prior to\n-@code{Client}, and this leads to a circularity.\n-\n-@node Resolving Elaboration Circularities,Resolving Task Issues,Elaboration Circularities,Elaboration Order Handling in GNAT\n-@anchor{gnat_ugn/elaboration_order_handling_in_gnat id13}@anchor{244}@anchor{gnat_ugn/elaboration_order_handling_in_gnat resolving-elaboration-circularities}@anchor{245}\n-@section Resolving Elaboration Circularities\n-\n-\n-When faced with an elaboration circularity, a programmer has several options\n-available.\n+The diagnostic consist of the following sections:\n \n \n @itemize *\n \n @item \n-@emph{Fix the program}\n+Reason\n \n-The most desirable option from the point of view of long-term maintenance\n-is to rearrange the program so that the elaboration problems are avoided.\n-One useful technique is to place the elaboration code into separate child\n-packages. Another is to move some of the initialization code to explicitly\n-invoked subprograms, where the program controls the order of initialization\n-explicitly. Although this is the most desirable option, it may be impractical\n-and involve too much modification, especially in the case of complex legacy\n-code.\n+This section provides a short explanation describing why the set of units\n+could not be ordered.\n \n @item \n-@emph{Switch to more permissive elaboration model}\n+Circularity\n \n-If the compilation was performed using the static model, enable the dynamic\n-model with compiler switch @code{-gnatE}. GNAT will no longer generate\n-implicit @code{Elaborate} and @code{Elaborate_All} pragmas, resulting in a behavior\n-identical to that specified by the Ada Reference Manual. The binder will\n-generate an executable program that may or may not raise @code{Program_Error},\n-and it is the programmer's responsibility to ensure that it does not raise\n-@code{Program_Error}.\n+This section enumerates the units comprising the deadlocked set, along with\n+their interdependencies.\n \n-If the compilation was performed using a post-18.x version of GNAT, consider\n-using the legacy elaboration model, in the following order:\n+@item \n+Suggestions\n \n+This section enumerates various tactics for eliminating the circularity.\n+@end itemize\n \n-@itemize -\n+@node Resolving Elaboration Circularities,Elaboration-related Compiler Switches,Elaboration Circularities,Elaboration Order Handling in GNAT\n+@anchor{gnat_ugn/elaboration_order_handling_in_gnat id11}@anchor{23f}@anchor{gnat_ugn/elaboration_order_handling_in_gnat resolving-elaboration-circularities}@anchor{240}\n+@section Resolving Elaboration Circularities\n \n-@item \n-Use the relaxed static elaboration model, with compiler switch\n-@code{-gnatJ}.\n \n-@item \n-Use the relaxed dynamic elaboration model, with compiler switches\n-@code{-gnatE} @code{-gnatJ}.\n+The most desirable option from the point of view of long-term maintenance is to\n+rearrange the program so that the elaboration problems are avoided. One useful\n+technique is to place the elaboration code into separate child packages.\n+Another is to move some of the initialization code to explicitly invoked\n+subprograms, where the program controls the order of initialization explicitly.\n+Although this is the most desirable option, it may be impractical and involve\n+too much modification, especially in the case of complex legacy code.\n \n-@item \n-Use the legacy static elaboration model, with compiler switch\n-@code{-gnatH}.\n-\n-@item \n-Use the legacy dynamic elaboration model, with compiler switches\n-@code{-gnatE} @code{-gnatH}.\n-@end itemize\n+When faced with an elaboration circularity, the programmer should also consider\n+the tactics given in the suggestions section of the circularity diagnostic.\n+Depending on the units involved in the circularity, their @emph{with} clauses,\n+purity, preelaborability, presence of elaboration control pragmas and\n+invocations at elaboration time, the binder may suggest one or more of the\n+following tactics to eliminate the circularity:\n \n-@item \n-@emph{Suppress all elaboration checks}\n \n-The drawback of run-time checks is that they generate overhead at run time,\n-both in space and time. If the programmer is absolutely sure that a program\n-will not raise an elaboration-related @code{Program_Error}, then using the\n-pragma @code{Suppress (Elaboration_Check)} globally (as a configuration pragma)\n-will eliminate all run-time checks.\n+@itemize *\n \n @item \n-@emph{Suppress elaboration checks selectively}\n+Pragma Elaborate elimination\n \n-If a scenario cannot possibly lead to an elaboration @code{Program_Error},\n-and the binder nevertheless complains about implicit @code{Elaborate} and\n-@code{Elaborate_All} pragmas that lead to elaboration circularities, it\n-is possible to suppress the generation of implicit @code{Elaborate} and\n-@code{Elaborate_All} pragmas, as well as run-time checks. Clearly this can\n-be unsafe, and it is the responsibility of the programmer to make sure\n-that the resulting program has no elaboration anomalies. Pragma\n-@code{Suppress (Elaboration_Check)} can be used with different levels of\n-granularity to achieve these effects.\n+@example\n+remove pragma Elaborate for unit \"...\" in unit \"...\"\n+@end example\n+\n+This tactic is suggested when the binder has determine that pragma\n+@code{Elaborate}\n \n \n @itemize -\n \n @item \n-@emph{Target suppression}\n+Prevents a set of units from being elaborated.\n \n-When the pragma is placed in a declarative part, without a second argument\n-naming an entity, it will suppress implicit @code{Elaborate} and\n-@code{Elaborate_All} pragma generation, as well as run-time checks, on all\n-targets within the region.\n-\n-@example\n-package Range_Suppress is\n-   pragma Suppress (Elaboration_Check);\n+@item \n+The removal of the pragma will not eliminate the semantic effects of the\n+pragma. In other words, the argument of the pragma will still be elaborated\n+prior to the unit containing the pragma.\n \n-   function Func return Integer;\n+@item \n+The removal of the pragma will enable the successful ordering of the units.\n+@end itemize\n \n-   generic\n-   procedure Gen;\n+The programmer should remove the pragma as advised, and rebuild the program.\n \n-   pragma Unsuppress (Elaboration_Check);\n+@item \n+Pragma Elaborate_All elimination\n \n-   task type Tsk;\n-end Range_Suppress;\n+@example\n+remove pragma Elaborate_All for unit \"...\" in unit \"...\"\n @end example\n \n-In the example above, a pair of Suppress/Unsuppress pragmas define a region\n-of suppression within package @code{Range_Suppress}. As a result, no implicit\n-@code{Elaborate} and @code{Elaborate_All} pragmas, nor any run-time checks, will\n-be generated by callers of @code{Func} and instantiators of @code{Gen}. Note that\n-task type @code{Tsk} is not within this region.\n+This tactic is suggested when the binder has determined that pragma\n+@code{Elaborate_All}\n \n-An alternative to the region-based suppression is to use multiple\n-@code{Suppress} pragmas with arguments naming specific entities for which\n-elaboration checks should be suppressed:\n \n-@example\n-package Range_Suppress is\n-   function Func return Integer;\n-   pragma Suppress (Elaboration_Check, Func);\n-\n-   generic\n-   procedure Gen;\n-   pragma Suppress (Elaboration_Check, Gen);\n-\n-   task type Tsk;\n-end Range_Suppress;\n-@end example\n+@itemize -\n \n @item \n-@emph{Scenario suppression}\n+Prevents a set of units from being elaborated.\n \n-When the pragma @code{Suppress} is placed in a declarative or statement\n-part, without an entity argument, it will suppress implicit @code{Elaborate}\n-and @code{Elaborate_All} pragma generation, as well as run-time checks, on\n-all scenarios within the region.\n-\n-@example\n-with Server;\n-package body Range_Suppress is\n-   pragma Suppress (Elaboration_Check);\n+@item \n+The removal of the pragma will not eliminate the semantic effects of the\n+pragma. In other words, the argument of the pragma along with its @emph{with}\n+closure will still be elaborated prior to the unit containing the pragma.\n \n-   function Func return Integer is\n-   begin\n-      return Server.Func;\n-   end Func;\n+@item \n+The removal of the pragma will enable the successful ordering of the units.\n+@end itemize\n \n-   procedure Gen is\n-   begin\n-      Server.Proc;\n-   end Gen;\n+The programmer should remove the pragma as advised, and rebuild the program.\n \n-   pragma Unsuppress (Elaboration_Check);\n+@item \n+Pragma Elaborate_All downgrade\n \n-   task body Tsk is\n-   begin\n-      Server.Proc;\n-   end Tsk;\n-end Range_Suppress;\n+@example\n+change pragma Elaborate_All for unit \"...\" to Elaborate in unit \"...\"\n @end example\n \n-In the example above, a pair of Suppress/Unsuppress pragmas define a region\n-of suppression within package body @code{Range_Suppress}. As a result, the\n-calls to @code{Server.Func} in @code{Func} and @code{Server.Proc} in @code{Gen} will\n-not generate any implicit @code{Elaborate} and @code{Elaborate_All} pragmas or\n-run-time checks.\n-@end itemize\n-@end itemize\n+This tactic is always suggested with the pragma @code{Elaborate_All} elimination\n+tactic. It offers a different alernative of guaranteeing that the argument of\n+the pragma will still be elaborated prior to the unit containing the pragma.\n \n-@node Resolving Task Issues,Elaboration-related Compiler Switches,Resolving Elaboration Circularities,Elaboration Order Handling in GNAT\n-@anchor{gnat_ugn/elaboration_order_handling_in_gnat id14}@anchor{246}@anchor{gnat_ugn/elaboration_order_handling_in_gnat resolving-task-issues}@anchor{247}\n-@section Resolving Task Issues\n+The programmer should update the pragma as advised, and rebuild the program.\n \n+@item \n+Pragma Elaborate_Body elimination\n \n-The model of execution in Ada dictates that elaboration must first take place,\n-and only then can the main program be started. Tasks which are activated during\n-elaboration violate this model and may lead to serious concurrent problems at\n-elaboration time.\n+@example\n+remove pragma Elaborate_Body in unit \"...\"\n+@end example\n \n-A task can be activated in two different ways:\n+This tactic is suggested when the binder has determined that pragma\n+@code{Elaborate_Body}\n \n \n-@itemize *\n+@itemize -\n \n @item \n-The task is created by an allocator in which case it is activated immediately\n-after the allocator is evaluated.\n+Prevents a set of units from being elaborated.\n \n @item \n-The task is declared at the library level or within some nested master in\n-which case it is activated before starting execution of the statement\n-sequence of the master defining the task.\n+The removal of the pragma will enable the successful ordering of the units.\n @end itemize\n \n-Since the elaboration of a partition is performed by the environment task\n-servicing that partition, any tasks activated during elaboration may be in\n-a race with the environment task, and lead to unpredictable state and behavior.\n-The static model seeks to avoid such interactions by assuming that all code in\n-the task body is executed at elaboration time, if the task was activated by\n-elaboration code.\n-\n-@example\n-package Decls is\n-   task Lib_Task is\n-      entry Start;\n-   end Lib_Task;\n+Note that the binder cannot determine whether the pragma is required for\n+other purposes, such as guaranteeing the initialization of a variable\n+declared in the spec by elaboration code in the body.\n \n-   type My_Int is new Integer;\n+The programmer should remove the pragma as advised, and rebuild the program.\n \n-   function Ident (M : My_Int) return My_Int;\n-end Decls;\n-@end example\n-\n-@example\n-with Utils;\n-package body Decls is\n-   task body Lib_Task is\n-   begin\n-      accept Start;\n-      Utils.Put_Val (2);\n-   end Lib_Task;\n-\n-   function Ident (M : My_Int) return My_Int is\n-   begin\n-      return M;\n-   end Ident;\n-end Decls;\n-@end example\n-\n-@example\n-with Decls;\n-package Utils is\n-   procedure Put_Val (Arg : Decls.My_Int);\n-end Utils;\n-@end example\n+@item \n+Use of dynamic elaboration model\n \n @example\n-with Ada.Text_IO; use Ada.Text_IO;\n-package body Utils is\n-   procedure Put_Val (Arg : Decls.My_Int) is\n-   begin\n-      Put_Line (Arg'Img);\n-   end Put_Val;\n-end Utils;\n+use the dynamic elaboration model (compiler switch -gnatE)\n @end example\n \n-@example\n-with Decls;\n-procedure Main is\n-begin\n-   Decls.Lib_Task.Start;\n-end Main;\n-@end example\n+This tactic is suggested when the binder has determined that an invocation at\n+elaboration time\n \n-When the above example is compiled with the static model, an elaboration\n-circularity arises:\n \n-@example\n-error: elaboration circularity detected\n-info:    \"decls (body)\" must be elaborated before \"decls (body)\"\n-info:       reason: implicit Elaborate_All in unit \"decls (body)\"\n-info:       recompile \"decls (body)\" with -gnatel for full details\n-info:          \"decls (body)\"\n-info:             must be elaborated along with its spec:\n-info:          \"decls (spec)\"\n-info:             which is withed by:\n-info:          \"utils (spec)\"\n-info:             which is withed by:\n-info:          \"decls (body)\"\n-@end example\n+@itemize -\n \n-In the above example, @code{Decls} must be elaborated prior to @code{Main} by virtue\n-of a with clause. The elaboration of @code{Decls} activates task @code{Lib_Task}. The\n-static model conservatibely assumes that all code within the body of\n-@code{Lib_Task} is executed, and generates an implicit @code{Elaborate_All} pragma\n-for @code{Units} due to the call to @code{Utils.Put_Val}. The pragma implies that\n-both the spec and body of @code{Utils}, along with any units they @emph{with},\n-must be elaborated prior to @code{Decls}. However, @code{Utils}'s spec @emph{with}s\n-@code{Decls}, implying that @code{Decls} must be elaborated before @code{Utils}. The end\n-result is that @code{Utils} must be elaborated prior to @code{Utils}, and this\n-leads to a circularity.\n+@item \n+Prevents a set of units from being elaborated.\n \n-In reality, the example above will not exhibit an ABE problem at run time.\n-When the body of task @code{Lib_Task} is activated, execution will wait for entry\n-@code{Start} to be accepted, and the call to @code{Utils.Put_Val} will not take place\n-at elaboration time. Task @code{Lib_Task} will resume its execution after the main\n-program is executed because @code{Main} performs a rendezvous with\n-@code{Lib_Task.Start}, and at that point all units have already been elaborated.\n-As a result, the static model may seem overly conservative, partly because it\n-does not take control and data flow into account.\n+@item \n+The use of the dynamic model will enable the successful ordering of the\n+units.\n+@end itemize\n \n-When faced with a task elaboration circularity, a programmer has several\n-options available:\n+The programmer has two options:\n \n \n-@itemize *\n+@itemize -\n \n @item \n-@emph{Use the dynamic model}\n-\n-The dynamic model does not generate implicit @code{Elaborate} and\n-@code{Elaborate_All} pragmas. Instead, it will install checks prior to every\n-call in the example above, thus verifying the successful elaboration of\n-@code{Utils.Put_Val} in case the call to it takes place at elaboration time.\n-The dynamic model is enabled with compiler switch @code{-gnatE}.\n+Determine the units involved in the invocation using the detailed\n+invocation information, and add compiler switch @code{-gnatE} to the\n+compilation arguments of selected files only. This approach will yield\n+safer elaboration orders compared to the other option because it will\n+minimize the opportunities presented to the dynamic model for ignoring\n+invocations.\n \n @item \n-@emph{Isolate the tasks}\n+Add compiler switch @code{-gnatE} to the general compilation arguments.\n+@end itemize\n \n-Relocating tasks in their own separate package could decouple them from\n-dependencies that would otherwise cause an elaboration circularity. The\n-example above can be rewritten as follows:\n+@item \n+Use of detailed invocation information\n \n @example\n-package Decls1 is                --  new\n-   task Lib_Task is\n-      entry Start;\n-   end Lib_Task;\n-end Decls1;\n+use detailed invocation information (compiler switch -gnatd_F)\n @end example\n \n-@example\n-with Utils;\n-package body Decls1 is           --  new\n-   task body Lib_Task is\n-   begin\n-      accept Start;\n-      Utils.Put_Val (2);\n-   end Lib_Task;\n-end Decls1;\n-@end example\n+This tactic is always suggested with the use of the dynamic model tactic. It\n+causes the circularity section of the circularity diagnostic to describe the\n+flow of elaboration code from a unit to a unit, enumerating all such paths in\n+the process.\n \n-@example\n-package Decls2 is                --  new\n-   type My_Int is new Integer;\n-   function Ident (M : My_Int) return My_Int;\n-end Decls2;\n-@end example\n+The programmer should analyze this information to determine which units\n+should be compiled with the dynamic model.\n \n-@example\n-with Utils;\n-package body Decls2 is           --  new\n-   function Ident (M : My_Int) return My_Int is\n-   begin\n-      return M;\n-   end Ident;\n-end Decls2;\n-@end example\n+@item \n+Forced dependency elimination\n \n @example\n-with Decls2;\n-package Utils is\n-   procedure Put_Val (Arg : Decls2.My_Int);\n-end Utils;\n+remove the dependency of unit \"...\" on unit \"...\" from the argument of switch -f\n @end example\n \n-@example\n-with Ada.Text_IO; use Ada.Text_IO;\n-package body Utils is\n-   procedure Put_Val (Arg : Decls2.My_Int) is\n-   begin\n-      Put_Line (Arg'Img);\n-   end Put_Val;\n-end Utils;\n-@end example\n+This tactic is suggested when the binder has determined that a dependency\n+present in the forced delboration order file indicated by binder switch\n+@code{-f}\n \n-@example\n-with Decls1;\n-procedure Main is\n-begin\n-   Decls1.Lib_Task.Start;\n-end Main;\n-@end example\n+\n+@itemize -\n \n @item \n-@emph{Declare the tasks}\n+Prevents a set of units from being elaborated.\n \n-The original example uses a single task declaration for @code{Lib_Task}. An\n-explicit task type declaration and a properly placed task object could avoid\n-the dependencies that would otherwise cause an elaboration circularity. The\n-example can be rewritten as follows:\n+@item \n+The removal of the dependency will enable the successful ordering of the\n+units.\n+@end itemize\n \n-@example\n-package Decls is\n-   task type Lib_Task is         --  new\n-      entry Start;\n-   end Lib_Task;\n+The programmer should edit the forced elaboration order file, remove the\n+dependency, and rebind the program.\n \n-   type My_Int is new Integer;\n+@item \n+All forced dependency elimination\n \n-   function Ident (M : My_Int) return My_Int;\n-end Decls;\n+@example\n+remove switch -f\n @end example\n \n-@example\n-with Utils;\n-package body Decls is\n-   task body Lib_Task is\n-   begin\n-      accept Start;\n-      Utils.Put_Val (2);\n-   end Lib_Task;\n+This tactic is suggested in case editing the forced elaboration order file is\n+not an option.\n \n-   function Ident (M : My_Int) return My_Int is\n-   begin\n-      return M;\n-   end Ident;\n-end Decls;\n-@end example\n+The programmer should remove binder switch @code{-f} from the binder\n+arguments, and rebind.\n \n-@example\n-with Decls;\n-package Utils is\n-   procedure Put_Val (Arg : Decls.My_Int);\n-end Utils;\n-@end example\n+@item \n+Multiple circularities diagnostic\n \n @example\n-with Ada.Text_IO; use Ada.Text_IO;\n-package body Utils is\n-   procedure Put_Val (Arg : Decls.My_Int) is\n-   begin\n-      Put_Line (Arg'Img);\n-   end Put_Val;\n-end Utils;\n+diagnose all circularities (binder switch -d_C)\n @end example\n \n-@example\n-with Decls;\n-package Obj_Decls is             --  new\n-   Task_Obj : Decls.Lib_Task;\n-end Obj_Decls;\n-@end example\n+By default, the binder will diagnose only the highest precedence circularity.\n+If the program contains multiple circularities, the binder will suggest the\n+use of binder switch @code{-d_C} in order to obtain the diagnostics of all\n+circularities.\n \n-@example\n-with Obj_Decls;\n-procedure Main is\n-begin\n-   Obj_Decls.Task_Obj.Start;     --  new\n-end Main;\n-@end example\n+The programmer should add binder switch @code{-d_C} to the binder\n+arguments, and rebind.\n+@end itemize\n \n-@item \n-@emph{Use restriction No_Entry_Calls_In_Elaboration_Code}\n+If none of the tactics suggested by the binder eliminate the elaboration\n+circularity, the programmer should consider using one of the legacy elaboration\n+models, in the following order:\n \n-The issue exhibited in the original example under this section revolves\n-around the body of @code{Lib_Task} blocking on an accept statement. There is\n-no rule to prevent elaboration code from performing entry calls, however in\n-practice this is highly unusual. In addition, the pattern of starting tasks\n-at elaboration time and then immediately blocking on accept or select\n-statements is quite common.\n \n-If a programmer knows that elaboration code will not perform any entry\n-calls, then the programmer can indicate that the static model should not\n-process the remainder of a task body once an accept or select statement has\n-been encountered. This behavior can be specified by a configuration pragma:\n+@itemize *\n \n-@example\n-pragma Restrictions (No_Entry_Calls_In_Elaboration_Code);\n-@end example\n+@item \n+Use the pre-20.x legacy elaboration order model, with binder switch\n+@code{-H}.\n \n-In addition to the change in behavior with respect to task bodies, the\n-static model will verify that no entry calls take place at elaboration time.\n+@item \n+Use both pre-18.x and pre-20.x legacy elaboration models, with compiler\n+switch @code{-gnatH} and binder switch @code{-H}.\n+\n+@item \n+Use the relaxed static elaboration model, with compiler switches\n+@code{-gnatH} @code{-gnatJ} and binder switch @code{-H}.\n+\n+@item \n+Use the relaxed dynamic elaboration model, with compiler switches\n+@code{-gnatH} @code{-gnatJ} @code{-gnatE} and binder switch\n+@code{-H}.\n @end itemize\n \n-@node Elaboration-related Compiler Switches,Summary of Procedures for Elaboration Control,Resolving Task Issues,Elaboration Order Handling in GNAT\n-@anchor{gnat_ugn/elaboration_order_handling_in_gnat elaboration-related-compiler-switches}@anchor{248}@anchor{gnat_ugn/elaboration_order_handling_in_gnat id15}@anchor{249}\n+@node Elaboration-related Compiler Switches,Summary of Procedures for Elaboration Control,Resolving Elaboration Circularities,Elaboration Order Handling in GNAT\n+@anchor{gnat_ugn/elaboration_order_handling_in_gnat id12}@anchor{241}@anchor{gnat_ugn/elaboration_order_handling_in_gnat elaboration-related-compiler-switches}@anchor{242}\n @section Elaboration-related Compiler Switches\n \n \n@@ -28847,7 +28606,7 @@ the elaboration order chosen by the binder.\n \n Dynamic elaboration checking mode enabled\n \n-When this switch is in effect, GNAT activates the dynamic elaboration model.\n+When this switch is in effect, GNAT activates the dynamic model.\n @end table\n \n @geindex -gnatel (gnat)\n@@ -28859,6 +28618,10 @@ When this switch is in effect, GNAT activates the dynamic elaboration model.\n \n Turn on info messages on generated Elaborate[_All] pragmas\n \n+This switch is only applicable to the pre-20.x legacy elaboration models.\n+The post-20.x elaboration model no longer relies on implicitly generated\n+@code{Elaborate} and @code{Elaborate_All} pragmas to order units.\n+\n When this switch is in effect, GNAT will emit the following supplementary\n information depending on the elaboration model in effect.\n \n@@ -28874,7 +28637,7 @@ all library-level scenarios within the partition.\n @item \n @emph{Static model}\n \n-GNAT will indicate all scenarios executed during elaboration. In addition,\n+GNAT will indicate all scenarios invoked during elaboration. In addition,\n it will provide detailed traceback when an implicit @code{Elaborate} or\n @code{Elaborate_All} pragma is generated.\n \n@@ -29008,7 +28771,7 @@ checks. The example above will still fail at run time with an ABE.\n @end table\n \n @node Summary of Procedures for Elaboration Control,Inspecting the Chosen Elaboration Order,Elaboration-related Compiler Switches,Elaboration Order Handling in GNAT\n-@anchor{gnat_ugn/elaboration_order_handling_in_gnat summary-of-procedures-for-elaboration-control}@anchor{24a}@anchor{gnat_ugn/elaboration_order_handling_in_gnat id16}@anchor{24b}\n+@anchor{gnat_ugn/elaboration_order_handling_in_gnat id13}@anchor{243}@anchor{gnat_ugn/elaboration_order_handling_in_gnat summary-of-procedures-for-elaboration-control}@anchor{244}\n @section Summary of Procedures for Elaboration Control\n \n \n@@ -29036,13 +28799,8 @@ as their origins. Elaboration warnings are enabled with compiler switch\n @code{-gnatwl}.\n \n @item \n-Use switch @code{-gnatel} to obtain messages on generated implicit\n-@code{Elaborate} and @code{Elaborate_All} pragmas. The trace information could\n-indicate why a server unit must be elaborated prior to a client unit.\n-\n-@item \n-If the warnings produced by the static model indicate that a task is\n-involved, consider the options in section @ref{246,,Resolving Task Issues}.\n+Cosider the tactics given in the suggestions section of the circularity\n+diagnostic.\n \n @item \n If none of the steps outlined above resolve the circularity, use a more\n@@ -29052,28 +28810,26 @@ permissive elaboration model, in the following order:\n @itemize -\n \n @item \n-Use the dynamic elaboration model, with compiler switch @code{-gnatE}.\n+Use the pre-20.x legacy elaboration order model, with binder switch\n+@code{-H}.\n \n @item \n-Use the legacy static elaboration model, with compiler switch\n-@code{-gnatH}.\n+Use both pre-18.x and pre-20.x legacy elaboration models, with compiler\n+switch @code{-gnatH} and binder switch @code{-H}.\n \n @item \n-Use the legacy dynamic elaboration model, with compiler switches\n-@code{-gnatH} @code{-gnatE}.\n+Use the relaxed static elaboration model, with compiler switches\n+@code{-gnatH} @code{-gnatJ} and binder switch @code{-H}.\n \n @item \n-Use the relaxed legacy static elaboration model, with compiler switches\n-@code{-gnatH} @code{-gnatJ}.\n-\n-@item \n-Use the relaxed legacy dynamic elaboration model, with compiler switches\n-@code{-gnatH} @code{-gnatJ} @code{-gnatE}.\n+Use the relaxed dynamic elaboration model, with compiler switches\n+@code{-gnatH} @code{-gnatJ} @code{-gnatE} and binder switch\n+@code{-H}.\n @end itemize\n @end itemize\n \n @node Inspecting the Chosen Elaboration Order,,Summary of Procedures for Elaboration Control,Elaboration Order Handling in GNAT\n-@anchor{gnat_ugn/elaboration_order_handling_in_gnat inspecting-the-chosen-elaboration-order}@anchor{24c}@anchor{gnat_ugn/elaboration_order_handling_in_gnat id17}@anchor{24d}\n+@anchor{gnat_ugn/elaboration_order_handling_in_gnat id14}@anchor{245}@anchor{gnat_ugn/elaboration_order_handling_in_gnat inspecting-the-chosen-elaboration-order}@anchor{246}\n @section Inspecting the Chosen Elaboration Order\n \n \n@@ -29083,6 +28839,8 @@ elaboration order appears as a sequence of calls to @code{Elab_Body} and\n @code{Elab_Spec}, interspersed with assignments to @cite{Exxx} which indicates that a\n particular unit is elaborated. For example:\n \n+@quotation\n+\n @example\n System.Soft_Links'Elab_Body;\n E14 := True;\n@@ -29118,10 +28876,13 @@ Ada.Text_Io'Elab_Spec;\n Ada.Text_Io'Elab_Body;\n E07 := True;\n @end example\n+@end quotation\n \n Note also binder switch @code{-l}, which outputs the chosen elaboration\n order and provides a more readable form of the above:\n \n+@quotation\n+\n @example\n ada (spec)\n interfaces (spec)\n@@ -29208,9 +28969,10 @@ ada.text_io (body)\n text_io (spec)\n gdbstr (body)\n @end example\n+@end quotation\n \n @node Inline Assembler,GNU Free Documentation License,Elaboration Order Handling in GNAT,Top\n-@anchor{gnat_ugn/inline_assembler inline-assembler}@anchor{10}@anchor{gnat_ugn/inline_assembler doc}@anchor{24e}@anchor{gnat_ugn/inline_assembler id1}@anchor{24f}\n+@anchor{gnat_ugn/inline_assembler inline-assembler}@anchor{10}@anchor{gnat_ugn/inline_assembler doc}@anchor{247}@anchor{gnat_ugn/inline_assembler id1}@anchor{248}\n @chapter Inline Assembler\n \n \n@@ -29269,7 +29031,7 @@ and with assembly language programming.\n @end menu\n \n @node Basic Assembler Syntax,A Simple Example of Inline Assembler,,Inline Assembler\n-@anchor{gnat_ugn/inline_assembler id2}@anchor{250}@anchor{gnat_ugn/inline_assembler basic-assembler-syntax}@anchor{251}\n+@anchor{gnat_ugn/inline_assembler id2}@anchor{249}@anchor{gnat_ugn/inline_assembler basic-assembler-syntax}@anchor{24a}\n @section Basic Assembler Syntax\n \n \n@@ -29385,7 +29147,7 @@ Intel: Destination first; for example @code{mov eax, 4}@w{ }\n \n \n @node A Simple Example of Inline Assembler,Output Variables in Inline Assembler,Basic Assembler Syntax,Inline Assembler\n-@anchor{gnat_ugn/inline_assembler a-simple-example-of-inline-assembler}@anchor{252}@anchor{gnat_ugn/inline_assembler id3}@anchor{253}\n+@anchor{gnat_ugn/inline_assembler a-simple-example-of-inline-assembler}@anchor{24b}@anchor{gnat_ugn/inline_assembler id3}@anchor{24c}\n @section A Simple Example of Inline Assembler\n \n \n@@ -29534,7 +29296,7 @@ If there are no errors, @code{as} will generate an object file\n @code{nothing.out}.\n \n @node Output Variables in Inline Assembler,Input Variables in Inline Assembler,A Simple Example of Inline Assembler,Inline Assembler\n-@anchor{gnat_ugn/inline_assembler id4}@anchor{254}@anchor{gnat_ugn/inline_assembler output-variables-in-inline-assembler}@anchor{255}\n+@anchor{gnat_ugn/inline_assembler id4}@anchor{24d}@anchor{gnat_ugn/inline_assembler output-variables-in-inline-assembler}@anchor{24e}\n @section Output Variables in Inline Assembler\n \n \n@@ -29901,7 +29663,7 @@ end Get_Flags_3;\n @end quotation\n \n @node Input Variables in Inline Assembler,Inlining Inline Assembler Code,Output Variables in Inline Assembler,Inline Assembler\n-@anchor{gnat_ugn/inline_assembler id5}@anchor{256}@anchor{gnat_ugn/inline_assembler input-variables-in-inline-assembler}@anchor{257}\n+@anchor{gnat_ugn/inline_assembler id5}@anchor{24f}@anchor{gnat_ugn/inline_assembler input-variables-in-inline-assembler}@anchor{250}\n @section Input Variables in Inline Assembler\n \n \n@@ -29990,7 +29752,7 @@ _increment__incr.1:\n @end quotation\n \n @node Inlining Inline Assembler Code,Other Asm Functionality,Input Variables in Inline Assembler,Inline Assembler\n-@anchor{gnat_ugn/inline_assembler id6}@anchor{258}@anchor{gnat_ugn/inline_assembler inlining-inline-assembler-code}@anchor{259}\n+@anchor{gnat_ugn/inline_assembler id6}@anchor{251}@anchor{gnat_ugn/inline_assembler inlining-inline-assembler-code}@anchor{252}\n @section Inlining Inline Assembler Code\n \n \n@@ -30061,7 +29823,7 @@ movl %esi,%eax\n thus saving the overhead of stack frame setup and an out-of-line call.\n \n @node Other Asm Functionality,,Inlining Inline Assembler Code,Inline Assembler\n-@anchor{gnat_ugn/inline_assembler other-asm-functionality}@anchor{25a}@anchor{gnat_ugn/inline_assembler id7}@anchor{25b}\n+@anchor{gnat_ugn/inline_assembler other-asm-functionality}@anchor{253}@anchor{gnat_ugn/inline_assembler id7}@anchor{254}\n @section Other @code{Asm} Functionality\n \n \n@@ -30076,7 +29838,7 @@ and @code{Volatile}, which inhibits unwanted optimizations.\n @end menu\n \n @node The Clobber Parameter,The Volatile Parameter,,Other Asm Functionality\n-@anchor{gnat_ugn/inline_assembler the-clobber-parameter}@anchor{25c}@anchor{gnat_ugn/inline_assembler id8}@anchor{25d}\n+@anchor{gnat_ugn/inline_assembler the-clobber-parameter}@anchor{255}@anchor{gnat_ugn/inline_assembler id8}@anchor{256}\n @subsection The @code{Clobber} Parameter\n \n \n@@ -30140,7 +29902,7 @@ Use 'register' name @code{memory} if you changed a memory location\n @end itemize\n \n @node The Volatile Parameter,,The Clobber Parameter,Other Asm Functionality\n-@anchor{gnat_ugn/inline_assembler the-volatile-parameter}@anchor{25e}@anchor{gnat_ugn/inline_assembler id9}@anchor{25f}\n+@anchor{gnat_ugn/inline_assembler the-volatile-parameter}@anchor{257}@anchor{gnat_ugn/inline_assembler id9}@anchor{258}\n @subsection The @code{Volatile} Parameter\n \n \n@@ -30176,7 +29938,7 @@ to @code{True} only if the compiler's optimizations have created\n problems.\n \n @node GNU Free Documentation License,Index,Inline Assembler,Top\n-@anchor{share/gnu_free_documentation_license gnu-fdl}@anchor{1}@anchor{share/gnu_free_documentation_license doc}@anchor{260}@anchor{share/gnu_free_documentation_license gnu-free-documentation-license}@anchor{261}\n+@anchor{share/gnu_free_documentation_license gnu-fdl}@anchor{1}@anchor{share/gnu_free_documentation_license doc}@anchor{259}@anchor{share/gnu_free_documentation_license gnu-free-documentation-license}@anchor{25a}\n @chapter GNU Free Documentation License\n \n "}, {"sha": "31455592d51445e82dbec61454eb2f4c50892030", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=16cc65b61a7c00920ff66d45d3b23a9e313dd1b8", "patch": "@@ -496,12 +496,6 @@ package body Sem_Elab is\n    --           actual subprograms through generic formal subprograms. As a\n    --           result, the calls are not recorded or processed.\n    --\n-   --  -gnatd_G encode invocation graph in ALI files\n-   --\n-   --           The ABE mechanism encodes the invocation graph of the main\n-   --           unit. This includes elaboration code, as well as invocation\n-   --           constructs.\n-   --\n    --  -gnatd_i ignore activations and calls to instances for elaboration\n    --\n    --           The ABE mechanism ignores calls and task activations when they\n@@ -12192,19 +12186,10 @@ package body Sem_Elab is\n          Main_Cunit : constant Node_Id := Cunit (Main_Unit);\n \n       begin\n-         --  ??? Remove the following use of the debug flag when switching from\n-         --  the old to the new elaboration-order mechanism.\n-\n-         --  Nothing to do when switch -gnatd_G (encode invocation graph in ALI\n-         --  files) is not in effect.\n-\n-         if not Debug_Flag_Underscore_GG then\n-            return False;\n-\n          --  Nothing to do when compiling for GNATprove because the invocation\n          --  graph is not needed.\n \n-         elsif GNATprove_Mode then\n+         if GNATprove_Mode then\n             return False;\n \n          --  Nothing to do when the compilation will not produce an ALI file"}, {"sha": "3902b66c34cf53d17f05854f753a5f03c4c618b4", "filename": "gcc/ada/switch-b.adb", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8/gcc%2Fada%2Fswitch-b.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16cc65b61a7c00920ff66d45d3b23a9e313dd1b8/gcc%2Fada%2Fswitch-b.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-b.adb?ref=16cc65b61a7c00920ff66d45d3b23a9e313dd1b8", "patch": "@@ -353,14 +353,11 @@ package body Switch.B is\n             Ptr := Ptr + 1;\n             Usage_Requested := True;\n \n-         --  ??? Enable the following code when switching from the old to the\n-         --  new elaboration-order mechanism.\n-\n          --  Processing for H switch\n \n-         --  when 'H' =>\n-         --     Ptr := Ptr + 1;\n-         --     Legacy_Elaboration_Order := True;\n+         when 'H' =>\n+            Ptr := Ptr + 1;\n+            Legacy_Elaboration_Order := True;\n \n          --  Processing for i switch\n "}]}