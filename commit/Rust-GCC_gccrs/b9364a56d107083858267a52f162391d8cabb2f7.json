{"sha": "b9364a56d107083858267a52f162391d8cabb2f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjkzNjRhNTZkMTA3MDgzODU4MjY3YTUyZjE2MjM5MWQ4Y2FiYjJmNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-09T20:36:11Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-09T20:36:11Z"}, "message": "Accept qualified aggregates in memset path\n\nAggregates can be surrounded by a qualified expression and this\nprepares the support code in gigi for accepting them.\n\n\t* gcc-interface/trans.c (gnat_to_gnu) <N_Assignment_Statement>: Deal\n\twith qualified \"others\" aggregates in the memset case.", "tree": {"sha": "598b18de55ad4f41f3ff21c5c20957f938d3e11b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/598b18de55ad4f41f3ff21c5c20957f938d3e11b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9364a56d107083858267a52f162391d8cabb2f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9364a56d107083858267a52f162391d8cabb2f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9364a56d107083858267a52f162391d8cabb2f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9364a56d107083858267a52f162391d8cabb2f7/comments", "author": null, "committer": null, "parents": [{"sha": "40bd5a536257aabc0f3899d661debc13dee18d75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40bd5a536257aabc0f3899d661debc13dee18d75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40bd5a536257aabc0f3899d661debc13dee18d75"}], "stats": {"total": 33, "additions": 21, "deletions": 12}, "files": [{"sha": "6aec0eeede1206eced2f7e1e6b5e99ab20f96377", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9364a56d107083858267a52f162391d8cabb2f7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9364a56d107083858267a52f162391d8cabb2f7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b9364a56d107083858267a52f162391d8cabb2f7", "patch": "@@ -1,3 +1,8 @@\n+2020-05-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (gnat_to_gnu) <N_Assignment_Statement>: Deal\n+\twith qualified \"others\" aggregates in the memset case.\n+\n 2020-05-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_param): Also back-annotate the"}, {"sha": "5de04abb97fab5fb6a598ce78222781ea1a9e597", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9364a56d107083858267a52f162391d8cabb2f7/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9364a56d107083858267a52f162391d8cabb2f7/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=b9364a56d107083858267a52f162391d8cabb2f7", "patch": "@@ -7813,25 +7813,29 @@ gnat_to_gnu (Node_Id gnat_node)\n       else\n \t{\n \t  const Node_Id gnat_expr = Expression (gnat_node);\n+\t  const Node_Id gnat_inner\n+\t    = Nkind (gnat_expr) == N_Qualified_Expression\n+\t      ? Expression (gnat_expr)\n+\t      : gnat_expr;\n \t  const Entity_Id gnat_type\n \t    = Underlying_Type (Etype (Name (gnat_node)));\n \t  const bool regular_array_type_p\n-\t    = (Is_Array_Type (gnat_type) && !Is_Bit_Packed_Array (gnat_type));\n+\t    = Is_Array_Type (gnat_type) && !Is_Bit_Packed_Array (gnat_type);\n \t  const bool use_memset_p\n-\t    = (regular_array_type_p\n-\t       && Nkind (gnat_expr) == N_Aggregate\n-\t       && Is_Others_Aggregate (gnat_expr));\n+\t    = regular_array_type_p\n+\t      && Nkind (gnat_inner) == N_Aggregate\n+\t      && Is_Others_Aggregate (gnat_inner);\n \n-\t  /* If we'll use memset, we need to find the inner expression.  */\n+\t  /* If we use memset, we need to find the innermost expression.  */\n \t  if (use_memset_p)\n \t    {\n-\t      Node_Id gnat_inner\n-\t\t= Expression (First (Component_Associations (gnat_expr)));\n-\t      while (Nkind (gnat_inner) == N_Aggregate\n-\t\t     && Is_Others_Aggregate (gnat_inner))\n-\t\tgnat_inner\n-\t\t  = Expression (First (Component_Associations (gnat_inner)));\n-\t      gnu_rhs = gnat_to_gnu (gnat_inner);\n+\t      gnat_temp = gnat_inner;\n+\t      do {\n+\t\tgnat_temp\n+\t\t  = Expression (First (Component_Associations (gnat_temp)));\n+\t      } while (Nkind (gnat_temp) == N_Aggregate\n+\t\t       && Is_Others_Aggregate (gnat_temp));\n+\t      gnu_rhs = gnat_to_gnu (gnat_temp);\n \t    }\n \t  else\n \t    gnu_rhs = maybe_unconstrained_array (gnat_to_gnu (gnat_expr));"}]}