{"sha": "7c13a2e5873f5919c00b5f37b6db52af8d0f7300", "node_id": "C_kwDOANBUbNoAKDdjMTNhMmU1ODczZjU5MTljMDBiNWYzN2I2ZGI1MmFmOGQwZjczMDA", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-07-16T16:01:47Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:24Z"}, "message": "gccrs const folding port: start porting cxx_eval_array_reference()\n\nFollowing functions are ported in this changeset:\n - array_index_cmp\n - unshare_constructor\n - find_array_ctor_elt\n - reduced_constant_expression_p\n - verify_constant\n - diag_array_subscript\n - get_array_or_vector_nelts\n - eval_and_check_array_index\n - extract_string_elt\n - free_constructor\n - cv_unqualified\n - make_tree_vector\n - release_tree_vector\n - vec_safe_push\n\nFollowing structs, classes and enums are ported in this changeset:\n - releasing_vec\n\nSigned-off-by: Faisal Abbas <90.abbasfaisal@gmail.com>", "tree": {"sha": "b62ac124ec3048924b4bcb50fa81278955be3426", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b62ac124ec3048924b4bcb50fa81278955be3426"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c13a2e5873f5919c00b5f37b6db52af8d0f7300", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c13a2e5873f5919c00b5f37b6db52af8d0f7300", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c13a2e5873f5919c00b5f37b6db52af8d0f7300", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c13a2e5873f5919c00b5f37b6db52af8d0f7300/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5b583d021a4cbbfafecc28445709afe32cdd1c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5b583d021a4cbbfafecc28445709afe32cdd1c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5b583d021a4cbbfafecc28445709afe32cdd1c8"}], "stats": {"total": 670, "additions": 653, "deletions": 17}, "files": [{"sha": "8fb378fbda508a6277c184ebabdb989ca6ebd17c", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 532, "deletions": 17, "changes": 549, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c13a2e5873f5919c00b5f37b6db52af8d0f7300/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c13a2e5873f5919c00b5f37b6db52af8d0f7300/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=7c13a2e5873f5919c00b5f37b6db52af8d0f7300", "patch": "@@ -25,10 +25,27 @@\n #include \"print-tree.h\"\n #include \"gimplify.h\"\n #include \"tree-iterator.h\"\n+#include \"varasm.h\"\n+\n+#define VERIFY_CONSTANT(X)                                                     \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      if (verify_constant ((X), ctx->quiet, non_constant_p, overflow_p))       \\\n+\treturn t;                                                              \\\n+    }                                                                          \\\n+  while (0)\n \n namespace Rust {\n namespace Compile {\n \n+static bool\n+verify_constant (tree, bool, bool *, bool *);\n+\n+static HOST_WIDE_INT\n+find_array_ctor_elt (tree ary, tree dindex, bool insert = false);\n+static int\n+array_index_cmp (tree key, tree index);\n+\n struct constexpr_global_ctx\n {\n   HOST_WIDE_INT constexpr_ops_count;\n@@ -38,7 +55,19 @@ struct constexpr_global_ctx\n \n struct constexpr_ctx\n {\n+  /* The part of the context that needs to be unique to the whole\n+   cxx_eval_outermost_constant_expr invocation.  */\n   constexpr_global_ctx *global;\n+\n+  /* Whether we should error on a non-constant expression or fail quietly.\n+    This flag needs to be here, but some of the others could move to global\n+    if they get larger than a word.  */\n+  bool quiet;\n+  /* The object we're building the CONSTRUCTOR for.  */\n+  tree object;\n+  /* The CONSTRUCTOR we're currently building up for an aggregate\n+     initializer.  */\n+  tree ctor;\n };\n \n static tree\n@@ -51,19 +80,20 @@ static void\n non_const_var_error (location_t loc, tree r);\n \n static tree\n-constexpr_expression (const constexpr_ctx *ctx, tree);\n+constexpr_expression (const constexpr_ctx *ctx, tree, bool, bool *, bool *,\n+\t\t      tree * = NULL);\n \n static tree\n constexpr_fn_retval (const constexpr_ctx *ctx, tree r);\n \n static tree\n-eval_store_expression (const constexpr_ctx *ctx, tree r);\n+eval_store_expression (const constexpr_ctx *ctx, tree r, bool, bool *, bool *);\n \n static tree\n eval_call_expression (const constexpr_ctx *ctx, tree r);\n \n static tree\n-eval_binary_expression (const constexpr_ctx *ctx, tree r);\n+eval_binary_expression (const constexpr_ctx *ctx, tree r, bool, bool *, bool *);\n \n static tree\n get_function_named_in_call (tree t);\n@@ -72,15 +102,20 @@ tree\n fold_expr (tree expr)\n {\n   constexpr_global_ctx global_ctx;\n-  constexpr_ctx ctx = {&global_ctx};\n+  constexpr_ctx ctx = {&global_ctx, false};\n+  bool non_constant_p = false;\n+  bool overflow_p = false;\n \n-  tree folded = constexpr_expression (&ctx, expr);\n+  tree folded\n+    = constexpr_expression (&ctx, expr, false, &non_constant_p, &overflow_p);\n   rust_assert (folded != NULL_TREE);\n   return folded;\n }\n \n static tree\n-constexpr_expression (const constexpr_ctx *ctx, tree t)\n+constexpr_expression (const constexpr_ctx *ctx, tree t, bool lval,\n+\t\t      bool *non_constant_p, bool *overflow_p,\n+\t\t      tree *jump_target /* = NULL */)\n {\n   location_t loc = EXPR_LOCATION (t);\n \n@@ -165,7 +200,7 @@ constexpr_expression (const constexpr_ctx *ctx, tree t)\n     case LTGT_EXPR:\n     case RANGE_EXPR:\n     case COMPLEX_EXPR:\n-      r = eval_binary_expression (ctx, t);\n+      r = eval_binary_expression (ctx, t, false, non_constant_p, overflow_p);\n       break;\n \n     case CALL_EXPR:\n@@ -174,11 +209,12 @@ constexpr_expression (const constexpr_ctx *ctx, tree t)\n \n     case RETURN_EXPR:\n       rust_assert (TREE_OPERAND (t, 0) != NULL_TREE);\n-      r = constexpr_expression (ctx, TREE_OPERAND (t, 0));\n+      r = constexpr_expression (ctx, TREE_OPERAND (t, 0), false, non_constant_p,\n+\t\t\t\toverflow_p);\n       break;\n \n     case MODIFY_EXPR:\n-      r = eval_store_expression (ctx, t);\n+      r = eval_store_expression (ctx, t, false, non_constant_p, overflow_p);\n       break;\n \n     default:\n@@ -189,7 +225,8 @@ constexpr_expression (const constexpr_ctx *ctx, tree t)\n }\n \n static tree\n-eval_store_expression (const constexpr_ctx *ctx, tree t)\n+eval_store_expression (const constexpr_ctx *ctx, tree t, bool lval,\n+\t\t       bool *non_constant_p, bool *overflow_p)\n {\n   tree init = TREE_OPERAND (t, 1);\n   if (TREE_CLOBBER_P (init))\n@@ -219,7 +256,8 @@ eval_store_expression (const constexpr_ctx *ctx, tree t)\n \t    object = probe;\n \t  else\n \t    {\n-\t      probe = constexpr_expression (ctx, probe);\n+\t      probe = constexpr_expression (ctx, probe, lval, non_constant_p,\n+\t\t\t\t\t    overflow_p);\n \t      evaluated = true;\n \t    }\n \t  break;\n@@ -232,14 +270,15 @@ eval_store_expression (const constexpr_ctx *ctx, tree t)\n /* Subroutine of cxx_eval_constant_expression.\n  Like cxx_eval_unary_expression, except for binary expressions.  */\n static tree\n-eval_binary_expression (const constexpr_ctx *ctx, tree t)\n+eval_binary_expression (const constexpr_ctx *ctx, tree t, bool lval,\n+\t\t\tbool *non_constant_p, bool *overflow_p)\n {\n   tree orig_lhs = TREE_OPERAND (t, 0);\n   tree orig_rhs = TREE_OPERAND (t, 1);\n   tree lhs, rhs;\n \n-  lhs = constexpr_expression (ctx, orig_lhs);\n-  rhs = constexpr_expression (ctx, orig_rhs);\n+  lhs = constexpr_expression (ctx, orig_lhs, lval, non_constant_p, overflow_p);\n+  rhs = constexpr_expression (ctx, orig_rhs, lval, non_constant_p, overflow_p);\n \n   location_t loc = EXPR_LOCATION (t);\n   enum tree_code code = TREE_CODE (t);\n@@ -285,9 +324,12 @@ constexpr_fn_retval (const constexpr_ctx *ctx, tree body)\n \treturn expr;\n       }\n \n-    case RETURN_EXPR:\n-      return constexpr_expression (ctx, body);\n-\n+      case RETURN_EXPR: {\n+\tbool non_constant_p = false;\n+\tbool overflow_p = false;\n+\treturn constexpr_expression (ctx, body, false, &non_constant_p,\n+\t\t\t\t     &overflow_p);\n+      }\n       case DECL_EXPR: {\n \ttree decl = DECL_EXPR_DECL (body);\n \tif (TREE_CODE (decl) == USING_DECL\n@@ -437,5 +479,478 @@ var_in_maybe_constexpr_fn (tree t)\n   return (DECL_FUNCTION_SCOPE_P (t) && maybe_constexpr_fn (DECL_CONTEXT (t)));\n }\n \n+// forked from gcc/cp/constexpr.cc array_index_cmp\n+\n+/* Returns less than, equal to, or greater than zero if KEY is found to be\n+   less than, to match, or to be greater than the constructor_elt's INDEX.  */\n+\n+static int\n+array_index_cmp (tree key, tree index)\n+{\n+  gcc_assert (TREE_CODE (key) == INTEGER_CST);\n+\n+  switch (TREE_CODE (index))\n+    {\n+    case INTEGER_CST:\n+      return tree_int_cst_compare (key, index);\n+      case RANGE_EXPR: {\n+\ttree lo = TREE_OPERAND (index, 0);\n+\ttree hi = TREE_OPERAND (index, 1);\n+\tif (tree_int_cst_lt (key, lo))\n+\t  return -1;\n+\telse if (tree_int_cst_lt (hi, key))\n+\t  return 1;\n+\telse\n+\t  return 0;\n+      }\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+// forked from gcc/cp/constexpr.cc unshare_constructor\n+\n+/* If T is a CONSTRUCTOR, return an unshared copy of T and any\n+   sub-CONSTRUCTORs.  Otherwise return T.\n+\n+   We use this whenever we initialize an object as a whole, whether it's a\n+   parameter, a local variable, or a subobject, so that subsequent\n+   modifications don't affect other places where it was used.  */\n+\n+tree\n+unshare_constructor (tree t MEM_STAT_DECL)\n+{\n+  if (!t || TREE_CODE (t) != CONSTRUCTOR)\n+    return t;\n+  auto_vec<tree *, 4> ptrs;\n+  ptrs.safe_push (&t);\n+  while (!ptrs.is_empty ())\n+    {\n+      tree *p = ptrs.pop ();\n+      tree n = copy_node (*p PASS_MEM_STAT);\n+      CONSTRUCTOR_ELTS (n)\n+\t= vec_safe_copy (CONSTRUCTOR_ELTS (*p) PASS_MEM_STAT);\n+      *p = n;\n+      vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (n);\n+      constructor_elt *ce;\n+      for (HOST_WIDE_INT i = 0; vec_safe_iterate (v, i, &ce); ++i)\n+\tif (ce->value && TREE_CODE (ce->value) == CONSTRUCTOR)\n+\t  ptrs.safe_push (&ce->value);\n+    }\n+  return t;\n+}\n+\n+// forked from gcc/cp/constexpr.cc find_array_ctor_elt\n+\n+/* Returns the index of the constructor_elt of ARY which matches DINDEX, or -1\n+   if none.  If INSERT is true, insert a matching element rather than fail.  */\n+\n+static HOST_WIDE_INT\n+find_array_ctor_elt (tree ary, tree dindex, bool insert)\n+{\n+  if (tree_int_cst_sgn (dindex) < 0)\n+    return -1;\n+\n+  unsigned HOST_WIDE_INT i = tree_to_uhwi (dindex);\n+  vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (ary);\n+  unsigned HOST_WIDE_INT len = vec_safe_length (elts);\n+\n+  unsigned HOST_WIDE_INT end = len;\n+  unsigned HOST_WIDE_INT begin = 0;\n+\n+  /* If the last element of the CONSTRUCTOR has its own index, we can assume\n+     that the same is true of the other elements and index directly.  */\n+  if (end > 0)\n+    {\n+      tree cindex = (*elts)[end - 1].index;\n+      if (cindex == NULL_TREE)\n+\t{\n+\t  /* Verify that if the last index is missing, all indexes\n+\t     are missing.  */\n+\t  if (flag_checking)\n+\t    for (unsigned int j = 0; j < len - 1; ++j)\n+\t      gcc_assert ((*elts)[j].index == NULL_TREE);\n+\t  if (i < end)\n+\t    return i;\n+\t  else\n+\t    {\n+\t      begin = end;\n+\t      if (i == end)\n+\t\t/* If the element is to be added right at the end,\n+\t\t   make sure it is added with cleared index too.  */\n+\t\tdindex = NULL_TREE;\n+\t      else if (insert)\n+\t\t/* Otherwise, in order not to break the assumption\n+\t\t   that CONSTRUCTOR either has all indexes or none,\n+\t\t   we need to add indexes to all elements.  */\n+\t\tfor (unsigned int j = 0; j < len; ++j)\n+\t\t  (*elts)[j].index = build_int_cst (TREE_TYPE (dindex), j);\n+\t    }\n+\t}\n+      else if (TREE_CODE (cindex) == INTEGER_CST\n+\t       && compare_tree_int (cindex, end - 1) == 0)\n+\t{\n+\t  if (i < end)\n+\t    return i;\n+\t  else\n+\t    begin = end;\n+\t}\n+    }\n+\n+  /* Otherwise, find a matching index by means of a binary search.  */\n+  while (begin != end)\n+    {\n+      unsigned HOST_WIDE_INT middle = (begin + end) / 2;\n+      constructor_elt &elt = (*elts)[middle];\n+      tree idx = elt.index;\n+\n+      int cmp = array_index_cmp (dindex, idx);\n+      if (cmp < 0)\n+\tend = middle;\n+      else if (cmp > 0)\n+\tbegin = middle + 1;\n+      else\n+\t{\n+\t  if (insert && TREE_CODE (idx) == RANGE_EXPR)\n+\t    {\n+\t      /* We need to split the range.  */\n+\t      constructor_elt e;\n+\t      tree lo = TREE_OPERAND (idx, 0);\n+\t      tree hi = TREE_OPERAND (idx, 1);\n+\t      tree value = elt.value;\n+\t      dindex = fold_convert (sizetype, dindex);\n+\t      if (tree_int_cst_lt (lo, dindex))\n+\t\t{\n+\t\t  /* There are still some lower elts; shorten the range.  */\n+\t\t  tree new_hi\n+\t\t    = int_const_binop (MINUS_EXPR, dindex, size_one_node);\n+\t\t  if (tree_int_cst_equal (lo, new_hi))\n+\t\t    /* Only one element left, no longer a range.  */\n+\t\t    elt.index = lo;\n+\t\t  else\n+\t\t    TREE_OPERAND (idx, 1) = new_hi;\n+\t\t  /* Append the element we want to insert.  */\n+\t\t  ++middle;\n+\t\t  e.index = dindex;\n+\t\t  e.value = unshare_constructor (value);\n+\t\t  vec_safe_insert (CONSTRUCTOR_ELTS (ary), middle, e);\n+\t\t}\n+\t      else\n+\t\t/* No lower elts, the range elt is now ours.  */\n+\t\telt.index = dindex;\n+\n+\t      if (tree_int_cst_lt (dindex, hi))\n+\t\t{\n+\t\t  /* There are still some higher elts; append a range.  */\n+\t\t  tree new_lo\n+\t\t    = int_const_binop (PLUS_EXPR, dindex, size_one_node);\n+\t\t  if (tree_int_cst_equal (new_lo, hi))\n+\t\t    e.index = hi;\n+\t\t  else\n+\t\t    e.index = build2 (RANGE_EXPR, sizetype, new_lo, hi);\n+\t\t  e.value = unshare_constructor (value);\n+\t\t  vec_safe_insert (CONSTRUCTOR_ELTS (ary), middle + 1, e);\n+\t\t}\n+\t    }\n+\t  return middle;\n+\t}\n+    }\n+\n+  if (insert)\n+    {\n+      constructor_elt e = {dindex, NULL_TREE};\n+      vec_safe_insert (CONSTRUCTOR_ELTS (ary), end, e);\n+      return end;\n+    }\n+\n+  return -1;\n+}\n+\n+// forked from gcc/cp/constexpr.cc reduced_constant_expression_p\n+\n+/* Return true if T is a valid constant initializer.  If a CONSTRUCTOR\n+   initializes all the members, the CONSTRUCTOR_NO_CLEARING flag will be\n+   cleared.\n+   FIXME speed this up, it's taking 16% of compile time on sieve testcase.  */\n+\n+bool\n+reduced_constant_expression_p (tree t)\n+{\n+  if (t == NULL_TREE)\n+    return false;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case PTRMEM_CST:\n+      /* Even if we can't lower this yet, it's constant.  */\n+      return true;\n+\n+    case CONSTRUCTOR:\n+      /* And we need to handle PTRMEM_CST wrapped in a CONSTRUCTOR.  */\n+      tree field;\n+      if (CONSTRUCTOR_NO_CLEARING (t))\n+\t{\n+\t  if (TREE_CODE (TREE_TYPE (t)) == VECTOR_TYPE)\n+\t    /* An initialized vector would have a VECTOR_CST.  */\n+\t    return false;\n+\t  else if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n+\t    {\n+\t      /* There must be a valid constant initializer at every array\n+\t\t index.  */\n+\t      tree min = TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (t)));\n+\t      tree max = TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (t)));\n+\t      tree cursor = min;\n+\t      for (auto &e : CONSTRUCTOR_ELTS (t))\n+\t\t{\n+\t\t  if (!reduced_constant_expression_p (e.value))\n+\t\t    return false;\n+\t\t  if (array_index_cmp (cursor, e.index) != 0)\n+\t\t    return false;\n+\t\t  if (TREE_CODE (e.index) == RANGE_EXPR)\n+\t\t    cursor = TREE_OPERAND (e.index, 1);\n+\t\t  cursor = int_const_binop (PLUS_EXPR, cursor, size_one_node);\n+\t\t}\n+\t      if (find_array_ctor_elt (t, max) == -1)\n+\t\treturn false;\n+\t      goto ok;\n+\t    }\n+\t  else if (TREE_CODE (TREE_TYPE (t)) == UNION_TYPE)\n+\t    {\n+\t      if (CONSTRUCTOR_NELTS (t) == 0)\n+\t\t/* An initialized union has a constructor element.  */\n+\t\treturn false;\n+\t      /* And it only initializes one member.  */\n+\t      field = NULL_TREE;\n+\t    }\n+\t  else\n+\t    field = next_initializable_field (TYPE_FIELDS (TREE_TYPE (t)));\n+\t}\n+      else\n+\tfield = NULL_TREE;\n+      for (auto &e : CONSTRUCTOR_ELTS (t))\n+\t{\n+\t  /* If VAL is null, we're in the middle of initializing this\n+\t     element.  */\n+\t  if (!reduced_constant_expression_p (e.value))\n+\t    return false;\n+\t  /* Empty class field may or may not have an initializer.  */\n+\t  for (; field && e.index != field;\n+\t       field = next_initializable_field (DECL_CHAIN (field)))\n+\t    if (!is_really_empty_class (TREE_TYPE (field),\n+\t\t\t\t\t/*ignore_vptr*/ false))\n+\t      return false;\n+\t  if (field)\n+\t    field = next_initializable_field (DECL_CHAIN (field));\n+\t}\n+      /* There could be a non-empty field at the end.  */\n+      for (; field; field = next_initializable_field (DECL_CHAIN (field)))\n+\tif (!is_really_empty_class (TREE_TYPE (field), /*ignore_vptr*/ false))\n+\t  return false;\n+    ok:\n+      if (CONSTRUCTOR_NO_CLEARING (t))\n+\t/* All the fields are initialized.  */\n+\tCONSTRUCTOR_NO_CLEARING (t) = false;\n+      return true;\n+\n+    default:\n+      /* FIXME are we calling this too much?  */\n+      return initializer_constant_valid_p (t, TREE_TYPE (t)) != NULL_TREE;\n+    }\n+}\n+\n+// forked from gcc/cp/constexpr.cc verify_constant\n+\n+/* Some expressions may have constant operands but are not constant\n+   themselves, such as 1/0.  Call this function to check for that\n+   condition.\n+\n+   We only call this in places that require an arithmetic constant, not in\n+   places where we might have a non-constant expression that can be a\n+   component of a constant expression, such as the address of a constexpr\n+   variable that might be dereferenced later.  */\n+\n+static bool\n+verify_constant (tree t, bool allow_non_constant, bool *non_constant_p,\n+\t\t bool *overflow_p)\n+{\n+  if (!*non_constant_p && !reduced_constant_expression_p (t) && t != void_node)\n+    {\n+      if (!allow_non_constant)\n+\terror (\"%q+E is not a constant expression\", t);\n+      *non_constant_p = true;\n+    }\n+  if (TREE_OVERFLOW_P (t))\n+    {\n+      if (!allow_non_constant)\n+\t{\n+\t  permerror (input_location, \"overflow in constant expression\");\n+\t  /* If we're being permissive (and are in an enforcing\n+\t     context), ignore the overflow.  */\n+\t  if (flag_permissive)\n+\t    return *non_constant_p;\n+\t}\n+      *overflow_p = true;\n+    }\n+  return *non_constant_p;\n+}\n+\n+// forked in gcc/cp/constexpr.cc diag_array_subscript\n+\n+/* Under the control of CTX, issue a detailed diagnostic for\n+   an out-of-bounds subscript INDEX into the expression ARRAY.  */\n+\n+static void\n+diag_array_subscript (location_t loc, const constexpr_ctx *ctx, tree array,\n+\t\t      tree index)\n+{\n+  if (!ctx->quiet)\n+    {\n+      tree arraytype = TREE_TYPE (array);\n+\n+      /* Convert the unsigned array subscript to a signed integer to avoid\n+\t printing huge numbers for small negative values.  */\n+      tree sidx = fold_convert (ssizetype, index);\n+      STRIP_ANY_LOCATION_WRAPPER (array);\n+      if (DECL_P (array))\n+\t{\n+\t  if (TYPE_DOMAIN (arraytype))\n+\t    error_at (loc,\n+\t\t      \"array subscript value %qE is outside the bounds \"\n+\t\t      \"of array %qD of type %qT\",\n+\t\t      sidx, array, arraytype);\n+\t  else\n+\t    error_at (loc,\n+\t\t      \"nonzero array subscript %qE is used with array %qD of \"\n+\t\t      \"type %qT with unknown bounds\",\n+\t\t      sidx, array, arraytype);\n+\t  inform (DECL_SOURCE_LOCATION (array), \"declared here\");\n+\t}\n+      else if (TYPE_DOMAIN (arraytype))\n+\terror_at (loc,\n+\t\t  \"array subscript value %qE is outside the bounds \"\n+\t\t  \"of array type %qT\",\n+\t\t  sidx, arraytype);\n+      else\n+\terror_at (loc,\n+\t\t  \"nonzero array subscript %qE is used with array of type %qT \"\n+\t\t  \"with unknown bounds\",\n+\t\t  sidx, arraytype);\n+    }\n+}\n+\n+// forked from gcc/cp/constexpr.cc get_array_or_vector_nelts\n+\n+/* Return the number of elements for TYPE (which is an ARRAY_TYPE or\n+   a VECTOR_TYPE).  */\n+\n+static tree\n+get_array_or_vector_nelts (const constexpr_ctx *ctx, tree type,\n+\t\t\t   bool *non_constant_p, bool *overflow_p)\n+{\n+  tree nelts;\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      if (TYPE_DOMAIN (type))\n+\tnelts = array_type_nelts_top (type);\n+      else\n+\tnelts = size_zero_node;\n+    }\n+  else if (VECTOR_TYPE_P (type))\n+    nelts = size_int (TYPE_VECTOR_SUBPARTS (type));\n+  else\n+    gcc_unreachable ();\n+\n+  /* For VLAs, the number of elements won't be an integer constant.  */\n+  nelts = constexpr_expression (ctx, nelts, false, non_constant_p, overflow_p);\n+  return nelts;\n+}\n+\n+// forked from gcc/cp/constexpr.cc eval_and_check_array_index\n+\n+/* Subroutine of cxx_eval_array_reference.  T is an ARRAY_REF; evaluate the\n+   subscript, diagnose any problems with it, and return the result.  */\n+\n+static tree\n+eval_and_check_array_index (const constexpr_ctx *ctx, tree t,\n+\t\t\t    bool allow_one_past, bool *non_constant_p,\n+\t\t\t    bool *overflow_p)\n+{\n+  location_t loc = rs_expr_loc_or_input_loc (t);\n+  tree ary = TREE_OPERAND (t, 0);\n+  t = TREE_OPERAND (t, 1);\n+  tree index\n+    = constexpr_expression (ctx, t, allow_one_past, non_constant_p, overflow_p);\n+  VERIFY_CONSTANT (index);\n+\n+  if (!tree_fits_shwi_p (index) || tree_int_cst_sgn (index) < 0)\n+    {\n+      diag_array_subscript (loc, ctx, ary, index);\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n+  tree nelts = get_array_or_vector_nelts (ctx, TREE_TYPE (ary), non_constant_p,\n+\t\t\t\t\t  overflow_p);\n+  VERIFY_CONSTANT (nelts);\n+  if (allow_one_past ? !tree_int_cst_le (index, nelts)\n+\t\t     : !tree_int_cst_lt (index, nelts))\n+    {\n+      diag_array_subscript (loc, ctx, ary, index);\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n+  return index;\n+}\n+\n+// forked from gcc/cp/constexpr.cc extract_string_elt\n+\n+/* Extract element INDEX consisting of CHARS_PER_ELT chars from\n+   STRING_CST STRING.  */\n+\n+static tree\n+extract_string_elt (tree string, unsigned chars_per_elt, unsigned index)\n+{\n+  tree type = cv_unqualified (TREE_TYPE (TREE_TYPE (string)));\n+  tree r;\n+\n+  if (chars_per_elt == 1)\n+    r = build_int_cst (type, TREE_STRING_POINTER (string)[index]);\n+  else\n+    {\n+      const unsigned char *ptr\n+\t= ((const unsigned char *) TREE_STRING_POINTER (string)\n+\t   + index * chars_per_elt);\n+      r = native_interpret_expr (type, ptr, chars_per_elt);\n+    }\n+  return r;\n+}\n+\n+// forked from gcc/cp/constexpr.cc free_constructor\n+\n+/* If T is a CONSTRUCTOR, ggc_free T and any sub-CONSTRUCTORs.  */\n+\n+static void\n+free_constructor (tree t)\n+{\n+  if (!t || TREE_CODE (t) != CONSTRUCTOR)\n+    return;\n+  releasing_vec ctors;\n+  vec_safe_push (ctors, t);\n+  while (!ctors->is_empty ())\n+    {\n+      tree c = ctors->pop ();\n+      if (vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (c))\n+\t{\n+\t  constructor_elt *ce;\n+\t  for (HOST_WIDE_INT i = 0; vec_safe_iterate (elts, i, &ce); ++i)\n+\t    if (TREE_CODE (ce->value) == CONSTRUCTOR)\n+\t      vec_safe_push (ctors, ce->value);\n+\t  ggc_free (elts);\n+\t}\n+      ggc_free (c);\n+    }\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "9221f7bb08183bf567ad4a617f3fcf96980ec8aa", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c13a2e5873f5919c00b5f37b6db52af8d0f7300/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c13a2e5873f5919c00b5f37b6db52af8d0f7300/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=7c13a2e5873f5919c00b5f37b6db52af8d0f7300", "patch": "@@ -3154,4 +3154,72 @@ check_for_uninitialized_const_var (tree decl, bool constexpr_context_p,\n \n   return true;\n }\n+\n+// forked from gcc/cp/tree.cc cv_unqualified\n+\n+/* Return TYPE with const and volatile removed.  */\n+\n+tree\n+cv_unqualified (tree type)\n+{\n+  int quals;\n+\n+  if (type == error_mark_node)\n+    return type;\n+\n+  quals = rs_type_quals (type);\n+  quals &= ~(TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n+  return rs_build_qualified_type (type, quals);\n+}\n+\n+/* The C and C++ parsers both use vectors to hold function arguments.\n+   For efficiency, we keep a cache of unused vectors.  This is the\n+   cache.  */\n+\n+typedef vec<tree, va_gc> *tree_gc_vec;\n+static GTY ((deletable)) vec<tree_gc_vec, va_gc> *tree_vector_cache;\n+\n+// forked from gcc/c-family/c-common.c make_tree_vector\n+\n+/* Return a new vector from the cache.  If the cache is empty,\n+   allocate a new vector.  These vectors are GC'ed, so it is OK if the\n+   pointer is not released..  */\n+\n+vec<tree, va_gc> *\n+make_tree_vector (void)\n+{\n+  if (tree_vector_cache && !tree_vector_cache->is_empty ())\n+    return tree_vector_cache->pop ();\n+  else\n+    {\n+      /* Passing 0 to vec::alloc returns NULL, and our callers require\n+\t that we always return a non-NULL value.  The vector code uses\n+\t 4 when growing a NULL vector, so we do too.  */\n+      vec<tree, va_gc> *v;\n+      vec_alloc (v, 4);\n+      return v;\n+    }\n+}\n+\n+// forked from gcc/c-family/c-common.c release_tree_vector\n+\n+/* Release a vector of trees back to the cache.  */\n+\n+void\n+release_tree_vector (vec<tree, va_gc> *vec)\n+{\n+  if (vec != NULL)\n+    {\n+      if (vec->allocated () >= 16)\n+\t/* Don't cache vecs that have expanded more than once.  On a p64\n+\t   target, vecs double in alloc size with each power of 2 elements, e.g\n+\t   at 16 elements the alloc increases from 128 to 256 bytes.  */\n+\tvec_free (vec);\n+      else\n+\t{\n+\t  vec->truncate (0);\n+\t  vec_safe_push (tree_vector_cache, vec);\n+\t}\n+    }\n+}\n } // namespace Rust"}, {"sha": "b93e9364990a5954b49ec2440bb422da3b5e3a38", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c13a2e5873f5919c00b5f37b6db52af8d0f7300/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c13a2e5873f5919c00b5f37b6db52af8d0f7300/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=7c13a2e5873f5919c00b5f37b6db52af8d0f7300", "patch": "@@ -2009,6 +2009,59 @@ gnu_vector_type_p (const_tree type)\n   return TREE_CODE (type) == VECTOR_TYPE && !TYPE_INDIVISIBLE_P (type);\n }\n \n+extern vec<tree, va_gc> *\n+make_tree_vector (void);\n+\n+extern void\n+release_tree_vector (vec<tree, va_gc> *);\n+\n+/* Simplified unique_ptr clone to release a tree vec on exit.  */\n+\n+class releasing_vec\n+{\n+public:\n+  typedef vec<tree, va_gc> vec_t;\n+\n+  releasing_vec (vec_t *v) : v (v) {}\n+  releasing_vec () : v (make_tree_vector ()) {}\n+\n+  /* Copy ops are deliberately declared but not defined,\n+     copies must always be elided.  */\n+  releasing_vec (const releasing_vec &);\n+  releasing_vec &operator= (const releasing_vec &);\n+\n+  vec_t &operator* () const { return *v; }\n+  vec_t *operator-> () const { return v; }\n+  vec_t *get () const { return v; }\n+  operator vec_t * () const { return v; }\n+  vec_t **operator& () { return &v; }\n+\n+  /* Breaks pointer/value consistency for convenience.  This takes ptrdiff_t\n+     rather than unsigned to avoid ambiguity with the built-in operator[]\n+     (bootstrap/91828).  */\n+  tree &operator[] (ptrdiff_t i) const { return (*v)[i]; }\n+\n+  tree *begin () { return ::begin (v); }\n+  tree *end () { return ::end (v); }\n+\n+  void release ()\n+  {\n+    release_tree_vector (v);\n+    v = NULL;\n+  }\n+\n+  ~releasing_vec () { release_tree_vector (v); }\n+\n+private:\n+  vec_t *v;\n+};\n+\n+inline tree *\n+vec_safe_push (releasing_vec &r, const tree &t CXX_MEM_STAT_INFO)\n+{\n+  return vec_safe_push (*&r, t PASS_MEM_STAT);\n+}\n+\n } // namespace Rust\n \n #endif // RUST_TREE"}]}