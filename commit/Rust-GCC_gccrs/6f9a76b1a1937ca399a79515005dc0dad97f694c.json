{"sha": "6f9a76b1a1937ca399a79515005dc0dad97f694c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY5YTc2YjFhMTkzN2NhMzk5YTc5NTE1MDA1ZGMwZGFkOTdmNjk0Yw==", "commit": {"author": {"name": "Kelvin Nilsen", "email": "kelvin@gcc.gnu.org", "date": "2018-05-09T00:37:35Z"}, "committer": {"name": "Kelvin Nilsen", "email": "kelvin@gcc.gnu.org", "date": "2018-05-09T00:37:35Z"}, "message": "revert: extend.texi (PowerPC Built-in Functions): Rename this subsection.\n\n2018-05-08  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n\n\tRevert:\n\t* doc/extend.texi (PowerPC Built-in Functions): Rename this\n\tsubsection.\n\t(Basic PowerPC Built-in Functions): The new name of the\n\tsubsection previously known as \"PowerPC Built-in Functions\".\n\t(Basic PowerPC Built-in Functions Available on all Configurations):\n\tNew subsubsection.\n\t(Basic PowerPC Built-in Functions Available on ISA 2.05): New\n\tsubsubsection.\n\t(Basic PowerPC Built-in Functions Available on ISA 2.06): New\n\tsubsubsection.\n\t(Basic PowerPC Built-in Functions Available on ISA 2.07): New\n\tsubsubsection.\n\t(Basic PowerPC Built-in Functions Available on ISA 3.0): New\n\tsubsubsection.\n\nFrom-SVN: r260065", "tree": {"sha": "469d7400f620ef4e6479981f7a6a2ab7f8958578", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/469d7400f620ef4e6479981f7a6a2ab7f8958578"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f9a76b1a1937ca399a79515005dc0dad97f694c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f9a76b1a1937ca399a79515005dc0dad97f694c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f9a76b1a1937ca399a79515005dc0dad97f694c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f9a76b1a1937ca399a79515005dc0dad97f694c/comments", "author": null, "committer": null, "parents": [{"sha": "6fd6a4d0aec428ae7b4b9f4518942b1b3525937e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fd6a4d0aec428ae7b4b9f4518942b1b3525937e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fd6a4d0aec428ae7b4b9f4518942b1b3525937e"}], "stats": {"total": 930, "additions": 443, "deletions": 487}, "files": [{"sha": "89ad01b872981b630f2a2a716327d1f5d090f14c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f9a76b1a1937ca399a79515005dc0dad97f694c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f9a76b1a1937ca399a79515005dc0dad97f694c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f9a76b1a1937ca399a79515005dc0dad97f694c", "patch": "@@ -1,3 +1,21 @@\n+2018-05-08  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n+\n+\tRevert:\n+\t* doc/extend.texi (PowerPC Built-in Functions): Rename this\n+\tsubsection.\n+\t(Basic PowerPC Built-in Functions): The new name of the\n+\tsubsection previously known as \"PowerPC Built-in Functions\".\n+\t(Basic PowerPC Built-in Functions Available on all Configurations):\n+\tNew subsubsection.\n+\t(Basic PowerPC Built-in Functions Available on ISA 2.05): New\n+\tsubsubsection.\n+\t(Basic PowerPC Built-in Functions Available on ISA 2.06): New\n+\tsubsubsection.\n+\t(Basic PowerPC Built-in Functions Available on ISA 2.07): New\n+\tsubsubsection.\n+\t(Basic PowerPC Built-in Functions Available on ISA 3.0): New\n+\tsubsubsection.\n+\n 2018-05-08  Jim Wilson  <jimw@sifive.com>\n \n \t* config/riscv/linux.h (MUSL_ABI_SUFFIX): Delete unnecessary backslash."}, {"sha": "9d085844cfde04b8f0a72f512b999c21c70b20cb", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 425, "deletions": 487, "changes": 912, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f9a76b1a1937ca399a79515005dc0dad97f694c/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f9a76b1a1937ca399a79515005dc0dad97f694c/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=6f9a76b1a1937ca399a79515005dc0dad97f694c", "patch": "@@ -12475,7 +12475,7 @@ instructions, but allow the compiler to schedule those calls.\n * MSP430 Built-in Functions::\n * NDS32 Built-in Functions::\n * picoChip Built-in Functions::\n-* Basic PowerPC Built-in Functions::\n+* PowerPC Built-in Functions::\n * PowerPC AltiVec/VSX Built-in Functions::\n * PowerPC Hardware Transactional Memory Built-in Functions::\n * PowerPC Atomic Memory Operation Functions::\n@@ -15534,16 +15534,11 @@ implementing assertions.\n \n @end table\n \n-@node Basic PowerPC Built-in Functions\n-@subsection Basic PowerPC Built-in Functions\n+@node PowerPC Built-in Functions\n+@subsection PowerPC Built-in Functions\n \n-This section describes PowerPC built-in functions that do not require\n-the inclusion of any special header files to declare prototypes or\n-provide macro definitions.  The sections that follow describe\n-additional PowerPC built-in functions.\n-\n-@node Basic PowerPC Built-in Functions Available on all Configurations\n-@subsubsection Basic PowerPC Built-in Functions Available on all Configurations\n+The following built-in functions are always available and can be used to\n+check the PowerPC target platform type:\n \n @deftypefn {Built-in Function} void __builtin_cpu_init (void)\n This function is a @code{nop} on the PowerPC platform and is included solely\n@@ -15648,8 +15643,6 @@ CPU supports the set of compatible performance monitoring events.\n CPU supports the Embedded ISA category.\n @item cellbe\n CPU has a CELL broadband engine.\n-@item darn\n-CPU supports the @code{darn} (deliver a random number) instruction.\n @item dfp\n CPU has a decimal floating point unit.\n @item dscr\n@@ -15666,9 +15659,6 @@ CPU has a floating point unit.\n CPU has hardware transaction memory instructions.\n @item htm-nosc\n Kernel aborts hardware transactions when a syscall is made.\n-@item htm-no-suspend\n-CPU supports hardware transaction memory but does not support the\n-@code{tsuspend.} instruction.\n @item ic_snoop\n CPU supports icache snooping capabilities.\n @item ieee128\n@@ -15697,8 +15687,6 @@ CPU supports the old POWER ISA (eg, 601)\n CPU supports 64-bit mode execution.\n @item ppcle\n CPU supports a little-endian mode that uses address swizzling.\n-@item scv\n-Kernel supports system call vectored.\n @item smt\n CPU support simultaneous multi-threading.\n @item spe\n@@ -15730,79 +15718,17 @@ Here is an example:\n @end smallexample\n @end deftypefn\n \n-The following built-in functions are also available on all PowerPC\n+These built-in functions are available for the PowerPC family of\n processors:\n @smallexample\n-uint64_t __builtin_ppc_get_timebase ();\n-unsigned long __builtin_ppc_mftb ();\n-@end smallexample\n-\n-The @code{__builtin_ppc_get_timebase} and @code{__builtin_ppc_mftb}\n-functions generate instructions to read the Time Base Register.  The\n-@code{__builtin_ppc_get_timebase} function may generate multiple\n-instructions and always returns the 64 bits of the Time Base Register.\n-The @code{__builtin_ppc_mftb} function always generates one instruction and\n-returns the Time Base Register value as an unsigned long, throwing away\n-the most significant word on 32-bit environments.\n-\n-@node Basic PowerPC Built-in Functions Available on ISA 2.05\n-@subsubsection Basic PowerPC Built-in Functions Available on ISA 2.05\n-\n-The basic built-in functions described in this section are\n-available on the PowerPC family of processors starting with ISA 2.05\n-or later.  Unless specific options are explicitly disabled on the\n-command line, specifying option @option{-mcpu=power6} has the effect of\n-enabling the @option{-mpowerpc64}, @option{-mpowerpc-gpopt},\n-@option{-mpowerpc-gfxopt}, @option{-mmfcrf}, @option{-mpopcntb},\n-@option{-mfprnd}, @option{-mcmpb}, @option{-mhard-dfp}, and\n-@option{-mrecip-precision} options.  Specify the\n-@option{-maltivec} and @option{-mfpgpr} options explicitly in\n-combination with the above options if they are desired.\n-\n-The following functions require option @option{-mcmpb}.\n-@smallexample\n-unsigned long long __builtin_cmpb (unsigned long long int, unsigned long long int);\n-unsigned int __builtin_cmpb (unsigned int, unsigned int);\n-@end smallexample\n-\n-The @code{__builtin_cmpb} function\n-performs a byte-wise compare on the contents of its two arguments,\n-returning the result of the byte-wise comparison as the returned\n-value.  For each byte comparison, the corresponding byte of the return\n-value holds 0xff if the input bytes are equal and 0 if the input bytes\n-are not equal.  If either of the arguments to this built-in function\n-is wider than 32 bits, the function call expands into the form that\n-expects @code{unsigned long long int} arguments\n-which is only available on 64-bit targets.\n-\n-The following built-in functions are available\n-when hardware decimal floating point\n-(@option{-mhard-dfp}) is available:\n-@smallexample\n-_Decimal64 __builtin_ddedpd (int, _Decimal64);\n-_Decimal128 __builtin_ddedpdq (int, _Decimal128);\n-_Decimal64 __builtin_denbcd (int, _Decimal64);\n-_Decimal128 __builtin_denbcdq (int, _Decimal128);\n-_Decimal64 __builtin_diex (long long, _Decimal64);\n-_Decimal128 _builtin_diexq (long long, _Decimal128);\n-_Decimal64 __builtin_dscli (_Decimal64, int);\n-_Decimal128 __builtin_dscliq (_Decimal128, int);\n-_Decimal64 __builtin_dscri (_Decimal64, int);\n-_Decimal128 __builtin_dscriq (_Decimal128, int);\n-long long __builtin_dxex (_Decimal64);\n-long long __builtin_dxexq (_Decimal128);\n-_Decimal128 __builtin_pack_dec128 (unsigned long long, unsigned long long);\n-unsigned long long __builtin_unpack_dec128 (_Decimal128, int);\n-@end smallexample\n-\n-The following functions require @option{-mhard-float},\n-@option{-mpowerpc-gfxopt}, and @option{-mpopcntb} options.\n-\n-@smallexample\n-double __builtin_recipdiv (double, double);\n float __builtin_recipdivf (float, float);\n-double __builtin_rsqrt (double);\n float __builtin_rsqrtf (float);\n+double __builtin_recipdiv (double, double);\n+double __builtin_rsqrt (double);\n+uint64_t __builtin_ppc_get_timebase ();\n+unsigned long __builtin_ppc_mftb ();\n+double __builtin_unpack_longdouble (long double, int);\n+long double __builtin_pack_longdouble (double, double);\n @end smallexample\n \n The @code{vec_rsqrt}, @code{__builtin_rsqrt}, and\n@@ -15814,85 +15740,43 @@ The @code{__builtin_recipdiv}, and @code{__builtin_recipdivf}\n functions generate multiple instructions to implement division using\n the reciprocal estimate instructions.\n \n-The following functions require @option{-mhard-float} and\n-@option{-mmultiple} options.\n-\n-@smallexample\n-long double __builtin_pack_longdouble (double, double);\n-double __builtin_unpack_longdouble (long double, int);\n-@end smallexample\n-\n-@node Basic PowerPC Built-in Functions Available on ISA 2.06\n-@subsubsection Basic PowerPC Built-in Functions Available on ISA 2.06\n-\n-The basic built-in functions described in this section are\n-available on the PowerPC family of processors starting with ISA 2.05\n-or later.  Unless specific options are explicitly disabled on the\n-command line, specifying option @option{-mcpu=power7} has the effect of\n-enabling all the same options as for @option{-mcpu=power6} in\n-addition to the @option{-maltivec}, @option{-mpopcntd}, and\n-@option{-mvsx} options.\n+The @code{__builtin_ppc_get_timebase} and @code{__builtin_ppc_mftb}\n+functions generate instructions to read the Time Base Register.  The\n+@code{__builtin_ppc_get_timebase} function may generate multiple\n+instructions and always returns the 64 bits of the Time Base Register.\n+The @code{__builtin_ppc_mftb} function always generates one instruction and\n+returns the Time Base Register value as an unsigned long, throwing away\n+the most significant word on 32-bit environments.\n \n-The following basic built-in functions require @option{-mpopcntd}:\n-@smallexample\n-unsigned int __builtin_addg6s (unsigned int, unsigned int);\n-long long __builtin_bpermd (long long, long long);\n-unsigned int __builtin_cbcdtd (unsigned int);\n-unsigned int __builtin_cdtbcd (unsigned int);\n-long long __builtin_divde (long long, long long);\n-unsigned long long __builtin_divdeu (unsigned long long, unsigned long long);\n-int __builtin_divwe (int, int);\n-unsigned int __builtin_divweu (unsigned int, unsigned int);\n-vector __int128_t __builtin_pack_vector_int128 (long long, long long);\n-void __builtin_rs6000_speculation_barrier (void);\n-long long __builtin_unpack_vector_int128 (vector __int128_t, signed char);\n-@end smallexample\n+Additional built-in functions are available for the 64-bit PowerPC\n+family of processors, for efficient use of 128-bit floating point\n+(@code{__float128}) values.\n \n-Of these, the @code{__builtin_divde} and @code{__builtin_divdeu} functions\n-require a 64-bit environment.\n+Previous versions of GCC supported some 'q' builtins for IEEE 128-bit\n+floating point.  These functions are now mapped into the equivalent\n+'f128' builtin functions.\n \n-The following basic built-in functions, which are also supported on\n-x86 targets, require @option{-mfloat128}.\n @smallexample\n-__float128 __builtin_fabsq (__float128);\n-__float128 __builtin_copysignq (__float128, __float128);\n-__float128 __builtin_infq (void);\n-__float128 __builtin_huge_valq (void);\n-__float128 __builtin_nanq (void);\n-__float128 __builtin_nansq (void);\n-\n-__float128 __builtin_sqrtf128 (__float128);\n-__float128 __builtin_fmaf128 (__float128, __float128, __float128);\n+__builtin_fabsq is mapped into __builtin_fabsf128\n+__builtin_copysignq is mapped into __builtin_copysignf128\n+__builtin_infq is mapped into __builtin_inff128\n+__builtin_huge_valq is mapped into __builtin_huge_valf128\n+__builtin_nanq is mapped into __builtin_nanf128\n+__builtin_nansq is mapped into __builtin_nansf128\n @end smallexample\n \n-@node Basic PowerPC Built-in Functions Available on ISA 2.07\n-@subsubsection Basic PowerPC Built-in Functions Available on ISA 2.07\n-\n-The basic built-in functions described in this section are\n-available on the PowerPC family of processors starting with ISA 2.07\n-or later.  Unless specific options are explicitly disabled on the\n-command line, specifying option @option{-mcpu=power8} has the effect of\n-enabling all the same options as for @option{-mcpu=power7} in\n-addition to the @option{-mpower8-fusion}, @option{-mpower8-vector},\n-@option{-mcrypto}, @option{-mhtm}, @option{-mquad-memory}, and\n-@option{-mquad-memory-atomic} options.\n-\n-This section intentionally empty.\n-\n-@node Basic PowerPC Built-in Functions Available on ISA 3.0\n-@subsubsection Basic PowerPC Built-in Functions Available on ISA 3.0\n-\n-The basic built-in functions described in this section are\n-available on the PowerPC family of processors starting with ISA 3.0\n-or later.  Unless specific options are explicitly disabled on the\n-command line, specifying option @option{-mcpu=power9} has the effect of\n-enabling all the same options as for @option{-mcpu=power8} in\n-addition to the @option{-misel} option.\n-\n The following built-in functions are available on Linux 64-bit systems\n-that use the ISA 3.0 instruction set (@option{-mcpu=power9}):\n+that use the ISA 3.0 instruction set.\n \n @table @code\n+@item __float128 __builtin_sqrtf128 (__float128)\n+Perform a 128-bit IEEE floating point square root operation.\n+@findex __builtin_sqrtf128\n+\n+@item __float128 __builtin_fmaf128 (__float128, __float128, __float128)\n+Perform a 128-bit IEEE floating point fused multiply and add operation.\n+@findex __builtin_fmaf128\n+\n @item __float128 __builtin_addf128_round_to_odd (__float128, __float128)\n Perform a 128-bit IEEE floating point add using round to odd as the\n rounding mode.\n@@ -15918,7 +15802,7 @@ Perform a 128-bit IEEE floating point square root using round to odd\n as the rounding mode.\n @findex __builtin_sqrtf128_round_to_odd\n \n-@item __float128 __builtin_fmaf128_round_to_odd (__float128, __float128, __float128)\n+@item __float128 __builtin_fmaf128 (__float128, __float128, __float128)\n Perform a 128-bit IEEE floating point fused multiply and add operation\n using round to odd as the rounding mode.\n @findex __builtin_fmaf128_round_to_odd\n@@ -15929,26 +15813,78 @@ round to odd as the rounding mode.\n @findex __builtin_truncf128_round_to_odd\n @end table\n \n-The following additional built-in functions are also available for the\n-PowerPC family of processors, starting with ISA 3.0 or later:\n+The following built-in functions are available for the PowerPC family\n+of processors, starting with ISA 2.05 or later (@option{-mcpu=power6}\n+or @option{-mcmpb}):\n+@smallexample\n+unsigned long long __builtin_cmpb (unsigned long long int, unsigned long long int);\n+unsigned int __builtin_cmpb (unsigned int, unsigned int);\n+@end smallexample\n+\n+The @code{__builtin_cmpb} function\n+performs a byte-wise compare on the contents of its two arguments,\n+returning the result of the byte-wise comparison as the returned\n+value.  For each byte comparison, the corresponding byte of the return\n+value holds 0xff if the input bytes are equal and 0 if the input bytes\n+are not equal.  If either of the arguments to this built-in function\n+is wider than 32 bits, the function call expands into the form that\n+expects @code{unsigned long long int} arguments\n+which is only available on 64-bit targets.\n+\n+The following built-in functions are available for the PowerPC family\n+of processors, starting with ISA 2.06 or later (@option{-mcpu=power7}\n+or @option{-mpopcntd}):\n+@smallexample\n+long __builtin_bpermd (long, long);\n+int __builtin_divwe (int, int);\n+unsigned int __builtin_divweu (unsigned int, unsigned int);\n+long __builtin_divde (long, long);\n+unsigned long __builtin_divdeu (unsigned long, unsigned long);\n+unsigned int cdtbcd (unsigned int);\n+unsigned int cbcdtd (unsigned int);\n+unsigned int addg6s (unsigned int, unsigned int);\n+void __builtin_rs6000_speculation_barrier (void);\n+@end smallexample\n+\n+The @code{__builtin_divde} and @code{__builtin_divdeu} functions\n+require a 64-bit environment supporting ISA 2.06 or later.\n+\n+The following built-in functions are available for the PowerPC family\n+of processors, starting with ISA 3.0 or later (@option{-mcpu=power9}):\n @smallexample\n long long __builtin_darn (void);\n long long __builtin_darn_raw (void);\n int __builtin_darn_32 (void);\n-@end smallexample\n \n-The @code{__builtin_darn} and @code{__builtin_darn_raw}\n-functions require a\n-64-bit environment supporting ISA 3.0 or later.\n-The @code{__builtin_darn} function provides a 64-bit conditioned\n-random number.  The @code{__builtin_darn_raw} function provides a\n-64-bit raw random number.  The @code{__builtin_darn_32} function\n-provides a 32-bit conditioned random number.\n+unsigned int scalar_extract_exp (double source);\n+unsigned long long int scalar_extract_exp (__ieee128 source);\n \n-The following additional built-in functions are also available for the\n-PowerPC family of processors, starting with ISA 3.0 or later:\n+unsigned long long int scalar_extract_sig (double source);\n+unsigned __int128 scalar_extract_sig (__ieee128 source);\n+\n+double\n+scalar_insert_exp (unsigned long long int significand, unsigned long long int exponent);\n+double\n+scalar_insert_exp (double significand, unsigned long long int exponent);\n+\n+ieee_128\n+scalar_insert_exp (unsigned __int128 significand, unsigned long long int exponent);\n+ieee_128\n+scalar_insert_exp (ieee_128 significand, unsigned long long int exponent);\n+\n+int scalar_cmp_exp_gt (double arg1, double arg2);\n+int scalar_cmp_exp_lt (double arg1, double arg2);\n+int scalar_cmp_exp_eq (double arg1, double arg2);\n+int scalar_cmp_exp_unordered (double arg1, double arg2);\n+\n+bool scalar_test_data_class (float source, const int condition);\n+bool scalar_test_data_class (double source, const int condition);\n+bool scalar_test_data_class (__ieee128 source, const int condition);\n+\n+bool scalar_test_neg (float source);\n+bool scalar_test_neg (double source);\n+bool scalar_test_neg (__ieee128 source);\n \n-@smallexample\n int __builtin_byte_in_set (unsigned char u, unsigned long long set);\n int __builtin_byte_in_range (unsigned char u, unsigned int range);\n int __builtin_byte_in_either_range (unsigned char u, unsigned int ranges);\n@@ -15973,6 +15909,81 @@ int __builtin_dfp_dtstsfi_ov (unsigned int comparison, _Decimal128 value);\n int __builtin_dfp_dtstsfi_ov_dd (unsigned int comparison, _Decimal64 value);\n int __builtin_dfp_dtstsfi_ov_td (unsigned int comparison, _Decimal128 value);\n @end smallexample\n+\n+The @code{__builtin_darn} and @code{__builtin_darn_raw}\n+functions require a\n+64-bit environment supporting ISA 3.0 or later.\n+The @code{__builtin_darn} function provides a 64-bit conditioned\n+random number.  The @code{__builtin_darn_raw} function provides a\n+64-bit raw random number.  The @code{__builtin_darn_32} function\n+provides a 32-bit random number.\n+\n+The @code{scalar_extract_exp} and @code{scalar_extract_sig}\n+functions require a 64-bit environment supporting ISA 3.0 or later.\n+The @code{scalar_extract_exp} and @code{scalar_extract_sig} built-in\n+functions return the significand and the biased exponent value\n+respectively of their @code{source} arguments.\n+When supplied with a 64-bit @code{source} argument, the\n+result returned by @code{scalar_extract_sig} has\n+the @code{0x0010000000000000} bit set if the\n+function's @code{source} argument is in normalized form.\n+Otherwise, this bit is set to 0.\n+When supplied with a 128-bit @code{source} argument, the\n+@code{0x00010000000000000000000000000000} bit of the result is\n+treated similarly.\n+Note that the sign of the significand is not represented in the result\n+returned from the @code{scalar_extract_sig} function.  Use the\n+@code{scalar_test_neg} function to test the sign of its @code{double}\n+argument.\n+\n+The @code{scalar_insert_exp}\n+functions require a 64-bit environment supporting ISA 3.0 or later.\n+When supplied with a 64-bit first argument, the\n+@code{scalar_insert_exp} built-in function returns a double-precision\n+floating point value that is constructed by assembling the values of its\n+@code{significand} and @code{exponent} arguments.  The sign of the\n+result is copied from the most significant bit of the\n+@code{significand} argument.  The significand and exponent components\n+of the result are composed of the least significant 11 bits of the\n+@code{exponent} argument and the least significant 52 bits of the\n+@code{significand} argument respectively.\n+\n+When supplied with a 128-bit first argument, the\n+@code{scalar_insert_exp} built-in function returns a quad-precision\n+ieee floating point value.  The sign bit of the result is copied from\n+the most significant bit of the @code{significand} argument.\n+The significand and exponent components of the result are composed of\n+the least significant 15 bits of the @code{exponent} argument and the\n+least significant 112 bits of the @code{significand} argument respectively.\n+\n+The @code{scalar_cmp_exp_gt}, @code{scalar_cmp_exp_lt},\n+@code{scalar_cmp_exp_eq}, and @code{scalar_cmp_exp_unordered} built-in\n+functions return a non-zero value if @code{arg1} is greater than, less\n+than, equal to, or not comparable to @code{arg2} respectively.  The\n+arguments are not comparable if one or the other equals NaN (not a\n+number). \n+\n+The @code{scalar_test_data_class} built-in function returns 1\n+if any of the condition tests enabled by the value of the\n+@code{condition} variable are true, and 0 otherwise.  The\n+@code{condition} argument must be a compile-time constant integer with\n+value not exceeding 127.  The\n+@code{condition} argument is encoded as a bitmask with each bit\n+enabling the testing of a different condition, as characterized by the\n+following:\n+@smallexample\n+0x40    Test for NaN\n+0x20    Test for +Infinity\n+0x10    Test for -Infinity\n+0x08    Test for +Zero\n+0x04    Test for -Zero\n+0x02    Test for +Denormal\n+0x01    Test for -Denormal\n+@end smallexample\n+\n+The @code{scalar_test_neg} built-in function returns 1 if its\n+@code{source} argument holds a negative value, 0 otherwise.\n+\n The @code{__builtin_byte_in_set} function requires a\n 64-bit environment supporting ISA 3.0 or later.  This function returns\n a non-zero value if and only if its @code{u} argument exactly equals one of\n@@ -16023,20 +16034,253 @@ The @code{__builtin_dfp_dtstsfi_ov_dd} and\n require that the type of the @code{value} argument be\n @code{__Decimal64} and @code{__Decimal128} respectively.\n \n+The following built-in functions are also available for the PowerPC family\n+of processors, starting with ISA 3.0 or later\n+(@option{-mcpu=power9}).  These string functions are described\n+separately in order to group the descriptions closer to the function\n+prototypes:\n+@smallexample\n+int vec_all_nez (vector signed char, vector signed char);\n+int vec_all_nez (vector unsigned char, vector unsigned char);\n+int vec_all_nez (vector signed short, vector signed short);\n+int vec_all_nez (vector unsigned short, vector unsigned short);\n+int vec_all_nez (vector signed int, vector signed int);\n+int vec_all_nez (vector unsigned int, vector unsigned int);\n \n+int vec_any_eqz (vector signed char, vector signed char);\n+int vec_any_eqz (vector unsigned char, vector unsigned char);\n+int vec_any_eqz (vector signed short, vector signed short);\n+int vec_any_eqz (vector unsigned short, vector unsigned short);\n+int vec_any_eqz (vector signed int, vector signed int);\n+int vec_any_eqz (vector unsigned int, vector unsigned int);\n \n-@node PowerPC AltiVec/VSX Built-in Functions\n-@subsection PowerPC AltiVec Built-in Functions\n-\n-GCC provides an interface for the PowerPC family of processors to access\n-the AltiVec operations described in Motorola's AltiVec Programming\n-Interface Manual.  The interface is made available by including\n-@code{<altivec.h>} and using @option{-maltivec} and\n-@option{-mabi=altivec}.  The interface supports the following vector\n-types.\n+vector bool char vec_cmpnez (vector signed char arg1, vector signed char arg2);\n+vector bool char vec_cmpnez (vector unsigned char arg1, vector unsigned char arg2);\n+vector bool short vec_cmpnez (vector signed short arg1, vector signed short arg2);\n+vector bool short vec_cmpnez (vector unsigned short arg1, vector unsigned short arg2);\n+vector bool int vec_cmpnez (vector signed int arg1, vector signed int arg2);\n+vector bool int vec_cmpnez (vector unsigned int, vector unsigned int);\n \n-@smallexample\n-vector unsigned char\n+vector signed char vec_cnttz (vector signed char);\n+vector unsigned char vec_cnttz (vector unsigned char);\n+vector signed short vec_cnttz (vector signed short);\n+vector unsigned short vec_cnttz (vector unsigned short);\n+vector signed int vec_cnttz (vector signed int);\n+vector unsigned int vec_cnttz (vector unsigned int);\n+vector signed long long vec_cnttz (vector signed long long);\n+vector unsigned long long vec_cnttz (vector unsigned long long);\n+\n+signed int vec_cntlz_lsbb (vector signed char);\n+signed int vec_cntlz_lsbb (vector unsigned char);\n+\n+signed int vec_cnttz_lsbb (vector signed char);\n+signed int vec_cnttz_lsbb (vector unsigned char);\n+\n+unsigned int vec_first_match_index (vector signed char, vector signed char);\n+unsigned int vec_first_match_index (vector unsigned char,\n+                                    vector unsigned char);\n+unsigned int vec_first_match_index (vector signed int, vector signed int);\n+unsigned int vec_first_match_index (vector unsigned int, vector unsigned int);\n+unsigned int vec_first_match_index (vector signed short, vector signed short);\n+unsigned int vec_first_match_index (vector unsigned short,\n+                                    vector unsigned short);\n+unsigned int vec_first_match_or_eos_index (vector signed char,\n+                                           vector signed char);\n+unsigned int vec_first_match_or_eos_index (vector unsigned char,\n+                                           vector unsigned char);\n+unsigned int vec_first_match_or_eos_index (vector signed int,\n+                                           vector signed int);\n+unsigned int vec_first_match_or_eos_index (vector unsigned int,\n+                                           vector unsigned int);\n+unsigned int vec_first_match_or_eos_index (vector signed short,\n+                                           vector signed short);\n+unsigned int vec_first_match_or_eos_index (vector unsigned short,\n+                                           vector unsigned short);\n+unsigned int vec_first_mismatch_index (vector signed char,\n+                                       vector signed char);\n+unsigned int vec_first_mismatch_index (vector unsigned char,\n+                                       vector unsigned char);\n+unsigned int vec_first_mismatch_index (vector signed int,\n+                                       vector signed int);\n+unsigned int vec_first_mismatch_index (vector unsigned int,\n+                                       vector unsigned int);\n+unsigned int vec_first_mismatch_index (vector signed short,\n+                                       vector signed short);\n+unsigned int vec_first_mismatch_index (vector unsigned short,\n+                                       vector unsigned short);\n+unsigned int vec_first_mismatch_or_eos_index (vector signed char,\n+                                              vector signed char);\n+unsigned int vec_first_mismatch_or_eos_index (vector unsigned char,\n+                                              vector unsigned char);\n+unsigned int vec_first_mismatch_or_eos_index (vector signed int,\n+                                              vector signed int);\n+unsigned int vec_first_mismatch_or_eos_index (vector unsigned int,\n+                                              vector unsigned int);\n+unsigned int vec_first_mismatch_or_eos_index (vector signed short,\n+                                              vector signed short);\n+unsigned int vec_first_mismatch_or_eos_index (vector unsigned short,\n+                                              vector unsigned short);\n+\n+vector unsigned short vec_pack_to_short_fp32 (vector float, vector float);\n+\n+vector signed char vec_xl_be (signed long long, signed char *);\n+vector unsigned char vec_xl_be (signed long long, unsigned char *);\n+vector signed int vec_xl_be (signed long long, signed int *);\n+vector unsigned int vec_xl_be (signed long long, unsigned int *);\n+vector signed __int128 vec_xl_be (signed long long, signed __int128 *);\n+vector unsigned __int128 vec_xl_be (signed long long, unsigned __int128 *);\n+vector signed long long vec_xl_be (signed long long, signed long long *);\n+vector unsigned long long vec_xl_be (signed long long, unsigned long long *);\n+vector signed short vec_xl_be (signed long long, signed short *);\n+vector unsigned short vec_xl_be (signed long long, unsigned short *);\n+vector double vec_xl_be (signed long long, double *);\n+vector float vec_xl_be (signed long long, float *);\n+\n+vector signed char vec_xl_len (signed char *addr, size_t len);\n+vector unsigned char vec_xl_len (unsigned char *addr, size_t len);\n+vector signed int vec_xl_len (signed int *addr, size_t len);\n+vector unsigned int vec_xl_len (unsigned int *addr, size_t len);\n+vector signed __int128 vec_xl_len (signed __int128 *addr, size_t len);\n+vector unsigned __int128 vec_xl_len (unsigned __int128 *addr, size_t len);\n+vector signed long long vec_xl_len (signed long long *addr, size_t len);\n+vector unsigned long long vec_xl_len (unsigned long long *addr, size_t len);\n+vector signed short vec_xl_len (signed short *addr, size_t len);\n+vector unsigned short vec_xl_len (unsigned short *addr, size_t len);\n+vector double vec_xl_len (double *addr, size_t len);\n+vector float vec_xl_len (float *addr, size_t len);\n+\n+vector unsigned char vec_xl_len_r (unsigned char *addr, size_t len);\n+\n+void vec_xst_len (vector signed char data, signed char *addr, size_t len);\n+void vec_xst_len (vector unsigned char data, unsigned char *addr, size_t len);\n+void vec_xst_len (vector signed int data, signed int *addr, size_t len);\n+void vec_xst_len (vector unsigned int data, unsigned int *addr, size_t len);\n+void vec_xst_len (vector unsigned __int128 data, unsigned __int128 *addr, size_t len);\n+void vec_xst_len (vector signed long long data, signed long long *addr, size_t len);\n+void vec_xst_len (vector unsigned long long data, unsigned long long *addr, size_t len);\n+void vec_xst_len (vector signed short data, signed short *addr, size_t len);\n+void vec_xst_len (vector unsigned short data, unsigned short *addr, size_t len);\n+void vec_xst_len (vector signed __int128 data, signed __int128 *addr, size_t len);\n+void vec_xst_len (vector double data, double *addr, size_t len);\n+void vec_xst_len (vector float data, float *addr, size_t len);\n+\n+void vec_xst_len_r (vector unsigned char data, unsigned char *addr, size_t len);\n+\n+signed char vec_xlx (unsigned int index, vector signed char data);\n+unsigned char vec_xlx (unsigned int index, vector unsigned char data);\n+signed short vec_xlx (unsigned int index, vector signed short data);\n+unsigned short vec_xlx (unsigned int index, vector unsigned short data);\n+signed int vec_xlx (unsigned int index, vector signed int data);\n+unsigned int vec_xlx (unsigned int index, vector unsigned int data);\n+float vec_xlx (unsigned int index, vector float data);\n+\n+signed char vec_xrx (unsigned int index, vector signed char data);\n+unsigned char vec_xrx (unsigned int index, vector unsigned char data);\n+signed short vec_xrx (unsigned int index, vector signed short data);\n+unsigned short vec_xrx (unsigned int index, vector unsigned short data);\n+signed int vec_xrx (unsigned int index, vector signed int data);\n+unsigned int vec_xrx (unsigned int index, vector unsigned int data);\n+float vec_xrx (unsigned int index, vector float data);\n+@end smallexample\n+\n+The @code{vec_all_nez}, @code{vec_any_eqz}, and @code{vec_cmpnez}\n+perform pairwise comparisons between the elements at the same\n+positions within their two vector arguments.\n+The @code{vec_all_nez} function returns a\n+non-zero value if and only if all pairwise comparisons are not\n+equal and no element of either vector argument contains a zero.\n+The @code{vec_any_eqz} function returns a\n+non-zero value if and only if at least one pairwise comparison is equal\n+or if at least one element of either vector argument contains a zero.\n+The @code{vec_cmpnez} function returns a vector of the same type as\n+its two arguments, within which each element consists of all ones to\n+denote that either the corresponding elements of the incoming arguments are\n+not equal or that at least one of the corresponding elements contains\n+zero.  Otherwise, the element of the returned vector contains all zeros.\n+\n+The @code{vec_cntlz_lsbb} function returns the count of the number of\n+consecutive leading byte elements (starting from position 0 within the\n+supplied vector argument) for which the least-significant bit\n+equals zero.  The @code{vec_cnttz_lsbb} function returns the count of\n+the number of consecutive trailing byte elements (starting from\n+position 15 and counting backwards within the supplied vector\n+argument) for which the least-significant bit equals zero.\n+\n+The @code{vec_xl_len} and @code{vec_xst_len} functions require a\n+64-bit environment supporting ISA 3.0 or later.  The @code{vec_xl_len}\n+function loads a variable length vector from memory.  The\n+@code{vec_xst_len} function stores a variable length vector to memory.\n+With both the @code{vec_xl_len} and @code{vec_xst_len} functions, the\n+@code{addr} argument represents the memory address to or from which\n+data will be transferred, and the\n+@code{len} argument represents the number of bytes to be\n+transferred, as computed by the C expression @code{min((len & 0xff), 16)}.\n+If this expression's value is not a multiple of the vector element's\n+size, the behavior of this function is undefined.\n+In the case that the underlying computer is configured to run in\n+big-endian mode, the data transfer moves bytes 0 to @code{(len - 1)} of\n+the corresponding vector.  In little-endian mode, the data transfer\n+moves bytes @code{(16 - len)} to @code{15} of the corresponding\n+vector.  For the load function, any bytes of the result vector that\n+are not loaded from memory are set to zero.\n+The value of the @code{addr} argument need not be aligned on a\n+multiple of the vector's element size.\n+\n+The @code{vec_xlx} and @code{vec_xrx} functions extract the single\n+element selected by the @code{index} argument from the vector\n+represented by the @code{data} argument.  The @code{index} argument\n+always specifies a byte offset, regardless of the size of the vector\n+element.  With @code{vec_xlx}, @code{index} is the offset of the first\n+byte of the element to be extracted.  With @code{vec_xrx}, @code{index}\n+represents the last byte of the element to be extracted, measured\n+from the right end of the vector.  In other words, the last byte of\n+the element to be extracted is found at position @code{(15 - index)}.\n+There is no requirement that @code{index} be a multiple of the vector\n+element size.  However, if the size of the vector element added to\n+@code{index} is greater than 15, the content of the returned value is\n+undefined.\n+\n+The following built-in functions are available for the PowerPC family\n+of processors when hardware decimal floating point\n+(@option{-mhard-dfp}) is available:\n+@smallexample\n+long long __builtin_dxex (_Decimal64);\n+long long __builtin_dxexq (_Decimal128);\n+_Decimal64 __builtin_ddedpd (int, _Decimal64);\n+_Decimal128 __builtin_ddedpdq (int, _Decimal128);\n+_Decimal64 __builtin_denbcd (int, _Decimal64);\n+_Decimal128 __builtin_denbcdq (int, _Decimal128);\n+_Decimal64 __builtin_diex (long long, _Decimal64);\n+_Decimal128 _builtin_diexq (long long, _Decimal128);\n+_Decimal64 __builtin_dscli (_Decimal64, int);\n+_Decimal128 __builtin_dscliq (_Decimal128, int);\n+_Decimal64 __builtin_dscri (_Decimal64, int);\n+_Decimal128 __builtin_dscriq (_Decimal128, int);\n+unsigned long long __builtin_unpack_dec128 (_Decimal128, int);\n+_Decimal128 __builtin_pack_dec128 (unsigned long long, unsigned long long);\n+@end smallexample\n+\n+The following built-in functions are available for the PowerPC family\n+of processors when the Vector Scalar (vsx) instruction set is\n+available:\n+@smallexample\n+unsigned long long __builtin_unpack_vector_int128 (vector __int128_t, int);\n+vector __int128_t __builtin_pack_vector_int128 (unsigned long long,\n+                                                unsigned long long);\n+@end smallexample\n+\n+@node PowerPC AltiVec/VSX Built-in Functions\n+@subsection PowerPC AltiVec Built-in Functions\n+\n+GCC provides an interface for the PowerPC family of processors to access\n+the AltiVec operations described in Motorola's AltiVec Programming\n+Interface Manual.  The interface is made available by including\n+@code{<altivec.h>} and using @option{-maltivec} and\n+@option{-mabi=altivec}.  The interface supports the following vector\n+types.\n+\n+@smallexample\n+vector unsigned char\n vector signed char\n vector bool char\n \n@@ -18796,312 +19040,6 @@ int __builtin_bcdsub_gt (vector __int128_t, vector __int128_t);\n int __builtin_bcdsub_ov (vector __int128_t, vector __int128_t);\n @end smallexample\n \n-The following additional built-in functions are also available for the\n-PowerPC family of processors, starting with ISA 3.0\n-(@option{-mcpu=power9}) or later:\n-@smallexample\n-unsigned int scalar_extract_exp (double source);\n-unsigned long long int scalar_extract_exp (__ieee128 source);\n-\n-unsigned long long int scalar_extract_sig (double source);\n-unsigned __int128 scalar_extract_sig (__ieee128 source);\n-\n-double\n-scalar_insert_exp (unsigned long long int significand, unsigned long long int exponent);\n-double\n-scalar_insert_exp (double significand, unsigned long long int exponent);\n-\n-ieee_128\n-scalar_insert_exp (unsigned __int128 significand, unsigned long long int exponent);\n-ieee_128\n-scalar_insert_exp (ieee_128 significand, unsigned long long int exponent);\n-\n-int scalar_cmp_exp_gt (double arg1, double arg2);\n-int scalar_cmp_exp_lt (double arg1, double arg2);\n-int scalar_cmp_exp_eq (double arg1, double arg2);\n-int scalar_cmp_exp_unordered (double arg1, double arg2);\n-\n-bool scalar_test_data_class (float source, const int condition);\n-bool scalar_test_data_class (double source, const int condition);\n-bool scalar_test_data_class (__ieee128 source, const int condition);\n-\n-bool scalar_test_neg (float source);\n-bool scalar_test_neg (double source);\n-bool scalar_test_neg (__ieee128 source);\n-@end smallexample\n-\n-The @code{scalar_extract_exp} and @code{scalar_extract_sig}\n-functions require a 64-bit environment supporting ISA 3.0 or later.\n-The @code{scalar_extract_exp} and @code{scalar_extract_sig} built-in\n-functions return the significand and the biased exponent value\n-respectively of their @code{source} arguments.\n-When supplied with a 64-bit @code{source} argument, the\n-result returned by @code{scalar_extract_sig} has\n-the @code{0x0010000000000000} bit set if the\n-function's @code{source} argument is in normalized form.\n-Otherwise, this bit is set to 0.\n-When supplied with a 128-bit @code{source} argument, the\n-@code{0x00010000000000000000000000000000} bit of the result is\n-treated similarly.\n-Note that the sign of the significand is not represented in the result\n-returned from the @code{scalar_extract_sig} function.  Use the\n-@code{scalar_test_neg} function to test the sign of its @code{double}\n-argument.\n-\n-The @code{scalar_insert_exp}\n-functions require a 64-bit environment supporting ISA 3.0 or later.\n-When supplied with a 64-bit first argument, the\n-@code{scalar_insert_exp} built-in function returns a double-precision\n-floating point value that is constructed by assembling the values of its\n-@code{significand} and @code{exponent} arguments.  The sign of the\n-result is copied from the most significant bit of the\n-@code{significand} argument.  The significand and exponent components\n-of the result are composed of the least significant 11 bits of the\n-@code{exponent} argument and the least significant 52 bits of the\n-@code{significand} argument respectively.\n-\n-When supplied with a 128-bit first argument, the\n-@code{scalar_insert_exp} built-in function returns a quad-precision\n-ieee floating point value.  The sign bit of the result is copied from\n-the most significant bit of the @code{significand} argument.\n-The significand and exponent components of the result are composed of\n-the least significant 15 bits of the @code{exponent} argument and the\n-least significant 112 bits of the @code{significand} argument respectively.\n-\n-The @code{scalar_cmp_exp_gt}, @code{scalar_cmp_exp_lt},\n-@code{scalar_cmp_exp_eq}, and @code{scalar_cmp_exp_unordered} built-in\n-functions return a non-zero value if @code{arg1} is greater than, less\n-than, equal to, or not comparable to @code{arg2} respectively.  The\n-arguments are not comparable if one or the other equals NaN (not a\n-number). \n-\n-The @code{scalar_test_data_class} built-in function returns 1\n-if any of the condition tests enabled by the value of the\n-@code{condition} variable are true, and 0 otherwise.  The\n-@code{condition} argument must be a compile-time constant integer with\n-value not exceeding 127.  The\n-@code{condition} argument is encoded as a bitmask with each bit\n-enabling the testing of a different condition, as characterized by the\n-following:\n-@smallexample\n-0x40    Test for NaN\n-0x20    Test for +Infinity\n-0x10    Test for -Infinity\n-0x08    Test for +Zero\n-0x04    Test for -Zero\n-0x02    Test for +Denormal\n-0x01    Test for -Denormal\n-@end smallexample\n-\n-The @code{scalar_test_neg} built-in function returns 1 if its\n-@code{source} argument holds a negative value, 0 otherwise.\n-\n-The following built-in functions are also available for the PowerPC family\n-of processors, starting with ISA 3.0 or later\n-(@option{-mcpu=power9}).  These string functions are described\n-separately in order to group the descriptions closer to the function\n-prototypes:\n-@smallexample\n-int vec_all_nez (vector signed char, vector signed char);\n-int vec_all_nez (vector unsigned char, vector unsigned char);\n-int vec_all_nez (vector signed short, vector signed short);\n-int vec_all_nez (vector unsigned short, vector unsigned short);\n-int vec_all_nez (vector signed int, vector signed int);\n-int vec_all_nez (vector unsigned int, vector unsigned int);\n-\n-int vec_any_eqz (vector signed char, vector signed char);\n-int vec_any_eqz (vector unsigned char, vector unsigned char);\n-int vec_any_eqz (vector signed short, vector signed short);\n-int vec_any_eqz (vector unsigned short, vector unsigned short);\n-int vec_any_eqz (vector signed int, vector signed int);\n-int vec_any_eqz (vector unsigned int, vector unsigned int);\n-\n-vector bool char vec_cmpnez (vector signed char arg1, vector signed char arg2);\n-vector bool char vec_cmpnez (vector unsigned char arg1, vector unsigned char arg2);\n-vector bool short vec_cmpnez (vector signed short arg1, vector signed short arg2);\n-vector bool short vec_cmpnez (vector unsigned short arg1, vector unsigned short arg2);\n-vector bool int vec_cmpnez (vector signed int arg1, vector signed int arg2);\n-vector bool int vec_cmpnez (vector unsigned int, vector unsigned int);\n-\n-vector signed char vec_cnttz (vector signed char);\n-vector unsigned char vec_cnttz (vector unsigned char);\n-vector signed short vec_cnttz (vector signed short);\n-vector unsigned short vec_cnttz (vector unsigned short);\n-vector signed int vec_cnttz (vector signed int);\n-vector unsigned int vec_cnttz (vector unsigned int);\n-vector signed long long vec_cnttz (vector signed long long);\n-vector unsigned long long vec_cnttz (vector unsigned long long);\n-\n-signed int vec_cntlz_lsbb (vector signed char);\n-signed int vec_cntlz_lsbb (vector unsigned char);\n-\n-signed int vec_cnttz_lsbb (vector signed char);\n-signed int vec_cnttz_lsbb (vector unsigned char);\n-\n-unsigned int vec_first_match_index (vector signed char, vector signed char);\n-unsigned int vec_first_match_index (vector unsigned char,\n-                                    vector unsigned char);\n-unsigned int vec_first_match_index (vector signed int, vector signed int);\n-unsigned int vec_first_match_index (vector unsigned int, vector unsigned int);\n-unsigned int vec_first_match_index (vector signed short, vector signed short);\n-unsigned int vec_first_match_index (vector unsigned short,\n-                                    vector unsigned short);\n-unsigned int vec_first_match_or_eos_index (vector signed char,\n-                                           vector signed char);\n-unsigned int vec_first_match_or_eos_index (vector unsigned char,\n-                                           vector unsigned char);\n-unsigned int vec_first_match_or_eos_index (vector signed int,\n-                                           vector signed int);\n-unsigned int vec_first_match_or_eos_index (vector unsigned int,\n-                                           vector unsigned int);\n-unsigned int vec_first_match_or_eos_index (vector signed short,\n-                                           vector signed short);\n-unsigned int vec_first_match_or_eos_index (vector unsigned short,\n-                                           vector unsigned short);\n-unsigned int vec_first_mismatch_index (vector signed char,\n-                                       vector signed char);\n-unsigned int vec_first_mismatch_index (vector unsigned char,\n-                                       vector unsigned char);\n-unsigned int vec_first_mismatch_index (vector signed int,\n-                                       vector signed int);\n-unsigned int vec_first_mismatch_index (vector unsigned int,\n-                                       vector unsigned int);\n-unsigned int vec_first_mismatch_index (vector signed short,\n-                                       vector signed short);\n-unsigned int vec_first_mismatch_index (vector unsigned short,\n-                                       vector unsigned short);\n-unsigned int vec_first_mismatch_or_eos_index (vector signed char,\n-                                              vector signed char);\n-unsigned int vec_first_mismatch_or_eos_index (vector unsigned char,\n-                                              vector unsigned char);\n-unsigned int vec_first_mismatch_or_eos_index (vector signed int,\n-                                              vector signed int);\n-unsigned int vec_first_mismatch_or_eos_index (vector unsigned int,\n-                                              vector unsigned int);\n-unsigned int vec_first_mismatch_or_eos_index (vector signed short,\n-                                              vector signed short);\n-unsigned int vec_first_mismatch_or_eos_index (vector unsigned short,\n-                                              vector unsigned short);\n-\n-vector unsigned short vec_pack_to_short_fp32 (vector float, vector float);\n-\n-vector signed char vec_xl_be (signed long long, signed char *);\n-vector unsigned char vec_xl_be (signed long long, unsigned char *);\n-vector signed int vec_xl_be (signed long long, signed int *);\n-vector unsigned int vec_xl_be (signed long long, unsigned int *);\n-vector signed __int128 vec_xl_be (signed long long, signed __int128 *);\n-vector unsigned __int128 vec_xl_be (signed long long, unsigned __int128 *);\n-vector signed long long vec_xl_be (signed long long, signed long long *);\n-vector unsigned long long vec_xl_be (signed long long, unsigned long long *);\n-vector signed short vec_xl_be (signed long long, signed short *);\n-vector unsigned short vec_xl_be (signed long long, unsigned short *);\n-vector double vec_xl_be (signed long long, double *);\n-vector float vec_xl_be (signed long long, float *);\n-\n-vector signed char vec_xl_len (signed char *addr, size_t len);\n-vector unsigned char vec_xl_len (unsigned char *addr, size_t len);\n-vector signed int vec_xl_len (signed int *addr, size_t len);\n-vector unsigned int vec_xl_len (unsigned int *addr, size_t len);\n-vector signed __int128 vec_xl_len (signed __int128 *addr, size_t len);\n-vector unsigned __int128 vec_xl_len (unsigned __int128 *addr, size_t len);\n-vector signed long long vec_xl_len (signed long long *addr, size_t len);\n-vector unsigned long long vec_xl_len (unsigned long long *addr, size_t len);\n-vector signed short vec_xl_len (signed short *addr, size_t len);\n-vector unsigned short vec_xl_len (unsigned short *addr, size_t len);\n-vector double vec_xl_len (double *addr, size_t len);\n-vector float vec_xl_len (float *addr, size_t len);\n-\n-vector unsigned char vec_xl_len_r (unsigned char *addr, size_t len);\n-\n-void vec_xst_len (vector signed char data, signed char *addr, size_t len);\n-void vec_xst_len (vector unsigned char data, unsigned char *addr, size_t len);\n-void vec_xst_len (vector signed int data, signed int *addr, size_t len);\n-void vec_xst_len (vector unsigned int data, unsigned int *addr, size_t len);\n-void vec_xst_len (vector unsigned __int128 data, unsigned __int128 *addr, size_t len);\n-void vec_xst_len (vector signed long long data, signed long long *addr, size_t len);\n-void vec_xst_len (vector unsigned long long data, unsigned long long *addr, size_t len);\n-void vec_xst_len (vector signed short data, signed short *addr, size_t len);\n-void vec_xst_len (vector unsigned short data, unsigned short *addr, size_t len);\n-void vec_xst_len (vector signed __int128 data, signed __int128 *addr, size_t len);\n-void vec_xst_len (vector double data, double *addr, size_t len);\n-void vec_xst_len (vector float data, float *addr, size_t len);\n-\n-void vec_xst_len_r (vector unsigned char data, unsigned char *addr, size_t len);\n-\n-signed char vec_xlx (unsigned int index, vector signed char data);\n-unsigned char vec_xlx (unsigned int index, vector unsigned char data);\n-signed short vec_xlx (unsigned int index, vector signed short data);\n-unsigned short vec_xlx (unsigned int index, vector unsigned short data);\n-signed int vec_xlx (unsigned int index, vector signed int data);\n-unsigned int vec_xlx (unsigned int index, vector unsigned int data);\n-float vec_xlx (unsigned int index, vector float data);\n-\n-signed char vec_xrx (unsigned int index, vector signed char data);\n-unsigned char vec_xrx (unsigned int index, vector unsigned char data);\n-signed short vec_xrx (unsigned int index, vector signed short data);\n-unsigned short vec_xrx (unsigned int index, vector unsigned short data);\n-signed int vec_xrx (unsigned int index, vector signed int data);\n-unsigned int vec_xrx (unsigned int index, vector unsigned int data);\n-float vec_xrx (unsigned int index, vector float data);\n-@end smallexample\n-\n-The @code{vec_all_nez}, @code{vec_any_eqz}, and @code{vec_cmpnez}\n-perform pairwise comparisons between the elements at the same\n-positions within their two vector arguments.\n-The @code{vec_all_nez} function returns a\n-non-zero value if and only if all pairwise comparisons are not\n-equal and no element of either vector argument contains a zero.\n-The @code{vec_any_eqz} function returns a\n-non-zero value if and only if at least one pairwise comparison is equal\n-or if at least one element of either vector argument contains a zero.\n-The @code{vec_cmpnez} function returns a vector of the same type as\n-its two arguments, within which each element consists of all ones to\n-denote that either the corresponding elements of the incoming arguments are\n-not equal or that at least one of the corresponding elements contains\n-zero.  Otherwise, the element of the returned vector contains all zeros.\n-\n-The @code{vec_cntlz_lsbb} function returns the count of the number of\n-consecutive leading byte elements (starting from position 0 within the\n-supplied vector argument) for which the least-significant bit\n-equals zero.  The @code{vec_cnttz_lsbb} function returns the count of\n-the number of consecutive trailing byte elements (starting from\n-position 15 and counting backwards within the supplied vector\n-argument) for which the least-significant bit equals zero.\n-\n-The @code{vec_xl_len} and @code{vec_xst_len} functions require a\n-64-bit environment supporting ISA 3.0 or later.  The @code{vec_xl_len}\n-function loads a variable length vector from memory.  The\n-@code{vec_xst_len} function stores a variable length vector to memory.\n-With both the @code{vec_xl_len} and @code{vec_xst_len} functions, the\n-@code{addr} argument represents the memory address to or from which\n-data will be transferred, and the\n-@code{len} argument represents the number of bytes to be\n-transferred, as computed by the C expression @code{min((len & 0xff), 16)}.\n-If this expression's value is not a multiple of the vector element's\n-size, the behavior of this function is undefined.\n-In the case that the underlying computer is configured to run in\n-big-endian mode, the data transfer moves bytes 0 to @code{(len - 1)} of\n-the corresponding vector.  In little-endian mode, the data transfer\n-moves bytes @code{(16 - len)} to @code{15} of the corresponding\n-vector.  For the load function, any bytes of the result vector that\n-are not loaded from memory are set to zero.\n-The value of the @code{addr} argument need not be aligned on a\n-multiple of the vector's element size.\n-\n-The @code{vec_xlx} and @code{vec_xrx} functions extract the single\n-element selected by the @code{index} argument from the vector\n-represented by the @code{data} argument.  The @code{index} argument\n-always specifies a byte offset, regardless of the size of the vector\n-element.  With @code{vec_xlx}, @code{index} is the offset of the first\n-byte of the element to be extracted.  With @code{vec_xrx}, @code{index}\n-represents the last byte of the element to be extracted, measured\n-from the right end of the vector.  In other words, the last byte of\n-the element to be extracted is found at position @code{(15 - index)}.\n-There is no requirement that @code{index} be a multiple of the vector\n-element size.  However, if the size of the vector element added to\n-@code{index} is greater than 15, the content of the returned value is\n-undefined.\n-\n If the ISA 3.0 instruction set additions (@option{-mcpu=power9})\n are available:\n "}]}