{"sha": "a8f59a33dc5af78faf21f1afb48358ae1918926d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThmNTlhMzNkYzVhZjc4ZmFmMjFmMWFmYjQ4MzU4YWUxOTE4OTI2ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-17T12:12:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-17T12:12:07Z"}, "message": "[multiple changes]\n\n2009-04-17  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch7.adb (Expand_Ctrl_Function_Call): Remove incorrect special\n\tcase for the case of an aggregate component, the attach call for the\n\tresult is actually needed.\n\n\t* exp_aggr.adb (Backend_Processing_Possible): Backend processing for\n\tan array aggregate must be disabled if the component type requires\n\tcontrolled actions.\n\n\t* exp_ch3.adb: Minor reformatting\n\n2009-04-17  Arnaud Charlet  <charlet@adacore.com>\n\n\t* s-taprop-tru64.adb, s-taprop-vms.adb, s-taprop-linux.adb,\n\ts-taprop-solaris.adb, s-taprop-irix.adb, s-taprop-hpux-dce.adb,\n\ts-taprop-posix.adb (Suspend_Until_True): Protect against early wakeup.\n\nFrom-SVN: r146254", "tree": {"sha": "94263310c65cdb19e5a42d5786b5f6570f07bc65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94263310c65cdb19e5a42d5786b5f6570f07bc65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8f59a33dc5af78faf21f1afb48358ae1918926d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8f59a33dc5af78faf21f1afb48358ae1918926d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8f59a33dc5af78faf21f1afb48358ae1918926d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8f59a33dc5af78faf21f1afb48358ae1918926d/comments", "author": null, "committer": null, "parents": [{"sha": "b1b543d2c07b470207d4b347d6b2a9af6d488da7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1b543d2c07b470207d4b347d6b2a9af6d488da7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1b543d2c07b470207d4b347d6b2a9af6d488da7"}], "stats": {"total": 148, "additions": 120, "deletions": 28}, "files": [{"sha": "45c6cadece6962def2651ebe02736fd94cf24440", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a8f59a33dc5af78faf21f1afb48358ae1918926d", "patch": "@@ -1,3 +1,42 @@\n+2009-04-17  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch7.adb (Expand_Ctrl_Function_Call): Remove incorrect special\n+\tcase for the case of an aggregate component, the attach call for the\n+\tresult is actually needed.\n+\n+\t* exp_aggr.adb (Backend_Processing_Possible): Backend processing for\n+\tan array aggregate must be disabled if the component type requires\n+\tcontrolled actions.\n+\n+\t* exp_ch3.adb: Minor reformatting\n+\n+2009-04-17  Bob Duff  <duff@adacore.com>\n+\n+\t* output.ads (Indent,Outdent): New procedures for indenting the output.\n+\t(Write_Char): Correct comment -- LF _is_ allowed.\n+\n+\t* output.adb (Indent,Outdent): New procedures for indenting the output.\n+\tKeep track of the indentation level, and make sure it doesn't get too\n+\thigh.\n+\t(Flush_Buffer): Insert spaces at the beginning of each line, if\n+\tindentation level is nonzero.\n+\t(Save_Output_Buffer,Restore_Output_Buffer): Save and restore the current\n+\tindentation level.\n+\t(Set_Standard_Error,Set_Standard_Output): Remove superfluous\n+\t\"Next_Col := 1;\".  Flush_Buffer does that.\n+\n+\t* sem_ch6.adb, sem_ch7.adb (Debug_Flag_C): Reorganize the output\n+\tcontrolled by the -gnatdc switch. It now occurs on entry/exit to the\n+\trelevant analysis routines, and calls Indent/Outdent to make the\n+\tindentation reflect the nesting level.  Add \"helper\" routines, since\n+\totherwise lots of \"return;\" statements would skip the debugging output.\n+\n+2009-04-17  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* s-taprop-tru64.adb, s-taprop-vms.adb, s-taprop-linux.adb,\n+\ts-taprop-solaris.adb, s-taprop-irix.adb, s-taprop-hpux-dce.adb,\n+\ts-taprop-posix.adb (Suspend_Until_True): Protect against early wakeup.\n+\n 2009-04-17  Thomas Quinot  <quinot@adacore.com>\n \n \t* exp_aggr.adb: Minor code reorganization, no behaviour change."}, {"sha": "0ed20d0bd68b5343f882824f87460aefd20d7ba5", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=a8f59a33dc5af78faf21f1afb48358ae1918926d", "patch": "@@ -506,6 +506,8 @@ package body Exp_Aggr is\n    --    9. There cannot be any discriminated record components, since the\n    --       back end cannot handle this complex case.\n \n+   --   10. No controlled actions need to be generated for components.\n+\n    function Backend_Processing_Possible (N : Node_Id) return Boolean is\n       Typ : constant Entity_Id := Etype (N);\n       --  Typ is the correct constrained array subtype of the aggregate\n@@ -580,9 +582,9 @@ package body Exp_Aggr is\n    --  Start of processing for Backend_Processing_Possible\n \n    begin\n-      --  Checks 2 (array must not be bit packed)\n+      --  Checks 2 (array not bit packed) and 10 (no controlled actions)\n \n-      if Is_Bit_Packed_Array (Typ) then\n+      if Is_Bit_Packed_Array (Typ) or else Needs_Finalization (Typ) then\n          return False;\n       end if;\n "}, {"sha": "242e5c45ffd2ea94258c5315bf4aa20b914bc851", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=a8f59a33dc5af78faf21f1afb48358ae1918926d", "patch": "@@ -2061,9 +2061,9 @@ package body Exp_Ch3 is\n          --       return O.Iface_Comp'Position;\n          --    end Fxx;\n \n-         ------------------------------\n-         -- Build_Offset_To_Top_Body --\n-         ------------------------------\n+         ----------------------------------\n+         -- Build_Offset_To_Top_Function --\n+         ----------------------------------\n \n          procedure Build_Offset_To_Top_Function (Iface_Comp : Entity_Id) is\n             Body_Node : Node_Id;\n@@ -6858,8 +6858,7 @@ package body Exp_Ch3 is\n            and then Is_Variable_Size_Record (Etype (Comp_Typ))\n            and then Chars (Tag_Comp) /= Name_uTag\n          then\n-            pragma Assert\n-              (Present (DT_Offset_To_Top_Func (Tag_Comp)));\n+            pragma Assert (Present (DT_Offset_To_Top_Func (Tag_Comp)));\n \n             --  Issue error if Set_Dynamic_Offset_To_Top is not available in a\n             --  configurable run-time environment."}, {"sha": "ea05b24b26428c6fec152d660dda1b2e24cc25e6", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=a8f59a33dc5af78faf21f1afb48358ae1918926d", "patch": "@@ -1401,20 +1401,6 @@ package body Exp_Ch7 is\n \n       --    Attach_To_Final_List (_Lx, Resx (Resx'last)._controller, 3);\n \n-      --  If the context is an array aggregate, the call will be expanded into\n-      --  an assignment, and the attachment will be done when the aggregate\n-      --  expansion is complete. See body of Exp_Aggr for the treatment of\n-      --  other controlled components.\n-\n-      if (Nkind (Parent (N)) = N_Aggregate\n-            and then Is_Array_Type (Etype (Parent (N))))\n-        or else\n-         (Nkind (Parent (N)) = N_Component_Association\n-            and then Is_Array_Type (Etype (Parent (Parent (N)))))\n-      then\n-         return;\n-      end if;\n-\n       --  Case where type has controlled components\n \n       if Has_Controlled_Component (Rtype) then"}, {"sha": "07fcc9cb20df59fcbf9e26414d8f89fa564e0d56", "filename": "gcc/ada/s-taprop-hpux-dce.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2Fs-taprop-hpux-dce.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2Fs-taprop-hpux-dce.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-hpux-dce.adb?ref=a8f59a33dc5af78faf21f1afb48358ae1918926d", "patch": "@@ -1068,7 +1068,16 @@ package body System.Task_Primitives.Operations is\n             S.State := False;\n          else\n             S.Waiting := True;\n-            Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+\n+            loop\n+               --  loop in case pthread_cond_wait returns earlier than\n+               --  expected (e.g. in case of EINTR caused by a signal).\n+\n+               Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+               pragma Assert (Result = 0 or else Result = EINTR);\n+\n+               exit when not S.Waiting;\n+            end loop;\n          end if;\n \n          Result := pthread_mutex_unlock (S.L'Access);"}, {"sha": "59297e941ff148ac2315d8f5fc9a525e16cf48e2", "filename": "gcc/ada/s-taprop-irix.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2Fs-taprop-irix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2Fs-taprop-irix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-irix.adb?ref=a8f59a33dc5af78faf21f1afb48358ae1918926d", "patch": "@@ -1153,7 +1153,16 @@ package body System.Task_Primitives.Operations is\n             S.State := False;\n          else\n             S.Waiting := True;\n-            Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+\n+            loop\n+               --  loop in case pthread_cond_wait returns earlier than\n+               --  expected (e.g. in case of EINTR caused by a signal).\n+\n+               Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+               pragma Assert (Result = 0 or else Result = EINTR);\n+\n+               exit when not S.Waiting;\n+            end loop;\n          end if;\n \n          Result := pthread_mutex_unlock (S.L'Access);"}, {"sha": "b9c3c5e6ae9e7b6adad08a4a4820b5a17cbcbd9d", "filename": "gcc/ada/s-taprop-linux.adb", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2Fs-taprop-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2Fs-taprop-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-linux.adb?ref=a8f59a33dc5af78faf21f1afb48358ae1918926d", "patch": "@@ -1083,7 +1083,19 @@ package body System.Task_Primitives.Operations is\n             S.State := False;\n          else\n             S.Waiting := True;\n-            Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+\n+            loop\n+               --  loop in case pthread_cond_wait returns earlier than\n+               --  expected (e.g. in case of EINTR caused by a signal).\n+               --  This should not happen on current implementation of pthread\n+               --  under Linux, but POSIX does not guarantee it, so this may\n+               --  change in the future.\n+\n+               Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+               pragma Assert (Result = 0 or else Result = EINTR);\n+\n+               exit when not S.Waiting;\n+            end loop;\n          end if;\n \n          Result := pthread_mutex_unlock (S.L'Access);"}, {"sha": "c8894d64929b82cb29d2cb11bfd5cf3d6a964fe1", "filename": "gcc/ada/s-taprop-posix.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2Fs-taprop-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2Fs-taprop-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-posix.adb?ref=a8f59a33dc5af78faf21f1afb48358ae1918926d", "patch": "@@ -1257,7 +1257,16 @@ package body System.Task_Primitives.Operations is\n             S.State := False;\n          else\n             S.Waiting := True;\n-            Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+\n+            loop\n+               --  loop in case pthread_cond_wait returns earlier than\n+               --  expected (e.g. in case of EINTR caused by a signal).\n+\n+               Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+               pragma Assert (Result = 0 or else Result = EINTR);\n+\n+               exit when not S.Waiting;\n+            end loop;\n          end if;\n \n          Result := pthread_mutex_unlock (S.L'Access);"}, {"sha": "bd2470057e3663373d8ed39cea47253ce074323a", "filename": "gcc/ada/s-taprop-solaris.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2Fs-taprop-solaris.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2Fs-taprop-solaris.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-solaris.adb?ref=a8f59a33dc5af78faf21f1afb48358ae1918926d", "patch": "@@ -1818,7 +1818,16 @@ package body System.Task_Primitives.Operations is\n             S.State := False;\n          else\n             S.Waiting := True;\n-            Result := cond_wait (S.CV'Access, S.L'Access);\n+\n+            loop\n+               --  loop in case pthread_cond_wait returns earlier than\n+               --  expected (e.g. in case of EINTR caused by a signal).\n+\n+               Result := cond_wait (S.CV'Access, S.L'Access);\n+               pragma Assert (Result = 0 or else Result = EINTR);\n+\n+               exit when not S.Waiting;\n+            end loop;\n          end if;\n \n          Result := mutex_unlock (S.L'Access);"}, {"sha": "20b0bbc04adfde9019a70458c6cc0855d32a4a70", "filename": "gcc/ada/s-taprop-tru64.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2Fs-taprop-tru64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2Fs-taprop-tru64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-tru64.adb?ref=a8f59a33dc5af78faf21f1afb48358ae1918926d", "patch": "@@ -1170,7 +1170,16 @@ package body System.Task_Primitives.Operations is\n             S.State := False;\n          else\n             S.Waiting := True;\n-            Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+\n+            loop\n+               --  loop in case pthread_cond_wait returns earlier than\n+               --  expected (e.g. in case of EINTR caused by a signal).\n+\n+               Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+               pragma Assert (Result = 0 or else Result = EINTR);\n+\n+               exit when not S.Waiting;\n+            end loop;\n          end if;\n \n          Result := pthread_mutex_unlock (S.L'Access);"}, {"sha": "0d0dd08699e7b808b6ce9afaf7e4cad716622f30", "filename": "gcc/ada/s-taprop-vms.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2Fs-taprop-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f59a33dc5af78faf21f1afb48358ae1918926d/gcc%2Fada%2Fs-taprop-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vms.adb?ref=a8f59a33dc5af78faf21f1afb48358ae1918926d", "patch": "@@ -1104,7 +1104,16 @@ package body System.Task_Primitives.Operations is\n             S.State := False;\n          else\n             S.Waiting := True;\n-            Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+\n+            loop\n+               --  loop in case pthread_cond_wait returns earlier than\n+               --  expected (e.g. in case of EINTR caused by a signal).\n+\n+               Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+               pragma Assert (Result = 0 or else Result = EINTR);\n+\n+               exit when not S.Waiting;\n+            end loop;\n          end if;\n \n          Result := pthread_mutex_unlock (S.L'Access);"}]}