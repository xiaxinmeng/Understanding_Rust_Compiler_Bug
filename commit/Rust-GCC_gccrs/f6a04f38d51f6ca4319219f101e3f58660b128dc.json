{"sha": "f6a04f38d51f6ca4319219f101e3f58660b128dc", "node_id": "C_kwDOANBUbNoAKGY2YTA0ZjM4ZDUxZjZjYTQzMTkyMTlmMTAxZTNmNTg2NjBiMTI4ZGM", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-10-05T13:50:29Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-10-05T14:09:09Z"}, "message": "Ensure we emit the code for coercion sites on CallExpr and MethodCallExpr\n\nWhen we coerce the types of arguments to the parameters of functions for\nexample we must store the actual type of the argument at that HIR ID not\nthe coerced ones. This gives the backend a chance to then figure out\nwhen to actually implement any coercion site code. such as computing the\ndynamic objects.\n\nFixes: #700", "tree": {"sha": "755b5bebd0b063be0464510d00bef0886a9aa03c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/755b5bebd0b063be0464510d00bef0886a9aa03c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6a04f38d51f6ca4319219f101e3f58660b128dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6a04f38d51f6ca4319219f101e3f58660b128dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6a04f38d51f6ca4319219f101e3f58660b128dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6a04f38d51f6ca4319219f101e3f58660b128dc/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "591b43e42e7f63841ce46fdd4f2760e47b6a7b0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/591b43e42e7f63841ce46fdd4f2760e47b6a7b0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/591b43e42e7f63841ce46fdd4f2760e47b6a7b0d"}], "stats": {"total": 217, "additions": 199, "deletions": 18}, "files": [{"sha": "b1a0f07e7ba03ebd11668909b87e8f83f33170d0", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a04f38d51f6ca4319219f101e3f58660b128dc/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a04f38d51f6ca4319219f101e3f58660b128dc/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=f6a04f38d51f6ca4319219f101e3f58660b128dc", "patch": "@@ -363,12 +363,28 @@ class CompileExpr : public HIRCompileBase\n   void visit (HIR::AssignmentExpr &expr) override\n   {\n     fncontext fn = ctx->peek_fn ();\n-    auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n-    auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n+    auto lvalue = CompileExpr::Compile (expr.get_lhs (), ctx);\n+    auto rvalue = CompileExpr::Compile (expr.get_rhs (), ctx);\n+\n+    // assignments are coercion sites so lets convert the rvalue if necessary\n+    TyTy::BaseType *expected = nullptr;\n+    TyTy::BaseType *actual = nullptr;\n+\n+    bool ok;\n+    ok = ctx->get_tyctx ()->lookup_type (\n+      expr.get_lhs ()->get_mappings ().get_hirid (), &expected);\n+    rust_assert (ok);\n+\n+    ok = ctx->get_tyctx ()->lookup_type (\n+      expr.get_rhs ()->get_mappings ().get_hirid (), &actual);\n+    rust_assert (ok);\n+\n+    rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n \n     Bstatement *assignment\n-      = ctx->get_backend ()->assignment_statement (fn.fndecl, lhs, rhs,\n+      = ctx->get_backend ()->assignment_statement (fn.fndecl, lvalue, rvalue,\n \t\t\t\t\t\t   expr.get_locus ());\n+\n     ctx->add_statement (assignment);\n   }\n "}, {"sha": "23a035fd46174013b3cbe5e382eefc39b4fd27bb", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 96, "deletions": 15, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a04f38d51f6ca4319219f101e3f58660b128dc/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a04f38d51f6ca4319219f101e3f58660b128dc/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=f6a04f38d51f6ca4319219f101e3f58660b128dc", "patch": "@@ -69,39 +69,120 @@ CompileExpr::visit (HIR::CallExpr &expr)\n \t       || tyty->get_kind () == TyTy::TypeKind::FNPTR;\n   if (!is_fn)\n     {\n-      Btype *type = TyTyResolveCompile::compile (ctx, tyty);\n+      rust_assert (tyty->get_kind () == TyTy::TypeKind::ADT);\n+      TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (tyty);\n+      Btype *compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n \n       // this assumes all fields are in order from type resolution and if a\n       // base struct was specified those fields are filed via accesors\n       std::vector<Bexpression *> vals;\n-      for (auto &argument : expr.get_arguments ())\n+      for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n \t{\n-\t  Bexpression *e = CompileExpr::Compile (argument.get (), ctx);\n-\t  vals.push_back (e);\n+\t  auto &argument = expr.get_arguments ().at (i);\n+\t  auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n+\n+\t  // assignments are coercion sites so lets convert the rvalue if\n+\t  // necessary\n+\t  auto respective_field = adt->get_field (i);\n+\t  auto expected = respective_field->get_field_type ();\n+\n+\t  TyTy::BaseType *actual = nullptr;\n+\t  bool ok = ctx->get_tyctx ()->lookup_type (\n+\t    argument->get_mappings ().get_hirid (), &actual);\n+\t  rust_assert (ok);\n+\n+\t  // coerce it if required\n+\t  rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n+\n+\t  // add it to the list\n+\t  vals.push_back (rvalue);\n \t}\n \n       translated\n-\t= ctx->get_backend ()->constructor_expression (type, vals, -1,\n-\t\t\t\t\t\t       expr.get_locus ());\n+\t= ctx->get_backend ()->constructor_expression (compiled_adt_type, vals,\n+\t\t\t\t\t\t       -1, expr.get_locus ());\n     }\n   else\n     {\n-      // must be a call to a function\n-      Bexpression *fn = CompileExpr::Compile (expr.get_fnexpr (), ctx);\n-      rust_assert (fn != nullptr);\n+      auto get_parameter_tyty_at_index\n+\t= [] (const TyTy::BaseType *base, size_t index,\n+\t      TyTy::BaseType **result) -> bool {\n+\tbool is_fn = base->get_kind () == TyTy::TypeKind::FNDEF\n+\t\t     || base->get_kind () == TyTy::TypeKind::FNPTR;\n+\trust_assert (is_fn);\n+\n+\tif (base->get_kind () == TyTy::TypeKind::FNPTR)\n+\t  {\n+\t    const TyTy::FnPtr *fn = static_cast<const TyTy::FnPtr *> (base);\n+\t    *result = fn->param_at (index);\n+\n+\t    return true;\n+\t  }\n+\n+\tconst TyTy::FnType *fn = static_cast<const TyTy::FnType *> (base);\n+\tauto param = fn->param_at (index);\n+\t*result = param.second;\n+\n+\treturn true;\n+      };\n+\n+      bool is_varadic = false;\n+      if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+\t{\n+\t  const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n+\t  is_varadic = fn->is_varadic ();\n+\t}\n+\n+      size_t required_num_args;\n+      if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+\t{\n+\t  const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n+\t  required_num_args = fn->num_params ();\n+\t}\n+      else\n+\t{\n+\t  const TyTy::FnPtr *fn = static_cast<const TyTy::FnPtr *> (tyty);\n+\t  required_num_args = fn->num_params ();\n+\t}\n \n       std::vector<Bexpression *> args;\n-      for (auto &argument : expr.get_arguments ())\n+      for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n \t{\n-\t  Bexpression *compiled_expr\n-\t    = CompileExpr::Compile (argument.get (), ctx);\n-\t  args.push_back (compiled_expr);\n+\t  auto &argument = expr.get_arguments ().at (i);\n+\t  auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n+\n+\t  if (is_varadic && i >= required_num_args)\n+\t    {\n+\t      args.push_back (rvalue);\n+\t      continue;\n+\t    }\n+\n+\t  // assignments are coercion sites so lets convert the rvalue if\n+\t  // necessary\n+\t  bool ok;\n+\t  TyTy::BaseType *expected = nullptr;\n+\t  ok = get_parameter_tyty_at_index (tyty, i, &expected);\n+\t  rust_assert (ok);\n+\n+\t  TyTy::BaseType *actual = nullptr;\n+\t  ok = ctx->get_tyctx ()->lookup_type (\n+\t    argument->get_mappings ().get_hirid (), &actual);\n+\t  rust_assert (ok);\n+\n+\t  // coerce it if required\n+\t  rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n+\n+\t  // add it to the list\n+\t  args.push_back (rvalue);\n \t}\n \n+      // must be a call to a function\n+      auto fn_address = CompileExpr::Compile (expr.get_fnexpr (), ctx);\n       auto fncontext = ctx->peek_fn ();\n       translated\n-\t= ctx->get_backend ()->call_expression (fncontext.fndecl, fn, args,\n-\t\t\t\t\t\tnullptr, expr.get_locus ());\n+\t= ctx->get_backend ()->call_expression (fncontext.fndecl, fn_address,\n+\t\t\t\t\t\targs, nullptr,\n+\t\t\t\t\t\texpr.get_locus ());\n     }\n }\n "}, {"sha": "dff98098a425ef60fa04ce36b44c161edad1a524", "filename": "gcc/testsuite/rust/execute/torture/coercion1.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a04f38d51f6ca4319219f101e3f58660b128dc/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fcoercion1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a04f38d51f6ca4319219f101e3f58660b128dc/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fcoercion1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fcoercion1.rs?ref=f6a04f38d51f6ca4319219f101e3f58660b128dc", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-output \"123\\n123\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+struct Foo(i32);\n+trait Bar {\n+    fn baz(&self);\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}\n+\n+impl Bar for Foo {\n+    fn baz(&self) {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, self.0);\n+        }\n+    }\n+}\n+\n+fn static_dispatch<T: Bar>(t: &T) {\n+    t.baz();\n+}\n+\n+fn dynamic_dispatch(t: &dyn Bar) {\n+    t.baz();\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = Foo(123);\n+    static_dispatch(&a);\n+\n+    let b: &dyn Bar;\n+    b = &a;\n+    dynamic_dispatch(b);\n+\n+    0\n+}"}, {"sha": "e4049546787512dbc5db8f408f8c04af432ccc91", "filename": "gcc/testsuite/rust/execute/torture/coercion2.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a04f38d51f6ca4319219f101e3f58660b128dc/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fcoercion2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a04f38d51f6ca4319219f101e3f58660b128dc/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fcoercion2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fcoercion2.rs?ref=f6a04f38d51f6ca4319219f101e3f58660b128dc", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-output \"123\\n123\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+struct Foo(i32);\n+trait Bar {\n+    fn baz(&self);\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}\n+\n+impl Bar for Foo {\n+    fn baz(&self) {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, self.0);\n+        }\n+    }\n+}\n+\n+fn static_dispatch<T: Bar>(t: &T) {\n+    t.baz();\n+}\n+\n+fn dynamic_dispatch(t: &dyn Bar) {\n+    t.baz();\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = &Foo(123);\n+\n+    static_dispatch(a);\n+    dynamic_dispatch(a);\n+\n+    0\n+}"}]}