{"sha": "65655f79213b9bbc5a5d6962a7f6a637883f780b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU2NTVmNzkyMTNiOWJiYzVhNWQ2OTYyYTdmNmE2Mzc4ODNmNzgwYg==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2009-08-17T22:25:06Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2009-08-17T22:25:06Z"}, "message": "m32c.md (UNS_FSETB, UNS_FREIT): New.\n\n* config/m32c/m32c.md (UNS_FSETB, UNS_FREIT): New.\n* config/m32c/prologue.md (epilogue_freit): New.\n(fset_b): New.\n* config/m32c/m32c.c (m32c_function_needs_enter): Add prototype.\n(bank_switch_p): Likewise.\n(fast_interrupt_p): Likewise.\n(interrupt_p): Likewise.\n(m32c_conditional_register_usage): Round memregs size up.\n(need_to_save): We only need to save $a0 when we use ENTER.\n(interrupt_p): Check for fast_interrupt too.\n(bank_switch_p): New.\n(fast_interrupt_p): New.\n(m32c_attribute_table): Add bank_switch and fast_interrupt.\n(m32c_emit_prolog): Support bank switching and fast interrupts.\n* doc/extend.texi (Function Attributes): Add bank_switch and\nfast_interrupt.\n\nFrom-SVN: r150862", "tree": {"sha": "c06c38535dd2071c8584011e69f62f150c8e33df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c06c38535dd2071c8584011e69f62f150c8e33df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65655f79213b9bbc5a5d6962a7f6a637883f780b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65655f79213b9bbc5a5d6962a7f6a637883f780b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65655f79213b9bbc5a5d6962a7f6a637883f780b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65655f79213b9bbc5a5d6962a7f6a637883f780b/comments", "author": null, "committer": null, "parents": [{"sha": "df15255add5471998a5cd84063dc4db98a6b774b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df15255add5471998a5cd84063dc4db98a6b774b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df15255add5471998a5cd84063dc4db98a6b774b"}], "stats": {"total": 136, "additions": 122, "deletions": 14}, "files": [{"sha": "94e20b38f6b1b61deba27117745fa7f8600239a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65655f79213b9bbc5a5d6962a7f6a637883f780b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65655f79213b9bbc5a5d6962a7f6a637883f780b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65655f79213b9bbc5a5d6962a7f6a637883f780b", "patch": "@@ -1,3 +1,22 @@\n+2009-08-17  DJ Delorie  <dj@redhat.com>\n+\n+\t* config/m32c/m32c.md (UNS_FSETB, UNS_FREIT): New.\n+\t* config/m32c/prologue.md (epilogue_freit): New.\n+\t(fset_b): New.\n+\t* config/m32c/m32c.c (m32c_function_needs_enter): Add prototype.\n+\t(bank_switch_p): Likewise.\n+\t(fast_interrupt_p): Likewise.\n+\t(interrupt_p): Likewise.\n+\t(m32c_conditional_register_usage): Round memregs size up.\n+\t(need_to_save): We only need to save $a0 when we use ENTER.\n+\t(interrupt_p): Check for fast_interrupt too.\n+\t(bank_switch_p): New.\n+\t(fast_interrupt_p): New.\n+\t(m32c_attribute_table): Add bank_switch and fast_interrupt.\n+\t(m32c_emit_prolog): Support bank switching and fast interrupts.\n+\t* doc/extend.texi (Function Attributes): Add bank_switch and\n+\tfast_interrupt.\n+\n 2009-08-17  Douglas B Rupp  <rupp@gnat.com>\n \n \t* config/alpha/alpha.c (vms_valid_pointer_mode): New function."}, {"sha": "ae4c8973dea882fdb5cf62901de42b78b5fff44e", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 71, "deletions": 14, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65655f79213b9bbc5a5d6962a7f6a637883f780b/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65655f79213b9bbc5a5d6962a7f6a637883f780b/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=65655f79213b9bbc5a5d6962a7f6a637883f780b", "patch": "@@ -60,9 +60,13 @@ typedef enum\n   PP_justcount\n } Push_Pop_Type;\n \n+static bool m32c_function_needs_enter (void);\n static tree interrupt_handler (tree *, tree, tree, int, bool *);\n static tree function_vector_handler (tree *, tree, tree, int, bool *);\n static int interrupt_p (tree node);\n+static int bank_switch_p (tree node);\n+static int fast_interrupt_p (tree node);\n+static int interrupt_p (tree node);\n static bool m32c_asm_integer (rtx, unsigned int, int);\n static int m32c_comp_type_attributes (const_tree, const_tree);\n static bool m32c_fixed_condition_code_regs (unsigned int *, unsigned int *);\n@@ -493,7 +497,7 @@ m32c_conditional_register_usage (void)\n     {\n       /* The command line option is bytes, but our \"registers\" are\n \t 16-bit words.  */\n-      for (i = target_memregs/2; i < 8; i++)\n+      for (i = (target_memregs+1)/2; i < 8; i++)\n \t{\n \t  fixed_regs[MEM0_REGNO + i] = 1;\n \t  CLEAR_HARD_REG_BIT (reg_class_contents[MEM_REGS], MEM0_REGNO + i);\n@@ -1255,7 +1259,10 @@ need_to_save (int regno)\n   if (regno == FP_REGNO)\n     return 0;\n   if (cfun->machine->is_interrupt\n-      && (!cfun->machine->is_leaf || regno == A0_REGNO))\n+      && (!cfun->machine->is_leaf\n+\t  || (regno == A0_REGNO\n+\t      && m32c_function_needs_enter ())\n+\t  ))\n     return 1;\n   if (df_regs_ever_live_p (regno)\n       && (!call_used_regs[regno] || cfun->machine->is_interrupt))\n@@ -2733,6 +2740,34 @@ interrupt_p (tree node ATTRIBUTE_UNUSED)\n \treturn 1;\n       list = TREE_CHAIN (list);\n     }\n+  return fast_interrupt_p (node);\n+}\n+\n+/* Returns TRUE if the given tree has the \"bank_switch\" attribute.  */\n+static int\n+bank_switch_p (tree node ATTRIBUTE_UNUSED)\n+{\n+  tree list = M32C_ATTRIBUTES (node);\n+  while (list)\n+    {\n+      if (is_attribute_p (\"bank_switch\", TREE_PURPOSE (list)))\n+\treturn 1;\n+      list = TREE_CHAIN (list);\n+    }\n+  return 0;\n+}\n+\n+/* Returns TRUE if the given tree has the \"fast_interrupt\" attribute.  */\n+static int\n+fast_interrupt_p (tree node ATTRIBUTE_UNUSED)\n+{\n+  tree list = M32C_ATTRIBUTES (node);\n+  while (list)\n+    {\n+      if (is_attribute_p (\"fast_interrupt\", TREE_PURPOSE (list)))\n+\treturn 1;\n+      list = TREE_CHAIN (list);\n+    }\n   return 0;\n }\n \n@@ -2846,6 +2881,8 @@ current_function_special_page_vector (rtx x)\n #define TARGET_ATTRIBUTE_TABLE m32c_attribute_table\n static const struct attribute_spec m32c_attribute_table[] = {\n   {\"interrupt\", 0, 0, false, false, false, interrupt_handler},\n+  {\"bank_switch\", 0, 0, false, false, false, interrupt_handler},\n+  {\"fast_interrupt\", 0, 0, false, false, false, interrupt_handler},\n   {\"function_vector\", 1, 1, true,  false, false, function_vector_handler},\n   {0, 0, 0, 0, 0, 0, 0}\n };\n@@ -3928,16 +3965,23 @@ m32c_emit_prologue (void)\n       cfun->machine->is_interrupt = 1;\n       complex_prologue = 1;\n     }\n+  else if (bank_switch_p (cfun->decl))\n+    warning (OPT_Wattributes,\n+\t     \"%<bank_switch%> has no effect on non-interrupt functions\");\n \n   reg_save_size = m32c_pushm_popm (PP_justcount);\n \n   if (interrupt_p (cfun->decl))\n-    emit_insn (gen_pushm (GEN_INT (cfun->machine->intr_pushm)));\n+    {\n+      if (bank_switch_p (cfun->decl))\n+\temit_insn (gen_fset_b ());\n+      else if (cfun->machine->intr_pushm)\n+\temit_insn (gen_pushm (GEN_INT (cfun->machine->intr_pushm)));\n+    }\n \n   frame_size =\n     m32c_initial_elimination_offset (FB_REGNO, SP_REGNO) - reg_save_size;\n   if (frame_size == 0\n-      && !cfun->machine->is_interrupt\n       && !m32c_function_needs_enter ())\n     cfun->machine->use_rts = 1;\n \n@@ -3988,16 +4032,29 @@ m32c_emit_epilogue (void)\n     {\n       enum machine_mode spmode = TARGET_A16 ? HImode : PSImode;\n \n-      emit_move_insn (gen_rtx_REG (spmode, A0_REGNO),\n-\t\t      gen_rtx_REG (spmode, FP_REGNO));\n-      emit_move_insn (gen_rtx_REG (spmode, SP_REGNO),\n-\t\t      gen_rtx_REG (spmode, A0_REGNO));\n-      if (TARGET_A16)\n-\temit_insn (gen_pophi_16 (gen_rtx_REG (HImode, FP_REGNO)));\n-      else\n-\temit_insn (gen_poppsi (gen_rtx_REG (PSImode, FP_REGNO)));\n-      emit_insn (gen_popm (GEN_INT (cfun->machine->intr_pushm)));\n-      if (TARGET_A16)\n+      /* REIT clears B flag and restores $fp for us, but we still\n+\t have to fix up the stack.  USE_RTS just means we didn't\n+\t emit ENTER.  */\n+      if (!cfun->machine->use_rts)\n+\t{\n+\t  emit_move_insn (gen_rtx_REG (spmode, A0_REGNO),\n+\t\t\t  gen_rtx_REG (spmode, FP_REGNO));\n+\t  emit_move_insn (gen_rtx_REG (spmode, SP_REGNO),\n+\t\t\t  gen_rtx_REG (spmode, A0_REGNO));\n+\t  /* We can't just add this to the POPM because it would be in\n+\t     the wrong order, and wouldn't fix the stack if we're bank\n+\t     switching.  */\n+\t  if (TARGET_A16)\n+\t    emit_insn (gen_pophi_16 (gen_rtx_REG (HImode, FP_REGNO)));\n+\t  else\n+\t    emit_insn (gen_poppsi (gen_rtx_REG (PSImode, FP_REGNO)));\n+\t}\n+      if (!bank_switch_p (cfun->decl) && cfun->machine->intr_pushm)\n+\temit_insn (gen_popm (GEN_INT (cfun->machine->intr_pushm)));\n+\n+      if (fast_interrupt_p (cfun->decl))\n+\temit_jump_insn (gen_epilogue_freit ());\n+      else if (TARGET_A16)\n \temit_jump_insn (gen_epilogue_reit_16 ());\n       else\n \temit_jump_insn (gen_epilogue_reit_24 ());"}, {"sha": "739f24c177e9484285314488907e2aff72c0d2df", "filename": "gcc/config/m32c/m32c.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65655f79213b9bbc5a5d6962a7f6a637883f780b/gcc%2Fconfig%2Fm32c%2Fm32c.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65655f79213b9bbc5a5d6962a7f6a637883f780b/gcc%2Fconfig%2Fm32c%2Fm32c.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.md?ref=65655f79213b9bbc5a5d6962a7f6a637883f780b", "patch": "@@ -47,6 +47,8 @@\n    (UNS_SSTR 7)\n    (UNS_SCMPU 8)\n    (UNS_SMOVU 9)\n+   (UNS_FSETB 10)\n+   (UNS_FREIT 11)\n    ])\n \n ;; n = no change, x = clobbered.  The first 16 values are chosen such"}, {"sha": "175b2b0ab9f014cea0df233100fba71c3918e185", "filename": "gcc/config/m32c/prologue.md", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65655f79213b9bbc5a5d6962a7f6a637883f780b/gcc%2Fconfig%2Fm32c%2Fprologue.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65655f79213b9bbc5a5d6962a7f6a637883f780b/gcc%2Fconfig%2Fm32c%2Fprologue.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fprologue.md?ref=65655f79213b9bbc5a5d6962a7f6a637883f780b", "patch": "@@ -149,6 +149,15 @@\n   [(set_attr \"flags\" \"x\")]\n   )\n \n+(define_insn \"epilogue_freit\"\n+  [(unspec [(const_int 0)] UNS_FREIT)\n+   (return)\n+   ]\n+  \"\"\n+  \"freit\"\n+  [(set_attr \"flags\" \"x\")]\n+  )\n+\n (define_insn \"epilogue_rts\"\n   [(return)\n    ]\n@@ -180,3 +189,11 @@\n   \"popm\\t%p0\"\n   [(set_attr \"flags\" \"n\")]\n   )\n+\n+(define_insn \"fset_b\"\n+  [(unspec [(const_int 0)] UNS_FSETB)]\n+  \"\"\n+  \"fset\\tB\"\n+  [(set_attr \"flags\" \"n\")]\n+  )\n+"}, {"sha": "4e9f18924d1c7df0cb7b22eebb5b3a6a76f712af", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65655f79213b9bbc5a5d6962a7f6a637883f780b/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65655f79213b9bbc5a5d6962a7f6a637883f780b/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=65655f79213b9bbc5a5d6962a7f6a637883f780b", "patch": "@@ -2019,6 +2019,12 @@ info format it will either mean marking the function as artificial\n or using the caller location for all instructions within the inlined\n body.\n \n+@item bank_switch\n+@cindex interrupt handler functions\n+When added to an interrupt handler with the M32C port, causes the\n+prologue and epilogue to use bank switching to preserve the registers\n+rather than saving them on the stack.\n+\n @item flatten\n @cindex @code{flatten} function attribute\n Generally, inlining into a function is limited.  For a function marked with\n@@ -2272,6 +2278,13 @@ On MeP targets this causes the compiler to use a calling convention\n which assumes the called function is too far away for the built-in\n addressing modes.\n \n+@item fast_interrupt\n+@cindex interrupt handler functions\n+Use this attribute on the M32C port to indicate that the specified\n+function is a fast interrupt handler.  This is just like the\n+@code{interrupt} attribute, except that @code{freit} is used to return\n+instead of @code{reit}.\n+\n @item fastcall\n @cindex functions that pop the argument stack on the 386\n On the Intel 386, the @code{fastcall} attribute causes the compiler to"}]}