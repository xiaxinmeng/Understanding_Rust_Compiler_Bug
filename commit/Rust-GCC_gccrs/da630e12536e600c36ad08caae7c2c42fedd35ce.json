{"sha": "da630e12536e600c36ad08caae7c2c42fedd35ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE2MzBlMTI1MzZlNjAwYzM2YWQwOGNhYWU3YzJjNDJmZWRkMzVjZQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-08-03T09:34:18Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-08-03T09:34:18Z"}, "message": "Delete questionable files\n\nFrom-SVN: r28460", "tree": {"sha": "c986f4515a8bad91968fc89af63aa9d716a605ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c986f4515a8bad91968fc89af63aa9d716a605ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da630e12536e600c36ad08caae7c2c42fedd35ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da630e12536e600c36ad08caae7c2c42fedd35ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da630e12536e600c36ad08caae7c2c42fedd35ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da630e12536e600c36ad08caae7c2c42fedd35ce/comments", "author": null, "committer": null, "parents": [{"sha": "b7bc283c660eaa418baf945634ae813ab3dd8f30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7bc283c660eaa418baf945634ae813ab3dd8f30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7bc283c660eaa418baf945634ae813ab3dd8f30"}], "stats": {"total": 8815, "additions": 0, "deletions": 8815}, "files": [{"sha": "c5fbde939d0f7e7c81dbb19cca9d609dc7b76438", "filename": "gcc/testsuite/g++.old-deja/g++.mike/eh43.C", "status": "removed", "additions": 0, "deletions": 741, "changes": 741, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7bc283c660eaa418baf945634ae813ab3dd8f30/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Feh43.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7bc283c660eaa418baf945634ae813ab3dd8f30/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Feh43.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Feh43.C?ref=b7bc283c660eaa418baf945634ae813ab3dd8f30", "patch": "@@ -1,741 +0,0 @@\n-// Build don't link:\n-// Special g++ Options: -fexceptions\n-\n-// testcase to check obstack allocation for cleanups\n-\n-typedef unsigned char byte;\n-typedef unsigned short word16;\n-typedef unsigned long word32;\n-typedef unsigned char boolean;\n-enum {FALSE, TRUE};\n-extern \"C\" {\n-extern void __eprintf (const char *, const char *, unsigned, const char *);\n-}\n-extern \"C\" {\n-typedef unsigned int size_t;\n-extern void *memccpy(void *, const void *, int, size_t);\n-extern void *memchr(const void *, int, size_t);\n-extern void *memset(void *, int, size_t);\n-}\n-template <class T> struct SecBlock\n-{\n-public:\n-    SecBlock(unsigned int size)\n-        : size(size), ptr((new  T [(  size )]) ) {}\n-    ~SecBlock()\n-        {(memset(( ptr ), 0, (  size )*sizeof(*( ptr ))), delete [] ( ptr )) ;}\n-    operator T *() const\n-        {return ptr;}\n-    T *operator +(unsigned int offset)\n-        {return ptr+offset;}\n-    T& operator[](int index)\n-        {((void) (( index<size ) ? 0 : (__eprintf (\"%s:%u: failed assertion `%s'\\n\",      \"misc.h\" ,   31 ,  \"index<size\" ), 0) )) ; return ptr[index];}\n-    const T& operator[](int index) const\n-        {((void) (( index<size ) ? 0 : (__eprintf (\"%s:%u: failed assertion `%s'\\n\",      \"misc.h\" ,   33 ,  \"index<size\" ), 0) )) ; return ptr[index];}\n-    const unsigned int size;\n-    T *const ptr;\n-};\n-typedef SecBlock<byte> SecByteBlock;\n-void xorbuf(byte *buf, const byte *mask, unsigned int count);\n-void byteReverse(word16 *out, const word16 *in, unsigned int byteCount);\n-void byteReverse(word32 *out, const word32 *in, unsigned int byteCount);\n-inline word16 Invert(const word16 value)\n-{\n-    return (value << 8) | (value >> 8);\n-}\n-inline word32 Invert(const word32 value)\n-{\n-    word32 work = ((value & 0xFF00FF00L) >> 8) | ((value & 0x00FF00FFL) << 8);\n-    return (work << 16) | (work >> 16);\n-}\n-template <class T> inline T min (const T t1, const T t2)\n-{\n-    return (t1 < t2 ? t1 : t2);\n-}\n-template <class T> inline T max (const T t1, const T t2)\n-{\n-    return (t1 > t2 ? t1 : t2);\n-}\n-template <class T> inline void swap (T &a, T &b)\n-{\n-    T temp = a;\n-    a = b;\n-    b = temp;\n-}\n-template <class T> inline T rotl(T x, unsigned int y)\n-{\n-    return ((x<<y) | (x>>(sizeof(T)*8-y)));\n-}\n-template <class T> inline T rotr(T x, unsigned int y)\n-{\n-    return ((x>>y) | (x<<(sizeof(T)*8-y)));\n-}\n-int BytePrecision(unsigned long);\n-int BitPrecision(unsigned long);\n-unsigned long Crop(unsigned long, int size);\n-enum CipherDir {ENCRYPTION, DECRYPTION};\n-class BlockTransformation\n-{\n-public:\n-    virtual ~BlockTransformation() {}\n-    virtual void ProcessBlock(byte *inoutBlock) =0;\n-    virtual void ProcessBlock(const byte *inBlock, byte *outBlock) =0;\n-    virtual unsigned int BlockSize() const =0;\n-};\n-class StreamCipher\n-{\n-public:\n-    virtual ~StreamCipher() {}\n-    virtual byte ProcessByte(byte input) =0;\n-    virtual void ProcessString(byte *outString, const byte *inString, unsigned int length);\n-    virtual void ProcessString(byte *inoutString, unsigned int length);\n-};\n-class RandomAccessStreamCipher : public StreamCipher\n-{\n-public:\n-    virtual ~RandomAccessStreamCipher() {}\n-    virtual void Seek(unsigned long position) =0;\n-};\n-class RandomNumberGenerator\n-{\n-public:\n-    virtual ~RandomNumberGenerator() {}\n-    virtual byte GetByte() =0;\n-    virtual int GetBit();\n-    virtual word32 GetLong(word32 min=0, word32 max=0xffffffffL);\n-    virtual word16 GetShort(word16 min=0, word16 max=0xffff)\n-        {return (word16)GetLong(min, max);}\n-    virtual void GetBlock(byte *output, unsigned int size);\n-};\n-template <class T> void Shuffle(RandomNumberGenerator &rng, T *array, unsigned int size)\n-{\n-    while (--size)\n-        swap(array[size], array[(unsigned int)rng.GetLong(0, size)]);\n-}\n-class HashModule\n-{\n-public:\n-    virtual ~HashModule() {}\n-    virtual void Update(const byte *input, unsigned int length) =0;\n-    virtual void Final(byte *digest) =0;\n-    virtual int DigestSize() const =0;\n-    virtual void CalculateDigest(byte *digest, const byte *input, int length)\n-        {Update(input, length); Final(digest);}\n-};\n-class BufferedTransformation\n-{\n-public:\n-    virtual ~BufferedTransformation() {}\n-    virtual unsigned long MaxRetrieveable() =0;\n-    virtual void TransferTo(BufferedTransformation &target);\n-    virtual boolean Attachable() {return FALSE;}\n-    virtual void Detach(BufferedTransformation *) {}\n-    virtual void Attach(BufferedTransformation *) {}\n-    virtual void Close() {InputFinished();}\n-    virtual void Put(byte inByte) =0;\n-    virtual void Put(const byte *inString, unsigned int length) =0;\n-    virtual void InputFinished() {}\n-    void PutShort(word16 value, boolean highFirst=TRUE);\n-    void PutLong(word32 value, boolean highFirst=TRUE);\n-    virtual int Get(byte &outByte) =0;\n-    virtual unsigned int Get(byte *outString, unsigned int getMax) =0;\n-    int GetShort(word16 &value, boolean highFirst=TRUE);\n-    int GetLong(word32 &value, boolean highFirst=TRUE);\n-    unsigned int Skip(unsigned int skipMax);\n-};\n-class PK_CryptoSystem\n-{\n-public:\n-    virtual ~PK_CryptoSystem() {};\n-    virtual unsigned int MaxPlainTextLength() const =0;\n-    virtual unsigned int CipherTextLength() const =0;\n-};\n-class PK_Encryptor : public PK_CryptoSystem\n-{\n-public:\n-    virtual void Encrypt(RandomNumberGenerator &rng, const byte *plainText, unsigned int plainTextLength, byte *cipherText) =0;\n-};\n-class PK_Decryptor : public PK_CryptoSystem\n-{\n-public:\n-    virtual unsigned int Decrypt(const byte *cipherText, byte *plainText) =0;\n-};\n-class PK_SignatureSystem\n-{\n-public:\n-    virtual ~PK_SignatureSystem() {};\n-    virtual unsigned int MaxMessageLength() const =0;\n-    virtual unsigned int SignatureLength() const =0;\n-};\n-class PK_Signer : public PK_SignatureSystem\n-{\n-public:\n-    virtual void Sign(RandomNumberGenerator &rng, const byte *message, unsigned int messageLen, byte *signature) =0;\n-};\n-class PK_Verifier : public PK_SignatureSystem\n-{\n-public:\n-    virtual boolean Verify(const byte *message, unsigned int messageLen, const byte *signature) =0;\n-};\n-class ByteQueueNode;\n-class ByteQueue : public BufferedTransformation\n-{\n-public:\n-    ByteQueue();\n-    ~ByteQueue();\n-    unsigned long CurrentSize() const;\n-    unsigned long MaxRetrieveable()\n-        {return CurrentSize();}\n-    void Put(byte inByte);\n-    void Put(const byte *inString, unsigned int length);\n-    int Get(byte &outByte);\n-    unsigned int Get(byte *outString, unsigned int getMax);\n-private:\n-    ByteQueueNode *head, *tail;\n-};\n-enum ASNTag {INTEGER=0x02, BIT_STRING=0x03, SEQUENCE=0x10};\n-enum ASNIdFlag {CONSTRUCTED = 0x20};\n-unsigned int DERLengthEncode(unsigned int length, byte *output);\n-unsigned int DERLengthEncode(unsigned int length, BufferedTransformation &);\n-class BERDecodeErr {};\n-boolean BERLengthDecode(BufferedTransformation &, unsigned int &);\n-class BERSequenceDecoder : public BufferedTransformation\n-{\n-public:\n-    BERSequenceDecoder(BufferedTransformation &inQueue);\n-    ~BERSequenceDecoder();\n-    void Put(byte inByte) {}\n-    void Put(const byte *, unsigned int) {}\n-    unsigned long MaxRetrieveable()\n-        {return inQueue.MaxRetrieveable();}\n-    int Get(byte &outByte)\n-        {return inQueue.Get(outByte);}\n-    unsigned int Get(byte *outString, unsigned int getMax)\n-        {return inQueue.Get(outString, getMax);}\n-private:\n-    BufferedTransformation &inQueue;\n-    boolean definiteLength;\n-    unsigned int length;\n-};\n-class DERSequenceEncoder : public ByteQueue\n-{\n-public:\n-    DERSequenceEncoder(BufferedTransformation &outQueue);\n-    ~DERSequenceEncoder();\n-private:\n-    BufferedTransformation &outQueue;\n-};\n-extern \"C\" {\n-}\n-extern \"C\" {\n-extern void *memmove(void *, const void *, size_t);\n-extern char *strcpy(char *, const char *);\n-extern char *strncpy(char *, const char *, size_t);\n-extern char *strcat(char *, const char *);\n-extern char *strncat(char *, const char *, size_t);\n-extern int strcmp(const char *, const char *);\n-extern int strcoll(const char *, const char *);\n-extern int strncmp(const char *, const char *, size_t);\n-extern size_t strxfrm(char *, const char *, size_t);\n-extern void * __hide_memchr (const void *, int, size_t);\n-extern char * __hide_strchr (const char *, int);\n-extern size_t strcspn(const char *, const char *);\n-extern char * __hide_strpbrk (const char *, const char *);\n-extern char * __hide_strrchr (const char *, int);\n-extern size_t strspn(const char *, const char *);\n-extern char * __hide_strstr (const char *, const char *);\n-extern char *strtok(char *, const char *);\n-extern void *memset(void *, int, size_t);\n-extern char *strerror(int);\n-extern void *memccpy(void *, const void *, int, size_t);\n-extern char *strdup(const char *);\n-extern char *strsignal(int);\n-extern int ffs(const int);\n-extern int strcasecmp(const char *, const char *);\n-extern int strncasecmp(const char *, const char *, size_t);\n-}\n-typedef int ptrdiff_t;\n-extern \"C\" const char *strchr (const char *, int);\n-inline char *\n-strchr (char *s, int c)\n-{\n-  return (char*) strchr ((const char *) s, c);\n-}\n-extern \"C\" const char *strpbrk (const char *, const char *);\n-inline char *\n-strpbrk (char *s1, const char *s2)\n-{\n-  return (char *) strpbrk ((const char *) s1, s2);\n-}\n-extern \"C\" const char *strrchr (const char *, int);\n-inline char *\n-strrchr (char *s, int c)\n-{\n-  return (char *) strrchr ((const char *) s, c);\n-}\n-extern \"C\" const char *strstr (const char *, const char *);\n-inline char *\n-strstr (char *s1, const char *s2)\n-{\n-  return (char *) strstr ((const char *) s1, s2);\n-}\n-extern \"C\" void *memchr (const void *, int, size_t);\n-inline void *\n-memchr (void *s, int c, size_t n)\n-{\n-  return (void *) memchr ((const void *) s, c, n);\n-}\n-typedef word16 unit;\n-typedef short signedunit;\n-typedef unit *unitptr;\n-extern short global_precision;\n-boolean mp_addc\n-        (register unitptr r1,const unit * r2,register boolean carry);\n-boolean mp_subb\n-        (register unitptr r1,const unit * r2,register boolean borrow);\n-boolean mp_rotate_left(register unitptr r1,register boolean carry);\n-void mp_shift_right_bits(register unitptr r1,register short bits);\n-short mp_compare(const unit * r1,const unit * r2);\n-boolean mp_inc(register unitptr r);\n-boolean mp_dec(register unitptr r);\n-void mp_neg(register unitptr r);\n-void mp_init(register unitptr r, word16 value);\n-short significance(const unit * r);\n-int mp_udiv(register unitptr remainder,register unitptr quotient,\n-        const unit * dividend,const unit * divisor);\n-int mp_recip(register unitptr quotient,const unit * divisor);\n-int mp_div(register unitptr remainder,register unitptr quotient,\n-        unit * dividend, unit * divisor);\n-word16 mp_shortdiv(register unitptr quotient,\n-        const unit * dividend,register word16 divisor);\n-int mp_mod(register unitptr remainder,\n-        const unit * dividend,const unit * divisor);\n-word16 mp_shortmod(register unitptr dividend,register word16 divisor);\n-int mp_mult(register unitptr prod,\n-        const unit * multiplicand,const unit * multiplier);\n-int countbits(const unit * r);\n-int stage_peasant_modulus(const unit * n);\n-int stage_merritt_modulus(const unit * n);\n-int stage_upton_modulus(const unit * n);\n-int stage_smith_modulus(const unit * n);\n-int peasant_modmult(register unitptr prod,\n-        const unit * multiplicand,const unit * multiplier);\n-int merritt_modmult(register unitptr prod,\n-        const unit * multiplicand,const unit * multiplier);\n-int upton_modmult(register unitptr prod,\n-        const unit * multiplicand,const unit * multiplier);\n-int smith_modmult(register unitptr prod,\n-        const unit * multiplicand,const unit * multiplier);\n-void peasant_burn();\n-void merritt_burn();\n-void upton_burn();\n-void smith_burn();\n-int mp_modexp(register unitptr expout,const unit * expin,\n-        const unit * exponent,const unit * modulus);\n-int mp_modexp_crt(unitptr expout, const unit * expin,\n-        const unit * p, const unit * q, const unit * ep, const unit * eq, const unit * u);\n-word16 fetch_word16(byte *buf);\n-byte *put_word16(word16 w, byte *buf);\n-word32 fetch_word32(byte *buf);\n-byte *put_word32(word32 w, byte *buf);\n-int string_length(const char *s);\n-int str2reg(unit * reg,const char* digitstr);\n-int reg2str(char * s,const unit * n,short radix);\n-void mp_display(char * s,unitptr r);\n-word16 checksum(register byte * buf, register word16 count);\n-void cbc_xor(register unitptr dst, register unitptr src, word16 bytecount);\n-void hiloswap(byte * r1,short numbytes);\n-short mpi2reg(register unitptr r, register byte * buf);\n-short reg2mpi(register byte * buf, register unitptr r);\n-enum RandomNumberType {ANY, ODD, PRIME, BLUMINT};\n-class MPIRegister : public SecBlock<unit>\n-{\n-public:\n-    MPIRegister() : SecBlock<unit>((2048 / 16 ) ) {}\n-};\n-class ostream;\n-class bignum\n-{\n-public:\n-    bignum()\n-        {}\n-    bignum(unsigned long value);\n-    bignum(const char *str)\n-        {str2reg(reg, str);}\n-    enum Signedness{UNSIGNED, SIGNED};\n-    bignum(const byte *encodedBignum, unsigned int byteCount, Signedness s=UNSIGNED)\n-        {Decode(encodedBignum, byteCount, s);}\n-    bignum(const byte *BEREncodedInteger)\n-        {BERDecode(BEREncodedInteger);}\n-    bignum(BufferedTransformation &bt)\n-        {BERDecode(bt);}\n-    bignum(RandomNumberGenerator &rng, unsigned int bitcount)\n-        {Randomize(rng, bitcount);}\n-    bignum(RandomNumberGenerator &rng, const bignum &min, const bignum &max, RandomNumberType rnType=ANY)\n-        {Randomize(rng, min, max, rnType);}\n-    bignum(const bignum& t)\n-        {memcpy(reg, t.reg, (2048 /8) );}\n-    unsigned int Encode(byte *output) const;\n-    unsigned int Encode(byte *output, unsigned int outputLen) const;\n-    void Decode(const byte *input, unsigned int inputLen, Signedness=UNSIGNED);\n-    unsigned int DEREncode(byte *output) const;\n-    unsigned int DEREncode(BufferedTransformation &bt) const;\n-    void BERDecode(const byte *input);\n-    void BERDecode(BufferedTransformation &bt);\n-    void Randomize(RandomNumberGenerator &rng, unsigned int bitcount);\n-    void Randomize(RandomNumberGenerator &rng, const bignum &min, const bignum &max);\n-    void Randomize(RandomNumberGenerator &rng, const bignum &min, const bignum &max, RandomNumberType rnType);\n-    unsigned int ByteCount() const\n-    {\n-        return ((countbits( reg )+7)>>3) ;\n-    }\n-    int BitCount() const\n-    {\n-        return countbits(reg);\n-    }\n-    bignum&  operator++()\n-    {\n-        mp_inc(reg);\n-        return *this;\n-    }\n-    bignum&  operator--()\n-    {\n-        mp_dec(reg);\n-        return *this;\n-    }\n-    int      operator!() const\n-    {\n-        return ( ((* ((   reg.ptr   )+( global_precision )-1) ) ==(  0 )) && (significance( reg.ptr )<=1) ) ;\n-    }\n-    bignum&  operator=(const bignum& t)\n-    {\n-        memcpy(reg, t.reg, (2048 /8) );\n-        return *this;\n-    }\n-    bignum&  operator+=(const bignum& t)\n-    {\n-        mp_addc( reg ,  t.reg ,(boolean)0) ;\n-        return *this;\n-    }\n-    bignum&  operator-=(const bignum& t)\n-    {\n-        mp_subb( reg ,  t.reg ,(boolean)0) ;\n-        return *this;\n-    }\n-    bignum&  operator*=(const bignum& t)\n-    {\n-        *this = (*this) * t;\n-        return *this;\n-    }\n-    bignum&  operator/=(const bignum& t)\n-    {\n-        *this = (*this) / t;\n-        return *this;\n-    }\n-    bignum&  operator%=(const bignum& t)\n-    {\n-        *this = (*this) % t;\n-        return *this;\n-    }\n-    bignum&  operator<<=(unsigned int);\n-    bignum&  operator>>=(unsigned int);\n-    unsigned MaxBitPrecision() const {return 2048 ;}\n-    int operator[](unsigned int n) const;\n-    friend bignum operator+(bignum a, const bignum &b)\n-    {\n-        return (a+=b);\n-    }\n-    friend bignum operator-(bignum a, const bignum &b)\n-    {\n-        return (a-=b);\n-    }\n-    friend bignum operator*(const bignum &a, const bignum &b);\n-    friend bignum operator/(const bignum &a, const bignum &b);\n-    friend bignum operator%(const bignum &a, const bignum &b);\n-    friend bignum operator/(const bignum &a, word16 b);\n-    friend word16 operator%(const bignum &a, word16 b);\n-    friend bignum operator>>(bignum a, unsigned int n)\n-        {return (a>>=n);}\n-    friend bignum operator<<(bignum a, unsigned int n)\n-        {return (a<<=n);}\n-    void Negate() {mp_neg(reg);}\n-    friend bignum operator-(bignum a)\n-    {\n-        a.Negate();\n-        return a;\n-    }\n-    friend int    operator==(const bignum &a, const bignum &b)\n-    {\n-        return (memcmp(a.reg.ptr, b.reg.ptr, (2048 /8) )==0);\n-    }\n-    friend int    operator!=(const bignum& a, const bignum& b)\n-    {\n-        return (memcmp(a.reg.ptr, b.reg.ptr, (2048 /8) )!=0);\n-    }\n-    friend int    operator>(const bignum& a, const bignum& b)\n-    {\n-        return (mp_compare(a.reg, b.reg)>0);\n-    }\n-    friend int    operator>=(const bignum& a, const bignum& b)\n-    {\n-        return (mp_compare(a.reg, b.reg)>=0);\n-    }\n-    friend int    operator<(const bignum& a, const bignum& b)\n-    {\n-        return (mp_compare(a.reg, b.reg)<0);\n-    }\n-    friend int    operator<=(const bignum& a, const bignum& b)\n-    {\n-        return (mp_compare(a.reg, b.reg)<=0);\n-    }\n-    friend bignum a_times_b_mod_c(const bignum &x, const bignum& y, const bignum& m);\n-    friend bignum a_exp_b_mod_c(const bignum &x, const bignum& e, const bignum& m);\n-    class DivideErr {};\n-    friend void Divide(bignum &r, bignum &q,\n-                       const bignum &a, const bignum &d,\n-                       Signedness s=SIGNED);\n-    friend boolean Negative(const bignum &a)\n-    {\n-        return ((signedunit) (* (   a.reg.ptr   ) )  < 0) ;\n-    }\n-    friend bignum Abs(bignum a)\n-    {\n-        (((signedunit) (* (    a.reg.ptr    ) )  < 0)  ? (mp_neg( a.reg.ptr ),TRUE) : FALSE) ;\n-        return a;\n-    }\n-    friend ostream& operator<<(ostream& out, const bignum &a);\n-    unit lsUnit()   {return (* ((  reg.ptr  )+( global_precision )-1) ) ;}\n-private:\n-    MPIRegister reg;\n-};\n-class RSAPublicKey : public PK_Encryptor, public PK_Decryptor,\n-                     public PK_Verifier\n-{\n-public:\n-    RSAPublicKey(const bignum &n, const bignum &e);\n-    RSAPublicKey(BufferedTransformation &bt);\n-    void DEREncode(BufferedTransformation &bt) const;\n-    void Encrypt(RandomNumberGenerator &rng, const byte *plainText, unsigned int plainTextLength, byte *cipherText);\n-    unsigned int Decrypt(const byte *cipherText, byte *plainText);\n-    boolean Verify(const byte *message, unsigned int messageLen, const byte *signature);\n-    unsigned int MaxPlainTextLength() const {return modulusLen-11;}\n-    unsigned int CipherTextLength() const {return modulusLen;}\n-    unsigned int MaxMessageLength() const {return modulusLen-11;}\n-    unsigned int SignatureLength() const {return modulusLen;}\n-    const bignum& Exponent() const {return e;}\n-    const bignum& Modulus() const {return n;}\n-protected:\n-    void RawEncrypt(const bignum &in, bignum &out) const;\n-private:\n-    friend class RSAPrivateKey;\n-    RSAPublicKey() {}\n-    bignum n;            \n-    bignum e;\n-    unsigned int modulusLen;\n-};\n-class RSAPrivateKey : public RSAPublicKey, public PK_Signer\n-{\n-public:\n-    RSAPrivateKey(const bignum &n, const bignum &e, const bignum &d,\n-                  const bignum &p, const bignum &q, const bignum &dp, const bignum &dq, const bignum &u);\n-    RSAPrivateKey(RandomNumberGenerator &rng, int keybits, bignum eStart=17);\n-    RSAPrivateKey(BufferedTransformation &bt);\n-    void DEREncode(BufferedTransformation &bt) const;\n-    void Encrypt(const byte *plainText, unsigned int plainTextLength, byte *cipherText);\n-    unsigned int Decrypt(const byte *cipherText, byte *plainText);\n-    void Encrypt(RandomNumberGenerator &, const byte *plainText, unsigned int plainTextLength, byte *cipherText)\n-        {Encrypt(plainText, plainTextLength, cipherText);}\n-    void Sign(const byte *message, unsigned int messageLen, byte *signature)\n-        {Encrypt(message, messageLen, signature);}\n-    void Sign(RandomNumberGenerator &, const byte *message, unsigned int messageLen, byte *signature)\n-        {Encrypt(message, messageLen, signature);}\n-    unsigned int MaxMessageLength() const {return modulusLen-11;}\n-    unsigned int SignatureLength() const {return modulusLen;}\n-protected:\n-    void RawEncrypt(const bignum &in, bignum &out) const;\n-private:\n-    bignum d;    \n-    bignum p;    \n-    bignum q;\n-    bignum dp;\n-    bignum dq;\n-    bignum u;\n-};\n-bignum Gcd(const bignum &a, const bignum &b);\n-bignum Inverse(const bignum &a, const bignum &m);\n-boolean IsSmallPrime(const bignum &p);\n-boolean SmallDivisorsTest(const bignum &p);\n-boolean FermatTest(const bignum &p, unsigned int rounds);\n-boolean RabinMillerTest(RandomNumberGenerator &rng, const bignum &w, unsigned int rounds);\n-inline boolean IsPrime(const bignum &p)\n-{\n-    return (IsSmallPrime(p) || (SmallDivisorsTest(p) && FermatTest(p, 2)));\n-}\n-boolean NextPrime(bignum &p, const bignum &max, boolean blumInt=FALSE);\n-bignum a_exp_b_mod_pq(const bignum &a, const bignum &ep, const bignum &eq,\n-                      const bignum &p, const bignum &q, const bignum &u);\n-class PrimeAndGenerator\n-{\n-public:\n-    PrimeAndGenerator(RandomNumberGenerator &rng, unsigned int pbits);\n-    PrimeAndGenerator(RandomNumberGenerator &rng, unsigned int pbits, unsigned qbits);\n-    const bignum& Prime() const {return p;}\n-    const bignum& SubPrime() const {return q;}\n-    const bignum& Generator() const {return g;}\n-private:\n-    bignum p, q, g;\n-};\n-extern \"C\" {\n-extern void __eprintf (const char *, const char *, unsigned, const char *);\n-}\n-RSAPublicKey::RSAPublicKey(const bignum &n, const bignum &e)\n-    : n(n), e(e), modulusLen(n.ByteCount())\n-{\n-}\n-RSAPublicKey::RSAPublicKey(BufferedTransformation &bt)\n-{\n-    BERSequenceDecoder seq(bt);\n-    n.BERDecode(seq);\n-    modulusLen = n.ByteCount();\n-    e.BERDecode(seq);\n-}\n-void RSAPublicKey::DEREncode(BufferedTransformation &bt) const\n-{\n-    DERSequenceEncoder seq(bt);\n-    n.DEREncode(seq);\n-    e.DEREncode(seq);\n-}\n-void RSAPublicKey::Encrypt(RandomNumberGenerator &rng, const byte *input, unsigned int inputLen, byte *output)\n-{unsigned int i;\n-    ((void) (( inputLen <= MaxPlainTextLength() ) ? 0 : (__eprintf (\"%s:%u: failed assertion `%s'\\n\",     \"rsa.cpp\" ,   30 ,  \"inputLen <= MaxPlainTextLength()\" ), 0) )) ;\n-    SecByteBlock pkcsBlock(modulusLen);\n-    pkcsBlock[0] = 0;\n-    pkcsBlock[1] = 2;   \n-    for (i = 2; i < modulusLen - inputLen - 1; i++)\n-    {\n-        do\n-            pkcsBlock[i] = rng.GetByte();\n-        while (pkcsBlock[i] == 0);\n-    }\n-    pkcsBlock[i++] = 0;      \n-    memcpy(pkcsBlock+i, input, inputLen);\n-    bignum c;\n-    RawEncrypt(bignum(pkcsBlock, modulusLen), c);\n-    c.Encode(output, modulusLen);\n-}\n-unsigned int RSAPublicKey::Decrypt(const byte *input, byte *output)\n-{unsigned int i;\n-    bignum m;\n-    RawEncrypt(bignum(input, modulusLen), m);\n-    SecByteBlock pkcsBlock(modulusLen);\n-    m.Encode(pkcsBlock, modulusLen);\n-    if ((pkcsBlock[0] != 0) || (pkcsBlock[1] != 1))\n-        return 0;\n-    for (i = 2; i < modulusLen-1; i++)\n-        if (pkcsBlock[i] != 0xff)\n-            break;\n-    if (pkcsBlock[i++] != 0)\n-        return 0;\n-    unsigned int outputLen = modulusLen - i;\n-    if (outputLen > MaxPlainTextLength())\n-        return 0;\n-    memcpy (output, pkcsBlock+i, outputLen);\n-    return outputLen;\n-}\n-boolean RSAPublicKey::Verify(const byte *message, unsigned int messageLen, const byte *signature)\n-{\n-    ((void) (( messageLen <= MaxMessageLength() ) ? 0 : (__eprintf (\"%s:%u: failed assertion `%s'\\n\",     \"rsa.cpp\" ,   83 ,  \"messageLen <= MaxMessageLength()\" ), 0) )) ;\n-    SecByteBlock m(MaxMessageLength());\n-    unsigned int mLen = RSAPublicKey::Decrypt(signature, m);\n-    return (mLen==messageLen && memcmp(message, m, mLen)==0);\n-}\n-void RSAPublicKey::RawEncrypt(const bignum &in, bignum &out) const\n-{\n-    out = a_exp_b_mod_c(in, e, n);\n-}\n-RSAPrivateKey::RSAPrivateKey(const bignum &nIn, const bignum &eIn, const bignum &dIn,\n-                             const bignum &pIn, const bignum &qIn,\n-                             const bignum &dpIn, const bignum &dqIn, const bignum &uIn)\n-    : RSAPublicKey(nIn, eIn)\n-{\n-    d=dIn;\n-    if (pIn < qIn)\n-    {\n-        p=pIn;\n-        q=qIn;\n-        dp=dpIn;\n-        dq=dqIn;\n-    }\n-    else\n-    {\n-        p=qIn;\n-        q=pIn;\n-        dp=dqIn;\n-        dq=dpIn;\n-    }\n-    u=uIn;\n-}\n-RSAPrivateKey::RSAPrivateKey(RandomNumberGenerator &rng, int keybits, bignum eStart)\n-{\n-    p = bignum(rng, keybits/2, PRIME);\n-    const bignum minQ = ((bignum(1) << (keybits-1)) / p) + 1;\n-    const bignum maxQ = (bignum(1) << keybits) / p;\n-    do\n-    {\n-        bignum temp(rng, minQ, maxQ, PRIME);\n-        if (p>temp && p.BitCount()-(p-temp).BitCount() < 7)\n-        {\n-            q=p;\n-            p=temp;\n-            break;\n-        }\n-        if (p<temp && temp.BitCount()-(temp-p).BitCount() < 7)\n-        {\n-            q=temp;\n-            break;\n-        }\n-    } while (1);\n-    bignum phi = (p-1)*(q-1);\n-    for (e = eStart; Gcd(e, phi)!=1; ++e, ++e);\n-    d = Inverse(e, phi/Gcd(p-1, q-1));\n-    dp = d % (p-1);\n-    dq = d % (q-1);\n-    u = Inverse(p, q);\n-    n = p * q;\n-    modulusLen = n.ByteCount();\n-}\n-RSAPrivateKey::RSAPrivateKey(BufferedTransformation &bt)\n-{\n-    BERSequenceDecoder seq(bt);\n-    bignum version(seq);\n-    if (!!version)   \n-        throw BERDecodeErr() ;\n-    n.BERDecode(seq);\n-    modulusLen = n.ByteCount();\n-    e.BERDecode(seq);\n-    d.BERDecode(seq);\n-    p.BERDecode(seq);\n-    q.BERDecode(seq);\n-    dp.BERDecode(seq);\n-    dq.BERDecode(seq);\n-    u.BERDecode(seq);\n-    if (p>q)     \n-    {\n-        swap(p, q);\n-        swap(dp, dq);\n-    }\n-}\n-void RSAPrivateKey::DEREncode(BufferedTransformation &bt) const\n-{\n-    DERSequenceEncoder seq(bt);\n-    byte version[] = {INTEGER, 1, 0};\n-    seq.Put(version, sizeof(version));\n-    n.DEREncode(seq);\n-    e.DEREncode(seq);\n-    d.DEREncode(seq);\n-    q.DEREncode(seq);     \n-    p.DEREncode(seq);\n-    dq.DEREncode(seq);\n-    dp.DEREncode(seq);\n-    u.DEREncode(seq);\n-}"}, {"sha": "7d61b093edd9408c11d6cad59fff5427da154e7d", "filename": "gcc/testsuite/g++.old-deja/g++.mike/p785.C", "status": "removed", "additions": 0, "deletions": 8074, "changes": 8074, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7bc283c660eaa418baf945634ae813ab3dd8f30/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp785.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7bc283c660eaa418baf945634ae813ab3dd8f30/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp785.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp785.C?ref=b7bc283c660eaa418baf945634ae813ab3dd8f30"}]}