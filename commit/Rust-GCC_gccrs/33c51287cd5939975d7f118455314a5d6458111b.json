{"sha": "33c51287cd5939975d7f118455314a5d6458111b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzNjNTEyODdjZDU5Mzk5NzVkN2YxMTg0NTUzMTRhNWQ2NDU4MTExYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2017-01-13T11:23:42Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-13T11:23:42Z"}, "message": "getting_started_with_gnat.rst, [...]: Update documentation.\n\n\t* doc/gnat_ugn/getting_started_with_gnat.rst,\n\tdoc/gnat_ugn/inline_assembler.rst,\n\tdoc/gnat_ugn/building_executable_programs_with_gnat.rst,\n\tdoc/gnat_ugn/elaboration_order_handling_in_gnat.rst,\n\tdoc/gnat_ugn/about_this_guide.rst,\n\tdoc/gnat_ugn/platform_specific_information.rst,\n\tdoc/gnat_ugn/example_of_binder_output.rst,\n\tdoc/gnat_ugn/gnat_and_program_execution.rst,\n\tdoc/gnat_ugn/gnat_utility_programs.rst,\n\tdoc/gnat_ugn/the_gnat_compilation_model.rst,\n\tdoc/gnat_rm/implementation_defined_attributes.rst,\n\tdoc/gnat_rm/compatibility_and_porting_guide.rst,\n\tdoc/gnat_rm/standard_library_routines.rst,\n\tdoc/gnat_rm/standard_and_implementation_defined_restrictions.rst,\n\tdoc/gnat_rm/implementation_defined_pragmas.rst,\n\tdoc/gnat_rm/the_gnat_library.rst,\n\tdoc/gnat_rm/obsolescent_features.rst,\n\tdoc/gnat_rm/about_this_guide.rst,\n\tdoc/gnat_rm/the_implementation_of_standard_i_o.rst,\n\tdoc/gnat_rm/implementation_of_ada_2012_features.rst,\n\tdoc/gnat_rm/interfacing_to_other_languages.rst,\n\tdoc/gnat_rm/implementation_defined_aspects.rst,\n\tdoc/gnat_rm.rst: Update documentation.\n\t* gnat_rm.texi, gnat_ugn.texi: Regenerated.\n\nFrom-SVN: r244426", "tree": {"sha": "6ce40ab741743e7dfc253652c32a4df558ae3f69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ce40ab741743e7dfc253652c32a4df558ae3f69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33c51287cd5939975d7f118455314a5d6458111b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33c51287cd5939975d7f118455314a5d6458111b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33c51287cd5939975d7f118455314a5d6458111b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33c51287cd5939975d7f118455314a5d6458111b/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b5f3c91301332315663d99e624a2efa1bf91a4f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5f3c91301332315663d99e624a2efa1bf91a4f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5f3c91301332315663d99e624a2efa1bf91a4f0"}], "stats": {"total": 3024, "additions": 1724, "deletions": 1300}, "files": [{"sha": "1d6b5c95869ad1e7c70022daac4c3cd5c917d860", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -1,3 +1,30 @@\n+2017-01-13  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* doc/gnat_ugn/getting_started_with_gnat.rst,\n+\tdoc/gnat_ugn/inline_assembler.rst,\n+\tdoc/gnat_ugn/building_executable_programs_with_gnat.rst,\n+\tdoc/gnat_ugn/elaboration_order_handling_in_gnat.rst,\n+\tdoc/gnat_ugn/about_this_guide.rst,\n+\tdoc/gnat_ugn/platform_specific_information.rst,\n+\tdoc/gnat_ugn/example_of_binder_output.rst,\n+\tdoc/gnat_ugn/gnat_and_program_execution.rst,\n+\tdoc/gnat_ugn/gnat_utility_programs.rst,\n+\tdoc/gnat_ugn/the_gnat_compilation_model.rst,\n+\tdoc/gnat_rm/implementation_defined_attributes.rst,\n+\tdoc/gnat_rm/compatibility_and_porting_guide.rst,\n+\tdoc/gnat_rm/standard_library_routines.rst,\n+\tdoc/gnat_rm/standard_and_implementation_defined_restrictions.rst,\n+\tdoc/gnat_rm/implementation_defined_pragmas.rst,\n+\tdoc/gnat_rm/the_gnat_library.rst,\n+\tdoc/gnat_rm/obsolescent_features.rst,\n+\tdoc/gnat_rm/about_this_guide.rst,\n+\tdoc/gnat_rm/the_implementation_of_standard_i_o.rst,\n+\tdoc/gnat_rm/implementation_of_ada_2012_features.rst,\n+\tdoc/gnat_rm/interfacing_to_other_languages.rst,\n+\tdoc/gnat_rm/implementation_defined_aspects.rst,\n+\tdoc/gnat_rm.rst: Update documentation.\n+\t* gnat_rm.texi, gnat_ugn.texi: Regenerated.\n+\n 2017-01-13  Ed Schonberg  <schonberg@adacore.com>\n \n \t* einfo.ads: minor grammar fixes in comment of Normalized_Position_Max."}, {"sha": "e18d1785d31315bffa842e7cddef9db0022a0cd9", "filename": "gcc/ada/doc/gnat_rm.rst", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -4,23 +4,23 @@ GNAT Reference Manual\n *GNAT, The GNU Ada Development Environment*\n \n .. only:: PRO\n-   \n+\n    *GNAT Pro Edition*\n-   \n+\n    | Version |version|\n    | Date: |today|\n \n .. only:: GPL\n-   \n+\n    *GNAT GPL Edition*\n-   \n+\n    | Version |version|\n    | Date: |today|\n \n .. only:: FSF\n-   \n+\n    .. raw:: texinfo\n-      \n+\n       @include gcc-common.texi\n       GCC version @value{version-GCC}@*\n "}, {"sha": "8071b4235d4b9e5121f0f9c679b35b65f5136e62", "filename": "gcc/ada/doc/gnat_rm/about_this_guide.rst", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fabout_this_guide.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fabout_this_guide.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fabout_this_guide.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -114,7 +114,7 @@ This reference manual contains the following chapters:\n .. index:: Ada 2005 Language Reference Manual\n \n This reference manual assumes a basic familiarity with the Ada 95 language, as\n-described in the \n+described in the\n :title:`International Standard ANSI/ISO/IEC-8652:1995`.\n It does not require knowledge of the new features introduced by Ada 2005 or\n Ada 2012.\n@@ -148,10 +148,10 @@ in this guide:\n   ::\n \n     and then shown this way.\n-    \n+\n * Commands that are entered by the user are shown as preceded by a prompt string\n   comprising the ``$`` character followed by a space.\n-  \n+\n Related Information\n ===================\n "}, {"sha": "a859761585fa0c5edafd338926246a33e8ea5e35", "filename": "gcc/ada/doc/gnat_rm/compatibility_and_porting_guide.rst", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fcompatibility_and_porting_guide.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fcompatibility_and_porting_guide.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fcompatibility_and_porting_guide.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -22,7 +22,7 @@ For example, if we write\n .. code-block:: ada\n \n      type F1 is delta 1.0 range -128.0 .. +128.0;\n-  \n+\n then the implementation is allowed to choose -128.0 .. +127.0 if it\n likes, but is not required to do so.\n \n@@ -45,7 +45,7 @@ representation. Let's take another example:\n .. code-block:: ada\n \n       type F2 is delta 2.0**(-15) range -1.0 .. +1.0;\n-  \n+\n Looking at this declaration, it seems casually as though\n it should fit in 16 bits, but again that extra positive value\n +1.0 has the scaled integer equivalent of 2**15 which is one too\n@@ -54,7 +54,7 @@ big for signed 16 bits. The implementation can treat this as:\n .. code-block:: ada\n \n      type F2 is delta 2.0**(-15) range -1.0 .. +1.0-(2.0**(-15));\n-  \n+\n and the Ada language design team felt that this was too annoying\n to require. We don't need to debate this decision at this point,\n since it is well established (the rule about narrowing the ranges\n@@ -77,14 +77,14 @@ approach: to narrow all the time, e.g. to treat\n .. code-block:: ada\n \n      type F3 is delta 1.0 range -10.0 .. +23.0;\n-  \n+\n as though it had been written:\n \n \n .. code-block:: ada\n \n       type F3 is delta 1.0 range -9.0 .. +22.0;\n-  \n+\n But although technically allowed, such a behavior would be hostile and silly,\n and no real compiler would do this. All real compilers will fall into one of\n the categories (a), (b) or (c) above.\n@@ -101,14 +101,14 @@ E.g., for `F2` above, we will write:\n      My_Last  : constant := +1.0 - My_Small;\n \n      type F2 is delta My_Small range My_First .. My_Last;\n-  \n+\n and then add\n \n .. code-block:: ada\n \n      for F2'Small use my_Small;\n      for F2'Size  use 16;\n-  \n+\n In practice all compilers will do the same thing here and will give you\n what you want, so the above declarations are fully portable. If you really\n want to play language lawyer and guard against ludicrous behavior by the\n@@ -118,7 +118,7 @@ compiler you could add\n \n      Test1 : constant := 1 / Boolean'Pos (F2'First = My_First);\n      Test2 : constant := 1 / Boolean'Pos (F2'Last  = My_Last);\n-  \n+\n One or other or both are allowed to be illegal if the compiler is\n behaving in a silly manner, but at least the silly compiler will not\n get away with silently messing with your (very clear) intentions.\n@@ -176,7 +176,7 @@ Ada 95 and later versions of the standard:\n   .. code-block:: ada\n \n        for Char in Character range 'A' .. 'Z' loop ... end loop;\n-    \n+\n * *New reserved words*\n \n   The identifiers `abstract`, `aliased`, `protected`,\n@@ -368,7 +368,7 @@ for a complete description please see the\n \n   Rule changes in this area have led to some incompatibilities; for example,\n   constrained subtypes of some access types are not permitted in Ada 2005.\n- \n+\n * *Aggregates for limited types.*\n \n   The allowance of aggregates for limited types in Ada 2005 raises the\n@@ -517,7 +517,7 @@ Compatibility with Other Ada Systems\n ====================================\n \n If programs avoid the use of implementation dependent and\n-implementation defined features, as documented in the \n+implementation defined features, as documented in the\n :title:`Ada Reference Manual`, there should be a high degree of portability between\n GNAT and other Ada systems.  The following are specific items which\n have proved troublesome in moving Ada 95 programs from GNAT to other Ada 95\n@@ -618,7 +618,7 @@ the cases most likely to arise in existing Ada 83 code.\n \n        type X is access all String;\n        for X'Size use Standard'Address_Size;\n-    \n+\n   which will cause the type X to be represented using a single pointer.\n   When using this representation, the bounds are right behind the array.\n   This representation is slightly less efficient, and does not allow quite\n@@ -658,4 +658,3 @@ applicable to GNAT.\n   that contains the additional definitions, and a special pragma,\n   Extend_System allows this package to be treated transparently as an\n   extension of package System.\n-"}, {"sha": "8d1cf7468bd2f2ea8cb728c443c934e990754199", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_aspects.rst", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_aspects.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_aspects.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_aspects.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -359,6 +359,13 @@ Aspect Lock_Free\n \n This boolean aspect is equivalent to :ref:`pragma Lock_Free<Pragma-Lock_Free>`.\n \n+Aspect Max_Queue_Length\n+=======================\n+\n+.. index:: Max_Queue_Length\n+\n+This aspect is equivalent to :ref:`pragma Max_Queue_Length<Pragma-Max_Queue_Length>`.\n+\n Aspect No_Elaboration_Code_All\n ==============================\n .. index:: No_Elaboration_Code_All\n@@ -447,6 +454,14 @@ Aspect Remote_Access_Type\n \n This aspect is equivalent to :ref:`pragma Remote_Access_Type<Pragma-Remote_Access_Type>`.\n \n+Aspect Secondary_Stack_Size\n+===========================\n+\n+.. index:: Secondary_Stack_Size\n+\n+This aspect is equivalent to :ref:`pragma Secondary_Stack_Size<Pragma-Secondary_Stack_Size>`.\n+\n+\n Aspect Scalar_Storage_Order\n ===========================\n .. index:: Scalar_Storage_Order"}, {"sha": "c813afd59730dedcc03ad6a9a6c7a426e4db8e8f", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_attributes.rst", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -404,6 +404,21 @@ Attribute Fast_Math\n prefix) yields a static Boolean value that is True if pragma\n `Fast_Math` is active, and False otherwise.\n \n+Attribute Finalization_Size\n+===========================\n+.. index:: Finalization_Size\n+\n+The prefix of attribute `Finalization_Size` must be an object or\n+a non-class-wide type. This attribute returns the size of any hidden data\n+reserved by the compiler to handle finalization-related actions. The type of\n+the attribute is `universal_integer`.\n+\n+`Finalization_Size` yields a value of zero for a type with no controlled\n+parts, an object whose type has no controlled parts, or an object of a\n+class-wide type whose tag denotes a type with no controlled parts.\n+\n+Note that only heap-allocated objects contain finalization data.\n+\n Attribute Fixed_Value\n =====================\n .. index:: Fixed_Value"}, {"sha": "b243c8ed1c133fb0f8d778b2fa1c95b392579f41", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_pragmas.rst", "status": "modified", "additions": 93, "deletions": 3, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -427,7 +427,7 @@ Syntax::\n                         Refined_Post         |\n                         Statement_Assertions\n \n-  POLICY_IDENTIFIER ::= Check | Disable | Ignore\n+  POLICY_IDENTIFIER ::= Check | Disable | Ignore | Suppressible\n \n \n This is a standard Ada 2012 pragma that is available as an\n@@ -450,6 +450,8 @@ If the policy is `IGNORE`, then assertions are ignored, i.e.\n the corresponding pragma or aspect is deactivated.\n This pragma overrides the effect of the *-gnata* switch on the\n command line.\n+If the policy is `SUPPRESSIBLE`, then assertions are enabled by default,\n+however, if the *-gnatp* switch is specified all assertions are ignored.\n \n The implementation defined policy `DISABLE` is like\n `IGNORE` except that it completely disables semantic\n@@ -2381,7 +2383,7 @@ Syntax:\n   pragma Implementation_Defined (local_NAME);\n \n \n-This pragma marks a previously declared entioty as implementation-defined.\n+This pragma marks a previously declared entity as implementation-defined.\n For an overloaded entity, applies to the most recent homonym.\n \n \n@@ -3561,6 +3563,19 @@ Syntax::\n This pragma is provided for compatibility with OpenVMS VAX Systems.  It has\n no effect in GNAT, other than being syntax checked.\n \n+Pragma Max_Queue_Length\n+=======================\n+\n+Syntax::\n+\n+   pragma Max_Entry_Queue (static_integer_EXPRESSION);\n+\n+\n+This pragma is used to specify the maximum callers per entry queue for\n+individual protected entries and entry families. It accepts a single\n+positive integer as a parameter and must appear after the declaration\n+of an entry.\n+\n Pragma No_Body\n ==============\n \n@@ -4530,6 +4545,43 @@ aspects, but is prepared to ignore the pragmas. The assertion\n policy that controls this pragma is `Post'Class`, not\n `Post_Class`.\n \n+Pragma Rename_Pragma\n+============================\n+.. index:: Pragmas, synonyms\n+\n+Syntax:\n+\n+\n+::\n+\n+  pragma Rename_Pragma (\n+           [New_Name =>] IDENTIFIER,\n+           [Renamed  =>] pragma_IDENTIFIER);\n+\n+This pragma provides a mechanism for supplying new names for existing\n+pragmas. The `New_Name` identifier can subsequently be used as a synonym for\n+the Renamed pragma. For example, suppose you have code that was originally\n+developed on a compiler that supports Inline_Only as an implementation defined\n+pragma. And suppose the semantics of pragma Inline_Only are identical to (or at\n+least very similar to) the GNAT implementation defined pragma\n+Inline_Always. You could globally replace Inline_Only with Inline_Always.\n+\n+However, to avoid that source modification, you could instead add a\n+configuration pragma:\n+\n+.. code-block:: ada\n+\n+  pragma Rename_Pragma (\n+           New_Name => Inline_Only,\n+           Renamed  => Inline_Always);\n+\n+\n+Then GNAT will treat \"pragma Inline_Only ...\" as if you had written\n+\"pragma Inline_Always ...\".\n+\n+Pragma Inline_Only will not necessarily mean the same thing as the other Ada\n+compiler; it's up to you to make sure the semantics are close enough.\n+\n Pragma Pre\n ==========\n .. index:: Pre\n@@ -4937,6 +4989,9 @@ is defined in the following sections.\n   The ``Simple_Barriers`` restriction has been replaced by\n   ``Pure_Barriers``.\n \n+  The ``Max_Protected_Entries``, ``Max_Entry_Queue_Length``, and\n+  ``No_Relative_Delay`` restrictions have been removed.\n+\n * Pragma Profile (Restricted)\n \n   This profile corresponds to the GNAT restricted run time. It\n@@ -5470,6 +5525,41 @@ run with various special switches as follows:\n   comprehensive messages identifying possible problems based on this\n   information.\n \n+.. _Pragma-Secondary_Stack_Size:\n+\n+Pragma Secondary_Stack_Size\n+===========================\n+\n+Syntax:\n+\n+.. code-block:: ada\n+\n+  pragma Secondary_Stack_Size (integer_EXPRESSION);\n+\n+This pragma appears within the task definition of a single task declaration \n+or a task type declaration (like pragma `Storage_Size`) and applies to all \n+task objects of that type. The argument specifies the size of the secondary \n+stack to be used by these task objects, and must be of an integer type. The\n+secondary stack is used to handle functions that return a variable-sized \n+result, for example a function returning an unconstrained String.\n+\n+Note this pragma only applies to targets using fixed secondary stacks, like\n+VxWorks 653 and bare board targets, where a fixed block for the \n+secondary stack is allocated from the primary stack of the task. By default,\n+these targets assign a percentage of the primary stack for the secondary stack,\n+as defined by `System.Parameter.Sec_Stack_Percentage`. With this pragma, \n+an `integer_EXPRESSION` of bytes is assigned from the primary stack instead.\n+\n+For most targets, the pragma does not apply as the secondary stack grows on \n+demand: allocated as a chain of blocks in the heap. The default size of these \n+blocks can be modified via the `-D` binder option as described in \n+:title:`GNAT User's Guide`.\n+\n+Note that no check is made to see if the secondary stack can fit inside the \n+primary stack.\n+\n+Note the pragma cannot appear when the restriction `No_Secondary_Stack`\n+is in effect.\n \n Pragma Share_Generic\n ====================\n@@ -6853,7 +6943,7 @@ variables whose name contains one of the substrings\n `DISCARD, DUMMY, IGNORE, JUNK, UNUSED` in any casing. Such names\n are typically to be used in cases where such warnings are expected.\n Thus it is never necessary to use `pragma Unmodified` for such\n-variables, though it is harmless to do so. \n+variables, though it is harmless to do so.\n \n Pragma Validity_Checks\n ======================"}, {"sha": "22ef54a959ba26a939b1c626d256e2ba606e3104", "filename": "gcc/ada/doc/gnat_rm/implementation_of_ada_2012_features.rst", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_of_ada_2012_features.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_of_ada_2012_features.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_of_ada_2012_features.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -114,48 +114,48 @@ Supported Aspect                    Source\n ================================== ===========\n   `Ada_2005`                           -- GNAT\n   `Ada_2012`                           -- GNAT\n-  `Address`     \n-  `Alignment`     \n-  `Atomic`     \n-  `Atomic_Components`     \n-  `Bit_Order`     \n-  `Component_Size`     \n+  `Address`\n+  `Alignment`\n+  `Atomic`\n+  `Atomic_Components`\n+  `Bit_Order`\n+  `Component_Size`\n   `Contract_Cases`                     -- GNAT\n-  `Discard_Names`     \n-  `External_Tag`     \n+  `Discard_Names`\n+  `External_Tag`\n   `Favor_Top_Level`                    -- GNAT\n-  `Inline`     \n+  `Inline`\n   `Inline_Always`                      -- GNAT\n   `Invariant`                          -- GNAT\n-  `Machine_Radix`     \n-  `No_Return`     \n+  `Machine_Radix`\n+  `No_Return`\n   `Object_Size`                        -- GNAT\n-  `Pack`     \n+  `Pack`\n   `Persistent_BSS`                     -- GNAT\n-  `Post`     \n-  `Pre`     \n-  `Predicate`     \n-  `Preelaborable_Initialization`     \n+  `Post`\n+  `Pre`\n+  `Predicate`\n+  `Preelaborable_Initialization`\n   `Pure_Function`                      -- GNAT\n   `Remote_Access_Type`                 -- GNAT\n   `Shared`                             -- GNAT\n-  `Size`     \n-  `Storage_Pool`     \n-  `Storage_Size`     \n-  `Stream_Size`     \n-  `Suppress`     \n+  `Size`\n+  `Storage_Pool`\n+  `Storage_Size`\n+  `Stream_Size`\n+  `Suppress`\n   `Suppress_Debug_Info`                -- GNAT\n   `Test_Case`                          -- GNAT\n   `Thread_Local_Storage`               -- GNAT\n-  `Type_Invariant`     \n-  `Unchecked_Union`     \n+  `Type_Invariant`\n+  `Unchecked_Union`\n   `Universal_Aliasing`                 -- GNAT\n   `Unmodified`                         -- GNAT\n   `Unreferenced`                       -- GNAT\n   `Unreferenced_Objects`               -- GNAT\n-  `Unsuppress`     \n+  `Unsuppress`\n   `Value_Size`                         -- GNAT\n-  `Volatile`     \n+  `Volatile`\n   `Volatile_Components`\n   `Warnings`                           -- GNAT\n ================================== ===========\n@@ -436,7 +436,7 @@ Supported Aspect                    Source\n   ::\n \n         (if expr then expr {elsif expr then expr} [else expr])\n-    \n+\n   The parentheses can be omitted in contexts where parentheses are present\n   anyway, such as subprogram arguments and pragma arguments. If the **else**\n   clause is omitted, **else** *True* is assumed;\n@@ -500,7 +500,7 @@ Supported Aspect                    Source\n   .. code-block:: ada\n \n       X := (case Y is when 1 => 2, when 2 => 3, when others => 31)\n-    \n+\n   RM References:  4.05.07 (0)   4.05.08 (0)   4.09 (12)   4.09 (33)\n \n .. index:: AI-0104 (Ada 2012 feature)"}, {"sha": "63fd5ffa345ca35e4f189f48e4ee294a46bf6fee", "filename": "gcc/ada/doc/gnat_rm/interfacing_to_other_languages.rst", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Finterfacing_to_other_languages.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Finterfacing_to_other_languages.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Finterfacing_to_other_languages.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -15,9 +15,9 @@ Interfacing to C\n \n Interfacing to C with GNAT can use one of two approaches:\n \n-* \n+*\n   The types in the package `Interfaces.C` may be used.\n-* \n+*\n   Standard Ada types may be used directly.  This may be less portable to\n   other compilers, but will work on all GNAT compilers, which guarantee\n   correspondence between the C and Ada types.\n@@ -44,7 +44,7 @@ Ada Type                 C Type\n Additionally, there are the following general correspondences between Ada\n and C types:\n \n-* \n+*\n   Ada enumeration types map to C enumeration types directly if pragma\n   `Convention C` is specified, which causes them to have int\n   length.  Without pragma `Convention C`, Ada enumeration types map to\n@@ -53,17 +53,17 @@ and C types:\n   This is the only case in which pragma `Convention C` affects the\n   representation of an Ada type.\n \n-* \n+*\n   Ada access types map to C pointers, except for the case of pointers to\n   unconstrained types in Ada, which have no direct C equivalent.\n \n-* \n+*\n   Ada arrays map directly to C arrays.\n \n-* \n+*\n   Ada records map directly to C structures.\n \n-* \n+*\n   Packed Ada records map to C structures where all members are bit fields\n   of the length corresponding to the ``type'Size`` value in Ada.\n \n@@ -116,7 +116,7 @@ It is also possible to import a C++ exception using the following syntax:\n   pragma Import (Cpp,\n     [Entity =>] LOCAL_NAME,\n     [External_Name =>] static_string_EXPRESSION);\n-  \n+\n \n The `External_Name` is the name of the C++ RTTI symbol. You can then\n cover a specific C++ exception in an exception handler.\n@@ -162,4 +162,3 @@ case in which it is possible to import foreign units of this type,\n provided that the data items passed are restricted to simple scalar\n values or simple record types without variants, or simple array\n types with fixed bounds.\n-"}, {"sha": "6c9b61ed70f218ee0606fce8565c80a673201770", "filename": "gcc/ada/doc/gnat_rm/obsolescent_features.rst", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fobsolescent_features.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fobsolescent_features.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fobsolescent_features.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -56,7 +56,7 @@ Syntax\n .. code-block:: ada\n \n   pragma Task_Info (EXPRESSION);\n-  \n+\n This pragma appears within a task definition (like pragma\n `Priority`) and applies to the task in which it appears.  The\n argument must be of type `System.Task_Info.Task_Info_Type`."}, {"sha": "78c489b2d1e9731e3c003b979553120faeea7a11", "filename": "gcc/ada/doc/gnat_rm/standard_and_implementation_defined_restrictions.rst", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fstandard_and_implementation_defined_restrictions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fstandard_and_implementation_defined_restrictions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fstandard_and_implementation_defined_restrictions.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -584,7 +584,8 @@ No_Secondary_Stack\n [GNAT] This restriction ensures at compile time that the generated code\n does not contain any reference to the secondary stack.  The secondary\n stack is used to implement functions returning unconstrained objects\n-(arrays or records) on some targets.\n+(arrays or records) on some targets. Suppresses the allocation of \n+secondary stacks for tasks (excluding the environment task) at run time.\n \n No_Select_Statements\n --------------------"}, {"sha": "6c9ac9fc4915e66c90ab195042576e056ddf1bf2", "filename": "gcc/ada/doc/gnat_rm/standard_library_routines.rst", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fstandard_library_routines.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fstandard_library_routines.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fstandard_library_routines.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -317,7 +317,7 @@ the unit is not implemented.\n   The following predefined instantiations of this package are provided:\n \n   * ``Short_Float``\n-  \n+\n     `Ada.Numerics.Short_Complex_Elementary_Functions`\n \n   * ``Float``\n@@ -706,4 +706,3 @@ the unit is not implemented.\n \n For packages in Interfaces and System, all the RM defined packages are\n available in GNAT, see the Ada 2012 RM for full details.\n-"}, {"sha": "57607fe8bd27a20de1d72a043f97a624de7ab19e", "filename": "gcc/ada/doc/gnat_rm/the_gnat_library.rst", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fthe_gnat_library.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fthe_gnat_library.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fthe_gnat_library.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -1996,6 +1996,21 @@ This package provides a limited binding to the VxWorks API.\n In particular, it interfaces with the\n VxWorks hardware interrupt facilities.\n \n+.. _`Interfaces.VxWorks.Int_Connection_(i-vxinco.ads)`:\n+\n+`Interfaces.VxWorks.Int_Connection` (:file:`i-vxinco.ads`)\n+==========================================================\n+\n+.. index:: Interfaces.VxWorks.Int_Connection (i-vxinco.ads)\n+\n+.. index:: Interfacing to VxWorks\n+\n+.. index:: VxWorks, interfacing\n+\n+This package provides a way for users to replace the use of\n+intConnect() with a custom routine for installing interrupt\n+handlers.\n+\n .. _`Interfaces.VxWorks.IO_(i-vxwoio.ads)`:\n \n `Interfaces.VxWorks.IO` (:file:`i-vxwoio.ads`)"}, {"sha": "e04fb9a33574b696ba6ffa99ea2faef8adfd6c9d", "filename": "gcc/ada/doc/gnat_rm/the_implementation_of_standard_i_o.rst", "status": "modified", "additions": 55, "deletions": 56, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fthe_implementation_of_standard_i_o.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fthe_implementation_of_standard_i_o.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fthe_implementation_of_standard_i_o.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -39,37 +39,37 @@ Standard I/O Packages\n \n The Standard I/O packages described in Annex A for\n \n-* \n+*\n   Ada.Text_IO\n-* \n+*\n   Ada.Text_IO.Complex_IO\n-* \n+*\n   Ada.Text_IO.Text_Streams\n-* \n+*\n   Ada.Wide_Text_IO\n-* \n+*\n   Ada.Wide_Text_IO.Complex_IO\n-* \n+*\n   Ada.Wide_Text_IO.Text_Streams\n-* \n+*\n   Ada.Wide_Wide_Text_IO\n-* \n+*\n   Ada.Wide_Wide_Text_IO.Complex_IO\n-* \n+*\n   Ada.Wide_Wide_Text_IO.Text_Streams\n-* \n+*\n   Ada.Stream_IO\n-* \n+*\n   Ada.Sequential_IO\n-* \n+*\n   Ada.Direct_IO\n \n are implemented using the C\n library streams facility; where\n \n-* \n+*\n   All files are opened using `fopen`.\n-* \n+*\n   All input/output operations use `fread`/`fwrite`.\n \n There is no internal buffering of any kind at the Ada library level. The only\n@@ -94,7 +94,7 @@ The format of a FORM string in GNAT is:\n ::\n \n   \"keyword=value,keyword=value,...,keyword=value\"\n-  \n+\n \n where letters may be in upper or lower case, and there are no spaces\n between values.  The order of the entries is not important.  Currently\n@@ -107,7 +107,7 @@ the following keywords defined.\n   SHARED=[YES|NO]\n   WCEM=[n|h|u|s|e|8|b]\n   ENCODING=[UTF8|8BITS]\n-  \n+\n \n The use of these parameters is described later in this section. If an\n unrecognized keyword appears in a form string, it is silently ignored\n@@ -173,7 +173,7 @@ arrays.  For example, the following will raise `Data_Error`:\n    IO.Read (F, S);\n    Put_Line (S);\n \n-  \n+\n \n On some Ada implementations, this will print `hell`, but the program is\n clearly incorrect, since there is only one element in the file, and that\n@@ -196,21 +196,21 @@ special control characters:\n \n   LF (line feed, 16#0A#) Line Mark\n   FF (form feed, 16#0C#) Page Mark\n-  \n+\n \n A canonical Text_IO file is defined as one in which the following\n conditions are met:\n \n-* \n+*\n   The character `LF` is used only as a line mark, i.e., to mark the end\n   of the line.\n \n-* \n+*\n   The character `FF` is used only as a page mark, i.e., to mark the\n   end of a page and consequently can appear only immediately following a\n   `LF` (line mark) character.\n \n-* \n+*\n   The file ends with either `LF` (line mark) or `LF`-`FF`\n   (line mark, page mark).  In the former case, the page mark is implicitly\n   assumed to be present.\n@@ -229,16 +229,16 @@ Manual, and all the routines in Text_IO are fully implemented.\n A text file that does not meet the requirements for a canonical Text_IO\n file has one of the following:\n \n-* \n+*\n   The file contains `FF` characters not immediately following a\n   `LF` character.\n \n-* \n+*\n   The file contains `LF` or `FF` characters written by\n   `Put` or `Put_Line`, which are not logically considered to be\n   line marks or page marks.\n \n-* \n+*\n   The file ends in a character other than `LF` or `FF`,\n   i.e., there is no explicit line mark or page mark at the end of the file.\n \n@@ -260,14 +260,14 @@ is being read.  No internal buffering occurs in Text_IO, and usually the\n physical position in the stream used to implement the file corresponds\n to this logical position defined by Text_IO.  There are two exceptions:\n \n-* \n+*\n   After a call to `End_Of_Page` that returns `True`, the stream\n   is positioned past the `LF` (line mark) that precedes the page\n   mark.  Text_IO maintains an internal flag so that subsequent read\n   operations properly handle the logical position which is unchanged by\n   the `End_Of_Page` call.\n \n-* \n+*\n   After a call to `End_Of_File` that returns `True`, if the\n   Text_IO file was positioned before the line mark at the end of file\n   before the call, then the logical position is unchanged, but the stream\n@@ -298,19 +298,19 @@ marks.  Any `Ascii.FF` characters (the character normally used for a\n page mark) appearing in the file are considered to be data\n characters.  In particular:\n \n-* \n+*\n   `Get_Line` and `Skip_Line` do not test for a page mark\n   following a line mark.  If a page mark appears, it will be treated as a\n   data character.\n \n-* \n+*\n   This avoids the need to wait for an extra character to be typed or\n   entered from the pipe to complete one of these operations.\n \n-* \n+*\n   `End_Of_Page` always returns `False`\n \n-* \n+*\n   `End_Of_File` will return `False` if there is a page mark at\n   the end of the file.\n \n@@ -440,7 +440,7 @@ specified using a FORM parameter:\n ::\n \n   WCEM=`x`\n-  \n+\n \n as part of the FORM string (WCEM = wide character encoding method),\n where `x` is one of the following characters\n@@ -477,7 +477,7 @@ being brackets encoding if no coding method was specified with -gnatW).\n ::\n \n     ESC a b c d\n-    \n+\n ..\n \n   where `a`, `b`, `c`, `d` are the four hexadecimal\n@@ -524,7 +524,7 @@ being brackets encoding if no coding method was specified with -gnatW).\n     16#0000#-16#007f#: 2#0xxxxxxx#\n     16#0080#-16#07ff#: 2#110xxxxx# 2#10xxxxxx#\n     16#0800#-16#ffff#: 2#1110xxxx# 2#10xxxxxx# 2#10xxxxxx#\n-    \n+\n ..\n \n   where the `xxx` bits correspond to the left-padded bits of the\n@@ -545,7 +545,7 @@ being brackets encoding if no coding method was specified with -gnatW).\n ::\n \n     [ \" a b c d \" ]\n-    \n+\n ..\n \n   where `a`, `b`, `c`, `d` are the four hexadecimal\n@@ -590,7 +590,7 @@ being brackets encoding if no coding method was specified with -gnatW).\n ::\n \n        Start of output [\"5B\"]first run]\n-    \n+\n ..\n \n   In practice brackets encoding is reasonably useful for normal Put_Line use\n@@ -623,7 +623,7 @@ normal lower ASCII set (i.e., a character in the range:\n .. code-block:: ada\n \n   Wide_Character'Val (16#0080#) .. Wide_Character'Val (16#FFFF#)\n-  \n+\n \n then although the logical position of the file pointer is unchanged by\n the `Look_Ahead` call, the stream is physically positioned past the\n@@ -658,7 +658,7 @@ specified using a FORM parameter:\n ::\n \n   WCEM=`x`\n-  \n+\n \n as part of the FORM string (WCEM = wide character encoding method),\n where `x` is one of the following characters\n@@ -701,7 +701,7 @@ being brackets encoding if no coding method was specified with -gnatW).\n     16#000080#-16#0007ff#: 2#110xxxxx# 2#10xxxxxx#\n     16#000800#-16#00ffff#: 2#1110xxxx# 2#10xxxxxx# 2#10xxxxxx#\n     16#010000#-16#10ffff#: 2#11110xxx# 2#10xxxxxx# 2#10xxxxxx# 2#10xxxxxx#\n-    \n+\n ..\n \n   where the `xxx` bits correspond to the left-padded bits of the\n@@ -719,7 +719,7 @@ being brackets encoding if no coding method was specified with -gnatW).\n ::\n \n     [ \" a b c d \" ]\n-    \n+\n ..\n \n   and by the following ten character sequence if not\n@@ -728,7 +728,7 @@ being brackets encoding if no coding method was specified with -gnatW).\n ::\n \n     [ \" a b c d e f \" ]\n-    \n+\n ..\n \n   where `a`, `b`, `c`, `d`, `e`, and `f`\n@@ -767,7 +767,7 @@ normal lower ASCII set (i.e., a character in the range:\n .. code-block:: ada\n \n   Wide_Wide_Character'Val (16#0080#) .. Wide_Wide_Character'Val (16#10FFFF#)\n-  \n+\n \n then although the logical position of the file pointer is unchanged by\n the `Look_Ahead` call, the stream is physically positioned past the\n@@ -798,11 +798,11 @@ written to the file as described in the Ada Reference Manual.  The type\n `Stream_Element` is simply a byte.  There are two ways to read or\n write a stream file.\n \n-* \n+*\n   The operations `Read` and `Write` directly read or write a\n   sequence of stream elements with no control information.\n \n-* \n+*\n   The stream attributes applied to a stream file transfer data in the\n   manner described for stream attributes.\n \n@@ -816,7 +816,7 @@ passed to Text_IO.Create and Text_IO.Open. ``Text_Translation=xxx``\n has no effect on Unix systems. Possible values are:\n \n \n-* \n+*\n   ``Yes`` or ``Text`` is the default, which means to\n   translate LF to/from CR/LF on Windows systems.\n \n@@ -825,15 +825,15 @@ has no effect on Unix systems. Possible values are:\n   may be used to create Unix-style files on\n   Windows.\n \n-* \n+*\n   ``wtext`` translation enabled in Unicode mode.\n   (corresponds to _O_WTEXT).\n \n-* \n+*\n   ``u8text`` translation enabled in Unicode UTF-8 mode.\n   (corresponds to O_U8TEXT).\n \n-* \n+*\n   ``u16text`` translation enabled in Unicode UTF-16\n   mode. (corresponds to_O_U16TEXT).\n \n@@ -851,21 +851,21 @@ To provide a full range of functionality, while at the same time\n minimizing the problems of portability caused by this implementation\n dependence, GNAT handles file sharing as follows:\n \n-* \n+*\n   In the absence of a ``shared=xxx`` form parameter, an attempt\n   to open two or more files with the same full name is considered an error\n   and is not supported.  The exception `Use_Error` will be\n   raised.  Note that a file that is not explicitly closed by the program\n   remains open until the program terminates.\n \n-* \n+*\n   If the form parameter ``shared=no`` appears in the form string, the\n   file can be opened or created with its own separate stream identifier,\n   regardless of whether other files sharing the same external file are\n   opened.  The exact effect depends on how the C stream routines handle\n   multiple accesses to the same external files using separate streams.\n \n-* \n+*\n   If the form parameter ``shared=yes`` appears in the form string for\n   each of two or more files opened using the same full name, the same\n   stream is shared between these files, and the semantics are as described\n@@ -905,11 +905,11 @@ Filenames encoding\n An encoding form parameter can be used to specify the filename\n encoding ``encoding=xxx``.\n \n-* \n+*\n   If the form parameter ``encoding=utf8`` appears in the form string, the\n   filename must be encoded in UTF-8.\n \n-* \n+*\n   If the form parameter ``encoding=8bits`` appears in the form\n   string, the filename must be a standard 8bits string.\n \n@@ -979,7 +979,7 @@ using the mode shown in the following table:\n +----------------------------+---------------+------------------+\n | Inout_File                 |   \"r+\"        |    \"w+\"          |\n +----------------------------+---------------+------------------+\n-  \n+\n \n If text file translation is required, then either ``b`` or ``t``\n is added to the mode, depending on the setting of Text.  Text file\n@@ -1153,7 +1153,7 @@ access to the C library functions for operations on C streams:\n     -- Maximum length of an allowable full path name on the\n     -- system, including a terminating NUL character.\n   end Interfaces.C_Streams;\n-  \n+\n \n .. _Interfacing_to_C_Streams:\n \n@@ -1231,7 +1231,7 @@ operations.\n          C_Stream : in Interfaces.C_Streams.FILEs;\n          Form : in String := \"\");\n    end Ada.Stream_IO.C_Streams;\n-  \n+\n \n In each of these six packages, the `C_Stream` function obtains the\n `FILE` pointer from a currently opened Ada file.  It is then\n@@ -1249,4 +1249,3 @@ The `Open` procedures in these packages open a file giving an\n existing C Stream instead of a file name.  Typically this stream is\n imported from a C program, allowing an Ada file to operate on an\n existing C file.\n-"}, {"sha": "079b20ba31dbef91a9c281d47c8bc1c97b430888", "filename": "gcc/ada/doc/gnat_ugn/about_this_guide.rst", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fabout_this_guide.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fabout_this_guide.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fabout_this_guide.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -45,11 +45,11 @@ This guide contains the following chapters:\n   with GNAT\n \n Appendices cover several additional topics:\n-  \n+\n * :ref:`Platform_Specific_Information` describes the different run-time\n   library implementations and also presents information on how to use\n   GNAT on several specific platforms\n-  \n+\n * :ref:`Example_of_Binder_Output_File` shows the source code for the binder\n   output file for a sample program.\n \n@@ -136,7 +136,7 @@ the new document structure.\n \n * :ref:`GNAT_Utility_Programs` is a new chapter consolidating the information about several\n   GNAT tools:\n-  \n+\n   .. only:: PRO or GPL\n \n     - :ref:`The_File_Cleanup_Utility_gnatclean`\n@@ -149,7 +149,7 @@ the new document structure.\n     - :ref:`The_GNAT_Pretty-Printer_gnatpp`\n     - :ref:`The_Body_Stub_Generator_gnatstub`\n     - :ref:`The_Unit_Test_Generator_gnattest`\n-  \n+\n   .. only:: FSF\n \n     - :ref:`The_File_Cleanup_Utility_gnatclean`\n@@ -206,12 +206,11 @@ in this guide:\n   ::\n \n     and then shown this way.\n-    \n+\n * Commands that are entered by the user are shown as preceded by a prompt string\n   comprising the ``$`` character followed by a space.\n \n * Full file names are shown with the '/' character\n   as the directory separator; e.g., :file:`parent-dir/subdir/myfile.adb`.\n   If you are using GNAT on a Windows platform, please note that\n   the '\\\\' character should be used instead.\n-"}, {"sha": "5b8d930bf734797e722c8f9214a33b490cabe9b9", "filename": "gcc/ada/doc/gnat_ugn/building_executable_programs_with_gnat.rst", "status": "modified", "additions": 84, "deletions": 29, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -28,14 +28,14 @@ how to make use of the general GNU make mechanism\n in a GNAT context (see :ref:`Using_the_GNU_make_Utility`).\n \n .. only:: PRO or GPL\n-  \n+\n    For building large systems with components possibly written\n    in different languages (such as Ada, C, C++ and Fortran)\n    and organized into subsystems and libraries, the GPRbuild\n    tool can be used. This tool, and the Project Manager\n    facility that it is based upon, is described in\n    *GPRbuild and GPR Companion Tools User's Guide*.\n-\t  \n+\n \n .. _The_GNAT_Make_Program_gnatmake:\n \n@@ -527,7 +527,7 @@ You may specify any of the following switches to *gnatmake*:\n :samp:`-P{project}`\n   Use project file `project`. Only one such switch can be used.\n \n-.. -- Comment:  \n+.. -- Comment:\n   :ref:`gnatmake_and_Project_Files`.\n \n \n@@ -1445,9 +1445,7 @@ Alphabetical List of All Switches\n   *-gnatc* as a builder switch (before *-cargs* or in package\n   Builder of the project file) then *gnatmake* will not fail because\n   it will not look for the object files after compilation, and it will not try\n-  to build and link. This switch may not be given if a previous `-gnatR`\n-  switch has been given, since `-gnatR` requires that the code generator\n-  be called to complete determination of representation information.\n+  to build and link.\n \n \n .. index:: -gnatC  (gcc)\n@@ -1476,7 +1474,7 @@ Alphabetical List of All Switches\n \n :samp:`-gnatD`\n   Create expanded source files for source level debugging. This switch\n-  also suppress generation of cross-reference information\n+  also suppresses generation of cross-reference information\n   (see *-gnatx*). Note that this switch is not allowed if a previous\n   -gnatR switch has been given, since these two switches are not compatible.\n \n@@ -1917,8 +1915,8 @@ Alphabetical List of All Switches\n .. index:: -gnatn  (gcc)\n \n :samp:`-gnatn[12]`\n-  Activate inlining for subprograms for which pragma `Inline` is\n-  specified. This inlining is performed by the GCC back-end. An optional\n+  Activate inlining across modules for subprograms for which pragma `Inline`\n+  is specified. This inlining is performed by the GCC back-end. An optional\n   digit sets the inlining level: 1 for moderate inlining across modules\n   or 2 for full inlining across modules. If no inlining level is specified,\n   the compiler will pick it based on the optimization level.\n@@ -5417,16 +5415,16 @@ Subprogram Inlining Control\n .. index:: -gnatn  (gcc)\n \n :samp:`-gnatn[12]`\n-  The `n` here is intended to suggest the first syllable of the\n-  word 'inline'.\n-  GNAT recognizes and processes `Inline` pragmas. However, for the\n-  inlining to actually occur, optimization must be enabled and, in order\n-  to enable inlining of subprograms specified by pragma `Inline`,\n+  The `n` here is intended to suggest the first syllable of the word 'inline'.\n+  GNAT recognizes and processes `Inline` pragmas. However, for inlining to\n+  actually occur, optimization must be enabled and, by default, inlining of\n+  subprograms across modules is not performed. If you want to additionally\n+  enable inlining of subprograms specified by pragma `Inline` across modules,\n   you must also specify this switch.\n-  In the absence of this switch, GNAT does not attempt\n-  inlining and does not need to access the bodies of\n-  subprograms for which `pragma Inline` is specified if they are not\n-  in the current unit.\n+\n+  In the absence of this switch, GNAT does not attempt inlining across modules\n+  and does not access the bodies of subprograms for which `pragma Inline` is\n+  specified if they are not in the current unit.\n \n   You can optionally specify the inlining level: 1 for moderate inlining across\n   modules, which is a good compromise between compilation times and performances\n@@ -5659,7 +5657,7 @@ Debugging Control\n   you to do source level debugging using the generated code which is\n   sometimes useful for complex code, for example to find out exactly\n   which part of a complex construction raised an exception. This switch\n-  also suppress generation of cross-reference information (see\n+  also suppresses generation of cross-reference information (see\n   *-gnatx*) since otherwise the cross-reference information\n   would refer to the :file:`.dg` file, which would cause\n   confusion since this is not the original source file.\n@@ -5727,12 +5725,6 @@ Debugging Control\n   this case, the component clause uses an obvious extension of permitted\n   Ada syntax, for example `at 0 range 0 .. -1`.\n \n-  Representation information requires that code be generated (since it is the\n-  code generator that lays out complex data structures). If an attempt is made\n-  to output representation information when no code is generated, for example\n-  when a subunit is compiled on its own, then no information can be generated\n-  and the compiler outputs a message to this effect.\n-\n \n .. index:: -gnatS  (gcc)\n \n@@ -5901,6 +5893,21 @@ there is no point in using *-m* switches to improve performance\n unless you actually see a performance improvement.\n \n \n+.. _Linker_Switches:\n+\n+Linker Switches\n+===============\n+\n+Linker switches can be specified after :samp:`-largs` builder switch.\n+\n+.. index:: -fuse-ld=name\n+\n+:samp:`-fuse-ld={name}`\n+  Linker to be used. The default is ``bfd`` for :file:`ld.bfd`,\n+  the alternative being ``gold`` for :file:`ld.gold`. The later is\n+  a more recent and faster linker, but only available on GNU/Linux\n+  platforms.\n+\n .. _Binding_with_gnatbind:\n \n Binding with `gnatbind`\n@@ -6113,10 +6120,12 @@ be presented in subsequent sections.\n   blocks (whose size is the minimum of the default secondary stack size value,\n   and the actual size needed for the current allocation request).\n \n-  For certain targets, notably VxWorks 653,\n-  the secondary stack is allocated by carving off a fixed ratio chunk of the\n-  primary task stack. The -D option is used to define the\n-  size of the environment task's secondary stack.\n+  For certain targets, notably VxWorks 653 and bare board targets,\n+  the secondary stack is allocated by carving off a chunk of the primary task \n+  stack. By default this is a fixed percentage of the primary task stack as\n+  defined by System.Parameter.Sec_Stack_Percentage. This can be overridden per \n+  task using the Secondary_Stack_Size pragma/aspect. The -D option is used to\n+  define the size of the environment task's secondary stack.\n \n \n .. index:: -e  (gnatbind)\n@@ -6151,6 +6160,11 @@ be presented in subsequent sections.\n   Currently the same as `-Ea`.\n \n \n+.. index:: -f  (gnatbind)\n+\n+:samp:`-f{elab-order}`\n+  Force elaboration order.\n+\n .. index:: -F  (gnatbind)\n \n :samp:`-F`\n@@ -6600,6 +6614,47 @@ The following switches provide additional control over the elaboration\n order. For full details see :ref:`Elaboration_Order_Handling_in_GNAT`.\n \n \n+.. index:: -f  (gnatbind)\n+\n+:samp:`-f{elab-order}`\n+  Force elaboration order.\n+\n+  `elab-order` should be the name of a \"forced elaboration order file\", that\n+  is, a text file containing library item names, one per line. A name of the\n+  form \"some.unit%s\" or \"some.unit (spec)\" denotes the spec of Some.Unit. A\n+  name of the form \"some.unit%b\" or \"some.unit (body)\" denotes the body of\n+  Some.Unit. Each pair of lines is taken to mean that there is an elaboration\n+  dependence of the second line on the first. For example, if the file\n+  contains:\n+\n+  .. code-block:: ada\n+\n+      this (spec)\n+      this (body)\n+      that (spec)\n+      that (body)\n+\n+  then the spec of This will be elaborated before the body of This, and the\n+  body of This will be elaborated before the spec of That, and the spec of That\n+  will be elaborated before the body of That. The first and last of these three\n+  dependences are already required by Ada rules, so this file is really just\n+  forcing the body of This to be elaborated before the spec of That.\n+\n+  The given order must be consistent with Ada rules, or else `gnatbind` will\n+  give elaboration cycle errors. For example, if you say x (body) should be\n+  elaborated before x (spec), there will be a cycle, because Ada rules require\n+  x (spec) to be elaborated before x (body); you can't have the spec and body\n+  both elaborated before each other.\n+\n+  If you later add \"with That;\" to the body of This, there will be a cycle, in\n+  which case you should erase either \"this (body)\" or \"that (spec)\" from the\n+  above forced elaboration order file.\n+\n+  Blank lines and Ada-style comments are ignored. Unit names that do not exist\n+  in the program are ignored. Units in the GNAT predefined library are also\n+  ignored.\n+\n+\n   .. index:: -p  (gnatbind)\n \n :samp:`-p`"}, {"sha": "1e96e311116a439366ad8e00af56f26f23657471", "filename": "gcc/ada/doc/gnat_ugn/elaboration_order_handling_in_gnat.rst", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Felaboration_order_handling_in_gnat.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Felaboration_order_handling_in_gnat.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Felaboration_order_handling_in_gnat.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -1661,8 +1661,8 @@ and\n ::\n \n     Init_Constants spec\n-    Init_Constants body\n     Constants spec\n+    Init_Constants body\n     Calc spec\n     Main body\n \n@@ -1703,7 +1703,7 @@ compilers can choose different orders.\n However, GNAT does attempt to diagnose the common situation where there\n are uninitialized variables in the visible part of a package spec, and the\n corresponding package body has an elaboration block that directly or\n-indirectly initialized one or more of these variables. This is the situation\n+indirectly initializes one or more of these variables. This is the situation\n in which a pragma Elaborate_Body is usually desirable, and GNAT will generate\n a warning that suggests this addition if it detects this situation.\n "}, {"sha": "4e78164a0c2c36399cec75106ce56882a1ccd953", "filename": "gcc/ada/doc/gnat_ugn/example_of_binder_output.rst", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fexample_of_binder_output.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fexample_of_binder_output.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fexample_of_binder_output.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -727,7 +727,7 @@ Comments have been added for clarification purposes.\n   -- END Object file/option list\n \n   end ada_main;\n-  \n+\n \n The Ada code in the above example is exactly what is generated by the\n binder. We have added comments to more clearly indicate the function\n@@ -743,8 +743,7 @@ you can place a breakpoint on the call:\n   .. code-block:: ada\n \n      Ada.Text_Io'Elab_Body;\n-  \n+\n and trace the elaboration routine for this package to find out where\n the problem might be (more usually of course you would be debugging\n elaboration code in your own application).\n-"}, {"sha": "f34b701ac09d94da47accde60afb6e79c3f9a7e6", "filename": "gcc/ada/doc/gnat_ugn/getting_started_with_gnat.rst", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgetting_started_with_gnat.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgetting_started_with_gnat.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgetting_started_with_gnat.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -75,7 +75,7 @@ as the command prompt in the examples in this document):\n .. code-block:: sh\n \n   $ gcc -c hello.adb\n-  \n+\n \n *gcc* is the command used to run the compiler. This compiler is\n capable of compiling programs in several languages, including Ada and\n@@ -273,4 +273,3 @@ Ada make tools, *gnatmake* does not rely on the dependencies that were\n found by the compiler on a previous compilation, which may possibly\n be wrong when sources change. *gnatmake* determines the exact set of\n dependencies from scratch each time it is run.\n-"}, {"sha": "b090236b48c09abb1b2cdd929a6b1774f8bf31b1", "filename": "gcc/ada/doc/gnat_ugn/gnat_and_program_execution.rst", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_and_program_execution.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_and_program_execution.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_and_program_execution.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -1740,10 +1740,9 @@ following conditions are met:\n   .. index:: Inline\n \n * Any one of the following applies: `pragma Inline` is applied to the\n-  subprogram and the *-gnatn* switch is specified; the\n-  subprogram is local to the unit and called once from within it; the\n-  subprogram is small and optimization level *-O2* is specified;\n-  optimization level *-O3* is specified.\n+  subprogram; the subprogram is local to the unit and called once from\n+  within it; the subprogram is small and optimization level *-O2* is\n+  specified; optimization level *-O3* is specified.\n \n Calls to subprograms in |withed| units are normally not inlined.\n To achieve actual inlining (that is, replacement of the call by the code\n@@ -1755,8 +1754,6 @@ in the body of the subprogram), the following conditions must all be true:\n   and not contain something that *gcc* cannot support in inlined\n   subprograms.\n \n-* The call appears in a body (not in a package spec).\n-\n * There is a `pragma Inline` for the subprogram.\n \n * The *-gnatn* switch is used on the command line.\n@@ -1806,7 +1803,7 @@ additional dependencies.\n .. index:: -fno-inline (gcc)\n \n Note: The *-fno-inline* switch overrides all other conditions and ensures that\n-no inlining occurs, unless requested with pragma Inline_Always for gcc\n+no inlining occurs, unless requested with pragma Inline_Always for *gcc*\n back-ends. The extra dependences resulting from *-gnatn* will still be active,\n even if this switch is used to suppress the resulting inlining actions.\n "}, {"sha": "062d6b90cdc3188670533809ea9013179c77af91", "filename": "gcc/ada/doc/gnat_ugn/gnat_utility_programs.rst", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_utility_programs.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_utility_programs.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_utility_programs.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -632,11 +632,7 @@ The following switches are available for *gnatxref*:\n .. index:: -pFILE (gnatxref)\n \n :samp:`p{FILE}`\n-  Specify a project file to use (see the *GNAT_Project_Manager*\n-  chapter in the *GPRbuild User's Guide*).\n-  If you need to use the :file:`.gpr`\n-  project files, you should use gnatxref through the GNAT driver\n-  (*gnat xref -Pproject*).\n+  Specify a project file to use.\n \n   By default, `gnatxref` and `gnatfind` will try to locate a\n   project file in the current directory.\n@@ -836,8 +832,7 @@ The following switches are available:\n .. index:: -pFILE (gnatfind)\n \n :samp:`p{FILE}`\n-  Specify a project file (see the *GNAT_Project_Manager* chapter in the\n-  *GPRbuild User's Guide*).\n+  Specify a project file.\n   By default, `gnatxref` and `gnatfind` will try to locate a\n   project file in the current directory.\n \n@@ -3060,7 +3055,7 @@ Alternatively, you may run the script using the following command line:\n    .. index:: -nt (gnatpp)\n \n \n-   :samp:`-neD`\n+   :samp:`-ntD`\n      Names introduced by type and subtype declarations are always\n      cased as they appear in the declaration in the source file.\n      Overrides -n casing setting.\n@@ -4206,6 +4201,14 @@ Alternatively, you may run the script using the following command line:\n   a skeleton for each visible subprogram in the packages under consideration when\n   they do not exist already.\n \n+  *gnattest* is a project-aware tool.\n+  (See :ref:`Using_Project_Files_with_GNAT_Tools` for a description of\n+  the project-related switches but note that *gnattest* does not support\n+  the :samp:`-U`, :samp:`-eL`, :samp:`--subdirs={dir}`, or\n+  :samp:`--no_objects_dir` switches.)\n+  The project file package that can specify\n+  *gnattest* switches is named ``gnattest``.\n+\n   The user can choose to generate a single test driver\n   that will run all individual tests, or separate test drivers for each test. The\n   second option allows much greater flexibility in test execution environment,\n@@ -4354,12 +4357,6 @@ Alternatively, you may run the script using the following command line:\n     Recursively considers all sources from all projects.\n \n \n-    .. index:: -X (gnattest)\n-\n-  :samp:`-X{name}={value}`\n-    Indicate that external variable `name` has the value `value`.\n-\n-\n     .. index:: --RTS (gnattest)\n \n   :samp:`--RTS={rts-path}`\n@@ -5050,7 +5047,7 @@ Alternatively, you may run the script using the following command line:\n    with a number of GNAT tools.\n    For a comprehensive description of project files and the overall\n    GNAT Project Manager facility, please refer to the\n-   *GNAT Project Manager* chapter in the \n+   *GNAT Project Manager* chapter in the\n    *GPRbuild and GPR Companion Tools User's Guide*.\n \n    .. index:: Project-aware tool\n@@ -5072,7 +5069,7 @@ Alternatively, you may run the script using the following command line:\n \n    :samp:`-U`\n       If a project file is supplied, say for project ``proj``,\n-      but no sources are specified for ``proj`` (either by a \n+      but no sources are specified for ``proj`` (either by a\n       project attribute or through a tool option that provides a list\n       of the files to be used), process all the source files\n       from projects imported either directly or indirectly by ``proj``.\n@@ -5108,7 +5105,7 @@ Alternatively, you may run the script using the following command line:\n    defined by that project, either implicitly by residing in the project\n    source directories, or explicitly through any of the source-related\n    attributes).\n-  \n+\n    .. _Tool-specific_packages_in_project files:\n \n    Tool-specific packages in project files\n@@ -5121,4 +5118,4 @@ Alternatively, you may run the script using the following command line:\n    A tool-specific package in a project file may define the ``Default_Switches``\n    attribute indexed by \"ada\" (as language name). The value of this attribute\n    is a list of switches that will be supplied at tool invocation.\n-   Project-specific switches cannot be specified through this attribute. \n+   Project-specific switches cannot be specified through this attribute."}, {"sha": "f2c0e7213826f4b5f6ad6a4bbf4d0e365310f249", "filename": "gcc/ada/doc/gnat_ugn/inline_assembler.rst", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Finline_assembler.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Finline_assembler.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Finline_assembler.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -119,7 +119,7 @@ from which it generates a sequence of assembly language instructions.\n \n The examples in this chapter will illustrate several of the forms\n for invoking `Asm`; a complete specification of the syntax\n-is found in the `Machine_Code_Insertions` section of the \n+is found in the `Machine_Code_Insertions` section of the\n :title:`GNAT Reference Manual`.\n \n Under the standard GNAT conventions, the `Nothing` procedure\n@@ -129,15 +129,15 @@ You can build the executable in the usual way:\n   ::\n \n      $ gnatmake nothing\n-  \n+\n However, the interesting aspect of this example is not its run-time behavior\n but rather the generated assembly code.\n To see this output, invoke the compiler as follows:\n \n   ::\n \n      $  gcc -c -S -fomit-frame-pointer -gnatp nothing.adb\n-  \n+\n where the options are:\n \n * :samp:`-c`\n@@ -191,7 +191,7 @@ Assembling the file using the command\n \n   ::\n \n-     $ as nothing.s  \n+     $ as nothing.s\n \n will give you error messages whose lines correspond to the assembler\n input file, so you can easily find and correct any mistakes you made.\n@@ -224,7 +224,7 @@ statements.\n              Outputs => Unsigned_32'Asm_Output (\"=g\", Flags));\n         Put_Line (\"Flags register:\" & Flags'Img);\n      end Get_Flags;\n-  \n+\n In order to have a nicely aligned assembly listing, we have separated\n multiple assembler statements in the Asm template string with linefeed\n (ASCII.LF) and horizontal tab (ASCII.HT) characters.\n@@ -243,15 +243,15 @@ It would have been legal to write the Asm invocation as:\n   .. code-block:: ada\n \n      Asm (\"pushfl popl %%eax movl %%eax, %0\")\n-  \n+\n but in the generated assembler file, this would come out as:\n \n   ::\n \n      #APP\n         pushfl popl %eax movl %eax, -40(%ebp)\n      #NO_APP\n-  \n+\n which is not so convenient for the human reader.\n \n We use Ada comments\n@@ -273,7 +273,7 @@ the third statement in the Asm template string:\n   ::\n \n      movl %%eax, %0\n-  \n+\n The intent is to store the contents of the eax register in a variable that can\n be accessed in Ada.  Simply writing `movl %%eax, Flags` would not\n necessarily work, since the compiler might optimize by using a register\n@@ -288,29 +288,29 @@ parameter to `Asm`:\n   .. code-block:: ada\n \n      Outputs => Unsigned_32'Asm_Output (\"=g\", Flags));\n-  \n+\n The output is defined by the `Asm_Output` attribute of the target type;\n the general format is\n \n   .. code-block:: ada\n \n      Type'Asm_Output (constraint_string, variable_name)\n-  \n+\n The constraint string directs the compiler how\n to store/access the associated variable.  In the example\n \n   .. code-block:: ada\n \n      Unsigned_32'Asm_Output (\"=m\", Flags);\n-  \n+\n the `\"m\"` (memory) constraint tells the compiler that the variable\n `Flags` should be stored in a memory variable, thus preventing\n the optimizer from keeping it in a register.  In contrast,\n \n   .. code-block:: ada\n \n      Unsigned_32'Asm_Output (\"=r\", Flags);\n-  \n+\n uses the `\"r\"` (register) constraint, telling the compiler to\n store the variable in a register.\n \n@@ -352,7 +352,7 @@ integer.  Thus in\n           \"popl %%eax\"      & LF & HT & -- load eax with flags\n           \"movl %%eax, %0\",             -- store flags in variable\n           Outputs => Unsigned_32'Asm_Output (\"=g\", Flags));\n-    \n+\n \n `%0` will be replaced in the expanded code by the appropriate operand,\n whatever\n@@ -375,7 +375,7 @@ For example:\n           Outputs => (Unsigned_32'Asm_Output (\"=g\", Var_A),   --  %0 = Var_A\n                       Unsigned_32'Asm_Output (\"=g\", Var_B),   --  %1 = Var_B\n                       Unsigned_32'Asm_Output (\"=g\", Var_C))); --  %2 = Var_C\n-  \n+\n where `Var_A`, `Var_B`, and `Var_C` are variables\n in the Ada program.\n \n@@ -398,7 +398,7 @@ variable, instead of including the store instruction explicitly in the\n              Outputs => Unsigned_32'Asm_Output (\"=a\", Flags));\n         Put_Line (\"Flags register:\" & Flags'Img);\n      end Get_Flags_2;\n-  \n+\n The `\"a\"` constraint tells the compiler that the `Flags`\n variable will come from the eax register. Here is the resulting code:\n \n@@ -409,7 +409,7 @@ variable will come from the eax register. Here is the resulting code:\n         popl %eax\n      #NO_APP\n         movl %eax,-40(%ebp)\n-  \n+\n The compiler generated the store of eax into Flags after\n expanding the assembler code.\n \n@@ -430,7 +430,7 @@ more simply, we could just pop the flags directly into the program variable:\n              Outputs => Unsigned_32'Asm_Output (\"=g\", Flags));\n         Put_Line (\"Flags register:\" & Flags'Img);\n      end Get_Flags_3;\n-  \n+\n \n .. _Input_Variables_in_Inline_Assembler:\n \n@@ -465,7 +465,7 @@ The program simply increments its input value by 1:\n         Value := Incr (Value);\n        Put_Line (\"Value after is\" & Value'Img);\n      end Increment;\n-  \n+\n The `Outputs` parameter to `Asm` specifies\n that the result will be in the eax register and that it is to be stored\n in the `Result` variable.\n@@ -505,7 +505,7 @@ The resulting assembler file (with *-O2* optimization) contains:\n         movl %ecx,(%esp)\n         addl $4,%esp\n         ret\n-  \n+\n \n .. _Inlining_Inline_Assembler_Code:\n \n@@ -545,7 +545,7 @@ Here is the resulting program:\n         Value := Increment (Value);\n         Put_Line (\"Value after is\" & Value'Img);\n      end Increment_2;\n- \n+\n Compile the program with both optimization (*-O2*) and inlining\n (*-gnatn*) enabled.\n \n@@ -557,7 +557,7 @@ point in `Increment` where our function used to be called:\n \n      pushl %edi\n      call _increment__incr.1\n-  \n+\n the code for the function body directly appears:\n \n \n@@ -607,7 +607,7 @@ assembly code; for example:\n           \"movl %%ebx, %1\",\n           Outputs => Unsigned_32'Asm_Output (\"=g\", Var_Out),\n           Inputs  => Unsigned_32'Asm_Input  (\"g\", Var_In));\n-  \n+\n where the compiler (since it does not analyze the `Asm` template string)\n does not know you are using the ebx register.\n \n@@ -622,7 +622,7 @@ to identify the registers that will be used by your assembly code:\n           Outputs => Unsigned_32'Asm_Output (\"=g\", Var_Out),\n           Inputs  => Unsigned_32'Asm_Input  (\"g\", Var_In),\n           Clobber => \"ebx\");\n-  \n+\n The Clobber parameter is a static string expression specifying the\n register(s) you are using.  Note that register names are *not* prefixed\n by a percent sign. Also, if more than one register is used then their names\n@@ -657,7 +657,7 @@ the `Volatile` parameter to `True`; for example:\n           Inputs   => Unsigned_32'Asm_Input  (\"g\", Var_In),\n           Clobber  => \"ebx\",\n           Volatile => True);\n-  \n+\n By default, `Volatile` is set to `False` unless there is no\n `Outputs` parameter.\n "}, {"sha": "8c94f907598279ec9d3d1144d59d36aaafe75328", "filename": "gcc/ada/doc/gnat_ugn/platform_specific_information.rst", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fplatform_specific_information.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fplatform_specific_information.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fplatform_specific_information.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -160,7 +160,7 @@ For example on x86-linux::\n \n   .. image:: rtlibrary-structure.png\n \n-.. only:: not (html or latex) \n+.. only:: not (html or latex)\n \n    ::\n \n@@ -562,7 +562,7 @@ and::\n \n    Ada.Command_Line.Argument (1) -> \"'*.txt'\"\n \n-   \n+\n .. _Mixed-Language_Programming_on_Windows:\n \n Mixed-Language Programming on Windows\n@@ -1944,7 +1944,7 @@ cookbook-style sequence of steps to follow:\n      $ gprbuild -p mylib.gpr\n \n 2. Produce a .def file for the symbols you need to interface with, either by\n-   hand or automatically with possibly some manual adjustments \n+   hand or automatically with possibly some manual adjustments\n    (see :ref:`Creating Definition File Automatically <Create_Def_File_Automatically>`):\n \n   ::"}, {"sha": "faedd8ae72d2cf157c793bb5d0900092b2e2e5ba", "filename": "gcc/ada/doc/gnat_ugn/the_gnat_compilation_model.rst", "status": "modified", "additions": 102, "deletions": 102, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fthe_gnat_compilation_model.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fthe_gnat_compilation_model.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fthe_gnat_compilation_model.rst?ref=33c51287cd5939975d7f118455314a5d6458111b", "patch": "@@ -27,7 +27,7 @@ the following material:\n   * :ref:`Source_Representation`\n   * :ref:`Foreign_Language_Representation`\n   * :ref:`File_Naming_Topics_and_Utilities`\n-  \n+\n * :ref:`Configuration_Pragmas`\n * :ref:`Generating_Object_Files`\n * :ref:`Source_Dependencies`\n@@ -217,7 +217,7 @@ possible encoding schemes:\n   character sequence::\n \n     ESC a b c d\n-    \n+\n   where `a`, `b`, `c`, `d` are the four hexadecimal\n   characters (using uppercase letters) of the wide character code. For\n   example, ESC A345 is used to represent the wide character with code\n@@ -281,7 +281,7 @@ possible encoding schemes:\n   character sequence::\n \n     [ \" a b c d \" ]\n-    \n+\n   where `a`, `b`, `c`, `d` are the four hexadecimal\n   characters (using uppercase letters) of the wide character code. For\n   example, ['A345'] is used to represent the wide character with code\n@@ -293,7 +293,7 @@ possible encoding schemes:\n   and is also the method used for wide character encoding in some standard\n   ACATS (Ada Conformity Assessment Test Suite) test suite distributions.\n \n-.. note:: \n+.. note::\n \n   Some of these coding schemes do not permit the full use of the\n   Ada character set. For example, neither Shift JIS nor EUC allow the\n@@ -321,7 +321,7 @@ possible encoding schemes:\n                                  10xxxxxx 10xxxxxx\n     16#0400_0000#-16#7FFF_FFFF#: 1111110x 10xxxxxx 10xxxxxx\n                                  10xxxxxx 10xxxxxx 10xxxxxx\n-    \n+\n \n   where the `xxx` bits correspond to the left-padded bits of the\n   32-bit character value.\n@@ -332,7 +332,7 @@ possible encoding schemes:\n \n     [ \" a b c d e f \" ]\n     [ \" a b c d e f g h \" ]\n-    \n+\n   where `a-h` are the six or eight hexadecimal\n   characters (using uppercase letters) of the wide wide character code. For\n   example, [\"1F4567\"] is used to represent the wide wide character with code\n@@ -441,7 +441,7 @@ The form of this pragma is as shown in the following examples:\n         Spec_File_Name => \"myutilst_a.ada\");\n       pragma Source_File_name (My_Utilities.Stacks,\n         Body_File_Name => \"myutilst.ada\");\n-  \n+\n As shown in this example, the first argument for the pragma is the unit\n name (in this example a child unit). The second argument has the form\n of a named association. The identifier\n@@ -467,7 +467,7 @@ of the language, here `ada`, as in:\n .. code-block:: sh\n \n      $ gcc -c -x ada peculiar_file_name.sim\n-  \n+\n `gnatmake` handles non-standard file names in the usual manner (the\n non-standard file name for the main program is simply used as the\n argument to gnatmake). Note that if the extension is also non-standard,\n@@ -573,7 +573,7 @@ two pragmas appear:\n        (Spec_File_Name => \".1.ada\");\n      pragma Source_File_Name\n        (Body_File_Name => \".2.ada\");\n-  \n+\n The default GNAT scheme is actually implemented by providing the following\n default pragmas internally:\n \n@@ -583,7 +583,7 @@ default pragmas internally:\n        (Spec_File_Name => \".ads\", Dot_Replacement => \"-\");\n      pragma Source_File_Name\n        (Body_File_Name => \".adb\", Dot_Replacement => \"-\");\n-  \n+\n Our final example implements a scheme typically used with one of the\n Ada 83 compilers, where the separator character for subunits was '__'\n (two underscores), specs were identified by adding :file:`_.ADA`, bodies\n@@ -609,7 +609,7 @@ the same double underscore separator for child units.\n         Casing = Uppercase);\n \n \n-.. index:: ! gnatname  \n+.. index:: ! gnatname\n \n .. _Handling_Arbitrary_File_Naming_Conventions_with_gnatname:\n \n@@ -654,7 +654,7 @@ The usual form of the `gnatname` command is:\n \n       $ gnatname [`switches`] `naming_pattern` [`naming_patterns`]\n           [--and [`switches`] `naming_pattern` [`naming_patterns`]]\n-  \n+\n \n All of the arguments are optional. If invoked without any argument,\n `gnatname` will display its usage.\n@@ -683,7 +683,7 @@ Examples of Naming Patterns are::\n      \"*.[12].ada\"\n      \"*.ad[sb]*\"\n      \"body_*\"    \"spec_*\"\n-  \n+\n For a more complete description of the syntax of Naming Patterns,\n see the second kind of regular expressions described in :file:`g-regexp.ads`\n (the 'Glob' regular expressions).\n@@ -784,7 +784,7 @@ You may specify any of the following switches to `gnatname`:\n   .. code-block:: sh\n \n      gnatname -Pprj -f\"*.c\" \"*.ada\"\n-    \n+\n   will look for Ada units in all files with the :file:`.ada` extension,\n   and will add to the list of file for project :file:`prj.gpr` the C files\n   with extension :file:`.c`.\n@@ -833,7 +833,7 @@ You may specify any of the following switches to `gnatname`:\n   .. code-block:: sh\n \n       gnatname -x \"*_nt.ada\" \"*.ada\"\n-    \n+\n   will look for Ada units in all files with the :file:`.ada` extension,\n   except those whose names end with :file:`_nt.ada`.\n \n@@ -846,7 +846,7 @@ Examples of `gnatname` Usage\n .. code-block:: sh\n \n      $ gnatname -c /home/me/names.adc -d sources \"[a-z]*.ada*\"\n-  \n+\n In this example, the directory :file:`/home/me` must already exist\n and be writable. In addition, the directory\n :file:`/home/me/sources` (specified by\n@@ -858,7 +858,7 @@ Note the optional spaces after *-c* and *-d*.\n \n      $ gnatname -P/home/me/proj -x \"*_nt_body.ada\"\n      -dsources -dsources/plus -Dcommon_dirs.txt \"body_*\" \"spec_*\"\n-  \n+\n Note that several switches *-d* may be used,\n even in conjunction with one or several switches\n *-D*. Several Naming Patterns and one excluded pattern\n@@ -920,7 +920,7 @@ The `gnatkr` command has the form:\n .. code-block:: sh\n \n       $ gnatkr `name` [`length`]\n-  \n+\n `name` is the uncrunched file name, derived from the name of the unit\n in the standard manner described in the previous section (i.e., in particular\n all dots are replaced by hyphens). The file name may or may not have an\n@@ -989,7 +989,7 @@ the specified length by following these rules:\n       ou  st      wi   fix   9\n       ou  st      wi   fi    8\n       Final file name: oustwifi.adb\n-    \n+\n * The file names for all predefined units are always krunched to eight\n   characters. The krunching of these predefined units uses the following\n   special prefix replacements:\n@@ -1023,7 +1023,7 @@ the specified length by following these rules:\n       a-  st      wi   fix   9\n       a-  st      wi   fi    8\n       Final file name: a-stwifi.adb\n-    \n+\n Of course no file shortening algorithm can guarantee uniqueness over all\n possible unit names, and if file name krunching is used then it is your\n responsibility to ensure that no name clashes occur. The utility\n@@ -1043,7 +1043,7 @@ Examples of `gnatkr` Usage\n     $ gnatkr grandparent-parent-child     --> grparchi\n     $ gnatkr very_long_unit_name.ads/count=6 --> vlunna.ads\n     $ gnatkr very_long_unit_name.ads/count=0 --> very_long_unit_name.ads\n-  \n+\n \n .. _Renaming_Files_with_gnatchop:\n \n@@ -1160,7 +1160,7 @@ The `gnatchop` command has the form:\n \n      $ gnatchop switches file_name [file_name ...]\n            [directory]\n-  \n+\n The only required argument is the file name of the file to be chopped.\n There are no restrictions on the form of this file name. The file itself\n contains one or more Ada units, in normal GNAT format, concatenated\n@@ -1179,19 +1179,19 @@ file called :file:`hellofiles` containing\n .. code-block:: ada\n \n      procedure Hello;\n-  \n+\n      with Ada.Text_IO; use Ada.Text_IO;\n      procedure Hello is\n      begin\n         Put_Line (\"Hello\");\n      end Hello;\n-  \n+\n the command\n \n .. code-block:: sh\n \n      $ gnatchop hellofiles\n-  \n+\n generates two files in the current directory, one called\n :file:`hello.ads` containing the single line that is the procedure spec,\n and the other called :file:`hello.adb` containing the remaining text. The\n@@ -1214,13 +1214,13 @@ the command\n .. code-block:: sh\n \n      $ gnatchop toto.txt\n-  \n+\n will not produce any new file and will result in the following warnings::\n \n      toto.txt:1:01: warning: empty file, contains no compilation units\n      no compilation units found\n      no source files written\n-  \n+\n \n .. _Switches_for_gnatchop:\n \n@@ -1355,7 +1355,7 @@ directory are modified).\n .. code-block:: sh\n \n       $ gnatchop archive\n-   \n+\n Chops the source file :file:`archive`\n into the current directory. One\n useful application of `gnatchop` is in sending sets of sources\n@@ -1368,7 +1368,7 @@ file names.\n .. code-block:: sh\n \n       $ gnatchop file1 file2 file3 direc\n-   \n+\n Chops all units in files :file:`file1`, :file:`file2`, :file:`file3`, placing\n the resulting files in the directory :file:`direc`. Note that if any units\n occur more than once anywhere within this set of files, an error message\n@@ -1390,7 +1390,7 @@ Configuration Pragmas\n Configuration pragmas include those pragmas described as\n such in the Ada Reference Manual, as well as\n implementation-dependent pragmas that are configuration pragmas.\n-See the `Implementation_Defined_Pragmas` chapter in the \n+See the `Implementation_Defined_Pragmas` chapter in the\n :title:`GNAT_Reference_Manual` for details on these\n additional GNAT-specific configuration pragmas.\n Most notably, the pragma `Source_File_Name`, which allows\n@@ -1446,6 +1446,7 @@ recognized by GNAT::\n      Propagate_Exceptions\n      Queuing_Policy\n      Ravenscar\n+     Rename_Pragma\n      Restricted_Run_Time\n      Restrictions\n      Restrictions_Warnings\n@@ -1464,7 +1465,7 @@ recognized by GNAT::\n      Validity_Checks\n      Warnings\n      Wide_Character_Encoding\n-  \n+\n \n .. _Handling_of_Configuration_Pragmas:\n \n@@ -1892,13 +1893,13 @@ Here is a simple library project file:\n          for Library_Dir use \"lib\";\n          for Library_Kind use \"dynamic\";\n        end My_lib;\n-  \n+\n and the compilation command to build and install the library:\n \n .. code-block:: sh\n \n      $ gnatmake -Pmy_lib\n-  \n+\n It is not entirely trivial to perform manually all the steps required to\n produce a library. We recommend that you use the GNAT Project Manager\n for this task. In special cases where this is not desired, the necessary\n@@ -1925,7 +1926,7 @@ Here is an example of such a dummy program:\n        begin\n           null;\n        end;\n-  \n+\n Here are the generic commands that will build an archive or a shared library.\n \n .. code-block:: sh\n@@ -1950,7 +1951,7 @@ Here are the generic commands that will build an archive or a shared library.\n      # Make the ALI files read-only so that gnatmake will not try to\n      # regenerate the objects that are in the library\n      $ chmod -w *.ali\n-  \n+\n Please note that the library must have a name of the form :file:`lib{xxx}.a`\n or :file:`lib{xxx}.so` (or :file:`lib{xxx}.dll` on Windows) in order to\n be accessed by the directive :samp:`-l{xxx}` at link time.\n@@ -1980,7 +1981,7 @@ file. The location of the gcc spec file can be determined as follows:\n .. code-block:: sh\n \n      $ gcc -v\n-  \n+\n \n The configuration files mentioned above have a simple format: each line\n must contain one unique directory name.\n@@ -2029,7 +2030,7 @@ write:\n        project My_Proj is\n          ...\n        end My_Proj;\n-  \n+\n Even if you have a third-party, non-Ada library, you can still use GNAT's\n Project Manager facility to provide a wrapper for it. For example, the\n following project, when |withed| by your main project, will link with the\n@@ -2044,7 +2045,7 @@ third-party library :file:`liba.a`:\n           for Library_Name use \"a\";\n           for Library_Kind use \"static\";\n        end Liba;\n-  \n+\n This is an alternative to the use of `pragma Linker_Options`. It is\n especially interesting in the context of systems with several interdependent\n static libraries where finding a proper linker order is not easy and best be\n@@ -2064,7 +2065,7 @@ For example, you can use the library :file:`mylib` installed in\n \n      $ gnatmake -aI/dir/my_lib_src -aO/dir/my_lib_obj my_appl \\\\\n        -largs -lmy_lib\n-  \n+\n This can be expressed more simply:\n \n .. code-block:: sh\n@@ -2087,7 +2088,7 @@ when the following conditions are met:\n   .. code-block:: ada\n \n        pragma Linker_Options (\"-lmy_lib\");\n-    \n+\n Note that you may also load a library dynamically at\n run time given its filename, as illustrated in the GNAT :file:`plugins` example\n in the directory :file:`share/examples/gnat/plugins` within the GNAT\n@@ -2150,11 +2151,11 @@ that make a project a Library Project (`Library_Name` and\n the attribute `Library_Interface` must be defined.  For example:\n \n .. code-block:: gpr\n- \n+\n        for Library_Dir use \"lib_dir\";\n        for Library_Name use \"dummy\";\n        for Library_Interface use (\"int1\", \"int1.child\");\n-  \n+\n Attribute `Library_Interface` has a non-empty string list value,\n each string in the list designating a unit contained in an immediate source\n of the project file.\n@@ -2195,7 +2196,7 @@ build an encapsulated library the attribute\n        for Library_Kind use \"dynamic\";\n        for Library_Interface use (\"int1\", \"int1.child\");\n        for Library_Standalone use \"encapsulated\";\n-  \n+\n The default value for this attribute is `standard` in which case\n a stand-alone library is built.\n \n@@ -2226,13 +2227,13 @@ occasions when it is necessary here are the steps that you need to perform:\n   .. code-block:: sh\n \n       $ gnatbind -n int1.ali int2.ali -Lsal1\n-    \n+\n * Compile the binder generated file:\n \n   .. code-block:: sh\n \n       $ gcc -c b~int2.adb\n-    \n+\n * Link the dynamic library with all the necessary object files,\n   indicating to the linker the names of the `init` (and possibly\n   `final`) procedures for automatic initialization (and finalization).\n@@ -2273,7 +2274,7 @@ Here is an example of simple library interface for use with C main program:\n           pragma Export (C, Do_Something_Else, \"do_something_else\");\n \n        end My_Package;\n-  \n+\n On the foreign language side, you must provide a 'foreign' view of the\n library interface; remember that it should contain elaboration routines in\n addition to interface subprograms.\n@@ -2292,7 +2293,7 @@ that there is no rule for the naming of this file, any name can be used)\n        /* the interface exported by the library */\n        extern void do_something (void);\n        extern void do_something_else (void);\n-  \n+\n Libraries built as explained above can be used from any program, provided\n that the elaboration procedures (named `mylibinit` in the previous\n example) are called before the library services are used. Any number of\n@@ -2310,7 +2311,7 @@ Below is an example of a C program that uses the `mylib` library.\n        {\n           /* First, elaborate the library before using it */\n           mylibinit ();\n- \n+\n           /* Main program, using the library exported entities */\n           do_something ();\n           do_something_else ();\n@@ -2387,7 +2388,7 @@ be determined by means of the command:\n .. code-block:: sh\n \n       $ gnatls -v\n-  \n+\n The last entry in the object search path usually contains the\n gnat library. This Makefile contains its own documentation and in\n particular the set of instructions needed to rebuild a new library and\n@@ -2453,7 +2454,7 @@ constants to control which code is executed.\n       if FP_Initialize_Required then\n       ...\n       end if;\n-  \n+\n Not only will the code inside the `if` statement not be executed if\n the constant Boolean is `False`, but it will also be completely\n deleted from the program.\n@@ -2475,7 +2476,7 @@ something like:\n           Reset_Available        : constant Boolean := False;\n           ...\n        end Config;\n- \n+\n The `Config` package exists in multiple forms for the various targets,\n with an appropriate script selecting the version of `Config` needed.\n Then any other unit requiring conditional compilation can do a |with|\n@@ -2520,13 +2521,13 @@ example, the last test could be written:\n .. code-block:: ada\n \n        pragma Assert (Temperature <= 999.0, \"Temperature Crazy\");\n-  \n+\n or simply\n \n .. code-block:: ada\n \n        pragma Assert (Temperature <= 999.0);\n-  \n+\n In both cases, if assertions are active and the temperature is excessive,\n the exception `Assert_Failure` will be raised, with the given string in\n the first case or a string indicating the location of the pragma in the second\n@@ -2552,7 +2553,7 @@ For the example above with the `Put_Line`, the GNAT-specific pragma\n .. code-block:: ada\n \n        pragma Debug (Put_Line (\"got to the first stage!\"));\n-  \n+\n If debug pragmas are enabled, the argument, which must be of the form of\n a procedure call, is executed (in this case, `Put_Line` will be called).\n Only one call can be present, but of course a special debugging procedure\n@@ -2593,7 +2594,7 @@ to add a `null` statement.\n           pragma Assert (Num_Cases < 10);\n           null;\n        end if;\n- \n+\n .. _Conditionalizing_Declarations:\n \n Conditionalizing Declarations\n@@ -2691,7 +2692,7 @@ to compile with an Ada 95 compiler. Conceptually you want to say:\n        else\n           ... not quite as neat Ada 95 code\n        end if;\n- \n+\n where `Ada_2005` is a Boolean constant.\n \n But this won't work when `Ada_2005` is set to `False`,\n@@ -2721,7 +2722,7 @@ This can also be done with project files' naming schemes. For example:\n .. code-block:: gpr\n \n        for body (\"File_Queries.Insert\") use \"file_queries-insert-2005.ada\";\n-  \n+\n Note also that with project files it is desirable to use a different extension\n than :file:`ads` / :file:`adb` for alternative versions. Otherwise a naming\n conflict may arise through another commonly used feature: to declare as part\n@@ -3024,22 +3025,22 @@ In this example, <expression> is defined by the following grammar::\n        <expression> ::=  <expression> and then <expression>\n        <expression> ::=  <expression> or else <expression>\n        <expression> ::=  ( <expression> )\n-  \n+\n Note the following restriction: it is not allowed to have \"and\" or \"or\"\n following \"not\" in the same expression without parentheses. For example, this\n is not allowed:\n \n .. code-block:: ada\n \n        not X or Y\n-  \n+\n This can be expressed instead as one of the following forms:\n \n .. code-block:: ada\n \n      (not X) or Y\n      not (X or Y)\n-  \n+\n For the first test (<expression> ::= <symbol>) the symbol must have\n either the value true or false, that is to say the right-hand of the\n symbol definition must be one of the (case-insensitive) literals\n@@ -3089,7 +3090,7 @@ Symbol substitution outside of preprocessor lines is obtained by using\n the sequence::\n \n       $symbol\n-  \n+\n anywhere within a source line, except in a comment or within a\n string literal. The identifier\n following the `$` must match one of the symbols defined in the symbol\n@@ -3303,7 +3304,7 @@ the main subprogram in Ada:\n \n     /* file1.c */\n     #include <stdio.h>\n-  \n+\n     void print_num (int num)\n     {\n       printf (\"num is %d.\\\\n\", num);\n@@ -3313,15 +3314,15 @@ the main subprogram in Ada:\n .. code-block:: c\n \n     /* file2.c */\n-  \n+\n     /* num_from_Ada is declared in my_main.adb */\n     extern int num_from_Ada;\n- \n+\n     int get_num (void)\n     {\n       return num_from_Ada;\n     }\n-  \n+\n .. code-block:: ada\n \n     --  my_main.adb\n@@ -3344,7 +3345,7 @@ the main subprogram in Ada:\n     begin\n        Print_Num (Get_Num);\n     end My_Main;\n-  \n+\n To build this example:\n \n * First compile the foreign language files to\n@@ -3354,7 +3355,7 @@ To build this example:\n \n       $ gcc -c file1.c\n       $ gcc -c file2.c\n-    \n+\n * Then, compile the Ada units to produce a set of object files and ALI\n   files:\n \n@@ -3374,13 +3375,13 @@ To build this example:\n   .. code-block:: sh\n \n       $ gnatlink my_main.ali file1.o file2.o\n-    \n+\n The last three steps can be grouped in a single command:\n \n .. code-block:: sh\n-  \n+\n    $ gnatmake my_main.adb -largs file1.o file2.o\n-  \n+\n \n .. index:: Binder output file\n \n@@ -3419,7 +3420,7 @@ sources.  To illustrate, we have the following example:\n \n         adafinal();\n      }\n-  \n+\n .. code-block:: ada\n \n      --  unit1.ads\n@@ -3455,7 +3456,7 @@ sources.  To illustrate, we have the following example:\n            return A - B;\n         end Sub;\n      end Unit2;\n-  \n+\n The build procedure for this application is similar to the last\n example's:\n \n@@ -3464,7 +3465,7 @@ example's:\n   .. code-block:: sh\n \n       $ gcc -c main.c\n-    \n+\n \n * Next, compile the Ada units to produce a set of object files and ALI\n   files:\n@@ -3473,21 +3474,21 @@ example's:\n \n       $ gnatmake -c unit1.adb\n       $ gnatmake -c unit2.adb\n-    \n+\n * Run the Ada binder on every generated ALI file.  Make sure to use the\n   :option:`-n` option to specify a foreign main program:\n \n   .. code-block:: sh\n \n       $ gnatbind -n unit1.ali unit2.ali\n-    \n+\n * Link the Ada main program, the Ada objects and the foreign language\n   objects. You need only list the last ALI file here:\n \n   .. code-block:: sh\n \n       $ gnatlink unit2.ali main.o -o exec_file\n-    \n+\n   This procedure yields a binary executable called :file:`exec_file`.\n \n Depending on the circumstances (for example when your non-Ada main object\n@@ -3673,7 +3674,7 @@ Convention identifiers are recognized by GNAT:\n       function \"/\" (D : Distance; T : Time)\n         return Velocity;\n       pragma Import (Intrinsic, \"/\");\n-      \n+\n     This common idiom is often programmed with a generic definition and an\n     explicit body. The pragma makes it simpler to introduce such declarations.\n     It incurs no overhead in compilation time or code size, because it is\n@@ -3691,7 +3692,7 @@ Convention identifiers are recognized by GNAT:\n \n          function builtin_sqrt (F : Float) return Float;\n          pragma Import (Intrinsic, builtin_sqrt, \"__builtin_sqrtf\");\n-      \n+\n     Most of the GCC builtins are accessible this way, and as for other\n     import conventions (e.g. C), it is the user's responsibility to ensure\n     that the Ada subprogram profile matches the underlying builtin\n@@ -3738,7 +3739,7 @@ pragma:\n .. code-block:: ada\n \n      pragma Convention_Identifier (Fortran77, Fortran);\n-  \n+\n And from now on the identifier Fortran77 may be used as a convention\n identifier (for example in an `Import` pragma) with the same\n meaning as Fortran.\n@@ -3805,7 +3806,7 @@ considered:\n     $ g++ -c -fkeep-inline-functions file1.C\n     $ g++ -c -fkeep-inline-functions file2.C\n     $ gnatmake ada_unit -largs file1.o file2.o --LINK=g++\n-    \n+\n \n * Using GNAT and G++ from two different GCC installations: If both\n   compilers are on the :envvar`PATH`, the previous method may be used. It is\n@@ -3825,7 +3826,7 @@ considered:\n \n     $ gnatbind ada_unit\n     $ gnatlink -v -v ada_unit file1.o file2.o --LINK=c++\n-    \n+\n   If there is a problem due to interfering environment variables, it can\n   be worked around by using an intermediate script. The following example\n   shows the proper script to use when GNAT has not been installed at its\n@@ -3839,7 +3840,7 @@ considered:\n     unset GCC_ROOT\n     c++ $*\n     $ gnatlink -v -v ada_unit file1.o file2.o --LINK=./my_script\n-    \n+\n \n * Using a non-GNU C++ compiler: The commands previously described can be\n   used to insure that the C++ linker is used. Nonetheless, you need to add\n@@ -3855,7 +3856,7 @@ considered:\n     #!/bin/sh\n     CC $* `gcc -print-file-name=libgcc.a` `gcc -print-file-name=libgcc_eh.a`\n     $ gnatlink ada_unit file1.o file2.o --LINK=./my_script\n-    \n+\n \n   where CC is the name of the non-GNU C++ compiler.\n \n@@ -3871,7 +3872,7 @@ considered:\n     `gcc -print-file-name=libgcc.a` `gcc -print-file-name=libgcc_eh.a` \\\\\n     `gcc -print-file-name=crtend.o`\n     $ gnatlink ada_unit file1.o file2.o --LINK=./my_script\n-    \n+\n \n   If the \"zero cost exception\" mechanism is used, and the platform\n   doesn't support automatic registration of exception tables (e.g., HP-UX\n@@ -3907,7 +3908,7 @@ Here are the compilation commands:\n      $ g++ -c ex7.C\n      $ gnatbind -n simple_cpp_interface\n      $ gnatlink simple_cpp_interface -o cpp_main --LINK=g++ -lstdc++ ex7.o cpp_main.o\n-  \n+\n Here are the corresponding sources:\n \n .. code-block:: cpp\n@@ -3977,7 +3978,7 @@ Here are the corresponding sources:\n         a_value = 1010;\n        printf (\"in A::A, a_value = %d \\\\n\",a_value);\n      }\n-  \n+\n .. code-block:: ada\n \n      -- simple_cpp_interface.ads\n@@ -3998,7 +3999,7 @@ Here are the corresponding sources:\n         pragma Export (C, Ada_Method2);\n \n      end Simple_Cpp_Interface;\n-  \n+\n .. code-block:: ada\n \n      -- simple_cpp_interface.adb\n@@ -4038,7 +4039,7 @@ C++ class:\n        Root(int v);         // 1st non-default constructor\n        Root(int v, int w);  // 2nd non-default constructor\n      };\n-  \n+\n For this purpose we can write the following package spec (further\n information on how to build this spec is available in\n :ref:`Interfacing_with_C++_at_the_Class_Level` and\n@@ -4059,14 +4060,14 @@ information on how to build this spec is available in\n \n        function Constructor return Root;\n        pragma Cpp_Constructor (Constructor, \"_ZN4RootC1Ev\");\n- \n+\n        function Constructor (v : Integer) return Root;\n        pragma Cpp_Constructor (Constructor, \"_ZN4RootC1Ei\");\n \n        function Constructor (v, w : Integer) return Root;\n        pragma Cpp_Constructor (Constructor, \"_ZN4RootC1Eii\");\n      end Pkg_Root;\n-  \n+\n On the Ada side the constructor is represented by a function (whose\n name is arbitrary) that returns the classwide type corresponding to\n the imported C++ class. Although the constructor is described as a\n@@ -4095,7 +4096,7 @@ expression that initializes the object. For example:\n      Obj2 : Root := Constructor;\n      Obj3 : Root := Constructor (v => 10);\n      Obj4 : Root := Constructor (30, 40);\n-  \n+\n The first two declarations are equivalent: in both cases the default C++\n constructor is invoked (in the former case the call to the constructor is\n implicit, and in the latter case the call is explicit in the object\n@@ -4242,7 +4243,7 @@ and `Domestic` animals:\n      public:\n         virtual void Set_Owner (char* Name) = 0;\n      };\n-  \n+\n Using these declarations, we can now say that a `Dog` is an animal that is\n both Carnivore and Domestic, that is:\n \n@@ -4309,7 +4310,7 @@ how to import these C++ declarations from the Ada side:\n        pragma CPP_Constructor (New_Dog);\n        pragma Import (CPP, New_Dog, \"_ZN3DogC2Ev\");\n      end Animals;\n-  \n+\n Thanks to the compatibility between GNAT run-time structures and the C++ ABI,\n interfacing with these C++ classes is easy. The only requirement is that all\n the primitives and components must be declared exactly in the same order in\n@@ -4398,7 +4399,7 @@ them to C++, using the same hierarchy of our previous example:\n        function New_Dog return Dog'Class;\n        pragma Export (C_Plus_Plus, New_Dog);\n      end Animals;\n-  \n+\n Compared with our previous example the only differences are the use of\n `pragma Convention` (instead of `pragma Import`), and the use of\n `pragma Export` to indicate to the GNAT compiler that the primitives will\n@@ -4442,7 +4443,7 @@ finalizing the Ada run-time system along the way:\n        adainit ();  test();  adafinal ();\n        return 0;\n      }\n-  \n+\n .. _Generating_Ada_Bindings_for_C_and_C++_headers:\n \n Generating Ada Bindings for C and C++ headers\n@@ -4487,7 +4488,7 @@ header files needed by these files transitively. For example:\n \n       $ g++ -c -fdump-ada-spec -C /usr/include/time.h\n       $ gcc -c -gnat05 *.ads\n-  \n+\n will generate, under GNU/Linux, the following files: :file:`time_h.ads`,\n :file:`bits_time_h.ads`, :file:`stddef_h.ads`, :file:`bits_types_h.ads` which\n correspond to the files :file:`/usr/include/time.h`,\n@@ -4530,7 +4531,7 @@ generating a generic:\n .. code-block:: ada\n \n      procedure foo (param1 : int);\n-  \n+\n with the C++ front-end, the name is available, and we generate:\n \n .. code-block:: ada\n@@ -4615,7 +4616,7 @@ For example, given the following C++ header file:\n \n          Dog();\n        };\n-  \n+\n The corresponding Ada code is generated:\n \n .. code-block:: ada\n@@ -4668,7 +4669,7 @@ The corresponding Ada code is generated:\n            pragma Import (CPP, New_Dog, \"_ZN3DogC1Ev\");\n          end;\n          use Class_Dog;\n-  \n+\n \n .. _Switches_for_Ada_Binding_Generation:\n \n@@ -4928,7 +4929,7 @@ we have the following package spec:\n      package QRS is\n         MN : Integer;\n      end QRS;\n-  \n+\n .. index:: pragma Export\n \n The variable `MN` has a full expanded Ada name of `QRS.MN`, so\n@@ -4943,7 +4944,7 @@ Of course if a `pragma Export` is used this may be overridden:\n         Var2 : Integer;\n         pragma Export (Var2, C, Link_Name => \"var2_link_name\");\n      end Exports;\n-  \n+\n In this case, the link name for `Var1` is whatever link name the\n C compiler would assign for the C function `var1_name`. This typically\n would be either `var1_name` or `_var1_name`, depending on operating\n@@ -4964,4 +4965,3 @@ names. So if we have a library level procedure such as:\n      procedure Hello (S : String);\n \n the external name of this procedure will be `_ada_hello`.\n-"}, {"sha": "c51ff384c91e1be6d7a5228f8f3f5fc4df9145ef", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 863, "deletions": 700, "changes": 1563, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=33c51287cd5939975d7f118455314a5d6458111b"}, {"sha": "421419f5bfa90eb3f92830c260ea21d5dbeee4f7", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 339, "deletions": 283, "changes": 622, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c51287cd5939975d7f118455314a5d6458111b/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=33c51287cd5939975d7f118455314a5d6458111b"}]}