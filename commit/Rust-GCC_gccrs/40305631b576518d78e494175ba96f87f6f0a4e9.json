{"sha": "40305631b576518d78e494175ba96f87f6f0a4e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAzMDU2MzFiNTc2NTE4ZDc4ZTQ5NDE3NWJhOTZmODdmNmYwYTRlOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-05-09T07:58:29Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-05-09T07:58:29Z"}, "message": "re PR rtl-optimization/85638 (build failure for Ada runtime with SJLJ exceptions on x86)\n\n\tPR rtl-optimization/85638\n\t* bb-reorder.c: Include common/common-target.h.\n\t(create_forwarder_block): New function extracted from...\n\t(fix_up_crossing_landing_pad): ...here.  Rename into...\n\t(dw2_fix_up_crossing_landing_pad): ...this.\n\t(sjlj_fix_up_crossing_landing_pad): New function.\n\t(find_rarely_executed_basic_blocks_and_crossing_edges): In SJLJ mode,\n\tcall sjlj_fix_up_crossing_landing_pad if there are incoming EH edges\n\tfrom both partitions and exit the loop after one iteration.\n\nFrom-SVN: r260070", "tree": {"sha": "0a26d79e9a2f6e7bd6947b459f97d550ea94d526", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a26d79e9a2f6e7bd6947b459f97d550ea94d526"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40305631b576518d78e494175ba96f87f6f0a4e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40305631b576518d78e494175ba96f87f6f0a4e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40305631b576518d78e494175ba96f87f6f0a4e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40305631b576518d78e494175ba96f87f6f0a4e9/comments", "author": null, "committer": null, "parents": [{"sha": "655b16da125b1210096b2f394ba0f222631fb44b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/655b16da125b1210096b2f394ba0f222631fb44b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/655b16da125b1210096b2f394ba0f222631fb44b"}], "stats": {"total": 138, "additions": 108, "deletions": 30}, "files": [{"sha": "7a36aeb65a441c8eaeb37e4ed4c08c4cbb1fd32b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40305631b576518d78e494175ba96f87f6f0a4e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40305631b576518d78e494175ba96f87f6f0a4e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40305631b576518d78e494175ba96f87f6f0a4e9", "patch": "@@ -1,3 +1,15 @@\n+2018-05-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR rtl-optimization/85638\n+\t* bb-reorder.c: Include common/common-target.h.\n+\t(create_forwarder_block): New function extracted from...\n+\t(fix_up_crossing_landing_pad): ...here.  Rename into...\n+\t(dw2_fix_up_crossing_landing_pad): ...this.\n+\t(sjlj_fix_up_crossing_landing_pad): New function.\n+\t(find_rarely_executed_basic_blocks_and_crossing_edges): In SJLJ mode,\n+\tcall sjlj_fix_up_crossing_landing_pad if there are incoming EH edges\n+\tfrom both partitions and exit the loop after one iteration.\n+\n 2018-05-08  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n \n \tRevert:"}, {"sha": "6f2ad5a522058333015ee24aa96d50d86856d70b", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 96, "deletions": 30, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40305631b576518d78e494175ba96f87f6f0a4e9/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40305631b576518d78e494175ba96f87f6f0a4e9/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=40305631b576518d78e494175ba96f87f6f0a4e9", "patch": "@@ -117,6 +117,7 @@\n #include \"fibonacci_heap.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include \"common/common-target.h\"\n \n /* The number of rounds.  In most cases there will only be 4 rounds, but\n    when partitioning hot and cold basic blocks into separate sections of\n@@ -1408,17 +1409,95 @@ get_uncond_jump_length (void)\n   return length;\n }\n \n+/* Create a forwarder block to OLD_BB starting with NEW_LABEL and in the\n+   other partition wrt OLD_BB.  */\n+\n+static basic_block\n+create_forwarder_block (rtx_code_label *new_label, basic_block old_bb)\n+{\n+  /* Put the new label and a jump in the new basic block.  */\n+  rtx_insn *label = emit_label (new_label);\n+  rtx_code_label *old_label = block_label (old_bb);\n+  rtx_insn *jump = emit_jump_insn (targetm.gen_jump (old_label));\n+  JUMP_LABEL (jump) = old_label;\n+\n+  /* Create the new basic block and put it in last position.  */\n+  basic_block last_bb = EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb;\n+  basic_block new_bb = create_basic_block (label, jump, last_bb);\n+  new_bb->aux = last_bb->aux;\n+  new_bb->count = old_bb->count;\n+  last_bb->aux = new_bb;\n+\n+  emit_barrier_after_bb (new_bb);\n+\n+  make_single_succ_edge (new_bb, old_bb, 0);\n+\n+  /* Make sure the new basic block is in the other partition.  */\n+  unsigned new_partition = BB_PARTITION (old_bb);\n+  new_partition ^= BB_HOT_PARTITION | BB_COLD_PARTITION;\n+  BB_SET_PARTITION (new_bb, new_partition);\n+\n+  return new_bb;\n+}\n+\n+/* The common landing pad in block OLD_BB has edges from both partitions.\n+   Add a new landing pad that will just jump to the old one and split the\n+   edges so that no EH edge crosses partitions.  */\n+\n+static void\n+sjlj_fix_up_crossing_landing_pad (basic_block old_bb)\n+{\n+  const unsigned lp_len = cfun->eh->lp_array->length ();\n+  edge_iterator ei;\n+  edge e;\n+\n+  /* Generate the new common landing-pad label.  */\n+  rtx_code_label *new_label = gen_label_rtx ();\n+  LABEL_PRESERVE_P (new_label) = 1;\n+\n+  /* Create the forwarder block.  */\n+  basic_block new_bb = create_forwarder_block (new_label, old_bb);\n+\n+  /* Create the map from old to new lp index and initialize it.  */\n+  unsigned *index_map = (unsigned *) alloca (lp_len * sizeof (unsigned));\n+  memset (index_map, 0, lp_len * sizeof (unsigned));\n+\n+  /* Fix up the edges.  */\n+  for (ei = ei_start (old_bb->preds); (e = ei_safe_edge (ei)) != NULL; )\n+    if (e->src != new_bb && BB_PARTITION (e->src) == BB_PARTITION (new_bb))\n+      {\n+\trtx_insn *insn = BB_END (e->src);\n+\trtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n+\n+\tgcc_assert (note != NULL);\n+\tconst unsigned old_index = INTVAL (XEXP (note, 0));\n+\n+\t/* Generate the new landing-pad structure.  */\n+\tif (index_map[old_index] == 0)\n+\t  {\n+\t    eh_landing_pad old_lp = (*cfun->eh->lp_array)[old_index];\n+\t    eh_landing_pad new_lp = gen_eh_landing_pad (old_lp->region);\n+\t    new_lp->post_landing_pad = old_lp->post_landing_pad;\n+\t    new_lp->landing_pad = new_label;\n+\t    index_map[old_index] = new_lp->index;\n+\t  }\n+\tXEXP (note, 0) = GEN_INT (index_map[old_index]);\n+\n+\t/* Adjust the edge to the new destination.  */\n+\tredirect_edge_succ (e, new_bb);\n+      }\n+    else\n+      ei_next (&ei);\n+}\n+\n /* The landing pad OLD_LP, in block OLD_BB, has edges from both partitions.\n    Add a new landing pad that will just jump to the old one and split the\n    edges so that no EH edge crosses partitions.  */\n \n static void\n-fix_up_crossing_landing_pad (eh_landing_pad old_lp, basic_block old_bb)\n+dw2_fix_up_crossing_landing_pad (eh_landing_pad old_lp, basic_block old_bb)\n {\n   eh_landing_pad new_lp;\n-  basic_block new_bb, last_bb;\n-  rtx_insn *jump;\n-  unsigned new_partition;\n   edge_iterator ei;\n   edge e;\n \n@@ -1428,32 +1507,12 @@ fix_up_crossing_landing_pad (eh_landing_pad old_lp, basic_block old_bb)\n   new_lp->landing_pad = gen_label_rtx ();\n   LABEL_PRESERVE_P (new_lp->landing_pad) = 1;\n \n-  /* Put appropriate instructions in new bb.  */\n-  rtx_code_label *new_label = emit_label (new_lp->landing_pad);\n-\n-  rtx_code_label *old_label = block_label (old_bb);\n-  jump = emit_jump_insn (targetm.gen_jump (old_label));\n-  JUMP_LABEL (jump) = old_label;\n-\n-  /* Create new basic block to be dest for lp.  */\n-  last_bb = EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb;\n-  new_bb = create_basic_block (new_label, jump, last_bb);\n-  new_bb->aux = last_bb->aux;\n-  new_bb->count = old_bb->count;\n-  last_bb->aux = new_bb;\n-\n-  emit_barrier_after_bb (new_bb);\n-\n-  make_single_succ_edge (new_bb, old_bb, 0);\n-\n-  /* Make sure new bb is in the other partition.  */\n-  new_partition = BB_PARTITION (old_bb);\n-  new_partition ^= BB_HOT_PARTITION | BB_COLD_PARTITION;\n-  BB_SET_PARTITION (new_bb, new_partition);\n+  /* Create the forwarder block.  */\n+  basic_block new_bb = create_forwarder_block (new_lp->landing_pad, old_bb);\n \n   /* Fix up the edges.  */\n   for (ei = ei_start (old_bb->preds); (e = ei_safe_edge (ei)) != NULL; )\n-    if (e->src != new_bb && BB_PARTITION (e->src) == new_partition)\n+    if (e->src != new_bb && BB_PARTITION (e->src) == BB_PARTITION (new_bb))\n       {\n \trtx_insn *insn = BB_END (e->src);\n \trtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n@@ -1652,9 +1711,11 @@ find_rarely_executed_basic_blocks_and_crossing_edges (void)\n \n   /* The format of .gcc_except_table does not allow landing pads to\n      be in a different partition as the throw.  Fix this by either\n-     moving or duplicating the landing pads.  */\n+     moving the landing pads or inserting forwarder landing pads.  */\n   if (cfun->eh->lp_array)\n     {\n+      const bool sjlj\n+\t= (targetm_common.except_unwind_info (&global_options) == UI_SJLJ);\n       unsigned i;\n       eh_landing_pad lp;\n \n@@ -1686,13 +1747,18 @@ find_rarely_executed_basic_blocks_and_crossing_edges (void)\n \t      which ^= BB_HOT_PARTITION | BB_COLD_PARTITION;\n \t      BB_SET_PARTITION (bb, which);\n \t    }\n+\t  else if (sjlj)\n+\t    sjlj_fix_up_crossing_landing_pad (bb);\n \t  else\n-\t    fix_up_crossing_landing_pad (lp, bb);\n+\t    dw2_fix_up_crossing_landing_pad (lp, bb);\n+\n+\t  /* There is a single, common landing pad in SJLJ mode.  */\n+\t  if (sjlj)\n+\t    break;\n \t}\n     }\n \n   /* Mark every edge that crosses between sections.  */\n-\n   FOR_EACH_BB_FN (bb, cfun)\n     FOR_EACH_EDGE (e, ei, bb->succs)\n       {"}]}