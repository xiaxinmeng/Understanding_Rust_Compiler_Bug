{"sha": "6dff0d21e56d15dafc683dd69c6a9fbf3f1e7dfc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRmZjBkMjFlNTZkMTVkYWZjNjgzZGQ2OWM2YTlmYmYzZjFlN2RmYw==", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2021-05-07T18:49:57Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-07-06T14:46:56Z"}, "message": "[Ada] Return_when_statement not working for non identifier return values\n\ngcc/ada/\n\n\t* par-ch6.adb (Get_Return_Kind): Removed.\n\t(Is_Extended): Created to identify simple and \"when\" return\n\tstatements from extended return statements.\n\t(P_Return_Statement): Merged simple and \"when\" return statement\n\tprocessing.", "tree": {"sha": "ccaef8ea28f85081b7dfbddd33800b3ad61d29de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccaef8ea28f85081b7dfbddd33800b3ad61d29de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dff0d21e56d15dafc683dd69c6a9fbf3f1e7dfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dff0d21e56d15dafc683dd69c6a9fbf3f1e7dfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dff0d21e56d15dafc683dd69c6a9fbf3f1e7dfc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dff0d21e56d15dafc683dd69c6a9fbf3f1e7dfc/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e11a24513632e2b2a3842bfd3ef226565f523778", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e11a24513632e2b2a3842bfd3ef226565f523778", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e11a24513632e2b2a3842bfd3ef226565f523778"}], "stats": {"total": 134, "additions": 61, "deletions": 73}, "files": [{"sha": "e3b315564d2cfd6c819174ea87aa01079f2b9a64", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 61, "deletions": 73, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dff0d21e56d15dafc683dd69c6a9fbf3f1e7dfc/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dff0d21e56d15dafc683dd69c6a9fbf3f1e7dfc/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=6dff0d21e56d15dafc683dd69c6a9fbf3f1e7dfc", "patch": "@@ -1874,48 +1874,38 @@ package body Ch6 is\n    function P_Return_Statement return Node_Id is\n       --  The caller has checked that the initial token is RETURN\n \n-      type Return_Kind is (Simple_Return, Extended_Return, Return_When);\n-\n-      function Get_Return_Kind return Return_Kind;\n+      function Is_Extended return Boolean;\n       --  Scan state is just after RETURN (and is left that way). Determine\n       --  whether this is a simple or extended return statement by looking\n       --  ahead for \"identifier :\", which implies extended.\n \n-      ---------------------\n-      -- Get_Return_Kind --\n-      ---------------------\n+      -----------------\n+      -- Is_Extended --\n+      -----------------\n \n-      function Get_Return_Kind return Return_Kind is\n-         Scan_State : Saved_Scan_State;\n-         Result     : Return_Kind := Simple_Return;\n+      function Is_Extended return Boolean is\n+         Scan_State  : Saved_Scan_State;\n+         Is_Extended : Boolean := False;\n \n       begin\n+\n          if Token = Tok_Identifier then\n             Save_Scan_State (Scan_State); -- at identifier\n             Scan; -- past identifier\n \n             if Token = Tok_Colon then\n-               Result := Extended_Return; -- It's an extended_return_statement\n-            elsif Token = Tok_When then\n-               Error_Msg_GNAT_Extension (\"return when statement\");\n-\n-               Result := Return_When;\n+               Is_Extended := True;\n             end if;\n \n             Restore_Scan_State (Scan_State); -- to identifier\n-\n-         elsif Token = Tok_When then\n-            Error_Msg_GNAT_Extension (\"return when statement\");\n-\n-            Result := Return_When;\n          end if;\n \n-         return Result;\n-      end Get_Return_Kind;\n+         return Is_Extended;\n+      end Is_Extended;\n \n       Ret_Sloc : constant Source_Ptr := Token_Ptr;\n       Ret_Strt : constant Column_Number := Start_Column;\n-      Ret_Node : Node_Id := New_Node (N_Simple_Return_Statement, Ret_Sloc);\n+      Ret_Node : Node_Id;\n       Decl     : Node_Id;\n \n    --  Start of processing for P_Return_Statement\n@@ -1928,75 +1918,73 @@ package body Ch6 is\n \n       if Token = Tok_Semicolon then\n          Scan; -- past ;\n+         Ret_Node := New_Node (N_Simple_Return_Statement, Ret_Sloc);\n \n       --  Nontrivial case\n \n       else\n-         --  Simple_return_statement with expression\n+         --  Extended_return_statement (Ada 2005 only -- AI-318):\n \n-         --  We avoid trying to scan an expression if we are at an\n-         --  expression terminator since in that case the best error\n-         --  message is probably that we have a missing semicolon.\n+         if Is_Extended then\n+            Error_Msg_Ada_2005_Extension (\"extended return statement\");\n \n-         case Get_Return_Kind is\n-            --  Return_when_statement (Experimental only)\n+            Ret_Node := New_Node (N_Extended_Return_Statement, Ret_Sloc);\n+            Decl := P_Return_Object_Declaration;\n+            Set_Return_Object_Declarations (Ret_Node, New_List (Decl));\n \n-            when Return_When =>\n-               Ret_Node := New_Node (N_Return_When_Statement, Ret_Sloc);\n-\n-               if Token not in Token_Class_Eterm then\n-                  Set_Expression (Ret_Node, P_Expression_No_Right_Paren);\n-               end if;\n-\n-               if Token = Tok_When and then not Missing_Semicolon_On_When then\n-                  Scan; -- past WHEN\n-                  Set_Condition (Ret_Node, P_Condition);\n-\n-               --  Allow IF instead of WHEN, giving error message\n+            if Token = Tok_With then\n+               P_Aspect_Specifications (Decl, False);\n+            end if;\n \n-               elsif Token = Tok_If then\n-                  T_When;\n-                  Scan; -- past IF used in place of WHEN\n-                  Set_Condition (Ret_Node, P_Expression_No_Right_Paren);\n-               end if;\n+            if Token = Tok_Do then\n+               Push_Scope_Stack;\n+               Scopes (Scope.Last).Ecol := Ret_Strt;\n+               Scopes (Scope.Last).Etyp := E_Return;\n+               Scopes (Scope.Last).Labl := Error;\n+               Scopes (Scope.Last).Sloc := Ret_Sloc;\n+               Scan; -- past DO\n+               Set_Handled_Statement_Sequence\n+                 (Ret_Node, P_Handled_Sequence_Of_Statements);\n+               End_Statements;\n+\n+               --  Do we need to handle Error_Resync here???\n+            end if;\n \n-            --  Simple_return_statement\n+         --  Simple_return_statement or Return_when_Statement\n+         --  with expression.\n \n-            when Simple_Return =>\n-               Ret_Node := New_Node (N_Simple_Return_Statement, Ret_Sloc);\n+         --  We avoid trying to scan an expression if we are at an\n+         --  expression terminator since in that case the best error\n+         --  message is probably that we have a missing semicolon.\n \n-               if Token not in Token_Class_Eterm then\n-                  Set_Expression (Ret_Node, P_Expression_No_Right_Paren);\n-               end if;\n+         else\n+            Ret_Node := New_Node (N_Simple_Return_Statement, Ret_Sloc);\n \n-            --  Extended_return_statement (Ada 2005 only -- AI-318):\n+            if Token not in Token_Class_Eterm then\n+               Set_Expression (Ret_Node, P_Expression_No_Right_Paren);\n+            end if;\n \n-            when Extended_Return =>\n-               Error_Msg_Ada_2005_Extension (\"extended return statement\");\n+            --  When the next token is WHEN or IF we know that we are looking\n+            --  at a Return_when_statement\n \n-               Ret_Node := New_Node (N_Extended_Return_Statement, Ret_Sloc);\n-               Decl := P_Return_Object_Declaration;\n-               Set_Return_Object_Declarations (Ret_Node, New_List (Decl));\n+            if Token = Tok_When and then not Missing_Semicolon_On_When then\n+               Error_Msg_GNAT_Extension (\"return when statement\");\n+               Mutate_Nkind (Ret_Node, N_Return_When_Statement);\n \n-               if Token = Tok_With then\n-                  P_Aspect_Specifications (Decl, False);\n-               end if;\n+               Scan; -- past WHEN\n+               Set_Condition (Ret_Node, P_Condition);\n \n-               if Token = Tok_Do then\n-                  Push_Scope_Stack;\n-                  Scopes (Scope.Last).Ecol := Ret_Strt;\n-                  Scopes (Scope.Last).Etyp := E_Return;\n-                  Scopes (Scope.Last).Labl := Error;\n-                  Scopes (Scope.Last).Sloc := Ret_Sloc;\n+            --  Allow IF instead of WHEN, giving error message\n \n-                  Scan; -- past DO\n-                  Set_Handled_Statement_Sequence\n-                    (Ret_Node, P_Handled_Sequence_Of_Statements);\n-                  End_Statements;\n+            elsif Token = Tok_If then\n+               Error_Msg_GNAT_Extension (\"return when statement\");\n+               Mutate_Nkind (Ret_Node, N_Return_When_Statement);\n \n-                  --  Do we need to handle Error_Resync here???\n-               end if;\n-         end case;\n+               T_When;\n+               Scan; -- past IF used in place of WHEN\n+               Set_Condition (Ret_Node, P_Condition);\n+            end if;\n+         end if;\n \n          TF_Semicolon;\n       end if;"}]}