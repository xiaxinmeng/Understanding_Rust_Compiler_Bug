{"sha": "26e237fb5b83582b30ef7c5a388bc4e968a5a289", "node_id": "C_kwDOANBUbNoAKDI2ZTIzN2ZiNWI4MzU4MmIzMGVmN2M1YTM4OGJjNGU5NjhhNWEyODk", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2022-01-28T11:34:17Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2022-01-28T11:34:17Z"}, "message": "Prevent malicious descriptor stacking for scalar components [V2].\n\ngcc/fortran/ChangeLog:\n\n\tPR fortran/103790\n\t* trans-array.cc (structure_alloc_comps): Prevent descriptor\n\tstacking for non-array data; do not broadcast caf-tokens.\n\t* trans-intrinsic.cc (conv_co_collective): Prevent generation\n\tof unused descriptor.\n\ngcc/testsuite/ChangeLog:\n\n\tPR fortran/103790\n\t* gfortran.dg/coarray_collectives_18.f90: New test.", "tree": {"sha": "9d69c81efeda6ebc2b6398735acf18dea1a14f6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d69c81efeda6ebc2b6398735acf18dea1a14f6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26e237fb5b83582b30ef7c5a388bc4e968a5a289", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26e237fb5b83582b30ef7c5a388bc4e968a5a289", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26e237fb5b83582b30ef7c5a388bc4e968a5a289", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26e237fb5b83582b30ef7c5a388bc4e968a5a289/comments", "author": null, "committer": null, "parents": [{"sha": "430dca620fa3d03e53f6771a2b61d3f0ebb73756", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/430dca620fa3d03e53f6771a2b61d3f0ebb73756", "html_url": "https://github.com/Rust-GCC/gccrs/commit/430dca620fa3d03e53f6771a2b61d3f0ebb73756"}], "stats": {"total": 151, "additions": 108, "deletions": 43}, "files": [{"sha": "cfb6eac11c74c5bf075a646c6e42c47075541d7d", "filename": "gcc/fortran/trans-array.cc", "status": "modified", "additions": 49, "deletions": 25, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26e237fb5b83582b30ef7c5a388bc4e968a5a289/gcc%2Ffortran%2Ftrans-array.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26e237fb5b83582b30ef7c5a388bc4e968a5a289/gcc%2Ffortran%2Ftrans-array.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.cc?ref=26e237fb5b83582b30ef7c5a388bc4e968a5a289", "patch": "@@ -9102,6 +9102,10 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\tcontinue;\n \t    }\n \n+\t  /* Do not broadcast a caf_token.  These are local to the image.  */\n+\t  if (attr->caf_token)\n+\t    continue;\n+\n \t  add_when_allocated = NULL_TREE;\n \t  if (cmp_has_alloc_comps\n \t      && !c->attr.pointer && !c->attr.proc_pointer)\n@@ -9134,52 +9138,72 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t  if (attr->dimension)\n \t    {\n \t      tmp = gfc_get_element_type (TREE_TYPE (comp));\n-\t      ubound = gfc_full_array_size (&tmpblock, comp,\n-\t\t\t\t\t    c->ts.type == BT_CLASS\n-\t\t\t\t\t    ? CLASS_DATA (c)->as->rank\n-\t\t\t\t\t    : c->as->rank);\n+\t      if (!GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (comp)))\n+\t\tubound = GFC_TYPE_ARRAY_SIZE (TREE_TYPE (comp));\n+\t      else\n+\t\tubound = gfc_full_array_size (&tmpblock, comp,\n+\t\t\t\t\t      c->ts.type == BT_CLASS\n+\t\t\t\t\t      ? CLASS_DATA (c)->as->rank\n+\t\t\t\t\t      : c->as->rank);\n \t    }\n \t  else\n \t    {\n \t      tmp = TREE_TYPE (comp);\n \t      ubound = build_int_cst (gfc_array_index_type, 1);\n \t    }\n \n-\t  cdesc = gfc_get_array_type_bounds (tmp, 1, 0, &gfc_index_one_node,\n-\t\t\t\t\t     &ubound, 1,\n-\t\t\t\t\t     GFC_ARRAY_ALLOCATABLE, false);\n+\t  /* Treat strings like arrays.  Or the other way around, do not\n+\t   * generate an additional array layer for scalar components.  */\n+\t  if (attr->dimension || c->ts.type == BT_CHARACTER)\n+\t    {\n+\t      cdesc = gfc_get_array_type_bounds (tmp, 1, 0, &gfc_index_one_node,\n+\t\t\t\t\t\t &ubound, 1,\n+\t\t\t\t\t\t GFC_ARRAY_ALLOCATABLE, false);\n \n-\t  cdesc = gfc_create_var (cdesc, \"cdesc\");\n-\t  DECL_ARTIFICIAL (cdesc) = 1;\n+\t      cdesc = gfc_create_var (cdesc, \"cdesc\");\n+\t      DECL_ARTIFICIAL (cdesc) = 1;\n \n-\t  gfc_add_modify (&tmpblock, gfc_conv_descriptor_dtype (cdesc),\n-\t\t\t  gfc_get_dtype_rank_type (1, tmp));\n-\t  gfc_conv_descriptor_lbound_set (&tmpblock, cdesc,\n-\t\t\t\t\t  gfc_index_zero_node,\n-\t\t\t\t\t  gfc_index_one_node);\n-\t  gfc_conv_descriptor_stride_set (&tmpblock, cdesc,\n-\t\t\t\t\t  gfc_index_zero_node,\n-\t\t\t\t\t  gfc_index_one_node);\n-\t  gfc_conv_descriptor_ubound_set (&tmpblock, cdesc,\n-\t\t\t\t\t  gfc_index_zero_node, ubound);\n+\t      gfc_add_modify (&tmpblock, gfc_conv_descriptor_dtype (cdesc),\n+\t\t\t      gfc_get_dtype_rank_type (1, tmp));\n+\t      gfc_conv_descriptor_lbound_set (&tmpblock, cdesc,\n+\t\t\t\t\t      gfc_index_zero_node,\n+\t\t\t\t\t      gfc_index_one_node);\n+\t      gfc_conv_descriptor_stride_set (&tmpblock, cdesc,\n+\t\t\t\t\t      gfc_index_zero_node,\n+\t\t\t\t\t      gfc_index_one_node);\n+\t      gfc_conv_descriptor_ubound_set (&tmpblock, cdesc,\n+\t\t\t\t\t      gfc_index_zero_node, ubound);\n+\t    }\n+\t  else\n+\t    /* Prevent warning.  */\n+\t    cdesc = NULL_TREE;\n \n \t  if (attr->dimension)\n-\t    comp = gfc_conv_descriptor_data_get (comp);\n+\t    {\n+\t      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (comp)))\n+\t\tcomp = gfc_conv_descriptor_data_get (comp);\n+\t      else\n+\t\tcomp = gfc_build_addr_expr (NULL_TREE, comp);\n+\t    }\n \t  else\n \t    {\n \t      gfc_se se;\n \n \t      gfc_init_se (&se, NULL);\n \n \t      comp = gfc_conv_scalar_to_descriptor (&se, comp,\n-\t      \t\t\t\t\t    c->ts.type == BT_CLASS\n-\t      \t\t\t\t\t    ? CLASS_DATA (c)->attr\n-\t      \t\t\t\t\t    : c->attr);\n-\t      comp = gfc_build_addr_expr (NULL_TREE, comp);\n+\t\t\t\t\t\t     c->ts.type == BT_CLASS\n+\t\t\t\t\t\t     ? CLASS_DATA (c)->attr\n+\t\t\t\t\t\t     : c->attr);\n+\t      if (c->ts.type == BT_CHARACTER)\n+\t\tcomp = gfc_build_addr_expr (NULL_TREE, comp);\n \t      gfc_add_block_to_block (&tmpblock, &se.pre);\n \t    }\n \n-\t  gfc_conv_descriptor_data_set (&tmpblock, cdesc, comp);\n+\t  if (attr->dimension || c->ts.type == BT_CHARACTER)\n+\t    gfc_conv_descriptor_data_set (&tmpblock, cdesc, comp);\n+\t  else\n+\t    cdesc = comp;\n \n \t  tree fndecl;\n "}, {"sha": "e680de1dbd1d316c2ff9ddf263bf1b1f3c17f5b7", "filename": "gcc/fortran/trans-intrinsic.cc", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26e237fb5b83582b30ef7c5a388bc4e968a5a289/gcc%2Ffortran%2Ftrans-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26e237fb5b83582b30ef7c5a388bc4e968a5a289/gcc%2Ffortran%2Ftrans-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.cc?ref=26e237fb5b83582b30ef7c5a388bc4e968a5a289", "patch": "@@ -11212,24 +11212,31 @@ conv_co_collective (gfc_code *code)\n       return gfc_finish_block (&block);\n     }\n \n+  gfc_symbol *derived = code->ext.actual->expr->ts.type == BT_DERIVED\n+    ? code->ext.actual->expr->ts.u.derived : NULL;\n+\n   /* Handle the array.  */\n   gfc_init_se (&argse, NULL);\n-  if (code->ext.actual->expr->rank == 0)\n-    {\n-      symbol_attribute attr;\n-      gfc_clear_attr (&attr);\n-      gfc_init_se (&argse, NULL);\n-      gfc_conv_expr (&argse, code->ext.actual->expr);\n-      gfc_add_block_to_block (&block, &argse.pre);\n-      gfc_add_block_to_block (&post_block, &argse.post);\n-      array = gfc_conv_scalar_to_descriptor (&argse, argse.expr, attr);\n-      array = gfc_build_addr_expr (NULL_TREE, array);\n-    }\n-  else\n+  if (!derived || !derived->attr.alloc_comp\n+      || code->resolved_isym->id != GFC_ISYM_CO_BROADCAST)\n     {\n-      argse.want_pointer = 1;\n-      gfc_conv_expr_descriptor (&argse, code->ext.actual->expr);\n-      array = argse.expr;\n+      if (code->ext.actual->expr->rank == 0)\n+\t{\n+\t  symbol_attribute attr;\n+\t  gfc_clear_attr (&attr);\n+\t  gfc_init_se (&argse, NULL);\n+\t  gfc_conv_expr (&argse, code->ext.actual->expr);\n+\t  gfc_add_block_to_block (&block, &argse.pre);\n+\t  gfc_add_block_to_block (&post_block, &argse.post);\n+\t  array = gfc_conv_scalar_to_descriptor (&argse, argse.expr, attr);\n+\t  array = gfc_build_addr_expr (NULL_TREE, array);\n+\t}\n+      else\n+\t{\n+\t  argse.want_pointer = 1;\n+\t  gfc_conv_expr_descriptor (&argse, code->ext.actual->expr);\n+\t  array = argse.expr;\n+\t}\n     }\n \n   gfc_add_block_to_block (&block, &argse.pre);\n@@ -11290,9 +11297,6 @@ conv_co_collective (gfc_code *code)\n       gcc_unreachable ();\n     }\n \n-  gfc_symbol *derived = code->ext.actual->expr->ts.type == BT_DERIVED\n-    ? code->ext.actual->expr->ts.u.derived : NULL;\n-\n   if (derived && derived->attr.alloc_comp\n       && code->resolved_isym->id == GFC_ISYM_CO_BROADCAST)\n     /* The derived type has the attribute 'alloc_comp'.  */"}, {"sha": "c83899de0e5bf3dc7577032ebc64796f70e099a6", "filename": "gcc/testsuite/gfortran.dg/coarray_collectives_18.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26e237fb5b83582b30ef7c5a388bc4e968a5a289/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_collectives_18.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26e237fb5b83582b30ef7c5a388bc4e968a5a289/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_collectives_18.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_collectives_18.f90?ref=26e237fb5b83582b30ef7c5a388bc4e968a5a289", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-fdump-tree-original -fcoarray=lib\" }\n+!\n+! PR 103970\n+! Test case inspired by code submitted by Damian Rousson\n+\n+program main\n+\n+  implicit none\n+\n+  type foo_t\n+    integer i\n+    integer, allocatable :: j\n+  end type\n+\n+  type(foo_t) foo\n+  integer, parameter :: source_image = 1\n+\n+  if (this_image() == source_image)  then\n+    foo = foo_t(2,3)\n+  else\n+    allocate(foo%j)\n+  end if\n+  call co_broadcast(foo, source_image)\n+\n+  if ((foo%i /= 2) .or. (foo%j /= 3))  error stop 1\n+  sync all\n+\n+end program\n+\n+! Wrong code generation produced too many temp descriptors\n+! leading to stacked descriptors handed to the co_broadcast.\n+! This lead to access to non exsitant memory in opencoarrays.\n+! In single image mode just checking for reduced number of\n+! descriptors is possible, i.e., execute always works.\n+! { dg-final { scan-tree-dump-times \"desc\\\\.\\[0-9\\]+\" 12 \"original\" } }\n+"}]}