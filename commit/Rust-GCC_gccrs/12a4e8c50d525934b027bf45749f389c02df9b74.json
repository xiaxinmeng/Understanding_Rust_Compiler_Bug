{"sha": "12a4e8c50d525934b027bf45749f389c02df9b74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJhNGU4YzUwZDUyNTkzNGIwMjdiZjQ1NzQ5ZjM4OWMwMmRmOWI3NA==", "commit": {"author": {"name": "Geoff Keating", "email": "geoffk@cygnus.com", "date": "2000-05-04T22:15:23Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2000-05-04T22:15:23Z"}, "message": "rs6000-protos.h: Add output_cbranch.\n\n* config/rs6000/rs6000-protos.h: Add output_cbranch.\n* config/rs6000/rs6000.c (ccr_bit_negated_p): Delete.\n(print_operand): Delete %t and %T codes.\n(output_cbranch): New function.  Support branch prediction.\n* config/rs6000/rs6000.md: Use output_cbranch for\nconditional branches and returns.\n\nFrom-SVN: r33686", "tree": {"sha": "d493f07d81ae30e20225cca33c92741716320b92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d493f07d81ae30e20225cca33c92741716320b92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12a4e8c50d525934b027bf45749f389c02df9b74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12a4e8c50d525934b027bf45749f389c02df9b74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12a4e8c50d525934b027bf45749f389c02df9b74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12a4e8c50d525934b027bf45749f389c02df9b74/comments", "author": null, "committer": null, "parents": [{"sha": "233844c0ea61bc336cf7d7e0ca250427b8c5b419", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/233844c0ea61bc336cf7d7e0ca250427b8c5b419", "html_url": "https://github.com/Rust-GCC/gccrs/commit/233844c0ea61bc336cf7d7e0ca250427b8c5b419"}], "stats": {"total": 202, "additions": 144, "deletions": 58}, "files": [{"sha": "d2897d90213073fb401b1907a1b2a958b6664ac6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12a4e8c50d525934b027bf45749f389c02df9b74/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12a4e8c50d525934b027bf45749f389c02df9b74/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=12a4e8c50d525934b027bf45749f389c02df9b74", "patch": "@@ -1,3 +1,12 @@\n+2000-05-04  Geoff Keating  <geoffk@cygnus.com>\n+\n+\t* config/rs6000/rs6000-protos.h: Add output_cbranch.\n+\t* config/rs6000/rs6000.c (ccr_bit_negated_p): Delete.\n+\t(print_operand): Delete %t and %T codes.\n+\t(output_cbranch): New function.  Support branch prediction.\n+\t* config/rs6000/rs6000.md: Use output_cbranch for\n+\tconditional branches and returns.\n+\n 2000-05-04  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* simplify-rtx.c (simplify_ternary_operation): Cast to unsigned."}, {"sha": "05201afafca5481bb71767d49f5b5a36a647d44b", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12a4e8c50d525934b027bf45749f389c02df9b74/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12a4e8c50d525934b027bf45749f389c02df9b74/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=12a4e8c50d525934b027bf45749f389c02df9b74", "patch": "@@ -84,6 +84,7 @@ extern enum reg_class secondary_reload_class PARAMS ((enum reg_class,\n extern int ccr_bit PARAMS ((rtx, int));\n extern void print_operand PARAMS ((FILE *, rtx, int));\n extern void print_operand_address PARAMS ((FILE *, rtx));\n+extern char * output_cbranch PARAMS ((rtx, const char *, int, rtx));\n extern void output_toc PARAMS ((FILE *, rtx, int));\n extern int rs6000_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n extern int rs6000_adjust_priority PARAMS ((rtx, int));"}, {"sha": "36c50b429cc69321a2184e331e09afd07e518d10", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 124, "deletions": 47, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12a4e8c50d525934b027bf45749f389c02df9b74/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12a4e8c50d525934b027bf45749f389c02df9b74/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=12a4e8c50d525934b027bf45749f389c02df9b74", "patch": "@@ -119,7 +119,6 @@ static int rs6000_sr_alias_set;\n static void rs6000_add_gc_roots PARAMS ((void));\n static int num_insns_constant_wide PARAMS ((HOST_WIDE_INT));\n static rtx expand_block_move_mem PARAMS ((enum machine_mode, rtx, rtx));\n-static int ccr_bit_negated_p PARAMS((rtx));\n static void rs6000_emit_stack_tie PARAMS ((void));\n static void rs6000_frame_related PARAMS ((rtx, rtx, HOST_WIDE_INT, rtx, rtx));\n static void rs6000_emit_allocate_stack PARAMS ((HOST_WIDE_INT, int));\n@@ -3195,29 +3194,6 @@ ccr_bit (op, scc_p)\n       abort ();\n     }\n }\n-\n-/* Given a comparison operation, say whether the bit tested (as returned\n-   by ccr_bit) should be negated.  */\n-\n-static int\n-ccr_bit_negated_p (op)\n-     rtx op;\n-{\n-  enum rtx_code code = GET_CODE (op);\n-  enum machine_mode mode = GET_MODE (XEXP (op, 0));\n-  \n-  if (code == EQ\n-      || code == LT || code == GT\n-      || code == LTU || code == GTU)\n-    return 0;\n-  else if (mode != CCFPmode\n-      || code == NE\n-      || code == ORDERED\n-      || code == UNGE || code == UNLE)\n-    return 1;\n-  else\n-    return 0;\n-}\n \f\n /* Return the GOT register.  */\n \n@@ -3732,29 +3708,6 @@ print_operand (file, x, code)\n \t  return;\n \t}\n \n-    case 't':\n-      /* Write 12 if this jump operation will branch if true, 4 otherwise. */\n-      if (GET_RTX_CLASS (GET_CODE (x)) != '<')\n-\toutput_operand_lossage (\"invalid %%t value\");\n-\n-      else if (! ccr_bit_negated_p (x))\n-\tfputs (\"12\", file);\n-      else\n-\tputc ('4', file);\n-      return;\n-      \n-    case 'T':\n-      /* Opposite of 't': write 4 if this jump operation will branch if true,\n-\t 12 otherwise.   */\n-      if (GET_RTX_CLASS (GET_CODE (x)) != '<')\n-\toutput_operand_lossage (\"invalid %%T value\");\n-\n-      else if (! ccr_bit_negated_p (x))\n-\tputc ('4', file);\n-      else\n-\tfputs (\"12\", file);\n-      return;\n-      \n     case 'u':\n       /* High-order 16 bits of constant for use in unsigned operand.  */\n       if (! INT_P (x))\n@@ -4011,6 +3964,130 @@ print_operand_address (file, x)\n     abort ();\n }\n \f\n+/* Return the string to output a conditional branch to LABEL, which is\n+   the operand number of the label, or -1 if the branch is really a\n+   conditional return.  \n+\n+   OP is the conditional expression.  XEXP (OP, 0) is assumed to be a\n+   condition code register and its mode specifies what kind of\n+   comparison we made.\n+\n+   REVERSED is non-zero if we should reverse the sense of the comparison.\n+\n+   INSN is the insn.  */\n+\n+char *\n+output_cbranch (op, label, reversed, insn)\n+     rtx op;\n+     const char * label;\n+     int reversed;\n+     rtx insn;\n+{\n+  static char string[64];\n+  enum rtx_code code = GET_CODE (op);\n+  rtx cc_reg = XEXP (op, 0);\n+  enum machine_mode mode = GET_MODE (cc_reg);\n+  int cc_regno = REGNO (cc_reg) - CR0_REGNO;\n+  int need_longbranch = label != NULL && get_attr_length (insn) == 12;\n+  int really_reversed = reversed ^ need_longbranch;\n+  char *s = string;\n+  const char *ccode;\n+  const char *pred;\n+  rtx note;\n+\n+  /* Work out which way this really branches.  */\n+  if (really_reversed)\n+    {\n+      /* Reversal of FP compares takes care -- an ordered compare\n+\t becomes an unordered compare and vice versa.  */\n+      if (mode == CCFPmode)\n+\tcode = reverse_condition_maybe_unordered (code);\n+      else\n+\tcode = reverse_condition (code);\n+    }\n+\n+  /* If needed, print the CROR required for various floating-point\n+     comparisons; and decide on the condition code to test.  */\n+  if ((code == LE || code == GE\n+       || code == UNEQ || code == LTGT\n+       || code == UNGT || code == UNLT)\n+      && mode == CCFPmode)\n+    {\n+      int base_bit = 4 * cc_regno;\n+      int bit0, bit1;\n+      \n+      if (code == UNEQ)\n+\tbit0 = 2;\n+      else if (code == UNGT || code == GE)\n+\tbit0 = 1;\n+      else\n+\tbit0 = 0;\n+      if (code == LTGT)\n+\tbit1 = 1;\n+      else if (code == LE || code == GE)\n+\tbit1 = 2;\n+      else\n+\tbit1 = 3;\n+      \n+      s += sprintf (s, \"cror %d,%d,%d\\n\\t\", base_bit + 3,\n+\t\t    base_bit + bit1, base_bit + bit0);\n+      ccode = \"so\";\n+    }\n+  else switch (code)\n+    {\n+      /* Not all of these are actually distinct opcodes, but\n+\t we distinguish them for clarity of the resulting assembler.  */\n+    case NE: ccode = \"ne\"; break;\n+    case EQ: ccode = \"eq\"; break;\n+    case GE: case GEU: ccode = \"ge\"; break;\n+    case GT: case GTU: ccode = \"gt\"; break;\n+    case LE: case LEU: ccode = \"le\"; break;\n+    case LT: case LTU: ccode = \"lt\"; break;\n+    case UNORDERED: ccode = \"un\"; break;\n+    case ORDERED: ccode = \"nu\"; break;\n+    case UNGE: ccode = \"nl\"; break;\n+    case UNLE: ccode = \"ng\"; break;\n+    default:\n+      abort();\n+    }\n+  \n+  /* Maybe we have a guess as to how likely the branch is.  */\n+  note = find_reg_note (insn, REG_BR_PROB, NULL_RTX);\n+  if (note != NULL_RTX)\n+    {\n+      /* PROB is the difference from 50%.  */\n+      int prob = INTVAL (XEXP (note, 0)) - REG_BR_PROB_BASE / 2;\n+      \n+      /* For branches that are very close to 50%, assume not-taken.  */\n+      if (abs (prob) > REG_BR_PROB_BASE / 20\n+\t  && ((prob > 0) ^ need_longbranch))\n+\tpred = \"+\";\n+      else\n+\tpred = \"-\";\n+    }\n+  else\n+    pred = \"\";\n+\n+  if (label == NULL)\n+    s += sprintf (s, \"{b%sr|b%slr}%s \", ccode, ccode, pred);\n+  else\n+    s += sprintf (s, \"b%s%s \", ccode, pred);\n+\n+  s += sprintf (s, \"cr%d\", cc_regno);\n+\n+  if (label != NULL)\n+    {\n+      /* If the branch distance was too far, we may have to use an\n+\t unconditional branch to go the distance.  */\n+      if (need_longbranch)\n+\ts += sprintf (s, \",%c$+8 ; b %s\", '%', label);\n+      else\n+\ts += sprintf (s, \",%s\", label);\n+    }\n+\n+  return string;\n+}\n+\f\n /* This page contains routines that are used to determine what the function\n    prologue and epilogue code will do and write them out.  */\n "}, {"sha": "66a23508cf7294b60ac347caa5c7bcad61afca80", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12a4e8c50d525934b027bf45749f389c02df9b74/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12a4e8c50d525934b027bf45749f389c02df9b74/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=12a4e8c50d525934b027bf45749f389c02df9b74", "patch": "@@ -13992,11 +13992,7 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n   \"\"\n   \"*\n {\n-  if (get_attr_length (insn) == 8)\n-    return \\\"%C1bc %t1,%j1,%l0\\\";\n-  else\n-    return \\\"%C1bc %T1,%j1,%$+8\\;b %l0\\\";\n-\n+  return output_cbranch (operands[1], \\\"%l0\\\", 0, insn);\n }\"\n   [(set_attr \"type\" \"branch\")])\n \n@@ -14009,7 +14005,10 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n \t\t      (return)\n \t\t      (pc)))]\n   \"direct_return ()\"\n-  \"{%C0bcr|%C0bclr} %t0,%j0\"\n+  \"*\n+{\n+  return output_cbranch (operands[0], NULL, 0, insn);\n+}\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"8\")])\n \n@@ -14024,10 +14023,7 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n   \"\"\n   \"*\n {\n-  if (get_attr_length (insn) == 8)\n-    return \\\"%C1bc %T1,%j1,%l0\\\";\n-  else\n-    return \\\"%C1bc %t1,%j1,%$+8\\;b %l0\\\";\n+  return output_cbranch (operands[1], \\\"%l0\\\", 1, insn);\n }\"\n   [(set_attr \"type\" \"branch\")])\n \n@@ -14040,7 +14036,10 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n \t\t      (pc)\n \t\t      (return)))]\n   \"direct_return ()\"\n-  \"{%C0bcr|%C0bclr} %T0,%j0\"\n+  \"*\n+{\n+  return output_cbranch (operands[0], NULL, 1, insn);\n+}\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"8\")])\n "}]}