{"sha": "7b53649518674605dd757f4089c8a522e4272273", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I1MzY0OTUxODY3NDYwNWRkNzU3ZjQwODljOGE1MjJlNDI3MjI3Mw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-01T14:11:18Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-01T14:11:18Z"}, "message": "[multiple changes]\n\n2014-08-01  Thomas Quinot  <quinot@adacore.com>\n\n\t* freeze.adb: Minor reformatting.\n\n2014-08-01  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch3.adb (Default_Initialize_Object): Do not generate\n\tdefault initialization for an imported object.\n\n2014-08-01  Olivier Hainque  <hainque@adacore.com>\n\n\t* seh_init.c (__gnat_map_SEH): Cast argument of IsBadCodePtr\n\tto the expected FARPROC type instead of void *.\n\t* adaint.c (f2t): Expect __time64_t * as second argument, in line with\n\tother datastructures.\n\t(__gnat_file_time_name_attr): Adjust accordingly.\n\t(__gnat_check_OWNER_ACL): Declare pSD as PSECURITY_DESCRIPTOR,\n\tin line with uses.\n\t(__gnat_check_OWNER_ACL): Declare AccessMode\n\tparameter as ACCESS_MODE instead of DWORD, in line with callers\n\tand uses.\n\t(__gnat_set_executable): Add ATTRIBUTE_UNUSED on mode,\n\tunused on win32.  Correct cast of \"args\" on call to spawnvp.\n\t(add_handle): Cast realloc calls into their destination types.\n\t(win32_wait): Remove declaration and initialization of unused variable.\n\t(__gnat_locate_exec_on_path): Cast alloca calls\n\tinto their destination types.\n\t* initialize.c (append_arg, __gnat_initialize): Cast xmalloc calls into\n\ttheir destination types.\n\n2014-08-01  Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Type_Conversion): Expand\n\trange checks for conversions between floating-point subtypes\n\twhen the target and source types are the same.\n\n2014-08-01  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_aggr.adb: Minor reformatting.\n\n2014-08-01  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sem_ch13.adb (Check_Indexing_Functions): Initialize\n\tIndexing_Found.\n\n2014-08-01  Arnaud Charlet  <charlet@adacore.com>\n\n\t* gnat1drv.adb (Gnat1drv): In gnatprove mode, we now write the\n\tALI file before we call the backend (so that gnat2why can append\n\tto it).\n\n2014-08-01  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_pakd.adb (Expand_Bit_Packed_Element_Set,\n\tExpand_Packed_Element_Reference): Pass additional Rev_SSO\n\tparameter indicating whether the packed array type has reverse\n\tscalar storage order to the s-pack* Set/Get routines.\n\t* s-pack*.ad* (Get, Set, GetU, SetU): New formal Rev_SSO\n\tindicating reverse scalar storage order.\n\n2014-08-01  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch3.adb (Check_Initialization): Set Do_Range_Check\n\tfor initial component value in -gnatc or GNATprove mode.\n\t(Process_Discriminants): Same fix for default discriminant values.\n\t* sem_eval.adb (Test_In_Range): Improve accuracy of results by\n\tchecking subtypes.\n\n2014-08-01  Robert Dewar  <dewar@adacore.com>\n\n\t* sinfo.ads: Minor comment clarification.\n\nFrom-SVN: r213471", "tree": {"sha": "fdb5a56e6066a99a0a05b387130465d401aa5e1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdb5a56e6066a99a0a05b387130465d401aa5e1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b53649518674605dd757f4089c8a522e4272273", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b53649518674605dd757f4089c8a522e4272273", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b53649518674605dd757f4089c8a522e4272273", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b53649518674605dd757f4089c8a522e4272273/comments", "author": null, "committer": null, "parents": [{"sha": "41d8ee1d52ca454571226a1083fcd66b169c5cda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41d8ee1d52ca454571226a1083fcd66b169c5cda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41d8ee1d52ca454571226a1083fcd66b169c5cda"}], "stats": {"total": 9718, "additions": 7146, "deletions": 2572}, "files": [{"sha": "dba624f96bf5f3cf4ed7dc7f89fc29da6df0b244", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -1,3 +1,75 @@\n+2014-08-01  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* freeze.adb: Minor reformatting.\n+\n+2014-08-01  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch3.adb (Default_Initialize_Object): Do not generate\n+\tdefault initialization for an imported object.\n+\n+2014-08-01  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* seh_init.c (__gnat_map_SEH): Cast argument of IsBadCodePtr\n+\tto the expected FARPROC type instead of void *.\n+\t* adaint.c (f2t): Expect __time64_t * as second argument, in line with\n+\tother datastructures.\n+\t(__gnat_file_time_name_attr): Adjust accordingly.\n+\t(__gnat_check_OWNER_ACL): Declare pSD as PSECURITY_DESCRIPTOR,\n+\tin line with uses.\n+\t(__gnat_check_OWNER_ACL): Declare AccessMode\n+\tparameter as ACCESS_MODE instead of DWORD, in line with callers\n+\tand uses.\n+\t(__gnat_set_executable): Add ATTRIBUTE_UNUSED on mode,\n+\tunused on win32.  Correct cast of \"args\" on call to spawnvp.\n+\t(add_handle): Cast realloc calls into their destination types.\n+\t(win32_wait): Remove declaration and initialization of unused variable.\n+\t(__gnat_locate_exec_on_path): Cast alloca calls\n+\tinto their destination types.\n+\t* initialize.c (append_arg, __gnat_initialize): Cast xmalloc calls into\n+\ttheir destination types.\n+\n+2014-08-01  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Type_Conversion): Expand\n+\trange checks for conversions between floating-point subtypes\n+\twhen the target and source types are the same.\n+\n+2014-08-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_aggr.adb: Minor reformatting.\n+\n+2014-08-01  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_ch13.adb (Check_Indexing_Functions): Initialize\n+\tIndexing_Found.\n+\n+2014-08-01  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* gnat1drv.adb (Gnat1drv): In gnatprove mode, we now write the\n+\tALI file before we call the backend (so that gnat2why can append\n+\tto it).\n+\n+2014-08-01  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_pakd.adb (Expand_Bit_Packed_Element_Set,\n+\tExpand_Packed_Element_Reference): Pass additional Rev_SSO\n+\tparameter indicating whether the packed array type has reverse\n+\tscalar storage order to the s-pack* Set/Get routines.\n+\t* s-pack*.ad* (Get, Set, GetU, SetU): New formal Rev_SSO\n+\tindicating reverse scalar storage order.\n+\n+2014-08-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch3.adb (Check_Initialization): Set Do_Range_Check\n+\tfor initial component value in -gnatc or GNATprove mode.\n+\t(Process_Discriminants): Same fix for default discriminant values.\n+\t* sem_eval.adb (Test_In_Range): Improve accuracy of results by\n+\tchecking subtypes.\n+\n+2014-08-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sinfo.ads: Minor comment clarification.\n+\n 2014-08-01  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_ch13.adb (Analyze_Aspect_Specifications): Code"}, {"sha": "8a1841814b79563b5df1b77fb5b2d1f2bf909205", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -1310,7 +1310,7 @@ win32_filetime (HANDLE h)\n \n /* As above but starting from a FILETIME.  */\n static void\n-f2t (const FILETIME *ft, time_t *t)\n+f2t (const FILETIME *ft, __time64_t *t)\n {\n   union\n   {\n@@ -1319,7 +1319,7 @@ f2t (const FILETIME *ft, time_t *t)\n   } t_write;\n \n   t_write.ft_time = *ft;\n-  *t = (time_t) (t_write.ull_time / 10000000ULL - w32_epoch_offset);\n+  *t = (__time64_t) (t_write.ull_time / 10000000ULL - w32_epoch_offset);\n }\n #endif\n \n@@ -1332,7 +1332,7 @@ __gnat_file_time_name_attr (char* name, struct file_attributes* attr)\n #if defined (_WIN32) && !defined (RTX)\n       BOOL res;\n       WIN32_FILE_ATTRIBUTE_DATA fad;\n-      time_t ret = -1;\n+      __time64_t ret = -1;\n       TCHAR wname[GNAT_MAX_PATH_LEN];\n       S2WSC (wname, name, GNAT_MAX_PATH_LEN);\n \n@@ -1748,7 +1748,7 @@ __gnat_check_OWNER_ACL (TCHAR *wname,\n   BOOL fAccessGranted = FALSE;\n   HANDLE hToken = NULL;\n   DWORD nLength = 0;\n-  SECURITY_DESCRIPTOR* pSD = NULL;\n+  PSECURITY_DESCRIPTOR pSD = NULL;\n \n   GetFileSecurity\n     (wname, OWNER_SECURITY_INFORMATION |\n@@ -1808,7 +1808,7 @@ __gnat_check_OWNER_ACL (TCHAR *wname,\n \n static void\n __gnat_set_OWNER_ACL (TCHAR *wname,\n-\t\t      DWORD AccessMode,\n+\t\t      ACCESS_MODE AccessMode,\n \t\t      DWORD AccessPermissions)\n {\n   PACL pOldDACL = NULL;\n@@ -2022,7 +2022,7 @@ __gnat_set_writable (char *name)\n #define S_OTHERS 4\n \n void\n-__gnat_set_executable (char *name, int mode)\n+__gnat_set_executable (char *name, int mode ATTRIBUTE_UNUSED)\n {\n #if defined (_WIN32) && !defined (RTX)\n   TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n@@ -2177,7 +2177,7 @@ __gnat_portable_spawn (char *args[] ATTRIBUTE_UNUSED)\n   strcat (args[0], args_0);\n   strcat (args[0], \"\\\"\");\n \n-  status = spawnvp (P_WAIT, args_0, (char* const*)args);\n+  status = spawnvp (P_WAIT, args_0, (char ** const)args);\n \n   /* restore previous value */\n   free (args[0]);\n@@ -2325,7 +2325,7 @@ add_handle (HANDLE h, int pid)\n     {\n       plist_max_length += 1000;\n       HANDLES_LIST =\n-        (void **) xrealloc (HANDLES_LIST, sizeof (HANDLE) * plist_max_length);\n+        (HANDLE *) xrealloc (HANDLES_LIST, sizeof (HANDLE) * plist_max_length);\n       PID_LIST =\n         (int *) xrealloc (PID_LIST, sizeof (int) * plist_max_length);\n     }\n@@ -2445,7 +2445,6 @@ win32_wait (int *status)\n   HANDLE *hl;\n   HANDLE h;\n   DWORD res;\n-  int k;\n   int hl_len;\n \n   if (plist_length == 0)\n@@ -2454,8 +2453,6 @@ win32_wait (int *status)\n       return -1;\n     }\n \n-  k = 0;\n-\n   /* -------------------- critical section -------------------- */\n   (*Lock_Task) ();\n "}, {"sha": "0214a6b237878fd019828c3537feed7fd7ba1646", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -2114,17 +2114,18 @@ package body Exp_Aggr is\n          Discr_Val   : Elmt_Id;\n \n       begin\n-         Btype := Base_Type (Typ);\n-\n-         --  The constraints on the hidden discriminants, if present, are\n-         --  kep in the Stored_Constraint list of the type itself, or in\n-         --  that of the base type.\n+         --  The constraints on the hidden discriminants, if present, are kept\n+         --  in the Stored_Constraint list of the type itself, or in that of\n+         --  the base type.\n \n+         Btype := Base_Type (Typ);\n          while Is_Derived_Type (Btype)\n            and then (Present (Stored_Constraint (Btype))\n-             or else Present (Stored_Constraint (Typ)))\n+                       or else\n+                     Present (Stored_Constraint (Typ)))\n          loop\n             Parent_Type := Etype (Btype);\n+\n             if not Has_Discriminants (Parent_Type) then\n                return;\n             end if;"}, {"sha": "e21e9e416987a5bc3c0b38bab44d93e52b95d892", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -5068,6 +5068,16 @@ package body Exp_Ch3 is\n       --  Start of processing for Default_Initialize_Object\n \n       begin\n+         --  Default initialization is suppressed for objects that are already\n+         --  known to be imported (i.e. whose declaration specifies the Import\n+         --  aspect). Note that for objects with a pragma Import, we generate\n+         --  initialization here, and then remove it downstream when processing\n+         --  the pragma.\n+\n+         if Is_Imported (Def_Id) then\n+            return;\n+         end if;\n+\n          --  Step 1: Initialize the object\n \n          if Needs_Finalization (Typ) and then not No_Initialization (N) then"}, {"sha": "3f82220a2727f3c90535f784985e3f1b8de77f7b", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 60, "deletions": 42, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -10835,60 +10835,78 @@ package body Exp_Ch4 is\n \n       --  The only remaining step is to generate a range check if we still have\n       --  a type conversion at this stage and Do_Range_Check is set. For now we\n-      --  do this only for conversions of discrete types.\n+      --  do this only for conversions of discrete types and for floating-point\n+      --  conversions where the base types of source and target are the same.\n \n-      if Nkind (N) = N_Type_Conversion\n-        and then Is_Discrete_Type (Etype (N))\n-      then\n-         declare\n-            Expr : constant Node_Id := Expression (N);\n-            Ftyp : Entity_Id;\n-            Ityp : Entity_Id;\n+      if Nkind (N) = N_Type_Conversion then\n \n-         begin\n-            if Do_Range_Check (Expr)\n-              and then Is_Discrete_Type (Etype (Expr))\n-            then\n-               Set_Do_Range_Check (Expr, False);\n+         --  For now we only support floating-point cases where the base types\n+         --  of the target type and source expression are the same, so there's\n+         --  potentially only a range check. Conversions where the source and\n+         --  target have different base types are still TBD. ???\n \n-               --  Before we do a range check, we have to deal with treating a\n-               --  fixed-point operand as an integer. The way we do this is\n-               --  simply to do an unchecked conversion to an appropriate\n-               --  integer type large enough to hold the result.\n+         if Is_Floating_Point_Type (Etype (N))\n+           and then\n+             Base_Type (Etype (N)) = Base_Type (Etype (Expression (N)))\n+         then\n+            if Do_Range_Check (Expression (N))\n+              and then Is_Floating_Point_Type (Target_Type)\n+            then\n+               Generate_Range_Check\n+                 (Expression (N), Target_Type, CE_Range_Check_Failed);\n+            end if;\n \n-               --  This code is not active yet, because we are only dealing\n-               --  with discrete types so far ???\n+         elsif Is_Discrete_Type (Etype (N)) then\n+            declare\n+               Expr : constant Node_Id := Expression (N);\n+               Ftyp : Entity_Id;\n+               Ityp : Entity_Id;\n \n-               if Nkind (Expr) in N_Has_Treat_Fixed_As_Integer\n-                 and then Treat_Fixed_As_Integer (Expr)\n+            begin\n+               if Do_Range_Check (Expr)\n+                 and then Is_Discrete_Type (Etype (Expr))\n                then\n-                  Ftyp := Base_Type (Etype (Expr));\n+                  Set_Do_Range_Check (Expr, False);\n \n-                  if Esize (Ftyp) >= Esize (Standard_Integer) then\n-                     Ityp := Standard_Long_Long_Integer;\n-                  else\n-                     Ityp := Standard_Integer;\n-                  end if;\n+                  --  Before we do a range check, we have to deal with treating\n+                  --  a fixed-point operand as an integer. The way we do this\n+                  --  is simply to do an unchecked conversion to an appropriate\n+                  --  integer type large enough to hold the result.\n \n-                  Rewrite (Expr, Unchecked_Convert_To (Ityp, Expr));\n-               end if;\n+                  --  This code is not active yet, because we are only dealing\n+                  --  with discrete types so far ???\n \n-               --  Reset overflow flag, since the range check will include\n-               --  dealing with possible overflow, and generate the check. If\n-               --  Address is either a source type or target type, suppress\n-               --  range check to avoid typing anomalies when it is a visible\n-               --  integer type.\n+                  if Nkind (Expr) in N_Has_Treat_Fixed_As_Integer\n+                    and then Treat_Fixed_As_Integer (Expr)\n+                  then\n+                     Ftyp := Base_Type (Etype (Expr));\n \n-               Set_Do_Overflow_Check (N, False);\n+                     if Esize (Ftyp) >= Esize (Standard_Integer) then\n+                        Ityp := Standard_Long_Long_Integer;\n+                     else\n+                        Ityp := Standard_Integer;\n+                     end if;\n \n-               if not Is_Descendent_Of_Address (Etype (Expr))\n-                 and then not Is_Descendent_Of_Address (Target_Type)\n-               then\n-                  Generate_Range_Check\n-                    (Expr, Target_Type, CE_Range_Check_Failed);\n+                     Rewrite (Expr, Unchecked_Convert_To (Ityp, Expr));\n+                  end if;\n+\n+                  --  Reset overflow flag, since the range check will include\n+                  --  dealing with possible overflow, and generate the check.\n+                  --  If Address is either a source type or target type,\n+                  --  suppress range check to avoid typing anomalies when\n+                  --  it is a visible integer type.\n+\n+                  Set_Do_Overflow_Check (N, False);\n+\n+                  if not Is_Descendent_Of_Address (Etype (Expr))\n+                    and then not Is_Descendent_Of_Address (Target_Type)\n+                  then\n+                     Generate_Range_Check\n+                       (Expr, Target_Type, CE_Range_Check_Failed);\n+                  end if;\n                end if;\n-            end if;\n-         end;\n+            end;\n+         end if;\n       end if;\n \n       --  Here at end of processing"}, {"sha": "6ff75278d9705758f1169545d35d8f062f7cd569", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -1727,6 +1727,7 @@ package body Exp_Pakd is\n             Set_nn  : Entity_Id;\n             Subscr  : Node_Id;\n             Atyp    : Entity_Id;\n+            Rev_SSO : Node_Id;\n \n          begin\n             if No (Bits_nn) then\n@@ -1752,6 +1753,12 @@ package body Exp_Pakd is\n             Atyp := Etype (Obj);\n             Compute_Linear_Subscript (Atyp, Lhs, Subscr);\n \n+            --  Set indication of whether the packed array has reverse SSO\n+\n+            Rev_SSO :=\n+              New_Occurrence_Of\n+                (Boolean_Literals (Reverse_Storage_Order (Atyp)), Loc);\n+\n             --  Below we must make the assumption that Obj is\n             --  at least byte aligned, since otherwise its address\n             --  cannot be taken. The assumption holds since the\n@@ -1767,8 +1774,8 @@ package body Exp_Pakd is\n                       Prefix         => Obj,\n                       Attribute_Name => Name_Address),\n                     Subscr,\n-                    Unchecked_Convert_To (Bits_nn,\n-                      Convert_To (Ctyp, Rhs)))));\n+                    Unchecked_Convert_To (Bits_nn, Convert_To (Ctyp, Rhs)),\n+                    Rev_SSO)));\n \n          end;\n       end if;\n@@ -2127,8 +2134,11 @@ package body Exp_Pakd is\n          --  where Subscr is the computed linear subscript\n \n          declare\n-            Get_nn : Entity_Id;\n-            Subscr : Node_Id;\n+            Get_nn  : Entity_Id;\n+            Subscr  : Node_Id;\n+            Rev_SSO : constant Node_Id :=\n+              New_Occurrence_Of\n+                (Boolean_Literals (Reverse_Storage_Order (Atyp)), Loc);\n \n          begin\n             --  Acquire proper Get entity. We use the aligned or unaligned\n@@ -2158,12 +2168,12 @@ package body Exp_Pakd is\n                     Make_Attribute_Reference (Loc,\n                       Prefix         => Obj,\n                       Attribute_Name => Name_Address),\n-                    Subscr))));\n+                    Subscr,\n+                    Rev_SSO))));\n          end;\n       end if;\n \n       Analyze_And_Resolve (N, Ctyp, Suppress => All_Checks);\n-\n    end Expand_Packed_Element_Reference;\n \n    ----------------------"}, {"sha": "fb4241a40aa2a64dabc260a1409eadf7b100b5bf", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -3701,8 +3701,7 @@ package body Freeze is\n \n             --  Acquire copy of Inline pragma\n \n-            Iprag :=\n-              Copy_Separate_Tree (Import_Pragma (E));\n+            Iprag := Copy_Separate_Tree (Import_Pragma (E));\n \n             --  Fix up spec to be not imported any more\n "}, {"sha": "e074b08d41a706546bfe977a1210ccba59edc7c1", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -1243,6 +1243,19 @@ begin\n \n       Prepcomp.Add_Dependencies;\n \n+      --  In gnatprove mode we're writing the ALI much earlier than usual\n+      --  as flow analysis needs the file present in order to append its\n+      --  own globals to it.\n+\n+      if GNATprove_Mode then\n+\n+         --  Note: In GNATprove mode, an \"object\" file is always generated as\n+         --  the result of calling gnat1 or gnat2why, although this is not the\n+         --  same as the object file produced for compilation.\n+\n+         Write_ALI (Object => True);\n+      end if;\n+\n       --  Back end needs to explicitly unlock tables it needs to touch\n \n       Atree.Lock;\n@@ -1295,12 +1308,9 @@ begin\n          Exit_Program (E_Errors);\n       end if;\n \n-      --  In GNATprove mode, an \"object\" file is always generated as the\n-      --  result of calling gnat1 or gnat2why, although this is not the\n-      --  same as the object file produced for compilation.\n-\n-      Write_ALI (Object => (Back_End_Mode = Generate_Object\n-                             or else GNATprove_Mode));\n+      if not GNATprove_Mode then\n+         Write_ALI (Object => (Back_End_Mode = Generate_Object));\n+      end if;\n \n       if not Compilation_Errors then\n "}, {"sha": "b081dc27f8f7d5f1d82300620e7b94f2ed014995", "filename": "gcc/ada/s-pack03.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack03.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack03.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack03.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_03 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_03 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_03 --\n    ------------\n \n-   function Get_03 (Arr : System.Address; N : Natural) return Bits_03 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_03\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_03\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_03;\n \n    ------------\n    -- Set_03 --\n    ------------\n \n-   procedure Set_03 (Arr : System.Address; N : Natural; E : Bits_03) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_03\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_03;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_03;\n \n end System.Pack_03;"}, {"sha": "265246ce8a3c7bff4fb11f68dc610ffc565abc0f", "filename": "gcc/ada/s-pack03.ads", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack03.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack03.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack03.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -39,11 +39,21 @@ package System.Pack_03 is\n    type Bits_03 is mod 2 ** Bits;\n    for Bits_03'Size use Bits;\n \n-   function Get_03 (Arr : System.Address; N : Natural) return Bits_03;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_03\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_03 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_03 (Arr : System.Address; N : Natural; E : Bits_03);\n+   procedure Set_03\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_03;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "645c3a7df6eceae05938b1fdfcd5fbb3e803e7ae", "filename": "gcc/ada/s-pack05.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack05.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack05.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack05.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_05 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_05 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_05 --\n    ------------\n \n-   function Get_05 (Arr : System.Address; N : Natural) return Bits_05 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_05\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_05\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_05;\n \n    ------------\n    -- Set_05 --\n    ------------\n \n-   procedure Set_05 (Arr : System.Address; N : Natural; E : Bits_05) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_05\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_05;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_05;\n \n end System.Pack_05;"}, {"sha": "567bdc785515325ee6d90f59ce5b71363aa4249d", "filename": "gcc/ada/s-pack05.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack05.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack05.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack05.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_05 is\n    type Bits_05 is mod 2 ** Bits;\n    for Bits_05'Size use Bits;\n \n-   function Get_05 (Arr : System.Address; N : Natural) return Bits_05;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_05\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_05 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_05 (Arr : System.Address; N : Natural; E : Bits_05);\n+   procedure Set_05\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_05;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "e467af0631e02d8aa0fa4f05ca78a4a9d121d453", "filename": "gcc/ada/s-pack06.adb", "status": "modified", "additions": 140, "deletions": 53, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack06.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack06.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack06.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_06 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_06 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_06 or SetU_06 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_06 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_06 --\n    ------------\n \n-   function Get_06 (Arr : System.Address; N : Natural) return Bits_06 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_06\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_06\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_06;\n \n    -------------\n    -- GetU_06 --\n    -------------\n \n-   function GetU_06 (Arr : System.Address; N : Natural) return Bits_06 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_06\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_06\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_06;\n \n    ------------\n    -- Set_06 --\n    ------------\n \n-   procedure Set_06 (Arr : System.Address; N : Natural; E : Bits_06) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_06\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_06;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_06;\n \n    -------------\n    -- SetU_06 --\n    -------------\n \n-   procedure SetU_06 (Arr : System.Address; N : Natural; E : Bits_06) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_06\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_06;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_06;\n \n end System.Pack_06;"}, {"sha": "9db47345386c7746621b77ed7fed7fdbc714f9c3", "filename": "gcc/ada/s-pack06.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack06.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack06.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack06.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_06 is\n    type Bits_06 is mod 2 ** Bits;\n    for Bits_06'Size use Bits;\n \n-   function Get_06 (Arr : System.Address; N : Natural) return Bits_06;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_06\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_06 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_06 (Arr : System.Address; N : Natural; E : Bits_06);\n+   procedure Set_06\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_06;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_06 (Arr : System.Address; N : Natural) return Bits_06;\n+   function GetU_06\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_06 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_06 (Arr : System.Address; N : Natural; E : Bits_06);\n+   procedure SetU_06\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_06;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "45ba8bddd058b677fb5f85836c9c50370dfd405c", "filename": "gcc/ada/s-pack07.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack07.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack07.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack07.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_07 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_07 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_07 --\n    ------------\n \n-   function Get_07 (Arr : System.Address; N : Natural) return Bits_07 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_07\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_07\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_07;\n \n    ------------\n    -- Set_07 --\n    ------------\n \n-   procedure Set_07 (Arr : System.Address; N : Natural; E : Bits_07) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_07\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_07;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_07;\n \n end System.Pack_07;"}, {"sha": "a0fa35d298ba24ee150d53bf4f96043c220cdbce", "filename": "gcc/ada/s-pack07.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack07.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack07.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack07.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_07 is\n    type Bits_07 is mod 2 ** Bits;\n    for Bits_07'Size use Bits;\n \n-   function Get_07 (Arr : System.Address; N : Natural) return Bits_07;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_07\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_07 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_07 (Arr : System.Address; N : Natural; E : Bits_07);\n+   procedure Set_07\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_07;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "e0360bbba4f39bfafcc5adc7319592fbad177305", "filename": "gcc/ada/s-pack09.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack09.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack09.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack09.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_09 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_09 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_09 --\n    ------------\n \n-   function Get_09 (Arr : System.Address; N : Natural) return Bits_09 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_09\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_09\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_09;\n \n    ------------\n    -- Set_09 --\n    ------------\n \n-   procedure Set_09 (Arr : System.Address; N : Natural; E : Bits_09) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_09\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_09;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_09;\n \n end System.Pack_09;"}, {"sha": "78defe038b26d41c1d0353f082a0d1b629153fb7", "filename": "gcc/ada/s-pack09.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack09.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack09.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack09.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_09 is\n    type Bits_09 is mod 2 ** Bits;\n    for Bits_09'Size use Bits;\n \n-   function Get_09 (Arr : System.Address; N : Natural) return Bits_09;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_09\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_09 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_09 (Arr : System.Address; N : Natural; E : Bits_09);\n+   procedure Set_09\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_09;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "402c9fa78672de2d171cf531cad75d7b2240e511", "filename": "gcc/ada/s-pack10.adb", "status": "modified", "additions": 140, "deletions": 53, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack10.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_10 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_10 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_10 or SetU_10 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_10 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_10 --\n    ------------\n \n-   function Get_10 (Arr : System.Address; N : Natural) return Bits_10 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_10\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_10\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_10;\n \n    -------------\n    -- GetU_10 --\n    -------------\n \n-   function GetU_10 (Arr : System.Address; N : Natural) return Bits_10 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_10\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_10\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_10;\n \n    ------------\n    -- Set_10 --\n    ------------\n \n-   procedure Set_10 (Arr : System.Address; N : Natural; E : Bits_10) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_10\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_10;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_10;\n \n    -------------\n    -- SetU_10 --\n    -------------\n \n-   procedure SetU_10 (Arr : System.Address; N : Natural; E : Bits_10) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_10\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_10;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_10;\n \n end System.Pack_10;"}, {"sha": "dc4113efeed673cc70bcbce25c3516941ef21f60", "filename": "gcc/ada/s-pack10.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack10.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack10.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack10.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_10 is\n    type Bits_10 is mod 2 ** Bits;\n    for Bits_10'Size use Bits;\n \n-   function Get_10 (Arr : System.Address; N : Natural) return Bits_10;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_10\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_10 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_10 (Arr : System.Address; N : Natural; E : Bits_10);\n+   procedure Set_10\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_10;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_10 (Arr : System.Address; N : Natural) return Bits_10;\n+   function GetU_10\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_10 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_10 (Arr : System.Address; N : Natural; E : Bits_10);\n+   procedure SetU_10\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_10;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "23edceb12cd74bf430dde07db97f4ffad891c2ab", "filename": "gcc/ada/s-pack11.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack11.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_11 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_11 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_11 --\n    ------------\n \n-   function Get_11 (Arr : System.Address; N : Natural) return Bits_11 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_11\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_11\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_11;\n \n    ------------\n    -- Set_11 --\n    ------------\n \n-   procedure Set_11 (Arr : System.Address; N : Natural; E : Bits_11) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_11\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_11;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_11;\n \n end System.Pack_11;"}, {"sha": "e812a0057ea93e5811a9261d98575bf3b65bd4c8", "filename": "gcc/ada/s-pack11.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack11.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack11.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack11.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_11 is\n    type Bits_11 is mod 2 ** Bits;\n    for Bits_11'Size use Bits;\n \n-   function Get_11 (Arr : System.Address; N : Natural) return Bits_11;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_11\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_11 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_11 (Arr : System.Address; N : Natural; E : Bits_11);\n+   procedure Set_11\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_11;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "69b090dc7bb0e3de113cfdd4af4ca9a8f390d496", "filename": "gcc/ada/s-pack12.adb", "status": "modified", "additions": 140, "deletions": 53, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack12.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_12 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_12 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_12 or SetU_12 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_12 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_12 --\n    ------------\n \n-   function Get_12 (Arr : System.Address; N : Natural) return Bits_12 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_12\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_12\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_12;\n \n    -------------\n    -- GetU_12 --\n    -------------\n \n-   function GetU_12 (Arr : System.Address; N : Natural) return Bits_12 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_12\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_12\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_12;\n \n    ------------\n    -- Set_12 --\n    ------------\n \n-   procedure Set_12 (Arr : System.Address; N : Natural; E : Bits_12) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_12\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_12;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_12;\n \n    -------------\n    -- SetU_12 --\n    -------------\n \n-   procedure SetU_12 (Arr : System.Address; N : Natural; E : Bits_12) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_12\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_12;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_12;\n \n end System.Pack_12;"}, {"sha": "ae0af7e635fb8e5e3075636e7741fbedd52307d8", "filename": "gcc/ada/s-pack12.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack12.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack12.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack12.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_12 is\n    type Bits_12 is mod 2 ** Bits;\n    for Bits_12'Size use Bits;\n \n-   function Get_12 (Arr : System.Address; N : Natural) return Bits_12;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_12\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_12 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_12 (Arr : System.Address; N : Natural; E : Bits_12);\n+   procedure Set_12\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_12;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_12 (Arr : System.Address; N : Natural) return Bits_12;\n+   function GetU_12\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_12 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_12 (Arr : System.Address; N : Natural; E : Bits_12);\n+   procedure SetU_12\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_12;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "0970d694810290c0bde0b80a585dded31fe55f61", "filename": "gcc/ada/s-pack13.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack13.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_13 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_13 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_13 --\n    ------------\n \n-   function Get_13 (Arr : System.Address; N : Natural) return Bits_13 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_13\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_13\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_13;\n \n    ------------\n    -- Set_13 --\n    ------------\n \n-   procedure Set_13 (Arr : System.Address; N : Natural; E : Bits_13) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_13\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_13;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_13;\n \n end System.Pack_13;"}, {"sha": "f58fbf7c61ff336061fe23dd30a690ce51c0a095", "filename": "gcc/ada/s-pack13.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack13.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_13 is\n    type Bits_13 is mod 2 ** Bits;\n    for Bits_13'Size use Bits;\n \n-   function Get_13 (Arr : System.Address; N : Natural) return Bits_13;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_13\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_13 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_13 (Arr : System.Address; N : Natural; E : Bits_13);\n+   procedure Set_13\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_13;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "8cae0d7091e26ad10bc4e92e425d3bce2766b211", "filename": "gcc/ada/s-pack14.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack14.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack14.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack14.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_14 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_14 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_14 or SetU_14 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_14 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_14 --\n    ------------\n \n-   function Get_14 (Arr : System.Address; N : Natural) return Bits_14 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_14\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_14\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_14;\n \n    -------------\n    -- GetU_14 --\n    -------------\n \n-   function GetU_14 (Arr : System.Address; N : Natural) return Bits_14 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_14\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_14\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_14;\n \n    ------------\n    -- Set_14 --\n    ------------\n \n-   procedure Set_14 (Arr : System.Address; N : Natural; E : Bits_14) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_14\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_14;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_14;\n \n    -------------\n    -- SetU_14 --\n    -------------\n \n-   procedure SetU_14 (Arr : System.Address; N : Natural; E : Bits_14) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_14\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_14;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_14;\n \n end System.Pack_14;"}, {"sha": "72cd783c5a627e89240db435407d7de9131718c3", "filename": "gcc/ada/s-pack14.ads", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack14.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack14.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack14.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -39,20 +39,37 @@ package System.Pack_14 is\n    type Bits_14 is mod 2 ** Bits;\n    for Bits_14'Size use Bits;\n \n-   function Get_14 (Arr : System.Address; N : Natural) return Bits_14;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_14\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_14 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_14 (Arr : System.Address; N : Natural; E : Bits_14);\n+   procedure Set_14\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_14;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_14 (Arr : System.Address; N : Natural) return Bits_14;\n+   function GetU_14\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_14 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_14 (Arr : System.Address; N : Natural; E : Bits_14);\n+   procedure SetU_14\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_14;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "4df1841d667c2b05a1a34cc534b92946a1130161", "filename": "gcc/ada/s-pack15.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack15.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack15.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack15.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_15 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_15 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_15 --\n    ------------\n \n-   function Get_15 (Arr : System.Address; N : Natural) return Bits_15 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_15\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_15\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_15;\n \n    ------------\n    -- Set_15 --\n    ------------\n \n-   procedure Set_15 (Arr : System.Address; N : Natural; E : Bits_15) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_15\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_15;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_15;\n \n end System.Pack_15;"}, {"sha": "787ca7ee7e31673b34f99198a4d1c2eb4541abbc", "filename": "gcc/ada/s-pack15.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack15.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack15.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack15.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_15 is\n    type Bits_15 is mod 2 ** Bits;\n    for Bits_15'Size use Bits;\n \n-   function Get_15 (Arr : System.Address; N : Natural) return Bits_15;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_15\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_15 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_15 (Arr : System.Address; N : Natural; E : Bits_15);\n+   procedure Set_15\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_15;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "0fc493881bb2b41121923fdd004d7de345a5ce9c", "filename": "gcc/ada/s-pack17.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack17.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack17.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack17.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_17 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_17 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_17 --\n    ------------\n \n-   function Get_17 (Arr : System.Address; N : Natural) return Bits_17 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_17\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_17\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_17;\n \n    ------------\n    -- Set_17 --\n    ------------\n \n-   procedure Set_17 (Arr : System.Address; N : Natural; E : Bits_17) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_17\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_17;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_17;\n \n end System.Pack_17;"}, {"sha": "9234b1e50082b7546b6740b7a4bf68a9ba36d5d7", "filename": "gcc/ada/s-pack17.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack17.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack17.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack17.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_17 is\n    type Bits_17 is mod 2 ** Bits;\n    for Bits_17'Size use Bits;\n \n-   function Get_17 (Arr : System.Address; N : Natural) return Bits_17;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_17\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_17 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_17 (Arr : System.Address; N : Natural; E : Bits_17);\n+   procedure Set_17\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_17;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "5e2e33f8602b858fe65575cc56e602893092b269", "filename": "gcc/ada/s-pack18.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack18.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack18.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack18.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_18 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_18 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_18 or SetU_18 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_18 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_18 --\n    ------------\n \n-   function Get_18 (Arr : System.Address; N : Natural) return Bits_18 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_18\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_18\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_18;\n \n    -------------\n    -- GetU_18 --\n    -------------\n \n-   function GetU_18 (Arr : System.Address; N : Natural) return Bits_18 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_18\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_18\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_18;\n \n    ------------\n    -- Set_18 --\n    ------------\n \n-   procedure Set_18 (Arr : System.Address; N : Natural; E : Bits_18) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_18\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_18;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_18;\n \n    -------------\n    -- SetU_18 --\n    -------------\n \n-   procedure SetU_18 (Arr : System.Address; N : Natural; E : Bits_18) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_18\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_18;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_18;\n \n end System.Pack_18;"}, {"sha": "051d992cbcceb7126723fbdcb63ea2ac128ed0d0", "filename": "gcc/ada/s-pack18.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack18.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack18.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack18.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_18 is\n    type Bits_18 is mod 2 ** Bits;\n    for Bits_18'Size use Bits;\n \n-   function Get_18 (Arr : System.Address; N : Natural) return Bits_18;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_18\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_18 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_18 (Arr : System.Address; N : Natural; E : Bits_18);\n+   procedure Set_18\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_18;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_18 (Arr : System.Address; N : Natural) return Bits_18;\n+   function GetU_18\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_18 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_18 (Arr : System.Address; N : Natural; E : Bits_18);\n+   procedure SetU_18\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_18;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "3a9c2e7f6d283200c4578a8dac1467cbf2011553", "filename": "gcc/ada/s-pack19.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack19.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack19.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack19.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_19 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_19 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_19 --\n    ------------\n \n-   function Get_19 (Arr : System.Address; N : Natural) return Bits_19 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_19\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_19\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_19;\n \n    ------------\n    -- Set_19 --\n    ------------\n \n-   procedure Set_19 (Arr : System.Address; N : Natural; E : Bits_19) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_19\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_19;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_19;\n \n end System.Pack_19;"}, {"sha": "03dedb4f42613ef4a08f57a07b42fe7a2d1c9082", "filename": "gcc/ada/s-pack19.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack19.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack19.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack19.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_19 is\n    type Bits_19 is mod 2 ** Bits;\n    for Bits_19'Size use Bits;\n \n-   function Get_19 (Arr : System.Address; N : Natural) return Bits_19;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_19\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_19 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_19 (Arr : System.Address; N : Natural; E : Bits_19);\n+   procedure Set_19\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_19;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "b0b9b4b4300a2c14d576489ebfa1526665dedf2e", "filename": "gcc/ada/s-pack20.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack20.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack20.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack20.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_20 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_20 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_20 or SetU_20 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_20 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_20 --\n    ------------\n \n-   function Get_20 (Arr : System.Address; N : Natural) return Bits_20 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_20\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_20\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_20;\n \n    -------------\n    -- GetU_20 --\n    -------------\n \n-   function GetU_20 (Arr : System.Address; N : Natural) return Bits_20 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_20\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_20\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_20;\n \n    ------------\n    -- Set_20 --\n    ------------\n \n-   procedure Set_20 (Arr : System.Address; N : Natural; E : Bits_20) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_20\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_20;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_20;\n \n    -------------\n    -- SetU_20 --\n    -------------\n \n-   procedure SetU_20 (Arr : System.Address; N : Natural; E : Bits_20) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_20\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_20;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_20;\n \n end System.Pack_20;"}, {"sha": "e75f828f382f3a233c361ce7a2f1378c53a29755", "filename": "gcc/ada/s-pack20.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack20.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack20.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack20.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_20 is\n    type Bits_20 is mod 2 ** Bits;\n    for Bits_20'Size use Bits;\n \n-   function Get_20 (Arr : System.Address; N : Natural) return Bits_20;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_20\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_20 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_20 (Arr : System.Address; N : Natural; E : Bits_20);\n+   procedure Set_20\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_20;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_20 (Arr : System.Address; N : Natural) return Bits_20;\n+   function GetU_20\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_20 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_20 (Arr : System.Address; N : Natural; E : Bits_20);\n+   procedure SetU_20\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_20;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "8357a699a7d612b6c99e779e582d24f0bc086803", "filename": "gcc/ada/s-pack21.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack21.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack21.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack21.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_21 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_21 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_21 --\n    ------------\n \n-   function Get_21 (Arr : System.Address; N : Natural) return Bits_21 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_21\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_21\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_21;\n \n    ------------\n    -- Set_21 --\n    ------------\n \n-   procedure Set_21 (Arr : System.Address; N : Natural; E : Bits_21) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_21\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_21;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_21;\n \n end System.Pack_21;"}, {"sha": "0454df05b483fd493a211b91290e0756722bff20", "filename": "gcc/ada/s-pack21.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack21.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack21.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack21.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_21 is\n    type Bits_21 is mod 2 ** Bits;\n    for Bits_21'Size use Bits;\n \n-   function Get_21 (Arr : System.Address; N : Natural) return Bits_21;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_21\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_21 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_21 (Arr : System.Address; N : Natural; E : Bits_21);\n+   procedure Set_21\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_21;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "ae27d67d53bfbd1d4141b0302d1d118db6b6ae17", "filename": "gcc/ada/s-pack22.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack22.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack22.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack22.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_22 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_22 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_22 or SetU_22 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_22 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_22 --\n    ------------\n \n-   function Get_22 (Arr : System.Address; N : Natural) return Bits_22 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_22\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_22\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_22;\n \n    -------------\n    -- GetU_22 --\n    -------------\n \n-   function GetU_22 (Arr : System.Address; N : Natural) return Bits_22 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_22\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_22\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_22;\n \n    ------------\n    -- Set_22 --\n    ------------\n \n-   procedure Set_22 (Arr : System.Address; N : Natural; E : Bits_22) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_22\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_22;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_22;\n \n    -------------\n    -- SetU_22 --\n    -------------\n \n-   procedure SetU_22 (Arr : System.Address; N : Natural; E : Bits_22) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_22\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_22;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_22;\n \n end System.Pack_22;"}, {"sha": "7504ba8b83d1ad38c31a6edd507696308910edf9", "filename": "gcc/ada/s-pack22.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack22.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack22.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack22.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_22 is\n    type Bits_22 is mod 2 ** Bits;\n    for Bits_22'Size use Bits;\n \n-   function Get_22 (Arr : System.Address; N : Natural) return Bits_22;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_22\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_22 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_22 (Arr : System.Address; N : Natural; E : Bits_22);\n+   procedure Set_22\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_22;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_22 (Arr : System.Address; N : Natural) return Bits_22;\n+   function GetU_22\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_22 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_22 (Arr : System.Address; N : Natural; E : Bits_22);\n+   procedure SetU_22\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_22;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "85f4af96a76897bf41c9c65e38bece465d975a98", "filename": "gcc/ada/s-pack23.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack23.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack23.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack23.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_23 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_23 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_23 --\n    ------------\n \n-   function Get_23 (Arr : System.Address; N : Natural) return Bits_23 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_23\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_23\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_23;\n \n    ------------\n    -- Set_23 --\n    ------------\n \n-   procedure Set_23 (Arr : System.Address; N : Natural; E : Bits_23) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_23\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_23;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_23;\n \n end System.Pack_23;"}, {"sha": "9057453c1b2a6ddf9a64a63fb695283f9a02dc8d", "filename": "gcc/ada/s-pack23.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack23.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack23.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack23.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_23 is\n    type Bits_23 is mod 2 ** Bits;\n    for Bits_23'Size use Bits;\n \n-   function Get_23 (Arr : System.Address; N : Natural) return Bits_23;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_23\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_23 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_23 (Arr : System.Address; N : Natural; E : Bits_23);\n+   procedure Set_23\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_23;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "96cbabf750cfccf92964a683dc7ec38bd55fda78", "filename": "gcc/ada/s-pack24.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack24.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack24.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack24.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_24 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_24 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_24 or SetU_24 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_24 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_24 --\n    ------------\n \n-   function Get_24 (Arr : System.Address; N : Natural) return Bits_24 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_24\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_24\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_24;\n \n    -------------\n    -- GetU_24 --\n    -------------\n \n-   function GetU_24 (Arr : System.Address; N : Natural) return Bits_24 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_24\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_24\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_24;\n \n    ------------\n    -- Set_24 --\n    ------------\n \n-   procedure Set_24 (Arr : System.Address; N : Natural; E : Bits_24) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_24\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_24;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_24;\n \n    -------------\n    -- SetU_24 --\n    -------------\n \n-   procedure SetU_24 (Arr : System.Address; N : Natural; E : Bits_24) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_24\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_24;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_24;\n \n end System.Pack_24;"}, {"sha": "fde2fa3e666c7ad64a6fa93a7ed16b56dc4e4242", "filename": "gcc/ada/s-pack24.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack24.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack24.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack24.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_24 is\n    type Bits_24 is mod 2 ** Bits;\n    for Bits_24'Size use Bits;\n \n-   function Get_24 (Arr : System.Address; N : Natural) return Bits_24;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_24\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_24 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_24 (Arr : System.Address; N : Natural; E : Bits_24);\n+   procedure Set_24\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_24;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_24 (Arr : System.Address; N : Natural) return Bits_24;\n+   function GetU_24\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_24 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_24 (Arr : System.Address; N : Natural; E : Bits_24);\n+   procedure SetU_24\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_24;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "e3df996ca4428d1e044204957dde2c73170ae9b9", "filename": "gcc/ada/s-pack25.adb", "status": "modified", "additions": 72, "deletions": 27, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack25.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack25.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack25.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_25 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_25 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_25 --\n    ------------\n \n-   function Get_25 (Arr : System.Address; N : Natural) return Bits_25 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_25\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_25\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_25;\n \n    ------------\n    -- Set_25 --\n    ------------\n \n-   procedure Set_25 (Arr : System.Address; N : Natural; E : Bits_25) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_25\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_25;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_25;\n \n end System.Pack_25;"}, {"sha": "d59beebd4bbcbf7bc5d64f800231b4fdb46a1cba", "filename": "gcc/ada/s-pack25.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack25.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack25.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack25.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_25 is\n    type Bits_25 is mod 2 ** Bits;\n    for Bits_25'Size use Bits;\n \n-   function Get_25 (Arr : System.Address; N : Natural) return Bits_25;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_25\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_25 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_25 (Arr : System.Address; N : Natural; E : Bits_25);\n+   procedure Set_25\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_25;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "d7edc149e726492b2ebc403aabc51ab8b27ae848", "filename": "gcc/ada/s-pack26.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack26.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack26.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack26.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_26 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_26 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_26 or SetU_26 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_26 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_26 --\n    ------------\n \n-   function Get_26 (Arr : System.Address; N : Natural) return Bits_26 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_26\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_26\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_26;\n \n    -------------\n    -- GetU_26 --\n    -------------\n \n-   function GetU_26 (Arr : System.Address; N : Natural) return Bits_26 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_26\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_26\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_26;\n \n    ------------\n    -- Set_26 --\n    ------------\n \n-   procedure Set_26 (Arr : System.Address; N : Natural; E : Bits_26) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_26\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_26;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_26;\n \n    -------------\n    -- SetU_26 --\n    -------------\n \n-   procedure SetU_26 (Arr : System.Address; N : Natural; E : Bits_26) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_26\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_26;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_26;\n \n end System.Pack_26;"}, {"sha": "979e8927856e9901d64f33a9fa67ebddaff58ee2", "filename": "gcc/ada/s-pack26.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack26.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack26.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack26.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_26 is\n    type Bits_26 is mod 2 ** Bits;\n    for Bits_26'Size use Bits;\n \n-   function Get_26 (Arr : System.Address; N : Natural) return Bits_26;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_26\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_26 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_26 (Arr : System.Address; N : Natural; E : Bits_26);\n+   procedure Set_26\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_26;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_26 (Arr : System.Address; N : Natural) return Bits_26;\n+   function GetU_26\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_26 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_26 (Arr : System.Address; N : Natural; E : Bits_26);\n+   procedure SetU_26\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_26;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "0a15d878abc0febae0b8ed0b850697e647880298", "filename": "gcc/ada/s-pack27.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack27.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack27.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack27.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_27 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_27 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_27 --\n    ------------\n \n-   function Get_27 (Arr : System.Address; N : Natural) return Bits_27 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_27\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_27\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_27;\n \n    ------------\n    -- Set_27 --\n    ------------\n \n-   procedure Set_27 (Arr : System.Address; N : Natural; E : Bits_27) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_27\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_27;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_27;\n \n end System.Pack_27;"}, {"sha": "da77d5746b6fc71c8962557455b10877b7519730", "filename": "gcc/ada/s-pack27.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack27.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack27.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack27.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_27 is\n    type Bits_27 is mod 2 ** Bits;\n    for Bits_27'Size use Bits;\n \n-   function Get_27 (Arr : System.Address; N : Natural) return Bits_27;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_27\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_27 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_27 (Arr : System.Address; N : Natural; E : Bits_27);\n+   procedure Set_27\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_27;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "35daf6d56e72ac6d6c9bfb05accfaf49d74b5be5", "filename": "gcc/ada/s-pack28.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack28.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack28.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack28.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_28 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_28 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_28 or SetU_28 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_28 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_28 --\n    ------------\n \n-   function Get_28 (Arr : System.Address; N : Natural) return Bits_28 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_28\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_28\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_28;\n \n    -------------\n    -- GetU_28 --\n    -------------\n \n-   function GetU_28 (Arr : System.Address; N : Natural) return Bits_28 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_28\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_28\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_28;\n \n    ------------\n    -- Set_28 --\n    ------------\n \n-   procedure Set_28 (Arr : System.Address; N : Natural; E : Bits_28) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_28\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_28;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_28;\n \n    -------------\n    -- SetU_28 --\n    -------------\n \n-   procedure SetU_28 (Arr : System.Address; N : Natural; E : Bits_28) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_28\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_28;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_28;\n \n end System.Pack_28;"}, {"sha": "996ff25a0fdb6de7aebaf79d9a8661f1e204a71e", "filename": "gcc/ada/s-pack28.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack28.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack28.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack28.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_28 is\n    type Bits_28 is mod 2 ** Bits;\n    for Bits_28'Size use Bits;\n \n-   function Get_28 (Arr : System.Address; N : Natural) return Bits_28;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_28\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_28 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_28 (Arr : System.Address; N : Natural; E : Bits_28);\n+   procedure Set_28\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_28;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_28 (Arr : System.Address; N : Natural) return Bits_28;\n+   function GetU_28\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_28 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_28 (Arr : System.Address; N : Natural; E : Bits_28);\n+   procedure SetU_28\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_28;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "73bc62f36f3d8b977a0352d8e8264f1a99b6bcc7", "filename": "gcc/ada/s-pack29.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack29.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack29.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack29.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_29 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_29 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_29 --\n    ------------\n \n-   function Get_29 (Arr : System.Address; N : Natural) return Bits_29 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_29\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_29\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_29;\n \n    ------------\n    -- Set_29 --\n    ------------\n \n-   procedure Set_29 (Arr : System.Address; N : Natural; E : Bits_29) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_29\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_29;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_29;\n \n end System.Pack_29;"}, {"sha": "47bcb234a8b4f4baaf5f7486a78f198a01727bee", "filename": "gcc/ada/s-pack29.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack29.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack29.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack29.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_29 is\n    type Bits_29 is mod 2 ** Bits;\n    for Bits_29'Size use Bits;\n \n-   function Get_29 (Arr : System.Address; N : Natural) return Bits_29;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_29\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_29 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_29 (Arr : System.Address; N : Natural; E : Bits_29);\n+   procedure Set_29\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_29;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "ceab502f7ca939195a61e521ec5499eeff98dcb6", "filename": "gcc/ada/s-pack30.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack30.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack30.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack30.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_30 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_30 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_30 or SetU_30 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_30 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_30 --\n    ------------\n \n-   function Get_30 (Arr : System.Address; N : Natural) return Bits_30 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_30\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_30\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_30;\n \n    -------------\n    -- GetU_30 --\n    -------------\n \n-   function GetU_30 (Arr : System.Address; N : Natural) return Bits_30 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_30\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_30\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_30;\n \n    ------------\n    -- Set_30 --\n    ------------\n \n-   procedure Set_30 (Arr : System.Address; N : Natural; E : Bits_30) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_30\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_30;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_30;\n \n    -------------\n    -- SetU_30 --\n    -------------\n \n-   procedure SetU_30 (Arr : System.Address; N : Natural; E : Bits_30) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_30\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_30;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_30;\n \n end System.Pack_30;"}, {"sha": "aa8585018f5131033de1a522c1d6b0efa813196e", "filename": "gcc/ada/s-pack30.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack30.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack30.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack30.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_30 is\n    type Bits_30 is mod 2 ** Bits;\n    for Bits_30'Size use Bits;\n \n-   function Get_30 (Arr : System.Address; N : Natural) return Bits_30;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_30\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_30 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_30 (Arr : System.Address; N : Natural; E : Bits_30);\n+   procedure Set_30\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_30;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_30 (Arr : System.Address; N : Natural) return Bits_30;\n+   function GetU_30\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_30 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_30 (Arr : System.Address; N : Natural; E : Bits_30);\n+   procedure SetU_30\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_30;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "d0eada3337dceb76da6767a21f005c909f462624", "filename": "gcc/ada/s-pack31.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack31.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack31.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack31.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_31 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_31 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_31 --\n    ------------\n \n-   function Get_31 (Arr : System.Address; N : Natural) return Bits_31 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_31\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_31\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_31;\n \n    ------------\n    -- Set_31 --\n    ------------\n \n-   procedure Set_31 (Arr : System.Address; N : Natural; E : Bits_31) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_31\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_31;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_31;\n \n end System.Pack_31;"}, {"sha": "5667e6fee59996f0de9207964979e9b870b5dc2c", "filename": "gcc/ada/s-pack31.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack31.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack31.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack31.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_31 is\n    type Bits_31 is mod 2 ** Bits;\n    for Bits_31'Size use Bits;\n \n-   function Get_31 (Arr : System.Address; N : Natural) return Bits_31;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_31\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_31 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_31 (Arr : System.Address; N : Natural; E : Bits_31);\n+   procedure Set_31\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_31;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "0cbbf658d114be12f5692ee7722bec7a78d9ce28", "filename": "gcc/ada/s-pack33.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack33.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack33.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack33.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_33 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_33 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_33 --\n    ------------\n \n-   function Get_33 (Arr : System.Address; N : Natural) return Bits_33 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_33\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_33\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_33;\n \n    ------------\n    -- Set_33 --\n    ------------\n \n-   procedure Set_33 (Arr : System.Address; N : Natural; E : Bits_33) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_33\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_33;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_33;\n \n end System.Pack_33;"}, {"sha": "085298b10e6c2d685c924c84ff16342c911764fc", "filename": "gcc/ada/s-pack33.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack33.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack33.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack33.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_33 is\n    type Bits_33 is mod 2 ** Bits;\n    for Bits_33'Size use Bits;\n \n-   function Get_33 (Arr : System.Address; N : Natural) return Bits_33;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_33\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_33 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_33 (Arr : System.Address; N : Natural; E : Bits_33);\n+   procedure Set_33\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_33;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "b97c63d0689d3a9d54a31babf20d42fe104cfcba", "filename": "gcc/ada/s-pack34.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack34.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack34.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack34.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_34 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_34 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_34 or SetU_34 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_34 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_34 --\n    ------------\n \n-   function Get_34 (Arr : System.Address; N : Natural) return Bits_34 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_34\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_34\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_34;\n \n    -------------\n    -- GetU_34 --\n    -------------\n \n-   function GetU_34 (Arr : System.Address; N : Natural) return Bits_34 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_34\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_34\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_34;\n \n    ------------\n    -- Set_34 --\n    ------------\n \n-   procedure Set_34 (Arr : System.Address; N : Natural; E : Bits_34) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_34\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_34;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_34;\n \n    -------------\n    -- SetU_34 --\n    -------------\n \n-   procedure SetU_34 (Arr : System.Address; N : Natural; E : Bits_34) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_34\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_34;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_34;\n \n end System.Pack_34;"}, {"sha": "668f8066cd8c1c3adff71dd34b4511cb09e0bb65", "filename": "gcc/ada/s-pack34.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack34.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack34.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack34.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_34 is\n    type Bits_34 is mod 2 ** Bits;\n    for Bits_34'Size use Bits;\n \n-   function Get_34 (Arr : System.Address; N : Natural) return Bits_34;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_34\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_34 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_34 (Arr : System.Address; N : Natural; E : Bits_34);\n+   procedure Set_34\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_34;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_34 (Arr : System.Address; N : Natural) return Bits_34;\n+   function GetU_34\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_34 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_34 (Arr : System.Address; N : Natural; E : Bits_34);\n+   procedure SetU_34\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_34;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "98bbd8586c79532c5e50ae96f5b66c0e074f796d", "filename": "gcc/ada/s-pack35.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack35.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack35.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack35.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_35 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_35 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_35 --\n    ------------\n \n-   function Get_35 (Arr : System.Address; N : Natural) return Bits_35 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_35\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_35\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_35;\n \n    ------------\n    -- Set_35 --\n    ------------\n \n-   procedure Set_35 (Arr : System.Address; N : Natural; E : Bits_35) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_35\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_35;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_35;\n \n end System.Pack_35;"}, {"sha": "a1e8e0c3c9d34ff54b1058c0663f89b9b98a03e3", "filename": "gcc/ada/s-pack35.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack35.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack35.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack35.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_35 is\n    type Bits_35 is mod 2 ** Bits;\n    for Bits_35'Size use Bits;\n \n-   function Get_35 (Arr : System.Address; N : Natural) return Bits_35;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_35\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_35 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_35 (Arr : System.Address; N : Natural; E : Bits_35);\n+   procedure Set_35\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_35;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "9303a5084870ddabb9ca6a3dc0c473d8888ca7f5", "filename": "gcc/ada/s-pack36.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack36.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack36.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack36.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_36 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_36 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_36 or SetU_36 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_36 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_36 --\n    ------------\n \n-   function Get_36 (Arr : System.Address; N : Natural) return Bits_36 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_36\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_36\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_36;\n \n    -------------\n    -- GetU_36 --\n    -------------\n \n-   function GetU_36 (Arr : System.Address; N : Natural) return Bits_36 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_36\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_36\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_36;\n \n    ------------\n    -- Set_36 --\n    ------------\n \n-   procedure Set_36 (Arr : System.Address; N : Natural; E : Bits_36) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_36\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_36;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_36;\n \n    -------------\n    -- SetU_36 --\n    -------------\n \n-   procedure SetU_36 (Arr : System.Address; N : Natural; E : Bits_36) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_36\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_36;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_36;\n \n end System.Pack_36;"}, {"sha": "456c7fa967c34c02e77349e23d80392565464c94", "filename": "gcc/ada/s-pack36.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack36.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack36.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack36.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_36 is\n    type Bits_36 is mod 2 ** Bits;\n    for Bits_36'Size use Bits;\n \n-   function Get_36 (Arr : System.Address; N : Natural) return Bits_36;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_36\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_36 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_36 (Arr : System.Address; N : Natural; E : Bits_36);\n+   procedure Set_36\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_36;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_36 (Arr : System.Address; N : Natural) return Bits_36;\n+   function GetU_36\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_36 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_36 (Arr : System.Address; N : Natural; E : Bits_36);\n+   procedure SetU_36\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_36;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "ec4a21ac77dd0a8e64fc6b0e91a7dcecebb5d09e", "filename": "gcc/ada/s-pack37.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack37.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack37.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack37.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_37 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_37 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_37 --\n    ------------\n \n-   function Get_37 (Arr : System.Address; N : Natural) return Bits_37 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_37\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_37\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_37;\n \n    ------------\n    -- Set_37 --\n    ------------\n \n-   procedure Set_37 (Arr : System.Address; N : Natural; E : Bits_37) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_37\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_37;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_37;\n \n end System.Pack_37;"}, {"sha": "8b8084346be7ba4767f25665b04b435f50dec463", "filename": "gcc/ada/s-pack37.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack37.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack37.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack37.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_37 is\n    type Bits_37 is mod 2 ** Bits;\n    for Bits_37'Size use Bits;\n \n-   function Get_37 (Arr : System.Address; N : Natural) return Bits_37;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_37\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_37 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_37 (Arr : System.Address; N : Natural; E : Bits_37);\n+   procedure Set_37\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_37;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "b12166ebfc91a2e098819a75e96785b99d638141", "filename": "gcc/ada/s-pack38.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack38.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack38.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack38.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_38 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_38 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_38 or SetU_38 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_38 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_38 --\n    ------------\n \n-   function Get_38 (Arr : System.Address; N : Natural) return Bits_38 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_38\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_38\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_38;\n \n    -------------\n    -- GetU_38 --\n    -------------\n \n-   function GetU_38 (Arr : System.Address; N : Natural) return Bits_38 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_38\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_38\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_38;\n \n    ------------\n    -- Set_38 --\n    ------------\n \n-   procedure Set_38 (Arr : System.Address; N : Natural; E : Bits_38) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_38\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_38;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_38;\n \n    -------------\n    -- SetU_38 --\n    -------------\n \n-   procedure SetU_38 (Arr : System.Address; N : Natural; E : Bits_38) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_38\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_38;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_38;\n \n end System.Pack_38;"}, {"sha": "f2a98891c0bd8369c9232f949dbb00bd0b45e235", "filename": "gcc/ada/s-pack38.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack38.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack38.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack38.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_38 is\n    type Bits_38 is mod 2 ** Bits;\n    for Bits_38'Size use Bits;\n \n-   function Get_38 (Arr : System.Address; N : Natural) return Bits_38;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_38\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_38 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_38 (Arr : System.Address; N : Natural; E : Bits_38);\n+   procedure Set_38\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_38;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_38 (Arr : System.Address; N : Natural) return Bits_38;\n+   function GetU_38\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_38 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_38 (Arr : System.Address; N : Natural; E : Bits_38);\n+   procedure SetU_38\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_38;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "85c942a64147c53373650f615373696ee89b36fe", "filename": "gcc/ada/s-pack39.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack39.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack39.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack39.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_39 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_39 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_39 --\n    ------------\n \n-   function Get_39 (Arr : System.Address; N : Natural) return Bits_39 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_39\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_39\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_39;\n \n    ------------\n    -- Set_39 --\n    ------------\n \n-   procedure Set_39 (Arr : System.Address; N : Natural; E : Bits_39) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_39\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_39;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_39;\n \n end System.Pack_39;"}, {"sha": "8ba083db4df3f86332bbae7df30772d36172d997", "filename": "gcc/ada/s-pack39.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack39.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack39.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack39.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_39 is\n    type Bits_39 is mod 2 ** Bits;\n    for Bits_39'Size use Bits;\n \n-   function Get_39 (Arr : System.Address; N : Natural) return Bits_39;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_39\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_39 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_39 (Arr : System.Address; N : Natural; E : Bits_39);\n+   procedure Set_39\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_39;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "993fc95dce7852e8854060771528099d9e7209e2", "filename": "gcc/ada/s-pack40.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack40.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack40.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack40.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_40 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_40 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_40 or SetU_40 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_40 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_40 --\n    ------------\n \n-   function Get_40 (Arr : System.Address; N : Natural) return Bits_40 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_40\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_40\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_40;\n \n    -------------\n    -- GetU_40 --\n    -------------\n \n-   function GetU_40 (Arr : System.Address; N : Natural) return Bits_40 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_40\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_40\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_40;\n \n    ------------\n    -- Set_40 --\n    ------------\n \n-   procedure Set_40 (Arr : System.Address; N : Natural; E : Bits_40) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_40\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_40;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_40;\n \n    -------------\n    -- SetU_40 --\n    -------------\n \n-   procedure SetU_40 (Arr : System.Address; N : Natural; E : Bits_40) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_40\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_40;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_40;\n \n end System.Pack_40;"}, {"sha": "1f30ee358ceb19dc3578553ce3c91b571dead2ad", "filename": "gcc/ada/s-pack40.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack40.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack40.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack40.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_40 is\n    type Bits_40 is mod 2 ** Bits;\n    for Bits_40'Size use Bits;\n \n-   function Get_40 (Arr : System.Address; N : Natural) return Bits_40;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_40\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_40 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_40 (Arr : System.Address; N : Natural; E : Bits_40);\n+   procedure Set_40\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_40;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_40 (Arr : System.Address; N : Natural) return Bits_40;\n+   function GetU_40\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_40 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_40 (Arr : System.Address; N : Natural; E : Bits_40);\n+   procedure SetU_40\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_40;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "dd580c06fa50fb33cdc071c9dacffa6be8cf617f", "filename": "gcc/ada/s-pack41.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack41.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack41.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack41.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_41 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_41 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_41 --\n    ------------\n \n-   function Get_41 (Arr : System.Address; N : Natural) return Bits_41 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_41\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_41\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_41;\n \n    ------------\n    -- Set_41 --\n    ------------\n \n-   procedure Set_41 (Arr : System.Address; N : Natural; E : Bits_41) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_41\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_41;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_41;\n \n end System.Pack_41;"}, {"sha": "8dcae701a0c541c6f64f330eed3eed6cc380b5e5", "filename": "gcc/ada/s-pack41.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack41.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack41.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack41.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_41 is\n    type Bits_41 is mod 2 ** Bits;\n    for Bits_41'Size use Bits;\n \n-   function Get_41 (Arr : System.Address; N : Natural) return Bits_41;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_41\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_41 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_41 (Arr : System.Address; N : Natural; E : Bits_41);\n+   procedure Set_41\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_41;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "bc8285a53d5d9e74f15bbd166da7af8f9516c421", "filename": "gcc/ada/s-pack42.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack42.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack42.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack42.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_42 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_42 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_42 or SetU_42 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_42 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_42 --\n    ------------\n \n-   function Get_42 (Arr : System.Address; N : Natural) return Bits_42 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_42\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_42\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_42;\n \n    -------------\n    -- GetU_42 --\n    -------------\n \n-   function GetU_42 (Arr : System.Address; N : Natural) return Bits_42 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_42\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_42\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_42;\n \n    ------------\n    -- Set_42 --\n    ------------\n \n-   procedure Set_42 (Arr : System.Address; N : Natural; E : Bits_42) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_42\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_42;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_42;\n \n    -------------\n    -- SetU_42 --\n    -------------\n \n-   procedure SetU_42 (Arr : System.Address; N : Natural; E : Bits_42) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_42\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_42;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_42;\n \n end System.Pack_42;"}, {"sha": "73872fd1dd299ccf9efc53f582960a04e69e0851", "filename": "gcc/ada/s-pack42.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack42.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack42.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack42.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_42 is\n    type Bits_42 is mod 2 ** Bits;\n    for Bits_42'Size use Bits;\n \n-   function Get_42 (Arr : System.Address; N : Natural) return Bits_42;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_42\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_42 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_42 (Arr : System.Address; N : Natural; E : Bits_42);\n+   procedure Set_42\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_42;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_42 (Arr : System.Address; N : Natural) return Bits_42;\n+   function GetU_42\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_42 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_42 (Arr : System.Address; N : Natural; E : Bits_42);\n+   procedure SetU_42\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_42;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "509cb006ef79deb27d124902c57dd1af5161c29c", "filename": "gcc/ada/s-pack43.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack43.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack43.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack43.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_43 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_43 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_43 --\n    ------------\n \n-   function Get_43 (Arr : System.Address; N : Natural) return Bits_43 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_43\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_43\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_43;\n \n    ------------\n    -- Set_43 --\n    ------------\n \n-   procedure Set_43 (Arr : System.Address; N : Natural; E : Bits_43) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_43\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_43;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_43;\n \n end System.Pack_43;"}, {"sha": "f82678f6efdde4da3b670bfa0222c982c3ea553d", "filename": "gcc/ada/s-pack43.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack43.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack43.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack43.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_43 is\n    type Bits_43 is mod 2 ** Bits;\n    for Bits_43'Size use Bits;\n \n-   function Get_43 (Arr : System.Address; N : Natural) return Bits_43;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_43\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_43 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_43 (Arr : System.Address; N : Natural; E : Bits_43);\n+   procedure Set_43\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_43;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "f7fe185573a40812fb1fb6847ec1a859afb40808", "filename": "gcc/ada/s-pack44.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack44.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack44.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack44.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_44 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_44 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_44 or SetU_44 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_44 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_44 --\n    ------------\n \n-   function Get_44 (Arr : System.Address; N : Natural) return Bits_44 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_44\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_44\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_44;\n \n    -------------\n    -- GetU_44 --\n    -------------\n \n-   function GetU_44 (Arr : System.Address; N : Natural) return Bits_44 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_44\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_44\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_44;\n \n    ------------\n    -- Set_44 --\n    ------------\n \n-   procedure Set_44 (Arr : System.Address; N : Natural; E : Bits_44) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_44\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_44;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_44;\n \n    -------------\n    -- SetU_44 --\n    -------------\n \n-   procedure SetU_44 (Arr : System.Address; N : Natural; E : Bits_44) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_44\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_44;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_44;\n \n end System.Pack_44;"}, {"sha": "89b3f3e747e680d11b9193b3d6ea53f7425fe465", "filename": "gcc/ada/s-pack44.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack44.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack44.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack44.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_44 is\n    type Bits_44 is mod 2 ** Bits;\n    for Bits_44'Size use Bits;\n \n-   function Get_44 (Arr : System.Address; N : Natural) return Bits_44;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_44\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_44 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_44 (Arr : System.Address; N : Natural; E : Bits_44);\n+   procedure Set_44\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_44;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_44 (Arr : System.Address; N : Natural) return Bits_44;\n+   function GetU_44\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_44 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_44 (Arr : System.Address; N : Natural; E : Bits_44);\n+   procedure SetU_44\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_44;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "2247312e77a0e17dcec00fcce8a5d81be77d0785", "filename": "gcc/ada/s-pack45.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack45.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack45.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack45.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_45 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_45 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_45 --\n    ------------\n \n-   function Get_45 (Arr : System.Address; N : Natural) return Bits_45 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_45\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_45\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_45;\n \n    ------------\n    -- Set_45 --\n    ------------\n \n-   procedure Set_45 (Arr : System.Address; N : Natural; E : Bits_45) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_45\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_45;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_45;\n \n end System.Pack_45;"}, {"sha": "2340d48fb231b1a480c5da71068c7af660a903c8", "filename": "gcc/ada/s-pack45.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack45.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack45.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack45.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_45 is\n    type Bits_45 is mod 2 ** Bits;\n    for Bits_45'Size use Bits;\n \n-   function Get_45 (Arr : System.Address; N : Natural) return Bits_45;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_45\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_45 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_45 (Arr : System.Address; N : Natural; E : Bits_45);\n+   procedure Set_45\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_45;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "c2b45f054df46e87c3ba9ef1b3a01d61566f5ccd", "filename": "gcc/ada/s-pack46.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack46.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack46.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack46.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_46 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_46 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_46 or SetU_46 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_46 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_46 --\n    ------------\n \n-   function Get_46 (Arr : System.Address; N : Natural) return Bits_46 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_46\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_46\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_46;\n \n    -------------\n    -- GetU_46 --\n    -------------\n \n-   function GetU_46 (Arr : System.Address; N : Natural) return Bits_46 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_46\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_46\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_46;\n \n    ------------\n    -- Set_46 --\n    ------------\n \n-   procedure Set_46 (Arr : System.Address; N : Natural; E : Bits_46) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_46\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_46;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_46;\n \n    -------------\n    -- SetU_46 --\n    -------------\n \n-   procedure SetU_46 (Arr : System.Address; N : Natural; E : Bits_46) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_46\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_46;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_46;\n \n end System.Pack_46;"}, {"sha": "6ab8dfe5cccddae6bfbaddab200e0fe3bb5fe313", "filename": "gcc/ada/s-pack46.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack46.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack46.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack46.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_46 is\n    type Bits_46 is mod 2 ** Bits;\n    for Bits_46'Size use Bits;\n \n-   function Get_46 (Arr : System.Address; N : Natural) return Bits_46;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_46\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_46 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_46 (Arr : System.Address; N : Natural; E : Bits_46);\n+   procedure Set_46\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_46;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_46 (Arr : System.Address; N : Natural) return Bits_46;\n+   function GetU_46\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_46 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_46 (Arr : System.Address; N : Natural; E : Bits_46);\n+   procedure SetU_46\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_46;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "d63e35df5741c3af1f4bd11f5f5e3ae7919646bf", "filename": "gcc/ada/s-pack47.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack47.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack47.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack47.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_47 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_47 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_47 --\n    ------------\n \n-   function Get_47 (Arr : System.Address; N : Natural) return Bits_47 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_47\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_47\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_47;\n \n    ------------\n    -- Set_47 --\n    ------------\n \n-   procedure Set_47 (Arr : System.Address; N : Natural; E : Bits_47) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_47\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_47;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_47;\n \n end System.Pack_47;"}, {"sha": "f924965b3eb92097a88808b4f52da80b64e1c545", "filename": "gcc/ada/s-pack47.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack47.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack47.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack47.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_47 is\n    type Bits_47 is mod 2 ** Bits;\n    for Bits_47'Size use Bits;\n \n-   function Get_47 (Arr : System.Address; N : Natural) return Bits_47;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_47\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_47 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_47 (Arr : System.Address; N : Natural; E : Bits_47);\n+   procedure Set_47\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_47;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "780a15793d5ff8cec9f811a90dd680ddbfe64d12", "filename": "gcc/ada/s-pack48.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack48.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack48.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack48.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_48 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_48 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_48 or SetU_48 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_48 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_48 --\n    ------------\n \n-   function Get_48 (Arr : System.Address; N : Natural) return Bits_48 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_48\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_48\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_48;\n \n    -------------\n    -- GetU_48 --\n    -------------\n \n-   function GetU_48 (Arr : System.Address; N : Natural) return Bits_48 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_48\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_48\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_48;\n \n    ------------\n    -- Set_48 --\n    ------------\n \n-   procedure Set_48 (Arr : System.Address; N : Natural; E : Bits_48) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_48\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_48;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_48;\n \n    -------------\n    -- SetU_48 --\n    -------------\n \n-   procedure SetU_48 (Arr : System.Address; N : Natural; E : Bits_48) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_48\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_48;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_48;\n \n end System.Pack_48;"}, {"sha": "ba1008e68b7c92778a56eb54873e80b8fd5ec5fe", "filename": "gcc/ada/s-pack48.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack48.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack48.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack48.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_48 is\n    type Bits_48 is mod 2 ** Bits;\n    for Bits_48'Size use Bits;\n \n-   function Get_48 (Arr : System.Address; N : Natural) return Bits_48;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_48\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_48 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_48 (Arr : System.Address; N : Natural; E : Bits_48);\n+   procedure Set_48\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_48;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_48 (Arr : System.Address; N : Natural) return Bits_48;\n+   function GetU_48\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_48 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_48 (Arr : System.Address; N : Natural; E : Bits_48);\n+   procedure SetU_48\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_48;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "a9cad23681060e1998ac26d38783a20504acac8d", "filename": "gcc/ada/s-pack49.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack49.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack49.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack49.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_49 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_49 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_49 --\n    ------------\n \n-   function Get_49 (Arr : System.Address; N : Natural) return Bits_49 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_49\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_49\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_49;\n \n    ------------\n    -- Set_49 --\n    ------------\n \n-   procedure Set_49 (Arr : System.Address; N : Natural; E : Bits_49) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_49\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_49;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_49;\n \n end System.Pack_49;"}, {"sha": "649e550231388fc4d2a9819aed2aa8052b70db74", "filename": "gcc/ada/s-pack49.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack49.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack49.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack49.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_49 is\n    type Bits_49 is mod 2 ** Bits;\n    for Bits_49'Size use Bits;\n \n-   function Get_49 (Arr : System.Address; N : Natural) return Bits_49;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_49\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_49 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_49 (Arr : System.Address; N : Natural; E : Bits_49);\n+   procedure Set_49\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_49;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "7cc04e69dacbd5cd53b73a9bc520585e798faa6b", "filename": "gcc/ada/s-pack50.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack50.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack50.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack50.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_50 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_50 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_50 or SetU_50 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_50 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_50 --\n    ------------\n \n-   function Get_50 (Arr : System.Address; N : Natural) return Bits_50 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_50\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_50\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_50;\n \n    -------------\n    -- GetU_50 --\n    -------------\n \n-   function GetU_50 (Arr : System.Address; N : Natural) return Bits_50 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_50\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_50\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_50;\n \n    ------------\n    -- Set_50 --\n    ------------\n \n-   procedure Set_50 (Arr : System.Address; N : Natural; E : Bits_50) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_50\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_50;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_50;\n \n    -------------\n    -- SetU_50 --\n    -------------\n \n-   procedure SetU_50 (Arr : System.Address; N : Natural; E : Bits_50) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_50\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_50;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_50;\n \n end System.Pack_50;"}, {"sha": "699165b49a7dec6328dbfcfcfdae6387fc0c612e", "filename": "gcc/ada/s-pack50.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack50.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack50.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack50.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_50 is\n    type Bits_50 is mod 2 ** Bits;\n    for Bits_50'Size use Bits;\n \n-   function Get_50 (Arr : System.Address; N : Natural) return Bits_50;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_50\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_50 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_50 (Arr : System.Address; N : Natural; E : Bits_50);\n+   procedure Set_50\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_50;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_50 (Arr : System.Address; N : Natural) return Bits_50;\n+   function GetU_50\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_50 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_50 (Arr : System.Address; N : Natural; E : Bits_50);\n+   procedure SetU_50\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_50;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "5617a983ae7302b374dd8d616bde159b8bf923f4", "filename": "gcc/ada/s-pack51.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack51.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack51.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack51.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_51 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_51 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_51 --\n    ------------\n \n-   function Get_51 (Arr : System.Address; N : Natural) return Bits_51 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_51\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_51\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_51;\n \n    ------------\n    -- Set_51 --\n    ------------\n \n-   procedure Set_51 (Arr : System.Address; N : Natural; E : Bits_51) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_51\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_51;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_51;\n \n end System.Pack_51;"}, {"sha": "99bdd51226703d36bdb6e1dfaa86304fcaa7c8a6", "filename": "gcc/ada/s-pack51.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack51.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack51.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack51.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_51 is\n    type Bits_51 is mod 2 ** Bits;\n    for Bits_51'Size use Bits;\n \n-   function Get_51 (Arr : System.Address; N : Natural) return Bits_51;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_51\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_51 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_51 (Arr : System.Address; N : Natural; E : Bits_51);\n+   procedure Set_51\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_51;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "5adf132af9e4444303fe23f0419069c6706bb6f3", "filename": "gcc/ada/s-pack52.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack52.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack52.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack52.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_52 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_52 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_52 or SetU_52 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_52 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_52 --\n    ------------\n \n-   function Get_52 (Arr : System.Address; N : Natural) return Bits_52 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_52\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_52\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_52;\n \n    -------------\n    -- GetU_52 --\n    -------------\n \n-   function GetU_52 (Arr : System.Address; N : Natural) return Bits_52 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_52\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_52\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_52;\n \n    ------------\n    -- Set_52 --\n    ------------\n \n-   procedure Set_52 (Arr : System.Address; N : Natural; E : Bits_52) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_52\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_52;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_52;\n \n    -------------\n    -- SetU_52 --\n    -------------\n \n-   procedure SetU_52 (Arr : System.Address; N : Natural; E : Bits_52) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_52\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_52;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_52;\n \n end System.Pack_52;"}, {"sha": "fab35eecc5d29db25a5ad17c54a74202dc9040a5", "filename": "gcc/ada/s-pack52.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack52.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack52.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack52.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_52 is\n    type Bits_52 is mod 2 ** Bits;\n    for Bits_52'Size use Bits;\n \n-   function Get_52 (Arr : System.Address; N : Natural) return Bits_52;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_52\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_52 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_52 (Arr : System.Address; N : Natural; E : Bits_52);\n+   procedure Set_52\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_52;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_52 (Arr : System.Address; N : Natural) return Bits_52;\n+   function GetU_52\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_52 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_52 (Arr : System.Address; N : Natural; E : Bits_52);\n+   procedure SetU_52\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_52;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "471d1fc1c2c3bd334c1279b9a32632a897145fe8", "filename": "gcc/ada/s-pack53.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack53.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack53.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack53.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_53 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_53 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_53 --\n    ------------\n \n-   function Get_53 (Arr : System.Address; N : Natural) return Bits_53 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_53\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_53\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_53;\n \n    ------------\n    -- Set_53 --\n    ------------\n \n-   procedure Set_53 (Arr : System.Address; N : Natural; E : Bits_53) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_53\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_53;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_53;\n \n end System.Pack_53;"}, {"sha": "380278c2eefd9f8c3d62d868db484988299a8b3f", "filename": "gcc/ada/s-pack53.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack53.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack53.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack53.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_53 is\n    type Bits_53 is mod 2 ** Bits;\n    for Bits_53'Size use Bits;\n \n-   function Get_53 (Arr : System.Address; N : Natural) return Bits_53;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_53\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_53 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_53 (Arr : System.Address; N : Natural; E : Bits_53);\n+   procedure Set_53\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_53;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "5d0294178e7079bc65da62e53bb321e2d3d2ab6c", "filename": "gcc/ada/s-pack54.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack54.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack54.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack54.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_54 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_54 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_54 or SetU_54 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_54 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_54 --\n    ------------\n \n-   function Get_54 (Arr : System.Address; N : Natural) return Bits_54 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_54\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_54\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_54;\n \n    -------------\n    -- GetU_54 --\n    -------------\n \n-   function GetU_54 (Arr : System.Address; N : Natural) return Bits_54 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_54\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_54\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_54;\n \n    ------------\n    -- Set_54 --\n    ------------\n \n-   procedure Set_54 (Arr : System.Address; N : Natural; E : Bits_54) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_54\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_54;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_54;\n \n    -------------\n    -- SetU_54 --\n    -------------\n \n-   procedure SetU_54 (Arr : System.Address; N : Natural; E : Bits_54) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_54\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_54;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_54;\n \n end System.Pack_54;"}, {"sha": "5ee9a88667835d80515a10427d2de6c65e6b5008", "filename": "gcc/ada/s-pack54.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack54.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack54.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack54.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_54 is\n    type Bits_54 is mod 2 ** Bits;\n    for Bits_54'Size use Bits;\n \n-   function Get_54 (Arr : System.Address; N : Natural) return Bits_54;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_54\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_54 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_54 (Arr : System.Address; N : Natural; E : Bits_54);\n+   procedure Set_54\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_54;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_54 (Arr : System.Address; N : Natural) return Bits_54;\n+   function GetU_54\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_54 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_54 (Arr : System.Address; N : Natural; E : Bits_54);\n+   procedure SetU_54\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_54;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "be264e1318f22af3867320cd52945fe06574c705", "filename": "gcc/ada/s-pack55.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack55.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack55.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack55.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_55 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_55 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_55 --\n    ------------\n \n-   function Get_55 (Arr : System.Address; N : Natural) return Bits_55 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_55\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_55\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_55;\n \n    ------------\n    -- Set_55 --\n    ------------\n \n-   procedure Set_55 (Arr : System.Address; N : Natural; E : Bits_55) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_55\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_55;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_55;\n \n end System.Pack_55;"}, {"sha": "8dce9fa71417d609781fd4e5b43e55a0aa596e05", "filename": "gcc/ada/s-pack55.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack55.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack55.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack55.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_55 is\n    type Bits_55 is mod 2 ** Bits;\n    for Bits_55'Size use Bits;\n \n-   function Get_55 (Arr : System.Address; N : Natural) return Bits_55;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_55\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_55 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_55 (Arr : System.Address; N : Natural; E : Bits_55);\n+   procedure Set_55\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_55;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "fd34211bf37bea93b9c4fd568099f870f3744cbb", "filename": "gcc/ada/s-pack56.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack56.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack56.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack56.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_56 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_56 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_56 or SetU_56 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_56 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_56 --\n    ------------\n \n-   function Get_56 (Arr : System.Address; N : Natural) return Bits_56 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_56\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_56\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_56;\n \n    -------------\n    -- GetU_56 --\n    -------------\n \n-   function GetU_56 (Arr : System.Address; N : Natural) return Bits_56 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_56\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_56\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_56;\n \n    ------------\n    -- Set_56 --\n    ------------\n \n-   procedure Set_56 (Arr : System.Address; N : Natural; E : Bits_56) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_56\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_56;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_56;\n \n    -------------\n    -- SetU_56 --\n    -------------\n \n-   procedure SetU_56 (Arr : System.Address; N : Natural; E : Bits_56) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_56\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_56;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_56;\n \n end System.Pack_56;"}, {"sha": "5e6578bb50c187d477613141ef122849f12dcb6f", "filename": "gcc/ada/s-pack56.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack56.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack56.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack56.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_56 is\n    type Bits_56 is mod 2 ** Bits;\n    for Bits_56'Size use Bits;\n \n-   function Get_56 (Arr : System.Address; N : Natural) return Bits_56;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_56\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_56 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_56 (Arr : System.Address; N : Natural; E : Bits_56);\n+   procedure Set_56\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_56;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_56 (Arr : System.Address; N : Natural) return Bits_56;\n+   function GetU_56\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_56 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_56 (Arr : System.Address; N : Natural; E : Bits_56);\n+   procedure SetU_56\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_56;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "b477b2e558922f09c1dcb2495c490221d7402458", "filename": "gcc/ada/s-pack57.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack57.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack57.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack57.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_57 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_57 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_57 --\n    ------------\n \n-   function Get_57 (Arr : System.Address; N : Natural) return Bits_57 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_57\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_57\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_57;\n \n    ------------\n    -- Set_57 --\n    ------------\n \n-   procedure Set_57 (Arr : System.Address; N : Natural; E : Bits_57) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_57\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_57;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_57;\n \n end System.Pack_57;"}, {"sha": "aff3c500c338b3d1137229bca9dd3251774c3f7f", "filename": "gcc/ada/s-pack57.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack57.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack57.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack57.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_57 is\n    type Bits_57 is mod 2 ** Bits;\n    for Bits_57'Size use Bits;\n \n-   function Get_57 (Arr : System.Address; N : Natural) return Bits_57;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_57\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_57 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_57 (Arr : System.Address; N : Natural; E : Bits_57);\n+   procedure Set_57\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_57;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "1aeb45003fe93bd68105fad0107e18a37329cff6", "filename": "gcc/ada/s-pack58.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack58.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack58.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack58.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_58 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_58 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_58 or SetU_58 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_58 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_58 --\n    ------------\n \n-   function Get_58 (Arr : System.Address; N : Natural) return Bits_58 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_58\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_58\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_58;\n \n    -------------\n    -- GetU_58 --\n    -------------\n \n-   function GetU_58 (Arr : System.Address; N : Natural) return Bits_58 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_58\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_58\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_58;\n \n    ------------\n    -- Set_58 --\n    ------------\n \n-   procedure Set_58 (Arr : System.Address; N : Natural; E : Bits_58) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_58\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_58;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_58;\n \n    -------------\n    -- SetU_58 --\n    -------------\n \n-   procedure SetU_58 (Arr : System.Address; N : Natural; E : Bits_58) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_58\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_58;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_58;\n \n end System.Pack_58;"}, {"sha": "503d990e0e9aaf0b7bb0e1994473f3ad2bc83c2a", "filename": "gcc/ada/s-pack58.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack58.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack58.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack58.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_58 is\n    type Bits_58 is mod 2 ** Bits;\n    for Bits_58'Size use Bits;\n \n-   function Get_58 (Arr : System.Address; N : Natural) return Bits_58;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_58\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_58 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_58 (Arr : System.Address; N : Natural; E : Bits_58);\n+   procedure Set_58\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_58;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_58 (Arr : System.Address; N : Natural) return Bits_58;\n+   function GetU_58\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_58 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_58 (Arr : System.Address; N : Natural; E : Bits_58);\n+   procedure SetU_58\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_58;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "35199ce47bdaded0e8d5d89eafc3a0d74a47563d", "filename": "gcc/ada/s-pack59.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack59.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack59.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack59.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_59 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_59 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_59 --\n    ------------\n \n-   function Get_59 (Arr : System.Address; N : Natural) return Bits_59 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_59\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_59\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_59;\n \n    ------------\n    -- Set_59 --\n    ------------\n \n-   procedure Set_59 (Arr : System.Address; N : Natural; E : Bits_59) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_59\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_59;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_59;\n \n end System.Pack_59;"}, {"sha": "2abbbf2efc32741d68701877f1bb82cf35338bf6", "filename": "gcc/ada/s-pack59.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack59.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack59.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack59.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_59 is\n    type Bits_59 is mod 2 ** Bits;\n    for Bits_59'Size use Bits;\n \n-   function Get_59 (Arr : System.Address; N : Natural) return Bits_59;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_59\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_59 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_59 (Arr : System.Address; N : Natural; E : Bits_59);\n+   procedure Set_59\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_59;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "e909f71b6a96f6bbda3dd355f40a9bd1146c488c", "filename": "gcc/ada/s-pack60.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack60.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack60.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack60.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_60 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_60 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_60 or SetU_60 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_60 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_60 --\n    ------------\n \n-   function Get_60 (Arr : System.Address; N : Natural) return Bits_60 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_60\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_60\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_60;\n \n    -------------\n    -- GetU_60 --\n    -------------\n \n-   function GetU_60 (Arr : System.Address; N : Natural) return Bits_60 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_60\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_60\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_60;\n \n    ------------\n    -- Set_60 --\n    ------------\n \n-   procedure Set_60 (Arr : System.Address; N : Natural; E : Bits_60) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_60\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_60;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_60;\n \n    -------------\n    -- SetU_60 --\n    -------------\n \n-   procedure SetU_60 (Arr : System.Address; N : Natural; E : Bits_60) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_60\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_60;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_60;\n \n end System.Pack_60;"}, {"sha": "bc4886878ed9c43958e903c1161836ed9e677d23", "filename": "gcc/ada/s-pack60.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack60.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack60.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack60.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_60 is\n    type Bits_60 is mod 2 ** Bits;\n    for Bits_60'Size use Bits;\n \n-   function Get_60 (Arr : System.Address; N : Natural) return Bits_60;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_60\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_60 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_60 (Arr : System.Address; N : Natural; E : Bits_60);\n+   procedure Set_60\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_60;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_60 (Arr : System.Address; N : Natural) return Bits_60;\n+   function GetU_60\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_60 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_60 (Arr : System.Address; N : Natural; E : Bits_60);\n+   procedure SetU_60\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_60;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "cd29c81294d3761a7a045e48233e1e9f2d03808c", "filename": "gcc/ada/s-pack61.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack61.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack61.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack61.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_61 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_61 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_61 --\n    ------------\n \n-   function Get_61 (Arr : System.Address; N : Natural) return Bits_61 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_61\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_61\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_61;\n \n    ------------\n    -- Set_61 --\n    ------------\n \n-   procedure Set_61 (Arr : System.Address; N : Natural; E : Bits_61) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_61\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_61;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_61;\n \n end System.Pack_61;"}, {"sha": "ac309a230f8e831639ebaed7001d80333fbfd9d3", "filename": "gcc/ada/s-pack61.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack61.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack61.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack61.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_61 is\n    type Bits_61 is mod 2 ** Bits;\n    for Bits_61'Size use Bits;\n \n-   function Get_61 (Arr : System.Address; N : Natural) return Bits_61;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_61\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_61 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_61 (Arr : System.Address; N : Natural; E : Bits_61);\n+   procedure Set_61\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_61;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "b13754df5c739392ff7b30500eb3c26f1281d315", "filename": "gcc/ada/s-pack62.adb", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack62.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack62.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack62.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_62 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,8 +71,10 @@ package body System.Pack_62 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    --  The following declarations are for the case where the address\n    --  passed to GetU_62 or SetU_62 is not guaranteed to be aligned.\n@@ -81,83 +86,165 @@ package body System.Pack_62 is\n \n    type ClusterU_Ref is access ClusterU;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, ClusterU_Ref);\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n \n    ------------\n    -- Get_62 --\n    ------------\n \n-   function Get_62 (Arr : System.Address; N : Natural) return Bits_62 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_62\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_62\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_62;\n \n    -------------\n    -- GetU_62 --\n    -------------\n \n-   function GetU_62 (Arr : System.Address; N : Natural) return Bits_62 is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function GetU_62\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_62\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end GetU_62;\n \n    ------------\n    -- Set_62 --\n    ------------\n \n-   procedure Set_62 (Arr : System.Address; N : Natural; E : Bits_62) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_62\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_62;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_62;\n \n    -------------\n    -- SetU_62 --\n    -------------\n \n-   procedure SetU_62 (Arr : System.Address; N : Natural; E : Bits_62) is\n-      C : constant ClusterU_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure SetU_62\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_62;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end SetU_62;\n \n end System.Pack_62;"}, {"sha": "b8b19f4a4f14448bcca4732619f7d3b543821a41", "filename": "gcc/ada/s-pack62.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack62.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack62.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack62.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,20 +39,37 @@ package System.Pack_62 is\n    type Bits_62 is mod 2 ** Bits;\n    for Bits_62'Size use Bits;\n \n-   function Get_62 (Arr : System.Address; N : Natural) return Bits_62;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_62\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_62 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_62 (Arr : System.Address; N : Natural; E : Bits_62);\n+   procedure Set_62\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_62;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n \n-   function GetU_62 (Arr : System.Address; N : Natural) return Bits_62;\n+   function GetU_62\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_62 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned. This version\n    --  is used when Arr may represent an unaligned address.\n \n-   procedure SetU_62 (Arr : System.Address; N : Natural; E : Bits_62);\n+   procedure SetU_62\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_62;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value. This version\n    --  is used when Arr may represent an unaligned address"}, {"sha": "109f914b9b31968959e17ea1144d654177ecd5bc", "filename": "gcc/ada/s-pack63.adb", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack63.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack63.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack63.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,10 +31,13 @@\n \n with System.Storage_Elements;\n with System.Unsigned_Types;\n-with Ada.Unchecked_Conversion;\n \n package body System.Pack_63 is\n \n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n    subtype Ofs is System.Storage_Elements.Storage_Offset;\n    subtype Uns is System.Unsigned_Types.Unsigned;\n    subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n@@ -68,45 +71,87 @@ package body System.Pack_63 is\n \n    type Cluster_Ref is access Cluster;\n \n-   function To_Ref is new\n-     Ada.Unchecked_Conversion (System.Address, Cluster_Ref);\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n \n    ------------\n    -- Get_63 --\n    ------------\n \n-   function Get_63 (Arr : System.Address; N : Natural) return Bits_63 is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   function Get_63\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_63\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => return C.E0;\n-         when 1 => return C.E1;\n-         when 2 => return C.E2;\n-         when 3 => return C.E3;\n-         when 4 => return C.E4;\n-         when 5 => return C.E5;\n-         when 6 => return C.E6;\n-         when 7 => return C.E7;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n    end Get_63;\n \n    ------------\n    -- Set_63 --\n    ------------\n \n-   procedure Set_63 (Arr : System.Address; N : Natural; E : Bits_63) is\n-      C : constant Cluster_Ref := To_Ref (Arr + Bits * Ofs (Uns (N) / 8));\n+   procedure Set_63\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_63;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n    begin\n-      case N07 (Uns (N) mod 8) is\n-         when 0 => C.E0 := E;\n-         when 1 => C.E1 := E;\n-         when 2 => C.E2 := E;\n-         when 3 => C.E3 := E;\n-         when 4 => C.E4 := E;\n-         when 5 => C.E5 := E;\n-         when 6 => C.E6 := E;\n-         when 7 => C.E7 := E;\n-      end case;\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n    end Set_63;\n \n end System.Pack_63;"}, {"sha": "c59678b4cd4cffa6282b00840d75895fcfbb03f7", "filename": "gcc/ada/s-pack63.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack63.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fs-pack63.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pack63.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,11 +39,21 @@ package System.Pack_63 is\n    type Bits_63 is mod 2 ** Bits;\n    for Bits_63'Size use Bits;\n \n-   function Get_63 (Arr : System.Address; N : Natural) return Bits_63;\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_63\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_63 with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is extracted and returned.\n \n-   procedure Set_63 (Arr : System.Address; N : Natural; E : Bits_63);\n+   procedure Set_63\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_63;\n+      Rev_SSO : Boolean) with Inline;\n    --  Arr is the address of the packed array, N is the zero-based\n    --  subscript. This element is set to the given value.\n "}, {"sha": "85b119b1d82b8a61b9d2d04d161f944ef0be98a0", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -3521,7 +3521,7 @@ package body Sem_Ch13 is\n       ------------------------------\n \n       procedure Check_Indexing_Functions is\n-         Indexing_Found : Boolean;\n+         Indexing_Found : Boolean := False;\n \n          procedure Check_One_Function (Subp : Entity_Id);\n          --  Check one possible interpretation. Sets Indexing_Found True if a"}, {"sha": "16dc5342c6fe60f84256a5f96d0831070c9f1268", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -10323,6 +10323,8 @@ package body Sem_Ch3 is\n \n    procedure Check_Initialization (T : Entity_Id; Exp : Node_Id) is\n    begin\n+      --  Special processing for limited types\n+\n       if Is_Limited_Type (T)\n         and then not In_Instance\n         and then not In_Inlined_Body\n@@ -10376,6 +10378,16 @@ package body Sem_Ch3 is\n             end if;\n          end if;\n       end if;\n+\n+      --  In gnatc or gnatprove mode, make sure set Do_Range_Check flag gets\n+      --  set unless we can be sure that no range check is required.\n+\n+      if (not Expander_Active and not GNATprove_Mode)\n+        and then Is_Scalar_Type (T)\n+        and then not Is_In_Range (Exp, T, Assume_Valid => True)\n+      then\n+         Set_Do_Range_Check (Exp);\n+      end if;\n    end Check_Initialization;\n \n    ----------------------\n@@ -18034,6 +18046,8 @@ package body Sem_Ch3 is\n          if Present (Expression (Discr)) then\n             Preanalyze_Spec_Expression (Expression (Discr), Discr_Type);\n \n+            --  Legaity checks\n+\n             if Nkind (N) = N_Formal_Type_Declaration then\n                Error_Msg_N\n                  (\"discriminant defaults not allowed for formal type\",\n@@ -18078,6 +18092,19 @@ package body Sem_Ch3 is\n                  (Defining_Identifier (Discr), Expression (Discr));\n             end if;\n \n+            --  In gnatc or gnatprove mode, make sure set Do_Range_Check flag\n+            --  gets set unless we can be sure that no range check is required.\n+\n+            if (not Expander_Active and not GNATprove_Mode)\n+              and then not\n+                Is_In_Range\n+                  (Expression (Discr), Discr_Type, Assume_Valid => True)\n+            then\n+               Set_Do_Range_Check (Expression (Discr));\n+            end if;\n+\n+         --  No default discriminant value given\n+\n          else\n             Default_Not_Present := True;\n          end if;"}, {"sha": "30bad6d42852af7d5b6f8e3281f90d97b9d6d6be", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -6079,9 +6079,18 @@ package body Sem_Eval is\n       --  to get the information in the variable case as well.\n \n    begin\n+      --  Expression that raises constraint error is an odd case. We certainly\n+      --  do not want to consider it to be in range. It might make sense to\n+      --  consider it always out of range, but this causes incorrect error\n+      --  messages about static expressions out of range. So we just return\n+      --  Unknown, which is always safe.\n+\n+      if Raises_Constraint_Error (N) then\n+         return Unknown;\n+\n       --  Universal types have no range limits, so always in range\n \n-      if Typ = Universal_Integer or else Typ = Universal_Real then\n+      elsif Typ = Universal_Integer or else Typ = Universal_Real then\n          return In_Range;\n \n       --  Never known if not scalar type. Don't know if this can actually\n@@ -6099,14 +6108,10 @@ package body Sem_Eval is\n       elsif Is_Generic_Type (Typ) then\n          return Unknown;\n \n-      --  Never known unless we have a compile time known value\n+      --  Case of a known compile time value, where we can check if it is in\n+      --  the bounds of the given type.\n \n-      elsif not Compile_Time_Known_Value (N) then\n-         return Unknown;\n-\n-      --  General processing with a known compile time value\n-\n-      else\n+      elsif Compile_Time_Known_Value (N) then\n          declare\n             Lo       : Node_Id;\n             Hi       : Node_Id;\n@@ -6172,6 +6177,20 @@ package body Sem_Eval is\n                end if;\n             end if;\n          end;\n+\n+      --  Here for value not known at compile time. Case of expression subtype\n+      --  is Typ or is a subtype of Typ, and we can assume expression is valid.\n+      --  In this case we know it is in range without knowing its value.\n+\n+      elsif Assume_Valid\n+        and then (Etype (N) = Typ or else Is_Subtype_Of (Etype (N), Typ))\n+      then\n+         return In_Range;\n+\n+      --  For all other cases, result is unknown\n+\n+      else\n+         return Unknown;\n       end if;\n    end Test_In_Range;\n "}, {"sha": "8921d6570937a1beb76b6686475c90c2bc911571", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b53649518674605dd757f4089c8a522e4272273/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=7b53649518674605dd757f4089c8a522e4272273", "patch": "@@ -1061,7 +1061,9 @@ package Sinfo is\n    --      Initialization expression for the initial value in an object\n    --      declaration. In this case the Do_Range_Check flag is set on\n    --      the initialization expression, and the check is against the\n-   --      range of the type of the object being declared.\n+   --      range of the type of the object being declared. This includes the\n+   --      cases of expressions providing default discriminant values, and\n+   --      expressions used to initialize record components.\n \n    --      The expression of a type conversion. In this case the range check is\n    --      against the target type of the conversion. See also the use of"}]}