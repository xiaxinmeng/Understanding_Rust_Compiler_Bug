{"sha": "b48ccf0df63bb9f2ab8de12397e3e72676fa2624", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ4Y2NmMGRmNjNiYjlmMmFiOGRlMTIzOTdlM2U3MjY3NmZhMjYyNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-10-28T09:50:58Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-10-28T09:50:58Z"}, "message": "ipa-inline.c (edge_badness): Reduce precision; use scc hints.\n\n\n\t* ipa-inline.c (edge_badness): Reduce precision; use scc hints.\n\t(inline_small_functions): Fix dumps; update all callees after inlining.\n\t* ipa-inline.h (INLINE_HINT_in_scc, INLINE_HINT_same_scc): New constants.\n\t(inline summary): Add SCC_NO.\n\t* ipa-inline-analysis.c (dump_inline_hints): Dump SCC hints.\n\t(reset_inline_summary): Reset scc_no.\n\t(estimate_node_size_and_time): Set in_scc hint.\n\t(do_estimate_edge_time): Add same_scc hint.\n\t(do_estimate_edge_hints): Likewise.\n\nFrom-SVN: r192888", "tree": {"sha": "2dae795a33d41ca45ce797578c0fa418c47bf057", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2dae795a33d41ca45ce797578c0fa418c47bf057"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b48ccf0df63bb9f2ab8de12397e3e72676fa2624", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b48ccf0df63bb9f2ab8de12397e3e72676fa2624", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b48ccf0df63bb9f2ab8de12397e3e72676fa2624", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b48ccf0df63bb9f2ab8de12397e3e72676fa2624/comments", "author": null, "committer": null, "parents": [{"sha": "f457c50cd95684173f68fe0e7c1b14b2533a62b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f457c50cd95684173f68fe0e7c1b14b2533a62b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f457c50cd95684173f68fe0e7c1b14b2533a62b2"}], "stats": {"total": 74, "additions": 61, "deletions": 13}, "files": [{"sha": "1e6f1fd8d985960516ff5ebe461c992b7aa7015f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48ccf0df63bb9f2ab8de12397e3e72676fa2624/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48ccf0df63bb9f2ab8de12397e3e72676fa2624/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b48ccf0df63bb9f2ab8de12397e3e72676fa2624", "patch": "@@ -1,3 +1,15 @@\n+2012-10-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline.c (edge_badness): Reduce precision; use scc hints.\n+\t(inline_small_functions): Fix dumps; update all callees after inlining.\n+\t* ipa-inline.h (INLINE_HINT_in_scc, INLINE_HINT_same_scc): New constants.\n+\t(inline summary): Add SCC_NO.\n+\t* ipa-inline-analysis.c (dump_inline_hints): Dump SCC hints.\n+\t(reset_inline_summary): Reset scc_no.\n+\t(estimate_node_size_and_time): Set in_scc hint.\n+\t(do_estimate_edge_time): Add same_scc hint.\n+\t(do_estimate_edge_hints): Likewise.\n+\n 2012-10-28  Andreas Schwab  <schwab@linux-m68k.org>\n \n \t* doc/cppopts.texi: Fix use of @item vs. @itemx inside @table."}, {"sha": "8dd9c6927ed935a16b24ad44da4dc51eb42fe198", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48ccf0df63bb9f2ab8de12397e3e72676fa2624/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48ccf0df63bb9f2ab8de12397e3e72676fa2624/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=b48ccf0df63bb9f2ab8de12397e3e72676fa2624", "patch": "@@ -639,6 +639,16 @@ dump_inline_hints (FILE *f, inline_hints hints)\n       hints &= ~INLINE_HINT_loop_stride;\n       fprintf (f, \" loop_stride\");\n     }\n+  if (hints & INLINE_HINT_same_scc)\n+    {\n+      hints &= ~INLINE_HINT_same_scc;\n+      fprintf (f, \" same_scc\");\n+    }\n+  if (hints & INLINE_HINT_in_scc)\n+    {\n+      hints &= ~INLINE_HINT_in_scc;\n+      fprintf (f, \" in_scc\");\n+    }\n   gcc_assert (!hints);\n }\n \n@@ -973,6 +983,7 @@ reset_inline_summary (struct cgraph_node *node)\n   info->stack_frame_offset = 0;\n   info->size = 0;\n   info->time = 0;\n+  info->scc_no = 0;\n   if (info->loop_iterations)\n     {\n       pool_free (edge_predicate_pool, info->loop_iterations);\n@@ -2825,7 +2836,8 @@ estimate_node_size_and_time (struct cgraph_node *node,\n   if (info->loop_stride\n       && !evaluate_predicate (info->loop_stride, possible_truths))\n     hints |=INLINE_HINT_loop_stride;\n-\n+  if (info->scc_no)\n+    hints |= INLINE_HINT_in_scc;\n \n   estimate_calls_size_and_time (node, &size, &time, &hints, possible_truths,\n \t\t\t\tknown_vals, known_binfos, known_aggs);\n@@ -3323,6 +3335,9 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   /* When caching, update the cache entry.  */\n   if (edge_growth_cache)\n     {\n+      struct cgraph_node *to = (edge->caller->global.inlined_to\n+\t\t\t        ? edge->caller->global.inlined_to\n+\t\t\t\t: edge->caller);\n       if ((int)VEC_length (edge_growth_cache_entry, edge_growth_cache)\n \t  <= edge->uid)\n \tVEC_safe_grow_cleared (edge_growth_cache_entry, heap, edge_growth_cache,\n@@ -3332,6 +3347,9 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n \n       VEC_index (edge_growth_cache_entry, edge_growth_cache, edge->uid).size\n \t= size + (size >= 0);\n+      if (inline_summary (to)->scc_no\n+\t  && inline_summary (to)->scc_no == inline_summary (callee)->scc_no)\n+\thints |= INLINE_HINT_same_scc;\n       VEC_index (edge_growth_cache_entry, edge_growth_cache, edge->uid).hints\n \t= hints + 1;\n     }\n@@ -3392,6 +3410,9 @@ do_estimate_edge_hints (struct cgraph_edge *edge)\n   VEC (tree, heap) *known_vals;\n   VEC (tree, heap) *known_binfos;\n   VEC (ipa_agg_jump_function_p, heap) *known_aggs;\n+  struct cgraph_node *to = (edge->caller->global.inlined_to\n+\t\t            ? edge->caller->global.inlined_to\n+\t\t\t    : edge->caller);\n \n   /* When we do caching, use do_estimate_edge_time to populate the entry.  */\n \n@@ -3417,6 +3438,9 @@ do_estimate_edge_hints (struct cgraph_edge *edge)\n   VEC_free (tree, heap, known_vals);\n   VEC_free (tree, heap, known_binfos);\n   VEC_free (ipa_agg_jump_function_p, heap, known_aggs);\n+  if (inline_summary (to)->scc_no\n+      && inline_summary (to)->scc_no == inline_summary (callee)->scc_no)\n+    hints |= INLINE_HINT_same_scc;\n   return hints;\n }\n "}, {"sha": "227941af8a7cdd51f4f490fcae8a2b07e8dccf51", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48ccf0df63bb9f2ab8de12397e3e72676fa2624/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48ccf0df63bb9f2ab8de12397e3e72676fa2624/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=b48ccf0df63bb9f2ab8de12397e3e72676fa2624", "patch": "@@ -845,8 +845,8 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t precision for small bandesses (those are interesting) yet we don't\n \t overflow for growths that are still in interesting range.\n \n-\t Fixed point arithmetic with point at 8th bit. */\n-      badness = ((gcov_type)growth) * (1<<(19+8));\n+\t Fixed point arithmetic with point at 6th bit. */\n+      badness = ((gcov_type)growth) * (1<<(19+6));\n       badness = (badness + div / 2) / div;\n \n       /* Overall growth of inlining all calls of function matters: we want to\n@@ -861,16 +861,20 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t We might mix the valud into the fraction by taking into account\n \t relative growth of the unit, but for now just add the number\n \t into resulting fraction.  */\n-      if (badness > INT_MAX / 2)\n+      if (badness > INT_MAX / 4)\n \t{\n-\t  badness = INT_MAX / 2;\n+\t  badness = INT_MAX / 4;\n \t  if (dump)\n \t    fprintf (dump_file, \"Badness overflow\\n\");\n \t}\n       if (hints & (INLINE_HINT_indirect_call\n \t\t   | INLINE_HINT_loop_iterations\n \t\t   | INLINE_HINT_loop_stride))\n \tbadness /= 8;\n+      if (hints & (INLINE_HINT_same_scc))\n+\tbadness *= 4;\n+      if (hints & (INLINE_HINT_in_scc))\n+\tbadness *= 2;\n       if (dump)\n \t{\n \t  fprintf (dump_file,\n@@ -1337,16 +1341,10 @@ inline_small_functions (void)\n   if (flag_indirect_inlining)\n     new_indirect_edges = VEC_alloc (cgraph_edge_p, heap, 8);\n \n-  if (dump_file)\n-    fprintf (dump_file,\n-\t     \"\\nDeciding on inlining of small functions.  Starting with size %i.\\n\",\n-\t     initial_size);\n-\n   /* Compute overall unit size and other global parameters used by badness\n      metrics.  */\n \n   max_count = 0;\n-  initialize_growth_caches ();\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (!node->global.inlined_to)\n@@ -1355,15 +1353,25 @@ inline_small_functions (void)\n \t    || node->thunk.thunk_p)\n \t  {\n \t    struct inline_summary *info = inline_summary (node);\n+\t    struct ipa_dfs_info *dfs = (struct ipa_dfs_info *) node->symbol.aux;\n \n \t    if (!DECL_EXTERNAL (node->symbol.decl))\n \t      initial_size += info->size;\n+\t    info->scc_no = (dfs && dfs->next_cycle && dfs->next_cycle != node\n+\t\t\t    ? dfs->scc_no + 1 : 0);\n \t  }\n \n \tfor (edge = node->callers; edge; edge = edge->next_caller)\n \t  if (max_count < edge->count)\n \t    max_count = edge->count;\n       }\n+  ipa_free_postorder_info ();\n+  initialize_growth_caches ();\n+\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"\\nDeciding on inlining of small functions.  Starting with size %i.\\n\",\n+\t     initial_size);\n \n   overall_size = initial_size;\n   max_size = compute_max_insns (overall_size);\n@@ -1528,7 +1536,7 @@ inline_small_functions (void)\n \t  reset_edge_caches (edge->callee);\n           reset_node_growth_cache (callee);\n \n-\t  update_callee_keys (edge_heap, edge->callee, updated_nodes);\n+\t  update_callee_keys (edge_heap, where, updated_nodes);\n \t}\n       where = edge->caller;\n       if (where->global.inlined_to)"}, {"sha": "ca59a7f70998ebb7258178e1257c4af7acdb0aa7", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48ccf0df63bb9f2ab8de12397e3e72676fa2624/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48ccf0df63bb9f2ab8de12397e3e72676fa2624/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=b48ccf0df63bb9f2ab8de12397e3e72676fa2624", "patch": "@@ -47,7 +47,9 @@ typedef struct GTY(()) condition\n enum inline_hints_vals {\n   INLINE_HINT_indirect_call = 1,\n   INLINE_HINT_loop_iterations = 2,\n-  INLINE_HINT_loop_stride = 4\n+  INLINE_HINT_loop_stride = 4,\n+  INLINE_HINT_same_scc = 8,\n+  INLINE_HINT_in_scc = 16\n };\n typedef int inline_hints;\n \n@@ -127,6 +129,8 @@ struct GTY(()) inline_summary\n   /* Predicate on when some loop in the function becomes to have known\n      stride.   */\n   struct predicate * GTY((skip)) loop_stride;\n+  /* Number of SCC on the beggining of inlining process.  */\n+  int scc_no;\n };\n \n "}]}