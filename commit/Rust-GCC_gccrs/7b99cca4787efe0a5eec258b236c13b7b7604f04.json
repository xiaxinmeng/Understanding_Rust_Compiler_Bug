{"sha": "7b99cca4787efe0a5eec258b236c13b7b7604f04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I5OWNjYTQ3ODdlZmUwYTVlZWMyNThiMjM2YzEzYjdiNzYwNGYwNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-09-09T12:31:32Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-09-09T12:31:32Z"}, "message": "Replace cgraph_node_set and varpool_node_set by symtab_node_encoder in partitioning.\n\n\n\n\tReplace cgraph_node_set and varpool_node_set by symtab_node_encoder\n\tin partitioning.\n\t* tree-pass.h (cgraph_node_set_def, varpool_node_set_def): Remove\n\tforward declaration.\n\t(lto_symtab_encoder_d): Forward declare.\n\t(ipa_write_optimization_summaries): Update.\n\t* lto-cgraph.c (lto_symtab_encoder_new): Do not initialize\n\tbody, initializer and in_partition.\n\t(lto_symtab_encoder_delete): Update.\n\t(lto_symtab_encoder_encode): Update.\n\t(lto_symtab_encoder_lookup): Move inline.\n\t(lto_symtab_encoder_delete_node): New function.\n\t(lto_symtab_encoder_encode_body_p, lto_set_symtab_encoder_encode_body,\n\tlto_symtab_encoder_encode_initializer_p,\n\tlto_set_symtab_encoder_encode_initializer, lto_symtab_encoder_in_partition_p,\n\tlto_symtab_encoder_in_partition_p): Update.\n\t(compute_ltrans_boundary): Take encoder as an input.\n\t* passes.c (ipa_write_summaries_1): Update.\n\t(ipa_write_summaries_1): Update.\n\t(ipa_write_summaries): Update.\n\t(ipa_write_optimization_summaries): Update.\n\t* lto-streamer.c (print_lto_report): Report number of cgraph nodes.\n\t* lto-streamer.h (lto_stats_d): Replace num_output_cgraph_nodes by\n\tnum_output_symtab_nodes.\n\t(lto_encoder_entry): New structure.\n\t(struct lto_symtab_encoder_d): Reorg.\n\t(lto_symtab_encoder_delete_node): Declare.\n\t(lto_symtab_encoder_lookup): Bring inline.\n\t(compute_ltrans_boundary): Update.\n\t(lto_symtab_encoder_size): Update.\n\t(lsei_node, lsei_cgraph_node, lsei_varpool_node): Update.\n\t(lto_symtab_encoder_deref): Update.\n\n\tReplace cgraph_node_set and varpool_node_set by symtab_node_encoder\n\tin partitioning.\n\t* lto-partition.h (ltrans_partition_def): Replace cgraph_set and varpool_set\n\tby encoder.\n\t* lto-partition.c (new_partition): Update.\n\t* lto.c (cmp_partitions_order): Update.\n\t(lto_wpa_write_files): Update.\n\t(free_ltrans_partitions): Update.\n\t(add_references_to_partition): Update.\n\t(add_cgraph_node_to_partition_1): Update.\n\t(add_cgraph_node_to_partition): Update.\n\t(add_varpool_node_to_partition): Update.\n\t(undo_partition): Update.\n\t(lto_balanced_map): Update.\n\t(set_referenced_from_other_partition_p, set_reachable_from_other_partition_p,\n\tset_referenced_from_this_partition_p): Update.\n\t(lto_promote_cross_file_statics): Update.\n\nFrom-SVN: r191107", "tree": {"sha": "58bcd25939fd842f2d2ab057e27eab3107a48c31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58bcd25939fd842f2d2ab057e27eab3107a48c31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b99cca4787efe0a5eec258b236c13b7b7604f04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b99cca4787efe0a5eec258b236c13b7b7604f04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b99cca4787efe0a5eec258b236c13b7b7604f04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b99cca4787efe0a5eec258b236c13b7b7604f04/comments", "author": null, "committer": null, "parents": [{"sha": "d5f8c6dc8cb56bb0536d81a3916639d3fdd1481b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5f8c6dc8cb56bb0536d81a3916639d3fdd1481b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5f8c6dc8cb56bb0536d81a3916639d3fdd1481b"}], "stats": {"total": 632, "additions": 318, "deletions": 314}, "files": [{"sha": "8f763ab3c66a1499e5f365a65877bd66616ff70a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b99cca4787efe0a5eec258b236c13b7b7604f04/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b99cca4787efe0a5eec258b236c13b7b7604f04/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b99cca4787efe0a5eec258b236c13b7b7604f04", "patch": "@@ -1,3 +1,38 @@\n+2012-09-08  Jan Hubicka  <jh@suse.cz>\n+\n+\tReplace cgraph_node_set and varpool_node_set by symtab_node_encoder\n+\tin partitioning.\n+\t* tree-pass.h (cgraph_node_set_def, varpool_node_set_def): Remove\n+\tforward declaration.\n+\t(lto_symtab_encoder_d): Forward declare.\n+\t(ipa_write_optimization_summaries): Update.\n+\t* lto-cgraph.c (lto_symtab_encoder_new): Do not initialize\n+\tbody, initializer and in_partition.\n+\t(lto_symtab_encoder_delete): Update.\n+\t(lto_symtab_encoder_encode): Update.\n+\t(lto_symtab_encoder_lookup): Move inline.\n+\t(lto_symtab_encoder_delete_node): New function.\n+\t(lto_symtab_encoder_encode_body_p, lto_set_symtab_encoder_encode_body,\n+\tlto_symtab_encoder_encode_initializer_p,\n+\tlto_set_symtab_encoder_encode_initializer, lto_symtab_encoder_in_partition_p,\n+\tlto_symtab_encoder_in_partition_p): Update.\n+\t(compute_ltrans_boundary): Take encoder as an input.\n+\t* passes.c (ipa_write_summaries_1): Update.\n+\t(ipa_write_summaries_1): Update.\n+\t(ipa_write_summaries): Update.\n+\t(ipa_write_optimization_summaries): Update.\n+\t* lto-streamer.c (print_lto_report): Report number of cgraph nodes.\n+\t* lto-streamer.h (lto_stats_d): Replace num_output_cgraph_nodes by\n+\tnum_output_symtab_nodes.\n+\t(lto_encoder_entry): New structure.\n+\t(struct lto_symtab_encoder_d): Reorg.\n+\t(lto_symtab_encoder_delete_node): Declare.\n+\t(lto_symtab_encoder_lookup): Bring inline.\n+\t(compute_ltrans_boundary): Update.\n+\t(lto_symtab_encoder_size): Update.\n+\t(lsei_node, lsei_cgraph_node, lsei_varpool_node): Update.\n+\t(lto_symtab_encoder_deref): Update.\n+\n 2012-09-08  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* config/pa/pa.c (hppa_rtx_costs): Update costs for large integer modes."}, {"sha": "0281cdb42bccb1fb5859ace8a55913a1c3b2179e", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 76, "deletions": 39, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b99cca4787efe0a5eec258b236c13b7b7604f04/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b99cca4787efe0a5eec258b236c13b7b7604f04/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=7b99cca4787efe0a5eec258b236c13b7b7604f04", "patch": "@@ -80,9 +80,6 @@ lto_symtab_encoder_new (void)\n   lto_symtab_encoder_t encoder = XCNEW (struct lto_symtab_encoder_d);\n   encoder->map = pointer_map_create ();\n   encoder->nodes = NULL;\n-  encoder->body = pointer_set_create ();\n-  encoder->initializer = pointer_set_create ();\n-  encoder->in_partition = pointer_set_create ();\n   return encoder;\n }\n \n@@ -92,11 +89,8 @@ lto_symtab_encoder_new (void)\n void\n lto_symtab_encoder_delete (lto_symtab_encoder_t encoder)\n {\n-   VEC_free (symtab_node, heap, encoder->nodes);\n+   VEC_free (lto_encoder_entry, heap, encoder->nodes);\n    pointer_map_destroy (encoder->map);\n-   pointer_set_destroy (encoder->body);\n-   pointer_set_destroy (encoder->initializer);\n-   pointer_set_destroy (encoder->in_partition);\n    free (encoder);\n }\n \n@@ -113,29 +107,57 @@ lto_symtab_encoder_encode (lto_symtab_encoder_t encoder,\n   void **slot;\n \n   slot = pointer_map_contains (encoder->map, node);\n-  if (!slot)\n+  if (!slot || !*slot)\n     {\n-      ref = VEC_length (symtab_node, encoder->nodes);\n-      slot = pointer_map_insert (encoder->map, node);\n-      *slot = (void *) (intptr_t) ref;\n-      VEC_safe_push (symtab_node, heap, encoder->nodes, node);\n+      lto_encoder_entry entry = {node, false, false, false};\n+      ref = VEC_length (lto_encoder_entry, encoder->nodes);\n+      if (!slot)\n+        slot = pointer_map_insert (encoder->map, node);\n+      *slot = (void *) (intptr_t) (ref + 1);\n+      VEC_safe_push (lto_encoder_entry, heap, encoder->nodes, &entry);\n     }\n   else\n-    ref = (int) (intptr_t) *slot;\n+    ref = (size_t) *slot - 1;\n \n   return ref;\n }\n \n+/* Remove NODE from encoder.  */\n \n-/* Look up NODE in encoder.  Return NODE's reference if it has been encoded\n-   or LCC_NOT_FOUND if it is not there.  */\n-\n-int\n-lto_symtab_encoder_lookup (lto_symtab_encoder_t encoder,\n-\t\t\t   symtab_node node)\n+bool\n+lto_symtab_encoder_delete_node (lto_symtab_encoder_t encoder,\n+\t\t\t        symtab_node node)\n {\n-  void **slot = pointer_map_contains (encoder->map, node);\n-  return (slot ? (int) (intptr_t) *slot : LCC_NOT_FOUND);\n+  void **slot, **last_slot;\n+  int index;\n+  lto_encoder_entry last_node;\n+\n+  slot = pointer_map_contains (encoder->map, node);\n+  if (slot == NULL || !*slot)\n+    return false;\n+\n+  index = (size_t) *slot - 1;\n+  gcc_checking_assert (VEC_index (lto_encoder_entry,\n+\t\t\t\t  encoder->nodes, index).node\n+\t      \t       == node);\n+\n+  /* Remove from vector. We do this by swapping node with the last element\n+     of the vector.  */\n+  last_node = VEC_pop (lto_encoder_entry, encoder->nodes);\n+  if (last_node.node != node)\n+    {\n+      last_slot = pointer_map_contains (encoder->map, last_node.node);\n+      gcc_checking_assert (last_slot && *last_slot);\n+      *last_slot = (void *)(size_t) (index + 1);\n+\n+      /* Move the last element to the original spot of NODE.  */\n+      VEC_replace (lto_encoder_entry, encoder->nodes, index,\n+\t\t   last_node);\n+    }\n+\n+  /* Remove element from hash table.  */\n+  *slot = NULL;\n+  return true;\n }\n \n \n@@ -145,7 +167,8 @@ bool\n lto_symtab_encoder_encode_body_p (lto_symtab_encoder_t encoder,\n \t\t\t\t  struct cgraph_node *node)\n {\n-  return pointer_set_contains (encoder->body, node);\n+  int index = lto_symtab_encoder_lookup (encoder, (symtab_node)node);\n+  return VEC_index (lto_encoder_entry, encoder->nodes, index).body;\n }\n \n /* Return TRUE if we should encode body of NODE (if any).  */\n@@ -154,7 +177,10 @@ static void\n lto_set_symtab_encoder_encode_body (lto_symtab_encoder_t encoder,\n \t\t\t\t    struct cgraph_node *node)\n {\n-  pointer_set_insert (encoder->body, node);\n+  int index = lto_symtab_encoder_encode (encoder, (symtab_node)node);\n+  gcc_checking_assert (VEC_index (lto_encoder_entry, encoder->nodes,\n+\t\t\t\t  index).node == (symtab_node)node);\n+  VEC_index (lto_encoder_entry, encoder->nodes, index).body = true;\n }\n \n /* Return TRUE if we should encode initializer of NODE (if any).  */\n@@ -163,7 +189,10 @@ bool\n lto_symtab_encoder_encode_initializer_p (lto_symtab_encoder_t encoder,\n \t\t\t\t\t struct varpool_node *node)\n {\n-  return pointer_set_contains (encoder->initializer, node);\n+  int index = lto_symtab_encoder_lookup (encoder, (symtab_node)node);\n+  if (index == LCC_NOT_FOUND)\n+    return false;\n+  return VEC_index (lto_encoder_entry, encoder->nodes, index).initializer;\n }\n \n /* Return TRUE if we should encode initializer of NODE (if any).  */\n@@ -172,7 +201,8 @@ static void\n lto_set_symtab_encoder_encode_initializer (lto_symtab_encoder_t encoder,\n \t\t\t\t\t   struct varpool_node *node)\n {\n-  pointer_set_insert (encoder->initializer, node);\n+  int index = lto_symtab_encoder_lookup (encoder, (symtab_node)node);\n+  VEC_index (lto_encoder_entry, encoder->nodes, index).initializer = true;\n }\n \n /* Return TRUE if we should encode initializer of NODE (if any).  */\n@@ -181,7 +211,10 @@ bool\n lto_symtab_encoder_in_partition_p (lto_symtab_encoder_t encoder,\n \t\t\t\t   symtab_node node)\n {\n-  return pointer_set_contains (encoder->in_partition, node);\n+  int index = lto_symtab_encoder_lookup (encoder, (symtab_node)node);\n+  if (index == LCC_NOT_FOUND)\n+    return false;\n+  return VEC_index (lto_encoder_entry, encoder->nodes, index).in_partition;\n }\n \n /* Return TRUE if we should encode body of NODE (if any).  */\n@@ -190,8 +223,8 @@ void\n lto_set_symtab_encoder_in_partition (lto_symtab_encoder_t encoder,\n \t\t\t\t     symtab_node node)\n {\n-  lto_symtab_encoder_encode (encoder, (symtab_node)node);\n-  pointer_set_insert (encoder->in_partition, node);\n+  int index = lto_symtab_encoder_encode (encoder, (symtab_node)node);\n+  VEC_index (lto_encoder_entry, encoder->nodes, index).in_partition = true;\n }\n \n /* Output the cgraph EDGE to OB using ENCODER.  */\n@@ -645,28 +678,31 @@ output_refs (lto_symtab_encoder_t encoder)\n    and insert them to encoders.  */\n void\n compute_ltrans_boundary (struct lto_out_decl_state *state,\n-\t\t\t cgraph_node_set set, varpool_node_set vset)\n+\t\t\t lto_symtab_encoder_t in_encoder)\n {\n   struct cgraph_node *node;\n-  cgraph_node_set_iterator csi;\n-  varpool_node_set_iterator vsi;\n   struct cgraph_edge *edge;\n   int i;\n   lto_symtab_encoder_t encoder;\n+  lto_symtab_encoder_iterator lsei;\n \n   encoder = state->symtab_node_encoder = lto_symtab_encoder_new ();\n \n-  /* Go over all the nodes in SET and assign references.  */\n-  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+  /* Go over all entries in the IN_ENCODER and duplicate them to\n+     ENCODER. At the same time insert masters of clones so\n+     every master appears before clone.  */\n+  for (lsei = lsei_start_function_in_partition (in_encoder);\n+       !lsei_end_p (lsei); lsei_next_function_in_partition (&lsei))\n     {\n-      node = csi_node (csi);\n+      node = lsei_cgraph_node (lsei);\n       add_node_to (encoder, node, true);\n       lto_set_symtab_encoder_in_partition (encoder, (symtab_node)node);\n       add_references (encoder, &node->symbol.ref_list);\n     }\n-  for (vsi = vsi_start (vset); !vsi_end_p (vsi); vsi_next (&vsi))\n+  for (lsei = lsei_start_variable_in_partition (in_encoder);\n+       !lsei_end_p (lsei); lsei_next_variable_in_partition (&lsei))\n     {\n-      struct varpool_node *vnode = vsi_node (vsi);\n+      struct varpool_node *vnode = lsei_varpool_node (lsei);\n       gcc_assert (!vnode->alias || vnode->alias_of);\n       lto_set_symtab_encoder_in_partition (encoder, (symtab_node)vnode);\n       lto_set_symtab_encoder_encode_initializer (encoder, vnode);\n@@ -696,13 +732,14 @@ compute_ltrans_boundary (struct lto_out_decl_state *state,\n \n   /* Go over all the nodes again to include callees that are not in\n      SET.  */\n-  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+  for (lsei = lsei_start_function_in_partition (encoder);\n+       !lsei_end_p (lsei); lsei_next_function_in_partition (&lsei))\n     {\n-      node = csi_node (csi);\n+      node = lsei_cgraph_node (lsei);\n       for (edge = node->callees; edge; edge = edge->next_callee)\n \t{\n \t  struct cgraph_node *callee = edge->callee;\n-\t  if (!cgraph_node_in_set_p (callee, set))\n+\t  if (!lto_symtab_encoder_in_partition_p (encoder, (symtab_node)callee))\n \t    {\n \t      /* We should have moved all the inlines.  */\n \t      gcc_assert (!callee->global.inlined_to);"}, {"sha": "66624f9a021d6094bf570de866890a0aa8c8f0c5", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b99cca4787efe0a5eec258b236c13b7b7604f04/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b99cca4787efe0a5eec258b236c13b7b7604f04/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=7b99cca4787efe0a5eec258b236c13b7b7604f04", "patch": "@@ -228,9 +228,9 @@ print_lto_report (void)\n \t       HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\", s,\n \t       lto_stats.num_output_files);\n \n-      fprintf (stderr, \"[%s] # of output cgraph nodes: \"\n+      fprintf (stderr, \"[%s] # of output symtab nodes: \"\n \t       HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\", s,\n-\t       lto_stats.num_output_cgraph_nodes);\n+\t       lto_stats.num_output_symtab_nodes);\n \n       fprintf (stderr, \"[%s] # callgraph partitions: \"\n \t       HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\", s,"}, {"sha": "595b538e5cee300b99a781a808e410c277d54d03", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 45, "deletions": 23, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b99cca4787efe0a5eec258b236c13b7b7604f04/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b99cca4787efe0a5eec258b236c13b7b7604f04/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=7b99cca4787efe0a5eec258b236c13b7b7604f04", "patch": "@@ -407,7 +407,7 @@ struct lto_asm_header\n struct lto_stats_d\n {\n   unsigned HOST_WIDE_INT num_input_cgraph_nodes;\n-  unsigned HOST_WIDE_INT num_output_cgraph_nodes;\n+  unsigned HOST_WIDE_INT num_output_symtab_nodes;\n   unsigned HOST_WIDE_INT num_input_files;\n   unsigned HOST_WIDE_INT num_output_files;\n   unsigned HOST_WIDE_INT num_cgraph_partitions;\n@@ -420,21 +420,29 @@ struct lto_stats_d\n   unsigned HOST_WIDE_INT num_uncompressed_il_bytes;\n };\n \n+/* Entry of LTO symtab encoder.  */\n+typedef struct\n+{\n+  symtab_node node;\n+  /* Is the node in this partition (i.e. ltrans of this partition will\n+     be responsible for outputting it)? */\n+  unsigned int in_partition:1;\n+  /* Do we encode body in this partition?  */\n+  unsigned int body:1;\n+  /* Do we encode initializer in this partition?\n+     For example the readonly variable initializers are encoded to aid\n+     constant folding even if they are not in the partition.  */\n+  unsigned int initializer:1;\n+} lto_encoder_entry;\n+\n+DEF_VEC_O(lto_encoder_entry);\n+DEF_VEC_ALLOC_O(lto_encoder_entry, heap);\n+\n /* Encoder data structure used to stream callgraph nodes.  */\n struct lto_symtab_encoder_d\n {\n-  /* Map nodes to reference number. */\n-  struct pointer_map_t *map;\n-\n-  /* Map reference number to node. */\n-  VEC(symtab_node,heap) *nodes;\n-\n-  /* Map of nodes where we want to output body.  */\n-  struct pointer_set_t *body;\n-  /* Map of nodes where we want to output initializer.  */\n-  struct pointer_set_t *initializer;\n-  /* Map of nodes in this partition.  */\n-  struct pointer_set_t *in_partition;\n+  VEC(lto_encoder_entry,gc) *nodes;\n+  pointer_map_t *map;\n };\n \n typedef struct lto_symtab_encoder_d *lto_symtab_encoder_t;\n@@ -825,10 +833,10 @@ void lto_output_location (struct output_block *, location_t);\n \n \n /* In lto-cgraph.c  */\n-int lto_symtab_encoder_lookup (lto_symtab_encoder_t, symtab_node);\n lto_symtab_encoder_t lto_symtab_encoder_new (void);\n int lto_symtab_encoder_encode (lto_symtab_encoder_t, symtab_node);\n void lto_symtab_encoder_delete (lto_symtab_encoder_t);\n+bool lto_symtab_encoder_delete_node (lto_symtab_encoder_t, symtab_node);\n bool lto_symtab_encoder_encode_body_p (lto_symtab_encoder_t,\n \t\t\t\t       struct cgraph_node *);\n bool lto_symtab_encoder_in_partition_p (lto_symtab_encoder_t,\n@@ -849,7 +857,7 @@ bool referenced_from_this_partition_p (struct ipa_ref_list *,\n bool reachable_from_this_partition_p (struct cgraph_node *,\n \t\t\t\t      lto_symtab_encoder_t);\n void compute_ltrans_boundary (struct lto_out_decl_state *state,\n-\t\t\t      cgraph_node_set, varpool_node_set);\n+\t\t\t      lto_symtab_encoder_t encoder);\n \n \n /* In lto-symtab.c.  */\n@@ -1007,7 +1015,21 @@ emit_label_in_global_context_p (tree label)\n static inline int\n lto_symtab_encoder_size (lto_symtab_encoder_t encoder)\n {\n-  return VEC_length (symtab_node, encoder->nodes);\n+  return VEC_length (lto_encoder_entry, encoder->nodes);\n+}\n+\n+/* Value used to represent failure of lto_symtab_encoder_lookup.  */\n+#define LCC_NOT_FOUND\t(-1)\n+\n+/* Look up NODE in encoder.  Return NODE's reference if it has been encoded\n+   or LCC_NOT_FOUND if it is not there.  */\n+\n+static inline int\n+lto_symtab_encoder_lookup (lto_symtab_encoder_t encoder,\n+\t\t\t   symtab_node node)\n+{\n+  void **slot = pointer_map_contains (encoder->map, node);\n+  return (slot && *slot ? (size_t) *(slot) - 1 : LCC_NOT_FOUND);\n }\n \n /* Return true if iterator LSE points to nothing.  */\n@@ -1028,26 +1050,26 @@ lsei_next (lto_symtab_encoder_iterator *lsei)\n static inline symtab_node\n lsei_node (lto_symtab_encoder_iterator lsei)\n {\n-  return VEC_index (symtab_node, lsei.encoder->nodes, lsei.index);\n+  return VEC_index (lto_encoder_entry,\n+\t\t    lsei.encoder->nodes, lsei.index).node;\n }\n \n /* Return the node pointed to by LSI.  */\n static inline struct cgraph_node *\n lsei_cgraph_node (lto_symtab_encoder_iterator lsei)\n {\n-  return cgraph (VEC_index (symtab_node, lsei.encoder->nodes, lsei.index));\n+  return cgraph (VEC_index (lto_encoder_entry,\n+\t\t\t    lsei.encoder->nodes, lsei.index).node);\n }\n \n /* Return the node pointed to by LSI.  */\n static inline struct varpool_node *\n lsei_varpool_node (lto_symtab_encoder_iterator lsei)\n {\n-  return varpool (VEC_index (symtab_node, lsei.encoder->nodes, lsei.index));\n+  return varpool (VEC_index (lto_encoder_entry,\n+\t\t\t     lsei.encoder->nodes, lsei.index).node);\n }\n \n-/* Value used to represent failure of lto_symtab_encoder_lookup.  */\n-#define LCC_NOT_FOUND\t(-1)\n-\n /* Return the cgraph node corresponding to REF using ENCODER.  */\n \n static inline symtab_node\n@@ -1056,7 +1078,7 @@ lto_symtab_encoder_deref (lto_symtab_encoder_t encoder, int ref)\n   if (ref == LCC_NOT_FOUND)\n     return NULL;\n \n-  return VEC_index (symtab_node, encoder->nodes, ref);\n+  return VEC_index (lto_encoder_entry, encoder->nodes, ref).node;\n }\n \n /* Return an iterator to the first node in LSI.  */"}, {"sha": "d5ae501d8da0264a92d1d1c585ed1b99d79420cc", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b99cca4787efe0a5eec258b236c13b7b7604f04/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b99cca4787efe0a5eec258b236c13b7b7604f04/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=7b99cca4787efe0a5eec258b236c13b7b7604f04", "patch": "@@ -1,3 +1,23 @@\n+2012-08-12  Jan Hubicka  <jh@suse.cz>\n+\n+\tReplace cgraph_node_set and varpool_node_set by symtab_node_encoder\n+\tin partitioning.\n+\t* lto-partition.h (ltrans_partition_def): Replace cgraph_set and varpool_set\n+\tby encoder.\n+\t* lto-partition.c (new_partition): Update.\n+\t* lto.c (cmp_partitions_order): Update.\n+\t(lto_wpa_write_files): Update.\n+\t(free_ltrans_partitions): Update.\n+\t(add_references_to_partition): Update.\n+\t(add_cgraph_node_to_partition_1): Update.\n+\t(add_cgraph_node_to_partition): Update.\n+\t(add_varpool_node_to_partition): Update.\n+\t(undo_partition): Update.\n+\t(lto_balanced_map): Update.\n+\t(set_referenced_from_other_partition_p, set_reachable_from_other_partition_p,\n+\tset_referenced_from_this_partition_p): Update.\n+\t(lto_promote_cross_file_statics): Update.\n+\n 2012-08-12  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-partition.c (set_referenced_from_other_partition_p,"}, {"sha": "954363dde6089b152c5f724765859c3a96408420", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 104, "deletions": 204, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b99cca4787efe0a5eec258b236c13b7b7604f04/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b99cca4787efe0a5eec258b236c13b7b7604f04/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=7b99cca4787efe0a5eec258b236c13b7b7604f04", "patch": "@@ -41,8 +41,7 @@ static ltrans_partition\n new_partition (const char *name)\n {\n   ltrans_partition part = XCNEW (struct ltrans_partition_def);\n-  part->cgraph_set = cgraph_node_set_new ();\n-  part->varpool_set = varpool_node_set_new ();\n+  part->encoder = lto_symtab_encoder_new ();\n   part->name = name;\n   part->insns = 0;\n   VEC_safe_push (ltrans_partition, heap, ltrans_partitions, part);\n@@ -57,7 +56,7 @@ free_ltrans_partitions (void)\n   ltrans_partition part;\n   for (idx = 0; VEC_iterate (ltrans_partition, ltrans_partitions, idx, part); idx++)\n     {\n-      free_cgraph_node_set (part->cgraph_set);\n+      /* Symtab encoder is freed after streaming.  */\n       free (part);\n     }\n   VEC_free (ltrans_partition, heap, ltrans_partitions);\n@@ -77,39 +76,38 @@ add_references_to_partition (ltrans_partition part, struct ipa_ref_list *refs)\n \t\t\t   NULL)->symbol.decl)\n \t      || (ref->use == IPA_REF_ALIAS\n \t\t  && lookup_attribute\n-\t\t       (\"weakref\", DECL_ATTRIBUTES (ipa_ref_node (ref)->symbol.decl))))\n-\t  && !cgraph_node_in_set_p (ipa_ref_node (ref), part->cgraph_set))\n+\t\t       (\"weakref\", DECL_ATTRIBUTES (ref->referred->symbol.decl))))\n+\t  && !lto_symtab_encoder_in_partition_p (part->encoder, ref->referred))\n \tadd_cgraph_node_to_partition (part, ipa_ref_node (ref));\n       else\n         if (symtab_variable_p (ref->referred)\n-\t    && (DECL_COMDAT (ipa_ref_varpool_node (ref)->symbol.decl)\n-\t\t|| DECL_EXTERNAL (ipa_ref_varpool_node (ref)->symbol.decl)\n+\t    && (DECL_COMDAT (ref->referred->symbol.decl)\n+\t\t|| DECL_EXTERNAL (ref->referred->symbol.decl)\n \t        || (ref->use == IPA_REF_ALIAS\n \t\t    && lookup_attribute\n \t\t         (\"weakref\",\n-\t\t\t  DECL_ATTRIBUTES (ipa_ref_varpool_node (ref)->symbol.decl))))\n-\t    && !varpool_node_in_set_p (ipa_ref_varpool_node (ref),\n-\t\t\t\t       part->varpool_set))\n+\t\t\t  DECL_ATTRIBUTES (ref->referred->symbol.decl))))\n+\t    && !lto_symtab_encoder_in_partition_p (part->encoder, ref->referred))\n \t  add_varpool_node_to_partition (part, ipa_ref_varpool_node (ref));\n     }\n   for (i = 0; ipa_ref_list_referring_iterate (refs, i, ref); i++)\n     {\n       if (symtab_function_p (ref->referring)\n \t  && ref->use == IPA_REF_ALIAS\n-\t  && !cgraph_node_in_set_p (ipa_ref_referring_node (ref),\n-\t\t\t\t    part->cgraph_set)\n+\t  && !lto_symtab_encoder_in_partition_p (part->encoder,\n+\t\t\t\t\t\t ref->referring)\n \t  && !lookup_attribute (\"weakref\",\n \t\t\t\tDECL_ATTRIBUTES\n-\t\t\t\t  (ipa_ref_referring_node (ref)->symbol.decl)))\n+\t\t\t\t  (ref->referring->symbol.decl)))\n \tadd_cgraph_node_to_partition (part, ipa_ref_referring_node (ref));\n       else\n         if (symtab_variable_p (ref->referring)\n \t    && ref->use == IPA_REF_ALIAS\n-\t    && !varpool_node_in_set_p (ipa_ref_referring_varpool_node (ref),\n-\t\t\t\t       part->varpool_set)\n+\t    && !lto_symtab_encoder_in_partition_p (part->encoder,\n+\t\t\t\t\t\t   ref->referring)\n \t    && !lookup_attribute (\"weakref\",\n \t\t\t\t  DECL_ATTRIBUTES\n-\t\t\t\t    (ipa_ref_referring_varpool_node (ref)->symbol.decl)))\n+\t\t\t\t    (ref->referring->symbol.decl)))\n \t  add_varpool_node_to_partition (part,\n \t\t\t\t\t ipa_ref_referring_varpool_node (ref));\n     }\n@@ -139,7 +137,7 @@ add_cgraph_node_to_partition_1 (struct cgraph_node *node, void *data)\n \t\t cgraph_node_name (node), node->uid);\n     }\n   node->symbol.aux = (void *)((size_t)node->symbol.aux + 1);\n-  cgraph_node_set_add (part->cgraph_set, node);\n+  lto_set_symtab_encoder_in_partition (part->encoder, (symtab_node)node);\n   return false;\n }\n \n@@ -149,25 +147,22 @@ static void\n add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node)\n {\n   struct cgraph_edge *e;\n-  cgraph_node_set_iterator csi;\n   struct cgraph_node *n;\n \n   /* If NODE is already there, we have nothing to do.  */\n-  csi = cgraph_node_set_find (part->cgraph_set, node);\n-  if (!csi_end_p (csi))\n+  if (lto_symtab_encoder_in_partition_p (part->encoder, (symtab_node) node))\n     return;\n \n   cgraph_for_node_thunks_and_aliases (node, add_cgraph_node_to_partition_1, part, true);\n \n   part->insns += inline_summary (node)->self_size;\n \n \n-  cgraph_node_set_add (part->cgraph_set, node);\n+  lto_set_symtab_encoder_in_partition (part->encoder, (symtab_node) node);\n \n   for (e = node->callees; e; e = e->next_callee)\n     if ((!e->inline_failed\n-\t || DECL_COMDAT (cgraph_function_node (e->callee, NULL)->symbol.decl))\n-\t&& !cgraph_node_in_set_p (e->callee, part->cgraph_set))\n+\t || DECL_COMDAT (cgraph_function_node (e->callee, NULL)->symbol.decl)))\n       add_cgraph_node_to_partition (part, e->callee);\n \n   /* The only way to assemble non-weakref alias is to add the aliased object into\n@@ -190,15 +185,13 @@ add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node)\n static void\n add_varpool_node_to_partition (ltrans_partition part, struct varpool_node *vnode)\n {\n-  varpool_node_set_iterator vsi;\n   struct varpool_node *v;\n \n   /* If NODE is already there, we have nothing to do.  */\n-  vsi = varpool_node_set_find (part->varpool_set, vnode);\n-  if (!vsi_end_p (vsi))\n+  if (lto_symtab_encoder_in_partition_p (part->encoder, (symtab_node) vnode))\n     return;\n \n-  varpool_node_set_add (part->varpool_set, vnode);\n+  lto_set_symtab_encoder_in_partition (part->encoder, (symtab_node) vnode);\n \n   if (vnode->symbol.aux)\n     {\n@@ -220,35 +213,24 @@ add_varpool_node_to_partition (ltrans_partition part, struct varpool_node *vnode\n   add_references_to_partition (part, &vnode->symbol.ref_list);\n \n   if (vnode->symbol.same_comdat_group\n-      && !varpool_node_in_set_p (varpool (vnode->symbol.same_comdat_group),\n-\t\t\t\t part->varpool_set))\n+      && !lto_symtab_encoder_in_partition_p (part->encoder,\n+\t\t\t\t\t     vnode->symbol.same_comdat_group))\n     add_varpool_node_to_partition (part, varpool (vnode->symbol.same_comdat_group));\n }\n \n /* Undo all additions until number of cgraph nodes in PARITION is N_CGRAPH_NODES\n    and number of varpool nodes is N_VARPOOL_NODES.  */\n \n static void\n-undo_partition (ltrans_partition partition, unsigned int n_cgraph_nodes,\n-\t\tunsigned int n_varpool_nodes)\n+undo_partition (ltrans_partition partition, unsigned int n_nodes)\n {\n-  while (VEC_length (cgraph_node_ptr, partition->cgraph_set->nodes) >\n-\t n_cgraph_nodes)\n+  while (lto_symtab_encoder_size (partition->encoder) > (int)n_nodes)\n     {\n-      struct cgraph_node *node = VEC_index (cgraph_node_ptr,\n-\t\t\t\t\t    partition->cgraph_set->nodes,\n-\t\t\t\t\t    n_cgraph_nodes);\n-      partition->insns -= inline_summary (node)->self_size;\n-      cgraph_node_set_remove (partition->cgraph_set, node);\n-      node->symbol.aux = (void *)((size_t)node->symbol.aux - 1);\n-    }\n-  while (VEC_length (varpool_node_ptr, partition->varpool_set->nodes) >\n-\t n_varpool_nodes)\n-    {\n-      struct varpool_node *node = VEC_index (varpool_node_ptr,\n-\t\t\t\t\t     partition->varpool_set->nodes,\n-\t\t\t\t\t     n_varpool_nodes);\n-      varpool_node_set_remove (partition->varpool_set, node);\n+      symtab_node node = lto_symtab_encoder_deref (partition->encoder,\n+\t\t\t\t\t\t   n_nodes);\n+      if (symtab_function_p (node))\n+        partition->insns -= inline_summary (cgraph (node))->self_size;\n+      lto_symtab_encoder_delete_node (partition->encoder, node);\n       node->symbol.aux = (void *)((size_t)node->symbol.aux - 1);\n     }\n }\n@@ -458,10 +440,10 @@ lto_balanced_map (void)\n   int total_size = 0, best_total_size = 0;\n   int partition_size;\n   ltrans_partition partition;\n-  unsigned int last_visited_cgraph_node = 0, last_visited_varpool_node = 0;\n+  int last_visited_node = 0;\n   struct varpool_node *vnode;\n   int cost = 0, internal = 0;\n-  int best_n_nodes = 0, best_n_varpool_nodes = 0, best_i = 0, best_cost =\n+  int best_n_nodes = 0, best_i = 0, best_cost =\n     INT_MAX, best_internal = 0;\n   int npartitions;\n   int current_order = -1;\n@@ -545,28 +527,22 @@ lto_balanced_map (void)\n          callgraph or IPA reference edge leaving the partition contributes into\n          COST.  Every edge inside partition was earlier computed as one leaving\n \t it and thus we need to subtract it from COST.  */\n-      while (last_visited_cgraph_node <\n-\t     VEC_length (cgraph_node_ptr, partition->cgraph_set->nodes)\n-\t     || last_visited_varpool_node < VEC_length (varpool_node_ptr,\n-\t\t\t\t\t\t\tpartition->varpool_set->\n-\t\t\t\t\t\t\tnodes))\n+      while (last_visited_node < lto_symtab_encoder_size (partition->encoder))\n \t{\n \t  struct ipa_ref_list *refs;\n \t  int j;\n \t  struct ipa_ref *ref;\n-\t  bool cgraph_p = false;\n+\t  symtab_node snode = lto_symtab_encoder_deref (partition->encoder,\n+\t\t\t\t\t\t\tlast_visited_node);\n \n-\t  if (last_visited_cgraph_node <\n-\t      VEC_length (cgraph_node_ptr, partition->cgraph_set->nodes))\n+\t  if (symtab_function_p (snode))\n \t    {\n \t      struct cgraph_edge *edge;\n \n-\t      cgraph_p = true;\n-\t      node = VEC_index (cgraph_node_ptr, partition->cgraph_set->nodes,\n-\t\t\t\tlast_visited_cgraph_node);\n+\t      node = cgraph (snode);\n \t      refs = &node->symbol.ref_list;\n \n-\t      last_visited_cgraph_node++;\n+\t      last_visited_node++;\n \n \t      gcc_assert (node->analyzed);\n \n@@ -575,103 +551,107 @@ lto_balanced_map (void)\n \t\tif (edge->callee->analyzed)\n \t\t  {\n \t\t    int edge_cost = edge->frequency;\n-\t\t    cgraph_node_set_iterator csi;\n+\t\t    int index;\n \n \t\t    if (!edge_cost)\n \t\t      edge_cost = 1;\n \t\t    gcc_assert (edge_cost > 0);\n-\t\t    csi = cgraph_node_set_find (partition->cgraph_set, edge->callee);\n-\t\t    if (!csi_end_p (csi)\n-\t\t        && csi.index < last_visited_cgraph_node - 1)\n-\t\t      cost -= edge_cost, internal+= edge_cost;\n+\t\t    index = lto_symtab_encoder_lookup (partition->encoder,\n+\t\t\t\t\t\t       (symtab_node)edge->callee);\n+\t\t    if (index != LCC_NOT_FOUND\n+\t\t        && index < last_visited_node - 1)\n+\t\t      cost -= edge_cost, internal += edge_cost;\n \t\t    else\n \t\t      cost += edge_cost;\n \t\t  }\n \t      for (edge = node->callers; edge; edge = edge->next_caller)\n \t\t{\n \t\t  int edge_cost = edge->frequency;\n-\t\t  cgraph_node_set_iterator csi;\n+\t\t  int index;\n \n \t\t  gcc_assert (edge->caller->analyzed);\n \t\t  if (!edge_cost)\n \t\t    edge_cost = 1;\n \t\t  gcc_assert (edge_cost > 0);\n-\t\t  csi = cgraph_node_set_find (partition->cgraph_set, edge->caller);\n-\t\t  if (!csi_end_p (csi)\n-\t\t      && csi.index < last_visited_cgraph_node)\n+\t\t  index = lto_symtab_encoder_lookup (partition->encoder,\n+\t\t\t\t\t\t     (symtab_node)edge->caller);\n+\t\t  if (index != LCC_NOT_FOUND\n+\t\t      && index < last_visited_node - 1)\n \t\t    cost -= edge_cost;\n \t\t  else\n \t\t    cost += edge_cost;\n \t\t}\n \t    }\n \t  else\n \t    {\n-\t      refs =\n-\t\t&VEC_index (varpool_node_ptr, partition->varpool_set->nodes,\n-\t\t\t    last_visited_varpool_node)->symbol.ref_list;\n-\t      last_visited_varpool_node++;\n+\t      refs = &snode->symbol.ref_list;\n+\t      last_visited_node++;\n \t    }\n \n \t  /* Compute boundary cost of IPA REF edges and at the same time look into\n \t     variables referenced from current partition and try to add them.  */\n \t  for (j = 0; ipa_ref_list_reference_iterate (refs, j, ref); j++)\n \t    if (symtab_variable_p (ref->referred))\n \t      {\n-\t\tvarpool_node_set_iterator vsi;\n+\t\tint index;\n \n \t\tvnode = ipa_ref_varpool_node (ref);\n \t\tif (!vnode->finalized)\n \t\t  continue;\n \t\tif (!vnode->symbol.aux && flag_toplevel_reorder\n \t\t    && partition_varpool_node_p (vnode))\n \t\t  add_varpool_node_to_partition (partition, vnode);\n-\t\tvsi = varpool_node_set_find (partition->varpool_set, vnode);\n-\t\tif (!vsi_end_p (vsi)\n-\t\t    && vsi.index < last_visited_varpool_node - !cgraph_p)\n+\t\tindex = lto_symtab_encoder_lookup (partition->encoder,\n+\t\t\t\t\t\t   (symtab_node)vnode);\n+\t\tif (index != LCC_NOT_FOUND\n+\t\t    && index < last_visited_node - 1)\n \t\t  cost--, internal++;\n \t\telse\n \t\t  cost++;\n \t      }\n \t    else\n \t      {\n-\t\tcgraph_node_set_iterator csi;\n+\t\tint index;\n \n \t\tnode = ipa_ref_node (ref);\n \t\tif (!node->analyzed)\n \t\t  continue;\n-\t\tcsi = cgraph_node_set_find (partition->cgraph_set, node);\n-\t\tif (!csi_end_p (csi)\n-\t\t    && csi.index < last_visited_cgraph_node - cgraph_p)\n+\t\tindex = lto_symtab_encoder_lookup (partition->encoder,\n+\t\t\t\t\t\t   (symtab_node)node);\n+\t\tif (index != LCC_NOT_FOUND\n+\t\t    && index < last_visited_node - 1)\n \t\t  cost--, internal++;\n \t\telse\n \t\t  cost++;\n \t      }\n \t  for (j = 0; ipa_ref_list_referring_iterate (refs, j, ref); j++)\n \t    if (symtab_variable_p (ref->referring))\n \t      {\n-\t\tvarpool_node_set_iterator vsi;\n+\t\tint index;\n \n \t\tvnode = ipa_ref_referring_varpool_node (ref);\n \t\tgcc_assert (vnode->finalized);\n \t\tif (!vnode->symbol.aux && flag_toplevel_reorder\n \t\t    && partition_varpool_node_p (vnode))\n \t\t  add_varpool_node_to_partition (partition, vnode);\n-\t\tvsi = varpool_node_set_find (partition->varpool_set, vnode);\n-\t\tif (!vsi_end_p (vsi)\n-\t\t    && vsi.index < last_visited_varpool_node)\n+\t\tindex = lto_symtab_encoder_lookup (partition->encoder,\n+\t\t\t\t\t\t   (symtab_node)vnode);\n+\t\tif (index != LCC_NOT_FOUND\n+\t\t    && index < last_visited_node - 1)\n \t\t  cost--;\n \t\telse\n \t\t  cost++;\n \t      }\n \t    else\n \t      {\n-\t\tcgraph_node_set_iterator csi;\n+\t\tint index;\n \n \t\tnode = ipa_ref_referring_node (ref);\n \t\tgcc_assert (node->analyzed);\n-\t\tcsi = cgraph_node_set_find (partition->cgraph_set, node);\n-\t\tif (!csi_end_p (csi)\n-\t\t    && csi.index < last_visited_cgraph_node)\n+\t\tindex = lto_symtab_encoder_lookup (partition->encoder,\n+\t\t\t\t\t\t   (symtab_node)node);\n+\t\tif (index != LCC_NOT_FOUND\n+\t\t    && index < last_visited_node - 1)\n \t\t  cost--;\n \t\telse\n \t\t  cost++;\n@@ -689,10 +669,7 @@ lto_balanced_map (void)\n \t  best_cost = cost;\n \t  best_internal = internal;\n \t  best_i = i;\n-\t  best_n_nodes = VEC_length (cgraph_node_ptr,\n-\t\t\t\t     partition->cgraph_set->nodes);\n-\t  best_n_varpool_nodes = VEC_length (varpool_node_ptr,\n-\t\t\t\t\t     partition->varpool_set->nodes);\n+\t  best_n_nodes = lto_symtab_encoder_size (partition->encoder);\n \t  best_total_size = total_size;\n \t}\n       if (cgraph_dump_file)\n@@ -708,7 +685,7 @@ lto_balanced_map (void)\n \t      if (cgraph_dump_file)\n \t\tfprintf (cgraph_dump_file, \"Unwinding %i insertions to step %i\\n\",\n \t\t\t i - best_i, best_i);\n-\t      undo_partition (partition, best_n_nodes, best_n_varpool_nodes);\n+\t      undo_partition (partition, best_n_nodes);\n \t    }\n \t  i = best_i;\n  \t  /* When we are finished, avoid creating empty partition.  */\n@@ -717,15 +694,13 @@ lto_balanced_map (void)\n \t  if (i == n_nodes - 1)\n \t    break;\n \t  partition = new_partition (\"\");\n-\t  last_visited_cgraph_node = 0;\n-\t  last_visited_varpool_node = 0;\n+\t  last_visited_node = 0;\n \t  total_size = best_total_size;\n \t  cost = 0;\n \n \t  if (cgraph_dump_file)\n \t    fprintf (cgraph_dump_file, \"New partition\\n\");\n \t  best_n_nodes = 0;\n-\t  best_n_varpool_nodes = 0;\n \t  best_cost = INT_MAX;\n \n \t  /* Since the size of partitions is just approximate, update the size after\n@@ -797,79 +772,6 @@ promote_fn (struct cgraph_node *node)\n   return true;\n }\n \n-/* Return if LIST contain references from other partitions.  \n-   TODO: remove this once lto partitioning is using encoders.  */\n-\n-static bool\n-set_referenced_from_other_partition_p (struct ipa_ref_list *list, cgraph_node_set set,\n-\t\t\t\t       varpool_node_set vset)\n-{\n-  int i;\n-  struct ipa_ref *ref;\n-  for (i = 0; ipa_ref_list_referring_iterate (list, i, ref); i++)\n-    {\n-      if (symtab_function_p (ref->referring))\n-\t{\n-\t  if (ipa_ref_referring_node (ref)->symbol.in_other_partition\n-\t      || !cgraph_node_in_set_p (ipa_ref_referring_node (ref), set))\n-\t    return true;\n-\t}\n-      else\n-\t{\n-\t  if (ipa_ref_referring_varpool_node (ref)->symbol.in_other_partition\n-\t      || !varpool_node_in_set_p (ipa_ref_referring_varpool_node (ref),\n-\t\t\t\t         vset))\n-\t    return true;\n-\t}\n-    }\n-  return false;\n-}\n-\n-/* Return true when node is reachable from other partition. \n-   TODO: remove this once lto partitioning is using encoders.  */\n-\n-static bool\n-set_reachable_from_other_partition_p (struct cgraph_node *node, cgraph_node_set set)\n-{\n-  struct cgraph_edge *e;\n-  if (!node->analyzed)\n-    return false;\n-  if (node->global.inlined_to)\n-    return false;\n-  for (e = node->callers; e; e = e->next_caller)\n-    if (e->caller->symbol.in_other_partition\n-\t|| !cgraph_node_in_set_p (e->caller, set))\n-      return true;\n-  return false;\n-}\n-\n-\n-/* Return if LIST contain references from other partitions. \n-   TODO: remove this once lto partitioning is using encoders.  */\n-\n-static bool\n-set_referenced_from_this_partition_p (struct ipa_ref_list *list, cgraph_node_set set,\n-\t\t\t\t  varpool_node_set vset)\n-{\n-  int i;\n-  struct ipa_ref *ref;\n-  for (i = 0; ipa_ref_list_referring_iterate (list, i, ref); i++)\n-    {\n-      if (symtab_function_p (ref->referring))\n-\t{\n-\t  if (cgraph_node_in_set_p (ipa_ref_referring_node (ref), set))\n-\t    return true;\n-\t}\n-      else\n-\t{\n-\t  if (varpool_node_in_set_p (ipa_ref_referring_varpool_node (ref),\n-\t\t\t\t     vset))\n-\t    return true;\n-\t}\n-    }\n-  return false;\n-}\n-\n /* Find out all static decls that need to be promoted to global because\n    of cross file sharing.  This function must be run in the WPA mode after\n    all inlinees are added.  */\n@@ -879,12 +781,10 @@ lto_promote_cross_file_statics (void)\n {\n   struct varpool_node *vnode;\n   unsigned i, n_sets;\n-  cgraph_node_set set;\n-  varpool_node_set vset;\n-  cgraph_node_set_iterator csi;\n-  varpool_node_set_iterator vsi;\n   VEC(varpool_node_ptr, heap) *promoted_initializers = NULL;\n   struct pointer_set_t *inserted = pointer_set_create ();\n+  lto_symtab_encoder_iterator lsei;\n+  lto_symtab_encoder_t encoder;\n \n   gcc_assert (flag_wpa);\n \n@@ -893,37 +793,37 @@ lto_promote_cross_file_statics (void)\n     {\n       ltrans_partition part\n \t= VEC_index (ltrans_partition, ltrans_partitions, i);\n-      set = part->cgraph_set;\n-      vset = part->varpool_set;\n+      encoder = part->encoder;\n \n       /* If node called or referred to from other partition, it needs to be\n \t globalized.  */\n-      for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+      for (lsei = lsei_start_in_partition (encoder); !lsei_end_p (lsei);\n+\t   lsei_next_in_partition (&lsei))\n \t{\n-\t  struct cgraph_node *node = csi_node (csi);\n+\t  symtab_node node = lsei_node (lsei);\n \t  if (node->symbol.externally_visible)\n \t    continue;\n-\t  if (node->global.inlined_to)\n-\t    continue;\n-\t  if ((!DECL_EXTERNAL (node->symbol.decl)\n-\t       && !DECL_COMDAT (node->symbol.decl))\n-\t      && (set_referenced_from_other_partition_p (&node->symbol.ref_list, set, vset)\n-\t\t  || set_reachable_from_other_partition_p (node, set)))\n-\t    promote_fn (node);\n-\t}\n-      for (vsi = vsi_start (vset); !vsi_end_p (vsi); vsi_next (&vsi))\n-\t{\n-\t  vnode = vsi_node (vsi);\n-\t  /* Constant pool references use internal labels and thus can not\n-\t     be made global.  It is sensible to keep those ltrans local to\n-\t     allow better optimization.  */\n-\t  if (!DECL_IN_CONSTANT_POOL (vnode->symbol.decl)\n-\t      && !DECL_EXTERNAL (vnode->symbol.decl)\n-\t      && !DECL_COMDAT (vnode->symbol.decl)\n-\t      && !vnode->symbol.externally_visible && vnode->analyzed\n-\t      && set_referenced_from_other_partition_p (&vnode->symbol.ref_list,\n-\t\t\t\t\t\t    set, vset))\n-\t    promote_var (vnode);\n+\t  if (symtab_function_p (node))\n+\t    {\n+\t      struct cgraph_node *cnode = cgraph (node);\n+\t      if (partition_cgraph_node_p (cnode)\n+\t\t  && (referenced_from_other_partition_p (&cnode->symbol.ref_list, encoder)\n+\t\t      || reachable_from_other_partition_p (cnode, encoder)))\n+\t\tpromote_fn (cnode);\n+\t    }\n+\t  else if (symtab_variable_p (node))\n+\t    {\n+\t      vnode = varpool (node);\n+\t      /* Constant pool references use internal labels and thus can not\n+\t\t be made global.  It is sensible to keep those ltrans local to\n+\t\t allow better optimization.  */\n+\t      if (partition_varpool_node_p (vnode)\n+\t\t  && referenced_from_other_partition_p (&vnode->symbol.ref_list,\n+\t\t\t\t\t\t\tencoder))\n+\t\tpromote_var (vnode);\n+\t    }\n+\t  else\n+\t    gcc_unreachable ();\n \t}\n \n       /* We export the initializer of a read-only var into each partition\n@@ -938,8 +838,8 @@ lto_promote_cross_file_statics (void)\n       FOR_EACH_VARIABLE (vnode)\n \tif (const_value_known_p (vnode->symbol.decl)\n \t    && DECL_INITIAL (vnode->symbol.decl)\n-\t    && !varpool_node_in_set_p (vnode, vset)\n-\t    && set_referenced_from_this_partition_p (&vnode->symbol.ref_list, set, vset)\n+\t    && !lto_symtab_encoder_in_partition_p (encoder, (symtab_node)vnode)\n+\t    && referenced_from_this_partition_p (&vnode->symbol.ref_list, encoder)\n \t    && !pointer_set_insert (inserted, vnode))\n \tVEC_safe_push (varpool_node_ptr, heap, promoted_initializers, vnode);\n \n@@ -958,13 +858,13 @@ lto_promote_cross_file_statics (void)\n \t\t  struct cgraph_node *n = ipa_ref_node (ref);\n \t\t  gcc_assert (!n->global.inlined_to);\n \t\t  if (!n->symbol.externally_visible\n-\t\t      && !cgraph_node_in_set_p (n, set))\n+\t\t      && !lto_symtab_encoder_in_partition_p (encoder, (symtab_node)n))\n \t\t    promote_fn (n);\n \t\t}\n \t      else\n \t\t{\n \t\t  struct varpool_node *v = ipa_ref_varpool_node (ref);\n-\t\t  if (varpool_node_in_set_p (v, vset))\n+\t\t  if (lto_symtab_encoder_in_partition_p (encoder, (symtab_node)v))\n \t\t    continue;\n \n \t\t  /* Constant pool references use internal labels and thus"}, {"sha": "e044934e5e7d79b4d6c55a99cb894eb23524737f", "filename": "gcc/lto/lto-partition.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b99cca4787efe0a5eec258b236c13b7b7604f04/gcc%2Flto%2Flto-partition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b99cca4787efe0a5eec258b236c13b7b7604f04/gcc%2Flto%2Flto-partition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.h?ref=7b99cca4787efe0a5eec258b236c13b7b7604f04", "patch": "@@ -22,8 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n \n struct ltrans_partition_def\n {\n-  cgraph_node_set cgraph_set;\n-  varpool_node_set varpool_set;\n+  lto_symtab_encoder_t encoder;\n   const char * name;\n   int insns;\n };"}, {"sha": "b757feaf4a32693968b69352490e0f69437c64b0", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b99cca4787efe0a5eec258b236c13b7b7604f04/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b99cca4787efe0a5eec258b236c13b7b7604f04/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=7b99cca4787efe0a5eec258b236c13b7b7604f04", "patch": "@@ -1421,14 +1421,10 @@ cmp_partitions_order (const void *a, const void *b)\n      = *(struct ltrans_partition_def *const *)b;\n   int ordera = -1, orderb = -1;\n \n-  if (VEC_length (cgraph_node_ptr, pa->cgraph_set->nodes))\n-    ordera = VEC_index (cgraph_node_ptr, pa->cgraph_set->nodes, 0)->symbol.order;\n-  else if (VEC_length (varpool_node_ptr, pa->varpool_set->nodes))\n-    ordera = VEC_index (varpool_node_ptr, pa->varpool_set->nodes, 0)->symbol.order;\n-  if (VEC_length (cgraph_node_ptr, pb->cgraph_set->nodes))\n-    orderb = VEC_index (cgraph_node_ptr, pb->cgraph_set->nodes, 0)->symbol.order;\n-  else if (VEC_length (varpool_node_ptr, pb->varpool_set->nodes))\n-    orderb = VEC_index (varpool_node_ptr, pb->varpool_set->nodes, 0)->symbol.order;\n+  if (lto_symtab_encoder_size (pa->encoder))\n+    ordera = lto_symtab_encoder_deref (pa->encoder, 0)->symbol.order;\n+  if (lto_symtab_encoder_size (pb->encoder))\n+    orderb = lto_symtab_encoder_deref (pb->encoder, 0)->symbol.order;\n   return orderb - ordera;\n }\n \n@@ -1440,8 +1436,6 @@ lto_wpa_write_files (void)\n {\n   unsigned i, n_sets;\n   lto_file *file;\n-  cgraph_node_set set;\n-  varpool_node_set vset;\n   ltrans_partition part;\n   FILE *ltrans_output_list_stream;\n   char *temp_filename;\n@@ -1457,8 +1451,7 @@ lto_wpa_write_files (void)\n   timevar_push (TV_WHOPR_WPA);\n \n   FOR_EACH_VEC_ELT (ltrans_partition, ltrans_partitions, i, part)\n-    lto_stats.num_output_cgraph_nodes += VEC_length (cgraph_node_ptr,\n-\t\t\t\t\t\t     part->cgraph_set->nodes);\n+    lto_stats.num_output_symtab_nodes += lto_symtab_encoder_size (part->encoder);\n \n   /* Find out statics that need to be promoted\n      to globals with hidden visibility because they are accessed from multiple\n@@ -1491,9 +1484,6 @@ lto_wpa_write_files (void)\n       size_t len;\n       ltrans_partition part = VEC_index (ltrans_partition, ltrans_partitions, i);\n \n-      set = part->cgraph_set;\n-      vset = part->varpool_set;\n-\n       /* Write all the nodes in SET.  */\n       sprintf (temp_filename + blen, \"%u.o\", i);\n       file = lto_obj_file_open (temp_filename, true);\n@@ -1504,22 +1494,28 @@ lto_wpa_write_files (void)\n \tfprintf (stderr, \" %s (%s %i insns)\", temp_filename, part->name, part->insns);\n       if (cgraph_dump_file)\n \t{\n+          lto_symtab_encoder_iterator lsei;\n+\t  \n \t  fprintf (cgraph_dump_file, \"Writing partition %s to file %s, %i insns\\n\",\n \t\t   part->name, temp_filename, part->insns);\n-\t  fprintf (cgraph_dump_file, \"cgraph nodes:\");\n-\t  dump_cgraph_node_set (cgraph_dump_file, set);\n-\t  fprintf (cgraph_dump_file, \"varpool nodes:\");\n-\t  dump_varpool_node_set (cgraph_dump_file, vset);\n+\t  for (lsei = lsei_start_in_partition (part->encoder); !lsei_end_p (lsei);\n+\t       lsei_next_in_partition (&lsei))\n+\t    {\n+\t      symtab_node node = lsei_node (lsei);\n+\t      fprintf (cgraph_dump_file, \"%s \", symtab_node_name (node));\n+\t    }\n+\t  fprintf (cgraph_dump_file, \"\\n\");\n \t}\n-      gcc_checking_assert (cgraph_node_set_nonempty_p (set)\n-\t\t\t   || varpool_node_set_nonempty_p (vset) || !i);\n+      gcc_checking_assert (lto_symtab_encoder_size (part->encoder) || !i);\n \n       lto_set_current_out_file (file);\n \n-      ipa_write_optimization_summaries (set, vset);\n+      ipa_write_optimization_summaries (part->encoder);\n \n       lto_set_current_out_file (NULL);\n       lto_obj_file_close (file);\n+      lto_symtab_encoder_delete (part->encoder);\n+      part->encoder = NULL;\n \n       len = strlen (temp_filename);\n       if (fwrite (temp_filename, 1, len, ltrans_output_list_stream) < len"}, {"sha": "8365cff2377ff0edcc24cc7ca003d7ef5a525e14", "filename": "gcc/passes.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b99cca4787efe0a5eec258b236c13b7b7604f04/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b99cca4787efe0a5eec258b236c13b7b7604f04/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=7b99cca4787efe0a5eec258b236c13b7b7604f04", "patch": "@@ -2261,10 +2261,10 @@ ipa_write_summaries_2 (struct opt_pass *pass, struct lto_out_decl_state *state)\n    summaries.  SET is the set of nodes to be written.  */\n \n static void\n-ipa_write_summaries_1 (cgraph_node_set set, varpool_node_set vset)\n+ipa_write_summaries_1 (lto_symtab_encoder_t encoder)\n {\n   struct lto_out_decl_state *state = lto_new_out_decl_state ();\n-  compute_ltrans_boundary (state, set, vset);\n+  compute_ltrans_boundary (state, encoder);\n \n   lto_push_out_decl_state (state);\n \n@@ -2282,16 +2282,15 @@ ipa_write_summaries_1 (cgraph_node_set set, varpool_node_set vset)\n void\n ipa_write_summaries (void)\n {\n-  cgraph_node_set set;\n-  varpool_node_set vset;\n-  struct cgraph_node **order;\n-  struct varpool_node *vnode;\n+  lto_symtab_encoder_t encoder;\n   int i, order_pos;\n+  struct varpool_node *vnode;\n+  struct cgraph_node **order;\n \n   if (!flag_generate_lto || seen_error ())\n     return;\n \n-  set = cgraph_node_set_new ();\n+  encoder = lto_symtab_encoder_new ();\n \n   /* Create the callgraph set in the same order used in\n      cgraph_expand_all_functions.  This mostly facilitates debugging,\n@@ -2318,19 +2317,16 @@ ipa_write_summaries (void)\n \t  pop_cfun ();\n \t}\n       if (node->analyzed)\n-        cgraph_node_set_add (set, node);\n+        lto_set_symtab_encoder_in_partition (encoder, (symtab_node)node);\n     }\n-  vset = varpool_node_set_new ();\n \n   FOR_EACH_DEFINED_VARIABLE (vnode)\n     if ((!vnode->alias || vnode->alias_of))\n-      varpool_node_set_add (vset, vnode);\n+      lto_set_symtab_encoder_in_partition (encoder, (symtab_node)vnode);\n \n-  ipa_write_summaries_1 (set, vset);\n+  ipa_write_summaries_1 (encoder);\n \n   free (order);\n-  free_cgraph_node_set (set);\n-  free_varpool_node_set (vset);\n }\n \n /* Same as execute_pass_list but assume that subpasses of IPA passes\n@@ -2376,16 +2372,17 @@ ipa_write_optimization_summaries_1 (struct opt_pass *pass, struct lto_out_decl_s\n    NULL, write out all summaries of all nodes. */\n \n void\n-ipa_write_optimization_summaries (cgraph_node_set set, varpool_node_set vset)\n+ipa_write_optimization_summaries (lto_symtab_encoder_t encoder)\n {\n   struct lto_out_decl_state *state = lto_new_out_decl_state ();\n-  cgraph_node_set_iterator csi;\n-  compute_ltrans_boundary (state, set, vset);\n+  lto_symtab_encoder_iterator lsei;\n+  compute_ltrans_boundary (state, encoder);\n \n   lto_push_out_decl_state (state);\n-  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+  for (lsei = lsei_start_function_in_partition (encoder);\n+       !lsei_end_p (lsei); lsei_next_function_in_partition (&lsei))\n     {\n-      struct cgraph_node *node = csi_node (csi);\n+      struct cgraph_node *node = lsei_cgraph_node (lsei);\n       /* When streaming out references to statements as part of some IPA\n \t pass summary, the statements need to have uids assigned.\n "}, {"sha": "1627a844c90d9dc6d0dcaefac139a76c412b51d5", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b99cca4787efe0a5eec258b236c13b7b7604f04/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b99cca4787efe0a5eec258b236c13b7b7604f04/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=7b99cca4787efe0a5eec258b236c13b7b7604f04", "patch": "@@ -92,8 +92,7 @@ struct rtl_opt_pass\n \n struct varpool_node;\n struct cgraph_node;\n-struct cgraph_node_set_def;\n-struct varpool_node_set_def;\n+struct lto_symtab_encoder_d;\n \n /* Description of IPA pass with generate summary, write, execute, read and\n    transform stages.  */\n@@ -526,8 +525,7 @@ extern const char *get_current_pass_name (void);\n extern void print_current_pass (FILE *);\n extern void debug_pass (void);\n extern void ipa_write_summaries (void);\n-extern void ipa_write_optimization_summaries (struct cgraph_node_set_def *,\n-\t\t\t\t\t      struct varpool_node_set_def *);\n+extern void ipa_write_optimization_summaries (struct lto_symtab_encoder_d *);\n extern void ipa_read_summaries (void);\n extern void ipa_read_optimization_summaries (void);\n extern void register_one_dump_file (struct opt_pass *);"}]}