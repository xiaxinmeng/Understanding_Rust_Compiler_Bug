{"sha": "e9e2bad7251477db92ab9ebcdc010f9282dd9890", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTllMmJhZDcyNTE0NzdkYjkyYWI5ZWJjZGMwMTBmOTI4MmRkOTg5MA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-06-25T01:22:06Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-06-25T01:30:47Z"}, "message": "middle-end: add support for per-location warning groups.\n\ngcc/ChangeLog:\n\n\t* builtins.c (warn_string_no_nul): Replace uses of TREE_NO_WARNING,\n\tgimple_no_warning_p and gimple_set_no_warning with\n\twarning_suppressed_p, and suppress_warning.\n\t(c_strlen): Same.\n\t(maybe_warn_for_bound): Same.\n\t(warn_for_access): Same.\n\t(check_access): Same.\n\t(expand_builtin_strncmp): Same.\n\t(fold_builtin_varargs): Same.\n\t* calls.c (maybe_warn_nonstring_arg): Same.\n\t(maybe_warn_rdwr_sizes): Same.\n\t* cfgexpand.c (expand_call_stmt): Same.\n\t* cgraphunit.c (check_global_declaration): Same.\n\t* fold-const.c (fold_undefer_overflow_warnings): Same.\n\t(fold_truth_not_expr): Same.\n\t(fold_unary_loc): Same.\n\t(fold_checksum_tree): Same.\n\t* gimple-array-bounds.cc (array_bounds_checker::check_array_ref): Same.\n\t(array_bounds_checker::check_mem_ref): Same.\n\t(array_bounds_checker::check_addr_expr): Same.\n\t(array_bounds_checker::check_array_bounds): Same.\n\t* gimple-expr.c (copy_var_decl): Same.\n\t* gimple-fold.c (gimple_fold_builtin_strcpy): Same.\n\t(gimple_fold_builtin_strncat): Same.\n\t(gimple_fold_builtin_stxcpy_chk): Same.\n\t(gimple_fold_builtin_stpcpy): Same.\n\t(gimple_fold_builtin_sprintf): Same.\n\t(fold_stmt_1): Same.\n\t* gimple-ssa-isolate-paths.c (diag_returned_locals): Same.\n\t* gimple-ssa-nonnull-compare.c (do_warn_nonnull_compare): Same.\n\t* gimple-ssa-sprintf.c (handle_printf_call): Same.\n\t* gimple-ssa-store-merging.c (imm_store_chain_info::output_merged_store): Same.\n\t* gimple-ssa-warn-restrict.c (maybe_diag_overlap): Same.\n\t* gimple-ssa-warn-restrict.h: Adjust declarations.\n\t(maybe_diag_access_bounds): Replace uses of TREE_NO_WARNING,\n\tgimple_no_warning_p and gimple_set_no_warning with\n\twarning_suppressed_p, and suppress_warning.\n\t(check_call): Same.\n\t(check_bounds_or_overlap): Same.\n\t* gimple.c (gimple_build_call_from_tree): Same.\n\t* gimplify.c (gimplify_return_expr): Same.\n\t(gimplify_cond_expr): Same.\n\t(gimplify_modify_expr_complex_part): Same.\n\t(gimplify_modify_expr): Same.\n\t(gimple_push_cleanup): Same.\n\t(gimplify_expr): Same.\n\t* omp-expand.c (expand_omp_for_generic): Same.\n\t(expand_omp_taskloop_for_outer): Same.\n\t* omp-low.c (lower_rec_input_clauses): Same.\n\t(lower_lastprivate_clauses): Same.\n\t(lower_send_clauses): Same.\n\t(lower_omp_target): Same.\n\t* tree-cfg.c (pass_warn_function_return::execute): Same.\n\t* tree-complex.c (create_one_component_var): Same.\n\t* tree-inline.c (remap_gimple_op_r): Same.\n\t(copy_tree_body_r): Same.\n\t(declare_return_variable): Same.\n\t(expand_call_inline): Same.\n\t* tree-nested.c (lookup_field_for_decl): Same.\n\t* tree-sra.c (create_access_replacement): Same.\n\t(generate_subtree_copies): Same.\n\t* tree-ssa-ccp.c (pass_post_ipa_warn::execute): Same.\n\t* tree-ssa-forwprop.c (combine_cond_expr_cond): Same.\n\t* tree-ssa-loop-ch.c (ch_base::copy_headers): Same.\n\t* tree-ssa-loop-im.c (execute_sm): Same.\n\t* tree-ssa-phiopt.c (cond_store_replacement): Same.\n\t* tree-ssa-strlen.c (maybe_warn_overflow): Same.\n\t(handle_builtin_strcpy): Same.\n\t(maybe_diag_stxncpy_trunc): Same.\n\t(handle_builtin_stxncpy_strncat): Same.\n\t(handle_builtin_strcat): Same.\n\t* tree-ssa-uninit.c (get_no_uninit_warning): Same.\n\t(set_no_uninit_warning): Same.\n\t(uninit_undefined_value_p): Same.\n\t(warn_uninit): Same.\n\t(maybe_warn_operand): Same.\n\t* tree-vrp.c (compare_values_warnv): Same.\n\t* vr-values.c (vr_values::extract_range_for_var_from_comparison_expr): Same.\n\t(test_for_singularity): Same.\n\n\t* gimple.h (warning_suppressed_p): New function.\n\t(suppress_warning): Same.\n\t(copy_no_warning): Same.\n\t(gimple_set_block): Call gimple_set_location.\n\t(gimple_set_location): Call copy_warning.", "tree": {"sha": "1cefadb261cd37cdf95da17157209feab279dbb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cefadb261cd37cdf95da17157209feab279dbb8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9e2bad7251477db92ab9ebcdc010f9282dd9890", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9e2bad7251477db92ab9ebcdc010f9282dd9890", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9e2bad7251477db92ab9ebcdc010f9282dd9890", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9e2bad7251477db92ab9ebcdc010f9282dd9890/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65870e75616ee4359d1c13b99be794e6a577bc65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65870e75616ee4359d1c13b99be794e6a577bc65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65870e75616ee4359d1c13b99be794e6a577bc65"}], "stats": {"total": 652, "additions": 359, "deletions": 293}, "files": [{"sha": "e5e39386a93dc6e28fff0f7d31e5048003459378", "filename": "gcc/builtins.c", "status": "modified", "additions": 48, "deletions": 42, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -1095,7 +1095,9 @@ warn_string_no_nul (location_t loc, tree expr, const char *fname,\n \t\t    bool exact /* = false */,\n \t\t    const wide_int bndrng[2] /* = NULL */)\n {\n-  if ((expr && TREE_NO_WARNING (expr)) || TREE_NO_WARNING (arg))\n+  const opt_code opt = OPT_Wstringop_overread;\n+  if ((expr && warning_suppressed_p (expr, opt))\n+      || warning_suppressed_p (arg, opt))\n     return;\n \n   loc = expansion_point_location_if_in_system_header (loc);\n@@ -1123,14 +1125,14 @@ warn_string_no_nul (location_t loc, tree expr, const char *fname,\n       if (bndrng)\n \t{\n \t  if (wi::ltu_p (maxsiz, bndrng[0]))\n-\t    warned = warning_at (loc, OPT_Wstringop_overread,\n+\t    warned = warning_at (loc, opt,\n \t\t\t\t \"%K%qD specified bound %s exceeds \"\n \t\t\t\t \"maximum object size %E\",\n \t\t\t\t expr, func, bndstr, maxobjsize);\n \t  else\n \t    {\n \t      bool maybe = wi::to_wide (size) == bndrng[0];\n-\t      warned = warning_at (loc, OPT_Wstringop_overread,\n+\t      warned = warning_at (loc, opt,\n \t\t\t\t   exact\n \t\t\t\t   ? G_(\"%K%qD specified bound %s exceeds \"\n \t\t\t\t\t\"the size %E of unterminated array\")\n@@ -1145,7 +1147,7 @@ warn_string_no_nul (location_t loc, tree expr, const char *fname,\n \t    }\n \t}\n       else\n-\twarned = warning_at (loc, OPT_Wstringop_overread,\n+\twarned = warning_at (loc, opt,\n \t\t\t     \"%K%qD argument missing terminating nul\",\n \t\t\t     expr, func);\n     }\n@@ -1154,14 +1156,14 @@ warn_string_no_nul (location_t loc, tree expr, const char *fname,\n       if (bndrng)\n \t{\n \t  if (wi::ltu_p (maxsiz, bndrng[0]))\n-\t    warned = warning_at (loc, OPT_Wstringop_overread,\n+\t    warned = warning_at (loc, opt,\n \t\t\t\t \"%qs specified bound %s exceeds \"\n \t\t\t\t \"maximum object size %E\",\n \t\t\t\t fname, bndstr, maxobjsize);\n \t  else\n \t    {\n \t      bool maybe = wi::to_wide (size) == bndrng[0];\n-\t      warned = warning_at (loc, OPT_Wstringop_overread,\n+\t      warned = warning_at (loc, opt,\n \t\t\t\t   exact\n \t\t\t\t   ? G_(\"%qs specified bound %s exceeds \"\n \t\t\t\t\t\"the size %E of unterminated array\")\n@@ -1176,7 +1178,7 @@ warn_string_no_nul (location_t loc, tree expr, const char *fname,\n \t    }\n \t}\n       else\n-\twarned = warning_at (loc, OPT_Wstringop_overread,\n+\twarned = warning_at (loc, opt,\n \t\t\t     \"%qs argument missing terminating nul\",\n \t\t\t     fname);\n     }\n@@ -1185,9 +1187,9 @@ warn_string_no_nul (location_t loc, tree expr, const char *fname,\n     {\n       inform (DECL_SOURCE_LOCATION (decl),\n \t      \"referenced argument declared here\");\n-      TREE_NO_WARNING (arg) = 1;\n+      suppress_warning (arg, opt);\n       if (expr)\n-\tTREE_NO_WARNING (expr) = 1;\n+\tsuppress_warning (expr, opt);\n     }\n }\n \n@@ -1445,14 +1447,14 @@ c_strlen (tree arg, int only_value, c_strlen_data *data, unsigned eltsize)\n     {\n       /* Suppress multiple warnings for propagated constant strings.  */\n       if (only_value != 2\n-\t  && !TREE_NO_WARNING (arg)\n+\t  && !warning_suppressed_p (arg, OPT_Warray_bounds)\n \t  && warning_at (loc, OPT_Warray_bounds,\n \t\t\t \"offset %qwi outside bounds of constant string\",\n \t\t\t eltoff))\n \t{\n \t  if (decl)\n \t    inform (DECL_SOURCE_LOCATION (decl), \"%qE declared here\", decl);\n-\t  TREE_NO_WARNING (arg) = 1;\n+\t  suppress_warning (arg, OPT_Warray_bounds);\n \t}\n       return NULL_TREE;\n     }\n@@ -3947,10 +3949,10 @@ determine_block_size (tree len, rtx len_rtx,\n    accessing an object with SIZE.  */\n \n static bool\n-maybe_warn_for_bound (int opt, location_t loc, tree exp, tree func,\n+maybe_warn_for_bound (opt_code opt, location_t loc, tree exp, tree func,\n \t\t      tree bndrng[2], tree size, const access_data *pad = NULL)\n {\n-  if (!bndrng[0] || TREE_NO_WARNING (exp))\n+  if (!bndrng[0] || warning_suppressed_p (exp, opt))\n     return false;\n \n   tree maxobjsize = max_object_size ();\n@@ -4042,7 +4044,7 @@ maybe_warn_for_bound (int opt, location_t loc, tree exp, tree func,\n \t\tinform (EXPR_LOCATION (pad->src.ref),\n \t\t\t\"source object allocated here\");\n \t    }\n-\t  TREE_NO_WARNING (exp) = true;\n+\t  suppress_warning (exp, opt);\n \t}\n \n       return warned;\n@@ -4089,14 +4091,14 @@ maybe_warn_for_bound (int opt, location_t loc, tree exp, tree func,\n     return false;\n   else if (tree_int_cst_equal (bndrng[0], bndrng[1]))\n     warned = (func\n-\t      ? warning_at (loc, OPT_Wstringop_overflow_,\n+\t      ? warning_at (loc, opt,\n \t\t\t    (maybe\n \t\t\t     ? G_(\"%K%qD specified bound %E may exceed \"\n \t\t\t\t  \"destination size %E\")\n \t\t\t     : G_(\"%K%qD specified bound %E exceeds \"\n \t\t\t\t  \"destination size %E\")),\n \t\t\t    exp, func, bndrng[0], size)\n-\t      : warning_at (loc, OPT_Wstringop_overflow_,\n+\t      : warning_at (loc, opt,\n \t\t\t    (maybe\n \t\t\t     ? G_(\"%Kspecified bound %E may exceed \"\n \t\t\t\t  \"destination size %E\")\n@@ -4105,14 +4107,14 @@ maybe_warn_for_bound (int opt, location_t loc, tree exp, tree func,\n \t\t\t    exp, bndrng[0], size));\n   else\n     warned = (func\n-\t      ? warning_at (loc, OPT_Wstringop_overflow_,\n+\t      ? warning_at (loc, opt,\n \t\t\t    (maybe\n \t\t\t     ? G_(\"%K%qD specified bound [%E, %E] may exceed \"\n \t\t\t\t  \"destination size %E\")\n \t\t\t     : G_(\"%K%qD specified bound [%E, %E] exceeds \"\n \t\t\t\t  \"destination size %E\")),\n \t\t\t    exp, func, bndrng[0], bndrng[1], size)\n-\t      : warning_at (loc, OPT_Wstringop_overflow_,\n+\t      : warning_at (loc, opt,\n \t\t\t    (maybe\n \t\t\t     ? G_(\"%Kspecified bound [%E, %E] exceeds \"\n \t\t\t\t  \"destination size %E\")\n@@ -4131,7 +4133,7 @@ maybe_warn_for_bound (int opt, location_t loc, tree exp, tree func,\n \t    inform (EXPR_LOCATION (pad->dst.ref),\n \t\t    \"destination object allocated here\");\n \t}\n-      TREE_NO_WARNING (exp) = true;\n+      suppress_warning (exp, opt);\n     }\n \n   return warned;\n@@ -4357,7 +4359,7 @@ warn_for_access (location_t loc, tree func, tree exp, int opt, tree range[2],\n \t\t\t\texp, range[0], range[1], size));\n \n       if (warned)\n-\tTREE_NO_WARNING (exp) = true;\n+\tsuppress_warning (exp, OPT_Wstringop_overread);\n \n       return warned;\n     }\n@@ -4400,7 +4402,7 @@ warn_for_access (location_t loc, tree func, tree exp, int opt, tree range[2],\n \t\t\t    exp, range[0], range[1], size));\n \n   if (warned)\n-    TREE_NO_WARNING (exp) = true;\n+    suppress_warning (exp, OPT_Wstringop_overread);\n \n   return warned;\n }\n@@ -4779,8 +4781,10 @@ check_access (tree exp, tree dstwrite,\n \t\t  && tree_fits_uhwi_p (dstwrite)\n \t\t  && tree_int_cst_lt (dstwrite, range[0]))))\n \t{\n-\t  if (TREE_NO_WARNING (exp)\n-\t      || (pad && pad->dst.ref && TREE_NO_WARNING (pad->dst.ref)))\n+\t  const opt_code opt = OPT_Wstringop_overflow_;\n+\t  if (warning_suppressed_p (exp, opt)\n+\t      || (pad && pad->dst.ref\n+\t\t  && warning_suppressed_p (pad->dst.ref, opt)))\n \t    return false;\n \n \t  location_t loc = tree_inlined_location (exp);\n@@ -4791,12 +4795,12 @@ check_access (tree exp, tree dstwrite,\n \t\t and a source of unknown length.  The call will write\n \t\t at least one byte past the end of the destination.  */\n \t      warned = (func\n-\t\t\t? warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t? warning_at (loc, opt,\n \t\t\t\t      \"%K%qD writing %E or more bytes into \"\n \t\t\t\t      \"a region of size %E overflows \"\n \t\t\t\t      \"the destination\",\n \t\t\t\t      exp, func, range[0], dstsize)\n-\t\t\t: warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t: warning_at (loc, opt,\n \t\t\t\t      \"%Kwriting %E or more bytes into \"\n \t\t\t\t      \"a region of size %E overflows \"\n \t\t\t\t      \"the destination\",\n@@ -4817,7 +4821,7 @@ check_access (tree exp, tree dstwrite,\n \n \t  if (warned)\n \t    {\n-\t      TREE_NO_WARNING (exp) = true;\n+\t      suppress_warning (exp, OPT_Wstringop_overflow_);\n \t      if (pad)\n \t\tpad->dst.inform_access (pad->mode);\n \t    }\n@@ -4852,9 +4856,9 @@ check_access (tree exp, tree dstwrite,\n \n \t  if (size != maxobjsize && tree_int_cst_lt (size, range[0]))\n \t    {\n-\t      int opt = (dstwrite || mode != access_read_only\n-\t\t\t ? OPT_Wstringop_overflow_\n-\t\t\t : OPT_Wstringop_overread);\n+\t      opt_code opt = (dstwrite || mode != access_read_only\n+\t\t\t      ? OPT_Wstringop_overflow_\n+\t\t\t      : OPT_Wstringop_overread);\n \t      maybe_warn_for_bound (opt, loc, exp, func, range, size, pad);\n \t      return false;\n \t    }\n@@ -4890,19 +4894,21 @@ check_access (tree exp, tree dstwrite,\n \n   if (overread)\n     {\n-      if (TREE_NO_WARNING (exp)\n-\t  || (srcstr && TREE_NO_WARNING (srcstr))\n-\t  || (pad && pad->src.ref && TREE_NO_WARNING (pad->src.ref)))\n+      const opt_code opt = OPT_Wstringop_overread;\n+      if (warning_suppressed_p (exp, opt)\n+\t  || (srcstr && warning_suppressed_p (srcstr, opt))\n+\t  || (pad && pad->src.ref\n+\t      && warning_suppressed_p (pad->src.ref, opt)))\n \treturn false;\n \n       location_t loc = tree_inlined_location (exp);\n       const bool read\n \t= mode == access_read_only || mode == access_read_write;\n       const bool maybe = pad && pad->dst.parmarray;\n-      if (warn_for_access (loc, func, exp, OPT_Wstringop_overread, range,\n-\t\t\t   slen, false, read, maybe))\n+      if (warn_for_access (loc, func, exp, opt, range, slen, false, read,\n+\t\t\t   maybe))\n \t{\n-\t  TREE_NO_WARNING (exp) = true;\n+\t  suppress_warning (exp, opt);\n \t  if (pad)\n \t    pad->src.inform_access (access_read_only);\n \t}\n@@ -7462,8 +7468,7 @@ expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n   /* Expand the library call ourselves using a stabilized argument\n      list to avoid re-evaluating the function's arguments twice.  */\n   tree call = build_call_nofold_loc (loc, fndecl, 3, arg1, arg2, len);\n-  if (TREE_NO_WARNING (exp))\n-    TREE_NO_WARNING (call) = true;\n+  copy_warning (call, exp);\n   gcc_assert (TREE_CODE (call) == CALL_EXPR);\n   CALL_EXPR_TAILCALL (call) = CALL_EXPR_TAILCALL (exp);\n   return expand_call (call, target, target == const0_rtx);\n@@ -13898,10 +13903,11 @@ maybe_emit_free_warning (tree exp)\n \t      else\n \t\t{\n \t\t  tree alloc_decl = gimple_call_fndecl (def_stmt);\n-\t\t  int opt = (DECL_IS_OPERATOR_NEW_P (alloc_decl)\n-\t\t\t     || DECL_IS_OPERATOR_DELETE_P (dealloc_decl)\n-\t\t\t     ? OPT_Wmismatched_new_delete\n-\t\t\t     : OPT_Wmismatched_dealloc);\n+\t\t  const opt_code opt =\n+\t\t    (DECL_IS_OPERATOR_NEW_P (alloc_decl)\n+\t\t     || DECL_IS_OPERATOR_DELETE_P (dealloc_decl)\n+\t\t     ? OPT_Wmismatched_new_delete\n+\t\t     : OPT_Wmismatched_dealloc);\n \t\t  warned = warning_at (loc, opt,\n \t\t\t\t       \"%K%qD called on pointer returned \"\n \t\t\t\t       \"from a mismatched allocation \"\n@@ -14012,7 +14018,7 @@ fold_builtin_varargs (location_t loc, tree fndecl, tree *args, int nargs)\n     {\n       ret = build1 (NOP_EXPR, TREE_TYPE (ret), ret);\n       SET_EXPR_LOCATION (ret, loc);\n-      TREE_NO_WARNING (ret) = 1;\n+      suppress_warning (ret);\n       return ret;\n     }\n   return NULL_TREE;"}, {"sha": "27e8c4516353aa8972894fca8a245489f1863204", "filename": "gcc/calls.c", "status": "modified", "additions": 47, "deletions": 43, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -1623,7 +1623,7 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n   if (!fndecl || !fndecl_built_in_p (fndecl, BUILT_IN_NORMAL))\n     return false;\n \n-  if (TREE_NO_WARNING (exp) || !warn_stringop_overread)\n+  if (!warn_stringop_overread || warning_suppressed_p (exp, OPT_Wstringop_overread))\n     return false;\n \n   /* Avoid clearly invalid calls (more checking done below).  */\n@@ -1739,7 +1739,7 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n \t\t\t\t exp, fndecl, bndrng[0], bndrng[1],\n \t\t\t\t maxobjsize);\n \t  if (warned)\n-\t    TREE_NO_WARNING (exp) = true;\n+\t    suppress_warning (exp, OPT_Wstringop_overread);\n \n \t  return warned;\n \t}\n@@ -1916,7 +1916,7 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n     }\n \n   if (any_arg_warned)\n-    TREE_NO_WARNING (exp) = true;\n+    suppress_warning (exp, OPT_Wstringop_overread);\n \n   return any_arg_warned;\n }\n@@ -1979,7 +1979,7 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n \n   /* Set if a warning has been issued for any argument (used to decide\n      whether to emit an informational note at the end).  */\n-  bool any_warned = false;\n+  opt_code opt_warned = N_OPTS;\n \n   /* A string describing the attributes that the warnings issued by this\n      function apply to.  Used to print one informational note per function\n@@ -2054,7 +2054,7 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n \t*sizstr = '\\0';\n \n       /* Set if a warning has been issued for the current argument.  */\n-      bool arg_warned = false;\n+      opt_code arg_warned = N_OPTS;\n       location_t loc = EXPR_LOCATION (exp);\n       tree ptr = access.second.ptr;\n       if (*sizstr\n@@ -2067,24 +2067,25 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n \t      const std::string argtypestr\n \t\t= access.second.array_as_string (ptrtype);\n \n-\t      arg_warned = warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t\t       \"%Kbound argument %i value %s is \"\n-\t\t\t\t       \"negative for a variable length array \"\n-\t\t\t\t       \"argument %i of type %s\",\n-\t\t\t\t       exp, sizidx + 1, sizstr,\n-\t\t\t\t       ptridx + 1, argtypestr.c_str ());\n+\t      if (warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t      \"%Kbound argument %i value %s is \"\n+\t\t\t      \"negative for a variable length array \"\n+\t\t\t      \"argument %i of type %s\",\n+\t\t\t      exp, sizidx + 1, sizstr,\n+\t\t\t      ptridx + 1, argtypestr.c_str ()))\n+\t\targ_warned = OPT_Wstringop_overflow_;\n \t    }\n-\t  else\n-\t    arg_warned = warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t\t     \"%Kargument %i value %s is negative\",\n-\t\t\t\t     exp, sizidx + 1, sizstr);\n+\t  else if (warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t       \"%Kargument %i value %s is negative\",\n+\t\t\t       exp, sizidx + 1, sizstr))\n+\t    arg_warned = OPT_Wstringop_overflow_;\n \n-\t  if (arg_warned)\n+\t  if (arg_warned != N_OPTS)\n \t    {\n \t      append_attrname (access, attrstr, sizeof attrstr);\n \t      /* Remember a warning has been issued and avoid warning\n \t\t again below for the same attribute.  */\n-\t      any_warned = true;\n+\t      opt_warned = arg_warned;\n \t      continue;\n \t    }\n \t}\n@@ -2122,39 +2123,41 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n \t\t  const std::string argtypestr\n \t\t    = access.second.array_as_string (ptrtype);\n \n-\t\t  arg_warned = warning_at (loc, OPT_Wnonnull,\n-\t\t\t\t\t   \"%Kargument %i of variable length \"\n-\t\t\t\t\t   \"array %s is null but \"\n-\t\t\t\t\t   \"the corresponding bound argument \"\n-\t\t\t\t\t   \"%i value is %s\",\n-\t\t\t\t\t   exp, sizidx + 1, argtypestr.c_str (),\n-\t\t\t\t\t   ptridx + 1, sizstr);\n+\t\t  if (warning_at (loc, OPT_Wnonnull,\n+\t\t\t\t  \"%Kargument %i of variable length \"\n+\t\t\t\t  \"array %s is null but \"\n+\t\t\t\t  \"the corresponding bound argument \"\n+\t\t\t\t  \"%i value is %s\",\n+\t\t\t\t  exp, sizidx + 1, argtypestr.c_str (),\n+\t\t\t\t  ptridx + 1, sizstr))\n+\t\t    arg_warned = OPT_Wnonnull;\n \t\t}\n-\t      else\n-\t\targ_warned = warning_at (loc, OPT_Wnonnull,\n-\t\t\t\t\t \"%Kargument %i is null but \"\n-\t\t\t\t\t \"the corresponding size argument \"\n-\t\t\t\t\t \"%i value is %s\",\n-\t\t\t\t\t exp, ptridx + 1, sizidx + 1,\n-\t\t\t\t\t sizstr);\n+\t      else if (warning_at (loc, OPT_Wnonnull,\n+\t\t\t\t   \"%Kargument %i is null but \"\n+\t\t\t\t   \"the corresponding size argument \"\n+\t\t\t\t   \"%i value is %s\",\n+\t\t\t\t   exp, ptridx + 1, sizidx + 1,\n+\t\t\t\t   sizstr))\n+\t\targ_warned = OPT_Wnonnull;\n \t    }\n \t  else if (access_size && access.second.static_p)\n \t    {\n \t      /* Warn about null pointers for [static N] array arguments\n \t\t but do not warn for ordinary (i.e., nonstatic) arrays.  */\n-\t      arg_warned = warning_at (loc, OPT_Wnonnull,\n-\t\t\t\t       \"%Kargument %i to %<%T[static %E]%> \"\n-\t\t\t\t       \"is null where non-null expected\",\n-\t\t\t\t       exp, ptridx + 1, argtype,\n-\t\t\t\t       access_size);\n+\t      if (warning_at (loc, OPT_Wnonnull,\n+\t\t\t      \"%Kargument %i to %<%T[static %E]%> \"\n+\t\t\t      \"is null where non-null expected\",\n+\t\t\t      exp, ptridx + 1, argtype,\n+\t\t\t      access_size))\n+\t\targ_warned = OPT_Wnonnull;\t\t\n \t    }\n \n \t  if (arg_warned)\n \t    {\n \t      append_attrname (access, attrstr, sizeof attrstr);\n \t      /* Remember a warning has been issued and avoid warning\n \t\t again below for the same attribute.  */\n-\t      any_warned = true;\n+\t      opt_warned = OPT_Wnonnull;\n \t      continue;\n \t    }\n \t}\n@@ -2190,17 +2193,17 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n       /* Clear the no-warning bit in case it was set by check_access\n \t in a prior iteration so that accesses via different arguments\n \t are diagnosed.  */\n-      TREE_NO_WARNING (exp) = false;\n+      suppress_warning (exp, OPT_Wstringop_overflow_, false);\n       access_mode mode = data.mode;\n       if (mode == access_deferred)\n \tmode = TYPE_READONLY (argtype) ? access_read_only : access_read_write;\n       check_access (exp, access_size, /*maxread=*/ NULL_TREE, srcsize,\n \t\t    dstsize, mode, &data);\n \n-      if (TREE_NO_WARNING (exp))\n+      if (warning_suppressed_p (exp, OPT_Wstringop_overflow_))\n+\topt_warned = OPT_Wstringop_overflow_;\n+      if (opt_warned != N_OPTS)\n \t{\n-\t  any_warned = true;\n-\n \t  if (access.second.internal_p)\n \t    inform (loc, \"referencing argument %u of type %qT\",\n \t\t    ptridx + 1, ptrtype);\n@@ -2222,7 +2225,7 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n \t\t\"in a call with type %qT and attribute %qs\",\n \t\tfntype, attrstr);\n     }\n-  else if (any_warned)\n+  else if (opt_warned != N_OPTS)\n     {\n       if (fndecl)\n \tinform (DECL_SOURCE_LOCATION (fndecl),\n@@ -2233,7 +2236,8 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n     }\n \n   /* Set the bit in case if was cleared and not set above.  */\n-  TREE_NO_WARNING (exp) = true;\n+  if (opt_warned != N_OPTS)\n+    suppress_warning (exp, opt_warned);\n }\n \n /* Fill in ARGS_SIZE and ARGS array based on the parameters found in"}, {"sha": "3edd53c37dcb367031b1460bc4c6afedd2107f6a", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -2807,9 +2807,6 @@ expand_call_stmt (gcall *stmt)\n   if (gimple_call_nothrow_p (stmt))\n     TREE_NOTHROW (exp) = 1;\n \n-  if (gimple_no_warning_p (stmt))\n-    TREE_NO_WARNING (exp) = 1;\n-\n   CALL_EXPR_TAILCALL (exp) = gimple_call_tail_p (stmt);\n   CALL_EXPR_MUST_TAIL_CALL (exp) = gimple_call_must_tail_p (stmt);\n   CALL_EXPR_RETURN_SLOT_OPT (exp) = gimple_call_return_slot_opt_p (stmt);\n@@ -2823,6 +2820,9 @@ expand_call_stmt (gcall *stmt)\n   CALL_EXPR_BY_DESCRIPTOR (exp) = gimple_call_by_descriptor_p (stmt);\n   SET_EXPR_LOCATION (exp, gimple_location (stmt));\n \n+  /* Must come after copying location.  */\n+  copy_warning (exp, stmt);\n+\n   /* Ensure RTL is created for debug args.  */\n   if (decl && DECL_HAS_DEBUG_ARGS_P (decl))\n     {"}, {"sha": "55cb0347149c4658e603751f41f80f263438381d", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -1074,7 +1074,7 @@ check_global_declaration (symtab_node *snode)\n       && ! DECL_ARTIFICIAL (decl)\n       && ! TREE_PUBLIC (decl))\n     {\n-      if (TREE_NO_WARNING (decl))\n+      if (warning_suppressed_p (decl, OPT_Wunused))\n \t;\n       else if (snode->referred_to_p (/*include_self=*/false))\n \tpedwarn (input_location, 0, \"%q+F used but never defined\", decl);"}, {"sha": "3aafbc98800b0a9229d944d9c22be8aa2eb72467", "filename": "gcc/fold-const.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -250,7 +250,7 @@ fold_undefer_overflow_warnings (bool issue, const gimple *stmt, int code)\n   if (!issue || warnmsg == NULL)\n     return;\n \n-  if (gimple_no_warning_p (stmt))\n+  if (warning_suppressed_p (stmt, OPT_Wstrict_overflow))\n     return;\n \n   /* Use the smallest code level when deciding to issue the\n@@ -4250,8 +4250,7 @@ fold_truth_not_expr (location_t loc, tree arg)\n \n       tree ret = build2_loc (loc, code, type, TREE_OPERAND (arg, 0),\n \t\t\t     TREE_OPERAND (arg, 1));\n-      if (TREE_NO_WARNING (arg))\n-\tTREE_NO_WARNING (ret) = 1;\n+      copy_warning (ret, arg);\n       return ret;\n     }\n \n@@ -9346,7 +9345,7 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n \t  tem = fold_build1_loc (loc, code, type, TREE_OPERAND (op0, 1));\n \t  /* First do the assignment, then return converted constant.  */\n \t  tem = build2_loc (loc, COMPOUND_EXPR, TREE_TYPE (tem), op0, tem);\n-\t  TREE_NO_WARNING (tem) = 1;\n+\t  suppress_warning (tem /* What warning? */);\n \t  TREE_USED (tem) = 1;\n \t  return tem;\n \t}\n@@ -13519,10 +13518,10 @@ fold_checksum_tree (const_tree expr, struct md5_ctx *ctx,\n \t  TYPE_CACHED_VALUES (tmp) = NULL;\n \t}\n     }\n-  else if (TREE_NO_WARNING (expr) && (DECL_P (expr) || EXPR_P (expr)))\n+  else if (warning_suppressed_p (expr) && (DECL_P (expr) || EXPR_P (expr)))\n     {\n-      /* Allow TREE_NO_WARNING to be set.  Perhaps we shouldn't allow that\n-\t and change builtins.c etc. instead - see PR89543.  */\n+      /* Allow the no-warning bit to be set.  Perhaps we shouldn't allow\n+\t that and change builtins.c etc. instead - see PR89543.  */\n       size_t sz = tree_size (expr);\n       buf = XALLOCAVAR (union tree_node, sz);\n       memcpy ((char *) buf, expr, sz);"}, {"sha": "13f08685f8f905408c885aa5a4f821b6aaad0a8b", "filename": "gcc/gimple-array-bounds.cc", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple-array-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple-array-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-array-bounds.cc?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -175,7 +175,7 @@ bool\n array_bounds_checker::check_array_ref (location_t location, tree ref,\n \t\t\t\t       bool ignore_off_by_one)\n {\n-  if (TREE_NO_WARNING (ref))\n+  if (warning_suppressed_p (ref, OPT_Warray_bounds))\n     /* Return true to have the caller prevent warnings for enclosing\n        refs.  */\n     return true;\n@@ -346,7 +346,7 @@ array_bounds_checker::check_array_ref (location_t location, tree ref,\n       /* Avoid more warnings when checking more significant subscripts\n \t of the same expression.  */\n       ref = TREE_OPERAND (ref, 0);\n-      TREE_NO_WARNING (ref) = 1;\n+      suppress_warning (ref, OPT_Warray_bounds);\n \n       if (decl)\n \tref = decl;\n@@ -411,7 +411,7 @@ bool\n array_bounds_checker::check_mem_ref (location_t location, tree ref,\n \t\t\t\t     bool ignore_off_by_one)\n {\n-  if (TREE_NO_WARNING (ref))\n+  if (warning_suppressed_p (ref, OPT_Warray_bounds))\n     return false;\n \n   tree arg = TREE_OPERAND (ref, 0);\n@@ -770,7 +770,7 @@ array_bounds_checker::check_mem_ref (location_t location, tree ref,\n \t    }\n \t}\n \n-      TREE_NO_WARNING (ref) = 1;\n+      suppress_warning (ref, OPT_Warray_bounds);\n       return true;\n     }\n \n@@ -787,7 +787,7 @@ array_bounds_checker::check_mem_ref (location_t location, tree ref,\n \t\t      \"intermediate array offset %wi is outside array bounds \"\n \t\t      \"of %qT\", tmpidx, reftype))\n \t{\n-\t  TREE_NO_WARNING (ref) = 1;\n+\t  suppress_warning (ref, OPT_Warray_bounds);\n \t  return true;\n \t}\n     }\n@@ -818,15 +818,15 @@ array_bounds_checker::check_addr_expr (location_t location, tree t)\n \twarned = check_mem_ref (location, t, ignore_off_by_one);\n \n       if (warned)\n-\tTREE_NO_WARNING (t) = true;\n+\tsuppress_warning (t, OPT_Warray_bounds);\n \n       t = TREE_OPERAND (t, 0);\n     }\n   while (handled_component_p (t) || TREE_CODE (t) == MEM_REF);\n \n   if (TREE_CODE (t) != MEM_REF\n       || TREE_CODE (TREE_OPERAND (t, 0)) != ADDR_EXPR\n-      || TREE_NO_WARNING (t))\n+      || warning_suppressed_p (t, OPT_Warray_bounds))\n     return;\n \n   tree tem = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n@@ -886,7 +886,7 @@ array_bounds_checker::check_addr_expr (location_t location, tree t)\n       if (DECL_P (t))\n \tinform (DECL_SOURCE_LOCATION (t), \"while referencing %qD\", t);\n \n-      TREE_NO_WARNING (t) = 1;\n+      suppress_warning (t, OPT_Warray_bounds);\n     }\n }\n \n@@ -980,9 +980,10 @@ array_bounds_checker::check_array_bounds (tree *tp, int *walk_subtree,\n        See pr98266 and pr97595.  */\n     *walk_subtree = false;\n \n-  /* Propagate the no-warning bit to the outer expression.  */\n+  /* Propagate the no-warning bit to the outer statement to avoid also\n+     issuing -Wstringop-overflow/-overread for the out-of-bounds accesses.  */\n   if (warned)\n-    TREE_NO_WARNING (t) = true;\n+    suppress_warning (wi->stmt, OPT_Warray_bounds);\n \n   return NULL_TREE;\n }"}, {"sha": "a2563a45c37dff400b0810c2f6b6c9968107d120", "filename": "gcc/gimple-expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-expr.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -377,7 +377,6 @@ copy_var_decl (tree var, tree name, tree type)\n   DECL_ARTIFICIAL (copy) = DECL_ARTIFICIAL (var);\n   DECL_IGNORED_P (copy) = DECL_IGNORED_P (var);\n   DECL_CONTEXT (copy) = DECL_CONTEXT (var);\n-  TREE_NO_WARNING (copy) = TREE_NO_WARNING (var);\n   TREE_USED (copy) = 1;\n   DECL_SEEN_IN_BIND_EXPR_P (copy) = 1;\n   DECL_ATTRIBUTES (copy) = DECL_ATTRIBUTES (var);\n@@ -387,6 +386,7 @@ copy_var_decl (tree var, tree name, tree type)\n       DECL_USER_ALIGN (copy) = 1;\n     }\n \n+  copy_warning (copy, var);\n   return copy;\n }\n "}, {"sha": "68031538145b31d4c97d263dfe5d4a10adebfbe5", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -2044,7 +2044,7 @@ gimple_fold_builtin_strcpy (gimple_stmt_iterator *gsi,\n \t not point to objects and so do not indicate an overlap;\n \t such calls could be the result of sanitization and jump\n \t threading).  */\n-      if (!integer_zerop (dest) && !gimple_no_warning_p (stmt))\n+      if (!integer_zerop (dest) && !warning_suppressed_p (stmt, OPT_Wrestrict))\n \t{\n \t  tree func = gimple_call_fndecl (stmt);\n \n@@ -2071,9 +2071,9 @@ gimple_fold_builtin_strcpy (gimple_stmt_iterator *gsi,\n   if (nonstr)\n     {\n       /* Avoid folding calls with unterminated arrays.  */\n-      if (!gimple_no_warning_p (stmt))\n+      if (!warning_suppressed_p (stmt, OPT_Wstringop_overread))\n \twarn_string_no_nul (loc, NULL_TREE, \"strcpy\", src, nonstr);\n-      gimple_set_no_warning (stmt, true);\n+      suppress_warning (stmt, OPT_Wstringop_overread);\n       return false;\n     }\n \n@@ -2481,7 +2481,7 @@ gimple_fold_builtin_strncat (gimple_stmt_iterator *gsi)\n \n   unsigned HOST_WIDE_INT dstsize;\n \n-  bool nowarn = gimple_no_warning_p (stmt);\n+  bool nowarn = warning_suppressed_p (stmt, OPT_Wstringop_overflow_);\n \n   if (!nowarn && compute_builtin_object_size (dst, 1, &dstsize))\n     {\n@@ -2504,7 +2504,7 @@ gimple_fold_builtin_strncat (gimple_stmt_iterator *gsi)\n \t\t\t\t    \"destination size %wu\"),\n \t\t\t       stmt, fndecl, len, dstsize);\n \t  if (nowarn)\n-\t    gimple_set_no_warning (stmt, true);\n+\t    suppress_warning (stmt, OPT_Wstringop_overflow_);\n \t}\n     }\n \n@@ -2520,7 +2520,7 @@ gimple_fold_builtin_strncat (gimple_stmt_iterator *gsi)\n       if (warning_at (loc, OPT_Wstringop_overflow_,\n \t\t      \"%G%qD specified bound %E equals source length\",\n \t\t      stmt, fndecl, len))\n-\tgimple_set_no_warning (stmt, true);\n+\tsuppress_warning (stmt, OPT_Wstringop_overflow_);\n     }\n \n   tree fn = builtin_decl_implicit (BUILT_IN_STRCAT);\n@@ -3105,7 +3105,8 @@ gimple_fold_builtin_stxcpy_chk (gimple_stmt_iterator *gsi,\n \t not point to objects and so do not indicate an overlap;\n \t such calls could be the result of sanitization and jump\n \t threading).  */\n-      if (!integer_zerop (dest) && !gimple_no_warning_p (stmt))\n+      if (!integer_zerop (dest)\n+\t  && !warning_suppressed_p (stmt, OPT_Wrestrict))\n \t{\n \t  tree func = gimple_call_fndecl (stmt);\n \n@@ -3288,10 +3289,10 @@ gimple_fold_builtin_stpcpy (gimple_stmt_iterator *gsi)\n   if (data.decl)\n     {\n       /* Avoid folding calls with unterminated arrays.  */\n-      if (!gimple_no_warning_p (stmt))\n+      if (!warning_suppressed_p (stmt, OPT_Wstringop_overread))\n \twarn_string_no_nul (loc, NULL_TREE, \"stpcpy\", src, data.decl, size,\n \t\t\t    exact);\n-      gimple_set_no_warning (stmt, true);\n+      suppress_warning (stmt, OPT_Wstringop_overread);\n       return false;\n     }\n \n@@ -3554,8 +3555,7 @@ gimple_fold_builtin_sprintf (gimple_stmt_iterator *gsi)\n \n       /* Propagate the NO_WARNING bit to avoid issuing the same\n \t warning more than once.  */\n-      if (gimple_no_warning_p (stmt))\n-\tgimple_set_no_warning (repl, true);\n+      copy_warning (repl, stmt);\n \n       gimple_seq_add_stmt_without_update (&stmts, repl);\n       if (tree lhs = gimple_call_lhs (stmt))\n@@ -3606,8 +3606,7 @@ gimple_fold_builtin_sprintf (gimple_stmt_iterator *gsi)\n \n       /* Propagate the NO_WARNING bit to avoid issuing the same\n \t warning more than once.  */\n-      if (gimple_no_warning_p (stmt))\n-\tgimple_set_no_warning (repl, true);\n+      copy_warning (repl, stmt);\n \n       gimple_seq_add_stmt_without_update (&stmts, repl);\n       if (tree lhs = gimple_call_lhs (stmt))\n@@ -6065,7 +6064,7 @@ fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace, tree (*valueize) (tree))\n {\n   bool changed = false;\n   gimple *stmt = gsi_stmt (*gsi);\n-  bool nowarning = gimple_no_warning_p (stmt);\n+  bool nowarning = warning_suppressed_p (stmt, OPT_Wstrict_overflow);\n   unsigned i;\n   fold_defer_overflow_warnings ();\n "}, {"sha": "2dafe849ad3f30ad0e165e5f69a4306a0aaebbe9", "filename": "gcc/gimple-ssa-isolate-paths.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple-ssa-isolate-paths.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple-ssa-isolate-paths.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-isolate-paths.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -400,6 +400,11 @@ diag_returned_locals (bool maybe, const locmap_t &locmap)\n       gimple *stmt = (*it).first;\n       const args_loc_t &argsloc = (*it).second;\n       location_t stmtloc = gimple_location (stmt);\n+      if (stmtloc == UNKNOWN_LOCATION)\n+\t/* When multiple return statements are merged into one it\n+\t   may not have an associated location.  Use the location\n+\t   of the closing brace instead.  */\n+\tstmtloc = cfun->function_end_locus;\n \n       auto_diagnostic_group d;\n       unsigned nargs = argsloc.locvec.length ();"}, {"sha": "f2757b66b284c12f834345a21b8e29321c3b29f2", "filename": "gcc/gimple-ssa-nonnull-compare.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple-ssa-nonnull-compare.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple-ssa-nonnull-compare.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-nonnull-compare.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -97,7 +97,7 @@ do_warn_nonnull_compare (function *fun, tree arg)\n       if (op\n \t  && (POINTER_TYPE_P (TREE_TYPE (arg))\n \t      ? integer_zerop (op) : integer_minus_onep (op))\n-\t  && !gimple_no_warning_p (stmt))\n+\t  && !warning_suppressed_p (stmt, OPT_Wnonnull_compare))\n \twarning_at (loc, OPT_Wnonnull_compare,\n \t\t    \"%<nonnull%> argument %qD compared to NULL\", arg);\n     }"}, {"sha": "41e3be6f9f4b665902d39862cd63c8eb87ecd61b", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -330,7 +330,8 @@ get_format_string (tree format, location_t *ploc)\n static bool\n ATTRIBUTE_GCC_DIAG (5, 6)\n fmtwarn (const substring_loc &fmt_loc, location_t param_loc,\n-\t const char *corrected_substring, int opt, const char *gmsgid, ...)\n+\t const char *corrected_substring, opt_code opt,\n+\t const char *gmsgid, ...)\n {\n   format_string_diagnostic_t diag (fmt_loc, NULL, param_loc, NULL,\n \t\t\t\t   corrected_substring);\n@@ -345,7 +346,8 @@ fmtwarn (const substring_loc &fmt_loc, location_t param_loc,\n static bool\n ATTRIBUTE_GCC_DIAG (6, 8) ATTRIBUTE_GCC_DIAG (7, 8)\n fmtwarn_n (const substring_loc &fmt_loc, location_t param_loc,\n-\t   const char *corrected_substring, int opt, unsigned HOST_WIDE_INT n,\n+\t   const char *corrected_substring, opt_code opt,\n+\t   unsigned HOST_WIDE_INT n,\n \t   const char *singular_gmsgid, const char *plural_gmsgid, ...)\n {\n   format_string_diagnostic_t diag (fmt_loc, NULL, param_loc, NULL,\n@@ -921,7 +923,7 @@ struct call_info\n   }\n \n   /* Return the warning option corresponding to the called function.  */\n-  int warnopt () const\n+  opt_code warnopt () const\n   {\n     return bounded ? OPT_Wformat_truncation_ : OPT_Wformat_overflow_;\n   }\n@@ -4680,7 +4682,7 @@ handle_printf_call (gimple_stmt_iterator *gsi, pointer_query &ptr_qry)\n \n   bool success = compute_format_length (info, &res, ptr_qry.rvals);\n   if (res.warned)\n-    gimple_set_no_warning (info.callstmt, true);\n+    suppress_warning (info.callstmt, info.warnopt ());\n \n   /* When optimizing and the printf return value optimization is enabled,\n      attempt to substitute the computed result for the return value of"}, {"sha": "20959acc1c6935cf1d1a4e35e99eee7870868889", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -4339,10 +4339,12 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \t\t      MR_DEPENDENCE_BASE (ops[j]) = base;\n \t\t    }\n \t\t  if (!integer_zerop (mask))\n-\t\t    /* The load might load some bits (that will be masked off\n-\t\t       later on) uninitialized, avoid -W*uninitialized\n-\t\t       warnings in that case.  */\n-\t\t    TREE_NO_WARNING (ops[j]) = 1;\n+\t\t    {\n+\t\t      /* The load might load some bits (that will be masked\n+\t\t\t off later on) uninitialized, avoid -W*uninitialized\n+\t\t\t warnings in that case.  */\n+\t\t      suppress_warning (ops[j], OPT_Wuninitialized);\n+\t\t    }\n \n \t\t  stmt = gimple_build_assign (make_ssa_name (dest_type), ops[j]);\n \t\t  gimple_set_location (stmt, load_loc);\n@@ -4524,7 +4526,7 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \t\t provably uninitialized (no stores at all yet or previous\n \t\t store a CLOBBER) we'd optimize away the load and replace\n \t\t it e.g. with 0.  */\n-\t      TREE_NO_WARNING (load_src) = 1;\n+\t      suppress_warning (load_src, OPT_Wuninitialized);\n \t      stmt = gimple_build_assign (tem, load_src);\n \t      gimple_set_location (stmt, loc);\n \t      gimple_set_vuse (stmt, new_vuse);"}, {"sha": "02771e4cd60367f5ff4037a20427afe923bda222", "filename": "gcc/gimple-ssa-warn-restrict.c", "status": "modified", "additions": 61, "deletions": 53, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple-ssa-warn-restrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple-ssa-warn-restrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -1431,7 +1431,7 @@ maybe_diag_overlap (location_t loc, gimple *call, builtin_access &acs)\n   if (!acs.overlap ())\n     return false;\n \n-  if (gimple_no_warning_p (call))\n+  if (warning_suppressed_p (call, OPT_Wrestrict))\n     return true;\n \n   /* For convenience.  */\n@@ -1680,10 +1680,11 @@ maybe_diag_overlap (location_t loc, gimple *call, builtin_access &acs)\n    be issued, false otherwise.\n    Both initial values of the offsets and their final value computed\n    by the function by incrementing the initial value by the size are\n-   validated.  Return true if the offsets are not valid and a diagnostic\n-   has been issued, or would have been issued if DO_WARN had been true.  */\n+   validated.  Return the warning number if the offsets are not valid\n+   and a diagnostic has been issued, or would have been issued if\n+   DO_WARN had been true, otherwise an invalid warning number.  */\n \n-static bool\n+static opt_code\n maybe_diag_access_bounds (gimple *call, tree func, int strict,\n \t\t\t  const builtin_memref &ref, offset_int wroff,\n \t\t\t  bool do_warn)\n@@ -1695,28 +1696,31 @@ maybe_diag_access_bounds (gimple *call, tree func, int strict,\n      since the result is used to make codegen decisions.  */\n   if (ref.sizrange[0] > maxobjsize)\n     {\n+      const opt_code opt = OPT_Wstringop_overflow_;\n       /* Return true without issuing a warning.  */\n       if (!do_warn)\n-\treturn true;\n+\treturn opt;\n \n-      if (ref.ref && TREE_NO_WARNING (ref.ref))\n-\treturn false;\n+      if (ref.ref && warning_suppressed_p (ref.ref, OPT_Wstringop_overflow_))\n+\treturn no_warning;\n \n+      bool warned = false;\n       if (warn_stringop_overflow)\n \t{\n \t  if (ref.sizrange[0] == ref.sizrange[1])\n-\t    return warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t       \"%G%qD specified bound %wu \"\n-\t\t\t       \"exceeds maximum object size %wu\",\n-\t\t\t       call, func, ref.sizrange[0].to_uhwi (),\n-\t\t\t       maxobjsize.to_uhwi ());\n-\n-\t  return warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t     \"%G%qD specified bound between %wu and %wu \"\n-\t\t\t     \"exceeds maximum object size %wu\",\n-\t\t\t     call, func, ref.sizrange[0].to_uhwi (),\n-\t\t\t     ref.sizrange[1].to_uhwi (),\n-\t\t\t     maxobjsize.to_uhwi ());\n+\t    warned = warning_at (loc, opt,\n+\t\t\t\t \"%G%qD specified bound %wu \"\n+\t\t\t\t \"exceeds maximum object size %wu\",\n+\t\t\t\t call, func, ref.sizrange[0].to_uhwi (),\n+\t\t\t\t maxobjsize.to_uhwi ());\n+\t  else\n+\t    warned = warning_at (loc, opt,\n+\t\t\t\t \"%G%qD specified bound between %wu and %wu \"\n+\t\t\t\t \"exceeds maximum object size %wu\",\n+\t\t\t\t call, func, ref.sizrange[0].to_uhwi (),\n+\t\t\t\t ref.sizrange[1].to_uhwi (),\n+\t\t\t\t maxobjsize.to_uhwi ());\n+\t  return warned ? opt : no_warning;\n \t}\n     }\n \n@@ -1729,18 +1733,19 @@ maybe_diag_access_bounds (gimple *call, tree func, int strict,\n   offset_int ooboff[] = { ref.offrange[0], ref.offrange[1], wroff };\n   tree oobref = ref.offset_out_of_bounds (strict, ooboff);\n   if (!oobref)\n-    return false;\n+    return no_warning;\n \n+  const opt_code opt = OPT_Warray_bounds;\n   /* Return true without issuing a warning.  */\n   if (!do_warn)\n-    return true;\n+    return opt;\n \n   if (!warn_array_bounds)\n-    return false;\n+    return no_warning;\n \n-  if (TREE_NO_WARNING (ref.ptr)\n-      || (ref.ref && TREE_NO_WARNING (ref.ref)))\n-    return false;\n+  if (warning_suppressed_p (ref.ptr, opt)\n+      || (ref.ref && warning_suppressed_p (ref.ref, opt)))\n+    return no_warning;\n \n   char rangestr[2][64];\n   if (ooboff[0] == ooboff[1]\n@@ -1770,7 +1775,7 @@ maybe_diag_access_bounds (gimple *call, tree func, int strict,\n \t  && TREE_CODE (type = TREE_TYPE (ref.base)) == ARRAY_TYPE)\n \t{\n \t  auto_diagnostic_group d;\n-\t  if (warning_at (loc, OPT_Warray_bounds,\n+\t  if (warning_at (loc, opt,\n \t\t\t  \"%G%qD pointer overflow between offset %s \"\n \t\t\t  \"and size %s accessing array %qD with type %qT\",\n \t\t\t  call, func, rangestr[0], rangestr[1], ref.base, type))\n@@ -1780,13 +1785,13 @@ maybe_diag_access_bounds (gimple *call, tree func, int strict,\n \t      warned = true;\n \t    }\n \t  else\n-\t    warned = warning_at (loc, OPT_Warray_bounds,\n+\t    warned = warning_at (loc, opt,\n \t\t\t\t \"%G%qD pointer overflow between offset %s \"\n \t\t\t\t \"and size %s\",\n \t\t\t\t call, func, rangestr[0], rangestr[1]);\n \t}\n       else\n-\twarned = warning_at (loc, OPT_Warray_bounds,\n+\twarned = warning_at (loc, opt,\n \t\t\t     \"%G%qD pointer overflow between offset %s \"\n \t\t\t     \"and size %s\",\n \t\t\t     call, func, rangestr[0], rangestr[1]);\n@@ -1802,7 +1807,7 @@ maybe_diag_access_bounds (gimple *call, tree func, int strict,\n \t{\n \t  auto_diagnostic_group d;\n \t  if ((ref.basesize < maxobjsize\n-\t       && warning_at (loc, OPT_Warray_bounds,\n+\t       && warning_at (loc, opt,\n \t\t\t      form\n \t\t\t      ? G_(\"%G%qD forming offset %s is out of \"\n \t\t\t\t   \"the bounds [0, %wu] of object %qD with \"\n@@ -1811,7 +1816,7 @@ maybe_diag_access_bounds (gimple *call, tree func, int strict,\n \t\t\t\t   \"[0, %wu] of object %qD with type %qT\"),\n \t\t\t      call, func, rangestr[0], ref.basesize.to_uhwi (),\n \t\t\t      ref.base, TREE_TYPE (ref.base)))\n-\t      || warning_at (loc, OPT_Warray_bounds,\n+\t      || warning_at (loc, opt,\n \t\t\t     form\n \t\t\t     ? G_(\"%G%qD forming offset %s is out of \"\n \t\t\t\t  \"the bounds of object %qD with type %qT\")\n@@ -1826,15 +1831,15 @@ maybe_diag_access_bounds (gimple *call, tree func, int strict,\n \t    }\n \t}\n       else if (ref.basesize < maxobjsize)\n-\twarned = warning_at (loc, OPT_Warray_bounds,\n+\twarned = warning_at (loc, opt,\n \t\t\t     form\n \t\t\t     ? G_(\"%G%qD forming offset %s is out \"\n \t\t\t\t  \"of the bounds [0, %wu]\")\n \t\t\t     : G_(\"%G%qD offset %s is out \"\n \t\t\t\t  \"of the bounds [0, %wu]\"),\n \t\t\t     call, func, rangestr[0], ref.basesize.to_uhwi ());\n       else\n-\twarned = warning_at (loc, OPT_Warray_bounds,\n+\twarned = warning_at (loc, opt,\n \t\t\t     form\n \t\t\t     ? G_(\"%G%qD forming offset %s is out of bounds\")\n \t\t\t     : G_(\"%G%qD offset %s is out of bounds\"),\n@@ -1848,7 +1853,7 @@ maybe_diag_access_bounds (gimple *call, tree func, int strict,\n \ttype = TREE_TYPE (type);\n       type = TYPE_MAIN_VARIANT (type);\n \n-      if (warning_at (loc, OPT_Warray_bounds,\n+      if (warning_at (loc, opt,\n \t\t      \"%G%qD offset %s from the object at %qE is out \"\n \t\t      \"of the bounds of %qT\",\n \t\t      call, func, rangestr[0], ref.base, type))\n@@ -1866,7 +1871,7 @@ maybe_diag_access_bounds (gimple *call, tree func, int strict,\n       tree refop = TREE_OPERAND (ref.ref, 0);\n       tree type = TYPE_MAIN_VARIANT (TREE_TYPE (ref.ref));\n \n-      if (warning_at (loc, OPT_Warray_bounds,\n+      if (warning_at (loc, opt,\n \t\t      \"%G%qD offset %s from the object at %qE is out \"\n \t\t      \"of the bounds of referenced subobject %qD with \"\n \t\t      \"type %qT at offset %wi\",\n@@ -1883,7 +1888,7 @@ maybe_diag_access_bounds (gimple *call, tree func, int strict,\n \t}\n     }\n \n-  return warned;\n+  return warned ? opt : no_warning;\n }\n \n /* Check a CALL statement for restrict-violations and issue warnings\n@@ -1894,7 +1899,7 @@ check_call (range_query *query, gimple *call)\n {\n   /* Avoid checking the call if it has already been diagnosed for\n      some reason.  */\n-  if (gimple_no_warning_p (call))\n+  if (warning_suppressed_p (call, OPT_Wrestrict))\n     return;\n \n   tree func = gimple_call_fndecl (call);\n@@ -1980,11 +1985,10 @@ check_call (range_query *query, gimple *call)\n       || (dstwr && !INTEGRAL_TYPE_P (TREE_TYPE (dstwr))))\n     return;\n \n-  if (!check_bounds_or_overlap (query, call, dst, src, dstwr, NULL_TREE))\n-    return;\n-\n+  opt_code opt = check_bounds_or_overlap (query, call, dst, src, dstwr,\n+\t\t\t\t\t  NULL_TREE);\n   /* Avoid diagnosing the call again.  */\n-  gimple_set_no_warning (call, true);\n+  suppress_warning (call, opt);\n }\n \n } /* anonymous namespace */\n@@ -1996,7 +2000,7 @@ check_call (range_query *query, gimple *call)\n    without issue a warning.  Return the OPT_Wxxx constant corresponding\n    to the warning if one has been detected and zero otherwise.  */\n \n-int\n+opt_code\n check_bounds_or_overlap (gimple *call, tree dst, tree src, tree dstsize,\n \t\t\t tree srcsize, bool bounds_only /* = false */,\n \t\t\t bool do_warn /* = true */)\n@@ -2006,7 +2010,7 @@ check_bounds_or_overlap (gimple *call, tree dst, tree src, tree dstsize,\n \t\t\t\t  bounds_only, do_warn);\n }\n \n-int\n+opt_code\n check_bounds_or_overlap (range_query *query,\n \t\t\t gimple *call, tree dst, tree src, tree dstsize,\n \t\t\t tree srcsize, bool bounds_only /* = false */,\n@@ -2032,16 +2036,20 @@ check_bounds_or_overlap (range_query *query,\n   /* Validate offsets to each reference before the access first to make\n      sure they are within the bounds of the destination object if its\n      size is known, or PTRDIFF_MAX otherwise.  */\n-  if (maybe_diag_access_bounds (call, func, strict, dstref, wroff, do_warn)\n-      || maybe_diag_access_bounds (call, func, strict, srcref, 0, do_warn))\n+  opt_code opt\n+    = maybe_diag_access_bounds (call, func, strict, dstref, wroff, do_warn);\n+  if (opt == no_warning)\n+    opt = maybe_diag_access_bounds (call, func, strict, srcref, 0, do_warn);\n+\n+  if (opt != no_warning)\n     {\n       if (do_warn)\n-\tgimple_set_no_warning (call, true);\n-      return OPT_Warray_bounds;\n+\tsuppress_warning (call, opt);\n+      return opt;\n     }\n \n   if (!warn_restrict || bounds_only || !src)\n-    return 0;\n+    return no_warning;\n \n   if (!bounds_only)\n     {\n@@ -2051,7 +2059,7 @@ check_bounds_or_overlap (range_query *query,\n \tcase BUILT_IN_MEMMOVE_CHK:\n \tcase BUILT_IN_MEMSET:\n \tcase BUILT_IN_MEMSET_CHK:\n-\t  return 0;\n+\t  return no_warning;\n \tdefault:\n \t  break;\n \t}\n@@ -2064,26 +2072,26 @@ check_bounds_or_overlap (range_query *query,\n \t not point to objects and so do not indicate an overlap;\n \t such calls could be the result of sanitization and jump\n \t threading).  */\n-      if (!integer_zerop (dst) && !gimple_no_warning_p (call))\n+      if (!integer_zerop (dst) && !warning_suppressed_p (call, OPT_Wrestrict))\n \t{\n \t  warning_at (loc, OPT_Wrestrict,\n \t\t      \"%G%qD source argument is the same as destination\",\n \t\t      call, func);\n-\t  gimple_set_no_warning (call, true);\n+\t  suppress_warning (call, OPT_Wrestrict);\n \t  return OPT_Wrestrict;\n \t}\n \n-      return 0;\n+      return no_warning;\n     }\n \n   /* Return false when overlap has been detected.  */\n   if (maybe_diag_overlap (loc, call, acs))\n     {\n-      gimple_set_no_warning (call, true);\n+      suppress_warning (call, OPT_Wrestrict);\n       return OPT_Wrestrict;\n     }\n \n-  return 0;\n+  return no_warning;\n }\n \n gimple_opt_pass *"}, {"sha": "98c0e2425748efa234b70c0a08c8dcc4266cb412", "filename": "gcc/gimple-ssa-warn-restrict.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple-ssa-warn-restrict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple-ssa-warn-restrict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.h?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -20,10 +20,10 @@\n \n #ifndef GIMPLE_SSA_WARN_RESTRICT_H\n \n-extern int check_bounds_or_overlap (gimple *, tree, tree, tree, tree,\n-\t\t\t\t    bool = false, bool = true);\n-extern int check_bounds_or_overlap (class range_query *, gimple *,\n-\t\t\t\t    tree, tree, tree, tree,\n-\t\t\t\t    bool = false, bool = true);\n+extern opt_code check_bounds_or_overlap (gimple *, tree, tree, tree, tree,\n+\t\t\t\t\t bool = false, bool = true);\n+extern opt_code check_bounds_or_overlap (class range_query *, gimple *,\n+\t\t\t\t\t tree, tree, tree, tree,\n+\t\t\t\t\t bool = false, bool = true);\n \n #endif /* GIMPLE_SSA_WARN_RESTRICT_H */"}, {"sha": "60a90667e4bad07fdd2d61ce55750ac9422b4936", "filename": "gcc/gimple.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -399,7 +399,7 @@ gimple_build_call_from_tree (tree t, tree fnptrtype)\n   gimple_call_set_va_arg_pack (call, CALL_EXPR_VA_ARG_PACK (t));\n   gimple_call_set_nothrow (call, TREE_NOTHROW (t));\n   gimple_call_set_by_descriptor (call, CALL_EXPR_BY_DESCRIPTOR (t));\n-  gimple_set_no_warning (call, TREE_NO_WARNING (t));\n+  copy_warning (call, t);\n \n   if (fnptrtype)\n     {"}, {"sha": "be1155e262d358bcfb71ef2bd65a6af7a0764d37", "filename": "gcc/gimple.h", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -1635,6 +1635,24 @@ extern bool gimple_inexpensive_call_p (gcall *);\n extern bool stmt_can_terminate_bb_p (gimple *);\n extern location_t gimple_or_expr_nonartificial_location (gimple *, tree);\n \n+/* Return the disposition for a warning (or all warnings by default)\n+   for a statement.  */\n+extern bool warning_suppressed_p (const gimple *, opt_code = all_warnings)\n+  ATTRIBUTE_NONNULL (1);\n+/* Set the disposition for a warning (or all warnings by default)\n+   at a location to enabled by default.  */\n+extern void suppress_warning (gimple *, opt_code = all_warnings,\n+\t\t\t      bool = true) ATTRIBUTE_NONNULL (1);\n+\n+/* Copy the warning disposition mapping from one statement to another.  */\n+extern void copy_warning (gimple *, const gimple *)\n+  ATTRIBUTE_NONNULL (1) ATTRIBUTE_NONNULL (2);\n+/* Copy the warning disposition mapping from an expression to a statement.  */\n+extern void copy_warning (gimple *, const_tree)\n+  ATTRIBUTE_NONNULL (1) ATTRIBUTE_NONNULL (2);\n+/* Copy the warning disposition mapping from a statement to an expression.  */\n+extern void copy_warning (tree, const gimple *)\n+  ATTRIBUTE_NONNULL (1) ATTRIBUTE_NONNULL (2);\n \n /* Formal (expression) temporary table handling: multiple occurrences of\n    the same scalar expression are evaluated into the same temporary.  */\n@@ -1855,16 +1873,17 @@ gimple_block (const gimple *g)\n   return LOCATION_BLOCK (g->location);\n }\n \n+/* Forward declare.  */\n+static inline void gimple_set_location (gimple *, location_t);\n \n /* Set BLOCK to be the lexical scope block holding statement G.  */\n \n static inline void\n gimple_set_block (gimple *g, tree block)\n {\n-  g->location = set_block (g->location, block);\n+  gimple_set_location (g, set_block (g->location, block));\n }\n \n-\n /* Return location information for statement G.  */\n \n static inline location_t\n@@ -1887,6 +1906,8 @@ gimple_location_safe (const gimple *g)\n static inline void\n gimple_set_location (gimple *g, location_t location)\n {\n+  /* Copy the no-warning data to the statement location.  */\n+  copy_warning (location, g->location);\n   g->location = location;\n }\n "}, {"sha": "75a4a9d59fd33f1630a08ebc96f6ea858488c412", "filename": "gcc/gimplify.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -1601,7 +1601,7 @@ gimplify_return_expr (tree stmt, gimple_seq *pre_p)\n     {\n       maybe_add_early_return_predict_stmt (pre_p);\n       greturn *ret = gimple_build_return (ret_expr);\n-      gimple_set_no_warning (ret, TREE_NO_WARNING (stmt));\n+      copy_warning (ret, stmt);\n       gimplify_seq_add_stmt (pre_p, ret);\n       return GS_ALL_DONE;\n     }\n@@ -1663,7 +1663,7 @@ gimplify_return_expr (tree stmt, gimple_seq *pre_p)\n \t we can wind up warning about an uninitialized value for this.  Due\n \t to how this variable is constructed and initialized, this is never\n \t true.  Give up and never warn.  */\n-      TREE_NO_WARNING (result) = 1;\n+      suppress_warning (result, OPT_Wuninitialized);\n \n       gimplify_ctxp->return_temp = result;\n     }\n@@ -1677,7 +1677,7 @@ gimplify_return_expr (tree stmt, gimple_seq *pre_p)\n \n   maybe_add_early_return_predict_stmt (pre_p);\n   ret = gimple_build_return (result);\n-  gimple_set_no_warning (ret, TREE_NO_WARNING (stmt));\n+  copy_warning (ret, stmt);\n   gimplify_seq_add_stmt (pre_p, ret);\n \n   return GS_ALL_DONE;\n@@ -4252,7 +4252,8 @@ gimplify_cond_expr (tree *expr_p, gimple_seq *pre_p, fallback_t fallback)\n \t\t\t\t &arm2);\n   cond_stmt = gimple_build_cond (pred_code, arm1, arm2, label_true,\n \t\t\t\t label_false);\n-  gimple_set_no_warning (cond_stmt, TREE_NO_WARNING (COND_EXPR_COND (expr)));\n+  gimple_set_location (cond_stmt, EXPR_LOCATION (expr));\n+  copy_warning (cond_stmt, COND_EXPR_COND (expr));\n   gimplify_seq_add_stmt (&seq, cond_stmt);\n   gimple_stmt_iterator gsi = gsi_last (seq);\n   maybe_fold_stmt (&gsi);\n@@ -5682,7 +5683,7 @@ gimplify_modify_expr_complex_part (tree *expr_p, gimple_seq *pre_p,\n \n   ocode = code == REALPART_EXPR ? IMAGPART_EXPR : REALPART_EXPR;\n   other = build1 (ocode, TREE_TYPE (rhs), lhs);\n-  TREE_NO_WARNING (other) = 1;\n+  suppress_warning (other);\n   other = get_formal_tmp_var (other, pre_p);\n \n   realpart = code == REALPART_EXPR ? rhs : other;\n@@ -5967,7 +5968,7 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n       assign = gimple_build_assign (*to_p, *from_p);\n       gimple_set_location (assign, EXPR_LOCATION (*expr_p));\n       if (COMPARISON_CLASS_P (*from_p))\n-\tgimple_set_no_warning (assign, TREE_NO_WARNING (*from_p));\n+\tcopy_warning (assign, *from_p);\n     }\n \n   if (gimplify_ctxp->into_ssa && is_gimple_reg (*to_p))\n@@ -6729,7 +6730,7 @@ gimple_push_cleanup (tree var, tree cleanup, bool eh_only, gimple_seq *pre_p,\n \t  /* Because of this manipulation, and the EH edges that jump\n \t     threading cannot redirect, the temporary (VAR) will appear\n \t     to be used uninitialized.  Don't warn.  */\n-\t  TREE_NO_WARNING (var) = 1;\n+\t  suppress_warning (var, OPT_Wuninitialized);\n \t}\n     }\n   else\n@@ -14624,7 +14625,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n \t    gimplify_and_add (EH_FILTER_FAILURE (*expr_p), &failure);\n \t    ehf = gimple_build_eh_filter (EH_FILTER_TYPES (*expr_p), failure);\n-\t    gimple_set_no_warning (ehf, TREE_NO_WARNING (*expr_p));\n+\t    copy_warning (ehf, *expr_p);\n \t    gimplify_seq_add_stmt (pre_p, ehf);\n \t    ret = GS_ALL_DONE;\n \t    break;"}, {"sha": "9fd1c65883d40e4c01f6678dfcaea19c50205117", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -3845,7 +3845,7 @@ expand_omp_for_generic (struct omp_region *region,\n \t  for (i = first_zero_iter1;\n \t       i < (fd->ordered ? fd->ordered : fd->collapse); i++)\n \t    if (SSA_VAR_P (counts[i]))\n-\t      TREE_NO_WARNING (counts[i]) = 1;\n+\t      suppress_warning (counts[i], OPT_Wuninitialized);\n \t  gsi_prev (&gsi);\n \t  e = split_block (entry_bb, gsi_stmt (gsi));\n \t  entry_bb = e->dest;\n@@ -3862,7 +3862,7 @@ expand_omp_for_generic (struct omp_region *region,\n \t     be executed in that case, so just avoid uninit warnings.  */\n \t  for (i = first_zero_iter2; i < fd->ordered; i++)\n \t    if (SSA_VAR_P (counts[i]))\n-\t      TREE_NO_WARNING (counts[i]) = 1;\n+\t      suppress_warning (counts[i], OPT_Wuninitialized);\n \t  if (zero_iter1_bb)\n \t    make_edge (zero_iter2_bb, entry_bb, EDGE_FALLTHRU);\n \t  else\n@@ -7051,7 +7051,7 @@ expand_omp_taskloop_for_outer (struct omp_region *region,\n \t     be executed in that case, so just avoid uninit warnings.  */\n \t  for (i = first_zero_iter; i < fd->collapse; i++)\n \t    if (SSA_VAR_P (counts[i]))\n-\t      TREE_NO_WARNING (counts[i]) = 1;\n+\t      suppress_warning (counts[i], OPT_Wuninitialized);\n \t  gsi_prev (&gsi);\n \t  edge e = split_block (entry_bb, gsi_stmt (gsi));\n \t  entry_bb = e->dest;"}, {"sha": "410a4a6eeebc17ed587a2234b22a3b4648f84012", "filename": "gcc/omp-low.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -5695,7 +5695,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t able to notice this and not store anything at all, but\n \t\t we're generating code too early.  Suppress the warning.  */\n \t      if (!by_ref)\n-\t\tTREE_NO_WARNING (var) = 1;\n+\t\tsuppress_warning (var, OPT_Wuninitialized);\n \t      break;\n \n \t    case OMP_CLAUSE__CONDTEMP_:\n@@ -6676,7 +6676,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n       uid = create_tmp_var (ptr_type_node, \"simduid\");\n       /* Don't want uninit warnings on simduid, it is always uninitialized,\n \t but we use it not for the value, but for the DECL_UID only.  */\n-      TREE_NO_WARNING (uid) = 1;\n+      suppress_warning (uid, OPT_Wuninitialized);\n       c = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE__SIMDUID_);\n       OMP_CLAUSE__SIMDUID__DECL (c) = uid;\n       OMP_CLAUSE_CHAIN (c) = gimple_omp_for_clauses (ctx->stmt);\n@@ -7104,7 +7104,7 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *body_p,\n \t      if (predicate\n \t\t  && (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n \t\t      || OMP_CLAUSE_LINEAR_NO_COPYIN (c)))\n-\t\tTREE_NO_WARNING (new_var) = 1;\n+\t\tsuppress_warning (new_var, OPT_Wuninitialized);\n \t    }\n \n \t  if (!maybe_simt && simduid && DECL_HAS_VALUE_EXPR_P (new_var))\n@@ -7938,7 +7938,7 @@ lower_send_clauses (tree clauses, gimple_seq *ilist, gimple_seq *olist,\n \t  if (OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT (c)\n \t      && !by_ref\n \t      && is_task_ctx (ctx))\n-\t    TREE_NO_WARNING (var) = 1;\n+\t    suppress_warning (var);\n \t  do_in = true;\n \t  break;\n \n@@ -12800,7 +12800,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t      {\n \t\t\tif (is_gimple_reg (var)\n \t\t\t    && OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT (c))\n-\t\t\t  TREE_NO_WARNING (var) = 1;\n+\t\t\t  suppress_warning (var);\n \t\t\tvar = build_fold_addr_expr (var);\n \t\t      }\n \t\t    else\n@@ -12824,7 +12824,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\t   we'll get a warning for the store to avar.\n \t\t\t   Don't warn in that case, the mapping might\n \t\t\t   be implicit.  */\n-\t\t\tTREE_NO_WARNING (var) = 1;\n+\t\t\tsuppress_warning (var, OPT_Wuninitialized);\n \t\t\tgimplify_assign (avar, var, &ilist);\n \t\t      }\n \t\t    avar = build_fold_addr_expr (avar);\n@@ -12978,7 +12978,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\tif (omp_is_reference (var))\n \t\t  t = build_simple_mem_ref (var);\n \t\telse if (OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT (c))\n-\t\t  TREE_NO_WARNING (var) = 1;\n+\t\t  suppress_warning (var);\n \t\tif (TREE_CODE (type) != POINTER_TYPE)\n \t\t  t = fold_convert (pointer_sized_int_node, t);\n \t\tt = fold_convert (TREE_TYPE (x), t);\n@@ -12991,7 +12991,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\ttree avar = create_tmp_var (TREE_TYPE (var));\n \t\tmark_addressable (avar);\n \t\tif (OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT (c))\n-\t\t  TREE_NO_WARNING (var) = 1;\n+\t\t  suppress_warning (var);\n \t\tgimplify_assign (avar, var, &ilist);\n \t\tavar = build_fold_addr_expr (avar);\n \t\tgimplify_assign (x, avar, &ilist);"}, {"sha": "c73e1cbdda6b9380190b03de66caee48c4e173e3", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -9445,7 +9445,7 @@ pass_warn_function_return::execute (function *fun)\n   /* If we see \"return;\" in some basic block, then we do reach the end\n      without returning a value.  */\n   else if (warn_return_type > 0\n-\t   && !TREE_NO_WARNING (fun->decl)\n+\t   && !warning_suppressed_p (fun->decl, OPT_Wreturn_type)\n \t   && !VOID_TYPE_P (TREE_TYPE (TREE_TYPE (fun->decl))))\n     {\n       FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (fun)->preds)\n@@ -9454,22 +9454,22 @@ pass_warn_function_return::execute (function *fun)\n \t  greturn *return_stmt = dyn_cast <greturn *> (last);\n \t  if (return_stmt\n \t      && gimple_return_retval (return_stmt) == NULL\n-\t      && !gimple_no_warning_p (last))\n+\t      && !warning_suppressed_p (last, OPT_Wreturn_type))\n \t    {\n \t      location = gimple_location (last);\n \t      if (LOCATION_LOCUS (location) == UNKNOWN_LOCATION)\n \t\tlocation = fun->function_end_locus;\n \t      if (warning_at (location, OPT_Wreturn_type,\n \t\t\t      \"control reaches end of non-void function\"))\n-\t\tTREE_NO_WARNING (fun->decl) = 1;\n+\t\tsuppress_warning (fun->decl, OPT_Wreturn_type);\n \t      break;\n \t    }\n \t}\n       /* The C++ FE turns fallthrough from the end of non-void function\n \t into __builtin_unreachable () call with BUILTINS_LOCATION.\n \t Recognize those too.  */\n       basic_block bb;\n-      if (!TREE_NO_WARNING (fun->decl))\n+      if (!warning_suppressed_p (fun->decl, OPT_Wreturn_type))\n \tFOR_EACH_BB_FN (bb, fun)\n \t  if (EDGE_COUNT (bb->succs) == 0)\n \t    {\n@@ -9493,7 +9493,7 @@ pass_warn_function_return::execute (function *fun)\n \t\t    location = fun->function_end_locus;\n \t\t  if (warning_at (location, OPT_Wreturn_type,\n \t\t\t\t  \"control reaches end of non-void function\"))\n-\t\t    TREE_NO_WARNING (fun->decl) = 1;\n+\t\t    suppress_warning (fun->decl, OPT_Wreturn_type);\n \t\t  break;\n \t\t}\n \t    }"}, {"sha": "a528cdc7feec3a97f7c30d280962504632fcaf25", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -456,12 +456,12 @@ create_one_component_var (tree type, tree orig, const char *prefix,\n       SET_DECL_DEBUG_EXPR (r, build1 (code, type, orig));\n       DECL_HAS_DEBUG_EXPR_P (r) = 1;\n       DECL_IGNORED_P (r) = 0;\n-      TREE_NO_WARNING (r) = TREE_NO_WARNING (orig);\n+      copy_warning (r, orig);\n     }\n   else\n     {\n       DECL_IGNORED_P (r) = 1;\n-      TREE_NO_WARNING (r) = 1;\n+      suppress_warning (r);\n     }\n \n   return r;"}, {"sha": "9e041ca4d565924a2831afe915cec6a750646f94", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -1116,7 +1116,7 @@ remap_gimple_op_r (tree *tp, int *walk_subtrees, void *data)\n \t  *tp = fold_build2 (MEM_REF, type, ptr, TREE_OPERAND (*tp, 1));\n \t  TREE_THIS_VOLATILE (*tp) = TREE_THIS_VOLATILE (old);\n \t  TREE_SIDE_EFFECTS (*tp) = TREE_SIDE_EFFECTS (old);\n-\t  TREE_NO_WARNING (*tp) = TREE_NO_WARNING (old);\n+\t  copy_warning (*tp, old);\n \t  if (MR_DEPENDENCE_CLIQUE (old) != 0)\n \t    {\n \t      MR_DEPENDENCE_CLIQUE (*tp)\n@@ -1375,7 +1375,7 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)\n \t  *tp = fold_build2 (MEM_REF, type, ptr, TREE_OPERAND (*tp, 1));\n \t  TREE_THIS_VOLATILE (*tp) = TREE_THIS_VOLATILE (old);\n \t  TREE_SIDE_EFFECTS (*tp) = TREE_SIDE_EFFECTS (old);\n-\t  TREE_NO_WARNING (*tp) = TREE_NO_WARNING (old);\n+\t  copy_warning (*tp, old);\n \t  if (MR_DEPENDENCE_CLIQUE (old) != 0)\n \t    {\n \t      MR_DEPENDENCE_CLIQUE (*tp)\n@@ -3769,7 +3769,7 @@ declare_return_variable (copy_body_data *id, tree return_slot, tree modify_dest,\n \n   /* Do not have the rest of GCC warn about this variable as it should\n      not be visible to the user.  */\n-  TREE_NO_WARNING (var) = 1;\n+  suppress_warning (var /* OPT_Wuninitialized? */);\n \n   declare_inline_vars (id->block, var);\n \n@@ -5027,7 +5027,7 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id,\n \t initialized.  We do not want to issue a warning about that\n \t uninitialized variable.  */\n       if (DECL_P (modify_dest))\n-\tTREE_NO_WARNING (modify_dest) = 1;\n+\tsuppress_warning (modify_dest, OPT_Wuninitialized);\n \n       if (gimple_call_return_slot_opt_p (call_stmt))\n \t{"}, {"sha": "9edd922a303f98f97b2a5903f25c65cd6a540453", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -411,8 +411,8 @@ lookup_field_for_decl (struct nesting_info *info, tree decl,\n \t  DECL_USER_ALIGN (field) = DECL_USER_ALIGN (decl);\n \t  DECL_IGNORED_P (field) = DECL_IGNORED_P (decl);\n \t  DECL_NONADDRESSABLE_P (field) = !TREE_ADDRESSABLE (decl);\n-\t  TREE_NO_WARNING (field) = TREE_NO_WARNING (decl);\n \t  TREE_THIS_VOLATILE (field) = TREE_THIS_VOLATILE (decl);\n+\t  copy_warning (field, decl);\n \n \t  /* Declare the transformation and adjust the original DECL.  For a\n \t     variable or for a parameter when not optimizing, we make it point"}, {"sha": "c05d22f3e8f1ea4e5c3c6a4c61781f6a6baec054", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -2246,12 +2246,12 @@ create_access_replacement (struct access *access, tree reg_type = NULL_TREE)\n \t  DECL_HAS_DEBUG_EXPR_P (repl) = 1;\n \t}\n       if (access->grp_no_warning)\n-\tTREE_NO_WARNING (repl) = 1;\n+\tsuppress_warning (repl /* Be more selective! */);\n       else\n-\tTREE_NO_WARNING (repl) = TREE_NO_WARNING (access->base);\n+\tcopy_warning (repl, access->base);\n     }\n   else\n-    TREE_NO_WARNING (repl) = 1;\n+    suppress_warning (repl /* Be more selective! */);\n \n   if (dump_file)\n     {\n@@ -3562,7 +3562,7 @@ generate_subtree_copies (struct access *access, tree agg,\n \t    }\n \t  else\n \t    {\n-\t      TREE_NO_WARNING (repl) = 1;\n+\t      suppress_warning (repl /* Be more selective! */);\n \t      if (access->grp_partial_lhs)\n \t\trepl = force_gimple_operand_gsi (gsi, repl, true, NULL_TREE,\n \t\t\t\t\t\t !insert_after,"}, {"sha": "425854123253681f78bbee0c99a96c61b9c6c4d5", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -3527,7 +3527,7 @@ pass_post_ipa_warn::execute (function *fun)\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple *stmt = gsi_stmt (gsi);\n-\t  if (!is_gimple_call (stmt) || gimple_no_warning_p (stmt))\n+\t  if (!is_gimple_call (stmt) || warning_suppressed_p (stmt, OPT_Wnonnull))\n \t    continue;\n \n \t  tree fntype = gimple_call_fntype (stmt);"}, {"sha": "db3b18b275c565b2adbb89c7037a63b1b941e863", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -403,7 +403,8 @@ combine_cond_expr_cond (gimple *stmt, enum tree_code code, tree type,\n       return NULL_TREE;\n     }\n \n-  fold_undefer_overflow_warnings (!gimple_no_warning_p (stmt), stmt, 0);\n+  bool nowarn = warning_suppressed_p (stmt, OPT_Wstrict_overflow);\n+  fold_undefer_overflow_warnings (!nowarn, stmt, 0);\n \n   return t;\n }"}, {"sha": "dfa5dc87c34fc99303133b22bf6069849087e923", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -458,7 +458,7 @@ ch_base::copy_headers (function *fun)\n \t\t\t  && gimple_cond_code (stmt) != NE_EXPR\n \t\t\t  && INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n \t\t\t  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (lhs)))\n-\t\t\tgimple_set_no_warning (stmt, true);\n+\t\t\tsuppress_warning (stmt, OPT_Wstrict_overflow_);\n \t\t    }\n \t\t  else if (is_gimple_assign (stmt))\n \t\t    {\n@@ -469,7 +469,7 @@ ch_base::copy_headers (function *fun)\n \t\t\t  && rhs_code != NE_EXPR\n \t\t\t  && INTEGRAL_TYPE_P (TREE_TYPE (rhs1))\n \t\t\t  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (rhs1)))\n-\t\t\tgimple_set_no_warning (stmt, true);\n+\t\t\tsuppress_warning (stmt, OPT_Wstrict_overflow_);\n \t\t    }\n \t\t}\n \t    }"}, {"sha": "48c952a1eac7cd0a7b5ecca7e705c361d5782171", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -2143,7 +2143,7 @@ execute_sm (class loop *loop, im_mem_ref *ref,\n       /* If not emitting a load mark the uninitialized state on the\n \t loop entry as not to be warned for.  */\n       tree uninit = create_tmp_reg (TREE_TYPE (aux->tmp_var));\n-      TREE_NO_WARNING (uninit) = 1;\n+      suppress_warning (uninit, OPT_Wuninitialized);\n       load = gimple_build_assign (aux->tmp_var, uninit);\n     }\n   lim_data = init_lim_data (load);"}, {"sha": "ce5f0d50f7bc62ae997898ea2cbdba428565977c", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -2963,9 +2963,12 @@ cond_store_replacement (basic_block middle_bb, basic_block join_bb,\n   new_stmt = gimple_build_assign (name, lhs);\n   gimple_set_location (new_stmt, locus);\n   lhs = unshare_expr (lhs);\n-  /* Set TREE_NO_WARNING on the rhs of the load to avoid uninit\n-     warnings.  */\n-  TREE_NO_WARNING (gimple_assign_rhs1 (new_stmt)) = 1;\n+  {\n+    /* Set the no-warning bit on the rhs of the load to avoid uninit\n+       warnings.  */\n+    tree rhs1 = gimple_assign_rhs1 (new_stmt);\n+    suppress_warning (rhs1, OPT_Wuninitialized);\n+  }\n   gsi_insert_on_edge (e1, new_stmt);\n \n   /* 3) Create a PHI node at the join block, with one argument"}, {"sha": "13ea107da1773b12a14b51c2995c31200010a870", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -1938,7 +1938,7 @@ maybe_warn_overflow (gimple *stmt, tree len, pointer_query &ptr_qry,\n \t\t     strinfo *si = NULL, bool plus_one = false,\n \t\t     bool rawmem = false)\n {\n-  if (!len || gimple_no_warning_p (stmt))\n+  if (!len || warning_suppressed_p (stmt, OPT_Wstringop_overflow_))\n     return;\n \n   /* The DECL of the function performing the write if it is done\n@@ -1957,7 +1957,7 @@ maybe_warn_overflow (gimple *stmt, tree len, pointer_query &ptr_qry,\n   else\n     return;\n \n-  if (TREE_NO_WARNING (dest))\n+  if (warning_suppressed_p (dest, OPT_Wstringop_overflow_))\n     return;\n \n   const int ostype = rawmem ? 0 : 1;\n@@ -2101,7 +2101,7 @@ maybe_warn_overflow (gimple *stmt, tree len, pointer_query &ptr_qry,\n   if (!warned)\n     return;\n \n-  gimple_set_no_warning (stmt, true);\n+  suppress_warning (stmt, OPT_Wstringop_overflow_);\n \n   aref.inform_access (access_write_only);\n }\n@@ -2624,16 +2624,16 @@ handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n   len = fold_convert_loc (loc, type, unshare_expr (srclen));\n   len = fold_build2_loc (loc, PLUS_EXPR, type, len, build_int_cst (type, 1));\n \n-  /* Set the no-warning bit on the transformed statement?  */\n-  bool set_no_warning = false;\n+  /* Disable warning for the transformed statement?  */\n+  opt_code no_warning_opt = no_warning;\n \n-  if (const strinfo *chksi = olddsi ? olddsi : dsi)\n-    if (si\n-\t&& check_bounds_or_overlap (stmt, chksi->ptr, si->ptr, NULL_TREE, len))\n-      {\n-\tgimple_set_no_warning (stmt, true);\n-\tset_no_warning = true;\n-      }\n+  if (const strinfo *chksi = si ? olddsi ? olddsi : dsi : NULL)\n+    {\n+      no_warning_opt = check_bounds_or_overlap (stmt, chksi->ptr, si->ptr,\n+\t\t\t\t\t\tNULL_TREE, len);\n+      if (no_warning_opt)\n+\tsuppress_warning (stmt, no_warning_opt);\n+    }\n \n   if (fn == NULL_TREE)\n     return;\n@@ -2667,8 +2667,8 @@ handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n   else if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n     fprintf (dump_file, \"not possible.\\n\");\n \n-  if (set_no_warning)\n-    gimple_set_no_warning (stmt, true);\n+  if (no_warning_opt)\n+    suppress_warning (stmt, no_warning_opt);\n }\n \n /* Check the size argument to the built-in forms of stpncpy and strncpy\n@@ -2796,7 +2796,7 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt,\n \t\t\t  pointer_query *ptr_qry /* = NULL */)\n {\n   gimple *stmt = gsi_stmt (gsi);\n-  if (gimple_no_warning_p (stmt))\n+  if (warning_suppressed_p (stmt, OPT_Wstringop_truncation))\n     return false;\n \n   wide_int cntrange[2];\n@@ -3156,9 +3156,10 @@ handle_builtin_stxncpy_strncat (bool append_p, gimple_stmt_iterator *gsi)\n   else\n     srclenp1 = NULL_TREE;\n \n-  if (check_bounds_or_overlap (stmt, dst, src, dstlenp1, srclenp1))\n+  opt_code opt = check_bounds_or_overlap (stmt, dst, src, dstlenp1, srclenp1);\n+  if (opt != no_warning)\n     {\n-      gimple_set_no_warning (stmt, true);\n+      suppress_warning (stmt, opt);\n       return;\n     }\n \n@@ -3169,7 +3170,7 @@ handle_builtin_stxncpy_strncat (bool append_p, gimple_stmt_iterator *gsi)\n   if (!pss || pss->first <= 0)\n     {\n       if (maybe_diag_stxncpy_trunc (*gsi, src, len))\n-\tgimple_set_no_warning (stmt, true);\n+\tsuppress_warning (stmt, OPT_Wstringop_truncation);\n \n       return;\n     }\n@@ -3206,8 +3207,8 @@ handle_builtin_stxncpy_strncat (bool append_p, gimple_stmt_iterator *gsi)\n       /* Issue -Wstringop-overflow when appending or when writing into\n \t a destination of a known size.  Otherwise, when copying into\n \t a destination of an unknown size, it's truncation.  */\n-      int opt = (append_p || dstsize\n-\t\t ? OPT_Wstringop_overflow_ : OPT_Wstringop_truncation);\n+      opt_code opt = (append_p || dstsize\n+\t\t      ? OPT_Wstringop_overflow_ : OPT_Wstringop_truncation);\n       warned = warning_at (callloc, opt,\n \t\t\t   \"%G%qD specified bound depends on the length \"\n \t\t\t   \"of the source argument\",\n@@ -3448,8 +3449,8 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n \tsrclen = get_string_length (si);\n     }\n \n-  /* Set the no-warning bit on the transformed statement?  */\n-  bool set_no_warning = false;\n+  /* Disable warning for the transformed statement?  */\n+  opt_code no_warning_opt = no_warning;\n \n   if (dsi == NULL || get_string_length (dsi) == NULL_TREE)\n     {\n@@ -3466,12 +3467,10 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n \t  }\n \n \ttree sptr = si && si->ptr ? si->ptr : src;\n-\n-\tif (check_bounds_or_overlap (stmt, dst, sptr, NULL_TREE, slen))\n-\t  {\n-\t    gimple_set_no_warning (stmt, true);\n-\t    set_no_warning = true;\n-\t  }\n+\tno_warning_opt = check_bounds_or_overlap (stmt, dst, sptr, NULL_TREE,\n+\t\t\t\t\t\t  slen);\n+\tif (no_warning_opt)\n+\t  suppress_warning (stmt, no_warning_opt);\n       }\n \n       /* strcat (p, q) can be transformed into\n@@ -3578,11 +3577,10 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n       tree dstsize = fold_build2 (PLUS_EXPR, type, dstlen, one);\n       tree sptr = si && si->ptr ? si->ptr : src;\n \n-      if (check_bounds_or_overlap (stmt, dst, sptr, dstsize, srcsize))\n-\t{\n-\t  gimple_set_no_warning (stmt, true);\n-\t  set_no_warning = true;\n-\t}\n+      no_warning_opt = check_bounds_or_overlap (stmt, dst, sptr, dstsize,\n+\t\t\t\t\t\tsrcsize);\n+      if (no_warning_opt)\n+\tsuppress_warning (stmt, no_warning_opt);\n     }\n \n   tree len = NULL_TREE;\n@@ -3648,8 +3646,8 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n   else if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n     fprintf (dump_file, \"not possible.\\n\");\n \n-  if (set_no_warning)\n-    gimple_set_no_warning (stmt, true);\n+  if (no_warning_opt)\n+    suppress_warning (stmt, no_warning_opt);\n }\n \n /* Handle a call to an allocation function like alloca, malloc or calloc,"}, {"sha": "99442d7f975cf31a91ba4960b61de7c25f5366e3", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -87,17 +87,33 @@ has_undefined_value_p (tree t)\n \t      && possibly_undefined_names->contains (t)));\n }\n \n-/* Like has_undefined_value_p, but don't return true if TREE_NO_WARNING\n-   is set on SSA_NAME_VAR.  */\n+/* Return true if EXPR should suppress either uninitialized warning.  */\n+\n+static inline bool\n+get_no_uninit_warning (tree expr)\n+{\n+  return warning_suppressed_p (expr, OPT_Wuninitialized);\n+}\n+\n+/* Suppress both uninitialized warnings for EXPR.  */\n+\n+static inline void\n+set_no_uninit_warning (tree expr)\n+{\n+  suppress_warning (expr, OPT_Wuninitialized);\n+}\n+\n+/* Like has_undefined_value_p, but don't return true if the no-warning\n+   bit is set on SSA_NAME_VAR for either uninit warning.  */\n \n static inline bool\n uninit_undefined_value_p (tree t)\n {\n   if (!has_undefined_value_p (t))\n     return false;\n-  if (SSA_NAME_VAR (t) && TREE_NO_WARNING (SSA_NAME_VAR (t)))\n-    return false;\n-  return true;\n+  if (!SSA_NAME_VAR (t))\n+    return true;\n+  return !get_no_uninit_warning (SSA_NAME_VAR (t));\n }\n \n /* Emit warnings for uninitialized variables.  This is done in two passes.\n@@ -165,10 +181,10 @@ warn_uninit (enum opt_code wc, tree t, tree expr, tree var,\n   /* TREE_NO_WARNING either means we already warned, or the front end\n      wishes to suppress the warning.  */\n   if ((context\n-       && (gimple_no_warning_p (context)\n+       && (warning_suppressed_p (context, OPT_Wuninitialized)\n \t   || (gimple_assign_single_p (context)\n-\t       && TREE_NO_WARNING (gimple_assign_rhs1 (context)))))\n-      || TREE_NO_WARNING (expr))\n+\t       && get_no_uninit_warning (gimple_assign_rhs1 (context)))))\n+      || get_no_uninit_warning (expr))\n     return;\n \n   if (context != NULL && gimple_has_location (context))\n@@ -185,7 +201,7 @@ warn_uninit (enum opt_code wc, tree t, tree expr, tree var,\n   auto_diagnostic_group d;\n   if (warning_at (location, wc, gmsgid, expr))\n     {\n-      TREE_NO_WARNING (expr) = 1;\n+      suppress_warning (expr, wc);\n \n       if (location == DECL_SOURCE_LOCATION (var))\n \treturn;\n@@ -260,15 +276,15 @@ maybe_warn_operand (ao_ref &ref, gimple *stmt, tree lhs, tree rhs,\n   use_operand_p luse_p;\n   imm_use_iterator liter;\n \n-  if (TREE_NO_WARNING (rhs))\n+  if (get_no_uninit_warning (rhs))\n     return NULL_TREE;\n \n   /* Do not warn if the base was marked so or this is a\n      hard register var.  */\n   tree base = ao_ref_base (&ref);\n   if ((VAR_P (base)\n        && DECL_HARD_REGISTER (base))\n-      || TREE_NO_WARNING (base))\n+      || get_no_uninit_warning (base))\n     return NULL_TREE;\n \n   /* Do not warn if the access is fully outside of the variable.  */\n@@ -407,7 +423,7 @@ maybe_warn_operand (ao_ref &ref, gimple *stmt, tree lhs, tree rhs,\n     rhs = TREE_OPERAND (rhs, 0);\n \n   /* Check again since RHS may have changed above.  */\n-  if (TREE_NO_WARNING (rhs))\n+  if (get_no_uninit_warning (rhs))\n     return NULL_TREE;\n \n   /* Avoid warning about empty types such as structs with no members.\n@@ -435,7 +451,7 @@ maybe_warn_operand (ao_ref &ref, gimple *stmt, tree lhs, tree rhs,\n \t     uses or accesses by functions as it may hide important\n \t     locations.  */\n \t  if (lhs)\n-\t    TREE_NO_WARNING (rhs) = 1;\n+\t    set_no_uninit_warning (rhs);\n \t  warned = true;\n \t}\n     }"}, {"sha": "0565c9b50739fd99705735dbe9972319d3356e45", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -406,10 +406,10 @@ compare_values_warnv (tree val1, tree val2, bool *strict_overflow_p)\n \treturn -2;\n \n       if (strict_overflow_p != NULL\n-\t  /* Symbolic range building sets TREE_NO_WARNING to declare\n+\t  /* Symbolic range building sets the no-warning bit to declare\n \t     that overflow doesn't happen.  */\n-\t  && (!inv1 || !TREE_NO_WARNING (val1))\n-\t  && (!inv2 || !TREE_NO_WARNING (val2)))\n+\t  && (!inv1 || !warning_suppressed_p (val1, OPT_Woverflow))\n+\t  && (!inv2 || !warning_suppressed_p (val2, OPT_Woverflow)))\n \t*strict_overflow_p = true;\n \n       if (!inv1)\n@@ -432,10 +432,10 @@ compare_values_warnv (tree val1, tree val2, bool *strict_overflow_p)\n \treturn -2;\n \n       if (strict_overflow_p != NULL\n-\t  /* Symbolic range building sets TREE_NO_WARNING to declare\n+\t  /* Symbolic range building sets the no-warning bit to declare\n \t     that overflow doesn't happen.  */\n-\t  && (!sym1 || !TREE_NO_WARNING (val1))\n-\t  && (!sym2 || !TREE_NO_WARNING (val2)))\n+\t  && (!sym1 || !warning_suppressed_p (val1, OPT_Woverflow))\n+\t  && (!sym2 || !warning_suppressed_p (val2, OPT_Woverflow)))\n \t*strict_overflow_p = true;\n \n       const signop sgn = TYPE_SIGN (TREE_TYPE (val1));"}, {"sha": "3ae2c68499df118cd96146605319def275017591", "filename": "gcc/vr-values.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e2bad7251477db92ab9ebcdc010f9282dd9890/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=e9e2bad7251477db92ab9ebcdc010f9282dd9890", "patch": "@@ -699,7 +699,7 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n \t\t\t\t   build_int_cst (TREE_TYPE (max), 1));\n \t      /* Signal to compare_values_warnv this expr doesn't overflow.  */\n \t      if (EXPR_P (max))\n-\t\tTREE_NO_WARNING (max) = 1;\n+\t\tsuppress_warning (max, OPT_Woverflow);\n \t    }\n \n \t  vr_p->update (min, max);\n@@ -739,7 +739,7 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n \t\t\t\t   build_int_cst (TREE_TYPE (min), 1));\n \t      /* Signal to compare_values_warnv this expr doesn't overflow.  */\n \t      if (EXPR_P (min))\n-\t\tTREE_NO_WARNING (min) = 1;\n+\t\tsuppress_warning (min, OPT_Woverflow);\n \t    }\n \n \t  vr_p->update (min, max);\n@@ -3355,7 +3355,7 @@ test_for_singularity (enum tree_code cond_code, tree op0,\n \t  max = fold_build2 (MINUS_EXPR, TREE_TYPE (op0), max, one);\n \t  /* Signal to compare_values_warnv this expr doesn't overflow.  */\n \t  if (EXPR_P (max))\n-\t    TREE_NO_WARNING (max) = 1;\n+\t    suppress_warning (max, OPT_Woverflow);\n \t}\n     }\n   else if (cond_code == GE_EXPR || cond_code == GT_EXPR)\n@@ -3369,7 +3369,7 @@ test_for_singularity (enum tree_code cond_code, tree op0,\n \t  min = fold_build2 (PLUS_EXPR, TREE_TYPE (op0), min, one);\n \t  /* Signal to compare_values_warnv this expr doesn't overflow.  */\n \t  if (EXPR_P (min))\n-\t    TREE_NO_WARNING (min) = 1;\n+\t    suppress_warning (min, OPT_Woverflow);\n \t}\n     }\n "}]}