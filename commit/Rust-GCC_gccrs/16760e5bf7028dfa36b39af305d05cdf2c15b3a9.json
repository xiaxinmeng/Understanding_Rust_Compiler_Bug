{"sha": "16760e5bf7028dfa36b39af305d05cdf2c15b3a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY3NjBlNWJmNzAyOGRmYTM2YjM5YWYzMDVkMDVjZGYyYzE1YjNhOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-09T10:24:46Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-09T11:15:10Z"}, "message": "tree-optimization/97334 - improve BB SLP discovery\n\nWe're running into a multiplication with one unvectorizable\noperand we expect to build from scalars but SLP discovery\nfatally fails the build of both since one stmt is commutated:\n\n  _60 = _58 * _59;\n  _63 = _59 * _62;\n  _66 = _59 * _65;\n...\n\nwhere _59 is the \"bad\" operand.  The following patch makes the\ncase work where the first stmt has a good operand by not fatally\nfailing the SLP build for the operand but communicating upwards\nhow to commutate.\n\n2020-10-09  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/97334\n\t* tree-vect-slp.c (vect_build_slp_tree_1): Do not fatally\n\tfail lanes other than zero when BB vectorizing.\n\n\t* gcc.dg/vect/bb-slp-pr65935.c: Amend.", "tree": {"sha": "e7fbe7b617e7172110d047bbc980e00d916c93ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7fbe7b617e7172110d047bbc980e00d916c93ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16760e5bf7028dfa36b39af305d05cdf2c15b3a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16760e5bf7028dfa36b39af305d05cdf2c15b3a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16760e5bf7028dfa36b39af305d05cdf2c15b3a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16760e5bf7028dfa36b39af305d05cdf2c15b3a9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afcbeb35e0b9fb0251d04362a1bd4031520ff7f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afcbeb35e0b9fb0251d04362a1bd4031520ff7f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afcbeb35e0b9fb0251d04362a1bd4031520ff7f8"}], "stats": {"total": 25, "additions": 25, "deletions": 0}, "files": [{"sha": "ea37e4e614cecbf4a13ea48f2b8cee8698f2ac62", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr65935.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16760e5bf7028dfa36b39af305d05cdf2c15b3a9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr65935.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16760e5bf7028dfa36b39af305d05cdf2c15b3a9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr65935.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr65935.c?ref=16760e5bf7028dfa36b39af305d05cdf2c15b3a9", "patch": "@@ -60,3 +60,6 @@ int main()\n /* We should also be able to use 2-lane SLP to initialize the real and\n    imaginary components in the first loop of main.  */\n /* { dg-final { scan-tree-dump-times \"optimized: basic block\" 10 \"slp1\" } } */\n+/* We should see the s->phase[dir] operand and only that operand built\n+   from scalars.  See PR97334.  */\n+/* { dg-final { scan-tree-dump-times \"Building vector operands from scalars\" 1 \"slp1\" } } */"}, {"sha": "495fb970e24c8c50685abf772db0692455e573dc", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16760e5bf7028dfa36b39af305d05cdf2c15b3a9/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16760e5bf7028dfa36b39af305d05cdf2c15b3a9/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=16760e5bf7028dfa36b39af305d05cdf2c15b3a9", "patch": "@@ -773,6 +773,12 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"Build SLP failed: unvectorizable statement %G\",\n \t\t\t     stmt);\n+\t  /* ???  For BB vectorization we want to commutate operands in a way\n+\t     to shuffle all unvectorizable defs into one operand and have\n+\t     the other still vectorized.  The following doesn't reliably\n+\t     work for this though but it's the easiest we can do here.  */\n+\t  if (is_a <bb_vec_info> (vinfo) && i != 0)\n+\t    continue;\n \t  /* Fatal mismatch.  */\n \t  matches[0] = false;\n           return false;\n@@ -785,6 +791,8 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"Build SLP failed: not GIMPLE_ASSIGN nor \"\n \t\t\t     \"GIMPLE_CALL %G\", stmt);\n+\t  if (is_a <bb_vec_info> (vinfo) && i != 0)\n+\t    continue;\n \t  /* Fatal mismatch.  */\n \t  matches[0] = false;\n \t  return false;\n@@ -797,6 +805,8 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t      && !vect_record_max_nunits (vinfo, stmt_info, group_size,\n \t\t\t\t\t  nunits_vectype, max_nunits)))\n \t{\n+\t  if (is_a <bb_vec_info> (vinfo) && i != 0)\n+\t    continue;\n \t  /* Fatal mismatch.  */\n \t  matches[0] = false;\n \t  return false;\n@@ -823,6 +833,8 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t \"Build SLP failed: unsupported call type %G\",\n \t\t\t\t call_stmt);\n+\t      if (is_a <bb_vec_info> (vinfo) && i != 0)\n+\t\tcontinue;\n \t      /* Fatal mismatch.  */\n \t      matches[0] = false;\n \t      return false;\n@@ -865,6 +877,8 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t\t      if (dump_enabled_p ())\n \t\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t\t \"Build SLP failed: no optab.\\n\");\n+\t\t      if (is_a <bb_vec_info> (vinfo) && i != 0)\n+\t\t\tcontinue;\n \t\t      /* Fatal mismatch.  */\n \t\t      matches[0] = false;\n \t\t      return false;\n@@ -876,6 +890,8 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t\t \"Build SLP failed: \"\n \t\t\t\t\t \"op not supported by target.\\n\");\n+\t\t      if (is_a <bb_vec_info> (vinfo) && i != 0)\n+\t\t\tcontinue;\n \t\t      /* Fatal mismatch.  */\n \t\t      matches[0] = false;\n \t\t      return false;\n@@ -900,6 +916,8 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t      if (TREE_CODE (vec) != SSA_NAME\n \t\t  || !types_compatible_p (vectype, TREE_TYPE (vec)))\n \t\t{\n+\t\t  if (is_a <bb_vec_info> (vinfo) && i != 0)\n+\t\t    continue;\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t     \"Build SLP failed: \"\n@@ -1048,6 +1066,8 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t\t\t\t \"Build SLP failed: not grouped load %G\", stmt);\n \n \t      /* FORNOW: Not grouped loads are not supported.  */\n+\t      if (is_a <bb_vec_info> (vinfo) && i != 0)\n+\t\tcontinue;\n \t      /* Fatal mismatch.  */\n \t      matches[0] = false;\n \t      return false;\n@@ -1066,6 +1086,8 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t \"Build SLP failed: operation unsupported %G\",\n \t\t\t\t stmt);\n+\t      if (is_a <bb_vec_info> (vinfo) && i != 0)\n+\t\tcontinue;\n \t      /* Fatal mismatch.  */\n \t      matches[0] = false;\n \t      return false;"}]}