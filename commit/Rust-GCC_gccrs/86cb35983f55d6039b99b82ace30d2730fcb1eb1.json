{"sha": "86cb35983f55d6039b99b82ace30d2730fcb1eb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZjYjM1OTgzZjU1ZDYwMzliOTliODJhY2UzMGQyNzMwZmNiMWViMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-07-28T13:41:30Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-07-28T13:41:30Z"}, "message": "c++: Fix up cp_lexer_safe_previous_token [PR96328]\n\nThe following testcase ICEs, because cp_lexer_safe_previous_token calls\ncp_lexer_previous_token and that ICEs, because all tokens in the lexer\nbuffer before the current one (CPP_EOF) have been purged.\n\ncp_lexer_safe_previous_token is used in the context where it is ok if it\npunts, so the patch changes the function so that it doesn't assert there is\nsome previous token, but instead returns NULL like in other cases where it\npunts.\n\nIn addition to this, in the last hunk it does a micro-optimization, don't\ncall the potentially expensive function if it will not need the result,\ninstead check the least expensive condition first.\n\nAnd the middle hunk is a similar change from Mark's version of the patch,\nto use the safe variant in there because it is again just about a hint\nand it is better not to provide the hint than to ICE, though we don't have a\ntestcase that would ICE.\n\n2020-07-28  Jakub Jelinek  <jakub@redhat.com>\n\t    Mark Wielaard  <mark@klomp.org>\n\n\tPR c++/96328\n\t* parser.c (cp_lexer_safe_previous_token): Don't call\n\tcp_lexer_previous_token, instead inline it by hand and return NULL\n\tinstead of failing assertion if all previous tokens until the first\n\tone are purged.\n\t(cp_parser_error_1): Optimize - only call cp_lexer_safe_previous_token\n\tif token->type is CPP_NAME.  Use cp_lexer_safe_previous_token instead\n\tof cp_lexer_previous_token for the missing_token_desc != RT_NONE\n\tcase too.\n\n\t* g++.dg/diagnostic/pr96328.C: New test.\n\nCo-Authored-By: Mark Wielaard <mark@klomp.org>", "tree": {"sha": "08ce56237c6fda746b917a9f3dff6d335b05c1fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08ce56237c6fda746b917a9f3dff6d335b05c1fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86cb35983f55d6039b99b82ace30d2730fcb1eb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86cb35983f55d6039b99b82ace30d2730fcb1eb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86cb35983f55d6039b99b82ace30d2730fcb1eb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86cb35983f55d6039b99b82ace30d2730fcb1eb1/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae49af94850b26e50268031e24f1559d5a51edec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae49af94850b26e50268031e24f1559d5a51edec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae49af94850b26e50268031e24f1559d5a51edec"}], "stats": {"total": 82, "additions": 49, "deletions": 33}, "files": [{"sha": "ab088874ba72724c173a51868d29f6e597cd5b31", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 45, "deletions": 33, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86cb35983f55d6039b99b82ace30d2730fcb1eb1/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86cb35983f55d6039b99b82ace30d2730fcb1eb1/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=86cb35983f55d6039b99b82ace30d2730fcb1eb1", "patch": "@@ -775,14 +775,25 @@ cp_lexer_previous_token (cp_lexer *lexer)\n \n /* Same as above, but return NULL when the lexer doesn't own the token\n    buffer or if the next_token is at the start of the token\n-   vector.  */\n+   vector or if all previous tokens are purged.  */\n \n static cp_token *\n cp_lexer_safe_previous_token (cp_lexer *lexer)\n {\n-  if (lexer->buffer)\n-    if (lexer->next_token != lexer->buffer->address ())\n-      return cp_lexer_previous_token (lexer);\n+  if (lexer->buffer\n+      && lexer->next_token != lexer->buffer->address ())\n+    {\n+      cp_token_position tp = cp_lexer_previous_token_position (lexer);\n+\n+      /* Skip past purged tokens.  */\n+      while (tp->purged_p)\n+\t{\n+\t  if (tp == lexer->buffer->address ())\n+\t    return NULL;\n+\t  tp--;\n+\t}\n+      return cp_lexer_token_at (lexer, tp);\n+    }\n \n   return NULL;\n }\n@@ -2934,42 +2945,43 @@ cp_parser_error_1 (cp_parser* parser, const char* gmsgid,\n   bool added_matching_location = false;\n \n   if (missing_token_desc != RT_NONE)\n-    {\n-      /* Potentially supply a fix-it hint, suggesting to add the\n-\t missing token immediately after the *previous* token.\n-\t This may move the primary location within richloc.  */\n-      enum cpp_ttype ttype = get_required_cpp_ttype (missing_token_desc);\n-      location_t prev_token_loc\n-\t= cp_lexer_previous_token (parser->lexer)->location;\n-      maybe_suggest_missing_token_insertion (&richloc, ttype, prev_token_loc);\n-\n-      /* If matching_location != UNKNOWN_LOCATION, highlight it.\n-\t Attempt to consolidate diagnostics by printing it as a\n-\tsecondary range within the main diagnostic.  */\n-      if (matching_location != UNKNOWN_LOCATION)\n-\tadded_matching_location\n-\t  = richloc.add_location_if_nearby (matching_location);\n-    }\n+    if (cp_token *prev_token = cp_lexer_safe_previous_token (parser->lexer))\n+      {\n+\t/* Potentially supply a fix-it hint, suggesting to add the\n+\t   missing token immediately after the *previous* token.\n+\t   This may move the primary location within richloc.  */\n+\tenum cpp_ttype ttype = get_required_cpp_ttype (missing_token_desc);\n+\tlocation_t prev_token_loc = prev_token->location;\n+\tmaybe_suggest_missing_token_insertion (&richloc, ttype,\n+\t\t\t\t\t       prev_token_loc);\n+\n+\t/* If matching_location != UNKNOWN_LOCATION, highlight it.\n+\t   Attempt to consolidate diagnostics by printing it as a\n+\t   secondary range within the main diagnostic.  */\n+\tif (matching_location != UNKNOWN_LOCATION)\n+\t  added_matching_location\n+\t    = richloc.add_location_if_nearby (matching_location);\n+      }\n \n   /* If we were parsing a string-literal and there is an unknown name\n      token right after, then check to see if that could also have been\n      a literal string by checking the name against a list of known\n      standard string literal constants defined in header files. If\n      there is one, then add that as an hint to the error message. */\n   name_hint h;\n-  cp_token *prev_token = cp_lexer_safe_previous_token (parser->lexer);\n-  if (prev_token && cp_parser_is_string_literal (prev_token)\n-      && token->type == CPP_NAME)\n-    {\n-      tree name = token->u.value;\n-      const char *token_name = IDENTIFIER_POINTER (name);\n-      const char *header_hint\n-\t= get_cp_stdlib_header_for_string_macro_name (token_name);\n-      if (header_hint != NULL)\n-\th = name_hint (NULL, new suggest_missing_header (token->location,\n-\t\t\t\t\t\t\t token_name,\n-\t\t\t\t\t\t\t header_hint));\n-    }\n+  if (token->type == CPP_NAME)\n+    if (cp_token *prev_token = cp_lexer_safe_previous_token (parser->lexer))\n+      if (cp_parser_is_string_literal (prev_token))\n+\t{\n+\t  tree name = token->u.value;\n+\t  const char *token_name = IDENTIFIER_POINTER (name);\n+\t  const char *header_hint\n+\t    = get_cp_stdlib_header_for_string_macro_name (token_name);\n+\t  if (header_hint != NULL)\n+\t    h = name_hint (NULL, new suggest_missing_header (token->location,\n+\t\t\t\t\t\t\t     token_name,\n+\t\t\t\t\t\t\t     header_hint));\n+\t}\n \n   /* Actually emit the error.  */\n   c_parse_error (gmsgid,"}, {"sha": "de5f9adb2626f17526e71672964c118656260812", "filename": "gcc/testsuite/g++.dg/diagnostic/pr96328.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86cb35983f55d6039b99b82ace30d2730fcb1eb1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fpr96328.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86cb35983f55d6039b99b82ace30d2730fcb1eb1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fpr96328.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fpr96328.C?ref=86cb35983f55d6039b99b82ace30d2730fcb1eb1", "patch": "@@ -0,0 +1,4 @@\n+// PR c++/96328\n+// { dg-do compile }\n+friend // { dg-error \"'friend' used outside of class\" }\n+// { dg-prune-output \"expected unqualified-id at end of input\" }"}]}