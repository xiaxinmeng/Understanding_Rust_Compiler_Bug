{"sha": "fac95383e36c37d13ced66564b546e948707b831", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFjOTUzODNlMzZjMzdkMTNjZWQ2NjU2NGI1NDZlOTQ4NzA3YjgzMQ==", "commit": {"author": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-08-30T18:14:14Z"}, "committer": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-08-30T18:14:14Z"}, "message": "Initial revision\n\nFrom-SVN: r12679", "tree": {"sha": "ba2dc504df909b2aa52d6a49fe134526f703e225", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba2dc504df909b2aa52d6a49fe134526f703e225"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fac95383e36c37d13ced66564b546e948707b831", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fac95383e36c37d13ced66564b546e948707b831", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fac95383e36c37d13ced66564b546e948707b831", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fac95383e36c37d13ced66564b546e948707b831/comments", "author": null, "committer": null, "parents": [{"sha": "abf3bf3863a047f5947f11e7a8376e8c27ba8435", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abf3bf3863a047f5947f11e7a8376e8c27ba8435", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abf3bf3863a047f5947f11e7a8376e8c27ba8435"}], "stats": {"total": 562, "additions": 562, "deletions": 0}, "files": [{"sha": "13d87ec0e90b29b9a1e9b7146c9fca842584b278", "filename": "gcc/config/i386/gmon-sol2.c", "status": "added", "additions": 402, "deletions": 0, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fac95383e36c37d13ced66564b546e948707b831/gcc%2Fconfig%2Fi386%2Fgmon-sol2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fac95383e36c37d13ced66564b546e948707b831/gcc%2Fconfig%2Fi386%2Fgmon-sol2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fgmon-sol2.c?ref=fac95383e36c37d13ced66564b546e948707b831", "patch": "@@ -0,0 +1,402 @@\n+/*-\n+ * Copyright (c) 1991 The Regents of the University of California.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *\tThis product includes software developed by the University of\n+ *\tCalifornia, Berkeley and its contributors.\n+ * 4. Neither the name of the University nor the names of its contributors\n+ *    may be used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ */\n+\n+/* \n+ * Re rework of the solaris 2 version of gmon by J.W.Hawtin 12/8/1996\n+ * Does not work right yet.\n+ */\n+\n+/*\n+ * This is a modified gmon.c by J.W.Hawtin <J.W.Hawtin@lboro.ac.uk>,\n+ * 14/8/96 based on the original gmon.c in GCC and the hacked version\n+ * solaris 2 sparc version (config/sparc/gmon-sol.c) by Mark Eichin. To do\n+ * process profiling on solaris 2.4 X86\n+ *\n+ * It must be used in conjunction with sol2-gc1.asm, which is used to start\n+ * and stop process monitoring.\n+ *\n+ * Differences.\n+ *\n+ * On Solaris 2 _mcount is called my library functions not mcount, so support\n+ * has been added for both.\n+ *\n+ * Also the prototype for profil() is different\n+ *\n+ * Solaris 2 does not seem to have char *minbrk whcih allows the setting of\n+ * the minimum SBRK region so this code has been removed and lets pray malloc\n+ * does not mess it up.\n+ *\n+ * Notes\n+ *\n+ * This code could easily be integrated with the orginal gmon.c and perhaps\n+ * should be.\n+ */\n+\n+#ifndef lint\n+static char sccsid[] = \"@(#)gmon.c\t5.3 (Berkeley) 5/22/91\";\n+#endif /* not lint */\n+\n+#if 0\n+#include <unistd.h>\n+\n+#endif\n+#ifdef DEBUG\n+#include <stdio.h>\n+#endif\n+\n+#if 0\n+#include \"i386/gmon.h\"\n+#else\n+\n+struct phdr {\n+                char    *lpc;\n+                char    *hpc;\n+                int     ncnt;\n+};\n+\n+\n+#define HISTFRACTION 2\n+#define HISTCOUNTER unsigned short\n+#define HASHFRACTION 1\n+#define ARCDENSITY 2\n+#define MINARCS 50\n+#define BASEADDRESS 0x8000000 /* On Solaris 2 X86 all excutables start here\n+\t\t\t\t and not at 0 */ \n+\n+struct tostruct {\n+  char *selfpc;\n+  long count;\n+  unsigned short link;\n+};\n+struct rawarc {\n+    unsigned long       raw_frompc;\n+    unsigned long       raw_selfpc;\n+    long                raw_count;\n+};\n+#define ROUNDDOWN(x,y)  (((x)/(y))*(y))\n+#define ROUNDUP(x,y)    ((((x)+(y)-1)/(y))*(y))\n+#endif\n+\n+/* char *minbrk; */\n+\n+#ifdef __alpha\n+extern char *sbrk ();\n+#endif\n+\n+    /*\n+     *\tfroms is actually a bunch of unsigned shorts indexing tos\n+     */\n+static int\t\tprofiling = 3;\n+static unsigned short\t*froms;\n+static struct tostruct\t*tos = 0;\n+static long\t\ttolimit = 0;\n+static char\t\t*s_lowpc = 0;\n+static char\t\t*s_highpc = 0;\n+static unsigned long\ts_textsize = 0;\n+\n+static int\tssiz;\n+static char\t*sbuf;\n+static int\ts_scale;\n+    /* see profil(2) where this is describe (incorrectly) */\n+#define\t\tSCALE_1_TO_1\t0x10000L\n+\n+#define\tMSG \"No space for profiling buffer(s)\\n\"\n+\n+extern int errno;\n+\n+monstartup(lowpc, highpc)\n+    char\t*lowpc;\n+    char\t*highpc;\n+{\n+    int\t\t\tmonsize;\n+    char\t\t*buffer;\n+    register int\to;\n+\n+\t/*\n+\t *\tround lowpc and highpc to multiples of the density we're using\n+\t *\tso the rest of the scaling (here and in gprof) stays in ints.\n+\t */\n+    lowpc = (char *)\n+\t    ROUNDDOWN((unsigned)lowpc, HISTFRACTION*sizeof(HISTCOUNTER));\n+    s_lowpc = lowpc;\n+    highpc = (char *)\n+\t    ROUNDUP((unsigned)highpc, HISTFRACTION*sizeof(HISTCOUNTER));\n+    s_highpc = highpc;\n+    s_textsize = highpc - lowpc;\n+    monsize = (s_textsize / HISTFRACTION) + sizeof(struct phdr);\n+    buffer = (char *) sbrk( monsize );\n+    if ( buffer == (char *) -1 ) {\n+\twrite( 2 , MSG , sizeof(MSG) );\n+\treturn;\n+    }\n+    froms = (unsigned short *) sbrk( s_textsize / HASHFRACTION );\n+    if ( froms == (unsigned short *) -1 ) {\n+\twrite( 2 , MSG , sizeof(MSG) );\n+\tfroms = 0;\n+\treturn;\n+    }\n+    tolimit = s_textsize * ARCDENSITY / 100;\n+    if ( tolimit < MINARCS ) {\n+\ttolimit = MINARCS;\n+    } else if ( tolimit > 65534 ) {\n+\ttolimit = 65534;\n+    }\n+    tos = (struct tostruct *) sbrk( tolimit * sizeof( struct tostruct ) );\n+    if ( tos == (struct tostruct *) -1 ) {\n+\twrite( 2 , MSG , sizeof(MSG) );\n+\tfroms = 0;\n+\ttos = 0;\n+\treturn;\n+    }\n+/*    minbrk = (char *) sbrk(0);*/\n+    tos[0].link = 0;\n+    sbuf = buffer;\n+    ssiz = monsize;\n+    ( (struct phdr *) buffer ) -> lpc = lowpc;\n+    ( (struct phdr *) buffer ) -> hpc = highpc;\n+    ( (struct phdr *) buffer ) -> ncnt = ssiz;\n+    monsize -= sizeof(struct phdr);\n+    if ( monsize <= 0 )\n+\treturn;\n+    o = highpc - lowpc;\n+    if( monsize < o )\n+#ifndef hp300\n+\ts_scale = ( (float) monsize / o ) * SCALE_1_TO_1;\n+#else /* avoid floating point */\n+    {\n+\tint quot = o / monsize;\n+\n+\tif (quot >= 0x10000)\n+\t\ts_scale = 1;\n+\telse if (quot >= 0x100)\n+\t\ts_scale = 0x10000 / quot;\n+\telse if (o >= 0x800000)\n+\t\ts_scale = 0x1000000 / (o / (monsize >> 8));\n+\telse\n+\t\ts_scale = 0x1000000 / ((o << 8) / monsize);\n+    }\n+#endif\n+    else\n+\ts_scale = SCALE_1_TO_1;\n+    moncontrol(1);\n+}\n+\n+_mcleanup()\n+{\n+    int\t\t\tfd;\n+    int\t\t\tfromindex;\n+    int\t\t\tendfrom;\n+    char\t\t*frompc;\n+    int\t\t\ttoindex;\n+    struct rawarc\trawarc;\n+\n+    moncontrol(0);\n+    fd = creat( \"gmon.out\" , 0666 );\n+    if ( fd < 0 ) {\n+\tperror( \"mcount: gmon.out\" );\n+\treturn;\n+    }\n+#   ifdef DEBUG\n+\tfprintf( stderr , \"[mcleanup] sbuf 0x%x ssiz %d\\n\" , sbuf , ssiz );\n+#   endif DEBUG\n+\n+    write( fd , sbuf , ssiz );\n+    endfrom = s_textsize / (HASHFRACTION * sizeof(*froms));\n+    for ( fromindex = 0 ; fromindex < endfrom ; fromindex++ ) {\n+\tif ( froms[fromindex] == 0 ) {\n+\t    continue;\n+\t}\n+\tfrompc = s_lowpc + (fromindex * HASHFRACTION * sizeof(*froms));\n+\tfor (toindex=froms[fromindex]; toindex!=0; toindex=tos[toindex].link) {\n+#\t    ifdef DEBUG\n+\t\tfprintf( stderr ,\n+\t\t\t\"[mcleanup] frompc 0x%x selfpc 0x%x count %d\\n\" ,\n+\t\t\tfrompc , tos[toindex].selfpc , tos[toindex].count );\n+#\t    endif DEBUG\n+\t    rawarc.raw_frompc = (unsigned long) frompc;\n+\t    rawarc.raw_selfpc = (unsigned long) tos[toindex].selfpc;\n+\t    rawarc.raw_count = tos[toindex].count;\n+\t    write( fd , &rawarc , sizeof rawarc );\n+\t}\n+    }\n+    close( fd );\n+}\n+\n+/* Solaris 2 libraries use _mcount.  */\n+asm(\".globl _mcount; _mcount: jmp internal_mcount\");\n+/* This is for compatibility with old versions of gcc which used mcount.  */\n+asm(\".globl mcount; mcount: jmp internal_mcount\");\n+\n+internal_mcount()\n+{\n+\tregister char\t\t\t*selfpc;\n+\tregister unsigned short\t\t*frompcindex;\n+\tregister struct tostruct\t*top;\n+\tregister struct tostruct\t*prevtop;\n+\tregister long\t\t\ttoindex;\n+\n+\t/*\n+\t *\tfind the return address for mcount,\n+\t *\tand the return address for mcount's caller.\n+\t */\n+\n+\t/* selfpc = pc pushed by mcount call.\n+\t   This identifies the function that was just entered.  */\n+\tselfpc = (void *) __builtin_return_address (0);\n+\t/* frompcindex = pc in preceding frame.\n+\t   This identifies the caller of the function just entered.  */\n+\tfrompcindex = (void *) __builtin_return_address (1);\n+\n+\t/*\n+\t *\tcheck that we are profiling\n+\t *\tand that we aren't recursively invoked.\n+\t */\n+\tif (profiling) {\n+\t\tgoto out;\n+\t}\n+\tprofiling++;\n+\t/*\n+\t *\tcheck that frompcindex is a reasonable pc value.\n+\t *\tfor example:\tsignal catchers get called from the stack,\n+\t *\t\t\tnot from text space.  too bad.\n+\t */\n+\tfrompcindex = (unsigned short *)((long)frompcindex - (long)s_lowpc);\n+\tif ((unsigned long)frompcindex > s_textsize) {\n+\t\tgoto done;\n+\t}\n+\tfrompcindex =\n+\t    &froms[((long)frompcindex) / (HASHFRACTION * sizeof(*froms))];\n+\ttoindex = *frompcindex;\n+\tif (toindex == 0) {\n+\t\t/*\n+\t\t *\tfirst time traversing this arc\n+\t\t */\n+\t\ttoindex = ++tos[0].link;\n+\t\tif (toindex >= tolimit) {\n+\t\t\tgoto overflow;\n+\t\t}\n+\t\t*frompcindex = toindex;\n+\t\ttop = &tos[toindex];\n+\t\ttop->selfpc = selfpc;\n+\t\ttop->count = 1;\n+\t\ttop->link = 0;\n+\t\tgoto done;\n+\t}\n+\ttop = &tos[toindex];\n+\tif (top->selfpc == selfpc) {\n+\t\t/*\n+\t\t *\tarc at front of chain; usual case.\n+\t\t */\n+\t\ttop->count++;\n+\t\tgoto done;\n+\t}\n+\t/*\n+\t *\thave to go looking down chain for it.\n+\t *\ttop points to what we are looking at,\n+\t *\tprevtop points to previous top.\n+\t *\twe know it is not at the head of the chain.\n+\t */\n+\tfor (; /* goto done */; ) {\n+\t\tif (top->link == 0) {\n+\t\t\t/*\n+\t\t\t *\ttop is end of the chain and none of the chain\n+\t\t\t *\thad top->selfpc == selfpc.\n+\t\t\t *\tso we allocate a new tostruct\n+\t\t\t *\tand link it to the head of the chain.\n+\t\t\t */\n+\t\t\ttoindex = ++tos[0].link;\n+\t\t\tif (toindex >= tolimit) {\n+\t\t\t\tgoto overflow;\n+\t\t\t}\n+\t\t\ttop = &tos[toindex];\n+\t\t\ttop->selfpc = selfpc;\n+\t\t\ttop->count = 1;\n+\t\t\ttop->link = *frompcindex;\n+\t\t\t*frompcindex = toindex;\n+\t\t\tgoto done;\n+\t\t}\n+\t\t/*\n+\t\t *\totherwise, check the next arc on the chain.\n+\t\t */\n+\t\tprevtop = top;\n+\t\ttop = &tos[top->link];\n+\t\tif (top->selfpc == selfpc) {\n+\t\t\t/*\n+\t\t\t *\tthere it is.\n+\t\t\t *\tincrement its count\n+\t\t\t *\tmove it to the head of the chain.\n+\t\t\t */\n+\t\t\ttop->count++;\n+\t\t\ttoindex = prevtop->link;\n+\t\t\tprevtop->link = top->link;\n+\t\t\ttop->link = *frompcindex;\n+\t\t\t*frompcindex = toindex;\n+\t\t\tgoto done;\n+\t\t}\n+\n+\t}\n+done:\n+\tprofiling--;\n+\t/* and fall through */\n+out:\n+\treturn;\t\t/* normal return restores saved registers */\n+\n+overflow:\n+\tprofiling++; /* halt further profiling */\n+#   define\tTOLIMIT\t\"mcount: tos overflow\\n\"\n+\twrite(2, TOLIMIT, sizeof(TOLIMIT));\n+\tgoto out;\n+}\n+\n+/*\n+ * Control profiling\n+ *\tprofiling is what mcount checks to see if\n+ *\tall the data structures are ready.\n+ */\n+moncontrol(mode)\n+    int mode;\n+{\n+    if (mode)\n+    {\n+      /* start */\n+      profil((unsigned short *)(sbuf + sizeof(struct phdr)),\n+\t     ssiz - sizeof(struct phdr),\n+\t     (int)s_lowpc, s_scale);\n+      \n+      profiling = 0;\n+    } else {\n+      /* stop */\n+      profil((unsigned short *)0, 0, 0, 0);\n+      profiling = 3;\n+    }\n+}"}, {"sha": "8983a672ac2aaa38b5ea614f1e229c6969a376a7", "filename": "gcc/config/i386/sol2-gc1.asm", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fac95383e36c37d13ced66564b546e948707b831/gcc%2Fconfig%2Fi386%2Fsol2-gc1.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fac95383e36c37d13ced66564b546e948707b831/gcc%2Fconfig%2Fi386%2Fsol2-gc1.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsol2-gc1.asm?ref=fac95383e36c37d13ced66564b546e948707b831", "patch": "@@ -0,0 +1,160 @@\n+! gcrt1.s for Solaris 2, x86\n+\n+!   Copyright (C) 1993 Free Software Foundation, Inc.\n+!   Written By Fred Fish, Nov 1992\n+! \n+! This file is free software; you can redistribute it and/or modify it\n+! under the terms of the GNU General Public License as published by the\n+! Free Software Foundation; either version 2, or (at your option) any\n+! later version.\n+! \n+! In addition to the permissions in the GNU General Public License, the\n+! Free Software Foundation gives you unlimited permission to link the\n+! compiled version of this file with other programs, and to distribute\n+! those programs without any restriction coming from the use of this\n+! file.  (The General Public License restrictions do apply in other\n+! respects; for example, they cover modification of the file, and\n+! distribution when not linked into another program.)\n+! \n+! This file is distributed in the hope that it will be useful, but\n+! WITHOUT ANY WARRANTY; without even the implied warranty of\n+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+! General Public License for more details.\n+! \n+! You should have received a copy of the GNU General Public License\n+! along with this program; see the file COPYING.  If not, write to\n+! the Free Software Foundation, 59 Temple Place - Suite 330,\n+! Boston, MA 02111-1307, USA.\n+! \n+!    As a special exception, if you link this library with files\n+!    compiled with GCC to produce an executable, this does not cause\n+!    the resulting executable to be covered by the GNU General Public License.\n+!    This exception does not however invalidate any other reasons why\n+!    the executable file might be covered by the GNU General Public License.\n+! \n+\n+! This file takes control of the process from the kernel, as specified\n+! in section 3 of the System V Application Binary Interface, Intel386\n+! Processor Supplement.  It has been constructed from information obtained\n+! from the ABI, information obtained from single stepping existing\n+! Solaris executables through their startup code with gdb, and from\n+! information obtained by single stepping executables on other i386 SVR4\n+! implementations.  This file is the first thing linked into any executable.\n+\n+! This is a modified crt1.s by J.W.Hawtin <J.W.Hawtin@lboro.ac.uk> 15/8/96, \n+! to allow program profiling, by calling monstartup on entry and _mcleanup \n+! on exit\n+\n+\t.file\t\"gcrt1.s\"\n+\t.ident\t\"GNU C gcrt1.s\"\n+\t.weak\t_DYNAMIC\n+\t.text\n+\n+! Start creating the initial frame by pushing a NULL value for the return\n+! address of the initial frame, and mark the end of the stack frame chain\n+! (the innermost stack frame) with a NULL value, per page 3-32 of the ABI.\n+! Initialize the first stack frame pointer in %ebp (the contents of which\n+! are unspecified at process initialization).\n+\n+\t.globl\t_start\n+_start:\n+\tpushl\t$0x0\n+\tpushl\t$0x0\n+\tmovl\t%esp,%ebp\n+\n+! As specified per page 3-32 of the ABI, %edx contains a function \n+! pointer that should be registered with atexit(), for proper\n+! shared object termination.  Just push it onto the stack for now\n+! to preserve it.  We want to register _cleanup() first.\n+\n+\tpushl\t%edx\n+\n+! Check to see if there is an _cleanup() function linked in, and if\n+! so, register it with atexit() as the last thing to be run by\n+! atexit().\n+\n+\tmovl\t$_mcleanup,%eax\n+\ttestl\t%eax,%eax\n+\tje\t.L1\n+\tpushl\t$_mcleanup\n+\tcall\tatexit\n+\taddl\t$0x4,%esp\n+.L1:\n+\n+! Now check to see if we have an _DYNAMIC table, and if so then\n+! we need to register the function pointer previously in %edx, but\n+! now conveniently saved on the stack as the argument to pass to\n+! atexit().\n+\n+\tmovl\t$_DYNAMIC,%eax\n+\ttestl\t%eax,%eax\n+\tje\t.L2\n+\tcall\tatexit\n+.L2:\n+\n+! Register _fini() with atexit().  We will take care of calling _init()\n+! directly.\n+\n+\tpushl\t$_fini\n+\tcall\tatexit\n+\n+! Start profiling\n+\n+        pushl %ebp\n+        movl %esp,%ebp\n+        pushl $_etext\n+        pushl $_start\n+        call monstartup\n+        addl $8,%esp\n+\tpopl %ebp\n+\n+! Compute the address of the environment vector on the stack and load\n+! it into the global variable _environ.  Currently argc is at 8 off\n+! the frame pointer.  Fetch the argument count into %eax, scale by the\n+! size of each arg (4 bytes) and compute the address of the environment\n+! vector which is 16 bytes (the two zero words we pushed, plus argc,\n+! plus the null word terminating the arg vector) further up the stack,\n+! off the frame pointer (whew!).\n+\n+\tmovl\t8(%ebp),%eax\n+\tleal\t16(%ebp,%eax,4),%edx\n+\tmovl\t%edx,_environ\n+\n+! Push the environment vector pointer, the argument vector pointer,\n+! and the argument count on to the stack to set up the arguments\n+! for _init(), _fpstart(), and main().  Note that the environment\n+! vector pointer and the arg count were previously loaded into\n+! %edx and %eax respectively.  The only new value we need to compute\n+! is the argument vector pointer, which is at a fixed address off\n+! the initial frame pointer.\n+\n+\tpushl\t%edx\n+\tleal\t12(%ebp),%edx\n+\tpushl\t%edx\n+\tpushl\t%eax\n+\n+! Call _init(argc, argv, environ), _fpstart(argc, argv, environ), and\n+! main(argc, argv, environ).\n+\n+\tcall\t_init\n+\tcall\t__fpstart\n+\tcall\tmain\n+\n+! Pop the argc, argv, and environ arguments off the stack, push the\n+! value returned from main(), and call exit().\n+\n+\taddl\t$12,%esp\n+\tpushl\t%eax\n+\tcall\texit\n+\n+! An inline equivalent of _exit, as specified in Figure 3-26 of the ABI.\n+\n+\tpushl\t$0x0\n+\tmovl\t$0x1,%eax\n+\tlcall\t$7,$0\n+\n+! If all else fails, just try a halt!\n+\n+\thlt\n+\t.type\t_start,@function\n+\t.size\t_start,.-_start"}]}