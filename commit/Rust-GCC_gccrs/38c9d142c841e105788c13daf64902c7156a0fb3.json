{"sha": "38c9d142c841e105788c13daf64902c7156a0fb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhjOWQxNDJjODQxZTEwNTc4OGMxM2RhZjY0OTAyYzcxNTZhMGZiMw==", "commit": {"author": {"name": "Ranjit Mathew", "email": "rmathew@gcc.gnu.org", "date": "2005-05-27T05:15:26Z"}, "committer": {"name": "Ranjit Mathew", "email": "rmathew@gcc.gnu.org", "date": "2005-05-27T05:15:26Z"}, "message": "re PR java/19870 (gcj -C doesn't generate accessors for private members across nested class boundaries)\n\n\tPR java/19870.\n\t* java-tree.h (OUTER_FIELD_ACCESS_IDENTIFIER_P): Rename to\n\tNESTED_FIELD_ACCESS_IDENTIFIER_P.\n\t(FIELD_INNER_ACCESS): Rename to FIELD_NESTED_ACCESS.\n\t(FIELD_INNER_ACCESS_P): Rename to FIELD_NESTED_ACCESS_P.\n\t* jcf-write.c (generate_classfile): Use\n\tNESTED_FIELD_ACCESS_IDENTIFIER_P instead of\n\tOUTER_FIELD_ACCESS_IDENTIFIER_P.\n\t* parse.y (build_outer_field_access): Rename to\n\tbuild_nested_field_access. Support static fields and outer-to-inner\n\tclass accesses.\n\t(outer_field_access_p): Rename to nested_field_access_p. Support\n\tstatic fields and generalise to outer-to-inner class and sibling\n\tinner class accesses.\n\t(outer_field_expanded_access_p): Rename to\n\tnested_field_expanded_access_p and support static fields.\n\t(outer_field_access_fix): Rename to nested_field_access_fix and\n\tsupport static fields.\n\t(build_outer_field_access_expr): Rename to\n\tbuild_nested_field_access_expr and support static fields.\n\t(build_outer_field_access_methods): Rename to\n\tbuild_nested_field_access_methods and support static fields. For\n\tstatic fields, generate accessors without class instance parameters.\n\t(build_outer_field_access_method): Rename to\n\tbuild_nested_field_access_method and support static fields.\n\t(build_outer_method_access_method): Use\n\tNESTED_FIELD_ACCESS_IDENTIFIER_P instead of\n\tOUTER_FIELD_ACCESS_IDENTIFIER_P.\n\t(resolve_expression_name): Consider static field accesses across\n\tnested classes.\n\t(resolve_qualified_expression_name): Likewise.\n\t(java_complete_lhs): Use nested_field_access_fix instead of\n\touter_field_access_fix.\n\t(patch_unary_op): Rename outer_field_flag to nested_field_flag.\n\tUse nested_field_expanded_access_p instead of\n\touter_field_expanded_access_p. Use nested_field_access_fix instead\n\tof outer_field_access_fix.\n\t(check_thrown_exceptions): Use NESTED_FIELD_ACCESS_IDENTIFIER_P\n\tinstead of OUTER_FIELD_ACCESS_IDENTIFIER_P.\n\nFrom-SVN: r100246", "tree": {"sha": "b3937d50c473e4e969f8f4dfe85d2bed7c441069", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3937d50c473e4e969f8f4dfe85d2bed7c441069"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38c9d142c841e105788c13daf64902c7156a0fb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38c9d142c841e105788c13daf64902c7156a0fb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38c9d142c841e105788c13daf64902c7156a0fb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38c9d142c841e105788c13daf64902c7156a0fb3/comments", "author": null, "committer": null, "parents": [{"sha": "27358466f931ecec6692d6d4267318ed1266d729", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27358466f931ecec6692d6d4267318ed1266d729", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27358466f931ecec6692d6d4267318ed1266d729"}], "stats": {"total": 465, "additions": 309, "deletions": 156}, "files": [{"sha": "e867f832b90a08173f83d683308242842c42417f", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c9d142c841e105788c13daf64902c7156a0fb3/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c9d142c841e105788c13daf64902c7156a0fb3/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=38c9d142c841e105788c13daf64902c7156a0fb3", "patch": "@@ -1,3 +1,45 @@\n+2005-05-26  Ranjit Mathew  <rmathew@hotmail.com>\n+\n+\tPR java/19870.\n+\t* java-tree.h (OUTER_FIELD_ACCESS_IDENTIFIER_P): Rename to\n+\tNESTED_FIELD_ACCESS_IDENTIFIER_P.\n+\t(FIELD_INNER_ACCESS): Rename to FIELD_NESTED_ACCESS.\n+\t(FIELD_INNER_ACCESS_P): Rename to FIELD_NESTED_ACCESS_P.\n+\t* jcf-write.c (generate_classfile): Use\n+\tNESTED_FIELD_ACCESS_IDENTIFIER_P instead of\n+\tOUTER_FIELD_ACCESS_IDENTIFIER_P.\n+\t* parse.y (build_outer_field_access): Rename to\n+\tbuild_nested_field_access. Support static fields and outer-to-inner\n+\tclass accesses.\n+\t(outer_field_access_p): Rename to nested_field_access_p. Support\n+\tstatic fields and generalise to outer-to-inner class and sibling\n+\tinner class accesses.\n+\t(outer_field_expanded_access_p): Rename to\n+\tnested_field_expanded_access_p and support static fields.\n+\t(outer_field_access_fix): Rename to nested_field_access_fix and\n+\tsupport static fields.\n+\t(build_outer_field_access_expr): Rename to\n+\tbuild_nested_field_access_expr and support static fields.\n+\t(build_outer_field_access_methods): Rename to\n+\tbuild_nested_field_access_methods and support static fields. For\n+\tstatic fields, generate accessors without class instance parameters.\n+\t(build_outer_field_access_method): Rename to\n+\tbuild_nested_field_access_method and support static fields.\n+\t(build_outer_method_access_method): Use\n+\tNESTED_FIELD_ACCESS_IDENTIFIER_P instead of\n+\tOUTER_FIELD_ACCESS_IDENTIFIER_P.\n+\t(resolve_expression_name): Consider static field accesses across\n+\tnested classes.\n+\t(resolve_qualified_expression_name): Likewise.\n+\t(java_complete_lhs): Use nested_field_access_fix instead of\n+\touter_field_access_fix.\n+\t(patch_unary_op): Rename outer_field_flag to nested_field_flag.\n+\tUse nested_field_expanded_access_p instead of\n+\touter_field_expanded_access_p. Use nested_field_access_fix instead\n+\tof outer_field_access_fix.\n+\t(check_thrown_exceptions): Use NESTED_FIELD_ACCESS_IDENTIFIER_P\n+\tinstead of OUTER_FIELD_ACCESS_IDENTIFIER_P.\n+\n 2005-05-26  Bryce McKinlay  <mckinlay@redhat.com>\n \n \t* decl.c (GCJ_BINARYCOMPAT_ADDITION, \n@@ -10461,7 +10503,7 @@\n \tproperly initialize `finished_label'. Don't emit gotos for empty\n \ttry statements.\n \n-2000-03-19  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n+2000-03-19  Martin v. L\ufffdis  <loewis@informatik.hu-berlin.de>\n \n \t* except.c (emit_handlers): Clear catch_clauses_last.\n "}, {"sha": "37995632f21cd103903453c78d091b6b4bc98930", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c9d142c841e105788c13daf64902c7156a0fb3/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c9d142c841e105788c13daf64902c7156a0fb3/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=38c9d142c841e105788c13daf64902c7156a0fb3", "patch": "@@ -71,7 +71,7 @@ struct JCF;\n       IS_CRAFTED_STRING_BUFFER_P (in CALL_EXPR)\n       IS_INIT_CHECKED (in SAVE_EXPR)\n    6: CAN_COMPLETE_NORMALLY (in statement nodes)\n-      OUTER_FIELD_ACCESS_IDENTIFIER_P (in IDENTIFIER_NODE)\n+      NESTED_FIELD_ACCESS_IDENTIFIER_P (in IDENTIFIER_NODE)\n \n    Usage of TYPE_LANG_FLAG_?:\n    0: CLASS_ACCESS0_GENERATED_P (in RECORD_TYPE)\n@@ -896,16 +896,16 @@ union lang_tree_node\n #define DECL_LOCAL_START_PC(NODE)  (DECL_LANG_SPECIFIC (NODE)->u.v.start_pc)\n /* The end (bytecode) pc for the valid range of this local variable. */\n #define DECL_LOCAL_END_PC(NODE)    (DECL_LANG_SPECIFIC (NODE)->u.v.end_pc)\n-/* For a VAR_DECLor PARM_DECL, used to chain decls with the same\n+/* For a VAR_DECL or PARM_DECL, used to chain decls with the same\n    slot_number in decl_map. */\n #define DECL_LOCAL_SLOT_CHAIN(NODE) (DECL_LANG_SPECIFIC(NODE)->u.v.slot_chain)\n /* For a FIELD_DECL, holds the name of the access method. Used to\n-   read/write the content of the field from an inner class.  */\n-#define FIELD_INNER_ACCESS(DECL) \\\n+   read/write the content of the field across nested class boundaries.  */\n+#define FIELD_NESTED_ACCESS(DECL) \\\n   (DECL_LANG_SPECIFIC (VAR_OR_FIELD_CHECK (DECL))->u.v.am)\n-/* Safely tests whether FIELD_INNER_ACCESS exists or not. */\n-#define FIELD_INNER_ACCESS_P(DECL) \\\n-  DECL_LANG_SPECIFIC (DECL) && FIELD_INNER_ACCESS (DECL)\n+/* Safely tests whether FIELD_NESTED_ACCESS exists or not.  */\n+#define FIELD_NESTED_ACCESS_P(DECL) \\\n+  DECL_LANG_SPECIFIC (DECL) && FIELD_NESTED_ACCESS (DECL)\n /* True if a final field was initialized upon its declaration\n    or in an initializer.  Set after definite assignment.  */\n #define DECL_FIELD_FINAL_IUD(NODE)  (DECL_LANG_SPECIFIC (NODE)->u.v.final_iud)\n@@ -1689,9 +1689,9 @@ extern tree *type_map;\n /* True if NODE (a statement) can complete normally. */\n #define CAN_COMPLETE_NORMALLY(NODE) TREE_LANG_FLAG_6 (NODE)\n \n-/* True if NODE (an IDENTIFIER) bears the name of a outer field from\n-   inner class access function.  */\n-#define OUTER_FIELD_ACCESS_IDENTIFIER_P(NODE) \\\n+/* True if NODE (an IDENTIFIER) bears the name of an outer field from\n+   inner class (or vice versa) access function.  */\n+#define NESTED_FIELD_ACCESS_IDENTIFIER_P(NODE) \\\n   TREE_LANG_FLAG_6 (IDENTIFIER_NODE_CHECK (NODE))\n \n /* True if NODE belongs to an inner class TYPE_DECL node."}, {"sha": "5deb5c84487ece39065c112f44942d31ac226a22", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c9d142c841e105788c13daf64902c7156a0fb3/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c9d142c841e105788c13daf64902c7156a0fb3/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=38c9d142c841e105788c13daf64902c7156a0fb3", "patch": "@@ -3087,7 +3087,7 @@ generate_classfile (tree clas, struct jcf_partial *state)\n       /* Make room for the Synthetic attribute (of zero length.)  */\n       if (DECL_FINIT_P (part)\n \t  || DECL_INSTINIT_P (part)\n-\t  || OUTER_FIELD_ACCESS_IDENTIFIER_P (DECL_NAME (part))\n+\t  || NESTED_FIELD_ACCESS_IDENTIFIER_P (DECL_NAME (part))\n \t  || TYPE_DOT_CLASS (clas) == part)\n \t{\n \t  i++;"}, {"sha": "9067dfc1ba2a50b2843f7181f6cbc9775063ae2a", "filename": "gcc/java/parse.y", "status": "modified", "additions": 255, "deletions": 144, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c9d142c841e105788c13daf64902c7156a0fb3/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c9d142c841e105788c13daf64902c7156a0fb3/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=38c9d142c841e105788c13daf64902c7156a0fb3", "patch": "@@ -320,19 +320,17 @@ static tree build_current_thisn (tree);\n static tree build_access_to_thisn (tree, tree, int);\n static tree maybe_build_thisn_access_method (tree);\n \n-static tree build_outer_field_access (tree, tree);\n-static tree build_outer_field_access_methods (tree);\n-static tree build_outer_field_access_expr (int, tree, tree,\n-\t\t\t\t\t\t  tree, tree);\n+static tree build_nested_field_access (tree, tree);\n+static tree build_nested_field_access_methods (tree);\n+static tree build_nested_field_access_method (tree, tree, tree, tree, tree);\n+static tree build_nested_field_access_expr (int, tree, tree, tree, tree);\n static tree build_outer_method_access_method (tree);\n static tree build_new_access_id (void);\n-static tree build_outer_field_access_method (tree, tree, tree,\n-\t\t\t\t\t\t    tree, tree);\n \n-static int outer_field_access_p (tree, tree);\n-static int outer_field_expanded_access_p (tree, tree *,\n-\t\t\t\t\t\t tree *, tree *);\n-static tree outer_field_access_fix (tree, tree, tree);\n+static int nested_field_access_p (tree, tree);\n+static int nested_field_expanded_access_p (tree, tree *, tree *, tree *);\n+static tree nested_field_access_fix (tree, tree, tree);\n+\n static tree build_incomplete_class_ref (int, tree);\n static tree patch_incomplete_class_ref (tree);\n static tree create_anonymous_class (tree);\n@@ -8289,114 +8287,159 @@ java_expand_method_bodies (tree class)\n    fields either directly by using the relevant access to this$<n> or\n    by invoking an access method crafted for that purpose.  */\n \n-/* Build the necessary access from an inner class to an outer\n-   class. This routine could be optimized to cache previous result\n+/* Build the necessary access across nested class boundaries.\n+   This routine could be optimized to cache previous result\n    (decl, current_class and returned access).  When an access method\n-   needs to be generated, it always takes the form of a read. It might\n-   be later turned into a write by calling outer_field_access_fix.  */\n+   needs to be generated, it always takes the form of a read.  It might\n+   be later turned into a write by calling nested_field_access_fix.  */\n \n static tree\n-build_outer_field_access (tree id, tree decl)\n+build_nested_field_access (tree id, tree decl)\n {\n   tree access = NULL_TREE;\n-  tree ctx = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (current_class)));\n+  tree ctx = NULL_TREE;\n   tree decl_ctx = DECL_CONTEXT (decl);\n+  bool is_static = FIELD_STATIC (decl);\n+\n+  if (DECL_CONTEXT (TYPE_NAME (current_class)))\n+    ctx = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (current_class)));\n \n-  /* If the immediate enclosing context of the current class is the\n-     field decl's class or inherits from it; build the access as\n-     `this$<n>.<field>'. Note that we will break the `private' barrier\n-     if we're not emitting bytecodes. */\n-  if ((ctx == decl_ctx || inherits_from_p (ctx, decl_ctx))\n-      && (!FIELD_PRIVATE (decl) || !flag_emit_class_files ))\n+  /* For non-static fields, if the immediate enclosing context of the\n+     current class is the field decl's class or inherits from it,\n+     build the access as `this$<n>.<field>'.  Note that we will break\n+     the `private' barrier if we're not emitting bytecodes.  */\n+  if (!is_static\n+      && ctx\n+      && (ctx == decl_ctx || inherits_from_p (ctx, decl_ctx))\n+      && (!FIELD_PRIVATE (decl) || !flag_emit_class_files))\n     {\n       tree thisn = build_current_thisn (current_class);\n       access = make_qualified_primary (build_wfl_node (thisn),\n \t\t\t\t       id, EXPR_WFL_LINECOL (id));\n     }\n-  /* Otherwise, generate access methods to outer this and access the\n-     field (either using an access method or by direct access.) */\n+  /* Otherwise, generate and use accessor methods for the field as\n+     needed.  */\n   else\n     {\n       int lc = EXPR_WFL_LINECOL (id);\n \n       /* Now we chain the required number of calls to the access$0 to\n-\t get a hold to the enclosing instance we need, and then we\n-\t build the field access. */\n-      access = build_access_to_thisn (current_class, decl_ctx, lc);\n+\t get a hold to the enclosing instance we need for a non-static\n+         field, and then we build the field access. */\n+      if (!is_static)\n+        access = build_access_to_thisn (current_class, decl_ctx, lc);\n \n       /* If the field is private and we're generating bytecode, then\n-         we generate an access method */\n-      if (FIELD_PRIVATE (decl) && flag_emit_class_files )\n+         we generate an access method.  */\n+      if (FIELD_PRIVATE (decl) && flag_emit_class_files)\n \t{\n-\t  tree name = build_outer_field_access_methods (decl);\n-\t  access = build_outer_field_access_expr (lc, decl_ctx,\n-\t\t\t\t\t\t  name, access, NULL_TREE);\n+\t  tree name = build_nested_field_access_methods (decl);\n+\t  access = build_nested_field_access_expr (lc, decl_ctx,\n+\t\t\t\t\t\t   name, access, NULL_TREE);\n \t}\n-      /* Otherwise we use `access$(this$<j>). ... access$(this$<i>).<field>'.\n+      /* Otherwise we use `access$(this$<j>). ... access$(this$<i>).<field>'\n+         for non-static fields.\n \t Once again we break the `private' access rule from a foreign\n-\t class. */\n+\t class.  */\n+      else if (is_static)\n+        {\n+          tree class_name = DECL_NAME (TYPE_NAME (decl_ctx));\n+          access\n+            = make_qualified_primary (build_wfl_node (class_name), id, lc);\n+        }\n       else\n-\taccess = make_qualified_primary (access, id, lc);\n+        access = make_qualified_primary (access, id, lc);\n     }\n+\n   return resolve_expression_name (access, NULL);\n }\n \n-/* Return a nonzero value if NODE describes an outer field inner\n-   access.  */\n+/* Return a nonzero value if DECL describes a field access across nested\n+   class boundaries.  That is, DECL is in a class that either encloses,\n+   is enclosed by or shares a common enclosing class with, the class\n+   TYPE.  */\n \n static int\n-outer_field_access_p (tree type, tree decl)\n+nested_field_access_p (tree type, tree decl)\n {\n+  bool is_static = false;\n+  tree decl_type = DECL_CONTEXT (decl);\n+  tree type_root, decl_type_root;\n+\n+  if (decl_type == type\n+      || (TREE_CODE (decl) != FIELD_DECL && TREE_CODE (decl) != VAR_DECL))\n+    return 0;\n+  \n   if (!INNER_CLASS_TYPE_P (type)\n-      || TREE_CODE (decl) != FIELD_DECL\n-      || DECL_CONTEXT (decl) == type)\n+      && !(TREE_CODE (decl_type) == RECORD_TYPE\n+           && INNER_CLASS_TYPE_P (decl_type)))\n     return 0;\n \n-  /* If the inner class extends the declaration context of the field\n-     we're trying to access, then this isn't an outer field access */\n-  if (inherits_from_p (type, DECL_CONTEXT (decl)))\n+  is_static = FIELD_STATIC (decl);\n+\n+  /* If TYPE extends the declaration context of the non-static\n+     field we're trying to access, then this isn't a nested field\n+     access we need to worry about.  */\n+  if (!is_static && inherits_from_p (type, decl_type))\n     return 0;\n \n-  for (type = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (type))); ;\n-       type = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (type))))\n+  for (type_root = type;\n+       DECL_CONTEXT (TYPE_NAME (type_root));\n+       type_root = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (type_root))))\n     {\n-      if (type == DECL_CONTEXT (decl))\n-\treturn 1;\n+      if (type_root == decl_type)\n+        return 1;\n \n-      if (!DECL_CONTEXT (TYPE_NAME (type)))\n-\t{\n-\t  /* Before we give up, see whether the field is inherited from\n-\t     the enclosing context we're considering. */\n-\t  if (inherits_from_p (type, DECL_CONTEXT (decl)))\n-\t    return 1;\n-\t  break;\n-\t}\n+      /* Before we give up, see whether it is a non-static field\n+         inherited from the enclosing context we are considering.  */\n+      if (!DECL_CONTEXT (TYPE_NAME (type_root))\n+          && !is_static\n+          && inherits_from_p (type_root, decl_type))\n+        return 1;\n     }\n \n+  if (TREE_CODE (decl_type) == RECORD_TYPE\n+      && INNER_CLASS_TYPE_P (decl_type))\n+    {\n+      for (decl_type_root = decl_type;\n+           DECL_CONTEXT (TYPE_NAME (decl_type_root));\n+           decl_type_root\n+             = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (decl_type_root))))\n+        {\n+          if (decl_type_root == type)\n+            return 1;\n+        }\n+    }\n+  else\n+    decl_type_root = decl_type;\n+    \n+  if (type_root == decl_type_root)\n+    return 1;\n+\n   return 0;\n }\n \n-/* Return a nonzero value if NODE represents an outer field inner\n-   access that was been already expanded. As a side effect, it returns\n+/* Return a nonzero value if NODE represents a cross-nested-class \n+   access that has already been expanded.  As a side effect, it returns\n    the name of the field being accessed and the argument passed to the\n    access function, suitable for a regeneration of the access method\n-   call if necessary. */\n+   call if necessary.  */\n \n static int\n-outer_field_expanded_access_p (tree node, tree *name, tree *arg_type,\n-\t\t\t       tree *arg)\n+nested_field_expanded_access_p (tree node, tree *name, tree *arg_type,\n+\t\t\t        tree *arg)\n {\n   int identified = 0;\n \n   if (TREE_CODE (node) != CALL_EXPR)\n     return 0;\n \n-  /* Well, gcj generates slightly different tree nodes when compiling\n-     to native or bytecodes. It's the case for function calls. */\n+  /* Well, GCJ generates slightly different tree nodes when compiling\n+     to native or bytecodes.  It's the case for function calls.  */\n \n   if (flag_emit_class_files\n       && TREE_CODE (node) == CALL_EXPR\n-      && OUTER_FIELD_ACCESS_IDENTIFIER_P (DECL_NAME (TREE_OPERAND (node, 0))))\n+      && NESTED_FIELD_ACCESS_IDENTIFIER_P (DECL_NAME (TREE_OPERAND (node, 0))))\n     identified = 1;\n   else if (!flag_emit_class_files)\n     {\n@@ -8408,7 +8451,7 @@ outer_field_expanded_access_p (tree node, tree *name, tree *arg_type,\n \t  node = TREE_OPERAND (node, 0);\n \t  if (TREE_OPERAND (node, 0)\n \t      && TREE_CODE (TREE_OPERAND (node, 0)) == FUNCTION_DECL\n-\t      && (OUTER_FIELD_ACCESS_IDENTIFIER_P\n+\t      && (NESTED_FIELD_ACCESS_IDENTIFIER_P\n \t\t  (DECL_NAME (TREE_OPERAND (node, 0)))))\n \t    identified = 1;\n \t}\n@@ -8418,26 +8461,37 @@ outer_field_expanded_access_p (tree node, tree *name, tree *arg_type,\n     {\n       tree argument = TREE_OPERAND (node, 1);\n       *name = DECL_NAME (TREE_OPERAND (node, 0));\n-      *arg_type = TREE_TYPE (TREE_TYPE (TREE_VALUE (argument)));\n-      *arg = TREE_VALUE (argument);\n+\n+      /* The accessors for static fields do not take in a this$<n> argument,\n+         so we take the class name from the accessor's context instead.  */\n+      if (argument)\n+        {\n+          *arg_type = TREE_TYPE (TREE_TYPE (TREE_VALUE (argument)));\n+          *arg = TREE_VALUE (argument);\n+        }\n+      else\n+        {\n+          *arg_type = DECL_CONTEXT (TREE_OPERAND (node, 0));\n+          *arg = NULL_TREE;\n+        }\n     }\n   return identified;\n }\n \n-/* Detect in NODE an outer field read access from an inner class and\n-   transform it into a write with RHS as an argument. This function is\n-   called from the java_complete_lhs when an assignment to a LHS can\n-   be identified. */\n+/* Detect in NODE cross-nested-class field read access and\n+   transform it into a write with RHS as an argument.  This function\n+   is called from the java_complete_lhs when an assignment to a LHS can\n+   be identified.  */\n \n static tree\n-outer_field_access_fix (tree wfl, tree node, tree rhs)\n+nested_field_access_fix (tree wfl, tree node, tree rhs)\n {\n   tree name, arg_type, arg;\n \n-  if (outer_field_expanded_access_p (node, &name, &arg_type, &arg))\n+  if (nested_field_expanded_access_p (node, &name, &arg_type, &arg))\n     {\n-      node = build_outer_field_access_expr (EXPR_WFL_LINECOL (wfl),\n-\t\t\t\t\t    arg_type, name, arg, rhs);\n+      node = build_nested_field_access_expr (EXPR_WFL_LINECOL (wfl),\n+\t\t\t\t\t     arg_type, name, arg, rhs);\n       return java_complete_tree (node);\n     }\n   return NULL_TREE;\n@@ -8450,23 +8504,34 @@ outer_field_access_fix (tree wfl, tree node, tree rhs)\n    read access.  */\n \n static tree\n-build_outer_field_access_expr (int lc, tree type, tree access_method_name,\n-\t\t\t       tree arg1, tree arg2)\n+build_nested_field_access_expr (int lc, tree type, tree access_method_name,\n+\t\t\t        tree arg1, tree arg2)\n {\n   tree args, cn, access;\n \n-  args = arg1 ? arg1 :\n-    build_wfl_node (build_current_thisn (current_class));\n-  args = build_tree_list (NULL_TREE, args);\n+  if (arg1)\n+    args = build_tree_list (NULL_TREE, arg1);\n+  else\n+    args = NULL_TREE;\n \n   if (arg2)\n-    args = tree_cons (NULL_TREE, arg2, args);\n+    {\n+      if (args)\n+        args = tree_cons (NULL_TREE, arg2, args);\n+      else\n+        args = build_tree_list (NULL_TREE, arg2);\n+    }\n \n-  access = build_method_invocation (build_wfl_node (access_method_name), args);\n+  access\n+    = build_method_invocation (build_wfl_node (access_method_name), args);\n   cn = build_wfl_node (DECL_NAME (TYPE_NAME (type)));\n+\n   return make_qualified_primary (cn, access, lc);\n }\n \n+/* Build the name of a synthetic accessor used to access class members\n+   across nested class boundaries.  */\n+\n static tree\n build_new_access_id (void)\n {\n@@ -8477,8 +8542,8 @@ build_new_access_id (void)\n   return get_identifier (buffer);\n }\n \n-/* Create the static access functions for the outer field DECL. We define a\n-   read:\n+/* Create the static access functions for the cross-nested-class field DECL.\n+   We define a read:\n      TREE_TYPE (<field>) access$<n> (DECL_CONTEXT (<field>) inst$) {\n        return inst$.field;\n      }\n@@ -8487,63 +8552,89 @@ build_new_access_id (void)\n                                      TREE_TYPE (<field>) value$) {\n        return inst$.field = value$;\n      }\n-   We should have a usage flags on the DECL so we can lazily turn the ones\n-   we're using for code generation. FIXME.\n+   For static fields, these methods are generated without the instance\n+   parameter.\n+   We should have a usage flag on the DECL so we can lazily turn the ones\n+   we're using for code generation.  FIXME.\n */\n \n static tree\n-build_outer_field_access_methods (tree decl)\n+build_nested_field_access_methods (tree decl)\n {\n-  tree id, args, stmt, mdecl;\n+  tree id, args, stmt, mdecl, class_name = NULL_TREE;\n+  bool is_static = FIELD_STATIC (decl);\n \n-  if (FIELD_INNER_ACCESS_P (decl))\n-    return FIELD_INNER_ACCESS (decl);\n+  if (FIELD_NESTED_ACCESS_P (decl))\n+    return FIELD_NESTED_ACCESS (decl);\n \n   MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (decl);\n \n-  /* Create the identifier and a function named after it. */\n+  /* Create the identifier and a function named after it.  */\n   id = build_new_access_id ();\n \n   /* The identifier is marked as bearing the name of a generated write\n-     access function for outer field accessed from inner classes. */\n-  OUTER_FIELD_ACCESS_IDENTIFIER_P (id) = 1;\n+     access function for outer field accessed from inner classes.  */\n+  NESTED_FIELD_ACCESS_IDENTIFIER_P (id) = 1;\n \n-  /* Create the read access */\n-  args = build_tree_list (inst_id, build_pointer_type (DECL_CONTEXT (decl)));\n-  TREE_CHAIN (args) = end_params_node;\n-  stmt = make_qualified_primary (build_wfl_node (inst_id),\n-\t\t\t\t build_wfl_node (DECL_NAME (decl)), 0);\n+  /* Create the read access.  */\n+  if (!is_static)\n+    {\n+      args = build_tree_list (inst_id,\n+                              build_pointer_type (DECL_CONTEXT (decl)));\n+      TREE_CHAIN (args) = end_params_node;\n+      stmt = make_qualified_primary (build_wfl_node (inst_id),\n+\t\t\t\t     build_wfl_node (DECL_NAME (decl)), 0);\n+    }\n+  else\n+    {\n+      args = end_params_node;\n+      class_name = DECL_NAME (TYPE_NAME (DECL_CONTEXT (decl)));\n+      stmt = make_qualified_primary (build_wfl_node (class_name),\n+                                     build_wfl_node (DECL_NAME (decl)), 0);\n+    }\n   stmt = build_return (0, stmt);\n-  mdecl = build_outer_field_access_method (DECL_CONTEXT (decl),\n-\t\t\t\t\t   TREE_TYPE (decl), id, args, stmt);\n+  mdecl = build_nested_field_access_method (DECL_CONTEXT (decl),\n+\t\t\t\t\t    TREE_TYPE (decl), id, args, stmt);\n   DECL_FUNCTION_ACCESS_DECL (mdecl) = decl;\n \n-  /* Create the write access method. No write access for final variable */\n+  /* Create the write access method.  No write access for final variable */\n   if (!FIELD_FINAL (decl))\n     {\n-      args = build_tree_list (inst_id,\n-\t\t\t      build_pointer_type (DECL_CONTEXT (decl)));\n-      TREE_CHAIN (args) = build_tree_list (wpv_id, TREE_TYPE (decl));\n-      TREE_CHAIN (TREE_CHAIN (args)) = end_params_node;\n-      stmt = make_qualified_primary (build_wfl_node (inst_id),\n-\t\t\t\t     build_wfl_node (DECL_NAME (decl)), 0);\n+      if (!is_static)\n+        {\n+          args = build_tree_list (inst_id,\n+\t\t\t          build_pointer_type (DECL_CONTEXT (decl)));\n+          TREE_CHAIN (args) = build_tree_list (wpv_id, TREE_TYPE (decl));\n+          TREE_CHAIN (TREE_CHAIN (args)) = end_params_node;\n+          stmt = make_qualified_primary (build_wfl_node (inst_id),\n+\t\t\t\t         build_wfl_node (DECL_NAME (decl)),\n+                                         0);\n+        }\n+      else\n+        {\n+          args = build_tree_list (wpv_id, TREE_TYPE (decl));\n+          TREE_CHAIN (args) = end_params_node;\n+          stmt = make_qualified_primary (build_wfl_node (class_name),\n+                                         build_wfl_node (DECL_NAME (decl)),\n+                                         0);\n+        }\n       stmt = build_return (0, build_assignment (ASSIGN_TK, 0, stmt,\n \t\t\t\t\t\tbuild_wfl_node (wpv_id)));\n-      mdecl = build_outer_field_access_method (DECL_CONTEXT (decl),\n-\t\t\t\t\t       TREE_TYPE (decl), id,\n-\t\t\t\t\t       args, stmt);\n+      mdecl = build_nested_field_access_method (DECL_CONTEXT (decl),\n+\t\t\t\t\t        TREE_TYPE (decl), id,\n+\t\t\t\t\t        args, stmt);\n     }\n   DECL_FUNCTION_ACCESS_DECL (mdecl) = decl;\n \n   /* Return the access name */\n-  return FIELD_INNER_ACCESS (decl) = id;\n+  return FIELD_NESTED_ACCESS (decl) = id;\n }\n \n-/* Build an field access method NAME.  */\n+/* Build a field access method NAME.  */\n \n static tree\n-build_outer_field_access_method (tree class, tree type, tree name,\n-\t\t\t\t tree args, tree body)\n+build_nested_field_access_method (tree class, tree type, tree name,\n+\t\t\t\t  tree args, tree body)\n {\n   tree saved_current_function_decl, mdecl;\n \n@@ -8587,7 +8678,7 @@ build_outer_method_access_method (tree decl)\n \n   /* Obtain an access identifier and mark it */\n   id = build_new_access_id ();\n-  OUTER_FIELD_ACCESS_IDENTIFIER_P (id) = 1;\n+  NESTED_FIELD_ACCESS_IDENTIFIER_P (id) = 1;\n \n   carg = TYPE_ARG_TYPES (TREE_TYPE (decl));\n   /* Create the arguments, as much as the original */\n@@ -8653,7 +8744,7 @@ build_outer_method_access_method (tree decl)\n    others. Access methods to this$<n> are build on the fly if\n    necessary. This CAN'T be used to solely access this$<n-1> from\n    this$<n> (which alway yield to special cases and optimization, see\n-   for example build_outer_field_access).  */\n+   for example build_nested_field_access).  */\n \n static tree\n build_access_to_thisn (tree from, tree to, int lc)\n@@ -9456,15 +9547,15 @@ resolve_expression_name (tree id, tree *orig)\n \n \t      /* If we're processing an inner class and we're trying\n \t\t to access a field belonging to an outer class, build\n-\t\t the access to the field */\n-\t      if (!fs && outer_field_access_p (current_class, decl))\n+\t\t the access to the field.  */\n+\t      if (nested_field_access_p (current_class, decl))\n \t\t{\n-\t\t  if (CLASS_STATIC (TYPE_NAME (current_class)))\n+\t\t  if (!fs && CLASS_STATIC (TYPE_NAME (current_class)))\n \t\t    {\n \t\t      static_ref_err (id, DECL_NAME (decl), current_class);\n \t\t      return error_mark_node;\n \t\t    }\n-\t\t  access = build_outer_field_access (id, decl);\n+\t\t  access = build_nested_field_access (id, decl);\n \t\t  if (orig)\n \t\t    *orig = access;\n \t\t  return access;\n@@ -9993,18 +10084,29 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \t      decl = QUAL_RESOLUTION (q);\n \t      if (!type)\n \t\t{\n-\t\t  if (TREE_CODE (decl) == FIELD_DECL && !FIELD_STATIC (decl))\n+\t\t  if (TREE_CODE (decl) == FIELD_DECL\n+                      || TREE_CODE (decl) == VAR_DECL)\n \t\t    {\n-\t\t      if (current_this)\n-\t\t\t*where_found = current_this;\n-\t\t      else\n-\t\t\t{\n-\t\t\t  static_ref_err (qual_wfl, DECL_NAME (decl),\n-\t\t\t\t\t  current_class);\n-\t\t\t  return 1;\n-\t\t\t}\n-                      if (outer_field_access_p (current_class, decl))\n-                        decl = build_outer_field_access (qual_wfl, decl);\n+                      if (TREE_CODE (decl) == FIELD_DECL\n+                          && !FIELD_STATIC (decl))\n+                        {\n+               \t          if (current_this)\n+                            *where_found = current_this;\n+                          else\n+                            {\n+                              static_ref_err (qual_wfl, DECL_NAME (decl),\n+                                              current_class);\n+                              return 1;\n+                            }\n+                        }\n+                      else\n+                        {\n+                          *where_found = TREE_TYPE (decl);\n+                          if (TREE_CODE (*where_found) == POINTER_TYPE)\n+                            *where_found = TREE_TYPE (*where_found);\n+                        }\n+                      if (nested_field_access_p (current_class, decl))\n+                        decl = build_nested_field_access (qual_wfl, decl);\n \t\t    }\n \t\t  else\n \t\t    {\n@@ -10113,7 +10215,7 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \t\t}\n \t      from_cast = from_super = 0;\n \n-\t      /* It's an access from a type but it isn't static, we\n+\t      /* If it's an access from a type but isn't static, we\n \t\t make it relative to `this'. */\n \t      if (!is_static && from_type)\n \t\tdecl = current_this;\n@@ -10128,19 +10230,27 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \t\t    return 1;\n \t\t}\n \n-\t      /* We want to keep the location were found it, and the type\n-\t\t we found. */\n+              /* We want to keep the location where we found it, and the\n+                 type we found.  */\n \t      *where_found = decl;\n \t      *type_found = type;\n \n \t      /* Generate the correct expression for field access from\n \t\t qualified this */\n \t      if (from_qualified_this)\n \t\t{\n-\t\t  field_decl = build_outer_field_access (qual_wfl, field_decl);\n+\t\t  field_decl\n+                    = build_nested_field_access (qual_wfl, field_decl);\n \t\t  from_qualified_this = 0;\n \t\t}\n \n+              /* If needed, generate accessors for static field access.  */\n+              if (is_static\n+                  && FIELD_PRIVATE (field_decl)\n+                  && flag_emit_class_files\n+                  && nested_field_access_p (current_class, field_decl))\n+                field_decl = build_nested_field_access (qual_wfl, field_decl);\n+\n \t      /* This is the decl found and eventually the next one to\n \t\t search from */\n \t      decl = field_decl;\n@@ -12120,10 +12230,10 @@ java_complete_lhs (tree node)\n       if ((nn = patch_string (TREE_OPERAND (node, 1))))\n \tTREE_OPERAND (node, 1) = nn;\n \n-      if ((nn = outer_field_access_fix (wfl_op1, TREE_OPERAND (node, 0),\n-\t\t\t\t\tTREE_OPERAND (node, 1))))\n+      if ((nn = nested_field_access_fix (wfl_op1, TREE_OPERAND (node, 0),\n+\t\t\t\t\t TREE_OPERAND (node, 1))))\n \t{\n-\t  /* We return error_mark_node if outer_field_access_fix\n+\t  /* We return error_mark_node if nested_field_access_fix\n \t     detects we write into a final. */\n \t  if (nn == error_mark_node)\n \t    return error_mark_node;\n@@ -14143,7 +14253,7 @@ patch_unaryop (tree node, tree wfl_op)\n   tree op = TREE_OPERAND (node, 0);\n   tree op_type = TREE_TYPE (op);\n   tree prom_type = NULL_TREE, value, decl;\n-  int outer_field_flag = 0;\n+  int nested_field_flag = 0;\n   int code = TREE_CODE (node);\n   int error_found = 0;\n \n@@ -14160,10 +14270,11 @@ patch_unaryop (tree node, tree wfl_op)\n       /* 15.14.2 Prefix Decrement Operator -- */\n     case PREDECREMENT_EXPR:\n       op = decl = extract_field_decl (op);\n-      outer_field_flag = outer_field_expanded_access_p (op, NULL, NULL, NULL);\n+      nested_field_flag\n+        = nested_field_expanded_access_p (op, NULL, NULL, NULL);\n       /* We might be trying to change an outer field accessed using\n          access method. */\n-      if (outer_field_flag)\n+      if (nested_field_flag)\n \t{\n \t  /* Retrieve the decl of the field we're trying to access. We\n              do that by first retrieving the function we would call to\n@@ -14217,15 +14328,15 @@ patch_unaryop (tree node, tree wfl_op)\n \t    }\n \n \t  /* We remember we might be accessing an outer field */\n-\t  if (outer_field_flag)\n+\t  if (nested_field_flag)\n \t    {\n \t      /* We re-generate an access to the field */\n \t      value = build2 (PLUS_EXPR, TREE_TYPE (op),\n-\t\t\t      build_outer_field_access (wfl_op, decl), value);\n+\t\t\t      build_nested_field_access (wfl_op, decl), value);\n \n \t      /* And we patch the original access$() into a write\n                  with plus_op as a rhs */\n-\t      return outer_field_access_fix (node, op, value);\n+\t      return nested_field_access_fix (node, op, value);\n \t    }\n \n \t  /* And write back into the node. */\n@@ -15809,7 +15920,7 @@ check_thrown_exceptions (\n   int is_array_call = 0;\n \n   /* Skip check within generated methods, such as access$<n>.  */\n-  if (OUTER_FIELD_ACCESS_IDENTIFIER_P (DECL_NAME (current_function_decl)))\n+  if (NESTED_FIELD_ACCESS_IDENTIFIER_P (DECL_NAME (current_function_decl)))\n     return;\n \n   if (this_expr != NULL_TREE"}]}