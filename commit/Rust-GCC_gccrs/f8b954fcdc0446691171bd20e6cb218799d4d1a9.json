{"sha": "f8b954fcdc0446691171bd20e6cb218799d4d1a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhiOTU0ZmNkYzA0NDY2OTExNzFiZDIwZTZjYjIxODc5OWQ0ZDFhOQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-04-26T06:32:50Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-04-26T06:32:50Z"}, "message": "cppexp.c (CPP_UMINUS, CPP_UPLUS): New.\n\n\t* cppexp.c (CPP_UMINUS, CPP_UPLUS): New.\n\t(HAVE_NO_R_OPERAND): Remove.\n\t(HAVE_VALUE): Remove.\n\t(op_to_prio): Update.\n\t(UNARY): Don't alter flags.\n\t(_cpp_parse_expr): want_value used to indicate whether\n\ta number or unary operator is expected next.  Distinguish\n\tunary and binary +/-.\n\t(op_as_text): Update for unary operators.\n\nFrom-SVN: r52780", "tree": {"sha": "41b138ea9b50f42af72e2ae19543c9e1a16ce126", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41b138ea9b50f42af72e2ae19543c9e1a16ce126"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8b954fcdc0446691171bd20e6cb218799d4d1a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8b954fcdc0446691171bd20e6cb218799d4d1a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8b954fcdc0446691171bd20e6cb218799d4d1a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8b954fcdc0446691171bd20e6cb218799d4d1a9/comments", "author": null, "committer": null, "parents": [{"sha": "6052bef039abf0676722cd1df243c1cf5ab99431", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6052bef039abf0676722cd1df243c1cf5ab99431", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6052bef039abf0676722cd1df243c1cf5ab99431"}], "stats": {"total": 178, "additions": 95, "deletions": 83}, "files": [{"sha": "93dd23b892613c2ca75f3a5fbb6f6b84dbd7e049", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8b954fcdc0446691171bd20e6cb218799d4d1a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8b954fcdc0446691171bd20e6cb218799d4d1a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8b954fcdc0446691171bd20e6cb218799d4d1a9", "patch": "@@ -1,3 +1,15 @@\n+2002-04-26  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cppexp.c (CPP_UMINUS, CPP_UPLUS): New.\n+\t(HAVE_NO_R_OPERAND): Remove.\n+\t(HAVE_VALUE): Remove.\n+\t(op_to_prio): Update.\n+\t(UNARY): Don't alter flags.\n+\t(_cpp_parse_expr): want_value used to indicate whether\n+\ta number or unary operator is expected next.  Distinguish\n+\tunary and binary +/-.\n+\t(op_as_text): Update for unary operators.\n+\n 2002-04-25  Richard Henderson  <rth@redhat.com>\n \n \tPR c/2161"}, {"sha": "e3756d7f23e700bfbe6b52d1e1d87f543022eba6", "filename": "gcc/cppexp.c", "status": "modified", "additions": 75, "deletions": 78, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8b954fcdc0446691171bd20e6cb218799d4d1a9/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8b954fcdc0446691171bd20e6cb218799d4d1a9/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=f8b954fcdc0446691171bd20e6cb218799d4d1a9", "patch": "@@ -48,9 +48,12 @@ struct op\n   HOST_WIDEST_INT value; /* The value logically \"right\" of op.  */\n };\n \n-/* There is no \"error\" token, but we can't get comments in #if, so we can\n-   abuse that token type.  */\n+/* Token type abuse.  There is no \"error\" token, but we can't get\n+   comments in #if, so we can abuse that token type.  Similarly,\n+   create unary plus and minus operators.  */\n #define CPP_ERROR CPP_COMMENT\n+#define CPP_UPLUS (CPP_LAST_CPP_OP + 1)\n+#define CPP_UMINUS (CPP_LAST_CPP_OP + 2)\n \n /* With -O2, gcc appears to produce nice code, moving the error\n    message load and subsequent jump completely out of the main path.  */\n@@ -454,10 +457,9 @@ same way as the ultra-low priority end-of-expression dummy operator.\n The exit code checks to see if the operator that caused it is ')', and\n if so outputs an appropriate error message.\n \n-The parser assumes all shifted operators require a right operand\n-unless the flag NO_R_OPERAND is set, and similarly for NO_L_OPERAND.\n-These semantics are automatically checked, any extra semantics need to\n-be handled with operator-specific code.  */\n+The parser assumes all shifted operators require a left operand unless\n+the flag NO_L_OPERAND is set.  These semantics are automatic; any\n+extra semantics need to be handled with operator-specific code.  */\n \n #define FLAG_BITS  8\n #define FLAG_MASK ((1 << FLAG_BITS) - 1)\n@@ -466,10 +468,8 @@ be handled with operator-specific code.  */\n #define EXTRACT_FLAGS(CNST) ((CNST) & FLAG_MASK)\n \n /* Flags.  */\n-#define HAVE_VALUE     (1 << 0)\n-#define NO_L_OPERAND   (1 << 1)\n-#define NO_R_OPERAND   (1 << 2)\n-#define SHORT_CIRCUIT  (1 << 3)\n+#define NO_L_OPERAND   (1 << 0)\n+#define SHORT_CIRCUIT  (1 << 1)\n \n /* Priority and flag combinations.  */\n #define RIGHT_ASSOC         (1 << FLAG_BITS)\n@@ -501,8 +501,8 @@ op_to_prio[] =\n   /* NOT */\t\tUNARY_PRIO,\n   /* GREATER */\t\tLESS_PRIO,\n   /* LESS */\t\tLESS_PRIO,\n-  /* PLUS */\t\tUNARY_PRIO,\t/* note these two can be unary */\n-  /* MINUS */\t\tUNARY_PRIO,\t/* or binary */\n+  /* PLUS */\t\tPLUS_PRIO,\n+  /* MINUS */\t\tPLUS_PRIO,\n   /* MULT */\t\tMUL_PRIO,\n   /* DIV */\t\tMUL_PRIO,\n   /* MOD */\t\tMUL_PRIO,\n@@ -525,7 +525,10 @@ op_to_prio[] =\n   /* EQ_EQ */\t\tEQUAL_PRIO,\n   /* NOT_EQ */\t\tEQUAL_PRIO,\n   /* GREATER_EQ */\tLESS_PRIO,\n-  /* LESS_EQ */\t\tLESS_PRIO\n+  /* LESS_EQ */\t\tLESS_PRIO,\n+  /* EOF */\t\tFORCE_REDUCE_PRIO,\n+  /* UPLUS */\t\tUNARY_PRIO,\n+  /* UMINUS */\t\tUNARY_PRIO\n };\n \n #define COMPARE(OP) \\\n@@ -544,8 +547,7 @@ op_to_prio[] =\n   top->unsignedp = unsigned1 | unsigned2;\n #define UNARY(OP) \\\n   top->value = OP v2; \\\n-  top->unsignedp = unsigned2; \\\n-  top->flags |= HAVE_VALUE;\n+  top->unsignedp = unsigned2;\n #define SHIFT(PSH, MSH) \\\n   if (skip_evaluation)  \\\n     break;\t\t\\\n@@ -568,8 +570,7 @@ _cpp_parse_expr (pfile)\n      There is a stack element for each operator (only),\n      and the most recently pushed operator is 'top->op'.\n      An operand (value) is stored in the 'value' field of the stack\n-     element of the operator that precedes it.\n-     In that case the 'flags' field has the HAVE_VALUE flag set.  */\n+     element of the operator that precedes it.  */\n \n #define INIT_STACK_SIZE 20\n   struct op init_stack[INIT_STACK_SIZE];\n@@ -579,6 +580,7 @@ _cpp_parse_expr (pfile)\n   int skip_evaluation = 0;\n   int result;\n   unsigned int lex_count, saw_leading_not;\n+  bool want_value = true;\n \n   /* Set up detection of #if ! defined().  */\n   pfile->mi_ind_cmacro = 0;\n@@ -589,8 +591,6 @@ _cpp_parse_expr (pfile)\n   top->op = CPP_EOF;\n   /* Nifty way to catch missing '('.  */\n   top->prio = EXTRACT_PRIO(CLOSE_PAREN_PRIO);\n-  /* Avoid missing right operand checks.  */\n-  top->flags = NO_R_OPERAND;\n \n   for (;;)\n     {\n@@ -603,38 +603,41 @@ _cpp_parse_expr (pfile)\n       lex_count++;\n \n       /* If the token is an operand, push its value and get next\n-\t token.  If it is an operator, get its priority and flags, and\n-\t try to reduce the expression on the stack.  */\n+\t token.  If it is an operator, handle some special cases, get\n+\t its priority and flags, and try to reduce the expression on\n+\t the stack.  */\n       switch (op.op)\n \t{\n \tcase CPP_ERROR:\n \t  goto syntax_error;\n-\tpush_immediate:\n \tcase CPP_NUMBER:\n \t  /* Push a value onto the stack.  */\n-\t  if (top->flags & HAVE_VALUE)\n+\t  if (!want_value)\n \t    SYNTAX_ERROR (\"missing binary operator\");\n+\tpush_immediate:\n+\t  want_value = false;\n \t  top->value = op.value;\n \t  top->unsignedp = op.unsignedp;\n-\t  top->flags |= HAVE_VALUE;\n \t  continue;\n \n-\tcase CPP_EOF:\tprio = FORCE_REDUCE_PRIO;\tbreak;\n-\n \tcase CPP_NOT:\n \t  saw_leading_not = lex_count == 1;\n-\t  prio = op_to_prio[op.op];\n \t  break;\n \tcase CPP_PLUS:\n-\tcase CPP_MINUS: prio = PLUS_PRIO;  if (top->flags & HAVE_VALUE) break;\n-          /* else unary; fall through */\n-\tdefault:\tprio = op_to_prio[op.op];\tbreak;\n+\t  if (want_value)\n+\t    op.op = CPP_UPLUS;\n+\t  break;\n+\tcase CPP_MINUS:\n+\t  if (want_value)\n+\t    op.op = CPP_UMINUS;\n+\t  break;\n+\tdefault:\n+\t  break;\n \t}\n \n-      /* Separate the operator's code into priority and flags.  */\n-      flags = EXTRACT_FLAGS(prio);\n-      prio = EXTRACT_PRIO(prio);\n-      if (prio == EXTRACT_PRIO(OPEN_PAREN_PRIO))\n+      flags = EXTRACT_FLAGS (op_to_prio[op.op]);\n+      prio = EXTRACT_PRIO (op_to_prio[op.op]);\n+      if (prio == EXTRACT_PRIO (OPEN_PAREN_PRIO))\n \tgoto skip_reduction;\n \n       /* Check for reductions.  Then push the operator.  */\n@@ -645,13 +648,15 @@ _cpp_parse_expr (pfile)\n \t  \n \t  /* Most operators that can appear on the stack require a\n \t     right operand.  Check this before trying to reduce.  */\n-\t  if ((top->flags & (HAVE_VALUE | NO_R_OPERAND)) == 0)\n+\t  if (want_value)\n \t    {\n \t      if (top->op == CPP_OPEN_PAREN)\n \t\tSYNTAX_ERROR (\"void expression between '(' and ')'\");\n-\t      else\n+\t      else if (top->op != CPP_EOF)\n \t\tSYNTAX_ERROR2 (\"operator '%s' has no right operand\",\n \t\t\t       op_as_text (pfile, top->op));\n+\t      else if (op.op != CPP_CLOSE_PAREN)\n+\t\tSYNTAX_ERROR (\"#if with no expression\");\n \t    }\n \n \t  unsigned2 = top->unsignedp, v2 = top->value;\n@@ -682,44 +687,35 @@ _cpp_parse_expr (pfile)\n \t    case CPP_MIN:\t MINMAX(<);\tbreak;\n \t    case CPP_MAX:\t MINMAX(>);\tbreak;\n \n+\t    case CPP_UPLUS:\n+\t      /* Can't use UNARY(+) because K+R C did not have unary\n+\t\t plus.  Can't use UNARY() because some compilers object\n+\t\t to the empty argument.  */\n+\t      top->value = v2;\n+\t      top->unsignedp = unsigned2;\n+\t      if (CPP_WTRADITIONAL (pfile))\n+\t\tcpp_error (pfile, DL_WARNING,\n+\t\t\t   \"traditional C rejects the unary plus operator\");\n+\t      break;\n+\t    case CPP_UMINUS:\n+\t      UNARY(-);\n+\t      if (!skip_evaluation && (top->value & v2) < 0 && !unsigned2)\n+\t\tinteger_overflow (pfile);\n+\t      break;\n+\n \t    case CPP_PLUS:\n-\t      if (!(top->flags & HAVE_VALUE))\n-\t\t{\n-\t\t  /* Can't use UNARY(+) because K+R C did not have unary\n-\t\t     plus.  Can't use UNARY() because some compilers object\n-\t\t     to the empty argument.  */\n-\t\t  top->value = v2;\n-\t\t  top->unsignedp = unsigned2;\n-\t\t  top->flags |= HAVE_VALUE;\n-\n-\t\t  if (CPP_WTRADITIONAL (pfile))\n-\t\t    cpp_error (pfile, DL_WARNING,\n-\t\t\t\"traditional C rejects the unary plus operator\");\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  top->value = v1 + v2;\n-\t\t  top->unsignedp = unsigned1 | unsigned2;\n-\t\t  if (! top->unsignedp && ! skip_evaluation\n-\t\t      && ! possible_sum_sign (v1, v2, top->value))\n-\t\t    integer_overflow (pfile);\n-\t\t}\n+\t      top->value = v1 + v2;\n+\t      top->unsignedp = unsigned1 | unsigned2;\n+\t      if (! top->unsignedp && ! skip_evaluation\n+\t\t  && ! possible_sum_sign (v1, v2, top->value))\n+\t\tinteger_overflow (pfile);\n \t      break;\n \t    case CPP_MINUS:\n-\t      if (!(top->flags & HAVE_VALUE))\n-\t\t{\n-\t\t  UNARY(-);\n-\t\t  if (!skip_evaluation && (top->value & v2) < 0 && !unsigned2)\n-\t\t    integer_overflow (pfile);\n-\t\t}\n-\t      else\n-\t\t{ /* Binary '-' */\n-\t\t  top->value = v1 - v2;\n-\t\t  top->unsignedp = unsigned1 | unsigned2;\n-\t\t  if (! top->unsignedp && ! skip_evaluation\n-\t\t      && ! possible_sum_sign (top->value, v2, v1))\n-\t\t    integer_overflow (pfile);\n-\t\t}\n+\t      top->value = v1 - v2;\n+\t      top->unsignedp = unsigned1 | unsigned2;\n+\t      if (! top->unsignedp && ! skip_evaluation\n+\t\t  && ! possible_sum_sign (top->value, v2, v1))\n+\t\tinteger_overflow (pfile);\n \t      break;\n \t    case CPP_MULT:\n \t      top->unsignedp = unsigned1 | unsigned2;\n@@ -821,16 +817,17 @@ _cpp_parse_expr (pfile)\n       /* Check we have a left operand iff we need one.  */\n       if (flags & NO_L_OPERAND)\n \t{\n-\t  if (top->flags & HAVE_VALUE)\n+\t  if (!want_value)\n \t    SYNTAX_ERROR2 (\"missing binary operator before '%s'\",\n \t\t\t   op_as_text (pfile, op.op));\n \t}\n       else\n \t{\n-\t  if (!(top->flags & HAVE_VALUE))\n+\t  if (want_value)\n \t    SYNTAX_ERROR2 (\"operator '%s' has no left operand\",\n \t\t\t   op_as_text (pfile, op.op));\n \t}\n+      want_value = true;\n \n       /* Check for and handle stack overflow.  */\n       top++;\n@@ -868,11 +865,6 @@ _cpp_parse_expr (pfile)\n   if (top != stack)\n     {\n       cpp_error (pfile, DL_ICE, \"unbalanced stack in #if\");\n-      goto syntax_error;\n-    }\n-  else if (!(top[1].flags & HAVE_VALUE))\n-    {\n-      SYNTAX_ERROR (\"#if with no expression\");\n     syntax_error:\n       result = 0;  /* Return 0 on syntax error.  */\n     }\n@@ -891,6 +883,11 @@ op_as_text (pfile, op)\n {\n   cpp_token token;\n \n+  if (op == CPP_UPLUS)\n+    op = CPP_PLUS;\n+  else if (op == CPP_UMINUS)\n+    op = CPP_MINUS;\n+\n   token.type = op;\n   token.flags = 0;\n   return cpp_token_as_text (pfile, &token);"}, {"sha": "164c4c8b5b5d3b49b12e45b81583cad6f040bb4a", "filename": "gcc/cpplib.h", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8b954fcdc0446691171bd20e6cb218799d4d1a9/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8b954fcdc0446691171bd20e6cb218799d4d1a9/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=f8b954fcdc0446691171bd20e6cb218799d4d1a9", "patch": "@@ -46,9 +46,9 @@ typedef struct cpp_callbacks cpp_callbacks;\n struct answer;\n struct file_name_map_list;\n \n-/* The first two groups, apart from '=', can appear in preprocessor\n-   expressions.  This allows a lookup table to be implemented in\n-   _cpp_parse_expr.\n+/* The first three groups, apart from '=', can appear in preprocessor\n+   expressions (+= and -= are used to indicate unary + and - resp.).\n+   This allows a lookup table to be implemented in _cpp_parse_expr.\n \n    The first group, to CPP_LAST_EQ, can be immediately followed by an\n    '='.  The lexer needs operators ending in '=', like \">>=\", to be in\n@@ -58,6 +58,7 @@ struct file_name_map_list;\n #define CPP_LAST_EQ CPP_MAX\n #define CPP_FIRST_DIGRAPH CPP_HASH\n #define CPP_LAST_PUNCTUATOR CPP_DOT_STAR\n+#define CPP_LAST_CPP_OP CPP_EOF\n \n #define TTYPE_TABLE\t\t\t\t\\\n   OP(CPP_EQ = 0,\t\"=\")\t\t\t\\\n@@ -90,8 +91,11 @@ struct file_name_map_list;\n   OP(CPP_GREATER_EQ,\t\">=\")\t\t\t\\\n   OP(CPP_LESS_EQ,\t\"<=\")\t\t\t\\\n \\\n+  /* These 3 are special in preprocessor expressions.  */ \\\n+  TK(CPP_EOF,\t\tSPELL_NONE)\t\t\\\n   OP(CPP_PLUS_EQ,\t\"+=\")\t/* math */\t\\\n   OP(CPP_MINUS_EQ,\t\"-=\")\t\t\t\\\n+\\\n   OP(CPP_MULT_EQ,\t\"*=\")\t\t\t\\\n   OP(CPP_DIV_EQ,\t\"/=\")\t\t\t\\\n   OP(CPP_MOD_EQ,\t\"%=\")\t\t\t\\\n@@ -135,8 +139,7 @@ struct file_name_map_list;\n   TK(CPP_COMMENT,\tSPELL_NUMBER)\t/* Only if output comments.  */ \\\n                                         /* SPELL_NUMBER happens to DTRT.  */ \\\n   TK(CPP_MACRO_ARG,\tSPELL_NONE)\t/* Macro argument.  */\t\t\\\n-  TK(CPP_PADDING,\tSPELL_NONE)\t/* Whitespace for cpp0.  */\t\\\n-  TK(CPP_EOF,\t\tSPELL_NONE)\t/* End of line or file.  */\n+  TK(CPP_PADDING,\tSPELL_NONE)\t/* Whitespace for cpp0.  */\n \n #define OP(e, s) e,\n #define TK(e, s) e,"}]}