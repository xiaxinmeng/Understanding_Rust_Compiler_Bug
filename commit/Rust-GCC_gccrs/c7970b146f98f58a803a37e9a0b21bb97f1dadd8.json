{"sha": "c7970b146f98f58a803a37e9a0b21bb97f1dadd8", "node_id": "C_kwDOANBUbNoAKGM3OTcwYjE0NmY5OGY1OGE4MDNhMzdlOWEwYjIxYmI5N2YxZGFkZDg", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-07-13T11:52:59Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-07-13T12:58:34Z"}, "message": "Speed up DOM record_temporary_equivalences\n\nThe following gets away computing a dominance bitmap when\nfast queries are not available and we are doing\nback_propagate_equivalences.  The comuted bitmap can be\ncheaply kept up-to-date during the domwalk since it is\nsimply the set of blocks on the domwalk stack.\n\nAbstraction of the threading makes this somewhat awkward\nbut it also fulfills the fixme comment in only considering\nequivalences in already (domwalk) visited blocks, even when\nquerying from the outgoing block of a forward thread.  Maybe\nthat's not what is intended but at least we have no testsuite\ncoverage of such missed equivalences.\n\n\t* tree-ssa-dom.h (record_temporary_equivalences): Remove.\n\t* tree-ssa-dom.cc (dom_jt_state::m_blocks_on_stack): New.\n\t(dom_jt_state::get_blocks_on_stack): Likewise.\n\t(dom_opt_dom_walker::dom_opt_dom_walker): Take dom_jt_state.\n\t(back_propagate_equivalences): Remove dominator bitmap\n\tcompute and instead use passed in m_blocks_on_stack.\n\t(record_temporary_equivalences): Likewise.\n\t(record_equivalences_from_incoming_edge): Likewise.\n\t(dom_opt_dom_walker::before_dom_children): Maintain and\n\tpass down blocks on stack.\n\t(dom_opt_dom_walker::after_dom_children): Likewise.", "tree": {"sha": "004a0f2fd9c19a8fc3fcee3a00716d2bf46a2e36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/004a0f2fd9c19a8fc3fcee3a00716d2bf46a2e36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7970b146f98f58a803a37e9a0b21bb97f1dadd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7970b146f98f58a803a37e9a0b21bb97f1dadd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7970b146f98f58a803a37e9a0b21bb97f1dadd8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7970b146f98f58a803a37e9a0b21bb97f1dadd8/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c5730a64d9ee29b84cb423cdb2cf3ab3c568701", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c5730a64d9ee29b84cb423cdb2cf3ab3c568701", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c5730a64d9ee29b84cb423cdb2cf3ab3c568701"}], "stats": {"total": 70, "additions": 31, "deletions": 39}, "files": [{"sha": "f5e8f57499760f04f07f4c85f00765899ec1329e", "filename": "gcc/tree-ssa-dom.cc", "status": "modified", "additions": 31, "deletions": 36, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7970b146f98f58a803a37e9a0b21bb97f1dadd8/gcc%2Ftree-ssa-dom.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7970b146f98f58a803a37e9a0b21bb97f1dadd8/gcc%2Ftree-ssa-dom.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.cc?ref=c7970b146f98f58a803a37e9a0b21bb97f1dadd8", "patch": "@@ -112,14 +112,17 @@ static void record_equality (tree, tree, class const_and_copies *);\n static void record_equivalences_from_phis (basic_block);\n static void record_equivalences_from_incoming_edge (basic_block,\n \t\t\t\t\t\t    class const_and_copies *,\n-\t\t\t\t\t\t    class avail_exprs_stack *);\n+\t\t\t\t\t\t    class avail_exprs_stack *,\n+\t\t\t\t\t\t    bitmap blocks_on_stack);\n static void eliminate_redundant_computations (gimple_stmt_iterator *,\n \t\t\t\t\t      class const_and_copies *,\n \t\t\t\t\t      class avail_exprs_stack *);\n static void record_equivalences_from_stmt (gimple *, int,\n \t\t\t\t\t   class avail_exprs_stack *);\n static void dump_dominator_optimization_stats (FILE *file,\n \t\t\t\t\t       hash_table<expr_elt_hasher> *);\n+static void record_temporary_equivalences (edge, class const_and_copies *,\n+\t\t\t\t\t   class avail_exprs_stack *, bitmap);\n \n /* Constructor for EDGE_INFO.  An EDGE_INFO instance is always\n    associated with an edge E.  */\n@@ -591,6 +594,7 @@ class dom_jt_state : public jt_state\n   dom_jt_state (const_and_copies *copies, avail_exprs_stack *avails)\n     : m_copies (copies), m_avails (avails)\n   {\n+    bitmap_tree_view (m_blocks_on_stack);\n   }\n   void push (edge e) override\n   {\n@@ -606,12 +610,16 @@ class dom_jt_state : public jt_state\n   }\n   void register_equivs_edge (edge e) override\n   {\n-    record_temporary_equivalences (e, m_copies, m_avails);\n+    record_temporary_equivalences (e, m_copies, m_avails, m_blocks_on_stack);\n   }\n   void register_equiv (tree dest, tree src, bool update) override;\n+  bitmap get_blocks_on_stack () { return m_blocks_on_stack; }\n private:\n   const_and_copies *m_copies;\n   avail_exprs_stack *m_avails;\n+  /* Set of blocks on the stack, to be used for medium-fast\n+     dominance queries in back_propagate_equivalences.  */\n+  auto_bitmap m_blocks_on_stack;\n };\n \n void\n@@ -653,7 +661,7 @@ class dom_opt_dom_walker : public dom_walker\n public:\n   dom_opt_dom_walker (cdi_direction direction,\n \t\t      jump_threader *threader,\n-\t\t      jt_state *state,\n+\t\t      dom_jt_state *state,\n \t\t      gimple_ranger *ranger,\n \t\t      const_and_copies *const_and_copies,\n \t\t      avail_exprs_stack *avail_exprs_stack)\n@@ -693,7 +701,7 @@ class dom_opt_dom_walker : public dom_walker\n \n   jump_threader *m_threader;\n   gimple_ranger *m_ranger;\n-  jt_state *m_state;\n+  dom_jt_state *m_state;\n };\n \n /* Jump threading, redundancy elimination and const/copy propagation.\n@@ -962,7 +970,7 @@ dom_valueize (tree t)\n static void\n back_propagate_equivalences (tree lhs, edge e,\n \t\t\t     class const_and_copies *const_and_copies,\n-\t\t\t     bitmap *domby)\n+\t\t\t     bitmap domby)\n {\n   use_operand_p use_p;\n   imm_use_iterator iter;\n@@ -997,29 +1005,12 @@ back_propagate_equivalences (tree lhs, edge e,\n \t}\n       else\n \t{\n-\t  /* Profiling has shown the domination tests here can be fairly\n-\t     expensive when the fast indexes are not computed.\n-\t     We get significant improvements by building the\n-\t     set of blocks that dominate BB.  We can then just test\n-\t     for set membership below.\n-\n-\t     We also initialize the set lazily since often the only uses\n-\t     are going to be in the same block as DEST.  */\n-\n-\t  if (!*domby)\n-\t    {\n-\t      *domby = BITMAP_ALLOC (NULL);\n-\t      bitmap_tree_view (*domby);\n-\t      basic_block bb = get_immediate_dominator (CDI_DOMINATORS, dest);\n-\t      while (bb)\n-\t\t{\n-\t\t  bitmap_set_bit (*domby, bb->index);\n-\t\t  bb = get_immediate_dominator (CDI_DOMINATORS, bb);\n-\t\t}\n-\t    }\n-\n+\t  /* We can use the set of BBs on the stack from a domwalk\n+\t     for a medium fast way to query dominance.  Profiling\n+\t     has shown non-fast query dominance tests here can be fairly\n+\t     expensive.  */\n \t  /* This tests if USE_STMT does not dominate DEST.  */\n-\t  if (!bitmap_bit_p (*domby, gimple_bb (use_stmt)->index))\n+\t  if (!bitmap_bit_p (domby, gimple_bb (use_stmt)->index))\n \t    continue;\n \t}\n \n@@ -1037,10 +1028,11 @@ back_propagate_equivalences (tree lhs, edge e,\n    by traversing edge E (which are cached in E->aux).\n \n    Callers are responsible for managing the unwinding markers.  */\n-void\n+static void\n record_temporary_equivalences (edge e,\n \t\t\t       class const_and_copies *const_and_copies,\n-\t\t\t       class avail_exprs_stack *avail_exprs_stack)\n+\t\t\t       class avail_exprs_stack *avail_exprs_stack,\n+\t\t\t       bitmap blocks_on_stack)\n {\n   int i;\n   class edge_info *edge_info = (class edge_info *) e->aux;\n@@ -1055,7 +1047,6 @@ record_temporary_equivalences (edge e,\n       for (i = 0; edge_info->cond_equivalences.iterate (i, &eq); ++i)\n \tavail_exprs_stack->record_cond (eq);\n \n-      bitmap domby = NULL;\n       edge_info::equiv_pair *seq;\n       for (i = 0; edge_info->simple_equivalences.iterate (i, &seq); ++i)\n \t{\n@@ -1092,10 +1083,9 @@ record_temporary_equivalences (edge e,\n \t  /* Any equivalence found for LHS may result in additional\n \t     equivalences for other uses of LHS that we have already\n \t     processed.  */\n-\t  back_propagate_equivalences (lhs, e, const_and_copies, &domby);\n+\t  back_propagate_equivalences (lhs, e, const_and_copies,\n+\t\t\t\t       blocks_on_stack);\n \t}\n-      if (domby)\n-\tBITMAP_FREE (domby);\n     }\n }\n \n@@ -1267,7 +1257,8 @@ dom_opt_dom_walker::set_global_ranges_from_unreachable_edges (basic_block bb)\n static void\n record_equivalences_from_incoming_edge (basic_block bb,\n     class const_and_copies *const_and_copies,\n-    class avail_exprs_stack *avail_exprs_stack)\n+    class avail_exprs_stack *avail_exprs_stack,\n+    bitmap blocks_on_stack)\n {\n   edge e;\n   basic_block parent;\n@@ -1282,7 +1273,8 @@ record_equivalences_from_incoming_edge (basic_block bb,\n   /* If we had a single incoming edge from our parent block, then enter\n      any data associated with the edge into our tables.  */\n   if (e && e->src == parent)\n-    record_temporary_equivalences (e, const_and_copies, avail_exprs_stack);\n+    record_temporary_equivalences (e, const_and_copies, avail_exprs_stack,\n+\t\t\t\t   blocks_on_stack);\n }\n \n /* Dump statistics for the hash table HTAB.  */\n@@ -1517,9 +1509,11 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n      far to unwind when we finalize this block.  */\n   m_avail_exprs_stack->push_marker ();\n   m_const_and_copies->push_marker ();\n+  bitmap_set_bit (m_state->get_blocks_on_stack (), bb->index);\n \n   record_equivalences_from_incoming_edge (bb, m_const_and_copies,\n-\t\t\t\t\t  m_avail_exprs_stack);\n+\t\t\t\t\t  m_avail_exprs_stack,\n+\t\t\t\t\t  m_state->get_blocks_on_stack ());\n   set_global_ranges_from_unreachable_edges (bb);\n \n   /* PHI nodes can create equivalences too.  */\n@@ -1594,6 +1588,7 @@ void\n dom_opt_dom_walker::after_dom_children (basic_block bb)\n {\n   m_threader->thread_outgoing_edges (bb);\n+  bitmap_clear_bit (m_state->get_blocks_on_stack (), bb->index);\n   m_avail_exprs_stack->pop_to_marker ();\n   m_const_and_copies->pop_to_marker ();\n }"}, {"sha": "98154c5313f52b1901e9a0aa7a42e9434d9afc0e", "filename": "gcc/tree-ssa-dom.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7970b146f98f58a803a37e9a0b21bb97f1dadd8/gcc%2Ftree-ssa-dom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7970b146f98f58a803a37e9a0b21bb97f1dadd8/gcc%2Ftree-ssa-dom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.h?ref=c7970b146f98f58a803a37e9a0b21bb97f1dadd8", "patch": "@@ -21,8 +21,5 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_TREE_SSA_DOM_H\n \n extern bool simple_iv_increment_p (gimple *);\n-extern void record_temporary_equivalences (edge,\n-\t\t\t\t\t   class const_and_copies *,\n-\t\t\t\t\t   class avail_exprs_stack *);\n \n #endif /* GCC_TREE_SSA_DOM_H */"}]}