{"sha": "19590d704b6d6eb487b63e112490e1d19946bae7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk1OTBkNzA0YjZkNmViNDg3YjYzZTExMjQ5MGUxZDE5OTQ2YmFlNw==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2007-08-16T12:18:16Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-16T12:18:16Z"}, "message": "exp_aggr.adb (Build_Record_Aggr_Code): Extend the test for an ancestor part given by an aggregate to test for an...\n\n2007-08-16  Gary Dismukes  <dismukes@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* exp_aggr.adb (Build_Record_Aggr_Code): Extend the test for an\n\tancestor part given by an aggregate to test for an unchecked conversion,\n\tsince this can occur in some cases when the ancestor part is a function\n\tcall, and we don't want to fall into the recursive call to this\n\tprocedure in that case.\n\n\t* exp_ch3.adb (Stream_Operation_OK): Revise tests for availability of\n\tstream attributes on limited types to account for user-specified\n\tattributes as well as whether Input (resp. Output) becomes available\n\tdue to Read (resp. Write) being available for the type. Change Boolean\n\tvariable to the more accurate name\n\tHas_Predefined_Or_Specified_Stream_Attribute. Change convoluted\n\tdouble-\"not\" predicate at beginning of return statement to more\n\tunderstandable form.\n\n\t* exp_ch5.adb (Expand_N_Extended_Return_Statement): If the extended\n\treturn has an associated N_Handled_Sequence_Of_Statements, then wrap it\n\tin a block statement and use that as the first statement of the\n\texpanded return rather than incorrectly using the handled sequence as\n\tthe first statement.\n\n\t* exp_ch6.adb (Expand_N_Subprogram_Declaration): If this is a protected\n\toperation, generate an explicit freeze node for it rather than\n\tgenerating extra formals, to ensure that gigi has the proper order of\n\telaboration for anonymous subtypes in the signature of the subprograms.\n\t(Build_In_Place_Formal): Move assertion to beginning of loop.\n\t(Is_Build_In_Place_Function_Call): Allow for an unchecked conversion\n\tapplied to a function call (occurs for some cases of 'Input).\n\t(Make_Build_In_Place_Call_In_*): Allow for an unchecked conversion\n\tapplied to a function call (occurs for some cases of 'Input).\n\n\t* exp_strm.adb (Build_Record_Or_Elementary_Input_Function): For Ada\n\t2005, generate an extended return statement enclosing the result object\n\tand 'Read call.\n\n\t* freeze.adb (Freeze_Record_Type): Extend the current management of\n\tcomponents that are access type with an allocator as default value: add\n\tmissing support to the use of qualified expressions of the\n\tallocator (which also cause freezing of the designated type!)\n\t(Freeze_Entity): Call Freeze_Subprogram in the case of a predefined\n\tdispatching operation, since extra formals may be needed by calls to\n\tbuild-in-place functions (such as stream 'Input).\n\n\t* sem_ch6.adb (Create_Extra_Formals): Skip creation of the extra\n\tformals for 'Constrained and accessibility level in the case of a\n\tpredefined dispatching operation.\n\n\t* exp_util.adb (Insert_Actions): A protected body is a valid insertion\n\tpoint, no need to find the parent node.\n\nFrom-SVN: r127538", "tree": {"sha": "8287b01b502f473c13196227c59903c163f16ae6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8287b01b502f473c13196227c59903c163f16ae6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19590d704b6d6eb487b63e112490e1d19946bae7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19590d704b6d6eb487b63e112490e1d19946bae7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19590d704b6d6eb487b63e112490e1d19946bae7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19590d704b6d6eb487b63e112490e1d19946bae7/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4c8e94abdccacc49ab9a087e34cd89cee8bc2f7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c8e94abdccacc49ab9a087e34cd89cee8bc2f7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c8e94abdccacc49ab9a087e34cd89cee8bc2f7e"}], "stats": {"total": 337, "additions": 246, "deletions": 91}, "files": [{"sha": "332b3c5605c23220c3d2f0bf1eeb00bdc4dc60e0", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19590d704b6d6eb487b63e112490e1d19946bae7/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19590d704b6d6eb487b63e112490e1d19946bae7/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=19590d704b6d6eb487b63e112490e1d19946bae7", "patch": "@@ -2426,11 +2426,15 @@ package body Exp_Aggr is\n             --  Ada 2005 (AI-287): If the ancestor part is an aggregate of\n             --  limited type, a recursive call expands the ancestor. Note that\n             --  in the limited case, the ancestor part must be either a\n-            --  function call (possibly qualified) or aggregate (definitely\n-            --  qualified).\n+            --  function call (possibly qualified, or wrapped in an unchecked\n+            --  conversion) or aggregate (definitely qualified).\n \n             elsif Is_Limited_Type (Etype (A))\n               and then Nkind (Unqualify (A)) /= N_Function_Call --  aggregate?\n+              and then\n+                (Nkind (Unqualify (A)) /= N_Unchecked_Type_Conversion\n+                   or else\n+                 Nkind (Expression (Unqualify (A))) /= N_Function_Call)\n             then\n                Ancestor_Is_Expression := True;\n "}, {"sha": "be5051265a5d1a6e933d1b5ba6ac2da2116fa2ba", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 54, "deletions": 20, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19590d704b6d6eb487b63e112490e1d19946bae7/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19590d704b6d6eb487b63e112490e1d19946bae7/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=19590d704b6d6eb487b63e112490e1d19946bae7", "patch": "@@ -8026,33 +8026,67 @@ package body Exp_Ch3 is\n      (Typ       : Entity_Id;\n       Operation : TSS_Name_Type) return Boolean\n    is\n-      Has_Inheritable_Stream_Attribute : Boolean := False;\n+      Has_Predefined_Or_Specified_Stream_Attribute : Boolean := False;\n \n    begin\n+      --  Special case of a limited type extension: a default implementation\n+      --  of the stream attributes Read or Write exists if that attribute\n+      --  has been specified or is available for an ancestor type; a default\n+      --  implementation of the attribute Output (resp. Input) exists if the\n+      --  attribute has been specified or Write (resp. Read) is available for\n+      --  an ancestor type. The last condition only applies under Ada 2005.\n+\n       if Is_Limited_Type (Typ)\n         and then Is_Tagged_Type (Typ)\n-        and then Is_Derived_Type (Typ)\n       then\n-         --  Special case of a limited type extension: a default implementation\n-         --  of the stream attributes Read and Write exists if the attribute\n-         --  has been specified for an ancestor type.\n+         if Operation = TSS_Stream_Read then\n+            Has_Predefined_Or_Specified_Stream_Attribute :=\n+              Has_Specified_Stream_Read (Typ);\n+\n+         elsif Operation = TSS_Stream_Write then\n+            Has_Predefined_Or_Specified_Stream_Attribute :=\n+              Has_Specified_Stream_Write (Typ);\n+\n+         elsif Operation = TSS_Stream_Input then\n+            Has_Predefined_Or_Specified_Stream_Attribute :=\n+              Has_Specified_Stream_Input (Typ)\n+                or else\n+                  (Ada_Version >= Ada_05\n+                    and then Stream_Operation_OK (Typ, TSS_Stream_Read));\n+\n+         elsif Operation = TSS_Stream_Output then\n+            Has_Predefined_Or_Specified_Stream_Attribute :=\n+              Has_Specified_Stream_Output (Typ)\n+                or else\n+                  (Ada_Version >= Ada_05\n+                    and then Stream_Operation_OK (Typ, TSS_Stream_Write));\n+         end if;\n+\n+         --  Case of inherited TSS_Stream_Read or TSS_Stream_Write\n \n-         Has_Inheritable_Stream_Attribute :=\n-           Present (Find_Inherited_TSS (Base_Type (Etype (Typ)), Operation));\n+         if not Has_Predefined_Or_Specified_Stream_Attribute\n+           and then Is_Derived_Type (Typ)\n+           and then (Operation = TSS_Stream_Read\n+                      or else Operation = TSS_Stream_Write)\n+         then\n+            Has_Predefined_Or_Specified_Stream_Attribute :=\n+              Present\n+                (Find_Inherited_TSS (Base_Type (Etype (Typ)), Operation));\n+         end if;\n       end if;\n \n-      return\n-        not (Is_Limited_Type (Typ)\n-               and then not Has_Inheritable_Stream_Attribute)\n-          and then not Has_Unknown_Discriminants (Typ)\n-          and then not (Is_Interface (Typ)\n-                         and then (Is_Task_Interface (Typ)\n-                                   or else Is_Protected_Interface (Typ)\n-                                   or else Is_Synchronized_Interface (Typ)))\n-          and then not Restriction_Active (No_Streams)\n-          and then not Restriction_Active (No_Dispatch)\n-          and then not No_Run_Time_Mode\n-          and then RTE_Available (RE_Tag)\n-          and then RTE_Available (RE_Root_Stream_Type);\n+      return (not Is_Limited_Type (Typ)\n+               or else Has_Predefined_Or_Specified_Stream_Attribute)\n+        and then not Has_Unknown_Discriminants (Typ)\n+        and then not (Is_Interface (Typ)\n+                       and then (Is_Task_Interface (Typ)\n+                                  or else Is_Protected_Interface (Typ)\n+                                  or else Is_Synchronized_Interface (Typ)))\n+        and then not Restriction_Active (No_Streams)\n+        and then not Restriction_Active (No_Dispatch)\n+        and then not No_Run_Time_Mode\n+        and then RTE_Available (RE_Tag)\n+        and then RTE_Available (RE_Root_Stream_Type);\n    end Stream_Operation_OK;\n+\n end Exp_Ch3;"}, {"sha": "30f89d0ef92265cc50a095e2a177d2df1a227c53", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19590d704b6d6eb487b63e112490e1d19946bae7/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19590d704b6d6eb487b63e112490e1d19946bae7/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=19590d704b6d6eb487b63e112490e1d19946bae7", "patch": "@@ -1412,7 +1412,6 @@ package body Exp_Ch5 is\n             Call           : Node_Id;\n             Conctyp        : Entity_Id;\n             Ent            : Entity_Id;\n-            Object_Parm    : Node_Id;\n             Subprg         : Entity_Id;\n             RT_Subprg_Name : Node_Id;\n \n@@ -1428,7 +1427,7 @@ package body Exp_Ch5 is\n             end loop;\n \n             --  The attribute Priority applied to protected objects has been\n-            --  previously expanded into calls to the Get_Ceiling run-time\n+            --  previously expanded into a call to the Get_Ceiling run-time\n             --  subprogram.\n \n             if Nkind (Ent) = N_Function_Call\n@@ -1452,18 +1451,6 @@ package body Exp_Ch5 is\n                   Subprg := Scope (Subprg);\n                end loop;\n \n-               Object_Parm :=\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix =>\n-                     Make_Selected_Component (Loc,\n-                       Prefix => New_Reference_To\n-                                   (First_Entity\n-                                     (Protected_Body_Subprogram (Subprg)),\n-                                    Loc),\n-                     Selector_Name =>\n-                       Make_Identifier (Loc, Name_uObject)),\n-                   Attribute_Name => Name_Unchecked_Access);\n-\n                --  Select the appropriate run-time call\n \n                if Number_Entries (Conctyp) = 0 then\n@@ -1477,9 +1464,9 @@ package body Exp_Ch5 is\n                Call :=\n                  Make_Procedure_Call_Statement (Loc,\n                    Name => RT_Subprg_Name,\n-                   Parameter_Associations =>\n-                     New_List (Object_Parm,\n-                               Relocate_Node (Expression (N))));\n+                   Parameter_Associations => New_List (\n+                     New_Copy_Tree (First (Parameter_Associations (Ent))),\n+                     Relocate_Node (Expression (N))));\n \n                Rewrite (N, Call);\n                Analyze (N);\n@@ -1616,16 +1603,16 @@ package body Exp_Ch5 is\n             --  We do not need to reanalyze that assignment, and we do not need\n             --  to worry about references to the temporary, but we do need to\n             --  make sure that the temporary is not marked as a true constant\n-            --  since we now have a generate assignment to it!\n+            --  since we now have a generated assignment to it!\n \n             Set_Is_True_Constant (Tnn, False);\n          end;\n       end if;\n \n-      --  When we have the appropriate type of aggregate in the\n-      --  expression (it has been determined during analysis of the\n-      --  aggregate by setting the delay flag), let's perform in place\n-      --  assignment and thus avoid creating a temporay.\n+      --  When we have the appropriate type of aggregate in the expression (it\n+      --  has been determined during analysis of the aggregate by setting the\n+      --  delay flag), let's perform in place assignment and thus avoid\n+      --  creating a temporary.\n \n       if Is_Delayed_Aggregate (Rhs) then\n          Convert_Aggr_In_Assignment (N);\n@@ -1762,8 +1749,10 @@ package body Exp_Ch5 is\n          Make_Build_In_Place_Call_In_Assignment (N, Rhs);\n \n       elsif Is_Tagged_Type (Typ) and then Is_Value_Type (Etype (Lhs)) then\n+\n          --  Nothing to do for valuetypes\n          --  ??? Set_Scope_Is_Transient (False);\n+\n          return;\n \n       elsif Is_Tagged_Type (Typ)\n@@ -2059,9 +2048,8 @@ package body Exp_Ch5 is\n             elsif Is_Entity_Name (Lhs)\n               and then Is_Known_Valid (Entity (Lhs))\n             then\n-               --  Note that the Ensure_Valid call is ignored if the\n-               --  Validity_Checking mode is set to none so we do not\n-               --  need to worry about that case here.\n+               --  Note: If Validity_Checking mode is set to none, we ignore\n+               --  the Ensure_Valid call so don't worry about that case here.\n \n                Ensure_Valid (Rhs);\n \n@@ -2484,10 +2472,17 @@ package body Exp_Ch5 is\n         or else Is_Composite_Type (Etype (Parent_Function))\n         or else No (Exp)\n       then\n-         Statements := New_List;\n+         if No (Handled_Stm_Seq) then\n+            Statements := New_List;\n+\n+         --  If the extended return has a handled statement sequence, then wrap\n+         --  it in a block and use the block as the first statement.\n \n-         if Present (Handled_Stm_Seq) then\n-            Append_To (Statements, Handled_Stm_Seq);\n+         else\n+            Statements :=\n+              New_List (Make_Block_Statement (Loc,\n+                          Declarations => New_List,\n+                          Handled_Statement_Sequence => Handled_Stm_Seq));\n          end if;\n \n          --  If control gets past the above Statements, we have successfully"}, {"sha": "ce68b6d85f2f1ff3cf4fa9d94e044bf8d1e6fb6e", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19590d704b6d6eb487b63e112490e1d19946bae7/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19590d704b6d6eb487b63e112490e1d19946bae7/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=19590d704b6d6eb487b63e112490e1d19946bae7", "patch": "@@ -537,11 +537,11 @@ package body Exp_Ch6 is\n       --  function to have a flag or a Uint attribute to identify it. ???\n \n       loop\n+         pragma Assert (Present (Extra_Formal));\n          exit when\n            Chars (Extra_Formal) =\n              New_External_Name (Chars (Func), BIP_Formal_Suffix (Kind));\n          Next_Formal_With_Extras (Extra_Formal);\n-         pragma Assert (Present (Extra_Formal));\n       end loop;\n \n       return Extra_Formal;\n@@ -4551,6 +4551,8 @@ package body Exp_Ch6 is\n             --  The protected subprogram is declared outside of the protected\n             --  body. Given that the body has frozen all entities so far, we\n             --  analyze the subprogram and perform freezing actions explicitly.\n+            --  including the generation of an explicit freeze node, to ensure\n+            --  that gigi has the proper order of elaboration.\n             --  If the body is a subunit, the insertion point is before the\n             --  stub in the parent.\n \n@@ -4562,10 +4564,11 @@ package body Exp_Ch6 is\n \n             Insert_Before (Prot_Bod, Prot_Decl);\n             Prot_Id := Defining_Unit_Name (Specification (Prot_Decl));\n+            Set_Has_Delayed_Freeze (Prot_Id);\n \n             Push_Scope (Scope (Scop));\n             Analyze (Prot_Decl);\n-            Create_Extra_Formals (Prot_Id);\n+            Insert_Actions (N, Freeze_Entity (Prot_Id, Loc));\n             Set_Protected_Body_Subprogram (Subp, Prot_Id);\n             Pop_Scope;\n          end if;\n@@ -4820,7 +4823,12 @@ package body Exp_Ch6 is\n       Function_Id : Entity_Id;\n \n    begin\n-      if Nkind (Exp_Node) = N_Qualified_Expression then\n+      --  Step past qualification or unchecked conversion (the latter can occur\n+      --  in cases of calls to 'Input).\n+\n+      if Nkind (Exp_Node) = N_Qualified_Expression\n+        or else Nkind (Exp_Node) = N_Unchecked_Type_Conversion\n+      then\n          Exp_Node := Expression (N);\n       end if;\n \n@@ -5022,7 +5030,12 @@ package body Exp_Ch6 is\n       Return_Obj_Access : Entity_Id;\n \n    begin\n-      if Nkind (Func_Call) = N_Qualified_Expression then\n+      --  Step past qualification or unchecked conversion (the latter can occur\n+      --  in cases of calls to 'Input).\n+\n+      if Nkind (Func_Call) = N_Qualified_Expression\n+        or else Nkind (Func_Call) = N_Unchecked_Type_Conversion\n+      then\n          Func_Call := Expression (Func_Call);\n       end if;\n \n@@ -5158,7 +5171,12 @@ package body Exp_Ch6 is\n       Return_Obj_Decl : Entity_Id;\n \n    begin\n-      if Nkind (Func_Call) = N_Qualified_Expression then\n+      --  Step past qualification or unchecked conversion (the latter can occur\n+      --  in cases of calls to 'Input).\n+\n+      if Nkind (Func_Call) = N_Qualified_Expression\n+        or else Nkind (Func_Call) = N_Unchecked_Type_Conversion\n+      then\n          Func_Call := Expression (Func_Call);\n       end if;\n \n@@ -5267,7 +5285,12 @@ package body Exp_Ch6 is\n       New_Expr        : Node_Id;\n \n    begin\n-      if Nkind (Func_Call) = N_Qualified_Expression then\n+      --  Step past qualification or unchecked conversion (the latter can occur\n+      --  in cases of calls to 'Input).\n+\n+      if Nkind (Func_Call) = N_Qualified_Expression\n+        or else Nkind (Func_Call) = N_Unchecked_Type_Conversion\n+      then\n          Func_Call := Expression (Func_Call);\n       end if;\n \n@@ -5372,7 +5395,12 @@ package body Exp_Ch6 is\n       Pass_Caller_Acc : Boolean := False;\n \n    begin\n-      if Nkind (Func_Call) = N_Qualified_Expression then\n+      --  Step past qualification or unchecked conversion (the latter can occur\n+      --  in cases of calls to 'Input).\n+\n+      if Nkind (Func_Call) = N_Qualified_Expression\n+        or else Nkind (Func_Call) = N_Unchecked_Type_Conversion\n+      then\n          Func_Call := Expression (Func_Call);\n       end if;\n "}, {"sha": "bfc5d585d97916e8389c84791bf6a7d8222544f0", "filename": "gcc/ada/exp_strm.adb", "status": "modified", "additions": 40, "deletions": 13, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19590d704b6d6eb487b63e112490e1d19946bae7/gcc%2Fada%2Fexp_strm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19590d704b6d6eb487b63e112490e1d19946bae7/gcc%2Fada%2Fexp_strm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_strm.adb?ref=19590d704b6d6eb487b63e112490e1d19946bae7", "patch": "@@ -29,6 +29,7 @@ with Einfo;    use Einfo;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n+with Opt;      use Opt;\n with Rtsfind;  use Rtsfind;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n@@ -1145,21 +1146,47 @@ package body Exp_Strm is\n          Odef := New_Occurrence_Of (Typ, Loc);\n       end if;\n \n-      Append_To (Decls,\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Make_Defining_Identifier (Loc, Name_V),\n-          Object_Definition => Odef));\n+      --  For Ada 2005 we create an extended return statement encapsulating\n+      --  the result object and 'Read call, which is needed in general for\n+      --  proper handling of build-in-place results (such as when the result\n+      --  type is inherently limited).\n+\n+      --  Perhaps we should just generate an extended return in all cases???\n+\n+      if Ada_Version >= Ada_05 then\n+         Stms := New_List (\n+           Make_Extended_Return_Statement (Loc,\n+             Return_Object_Declarations =>\n+               New_List (Make_Object_Declaration (Loc,\n+                           Defining_Identifier =>\n+                             Make_Defining_Identifier (Loc, Name_V),\n+                           Object_Definition => Odef)),\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 New_List (Make_Attribute_Reference (Loc,\n+                             Prefix => New_Occurrence_Of (Typ, Loc),\n+                             Attribute_Name => Name_Read,\n+                             Expressions => New_List (\n+                               Make_Identifier (Loc, Name_S),\n+                               Make_Identifier (Loc, Name_V)))))));\n \n-      Stms := New_List (\n-         Make_Attribute_Reference (Loc,\n-           Prefix => New_Occurrence_Of (Typ, Loc),\n-           Attribute_Name => Name_Read,\n-           Expressions => New_List (\n-             Make_Identifier (Loc, Name_S),\n-             Make_Identifier (Loc, Name_V))),\n+      else\n+         Append_To (Decls,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Make_Defining_Identifier (Loc, Name_V),\n+             Object_Definition => Odef));\n \n-         Make_Simple_Return_Statement (Loc,\n-           Expression => Make_Identifier (Loc, Name_V)));\n+         Stms := New_List (\n+            Make_Attribute_Reference (Loc,\n+              Prefix => New_Occurrence_Of (Typ, Loc),\n+              Attribute_Name => Name_Read,\n+              Expressions => New_List (\n+                Make_Identifier (Loc, Name_S),\n+                Make_Identifier (Loc, Name_V))),\n+\n+            Make_Simple_Return_Statement (Loc,\n+              Expression => Make_Identifier (Loc, Name_V)));\n+      end if;\n \n       Fnam := Make_Stream_Subprogram_Name (Loc, Typ, TSS_Stream_Input);\n "}, {"sha": "d00c96d031e90425290cc997ffde0b5953af0b1f", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19590d704b6d6eb487b63e112490e1d19946bae7/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19590d704b6d6eb487b63e112490e1d19946bae7/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=19590d704b6d6eb487b63e112490e1d19946bae7", "patch": "@@ -1065,7 +1065,7 @@ package body Exp_Util is\n       --  itype, so that gigi can elaborate it on the proper objstack.\n \n       if Is_Itype (Typ)\n-        and then  Scope (Typ) = Current_Scope\n+        and then Scope (Typ) = Current_Scope\n       then\n          IR := Make_Itype_Reference (Sloc (N));\n          Set_Itype (IR, Typ);\n@@ -2476,6 +2476,7 @@ package body Exp_Util is\n                N_Private_Extension_Declaration          |\n                N_Private_Type_Declaration               |\n                N_Procedure_Instantiation                |\n+               N_Protected_Body                         |\n                N_Protected_Body_Stub                    |\n                N_Protected_Type_Declaration             |\n                N_Single_Task_Declaration                |\n@@ -2748,7 +2749,6 @@ package body Exp_Util is\n                N_Pop_Storage_Error_Label                |\n                N_Pragma_Argument_Association            |\n                N_Procedure_Specification                |\n-               N_Protected_Body                         |\n                N_Protected_Definition                   |\n                N_Push_Constraint_Error_Label            |\n                N_Push_Program_Error_Label               |"}, {"sha": "2923aede4c5d69ef090b2cbfadd2350009867941", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 49, "deletions": 13, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19590d704b6d6eb487b63e112490e1d19946bae7/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19590d704b6d6eb487b63e112490e1d19946bae7/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=19590d704b6d6eb487b63e112490e1d19946bae7", "patch": "@@ -1,4 +1,4 @@\n-------------------------------------------------------------------------------\n+-----------------------------------------------------------------------------\n --                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n@@ -1461,6 +1461,10 @@ package body Freeze is\n          --  Set True if we find at least one component with a component\n          --  clause (used to warn about useless Bit_Order pragmas).\n \n+         function Check_Allocator (N : Node_Id) return Boolean;\n+         --  Returns True if N is an expression or a qualified expression with\n+         --  an allocator.\n+\n          procedure Check_Itype (Typ : Entity_Id);\n          --  If the component subtype is an access to a constrained subtype of\n          --  an already frozen type, make the subtype frozen as well. It might\n@@ -1471,6 +1475,21 @@ package body Freeze is\n          --  freeze node at some eventual point of call. Protected operations\n          --  are handled elsewhere.\n \n+         ---------------------\n+         -- Check_Allocator --\n+         ---------------------\n+\n+         function Check_Allocator (N : Node_Id) return Boolean is\n+         begin\n+            if Nkind (N) = N_Allocator then\n+               return True;\n+            elsif Nkind (N) = N_Qualified_Expression then\n+               return Check_Allocator (Expression (N));\n+            else\n+               return False;\n+            end if;\n+         end Check_Allocator;\n+\n          -----------------\n          -- Check_Itype --\n          -----------------\n@@ -1819,16 +1838,24 @@ package body Freeze is\n             elsif Is_Access_Type (Etype (Comp))\n               and then Present (Parent (Comp))\n               and then Present (Expression (Parent (Comp)))\n-              and then Nkind (Expression (Parent (Comp))) = N_Allocator\n+              and then Check_Allocator (Expression (Parent (Comp)))\n             then\n                declare\n-                  Alloc : constant Node_Id := Expression (Parent (Comp));\n+                  Alloc : Node_Id;\n \n                begin\n-                  --  If component is pointer to a classwide type, freeze\n-                  --  the specific type in the expression being allocated.\n-                  --  The expression may be a subtype indication, in which\n-                  --  case freeze the subtype mark.\n+                  --  Handle qualified expressions\n+\n+                  Alloc := Expression (Parent (Comp));\n+                  while Nkind (Alloc) /= N_Allocator loop\n+                     pragma Assert (Nkind (Alloc) = N_Qualified_Expression);\n+                     Alloc := Expression (Alloc);\n+                  end loop;\n+\n+                  --  If component is pointer to a classwide type, freeze the\n+                  --  specific type in the expression being allocated. The\n+                  --  expression may be a subtype indication, in which case\n+                  --  freeze the subtype mark.\n \n                   if Is_Class_Wide_Type (Designated_Type (Etype (Comp))) then\n                      if Is_Entity_Name (Expression (Alloc)) then\n@@ -2061,11 +2088,12 @@ package body Freeze is\n       --  The two-pass elaboration mechanism in gigi guarantees that E will\n       --  be frozen before the inner call is elaborated. We exclude constants\n       --  from this test, because deferred constants may be frozen early, and\n-      --  must be diagnosed (see e.g. 1522-005). If the enclosing subprogram\n-      --  comes from source, or is a generic instance, then the freeze point\n-      --  is the one mandated by the language. and we freze the entity.\n-      --  A subprogram that is a child unit body that acts as a spec does not\n-      --  have a spec that comes from source, but can only come from source.\n+      --  must be diagnosed (e.g. in the case of a deferred constant being used\n+      --  in a default expression). If the enclosing subprogram comes from\n+      --  source, or is a generic instance, then the freeze point is the one\n+      --  mandated by the language, and we freeze the entity. A subprogram that\n+      --  is a child unit body that acts as a spec does not have a spec that\n+      --  comes from source, but can only come from source.\n \n       elsif In_Open_Scopes (Scope (Test_E))\n         and then Scope (Test_E) /= Current_Scope\n@@ -2380,7 +2408,15 @@ package body Freeze is\n                Freeze_And_Append (Alias (E), Loc, Result);\n             end if;\n \n-            if not Is_Internal (E) then\n+            --  We don't freeze internal subprograms, because we don't normally\n+            --  want addition of extra formals or mechanism setting to happen\n+            --  for those. However we do pass through predefined dispatching\n+            --  cases, since extra formals may be needed in some cases, such as\n+            --  for the stream 'Input function (build-in-place formals).\n+\n+            if not Is_Internal (E)\n+              or else Is_Predefined_Dispatching_Operation (E)\n+            then\n                Freeze_Subprogram (E);\n             end if;\n "}, {"sha": "fbd34d4a8e5dae465f8301cbfdcdc137217b41f1", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 37, "deletions": 6, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19590d704b6d6eb487b63e112490e1d19946bae7/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19590d704b6d6eb487b63e112490e1d19946bae7/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=19590d704b6d6eb487b63e112490e1d19946bae7", "patch": "@@ -2946,16 +2946,34 @@ package body Sem_Ch6 is\n                     (\"not type conformant with declaration#!\", Enode);\n \n                when Mode_Conformant =>\n-                  Error_Msg_N\n-                    (\"not mode conformant with declaration#!\", Enode);\n+                  if Nkind (Parent (Old_Id)) = N_Full_Type_Declaration then\n+                     Error_Msg_N\n+                       (\"not mode conformant with operation inherited#!\",\n+                         Enode);\n+                  else\n+                     Error_Msg_N\n+                       (\"not mode conformant with declaration#!\", Enode);\n+                  end if;\n \n                when Subtype_Conformant =>\n-                  Error_Msg_N\n-                    (\"not subtype conformant with declaration#!\", Enode);\n+                  if Nkind (Parent (Old_Id)) = N_Full_Type_Declaration then\n+                     Error_Msg_N\n+                       (\"not subtype conformant with operation inherited#!\",\n+                         Enode);\n+                  else\n+                     Error_Msg_N\n+                       (\"not subtype conformant with declaration#!\", Enode);\n+                  end if;\n \n                when Fully_Conformant =>\n-                  Error_Msg_N\n-                    (\"not fully conformant with declaration#!\", Enode);\n+                  if Nkind (Parent (Old_Id)) = N_Full_Type_Declaration then\n+                     Error_Msg_N\n+                       (\"not fully conformant with operation inherited#!\",\n+                         Enode);\n+                  else\n+                     Error_Msg_N\n+                       (\"not fully conformant with declaration#!\", Enode);\n+                  end if;\n             end case;\n \n             Error_Msg_NE (Msg, Enode, N);\n@@ -4728,6 +4746,17 @@ package body Sem_Ch6 is\n          return;\n       end if;\n \n+      --  If the subprogram is a predefined dispatching subprogram then don't\n+      --  generate any extra constrained or accessibility level formals. In\n+      --  general we suppress these for internal subprograms (by not calling\n+      --  Freeze_Subprogram and Create_Extra_Formals at all), but internally\n+      --  generated stream attributes do get passed through because extra\n+      --  build-in-place formals are needed in some cases (limited 'Input).\n+\n+      if Is_Predefined_Dispatching_Operation (E) then\n+         goto Test_For_BIP_Extras;\n+      end if;\n+\n       Formal := First_Formal (E);\n       while Present (Formal) loop\n \n@@ -4818,6 +4847,8 @@ package body Sem_Ch6 is\n          Next_Formal (Formal);\n       end loop;\n \n+      <<Test_For_BIP_Extras>>\n+\n       --  Ada 2005 (AI-318-02): In the case of build-in-place functions, add\n       --  appropriate extra formals. See type Exp_Ch6.BIP_Formal_Kind.\n "}]}