{"sha": "5345f91a0be605ab09f2f42abecd1a0fc5083f47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM0NWY5MWEwYmU2MDVhYjA5ZjJmNDJhYmVjZDFhMGZjNTA4M2Y0Nw==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1994-06-03T19:50:48Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1994-06-03T19:50:48Z"}, "message": "(FP_REGNO_P): New macro for intra file usage.\n\n(REGNO_OK_FOR_FP_P): Use FP_REGNO_P.\n(FUNCTION_VALUE_REGNO_P): Revert last change.\n(CONDITIONAL_REGISTER_USAGE): Partially revert last changes;\nMake non-existing 1.0 fp regs fixed, including odd-numbered regs.\n(enum reg_class): Get rid of SNAKE_FP_REGS, GENERAL_OR_SNAKE_FP_REGS,\nand NON_SHIFT_REGS.\n(REG_CLASS_NAMES): Likewise.\n(REG_CLASS_CONTENTS): Likewise.\n(REGNO_REG_CLASS): Likewise.\n(HARD_REGNO_MODE_OK): Corresponding changes.  Don't force 1.0 fpregs\nto even regno here; fixed_regs does the job better.\n(FP_REG_CLASS_P): Get rid of SNAKE_FP_REGS.\n(REG_CLASS_FROM_LETTER, case 'z'): Deleted.\n(HARD_REGNO_NREGS): Partially revert last change.\n(CLASS_MAX_NREGS): Partially revert last change.\n\nFrom-SVN: r7438", "tree": {"sha": "c1ab9c4e3385c68a07953a207dc5ee0eed009ac7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1ab9c4e3385c68a07953a207dc5ee0eed009ac7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5345f91a0be605ab09f2f42abecd1a0fc5083f47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5345f91a0be605ab09f2f42abecd1a0fc5083f47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5345f91a0be605ab09f2f42abecd1a0fc5083f47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5345f91a0be605ab09f2f42abecd1a0fc5083f47/comments", "author": null, "committer": null, "parents": [{"sha": "0b27d5ddb2ce7353a168c60c9109b4ee01e481eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b27d5ddb2ce7353a168c60c9109b4ee01e481eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b27d5ddb2ce7353a168c60c9109b4ee01e481eb"}], "stats": {"total": 71, "additions": 37, "deletions": 34}, "files": [{"sha": "39d21bbe924fb9f6a737b3176a39144ae0a222d1", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 37, "deletions": 34, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5345f91a0be605ab09f2f42abecd1a0fc5083f47/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5345f91a0be605ab09f2f42abecd1a0fc5083f47/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=5345f91a0be605ab09f2f42abecd1a0fc5083f47", "patch": "@@ -360,6 +360,18 @@ extern int target_flags;\n \n #define CONDITIONAL_REGISTER_USAGE \\\n {\t\t\t\t\t\t\\\n+  if (!TARGET_SNAKE)\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      for (i = 56; i < 88; i++) \t\t\\\n+\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n+      for (i = 33; i < 88; i += 2) \t\t\\\n+\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n+    }\t\t\t\t\t\t\\\n+  else if (TARGET_DISABLE_FPREGS)\t\t\\\n+    {\t\t\t\t\t\t\\\n+      for (i = 32; i < 88; i++) \t\t\\\n+\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n+    }\t\t\t\t\t\t\\\n   if (flag_pic)\t\t\t\t\t\\\n     fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n }\n@@ -393,6 +405,9 @@ extern int target_flags;\n    1, 30,  0, 88}\n \n \n+/* True if register is floating-point.  */\n+#define FP_REGNO_P(N) ((N) >= 32 && (N) <= 87)\n+\n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n    This is ordinarily the length in words of a value of mode MODE\n@@ -401,21 +416,19 @@ extern int target_flags;\n    On the HP-PA, ordinary registers hold 32 bits worth;\n    The floating point registers are 64 bits wide. Snake fp regs are 32\n    bits wide */\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n+  (!TARGET_SNAKE && FP_REGNO_P (REGNO) ? 1\t\t\t\t\\\n+   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    On the HP-PA, the cpu registers can hold any mode.  We\n    force this to be an even register is it cannot hold the full mode.  */\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n   ((REGNO) == 0 ? (MODE) == CCmode || (MODE) == CCFPmode\t\t\\\n-   : !TARGET_SNAKE && (REGNO) >= 32\t\t\t\t\t\\\n-     /* On 1.0 machines, all fp registers are 64 bits. */\t\t\\\n-     ? (((REGNO) & 1) == 0\t\t\t\t\t\t\\\n-     /* On 1.0 machines, don't allow large non-fp values in fp regs. */\t\\\n-\t&& (GET_MODE_SIZE (MODE) <= 4\t\t\t\t\t\\\n-\t    || GET_MODE_CLASS (MODE) == MODE_FLOAT))\t\t\t\\\n-   /* Make large values be in aligned registers. */\t\t\t\\\n+   /* On 1.0 machines, don't allow wide non-fp modes in fp regs. */\t\\\n+   : !TARGET_SNAKE && FP_REGNO_P (REGNO)\t\t\t\t\\\n+     ? GET_MODE_SIZE (MODE) <= 4 || GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n+   /* Make wide modes be in aligned registers. */\t\t\t\\\n    : GET_MODE_SIZE (MODE) <= 4 || ((REGNO) & 1) == 0)\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n@@ -497,17 +510,15 @@ extern int target_flags;\n      fmpyadd and fmpysub are restricted.  */\n \n enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n-  SNAKE_FP_REGS, GENERAL_OR_SNAKE_FP_REGS,\n-  NON_SHIFT_REGS, SHIFT_REGS, ALL_REGS, LIM_REG_CLASSES};\n+  SHIFT_REGS, ALL_REGS, LIM_REG_CLASSES};\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n /* Give names of register classes as strings for dump file.   */\n \n #define REG_CLASS_NAMES \\\n   {\"NO_REGS\", \"R1_REGS\", \"GENERAL_REGS\", \"FP_REGS\",\t\t\t\\\n-   \"GENERAL_OR_FP_REGS\", \"SNAKE_FP_REGS\", \"GENERAL_OR_SNAKE_FP_REGS\",\t\\\n-   \"NON_SHIFT_REGS\", \"SHIFT_REGS\", \"ALL_REGS\"}\n+   \"GENERAL_OR_FP_REGS\", \"SHIFT_REGS\", \"ALL_REGS\"}\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n@@ -518,11 +529,8 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n  {{0x00000000, 0x00000000, 0x00000000},\t/* NO_REGS */\t\t\t\\\n   {0x00000002, 0x00000000, 0x00000000},\t/* R1_REGS */\t\t\t\\\n   {0xfffffffe, 0x00000000, 0x00000000},\t/* GENERAL_REGS */\t\t\\\n-  {0x00000000, 0x00ffffff, 0x00000000},\t/* FP_REGS */\t\t\t\\\n-  {0xfffffffe, 0x00ffffff, 0x00000000},\t/* GENERAL_OR_FP_REGS */\t\\\n-  {0x00000000, 0xffffffff, 0x00ffffff},\t/* SNAKE_FP_REGS */\t\t\\\n-  {0xfffffffe, 0xffffffff, 0x00ffffff},\t/* GENERAL_OR_SNAKE_FP_REGS */\t\\\n-  {0xfffffffe, 0xffffffff, 0x00ffffff},\t/* NON_SHIFT_REGS */\t\t\\\n+  {0x00000000, 0xffffffff, 0x00ffffff},\t/* FP_REGS */\t\t\t\\\n+  {0xfffffffe, 0xffffffff, 0x00ffffff},\t/* GENERAL_OR_FP_REGS */\t\\\n   {0x00000000, 0x00000000, 0x01000000},\t/* SHIFT_REGS */\t\t\\\n   {0xfffffffe, 0xffffffff, 0x01ffffff}}\t/* ALL_REGS */\n \n@@ -535,28 +543,23 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n   ((REGNO) == 0 ? NO_REGS \t\t\t\t\t\t\\\n    : (REGNO) == 1 ? R1_REGS\t\t\t\t\t\t\\\n    : (REGNO) < 32 ? GENERAL_REGS\t\t\t\t\t\\\n-   : (REGNO) < 44 && !TARGET_SNAKE ? FP_REGS\t\t\t\t\\\n-   : (REGNO) < 88 && TARGET_SNAKE ? SNAKE_FP_REGS\t\t\t\\\n+   : (REGNO) < 88 ? FP_REGS\t\t\t\t\t\t\\\n    : SHIFT_REGS)\n \n /* The class value for index registers, and the one for base regs.  */\n #define INDEX_REG_CLASS GENERAL_REGS\n #define BASE_REG_CLASS GENERAL_REGS\n \n #define FP_REG_CLASS_P(CLASS) \\\n-  (CLASS == FP_REGS || CLASS == SNAKE_FP_REGS)\n-\n-/* Get reg_class from a letter such as appears in the machine description.\n-   Note 'Z' is not the same as 'r' since SHIFT_REGS is not part of\n-   GENERAL_REGS.  */\n+  ((CLASS) == FP_REGS)\n \n-/* OOPS Merge f and x? */\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+/* Keep 'x' for backward compatibility with user asm.   */\n #define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'f' ? (!TARGET_SNAKE ? FP_REGS : NO_REGS) :\t\t\\\n-   (C) == 'x' ? (TARGET_SNAKE ? SNAKE_FP_REGS : NO_REGS) :\t\\\n+  ((C) == 'f' ? FP_REGS :\t\t\t\t\t\\\n+   (C) == 'x' ? FP_REGS :\t\t\t\t\t\\\n    (C) == 'q' ? SHIFT_REGS :\t\t\t\t\t\\\n    (C) == 'a' ? R1_REGS :\t\t\t\t\t\\\n-   (C) == 'z' ? SNAKE_FP_REGS :\t\t\t\t\t\\\n    (C) == 'Z' ? ALL_REGS : NO_REGS)\n \n /* The letters I, J, K, L and M in a register constraint string\n@@ -619,8 +622,9 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n+  (!TARGET_SNAKE && (CLASS) == FP_REGS ? 1 :\t\t\t\t\\\n+   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n@@ -719,7 +723,7 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n    as seen by the caller.  */\n \n #define FUNCTION_VALUE_REGNO_P(N) \\\n-  ((N) == 28 || (N) == 29 || (N) == 32 || (N) == 33)\n+  ((N) == 28 || (N) == 32)\n \n /* 1 if N is a possible register number for function argument passing.  */\n \n@@ -1124,8 +1128,7 @@ extern union tree_node *current_function_decl;\n #define REGNO_OK_FOR_BASE_P(REGNO)  \\\n   ((REGNO) && ((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32))\n #define REGNO_OK_FOR_FP_P(REGNO) \\\n-  (((REGNO) >= 32 && (REGNO) <= 87)\\\n-   || (reg_renumber[REGNO] >= 32 && reg_renumber[REGNO] <= 87))\n+  (FP_REGNO_P (REGNO) || FP_REGNO_P (reg_renumber[REGNO]))\n \n /* Now macros that check whether X is a register and also,\n    strictly, whether it is in a specified class."}]}