{"sha": "a6f778b21e8ed7c51e7b7fea73e2105c0996095c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZmNzc4YjIxZThlZDdjNTFlN2I3ZmVhNzNlMjEwNWMwOTk2MDk1Yw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-01-06T20:22:56Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-01-06T20:22:56Z"}, "message": "re PR tree-optimization/18527 (cannot determine number of iterations for loops with <=)\n\n\tPR tree-optimization/18527\n\t* tree-ssa-loop-niter.c (number_of_iterations_cond,\n\tnumber_of_iterations_special, number_of_iterations_exit):\n\tMove base and step of an iv to a single structure.  Add\n\tno_overflow flag, and use it in # of iterations analysis.\n\t* tree-scalar-evolution.c (analyze_scalar_evolution_in_loop): Add\n\tfolded_casts argument.\n\t(simple_iv): Pass base and step in a structure.  Set no_overflow\n\tflag.\n\t(scev_const_prop): Add argument to analyze_scalar_evolution_in_loop.\n\tEvaluate expensiveness of computing # of iterations instead of\n\tthe final expression.\n\t* tree-scalar-evolution.h (affine_iv): New structure.\n\t(simple_iv): Declaration changed.\n\t* tree-chrec.c (chrec_apply): Handle chrecs containing symbols.\n\t* tree-ssa-loop-ivopts.c (determine_biv_step, find_givs_in_stmt_scev,\n\tfind_givs_in_stmt): Changed due to simple_iv change.\n\n\t* gcc.dg/tree-ssa/loop-15.c: New test.\n\nFrom-SVN: r109427", "tree": {"sha": "2f80a9e9f7dc377dcb9bdd829e0f2a5a8d6c28d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f80a9e9f7dc377dcb9bdd829e0f2a5a8d6c28d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6f778b21e8ed7c51e7b7fea73e2105c0996095c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6f778b21e8ed7c51e7b7fea73e2105c0996095c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6f778b21e8ed7c51e7b7fea73e2105c0996095c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6f778b21e8ed7c51e7b7fea73e2105c0996095c/comments", "author": null, "committer": null, "parents": [{"sha": "782e98753b7ce46cc3fa79253d57b3365149fa54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/782e98753b7ce46cc3fa79253d57b3365149fa54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/782e98753b7ce46cc3fa79253d57b3365149fa54"}], "stats": {"total": 464, "additions": 279, "deletions": 185}, "files": [{"sha": "f7834cb640a38ec11c9340c191d0600d8346fc1c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f778b21e8ed7c51e7b7fea73e2105c0996095c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f778b21e8ed7c51e7b7fea73e2105c0996095c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6f778b21e8ed7c51e7b7fea73e2105c0996095c", "patch": "@@ -1,3 +1,23 @@\n+2005-01-06  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/18527\n+\t* tree-ssa-loop-niter.c (number_of_iterations_cond,\n+\tnumber_of_iterations_special, number_of_iterations_exit):\n+\tMove base and step of an iv to a single structure.  Add\n+\tno_overflow flag, and use it in # of iterations analysis.\n+\t* tree-scalar-evolution.c (analyze_scalar_evolution_in_loop): Add\n+\tfolded_casts argument.\n+\t(simple_iv): Pass base and step in a structure.  Set no_overflow\n+\tflag.\n+\t(scev_const_prop): Add argument to analyze_scalar_evolution_in_loop.\n+\tEvaluate expensiveness of computing # of iterations instead of\n+\tthe final expression.\n+\t* tree-scalar-evolution.h (affine_iv): New structure.\n+\t(simple_iv): Declaration changed.\n+\t* tree-chrec.c (chrec_apply): Handle chrecs containing symbols.\n+\t* tree-ssa-loop-ivopts.c (determine_biv_step, find_givs_in_stmt_scev,\n+\tfind_givs_in_stmt): Changed due to simple_iv change.\n+\n 2005-01-06  Jeff Law  <law@redhat.com>\n \n \tPR ada/24994"}, {"sha": "ca893730e66af26ef93559b93404d5ae889314d7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f778b21e8ed7c51e7b7fea73e2105c0996095c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f778b21e8ed7c51e7b7fea73e2105c0996095c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a6f778b21e8ed7c51e7b7fea73e2105c0996095c", "patch": "@@ -1,3 +1,7 @@\n+2005-01-06  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/loop-15.c: New test.\n+\n 2005-01-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/25598"}, {"sha": "44cd10103fa642c41a6e4c261ac9ec28028c0a29", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-15.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f778b21e8ed7c51e7b7fea73e2105c0996095c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f778b21e8ed7c51e7b7fea73e2105c0996095c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-15.c?ref=a6f778b21e8ed7c51e7b7fea73e2105c0996095c", "patch": "@@ -0,0 +1,27 @@\n+/* A test for # of iterations analysis (signed counter cannot wrap) and final\n+   value replacement.  */\n+\n+/* { dg-options \"-O2 -fdump-tree-vars\" } */\n+\n+int foo(void);\n+\n+int bla(void)\n+{\n+  int i, n = foo (), j;\n+\n+  j = 0;\n+  /* The loop should be removed completely.  */\n+  for (i = 1; i <= n; i++)\n+    j += n;\n+\n+  /* Should be replaced with return n * n;  */\n+  return j;\n+}\n+\n+/* Since the loop is removed, there should be no addition.  */\n+/* { dg-final { scan-tree-dump-times \"\\\\+\" 0 \"vars\" } } */\n+/* { dg-final { scan-tree-dump-times \"n \\\\* n\" 1 \"vars\" } } */\n+\n+/* The if from the loop header copying remains in the code.  */\n+/* { dg-final { scan-tree-dump-times \"if \" 1 \"vars\" } } */\n+/* { dg-final { cleanup-tree-dump \"vars\" } } */"}, {"sha": "30915d280ec148ef68f960406cd51a58a96de627", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f778b21e8ed7c51e7b7fea73e2105c0996095c/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f778b21e8ed7c51e7b7fea73e2105c0996095c/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=a6f778b21e8ed7c51e7b7fea73e2105c0996095c", "patch": "@@ -533,10 +533,9 @@ chrec_apply (unsigned var,\n       /* When the symbols are defined in an outer loop, it is possible\n \t to symbolically compute the apply, since the symbols are\n \t constants with respect to the varying loop.  */\n-      || chrec_contains_symbols_defined_in_loop (chrec, var)\n-      || chrec_contains_symbols (x))\n+      || chrec_contains_symbols_defined_in_loop (chrec, var))\n     return chrec_dont_know;\n-  \n+ \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"(chrec_apply \\n\");\n \n@@ -546,14 +545,10 @@ chrec_apply (unsigned var,\n   if (evolution_function_is_affine_p (chrec))\n     {\n       /* \"{a, +, b} (x)\"  ->  \"a + b*x\".  */\n-      if (TREE_CODE (CHREC_LEFT (chrec)) == INTEGER_CST\n-\t  && integer_zerop (CHREC_LEFT (chrec)))\n-\tres = chrec_fold_multiply (type, CHREC_RIGHT (chrec), x);\n-      \n-      else\n-\tres = chrec_fold_plus (type, CHREC_LEFT (chrec), \n-\t\t\t       chrec_fold_multiply (type, \n-\t\t\t\t\t\t    CHREC_RIGHT (chrec), x));\n+      x = chrec_convert (type, x, NULL_TREE);\n+      res = chrec_fold_multiply (type, CHREC_RIGHT (chrec), x);\n+      if (!integer_zerop (CHREC_LEFT (chrec)))\n+\tres = chrec_fold_plus (type, CHREC_LEFT (chrec), res);\n     }\n   \n   else if (TREE_CODE (chrec) != POLYNOMIAL_CHREC)\n@@ -563,7 +558,6 @@ chrec_apply (unsigned var,\n \t   && tree_int_cst_sgn (x) == 1)\n     /* testsuite/.../ssa-chrec-38.c.  */\n     res = chrec_evaluate (var, chrec, x, 0);\n-\n   else\n     res = chrec_dont_know;\n   "}, {"sha": "3075839f3e75955409e78fbd6665fcb0ba6e00df", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 47, "deletions": 29, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f778b21e8ed7c51e7b7fea73e2105c0996095c/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f778b21e8ed7c51e7b7fea73e2105c0996095c/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=a6f778b21e8ed7c51e7b7fea73e2105c0996095c", "patch": "@@ -1831,19 +1831,28 @@ analyze_scalar_evolution (struct loop *loop, tree var)\n \n /* Analyze scalar evolution of use of VERSION in USE_LOOP with respect to\n    WRTO_LOOP (which should be a superloop of both USE_LOOP and definition\n-   of VERSION).  */\n+   of VERSION).\n+\n+   FOLDED_CASTS is set to true if resolve_mixers used\n+   chrec_convert_aggressive (TODO -- not really, we are way too conservative\n+   at the moment in order to keep things simple).  */\n \n static tree\n analyze_scalar_evolution_in_loop (struct loop *wrto_loop, struct loop *use_loop,\n-\t\t\t\t  tree version)\n+\t\t\t\t  tree version, bool *folded_casts)\n {\n   bool val = false;\n-  tree ev = version;\n+  tree ev = version, tmp;\n \n+  if (folded_casts)\n+    *folded_casts = false;\n   while (1)\n     {\n-      ev = analyze_scalar_evolution (use_loop, ev);\n-      ev = resolve_mixers (use_loop, ev);\n+      tmp = analyze_scalar_evolution (use_loop, ev);\n+      ev = resolve_mixers (use_loop, tmp);\n+\n+      if (folded_casts && tmp != ev)\n+\t*folded_casts = true;\n \n       if (use_loop == wrto_loop)\n \treturn ev;\n@@ -2561,55 +2570,63 @@ scev_reset (void)\n }\n \n /* Checks whether OP behaves as a simple affine iv of LOOP in STMT and returns\n-   its BASE and STEP if possible.  If ALLOW_NONCONSTANT_STEP is true, we\n-   want STEP to be invariant in LOOP.  Otherwise we require it to be an\n-   integer constant.  */\n+   its base and step in IV if possible.  If ALLOW_NONCONSTANT_STEP is true, we\n+   want step to be invariant in LOOP.  Otherwise we require it to be an\n+   integer constant.  IV->no_overflow is set to true if we are sure the iv cannot\n+   overflow (e.g.  because it is computed in signed arithmetics).  */\n \n bool\n-simple_iv (struct loop *loop, tree stmt, tree op, tree *base, tree *step,\n+simple_iv (struct loop *loop, tree stmt, tree op, affine_iv *iv,\n \t   bool allow_nonconstant_step)\n {\n   basic_block bb = bb_for_stmt (stmt);\n   tree type, ev;\n+  bool folded_casts;\n \n-  *base = NULL_TREE;\n-  *step = NULL_TREE;\n+  iv->base = NULL_TREE;\n+  iv->step = NULL_TREE;\n+  iv->no_overflow = false;\n \n   type = TREE_TYPE (op);\n   if (TREE_CODE (type) != INTEGER_TYPE\n       && TREE_CODE (type) != POINTER_TYPE)\n     return false;\n \n-  ev = analyze_scalar_evolution_in_loop (loop, bb->loop_father, op);\n+  ev = analyze_scalar_evolution_in_loop (loop, bb->loop_father, op,\n+\t\t\t\t\t &folded_casts);\n   if (chrec_contains_undetermined (ev))\n     return false;\n \n   if (tree_does_not_contain_chrecs (ev)\n       && !chrec_contains_symbols_defined_in_loop (ev, loop->num))\n     {\n-      *base = ev;\n+      iv->base = ev;\n+      iv->no_overflow = true;\n       return true;\n     }\n \n   if (TREE_CODE (ev) != POLYNOMIAL_CHREC\n       || CHREC_VARIABLE (ev) != (unsigned) loop->num)\n     return false;\n \n-  *step = CHREC_RIGHT (ev);\n+  iv->step = CHREC_RIGHT (ev);\n   if (allow_nonconstant_step)\n     {\n-      if (tree_contains_chrecs (*step, NULL)\n-\t  || chrec_contains_symbols_defined_in_loop (*step, loop->num))\n+      if (tree_contains_chrecs (iv->step, NULL)\n+\t  || chrec_contains_symbols_defined_in_loop (iv->step, loop->num))\n \treturn false;\n     }\n-  else if (TREE_CODE (*step) != INTEGER_CST)\n+  else if (TREE_CODE (iv->step) != INTEGER_CST)\n     return false;\n \n-  *base = CHREC_LEFT (ev);\n-  if (tree_contains_chrecs (*base, NULL)\n-      || chrec_contains_symbols_defined_in_loop (*base, loop->num))\n+  iv->base = CHREC_LEFT (ev);\n+  if (tree_contains_chrecs (iv->base, NULL)\n+      || chrec_contains_symbols_defined_in_loop (iv->base, loop->num))\n     return false;\n \n+  iv->no_overflow = (!folded_casts\n+\t\t     && !flag_wrapv\n+\t\t     && !TYPE_UNSIGNED (type));\n   return true;\n }\n \n@@ -2722,7 +2739,7 @@ scev_const_prop (void)\n   for (i = current_loops->num - 1; i > 0; i--)\n     {\n       edge exit;\n-      tree def, rslt, ass;\n+      tree def, rslt, ass, niter;\n       block_stmt_iterator bsi;\n \n       loop = current_loops->parray[i];\n@@ -2732,8 +2749,14 @@ scev_const_prop (void)\n       /* If we do not know exact number of iterations of the loop, we cannot\n \t replace the final value.  */\n       exit = loop->single_exit;\n-      if (!exit\n-\t  || number_of_iterations_in_loop (loop) == chrec_dont_know)\n+      if (!exit)\n+\tcontinue;\n+\n+      niter = number_of_iterations_in_loop (loop);\n+      if (niter == chrec_dont_know\n+\t  /* If computing the number of iterations is expensive, it may be\n+\t     better not to introduce computations involving it.  */\n+\t  || expression_expensive_p (niter))\n \tcontinue;\n \n       /* Ensure that it is possible to insert new statements somewhere.  */\n@@ -2756,17 +2779,12 @@ scev_const_prop (void)\n \t      && !INTEGRAL_TYPE_P (TREE_TYPE (def)))\n \t    continue;\n \n-\t  def = analyze_scalar_evolution_in_loop (ex_loop, loop, def);\n+\t  def = analyze_scalar_evolution_in_loop (ex_loop, loop, def, NULL);\n \t  def = compute_overall_effect_of_inner_loop (ex_loop, def);\n \t  if (!tree_does_not_contain_chrecs (def)\n \t      || chrec_contains_symbols_defined_in_loop (def, ex_loop->num))\n \t    continue;\n \n-\t  /* If computing the expression is expensive, let it remain in the\n-\t     loop.  */\n-\t  if (expression_expensive_p (def))\n-\t    continue;\n-\n \t  /* Eliminate the phi node and replace it by a computation outside\n \t     the loop.  */\n \t  def = unshare_expr (def);"}, {"sha": "0fecaee2390ec1fb2fe3d4754ce3f6ad5b207559", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f778b21e8ed7c51e7b7fea73e2105c0996095c/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f778b21e8ed7c51e7b7fea73e2105c0996095c/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=a6f778b21e8ed7c51e7b7fea73e2105c0996095c", "patch": "@@ -32,7 +32,19 @@ extern tree analyze_scalar_evolution (struct loop *, tree);\n extern tree instantiate_parameters (struct loop *, tree);\n extern void gather_stats_on_scev_database (void);\n extern void scev_analysis (void);\n-extern bool simple_iv (struct loop *, tree, tree, tree *, tree *, bool);\n void scev_const_prop (void);\n \n+/* Affine iv.  */\n+\n+typedef struct\n+{\n+  /* Iv = BASE + STEP * i.  */\n+  tree base, step;\n+\n+  /* True if this iv does not overflow.  */\n+  bool no_overflow;\n+} affine_iv;\n+\n+extern bool simple_iv (struct loop *, tree, tree, affine_iv *, bool);\n+\n #endif  /* GCC_TREE_SCALAR_EVOLUTION_H  */"}, {"sha": "8e1c53ad174a2f16a2aaa2fd534aab352d7b7b50", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f778b21e8ed7c51e7b7fea73e2105c0996095c/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f778b21e8ed7c51e7b7fea73e2105c0996095c/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=a6f778b21e8ed7c51e7b7fea73e2105c0996095c", "patch": "@@ -881,18 +881,16 @@ static tree\n determine_biv_step (tree phi)\n {\n   struct loop *loop = bb_for_stmt (phi)->loop_father;\n-  tree name = PHI_RESULT (phi), base, step;\n+  tree name = PHI_RESULT (phi);\n+  affine_iv iv;\n \n   if (!is_gimple_reg (name))\n     return NULL_TREE;\n \n-  if (!simple_iv (loop, phi, name, &base, &step, true))\n+  if (!simple_iv (loop, phi, name, &iv, true))\n     return NULL_TREE;\n \n-  if (zero_p (step))\n-    return NULL_TREE;\n-\n-  return step;\n+  return (zero_p (iv.step) ? NULL_TREE : iv.step);\n }\n \n /* Returns true if EXP is a ssa name that occurs in an abnormal phi node.  */\n@@ -1044,17 +1042,16 @@ mark_bivs (struct ivopts_data *data)\n }\n \n /* Checks whether STMT defines a linear induction variable and stores its\n-   parameters to BASE and STEP.  */\n+   parameters to IV.  */\n \n static bool\n-find_givs_in_stmt_scev (struct ivopts_data *data, tree stmt,\n-\t\t\ttree *base, tree *step)\n+find_givs_in_stmt_scev (struct ivopts_data *data, tree stmt, affine_iv *iv)\n {\n   tree lhs;\n   struct loop *loop = data->current_loop;\n \n-  *base = NULL_TREE;\n-  *step = NULL_TREE;\n+  iv->base = NULL_TREE;\n+  iv->step = NULL_TREE;\n \n   if (TREE_CODE (stmt) != MODIFY_EXPR)\n     return false;\n@@ -1063,12 +1060,12 @@ find_givs_in_stmt_scev (struct ivopts_data *data, tree stmt,\n   if (TREE_CODE (lhs) != SSA_NAME)\n     return false;\n \n-  if (!simple_iv (loop, stmt, TREE_OPERAND (stmt, 1), base, step, true))\n+  if (!simple_iv (loop, stmt, TREE_OPERAND (stmt, 1), iv, true))\n     return false;\n-  *base = expand_simple_operations (*base);\n+  iv->base = expand_simple_operations (iv->base);\n \n-  if (contains_abnormal_ssa_name_p (*base)\n-      || contains_abnormal_ssa_name_p (*step))\n+  if (contains_abnormal_ssa_name_p (iv->base)\n+      || contains_abnormal_ssa_name_p (iv->step))\n     return false;\n \n   return true;\n@@ -1079,12 +1076,12 @@ find_givs_in_stmt_scev (struct ivopts_data *data, tree stmt,\n static void\n find_givs_in_stmt (struct ivopts_data *data, tree stmt)\n {\n-  tree base, step;\n+  affine_iv iv;\n \n-  if (!find_givs_in_stmt_scev (data, stmt, &base, &step))\n+  if (!find_givs_in_stmt_scev (data, stmt, &iv))\n     return;\n \n-  set_iv (data, TREE_OPERAND (stmt, 0), base, step);\n+  set_iv (data, TREE_OPERAND (stmt, 0), iv.base, iv.step);\n }\n \n /* Finds general ivs in basic block BB.  */"}, {"sha": "bd3667b302eb41cb6e023677cb30db59df2bd77a", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 147, "deletions": 125, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f778b21e8ed7c51e7b7fea73e2105c0996095c/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f778b21e8ed7c51e7b7fea73e2105c0996095c/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=a6f778b21e8ed7c51e7b7fea73e2105c0996095c", "patch": "@@ -129,24 +129,22 @@ inverse (tree x, tree mask)\n /* Determine the number of iterations according to condition (for staying\n    inside loop) which compares two induction variables using comparison\n    operator CODE.  The induction variable on left side of the comparison\n-   has base BASE0 and step STEP0. the right-hand side one has base\n-   BASE1 and step STEP1.  Both induction variables must have type TYPE,\n-   which must be an integer or pointer type.  STEP0 and STEP1 must be\n-   constants (or NULL_TREE, which is interpreted as constant zero).\n+   is IV0, the right-hand side is IV1.  Both induction variables must have\n+   type TYPE, which must be an integer or pointer type.  The steps of the\n+   ivs must be constants (or NULL_TREE, which is interpreted as constant zero).\n    \n    The results (number of iterations and assumptions as described in\n    comments at struct tree_niter_desc in tree-flow.h) are stored to NITER.\n    In case we are unable to determine number of iterations, contents of\n    this structure is unchanged.  */\n \n static void\n-number_of_iterations_cond (tree type, tree base0, tree step0,\n-\t\t\t   enum tree_code code, tree base1, tree step1,\n-\t\t\t   struct tree_niter_desc *niter)\n+number_of_iterations_cond (tree type, affine_iv *iv0, enum tree_code code,\n+\t\t\t   affine_iv *iv1, struct tree_niter_desc *niter)\n {\n   tree step, delta, mmin, mmax;\n   tree may_xform, bound, s, d, tmp;\n-  bool was_sharp = false;\n+  bool was_sharp = false, never_infinite;\n   tree assumption;\n   tree assumptions = boolean_true_node;\n   tree noloop_assumptions = boolean_false_node;\n@@ -165,36 +163,47 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n   if (code == GE_EXPR\n       || code == GT_EXPR)\n     {\n-      SWAP (base0, base1);\n-      SWAP (step0, step1);\n+      SWAP (iv0, iv1);\n       code = swap_tree_comparison (code);\n     }\n \n+  /* If the control induction variable does not overflow, the loop obviously\n+     cannot be infinite.  */\n+  if (!zero_p (iv0->step) && iv0->no_overflow)\n+    never_infinite = true;\n+  else if (!zero_p (iv1->step) && iv1->no_overflow)\n+    never_infinite = true;\n+  else\n+    never_infinite = false;\n+\n   /* We can handle the case when neither of the sides of the comparison is\n      invariant, provided that the test is NE_EXPR.  This rarely occurs in\n      practice, but it is simple enough to manage.  */\n-  if (!zero_p (step0) && !zero_p (step1))\n+  if (!zero_p (iv0->step) && !zero_p (iv1->step))\n     {\n       if (code != NE_EXPR)\n \treturn;\n \n-      step0 = fold_binary_to_constant (MINUS_EXPR, type, step0, step1);\n-      step1 = NULL_TREE;\n+      iv0->step = fold_binary_to_constant (MINUS_EXPR, type,\n+\t\t\t\t\t   iv0->step, iv1->step);\n+      iv0->no_overflow = false;\n+      iv1->step = NULL_TREE;\n+      iv1->no_overflow = true;\n     }\n \n   /* If the result is a constant,  the loop is weird.  More precise handling\n      would be possible, but the situation is not common enough to waste time\n      on it.  */\n-  if (zero_p (step0) && zero_p (step1))\n+  if (zero_p (iv0->step) && zero_p (iv1->step))\n     return;\n \n   /* Ignore loops of while (i-- < 10) type.  */\n   if (code != NE_EXPR)\n     {\n-      if (step0 && tree_int_cst_sign_bit (step0))\n+      if (iv0->step && tree_int_cst_sign_bit (iv0->step))\n \treturn;\n \n-      if (!zero_p (step1) && !tree_int_cst_sign_bit (step1))\n+      if (!zero_p (iv1->step) && !tree_int_cst_sign_bit (iv1->step))\n \treturn;\n     }\n \n@@ -220,27 +229,29 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t care of <, as NE is more similar to it, but the problem is that here\n \t the transformation would be more difficult due to possibly infinite\n \t loops.  */\n-      if (zero_p (step0))\n+      if (zero_p (iv0->step))\n \t{\n \t  if (mmax)\n-\t    assumption = fold_build2 (EQ_EXPR, boolean_type_node, base0, mmax);\n+\t    assumption = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\t      iv0->base, mmax);\n \t  else\n \t    assumption = boolean_false_node;\n \t  if (nonzero_p (assumption))\n \t    goto zero_iter;\n-\t  base0 = fold_build2 (PLUS_EXPR, type, base0,\n-\t\t\t       build_int_cst_type (type, 1));\n+\t  iv0->base = fold_build2 (PLUS_EXPR, type, iv0->base,\n+\t\t\t\t   build_int_cst_type (type, 1));\n \t}\n       else\n \t{\n \t  if (mmin)\n-\t    assumption = fold_build2 (EQ_EXPR, boolean_type_node, base1, mmin);\n+\t    assumption = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\t      iv1->base, mmin);\n \t  else\n \t    assumption = boolean_false_node;\n \t  if (nonzero_p (assumption))\n \t    goto zero_iter;\n-\t  base1 = fold_build2 (MINUS_EXPR, type, base1,\n-\t\t\t       build_int_cst_type (type, 1));\n+\t  iv1->base = fold_build2 (MINUS_EXPR, type, iv1->base,\n+\t\t\t\t   build_int_cst_type (type, 1));\n \t}\n       noloop_assumptions = assumption;\n       code = LE_EXPR;\n@@ -253,13 +264,13 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n   /* Take care of trivially infinite loops.  */\n   if (code != NE_EXPR)\n     {\n-      if (zero_p (step0)\n+      if (zero_p (iv0->step)\n \t  && mmin\n-\t  && operand_equal_p (base0, mmin, 0))\n+\t  && operand_equal_p (iv0->base, mmin, 0))\n \treturn;\n-      if (zero_p (step1)\n+      if (zero_p (iv1->step)\n \t  && mmax\n-\t  && operand_equal_p (base1, mmax, 0))\n+\t  && operand_equal_p (iv1->base, mmax, 0))\n \treturn;\n     }\n \n@@ -271,11 +282,11 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n      there is not an overflow.  */\n   if (code != NE_EXPR)\n     {\n-      if (zero_p (step0))\n-\tstep = fold_unary_to_constant (NEGATE_EXPR, type, step1);\n+      if (zero_p (iv0->step))\n+\tstep = fold_unary_to_constant (NEGATE_EXPR, type, iv1->step);\n       else\n-\tstep = step0;\n-      delta = fold_build2 (MINUS_EXPR, type, base1, base0);\n+\tstep = iv0->step;\n+      delta = fold_build2 (MINUS_EXPR, type, iv1->base, iv0->base);\n       delta = fold_build2 (FLOOR_MOD_EXPR, type, delta, step);\n       may_xform = boolean_false_node;\n \n@@ -297,9 +308,9 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t\t worth the troubles.  */\n \t      may_xform = boolean_true_node;\n \t    }\n-\t  else if (zero_p (step0))\n+\t  else if (zero_p (iv0->step))\n \t    {\n-\t      if (!mmin)\n+\t      if (!mmin || iv1->no_overflow)\n \t\tmay_xform = boolean_true_node;\n \t      else\n \t\t{\n@@ -308,12 +319,12 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t\t  bound = fold_binary_to_constant (MINUS_EXPR, type,\n \t\t\t\t\t\t   bound, delta);\n \t\t  may_xform = fold_build2 (LE_EXPR, boolean_type_node,\n-\t\t\t\t\t   bound, base0);\n+\t\t\t\t\t   bound, iv0->base);\n \t\t}\n \t    }\n \t  else\n \t    {\n-\t      if (!mmax)\n+\t      if (!mmax || iv0->no_overflow)\n \t\tmay_xform = boolean_true_node;\n \t      else\n \t\t{\n@@ -322,7 +333,7 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t\t  bound = fold_binary_to_constant (PLUS_EXPR, type,\n \t\t\t\t\t\t   bound, delta);\n \t\t  may_xform = fold_build2 (LE_EXPR, boolean_type_node,\n-\t\t\t\t\t   base1, bound);\n+\t\t\t\t\t   iv1->base, bound);\n \t\t}\n \t    }\n \t}\n@@ -335,18 +346,19 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t  if (!nonzero_p (may_xform))\n \t    assumptions = may_xform;\n \n-\t  if (zero_p (step0))\n+\t  if (zero_p (iv0->step))\n \t    {\n-\t      base0 = fold_build2 (PLUS_EXPR, type, base0, delta);\n-\t      base0 = fold_build2 (MINUS_EXPR, type, base0, step);\n+\t      iv0->base = fold_build2 (PLUS_EXPR, type, iv0->base, delta);\n+\t      iv0->base = fold_build2 (MINUS_EXPR, type, iv0->base, step);\n \t    }\n \t  else\n \t    {\n-\t      base1 = fold_build2 (MINUS_EXPR, type, base1, delta);\n-\t      base1 = fold_build2 (PLUS_EXPR, type, base1, step);\n+\t      iv1->base = fold_build2 (MINUS_EXPR, type, iv1->base, delta);\n+\t      iv1->base = fold_build2 (PLUS_EXPR, type, iv1->base, step);\n \t    }\n \n-\t  assumption = fold_build2 (GT_EXPR, boolean_type_node, base0, base1);\n+\t  assumption = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t\t\t    iv0->base, iv1->base);\n \t  noloop_assumptions = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n \t\t\t\t\t    noloop_assumptions, assumption);\n \t  code = NE_EXPR;\n@@ -363,87 +375,95 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t makes us able to do more involved computations of number of iterations\n \t than in other cases.  First transform the condition into shape\n \t s * i <> c, with s positive.  */\n-      base1 = fold_build2 (MINUS_EXPR, type, base1, base0);\n-      base0 = NULL_TREE;\n-      if (!zero_p (step1))\n-  \tstep0 = fold_unary_to_constant (NEGATE_EXPR, type, step1);\n-      step1 = NULL_TREE;\n-      if (tree_int_cst_sign_bit (fold_convert (signed_niter_type, step0)))\n+      iv1->base = fold_build2 (MINUS_EXPR, type, iv1->base, iv0->base);\n+      iv0->base = NULL_TREE;\n+      if (!zero_p (iv1->step))\n+  \tiv0->step = fold_unary_to_constant (NEGATE_EXPR, type, iv1->step);\n+      iv1->step = NULL_TREE;\n+      if (tree_int_cst_sign_bit (fold_convert (signed_niter_type, iv0->step)))\n \t{\n-\t  step0 = fold_unary_to_constant (NEGATE_EXPR, type, step0);\n-\t  base1 = fold_build1 (NEGATE_EXPR, type, base1);\n+\t  iv0->step = fold_unary_to_constant (NEGATE_EXPR, type, iv0->step);\n+\t  iv1->base = fold_build1 (NEGATE_EXPR, type, iv1->base);\n \t}\n \n-      base1 = fold_convert (niter_type, base1);\n-      step0 = fold_convert (niter_type, step0);\n+      iv1->base = fold_convert (niter_type, iv1->base);\n+      iv0->step = fold_convert (niter_type, iv0->step);\n \n       /* Let nsd (step, size of mode) = d.  If d does not divide c, the loop\n \t is infinite.  Otherwise, the number of iterations is\n \t (inverse(s/d) * (c/d)) mod (size of mode/d).  */\n-      bits = num_ending_zeros (step0);\n+      bits = num_ending_zeros (iv0->step);\n       d = fold_binary_to_constant (LSHIFT_EXPR, niter_type,\n \t\t\t\t   build_int_cst_type (niter_type, 1), bits);\n-      s = fold_binary_to_constant (RSHIFT_EXPR, niter_type, step0, bits);\n+      s = fold_binary_to_constant (RSHIFT_EXPR, niter_type, iv0->step, bits);\n \n       bound = build_low_bits_mask (niter_type,\n \t\t\t\t   (TYPE_PRECISION (niter_type)\n \t\t\t\t    - tree_low_cst (bits, 1)));\n \n-      assumption = fold_build2 (FLOOR_MOD_EXPR, niter_type, base1, d);\n-      assumption = fold_build2 (EQ_EXPR, boolean_type_node,\n-\t\t\t\tassumption,\n-\t\t\t\tbuild_int_cst (niter_type, 0));\n-      assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t assumptions, assumption);\n+      if (!never_infinite)\n+\t{\n+\t  /* If we cannot assume that the loop is not infinite, record the\n+\t     assumptions for divisibility of c.  */\n+\t  assumption = fold_build2 (FLOOR_MOD_EXPR, niter_type, iv1->base, d);\n+\t  assumption = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\t    assumption,\n+\t\t\t\t    build_int_cst (niter_type, 0));\n+\t  assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t     assumptions, assumption);\n+\t}\n \n-      tmp = fold_build2 (EXACT_DIV_EXPR, niter_type, base1, d);\n+      tmp = fold_build2 (EXACT_DIV_EXPR, niter_type, iv1->base, d);\n       tmp = fold_build2 (MULT_EXPR, niter_type, tmp, inverse (s, bound));\n       niter->niter = fold_build2 (BIT_AND_EXPR, niter_type, tmp, bound);\n     }\n   else\n     {\n-      if (zero_p (step1))\n+      if (zero_p (iv1->step))\n \t/* Condition in shape a + s * i <= b\n \t   We must know that b + s does not overflow and a <= b + s and then we\n \t   can compute number of iterations as (b + s - a) / s.  (It might\n \t   seem that we in fact could be more clever about testing the b + s\n \t   overflow condition using some information about b - a mod s,\n \t   but it was already taken into account during LE -> NE transform).  */\n \t{\n-\t  if (mmax)\n+\t  if (mmax && !iv0->no_overflow)\n \t    {\n-\t      bound = fold_binary_to_constant (MINUS_EXPR, type, mmax, step0);\n+\t      bound = fold_binary_to_constant (MINUS_EXPR, type,\n+\t\t\t\t\t       mmax, iv0->step);\n \t      assumption = fold_build2 (LE_EXPR, boolean_type_node,\n-\t\t\t\t\tbase1, bound);\n+\t\t\t\t\tiv1->base, bound);\n \t      assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t\t assumptions, assumption);\n \t    }\n \n-\t  step = step0;\n-\t  tmp = fold_build2 (PLUS_EXPR, type, base1, step0);\n-\t  assumption = fold_build2 (GT_EXPR, boolean_type_node, base0, tmp);\n-\t  delta = fold_build2 (PLUS_EXPR, type, base1, step);\n-\t  delta = fold_build2 (MINUS_EXPR, type, delta, base0);\n+\t  step = iv0->step;\n+\t  tmp = fold_build2 (PLUS_EXPR, type, iv1->base, iv0->step);\n+\t  assumption = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t\t\t    iv0->base, tmp);\n+\t  delta = fold_build2 (PLUS_EXPR, type, iv1->base, step);\n+\t  delta = fold_build2 (MINUS_EXPR, type, delta, iv0->base);\n \t  delta = fold_convert (niter_type, delta);\n \t}\n       else\n \t{\n \t  /* Condition in shape a <= b - s * i\n \t     We must know that a - s does not overflow and a - s <= b and then\n \t     we can again compute number of iterations as (b - (a - s)) / s.  */\n-\t  if (mmin)\n+\t  if (mmin && !iv1->no_overflow)\n \t    {\n-\t      bound = fold_binary_to_constant (MINUS_EXPR, type, mmin, step1);\n+\t      bound = fold_binary_to_constant (MINUS_EXPR, type,\n+\t\t\t\t\t       mmin, iv1->step);\n \t      assumption = fold_build2 (LE_EXPR, boolean_type_node,\n-\t\t\t\t\tbound, base0);\n+\t\t\t\t\tbound, iv0->base);\n \t      assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t\t assumptions, assumption);\n \t    }\n-\t  step = fold_build1 (NEGATE_EXPR, type, step1);\n-\t  tmp = fold_build2 (PLUS_EXPR, type, base0, step1);\n-\t  assumption = fold_build2 (GT_EXPR, boolean_type_node, tmp, base1);\n-\t  delta = fold_build2 (MINUS_EXPR, type, base0, step);\n-\t  delta = fold_build2 (MINUS_EXPR, type, base1, delta);\n+\t  step = fold_build1 (NEGATE_EXPR, type, iv1->step);\n+\t  tmp = fold_build2 (PLUS_EXPR, type, iv0->base, iv1->step);\n+\t  assumption = fold_build2 (GT_EXPR, boolean_type_node, tmp, iv1->base);\n+\t  delta = fold_build2 (MINUS_EXPR, type, iv0->base, step);\n+\t  delta = fold_build2 (MINUS_EXPR, type, iv1->base, delta);\n \t  delta = fold_convert (niter_type, delta);\n \t}\n       noloop_assumptions = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n@@ -471,70 +491,69 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n    returns true if the special case was recognized, false otherwise.  */\n \n static bool\n-number_of_iterations_special (tree type, tree base0, tree step0,\n-\t\t\t      enum tree_code code, tree base1, tree step1,\n-\t\t\t      struct tree_niter_desc *niter)\n+number_of_iterations_special (tree type, affine_iv *iv0, enum tree_code code,\n+\t\t\t      affine_iv *iv1, struct tree_niter_desc *niter)\n {\n   tree niter_type = unsigned_type_for (type), mmax, mmin;\n \n   /* Make < comparison from > ones.  */\n   if (code == GE_EXPR\n       || code == GT_EXPR)\n     {\n-      SWAP (base0, base1);\n-      SWAP (step0, step1);\n+      SWAP (iv0, iv1);\n       code = swap_tree_comparison (code);\n     }\n \n   switch (code)\n     {\n     case NE_EXPR:\n-      if (zero_p (step0))\n+      if (zero_p (iv0->step))\n \t{\n-\t  if (zero_p (step1))\n+\t  if (zero_p (iv1->step))\n \t    return false;\n-    \t  SWAP (base0, base1);\n-\t  SWAP (step0, step1);\n+    \t  SWAP (iv0, iv1);\n \t}\n-      else if (!zero_p (step1))\n+      else if (!zero_p (iv1->step))\n \treturn false;\n \n-      if (integer_onep (step0))\n+      if (integer_onep (iv0->step))\n \t{\n-\t  /* for (i = base0; i != base1; i++)  */\n+\t  /* for (i = iv0->base; i != iv1->base; i++)  */\n \t  niter->assumptions = boolean_true_node;\n \t  niter->may_be_zero = boolean_false_node;\n-\t  niter->niter = fold_build2 (MINUS_EXPR, type, base1, base0);\n+\t  niter->niter = fold_build2 (MINUS_EXPR, type, iv1->base, iv0->base);\n \t  niter->additional_info = boolean_true_node;\n \t}\n-      else if (integer_all_onesp (step0))\n+      else if (integer_all_onesp (iv0->step))\n \t{\n-\t  /* for (i = base0; i != base1; i--)  */\n+\t  /* for (i = iv0->base; i != iv1->base; i--)  */\n \t  niter->assumptions = boolean_true_node;\n \t  niter->may_be_zero = boolean_false_node;\n-\t  niter->niter = fold_build2 (MINUS_EXPR, type, base0, base1);\n+\t  niter->niter = fold_build2 (MINUS_EXPR, type, iv0->base, iv1->base);\n \t}\n       else\n \treturn false;\n \n       break;\n \n     case LT_EXPR:\n-      if ((step0 && integer_onep (step0) && zero_p (step1))\n-\t  || (step1 && integer_all_onesp (step1) && zero_p (step0)))\n+      if ((iv0->step && integer_onep (iv0->step)\n+\t   && zero_p (iv1->step))\n+\t  || (iv1->step && integer_all_onesp (iv1->step)\n+\t      && zero_p (iv0->step)))\n \t{\n-\t  /* for (i = base0; i < base1; i++)\n+\t  /* for (i = iv0->base; i < iv1->base; i++)\n \t     \n \t     or\n \n-\t     for (i = base1; i > base0; i--).\n+\t     for (i = iv1->base; i > iv0->base; i--).\n \t     \n-\t     In both cases # of iterations is base1 - base0.  */\n+\t     In both cases # of iterations is iv1->base - iv0->base.  */\n \n \t  niter->assumptions = boolean_true_node;\n \t  niter->may_be_zero = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t\t\t    base0, base1);\n-\t  niter->niter = fold_build2 (MINUS_EXPR, type, base1, base0);\n+\t\t\t\t\t    iv0->base, iv1->base);\n+\t  niter->niter = fold_build2 (MINUS_EXPR, type, iv1->base, iv0->base);\n \t}\n       else\n \treturn false;\n@@ -552,34 +571,36 @@ number_of_iterations_special (tree type, tree base0, tree step0,\n \t  mmax = TYPE_MAX_VALUE (type);\n \t}\n \n-      if (step0 && integer_onep (step0) && zero_p (step1))\n+      if (iv0->step && integer_onep (iv0->step)\n+\t  && zero_p (iv1->step))\n \t{\n-\t  /* for (i = base0; i <= base1; i++)  */\n-\t  if (mmax)\n+\t  /* for (i = iv0->base; i <= iv1->base; i++)  */\n+\t  if (mmax && !iv0->no_overflow)\n \t    niter->assumptions = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t\t\t\t      base1, mmax);\n+\t\t\t\t\t      iv1->base, mmax);\n \t  else\n \t    niter->assumptions = boolean_true_node;\n-\t  base1 = fold_build2 (PLUS_EXPR, type, base1,\n-\t\t\t       build_int_cst_type (type, 1));\n+\t  iv1->base = fold_build2 (PLUS_EXPR, type, iv1->base,\n+\t\t\t\t   build_int_cst_type (type, 1));\n \t}\n-      else if (step1 && integer_all_onesp (step1) && zero_p (step0))\n+      else if (iv1->step && integer_all_onesp (iv1->step)\n+\t       && zero_p (iv0->step))\n \t{\n-\t  /* for (i = base1; i >= base0; i--)  */\n-\t  if (mmin)\n+\t  /* for (i = iv1->base; i >= iv0->base; i--)  */\n+\t  if (mmin && !iv1->no_overflow)\n \t    niter->assumptions = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t\t\t\t      base0, mmin);\n+\t\t\t\t\t      iv0->base, mmin);\n \t  else\n \t    niter->assumptions = boolean_true_node;\n-\t  base0 = fold_build2 (MINUS_EXPR, type, base0,\n-\t\t\t       build_int_cst_type (type, 1));\n+\t  iv0->base = fold_build2 (MINUS_EXPR, type, iv0->base,\n+\t\t\t\t   build_int_cst_type (type, 1));\n \t}\n       else\n \treturn false;\n \n       niter->may_be_zero = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t\t\tbase0, base1);\n-      niter->niter = fold_build2 (MINUS_EXPR, type, base1, base0);\n+\t\t\t\t\tiv0->base, iv1->base);\n+      niter->niter = fold_build2 (MINUS_EXPR, type, iv1->base, iv0->base);\n       break;\n \n     default:\n@@ -922,9 +943,9 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n \t\t\t   bool warn)\n {\n   tree stmt, cond, type;\n-  tree op0, base0, step0;\n-  tree op1, base1, step1;\n+  tree op0, op1;\n   enum tree_code code;\n+  affine_iv iv0, iv1;\n \n   if (!dominated_by_p (CDI_DOMINATORS, loop->latch, exit->src))\n     return false;\n@@ -961,21 +982,19 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n       && !POINTER_TYPE_P (type))\n     return false;\n      \n-  if (!simple_iv (loop, stmt, op0, &base0, &step0, false))\n+  if (!simple_iv (loop, stmt, op0, &iv0, false))\n     return false;\n-  if (!simple_iv (loop, stmt, op1, &base1, &step1, false))\n+  if (!simple_iv (loop, stmt, op1, &iv1, false))\n     return false;\n \n   niter->niter = NULL_TREE;\n \n   /* Handle common special cases first, so that we do not need to use\n      generic (and slow) analysis very often.  */\n-  if (!number_of_iterations_special (type, base0, step0, code, base1, step1,\n-\t\t\t\t     niter))\n+  if (!number_of_iterations_special (type, &iv0, code, &iv1, niter))\n     {\n \n-      number_of_iterations_cond (type, base0, step0, code, base1, step1,\n-\t\t\t\t niter);\n+      number_of_iterations_cond (type, &iv0, code, &iv1, niter);\n \n       if (!niter->niter)\n \treturn false;\n@@ -1019,8 +1038,11 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n   \n       /* We can provide a more specific warning if one of the operator is\n \t constant and the other advances by +1 or -1.  */\n-      if (step1 ? !step0 && (integer_onep (step1) || integer_all_onesp (step1))\n-\t  \t: step0 && (integer_onep (step0) || integer_all_onesp (step0)))\n+      if (!zero_p (iv1.step)\n+\t  ? (zero_p (iv0.step)\n+\t     && (integer_onep (iv1.step) || integer_all_onesp (iv1.step)))\n+\t  : (iv0.step\n+\t     && (integer_onep (iv0.step) || integer_all_onesp (iv0.step))))\n         wording =\n           flag_unsafe_loop_optimizations\n           ? N_(\"assuming that the loop is not infinite\")"}]}