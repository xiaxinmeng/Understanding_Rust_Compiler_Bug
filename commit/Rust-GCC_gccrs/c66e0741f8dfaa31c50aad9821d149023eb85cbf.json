{"sha": "c66e0741f8dfaa31c50aad9821d149023eb85cbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzY2ZTA3NDFmOGRmYWEzMWM1MGFhZDk4MjFkMTQ5MDIzZWI4NWNiZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-01-15T21:34:28Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-01-15T21:34:28Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r191", "tree": {"sha": "37fa8a4be636905df421c8037bd5823a5a867ce0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37fa8a4be636905df421c8037bd5823a5a867ce0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c66e0741f8dfaa31c50aad9821d149023eb85cbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c66e0741f8dfaa31c50aad9821d149023eb85cbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c66e0741f8dfaa31c50aad9821d149023eb85cbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c66e0741f8dfaa31c50aad9821d149023eb85cbf/comments", "author": null, "committer": null, "parents": [{"sha": "d7429b6aeb5a4167e3bcaf8153387ba9509da0b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7429b6aeb5a4167e3bcaf8153387ba9509da0b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7429b6aeb5a4167e3bcaf8153387ba9509da0b0"}], "stats": {"total": 37, "additions": 24, "deletions": 13}, "files": [{"sha": "984cc8b81495a3883f10fafaa38da10e209a6d8c", "filename": "gcc/genrecog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c66e0741f8dfaa31c50aad9821d149023eb85cbf/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c66e0741f8dfaa31c50aad9821d149023eb85cbf/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=c66e0741f8dfaa31c50aad9821d149023eb85cbf", "patch": "@@ -1,5 +1,5 @@\n /* Generate code from machine description to recognize rtl as insns.\n-   Copyright (C) 1987, 1988, 1991 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1992 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n "}, {"sha": "72170a8b534b8c4ceac479bf52f398e0c97e31b6", "filename": "gcc/integrate.c", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c66e0741f8dfaa31c50aad9821d149023eb85cbf/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c66e0741f8dfaa31c50aad9821d149023eb85cbf/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=c66e0741f8dfaa31c50aad9821d149023eb85cbf", "patch": "@@ -1,5 +1,5 @@\n /* Procedure integration for GNU CC.\n-   Copyright (C) 1988-1991 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 1992 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -1042,7 +1042,6 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n   rtx *arg_vals;\n   rtx insn;\n   int max_regno;\n-  int equiv_map_size;\n   register int i;\n   int min_labelno = FIRST_LABELNO (header);\n   int max_labelno = LAST_LABELNO (header);\n@@ -1173,16 +1172,26 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n \n   /* const_equiv_map maps pseudos in our routine to constants, so it needs to\n      be large enough for all our pseudos.  This is the number we are currently\n-     using plus the number in the called routine, plus one for each arg and\n-     one for the return value.  */\n-  equiv_map_size\n-    = max_reg_num () + (max_regno - FIRST_PSEUDO_REGISTER) + nargs + 1;\n-\n-  map->const_equiv_map = (rtx *)alloca (equiv_map_size * sizeof (rtx));\n-  bzero (map->const_equiv_map, equiv_map_size * sizeof (rtx));\n-\n-  map->const_age_map = (unsigned *)alloca (equiv_map_size * sizeof (unsigned));\n-  bzero (map->const_age_map, equiv_map_size * sizeof (unsigned));\n+     using plus the number in the called routine, plus 15 for each arg,\n+     five to compute the virtual frame pointer, and five for the return value.\n+     This should be enough for most cases.  We do not reference entries\n+     outside the range of the map.\n+\n+     ??? These numbers are quite arbitrary and were obtained by\n+     experimentation.  At some point, we should try to allocate the\n+     table after all the parameters are set up so we an more accurately\n+     estimate the number of pseudos we will need.  */\n+\n+  map->const_equiv_map_size\n+    = max_reg_num () + (max_regno - FIRST_PSEUDO_REGISTER) + 15 * nargs + 10;\n+\n+  map->const_equiv_map\n+    = (rtx *)alloca (map->const_equiv_map_size * sizeof (rtx));\n+  bzero (map->const_equiv_map, map->const_equiv_map_size * sizeof (rtx));\n+\n+  map->const_age_map\n+    = (unsigned *)alloca (map->const_equiv_map_size * sizeof (unsigned));\n+  bzero (map->const_age_map, map->const_equiv_map_size * sizeof (unsigned));\n   map->const_age = 0;\n \n   /* Record the current insn in case we have to set up pointers to frame\n@@ -2139,7 +2148,9 @@ subst_constants (loc, insn, map)\n \t hard regs used as user variables with constants.  */\n       {\n \tint regno = REGNO (x);\n+\n \tif (! (regno < FIRST_PSEUDO_REGISTER && REG_USERVAR_P (x))\n+\t    && regno < map->const_equiv_map_size\n \t    && map->const_equiv_map[regno] != 0\n \t    && map->const_age_map[regno] >= map->const_age)\n \t  validate_change (insn, loc, map->const_equiv_map[regno], 1);"}]}