{"sha": "2c699fd29829cd6115f78238dab7cab74f0a5009", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM2OTlmZDI5ODI5Y2Q2MTE1Zjc4MjM4ZGFiN2NhYjc0ZjBhNTAwOQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-07-09T14:20:25Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-07-09T14:20:25Z"}, "message": "c++: requires-expr with dependent extra args [PR101181]\n\nHere we're crashing ultimately because the mechanism for delaying\nsubstitution into a requires-expression (and constexpr if and pack\nexpansions) doesn't expect to see dependent args.  But we end up\ncapturing dependent args here during substitution into the default\ntemplate argument as part of coerce_template_parms for the dependent\nspecialization p<T>.\n\nThis patch enables the commented out code in add_extra_args for handling\nthis situation.  This isn't needed for pack expansions (as the\naccompanying comment points out), and it doesn't seem strictly necessary\nfor constexpr if either, but for requires-expressions delaying even\ndependent substitution is important for ensuring we don't evaluate\nrequirements out of order.\n\nIt turns out we also need to make a copy of the arguments when capturing\nthem so that coerce_template_parms doesn't later add to them and form an\nunexpected cycle (REQUIRES_EXPR_EXTRA_ARGS (t) would indirectly point to t).\nWe also need to make tsubst_template_args handle missing template\narguments, since the arguments we capture from coerce_template_parms\nand are incomplete at that point.\n\n\tPR c++/101181\n\ngcc/cp/ChangeLog:\n\n\t* constraint.cc (tsubst_requires_expr): Pass complain/in_decl to\n\tadd_extra_args.\n\t* cp-tree.h (add_extra_args): Add complain/in_decl parameters.\n\t* pt.c (build_extra_args): Make a copy of args.\n\t(add_extra_args): Add complain/in_decl parameters.  Enable the\n\tcode for handling the case where the extra arguments are\n\tdependent.\n\t(tsubst_pack_expansion): Pass complain/in_decl to\n\tadd_extra_args.\n\t(tsubst_template_args): Handle missing template arguments.\n\t(tsubst_expr) <case IF_STMT>: Pass complain/in_decl to\n\tadd_extra_args.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/concepts-requires26.C: New test.\n\t* g++.dg/cpp2a/lambda-uneval16.C: New test.", "tree": {"sha": "736e4d48fa994c1f2485c5badcfe363da30c5c4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/736e4d48fa994c1f2485c5badcfe363da30c5c4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c699fd29829cd6115f78238dab7cab74f0a5009", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c699fd29829cd6115f78238dab7cab74f0a5009", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c699fd29829cd6115f78238dab7cab74f0a5009", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c699fd29829cd6115f78238dab7cab74f0a5009/comments", "author": null, "committer": null, "parents": [{"sha": "f53e66019df819f55d424cc56f8b0ea81c074b55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f53e66019df819f55d424cc56f8b0ea81c074b55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f53e66019df819f55d424cc56f8b0ea81c074b55"}], "stats": {"total": 76, "additions": 58, "deletions": 18}, "files": [{"sha": "4ee5215df505a56943d0195bb244d707ca3e7421", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c699fd29829cd6115f78238dab7cab74f0a5009/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c699fd29829cd6115f78238dab7cab74f0a5009/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=2c699fd29829cd6115f78238dab7cab74f0a5009", "patch": "@@ -2266,7 +2266,8 @@ tsubst_requires_expr (tree t, tree args, sat_info info)\n   /* A requires-expression is an unevaluated context.  */\n   cp_unevaluated u;\n \n-  args = add_extra_args (REQUIRES_EXPR_EXTRA_ARGS (t), args);\n+  args = add_extra_args (REQUIRES_EXPR_EXTRA_ARGS (t), args,\n+\t\t\t info.complain, info.in_decl);\n   if (processing_template_decl)\n     {\n       /* We're partially instantiating a generic lambda.  Substituting into"}, {"sha": "b1cf44ecdb88583cd25d56bffda047b5f8d4768e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c699fd29829cd6115f78238dab7cab74f0a5009/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c699fd29829cd6115f78238dab7cab74f0a5009/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2c699fd29829cd6115f78238dab7cab74f0a5009", "patch": "@@ -7291,7 +7291,7 @@ extern void add_mergeable_specialization        (bool is_decl, bool is_alias,\n \t\t\t\t\t\t tree outer, unsigned);\n extern tree add_to_template_args\t\t(tree, tree);\n extern tree add_outermost_template_args\t\t(tree, tree);\n-extern tree add_extra_args\t\t\t(tree, tree);\n+extern tree add_extra_args\t\t\t(tree, tree, tsubst_flags_t, tree);\n extern tree build_extra_args\t\t\t(tree, tree, tsubst_flags_t);\n \n /* in rtti.c */"}, {"sha": "cf0ce770d52fa420633eaf3757ee65674fce8cbd", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c699fd29829cd6115f78238dab7cab74f0a5009/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c699fd29829cd6115f78238dab7cab74f0a5009/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2c699fd29829cd6115f78238dab7cab74f0a5009", "patch": "@@ -12907,7 +12907,9 @@ extract_local_specs (tree pattern, tsubst_flags_t complain)\n tree\n build_extra_args (tree pattern, tree args, tsubst_flags_t complain)\n {\n-  tree extra = args;\n+  /* Make a copy of the extra arguments so that they won't get changed\n+     out from under us.  */\n+  tree extra = copy_template_args (args);\n   if (local_specializations)\n     if (tree locals = extract_local_specs (pattern, complain))\n       extra = tree_cons (NULL_TREE, extra, locals);\n@@ -12918,7 +12920,7 @@ build_extra_args (tree pattern, tree args, tsubst_flags_t complain)\n    normal template args to ARGS.  */\n \n tree\n-add_extra_args (tree extra, tree args)\n+add_extra_args (tree extra, tree args, tsubst_flags_t complain, tree in_decl)\n {\n   if (extra && TREE_CODE (extra) == TREE_LIST)\n     {\n@@ -12938,20 +12940,14 @@ add_extra_args (tree extra, tree args)\n       gcc_assert (!TREE_PURPOSE (extra));\n       extra = TREE_VALUE (extra);\n     }\n-#if 1\n-  /* I think we should always be able to substitute dependent args into the\n-     pattern.  If that turns out to be incorrect in some cases, enable the\n-     alternate code (and add complain/in_decl parms to this function).  */\n-  gcc_checking_assert (!uses_template_parms (extra));\n-#else\n-  if (!uses_template_parms (extra))\n+  if (uses_template_parms (extra))\n     {\n-      gcc_unreachable ();\n+      /* This can happen after dependent substitution into a\n+\t requires-expr or a lambda that uses constexpr if.  */\n       extra = tsubst_template_args (extra, args, complain, in_decl);\n       args = add_outermost_template_args (args, extra);\n     }\n   else\n-#endif\n     args = add_to_template_args (extra, args);\n   return args;\n }\n@@ -12977,7 +12973,7 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n   pattern = PACK_EXPANSION_PATTERN (t);\n \n   /* Add in any args remembered from an earlier partial instantiation.  */\n-  args = add_extra_args (PACK_EXPANSION_EXTRA_ARGS (t), args);\n+  args = add_extra_args (PACK_EXPANSION_EXTRA_ARGS (t), args, complain, in_decl);\n \n   levels = TMPL_ARGS_DEPTH (args);\n \n@@ -13349,7 +13345,9 @@ tsubst_template_args (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       tree orig_arg = TREE_VEC_ELT (t, i);\n       tree new_arg;\n \n-      if (TREE_CODE (orig_arg) == TREE_VEC)\n+      if (!orig_arg)\n+\tnew_arg = NULL_TREE;\n+      else if (TREE_CODE (orig_arg) == TREE_VEC)\n \tnew_arg = tsubst_template_args (orig_arg, args, complain, in_decl);\n       else if (PACK_EXPANSION_P (orig_arg))\n         {\n@@ -13399,8 +13397,9 @@ tsubst_template_args (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     }\n   for (i = 0, out = 0; i < len; i++)\n     {\n-      if ((PACK_EXPANSION_P (TREE_VEC_ELT (orig_t, i))\n-           || ARGUMENT_PACK_P (TREE_VEC_ELT (orig_t, i)))\n+      tree orig_arg = TREE_VEC_ELT (orig_t, i);\n+      if (orig_arg\n+\t  && (PACK_EXPANSION_P (orig_arg) || ARGUMENT_PACK_P (orig_arg))\n           && TREE_CODE (elts[i]) == TREE_VEC)\n         {\n           int idx;\n@@ -18428,7 +18427,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       IF_STMT_CONSTEXPR_P (stmt) = IF_STMT_CONSTEXPR_P (t);\n       IF_STMT_CONSTEVAL_P (stmt) = IF_STMT_CONSTEVAL_P (t);\n       if (IF_STMT_CONSTEXPR_P (t))\n-\targs = add_extra_args (IF_STMT_EXTRA_ARGS (t), args);\n+\targs = add_extra_args (IF_STMT_EXTRA_ARGS (t), args, complain, in_decl);\n       tmp = RECUR (IF_COND (t));\n       tmp = finish_if_stmt_cond (tmp, stmt);\n       if (IF_STMT_CONSTEXPR_P (t)"}, {"sha": "824d23431f0e38e8da632b16b02877ff63622034", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires26.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c699fd29829cd6115f78238dab7cab74f0a5009/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c699fd29829cd6115f78238dab7cab74f0a5009/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires26.C?ref=2c699fd29829cd6115f78238dab7cab74f0a5009", "patch": "@@ -0,0 +1,18 @@\n+// PR c++/101181\n+// { dg-do compile { target c++20 } }\n+\n+template<class T,\n+\t bool = requires { typename T::type; }>\n+struct p { using type = void; };\n+\n+template<class T>\n+struct p<T, true> { using type = typename T::type; };\n+\n+template<class T> using P = typename p<T>::type;\n+\n+using type1 = P<int>;\n+using type1 = void;\n+\n+struct A { using type = char; };\n+using type2 = P<A>;\n+using type2 = char;"}, {"sha": "1113c6f02b9a7890fe15587cdb7ec9d0b35d62c6", "filename": "gcc/testsuite/g++.dg/cpp2a/lambda-uneval16.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c699fd29829cd6115f78238dab7cab74f0a5009/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c699fd29829cd6115f78238dab7cab74f0a5009/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval16.C?ref=2c699fd29829cd6115f78238dab7cab74f0a5009", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/101181\n+// { dg-do compile { target c++20 } }\n+\n+template<class T,\n+\t bool = [] () -> bool {\n+\t   if constexpr (requires { typename T::type; })\n+\t     return true;\n+\t   return false;\n+\t }()>\n+struct p { using type = void; };\n+\n+template<class T>\n+struct p<T, true> { using type = typename T::type; };\n+\n+template<class T> using P = typename p<T>::type;\n+\n+using type1 = P<int>;\n+using type = void;\n+\n+struct A { using type = char; };\n+using type2 = P<A>;\n+using type2 = char;"}]}