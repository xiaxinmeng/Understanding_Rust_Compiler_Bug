{"sha": "26ca7d1b24478324969eae0d171ad698926c8541", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZjYTdkMWIyNDQ3ODMyNDk2OWVhZTBkMTcxYWQ2OTg5MjZjODU0MQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2019-09-30T13:49:13Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2019-09-30T13:49:13Z"}, "message": "Add initial support for prefixed/PC-relative addressing.\n\n2019-09-30  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* config/rs6000/predicates.md (pcrel_address): Delete predicate.\n\t(pcrel_local_address): Replace pcrel_address predicate, use the\n\tnew function address_to_insn_form.\n\t(pcrel_external_address): Replace with new implementation using\n\taddress_to_insn_form..\n\t(prefixed_mem_operand): Delete predicate which is now unused.\n\t(pcrel_external_mem_operand): Delete predicate which is now\n\tunused.\n\t* config/rs6000/rs6000-protos.h (enum insn_form): New\n\tenumeration.\n\t(enum non_prefixed): New enumeration.\n\t(address_to_insn_form): New declaration.\n\t(prefixed_load_p): New declaration.\n\t(prefixed_store_p): New declaration.\n\t(prefixed_paddi_p): New declaration.\n\t(rs6000_asm_output_opcode): New declaration.\n\t(rs6000_final_prescan_insn): Move declaration and update calling\n\tsignature.\n\t(address_is_prefixed): New helper inline function.\n\t* config/rs6000/rs6000.c(print_operand_address): Check for either\n\tPC-relative local symbols or PC-relative external symbols.\n\t(rs6000_emit_move): Support loading PC-relative addresses.\n\t(mode_supports_prefixed_address_p): Delete, no longer used.\n\t(rs6000_prefixed_address_mode_p): Delete, no longer used.\n\t(address_to_insn_form): New function to decode an address format.\n\t(reg_to_non_prefixed): New function to identify what the\n\tnon-prefixed memory instruction format is for a register.\n\t(prefixed_load_p): New function to identify prefixed loads.\n\t(prefixed_store_p): New function to identify prefixed stores.\n\t(prefixed_paddi_p): New function to identify prefixed load\n\timmediates.\n\t(next_insn_prefixed_p): New static state variable.\n\t(rs6000_final_prescan_insn): New function to determine if an insn\n\tuses a prefixed instruction.\n\t(rs6000_asm_output_opcode): New function to emit 'p' in front of a\n\tprefixed instruction.\n\t* config/rs6000/rs6000.h (FINAL_PRESCAN_INSN): New target hook.\n\t(ASM_OUTPUT_OPCODE): New target hook.\n\t* config/rs6000/rs6000.md (prefixed): New insn attribute for\n\tprefixed instructions.\n\t(prefixed_length): New insn attribute for the size of prefixed\n\tinstructions.\n\t(non_prefixed_length): New insn attribute for the size of\n\tnon-prefixed instructions.\n\t(pcrel_local_addr): New insn to load up a local PC-relative\n\taddress.\n\t(pcrel_extern_addr): New insn to load up an external PC-relative\n\taddress.\n\t(mov<mode>_64bit_dm): Split the alternatives for loading 0.0 to a\n\tGPR and loading a 128-bit floating point type to a GPR.\n\nFrom-SVN: r276300", "tree": {"sha": "8b0f45dd1047df383435ff8e968cd6e5280b76e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b0f45dd1047df383435ff8e968cd6e5280b76e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26ca7d1b24478324969eae0d171ad698926c8541", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26ca7d1b24478324969eae0d171ad698926c8541", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26ca7d1b24478324969eae0d171ad698926c8541", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26ca7d1b24478324969eae0d171ad698926c8541/comments", "author": null, "committer": null, "parents": [{"sha": "61362d9d18916bd5b694385982cf4a02b7537b0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61362d9d18916bd5b694385982cf4a02b7537b0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61362d9d18916bd5b694385982cf4a02b7537b0e"}], "stats": {"total": 784, "additions": 631, "deletions": 153}, "files": [{"sha": "74f08cc6dd3a312450784379e7b78b79a7d06724", "filename": "gcc/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26ca7d1b24478324969eae0d171ad698926c8541/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26ca7d1b24478324969eae0d171ad698926c8541/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=26ca7d1b24478324969eae0d171ad698926c8541", "patch": "@@ -1,3 +1,56 @@\n+2019-09-30  Michael Meissner  <meissner@linux.ibm.com>\n+\n+\t* config/rs6000/predicates.md (pcrel_address): Delete predicate.\n+\t(pcrel_local_address): Replace pcrel_address predicate, use the\n+\tnew function address_to_insn_form.\n+\t(pcrel_external_address): Replace with new implementation using\n+\taddress_to_insn_form..\n+\t(prefixed_mem_operand): Delete predicate which is now unused.\n+\t(pcrel_external_mem_operand): Delete predicate which is now\n+\tunused.\n+\t* config/rs6000/rs6000-protos.h (enum insn_form): New\n+\tenumeration.\n+\t(enum non_prefixed): New enumeration.\n+\t(address_to_insn_form): New declaration.\n+\t(prefixed_load_p): New declaration.\n+\t(prefixed_store_p): New declaration.\n+\t(prefixed_paddi_p): New declaration.\n+\t(rs6000_asm_output_opcode): New declaration.\n+\t(rs6000_final_prescan_insn): Move declaration and update calling\n+\tsignature.\n+\t(address_is_prefixed): New helper inline function.\n+\t* config/rs6000/rs6000.c(print_operand_address): Check for either\n+\tPC-relative local symbols or PC-relative external symbols.\n+\t(rs6000_emit_move): Support loading PC-relative addresses.\n+\t(mode_supports_prefixed_address_p): Delete, no longer used.\n+\t(rs6000_prefixed_address_mode_p): Delete, no longer used.\n+\t(address_to_insn_form): New function to decode an address format.\n+\t(reg_to_non_prefixed): New function to identify what the\n+\tnon-prefixed memory instruction format is for a register.\n+\t(prefixed_load_p): New function to identify prefixed loads.\n+\t(prefixed_store_p): New function to identify prefixed stores.\n+\t(prefixed_paddi_p): New function to identify prefixed load\n+\timmediates.\n+\t(next_insn_prefixed_p): New static state variable.\n+\t(rs6000_final_prescan_insn): New function to determine if an insn\n+\tuses a prefixed instruction.\n+\t(rs6000_asm_output_opcode): New function to emit 'p' in front of a\n+\tprefixed instruction.\n+\t* config/rs6000/rs6000.h (FINAL_PRESCAN_INSN): New target hook.\n+\t(ASM_OUTPUT_OPCODE): New target hook.\n+\t* config/rs6000/rs6000.md (prefixed): New insn attribute for\n+\tprefixed instructions.\n+\t(prefixed_length): New insn attribute for the size of prefixed\n+\tinstructions.\n+\t(non_prefixed_length): New insn attribute for the size of\n+\tnon-prefixed instructions.\n+\t(pcrel_local_addr): New insn to load up a local PC-relative\n+\taddress.\n+\t(pcrel_extern_addr): New insn to load up an external PC-relative\n+\taddress.\n+\t(mov<mode>_64bit_dm): Split the alternatives for loading 0.0 to a\n+\tGPR and loading a 128-bit floating point type to a GPR.\n+\n 2019-09-30  Richard Biener  <rguenther@suse.de>\n \n \t* gimple.c (gimple_get_lhs): For PHIs return the result."}, {"sha": "345d9c337af8928fcb33cb19da95e766797c30be", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 26, "deletions": 76, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26ca7d1b24478324969eae0d171ad698926c8541/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26ca7d1b24478324969eae0d171ad698926c8541/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=26ca7d1b24478324969eae0d171ad698926c8541", "patch": "@@ -1625,82 +1625,7 @@\n   return GET_CODE (op) == UNSPEC && XINT (op, 1) == UNSPEC_TOCREL;\n })\n \n-;; Return true if the operand is a pc-relative address.\n-(define_predicate \"pcrel_address\"\n-  (match_code \"label_ref,symbol_ref,const\")\n-{\n-  if (!rs6000_pcrel_p (cfun))\n-    return false;\n-\n-  if (GET_CODE (op) == CONST)\n-    op = XEXP (op, 0);\n-\n-  /* Validate offset.  */\n-  if (GET_CODE (op) == PLUS)\n-    {\n-      rtx op0 = XEXP (op, 0);\n-      rtx op1 = XEXP (op, 1);\n-\n-      if (!CONST_INT_P (op1) || !SIGNED_34BIT_OFFSET_P (INTVAL (op1)))\n-\treturn false;\n-\n-      op = op0;\n-    }\n-\n-  if (LABEL_REF_P (op))\n-    return true;\n-\n-  return (SYMBOL_REF_P (op) && SYMBOL_REF_LOCAL_P (op));\n-})\n-\n-;; Return true if the operand is an external symbol whose address can be loaded\n-;; into a register using:\n-;;\tPLD reg,label@pcrel@got\n-;;\n-;; The linker will either optimize this to either a PADDI if the label is\n-;; defined locally in another module or a PLD of the address if the label is\n-;; defined in another module.\n-\n-(define_predicate \"pcrel_external_address\"\n-  (match_code \"symbol_ref,const\")\n-{\n-  if (!rs6000_pcrel_p (cfun))\n-    return false;\n-\n-  if (GET_CODE (op) == CONST)\n-    op = XEXP (op, 0);\n-\n-  /* Validate offset.  */\n-  if (GET_CODE (op) == PLUS)\n-    {\n-      rtx op0 = XEXP (op, 0);\n-      rtx op1 = XEXP (op, 1);\n-\n-      if (!CONST_INT_P (op1) || !SIGNED_34BIT_OFFSET_P (INTVAL (op1)))\n-\treturn false;\n-\n-      op = op0;\n-    }\n-\n-  return (SYMBOL_REF_P (op) && !SYMBOL_REF_LOCAL_P (op));\n-})\n-\n-;; Return 1 if op is a prefixed memory operand.\n-(define_predicate \"prefixed_mem_operand\"\n-  (match_code \"mem\")\n-{\n-  return rs6000_prefixed_address_mode_p (XEXP (op, 0), GET_MODE (op));\n-})\n-\n-;; Return 1 if op is a memory operand to an external variable when we\n-;; support pc-relative addressing and the PCREL_OPT relocation to\n-;; optimize references to it.\n-(define_predicate \"pcrel_external_mem_operand\"\n-  (match_code \"mem\")\n-{\n-  return pcrel_external_address (XEXP (op, 0), Pmode);\n-})\n-\n+\f\n ;; Match the first insn (addis) in fusing the combination of addis and loads to\n ;; GPR registers on power8.\n (define_predicate \"fusion_gpr_addis\"\n@@ -1857,3 +1782,28 @@\n \n   return 0;\n })\n+\n+\f\n+;; Return true if the operand is a PC-relative address of a local symbol or a\n+;; label that can be used directly in a memory operation.\n+(define_predicate \"pcrel_local_address\"\n+  (match_code \"label_ref,symbol_ref,const\")\n+{\n+  enum insn_form iform = address_to_insn_form (op, mode, NON_PREFIXED_DEFAULT);\n+  return iform == INSN_FORM_PCREL_LOCAL;\n+})\n+\n+;; Return true if the operand is a PC-relative external symbol whose address\n+;; can be loaded into a register.\n+(define_predicate \"pcrel_external_address\"\n+  (match_code \"symbol_ref,const\")\n+{\n+  enum insn_form iform = address_to_insn_form (op, mode, NON_PREFIXED_DEFAULT);\n+  return iform == INSN_FORM_PCREL_EXTERNAL;\n+})\n+\n+;; Return true if the address is PC-relative and the symbol is either local or\n+;; external.\n+(define_predicate \"pcrel_local_or_external_address\"\n+  (ior (match_operand 0 \"pcrel_local_address\")\n+       (match_operand 0 \"pcrel_external_address\")))"}, {"sha": "c51b768d96475c8bc4ff1507815b608e69ca6272", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 60, "deletions": 3, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26ca7d1b24478324969eae0d171ad698926c8541/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26ca7d1b24478324969eae0d171ad698926c8541/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=26ca7d1b24478324969eae0d171ad698926c8541", "patch": "@@ -154,7 +154,66 @@ extern align_flags rs6000_loop_align (rtx);\n extern void rs6000_split_logical (rtx [], enum rtx_code, bool, bool, bool);\n extern bool rs6000_pcrel_p (struct function *);\n extern bool rs6000_fndecl_pcrel_p (const_tree);\n-extern bool rs6000_prefixed_address_mode_p (rtx, machine_mode);\n+\n+/* Different PowerPC instruction formats that are used by GCC.  There are\n+   various other instruction formats used by the PowerPC hardware, but these\n+   formats are not currently used by GCC.  */\n+\n+enum insn_form {\n+  INSN_FORM_BAD,\t\t/* Bad instruction format.  */\n+  INSN_FORM_BASE_REG,\t\t/* Base register only.  */\n+  INSN_FORM_D,\t\t\t/* Reg + 16-bit numeric offset.  */\n+  INSN_FORM_DS,\t\t\t/* Reg + offset, bottom 2 bits must be 0.  */\n+  INSN_FORM_DQ,\t\t\t/* Reg + offset, bottom 4 bits must be 0.  */\n+  INSN_FORM_X,\t\t\t/* Base register + index register.  */\n+  INSN_FORM_UPDATE,\t\t/* Address updates base register.  */\n+  INSN_FORM_LO_SUM,\t\t/* Reg + offset using symbol.  */\n+  INSN_FORM_PREFIXED_NUMERIC,\t/* Reg + 34 bit numeric offset.  */\n+  INSN_FORM_PCREL_LOCAL,\t/* PC-relative local symbol.  */\n+  INSN_FORM_PCREL_EXTERNAL\t/* PC-relative external symbol.  */\n+};\n+\n+/* Instruction format for the non-prefixed version of a load or store.  This is\n+   used to determine if a 16-bit offset is valid to be used with a non-prefixed\n+   (traditional) instruction or if the bottom bits of the offset cannot be used\n+   with a DS or DQ instruction format, and GCC has to use a prefixed\n+   instruction for the load or store.  */\n+\n+enum non_prefixed_form {\n+  NON_PREFIXED_DEFAULT,\t\t/* Use the default.  */\n+  NON_PREFIXED_D,\t\t/* All 16-bits are valid.  */\n+  NON_PREFIXED_DS,\t\t/* Bottom 2 bits must be 0.  */\n+  NON_PREFIXED_DQ,\t\t/* Bottom 4 bits must be 0.  */\n+  NON_PREFIXED_X\t\t/* No offset memory form exists.  */\n+};\n+\n+extern enum insn_form address_to_insn_form (rtx, machine_mode,\n+\t\t\t\t\t    enum non_prefixed_form);\n+extern bool prefixed_load_p (rtx_insn *);\n+extern bool prefixed_store_p (rtx_insn *);\n+extern bool prefixed_paddi_p (rtx_insn *);\n+extern void rs6000_asm_output_opcode (FILE *);\n+extern void rs6000_final_prescan_insn (rtx_insn *, rtx [], int);\n+\n+/* Return true if the address can be used for a prefixed load, store, or add\n+   immediate instructions that cannot be used with a non-prefixed instruction.\n+   For example, using a numeric offset that is not valid for the non-prefixed\n+   instruction or a PC-relative reference to a local symbol would return true,\n+   but an address with an offset of 64 would not return true.\n+\n+   References to external PC-relative symbols aren't allowed, because GCC has\n+   to load the address into a register and then issue a separate load or\n+   store.  */\n+\n+static inline bool\n+address_is_prefixed (rtx addr,\n+\t\t     machine_mode mode,\n+\t\t     enum non_prefixed_form non_prefixed)\n+{\n+  enum insn_form iform = address_to_insn_form (addr, mode, non_prefixed);\n+  return (iform == INSN_FORM_PREFIXED_NUMERIC\n+\t  || iform == INSN_FORM_PCREL_LOCAL);\n+}\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE\n@@ -234,8 +293,6 @@ extern void rs6000_d_target_versions (void);\n const char * rs6000_xcoff_strip_dollar (const char *);\n #endif\n \n-void rs6000_final_prescan_insn (rtx_insn *, rtx *operand, int num_operands);\n-\n extern unsigned char rs6000_class_max_nregs[][LIM_REG_CLASSES];\n extern unsigned char rs6000_hard_regno_nregs[][FIRST_PSEUDO_REGISTER];\n "}, {"sha": "d6e1fea842646d473de0aa80581aa9021cbf7ce5", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 393, "deletions": 68, "changes": 461, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26ca7d1b24478324969eae0d171ad698926c8541/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26ca7d1b24478324969eae0d171ad698926c8541/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=26ca7d1b24478324969eae0d171ad698926c8541", "patch": "@@ -9640,6 +9640,14 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n \t  return;\n \t}\n \n+      /* Use the default pattern for loading up PC-relative addresses.  */\n+      if (TARGET_PCREL && mode == Pmode\n+\t  && pcrel_local_or_external_address (operands[1], Pmode))\n+\t{\n+\t  emit_insn (gen_rtx_SET (operands[0], operands[1]));\n+\t  return;\n+\t}\n+\n       if (DEFAULT_ABI == ABI_V4\n \t  && mode == Pmode && mode == SImode\n \t  && flag_pic == 1 && got_operand (operands[1], mode))\n@@ -13082,8 +13090,8 @@ print_operand_address (FILE *file, rtx x)\n   if (REG_P (x))\n     fprintf (file, \"0(%s)\", reg_names[ REGNO (x) ]);\n \n-  /* Is it a pc-relative address?  */\n-  else if (pcrel_address (x, Pmode))\n+  /* Is it a PC-relative address?  */\n+  else if (TARGET_PCREL && pcrel_local_or_external_address (x, VOIDmode))\n     {\n       HOST_WIDE_INT offset;\n \n@@ -13103,7 +13111,10 @@ print_operand_address (FILE *file, rtx x)\n       if (offset)\n \tfprintf (file, \"%+\" PRId64, offset);\n \n-      fputs (\"@pcrel\", file);\n+      if (SYMBOL_REF_P (x) && !SYMBOL_REF_LOCAL_P (x))\n+\tfprintf (file, \"@got\");\n+\n+      fprintf (file, \"@pcrel\");\n     }\n   else if (SYMBOL_REF_P (x) || GET_CODE (x) == CONST\n \t   || GET_CODE (x) == LABEL_REF)\n@@ -13588,71 +13599,6 @@ rs6000_pltseq_template (rtx *operands, int which)\n   return str;\n }\n #endif\n-\n-/* Helper function to return whether a MODE can do prefixed loads/stores.\n-   VOIDmode is used when we are loading the pc-relative address into a base\n-   register, but we are not using it as part of a memory operation.  As modes\n-   add support for prefixed memory, they will be added here.  */\n-\n-static bool\n-mode_supports_prefixed_address_p (machine_mode mode)\n-{\n-  return mode == VOIDmode;\n-}\n-\n-/* Function to return true if ADDR is a valid prefixed memory address that uses\n-   mode MODE.  */\n-\n-bool\n-rs6000_prefixed_address_mode_p (rtx addr, machine_mode mode)\n-{\n-  if (!TARGET_PREFIXED_ADDR || !mode_supports_prefixed_address_p (mode))\n-    return false;\n-\n-  /* Check for PC-relative addresses.  */\n-  if (pcrel_address (addr, Pmode))\n-    return true;\n-\n-  /* Check for prefixed memory addresses that have a large numeric offset,\n-     or an offset that can't be used for a DS/DQ-form memory operation.  */\n-  if (GET_CODE (addr) == PLUS)\n-    {\n-      rtx op0 = XEXP (addr, 0);\n-      rtx op1 = XEXP (addr, 1);\n-\n-      if (!base_reg_operand (op0, Pmode) || !CONST_INT_P (op1))\n-\treturn false;\n-\n-      HOST_WIDE_INT value = INTVAL (op1);\n-      if (!SIGNED_34BIT_OFFSET_P (value))\n-\treturn false;\n-\n-      /* Offset larger than 16-bits?  */\n-      if (!SIGNED_16BIT_OFFSET_P (value))\n-\treturn true;\n-\n-      /* DQ instruction (bottom 4 bits must be 0) for vectors.  */\n-      HOST_WIDE_INT mask;\n-      if (GET_MODE_SIZE (mode) >= 16)\n-\tmask = 15;\n-\n-      /* DS instruction (bottom 2 bits must be 0).  For 32-bit integers, we\n-\t need to use DS instructions if we are sign-extending the value with\n-\t LWA.  For 32-bit floating point, we need DS instructions to load and\n-\t store values to the traditional Altivec registers.  */\n-      else if (GET_MODE_SIZE (mode) >= 4)\n-\tmask = 3;\n-\n-      /* QImode/HImode has no restrictions.  */\n-      else\n-\treturn true;\n-\n-      /* Return true if we must use a prefixed instruction.  */\n-      return (value & mask) != 0;\n-    }\n-\n-  return false;\n-}\n \f\n #if defined (HAVE_GAS_HIDDEN) && !TARGET_MACHO\n /* Emit an assembler directive to set symbol visibility for DECL to\n@@ -24617,6 +24563,385 @@ rs6000_pcrel_p (struct function *fn)\n   return rs6000_fndecl_pcrel_p (fn->decl);\n }\n \n+\f\n+/* Given an address (ADDR), a mode (MODE), and what the format of the\n+   non-prefixed address (NON_PREFIXED_FORMAT) is, return the instruction format\n+   for the address.  */\n+\n+enum insn_form\n+address_to_insn_form (rtx addr,\n+\t\t      machine_mode mode,\n+\t\t      enum non_prefixed_form non_prefixed_format)\n+{\n+  /* Single register is easy.  */\n+  if (REG_P (addr) || SUBREG_P (addr))\n+    return INSN_FORM_BASE_REG;\n+\n+  /* If the non prefixed instruction format doesn't support offset addressing,\n+     make sure only indexed addressing is allowed.\n+\n+     We special case SDmode so that the register allocator does not try to move\n+     SDmode through GPR registers, but instead uses the 32-bit integer load and\n+     store instructions for the floating point registers.  */\n+  if (non_prefixed_format == NON_PREFIXED_X || (mode == SDmode && TARGET_DFP))\n+    {\n+      if (GET_CODE (addr) != PLUS)\n+\treturn INSN_FORM_BAD;\n+\n+      rtx op0 = XEXP (addr, 0);\n+      rtx op1 = XEXP (addr, 1);\n+      if (!REG_P (op0) && !SUBREG_P (op0))\n+\treturn INSN_FORM_BAD;\n+\n+      if (!REG_P (op1) && !SUBREG_P (op1))\n+\treturn INSN_FORM_BAD;\n+\n+      return INSN_FORM_X;\n+    }\n+\n+  /* Deal with update forms.  */\n+  if (GET_RTX_CLASS (GET_CODE (addr)) == RTX_AUTOINC)\n+    return INSN_FORM_UPDATE;\n+\n+  /* Handle PC-relative symbols and labels.  Check for both local and external\n+     symbols.  Assume labels are always local.  */\n+  if (TARGET_PCREL)\n+    {\n+      if (SYMBOL_REF_P (addr) && !SYMBOL_REF_LOCAL_P (addr))\n+\treturn INSN_FORM_PCREL_EXTERNAL;\n+\n+      if (SYMBOL_REF_P (addr) || LABEL_REF_P (addr))\n+\treturn INSN_FORM_PCREL_LOCAL;\n+    }\n+\n+  if (GET_CODE (addr) == CONST)\n+    addr = XEXP (addr, 0);\n+\n+  /* Recognize LO_SUM addresses used with TOC and 32-bit addressing.  */\n+  if (GET_CODE (addr) == LO_SUM)\n+    return INSN_FORM_LO_SUM;\n+\n+  /* Everything below must be an offset address of some form.  */\n+  if (GET_CODE (addr) != PLUS)\n+    return INSN_FORM_BAD;\n+\n+  rtx op0 = XEXP (addr, 0);\n+  rtx op1 = XEXP (addr, 1);\n+\n+  /* Check for indexed addresses.  */\n+  if (REG_P (op1) || SUBREG_P (op1))\n+    {\n+      if (REG_P (op0) || SUBREG_P (op0))\n+\treturn INSN_FORM_X;\n+\n+      return INSN_FORM_BAD;\n+    }\n+\n+  if (!CONST_INT_P (op1))\n+    return INSN_FORM_BAD;\n+\n+  HOST_WIDE_INT offset = INTVAL (op1);\n+  if (!SIGNED_34BIT_OFFSET_P (offset))\n+    return INSN_FORM_BAD;\n+\n+  /* Check for local and external PC-relative addresses.  Labels are always\n+     local.  */\n+  if (TARGET_PCREL)\n+    {\n+      if (SYMBOL_REF_P (op0) && !SYMBOL_REF_LOCAL_P (op0))\n+\treturn INSN_FORM_PCREL_EXTERNAL;\n+\n+      if (SYMBOL_REF_P (op0) || LABEL_REF_P (op0))\n+\treturn INSN_FORM_PCREL_LOCAL;\n+    }\n+\n+  /* If it isn't PC-relative, the address must use a base register.  */\n+  if (!REG_P (op0) && !SUBREG_P (op0))\n+    return INSN_FORM_BAD;\n+\n+  /* Large offsets must be prefixed.  */\n+  if (!SIGNED_16BIT_OFFSET_P (offset))\n+    {\n+      if (TARGET_PREFIXED_ADDR)\n+\treturn INSN_FORM_PREFIXED_NUMERIC;\n+\n+      return INSN_FORM_BAD;\n+    }\n+\n+  /* We have a 16-bit offset, see what default instruction format to use.  */\n+  if (non_prefixed_format == NON_PREFIXED_DEFAULT)\n+    {\n+      unsigned size = GET_MODE_SIZE (mode);\n+\n+      /* On 64-bit systems, assume 64-bit integers need to use DS form\n+\t addresses (for LD/STD).  VSX vectors need to use DQ form addresses\n+\t (for LXV and STXV).  TImode is problematical in that its normal usage\n+\t is expected to be GPRs where it wants a DS instruction format, but if\n+\t it goes into the vector registers, it wants a DQ instruction\n+\t format.  */\n+      if (TARGET_POWERPC64 && size >= 8 && GET_MODE_CLASS (mode) == MODE_INT)\n+\tnon_prefixed_format = NON_PREFIXED_DS;\n+\n+      else if (TARGET_VSX && size >= 16\n+\t       && (VECTOR_MODE_P (mode) || FLOAT128_VECTOR_P (mode)))\n+\tnon_prefixed_format = NON_PREFIXED_DQ;\n+\n+      else\n+\tnon_prefixed_format = NON_PREFIXED_D;\n+    }\n+\n+  /* Classify the D/DS/DQ-form addresses.  */\n+  switch (non_prefixed_format)\n+    {\n+      /* Instruction format D, all 16 bits are valid.  */\n+    case NON_PREFIXED_D:\n+      return INSN_FORM_D;\n+\n+      /* Instruction format DS, bottom 2 bits must be 0.  */\n+    case NON_PREFIXED_DS:\n+      if ((offset & 3) == 0)\n+\treturn INSN_FORM_DS;\n+\n+      else if (TARGET_PREFIXED_ADDR)\n+\treturn INSN_FORM_PREFIXED_NUMERIC;\n+\n+      else\n+\treturn INSN_FORM_BAD;\n+\n+      /* Instruction format DQ, bottom 4 bits must be 0.  */\n+    case NON_PREFIXED_DQ:\n+      if ((offset & 15) == 0)\n+\treturn INSN_FORM_DQ;\n+\n+      else if (TARGET_PREFIXED_ADDR)\n+\treturn INSN_FORM_PREFIXED_NUMERIC;\n+\n+      else\n+\treturn INSN_FORM_BAD;\n+\n+    default:\n+      break;\n+    }\n+\n+  return INSN_FORM_BAD;\n+}\n+\n+/* Helper function to take a REG and a MODE and turn it into the non-prefixed\n+   instruction format (D/DS/DQ) used for offset memory.  */\n+\n+static enum non_prefixed_form\n+reg_to_non_prefixed (rtx reg, machine_mode mode)\n+{\n+  /* If it isn't a register, use the defaults.  */\n+  if (!REG_P (reg) && !SUBREG_P (reg))\n+    return NON_PREFIXED_DEFAULT;\n+\n+  unsigned int r = reg_or_subregno (reg);\n+\n+  /* If we have a pseudo, use the default instruction format.  */\n+  if (!HARD_REGISTER_NUM_P (r))\n+    return NON_PREFIXED_DEFAULT;\n+\n+  unsigned size = GET_MODE_SIZE (mode);\n+\n+  /* FPR registers use D-mode for scalars, and DQ-mode for vectors, IEEE\n+     128-bit floating point, and 128-bit integers.  */\n+  if (FP_REGNO_P (r))\n+    {\n+      if (mode == SFmode || size == 8 || FLOAT128_2REG_P (mode))\n+\treturn NON_PREFIXED_D;\n+\n+      else if (size < 8)\n+\treturn NON_PREFIXED_X;\n+\n+      else if (TARGET_VSX && size >= 16\n+\t       && (VECTOR_MODE_P (mode)\n+\t\t   || FLOAT128_VECTOR_P (mode)\n+\t\t   || mode == TImode || mode == CTImode))\n+\treturn NON_PREFIXED_DQ;\n+\n+      else\n+\treturn NON_PREFIXED_DEFAULT;\n+    }\n+\n+  /* Altivec registers use DS-mode for scalars, and DQ-mode for vectors, IEEE\n+     128-bit floating point, and 128-bit integers.  */\n+  else if (ALTIVEC_REGNO_P (r))\n+    {\n+      if (mode == SFmode || size == 8 || FLOAT128_2REG_P (mode))\n+\treturn NON_PREFIXED_DS;\n+\n+      else if (size < 8)\n+\treturn NON_PREFIXED_X;\n+\n+      else if (TARGET_VSX && size >= 16\n+\t       && (VECTOR_MODE_P (mode)\n+\t\t   || FLOAT128_VECTOR_P (mode)\n+\t\t   || mode == TImode || mode == CTImode))\n+\treturn NON_PREFIXED_DQ;\n+\n+      else\n+\treturn NON_PREFIXED_DEFAULT;\n+    }\n+\n+  /* GPR registers use DS-mode for 64-bit items on 64-bit systems, and D-mode\n+     otherwise.  Assume that any other register, such as LR, CRs, etc. will go\n+     through the GPR registers for memory operations.  */\n+  else if (TARGET_POWERPC64 && size >= 8)\n+    return NON_PREFIXED_DS;\n+\n+  return NON_PREFIXED_D;\n+}\n+\n+\f\n+/* Whether a load instruction is a prefixed instruction.  This is called from\n+   the prefixed attribute processing.  */\n+\n+bool\n+prefixed_load_p (rtx_insn *insn)\n+{\n+  /* Validate the insn to make sure it is a normal load insn.  */\n+  extract_insn_cached (insn);\n+  if (recog_data.n_operands < 2)\n+    return false;\n+\n+  rtx reg = recog_data.operand[0];\n+  rtx mem = recog_data.operand[1];\n+\n+  if (!REG_P (reg) && !SUBREG_P (reg))\n+    return false;\n+\n+  if (!MEM_P (mem))\n+    return false;\n+\n+  /* Prefixed load instructions do not support update or indexed forms.  */\n+  if (get_attr_indexed (insn) == INDEXED_YES\n+      || get_attr_update (insn) == UPDATE_YES)\n+    return false;\n+\n+  /* LWA uses the DS format instead of the D format that LWZ uses.  */\n+  enum non_prefixed_form non_prefixed;\n+  machine_mode reg_mode = GET_MODE (reg);\n+  machine_mode mem_mode = GET_MODE (mem);\n+\n+  if (mem_mode == SImode && reg_mode == DImode\n+      && get_attr_sign_extend (insn) == SIGN_EXTEND_YES)\n+    non_prefixed = NON_PREFIXED_DS;\n+\n+  else\n+    non_prefixed = reg_to_non_prefixed (reg, mem_mode);\n+\n+  return address_is_prefixed (XEXP (mem, 0), mem_mode, non_prefixed);\n+}\n+\n+/* Whether a store instruction is a prefixed instruction.  This is called from\n+   the prefixed attribute processing.  */\n+\n+bool\n+prefixed_store_p (rtx_insn *insn)\n+{\n+  /* Validate the insn to make sure it is a normal store insn.  */\n+  extract_insn_cached (insn);\n+  if (recog_data.n_operands < 2)\n+    return false;\n+\n+  rtx mem = recog_data.operand[0];\n+  rtx reg = recog_data.operand[1];\n+\n+  if (!REG_P (reg) && !SUBREG_P (reg))\n+    return false;\n+\n+  if (!MEM_P (mem))\n+    return false;\n+\n+  /* Prefixed store instructions do not support update or indexed forms.  */\n+  if (get_attr_indexed (insn) == INDEXED_YES\n+      || get_attr_update (insn) == UPDATE_YES)\n+    return false;\n+\n+  machine_mode mem_mode = GET_MODE (mem);\n+  enum non_prefixed_form non_prefixed = reg_to_non_prefixed (reg, mem_mode);\n+  return address_is_prefixed (XEXP (mem, 0), mem_mode, non_prefixed);\n+}\n+\n+/* Whether a load immediate or add instruction is a prefixed instruction.  This\n+   is called from the prefixed attribute processing.  */\n+\n+bool\n+prefixed_paddi_p (rtx_insn *insn)\n+{\n+  rtx set = single_set (insn);\n+  if (!set)\n+    return false;\n+\n+  rtx dest = SET_DEST (set);\n+  rtx src = SET_SRC (set);\n+\n+  if (!REG_P (dest) && !SUBREG_P (dest))\n+    return false;\n+\n+  /* Is this a load immediate that can't be done with a simple ADDI or\n+     ADDIS?  */\n+  if (CONST_INT_P (src))\n+    return (satisfies_constraint_eI (src)\n+\t    && !satisfies_constraint_I (src)\n+\t    && !satisfies_constraint_L (src));\n+\n+  /* Is this a PADDI instruction that can't be done with a simple ADDI or\n+     ADDIS?  */\n+  if (GET_CODE (src) == PLUS)\n+    {\n+      rtx op1 = XEXP (src, 1);\n+\n+      return (CONST_INT_P (op1)\n+\t      && satisfies_constraint_eI (op1)\n+\t      && !satisfies_constraint_I (op1)\n+\t      && !satisfies_constraint_L (op1));\n+    }\n+\n+  /* If not, is it a load of a PC-relative address?  */\n+  if (!TARGET_PCREL || GET_MODE (dest) != Pmode)\n+    return false;\n+\n+  if (!SYMBOL_REF_P (src) && !LABEL_REF_P (src) && GET_CODE (src) != CONST)\n+    return false;\n+\n+  enum insn_form iform = address_to_insn_form (src, Pmode,\n+\t\t\t\t\t       NON_PREFIXED_DEFAULT);\n+\n+  return (iform == INSN_FORM_PCREL_EXTERNAL || iform == INSN_FORM_PCREL_LOCAL);\n+}\n+\n+/* Whether the next instruction needs a 'p' prefix issued before the\n+   instruction is printed out.  */\n+static bool next_insn_prefixed_p;\n+\n+/* Define FINAL_PRESCAN_INSN if some processing needs to be done before\n+   outputting the assembler code.  On the PowerPC, we remember if the current\n+   insn is a prefixed insn where we need to emit a 'p' before the insn.\n+\n+   In addition, if the insn is part of a PC-relative reference to an external\n+   label optimization, this is recorded also.  */\n+void\n+rs6000_final_prescan_insn (rtx_insn *insn, rtx [], int)\n+{\n+  next_insn_prefixed_p = (get_attr_prefixed (insn) != PREFIXED_NO);\n+  return;\n+}\n+\n+/* Define ASM_OUTPUT_OPCODE to do anything special before emitting an opcode.\n+   We use it to emit a 'p' for prefixed insns that is set in\n+   FINAL_PRESCAN_INSN.  */\n+void\n+rs6000_asm_output_opcode (FILE *stream)\n+{\n+  if (next_insn_prefixed_p)\n+    fprintf (stream, \"p\");\n+\n+  return;\n+}\n+\n+\f\n #ifdef HAVE_GAS_HIDDEN\n # define USE_HIDDEN_LINKONCE 1\n #else"}, {"sha": "0156448f57237fd6ac94d8ac017ef9532c1f74d6", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26ca7d1b24478324969eae0d171ad698926c8541/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26ca7d1b24478324969eae0d171ad698926c8541/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=26ca7d1b24478324969eae0d171ad698926c8541", "patch": "@@ -2547,3 +2547,24 @@ typedef struct GTY(()) machine_function\n   IN_RANGE ((VALUE),\t\t\t\t\t\t\t\\\n \t    -(HOST_WIDE_INT_1 << 33),\t\t\t\t\t\\\n \t    (HOST_WIDE_INT_1 << 33) - 1 - (EXTRA))\n+\n+/* Define this if some processing needs to be done before outputting the\n+   assembler code.  On the PowerPC, we remember if the current insn is a normal\n+   prefixed insn where we need to emit a 'p' before the insn.  */\n+#define FINAL_PRESCAN_INSN(INSN, OPERANDS, NOPERANDS)\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (TARGET_PREFIXED_ADDR)\t\t\t\t\t\t\\\n+      rs6000_final_prescan_insn (INSN, OPERANDS, NOPERANDS);\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+/* Do anything special before emitting an opcode.  We use it to emit a 'p' for\n+   prefixed insns that is set in FINAL_PRESCAN_INSN.  */\n+#define ASM_OUTPUT_OPCODE(STREAM, OPCODE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+     if (TARGET_PREFIXED_ADDR)\t\t\t\t\t\t\\\n+       rs6000_asm_output_opcode (STREAM);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)"}, {"sha": "4f27f13772bdba570bfa7b03e7532b7fcaabbd7e", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 78, "deletions": 6, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26ca7d1b24478324969eae0d171ad698926c8541/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26ca7d1b24478324969eae0d171ad698926c8541/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=26ca7d1b24478324969eae0d171ad698926c8541", "patch": "@@ -256,8 +256,49 @@\n ;; Is copying of this instruction disallowed?\n (define_attr \"cannot_copy\" \"no,yes\" (const_string \"no\"))\n \n-;; Length of the instruction (in bytes).\n-(define_attr \"length\" \"\" (const_int 4))\n+\n+;; Whether an insn is a prefixed insn, and an initial 'p' should be printed\n+;; before the instruction.  A prefixed instruction has a prefix instruction\n+;; word that extends the immediate value of the instructions from 12-16 bits to\n+;; 34 bits.  The macro ASM_OUTPUT_OPCODE emits a leading 'p' for prefixed\n+;; insns.  The default \"length\" attribute will also be adjusted by default to\n+;; be 12 bytes.\n+(define_attr \"prefixed\" \"no,yes\"\n+  (cond [(ior (match_test \"!TARGET_PREFIXED_ADDR\")\n+\t      (match_test \"!NONJUMP_INSN_P (insn)\"))\n+\t (const_string \"no\")\n+\n+\t (eq_attr \"type\" \"load,fpload,vecload\")\n+\t (if_then_else (match_test \"prefixed_load_p (insn)\")\n+\t\t       (const_string \"yes\")\n+\t\t       (const_string \"no\"))\n+\n+\t (eq_attr \"type\" \"store,fpstore,vecstore\")\n+\t (if_then_else (match_test \"prefixed_store_p (insn)\")\n+\t\t       (const_string \"yes\")\n+\t\t       (const_string \"no\"))\n+\n+\t (eq_attr \"type\" \"integer,add\")\n+\t (if_then_else (match_test \"prefixed_paddi_p (insn)\")\n+\t\t       (const_string \"yes\")\n+\t\t       (const_string \"no\"))]\n+\n+\t(const_string \"no\")))\n+\n+;; Length in bytes of instructions that use prefixed addressing and length in\n+;; bytes of instructions that does not use prefixed addressing.  This allows\n+;; both lengths to be defined as constants, and the length attribute can pick\n+;; the size as appropriate.\n+(define_attr \"prefixed_length\" \"\" (const_int 12))\n+(define_attr \"non_prefixed_length\" \"\" (const_int 4))\n+\n+;; Length of the instruction (in bytes).  Prefixed insns are 8 bytes, but the\n+;; assembler might issue need to issue a NOP so that the prefixed instruction\n+;; does not cross a cache boundary, which makes them possibly 12 bytes.\n+(define_attr \"length\" \"\"\n+  (if_then_else (eq_attr \"prefixed\" \"yes\")\n+\t\t(attr \"prefixed_length\")\n+\t\t(attr \"non_prefixed_length\")))\n \n ;; Processor type -- this attribute must exactly match the processor_type\n ;; enumeration in rs6000-opts.h.\n@@ -7713,9 +7754,18 @@\n ;; not swapped like they are for TImode or TFmode.  Subregs therefore are\n ;; problematical.  Don't allow direct move for this case.\n \n+;;\t\tFPR load    FPR store   FPR move    FPR zero    GPR load\n+;;\t\tGPR zero    GPR store   GPR move    MFVSRD      MTVSRD\n+\n (define_insn_and_split \"*mov<mode>_64bit_dm\"\n-  [(set (match_operand:FMOVE128_FPR 0 \"nonimmediate_operand\" \"=m,d,d,d,Y,r,r,r,d\")\n-\t(match_operand:FMOVE128_FPR 1 \"input_operand\" \"d,m,d,<zero_fp>,r,<zero_fp>Y,r,d,r\"))]\n+  [(set (match_operand:FMOVE128_FPR 0 \"nonimmediate_operand\"\n+\t\t\"=m,        d,          d,          d,          Y,\n+\t\t r,         r,          r,          r,          d\")\n+\n+\t(match_operand:FMOVE128_FPR 1 \"input_operand\"\n+\t\t\"d,         m,          d,          <zero_fp>,  r,\n+\t\t <zero_fp>, Y,          r,          d,          r\"))]\n+\n   \"TARGET_HARD_FLOAT && TARGET_POWERPC64 && FLOAT128_2REG_P (<MODE>mode)\n    && (<MODE>mode != TDmode || WORDS_BIG_ENDIAN)\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n@@ -7724,8 +7774,8 @@\n   \"&& reload_completed\"\n   [(pc)]\n { rs6000_split_multireg_move (operands[0], operands[1]); DONE; }\n-  [(set_attr \"length\" \"8,8,8,8,12,12,8,8,8\")\n-   (set_attr \"isa\" \"*,*,*,*,*,*,*,p8v,p8v\")])\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"isa\" \"*,*,*,*,*,*,*,*,p8v,p8v\")])\n \n (define_insn_and_split \"*movtd_64bit_nodm\"\n   [(set (match_operand:TD 0 \"nonimmediate_operand\" \"=m,d,d,Y,r,r\")\n@@ -9874,6 +9924,28 @@\n   operands[6] = gen_rtx_PARALLEL (VOIDmode, p);\n })\n \f\n+;; Load up a PC-relative address.  Print_operand_address will append a @pcrel\n+;; to the symbol or label.\n+(define_insn \"*pcrel_local_addr\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(match_operand:DI 1 \"pcrel_local_address\"))]\n+  \"TARGET_PCREL\"\n+  \"la %0,%a1\"\n+  [(set_attr \"prefixed\" \"yes\")])\n+\n+;; Load up a PC-relative address to an external symbol.  If the symbol and the\n+;; program are both defined in the main program, the linker will optimize this\n+;; to a PADDI.  Otherwise, it will create a GOT address that is relocated by\n+;; the dynamic linker and loaded up.  Print_operand_address will append a\n+;; @got@pcrel to the symbol.\n+(define_insn \"*pcrel_extern_addr\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(match_operand:DI 1 \"pcrel_external_address\"))]\n+  \"TARGET_PCREL\"\n+  \"ld %0,%a1\"\n+  [(set_attr \"prefixed\" \"yes\")\n+   (set_attr \"type\" \"load\")])\n+\n ;; TOC register handling.\n \n ;; Code to initialize the TOC register..."}]}