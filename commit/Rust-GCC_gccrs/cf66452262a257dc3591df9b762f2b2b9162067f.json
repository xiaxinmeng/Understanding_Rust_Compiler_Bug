{"sha": "cf66452262a257dc3591df9b762f2b2b9162067f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y2NjQ1MjI2MmEyNTdkYzM1OTFkZjliNzYyZjJiMmI5MTYyMDY3Zg==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2013-08-23T16:06:44Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2013-08-23T16:06:44Z"}, "message": "trans-array.c (gfc_conv_section_startstride): Move &loop->pre access to the callers.\n\n2013-08-23  Mikael Morin  <mikael@gcc.gnu.org>\n\n\t* trans-array.c (gfc_conv_section_startstride): Move &loop->pre access\n\tto the callers.\n\t(gfc_conv_ss_startstride, gfc_conv_expr_descriptor): Update callers.\n\nFrom-SVN: r201945", "tree": {"sha": "284a56059231a897a6f3e258187a38e5fc4f50f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/284a56059231a897a6f3e258187a38e5fc4f50f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf66452262a257dc3591df9b762f2b2b9162067f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf66452262a257dc3591df9b762f2b2b9162067f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf66452262a257dc3591df9b762f2b2b9162067f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf66452262a257dc3591df9b762f2b2b9162067f/comments", "author": null, "committer": null, "parents": [{"sha": "64cbf23d1f42c3ac9e545077868c6b669c1b5b5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64cbf23d1f42c3ac9e545077868c6b669c1b5b5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64cbf23d1f42c3ac9e545077868c6b669c1b5b5c"}], "stats": {"total": 22, "additions": 14, "deletions": 8}, "files": [{"sha": "122f6c689c960ab336c722175bbb762a213e3339", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf66452262a257dc3591df9b762f2b2b9162067f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf66452262a257dc3591df9b762f2b2b9162067f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=cf66452262a257dc3591df9b762f2b2b9162067f", "patch": "@@ -1,3 +1,9 @@\n+2013-08-23  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* trans-array.c (gfc_conv_section_startstride): Move &loop->pre access\n+\tto the callers.\n+\t(gfc_conv_ss_startstride, gfc_conv_expr_descriptor): Update callers.\n+\n 2013-08-22  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/58185"}, {"sha": "a626d66b7d8f221dd27f9d2ebbd791082a8441d6", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf66452262a257dc3591df9b762f2b2b9162067f/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf66452262a257dc3591df9b762f2b2b9162067f/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=cf66452262a257dc3591df9b762f2b2b9162067f", "patch": "@@ -3715,7 +3715,7 @@ evaluate_bound (stmtblock_t *block, tree *bounds, gfc_expr ** values,\n /* Calculate the lower bound of an array section.  */\n \n static void\n-gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int dim)\n+gfc_conv_section_startstride (stmtblock_t * block, gfc_ss * ss, int dim)\n {\n   gfc_expr *stride = NULL;\n   tree desc;\n@@ -3744,12 +3744,12 @@ gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int dim)\n \n   /* Calculate the start of the range.  For vector subscripts this will\n      be the range of the vector.  */\n-  evaluate_bound (&loop->pre, info->start, ar->start, desc, dim, true);\n+  evaluate_bound (block, info->start, ar->start, desc, dim, true);\n \n   /* Similarly calculate the end.  Although this is not used in the\n      scalarizer, it is needed when checking bounds and where the end\n      is an expression with side-effects.  */\n-  evaluate_bound (&loop->pre, info->end, ar->end, desc, dim, false);\n+  evaluate_bound (block, info->end, ar->end, desc, dim, false);\n \n   /* Calculate the stride.  */\n   if (stride == NULL)\n@@ -3758,8 +3758,8 @@ gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int dim)\n     {\n       gfc_init_se (&se, NULL);\n       gfc_conv_expr_type (&se, stride, gfc_array_index_type);\n-      gfc_add_block_to_block (&loop->pre, &se.pre);\n-      info->stride[dim] = gfc_evaluate_now (se.expr, &loop->pre);\n+      gfc_add_block_to_block (block, &se.pre);\n+      info->stride[dim] = gfc_evaluate_now (se.expr, block);\n     }\n }\n \n@@ -3838,7 +3838,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t    gfc_conv_ss_descriptor (&loop->pre, ss, !loop->array_parameter);\n \n \t  for (n = 0; n < ss->dimen; n++)\n-\t    gfc_conv_section_startstride (loop, ss, ss->dim[n]);\n+\t    gfc_conv_section_startstride (&loop->pre, ss, ss->dim[n]);\n \t  break;\n \n \tcase GFC_SS_INTRINSIC:\n@@ -6727,10 +6727,10 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t      gcc_assert (ar->dimen_type[n + ndim] == DIMEN_THIS_IMAGE);\n \n \t      /* Make sure the call to gfc_conv_section_startstride won't\n-\t         generate unnecessary code to calculate stride.  */\n+\t\t generate unnecessary code to calculate stride.  */\n \t      gcc_assert (ar->stride[n + ndim] == NULL);\n \n-\t      gfc_conv_section_startstride (&loop, ss, n + ndim);\n+\t      gfc_conv_section_startstride (&loop.pre, ss, n + ndim);\n \t      loop.from[n + loop.dimen] = info->start[n + ndim];\n \t      loop.to[n + loop.dimen]   = info->end[n + ndim];\n \t    }"}]}