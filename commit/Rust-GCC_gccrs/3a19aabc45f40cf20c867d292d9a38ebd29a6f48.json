{"sha": "3a19aabc45f40cf20c867d292d9a38ebd29a6f48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ExOWFhYmM0NWY0MGNmMjBjODY3ZDI5MmQ5YTM4ZWJkMjlhNmY0OA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-01-22T21:50:41Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-01-22T21:50:41Z"}, "message": "(if_then_else_cond): Don't do anything with COMPARE.\n\n(simplify_comparison): Strip SIGN_EXTEND, NOT, or NEG when both operands\nhave it.\n\nFrom-SVN: r6404", "tree": {"sha": "b900aaa5b638bedc4048a12be8673cf4d460eaeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b900aaa5b638bedc4048a12be8673cf4d460eaeb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a19aabc45f40cf20c867d292d9a38ebd29a6f48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a19aabc45f40cf20c867d292d9a38ebd29a6f48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a19aabc45f40cf20c867d292d9a38ebd29a6f48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a19aabc45f40cf20c867d292d9a38ebd29a6f48/comments", "author": null, "committer": null, "parents": [{"sha": "0c314d1ab0636a2253dfc8b4f9f50010210556dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c314d1ab0636a2253dfc8b4f9f50010210556dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c314d1ab0636a2253dfc8b4f9f50010210556dc"}], "stats": {"total": 69, "additions": 56, "deletions": 13}, "files": [{"sha": "583be741ca0fb19c276d79ad9bd6d05f9c3ee437", "filename": "gcc/combine.c", "status": "modified", "additions": 56, "deletions": 13, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a19aabc45f40cf20c867d292d9a38ebd29a6f48/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a19aabc45f40cf20c867d292d9a38ebd29a6f48/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=3a19aabc45f40cf20c867d292d9a38ebd29a6f48", "patch": "@@ -6067,6 +6067,11 @@ if_then_else_cond (x, ptrue, pfalse)\n       return cond0;\n     }\n \n+  /* If this is a COMPARE, do nothing, since the IF_THEN_ELSE we would\n+     make can't possibly match and would supress other optimizations.  */\n+  else if (code == COMPARE)\n+    ;\n+\n   /* If this is a binary operation, see if either side has only one of two\n      values.  If either one does or if both do and they are conditional on\n      the same value, compute the new true and false values.  */\n@@ -8414,23 +8419,53 @@ simplify_comparison (code, pop0, pop1)\n   /* Try a few ways of applying the same transformation to both operands.  */\n   while (1)\n     {\n+#ifndef WORD_REGISTER_OPERATIONS\n+      /* The test below this one won't handle SIGN_EXTENDs on these machines,\n+\t so check specially.  */\n+      if (code != GTU && code != GEU && code != LTU && code != LEU\n+\t  && GET_CODE (op0) == ASHIFTRT && GET_CODE (op1) == ASHIFTRT\n+\t  && GET_CODE (XEXP (op0, 0)) == ASHIFT\n+\t  && GET_CODE (XEXP (op1, 0)) == ASHIFT\n+\t  && GET_CODE (XEXP (XEXP (op0, 0), 0)) == SUBREG\n+\t  && GET_CODE (XEXP (XEXP (op1, 0), 0)) == SUBREG\n+\t  && (GET_MODE (SUBREG_REG (XEXP (XEXP (op0, 0), 0)))\n+\t      == GET_MODE (SUBREG_REG (XEXP (XEXP (op0, 0), 0))))\n+\t  && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t  && GET_CODE (XEXP (op1, 1)) == CONST_INT\n+\t  && GET_CODE (XEXP (XEXP (op0, 0), 1)) == CONST_INT\n+\t  && GET_CODE (XEXP (XEXP (op1, 0), 1)) == CONST_INT\n+\t  && INTVAL (XEXP (op0, 1)) == INTVAL (XEXP (op1, 1))\n+\t  && INTVAL (XEXP (op0, 1)) == INTVAL (XEXP (XEXP (op0, 0), 1))\n+\t  && INTVAL (XEXP (op0, 1)) == INTVAL (XEXP (XEXP (op1, 0), 1))\n+\t  && (INTVAL (XEXP (op0, 1))\n+\t      == (GET_MODE_BITSIZE (GET_MODE (op0))\n+\t\t  - (GET_MODE_BITSIZE\n+\t\t     (GET_MODE (SUBREG_REG (XEXP (XEXP (op0, 0), 0))))))))\n+\t{\n+\t  op0 = SUBREG_REG (XEXP (XEXP (op0, 0), 0));\n+\t  op1 = SUBREG_REG (XEXP (XEXP (op1, 0), 0));\n+\t}\n+#endif\n+\n       /* If both operands are the same constant shift, see if we can ignore the\n \t shift.  We can if the shift is a rotate or if the bits shifted out of\n \t this shift are known to be zero for both inputs and if the type of\n \t comparison is compatible with the shift.  */\n-      if (GET_CODE (op0) == GET_CODE (op1)\n-\t  && GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_WIDE_INT\n-\t  && ((GET_CODE (op0) == ROTATE && (code == NE || code == EQ))\n-\t      || ((GET_CODE (op0) == LSHIFTRT\n-\t\t   || GET_CODE (op0) == ASHIFT || GET_CODE (op0) == LSHIFT)\n-\t\t  && (code != GT && code != LT && code != GE && code != LE))\n-\t      || (GET_CODE (op0) == ASHIFTRT\n-\t\t  && (code != GTU && code != LTU\n-\t\t      && code != GEU && code != GEU)))\n-\t  && GET_CODE (XEXP (op0, 1)) == CONST_INT\n-\t  && INTVAL (XEXP (op0, 1)) >= 0\n-\t  && INTVAL (XEXP (op0, 1)) < HOST_BITS_PER_WIDE_INT\n-\t  && XEXP (op0, 1) == XEXP (op1, 1))\n+      else if (GET_CODE (op0) == GET_CODE (op1)\n+\t       && GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_WIDE_INT\n+\t       && ((GET_CODE (op0) == ROTATE && (code == NE || code == EQ))\n+\t\t   || ((GET_CODE (op0) == LSHIFTRT\n+\t\t\t|| GET_CODE (op0) == ASHIFT\n+\t\t\t|| GET_CODE (op0) == LSHIFT)\n+\t\t       && (code != GT && code != LT\n+\t\t\t   && code != GE && code != LE))\n+\t\t   || (GET_CODE (op0) == ASHIFTRT\n+\t\t       && (code != GTU && code != LTU\n+\t\t\t   && code != GEU && code != GEU)))\n+\t       && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t       && INTVAL (XEXP (op0, 1)) >= 0\n+\t       && INTVAL (XEXP (op0, 1)) < HOST_BITS_PER_WIDE_INT\n+\t       && XEXP (op0, 1) == XEXP (op1, 1))\n \t{\n \t  enum machine_mode mode = GET_MODE (op0);\n \t  unsigned HOST_WIDE_INT mask = GET_MODE_MASK (mode);\n@@ -8482,6 +8517,14 @@ simplify_comparison (code, pop0, pop1)\n \t     the original sign bit. */\n \t  code = unsigned_condition (code);\n \t}\n+\n+      /* If both operands are NOT or both are NEG, we can strip off the\n+\t outer operation if this is just an equality comparison.  */\n+      else if ((code == EQ || code == NE)\n+\t       && ((GET_CODE (op0) == NOT && GET_CODE (op1) == NOT)\n+\t\t   || (GET_CODE (op0) == NEG && GET_CODE (op1) == NEG)))\n+\top0 = XEXP (op0, 0), op1 = XEXP (op1, 0);\n+\n       else\n \tbreak;\n     }"}]}