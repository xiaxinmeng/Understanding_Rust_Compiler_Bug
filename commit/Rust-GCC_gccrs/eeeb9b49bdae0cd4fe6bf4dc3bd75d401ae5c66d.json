{"sha": "eeeb9b49bdae0cd4fe6bf4dc3bd75d401ae5c66d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVlYjliNDliZGFlMGNkNGZlNmJmNGRjM2JkNzVkNDAxYWU1YzY2ZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-06-01T16:09:28Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-06-01T16:09:28Z"}, "message": "dwarf2out.c (compare_loc_descriptor, [...]): New functions.\n\n\t* dwarf2out.c (compare_loc_descriptor, scompare_loc_descriptor,\n\tucompare_loc_descriptor, minmax_loc_descriptor, clz_loc_descriptor,\n\tpopcount_loc_descriptor, bswap_loc_descriptor, rotate_loc_descriptor):\n\tNew functions.\n\t(mem_loc_descriptor): Use them.\n\nFrom-SVN: r174535", "tree": {"sha": "9bd8dfee4c01cc5891cfca429fbd51e8151f04ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bd8dfee4c01cc5891cfca429fbd51e8151f04ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eeeb9b49bdae0cd4fe6bf4dc3bd75d401ae5c66d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eeeb9b49bdae0cd4fe6bf4dc3bd75d401ae5c66d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eeeb9b49bdae0cd4fe6bf4dc3bd75d401ae5c66d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eeeb9b49bdae0cd4fe6bf4dc3bd75d401ae5c66d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ebdc0d4b15c424a4a953024a71598d16bf503ea7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebdc0d4b15c424a4a953024a71598d16bf503ea7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebdc0d4b15c424a4a953024a71598d16bf503ea7"}], "stats": {"total": 1253, "additions": 651, "deletions": 602}, "files": [{"sha": "9b969a76bf5667f3ec95044c04eb56790bf28b7e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeeb9b49bdae0cd4fe6bf4dc3bd75d401ae5c66d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeeb9b49bdae0cd4fe6bf4dc3bd75d401ae5c66d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eeeb9b49bdae0cd4fe6bf4dc3bd75d401ae5c66d", "patch": "@@ -1,5 +1,11 @@\n 2011-06-01  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* dwarf2out.c (compare_loc_descriptor, scompare_loc_descriptor,\n+\tucompare_loc_descriptor, minmax_loc_descriptor, clz_loc_descriptor,\n+\tpopcount_loc_descriptor, bswap_loc_descriptor, rotate_loc_descriptor):\n+\tNew functions.\n+\t(mem_loc_descriptor): Use them.\n+\n \t* var-tracking.c (create_entry_value): New function.\n \t(vt_add_function_parameter): Use it.\n "}, {"sha": "b3cf4a65730cb2ed3052a99bb3f0b4326fbc9cf4", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 645, "deletions": 602, "changes": 1247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeeb9b49bdae0cd4fe6bf4dc3bd75d401ae5c66d/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeeb9b49bdae0cd4fe6bf4dc3bd75d401ae5c66d/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=eeeb9b49bdae0cd4fe6bf4dc3bd75d401ae5c66d", "patch": "@@ -13855,6 +13855,627 @@ convert_descriptor_to_signed (enum machine_mode mode, dw_loc_descr_ref op)\n   return op;\n }\n \n+/* Return location descriptor for comparison OP with operands OP0 and OP1.  */\n+\n+static dw_loc_descr_ref\n+compare_loc_descriptor (enum dwarf_location_atom op, dw_loc_descr_ref op0,\n+\t\t\tdw_loc_descr_ref op1)\n+{\n+  dw_loc_descr_ref ret = op0;\n+  add_loc_descr (&ret, op1);\n+  add_loc_descr (&ret, new_loc_descr (op, 0, 0));\n+  if (STORE_FLAG_VALUE != 1)\n+    {\n+      add_loc_descr (&ret, int_loc_descriptor (STORE_FLAG_VALUE));\n+      add_loc_descr (&ret, new_loc_descr (DW_OP_mul, 0, 0));\n+    }\n+  return ret;\n+}\n+\n+/* Return location descriptor for signed comparison OP RTL.  */\n+\n+static dw_loc_descr_ref\n+scompare_loc_descriptor (enum dwarf_location_atom op, rtx rtl,\n+\t\t\t enum machine_mode mem_mode)\n+{\n+  enum machine_mode op_mode = GET_MODE (XEXP (rtl, 0));\n+  dw_loc_descr_ref op0, op1;\n+  int shift;\n+\n+  if (op_mode == VOIDmode)\n+    op_mode = GET_MODE (XEXP (rtl, 1));\n+  if (op_mode == VOIDmode)\n+    return NULL;\n+\n+  if (dwarf_strict\n+      && (GET_MODE_CLASS (op_mode) != MODE_INT\n+\t  || GET_MODE_SIZE (op_mode) > DWARF2_ADDR_SIZE))\n+    return NULL;\n+\n+  op0 = mem_loc_descriptor (XEXP (rtl, 0), op_mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+  op1 = mem_loc_descriptor (XEXP (rtl, 1), op_mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\n+  if (op0 == NULL || op1 == NULL)\n+    return NULL;\n+\n+  if (GET_MODE_CLASS (op_mode) != MODE_INT\n+      || GET_MODE_SIZE (op_mode) >= DWARF2_ADDR_SIZE)\n+    return compare_loc_descriptor (op, op0, op1);\n+\n+  shift = (DWARF2_ADDR_SIZE - GET_MODE_SIZE (op_mode)) * BITS_PER_UNIT;\n+  /* For eq/ne, if the operands are known to be zero-extended,\n+     there is no need to do the fancy shifting up.  */\n+  if (op == DW_OP_eq || op == DW_OP_ne)\n+    {\n+      dw_loc_descr_ref last0, last1;\n+      for (last0 = op0; last0->dw_loc_next != NULL; last0 = last0->dw_loc_next)\n+\t;\n+      for (last1 = op1; last1->dw_loc_next != NULL; last1 = last1->dw_loc_next)\n+\t;\n+      /* deref_size zero extends, and for constants we can check\n+\t whether they are zero extended or not.  */\n+      if (((last0->dw_loc_opc == DW_OP_deref_size\n+\t    && last0->dw_loc_oprnd1.v.val_int <= GET_MODE_SIZE (op_mode))\n+\t   || (CONST_INT_P (XEXP (rtl, 0))\n+\t       && (unsigned HOST_WIDE_INT) INTVAL (XEXP (rtl, 0))\n+\t\t  == (INTVAL (XEXP (rtl, 0)) & GET_MODE_MASK (op_mode))))\n+\t  && ((last1->dw_loc_opc == DW_OP_deref_size\n+\t       && last1->dw_loc_oprnd1.v.val_int <= GET_MODE_SIZE (op_mode))\n+\t      || (CONST_INT_P (XEXP (rtl, 1))\n+\t\t  && (unsigned HOST_WIDE_INT) INTVAL (XEXP (rtl, 1))\n+\t\t     == (INTVAL (XEXP (rtl, 1)) & GET_MODE_MASK (op_mode)))))\n+\treturn compare_loc_descriptor (op, op0, op1);\n+    }\n+  add_loc_descr (&op0, int_loc_descriptor (shift));\n+  add_loc_descr (&op0, new_loc_descr (DW_OP_shl, 0, 0));\n+  if (CONST_INT_P (XEXP (rtl, 1)))\n+    op1 = int_loc_descriptor (INTVAL (XEXP (rtl, 1)) << shift);\n+  else\n+    {\n+      add_loc_descr (&op1, int_loc_descriptor (shift));\n+      add_loc_descr (&op1, new_loc_descr (DW_OP_shl, 0, 0));\n+    }\n+  return compare_loc_descriptor (op, op0, op1);\n+}\n+\n+/* Return location descriptor for unsigned comparison OP RTL.  */\n+\n+static dw_loc_descr_ref\n+ucompare_loc_descriptor (enum dwarf_location_atom op, rtx rtl,\n+\t\t\t enum machine_mode mem_mode)\n+{\n+  enum machine_mode op_mode = GET_MODE (XEXP (rtl, 0));\n+  dw_loc_descr_ref op0, op1;\n+\n+  if (op_mode == VOIDmode)\n+    op_mode = GET_MODE (XEXP (rtl, 1));\n+  if (op_mode == VOIDmode)\n+    return NULL;\n+  if (GET_MODE_CLASS (op_mode) != MODE_INT)\n+    return NULL;\n+\n+  if (dwarf_strict && GET_MODE_SIZE (op_mode) > DWARF2_ADDR_SIZE)\n+    return NULL;\n+\n+  if (op_mode != VOIDmode && GET_MODE_CLASS (op_mode) != MODE_INT)\n+    return NULL;\n+\n+  op0 = mem_loc_descriptor (XEXP (rtl, 0), op_mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+  op1 = mem_loc_descriptor (XEXP (rtl, 1), op_mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\n+  if (op0 == NULL || op1 == NULL)\n+    return NULL;\n+\n+  if (GET_MODE_SIZE (op_mode) < DWARF2_ADDR_SIZE)\n+    {\n+      HOST_WIDE_INT mask = GET_MODE_MASK (op_mode);\n+      dw_loc_descr_ref last0, last1;\n+      for (last0 = op0; last0->dw_loc_next != NULL; last0 = last0->dw_loc_next)\n+\t;\n+      for (last1 = op1; last1->dw_loc_next != NULL; last1 = last1->dw_loc_next)\n+\t;\n+      if (CONST_INT_P (XEXP (rtl, 0)))\n+\top0 = int_loc_descriptor (INTVAL (XEXP (rtl, 0)) & mask);\n+      /* deref_size zero extends, so no need to mask it again.  */\n+      else if (last0->dw_loc_opc != DW_OP_deref_size\n+\t       || last0->dw_loc_oprnd1.v.val_int > GET_MODE_SIZE (op_mode))\n+\t{\n+\t  add_loc_descr (&op0, int_loc_descriptor (mask));\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_and, 0, 0));\n+\t}\n+      if (CONST_INT_P (XEXP (rtl, 1)))\n+\top1 = int_loc_descriptor (INTVAL (XEXP (rtl, 1)) & mask);\n+      /* deref_size zero extends, so no need to mask it again.  */\n+      else if (last1->dw_loc_opc != DW_OP_deref_size\n+\t       || last1->dw_loc_oprnd1.v.val_int > GET_MODE_SIZE (op_mode))\n+\t{\n+\t  add_loc_descr (&op1, int_loc_descriptor (mask));\n+\t  add_loc_descr (&op1, new_loc_descr (DW_OP_and, 0, 0));\n+\t}\n+    }\n+  else if (GET_MODE_SIZE (op_mode) == DWARF2_ADDR_SIZE)\n+    {\n+      HOST_WIDE_INT bias = 1;\n+      bias <<= (DWARF2_ADDR_SIZE * BITS_PER_UNIT - 1);\n+      add_loc_descr (&op0, new_loc_descr (DW_OP_plus_uconst, bias, 0));\n+      if (CONST_INT_P (XEXP (rtl, 1)))\n+\top1 = int_loc_descriptor ((unsigned HOST_WIDE_INT) bias\n+\t\t\t\t  + INTVAL (XEXP (rtl, 1)));\n+      else\n+\tadd_loc_descr (&op1, new_loc_descr (DW_OP_plus_uconst,\n+\t\t\t\t\t    bias, 0));\n+    }\n+  else\n+    {\n+      dw_die_ref type_die = base_type_for_mode (op_mode, 1);\n+      dw_loc_descr_ref cvt;\n+\n+      if (type_die == NULL)\n+\treturn NULL;\n+      cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+      cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+      cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+      cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+      add_loc_descr (&op0, cvt);\n+      cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+      cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+      cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+      cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+      add_loc_descr (&op1, cvt);\n+    }\n+  return compare_loc_descriptor (op, op0, op1);\n+}\n+\n+/* Return location descriptor for {U,S}{MIN,MAX}.  */\n+\n+static dw_loc_descr_ref\n+minmax_loc_descriptor (rtx rtl, enum machine_mode mode,\n+\t\t       enum machine_mode mem_mode)\n+{\n+  enum dwarf_location_atom op;\n+  dw_loc_descr_ref op0, op1, ret;\n+  dw_loc_descr_ref bra_node, drop_node;\n+\n+  if (dwarf_strict\n+      && (GET_MODE_CLASS (mode) != MODE_INT\n+\t  || GET_MODE_SIZE (mode) > DWARF2_ADDR_SIZE))\n+    return NULL;\n+\n+  op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+  op1 = mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\n+  if (op0 == NULL || op1 == NULL)\n+    return NULL;\n+\n+  add_loc_descr (&op0, new_loc_descr (DW_OP_dup, 0, 0));\n+  add_loc_descr (&op1, new_loc_descr (DW_OP_swap, 0, 0));\n+  add_loc_descr (&op1, new_loc_descr (DW_OP_over, 0, 0));\n+  if (GET_CODE (rtl) == UMIN || GET_CODE (rtl) == UMAX)\n+    {\n+      if (GET_MODE_SIZE (mode) < DWARF2_ADDR_SIZE)\n+\t{\n+\t  HOST_WIDE_INT mask = GET_MODE_MASK (mode);\n+\t  add_loc_descr (&op0, int_loc_descriptor (mask));\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_and, 0, 0));\n+\t  add_loc_descr (&op1, int_loc_descriptor (mask));\n+\t  add_loc_descr (&op1, new_loc_descr (DW_OP_and, 0, 0));\n+\t}\n+      else if (GET_MODE_SIZE (mode) == DWARF2_ADDR_SIZE)\n+\t{\n+\t  HOST_WIDE_INT bias = 1;\n+\t  bias <<= (DWARF2_ADDR_SIZE * BITS_PER_UNIT - 1);\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_plus_uconst, bias, 0));\n+\t  add_loc_descr (&op1, new_loc_descr (DW_OP_plus_uconst, bias, 0));\n+\t}\n+      else\n+\t{\n+\t  dw_die_ref type_die = base_type_for_mode (mode, 1);\n+\t  dw_loc_descr_ref cvt;\n+\t  if (type_die == NULL)\n+\t    return NULL;\n+\t  cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+\t  cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t  cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+\t  cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t  add_loc_descr (&op0, cvt);\n+\t  cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+\t  cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t  cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+\t  cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t  add_loc_descr (&op1, cvt);\n+\t}\n+    }\n+  else if (GET_MODE_CLASS (mode) == MODE_INT\n+\t   && GET_MODE_SIZE (mode) < DWARF2_ADDR_SIZE)\n+    {\n+      int shift = (DWARF2_ADDR_SIZE - GET_MODE_SIZE (mode)) * BITS_PER_UNIT;\n+      add_loc_descr (&op0, int_loc_descriptor (shift));\n+      add_loc_descr (&op0, new_loc_descr (DW_OP_shl, 0, 0));\n+      add_loc_descr (&op1, int_loc_descriptor (shift));\n+      add_loc_descr (&op1, new_loc_descr (DW_OP_shl, 0, 0));\n+    }\n+\n+  if (GET_CODE (rtl) == SMIN || GET_CODE (rtl) == UMIN)\n+    op = DW_OP_lt;\n+  else\n+    op = DW_OP_gt;\n+  ret = op0;\n+  add_loc_descr (&ret, op1);\n+  add_loc_descr (&ret, new_loc_descr (op, 0, 0));\n+  bra_node = new_loc_descr (DW_OP_bra, 0, 0);\n+  add_loc_descr (&ret, bra_node);\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_swap, 0, 0));\n+  drop_node = new_loc_descr (DW_OP_drop, 0, 0);\n+  add_loc_descr (&ret, drop_node);\n+  bra_node->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+  bra_node->dw_loc_oprnd1.v.val_loc = drop_node;\n+  return ret;\n+}\n+\n+/* CLZ (where constV is CLZ_DEFINED_VALUE_AT_ZERO computed value,\n+   const0 is DW_OP_lit0 or corresponding typed constant,\n+   const1 is DW_OP_lit1 or corresponding typed constant\n+   and constMSB is constant with just the MSB bit set\n+   for the mode):\n+       DW_OP_dup DW_OP_bra <L1> DW_OP_drop constV DW_OP_skip <L4>\n+   L1: const0 DW_OP_swap\n+   L2: DW_OP_dup constMSB DW_OP_and DW_OP_bra <L3> const1 DW_OP_shl\n+       DW_OP_swap DW_OP_plus_uconst <1> DW_OP_swap DW_OP_skip <L2>\n+   L3: DW_OP_drop\n+   L4: DW_OP_nop\n+\n+   CTZ is similar:\n+       DW_OP_dup DW_OP_bra <L1> DW_OP_drop constV DW_OP_skip <L4>\n+   L1: const0 DW_OP_swap\n+   L2: DW_OP_dup const1 DW_OP_and DW_OP_bra <L3> const1 DW_OP_shr\n+       DW_OP_swap DW_OP_plus_uconst <1> DW_OP_swap DW_OP_skip <L2>\n+   L3: DW_OP_drop\n+   L4: DW_OP_nop\n+\n+   FFS is similar:\n+       DW_OP_dup DW_OP_bra <L1> DW_OP_drop const0 DW_OP_skip <L4>\n+   L1: const1 DW_OP_swap\n+   L2: DW_OP_dup const1 DW_OP_and DW_OP_bra <L3> const1 DW_OP_shr\n+       DW_OP_swap DW_OP_plus_uconst <1> DW_OP_swap DW_OP_skip <L2>\n+   L3: DW_OP_drop\n+   L4: DW_OP_nop  */\n+\n+static dw_loc_descr_ref\n+clz_loc_descriptor (rtx rtl, enum machine_mode mode,\n+\t\t    enum machine_mode mem_mode)\n+{\n+  dw_loc_descr_ref op0, ret, tmp;\n+  HOST_WIDE_INT valv;\n+  dw_loc_descr_ref l1jump, l1label;\n+  dw_loc_descr_ref l2jump, l2label;\n+  dw_loc_descr_ref l3jump, l3label;\n+  dw_loc_descr_ref l4jump, l4label;\n+  rtx msb;\n+\n+  if (GET_MODE_CLASS (mode) != MODE_INT\n+      || GET_MODE (XEXP (rtl, 0)) != mode\n+      || (GET_CODE (rtl) == CLZ\n+\t  && GET_MODE_BITSIZE (mode) > 2 * HOST_BITS_PER_WIDE_INT))\n+    return NULL;\n+\n+  op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+  if (op0 == NULL)\n+    return NULL;\n+  ret = op0;\n+  if (GET_CODE (rtl) == CLZ)\n+    {\n+      if (!CLZ_DEFINED_VALUE_AT_ZERO (mode, valv))\n+\tvalv = GET_MODE_BITSIZE (mode);\n+    }\n+  else if (GET_CODE (rtl) == FFS)\n+    valv = 0;\n+  else if (!CTZ_DEFINED_VALUE_AT_ZERO (mode, valv))\n+    valv = GET_MODE_BITSIZE (mode);\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_dup, 0, 0));\n+  l1jump = new_loc_descr (DW_OP_bra, 0, 0);\n+  add_loc_descr (&ret, l1jump);\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_drop, 0, 0));\n+  tmp = mem_loc_descriptor (GEN_INT (valv), mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+  if (tmp == NULL)\n+    return NULL;\n+  add_loc_descr (&ret, tmp);\n+  l4jump = new_loc_descr (DW_OP_skip, 0, 0);\n+  add_loc_descr (&ret, l4jump);\n+  l1label = mem_loc_descriptor (GET_CODE (rtl) == FFS\n+\t\t\t\t? const1_rtx : const0_rtx,\n+\t\t\t\tmode, mem_mode,\n+\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+  if (l1label == NULL)\n+    return NULL;\n+  add_loc_descr (&ret, l1label);\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_swap, 0, 0));\n+  l2label = new_loc_descr (DW_OP_dup, 0, 0);\n+  add_loc_descr (&ret, l2label);\n+  if (GET_CODE (rtl) != CLZ)\n+    msb = const1_rtx;\n+  else if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n+    msb = GEN_INT ((unsigned HOST_WIDE_INT) 1\n+\t\t   << (GET_MODE_BITSIZE (mode) - 1));\n+  else\n+    msb = immed_double_const (0, (unsigned HOST_WIDE_INT) 1\n+\t\t\t\t  << (GET_MODE_BITSIZE (mode)\n+\t\t\t\t      - HOST_BITS_PER_WIDE_INT - 1), mode);\n+  if (GET_CODE (msb) == CONST_INT && INTVAL (msb) < 0)\n+    tmp = new_loc_descr (HOST_BITS_PER_WIDE_INT == 32\n+\t\t\t ? DW_OP_const4u : HOST_BITS_PER_WIDE_INT == 64\n+\t\t\t ? DW_OP_const8u : DW_OP_constu, INTVAL (msb), 0);\n+  else\n+    tmp = mem_loc_descriptor (msb, mode, mem_mode,\n+\t\t\t      VAR_INIT_STATUS_INITIALIZED);\n+  if (tmp == NULL)\n+    return NULL;\n+  add_loc_descr (&ret, tmp);\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_and, 0, 0));\n+  l3jump = new_loc_descr (DW_OP_bra, 0, 0);\n+  add_loc_descr (&ret, l3jump);\n+  tmp = mem_loc_descriptor (const1_rtx, mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+  if (tmp == NULL)\n+    return NULL;\n+  add_loc_descr (&ret, tmp);\n+  add_loc_descr (&ret, new_loc_descr (GET_CODE (rtl) == CLZ\n+\t\t\t\t      ? DW_OP_shl : DW_OP_shr, 0, 0));\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_swap, 0, 0));\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_plus_uconst, 1, 0));\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_swap, 0, 0));\n+  l2jump = new_loc_descr (DW_OP_skip, 0, 0);\n+  add_loc_descr (&ret, l2jump);\n+  l3label = new_loc_descr (DW_OP_drop, 0, 0);\n+  add_loc_descr (&ret, l3label);\n+  l4label = new_loc_descr (DW_OP_nop, 0, 0);\n+  add_loc_descr (&ret, l4label);\n+  l1jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+  l1jump->dw_loc_oprnd1.v.val_loc = l1label;\n+  l2jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+  l2jump->dw_loc_oprnd1.v.val_loc = l2label;\n+  l3jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+  l3jump->dw_loc_oprnd1.v.val_loc = l3label;\n+  l4jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+  l4jump->dw_loc_oprnd1.v.val_loc = l4label;\n+  return ret;\n+}\n+\n+/* POPCOUNT (const0 is DW_OP_lit0 or corresponding typed constant,\n+   const1 is DW_OP_lit1 or corresponding typed constant):\n+       const0 DW_OP_swap\n+   L1: DW_OP_dup DW_OP_bra <L2> DW_OP_dup DW_OP_rot const1 DW_OP_and\n+       DW_OP_plus DW_OP_swap const1 DW_OP_shr DW_OP_skip <L1>\n+   L2: DW_OP_drop\n+\n+   PARITY is similar:\n+   L1: DW_OP_dup DW_OP_bra <L2> DW_OP_dup DW_OP_rot const1 DW_OP_and\n+       DW_OP_xor DW_OP_swap const1 DW_OP_shr DW_OP_skip <L1>\n+   L2: DW_OP_drop  */\n+\n+static dw_loc_descr_ref\n+popcount_loc_descriptor (rtx rtl, enum machine_mode mode,\n+\t\t\t enum machine_mode mem_mode)\n+{\n+  dw_loc_descr_ref op0, ret, tmp;\n+  dw_loc_descr_ref l1jump, l1label;\n+  dw_loc_descr_ref l2jump, l2label;\n+\n+  if (GET_MODE_CLASS (mode) != MODE_INT\n+      || GET_MODE (XEXP (rtl, 0)) != mode)\n+    return NULL;\n+\n+  op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+  if (op0 == NULL)\n+    return NULL;\n+  ret = op0;\n+  tmp = mem_loc_descriptor (const0_rtx, mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+  if (tmp == NULL)\n+    return NULL;\n+  add_loc_descr (&ret, tmp);\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_swap, 0, 0));\n+  l1label = new_loc_descr (DW_OP_dup, 0, 0);\n+  add_loc_descr (&ret, l1label);\n+  l2jump = new_loc_descr (DW_OP_bra, 0, 0);\n+  add_loc_descr (&ret, l2jump);\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_dup, 0, 0));\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_rot, 0, 0));\n+  tmp = mem_loc_descriptor (const1_rtx, mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+  if (tmp == NULL)\n+    return NULL;\n+  add_loc_descr (&ret, tmp);\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_and, 0, 0));\n+  add_loc_descr (&ret, new_loc_descr (GET_CODE (rtl) == POPCOUNT\n+\t\t\t\t      ? DW_OP_plus : DW_OP_xor, 0, 0));\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_swap, 0, 0));\n+  tmp = mem_loc_descriptor (const1_rtx, mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+  add_loc_descr (&ret, tmp);\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_shr, 0, 0));\n+  l1jump = new_loc_descr (DW_OP_skip, 0, 0);\n+  add_loc_descr (&ret, l1jump);\n+  l2label = new_loc_descr (DW_OP_drop, 0, 0);\n+  add_loc_descr (&ret, l2label);\n+  l1jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+  l1jump->dw_loc_oprnd1.v.val_loc = l1label;\n+  l2jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+  l2jump->dw_loc_oprnd1.v.val_loc = l2label;\n+  return ret;\n+}\n+\n+/* BSWAP (constS is initial shift count, either 56 or 24):\n+       constS const0\n+   L1: DW_OP_pick <2> constS DW_OP_pick <3> DW_OP_minus DW_OP_shr\n+       const255 DW_OP_and DW_OP_pick <2> DW_OP_shl DW_OP_or\n+       DW_OP_swap DW_OP_dup const0 DW_OP_eq DW_OP_bra <L2> const8\n+       DW_OP_minus DW_OP_swap DW_OP_skip <L1>\n+   L2: DW_OP_drop DW_OP_swap DW_OP_drop  */\n+\n+static dw_loc_descr_ref\n+bswap_loc_descriptor (rtx rtl, enum machine_mode mode,\n+\t\t      enum machine_mode mem_mode)\n+{\n+  dw_loc_descr_ref op0, ret, tmp;\n+  dw_loc_descr_ref l1jump, l1label;\n+  dw_loc_descr_ref l2jump, l2label;\n+\n+  if (GET_MODE_CLASS (mode) != MODE_INT\n+      || BITS_PER_UNIT != 8\n+      || (GET_MODE_BITSIZE (mode) != 32\n+\t  &&  GET_MODE_BITSIZE (mode) != 64))\n+    return NULL;\n+\n+  op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+  if (op0 == NULL)\n+    return NULL;\n+\n+  ret = op0;\n+  tmp = mem_loc_descriptor (GEN_INT (GET_MODE_BITSIZE (mode) - 8),\n+\t\t\t    mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+  if (tmp == NULL)\n+    return NULL;\n+  add_loc_descr (&ret, tmp);\n+  tmp = mem_loc_descriptor (const0_rtx, mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+  if (tmp == NULL)\n+    return NULL;\n+  add_loc_descr (&ret, tmp);\n+  l1label = new_loc_descr (DW_OP_pick, 2, 0);\n+  add_loc_descr (&ret, l1label);\n+  tmp = mem_loc_descriptor (GEN_INT (GET_MODE_BITSIZE (mode) - 8),\n+\t\t\t    mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+  add_loc_descr (&ret, tmp);\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_pick, 3, 0));\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_minus, 0, 0));\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_shr, 0, 0));\n+  tmp = mem_loc_descriptor (GEN_INT (255), mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+  if (tmp == NULL)\n+    return NULL;\n+  add_loc_descr (&ret, tmp);\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_and, 0, 0));\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_pick, 2, 0));\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_shl, 0, 0));\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_or, 0, 0));\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_swap, 0, 0));\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_dup, 0, 0));\n+  tmp = mem_loc_descriptor (const0_rtx, mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+  add_loc_descr (&ret, tmp);\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_eq, 0, 0));\n+  l2jump = new_loc_descr (DW_OP_bra, 0, 0);\n+  add_loc_descr (&ret, l2jump);\n+  tmp = mem_loc_descriptor (GEN_INT (8), mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+  add_loc_descr (&ret, tmp);\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_minus, 0, 0));\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_swap, 0, 0));\n+  l1jump = new_loc_descr (DW_OP_skip, 0, 0);\n+  add_loc_descr (&ret, l1jump);\n+  l2label = new_loc_descr (DW_OP_drop, 0, 0);\n+  add_loc_descr (&ret, l2label);\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_swap, 0, 0));\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_drop, 0, 0));\n+  l1jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+  l1jump->dw_loc_oprnd1.v.val_loc = l1label;\n+  l2jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+  l2jump->dw_loc_oprnd1.v.val_loc = l2label;\n+  return ret;\n+}\n+\n+/* ROTATE (constMASK is mode mask, BITSIZE is bitsize of mode):\n+   DW_OP_over DW_OP_over DW_OP_shl [ constMASK DW_OP_and ] DW_OP_rot\n+   [ DW_OP_swap constMASK DW_OP_and DW_OP_swap ] DW_OP_neg\n+   DW_OP_plus_uconst <BITSIZE> DW_OP_shr DW_OP_or\n+\n+   ROTATERT is similar:\n+   DW_OP_over DW_OP_over DW_OP_neg DW_OP_plus_uconst <BITSIZE>\n+   DW_OP_shl [ constMASK DW_OP_and ] DW_OP_rot\n+   [ DW_OP_swap constMASK DW_OP_and DW_OP_swap ] DW_OP_shr DW_OP_or  */\n+\n+static dw_loc_descr_ref\n+rotate_loc_descriptor (rtx rtl, enum machine_mode mode,\n+\t\t       enum machine_mode mem_mode)\n+{\n+  rtx rtlop1 = XEXP (rtl, 1);\n+  dw_loc_descr_ref op0, op1, ret, mask[2] = { NULL, NULL };\n+  int i;\n+\n+  if (GET_MODE_CLASS (mode) != MODE_INT)\n+    return NULL;\n+\n+  if (GET_MODE (rtlop1) != VOIDmode\n+      && GET_MODE_BITSIZE (GET_MODE (rtlop1)) < GET_MODE_BITSIZE (mode))\n+    rtlop1 = gen_rtx_ZERO_EXTEND (mode, rtlop1);\n+  op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+  op1 = mem_loc_descriptor (rtlop1, mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+  if (op0 == NULL || op1 == NULL)\n+    return NULL;\n+  if (GET_MODE_SIZE (mode) < DWARF2_ADDR_SIZE)\n+    for (i = 0; i < 2; i++)\n+      {\n+\tif (GET_MODE_BITSIZE (mode) < HOST_BITS_PER_WIDE_INT)\n+\t  mask[i] = mem_loc_descriptor (GEN_INT (GET_MODE_MASK (mode)),\n+\t\t\t\t\tmode, mem_mode,\n+\t\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+\telse if (GET_MODE_BITSIZE (mode) == HOST_BITS_PER_WIDE_INT)\n+\t  mask[i] = new_loc_descr (HOST_BITS_PER_WIDE_INT == 32\n+\t\t\t\t   ? DW_OP_const4u\n+\t\t\t\t   : HOST_BITS_PER_WIDE_INT == 64\n+\t\t\t\t   ? DW_OP_const8u : DW_OP_constu,\n+\t\t\t\t   GET_MODE_MASK (mode), 0);\n+\telse\n+\t  mask[i] = NULL;\n+\tif (mask[i] == NULL)\n+\t  return NULL;\n+\tadd_loc_descr (&mask[i], new_loc_descr (DW_OP_and, 0, 0));\n+      }\n+  ret = op0;\n+  add_loc_descr (&ret, op1);\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_over, 0, 0));\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_over, 0, 0));\n+  if (GET_CODE (rtl) == ROTATERT)\n+    {\n+      add_loc_descr (&ret, new_loc_descr (DW_OP_neg, 0, 0));\n+      add_loc_descr (&ret, new_loc_descr (DW_OP_plus_uconst,\n+\t\t\t\t\t  GET_MODE_BITSIZE (mode), 0));\n+    }\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_shl, 0, 0));\n+  if (mask[0] != NULL)\n+    add_loc_descr (&ret, mask[0]);\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_rot, 0, 0));\n+  if (mask[1] != NULL)\n+    {\n+      add_loc_descr (&ret, new_loc_descr (DW_OP_swap, 0, 0));\n+      add_loc_descr (&ret, mask[1]);\n+      add_loc_descr (&ret, new_loc_descr (DW_OP_swap, 0, 0));\n+    }\n+  if (GET_CODE (rtl) == ROTATE)\n+    {\n+      add_loc_descr (&ret, new_loc_descr (DW_OP_neg, 0, 0));\n+      add_loc_descr (&ret, new_loc_descr (DW_OP_plus_uconst,\n+\t\t\t\t\t  GET_MODE_BITSIZE (mode), 0));\n+    }\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_shr, 0, 0));\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_or, 0, 0));\n+  return ret;\n+}\n+\n /* The following routine converts the RTL for a variable or parameter\n    (resident in memory) into an equivalent Dwarf representation of a\n    mechanism for getting the address of that same variable onto the top of a\n@@ -14491,218 +15112,44 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n       break;\n \n     case EQ:\n-      op = DW_OP_eq;\n-      goto do_scompare;\n+      mem_loc_result = scompare_loc_descriptor (DW_OP_eq, rtl, mem_mode);\n+      break;\n \n     case GE:\n-      op = DW_OP_ge;\n-      goto do_scompare;\n+      mem_loc_result = scompare_loc_descriptor (DW_OP_ge, rtl, mem_mode);\n+      break;\n \n     case GT:\n-      op = DW_OP_gt;\n-      goto do_scompare;\n+      mem_loc_result = scompare_loc_descriptor (DW_OP_gt, rtl, mem_mode);\n+      break;\n \n     case LE:\n-      op = DW_OP_le;\n-      goto do_scompare;\n+      mem_loc_result = scompare_loc_descriptor (DW_OP_le, rtl, mem_mode);\n+      break;\n \n     case LT:\n-      op = DW_OP_lt;\n-      goto do_scompare;\n+      mem_loc_result = scompare_loc_descriptor (DW_OP_lt, rtl, mem_mode);\n+      break;\n \n     case NE:\n-      op = DW_OP_ne;\n-      goto do_scompare;\n-\n-    do_scompare:\n-      {\n-\tenum machine_mode op_mode = GET_MODE (XEXP (rtl, 0));\n-\n-\tif (op_mode == VOIDmode)\n-\t  op_mode = GET_MODE (XEXP (rtl, 1));\n-\tif (op_mode == VOIDmode)\n-\t  break;\n-\n-\tif (dwarf_strict\n-\t    && (GET_MODE_CLASS (op_mode) != MODE_INT\n-\t\t|| GET_MODE_SIZE (op_mode) > DWARF2_ADDR_SIZE))\n-\t  break;\n-\n-\top0 = mem_loc_descriptor (XEXP (rtl, 0), op_mode, mem_mode,\n-\t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n-\top1 = mem_loc_descriptor (XEXP (rtl, 1), op_mode, mem_mode,\n-\t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n-\n-\tif (op0 == 0 || op1 == 0)\n-\t  break;\n-\n-\tif (GET_MODE_CLASS (op_mode) == MODE_INT\n-\t    && GET_MODE_SIZE (op_mode) < DWARF2_ADDR_SIZE)\n-\t  {\n-\t    int shift = DWARF2_ADDR_SIZE - GET_MODE_SIZE (op_mode);\n-\t    shift *= BITS_PER_UNIT;\n-\t    /* For eq/ne, if the operands are known to be zero-extended,\n-\t       there is no need to do the fancy shifting up.  */\n-\t    if (op == DW_OP_eq || op == DW_OP_ne)\n-\t      {\n-\t\tdw_loc_descr_ref last0, last1;\n-\t\tfor (last0 = op0;\n-\t\t     last0->dw_loc_next != NULL;\n-\t\t     last0 = last0->dw_loc_next)\n-\t\t  ;\n-\t\tfor (last1 = op1;\n-\t\t     last1->dw_loc_next != NULL;\n-\t\t     last1 = last1->dw_loc_next)\n-\t\t  ;\n-\t\t/* deref_size zero extends, and for constants we can check\n-\t\t   whether they are zero extended or not.  */\n-\t\tif (((last0->dw_loc_opc == DW_OP_deref_size\n-\t\t      && last0->dw_loc_oprnd1.v.val_int\n-\t\t\t <= GET_MODE_SIZE (op_mode))\n-\t\t     || (CONST_INT_P (XEXP (rtl, 0))\n-\t\t\t && (unsigned HOST_WIDE_INT) INTVAL (XEXP (rtl, 0))\n-\t\t\t     == (INTVAL (XEXP (rtl, 0))\n-\t\t\t\t & GET_MODE_MASK (op_mode))))\n-\t\t    && ((last1->dw_loc_opc == DW_OP_deref_size\n-\t\t\t && last1->dw_loc_oprnd1.v.val_int\n-\t\t\t    <= GET_MODE_SIZE (op_mode))\n-\t\t\t|| (CONST_INT_P (XEXP (rtl, 1))\n-\t\t\t    && (unsigned HOST_WIDE_INT)\n-\t\t\t       INTVAL (XEXP (rtl, 1))\n-\t\t\t       == (INTVAL (XEXP (rtl, 1))\n-\t\t\t\t   & GET_MODE_MASK (op_mode)))))\n-\t\t  goto do_compare;\n-\t      }\n-\t    add_loc_descr (&op0, int_loc_descriptor (shift));\n-\t    add_loc_descr (&op0, new_loc_descr (DW_OP_shl, 0, 0));\n-\t    if (CONST_INT_P (XEXP (rtl, 1)))\n-\t      op1 = int_loc_descriptor (INTVAL (XEXP (rtl, 1)) << shift);\n-\t    else\n-\t      {\n-\t\tadd_loc_descr (&op1, int_loc_descriptor (shift));\n-\t\tadd_loc_descr (&op1, new_loc_descr (DW_OP_shl, 0, 0));\n-\t      }\n-\t  }\n-      }\n-\n-    do_compare:\n-      mem_loc_result = op0;\n-      add_loc_descr (&mem_loc_result, op1);\n-      add_loc_descr (&mem_loc_result, new_loc_descr (op, 0, 0));\n-      if (STORE_FLAG_VALUE != 1)\n-\t{\n-\t  add_loc_descr (&mem_loc_result,\n-\t\t\t int_loc_descriptor (STORE_FLAG_VALUE));\n-\t  add_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_mul, 0, 0));\n-\t}\n+      mem_loc_result = scompare_loc_descriptor (DW_OP_ne, rtl, mem_mode);\n       break;\n \n     case GEU:\n-      op = DW_OP_ge;\n-      goto do_ucompare;\n+      mem_loc_result = ucompare_loc_descriptor (DW_OP_ge, rtl, mem_mode);\n+      break;\n \n     case GTU:\n-      op = DW_OP_gt;\n-      goto do_ucompare;\n+      mem_loc_result = ucompare_loc_descriptor (DW_OP_gt, rtl, mem_mode);\n+      break;\n \n     case LEU:\n-      op = DW_OP_le;\n-      goto do_ucompare;\n+      mem_loc_result = ucompare_loc_descriptor (DW_OP_le, rtl, mem_mode);\n+      break;\n \n     case LTU:\n-      op = DW_OP_lt;\n-      goto do_ucompare;\n-\n-    do_ucompare:\n-      {\n-\tenum machine_mode op_mode = GET_MODE (XEXP (rtl, 0));\n-\n-\tif (op_mode == VOIDmode)\n-\t  op_mode = GET_MODE (XEXP (rtl, 1));\n-\tif (op_mode == VOIDmode)\n-\t  break;\n-\tif (GET_MODE_CLASS (op_mode) != MODE_INT)\n-\t  break;\n-\n-\tif (dwarf_strict && GET_MODE_SIZE (op_mode) > DWARF2_ADDR_SIZE)\n-\t  break;\n-\n-\tif (op_mode != VOIDmode && GET_MODE_CLASS (op_mode) != MODE_INT)\n-\t    break;\n-\n-\top0 = mem_loc_descriptor (XEXP (rtl, 0), op_mode, mem_mode,\n-\t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n-\top1 = mem_loc_descriptor (XEXP (rtl, 1), op_mode, mem_mode,\n-\t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n-\n-\tif (op0 == 0 || op1 == 0)\n-\t  break;\n-\n-\tif (GET_MODE_SIZE (op_mode) < DWARF2_ADDR_SIZE)\n-\t  {\n-\t    HOST_WIDE_INT mask = GET_MODE_MASK (op_mode);\n-\t    dw_loc_descr_ref last0, last1;\n-\t    for (last0 = op0;\n-\t\t last0->dw_loc_next != NULL;\n-\t\t last0 = last0->dw_loc_next)\n-\t      ;\n-\t    for (last1 = op1;\n-\t\t last1->dw_loc_next != NULL;\n-\t\t last1 = last1->dw_loc_next)\n-\t      ;\n-\t    if (CONST_INT_P (XEXP (rtl, 0)))\n-\t      op0 = int_loc_descriptor (INTVAL (XEXP (rtl, 0)) & mask);\n-\t    /* deref_size zero extends, so no need to mask it again.  */\n-\t    else if (last0->dw_loc_opc != DW_OP_deref_size\n-\t\t     || last0->dw_loc_oprnd1.v.val_int\n-\t\t\t> GET_MODE_SIZE (op_mode))\n-\t      {\n-\t\tadd_loc_descr (&op0, int_loc_descriptor (mask));\n-\t\tadd_loc_descr (&op0, new_loc_descr (DW_OP_and, 0, 0));\n-\t      }\n-\t    if (CONST_INT_P (XEXP (rtl, 1)))\n-\t      op1 = int_loc_descriptor (INTVAL (XEXP (rtl, 1)) & mask);\n-\t    /* deref_size zero extends, so no need to mask it again.  */\n-\t    else if (last1->dw_loc_opc != DW_OP_deref_size\n-\t\t     || last1->dw_loc_oprnd1.v.val_int\n-\t\t\t> GET_MODE_SIZE (op_mode))\n-\t      {\n-\t\tadd_loc_descr (&op1, int_loc_descriptor (mask));\n-\t\tadd_loc_descr (&op1, new_loc_descr (DW_OP_and, 0, 0));\n-\t      }\n-\t  }\n-\telse if (GET_MODE_SIZE (op_mode) == DWARF2_ADDR_SIZE)\n-\t  {\n-\t    HOST_WIDE_INT bias = 1;\n-\t    bias <<= (DWARF2_ADDR_SIZE * BITS_PER_UNIT - 1);\n-\t    add_loc_descr (&op0, new_loc_descr (DW_OP_plus_uconst, bias, 0));\n-\t    if (CONST_INT_P (XEXP (rtl, 1)))\n-\t      op1 = int_loc_descriptor ((unsigned HOST_WIDE_INT) bias\n-\t\t\t\t\t+ INTVAL (XEXP (rtl, 1)));\n-\t    else\n-\t      add_loc_descr (&op1, new_loc_descr (DW_OP_plus_uconst,\n-\t\t\t\t\t\t  bias, 0));\n-\t  }\n-\telse\n-\t  {\n-\t    dw_die_ref type_die = base_type_for_mode (op_mode, 1);\n-\t    dw_loc_descr_ref cvt;\n-\n-\t    if (type_die == NULL)\n-\t      break;\n-\t    cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n-\t    cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n-\t    cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n-\t    cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n-\t    add_loc_descr (&op0, cvt);\n-\t    cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n-\t    cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n-\t    cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n-\t    cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n-\t    add_loc_descr (&op1, cvt);\n-\t  }\n-      }\n-      goto do_compare;\n+      mem_loc_result = ucompare_loc_descriptor (DW_OP_lt, rtl, mem_mode);\n+      break;\n \n     case UMIN:\n     case UMAX:\n@@ -14711,87 +15158,7 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n       /* FALLTHRU */\n     case SMIN:\n     case SMAX:\n-      if (dwarf_strict\n-\t  && (GET_MODE_CLASS (mode) != MODE_INT\n-\t      || GET_MODE_SIZE (mode) > DWARF2_ADDR_SIZE))\n-\tbreak;\n-\n-      op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n-\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n-      op1 = mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode,\n-\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n-\n-      if (op0 == 0 || op1 == 0)\n-\tbreak;\n-\n-      add_loc_descr (&op0, new_loc_descr (DW_OP_dup, 0, 0));\n-      add_loc_descr (&op1, new_loc_descr (DW_OP_swap, 0, 0));\n-      add_loc_descr (&op1, new_loc_descr (DW_OP_over, 0, 0));\n-      if (GET_CODE (rtl) == UMIN || GET_CODE (rtl) == UMAX)\n-\t{\n-\t  if (GET_MODE_SIZE (mode) < DWARF2_ADDR_SIZE)\n-\t    {\n-\t      HOST_WIDE_INT mask = GET_MODE_MASK (mode);\n-\t      add_loc_descr (&op0, int_loc_descriptor (mask));\n-\t      add_loc_descr (&op0, new_loc_descr (DW_OP_and, 0, 0));\n-\t      add_loc_descr (&op1, int_loc_descriptor (mask));\n-\t      add_loc_descr (&op1, new_loc_descr (DW_OP_and, 0, 0));\n-\t    }\n-\t  else if (GET_MODE_SIZE (mode) == DWARF2_ADDR_SIZE)\n-\t    {\n-\t      HOST_WIDE_INT bias = 1;\n-\t      bias <<= (DWARF2_ADDR_SIZE * BITS_PER_UNIT - 1);\n-\t      add_loc_descr (&op0, new_loc_descr (DW_OP_plus_uconst, bias, 0));\n-\t      add_loc_descr (&op1, new_loc_descr (DW_OP_plus_uconst, bias, 0));\n-\t    }\n-\t  else\n-\t    {\n-\t      dw_die_ref type_die = base_type_for_mode (mode, 1);\n-\t      dw_loc_descr_ref cvt;\n-\n-\t      if (type_die == NULL)\n-\t\tbreak;\n-\t      cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n-\t      cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n-\t      cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n-\t      cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n-\t      add_loc_descr (&op0, cvt);\n-\t      cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n-\t      cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n-\t      cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n-\t      cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n-\t      add_loc_descr (&op1, cvt);\n-\t    }\n-\t}\n-      else if (GET_MODE_CLASS (mode) == MODE_INT\n-\t       && GET_MODE_SIZE (mode) < DWARF2_ADDR_SIZE)\n-\t{\n-\t  int shift = DWARF2_ADDR_SIZE - GET_MODE_SIZE (mode);\n-\t  shift *= BITS_PER_UNIT;\n-\t  add_loc_descr (&op0, int_loc_descriptor (shift));\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_shl, 0, 0));\n-\t  add_loc_descr (&op1, int_loc_descriptor (shift));\n-\t  add_loc_descr (&op1, new_loc_descr (DW_OP_shl, 0, 0));\n-\t}\n-\n-      if (GET_CODE (rtl) == SMIN || GET_CODE (rtl) == UMIN)\n-\top = DW_OP_lt;\n-      else\n-\top = DW_OP_gt;\n-      mem_loc_result = op0;\n-      add_loc_descr (&mem_loc_result, op1);\n-      add_loc_descr (&mem_loc_result, new_loc_descr (op, 0, 0));\n-      {\n-\tdw_loc_descr_ref bra_node, drop_node;\n-\n-\tbra_node = new_loc_descr (DW_OP_bra, 0, 0);\n-\tadd_loc_descr (&mem_loc_result, bra_node);\n-\tadd_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_swap, 0, 0));\n-\tdrop_node = new_loc_descr (DW_OP_drop, 0, 0);\n-\tadd_loc_descr (&mem_loc_result, drop_node);\n-\tbra_node->dw_loc_oprnd1.val_class = dw_val_class_loc;\n-\tbra_node->dw_loc_oprnd1.v.val_loc = drop_node;\n-      }\n+      mem_loc_result = minmax_loc_descriptor (rtl, mode, mem_mode);\n       break;\n \n     case ZERO_EXTRACT:\n@@ -14916,345 +15283,21 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n     case CLZ:\n     case CTZ:\n     case FFS:\n-      /* CLZ (where constV is CLZ_DEFINED_VALUE_AT_ZERO computed value,\n-\t      const0 is DW_OP_lit0 or corresponding typed constant,\n-\t      const1 is DW_OP_lit1 or corresponding typed constant\n-\t      and constMSB is constant with just the MSB bit set\n-\t      for the mode):\n-\t   DW_OP_dup DW_OP_bra <L1> DW_OP_drop constV DW_OP_skip <L4>\n-\t L1: const0 DW_OP_swap\n-\t L2: DW_OP_dup constMSB DW_OP_and DW_OP_bra <L3> const1 DW_OP_shl\n-\t     DW_OP_swap DW_OP_plus_uconst <1> DW_OP_swap DW_OP_skip <L2>\n-\t L3: DW_OP_drop\n-\t L4: DW_OP_nop\n-\n-\t CTZ is similar:\n-\t   DW_OP_dup DW_OP_bra <L1> DW_OP_drop constV DW_OP_skip <L4>\n-\t L1: const0 DW_OP_swap\n-\t L2: DW_OP_dup const1 DW_OP_and DW_OP_bra <L3> const1 DW_OP_shr\n-\t     DW_OP_swap DW_OP_plus_uconst <1> DW_OP_swap DW_OP_skip <L2>\n-\t L3: DW_OP_drop\n-\t L4: DW_OP_nop\n-\n-\t FFS is similar:\n-\t   DW_OP_dup DW_OP_bra <L1> DW_OP_drop const0 DW_OP_skip <L4>\n-\t L1: const1 DW_OP_swap\n-\t L2: DW_OP_dup const1 DW_OP_and DW_OP_bra <L3> const1 DW_OP_shr\n-\t     DW_OP_swap DW_OP_plus_uconst <1> DW_OP_swap DW_OP_skip <L2>\n-\t L3: DW_OP_drop\n-\t L4: DW_OP_nop  */\n-      if (GET_MODE_CLASS (mode) == MODE_INT\n-\t  && GET_MODE (XEXP (rtl, 0)) == mode\n-\t  && (GET_CODE (rtl) != CLZ\n-\t      || GET_MODE_BITSIZE (mode) <= 2 * HOST_BITS_PER_WIDE_INT))\n-\t{\n-\t  HOST_WIDE_INT valv;\n-\t  dw_loc_descr_ref l1jump, l1label;\n-\t  dw_loc_descr_ref l2jump, l2label;\n-\t  dw_loc_descr_ref l3jump, l3label;\n-\t  dw_loc_descr_ref l4jump, l4label;\n-\t  rtx msb;\n-\n-\t  op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n-\t  if (op0 == NULL)\n-\t    break;\n-\t  if (GET_CODE (rtl) == CLZ)\n-\t    {\n-\t      if (!CLZ_DEFINED_VALUE_AT_ZERO (mode, valv))\n-\t\tvalv = GET_MODE_BITSIZE (mode);\n-\t    }\n-\t  else if (GET_CODE (rtl) == FFS)\n-\t    valv = 0;\n-\t  else if (!CTZ_DEFINED_VALUE_AT_ZERO (mode, valv))\n-\t    valv = GET_MODE_BITSIZE (mode);\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_dup, 0, 0));\n-\t  l1jump = new_loc_descr (DW_OP_bra, 0, 0);\n-\t  add_loc_descr (&op0, l1jump);\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_drop, 0, 0));\n-\t  op1 = mem_loc_descriptor (GEN_INT (valv), mode, mem_mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n-\t  if (op1 == NULL)\n-\t    break;\n-\t  add_loc_descr (&op0, op1);\n-\t  l4jump = new_loc_descr (DW_OP_skip, 0, 0);\n-\t  add_loc_descr (&op0, l4jump);\n-\t  l1label = mem_loc_descriptor (GET_CODE (rtl) == FFS\n-\t\t\t\t\t? const1_rtx : const0_rtx,\n-\t\t\t\t\tmode, mem_mode,\n-\t\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n-\t  if (l1label == NULL)\n-\t    break;\n-\t  add_loc_descr (&op0, l1label);\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_swap, 0, 0));\n-\t  l2label = new_loc_descr (DW_OP_dup, 0, 0);\n-\t  add_loc_descr (&op0, l2label);\n-\t  if (GET_CODE (rtl) != CLZ)\n-\t    msb = const1_rtx;\n-\t  else if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n-\t    msb = GEN_INT ((unsigned HOST_WIDE_INT) 1\n-\t\t\t   << (GET_MODE_BITSIZE (mode) - 1));\n-\t  else\n-\t    msb = immed_double_const (0, (unsigned HOST_WIDE_INT) 1\n-\t\t\t\t\t << (GET_MODE_BITSIZE (mode)\n-\t\t\t\t\t     - HOST_BITS_PER_WIDE_INT - 1),\n-\t\t\t\t      mode);\n-\t  if (GET_CODE (msb) == CONST_INT && INTVAL (msb) < 0)\n-\t    op1 = new_loc_descr (HOST_BITS_PER_WIDE_INT == 32\n-\t\t\t\t ? DW_OP_const4u\n-\t\t\t\t : HOST_BITS_PER_WIDE_INT == 64\n-\t\t\t\t ? DW_OP_const8u : DW_OP_constu,\n-\t\t\t\t INTVAL (msb), 0);\n-\t  else\n-\t    op1 = mem_loc_descriptor (msb, mode, mem_mode,\n-\t\t\t\t      VAR_INIT_STATUS_INITIALIZED);\n-\t  if (op1 == NULL)\n-\t    break;\n-\t  add_loc_descr (&op0, op1);\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_and, 0, 0));\n-\t  l3jump = new_loc_descr (DW_OP_bra, 0, 0);\n-\t  add_loc_descr (&op0, l3jump);\n-\t  op1 = mem_loc_descriptor (const1_rtx, mode, mem_mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n-\t  if (op1 == NULL)\n-\t    break;\n-\t  add_loc_descr (&op0, op1);\n-\t  add_loc_descr (&op0, new_loc_descr (GET_CODE (rtl) == CLZ\n-\t\t\t\t\t      ? DW_OP_shl : DW_OP_shr, 0, 0));\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_swap, 0, 0));\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_plus_uconst, 1, 0));\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_swap, 0, 0));\n-\t  l2jump = new_loc_descr (DW_OP_skip, 0, 0);\n-\t  add_loc_descr (&op0, l2jump);\n-\t  l3label = new_loc_descr (DW_OP_drop, 0, 0);\n-\t  add_loc_descr (&op0, l3label);\n-\t  l4label = new_loc_descr (DW_OP_nop, 0, 0);\n-\t  add_loc_descr (&op0, l4label);\n-\t  l1jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n-\t  l1jump->dw_loc_oprnd1.v.val_loc = l1label;\n-\t  l2jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n-\t  l2jump->dw_loc_oprnd1.v.val_loc = l2label;\n-\t  l3jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n-\t  l3jump->dw_loc_oprnd1.v.val_loc = l3label;\n-\t  l4jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n-\t  l4jump->dw_loc_oprnd1.v.val_loc = l4label;\n-\t  mem_loc_result = op0;\n-\t}\n+      mem_loc_result = clz_loc_descriptor (rtl, mode, mem_mode);\n       break;\n \n     case POPCOUNT:\n     case PARITY:\n-      /* POPCOUNT (const0 is DW_OP_lit0 or corresponding typed constant,\n-\t\t   const1 is DW_OP_lit1 or corresponding typed constant):\n-\t     const0 DW_OP_swap\n-\t L1: DW_OP_dup DW_OP_bra <L2> DW_OP_dup DW_OP_rot const1 DW_OP_and\n-\t     DW_OP_plus DW_OP_swap const1 DW_OP_shr DW_OP_skip <L1>\n-\t L2: DW_OP_drop\n-\n-\t PARITY is similar:\n-\t L1: DW_OP_dup DW_OP_bra <L2> DW_OP_dup DW_OP_rot const1 DW_OP_and\n-\t     DW_OP_xor DW_OP_swap const1 DW_OP_shr DW_OP_skip <L1>\n-\t L2: DW_OP_drop  */\n-      if (GET_MODE_CLASS (mode) == MODE_INT\n-\t  && GET_MODE (XEXP (rtl, 0)) == mode)\n-\t{\n-\t  dw_loc_descr_ref l1jump, l1label;\n-\t  dw_loc_descr_ref l2jump, l2label;\n-\n-\t  op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n-\t  if (op0 == NULL)\n-\t    break;\n-\t  op1 = mem_loc_descriptor (const0_rtx, mode, mem_mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n-\t  if (op1 == NULL)\n-\t    break;\n-\t  add_loc_descr (&op0, op1);\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_swap, 0, 0));\n-\t  l1label = new_loc_descr (DW_OP_dup, 0, 0);\n-\t  add_loc_descr (&op0, l1label);\n-\t  l2jump = new_loc_descr (DW_OP_bra, 0, 0);\n-\t  add_loc_descr (&op0, l2jump);\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_dup, 0, 0));\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_rot, 0, 0));\n-\t  op1 = mem_loc_descriptor (const1_rtx, mode, mem_mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n-\t  if (op1 == NULL)\n-\t    break;\n-\t  add_loc_descr (&op0, op1);\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_and, 0, 0));\n-\t  add_loc_descr (&op0, new_loc_descr (GET_CODE (rtl) == POPCOUNT\n-\t\t\t\t\t      ? DW_OP_plus : DW_OP_xor, 0, 0));\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_swap, 0, 0));\n-\t  op1 = mem_loc_descriptor (const1_rtx, mode, mem_mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n-\t  add_loc_descr (&op0, op1);\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_shr, 0, 0));\n-\t  l1jump = new_loc_descr (DW_OP_skip, 0, 0);\n-\t  add_loc_descr (&op0, l1jump);\n-\t  l2label = new_loc_descr (DW_OP_drop, 0, 0);\n-\t  add_loc_descr (&op0, l2label);\n-\t  l1jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n-\t  l1jump->dw_loc_oprnd1.v.val_loc = l1label;\n-\t  l2jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n-\t  l2jump->dw_loc_oprnd1.v.val_loc = l2label;\n-\t  mem_loc_result = op0;\n-\t}\n+      mem_loc_result = popcount_loc_descriptor (rtl, mode, mem_mode);\n       break;\n \n     case BSWAP:\n-      /* BSWAP (constS is initial shift count, either 56 or 24):\n-\t     constS const0\n-\t L1: DW_OP_pick <2> constS DW_OP_pick <3> DW_OP_minus DW_OP_shr\n-\t     const255 DW_OP_and DW_OP_pick <2> DW_OP_shl DW_OP_or\n-\t     DW_OP_swap DW_OP_dup const0 DW_OP_eq DW_OP_bra <L2> const8\n-\t     DW_OP_minus DW_OP_swap DW_OP_skip <L1>\n-\t L2: DW_OP_drop DW_OP_swap DW_OP_drop  */\n-      if (GET_MODE_CLASS (mode) == MODE_INT\n-\t  && BITS_PER_UNIT == 8\n-\t  && (GET_MODE_BITSIZE (mode) == 32\n-\t      || GET_MODE_BITSIZE (mode) == 64))\n-\t{\n-\t  dw_loc_descr_ref l1jump, l1label;\n-\t  dw_loc_descr_ref l2jump, l2label;\n-\n-\t  op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n-\t  if (op0 == NULL)\n-\t    break;\n-\n-\t  op1 = mem_loc_descriptor (GEN_INT (GET_MODE_BITSIZE (mode) - 8),\n-\t\t\t\t    mode, mem_mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n-\t  if (op1 == NULL)\n-\t    break;\n-\t  add_loc_descr (&op0, op1);\n-\t  op1 = mem_loc_descriptor (const0_rtx, mode, mem_mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n-\t  if (op1 == NULL)\n-\t    break;\n-\t  add_loc_descr (&op0, op1);\n-\t  l1label = new_loc_descr (DW_OP_pick, 2, 0);\n-\t  add_loc_descr (&op0, l1label);\n-\t  op1 = mem_loc_descriptor (GEN_INT (GET_MODE_BITSIZE (mode) - 8),\n-\t\t\t\t    mode, mem_mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n-\t  add_loc_descr (&op0, op1);\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_pick, 3, 0));\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_minus, 0, 0));\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_shr, 0, 0));\n-\t  op1 = mem_loc_descriptor (GEN_INT (255), mode, mem_mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n-\t  if (op1 == NULL)\n-\t    break;\n-\t  add_loc_descr (&op0, op1);\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_and, 0, 0));\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_pick, 2, 0));\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_shl, 0, 0));\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_or, 0, 0));\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_swap, 0, 0));\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_dup, 0, 0));\n-\t  op1 = mem_loc_descriptor (const0_rtx, mode, mem_mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n-\t  add_loc_descr (&op0, op1);\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_eq, 0, 0));\n-\t  l2jump = new_loc_descr (DW_OP_bra, 0, 0);\n-\t  add_loc_descr (&op0, l2jump);\n-\t  op1 = mem_loc_descriptor (GEN_INT (8), mode, mem_mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n-\t  add_loc_descr (&op0, op1);\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_minus, 0, 0));\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_swap, 0, 0));\n-\t  l1jump = new_loc_descr (DW_OP_skip, 0, 0);\n-\t  add_loc_descr (&op0, l1jump);\n-\t  l2label = new_loc_descr (DW_OP_drop, 0, 0);\n-\t  add_loc_descr (&op0, l2label);\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_swap, 0, 0));\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_drop, 0, 0));\n-\t  l1jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n-\t  l1jump->dw_loc_oprnd1.v.val_loc = l1label;\n-\t  l2jump->dw_loc_oprnd1.val_class = dw_val_class_loc;\n-\t  l2jump->dw_loc_oprnd1.v.val_loc = l2label;\n-\t  mem_loc_result = op0;\n-\t}\n+      mem_loc_result = bswap_loc_descriptor (rtl, mode, mem_mode);\n       break;\n \n     case ROTATE:\n     case ROTATERT:\n-      /* ROTATE (constMASK is mode mask, BITSIZE is bitsize of mode):\n-\t     DW_OP_over DW_OP_over DW_OP_shl [ constMASK DW_OP_and ] DW_OP_rot\n-\t     [ DW_OP_swap constMASK DW_OP_and DW_OP_swap ] DW_OP_neg\n-\t     DW_OP_plus_uconst <BITSIZE> DW_OP_shr DW_OP_or\n-\n-\t ROTATERT is similar:\n-\t     DW_OP_over DW_OP_over DW_OP_neg DW_OP_plus_uconst <BITSIZE>\n-\t     DW_OP_shl [ constMASK DW_OP_and ] DW_OP_rot\n-\t     [ DW_OP_swap constMASK DW_OP_and DW_OP_swap ] DW_OP_shr DW_OP_or\n-\t */\n-      if (GET_MODE_CLASS (mode) == MODE_INT)\n-\t{\n-\t  rtx rtlop1 = XEXP (rtl, 1);\n-\t  dw_loc_descr_ref mask[2] = { NULL, NULL };\n-\t  int i;\n-\n-\t  if (GET_MODE (rtlop1) != VOIDmode\n-\t      && GET_MODE_BITSIZE (GET_MODE (rtlop1))\n-\t\t < GET_MODE_BITSIZE (mode))\n-\t    rtlop1 = gen_rtx_ZERO_EXTEND (mode, rtlop1);\n-\t  op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n-\t  op1 = mem_loc_descriptor (rtlop1, mode, mem_mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n-\t  if (op0 == NULL || op1 == NULL)\n-\t    break;\n-\t  if (GET_MODE_SIZE (mode) < DWARF2_ADDR_SIZE)\n-\t    for (i = 0; i < 2; i++)\n-\t      {\n-\t\tif (GET_MODE_BITSIZE (mode) < HOST_BITS_PER_WIDE_INT)\n-\t\t  mask[i] = mem_loc_descriptor (GEN_INT (GET_MODE_MASK (mode)),\n-\t\t\t\t\t\tmode, mem_mode,\n-\t\t\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n-\t\telse if (GET_MODE_BITSIZE (mode) == HOST_BITS_PER_WIDE_INT)\n-\t\t  mask[i] = new_loc_descr (HOST_BITS_PER_WIDE_INT == 32\n-\t\t\t\t\t   ? DW_OP_const4u\n-\t\t\t\t\t   : HOST_BITS_PER_WIDE_INT == 64\n-\t\t\t\t\t   ? DW_OP_const8u : DW_OP_constu,\n-\t\t\t\t\t   GET_MODE_MASK (mode), 0);\n-\t\telse\n-\t\t  mask[i] = NULL;\n-\t\tif (mask[i] == NULL)\n-\t\t  return NULL;\n-\t\tadd_loc_descr (&mask[i], new_loc_descr (DW_OP_and, 0, 0));\n-\t      }\n-\t  add_loc_descr (&op0, op1);\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_over, 0, 0));\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_over, 0, 0));\n-\t  if (GET_CODE (rtl) == ROTATERT)\n-\t    {\n-\t      add_loc_descr (&op0, new_loc_descr (DW_OP_neg, 0, 0));\n-\t      add_loc_descr (&op0, new_loc_descr (DW_OP_plus_uconst,\n-\t\t\t\t\t\t  GET_MODE_BITSIZE (mode), 0));\n-\t    }\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_shl, 0, 0));\n-\t  if (mask[0] != NULL)\n-\t    add_loc_descr (&op0, mask[0]);\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_rot, 0, 0));\n-\t  if (mask[1] != NULL)\n-\t    {\n-\t      add_loc_descr (&op0, new_loc_descr (DW_OP_swap, 0, 0));\n-\t      add_loc_descr (&op0, mask[1]);\n-\t      add_loc_descr (&op0, new_loc_descr (DW_OP_swap, 0, 0));\n-\t    }\n-\t  if (GET_CODE (rtl) == ROTATE)\n-\t    {\n-\t      add_loc_descr (&op0, new_loc_descr (DW_OP_neg, 0, 0));\n-\t      add_loc_descr (&op0, new_loc_descr (DW_OP_plus_uconst,\n-\t\t\t\t\t\t  GET_MODE_BITSIZE (mode), 0));\n-\t    }\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_shr, 0, 0));\n-\t  add_loc_descr (&op0, new_loc_descr (DW_OP_or, 0, 0));\n-\t  mem_loc_result = op0;\n-\t}\n+      mem_loc_result = rotate_loc_descriptor (rtl, mode, mem_mode);\n       break;\n \n     case COMPARE:"}]}