{"sha": "5f39ad476ca64351cd077070105f97236c19ae78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYzOWFkNDc2Y2E2NDM1MWNkMDc3MDcwMTA1Zjk3MjM2YzE5YWU3OA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2009-04-27T17:21:27Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2009-04-27T17:21:27Z"}, "message": "dbgcnt.def (cprop1, [...]): Remove\n\n\t* dbgcnt.def (cprop1, cprop2, gcse, jump_bypass): Remove\n\t(cprop, hoist, pre, store_motion): New debug counters.\n\t* tree-pass.h (pass_tracer): Move to list of gimple passes, it\n\tis not an RTL pass anymore.\n\t(pass_profiling): Remove extern decl for pass removed in 2005.\n\t(pass_gcse, pass_jump_bypass): Remove.\n\t* final.c (rest_of_clean_state): Set flag_rerun_cse_after_global_opts\n\tto 0 for clean state.\n\t* toplev.h (flag_rerun_cse_after_global_opts): Add extern declaration.\n\t* cse.c (gate_handle_cse_after_global_opts,\n\trest_of_handle_cse_after_global_opts): New functions.\n\t(pass_cse_after_global_opts): New pass, does local CSE.\n\t* timevar.def (TV_GCSE, TV_CPROP1, TV_CPROP2, TV_BYPASS): Remove.\n\t(TV_CPROP): New timevar.\n\t* gcse.c (flag_rerun_cse_after_global_opts): New global variable.\n\t(run_jump_opt_after_gcse, max_gcse_regno): Remove global vars.\n\t(gcse_main, recompute_all_luids): Remove.\n\t(compute_hash_table_work): Call max_reg_num instead of reading\n\tmax_gcse_regno.\n\t(cprop_jump): Don't set run_jump_opt_after_gcse.\n\t(constprop_register): Always allow to alter jumps.\n\t(cprop_insn): Likewise.\n\t(do_local_cprop): Likewise.\n\t(local_cprop_pass): Likewise.  Return non-zero if something changed.\n\t(cprop): Remove function, fold interesting bits into one_cprop_pass.\n\t(find_implicit_sets): Add note about missed optimization opportunity.\n\t(one_cprop_pass): Rewrite to be \"the\" CPROP pass, called from the\n\tpass_rtl_cprop execute function.\n\tDon't bother tracking the pass number, each pass gets its own dumpfile\n\tnow anyway.\n\tAlways allow to alter jumpsand bypass jumps.\n\t(bypass_block): Don't ignore regno >= max_gcse_regno, find_bypass_set\n\twill just find no suitable set.\n\t(pre_edge_insert): Fix dumping, this function is for PRE only.\n\t(one_pre_gcse_pass): Rewrite to be \"the\" PRE pass, called from the\n\tpass_rtl_pre execute function.\n\t(hoist_code): Return non-zero if something changed.  Keep track of\n\tsubstitutions and insertions for statistics gathering similar to PRE.\n\t(one_code_hoisting_pass): Rewrite to be \"the\" code hoisting pass,\n\tcalled from the pass_rtl_hoist execute function.  Show pass statistics.\n\t(compute_store_table): Use max_reg_num directly instead of using the\n\tformerly global max_gcse_regno.\n\t(build_store_vectors): Likewise.\n\t(replace_store_insn): Fix dumping.\n\t(store_motion): Rename to ...\n\t(one_store_motion_pass): ... this.  Rewrite to be \"the\" STORE_MOTION\n\tpass, called from the pass_rtl_store_motion execute function.  Keep\n\ttrack of substitutions and insertions for statistics gathering similar\n\tto PRE.\n\t(bypass_jumps): Remove, fold interesting bits into ...\n\t(one_cprop_pass): ... this.  Rewrite to be \"the\" CPROP pass, called\n\tfrom the pass_rtl_cprop execute function.\n\t(gate_handle_jump_bypass, rest_of_handle_jump_bypass,\n\tpass_jump_bypass): Remove.\n\t(gate_handle_gcse, rest_of_handle_gcse): Remove.\n\t(gate_rtl_cprop, execute_rtl_cprop, pass_rtl_cprop): New.\n\t(gate_rtl_pre, execute_rtl_pre, pass_rtl_pre): New.\n\t(gate_rtl_hoist, execute_rtl_hoist, pass_rtl_hoist): New.\n\t(gate_rtl_store_motion, execute_rtl_store_motion,\n\tpass_rtl_store_motion): New.\n\t* common.opt: Remove flag_cse_skip_blocks, adjust documentation to\n\tmake it clear that -fcse-skip-blocks is a no-op for backward compat.\n\t* passes.c (init_optimization_passes): Remove pass_gcse and\n\tpass_jump_bypass.  Schedule cprop, pre, hoist, cprop, store_motion,\n\tand cse_after_global_opts in place of pass_gcse.  Schedule cprop\n\tinstead of pass_jump_bypass.\n\nFrom-SVN: r146848", "tree": {"sha": "fcb9da5c176fcf8fb2c23a28f80734d495b623b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcb9da5c176fcf8fb2c23a28f80734d495b623b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f39ad476ca64351cd077070105f97236c19ae78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f39ad476ca64351cd077070105f97236c19ae78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f39ad476ca64351cd077070105f97236c19ae78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f39ad476ca64351cd077070105f97236c19ae78/comments", "author": null, "committer": null, "parents": [{"sha": "c685de4a22030cd5bf773568dd7395d5b428ec3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c685de4a22030cd5bf773568dd7395d5b428ec3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c685de4a22030cd5bf773568dd7395d5b428ec3c"}], "stats": {"total": 976, "additions": 502, "deletions": 474}, "files": [{"sha": "17520f47292814aae4c2a0fde968199cf1dff0c0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f39ad476ca64351cd077070105f97236c19ae78/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f39ad476ca64351cd077070105f97236c19ae78/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f39ad476ca64351cd077070105f97236c19ae78", "patch": "@@ -1,3 +1,72 @@\n+2009-04-27  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* dbgcnt.def (cprop1, cprop2, gcse, jump_bypass): Remove\n+\t(cprop, hoist, pre, store_motion): New debug counters.\n+\t* tree-pass.h (pass_tracer): Move to list of gimple passes, it\n+\tis not an RTL pass anymore.\n+\t(pass_profiling): Remove extern decl for pass removed in 2005.\n+\t(pass_gcse, pass_jump_bypass): Remove.\n+\t* final.c (rest_of_clean_state): Set flag_rerun_cse_after_global_opts\n+\tto 0 for clean state.\n+\t* toplev.h (flag_rerun_cse_after_global_opts): Add extern declaration.\n+\t* cse.c (gate_handle_cse_after_global_opts,\n+\trest_of_handle_cse_after_global_opts): New functions.\n+\t(pass_cse_after_global_opts): New pass, does local CSE.\n+\t* timevar.def (TV_GCSE, TV_CPROP1, TV_CPROP2, TV_BYPASS): Remove.\n+\t(TV_CPROP): New timevar.\n+\t* gcse.c (flag_rerun_cse_after_global_opts): New global variable.\n+\t(run_jump_opt_after_gcse, max_gcse_regno): Remove global vars.\n+\t(gcse_main, recompute_all_luids): Remove.\n+\t(compute_hash_table_work): Call max_reg_num instead of reading\n+\tmax_gcse_regno.\n+\t(cprop_jump): Don't set run_jump_opt_after_gcse.\n+\t(constprop_register): Always allow to alter jumps.\n+\t(cprop_insn): Likewise.\n+\t(do_local_cprop): Likewise.\n+\t(local_cprop_pass): Likewise.  Return non-zero if something changed.\n+\t(cprop): Remove function, fold interesting bits into one_cprop_pass.\n+\t(find_implicit_sets): Add note about missed optimization opportunity.\n+\t(one_cprop_pass): Rewrite to be \"the\" CPROP pass, called from the\n+\tpass_rtl_cprop execute function.\n+\tDon't bother tracking the pass number, each pass gets its own dumpfile\n+\tnow anyway.\n+\tAlways allow to alter jumpsand bypass jumps.\n+\t(bypass_block): Don't ignore regno >= max_gcse_regno, find_bypass_set\n+\twill just find no suitable set.\n+\t(pre_edge_insert): Fix dumping, this function is for PRE only.\n+\t(one_pre_gcse_pass): Rewrite to be \"the\" PRE pass, called from the\n+\tpass_rtl_pre execute function.\n+\t(hoist_code): Return non-zero if something changed.  Keep track of\n+\tsubstitutions and insertions for statistics gathering similar to PRE.\n+\t(one_code_hoisting_pass): Rewrite to be \"the\" code hoisting pass,\n+\tcalled from the pass_rtl_hoist execute function.  Show pass statistics.\n+\t(compute_store_table): Use max_reg_num directly instead of using the\n+\tformerly global max_gcse_regno.\n+\t(build_store_vectors): Likewise.\n+\t(replace_store_insn): Fix dumping.\n+\t(store_motion): Rename to ...\n+\t(one_store_motion_pass): ... this.  Rewrite to be \"the\" STORE_MOTION\n+\tpass, called from the pass_rtl_store_motion execute function.  Keep\n+\ttrack of substitutions and insertions for statistics gathering similar\n+\tto PRE.\n+\t(bypass_jumps): Remove, fold interesting bits into ...\n+\t(one_cprop_pass): ... this.  Rewrite to be \"the\" CPROP pass, called\n+\tfrom the pass_rtl_cprop execute function.\n+\t(gate_handle_jump_bypass, rest_of_handle_jump_bypass,\n+\tpass_jump_bypass): Remove.\n+\t(gate_handle_gcse, rest_of_handle_gcse): Remove.\n+\t(gate_rtl_cprop, execute_rtl_cprop, pass_rtl_cprop): New.\n+\t(gate_rtl_pre, execute_rtl_pre, pass_rtl_pre): New.\n+\t(gate_rtl_hoist, execute_rtl_hoist, pass_rtl_hoist): New.\n+\t(gate_rtl_store_motion, execute_rtl_store_motion,\n+\tpass_rtl_store_motion): New.\n+\t* common.opt: Remove flag_cse_skip_blocks, adjust documentation to\n+\tmake it clear that -fcse-skip-blocks is a no-op for backward compat.\n+\t* passes.c (init_optimization_passes): Remove pass_gcse and\n+\tpass_jump_bypass.  Schedule cprop, pre, hoist, cprop, store_motion,\n+\tand cse_after_global_opts in place of pass_gcse.  Schedule cprop\n+\tinstead of pass_jump_bypass.\n+\n 2009-04-27  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/39928"}, {"sha": "3e1b80a7215955ad4f64e46f738f4ad3cff4501f", "filename": "gcc/common.opt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f39ad476ca64351cd077070105f97236c19ae78/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f39ad476ca64351cd077070105f97236c19ae78/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=5f39ad476ca64351cd077070105f97236c19ae78", "patch": "@@ -397,8 +397,8 @@ Common Report Var(flag_cse_follow_jumps) Optimization\n When running CSE, follow jumps to their targets\n \n fcse-skip-blocks\n-Common Report Var(flag_cse_skip_blocks) Optimization\n-When running CSE, follow conditional jumps\n+Common\n+Does nothing.  Preserved for backward compatibility.\n \n fcx-limited-range\n Common Report Var(flag_cx_limited_range) Optimization"}, {"sha": "2b814937535225e32f736ad0b9c5b977bcb47778", "filename": "gcc/cse.c", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f39ad476ca64351cd077070105f97236c19ae78/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f39ad476ca64351cd077070105f97236c19ae78/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=5f39ad476ca64351cd077070105f97236c19ae78", "patch": "@@ -6997,3 +6997,65 @@ struct rtl_opt_pass pass_cse2 =\n   TODO_verify_flow                      /* todo_flags_finish */\n  }\n };\n+\n+static bool\n+gate_handle_cse_after_global_opts (void)\n+{\n+  return optimize > 0 && flag_rerun_cse_after_global_opts;\n+}\n+\n+/* Run second CSE pass after loop optimizations.  */\n+static unsigned int\n+rest_of_handle_cse_after_global_opts (void)\n+{\n+  int save_cfj;\n+  int tem;\n+\n+  /* We only want to do local CSE, so don't follow jumps.  */\n+  save_cfj = flag_cse_follow_jumps;\n+  flag_cse_follow_jumps = 0;\n+\n+  rebuild_jump_labels (get_insns ());\n+  tem = cse_main (get_insns (), max_reg_num ());\n+  purge_all_dead_edges ();\n+  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n+\n+  cse_not_expected = !flag_rerun_cse_after_loop;\n+\n+  /* If cse altered any jumps, rerun jump opts to clean things up.  */\n+  if (tem == 2)\n+    {\n+      timevar_push (TV_JUMP);\n+      rebuild_jump_labels (get_insns ());\n+      cleanup_cfg (0);\n+      timevar_pop (TV_JUMP);\n+    }\n+  else if (tem == 1)\n+    cleanup_cfg (0);\n+\n+  flag_cse_follow_jumps = save_cfj;\n+  return 0;\n+}\n+\n+struct rtl_opt_pass pass_cse_after_global_opts =\n+{\n+ {\n+  RTL_PASS,\n+  \"cse_local\",                          /* name */\n+  gate_handle_cse_after_global_opts,    /* gate */   \n+  rest_of_handle_cse_after_global_opts, /* execute */       \n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_CSE,                               /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_df_finish | TODO_verify_rtl_sharing |\n+  TODO_dump_func |\n+  TODO_ggc_collect |\n+  TODO_verify_flow                      /* todo_flags_finish */\n+ }\n+};\n+"}, {"sha": "82dd988a86ca0620147b490012f4da943ecdc3c8", "filename": "gcc/dbgcnt.def", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f39ad476ca64351cd077070105f97236c19ae78/gcc%2Fdbgcnt.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f39ad476ca64351cd077070105f97236c19ae78/gcc%2Fdbgcnt.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbgcnt.def?ref=5f39ad476ca64351cd077070105f97236c19ae78", "patch": "@@ -145,8 +145,7 @@ DEBUG_COUNTER (auto_inc_dec)\n DEBUG_COUNTER (ccp)\n DEBUG_COUNTER (cfg_cleanup)\n DEBUG_COUNTER (cse2_move2add)\n-DEBUG_COUNTER (cprop1)\n-DEBUG_COUNTER (cprop2)\n+DEBUG_COUNTER (cprop)\n DEBUG_COUNTER (dce)\n DEBUG_COUNTER (dce_fast)\n DEBUG_COUNTER (dce_ud)\n@@ -155,17 +154,17 @@ DEBUG_COUNTER (df_byte_scan)\n DEBUG_COUNTER (dse)\n DEBUG_COUNTER (dse1)\n DEBUG_COUNTER (dse2)\n-DEBUG_COUNTER (gcse)\n DEBUG_COUNTER (gcse2_delete)\n DEBUG_COUNTER (global_alloc_at_func)\n DEBUG_COUNTER (global_alloc_at_reg)\n+DEBUG_COUNTER (hoist)\n DEBUG_COUNTER (ia64_sched2)\n DEBUG_COUNTER (if_conversion)\n DEBUG_COUNTER (if_after_combine)\n DEBUG_COUNTER (if_after_reload)\n-DEBUG_COUNTER (jump_bypass)\n DEBUG_COUNTER (local_alloc_for_sched)\n DEBUG_COUNTER (postreload_cse)\n+DEBUG_COUNTER (pre)\n DEBUG_COUNTER (pre_insn)\n DEBUG_COUNTER (treepre_insert)\n DEBUG_COUNTER (sched2_func)\n@@ -177,5 +176,6 @@ DEBUG_COUNTER (sel_sched_cnt)\n DEBUG_COUNTER (sel_sched_region_cnt)\n DEBUG_COUNTER (sel_sched_insn_cnt)\n DEBUG_COUNTER (sms_sched_loop)\n+DEBUG_COUNTER (store_motion)\n DEBUG_COUNTER (split_for_sched2)\n DEBUG_COUNTER (tail_call)"}, {"sha": "551b3a0e8b0d73317f1ac082fa4f378bd8aef7bb", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f39ad476ca64351cd077070105f97236c19ae78/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f39ad476ca64351cd077070105f97236c19ae78/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=5f39ad476ca64351cd077070105f97236c19ae78", "patch": "@@ -4298,6 +4298,7 @@ rest_of_clean_state (void)\n     sdbout_types (NULL_TREE);\n #endif\n \n+  flag_rerun_cse_after_global_opts = 0;\n   reload_completed = 0;\n   epilogue_completed = 0;\n #ifdef STACK_REGS"}, {"sha": "c7b4b8fd1f9736f0cd679853824c4c6dac29e5cc", "filename": "gcc/gcse.c", "status": "modified", "additions": 349, "deletions": 458, "changes": 807, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f39ad476ca64351cd077070105f97236c19ae78/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f39ad476ca64351cd077070105f97236c19ae78/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=5f39ad476ca64351cd077070105f97236c19ae78", "patch": "@@ -280,13 +280,8 @@ along with GCC; see the file COPYING3.  If not see\n \f\n /* GCSE global vars.  */\n \n-/* Note whether or not we should run jump optimization after gcse.  We\n-   want to do this for two cases.\n-\n-    * If we changed any jumps via cprop.\n-\n-    * If we added any labels via edge splitting.  */\n-static int run_jump_opt_after_gcse;\n+/* Set to non-zero if CSE should run after all GCSE optimizations are done.  */\n+int flag_rerun_cse_after_global_opts;\n \n /* An obstack for our working variables.  */\n static struct obstack gcse_obstack;\n@@ -370,11 +365,6 @@ static struct hash_table expr_hash_table;\n /* Copy propagation hash table.  */\n static struct hash_table set_hash_table;\n \n-/* Maximum register number in function prior to doing gcse + 1.\n-   Registers created during this pass have regno >= max_gcse_regno.\n-   This is named with \"gcse\" to not collide with global of same name.  */\n-static unsigned int max_gcse_regno;\n-\n /* This is a list of expressions which are MEMs and will be used by load\n    or store motion.\n    Load motion tracks MEMs which aren't killed by\n@@ -450,7 +440,6 @@ static int global_copy_prop_count;\n static sbitmap *ae_kill, *ae_gen;\n \f\n static void compute_can_copy (void);\n-static void recompute_all_luids (void);\n static void *gmalloc (size_t) ATTRIBUTE_MALLOC;\n static void *gcalloc (size_t, size_t) ATTRIBUTE_MALLOC;\n static void *gcse_alloc (unsigned long);\n@@ -502,11 +491,10 @@ static int cprop_jump (basic_block, rtx, rtx, rtx, rtx);\n static void mems_conflict_for_gcse_p (rtx, const_rtx, void *);\n static int load_killed_in_block_p (const_basic_block, int, const_rtx, int);\n static void canon_list_insert (rtx, const_rtx, void *);\n-static int cprop_insn (rtx, int);\n-static int cprop (int);\n+static int cprop_insn (rtx);\n static void find_implicit_sets (void);\n-static int one_cprop_pass (int, bool, bool);\n-static bool constprop_register (rtx, rtx, rtx, bool);\n+static int one_cprop_pass (void);\n+static bool constprop_register (rtx, rtx, rtx);\n static struct expr *find_bypass_set (int, int);\n static bool reg_killed_on_edge (const_rtx, const_edge);\n static int bypass_block (basic_block, rtx, rtx);\n@@ -521,14 +509,14 @@ static void pre_insert_copy_insn (struct expr *, rtx);\n static void pre_insert_copies (void);\n static int pre_delete (void);\n static int pre_gcse (void);\n-static int one_pre_gcse_pass (int);\n+static int one_pre_gcse_pass (void);\n static void add_label_notes (rtx, rtx);\n static void alloc_code_hoist_mem (int, int);\n static void free_code_hoist_mem (void);\n static void compute_code_hoist_vbeinout (void);\n static void compute_code_hoist_data (void);\n static int hoist_expr_reaches_here_p (basic_block, int, basic_block, char *);\n-static void hoist_code (void);\n+static int hoist_code (void);\n static int one_code_hoisting_pass (void);\n static rtx process_insert_insn (struct expr *);\n static int pre_edge_insert (struct edge_list *, struct expr **);\n@@ -566,14 +554,14 @@ static void remove_reachable_equiv_notes (basic_block, struct ls_expr *);\n static void replace_store_insn (rtx, rtx, basic_block, struct ls_expr *);\n static void delete_store (struct ls_expr *, basic_block);\n static void free_store_memory (void);\n-static void store_motion (void);\n+static int one_store_motion_pass (void);\n static void free_insn_expr_list_list (rtx *);\n static void clear_modify_mem_tables (void);\n static void free_modify_mem_tables (void);\n static rtx gcse_emit_move_after (rtx, rtx, rtx);\n static void local_cprop_find_used_regs (rtx *, void *);\n-static bool do_local_cprop (rtx, rtx, bool);\n-static void local_cprop_pass (bool);\n+static bool do_local_cprop (rtx, rtx);\n+static int local_cprop_pass (void);\n static bool is_too_expensive (const char *);\n \n #define GNEW(T)\t\t\t((T *) gmalloc (sizeof (T)))\n@@ -588,155 +576,6 @@ static bool is_too_expensive (const char *);\n #define GOBNEW(T)\t\t((T *) gcse_alloc (sizeof (T)))\n #define GOBNEWVAR(T, S)\t\t((T *) gcse_alloc ((S)))\n \f\n-\n-/* Entry point for global common subexpression elimination.\n-   F is the first instruction in the function.  Return nonzero if a\n-   change is mode.  */\n-\n-static int\n-gcse_main (rtx f ATTRIBUTE_UNUSED)\n-{\n-  int changed;\n-  /* Point to release obstack data from for each pass.  */\n-  char *gcse_obstack_bottom;\n-\n-  /* We do not construct an accurate cfg in functions which call\n-     setjmp, so just punt to be safe.  */\n-  if (cfun->calls_setjmp)\n-    return 0;\n-\n-  /* Assume that we do not need to run jump optimizations after gcse.  */\n-  run_jump_opt_after_gcse = 0;\n-\n-  /* Identify the basic block information for this function, including\n-     successors and predecessors.  */\n-  max_gcse_regno = max_reg_num ();\n-\n-  df_note_add_problem ();\n-  df_analyze ();\n-\n-  if (dump_file)\n-    dump_flow_info (dump_file, dump_flags);\n-\n-  /* Return if there's nothing to do, or it is too expensive.  */\n-  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1\n-      || is_too_expensive (_(\"GCSE disabled\")))\n-    return 0;\n-\n-  gcc_obstack_init (&gcse_obstack);\n-  bytes_used = 0;\n-\n-  /* We need alias.  */\n-  init_alias_analysis ();\n-\n-  gcse_obstack_bottom = GOBNEWVAR (char, 1);\n-  changed = 0;\n- \n-  if (dump_file)\n-    fprintf (dump_file, \"GCSE pass\\n\\n\");\n-\n-  max_gcse_regno = max_reg_num ();\n-\n-  alloc_gcse_mem ();\n-\n-  /* Don't allow constant propagation to modify jumps\n-     during this pass.  */\n-  if (dbg_cnt (cprop1))\n-    {\n-      timevar_push (TV_CPROP1);\n-      changed = one_cprop_pass (1, false, false);\n-      if (changed)\n-        recompute_all_luids ();\n-      timevar_pop (TV_CPROP1);\n-    }\n-\n-  if (optimize_function_for_speed_p (cfun))\n-    {\n-      timevar_push (TV_PRE);\n-      changed |= one_pre_gcse_pass (1);\n-      /* We may have just created new basic blocks.  Release and\n-\t recompute various things which are sized on the number of\n-\t basic blocks.\n-\t ??? There would be no need for this if we used a block\n-\t based Lazy Code Motion variant, with all (or selected)\n-\t edges split before running the pass.  That would also\n-\t help find_implicit_sets for cprop.  FIXME.  */\n-      if (changed)\n-\t{\n-\t  free_modify_mem_tables ();\n-\t  modify_mem_list = GCNEWVEC (rtx, last_basic_block);\n-\t  canon_modify_mem_list = GCNEWVEC (rtx, last_basic_block);\n-\t}\n-\n-      df_analyze ();\n-      run_jump_opt_after_gcse = 1;\n-      timevar_pop (TV_PRE);\n-    }\n-  else\n-    {\n-      /* This function is being optimized for code size.\n-\t It does not make sense to run code hoisting unless we are optimizing\n-\t for code size -- it rarely makes programs faster, and can make\n-\t them bigger if we did partial redundancy elimination (when optimizing\n-\t for space, we don't run the partial redundancy algorithms).  */\n-      timevar_push (TV_HOIST);\n-      max_gcse_regno = max_reg_num ();\n-      alloc_gcse_mem ();\n-      one_code_hoisting_pass ();\n-      timevar_pop (TV_HOIST);\n-    }\n-\n-  free_gcse_mem ();\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"\\n\");\n-      fflush (dump_file);\n-    }\n-\n-  obstack_free (&gcse_obstack, gcse_obstack_bottom);\n-\n-  /* Do the second const/copy propagation pass, including cprop into\n-     conditional jumps.  */\n-  if (dbg_cnt (cprop2))\n-    {\n-      max_gcse_regno = max_reg_num ();\n-      alloc_gcse_mem ();\n-\n-      /* This time, go ahead and allow cprop to alter jumps.  */\n-      timevar_push (TV_CPROP2);\n-      changed = one_cprop_pass (2, true, true);\n-      if (changed)\n-        recompute_all_luids ();\n-      timevar_pop (TV_CPROP2);\n-      free_gcse_mem ();\n-    }\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"GCSE of %s: %d basic blocks, \",\n-\t       current_function_name (), n_basic_blocks);\n-      fprintf (dump_file, \"pass 1, %d bytes\\n\\n\", bytes_used);\n-    }\n-\n-  obstack_free (&gcse_obstack, NULL);\n-\n-  /* We are finished with alias.\n-     ??? Actually we recompute alias in store_motion.  */\n-  end_alias_analysis ();\n-\n-  /* Run store motion.  */\n-  if (optimize_function_for_speed_p (cfun) && flag_gcse_sm)\n-    {\n-      timevar_push (TV_LSM);\n-      store_motion ();\n-      timevar_pop (TV_LSM);\n-    }\n-\n-  /* Record where pseudo-registers are set.  */\n-  return run_jump_opt_after_gcse;\n-}\n-\f\n /* Misc. utilities.  */\n \n /* Nonzero for each mode that supports (set (reg) (reg)).\n@@ -790,19 +629,6 @@ can_copy_p (enum machine_mode mode)\n   return can_copy[mode] != 0;\n }\n \n-/* Recompute the DF LUIDs for all basic blocks.  If a sub-pass in this\n-   file changes something, we have to recompute them for the next pass.\n-   FIXME: If we would track which basic blocks we touch, we could\n-\t  update LUIDs in only those basic blocks.  */\n-\n-static void\n-recompute_all_luids (void)\n-{\n-  basic_block bb;\n-  FOR_EACH_BB (bb)\n-    df_recompute_luids (bb);\n-}\n-\n \f\n /* Cover function to xmalloc to record bytes allocated.  */\n \n@@ -1447,11 +1273,10 @@ insert_set_in_table (rtx x, rtx insn, struct hash_table *table)\n       /* First occurrence of this expression in this basic block.  */\n       cur_occr = GOBNEW (struct occr);\n       bytes_used += sizeof (struct occr);\n-\n-\t  cur_occr->insn = insn;\n-\t  cur_occr->next = cur_expr->avail_occr;\n-\t  cur_occr->deleted_p = 0;\n-\t  cur_expr->avail_occr = cur_occr;\n+      cur_occr->insn = insn;\n+      cur_occr->next = cur_expr->avail_occr;\n+      cur_occr->deleted_p = 0;\n+      cur_expr->avail_occr = cur_occr;\n     }\n }\n \n@@ -1839,14 +1664,14 @@ record_last_set_info (rtx dest, const_rtx setter ATTRIBUTE_UNUSED, void *data)\n static void\n compute_hash_table_work (struct hash_table *table)\n {\n-  unsigned int i;\n+  int i;\n \n   /* re-Cache any INSN_LIST nodes we have allocated.  */\n   clear_modify_mem_tables ();\n   /* Some working arrays used to track first and last set in each block.  */\n-  reg_avail_info = GNEWVEC (struct reg_avail_info, max_gcse_regno);\n+  reg_avail_info = GNEWVEC (struct reg_avail_info, max_reg_num ());\n \n-  for (i = 0; i < max_gcse_regno; ++i)\n+  for (i = 0; i < max_reg_num (); ++i)\n     reg_avail_info[i].last_bb = NULL;\n \n   FOR_EACH_BB (current_bb)\n@@ -2631,8 +2456,6 @@ cprop_jump (basic_block bb, rtx setcc, rtx jump, rtx from, rtx src)\n     delete_insn (setcc);\n #endif\n \n-  run_jump_opt_after_gcse = 1;\n-\n   global_const_prop_count++;\n   if (dump_file != NULL)\n     {\n@@ -2666,14 +2489,13 @@ cprop_jump (basic_block bb, rtx setcc, rtx jump, rtx from, rtx src)\n }\n \n static bool\n-constprop_register (rtx insn, rtx from, rtx to, bool alter_jumps)\n+constprop_register (rtx insn, rtx from, rtx to)\n {\n   rtx sset;\n \n   /* Check for reg or cc0 setting instructions followed by\n      conditional branch instructions first.  */\n-  if (alter_jumps\n-      && (sset = single_set (insn)) != NULL\n+  if ((sset = single_set (insn)) != NULL\n       && NEXT_INSN (insn)\n       && any_condjump_p (NEXT_INSN (insn)) && onlyjump_p (NEXT_INSN (insn)))\n     {\n@@ -2694,7 +2516,7 @@ constprop_register (rtx insn, rtx from, rtx to, bool alter_jumps)\n \n      Right now the insn in question must look like\n      (set (pc) (if_then_else ...))  */\n-  else if (alter_jumps && any_condjump_p (insn) && onlyjump_p (insn))\n+  else if (any_condjump_p (insn) && onlyjump_p (insn))\n     return cprop_jump (BLOCK_FOR_INSN (insn), NULL, insn, from, to);\n   return 0;\n }\n@@ -2703,7 +2525,7 @@ constprop_register (rtx insn, rtx from, rtx to, bool alter_jumps)\n    The result is nonzero if a change was made.  */\n \n static int\n-cprop_insn (rtx insn, int alter_jumps)\n+cprop_insn (rtx insn)\n {\n   struct reg_use *reg_used;\n   int changed = 0;\n@@ -2728,11 +2550,6 @@ cprop_insn (rtx insn, int alter_jumps)\n       rtx pat, src;\n       struct expr *set;\n \n-      /* Ignore registers created by GCSE.\n-\t We do this because ...  */\n-      if (regno >= max_gcse_regno)\n-\tcontinue;\n-\n       /* If the register has already been set in this block, there's\n \t nothing we can do.  */\n       if (! oprs_not_set_p (reg_used->reg_rtx, insn))\n@@ -2753,7 +2570,7 @@ cprop_insn (rtx insn, int alter_jumps)\n       /* Constant propagation.  */\n       if (gcse_constant_p (src))\n \t{\n-          if (constprop_register (insn, reg_used->reg_rtx, src, alter_jumps))\n+          if (constprop_register (insn, reg_used->reg_rtx, src))\n \t    {\n \t      changed = 1;\n \t      global_const_prop_count++;\n@@ -2840,11 +2657,10 @@ local_cprop_find_used_regs (rtx *xptr, void *data)\n   find_used_regs (xptr, data);\n }\n \n-/* Try to perform local const/copy propagation on X in INSN.\n-   If ALTER_JUMPS is false, changing jump insns is not allowed.  */\n+/* Try to perform local const/copy propagation on X in INSN.  */\n \n static bool\n-do_local_cprop (rtx x, rtx insn, bool alter_jumps)\n+do_local_cprop (rtx x, rtx insn)\n {\n   rtx newreg = NULL, newcnst = NULL;\n \n@@ -2877,7 +2693,7 @@ do_local_cprop (rtx x, rtx insn, bool alter_jumps)\n \t\t  || ! MEM_P (XEXP (note, 0))))\n \t    newreg = this_rtx;\n \t}\n-      if (newcnst && constprop_register (insn, x, newcnst, alter_jumps))\n+      if (newcnst && constprop_register (insn, x, newcnst))\n \t{\n \t  if (dump_file != NULL)\n \t    {\n@@ -2907,12 +2723,10 @@ do_local_cprop (rtx x, rtx insn, bool alter_jumps)\n   return false;\n }\n \n-/* Do local const/copy propagation (i.e. within each basic block).\n-   If ALTER_JUMPS is true, allow propagating into jump insns, which\n-   could modify the CFG.  */\n+/* Do local const/copy propagation (i.e. within each basic block).  */\n \n-static void\n-local_cprop_pass (bool alter_jumps)\n+static int\n+local_cprop_pass (void)\n {\n   basic_block bb;\n   rtx insn;\n@@ -2938,7 +2752,7 @@ local_cprop_pass (bool alter_jumps)\n \t\t  for (reg_used = &reg_use_table[0]; reg_use_count > 0;\n \t\t       reg_used++, reg_use_count--)\n \t\t    {\n-\t\t      if (do_local_cprop (reg_used->reg_rtx, insn, alter_jumps))\n+\t\t      if (do_local_cprop (reg_used->reg_rtx, insn))\n \t\t\t{\n \t\t\t  changed = true;\n \t\t\t  break;\n@@ -2958,52 +2772,6 @@ local_cprop_pass (bool alter_jumps)\n \n   cselib_finish ();\n \n-  /* Global analysis may get into infinite loops for unreachable blocks.  */\n-  if (changed && alter_jumps)\n-    delete_unreachable_blocks ();\n-}\n-\n-/* Forward propagate copies.  This includes copies and constants.  Return\n-   nonzero if a change was made.  */\n-\n-static int\n-cprop (int alter_jumps)\n-{\n-  int changed;\n-  basic_block bb;\n-  rtx insn;\n-\n-  /* Note we start at block 1.  */\n-  if (ENTRY_BLOCK_PTR->next_bb == EXIT_BLOCK_PTR)\n-    {\n-      if (dump_file != NULL)\n-\tfprintf (dump_file, \"\\n\");\n-      return 0;\n-    }\n-\n-  changed = 0;\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb->next_bb, EXIT_BLOCK_PTR, next_bb)\n-    {\n-      /* Reset tables used to keep track of what's still valid [since the\n-\t start of the block].  */\n-      reset_opr_set_tables ();\n-\n-      FOR_BB_INSNS (bb, insn)\n-\tif (INSN_P (insn))\n-\t  {\n-\t    changed |= cprop_insn (insn, alter_jumps);\n-\n-\t    /* Keep track of everything modified by this insn.  */\n-\t    /* ??? Need to be careful w.r.t. mods done to INSN.  Don't\n-\t       call mark_oprs_set if we turned the insn into a NOTE.  */\n-\t    if (! NOTE_P (insn))\n-\t      mark_oprs_set (insn);\n-\t  }\n-    }\n-\n-  if (dump_file != NULL)\n-    fprintf (dump_file, \"\\n\");\n-\n   return changed;\n }\n \n@@ -3060,7 +2828,12 @@ implicit_set_cond_p (const_rtx cond)\n    following \"if (x == 2)\", the then branch may be optimized as though the\n    conditional performed an \"explicit set\", in this example, \"x = 2\".  This\n    function records the set patterns that are implicit at the start of each\n-   basic block.  */\n+   basic block.\n+\n+   FIXME: This would be more effective if critical edges are pre-split.  As\n+\t  it is now, we can't record implicit sets for blocks that have\n+\t  critical successor edges.  This results in missed optimizations\n+\t  and in more (unnecessary) work in cfgcleanup.c:thread_jump().  */\n \n static void\n find_implicit_sets (void)\n@@ -3085,7 +2858,9 @@ find_implicit_sets (void)\n \t    dest = GET_CODE (cond) == EQ ? BRANCH_EDGE (bb)->dest\n \t\t\t\t\t : FALLTHRU_EDGE (bb)->dest;\n \n-\t    if (dest && single_pred_p (dest)\n+\t    if (dest\n+\t\t/* Record nothing for a critical edge.  */\n+\t\t&& single_pred_p (dest)\n \t\t&& dest != EXIT_BLOCK_PTR)\n \t      {\n \t\tnew_rtx = gen_rtx_SET (VOIDmode, XEXP (cond, 0),\n@@ -3106,63 +2881,6 @@ find_implicit_sets (void)\n     fprintf (dump_file, \"Found %d implicit sets\\n\", count);\n }\n \n-/* Perform one copy/constant propagation pass.\n-   PASS is the pass count.  If CPROP_JUMPS is true, perform constant\n-   propagation into conditional jumps.  If BYPASS_JUMPS is true,\n-   perform conditional jump bypassing optimizations.  */\n-\n-static int\n-one_cprop_pass (int pass, bool cprop_jumps, bool bypass_jumps)\n-{\n-  int changed = 0;\n-\n-  global_const_prop_count = local_const_prop_count = 0;\n-  global_copy_prop_count = local_copy_prop_count = 0;\n-\n-  if (cprop_jumps)\n-    local_cprop_pass (cprop_jumps);\n-\n-  /* Determine implicit sets.  */\n-  implicit_sets = XCNEWVEC (rtx, last_basic_block);\n-  find_implicit_sets ();\n-\n-  alloc_hash_table (get_max_uid (), &set_hash_table, 1);\n-  compute_hash_table (&set_hash_table);\n-\n-  /* Free implicit_sets before peak usage.  */\n-  free (implicit_sets);\n-  implicit_sets = NULL;\n-\n-  if (dump_file)\n-    dump_hash_table (dump_file, \"SET\", &set_hash_table);\n-  if (set_hash_table.n_elems > 0)\n-    {\n-      alloc_cprop_mem (last_basic_block, set_hash_table.n_elems);\n-      compute_cprop_data ();\n-      changed = cprop (cprop_jumps);\n-      if (bypass_jumps)\n-\tchanged |= bypass_conditional_jumps ();\n-      free_cprop_mem ();\n-    }\n-\n-  free_hash_table (&set_hash_table);\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"CPROP of %s, pass %d: %d bytes needed, \",\n-\t       current_function_name (), pass, bytes_used);\n-      fprintf (dump_file, \"%d local const props, %d local copy props, \",\n-\t       local_const_prop_count, local_copy_prop_count);\n-      fprintf (dump_file, \"%d global const props, %d global copy props\\n\\n\",\n-\t       global_const_prop_count, global_copy_prop_count);\n-    }\n-  /* Global analysis may get into infinite loops for unreachable blocks.  */\n-  if (changed && cprop_jumps)\n-    delete_unreachable_blocks ();\n-\n-  return changed;\n-}\n-\f\n /* Bypass conditional jumps.  */\n \n /* The value of last_basic_block at the beginning of the jump_bypass\n@@ -3302,9 +3020,6 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n \t  struct expr *set;\n \t  rtx src, new_rtx;\n \n-\t  if (regno >= max_gcse_regno)\n-\t    continue;\n-\n \t  set = find_bypass_set (regno, e->src->index);\n \n \t  if (! set)\n@@ -3888,7 +3603,7 @@ pre_edge_insert (struct edge_list *edge_list, struct expr **index_map)\n \n \t\t\tif (dump_file)\n \t\t\t  {\n-\t\t\t    fprintf (dump_file, \"PRE/HOIST: edge (%d,%d), \",\n+\t\t\t    fprintf (dump_file, \"PRE: edge (%d,%d), \",\n \t\t\t\t     bb->index,\n \t\t\t\t     INDEX_EDGE_SUCC_BB (edge_list, e)->index);\n \t\t\t    fprintf (dump_file, \"copy expression %d\\n\",\n@@ -4232,13 +3947,25 @@ pre_gcse (void)\n    Return nonzero if a change was made.  */\n \n static int\n-one_pre_gcse_pass (int pass)\n+one_pre_gcse_pass (void)\n {\n   int changed = 0;\n \n   gcse_subst_count = 0;\n   gcse_create_count = 0;\n \n+  /* Return if there's nothing to do, or it is too expensive.  */\n+  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1\n+      || is_too_expensive (_(\"PRE disabled\")))\n+    return 0;\n+\n+  /* We need alias.  */\n+  init_alias_analysis ();\n+\n+  bytes_used = 0;\n+  gcc_obstack_init (&gcse_obstack);\n+  alloc_gcse_mem ();\n+\n   alloc_hash_table (get_max_uid (), &expr_hash_table, 0);\n   add_noreturn_fake_exit_edges ();\n   if (flag_gcse_lm)\n@@ -4262,10 +3989,16 @@ one_pre_gcse_pass (int pass)\n   remove_fake_exit_edges ();\n   free_hash_table (&expr_hash_table);\n \n+  free_gcse_mem ();\n+  obstack_free (&gcse_obstack, NULL);\n+\n+  /* We are finished with alias.  */\n+  end_alias_analysis ();\n+\n   if (dump_file)\n     {\n-      fprintf (dump_file, \"\\nPRE GCSE of %s, pass %d: %d bytes needed, \",\n-\t       current_function_name (), pass, bytes_used);\n+      fprintf (dump_file, \"PRE GCSE of %s, %d basic blocks, %d bytes needed, \",\n+\t       current_function_name (), n_basic_blocks, bytes_used);\n       fprintf (dump_file, \"%d substs, %d insns created\\n\",\n \t       gcse_subst_count, gcse_create_count);\n     }\n@@ -4530,14 +4263,15 @@ hoist_expr_reaches_here_p (basic_block expr_bb, int expr_index, basic_block bb,\n \f\n /* Actually perform code hoisting.  */\n \n-static void\n+static int\n hoist_code (void)\n {\n   basic_block bb, dominated;\n   VEC (basic_block, heap) *domby;\n   unsigned int i,j;\n   struct expr **index_map;\n   struct expr *expr;\n+  int changed = 0;\n \n   sbitmap_vector_zero (hoist_exprs, last_basic_block);\n \n@@ -4669,6 +4403,9 @@ hoist_code (void)\n \t\t      gcse_emit_move_after (expr->reaching_reg, SET_DEST (set), insn);\n \t\t      delete_insn (insn);\n \t\t      occr->deleted_p = 1;\n+\t\t      changed = 1;\n+\t\t      gcse_subst_count++;\n+\n \t\t      if (!insn_inserted_p)\n \t\t\t{\n \t\t\t  insert_insn_end_basic_block (index_map[i], bb, 0);\n@@ -4682,6 +4419,8 @@ hoist_code (void)\n     }\n \n   free (index_map);\n+\n+  return changed;\n }\n \n /* Top level routine to perform one code hoisting (aka unification) pass\n@@ -4693,6 +4432,21 @@ one_code_hoisting_pass (void)\n {\n   int changed = 0;\n \n+  gcse_subst_count = 0;\n+  gcse_create_count = 0;\n+\n+  /* Return if there's nothing to do, or it is too expensive.  */\n+  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1\n+      || is_too_expensive (_(\"GCSE disabled\")))\n+    return 0;\n+\n+  /* We need alias.  */\n+  init_alias_analysis ();\n+\n+  bytes_used = 0;\n+  gcc_obstack_init (&gcse_obstack);\n+  alloc_gcse_mem ();\n+\n   alloc_hash_table (get_max_uid (), &expr_hash_table, 0);\n   compute_hash_table (&expr_hash_table);\n   if (dump_file)\n@@ -4702,11 +4456,24 @@ one_code_hoisting_pass (void)\n     {\n       alloc_code_hoist_mem (last_basic_block, expr_hash_table.n_elems);\n       compute_code_hoist_data ();\n-      hoist_code ();\n+      changed = hoist_code ();\n       free_code_hoist_mem ();\n     }\n \n   free_hash_table (&expr_hash_table);\n+  free_gcse_mem ();\n+  obstack_free (&gcse_obstack, NULL);\n+\n+  /* We are finished with alias.  */\n+  end_alias_analysis ();\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"HOIST of %s, %d basic blocks, %d bytes needed, \",\n+\t       current_function_name (), n_basic_blocks, bytes_used);\n+      fprintf (dump_file, \"%d substs, %d insns created\\n\",\n+\t       gcse_subst_count, gcse_create_count);\n+    }\n \n   return changed;\n }\n@@ -5441,8 +5208,7 @@ compute_store_table (void)\n   rtx insn, pat, tmp;\n   int *last_set_in, *already_set;\n   struct ls_expr * ptr, **prev_next_ptr_ptr;\n-\n-  max_gcse_regno = max_reg_num ();\n+  unsigned int max_gcse_regno = max_reg_num ();\n \n   pre_ldst_mems = 0;\n   pre_ldst_table = htab_create (13, pre_ldst_expr_hash,\n@@ -5762,6 +5528,7 @@ build_store_vectors (void)\n   int *regs_set_in_block;\n   rtx insn, st;\n   struct ls_expr * ptr;\n+  unsigned int max_gcse_regno = max_reg_num ();\n \n   /* Build the gen_vector. This is any store in the table which is not killed\n      by aliasing later in its block.  */\n@@ -6060,7 +5827,7 @@ replace_store_insn (rtx reg, rtx del, basic_block bb, struct ls_expr *smexpr)\n       fprintf (dump_file,\n \t       \"STORE_MOTION  delete insn in BB %d:\\n      \", bb->index);\n       print_inline_rtx (dump_file, del, 6);\n-      fprintf (dump_file, \"\\nSTORE MOTION  replaced with insn:\\n      \");\n+      fprintf (dump_file, \"\\nSTORE_MOTION  replaced with insn:\\n      \");\n       print_inline_rtx (dump_file, insn, 6);\n       fprintf (dump_file, \"\\n\");\n     }\n@@ -6142,21 +5909,19 @@ free_store_memory (void)\n }\n \n /* Perform store motion. Much like gcse, except we move expressions the\n-   other way by looking at the flowgraph in reverse.  */\n+   other way by looking at the flowgraph in reverse.\n+   Return non-zero if transformations are performed by the pass.  */\n \n-static void\n-store_motion (void)\n+static int\n+one_store_motion_pass (void)\n {\n   basic_block bb;\n   int x;\n   struct ls_expr * ptr;\n   int update_flow = 0;\n \n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"before store motion\\n\");\n-      print_rtl (dump_file, get_insns ());\n-    }\n+  gcse_subst_count = 0;\n+  gcse_create_count = 0;\n \n   init_alias_analysis ();\n \n@@ -6167,7 +5932,7 @@ store_motion (void)\n       htab_delete (pre_ldst_table);\n       pre_ldst_table = NULL;\n       end_alias_analysis ();\n-      return;\n+      return 0;\n     }\n \n   /* Now compute kill & transp vectors.  */\n@@ -6203,11 +5968,17 @@ store_motion (void)\n \n       FOR_EACH_BB (bb)\n \tif (TEST_BIT (pre_delete_map[bb->index], ptr->index))\n-\t  delete_store (ptr, bb);\n+\t  {\n+\t    delete_store (ptr, bb);\n+\t    gcse_subst_count++;\n+\t  }\n \n       for (x = 0; x < NUM_EDGES (edge_list); x++)\n \tif (TEST_BIT (pre_insert_map[x], ptr->index))\n-\t  update_flow |= insert_store (ptr, INDEX_EDGE (edge_list, x));\n+\t  {\n+\t    update_flow |= insert_store (ptr, INDEX_EDGE (edge_list, x));\n+\t    gcse_create_count++;\n+\t  }\n     }\n \n   if (update_flow)\n@@ -6217,59 +5988,19 @@ store_motion (void)\n   free_edge_list (edge_list);\n   remove_fake_exit_edges ();\n   end_alias_analysis ();\n-}\n-\n-\f\n-/* Entry point for jump bypassing optimization pass.  */\n-\n-static int\n-bypass_jumps (void)\n-{\n-  int changed;\n-\n-  /* We do not construct an accurate cfg in functions which call\n-     setjmp, so just punt to be safe.  */\n-  if (cfun->calls_setjmp)\n-    return 0;\n-\n-  /* Identify the basic block information for this function, including\n-     successors and predecessors.  */\n-  max_gcse_regno = max_reg_num ();\n-\n-  if (dump_file)\n-    dump_flow_info (dump_file, dump_flags);\n-\n-  /* Return if there's nothing to do, or it is too expensive.  */\n-  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1\n-      || is_too_expensive (_ (\"jump bypassing disabled\")))\n-    return 0;\n-\n-  gcc_obstack_init (&gcse_obstack);\n-  bytes_used = 0;\n-\n-  /* We need alias.  */\n-  init_alias_analysis ();\n-\n-  max_gcse_regno = max_reg_num ();\n-  alloc_gcse_mem ();\n-  changed = one_cprop_pass (3, true, true);\n-  free_gcse_mem ();\n \n   if (dump_file)\n     {\n-      fprintf (dump_file, \"BYPASS of %s: %d basic blocks, \",\n+      fprintf (dump_file, \"STORE_MOTION of %s, %d basic blocks, \",\n \t       current_function_name (), n_basic_blocks);\n-      fprintf (dump_file, \"%d bytes\\n\\n\", bytes_used);\n+      fprintf (dump_file, \"%d substs, %d insns created\\n\",\n+\t       gcse_subst_count, gcse_create_count);\n     }\n \n-  obstack_free (&gcse_obstack, NULL);\n-\n-  /* We are finished with alias.  */\n-  end_alias_analysis ();\n-\n-  return changed;\n+  return (gcse_subst_count > 0 || gcse_create_count > 0);\n }\n \n+\f\n /* Return true if the graph is too expensive to optimize. PASS is the\n    optimization about to be performed.  */\n \n@@ -6309,110 +6040,250 @@ is_too_expensive (const char *pass)\n \n   return false;\n }\n+\n \f\n+/* Main function for the CPROP pass.  */\n+\n+static int\n+one_cprop_pass (void)\n+{\n+  int changed = 0;\n+\n+  /* Return if there's nothing to do, or it is too expensive.  */\n+  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1\n+      || is_too_expensive (_ (\"const/copy propagation disabled\")))\n+    return 0;\n+\n+  global_const_prop_count = local_const_prop_count = 0;\n+  global_copy_prop_count = local_copy_prop_count = 0;\n+\n+  bytes_used = 0;\n+  gcc_obstack_init (&gcse_obstack);\n+  alloc_gcse_mem ();\n+\n+  /* Do a local const/copy propagation pass first.  The global pass\n+     only handles global opportunities.\n+     If the local pass changes something, remove any unreachable blocks\n+     because the CPROP global dataflow analysis may get into infinite\n+     loops for CFGs with unreachable blocks.\n+\n+     FIXME: This local pass should not be necessary after CSE (but for\n+\t    some reason it still is).  It is also (proven) not necessary\n+\t    to run the local pass right after FWPWOP.\n+\t    \n+     FIXME: The global analysis would not get into infinite loops if it\n+\t    would use the DF solver (via df_simple_dataflow) instead of\n+\t    the solver implemented in this file.  */\n+  if (local_cprop_pass ())\n+    {\n+      delete_unreachable_blocks ();\n+      df_analyze ();\n+    }\n+\n+  /* Determine implicit sets.  */\n+  implicit_sets = XCNEWVEC (rtx, last_basic_block);\n+  find_implicit_sets ();\n+\n+  alloc_hash_table (get_max_uid (), &set_hash_table, 1);\n+  compute_hash_table (&set_hash_table);\n+\n+  /* Free implicit_sets before peak usage.  */\n+  free (implicit_sets);\n+  implicit_sets = NULL;\n+\n+  if (dump_file)\n+    dump_hash_table (dump_file, \"SET\", &set_hash_table);\n+  if (set_hash_table.n_elems > 0)\n+    {\n+      basic_block bb;\n+      rtx insn;\n+\n+      alloc_cprop_mem (last_basic_block, set_hash_table.n_elems);\n+      compute_cprop_data ();\n+\n+      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb->next_bb, EXIT_BLOCK_PTR, next_bb)\n+\t{\n+\t  /* Reset tables used to keep track of what's still valid [since\n+\t     the start of the block].  */\n+\t  reset_opr_set_tables ();\n+\n+\t  FOR_BB_INSNS (bb, insn)\n+\t    if (INSN_P (insn))\n+\t      {\n+\t\tchanged |= cprop_insn (insn);\n+\n+\t\t/* Keep track of everything modified by this insn.  */\n+\t\t/* ??? Need to be careful w.r.t. mods done to INSN.\n+\t\t       Don't call mark_oprs_set if we turned the\n+\t\t       insn into a NOTE.  */\n+\t\tif (! NOTE_P (insn))\n+\t\t  mark_oprs_set (insn);\n+\t      }\n+\t}\n+\n+      changed |= bypass_conditional_jumps ();\n+      free_cprop_mem ();\n+    }\n+\n+  free_hash_table (&set_hash_table);\n+  free_gcse_mem ();\n+  obstack_free (&gcse_obstack, NULL);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"CPROP of %s, %d basic blocks, %d bytes needed, \",\n+\t       current_function_name (), n_basic_blocks, bytes_used);\n+      fprintf (dump_file, \"%d local const props, %d local copy props, \",\n+\t       local_const_prop_count, local_copy_prop_count);\n+      fprintf (dump_file, \"%d global const props, %d global copy props\\n\\n\",\n+\t       global_const_prop_count, global_copy_prop_count);\n+    }\n+\n+  return changed;\n+}\n+\n+\f\n+/* All the passes implemented in this file.  Each pass has its\n+   own gate and execute function, and at the end of the file a\n+   pass definition for passes.c.\n+\n+   We do not construct an accurate cfg in functions which call\n+   setjmp, so none of these passes runs if the function calls\n+   setjmp.\n+   FIXME: Should just handle setjmp via REG_SETJMP notes.  */\n+\n static bool\n-gate_handle_jump_bypass (void)\n+gate_rtl_cprop (void)\n {\n   return optimize > 0 && flag_gcse\n-    && dbg_cnt (jump_bypass);\n+    && !cfun->calls_setjmp\n+    && dbg_cnt (cprop);\n }\n \n-/* Perform jump bypassing and control flow optimizations.  */\n static unsigned int\n-rest_of_handle_jump_bypass (void)\n+execute_rtl_cprop (void)\n {\n   delete_unreachable_blocks ();\n-  if (bypass_jumps ())\n-    {\n-      delete_trivially_dead_insns (get_insns (), max_reg_num ());\n-      rebuild_jump_labels (get_insns ());\n-      cleanup_cfg (0);\n-    }\n+  df_note_add_problem ();\n+  df_set_flags (DF_LR_RUN_DCE);\n+  df_analyze ();\n+  flag_rerun_cse_after_global_opts |= one_cprop_pass ();\n+  return 0;\n+}\n+\n+static bool\n+gate_rtl_pre (void)\n+{\n+  return optimize > 0 && flag_gcse\n+    && !cfun->calls_setjmp\n+    && optimize_function_for_speed_p (cfun)\n+    && dbg_cnt (pre);\n+}\n+\n+static unsigned int\n+execute_rtl_pre (void)\n+{\n+  delete_unreachable_blocks ();\n+  df_note_add_problem ();\n+  df_analyze ();\n+  flag_rerun_cse_after_global_opts |= one_pre_gcse_pass ();\n+  return 0;\n+}\n+\n+static bool\n+gate_rtl_hoist (void)\n+{\n+  return optimize > 0 && flag_gcse\n+    && !cfun->calls_setjmp\n+    /* It does not make sense to run code hoisting unless we are optimizing\n+       for code size -- it rarely makes programs faster, and can make then\n+       bigger if we did PRE (when optimizing for space, we don't run PRE).  */\n+    && optimize_function_for_size_p (cfun)\n+    && dbg_cnt (hoist);\n+}\n+\n+static unsigned int\n+execute_rtl_hoist (void)\n+{\n+  delete_unreachable_blocks ();\n+  df_note_add_problem ();\n+  df_analyze ();\n+  flag_rerun_cse_after_global_opts |= one_code_hoisting_pass ();\n+  return 0;\n+}\n+\n+static bool\n+gate_rtl_store_motion (void)\n+{\n+  return optimize > 0 && flag_gcse_sm\n+    && !cfun->calls_setjmp\n+    && optimize_function_for_speed_p (cfun)\n+    && dbg_cnt (store_motion);\n+}\n+\n+static unsigned int\n+execute_rtl_store_motion (void)\n+{\n+  delete_unreachable_blocks ();\n+  df_note_add_problem ();\n+  df_analyze ();\n+  flag_rerun_cse_after_global_opts |= one_store_motion_pass ();\n   return 0;\n }\n \n-struct rtl_opt_pass pass_jump_bypass =\n+struct rtl_opt_pass pass_rtl_cprop =\n {\n  {\n   RTL_PASS,\n-  \"bypass\",                             /* name */\n-  gate_handle_jump_bypass,              /* gate */   \n-  rest_of_handle_jump_bypass,           /* execute */       \n+  \"cprop\",                              /* name */\n+  gate_rtl_cprop,                       /* gate */   \n+  execute_rtl_cprop,  \t\t\t/* execute */       \n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */\n-  TV_BYPASS,                            /* tv_id */\n+  TV_CPROP,                             /* tv_id */\n   PROP_cfglayout,                       /* properties_required */\n   0,                                    /* properties_provided */\n   0,                                    /* properties_destroyed */\n   0,                                    /* todo_flags_start */\n+  TODO_df_finish | TODO_verify_rtl_sharing |\n   TODO_dump_func |\n-  TODO_ggc_collect | TODO_verify_flow   /* todo_flags_finish */\n+  TODO_verify_flow | TODO_ggc_collect   /* todo_flags_finish */\n  }\n };\n \n-\n-static bool\n-gate_handle_gcse (void)\n+struct rtl_opt_pass pass_rtl_pre =\n {\n-  return optimize > 0 && flag_gcse\n-    && dbg_cnt (gcse);\n-}\n-\n-\n-static unsigned int\n-rest_of_handle_gcse (void)\n-{\n-  int save_csb, save_cfj;\n-  int tem2 = 0, tem;\n-  tem = gcse_main (get_insns ());\n-  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n-  rebuild_jump_labels (get_insns ());\n-  save_csb = flag_cse_skip_blocks;\n-  save_cfj = flag_cse_follow_jumps;\n-  flag_cse_skip_blocks = flag_cse_follow_jumps = 0;\n-\n-  /* If -fexpensive-optimizations, re-run CSE to clean up things done\n-     by gcse.  */\n-  if (flag_expensive_optimizations)\n-    {\n-      timevar_push (TV_CSE);\n-      tem2 = cse_main (get_insns (), max_reg_num ());\n-      df_finish_pass (false);\n-      purge_all_dead_edges ();\n-      delete_trivially_dead_insns (get_insns (), max_reg_num ());\n-      timevar_pop (TV_CSE);\n-      cse_not_expected = !flag_rerun_cse_after_loop;\n-    }\n-\n-  /* If gcse or cse altered any jumps, rerun jump optimizations to clean\n-     things up.  */\n-  if (tem || tem2 == 2)\n-    {\n-      timevar_push (TV_JUMP);\n-      rebuild_jump_labels (get_insns ());\n-      cleanup_cfg (0);\n-      timevar_pop (TV_JUMP);\n-    }\n-  else if (tem2 == 1)\n-    cleanup_cfg (0);\n-\n-  flag_cse_skip_blocks = save_csb;\n-  flag_cse_follow_jumps = save_cfj;\n-  return 0;\n-}\n+ {\n+  RTL_PASS,\n+  \"pre\",                                /* name */\n+  gate_rtl_pre,                         /* gate */   \n+  execute_rtl_pre,    \t\t\t/* execute */       \n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_PRE,                               /* tv_id */\n+  PROP_cfglayout,                       /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_df_finish | TODO_verify_rtl_sharing |\n+  TODO_dump_func |\n+  TODO_verify_flow | TODO_ggc_collect   /* todo_flags_finish */\n+ }\n+};\n \n-struct rtl_opt_pass pass_gcse =\n+struct rtl_opt_pass pass_rtl_hoist =\n {\n  {\n   RTL_PASS,\n-  \"gcse1\",                              /* name */\n-  gate_handle_gcse,                     /* gate */   \n-  rest_of_handle_gcse,\t\t\t/* execute */       \n+  \"hoist\",                              /* name */\n+  gate_rtl_hoist,                       /* gate */   \n+  execute_rtl_hoist,  \t\t\t/* execute */       \n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */\n-  TV_GCSE,                              /* tv_id */\n+  TV_HOIST,                             /* tv_id */\n   PROP_cfglayout,                       /* properties_required */\n   0,                                    /* properties_provided */\n   0,                                    /* properties_destroyed */\n@@ -6423,5 +6294,25 @@ struct rtl_opt_pass pass_gcse =\n  }\n };\n \n+struct rtl_opt_pass pass_rtl_store_motion =\n+{\n+ {\n+  RTL_PASS,\n+  \"store_motion\",                       /* name */\n+  gate_rtl_store_motion,                /* gate */   \n+  execute_rtl_store_motion,\t\t/* execute */       \n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_LSM,                               /* tv_id */\n+  PROP_cfglayout,                       /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_df_finish | TODO_verify_rtl_sharing |\n+  TODO_dump_func |\n+  TODO_verify_flow | TODO_ggc_collect   /* todo_flags_finish */\n+ }\n+};\n \n #include \"gt-gcse.h\""}, {"sha": "312dfa9db72b5d8af2fce08d9e647e3e1ebe8916", "filename": "gcc/passes.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f39ad476ca64351cd077070105f97236c19ae78/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f39ad476ca64351cd077070105f97236c19ae78/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=5f39ad476ca64351cd077070105f97236c19ae78", "patch": "@@ -729,7 +729,12 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_df_initialize_opt);\n       NEXT_PASS (pass_cse);\n       NEXT_PASS (pass_rtl_fwprop);\n-      NEXT_PASS (pass_gcse);\n+      NEXT_PASS (pass_rtl_cprop);\n+      NEXT_PASS (pass_rtl_pre);\n+      NEXT_PASS (pass_rtl_hoist);\n+      NEXT_PASS (pass_rtl_cprop);\n+      NEXT_PASS (pass_rtl_store_motion);\n+      NEXT_PASS (pass_cse_after_global_opts);\n       NEXT_PASS (pass_rtl_ifcvt);\n       /* Perform loop optimizations.  It might be better to do them a bit\n \t sooner, but we want the profile feedback to work more\n@@ -746,7 +751,7 @@ init_optimization_passes (void)\n \t  *p = NULL;\n \t}\n       NEXT_PASS (pass_web);\n-      NEXT_PASS (pass_jump_bypass);\n+      NEXT_PASS (pass_rtl_cprop);\n       NEXT_PASS (pass_cse2);\n       NEXT_PASS (pass_rtl_dse1);\n       NEXT_PASS (pass_rtl_fwprop_addr);"}, {"sha": "d3510a23af0db0f83d19a4a96449500f4bc0b064", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f39ad476ca64351cd077070105f97236c19ae78/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f39ad476ca64351cd077070105f97236c19ae78/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=5f39ad476ca64351cd077070105f97236c19ae78", "patch": "@@ -154,13 +154,10 @@ DEFTIMEVAR (TV_DCE                   , \"dead code elimination\")\n DEFTIMEVAR (TV_DSE1                  , \"dead store elim1\")\n DEFTIMEVAR (TV_DSE2                  , \"dead store elim2\")\n DEFTIMEVAR (TV_LOOP                  , \"loop analysis\")\n-DEFTIMEVAR (TV_GCSE                  , \"global CSE\")\n-DEFTIMEVAR (TV_CPROP1                , \"CPROP 1\")\n+DEFTIMEVAR (TV_CPROP                 , \"CPROP\")\n DEFTIMEVAR (TV_PRE                   , \"PRE\")\n DEFTIMEVAR (TV_HOIST                 , \"code hoisting\")\n-DEFTIMEVAR (TV_CPROP2                , \"CPROP 2\")\n DEFTIMEVAR (TV_LSM                   , \"LSM\")\n-DEFTIMEVAR (TV_BYPASS                , \"bypass jumps\")\n DEFTIMEVAR (TV_TRACER                , \"tracer\")\n DEFTIMEVAR (TV_WEB                   , \"web\")\n DEFTIMEVAR (TV_AUTO_INC_DEC          , \"auto inc dec\")"}, {"sha": "28f5d0c4b17e140b1e042e035922d60cffb7e21b", "filename": "gcc/toplev.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f39ad476ca64351cd077070105f97236c19ae78/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f39ad476ca64351cd077070105f97236c19ae78/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=5f39ad476ca64351cd077070105f97236c19ae78", "patch": "@@ -132,6 +132,7 @@ extern int flag_if_conversion;\n extern int flag_if_conversion2;\n extern int flag_keep_static_consts;\n extern int flag_peel_loops;\n+extern int flag_rerun_cse_after_global_opts;\n extern int flag_rerun_cse_after_loop;\n extern int flag_thread_jumps;\n extern int flag_tracer;"}, {"sha": "8ce7c3ae81b812b628594bcf85543c4113cad442", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f39ad476ca64351cd077070105f97236c19ae78/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f39ad476ca64351cd077070105f97236c19ae78/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=5f39ad476ca64351cd077070105f97236c19ae78", "patch": "@@ -394,6 +394,7 @@ extern struct gimple_opt_pass pass_rebuild_cgraph_edges;\n extern struct gimple_opt_pass pass_remove_cgraph_callee_edges;\n extern struct gimple_opt_pass pass_build_cgraph_edges;\n extern struct gimple_opt_pass pass_local_pure_const;\n+extern struct gimple_opt_pass pass_tracer;\n \n /* IPA Passes */\n extern struct ipa_opt_pass pass_ipa_inline;\n@@ -433,11 +434,12 @@ extern struct rtl_opt_pass pass_rtl_dce;\n extern struct rtl_opt_pass pass_rtl_dse1;\n extern struct rtl_opt_pass pass_rtl_dse2;\n extern struct rtl_opt_pass pass_rtl_dse3;\n-extern struct rtl_opt_pass pass_gcse;\n-extern struct rtl_opt_pass pass_jump_bypass;\n-extern struct rtl_opt_pass pass_profiling;\n+extern struct rtl_opt_pass pass_rtl_cprop;\n+extern struct rtl_opt_pass pass_rtl_pre;\n+extern struct rtl_opt_pass pass_rtl_hoist;\n+extern struct rtl_opt_pass pass_rtl_store_motion;\n+extern struct rtl_opt_pass pass_cse_after_global_opts;\n extern struct rtl_opt_pass pass_rtl_ifcvt;\n-extern struct gimple_opt_pass pass_tracer;\n \n extern struct rtl_opt_pass pass_into_cfg_layout_mode;\n extern struct rtl_opt_pass pass_outof_cfg_layout_mode;"}]}