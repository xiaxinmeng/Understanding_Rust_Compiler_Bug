{"sha": "bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ3Y2YxN2VmZDM4Yjk0ZjI2YmNmMGMzMDljNmI5MDUzYzBhMjFkZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2000-11-14T17:37:19Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2000-11-14T17:37:19Z"}, "message": "varasm.c (struct deferred_string): New structure.\n\n\t* varasm.c (struct deferred_string): New structure.\n\t(const_str_htab): New variable.\n\t(STRHASH): New macro.\n\t(mark_const_str_htab_1, mark_const_str_htab, const_str_htab_hash,\n\tconstr_str_htab_eq, const_str_htab_del): New functions.\n\t(output_constant_def): Add DEFER argument, defer string\n\tconstants until mark_constant_pool time if requested.\n\t(mark_constant_pool): Walk the insn chain even if const_str_htab is\n\tnot empty.\n\t(mark_constants): If a SYMBOL_REF for deferred string is found,\n\toutput it and remove from hash table.\n\t(output_addressed_constants): Set DEFER to 0 in call to\n\toutput_constant_def.\n\t* rtl.h (STRING_POOL_ADDRESS_P): Define.\n\t(output_constant_def): Adjust prototype.\n\t* expr.c (expand_expr): Set DEFER to 1 in call to output_constant_def.\n\n\t* gcc.c-torture/execute/20000801-4.c: Make sure the second string is\n\toutput.\n\nFrom-SVN: r37459", "tree": {"sha": "b5c71843b63df50a1d55b0f1bf1e75e0c89fa1d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5c71843b63df50a1d55b0f1bf1e75e0c89fa1d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "10e927efe90d9c6bef3ec33a1faeb98cfdde88ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10e927efe90d9c6bef3ec33a1faeb98cfdde88ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10e927efe90d9c6bef3ec33a1faeb98cfdde88ee"}], "stats": {"total": 205, "additions": 186, "deletions": 19}, "files": [{"sha": "e0dd9f7e968add6e5136d7dff748654b6d7f697e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd", "patch": "@@ -1,3 +1,22 @@\n+2000-11-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* varasm.c (struct deferred_string): New structure.\n+\t(const_str_htab): New variable.\n+\t(STRHASH): New macro.\n+\t(mark_const_str_htab_1, mark_const_str_htab, const_str_htab_hash,\n+\tconstr_str_htab_eq, const_str_htab_del): New functions.\n+\t(output_constant_def): Add DEFER argument, defer string\n+\tconstants until mark_constant_pool time if requested.\n+\t(mark_constant_pool): Walk the insn chain even if const_str_htab is\n+\tnot empty.\n+\t(mark_constants): If a SYMBOL_REF for deferred string is found,\n+\toutput it and remove from hash table.\n+\t(output_addressed_constants): Set DEFER to 0 in call to\n+\toutput_constant_def.\n+\t* rtl.h (STRING_POOL_ADDRESS_P): Define.\n+\t(output_constant_def): Adjust prototype.\n+\t* expr.c (expand_expr): Set DEFER to 1 in call to output_constant_def.\n+\n 2000-11-14  Chandrakala Chavva  <cchavva@redhat.com>\n \n \t* optabs.c (expand_complex_ab):: Use overflow-trapping optabs for"}, {"sha": "35ccf0359a9a0446c6ae9e9dd65cda2a212b2ddc", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd", "patch": "@@ -6143,7 +6143,7 @@ expand_expr (exp, target, tmode, modifier)\n     case COMPLEX_CST:\n     case STRING_CST:\n       if (! TREE_CST_RTL (exp))\n-\toutput_constant_def (exp);\n+\toutput_constant_def (exp, 1);\n \n       /* TREE_CST_RTL probably contains a constant address.\n \t On RISC machines where a constant address isn't valid,\n@@ -6456,7 +6456,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t&& ! mostly_zeros_p (exp))))\n \t       || (modifier == EXPAND_INITIALIZER && TREE_CONSTANT (exp)))\n \t{\n-\t  rtx constructor = output_constant_def (exp);\n+\t  rtx constructor = output_constant_def (exp, 1);\n \n \t  if (modifier != EXPAND_CONST_ADDRESS\n \t      && modifier != EXPAND_INITIALIZER"}, {"sha": "762226cd3d49a5d97276599920a24660eec4450e", "filename": "gcc/rtl.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd", "patch": "@@ -168,7 +168,9 @@ typedef struct rtx_def\n      either changing how we compute the frame address or saving and\n      restoring registers in the prologue and epilogue.\n      1 in a MEM if the MEM refers to a scalar, rather than a member of\n-     an aggregate.  */\n+     an aggregate.\n+     1 in a SYMBOL_REF if it addresses something in the per-function\n+     constant string pool.  */\n   unsigned frame_related : 1;\n \n   /* The first element of the operands of this rtx.\n@@ -904,6 +906,9 @@ extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n /* 1 in a SYMBOL_REF if it addresses this function's constants pool.  */\n #define CONSTANT_POOL_ADDRESS_P(RTX) ((RTX)->unchanging)\n \n+/* 1 in a SYMBOL_REF if it addresses this function's string constant pool.  */\n+#define STRING_POOL_ADDRESS_P(RTX) ((RTX)->frame_related)\n+\n /* Flag in a SYMBOL_REF for machine-specific purposes.  */\n #define SYMBOL_REF_FLAG(RTX) ((RTX)->volatil)\n \n@@ -1587,7 +1592,7 @@ extern rtx gen_rtx_MEM PARAMS ((enum machine_mode, rtx));\n extern rtx find_next_ref\t\tPARAMS ((rtx, rtx));\n extern rtx *find_single_use\t\tPARAMS ((rtx, rtx, rtx *));\n \n-extern rtx output_constant_def\t\tPARAMS ((union tree_node *));\n+extern rtx output_constant_def\t\tPARAMS ((union tree_node *, int));\n extern rtx immed_real_const\t\tPARAMS ((union tree_node *));\n extern union tree_node *make_tree\tPARAMS ((union tree_node *, rtx));\n "}, {"sha": "ab2666689a4a0a7931863d1a7e6b507ec55ce725", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd", "patch": "@@ -1,3 +1,8 @@\n+2000-11-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.c-torture/execute/20000801-4.c: Make sure the second string is\n+\toutput.\n+\n 2000-11-13  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* gcc.dg/wtr-label-1.c, gcc.dg/990214-1.c: Add semicolons after"}, {"sha": "dd6227d05fb9a427e9254e06a36830cf9ff569dc", "filename": "gcc/testsuite/gcc.c-torture/execute/20000801-4.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20000801-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20000801-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20000801-4.c?ref=bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd", "patch": "@@ -14,11 +14,14 @@ foo (void)\n   return 0 == s[1];\n }\n \n+char *t;\n+\n int\n main (void)\n {\n   {\n     char s[] = \"x\";\n+    t = s;\n   }\n   if (foo ())\n     exit (0);"}, {"sha": "0fc4ea8aa4a370dcf6721f55725b68ea0a73a8a4", "filename": "gcc/varasm.c", "status": "modified", "additions": 150, "deletions": 15, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd", "patch": "@@ -44,6 +44,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"dbxout.h\"\n #include \"sdbout.h\"\n #include \"obstack.h\"\n+#include \"hashtab.h\"\n #include \"c-pragma.h\"\n #include \"ggc.h\"\n #include \"tm_p.h\"\n@@ -185,6 +186,11 @@ static void asm_output_aligned_bss\tPARAMS ((FILE *, tree, const char *,\n #endif /* BSS_SECTION_ASM_OP */\n static void mark_pool_constant          PARAMS ((struct pool_constant *));\n static void mark_const_hash_entry\tPARAMS ((void *));\n+static int mark_const_str_htab_1\tPARAMS ((void **, void *));\n+static void mark_const_str_htab\t\tPARAMS ((void *));\n+static hashval_t const_str_htab_hash\tPARAMS ((const void *x));\n+static int const_str_htab_eq\t\tPARAMS ((const void *x, const void *y));\n+static void const_str_htab_del\t\tPARAMS ((void *));\n static void asm_emit_uninitialised\tPARAMS ((tree, const char*, int, int));\n \f\n static enum in_section { no_section, in_text, in_data, in_named\n@@ -2342,6 +2348,17 @@ struct constant_descriptor\n #define MAX_HASH_TABLE 1009\n static struct constant_descriptor *const_hash_table[MAX_HASH_TABLE];\n \n+#define STRHASH(x) ((hashval_t)((long)(x) >> 3))\n+\n+struct deferred_string\n+{\n+  char *label;\n+  tree exp;\n+  int labelno;\n+};\n+\n+static htab_t const_str_htab;\n+\n /* Mark a const_hash_table descriptor for GC.  */\n \n static void \n@@ -2358,6 +2375,58 @@ mark_const_hash_entry (ptr)\n     }\n }\n \n+/* Mark the hash-table element X (which is really a pointer to an\n+   struct deferred_string *).  */\n+   \n+static int\n+mark_const_str_htab_1 (x, data)\n+     void **x;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  ggc_mark_tree (((struct deferred_string *) *x)->exp);\n+  return 1;\n+}\n+\n+/* Mark a const_str_htab for GC.  */\n+\n+static void \n+mark_const_str_htab (htab)\n+     void *htab;\n+{\n+  htab_traverse (*((htab_t *) htab), mark_const_str_htab_1, NULL);\n+}\n+\n+/* Returns a hash code for X (which is a really a\n+   struct deferred_string *).  */\n+\n+static hashval_t\n+const_str_htab_hash (x)\n+     const void *x;\n+{\n+  return STRHASH (((struct deferred_string *) x)->label);\n+}\n+\n+/* Returns non-zero if the value represented by X (which is really a\n+   struct deferred_string *) is the same as that given by Y\n+   (which is really a char *).  */\n+\n+static int\n+const_str_htab_eq (x, y)\n+     const void *x;\n+     const void *y;\n+{\n+  return (((struct deferred_string *) x)->label == (char *) y);\n+}\n+\n+/* Delete the hash table entry dfsp.  */\n+\n+static void\n+const_str_htab_del (dfsp)\n+    void *dfsp;\n+{\n+  free (dfsp);\n+}\n+\n /* Compute a hash code for a constant expression.  */\n \n static int\n@@ -3056,18 +3125,25 @@ copy_constant (exp)\n    Otherwise, output such a constant in memory (or defer it for later)\n    and generate an rtx for it.\n \n+   If DEFER is non-zero, the output of string constants can be deferred\n+   and output only if referenced in the function after all optimizations.\n+\n    The TREE_CST_RTL of EXP is set up to point to that rtx.\n    The const_hash_table records which constants already have label strings.  */\n \n rtx\n-output_constant_def (exp)\n+output_constant_def (exp, defer)\n      tree exp;\n+     int defer;\n {\n   register int hash;\n   register struct constant_descriptor *desc;\n+  struct deferred_string **defstr;\n   char label[256];\n   int reloc;\n   int found = 1;\n+  int after_function = 0;\n+  int labelno = -1;\n \n   if (TREE_CST_RTL (exp))\n     return TREE_CST_RTL (exp);\n@@ -3095,7 +3171,8 @@ output_constant_def (exp)\n \t future calls to this function to find.  */\n \t  \n       /* Create a string containing the label name, in LABEL.  */\n-      ASM_GENERATE_INTERNAL_LABEL (label, \"LC\", const_labelno);\n+      labelno = const_labelno++;\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"LC\", labelno);\n \n       desc = record_constant (exp);\n       desc->next = const_hash_table[hash];\n@@ -3121,26 +3198,42 @@ output_constant_def (exp)\n   ENCODE_SECTION_INFO (exp);\n #endif\n \n+#ifdef CONSTANT_AFTER_FUNCTION_P\n+  if (current_function_decl != 0\n+      && CONSTANT_AFTER_FUNCTION_P (exp))\n+    after_function = 1;\n+#endif\n+\n+  if (found\n+      && STRING_POOL_ADDRESS_P (XEXP (desc->rtl, 0))\n+      && (!defer || defer_addressed_constants_flag || after_function))\n+    {\n+      defstr = (struct deferred_string **)\n+\thtab_find_slot_with_hash (const_str_htab, desc->label,\n+\t\t\t\t  STRHASH (desc->label), NO_INSERT);\n+      if (defstr)\n+\t{\n+\t  /* If the string is currently deferred but we need to output it now,\n+\t     remove it from deferred string hash table.  */\n+\t  found = 0;\n+\t  labelno = (*defstr)->labelno;\n+\t  STRING_POOL_ADDRESS_P (XEXP (desc->rtl, 0)) = 0;\n+\t  htab_clear_slot (const_str_htab, (void **) defstr);\n+\t}\n+    }\n+\n   /* If this is the first time we've seen this particular constant,\n      output it (or defer its output for later).  */\n   if (! found)\n     {\n-      int after_function = 0;\n-\n-#ifdef CONSTANT_AFTER_FUNCTION_P\n-      if (current_function_decl != 0\n-\t  && CONSTANT_AFTER_FUNCTION_P (exp))\n-\tafter_function = 1;\n-#endif\n-\n       if (defer_addressed_constants_flag || after_function)\n \t{\n \t  struct deferred_constant *p;\n \t  p = (struct deferred_constant *) xmalloc (sizeof (struct deferred_constant));\n \n \t  p->exp = copy_constant (exp);\n \t  p->reloc = reloc;\n-\t  p->labelno = const_labelno++;\n+\t  p->labelno = labelno;\n \t  if (after_function)\n \t    {\n \t      p->next = after_function_constants;\n@@ -3156,8 +3249,30 @@ output_constant_def (exp)\n \t{\n \t  /* Do no output if -fsyntax-only.  */\n \t  if (! flag_syntax_only)\n-\t    output_constant_def_contents (exp, reloc, const_labelno);\n-\t  ++const_labelno;\n+\t    {\n+\t      if (TREE_CODE (exp) != STRING_CST\n+\t\t  || !defer\n+\t\t  || flag_writable_strings\n+\t\t  || (defstr = (struct deferred_string **)\n+\t\t\t       htab_find_slot_with_hash (const_str_htab,\n+\t\t\t\t\t\t\t desc->label,\n+\t\t\t\t\t\t\t STRHASH (desc->label),\n+\t\t\t\t\t\t\t INSERT)) == NULL)\n+\t\toutput_constant_def_contents (exp, reloc, labelno);\n+\t      else\n+\t\t{\n+\t\t  struct deferred_string *p;\n+\n+\t\t  p = (struct deferred_string *)\n+\t\t      xmalloc (sizeof (struct deferred_string));\n+\n+\t\t  p->exp = copy_constant (exp);\n+\t\t  p->label = desc->label;\n+\t\t  p->labelno = labelno;\n+\t\t  *defstr = p;\n+\t\t  STRING_POOL_ADDRESS_P (XEXP (desc->rtl, 0)) = 1;\n+\t\t}\n+\t    }\n \t}\n     }\n \n@@ -3806,7 +3921,7 @@ mark_constant_pool ()\n   register rtx insn;\n   struct pool_constant *pool;\n \n-  if (first_pool == 0)\n+  if (first_pool == 0 && htab_elements (const_str_htab) == 0)\n     return;\n \n   for (pool = first_pool; pool; pool = pool->next)\n@@ -3867,6 +3982,22 @@ mark_constants (x)\n     {\n       if (CONSTANT_POOL_ADDRESS_P (x))\n \tfind_pool_constant (cfun, x)->mark = 1;\n+      else if (STRING_POOL_ADDRESS_P (x))\n+\t{\n+\t  struct deferred_string **defstr;\n+\n+\t  defstr = (struct deferred_string **)\n+\t\t   htab_find_slot_with_hash (const_str_htab, XSTR (x, 0),\n+\t\t\t\t\t     STRHASH (XSTR (x, 0)), NO_INSERT);\n+\t  if (defstr)\n+\t    {\n+\t      struct deferred_string *p = *defstr;\n+\n+\t      STRING_POOL_ADDRESS_P (x) = 0;\n+\t      output_constant_def_contents (p->exp, 0, p->labelno);\n+\t      htab_clear_slot (const_str_htab, (void **) defstr);\n+\t    }\n+\t}\n       return;\n     }\n   /* Never search inside a CONST_DOUBLE, because CONST_DOUBLE_MEM may be\n@@ -3943,7 +4074,7 @@ output_addressed_constants (exp)\n \t    || TREE_CODE (constant) == CONSTRUCTOR)\n \t  /* No need to do anything here\n \t     for addresses of variables or functions.  */\n-\t  output_constant_def (constant);\n+\t  output_constant_def (constant, 0);\n       }\n       reloc = 1;\n       break;\n@@ -4757,8 +4888,12 @@ make_decl_one_only (decl)\n void\n init_varasm_once ()\n {\n+  const_str_htab = htab_create (128, const_str_htab_hash, const_str_htab_eq,\n+  \t\t\t\tconst_str_htab_del);\n   ggc_add_root (const_hash_table, MAX_HASH_TABLE, sizeof const_hash_table[0],\n \t\tmark_const_hash_entry);\n+  ggc_add_root (&const_str_htab, 1, sizeof const_str_htab,\n+\t\tmark_const_str_htab);\n   ggc_add_string_root (&in_named_name, 1);\n }\n "}]}