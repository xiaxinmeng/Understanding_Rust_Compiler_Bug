{"sha": "dd2fc5256e440377a3883a793af98b95f6ace957", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQyZmM1MjU2ZTQ0MDM3N2EzODgzYTc5M2FmOThiOTVmNmFjZTk1Nw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-05-11T20:26:36Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-05-11T20:26:36Z"}, "message": "tree.h (OMP_CLAUSE_LINEAR_STMT): Define.\n\n\t* tree.h (OMP_CLAUSE_LINEAR_STMT): Define.\n\t* tree.c (omp_clause_num_ops): Increase OMP_CLAUSE_LINEAR\n\tnumber of operands to 3.\n\t(walk_tree_1): Walk all operands of OMP_CLAUSE_LINEAR.\n\t* tree-nested.c (convert_nonlocal_omp_clauses,\n\tconvert_local_omp_clauses): Handle OMP_CLAUSE_DEPEND.\n\t* gimplify.c (gimplify_scan_omp_clauses): Handle\n\tOMP_CLAUSE_LINEAR_STMT.\n\t* omp-low.c (lower_rec_input_clauses): Fix typo.\n\t(maybe_add_implicit_barrier_cancel, lower_omp_1): Add\n\tcast between Fortran boolean_type_node and C _Bool if\n\tneeded.\ngcc/fortran/\n\t* gfortran.h (gfc_statement): Add ST_OMP_CANCEL,\n\tST_OMP_CANCELLATION_POINT, ST_OMP_TASKGROUP, ST_OMP_END_TASKGROUP,\n\tST_OMP_SIMD, ST_OMP_END_SIMD, ST_OMP_DO_SIMD, ST_OMP_END_DO_SIMD,\n\tST_OMP_PARALLEL_DO_SIMD, ST_OMP_END_PARALLEL_DO_SIMD and\n\tST_OMP_DECLARE_SIMD.\n\t(gfc_omp_namelist): New typedef.\n\t(gfc_get_omp_namelist): Define.\n\t(OMP_LIST_UNIFORM, OMP_LIST_ALIGNED, OMP_LIST_LINEAR,\n\tOMP_LIST_DEPEND_IN, OMP_LIST_DEPEND_OUT): New clause list kinds.\n\t(gfc_omp_proc_bind_kind, gfc_omp_cancel_kind): New enums.\n\t(gfc_omp_clauses): Change type of lists to gfc_omp_namelist *.\n\tAdd inbranch, notinbranch, cancel, proc_bind, safelen_expr and\n\tsimdlen_expr fields.\n\t(gfc_omp_declare_simd): New typedef.\n\t(gfc_get_omp_declare_simd): Define.\n\t(gfc_namespace): Add omp_declare_simd field.\n\t(gfc_exec_op): Add EXEC_OMP_CANCEL, EXEC_OMP_CANCELLATION_POINT,\n\tEXEC_OMP_TASKGROUP, EXEC_OMP_SIMD, EXEC_OMP_DO_SIMD and\n\tEXEC_OMP_PARALLEL_DO_SIMD.\n\t(gfc_omp_atomic_op): Add GFC_OMP_ATOMIC_MASK, GFC_OMP_ATOMIC_SEQ_CST\n\tand GFC_OMP_ATOMIC_SWAP.\n\t(gfc_code): Change type of omp_namelist field to gfc_omp_namelist *.\n\t(gfc_free_omp_namelist, gfc_free_omp_declare_simd,\n\tgfc_free_omp_declare_simd_list, gfc_resolve_omp_declare_simd): New\n\tprototypes.\n\t* trans-stmt.h (gfc_trans_omp_declare_simd): New prototype.\n\t* symbol.c (gfc_free_namespace): Call gfc_free_omp_declare_simd.\n\t* openmp.c (gfc_free_omp_clauses): Free safelen_expr and\n\tsimdlen_expr.  Use gfc_free_omp_namelist instead of\n\tgfc_free_namelist.\n\t(gfc_free_omp_declare_simd, gfc_free_omp_declare_simd_list): New\n\tfunctions.\n\t(gfc_match_omp_variable_list): Add end_colon, headp and\n\tallow_sections arguments.  Handle parsing of array sections.\n\tUse *omp_namelist* instead of *namelist* data structure and\n\tfunctions/macros.  Allow termination at : character.\n\t(OMP_CLAUSE_ALIGNED, OMP_CLAUSE_DEPEND, OMP_CLAUSE_INBRANCH,\n\tOMP_CLAUSE_LINEAR, OMP_CLAUSE_NOTINBRANCH, OMP_CLAUSE_PROC_BIND,\n\tOMP_CLAUSE_SAFELEN, OMP_CLAUSE_SIMDLEN, OMP_CLAUSE_UNIFORM): Define.\n\t(gfc_match_omp_clauses): Change first and needs_space variables\n\tinto arguments with default values.  Parse inbranch, notinbranch,\n\tproc_bind, safelen, simdlen, uniform, linear, aligned and\n\tdepend clauses.\n\t(OMP_PARALLEL_CLAUSES): Add OMP_CLAUSE_PROC_BIND.\n\t(OMP_DECLARE_SIMD_CLAUSES, OMP_SIMD_CLAUSES): Define.\n\t(OMP_TASK_CLAUSES): Add OMP_CLAUSE_DEPEND.\n\t(gfc_match_omp_do_simd): New function.\n\t(gfc_match_omp_flush): Use *omp_namelist* instead of *namelist*\n\tdata structure and functions/macros.\n\t(gfc_match_omp_simd, gfc_match_omp_declare_simd,\n\tgfc_match_omp_parallel_do_simd): New functions.\n\t(gfc_match_omp_atomic): Handle seq_cst clause.  Handle atomic swap.\n\t(gfc_match_omp_taskgroup, gfc_match_omp_cancel_kind,\n\tgfc_match_omp_cancel, gfc_match_omp_cancellation_point): New\n\tfunctions.\n\t(resolve_omp_clauses): Add where, omp_clauses and ns arguments.\n\tUse *omp_namelist* instead of *namelist* data structure and\n\tfunctions/macros.  Resolve uniform, aligned, linear, depend,\n\tsafelen and simdlen clauses.\n\t(resolve_omp_atomic): Adjust for GFC_OMP_ATOMIC_{MASK,SEQ_CST,SWAP}\n\taddition, recognize atomic swap.\n\t(gfc_resolve_omp_parallel_blocks): Use gfc_omp_namelist instead\n\tof gfc_namelist.  Handle EXEC_OMP_PARALLEL_DO_SIMD the same as\n\tEXEC_OMP_PARALLEL_DO.\n\t(gfc_resolve_do_iterator): Use *omp_namelist* instead of *namelist*\n\tdata structure and functions/macros.\n\t(resolve_omp_do): Likewise.  Handle EXEC_OMP_SIMD, EXEC_OMP_DO_SIMD,\n\tEXEC_OMP_PARALLEL_DO_SIMD.\n\t(gfc_resolve_omp_directive): Handle EXEC_OMP_SIMD, EXEC_OMP_DO_SIMD,\n\tEXEC_OMP_PARALLEL_DO_SIMD and EXEC_OMP_CANCEL.  Adjust\n\tresolve_omp_clauses caller.\n\t(gfc_resolve_omp_declare_simd): New function.\n\t* parse.c (decode_omp_directive): Parse cancellation point, cancel,\n\tdeclare simd, end do simd, end simd, end parallel do simd,\n\tend taskgroup, parallel do simd, simd and taskgroup directives.\n\t(case_executable): Add ST_OMP_CANCEL and ST_OMP_CANCELLATION_POINT.\n\t(case_exec_markers): Add ST_OMP_TASKGROUP, case ST_OMP_SIMD,\n\tST_OMP_DO_SIMD and ST_OMP_PARALLEL_DO_SIMD.\n\t(case_decl): Add ST_OMP_DECLARE_SIMD.\n\t(gfc_ascii_statement): Handle ST_OMP_CANCEL,\n\tST_OMP_CANCELLATION_POINT, ST_OMP_TASKGROUP, ST_OMP_END_TASKGROUP,\n\tST_OMP_SIMD, ST_OMP_END_SIMD, ST_OMP_DO_SIMD, ST_OMP_END_DO_SIMD,\n\tST_OMP_PARALLEL_DO_SIMD, ST_OMP_END_PARALLEL_DO_SIMD and\n\tST_OMP_DECLARE_SIMD.\n\t(parse_omp_do): Handle ST_OMP_SIMD, ST_OMP_DO_SIMD and\n\tST_OMP_PARALLEL_DO_SIMD.\n\t(parse_omp_atomic): Adjust for GFC_OMP_ATOMIC_* additions.\n\t(parse_omp_structured_block): Handle ST_OMP_TASKGROUP and\n\tST_OMP_PARALLEL_DO_SIMD.\n\t(parse_executable): Handle ST_OMP_SIMD, ST_OMP_DO_SIMD,\n\tST_OMP_PARALLEL_DO_SIMD and ST_OMP_TASKGROUP.\n\t* trans-decl.c (gfc_get_extern_function_decl,\n\tgfc_create_function_decl): Call gfc_trans_omp_declare_simd if\n\tneeded.\n\t* frontend-passes.c (gfc_code_walker): Handle EXEC_OMP_SIMD,\n\tEXEC_OMP_DO_SIMD and EXEC_OMP_PARALLEL_DO_SIMD.  Walk\n\tsafelen_expr and simdlen_expr.  Walk expressions in gfc_omp_namelist\n\tof depend, aligned and linear clauses.\n\t* match.c (match_exit_cycle): Handle EXEC_OMP_SIMD, EXEC_OMP_DO_SIMD\n\tand EXEC_OMP_PARALLEL_DO_SIMD.\n\t(gfc_free_omp_namelist): New function.\n\t* dump-parse-tree.c (show_namelist): Removed.\n\t(show_omp_namelist): New function.\n\t(show_omp_node): Handle OpenMP 4.0 additions.\n\t(show_code_node): Handle EXEC_OMP_CANCEL, EXEC_OMP_CANCELLATION_POINT,\n\tEXEC_OMP_DO_SIMD, EXEC_OMP_PARALLEL_DO_SIMD, EXEC_OMP_SIMD and\n\tEXEC_OMP_TASKGROUP.\n\t* match.h (gfc_match_omp_cancel, gfc_match_omp_cancellation_point,\n\tgfc_match_omp_declare_simd, gfc_match_omp_do_simd,\n\tgfc_match_omp_parallel_do_simd, gfc_match_omp_simd,\n\tgfc_match_omp_taskgroup): New prototypes.\n\t* trans-openmp.c (gfc_trans_omp_variable): Add declare_simd\n\targument, handle it.  Allow current_function_decl to be NULL.\n\t(gfc_trans_omp_variable_list): Add declare_simd argument, pass\n\tit through to gfc_trans_omp_variable and disregard whether\n\tsym is referenced if declare_simd is true.  Work on gfc_omp_namelist\n\tinstead of gfc_namelist.\n\t(gfc_trans_omp_reduction_list): Work on gfc_omp_namelist instead of\n\tgfc_namelist.  Adjust gfc_trans_omp_variable caller.\n\t(gfc_trans_omp_clauses): Add declare_simd argument, pass it through\n\tto gfc_trans_omp_variable{,_list} callers.  Work on gfc_omp_namelist\n\tinstead of gfc_namelist.  Handle inbranch, notinbranch, safelen,\n\tsimdlen, depend, uniform, linear, proc_bind and aligned clauses.\n\tHandle cancel kind.\n\t(gfc_trans_omp_atomic): Handle seq_cst clause, handle atomic swap,\n\tadjust for GFC_OMP_ATOMIC_* changes.\n\t(gfc_trans_omp_cancel, gfc_trans_omp_cancellation_point): New\n\tfunctions.\n\t(gfc_trans_omp_do): Add op argument, handle simd translation into\n\tgeneric.\n\t(GFC_OMP_SPLIT_SIMD, GFC_OMP_SPLIT_DO, GFC_OMP_SPLIT_PARALLEL,\n\tGFC_OMP_SPLIT_NUM, GFC_OMP_MASK_SIMD, GFC_OMP_MASK_DO,\n\tGFC_OMP_MASK_PARALLEL): New.\n\t(gfc_split_omp_clauses, gfc_trans_omp_do_simd): New functions.\n\t(gfc_trans_omp_parallel_do): Rework to use gfc_split_omp_clauses.\n\t(gfc_trans_omp_parallel_do_simd, gfc_trans_omp_taskgroup): New\n\tfunctions.\n\t(gfc_trans_omp_directive): Handle EXEC_OMP_CANCEL,\n\tEXEC_OMP_CANCELLATION_POINT, EXEC_OMP_DO_SIMD,\n\tEXEC_OMP_PARALLEL_DO_SIMD, EXEC_OMP_SIMD and EXEC_OMP_TASKGROUP.\n\tAdjust gfc_trans_omp_do caller.\n\t(gfc_trans_omp_declare_simd): New function.\n\t* st.c (gfc_free_statement): Handle EXEC_OMP_CANCEL,\n\tEXEC_OMP_CANCELLATION_POINT, EXEC_OMP_DO_SIMD,\n\tEXEC_OMP_PARALLEL_DO_SIMD, EXEC_OMP_SIMD and EXEC_OMP_TASKGROUP.\n\tFor EXEC_OMP_FLUSH call gfc_free_omp_namelist instead of\n\tgfc_free_namelist.\n\t* module.c (omp_declare_simd_clauses): New variable.\n\t(mio_omp_declare_simd): New function.\n\t(mio_symbol): Call it.\n\t* trans.c (trans_code): Handle EXEC_OMP_CANCEL,\n\tEXEC_OMP_CANCELLATION_POINT, EXEC_OMP_DO_SIMD,\n\tEXEC_OMP_PARALLEL_DO_SIMD, EXEC_OMP_SIMD and EXEC_OMP_TASKGROUP.\n\t* resolve.c (gfc_resolve_blocks): Handle EXEC_OMP_DO_SIMD,  \n\tEXEC_OMP_PARALLEL_DO_SIMD, EXEC_OMP_SIMD and EXEC_OMP_TASKGROUP.\n\t(resolve_code): Handle EXEC_OMP_CANCEL,\n\tEXEC_OMP_CANCELLATION_POINT, EXEC_OMP_DO_SIMD,\n\tEXEC_OMP_PARALLEL_DO_SIMD, EXEC_OMP_SIMD and EXEC_OMP_TASKGROUP.\n\t(resolve_types): Call gfc_resolve_omp_declare_simd.\ngcc/testsuite/\n\t* gfortran.dg/gomp/affinity-1.f90: New test.\nlibgomp/\n\t* testsuite/libgomp.fortran/cancel-do-1.f90: New test.\n\t* testsuite/libgomp.fortran/cancel-do-2.f90: New test.\n\t* testsuite/libgomp.fortran/cancel-parallel-1.f90: New test.\n\t* testsuite/libgomp.fortran/cancel-parallel-3.f90: New test.\n\t* testsuite/libgomp.fortran/cancel-sections-1.f90: New test.\n\t* testsuite/libgomp.fortran/cancel-taskgroup-2.f90: New test.\n\t* testsuite/libgomp.fortran/declare-simd-1.f90: New test.\n\t* testsuite/libgomp.fortran/declare-simd-2.f90: New test.\n\t* testsuite/libgomp.fortran/declare-simd-3.f90: New test.\n\t* testsuite/libgomp.fortran/depend-1.f90: New test.\n\t* testsuite/libgomp.fortran/depend-2.f90: New test.\n\t* testsuite/libgomp.fortran/omp_atomic5.f90: New test.\n\t* testsuite/libgomp.fortran/simd1.f90: New test.\n\t* testsuite/libgomp.fortran/simd2.f90: New test.\n\t* testsuite/libgomp.fortran/simd3.f90: New test.\n\t* testsuite/libgomp.fortran/simd4.f90: New test.\n\t* testsuite/libgomp.fortran/taskgroup1.f90: New test.\n\nFrom-SVN: r210313", "tree": {"sha": "c4f127aea63536dd03600145240bfabcf8433393", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4f127aea63536dd03600145240bfabcf8433393"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd2fc5256e440377a3883a793af98b95f6ace957", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd2fc5256e440377a3883a793af98b95f6ace957", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd2fc5256e440377a3883a793af98b95f6ace957", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd2fc5256e440377a3883a793af98b95f6ace957/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7588d8aae498ba0a9643858555ac44e97877d5cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7588d8aae498ba0a9643858555ac44e97877d5cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7588d8aae498ba0a9643858555ac44e97877d5cf"}], "stats": {"total": 3156, "additions": 2983, "deletions": 173}, "files": [{"sha": "f3cb5f7510e7d7b676d5451c3517999f8b68c48c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -1,3 +1,18 @@\n+2014-05-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree.h (OMP_CLAUSE_LINEAR_STMT): Define.\n+\t* tree.c (omp_clause_num_ops): Increase OMP_CLAUSE_LINEAR\n+\tnumber of operands to 3.\n+\t(walk_tree_1): Walk all operands of OMP_CLAUSE_LINEAR.\n+\t* tree-nested.c (convert_nonlocal_omp_clauses,\n+\tconvert_local_omp_clauses): Handle OMP_CLAUSE_DEPEND.\n+\t* gimplify.c (gimplify_scan_omp_clauses): Handle\n+\tOMP_CLAUSE_LINEAR_STMT.\n+\t* omp-low.c (lower_rec_input_clauses): Fix typo.\n+\t(maybe_add_implicit_barrier_cancel, lower_omp_1): Add\n+\tcast between Fortran boolean_type_node and C _Bool if\n+\tneeded.\n+\n 2014-05-11  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \tPR tree-optimization/61136"}, {"sha": "3f2f787cf21d149bc3db21483bedd32ded4735bd", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -1,3 +1,165 @@\n+2014-05-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gfortran.h (gfc_statement): Add ST_OMP_CANCEL,\n+\tST_OMP_CANCELLATION_POINT, ST_OMP_TASKGROUP, ST_OMP_END_TASKGROUP,\n+\tST_OMP_SIMD, ST_OMP_END_SIMD, ST_OMP_DO_SIMD, ST_OMP_END_DO_SIMD,\n+\tST_OMP_PARALLEL_DO_SIMD, ST_OMP_END_PARALLEL_DO_SIMD and\n+\tST_OMP_DECLARE_SIMD.\n+\t(gfc_omp_namelist): New typedef.\n+\t(gfc_get_omp_namelist): Define.\n+\t(OMP_LIST_UNIFORM, OMP_LIST_ALIGNED, OMP_LIST_LINEAR,\n+\tOMP_LIST_DEPEND_IN, OMP_LIST_DEPEND_OUT): New clause list kinds.\n+\t(gfc_omp_proc_bind_kind, gfc_omp_cancel_kind): New enums.\n+\t(gfc_omp_clauses): Change type of lists to gfc_omp_namelist *.\n+\tAdd inbranch, notinbranch, cancel, proc_bind, safelen_expr and\n+\tsimdlen_expr fields.\n+\t(gfc_omp_declare_simd): New typedef.\n+\t(gfc_get_omp_declare_simd): Define.\n+\t(gfc_namespace): Add omp_declare_simd field.\n+\t(gfc_exec_op): Add EXEC_OMP_CANCEL, EXEC_OMP_CANCELLATION_POINT,\n+\tEXEC_OMP_TASKGROUP, EXEC_OMP_SIMD, EXEC_OMP_DO_SIMD and\n+\tEXEC_OMP_PARALLEL_DO_SIMD.\n+\t(gfc_omp_atomic_op): Add GFC_OMP_ATOMIC_MASK, GFC_OMP_ATOMIC_SEQ_CST\n+\tand GFC_OMP_ATOMIC_SWAP.\n+\t(gfc_code): Change type of omp_namelist field to gfc_omp_namelist *.\n+\t(gfc_free_omp_namelist, gfc_free_omp_declare_simd,\n+\tgfc_free_omp_declare_simd_list, gfc_resolve_omp_declare_simd): New\n+\tprototypes.\n+\t* trans-stmt.h (gfc_trans_omp_declare_simd): New prototype.\n+\t* symbol.c (gfc_free_namespace): Call gfc_free_omp_declare_simd.\n+\t* openmp.c (gfc_free_omp_clauses): Free safelen_expr and\n+\tsimdlen_expr.  Use gfc_free_omp_namelist instead of\n+\tgfc_free_namelist.\n+\t(gfc_free_omp_declare_simd, gfc_free_omp_declare_simd_list): New\n+\tfunctions.\n+\t(gfc_match_omp_variable_list): Add end_colon, headp and\n+\tallow_sections arguments.  Handle parsing of array sections.\n+\tUse *omp_namelist* instead of *namelist* data structure and\n+\tfunctions/macros.  Allow termination at : character.\n+\t(OMP_CLAUSE_ALIGNED, OMP_CLAUSE_DEPEND, OMP_CLAUSE_INBRANCH,\n+\tOMP_CLAUSE_LINEAR, OMP_CLAUSE_NOTINBRANCH, OMP_CLAUSE_PROC_BIND,\n+\tOMP_CLAUSE_SAFELEN, OMP_CLAUSE_SIMDLEN, OMP_CLAUSE_UNIFORM): Define.\n+\t(gfc_match_omp_clauses): Change first and needs_space variables\n+\tinto arguments with default values.  Parse inbranch, notinbranch,\n+\tproc_bind, safelen, simdlen, uniform, linear, aligned and\n+\tdepend clauses.\n+\t(OMP_PARALLEL_CLAUSES): Add OMP_CLAUSE_PROC_BIND.\n+\t(OMP_DECLARE_SIMD_CLAUSES, OMP_SIMD_CLAUSES): Define.\n+\t(OMP_TASK_CLAUSES): Add OMP_CLAUSE_DEPEND.\n+\t(gfc_match_omp_do_simd): New function.\n+\t(gfc_match_omp_flush): Use *omp_namelist* instead of *namelist*\n+\tdata structure and functions/macros.\n+\t(gfc_match_omp_simd, gfc_match_omp_declare_simd,\n+\tgfc_match_omp_parallel_do_simd): New functions.\n+\t(gfc_match_omp_atomic): Handle seq_cst clause.  Handle atomic swap.\n+\t(gfc_match_omp_taskgroup, gfc_match_omp_cancel_kind,\n+\tgfc_match_omp_cancel, gfc_match_omp_cancellation_point): New\n+\tfunctions.\n+\t(resolve_omp_clauses): Add where, omp_clauses and ns arguments.\n+\tUse *omp_namelist* instead of *namelist* data structure and\n+\tfunctions/macros.  Resolve uniform, aligned, linear, depend,\n+\tsafelen and simdlen clauses.\n+\t(resolve_omp_atomic): Adjust for GFC_OMP_ATOMIC_{MASK,SEQ_CST,SWAP}\n+\taddition, recognize atomic swap.\n+\t(gfc_resolve_omp_parallel_blocks): Use gfc_omp_namelist instead\n+\tof gfc_namelist.  Handle EXEC_OMP_PARALLEL_DO_SIMD the same as\n+\tEXEC_OMP_PARALLEL_DO.\n+\t(gfc_resolve_do_iterator): Use *omp_namelist* instead of *namelist*\n+\tdata structure and functions/macros.\n+\t(resolve_omp_do): Likewise.  Handle EXEC_OMP_SIMD, EXEC_OMP_DO_SIMD,\n+\tEXEC_OMP_PARALLEL_DO_SIMD.\n+\t(gfc_resolve_omp_directive): Handle EXEC_OMP_SIMD, EXEC_OMP_DO_SIMD,\n+\tEXEC_OMP_PARALLEL_DO_SIMD and EXEC_OMP_CANCEL.  Adjust\n+\tresolve_omp_clauses caller.\n+\t(gfc_resolve_omp_declare_simd): New function.\n+\t* parse.c (decode_omp_directive): Parse cancellation point, cancel,\n+\tdeclare simd, end do simd, end simd, end parallel do simd,\n+\tend taskgroup, parallel do simd, simd and taskgroup directives.\n+\t(case_executable): Add ST_OMP_CANCEL and ST_OMP_CANCELLATION_POINT.\n+\t(case_exec_markers): Add ST_OMP_TASKGROUP, case ST_OMP_SIMD,\n+\tST_OMP_DO_SIMD and ST_OMP_PARALLEL_DO_SIMD.\n+\t(case_decl): Add ST_OMP_DECLARE_SIMD.\n+\t(gfc_ascii_statement): Handle ST_OMP_CANCEL,\n+\tST_OMP_CANCELLATION_POINT, ST_OMP_TASKGROUP, ST_OMP_END_TASKGROUP,\n+\tST_OMP_SIMD, ST_OMP_END_SIMD, ST_OMP_DO_SIMD, ST_OMP_END_DO_SIMD,\n+\tST_OMP_PARALLEL_DO_SIMD, ST_OMP_END_PARALLEL_DO_SIMD and\n+\tST_OMP_DECLARE_SIMD.\n+\t(parse_omp_do): Handle ST_OMP_SIMD, ST_OMP_DO_SIMD and\n+\tST_OMP_PARALLEL_DO_SIMD.\n+\t(parse_omp_atomic): Adjust for GFC_OMP_ATOMIC_* additions.\n+\t(parse_omp_structured_block): Handle ST_OMP_TASKGROUP and\n+\tST_OMP_PARALLEL_DO_SIMD.\n+\t(parse_executable): Handle ST_OMP_SIMD, ST_OMP_DO_SIMD,\n+\tST_OMP_PARALLEL_DO_SIMD and ST_OMP_TASKGROUP.\n+\t* trans-decl.c (gfc_get_extern_function_decl,\n+\tgfc_create_function_decl): Call gfc_trans_omp_declare_simd if\n+\tneeded.\n+\t* frontend-passes.c (gfc_code_walker): Handle EXEC_OMP_SIMD,\n+\tEXEC_OMP_DO_SIMD and EXEC_OMP_PARALLEL_DO_SIMD.  Walk\n+\tsafelen_expr and simdlen_expr.  Walk expressions in gfc_omp_namelist\n+\tof depend, aligned and linear clauses.\n+\t* match.c (match_exit_cycle): Handle EXEC_OMP_SIMD, EXEC_OMP_DO_SIMD\n+\tand EXEC_OMP_PARALLEL_DO_SIMD.\n+\t(gfc_free_omp_namelist): New function.\n+\t* dump-parse-tree.c (show_namelist): Removed.\n+\t(show_omp_namelist): New function.\n+\t(show_omp_node): Handle OpenMP 4.0 additions.\n+\t(show_code_node): Handle EXEC_OMP_CANCEL, EXEC_OMP_CANCELLATION_POINT,\n+\tEXEC_OMP_DO_SIMD, EXEC_OMP_PARALLEL_DO_SIMD, EXEC_OMP_SIMD and\n+\tEXEC_OMP_TASKGROUP.\n+\t* match.h (gfc_match_omp_cancel, gfc_match_omp_cancellation_point,\n+\tgfc_match_omp_declare_simd, gfc_match_omp_do_simd,\n+\tgfc_match_omp_parallel_do_simd, gfc_match_omp_simd,\n+\tgfc_match_omp_taskgroup): New prototypes.\n+\t* trans-openmp.c (gfc_trans_omp_variable): Add declare_simd\n+\targument, handle it.  Allow current_function_decl to be NULL.\n+\t(gfc_trans_omp_variable_list): Add declare_simd argument, pass\n+\tit through to gfc_trans_omp_variable and disregard whether\n+\tsym is referenced if declare_simd is true.  Work on gfc_omp_namelist\n+\tinstead of gfc_namelist.\n+\t(gfc_trans_omp_reduction_list): Work on gfc_omp_namelist instead of\n+\tgfc_namelist.  Adjust gfc_trans_omp_variable caller.\n+\t(gfc_trans_omp_clauses): Add declare_simd argument, pass it through\n+\tto gfc_trans_omp_variable{,_list} callers.  Work on gfc_omp_namelist\n+\tinstead of gfc_namelist.  Handle inbranch, notinbranch, safelen,\n+\tsimdlen, depend, uniform, linear, proc_bind and aligned clauses.\n+\tHandle cancel kind.\n+\t(gfc_trans_omp_atomic): Handle seq_cst clause, handle atomic swap,\n+\tadjust for GFC_OMP_ATOMIC_* changes.\n+\t(gfc_trans_omp_cancel, gfc_trans_omp_cancellation_point): New\n+\tfunctions.\n+\t(gfc_trans_omp_do): Add op argument, handle simd translation into\n+\tgeneric.\n+\t(GFC_OMP_SPLIT_SIMD, GFC_OMP_SPLIT_DO, GFC_OMP_SPLIT_PARALLEL,\n+\tGFC_OMP_SPLIT_NUM, GFC_OMP_MASK_SIMD, GFC_OMP_MASK_DO,\n+\tGFC_OMP_MASK_PARALLEL): New.\n+\t(gfc_split_omp_clauses, gfc_trans_omp_do_simd): New functions.\n+\t(gfc_trans_omp_parallel_do): Rework to use gfc_split_omp_clauses.\n+\t(gfc_trans_omp_parallel_do_simd, gfc_trans_omp_taskgroup): New\n+\tfunctions.\n+\t(gfc_trans_omp_directive): Handle EXEC_OMP_CANCEL,\n+\tEXEC_OMP_CANCELLATION_POINT, EXEC_OMP_DO_SIMD,\n+\tEXEC_OMP_PARALLEL_DO_SIMD, EXEC_OMP_SIMD and EXEC_OMP_TASKGROUP.\n+\tAdjust gfc_trans_omp_do caller.\n+\t(gfc_trans_omp_declare_simd): New function.\n+\t* st.c (gfc_free_statement): Handle EXEC_OMP_CANCEL,\n+\tEXEC_OMP_CANCELLATION_POINT, EXEC_OMP_DO_SIMD,\n+\tEXEC_OMP_PARALLEL_DO_SIMD, EXEC_OMP_SIMD and EXEC_OMP_TASKGROUP.\n+\tFor EXEC_OMP_FLUSH call gfc_free_omp_namelist instead of\n+\tgfc_free_namelist.\n+\t* module.c (omp_declare_simd_clauses): New variable.\n+\t(mio_omp_declare_simd): New function.\n+\t(mio_symbol): Call it.\n+\t* trans.c (trans_code): Handle EXEC_OMP_CANCEL,\n+\tEXEC_OMP_CANCELLATION_POINT, EXEC_OMP_DO_SIMD,\n+\tEXEC_OMP_PARALLEL_DO_SIMD, EXEC_OMP_SIMD and EXEC_OMP_TASKGROUP.\n+\t* resolve.c (gfc_resolve_blocks): Handle EXEC_OMP_DO_SIMD,  \n+\tEXEC_OMP_PARALLEL_DO_SIMD, EXEC_OMP_SIMD and EXEC_OMP_TASKGROUP.\n+\t(resolve_code): Handle EXEC_OMP_CANCEL,\n+\tEXEC_OMP_CANCELLATION_POINT, EXEC_OMP_DO_SIMD,\n+\tEXEC_OMP_PARALLEL_DO_SIMD, EXEC_OMP_SIMD and EXEC_OMP_TASKGROUP.\n+\t(resolve_types): Call gfc_resolve_omp_declare_simd.\n+\n 2014-05-11  Tobias Burnus  <burnus@net-b.de>\n \n \t* trans-intrinsic.c (gfc_build_builtin_function_decls):"}, {"sha": "b5d2537a083a11351f012c9b84523b1e4d7d8952", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 91, "deletions": 9, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -1016,11 +1016,19 @@ show_code (int level, gfc_code *c)\n }\n \n static void\n-show_namelist (gfc_namelist *n)\n+show_omp_namelist (gfc_omp_namelist *n)\n {\n-  for (; n->next; n = n->next)\n-    fprintf (dumpfile, \"%s,\", n->sym->name);\n-  fprintf (dumpfile, \"%s\", n->sym->name);\n+  for (; n; n = n->next)\n+    {\n+      fprintf (dumpfile, \"%s\", n->sym->name);\n+      if (n->expr)\n+\t{\n+\t  fputc (':', dumpfile);\n+\t  show_expr (n->expr);\n+\t}\n+      if (n->next)\n+\tfputc (',', dumpfile);\n+    }\n }\n \n /* Show a single OpenMP directive node and everything underneath it\n@@ -1036,18 +1044,24 @@ show_omp_node (int level, gfc_code *c)\n     {\n     case EXEC_OMP_ATOMIC: name = \"ATOMIC\"; break;\n     case EXEC_OMP_BARRIER: name = \"BARRIER\"; break;\n+    case EXEC_OMP_CANCEL: name = \"CANCEL\"; break;\n+    case EXEC_OMP_CANCELLATION_POINT: name = \"CANCELLATION POINT\"; break;\n     case EXEC_OMP_CRITICAL: name = \"CRITICAL\"; break;\n     case EXEC_OMP_FLUSH: name = \"FLUSH\"; break;\n     case EXEC_OMP_DO: name = \"DO\"; break;\n+    case EXEC_OMP_DO_SIMD: name = \"DO SIMD\"; break;\n     case EXEC_OMP_MASTER: name = \"MASTER\"; break;\n     case EXEC_OMP_ORDERED: name = \"ORDERED\"; break;\n     case EXEC_OMP_PARALLEL: name = \"PARALLEL\"; break;\n     case EXEC_OMP_PARALLEL_DO: name = \"PARALLEL DO\"; break;\n+    case EXEC_OMP_PARALLEL_DO_SIMD: name = \"PARALLEL DO SIMD\"; break;\n     case EXEC_OMP_PARALLEL_SECTIONS: name = \"PARALLEL SECTIONS\"; break;\n     case EXEC_OMP_PARALLEL_WORKSHARE: name = \"PARALLEL WORKSHARE\"; break;\n     case EXEC_OMP_SECTIONS: name = \"SECTIONS\"; break;\n+    case EXEC_OMP_SIMD: name = \"SIMD\"; break;\n     case EXEC_OMP_SINGLE: name = \"SINGLE\"; break;\n     case EXEC_OMP_TASK: name = \"TASK\"; break;\n+    case EXEC_OMP_TASKGROUP: name = \"TASKGROUP\"; break;\n     case EXEC_OMP_TASKWAIT: name = \"TASKWAIT\"; break;\n     case EXEC_OMP_TASKYIELD: name = \"TASKYIELD\"; break;\n     case EXEC_OMP_WORKSHARE: name = \"WORKSHARE\"; break;\n@@ -1057,11 +1071,16 @@ show_omp_node (int level, gfc_code *c)\n   fprintf (dumpfile, \"!$OMP %s\", name);\n   switch (c->op)\n     {\n+    case EXEC_OMP_CANCEL:\n+    case EXEC_OMP_CANCELLATION_POINT:\n     case EXEC_OMP_DO:\n+    case EXEC_OMP_DO_SIMD:\n     case EXEC_OMP_PARALLEL:\n     case EXEC_OMP_PARALLEL_DO:\n+    case EXEC_OMP_PARALLEL_DO_SIMD:\n     case EXEC_OMP_PARALLEL_SECTIONS:\n     case EXEC_OMP_SECTIONS:\n+    case EXEC_OMP_SIMD:\n     case EXEC_OMP_SINGLE:\n     case EXEC_OMP_WORKSHARE:\n     case EXEC_OMP_PARALLEL_WORKSHARE:\n@@ -1076,7 +1095,7 @@ show_omp_node (int level, gfc_code *c)\n       if (c->ext.omp_namelist)\n \t{\n \t  fputs (\" (\", dumpfile);\n-\t  show_namelist (c->ext.omp_namelist);\n+\t  show_omp_namelist (c->ext.omp_namelist);\n \t  fputc (')', dumpfile);\n \t}\n       return;\n@@ -1091,6 +1110,23 @@ show_omp_node (int level, gfc_code *c)\n     {\n       int list_type;\n \n+      switch (omp_clauses->cancel)\n+\t{\n+\tcase OMP_CANCEL_UNKNOWN:\n+\t  break;\n+\tcase OMP_CANCEL_PARALLEL:\n+\t  fputs (\" PARALLEL\", dumpfile);\n+\t  break;\n+\tcase OMP_CANCEL_SECTIONS:\n+\t  fputs (\" SECTIONS\", dumpfile);\n+\t  break;\n+\tcase OMP_CANCEL_DO:\n+\t  fputs (\" DO\", dumpfile);\n+\t  break;\n+\tcase OMP_CANCEL_TASKGROUP:\n+\t  fputs (\" TASKGROUP\", dumpfile);\n+\t  break;\n+\t}\n       if (omp_clauses->if_expr)\n \t{\n \t  fputs (\" IF(\", dumpfile);\n@@ -1156,7 +1192,7 @@ show_omp_node (int level, gfc_code *c)\n \tif (omp_clauses->lists[list_type] != NULL\n \t    && list_type != OMP_LIST_COPYPRIVATE)\n \t  {\n-\t    const char *type;\n+\t    const char *type = NULL;\n \t    if (list_type >= OMP_LIST_REDUCTION_FIRST)\n \t      {\n \t\tswitch (list_type)\n@@ -1187,14 +1223,53 @@ show_omp_node (int level, gfc_code *c)\n \t\t  case OMP_LIST_LASTPRIVATE: type = \"LASTPRIVATE\"; break;\n \t\t  case OMP_LIST_SHARED: type = \"SHARED\"; break;\n \t\t  case OMP_LIST_COPYIN: type = \"COPYIN\"; break;\n+\t\t  case OMP_LIST_UNIFORM: type = \"UNIFORM\"; break;\n+\t\t  case OMP_LIST_ALIGNED: type = \"ALIGNED\"; break;\n+\t\t  case OMP_LIST_LINEAR: type = \"LINEAR\"; break;\n+\t\t  case OMP_LIST_DEPEND_IN:\n+\t\t    fprintf (dumpfile, \" DEPEND(IN:\");\n+\t\t    break;\n+\t\t  case OMP_LIST_DEPEND_OUT:\n+\t\t    fprintf (dumpfile, \" DEPEND(OUT:\");\n+\t\t    break;\n \t\t  default:\n \t\t    gcc_unreachable ();\n \t\t  }\n-\t\tfprintf (dumpfile, \" %s(\", type);\n+\t\tif (type)\n+\t\t  fprintf (dumpfile, \" %s(\", type);\n \t      }\n-\t    show_namelist (omp_clauses->lists[list_type]);\n+\t    show_omp_namelist (omp_clauses->lists[list_type]);\n \t    fputc (')', dumpfile);\n \t  }\n+      if (omp_clauses->safelen_expr)\n+\t{\n+\t  fputs (\" SAFELEN(\", dumpfile);\n+\t  show_expr (omp_clauses->safelen_expr);\n+\t  fputc (')', dumpfile);\n+\t}\n+      if (omp_clauses->simdlen_expr)\n+\t{\n+\t  fputs (\" SIMDLEN(\", dumpfile);\n+\t  show_expr (omp_clauses->simdlen_expr);\n+\t  fputc (')', dumpfile);\n+\t}\n+      if (omp_clauses->inbranch)\n+\tfputs (\" INBRANCH\", dumpfile);\n+      if (omp_clauses->notinbranch)\n+\tfputs (\" NOTINBRANCH\", dumpfile);\n+      if (omp_clauses->proc_bind != OMP_PROC_BIND_UNKNOWN)\n+\t{\n+\t  const char *type;\n+\t  switch (omp_clauses->proc_bind)\n+\t    {\n+\t    case OMP_PROC_BIND_MASTER: type = \"MASTER\"; break;\n+\t    case OMP_PROC_BIND_SPREAD: type = \"SPREAD\"; break;\n+\t    case OMP_PROC_BIND_CLOSE: type = \"CLOSE\"; break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  fprintf (dumpfile, \" PROC_BIND(%s)\", type);\n+\t}\n     }\n   fputc ('\\n', dumpfile);\n   if (c->op == EXEC_OMP_SECTIONS || c->op == EXEC_OMP_PARALLEL_SECTIONS)\n@@ -1214,14 +1289,15 @@ show_omp_node (int level, gfc_code *c)\n     show_code (level + 1, c->block->next);\n   if (c->op == EXEC_OMP_ATOMIC)\n     return;\n+  fputc ('\\n', dumpfile);\n   code_indent (level, 0);\n   fprintf (dumpfile, \"!$OMP END %s\", name);\n   if (omp_clauses != NULL)\n     {\n       if (omp_clauses->lists[OMP_LIST_COPYPRIVATE])\n \t{\n \t  fputs (\" COPYPRIVATE(\", dumpfile);\n-\t  show_namelist (omp_clauses->lists[OMP_LIST_COPYPRIVATE]);\n+\t  show_omp_namelist (omp_clauses->lists[OMP_LIST_COPYPRIVATE]);\n \t  fputc (')', dumpfile);\n \t}\n       else if (omp_clauses->nowait)\n@@ -2195,19 +2271,25 @@ show_code_node (int level, gfc_code *c)\n       break;\n \n     case EXEC_OMP_ATOMIC:\n+    case EXEC_OMP_CANCEL:\n+    case EXEC_OMP_CANCELLATION_POINT:\n     case EXEC_OMP_BARRIER:\n     case EXEC_OMP_CRITICAL:\n     case EXEC_OMP_FLUSH:\n     case EXEC_OMP_DO:\n+    case EXEC_OMP_DO_SIMD:\n     case EXEC_OMP_MASTER:\n     case EXEC_OMP_ORDERED:\n     case EXEC_OMP_PARALLEL:\n     case EXEC_OMP_PARALLEL_DO:\n+    case EXEC_OMP_PARALLEL_DO_SIMD:\n     case EXEC_OMP_PARALLEL_SECTIONS:\n     case EXEC_OMP_PARALLEL_WORKSHARE:\n     case EXEC_OMP_SECTIONS:\n+    case EXEC_OMP_SIMD:\n     case EXEC_OMP_SINGLE:\n     case EXEC_OMP_TASK:\n+    case EXEC_OMP_TASKGROUP:\n     case EXEC_OMP_TASKWAIT:\n     case EXEC_OMP_TASKYIELD:\n     case EXEC_OMP_WORKSHARE:"}, {"sha": "8bac7bf35166f153eef5224a5cacab88d3b6a397", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -2112,6 +2112,7 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,\n \n \t    case EXEC_OMP_PARALLEL:\n \t    case EXEC_OMP_PARALLEL_DO:\n+\t    case EXEC_OMP_PARALLEL_DO_SIMD:\n \t    case EXEC_OMP_PARALLEL_SECTIONS:\n \n \t      in_omp_workshare = false;\n@@ -2128,9 +2129,11 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,\n \t      /* Fall through  */\n \t      \n \t    case EXEC_OMP_DO:\n+\t    case EXEC_OMP_DO_SIMD:\n \t    case EXEC_OMP_SECTIONS:\n \t    case EXEC_OMP_SINGLE:\n \t    case EXEC_OMP_END_SINGLE:\n+\t    case EXEC_OMP_SIMD:\n \t    case EXEC_OMP_TASK:\n \n \t      /* Come to this label only from the\n@@ -2144,7 +2147,24 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,\n \t\t  WALK_SUBEXPR (co->ext.omp_clauses->final_expr);\n \t\t  WALK_SUBEXPR (co->ext.omp_clauses->num_threads);\n \t\t  WALK_SUBEXPR (co->ext.omp_clauses->chunk_size);\n+\t\t  WALK_SUBEXPR (co->ext.omp_clauses->safelen_expr);\n+\t\t  WALK_SUBEXPR (co->ext.omp_clauses->simdlen_expr);\n \t\t}\n+\t      {\n+\t\tgfc_omp_namelist *n;\n+\t\tfor (n = co->ext.omp_clauses->lists[OMP_LIST_ALIGNED];\n+\t\t     n; n = n->next)\n+\t\t  WALK_SUBEXPR (n->expr);\n+\t\tfor (n = co->ext.omp_clauses->lists[OMP_LIST_LINEAR];\n+\t\t     n; n = n->next)\n+\t\t  WALK_SUBEXPR (n->expr);\n+\t\tfor (n = co->ext.omp_clauses->lists[OMP_LIST_DEPEND_IN];\n+\t\t     n; n = n->next)\n+\t\t  WALK_SUBEXPR (n->expr);\n+\t\tfor (n = co->ext.omp_clauses->lists[OMP_LIST_DEPEND_OUT];\n+\t\t     n; n = n->next)\n+\t\t  WALK_SUBEXPR (n->expr);\n+\t      }\n \t      break;\n \t    default:\n \t      break;"}, {"sha": "3e5cdbd7d49ab2943ab72182dccfe90e4a6be668", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 80, "deletions": 9, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -211,8 +211,12 @@ typedef enum\n   ST_OMP_PARALLEL, ST_OMP_PARALLEL_DO, ST_OMP_PARALLEL_SECTIONS,\n   ST_OMP_PARALLEL_WORKSHARE, ST_OMP_SECTIONS, ST_OMP_SECTION, ST_OMP_SINGLE,\n   ST_OMP_THREADPRIVATE, ST_OMP_WORKSHARE, ST_OMP_TASK, ST_OMP_END_TASK,\n-  ST_OMP_TASKWAIT, ST_OMP_TASKYIELD, ST_PROCEDURE, ST_GENERIC, ST_CRITICAL,\n-  ST_END_CRITICAL, ST_GET_FCN_CHARACTERISTICS, ST_LOCK, ST_UNLOCK, ST_NONE\n+  ST_OMP_TASKWAIT, ST_OMP_TASKYIELD, ST_OMP_CANCEL, ST_OMP_CANCELLATION_POINT,\n+  ST_OMP_TASKGROUP, ST_OMP_END_TASKGROUP, ST_OMP_SIMD, ST_OMP_END_SIMD,\n+  ST_OMP_DO_SIMD, ST_OMP_END_DO_SIMD, ST_OMP_PARALLEL_DO_SIMD,\n+  ST_OMP_END_PARALLEL_DO_SIMD, ST_OMP_DECLARE_SIMD, ST_PROCEDURE, ST_GENERIC,\n+  ST_CRITICAL, ST_END_CRITICAL, ST_GET_FCN_CHARACTERISTICS, ST_LOCK,\n+  ST_UNLOCK, ST_NONE\n }\n gfc_statement;\n \n@@ -1033,6 +1037,19 @@ gfc_namelist;\n \n #define gfc_get_namelist() XCNEW (gfc_namelist)\n \n+/* For use in OpenMP clauses in case we need extra information\n+   (aligned clause alignment, linear clause step, etc.).  */\n+\n+typedef struct gfc_omp_namelist\n+{\n+  struct gfc_symbol *sym;\n+  struct gfc_expr *expr;\n+  struct gfc_omp_namelist *next;\n+}\n+gfc_omp_namelist;\n+\n+#define gfc_get_omp_namelist() XCNEW (gfc_omp_namelist)\n+\n enum\n {\n   OMP_LIST_PRIVATE,\n@@ -1041,6 +1058,11 @@ enum\n   OMP_LIST_COPYPRIVATE,\n   OMP_LIST_SHARED,\n   OMP_LIST_COPYIN,\n+  OMP_LIST_UNIFORM,\n+  OMP_LIST_ALIGNED,\n+  OMP_LIST_LINEAR,\n+  OMP_LIST_DEPEND_IN,\n+  OMP_LIST_DEPEND_OUT,\n   OMP_LIST_PLUS,\n   OMP_LIST_REDUCTION_FIRST = OMP_LIST_PLUS,\n   OMP_LIST_MULT,\n@@ -1080,23 +1102,60 @@ enum gfc_omp_default_sharing\n   OMP_DEFAULT_FIRSTPRIVATE\n };\n \n+enum gfc_omp_proc_bind_kind\n+{\n+  OMP_PROC_BIND_UNKNOWN,\n+  OMP_PROC_BIND_MASTER,\n+  OMP_PROC_BIND_SPREAD,\n+  OMP_PROC_BIND_CLOSE\n+};\n+\n+enum gfc_omp_cancel_kind\n+{\n+  OMP_CANCEL_UNKNOWN,\n+  OMP_CANCEL_PARALLEL,\n+  OMP_CANCEL_SECTIONS,\n+  OMP_CANCEL_DO,\n+  OMP_CANCEL_TASKGROUP\n+};\n+\n typedef struct gfc_omp_clauses\n {\n   struct gfc_expr *if_expr;\n   struct gfc_expr *final_expr;\n   struct gfc_expr *num_threads;\n-  gfc_namelist *lists[OMP_LIST_NUM];\n+  gfc_omp_namelist *lists[OMP_LIST_NUM];\n   enum gfc_omp_sched_kind sched_kind;\n   struct gfc_expr *chunk_size;\n   enum gfc_omp_default_sharing default_sharing;\n   int collapse;\n   bool nowait, ordered, untied, mergeable;\n+  bool inbranch, notinbranch;\n+  enum gfc_omp_cancel_kind cancel;\n+  enum gfc_omp_proc_bind_kind proc_bind;\n+  struct gfc_expr *safelen_expr;\n+  struct gfc_expr *simdlen_expr;\n }\n gfc_omp_clauses;\n \n #define gfc_get_omp_clauses() XCNEW (gfc_omp_clauses)\n \n \n+/* Node in the linked list used for storing !$omp declare simd constructs.  */\n+\n+typedef struct gfc_omp_declare_simd\n+{\n+  struct gfc_omp_declare_simd *next;\n+  locus where; /* Where the !$omp declare simd construct occurred.  */\n+\n+  gfc_symbol *proc_name;\n+\n+  gfc_omp_clauses *clauses;\n+}\n+gfc_omp_declare_simd;\n+#define gfc_get_omp_declare_simd() XCNEW (gfc_omp_declare_simd)\n+\n+\n /* The gfc_st_label structure is a BBT attached to a namespace that\n    records the usage of statement labels within that space.  */\n \n@@ -1469,6 +1528,9 @@ typedef struct gfc_namespace\n   /* A list of USE statements in this namespace.  */\n   gfc_use_list *use_stmts;\n \n+  /* Linked list of !$omp declare simd constructs.  */\n+  struct gfc_omp_declare_simd *omp_declare_simd;\n+\n   /* Set to 1 if namespace is a BLOCK DATA program unit.  */\n   unsigned is_block_data:1;\n \n@@ -2116,16 +2178,21 @@ typedef enum\n   EXEC_OMP_SECTIONS, EXEC_OMP_SINGLE, EXEC_OMP_WORKSHARE,\n   EXEC_OMP_ATOMIC, EXEC_OMP_BARRIER, EXEC_OMP_END_NOWAIT,\n   EXEC_OMP_END_SINGLE, EXEC_OMP_TASK, EXEC_OMP_TASKWAIT,\n-  EXEC_OMP_TASKYIELD\n+  EXEC_OMP_TASKYIELD, EXEC_OMP_CANCEL, EXEC_OMP_CANCELLATION_POINT,\n+  EXEC_OMP_TASKGROUP, EXEC_OMP_SIMD, EXEC_OMP_DO_SIMD,\n+  EXEC_OMP_PARALLEL_DO_SIMD\n }\n gfc_exec_op;\n \n typedef enum\n {\n-  GFC_OMP_ATOMIC_UPDATE,\n-  GFC_OMP_ATOMIC_READ,\n-  GFC_OMP_ATOMIC_WRITE,\n-  GFC_OMP_ATOMIC_CAPTURE\n+  GFC_OMP_ATOMIC_UPDATE = 0,\n+  GFC_OMP_ATOMIC_READ = 1,\n+  GFC_OMP_ATOMIC_WRITE = 2,\n+  GFC_OMP_ATOMIC_CAPTURE = 3,\n+  GFC_OMP_ATOMIC_MASK = 3,\n+  GFC_OMP_ATOMIC_SEQ_CST = 4,\n+  GFC_OMP_ATOMIC_SWAP = 8\n }\n gfc_omp_atomic_op;\n \n@@ -2177,7 +2244,7 @@ typedef struct gfc_code\n     gfc_entry_list *entry;\n     gfc_omp_clauses *omp_clauses;\n     const char *omp_name;\n-    gfc_namelist *omp_namelist;\n+    gfc_omp_namelist *omp_namelist;\n     bool omp_bool;\n     gfc_omp_atomic_op omp_atomic;\n   }\n@@ -2733,6 +2800,7 @@ void gfc_free_iterator (gfc_iterator *, int);\n void gfc_free_forall_iterator (gfc_forall_iterator *);\n void gfc_free_alloc_list (gfc_alloc *);\n void gfc_free_namelist (gfc_namelist *);\n+void gfc_free_omp_namelist (gfc_omp_namelist *);\n void gfc_free_equiv (gfc_equiv *);\n void gfc_free_equiv_until (gfc_equiv *, gfc_equiv *);\n void gfc_free_data (gfc_data *);\n@@ -2744,10 +2812,13 @@ gfc_expr *gfc_get_parentheses (gfc_expr *);\n /* openmp.c */\n struct gfc_omp_saved_state { void *ptrs[2]; int ints[1]; };\n void gfc_free_omp_clauses (gfc_omp_clauses *);\n+void gfc_free_omp_declare_simd (gfc_omp_declare_simd *);\n+void gfc_free_omp_declare_simd_list (gfc_omp_declare_simd *);\n void gfc_resolve_omp_directive (gfc_code *, gfc_namespace *);\n void gfc_resolve_do_iterator (gfc_code *, gfc_symbol *);\n void gfc_resolve_omp_parallel_blocks (gfc_code *, gfc_namespace *);\n void gfc_resolve_omp_do_blocks (gfc_code *, gfc_namespace *);\n+void gfc_resolve_omp_declare_simd (gfc_namespace *);\n void gfc_omp_save_and_clear_state (struct gfc_omp_saved_state *);\n void gfc_omp_restore_state (struct gfc_omp_saved_state *);\n "}, {"sha": "41915b4118ebde9e0f8a44a1c7ccb9a99823494d", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -2595,7 +2595,10 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n       && o != NULL\n       && o->state == COMP_OMP_STRUCTURED_BLOCK\n       && (o->head->op == EXEC_OMP_DO\n-\t  || o->head->op == EXEC_OMP_PARALLEL_DO))\n+\t  || o->head->op == EXEC_OMP_PARALLEL_DO\n+\t  || o->head->op == EXEC_OMP_SIMD\n+\t  || o->head->op == EXEC_OMP_DO_SIMD\n+\t  || o->head->op == EXEC_OMP_PARALLEL_DO_SIMD))\n     {\n       int collapse = 1;\n       gcc_assert (o->head->next != NULL\n@@ -4564,6 +4567,22 @@ gfc_free_namelist (gfc_namelist *name)\n }\n \n \n+/* Free an OpenMP namelist structure.  */\n+\n+void\n+gfc_free_omp_namelist (gfc_omp_namelist *name)\n+{\n+  gfc_omp_namelist *n;\n+\n+  for (; name; name = n)\n+    {\n+      gfc_free_expr (name->expr);\n+      n = name->next;\n+      free (name);\n+    }\n+}\n+\n+\n /* Match a NAMELIST statement.  */\n \n match"}, {"sha": "51c6b728ab4579e30057735cf9567ca3375a6a20", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -126,18 +126,25 @@ gfc_common_head *gfc_get_common (const char *, int);\n match gfc_match_omp_eos (void);\n match gfc_match_omp_atomic (void);\n match gfc_match_omp_barrier (void);\n+match gfc_match_omp_cancel (void);\n+match gfc_match_omp_cancellation_point (void);\n match gfc_match_omp_critical (void);\n+match gfc_match_omp_declare_simd (void);\n match gfc_match_omp_do (void);\n+match gfc_match_omp_do_simd (void);\n match gfc_match_omp_flush (void);\n match gfc_match_omp_master (void);\n match gfc_match_omp_ordered (void);\n match gfc_match_omp_parallel (void);\n match gfc_match_omp_parallel_do (void);\n+match gfc_match_omp_parallel_do_simd (void);\n match gfc_match_omp_parallel_sections (void);\n match gfc_match_omp_parallel_workshare (void);\n match gfc_match_omp_sections (void);\n+match gfc_match_omp_simd (void);\n match gfc_match_omp_single (void);\n match gfc_match_omp_task (void);\n+match gfc_match_omp_taskgroup (void);\n match gfc_match_omp_taskwait (void);\n match gfc_match_omp_taskyield (void);\n match gfc_match_omp_threadprivate (void);"}, {"sha": "8b374a2e4b09d485d6b211e88fcf9427f600d826", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -3790,6 +3790,111 @@ mio_full_f2k_derived (gfc_symbol *sym)\n   mio_rparen ();\n }\n \n+static const mstring omp_declare_simd_clauses[] =\n+{\n+    minit (\"INBRANCH\", 0),\n+    minit (\"NOTINBRANCH\", 1),\n+    minit (\"SIMDLEN\", 2),\n+    minit (\"UNIFORM\", 3),\n+    minit (\"LINEAR\", 4),\n+    minit (\"ALIGNED\", 5),\n+    minit (NULL, -1)\n+};\n+\n+/* Handle !$omp declare simd.  */\n+\n+static void\n+mio_omp_declare_simd (gfc_namespace *ns, gfc_omp_declare_simd **odsp)\n+{\n+  if (iomode == IO_OUTPUT)\n+    {\n+      if (*odsp == NULL)\n+\treturn;\n+    }\n+  else if (peek_atom () != ATOM_LPAREN)\n+    return;\n+\n+  gfc_omp_declare_simd *ods = *odsp;\n+\n+  mio_lparen ();\n+  if (iomode == IO_OUTPUT)\n+    {\n+      write_atom (ATOM_NAME, \"OMP_DECLARE_SIMD\");\n+      if (ods->clauses)\n+\t{\n+\t  gfc_omp_namelist *n;\n+\n+\t  if (ods->clauses->inbranch)\n+\t    mio_name (0, omp_declare_simd_clauses);\n+\t  if (ods->clauses->notinbranch)\n+\t    mio_name (1, omp_declare_simd_clauses);\n+\t  if (ods->clauses->simdlen_expr)\n+\t    {\n+\t      mio_name (2, omp_declare_simd_clauses);\n+\t      mio_expr (&ods->clauses->simdlen_expr);\n+\t    }\n+\t  for (n = ods->clauses->lists[OMP_LIST_UNIFORM]; n; n = n->next)\n+\t    {\n+\t      mio_name (3, omp_declare_simd_clauses);\n+\t      mio_symbol_ref (&n->sym);\n+\t    }\n+\t  for (n = ods->clauses->lists[OMP_LIST_LINEAR]; n; n = n->next)\n+\t    {\n+\t      mio_name (4, omp_declare_simd_clauses);\n+\t      mio_symbol_ref (&n->sym);\n+\t      mio_expr (&n->expr);\n+\t    }\n+\t  for (n = ods->clauses->lists[OMP_LIST_ALIGNED]; n; n = n->next)\n+\t    {\n+\t      mio_name (5, omp_declare_simd_clauses);\n+\t      mio_symbol_ref (&n->sym);\n+\t      mio_expr (&n->expr);\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      gfc_omp_namelist **ptrs[3] = { NULL, NULL, NULL };\n+\n+      require_atom (ATOM_NAME);\n+      *odsp = ods = gfc_get_omp_declare_simd ();\n+      ods->where = gfc_current_locus;\n+      ods->proc_name = ns->proc_name;\n+      if (peek_atom () == ATOM_NAME)\n+\t{\n+\t  ods->clauses = gfc_get_omp_clauses ();\n+\t  ptrs[0] = &ods->clauses->lists[OMP_LIST_UNIFORM];\n+\t  ptrs[1] = &ods->clauses->lists[OMP_LIST_LINEAR];\n+\t  ptrs[2] = &ods->clauses->lists[OMP_LIST_ALIGNED];\n+\t}\n+      while (peek_atom () == ATOM_NAME)\n+\t{\n+\t  gfc_omp_namelist *n;\n+\t  int t = mio_name (0, omp_declare_simd_clauses);\n+\n+\t  switch (t)\n+\t    {\n+\t    case 0: ods->clauses->inbranch = true; break;\n+\t    case 1: ods->clauses->notinbranch = true; break;\n+\t    case 2: mio_expr (&ods->clauses->simdlen_expr); break;\n+\t    case 3:\n+\t    case 4:\n+\t    case 5:\n+\t      *ptrs[t - 3] = n = gfc_get_omp_namelist ();\n+\t      ptrs[t - 3] = &n->next;\n+\t      mio_symbol_ref (&n->sym);\n+\t      if (t != 3)\n+\t\tmio_expr (&n->expr);\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  mio_omp_declare_simd (ns, &ods->next);\n+\n+  mio_rparen ();\n+}\n+\n \n /* Unlike most other routines, the address of the symbol node is already\n    fixed on input and the name/module has already been filled in.\n@@ -3864,6 +3969,11 @@ mio_symbol (gfc_symbol *sym)\n   if (sym->attr.flavor == FL_DERIVED)\n     mio_integer (&(sym->hash_value));\n \n+  if (sym->formal_ns\n+      && sym->formal_ns->proc_name == sym\n+      && sym->formal_ns->entries == NULL)\n+    mio_omp_declare_simd (sym->formal_ns, &sym->formal_ns->omp_declare_simd);\n+\n   mio_rparen ();\n }\n "}, {"sha": "16c777417bb8941ffac001428bdb7d0437ccc8bf", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 638, "deletions": 92, "changes": 730, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -69,19 +69,47 @@ gfc_free_omp_clauses (gfc_omp_clauses *c)\n   gfc_free_expr (c->final_expr);\n   gfc_free_expr (c->num_threads);\n   gfc_free_expr (c->chunk_size);\n+  gfc_free_expr (c->safelen_expr);\n+  gfc_free_expr (c->simdlen_expr);\n   for (i = 0; i < OMP_LIST_NUM; i++)\n-    gfc_free_namelist (c->lists[i]);\n+    gfc_free_omp_namelist (c->lists[i]);\n   free (c);\n }\n \n+/* Free an !$omp declare simd construct list.  */\n+\n+void\n+gfc_free_omp_declare_simd (gfc_omp_declare_simd *ods)\n+{\n+  if (ods)\n+    {\n+      gfc_free_omp_clauses (ods->clauses);\n+      free (ods);\n+    }\n+}\n+\n+void\n+gfc_free_omp_declare_simd_list (gfc_omp_declare_simd *list)\n+{\n+  while (list)\n+    {\n+      gfc_omp_declare_simd *current = list;\n+      list = list->next;\n+      gfc_free_omp_declare_simd (current);\n+    }\n+}\n+\n+\n /* Match a variable/common block list and construct a namelist from it.  */\n \n static match\n-gfc_match_omp_variable_list (const char *str, gfc_namelist **list,\n-\t\t\t     bool allow_common)\n+gfc_match_omp_variable_list (const char *str, gfc_omp_namelist **list,\n+\t\t\t     bool allow_common, bool *end_colon = NULL,\n+\t\t\t     gfc_omp_namelist ***headp = NULL,\n+\t\t\t     bool allow_sections = false)\n {\n-  gfc_namelist *head, *tail, *p;\n-  locus old_loc;\n+  gfc_omp_namelist *head, *tail, *p;\n+  locus old_loc, cur_loc;\n   char n[GFC_MAX_SYMBOL_LEN+1];\n   gfc_symbol *sym;\n   match m;\n@@ -97,12 +125,29 @@ gfc_match_omp_variable_list (const char *str, gfc_namelist **list,\n \n   for (;;)\n     {\n+      cur_loc = gfc_current_locus;\n       m = gfc_match_symbol (&sym, 1);\n       switch (m)\n \t{\n \tcase MATCH_YES:\n+\t  gfc_expr *expr;\n+\t  expr = NULL;\n+\t  if (allow_sections && gfc_peek_ascii_char () == '(')\n+\t    {\n+\t      gfc_current_locus = cur_loc;\n+\t      m = gfc_match_variable (&expr, 0);\n+\t      switch (m)\n+\t\t{\n+\t\tcase MATCH_ERROR:\n+\t\t  goto cleanup;\n+\t\tcase MATCH_NO:\n+\t\t  goto syntax;\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\t    }\n \t  gfc_set_sym_referenced (sym);\n-\t  p = gfc_get_namelist ();\n+\t  p = gfc_get_omp_namelist ();\n \t  if (head == NULL)\n \t    head = tail = p;\n \t  else\n@@ -111,6 +156,7 @@ gfc_match_omp_variable_list (const char *str, gfc_namelist **list,\n \t      tail = tail->next;\n \t    }\n \t  tail->sym = sym;\n+\t  tail->expr = expr;\n \t  goto next_item;\n \tcase MATCH_NO:\n \t  break;\n@@ -136,7 +182,7 @@ gfc_match_omp_variable_list (const char *str, gfc_namelist **list,\n       for (sym = st->n.common->head; sym; sym = sym->common_next)\n \t{\n \t  gfc_set_sym_referenced (sym);\n-\t  p = gfc_get_namelist ();\n+\t  p = gfc_get_omp_namelist ();\n \t  if (head == NULL)\n \t    head = tail = p;\n \t  else\n@@ -148,6 +194,11 @@ gfc_match_omp_variable_list (const char *str, gfc_namelist **list,\n \t}\n \n     next_item:\n+      if (end_colon && gfc_match_char (':') == MATCH_YES)\n+\t{\n+\t  *end_colon = true;\n+\t  break;\n+\t}\n       if (gfc_match_char (')') == MATCH_YES)\n \tbreak;\n       if (gfc_match_char (',') != MATCH_YES)\n@@ -158,13 +209,15 @@ gfc_match_omp_variable_list (const char *str, gfc_namelist **list,\n     list = &(*list)->next;\n \n   *list = head;\n+  if (headp)\n+    *headp = list;\n   return MATCH_YES;\n \n syntax:\n   gfc_error (\"Syntax error in OpenMP variable list at %C\");\n \n cleanup:\n-  gfc_free_namelist (head);\n+  gfc_free_omp_namelist (head);\n   gfc_current_locus = old_loc;\n   return MATCH_ERROR;\n }\n@@ -185,16 +238,25 @@ gfc_match_omp_variable_list (const char *str, gfc_namelist **list,\n #define OMP_CLAUSE_UNTIED\t(1 << 13)\n #define OMP_CLAUSE_FINAL\t(1 << 14)\n #define OMP_CLAUSE_MERGEABLE\t(1 << 15)\n+#define OMP_CLAUSE_ALIGNED\t(1 << 16)\n+#define OMP_CLAUSE_DEPEND\t(1 << 17)\n+#define OMP_CLAUSE_INBRANCH\t(1 << 18)\n+#define OMP_CLAUSE_LINEAR\t(1 << 19)\n+#define OMP_CLAUSE_NOTINBRANCH\t(1 << 20)\n+#define OMP_CLAUSE_PROC_BIND\t(1 << 21)\n+#define OMP_CLAUSE_SAFELEN\t(1 << 22)\n+#define OMP_CLAUSE_SIMDLEN\t(1 << 23)\n+#define OMP_CLAUSE_UNIFORM\t(1 << 24)\n \n /* Match OpenMP directive clauses. MASK is a bitmask of\n    clauses that are allowed for a particular directive.  */\n \n static match\n-gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask)\n+gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask, bool first = true,\n+\t\t       bool needs_space = true)\n {\n   gfc_omp_clauses *c = gfc_get_omp_clauses ();\n   locus old_loc;\n-  bool needs_space = true, first = true;\n \n   *cp = NULL;\n   while (1)\n@@ -419,6 +481,115 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask)\n \t      continue;\n \t    }\n \t}\n+      if ((mask & OMP_CLAUSE_INBRANCH) && !c->inbranch\n+\t  && gfc_match (\"inbranch\") == MATCH_YES)\n+\t{\n+\t  c->inbranch = needs_space = true;\n+\t  continue;\n+\t}\n+      if ((mask & OMP_CLAUSE_NOTINBRANCH) && !c->notinbranch\n+\t  && gfc_match (\"notinbranch\") == MATCH_YES)\n+\t{\n+\t  c->notinbranch = needs_space = true;\n+\t  continue;\n+\t}\n+      if ((mask & OMP_CLAUSE_PROC_BIND)\n+\t  && c->proc_bind == OMP_PROC_BIND_UNKNOWN)\n+\t{\n+\t  if (gfc_match (\"proc_bind ( master )\") == MATCH_YES)\n+\t    c->proc_bind = OMP_PROC_BIND_MASTER;\n+\t  else if (gfc_match (\"proc_bind ( spread )\") == MATCH_YES)\n+\t    c->proc_bind = OMP_PROC_BIND_SPREAD;\n+\t  else if (gfc_match (\"proc_bind ( close )\") == MATCH_YES)\n+\t    c->proc_bind = OMP_PROC_BIND_CLOSE;\n+\t  if (c->proc_bind != OMP_PROC_BIND_UNKNOWN)\n+\t    continue;\n+\t}\n+      if ((mask & OMP_CLAUSE_SAFELEN) && c->safelen_expr == NULL\n+\t  && gfc_match (\"safelen ( %e )\", &c->safelen_expr) == MATCH_YES)\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_SIMDLEN) && c->simdlen_expr == NULL\n+\t  && gfc_match (\"simdlen ( %e )\", &c->simdlen_expr) == MATCH_YES)\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_UNIFORM)\n+\t  && gfc_match_omp_variable_list (\"uniform (\",\n+\t\t\t\t\t  &c->lists[OMP_LIST_UNIFORM], false)\n+\t     == MATCH_YES)\n+\tcontinue;\n+      bool end_colon = false;\n+      gfc_omp_namelist **head = NULL;\n+      old_loc = gfc_current_locus;\n+      if ((mask & OMP_CLAUSE_ALIGNED)\n+\t  && gfc_match_omp_variable_list (\"aligned (\",\n+\t\t\t\t\t  &c->lists[OMP_LIST_ALIGNED], false,\n+\t\t\t\t\t  &end_colon, &head)\n+\t     == MATCH_YES)\n+\t{\n+\t  gfc_expr *alignment = NULL;\n+\t  gfc_omp_namelist *n;\n+\n+\t  if (end_colon\n+\t      && gfc_match (\" %e )\", &alignment) != MATCH_YES)\n+\t    {\n+\t      gfc_free_omp_namelist (*head);\n+\t      gfc_current_locus = old_loc;\n+\t      *head = NULL;\n+\t      break;\n+\t    }\n+\t  for (n = *head; n; n = n->next)\n+\t    if (n->next && alignment)\n+\t      n->expr = gfc_copy_expr (alignment);\n+\t    else\n+\t      n->expr = alignment;\n+\t  continue;\n+\t}\n+      end_colon = false;\n+      head = NULL;\n+      old_loc = gfc_current_locus;\n+      if ((mask & OMP_CLAUSE_LINEAR)\n+\t  && gfc_match_omp_variable_list (\"linear (\",\n+\t\t\t\t\t  &c->lists[OMP_LIST_LINEAR], false,\n+\t\t\t\t\t  &end_colon, &head)\n+\t     == MATCH_YES)\n+\t{\n+\t  gfc_expr *step = NULL;\n+\n+\t  if (end_colon\n+\t      && gfc_match (\" %e )\", &step) != MATCH_YES)\n+\t    {\n+\t      gfc_free_omp_namelist (*head);\n+\t      gfc_current_locus = old_loc;\n+\t      *head = NULL;\n+\t      break;\n+\t    }\n+\t  else if (!end_colon)\n+\t    {\n+\t      step = gfc_get_constant_expr (BT_INTEGER,\n+\t\t\t\t\t    gfc_default_integer_kind,\n+\t\t\t\t\t    &old_loc);\n+\t      mpz_set_si (step->value.integer, 1);\n+\t    }\n+\t  (*head)->expr = step;\n+\t  continue;\n+\t}\n+      if ((mask & OMP_CLAUSE_DEPEND)\n+\t  && gfc_match_omp_variable_list (\"depend ( in : \",\n+\t\t\t\t\t  &c->lists[OMP_LIST_DEPEND_IN], false,\n+\t\t\t\t\t  NULL, NULL, true)\n+\t     == MATCH_YES)\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_DEPEND)\n+\t  && gfc_match_omp_variable_list (\"depend ( out : \",\n+\t\t\t\t\t  &c->lists[OMP_LIST_DEPEND_OUT], false,\n+\t\t\t\t\t  NULL, NULL, true)\n+\t     == MATCH_YES)\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_DEPEND)\n+\t  && gfc_match_omp_variable_list (\"depend ( inout : \",\n+\t\t\t\t\t  &c->lists[OMP_LIST_DEPEND_OUT], false,\n+\t\t\t\t\t  NULL, NULL, true)\n+\t     == MATCH_YES)\n+\tcontinue;\n \n       break;\n     }\n@@ -436,18 +607,25 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask)\n #define OMP_PARALLEL_CLAUSES \\\n   (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE | OMP_CLAUSE_SHARED\t\\\n    | OMP_CLAUSE_COPYIN | OMP_CLAUSE_REDUCTION | OMP_CLAUSE_IF\t\t\\\n-   | OMP_CLAUSE_NUM_THREADS | OMP_CLAUSE_DEFAULT)\n+   | OMP_CLAUSE_NUM_THREADS | OMP_CLAUSE_DEFAULT | OMP_CLAUSE_PROC_BIND)\n+#define OMP_DECLARE_SIMD_CLAUSES \\\n+  (OMP_CLAUSE_SIMDLEN | OMP_CLAUSE_LINEAR | OMP_CLAUSE_UNIFORM\t\t\\\n+   | OMP_CLAUSE_ALIGNED)\n #define OMP_DO_CLAUSES \\\n   (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE\t\t\t\t\\\n    | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_REDUCTION\t\t\t\\\n    | OMP_CLAUSE_SCHEDULE | OMP_CLAUSE_ORDERED | OMP_CLAUSE_COLLAPSE)\n #define OMP_SECTIONS_CLAUSES \\\n   (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE\t\t\t\t\\\n    | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_REDUCTION)\n+#define OMP_SIMD_CLAUSES \\\n+  (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_REDUCTION\t\\\n+   | OMP_CLAUSE_COLLAPSE | OMP_CLAUSE_SAFELEN | OMP_CLAUSE_LINEAR\t\\\n+   | OMP_CLAUSE_ALIGNED)\n #define OMP_TASK_CLAUSES \\\n   (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE | OMP_CLAUSE_SHARED\t\\\n    | OMP_CLAUSE_IF | OMP_CLAUSE_DEFAULT | OMP_CLAUSE_UNTIED\t\t\\\n-   | OMP_CLAUSE_FINAL | OMP_CLAUSE_MERGEABLE)\n+   | OMP_CLAUSE_FINAL | OMP_CLAUSE_MERGEABLE | OMP_CLAUSE_DEPEND)\n \n match\n gfc_match_omp_parallel (void)\n@@ -531,15 +709,29 @@ gfc_match_omp_do (void)\n }\n \n \n+match\n+gfc_match_omp_do_simd (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, ((OMP_DO_CLAUSES | OMP_SIMD_CLAUSES)\n+\t\t\t\t  & ~OMP_CLAUSE_ORDERED))\n+      != MATCH_YES)\n+    return MATCH_ERROR;\n+  new_st.op = EXEC_OMP_DO_SIMD;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+\n match\n gfc_match_omp_flush (void)\n {\n-  gfc_namelist *list = NULL;\n+  gfc_omp_namelist *list = NULL;\n   gfc_match_omp_variable_list (\" (\", &list, true);\n   if (gfc_match_omp_eos () != MATCH_YES)\n     {\n       gfc_error (\"Unexpected junk after $OMP FLUSH statement at %C\");\n-      gfc_free_namelist (list);\n+      gfc_free_omp_namelist (list);\n       return MATCH_ERROR;\n     }\n   new_st.op = EXEC_OMP_FLUSH;\n@@ -548,6 +740,43 @@ gfc_match_omp_flush (void)\n }\n \n \n+match\n+gfc_match_omp_simd (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, OMP_SIMD_CLAUSES) != MATCH_YES)\n+    return MATCH_ERROR;\n+  new_st.op = EXEC_OMP_SIMD;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+\n+match\n+gfc_match_omp_declare_simd (void)\n+{\n+  locus where = gfc_current_locus;\n+  gfc_symbol *proc_name;\n+  gfc_omp_clauses *c;\n+  gfc_omp_declare_simd *ods;\n+\n+  if (gfc_match (\" ( %s ) \", &proc_name) != MATCH_YES)\n+    return MATCH_ERROR;\n+\n+  if (gfc_match_omp_clauses (&c, OMP_DECLARE_SIMD_CLAUSES, true,\n+\t\t\t     false) != MATCH_YES)\n+    return MATCH_ERROR;\n+\n+  ods = gfc_get_omp_declare_simd ();\n+  ods->where = where;\n+  ods->proc_name = proc_name;\n+  ods->clauses = c;\n+  ods->next = gfc_current_ns->omp_declare_simd;\n+  gfc_current_ns->omp_declare_simd = ods;\n+  return MATCH_YES;\n+}\n+\n+\n match\n gfc_match_omp_threadprivate (void)\n {\n@@ -629,6 +858,20 @@ gfc_match_omp_parallel_do (void)\n }\n \n \n+match\n+gfc_match_omp_parallel_do_simd (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, (OMP_PARALLEL_CLAUSES | OMP_DO_CLAUSES\n+\t\t\t\t  | OMP_SIMD_CLAUSES) & ~OMP_CLAUSE_ORDERED)\n+      != MATCH_YES)\n+    return MATCH_ERROR;\n+  new_st.op = EXEC_OMP_PARALLEL_DO_SIMD;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+\n match\n gfc_match_omp_parallel_sections (void)\n {\n@@ -725,20 +968,44 @@ match\n gfc_match_omp_atomic (void)\n {\n   gfc_omp_atomic_op op = GFC_OMP_ATOMIC_UPDATE;\n-  if (gfc_match (\"% update\") == MATCH_YES)\n-    op = GFC_OMP_ATOMIC_UPDATE;\n-  else if (gfc_match (\"% read\") == MATCH_YES)\n-    op = GFC_OMP_ATOMIC_READ;\n-  else if (gfc_match (\"% write\") == MATCH_YES)\n-    op = GFC_OMP_ATOMIC_WRITE;\n-  else if (gfc_match (\"% capture\") == MATCH_YES)\n-    op = GFC_OMP_ATOMIC_CAPTURE;\n+  int seq_cst = 0;\n+  if (gfc_match (\"% seq_cst\") == MATCH_YES)\n+    seq_cst = 1;\n+  locus old_loc = gfc_current_locus;\n+  if (seq_cst && gfc_match_char (',') == MATCH_YES)\n+    seq_cst = 2;\n+  if (seq_cst == 2\n+      || gfc_match_space () == MATCH_YES)\n+    {\n+      gfc_gobble_whitespace ();\n+      if (gfc_match (\"update\") == MATCH_YES)\n+\top = GFC_OMP_ATOMIC_UPDATE;\n+      else if (gfc_match (\"read\") == MATCH_YES)\n+\top = GFC_OMP_ATOMIC_READ;\n+      else if (gfc_match (\"write\") == MATCH_YES)\n+\top = GFC_OMP_ATOMIC_WRITE;\n+      else if (gfc_match (\"capture\") == MATCH_YES)\n+\top = GFC_OMP_ATOMIC_CAPTURE;\n+      else\n+\t{\n+\t  if (seq_cst == 2)\n+\t    gfc_current_locus = old_loc;\n+\t  goto finish;\n+\t}\n+      if (!seq_cst\n+\t  && (gfc_match (\", seq_cst\") == MATCH_YES\n+\t      || gfc_match (\"% seq_cst\") == MATCH_YES))\n+\tseq_cst = 1;\n+    }\n+ finish:\n   if (gfc_match_omp_eos () != MATCH_YES)\n     {\n       gfc_error (\"Unexpected junk after $OMP ATOMIC statement at %C\");\n       return MATCH_ERROR;\n     }\n   new_st.op = EXEC_OMP_ATOMIC;\n+  if (seq_cst)\n+    op = (gfc_omp_atomic_op) (op | GFC_OMP_ATOMIC_SEQ_CST);\n   new_st.ext.omp_atomic = op;\n   return MATCH_YES;\n }\n@@ -758,6 +1025,73 @@ gfc_match_omp_barrier (void)\n }\n \n \n+match\n+gfc_match_omp_taskgroup (void)\n+{\n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    {\n+      gfc_error (\"Unexpected junk after $OMP TASKGROUP statement at %C\");\n+      return MATCH_ERROR;\n+    }\n+  new_st.op = EXEC_OMP_TASKGROUP;\n+  return MATCH_YES;\n+}\n+\n+\n+static enum gfc_omp_cancel_kind\n+gfc_match_omp_cancel_kind (void)\n+{\n+  if (gfc_match_space () != MATCH_YES)\n+    return OMP_CANCEL_UNKNOWN;\n+  if (gfc_match (\"parallel\") == MATCH_YES)\n+    return OMP_CANCEL_PARALLEL;\n+  if (gfc_match (\"sections\") == MATCH_YES)\n+    return OMP_CANCEL_SECTIONS;\n+  if (gfc_match (\"do\") == MATCH_YES)\n+    return OMP_CANCEL_DO;\n+  if (gfc_match (\"taskgroup\") == MATCH_YES)\n+    return OMP_CANCEL_TASKGROUP;\n+  return OMP_CANCEL_UNKNOWN;\n+}\n+\n+\n+match\n+gfc_match_omp_cancel (void)\n+{\n+  gfc_omp_clauses *c;\n+  enum gfc_omp_cancel_kind kind = gfc_match_omp_cancel_kind ();\n+  if (kind == OMP_CANCEL_UNKNOWN)\n+    return MATCH_ERROR;\n+  if (gfc_match_omp_clauses (&c, OMP_CLAUSE_IF, false) != MATCH_YES)\n+    return MATCH_ERROR;\n+  c->cancel = kind;\n+  new_st.op = EXEC_OMP_CANCEL;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+\n+match\n+gfc_match_omp_cancellation_point (void)\n+{\n+  gfc_omp_clauses *c;\n+  enum gfc_omp_cancel_kind kind = gfc_match_omp_cancel_kind ();\n+  if (kind == OMP_CANCEL_UNKNOWN)\n+    return MATCH_ERROR;\n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    {\n+      gfc_error (\"Unexpected junk after $OMP CANCELLATION POINT statement \"\n+\t\t \"at %C\");\n+      return MATCH_ERROR;\n+    }\n+  c = gfc_get_omp_clauses ();\n+  c->cancel = kind;\n+  new_st.op = EXEC_OMP_CANCELLATION_POINT;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+\n match\n gfc_match_omp_end_nowait (void)\n {\n@@ -796,14 +1130,15 @@ gfc_match_omp_end_single (void)\n /* OpenMP directive resolving routines.  */\n \n static void\n-resolve_omp_clauses (gfc_code *code)\n+resolve_omp_clauses (gfc_code *code, locus *where,\n+\t\t     gfc_omp_clauses *omp_clauses, gfc_namespace *ns)\n {\n-  gfc_omp_clauses *omp_clauses = code->ext.omp_clauses;\n-  gfc_namelist *n;\n+  gfc_omp_namelist *n;\n   int list;\n   static const char *clause_names[]\n     = { \"PRIVATE\", \"FIRSTPRIVATE\", \"LASTPRIVATE\", \"COPYPRIVATE\", \"SHARED\",\n-\t\"COPYIN\", \"REDUCTION\" };\n+\t\"COPYIN\", \"UNIFORM\", \"ALIGNED\", \"LINEAR\", \"DEPEND\", \"DEPEND\",\n+\t\"REDUCTION\" };\n \n   if (omp_clauses == NULL)\n     return;\n@@ -847,8 +1182,15 @@ resolve_omp_clauses (gfc_code *code)\n     for (n = omp_clauses->lists[list]; n; n = n->next)\n       {\n \tn->sym->mark = 0;\n-\tif (n->sym->attr.flavor == FL_VARIABLE || n->sym->attr.proc_pointer)\n-\t  continue;\n+\tif (n->sym->attr.flavor == FL_VARIABLE\n+\t    || n->sym->attr.proc_pointer\n+\t    || (!code && (!n->sym->attr.dummy || n->sym->ns != ns)))\n+\t  {\n+\t    if (!code && (!n->sym->attr.dummy || n->sym->ns != ns))\n+\t      gfc_error (\"Variable '%s' is not a dummy argument at %L\",\n+\t\t\t n->sym->name, where);\n+\t    continue;\n+\t  }\n \tif (n->sym->attr.flavor == FL_PROCEDURE\n \t    && n->sym->result == n->sym\n \t    && n->sym->attr.function)\n@@ -878,16 +1220,20 @@ resolve_omp_clauses (gfc_code *code)\n \t      }\n \t  }\n \tgfc_error (\"Object '%s' is not a variable at %L\", n->sym->name,\n-\t\t   &code->loc);\n+\t\t   where);\n       }\n \n   for (list = 0; list < OMP_LIST_NUM; list++)\n-    if (list != OMP_LIST_FIRSTPRIVATE && list != OMP_LIST_LASTPRIVATE)\n+    if (list != OMP_LIST_FIRSTPRIVATE\n+\t&& list != OMP_LIST_LASTPRIVATE\n+\t&& list != OMP_LIST_ALIGNED\n+\t&& list != OMP_LIST_DEPEND_IN\n+\t&& list != OMP_LIST_DEPEND_OUT)\n       for (n = omp_clauses->lists[list]; n; n = n->next)\n \t{\n \t  if (n->sym->mark)\n \t    gfc_error (\"Symbol '%s' present on multiple clauses at %L\",\n-\t\t       n->sym->name, &code->loc);\n+\t\t       n->sym->name, where);\n \t  else\n \t    n->sym->mark = 1;\n \t}\n@@ -898,15 +1244,15 @@ resolve_omp_clauses (gfc_code *code)\n       if (n->sym->mark)\n \t{\n \t  gfc_error (\"Symbol '%s' present on multiple clauses at %L\",\n-\t\t     n->sym->name, &code->loc);\n+\t\t     n->sym->name, where);\n \t  n->sym->mark = 0;\n \t}\n \n   for (n = omp_clauses->lists[OMP_LIST_FIRSTPRIVATE]; n; n = n->next)\n     {\n       if (n->sym->mark)\n \tgfc_error (\"Symbol '%s' present on multiple clauses at %L\",\n-\t\t   n->sym->name, &code->loc);\n+\t\t   n->sym->name, where);\n       else\n \tn->sym->mark = 1;\n     }\n@@ -917,10 +1263,23 @@ resolve_omp_clauses (gfc_code *code)\n     {\n       if (n->sym->mark)\n \tgfc_error (\"Symbol '%s' present on multiple clauses at %L\",\n-\t\t   n->sym->name, &code->loc);\n+\t\t   n->sym->name, where);\n       else\n \tn->sym->mark = 1;\n     }\n+\n+  for (n = omp_clauses->lists[OMP_LIST_ALIGNED]; n; n = n->next)\n+    n->sym->mark = 0;\n+\n+  for (n = omp_clauses->lists[OMP_LIST_ALIGNED]; n; n = n->next)\n+    {\n+      if (n->sym->mark)\n+\tgfc_error (\"Symbol '%s' present on multiple clauses at %L\",\n+\t\t   n->sym->name, where);\n+      else\n+\tn->sym->mark = 1;\n+    }\n+\n   for (list = 0; list < OMP_LIST_NUM; list++)\n     if ((n = omp_clauses->lists[list]) != NULL)\n       {\n@@ -940,71 +1299,150 @@ resolve_omp_clauses (gfc_code *code)\n \t      {\n \t\tif (!n->sym->attr.threadprivate)\n \t\t  gfc_error (\"Non-THREADPRIVATE object '%s' in COPYIN clause\"\n-\t\t\t     \" at %L\", n->sym->name, &code->loc);\n+\t\t\t     \" at %L\", n->sym->name, where);\n \t\tif (n->sym->ts.type == BT_DERIVED && n->sym->ts.u.derived->attr.alloc_comp)\n \t\t  gfc_error (\"COPYIN clause object '%s' at %L has ALLOCATABLE components\",\n-\t\t\t     n->sym->name, &code->loc);\n+\t\t\t     n->sym->name, where);\n \t      }\n \t    break;\n \t  case OMP_LIST_COPYPRIVATE:\n \t    for (; n != NULL; n = n->next)\n \t      {\n \t\tif (n->sym->as && n->sym->as->type == AS_ASSUMED_SIZE)\n \t\t  gfc_error (\"Assumed size array '%s' in COPYPRIVATE clause \"\n-\t\t\t     \"at %L\", n->sym->name, &code->loc);\n+\t\t\t     \"at %L\", n->sym->name, where);\n \t\tif (n->sym->ts.type == BT_DERIVED && n->sym->ts.u.derived->attr.alloc_comp)\n \t\t  gfc_error (\"COPYPRIVATE clause object '%s' at %L has ALLOCATABLE components\",\n-\t\t\t     n->sym->name, &code->loc);\n+\t\t\t     n->sym->name, where);\n \t      }\n \t    break;\n \t  case OMP_LIST_SHARED:\n \t    for (; n != NULL; n = n->next)\n \t      {\n \t\tif (n->sym->attr.threadprivate)\n \t\t  gfc_error (\"THREADPRIVATE object '%s' in SHARED clause at \"\n-\t\t\t     \"%L\", n->sym->name, &code->loc);\n+\t\t\t     \"%L\", n->sym->name, where);\n \t\tif (n->sym->attr.cray_pointee)\n \t\t  gfc_error (\"Cray pointee '%s' in SHARED clause at %L\",\n-\t\t\t    n->sym->name, &code->loc);\n+\t\t\t    n->sym->name, where);\n+\t      }\n+\t    break;\n+\t  case OMP_LIST_ALIGNED:\n+\t    for (; n != NULL; n = n->next)\n+\t      {\n+\t\tif (!n->sym->attr.pointer\n+\t\t    && !n->sym->attr.allocatable\n+\t\t    && !n->sym->attr.cray_pointer\n+\t\t    && (n->sym->ts.type != BT_DERIVED\n+\t\t\t|| (n->sym->ts.u.derived->from_intmod\n+\t\t\t    != INTMOD_ISO_C_BINDING)\n+\t\t\t|| (n->sym->ts.u.derived->intmod_sym_id\n+\t\t\t    != ISOCBINDING_PTR)))\n+\t\t  gfc_error (\"'%s' in ALIGNED clause must be POINTER, \"\n+\t\t\t     \"ALLOCATABLE, Cray pointer or C_PTR at %L\",\n+\t\t\t     n->sym->name, where);\n+\t\telse if (n->expr)\n+\t\t  {\n+\t\t    gfc_expr *expr = n->expr;\n+\t\t    int alignment = 0;\n+\t\t    if (!gfc_resolve_expr (expr)\n+\t\t\t|| expr->ts.type != BT_INTEGER\n+\t\t\t|| expr->rank != 0\n+\t\t\t|| gfc_extract_int (expr, &alignment)\n+\t\t\t|| alignment <= 0)\n+\t\t      gfc_error (\"'%s' in ALIGNED clause at %L requires a scalar \"\n+\t\t\t\t \"positive constant integer alignment \"\n+\t\t\t\t \"expression\", n->sym->name, where);\n+\t\t  }\n \t      }\n \t    break;\n+\t  case OMP_LIST_DEPEND_IN:\n+\t  case OMP_LIST_DEPEND_OUT:\n+\t    for (; n != NULL; n = n->next)\n+\t      if (n->expr)\n+\t\t{\n+\t\t  if (!gfc_resolve_expr (n->expr)\n+\t\t      || n->expr->expr_type != EXPR_VARIABLE\n+\t\t      || n->expr->ref == NULL\n+\t\t      || n->expr->ref->next\n+\t\t      || n->expr->ref->type != REF_ARRAY)\n+\t\t    gfc_error (\"'%s' in DEPEND clause at %L is not a proper \"\n+\t\t\t       \"array section\", n->sym->name, where);\n+\t\t  else if (n->expr->ref->u.ar.codimen)\n+\t\t    gfc_error (\"Coarrays not supported in DEPEND clause at %L\",\n+\t\t\t       where);\n+\t\t  else\n+\t\t    {\n+\t\t      int i;\n+\t\t      gfc_array_ref *ar = &n->expr->ref->u.ar;\n+\t\t      for (i = 0; i < ar->dimen; i++)\n+\t\t\tif (ar->stride[i])\n+\t\t\t  {\n+\t\t\t    gfc_error (\"Stride should not be specified for \"\n+\t\t\t\t       \"array section in DEPEND clause at %L\",\n+\t\t\t\t       where);\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t\telse if (ar->dimen_type[i] != DIMEN_ELEMENT\n+\t\t\t\t && ar->dimen_type[i] != DIMEN_RANGE)\n+\t\t\t  {\n+\t\t\t    gfc_error (\"'%s' in DEPEND clause at %L is not a \"\n+\t\t\t\t       \"proper array section\",\n+\t\t\t\t       n->sym->name, where);\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t\telse if (ar->start[i]\n+\t\t\t\t && ar->start[i]->expr_type == EXPR_CONSTANT\n+\t\t\t\t && ar->end[i]\n+\t\t\t\t && ar->end[i]->expr_type == EXPR_CONSTANT\n+\t\t\t\t && mpz_cmp (ar->start[i]->value.integer,\n+\t\t\t\t\t     ar->end[i]->value.integer) > 0)\n+\t\t\t  {\n+\t\t\t    gfc_error (\"'%s' in DEPEND clause at %L is a zero \"\n+\t\t\t\t       \"size array section\", n->sym->name,\n+\t\t\t\t       where);\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t    }\n+\t\t}\n+\t    break;\n \t  default:\n \t    for (; n != NULL; n = n->next)\n \t      {\n \t\tif (n->sym->attr.threadprivate)\n \t\t  gfc_error (\"THREADPRIVATE object '%s' in %s clause at %L\",\n-\t\t\t     n->sym->name, name, &code->loc);\n+\t\t\t     n->sym->name, name, where);\n \t\tif (n->sym->attr.cray_pointee)\n \t\t  gfc_error (\"Cray pointee '%s' in %s clause at %L\",\n-\t\t\t    n->sym->name, name, &code->loc);\n+\t\t\t    n->sym->name, name, where);\n \t\tif (list != OMP_LIST_PRIVATE)\n \t\t  {\n \t\t    if (n->sym->attr.pointer\n \t\t\t&& list >= OMP_LIST_REDUCTION_FIRST\n \t\t\t&& list <= OMP_LIST_REDUCTION_LAST)\n \t\t      gfc_error (\"POINTER object '%s' in %s clause at %L\",\n-\t\t\t\t n->sym->name, name, &code->loc);\n+\t\t\t\t n->sym->name, name, where);\n \t\t    /* Variables in REDUCTION-clauses must be of intrinsic type (flagged below).  */\n \t\t    if ((list < OMP_LIST_REDUCTION_FIRST || list > OMP_LIST_REDUCTION_LAST)\n \t\t\t && n->sym->ts.type == BT_DERIVED\n \t\t\t && n->sym->ts.u.derived->attr.alloc_comp)\n \t\t      gfc_error (\"%s clause object '%s' has ALLOCATABLE components at %L\",\n-\t\t\t\t name, n->sym->name, &code->loc);\n+\t\t\t\t name, n->sym->name, where);\n \t\t    if (n->sym->attr.cray_pointer\n \t\t\t&& list >= OMP_LIST_REDUCTION_FIRST\n \t\t\t&& list <= OMP_LIST_REDUCTION_LAST)\n \t\t      gfc_error (\"Cray pointer '%s' in %s clause at %L\",\n-\t\t\t\t n->sym->name, name, &code->loc);\n+\t\t\t\t n->sym->name, name, where);\n \t\t  }\n \t\tif (n->sym->as && n->sym->as->type == AS_ASSUMED_SIZE)\n \t\t  gfc_error (\"Assumed size array '%s' in %s clause at %L\",\n-\t\t\t     n->sym->name, name, &code->loc);\n+\t\t\t     n->sym->name, name, where);\n \t\tif (n->sym->attr.in_namelist\n \t\t    && (list < OMP_LIST_REDUCTION_FIRST\n \t\t\t|| list > OMP_LIST_REDUCTION_LAST))\n \t\t  gfc_error (\"Variable '%s' in %s clause is used in \"\n \t\t\t     \"NAMELIST statement at %L\",\n-\t\t\t     n->sym->name, name, &code->loc);\n+\t\t\t     n->sym->name, name, where);\n \t\tswitch (list)\n \t\t  {\n \t\t  case OMP_LIST_PLUS:\n@@ -1014,7 +1452,7 @@ resolve_omp_clauses (gfc_code *code)\n \t\t      gfc_error (\"%c REDUCTION variable '%s' at %L must be of numeric type, got %s\",\n \t\t\t\t list == OMP_LIST_PLUS ? '+'\n \t\t\t\t : list == OMP_LIST_MULT ? '*' : '-',\n-\t\t\t\t n->sym->name, &code->loc,\n+\t\t\t\t n->sym->name, where,\n \t\t\t\t gfc_typename (&n->sym->ts));\n \t\t    break;\n \t\t  case OMP_LIST_AND:\n@@ -1027,7 +1465,7 @@ resolve_omp_clauses (gfc_code *code)\n \t\t\t\t list == OMP_LIST_AND ? \".AND.\"\n \t\t\t\t : list == OMP_LIST_OR ? \".OR.\"\n \t\t\t\t : list == OMP_LIST_EQV ? \".EQV.\" : \".NEQV.\",\n-\t\t\t\t n->sym->name, &code->loc);\n+\t\t\t\t n->sym->name, where);\n \t\t    break;\n \t\t  case OMP_LIST_MAX:\n \t\t  case OMP_LIST_MIN:\n@@ -1036,7 +1474,7 @@ resolve_omp_clauses (gfc_code *code)\n \t\t      gfc_error (\"%s REDUCTION variable '%s' must be \"\n \t\t\t\t \"INTEGER or REAL at %L\",\n \t\t\t\t list == OMP_LIST_MAX ? \"MAX\" : \"MIN\",\n-\t\t\t\t n->sym->name, &code->loc);\n+\t\t\t\t n->sym->name, where);\n \t\t    break;\n \t\t  case OMP_LIST_IAND:\n \t\t  case OMP_LIST_IOR:\n@@ -1046,19 +1484,57 @@ resolve_omp_clauses (gfc_code *code)\n \t\t\t\t \"at %L\",\n \t\t\t\t list == OMP_LIST_IAND ? \"IAND\"\n \t\t\t\t : list == OMP_LIST_MULT ? \"IOR\" : \"IEOR\",\n-\t\t\t\t n->sym->name, &code->loc);\n+\t\t\t\t n->sym->name, where);\n+\t\t    break;\n+\t\t  case OMP_LIST_LINEAR:\n+\t\t    if (n->sym->ts.type != BT_INTEGER)\n+\t\t      gfc_error (\"LINEAR variable '%s' must be INTEGER \"\n+\t\t\t\t \"at %L\", n->sym->name, where);\n+\t\t    else if (!code && !n->sym->attr.value)\n+\t\t      gfc_error (\"LINEAR dummy argument '%s' must have VALUE \"\n+\t\t\t\t \"attribute at %L\", n->sym->name, where);\n+\t\t    else if (n->expr)\n+\t\t      {\n+\t\t\tgfc_expr *expr = n->expr;\n+\t\t\tif (!gfc_resolve_expr (expr)\n+\t\t\t    || expr->ts.type != BT_INTEGER\n+\t\t\t    || expr->rank != 0)\n+\t\t\t  gfc_error (\"'%s' in LINEAR clause at %L requires \"\n+\t\t\t\t     \"a scalar integer linear-step expression\",\n+\t\t\t\t     n->sym->name, where);\n+\t\t\telse if (!code && expr->expr_type != EXPR_CONSTANT)\n+\t\t\t  gfc_error (\"'%s' in LINEAR clause at %L requires \"\n+\t\t\t\t     \"a constant integer linear-step expression\",\n+\t\t\t\t     n->sym->name, where);\n+\t\t      }\n \t\t    break;\n \t\t  /* Workaround for PR middle-end/26316, nothing really needs\n \t\t     to be done here for OMP_LIST_PRIVATE.  */\n \t\t  case OMP_LIST_PRIVATE:\n-\t\t    gcc_assert (code->op != EXEC_NOP);\n+\t\t    gcc_assert (code && code->op != EXEC_NOP);\n \t\t  default:\n \t\t    break;\n \t\t  }\n \t      }\n \t    break;\n \t  }\n       }\n+  if (omp_clauses->safelen_expr)\n+    {\n+      gfc_expr *expr = omp_clauses->safelen_expr;\n+      if (!gfc_resolve_expr (expr)\n+\t  || expr->ts.type != BT_INTEGER || expr->rank != 0)\n+\tgfc_error (\"SAFELEN clause at %L requires a scalar \"\n+\t\t   \"INTEGER expression\", &expr->where);\n+    }\n+  if (omp_clauses->simdlen_expr)\n+    {\n+      gfc_expr *expr = omp_clauses->simdlen_expr;\n+      if (!gfc_resolve_expr (expr)\n+\t  || expr->ts.type != BT_INTEGER || expr->rank != 0)\n+\tgfc_error (\"SIMDLEN clause at %L requires a scalar \"\n+\t\t   \"INTEGER expression\", &expr->where);\n+    }\n }\n \n \n@@ -1142,12 +1618,13 @@ resolve_omp_atomic (gfc_code *code)\n   gfc_code *atomic_code = code;\n   gfc_symbol *var;\n   gfc_expr *expr2, *expr2_tmp;\n+  gfc_omp_atomic_op aop\n+    = (gfc_omp_atomic_op) (atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_MASK);\n \n   code = code->block->next;\n   gcc_assert (code->op == EXEC_ASSIGN);\n-  gcc_assert ((atomic_code->ext.omp_atomic != GFC_OMP_ATOMIC_CAPTURE\n-\t       && code->next == NULL)\n-\t      || (atomic_code->ext.omp_atomic == GFC_OMP_ATOMIC_CAPTURE\n+  gcc_assert (((aop != GFC_OMP_ATOMIC_CAPTURE) && code->next == NULL)\n+\t      || ((aop == GFC_OMP_ATOMIC_CAPTURE)\n \t\t  && code->next != NULL\n \t\t  && code->next->op == EXEC_ASSIGN\n \t\t  && code->next->next == NULL));\n@@ -1169,14 +1646,13 @@ resolve_omp_atomic (gfc_code *code)\n   expr2 = is_conversion (code->expr2, false);\n   if (expr2 == NULL)\n     {\n-      if (atomic_code->ext.omp_atomic == GFC_OMP_ATOMIC_READ\n-\t  || atomic_code->ext.omp_atomic == GFC_OMP_ATOMIC_WRITE)\n+      if (aop == GFC_OMP_ATOMIC_READ || aop == GFC_OMP_ATOMIC_WRITE)\n \texpr2 = is_conversion (code->expr2, true);\n       if (expr2 == NULL)\n \texpr2 = code->expr2;\n     }\n \n-  switch (atomic_code->ext.omp_atomic)\n+  switch (aop)\n     {\n     case GFC_OMP_ATOMIC_READ:\n       if (expr2->expr_type != EXPR_VARIABLE\n@@ -1249,7 +1725,21 @@ resolve_omp_atomic (gfc_code *code)\n       break;\n     }\n \n-  if (expr2->expr_type == EXPR_OP)\n+  if (var->attr.allocatable)\n+    {\n+      gfc_error (\"!$OMP ATOMIC with ALLOCATABLE variable at %L\",\n+\t\t &code->loc);\n+      return;\n+    }\n+\n+  if (aop == GFC_OMP_ATOMIC_CAPTURE\n+      && code->next == NULL\n+      && code->expr2->rank == 0\n+      && !expr_references_sym (code->expr2, var, NULL))\n+    atomic_code->ext.omp_atomic\n+      = (gfc_omp_atomic_op) (atomic_code->ext.omp_atomic\n+\t\t\t     | GFC_OMP_ATOMIC_SWAP);\n+  else if (expr2->expr_type == EXPR_OP)\n     {\n       gfc_expr *v = NULL, *e, *c;\n       gfc_intrinsic_op op = expr2->value.op.op;\n@@ -1420,11 +1910,18 @@ resolve_omp_atomic (gfc_code *code)\n \t      && arg->expr->symtree->n.sym == var)\n \t    var_arg = arg;\n \t  else if (expr_references_sym (arg->expr, var, NULL))\n-\t    gfc_error (\"!$OMP ATOMIC intrinsic arguments except one must not \"\n-\t\t       \"reference '%s' at %L\", var->name, &arg->expr->where);\n+\t    {\n+\t      gfc_error (\"!$OMP ATOMIC intrinsic arguments except one must \"\n+\t\t\t \"not reference '%s' at %L\",\n+\t\t\t var->name, &arg->expr->where);\n+\t      return;\n+\t    }\n \t  if (arg->expr->rank != 0)\n-\t    gfc_error (\"!$OMP ATOMIC intrinsic arguments must be scalar \"\n-\t\t       \"at %L\", &arg->expr->where);\n+\t    {\n+\t      gfc_error (\"!$OMP ATOMIC intrinsic arguments must be scalar \"\n+\t\t\t \"at %L\", &arg->expr->where);\n+\t      return;\n+\t    }\n \t}\n \n       if (var_arg == NULL)\n@@ -1447,10 +1944,10 @@ resolve_omp_atomic (gfc_code *code)\n \t}\n     }\n   else\n-    gfc_error (\"!$OMP ATOMIC assignment must have an operator or intrinsic \"\n-\t       \"on right hand side at %L\", &expr2->where);\n+    gfc_error (\"!$OMP ATOMIC assignment must have an operator or \"\n+\t       \"intrinsic on right hand side at %L\", &expr2->where);\n \n-  if (atomic_code->ext.omp_atomic == GFC_OMP_ATOMIC_CAPTURE && code->next)\n+  if (aop == GFC_OMP_ATOMIC_CAPTURE && code->next)\n     {\n       code = code->next;\n       if (code->expr1->expr_type != EXPR_VARIABLE\n@@ -1542,7 +2039,7 @@ gfc_resolve_omp_parallel_blocks (gfc_code *code, gfc_namespace *ns)\n {\n   struct omp_context ctx;\n   gfc_omp_clauses *omp_clauses = code->ext.omp_clauses;\n-  gfc_namelist *n;\n+  gfc_omp_namelist *n;\n   int list;\n \n   ctx.code = code;\n@@ -1555,7 +2052,8 @@ gfc_resolve_omp_parallel_blocks (gfc_code *code, gfc_namespace *ns)\n     for (n = omp_clauses->lists[list]; n; n = n->next)\n       pointer_set_insert (ctx.sharing_clauses, n->sym);\n \n-  if (code->op == EXEC_OMP_PARALLEL_DO)\n+  if (code->op == EXEC_OMP_PARALLEL_DO\n+      || code->op == EXEC_OMP_PARALLEL_DO_SIMD)\n     gfc_resolve_omp_do_blocks (code, ns);\n   else\n     gfc_resolve_blocks (code->block, ns);\n@@ -1624,9 +2122,9 @@ gfc_resolve_do_iterator (gfc_code *code, gfc_symbol *sym)\n   if (! pointer_set_insert (omp_current_ctx->private_iterators, sym))\n     {\n       gfc_omp_clauses *omp_clauses = omp_current_ctx->code->ext.omp_clauses;\n-      gfc_namelist *p;\n+      gfc_omp_namelist *p;\n \n-      p = gfc_get_namelist ();\n+      p = gfc_get_omp_namelist ();\n       p->sym = sym;\n       p->next = omp_clauses->lists[OMP_LIST_PRIVATE];\n       omp_clauses->lists[OMP_LIST_PRIVATE] = p;\n@@ -1639,11 +2137,25 @@ resolve_omp_do (gfc_code *code)\n {\n   gfc_code *do_code, *c;\n   int list, i, collapse;\n-  gfc_namelist *n;\n+  gfc_omp_namelist *n;\n   gfc_symbol *dovar;\n+  const char *name;\n+  bool is_simd = false;\n+\n+  switch (code->op)\n+    {\n+    case EXEC_OMP_DO: name = \"!$OMP DO\"; break;\n+    case EXEC_OMP_DO_SIMD: name = \"!$OMP DO SIMD\"; is_simd = true; break;\n+    case EXEC_OMP_PARALLEL_DO: name = \"!$OMP PARALLEL DO\"; break;\n+    case EXEC_OMP_PARALLEL_DO_SIMD:\n+      name = \"!$OMP PARALLEL DO SIMD\";\n+      is_simd = true; break;\n+    case EXEC_OMP_SIMD: name = \"!$OMP SIMD\"; is_simd = true; break;\n+    default: gcc_unreachable ();\n+    }\n \n   if (code->ext.omp_clauses)\n-    resolve_omp_clauses (code);\n+    resolve_omp_clauses (code, &code->loc, code->ext.omp_clauses, NULL);\n \n   do_code = code->block->next;\n   collapse = code->ext.omp_clauses->collapse;\n@@ -1653,27 +2165,40 @@ resolve_omp_do (gfc_code *code)\n     {\n       if (do_code->op == EXEC_DO_WHILE)\n \t{\n-\t  gfc_error (\"!$OMP DO cannot be a DO WHILE or DO without loop control \"\n-\t\t     \"at %L\", &do_code->loc);\n+\t  gfc_error (\"%s cannot be a DO WHILE or DO without loop control \"\n+\t\t     \"at %L\", name, &do_code->loc);\n \t  break;\n \t}\n       gcc_assert (do_code->op == EXEC_DO);\n       if (do_code->ext.iterator->var->ts.type != BT_INTEGER)\n-\tgfc_error (\"!$OMP DO iteration variable must be of type integer at %L\",\n-\t\t   &do_code->loc);\n+\tgfc_error (\"%s iteration variable must be of type integer at %L\",\n+\t\t   name, &do_code->loc);\n       dovar = do_code->ext.iterator->var->symtree->n.sym;\n       if (dovar->attr.threadprivate)\n-\tgfc_error (\"!$OMP DO iteration variable must not be THREADPRIVATE \"\n-\t\t   \"at %L\", &do_code->loc);\n+\tgfc_error (\"%s iteration variable must not be THREADPRIVATE \"\n+\t\t   \"at %L\", name, &do_code->loc);\n       if (code->ext.omp_clauses)\n \tfor (list = 0; list < OMP_LIST_NUM; list++)\n-\t  if (list != OMP_LIST_PRIVATE && list != OMP_LIST_LASTPRIVATE)\n+\t  if (!is_simd\n+\t      ? (list != OMP_LIST_PRIVATE && list != OMP_LIST_LASTPRIVATE)\n+\t      : code->ext.omp_clauses->collapse > 1\n+\t      ? (list != OMP_LIST_LASTPRIVATE)\n+\t      : (list != OMP_LIST_LINEAR))\n \t    for (n = code->ext.omp_clauses->lists[list]; n; n = n->next)\n \t      if (dovar == n->sym)\n \t\t{\n-\t\t  gfc_error (\"!$OMP DO iteration variable present on clause \"\n-\t\t\t     \"other than PRIVATE or LASTPRIVATE at %L\",\n-\t\t\t     &do_code->loc);\n+\t\t  if (!is_simd)\n+\t\t    gfc_error (\"%s iteration variable present on clause \"\n+\t\t\t       \"other than PRIVATE or LASTPRIVATE at %L\",\n+\t\t\t       name, &do_code->loc);\n+\t\t  else if (code->ext.omp_clauses->collapse > 1)\n+\t\t    gfc_error (\"%s iteration variable present on clause \"\n+\t\t\t       \"other than LASTPRIVATE at %L\",\n+\t\t\t       name, &do_code->loc);\n+\t\t  else\n+\t\t    gfc_error (\"%s iteration variable present on clause \"\n+\t\t\t       \"other than LINEAR at %L\",\n+\t\t\t       name, &do_code->loc);\n \t\t  break;\n \t\t}\n       if (i > 1)\n@@ -1689,8 +2214,8 @@ resolve_omp_do (gfc_code *code)\n \t\t  || gfc_find_sym_in_expr (ivar, do_code->ext.iterator->end)\n \t\t  || gfc_find_sym_in_expr (ivar, do_code->ext.iterator->step))\n \t\t{\n-\t\t  gfc_error (\"!$OMP DO collapsed loops don't form rectangular iteration space at %L\",\n-\t\t\t     &do_code->loc);\n+\t\t  gfc_error (\"%s collapsed loops don't form rectangular \"\n+\t\t\t     \"iteration space at %L\", name, &do_code->loc);\n \t\t  break;\n \t\t}\n \t      if (j < i)\n@@ -1703,25 +2228,25 @@ resolve_omp_do (gfc_code *code)\n       for (c = do_code->next; c; c = c->next)\n \tif (c->op != EXEC_NOP && c->op != EXEC_CONTINUE)\n \t  {\n-\t    gfc_error (\"collapsed !$OMP DO loops not perfectly nested at %L\",\n-\t\t       &c->loc);\n+\t    gfc_error (\"collapsed %s loops not perfectly nested at %L\",\n+\t\t       name, &c->loc);\n \t    break;\n \t  }\n       if (c)\n \tbreak;\n       do_code = do_code->block;\n       if (do_code->op != EXEC_DO && do_code->op != EXEC_DO_WHILE)\n \t{\n-\t  gfc_error (\"not enough DO loops for collapsed !$OMP DO at %L\",\n-\t\t     &code->loc);\n+\t  gfc_error (\"not enough DO loops for collapsed %s at %L\",\n+\t\t     name, &code->loc);\n \t  break;\n \t}\n       do_code = do_code->next;\n       if (do_code == NULL\n \t  || (do_code->op != EXEC_DO && do_code->op != EXEC_DO_WHILE))\n \t{\n-\t  gfc_error (\"not enough DO loops for collapsed !$OMP DO at %L\",\n-\t\t     &code->loc);\n+\t  gfc_error (\"not enough DO loops for collapsed %s at %L\",\n+\t\t     name, &code->loc);\n \t  break;\n \t}\n     }\n@@ -1740,18 +2265,22 @@ gfc_resolve_omp_directive (gfc_code *code, gfc_namespace *ns ATTRIBUTE_UNUSED)\n   switch (code->op)\n     {\n     case EXEC_OMP_DO:\n+    case EXEC_OMP_DO_SIMD:\n     case EXEC_OMP_PARALLEL_DO:\n+    case EXEC_OMP_PARALLEL_DO_SIMD:\n+    case EXEC_OMP_SIMD:\n       resolve_omp_do (code);\n       break;\n-    case EXEC_OMP_WORKSHARE:\n+    case EXEC_OMP_CANCEL:\n     case EXEC_OMP_PARALLEL_WORKSHARE:\n     case EXEC_OMP_PARALLEL:\n     case EXEC_OMP_PARALLEL_SECTIONS:\n     case EXEC_OMP_SECTIONS:\n     case EXEC_OMP_SINGLE:\n     case EXEC_OMP_TASK:\n+    case EXEC_OMP_WORKSHARE:\n       if (code->ext.omp_clauses)\n-\tresolve_omp_clauses (code);\n+\tresolve_omp_clauses (code, &code->loc, code->ext.omp_clauses, NULL);\n       break;\n     case EXEC_OMP_ATOMIC:\n       resolve_omp_atomic (code);\n@@ -1760,3 +2289,20 @@ gfc_resolve_omp_directive (gfc_code *code, gfc_namespace *ns ATTRIBUTE_UNUSED)\n       break;\n     }\n }\n+\n+/* Resolve !$omp declare simd constructs in NS.  */\n+\n+void\n+gfc_resolve_omp_declare_simd (gfc_namespace *ns)\n+{\n+  gfc_omp_declare_simd *ods;\n+\n+  for (ods = ns->omp_declare_simd; ods; ods = ods->next)\n+    {\n+      if (ods->proc_name != ns->proc_name)\n+\tgfc_error (\"!$OMP DECLARE SIMD should refer to containing procedure\"\n+\t\t   \"'%s' at %L\", ns->proc_name->name, &ods->where);\n+      if (ods->clauses)\n+\tresolve_omp_clauses (NULL, &ods->where, ods->clauses, ns);\n+    }\n+}"}, {"sha": "9735714ea9e6823daaef4c79fb94f4677f179e13", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 78, "deletions": 6, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -569,17 +569,27 @@ decode_omp_directive (void)\n       match (\"barrier\", gfc_match_omp_barrier, ST_OMP_BARRIER);\n       break;\n     case 'c':\n+      match (\"cancellation% point\", gfc_match_omp_cancellation_point,\n+\t     ST_OMP_CANCELLATION_POINT);\n+      match (\"cancel\", gfc_match_omp_cancel, ST_OMP_CANCEL);\n       match (\"critical\", gfc_match_omp_critical, ST_OMP_CRITICAL);\n       break;\n     case 'd':\n+      match (\"declare simd\", gfc_match_omp_declare_simd,\n+\t     ST_OMP_DECLARE_SIMD);\n+      match (\"do simd\", gfc_match_omp_do_simd, ST_OMP_DO_SIMD);\n       match (\"do\", gfc_match_omp_do, ST_OMP_DO);\n       break;\n     case 'e':\n       match (\"end atomic\", gfc_match_omp_eos, ST_OMP_END_ATOMIC);\n       match (\"end critical\", gfc_match_omp_critical, ST_OMP_END_CRITICAL);\n+      match (\"end do simd\", gfc_match_omp_end_nowait, ST_OMP_END_DO_SIMD);\n       match (\"end do\", gfc_match_omp_end_nowait, ST_OMP_END_DO);\n+      match (\"end simd\", gfc_match_omp_eos, ST_OMP_END_SIMD);\n       match (\"end master\", gfc_match_omp_eos, ST_OMP_END_MASTER);\n       match (\"end ordered\", gfc_match_omp_eos, ST_OMP_END_ORDERED);\n+      match (\"end parallel do simd\", gfc_match_omp_eos,\n+\t     ST_OMP_END_PARALLEL_DO_SIMD);\n       match (\"end parallel do\", gfc_match_omp_eos, ST_OMP_END_PARALLEL_DO);\n       match (\"end parallel sections\", gfc_match_omp_eos,\n \t     ST_OMP_END_PARALLEL_SECTIONS);\n@@ -588,6 +598,7 @@ decode_omp_directive (void)\n       match (\"end parallel\", gfc_match_omp_eos, ST_OMP_END_PARALLEL);\n       match (\"end sections\", gfc_match_omp_end_nowait, ST_OMP_END_SECTIONS);\n       match (\"end single\", gfc_match_omp_end_single, ST_OMP_END_SINGLE);\n+      match (\"end taskgroup\", gfc_match_omp_eos, ST_OMP_END_TASKGROUP);\n       match (\"end task\", gfc_match_omp_eos, ST_OMP_END_TASK);\n       match (\"end workshare\", gfc_match_omp_end_nowait,\n \t     ST_OMP_END_WORKSHARE);\n@@ -602,6 +613,8 @@ decode_omp_directive (void)\n       match (\"ordered\", gfc_match_omp_ordered, ST_OMP_ORDERED);\n       break;\n     case 'p':\n+      match (\"parallel do simd\", gfc_match_omp_parallel_do_simd,\n+\t     ST_OMP_PARALLEL_DO_SIMD);\n       match (\"parallel do\", gfc_match_omp_parallel_do, ST_OMP_PARALLEL_DO);\n       match (\"parallel sections\", gfc_match_omp_parallel_sections,\n \t     ST_OMP_PARALLEL_SECTIONS);\n@@ -612,12 +625,14 @@ decode_omp_directive (void)\n     case 's':\n       match (\"sections\", gfc_match_omp_sections, ST_OMP_SECTIONS);\n       match (\"section\", gfc_match_omp_eos, ST_OMP_SECTION);\n+      match (\"simd\", gfc_match_omp_simd, ST_OMP_SIMD);\n       match (\"single\", gfc_match_omp_single, ST_OMP_SINGLE);\n       break;\n     case 't':\n-      match (\"task\", gfc_match_omp_task, ST_OMP_TASK);\n+      match (\"taskgroup\", gfc_match_omp_taskgroup, ST_OMP_TASKGROUP);\n       match (\"taskwait\", gfc_match_omp_taskwait, ST_OMP_TASKWAIT);\n       match (\"taskyield\", gfc_match_omp_taskyield, ST_OMP_TASKYIELD);\n+      match (\"task\", gfc_match_omp_task, ST_OMP_TASK);\n       match (\"threadprivate\", gfc_match_omp_threadprivate,\n \t     ST_OMP_THREADPRIVATE);\n       break;\n@@ -1013,6 +1028,7 @@ next_statement (void)\n   case ST_ASSIGNMENT: case ST_ARITHMETIC_IF: case ST_WHERE: case ST_FORALL: \\\n   case ST_LABEL_ASSIGNMENT: case ST_FLUSH: case ST_OMP_FLUSH: \\\n   case ST_OMP_BARRIER: case ST_OMP_TASKWAIT: case ST_OMP_TASKYIELD: \\\n+  case ST_OMP_CANCEL: case ST_OMP_CANCELLATION_POINT: \\\n   case ST_ERROR_STOP: case ST_SYNC_ALL: case ST_SYNC_IMAGES: \\\n   case ST_SYNC_MEMORY: case ST_LOCK: case ST_UNLOCK\n \n@@ -1026,14 +1042,15 @@ next_statement (void)\n   case ST_OMP_CRITICAL: case ST_OMP_MASTER: case ST_OMP_SINGLE: \\\n   case ST_OMP_DO: case ST_OMP_PARALLEL_DO: case ST_OMP_ATOMIC: \\\n   case ST_OMP_WORKSHARE: case ST_OMP_PARALLEL_WORKSHARE: \\\n-  case ST_OMP_TASK: case ST_CRITICAL\n+  case ST_OMP_TASK: case ST_OMP_TASKGROUP: case ST_OMP_SIMD: \\\n+  case ST_OMP_DO_SIMD: case ST_OMP_PARALLEL_DO_SIMD: case ST_CRITICAL\n \n /* Declaration statements */\n \n #define case_decl case ST_ATTR_DECL: case ST_COMMON: case ST_DATA_DECL: \\\n   case ST_EQUIVALENCE: case ST_NAMELIST: case ST_STATEMENT_FUNCTION: \\\n   case ST_TYPE: case ST_INTERFACE: case ST_OMP_THREADPRIVATE: \\\n-  case ST_PROCEDURE\n+  case ST_PROCEDURE: case ST_OMP_DECLARE_SIMD\n \n /* Block end statements.  Errors associated with interchanging these\n    are detected in gfc_match_end().  */\n@@ -1524,12 +1541,24 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_BARRIER:\n       p = \"!$OMP BARRIER\";\n       break;\n+    case ST_OMP_CANCEL:\n+      p = \"!$OMP CANCEL\";\n+      break;\n+    case ST_OMP_CANCELLATION_POINT:\n+      p = \"!$OMP CANCELLATION POINT\";\n+      break;\n     case ST_OMP_CRITICAL:\n       p = \"!$OMP CRITICAL\";\n       break;\n+    case ST_OMP_DECLARE_SIMD:\n+      p = \"!$OMP DECLARE SIMD\";\n+      break;\n     case ST_OMP_DO:\n       p = \"!$OMP DO\";\n       break;\n+    case ST_OMP_DO_SIMD:\n+      p = \"!$OMP DO SIMD\";\n+      break;\n     case ST_OMP_END_ATOMIC:\n       p = \"!$OMP END ATOMIC\";\n       break;\n@@ -1539,6 +1568,12 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_END_DO:\n       p = \"!$OMP END DO\";\n       break;\n+    case ST_OMP_END_DO_SIMD:\n+      p = \"!$OMP END DO SIMD\";\n+      break;\n+    case ST_OMP_END_SIMD:\n+      p = \"!$OMP END SIMD\";\n+      break;\n     case ST_OMP_END_MASTER:\n       p = \"!$OMP END MASTER\";\n       break;\n@@ -1551,6 +1586,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_END_PARALLEL_DO:\n       p = \"!$OMP END PARALLEL DO\";\n       break;\n+    case ST_OMP_END_PARALLEL_DO_SIMD:\n+      p = \"!$OMP END PARALLEL DO SIMD\";\n+      break;\n     case ST_OMP_END_PARALLEL_SECTIONS:\n       p = \"!$OMP END PARALLEL SECTIONS\";\n       break;\n@@ -1566,6 +1604,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_END_TASK:\n       p = \"!$OMP END TASK\";\n       break;\n+    case ST_OMP_END_TASKGROUP:\n+      p = \"!$OMP END TASKGROUP\";\n+      break;\n     case ST_OMP_END_WORKSHARE:\n       p = \"!$OMP END WORKSHARE\";\n       break;\n@@ -1584,6 +1625,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_PARALLEL_DO:\n       p = \"!$OMP PARALLEL DO\";\n       break;\n+    case ST_OMP_PARALLEL_DO_SIMD:\n+      p = \"!$OMP PARALLEL DO SIMD\";\n+      break;\n     case ST_OMP_PARALLEL_SECTIONS:\n       p = \"!$OMP PARALLEL SECTIONS\";\n       break;\n@@ -1596,12 +1640,18 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_SECTION:\n       p = \"!$OMP SECTION\";\n       break;\n+    case ST_OMP_SIMD:\n+      p = \"!$OMP SIMD\";\n+      break;\n     case ST_OMP_SINGLE:\n       p = \"!$OMP SINGLE\";\n       break;\n     case ST_OMP_TASK:\n       p = \"!$OMP TASK\";\n       break;\n+    case ST_OMP_TASKGROUP:\n+      p = \"!$OMP TASKGROUP\";\n+      break;\n     case ST_OMP_TASKWAIT:\n       p = \"!$OMP TASKWAIT\";\n       break;\n@@ -3578,7 +3628,19 @@ parse_omp_do (gfc_statement omp_st)\n   pop_state ();\n \n   st = next_statement ();\n-  if (st == (omp_st == ST_OMP_DO ? ST_OMP_END_DO : ST_OMP_END_PARALLEL_DO))\n+  gfc_statement omp_end_st = ST_OMP_END_DO;\n+  switch (omp_st)\n+    {\n+    case ST_OMP_SIMD: omp_end_st = ST_OMP_END_SIMD; break;\n+    case ST_OMP_DO: omp_end_st = ST_OMP_END_DO; break;\n+    case ST_OMP_DO_SIMD: omp_end_st = ST_OMP_END_DO_SIMD; break;\n+    case ST_OMP_PARALLEL_DO: omp_end_st = ST_OMP_END_PARALLEL_DO; break;\n+    case ST_OMP_PARALLEL_DO_SIMD:\n+      omp_end_st = ST_OMP_END_PARALLEL_DO_SIMD;\n+      break;\n+    default: gcc_unreachable ();\n+    }\n+  if (st == omp_end_st)\n     {\n       if (new_st.op == EXEC_OMP_END_NOWAIT)\n \tcp->ext.omp_clauses->nowait |= new_st.ext.omp_bool;\n@@ -3610,7 +3672,8 @@ parse_omp_atomic (void)\n   np = new_level (cp);\n   np->op = cp->op;\n   np->block = NULL;\n-  count = 1 + (cp->ext.omp_atomic == GFC_OMP_ATOMIC_CAPTURE);\n+  count = 1 + ((cp->ext.omp_atomic & GFC_OMP_ATOMIC_MASK)\n+\t       == GFC_OMP_ATOMIC_CAPTURE);\n \n   while (count)\n     {\n@@ -3636,7 +3699,8 @@ parse_omp_atomic (void)\n       gfc_warning_check ();\n       st = next_statement ();\n     }\n-  else if (cp->ext.omp_atomic == GFC_OMP_ATOMIC_CAPTURE)\n+  else if ((cp->ext.omp_atomic & GFC_OMP_ATOMIC_MASK)\n+\t   == GFC_OMP_ATOMIC_CAPTURE)\n     gfc_error (\"Missing !$OMP END ATOMIC after !$OMP ATOMIC CAPTURE at %C\");\n   return st;\n }\n@@ -3685,6 +3749,9 @@ parse_omp_structured_block (gfc_statement omp_st, bool workshare_stmts_only)\n     case ST_OMP_TASK:\n       omp_end_st = ST_OMP_END_TASK;\n       break;\n+    case ST_OMP_TASKGROUP:\n+      omp_end_st = ST_OMP_END_TASKGROUP;\n+      break;\n     case ST_OMP_WORKSHARE:\n       omp_end_st = ST_OMP_END_WORKSHARE;\n       break;\n@@ -3744,6 +3811,7 @@ parse_omp_structured_block (gfc_statement omp_st, bool workshare_stmts_only)\n \t\t  break;\n \n \t\tcase ST_OMP_PARALLEL_DO:\n+\t\tcase ST_OMP_PARALLEL_DO_SIMD:\n \t\t  st = parse_omp_do (st);\n \t\t  continue;\n \n@@ -3917,6 +3985,7 @@ parse_executable (gfc_statement st)\n \tcase ST_OMP_MASTER:\n \tcase ST_OMP_SINGLE:\n \tcase ST_OMP_TASK:\n+\tcase ST_OMP_TASKGROUP:\n \t  parse_omp_structured_block (st, false);\n \t  break;\n \n@@ -3926,7 +3995,10 @@ parse_executable (gfc_statement st)\n \t  break;\n \n \tcase ST_OMP_DO:\n+\tcase ST_OMP_DO_SIMD:\n \tcase ST_OMP_PARALLEL_DO:\n+\tcase ST_OMP_PARALLEL_DO_SIMD:\n+\tcase ST_OMP_SIMD:\n \t  st = parse_omp_do (st);\n \t  if (st == ST_IMPLIED_ENDDO)\n \t    return st;"}, {"sha": "7579573599a698c3240e0089984fa0b7a2a5296b", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -9028,15 +9028,19 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n \tcase EXEC_OMP_ATOMIC:\n \tcase EXEC_OMP_CRITICAL:\n \tcase EXEC_OMP_DO:\n+\tcase EXEC_OMP_DO_SIMD:\n \tcase EXEC_OMP_MASTER:\n \tcase EXEC_OMP_ORDERED:\n \tcase EXEC_OMP_PARALLEL:\n \tcase EXEC_OMP_PARALLEL_DO:\n+\tcase EXEC_OMP_PARALLEL_DO_SIMD:\n \tcase EXEC_OMP_PARALLEL_SECTIONS:\n \tcase EXEC_OMP_PARALLEL_WORKSHARE:\n \tcase EXEC_OMP_SECTIONS:\n+\tcase EXEC_OMP_SIMD:\n \tcase EXEC_OMP_SINGLE:\n \tcase EXEC_OMP_TASK:\n+\tcase EXEC_OMP_TASKGROUP:\n \tcase EXEC_OMP_TASKWAIT:\n \tcase EXEC_OMP_TASKYIELD:\n \tcase EXEC_OMP_WORKSHARE:\n@@ -9802,13 +9806,16 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t      break;\n \t    case EXEC_OMP_PARALLEL:\n \t    case EXEC_OMP_PARALLEL_DO:\n+\t    case EXEC_OMP_PARALLEL_DO_SIMD:\n \t    case EXEC_OMP_PARALLEL_SECTIONS:\n \t    case EXEC_OMP_TASK:\n \t      omp_workshare_save = omp_workshare_flag;\n \t      omp_workshare_flag = 0;\n \t      gfc_resolve_omp_parallel_blocks (code, ns);\n \t      break;\n \t    case EXEC_OMP_DO:\n+\t    case EXEC_OMP_DO_SIMD:\n+\t    case EXEC_OMP_SIMD:\n \t      gfc_resolve_omp_do_blocks (code, ns);\n \t      break;\n \t    case EXEC_SELECT_TYPE:\n@@ -10128,13 +10135,18 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \n \tcase EXEC_OMP_ATOMIC:\n \tcase EXEC_OMP_BARRIER:\n+\tcase EXEC_OMP_CANCEL:\n+\tcase EXEC_OMP_CANCELLATION_POINT:\n \tcase EXEC_OMP_CRITICAL:\n \tcase EXEC_OMP_FLUSH:\n \tcase EXEC_OMP_DO:\n+\tcase EXEC_OMP_DO_SIMD:\n \tcase EXEC_OMP_MASTER:\n \tcase EXEC_OMP_ORDERED:\n \tcase EXEC_OMP_SECTIONS:\n+\tcase EXEC_OMP_SIMD:\n \tcase EXEC_OMP_SINGLE:\n+\tcase EXEC_OMP_TASKGROUP:\n \tcase EXEC_OMP_TASKWAIT:\n \tcase EXEC_OMP_TASKYIELD:\n \tcase EXEC_OMP_WORKSHARE:\n@@ -10143,6 +10155,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \n \tcase EXEC_OMP_PARALLEL:\n \tcase EXEC_OMP_PARALLEL_DO:\n+\tcase EXEC_OMP_PARALLEL_DO_SIMD:\n \tcase EXEC_OMP_PARALLEL_SECTIONS:\n \tcase EXEC_OMP_PARALLEL_WORKSHARE:\n \tcase EXEC_OMP_TASK:\n@@ -14681,6 +14694,8 @@ resolve_types (gfc_namespace *ns)\n \n   gfc_resolve_uops (ns->uop_root);\n \n+  gfc_resolve_omp_declare_simd (ns);\n+\n   gfc_current_ns = old_ns;\n }\n "}, {"sha": "a3df43ed38666de42bd05fa2df5f85b52ca581d6", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -185,12 +185,17 @@ gfc_free_statement (gfc_code *p)\n       gfc_free_forall_iterator (p->ext.forall_iterator);\n       break;\n \n+    case EXEC_OMP_CANCEL:\n+    case EXEC_OMP_CANCELLATION_POINT:\n     case EXEC_OMP_DO:\n+    case EXEC_OMP_DO_SIMD:\n     case EXEC_OMP_END_SINGLE:\n     case EXEC_OMP_PARALLEL:\n     case EXEC_OMP_PARALLEL_DO:\n+    case EXEC_OMP_PARALLEL_DO_SIMD:\n     case EXEC_OMP_PARALLEL_SECTIONS:\n     case EXEC_OMP_SECTIONS:\n+    case EXEC_OMP_SIMD:\n     case EXEC_OMP_SINGLE:\n     case EXEC_OMP_TASK:\n     case EXEC_OMP_WORKSHARE:\n@@ -203,14 +208,15 @@ gfc_free_statement (gfc_code *p)\n       break;\n \n     case EXEC_OMP_FLUSH:\n-      gfc_free_namelist (p->ext.omp_namelist);\n+      gfc_free_omp_namelist (p->ext.omp_namelist);\n       break;\n \n     case EXEC_OMP_ATOMIC:\n     case EXEC_OMP_BARRIER:\n     case EXEC_OMP_MASTER:\n     case EXEC_OMP_ORDERED:\n     case EXEC_OMP_END_NOWAIT:\n+    case EXEC_OMP_TASKGROUP:\n     case EXEC_OMP_TASKWAIT:\n     case EXEC_OMP_TASKYIELD:\n       break;"}, {"sha": "3785c2e18ebc4e77ddd6dfb4978afc07966f3392", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -3468,6 +3468,7 @@ gfc_free_namespace (gfc_namespace *ns)\n   free_tb_tree (ns->tb_sym_root);\n   free_tb_tree (ns->tb_uop_root);\n   gfc_free_finalizer_list (ns->finalizers);\n+  gfc_free_omp_declare_simd_list (ns->omp_declare_simd);\n   gfc_free_charlen (ns->cl_list, NULL);\n   free_st_labels (ns->st_labels);\n "}, {"sha": "5b9661224d00887866aa9cb35b6455b559f7c58d", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -1850,6 +1850,11 @@ gfc_get_extern_function_decl (gfc_symbol * sym)\n   if (DECL_CONTEXT (fndecl) == NULL_TREE)\n     pushdecl_top_level (fndecl);\n \n+  if (sym->formal_ns\n+      && sym->formal_ns->proc_name == sym\n+      && sym->formal_ns->omp_declare_simd)\n+    gfc_trans_omp_declare_simd (sym->formal_ns);\n+\n   return fndecl;\n }\n \n@@ -2555,6 +2560,9 @@ gfc_create_function_decl (gfc_namespace * ns, bool global)\n \n   /* Now create the read argument list.  */\n   create_function_arglist (ns->proc_name);\n+\n+  if (ns->omp_declare_simd)\n+    gfc_trans_omp_declare_simd (ns);\n }\n \n /* Return the decl used to hold the function return value.  If"}, {"sha": "101dfe5594e0cde236686581193cd0e1eee97419", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 581, "deletions": 46, "changes": 627, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -427,8 +427,33 @@ gfc_trans_add_clause (tree node, tree tail)\n }\n \n static tree\n-gfc_trans_omp_variable (gfc_symbol *sym)\n+gfc_trans_omp_variable (gfc_symbol *sym, bool declare_simd)\n {\n+  if (declare_simd)\n+    {\n+      int cnt = 0;\n+      gfc_symbol *proc_sym;\n+      gfc_formal_arglist *f;\n+\n+      gcc_assert (sym->attr.dummy);\n+      proc_sym = sym->ns->proc_name;\n+      if (proc_sym->attr.entry_master)\n+\t++cnt;\n+      if (gfc_return_by_reference (proc_sym))\n+\t{\n+\t  ++cnt;\n+\t  if (proc_sym->ts.type == BT_CHARACTER)\n+\t    ++cnt;\n+\t}\n+      for (f = gfc_sym_get_dummy_args (proc_sym); f; f = f->next)\n+\tif (f->sym == sym)\n+\t  break;\n+\telse if (f->sym)\n+\t  ++cnt;\n+      gcc_assert (f);\n+      return build_int_cst (integer_type_node, cnt);\n+    }\n+\n   tree t = gfc_get_symbol_decl (sym);\n   tree parent_decl;\n   int parent_flag;\n@@ -442,7 +467,8 @@ gfc_trans_omp_variable (gfc_symbol *sym)\n   entry_master = sym->attr.result\n \t\t && sym->ns->proc_name->attr.entry_master\n \t\t && !gfc_return_by_reference (sym->ns->proc_name);\n-  parent_decl = DECL_CONTEXT (current_function_decl);\n+  parent_decl = current_function_decl\n+\t\t? DECL_CONTEXT (current_function_decl) : NULL_TREE;\n \n   if ((t == parent_decl && return_value)\n        || (sym->ns && sym->ns->proc_name\n@@ -481,13 +507,14 @@ gfc_trans_omp_variable (gfc_symbol *sym)\n }\n \n static tree\n-gfc_trans_omp_variable_list (enum omp_clause_code code, gfc_namelist *namelist,\n-\t\t\t     tree list)\n+gfc_trans_omp_variable_list (enum omp_clause_code code,\n+\t\t\t     gfc_omp_namelist *namelist, tree list,\n+\t\t\t     bool declare_simd)\n {\n   for (; namelist != NULL; namelist = namelist->next)\n-    if (namelist->sym->attr.referenced)\n+    if (namelist->sym->attr.referenced || declare_simd)\n       {\n-\ttree t = gfc_trans_omp_variable (namelist->sym);\n+\ttree t = gfc_trans_omp_variable (namelist->sym, declare_simd);\n \tif (t != error_mark_node)\n \t  {\n \t    tree node = build_omp_clause (input_location, code);\n@@ -745,13 +772,13 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n }\n \n static tree\n-gfc_trans_omp_reduction_list (gfc_namelist *namelist, tree list, \n+gfc_trans_omp_reduction_list (gfc_omp_namelist *namelist, tree list,\n \t\t\t      enum tree_code reduction_code, locus where)\n {\n   for (; namelist != NULL; namelist = namelist->next)\n     if (namelist->sym->attr.referenced)\n       {\n-\ttree t = gfc_trans_omp_variable (namelist->sym);\n+\ttree t = gfc_trans_omp_variable (namelist->sym, false);\n \tif (t != error_mark_node)\n \t  {\n \t    tree node = build_omp_clause (where.lb->location,\n@@ -768,7 +795,7 @@ gfc_trans_omp_reduction_list (gfc_namelist *namelist, tree list,\n \n static tree\n gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n-\t\t       locus where)\n+\t\t       locus where, bool declare_simd = false)\n {\n   tree omp_clauses = NULL_TREE, chunk_size, c;\n   int list;\n@@ -780,7 +807,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \n   for (list = 0; list < OMP_LIST_NUM; list++)\n     {\n-      gfc_namelist *n = clauses->lists[list];\n+      gfc_omp_namelist *n = clauses->lists[list];\n \n       if (n == NULL)\n \tcontinue;\n@@ -853,10 +880,125 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t  goto add_clause;\n \tcase OMP_LIST_COPYPRIVATE:\n \t  clause_code = OMP_CLAUSE_COPYPRIVATE;\n+\t  goto add_clause;\n+\tcase OMP_LIST_UNIFORM:\n+\t  clause_code = OMP_CLAUSE_UNIFORM;\n \t  /* FALLTHROUGH */\n \tadd_clause:\n \t  omp_clauses\n-\t    = gfc_trans_omp_variable_list (clause_code, n, omp_clauses);\n+\t    = gfc_trans_omp_variable_list (clause_code, n, omp_clauses,\n+\t\t\t\t\t   declare_simd);\n+\t  break;\n+\tcase OMP_LIST_ALIGNED:\n+\t  for (; n != NULL; n = n->next)\n+\t    if (n->sym->attr.referenced || declare_simd)\n+\t      {\n+\t\ttree t = gfc_trans_omp_variable (n->sym, declare_simd);\n+\t\tif (t != error_mark_node)\n+\t\t  {\n+\t\t    tree node = build_omp_clause (input_location,\n+\t\t\t\t\t\t  OMP_CLAUSE_ALIGNED);\n+\t\t    OMP_CLAUSE_DECL (node) = t;\n+\t\t    if (n->expr)\n+\t\t      {\n+\t\t\ttree alignment_var;\n+\n+\t\t\tif (block == NULL)\n+\t\t\t  alignment_var = gfc_conv_constant_to_tree (n->expr);\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    gfc_init_se (&se, NULL);\n+\t\t\t    gfc_conv_expr (&se, n->expr);\n+\t\t\t    gfc_add_block_to_block (block, &se.pre);\n+\t\t\t    alignment_var = gfc_evaluate_now (se.expr, block);\n+\t\t\t    gfc_add_block_to_block (block, &se.post);\n+\t\t\t  }\n+\t\t\tOMP_CLAUSE_ALIGNED_ALIGNMENT (node) = alignment_var;\n+\t\t      }\n+\t\t    omp_clauses = gfc_trans_add_clause (node, omp_clauses);\n+\t\t  }\n+\t      }\n+\t  break;\n+\tcase OMP_LIST_LINEAR:\n+\t  {\n+\t    gfc_expr *last_step_expr = NULL;\n+\t    tree last_step = NULL_TREE;\n+\n+\t    for (; n != NULL; n = n->next)\n+\t      {\n+\t\tif (n->expr)\n+\t\t  {\n+\t\t    last_step_expr = n->expr;\n+\t\t    last_step = NULL_TREE;\n+\t\t  }\n+\t\tif (n->sym->attr.referenced || declare_simd)\n+\t\t  {\n+\t\t    tree t = gfc_trans_omp_variable (n->sym, declare_simd);\n+\t\t    if (t != error_mark_node)\n+\t\t      {\n+\t\t\ttree node = build_omp_clause (input_location,\n+\t\t\t\t\t\t      OMP_CLAUSE_LINEAR);\n+\t\t\tOMP_CLAUSE_DECL (node) = t;\n+\t\t\tif (last_step_expr && last_step == NULL_TREE)\n+\t\t\t  {\n+\t\t\t    if (block == NULL)\n+\t\t\t      last_step\n+\t\t\t\t= gfc_conv_constant_to_tree (last_step_expr);\n+\t\t\t    else\n+\t\t\t      {\n+\t\t\t\tgfc_init_se (&se, NULL);\n+\t\t\t\tgfc_conv_expr (&se, last_step_expr);\n+\t\t\t\tgfc_add_block_to_block (block, &se.pre);\n+\t\t\t\tlast_step = gfc_evaluate_now (se.expr, block);\n+\t\t\t\tgfc_add_block_to_block (block, &se.post);\n+\t\t\t      }\n+\t\t\t  }\n+\t\t\tOMP_CLAUSE_LINEAR_STEP (node) = last_step;\n+\t\t\tomp_clauses = gfc_trans_add_clause (node, omp_clauses);\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t  }\n+\t  break;\n+\tcase OMP_LIST_DEPEND_IN:\n+\tcase OMP_LIST_DEPEND_OUT:\n+\t  for (; n != NULL; n = n->next)\n+\t    {\n+\t      if (!n->sym->attr.referenced)\n+\t\tcontinue;\n+\n+\t      tree node = build_omp_clause (input_location, OMP_CLAUSE_DEPEND);\n+\t      if (n->expr == NULL || n->expr->ref->u.ar.type == AR_FULL)\n+\t\t{\n+\t\t  OMP_CLAUSE_DECL (node) = gfc_get_symbol_decl (n->sym);\n+\t\t  if (DECL_P (OMP_CLAUSE_DECL (node)))\n+\t\t    TREE_ADDRESSABLE (OMP_CLAUSE_DECL (node)) = 1;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  tree ptr;\n+\t\t  gfc_init_se (&se, NULL);\n+\t\t  if (n->expr->ref->u.ar.type == AR_ELEMENT)\n+\t\t    {\n+\t\t      gfc_conv_expr_reference (&se, n->expr);\n+\t\t      ptr = se.expr;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      gfc_conv_expr_descriptor (&se, n->expr);\n+\t\t      ptr = gfc_conv_array_data (se.expr);\n+\t\t    }\n+\t\t  gfc_add_block_to_block (block, &se.pre);\n+\t\t  gfc_add_block_to_block (block, &se.post);\n+\t\t  OMP_CLAUSE_DECL (node)\n+\t\t    = fold_build1_loc (input_location, INDIRECT_REF,\n+\t\t\t\t       TREE_TYPE (TREE_TYPE (ptr)), ptr);\n+\t\t}\n+\t      OMP_CLAUSE_DEPEND_KIND (node)\n+\t\t= ((list == OMP_LIST_DEPEND_IN)\n+\t\t   ? OMP_CLAUSE_DEPEND_IN : OMP_CLAUSE_DEPEND_OUT);\n+\t      omp_clauses = gfc_trans_add_clause (node, omp_clauses);\n+\t    }\n \t  break;\n \tdefault:\n \t  break;\n@@ -1000,6 +1142,83 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n \n+  if (clauses->inbranch)\n+    {\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_INBRANCH);\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n+  if (clauses->notinbranch)\n+    {\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_NOTINBRANCH);\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n+  switch (clauses->cancel)\n+    {\n+    case OMP_CANCEL_UNKNOWN:\n+      break;\n+    case OMP_CANCEL_PARALLEL:\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_PARALLEL);\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+      break;\n+    case OMP_CANCEL_SECTIONS:\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_SECTIONS);\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+      break;\n+    case OMP_CANCEL_DO:\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_FOR);\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+      break;\n+    case OMP_CANCEL_TASKGROUP:\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_TASKGROUP);\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+      break;\n+    }\n+\n+  if (clauses->proc_bind != OMP_PROC_BIND_UNKNOWN)\n+    {\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_PROC_BIND);\n+      switch (clauses->proc_bind)\n+\t{\n+\tcase OMP_PROC_BIND_MASTER:\n+\t  OMP_CLAUSE_PROC_BIND_KIND (c) = OMP_CLAUSE_PROC_BIND_MASTER;\n+\t  break;\n+\tcase OMP_PROC_BIND_SPREAD:\n+\t  OMP_CLAUSE_PROC_BIND_KIND (c) = OMP_CLAUSE_PROC_BIND_SPREAD;\n+\t  break;\n+\tcase OMP_PROC_BIND_CLOSE:\n+\t  OMP_CLAUSE_PROC_BIND_KIND (c) = OMP_CLAUSE_PROC_BIND_CLOSE;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n+  if (clauses->safelen_expr)\n+    {\n+      tree safelen_var;\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, clauses->safelen_expr);\n+      gfc_add_block_to_block (block, &se.pre);\n+      safelen_var = gfc_evaluate_now (se.expr, block);\n+      gfc_add_block_to_block (block, &se.post);\n+\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_SAFELEN);\n+      OMP_CLAUSE_SAFELEN_EXPR (c) = safelen_var;\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n+  if (clauses->simdlen_expr)\n+    {\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_SIMDLEN);\n+      OMP_CLAUSE_SIMDLEN_EXPR (c)\n+\t= gfc_conv_constant_to_tree (clauses->simdlen_expr);\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n   return omp_clauses;\n }\n \n@@ -1045,6 +1264,7 @@ gfc_trans_omp_atomic (gfc_code *code)\n   enum tree_code op = ERROR_MARK;\n   enum tree_code aop = OMP_ATOMIC;\n   bool var_on_left = false;\n+  bool seq_cst = (atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_SEQ_CST) != 0;\n \n   code = code->block->next;\n   gcc_assert (code->op == EXEC_ASSIGN);\n@@ -1060,7 +1280,7 @@ gfc_trans_omp_atomic (gfc_code *code)\n       && expr2->value.function.isym->id == GFC_ISYM_CONVERSION)\n     expr2 = expr2->value.function.actual->expr;\n \n-  switch (atomic_code->ext.omp_atomic)\n+  switch (atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_MASK)\n     {\n     case GFC_OMP_ATOMIC_READ:\n       gfc_conv_expr (&vse, code->expr1);\n@@ -1072,6 +1292,7 @@ gfc_trans_omp_atomic (gfc_code *code)\n       lhsaddr = gfc_build_addr_expr (NULL, lse.expr);\n \n       x = build1 (OMP_ATOMIC_READ, type, lhsaddr);\n+      OMP_ATOMIC_SEQ_CST (x) = seq_cst;\n       x = convert (TREE_TYPE (vse.expr), x);\n       gfc_add_modify (&block, vse.expr, x);\n \n@@ -1107,7 +1328,9 @@ gfc_trans_omp_atomic (gfc_code *code)\n   type = TREE_TYPE (lse.expr);\n   lhsaddr = gfc_build_addr_expr (NULL, lse.expr);\n \n-  if (atomic_code->ext.omp_atomic == GFC_OMP_ATOMIC_WRITE)\n+  if (((atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_MASK)\n+       == GFC_OMP_ATOMIC_WRITE)\n+      || (atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_SWAP))\n     {\n       gfc_conv_expr (&rse, expr2);\n       gfc_add_block_to_block (&block, &rse.pre);\n@@ -1229,7 +1452,9 @@ gfc_trans_omp_atomic (gfc_code *code)\n   lhsaddr = save_expr (lhsaddr);\n   rhs = gfc_evaluate_now (rse.expr, &block);\n \n-  if (atomic_code->ext.omp_atomic == GFC_OMP_ATOMIC_WRITE)\n+  if (((atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_MASK)\n+       == GFC_OMP_ATOMIC_WRITE)\n+      || (atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_SWAP))\n     x = rhs;\n   else\n     {\n@@ -1252,6 +1477,7 @@ gfc_trans_omp_atomic (gfc_code *code)\n   if (aop == OMP_ATOMIC)\n     {\n       x = build2_v (OMP_ATOMIC, lhsaddr, convert (type, x));\n+      OMP_ATOMIC_SEQ_CST (x) = seq_cst;\n       gfc_add_expr_to_block (&block, x);\n     }\n   else\n@@ -1273,6 +1499,7 @@ gfc_trans_omp_atomic (gfc_code *code)\n \t  gfc_add_block_to_block (&block, &lse.pre);\n \t}\n       x = build2 (aop, type, lhsaddr, convert (type, x));\n+      OMP_ATOMIC_SEQ_CST (x) = seq_cst;\n       x = convert (TREE_TYPE (vse.expr), x);\n       gfc_add_modify (&block, vse.expr, x);\n     }\n@@ -1287,6 +1514,63 @@ gfc_trans_omp_barrier (void)\n   return build_call_expr_loc (input_location, decl, 0);\n }\n \n+static tree\n+gfc_trans_omp_cancel (gfc_code *code)\n+{\n+  int mask = 0;\n+  tree ifc = boolean_true_node;\n+  stmtblock_t block;\n+  switch (code->ext.omp_clauses->cancel)\n+    {\n+    case OMP_CANCEL_PARALLEL: mask = 1; break;\n+    case OMP_CANCEL_DO: mask = 2; break;\n+    case OMP_CANCEL_SECTIONS: mask = 4; break;\n+    case OMP_CANCEL_TASKGROUP: mask = 8; break;\n+    default: gcc_unreachable ();\n+    }\n+  gfc_start_block (&block);\n+  if (code->ext.omp_clauses->if_expr)\n+    {\n+      gfc_se se;\n+      tree if_var;\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, code->ext.omp_clauses->if_expr);\n+      gfc_add_block_to_block (&block, &se.pre);\n+      if_var = gfc_evaluate_now (se.expr, &block);\n+      gfc_add_block_to_block (&block, &se.post);\n+      tree type = TREE_TYPE (if_var);\n+      ifc = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t     boolean_type_node, if_var,\n+\t\t\t     build_zero_cst (type));\n+    }\n+  tree decl = builtin_decl_explicit (BUILT_IN_GOMP_CANCEL);\n+  tree c_bool_type = TREE_TYPE (TREE_TYPE (decl));\n+  ifc = fold_convert (c_bool_type, ifc);\n+  gfc_add_expr_to_block (&block,\n+\t\t\t build_call_expr_loc (input_location, decl, 2,\n+\t\t\t\t\t      build_int_cst (integer_type_node,\n+\t\t\t\t\t\t\t     mask), ifc));\n+  return gfc_finish_block (&block);\n+}\n+\n+static tree\n+gfc_trans_omp_cancellation_point (gfc_code *code)\n+{\n+  int mask = 0;\n+  switch (code->ext.omp_clauses->cancel)\n+    {\n+    case OMP_CANCEL_PARALLEL: mask = 1; break;\n+    case OMP_CANCEL_DO: mask = 2; break;\n+    case OMP_CANCEL_SECTIONS: mask = 4; break;\n+    case OMP_CANCEL_TASKGROUP: mask = 8; break;\n+    default: gcc_unreachable ();\n+    }\n+  tree decl = builtin_decl_explicit (BUILT_IN_GOMP_CANCELLATION_POINT);\n+  return build_call_expr_loc (input_location, decl, 1,\n+\t\t\t      build_int_cst (integer_type_node, mask));\n+}\n+\n static tree\n gfc_trans_omp_critical (gfc_code *code)\n {\n@@ -1304,7 +1588,7 @@ typedef struct dovar_init_d {\n \n \n static tree\n-gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n+gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t\t  gfc_omp_clauses *do_clauses, tree par_clauses)\n {\n   gfc_se se;\n@@ -1344,14 +1628,15 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n \n       if (clauses)\n \t{\n-\t  gfc_namelist *n;\n-\t  for (n = clauses->lists[OMP_LIST_LASTPRIVATE]; n != NULL;\n-\t       n = n->next)\n+\t  gfc_omp_namelist *n;\n+\t  for (n = clauses->lists[(op == EXEC_OMP_SIMD && collapse == 1)\n+\t\t\t\t  ? OMP_LIST_LINEAR : OMP_LIST_LASTPRIVATE];\n+\t       n != NULL; n = n->next)\n \t    if (code->ext.iterator->var->symtree->n.sym == n->sym)\n \t      break;\n \t  if (n != NULL)\n \t    dovar_found = 1;\n-\t  else if (n == NULL)\n+\t  else if (n == NULL && op != EXEC_OMP_SIMD)\n \t    for (n = clauses->lists[OMP_LIST_PRIVATE]; n != NULL; n = n->next)\n \t      if (code->ext.iterator->var->symtree->n.sym == n->sym)\n \t\tbreak;\n@@ -1393,7 +1678,8 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n \t}\n       else\n \tdovar_decl\n-\t  = gfc_trans_omp_variable (code->ext.iterator->var->symtree->n.sym);\n+\t  = gfc_trans_omp_variable (code->ext.iterator->var->symtree->n.sym,\n+\t\t\t\t    false);\n \n       /* Loop body.  */\n       if (simple)\n@@ -1447,11 +1733,24 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n \n       if (!dovar_found)\n \t{\n-\t  tmp = build_omp_clause (input_location, OMP_CLAUSE_PRIVATE);\n+\t  if (op == EXEC_OMP_SIMD)\n+\t    {\n+\t      if (collapse == 1)\n+\t\t{\n+\t\t  tmp = build_omp_clause (input_location, OMP_CLAUSE_LINEAR);\n+\t\t  OMP_CLAUSE_LINEAR_STEP (tmp) = step;\n+\t\t}\n+\t      else\n+\t\ttmp = build_omp_clause (input_location, OMP_CLAUSE_LASTPRIVATE);\n+\t      if (!simple)\n+\t\tdovar_found = 2;\n+\t    }\n+\t  else\n+\t    tmp = build_omp_clause (input_location, OMP_CLAUSE_PRIVATE);\n \t  OMP_CLAUSE_DECL (tmp) = dovar_decl;\n \t  omp_clauses = gfc_trans_add_clause (tmp, omp_clauses);\n \t}\n-      else if (dovar_found == 2)\n+      if (dovar_found == 2)\n \t{\n \t  tree c = NULL;\n \n@@ -1475,8 +1774,14 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n \t\t    OMP_CLAUSE_LASTPRIVATE_STMT (c) = tmp;\n \t\t    break;\n \t\t  }\n+\t\telse if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINEAR\n+\t\t\t && OMP_CLAUSE_DECL (c) == dovar_decl)\n+\t\t  {\n+\t\t    OMP_CLAUSE_LINEAR_STMT (c) = tmp;\n+\t\t    break;\n+\t\t  }\n \t    }\n-\t  if (c == NULL && par_clauses != NULL)\n+\t  if (c == NULL && op == EXEC_OMP_DO && par_clauses != NULL)\n \t    {\n \t      for (c = par_clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n \t\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n@@ -1496,7 +1801,17 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n \t}\n       if (!simple)\n \t{\n-\t  tmp = build_omp_clause (input_location, OMP_CLAUSE_PRIVATE);\n+\t  if (op != EXEC_OMP_SIMD)\n+\t    tmp = build_omp_clause (input_location, OMP_CLAUSE_PRIVATE);\n+\t  else if (collapse == 1)\n+\t    {\n+\t      tmp = build_omp_clause (input_location, OMP_CLAUSE_LINEAR);\n+\t      OMP_CLAUSE_LINEAR_STEP (tmp) = step;\n+\t      OMP_CLAUSE_LINEAR_NO_COPYIN (tmp) = 1;\n+\t      OMP_CLAUSE_LINEAR_NO_COPYOUT (tmp) = 1;\n+\t    }\n+\t  else\n+\t    tmp = build_omp_clause (input_location, OMP_CLAUSE_LASTPRIVATE);\n \t  OMP_CLAUSE_DECL (tmp) = count;\n \t  omp_clauses = gfc_trans_add_clause (tmp, omp_clauses);\n \t}\n@@ -1538,7 +1853,7 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n     }\n \n   /* End of loop body.  */\n-  stmt = make_node (OMP_FOR);\n+  stmt = make_node (op == EXEC_OMP_SIMD ? OMP_SIMD : OMP_FOR);\n \n   TREE_TYPE (stmt) = void_type_node;\n   OMP_FOR_BODY (stmt) = gfc_finish_block (&body);\n@@ -1589,37 +1904,219 @@ gfc_trans_omp_parallel (gfc_code *code)\n   return gfc_finish_block (&block);\n }\n \n+enum\n+{\n+  GFC_OMP_SPLIT_SIMD,\n+  GFC_OMP_SPLIT_DO,\n+  GFC_OMP_SPLIT_PARALLEL,\n+  GFC_OMP_SPLIT_NUM\n+};\n+\n+enum\n+{\n+  GFC_OMP_MASK_SIMD = (1 << GFC_OMP_SPLIT_SIMD),\n+  GFC_OMP_MASK_DO = (1 << GFC_OMP_SPLIT_DO),\n+  GFC_OMP_MASK_PARALLEL = (1 << GFC_OMP_SPLIT_PARALLEL)\n+};\n+\n+static void\n+gfc_split_omp_clauses (gfc_code *code,\n+\t\t       gfc_omp_clauses clausesa[GFC_OMP_SPLIT_NUM])\n+{\n+  int mask = 0, innermost = 0, i;\n+  memset (clausesa, 0, GFC_OMP_SPLIT_NUM * sizeof (gfc_omp_clauses));\n+  switch (code->op)\n+    {\n+    case EXEC_OMP_DO_SIMD:\n+      mask = GFC_OMP_MASK_DO | GFC_OMP_MASK_SIMD;\n+      innermost = GFC_OMP_SPLIT_SIMD;\n+      break;\n+    case EXEC_OMP_PARALLEL_DO:\n+      mask = GFC_OMP_MASK_PARALLEL | GFC_OMP_MASK_DO;\n+      innermost = GFC_OMP_SPLIT_DO;\n+      break;\n+    case EXEC_OMP_PARALLEL_DO_SIMD:\n+      mask = GFC_OMP_MASK_PARALLEL | GFC_OMP_MASK_DO | GFC_OMP_MASK_SIMD;\n+      innermost = GFC_OMP_SPLIT_SIMD;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  if (code->ext.omp_clauses != NULL)\n+    {\n+      if (mask & GFC_OMP_MASK_PARALLEL)\n+\t{\n+\t  /* First the clauses that are unique to some constructs.  */\n+\t  clausesa[GFC_OMP_SPLIT_PARALLEL].lists[OMP_LIST_COPYIN]\n+\t    = code->ext.omp_clauses->lists[OMP_LIST_COPYIN];\n+\t  clausesa[GFC_OMP_SPLIT_PARALLEL].num_threads\n+\t    = code->ext.omp_clauses->num_threads;\n+\t  clausesa[GFC_OMP_SPLIT_PARALLEL].proc_bind\n+\t    = code->ext.omp_clauses->proc_bind;\n+\t  /* Shared and default clauses are allowed on parallel and teams.  */\n+\t  clausesa[GFC_OMP_SPLIT_PARALLEL].lists[OMP_LIST_SHARED]\n+\t    = code->ext.omp_clauses->lists[OMP_LIST_SHARED];\n+\t  clausesa[GFC_OMP_SPLIT_PARALLEL].default_sharing\n+\t    = code->ext.omp_clauses->default_sharing;\n+\t  /* FIXME: This is currently being discussed.  */\n+\t  clausesa[GFC_OMP_SPLIT_PARALLEL].if_expr\n+\t    = code->ext.omp_clauses->if_expr;\n+\t}\n+      if (mask & GFC_OMP_MASK_DO)\n+\t{\n+\t  /* First the clauses that are unique to some constructs.  */\n+\t  clausesa[GFC_OMP_SPLIT_DO].ordered\n+\t    = code->ext.omp_clauses->ordered;\n+\t  clausesa[GFC_OMP_SPLIT_DO].sched_kind\n+\t    = code->ext.omp_clauses->sched_kind;\n+\t  clausesa[GFC_OMP_SPLIT_DO].chunk_size\n+\t    = code->ext.omp_clauses->chunk_size;\n+\t  clausesa[GFC_OMP_SPLIT_DO].nowait\n+\t    = code->ext.omp_clauses->nowait;\n+\t  /* Duplicate collapse.  */\n+\t  clausesa[GFC_OMP_SPLIT_DO].collapse\n+\t    = code->ext.omp_clauses->collapse;\n+\t}\n+      if (mask & GFC_OMP_MASK_SIMD)\n+\t{\n+\t  clausesa[GFC_OMP_SPLIT_SIMD].safelen_expr\n+\t    = code->ext.omp_clauses->safelen_expr;\n+\t  clausesa[GFC_OMP_SPLIT_SIMD].lists[OMP_LIST_LINEAR]\n+\t    = code->ext.omp_clauses->lists[OMP_LIST_LINEAR];\n+\t  clausesa[GFC_OMP_SPLIT_SIMD].lists[OMP_LIST_ALIGNED]\n+\t    = code->ext.omp_clauses->lists[OMP_LIST_ALIGNED];\n+\t  /* Duplicate collapse.  */\n+\t  clausesa[GFC_OMP_SPLIT_SIMD].collapse\n+\t    = code->ext.omp_clauses->collapse;\n+\t}\n+      /* Private clause is supported on all constructs but target,\n+\t it is enough to put it on the innermost one.  For\n+\t !$ omp do put it on parallel though,\n+\t as that's what we did for OpenMP 3.1.  */\n+      clausesa[innermost == GFC_OMP_SPLIT_DO\n+\t       ? (int) GFC_OMP_SPLIT_PARALLEL\n+\t       : innermost].lists[OMP_LIST_PRIVATE]\n+\t= code->ext.omp_clauses->lists[OMP_LIST_PRIVATE];\n+      /* Firstprivate clause is supported on all constructs but\n+\t target and simd.  Put it on the outermost of those and\n+\t duplicate on parallel.  */\n+      if (mask & GFC_OMP_MASK_PARALLEL)\n+\tclausesa[GFC_OMP_SPLIT_PARALLEL].lists[OMP_LIST_FIRSTPRIVATE]\n+\t  = code->ext.omp_clauses->lists[OMP_LIST_FIRSTPRIVATE];\n+      else if (mask & GFC_OMP_MASK_DO)\n+\tclausesa[GFC_OMP_SPLIT_DO].lists[OMP_LIST_FIRSTPRIVATE]\n+\t  = code->ext.omp_clauses->lists[OMP_LIST_FIRSTPRIVATE];\n+      /* Lastprivate is allowed on do and simd.  In\n+\t parallel do{, simd} we actually want to put it on\n+\t parallel rather than do.  */\n+      if (mask & GFC_OMP_MASK_PARALLEL)\n+\tclausesa[GFC_OMP_SPLIT_PARALLEL].lists[OMP_LIST_LASTPRIVATE]\n+\t  = code->ext.omp_clauses->lists[OMP_LIST_LASTPRIVATE];\n+      else if (mask & GFC_OMP_MASK_DO)\n+\tclausesa[GFC_OMP_SPLIT_DO].lists[OMP_LIST_LASTPRIVATE]\n+\t  = code->ext.omp_clauses->lists[OMP_LIST_LASTPRIVATE];\n+      if (mask & GFC_OMP_MASK_SIMD)\n+\tclausesa[GFC_OMP_SPLIT_SIMD].lists[OMP_LIST_LASTPRIVATE]\n+\t  = code->ext.omp_clauses->lists[OMP_LIST_LASTPRIVATE];\n+      /* Reduction is allowed on simd, do, parallel and teams.\n+\t Duplicate it on all of them, but omit on do if\n+\t parallel is present.  */\n+      for (i = OMP_LIST_REDUCTION_FIRST; i <= OMP_LIST_REDUCTION_LAST; i++)\n+\t{\n+\t  if (mask & GFC_OMP_MASK_PARALLEL)\n+\t    clausesa[GFC_OMP_SPLIT_PARALLEL].lists[i]\n+\t      = code->ext.omp_clauses->lists[i];\n+\t  else if (mask & GFC_OMP_MASK_DO)\n+\t    clausesa[GFC_OMP_SPLIT_DO].lists[i]\n+\t      = code->ext.omp_clauses->lists[i];\n+\t  if (mask & GFC_OMP_MASK_SIMD)\n+\t    clausesa[GFC_OMP_SPLIT_SIMD].lists[i]\n+\t      = code->ext.omp_clauses->lists[i];\n+\t}\n+    }\n+  if ((mask & (GFC_OMP_MASK_PARALLEL | GFC_OMP_MASK_DO))\n+      == (GFC_OMP_MASK_PARALLEL | GFC_OMP_MASK_DO))\n+    clausesa[GFC_OMP_SPLIT_DO].nowait = true;\n+}\n+\n static tree\n-gfc_trans_omp_parallel_do (gfc_code *code)\n+gfc_trans_omp_do_simd (gfc_code *code, gfc_omp_clauses *clausesa,\n+\t\t       tree omp_clauses)\n {\n   stmtblock_t block, *pblock = NULL;\n-  gfc_omp_clauses parallel_clauses, do_clauses;\n-  tree stmt, omp_clauses = NULL_TREE;\n+  gfc_omp_clauses clausesa_buf[GFC_OMP_SPLIT_NUM];\n+  tree stmt, body, omp_do_clauses = NULL_TREE;\n \n   gfc_start_block (&block);\n \n-  memset (&do_clauses, 0, sizeof (do_clauses));\n-  if (code->ext.omp_clauses != NULL)\n+  if (clausesa == NULL)\n     {\n-      memcpy (&parallel_clauses, code->ext.omp_clauses,\n-\t      sizeof (parallel_clauses));\n-      do_clauses.sched_kind = parallel_clauses.sched_kind;\n-      do_clauses.chunk_size = parallel_clauses.chunk_size;\n-      do_clauses.ordered = parallel_clauses.ordered;\n-      do_clauses.collapse = parallel_clauses.collapse;\n-      parallel_clauses.sched_kind = OMP_SCHED_NONE;\n-      parallel_clauses.chunk_size = NULL;\n-      parallel_clauses.ordered = false;\n-      parallel_clauses.collapse = 0;\n-      omp_clauses = gfc_trans_omp_clauses (&block, &parallel_clauses,\n-\t\t\t\t\t   code->loc);\n+      clausesa = clausesa_buf;\n+      gfc_split_omp_clauses (code, clausesa);\n     }\n-  do_clauses.nowait = true;\n-  if (!do_clauses.ordered && do_clauses.sched_kind != OMP_SCHED_STATIC)\n+  omp_do_clauses\n+    = gfc_trans_omp_clauses (&block, &clausesa[GFC_OMP_SPLIT_DO], code->loc);\n+  pblock = &block;\n+  body = gfc_trans_omp_do (code, EXEC_OMP_SIMD, pblock,\n+\t\t\t   &clausesa[GFC_OMP_SPLIT_SIMD], omp_clauses);\n+  if (TREE_CODE (body) != BIND_EXPR)\n+    body = build3_v (BIND_EXPR, NULL, body, poplevel (1, 0));\n+  else\n+    poplevel (0, 0);\n+  stmt = make_node (OMP_FOR);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_FOR_BODY (stmt) = body;\n+  OMP_FOR_CLAUSES (stmt) = omp_do_clauses;\n+  gfc_add_expr_to_block (&block, stmt);\n+  return gfc_finish_block (&block);\n+}\n+\n+static tree\n+gfc_trans_omp_parallel_do (gfc_code *code)\n+{\n+  stmtblock_t block, *pblock = NULL;\n+  gfc_omp_clauses clausesa[GFC_OMP_SPLIT_NUM];\n+  tree stmt, omp_clauses = NULL_TREE;\n+\n+  gfc_start_block (&block);\n+\n+  gfc_split_omp_clauses (code, clausesa);\n+  omp_clauses\n+    = gfc_trans_omp_clauses (&block, &clausesa[GFC_OMP_SPLIT_PARALLEL],\n+\t\t\t     code->loc);\n+  if (!clausesa[GFC_OMP_SPLIT_DO].ordered\n+      && clausesa[GFC_OMP_SPLIT_DO].sched_kind != OMP_SCHED_STATIC)\n     pblock = &block;\n   else\n     pushlevel ();\n-  stmt = gfc_trans_omp_do (code, pblock, &do_clauses, omp_clauses);\n+  stmt = gfc_trans_omp_do (code, EXEC_OMP_DO, pblock,\n+\t\t\t   &clausesa[GFC_OMP_SPLIT_DO], omp_clauses);\n+  if (TREE_CODE (stmt) != BIND_EXPR)\n+    stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n+  else\n+    poplevel (0, 0);\n+  stmt = build2_loc (input_location, OMP_PARALLEL, void_type_node, stmt,\n+\t\t     omp_clauses);\n+  OMP_PARALLEL_COMBINED (stmt) = 1;\n+  gfc_add_expr_to_block (&block, stmt);\n+  return gfc_finish_block (&block);\n+}\n+\n+static tree\n+gfc_trans_omp_parallel_do_simd (gfc_code *code)\n+{\n+  stmtblock_t block;\n+  gfc_omp_clauses clausesa[GFC_OMP_SPLIT_NUM];\n+  tree stmt, omp_clauses = NULL_TREE;\n+\n+  gfc_start_block (&block);\n+\n+  gfc_split_omp_clauses (code, clausesa);\n+  omp_clauses\n+    = gfc_trans_omp_clauses (&block, &clausesa[GFC_OMP_SPLIT_PARALLEL],\n+\t\t\t     code->loc);\n+  pushlevel ();\n+  stmt = gfc_trans_omp_do_simd (code, clausesa, omp_clauses);\n   if (TREE_CODE (stmt) != BIND_EXPR)\n     stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n   else\n@@ -1742,6 +2239,13 @@ gfc_trans_omp_task (gfc_code *code)\n   return gfc_finish_block (&block);\n }\n \n+static tree\n+gfc_trans_omp_taskgroup (gfc_code *code)\n+{\n+  tree stmt = gfc_trans_code (code->block->next);\n+  return build1_loc (input_location, OMP_TASKGROUP, void_type_node, stmt);\n+}\n+\n static tree\n gfc_trans_omp_taskwait (void)\n {\n@@ -1923,10 +2427,18 @@ gfc_trans_omp_directive (gfc_code *code)\n       return gfc_trans_omp_atomic (code);\n     case EXEC_OMP_BARRIER:\n       return gfc_trans_omp_barrier ();\n+    case EXEC_OMP_CANCEL:\n+      return gfc_trans_omp_cancel (code);\n+    case EXEC_OMP_CANCELLATION_POINT:\n+      return gfc_trans_omp_cancellation_point (code);\n     case EXEC_OMP_CRITICAL:\n       return gfc_trans_omp_critical (code);\n     case EXEC_OMP_DO:\n-      return gfc_trans_omp_do (code, NULL, code->ext.omp_clauses, NULL);\n+    case EXEC_OMP_SIMD:\n+      return gfc_trans_omp_do (code, code->op, NULL, code->ext.omp_clauses,\n+\t\t\t       NULL);\n+    case EXEC_OMP_DO_SIMD:\n+      return gfc_trans_omp_do_simd (code, NULL, NULL_TREE);\n     case EXEC_OMP_FLUSH:\n       return gfc_trans_omp_flush ();\n     case EXEC_OMP_MASTER:\n@@ -1937,6 +2449,8 @@ gfc_trans_omp_directive (gfc_code *code)\n       return gfc_trans_omp_parallel (code);\n     case EXEC_OMP_PARALLEL_DO:\n       return gfc_trans_omp_parallel_do (code);\n+    case EXEC_OMP_PARALLEL_DO_SIMD:\n+      return gfc_trans_omp_parallel_do_simd (code);\n     case EXEC_OMP_PARALLEL_SECTIONS:\n       return gfc_trans_omp_parallel_sections (code);\n     case EXEC_OMP_PARALLEL_WORKSHARE:\n@@ -1947,6 +2461,8 @@ gfc_trans_omp_directive (gfc_code *code)\n       return gfc_trans_omp_single (code, code->ext.omp_clauses);\n     case EXEC_OMP_TASK:\n       return gfc_trans_omp_task (code);\n+    case EXEC_OMP_TASKGROUP:\n+      return gfc_trans_omp_taskgroup (code);\n     case EXEC_OMP_TASKWAIT:\n       return gfc_trans_omp_taskwait ();\n     case EXEC_OMP_TASKYIELD:\n@@ -1957,3 +2473,22 @@ gfc_trans_omp_directive (gfc_code *code)\n       gcc_unreachable ();\n     }\n }\n+\n+void\n+gfc_trans_omp_declare_simd (gfc_namespace *ns)\n+{\n+  if (ns->entries)\n+    return;\n+\n+  gfc_omp_declare_simd *ods;\n+  for (ods = ns->omp_declare_simd; ods; ods = ods->next)\n+    {\n+      tree c = gfc_trans_omp_clauses (NULL, ods->clauses, ods->where, true);\n+      tree fndecl = ns->proc_name->backend_decl;\n+      if (c != NULL_TREE)\n+\tc = tree_cons (NULL_TREE, c, NULL_TREE);\n+      c = build_tree_list (get_identifier (\"omp declare simd\"), c);\n+      TREE_CHAIN (c) = DECL_ATTRIBUTES (fndecl);\n+      DECL_ATTRIBUTES (fndecl) = c;\n+    }\n+}"}, {"sha": "087bafea4b00f54fc25721c3fe1657276447a5f7", "filename": "gcc/fortran/trans-stmt.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Ftrans-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Ftrans-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.h?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -63,6 +63,7 @@ tree gfc_trans_deallocate_array (tree);\n \n /* trans-openmp.c */\n tree gfc_trans_omp_directive (gfc_code *);\n+void gfc_trans_omp_declare_simd (gfc_namespace *);\n \n /* trans-io.c */\n tree gfc_trans_open (gfc_code *);"}, {"sha": "8182da5414117f29a330c8c6cdb1c69f6618834a", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -1848,18 +1848,24 @@ trans_code (gfc_code * code, tree cond)\n \n \tcase EXEC_OMP_ATOMIC:\n \tcase EXEC_OMP_BARRIER:\n+\tcase EXEC_OMP_CANCEL:\n+\tcase EXEC_OMP_CANCELLATION_POINT:\n \tcase EXEC_OMP_CRITICAL:\n \tcase EXEC_OMP_DO:\n+\tcase EXEC_OMP_DO_SIMD:\n \tcase EXEC_OMP_FLUSH:\n \tcase EXEC_OMP_MASTER:\n \tcase EXEC_OMP_ORDERED:\n \tcase EXEC_OMP_PARALLEL:\n \tcase EXEC_OMP_PARALLEL_DO:\n+\tcase EXEC_OMP_PARALLEL_DO_SIMD:\n \tcase EXEC_OMP_PARALLEL_SECTIONS:\n \tcase EXEC_OMP_PARALLEL_WORKSHARE:\n \tcase EXEC_OMP_SECTIONS:\n+\tcase EXEC_OMP_SIMD:\n \tcase EXEC_OMP_SINGLE:\n \tcase EXEC_OMP_TASK:\n+\tcase EXEC_OMP_TASKGROUP:\n \tcase EXEC_OMP_TASKWAIT:\n \tcase EXEC_OMP_TASKYIELD:\n \tcase EXEC_OMP_WORKSHARE:"}, {"sha": "32416331ac5c6e43c2f3f6fddb1ddfe87a767379", "filename": "gcc/gimplify.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -6067,6 +6067,27 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t(gimple_seq_first_stmt (OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (c)));\n \t      OMP_CLAUSE_LASTPRIVATE_STMT (c) = NULL_TREE;\n \n+\t      gimplify_omp_ctxp = outer_ctx;\n+\t    }\n+\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINEAR\n+\t\t   && OMP_CLAUSE_LINEAR_STMT (c))\n+\t    {\n+\t      gimplify_omp_ctxp = ctx;\n+\t      push_gimplify_context ();\n+\t      if (TREE_CODE (OMP_CLAUSE_LINEAR_STMT (c)) != BIND_EXPR)\n+\t\t{\n+\t\t  tree bind = build3 (BIND_EXPR, void_type_node, NULL,\n+\t\t\t\t      NULL, NULL);\n+\t\t  TREE_SIDE_EFFECTS (bind) = 1;\n+\t\t  BIND_EXPR_BODY (bind) = OMP_CLAUSE_LINEAR_STMT (c);\n+\t\t  OMP_CLAUSE_LINEAR_STMT (c) = bind;\n+\t\t}\n+\t      gimplify_and_add (OMP_CLAUSE_LINEAR_STMT (c),\n+\t\t\t\t&OMP_CLAUSE_LINEAR_GIMPLE_SEQ (c));\n+\t      pop_gimplify_context\n+\t\t(gimple_seq_first_stmt (OMP_CLAUSE_LINEAR_GIMPLE_SEQ (c)));\n+\t      OMP_CLAUSE_LINEAR_STMT (c) = NULL_TREE;\n+\n \t      gimplify_omp_ctxp = outer_ctx;\n \t    }\n \t  if (notice_outer)"}, {"sha": "ddd2bd563e178b0af9a6f8cadafcd85be5c10839", "filename": "gcc/omp-low.c", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -3405,8 +3405,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t    = gimple_build_assign (unshare_expr (lvar), iv);\n \t\t\t  gsi_insert_before_without_update (&gsi, g,\n \t\t\t\t\t\t\t    GSI_SAME_STMT);\n-\t\t\t  tree stept = POINTER_TYPE_P (TREE_TYPE (x))\n-\t\t\t\t       ? sizetype : TREE_TYPE (x);\n+\t\t\t  tree stept = POINTER_TYPE_P (TREE_TYPE (iv))\n+\t\t\t\t       ? sizetype : TREE_TYPE (iv);\n \t\t\t  tree t = fold_convert (stept,\n \t\t\t\t\t\t OMP_CLAUSE_LINEAR_STEP (c));\n \t\t\t  enum tree_code code = PLUS_EXPR;\n@@ -8416,10 +8416,14 @@ maybe_add_implicit_barrier_cancel (omp_context *ctx, gimple_seq *body)\n       && gimple_code (ctx->outer->stmt) == GIMPLE_OMP_PARALLEL\n       && ctx->outer->cancellable)\n     {\n-      tree lhs = create_tmp_var (boolean_type_node, NULL);\n+      tree fndecl = builtin_decl_explicit (BUILT_IN_GOMP_CANCEL);\n+      tree c_bool_type = TREE_TYPE (TREE_TYPE (fndecl));\n+      tree lhs = create_tmp_var (c_bool_type, NULL);\n       gimple_omp_return_set_lhs (omp_return, lhs);\n       tree fallthru_label = create_artificial_label (UNKNOWN_LOCATION);\n-      gimple g = gimple_build_cond (NE_EXPR, lhs, boolean_false_node,\n+      gimple g = gimple_build_cond (NE_EXPR, lhs,\n+\t\t\t\t    fold_convert (c_bool_type,\n+\t\t\t\t\t\t  boolean_false_node),\n \t\t\t\t    ctx->outer->cancel_label, fallthru_label);\n       gimple_seq_add_stmt (body, g);\n       gimple_seq_add_stmt (body, gimple_build_label (fallthru_label));\n@@ -10125,21 +10129,23 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t  }\n \t\tbreak;\n \t      }\n-\t    tree lhs;\n-\t    lhs = create_tmp_var (boolean_type_node, NULL);\n \t    if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_GOMP_BARRIER)\n \t      {\n \t\tfndecl = builtin_decl_explicit (BUILT_IN_GOMP_BARRIER_CANCEL);\n \t\tgimple_call_set_fndecl (stmt, fndecl);\n \t\tgimple_call_set_fntype (stmt, TREE_TYPE (fndecl));\n \t      }\n+\t    tree lhs;\n+\t    lhs = create_tmp_var (TREE_TYPE (TREE_TYPE (fndecl)), NULL);\n \t    gimple_call_set_lhs (stmt, lhs);\n \t    tree fallthru_label;\n \t    fallthru_label = create_artificial_label (UNKNOWN_LOCATION);\n \t    gimple g;\n \t    g = gimple_build_label (fallthru_label);\n \t    gsi_insert_after (gsi_p, g, GSI_SAME_STMT);\n-\t    g = gimple_build_cond (NE_EXPR, lhs, boolean_false_node,\n+\t    g = gimple_build_cond (NE_EXPR, lhs,\n+\t\t\t\t   fold_convert (TREE_TYPE (lhs),\n+\t\t\t\t\t\t boolean_false_node),\n \t\t\t\t   cctx->cancel_label, fallthru_label);\n \t    gsi_insert_after (gsi_p, g, GSI_SAME_STMT);\n \t    break;"}, {"sha": "2afe7e603bc86b6cb1b74b15f3050eedd2f69c94", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -1,3 +1,7 @@\n+2014-05-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gfortran.dg/gomp/affinity-1.f90: New test.\n+\n 2014-05-11  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* gcc.dg/torture/pr61136.c: New test."}, {"sha": "b6e20b9ce63fe58e1fd12543f1461ef8a1172faa", "filename": "gcc/testsuite/gfortran.dg/gomp/affinity-1.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Faffinity-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Faffinity-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Faffinity-1.f90?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -0,0 +1,19 @@\n+  integer :: i, j\n+  integer, dimension (10, 10) :: a\n+!$omp parallel do default(none)proc_bind(master)shared(a)\n+  do i = 1, 10\n+    j = 4\n+    do j = 1, 10\n+      a(i, j) = i + j\n+    end do\n+    j = 8\n+  end do\n+!$omp end parallel do\n+!$omp parallel proc_bind (close)\n+!$omp parallel default(none) proc_bind (spread) firstprivate(a) private (i)\n+  do i = 1, 10\n+    a(i, i) = i\n+  enddo\n+!$omp end parallel\n+!$omp endparallel\n+end"}, {"sha": "ba2cc7657098910fe5242e0feeef5b9fa6adf7f6", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -1112,6 +1112,7 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_FINAL:\n \tcase OMP_CLAUSE_IF:\n \tcase OMP_CLAUSE_NUM_THREADS:\n+\tcase OMP_CLAUSE_DEPEND:\n \t  wi->val_only = true;\n \t  wi->is_lhs = false;\n \t  convert_nonlocal_reference_op (&OMP_CLAUSE_OPERAND (clause, 0),\n@@ -1651,6 +1652,7 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_FINAL:\n \tcase OMP_CLAUSE_IF:\n \tcase OMP_CLAUSE_NUM_THREADS:\n+\tcase OMP_CLAUSE_DEPEND:\n \t  wi->val_only = true;\n \t  wi->is_lhs = false;\n \t  convert_local_reference_op (&OMP_CLAUSE_OPERAND (clause, 0), &dummy,"}, {"sha": "4655227e660c3aa5e8f86985b07ebc9bce78f96b", "filename": "gcc/tree.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -253,7 +253,7 @@ unsigned const char omp_clause_num_ops[] =\n   4, /* OMP_CLAUSE_REDUCTION  */\n   1, /* OMP_CLAUSE_COPYIN  */\n   1, /* OMP_CLAUSE_COPYPRIVATE  */\n-  2, /* OMP_CLAUSE_LINEAR  */\n+  3, /* OMP_CLAUSE_LINEAR  */\n   2, /* OMP_CLAUSE_ALIGNED  */\n   1, /* OMP_CLAUSE_DEPEND  */\n   1, /* OMP_CLAUSE_UNIFORM  */\n@@ -10960,8 +10960,13 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \t    WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));\n \t  }\n \n-\tcase OMP_CLAUSE_ALIGNED:\n \tcase OMP_CLAUSE_LINEAR:\n+\t  WALK_SUBTREE (OMP_CLAUSE_DECL (*tp));\n+\t  WALK_SUBTREE (OMP_CLAUSE_LINEAR_STEP (*tp));\n+\t  WALK_SUBTREE (OMP_CLAUSE_LINEAR_STMT (*tp));\n+\t  WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));\n+\n+\tcase OMP_CLAUSE_ALIGNED:\n \tcase OMP_CLAUSE_FROM:\n \tcase OMP_CLAUSE_TO:\n \tcase OMP_CLAUSE_MAP:"}, {"sha": "14bbeb13618d64fc8c6b119da8d2ea4c8708170c", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -1333,6 +1333,9 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_CLAUSE_LINEAR_STEP(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR), 1)\n \n+#define OMP_CLAUSE_LINEAR_STMT(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR), 2)\n+\n #define OMP_CLAUSE_LINEAR_GIMPLE_SEQ(NODE) \\\n   (OMP_CLAUSE_CHECK (NODE))->omp_clause.gimple_reduction_init\n "}, {"sha": "769deca9c0509b8c6042fdb643d5c64225f71d1f", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -1,3 +1,23 @@\n+2014-05-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/cancel-do-1.f90: New test.\n+\t* testsuite/libgomp.fortran/cancel-do-2.f90: New test.\n+\t* testsuite/libgomp.fortran/cancel-parallel-1.f90: New test.\n+\t* testsuite/libgomp.fortran/cancel-parallel-3.f90: New test.\n+\t* testsuite/libgomp.fortran/cancel-sections-1.f90: New test.\n+\t* testsuite/libgomp.fortran/cancel-taskgroup-2.f90: New test.\n+\t* testsuite/libgomp.fortran/declare-simd-1.f90: New test.\n+\t* testsuite/libgomp.fortran/declare-simd-2.f90: New test.\n+\t* testsuite/libgomp.fortran/declare-simd-3.f90: New test.\n+\t* testsuite/libgomp.fortran/depend-1.f90: New test.\n+\t* testsuite/libgomp.fortran/depend-2.f90: New test.\n+\t* testsuite/libgomp.fortran/omp_atomic5.f90: New test.\n+\t* testsuite/libgomp.fortran/simd1.f90: New test.\n+\t* testsuite/libgomp.fortran/simd2.f90: New test.\n+\t* testsuite/libgomp.fortran/simd3.f90: New test.\n+\t* testsuite/libgomp.fortran/simd4.f90: New test.\n+\t* testsuite/libgomp.fortran/taskgroup1.f90: New test.\n+\n 2014-05-02  Jakub Jelinek  <jakub@redhat.com>\n \n \t* testsuite/libgomp.c/simd-10.c: New test."}, {"sha": "61713c4dd947c6e78880cc7a2189e2cc5d58fb85", "filename": "libgomp/testsuite/libgomp.fortran/cancel-do-1.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcancel-do-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcancel-do-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcancel-do-1.f90?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do run }\n+! { dg-set-target-env-var OMP_CANCELLATION \"true\" }\n+\n+  use omp_lib\n+  integer :: i\n+\n+  !$omp parallel num_threads(32)\n+    !$omp do\n+      do i = 0, 999\n+\t!$omp cancel do\n+\tif (omp_get_cancellation ()) call abort\n+      enddo\n+  !$omp endparallel\n+end"}, {"sha": "c748800cad5523fd30174df3f31999a1cc20c190", "filename": "libgomp/testsuite/libgomp.fortran/cancel-do-2.f90", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcancel-do-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcancel-do-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcancel-do-2.f90?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -0,0 +1,90 @@\n+! { dg-do run }\n+! { dg-options \"-fno-inline -fno-ipa-sra -fno-ipa-cp -fno-ipa-cp-clone\" }\n+! { dg-set-target-env-var OMP_CANCELLATION \"true\" }\n+\n+  use omp_lib\n+  integer :: i\n+  logical :: x(5)\n+\n+  x(:) = .false.\n+  x(1) = .true.\n+  x(3) = .true.\n+  if (omp_get_cancellation ()) call foo (x)\n+contains\n+  subroutine foo (x)\n+    use omp_lib\n+    logical :: x(5)\n+    integer :: v, w, i\n+\n+    v = 0\n+    w = 0\n+    !$omp parallel num_threads (32) shared (v, w)\n+      !$omp do\n+\tdo i = 0, 999\n+\t  !$omp cancel do if (x(1))\n+\t  call abort\n+\tend do\n+      !$omp do\n+\tdo i = 0, 999\n+\t  !$omp cancel do if (x(2))\n+\t  !$omp atomic\n+\t    v = v + 1\n+\t  !$omp endatomic\n+\tenddo\n+      !$omp do\n+\tdo i = 0, 999\n+\t  !$omp cancel do if (x(3))\n+\t  !$omp atomic\n+\t    w = w + 8\n+\t  !$omp end atomic\n+\tend do\n+      !$omp do\n+\tdo i = 0, 999\n+\t  !$omp cancel do if (x(4))\n+\t  !$omp atomic\n+\t    v = v + 2\n+\t  !$omp end atomic\n+\tend do\n+      !$omp end do\n+    !$omp end parallel\n+    if (v.ne.3000.or.w.ne.0) call abort\n+    !$omp parallel num_threads (32) shared (v, w)\n+      ! None of these cancel directives should actually cancel anything,\n+      ! but the compiler shouldn't know that and thus should use cancellable\n+      ! barriers at the end of all the workshares.\n+      !$omp cancel parallel if (omp_get_thread_num ().eq.1.and.x(5))\n+      !$omp do\n+\tdo i = 0, 999\n+\t  !$omp cancel do if (x(1))\n+\t  call abort\n+\tend do\n+      !$omp cancel parallel if (omp_get_thread_num ().eq.2.and.x(5))\n+      !$omp do\n+\tdo i = 0, 999\n+\t  !$omp cancel do if (x(2))\n+\t  !$omp atomic\n+\t    v = v + 1\n+\t  !$omp endatomic\n+\tenddo\n+      !$omp cancel parallel if (omp_get_thread_num ().eq.3.and.x(5))\n+      !$omp do\n+\tdo i = 0, 999\n+\t  !$omp cancel do if (x(3))\n+\t  !$omp atomic\n+\t    w = w + 8\n+\t  !$omp end atomic\n+\tend do\n+      !$omp cancel parallel if (omp_get_thread_num ().eq.4.and.x(5))\n+      !$omp do\n+\tdo i = 0, 999\n+\t  !$omp cancel do if (x(4))\n+\t  !$omp atomic\n+\t    v = v + 2\n+\t  !$omp end atomic\n+\tend do\n+      !$omp end do\n+      !$omp cancel parallel if (omp_get_thread_num ().eq.5.and.x(5))\n+    !$omp end parallel\n+    if (v.ne.6000.or.w.ne.0) call abort\n+  end subroutine\n+end"}, {"sha": "7d91ff5c1694da963c75c7c18c920b5fa9c26609", "filename": "libgomp/testsuite/libgomp.fortran/cancel-parallel-1.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcancel-parallel-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcancel-parallel-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcancel-parallel-1.f90?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do run }\n+! { dg-set-target-env-var OMP_CANCELLATION \"true\" }\n+\n+  use omp_lib\n+\n+  !$omp parallel num_threads(32)\n+    !$omp cancel parallel\n+    if (omp_get_cancellation ()) call abort\n+  !$omp end parallel\n+end"}, {"sha": "9d5ba8ffa388aaa4e1b6fad0497d27ac651c88b7", "filename": "libgomp/testsuite/libgomp.fortran/cancel-parallel-3.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcancel-parallel-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcancel-parallel-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcancel-parallel-3.f90?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do run }\n+! { dg-options \"-fno-inline -fno-ipa-sra -fno-ipa-cp -fno-ipa-cp-clone\" }\n+! { dg-set-target-env-var OMP_CANCELLATION \"true\" }\n+\n+  use omp_lib\n+  integer :: x, i, j\n+  common /x/ x\n+\n+  call omp_set_dynamic (.false.)\n+  call omp_set_schedule (omp_sched_static, 1)\n+  !$omp parallel num_threads(16) private (i, j)\n+    call do_some_work\n+    !$omp barrier\n+    if (omp_get_thread_num ().eq.1) then\n+      call sleep (2)\n+      !$omp cancellation point parallel\n+    end if\n+    do j = 3, 16\n+      !$omp do schedule(runtime)\n+\tdo i = 0, j - 1\n+\t  call do_some_work\n+\tend do\n+      !$omp enddo nowait\n+    end do\n+    if (omp_get_thread_num ().eq.0) then\n+      call sleep (1)\n+      !$omp cancel parallel\n+    end if\n+  !$omp end parallel\n+contains\n+  subroutine do_some_work\n+    integer :: x\n+    common /x/ x\n+    !$omp atomic\n+      x = x + 1\n+    !$omp end atomic\n+  endsubroutine do_some_work\n+end"}, {"sha": "9ba8af84679e6662899acefb209e859fa1a7784e", "filename": "libgomp/testsuite/libgomp.fortran/cancel-sections-1.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcancel-sections-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcancel-sections-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcancel-sections-1.f90?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do run }\n+! { dg-set-target-env-var OMP_CANCELLATION \"true\" }\n+\n+  use omp_lib\n+\n+  if (omp_get_cancellation ()) then\n+    !$omp parallel num_threads(32)\n+      !$omp sections\n+\t  !$omp cancel sections\n+\t  call abort\n+\t!$omp section\n+\t  !$omp cancel sections\n+\t  call abort\n+\t!$omp section\n+\t  !$omp cancel sections\n+\t  call abort\n+\t!$omp section\n+\t  !$omp cancel sections\n+\t  call abort\n+      !$omp end sections\n+    !$omp end parallel\n+  end if\n+end"}, {"sha": "c727a20ae41d7de9bdaedab5c0e2daf89420c9c6", "filename": "libgomp/testsuite/libgomp.fortran/cancel-taskgroup-2.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcancel-taskgroup-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcancel-taskgroup-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcancel-taskgroup-2.f90?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do run }\n+! { dg-set-target-env-var OMP_CANCELLATION \"true\" }\n+\n+  use omp_lib\n+  integer :: i\n+\n+  !$omp parallel\n+    !$omp taskgroup\n+      !$omp task\n+\t!$omp cancel taskgroup\n+\tcall abort\n+      !$omp endtask\n+    !$omp endtaskgroup\n+  !$omp endparallel\n+  !$omp parallel private (i)\n+    !$omp barrier\n+    !$omp single\n+      !$omp taskgroup\n+\tdo i = 0, 49\n+\t  !$omp task\n+\t    !$omp cancellation point taskgroup\n+\t    !$omp cancel taskgroup if (i.gt.5)\n+\t  !$omp end task\n+\tend do\n+      !$omp end taskgroup\n+    !$omp endsingle\n+  !$omp end parallel\n+end"}, {"sha": "ac591814538f93be985a75188179c47522036674", "filename": "libgomp/testsuite/libgomp.fortran/declare-simd-1.f90", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdeclare-simd-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdeclare-simd-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdeclare-simd-1.f90?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -0,0 +1,92 @@\n+! { dg-options \"-fno-inline\" }\n+! { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+! { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+module declare_simd_1_mod\n+  contains\n+    real function foo (a, b, c)\n+      !$omp declare simd (foo) simdlen (4) uniform (a) linear (b : 5)\n+      double precision, value :: a\n+      real, value :: c\n+      !$omp declare simd (foo)\n+      integer, value :: b\n+      foo = a + b * c\n+    end function foo\n+end module declare_simd_1_mod\n+  use declare_simd_1_mod\n+  interface\n+    function bar (a, b, c)\n+      !$omp declare simd (bar)\n+      integer, value :: b\n+      real, value :: c\n+      real :: bar\n+      !$omp declare simd (bar) simdlen (4) linear (b : 2)\n+      double precision, value :: a\n+    end function bar\n+  end interface\n+  integer :: i\n+  double precision :: a(128)\n+  real :: b(128), d(128)\n+  data d /171., 414., 745., 1164., 1671., 2266., 2949., 3720., 4579., &\n+  &       5526., 6561., 7684., 8895., 10194., 11581., 13056., 14619., &\n+  &       16270., 18009., 19836., 21751., 23754., 25845., 28024., &\n+  &       30291., 32646., 35089., 37620., 40239., 42946., 45741., &\n+  &       48624., 51595., 54654., 57801., 61036., 64359., 67770., &\n+  &       71269., 74856., 78531., 82294., 86145., 90084., 94111., &\n+  &       98226., 102429., 106720., 111099., 115566., 120121., 124764., &\n+  &       129495., 134314., 139221., 144216., 149299., 154470., 159729., &\n+  &       165076., 170511., 176034., 181645., 187344., 193131., 199006., &\n+  &       204969., 211020., 217159., 223386., 229701., 236104., 242595., &\n+  &       249174., 255841., 262596., 269439., 276370., 283389., 290496., &\n+  &       297691., 304974., 312345., 319804., 327351., 334986., 342709., &\n+  &       350520., 358419., 366406., 374481., 382644., 390895., 399234., &\n+  &       407661., 416176., 424779., 433470., 442249., 451116., 460071., &\n+  &       469114., 478245., 487464., 496771., 506166., 515649., 525220., &\n+  &       534879., 544626., 554461., 564384., 574395., 584494., 594681., &\n+  &       604956., 615319., 625770., 636309., 646936., 657651., 668454., &\n+  &       679345., 690324., 701391., 712546., 723789., 735120./\n+  !$omp simd\n+  do i = 1, 128\n+    a(i) = 7.0 * i + 16.0\n+    b(i) = 5.0 * i + 12.0\n+  end do\n+  !$omp simd\n+  do i = 1, 128\n+    b(i) = foo (a(i), 3, b(i))\n+  end do\n+  !$omp simd\n+  do i = 1, 128\n+    b(i) = bar (a(i), 2 * i, b(i))\n+  end do\n+  if (any (b.ne.d)) call abort\n+  !$omp simd\n+  do i = 1, 128\n+    b(i) = i * 2.0\n+  end do\n+  !$omp simd\n+  do i = 1, 128\n+    b(i) = baz (7.0_8, 2, b(i))\n+  end do\n+  do i = 1, 128\n+    if (b(i).ne.(7.0 + 4.0 * i)) call abort\n+  end do\n+contains\n+  function baz (x, y, z)\n+    !$omp declare simd (baz) simdlen (8) uniform (x, y)\n+    !$omp declare simd (baz)\n+    integer, value :: y\n+    real, value :: z\n+    real :: baz\n+    double precision, value :: x\n+    baz = x + y * z\n+  end function baz\n+end\n+function bar (a, b, c)\n+  integer, value :: b\n+  real, value :: c\n+  real :: bar\n+  double precision, value :: a\n+  !$omp declare simd (bar)\n+  !$omp declare simd (bar) simdlen (4) linear (b : 2)\n+  bar = a + b * c\n+end function bar"}, {"sha": "bb287d95d672b79a9cbc7c892b99f9de467637f7", "filename": "libgomp/testsuite/libgomp.fortran/declare-simd-2.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdeclare-simd-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdeclare-simd-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdeclare-simd-2.f90?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do run }\n+! { dg-options \"-fno-inline\" }\n+  ! { dg-additional-sources declare-simd-3.f90 }\n+! { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+! { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+module declare_simd_2_mod\n+  contains\n+    real function foo (a, b, c)\n+      !$omp declare simd (foo) simdlen (4) uniform (a) linear (b : 5)\n+      double precision, value :: a\n+      real, value :: c\n+      !$omp declare simd (foo)\n+      integer, value :: b\n+      foo = a + b * c\n+    end function foo\n+end module declare_simd_2_mod\n+\n+  interface\n+    subroutine bar ()\n+    end subroutine bar\n+  end interface\n+\n+  call bar ()\n+end"}, {"sha": "031625ec43514e2ec996bdb26000266427c0fe97", "filename": "libgomp/testsuite/libgomp.fortran/declare-simd-3.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdeclare-simd-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdeclare-simd-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdeclare-simd-3.f90?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -0,0 +1,22 @@\n+! Don't compile this anywhere, it is just auxiliary\n+! file compiled together with declare-simd-2.f90\n+! to verify inter-CU module handling of omp declare simd.\n+! { dg-do compile { target { lp64 && { ! lp64 } } } }\n+\n+subroutine bar\n+  use declare_simd_2_mod\n+  real :: b(128)\n+  integer :: i\n+\n+  !$omp simd\n+  do i = 1, 128\n+    b(i) = i * 2.0\n+  end do\n+  !$omp simd\n+  do i = 1, 128\n+    b(i) = foo (7.0_8, 5 * i, b(i))\n+  end do\n+  do i = 1, 128\n+    if (b(i).ne.(7.0 + 10.0 * i * i)) call abort\n+  end do\n+end subroutine bar"}, {"sha": "030d3fb6a552e13b6de396499f1e03ea4b48d7c4", "filename": "libgomp/testsuite/libgomp.fortran/depend-1.f90", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdepend-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdepend-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdepend-1.f90?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -0,0 +1,203 @@\n+! { dg-do run }\n+\n+  call dep ()\n+  call dep2 ()\n+  call dep3 ()\n+  call firstpriv ()\n+  call antidep ()\n+  call antidep2 ()\n+  call antidep3 ()\n+  call outdep ()\n+  call concurrent ()\n+  call concurrent2 ()\n+  call concurrent3 ()\n+contains\n+  subroutine dep\n+    integer :: x\n+    x = 1\n+    !$omp parallel\n+      !$omp single\n+        !$omp task shared (x) depend(out: x)\n+          x = 2\n+        !$omp end task\n+        !$omp task shared (x) depend(in: x)\n+          if (x.ne.2) call abort\n+        !$omp end task\n+      !$omp end single\n+    !$omp end parallel\n+  end subroutine dep\n+\n+  subroutine dep2\n+    integer :: x\n+    !$omp parallel\n+      !$omp single private (x)\n+        x = 1\n+        !$omp task shared (x) depend(out: x)\n+          x = 2\n+        !$omp end task\n+        !$omp task shared (x) depend(in: x)\n+          if (x.ne.2) call abort\n+        !$omp end task\n+        !$omp taskwait\n+      !$omp end single\n+    !$omp end parallel\n+  end subroutine dep2\n+\n+  subroutine dep3\n+    integer :: x\n+    !$omp parallel private (x)\n+      x = 1\n+      !$omp single\n+        !$omp task shared (x) depend(out: x)\n+          x = 2\n+        !$omp endtask\n+        !$omp task shared (x) depend(in: x)\n+          if (x.ne.2) call abort\n+        !$omp endtask\n+      !$omp endsingle\n+    !$omp endparallel\n+  end subroutine dep3\n+\n+  subroutine firstpriv\n+    integer :: x\n+    !$omp parallel private (x)\n+      !$omp single\n+        x = 1\n+        !$omp task depend(out: x)\n+          x = 2\n+        !$omp end task\n+        !$omp task depend(in: x)\n+          if (x.ne.1) call abort\n+        !$omp end task\n+      !$omp end single\n+    !$omp end parallel\n+  end subroutine firstpriv\n+\n+  subroutine antidep\n+    integer :: x\n+    x = 1\n+    !$omp parallel\n+      !$omp single\n+        !$omp task shared(x) depend(in: x)\n+          if (x.ne.1) call abort\n+        !$omp end task\n+        !$omp task shared(x) depend(out: x)\n+          x = 2\n+        !$omp end task\n+      !$omp end single\n+    !$omp end parallel\n+  end subroutine antidep\n+\n+  subroutine antidep2\n+    integer :: x\n+    !$omp parallel private (x)\n+      !$omp single\n+        x = 1\n+        !$omp taskgroup\n+          !$omp task shared(x) depend(in: x)\n+            if (x.ne.1) call abort\n+          !$omp end task\n+          !$omp task shared(x) depend(out: x)\n+            x = 2\n+          !$omp end task\n+        !$omp end taskgroup\n+      !$omp end single\n+    !$omp end parallel\n+  end subroutine antidep2\n+\n+  subroutine antidep3\n+    integer :: x\n+    !$omp parallel\n+      x = 1\n+      !$omp single\n+        !$omp task shared(x) depend(in: x)\n+          if (x.ne.1) call abort\n+        !$omp end task\n+        !$omp task shared(x) depend(out: x)\n+          x = 2\n+        !$omp end task\n+      !$omp end single\n+    !$omp end parallel\n+  end subroutine antidep3\n+\n+  subroutine outdep\n+    integer :: x\n+    !$omp parallel private (x)\n+      !$omp single\n+        x = 0\n+        !$omp task shared(x) depend(out: x)\n+          x = 1\n+        !$omp end task\n+        !$omp task shared(x) depend(out: x)\n+          x = 2\n+        !$omp end task\n+        !$omp taskwait\n+        if (x.ne.2) call abort\n+      !$omp end single\n+    !$omp end parallel\n+  end subroutine outdep\n+\n+  subroutine concurrent\n+    integer :: x\n+    x = 1\n+    !$omp parallel\n+      !$omp single\n+        !$omp task shared (x) depend(out: x)\n+          x = 2\n+        !$omp end task\n+        !$omp task shared (x) depend(in: x)\n+          if (x.ne.2) call abort\n+        !$omp end task\n+        !$omp task shared (x) depend(in: x)\n+          if (x.ne.2) call abort\n+        !$omp end task\n+        !$omp task shared (x) depend(in: x)\n+          if (x.ne.2) call abort\n+        !$omp end task\n+      !$omp end single\n+    !$omp end parallel\n+  end subroutine concurrent\n+\n+  subroutine concurrent2\n+    integer :: x\n+    !$omp parallel private (x)\n+      !$omp single\n+        x = 1\n+        !$omp task shared (x) depend(out: x)\n+          x = 2;\n+        !$omp end task\n+        !$omp task shared (x) depend(in: x)\n+          if (x.ne.2) call abort\n+        !$omp end task\n+        !$omp task shared (x) depend(in: x)\n+          if (x.ne.2) call abort\n+        !$omp end task\n+        !$omp task shared (x) depend(in: x)\n+          if (x.ne.2) call abort\n+        !$omp end task\n+        !$omp taskwait\n+      !$omp end single\n+    !$omp end parallel\n+  end subroutine concurrent2\n+\n+  subroutine concurrent3\n+    integer :: x\n+    !$omp parallel private (x)\n+      x = 1\n+      !$omp single\n+        !$omp task shared (x) depend(out: x)\n+          x = 2\n+        !$omp end task\n+        !$omp task shared (x) depend(in: x)\n+          if (x.ne.2) call abort\n+        !$omp end task\n+        !$omp task shared (x) depend(in: x)\n+          if (x.ne.2) call abort\n+        !$omp end task\n+        !$omp task shared (x) depend(in: x)\n+          if (x.ne.2) call abort\n+        !$omp end task\n+      !$omp end single\n+    !$omp end parallel\n+  end subroutine concurrent3\n+end"}, {"sha": "0694ce742063c1f243e0ce8a0b43658c0745a34c", "filename": "libgomp/testsuite/libgomp.fortran/depend-2.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdepend-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdepend-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdepend-2.f90?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do run }\n+\n+  integer :: x(3:6, 7:12), y\n+  y = 1\n+  !$omp parallel shared (x, y)\n+    !$omp single\n+      !$omp taskgroup\n+        !$omp task depend(in: x(:, :))\n+\t  if (y.ne.1) call abort\n+        !$omp end task\n+        !$omp task depend(out: x(:, :))\n+\t  y = 2\n+        !$omp end task\n+      !$omp end taskgroup\n+      !$omp taskgroup\n+        !$omp task depend(in: x(4, 7))\n+\t  if (y.ne.2) call abort\n+        !$omp end task\n+        !$omp task depend(out: x(4:4, 7:7))\n+\t  y = 3\n+        !$omp end task\n+      !$omp end taskgroup\n+      !$omp taskgroup\n+        !$omp task depend(in: x(4:, 8:))\n+\t  if (y.ne.3) call abort\n+        !$omp end task\n+        !$omp task depend(out: x(4:6, 8:12))\n+\t  y = 4\n+        !$omp end task\n+      !$omp end taskgroup\n+    !$omp end single\n+  !$omp end parallel\n+  if (y.ne.4) call abort\n+end"}, {"sha": "8e0641592fd1a26118ec31536bd0fff3a5d97909", "filename": "libgomp/testsuite/libgomp.fortran/omp_atomic5.f90", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_atomic5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_atomic5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_atomic5.f90?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -0,0 +1,59 @@\n+! { dg-do run }\n+    integer (kind = 4) :: a, a2\n+    integer (kind = 2) :: b, b2\n+    real :: c\n+    double precision :: d, d2, c2\n+    integer, dimension (10) :: e\n+    e(:) = 5\n+    e(7) = 9\n+!$omp atomic write seq_cst\n+    a = 1\n+!$omp atomic seq_cst, write\n+    b = 2\n+!$omp atomic write, seq_cst\n+    c = 3\n+!$omp atomic seq_cst write\n+    d = 4\n+!$omp atomic capture seq_cst\n+    a2 = a\n+    a = a + 4\n+!$omp end atomic\n+!$omp atomic capture, seq_cst\n+    b = b - 18\n+    b2 = b\n+!$omp end atomic\n+!$omp atomic seq_cst, capture\n+    c2 = c\n+    c = 2.0 * c\n+!$omp end atomic\n+!$omp atomic seq_cst capture\n+    d = d / 2.0\n+    d2 = d\n+!$omp end atomic\n+    if (a2 .ne. 1 .or. b2 .ne. -16 .or. c2 .ne. 3 .or. d2 .ne. 2) call abort\n+!$omp atomic read seq_cst\n+    a2 = a\n+!$omp atomic seq_cst, read\n+    c2 = c\n+    if (a2 .ne. 5 .or. b2 .ne. -16 .or. c2 .ne. 6 .or. d2 .ne. 2) call abort\n+    a2 = 10\n+    if (a2 .ne. 10) call abort\n+!$omp atomic capture\n+    a2 = a\n+    a = e(1) + e(6) + e(7) * 2\n+!$omp endatomic\n+    if (a2 .ne. 5) call abort\n+!$omp atomic read\n+    a2 = a\n+!$omp end atomic\n+    if (a2 .ne. 28) call abort\n+!$omp atomic capture seq_cst\n+    b2 = b\n+    b = e(1) + e(7) + e(5) * 2\n+!$omp end atomic\n+    if (b2 .ne. -16) call abort\n+!$omp atomic seq_cst, read\n+    b2 = b\n+!$omp end atomic\n+    if (b2 .ne. 24) call abort\n+end"}, {"sha": "abd63b0643fa55e767fd4b15c562f3cfc9da1439", "filename": "libgomp/testsuite/libgomp.fortran/simd1.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd1.f90?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do run }\n+! { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+! { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+  integer :: i, j, k, l, r, a(30)\n+  integer, target :: q(30)\n+  integer, pointer :: p(:)\n+  a(:) = 1\n+  q(:) = 1\n+  p => q\n+  r = 0\n+  j = 10\n+  k = 20\n+  !$omp simd safelen (8) reduction(+:r) linear(j, k : 2) &\n+  !$omp& private (l) aligned(p : 4)\n+  do i = 1, 30\n+    l = j + k + a(i) + p(i)\n+    r = r + l\n+    j = j + 2\n+    k = k + 2\n+  end do\n+  if (r.ne.2700.or.j.ne.70.or.k.ne.80) call abort\n+end"}, {"sha": "9b90bcdd019bccc96b02c50a1f1d9df2af2593e9", "filename": "libgomp/testsuite/libgomp.fortran/simd2.f90", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd2.f90?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -0,0 +1,101 @@\n+! { dg-do run }\n+! { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+! { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+  integer :: a(1024), b(1024), k, m, i, s, t\n+  k = 4\n+  m = 2\n+  t = 1\n+  do i = 1, 1024\n+    a(i) = i - 513\n+    b(i) = modulo (i - 52, 39)\n+    if (i.lt.52.and.b(i).ne.0) b(i) = b(i) - 39\n+  end do\n+  s = foo (b)\n+  do i = 1, 1024\n+    if (a(i).ne.((i - 513) * b(i))) call abort\n+    if (i.lt.52.and.modulo (i - 52, 39).ne.0) then\n+      if (b(i).ne.(modulo (i - 52, 39) - 39)) call abort\n+    else\n+      if (b(i).ne.(modulo (i - 52, 39))) call abort\n+    end if\n+    a(i) = i - 513\n+  end do\n+  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) call abort\n+  k = 4\n+  m = 2\n+  t = 1\n+  s = bar (b)\n+  do i = 1, 1024\n+    if (a(i).ne.((i - 513) * b(i))) call abort\n+    if (i.lt.52.and.modulo (i - 52, 39).ne.0) then\n+      if (b(i).ne.(modulo (i - 52, 39) - 39)) call abort\n+    else\n+      if (b(i).ne.(modulo (i - 52, 39))) call abort\n+    end if\n+    a(i) = i - 513\n+  end do\n+  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) call abort\n+  k = 4\n+  m = 2\n+  t = 1\n+  s = baz (b)\n+  do i = 1, 1024\n+    if (a(i).ne.((i - 513) * b(i))) call abort\n+    if (i.lt.52.and.modulo (i - 52, 39).ne.0) then\n+      if (b(i).ne.(modulo (i - 52, 39) - 39)) call abort\n+    else\n+      if (b(i).ne.(modulo (i - 52, 39))) call abort\n+    end if\n+  end do\n+  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) call abort\n+contains\n+  function foo (p)\n+    integer :: p(1024), u, v, i, s, foo\n+    s = 0\n+    !$omp simd linear(k : m + 1) reduction(+: s) lastprivate(u, v)\n+    do i = 1, 1024\n+      a(i) = a(i) * p(i)\n+      u = p(i) + k\n+      k = k + m + 1\n+      v = p(i) + k\n+      s = s + p(i) + k\n+    end do\n+    !$omp end simd\n+    if (i.ne.1025) call abort\n+    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) call abort\n+    foo = s\n+  end function foo\n+  function bar (p)\n+    integer :: p(1024), u, v, i, s, bar\n+    s = 0\n+    !$omp simd linear(k : m + 1) reduction(+: s) lastprivate(u, v)\n+    do i = 1, 1024, t\n+      a(i) = a(i) * p(i)\n+      u = p(i) + k\n+      k = k + m + 1\n+      v = p(i) + k\n+      s = s + p(i) + k\n+    end do\n+    !$omp end simd\n+    if (i.ne.1025) call abort\n+    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) call abort\n+    bar = s\n+  end function bar\n+  function baz (p)\n+    integer :: p(1024), u, v, i, s, baz\n+    s = 0\n+    !$omp simd linear(k : m + 1) reduction(+: s) lastprivate(u, v) &\n+    !$omp & linear(i : t)\n+    do i = 1, 1024, t\n+      a(i) = a(i) * p(i)\n+      u = p(i) + k\n+      k = k + m + 1\n+      v = p(i) + k\n+      s = s + p(i) + k\n+    end do\n+    if (i.ne.1025) call abort\n+    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) call abort\n+    baz = s\n+  end function baz\n+end"}, {"sha": "df9f4cac3fef42de2a38053e8a36f0f1846eabef", "filename": "libgomp/testsuite/libgomp.fortran/simd3.f90", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd3.f90?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -0,0 +1,109 @@\n+! { dg-do run }\n+! { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+! { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+  integer :: a(1024), b(1024), k, m, i, s, t\n+  k = 4\n+  m = 2\n+  t = 1\n+  do i = 1, 1024\n+    a(i) = i - 513\n+    b(i) = modulo (i - 52, 39)\n+    if (i.lt.52.and.b(i).ne.0) b(i) = b(i) - 39\n+  end do\n+  s = foo (b)\n+  do i = 1, 1024\n+    if (a(i).ne.((i - 513) * b(i))) call abort\n+    if (i.lt.52.and.modulo (i - 52, 39).ne.0) then\n+      if (b(i).ne.(modulo (i - 52, 39) - 39)) call abort\n+    else\n+      if (b(i).ne.(modulo (i - 52, 39))) call abort\n+    end if\n+    a(i) = i - 513\n+  end do\n+  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) call abort\n+  k = 4\n+  m = 2\n+  t = 1\n+  s = bar (b)\n+  do i = 1, 1024\n+    if (a(i).ne.((i - 513) * b(i))) call abort\n+    if (i.lt.52.and.modulo (i - 52, 39).ne.0) then\n+      if (b(i).ne.(modulo (i - 52, 39) - 39)) call abort\n+    else\n+      if (b(i).ne.(modulo (i - 52, 39))) call abort\n+    end if\n+    a(i) = i - 513\n+  end do\n+  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) call abort\n+  k = 4\n+  m = 2\n+  t = 1\n+  s = baz (b)\n+  do i = 1, 1024\n+    if (a(i).ne.((i - 513) * b(i))) call abort\n+    if (i.lt.52.and.modulo (i - 52, 39).ne.0) then\n+      if (b(i).ne.(modulo (i - 52, 39) - 39)) call abort\n+    else\n+      if (b(i).ne.(modulo (i - 52, 39))) call abort\n+    end if\n+  end do\n+  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) call abort\n+contains\n+  function foo (p)\n+    integer :: p(1024), u, v, i, s, foo\n+    s = 0\n+    !$omp parallel\n+    !$omp do simd linear(k : m + 1) reduction(+: s) lastprivate(u, v) &\n+    !$omp & schedule (static, 32)\n+    do i = 1, 1024\n+      a(i) = a(i) * p(i)\n+      u = p(i) + k\n+      k = k + m + 1\n+      v = p(i) + k\n+      s = s + p(i) + k\n+    end do\n+    !$omp end do simd\n+    !$omp end parallel\n+    if (i.ne.1025) call abort\n+    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) call abort\n+    foo = s\n+  end function foo\n+  function bar (p)\n+    integer :: p(1024), u, v, i, s, bar\n+    s = 0\n+    !$omp parallel\n+    !$omp do simd linear(k : m + 1) reduction(+: s) lastprivate(u, v) &\n+    !$omp & schedule (dynamic, 32)\n+    do i = 1, 1024, t\n+      a(i) = a(i) * p(i)\n+      u = p(i) + k\n+      k = k + m + 1\n+      v = p(i) + k\n+      s = s + p(i) + k\n+    end do\n+    !$omp end do simd\n+    !$omp endparallel\n+    if (i.ne.1025) call abort\n+    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) call abort\n+    bar = s\n+  end function bar\n+  function baz (p)\n+    integer :: p(1024), u, v, i, s, baz\n+    s = 0\n+    !$omp parallel\n+    !$omp do simd linear(k : m + 1) reduction(+: s) lastprivate(u, v) &\n+    !$omp & linear(i : t) schedule (static, 8)\n+    do i = 1, 1024, t\n+      a(i) = a(i) * p(i)\n+      u = p(i) + k\n+      k = k + m + 1\n+      v = p(i) + k\n+      s = s + p(i) + k\n+    end do\n+    !$omp end parallel\n+    if (i.ne.1025) call abort\n+    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) call abort\n+    baz = s\n+  end function baz\n+end"}, {"sha": "a5b8ba0babdaed2dc361f9f22dc42d922c299232", "filename": "libgomp/testsuite/libgomp.fortran/simd4.f90", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd4.f90?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -0,0 +1,103 @@\n+! { dg-do run }\n+! { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+! { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+  integer :: a(1024), b(1024), k, m, i, s, t\n+  k = 4\n+  m = 2\n+  t = 1\n+  do i = 1, 1024\n+    a(i) = i - 513\n+    b(i) = modulo (i - 52, 39)\n+    if (i.lt.52.and.b(i).ne.0) b(i) = b(i) - 39\n+  end do\n+  s = foo (b)\n+  do i = 1, 1024\n+    if (a(i).ne.((i - 513) * b(i))) call abort\n+    if (i.lt.52.and.modulo (i - 52, 39).ne.0) then\n+      if (b(i).ne.(modulo (i - 52, 39) - 39)) call abort\n+    else\n+      if (b(i).ne.(modulo (i - 52, 39))) call abort\n+    end if\n+    a(i) = i - 513\n+  end do\n+  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) call abort\n+  k = 4\n+  m = 2\n+  t = 1\n+  s = bar (b)\n+  do i = 1, 1024\n+    if (a(i).ne.((i - 513) * b(i))) call abort\n+    if (i.lt.52.and.modulo (i - 52, 39).ne.0) then\n+      if (b(i).ne.(modulo (i - 52, 39) - 39)) call abort\n+    else\n+      if (b(i).ne.(modulo (i - 52, 39))) call abort\n+    end if\n+    a(i) = i - 513\n+  end do\n+  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) call abort\n+  k = 4\n+  m = 2\n+  t = 1\n+  s = baz (b)\n+  do i = 1, 1024\n+    if (a(i).ne.((i - 513) * b(i))) call abort\n+    if (i.lt.52.and.modulo (i - 52, 39).ne.0) then\n+      if (b(i).ne.(modulo (i - 52, 39) - 39)) call abort\n+    else\n+      if (b(i).ne.(modulo (i - 52, 39))) call abort\n+    end if\n+  end do\n+  if (k.ne.(4 + 3 * 1024).or.s.ne.1596127) call abort\n+contains\n+  function foo (p)\n+    integer :: p(1024), u, v, i, s, foo\n+    s = 0\n+    !$omp parallel do simd linear(k : m + 1) reduction(+: s) &\n+    !$omp & lastprivate(u, v) schedule (static, 32)\n+    do i = 1, 1024\n+      a(i) = a(i) * p(i)\n+      u = p(i) + k\n+      k = k + m + 1\n+      v = p(i) + k\n+      s = s + p(i) + k\n+    end do\n+    !$omp end parallel do simd\n+    if (i.ne.1025) call abort\n+    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) call abort\n+    foo = s\n+  end function foo\n+  function bar (p)\n+    integer :: p(1024), u, v, i, s, bar\n+    s = 0\n+    !$omp parallel do simd linear(k : m + 1) reduction(+: s) &\n+    !$omp & lastprivate(u, v) schedule (dynamic, 32)\n+    do i = 1, 1024, t\n+      a(i) = a(i) * p(i)\n+      u = p(i) + k\n+      k = k + m + 1\n+      v = p(i) + k\n+      s = s + p(i) + k\n+    end do\n+    !$omp endparalleldosimd\n+    if (i.ne.1025) call abort\n+    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) call abort\n+    bar = s\n+  end function bar\n+  function baz (p)\n+    integer :: p(1024), u, v, i, s, baz\n+    s = 0\n+    !$omp parallel do simd linear(k : m + 1) reduction(+: s) &\n+    !$omp & lastprivate(u, v) linear(i : t) schedule (static, 8)\n+    do i = 1, 1024, t\n+      a(i) = a(i) * p(i)\n+      u = p(i) + k\n+      k = k + m + 1\n+      v = p(i) + k\n+      s = s + p(i) + k\n+    end do\n+    if (i.ne.1025) call abort\n+    if (u.ne.(36 + 4 + 3 * 1023).or.v.ne.(36 + 4 + 3 * 1024)) call abort\n+    baz = s\n+  end function baz\n+end"}, {"sha": "018d3e83b92df4e2d494fc56b82b2dd465493a4e", "filename": "libgomp/testsuite/libgomp.fortran/taskgroup1.f90", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftaskgroup1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2fc5256e440377a3883a793af98b95f6ace957/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftaskgroup1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftaskgroup1.f90?ref=dd2fc5256e440377a3883a793af98b95f6ace957", "patch": "@@ -0,0 +1,80 @@\n+  integer :: v(16), i\n+  do i = 1, 16\n+    v(i) = i\n+  end do\n+\n+  !$omp parallel num_threads (4)\n+    !$omp single\n+      !$omp taskgroup\n+\tdo i = 1, 16, 2\n+\t  !$omp task\n+\t    !$omp task\n+\t      v(i) = v(i) + 1\n+\t    !$omp end task\n+\t    !$omp task\n+\t      v(i + 1) = v(i + 1) + 1\n+\t    !$omp end task\n+\t  !$omp end task\n+\tend do\n+      !$omp end taskgroup\n+      do i = 1, 16\n+\tif (v(i).ne.(i + 1)) call abort\n+      end do\n+      !$omp taskgroup\n+\tdo i = 1, 16, 2\n+\t  !$omp task\n+\t    !$omp task\n+\t      v(i) = v(i) + 1\n+\t    !$omp endtask\n+\t    !$omp task\n+\t      v(i + 1) = v(i + 1) + 1\n+\t    !$omp endtask\n+\t    !$omp taskwait\n+\t  !$omp endtask\n+\tend do\n+      !$omp endtaskgroup\n+      do i = 1, 16\n+\tif (v(i).ne.(i + 2)) call abort\n+      end do\n+      !$omp taskgroup\n+\tdo i = 1, 16, 2\n+\t  !$omp task\n+\t    !$omp task\n+\t      v(i) = v(i) + 1\n+\t    !$omp end task\n+\t    v(i + 1) = v(i + 1) + 1\n+\t  !$omp end task\n+\tend do\n+\t!$omp taskwait\n+\tdo i = 1, 16, 2\n+\t  !$omp task\n+\t    v(i + 1) = v(i + 1) + 1\n+\t  !$omp end task\n+\tend do\n+      !$omp end taskgroup\n+      do i = 1, 16, 2\n+\tif (v(i).ne.(i + 3)) call abort\n+\tif (v(i + 1).ne.(i + 5)) call abort\n+      end do\n+      !$omp taskgroup\n+\tdo i = 1, 16, 2\n+\t  !$omp taskgroup\n+\t    !$omp task\n+\t      v(i) = v(i) + 1\n+\t    !$omp end task\n+\t    !$omp task\n+\t      v(i + 1) = v(i + 1) + 1\n+\t    !$omp end task\n+\t  !$omp end taskgroup\n+\t  if (v(i).ne.(i + 4).or.v(i + 1).ne.(i + 6)) call abort\n+\t  !$omp task\n+\t    v(i) = v(i) + 1\n+\t  !$omp end task\n+\tend do\n+      !$omp end taskgroup\n+      do i = 1, 16\n+\tif (v(i).ne.(i + 5)) call abort\n+      end do\n+    !$omp end single\n+  !$omp end parallel\n+end"}]}