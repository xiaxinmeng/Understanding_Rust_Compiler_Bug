{"sha": "f6d67708ca8d0efbeeb5742ef177db2e1a096278", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZkNjc3MDhjYThkMGVmYmVlYjU3NDJlZjE3N2RiMmUxYTA5NjI3OA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-05-16T23:23:58Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-05-16T23:23:58Z"}, "message": "compiler: add intrinsics for runtime/internal/sys functions\n    \n    runtime/internal/sys.Ctz32/64 and Bswap32/64 are currently\n    implemented with compiler builtin functions. But if they are\n    called from another package, the compiler does not know and\n    therefore cannot turn them into compiler intrinsics. This CL\n    makes the compiler recognize these functions and turn them into\n    intrinsics directly, as the gc compiler does.\n    \n    This CL sets up a way for adding intrinsics in the compiler.\n    More intrinsics will be added in later CLs.\n    \n    Also move the handling of runtime.getcallerpc/sp to the new way\n    of generating intrinsics.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/176917\n\nFrom-SVN: r271303", "tree": {"sha": "67a942ae567ef9f5abff55de4595f64d8be2b14d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67a942ae567ef9f5abff55de4595f64d8be2b14d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6d67708ca8d0efbeeb5742ef177db2e1a096278", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6d67708ca8d0efbeeb5742ef177db2e1a096278", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6d67708ca8d0efbeeb5742ef177db2e1a096278", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6d67708ca8d0efbeeb5742ef177db2e1a096278/comments", "author": null, "committer": null, "parents": [{"sha": "7110128236989c9f957b7345d5615e9df8a337f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7110128236989c9f957b7345d5615e9df8a337f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7110128236989c9f957b7345d5615e9df8a337f2"}], "stats": {"total": 258, "additions": 149, "deletions": 109}, "files": [{"sha": "c3da5bfce87705b60d2c0a582bef2dea5f22e187", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d67708ca8d0efbeeb5742ef177db2e1a096278/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d67708ca8d0efbeeb5742ef177db2e1a096278/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=f6d67708ca8d0efbeeb5742ef177db2e1a096278", "patch": "@@ -1,4 +1,4 @@\n-2df0879e7880057293c0a59be6868a3e6ea5105b\n+c0c8ad50627e3a59267e6e3de233a0b30cf64150\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "d162b05621177888c4d608f9580670e25f353038", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 116, "deletions": 61, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d67708ca8d0efbeeb5742ef177db2e1a096278/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d67708ca8d0efbeeb5742ef177db2e1a096278/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=f6d67708ca8d0efbeeb5742ef177db2e1a096278", "patch": "@@ -10252,42 +10252,6 @@ Call_expression::do_lower(Gogo* gogo, Named_object* function,\n \t\t\t\t\t\t  bme->location());\n     }\n \n-  // Handle a couple of special runtime functions.  In the runtime\n-  // package, getcallerpc returns the PC of the caller, and\n-  // getcallersp returns the frame pointer of the caller.  Implement\n-  // these by turning them into calls to GCC builtin functions.  We\n-  // could implement them in normal code, but then we would have to\n-  // explicitly unwind the stack.  These functions are intended to be\n-  // efficient.  Note that this technique obviously only works for\n-  // direct calls, but that is the only way they are used.\n-  if (gogo->compiling_runtime() && gogo->package_name() == \"runtime\")\n-    {\n-      Func_expression* fe = this->fn_->func_expression();\n-      if (fe != NULL\n-\t  && fe->named_object()->is_function_declaration()\n-\t  && fe->named_object()->package() == NULL)\n-\t{\n-\t  std::string n = Gogo::unpack_hidden_name(fe->named_object()->name());\n-\t  if ((this->args_ == NULL || this->args_->size() == 0)\n-\t      && n == \"getcallerpc\")\n-\t    {\n-\t      static Named_object* builtin_return_address;\n-              int arg = 0;\n-\t      return this->lower_to_builtin(&builtin_return_address,\n-\t\t\t\t\t    \"__builtin_return_address\",\n-\t\t\t\t\t    &arg);\n-\t    }\n-\t  else if ((this->args_ == NULL || this->args_->size() == 0)\n-\t\t   && n == \"getcallersp\")\n-\t    {\n-\t      static Named_object* builtin_dwarf_cfa;\n-\t      return this->lower_to_builtin(&builtin_dwarf_cfa,\n-\t\t\t\t\t    \"__builtin_dwarf_cfa\",\n-\t\t\t\t\t    NULL);\n-\t    }\n-\t}\n-    }\n-\n   // If this is a call to an imported function for which we have an\n   // inlinable function body, add it to the list of functions to give\n   // to the backend as inlining opportunities.\n@@ -10401,31 +10365,6 @@ Call_expression::lower_varargs(Gogo* gogo, Named_object* function,\n   this->varargs_are_lowered_ = true;\n }\n \n-// Return a call to __builtin_return_address or __builtin_dwarf_cfa.\n-\n-Expression*\n-Call_expression::lower_to_builtin(Named_object** pno, const char* name,\n-\t\t\t\t  int* arg)\n-{\n-  if (*pno == NULL)\n-    *pno = Gogo::declare_builtin_rf_address(name, arg != NULL);\n-\n-  Location loc = this->location();\n-\n-  Expression* fn = Expression::make_func_reference(*pno, NULL, loc);\n-  Expression_list *args = new Expression_list();\n-  if (arg != NULL)\n-    {\n-      Expression* a = Expression::make_integer_ul(*arg, NULL, loc);\n-      args->push_back(a);\n-    }\n-  Expression* call = Expression::make_call(fn, args, false, loc);\n-\n-  // The builtin functions return void*, but the Go functions return uintptr.\n-  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n-  return Expression::make_cast(uintptr_type, call, loc);\n-}\n-\n // Flatten a call with multiple results into a temporary.\n \n Expression*\n@@ -10491,9 +10430,125 @@ Call_expression::do_flatten(Gogo* gogo, Named_object*,\n       this->args_ = args;\n     }\n \n+  // Lower to compiler intrinsic if possible.\n+  Func_expression* fe = this->fn_->func_expression();\n+  if (fe != NULL\n+      && (fe->named_object()->is_function_declaration()\n+          || fe->named_object()->is_function()))\n+    {\n+      Expression* ret = this->intrinsify(gogo, inserter);\n+      if (ret != NULL)\n+        return ret;\n+    }\n+\n   return this;\n }\n \n+// Lower a call to a compiler intrinsic if possible.\n+// Returns NULL if it is not an intrinsic.\n+\n+Expression*\n+Call_expression::intrinsify(Gogo* gogo,\n+                            Statement_inserter* inserter)\n+{\n+  Func_expression* fe = this->fn_->func_expression();\n+  Named_object* no = fe->named_object();\n+  std::string name = Gogo::unpack_hidden_name(no->name());\n+  std::string package = (no->package() != NULL\n+                         ? no->package()->pkgpath()\n+                         : gogo->pkgpath());\n+  Location loc = this->location();\n+\n+  Type* int_type = Type::lookup_integer_type(\"int\");\n+  Type* uint32_type = Type::lookup_integer_type(\"uint32\");\n+  Type* uint64_type = Type::lookup_integer_type(\"uint64\");\n+  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+\n+  if (package == \"runtime\")\n+    {\n+      // Handle a couple of special runtime functions.  In the runtime\n+      // package, getcallerpc returns the PC of the caller, and\n+      // getcallersp returns the frame pointer of the caller.  Implement\n+      // these by turning them into calls to GCC builtin functions.  We\n+      // could implement them in normal code, but then we would have to\n+      // explicitly unwind the stack.  These functions are intended to be\n+      // efficient.  Note that this technique obviously only works for\n+      // direct calls, but that is the only way they are used.\n+      if (name == \"getcallerpc\"\n+          && (this->args_ == NULL || this->args_->size() == 0))\n+        {\n+          Expression* arg = Expression::make_integer_ul(0, uint32_type, loc);\n+          Expression* call =\n+            Runtime::make_call(Runtime::BUILTIN_RETURN_ADDRESS, loc,\n+                               1, arg);\n+          // The builtin functions return void*, but the Go functions return uintptr.\n+          return Expression::make_cast(uintptr_type, call, loc);\n+        }\n+      else if (name == \"getcallersp\"\n+               && (this->args_ == NULL || this->args_->size() == 0))\n+\n+        {\n+          Expression* call =\n+            Runtime::make_call(Runtime::BUILTIN_DWARF_CFA, loc, 0);\n+          // The builtin functions return void*, but the Go functions return uintptr.\n+          return Expression::make_cast(uintptr_type, call, loc);\n+        }\n+    }\n+  else if (package == \"runtime/internal/sys\")\n+    {\n+      if (name == \"Bswap32\"\n+          && this->args_ != NULL && this->args_->size() == 1)\n+        {\n+          Expression* arg = this->args_->front();\n+          return Runtime::make_call(Runtime::BUILTIN_BSWAP32, loc, 1, arg);\n+        }\n+      else if (name == \"Bswap64\"\n+               && this->args_ != NULL && this->args_->size() == 1)\n+        {\n+          Expression* arg = this->args_->front();\n+          return Runtime::make_call(Runtime::BUILTIN_BSWAP64, loc, 1, arg);\n+        }\n+      else if (name == \"Ctz32\"\n+               && this->args_ != NULL && this->args_->size() == 1)\n+        {\n+          Expression* arg = this->args_->front();\n+          if (!arg->is_variable())\n+            {\n+              Temporary_statement* ts = Statement::make_temporary(uint32_type, arg, loc);\n+              inserter->insert(ts);\n+              arg = Expression::make_temporary_reference(ts, loc);\n+            }\n+          // arg == 0 ? 32 : __builtin_ctz(arg)\n+          Expression* zero = Expression::make_integer_ul(0, uint32_type, loc);\n+          Expression* cmp = Expression::make_binary(OPERATOR_EQEQ, arg, zero, loc);\n+          Expression* c32 = Expression::make_integer_ul(32, int_type, loc);\n+          Expression* call = Runtime::make_call(Runtime::BUILTIN_CTZ, loc, 1, arg->copy());\n+          call = Expression::make_cast(int_type, call, loc);\n+          return Expression::make_conditional(cmp, c32, call, loc);\n+        }\n+      else if (name == \"Ctz64\"\n+               && this->args_ != NULL && this->args_->size() == 1)\n+        {\n+          Expression* arg = this->args_->front();\n+          if (!arg->is_variable())\n+            {\n+              Temporary_statement* ts = Statement::make_temporary(uint64_type, arg, loc);\n+              inserter->insert(ts);\n+              arg = Expression::make_temporary_reference(ts, loc);\n+            }\n+          // arg == 0 ? 64 : __builtin_ctzll(arg)\n+          Expression* zero = Expression::make_integer_ul(0, uint64_type, loc);\n+          Expression* cmp = Expression::make_binary(OPERATOR_EQEQ, arg, zero, loc);\n+          Expression* c64 = Expression::make_integer_ul(64, int_type, loc);\n+          Expression* call = Runtime::make_call(Runtime::BUILTIN_CTZLL, loc, 1, arg->copy());\n+          call = Expression::make_cast(int_type, call, loc);\n+          return Expression::make_conditional(cmp, c64, call, loc);\n+        }\n+    }\n+\n+  return NULL;\n+}\n+\n // Make implicit type conversions explicit.\n \n void"}, {"sha": "21a214db632226e6c447881ddedcd0d843966f31", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d67708ca8d0efbeeb5742ef177db2e1a096278/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d67708ca8d0efbeeb5742ef177db2e1a096278/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=f6d67708ca8d0efbeeb5742ef177db2e1a096278", "patch": "@@ -2427,7 +2427,7 @@ class Call_expression : public Expression\n   check_argument_type(int, const Type*, const Type*, Location, bool);\n \n   Expression*\n-  lower_to_builtin(Named_object**, const char*, int*);\n+  intrinsify(Gogo*, Statement_inserter*);\n \n   Expression*\n   interface_method_function(Interface_field_reference_expression*,"}, {"sha": "02120f2e1fdbca8e96a73474dad33fba7331db9e", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 4, "deletions": 41, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d67708ca8d0efbeeb5742ef177db2e1a096278/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d67708ca8d0efbeeb5742ef177db2e1a096278/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=f6d67708ca8d0efbeeb5742ef177db2e1a096278", "patch": "@@ -4566,11 +4566,6 @@ Build_recover_thunks::function(Named_object* orig_no)\n Expression*\n Build_recover_thunks::can_recover_arg(Location location)\n {\n-  static Named_object* builtin_return_address;\n-  if (builtin_return_address == NULL)\n-    builtin_return_address =\n-      Gogo::declare_builtin_rf_address(\"__builtin_return_address\", true);\n-\n   Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n   static Named_object* can_recover;\n   if (can_recover == NULL)\n@@ -4589,20 +4584,15 @@ Build_recover_thunks::can_recover_arg(Location location)\n       can_recover->func_declaration_value()->set_asm_name(\"runtime.canrecover\");\n     }\n \n-  Expression* fn = Expression::make_func_reference(builtin_return_address,\n-\t\t\t\t\t\t   NULL, location);\n-\n   Expression* zexpr = Expression::make_integer_ul(0, NULL, location);\n-  Expression_list *args = new Expression_list();\n-  args->push_back(zexpr);\n-\n-  Expression* call = Expression::make_call(fn, args, false, location);\n+  Expression* call = Runtime::make_call(Runtime::BUILTIN_RETURN_ADDRESS,\n+                                        location, 1, zexpr);\n   call = Expression::make_unsafe_cast(uintptr_type, call, location);\n \n-  args = new Expression_list();\n+  Expression_list* args = new Expression_list();\n   args->push_back(call);\n \n-  fn = Expression::make_func_reference(can_recover, NULL, location);\n+  Expression* fn = Expression::make_func_reference(can_recover, NULL, location);\n   return Expression::make_call(fn, args, false, location);\n }\n \n@@ -4622,33 +4612,6 @@ Gogo::build_recover_thunks()\n   this->traverse(&build_recover_thunks);\n }\n \n-// Return a declaration for __builtin_return_address or\n-// __builtin_dwarf_cfa.\n-\n-Named_object*\n-Gogo::declare_builtin_rf_address(const char* name, bool hasarg)\n-{\n-  const Location bloc = Linemap::predeclared_location();\n-\n-  Typed_identifier_list* param_types = new Typed_identifier_list();\n-  if (hasarg)\n-    {\n-      Type* uint32_type = Type::lookup_integer_type(\"uint32\");\n-      param_types->push_back(Typed_identifier(\"l\", uint32_type, bloc));\n-    }\n-\n-  Typed_identifier_list* return_types = new Typed_identifier_list();\n-  Type* voidptr_type = Type::make_pointer_type(Type::make_void_type());\n-  return_types->push_back(Typed_identifier(\"\", voidptr_type, bloc));\n-\n-  Function_type* fntype = Type::make_function_type(NULL, param_types,\n-\t\t\t\t\t\t   return_types, bloc);\n-  Named_object* ret = Named_object::make_function_declaration(name, NULL,\n-\t\t\t\t\t\t\t      fntype, bloc);\n-  ret->func_declaration_value()->set_asm_name(name);\n-  return ret;\n-}\n-\n // Build a call to the runtime error function.\n \n Expression*"}, {"sha": "e67a8a5db6c24e83964ebd4a2cf2720da86432aa", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d67708ca8d0efbeeb5742ef177db2e1a096278/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d67708ca8d0efbeeb5742ef177db2e1a096278/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=f6d67708ca8d0efbeeb5742ef177db2e1a096278", "patch": "@@ -764,11 +764,6 @@ class Gogo\n   void\n   build_recover_thunks();\n \n-  // Return a declaration for __builtin_return_address or\n-  // __builtin_dwarf_cfa.\n-  static Named_object*\n-  declare_builtin_rf_address(const char* name, bool hasarg);\n-\n   // Simplify statements which might use thunks: go and defer\n   // statements.\n   void"}, {"sha": "289d6bf8297dd5a42e03a6207a227d4671449ce1", "filename": "gcc/go/gofrontend/runtime.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d67708ca8d0efbeeb5742ef177db2e1a096278/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d67708ca8d0efbeeb5742ef177db2e1a096278/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.cc?ref=f6d67708ca8d0efbeeb5742ef177db2e1a096278", "patch": "@@ -32,6 +32,8 @@ enum Runtime_function_type\n   RFT_INT,\n   // Go type int32, C type int32_t.\n   RFT_INT32,\n+  // Go type uint32, C type uint32_t.\n+  RFT_UINT32,\n   // Go type int64, C type int64_t.\n   RFT_INT64,\n   // Go type uint64, C type uint64_t.\n@@ -111,6 +113,10 @@ runtime_function_type(Runtime_function_type bft)\n \t  t = Type::lookup_integer_type(\"int32\");\n \t  break;\n \n+\tcase RFT_UINT32:\n+\t  t = Type::lookup_integer_type(\"uint32\");\n+\t  break;\n+\n \tcase RFT_INT64:\n \t  t = Type::lookup_integer_type(\"int64\");\n \t  break;\n@@ -245,6 +251,7 @@ convert_to_runtime_function_type(Runtime_function_type bft, Expression* e,\n     case RFT_BOOLPTR:\n     case RFT_INT:\n     case RFT_INT32:\n+    case RFT_UINT32:\n     case RFT_INT64:\n     case RFT_UINT64:\n     case RFT_UINTPTR:"}, {"sha": "a5264eebadaf0117b187e6994d3a931ac7819ead", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d67708ca8d0efbeeb5742ef177db2e1a096278/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d67708ca8d0efbeeb5742ef177db2e1a096278/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=f6d67708ca8d0efbeeb5742ef177db2e1a096278", "patch": "@@ -376,6 +376,26 @@ DEF_GO_RUNTIME(UNREACHABLE, \"__builtin_unreachable\", P0(), R0())\n DEF_GO_RUNTIME(BUILTIN_MEMMOVE, \"__builtin_memmove\",\n                P3(POINTER, POINTER, UINTPTR), R0())\n \n+// Various intrinsics.\n+\n+// Get the caller's PC, used for runtime.getcallerpc.\n+DEF_GO_RUNTIME(BUILTIN_RETURN_ADDRESS, \"__builtin_return_address\",\n+               P1(UINT32), R1(POINTER))\n+\n+// Get the caller's SP, used for runtime.getcallersp.\n+DEF_GO_RUNTIME(BUILTIN_DWARF_CFA, \"__builtin_dwarf_cfa\", P0(),\n+               R1(POINTER))\n+\n+// Swap bytes.\n+DEF_GO_RUNTIME(BUILTIN_BSWAP32, \"__builtin_bswap32\", P1(UINT32),\n+               R1(UINT32))\n+DEF_GO_RUNTIME(BUILTIN_BSWAP64, \"__builtin_bswap64\", P1(UINT64),\n+               R1(UINT64))\n+\n+// Count trailing zeros.\n+DEF_GO_RUNTIME(BUILTIN_CTZ, \"__builtin_ctz\", P1(UINT32), R1(INT32))\n+DEF_GO_RUNTIME(BUILTIN_CTZLL, \"__builtin_ctzll\", P1(UINT64), R1(INT32))\n+\n // Remove helper macros.\n #undef ABFT6\n #undef ABFT2"}]}