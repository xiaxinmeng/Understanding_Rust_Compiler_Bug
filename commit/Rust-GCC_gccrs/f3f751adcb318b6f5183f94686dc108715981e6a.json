{"sha": "f3f751adcb318b6f5183f94686dc108715981e6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNmNzUxYWRjYjMxOGI2ZjUxODNmOTQ2ODZkYzEwODcxNTk4MWU2YQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2000-06-30T09:47:49Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-06-30T09:47:49Z"}, "message": "cpp.texi: Document #pragma GCC dependency\n\n\t* cpp.texi: Document #pragma GCC dependency\n\t* cppfiles.c (open_include_file): Set date to unknown.\n\t(_cpp_compare_file_date): New function.\n\t(read_include_file): Set file date.\n\t* cpphash.h (struct include_file): Add date member.\n\t(_cpp_compare_file_date): Prototype.\n\t* cpplib.c (parse_include): Add trail parameter. Adjust.\n\t(do_include): Adjust parse_include call.\n\t(do_import): Likewise.\n\t(do_include_next): Likewise.\n\t(gcc_pragmas): Add dependency pragma.\n\t(do_pragma_dependancy): New pragma.\n\nFrom-SVN: r34808", "tree": {"sha": "4970a3469f1e57aa1f8e1516bdd8be5ca7391d38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4970a3469f1e57aa1f8e1516bdd8be5ca7391d38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3f751adcb318b6f5183f94686dc108715981e6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3f751adcb318b6f5183f94686dc108715981e6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3f751adcb318b6f5183f94686dc108715981e6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3f751adcb318b6f5183f94686dc108715981e6a/comments", "author": null, "committer": null, "parents": [{"sha": "34f9943ef73797e5db1039d888785b0bc5f220e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34f9943ef73797e5db1039d888785b0bc5f220e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34f9943ef73797e5db1039d888785b0bc5f220e0"}], "stats": {"total": 144, "additions": 137, "deletions": 7}, "files": [{"sha": "3ee3b4091ae9d92cc9701c577a7c637e853000be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3f751adcb318b6f5183f94686dc108715981e6a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3f751adcb318b6f5183f94686dc108715981e6a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3f751adcb318b6f5183f94686dc108715981e6a", "patch": "@@ -1,3 +1,18 @@\n+2000-06-30  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cpp.texi: Document #pragma GCC dependency\n+\t* cppfiles.c (open_include_file): Set date to unknown.\n+\t(_cpp_compare_file_date): New function.\n+\t(read_include_file): Set file date.\n+\t* cpphash.h (struct include_file): Add date member.\n+\t(_cpp_compare_file_date): Prototype.\n+\t* cpplib.c (parse_include): Add trail parameter. Adjust.\n+\t(do_include): Adjust parse_include call.\n+\t(do_import): Likewise.\n+\t(do_include_next): Likewise.\n+\t(gcc_pragmas): Add dependency pragma.\n+\t(do_pragma_dependancy): New pragma.\n+\n 2000-06-29  Jason Merrill  <jason@redhat.com>\n \n \t* dwarf2out.c (output_loc_operands): Don't abort on codes that have"}, {"sha": "47647025bcc067c642556766e44f62bccb7adaf8", "filename": "gcc/cpp.texi", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3f751adcb318b6f5183f94686dc108715981e6a/gcc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3f751adcb318b6f5183f94686dc108715981e6a/gcc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpp.texi?ref=f3f751adcb318b6f5183f94686dc108715981e6a", "patch": "@@ -2664,6 +2664,20 @@ the text is ignored and this directive has no effect.  Typically\n @samp{#ident} is only used in header files supplied with those systems\n where it is meaningful.\n \n+@findex #pragma GCC dependency\n+The @samp{#pragma GCC dependency} allows you to check the relative dates\n+of the current file and another file. If the other file is more\n+recent than the current file, a warning is issued. This is useful if the\n+include file is derived from the other file, and should be regenerated.\n+The other file is searched for using the normal include search path.\n+Optional trailing text can be used to give more information in the\n+warning message.\n+\n+@smallexample\n+#pragma GCC dependency \"parse.y\"\n+#pragma GCC dependency \"/usr/include/time.h\" rerun /path/to/fixincludes\n+@end smallexample\n+\n @node Output, Invocation, Other Directives, Top\n @section C Preprocessor Output\n "}, {"sha": "4e14aae102f9927268bc7203815dfe5fa80a7108", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3f751adcb318b6f5183f94686dc108715981e6a/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3f751adcb318b6f5183f94686dc108715981e6a/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=f3f751adcb318b6f5183f94686dc108715981e6a", "patch": "@@ -227,6 +227,7 @@ open_include_file (pfile, filename)\n     }\n \n   file->fd = fd;\n+  file->date = (time_t) -1;\n   return file;\n }\n \n@@ -465,6 +466,60 @@ _cpp_execute_include (pfile, f, len, no_reinclude, search_start)\n     cpp_error_from_errno (pfile, fname);\n }\n \n+/* Locate file F, and determine whether it is newer than PFILE. Return -1,\n+   if F cannot be located or dated, 1, if it is newer and 0 if older.  */\n+\n+int\n+_cpp_compare_file_date (pfile, f, len, search_start)\n+     cpp_reader *pfile;\n+     U_CHAR *f;\n+     unsigned int len;\n+     struct file_name_list *search_start;\n+{\n+  char *fname = (char *)f;\n+  int angle_brackets = fname[0] == '<';\n+  struct include_file *inc;\n+  struct include_file *current_include = cpp_file_buffer (pfile)->inc;\n+\n+  if (!search_start)\n+    {\n+      if (angle_brackets)\n+\tsearch_start = CPP_OPTION (pfile, bracket_include);\n+      else if (CPP_OPTION (pfile, ignore_srcdir))\n+\tsearch_start = CPP_OPTION (pfile, quote_include);\n+      else\n+\tsearch_start = CPP_BUFFER (pfile)->actual_dir;\n+    }\n+\n+  /* Remove quote marks.  */\n+  fname++;\n+  len -= 2;\n+  fname[len] = '\\0';\n+  \n+  inc = find_include_file (pfile, fname, search_start);\n+  \n+  if (!inc)\n+    return -1;\n+  if (inc->fd >= 0)\n+    {\n+      struct stat source;\n+      \n+      if (fstat (inc->fd, &source) < 0)\n+        {\n+          close (inc->fd);\n+          inc->fd = -1;\n+          return -1;\n+        }\n+      inc->date = source.st_mtime;\n+      close (inc->fd);\n+      inc->fd = -1;\n+    }\n+  if (inc->date == (time_t)-1 || current_include->date == (time_t)-1)\n+    return -1;\n+  return inc->date > current_include->date;\n+}\n+\n+\n /* Push an input buffer and load it up with the contents of FNAME.\n    If FNAME is \"\" or NULL, read standard input.  */\n int\n@@ -502,6 +557,8 @@ read_include_file (pfile, inc)\n \n   if (fstat (fd, &st) < 0)\n     goto perror_fail;\n+  \n+  inc->date = st.st_mtime;\n \n   /* If fd points to a plain file, we might be able to mmap it; we can\n      definitely allocate the buffer all at once.  If fd is a pipe or"}, {"sha": "ec9204a0e9e31c359028e6215d49a8c233be4271", "filename": "gcc/cpphash.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3f751adcb318b6f5183f94686dc108715981e6a/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3f751adcb318b6f5183f94686dc108715981e6a/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=f3f751adcb318b6f5183f94686dc108715981e6a", "patch": "@@ -64,6 +64,7 @@ struct include_file\n   int fd;\t\t\t/* file descriptor possibly open on file */\n   unsigned short include_count;\t/* number of times file has been read */\n   unsigned short sysp;\t\t/* file is a system header */\n+  time_t  date;                 /* modification date of file, if known */\n };\n \n /* The cmacro works like this: If it's NULL, the file is to be\n@@ -193,6 +194,9 @@ extern void _cpp_simplify_pathname\tPARAMS ((char *));\n extern void _cpp_execute_include\tPARAMS ((cpp_reader *, U_CHAR *,\n \t\t\t\t\t\t unsigned int, int,\n \t\t\t\t\t\t struct file_name_list *));\n+extern int _cpp_compare_file_date       PARAMS ((cpp_reader *, U_CHAR *,\n+                                                 unsigned int,\n+                                                 struct file_name_list *));\n extern void _cpp_init_include_table\tPARAMS ((cpp_reader *));\n extern const char *_cpp_fake_include\tPARAMS ((cpp_reader *, const char *));\n "}, {"sha": "26396df8e2987111a348da60e9cd33a58b1abccd", "filename": "gcc/cpplib.c", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3f751adcb318b6f5183f94686dc108715981e6a/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3f751adcb318b6f5183f94686dc108715981e6a/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=f3f751adcb318b6f5183f94686dc108715981e6a", "patch": "@@ -52,7 +52,7 @@ struct if_stack\n /* Forward declarations.  */\n \n static void validate_else\t\tPARAMS ((cpp_reader *, const U_CHAR *));\n-static unsigned int parse_include\tPARAMS ((cpp_reader *, const U_CHAR *));\n+static unsigned int parse_include\tPARAMS ((cpp_reader *, const U_CHAR *, int));\n static void push_conditional\t\tPARAMS ((cpp_reader *, int, int,\n \t\t\t\t\t\t const cpp_hashnode *));\n static void pass_thru_directive\t\tPARAMS ((const U_CHAR *, size_t,\n@@ -398,9 +398,10 @@ do_define (pfile)\n /* Handle #include and #import.  */\n \n static unsigned int\n-parse_include (pfile, name)\n+parse_include (pfile, name, trail)\n      cpp_reader *pfile;\n      const U_CHAR *name;\n+     int trail;\n {\n   long old_written = CPP_WRITTEN (pfile);\n   enum cpp_ttype token;\n@@ -420,7 +421,7 @@ parse_include (pfile, name)\n       return 0;\n     }\n \n-  if (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n+  if (!trail && _cpp_get_directive_token (pfile) != CPP_VSPACE)\n     {\n       cpp_error (pfile, \"junk at end of #%s\", name);\n       _cpp_skip_rest_of_line (pfile);\n@@ -441,7 +442,7 @@ do_include (pfile)\n   unsigned int len;\n   U_CHAR *token;\n \n-  len = parse_include (pfile, dtable[T_INCLUDE].name);\n+  len = parse_include (pfile, dtable[T_INCLUDE].name, 0);\n   if (len == 0)\n     return 0;\n   token = (U_CHAR *) alloca (len + 1);\n@@ -470,7 +471,7 @@ do_import (pfile)\n \t   \"#import is obsolete, use an #ifndef wrapper in the header file\");\n     }\n \n-  len = parse_include (pfile, dtable[T_IMPORT].name);\n+  len = parse_include (pfile, dtable[T_IMPORT].name, 0);\n   if (len == 0)\n     return 0;\n   token = (U_CHAR *) alloca (len + 1);\n@@ -492,7 +493,7 @@ do_include_next (pfile)\n   U_CHAR *token;\n   struct file_name_list *search_start = 0;\n \n-  len = parse_include (pfile, dtable[T_INCLUDE_NEXT].name);\n+  len = parse_include (pfile, dtable[T_INCLUDE_NEXT].name, 0);\n   if (len == 0)\n     return 0;\n   token = (U_CHAR *) alloca (len + 1);\n@@ -803,6 +804,7 @@ static int do_pragma_poison\t\tPARAMS ((cpp_reader *));\n static int do_pragma_system_header\tPARAMS ((cpp_reader *));\n static int do_pragma_default\t\tPARAMS ((cpp_reader *));\n static int do_pragma_gcc                PARAMS ((cpp_reader *));\n+static int do_pragma_dependency         PARAMS ((cpp_reader *));\n \n static const struct pragma_entry top_pragmas[] =\n {\n@@ -819,6 +821,7 @@ static const struct pragma_entry gcc_pragmas[] =\n   {\"implementation\", do_pragma_implementation},\n   {\"poison\", do_pragma_poison},\n   {\"system_header\", do_pragma_system_header},\n+  {\"dependency\", do_pragma_dependency},\n   {NULL, do_pragma_default}\n };\n \n@@ -1033,7 +1036,44 @@ do_pragma_system_header (pfile)\n \n   return 1;\n }\n- \n+\n+/* Check the modified date of the current include file against a specified\n+   file. Issue a diagnostic, if the specified file is newer. We use this to\n+   determine if a fixed header should be refixed.  */\n+static int\n+do_pragma_dependency (pfile)\n+     cpp_reader *pfile;\n+{\n+  U_CHAR *original_name, *name;\n+  unsigned len;\n+  int ordering;\n+  \n+  len = parse_include (pfile, (const U_CHAR *)\"pragma dependency\", 1);\n+  original_name = (U_CHAR *) alloca (len + 1);\n+  name = (U_CHAR *) alloca (len + 1);\n+  memcpy (original_name, CPP_PWRITTEN (pfile), len);\n+  memcpy (name, CPP_PWRITTEN (pfile), len);\n+  original_name[len] = name[len] = 0;\n+  \n+  ordering = _cpp_compare_file_date (pfile, name, len, 0);\n+  if (ordering < 0)\n+    cpp_warning (pfile, \"cannot find source %s\", original_name);\n+  else if (ordering > 0)\n+    {\n+      const U_CHAR *text, *limit;\n+      _cpp_skip_hspace (pfile);\n+      text = CPP_BUFFER (pfile)->cur;\n+      _cpp_skip_rest_of_line (pfile);\n+      limit = CPP_BUFFER (pfile)->cur;\n+      \n+      cpp_warning (pfile, \"current file is older than %s\", original_name);\n+      if (limit != text)\n+        cpp_warning (pfile, \"%.*s\", (int)(limit - text), text);\n+    }\n+  _cpp_skip_rest_of_line (pfile);\n+  return 1;\n+}\n+\n /* Just ignore #sccs, on systems where we define it at all.  */\n #ifdef SCCS_DIRECTIVE\n static int"}]}