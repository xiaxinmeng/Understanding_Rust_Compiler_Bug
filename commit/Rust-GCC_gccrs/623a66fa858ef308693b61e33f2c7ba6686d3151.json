{"sha": "623a66fa858ef308693b61e33f2c7ba6686d3151", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjIzYTY2ZmE4NThlZjMwODY5M2I2MWUzM2YyYzdiYTY2ODZkMzE1MQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2004-06-14T12:09:08Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2004-06-14T12:09:08Z"}, "message": "basic-block.h (could_fall_through): Declare.\n\n\t* basic-block.h (could_fall_through): Declare.\n\t* cfganal.c (can_fallthru): Succeed if the target is EXIT_BLOCK_PTR.\n\tFail if the source already has a fallthrough edge to the exit\n\tblock pointer.\n\t(could_fall_through): New function.\n\t* cfgbuild.c (make_edges): Check if we already have a fallthrough\n\tedge to the exit block pointer.\n\t* cfglayout.c (fixup_fallthru_exit_predecessor): Check that it is\n\tnot called before reload has completed.\n\tHandle special case of first block having a fall-through exit edge.\n\t(cfg_layout_finalize): Don't call it before reload or if we have\n\trtl epilogues.\n\t(fixup_reorder_chain): A fall through to the exit block does not\n\trequire the block to come last.  Add sanity checks.\n\t* cfgrtl.c (rtl_split_edge): Add special handling of fall through\n\tedges to the exit block.\n\t* function.c (cfglayout.h): #include.\n\t(thread_prologue_and_epilogue_insns): If we have neither return nor\n\tepilogue, but a fall through to the exit block from mid-function,\n\tforce a non-fall-through exit.\n\t* Makefile.in (function.o): Depend on CFGLAYOUT_H.\n\nFrom-SVN: r83089", "tree": {"sha": "a37b5ac1c93cff4befd42e4070615ba42213a250", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a37b5ac1c93cff4befd42e4070615ba42213a250"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/623a66fa858ef308693b61e33f2c7ba6686d3151", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/623a66fa858ef308693b61e33f2c7ba6686d3151", "html_url": "https://github.com/Rust-GCC/gccrs/commit/623a66fa858ef308693b61e33f2c7ba6686d3151", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/623a66fa858ef308693b61e33f2c7ba6686d3151/comments", "author": null, "committer": null, "parents": [{"sha": "ce2a46a203b146e4cf3ebc23ea5de2dba3b4917f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce2a46a203b146e4cf3ebc23ea5de2dba3b4917f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce2a46a203b146e4cf3ebc23ea5de2dba3b4917f"}], "stats": {"total": 157, "additions": 139, "deletions": 18}, "files": [{"sha": "24a8365f4613e3ee88bd999e3c79f2929269263a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623a66fa858ef308693b61e33f2c7ba6686d3151/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623a66fa858ef308693b61e33f2c7ba6686d3151/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=623a66fa858ef308693b61e33f2c7ba6686d3151", "patch": "@@ -1,3 +1,27 @@\n+2004-06-14  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* basic-block.h (could_fall_through): Declare.\n+\t* cfganal.c (can_fallthru): Succeed if the target is EXIT_BLOCK_PTR.\n+\tFail if the source already has a fallthrough edge to the exit\n+\tblock pointer.\n+\t(could_fall_through): New function.\n+\t* cfgbuild.c (make_edges): Check if we already have a fallthrough\n+\tedge to the exit block pointer.\n+\t* cfglayout.c (fixup_fallthru_exit_predecessor): Check that it is\n+\tnot called before reload has completed.\n+\tHandle special case of first block having a fall-through exit edge.\n+\t(cfg_layout_finalize): Don't call it before reload or if we have\n+\trtl epilogues.\n+\t(fixup_reorder_chain): A fall through to the exit block does not\n+\trequire the block to come last.  Add sanity checks.\n+\t* cfgrtl.c (rtl_split_edge): Add special handling of fall through\n+\tedges to the exit block.\n+\t* function.c (cfglayout.h): #include.\n+\t(thread_prologue_and_epilogue_insns): If we have neither return nor\n+\tepilogue, but a fall through to the exit block from mid-function,\n+\tforce a non-fall-through exit.\n+\t* Makefile.in (function.o): Depend on CFGLAYOUT_H.\n+\n 2004-06-14  Alan Modra  <amodra@bigpond.net.au>\n \n \t* config/rs6000/rs6000.h (ASM_CPU_SPEC): Handle -mpowerpc64 and -mcpu"}, {"sha": "0e94fd630f9e1901ac52a7a0e2cff57c3ee2bd9d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623a66fa858ef308693b61e33f2c7ba6686d3151/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623a66fa858ef308693b61e33f2c7ba6686d3151/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=623a66fa858ef308693b61e33f2c7ba6686d3151", "patch": "@@ -1759,7 +1759,8 @@ varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_\n    flags.h function.h $(EXPR_H) hard-reg-set.h $(REGS_H) \\\n    output.h c-pragma.h toplev.h xcoffout.h debug.h $(GGC_H) $(TM_P_H) \\\n    $(HASHTAB_H) $(TARGET_H) langhooks.h gt-varasm.h real.h\n-function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n+function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n+   $(TREE_H) $(CFGLAYOUT_H) \\\n    flags.h function.h $(EXPR_H) $(OPTABS_H) libfuncs.h $(REGS_H) hard-reg-set.h \\\n    insn-config.h $(RECOG_H) output.h toplev.h except.h $(HASHTAB_H) $(GGC_H) \\\n    $(TM_P_H) langhooks.h gt-function.h $(TARGET_H) basic-block.h"}, {"sha": "97f71efef4cdb28781a20c2784db21aee63ef8a0", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623a66fa858ef308693b61e33f2c7ba6686d3151/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623a66fa858ef308693b61e33f2c7ba6686d3151/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=623a66fa858ef308693b61e33f2c7ba6686d3151", "patch": "@@ -629,6 +629,7 @@ extern void find_sub_basic_blocks (basic_block);\n extern void find_many_sub_basic_blocks (sbitmap);\n extern void rtl_make_eh_edge (sbitmap *, basic_block, rtx);\n extern bool can_fallthru (basic_block, basic_block);\n+extern bool could_fall_through (basic_block, basic_block);\n extern void flow_nodes_print (const char *, const sbitmap, FILE *);\n extern void flow_edge_list_print (const char *, const edge *, int, FILE *);\n extern void alloc_aux_for_block (basic_block, int);"}, {"sha": "c8675dca6e26cd86fb94dc4913769f16ff950ea8", "filename": "gcc/cfganal.c", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623a66fa858ef308693b61e33f2c7ba6686d3151/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623a66fa858ef308693b61e33f2c7ba6686d3151/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=623a66fa858ef308693b61e33f2c7ba6686d3151", "patch": "@@ -103,17 +103,42 @@ bool\n can_fallthru (basic_block src, basic_block target)\n {\n   rtx insn = BB_END (src);\n-  rtx insn2 = target == EXIT_BLOCK_PTR ? NULL : BB_HEAD (target);\n+  rtx insn2;\n+  edge e;\n \n+  if (target == EXIT_BLOCK_PTR)\n+    return true;\n   if (src->next_bb != target)\n     return 0;\n+  for (e = src->succ; e; e = e->succ_next)\n+    if (e->dest == EXIT_BLOCK_PTR\n+\t&& e->flags & EDGE_FALLTHRU)\n+    return 0;\n \n+  insn2 = BB_HEAD (target);\n   if (insn2 && !active_insn_p (insn2))\n     insn2 = next_active_insn (insn2);\n \n   /* ??? Later we may add code to move jump tables offline.  */\n   return next_active_insn (insn) == insn2;\n }\n+\n+/* Return nonzero if we could reach target from src by falling through,\n+   if the target was made adjacent.  If we already have a fall-through\n+   edge to the exit block, we can't do that.  */\n+bool\n+could_fall_through (basic_block src, basic_block target)\n+{\n+  edge e;\n+\n+  if (target == EXIT_BLOCK_PTR)\n+    return true;\n+  for (e = src->succ; e; e = e->succ_next)\n+    if (e->dest == EXIT_BLOCK_PTR\n+\t&& e->flags & EDGE_FALLTHRU)\n+    return 0;\n+  return true;\n+}\n \f\n /* Mark the back edges in DFS traversal.\n    Return nonzero if a loop (natural or otherwise) is present."}, {"sha": "8402dad578f8840f1a9cbb687c43af5de49b65e9", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623a66fa858ef308693b61e33f2c7ba6686d3151/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623a66fa858ef308693b61e33f2c7ba6686d3151/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=623a66fa858ef308693b61e33f2c7ba6686d3151", "patch": "@@ -267,6 +267,7 @@ make_edges (rtx label_value_list, basic_block min, basic_block max, int update_p\n       rtx insn, x;\n       enum rtx_code code;\n       int force_fallthru = 0;\n+      edge e;\n \n       if (GET_CODE (BB_HEAD (bb)) == CODE_LABEL\n \t  && LABEL_ALT_ENTRY_P (BB_HEAD (bb)))\n@@ -389,6 +390,12 @@ make_edges (rtx label_value_list, basic_block min, basic_block max, int update_p\n \n       /* Find out if we can drop through to the next block.  */\n       insn = NEXT_INSN (insn);\n+      for (e = bb->succ; e; e = e->succ_next)\n+\tif (e->dest == EXIT_BLOCK_PTR && e->flags & EDGE_FALLTHRU)\n+\t  {\n+\t    insn = 0;\n+\t    break;\n+\t  }\n       while (insn\n \t     && GET_CODE (insn) == NOTE\n \t     && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK)"}, {"sha": "66742686e1625577a01179955c6fafb7e551fef2", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623a66fa858ef308693b61e33f2c7ba6686d3151/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623a66fa858ef308693b61e33f2c7ba6686d3151/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=623a66fa858ef308693b61e33f2c7ba6686d3151", "patch": "@@ -714,6 +714,10 @@ fixup_reorder_chain (void)\n \t\t      && invert_jump (bb_end_insn,\n \t\t\t\t      label_for_bb (e_fall->dest), 0))\n \t\t    {\n+#ifdef ENABLE_CHECKING\n+\t\t      if (!could_fall_through (e_taken->src, e_taken->dest))\n+\t\t\tabort ();\n+#endif\n \t\t      e_fall->flags &= ~EDGE_FALLTHRU;\n \t\t      e_taken->flags |= EDGE_FALLTHRU;\n \t\t      update_br_prob_note (bb);\n@@ -731,6 +735,10 @@ fixup_reorder_chain (void)\n \t      else if (invert_jump (bb_end_insn,\n \t\t\t\t    label_for_bb (e_fall->dest), 0))\n \t\t{\n+#ifdef ENABLE_CHECKING\n+\t\t  if (!could_fall_through (e_taken->src, e_taken->dest))\n+\t\t    abort ();\n+#endif\n \t\t  e_fall->flags &= ~EDGE_FALLTHRU;\n \t\t  e_taken->flags |= EDGE_FALLTHRU;\n \t\t  update_br_prob_note (bb);\n@@ -770,7 +778,7 @@ fixup_reorder_chain (void)\n \t    continue;\n \n \t  /* A fallthru to exit block.  */\n-\t  if (!bb->rbi->next && e_fall->dest == EXIT_BLOCK_PTR)\n+\t  if (e_fall->dest == EXIT_BLOCK_PTR)\n \t    continue;\n \t}\n \n@@ -910,14 +918,20 @@ verify_insn_chain (void)\n     abort ();\n }\n \f\n-/* The block falling through to exit must be the last one in the\n-   reordered chain.  Ensure that this condition is met.  */\n+/* If we have assembler epilogues, the block falling through to exit must\n+   be the last one in the reordered chain when we reach final.  Ensure\n+   that this condition is met.  */\n static void\n fixup_fallthru_exit_predecessor (void)\n {\n   edge e;\n   basic_block bb = NULL;\n \n+  /* This transformation is not valid before reload, because we might separate\n+     a call from the instruction that copies the return value.  */\n+  if (! reload_completed)\n+    abort ();\n+\n   for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n     if (e->flags & EDGE_FALLTHRU)\n       bb = e->src;\n@@ -926,6 +940,18 @@ fixup_fallthru_exit_predecessor (void)\n     {\n       basic_block c = ENTRY_BLOCK_PTR->next_bb;\n \n+      /* If the very first block is the one with the fall-through exit\n+\t edge, we have to split that block.  */\n+      if (c == bb)\n+\t{\n+\t  bb = split_block (bb, NULL)->dest;\n+\t  initialize_bb_rbi (bb);\n+\t  bb->rbi->next = c->rbi->next;\n+\t  c->rbi->next = bb;\n+\t  bb->rbi->footer = c->rbi->footer;\n+\t  c->rbi->footer = NULL;\n+\t}\n+\n       while (c->rbi->next != bb)\n \tc = c->rbi->next;\n \n@@ -1176,7 +1202,12 @@ cfg_layout_finalize (void)\n   verify_flow_info ();\n #endif\n   rtl_register_cfg_hooks ();\n-  fixup_fallthru_exit_predecessor ();\n+  if (reload_completed\n+#ifdef HAVE_epilogue\n+      && !HAVE_epilogue\n+#endif\n+      )\n+    fixup_fallthru_exit_predecessor ();\n   fixup_reorder_chain ();\n \n #ifdef ENABLE_CHECKING"}, {"sha": "6e22d80ac84cfd676ff7faed77b2c38949f7bec2", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623a66fa858ef308693b61e33f2c7ba6686d3151/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623a66fa858ef308693b61e33f2c7ba6686d3151/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=623a66fa858ef308693b61e33f2c7ba6686d3151", "patch": "@@ -1336,7 +1336,19 @@ rtl_split_edge (edge edge_in)\n   else\n     before = NULL_RTX;\n \n-  bb = create_basic_block (before, NULL, edge_in->dest->prev_bb);\n+  /* If this is a fall through edge to the exit block, the blocks might be\n+     not adjacent, and the right place is the after the source.  */\n+  if (edge_in->flags & EDGE_FALLTHRU && edge_in->dest == EXIT_BLOCK_PTR)\n+    {\n+      before = NEXT_INSN (BB_END (edge_in->src));\n+      if (before\n+\t  && GET_CODE (before) == NOTE\n+\t  && NOTE_LINE_NUMBER (before) == NOTE_INSN_LOOP_END)\n+\tbefore = NEXT_INSN (before);\n+      bb = create_basic_block (before, NULL, edge_in->src);\n+    }\n+  else\n+    bb = create_basic_block (before, NULL, edge_in->dest->prev_bb);\n \n   /* ??? This info is likely going to be out of date very soon.  */\n   if (edge_in->dest->global_live_at_start)"}, {"sha": "b59da9a4160732a6ca6fd79c80dd9c5baee23203", "filename": "gcc/function.c", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623a66fa858ef308693b61e33f2c7ba6686d3151/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623a66fa858ef308693b61e33f2c7ba6686d3151/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=623a66fa858ef308693b61e33f2c7ba6686d3151", "patch": "@@ -63,6 +63,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"integrate.h\"\n #include \"langhooks.h\"\n #include \"target.h\"\n+#include \"cfglayout.h\"\n \n #ifndef LOCAL_ALIGNMENT\n #define LOCAL_ALIGNMENT(TYPE, ALIGNMENT) ALIGNMENT\n@@ -7558,20 +7559,20 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \t}\n     }\n #endif\n+  /* Find the edge that falls through to EXIT.  Other edges may exist\n+     due to RETURN instructions, but those don't need epilogues.\n+     There really shouldn't be a mixture -- either all should have\n+     been converted or none, however...  */\n+\n+  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n+    if (e->flags & EDGE_FALLTHRU)\n+      break;\n+  if (e == NULL)\n+    goto epilogue_done;\n+\n #ifdef HAVE_epilogue\n   if (HAVE_epilogue)\n     {\n-      /* Find the edge that falls through to EXIT.  Other edges may exist\n-\t due to RETURN instructions, but those don't need epilogues.\n-\t There really shouldn't be a mixture -- either all should have\n-\t been converted or none, however...  */\n-\n-      for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n-\tif (e->flags & EDGE_FALLTHRU)\n-\t  break;\n-      if (e == NULL)\n-\tgoto epilogue_done;\n-\n       start_sequence ();\n       epilogue_end = emit_note (NOTE_INSN_EPILOGUE_BEG);\n \n@@ -7597,7 +7598,26 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n       insert_insn_on_edge (seq, e);\n       inserted = 1;\n     }\n+  else\n #endif\n+    {\n+      basic_block cur_bb;\n+\n+      if (! next_active_insn (BB_END (e->src)))\n+\tgoto epilogue_done;\n+      /* We have a fall-through edge to the exit block, the source is not\n+         at the end of the function, and there will be an assembler epilogue\n+         at the end of the function.\n+         We can't use force_nonfallthru here, because that would try to\n+         use return.  Inserting a jump 'by hand' is extremely messy, so\n+\t we take advantage of cfg_layout_finalize using\n+\tfixup_fallthru_exit_predecessor.  */\n+      cfg_layout_initialize ();\n+      FOR_EACH_BB (cur_bb)\n+\tif (cur_bb->index >= 0 && cur_bb->next_bb->index >= 0)\n+\t  cur_bb->rbi->next = cur_bb->next_bb;\n+      cfg_layout_finalize ();\n+    }\n epilogue_done:\n \n   if (inserted)"}]}