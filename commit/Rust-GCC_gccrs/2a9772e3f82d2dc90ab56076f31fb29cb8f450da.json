{"sha": "2a9772e3f82d2dc90ab56076f31fb29cb8f450da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE5NzcyZTNmODJkMmRjOTBhYjU2MDc2ZjMxZmIyOWNiOGY0NTBkYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-10-08T19:55:31Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-10-08T19:55:31Z"}, "message": "integrate.c (try_constants, [...]): Remove.\n\n\t* integrate.c (try_constants, subst_constants, mark_stores):\n\tRemove.\n\t* integrate.h: Remove the prototype for try_constants.\n\nFrom-SVN: r88787", "tree": {"sha": "318ee969151bdfa52f5c36e72343baf6ca340863", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/318ee969151bdfa52f5c36e72343baf6ca340863"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a9772e3f82d2dc90ab56076f31fb29cb8f450da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a9772e3f82d2dc90ab56076f31fb29cb8f450da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a9772e3f82d2dc90ab56076f31fb29cb8f450da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a9772e3f82d2dc90ab56076f31fb29cb8f450da/comments", "author": null, "committer": null, "parents": [{"sha": "6dcc04b0603acb478023cd019af32eb5ca99e85f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dcc04b0603acb478023cd019af32eb5ca99e85f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dcc04b0603acb478023cd019af32eb5ca99e85f"}], "stats": {"total": 447, "additions": 6, "deletions": 441}, "files": [{"sha": "0a21fc1300fc3b0cb0362f01190e58c1c1ce7cf8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9772e3f82d2dc90ab56076f31fb29cb8f450da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9772e3f82d2dc90ab56076f31fb29cb8f450da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a9772e3f82d2dc90ab56076f31fb29cb8f450da", "patch": "@@ -1,3 +1,9 @@\n+2004-10-08  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* integrate.c (try_constants, subst_constants, mark_stores):\n+\tRemove.\n+\t* integrate.h: Remove the prototype for try_constants.\n+\n 2004-10-08  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* c-typeck.c (enum impl_conv): Add ic_argpass_nonproto."}, {"sha": "2202e22f910736ca82e96197b0154cb792f20180", "filename": "gcc/integrate.c", "status": "modified", "additions": 0, "deletions": 439, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9772e3f82d2dc90ab56076f31fb29cb8f450da/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9772e3f82d2dc90ab56076f31fb29cb8f450da/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=2a9772e3f82d2dc90ab56076f31fb29cb8f450da", "patch": "@@ -61,10 +61,8 @@ typedef struct initial_value_struct GTY(()) {\n   initial_value_pair * GTY ((length (\"%h.num_entries\"))) entries;\n } initial_value_struct;\n \n-static void subst_constants (rtx *, rtx, struct inline_remap *, int);\n static void set_block_origin_self (tree);\n static void set_block_abstract_flags (tree, int);\n-static void mark_stores (rtx, rtx, void *);\n \f\n /* Returns the Ith entry in the label_map contained in MAP.  If the\n    Ith entry has not yet been set, return a fresh label.  This function\n@@ -583,443 +581,6 @@ copy_rtx_and_substitute (rtx orig, struct inline_remap *map, int for_lhs)\n   return copy;\n }\n \f\n-/* Substitute known constant values into INSN, if that is valid.  */\n-\n-void\n-try_constants (rtx insn, struct inline_remap *map)\n-{\n-  int i;\n-\n-  map->num_sets = 0;\n-\n-  /* First try just updating addresses, then other things.  This is\n-     important when we have something like the store of a constant\n-     into memory and we can update the memory address but the machine\n-     does not support a constant source.  */\n-  subst_constants (&PATTERN (insn), insn, map, 1);\n-  apply_change_group ();\n-  subst_constants (&PATTERN (insn), insn, map, 0);\n-  apply_change_group ();\n-\n-  /* Enforce consistency between the addresses in the regular insn flow\n-     and the ones in CALL_INSN_FUNCTION_USAGE lists, if any.  */\n-  if (CALL_P (insn) && CALL_INSN_FUNCTION_USAGE (insn))\n-    {\n-      subst_constants (&CALL_INSN_FUNCTION_USAGE (insn), insn, map, 1);\n-      apply_change_group ();\n-    }\n-\n-  /* Show we don't know the value of anything stored or clobbered.  */\n-  note_stores (PATTERN (insn), mark_stores, NULL);\n-  map->last_pc_value = 0;\n-#ifdef HAVE_cc0\n-  map->last_cc0_value = 0;\n-#endif\n-\n-  /* Set up any constant equivalences made in this insn.  */\n-  for (i = 0; i < map->num_sets; i++)\n-    {\n-      if (REG_P (map->equiv_sets[i].dest))\n-\t{\n-\t  int regno = REGNO (map->equiv_sets[i].dest);\n-\n-\t  MAYBE_EXTEND_CONST_EQUIV_VARRAY (map, regno);\n-\t  if (VARRAY_CONST_EQUIV (map->const_equiv_varray, regno).rtx == 0\n-\t      /* Following clause is a hack to make case work where GNU C++\n-\t\t reassigns a variable to make cse work right.  */\n-\t      || ! rtx_equal_p (VARRAY_CONST_EQUIV (map->const_equiv_varray,\n-\t\t\t\t\t\t    regno).rtx,\n-\t\t\t\tmap->equiv_sets[i].equiv))\n-\t    SET_CONST_EQUIV_DATA (map, map->equiv_sets[i].dest,\n-\t\t\t\t  map->equiv_sets[i].equiv, map->const_age);\n-\t}\n-      else if (map->equiv_sets[i].dest == pc_rtx)\n-\tmap->last_pc_value = map->equiv_sets[i].equiv;\n-#ifdef HAVE_cc0\n-      else if (map->equiv_sets[i].dest == cc0_rtx)\n-\tmap->last_cc0_value = map->equiv_sets[i].equiv;\n-#endif\n-    }\n-}\n-\f\n-/* Substitute known constants for pseudo regs in the contents of LOC,\n-   which are part of INSN.\n-   If INSN is zero, the substitution should always be done (this is used to\n-   update DECL_RTL).\n-   These changes are taken out by try_constants if the result is not valid.\n-\n-   Note that we are more concerned with determining when the result of a SET\n-   is a constant, for further propagation, than actually inserting constants\n-   into insns; cse will do the latter task better.\n-\n-   This function is also used to adjust address of items previously addressed\n-   via the virtual stack variable or virtual incoming arguments registers.\n-\n-   If MEMONLY is nonzero, only make changes inside a MEM.  */\n-\n-static void\n-subst_constants (rtx *loc, rtx insn, struct inline_remap *map, int memonly)\n-{\n-  rtx x = *loc;\n-  int i, j;\n-  enum rtx_code code;\n-  const char *format_ptr;\n-  int num_changes = num_validated_changes ();\n-  rtx new = 0;\n-  enum machine_mode op0_mode = MAX_MACHINE_MODE;\n-\n-  code = GET_CODE (x);\n-\n-  switch (code)\n-    {\n-    case PC:\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case CONST_VECTOR:\n-    case SYMBOL_REF:\n-    case CONST:\n-    case LABEL_REF:\n-    case ADDRESS:\n-      return;\n-\n-#ifdef HAVE_cc0\n-    case CC0:\n-      if (! memonly)\n-\tvalidate_change (insn, loc, map->last_cc0_value, 1);\n-      return;\n-#endif\n-\n-    case USE:\n-    case CLOBBER:\n-      /* The only thing we can do with a USE or CLOBBER is possibly do\n-\t some substitutions in a MEM within it.  */\n-      if (MEM_P (XEXP (x, 0)))\n-\tsubst_constants (&XEXP (XEXP (x, 0), 0), insn, map, 0);\n-      return;\n-\n-    case REG:\n-      /* Substitute for parms and known constants.  Don't replace\n-\t hard regs used as user variables with constants.  */\n-      if (! memonly)\n-\t{\n-\t  int regno = REGNO (x);\n-\t  struct const_equiv_data *p;\n-\n-\t  if (! (regno < FIRST_PSEUDO_REGISTER && REG_USERVAR_P (x))\n-\t      && (size_t) regno < VARRAY_SIZE (map->const_equiv_varray)\n-\t      && (p = &VARRAY_CONST_EQUIV (map->const_equiv_varray, regno),\n-\t\t  p->rtx != 0)\n-\t      && p->age >= map->const_age)\n-\t    validate_change (insn, loc, p->rtx, 1);\n-\t}\n-      return;\n-\n-    case SUBREG:\n-      /* SUBREG applied to something other than a reg\n-\t should be treated as ordinary, since that must\n-\t be a special hack and we don't know how to treat it specially.\n-\t Consider for example mulsidi3 in m68k.md.\n-\t Ordinary SUBREG of a REG needs this special treatment.  */\n-      if (! memonly && REG_P (SUBREG_REG (x)))\n-\t{\n-\t  rtx inner = SUBREG_REG (x);\n-\t  rtx new = 0;\n-\n-\t  /* We can't call subst_constants on &SUBREG_REG (x) because any\n-\t     constant or SUBREG wouldn't be valid inside our SUBEG.  Instead,\n-\t     see what is inside, try to form the new SUBREG and see if that is\n-\t     valid.  We handle two cases: extracting a full word in an\n-\t     integral mode and extracting the low part.  */\n-\t  subst_constants (&inner, NULL_RTX, map, 0);\n-\t  new = simplify_gen_subreg (GET_MODE (x), inner,\n-\t\t\t\t     GET_MODE (SUBREG_REG (x)),\n-\t\t\t\t     SUBREG_BYTE (x));\n-\n-\t  if (new)\n-\t    validate_change (insn, loc, new, 1);\n-\t  else\n-\t    cancel_changes (num_changes);\n-\n-\t  return;\n-\t}\n-      break;\n-\n-    case MEM:\n-      subst_constants (&XEXP (x, 0), insn, map, 0);\n-\n-      /* If a memory address got spoiled, change it back.  */\n-      if (! memonly && insn != 0 && num_validated_changes () != num_changes\n-\t  && ! memory_address_p (GET_MODE (x), XEXP (x, 0)))\n-\tcancel_changes (num_changes);\n-      return;\n-\n-    case SET:\n-      {\n-\t/* Substitute constants in our source, and in any arguments to a\n-\t   complex (e..g, ZERO_EXTRACT) destination, but not in the destination\n-\t   itself.  */\n-\trtx *dest_loc = &SET_DEST (x);\n-\trtx dest = *dest_loc;\n-\trtx src, tem;\n-\tenum machine_mode compare_mode = VOIDmode;\n-\n-\t/* If SET_SRC is a COMPARE which subst_constants would turn into\n-\t   COMPARE of 2 VOIDmode constants, note the mode in which comparison\n-\t   is to be done.  */\n-\tif (GET_CODE (SET_SRC (x)) == COMPARE)\n-\t  {\n-\t    src = SET_SRC (x);\n-\t    if (GET_MODE_CLASS (GET_MODE (src)) == MODE_CC\n-\t\t|| CC0_P (dest))\n-\t      {\n-\t\tcompare_mode = GET_MODE (XEXP (src, 0));\n-\t\tif (compare_mode == VOIDmode)\n-\t\t  compare_mode = GET_MODE (XEXP (src, 1));\n-\t      }\n-\t  }\n-\n-\tsubst_constants (&SET_SRC (x), insn, map, memonly);\n-\tsrc = SET_SRC (x);\n-\n-\twhile (GET_CODE (*dest_loc) == ZERO_EXTRACT\n-\t       || GET_CODE (*dest_loc) == SUBREG\n-\t       || GET_CODE (*dest_loc) == STRICT_LOW_PART)\n-\t  {\n-\t    if (GET_CODE (*dest_loc) == ZERO_EXTRACT)\n-\t      {\n-\t\tsubst_constants (&XEXP (*dest_loc, 1), insn, map, memonly);\n-\t\tsubst_constants (&XEXP (*dest_loc, 2), insn, map, memonly);\n-\t      }\n-\t    dest_loc = &XEXP (*dest_loc, 0);\n-\t  }\n-\n-\t/* Do substitute in the address of a destination in memory.  */\n-\tif (MEM_P (*dest_loc))\n-\t  subst_constants (&XEXP (*dest_loc, 0), insn, map, 0);\n-\n-\t/* Check for the case of DEST a SUBREG, both it and the underlying\n-\t   register are less than one word, and the SUBREG has the wider mode.\n-\t   In the case, we are really setting the underlying register to the\n-\t   source converted to the mode of DEST.  So indicate that.  */\n-\tif (GET_CODE (dest) == SUBREG\n-\t    && GET_MODE_SIZE (GET_MODE (dest)) <= UNITS_PER_WORD\n-\t    && GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest))) <= UNITS_PER_WORD\n-\t    && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest)))\n-\t\t      <= GET_MODE_SIZE (GET_MODE (dest)))\n-\t    && (tem = gen_lowpart_if_possible (GET_MODE (SUBREG_REG (dest)),\n-\t\t\t\t\t       src)))\n-\t  src = tem, dest = SUBREG_REG (dest);\n-\n-\t/* If storing a recognizable value save it for later recording.  */\n-\tif ((map->num_sets < MAX_RECOG_OPERANDS)\n-\t    && (CONSTANT_P (src)\n-\t\t|| (REG_P (src)\n-\t\t    && (REGNO (src) == VIRTUAL_INCOMING_ARGS_REGNUM\n-\t\t\t|| REGNO (src) == VIRTUAL_STACK_VARS_REGNUM))\n-\t\t|| (GET_CODE (src) == PLUS\n-\t\t    && REG_P (XEXP (src, 0))\n-\t\t    && (REGNO (XEXP (src, 0)) == VIRTUAL_INCOMING_ARGS_REGNUM\n-\t\t\t|| REGNO (XEXP (src, 0)) == VIRTUAL_STACK_VARS_REGNUM)\n-\t\t    && CONSTANT_P (XEXP (src, 1)))\n-\t\t|| GET_CODE (src) == COMPARE\n-\t\t|| CC0_P (dest)\n-\t\t|| (dest == pc_rtx\n-\t\t    && (src == pc_rtx || GET_CODE (src) == RETURN\n-\t\t\t|| GET_CODE (src) == LABEL_REF))))\n-\t  {\n-\t    /* Normally, this copy won't do anything.  But, if SRC is a COMPARE\n-\t       it will cause us to save the COMPARE with any constants\n-\t       substituted, which is what we want for later.  */\n-\t    rtx src_copy = copy_rtx (src);\n-\t    map->equiv_sets[map->num_sets].equiv = src_copy;\n-\t    map->equiv_sets[map->num_sets++].dest = dest;\n-\t    if (compare_mode != VOIDmode\n-\t\t&& GET_CODE (src) == COMPARE\n-\t\t&& (GET_MODE_CLASS (GET_MODE (src)) == MODE_CC\n-\t\t    || CC0_P (dest))\n-\t\t&& GET_MODE (XEXP (src, 0)) == VOIDmode\n-\t\t&& GET_MODE (XEXP (src, 1)) == VOIDmode)\n-\t      {\n-\t\tmap->compare_src = src_copy;\n-\t\tmap->compare_mode = compare_mode;\n-\t      }\n-\t  }\n-      }\n-      return;\n-\n-    default:\n-      break;\n-    }\n-\n-  format_ptr = GET_RTX_FORMAT (code);\n-\n-  /* If the first operand is an expression, save its mode for later.  */\n-  if (*format_ptr == 'e')\n-    op0_mode = GET_MODE (XEXP (x, 0));\n-\n-  for (i = 0; i < GET_RTX_LENGTH (code); i++)\n-    {\n-      switch (*format_ptr++)\n-\t{\n-\tcase '0':\n-\t  break;\n-\n-\tcase 'e':\n-\t  if (XEXP (x, i))\n-\t    subst_constants (&XEXP (x, i), insn, map, memonly);\n-\t  break;\n-\n-\tcase 'u':\n-\tcase 'i':\n-\tcase 's':\n-\tcase 'w':\n-\tcase 'n':\n-\tcase 't':\n-\tcase 'B':\n-\t  break;\n-\n-\tcase 'E':\n-\t  if (XVEC (x, i) != NULL && XVECLEN (x, i) != 0)\n-\t    for (j = 0; j < XVECLEN (x, i); j++)\n-\t      subst_constants (&XVECEXP (x, i, j), insn, map, memonly);\n-\n-\t  break;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n-    }\n-\n-  /* If this is a commutative operation, move a constant to the second\n-     operand unless the second operand is already a CONST_INT.  */\n-  if (! memonly\n-      && (GET_RTX_CLASS (code) == RTX_COMM_ARITH\n-\t  || GET_RTX_CLASS (code) == RTX_COMM_COMPARE)\n-      && CONSTANT_P (XEXP (x, 0)) && GET_CODE (XEXP (x, 1)) != CONST_INT)\n-    {\n-      rtx tem = XEXP (x, 0);\n-      validate_change (insn, &XEXP (x, 0), XEXP (x, 1), 1);\n-      validate_change (insn, &XEXP (x, 1), tem, 1);\n-    }\n-\n-  /* Simplify the expression in case we put in some constants.  */\n-  if (! memonly)\n-    switch (GET_RTX_CLASS (code))\n-      {\n-      case RTX_UNARY:\n-\tif (op0_mode == MAX_MACHINE_MODE)\n-\t  abort ();\n-\tnew = simplify_unary_operation (code, GET_MODE (x),\n-\t\t\t\t\tXEXP (x, 0), op0_mode);\n-\tbreak;\n-\n-      case RTX_COMPARE:\n-      case RTX_COMM_COMPARE:\n-\t{\n-\t  enum machine_mode op_mode = GET_MODE (XEXP (x, 0));\n-\n-\t  if (op_mode == VOIDmode)\n-\t    op_mode = GET_MODE (XEXP (x, 1));\n-\n-\t  new = simplify_relational_operation (code, GET_MODE (x), op_mode,\n-\t\t\t\t\t       XEXP (x, 0), XEXP (x, 1));\n-\t  break;\n-\t}\n-\n-      case RTX_BIN_ARITH:\n-      case RTX_COMM_ARITH:\n-\tnew = simplify_binary_operation (code, GET_MODE (x),\n-\t\t\t\t\t XEXP (x, 0), XEXP (x, 1));\n-\tbreak;\n-\n-      case RTX_BITFIELD_OPS:\n-      case RTX_TERNARY:\n-\tif (op0_mode == MAX_MACHINE_MODE)\n-\t  abort ();\n-\n-\tif (code == IF_THEN_ELSE)\n-\t  {\n-\t    rtx op0 = XEXP (x, 0);\n-\n-\t    if (COMPARISON_P (op0)\n-\t\t&& GET_MODE (op0) == VOIDmode\n-\t\t&& ! side_effects_p (op0)\n-\t\t&& XEXP (op0, 0) == map->compare_src\n-\t\t&& GET_MODE (XEXP (op0, 1)) == VOIDmode)\n-\t      {\n-\t\t/* We have compare of two VOIDmode constants for which\n-\t\t   we recorded the comparison mode.  */\n-\t\trtx tem =\n-\t\t  simplify_gen_relational (GET_CODE (op0), GET_MODE (op0),\n-\t\t\t\t\t   map->compare_mode, XEXP (op0, 0),\n-\t\t\t\t\t   XEXP (op0, 1));\n-\n-\t\tif (GET_CODE (tem) != CONST_INT)\n-\t\t  new = simplify_ternary_operation (code, GET_MODE (x),\n-\t\t\t\t  \t\t    op0_mode, tem, XEXP (x, 1),\n-\t\t\t\t\t\t    XEXP (x, 2));\n-\t\telse if (tem == const0_rtx)\n-\t\t  new = XEXP (x, 2);\n-\t\telse\n-\t\t  new = XEXP (x, 1);\n-\t      }\n-\t  }\n-\tif (!new)\n-\t  new = simplify_ternary_operation (code, GET_MODE (x), op0_mode,\n-\t\t\t\t\t    XEXP (x, 0), XEXP (x, 1),\n-\t\t\t\t\t    XEXP (x, 2));\n-\tbreak;\n-\n-      default:\n-\tbreak;\n-      }\n-\n-  if (new)\n-    validate_change (insn, loc, new, 1);\n-}\n-\n-/* Show that register modified no longer contain known constants.  We are\n-   called from note_stores with parts of the new insn.  */\n-\n-static void\n-mark_stores (rtx dest, rtx x ATTRIBUTE_UNUSED, void *data ATTRIBUTE_UNUSED)\n-{\n-  int regno = -1;\n-  enum machine_mode mode = VOIDmode;\n-\n-  /* DEST is always the innermost thing set, except in the case of\n-     SUBREGs of hard registers.  */\n-\n-  if (REG_P (dest))\n-    regno = REGNO (dest), mode = GET_MODE (dest);\n-  else if (GET_CODE (dest) == SUBREG && REG_P (SUBREG_REG (dest)))\n-    {\n-      regno = REGNO (SUBREG_REG (dest));\n-      if (regno < FIRST_PSEUDO_REGISTER)\n-\tregno += subreg_regno_offset (REGNO (SUBREG_REG (dest)),\n-\t\t\t\t      GET_MODE (SUBREG_REG (dest)),\n-\t\t\t\t      SUBREG_BYTE (dest),\n-\t\t\t\t      GET_MODE (dest));\n-      mode = GET_MODE (SUBREG_REG (dest));\n-    }\n-\n-  if (regno >= 0)\n-    {\n-      unsigned int uregno = regno;\n-      unsigned int last_reg = (uregno >= FIRST_PSEUDO_REGISTER ? uregno\n-\t\t\t       : uregno + hard_regno_nregs[uregno][mode] - 1);\n-      unsigned int i;\n-\n-      /* Ignore virtual stack var or virtual arg register since those\n-\t are handled separately.  */\n-      if (uregno != VIRTUAL_INCOMING_ARGS_REGNUM\n-\t  && uregno != VIRTUAL_STACK_VARS_REGNUM)\n-\tfor (i = uregno; i <= last_reg; i++)\n-\t  if ((size_t) i < VARRAY_SIZE (global_const_equiv_varray))\n-\t    VARRAY_CONST_EQUIV (global_const_equiv_varray, i).rtx = 0;\n-    }\n-}\n-\f\n /* Given a pointer to some BLOCK node, if the BLOCK_ABSTRACT_ORIGIN for the\n    given BLOCK node is NULL, set the BLOCK_ABSTRACT_ORIGIN for the node so\n    that it points to the node itself, thus indicating that the node is its"}, {"sha": "7ca2951b69216f52793e83ff887cf92fe514c891", "filename": "gcc/integrate.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9772e3f82d2dc90ab56076f31fb29cb8f450da/gcc%2Fintegrate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9772e3f82d2dc90ab56076f31fb29cb8f450da/gcc%2Fintegrate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.h?ref=2a9772e3f82d2dc90ab56076f31fb29cb8f450da", "patch": "@@ -142,8 +142,6 @@ extern tree copy_decl_for_inlining (tree, tree, tree);\n    true otherwise.  */\n extern bool function_attribute_inlinable_p (tree);\n \n-extern void try_constants (rtx, struct inline_remap *);\n-\n /* Return the label indicated.  */\n extern rtx get_label_from_map (struct inline_remap *, int);\n "}]}