{"sha": "9bcb9aae27c7ffe6a74521f951918739d87518ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJjYjlhYWUyN2M3ZmZlNmE3NDUyMWY5NTE5MTg3MzlkODc1MThiYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-07-06T23:23:46Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-07-06T23:23:46Z"}, "message": "call.c: Fix comment formatting.\n\n\t* call.c: Fix comment formatting.\n\t* class.c: Likewise.\n\t* cp-tree.h: Likewise.\n\t* decl.c: Likewise.\n\t* decl2.c: Likewise.\n\t* error.c: Likewise.\n\t* method.c: Likewise.\n\t* name-lookup.c: Likewise.\n\t* parser.c: Likewise.\n\t* pt.c: Likewise.\n\t* rtti.c: Likewise.\n\t* search.c: Likewise.\n\t* typeck.c: Likewise.\n\nFrom-SVN: r69022", "tree": {"sha": "b9ad3c88816bfbd4d57c6c8b46f31b765727c245", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9ad3c88816bfbd4d57c6c8b46f31b765727c245"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bcb9aae27c7ffe6a74521f951918739d87518ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bcb9aae27c7ffe6a74521f951918739d87518ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bcb9aae27c7ffe6a74521f951918739d87518ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bcb9aae27c7ffe6a74521f951918739d87518ba/comments", "author": null, "committer": null, "parents": [{"sha": "2a43945fa59a5d450f24b2c47c35c8fef8f959a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a43945fa59a5d450f24b2c47c35c8fef8f959a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a43945fa59a5d450f24b2c47c35c8fef8f959a8"}], "stats": {"total": 126, "additions": 71, "deletions": 55}, "files": [{"sha": "dd271350d86101ae0ab489ceacc14a21271402df", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9bcb9aae27c7ffe6a74521f951918739d87518ba", "patch": "@@ -1,3 +1,19 @@\n+2003-07-06  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* call.c: Fix comment formatting.\n+\t* class.c: Likewise.\n+\t* cp-tree.h: Likewise.\n+\t* decl.c: Likewise.\n+\t* decl2.c: Likewise.\n+\t* error.c: Likewise.\n+\t* method.c: Likewise.\n+\t* name-lookup.c: Likewise.\n+\t* parser.c: Likewise.\n+\t* pt.c: Likewise.\n+\t* rtti.c: Likewise.\n+\t* search.c: Likewise.\n+\t* typeck.c: Likewise.\n+\n 2003-07-06  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/11345"}, {"sha": "29c00de01eb8733a75977c78d994a55b33302a4e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=9bcb9aae27c7ffe6a74521f951918739d87518ba", "patch": "@@ -2726,7 +2726,7 @@ build_user_type_conversion (tree totype, tree expr, int flags)\n \n /* Find the possibly overloaded set of functions corresponding to a\n    call of the form SCOPE::NAME (...). NAME might be a\n-   TEMPLATE_ID_EXPR, OVERLOAD, _DECL, IDENTIFIER_NODE or LOOKUP_EXPR. */\n+   TEMPLATE_ID_EXPR, OVERLOAD, _DECL, IDENTIFIER_NODE or LOOKUP_EXPR.  */\n \n tree\n resolve_scoped_fn_name (tree scope, tree name)\n@@ -2916,7 +2916,7 @@ build_new_function_call (tree fn, tree args)\n    required by the allocation, and is updated if that is changed here.\n    *COOKIE_SIZE is non-NULL if a cookie should be used.  If this\n    function determines that no cookie should be used, after all,\n-   *COOKIE_SIZE is set to NULL_TREE. */\n+   *COOKIE_SIZE is set to NULL_TREE.  */\n \n tree\n build_operator_new_call (tree fnname, tree args, tree *size, tree *cookie_size)\n@@ -5786,7 +5786,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n       \n       /* We don't want to complain about `X::operator T1 ()'\n \t beating `X::operator T2 () const', when T2 is a no less\n-\t cv-qualified version of T1. */\n+\t cv-qualified version of T1.  */\n       if (DECL_CONTEXT (w->fn) == DECL_CONTEXT (l->fn)\n \t  && !DECL_CONSTRUCTOR_P (w->fn) && !DECL_CONSTRUCTOR_P (l->fn))\n \t{"}, {"sha": "00e66078984be365052934e53d0389963f86a6be", "filename": "gcc/cp/class.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9bcb9aae27c7ffe6a74521f951918739d87518ba", "patch": "@@ -2216,7 +2216,7 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n     return;\n   overrider_target = overrider_fn = TREE_PURPOSE (overrider);\n   \n-  /* Check for adjusting covariant return types. */\n+  /* Check for adjusting covariant return types.  */\n   over_return = TREE_TYPE (TREE_TYPE (overrider_target));\n   base_return = TREE_TYPE (TREE_TYPE (target_fn));\n   \n@@ -2242,7 +2242,7 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n       if (!virtual_offset)\n \t{\n \t  /* There was no existing virtual thunk (which takes\n-\t     precidence). */\n+\t     precidence).  */\n \t  tree thunk_binfo;\n \t  base_kind kind;\n \t  \n@@ -2279,7 +2279,7 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n       if (fixed_offset || virtual_offset)\n \t/* Replace the overriding function with a covariant thunk.  We\n \t   will emit the overriding function in its own slot as\n-\t   well. */\n+\t   well.  */\n \toverrider_fn = make_thunk (overrider_target, /*this_adjusting=*/0,\n \t\t\t\t   fixed_offset, virtual_offset);\n     }\n@@ -5061,7 +5061,7 @@ finish_struct_1 (tree t)\n       CLASSTYPE_KEY_METHOD (t) = key_method (t);\n \n       /* If a polymorphic class has no key method, we may emit the vtable\n-\t in every translation unit where the class definition appears. */\n+\t in every translation unit where the class definition appears.  */\n       if (CLASSTYPE_KEY_METHOD (t) == NULL_TREE)\n \tkeyed_classes = tree_cons (NULL_TREE, t, keyed_classes);\n     }\n@@ -5622,7 +5622,7 @@ currently_open_derived_class (tree t)\n {\n   int i;\n \n-  /* The bases of a dependent type are unknown. */\n+  /* The bases of a dependent type are unknown.  */\n   if (dependent_type_p (t))\n     return NULL_TREE;\n \n@@ -6522,7 +6522,7 @@ maybe_indent_hierarchy (FILE * stream, int indent, int indented_p)\n /* Dump the offsets of all the bases rooted at BINFO to STREAM.\n    INDENT should be zero when called from the top level; it is\n    incremented recursively.  IGO indicates the next expected BINFO in\n-   inheritance graph ordering. */\n+   inheritance graph ordering.  */\n \n static tree\n dump_class_hierarchy_r (FILE *stream,"}, {"sha": "85815a2c43d5b1009bfcce776c47746d7c88feeb", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9bcb9aae27c7ffe6a74521f951918739d87518ba", "patch": "@@ -1470,7 +1470,7 @@ struct lang_type GTY(())\n #define BINFO_VTABLE_PATH_MARKED(NODE) TREE_LANG_FLAG_3 (NODE)\n \n /* Nonzero means B (a BINFO) has its own vtable.  Any copies will not\n-   have this flag set. */\n+   have this flag set.  */\n #define BINFO_NEW_VTABLE_MARKED(B) (TREE_LANG_FLAG_4 (B))\n \n /* Any subobject that needs a new vtable must have a vptr and must not\n@@ -1691,7 +1691,7 @@ struct lang_decl GTY(())\n \t   DECL_THIS_THUNK_P does not hold, this is DECL_THUNKS. Both\n \t   this pointer and result pointer adjusting thunks are\n \t   chained here.  This pointer thunks to return pointer thunks\n-\t   will be chained on the return pointer thunk. */\n+\t   will be chained on the return pointer thunk.  */\n \ttree context;\n \n \t/* In a FUNCTION_DECL, this is DECL_CLONED_FUNCTION.  */\n@@ -1911,7 +1911,7 @@ struct lang_decl GTY(())\n \n /* Nonzero if the DECL was initialized in the class definition itself,\n    rather than outside the class.  This is used for both static member\n-   VAR_DECLS, and FUNTION_DECLS that are defined in the class. */\n+   VAR_DECLS, and FUNTION_DECLS that are defined in the class.  */\n #define DECL_INITIALIZED_IN_CLASS_P(DECL) \\\n  (DECL_LANG_SPECIFIC (DECL)->decl_flags.initialized_in_class)\n \n@@ -2966,7 +2966,7 @@ typedef enum tmpl_spec_kind {\n /* The various kinds of access.  BINFO_ACCESS depends on these being\n    two bit quantities.  The numerical values are important; they are\n    used to initialize RTTI data structures, so changing them changes\n-   the ABI.   */\n+   the ABI.  */\n typedef enum access_kind {\n   ak_none = 0,             /* Inaccessible.  */\n   ak_public = 1,           /* Accessible, as a `public' thing.  */\n@@ -3989,7 +3989,7 @@ extern void init_repo (const char *);\n extern void finish_repo (void);\n \n /* in rtti.c */\n-/* A varray of all tinfo decls that haven't been emitted yet. */\n+/* A varray of all tinfo decls that haven't been emitted yet.  */\n extern GTY(()) varray_type unemitted_tinfo_decls;\n \n extern void init_rtti_processing (void);"}, {"sha": "c62e004117a00e69527111cc7d54b8afea6695ac", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9bcb9aae27c7ffe6a74521f951918739d87518ba", "patch": "@@ -2377,7 +2377,7 @@ identifier_type_value (tree id)\n   if (REAL_IDENTIFIER_TYPE_VALUE (id) != global_type_node)\n     POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, REAL_IDENTIFIER_TYPE_VALUE (id));\n   /* Have to search for it. It must be on the global level, now.\n-     Ask lookup_name not to return non-types. */\n+     Ask lookup_name not to return non-types.  */\n   id = lookup_name_real (id, 2, 1, 0, LOOKUP_COMPLAIN);\n   if (id)\n     POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, TREE_TYPE (id));"}, {"sha": "661786d036cc8fed3b7b78fff0ab9872f0ddee7a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=9bcb9aae27c7ffe6a74521f951918739d87518ba", "patch": "@@ -883,7 +883,7 @@ grokfield (tree declarator, tree declspecs, tree init, tree asmspec_tree,\n   if (value == void_type_node)\n     return value;\n \n-  /* Pass friend decls back. */\n+  /* Pass friend decls back.  */\n   if ((TREE_CODE (value) == FUNCTION_DECL\n        || TREE_CODE (value) == TEMPLATE_DECL)\n       && DECL_CONTEXT (value) != current_class_type)\n@@ -2641,7 +2641,7 @@ finish_file ()\n   \t the virtual table for a template class may cause the\n  \t instantiation of members of that class.  If we write out\n  \t vtables then we remove the class from our list so we don't\n- \t have to look at it again. */\n+ \t have to look at it again.  */\n  \n       while (keyed_classes != NULL_TREE\n  \t     && maybe_emit_vtables (TREE_VALUE (keyed_classes)))\n@@ -2674,7 +2674,7 @@ finish_file ()\n  \t cause other variables to be needed.  We stick new elements\n  \t (and old elements that we may need to reconsider) at the end\n  \t of the array, then shift them back to the beginning once we're\n- \t done. */\n+ \t done.  */\n   \n       n_old = VARRAY_ACTIVE_SIZE (unemitted_tinfo_decls);\n       for (i = 0; i < n_old; ++i)\n@@ -2688,7 +2688,7 @@ finish_file ()\n   \n       /* The only elements we want to keep are the new ones.  Copy\n   \t them to the beginning of the array, then get rid of the\n-  \t leftovers. */\n+  \t leftovers.  */\n       n_new = VARRAY_ACTIVE_SIZE (unemitted_tinfo_decls) - n_old;\n       memmove (&VARRAY_TREE (unemitted_tinfo_decls, 0),\n   \t       &VARRAY_TREE (unemitted_tinfo_decls, n_old),\n@@ -2851,7 +2851,7 @@ finish_file ()\n     } \n   while (reconsider);\n \n-  /* All used inline functions must have a definition at this point. */\n+  /* All used inline functions must have a definition at this point.  */\n   for (i = 0; i < deferred_fns_used; ++i)\n     {\n       tree decl = VARRAY_TREE (deferred_fns, i);\n@@ -4304,7 +4304,7 @@ validate_nonmember_using_decl (tree decl, tree *scope, tree *name)\n       return NULL_TREE;\n     }\n   *name = DECL_NAME (decl);\n-  /* Make a USING_DECL. */\n+  /* Make a USING_DECL.  */\n   return push_using_decl (*scope, *name);\n }\n "}, {"sha": "17dc1185cdbe34157f629d0f438ff93a261bde9b", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=9bcb9aae27c7ffe6a74521f951918739d87518ba", "patch": "@@ -1514,7 +1514,7 @@ dump_expr (tree t, int flags)\n     case COMPOUND_EXPR:\n       print_left_paren (scratch_buffer);\n       /* Within templates, a COMPOUND_EXPR has only one operand,\n-         containing a TREE_LIST of the two operands. */\n+         containing a TREE_LIST of the two operands.  */\n       if (TREE_CODE (TREE_OPERAND (t, 0)) == TREE_LIST)\n       {\n         if (TREE_OPERAND (t, 1))"}, {"sha": "a0d8b63c97216469502798e07abf44d96233c229", "filename": "gcc/cp/method.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=9bcb9aae27c7ffe6a74521f951918739d87518ba", "patch": "@@ -218,7 +218,7 @@ make_thunk (tree function, bool this_adjusting,\n   tree thunk;\n   \n   my_friendly_assert (TREE_CODE (function) == FUNCTION_DECL, 20021025);\n-  /* We can have this thunks to covariant thunks, but not vice versa. */\n+  /* We can have this thunks to covariant thunks, but not vice versa.  */\n   my_friendly_assert (!DECL_THIS_THUNK_P (function), 20021127);\n   \n   /* Scale the VIRTUAL_OFFSET to be in terms of bytes.  */\n@@ -233,7 +233,7 @@ make_thunk (tree function, bool this_adjusting,\n   \n   /* See if we already have the thunk in question.  For this_adjusting\n      thunks VIRTUAL_OFFSET will be an INTEGER_CST, for covariant thunks it\n-     will be a BINFO. */\n+     will be a BINFO.  */\n   for (thunk = DECL_THUNKS (function); thunk; thunk = TREE_CHAIN (thunk))\n     if (DECL_THIS_THUNK_P (thunk) == this_adjusting\n  \t&& THUNK_FIXED_OFFSET (thunk) == d\n@@ -313,7 +313,7 @@ finish_thunk (tree thunk)\n /* Adjust PTR by the constant FIXED_OFFSET, and by the vtable\n    offset indicated by VIRTUAL_OFFSET, if that is\n    non-null. THIS_ADJUSTING is nonzero for a this adjusting thunk and\n-   zero for a result adjusting thunk. */\n+   zero for a result adjusting thunk.  */\n \n static tree\n thunk_adjust (tree ptr, bool this_adjusting,\n@@ -417,7 +417,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n   HOST_WIDE_INT fixed_offset, virtual_value;\n   bool this_adjusting = DECL_THIS_THUNK_P (thunk_fndecl);\n \n-  /* We should have called finish_thunk to give it a name. */\n+  /* We should have called finish_thunk to give it a name.  */\n   my_friendly_assert (DECL_NAME (thunk_fndecl), 20021127);\n \n   if (TREE_ASM_WRITTEN (thunk_fndecl))"}, {"sha": "1a1a431c7888aa1054e3f2bb2afd354cbb86b0bd", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=9bcb9aae27c7ffe6a74521f951918739d87518ba", "patch": "@@ -90,7 +90,7 @@ binding_table_construct (binding_table table, size_t chain_count)\n     (table->chain_count * sizeof (binding_entry));\n }\n \n-/* Free TABLE by making its entries ready for reuse. */\n+/* Free TABLE by making its entries ready for reuse.  */\n void\n binding_table_free (binding_table table)\n {"}, {"sha": "1fd2ead6ab9a48f579644d7442ec3c64008e0857", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=9bcb9aae27c7ffe6a74521f951918739d87518ba", "patch": "@@ -115,7 +115,7 @@ typedef struct cp_token_cache GTY (())\n   cp_token_block *last;\n } cp_token_cache;\n \n-/* Prototypes. */\n+/* Prototypes.  */\n \n static cp_token_cache *cp_token_cache_new \n   (void);\n@@ -1065,7 +1065,7 @@ typedef enum cp_parser_id_kind\n \n typedef enum cp_parser_declarator_kind\n {\n-  /* We want an abstract declartor. */\n+  /* We want an abstract declartor.  */\n   CP_PARSER_DECLARATOR_ABSTRACT,\n   /* We want a named declarator.  */\n   CP_PARSER_DECLARATOR_NAMED,\n@@ -1264,7 +1264,7 @@ typedef struct cp_parser GTY(())\n      processing.\n \n      These lists can only be processed once the outermost class being\n-     defined is complete. */\n+     defined is complete.  */\n   tree unparsed_functions_queues;\n \n   /* The number of classes whose definitions are currently in\n@@ -2439,7 +2439,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t  cp_parser_error (parser, \"expected primary-expression\");\n \t  return error_mark_node;\n \t}\n-      /* Fall through. */\n+      /* Fall through.  */\n \n       /* An id-expression can start with either an identifier, a\n \t `::' as the beginning of a qualified-id, or the \"operator\"\n@@ -2748,7 +2748,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t/* Const variables or static data members of integral\n \t\t   or enumeration types initialized with constant\n                    expressions (or dependent expressions - in this case\n-                   the check will be done at instantiation time). */\n+                   the check will be done at instantiation time).  */\n \t\t&& !(TREE_CODE (decl) == VAR_DECL\n \t\t     && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (decl))\n \t\t     && DECL_INITIAL (decl)\n@@ -4240,7 +4240,7 @@ cp_parser_pseudo_destructor_name (cp_parser* parser,\n       cp_parser_require (parser, CPP_SCOPE, \"`::'\");\n     }\n   /* If the next token is not a `~', then there might be some\n-     additional qualification. */\n+     additional qualification.  */\n   else if (cp_lexer_next_token_is_not (parser->lexer, CPP_COMPL))\n     {\n       /* Look for the type-name.  */\n@@ -4313,7 +4313,7 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p)\n \t  {\n \t    tree operand;\n \t    \n-\t    /* Consume the `sizeof' token.   */\n+\t    /* Consume the `sizeof' token.  */\n \t    cp_lexer_consume_token (parser->lexer);\n \t    /* Parse the operand.  */\n \t    operand = cp_parser_sizeof_operand (parser, keyword);\n@@ -6465,7 +6465,7 @@ cp_parser_block_declaration (cp_parser *parser,\n      init-declarator-list , init-declarator \n \n    If FUNCTION_DEFINITION_ALLOWED_P is TRUE, then we also recognize a\n-   function-definition as a simple-declaration.   */\n+   function-definition as a simple-declaration.  */\n \n static void\n cp_parser_simple_declaration (cp_parser* parser, \n@@ -8877,7 +8877,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \n \t     Also, `new struct S' or `sizeof (struct S)' never results in the\n \t     definition of a new type; a new type can only be declared in a\n-\t     declaration context.   */\n+\t     declaration context.  */\n \n \t  type = xref_tag (tag_type, identifier, \n \t\t\t   /*attributes=*/NULL_TREE,\n@@ -9634,7 +9634,7 @@ cp_parser_init_declarator (cp_parser* parser,\n \n       /* If the entity being declared is a function, pretend that we\n \t are in its scope.  If it is a `friend', it may have access to\n-\t things that would not otherwise be accessible. */\n+\t things that would not otherwise be accessible.  */\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n \t{\n \t  saved_current_function_decl = current_function_decl;\n@@ -9987,7 +9987,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      \n \t      goto handle_declarator;\n \t    }\n-\t  /* Otherwise, we must be done. */\n+\t  /* Otherwise, we must be done.  */\n \t  else\n \t    break;\n \t}\n@@ -11179,7 +11179,7 @@ cp_parser_initializer_clause (cp_parser* parser)\n \n    Returns a TREE_LIST.  The TREE_VALUE of each node is an expression\n    for the initializer.  If the TREE_PURPOSE is non-NULL, it is the\n-   IDENTIFIER_NODE naming the field to initialize.   */\n+   IDENTIFIER_NODE naming the field to initialize.  */\n \n static tree\n cp_parser_initializer_list (cp_parser* parser)\n@@ -11413,7 +11413,7 @@ cp_parser_class_specifier (cp_parser* parser)\n   /* Start the class.  */\n   type = begin_class_definition (type);\n   if (type == error_mark_node)\n-    /* If the type is erroneous, skip the entire body of the class. */\n+    /* If the type is erroneous, skip the entire body of the class.  */\n     cp_parser_skip_to_closing_brace (parser);\n   else\n     /* Parse the member-specification.  */"}, {"sha": "af3b55602962dd2c04362dd172520c12ffb1a7bb", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9bcb9aae27c7ffe6a74521f951918739d87518ba", "patch": "@@ -1009,7 +1009,7 @@ register_specialization (tree spec, tree tmpl, tree args)\n \t\t  if (!duplicate_decls (spec, fn) && DECL_INITIAL (spec))\n \t\t    /* Dup decl failed, but this is a new\n \t\t       definition. Set the line number so any errors\n-\t\t       match this new definition. */\n+\t\t       match this new definition.  */\n \t\t    DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (spec);\n \t\t  \n \t\t  return fn;\n@@ -7171,7 +7171,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t   class, rather than the instantiated class.  \n \t   \n \t   In addition, lookups that were not ambiguous before may be\n-\t   ambiguous now.  Therefore, we perform the lookup again. */\n+\t   ambiguous now.  Therefore, we perform the lookup again.  */\n \tqualifying_scope = BINFO_TYPE (BASELINK_ACCESS_BINFO (t));\n \tfns = BASELINK_FUNCTIONS (t);\n \tif (TREE_CODE (fns) == TEMPLATE_ID_EXPR)\n@@ -8319,7 +8319,7 @@ tsubst_copy_and_build (tree t,\n /* Verify that the instantiated ARGS are valid. For type arguments,\n    make sure that the type's linkage is ok. For non-type arguments,\n    make sure they are constants if they are integral or enumerations.\n-   Emit an error under control of COMPLAIN, and return TRUE on error. */\n+   Emit an error under control of COMPLAIN, and return TRUE on error.  */\n \n static bool\n check_instantiated_args (tree tmpl, tree args, tsubst_flags_t complain)\n@@ -9472,7 +9472,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t{\n \t  /* If ARG is an offset type, we're trying to unify '*T' with\n \t     'U C::*', which is ill-formed. See the comment in the\n-\t     POINTER_TYPE case about this ugliness. */\n+\t     POINTER_TYPE case about this ugliness.  */\n \t  if (TREE_CODE (arg) == OFFSET_TYPE)\n \t    return 1;\n \t  \n@@ -10345,7 +10345,7 @@ mark_class_instantiated (tree t, int extern_p)\n }     \n \n /* Called from do_type_instantiation through binding_table_foreach to\n-   do recursive instantiation for the type bound in ENTRY.   */\n+   do recursive instantiation for the type bound in ENTRY.  */\n static void\n bt_instantiate_type_proc (binding_entry entry, void *data)\n {"}, {"sha": "33745e573242d85a61efa5aa6f0e1e3797d14ba8", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=9bcb9aae27c7ffe6a74521f951918739d87518ba", "patch": "@@ -73,7 +73,7 @@ Boston, MA 02111-1307, USA.  */\n /* The IDENTIFIER_NODE naming the real class.  */\n #define TINFO_REAL_NAME(NODE) TREE_PURPOSE (NODE)\n \n-/* A varray of all tinfo decls that haven't yet been emitted. */\n+/* A varray of all tinfo decls that haven't yet been emitted.  */\n varray_type unemitted_tinfo_decls;\n \n static tree build_headof (tree);\n@@ -373,7 +373,7 @@ get_tinfo_decl (tree type)\n       /* Remember the type it is for.  */\n       TREE_TYPE (name) = type;\n \n-      /* Add decl to the global array of tinfo decls. */\n+      /* Add decl to the global array of tinfo decls.  */\n       my_friendly_assert (unemitted_tinfo_decls != 0, 20030312);\n       VARRAY_PUSH_TREE (unemitted_tinfo_decls, d);\n     }"}, {"sha": "c287dff5cb6f1afdf8fb53f9bfda34013f4be2cc", "filename": "gcc/cp/search.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=9bcb9aae27c7ffe6a74521f951918739d87518ba", "patch": "@@ -1440,7 +1440,7 @@ lookup_fnfields_1 (tree type, tree name)\n \t  tmp = methods[i];\n \t  /* This slot may be empty; we allocate more slots than we\n \t     need.  In that case, the entry we're looking for is\n-\t     closer to the beginning of the list. */\n+\t     closer to the beginning of the list.  */\n \t  if (tmp)\n \t    tmp = DECL_NAME (OVL_CURRENT (tmp));\n \t  if (!tmp || tmp > name)\n@@ -1685,7 +1685,7 @@ check_final_overrider (tree overrider, tree basefn)\n \t   || (TREE_CODE (base_return) == TREE_CODE (over_return)\n \t       && POINTER_TYPE_P (base_return)))\n     {\n-      /* Potentially covariant. */\n+      /* Potentially covariant.  */\n       unsigned base_quals, over_quals;\n       \n       fail = !POINTER_TYPE_P (base_return);\n@@ -1716,7 +1716,7 @@ check_final_overrider (tree overrider, tree basefn)\n \t   converting to void *, or qualification conversion.  */\n \t{\n \t  /* can_convert will permit user defined conversion from a\n-\t     (reference to) class type. We must reject them. */\n+\t     (reference to) class type. We must reject them.  */\n \t  over_return = TREE_TYPE (over_type);\n \t  if (TREE_CODE (over_return) == REFERENCE_TYPE)\n \t    over_return = TREE_TYPE (over_return);\n@@ -2448,7 +2448,7 @@ binfo_via_virtual (tree binfo, tree limit)\n \n /* BINFO is a base binfo in the complete type BINFO_TYPE (HERE).\n    Find the equivalent binfo within whatever graph HERE is located.\n-   This is the inverse of original_binfo. */\n+   This is the inverse of original_binfo.  */\n \n tree\n copied_binfo (tree binfo, tree here)\n@@ -2499,7 +2499,7 @@ copied_binfo (tree binfo, tree here)\n /* BINFO is some base binfo of HERE, within some other\n    hierarchy. Return the equivalent binfo, but in the hierarchy\n    dominated by HERE.  This is the inverse of copied_binfo.  If BINFO\n-   is not a base binfo of HERE, returns NULL_TREE. */\n+   is not a base binfo of HERE, returns NULL_TREE.  */\n \n tree\n original_binfo (tree binfo, tree here)"}, {"sha": "b2a674cd1cc0a45d180c337adef3fd2f471d4f3f", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bcb9aae27c7ffe6a74521f951918739d87518ba/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9bcb9aae27c7ffe6a74521f951918739d87518ba", "patch": "@@ -981,7 +981,7 @@ comptypes (tree t1, tree t2, int strict)\n       return compparms (TYPE_ARG_TYPES (t1), TYPE_ARG_TYPES (t2));\n \n     case ARRAY_TYPE:\n-      /* Target types must match incl. qualifiers. */\n+      /* Target types must match incl. qualifiers.  */\n       return comp_array_types (t1, t2, !!(strict & COMPARE_REDECLARATION));\n \n     case TEMPLATE_TYPE_PARM:\n@@ -2975,12 +2975,12 @@ build_template_expr (enum tree_code code, tree op0, tree op1, tree op2)\n \t    case MINUS_EXPR:\n \t      /* FIXME: Be careful of special pointer-arithmetic\n \t\t cases.  */\n-\t      /* Fall through. */\n+\t      /* Fall through.  */\n \t    case MAX_EXPR:\n \t    case MIN_EXPR:\n \t      /* These are GNU extensions; the result type is computed\n \t\t as it would be for other arithmetic operators.  */\n-\t      /* Fall through. */\n+\t      /* Fall through.  */\n \t    case BIT_AND_EXPR:\n \t    case BIT_XOR_EXPR:\n \t    case BIT_IOR_EXPR:"}]}