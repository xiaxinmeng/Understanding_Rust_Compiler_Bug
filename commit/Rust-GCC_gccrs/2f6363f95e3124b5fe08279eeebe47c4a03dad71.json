{"sha": "2f6363f95e3124b5fe08279eeebe47c4a03dad71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY2MzYzZjk1ZTMxMjRiNWZlMDgyNzllZWViZTQ3YzRhMDNkYWQ3MQ==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2005-02-16T23:11:06Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2005-02-16T23:11:06Z"}, "message": "[multiple changes]\n\n2005-02-16  Mark Wielaard  <mark@klomp.org>\n\n       * Makefile.am (ordinary_java_source_files): Add new files\n       gnu/java/security/ber/BER.java,\n       gnu/java/security/ber/BEREncodingException.java,\n       gnu/java/security/ber/BERReader.java,\n       gnu/java/security/ber/BERValue.java,\n       gnu/java/security/pkcs/PKCS7SignedData.java and\n       gnu/java/security/pkcs/SignerInfo.java.\n       * Makefile.in: Regenerated.\n\n2005-02-16  Casey Marshall  <csm@gnu.org>\n\n       * gnu/java/security/provider/GnuDSAPrivateKey.java\n       (encodedKey): new field.\n       (getFormat): return \"PKCS#8\".\n       (getEncoded): implemented.\n       (toString): check for 'null' values.\n       * gnu/java/security/provider/GnuDSAPublicKey.java\n       (encodedKey): new field.\n       (getFormat): return \"X.509\".\n       (getEncoded): implemented.\n       (toString): check for 'null' values.\n\n2005-02-16  Michael Koch  <konqueror@gmx.de>\n\n       * java/util/jar/JarFile.java: Imports reworked.\n\n2005-02-16  Mark Wielaard  <mark@klomp.org>\n\n       * java/util/jar/JarFile.java (verify): Make package private.\n       (signaturesRead): Likewise.\n       (verified): Likewise.\n       (entryCerts): Likewise.\n       (DEBUG): Likewise.\n       (debug): Likewise.\n       (entries): Construct new JarEnumeration with reference to this.\n       (JarEnumeration): Make static.\n       (JarEnumeration.jarfile): New field.\n       (JarEnumeration.nextElement): Use and synchronize on jarfile.\n       Compare verified value to Boolean.TRUE or Boolean.False only\n       when verify is true.\n       (getEntry): Make synchronized. Compare value of verified to\n       Boolean.TRUE.\n       (getInputStream): Construct EntryInputStream with reference to this.\n       (getManifest): Make synchronized.\n       (EntryInputStream): Make static.\n       (EntryInputStream.jarfile): New field.\n       (EntryInputStream.EntryInputStream): Check if manifest exists,\n       before getting attributes.\n       (eof): Synchronize on jarfile.\n\n2005-02-16  Casey Marshall  <csm@gnu.org>\n\n       * java/util/jar/JarFile.java (verify): return if the jar is signed\n       with an unsupported algorithm.\n\n2005-02-16  Mark Wielaard  <mark@klomp.org>\n\n       * java/util/jar/JarFile.java (EntryInputStream): Add actual\n       InputStream as argument.\n       (getInputStream): Construct a new EntryInputStream with the result of\n       super.getInputStream(entry).\n\n2005-02-16  Casey Marshall  <csm@gnu.org>\n\n       Signed JAR file support.\n       * java/net/URLClassLoader.java\n       (JarURLResource.getCertificates): re-read jar entry to ensure\n       certificates are picked up.\n       (findClass): fill in class `signers' field, too.\n       * java/util/jar/JarFile.java (META_INF): new constant.\n       (PKCS7_DSA_SUFFIX): new constant.\n       (PKCS7_RSA_SUFFIX): new constant.\n       (DIGEST_KEY_SUFFIX): new constant.\n       (SF_SUFFIX): new constant.\n       (MD2_OID): new constant.\n       (MD4_OID): new constant.\n       (MD5_OID): new constant.\n       (SHA1_OID): new constant.\n       (DSA_ENCRYPTION_OID): new constant.\n       (RSA_ENCRYPTION_OID): new constant.\n       (signaturesRead): new field.\n       (verified): new field.\n       (entryCerts): new field.\n       (DEBUG): new constant.\n       (debug): new method.\n       (JarEnumeration.nextElement): fill in entry certificates, read\n       signatures if they haven't been read.\n       (getEntry): likewise.\n       (getInputStream): verify stream if it hasn't been verified yet.\n       (readSignatures): new method.\n       (verify): new method.\n       (verifyHashes): new method.\n       (readManifestEntry): new method.\n       (EntryInputStream): new class.\n       * gnu/java/io/Base64InputStream.java (decode): new class\n       method.\n       * gnu/java/security/der/DERReader.java don't make class\n       final.\n       (in): made protected.\n       (encBuf): likewise.\n       (readLength): likewise.\n       * gnu/java/security/ber/BER.java,\n       * gnu/java/security/ber/BEREncodingException.java,\n       * gnu/java/security/ber/BERReader.java,\n       * gnu/java/security/ber/BERValue.java,\n       * gnu/java/security/pkcs/PKCS7SignedData.java,\n       * gnu/java/security/pkcs/SignerInfo.java:\n       new files.\n\nFrom-SVN: r95124", "tree": {"sha": "3319a290dccac2cf50b974a8576c06ac7b98f424", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3319a290dccac2cf50b974a8576c06ac7b98f424"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f6363f95e3124b5fe08279eeebe47c4a03dad71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f6363f95e3124b5fe08279eeebe47c4a03dad71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f6363f95e3124b5fe08279eeebe47c4a03dad71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f6363f95e3124b5fe08279eeebe47c4a03dad71/comments", "author": null, "committer": null, "parents": [{"sha": "4f2e0d5eccb106b4183ec00195dcf7a65d416692", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f2e0d5eccb106b4183ec00195dcf7a65d416692", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f2e0d5eccb106b4183ec00195dcf7a65d416692"}], "stats": {"total": 2063, "additions": 2010, "deletions": 53}, "files": [{"sha": "f928e364c4b20f206430c96829851e6400a6c4eb", "filename": "libjava/ChangeLog", "status": "modified", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=2f6363f95e3124b5fe08279eeebe47c4a03dad71", "patch": "@@ -1,3 +1,114 @@\n+2005-02-16  Mark Wielaard  <mark@klomp.org>\n+\n+\t* Makefile.am (ordinary_java_source_files): Add new files\n+\tgnu/java/security/ber/BER.java,\n+\tgnu/java/security/ber/BEREncodingException.java,\n+\tgnu/java/security/ber/BERReader.java,\n+\tgnu/java/security/ber/BERValue.java,\n+\tgnu/java/security/pkcs/PKCS7SignedData.java and\n+\tgnu/java/security/pkcs/SignerInfo.java.\n+\t* Makefile.in: Regenerated.\n+\n+2005-02-16  Casey Marshall  <csm@gnu.org>\n+\n+\t* gnu/java/security/provider/GnuDSAPrivateKey.java\n+\t(encodedKey): new field.\n+\t(getFormat): return \"PKCS#8\".\n+\t(getEncoded): implemented.\n+\t(toString): check for 'null' values.\n+\t* gnu/java/security/provider/GnuDSAPublicKey.java\n+\t(encodedKey): new field.\n+\t(getFormat): return \"X.509\".\n+\t(getEncoded): implemented.\n+\t(toString): check for 'null' values.\n+\n+2005-02-16  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/util/jar/JarFile.java: Imports reworked.\n+\n+2005-02-16  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/util/jar/JarFile.java (verify): Make package private.\n+\t(signaturesRead): Likewise.\n+\t(verified): Likewise.\n+\t(entryCerts): Likewise.\n+\t(DEBUG): Likewise.\n+\t(debug): Likewise.\n+\t(entries): Construct new JarEnumeration with reference to this.\n+\t(JarEnumeration): Make static.\n+\t(JarEnumeration.jarfile): New field.\n+\t(JarEnumeration.nextElement): Use and synchronize on jarfile.\n+\tCompare verified value to Boolean.TRUE or Boolean.False only\n+\twhen verify is true.\n+\t(getEntry): Make synchronized. Compare value of verified to\n+\tBoolean.TRUE.\n+\t(getInputStream): Construct EntryInputStream with reference to this.\n+\t(getManifest): Make synchronized.\n+\t(EntryInputStream): Make static.\n+\t(EntryInputStream.jarfile): New field.\n+\t(EntryInputStream.EntryInputStream): Check if manifest exists,\n+\tbefore getting attributes.\n+\t(eof): Synchronize on jarfile.\n+\n+2005-02-16  Casey Marshall  <csm@gnu.org>\n+\n+\t* java/util/jar/JarFile.java (verify): return if the jar is signed\n+\twith an unsupported algorithm.\n+\n+2005-02-16  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/util/jar/JarFile.java (EntryInputStream): Add actual\n+\tInputStream as argument.\n+\t(getInputStream): Construct a new EntryInputStream with the result of\n+\tsuper.getInputStream(entry).\n+\n+2005-02-16  Casey Marshall  <csm@gnu.org>\n+\n+\tSigned JAR file support.\n+\t* java/net/URLClassLoader.java\n+\t(JarURLResource.getCertificates): re-read jar entry to ensure\n+\tcertificates are picked up.\n+\t(findClass): fill in class `signers' field, too.\n+\t* java/util/jar/JarFile.java (META_INF): new constant.\n+\t(PKCS7_DSA_SUFFIX): new constant.\n+\t(PKCS7_RSA_SUFFIX): new constant.\n+\t(DIGEST_KEY_SUFFIX): new constant.\n+\t(SF_SUFFIX): new constant.\n+\t(MD2_OID): new constant.\n+\t(MD4_OID): new constant.\n+\t(MD5_OID): new constant.\n+\t(SHA1_OID): new constant.\n+\t(DSA_ENCRYPTION_OID): new constant.\n+\t(RSA_ENCRYPTION_OID): new constant.\n+\t(signaturesRead): new field.\n+\t(verified): new field.\n+\t(entryCerts): new field.\n+\t(DEBUG): new constant.\n+\t(debug): new method.\n+\t(JarEnumeration.nextElement): fill in entry certificates, read\n+\tsignatures if they haven't been read.\n+\t(getEntry): likewise.\n+\t(getInputStream): verify stream if it hasn't been verified yet.\n+\t(readSignatures): new method.\n+\t(verify): new method.\n+\t(verifyHashes): new method.\n+\t(readManifestEntry): new method.\n+\t(EntryInputStream): new class.\n+\t* gnu/java/io/Base64InputStream.java (decode): new class\n+\tmethod.\n+\t* gnu/java/security/der/DERReader.java don't make class\n+\tfinal.\n+\t(in): made protected.\n+\t(encBuf): likewise.\n+\t(readLength): likewise.\n+\t* gnu/java/security/ber/BER.java,\n+\t* gnu/java/security/ber/BEREncodingException.java,\n+\t* gnu/java/security/ber/BERReader.java,\n+\t* gnu/java/security/ber/BERValue.java,\n+\t* gnu/java/security/pkcs/PKCS7SignedData.java,\n+\t* gnu/java/security/pkcs/SignerInfo.java:\n+\tnew files.\n+\n 2005-02-16  Tom Tromey  <tromey@redhat.com>\n \n \t* gnu/gcj/runtime/SharedLibHelper.java (findHelper): Delete"}, {"sha": "abf837d60dc675d28856949e8d18813a9fa0ea30", "filename": "libjava/Makefile.am", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=2f6363f95e3124b5fe08279eeebe47c4a03dad71", "patch": "@@ -3103,12 +3103,18 @@ gnu/java/security/PolicyFile.java \\\n gnu/java/security/action/GetPropertyAction.java \\\n gnu/java/security/action/GetSecurityPropertyAction.java \\\n gnu/java/security/action/SetAccessibleAction.java \\\n+gnu/java/security/ber/BER.java \\\n+gnu/java/security/ber/BEREncodingException.java \\\n+gnu/java/security/ber/BERReader.java \\\n+gnu/java/security/ber/BERValue.java \\\n gnu/java/security/der/BitString.java \\\n gnu/java/security/der/DER.java \\\n gnu/java/security/der/DEREncodingException.java \\\n gnu/java/security/der/DERReader.java \\\n gnu/java/security/der/DERValue.java \\\n gnu/java/security/der/DERWriter.java \\\n+gnu/java/security/pkcs/PKCS7SignedData.java \\\n+gnu/java/security/pkcs/SignerInfo.java \\\n gnu/java/security/provider/CollectionCertStoreImpl.java \\\n gnu/java/security/provider/DSAKeyFactory.java \\\n gnu/java/security/provider/DSAKeyPairGenerator.java \\"}, {"sha": "ca6b28a2af3b40701827fd3a7444aef667072311", "filename": "libjava/Makefile.in", "status": "modified", "additions": 73, "deletions": 2, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=2f6363f95e3124b5fe08279eeebe47c4a03dad71", "patch": "@@ -780,12 +780,18 @@ am__libgcj0_convenience_la_SOURCES_DIST = prims.cc jni.cc exception.cc \\\n \tgnu/java/security/action/GetPropertyAction.java \\\n \tgnu/java/security/action/GetSecurityPropertyAction.java \\\n \tgnu/java/security/action/SetAccessibleAction.java \\\n+\tgnu/java/security/ber/BER.java \\\n+\tgnu/java/security/ber/BEREncodingException.java \\\n+\tgnu/java/security/ber/BERReader.java \\\n+\tgnu/java/security/ber/BERValue.java \\\n \tgnu/java/security/der/BitString.java \\\n \tgnu/java/security/der/DER.java \\\n \tgnu/java/security/der/DEREncodingException.java \\\n \tgnu/java/security/der/DERReader.java \\\n \tgnu/java/security/der/DERValue.java \\\n \tgnu/java/security/der/DERWriter.java \\\n+\tgnu/java/security/pkcs/PKCS7SignedData.java \\\n+\tgnu/java/security/pkcs/SignerInfo.java \\\n \tgnu/java/security/provider/CollectionCertStoreImpl.java \\\n \tgnu/java/security/provider/DSAKeyFactory.java \\\n \tgnu/java/security/provider/DSAKeyPairGenerator.java \\\n@@ -4104,12 +4110,18 @@ am__objects_15 = $(am__objects_9) gnu/classpath/ServiceFactory.lo \\\n \tgnu/java/security/action/GetPropertyAction.lo \\\n \tgnu/java/security/action/GetSecurityPropertyAction.lo \\\n \tgnu/java/security/action/SetAccessibleAction.lo \\\n+\tgnu/java/security/ber/BER.lo \\\n+\tgnu/java/security/ber/BEREncodingException.lo \\\n+\tgnu/java/security/ber/BERReader.lo \\\n+\tgnu/java/security/ber/BERValue.lo \\\n \tgnu/java/security/der/BitString.lo \\\n \tgnu/java/security/der/DER.lo \\\n \tgnu/java/security/der/DEREncodingException.lo \\\n \tgnu/java/security/der/DERReader.lo \\\n \tgnu/java/security/der/DERValue.lo \\\n \tgnu/java/security/der/DERWriter.lo \\\n+\tgnu/java/security/pkcs/PKCS7SignedData.lo \\\n+\tgnu/java/security/pkcs/SignerInfo.lo \\\n \tgnu/java/security/provider/CollectionCertStoreImpl.lo \\\n \tgnu/java/security/provider/DSAKeyFactory.lo \\\n \tgnu/java/security/provider/DSAKeyPairGenerator.lo \\\n@@ -7357,12 +7369,18 @@ gnu/java/security/PolicyFile.java \\\n gnu/java/security/action/GetPropertyAction.java \\\n gnu/java/security/action/GetSecurityPropertyAction.java \\\n gnu/java/security/action/SetAccessibleAction.java \\\n+gnu/java/security/ber/BER.java \\\n+gnu/java/security/ber/BEREncodingException.java \\\n+gnu/java/security/ber/BERReader.java \\\n+gnu/java/security/ber/BERValue.java \\\n gnu/java/security/der/BitString.java \\\n gnu/java/security/der/DER.java \\\n gnu/java/security/der/DEREncodingException.java \\\n gnu/java/security/der/DERReader.java \\\n gnu/java/security/der/DERValue.java \\\n gnu/java/security/der/DERWriter.java \\\n+gnu/java/security/pkcs/PKCS7SignedData.java \\\n+gnu/java/security/pkcs/SignerInfo.java \\\n gnu/java/security/provider/CollectionCertStoreImpl.java \\\n gnu/java/security/provider/DSAKeyFactory.java \\\n gnu/java/security/provider/DSAKeyPairGenerator.java \\\n@@ -10123,6 +10141,23 @@ gnu/java/security/action/GetSecurityPropertyAction.lo:  \\\n gnu/java/security/action/SetAccessibleAction.lo:  \\\n \tgnu/java/security/action/$(am__dirstamp) \\\n \tgnu/java/security/action/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/ber/$(am__dirstamp):\n+\t@$(mkdir_p) gnu/java/security/ber\n+\t@: > gnu/java/security/ber/$(am__dirstamp)\n+gnu/java/security/ber/$(DEPDIR)/$(am__dirstamp):\n+\t@$(mkdir_p) gnu/java/security/ber/$(DEPDIR)\n+\t@: > gnu/java/security/ber/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/ber/BER.lo: gnu/java/security/ber/$(am__dirstamp) \\\n+\tgnu/java/security/ber/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/ber/BEREncodingException.lo:  \\\n+\tgnu/java/security/ber/$(am__dirstamp) \\\n+\tgnu/java/security/ber/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/ber/BERReader.lo:  \\\n+\tgnu/java/security/ber/$(am__dirstamp) \\\n+\tgnu/java/security/ber/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/ber/BERValue.lo:  \\\n+\tgnu/java/security/ber/$(am__dirstamp) \\\n+\tgnu/java/security/ber/$(DEPDIR)/$(am__dirstamp)\n gnu/java/security/der/$(am__dirstamp):\n \t@$(mkdir_p) gnu/java/security/der\n \t@: > gnu/java/security/der/$(am__dirstamp)\n@@ -10146,6 +10181,18 @@ gnu/java/security/der/DERValue.lo:  \\\n gnu/java/security/der/DERWriter.lo:  \\\n \tgnu/java/security/der/$(am__dirstamp) \\\n \tgnu/java/security/der/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/pkcs/$(am__dirstamp):\n+\t@$(mkdir_p) gnu/java/security/pkcs\n+\t@: > gnu/java/security/pkcs/$(am__dirstamp)\n+gnu/java/security/pkcs/$(DEPDIR)/$(am__dirstamp):\n+\t@$(mkdir_p) gnu/java/security/pkcs/$(DEPDIR)\n+\t@: > gnu/java/security/pkcs/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/pkcs/PKCS7SignedData.lo:  \\\n+\tgnu/java/security/pkcs/$(am__dirstamp) \\\n+\tgnu/java/security/pkcs/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/pkcs/SignerInfo.lo:  \\\n+\tgnu/java/security/pkcs/$(am__dirstamp) \\\n+\tgnu/java/security/pkcs/$(DEPDIR)/$(am__dirstamp)\n gnu/java/security/provider/$(am__dirstamp):\n \t@$(mkdir_p) gnu/java/security/provider\n \t@: > gnu/java/security/provider/$(am__dirstamp)\n@@ -16756,6 +16803,14 @@ mostlyclean-compile:\n \t-rm -f gnu/java/security/action/GetSecurityPropertyAction.lo\n \t-rm -f gnu/java/security/action/SetAccessibleAction.$(OBJEXT)\n \t-rm -f gnu/java/security/action/SetAccessibleAction.lo\n+\t-rm -f gnu/java/security/ber/BER.$(OBJEXT)\n+\t-rm -f gnu/java/security/ber/BER.lo\n+\t-rm -f gnu/java/security/ber/BEREncodingException.$(OBJEXT)\n+\t-rm -f gnu/java/security/ber/BEREncodingException.lo\n+\t-rm -f gnu/java/security/ber/BERReader.$(OBJEXT)\n+\t-rm -f gnu/java/security/ber/BERReader.lo\n+\t-rm -f gnu/java/security/ber/BERValue.$(OBJEXT)\n+\t-rm -f gnu/java/security/ber/BERValue.lo\n \t-rm -f gnu/java/security/der/BitString.$(OBJEXT)\n \t-rm -f gnu/java/security/der/BitString.lo\n \t-rm -f gnu/java/security/der/DER.$(OBJEXT)\n@@ -16768,6 +16823,10 @@ mostlyclean-compile:\n \t-rm -f gnu/java/security/der/DERValue.lo\n \t-rm -f gnu/java/security/der/DERWriter.$(OBJEXT)\n \t-rm -f gnu/java/security/der/DERWriter.lo\n+\t-rm -f gnu/java/security/pkcs/PKCS7SignedData.$(OBJEXT)\n+\t-rm -f gnu/java/security/pkcs/PKCS7SignedData.lo\n+\t-rm -f gnu/java/security/pkcs/SignerInfo.$(OBJEXT)\n+\t-rm -f gnu/java/security/pkcs/SignerInfo.lo\n \t-rm -f gnu/java/security/provider/CollectionCertStoreImpl.$(OBJEXT)\n \t-rm -f gnu/java/security/provider/CollectionCertStoreImpl.lo\n \t-rm -f gnu/java/security/provider/DSAKeyFactory.$(OBJEXT)\n@@ -21834,12 +21893,18 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/action/$(DEPDIR)/GetPropertyAction.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/action/$(DEPDIR)/GetSecurityPropertyAction.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/action/$(DEPDIR)/SetAccessibleAction.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/ber/$(DEPDIR)/BER.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/ber/$(DEPDIR)/BEREncodingException.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/ber/$(DEPDIR)/BERReader.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/ber/$(DEPDIR)/BERValue.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/der/$(DEPDIR)/BitString.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/der/$(DEPDIR)/DER.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/der/$(DEPDIR)/DEREncodingException.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/der/$(DEPDIR)/DERReader.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/der/$(DEPDIR)/DERValue.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/der/$(DEPDIR)/DERWriter.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/pkcs/$(DEPDIR)/PKCS7SignedData.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/pkcs/$(DEPDIR)/SignerInfo.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/CollectionCertStoreImpl.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/DSAKeyFactory.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/DSAKeyPairGenerator.Plo@am__quote@\n@@ -25006,7 +25071,9 @@ clean-libtool:\n \t-rm -rf gnu/java/rmi/server/.libs gnu/java/rmi/server/_libs\n \t-rm -rf gnu/java/security/.libs gnu/java/security/_libs\n \t-rm -rf gnu/java/security/action/.libs gnu/java/security/action/_libs\n+\t-rm -rf gnu/java/security/ber/.libs gnu/java/security/ber/_libs\n \t-rm -rf gnu/java/security/der/.libs gnu/java/security/der/_libs\n+\t-rm -rf gnu/java/security/pkcs/.libs gnu/java/security/pkcs/_libs\n \t-rm -rf gnu/java/security/provider/.libs gnu/java/security/provider/_libs\n \t-rm -rf gnu/java/security/util/.libs gnu/java/security/util/_libs\n \t-rm -rf gnu/java/security/x509/.libs gnu/java/security/x509/_libs\n@@ -25555,8 +25622,12 @@ distclean-generic:\n \t-rm -f gnu/java/security/$(am__dirstamp)\n \t-rm -f gnu/java/security/action/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f gnu/java/security/action/$(am__dirstamp)\n+\t-rm -f gnu/java/security/ber/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f gnu/java/security/ber/$(am__dirstamp)\n \t-rm -f gnu/java/security/der/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f gnu/java/security/der/$(am__dirstamp)\n+\t-rm -f gnu/java/security/pkcs/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f gnu/java/security/pkcs/$(am__dirstamp)\n \t-rm -f gnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f gnu/java/security/provider/$(am__dirstamp)\n \t-rm -f gnu/java/security/util/$(DEPDIR)/$(am__dirstamp)\n@@ -25807,7 +25878,7 @@ clean-am: clean-binPROGRAMS clean-generic clean-libtool clean-local \\\n \n distclean: distclean-recursive\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf ./$(DEPDIR) gnu/awt/$(DEPDIR) gnu/awt/j2d/$(DEPDIR) gnu/awt/xlib/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/tools/gcj_dbtool/$(DEPDIR) gnu/gcj/util/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/awt/$(DEPDIR) gnu/java/awt/color/$(DEPDIR) gnu/java/awt/image/$(DEPDIR) gnu/java/awt/peer/$(DEPDIR) gnu/java/awt/peer/gtk/$(DEPDIR) gnu/java/beans/$(DEPDIR) gnu/java/beans/editors/$(DEPDIR) gnu/java/beans/info/$(DEPDIR) gnu/java/io/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/lang/reflect/$(DEPDIR) gnu/java/locale/$(DEPDIR) gnu/java/math/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/net/protocol/file/$(DEPDIR) gnu/java/net/protocol/gcjlib/$(DEPDIR) gnu/java/net/protocol/http/$(DEPDIR) gnu/java/net/protocol/http/event/$(DEPDIR) gnu/java/net/protocol/jar/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) gnu/java/nio/charset/$(DEPDIR) gnu/java/rmi/$(DEPDIR) gnu/java/rmi/dgc/$(DEPDIR) gnu/java/rmi/registry/$(DEPDIR) gnu/java/rmi/rmic/$(DEPDIR) gnu/java/rmi/server/$(DEPDIR) gnu/java/security/$(DEPDIR) gnu/java/security/action/$(DEPDIR) gnu/java/security/der/$(DEPDIR) gnu/java/security/provider/$(DEPDIR) gnu/java/security/util/$(DEPDIR) gnu/java/security/x509/$(DEPDIR) gnu/java/security/x509/ext/$(DEPDIR) gnu/java/text/$(DEPDIR) gnu/java/util/$(DEPDIR) gnu/java/util/prefs/$(DEPDIR) gnu/regexp/$(DEPDIR) gnu/xml/aelfred2/$(DEPDIR) gnu/xml/dom/$(DEPDIR) gnu/xml/dom/ls/$(DEPDIR) gnu/xml/pipeline/$(DEPDIR) gnu/xml/transform/$(DEPDIR) gnu/xml/util/$(DEPDIR) gnu/xml/xpath/$(DEPDIR) java/applet/$(DEPDIR) java/awt/$(DEPDIR) java/awt/color/$(DEPDIR) java/awt/datatransfer/$(DEPDIR) java/awt/dnd/$(DEPDIR) java/awt/dnd/peer/$(DEPDIR) java/awt/event/$(DEPDIR) java/awt/font/$(DEPDIR) java/awt/geom/$(DEPDIR) java/awt/im/$(DEPDIR) java/awt/im/spi/$(DEPDIR) java/awt/image/$(DEPDIR) java/awt/image/renderable/$(DEPDIR) java/awt/peer/$(DEPDIR) java/awt/print/$(DEPDIR) java/beans/$(DEPDIR) java/beans/beancontext/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/math/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/nio/channels/spi/$(DEPDIR) java/nio/charset/$(DEPDIR) java/nio/charset/spi/$(DEPDIR) java/rmi/$(DEPDIR) java/rmi/activation/$(DEPDIR) java/rmi/dgc/$(DEPDIR) java/rmi/registry/$(DEPDIR) java/rmi/server/$(DEPDIR) java/security/$(DEPDIR) java/security/acl/$(DEPDIR) java/security/cert/$(DEPDIR) java/security/interfaces/$(DEPDIR) java/security/spec/$(DEPDIR) java/sql/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/jar/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/prefs/$(DEPDIR) java/util/regex/$(DEPDIR) java/util/zip/$(DEPDIR) javax/accessibility/$(DEPDIR) javax/crypto/$(DEPDIR) javax/crypto/interfaces/$(DEPDIR) javax/crypto/spec/$(DEPDIR) javax/imageio/$(DEPDIR) javax/imageio/event/$(DEPDIR) javax/imageio/metadata/$(DEPDIR) javax/imageio/spi/$(DEPDIR) javax/imageio/stream/$(DEPDIR) javax/naming/$(DEPDIR) javax/naming/directory/$(DEPDIR) javax/naming/event/$(DEPDIR) javax/naming/ldap/$(DEPDIR) javax/naming/spi/$(DEPDIR) javax/net/$(DEPDIR) javax/net/ssl/$(DEPDIR) javax/print/$(DEPDIR) javax/print/attribute/$(DEPDIR) javax/print/attribute/standard/$(DEPDIR) javax/print/event/$(DEPDIR) javax/security/auth/$(DEPDIR) javax/security/auth/callback/$(DEPDIR) javax/security/auth/login/$(DEPDIR) javax/security/auth/spi/$(DEPDIR) javax/security/auth/x500/$(DEPDIR) javax/security/cert/$(DEPDIR) javax/security/sasl/$(DEPDIR) javax/sql/$(DEPDIR) javax/swing/$(DEPDIR) javax/swing/border/$(DEPDIR) javax/swing/colorchooser/$(DEPDIR) javax/swing/event/$(DEPDIR) javax/swing/filechooser/$(DEPDIR) javax/swing/plaf/$(DEPDIR) javax/swing/plaf/basic/$(DEPDIR) javax/swing/plaf/metal/$(DEPDIR) javax/swing/table/$(DEPDIR) javax/swing/text/$(DEPDIR) javax/swing/text/html/$(DEPDIR) javax/swing/text/html/parser/$(DEPDIR) javax/swing/tree/$(DEPDIR) javax/swing/undo/$(DEPDIR) javax/transaction/$(DEPDIR) javax/transaction/xa/$(DEPDIR) javax/xml/$(DEPDIR) javax/xml/datatype/$(DEPDIR) javax/xml/namespace/$(DEPDIR) javax/xml/parsers/$(DEPDIR) javax/xml/transform/$(DEPDIR) javax/xml/transform/dom/$(DEPDIR) javax/xml/transform/sax/$(DEPDIR) javax/xml/transform/stream/$(DEPDIR) javax/xml/validation/$(DEPDIR) javax/xml/xpath/$(DEPDIR) jni/classpath/$(DEPDIR) jni/gtk-peer/$(DEPDIR) org/ietf/jgss/$(DEPDIR) sysdep/$(DEPDIR)\n+\t-rm -rf ./$(DEPDIR) gnu/awt/$(DEPDIR) gnu/awt/j2d/$(DEPDIR) gnu/awt/xlib/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/tools/gcj_dbtool/$(DEPDIR) gnu/gcj/util/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/awt/$(DEPDIR) gnu/java/awt/color/$(DEPDIR) gnu/java/awt/image/$(DEPDIR) gnu/java/awt/peer/$(DEPDIR) gnu/java/awt/peer/gtk/$(DEPDIR) gnu/java/beans/$(DEPDIR) gnu/java/beans/editors/$(DEPDIR) gnu/java/beans/info/$(DEPDIR) gnu/java/io/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/lang/reflect/$(DEPDIR) gnu/java/locale/$(DEPDIR) gnu/java/math/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/net/protocol/file/$(DEPDIR) gnu/java/net/protocol/gcjlib/$(DEPDIR) gnu/java/net/protocol/http/$(DEPDIR) gnu/java/net/protocol/http/event/$(DEPDIR) gnu/java/net/protocol/jar/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) gnu/java/nio/charset/$(DEPDIR) gnu/java/rmi/$(DEPDIR) gnu/java/rmi/dgc/$(DEPDIR) gnu/java/rmi/registry/$(DEPDIR) gnu/java/rmi/rmic/$(DEPDIR) gnu/java/rmi/server/$(DEPDIR) gnu/java/security/$(DEPDIR) gnu/java/security/action/$(DEPDIR) gnu/java/security/ber/$(DEPDIR) gnu/java/security/der/$(DEPDIR) gnu/java/security/pkcs/$(DEPDIR) gnu/java/security/provider/$(DEPDIR) gnu/java/security/util/$(DEPDIR) gnu/java/security/x509/$(DEPDIR) gnu/java/security/x509/ext/$(DEPDIR) gnu/java/text/$(DEPDIR) gnu/java/util/$(DEPDIR) gnu/java/util/prefs/$(DEPDIR) gnu/regexp/$(DEPDIR) gnu/xml/aelfred2/$(DEPDIR) gnu/xml/dom/$(DEPDIR) gnu/xml/dom/ls/$(DEPDIR) gnu/xml/pipeline/$(DEPDIR) gnu/xml/transform/$(DEPDIR) gnu/xml/util/$(DEPDIR) gnu/xml/xpath/$(DEPDIR) java/applet/$(DEPDIR) java/awt/$(DEPDIR) java/awt/color/$(DEPDIR) java/awt/datatransfer/$(DEPDIR) java/awt/dnd/$(DEPDIR) java/awt/dnd/peer/$(DEPDIR) java/awt/event/$(DEPDIR) java/awt/font/$(DEPDIR) java/awt/geom/$(DEPDIR) java/awt/im/$(DEPDIR) java/awt/im/spi/$(DEPDIR) java/awt/image/$(DEPDIR) java/awt/image/renderable/$(DEPDIR) java/awt/peer/$(DEPDIR) java/awt/print/$(DEPDIR) java/beans/$(DEPDIR) java/beans/beancontext/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/math/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/nio/channels/spi/$(DEPDIR) java/nio/charset/$(DEPDIR) java/nio/charset/spi/$(DEPDIR) java/rmi/$(DEPDIR) java/rmi/activation/$(DEPDIR) java/rmi/dgc/$(DEPDIR) java/rmi/registry/$(DEPDIR) java/rmi/server/$(DEPDIR) java/security/$(DEPDIR) java/security/acl/$(DEPDIR) java/security/cert/$(DEPDIR) java/security/interfaces/$(DEPDIR) java/security/spec/$(DEPDIR) java/sql/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/jar/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/prefs/$(DEPDIR) java/util/regex/$(DEPDIR) java/util/zip/$(DEPDIR) javax/accessibility/$(DEPDIR) javax/crypto/$(DEPDIR) javax/crypto/interfaces/$(DEPDIR) javax/crypto/spec/$(DEPDIR) javax/imageio/$(DEPDIR) javax/imageio/event/$(DEPDIR) javax/imageio/metadata/$(DEPDIR) javax/imageio/spi/$(DEPDIR) javax/imageio/stream/$(DEPDIR) javax/naming/$(DEPDIR) javax/naming/directory/$(DEPDIR) javax/naming/event/$(DEPDIR) javax/naming/ldap/$(DEPDIR) javax/naming/spi/$(DEPDIR) javax/net/$(DEPDIR) javax/net/ssl/$(DEPDIR) javax/print/$(DEPDIR) javax/print/attribute/$(DEPDIR) javax/print/attribute/standard/$(DEPDIR) javax/print/event/$(DEPDIR) javax/security/auth/$(DEPDIR) javax/security/auth/callback/$(DEPDIR) javax/security/auth/login/$(DEPDIR) javax/security/auth/spi/$(DEPDIR) javax/security/auth/x500/$(DEPDIR) javax/security/cert/$(DEPDIR) javax/security/sasl/$(DEPDIR) javax/sql/$(DEPDIR) javax/swing/$(DEPDIR) javax/swing/border/$(DEPDIR) javax/swing/colorchooser/$(DEPDIR) javax/swing/event/$(DEPDIR) javax/swing/filechooser/$(DEPDIR) javax/swing/plaf/$(DEPDIR) javax/swing/plaf/basic/$(DEPDIR) javax/swing/plaf/metal/$(DEPDIR) javax/swing/table/$(DEPDIR) javax/swing/text/$(DEPDIR) javax/swing/text/html/$(DEPDIR) javax/swing/text/html/parser/$(DEPDIR) javax/swing/tree/$(DEPDIR) javax/swing/undo/$(DEPDIR) javax/transaction/$(DEPDIR) javax/transaction/xa/$(DEPDIR) javax/xml/$(DEPDIR) javax/xml/datatype/$(DEPDIR) javax/xml/namespace/$(DEPDIR) javax/xml/parsers/$(DEPDIR) javax/xml/transform/$(DEPDIR) javax/xml/transform/dom/$(DEPDIR) javax/xml/transform/sax/$(DEPDIR) javax/xml/transform/stream/$(DEPDIR) javax/xml/validation/$(DEPDIR) javax/xml/xpath/$(DEPDIR) jni/classpath/$(DEPDIR) jni/gtk-peer/$(DEPDIR) org/ietf/jgss/$(DEPDIR) sysdep/$(DEPDIR)\n \t-rm -f Makefile\n distclean-am: clean-am distclean-compile distclean-generic \\\n \tdistclean-libtool distclean-local distclean-tags\n@@ -25837,7 +25908,7 @@ installcheck-am:\n maintainer-clean: maintainer-clean-recursive\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n \t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -rf ./$(DEPDIR) gnu/awt/$(DEPDIR) gnu/awt/j2d/$(DEPDIR) gnu/awt/xlib/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/tools/gcj_dbtool/$(DEPDIR) gnu/gcj/util/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/awt/$(DEPDIR) gnu/java/awt/color/$(DEPDIR) gnu/java/awt/image/$(DEPDIR) gnu/java/awt/peer/$(DEPDIR) gnu/java/awt/peer/gtk/$(DEPDIR) gnu/java/beans/$(DEPDIR) gnu/java/beans/editors/$(DEPDIR) gnu/java/beans/info/$(DEPDIR) gnu/java/io/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/lang/reflect/$(DEPDIR) gnu/java/locale/$(DEPDIR) gnu/java/math/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/net/protocol/file/$(DEPDIR) gnu/java/net/protocol/gcjlib/$(DEPDIR) gnu/java/net/protocol/http/$(DEPDIR) gnu/java/net/protocol/http/event/$(DEPDIR) gnu/java/net/protocol/jar/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) gnu/java/nio/charset/$(DEPDIR) gnu/java/rmi/$(DEPDIR) gnu/java/rmi/dgc/$(DEPDIR) gnu/java/rmi/registry/$(DEPDIR) gnu/java/rmi/rmic/$(DEPDIR) gnu/java/rmi/server/$(DEPDIR) gnu/java/security/$(DEPDIR) gnu/java/security/action/$(DEPDIR) gnu/java/security/der/$(DEPDIR) gnu/java/security/provider/$(DEPDIR) gnu/java/security/util/$(DEPDIR) gnu/java/security/x509/$(DEPDIR) gnu/java/security/x509/ext/$(DEPDIR) gnu/java/text/$(DEPDIR) gnu/java/util/$(DEPDIR) gnu/java/util/prefs/$(DEPDIR) gnu/regexp/$(DEPDIR) gnu/xml/aelfred2/$(DEPDIR) gnu/xml/dom/$(DEPDIR) gnu/xml/dom/ls/$(DEPDIR) gnu/xml/pipeline/$(DEPDIR) gnu/xml/transform/$(DEPDIR) gnu/xml/util/$(DEPDIR) gnu/xml/xpath/$(DEPDIR) java/applet/$(DEPDIR) java/awt/$(DEPDIR) java/awt/color/$(DEPDIR) java/awt/datatransfer/$(DEPDIR) java/awt/dnd/$(DEPDIR) java/awt/dnd/peer/$(DEPDIR) java/awt/event/$(DEPDIR) java/awt/font/$(DEPDIR) java/awt/geom/$(DEPDIR) java/awt/im/$(DEPDIR) java/awt/im/spi/$(DEPDIR) java/awt/image/$(DEPDIR) java/awt/image/renderable/$(DEPDIR) java/awt/peer/$(DEPDIR) java/awt/print/$(DEPDIR) java/beans/$(DEPDIR) java/beans/beancontext/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/math/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/nio/channels/spi/$(DEPDIR) java/nio/charset/$(DEPDIR) java/nio/charset/spi/$(DEPDIR) java/rmi/$(DEPDIR) java/rmi/activation/$(DEPDIR) java/rmi/dgc/$(DEPDIR) java/rmi/registry/$(DEPDIR) java/rmi/server/$(DEPDIR) java/security/$(DEPDIR) java/security/acl/$(DEPDIR) java/security/cert/$(DEPDIR) java/security/interfaces/$(DEPDIR) java/security/spec/$(DEPDIR) java/sql/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/jar/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/prefs/$(DEPDIR) java/util/regex/$(DEPDIR) java/util/zip/$(DEPDIR) javax/accessibility/$(DEPDIR) javax/crypto/$(DEPDIR) javax/crypto/interfaces/$(DEPDIR) javax/crypto/spec/$(DEPDIR) javax/imageio/$(DEPDIR) javax/imageio/event/$(DEPDIR) javax/imageio/metadata/$(DEPDIR) javax/imageio/spi/$(DEPDIR) javax/imageio/stream/$(DEPDIR) javax/naming/$(DEPDIR) javax/naming/directory/$(DEPDIR) javax/naming/event/$(DEPDIR) javax/naming/ldap/$(DEPDIR) javax/naming/spi/$(DEPDIR) javax/net/$(DEPDIR) javax/net/ssl/$(DEPDIR) javax/print/$(DEPDIR) javax/print/attribute/$(DEPDIR) javax/print/attribute/standard/$(DEPDIR) javax/print/event/$(DEPDIR) javax/security/auth/$(DEPDIR) javax/security/auth/callback/$(DEPDIR) javax/security/auth/login/$(DEPDIR) javax/security/auth/spi/$(DEPDIR) javax/security/auth/x500/$(DEPDIR) javax/security/cert/$(DEPDIR) javax/security/sasl/$(DEPDIR) javax/sql/$(DEPDIR) javax/swing/$(DEPDIR) javax/swing/border/$(DEPDIR) javax/swing/colorchooser/$(DEPDIR) javax/swing/event/$(DEPDIR) javax/swing/filechooser/$(DEPDIR) javax/swing/plaf/$(DEPDIR) javax/swing/plaf/basic/$(DEPDIR) javax/swing/plaf/metal/$(DEPDIR) javax/swing/table/$(DEPDIR) javax/swing/text/$(DEPDIR) javax/swing/text/html/$(DEPDIR) javax/swing/text/html/parser/$(DEPDIR) javax/swing/tree/$(DEPDIR) javax/swing/undo/$(DEPDIR) javax/transaction/$(DEPDIR) javax/transaction/xa/$(DEPDIR) javax/xml/$(DEPDIR) javax/xml/datatype/$(DEPDIR) javax/xml/namespace/$(DEPDIR) javax/xml/parsers/$(DEPDIR) javax/xml/transform/$(DEPDIR) javax/xml/transform/dom/$(DEPDIR) javax/xml/transform/sax/$(DEPDIR) javax/xml/transform/stream/$(DEPDIR) javax/xml/validation/$(DEPDIR) javax/xml/xpath/$(DEPDIR) jni/classpath/$(DEPDIR) jni/gtk-peer/$(DEPDIR) org/ietf/jgss/$(DEPDIR) sysdep/$(DEPDIR)\n+\t-rm -rf ./$(DEPDIR) gnu/awt/$(DEPDIR) gnu/awt/j2d/$(DEPDIR) gnu/awt/xlib/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/tools/gcj_dbtool/$(DEPDIR) gnu/gcj/util/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/awt/$(DEPDIR) gnu/java/awt/color/$(DEPDIR) gnu/java/awt/image/$(DEPDIR) gnu/java/awt/peer/$(DEPDIR) gnu/java/awt/peer/gtk/$(DEPDIR) gnu/java/beans/$(DEPDIR) gnu/java/beans/editors/$(DEPDIR) gnu/java/beans/info/$(DEPDIR) gnu/java/io/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/lang/reflect/$(DEPDIR) gnu/java/locale/$(DEPDIR) gnu/java/math/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/net/protocol/file/$(DEPDIR) gnu/java/net/protocol/gcjlib/$(DEPDIR) gnu/java/net/protocol/http/$(DEPDIR) gnu/java/net/protocol/http/event/$(DEPDIR) gnu/java/net/protocol/jar/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) gnu/java/nio/charset/$(DEPDIR) gnu/java/rmi/$(DEPDIR) gnu/java/rmi/dgc/$(DEPDIR) gnu/java/rmi/registry/$(DEPDIR) gnu/java/rmi/rmic/$(DEPDIR) gnu/java/rmi/server/$(DEPDIR) gnu/java/security/$(DEPDIR) gnu/java/security/action/$(DEPDIR) gnu/java/security/ber/$(DEPDIR) gnu/java/security/der/$(DEPDIR) gnu/java/security/pkcs/$(DEPDIR) gnu/java/security/provider/$(DEPDIR) gnu/java/security/util/$(DEPDIR) gnu/java/security/x509/$(DEPDIR) gnu/java/security/x509/ext/$(DEPDIR) gnu/java/text/$(DEPDIR) gnu/java/util/$(DEPDIR) gnu/java/util/prefs/$(DEPDIR) gnu/regexp/$(DEPDIR) gnu/xml/aelfred2/$(DEPDIR) gnu/xml/dom/$(DEPDIR) gnu/xml/dom/ls/$(DEPDIR) gnu/xml/pipeline/$(DEPDIR) gnu/xml/transform/$(DEPDIR) gnu/xml/util/$(DEPDIR) gnu/xml/xpath/$(DEPDIR) java/applet/$(DEPDIR) java/awt/$(DEPDIR) java/awt/color/$(DEPDIR) java/awt/datatransfer/$(DEPDIR) java/awt/dnd/$(DEPDIR) java/awt/dnd/peer/$(DEPDIR) java/awt/event/$(DEPDIR) java/awt/font/$(DEPDIR) java/awt/geom/$(DEPDIR) java/awt/im/$(DEPDIR) java/awt/im/spi/$(DEPDIR) java/awt/image/$(DEPDIR) java/awt/image/renderable/$(DEPDIR) java/awt/peer/$(DEPDIR) java/awt/print/$(DEPDIR) java/beans/$(DEPDIR) java/beans/beancontext/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/math/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/nio/channels/spi/$(DEPDIR) java/nio/charset/$(DEPDIR) java/nio/charset/spi/$(DEPDIR) java/rmi/$(DEPDIR) java/rmi/activation/$(DEPDIR) java/rmi/dgc/$(DEPDIR) java/rmi/registry/$(DEPDIR) java/rmi/server/$(DEPDIR) java/security/$(DEPDIR) java/security/acl/$(DEPDIR) java/security/cert/$(DEPDIR) java/security/interfaces/$(DEPDIR) java/security/spec/$(DEPDIR) java/sql/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/jar/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/prefs/$(DEPDIR) java/util/regex/$(DEPDIR) java/util/zip/$(DEPDIR) javax/accessibility/$(DEPDIR) javax/crypto/$(DEPDIR) javax/crypto/interfaces/$(DEPDIR) javax/crypto/spec/$(DEPDIR) javax/imageio/$(DEPDIR) javax/imageio/event/$(DEPDIR) javax/imageio/metadata/$(DEPDIR) javax/imageio/spi/$(DEPDIR) javax/imageio/stream/$(DEPDIR) javax/naming/$(DEPDIR) javax/naming/directory/$(DEPDIR) javax/naming/event/$(DEPDIR) javax/naming/ldap/$(DEPDIR) javax/naming/spi/$(DEPDIR) javax/net/$(DEPDIR) javax/net/ssl/$(DEPDIR) javax/print/$(DEPDIR) javax/print/attribute/$(DEPDIR) javax/print/attribute/standard/$(DEPDIR) javax/print/event/$(DEPDIR) javax/security/auth/$(DEPDIR) javax/security/auth/callback/$(DEPDIR) javax/security/auth/login/$(DEPDIR) javax/security/auth/spi/$(DEPDIR) javax/security/auth/x500/$(DEPDIR) javax/security/cert/$(DEPDIR) javax/security/sasl/$(DEPDIR) javax/sql/$(DEPDIR) javax/swing/$(DEPDIR) javax/swing/border/$(DEPDIR) javax/swing/colorchooser/$(DEPDIR) javax/swing/event/$(DEPDIR) javax/swing/filechooser/$(DEPDIR) javax/swing/plaf/$(DEPDIR) javax/swing/plaf/basic/$(DEPDIR) javax/swing/plaf/metal/$(DEPDIR) javax/swing/table/$(DEPDIR) javax/swing/text/$(DEPDIR) javax/swing/text/html/$(DEPDIR) javax/swing/text/html/parser/$(DEPDIR) javax/swing/tree/$(DEPDIR) javax/swing/undo/$(DEPDIR) javax/transaction/$(DEPDIR) javax/transaction/xa/$(DEPDIR) javax/xml/$(DEPDIR) javax/xml/datatype/$(DEPDIR) javax/xml/namespace/$(DEPDIR) javax/xml/parsers/$(DEPDIR) javax/xml/transform/$(DEPDIR) javax/xml/transform/dom/$(DEPDIR) javax/xml/transform/sax/$(DEPDIR) javax/xml/transform/stream/$(DEPDIR) javax/xml/validation/$(DEPDIR) javax/xml/xpath/$(DEPDIR) jni/classpath/$(DEPDIR) jni/gtk-peer/$(DEPDIR) org/ietf/jgss/$(DEPDIR) sysdep/$(DEPDIR)\n \t-rm -f Makefile\n maintainer-clean-am: distclean-am maintainer-clean-generic\n "}, {"sha": "617e8315102e761dccfcec74c3ab515c109012c8", "filename": "libjava/gnu/java/io/Base64InputStream.java", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fgnu%2Fjava%2Fio%2FBase64InputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fgnu%2Fjava%2Fio%2FBase64InputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fio%2FBase64InputStream.java?ref=2f6363f95e3124b5fe08279eeebe47c4a03dad71", "patch": "@@ -1,5 +1,5 @@\n /* Base64InputStream.java -- base-64 input stream.\n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,6 +38,8 @@\n \n package gnu.java.io;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n import java.io.FilterInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n@@ -90,6 +92,30 @@ public Base64InputStream(InputStream in)\n     eof = false;\n   }\n \n+  // Class method.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Decode a single Base-64 string to a byte array.\n+   *\n+   * @param base64 The Base-64 encoded data.\n+   * @return The decoded bytes.\n+   * @throws IOException If the given data do not compose a valid Base-64\n+   *  sequence.\n+   */\n+  public static byte[] decode(String base64) throws IOException\n+  {\n+    Base64InputStream in =\n+      new Base64InputStream(new ByteArrayInputStream(base64.getBytes()));\n+    ByteArrayOutputStream out =\n+      new ByteArrayOutputStream((int) (base64.length() / 0.666));\n+    byte[] buf = new byte[1024];\n+    int len;\n+    while ((len = in.read(buf)) != -1)\n+      out.write(buf, 0, len);\n+    return out.toByteArray();\n+  }\n+\n   // Instance methods.\n   // ------------------------------------------------------------------------\n "}, {"sha": "ff666bfe1b34c3d8e2a07bb9d97b81dc1607c388", "filename": "libjava/gnu/java/security/ber/BER.java", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fgnu%2Fjava%2Fsecurity%2Fber%2FBER.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fgnu%2Fjava%2Fsecurity%2Fber%2FBER.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fber%2FBER.java?ref=2f6363f95e3124b5fe08279eeebe47c4a03dad71", "patch": "@@ -0,0 +1,46 @@\n+/* BER.java -- basic encoding rules (BER) constants.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.ber;\n+\n+import gnu.java.security.der.DER;\n+\n+public interface BER extends DER\n+{\n+  BERValue END_OF_SEQUENCE = new BERValue(0, null);\n+}"}, {"sha": "5c3ed243b20471eed63a3f8b3008bad2cfd494b8", "filename": "libjava/gnu/java/security/ber/BEREncodingException.java", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fgnu%2Fjava%2Fsecurity%2Fber%2FBEREncodingException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fgnu%2Fjava%2Fsecurity%2Fber%2FBEREncodingException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fber%2FBEREncodingException.java?ref=2f6363f95e3124b5fe08279eeebe47c4a03dad71", "patch": "@@ -0,0 +1,54 @@\n+/* BEREncodingException.java --- BER Encoding Exception\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.ber;\n+\n+import gnu.java.security.der.DEREncodingException;\n+\n+public class BEREncodingException extends DEREncodingException\n+{\n+  public BEREncodingException()\n+  {\n+    super ();\n+  }\n+\n+  public BEREncodingException (String msg)\n+  {\n+    super (msg);\n+  }\n+}"}, {"sha": "600d46b4d7bee98d67d5016005278109f40cda14", "filename": "libjava/gnu/java/security/ber/BERReader.java", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fgnu%2Fjava%2Fsecurity%2Fber%2FBERReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fgnu%2Fjava%2Fsecurity%2Fber%2FBERReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fber%2FBERReader.java?ref=2f6363f95e3124b5fe08279eeebe47c4a03dad71", "patch": "@@ -0,0 +1,103 @@\n+/* BERReader.java -- basic encoding rules (BER) reader.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.ber;\n+\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+public class BERReader extends DERReader implements BER\n+{\n+\n+  /**\n+   * Create a new DER reader from a byte array.\n+   *\n+   * @param in The encoded bytes.\n+   */\n+  public BERReader(byte[] in)\n+  {\n+    super(in);\n+  }\n+\n+  public BERReader (byte[] in, int off, int len)\n+  {\n+    super(in, off, len);\n+  }\n+\n+  /**\n+   * Create a new DER readed from an input stream.\n+   *\n+   * @param in The encoded bytes.\n+   */\n+  public BERReader(InputStream in)\n+  {\n+    super(in);\n+  }\n+\n+  public DERValue read() throws IOException\n+  {\n+    in.mark(2);\n+    int tag = in.read();\n+    if (tag == -1)\n+      throw new EOFException();\n+    int length = in.read();\n+    if (length == 0)\n+      {\n+        if (tag == 0)\n+          return END_OF_SEQUENCE;\n+        return new BERValue(tag, CONSTRUCTED_VALUE, new byte[] { (byte) tag, 0 });\n+      }\n+    else\n+      {\n+        in.reset();\n+        return super.read();\n+      }\n+  }\n+\n+  public int peek() throws IOException\n+  {\n+    in.mark(1);\n+    int ret = in.read();\n+    in.reset();\n+    return ret;\n+  }\n+}"}, {"sha": "dd4364a6d93a3e6dcd7f20761f08f44ce6b9b606", "filename": "libjava/gnu/java/security/ber/BERValue.java", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fgnu%2Fjava%2Fsecurity%2Fber%2FBERValue.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fgnu%2Fjava%2Fsecurity%2Fber%2FBERValue.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fber%2FBERValue.java?ref=2f6363f95e3124b5fe08279eeebe47c4a03dad71", "patch": "@@ -0,0 +1,82 @@\n+/* BERReader.java -- basic encoding rules (BER) value.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.ber;\n+\n+import gnu.java.security.der.DERValue;\n+\n+public class BERValue extends DERValue\n+{\n+\n+  private boolean indefinite;\n+\n+  public BERValue(int tag, Object value, byte[] encoded)\n+  {\n+    super(tag, 0, value, encoded);\n+    indefinite = true;\n+  }\n+\n+  public BERValue(int tag, int length, Object value, byte[] encoded)\n+  {\n+    super(tag, length, value, encoded);\n+  }\n+\n+  public BERValue(int tag, Object value)\n+  {\n+    super(tag, 0, value, null);\n+  }\n+\n+  public static boolean isIndefinite(DERValue value)\n+  {\n+    if (value instanceof BERValue)\n+      return ((BERValue) value).getIndefinite();\n+    return false;\n+  }\n+\n+  public boolean getIndefinite()\n+  {\n+    return indefinite;\n+  }\n+\n+  public int getLength()\n+  {\n+    if (indefinite)\n+      return 0;\n+    return super.getLength();\n+  }\n+}"}, {"sha": "688b509eb2ce6ac65d1ba8f9e6b0e950d8debdfc", "filename": "libjava/gnu/java/security/der/DERReader.java", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fgnu%2Fjava%2Fsecurity%2Fder%2FDERReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fgnu%2Fjava%2Fsecurity%2Fder%2FDERReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fder%2FDERReader.java?ref=2f6363f95e3124b5fe08279eeebe47c4a03dad71", "patch": "@@ -62,15 +62,15 @@\n  *\n  * @author Casey Marshall (csm@gnu.org)\n  */\n-public final class DERReader implements DER\n+public class DERReader implements DER\n {\n \n   // Fields.\n   // ------------------------------------------------------------------------\n \n-  private InputStream in;\n+  protected InputStream in;\n \n-  private final ByteArrayOutputStream encBuf;\n+  protected final ByteArrayOutputStream encBuf;\n \n   // Constructor.\n   // ------------------------------------------------------------------------\n@@ -185,6 +185,26 @@ public DERValue read() throws IOException\n     return value;\n   }\n \n+  protected int readLength() throws IOException\n+  {\n+    int i = in.read();\n+    if (i == -1)\n+      throw new EOFException();\n+    encBuf.write(i);\n+    if ((i & ~0x7F) == 0)\n+      {\n+        return i;\n+      }\n+    else if (i < 0xFF)\n+      {\n+        byte[] octets = new byte[i & 0x7F];\n+        in.read(octets);\n+        encBuf.write(octets);\n+        return new BigInteger(1, octets).intValue();\n+      }\n+    throw new DEREncodingException();\n+  }\n+\n   // Own methods.\n   // ------------------------------------------------------------------------\n \n@@ -236,26 +256,6 @@ private Object readUniversal(int tag, int len) throws IOException\n       }\n   }\n \n-  private int readLength() throws IOException\n-  {\n-    int i = in.read();\n-    if (i == -1)\n-      throw new EOFException();\n-    encBuf.write(i);\n-    if ((i & ~0x7F) == 0)\n-      {\n-        return i;\n-      }\n-    else if (i < 0xFF)\n-      {\n-        byte[] octets = new byte[i & 0x7F];\n-        in.read(octets);\n-        encBuf.write(octets);\n-        return new BigInteger(1, octets).intValue();\n-      }\n-    throw new DEREncodingException();\n-  }\n-\n   private static String makeString(int tag, byte[] value)\n     throws IOException\n   {"}, {"sha": "5c2a98a5cac82649cb4737d7214e49b699aeb543", "filename": "libjava/gnu/java/security/pkcs/PKCS7SignedData.java", "status": "added", "additions": 363, "deletions": 0, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fgnu%2Fjava%2Fsecurity%2Fpkcs%2FPKCS7SignedData.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fgnu%2Fjava%2Fsecurity%2Fpkcs%2FPKCS7SignedData.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fpkcs%2FPKCS7SignedData.java?ref=2f6363f95e3124b5fe08279eeebe47c4a03dad71", "patch": "@@ -0,0 +1,363 @@\n+/* PKCS7SignedData.java -- reader for PKCS#7 signedData objects.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+This program is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.pkcs;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.ber.BER;\n+import gnu.java.security.ber.BEREncodingException;\n+import gnu.java.security.ber.BERReader;\n+import gnu.java.security.ber.BERValue;\n+import gnu.java.security.der.DERValue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import java.math.BigInteger;\n+\n+import java.security.cert.CRL;\n+import java.security.cert.CRLException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * The SignedData object in PKCS #7. This is a read-only implementation of\n+ * this format, and is used to provide signed Jar file support.\n+ *\n+ * @author Casey Marshall (csm@gnu.org)\n+ */\n+public class PKCS7SignedData\n+{\n+\n+  public static final OID PKCS7_DATA = new OID(\"1.2.840.113549.1.7.1\");\n+  public static final OID PKCS7_SIGNED_DATA = new OID(\"1.2.840.113549.1.7.2\");\n+\n+  private BigInteger version;\n+  private Set digestAlgorithms;\n+  private OID contentType;\n+  private byte[] content;\n+  private Certificate[] certificates;\n+  private CRL[] crls;\n+  private Set signerInfos;\n+\n+  private static final boolean DEBUG = false;\n+  private static void debug(String msg)\n+  {\n+    System.err.print(\"PKCS7SignedData >> \");\n+    System.err.println(msg);\n+  }\n+\n+  public PKCS7SignedData(InputStream in)\n+    throws CRLException, CertificateException, IOException\n+  {\n+    this(new BERReader(in));\n+  }\n+\n+  /**\n+   * Parse an encoded PKCS#7 SignedData object. The ASN.1 format of this\n+   * object is:\n+   *\n+   * <pre>\n+   * SignedData ::= SEQUENCE {\n+   *   version Version,\n+   *   digestAlgorithms DigestAlgorithmIdentifiers,\n+   *   contentInfo ContentInfo,\n+   *   certificates\n+   *     [0] IMPLICIT ExtendedCertificatesAndCertificates OPTIONAL,\n+   *   crls\n+   *     [1] IMPLICIT CertificateRevocationLists OPTIONAL,\n+   *   signerInfos SignerInfos }\n+   *\n+   * Version ::= INTEGER\n+   *\n+   * DigestAlgorithmIdentifiers ::= SET OF DigestAlgorithmIdentifier\n+   *\n+   * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\n+   *\n+   * ContentInfo ::= SEQUENCE {\n+   *   contentType ContentType,\n+   *   content [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL }\n+   *\n+   * ContentType ::= OBJECT IDENTIFIER\n+   *\n+   * ExtendedCertificatesAndCertificates ::=\n+   *   SET OF ExtendedCertificatesAndCertificate\n+   *\n+   * ExtendedCertificatesAndCertificate ::= CHOICE {\n+   *   certificate Certificate, -- from X.509\n+   *   extendedCertificate [0] IMPLICIT ExtendedCertificate }\n+   *\n+   * CertificateRevocationLists ::= SET OF CertificateRevocationList\n+   *   -- from X.509\n+   *\n+   * SignerInfos ::= SET OF SignerInfo\n+   *\n+   * SignerInfo ::= SEQUENCE {\n+   *   version Version,\n+   *   issuerAndSerialNumber IssuerAndSerialNumber,\n+   *   digestAlgorithm DigestAlgorithmIdentifier,\n+   *   authenticatedAttributes\n+   *     [0] IMPLICIT Attributes OPTIONAL,\n+   *   digestEncryptionAlgorithm DigestEncryptionAlgorithmIdentifier,\n+   *   encryptedDigest EncryptedDigest,\n+   *   unauthenticatedAttributes\n+   *     [1] IMPLICIT Attributes OPTIONAL }\n+   *\n+   * EncryptedDigest ::= OCTET STRING\n+   * </pre>\n+   *\n+   * <p>(Readers who are confused as to why it takes 40 levels of indirection\n+   * to specify \"data with a signature\", rest assured that the present author\n+   * is as confused as you are).</p>\n+   */\n+  public PKCS7SignedData(BERReader ber)\n+    throws CRLException, CertificateException, IOException\n+  {\n+    CertificateFactory x509 = CertificateFactory.getInstance(\"X509\");\n+    DERValue val = ber.read();\n+    if (!val.isConstructed())\n+      throw new BEREncodingException(\"malformed ContentInfo\");\n+\n+    val = ber.read();\n+    if (val.getTag() != BER.OBJECT_IDENTIFIER)\n+      throw new BEREncodingException(\"malformed ContentType\");\n+\n+    if (!PKCS7_SIGNED_DATA.equals(val.getValue()))\n+      throw new BEREncodingException(\"content is not SignedData\");\n+\n+    val = ber.read();\n+    if (val.getTag() != 0)\n+      throw new BEREncodingException(\"malformed Content\");\n+\n+    val = ber.read();\n+    if (!val.isConstructed())\n+      throw new BEREncodingException(\"malformed SignedData\");\n+\n+    if (DEBUG)\n+      debug(\"SignedData: \" + val);\n+\n+    val = ber.read();\n+    if (val.getTag() != BER.INTEGER)\n+      throw new BEREncodingException(\"expecting Version\");\n+    version = (BigInteger) val.getValue();\n+\n+    if (DEBUG)\n+      debug(\"  Version: \" + version);\n+\n+    digestAlgorithms = new HashSet();\n+    val = ber.read();\n+    if (!val.isConstructed())\n+      throw new BEREncodingException(\"malformed DigestAlgorithmIdentifiers\");\n+    if (DEBUG)\n+      debug(\"  DigestAlgorithmIdentifiers: \" + val);\n+    int count = 0;\n+    DERValue val2 = ber.read();\n+    while (val2 != BER.END_OF_SEQUENCE &&\n+           (val.getLength() > 0 && val.getLength() > count))\n+      {\n+        if (!val2.isConstructed())\n+          throw new BEREncodingException(\"malformed AlgorithmIdentifier\");\n+        if (DEBUG)\n+          debug(\"    AlgorithmIdentifier: \" + val2);\n+        count += val2.getEncodedLength();\n+        val2 = ber.read();\n+        if (val2.getTag() != BER.OBJECT_IDENTIFIER)\n+          throw new BEREncodingException(\"malformed AlgorithmIdentifier\");\n+        if (DEBUG)\n+          debug(\"      ID: \" + val2.getValue());\n+        List algId = new ArrayList(2);\n+        algId.add(val2.getValue());\n+        val2 = ber.read();\n+        if (val2 != BER.END_OF_SEQUENCE)\n+          {\n+            count += val2.getEncodedLength();\n+            if (val2.getTag() == BER.NULL)\n+              algId.add(null);\n+            else\n+              algId.add(val2.getEncoded());\n+            if (DEBUG)\n+              debug(\"      params: \" + new BigInteger(1, val2.getEncoded()).toString(16));\n+            if (val2.isConstructed())\n+              ber.skip(val2.getLength());\n+            if (BERValue.isIndefinite(val))\n+              val2 = ber.read();\n+          }\n+        else\n+          algId.add(null);\n+        digestAlgorithms.add(algId);\n+      }\n+\n+    val = ber.read();\n+    if (!val.isConstructed())\n+      throw new BEREncodingException(\"malformed ContentInfo\");\n+    if (DEBUG)\n+      debug(\"  ContentInfo: \" + val);\n+    val2 = ber.read();\n+    if (val2.getTag() != BER.OBJECT_IDENTIFIER)\n+      throw new BEREncodingException(\"malformed ContentType\");\n+    contentType = (OID) val2.getValue();\n+    if (DEBUG)\n+      debug(\"    ContentType: \" + contentType);\n+    if (BERValue.isIndefinite(val)\n+        || (val.getLength() > 0 && val.getLength() > val2.getEncodedLength()))\n+      {\n+        val2 = ber.read();\n+        if (val2 != BER.END_OF_SEQUENCE)\n+          {\n+            content = val2.getEncoded();\n+            if (BERValue.isIndefinite(val))\n+              val2 = ber.read();\n+            if (DEBUG)\n+              debug(\"    Content: \" + new BigInteger(1, content).toString(16));\n+          }\n+      }\n+\n+    val = ber.read();\n+    if (val.getTag() == 0)\n+      {\n+        if (!val.isConstructed())\n+          throw new BEREncodingException(\"malformed ExtendedCertificatesAndCertificates\");\n+        if (DEBUG)\n+          debug(\"  ExtendedCertificatesAndCertificates: \" + val);\n+        count = 0;\n+        val2 = ber.read();\n+        List certs = new LinkedList();\n+        while (val2 != BER.END_OF_SEQUENCE &&\n+               (val.getLength() > 0 && val.getLength() > count))\n+          {\n+            Certificate cert =\n+              x509.generateCertificate(new ByteArrayInputStream(val2.getEncoded()));\n+            if (DEBUG)\n+              debug(\"    Certificate: \" + cert);\n+            certs.add(cert);\n+            count += val2.getEncodedLength();\n+            ber.skip(val2.getLength());\n+            if (BERValue.isIndefinite(val) || val.getLength() > count)\n+              val2 = ber.read();\n+          }\n+        certificates = (Certificate[]) certs.toArray(new Certificate[certs.size()]);\n+        val = ber.read();\n+      }\n+\n+    if (val.getTag() == 1)\n+      {\n+        if (!val.isConstructed())\n+          throw new BEREncodingException(\"malformed CertificateRevocationLists\");\n+        if (DEBUG)\n+          debug(\"  CertificateRevocationLists: \" + val);\n+        count = 0;\n+        val2 = ber.read();\n+        List crls = new LinkedList();\n+        while (val2 != BER.END_OF_SEQUENCE &&\n+               (val.getLength() > 0 && val.getLength() > count))\n+          {\n+            CRL crl = x509.generateCRL(new ByteArrayInputStream(val2.getEncoded()));\n+            if (DEBUG)\n+              debug (\"    CRL: \" + crl);\n+            crls.add(crl);\n+            count += val2.getEncodedLength();\n+            ber.skip(val2.getLength());\n+            if (BERValue.isIndefinite(val) || val.getLength() > count)\n+              val2 = ber.read();\n+          }\n+        this.crls = (CRL[]) crls.toArray(new CRL[crls.size()]);\n+        val = ber.read();\n+      }\n+\n+    signerInfos = new HashSet();\n+    if (!val.isConstructed())\n+      throw new BEREncodingException(\"malformed SignerInfos\");\n+\n+    if (DEBUG)\n+      debug(\"  SignerInfos: \" + val);\n+\n+    // FIXME read this more carefully.\n+    // Since we are just reading a file (probably) we just read until we\n+    // reach the end.\n+    while (true)\n+      {\n+        int i = ber.peek();\n+        if (i == 0 || i == -1)\n+          break;\n+        signerInfos.add(new SignerInfo(ber));\n+      }\n+  }\n+\n+  public BigInteger getVersion()\n+  {\n+    return version;\n+  }\n+\n+  public Certificate[] getCertificates()\n+  {\n+    return (certificates != null ? (Certificate[]) certificates.clone()\n+            : null);\n+  }\n+\n+  public OID getContentType()\n+  {\n+    return contentType;\n+  }\n+\n+  public byte[] getContent()\n+  {\n+    return (content != null ? (byte[]) content.clone() : null);\n+  }\n+\n+  public Set getDigestAlgorithms()\n+  {\n+    // FIXME copy contents too, they are mutable!!!\n+    return Collections.unmodifiableSet(digestAlgorithms);\n+  }\n+\n+  public Set getSignerInfos()\n+  {\n+    Set copy = new HashSet();\n+    for (Iterator it = signerInfos.iterator(); it.hasNext(); )\n+      copy.add(it.next());\n+    return Collections.unmodifiableSet(copy);\n+  }\n+}"}, {"sha": "444429493c631be53f027790911dcade94d977f8", "filename": "libjava/gnu/java/security/pkcs/SignerInfo.java", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fgnu%2Fjava%2Fsecurity%2Fpkcs%2FSignerInfo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fgnu%2Fjava%2Fsecurity%2Fpkcs%2FSignerInfo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fpkcs%2FSignerInfo.java?ref=2f6363f95e3124b5fe08279eeebe47c4a03dad71", "patch": "@@ -0,0 +1,280 @@\n+/* SignerInfo.java -- a SignerInfo object, from PKCS #7.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+This program is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.pkcs;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.ber.BER;\n+import gnu.java.security.ber.BEREncodingException;\n+import gnu.java.security.ber.BERReader;\n+import gnu.java.security.ber.BERValue;\n+import gnu.java.security.der.BitString;\n+import gnu.java.security.der.DERValue;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import java.math.BigInteger;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+public class SignerInfo\n+{\n+  private final BigInteger version;\n+  private final BigInteger serialNumber;\n+  private final X500Principal issuer;\n+  private final OID digestAlgorithmId;\n+  private final byte[] digestAlgorithmParams;\n+  private final byte[] authenticatedAttributes;\n+  private final OID digestEncryptionAlgorithmId;\n+  private final byte[] digestEncryptionAlgorithmParams;\n+  private final byte[] encryptedDigest;\n+  private final byte[] unauthenticatedAttributes;\n+\n+  private static final boolean DEBUG = false;\n+  private static void debug(String msg)\n+  {\n+    System.err.print(\"SignerInfo >> \");\n+    System.err.println(msg);\n+  }\n+\n+  /**\n+   * Parse a SignerInfo object.\n+   */\n+  public SignerInfo(BERReader ber) throws IOException\n+  {\n+    DERValue val = ber.read();\n+    if (DEBUG)\n+      debug(\"SignerInfo: \" + val);\n+    if (!val.isConstructed())\n+      throw new BEREncodingException(\"malformed SignerInfo\");\n+\n+    val = ber.read();\n+    if (val.getTag() != BER.INTEGER)\n+      throw new BEREncodingException(\"malformed Version\");\n+    version = (BigInteger) val.getValue();\n+\n+    if (DEBUG)\n+      debug(\"  Version: \" + version);\n+\n+    val = ber.read();\n+    if (!val.isConstructed())\n+      throw new BEREncodingException(\"malformed IssuerAndSerialNumber\");\n+\n+    if (DEBUG)\n+      debug(\"  IssuerAndSerialNumber: \" + val);\n+\n+    val = ber.read();\n+    if (!val.isConstructed())\n+      throw new BEREncodingException(\"malformed Issuer\");\n+    issuer = new X500Principal(val.getEncoded());\n+    ber.skip(val.getLength());\n+    if (DEBUG)\n+      debug(\"    Issuer: \" + issuer);\n+\n+    val = ber.read();\n+    if (val.getTag() != BER.INTEGER)\n+      throw new BEREncodingException(\"malformed SerialNumber\");\n+    serialNumber = (BigInteger) val.getValue();\n+    if (DEBUG)\n+      debug(\"    SerialNumber: \" + serialNumber);\n+\n+    val = ber.read();\n+    if (!val.isConstructed())\n+      throw new BEREncodingException(\"malformed DigestAlgorithmIdentifier\");\n+    if (DEBUG)\n+      debug(\"  DigestAlgorithmIdentifier: \" + val);\n+\n+    int count = 0;\n+    DERValue val2 = ber.read();\n+    if (val2.getTag() != BER.OBJECT_IDENTIFIER)\n+      throw new BEREncodingException(\"malformed AlgorithmIdentifier\");\n+    digestAlgorithmId = (OID) val2.getValue();\n+    if (DEBUG)\n+      debug(\"    OID: \" + digestAlgorithmId);\n+\n+    if (BERValue.isIndefinite(val))\n+      {\n+        val2 = ber.read();\n+        if (val2 != BER.END_OF_SEQUENCE)\n+          {\n+            digestAlgorithmParams = val2.getEncoded();\n+            val2 = ber.read();\n+            if (val2 != BER.END_OF_SEQUENCE)\n+              throw new BEREncodingException(\"expecting BER end-of-sequence\");\n+          }\n+        else\n+          digestAlgorithmParams = null;\n+      }\n+    else if (val2.getEncodedLength() < val.getLength())\n+      {\n+        val2 = ber.read();\n+        digestAlgorithmParams = val2.getEncoded();\n+        if (val2.isConstructed())\n+          ber.skip(val2.getLength());\n+      }\n+    else\n+      digestAlgorithmParams = null;\n+    if(DEBUG)\n+      debug(\"    params: \" + (digestAlgorithmParams == null ? null\n+                              : new BigInteger(digestAlgorithmParams).toString(16)));\n+\n+    val = ber.read();\n+    if (val.getTag() == 0)\n+      {\n+        authenticatedAttributes = val.getEncoded();\n+        val = ber.read();\n+        if (val.isConstructed())\n+          ber.skip(val.getLength());\n+        if (DEBUG)\n+          debug(\"  AuthenticatedAttributes: \" + val);\n+        val = ber.read();\n+      }\n+    else\n+      authenticatedAttributes = null;\n+\n+    if (!val.isConstructed())\n+      throw new BEREncodingException(\"malformed DigestEncryptionAlgorithmIdentifier\");\n+    if (DEBUG)\n+      debug(\"  DigestEncryptionAlgorithmIdentifier: \" + val);\n+    count = 0;\n+    val2 = ber.read();\n+    if (val2.getTag() != BER.OBJECT_IDENTIFIER)\n+      throw new BEREncodingException(\"malformed AlgorithmIdentifier\");\n+    digestEncryptionAlgorithmId = (OID) val2.getValue();\n+    if (DEBUG)\n+      debug(\"    OID: \" + digestEncryptionAlgorithmId);\n+\n+    if (BERValue.isIndefinite(val))\n+      {\n+        val2 = ber.read();\n+        if (val2 != BER.END_OF_SEQUENCE)\n+          {\n+            digestEncryptionAlgorithmParams = val2.getEncoded();\n+            val2 = ber.read();\n+            if (val2 != BER.END_OF_SEQUENCE)\n+              throw new BEREncodingException(\"expecting BER end-of-sequence\");\n+          }\n+        else\n+          digestEncryptionAlgorithmParams = null;\n+      }\n+    else if (val2.getEncodedLength() < val.getLength())\n+      {\n+        val2 = ber.read();\n+        digestEncryptionAlgorithmParams = val2.getEncoded();\n+        if (val2.isConstructed())\n+          ber.skip(val2.getLength());\n+      }\n+    else\n+      digestEncryptionAlgorithmParams = null;\n+    if(DEBUG)\n+      debug(\"    params: \" + (digestEncryptionAlgorithmParams == null ? null\n+                              : new BigInteger(digestEncryptionAlgorithmParams).toString(16)));\n+\n+    val = ber.read();\n+    if (val.getTag() != BER.OCTET_STRING)\n+      throw new BEREncodingException(\"malformed EncryptedDigest\");\n+    encryptedDigest = (byte[]) val.getValue();\n+    if (DEBUG)\n+      debug(\"  EncryptedDigest: \" + new BigInteger(1, encryptedDigest).toString(16));\n+\n+    if (ber.peek() == 1)\n+      unauthenticatedAttributes = ber.read().getEncoded();\n+    else\n+      unauthenticatedAttributes = null;\n+\n+    if (ber.peek() == 0)\n+      ber.read();\n+  }\n+\n+  public BigInteger getVersion()\n+  {\n+    return version;\n+  }\n+\n+  public BigInteger getSerialNumber()\n+  {\n+    return serialNumber;\n+  }\n+\n+  public X500Principal getIssuer()\n+  {\n+    return issuer;\n+  }\n+\n+  public OID getDigestAlgorithmId()\n+  {\n+    return digestAlgorithmId;\n+  }\n+\n+  public byte[] getDigestAlgorithmParams()\n+  {\n+    return (digestAlgorithmParams != null\n+            ? (byte[]) digestAlgorithmParams.clone()\n+            : null);\n+  }\n+\n+  public byte[] getAuthenticatedAttributes()\n+  {\n+    return (authenticatedAttributes != null\n+            ? (byte[]) authenticatedAttributes.clone()\n+            : null);\n+  }\n+\n+  public OID getDigestEncryptionAlgorithmId()\n+  {\n+    return digestEncryptionAlgorithmId;\n+  }\n+\n+  public byte[] getDigestEncryptionAlgorithmParams()\n+  {\n+    return (digestEncryptionAlgorithmParams != null\n+            ? (byte[]) digestEncryptionAlgorithmParams.clone()\n+            : null);\n+  }\n+\n+  public byte[] getEncryptedDigest()\n+  {\n+    return (encryptedDigest != null ? (byte[]) encryptedDigest.clone() : null);\n+  }\n+\n+  public byte[] getUnauthenticatedAttributes()\n+  {\n+    return (unauthenticatedAttributes != null\n+            ? (byte[]) unauthenticatedAttributes.clone()\n+            : null);\n+  }\n+}"}, {"sha": "e82483c5adfdd5c3ca9067a401107daa6447c6da", "filename": "libjava/gnu/java/security/provider/GnuDSAPrivateKey.java", "status": "modified", "additions": 63, "deletions": 4, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnuDSAPrivateKey.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnuDSAPrivateKey.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnuDSAPrivateKey.java?ref=2f6363f95e3124b5fe08279eeebe47c4a03dad71", "patch": "@@ -1,5 +1,5 @@\n /* GnuDSAPrivateKey.java --- Gnu DSA Private Key\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999,2003,2004  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,13 +38,25 @@\n \n package gnu.java.security.provider;\n \n+import gnu.java.security.OID;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERValue;\n+import gnu.java.security.der.DERWriter;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n import java.math.BigInteger;\n+\n import java.security.interfaces.DSAPrivateKey;\n import java.security.interfaces.DSAParams;\n import java.security.spec.DSAParameterSpec;\n \n+import java.util.ArrayList;\n+\n public class GnuDSAPrivateKey implements DSAPrivateKey\n {\n+  private byte[] encodedKey;\n   BigInteger x;\n   BigInteger p;\n   BigInteger q;\n@@ -65,13 +77,57 @@ public String getAlgorithm()\n \n   public String getFormat()\n   {\n-    return null;\n+    return \"PKCS#8\";\n   }\n \n+  /**\n+   * Encodes this key as a <code>PrivateKeyInfo</code>, as described in\n+   * PKCS #8. The ASN.1 specification for this structure is:\n+   *\n+   * <blockquote><pre>\n+   * PrivateKeyInfo ::= SEQUENCE {\n+   *   version Version,\n+   *   privateKeyAlgorithm PrivateKeyAlgorithmIdentifier,\n+   *   privateKey PrivateKey,\n+   *   attributes [0] IMPLICIT Attributes OPTIONAL }\n+   *\n+   * Version ::= INTEGER\n+   *\n+   * PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier\n+   *\n+   * PrivateKey ::= OCTET STRING\n+   *\n+   * Attributes ::= SET OF Attribute\n+   * </pre></blockquote>\n+   *\n+   * <p>DSA private keys (in Classpath at least) have no attributes.\n+   */\n   public byte[] getEncoded()\n   {\n+    if (encodedKey != null)\n+      return (byte[]) encodedKey.clone();\n+    try\n+      {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        ArrayList pki = new ArrayList(3);\n+        pki.add(new DERValue(DER.INTEGER, BigInteger.ZERO));\n+        ArrayList algId = new ArrayList(2);\n+        algId.add(new DERValue(DER.OBJECT_IDENTIFIER,\n+                  new OID(\"1.2.840.10040.4.1\")));\n+        ArrayList algParams = new ArrayList(3);\n+        algParams.add(new DERValue(DER.INTEGER, p));\n+        algParams.add(new DERValue(DER.INTEGER, q));\n+        algParams.add(new DERValue(DER.INTEGER, g));\n+        algId.add(new DERValue(DER.CONSTRUCTED|DER.SEQUENCE, algParams));\n+        pki.add(new DERValue(DER.OCTET_STRING, x.toByteArray()));\n+        DERWriter.write(out, new DERValue(DER.CONSTRUCTED|DER.SEQUENCE, pki));\n+        return (byte[]) (encodedKey = out.toByteArray()).clone();\n+      }\n+    catch (IOException ioe)\n+      {\n     return null;\n   }\n+  }\n \n   public DSAParams getParams()\n   {\n@@ -85,7 +141,10 @@ public BigInteger getX()\n \n   public String toString()\n   {\n-    return \"GnuDSAPrivateKey: x=\" + x.toString(16) + \" p=\" + p.toString(16)\n-      + \" q=\" + q.toString(16) + \" g=\" + g.toString(16);\n+    return \"GnuDSAPrivateKey: x=\"\n+      + (x != null ? x.toString(16) : \"null\") + \" p=\"\n+      + (p != null ? p.toString(16) : \"null\") + \" q=\"\n+      + (q != null ? q.toString(16) : \"null\") + \" g=\"\n+      + (g != null ? g.toString(16) : \"null\");\n   }\n }"}, {"sha": "24600d6c583f87e9a97961ebe4e0304a0877e892", "filename": "libjava/gnu/java/security/provider/GnuDSAPublicKey.java", "status": "modified", "additions": 53, "deletions": 4, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnuDSAPublicKey.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnuDSAPublicKey.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnuDSAPublicKey.java?ref=2f6363f95e3124b5fe08279eeebe47c4a03dad71", "patch": "@@ -1,5 +1,5 @@\n /* GnuDSAPublicKey.java --- Gnu DSA Public Key\n-   Copyright (C) 1999,2003 Free Software Foundation, Inc.\n+   Copyright (C) 1999,2003,2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,13 +38,26 @@\n \n package gnu.java.security.provider;\n \n+import gnu.java.security.OID;\n+import gnu.java.security.der.BitString;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERValue;\n+import gnu.java.security.der.DERWriter;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n import java.math.BigInteger;\n+\n import java.security.interfaces.DSAPublicKey;\n import java.security.interfaces.DSAParams;\n import java.security.spec.DSAParameterSpec;\n \n+import java.util.ArrayList;\n+\n public class GnuDSAPublicKey implements DSAPublicKey\n {\n+  private byte[] encodedKey;\n   BigInteger y;\n   BigInteger p;\n   BigInteger q;\n@@ -65,16 +78,49 @@ public String getAlgorithm()\n \n   public String getFormat()\n   {\n-    return null;\n+    return \"X.509\";\n   }\n \n+  /**\n+   * The encoded form of DSA public keys is:\n+   *\n+   * <blockquote><pre>\n+   * SubjectPublicKeyInfo ::= SEQUENCE {\n+   *   algorithm AlgorithmIdentifier,\n+   *   subjectPublicKey BIT STRING }\n+   * </pre></blockquote>\n+   */\n   public byte[] getEncoded()\n   {\n+    if (encodedKey != null)\n+      return (byte[]) encodedKey.clone();\n+    try\n+      {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        ArrayList spki = new ArrayList(2);\n+        ArrayList alg = new ArrayList(2);\n+        alg.add(new DERValue(DER.OBJECT_IDENTIFIER,\n+                new OID(\"1.2.840.113549.1.1.1\")));\n+        ArrayList params = new ArrayList(3);\n+        params.add(new DERValue(DER.INTEGER, p));\n+        params.add(new DERValue(DER.INTEGER, q));\n+        params.add(new DERValue(DER.INTEGER, g));\n+        alg.add(new DERValue(DER.CONSTRUCTED|DER.SEQUENCE, params));\n+        spki.add(new DERValue(DER.CONSTRUCTED|DER.SEQUENCE, alg));\n+        spki.add(new DERValue(DER.BIT_STRING, new BitString(y.toByteArray())));\n+        DERWriter.write(out, new DERValue(DER.CONSTRUCTED|DER.SEQUENCE, spki));\n+        return (byte[]) (encodedKey = out.toByteArray()).clone();\n+      }\n+    catch (IOException ioe)\n+      {\n     return null;\n   }\n+  }\n \n   public DSAParams getParams()\n   {\n+    if (p == null || q == null || g == null)\n+      return null;\n     return (DSAParams)(new DSAParameterSpec(p,q,g));\n   }\n \n@@ -85,7 +131,10 @@ public BigInteger getY()\n \n   public String toString()\n   {\n-    return \"GnuDSAPublicKey: y=\" + y.toString(16) + \" p=\" + p.toString(16)\n-      + \" q=\" + q.toString(16) + \" g=\" + g.toString(16);\n+    return\n+      \"GnuDSAPublicKey: y=\" + (y != null ? y.toString(16) : \"(null)\") +\n+      \" p=\" + (p != null ? p.toString(16) : \"(null)\") +\n+      \" q=\" + (q != null ? q.toString(16) : \"(null)\") +\n+      \" g=\" + (g != null ? g.toString(16) : \"(null)\");\n   }\n }"}, {"sha": "919fc9de0f61a0b211777121dc404243aa200647", "filename": "libjava/java/net/URLClassLoader.java", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fjava%2Fnet%2FURLClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fjava%2Fnet%2FURLClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLClassLoader.java?ref=2f6363f95e3124b5fe08279eeebe47c4a03dad71", "patch": "@@ -332,7 +332,7 @@ public JarURLLoader(URLClassLoader classloader, URL baseURL)\n \t  Manifest manifest;\n \t  Attributes attributes;\n \t  String classPathString;\n-\t  \n+\n \t  if ((manifest = jarfile.getManifest()) != null\n \t      && (attributes = manifest.getMainAttributes()) != null\n \t      && ((classPathString \n@@ -422,7 +422,11 @@ int getLength()\n \n     Certificate[] getCertificates()\n     {\n-      return entry.getCertificates();\n+      // We have to get the entry from the jar file again, because the\n+      // certificates will not be available until the entire entry has\n+      // been read.\n+      return ((JarEntry) ((JarURLLoader) loader).jarfile.getEntry(name))\n+        .getCertificates();\n     }\n \n     URL getURL()\n@@ -977,9 +981,10 @@ protected Class findClass(final String className)\n \n         // And finally construct the class!\n         SecurityManager sm = System.getSecurityManager();\n+        Class result = null;\n         if (sm != null && securityContext != null)\n           {\n-\t    return (Class)AccessController.doPrivileged\n+            result = (Class)AccessController.doPrivileged\n               (new PrivilegedAction()\n                 {\n                   public Object run()\n@@ -991,7 +996,10 @@ public Object run()\n                 }, securityContext);\n           }\n         else\n-\t  return defineClass(className, classData, 0, classData.length, source);\n+          result = defineClass(className, classData, 0, classData.length, source);\n+\n+        super.setSigners(result, resource.getCertificates());\n+        return result;\n       }\n     catch (IOException ioe)\n       {"}, {"sha": "c66881f1900c2d2d8868215d92e49f051b1bc620", "filename": "libjava/java/util/jar/JarFile.java", "status": "modified", "additions": 714, "deletions": 15, "changes": 729, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fjava%2Futil%2Fjar%2FJarFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6363f95e3124b5fe08279eeebe47c4a03dad71/libjava%2Fjava%2Futil%2Fjar%2FJarFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fjar%2FJarFile.java?ref=2f6363f95e3124b5fe08279eeebe47c4a03dad71", "patch": "@@ -35,13 +35,38 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n+\n package java.util.jar;\n \n+import gnu.java.io.Base64InputStream;\n+import gnu.java.security.OID;\n+import gnu.java.security.pkcs.PKCS7SignedData;\n+import gnu.java.security.pkcs.SignerInfo;\n+\n+import java.io.ByteArrayOutputStream;\n import java.io.File;\n import java.io.FileNotFoundException;\n+import java.io.FilterInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.security.InvalidKeyException;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Signature;\n+import java.security.SignatureException;\n+import java.security.cert.CRLException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.zip.ZipEntry;\n import java.util.zip.ZipException;\n import java.util.zip.ZipFile;\n@@ -52,11 +77,11 @@\n  * Note that this class is not a subclass of java.io.File but a subclass of\n  * java.util.zip.ZipFile and you can only read JarFiles with it (although\n  * there are constructors that take a File object).\n- * <p>\n- * XXX - verification of Manifest signatures is not yet implemented.\n  *\n  * @since 1.2\n  * @author Mark Wielaard (mark@klomp.org)\n+ * @author Casey Marshall (csm@gnu.org) wrote the certificate and entry\n+ *  verification code.\n  */\n public class JarFile extends ZipFile\n {\n@@ -65,18 +90,64 @@ public class JarFile extends ZipFile\n   /** The name of the manifest entry: META-INF/MANIFEST.MF */\n   public static final String MANIFEST_NAME = \"META-INF/MANIFEST.MF\";\n \n+  /** The META-INF directory entry. */\n+  private static final String META_INF = \"META-INF/\";\n+\n+  /** The suffix for PKCS7 DSA signature entries. */\n+  private static final String PKCS7_DSA_SUFFIX = \".DSA\";\n+\n+  /** The suffix for PKCS7 RSA signature entries. */\n+  private static final String PKCS7_RSA_SUFFIX = \".RSA\";\n+\n+  /** The suffix for digest attributes. */\n+  private static final String DIGEST_KEY_SUFFIX = \"-Digest\";\n+\n+  /** The suffix for signature files. */\n+  private static final String SF_SUFFIX = \".SF\";\n+\n+  // Signature OIDs.\n+  private static final OID MD2_OID = new OID(\"1.2.840.113549.2.2\");\n+  private static final OID MD4_OID = new OID(\"1.2.840.113549.2.4\");\n+  private static final OID MD5_OID = new OID(\"1.2.840.113549.2.5\");\n+  private static final OID SHA1_OID = new OID(\"1.3.14.3.2.26\");\n+  private static final OID DSA_ENCRYPTION_OID = new OID(\"1.2.840.10040.4.1\");\n+  private static final OID RSA_ENCRYPTION_OID = new OID(\"1.2.840.113549.1.1.1\");\n+\n   /**\n    * The manifest of this file, if any, otherwise null.\n    * Read when first needed.\n    */\n   private Manifest manifest;\n \n   /** Whether to verify the manifest and all entries. */\n-  private boolean verify;\n+  boolean verify;\n \n   /** Whether the has already been loaded. */\n   private boolean manifestRead = false;\n \n+  /** Whether the signature files have been loaded. */\n+  boolean signaturesRead = false;\n+\n+  /**\n+   * A map between entry names and booleans, signaling whether or\n+   * not that entry has been verified.\n+   * Only be accessed with lock on this JarFile*/\n+  HashMap verified = new HashMap();\n+\n+  /**\n+   * A mapping from entry name to certificates, if any.\n+   * Only accessed with lock on this JarFile.\n+   */\n+  HashMap entryCerts;\n+\n+  static boolean DEBUG = false;\n+  static void debug(Object msg)\n+  {\n+    System.err.print(JarFile.class.getName());\n+    System.err.print(\" >>> \");\n+    System.err.println(msg);\n+  }\n+\n   // Constructors\n \n   /**\n@@ -235,22 +306,23 @@ private Manifest readManifest()\n    */\n   public Enumeration entries() throws IllegalStateException\n   {\n-    return new JarEnumeration(super.entries());\n+    return new JarEnumeration(super.entries(), this);\n   }\n \n   /**\n    * Wraps a given Zip Entries Enumeration. For every zip entry a\n    * JarEntry is created and the corresponding Attributes are looked up.\n-   * XXX - Should also look up the certificates.\n    */\n-  private class JarEnumeration implements Enumeration\n+  private static class JarEnumeration implements Enumeration\n   {\n \n     private final Enumeration entries;\n+    private final JarFile jarfile;\n \n-    JarEnumeration(Enumeration e)\n+    JarEnumeration(Enumeration e, JarFile f)\n     {\n       entries = e;\n+      jarfile = f;\n     }\n \n     public boolean hasMoreElements()\n@@ -265,7 +337,7 @@ public Object nextElement()\n       Manifest manifest;\n       try\n \t{\n-\t  manifest = getManifest();\n+\t  manifest = jarfile.getManifest();\n \t}\n       catch (IOException ioe)\n \t{\n@@ -276,7 +348,36 @@ public Object nextElement()\n \t{\n \t  jar.attr = manifest.getAttributes(jar.getName());\n \t}\n-      // XXX jar.certs\n+\n+      synchronized(jarfile)\n+\t{\n+\t  if (!jarfile.signaturesRead)\n+\t    try\n+\t      {\n+\t\tjarfile.readSignatures();\n+\t      }\n+\t    catch (IOException ioe)\n+\t      {\n+\t\tif (JarFile.DEBUG)\n+\t\t  {\n+\t\t    JarFile.debug(ioe);\n+\t\t    ioe.printStackTrace();\n+\t\t  }\n+\t\tjarfile.signaturesRead = true; // fudge it.\n+\t      }\n+\n+\t  // Include the certificates only if we have asserted that the\n+\t  // signatures are valid. This means the certificates will not be\n+\t  // available if the entry hasn't been read yet.\n+\t  if (jarfile.entryCerts != null\n+\t      && jarfile.verified.get(zip.getName()) == Boolean.TRUE)\n+\t    {\n+\t      Set certs = (Set) jarfile.entryCerts.get(jar.getName());\n+\t      if (certs != null)\n+\t\tjar.certs = (Certificate[])\n+\t\t  certs.toArray(new Certificate[certs.size()]);\n+\t    }\n+\t}\n       return jar;\n     }\n   }\n@@ -286,7 +387,7 @@ public Object nextElement()\n    * It actually returns a JarEntry not a zipEntry\n    * @param name XXX\n    */\n-  public ZipEntry getEntry(String name)\n+  public synchronized ZipEntry getEntry(String name)\n   {\n     ZipEntry entry = super.getEntry(name);\n     if (entry != null)\n@@ -305,23 +406,66 @@ public ZipEntry getEntry(String name)\n \tif (manifest != null)\n \t  {\n \t    jarEntry.attr = manifest.getAttributes(name);\n-\t    // XXX jarEntry.certs\n+          }\n+\n+\tif (!signaturesRead)\n+\t  try\n+\t    {\n+\t      readSignatures();\n+\t    }\n+\t  catch (IOException ioe)\n+\t    {\n+\t      if (DEBUG)\n+\t\t{\n+\t\t  debug(ioe);\n+\t\t  ioe.printStackTrace();\n+\t\t}\n+\t      signaturesRead = true;\n+\t    }\n+\t// See the comments in the JarEnumeration for why we do this\n+\t// check.\n+\tif (DEBUG)\n+\t  debug(\"entryCerts=\" + entryCerts + \" verified \" + name\n+\t\t+ \" ? \" + verified.get(name));\n+\tif (entryCerts != null && verified.get(name) == Boolean.TRUE)\n+\t  {\n+\t    Set certs = (Set) entryCerts.get(name);\n+\t    if (certs != null)\n+\t      jarEntry.certs = (Certificate[])\n+\t\tcerts.toArray(new Certificate[certs.size()]);\n \t  }\n \treturn jarEntry;\n       }\n     return null;\n   }\n \n   /**\n-   * XXX should verify the inputstream\n-   * @param entry XXX\n+   * Returns an input stream for the given entry. If configured to\n+   * verify entries, the input stream returned will verify them while\n+   * the stream is read, but only on the first time.\n+   *\n+   * @param entry The entry to get the input stream for.\n    * @exception ZipException XXX\n    * @exception IOException XXX\n    */\n   public synchronized InputStream getInputStream(ZipEntry entry) throws\n     ZipException, IOException\n   {\n-    return super.getInputStream(entry);\t// XXX verify\n+    // If we haven't verified the hash, do it now.\n+    if (!verified.containsKey(entry.getName()) && verify)\n+      {\n+        if (DEBUG)\n+          debug(\"reading and verifying \" + entry);\n+        return new EntryInputStream(entry, super.getInputStream(entry), this);\n+      }\n+    else\n+      {\n+        if (DEBUG)\n+          debug(\"reading already verified entry \" + entry);\n+        if (verify && verified.get(entry.getName()) == Boolean.FALSE)\n+          throw new ZipException(\"digest for \" + entry + \" is invalid\");\n+        return super.getInputStream(entry);\n+      }\n   }\n \n   /**\n@@ -342,11 +486,566 @@ public JarEntry getJarEntry(String name)\n    * Returns the manifest for this JarFile or null when the JarFile does not\n    * contain a manifest file.\n    */\n-  public Manifest getManifest() throws IOException\n+  public synchronized Manifest getManifest() throws IOException\n   {\n     if (!manifestRead)\n       manifest = readManifest();\n \n     return manifest;\n   }\n+\n+  // Only called with lock on this JarFile.\n+  private void readSignatures() throws IOException\n+  {\n+    Map pkcs7Dsa = new HashMap();\n+    Map pkcs7Rsa = new HashMap();\n+    Map sigFiles = new HashMap();\n+\n+    // Phase 1: Read all signature files. These contain the user\n+    // certificates as well as the signatures themselves.\n+    for (Enumeration e = super.entries(); e.hasMoreElements(); )\n+      {\n+        ZipEntry ze = (ZipEntry) e.nextElement();\n+        String name = ze.getName();\n+        if (name.startsWith(META_INF))\n+          {\n+            String alias = name.substring(META_INF.length());\n+            if (alias.lastIndexOf('.') >= 0)\n+              alias = alias.substring(0, alias.lastIndexOf('.'));\n+\n+            if (name.endsWith(PKCS7_DSA_SUFFIX) || name.endsWith(PKCS7_RSA_SUFFIX))\n+              {\n+                if (DEBUG)\n+                  debug(\"reading PKCS7 info from \" + name + \", alias=\" + alias);\n+                PKCS7SignedData sig = null;\n+                try\n+                  {\n+                    sig = new PKCS7SignedData(super.getInputStream(ze));\n+                  }\n+                catch (CertificateException ce)\n+                  {\n+                    IOException ioe = new IOException(\"certificate parsing error\");\n+                    ioe.initCause(ce);\n+                    throw ioe;\n+                  }\n+                catch (CRLException crle)\n+                  {\n+                    IOException ioe = new IOException(\"CRL parsing error\");\n+                    ioe.initCause(crle);\n+                    throw ioe;\n+                  }\n+                if (name.endsWith(PKCS7_DSA_SUFFIX))\n+                  pkcs7Dsa.put(alias, sig);\n+                else if (name.endsWith(PKCS7_RSA_SUFFIX))\n+                  pkcs7Rsa.put(alias, sig);\n+              }\n+            else if (name.endsWith(SF_SUFFIX))\n+              {\n+                if (DEBUG)\n+                  debug(\"reading signature file for \" + alias + \": \" + name);\n+                Manifest sf = new Manifest(super.getInputStream(ze));\n+                sigFiles.put(alias, sf);\n+                if (DEBUG)\n+                  debug(\"result: \" + sf);\n+              }\n+          }\n+      }\n+\n+    // Phase 2: verify the signatures on any signature files.\n+    Set validCerts = new HashSet();\n+    Map entryCerts = new HashMap();\n+    for (Iterator it = sigFiles.entrySet().iterator(); it.hasNext(); )\n+      {\n+        int valid = 0;\n+        Map.Entry e = (Map.Entry) it.next();\n+        String alias = (String) e.getKey();\n+\n+        PKCS7SignedData sig = (PKCS7SignedData) pkcs7Dsa.get(alias);\n+        if (sig != null)\n+          {\n+            Certificate[] certs = sig.getCertificates();\n+            Set signerInfos = sig.getSignerInfos();\n+            for (Iterator it2 = signerInfos.iterator(); it2.hasNext(); )\n+              verify(certs, (SignerInfo) it2.next(), alias, validCerts);\n+          }\n+\n+        sig = (PKCS7SignedData) pkcs7Rsa.get(alias);\n+        if (sig != null)\n+          {\n+            Certificate[] certs = sig.getCertificates();\n+            Set signerInfos = sig.getSignerInfos();\n+            for (Iterator it2 = signerInfos.iterator(); it2.hasNext(); )\n+              verify(certs, (SignerInfo) it2.next(), alias, validCerts);\n+          }\n+\n+        // It isn't a signature for anything. Punt it.\n+        if (validCerts.isEmpty())\n+          {\n+            it.remove();\n+            continue;\n+          }\n+\n+        entryCerts.put(e.getValue(), new HashSet(validCerts));\n+        validCerts.clear();\n+      }\n+\n+    // Phase 3: verify the signature file signatures against the manifest,\n+    // mapping the entry name to the target certificates.\n+    this.entryCerts = new HashMap();\n+    for (Iterator it = entryCerts.entrySet().iterator(); it.hasNext(); )\n+      {\n+        Map.Entry e = (Map.Entry) it.next();\n+        Manifest sigfile = (Manifest) e.getKey();\n+        Map entries = sigfile.getEntries();\n+        Set certificates = (Set) e.getValue();\n+\n+        for (Iterator it2 = entries.entrySet().iterator(); it2.hasNext(); )\n+          {\n+            Map.Entry e2 = (Map.Entry) it2.next();\n+            String entryname = String.valueOf(e2.getKey());\n+            Attributes attr = (Attributes) e2.getValue();\n+            if (verifyHashes(entryname, attr))\n+              {\n+                if (DEBUG)\n+                  debug(\"entry \" + entryname + \" has certificates \" + certificates);\n+                Set s = (Set) this.entryCerts.get(entryname);\n+                if (s != null)\n+                  s.addAll(certificates);\n+                else\n+                  this.entryCerts.put(entryname, new HashSet(certificates));\n+              }\n+          }\n+      }\n+\n+    signaturesRead = true;\n+  }\n+\n+  /**\n+   * Tell if the given signer info is over the given alias's signature file,\n+   * given one of the certificates specified.\n+   */\n+  private void verify(Certificate[] certs, SignerInfo signerInfo,\n+                      String alias, Set validCerts)\n+  {\n+    Signature sig = null;\n+    try\n+      {\n+        OID alg = signerInfo.getDigestEncryptionAlgorithmId();\n+        if (alg.equals(DSA_ENCRYPTION_OID))\n+          {\n+            if (!signerInfo.getDigestAlgorithmId().equals(SHA1_OID))\n+              return;\n+            sig = Signature.getInstance(\"SHA1withDSA\");\n+          }\n+        else if (alg.equals(RSA_ENCRYPTION_OID))\n+          {\n+            OID hash = signerInfo.getDigestAlgorithmId();\n+            if (hash.equals(MD2_OID))\n+              sig = Signature.getInstance(\"md2WithRsaEncryption\");\n+            else if (hash.equals(MD4_OID))\n+              sig = Signature.getInstance(\"md4WithRsaEncryption\");\n+            else if (hash.equals(MD5_OID))\n+              sig = Signature.getInstance(\"md5WithRsaEncryption\");\n+            else if (hash.equals(SHA1_OID))\n+              sig = Signature.getInstance(\"sha1WithRsaEncryption\");\n+            else\n+              return;\n+          }\n+        else\n+          {\n+            if (DEBUG)\n+              debug(\"unsupported signature algorithm: \" + alg);\n+            return;\n+          }\n+      }\n+    catch (NoSuchAlgorithmException nsae)\n+      {\n+        if (DEBUG)\n+          {\n+            debug(nsae);\n+            nsae.printStackTrace();\n+          }\n+        return;\n+      }\n+    ZipEntry sigFileEntry = super.getEntry(META_INF + alias + SF_SUFFIX);\n+    if (sigFileEntry == null)\n+      return;\n+    for (int i = 0; i < certs.length; i++)\n+      {\n+        if (!(certs[i] instanceof X509Certificate))\n+          continue;\n+        X509Certificate cert = (X509Certificate) certs[i];\n+        if (!cert.getIssuerX500Principal().equals(signerInfo.getIssuer()) ||\n+            !cert.getSerialNumber().equals(signerInfo.getSerialNumber()))\n+          continue;\n+        try\n+          {\n+            sig.initVerify(cert.getPublicKey());\n+            InputStream in = super.getInputStream(sigFileEntry);\n+            if (in == null)\n+              continue;\n+            byte[] buf = new byte[1024];\n+            int len = 0;\n+            while ((len = in.read(buf)) != -1)\n+              sig.update(buf, 0, len);\n+            if (sig.verify(signerInfo.getEncryptedDigest()))\n+              {\n+                if (DEBUG)\n+                  debug(\"signature for \" + cert.getSubjectDN() + \" is good\");\n+                validCerts.add(cert);\n+              }\n+          }\n+        catch (IOException ioe)\n+          {\n+            continue;\n+          }\n+        catch (InvalidKeyException ike)\n+          {\n+            continue;\n+          }\n+        catch (SignatureException se)\n+          {\n+            continue;\n+          }\n+      }\n+  }\n+\n+  /**\n+   * Verifies that the digest(s) in a signature file were, in fact, made\n+   * over the manifest entry for ENTRY.\n+   *\n+   * @param entry The entry name.\n+   * @param attr The attributes from the signature file to verify.\n+   */\n+  private boolean verifyHashes(String entry, Attributes attr)\n+  {\n+    int verified = 0;\n+\n+    // The bytes for ENTRY's manifest entry, which are signed in the\n+    // signature file.\n+    byte[] entryBytes = null;\n+    try\n+      {\n+        entryBytes = readManifestEntry(super.getEntry(entry));\n+      }\n+    catch (IOException ioe)\n+      {\n+        if (DEBUG)\n+          {\n+            debug(ioe);\n+            ioe.printStackTrace();\n+          }\n+        return false;\n+      }\n+\n+    for (Iterator it = attr.entrySet().iterator(); it.hasNext(); )\n+      {\n+        Map.Entry e = (Map.Entry) it.next();\n+        String key = String.valueOf(e.getKey());\n+        if (!key.endsWith(DIGEST_KEY_SUFFIX))\n+          continue;\n+        String alg = key.substring(0, key.length() - DIGEST_KEY_SUFFIX.length());\n+        try\n+          {\n+            byte[] hash = Base64InputStream.decode((String) e.getValue());\n+            MessageDigest md = MessageDigest.getInstance(alg);\n+            md.update(entryBytes);\n+            byte[] hash2 = md.digest();\n+            if (DEBUG)\n+              debug(\"verifying SF entry \" + entry + \" alg: \" + md.getAlgorithm()\n+                    + \" expect=\" + new java.math.BigInteger(hash).toString(16)\n+                    + \" comp=\" + new java.math.BigInteger(hash2).toString(16));\n+            if (!Arrays.equals(hash, hash2))\n+              return false;\n+            verified++;\n+          }\n+        catch (IOException ioe)\n+          {\n+            if (DEBUG)\n+              {\n+                debug(ioe);\n+                ioe.printStackTrace();\n+              }\n+            return false;\n+          }\n+        catch (NoSuchAlgorithmException nsae)\n+          {\n+            if (DEBUG)\n+              {\n+                debug(nsae);\n+                nsae.printStackTrace();\n+              }\n+            return false;\n+          }\n+      }\n+\n+    // We have to find at least one valid digest.\n+    return verified > 0;\n+  }\n+\n+  /**\n+   * Read the raw bytes that comprise a manifest entry. We can't use the\n+   * Manifest object itself, because that loses information (such as line\n+   * endings, and order of entries).\n+   */\n+  private byte[] readManifestEntry(ZipEntry entry) throws IOException\n+  {\n+    InputStream in = super.getInputStream(super.getEntry(MANIFEST_NAME));\n+    ByteArrayOutputStream out = new ByteArrayOutputStream();\n+    byte[] target = (\"Name: \" + entry.getName()).getBytes();\n+    int t = 0, c, prev = -1, state = 0, l = -1;\n+\n+    while ((c = in.read()) != -1)\n+      {\n+//         if (DEBUG)\n+//           debug(\"read \"\n+//                 + (c == '\\n' ? \"\\\\n\" : (c == '\\r' ? \"\\\\r\" : String.valueOf((char) c)))\n+//                 + \" state=\" + state + \" prev=\"\n+//                 + (prev == '\\n' ? \"\\\\n\" : (prev == '\\r' ? \"\\\\r\" : String.valueOf((char) prev)))\n+//                 + \" t=\" + t + (t < target.length ? (\" target[t]=\" + (char) target[t]) : \"\")\n+//                 + \" l=\" + l);\n+        switch (state)\n+          {\n+\n+          // Step 1: read until we find the \"target\" bytes: the start\n+          // of the entry we need to read.\n+          case 0:\n+            if (((byte) c) != target[t])\n+              t = 0;\n+            else\n+              {\n+                t++;\n+                if (t == target.length)\n+                  {\n+                    out.write(target);\n+                    state = 1;\n+                  }\n+              }\n+            break;\n+\n+          // Step 2: assert that there is a newline character after\n+          // the \"target\" bytes.\n+          case 1:\n+            if (c != '\\n' && c != '\\r')\n+              {\n+                out.reset();\n+                t = 0;\n+                state = 0;\n+              }\n+            else\n+              {\n+                out.write(c);\n+                state = 2;\n+              }\n+            break;\n+\n+          // Step 3: read this whole entry, until we reach an empty\n+          // line.\n+          case 2:\n+            if (c == '\\n')\n+              {\n+                out.write(c);\n+                // NL always terminates a line.\n+                if (l == 0 || (l == 1 && prev == '\\r'))\n+                  return out.toByteArray();\n+                l = 0;\n+              }\n+            else\n+              {\n+                // Here we see a blank line terminated by a CR,\n+                // followed by the next entry. Technically, `c' should\n+                // always be 'N' at this point.\n+                if (l == 1 && prev == '\\r')\n+                  return out.toByteArray();\n+                out.write(c);\n+                l++;\n+              }\n+            prev = c;\n+            break;\n+\n+          default:\n+            throw new RuntimeException(\"this statement should be unreachable\");\n+          }\n+      }\n+\n+    // The last entry, with a single CR terminating the line.\n+    if (state == 2 && prev == '\\r' && l == 0)\n+      return out.toByteArray();\n+\n+    // We should not reach this point, we didn't find the entry (or, possibly,\n+    // it is the last entry and is malformed).\n+    throw new IOException(\"could not find \" + entry + \" in manifest\");\n+  }\n+\n+  /**\n+   * A utility class that verifies jar entries as they are read.\n+   */\n+  private static class EntryInputStream extends FilterInputStream\n+  {\n+    private final JarFile jarfile;\n+    private final long length;\n+    private long pos;\n+    private final ZipEntry entry;\n+    private final byte[][] hashes;\n+    private final MessageDigest[] md;\n+    private boolean checked;\n+\n+    EntryInputStream(final ZipEntry entry,\n+\t\t     final InputStream in,\n+\t\t     final JarFile jar)\n+      throws IOException\n+    {\n+      super(in);\n+      this.entry = entry;\n+      this.jarfile = jar;\n+\n+      length = entry.getSize();\n+      pos = 0;\n+      checked = false;\n+\n+      Attributes attr;\n+      Manifest manifest = jarfile.getManifest();\n+      if (manifest != null)\n+\tattr = manifest.getAttributes(entry.getName());\n+      else\n+\tattr = null;\n+      if (DEBUG)\n+        debug(\"verifying entry \" + entry + \" attr=\" + attr);\n+      if (attr == null)\n+        {\n+          hashes = new byte[0][];\n+          md = new MessageDigest[0];\n+        }\n+      else\n+        {\n+          List hashes = new LinkedList();\n+          List md = new LinkedList();\n+          for (Iterator it = attr.entrySet().iterator(); it.hasNext(); )\n+            {\n+              Map.Entry e = (Map.Entry) it.next();\n+              String key = String.valueOf(e.getKey());\n+              if (key == null)\n+                continue;\n+              if (!key.endsWith(DIGEST_KEY_SUFFIX))\n+                continue;\n+              hashes.add(Base64InputStream.decode((String) e.getValue()));\n+              try\n+                {\n+                  md.add(MessageDigest.getInstance\n+                         (key.substring(0, key.length() - DIGEST_KEY_SUFFIX.length())));\n+                }\n+              catch (NoSuchAlgorithmException nsae)\n+                {\n+                  IOException ioe = new IOException(\"no such message digest: \" + key);\n+                  ioe.initCause(nsae);\n+                  throw ioe;\n+                }\n+            }\n+          if (DEBUG)\n+            debug(\"digests=\" + md);\n+          this.hashes = (byte[][]) hashes.toArray(new byte[hashes.size()][]);\n+          this.md = (MessageDigest[]) md.toArray(new MessageDigest[md.size()]);\n+        }\n+    }\n+\n+    public boolean markSupported()\n+    {\n+      return false;\n+    }\n+\n+    public void mark(int readLimit)\n+    {\n+    }\n+\n+    public void reset()\n+    {\n+    }\n+\n+    public int read() throws IOException\n+    {\n+      int b = super.read();\n+      if (b == -1)\n+        {\n+          eof();\n+          return -1;\n+        }\n+      for (int i = 0; i < md.length; i++)\n+        md[i].update((byte) b);\n+      pos++;\n+      if (length > 0 && pos >= length)\n+        eof();\n+      return b;\n+    }\n+\n+    public int read(byte[] buf, int off, int len) throws IOException\n+    {\n+      int count = super.read(buf, off, (int) Math.min(len, (length != 0\n+                                                            ? length - pos\n+                                                            : Integer.MAX_VALUE)));\n+      if (count == -1 || (length > 0 && pos >= length))\n+        {\n+          eof();\n+          return -1;\n+        }\n+      for (int i = 0; i < md.length; i++)\n+        md[i].update(buf, off, count);\n+      pos += count;\n+      if (length != 0 && pos >= length)\n+        eof();\n+      return count;\n+    }\n+\n+    public int read(byte[] buf) throws IOException\n+    {\n+      return read(buf, 0, buf.length);\n+    }\n+\n+    public long skip(long bytes) throws IOException\n+    {\n+      byte[] b = new byte[1024];\n+      long amount = 0;\n+      while (amount < bytes)\n+        {\n+          int l = read(b, 0, (int) Math.min(b.length, bytes - amount));\n+          if (l == -1)\n+            break;\n+          amount += l;\n+        }\n+      return amount;\n+    }\n+\n+    private void eof() throws IOException\n+    {\n+      if (checked)\n+        return;\n+      checked = true;\n+      for (int i = 0; i < md.length; i++)\n+        {\n+          byte[] hash = md[i].digest();\n+          if (DEBUG)\n+            debug(\"verifying \" + md[i].getAlgorithm() + \" expect=\"\n+                  + new java.math.BigInteger(hashes[i]).toString(16)\n+                  + \" comp=\" + new java.math.BigInteger(hash).toString(16));\n+          if (!Arrays.equals(hash, hashes[i]))\n+            {\n+\t      synchronized(jarfile)\n+\t\t{\n+\t\t  if (DEBUG)\n+\t\t    debug(entry + \" could NOT be verified\");\n+\t\t  jarfile.verified.put(entry.getName(), Boolean.FALSE);\n+\t\t}\n+\t      return;\n+\t      // XXX ??? what do we do here?\n+\t      // throw new ZipException(\"message digest mismatch\");\n+            }\n+        }\n+\n+      synchronized(jarfile)\n+\t{\n+\t  if (DEBUG)\n+\t    debug(entry + \" has been VERIFIED\");\n+\t  jarfile.verified.put(entry.getName(), Boolean.TRUE);\n+\t}\n+    }\n+  }\n }"}]}