{"sha": "4d814b69890171b7d742fabd966e5167b222cfd0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ4MTRiNjk4OTAxNzFiN2Q3NDJmYWJkOTY2ZTUxNjdiMjIyY2ZkMA==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2018-12-17T18:32:31Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2018-12-17T18:32:31Z"}, "message": "Merge dmd upstream 237ca3fbe\n\nBackports a fix where a bad cast to TypeFunction resulted in memory\ncorruption.  The logic in the function semantic has been fixed, and\ncasts have been replaced with a function call to always check the\nfront-end AST node value.\n\nReviewed-on: https://github.com/dlang/dmd/pull/9054\n\nFrom-SVN: r267207", "tree": {"sha": "f23ff2741fedcf6d02736a2b3dc9e7ca2299f01c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f23ff2741fedcf6d02736a2b3dc9e7ca2299f01c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d814b69890171b7d742fabd966e5167b222cfd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d814b69890171b7d742fabd966e5167b222cfd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d814b69890171b7d742fabd966e5167b222cfd0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d814b69890171b7d742fabd966e5167b222cfd0/comments", "author": null, "committer": null, "parents": [{"sha": "22b04f05ab8e05707a031a5b6dfc1eb72d056957", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22b04f05ab8e05707a031a5b6dfc1eb72d056957", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22b04f05ab8e05707a031a5b6dfc1eb72d056957"}], "stats": {"total": 112, "additions": 59, "deletions": 53}, "files": [{"sha": "bc35d4adc1f4374b64a68b4c7ddc080774b27935", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d814b69890171b7d742fabd966e5167b222cfd0/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d814b69890171b7d742fabd966e5167b222cfd0/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=4d814b69890171b7d742fabd966e5167b222cfd0", "patch": "@@ -1,4 +1,4 @@\n-e2fe2687b817a201528abaa3aa882333e04db01b\n+237ca3fbe8f9ac4b64e26ce912c20439ee4fc63a\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "ce9849fc7dda9d0cbf34f0daebc49c82b259171b", "filename": "gcc/d/dmd/dclass.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d814b69890171b7d742fabd966e5167b222cfd0/gcc%2Fd%2Fdmd%2Fdclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d814b69890171b7d742fabd966e5167b222cfd0/gcc%2Fd%2Fdmd%2Fdclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdclass.c?ref=4d814b69890171b7d742fabd966e5167b222cfd0", "patch": "@@ -805,7 +805,7 @@ void ClassDeclaration::semantic(Scope *sc)\n         if (fd && !fd->errors)\n         {\n             //printf(\"Creating default this(){} for class %s\\n\", toChars());\n-            TypeFunction *btf = (TypeFunction *)fd->type;\n+            TypeFunction *btf = fd->type->toTypeFunction();\n             TypeFunction *tf = new TypeFunction(NULL, NULL, 0, LINKd, fd->storage_class);\n             tf->mod = btf->mod;\n             tf->purity = btf->purity;\n@@ -1152,7 +1152,7 @@ int isf(void *param, Dsymbol *s)\n \n bool ClassDeclaration::isFuncHidden(FuncDeclaration *fd)\n {\n-    //printf(\"ClassDeclaration::isFuncHidden(class = %s, fd = %s)\\n\", toChars(), fd->toChars());\n+    //printf(\"ClassDeclaration::isFuncHidden(class = %s, fd = %s)\\n\", toChars(), fd->toPrettyChars());\n     Dsymbol *s = search(Loc(), fd->ident, IgnoreAmbiguous | IgnoreErrors);\n     if (!s)\n     {\n@@ -1749,6 +1749,7 @@ bool InterfaceDeclaration::isBaseOf(ClassDeclaration *cd, int *poffset)\n         //printf(\"\\tX base %s\\n\", b->sym->toChars());\n         if (this == b->sym)\n         {\n+            //printf(\"\\tfound at offset %d\\n\", b->offset);\n             if (poffset)\n             {\n                 // don't return incorrect offsets https://issues.dlang.org/show_bug.cgi?id=16980\n@@ -1882,8 +1883,7 @@ bool BaseClass::fillVtbl(ClassDeclaration *cd, FuncDeclarations *vtbl, int newin\n \n         assert(ifd);\n         // Find corresponding function in this class\n-        tf = (ifd->type->ty == Tfunction) ? (TypeFunction *)(ifd->type) : NULL;\n-        assert(tf);  // should always be non-null\n+        tf = ifd->type->toTypeFunction();\n         fd = cd->findFunc(ifd->ident, tf);\n         if (fd && !fd->isAbstract())\n         {"}, {"sha": "77d6174241d50f193cae88a9d10abeb1f753fb20", "filename": "gcc/d/dmd/dstruct.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d814b69890171b7d742fabd966e5167b222cfd0/gcc%2Fd%2Fdmd%2Fdstruct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d814b69890171b7d742fabd966e5167b222cfd0/gcc%2Fd%2Fdmd%2Fdstruct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdstruct.c?ref=4d814b69890171b7d742fabd966e5167b222cfd0", "patch": "@@ -46,7 +46,7 @@ FuncDeclaration *search_toString(StructDeclaration *sd)\n         if (!tftostring)\n         {\n             tftostring = new TypeFunction(NULL, Type::tstring, 0, LINKd);\n-            tftostring = (TypeFunction *)tftostring->merge();\n+            tftostring = tftostring->merge()->toTypeFunction();\n         }\n \n         fd = fd->overloadExactMatch(tftostring);\n@@ -92,6 +92,7 @@ void semanticTypeInfo(Scope *sc, Type *t)\n         }\n         void visit(TypeStruct *t)\n         {\n+            //printf(\"semanticTypeInfo::visit(TypeStruct = %s)\\n\", t->toChars());\n             StructDeclaration *sd = t->sym;\n \n             /* Step 1: create TypeInfoDeclaration"}, {"sha": "4e1b3e2d2d3a0e67bac8e2ca37f29ea0d0c14b1d", "filename": "gcc/d/dmd/func.c", "status": "modified", "additions": 40, "deletions": 42, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d814b69890171b7d742fabd966e5167b222cfd0/gcc%2Fd%2Fdmd%2Ffunc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d814b69890171b7d742fabd966e5167b222cfd0/gcc%2Fd%2Fdmd%2Ffunc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.c?ref=4d814b69890171b7d742fabd966e5167b222cfd0", "patch": "@@ -411,8 +411,8 @@ static bool canInferAttributes(FuncDeclaration *fd, Scope *sc)\n  */\n static void initInferAttributes(FuncDeclaration *fd)\n {\n-    assert(fd->type->ty == Tfunction);\n-    TypeFunction *tf = (TypeFunction *)fd->type;\n+    //printf(\"initInferAttributes() for %s\\n\", toPrettyChars());\n+    TypeFunction *tf = fd->type->toTypeFunction();\n     if (tf->purity == PUREimpure) // purity not specified\n         fd->flags |= FUNCFLAGpurityInprocess;\n \n@@ -495,7 +495,7 @@ void FuncDeclaration::semantic(Scope *sc)\n             fld->tok = TOKfunction;\n         else\n             assert(0);\n-        linkage = ((TypeFunction *)treq->nextOf())->linkage;\n+        linkage = treq->nextOf()->toTypeFunction()->linkage;\n     }\n     else\n         linkage = sc->linkage;\n@@ -505,11 +505,21 @@ void FuncDeclaration::semantic(Scope *sc)\n \n     if (!originalType)\n         originalType = type->syntaxCopy();\n+    if (type->ty != Tfunction)\n+    {\n+        if (type->ty != Terror)\n+        {\n+            error(\"%s must be a function instead of %s\", toChars(), type->toChars());\n+            type = Type::terror;\n+        }\n+        errors = true;\n+        return;\n+    }\n     if (!type->deco)\n     {\n         sc = sc->push();\n         sc->stc |= storage_class & (STCdisable | STCdeprecated);  // forward to function type\n-        TypeFunction *tf = (TypeFunction *)type;\n+        TypeFunction *tf = type->toTypeFunction();\n \n         if (sc->func)\n         {\n@@ -678,8 +688,8 @@ void FuncDeclaration::semantic(Scope *sc)\n     {\n         // Merge back function attributes into 'originalType'.\n         // It's used for mangling, ddoc, and json output.\n-        TypeFunction *tfo = (TypeFunction *)originalType;\n-        TypeFunction *tfx = (TypeFunction *)type;\n+        TypeFunction *tfo = originalType->toTypeFunction();\n+        TypeFunction *tfx = type->toTypeFunction();\n         tfo->mod        = tfx->mod;\n         tfo->isscope    = tfx->isscope;\n         tfo->isscopeinferred = tfx->isscopeinferred;\n@@ -1132,8 +1142,7 @@ void FuncDeclaration::semantic(Scope *sc)\n         error(\"override only applies to class member functions\");\n \n     // Reflect this->type to f because it could be changed by findVtblIndex\n-    assert(type->ty == Tfunction);\n-    f = (TypeFunction *)type;\n+    f = type->toTypeFunction();\n \n     /* Do not allow template instances to add virtual functions\n      * to a class.\n@@ -2560,8 +2569,7 @@ void FuncDeclaration::buildResultVar(Scope *sc, Type *tret)\n \n     if (sc && vresult->semanticRun == PASSinit)\n     {\n-        assert(type->ty == Tfunction);\n-        TypeFunction *tf = (TypeFunction *)type;\n+        TypeFunction *tf = type->toTypeFunction();\n         if (tf->isref)\n             vresult->storage_class |= STCref;\n         vresult->type = tret;\n@@ -3135,7 +3143,7 @@ FuncDeclaration *FuncDeclaration::overloadModMatch(Loc loc, Type *tthis, bool &h\n             return 0;\n \n         m->anyf = f;\n-        TypeFunction *tf = (TypeFunction *)f->type;\n+        TypeFunction *tf = f->type->toTypeFunction();\n         //printf(\"tf = %s\\n\", tf->toChars());\n \n         MATCH match;\n@@ -3205,7 +3213,7 @@ FuncDeclaration *FuncDeclaration::overloadModMatch(Loc loc, Type *tthis, bool &h\n     else                    // no match\n     {\n         hasOverloads = true;\n-        TypeFunction *tf = (TypeFunction *)this->type;\n+        TypeFunction *tf = this->type->toTypeFunction();\n         assert(tthis);\n         assert(!MODimplicitConv(tthis->mod, tf->mod));  // modifier mismatch\n         {\n@@ -3270,8 +3278,8 @@ MATCH FuncDeclaration::leastAsSpecialized(FuncDeclaration *g)\n      * as g() is.\n      */\n \n-    TypeFunction *tf = (TypeFunction *)type;\n-    TypeFunction *tg = (TypeFunction *)g->type;\n+    TypeFunction *tf = type->toTypeFunction();\n+    TypeFunction *tg = g->type->toTypeFunction();\n     size_t nfparams = Parameter::dim(tf->parameters);\n \n     /* If both functions have a 'this' pointer, and the mods are not\n@@ -3524,7 +3532,7 @@ FuncDeclaration *resolveFuncCall(Loc loc, Scope *sc, Dsymbol *s,\n             assert(fd);\n \n             bool hasOverloads = fd->overnext != NULL;\n-            TypeFunction *tf = (TypeFunction *)fd->type;\n+            TypeFunction *tf = fd->type->toTypeFunction();\n             if (tthis && !MODimplicitConv(tthis->mod, tf->mod)) // modifier mismatch\n             {\n                 OutBuffer thisBuf, funcBuf;\n@@ -3562,8 +3570,8 @@ FuncDeclaration *resolveFuncCall(Loc loc, Scope *sc, Dsymbol *s,\n     }\n     else if (m.nextf)\n     {\n-        TypeFunction *tf1 = (TypeFunction *)m.lastf->type;\n-        TypeFunction *tf2 = (TypeFunction *)m.nextf->type;\n+        TypeFunction *tf1 = m.lastf->type->toTypeFunction();\n+        TypeFunction *tf2 = m.nextf->type->toTypeFunction();\n         const char *lastprms = parametersTypeToChars(tf1->parameters, tf1->varargs);\n         const char *nextprms = parametersTypeToChars(tf2->parameters, tf2->varargs);\n         ::error(loc, \"%s.%s called with argument types %s matches both:\\n\"\n@@ -3679,7 +3687,7 @@ const char *FuncDeclaration::toPrettyChars(bool QualifyTypes)\n const char *FuncDeclaration::toFullSignature()\n {\n     OutBuffer buf;\n-    functionToBufferWithIdent((TypeFunction *)type, &buf, toChars());\n+    functionToBufferWithIdent(type->toTypeFunction(), &buf, toChars());\n     return buf.extractString();\n }\n \n@@ -3776,8 +3784,7 @@ bool FuncDeclaration::isOverloadable()\n PURE FuncDeclaration::isPure()\n {\n     //printf(\"FuncDeclaration::isPure() '%s'\\n\", toChars());\n-    assert(type->ty == Tfunction);\n-    TypeFunction *tf = (TypeFunction *)type;\n+    TypeFunction *tf = type->toTypeFunction();\n     if (flags & FUNCFLAGpurityInprocess)\n         setImpure();\n     if (tf->purity == PUREfwdref)\n@@ -3829,10 +3836,9 @@ bool FuncDeclaration::setImpure()\n \n bool FuncDeclaration::isSafe()\n {\n-    assert(type->ty == Tfunction);\n     if (flags & FUNCFLAGsafetyInprocess)\n         setUnsafe();\n-    return ((TypeFunction *)type)->trust == TRUSTsafe;\n+    return type->toTypeFunction()->trust == TRUSTsafe;\n }\n \n bool FuncDeclaration::isSafeBypassingInference()\n@@ -3842,10 +3848,9 @@ bool FuncDeclaration::isSafeBypassingInference()\n \n bool FuncDeclaration::isTrusted()\n {\n-    assert(type->ty == Tfunction);\n     if (flags & FUNCFLAGsafetyInprocess)\n         setUnsafe();\n-    return ((TypeFunction *)type)->trust == TRUSTtrusted;\n+    return type->toTypeFunction()->trust == TRUSTtrusted;\n }\n \n /**************************************\n@@ -3858,7 +3863,7 @@ bool FuncDeclaration::setUnsafe()\n     if (flags & FUNCFLAGsafetyInprocess)\n     {\n         flags &= ~FUNCFLAGsafetyInprocess;\n-        ((TypeFunction *)type)->trust = TRUSTsystem;\n+        type->toTypeFunction()->trust = TRUSTsystem;\n         if (fes)\n             fes->func->setUnsafe();\n     }\n@@ -3869,10 +3874,9 @@ bool FuncDeclaration::setUnsafe()\n \n bool FuncDeclaration::isNogc()\n {\n-    assert(type->ty == Tfunction);\n     if (flags & FUNCFLAGnogcInprocess)\n         setGC();\n-    return ((TypeFunction *)type)->isnogc;\n+    return type->toTypeFunction()->isnogc;\n }\n \n bool FuncDeclaration::isNogcBypassingInference()\n@@ -3891,7 +3895,7 @@ bool FuncDeclaration::setGC()\n     if (flags & FUNCFLAGnogcInprocess)\n     {\n         flags &= ~FUNCFLAGnogcInprocess;\n-        ((TypeFunction *)type)->isnogc = false;\n+        type->toTypeFunction()->isnogc = false;\n         if (fes)\n             fes->func->setGC();\n     }\n@@ -4000,8 +4004,7 @@ bool traverseIndirections(Type *ta, Type *tb, void *p = NULL, bool reversePass =\n \n bool FuncDeclaration::isolateReturn()\n {\n-    assert(type->ty == Tfunction);\n-    TypeFunction *tf = (TypeFunction *)type;\n+    TypeFunction *tf = type->toTypeFunction();\n     assert(tf->next);\n \n     Type *treti = tf->next;\n@@ -4022,8 +4025,7 @@ bool FuncDeclaration::parametersIntersect(Type *t)\n     if (!isPureBypassingInference() || isNested())\n         return false;\n \n-    assert(type->ty == Tfunction);\n-    TypeFunction *tf = (TypeFunction *)type;\n+    TypeFunction *tf = type->toTypeFunction();\n \n     //printf(\"parametersIntersect(%s) t = %s\\n\", tf->toChars(), t->toChars());\n \n@@ -4229,7 +4231,7 @@ FuncDeclaration *FuncDeclaration::genCfunc(Parameters *fparams, Type *treturn, I\n  */\n void FuncDeclaration::checkDmain()\n {\n-    TypeFunction *tf = (TypeFunction *)type;\n+    TypeFunction *tf = type->toTypeFunction();\n     const size_t nparams = Parameter::dim(tf->parameters);\n     bool argerr = false;\n     if (nparams == 1)\n@@ -4608,8 +4610,7 @@ Parameters *FuncDeclaration::getParameters(int *pvarargs)\n \n     if (type)\n     {\n-        assert(type->ty == Tfunction);\n-        TypeFunction *fdtype = (TypeFunction *)type;\n+        TypeFunction *fdtype = type->toTypeFunction();\n         fparameters = fdtype->parameters;\n         fvarargs = fdtype->varargs;\n     }\n@@ -4752,7 +4753,7 @@ void FuncLiteralDeclaration::modifyReturns(Scope *sc, Type *tret)\n     // This is required so the code generator does not try to cast the\n     // modified returns back to the original type.\n     if (inferRetType && type->nextOf() != tret)\n-        ((TypeFunction *)type)->next = tret;\n+        type->toTypeFunction()->next = tret;\n }\n \n const char *FuncLiteralDeclaration::kind() const\n@@ -4820,8 +4821,7 @@ void CtorDeclaration::semantic(Scope *sc)\n     if (errors)\n         return;\n \n-    TypeFunction *tf = (TypeFunction *)type;\n-    assert(tf && tf->ty == Tfunction);\n+    TypeFunction *tf = type->toTypeFunction();\n \n     /* See if it's the default constructor\n      * But, template constructor should not become a default constructor.\n@@ -5502,10 +5502,9 @@ void NewDeclaration::semantic(Scope *sc)\n         type = new TypeFunction(parameters, tret, varargs, LINKd, storage_class);\n \n     type = type->semantic(loc, sc);\n-    assert(type->ty == Tfunction);\n \n     // Check that there is at least one argument of type size_t\n-    TypeFunction *tf = (TypeFunction *)type;\n+    TypeFunction *tf = type->toTypeFunction();\n     if (Parameter::dim(tf->parameters) < 1)\n     {\n         error(\"at least one argument of type size_t expected\");\n@@ -5581,10 +5580,9 @@ void DeleteDeclaration::semantic(Scope *sc)\n         type = new TypeFunction(parameters, Type::tvoid, 0, LINKd, storage_class);\n \n     type = type->semantic(loc, sc);\n-    assert(type->ty == Tfunction);\n \n     // Check that there is only one argument of type void*\n-    TypeFunction *tf = (TypeFunction *)type;\n+    TypeFunction *tf = type->toTypeFunction();\n     if (Parameter::dim(tf->parameters) != 1)\n     {\n         error(\"one argument of type void* expected\");"}, {"sha": "52598033832ea94f70476532163470927395d6ae", "filename": "gcc/d/dmd/mtype.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d814b69890171b7d742fabd966e5167b222cfd0/gcc%2Fd%2Fdmd%2Fmtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d814b69890171b7d742fabd966e5167b222cfd0/gcc%2Fd%2Fdmd%2Fmtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.c?ref=4d814b69890171b7d742fabd966e5167b222cfd0", "patch": "@@ -2345,6 +2345,12 @@ TypeBasic *Type::isTypeBasic()\n     return NULL;\n }\n \n+TypeFunction *Type::toTypeFunction()\n+{\n+    if (ty != Tfunction)\n+        assert(0);\n+    return (TypeFunction *)this;\n+}\n \n /***************************************\n  * Resolve 'this' type to either type, symbol, or expression.\n@@ -4808,14 +4814,14 @@ Expression *TypeAArray::dotExp(Scope *sc, Expression *e, Identifier *ident, int\n             Parameters *fparams = new Parameters();\n             fparams->push(new Parameter(STCin, this, NULL, NULL));\n             fd_aaLen = FuncDeclaration::genCfunc(fparams, Type::tsize_t, Id::aaLen);\n-            TypeFunction *tf = (TypeFunction *)fd_aaLen->type;\n+            TypeFunction *tf = fd_aaLen->type->toTypeFunction();\n             tf->purity = PUREconst;\n             tf->isnothrow = true;\n             tf->isnogc = false;\n         }\n         Expression *ev = new VarExp(e->loc, fd_aaLen, false);\n         e = new CallExp(e->loc, ev, e);\n-        e->type = ((TypeFunction *)fd_aaLen->type)->next;\n+        e->type = fd_aaLen->type->toTypeFunction()->next;\n     }\n     else\n         e = Type::dotExp(sc, e, ident, flag);\n@@ -5425,7 +5431,7 @@ Type *TypeFunction::semantic(Loc loc, Scope *sc)\n      * This can produce redundant copies if inferring return type,\n      * as semantic() will get called again on this.\n      */\n-    TypeFunction *tf = (TypeFunction *)copy();\n+    TypeFunction *tf = copy()->toTypeFunction();\n     if (parameters)\n     {\n         tf->parameters = parameters->copy();\n@@ -6283,7 +6289,7 @@ Expression *TypeFunction::defaultInit(Loc loc)\n Type *TypeFunction::addStorageClass(StorageClass stc)\n {\n     //printf(\"addStorageClass(%llx) %d\\n\", stc, (stc & STCscope) != 0);\n-    TypeFunction *t = (TypeFunction *)Type::addStorageClass(stc);\n+    TypeFunction *t = Type::addStorageClass(stc)->toTypeFunction();\n     if ((stc & STCpure && !t->purity) ||\n         (stc & STCnothrow && !t->isnothrow) ||\n         (stc & STCnogc && !t->isnogc) ||\n@@ -9181,7 +9187,7 @@ Type *Parameter::isLazyArray()\n         if (tel->ty == Tdelegate)\n         {\n             TypeDelegate *td = (TypeDelegate *)tel;\n-            TypeFunction *tf = (TypeFunction *)td->next;\n+            TypeFunction *tf = td->next->toTypeFunction();\n \n             if (!tf->varargs && Parameter::dim(tf->parameters) == 0)\n             {"}, {"sha": "b459fdf869faa3349e0c8fdb6ea31235d11fee72", "filename": "gcc/d/dmd/mtype.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d814b69890171b7d742fabd966e5167b222cfd0/gcc%2Fd%2Fdmd%2Fmtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d814b69890171b7d742fabd966e5167b222cfd0/gcc%2Fd%2Fdmd%2Fmtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.h?ref=4d814b69890171b7d742fabd966e5167b222cfd0", "patch": "@@ -335,6 +335,7 @@ class Type : public RootObject\n     virtual bool needsDestruction();\n     virtual bool needsNested();\n     void checkComplexTransition(Loc loc);\n+    TypeFunction *toTypeFunction();\n \n     static void error(Loc loc, const char *format, ...);\n     static void warning(Loc loc, const char *format, ...);"}]}