{"sha": "61b5f21009e170106b4d44501b3e551c399c1fec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFiNWYyMTAwOWUxNzAxMDZiNGQ0NDUwMWIzZTU1MWMzOTljMWZlYw==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2004-09-05T10:54:26Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2004-09-05T10:54:26Z"}, "message": "* tree-if-conv.c: Spell check comments and clean up whitespace.\n\nFrom-SVN: r87101", "tree": {"sha": "e0ef4e2fadeca756d91e40c0f6796e4f121ca8c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0ef4e2fadeca756d91e40c0f6796e4f121ca8c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61b5f21009e170106b4d44501b3e551c399c1fec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61b5f21009e170106b4d44501b3e551c399c1fec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61b5f21009e170106b4d44501b3e551c399c1fec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61b5f21009e170106b4d44501b3e551c399c1fec/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8b11a64cd99d948ac278cc508d1866c6d28df85e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b11a64cd99d948ac278cc508d1866c6d28df85e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b11a64cd99d948ac278cc508d1866c6d28df85e"}], "stats": {"total": 171, "additions": 87, "deletions": 84}, "files": [{"sha": "224c55d014b1bb4dd70c7a8236528aa43ceec691", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b5f21009e170106b4d44501b3e551c399c1fec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b5f21009e170106b4d44501b3e551c399c1fec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61b5f21009e170106b4d44501b3e551c399c1fec", "patch": "@@ -1,3 +1,7 @@\n+2004-09-05  Andreas Jaeger  <aj@suse.de>\n+\n+\t* tree-if-conv.c: Spell check comments and clean up whitespace.\n+\n 2004-09-05  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* tree-ssa-loop-ivopts.c: New file."}, {"sha": "3b9151acb8ed0eda0eb7d55737a51f68427decfa", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 83, "deletions": 84, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b5f21009e170106b4d44501b3e551c399c1fec/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b5f21009e170106b4d44501b3e551c399c1fec/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=61b5f21009e170106b4d44501b3e551c399c1fec", "patch": "@@ -19,15 +19,15 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n-/* This pass implements tree level if-conversion transformation of loops. \n+/* This pass implements tree level if-conversion transformation of loops.\n    Initial goal is to help vectorizer vectorize loops with conditions.\n \n    A short description of if-conversion:\n \n      o Decide if a loop is if-convertable or not.\n      o Walk all loop basic blocks in breadth first order (BFS order).\n        o Remove conditional statements (at the end of basic block)\n-         and propogate condition into destination basic blcoks'\n+         and propagate condition into destination basic blocks'\n \t predicate list.\n        o Replace modify expression with conditional modify expression\n          using current basic block's condition.\n@@ -67,13 +67,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n      # i_23 = PHI <0(0), i_18(10)>;\n      <L0>:;\n      j_15 = A[i_23];\n-     \n+\n      <L3>:;\n      iftmp.2_4 = j_15 > 41 ? 42 : 0;\n      A[i_23] = iftmp.2_4;\n      i_18 = i_23 + 1;\n      if (i_18 <= 15) goto <L19>; else goto <L18>;\n-     \n+\n      <L19>:;\n      goto <bb 1> (<L0>);\n \n@@ -104,9 +104,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* local function prototypes */\n static void main_tree_if_conversion (void);\n-static tree tree_if_convert_stmt (struct loop *loop, tree, tree, \n+static tree tree_if_convert_stmt (struct loop *loop, tree, tree,\n \t\t\t\t  block_stmt_iterator *);\n-static void tree_if_convert_cond_expr (struct loop *, tree, tree, \n+static void tree_if_convert_cond_expr (struct loop *, tree, tree,\n \t\t\t\t       block_stmt_iterator *);\n static bool if_convertable_phi_p (struct loop *, basic_block, tree);\n static bool if_convertable_modify_expr_p (struct loop *, basic_block, tree);\n@@ -133,10 +133,10 @@ static basic_block *ifc_bbs;\n \n /* Main entry point.\n    Apply if-conversion to the LOOP. Return true if successful otherwise return\n-   false. If false is returned then loop remains unchanged.  \n+   false. If false is returned then loop remains unchanged.\n    FOR_VECTORIZER is a boolean flag. It indicates whether if-conversion is used\n    for vectorizer or not. If it is used for vectorizer, additional checks are\n-   used. (Vectorization checks are not yet imlemented).  */\n+   used. (Vectorization checks are not yet implemented).  */\n \n bool\n tree_if_conversion (struct loop *loop, bool for_vectorizer)\n@@ -165,17 +165,17 @@ tree_if_conversion (struct loop *loop, bool for_vectorizer)\n     }\n \n   cond = NULL_TREE;\n-  \n+\n   /* Do actual work now.  */\n-  for (i = 0; i < loop->num_nodes; i++)  \n+  for (i = 0; i < loop->num_nodes; i++)\n     {\n       bb = ifc_bbs [i];\n \n       /* Update condition using predicate list.  */\n       cond = bb->aux;\n \n       /* Process all statements in this basic block.\n-\t Remove conditional expresion, if any, and annotate\n+\t Remove conditional expression, if any, and annotate\n \t destination basic block(s) appropriately.  */\n       for (itr = bsi_start (bb); !bsi_end_p (itr); /* empty */)\n \t{\n@@ -185,7 +185,7 @@ tree_if_conversion (struct loop *loop, bool for_vectorizer)\n \t    bsi_next (&itr);\n \t}\n \n-      /* If current bb has only one successor, then consider it as an \n+      /* If current bb has only one successor, then consider it as an\n \t unconditional goto.  */\n       if (bb->succ && !bb->succ->succ_next)\n \t{\n@@ -210,15 +210,15 @@ tree_if_conversion (struct loop *loop, bool for_vectorizer)\n   return true;\n }\n \n-/* if-convert stmt T which is part of LOOP. \n-   If T is a MODIFY_EXPR than it is converted into conditional modify \n-   expression using COND.  For conditional expressions, add condition in the \n-   destination basic block's predicate list and remove conditional \n-   expression itself. BSI is the iterator used to traverse statements of \n+/* if-convert stmt T which is part of LOOP.\n+   If T is a MODIFY_EXPR than it is converted into conditional modify\n+   expression using COND.  For conditional expressions, add condition in the\n+   destination basic block's predicate list and remove conditional\n+   expression itself. BSI is the iterator used to traverse statements of\n    loop. It is used here when it is required to delete current statement.  */\n \n static tree\n-tree_if_convert_stmt (struct loop *  loop, tree t, tree cond, \n+tree_if_convert_stmt (struct loop *  loop, tree t, tree cond,\n \t\t      block_stmt_iterator *bsi)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -238,7 +238,7 @@ tree_if_convert_stmt (struct loop *  loop, tree t, tree cond,\n       /* This modify_expr is killing previous value of LHS. Appropriate value will\n \t be selected by PHI node based on condition. It is possible that before\n \t this transformation, PHI nodes was selecting default value and now it will\n-\t use this new value. This is OK because it does not change validity the \n+\t use this new value. This is OK because it does not change validity the\n \t program.  */\n       break;\n \n@@ -253,10 +253,10 @@ tree_if_convert_stmt (struct loop *  loop, tree t, tree cond,\n       /* Update destination blocks' predicate list and remove this\n \t condition expression.  */\n       tree_if_convert_cond_expr (loop, t, cond, bsi);\n-      cond = NULL_TREE; \n+      cond = NULL_TREE;\n       break;\n-\t\n-    default:    \n+\n+    default:\n       abort ();\n       break;\n     }\n@@ -265,11 +265,11 @@ tree_if_convert_stmt (struct loop *  loop, tree t, tree cond,\n \n /* STMT is COND_EXPR. Update two destination's predicate list.\n    Remove COND_EXPR, if it is not the loop exit condition. Otherwise\n-   update loop exit condition appropriatly.  BSI is the iterator\n+   update loop exit condition appropriately.  BSI is the iterator\n    used to traverse statement list. STMT is part of loop LOOP.  */\n \n static void\n-tree_if_convert_cond_expr (struct loop *loop, tree stmt, tree cond, \n+tree_if_convert_cond_expr (struct loop *loop, tree stmt, tree cond,\n \t\t\t   block_stmt_iterator *bsi)\n {\n   tree then_clause, else_clause, c, new_cond;\n@@ -283,7 +283,7 @@ tree_if_convert_cond_expr (struct loop *loop, tree stmt, tree cond,\n   c = TREE_OPERAND (stmt, 0);\n   then_clause = TREE_OPERAND (stmt, 1);\n   else_clause = TREE_OPERAND (stmt, 2);\n-  \n+\n   /* Create temp. for condition.  */\n   if (!is_gimple_reg (c))\n     {\n@@ -292,22 +292,22 @@ tree_if_convert_cond_expr (struct loop *loop, tree stmt, tree cond,\n       bsi_insert_before (bsi, new_stmt, BSI_SAME_STMT);\n       c = TREE_OPERAND (new_stmt, 0);\n     }\n-\t\n+\n   /* Add new condition into destination's predicate list.  */\n   if (then_clause)\n     /* if 'c' is true then then_clause is reached.  */\n     new_cond = add_to_dst_predicate_list (loop, then_clause, cond, c, bsi);\n-  \n+\n   if (else_clause)\n     {\n       /* if 'c' is false then else_clause is reached.  */\n-      tree c2 = build1 (TRUTH_NOT_EXPR, \n-\t\t\tboolean_type_node, \n+      tree c2 = build1 (TRUTH_NOT_EXPR,\n+\t\t\tboolean_type_node,\n \t\t\tunshare_expr (c));\n       add_to_dst_predicate_list (loop, else_clause, cond, c2, bsi);\n     }\n \n-  /* Now this conditional statement is redundent. Remove it.\n+  /* Now this conditional statement is redundant. Remove it.\n      But, do not remove exit condition! Update exit condition\n      using new condition.  */\n   if (!bb_with_exit_edge_p (bb_for_stmt (stmt)))\n@@ -325,7 +325,7 @@ tree_if_convert_cond_expr (struct loop *loop, tree stmt, tree cond,\n \n /* Return true, iff PHI is if-convertable. PHI is part of loop LOOP\n    and it belongs to basic block BB.\n-   PHI is not if-convertable \n+   PHI is not if-convertable\n    - if it has more than 2 arguments.\n    - Virtual PHI is immediately used in another PHI node.  */\n \n@@ -337,14 +337,14 @@ if_convertable_phi_p (struct loop *loop, basic_block bb, tree phi)\n       fprintf (dump_file, \"-------------------------\\n\");\n       print_generic_stmt (dump_file, phi, TDF_SLIM);\n     }\n-  \n+\n   if (bb != loop->header && PHI_NUM_ARGS (phi) != 2)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"More than two phi node args.\\n\");\n       return false;\n     }\n-  \n+\n   if (!is_gimple_reg (SSA_NAME_VAR (PHI_RESULT (phi))))\n     {\n       int j;\n@@ -365,7 +365,7 @@ if_convertable_phi_p (struct loop *loop, basic_block bb, tree phi)\n   return true;\n }\n \n-/* Return true, if M_EXPR is if-convertable.  \n+/* Return true, if M_EXPR is if-convertable.\n    MODIFY_EXPR is not if-convertable if,\n    - It is not movable.\n    - It could trap.\n@@ -381,7 +381,7 @@ if_convertable_modify_expr_p (struct loop *loop, basic_block bb, tree m_expr)\n       fprintf (dump_file, \"-------------------------\\n\");\n       print_generic_stmt (dump_file, m_expr, TDF_SLIM);\n     }\n-  \n+\n   /* Be conservative and do not handle immovable expressions.  */\n   if (movement_possibility (m_expr) == MOVE_IMPOSSIBLE)\n     {\n@@ -391,7 +391,7 @@ if_convertable_modify_expr_p (struct loop *loop, basic_block bb, tree m_expr)\n     }\n \n   /* See if it needs speculative loading or not.  */\n-  if (bb != loop->header \n+  if (bb != loop->header\n       && tree_could_trap_p (TREE_OPERAND (m_expr, 1)))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -422,10 +422,10 @@ if_convertable_modify_expr_p (struct loop *loop, basic_block bb, tree m_expr)\n   return true;\n }\n \n-/* Return true, iff STMT is if-convertable.  \n+/* Return true, iff STMT is if-convertable.\n    Statement is if-convertable if,\n-   - It is if-converatable MODIFY_EXPR\n-   - IT is LABEL_EXPR, GOTO_EXPR or COND_EXPR.  \n+   - It is if-convertable MODIFY_EXPR\n+   - IT is LABEL_EXPR, GOTO_EXPR or COND_EXPR.\n    STMT is inside block BB, which is inside loop LOOP.  */\n \n static bool\n@@ -435,17 +435,17 @@ if_convertable_stmt_p (struct loop *loop, basic_block bb, tree stmt)\n     {\n     case LABEL_EXPR:\n       break;\n-      \n+\n     case MODIFY_EXPR:\n-      \n+\n       if (!if_convertable_modify_expr_p (loop, bb, stmt))\n \treturn false;\n       break;\n-      \n+\n     case GOTO_EXPR:\n     case COND_EXPR:\n       break;\n-      \n+\n     default:\n       /* Don't know what to do with 'em so don't do anything.  */\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -460,23 +460,23 @@ if_convertable_stmt_p (struct loop *loop, basic_block bb, tree stmt)\n   return true;\n }\n \n-/* Return true, iff BB is if-convertable. \n+/* Return true, iff BB is if-convertable.\n    Note: This routine does _not_ check basic block statements and phis.\n-   Basic block is not if-converatable if,\n-   - Basic block is non-empty and it is after exit block (in BFS order).  \n+   Basic block is not if-convertable if,\n+   - Basic block is non-empty and it is after exit block (in BFS order).\n    - Basic block is after exit block but before latch.\n-   - Basic block edge(s) is not normal.  \n+   - Basic block edge(s) is not normal.\n    EXIT_BB_SEEN is true if basic block with exit edge is already seen.\n    BB is inside loop LOOP. */\n \n-static bool \n+static bool\n if_convertable_bb_p (struct loop *loop, basic_block bb, bool exit_bb_seen)\n {\n   edge e;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"----------[%d]-------------\\n\", bb->index);\n-  \n+\n   if (exit_bb_seen)\n     {\n       if (bb != loop->latch)\n@@ -492,10 +492,10 @@ if_convertable_bb_p (struct loop *loop, basic_block bb, bool exit_bb_seen)\n \t  return false;\n \t}\n     }\n-  \n-  /* Be less adveturous and handle only normal edges.  */\n+\n+  /* Be less adventurous and handle only normal edges.  */\n   for (e = bb->succ; e; e = e->succ_next)\n-    if (e->flags & \n+    if (e->flags &\n \t(EDGE_ABNORMAL_CALL | EDGE_EH | EDGE_ABNORMAL | EDGE_IRREDUCIBLE_LOOP))\n       {\n \tif (dump_file && (dump_flags & TDF_DETAILS))\n@@ -506,14 +506,14 @@ if_convertable_bb_p (struct loop *loop, basic_block bb, bool exit_bb_seen)\n   return true;\n }\n \n-/* Return true, iff LOOP is if-convertable. \n+/* Return true, iff LOOP is if-convertable.\n    LOOP is if-convertable if,\n    - It is innermost.\n    - It has two or more basic blocks.\n    - It has only one exit.\n-   - Loop header is not the exit edge. \n-   - If its basic blocks and phi nodes are if convertable. See above for \n-     more info.   \n+   - Loop header is not the exit edge.\n+   - If its basic blocks and phi nodes are if convertable. See above for\n+     more info.\n    FOR_VECTORIZER enables vectorizer specific checks. For example, support\n    for vector conditions, data dependency checks etc.. (Not implemented yet).  */\n \n@@ -534,17 +534,17 @@ if_convertable_loop_p (struct loop *loop, bool for_vectorizer ATTRIBUTE_UNUSED)\n \tfprintf (dump_file, \"not inner most loop\\n\");\n       return false;\n     }\n-  \n+\n   flow_loop_scan (loop, LOOP_ALL);\n \n   /* If only one block, no need for if-conversion.  */\n   if (loop->num_nodes <= 2)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"less thant 2 basic blocks\\n\");\n+\tfprintf (dump_file, \"less than 2 basic blocks\\n\");\n       return false;\n     }\n-  \n+\n   /* More than one loop exit is too much to handle.  */\n   if (loop->num_exits > 1)\n     {\n@@ -575,7 +575,7 @@ if_convertable_loop_p (struct loop *loop, bool for_vectorizer ATTRIBUTE_UNUSED)\n       free_dominance_info (CDI_POST_DOMINATORS);\n       return false;\n     }\n-    \n+\n   for (i = 0; i < loop->num_nodes; i++)\n     {\n       bb = ifc_bbs[i];\n@@ -613,7 +613,7 @@ static void\n add_to_predicate_list (basic_block bb, tree new_cond)\n {\n   tree cond = bb->aux;\n-  \n+\n   if (cond)\n     cond = fold (build (TRUTH_OR_EXPR, boolean_type_node,\n \t\t\tunshare_expr (cond), new_cond));\n@@ -627,7 +627,7 @@ add_to_predicate_list (basic_block bb, tree new_cond)\n    existing condition.  */\n \n static tree\n-add_to_dst_predicate_list (struct loop * loop, tree dst, \n+add_to_dst_predicate_list (struct loop * loop, tree dst,\n \t\t\t   tree prev_cond, tree cond,\n \t\t\t   block_stmt_iterator *bsi)\n {\n@@ -707,10 +707,10 @@ find_phi_replacement_condition (basic_block bb, tree *cond,\n       *cond  = p1->aux;\n       switch_args = false;\n     }\n-    \n-  /* Create temp. for the condition. Vectorizier prefers to have gimple \n-     value as condition. Various targets use different means to communicate \n-     condition in vector compare operation. Using gimple value allows compiler \n+\n+  /* Create temp. for the condition. Vectorizer prefers to have gimple\n+     value as condition. Various targets use different means to communicate\n+     condition in vector compare operation. Using gimple value allows compiler\n      to emit vector compare and select RTL without exposing compare's result.  */\n   if (!is_gimple_reg (*cond) && !is_gimple_condexpr (*cond))\n     {\n@@ -731,8 +731,8 @@ find_phi_replacement_condition (basic_block bb, tree *cond,\n }\n \n \n-/* Replace PHI node with conditional modify expr using COND.  \n-   This routine does not handle PHI nodes with more than two arguments. \n+/* Replace PHI node with conditional modify expr using COND.\n+   This routine does not handle PHI nodes with more than two arguments.\n    For example,\n      S1: A = PHI <x1(1), x2(5)\n    is converted into,\n@@ -765,7 +765,7 @@ replace_phi_with_cond_modify_expr (tree phi, tree cond, bool switch_args,\n   new_stmt = NULL_TREE;\n   arg_0 = NULL_TREE;\n   arg_1 = NULL_TREE;\n-  \n+\n   /* Use condition that is not TRUTH_NOT_EXPR in conditional modify expr.  */\n   if (switch_args)\n     {\n@@ -778,12 +778,12 @@ replace_phi_with_cond_modify_expr (tree phi, tree cond, bool switch_args,\n       arg_1 = PHI_ARG_DEF (phi, 1);\n     }\n \n-  /* Build new RHS using selected condtion and arguments.  */\n+  /* Build new RHS using selected condition and arguments.  */\n   rhs = build (COND_EXPR, TREE_TYPE (PHI_RESULT (phi)),\n \t       unshare_expr (cond), unshare_expr (arg_0),\n \t       unshare_expr (arg_1));\n \n-  /* Create new MODIFY expresstion using RHS.  */\n+  /* Create new MODIFY expression using RHS.  */\n   new_stmt = build (MODIFY_EXPR, TREE_TYPE (PHI_RESULT (phi)),\n \t\t    unshare_expr (PHI_RESULT (phi)), rhs);\n \n@@ -805,7 +805,7 @@ replace_phi_with_cond_modify_expr (tree phi, tree cond, bool switch_args,\n     }\n }\n \n-/* Process phi nodes for the given  LOOP.  Replace phi nodes with cond \n+/* Process phi nodes for the given  LOOP.  Replace phi nodes with cond\n    modify expr.  */\n \n static void\n@@ -822,7 +822,7 @@ process_phi_nodes (struct loop *loop)\n       block_stmt_iterator bsi;\n       bool switch_args = false;\n       bb = ifc_bbs[i];\n-      \n+\n       if (bb == loop->header || bb == loop->latch)\n \tcontinue;\n \n@@ -846,7 +846,7 @@ process_phi_nodes (struct loop *loop)\n   return;\n }\n \n-/* Combine all basic block from the given LOOP into one or two super \n+/* Combine all basic block from the given LOOP into one or two super\n    basic block.  Replace PHI nodes with conditional modify expression. */\n \n static void\n@@ -926,14 +926,14 @@ combine_blocks (struct loop *loop)\n \tdelete_from_dominance_info (CDI_DOMINATORS, bb);\n       if (dom_computed[CDI_POST_DOMINATORS])\n \tdelete_from_dominance_info (CDI_POST_DOMINATORS, bb);\n-      \n+\n       /* Remove basic block.  */\n       remove_bb_from_loops (bb);\n       expunge_block (bb);\n     }\n }\n \n-/* Make new  temp variable of type TYPE. Add MODIFY_EXPR to assign EXP \n+/* Make new  temp variable of type TYPE. Add MODIFY_EXPR to assign EXP\n    to the new variable.  */\n \n static tree\n@@ -951,7 +951,7 @@ ifc_temp_var (tree type, tree exp)\n \n   /* Build new statement to assigne EXP to new variable.  */\n   stmt = build (MODIFY_EXPR, type, var, exp);\n-  \n+\n   /* Get SSA name for the new variable and set make new statement\n      its definition statment.  */\n   new_name = make_ssa_name (var, stmt);\n@@ -972,7 +972,7 @@ pred_blocks_visited_p (basic_block bb, bitmap *visited)\n   for (e = bb->pred; e; e = e->pred_next)\n     if (!bitmap_bit_p (*visited, e->src->index))\n       return false;\n-  \n+\n   return true;\n }\n \n@@ -982,7 +982,7 @@ pred_blocks_visited_p (basic_block bb, bitmap *visited)\n    additional constraint. Select block in BFS block, if all\n    pred are already selected.  */\n \n-static basic_block * \n+static basic_block *\n get_loop_body_in_if_conv_order (const struct loop *loop)\n {\n   basic_block *blocks, *blocks_in_bfs_order;\n@@ -993,7 +993,7 @@ get_loop_body_in_if_conv_order (const struct loop *loop)\n \n   if (!loop->num_nodes)\n     abort ();\n-  \n+\n   if (loop->latch == EXIT_BLOCK_PTR)\n     abort ();\n \n@@ -1006,7 +1006,7 @@ get_loop_body_in_if_conv_order (const struct loop *loop)\n   while (index < loop->num_nodes)\n     {\n       bb = blocks_in_bfs_order [index];\n-      \n+\n       if (bb->flags & BB_IRREDUCIBLE_LOOP)\n \t{\n \t  free (blocks_in_bfs_order);\n@@ -1094,9 +1094,8 @@ struct tree_opt_pass pass_if_conversion =\n   0,                                 /* properties_provided */\n   0,                                 /* properties_destroyed */\n   TODO_dump_func,                    /* todo_flags_start */\n-  TODO_dump_func \n+  TODO_dump_func\n     | TODO_verify_ssa\n-    | TODO_verify_stmts \n+    | TODO_verify_stmts\n     | TODO_verify_flow               /* todo_flags_finish */\n };\n-"}]}