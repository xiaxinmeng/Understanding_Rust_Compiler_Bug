{"sha": "4d99a8487287e94b9bd42807cbe864991a0d1d3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ5OWE4NDg3Mjg3ZTk0YjliZDQyODA3Y2JlODY0OTkxYTBkMWQzYg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2017-11-09T15:31:06Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2017-11-09T15:31:06Z"}, "message": "Moving parameter manipulation into its own file\n\n2017-11-09  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-param-manipulation.c: New file.\n\t* ipa-param-manipulation.h: Likewise.\n\t* Makefile.in (OBJS): Add ipa-param-manipulation.o.\n\t(PLUGIN_HEADERS): Addded ipa-param-manipulation.h\n\t* ipa-param.h (ipa_parm_op): Moved to ipa-param-manipulation.h.\n\t(ipa_parm_adjustment): Likewise.\n\t(ipa_parm_adjustment_vec): Likewise.\n\t(ipa_get_vector_of_formal_parms): Moved declaration to\n\tipa-param-manipulation.h.\n\t(ipa_get_vector_of_formal_parm_types): Likewise.\n\t(ipa_modify_formal_parameters): Likewise.\n\t(ipa_modify_call_arguments): Likewise.\n\t(ipa_combine_adjustments): Likewise.\n\t(ipa_dump_param_adjustments): Likewise.\n\t(ipa_modify_expr): Likewise.\n\t(ipa_get_adjustment_candidate): Likewise.\n\t* ipa-prop.c (ipa_get_vector_of_formal_parms): Moved to\n\tipa-param-manipulation.c.\n\t(ipa_get_vector_of_formal_parm_types): Likewise.\n\t(ipa_modify_formal_parameters): Likewise.\n\t(ipa_modify_call_arguments): Likewise.\n\t(ipa_modify_expr): Likewise.\n\t(get_ssa_base_param): Likewise.\n\t(ipa_get_adjustment_candidate): Likewise.\n\t(index_in_adjustments_multiple_times_p): Likewise.\n\t(ipa_combine_adjustments): Likewise.\n\t(ipa_dump_param_adjustments): Likewise.\n\t* tree-sra.c: Also include ipa-param-manipulation.h\n\t* omp-simd-clone.c: Include ipa-param-manipulation.h instead of\n\tipa-param.h.\n\nFrom-SVN: r254598", "tree": {"sha": "4072ebdd65fa27492661090e3905d06c6fbb3a79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4072ebdd65fa27492661090e3905d06c6fbb3a79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d99a8487287e94b9bd42807cbe864991a0d1d3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d99a8487287e94b9bd42807cbe864991a0d1d3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d99a8487287e94b9bd42807cbe864991a0d1d3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d99a8487287e94b9bd42807cbe864991a0d1d3b/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c48a8e71c8b5d3e6bdffaec85b1e3b111814cee0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c48a8e71c8b5d3e6bdffaec85b1e3b111814cee0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c48a8e71c8b5d3e6bdffaec85b1e3b111814cee0"}], "stats": {"total": 1745, "additions": 924, "deletions": 821}, "files": [{"sha": "2dd56ddc88cc183c6763c2970baf1d1ef28b32e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d99a8487287e94b9bd42807cbe864991a0d1d3b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d99a8487287e94b9bd42807cbe864991a0d1d3b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d99a8487287e94b9bd42807cbe864991a0d1d3b", "patch": "@@ -1,3 +1,36 @@\n+2017-11-09  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-param-manipulation.c: New file.\n+\t* ipa-param-manipulation.h: Likewise.\n+\t* Makefile.in (OBJS): Add ipa-param-manipulation.o.\n+\t(PLUGIN_HEADERS): Addded ipa-param-manipulation.h\n+\t* ipa-param.h (ipa_parm_op): Moved to ipa-param-manipulation.h.\n+\t(ipa_parm_adjustment): Likewise.\n+\t(ipa_parm_adjustment_vec): Likewise.\n+\t(ipa_get_vector_of_formal_parms): Moved declaration to\n+\tipa-param-manipulation.h.\n+\t(ipa_get_vector_of_formal_parm_types): Likewise.\n+\t(ipa_modify_formal_parameters): Likewise.\n+\t(ipa_modify_call_arguments): Likewise.\n+\t(ipa_combine_adjustments): Likewise.\n+\t(ipa_dump_param_adjustments): Likewise.\n+\t(ipa_modify_expr): Likewise.\n+\t(ipa_get_adjustment_candidate): Likewise.\n+\t* ipa-prop.c (ipa_get_vector_of_formal_parms): Moved to\n+\tipa-param-manipulation.c.\n+\t(ipa_get_vector_of_formal_parm_types): Likewise.\n+\t(ipa_modify_formal_parameters): Likewise.\n+\t(ipa_modify_call_arguments): Likewise.\n+\t(ipa_modify_expr): Likewise.\n+\t(get_ssa_base_param): Likewise.\n+\t(ipa_get_adjustment_candidate): Likewise.\n+\t(index_in_adjustments_multiple_times_p): Likewise.\n+\t(ipa_combine_adjustments): Likewise.\n+\t(ipa_dump_param_adjustments): Likewise.\n+\t* tree-sra.c: Also include ipa-param-manipulation.h\n+\t* omp-simd-clone.c: Include ipa-param-manipulation.h instead of\n+\tipa-param.h.\n+\n 2017-11-09  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "1bb1d6ec0ff8051a4c3e77c18bde38accb91e06b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d99a8487287e94b9bd42807cbe864991a0d1d3b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d99a8487287e94b9bd42807cbe864991a0d1d3b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4d99a8487287e94b9bd42807cbe864991a0d1d3b", "patch": "@@ -1354,6 +1354,7 @@ OBJS = \\\n \tipa-predicate.o \\\n \tipa-profile.o \\\n \tipa-prop.o \\\n+\tipa-param-manipulation.o \\\n \tipa-pure-const.o \\\n \tipa-icf.o \\\n \tipa-icf-gimple.o \\\n@@ -3467,7 +3468,7 @@ PLUGIN_HEADERS = $(TREE_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   $(C_COMMON_H) c-family/c-objc.h $(C_PRETTY_PRINT_H) \\\n   tree-iterator.h $(PLUGIN_H) $(TREE_SSA_H) langhooks.h incpath.h debug.h \\\n   $(EXCEPT_H) tree-ssa-sccvn.h real.h output.h $(IPA_UTILS_H) \\\n-  $(C_PRAGMA_H)  $(CPPLIB_H)  $(FUNCTION_H) \\\n+  ipa-param-manipulation.h $(C_PRAGMA_H)  $(CPPLIB_H)  $(FUNCTION_H) \\\n   cppdefault.h flags.h $(MD5_H) params.def params.h params-enum.h \\\n   prefix.h tree-inline.h $(GIMPLE_PRETTY_PRINT_H) realmpfr.h \\\n   $(IPA_PROP_H) $(TARGET_H) $(RTL_H) $(TM_P_H) $(CFGLOOP_H) $(EMIT_RTL_H) \\"}, {"sha": "bedd201f6dd1e9f1a9d7be4680847a76cf5b6420", "filename": "gcc/ipa-param-manipulation.c", "status": "added", "additions": 767, "deletions": 0, "changes": 767, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d99a8487287e94b9bd42807cbe864991a0d1d3b/gcc%2Fipa-param-manipulation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d99a8487287e94b9bd42807cbe864991a0d1d3b/gcc%2Fipa-param-manipulation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.c?ref=4d99a8487287e94b9bd42807cbe864991a0d1d3b", "patch": "@@ -0,0 +1,767 @@\n+/* Manipulation of formal and actual parameters of functions and function\n+   calls.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"ssa.h\"\n+#include \"cgraph.h\"\n+#include \"fold-const.h\"\n+#include \"stor-layout.h\"\n+#include \"gimplify.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimplify-me.h\"\n+#include \"tree-dfa.h\"\n+#include \"ipa-param-manipulation.h\"\n+#include \"print-tree.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"builtins.h\"\n+\n+/* Return a heap allocated vector containing formal parameters of FNDECL.  */\n+\n+vec<tree>\n+ipa_get_vector_of_formal_parms (tree fndecl)\n+{\n+  vec<tree> args;\n+  int count;\n+  tree parm;\n+\n+  gcc_assert (!flag_wpa);\n+  count = 0;\n+  for (parm = DECL_ARGUMENTS (fndecl); parm; parm = DECL_CHAIN (parm))\n+    count++;\n+\n+  args.create (count);\n+  for (parm = DECL_ARGUMENTS (fndecl); parm; parm = DECL_CHAIN (parm))\n+    args.quick_push (parm);\n+\n+  return args;\n+}\n+\n+/* Return a heap allocated vector containing types of formal parameters of\n+   function type FNTYPE.  */\n+\n+vec<tree>\n+ipa_get_vector_of_formal_parm_types (tree fntype)\n+{\n+  vec<tree> types;\n+  int count = 0;\n+  tree t;\n+\n+  for (t = TYPE_ARG_TYPES (fntype); t; t = TREE_CHAIN (t))\n+    count++;\n+\n+  types.create (count);\n+  for (t = TYPE_ARG_TYPES (fntype); t; t = TREE_CHAIN (t))\n+    types.quick_push (TREE_VALUE (t));\n+\n+  return types;\n+}\n+\n+/* Modify the function declaration FNDECL and its type according to the plan in\n+   ADJUSTMENTS.  It also sets base fields of individual adjustments structures\n+   to reflect the actual parameters being modified which are determined by the\n+   base_index field.  */\n+\n+void\n+ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec adjustments)\n+{\n+  vec<tree> oparms = ipa_get_vector_of_formal_parms (fndecl);\n+  tree orig_type = TREE_TYPE (fndecl);\n+  tree old_arg_types = TYPE_ARG_TYPES (orig_type);\n+\n+  /* The following test is an ugly hack, some functions simply don't have any\n+     arguments in their type.  This is probably a bug but well... */\n+  bool care_for_types = (old_arg_types != NULL_TREE);\n+  bool last_parm_void;\n+  vec<tree> otypes;\n+  if (care_for_types)\n+    {\n+      last_parm_void = (TREE_VALUE (tree_last (old_arg_types))\n+\t\t\t== void_type_node);\n+      otypes = ipa_get_vector_of_formal_parm_types (orig_type);\n+      if (last_parm_void)\n+\tgcc_assert (oparms.length () + 1 == otypes.length ());\n+      else\n+\tgcc_assert (oparms.length () == otypes.length ());\n+    }\n+  else\n+    {\n+      last_parm_void = false;\n+      otypes.create (0);\n+    }\n+\n+  int len = adjustments.length ();\n+  tree *link = &DECL_ARGUMENTS (fndecl);\n+  tree new_arg_types = NULL;\n+  for (int i = 0; i < len; i++)\n+    {\n+      struct ipa_parm_adjustment *adj;\n+      gcc_assert (link);\n+\n+      adj = &adjustments[i];\n+      tree parm;\n+      if (adj->op == IPA_PARM_OP_NEW)\n+\tparm = NULL;\n+      else\n+\tparm = oparms[adj->base_index];\n+      adj->base = parm;\n+\n+      if (adj->op == IPA_PARM_OP_COPY)\n+\t{\n+\t  if (care_for_types)\n+\t    new_arg_types = tree_cons (NULL_TREE, otypes[adj->base_index],\n+\t\t\t\t       new_arg_types);\n+\t  *link = parm;\n+\t  link = &DECL_CHAIN (parm);\n+\t}\n+      else if (adj->op != IPA_PARM_OP_REMOVE)\n+\t{\n+\t  tree new_parm;\n+\t  tree ptype;\n+\n+\t  if (adj->by_ref)\n+\t    ptype = build_pointer_type (adj->type);\n+\t  else\n+\t    {\n+\t      ptype = adj->type;\n+\t      if (is_gimple_reg_type (ptype)\n+\t\t  && TYPE_MODE (ptype) != BLKmode)\n+\t\t{\n+\t\t  unsigned malign = GET_MODE_ALIGNMENT (TYPE_MODE (ptype));\n+\t\t  if (TYPE_ALIGN (ptype) != malign)\n+\t\t    ptype = build_aligned_type (ptype, malign);\n+\t\t}\n+\t    }\n+\n+\t  if (care_for_types)\n+\t    new_arg_types = tree_cons (NULL_TREE, ptype, new_arg_types);\n+\n+\t  new_parm = build_decl (UNKNOWN_LOCATION, PARM_DECL, NULL_TREE,\n+\t\t\t\t ptype);\n+\t  const char *prefix = adj->arg_prefix ? adj->arg_prefix : \"SYNTH\";\n+\t  DECL_NAME (new_parm) = create_tmp_var_name (prefix);\n+\t  DECL_ARTIFICIAL (new_parm) = 1;\n+\t  DECL_ARG_TYPE (new_parm) = ptype;\n+\t  DECL_CONTEXT (new_parm) = fndecl;\n+\t  TREE_USED (new_parm) = 1;\n+\t  DECL_IGNORED_P (new_parm) = 1;\n+\t  layout_decl (new_parm, 0);\n+\n+\t  if (adj->op == IPA_PARM_OP_NEW)\n+\t    adj->base = NULL;\n+\t  else\n+\t    adj->base = parm;\n+\t  adj->new_decl = new_parm;\n+\n+\t  *link = new_parm;\n+\t  link = &DECL_CHAIN (new_parm);\n+\t}\n+    }\n+\n+  *link = NULL_TREE;\n+\n+  tree new_reversed = NULL;\n+  if (care_for_types)\n+    {\n+      new_reversed = nreverse (new_arg_types);\n+      if (last_parm_void)\n+\t{\n+\t  if (new_reversed)\n+\t    TREE_CHAIN (new_arg_types) = void_list_node;\n+\t  else\n+\t    new_reversed = void_list_node;\n+\t}\n+    }\n+\n+  /* Use copy_node to preserve as much as possible from original type\n+     (debug info, attribute lists etc.)\n+     Exception is METHOD_TYPEs must have THIS argument.\n+     When we are asked to remove it, we need to build new FUNCTION_TYPE\n+     instead.  */\n+  tree new_type = NULL;\n+  if (TREE_CODE (orig_type) != METHOD_TYPE\n+       || (adjustments[0].op == IPA_PARM_OP_COPY\n+\t  && adjustments[0].base_index == 0))\n+    {\n+      new_type = build_distinct_type_copy (orig_type);\n+      TYPE_ARG_TYPES (new_type) = new_reversed;\n+    }\n+  else\n+    {\n+      new_type\n+        = build_distinct_type_copy (build_function_type (TREE_TYPE (orig_type),\n+\t\t\t\t\t\t\t new_reversed));\n+      TYPE_CONTEXT (new_type) = TYPE_CONTEXT (orig_type);\n+      DECL_VINDEX (fndecl) = NULL_TREE;\n+    }\n+\n+  /* When signature changes, we need to clear builtin info.  */\n+  if (DECL_BUILT_IN (fndecl))\n+    {\n+      DECL_BUILT_IN_CLASS (fndecl) = NOT_BUILT_IN;\n+      DECL_FUNCTION_CODE (fndecl) = (enum built_in_function) 0;\n+    }\n+\n+  TREE_TYPE (fndecl) = new_type;\n+  DECL_VIRTUAL_P (fndecl) = 0;\n+  DECL_LANG_SPECIFIC (fndecl) = NULL;\n+  otypes.release ();\n+  oparms.release ();\n+}\n+\n+/* Modify actual arguments of a function call CS as indicated in ADJUSTMENTS.\n+   If this is a directly recursive call, CS must be NULL.  Otherwise it must\n+   contain the corresponding call graph edge.  */\n+\n+void\n+ipa_modify_call_arguments (struct cgraph_edge *cs, gcall *stmt,\n+\t\t\t   ipa_parm_adjustment_vec adjustments)\n+{\n+  struct cgraph_node *current_node = cgraph_node::get (current_function_decl);\n+  vec<tree> vargs;\n+  vec<tree, va_gc> **debug_args = NULL;\n+  gcall *new_stmt;\n+  gimple_stmt_iterator gsi, prev_gsi;\n+  tree callee_decl;\n+  int i, len;\n+\n+  len = adjustments.length ();\n+  vargs.create (len);\n+  callee_decl = !cs ? gimple_call_fndecl (stmt) : cs->callee->decl;\n+  current_node->remove_stmt_references (stmt);\n+\n+  gsi = gsi_for_stmt (stmt);\n+  prev_gsi = gsi;\n+  gsi_prev (&prev_gsi);\n+  for (i = 0; i < len; i++)\n+    {\n+      struct ipa_parm_adjustment *adj;\n+\n+      adj = &adjustments[i];\n+\n+      if (adj->op == IPA_PARM_OP_COPY)\n+\t{\n+\t  tree arg = gimple_call_arg (stmt, adj->base_index);\n+\n+\t  vargs.quick_push (arg);\n+\t}\n+      else if (adj->op != IPA_PARM_OP_REMOVE)\n+\t{\n+\t  tree expr, base, off;\n+\t  location_t loc;\n+\t  unsigned int deref_align = 0;\n+\t  bool deref_base = false;\n+\n+\t  /* We create a new parameter out of the value of the old one, we can\n+\t     do the following kind of transformations:\n+\n+\t     - A scalar passed by reference is converted to a scalar passed by\n+               value.  (adj->by_ref is false and the type of the original\n+               actual argument is a pointer to a scalar).\n+\n+             - A part of an aggregate is passed instead of the whole aggregate.\n+               The part can be passed either by value or by reference, this is\n+               determined by value of adj->by_ref.  Moreover, the code below\n+               handles both situations when the original aggregate is passed by\n+               value (its type is not a pointer) and when it is passed by\n+               reference (it is a pointer to an aggregate).\n+\n+\t     When the new argument is passed by reference (adj->by_ref is true)\n+\t     it must be a part of an aggregate and therefore we form it by\n+\t     simply taking the address of a reference inside the original\n+\t     aggregate.  */\n+\n+\t  gcc_checking_assert (adj->offset % BITS_PER_UNIT == 0);\n+\t  base = gimple_call_arg (stmt, adj->base_index);\n+\t  loc = DECL_P (base) ? DECL_SOURCE_LOCATION (base)\n+\t\t\t      : EXPR_LOCATION (base);\n+\n+\t  if (TREE_CODE (base) != ADDR_EXPR\n+\t      && POINTER_TYPE_P (TREE_TYPE (base)))\n+\t    off = build_int_cst (adj->alias_ptr_type,\n+\t\t\t\t adj->offset / BITS_PER_UNIT);\n+\t  else\n+\t    {\n+\t      HOST_WIDE_INT base_offset;\n+\t      tree prev_base;\n+\t      bool addrof;\n+\n+\t      if (TREE_CODE (base) == ADDR_EXPR)\n+\t\t{\n+\t\t  base = TREE_OPERAND (base, 0);\n+\t\t  addrof = true;\n+\t\t}\n+\t      else\n+\t\taddrof = false;\n+\t      prev_base = base;\n+\t      base = get_addr_base_and_unit_offset (base, &base_offset);\n+\t      /* Aggregate arguments can have non-invariant addresses.  */\n+\t      if (!base)\n+\t\t{\n+\t\t  base = build_fold_addr_expr (prev_base);\n+\t\t  off = build_int_cst (adj->alias_ptr_type,\n+\t\t\t\t       adj->offset / BITS_PER_UNIT);\n+\t\t}\n+\t      else if (TREE_CODE (base) == MEM_REF)\n+\t\t{\n+\t\t  if (!addrof)\n+\t\t    {\n+\t\t      deref_base = true;\n+\t\t      deref_align = TYPE_ALIGN (TREE_TYPE (base));\n+\t\t    }\n+\t\t  off = build_int_cst (adj->alias_ptr_type,\n+\t\t\t\t       base_offset\n+\t\t\t\t       + adj->offset / BITS_PER_UNIT);\n+\t\t  off = int_const_binop (PLUS_EXPR, TREE_OPERAND (base, 1),\n+\t\t\t\t\t off);\n+\t\t  base = TREE_OPERAND (base, 0);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  off = build_int_cst (adj->alias_ptr_type,\n+\t\t\t\t       base_offset\n+\t\t\t\t       + adj->offset / BITS_PER_UNIT);\n+\t\t  base = build_fold_addr_expr (base);\n+\t\t}\n+\t    }\n+\n+\t  if (!adj->by_ref)\n+\t    {\n+\t      tree type = adj->type;\n+\t      unsigned int align;\n+\t      unsigned HOST_WIDE_INT misalign;\n+\n+\t      if (deref_base)\n+\t\t{\n+\t\t  align = deref_align;\n+\t\t  misalign = 0;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  get_pointer_alignment_1 (base, &align, &misalign);\n+\t\t  if (TYPE_ALIGN (type) > align)\n+\t\t    align = TYPE_ALIGN (type);\n+\t\t}\n+\t      misalign += (offset_int::from (wi::to_wide (off),\n+\t\t\t\t\t     SIGNED).to_short_addr ()\n+\t\t\t   * BITS_PER_UNIT);\n+\t      misalign = misalign & (align - 1);\n+\t      if (misalign != 0)\n+\t\talign = least_bit_hwi (misalign);\n+\t      if (align < TYPE_ALIGN (type))\n+\t\ttype = build_aligned_type (type, align);\n+\t      base = force_gimple_operand_gsi (&gsi, base,\n+\t\t\t\t\t       true, NULL, true, GSI_SAME_STMT);\n+\t      expr = fold_build2_loc (loc, MEM_REF, type, base, off);\n+\t      REF_REVERSE_STORAGE_ORDER (expr) = adj->reverse;\n+\t      /* If expr is not a valid gimple call argument emit\n+\t         a load into a temporary.  */\n+\t      if (is_gimple_reg_type (TREE_TYPE (expr)))\n+\t\t{\n+\t\t  gimple *tem = gimple_build_assign (NULL_TREE, expr);\n+\t\t  if (gimple_in_ssa_p (cfun))\n+\t\t    {\n+\t\t      gimple_set_vuse (tem, gimple_vuse (stmt));\n+\t\t      expr = make_ssa_name (TREE_TYPE (expr), tem);\n+\t\t    }\n+\t\t  else\n+\t\t    expr = create_tmp_reg (TREE_TYPE (expr));\n+\t\t  gimple_assign_set_lhs (tem, expr);\n+\t\t  gsi_insert_before (&gsi, tem, GSI_SAME_STMT);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      expr = fold_build2_loc (loc, MEM_REF, adj->type, base, off);\n+\t      REF_REVERSE_STORAGE_ORDER (expr) = adj->reverse;\n+\t      expr = build_fold_addr_expr (expr);\n+\t      expr = force_gimple_operand_gsi (&gsi, expr,\n+\t\t\t\t\t       true, NULL, true, GSI_SAME_STMT);\n+\t    }\n+\t  vargs.quick_push (expr);\n+\t}\n+      if (adj->op != IPA_PARM_OP_COPY && MAY_HAVE_DEBUG_STMTS)\n+\t{\n+\t  unsigned int ix;\n+\t  tree ddecl = NULL_TREE, origin = DECL_ORIGIN (adj->base), arg;\n+\t  gimple *def_temp;\n+\n+\t  arg = gimple_call_arg (stmt, adj->base_index);\n+\t  if (!useless_type_conversion_p (TREE_TYPE (origin), TREE_TYPE (arg)))\n+\t    {\n+\t      if (!fold_convertible_p (TREE_TYPE (origin), arg))\n+\t\tcontinue;\n+\t      arg = fold_convert_loc (gimple_location (stmt),\n+\t\t\t\t      TREE_TYPE (origin), arg);\n+\t    }\n+\t  if (debug_args == NULL)\n+\t    debug_args = decl_debug_args_insert (callee_decl);\n+\t  for (ix = 0; vec_safe_iterate (*debug_args, ix, &ddecl); ix += 2)\n+\t    if (ddecl == origin)\n+\t      {\n+\t\tddecl = (**debug_args)[ix + 1];\n+\t\tbreak;\n+\t      }\n+\t  if (ddecl == NULL)\n+\t    {\n+\t      ddecl = make_node (DEBUG_EXPR_DECL);\n+\t      DECL_ARTIFICIAL (ddecl) = 1;\n+\t      TREE_TYPE (ddecl) = TREE_TYPE (origin);\n+\t      SET_DECL_MODE (ddecl, DECL_MODE (origin));\n+\n+\t      vec_safe_push (*debug_args, origin);\n+\t      vec_safe_push (*debug_args, ddecl);\n+\t    }\n+\t  def_temp = gimple_build_debug_bind (ddecl, unshare_expr (arg), stmt);\n+\t  gsi_insert_before (&gsi, def_temp, GSI_SAME_STMT);\n+\t}\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"replacing stmt:\");\n+      print_gimple_stmt (dump_file, gsi_stmt (gsi), 0);\n+    }\n+\n+  new_stmt = gimple_build_call_vec (callee_decl, vargs);\n+  vargs.release ();\n+  if (gimple_call_lhs (stmt))\n+    gimple_call_set_lhs (new_stmt, gimple_call_lhs (stmt));\n+\n+  gimple_set_block (new_stmt, gimple_block (stmt));\n+  if (gimple_has_location (stmt))\n+    gimple_set_location (new_stmt, gimple_location (stmt));\n+  gimple_call_set_chain (new_stmt, gimple_call_chain (stmt));\n+  gimple_call_copy_flags (new_stmt, stmt);\n+  if (gimple_in_ssa_p (cfun))\n+    {\n+      gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n+      if (gimple_vdef (stmt))\n+\t{\n+\t  gimple_set_vdef (new_stmt, gimple_vdef (stmt));\n+\t  SSA_NAME_DEF_STMT (gimple_vdef (new_stmt)) = new_stmt;\n+\t}\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"with stmt:\");\n+      print_gimple_stmt (dump_file, new_stmt, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  gsi_replace (&gsi, new_stmt, true);\n+  if (cs)\n+    cs->set_call_stmt (new_stmt);\n+  do\n+    {\n+      current_node->record_stmt_references (gsi_stmt (gsi));\n+      gsi_prev (&gsi);\n+    }\n+  while (gsi_stmt (gsi) != gsi_stmt (prev_gsi));\n+}\n+\n+/* Return true iff BASE_INDEX is in ADJUSTMENTS more than once.  */\n+\n+static bool\n+index_in_adjustments_multiple_times_p (int base_index,\n+\t\t\t\t       ipa_parm_adjustment_vec adjustments)\n+{\n+  int i, len = adjustments.length ();\n+  bool one = false;\n+\n+  for (i = 0; i < len; i++)\n+    {\n+      struct ipa_parm_adjustment *adj;\n+      adj = &adjustments[i];\n+\n+      if (adj->base_index == base_index)\n+\t{\n+\t  if (one)\n+\t    return true;\n+\t  else\n+\t    one = true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Return adjustments that should have the same effect on function parameters\n+   and call arguments as if they were first changed according to adjustments in\n+   INNER and then by adjustments in OUTER.  */\n+\n+ipa_parm_adjustment_vec\n+ipa_combine_adjustments (ipa_parm_adjustment_vec inner,\n+\t\t\t ipa_parm_adjustment_vec outer)\n+{\n+  int i, outlen = outer.length ();\n+  int inlen = inner.length ();\n+  int removals = 0;\n+  ipa_parm_adjustment_vec adjustments, tmp;\n+\n+  tmp.create (inlen);\n+  for (i = 0; i < inlen; i++)\n+    {\n+      struct ipa_parm_adjustment *n;\n+      n = &inner[i];\n+\n+      if (n->op == IPA_PARM_OP_REMOVE)\n+\tremovals++;\n+      else\n+\t{\n+\t  /* FIXME: Handling of new arguments are not implemented yet.  */\n+\t  gcc_assert (n->op != IPA_PARM_OP_NEW);\n+\t  tmp.quick_push (*n);\n+\t}\n+    }\n+\n+  adjustments.create (outlen + removals);\n+  for (i = 0; i < outlen; i++)\n+    {\n+      struct ipa_parm_adjustment r;\n+      struct ipa_parm_adjustment *out = &outer[i];\n+      struct ipa_parm_adjustment *in = &tmp[out->base_index];\n+\n+      memset (&r, 0, sizeof (r));\n+      gcc_assert (in->op != IPA_PARM_OP_REMOVE);\n+      if (out->op == IPA_PARM_OP_REMOVE)\n+\t{\n+\t  if (!index_in_adjustments_multiple_times_p (in->base_index, tmp))\n+\t    {\n+\t      r.op = IPA_PARM_OP_REMOVE;\n+\t      adjustments.quick_push (r);\n+\t    }\n+\t  continue;\n+\t}\n+      else\n+\t{\n+\t  /* FIXME: Handling of new arguments are not implemented yet.  */\n+\t  gcc_assert (out->op != IPA_PARM_OP_NEW);\n+\t}\n+\n+      r.base_index = in->base_index;\n+      r.type = out->type;\n+\n+      /* FIXME:  Create nonlocal value too.  */\n+\n+      if (in->op == IPA_PARM_OP_COPY && out->op == IPA_PARM_OP_COPY)\n+\tr.op = IPA_PARM_OP_COPY;\n+      else if (in->op == IPA_PARM_OP_COPY)\n+\tr.offset = out->offset;\n+      else if (out->op == IPA_PARM_OP_COPY)\n+\tr.offset = in->offset;\n+      else\n+\tr.offset = in->offset + out->offset;\n+      adjustments.quick_push (r);\n+    }\n+\n+  for (i = 0; i < inlen; i++)\n+    {\n+      struct ipa_parm_adjustment *n = &inner[i];\n+\n+      if (n->op == IPA_PARM_OP_REMOVE)\n+\tadjustments.quick_push (*n);\n+    }\n+\n+  tmp.release ();\n+  return adjustments;\n+}\n+\n+/* If T is an SSA_NAME, return NULL if it is not a default def or\n+   return its base variable if it is.  If IGNORE_DEFAULT_DEF is true,\n+   the base variable is always returned, regardless if it is a default\n+   def.  Return T if it is not an SSA_NAME.  */\n+\n+static tree\n+get_ssa_base_param (tree t, bool ignore_default_def)\n+{\n+  if (TREE_CODE (t) == SSA_NAME)\n+    {\n+      if (ignore_default_def || SSA_NAME_IS_DEFAULT_DEF (t))\n+\treturn SSA_NAME_VAR (t);\n+      else\n+\treturn NULL_TREE;\n+    }\n+  return t;\n+}\n+\n+/* Given an expression, return an adjustment entry specifying the\n+   transformation to be done on EXPR.  If no suitable adjustment entry\n+   was found, returns NULL.\n+\n+   If IGNORE_DEFAULT_DEF is set, consider SSA_NAMEs which are not a\n+   default def, otherwise bail on them.\n+\n+   If CONVERT is non-NULL, this function will set *CONVERT if the\n+   expression provided is a component reference.  ADJUSTMENTS is the\n+   adjustments vector.  */\n+\n+ipa_parm_adjustment *\n+ipa_get_adjustment_candidate (tree **expr, bool *convert,\n+\t\t\t      ipa_parm_adjustment_vec adjustments,\n+\t\t\t      bool ignore_default_def)\n+{\n+  if (TREE_CODE (**expr) == BIT_FIELD_REF\n+      || TREE_CODE (**expr) == IMAGPART_EXPR\n+      || TREE_CODE (**expr) == REALPART_EXPR)\n+    {\n+      *expr = &TREE_OPERAND (**expr, 0);\n+      if (convert)\n+\t*convert = true;\n+    }\n+\n+  HOST_WIDE_INT offset, size, max_size;\n+  bool reverse;\n+  tree base\n+    = get_ref_base_and_extent (**expr, &offset, &size, &max_size, &reverse);\n+  if (!base || size == -1 || max_size == -1)\n+    return NULL;\n+\n+  if (TREE_CODE (base) == MEM_REF)\n+    {\n+      offset += mem_ref_offset (base).to_short_addr () * BITS_PER_UNIT;\n+      base = TREE_OPERAND (base, 0);\n+    }\n+\n+  base = get_ssa_base_param (base, ignore_default_def);\n+  if (!base || TREE_CODE (base) != PARM_DECL)\n+    return NULL;\n+\n+  struct ipa_parm_adjustment *cand = NULL;\n+  unsigned int len = adjustments.length ();\n+  for (unsigned i = 0; i < len; i++)\n+    {\n+      struct ipa_parm_adjustment *adj = &adjustments[i];\n+\n+      if (adj->base == base\n+\t  && (adj->offset == offset || adj->op == IPA_PARM_OP_REMOVE))\n+\t{\n+\t  cand = adj;\n+\t  break;\n+\t}\n+    }\n+\n+  if (!cand || cand->op == IPA_PARM_OP_COPY || cand->op == IPA_PARM_OP_REMOVE)\n+    return NULL;\n+  return cand;\n+}\n+\n+/* If the expression *EXPR should be replaced by a reduction of a parameter, do\n+   so.  ADJUSTMENTS is a pointer to a vector of adjustments.  CONVERT\n+   specifies whether the function should care about type incompatibility the\n+   current and new expressions.  If it is false, the function will leave\n+   incompatibility issues to the caller.  Return true iff the expression\n+   was modified. */\n+\n+bool\n+ipa_modify_expr (tree *expr, bool convert,\n+\t\t ipa_parm_adjustment_vec adjustments)\n+{\n+  struct ipa_parm_adjustment *cand\n+    = ipa_get_adjustment_candidate (&expr, &convert, adjustments, false);\n+  if (!cand)\n+    return false;\n+\n+  tree src;\n+  if (cand->by_ref)\n+    {\n+      src = build_simple_mem_ref (cand->new_decl);\n+      REF_REVERSE_STORAGE_ORDER (src) = cand->reverse;\n+    }\n+  else\n+    src = cand->new_decl;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"About to replace expr \");\n+      print_generic_expr (dump_file, *expr);\n+      fprintf (dump_file, \" with \");\n+      print_generic_expr (dump_file, src);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  if (convert && !useless_type_conversion_p (TREE_TYPE (*expr), cand->type))\n+    {\n+      tree vce = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (*expr), src);\n+      *expr = vce;\n+    }\n+  else\n+    *expr = src;\n+  return true;\n+}\n+\n+/* Dump the adjustments in the vector ADJUSTMENTS to dump_file in a human\n+   friendly way, assuming they are meant to be applied to FNDECL.  */\n+\n+void\n+ipa_dump_param_adjustments (FILE *file, ipa_parm_adjustment_vec adjustments,\n+\t\t\t    tree fndecl)\n+{\n+  int i, len = adjustments.length ();\n+  bool first = true;\n+  vec<tree> parms = ipa_get_vector_of_formal_parms (fndecl);\n+\n+  fprintf (file, \"IPA param adjustments: \");\n+  for (i = 0; i < len; i++)\n+    {\n+      struct ipa_parm_adjustment *adj;\n+      adj = &adjustments[i];\n+\n+      if (!first)\n+\tfprintf (file, \"                 \");\n+      else\n+\tfirst = false;\n+\n+      fprintf (file, \"%i. base_index: %i - \", i, adj->base_index);\n+      print_generic_expr (file, parms[adj->base_index]);\n+      if (adj->base)\n+\t{\n+\t  fprintf (file, \", base: \");\n+\t  print_generic_expr (file, adj->base);\n+\t}\n+      if (adj->new_decl)\n+\t{\n+\t  fprintf (file, \", new_decl: \");\n+\t  print_generic_expr (file, adj->new_decl);\n+\t}\n+      if (adj->new_ssa_base)\n+\t{\n+\t  fprintf (file, \", new_ssa_base: \");\n+\t  print_generic_expr (file, adj->new_ssa_base);\n+\t}\n+\n+      if (adj->op == IPA_PARM_OP_COPY)\n+\tfprintf (file, \", copy_param\");\n+      else if (adj->op == IPA_PARM_OP_REMOVE)\n+\tfprintf (file, \", remove_param\");\n+      else\n+\tfprintf (file, \", offset %li\", (long) adj->offset);\n+      if (adj->by_ref)\n+\tfprintf (file, \", by_ref\");\n+      print_node_brief (file, \", type: \", adj->type, 0);\n+      fprintf (file, \"\\n\");\n+    }\n+  parms.release ();\n+}\n+"}, {"sha": "364e4489c294ddf94d757187878613f81697e624", "filename": "gcc/ipa-param-manipulation.h", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d99a8487287e94b9bd42807cbe864991a0d1d3b/gcc%2Fipa-param-manipulation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d99a8487287e94b9bd42807cbe864991a0d1d3b/gcc%2Fipa-param-manipulation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.h?ref=4d99a8487287e94b9bd42807cbe864991a0d1d3b", "patch": "@@ -0,0 +1,120 @@\n+/* Manipulation of formal and actual parameters of functions and function\n+   calls.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef IPA_PARAM_MANIPULATION_H\n+#define IPA_PARAM_MANIPULATION_H\n+\n+/* Operation to be performed for the parameter in ipa_parm_adjustment\n+   below.  */\n+enum ipa_parm_op {\n+  IPA_PARM_OP_NONE,\n+\n+  /* This describes a brand new parameter.\n+\n+     The field `type' should be set to the new type, `arg_prefix'\n+     should be set to the string prefix for the new DECL_NAME, and\n+     `new_decl' will ultimately hold the newly created argument.  */\n+  IPA_PARM_OP_NEW,\n+\n+  /* This new parameter is an unmodified parameter at index base_index. */\n+  IPA_PARM_OP_COPY,\n+\n+  /* This adjustment describes a parameter that is about to be removed\n+     completely.  Most users will probably need to book keep those so that they\n+     don't leave behinfd any non default def ssa names belonging to them.  */\n+  IPA_PARM_OP_REMOVE\n+};\n+\n+/* Structure to describe transformations of formal parameters and actual\n+   arguments.  Each instance describes one new parameter and they are meant to\n+   be stored in a vector.  Additionally, most users will probably want to store\n+   adjustments about parameters that are being removed altogether so that SSA\n+   names belonging to them can be replaced by SSA names of an artificial\n+   variable.  */\n+struct ipa_parm_adjustment\n+{\n+  /* The original PARM_DECL itself, helpful for processing of the body of the\n+     function itself.  Intended for traversing function bodies.\n+     ipa_modify_formal_parameters, ipa_modify_call_arguments and\n+     ipa_combine_adjustments ignore this and use base_index.\n+     ipa_modify_formal_parameters actually sets this.  */\n+  tree base;\n+\n+  /* Type of the new parameter.  However, if by_ref is true, the real type will\n+     be a pointer to this type.  */\n+  tree type;\n+\n+  /* Alias refrerence type to be used in MEM_REFs when adjusting caller\n+     arguments.  */\n+  tree alias_ptr_type;\n+\n+  /* The new declaration when creating/replacing a parameter.  Created\n+     by ipa_modify_formal_parameters, useful for functions modifying\n+     the body accordingly.  For brand new arguments, this is the newly\n+     created argument.  */\n+  tree new_decl;\n+\n+  /* New declaration of a substitute variable that we may use to replace all\n+     non-default-def ssa names when a parm decl is going away.  */\n+  tree new_ssa_base;\n+\n+  /* If non-NULL and the original parameter is to be removed (copy_param below\n+     is NULL), this is going to be its nonlocalized vars value.  */\n+  tree nonlocal_value;\n+\n+  /* This holds the prefix to be used for the new DECL_NAME.  */\n+  const char *arg_prefix;\n+\n+  /* Offset into the original parameter (for the cases when the new parameter\n+     is a component of an original one).  */\n+  HOST_WIDE_INT offset;\n+\n+  /* Zero based index of the original parameter this one is based on.  */\n+  int base_index;\n+\n+  /* Whether this parameter is a new parameter, a copy of an old one,\n+     or one about to be removed.  */\n+  enum ipa_parm_op op;\n+\n+  /* Storage order of the original parameter (for the cases when the new\n+     parameter is a component of an original one).  */\n+  unsigned reverse : 1;\n+\n+  /* The parameter is to be passed by reference.  */\n+  unsigned by_ref : 1;\n+};\n+\n+typedef vec<ipa_parm_adjustment> ipa_parm_adjustment_vec;\n+\n+vec<tree> ipa_get_vector_of_formal_parms (tree fndecl);\n+vec<tree> ipa_get_vector_of_formal_parm_types (tree fntype);\n+void ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec);\n+void ipa_modify_call_arguments (struct cgraph_edge *, gcall *,\n+\t\t\t\tipa_parm_adjustment_vec);\n+ipa_parm_adjustment_vec ipa_combine_adjustments (ipa_parm_adjustment_vec,\n+\t\t\t\t\t\t ipa_parm_adjustment_vec);\n+void ipa_dump_param_adjustments (FILE *, ipa_parm_adjustment_vec, tree);\n+\n+bool ipa_modify_expr (tree *, bool, ipa_parm_adjustment_vec);\n+ipa_parm_adjustment *ipa_get_adjustment_candidate (tree **, bool *,\n+\t\t\t\t\t\t   ipa_parm_adjustment_vec,\n+\t\t\t\t\t\t   bool);\n+\n+#endif\t/* IPA_PARAM_MANIPULATION_H */"}, {"sha": "729251714de896daa6837150cdf8a0f228e0e0ab", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 0, "deletions": 725, "changes": 725, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d99a8487287e94b9bd42807cbe864991a0d1d3b/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d99a8487287e94b9bd42807cbe864991a0d1d3b/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=4d99a8487287e94b9bd42807cbe864991a0d1d3b", "patch": "@@ -4050,731 +4050,6 @@ ipa_print_all_params (FILE * f)\n     ipa_print_node_params (f, node);\n }\n \n-/* Return a heap allocated vector containing formal parameters of FNDECL.  */\n-\n-vec<tree> \n-ipa_get_vector_of_formal_parms (tree fndecl)\n-{\n-  vec<tree> args;\n-  int count;\n-  tree parm;\n-\n-  gcc_assert (!flag_wpa);\n-  count = count_formal_params (fndecl);\n-  args.create (count);\n-  for (parm = DECL_ARGUMENTS (fndecl); parm; parm = DECL_CHAIN (parm))\n-    args.quick_push (parm);\n-\n-  return args;\n-}\n-\n-/* Return a heap allocated vector containing types of formal parameters of\n-   function type FNTYPE.  */\n-\n-vec<tree>\n-ipa_get_vector_of_formal_parm_types (tree fntype)\n-{\n-  vec<tree> types;\n-  int count = 0;\n-  tree t;\n-\n-  for (t = TYPE_ARG_TYPES (fntype); t; t = TREE_CHAIN (t))\n-    count++;\n-\n-  types.create (count);\n-  for (t = TYPE_ARG_TYPES (fntype); t; t = TREE_CHAIN (t))\n-    types.quick_push (TREE_VALUE (t));\n-\n-  return types;\n-}\n-\n-/* Modify the function declaration FNDECL and its type according to the plan in\n-   ADJUSTMENTS.  It also sets base fields of individual adjustments structures\n-   to reflect the actual parameters being modified which are determined by the\n-   base_index field.  */\n-\n-void\n-ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec adjustments)\n-{\n-  vec<tree> oparms = ipa_get_vector_of_formal_parms (fndecl);\n-  tree orig_type = TREE_TYPE (fndecl);\n-  tree old_arg_types = TYPE_ARG_TYPES (orig_type);\n-\n-  /* The following test is an ugly hack, some functions simply don't have any\n-     arguments in their type.  This is probably a bug but well... */\n-  bool care_for_types = (old_arg_types != NULL_TREE);\n-  bool last_parm_void;\n-  vec<tree> otypes;\n-  if (care_for_types)\n-    {\n-      last_parm_void = (TREE_VALUE (tree_last (old_arg_types))\n-\t\t\t== void_type_node);\n-      otypes = ipa_get_vector_of_formal_parm_types (orig_type);\n-      if (last_parm_void)\n-\tgcc_assert (oparms.length () + 1 == otypes.length ());\n-      else\n-\tgcc_assert (oparms.length () == otypes.length ());\n-    }\n-  else\n-    {\n-      last_parm_void = false;\n-      otypes.create (0);\n-    }\n-\n-  int len = adjustments.length ();\n-  tree *link = &DECL_ARGUMENTS (fndecl);\n-  tree new_arg_types = NULL;\n-  for (int i = 0; i < len; i++)\n-    {\n-      struct ipa_parm_adjustment *adj;\n-      gcc_assert (link);\n-\n-      adj = &adjustments[i];\n-      tree parm;\n-      if (adj->op == IPA_PARM_OP_NEW)\n-\tparm = NULL;\n-      else\n-\tparm = oparms[adj->base_index];\n-      adj->base = parm;\n-\n-      if (adj->op == IPA_PARM_OP_COPY)\n-\t{\n-\t  if (care_for_types)\n-\t    new_arg_types = tree_cons (NULL_TREE, otypes[adj->base_index],\n-\t\t\t\t       new_arg_types);\n-\t  *link = parm;\n-\t  link = &DECL_CHAIN (parm);\n-\t}\n-      else if (adj->op != IPA_PARM_OP_REMOVE)\n-\t{\n-\t  tree new_parm;\n-\t  tree ptype;\n-\n-\t  if (adj->by_ref)\n-\t    ptype = build_pointer_type (adj->type);\n-\t  else\n-\t    {\n-\t      ptype = adj->type;\n-\t      if (is_gimple_reg_type (ptype)\n-\t\t  && TYPE_MODE (ptype) != BLKmode)\n-\t\t{\n-\t\t  unsigned malign = GET_MODE_ALIGNMENT (TYPE_MODE (ptype));\n-\t\t  if (TYPE_ALIGN (ptype) != malign)\n-\t\t    ptype = build_aligned_type (ptype, malign);\n-\t\t}\n-\t    }\n-\n-\t  if (care_for_types)\n-\t    new_arg_types = tree_cons (NULL_TREE, ptype, new_arg_types);\n-\n-\t  new_parm = build_decl (UNKNOWN_LOCATION, PARM_DECL, NULL_TREE,\n-\t\t\t\t ptype);\n-\t  const char *prefix = adj->arg_prefix ? adj->arg_prefix : \"SYNTH\";\n-\t  DECL_NAME (new_parm) = create_tmp_var_name (prefix);\n-\t  DECL_ARTIFICIAL (new_parm) = 1;\n-\t  DECL_ARG_TYPE (new_parm) = ptype;\n-\t  DECL_CONTEXT (new_parm) = fndecl;\n-\t  TREE_USED (new_parm) = 1;\n-\t  DECL_IGNORED_P (new_parm) = 1;\n-\t  layout_decl (new_parm, 0);\n-\n-\t  if (adj->op == IPA_PARM_OP_NEW)\n-\t    adj->base = NULL;\n-\t  else\n-\t    adj->base = parm;\n-\t  adj->new_decl = new_parm;\n-\n-\t  *link = new_parm;\n-\t  link = &DECL_CHAIN (new_parm);\n-\t}\n-    }\n-\n-  *link = NULL_TREE;\n-\n-  tree new_reversed = NULL;\n-  if (care_for_types)\n-    {\n-      new_reversed = nreverse (new_arg_types);\n-      if (last_parm_void)\n-\t{\n-\t  if (new_reversed)\n-\t    TREE_CHAIN (new_arg_types) = void_list_node;\n-\t  else\n-\t    new_reversed = void_list_node;\n-\t}\n-    }\n-\n-  /* Use copy_node to preserve as much as possible from original type\n-     (debug info, attribute lists etc.)\n-     Exception is METHOD_TYPEs must have THIS argument.\n-     When we are asked to remove it, we need to build new FUNCTION_TYPE\n-     instead.  */\n-  tree new_type = NULL;\n-  if (TREE_CODE (orig_type) != METHOD_TYPE\n-       || (adjustments[0].op == IPA_PARM_OP_COPY\n-\t  && adjustments[0].base_index == 0))\n-    {\n-      new_type = build_distinct_type_copy (orig_type);\n-      TYPE_ARG_TYPES (new_type) = new_reversed;\n-    }\n-  else\n-    {\n-      new_type\n-        = build_distinct_type_copy (build_function_type (TREE_TYPE (orig_type),\n-\t\t\t\t\t\t\t new_reversed));\n-      TYPE_CONTEXT (new_type) = TYPE_CONTEXT (orig_type);\n-      DECL_VINDEX (fndecl) = NULL_TREE;\n-    }\n-\n-  /* When signature changes, we need to clear builtin info.  */\n-  if (DECL_BUILT_IN (fndecl))\n-    {\n-      DECL_BUILT_IN_CLASS (fndecl) = NOT_BUILT_IN;\n-      DECL_FUNCTION_CODE (fndecl) = (enum built_in_function) 0;\n-    }\n-\n-  TREE_TYPE (fndecl) = new_type;\n-  DECL_VIRTUAL_P (fndecl) = 0;\n-  DECL_LANG_SPECIFIC (fndecl) = NULL;\n-  otypes.release ();\n-  oparms.release ();\n-}\n-\n-/* Modify actual arguments of a function call CS as indicated in ADJUSTMENTS.\n-   If this is a directly recursive call, CS must be NULL.  Otherwise it must\n-   contain the corresponding call graph edge.  */\n-\n-void\n-ipa_modify_call_arguments (struct cgraph_edge *cs, gcall *stmt,\n-\t\t\t   ipa_parm_adjustment_vec adjustments)\n-{\n-  struct cgraph_node *current_node = cgraph_node::get (current_function_decl);\n-  vec<tree> vargs;\n-  vec<tree, va_gc> **debug_args = NULL;\n-  gcall *new_stmt;\n-  gimple_stmt_iterator gsi, prev_gsi;\n-  tree callee_decl;\n-  int i, len;\n-\n-  len = adjustments.length ();\n-  vargs.create (len);\n-  callee_decl = !cs ? gimple_call_fndecl (stmt) : cs->callee->decl;\n-  current_node->remove_stmt_references (stmt);\n-\n-  gsi = gsi_for_stmt (stmt);\n-  prev_gsi = gsi;\n-  gsi_prev (&prev_gsi);\n-  for (i = 0; i < len; i++)\n-    {\n-      struct ipa_parm_adjustment *adj;\n-\n-      adj = &adjustments[i];\n-\n-      if (adj->op == IPA_PARM_OP_COPY)\n-\t{\n-\t  tree arg = gimple_call_arg (stmt, adj->base_index);\n-\n-\t  vargs.quick_push (arg);\n-\t}\n-      else if (adj->op != IPA_PARM_OP_REMOVE)\n-\t{\n-\t  tree expr, base, off;\n-\t  location_t loc;\n-\t  unsigned int deref_align = 0;\n-\t  bool deref_base = false;\n-\n-\t  /* We create a new parameter out of the value of the old one, we can\n-\t     do the following kind of transformations:\n-\n-\t     - A scalar passed by reference is converted to a scalar passed by\n-               value.  (adj->by_ref is false and the type of the original\n-               actual argument is a pointer to a scalar).\n-\n-             - A part of an aggregate is passed instead of the whole aggregate.\n-               The part can be passed either by value or by reference, this is\n-               determined by value of adj->by_ref.  Moreover, the code below\n-               handles both situations when the original aggregate is passed by\n-               value (its type is not a pointer) and when it is passed by\n-               reference (it is a pointer to an aggregate).\n-\n-\t     When the new argument is passed by reference (adj->by_ref is true)\n-\t     it must be a part of an aggregate and therefore we form it by\n-\t     simply taking the address of a reference inside the original\n-\t     aggregate.  */\n-\n-\t  gcc_checking_assert (adj->offset % BITS_PER_UNIT == 0);\n-\t  base = gimple_call_arg (stmt, adj->base_index);\n-\t  loc = DECL_P (base) ? DECL_SOURCE_LOCATION (base)\n-\t\t\t      : EXPR_LOCATION (base);\n-\n-\t  if (TREE_CODE (base) != ADDR_EXPR\n-\t      && POINTER_TYPE_P (TREE_TYPE (base)))\n-\t    off = build_int_cst (adj->alias_ptr_type,\n-\t\t\t\t adj->offset / BITS_PER_UNIT);\n-\t  else\n-\t    {\n-\t      HOST_WIDE_INT base_offset;\n-\t      tree prev_base;\n-\t      bool addrof;\n-\n-\t      if (TREE_CODE (base) == ADDR_EXPR)\n-\t\t{\n-\t\t  base = TREE_OPERAND (base, 0);\n-\t\t  addrof = true;\n-\t\t}\n-\t      else\n-\t\taddrof = false;\n-\t      prev_base = base;\n-\t      base = get_addr_base_and_unit_offset (base, &base_offset);\n-\t      /* Aggregate arguments can have non-invariant addresses.  */\n-\t      if (!base)\n-\t\t{\n-\t\t  base = build_fold_addr_expr (prev_base);\n-\t\t  off = build_int_cst (adj->alias_ptr_type,\n-\t\t\t\t       adj->offset / BITS_PER_UNIT);\n-\t\t}\n-\t      else if (TREE_CODE (base) == MEM_REF)\n-\t\t{\n-\t\t  if (!addrof)\n-\t\t    {\n-\t\t      deref_base = true;\n-\t\t      deref_align = TYPE_ALIGN (TREE_TYPE (base));\n-\t\t    }\n-\t\t  off = build_int_cst (adj->alias_ptr_type,\n-\t\t\t\t       base_offset\n-\t\t\t\t       + adj->offset / BITS_PER_UNIT);\n-\t\t  off = int_const_binop (PLUS_EXPR, TREE_OPERAND (base, 1),\n-\t\t\t\t\t off);\n-\t\t  base = TREE_OPERAND (base, 0);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  off = build_int_cst (adj->alias_ptr_type,\n-\t\t\t\t       base_offset\n-\t\t\t\t       + adj->offset / BITS_PER_UNIT);\n-\t\t  base = build_fold_addr_expr (base);\n-\t\t}\n-\t    }\n-\n-\t  if (!adj->by_ref)\n-\t    {\n-\t      tree type = adj->type;\n-\t      unsigned int align;\n-\t      unsigned HOST_WIDE_INT misalign;\n-\n-\t      if (deref_base)\n-\t\t{\n-\t\t  align = deref_align;\n-\t\t  misalign = 0;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  get_pointer_alignment_1 (base, &align, &misalign);\n-\t\t  if (TYPE_ALIGN (type) > align)\n-\t\t    align = TYPE_ALIGN (type);\n-\t\t}\n-\t      misalign += (offset_int::from (wi::to_wide (off),\n-\t\t\t\t\t     SIGNED).to_short_addr ()\n-\t\t\t   * BITS_PER_UNIT);\n-\t      misalign = misalign & (align - 1);\n-\t      if (misalign != 0)\n-\t\talign = least_bit_hwi (misalign);\n-\t      if (align < TYPE_ALIGN (type))\n-\t\ttype = build_aligned_type (type, align);\n-\t      base = force_gimple_operand_gsi (&gsi, base,\n-\t\t\t\t\t       true, NULL, true, GSI_SAME_STMT);\n-\t      expr = fold_build2_loc (loc, MEM_REF, type, base, off);\n-\t      REF_REVERSE_STORAGE_ORDER (expr) = adj->reverse;\n-\t      /* If expr is not a valid gimple call argument emit\n-\t         a load into a temporary.  */\n-\t      if (is_gimple_reg_type (TREE_TYPE (expr)))\n-\t\t{\n-\t\t  gimple *tem = gimple_build_assign (NULL_TREE, expr);\n-\t\t  if (gimple_in_ssa_p (cfun))\n-\t\t    {\n-\t\t      gimple_set_vuse (tem, gimple_vuse (stmt));\n-\t\t      expr = make_ssa_name (TREE_TYPE (expr), tem);\n-\t\t    }\n-\t\t  else\n-\t\t    expr = create_tmp_reg (TREE_TYPE (expr));\n-\t\t  gimple_assign_set_lhs (tem, expr);\n-\t\t  gsi_insert_before (&gsi, tem, GSI_SAME_STMT);\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      expr = fold_build2_loc (loc, MEM_REF, adj->type, base, off);\n-\t      REF_REVERSE_STORAGE_ORDER (expr) = adj->reverse;\n-\t      expr = build_fold_addr_expr (expr);\n-\t      expr = force_gimple_operand_gsi (&gsi, expr,\n-\t\t\t\t\t       true, NULL, true, GSI_SAME_STMT);\n-\t    }\n-\t  vargs.quick_push (expr);\n-\t}\n-      if (adj->op != IPA_PARM_OP_COPY && MAY_HAVE_DEBUG_STMTS)\n-\t{\n-\t  unsigned int ix;\n-\t  tree ddecl = NULL_TREE, origin = DECL_ORIGIN (adj->base), arg;\n-\t  gimple *def_temp;\n-\n-\t  arg = gimple_call_arg (stmt, adj->base_index);\n-\t  if (!useless_type_conversion_p (TREE_TYPE (origin), TREE_TYPE (arg)))\n-\t    {\n-\t      if (!fold_convertible_p (TREE_TYPE (origin), arg))\n-\t\tcontinue;\n-\t      arg = fold_convert_loc (gimple_location (stmt),\n-\t\t\t\t      TREE_TYPE (origin), arg);\n-\t    }\n-\t  if (debug_args == NULL)\n-\t    debug_args = decl_debug_args_insert (callee_decl);\n-\t  for (ix = 0; vec_safe_iterate (*debug_args, ix, &ddecl); ix += 2)\n-\t    if (ddecl == origin)\n-\t      {\n-\t\tddecl = (**debug_args)[ix + 1];\n-\t\tbreak;\n-\t      }\n-\t  if (ddecl == NULL)\n-\t    {\n-\t      ddecl = make_node (DEBUG_EXPR_DECL);\n-\t      DECL_ARTIFICIAL (ddecl) = 1;\n-\t      TREE_TYPE (ddecl) = TREE_TYPE (origin);\n-\t      SET_DECL_MODE (ddecl, DECL_MODE (origin));\n-\n-\t      vec_safe_push (*debug_args, origin);\n-\t      vec_safe_push (*debug_args, ddecl);\n-\t    }\n-\t  def_temp = gimple_build_debug_bind (ddecl, unshare_expr (arg), stmt);\n-\t  gsi_insert_before (&gsi, def_temp, GSI_SAME_STMT);\n-\t}\n-    }\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"replacing stmt:\");\n-      print_gimple_stmt (dump_file, gsi_stmt (gsi), 0);\n-    }\n-\n-  new_stmt = gimple_build_call_vec (callee_decl, vargs);\n-  vargs.release ();\n-  if (gimple_call_lhs (stmt))\n-    gimple_call_set_lhs (new_stmt, gimple_call_lhs (stmt));\n-\n-  gimple_set_block (new_stmt, gimple_block (stmt));\n-  if (gimple_has_location (stmt))\n-    gimple_set_location (new_stmt, gimple_location (stmt));\n-  gimple_call_set_chain (new_stmt, gimple_call_chain (stmt));\n-  gimple_call_copy_flags (new_stmt, stmt);\n-  if (gimple_in_ssa_p (cfun))\n-    {\n-      gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n-      if (gimple_vdef (stmt))\n-\t{\n-\t  gimple_set_vdef (new_stmt, gimple_vdef (stmt));\n-\t  SSA_NAME_DEF_STMT (gimple_vdef (new_stmt)) = new_stmt;\n-\t}\n-    }\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"with stmt:\");\n-      print_gimple_stmt (dump_file, new_stmt, 0);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-  gsi_replace (&gsi, new_stmt, true);\n-  if (cs)\n-    cs->set_call_stmt (new_stmt);\n-  do\n-    {\n-      current_node->record_stmt_references (gsi_stmt (gsi));\n-      gsi_prev (&gsi);\n-    }\n-  while (gsi_stmt (gsi) != gsi_stmt (prev_gsi));\n-}\n-\n-/* If the expression *EXPR should be replaced by a reduction of a parameter, do\n-   so.  ADJUSTMENTS is a pointer to a vector of adjustments.  CONVERT\n-   specifies whether the function should care about type incompatibility the\n-   current and new expressions.  If it is false, the function will leave\n-   incompatibility issues to the caller.  Return true iff the expression\n-   was modified. */\n-\n-bool\n-ipa_modify_expr (tree *expr, bool convert,\n-\t\t ipa_parm_adjustment_vec adjustments)\n-{\n-  struct ipa_parm_adjustment *cand\n-    = ipa_get_adjustment_candidate (&expr, &convert, adjustments, false);\n-  if (!cand)\n-    return false;\n-\n-  tree src;\n-  if (cand->by_ref)\n-    {\n-      src = build_simple_mem_ref (cand->new_decl);\n-      REF_REVERSE_STORAGE_ORDER (src) = cand->reverse;\n-    }\n-  else\n-    src = cand->new_decl;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"About to replace expr \");\n-      print_generic_expr (dump_file, *expr);\n-      fprintf (dump_file, \" with \");\n-      print_generic_expr (dump_file, src);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  if (convert && !useless_type_conversion_p (TREE_TYPE (*expr), cand->type))\n-    {\n-      tree vce = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (*expr), src);\n-      *expr = vce;\n-    }\n-  else\n-    *expr = src;\n-  return true;\n-}\n-\n-/* If T is an SSA_NAME, return NULL if it is not a default def or\n-   return its base variable if it is.  If IGNORE_DEFAULT_DEF is true,\n-   the base variable is always returned, regardless if it is a default\n-   def.  Return T if it is not an SSA_NAME.  */\n-\n-static tree\n-get_ssa_base_param (tree t, bool ignore_default_def)\n-{\n-  if (TREE_CODE (t) == SSA_NAME)\n-    {\n-      if (ignore_default_def || SSA_NAME_IS_DEFAULT_DEF (t))\n-\treturn SSA_NAME_VAR (t);\n-      else\n-\treturn NULL_TREE;\n-    }\n-  return t;\n-}\n-\n-/* Given an expression, return an adjustment entry specifying the\n-   transformation to be done on EXPR.  If no suitable adjustment entry\n-   was found, returns NULL.\n-\n-   If IGNORE_DEFAULT_DEF is set, consider SSA_NAMEs which are not a\n-   default def, otherwise bail on them.\n-\n-   If CONVERT is non-NULL, this function will set *CONVERT if the\n-   expression provided is a component reference.  ADJUSTMENTS is the\n-   adjustments vector.  */\n-\n-ipa_parm_adjustment *\n-ipa_get_adjustment_candidate (tree **expr, bool *convert,\n-\t\t\t      ipa_parm_adjustment_vec adjustments,\n-\t\t\t      bool ignore_default_def)\n-{\n-  if (TREE_CODE (**expr) == BIT_FIELD_REF\n-      || TREE_CODE (**expr) == IMAGPART_EXPR\n-      || TREE_CODE (**expr) == REALPART_EXPR)\n-    {\n-      *expr = &TREE_OPERAND (**expr, 0);\n-      if (convert)\n-\t*convert = true;\n-    }\n-\n-  HOST_WIDE_INT offset, size, max_size;\n-  bool reverse;\n-  tree base\n-    = get_ref_base_and_extent (**expr, &offset, &size, &max_size, &reverse);\n-  if (!base || size == -1 || max_size == -1)\n-    return NULL;\n-\n-  if (TREE_CODE (base) == MEM_REF)\n-    {\n-      offset += mem_ref_offset (base).to_short_addr () * BITS_PER_UNIT;\n-      base = TREE_OPERAND (base, 0);\n-    }\n-\n-  base = get_ssa_base_param (base, ignore_default_def);\n-  if (!base || TREE_CODE (base) != PARM_DECL)\n-    return NULL;\n-\n-  struct ipa_parm_adjustment *cand = NULL;\n-  unsigned int len = adjustments.length ();\n-  for (unsigned i = 0; i < len; i++)\n-    {\n-      struct ipa_parm_adjustment *adj = &adjustments[i];\n-\n-      if (adj->base == base\n-\t  && (adj->offset == offset || adj->op == IPA_PARM_OP_REMOVE))\n-\t{\n-\t  cand = adj;\n-\t  break;\n-\t}\n-    }\n-\n-  if (!cand || cand->op == IPA_PARM_OP_COPY || cand->op == IPA_PARM_OP_REMOVE)\n-    return NULL;\n-  return cand;\n-}\n-\n-/* Return true iff BASE_INDEX is in ADJUSTMENTS more than once.  */\n-\n-static bool\n-index_in_adjustments_multiple_times_p (int base_index,\n-\t\t\t\t       ipa_parm_adjustment_vec adjustments)\n-{\n-  int i, len = adjustments.length ();\n-  bool one = false;\n-\n-  for (i = 0; i < len; i++)\n-    {\n-      struct ipa_parm_adjustment *adj;\n-      adj = &adjustments[i];\n-\n-      if (adj->base_index == base_index)\n-\t{\n-\t  if (one)\n-\t    return true;\n-\t  else\n-\t    one = true;\n-\t}\n-    }\n-  return false;\n-}\n-\n-\n-/* Return adjustments that should have the same effect on function parameters\n-   and call arguments as if they were first changed according to adjustments in\n-   INNER and then by adjustments in OUTER.  */\n-\n-ipa_parm_adjustment_vec\n-ipa_combine_adjustments (ipa_parm_adjustment_vec inner,\n-\t\t\t ipa_parm_adjustment_vec outer)\n-{\n-  int i, outlen = outer.length ();\n-  int inlen = inner.length ();\n-  int removals = 0;\n-  ipa_parm_adjustment_vec adjustments, tmp;\n-\n-  tmp.create (inlen);\n-  for (i = 0; i < inlen; i++)\n-    {\n-      struct ipa_parm_adjustment *n;\n-      n = &inner[i];\n-\n-      if (n->op == IPA_PARM_OP_REMOVE)\n-\tremovals++;\n-      else\n-\t{\n-\t  /* FIXME: Handling of new arguments are not implemented yet.  */\n-\t  gcc_assert (n->op != IPA_PARM_OP_NEW);\n-\t  tmp.quick_push (*n);\n-\t}\n-    }\n-\n-  adjustments.create (outlen + removals);\n-  for (i = 0; i < outlen; i++)\n-    {\n-      struct ipa_parm_adjustment r;\n-      struct ipa_parm_adjustment *out = &outer[i];\n-      struct ipa_parm_adjustment *in = &tmp[out->base_index];\n-\n-      memset (&r, 0, sizeof (r));\n-      gcc_assert (in->op != IPA_PARM_OP_REMOVE);\n-      if (out->op == IPA_PARM_OP_REMOVE)\n-\t{\n-\t  if (!index_in_adjustments_multiple_times_p (in->base_index, tmp))\n-\t    {\n-\t      r.op = IPA_PARM_OP_REMOVE;\n-\t      adjustments.quick_push (r);\n-\t    }\n-\t  continue;\n-\t}\n-      else\n-\t{\n-\t  /* FIXME: Handling of new arguments are not implemented yet.  */\n-\t  gcc_assert (out->op != IPA_PARM_OP_NEW);\n-\t}\n-\n-      r.base_index = in->base_index;\n-      r.type = out->type;\n-\n-      /* FIXME:  Create nonlocal value too.  */\n-\n-      if (in->op == IPA_PARM_OP_COPY && out->op == IPA_PARM_OP_COPY)\n-\tr.op = IPA_PARM_OP_COPY;\n-      else if (in->op == IPA_PARM_OP_COPY)\n-\tr.offset = out->offset;\n-      else if (out->op == IPA_PARM_OP_COPY)\n-\tr.offset = in->offset;\n-      else\n-\tr.offset = in->offset + out->offset;\n-      adjustments.quick_push (r);\n-    }\n-\n-  for (i = 0; i < inlen; i++)\n-    {\n-      struct ipa_parm_adjustment *n = &inner[i];\n-\n-      if (n->op == IPA_PARM_OP_REMOVE)\n-\tadjustments.quick_push (*n);\n-    }\n-\n-  tmp.release ();\n-  return adjustments;\n-}\n-\n-/* Dump the adjustments in the vector ADJUSTMENTS to dump_file in a human\n-   friendly way, assuming they are meant to be applied to FNDECL.  */\n-\n-void\n-ipa_dump_param_adjustments (FILE *file, ipa_parm_adjustment_vec adjustments,\n-\t\t\t    tree fndecl)\n-{\n-  int i, len = adjustments.length ();\n-  bool first = true;\n-  vec<tree> parms = ipa_get_vector_of_formal_parms (fndecl);\n-\n-  fprintf (file, \"IPA param adjustments: \");\n-  for (i = 0; i < len; i++)\n-    {\n-      struct ipa_parm_adjustment *adj;\n-      adj = &adjustments[i];\n-\n-      if (!first)\n-\tfprintf (file, \"                 \");\n-      else\n-\tfirst = false;\n-\n-      fprintf (file, \"%i. base_index: %i - \", i, adj->base_index);\n-      print_generic_expr (file, parms[adj->base_index]);\n-      if (adj->base)\n-\t{\n-\t  fprintf (file, \", base: \");\n-\t  print_generic_expr (file, adj->base);\n-\t}\n-      if (adj->new_decl)\n-\t{\n-\t  fprintf (file, \", new_decl: \");\n-\t  print_generic_expr (file, adj->new_decl);\n-\t}\n-      if (adj->new_ssa_base)\n-\t{\n-\t  fprintf (file, \", new_ssa_base: \");\n-\t  print_generic_expr (file, adj->new_ssa_base);\n-\t}\n-\n-      if (adj->op == IPA_PARM_OP_COPY)\n-\tfprintf (file, \", copy_param\");\n-      else if (adj->op == IPA_PARM_OP_REMOVE)\n-\tfprintf (file, \", remove_param\");\n-      else\n-\tfprintf (file, \", offset %li\", (long) adj->offset);\n-      if (adj->by_ref)\n-\tfprintf (file, \", by_ref\");\n-      print_node_brief (file, \", type: \", adj->type, 0);\n-      fprintf (file, \"\\n\");\n-    }\n-  parms.release ();\n-}\n-\n /* Dump the AV linked list.  */\n \n void"}, {"sha": "bd8ae3e8daed8b8d77fb6f106d1166194aca9a6b", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d99a8487287e94b9bd42807cbe864991a0d1d3b/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d99a8487287e94b9bd42807cbe864991a0d1d3b/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=4d99a8487287e94b9bd42807cbe864991a0d1d3b", "patch": "@@ -765,96 +765,6 @@ class ipcp_agg_lattice;\n \n extern object_allocator<ipcp_agg_lattice> ipcp_agg_lattice_pool;\n \n-/* Operation to be performed for the parameter in ipa_parm_adjustment\n-   below.  */\n-enum ipa_parm_op {\n-  IPA_PARM_OP_NONE,\n-\n-  /* This describes a brand new parameter.\n-\n-     The field `type' should be set to the new type, `arg_prefix'\n-     should be set to the string prefix for the new DECL_NAME, and\n-     `new_decl' will ultimately hold the newly created argument.  */\n-  IPA_PARM_OP_NEW,\n-\n-  /* This new parameter is an unmodified parameter at index base_index. */\n-  IPA_PARM_OP_COPY,\n-\n-  /* This adjustment describes a parameter that is about to be removed\n-     completely.  Most users will probably need to book keep those so that they\n-     don't leave behinfd any non default def ssa names belonging to them.  */\n-  IPA_PARM_OP_REMOVE\n-};\n-\n-/* Structure to describe transformations of formal parameters and actual\n-   arguments.  Each instance describes one new parameter and they are meant to\n-   be stored in a vector.  Additionally, most users will probably want to store\n-   adjustments about parameters that are being removed altogether so that SSA\n-   names belonging to them can be replaced by SSA names of an artificial\n-   variable.  */\n-struct ipa_parm_adjustment\n-{\n-  /* The original PARM_DECL itself, helpful for processing of the body of the\n-     function itself.  Intended for traversing function bodies.\n-     ipa_modify_formal_parameters, ipa_modify_call_arguments and\n-     ipa_combine_adjustments ignore this and use base_index.\n-     ipa_modify_formal_parameters actually sets this.  */\n-  tree base;\n-\n-  /* Type of the new parameter.  However, if by_ref is true, the real type will\n-     be a pointer to this type.  */\n-  tree type;\n-\n-  /* Alias refrerence type to be used in MEM_REFs when adjusting caller\n-     arguments.  */\n-  tree alias_ptr_type;\n-\n-  /* The new declaration when creating/replacing a parameter.  Created\n-     by ipa_modify_formal_parameters, useful for functions modifying\n-     the body accordingly.  For brand new arguments, this is the newly\n-     created argument.  */\n-  tree new_decl;\n-\n-  /* New declaration of a substitute variable that we may use to replace all\n-     non-default-def ssa names when a parm decl is going away.  */\n-  tree new_ssa_base;\n-\n-  /* If non-NULL and the original parameter is to be removed (copy_param below\n-     is NULL), this is going to be its nonlocalized vars value.  */\n-  tree nonlocal_value;\n-\n-  /* This holds the prefix to be used for the new DECL_NAME.  */\n-  const char *arg_prefix;\n-\n-  /* Offset into the original parameter (for the cases when the new parameter\n-     is a component of an original one).  */\n-  HOST_WIDE_INT offset;\n-\n-  /* Zero based index of the original parameter this one is based on.  */\n-  int base_index;\n-\n-  /* Whether this parameter is a new parameter, a copy of an old one,\n-     or one about to be removed.  */\n-  enum ipa_parm_op op;\n-\n-  /* Storage order of the original parameter (for the cases when the new\n-     parameter is a component of an original one).  */\n-  unsigned reverse : 1;\n-\n-  /* The parameter is to be passed by reference.  */\n-  unsigned by_ref : 1;\n-};\n-\n-typedef vec<ipa_parm_adjustment> ipa_parm_adjustment_vec;\n-\n-vec<tree> ipa_get_vector_of_formal_parms (tree fndecl);\n-vec<tree> ipa_get_vector_of_formal_parm_types (tree fntype);\n-void ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec);\n-void ipa_modify_call_arguments (struct cgraph_edge *, gcall *,\n-\t\t\t\tipa_parm_adjustment_vec);\n-ipa_parm_adjustment_vec ipa_combine_adjustments (ipa_parm_adjustment_vec,\n-\t\t\t\t\t\t ipa_parm_adjustment_vec);\n-void ipa_dump_param_adjustments (FILE *, ipa_parm_adjustment_vec, tree);\n void ipa_dump_agg_replacement_values (FILE *f,\n \t\t\t\t      struct ipa_agg_replacement_value *av);\n void ipa_prop_write_jump_functions (void);\n@@ -870,10 +780,6 @@ ipa_polymorphic_call_context ipa_context_from_jfunc (ipa_node_params *,\n \t\t\t\t\t\t     int,\n \t\t\t\t\t\t     ipa_jump_func *);\n void ipa_dump_param (FILE *, struct ipa_node_params *info, int i);\n-bool ipa_modify_expr (tree *, bool, ipa_parm_adjustment_vec);\n-ipa_parm_adjustment *ipa_get_adjustment_candidate (tree **, bool *,\n-\t\t\t\t\t\t   ipa_parm_adjustment_vec,\n-\t\t\t\t\t\t   bool);\n void ipa_release_body_info (struct ipa_func_body_info *);\n tree ipa_get_callee_param_type (struct cgraph_edge *e, int i);\n "}, {"sha": "b8386037dfd7a3bac5f9a3e1e7d3bc5d24c3ad4a", "filename": "gcc/omp-simd-clone.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d99a8487287e94b9bd42807cbe864991a0d1d3b/gcc%2Fomp-simd-clone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d99a8487287e94b9bd42807cbe864991a0d1d3b/gcc%2Fomp-simd-clone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.c?ref=4d99a8487287e94b9bd42807cbe864991a0d1d3b", "patch": "@@ -45,7 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dfa.h\"\n #include \"cfgloop.h\"\n #include \"symbol-summary.h\"\n-#include \"ipa-prop.h\"\n+#include \"ipa-param-manipulation.h\"\n #include \"tree-eh.h\"\n #include \"varasm.h\"\n #include \"stringpool.h\""}, {"sha": "db490b20c3ed1049380dd3a51555f0de17c3afa3", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d99a8487287e94b9bd42807cbe864991a0d1d3b/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d99a8487287e94b9bd42807cbe864991a0d1d3b/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=4d99a8487287e94b9bd42807cbe864991a0d1d3b", "patch": "@@ -97,6 +97,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dfa.h\"\n #include \"tree-ssa.h\"\n #include \"symbol-summary.h\"\n+#include \"ipa-param-manipulation.h\"\n #include \"ipa-prop.h\"\n #include \"params.h\"\n #include \"dbgcnt.h\""}]}