{"sha": "bd16cb258ee3cf903c488b162b7cd479c12feb7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQxNmNiMjU4ZWUzY2Y5MDNjNDg4YjE2MmI3Y2Q0NzljMTJmZWI3Yw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-07-23T21:28:24Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-07-23T21:28:24Z"}, "message": "re PR c++/11645 (Failure to deal with using and private inheritance)\n\n\tPR c++/11645\n\t* cp-tree.h (accessible_base_p): Declare.\n\t* call.c (build_over_call): Use it.\n\t* search.c (accessible_base_p): New function, split out from ...\n\t(lookup_base): ... here.\n\n\tPR c++/11645\n\t* g++.dg/inherit/access4.C: New test.\n\nFrom-SVN: r69724", "tree": {"sha": "9f2a2970cd70097047c205b2cf2c52e242f3e23d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f2a2970cd70097047c205b2cf2c52e242f3e23d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd16cb258ee3cf903c488b162b7cd479c12feb7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd16cb258ee3cf903c488b162b7cd479c12feb7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd16cb258ee3cf903c488b162b7cd479c12feb7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd16cb258ee3cf903c488b162b7cd479c12feb7c/comments", "author": null, "committer": null, "parents": [{"sha": "ff89cb01b7f1367a71be2b5df30c0768b20b2da8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff89cb01b7f1367a71be2b5df30c0768b20b2da8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff89cb01b7f1367a71be2b5df30c0768b20b2da8"}], "stats": {"total": 80, "additions": 55, "deletions": 25}, "files": [{"sha": "3314b35c1588209b6645bc823dd43e977dbc6c83", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd16cb258ee3cf903c488b162b7cd479c12feb7c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd16cb258ee3cf903c488b162b7cd479c12feb7c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bd16cb258ee3cf903c488b162b7cd479c12feb7c", "patch": "@@ -1,5 +1,11 @@\n 2003-07-23  Mark Mitchell  <mark@codesourcery.com>\n \n+\tPR c++/11645\n+\t* cp-tree.h (accessible_base_p): Declare.\n+\t* call.c (build_over_call): Use it.\n+\t* search.c (accessible_base_p): New function, split out from ...\n+\t(lookup_base): ... here.\n+\n \tPR c++/11517\n \t* call.c (build_conditional_expr): Use perform_implicit_conversion\n \tand error_operand_p.  Robustify."}, {"sha": "11e8d2e0cabdc05690f88fc435a7e9d2d16627dc", "filename": "gcc/cp/call.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd16cb258ee3cf903c488b162b7cd479c12feb7c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd16cb258ee3cf903c488b162b7cd479c12feb7c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=bd16cb258ee3cf903c488b162b7cd479c12feb7c", "patch": "@@ -4414,12 +4414,17 @@ build_over_call (struct z_candidate *cand, int flags)\n \t\t\t\t       TREE_VALUE (arg),\n \t\t\t\t       cand->conversion_path,\n \t\t\t\t       1);\n+      /* Check that the base class is accessible.  */\n+      if (!accessible_base_p (TREE_TYPE (argtype), \n+\t\t\t      BINFO_TYPE (cand->conversion_path)))\n+\terror (\"`%T' is not an accessible base of `%T'\",\n+\t       BINFO_TYPE (cand->conversion_path),\n+\t       TREE_TYPE (argtype));\n       /* If fn was found by a using declaration, the conversion path\n          will be to the derived class, not the base declaring fn. We\n          must convert from derived to base.  */\n       base_binfo = lookup_base (TREE_TYPE (TREE_TYPE (converted_arg)),\n \t\t\t\tTREE_TYPE (parmtype), ba_ignore, NULL);\n-      \n       converted_arg = build_base_path (PLUS_EXPR, converted_arg,\n \t\t\t\t       base_binfo, 1);\n       "}, {"sha": "15bcea07eee7f1281a76803b4556af477708753c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd16cb258ee3cf903c488b162b7cd479c12feb7c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd16cb258ee3cf903c488b162b7cd479c12feb7c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=bd16cb258ee3cf903c488b162b7cd479c12feb7c", "patch": "@@ -4025,6 +4025,7 @@ extern void emit_support_tinfos (void);\n extern bool emit_tinfo_decl (tree);\n \n /* in search.c */\n+extern bool accessible_base_p (tree, tree);\n extern tree lookup_base (tree, tree, base_access, base_kind *);\n extern int types_overlap_p\t\t\t(tree, tree);\n extern tree get_vbase\t\t\t\t(tree, tree);"}, {"sha": "3f8e2daf8a86fbb1fa510bbc6337fec47f178145", "filename": "gcc/cp/search.c", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd16cb258ee3cf903c488b162b7cd479c12feb7c/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd16cb258ee3cf903c488b162b7cd479c12feb7c/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=bd16cb258ee3cf903c488b162b7cd479c12feb7c", "patch": "@@ -231,6 +231,28 @@ lookup_base_r (tree binfo, tree base, base_access access,\n   return found;\n }\n \n+/* Returns true if type BASE is accessible in T.  (BASE is known to be\n+   a base class of T.)  */\n+\n+bool\n+accessible_base_p (tree t, tree base)\n+{\n+  tree decl;\n+\n+  /* [class.access.base]\n+\n+     A base class is said to be accessible if an invented public\n+     member of the base class is accessible.  */\n+  /* Rather than inventing a public member, we use the implicit\n+     public typedef created in the scope of every class.  */\n+  decl = TYPE_FIELDS (base);\n+  while (!DECL_SELF_REFERENCE_P (decl))\n+    decl = TREE_CHAIN (decl);\n+  while (ANON_AGGR_TYPE_P (t))\n+    t = TYPE_CONTEXT (t);\n+  return accessible_p (t, decl);\n+}\n+\n /* Lookup BASE in the hierarchy dominated by T.  Do access checking as\n    ACCESS specifies.  Return the binfo we discover.  If KIND_PTR is\n    non-NULL, fill with information about what kind of base we\n@@ -287,39 +309,24 @@ lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n \tbreak;\n \n       default:\n-\tif (access != ba_ignore\n+\tif ((access & ~ba_quiet) != ba_ignore\n \t    /* If BASE is incomplete, then BASE and TYPE are probably\n \t       the same, in which case BASE is accessible.  If they\n \t       are not the same, then TYPE is invalid.  In that case,\n \t       there's no need to issue another error here, and\n \t       there's no implicit typedef to use in the code that\n \t       follows, so we skip the check.  */\n-\t    && COMPLETE_TYPE_P (base))\n+\t    && COMPLETE_TYPE_P (base)\n+\t    && !accessible_base_p (t, base))\n \t  {\n-\t    tree decl;\n-\n-\t    /* [class.access.base]\n-\n-\t       A base class is said to be accessible if an invented public\n-\t       member of the base class is accessible.  */\n-\t    /* Rather than inventing a public member, we use the implicit\n-\t       public typedef created in the scope of every class.  */\n-\t    decl = TYPE_FIELDS (base);\n-\t    while (!DECL_SELF_REFERENCE_P (decl))\n-\t      decl = TREE_CHAIN (decl);\n-\t    while (ANON_AGGR_TYPE_P (t))\n-\t      t = TYPE_CONTEXT (t);\n-\t    if (!accessible_p (t, decl))\n+\t    if (!(access & ba_quiet))\n \t      {\n-\t\tif (!(access & ba_quiet))\n-\t\t  {\n-\t\t    error (\"`%T' is an inaccessible base of `%T'\", base, t);\n-\t\t    binfo = error_mark_node;\n-\t\t  }\n-\t\telse\n-\t\t  binfo = NULL_TREE;\n-\t\tbk = bk_inaccessible;\n+\t\terror (\"`%T' is an inaccessible base of `%T'\", base, t);\n+\t\tbinfo = error_mark_node;\n \t      }\n+\t    else\n+\t      binfo = NULL_TREE;\n+\t    bk = bk_inaccessible;\n \t  }\n \tbreak;\n       }"}, {"sha": "1e703c101646b20c76e72f39b3697311acd2f7b0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd16cb258ee3cf903c488b162b7cd479c12feb7c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd16cb258ee3cf903c488b162b7cd479c12feb7c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bd16cb258ee3cf903c488b162b7cd479c12feb7c", "patch": "@@ -1,5 +1,8 @@\n 2003-07-23  Mark Mitchell  <mark@codesourcery.com>\n \n+\tPR c++/11645\n+\t* g++.dg/inherit/access4.C: New test.\n+\n \tPR c++/11517\n \t* g++.dg/expr/cond2.C: New test.\n \t"}, {"sha": "33f991b666f79601b40751e35f41951be1a36d2f", "filename": "gcc/testsuite/g++.dg/inherit/access4.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd16cb258ee3cf903c488b162b7cd479c12feb7c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Faccess4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd16cb258ee3cf903c488b162b7cd479c12feb7c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Faccess4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Faccess4.C?ref=bd16cb258ee3cf903c488b162b7cd479c12feb7c", "patch": "@@ -0,0 +1,8 @@\n+struct Container { int Count(); };\n+struct List : private Container {\n+    using Container::Count;\n+};\n+struct INetContentTypeParameterList : private List { void Clear(); };\n+void INetContentTypeParameterList::Clear() {\n+    Count();//Calling non static but in a non-static method.\n+}"}]}