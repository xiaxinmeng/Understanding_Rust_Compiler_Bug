{"sha": "0edf2e81bb02cba43b649b3f6e7258b68a779ac0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVkZjJlODFiYjAyY2JhNDNiNjQ5YjNmNmU3MjU4YjY4YTc3OWFjMA==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2021-08-17T08:47:02Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2021-08-17T19:00:10Z"}, "message": "Turn global 'ggc_force_collect' variable into 'force_collect' parameter to 'ggc_collect'\n\nThis simplifies the interface and gets us rid of a global variable.\nNo change in behavior.\n\nClean-up for 2004-09-02 CVS commit (Subversion r86974,\nGit commit 0772402279c0161fe41784911b52c77e12803c42)\n\"Better memory statistics, take 2\".\n\n\tgcc/\n\t* ggc.h (ggc_collect): Add 'force_collect' parameter.\n\t* ggc-page.c (ggc_collect): Use that one instead of global\n\t'ggc_force_collect'.  Adjust all users.\n\t* doc/gty.texi (Invoking the garbage collector): Update.\n\t* ggc-internal.h (ggc_force_collect): Remove.\n\t* ggc-common.c (ggc_force_collect): Likewise.\n\t* selftest.h (forcibly_ggc_collect): Remove.\n\t* ggc-tests.c (selftest::forcibly_ggc_collect): Likewise.\n\t* read-rtl-function.c (test_loading_labels): Adjust.\n\t* selftest-run-tests.c (run_tests): Likewise.", "tree": {"sha": "5b18e566cc8b9c254b6e1ef74f90575fe49cca0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b18e566cc8b9c254b6e1ef74f90575fe49cca0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0edf2e81bb02cba43b649b3f6e7258b68a779ac0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0edf2e81bb02cba43b649b3f6e7258b68a779ac0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0edf2e81bb02cba43b649b3f6e7258b68a779ac0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0edf2e81bb02cba43b649b3f6e7258b68a779ac0/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a42467bdb70650cd2f421e67b6c3418f74feaec2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a42467bdb70650cd2f421e67b6c3418f74feaec2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a42467bdb70650cd2f421e67b6c3418f74feaec2"}], "stats": {"total": 64, "additions": 22, "deletions": 42}, "files": [{"sha": "b667d1d19ba12b8814ec3e13e3d94f350fb83a46", "filename": "gcc/doc/gty.texi", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0edf2e81bb02cba43b649b3f6e7258b68a779ac0/gcc%2Fdoc%2Fgty.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0edf2e81bb02cba43b649b3f6e7258b68a779ac0/gcc%2Fdoc%2Fgty.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgty.texi?ref=0edf2e81bb02cba43b649b3f6e7258b68a779ac0", "patch": "@@ -654,7 +654,10 @@ The GCC garbage collector GGC is only invoked explicitly. In contrast\n with many other garbage collectors, it is not implicitly invoked by\n allocation routines when a lot of memory has been consumed. So the\n only way to have GGC reclaim storage is to call the @code{ggc_collect}\n-function explicitly.  This call is an expensive operation, as it may\n+function explicitly.\n+When the @var{force_collect} parameter is set or otherwise an internal\n+heuristic decides whether to actually collect, this call is\n+potentially an expensive operation, as it may\n have to scan the entire heap.  Beware that local variables (on the GCC\n call stack) are not followed by such an invocation (as many other\n garbage collectors do): you should reference all your data from static"}, {"sha": "f38e4d5020dca0c1d29863ccfcf91e70f223354f", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0edf2e81bb02cba43b649b3f6e7258b68a779ac0/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0edf2e81bb02cba43b649b3f6e7258b68a779ac0/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=0edf2e81bb02cba43b649b3f6e7258b68a779ac0", "patch": "@@ -31,9 +31,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"plugin.h\"\n #include \"options.h\"\n \n-/* When set, ggc_collect will do collection.  */\n-bool ggc_force_collect;\n-\n /* When true, protect the contents of the identifier hash table.  */\n bool ggc_protect_identifiers = true;\n \n@@ -965,12 +962,9 @@ dump_ggc_loc_statistics ()\n   if (! GATHER_STATISTICS)\n     return;\n \n-  ggc_force_collect = true;\n-  ggc_collect ();\n+  ggc_collect (true);\n \n   ggc_mem_desc.dump (GGC_ORIGIN);\n-\n-  ggc_force_collect = false;\n }\n \n /* Record ALLOCATED and OVERHEAD bytes to descriptor NAME:LINE (FUNCTION).  */"}, {"sha": "4dcfb4c008c113d9ad33e6d98b27e692041daa95", "filename": "gcc/ggc-internal.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0edf2e81bb02cba43b649b3f6e7258b68a779ac0/gcc%2Fggc-internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0edf2e81bb02cba43b649b3f6e7258b68a779ac0/gcc%2Fggc-internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-internal.h?ref=0edf2e81bb02cba43b649b3f6e7258b68a779ac0", "patch": "@@ -88,9 +88,6 @@ extern void ggc_pch_read (FILE *, void *);\n \n /* Allocation and collection.  */\n \n-/* When set, ggc_collect will do collection.  */\n-extern bool ggc_force_collect;\n-\n extern void ggc_record_overhead (size_t, size_t, void * FINAL_MEM_STAT_DECL);\n \n extern void ggc_free_overhead (void *);"}, {"sha": "a6fbecaa1d84c45713ed008f677ca9125aad9930", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0edf2e81bb02cba43b649b3f6e7258b68a779ac0/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0edf2e81bb02cba43b649b3f6e7258b68a779ac0/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=0edf2e81bb02cba43b649b3f6e7258b68a779ac0", "patch": "@@ -2184,7 +2184,7 @@ validate_free_objects (void)\n /* Top level mark-and-sweep routine.  */\n \n void\n-ggc_collect (void)\n+ggc_collect (bool force_collect)\n {\n   /* Avoid frequent unnecessary work by skipping collection if the\n      total allocations haven't expanded much since the last\n@@ -2196,7 +2196,7 @@ ggc_collect (void)\n   memory_block_pool::trim ();\n \n   float min_expand = allocated_last_gc * param_ggc_min_expand / 100;\n-  if (G.allocated < allocated_last_gc + min_expand && !ggc_force_collect)\n+  if (G.allocated < allocated_last_gc + min_expand && !force_collect)\n     return;\n \n   timevar_push (TV_GC);"}, {"sha": "2891c20ceac22a03b2042422894560a0ccfa375c", "filename": "gcc/ggc-tests.c", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0edf2e81bb02cba43b649b3f6e7258b68a779ac0/gcc%2Fggc-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0edf2e81bb02cba43b649b3f6e7258b68a779ac0/gcc%2Fggc-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-tests.c?ref=0edf2e81bb02cba43b649b3f6e7258b68a779ac0", "patch": "@@ -22,21 +22,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tree-core.h\"\n #include \"tree.h\"\n-#include \"ggc-internal.h\" /* (for ggc_force_collect).  */\n #include \"selftest.h\"\n \n #if CHECKING_P\n \n-/* A helper function for writing ggc tests.  */\n-\n-void\n-selftest::forcibly_ggc_collect ()\n-{\n-  ggc_force_collect = true;\n-  ggc_collect ();\n-  ggc_force_collect = false;\n-}\n-\n /* The various GTY markers must be outside of a namespace to be seen by\n    gengtype, so we don't put this file within the selftest namespace.  */\n \n@@ -58,7 +47,7 @@ test_basic_struct ()\n   root_test_struct = ggc_cleared_alloc <test_struct> ();\n   root_test_struct->other = ggc_cleared_alloc <test_struct> ();\n \n-  selftest::forcibly_ggc_collect ();\n+  ggc_collect (true);\n \n   ASSERT_TRUE (ggc_marked_p (root_test_struct));\n   ASSERT_TRUE (ggc_marked_p (root_test_struct->other));\n@@ -88,7 +77,7 @@ test_length ()\n   for (int i = 0; i < count; i++)\n     root_test_of_length->elem[i] = ggc_cleared_alloc <test_of_length> ();\n \n-  selftest::forcibly_ggc_collect ();\n+  ggc_collect (true);\n \n   ASSERT_TRUE (ggc_marked_p (root_test_of_length));\n   for (int i = 0; i < count; i++)\n@@ -162,7 +151,7 @@ test_union ()\n   test_struct *referenced_by_other = ggc_cleared_alloc <test_struct> ();\n   other->m_ptr = referenced_by_other;\n \n-  selftest::forcibly_ggc_collect ();\n+  ggc_collect (true);\n \n   ASSERT_TRUE (ggc_marked_p (root_test_of_union_1));\n   ASSERT_TRUE (ggc_marked_p (ts));\n@@ -203,7 +192,7 @@ test_finalization ()\n \n   test_struct_with_dtor::dtor_call_count = 0;\n \n-  selftest::forcibly_ggc_collect ();\n+  ggc_collect (true);\n \n   /* Verify that the destructor was run for each instance.  */\n   ASSERT_EQ (count, test_struct_with_dtor::dtor_call_count);\n@@ -221,7 +210,7 @@ test_deletable_global ()\n   test_of_deletable = ggc_cleared_alloc <test_struct> ();\n   ASSERT_TRUE (test_of_deletable != NULL);\n \n-  selftest::forcibly_ggc_collect ();\n+  ggc_collect (true);\n \n   ASSERT_EQ (NULL, test_of_deletable);\n }\n@@ -294,7 +283,7 @@ test_inheritance ()\n   test_some_subclass_as_base_ptr = new some_subclass ();\n   test_some_other_subclass_as_base_ptr = new some_other_subclass ();\n \n-  selftest::forcibly_ggc_collect ();\n+  ggc_collect (true);\n \n   /* Verify that the roots and everything referenced by them got marked\n      (both for fields in the base class and those in subclasses).  */\n@@ -373,7 +362,7 @@ test_chain_next ()\n       tail_node = new_node;\n     }\n \n-  selftest::forcibly_ggc_collect ();\n+  ggc_collect (true);\n \n   /* If we got here, we survived.  */\n \n@@ -440,7 +429,7 @@ test_user_struct ()\n \n   num_calls_to_user_gt_ggc_mx = 0;\n \n-  selftest::forcibly_ggc_collect ();\n+  ggc_collect (true);\n \n   ASSERT_TRUE (ggc_marked_p (root_user_struct_ptr));\n   ASSERT_TRUE (ggc_marked_p (referenced));\n@@ -458,7 +447,7 @@ test_tree_marking ()\n {\n   dummy_unittesting_tree = build_int_cst (integer_type_node, 1066);\n \n-  selftest::forcibly_ggc_collect ();\n+  ggc_collect (true);\n \n   ASSERT_TRUE (ggc_marked_p (dummy_unittesting_tree));\n }"}, {"sha": "0f640b255e8ee5dbad623dd6ea19c0bf6a17a536", "filename": "gcc/ggc.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0edf2e81bb02cba43b649b3f6e7258b68a779ac0/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0edf2e81bb02cba43b649b3f6e7258b68a779ac0/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=0edf2e81bb02cba43b649b3f6e7258b68a779ac0", "patch": "@@ -262,8 +262,10 @@ extern const char *ggc_alloc_string (const char *contents, int length\n #define ggc_strdup(S) ggc_alloc_string ((S), -1 MEM_STAT_INFO)\n \n /* Invoke the collector.  Garbage collection occurs only when this\n-   function is called, not during allocations.  */\n-extern void ggc_collect\t(void);\n+   function is called, not during allocations.\n+   Unless FORCE_COLLECT, an internal heuristic decides whether to actually\n+   collect.  */\n+extern void ggc_collect (bool force_collect = false);\n \n /* Return unused memory pages to the system.  */\n extern void ggc_trim (void);"}, {"sha": "0badfb98f9d8643c20a1b5b0db8823e0d9a81e17", "filename": "gcc/read-rtl-function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0edf2e81bb02cba43b649b3f6e7258b68a779ac0/gcc%2Fread-rtl-function.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0edf2e81bb02cba43b649b3f6e7258b68a779ac0/gcc%2Fread-rtl-function.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl-function.c?ref=0edf2e81bb02cba43b649b3f6e7258b68a779ac0", "patch": "@@ -1861,7 +1861,7 @@ test_loading_labels ()\n \n   /* Ensure that label names read from a dump are GC-managed\n      and are found through the insn.  */\n-  forcibly_ggc_collect ();\n+  ggc_collect (true);\n   ASSERT_TRUE (ggc_marked_p (insn_200));\n   ASSERT_TRUE (ggc_marked_p (LABEL_NAME (insn_200)));\n }"}, {"sha": "10881fce2301d5cd844ec42c1c72a0bb18673928", "filename": "gcc/selftest-run-tests.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0edf2e81bb02cba43b649b3f6e7258b68a779ac0/gcc%2Fselftest-run-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0edf2e81bb02cba43b649b3f6e7258b68a779ac0/gcc%2Fselftest-run-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-run-tests.c?ref=0edf2e81bb02cba43b649b3f6e7258b68a779ac0", "patch": "@@ -128,7 +128,7 @@ selftest::run_tests ()\n      issues.  For example, if any GC-managed items have buggy (or missing)\n      finalizers, this last collection will ensure that things that were\n      failed to be finalized can be detected by valgrind.  */\n-  forcibly_ggc_collect ();\n+  ggc_collect (true);\n \n   /* Finished running tests; the test_runner dtor will print a summary.  */\n }"}, {"sha": "58d8d383cee31507f409d8c982769db36e7864f4", "filename": "gcc/selftest.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0edf2e81bb02cba43b649b3f6e7258b68a779ac0/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0edf2e81bb02cba43b649b3f6e7258b68a779ac0/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=0edf2e81bb02cba43b649b3f6e7258b68a779ac0", "patch": "@@ -190,11 +190,6 @@ for_each_line_table_case (void (*testcase) (const line_table_case &));\n \n extern char *read_file (const location &loc, const char *path);\n \n-/* A helper function for writing tests that interact with the\n-   garbage collector.  */\n-\n-extern void forcibly_ggc_collect ();\n-\n /* Convert a path relative to SRCDIR/gcc/testsuite/selftests\n    to a real path (either absolute, or relative to pwd).\n    The result should be freed by the caller.  */"}]}