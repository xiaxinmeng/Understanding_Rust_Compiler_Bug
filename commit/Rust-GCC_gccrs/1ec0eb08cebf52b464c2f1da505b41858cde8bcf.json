{"sha": "1ec0eb08cebf52b464c2f1da505b41858cde8bcf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVjMGViMDhjZWJmNTJiNDY0YzJmMWRhNTA1YjQxODU4Y2RlOGJjZg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2018-06-27T18:31:10Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-06-27T18:31:10Z"}, "message": "v850-protos.h (notice_update_cc): Remove.\n\n\t* config/v850/v850-protos.h (notice_update_cc): Remove.\n\t* config/v850/v850.c (v850_compare_op0, v850_compare_op1): Remove.\n\t(v850_print_operand): Handle 'D' and \"d\".\n\t(v850_select_cc_mode): Remove ATTRIBUTE_UNUSED for last argument.\n\tAdd handling of arithmetic/logical operations compared against zero.\n\t(v850_gen_float_compare): Remove ATTRIBUTE_UNUSED for last argument.\n\tDo not look at v850_compare_op, instead get mode from last argument.\n\t(v850_gen_compare): Remove\n\t(increment_stack): Use addsi3_clobber_flags to avoid splitting failure\n\tafter reload for prologue insns.\n\t(expand_prologue): Account for CLOBBER of CC_REGNUM in various\n\tpatterns.\n\t(construct_save_jarl): Likewise.\n\t(TARGET_FLAGS_REGNUM): Define.\n\t* config/v850/v850.h (v850_compare_op0, v850_compare_op1): Remove.\n\t(NOTICE_UPDATE_CC): Remove.\n\t* config/v850/v850.md (v850_tst1): Use (reg:CCZ CC_REGNUM) rather\n\tthan cc0.  Conditionalize on reload_completed.\n\t(cmpsi_insn, setfcc_insn): Likewise.\n\t(tst1 splitter): Turn into define_and_split which sets the flags\n\tafter reload.\n\t(cstoresi4, cbranchsf4, cbranchdf4, cbranchsi4_insn): Likewise.\n\t(cbranchsi4, branch_normal, branch_invert): Do not expose cc0 here.\n\t(cstoresf4, cstoredf4): Clobber the flags.\n\t(cmpsi, cmpsf, cmpdf): Remove expanders.\n\t(setf_insn): Remove pattern.\n\t(addsi3): Turn into define_and_split which clobbers the flags after\n\treload and a suitable pattern (addsi3_clobber_flags) for use after\n\treload.\n\t(subsi3, negsi2, andsi3, iorsi3, xorsi3, one_cmplsi2) Likewise.\n\t(ashlsi3, ashlsi3_v850e2, lshrsi3, lsh4si3_v850e2): Likewise.\n\t(ashrsi3, ashrsi3_v850e2): Likewise.\n\t(bins): Clobber the flags.\n\t(movsicc_normal_cc, movsicc_normal, movsicc_tst1): Likewise.\n\t(movsicc_tst1_revesed, sasf, swap and rotate patterns): Likewise.\n\t(fix_loop_counter, call_internal_short, call_internal_long): Likewise.\n\t(call_value_internal_short, call_value_internal_long): Likewise.\n\t(callt_save_interrupt, callt_return_interrupt): Likewise.\n\t(save_interrupt, return_interrupt): Likewise.\n\t(callt_save_all_interrupt, save_all_interrupt): Likewise.\n\t(_save_all_interrupt, callt_restore_all_interrupt): Likewise.\n\t(restore_all_interrupt, _restore_all_interrupt): Likewise.\n\t(All FP comparisons): Only allow after reload has completed.\n\t(trfsr): Likewise.\n\t(divh, divhu): Tweak output template.\n\t(branch_z_normal, branch_z_invert): Remove\n\t(branch_nz_normal, branch_nz_invert): Likewise.\n\t(extendhisi_insn, extendqisi_insn): Do not clobber flags.\n\nCo-Authored-By: Austin Law <austinklaw@gmail.com>\n\nFrom-SVN: r262190", "tree": {"sha": "d75e64d92f0d5bdb5a96609f7e5e6bcdd2a49952", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d75e64d92f0d5bdb5a96609f7e5e6bcdd2a49952"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ec0eb08cebf52b464c2f1da505b41858cde8bcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ec0eb08cebf52b464c2f1da505b41858cde8bcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ec0eb08cebf52b464c2f1da505b41858cde8bcf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ec0eb08cebf52b464c2f1da505b41858cde8bcf/comments", "author": null, "committer": null, "parents": [{"sha": "03e32fb74897185119352fa2340782b6d7510024", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03e32fb74897185119352fa2340782b6d7510024", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03e32fb74897185119352fa2340782b6d7510024"}], "stats": {"total": 829, "additions": 493, "deletions": 336}, "files": [{"sha": "9cd59b2723659ee5e758b97699093be09409fbe7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ec0eb08cebf52b464c2f1da505b41858cde8bcf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ec0eb08cebf52b464c2f1da505b41858cde8bcf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ec0eb08cebf52b464c2f1da505b41858cde8bcf", "patch": "@@ -1,6 +1,55 @@\n 2018-06-27  Jeff Law  <law@redhat.com>\n \t    Austin Law  <austinklaw@gmail.com>\n \n+\t* config/v850/v850-protos.h (notice_update_cc): Remove.\n+\t* config/v850/v850.c (v850_compare_op0, v850_compare_op1): Remove.\n+\t(v850_print_operand): Handle 'D' and \"d\".\n+\t(v850_select_cc_mode): Remove ATTRIBUTE_UNUSED for last argument.\n+\tAdd handling of arithmetic/logical operations compared against zero.\n+\t(v850_gen_float_compare): Remove ATTRIBUTE_UNUSED for last argument.\n+\tDo not look at v850_compare_op, instead get mode from last argument.\n+\t(v850_gen_compare): Remove\n+\t(increment_stack): Use addsi3_clobber_flags to avoid splitting failure\n+\tafter reload for prologue insns.\n+\t(expand_prologue): Account for CLOBBER of CC_REGNUM in various\n+\tpatterns.\n+\t(construct_save_jarl): Likewise.\n+\t(TARGET_FLAGS_REGNUM): Define.\n+\t* config/v850/v850.h (v850_compare_op0, v850_compare_op1): Remove.\n+\t(NOTICE_UPDATE_CC): Remove.\n+\t* config/v850/v850.md (v850_tst1): Use (reg:CCZ CC_REGNUM) rather\n+\tthan cc0.  Conditionalize on reload_completed.\n+\t(cmpsi_insn, setfcc_insn): Likewise.\n+\t(tst1 splitter): Turn into define_and_split which sets the flags\n+\tafter reload.\n+\t(cstoresi4, cbranchsf4, cbranchdf4, cbranchsi4_insn): Likewise.\n+\t(cbranchsi4, branch_normal, branch_invert): Do not expose cc0 here.\n+\t(cstoresf4, cstoredf4): Clobber the flags.\n+\t(cmpsi, cmpsf, cmpdf): Remove expanders.\n+\t(setf_insn): Remove pattern.\n+\t(addsi3): Turn into define_and_split which clobbers the flags after\n+\treload and a suitable pattern (addsi3_clobber_flags) for use after\n+\treload.\n+\t(subsi3, negsi2, andsi3, iorsi3, xorsi3, one_cmplsi2) Likewise.\n+\t(ashlsi3, ashlsi3_v850e2, lshrsi3, lsh4si3_v850e2): Likewise.\n+\t(ashrsi3, ashrsi3_v850e2): Likewise.\n+\t(bins): Clobber the flags.\n+\t(movsicc_normal_cc, movsicc_normal, movsicc_tst1): Likewise.\n+\t(movsicc_tst1_revesed, sasf, swap and rotate patterns): Likewise.\n+\t(fix_loop_counter, call_internal_short, call_internal_long): Likewise.\n+\t(call_value_internal_short, call_value_internal_long): Likewise.\n+\t(callt_save_interrupt, callt_return_interrupt): Likewise.\n+\t(save_interrupt, return_interrupt): Likewise.\n+\t(callt_save_all_interrupt, save_all_interrupt): Likewise.\n+\t(_save_all_interrupt, callt_restore_all_interrupt): Likewise.\n+\t(restore_all_interrupt, _restore_all_interrupt): Likewise.\n+\t(All FP comparisons): Only allow after reload has completed.\n+\t(trfsr): Likewise.\n+\t(divh, divhu): Tweak output template.\n+\t(branch_z_normal, branch_z_invert): Remove\n+\t(branch_nz_normal, branch_nz_invert): Likewise.\n+\t(extendhisi_insn, extendqisi_insn): Do not clobber flags.\n+\n \t* config/v850/v850-modes.def (CCZ, CCNZ): Add new modes.\n \t* config/v850/v850.c (notice_update_cc): Remove.\n \t* config/v850/v850.h  (CC_OVERFLOW_UNUSABLE): Remove"}, {"sha": "ca99703248b65e171c01668ccbdfa78cd538126e", "filename": "gcc/config/v850/v850-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ec0eb08cebf52b464c2f1da505b41858cde8bcf/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ec0eb08cebf52b464c2f1da505b41858cde8bcf/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850-protos.h?ref=1ec0eb08cebf52b464c2f1da505b41858cde8bcf", "patch": "@@ -32,7 +32,6 @@ extern void   v850_init_expanders           (void);\n #ifdef RTX_CODE\n extern rtx    v850_return_addr              (int);\n extern const char *output_move_single       (rtx *);\n-extern void   notice_update_cc              (rtx, rtx_insn *);\n extern char * construct_save_jarl           (rtx);\n extern char * construct_restore_jr          (rtx);\n #ifdef HAVE_MACHINE_MODES"}, {"sha": "cb2debf46f17b6a74011e2ed756c21d7466e08c8", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ec0eb08cebf52b464c2f1da505b41858cde8bcf/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ec0eb08cebf52b464c2f1da505b41858cde8bcf/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=1ec0eb08cebf52b464c2f1da505b41858cde8bcf", "patch": "@@ -68,8 +68,6 @@ data_area_stack_element * data_area_stack = NULL;\n    function is an interrupt handler.  */\n static int v850_interrupt_cache_p = FALSE;\n \n-rtx v850_compare_op0, v850_compare_op1;\n-\n /* Whether current function is an interrupt handler.  */\n static int v850_interrupt_p = FALSE;\n \n@@ -418,7 +416,9 @@ v850_print_operand (FILE * file, rtx x, int code)\n     case 'b':\n     case 'B':\n     case 'C':\n-      switch ((code == 'B' || code == 'C')\n+    case 'd':\n+    case 'D':\n+      switch ((code == 'B' || code == 'C' || code == 'D')\n \t      ? reverse_condition (GET_CODE (x)) : GET_CODE (x))\n \t{\n \t  case NE:\n@@ -434,7 +434,10 @@ v850_print_operand (FILE * file, rtx x, int code)\n \t      fprintf (file, \"e\");\n \t    break;\n \t  case GE:\n-\t    fprintf (file, \"ge\");\n+\t    if (code == 'D' || code == 'd')\n+\t      fprintf (file, \"p\");\n+\t    else\n+\t      fprintf (file, \"ge\");\n \t    break;\n \t  case GT:\n \t    fprintf (file, \"gt\");\n@@ -443,7 +446,10 @@ v850_print_operand (FILE * file, rtx x, int code)\n \t    fprintf (file, \"le\");\n \t    break;\n \t  case LT:\n-\t    fprintf (file, \"lt\");\n+\t    if (code == 'D' || code == 'd')\n+\t      fprintf (file, \"n\");\n+\t    else\n+\t      fprintf (file, \"lt\");\n \t    break;\n \t  case GEU:\n \t    fprintf (file, \"nl\");\n@@ -905,7 +911,7 @@ output_move_single (rtx * operands)\n }\n \n machine_mode\n-v850_select_cc_mode (enum rtx_code cond, rtx op0, rtx op1 ATTRIBUTE_UNUSED)\n+v850_select_cc_mode (enum rtx_code cond, rtx op0, rtx op1)\n {\n   if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_FLOAT)\n     {\n@@ -927,11 +933,20 @@ v850_select_cc_mode (enum rtx_code cond, rtx op0, rtx op1 ATTRIBUTE_UNUSED)\n \t  gcc_unreachable ();\n \t}\n     }\n+\n+  if (op1 == const0_rtx\n+      && (cond == EQ || cond == NE || cond == LT || cond == GE)\n+      && (GET_CODE (op0) == PLUS || GET_CODE (op0) == MINUS\n+\t  || GET_CODE (op0) == NEG || GET_CODE (op0) == AND\n+\t  || GET_CODE (op0) == IOR || GET_CODE (op0) == XOR\n+\t  || GET_CODE (op0) == NOT || GET_CODE (op0) == ASHIFT))\n+    return CCNZmode;\n+\n   return CCmode;\n }\n \n machine_mode\n-v850_gen_float_compare (enum rtx_code cond, machine_mode mode ATTRIBUTE_UNUSED, rtx op0, rtx op1)\n+v850_gen_float_compare (enum rtx_code cond, machine_mode mode, rtx op0, rtx op1)\n {\n   if (GET_MODE (op0) == DFmode)\n     {\n@@ -960,7 +975,7 @@ v850_gen_float_compare (enum rtx_code cond, machine_mode mode ATTRIBUTE_UNUSED,\n \t  gcc_unreachable ();\n \t}\n     }\n-  else if (GET_MODE (v850_compare_op0) == SFmode)\n+  else if (mode == SFmode)\n     {\n       switch (cond)\n \t{\n@@ -993,25 +1008,6 @@ v850_gen_float_compare (enum rtx_code cond, machine_mode mode ATTRIBUTE_UNUSED,\n   return v850_select_cc_mode (cond, op0, op1);\n }\n \n-rtx\n-v850_gen_compare (enum rtx_code cond, machine_mode mode, rtx op0, rtx op1)\n-{\n-  if (GET_MODE_CLASS(GET_MODE (op0)) != MODE_FLOAT)\n-    {\n-      emit_insn (gen_cmpsi_insn (op0, op1));\n-      return gen_rtx_fmt_ee (cond, mode, gen_rtx_REG(CCmode, CC_REGNUM), const0_rtx);\n-    }\n-  else\n-    {\n-      rtx cc_reg;\n-      mode = v850_gen_float_compare (cond, mode, op0, op1);\n-      cc_reg = gen_rtx_REG (mode, CC_REGNUM);\n-      emit_insn (gen_rtx_SET (cc_reg, gen_rtx_REG (mode, FCC_REGNUM)));\n-\n-      return gen_rtx_fmt_ee (cond, mode, cc_reg, const0_rtx);\n-    }\n-}\n-\n /* Return maximum offset supported for a short EP memory reference of mode\n    MODE and signedness UNSIGNEDP.  */\n \n@@ -1635,7 +1631,7 @@ increment_stack (signed int amount, bool in_prologue)\n       inc = reg;\n     }\n \n-  inc = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, inc));\n+  inc = emit_insn (gen_addsi3_clobber_flags (stack_pointer_rtx, stack_pointer_rtx, inc));\n   if (in_prologue)\n     F (inc);\n }\n@@ -1712,7 +1708,7 @@ expand_prologue (void)\n \n \t  save_all = gen_rtx_PARALLEL\n \t    (VOIDmode,\n-\t     rtvec_alloc (num_save + 1\n+\t     rtvec_alloc (num_save + 2\n \t\t\t  + (TARGET_DISABLE_CALLT ? (TARGET_LONG_CALLS ? 2 : 1) : 0)));\n \n \t  XVECEXP (save_all, 0, 0)\n@@ -1731,13 +1727,16 @@ expand_prologue (void)\n \t\t\t       save_regs[i]);\n \t    }\n \n+\t  XVECEXP (save_all, 0, num_save + 1)\n+\t    = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, CC_REGNUM));\n+\n \t  if (TARGET_DISABLE_CALLT)\n \t    {\n-\t      XVECEXP (save_all, 0, num_save + 1)\n+\t      XVECEXP (save_all, 0, num_save + 2)\n \t\t= gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 10));\n \n \t      if (TARGET_LONG_CALLS)\n-\t\tXVECEXP (save_all, 0, num_save + 2)\n+\t\tXVECEXP (save_all, 0, num_save + 3)\n \t\t  = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 11));\n \t    }\n \n@@ -2330,7 +2329,7 @@ construct_save_jarl (rtx op)\n   stack_bytes = INTVAL (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 1));\n \n   /* Each push will put 4 bytes from the stack....  */\n-  stack_bytes += (count - (TARGET_LONG_CALLS ? 3 : 2)) * 4;\n+  stack_bytes += (count - (TARGET_LONG_CALLS ? 4 : 3)) * 4;\n \n   /* Make sure that the amount we are popping either 0 or 16 bytes.  */\n   if (stack_bytes != 0)\n@@ -2341,7 +2340,7 @@ construct_save_jarl (rtx op)\n \n   /* Now compute the bit mask of registers to push.  */\n   mask = 0;\n-  for (i = 1; i < count - (TARGET_LONG_CALLS ? 2 : 1); i++)\n+  for (i = 1; i < count - (TARGET_LONG_CALLS ? 3 : 2); i++)\n     {\n       rtx vector_element = XVECEXP (op, 0, i);\n       \n@@ -3325,6 +3324,9 @@ v850_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n #undef  TARGET_MODES_TIEABLE_P\n #define TARGET_MODES_TIEABLE_P v850_modes_tieable_p\n \n+#undef TARGET_FLAGS_REGNUM\n+#define TARGET_FLAGS_REGNUM 32\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-v850.h\""}, {"sha": "04d226a8e05d823c44971c3e8b212e947feb977a", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ec0eb08cebf52b464c2f1da505b41858cde8bcf/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ec0eb08cebf52b464c2f1da505b41858cde8bcf/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=1ec0eb08cebf52b464c2f1da505b41858cde8bcf", "patch": "@@ -26,9 +26,6 @@\n #ifndef GCC_V850_H\n #define GCC_V850_H\n \n-extern GTY(()) rtx v850_compare_op0;\n-extern GTY(()) rtx v850_compare_op1;\n-\n #undef LIB_SPEC\n #define LIB_SPEC \"%{!shared:%{!symbolic:--start-group -lc -lgcc --end-group}}\"\n \n@@ -567,8 +564,6 @@ struct cum_arg { int nbytes; };\n \n #define SELECT_CC_MODE(OP, X, Y)       v850_select_cc_mode (OP, X, Y)\n \n-#define NOTICE_UPDATE_CC(EXP, INSN)\n-\n /* Nonzero if access to memory by bytes or half words is no faster\n    than accessing full words.  */\n #define SLOW_BYTE_ACCESS 1"}, {"sha": "3cfec74324f6c985aa4129a57b1e3e6ce3afb435", "filename": "gcc/config/v850/v850.md", "status": "modified", "additions": 409, "deletions": 297, "changes": 706, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ec0eb08cebf52b464c2f1da505b41858cde8bcf/gcc%2Fconfig%2Fv850%2Fv850.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ec0eb08cebf52b464c2f1da505b41858cde8bcf/gcc%2Fconfig%2Fv850%2Fv850.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.md?ref=1ec0eb08cebf52b464c2f1da505b41858cde8bcf", "patch": "@@ -28,6 +28,42 @@\n ;;\n ;; One day we'll probably need to handle calls to targets more than 4M\n ;; away.\n+;;\n+\n+;; Condition codes\n+;;\n+;; Data movement (load, store, register copy) does not modify condition\n+;; codes.  But there is no way to add two registers together without\n+;; modifying the condition codes.\n+;;\n+;; So we do not expose the condition codes until after reload.  The\n+;; general approach is to have a define_insn_and_split for the basic\n+;; operation with no condition codes in the pattern (to give the\n+;; optimizers maximal freedom).  The splitter adds a clobber of the\n+;; condition codes after reload.  There is a distinct pattern which\n+;; sets the condition codes.\n+;;\n+;; As noted, data movement does not affect condition codes.\n+;;\n+;; Arithmetic generally set the codes in the expected ways, with mul\n+;; instructions being a notable outlier.  div instructions generally\n+;; do the right thing, except when the output registers are the same\n+;; when the flags do not get set.  We just assume they're clobbered\n+;; for div instructions to avoid MD bloat with marginal benefit\n+;;\n+;; The bit manipulation instructions (clr1, not1, set1) set condition\n+;; codes, but not in a useful way (they're set to the prior status of\n+;; the bit).  So we just model those as clobbers.  tst1 does set the\n+;; condition codes in a useful way.  We could perhaps do better with\n+;; these by noting they only modify the Z flag, it doesn't seem worth\n+;; the effort.\n+;;\n+;; Byte swaps seem to change the condition codes, but I haven't tried\n+;; to describe how.\n+;;\n+;; I have no documentation on the rotate instructions.  They likely\n+;; set the condition codes, but I've left them as clobbers for now.\n+\n \n ;; The size of instructions in bytes.\n \n@@ -352,110 +388,90 @@\n ;; ----------------------------------------------------------------------\n \n (define_insn \"*v850_tst1\"\n-  [(set (cc0)\n+  [(set (reg:CCZ CC_REGNUM)\n \t(compare (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"m\")\n                                   (const_int 1)\n                                   (match_operand:QI 1 \"const_int_operand\" \"n\"))\n \t\t (const_int 0)))]\n-  \"\"\n+  \"reload_completed\"\n   \"tst1 %1,%0\"\n   [(set_attr \"length\" \"4\")])\n \n ;; This replaces ld.b;sar;andi with tst1;setf nz.\n+;; Should there be variants for HI or SI modes?\n \n-(define_split\n+(define_insn_and_split \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(compare (zero_extract:SI (match_operand:QI 1 \"memory_operand\" \"\")\n \t\t\t\t  (const_int 1)\n \t\t\t\t  (match_operand 2 \"const_int_operand\" \"\"))\n \t\t (const_int 0)))]\n   \"\"\n-  [(set (cc0) (compare (zero_extract:SI (match_dup 1)\n-\t\t\t\t        (const_int 1)\n-\t\t\t\t        (match_dup 2))\n-\t\t       (const_int 0)))\n-   (set (match_dup 0) (ne:SI (cc0) (const_int 0)))])\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (reg:CCZ CC_REGNUM) (compare (zero_extract:SI (match_dup 1)\n+\t\t\t\t\t\t      (const_int 1)\n+\t\t\t\t\t\t      (match_dup 2))\n+\t\t\t\t     (const_int 0)))\n+   (set (match_dup 0) (ne:SI (reg:CCZ CC_REGNUM) (const_int 0)))])\n \n (define_expand \"cbranchsi4\"\n-  [(set (cc0)\n-\t(compare (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t (match_operand:SI 2 \"reg_or_int5_operand\" \"\")))\n-   (set (pc)\n+  [(set (pc)\n \t(if_then_else\n-\t      (match_operator 0 \"ordered_comparison_operator\" [(cc0)\n-\t\t\t\t\t\t\t       (const_int 0)])\n+\t      (match_operator 0 \"comparison_operator\"\n+\t        [(match_operand:SI 1 \"register_operand\")\n+\t\t (match_operand:SI 2 \"reg_or_int5_operand\")])\n               (label_ref (match_operand 3 \"\" \"\"))\n               (pc)))]\n  \"\")\n \n-(define_expand \"cstoresi4\"\n-  [(set (cc0)\n-\t(compare (match_operand:SI 2 \"register_operand\" \"\")\n-\t\t (match_operand:SI 3 \"reg_or_int5_operand\" \"\")))\n-   (set (match_operand:SI 0 \"register_operand\")\n-        (match_operator:SI 1 \"ordered_comparison_operator\" [(cc0)\n-\t\t\t\t\t\t\t    (const_int 0)]))]\n-  \"\")\n-\n-(define_expand \"cmpsi\"\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"r,r\")\n-\t\t (match_operand:SI 1 \"reg_or_int5_operand\" \"r,J\")))]\n-   \"\"\n-  {\n-    v850_compare_op0 = operands[0];\n-    v850_compare_op1 = operands[1];\n-    DONE;\n-  })\n-\n (define_insn \"cmpsi_insn\"\n-  [(set (cc0)\n+  [(set (reg:CC CC_REGNUM)\n \t(compare (match_operand:SI 0 \"register_operand\" \"r,r\")\n \t\t (match_operand:SI 1 \"reg_or_int5_operand\" \"r,J\")))]\n-  \"\"\n-  \"@\n-  cmp %1,%0\n-  cmp %1,%0\"\n+  \"reload_completed\"\n+  \"cmp %1,%0\"\n   [(set_attr \"length\" \"2,2\")])\n \n-(define_expand \"cbranchsf4\"\n+(define_insn_and_split \"cbranchsf4\"\n   [(set (pc)\n        (if_then_else (match_operator     0 \"ordered_comparison_operator\"\n-                      [(match_operand:SF 1 \"register_operand\")\n-                       (match_operand:SF 2 \"register_operand\")])\n+                      [(match_operand:SF 1 \"register_operand\" \"r\")\n+                       (match_operand:SF 2 \"register_operand\" \"r\")])\n                      (label_ref (match_operand 3 \"\"))\n-                     (pc)))\n-  (clobber (cc0))]\n+                     (pc)))]\n   \"TARGET_USE_FPU\"\n-{\n-  enum rtx_code cond = GET_CODE (operands[0]);\n-  machine_mode mode;\n-  rtx fcc_reg;\n-  rtx cc_reg;\n-  rtx tmp;\n-\n-  v850_compare_op0 = operands[1];\n-  v850_compare_op1 = operands[2];\n-\n-  if (GET_MODE_CLASS (GET_MODE (v850_compare_op0)) != MODE_FLOAT)\n-    FAIL;\n-\n-  mode = v850_gen_float_compare (cond, VOIDmode, v850_compare_op0, v850_compare_op1);\n-  fcc_reg = gen_rtx_REG (mode, FCC_REGNUM);\n-  cc_reg = gen_rtx_REG (mode, CC_REGNUM);\n-  emit_insn (gen_rtx_SET (cc_reg, fcc_reg));\n-  tmp = gen_rtx_fmt_ee (cond, mode, cc_reg, const0_rtx);\n-  tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n-                              gen_rtx_LABEL_REF (VOIDmode, operands[3]), pc_rtx);\n-  emit_jump_insn (gen_rtx_SET (pc_rtx, tmp));\n-  DONE;\n-})\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 4) (match_dup 5))\n+   (set (pc)\n+        (if_then_else (match_dup 6)\n+                      (label_ref (match_dup 3))\n+                      (pc)))]\n+  \"{\n+     /* This will generate the comparison insn at the start of\n+\tthe sequence and get us the right mode to use for our\n+\tcondition code registers.  */\n+     enum machine_mode mode\n+       = v850_gen_float_compare (GET_CODE (operands[0]),\n+\t\t\t\t GET_MODE (operands[1]),\n+\t\t\t\t operands[1], operands[2]);\n+     /* We want operands referring to CC_REGNUM and FCC_REGNUM\n+\tin mode MODE.  */\n+     operands[4] = gen_rtx_REG (mode, CC_REGNUM);\n+     operands[5] = gen_rtx_REG (mode, FCC_REGNUM);\n+     if (mode == CC_FPU_NEmode)\n+       operands[6] = gen_rtx_NE (mode, operands[4], const0_rtx);\n+     else\n+       operands[6] = gen_rtx_EQ (mode, operands[4], const0_rtx);\n+}\")\n \n (define_insn \"cstoresf4\"\n   [(set (match_operand:SI   0 \"register_operand\" \"=r\")\n         (match_operator:SI  1 \"ordered_comparison_operator\"\n          [(match_operand:SF 2 \"register_operand\" \"r\")\n-          (match_operand:SF 3 \"register_operand\" \"r\")]))]\n+          (match_operand:SF 3 \"register_operand\" \"r\")]))\n+  (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_USE_FPU\"\n {\n   if (GET_CODE (operands[1]) == GT || GET_CODE (operands[1]) == GE)\n@@ -471,44 +487,47 @@\n   [(set_attr \"length\" \"12\")\n    (set_attr \"type\" \"fpu\")])\n \n-(define_expand \"cbranchdf4\"\n+(define_insn_and_split \"cbranchdf4\"\n   [(set (pc)\n        (if_then_else (match_operator     0 \"ordered_comparison_operator\"\n-                      [(match_operand:DF 1 \"even_reg_operand\")\n-                       (match_operand:DF 2 \"even_reg_operand\")])\n+                      [(match_operand:DF 1 \"even_reg_operand\" \"r\")\n+                       (match_operand:DF 2 \"even_reg_operand\" \"r\")])\n                      (label_ref (match_operand 3 \"\"))\n-                     (pc)))\n-  (clobber (cc0))]\n+                     (pc)))]\n   \"TARGET_USE_FPU\"\n-{\n-  enum rtx_code cond = GET_CODE (operands[0]);\n-  machine_mode mode;\n-  rtx fcc_reg;\n-  rtx cc_reg;\n-  rtx tmp;\n-\n-    v850_compare_op0 = operands[1];\n-    v850_compare_op1 = operands[2];\n-\n-  if (GET_MODE_CLASS (GET_MODE (v850_compare_op0)) != MODE_FLOAT)\n-    FAIL;\n-\n-  mode = v850_gen_float_compare (cond, VOIDmode, v850_compare_op0, v850_compare_op1);\n-  fcc_reg = gen_rtx_REG (mode, FCC_REGNUM);\n-  cc_reg = gen_rtx_REG (mode, CC_REGNUM);\n-  emit_insn (gen_rtx_SET (cc_reg, fcc_reg));\n-  tmp = gen_rtx_fmt_ee (cond, mode, cc_reg, const0_rtx);\n-  tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n-                              gen_rtx_LABEL_REF (VOIDmode, operands[3]), pc_rtx);\n-  emit_jump_insn (gen_rtx_SET (pc_rtx, tmp));\n-  DONE;\n-})\n+  \"#\"\n+  \"reload_completed\"\n+;; How to get the mode here?\n+  [(set (match_dup 4) (match_dup 5))\n+   (set (pc)\n+        (if_then_else (match_dup 6)\n+                      (label_ref (match_dup 3))\n+                      (pc)))]\n+  \"{\n+     /* This will generate the comparison insn at the start of\n+\tthe sequence and get us the right mode to use for our\n+\tcondition code registers.  */\n+     enum machine_mode mode\n+       = v850_gen_float_compare (GET_CODE (operands[0]),\n+\t\t\t\t GET_MODE (operands[1]),\n+\t\t\t\t operands[1], operands[2]);\n+     PUT_MODE (operands[0], mode);\n+     /* We want operands referring to CC_REGNUM and FCC_REGNUM\n+\tin mode MODE.  */\n+     operands[4] = gen_rtx_REG (mode, CC_REGNUM);\n+     operands[5] = gen_rtx_REG (mode, FCC_REGNUM);\n+     if (mode == CC_FPU_NEmode)\n+       operands[6] = gen_rtx_NE (mode, operands[4], const0_rtx);\n+     else\n+       operands[6] = gen_rtx_EQ (mode, operands[4], const0_rtx);\n+}\")\n \n (define_insn \"cstoredf4\"\n   [(set (match_operand:SI   0 \"register_operand\" \"=r\")\n         (match_operator:SI  1 \"ordered_comparison_operator\"\n          [(match_operand:DF 2 \"even_reg_operand\"  \"r\")\n-          (match_operand:DF 3 \"even_reg_operand\" \"r\")]))]\n+          (match_operand:DF 3 \"even_reg_operand\" \"r\")]))\n+  (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_USE_FPU\"\n {\n   if (GET_CODE (operands[1]) == GT || GET_CODE (operands[1]) == GE)\n@@ -524,38 +543,25 @@\n   [(set_attr \"length\" \"12\")\n    (set_attr \"type\" \"fpu\")])\n \n-(define_expand \"cmpsf\"\n-  [(set (reg:CC CC_REGNUM)\n-\t(compare (match_operand:SF 0 \"register_operand\" \"r\")\n-\t\t (match_operand:SF 1 \"register_operand\" \"r\")))]\n-  \"TARGET_USE_FPU\"\n-  {\n-    v850_compare_op0 = operands[0];\n-    v850_compare_op1 = operands[1];\n-    DONE;\n-  })\n-\n-(define_expand \"cmpdf\"\n-  [(set (reg:CC CC_REGNUM)\n-\t(compare (match_operand:DF 0 \"even_reg_operand\" \"r\")\n-\t\t (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n-  \"TARGET_USE_FPU\"\n-  {\n-    v850_compare_op0 = operands[0];\n-    v850_compare_op1 = operands[1];\n-    DONE;\n-  })\n-\n ;; ----------------------------------------------------------------------\n ;; ADD INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_insn \"addsi3\"\n+(define_insn_and_split \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,r,r\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rJ,K,U\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])])\n+\n+(define_insn \"addsi3_clobber_flags\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,r,r\")\n \t\t (match_operand:SI 2 \"nonmemory_operand\" \"rJ,K,U\")))\n    (clobber (reg:CC CC_REGNUM))]\n-\n   \"\"\n   \"@\n    add %2,%0\n@@ -566,8 +572,17 @@\n ;; ----------------------------------------------------------------------\n ;; SUBTRACT INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n+(define_insn_and_split \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"0,r\")\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r,0\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (minus:SI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])])\n \n-(define_insn \"subsi3\"\n+(define_insn \"subsi3_clobber_flags\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(minus:SI (match_operand:SI 1 \"register_operand\" \"0,r\")\n \t\t  (match_operand:SI 2 \"register_operand\" \"r,0\")))\n@@ -578,7 +593,16 @@\n   subr %1,%0\"\n   [(set_attr \"length\" \"2,2\")])\n \n-(define_insn \"negsi2\"\n+(define_insn_and_split \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (neg:SI (match_dup 1)))\n+\t      (clobber (reg:CC CC_REGNUM))])])\n+\n+(define_insn \"negsi2_clobber_flags\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(neg:SI (match_operand:SI 1 \"register_operand\" \"0\")))\n    (clobber (reg:CC CC_REGNUM))]\n@@ -703,7 +727,7 @@\n \t\t(match_dup 2)))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_V850E_UP\"\n-  \"sxh %0\\n\\tdivh %2,%0,%3\"\n+  \"sxh %0\\\\n\\\\tdivh %2,%0,%3\"\n   [(set_attr \"length\" \"6\")\n    (set_attr \"type\" \"div\")])\n \n@@ -719,7 +743,7 @@\n \t\t (match_dup 2)))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_V850E_UP\"\n-  \"zxh %0\\n\\tdivhu %2,%0,%3\"\n+  \"zxh %0\\\\n\\\\ndivhu %2,%0,%3\"\n   [(set_attr \"length\" \"6\")\n    (set_attr \"type\" \"div\")])\n \f\n@@ -785,12 +809,22 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"bit1\")])\n \n-(define_insn \"andsi3\"\n+(define_insn_and_split \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0,r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,I,M\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (and:SI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])])\n+\n+(define_insn \"andsi3_clobber_flags\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n \t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0,r\")\n \t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,I,M\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n+  \"reload_completed\"\n   \"@\n   and %2,%0\n   and %.,%0\n@@ -860,7 +894,17 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"bit1\")])\n \n-(define_insn \"iorsi3\"\n+(define_insn_and_split \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0,r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,I,M\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (ior:SI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])])\n+\n+(define_insn \"iorsi3_clobber_flags\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0,r\")\n \t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,I,M\")))\n@@ -935,7 +979,17 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"bit1\")])\n \n-(define_insn \"xorsi3\"\n+(define_insn_and_split \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,0,r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,I,M\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (xor:SI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])])\n+\n+(define_insn \"xorsi3_clobber_flags\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,0,r\")\n \t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,I,M\")))\n@@ -946,12 +1000,23 @@\n   xor %.,%0\n   xori %2,%1,%0\"\n   [(set_attr \"length\" \"2,2,4\")])\n+\n \f\n ;; ----------------------------------------------------------------------\n ;; NOT INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_insn \"one_cmplsi2\"\n+(define_insn_and_split \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (not:SI (match_dup 1)))\n+\t      (clobber (reg:CC CC_REGNUM))])])\n+\n+\n+(define_insn \"one_cmplsi2_clobber_flags\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))\n    (clobber (reg:CC CC_REGNUM))]\n@@ -977,7 +1042,8 @@\n   [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n \t\t\t (match_operand:SI 1 \"immediate_operand\" \"n\")\n \t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\"))\n-\t(match_operand:SI 3 \"register_operand\" \"r\"))]\n+\t(match_operand:SI 3 \"register_operand\" \"r\"))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_V850E3V5_UP\"\n   \"bins %3, %2, %1, %0\"\n   [(set_attr \"length\" \"4\")])\n@@ -986,20 +1052,46 @@\n ;; Scc INSTRUCTIONS\n ;; -----------------------------------------------------------------\n \n-(define_insn \"*setcc\"\n+(define_insn_and_split \"*cbranchsi4_insn\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t[(match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"reg_or_int5_operand\" \"rJ\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC (match_dup 1) (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 0\n+\t\t\t[(reg:CC CC_REGNUM) (const_int 0)])\n+\t\t      (label_ref (match_dup 3))\n+\t\t      (pc)))]\n+  \"\")\n+\n+\n+(define_insn_and_split \"cstoresi4\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n         (match_operator:SI 1 \"comparison_operator\"\n-\t [(cc0) (const_int 0)]))]\n+\t [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t  (match_operand:SI 3 \"reg_or_int5_operand\" \"rJ\")]))]\n   \"\"\n-  \"setf %c1,%0\"\n-  [(set_attr \"length\" \"4\")])\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC (match_dup 2) (match_dup 3)))\n+   (set (match_dup 0) (match_op_dup 1 \n+\t\t\t[(reg:CC CC_REGNUM) (const_int 0)]))]\n+  \"\")\n \n-(define_insn \"setf_insn\"\n+(define_insn \"*setcc_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operator:SI 1 \"comparison_operator\"\n-                          [(reg:CC CC_REGNUM) (const_int 0)]))]\n-  \"\"\n-  \"setf %b1,%0\"\n+        (match_operator:SI 1 \"comparison_operator\"\n+\t [(reg:CC CC_REGNUM) (const_int 0)]))]\n+  \"reload_completed\"\n+  \"setf %c1,%0\"\n   [(set_attr \"length\" \"4\")])\n \n (define_insn \"set_z_insn\"\n@@ -1065,20 +1157,14 @@\n       }\n   })\n \n-;; ??? Clobbering the condition codes is overkill.\n-\n-;; ??? We sometimes emit an unnecessary compare instruction because the\n-;; condition codes may have already been set by an earlier instruction,\n-;; but we have no code here to avoid the compare if it is unnecessary.\n-\n (define_insn \"movsicc_normal_cc\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n         (if_then_else:SI\n          (match_operator 1 \"comparison_operator\"\n                          [(reg:CC CC_REGNUM) (const_int 0)])\n          (match_operand:SI 2 \"reg_or_int5_operand\" \"rJ\")\n          (match_operand:SI 3 \"reg_or_0_operand\" \"rI\")))]\n-  \"(TARGET_V850E_UP)\"\n+  \"reload_completed && (TARGET_V850E_UP)\"\n   \"cmov %c1,%2,%z3,%0\";\n   [(set_attr \"length\" \"6\")])\n \n@@ -1089,11 +1175,11 @@\n                          [(reg:CC CC_REGNUM) (const_int 0)])\n          (match_operand:SI 2 \"reg_or_0_operand\" \"rI\")\n          (match_operand:SI 3 \"reg_or_int5_operand\" \"rJ\")))]\n-  \"(TARGET_V850E_UP)\"\n+  \"reload_completed && (TARGET_V850E_UP)\"\n   \"cmov %C1,%3,%z2,%0\"\n   [(set_attr \"length\" \"6\")])\n \n-(define_insn \"*movsicc_normal\"\n+(define_insn_and_split \"*movsicc_normal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(if_then_else:SI\n \t (match_operator 1 \"comparison_operator\"\n@@ -1102,21 +1188,35 @@\n \t (match_operand:SI 2 \"reg_or_int5_operand\" \"rJ\")\n \t (match_operand:SI 3 \"reg_or_0_operand\" \"rI\")))]\n   \"(TARGET_V850E_UP)\"\n-  \"cmp %5,%4 ; cmov %c1,%2,%z3,%0\"\n-  [(set_attr \"length\" \"6\")])\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC (match_dup 4) (match_dup 5)))\n+   (set (match_dup 0)\n+\t(if_then_else:SI (match_op_dup 1\n+\t\t\t   [(reg:CC CC_REGNUM) (const_int 0)])\n+\t\t\t (match_dup 2) (match_dup 3)))])\n \n-(define_insn \"*movsicc_reversed\"\n+\n+(define_insn_and_split \"*movsicc_reversed\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(if_then_else:SI\n \t (match_operator 1 \"comparison_operator\"\n \t\t\t [(match_operand:SI 4 \"register_operand\" \"r\")\n \t\t\t  (match_operand:SI 5 \"reg_or_int5_operand\" \"rJ\")])\n-\t (match_operand:SI 2 \"reg_or_0_operand\" \"rI\")\n-\t (match_operand:SI 3 \"reg_or_int5_operand\" \"rJ\")))]\n+\t (match_operand:SI 2 \"reg_or_int5_operand\" \"rI\")\n+\t (match_operand:SI 3 \"reg_or_0_operand\" \"rJ\")))]\n   \"(TARGET_V850E_UP)\"\n-  \"cmp %5,%4 ; cmov %C1,%3,%z2,%0\"\n-  [(set_attr \"length\" \"6\")])\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC (match_dup 4) (match_dup 5)))\n+   (set (match_dup 0)\n+\t(if_then_else:SI (match_op_dup 1\n+\t\t\t   [(reg:CC CC_REGNUM) (const_int 0)])\n+\t\t\t (match_dup 2) (match_dup 3)))])\n \n+;; We could expose the setting of the condition codes here.\n (define_insn \"*movsicc_tst1\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(if_then_else:SI\n@@ -1127,11 +1227,13 @@\n \t\t\t   (match_operand 3 \"const_int_operand\" \"n\"))\n \t\t\t  (const_int 0)])\n \t (match_operand:SI 4 \"reg_or_int5_operand\" \"rJ\")\n-\t (match_operand:SI 5 \"reg_or_0_operand\" \"rI\")))]\n+\t (match_operand:SI 5 \"reg_or_0_operand\" \"rI\")))\n+  (clobber (reg:CC CC_REGNUM))]\n   \"(TARGET_V850E_UP)\"\n   \"tst1 %3,%2 ; cmov %c1,%4,%z5,%0\"\n   [(set_attr \"length\" \"8\")])\n \n+;; We could expose the setting of the condition codes here.\n (define_insn \"*movsicc_tst1_reversed\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(if_then_else:SI\n@@ -1142,7 +1244,8 @@\n \t\t\t   (match_operand 3 \"const_int_operand\" \"n\"))\n \t\t\t  (const_int 0)])\n \t (match_operand:SI 4 \"reg_or_0_operand\" \"rI\")\n-\t (match_operand:SI 5 \"reg_or_int5_operand\" \"rJ\")))]\n+\t (match_operand:SI 5 \"reg_or_int5_operand\" \"rJ\")))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"(TARGET_V850E_UP)\"\n   \"tst1 %3,%2 ; cmov %C1,%5,%z4,%0\"\n   [(set_attr \"length\" \"8\")])\n@@ -1152,6 +1255,9 @@\n ;; second pattern by subsequent combining.  As above, we must include the\n ;; comparison to avoid input reloads in an insn using cc0.\n \n+;; We could expose the setting of the condition codes here.\n+;; However, I haven't seen this pattern used, so I'm not going\n+;; to bother.\n (define_insn \"*sasf\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(ior:SI\n@@ -1235,7 +1341,8 @@\n        [(ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t   (match_operand:SI 2 \"const_int_operand\" \"n\"))\n \t(lshiftrt:SI (match_dup 1)\n-\t(match_operand:SI 3 \"const_int_operand\" \"n\"))]))]\n+\t(match_operand:SI 3 \"const_int_operand\" \"n\"))]))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_V850E3V5_UP && (INTVAL (operands[2]) + INTVAL (operands[3]) == 32)\"\n   \"rotl %2, %1, %0\"\n   [(set_attr \"length\" \"4\")])\n@@ -1246,7 +1353,8 @@\n        [(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t     (match_operand:SI 3 \"const_int_operand\" \"n\"))\n \t(ashift:SI (match_dup 1)\n-\t\t   (match_operand:SI 2 \"const_int_operand\" \"n\"))]))]\n+\t\t   (match_operand:SI 2 \"const_int_operand\" \"n\"))]))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_V850E3V5_UP && (INTVAL (operands[2]) + INTVAL (operands[3]) == 32)\"\n   \"rotl %2, %1, %0\"\n   [(set_attr \"length\" \"4\")])\n@@ -1287,9 +1395,11 @@\n   }\n )\n \n+;; Note the embedded arithmetic.  That affects the condition codes!\n (define_insn \"fix_loop_counter\"\n   [(unspec:SI [(match_operand:SI          0 \"register_operand\" \"+r,!m\")\n-\t       (clobber (match_scratch:SI 1                    \"=X,r\"))] UNSPEC_LOOP)]\n+\t       (clobber (match_scratch:SI 1                    \"=X,r\"))] UNSPEC_LOOP)\n+   (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_V850E3V5_UP && TARGET_LOOP\"\n   {\n     switch (which_alternative)\n@@ -1349,68 +1459,52 @@\n \n ;; Conditional jump instructions\n \n-(define_insn \"*branch_normal\"\n+(define_insn_and_split \"*cbranchsi4_insn\"\n   [(set (pc)\n-\t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t[(match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"reg_or_int5_operand\" \"rJ\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-{\n-  if (get_attr_length (insn) == 2)\n-    return \"b%b1 %l0\";\n-  if (TARGET_V850E3V5_UP && get_attr_length (insn) == 4)\n-    return \"b%b1 %l0\";\n-  return \"b%B1 .+6 ; jr %l0\";\n-}\n- [(set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 0) (pc)))\n-\t\t      (const_int 256))\n-\t\t  (const_int 2)\n-\t\t  (if_then_else (lt (abs (minus (match_dup 0) (pc)))\n-\t\t      (const_int 65536))\n-\t\t      (const_int 4)\n-\t\t      (const_int 6))))])\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC (match_dup 1) (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 0\n+\t\t\t[(reg:CC CC_REGNUM) (const_int 0)])\n+\t\t      (label_ref (match_dup 3))\n+\t\t      (pc)))]\n+  \"\")\n \n-(define_insn \"*branch_invert\"\n+(define_insn \"*branch_normal\"\n   [(set (pc)\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(cc0) (const_int 0)])\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-{\n-  if (get_attr_length (insn) == 2)\n-    return \"b%B1 %l0\";\n-\n-  if (TARGET_V850E3V5_UP && get_attr_length (insn) == 4)\n-    return \"b%B1 %l0\";\n-    \n-  return \"b%b1 .+6 ; jr %l0\";\n-}\n- [(set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 0) (pc)))\n-\t\t      (const_int 256))\n-\t\t  (const_int 2)\n-\t\t  (if_then_else (lt (abs (minus (match_dup 0) (pc)))\n-\t\t      (const_int 65536))\n-\t\t      (const_int 4)\n-\t\t      (const_int 6))))])\n-\n-(define_insn \"branch_z_normal\"\t\n-  [(set (pc)\n-\t(if_then_else (match_operand 1 \"v850_float_z_comparison_operator\" \"\")\n+\t\t\t\t      [(reg CC_REGNUM) (const_int 0)])\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_V850E2V3_UP\"\n+  \"reload_completed\"\n {\n+  bool nzmode = GET_MODE (XEXP (operands[1], 0)) == CCNZmode;\n   if (get_attr_length (insn) == 2)\n-    return \"bz %l0\";\n-\n+    {\n+      if (nzmode)\n+\treturn \"b%d1 %l0\";\n+      else\n+\treturn \"b%b1 %l0\";\n+    }\n   if (TARGET_V850E3V5_UP && get_attr_length (insn) == 4)\n-    return \"bz %l0\";\n-\n-  return \"bnz 1f ; jr %l0 ; 1:\";\n+    {\n+      if (nzmode)\n+\treturn \"b%d1 %l0\";\n+      else\n+\treturn \"b%b1 %l0\";\n+    }\n+  if (nzmode)\n+    return \"b%D1 .+6 ; jr %l0\";\n+  else\n+    return \"b%B1 .+6 ; jr %l0\";\n }\n  [(set (attr \"length\")\n     (if_then_else (lt (abs (minus (match_dup 0) (pc)))\n@@ -1421,68 +1515,36 @@\n \t\t      (const_int 4)\n \t\t      (const_int 6))))])\n \n-(define_insn \"*branch_z_invert\"\n+(define_insn \"*branch_invert\"\n   [(set (pc)\n-\t(if_then_else (match_operand 1 \"v850_float_z_comparison_operator\" \"\")\n+\t(if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t\t\t      [(reg CC_REGNUM) (const_int 0)])\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"TARGET_V850E2V3_UP\"\n+  \"reload_completed\"\n {\n-  if (get_attr_length (insn) == 2)\n-    return \"bnz %l0\";\n-\n-  if (TARGET_V850E3V5_UP && get_attr_length (insn) == 4)\n-    return \"bnz %l0\";\n-\n-  return \"bz 1f ; jr %l0 ; 1:\";\n-}\n- [(set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 0) (pc)))\n-\t\t\t   (const_int 256))\n-\t\t  (const_int 2)\n-\t\t  (if_then_else (lt (abs (minus (match_dup 0) (pc)))\n-\t\t      (const_int 65536))\n-\t\t      (const_int 4)\n-\t\t      (const_int 6))))])\n+  bool nzmode = GET_MODE (XEXP (operands[1], 0)) == CCNZmode;\n \n-(define_insn \"branch_nz_normal\"\n-  [(set (pc)\n-\t(if_then_else (match_operand 1 \"v850_float_nz_comparison_operator\" \"\")\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_V850E2V3_UP\"\n-{\n   if (get_attr_length (insn) == 2)\n-    return \"bnz %l0\";\n-\n-  if (TARGET_V850E3V5_UP && get_attr_length (insn) == 4)\n-    return \"bnz %l0\";\n-\n-  return \"bz 1f ; jr %l0 ; 1:\";\n-}\n-[(set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 0) (pc)))\n-\t\t\t   (const_int 256))\n-\t\t  (const_int 2)\n-\t\t  (if_then_else (lt (abs (minus (match_dup 0) (pc)))\n-\t\t      (const_int 65536))\n-\t\t      (const_int 4)\n-\t\t      (const_int 6))))])\n-\n-(define_insn \"*branch_nz_invert\"\n-  [(set (pc)\n-\t(if_then_else (match_operand 1 \"v850_float_nz_comparison_operator\" \"\")\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"TARGET_V850E2V3_UP\"\n-{\n-  if (get_attr_length (insn) == 2)\n-    return \"bz %l0\";\n+    {\n+      if (nzmode)\n+\treturn \"b%D1 %l0\";\n+      else\n+\treturn \"b%B1 %l0\";\n+    }\n \n   if (TARGET_V850E3V5_UP && get_attr_length (insn) == 4)\n-    return \"bz %l0\";\n+    {\n+      if (nzmode)\n+\treturn \"b%D1 %l0\";\n+      else\n+\treturn \"b%B1 %l0\";\n+    }\n \n-  return \"bnz 1f ; jr %l0 ; 1:\";\n+  if (nzmode)\n+    return \"b%d1 .+6 ; jr %l0\";\n+  else\n+    return \"b%b1 .+6 ; jr %l0\";\n }\n  [(set (attr \"length\")\n     (if_then_else (lt (abs (minus (match_dup 0) (pc)))\n@@ -1602,6 +1664,7 @@\n (define_insn \"call_internal_short\"\n   [(call (mem:QI (match_operand:SI 0 \"call_address_operand\" \"S,r\"))\n \t (match_operand:SI 1 \"general_operand\" \"g,g\"))\n+   (clobber (reg:CC CC_REGNUM))\n    (clobber (reg:SI 31))]\n   \"! TARGET_LONG_CALLS\"\n   {\n@@ -1620,6 +1683,7 @@\n (define_insn \"call_internal_long\"\n   [(call (mem:QI (match_operand:SI 0 \"call_address_operand\" \"S,r\"))\n \t (match_operand:SI 1 \"general_operand\" \"g,g\"))\n+   (clobber (reg:CC CC_REGNUM))\n    (clobber (reg:SI 31))]\n   \"TARGET_LONG_CALLS\"\n {\n@@ -1668,6 +1732,7 @@\n   [(set (match_operand 0 \"\" \"=r,r\")\n \t(call (mem:QI (match_operand:SI 1 \"call_address_operand\" \"S,r\"))\n \t      (match_operand:SI 2 \"general_operand\" \"g,g\")))\n+   (clobber (reg:CC CC_REGNUM))\n    (clobber (reg:SI 31))]\n   \"! TARGET_LONG_CALLS\"\n   {\n@@ -1687,6 +1752,7 @@\n   [(set (match_operand 0 \"\" \"=r,r\")\n \t(call (mem:QI (match_operand:SI 1 \"call_address_operand\" \"S,r\"))\n \t      (match_operand:SI 2 \"general_operand\" \"g,g\")))\n+   (clobber (reg:CC CC_REGNUM))\n    (clobber (reg:SI 31))]\n   \"TARGET_LONG_CALLS\"\n {\n@@ -1719,6 +1785,7 @@\n ;; EXTEND INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n+;; We only need the CC clobber because of the andi alternative\n (define_insn \"*zero_extendhisi2_v850e\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n \t(zero_extend:SI\n@@ -1791,8 +1858,7 @@\n \n (define_insn \"*extendhisi_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n-\t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"0,Q,m\")))\n-   (clobber (reg:CC CC_REGNUM))]\n+\t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"0,Q,m\")))]\n   \"(TARGET_V850E_UP)\"\n   \"@\n    sxh %0\n@@ -1822,8 +1888,7 @@\n \n (define_insn \"*extendqisi_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n-\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"0,Q,m\")))\n-   (clobber (reg:CC CC_REGNUM))]\n+\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"0,Q,m\")))]\n   \"(TARGET_V850E_UP)\"\n   \"@\n    sxb %0\n@@ -1853,7 +1918,18 @@\n ;; SHIFTS\n ;; ----------------------------------------------------------------------\n \n-(define_insn \"ashlsi3\"\n+(define_insn_and_split \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+      (ashift:SI\n+\t(match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t(match_operand:SI 2 \"nonmemory_operand\" \"r,N\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (ashift:SI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])])\n+\n+(define_insn \"ashlsi3_clobber_flags\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n       (ashift:SI\n \t(match_operand:SI 1 \"register_operand\" \"0,0\")\n@@ -1865,7 +1941,7 @@\n   shl %2,%0\"\n   [(set_attr \"length\" \"4,2\")])\n \n-(define_insn \"ashlsi3_v850e2\"\n+(define_insn \"ashlsi3_v850e2_clobber_flags\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n       (ashift:SI\n \t(match_operand:SI 1 \"register_operand\" \"r\")\n@@ -1875,7 +1951,18 @@\n   \"shl %2,%1,%0\"\n   [(set_attr \"length\" \"4\")])\n \n-(define_insn \"lshrsi3\"\n+(define_insn_and_split \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+      (lshiftrt:SI\n+\t(match_operand:SI 1 \"register_operand\" \"0,0\")\n+        (match_operand:SI 2 \"nonmemory_operand\" \"r,N\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (lshiftrt:SI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])])\n+\n+(define_insn \"lshrsi3_clobber_flags\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n       (lshiftrt:SI\n \t(match_operand:SI 1 \"register_operand\" \"0,0\")\n@@ -1887,7 +1974,7 @@\n   shr %2,%0\"\n   [(set_attr \"length\" \"4,2\")])\n \n-(define_insn \"lshrsi3_v850e2\"\n+(define_insn \"lshrsi3_v850e2_clobber_flags\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n       (lshiftrt:SI\n \t(match_operand:SI 1 \"register_operand\" \"r\")\n@@ -1897,7 +1984,18 @@\n   \"shr %2,%1,%0\"\n   [(set_attr \"length\" \"4\")])\n \n-(define_insn \"ashrsi3\"\n+(define_insn_and_split \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+      (ashiftrt:SI\n+\t(match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t(match_operand:SI 2 \"nonmemory_operand\" \"r,N\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (ashiftrt:SI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])])\n+\n+(define_insn \"ashrsi3_clobber_flags\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n       (ashiftrt:SI\n \t(match_operand:SI 1 \"register_operand\" \"0,0\")\n@@ -1909,7 +2007,7 @@\n   sar %2,%0\"\n   [(set_attr \"length\" \"4,2\")])\n \n-(define_insn \"ashrsi3_v850e2\"\n+(define_insn \"ashrsi3_v850e2_clobber_flags\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n       (ashiftrt:SI\n \t(match_operand:SI 1 \"register_operand\" \"r\")\n@@ -2279,6 +2377,8 @@\n ;; ---------------- special insns\n ;;\n \n+;; reciprocal\n+\n ;; Generic code demands that the recip and rsqrt named patterns\n ;; have precisely one operand.  So that's what we expose in the\n ;; expander via the strange UNSPEC.  However, those expanders\n@@ -2417,7 +2517,7 @@\n   [(set (reg:CC_FPU_LE FCC_REGNUM)\n         (compare:CC_FPU_LE (match_operand:SF 0 \"register_operand\" \"r\")\n \t\t\t   (match_operand:SF 1 \"register_operand\" \"r\")))]\n-  \"TARGET_USE_FPU\"\n+  \"reload_completed && TARGET_USE_FPU\"\n   \"cmpf.s le, %z0, %z1\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"fpu\")])\n@@ -2426,7 +2526,7 @@\n   [(set (reg:CC_FPU_LT FCC_REGNUM)\n         (compare:CC_FPU_LT (match_operand:SF 0 \"register_operand\" \"r\")\n \t\t\t   (match_operand:SF 1 \"register_operand\" \"r\")))]\n-  \"TARGET_USE_FPU\"\n+  \"reload_completed && TARGET_USE_FPU\"\n   \"cmpf.s lt, %z0, %z1\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"fpu\")])\n@@ -2435,7 +2535,7 @@\n   [(set (reg:CC_FPU_GE FCC_REGNUM)\n         (compare:CC_FPU_GE (match_operand:SF 0 \"register_operand\" \"r\")\n \t\t\t   (match_operand:SF 1 \"register_operand\" \"r\")))]\n-  \"TARGET_USE_FPU\"\n+  \"reload_completed && TARGET_USE_FPU\"\n   \"cmpf.s le, %z1, %z0\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"fpu\")])\n@@ -2444,7 +2544,7 @@\n   [(set (reg:CC_FPU_GT FCC_REGNUM)\n         (compare:CC_FPU_GT (match_operand:SF 0 \"register_operand\" \"r\")\n \t\t\t   (match_operand:SF 1 \"register_operand\" \"r\")))]\n-  \"TARGET_USE_FPU\"\n+  \"reload_completed && TARGET_USE_FPU\"\n   \"cmpf.s lt, %z1, %z0\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"fpu\")])\n@@ -2453,7 +2553,7 @@\n   [(set (reg:CC_FPU_EQ FCC_REGNUM)\n         (compare:CC_FPU_EQ (match_operand:SF 0 \"register_operand\" \"r\")\n \t\t\t   (match_operand:SF 1 \"register_operand\" \"r\")))]\n-  \"TARGET_USE_FPU\"\n+  \"reload_completed && TARGET_USE_FPU\"\n   \"cmpf.s eq, %z0, %z1\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"fpu\")])\n@@ -2464,7 +2564,7 @@\n   [(set (reg:CC_FPU_LE FCC_REGNUM)\n         (compare:CC_FPU_LE (match_operand:DF 0 \"even_reg_operand\" \"r\")\n \t\t\t   (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n-  \"TARGET_USE_FPU\"\n+  \"reload_completed && TARGET_USE_FPU\"\n   \"cmpf.d le, %z0, %z1\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"fpu\")])\n@@ -2473,7 +2573,7 @@\n   [(set (reg:CC_FPU_LT FCC_REGNUM)\n         (compare:CC_FPU_LT (match_operand:DF 0 \"even_reg_operand\" \"r\")\n \t\t\t   (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n-  \"TARGET_USE_FPU\"\n+  \"reload_completed && TARGET_USE_FPU\"\n   \"cmpf.d lt, %z0, %z1\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"fpu\")])\n@@ -2482,7 +2582,7 @@\n   [(set (reg:CC_FPU_GE FCC_REGNUM)\n         (compare:CC_FPU_GE (match_operand:DF 0 \"even_reg_operand\" \"r\")\n \t\t\t   (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n-  \"TARGET_USE_FPU\"\n+  \"reload_completed && TARGET_USE_FPU\"\n   \"cmpf.d le, %z1, %z0\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"fpu\")])\n@@ -2491,7 +2591,7 @@\n   [(set (reg:CC_FPU_GT FCC_REGNUM)\n         (compare:CC_FPU_GT (match_operand:DF 0 \"even_reg_operand\" \"r\")\n \t\t           (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n-  \"TARGET_USE_FPU\"\n+  \"reload_completed && TARGET_USE_FPU\"\n   \"cmpf.d lt, %z1, %z0\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"fpu\")])\n@@ -2500,7 +2600,7 @@\n   [(set (reg:CC_FPU_EQ FCC_REGNUM)\n         (compare:CC_FPU_EQ (match_operand:DF 0 \"even_reg_operand\" \"r\")\n \t\t\t   (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n-  \"TARGET_USE_FPU\"\n+  \"reload_completed && TARGET_USE_FPU\"\n   \"cmpf.d eq, %z0, %z1\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"fpu\")])\n@@ -2512,7 +2612,8 @@\n \n (define_insn \"trfsr\"\n   [(set (match_operand 0 \"\" \"\") (match_operand 1 \"\" \"\"))]\n-  \"TARGET_USE_FPU\n+  \"reload_completed\n+   && TARGET_USE_FPU\n    && GET_MODE(operands[0]) == GET_MODE(operands[1])\n    && GET_CODE(operands[0]) == REG && REGNO (operands[0]) == CC_REGNUM\n    && GET_CODE(operands[1]) == REG && REGNO (operands[1]) == FCC_REGNUM\n@@ -2668,7 +2769,8 @@\n \n ;; Initialize an interrupt function.  Do not depend on TARGET_PROLOG_FUNCTION.\n (define_insn \"callt_save_interrupt\"\n-  [(unspec_volatile [(const_int 0)] 2)]\n+  [(unspec_volatile [(const_int 0)] 2)\n+   (clobber (reg:CC CC_REGNUM))]\n     \"(TARGET_V850E_UP) && !TARGET_DISABLE_CALLT\"\n     ;; The CALLT instruction stores the next address of CALLT to CTPC register\n     ;; without saving its previous value.  So if the interrupt handler\n@@ -2689,7 +2791,8 @@\n    [(set_attr \"length\" \"26\")])\n \n (define_insn \"callt_return_interrupt\"\n-  [(unspec_volatile [(const_int 0)] 3)]\n+  [(unspec_volatile [(const_int 0)] 3)\n+   (clobber (reg:CC CC_REGNUM))]\n   \"(TARGET_V850E_UP) && !TARGET_DISABLE_CALLT\"\n   \"callt ctoff(__callt_return_interrupt)\"\n   [(set_attr \"length\" \"2\")])\n@@ -2700,7 +2803,8 @@\n    (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 4))\n    (set (mem:SI (plus:SI (reg:SI 3) (const_int -12))) (reg:SI 1))\n    (set (mem:SI (plus:SI (reg:SI 3) (const_int  -8))) (reg:SI 10))\n-   (set (mem:SI (plus:SI (reg:SI 3) (const_int  -4))) (reg:SI 11))]\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int  -4))) (reg:SI 11))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n {\n   if (TARGET_PROLOG_FUNCTION && !TARGET_LONG_CALLS)\n@@ -2733,7 +2837,8 @@\n    (set (reg:SI 10) (mem:SI (plus:SI (reg:SI 3) (const_int 12))))\n    (set (reg:SI 1)  (mem:SI (plus:SI (reg:SI 3) (const_int  8))))\n    (set (reg:SI 4)  (mem:SI (plus:SI (reg:SI 3) (const_int  4))))\n-   (set (reg:SI 30) (mem:SI (reg:SI 3)))]\n+   (set (reg:SI 30) (mem:SI (reg:SI 3)))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n {\n   if (TARGET_PROLOG_FUNCTION && !TARGET_LONG_CALLS)\n@@ -2763,13 +2868,15 @@\n ;; insns this complicated.\n \n (define_insn \"callt_save_all_interrupt\"\n-  [(unspec_volatile [(const_int 0)] 0)]\n+  [(unspec_volatile [(const_int 0)] 0)\n+   (clobber (reg:CC CC_REGNUM))]\n   \"(TARGET_V850E_UP) && !TARGET_DISABLE_CALLT\"\n   \"callt ctoff(__callt_save_all_interrupt)\"\n   [(set_attr \"length\" \"2\")])\n \n (define_insn \"save_all_interrupt\"\n-  [(unspec_volatile [(const_int 0)] 0)]\n+  [(unspec_volatile [(const_int 0)] 0)\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n {\n   if (TARGET_PROLOG_FUNCTION && !TARGET_LONG_CALLS)\n@@ -2844,10 +2951,12 @@\n   [(set (attr \"length\")\n         (if_then_else (match_test \"TARGET_LONG_CALLS\")\n                        (const_int 4)\n-                       (const_int 62)))])\n+                       (const_int 62)\n+\t))])\n \n (define_insn \"_save_all_interrupt\"\n-  [(unspec_volatile [(const_int 0)] 0)]\n+  [(unspec_volatile [(const_int 0)] 0)\n+   (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_V850 && ! TARGET_LONG_CALLS\"\n   \"jarl __save_all_interrupt,r10\"\n   [(set_attr \"length\" \"4\")])\n@@ -2859,13 +2968,15 @@\n ;; insns this complicated.\n \n (define_insn \"callt_restore_all_interrupt\"\n-  [(unspec_volatile [(const_int 0)] 1)]\n+  [(unspec_volatile [(const_int 0)] 1)\n+   (clobber (reg:CC CC_REGNUM))]\n   \"(TARGET_V850E_UP) && !TARGET_DISABLE_CALLT\"\n   \"callt ctoff(__callt_restore_all_interrupt)\"\n   [(set_attr \"length\" \"2\")])\n \n (define_insn \"restore_all_interrupt\"\n-  [(unspec_volatile [(const_int 0)] 1)]\n+  [(unspec_volatile [(const_int 0)] 1)\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n {\n   if (TARGET_PROLOG_FUNCTION && !TARGET_LONG_CALLS)\n@@ -2942,7 +3053,8 @@\n \t))])\n \n (define_insn \"_restore_all_interrupt\"\n-  [(unspec_volatile [(const_int 0)] 1)]\n+  [(unspec_volatile [(const_int 0)] 1)\n+   (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_V850 && ! TARGET_LONG_CALLS\"\n   \"jarl __restore_all_interrupt,r10\"\n   [(set_attr \"length\" \"4\")])"}]}