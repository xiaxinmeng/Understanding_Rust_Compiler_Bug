{"sha": "c2ebf4f10de9257baffbe29cd0074893a01cfd83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJlYmY0ZjEwZGU5MjU3YmFmZmJlMjljZDAwNzQ4OTNhMDFjZmQ4Mw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-09-25T08:43:37Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-09-25T08:43:37Z"}, "message": "openmp: Add support for non-rect simd and improve collapsed simd support\n\nThe following change adds support for non-rectangular simd loops.\nWhile working on that, I've noticed we actually don't vectorize collapsed\nsimd loops at all, because the code that I thought would be vectorizable\nactually is not vectorized.  While in theory for the constant lower/upper\nbounds and constant step of all but the outermost loop we could in theory\nvectorize by computing the seprate iterators using vectorized division\nand modulo for each of them from the single iterator that increments\nby 1 from 0 to total iteration count in the loop nest, I think that would\nbe fairly expensive and the chances of the loop body being vectorizable\nwould be low e.g. because of array indices unlikely to be linear and would\nneed scatters/gathers.\nThis patch changes the generated code to vectorize only the innermost\nloop which has higher chance of being vectorized.  Below is the list of\ntests and function names in which the patch resulted in vectorizing something\nthat hasn't been vectorized before (ok, the first line is a new test).\nI've also found that the vectorizer will not vectorize loops with non-constant\nsteps, I plan to do something about those incrementally on the omp-expand.c\nside (basically, compute number of iterations before the loop and use a 0 to\nnumber_of_iterations step 1 IV as the main one).\n\nI have problem with the composite simd vectorization though.\nThe point is that each thread (or task etc.) is given only a range of\nconsecutive iterations, so somewhere earlier it computes total number of iterations\nand splits the work between the workers and then the intent is to try to vectorize it.\nSo, each thread is then given a begin ... end-1 range that it would handle.\nThis means that from the single begin value I need to compute the individual iteration\nvars I should start at and then goto into the loop nest to begin iterating there\n(and actually compute how many iterations the innermost loop should do each time\nso that it stops before end).\nVery roughly the IL I emit is something like:\nint t[100][100][100];\n\nvoid\nfoo (int a, int b, int c, int d, int e, int f, int g, int h, int u, int v, int w, int x)\n{\n  int i, j, k;\n  int cnt;\n  if (x)\n    {\n      i = u; j = v; k = w; goto doit;\n    }\n  for (i = a; i < b; i += c)\n    for (j = d; j < e; j += f)\n      {\n        k = g;\n        doit:\n        for (; k < h; k++)\n          t[i][j][k] += i + j + k;\n      }\n}\nUnfortunately, some pass then turns the innermost loop to have more than 2 basic blocks\nand it isn't vectorized because of that.\n\nAlso, I have disabled (for now) SIMTization of collapsed simd loops, because for SIMT\nit would be using a single thread anyway and I didn't want to bother with checking\nSIMT on all places I've been changing.  If SIMT support is added for some or all\ncollapsed loops, that omp-low.c change needs to be reverted.\n\nHere is that list of what hasn't been vectorized before and is now:\n\ngcc/testsuite/gcc.dg/vect/vect-simd-17.c doit\ngcc/testsuite/gfortran.dg/gomp/openmp-simd-6.f90 bar\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-10.c f28_taskloop_simd_normal._omp_fn.0\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-10.c _Z24f28_taskloop_simd_normalv._omp_fn.0\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-11.c f25_t_simd_normal._omp_fn.0\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-11.c f26_t_simd_normal._omp_fn.0\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-11.c f27_t_simd_normal._omp_fn.0\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-11.c f28_tpf_simd_guided32._omp_fn.1\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-11.c f28_tpf_simd_runtime._omp_fn.1\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-11.c _Z17f25_t_simd_normaliiiiiii._omp_fn.0\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-11.c _Z17f26_t_simd_normaliiiixxi._omp_fn.0\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-11.c _Z17f27_t_simd_normalv._omp_fn.0\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-11.c _Z20f28_tpf_simd_runtimev._omp_fn.1\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-11.c _Z21f28_tpf_simd_guided32v._omp_fn.1\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-2.c f7_simd_normal\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-2.c f7_simd_normal\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-2.c f8_f_simd_guided32\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-2.c f8_f_simd_guided32\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-2.c f8_f_simd_runtime\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-2.c f8_f_simd_runtime\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-2.c f8_pf_simd_guided32._omp_fn.0\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-2.c f8_pf_simd_runtime._omp_fn.0\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-2.c _Z18f8_pf_simd_runtimev._omp_fn.0\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-2.c _Z19f8_pf_simd_guided32v._omp_fn.0\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-4.c f8_taskloop_simd_normal._omp_fn.0\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-4.c _Z23f8_taskloop_simd_normalv._omp_fn.0\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-5.c f7_t_simd_normal._omp_fn.0\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-5.c f8_tpf_simd_guided32._omp_fn.1\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-5.c f8_tpf_simd_runtime._omp_fn.1\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-5.c _Z16f7_t_simd_normalv._omp_fn.0\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-5.c _Z19f8_tpf_simd_runtimev._omp_fn.1\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-5.c _Z20f8_tpf_simd_guided32v._omp_fn.1\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-8.c f25_simd_normal\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-8.c f25_simd_normal\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-8.c f26_simd_normal\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-8.c f26_simd_normal\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-8.c f27_simd_normal\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-8.c f27_simd_normal\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-8.c f28_f_simd_guided32\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-8.c f28_f_simd_guided32\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-8.c f28_f_simd_runtime\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-8.c f28_f_simd_runtime\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-8.c f28_pf_simd_guided32._omp_fn.0\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/for-8.c f28_pf_simd_runtime._omp_fn.0\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-8.c _Z19f28_pf_simd_runtimev._omp_fn.0\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/for-8.c _Z20f28_pf_simd_guided32v._omp_fn.0\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/master-combined-1.c main._omp_fn.9\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/master-combined-1.c main._omp_fn.9\nlibgomp/testsuite/libgomp.c++/../libgomp.c-c++-common/simd-1.c f2\nlibgomp/testsuite/libgomp.c/../libgomp.c-c++-common/simd-1.c f2\nlibgomp/testsuite/libgomp.c/pr70680-2.c f1._omp_fn.0\nlibgomp/testsuite/libgomp.c/pr70680-2.c f2._omp_fn.0\nlibgomp/testsuite/libgomp.c/pr70680-2.c f3._omp_fn.0\nlibgomp/testsuite/libgomp.c/pr70680-2.c f4._omp_fn.0\nlibgomp/testsuite/libgomp.c/simd-8.c foo\nlibgomp/testsuite/libgomp.c/simd-9.c bar\nlibgomp/testsuite/libgomp.c/simd-9.c foo\n\n2020-09-25  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/\n\t* omp-low.c (scan_omp_1_stmt): Don't call scan_omp_simd for\n\tcollapse > 1 loops as simt doesn't support collapsed loops yet.\n\t* omp-expand.c (expand_omp_for_init_counts, expand_omp_for_init_vars):\n\tSmall tweaks to function comment.\n\t(expand_omp_simd): Rewritten collapse > 1 support to only attempt\n\tto vectorize the innermost loop and emit set of outer loops around it.\n\tFor non-composite simd with collapse > 1 without broken loop don't\n\teven try to compute number of iterations first.  Add support for\n\tnon-rectangular simd loops.\n\t(expand_omp_for): Don't sorry_at on non-rectangular simd loops.\ngcc/testsuite/\n\t* gcc.dg/vect/vect-simd-17.c: New test.\nlibgomp/\n\t* testsuite/libgomp.c/loop-25.c: New test.", "tree": {"sha": "3b385ddc8b485d7348be3782bbfc5f1073151293", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b385ddc8b485d7348be3782bbfc5f1073151293"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2ebf4f10de9257baffbe29cd0074893a01cfd83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2ebf4f10de9257baffbe29cd0074893a01cfd83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2ebf4f10de9257baffbe29cd0074893a01cfd83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2ebf4f10de9257baffbe29cd0074893a01cfd83/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2784a9698ffdd6cd8434694c11336e9f7905be5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2784a9698ffdd6cd8434694c11336e9f7905be5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2784a9698ffdd6cd8434694c11336e9f7905be5"}], "stats": {"total": 1015, "additions": 904, "deletions": 111}, "files": [{"sha": "9160022729700327207a4ee24301ea4e7d9ec90f", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 302, "deletions": 110, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ebf4f10de9257baffbe29cd0074893a01cfd83/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ebf4f10de9257baffbe29cd0074893a01cfd83/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=c2ebf4f10de9257baffbe29cd0074893a01cfd83", "patch": "@@ -1700,8 +1700,8 @@ expand_oacc_collapse_vars (const struct omp_for_data *fd, bool inner,\n    loops, do this only for the rectangular loops.  Then pick\n    the loops which reference outer vars in their bound expressions\n    and the loops which they refer to and for this sub-nest compute\n-   number of iterations.  For triangular loops use Faulhaber's formula\n-   (TBD.), otherwise as a fallback, compute by iterating the loops.\n+   number of iterations.  For triangular loops use Faulhaber's formula,\n+   otherwise as a fallback, compute by iterating the loops.\n    If e.g. the sub-nest is\n \tfor (I = N11; I COND1 N12; I += STEP1)\n \tfor (J = M21 * I + N21; J COND2 M22 * I + N22; J += STEP2)\n@@ -2383,7 +2383,7 @@ expand_omp_for_init_counts (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n    into its _looptemp_ temporaries instead.\n    For non-rectangular loops (between fd->first_nonrect and fd->last_nonrect\n    inclusive), use the count of all those loops together, and either\n-   find quadratic etc. equation roots (TBD), or as a fallback, do:\n+   find quadratic etc. equation roots, or as a fallback, do:\n \tCOUNT = 0;\n \tfor (tmpi = N11; tmpi COND1 N12; tmpi += STEP1)\n \tfor (tmpj = M21 * tmpi + N21;\n@@ -6203,49 +6203,8 @@ expand_omp_for_static_chunk (struct omp_region *region,\n \tif (V cond N2) goto L0; else goto L2;\n     L2:\n \n-    For collapsed loops, given parameters:\n-      collapse(3)\n-      for (V1 = N11; V1 cond1 N12; V1 += STEP1)\n-\tfor (V2 = N21; V2 cond2 N22; V2 += STEP2)\n-\t  for (V3 = N31; V3 cond3 N32; V3 += STEP3)\n-\t    BODY;\n-\n-    we generate pseudocode\n-\n-\tif (cond3 is <)\n-\t  adj = STEP3 - 1;\n-\telse\n-\t  adj = STEP3 + 1;\n-\tcount3 = (adj + N32 - N31) / STEP3;\n-\tif (cond2 is <)\n-\t  adj = STEP2 - 1;\n-\telse\n-\t  adj = STEP2 + 1;\n-\tcount2 = (adj + N22 - N21) / STEP2;\n-\tif (cond1 is <)\n-\t  adj = STEP1 - 1;\n-\telse\n-\t  adj = STEP1 + 1;\n-\tcount1 = (adj + N12 - N11) / STEP1;\n-\tcount = count1 * count2 * count3;\n-\tV = 0;\n-\tV1 = N11;\n-\tV2 = N21;\n-\tV3 = N31;\n-\tgoto L1;\n-    L0:\n-\tBODY;\n-\tV += 1;\n-\tV3 += STEP3;\n-\tV2 += (V3 cond3 N32) ? 0 : STEP2;\n-\tV3 = (V3 cond3 N32) ? V3 : N31;\n-\tV1 += (V2 cond2 N22) ? 0 : STEP1;\n-\tV2 = (V2 cond2 N22) ? V2 : N21;\n-    L1:\n-\tif (V < count) goto L0; else goto L2;\n-    L2:\n-\n-      */\n+    For collapsed loops, emit the outer loops as scalar\n+    and only try to vectorize the innermost loop.  */\n \n static void\n expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n@@ -6319,7 +6278,9 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n   /* Not needed in SSA form right now.  */\n   gcc_assert (!gimple_in_ssa_p (cfun));\n-  if (fd->collapse > 1)\n+  if (fd->collapse > 1\n+      && (gimple_omp_for_combined_into_p (fd->for_stmt)\n+\t  || broken_loop))\n     {\n       int first_zero_iter = -1, dummy = -1;\n       basic_block zero_iter_bb = l2_bb, dummy_bb = NULL;\n@@ -6383,25 +6344,114 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n       step = fold_build2 (MULT_EXPR, TREE_TYPE (step), step, vf);\n     }\n \n-  expand_omp_build_assign (&gsi, fd->loop.v, fold_convert (type, n1));\n+  tree n2var = NULL_TREE;\n+  tree n2v = NULL_TREE;\n+  tree *nonrect_bounds = NULL;\n   if (fd->collapse > 1)\n     {\n-      if (gimple_omp_for_combined_into_p (fd->for_stmt))\n+      if (broken_loop || gimple_omp_for_combined_into_p (fd->for_stmt))\n \t{\n+\t  if (fd->non_rect)\n+\t    {\n+\t      nonrect_bounds = XALLOCAVEC (tree, fd->last_nonrect + 1);\n+\t      memset (nonrect_bounds, 0,\n+\t\t      sizeof (tree) * (fd->last_nonrect + 1));\n+\t    }\n+\t  expand_omp_build_assign (&gsi, fd->loop.v, fold_convert (type, n1));\n+\t  gcc_assert (entry_bb == gsi_bb (gsi));\n+\t  gcc_assert (fd->for_stmt == gsi_stmt (gsi));\n \t  gsi_prev (&gsi);\n-\t  expand_omp_for_init_vars (fd, &gsi, counts, NULL, NULL, n1);\n-\t  gsi_next (&gsi);\n+\t  entry_bb = split_block (entry_bb, gsi_stmt (gsi))->dest;\n+\t  expand_omp_for_init_vars (fd, &gsi, counts, nonrect_bounds,\n+\t\t\t\t    NULL, n1);\n+\t  gsi = gsi_for_stmt (fd->for_stmt);\n+\t}\n+      if (broken_loop)\n+\t;\n+      else if (gimple_omp_for_combined_into_p (fd->for_stmt))\n+\t{\n+\t  /* Compute in n2var the limit for the first innermost loop,\n+\t     i.e. fd->loop.v + MIN (n2 - fd->loop.v, cnt)\n+\t     where cnt is how many iterations would the loop have if\n+\t     all further iterations were assigned to the current task.  */\n+\t  n2var = create_tmp_var (type);\n+\t  i = fd->collapse - 1;\n+\t  tree itype = TREE_TYPE (fd->loops[i].v);\n+\t  if (POINTER_TYPE_P (itype))\n+\t    itype = signed_type_for (itype);\n+\t  t = build_int_cst (itype, (fd->loops[i].cond_code == LT_EXPR\n+\t\t\t\t     ? -1 : 1));\n+\t  t = fold_build2 (PLUS_EXPR, itype,\n+\t\t\t   fold_convert (itype, fd->loops[i].step), t);\n+\t  t = fold_build2 (PLUS_EXPR, itype, t,\n+\t\t\t   fold_convert (itype, fd->loops[i].n2));\n+\t  if (fd->loops[i].m2)\n+\t    {\n+\t      tree t2 = fold_convert (itype,\n+\t\t\t\t      fd->loops[i - fd->loops[i].outer].v);\n+\t      tree t3 = fold_convert (itype, fd->loops[i].m2);\n+\t      t2 = fold_build2 (MULT_EXPR, TREE_TYPE (t), t2, t3);\n+\t      t = fold_build2 (PLUS_EXPR, itype, t, t2);\n+\t    }\n+\t  t = fold_build2 (MINUS_EXPR, itype, t,\n+\t\t\t   fold_convert (itype, fd->loops[i].v));\n+\t  if (TYPE_UNSIGNED (itype) && fd->loops[i].cond_code == GT_EXPR)\n+\t    t = fold_build2 (TRUNC_DIV_EXPR, itype,\n+\t\t\t     fold_build1 (NEGATE_EXPR, itype, t),\n+\t\t\t     fold_build1 (NEGATE_EXPR, itype,\n+\t\t\t\t\t  fold_convert (itype,\n+\t\t\t\t\t\t\tfd->loops[i].step)));\n+\t  else\n+\t    t = fold_build2 (TRUNC_DIV_EXPR, itype, t,\n+\t\t\t     fold_convert (itype, fd->loops[i].step));\n+\t  t = fold_convert (type, t);\n+\t  tree t2 = fold_build2 (MINUS_EXPR, type, n2, n1);\n+\t  t = fold_build2 (MIN_EXPR, type, t2, t);\n+\t  t = fold_build2 (PLUS_EXPR, type, fd->loop.v, t);\n+\t  expand_omp_build_assign (&gsi, n2var, t);\n \t}\n       else\n-\tfor (i = 0; i < fd->collapse; i++)\n-\t  {\n-\t    tree itype = TREE_TYPE (fd->loops[i].v);\n-\t    if (POINTER_TYPE_P (itype))\n-\t      itype = signed_type_for (itype);\n-\t    t = fold_convert (TREE_TYPE (fd->loops[i].v), fd->loops[i].n1);\n-\t    expand_omp_build_assign (&gsi, fd->loops[i].v, t);\n-\t  }\n+\t{\n+\t  if (TREE_CODE (n2) == INTEGER_CST)\n+\t    {\n+\t      /* Indicate for lastprivate handling that at least one iteration\n+\t\t has been performed, without wasting runtime.  */\n+\t      if (integer_nonzerop (n2))\n+\t\texpand_omp_build_assign (&gsi, fd->loop.v,\n+\t\t\t\t\t fold_convert (type, n2));\n+\t      else\n+\t\t/* Indicate that no iteration has been performed.  */\n+\t\texpand_omp_build_assign (&gsi, fd->loop.v,\n+\t\t\t\t\t build_one_cst (type));\n+\t    }\n+\t  else\n+\t    {\n+\t      expand_omp_build_assign (&gsi, fd->loop.v,\n+\t\t\t\t       build_zero_cst (type));\n+\t      expand_omp_build_assign (&gsi, n2, build_one_cst (type));\n+\t    }\n+\t  for (i = 0; i < fd->collapse; i++)\n+\t    {\n+\t      t = fold_convert (TREE_TYPE (fd->loops[i].v), fd->loops[i].n1);\n+\t      if (fd->loops[i].m1)\n+\t\t{\n+\t\t  tree t2\n+\t\t    = fold_convert (TREE_TYPE (t),\n+\t\t\t\t    fd->loops[i - fd->loops[i].outer].v);\n+\t\t  tree t3 = fold_convert (TREE_TYPE (t), fd->loops[i].m1);\n+\t\t  t2 = fold_build2 (MULT_EXPR, TREE_TYPE (t), t2, t3);\n+\t\t  t = fold_build2 (PLUS_EXPR, TREE_TYPE (t), t, t2);\n+\t\t}\n+\t      expand_omp_build_assign (&gsi, fd->loops[i].v, t);\n+\t      /* For normal non-combined collapsed loops just initialize\n+\t\t the outermost iterator in the entry_bb.  */\n+\t      if (!broken_loop)\n+\t\tbreak;\n+\t    }\n+\t}\n     }\n+  else\n+    expand_omp_build_assign (&gsi, fd->loop.v, fold_convert (type, n1));\n   if (cond_var)\n     {\n       if (POINTER_TYPE_P (type)\n@@ -6425,11 +6475,17 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n       stmt = gsi_stmt (gsi);\n       gcc_assert (gimple_code (stmt) == GIMPLE_OMP_CONTINUE);\n \n-      if (POINTER_TYPE_P (type))\n-\tt = fold_build_pointer_plus (fd->loop.v, step);\n-      else\n-\tt = fold_build2 (PLUS_EXPR, type, fd->loop.v, step);\n-      expand_omp_build_assign (&gsi, fd->loop.v, t);\n+      if (fd->collapse == 1\n+\t  || gimple_omp_for_combined_into_p (fd->for_stmt))\n+\t{\n+\t  if (POINTER_TYPE_P (type))\n+\t    t = fold_build_pointer_plus (fd->loop.v, step);\n+\t  else\n+\t    t = fold_build2 (PLUS_EXPR, type, fd->loop.v, step);\n+\t  expand_omp_build_assign (&gsi, fd->loop.v, t);\n+\t}\n+      else if (TREE_CODE (n2) != INTEGER_CST)\n+\texpand_omp_build_assign (&gsi, fd->loop.v, build_one_cst (type));\n \n       if (fd->collapse > 1)\n \t{\n@@ -6447,37 +6503,6 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n \t\t\t       fd->loops[i].v, t);\n \t    }\n \t  expand_omp_build_assign (&gsi, fd->loops[i].v, t);\n-\n-\t  for (i = fd->collapse - 1; i > 0; i--)\n-\t    {\n-\t      tree itype = TREE_TYPE (fd->loops[i].v);\n-\t      tree itype2 = TREE_TYPE (fd->loops[i - 1].v);\n-\t      if (POINTER_TYPE_P (itype2))\n-\t\titype2 = signed_type_for (itype2);\n-\t      t = fold_convert (itype2, fd->loops[i - 1].step);\n-\t      t = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE, true,\n-\t\t\t\t\t    GSI_SAME_STMT);\n-\t      t = build3 (COND_EXPR, itype2,\n-\t\t\t  build2 (fd->loops[i].cond_code, boolean_type_node,\n-\t\t\t\t  fd->loops[i].v,\n-\t\t\t\t  fold_convert (itype, fd->loops[i].n2)),\n-\t\t\t  build_int_cst (itype2, 0), t);\n-\t      if (POINTER_TYPE_P (TREE_TYPE (fd->loops[i - 1].v)))\n-\t\tt = fold_build_pointer_plus (fd->loops[i - 1].v, t);\n-\t      else\n-\t\tt = fold_build2 (PLUS_EXPR, itype2, fd->loops[i - 1].v, t);\n-\t      expand_omp_build_assign (&gsi, fd->loops[i - 1].v, t);\n-\n-\t      t = fold_convert (itype, fd->loops[i].n1);\n-\t      t = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE, true,\n-\t\t\t\t\t    GSI_SAME_STMT);\n-\t      t = build3 (COND_EXPR, itype,\n-\t\t\t  build2 (fd->loops[i].cond_code, boolean_type_node,\n-\t\t\t\t  fd->loops[i].v,\n-\t\t\t\t  fold_convert (itype, fd->loops[i].n2)),\n-\t\t\t  fd->loops[i].v, t);\n-\t      expand_omp_build_assign (&gsi, fd->loops[i].v, t);\n-\t    }\n \t}\n       if (cond_var)\n \t{\n@@ -6500,14 +6525,38 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n   /* Emit the condition in L1_BB.  */\n   gsi = gsi_start_bb (l1_bb);\n \n-  t = fold_convert (type, n2);\n-  t = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n-\t\t\t\tfalse, GSI_CONTINUE_LINKING);\n-  tree v = fd->loop.v;\n-  if (DECL_P (v) && TREE_ADDRESSABLE (v))\n-    v = force_gimple_operand_gsi (&gsi, v, true, NULL_TREE,\n-\t\t\t\t  false, GSI_CONTINUE_LINKING);\n-  t = build2 (fd->loop.cond_code, boolean_type_node, v, t);\n+  if (fd->collapse > 1\n+      && !gimple_omp_for_combined_into_p (fd->for_stmt)\n+      && !broken_loop)\n+    {\n+      i = fd->collapse - 1;\n+      tree itype = TREE_TYPE (fd->loops[i].v);\n+      if (fd->loops[i].m2)\n+\tt = n2v = create_tmp_var (itype);\n+      else\n+\tt = fold_convert (itype, fd->loops[i].n2);\n+      t = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n+\t\t\t\t    false, GSI_CONTINUE_LINKING);\n+      tree v = fd->loops[i].v;\n+      if (DECL_P (v) && TREE_ADDRESSABLE (v))\n+\tv = force_gimple_operand_gsi (&gsi, v, true, NULL_TREE,\n+\t\t\t\t      false, GSI_CONTINUE_LINKING);\n+      t = build2 (fd->loops[i].cond_code, boolean_type_node, v, t);\n+    }\n+  else\n+    {\n+      if (fd->collapse > 1 && !broken_loop)\n+\tt = n2var;\n+      else\n+\tt = fold_convert (type, n2);\n+      t = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n+\t\t\t\t    false, GSI_CONTINUE_LINKING);\n+      tree v = fd->loop.v;\n+      if (DECL_P (v) && TREE_ADDRESSABLE (v))\n+\tv = force_gimple_operand_gsi (&gsi, v, true, NULL_TREE,\n+\t\t\t\t      false, GSI_CONTINUE_LINKING);\n+      t = build2 (fd->loop.cond_code, boolean_type_node, v, t);\n+    }\n   cond_stmt = gimple_build_cond_empty (t);\n   gsi_insert_after (&gsi, cond_stmt, GSI_CONTINUE_LINKING);\n   if (walk_tree (gimple_cond_lhs_ptr (cond_stmt), expand_omp_regimplify_p,\n@@ -6572,12 +6621,160 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n       FALLTHRU_EDGE (entry_bb)->flags = EDGE_TRUE_VALUE;\n       FALLTHRU_EDGE (entry_bb)->probability\n \t = profile_probability::guessed_always ().apply_scale (7, 8);\n-      BRANCH_EDGE (entry_bb)->probability \n+      BRANCH_EDGE (entry_bb)->probability\n \t = FALLTHRU_EDGE (entry_bb)->probability.invert ();\n       l2_dom_bb = entry_bb;\n     }\n   set_immediate_dominator (CDI_DOMINATORS, l2_bb, l2_dom_bb);\n \n+  if (!broken_loop && fd->collapse > 1)\n+    {\n+      basic_block last_bb = l1_bb;\n+      basic_block init_bb = NULL;\n+      for (i = fd->collapse - 2; i >= 0; i--)\n+\t{\n+\t  tree nextn2v = NULL_TREE;\n+\t  if (EDGE_SUCC (last_bb, 0)->flags & EDGE_FALSE_VALUE)\n+\t    e = EDGE_SUCC (last_bb, 0);\n+\t  else\n+\t    e = EDGE_SUCC (last_bb, 1);\n+\t  basic_block bb = split_edge (e);\n+\t  if (POINTER_TYPE_P (TREE_TYPE (fd->loops[i].v)))\n+\t    {\n+\t      t = fold_convert (sizetype, fd->loops[i].step);\n+\t      t = fold_build_pointer_plus (fd->loops[i].v, t);\n+\t    }\n+\t  else\n+\t    {\n+\t      t = fold_convert (TREE_TYPE (fd->loops[i].v),\n+\t\t\t\tfd->loops[i].step);\n+\t      t = fold_build2 (PLUS_EXPR, TREE_TYPE (fd->loops[i].v),\n+\t\t\t       fd->loops[i].v, t);\n+\t    }\n+\t  gsi = gsi_after_labels (bb);\n+\t  expand_omp_build_assign (&gsi, fd->loops[i].v, t);\n+\n+\t  bb = split_block (bb, last_stmt (bb))->dest;\n+\t  gsi = gsi_start_bb (bb);\n+\t  tree itype = TREE_TYPE (fd->loops[i].v);\n+\t  if (fd->loops[i].m2)\n+\t    t = nextn2v = create_tmp_var (itype);\n+\t  else\n+\t    t = fold_convert (itype, fd->loops[i].n2);\n+\t  t = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n+\t\t\t\t\tfalse, GSI_CONTINUE_LINKING);\n+\t  tree v = fd->loops[i].v;\n+\t  if (DECL_P (v) && TREE_ADDRESSABLE (v))\n+\t    v = force_gimple_operand_gsi (&gsi, v, true, NULL_TREE,\n+\t\t\t\t\t  false, GSI_CONTINUE_LINKING);\n+\t  t = build2 (fd->loops[i].cond_code, boolean_type_node, v, t);\n+\t  cond_stmt = gimple_build_cond_empty (t);\n+\t  gsi_insert_after (&gsi, cond_stmt, GSI_CONTINUE_LINKING);\n+\t  if (walk_tree (gimple_cond_lhs_ptr (cond_stmt),\n+\t\t\t expand_omp_regimplify_p, NULL, NULL)\n+\t      || walk_tree (gimple_cond_rhs_ptr (cond_stmt),\n+\t\t\t    expand_omp_regimplify_p, NULL, NULL))\n+\t    {\n+\t      gsi = gsi_for_stmt (cond_stmt);\n+\t      gimple_regimplify_operands (cond_stmt, &gsi);\n+\t    }\n+\t  ne = single_succ_edge (bb);\n+\t  ne->flags = EDGE_FALSE_VALUE;\n+\n+\t  init_bb = create_empty_bb (bb);\n+\t  set_immediate_dominator (CDI_DOMINATORS, init_bb, bb);\n+\t  add_bb_to_loop (init_bb, bb->loop_father);\n+\t  e = make_edge (bb, init_bb, EDGE_TRUE_VALUE);\n+\t  e->probability\n+\t    = profile_probability::guessed_always ().apply_scale (7, 8);\n+\t  ne->probability = e->probability.invert ();\n+\n+\t  gsi = gsi_after_labels (init_bb);\n+\t  t = fold_convert (TREE_TYPE (fd->loops[i + 1].v),\n+\t\t\t    fd->loops[i + 1].n1);\n+\t  if (fd->loops[i + 1].m1)\n+\t    {\n+\t      tree t2 = fold_convert (TREE_TYPE (t),\n+\t\t\t\t      fd->loops[i + 1\n+\t\t\t\t\t\t- fd->loops[i + 1].outer].v);\n+\t      tree t3 = fold_convert (TREE_TYPE (t), fd->loops[i + 1].m1);\n+\t      t2 = fold_build2 (MULT_EXPR, TREE_TYPE (t), t2, t3);\n+\t      t = fold_build2 (PLUS_EXPR, TREE_TYPE (t), t, t2);\n+\t    }\n+\t  expand_omp_build_assign (&gsi, fd->loops[i + 1].v, t);\n+\t  if (fd->loops[i + 1].m2)\n+\t    {\n+\t      if (i + 2 == fd->collapse && n2var)\n+\t\t{\n+\t\t  gcc_assert (n2v == NULL_TREE);\n+\t\t  n2v = create_tmp_var (TREE_TYPE (fd->loops[i + 1].v));\n+\t\t}\n+\t      t = fold_convert (TREE_TYPE (fd->loops[i + 1].v),\n+\t\t\t\tfd->loops[i + 1].n2);\n+\t      tree t2 = fold_convert (TREE_TYPE (t),\n+\t\t\t\t      fd->loops[i + 1\n+\t\t\t\t\t\t- fd->loops[i + 1].outer].v);\n+\t      tree t3 = fold_convert (TREE_TYPE (t), fd->loops[i + 1].m2);\n+\t      t2 = fold_build2 (MULT_EXPR, TREE_TYPE (t), t2, t3);\n+\t      t = fold_build2 (PLUS_EXPR, TREE_TYPE (t), t, t2);\n+\t      expand_omp_build_assign (&gsi, n2v, t);\n+\t    }\n+\t  if (i + 2 == fd->collapse && n2var)\n+\t    {\n+\t      /* For composite simd, n2 is the first iteration the current\n+\t\t task shouldn't already handle, so we effectively want to use\n+\t\t for (V3 = N31; V < N2 && V3 < N32; V++, V3 += STEP3)\n+\t\t as the vectorized loop.  Except the vectorizer will not\n+\t\t vectorize that, so instead compute N2VAR as\n+\t\t N2VAR = V + MIN (N2 - V, COUNTS3) and use\n+\t\t for (V3 = N31; V < N2VAR; V++, V3 += STEP3)\n+\t\t as the loop to vectorize.  */\n+\t      tree t2 = fold_build2 (MINUS_EXPR, type, n2, fd->loop.v);\n+\t      if (fd->loops[i + 1].m1 || fd->loops[i + 1].m2)\n+\t\t{\n+\t\t  t = build_int_cst (itype, (fd->loops[i + 1].cond_code\n+\t\t\t\t\t     == LT_EXPR ? -1 : 1));\n+\t\t  t = fold_build2 (PLUS_EXPR, itype,\n+\t\t\t\t   fold_convert (itype,\n+\t\t\t\t\t\t fd->loops[i + 1].step), t);\n+\t\t  if (fd->loops[i + 1].m2)\n+\t\t    t = fold_build2 (PLUS_EXPR, itype, t, n2v);\n+\t\t  else\n+\t\t    t = fold_build2 (PLUS_EXPR, itype, t,\n+\t\t\t\t     fold_convert (itype,\n+\t\t\t\t\t\t   fd->loops[i + 1].n2));\n+\t\t  t = fold_build2 (MINUS_EXPR, itype, t,\n+\t\t\t\t   fold_convert (itype, fd->loops[i + 1].v));\n+\t\t  tree step = fold_convert (itype, fd->loops[i + 1].step);\n+\t\t  if (TYPE_UNSIGNED (itype)\n+\t\t      && fd->loops[i + 1].cond_code == GT_EXPR)\n+\t\t    t = fold_build2 (TRUNC_DIV_EXPR, itype,\n+\t\t\t\t     fold_build1 (NEGATE_EXPR, itype, t),\n+\t\t\t\t     fold_build1 (NEGATE_EXPR, itype, step));\n+\t\t  else\n+\t\t    t = fold_build2 (TRUNC_DIV_EXPR, itype, t, step);\n+\t\t  t = fold_convert (type, t);\n+\t\t}\n+\t      else\n+\t\tt = counts[i + 1];\n+\t      t = fold_build2 (MIN_EXPR, type, t2, t);\n+\t      t = fold_build2 (PLUS_EXPR, type, fd->loop.v, t);\n+\t      expand_omp_build_assign (&gsi, n2var, t);\n+\t    }\n+\t  n2v = nextn2v;\n+\n+\t  make_edge (init_bb, last_bb, EDGE_FALLTHRU);\n+\t  if (!gimple_omp_for_combined_into_p (fd->for_stmt))\n+\t    {\n+\t      e = find_edge (entry_bb, last_bb);\n+\t      redirect_edge_succ (e, bb);\n+\t      set_immediate_dominator (CDI_DOMINATORS, bb, entry_bb);\n+\t      set_immediate_dominator (CDI_DOMINATORS, last_bb, init_bb);\n+\t    }\n+\n+\t  last_bb = bb;\n+\t}\n+    }\n   if (!broken_loop)\n     {\n       class loop *loop = alloc_loop ();\n@@ -7643,12 +7840,7 @@ expand_omp_for (struct omp_region *region, gimple *inner_stmt)\n     loops_state_set (LOOPS_NEED_FIXUP);\n \n   if (gimple_omp_for_kind (fd.for_stmt) == GF_OMP_FOR_KIND_SIMD)\n-    {\n-      if (fd.non_rect)\n-\tsorry_at (gimple_location (fd.for_stmt),\n-\t\t  \"non-rectangular %<simd%> not supported yet\");\n-      expand_omp_simd (region, &fd);\n-    }\n+    expand_omp_simd (region, &fd);\n   else if (gimple_omp_for_kind (fd.for_stmt) == GF_OMP_FOR_KIND_OACC_LOOP)\n     {\n       gcc_assert (!inner_stmt && !fd.non_rect);"}, {"sha": "b054961b1bcb4f2e293dec769ef67cd104b97b11", "filename": "gcc/omp-low.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ebf4f10de9257baffbe29cd0074893a01cfd83/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ebf4f10de9257baffbe29cd0074893a01cfd83/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=c2ebf4f10de9257baffbe29cd0074893a01cfd83", "patch": "@@ -3729,7 +3729,8 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       if ((gimple_omp_for_kind (as_a <gomp_for *> (stmt))\n \t   == GF_OMP_FOR_KIND_SIMD)\n \t  && omp_maybe_offloaded_ctx (ctx)\n-\t  && omp_max_simt_vf ())\n+\t  && omp_max_simt_vf ()\n+\t  && gimple_omp_for_collapse (stmt) == 1)\n \tscan_omp_simd (gsi, as_a <gomp_for *> (stmt), ctx);\n       else\n \tscan_omp_for (as_a <gomp_for *> (stmt), ctx);"}, {"sha": "9330aaa59b9aaba62bef14eb9bc44f2a87ea42ac", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-17.c", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ebf4f10de9257baffbe29cd0074893a01cfd83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ebf4f10de9257baffbe29cd0074893a01cfd83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-17.c?ref=c2ebf4f10de9257baffbe29cd0074893a01cfd83", "patch": "@@ -0,0 +1,304 @@\n+/* { dg-additional-options \"-fopenmp-simd -fno-tree-vectorize\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-final { scan-tree-dump \"vectorized \\(\\[4-9]\\|1\\[0-2]\\) loops\" \"vect\" { target i?86-*-* x86_64-*-* } } } */\n+\n+#include \"tree-vect.h\"\n+\n+int x, i, j;\n+volatile int a, b, c, d, e, f, g, h;\n+int k[11][101];\n+\n+__attribute__((noipa)) void\n+doit (void)\n+{\n+  int niters, err = 0;\n+  for (i = 1; i <= 10; i++)\n+    for (j = 1; j <= 10 * i; j++)\n+      {\n+\tk[i][j] = 1;\n+\tasm volatile (\"\" : : : \"memory\");\n+      }\n+  a = 1; b = 11; c = 1; d = 0; e = 1; f = 10; g = 1; h = 1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = 1; i <= 10; i++)\n+    for (j = 1; j <= 10 * i; j++)\n+      {\n+\terr |= (i < 1);\n+\terr |= (i > 10);\n+\terr |= (j < 1);\n+\terr |= (j > 10 * i);\n+\terr |= (k[i][j] != 1);\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 11 || j != 101 || x != 10340 || niters != 550 || err)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\terr |= (i < 1);\n+\terr |= (i > 10);\n+\terr |= (j < 1);\n+\terr |= (j > 10 * i);\n+\terr |= (k[i][j] != 2);\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 11 || j != 101 || x != 10340 || niters != 550 || err)\n+    abort ();\n+  for (i = 1; i <= 10; i++)\n+    for (j = 1; j <= 10 * i; j++)\n+      if (k[i][j] == 3)\n+\tk[i][j] = 0;\n+      else\n+\tabort ();\n+  for (i = 0; i < 11; i++)\n+    for (j = 0; j < 101; j++)\n+      if (k[i][j] != 0)\n+\tabort ();\n+  for (i = 0; i < 10; i++)\n+    for (j = 0; j < 10 * i; j++)\n+      {\n+        k[i][j] = 1;\n+\tasm volatile (\"\" : : : \"memory\");\n+      }\n+  a = 0; b = 10; c = 1; d = 0; e = 0; f = 10; g = 0; h = 1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = 0; i < 10; i++)\n+    for (j = 0; j < 10 * i; j++)\n+      {\n+\terr |= (i < 0);\n+\terr |= (i >= 10);\n+\terr |= (j < 0);\n+\terr |= (j >= 10 * i);\n+\terr |= (k[i][j] != 1);\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 10 || j != 90 || x != 9305 || niters != 450 || err)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\terr |= (i < 0);\n+\terr |= (i >= 10);\n+\terr |= (j < 0);\n+\terr |= (j >= 10 * i);\n+\terr |= (k[i][j] != 2);\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 10 || j != 90 || x != 9305 || niters != 450 || err)\n+    abort ();\n+  for (i = 0; i < 10; i++)\n+    for (j = 0; j < 10 * i; j++)\n+      if (k[i][j] == 3)\n+\tk[i][j] = 0;\n+      else\n+\tabort ();\n+  for (i = 0; i < 11; i++)\n+    for (j = 0; j < 101; j++)\n+      if (k[i][j] != 0)\n+\tabort ();\n+  for (i = 4; i < 10; i++)\n+    for (j = -9 + 2 * i; j < i; j++)\n+      {\n+        k[i][j + 1] = 1;\n+\tasm volatile (\"\" : : : \"memory\");\n+      }\n+  a = 4; b = 10; c = 1; d = 2; e = -9; f = 1; g = 0; h = 1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = 4; i < 10; i++)\n+    for (j = -9 + 2 * i; j < i; j++)\n+      {\n+\terr |= (i < 4);\n+\terr |= (i >= 10);\n+\terr |= (j < -9 + 2 * i);\n+\terr |= (j >= i);\n+\terr |= (k[i][j + 1] != 1);\n+\tk[i][j + 1]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (/*i != 10 || j != 9 || */x != 8199 || niters != 15 || err)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\terr |= (i < 4);\n+\terr |= (i >= 10);\n+\terr |= (j < -9 + 2 * i);\n+\terr |= (j >= i);\n+\terr |= (k[i][j + 1] != 2);\n+\tk[i][j + 1]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (/*i != 10 || j != 9 || */x != 8199 || niters != 15 || err)\n+    abort ();\n+  for (i = 4; i < 10; i++)\n+    for (j = -9 + 2 * i; j < i; j++)\n+      if (k[i][j + 1] == 3)\n+\tk[i][j + 1] = 0;\n+      else\n+\tabort ();\n+  for (i = 0; i < 11; i++)\n+    for (j = 0; j < 101; j++)\n+      if (k[i][j] != 0)\n+\tabort ();\n+  for (i = 1; i < 10; i += 2)\n+    for (j = 1; j < i + 1; j++)\n+      {\n+\tk[i][j] = 1;\n+\tasm volatile (\"\" : : : \"memory\");\n+      }\n+  a = 1; b = 10; c = 2; d = 0; e = 1; f = 1; g = 1; h = 1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = 1; i < 10; i += 2)\n+    for (j = 1; j < i + 1; j++)\n+      {\n+\terr |= (i < 1);\n+\terr |= (i >= 10);\n+\terr |= (j < 1);\n+\terr |= (j >= i + 1);\n+\terr |= (k[i][j] != 1);\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 11 || j != 10 || x != 9225 || niters != 25 || err)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\terr |= (i < 1);\n+\terr |= (i >= 10);\n+\terr |= (j < 1);\n+\terr |= (j >= i + 1);\n+\terr |= (k[i][j] != 2);\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 11 || j != 10 || x != 9225 || niters != 25 || err)\n+    abort ();\n+  for (i = 1; i < 10; i += 2)\n+    for (j = 1; j < i + 1; j++)\n+      if (k[i][j] == 3)\n+\tk[i][j] = 0;\n+      else\n+\tabort ();\n+  for (i = 0; i < 11; i++)\n+    for (j = 0; j < 101; j++)\n+      if (k[i][j] != 0)\n+\tabort ();\n+  for (j = -11; j >= -41; j -= 15)\n+    {\n+      k[0][-j] = 1;\n+      asm volatile (\"\" : : : \"memory\");\n+    }\n+  a = 4; b = 8; c = 12; d = -8; e = -9; f = -3; g = 6; h = 15;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = 4; i < 8; i += 12)\n+    for (j = -8 * i - 9; j < i * -3 + 6; j += 15)\n+      {\n+\terr |= (i != 4);\n+\terr |= (j < -41);\n+\terr |= (j > -11);\n+\terr |= (k[0][-j] != 1);\n+\tk[0][-j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 16 || j != 4 || x != 5109 || niters != 3 || err)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\terr |= (i != 4);\n+\terr |= (j < -41);\n+\terr |= (j > -11);\n+\terr |= (k[0][-j] != 2);\n+\tk[0][-j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 16 || j != 4 || x != 5109 || niters != 3 || err)\n+    abort ();\n+  for (j = -11; j >= -41; j -= 15)\n+    if (k[0][-j] == 3)\n+      k[0][-j] = 0;\n+    else\n+      abort ();\n+  for (j = -11; j >= -41; j--)\n+    if (k[0][-j] != 0)\n+      abort ();\n+  for (j = -34; j <= -7; j++)\n+    {\n+      k[0][-j] = 1;\n+      asm volatile (\"\" : : : \"memory\");\n+    }\n+  a = -13; b = 7; c = 12; d = 3; e = 5; f = 0; g = -6; h = 1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = -13; i < 7; i += 12)\n+    for (j = 3 * i + 5; j < -6; j++)\n+      {\n+\terr |= (i != -13);\n+\terr |= (j < -34);\n+\terr |= (j > -7);\n+\terr |= (k[0][-j] != 1);\n+\tk[0][-j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (/*i != 11 || j != 2 || */x != -12295 || niters != 28 || err)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\terr |= (i != -13);\n+\terr |= (j < -34);\n+\terr |= (j > -7);\n+\terr |= (k[0][-j] != 2);\n+\tk[0][-j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (/*i != 11 || j != 2 || */x != -12295 || niters != 28 || err)\n+    abort ();\n+  for (j = -34; j <= -7; j++)\n+    if (k[0][-j] == 3)\n+      k[0][-j] = 0;\n+    else\n+      abort ();\n+}\n+\n+int\n+main ()\n+{\n+  check_vect ();\n+  doit ();\n+  return 0;\n+}"}, {"sha": "052da71be0f29a5b0c14c633d08d7d740c0216cf", "filename": "libgomp/testsuite/libgomp.c/loop-25.c", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ebf4f10de9257baffbe29cd0074893a01cfd83/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ebf4f10de9257baffbe29cd0074893a01cfd83/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-25.c?ref=c2ebf4f10de9257baffbe29cd0074893a01cfd83", "patch": "@@ -0,0 +1,296 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-O2 -fopenmp -fdump-tree-vect-details\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+int x, i, j;\n+volatile int a, b, c, d, e, f, g, h;\n+int k[11][101];\n+extern void abort (void);\n+\n+int\n+main ()\n+{\n+  int niters, err = 0;\n+  for (i = 1; i <= 10; i++)\n+    for (j = 1; j <= 10 * i; j++)\n+      {\n+\tk[i][j] = 1;\n+\tasm volatile (\"\" : : : \"memory\");\n+      }\n+  a = 1; b = 11; c = 1; d = 0; e = 1; f = 10; g = 1; h = 1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = 1; i <= 10; i++)\n+    for (j = 1; j <= 10 * i; j++)\n+      {\n+\terr |= (i < 1);\n+\terr |= (i > 10);\n+\terr |= (j < 1);\n+\terr |= (j > 10 * i);\n+\terr |= (k[i][j] != 1);\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 11 || j != 101 || x != 10340 || niters != 550 || err)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\terr |= (i < 1);\n+\terr |= (i > 10);\n+\terr |= (j < 1);\n+\terr |= (j > 10 * i);\n+\terr |= (k[i][j] != 2);\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 11 || j != 101 || x != 10340 || niters != 550 || err)\n+    abort ();\n+  for (i = 1; i <= 10; i++)\n+    for (j = 1; j <= 10 * i; j++)\n+      if (k[i][j] == 3)\n+\tk[i][j] = 0;\n+      else\n+\tabort ();\n+  for (i = 0; i < 11; i++)\n+    for (j = 0; j < 101; j++)\n+      if (k[i][j] != 0)\n+\tabort ();\n+  for (i = 0; i < 10; i++)\n+    for (j = 0; j < 10 * i; j++)\n+      {\n+        k[i][j] = 1;\n+\tasm volatile (\"\" : : : \"memory\");\n+      }\n+  a = 0; b = 10; c = 1; d = 0; e = 0; f = 10; g = 0; h = 1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = 0; i < 10; i++)\n+    for (j = 0; j < 10 * i; j++)\n+      {\n+\terr |= (i < 0);\n+\terr |= (i >= 10);\n+\terr |= (j < 0);\n+\terr |= (j >= 10 * i);\n+\terr |= (k[i][j] != 1);\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 10 || j != 90 || x != 9305 || niters != 450 || err)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\terr |= (i < 0);\n+\terr |= (i >= 10);\n+\terr |= (j < 0);\n+\terr |= (j >= 10 * i);\n+\terr |= (k[i][j] != 2);\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 10 || j != 90 || x != 9305 || niters != 450 || err)\n+    abort ();\n+  for (i = 0; i < 10; i++)\n+    for (j = 0; j < 10 * i; j++)\n+      if (k[i][j] == 3)\n+\tk[i][j] = 0;\n+      else\n+\tabort ();\n+  for (i = 0; i < 11; i++)\n+    for (j = 0; j < 101; j++)\n+      if (k[i][j] != 0)\n+\tabort ();\n+  for (i = 4; i < 10; i++)\n+    for (j = -9 + 2 * i; j < i; j++)\n+      {\n+        k[i][j + 1] = 1;\n+\tasm volatile (\"\" : : : \"memory\");\n+      }\n+  a = 4; b = 10; c = 1; d = 2; e = -9; f = 1; g = 0; h = 1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = 4; i < 10; i++)\n+    for (j = -9 + 2 * i; j < i; j++)\n+      {\n+\terr |= (i < 4);\n+\terr |= (i >= 10);\n+\terr |= (j < -9 + 2 * i);\n+\terr |= (j >= i);\n+\terr |= (k[i][j + 1] != 1);\n+\tk[i][j + 1]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (/*i != 10 || j != 9 || */x != 8199 || niters != 15 || err)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\terr |= (i < 4);\n+\terr |= (i >= 10);\n+\terr |= (j < -9 + 2 * i);\n+\terr |= (j >= i);\n+\terr |= (k[i][j + 1] != 2);\n+\tk[i][j + 1]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (/*i != 10 || j != 9 || */x != 8199 || niters != 15 || err)\n+    abort ();\n+  for (i = 4; i < 10; i++)\n+    for (j = -9 + 2 * i; j < i; j++)\n+      if (k[i][j + 1] == 3)\n+\tk[i][j + 1] = 0;\n+      else\n+\tabort ();\n+  for (i = 0; i < 11; i++)\n+    for (j = 0; j < 101; j++)\n+      if (k[i][j] != 0)\n+\tabort ();\n+  for (i = 1; i < 10; i += 2)\n+    for (j = 1; j < i + 1; j++)\n+      {\n+\tk[i][j] = 1;\n+\tasm volatile (\"\" : : : \"memory\");\n+      }\n+  a = 1; b = 10; c = 2; d = 0; e = 1; f = 1; g = 1; h = 1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = 1; i < 10; i += 2)\n+    for (j = 1; j < i + 1; j++)\n+      {\n+\terr |= (i < 1);\n+\terr |= (i >= 10);\n+\terr |= (j < 1);\n+\terr |= (j >= i + 1);\n+\terr |= (k[i][j] != 1);\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 11 || j != 10 || x != 9225 || niters != 25 || err)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\terr |= (i < 1);\n+\terr |= (i >= 10);\n+\terr |= (j < 1);\n+\terr |= (j >= i + 1);\n+\terr |= (k[i][j] != 2);\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 11 || j != 10 || x != 9225 || niters != 25 || err)\n+    abort ();\n+  for (i = 1; i < 10; i += 2)\n+    for (j = 1; j < i + 1; j++)\n+      if (k[i][j] == 3)\n+\tk[i][j] = 0;\n+      else\n+\tabort ();\n+  for (i = 0; i < 11; i++)\n+    for (j = 0; j < 101; j++)\n+      if (k[i][j] != 0)\n+\tabort ();\n+  for (j = -11; j >= -41; j -= 15)\n+    {\n+      k[0][-j] = 1;\n+      asm volatile (\"\" : : : \"memory\");\n+    }\n+  a = 4; b = 8; c = 12; d = -8; e = -9; f = -3; g = 6; h = 15;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = 4; i < 8; i += 12)\n+    for (j = -8 * i - 9; j < i * -3 + 6; j += 15)\n+      {\n+\terr |= (i != 4);\n+\terr |= (j < -41);\n+\terr |= (j > -11);\n+\terr |= (k[0][-j] != 1);\n+\tk[0][-j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 16 || j != 4 || x != 5109 || niters != 3 || err)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\terr |= (i != 4);\n+\terr |= (j < -41);\n+\terr |= (j > -11);\n+\terr |= (k[0][-j] != 2);\n+\tk[0][-j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 16 || j != 4 || x != 5109 || niters != 3 || err)\n+    abort ();\n+  for (j = -11; j >= -41; j -= 15)\n+    if (k[0][-j] == 3)\n+      k[0][-j] = 0;\n+    else\n+      abort ();\n+  for (j = -11; j >= -41; j--)\n+    if (k[0][-j] != 0)\n+      abort ();\n+  for (j = -34; j <= -7; j++)\n+    {\n+      k[0][-j] = 1;\n+      asm volatile (\"\" : : : \"memory\");\n+    }\n+  a = -13; b = 7; c = 12; d = 3; e = 5; f = 0; g = -6; h = 1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = -13; i < 7; i += 12)\n+    for (j = 3 * i + 5; j < -6; j++)\n+      {\n+\terr |= (i != -13);\n+\terr |= (j < -34);\n+\terr |= (j > -7);\n+\terr |= (k[0][-j] != 1);\n+\tk[0][-j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (/*i != 11 || j != 2 || */x != -12295 || niters != 28 || err)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for simd collapse(2) lastprivate (i, j, x) reduction(+:niters) reduction(|:err)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\terr |= (i != -13);\n+\terr |= (j < -34);\n+\terr |= (j > -7);\n+\terr |= (k[0][-j] != 2);\n+\tk[0][-j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (/*i != 11 || j != 2 || */x != -12295 || niters != 28 || err)\n+    abort ();\n+  for (j = -34; j <= -7; j++)\n+    if (k[0][-j] == 3)\n+      k[0][-j] = 0;\n+    else\n+      abort ();\n+  return 0;\n+}"}]}