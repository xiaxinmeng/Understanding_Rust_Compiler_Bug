{"sha": "93e2e0465e67d3e26f839c3069d0618708054b24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNlMmUwNDY1ZTY3ZDNlMjZmODM5YzMwNjlkMDYxODcwODA1NGIyNA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2014-08-31T06:32:06Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2014-08-31T06:32:06Z"}, "message": "trans-decl.c (gfc_build_builtin_function_decls): Add may_require_tmp dummy argument.\n\n2014-08-31  Tobias Burnus  <burnus@net-b.de>\n\ngcc/fortran/\n        * trans-decl.c (gfc_build_builtin_function_decls): Add\n        may_require_tmp dummy argument.\n        * trans-intrinsic.c (gfc_conv_intrinsic_caf_get,\n        conv_caf_send): Handle may_require_tmp argument.\n        (gfc_conv_intrinsic_function): Update call.\n        * gfortran.texi (_gfortran_caf_send, _gfortran_caf_get,\n        _gfortran_caf_sendget): Update interface description.\n\ngcc/testsuite/\n        * gfortran.dg/coarray_lib_comm_1.f90: New.\n\nlibgfortran/\n        * caf/libcaf.h (_gfortran_caf_send, _gfortran_caf_get,\n        _gfortran_caf_sendget): Update prototype.\n        * caf/single.c (_gfortran_caf_send, _gfortran_caf_get,\n        _gfortran_caf_sendget): Handle may_require_tmp.\n\nFrom-SVN: r214764", "tree": {"sha": "7515b78b346b4c72b9972ea0c1e2d9756f6f8fa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7515b78b346b4c72b9972ea0c1e2d9756f6f8fa8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93e2e0465e67d3e26f839c3069d0618708054b24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93e2e0465e67d3e26f839c3069d0618708054b24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93e2e0465e67d3e26f839c3069d0618708054b24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93e2e0465e67d3e26f839c3069d0618708054b24/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5c535ce21614d6c7f27918b4ba1162aec43d481d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c535ce21614d6c7f27918b4ba1162aec43d481d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c535ce21614d6c7f27918b4ba1162aec43d481d"}], "stats": {"total": 357, "additions": 317, "deletions": 40}, "files": [{"sha": "57b76bf7af38abb19ca9a26c5de9ac6af2a9a731", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e2e0465e67d3e26f839c3069d0618708054b24/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e2e0465e67d3e26f839c3069d0618708054b24/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=93e2e0465e67d3e26f839c3069d0618708054b24", "patch": "@@ -1,3 +1,13 @@\n+2014-08-31  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* trans-decl.c (gfc_build_builtin_function_decls): Add\n+\tmay_require_tmp dummy argument.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_caf_get,\n+\tconv_caf_send): Handle may_require_tmp argument.\n+\t(gfc_conv_intrinsic_function): Update call.\n+\t* gfortran.texi (_gfortran_caf_send, _gfortran_caf_get,\n+\t_gfortran_caf_sendget): Update interface description.\n+\n 2014-08-30  Tobias Burnus  <burnus@net-b.de>\n \n \t* trans.h (gfc_caf_get_image_index,"}, {"sha": "d02452c04e3b3cbc2a84482830aedcd1d6b2fbc4", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 51, "deletions": 18, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e2e0465e67d3e26f839c3069d0618708054b24/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e2e0465e67d3e26f839c3069d0618708054b24/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=93e2e0465e67d3e26f839c3069d0618708054b24", "patch": "@@ -3448,7 +3448,7 @@ to a remote image identified by the image_index.\n @item @emph{Syntax}:\n @code{void _gfortran_caf_send (caf_token_t token, size_t offset,\n int image_index, gfc_descriptor_t *dest, caf_vector_t *dst_vector,\n-gfc_descriptor_t *src, int dst_kind, int src_kind)}\n+gfc_descriptor_t *src, int dst_kind, int src_kind, bool may_require_tmp)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n@@ -3466,15 +3466,26 @@ triplet of the dest argument.\n transferred to the remote image\n @item @var{dst_kind} @tab Kind of the destination argument\n @item @var{src_kind} @tab Kind of the source argument\n+@item @var{may_require_tmp} @tab The variable is false it is known at compile\n+time that the @var{dest} and @var{src} either cannot overlap or overlap (fully\n+or partially) such that walking @var{src} and @var{dest} in element wise\n+element order (honoring the stride value) will not lead to wrong results.\n+Otherwise, the value is true.\n @end multitable\n \n @item @emph{NOTES}\n It is permitted to have image_id equal the current image; the memory of the\n send-to and the send-from might (partially) overlap in that case. The\n-implementation has to take care that it handles this case. Note that the\n-assignment of a scalar to an array is permitted. In addition, the library has\n-to handle numeric-type conversion and for strings, padding and different\n-character kinds.\n+implementation has to take care that it handles this case, e.g. using\n+@code{memmove} which handles (partially) overlapping memory. If\n+@var{may_require_tmp} is true, the library might additionally create a\n+temporary variable, unless additional checks show that this is not required\n+(e.g. because walking backward is possible or because both arrays are\n+contiguous and @code{memmove} takes care of overlap issues).\n+\n+Note that the assignment of a scalar to an array is permitted. In addition,\n+the library has to handle numeric-type conversion and for strings, padding\n+and different character kinds.\n @end table\n \n \n@@ -3490,7 +3501,7 @@ image identified by the image_index.\n @item @emph{Syntax}:\n @code{void _gfortran_caf_get_desc (caf_token_t token, size_t offset,\n int image_index, gfc_descriptor_t *src, caf_vector_t *src_vector,\n-gfc_descriptor_t *dest, int src_kind, int dst_kind)}\n+gfc_descriptor_t *dest, int src_kind, int dst_kind, bool may_require_tmp)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n@@ -3508,14 +3519,25 @@ subscript of the destination array; the values are relative to the dimension\n triplet of the dest argument.\n @item @var{dst_kind} @tab Kind of the destination argument\n @item @var{src_kind} @tab Kind of the source argument\n+@item @var{may_require_tmp} @tab The variable is false it is known at compile\n+time that the @var{dest} and @var{src} either cannot overlap or overlap (fully\n+or partially) such that walking @var{src} and @var{dest} in element wise\n+element order (honoring the stride value) will not lead to wrong results.\n+Otherwise, the value is true.\n @end multitable\n \n @item @emph{NOTES}\n It is permitted to have image_id equal the current image; the memory of the\n send-to and the send-from might (partially) overlap in that case. The\n-implementation has to take care that it handles this case. Note that the\n-library has to handle numeric-type conversion and for strings, padding\n-and different character kinds.\n+implementation has to take care that it handles this case, e.g. using\n+@code{memmove} which handles (partially) overlapping memory. If\n+@var{may_require_tmp} is true, the library might additionally create a\n+temporary variable, unless additional checks show that this is not required\n+(e.g. because walking backward is possible or because both arrays are\n+contiguous and @code{memmove} takes care of overlap issues).\n+\n+Note that the library has to handle numeric-type conversion and for strings,\n+padding and different character kinds.\n @end table\n \n \n@@ -3533,7 +3555,8 @@ dst_image_index.\n @code{void _gfortran_caf_sendget (caf_token_t dst_token, size_t dst_offset,\n int dst_image_index, gfc_descriptor_t *dest, caf_vector_t *dst_vector,\n caf_token_t src_token, size_t src_offset, int src_image_index,\n-gfc_descriptor_t *src, caf_vector_t *src_vector, int dst_kind, int src_kind)}\n+gfc_descriptor_t *src, caf_vector_t *src_vector, int dst_kind, int src_kind,\n+bool may_require_tmp)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n@@ -3543,7 +3566,7 @@ destination coarray.\n shifted compared to the base address of the destination coarray.\n @item @var{dst_image_index} @tab The ID of the destination remote image; must\n be a positive number.\n-@item @var{dst_dest} @tab intent(in) Array descriptor for the destination\n+@item @var{dest} @tab intent(in) Array descriptor for the destination\n remote image for the bounds and the size. The base_addr shall not be accessed.\n @item @var{dst_vector} @tab intent(int)  If not NULL, it contains the vector\n subscript of the destination array; the values are relative to the dimension\n@@ -3553,21 +3576,31 @@ triplet of the dest argument.\n compared to the base address of the source coarray.\n @item @var{src_image_index} @tab The ID of the source remote image; must be a\n positive number.\n-@item @var{src_dest} @tab intent(in) Array descriptor of the local array to be\n+@item @var{src} @tab intent(in) Array descriptor of the local array to be\n transferred to the remote image.\n @item @var{src_vector} @tab intent(in) Array descriptor of the local array to\n be transferred to the remote image\n @item @var{dst_kind} @tab Kind of the destination argument\n @item @var{src_kind} @tab Kind of the source argument\n+@item @var{may_require_tmp} @tab The variable is false it is known at compile\n+time that the @var{dest} and @var{src} either cannot overlap or overlap (fully\n+or partially) such that walking @var{src} and @var{dest} in element wise\n+element order (honoring the stride value) will not lead to wrong results.\n+Otherwise, the value is true.\n @end multitable\n \n @item @emph{NOTES}\n-It is permitted to have image_id equal the current image; the memory of the\n-send-to and the send-from might (partially) overlap in that case. The\n-implementation has to take care that it handles this case. Note that the\n-assignment of a scalar to an array is permitted. In addition, the library has\n-to handle numeric-type conversion and for strings, padding and different\n-character kinds.\n+It is permitted to have image_ids equal; the memory of the send-to and the\n+send-from might (partially) overlap in that case. The implementation has to\n+take care that it handles this case, e.g. using @code{memmove} which handles\n+(partially) overlapping memory. If @var{may_require_tmp} is true, the library\n+might additionally create a temporary variable, unless additional checks show\n+that this is not required (e.g. because walking backward is possible or because\n+both arrays are contiguous and @code{memmove} takes care of overlap issues).\n+\n+Note that the assignment of a scalar to an array is permitted. In addition,\n+the library has to handle numeric-type conversion and for strings, padding and\n+different character kinds.\n @end table\n \n "}, {"sha": "6afa6f3b6963ac3e65993290a9f628b6e74f8edd", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e2e0465e67d3e26f839c3069d0618708054b24/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e2e0465e67d3e26f839c3069d0618708054b24/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=93e2e0465e67d3e26f839c3069d0618708054b24", "patch": "@@ -3353,20 +3353,23 @@ gfc_build_builtin_function_decls (void)\n         ppvoid_type_node, pint_type, pchar_type_node, integer_type_node);\n \n       gfor_fndecl_caf_get = gfc_build_library_function_decl_with_spec (\n-\tget_identifier (PREFIX(\"caf_get\")), \".R.RRRW\", void_type_node, 8,\n+\tget_identifier (PREFIX(\"caf_get\")), \".R.RRRW\", void_type_node, 9,\n         pvoid_type_node, size_type_node, integer_type_node, pvoid_type_node,\n-\tpvoid_type_node, pvoid_type_node, integer_type_node, integer_type_node);\n+\tpvoid_type_node, pvoid_type_node, integer_type_node, integer_type_node,\n+\tboolean_type_node);\n \n       gfor_fndecl_caf_send = gfc_build_library_function_decl_with_spec (\n-\tget_identifier (PREFIX(\"caf_send\")), \".R.RRRR\", void_type_node, 8,\n+\tget_identifier (PREFIX(\"caf_send\")), \".R.RRRR\", void_type_node, 9,\n         pvoid_type_node, size_type_node, integer_type_node, pvoid_type_node,\n-\tpvoid_type_node, pvoid_type_node, integer_type_node, integer_type_node);\n+\tpvoid_type_node, pvoid_type_node, integer_type_node, integer_type_node,\n+\tboolean_type_node);\n \n       gfor_fndecl_caf_sendget = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"caf_sendget\")), \".R.RRRR.RRR\", void_type_node,\n-\t12, pvoid_type_node, size_type_node, integer_type_node, pvoid_type_node,\n+\t13, pvoid_type_node, size_type_node, integer_type_node, pvoid_type_node,\n \tpvoid_type_node, pvoid_type_node, size_type_node, integer_type_node,\n-\tpvoid_type_node, pvoid_type_node, integer_type_node, integer_type_node);\n+\tpvoid_type_node, pvoid_type_node, integer_type_node, integer_type_node,\n+\tboolean_type_node);\n \n       gfor_fndecl_caf_sync_all = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"caf_sync_all\")), \".WW\", void_type_node,"}, {"sha": "a13b11356af646a224412a23ec9dd7099f131ad0", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e2e0465e67d3e26f839c3069d0618708054b24/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e2e0465e67d3e26f839c3069d0618708054b24/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=93e2e0465e67d3e26f839c3069d0618708054b24", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"trans-const.h\"\n #include \"trans-types.h\"\n #include \"trans-array.h\"\n+#include \"dependency.h\"\t/* For CAF array alias analysis.  */\n /* Only for gfc_trans_assign and gfc_trans_pointer_assign.  */\n #include \"trans-stmt.h\"\n #include \"tree-nested.h\"\n@@ -1086,7 +1087,8 @@ conv_caf_vector_subscript (stmtblock_t *block, tree desc, gfc_array_ref *ar)\n /* Get data from a remote coarray.  */\n \n static void\n-gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind)\n+gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind,\n+\t\t\t    tree may_require_tmp)\n {\n   gfc_expr *array_expr;\n   gfc_se argse;\n@@ -1193,9 +1195,13 @@ gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind)\n   image_index = gfc_caf_get_image_index (&se->pre, array_expr, caf_decl);\n   gfc_get_caf_token_offset (&token, &offset, caf_decl, argse.expr, array_expr);\n \n-  tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_get, 8,\n+  /* No overlap possible as we have generated a temporary.  */\n+  if (lhs == NULL_TREE)\n+    may_require_tmp = boolean_false_node;\n+\n+  tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_get, 9,\n \t\t\t     token, offset, image_index, argse.expr, vec,\n-\t\t\t     dst_var, kind, lhs_kind);\n+\t\t\t     dst_var, kind, lhs_kind, may_require_tmp);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   if (se->ss)\n@@ -1215,13 +1221,16 @@ conv_caf_send (gfc_code *code) {\n   gfc_se lhs_se, rhs_se;\n   stmtblock_t block;\n   tree caf_decl, token, offset, image_index, tmp, lhs_kind, rhs_kind;\n+  tree may_require_tmp;\n   tree lhs_type = NULL_TREE;\n   tree vec = null_pointer_node, rhs_vec = null_pointer_node;\n \n   gcc_assert (gfc_option.coarray == GFC_FCOARRAY_LIB);\n \n   lhs_expr = code->ext.actual->expr;\n   rhs_expr = code->ext.actual->next->expr;\n+  may_require_tmp = gfc_check_dependency (lhs_expr, rhs_expr, false) == 0\n+\t\t    ? boolean_false_node : boolean_true_node;\n   gfc_init_block (&block);\n \n   /* LHS.  */\n@@ -1275,7 +1284,8 @@ conv_caf_send (gfc_code *code) {\n     {\n       gcc_assert (gfc_is_coindexed (rhs_expr));\n       gfc_init_se (&rhs_se, NULL);\n-      gfc_conv_intrinsic_caf_get (&rhs_se, rhs_expr, lhs_se.expr, lhs_kind);\n+      gfc_conv_intrinsic_caf_get (&rhs_se, rhs_expr, lhs_se.expr, lhs_kind,\n+\t\t\t\t  may_require_tmp);\n       gfc_add_block_to_block (&block, &rhs_se.pre);\n       gfc_add_block_to_block (&block, &rhs_se.post);\n       gfc_add_block_to_block (&block, &lhs_se.post);\n@@ -1342,9 +1352,9 @@ conv_caf_send (gfc_code *code) {\n   rhs_kind = build_int_cst (integer_type_node, rhs_expr->ts.kind);\n \n   if (!gfc_is_coindexed (rhs_expr))\n-    tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_send, 8, token,\n+    tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_send, 9, token,\n \t\t\t     offset, image_index, lhs_se.expr, vec,\n-\t\t\t     rhs_se.expr, lhs_kind, rhs_kind);\n+\t\t\t     rhs_se.expr, lhs_kind, rhs_kind, may_require_tmp);\n   else\n     {\n       tree rhs_token, rhs_offset, rhs_image_index;\n@@ -1355,10 +1365,11 @@ conv_caf_send (gfc_code *code) {\n       rhs_image_index = gfc_caf_get_image_index (&block, rhs_expr, caf_decl);\n       gfc_get_caf_token_offset (&rhs_token, &rhs_offset, caf_decl, rhs_se.expr,\n \t\t\t\trhs_expr);\n-      tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_sendget, 12,\n+      tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_sendget, 13,\n \t\t\t\t token, offset, image_index, lhs_se.expr, vec,\n \t\t\t\t rhs_token, rhs_offset, rhs_image_index,\n-\t\t\t\t rhs_se.expr, rhs_vec, lhs_kind, rhs_kind);\n+\t\t\t\t rhs_se.expr, rhs_vec, lhs_kind, rhs_kind,\n+\t\t\t\t may_require_tmp);\n     }\n   gfc_add_expr_to_block (&block, tmp);\n   gfc_add_block_to_block (&block, &lhs_se.post);\n@@ -7383,7 +7394,7 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       break;\n \n     case GFC_ISYM_CAF_GET:\n-      gfc_conv_intrinsic_caf_get (se, expr, NULL_TREE, NULL_TREE);\n+      gfc_conv_intrinsic_caf_get (se, expr, NULL_TREE, NULL_TREE, NULL_TREE);\n       break;\n \n     case GFC_ISYM_CMPLX:"}, {"sha": "8cc10e7f699dea18bc756bad3ed5a6b072041a8d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e2e0465e67d3e26f839c3069d0618708054b24/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e2e0465e67d3e26f839c3069d0618708054b24/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=93e2e0465e67d3e26f839c3069d0618708054b24", "patch": "@@ -1,3 +1,7 @@\n+2014-08-31  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.dg/coarray_lib_comm_1.f90: New.\n+\n 2014-08-30  Andrew Pinski  <apinski@cavium.com>\n \n \t* gcc.c-torture/execute/20140828-1.c: New testcase."}, {"sha": "1db40feb7f9906d5910df95a2e031e21c2e47ee6", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e2e0465e67d3e26f839c3069d0618708054b24/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_comm_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e2e0465e67d3e26f839c3069d0618708054b24/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_comm_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_comm_1.f90?ref=93e2e0465e67d3e26f839c3069d0618708054b24", "patch": "@@ -0,0 +1,46 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original -fcoarray=lib -lcaf_single\" }\n+!\n+! Some dependency-analysis check for coarray communication\n+!\n+integer, target, save :: A(10)[*]\n+integer, pointer :: P(:)\n+integer, save :: B(10)[*]\n+\n+A = [1,2,3,4,5,6,7,8,9,10]\n+B = [1,2,3,4,5,6,7,8,9,10]\n+A(10:2:-1) = A(9:1:-1)[1] ! 0\n+B(10:2:-1) = B(9:1:-1)\n+if (any (A-B /= 0)) call abort\n+\n+A = [1,2,3,4,5,6,7,8,9,10]\n+B = [1,2,3,4,5,6,7,8,9,10]\n+A(9:1:-1) = A(10:2:-1)[1] ! 1\n+B(9:1:-1) = B(10:2:-1)\n+if (any (A-B /= 0)) call abort\n+\n+A = [1,2,3,4,5,6,7,8,9,10]\n+B = [1,2,3,4,5,6,7,8,9,10]\n+allocate(P(10))\n+P(:) = A(:)[1] ! 1\n+if (any (A-B /= 0)) call abort\n+\n+A = [1,2,3,4,5,6,7,8,9,10]\n+B = [1,2,3,4,5,6,7,8,9,10]\n+allocate(P(10))\n+P(:) = B(:)[1] ! 0\n+\n+A = [1,2,3,4,5,6,7,8,9,10]\n+B = [1,2,3,4,5,6,7,8,9,10]\n+A(1:5)[1] = A(3:7)[1] ! 1\n+B(1:5) = B(3:7)\n+if (any (A-B /= 0)) call abort\n+end\n+\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_get \\\\\\(caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, &parm.\\[0-9\\]+, 4, 4, 0\\\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_get \\\\\\(caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, &parm.\\[0-9\\]+, 4, 4, 1\\\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_get \\\\\\(caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, &p, 4, 4, 1\\\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_get \\\\\\(caf_token.1, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) b, 1, &parm.\\[0-9\\]+, 0B, &p, 4, 4, 0\\\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_sendget \\\\\\(caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, 4, 4, 0\\\\\\);\" 1 \"original\" } }\n+\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "b79790e3f3c69a1b9ec5e5a1ae5fff529df02b00", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e2e0465e67d3e26f839c3069d0618708054b24/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e2e0465e67d3e26f839c3069d0618708054b24/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=93e2e0465e67d3e26f839c3069d0618708054b24", "patch": "@@ -1,3 +1,10 @@\n+2014-08-31  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* caf/libcaf.h (_gfortran_caf_send, _gfortran_caf_get,\n+\t_gfortran_caf_sendget): Update prototype.\n+\t* caf/single.c (_gfortran_caf_send, _gfortran_caf_get,\n+\t_gfortran_caf_sendget): Handle may_require_tmp.\n+\n 2014-08-20  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR libgfortran/62188"}, {"sha": "0f3398ac6325d5a7d2cc8ae175a43bb39c4623be", "filename": "libgfortran/caf/libcaf.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e2e0465e67d3e26f839c3069d0618708054b24/libgfortran%2Fcaf%2Flibcaf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e2e0465e67d3e26f839c3069d0618708054b24/libgfortran%2Fcaf%2Flibcaf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Flibcaf.h?ref=93e2e0465e67d3e26f839c3069d0618708054b24", "patch": "@@ -114,12 +114,12 @@ void _gfortran_caf_co_max (gfc_descriptor_t *, int, int *, char *,\n \t\t\t   int, int);\n \n void _gfortran_caf_get (caf_token_t, size_t, int, gfc_descriptor_t *,\n-                        caf_vector_t *, gfc_descriptor_t *, int, int);\n+                        caf_vector_t *, gfc_descriptor_t *, int, int, bool);\n void _gfortran_caf_send (caf_token_t, size_t, int, gfc_descriptor_t *,\n-\t\t\t caf_vector_t *, gfc_descriptor_t *, int, int);\n+\t\t\t caf_vector_t *, gfc_descriptor_t *, int, int, bool);\n void _gfortran_caf_sendget (caf_token_t, size_t, int, gfc_descriptor_t *,\n \t\t\t    caf_vector_t *, caf_token_t, size_t, int,\n-\t\t\t    gfc_descriptor_t *, caf_vector_t *, int, int);\n+\t\t\t    gfc_descriptor_t *, caf_vector_t *, int, int, bool);\n \n void _gfortran_caf_atomic_define (caf_token_t, size_t, int, void *, int *,\n \t\t\t\t  int, int);"}, {"sha": "773941bc086b0a24dfd6ea3f43dfa84068ff61f0", "filename": "libgfortran/caf/single.c", "status": "modified", "additions": 167, "deletions": 4, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e2e0465e67d3e26f839c3069d0618708054b24/libgfortran%2Fcaf%2Fsingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e2e0465e67d3e26f839c3069d0618708054b24/libgfortran%2Fcaf%2Fsingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Fsingle.c?ref=93e2e0465e67d3e26f839c3069d0618708054b24", "patch": "@@ -533,7 +533,8 @@ _gfortran_caf_get (caf_token_t token, size_t offset,\n \t\t   int image_index __attribute__ ((unused)),\n \t\t   gfc_descriptor_t *src,\n \t\t   caf_vector_t *src_vector __attribute__ ((unused)),\n-\t\t   gfc_descriptor_t *dest, int src_kind, int dst_kind)\n+\t\t   gfc_descriptor_t *dest, int src_kind, int dst_kind,\n+\t\t   bool may_require_tmp)\n {\n   /* FIXME: Handle vector subscripts.  */\n   size_t i, k, size;\n@@ -584,6 +585,82 @@ _gfortran_caf_get (caf_token_t token, size_t offset,\n   if (size == 0)\n     return;\n \n+  if (may_require_tmp)\n+    {\n+      ptrdiff_t array_offset_sr, array_offset_dst;\n+      void *tmp = malloc (size*src_size);\n+\n+      array_offset_dst = 0;\n+      for (i = 0; i < size; i++)\n+\t{\n+\t  ptrdiff_t array_offset_sr = 0;\n+\t  ptrdiff_t stride = 1;\n+\t  ptrdiff_t extent = 1;\n+\t  for (j = 0; j < GFC_DESCRIPTOR_RANK (src)-1; j++)\n+\t    {\n+\t      array_offset_sr += ((i / (extent*stride))\n+\t\t\t\t  % (src->dim[j]._ubound\n+\t\t\t\t    - src->dim[j].lower_bound + 1))\n+\t\t\t\t * src->dim[j]._stride;\n+\t      extent = (src->dim[j]._ubound - src->dim[j].lower_bound + 1);\n+\t      stride = src->dim[j]._stride;\n+\t    }\n+\t  array_offset_sr += (i / extent) * src->dim[rank-1]._stride;\n+\t  void *sr = (void *)((char *) TOKEN (token) + offset\n+\t\t\t  + array_offset_sr*GFC_DESCRIPTOR_SIZE (src));\n+          memcpy ((void *) ((char *) tmp + array_offset_dst), sr, src_size);\n+          array_offset_dst += src_size;\n+\t}\n+\n+      array_offset_sr = 0;\n+      for (i = 0; i < size; i++)\n+\t{\n+\t  ptrdiff_t array_offset_dst = 0;\n+\t  ptrdiff_t stride = 1;\n+\t  ptrdiff_t extent = 1;\n+\t  for (j = 0; j < rank-1; j++)\n+\t    {\n+\t      array_offset_dst += ((i / (extent*stride))\n+\t\t\t\t   % (dest->dim[j]._ubound\n+\t\t\t\t      - dest->dim[j].lower_bound + 1))\n+\t\t\t\t  * dest->dim[j]._stride;\n+\t      extent = (dest->dim[j]._ubound - dest->dim[j].lower_bound + 1);\n+\t      stride = dest->dim[j]._stride;\n+\t    }\n+\t  array_offset_dst += (i / extent) * dest->dim[rank-1]._stride;\n+\t  void *dst = dest->base_addr\n+\t\t      + array_offset_dst*GFC_DESCRIPTOR_SIZE (dest);\n+          void *sr = tmp + array_offset_sr;\n+\n+\t  if (GFC_DESCRIPTOR_TYPE (dest) == GFC_DESCRIPTOR_TYPE (src)\n+\t      && dst_kind == src_kind)\n+\t    {\n+\t      memmove (dst, sr, dst_size > src_size ? src_size : dst_size);\n+\t      if (GFC_DESCRIPTOR_TYPE (dest) == BT_CHARACTER\n+\t          && dst_size > src_size)\n+\t\t{\n+\t\t  if (dst_kind == 1)\n+\t\t    memset ((void*)(char*) dst + src_size, ' ',\n+\t\t\t    dst_size-src_size);\n+\t\t  else /* dst_kind == 4.  */\n+\t\t    for (k = src_size/4; k < dst_size/4; k++)\n+\t\t      ((int32_t*) dst)[k] = (int32_t) ' ';\n+\t\t}\n+\t    }\n+\t  else if (GFC_DESCRIPTOR_TYPE (dest) == BT_CHARACTER && dst_kind == 1)\n+\t    assign_char1_from_char4 (dst_size, src_size, dst, sr);\n+\t  else if (GFC_DESCRIPTOR_TYPE (dest) == BT_CHARACTER)\n+\t    assign_char4_from_char1 (dst_size, src_size, dst, sr);\n+\t  else\n+\t    convert_type (dst, GFC_DESCRIPTOR_TYPE (dest), dst_kind,\n+\t\t\t  sr, GFC_DESCRIPTOR_TYPE (src), src_kind);\n+          array_offset_sr += src_size;\n+\t}\n+\n+      free (tmp);\n+      return;\n+    }\n+\n   for (i = 0; i < size; i++)\n     {\n       ptrdiff_t array_offset_dst = 0;\n@@ -646,7 +723,8 @@ _gfortran_caf_send (caf_token_t token, size_t offset,\n \t\t    int image_index __attribute__ ((unused)),\n \t\t    gfc_descriptor_t *dest,\n \t\t    caf_vector_t *dst_vector __attribute__ ((unused)),\n-\t\t    gfc_descriptor_t *src, int dst_kind, int src_kind)\n+\t\t    gfc_descriptor_t *src, int dst_kind, int src_kind,\n+\t\t    bool may_require_tmp)\n {\n   /* FIXME: Handle vector subscripts.  */\n   size_t i, k, size;\n@@ -697,6 +775,91 @@ _gfortran_caf_send (caf_token_t token, size_t offset,\n   if (size == 0)\n     return;\n \n+  if (may_require_tmp)\n+    {\n+      ptrdiff_t array_offset_sr, array_offset_dst;\n+      void *tmp;\n+\n+      if (GFC_DESCRIPTOR_RANK (src) == 0)\n+\t{\n+\t  tmp = malloc (src_size);\n+\t  memcpy (tmp, GFC_DESCRIPTOR_DATA (src), src_size);\n+\t}\n+      else\n+\t{\n+\t  tmp = malloc (size*src_size);\n+\t  array_offset_dst = 0;\n+\t  for (i = 0; i < size; i++)\n+\t    {\n+\t      ptrdiff_t array_offset_sr = 0;\n+\t      ptrdiff_t stride = 1;\n+\t      ptrdiff_t extent = 1;\n+\t      for (j = 0; j < GFC_DESCRIPTOR_RANK (src)-1; j++)\n+\t\t{\n+\t\t  array_offset_sr += ((i / (extent*stride))\n+\t\t\t\t      % (src->dim[j]._ubound\n+\t\t\t\t\t - src->dim[j].lower_bound + 1))\n+\t\t\t\t     * src->dim[j]._stride;\n+\t\t  extent = (src->dim[j]._ubound - src->dim[j].lower_bound + 1);\n+\t\t  stride = src->dim[j]._stride;\n+\t\t}\n+\t      array_offset_sr += (i / extent) * src->dim[rank-1]._stride;\n+\t      void *sr = (void *) ((char *) src->base_addr\n+\t\t\t\t   + array_offset_sr*GFC_DESCRIPTOR_SIZE (src));\n+\t      memcpy ((void *) ((char *) tmp + array_offset_dst), sr, src_size);\n+\t      array_offset_dst += src_size;\n+\t    }\n+\t}\n+\n+      array_offset_sr = 0;\n+      for (i = 0; i < size; i++)\n+\t{\n+\t  ptrdiff_t array_offset_dst = 0;\n+\t  ptrdiff_t stride = 1;\n+\t  ptrdiff_t extent = 1;\n+\t  for (j = 0; j < rank-1; j++)\n+\t    {\n+\t      array_offset_dst += ((i / (extent*stride))\n+\t\t\t\t   % (dest->dim[j]._ubound\n+\t\t\t\t      - dest->dim[j].lower_bound + 1))\n+\t\t\t\t  * dest->dim[j]._stride;\n+\t  extent = (dest->dim[j]._ubound - dest->dim[j].lower_bound + 1);\n+          stride = dest->dim[j]._stride;\n+\t    }\n+\t  array_offset_dst += (i / extent) * dest->dim[rank-1]._stride;\n+\t  void *dst = (void *)((char *) TOKEN (token) + offset\n+\t\t      + array_offset_dst*GFC_DESCRIPTOR_SIZE (dest));\n+          void *sr = tmp + array_offset_sr;\n+\t  if (GFC_DESCRIPTOR_TYPE (dest) == GFC_DESCRIPTOR_TYPE (src)\n+\t      && dst_kind == src_kind)\n+\t    {\n+\t      memmove (dst, sr,\n+\t\t       dst_size > src_size ? src_size : dst_size);\n+\t      if (GFC_DESCRIPTOR_TYPE (dest) == BT_CHARACTER\n+\t\t  && dst_size > src_size)\n+\t\t{\n+\t\t  if (dst_kind == 1)\n+\t\t    memset ((void*)(char*) dst + src_size, ' ',\n+\t\t\t    dst_size-src_size);\n+\t\t  else /* dst_kind == 4.  */\n+\t\t    for (k = src_size/4; k < dst_size/4; k++)\n+\t\t      ((int32_t*) dst)[k] = (int32_t) ' ';\n+\t\t}\n+\t    }\n+\t  else if (GFC_DESCRIPTOR_TYPE (dest) == BT_CHARACTER && dst_kind == 1)\n+\t    assign_char1_from_char4 (dst_size, src_size, dst, sr);\n+\t  else if (GFC_DESCRIPTOR_TYPE (dest) == BT_CHARACTER)\n+\t    assign_char4_from_char1 (dst_size, src_size, dst, sr);\n+\t  else\n+\t    convert_type (dst, GFC_DESCRIPTOR_TYPE (dest), dst_kind,\n+\t\t\t  sr, GFC_DESCRIPTOR_TYPE (src), src_kind);\n+          if (GFC_DESCRIPTOR_RANK (src))\n+\t    array_offset_sr += src_size;\n+\t}\n+      free (tmp);\n+      return;\n+    }\n+\n   for (i = 0; i < size; i++)\n     {\n       ptrdiff_t array_offset_dst = 0;\n@@ -769,15 +932,15 @@ _gfortran_caf_sendget (caf_token_t dst_token, size_t dst_offset,\n \t\t       int src_image_index __attribute__ ((unused)),\n \t\t       gfc_descriptor_t *src,\n \t\t       caf_vector_t *src_vector __attribute__ ((unused)),\n-\t\t       int dst_kind, int src_kind)\n+\t\t       int dst_kind, int src_kind, bool may_require_tmp)\n {\n   /* FIXME: Handle vector subscript of 'src_vector'.  */\n   /* For a single image, src->base_addr should be the same as src_token + offset\n      but to play save, we do it properly.  */\n   void *src_base = GFC_DESCRIPTOR_DATA (src);\n   GFC_DESCRIPTOR_DATA (src) = (void *) ((char *) TOKEN (src_token) + src_offset);\n   _gfortran_caf_send (dst_token, dst_offset, dst_image_index, dest, dst_vector,\n-\t\t      src, dst_kind, src_kind);\n+\t\t      src, dst_kind, src_kind, may_require_tmp);\n   GFC_DESCRIPTOR_DATA (src) = src_base;\n }\n "}]}