{"sha": "3d03ead0b8273efde57f6194617b35111a84b05d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2QwM2VhZDBiODI3M2VmZGU1N2Y2MTk0NjE3YjM1MTExYTg0YjA1ZA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-07-23T14:25:55Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-07-23T14:25:55Z"}, "message": "re PR fortran/24524 (Fortran dependency checking should reverse loops)\n\n2009-07-23  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/24524\n\t* trans-array.c (gfc_init_loopinfo): Initialize the reverse\n\tfield.\n\tgfc_trans_scalarized_loop_end: If reverse set in dimension n,\n\treverse the scalarization loop.\n\tgfc_conv_resolve_dependencies: Pass the reverse field of the\n\tloopinfo to gfc_dep_resolver.\n\ttrans-expr.c (gfc_trans_assignment_1): Enable loop reversal for\n\tassignment by resetting loop.reverse.\n\tgfortran.h : Add the gfc_reverse enum.\n\ttrans.h : Add the reverse field to gfc_loopinfo.\n\tdependency.c (gfc_check_dependency): Pass null to the new arg\n\tof gfc_dep_resolver.\n\t(gfc_check_section_vs_section): Check for reverse dependencies.\n\t(gfc_dep_resolver): Add reverse argument and deal with the loop\n\treversal logic.\n\tdependency.h : Modify prototype for gfc_dep_resolver to include\n\tgfc_reverse *.\n\nFrom-SVN: r162462", "tree": {"sha": "be85c1a1d325c1a8b6496500d502795c61e15506", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be85c1a1d325c1a8b6496500d502795c61e15506"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d03ead0b8273efde57f6194617b35111a84b05d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d03ead0b8273efde57f6194617b35111a84b05d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d03ead0b8273efde57f6194617b35111a84b05d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d03ead0b8273efde57f6194617b35111a84b05d/comments", "author": null, "committer": null, "parents": [{"sha": "c4fcd06a10ddacc81f535b165034dbaa93b6005c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4fcd06a10ddacc81f535b165034dbaa93b6005c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4fcd06a10ddacc81f535b165034dbaa93b6005c"}], "stats": {"total": 139, "additions": 126, "deletions": 13}, "files": [{"sha": "8592db99d6fc34aee5b8c201c98772366d5b83d1", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d03ead0b8273efde57f6194617b35111a84b05d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d03ead0b8273efde57f6194617b35111a84b05d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3d03ead0b8273efde57f6194617b35111a84b05d", "patch": "@@ -1,3 +1,24 @@\n+2009-07-23  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/24524\n+\t* trans-array.c (gfc_init_loopinfo): Initialize the reverse\n+\tfield.\n+\tgfc_trans_scalarized_loop_end: If reverse set in dimension n,\n+\treverse the scalarization loop.\n+\tgfc_conv_resolve_dependencies: Pass the reverse field of the\n+\tloopinfo to gfc_dep_resolver.\n+\ttrans-expr.c (gfc_trans_assignment_1): Enable loop reversal for\n+\tassignment by resetting loop.reverse.\n+\tgfortran.h : Add the gfc_reverse enum.\n+\ttrans.h : Add the reverse field to gfc_loopinfo.\n+\tdependency.c (gfc_check_dependency): Pass null to the new arg\n+\tof gfc_dep_resolver.\n+\t(gfc_check_section_vs_section): Check for reverse dependencies.\n+\t(gfc_dep_resolver): Add reverse argument and deal with the loop\n+\treversal logic.\n+\tdependency.h : Modify prototype for gfc_dep_resolver to include\n+\tgfc_reverse *.\n+\n 2010-07-23  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/44709"}, {"sha": "9dd4d9c46729917382e3ada8bcdfda876492b2fd", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 65, "deletions": 4, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d03ead0b8273efde57f6194617b35111a84b05d/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d03ead0b8273efde57f6194617b35111a84b05d/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=3d03ead0b8273efde57f6194617b35111a84b05d", "patch": "@@ -39,7 +39,8 @@ typedef enum\n {\n   GFC_DEP_ERROR,\n   GFC_DEP_EQUAL,\t/* Identical Ranges.  */\n-  GFC_DEP_FORWARD,\t/* e.g., a(1:3), a(2:4).  */\n+  GFC_DEP_FORWARD,\t/* e.g., a(1:3) = a(2:4).  */\n+  GFC_DEP_BACKWARD,\t/* e.g. a(2:4) = a(1:3).  */\n   GFC_DEP_OVERLAP,\t/* May overlap in some other way.  */\n   GFC_DEP_NODEP\t\t/* Distinct ranges.  */\n }\n@@ -831,7 +832,7 @@ gfc_check_dependency (gfc_expr *expr1, gfc_expr *expr2, bool identical)\n       /* Identical and disjoint ranges return 0,\n \t overlapping ranges return 1.  */\n       if (expr1->ref && expr2->ref)\n-\treturn gfc_dep_resolver (expr1->ref, expr2->ref);\n+\treturn gfc_dep_resolver (expr1->ref, expr2->ref, NULL);\n \n       return 1;\n \n@@ -1074,6 +1075,30 @@ gfc_check_section_vs_section (gfc_ref *lref, gfc_ref *rref, int n)\n \treturn GFC_DEP_FORWARD;\n     }\n \n+  /* Check for backward dependencies:\n+     Are the strides the same?.  */\n+  if ((!l_stride && !r_stride)\n+\t||\n+      (l_stride && r_stride\n+\t&& gfc_dep_compare_expr (l_stride, r_stride) == 0))\n+    {\n+      /* x:y vs. x+1:z.  */\n+      if (l_dir == 1 && r_dir == 1\n+\t    && l_start && r_start\n+\t    && gfc_dep_compare_expr (l_start, r_start) == 1\n+\t    && l_end && r_end\n+\t    && gfc_dep_compare_expr (l_end, r_end) == 1)\n+\treturn GFC_DEP_BACKWARD;\n+\n+      /* x:y:-1 vs. x-1:z:-1.  */\n+      if (l_dir == -1 && r_dir == -1\n+\t    && l_start && r_start\n+\t    && gfc_dep_compare_expr (l_start, r_start) == -1\n+\t    && l_end && r_end\n+\t    && gfc_dep_compare_expr (l_end, r_end) == -1)\n+\treturn GFC_DEP_BACKWARD;\n+    }\n+\n   return GFC_DEP_OVERLAP;\n }\n \n@@ -1481,16 +1506,19 @@ ref_same_as_full_array (gfc_ref *full_ref, gfc_ref *ref)\n \n /* Finds if two array references are overlapping or not.\n    Return value\n+   \t2 : array references are overlapping but reversal of one or\n+\t    more dimensions will clear the dependency.\n    \t1 : array references are overlapping.\n    \t0 : array references are identical or not overlapping.  */\n \n int\n-gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref)\n+gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n {\n   int n;\n   gfc_dependency fin_dep;\n   gfc_dependency this_dep;\n \n+  this_dep = GFC_DEP_ERROR;\n   fin_dep = GFC_DEP_ERROR;\n   /* Dependencies due to pointers should already have been identified.\n      We only need to check for overlapping array references.  */\n@@ -1543,6 +1571,7 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref)\n \t      if (lref->u.ar.dimen_type[n] == DIMEN_VECTOR\n \t\t  || rref->u.ar.dimen_type[n] == DIMEN_VECTOR)\n \t\treturn 1;\n+\n \t      if (lref->u.ar.dimen_type[n] == DIMEN_RANGE\n \t\t  && rref->u.ar.dimen_type[n] == DIMEN_RANGE)\n \t\tthis_dep = gfc_check_section_vs_section (lref, rref, n);\n@@ -1563,6 +1592,38 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref)\n \t      if (this_dep == GFC_DEP_NODEP)\n \t\treturn 0;\n \n+\t      /* Now deal with the loop reversal logic:  This only works on\n+\t\t ranges and is activated by setting\n+\t\t\t\treverse[n] == GFC_CAN_REVERSE\n+\t\t The ability to reverse or not is set by previous conditions\n+\t\t in this dimension.  If reversal is not activated, the\n+\t\t value GFC_DEP_BACKWARD is reset to GFC_DEP_OVERLAP.  */\n+\t      if (rref->u.ar.dimen_type[n] == DIMEN_RANGE\n+\t\t    && lref->u.ar.dimen_type[n] == DIMEN_RANGE)\n+\t\t{\n+\t\t  /* Set reverse if backward dependence and not inhibited.  */\n+\t\t  if (reverse && reverse[n] != GFC_CANNOT_REVERSE)\n+\t\t    reverse[n] = (this_dep == GFC_DEP_BACKWARD) ?\n+\t\t\t         GFC_REVERSE_SET : reverse[n];\n+\n+\t\t  /* Inhibit loop reversal if dependence not compatible.  */\n+\t\t  if (reverse && reverse[n] != GFC_REVERSE_NOT_SET\n+\t\t        && this_dep != GFC_DEP_EQUAL\n+\t\t        && this_dep != GFC_DEP_BACKWARD\n+\t\t        && this_dep != GFC_DEP_NODEP)\n+\t\t    {\n+\t              reverse[n] = GFC_CANNOT_REVERSE;\n+\t\t      if (this_dep != GFC_DEP_FORWARD)\n+\t\t\tthis_dep = GFC_DEP_OVERLAP;\n+\t\t    }\n+\n+\t\t  /* If no intention of reversing or reversing is explicitly\n+\t\t     inhibited, convert backward dependence to overlap.  */\n+\t\t  if ((reverse == NULL && this_dep == GFC_DEP_BACKWARD)\n+\t\t\t|| (reverse && reverse[n] == GFC_CANNOT_REVERSE))\n+\t\t    this_dep = GFC_DEP_OVERLAP;\n+\t\t}\n+\n \t      /* Overlap codes are in order of priority.  We only need to\n \t\t know the worst one.*/\n \t      if (this_dep > fin_dep)\n@@ -1578,7 +1639,7 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref)\n \n \t  /* Exactly matching and forward overlapping ranges don't cause a\n \t     dependency.  */\n-\t  if (fin_dep < GFC_DEP_OVERLAP)\n+\t  if (fin_dep < GFC_DEP_BACKWARD)\n \t    return 0;\n \n \t  /* Keep checking.  We only have a dependency if"}, {"sha": "bac2749093b522a1e90c516eeb8cdd18f95e5f98", "filename": "gcc/fortran/dependency.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d03ead0b8273efde57f6194617b35111a84b05d/gcc%2Ffortran%2Fdependency.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d03ead0b8273efde57f6194617b35111a84b05d/gcc%2Ffortran%2Fdependency.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.h?ref=3d03ead0b8273efde57f6194617b35111a84b05d", "patch": "@@ -29,7 +29,6 @@ typedef enum\n }\n gfc_dep_check;\n \n-\n /*********************** Functions prototypes **************************/\n \n bool gfc_ref_needs_temporary_p (gfc_ref *);\n@@ -41,6 +40,6 @@ int gfc_check_dependency (gfc_expr *, gfc_expr *, bool);\n int gfc_is_same_range (gfc_array_ref *, gfc_array_ref *, int, int);\n int gfc_expr_is_one (gfc_expr *, int);\n \n-int gfc_dep_resolver(gfc_ref *, gfc_ref *);\n+int gfc_dep_resolver(gfc_ref *, gfc_ref *, gfc_reverse *);\n int gfc_are_equivalenced_arrays (gfc_expr *, gfc_expr *);\n "}, {"sha": "a493866ab3691848adf49cb2d45a449a68f43ccb", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d03ead0b8273efde57f6194617b35111a84b05d/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d03ead0b8273efde57f6194617b35111a84b05d/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=3d03ead0b8273efde57f6194617b35111a84b05d", "patch": "@@ -576,6 +576,15 @@ typedef enum\n }\n gfc_fcoarray;\n \n+typedef enum\n+{\n+  GFC_REVERSE_NOT_SET,\n+  GFC_REVERSE_SET,\n+  GFC_CAN_REVERSE,\n+  GFC_CANNOT_REVERSE\n+}\n+gfc_reverse;\n+\n /************************* Structures *****************************/\n \n /* Used for keeping things in balanced binary trees.  */"}, {"sha": "cca4ecc4d9c5c83e5e5687e269e4c67eb78c340e", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d03ead0b8273efde57f6194617b35111a84b05d/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d03ead0b8273efde57f6194617b35111a84b05d/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=3d03ead0b8273efde57f6194617b35111a84b05d", "patch": "@@ -2180,9 +2180,12 @@ gfc_init_loopinfo (gfc_loopinfo * loop)\n   gfc_init_block (&loop->pre);\n   gfc_init_block (&loop->post);\n \n-  /* Initially scalarize in order.  */\n+  /* Initially scalarize in order and default to no loop reversal.  */\n   for (n = 0; n < GFC_MAX_DIMENSIONS; n++)\n-    loop->order[n] = n;\n+    {\n+      loop->order[n] = n;\n+      loop->reverse[n] = GFC_CANNOT_REVERSE;\n+    }\n \n   loop->ss = gfc_ss_terminator;\n }\n@@ -2842,8 +2845,18 @@ gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,\n     }\n   else\n     {\n+      bool reverse_loop = (loop->reverse[n] == GFC_REVERSE_SET)\n+\t\t\t     && (loop->temp_ss == NULL);\n+\n       loopbody = gfc_finish_block (pbody);\n \n+      if (reverse_loop)\n+\t{\n+\t  tmp = loop->from[n];\n+\t  loop->from[n] = loop->to[n];\n+\t  loop->to[n] = tmp;\n+\t}\n+\n       /* Initialize the loopvar.  */\n       if (loop->loopvar[n] != loop->from[n])\n \tgfc_add_modify (&loop->code[n], loop->loopvar[n], loop->from[n]);\n@@ -2854,8 +2867,8 @@ gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,\n       gfc_init_block (&block);\n \n       /* The exit condition.  */\n-      cond = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t loop->loopvar[n], loop->to[n]);\n+      cond = fold_build2 (reverse_loop ? LT_EXPR : GT_EXPR,\n+\t\t\t  boolean_type_node, loop->loopvar[n], loop->to[n]);\n       tmp = build1_v (GOTO_EXPR, exit_label);\n       TREE_USED (exit_label) = 1;\n       tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt (input_location));\n@@ -2865,8 +2878,10 @@ gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,\n       gfc_add_expr_to_block (&block, loopbody);\n \n       /* Increment the loopvar.  */\n-      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t loop->loopvar[n], gfc_index_one_node);\n+      tmp = fold_build2 (reverse_loop ? MINUS_EXPR : PLUS_EXPR,\n+\t\t\t gfc_array_index_type, loop->loopvar[n],\n+\t\t\t gfc_index_one_node);\n+\n       gfc_add_modify (&block, loop->loopvar[n], tmp);\n \n       /* Build the loop.  */\n@@ -3449,7 +3464,8 @@ gfc_conv_resolve_dependencies (gfc_loopinfo * loop, gfc_ss * dest,\n \t  lref = dest->expr->ref;\n \t  rref = ss->expr->ref;\n \n-\t  nDepend = gfc_dep_resolver (lref, rref);\n+\t  nDepend = gfc_dep_resolver (lref, rref, &loop->reverse[0]);\n+\n \t  if (nDepend == 1)\n \t    break;\n #if 0"}, {"sha": "a83d4b3eda4d07c79d08af6bd86cbacc1f824d35", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d03ead0b8273efde57f6194617b35111a84b05d/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d03ead0b8273efde57f6194617b35111a84b05d/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=3d03ead0b8273efde57f6194617b35111a84b05d", "patch": "@@ -5303,6 +5303,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n   bool l_is_temp;\n   bool scalar_to_array;\n   tree string_length;\n+  int n;\n \n   /* Assignment of the form lhs = rhs.  */\n   gfc_start_block (&block);\n@@ -5348,6 +5349,9 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \n       /* Calculate the bounds of the scalarization.  */\n       gfc_conv_ss_startstride (&loop);\n+      /* Enable loop reversal.  */\n+      for (n = 0; n < loop.dimen; n++)\n+\tloop.reverse[n] = GFC_REVERSE_NOT_SET;\n       /* Resolve any data dependencies in the statement.  */\n       gfc_conv_resolve_dependencies (&loop, lss, rss);\n       /* Setup the scalarizing loops.  */"}, {"sha": "9872e83df9e75074050125011ad19a3ebd7b51e1", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d03ead0b8273efde57f6194617b35111a84b05d/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d03ead0b8273efde57f6194617b35111a84b05d/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=3d03ead0b8273efde57f6194617b35111a84b05d", "patch": "@@ -240,6 +240,9 @@ typedef struct gfc_loopinfo\n   /* Order in which the dimensions should be looped, innermost first.  */\n   int order[GFC_MAX_DIMENSIONS];\n \n+  /* Enum to control loop reversal.  */\n+  gfc_reverse reverse[GFC_MAX_DIMENSIONS];\n+\n   /* The number of dimensions for which a temporary is used.  */\n   int temp_dim;\n "}]}