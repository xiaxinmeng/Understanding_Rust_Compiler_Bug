{"sha": "9246aadb572e69545ab6c1bc723018a8bfe44b2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI0NmFhZGI1NzJlNjk1NDVhYjZjMWJjNzIzMDE4YThiZmU0NGIyZA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2000-07-23T06:17:41Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2000-07-23T06:17:41Z"}, "message": "find_reloads_toplev: add new parameter \"address_reloaded\".\n\nFrom-SVN: r35196", "tree": {"sha": "47fb576a96be1d9b056936754b05e5089407b3da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47fb576a96be1d9b056936754b05e5089407b3da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9246aadb572e69545ab6c1bc723018a8bfe44b2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9246aadb572e69545ab6c1bc723018a8bfe44b2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9246aadb572e69545ab6c1bc723018a8bfe44b2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9246aadb572e69545ab6c1bc723018a8bfe44b2d/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8039a4ea734415951af932bb5dc93a9cbc5f13dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8039a4ea734415951af932bb5dc93a9cbc5f13dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8039a4ea734415951af932bb5dc93a9cbc5f13dc"}], "stats": {"total": 46, "additions": 34, "deletions": 12}, "files": [{"sha": "097002364f0cfc0d983423c31366b741a50b4c4b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9246aadb572e69545ab6c1bc723018a8bfe44b2d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9246aadb572e69545ab6c1bc723018a8bfe44b2d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9246aadb572e69545ab6c1bc723018a8bfe44b2d", "patch": "@@ -1,3 +1,9 @@\n+2000-07-22  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* reload.c (find_reloads_toplev): Add new parameter\n+\t\"address_reloaded\".\n+\t(find_reloads): Add new parameter to find_reloads_toplev calls.\n+\n 2000-07-22  Jeffrey Oldham  <oldham@codesourcery.com>\n \n \t* collect2.c (main): Typo fixed."}, {"sha": "f6621d8e6f7dc472683d97c09dee605316b7082b", "filename": "gcc/reload.c", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9246aadb572e69545ab6c1bc723018a8bfe44b2d/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9246aadb572e69545ab6c1bc723018a8bfe44b2d/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=9246aadb572e69545ab6c1bc723018a8bfe44b2d", "patch": "@@ -258,7 +258,7 @@ static struct decomposition decompose PARAMS ((rtx));\n static int immune_p\t\tPARAMS ((rtx, rtx, struct decomposition));\n static int alternative_allows_memconst PARAMS ((const char *, int));\n static rtx find_reloads_toplev\tPARAMS ((rtx, int, enum reload_type, int,\n-\t\t\t\t\t int, rtx));\n+\t\t\t\t\t int, rtx, int *));\n static rtx make_memloc\t\tPARAMS ((rtx, int));\n static int find_reloads_address\tPARAMS ((enum machine_mode, rtx *, rtx, rtx *,\n \t\t\t\t       int, enum reload_type, int, rtx));\n@@ -2592,7 +2592,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t\t   ind_levels,\n \t\t\t\t   set != 0\n \t\t\t\t   && &SET_DEST (set) == recog_data.operand_loc[i],\n-\t\t\t\t   insn);\n+\t\t\t\t   insn,\n+\t\t\t\t   &address_reloaded[i]);\n \n \t  /* If we made a MEM to load (a part of) the stackslot of a pseudo\n \t     that didn't get a hard register, emit a USE with a REG_EQUAL\n@@ -2616,7 +2617,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t   a unary operator by reloading the operand.  */\n \tsubsted_operand[i] = recog_data.operand[i]\n \t  = find_reloads_toplev (recog_data.operand[i], i, address_type[i],\n-\t\t\t\t ind_levels, 0, insn);\n+\t\t\t\t ind_levels, 0, insn,\n+\t\t\t\t &address_reloaded[i]);\n       else if (code == REG)\n \t{\n \t  /* This is equivalent to calling find_reloads_toplev.\n@@ -2644,7 +2646,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t       of a constant equivalence was checked above.  */\n \t    substed_operand[i] = recog_data.operand[i]\n \t      = find_reloads_toplev (recog_data.operand[i], i, address_type[i],\n-\t\t\t\t     ind_levels, 0, insn);\n+\t\t\t\t     ind_levels, 0, insn,\n+\t\t\t\t     &address_reloaded[i]);\n \t}\n       /* If the operand is still a register (we didn't replace it with an\n \t equivalent), get the preferred class to reload it into.  */\n@@ -3540,7 +3543,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \tsubsted_operand[i] = recog_data.operand[i]\n \t  = find_reloads_toplev (force_const_mem (operand_mode[i],\n \t\t\t\t\t\t  recog_data.operand[i]),\n-\t\t\t\t i, address_type[i], ind_levels, 0, insn);\n+\t\t\t\t i, address_type[i], ind_levels, 0, insn,\n+\t\t\t\t NULL);\n \tif (alternative_allows_memconst (recog_data.constraints[i],\n \t\t\t\t\t goal_alternative_number))\n \t  goal_alternative_win[i] = 1;\n@@ -4169,16 +4173,21 @@ alternative_allows_memconst (constraint, altnum)\n \n    INSN, if nonzero, is the insn in which we do the reload.  It is used\n    to determine if we may generate output reloads, and where to put USEs\n-   for pseudos that we have to replace with stack slots.  */\n+   for pseudos that we have to replace with stack slots.\n+\n+   ADDRESS_RELOADED.  If nonzero, is a pointer to where we put the\n+   result of find_reloads_address.  */\n \n static rtx\n-find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest, insn)\n+find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest, insn,\n+\t\t     address_reloaded)\n      rtx x;\n      int opnum;\n      enum reload_type type;\n      int ind_levels;\n      int is_set_dest;\n      rtx insn;\n+     int *address_reloaded;\n {\n   register RTX_CODE code = GET_CODE (x);\n \n@@ -4211,17 +4220,23 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest, insn)\n \t      if (replace_reloads && recog_data.operand[opnum] != x)\n \t\temit_insn_before (gen_rtx_USE (VOIDmode, x), insn);\n \t      x = mem;\n-\t      find_reloads_address (GET_MODE (x), &x, XEXP (x, 0), &XEXP (x, 0),\n-\t\t\t\t    opnum, type, ind_levels, insn);\n+\t      i = find_reloads_address (GET_MODE (x), &x, XEXP (x, 0), &XEXP (x, 0),\n+\t\t\t\t\topnum, type, ind_levels, insn);\n+\t      if (address_reloaded)\n+\t\t*address_reloaded = i;\n \t    }\n \t}\n       return x;\n     }\n   if (code == MEM)\n     {\n       rtx tem = x;\n-      find_reloads_address (GET_MODE (x), &tem, XEXP (x, 0), &XEXP (x, 0),\n-\t\t\t    opnum, type, ind_levels, insn);\n+\n+      i = find_reloads_address (GET_MODE (x), &tem, XEXP (x, 0), &XEXP (x, 0),\n+\t\t\t\topnum, type, ind_levels, insn);\n+      if (address_reloaded)\n+\t*address_reloaded = i;\n+\n       return tem;\n     }\n \n@@ -4326,7 +4341,8 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest, insn)\n       if (fmt[i] == 'e')\n \t{\n \t  rtx new_part = find_reloads_toplev (XEXP (x, i), opnum, type,\n-\t\t\t\t\t      ind_levels, is_set_dest, insn);\n+\t\t\t\t\t      ind_levels, is_set_dest, insn,\n+\t\t\t\t\t      address_reloaded);\n \t  /* If we have replaced a reg with it's equivalent memory loc -\n \t     that can still be handled here e.g. if it's in a paradoxical\n \t     subreg - we must make the change in a copy, rather than using"}]}