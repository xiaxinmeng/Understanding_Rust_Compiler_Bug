{"sha": "b2264b0964560e724010aac2faf4f6a3ec2729f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjIyNjRiMDk2NDU2MGU3MjQwMTBhYWMyZmFmNGY2YTNlYzI3MjlmNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-12-08T15:54:30Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-12-08T15:54:30Z"}, "message": "runtime: allocate _panic struct on heap\n    \n    The gc library allocates a _panic struct on the stack. This does not\n    work for gccgo, because when a deferred function recovers the panic we\n    unwind the stack up to that point so that returning from the function\n    will work correctly.\n    \n    Allocating on the stack fine if the panic is not recovered, and it\n    works fine if the panic is recovered by a function that\n    returns. However, it fails if the panic is recovered by a function\n    that itself panics, and if that second panic is then recovered by a\n    function higher up on the stack. When we unwind the stack to that\n    second panic, the g will wind up pointing at a panic farther down on\n    the stack. Even then everything will often work fine, except when the\n    deferred function catching the second panic makes a bunch of calls\n    that use stack space before returning. In that case the code can\n    overwrite the panic struct, which will then cause disaster when we\n    remove the struct from the linked list, as the link field will be\n    garbage. This case is rare enough that all the x86 tests were passing,\n    but there was a failure on ppc64le.\n    \n    Before https://golang.org/cl/33414 we allocated the panic struct on\n    the heap, so go back to doing that again.\n    \n    Fixes golang/go#18228.\n    \n    Reviewed-on: https://go-review.googlesource.com/34027\n\nFrom-SVN: r243444", "tree": {"sha": "6975dcd13003606feee2cb8d7753ef271c391a97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6975dcd13003606feee2cb8d7753ef271c391a97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2264b0964560e724010aac2faf4f6a3ec2729f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2264b0964560e724010aac2faf4f6a3ec2729f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2264b0964560e724010aac2faf4f6a3ec2729f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2264b0964560e724010aac2faf4f6a3ec2729f7/comments", "author": null, "committer": null, "parents": [{"sha": "0a7577bbac00ea3ecfa8f25d38c98ea696f3a0ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a7577bbac00ea3ecfa8f25d38c98ea696f3a0ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a7577bbac00ea3ecfa8f25d38c98ea696f3a0ce"}], "stats": {"total": 19, "additions": 14, "deletions": 5}, "files": [{"sha": "df38903801645e873194be0d979ad798d51a3dc5", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2264b0964560e724010aac2faf4f6a3ec2729f7/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2264b0964560e724010aac2faf4f6a3ec2729f7/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=b2264b0964560e724010aac2faf4f6a3ec2729f7", "patch": "@@ -1,4 +1,4 @@\n-7a941ba323660ec7034cd92d4eab466024a3c72c\n+2442fca7be8a4f51ddc91070fa69ef66e24593ac\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "f7e5efe363e0a6fd035ccbc13ac79691ee4a21da", "filename": "libgo/go/runtime/panic.go", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2264b0964560e724010aac2faf4f6a3ec2729f7/libgo%2Fgo%2Fruntime%2Fpanic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2264b0964560e724010aac2faf4f6a3ec2729f7/libgo%2Fgo%2Fruntime%2Fpanic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpanic.go?ref=b2264b0964560e724010aac2faf4f6a3ec2729f7", "patch": "@@ -415,10 +415,19 @@ func gopanic(e interface{}) {\n \t\tthrow(\"panic holding locks\")\n \t}\n \n-\tvar p _panic\n-\tp.arg = e\n-\tp.link = gp._panic\n-\tgp._panic = (*_panic)(noescape(unsafe.Pointer(&p)))\n+\t// The gc compiler allocates this new _panic struct on the\n+\t// stack. We can't do that, because when a deferred function\n+\t// recovers the panic we unwind the stack. We unlink this\n+\t// entry before unwinding the stack, but that doesn't help in\n+\t// the case where we panic, a deferred function recovers and\n+\t// then panics itself, that panic is in turn recovered, and\n+\t// unwinds the stack past this stack frame.\n+\n+\tp := &_panic{\n+\t\targ:  e,\n+\t\tlink: gp._panic,\n+\t}\n+\tgp._panic = p\n \n \tfor {\n \t\td := gp._defer"}]}