{"sha": "b4b340377307a6a4eb69473947fae238577282bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRiMzQwMzc3MzA3YTZhNGViNjk0NzM5NDdmYWUyMzg1NzcyODJiYw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-03-07T00:56:15Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-03-07T00:56:15Z"}, "message": "New file.\n\nFrom-SVN: r11484", "tree": {"sha": "46b6a43cbae709f63746c37b63fb06df5fb416f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46b6a43cbae709f63746c37b63fb06df5fb416f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4b340377307a6a4eb69473947fae238577282bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4b340377307a6a4eb69473947fae238577282bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4b340377307a6a4eb69473947fae238577282bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4b340377307a6a4eb69473947fae238577282bc/comments", "author": null, "committer": null, "parents": [{"sha": "e63ffc3836f06f9176692dbc6463f5ff61a9c277", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e63ffc3836f06f9176692dbc6463f5ff61a9c277", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e63ffc3836f06f9176692dbc6463f5ff61a9c277"}], "stats": {"total": 183, "additions": 183, "deletions": 0}, "files": [{"sha": "6e72814d1261e9b6cea69f79236aa8455966bf96", "filename": "gcc/ginclude/va-sh.h", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b340377307a6a4eb69473947fae238577282bc/gcc%2Fginclude%2Fva-sh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b340377307a6a4eb69473947fae238577282bc/gcc%2Fginclude%2Fva-sh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-sh.h?ref=b4b340377307a6a4eb69473947fae238577282bc", "patch": "@@ -0,0 +1,183 @@\n+/* This is just like the default gvarargs.h\n+   except for differences described below.  */\n+\n+/* Define __gnuc_va_list.  */\n+\n+#ifndef __GNUC_VA_LIST\n+#define __GNUC_VA_LIST\n+\n+#ifdef __SH3E__\n+\n+typedef long __va_greg;\n+typedef double __va_freg;\n+\n+typedef struct {\n+  __va_greg * __va_next_o;\t\t/* next available register */\n+  __va_greg * __va_next_o_limit;\t/* past last available register */\n+  __va_freg * __va_next_fp;\t\t/* next available fp register */\n+  __va_freg * __va_next_fp_limit;\t/* last available fp register */\n+  __va_greg * __va_next_stack;\t\t/* next extended word on stack */\n+} __gnuc_va_list;\n+\n+#else /* ! SH3E */\n+\n+typedef void *__gnuc_va_list;\n+\n+#define __va_rounded_size(TYPE)  \\\n+  (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))\n+\n+#endif /* ! SH3E */\n+\n+#endif /* __GNUC_VA_LIST */\n+\n+/* If this is for internal libc use, don't define anything but\n+   __gnuc_va_list.  */\n+#if defined (_STDARG_H) || defined (_VARARGS_H)\n+\n+#ifdef _STDARG_H\n+\n+#ifdef __SH3E__\n+\n+#define va_start(AP, LASTARG) \\\n+__extension__ \\\n+  ({ \\\n+     AP.__va_next_fp = (__va_freg *) __builtin_saveregs (); \\\n+     AP.__va_next_fp_limit = (AP.__va_next_fp + \\\n+\t\t\t      (__builtin_args_info (1) < 8 ? 8 - __builtin_args_info (1) : 0)); \\\n+     AP.__va_next_o = (__va_greg *) AP.__va_next_fp_limit; \\\n+     AP.__va_next_o_limit = (AP.__va_next_o + \\\n+\t\t\t     (__builtin_args_info (0) < 4 ? 4 - __builtin_args_info (0) : 0)); \\\n+     AP.__va_next_stack = (__va_greg *) __builtin_next_arg (LASTARG); \\\n+  })\n+\n+#else /* ! SH3E */\n+\n+#define va_start(AP, LASTARG) \t\t\t\t\t\t\\\n+ (AP = ((__gnuc_va_list) __builtin_next_arg (LASTARG)))\n+\n+#endif /* ! SH3E */\n+\n+#else /* _VARARGS_H */\n+\n+#define va_alist  __builtin_va_alist\n+#define va_dcl    int __builtin_va_alist;...\n+\n+#ifdef __SH3E___\n+\n+#define va_start(AP) \\\n+__extension__ \\\n+  ({ \\\n+     AP.__va_next_fp = (__va_freg *) __builtin_saveregs (); \\\n+     AP.__va_next_fp_limit = (AP.__va_next_fp + \\\n+\t\t\t      (__builtin_args_info (1) < 8 ? 8 - __builtin_args_info (1) : 0)); \\\n+     AP.__va_next_o = (__va_greg *) AP.__va_next_fp_limit; \\\n+     AP.__va_next_o_limit = (AP.__va_next_o + \\\n+\t\t\t     (__builtin_args_info (0) < 4 ? 4 - __builtin_args_info (0) : 0)); \\\n+     AP.__va_next_stack = (__va_greg *) __builtin_next_arg (__builtin_va_alist) \\\n+       - (__builtin_args_info (0) >= 4 || __builtin_args_info (1) >= 8 ? 1 : 0); \\\n+  })\n+\n+#else /* ! SH3E */\n+\n+#define va_start(AP)  AP=(char *) &__builtin_va_alist\n+\n+#endif /* ! SH3E */\n+\n+#endif /* _STDARG */\n+\n+#ifndef va_end\n+void va_end (__gnuc_va_list);\t\t/* Defined in libgcc.a */\n+\n+/* Values returned by __builtin_classify_type.  */\n+\n+enum __va_type_classes {\n+  __no_type_class = -1,\n+  __void_type_class,\n+  __integer_type_class,\n+  __char_type_class,\n+  __enumeral_type_class,\n+  __boolean_type_class,\n+  __pointer_type_class,\n+  __reference_type_class,\n+  __offset_type_class,\n+  __real_type_class,\n+  __complex_type_class,\n+  __function_type_class,\n+  __method_type_class,\n+  __record_type_class,\n+  __union_type_class,\n+  __array_type_class,\n+  __string_type_class,\n+  __set_type_class,\n+  __file_type_class,\n+  __lang_type_class\n+};\n+\n+#endif\n+#define va_end(pvar)\t((void)0)\n+\n+/* RECORD_TYPE args passed using the C calling convention are\n+   passed by invisible reference.  ??? RECORD_TYPE args passed\n+   in the stack are made to be word-aligned; for an aggregate that is\n+   not word-aligned, we advance the pointer to the first non-reg slot.  */\n+\n+#ifdef __SH3E__\n+\n+#ifdef __LITTLE_ENDIAN__\n+#warning SH3e little endian varargs/stdarg support has not been written yet.\n+#endif\n+\n+#define va_arg(pvar,TYPE)\t\t\t\t\t\\\n+__extension__\t\t\t\t\t\t\t\\\n+(*({int __type = __builtin_classify_type (* (TYPE *) 0);\t\\\n+  void * __result;\t\t\t\t\t\t\\\n+  if (__type == __real_type_class && sizeof(TYPE) == 4)\t\t\\\n+\t\t\t\t\t\t/* float? */\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      __va_freg *__r;\t\t\t\t\t\t\\\n+      if (pvar.__va_next_fp < pvar.__va_next_fp_limit)\t\t\\\n+\t__r = (__va_freg *) pvar.__va_next_fp++;\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\t__r = (__va_freg *) pvar.__va_next_stack++;\t\t\\\n+      __result = (char *) __r;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      __va_greg *__r;\t\t\t\t\t\t\\\n+      if (pvar.__va_next_o + ((sizeof (TYPE) + 3) / 4) <= pvar.__va_next_o_limit) \t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  __r = (__va_greg *) pvar.__va_next_o;\t\t\t\\\n+          pvar.__va_next_o += (sizeof (TYPE) + 3) / 4;\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+          __r = (__va_greg *) pvar.__va_next_stack;             \\\n+          pvar.__va_next_stack += (sizeof (TYPE) + 3) / 4;\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      __result = (char *) __r;\t\t\t\t\t\\\n+    } \t\t\t\t\t\t\t\t\\\n+  (TYPE *) __result;}))\n+\n+#else /* ! SH3E */\n+\n+#ifdef __LITTLE_ENDIAN__\n+\n+/* This is for little-endian machines; small args are padded upward.  */\n+#define va_arg(AP, TYPE)\t\t\t\t\t\t\\\n+ (AP = (__gnuc_va_list) ((char *) (AP) + __va_rounded_size (TYPE)),\t\\\n+  *((TYPE *) (void *) ((char *) (AP) - __va_rounded_size (TYPE))))\n+\n+#else /* ! __LITTLE_ENDIAN__ */\n+\n+/* This is for big-endian machines; small args are padded downward.  */\n+#define va_arg(AP, TYPE)\t\t\t\t\t\t\\\n+ (AP = (__gnuc_va_list) ((char *) (AP) + __va_rounded_size (TYPE)),\t\\\n+  *((TYPE *) (void *) ((char *) (AP)\t\t\t\t\t\\\n+\t\t       - ((sizeof (TYPE) < __va_rounded_size (char)\t\\\n+\t\t\t   ? sizeof (TYPE) : __va_rounded_size (TYPE))))))\n+\n+#endif /* __LITTLE_ENDIAN__ */\n+\n+#endif /* SH3E */\n+\n+#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */"}]}