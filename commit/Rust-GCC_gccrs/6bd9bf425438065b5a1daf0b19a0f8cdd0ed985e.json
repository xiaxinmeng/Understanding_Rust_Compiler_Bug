{"sha": "6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJkOWJmNDI1NDM4MDY1YjVhMWRhZjBiMTlhMGY4Y2RkMGVkOTg1ZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-09-02T17:53:54Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-09-02T17:53:54Z"}, "message": "c6x.md (collapse-ndfa, [...]): New automata_options.\n\n\t* config/c6x/c6x.md (collapse-ndfa, no-comb-vect): New\n\tautomata_options.\n\t(d1, l1, s1, m1, d2, l2, s2, m2): Changed to define_query_cpu_unit.\n\t(l1w, s1w, l2w, s2w): Define in the main automaton.\n\t(fps1, fpl1, adddps1, adddpl1, fps2, fpl2, adddps2, adddpl2): New\n\tunits.\n\t* config/c6x/c6x.c (c6x_sched_insn_info): Add unit_mask member.\n\t(c6x_unit_names): Add the new units.\n\t(c6x_unit_codes): New static array.\n\t(UNIT_QID_D1, UNIT_QID_L1, UNIT_QID_S1, UNIT_QID_M1, UNIT_QID_FPS1,\n\tUNIT_QID_FPL1, UNIT_QID_ADDDPS1, UNIT_QID_ADDDPL1,\n\tUNIT_QID_SIDE_OFFSET): New macros.\n\t(RESERVATION_S2): Adjust value.\n\t(c6x_option_override): Compute c6x_unit_codes.\n\t(assign_reservations): Take the unit_mask of the last instruction\n\tinto account.  Detect floating point reservations by looking for\n\tthe new units.  Don't assign reservations if the field is already\n\tnonzero.\n\t(struct c6x_sched_context): Add member prev_cycle_state_ctx.\n\t(init_sched_state): Initialize it.\n\t(c6x_clear_sched_context): Free it.\n\t(insn_set_clock): Clear reservation.\n\t(prev_cycle_state): New static variable.\n\t(c6x_init_sched_context): Save it.\n\t(c6x_sched_init): Allocate space for it and clear it.\n\t(c6x_sched_dfa_pre_cycle_insn): New static function.\n\t(c6x_dfa_new_cycle): Save state at the start of a new cycle.\n\t(c6x_variable_issue): Only record units in the unit_mask that\n\twere not set at the start of the cycle.\n\t(c6x_variable_issue): Compute and store the unit_mask from the\n\tcurrent state.\n\t(reorg_split_calls): Ensure the new information remains correct.\n\t(TARGET_SCHED_DFA_NEW_CYCLE, TARGET_SCHED_CLEAR_SCHED_CONTEXT,\n\tTARGET_SCHED_DFA_PRE_CYCLE_INSN): Define.\n\t* config/c6x/c6x.h (CPU_UNITS_QUERY): Define.\n\t* config/c6x/c6x-sched.md.in (fp4_ls_N__CROSS_, adddp_ls_N__CROSS_):\n\tAdd special reservations.\n\t* config/c6x/c6x-sched.md: Regenerate.\n\nFrom-SVN: r178488", "tree": {"sha": "c86b8a712bb7f6e6f92e28398c0e34fa6d44b3c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c86b8a712bb7f6e6f92e28398c0e34fa6d44b3c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e/comments", "author": null, "committer": null, "parents": [{"sha": "e1f3ce0db179a9c602c4699c517d9c689ebce34f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1f3ce0db179a9c602c4699c517d9c689ebce34f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1f3ce0db179a9c602c4699c517d9c689ebce34f"}], "stats": {"total": 318, "additions": 277, "deletions": 41}, "files": [{"sha": "268eabd37ae5b908fed11936a1ed0b5b85d00e1a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e", "patch": "@@ -1,3 +1,44 @@\n+2011-09-02  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* config/c6x/c6x.md (collapse-ndfa, no-comb-vect): New\n+\tautomata_options.\n+\t(d1, l1, s1, m1, d2, l2, s2, m2): Changed to define_query_cpu_unit.\n+\t(l1w, s1w, l2w, s2w): Define in the main automaton.\n+\t(fps1, fpl1, adddps1, adddpl1, fps2, fpl2, adddps2, adddpl2): New\n+\tunits.\n+\t* config/c6x/c6x.c (c6x_sched_insn_info): Add unit_mask member.\n+\t(c6x_unit_names): Add the new units.\n+\t(c6x_unit_codes): New static array.\n+\t(UNIT_QID_D1, UNIT_QID_L1, UNIT_QID_S1, UNIT_QID_M1, UNIT_QID_FPS1,\n+\tUNIT_QID_FPL1, UNIT_QID_ADDDPS1, UNIT_QID_ADDDPL1,\n+\tUNIT_QID_SIDE_OFFSET): New macros.\n+\t(RESERVATION_S2): Adjust value.\n+\t(c6x_option_override): Compute c6x_unit_codes.\n+\t(assign_reservations): Take the unit_mask of the last instruction\n+\tinto account.  Detect floating point reservations by looking for\n+\tthe new units.  Don't assign reservations if the field is already\n+\tnonzero.\n+\t(struct c6x_sched_context): Add member prev_cycle_state_ctx.\n+\t(init_sched_state): Initialize it.\n+\t(c6x_clear_sched_context): Free it.\n+\t(insn_set_clock): Clear reservation.\n+\t(prev_cycle_state): New static variable.\n+\t(c6x_init_sched_context): Save it.\n+\t(c6x_sched_init): Allocate space for it and clear it.\n+\t(c6x_sched_dfa_pre_cycle_insn): New static function.\n+\t(c6x_dfa_new_cycle): Save state at the start of a new cycle.\n+\t(c6x_variable_issue): Only record units in the unit_mask that\n+\twere not set at the start of the cycle.\n+\t(c6x_variable_issue): Compute and store the unit_mask from the\n+\tcurrent state.\n+\t(reorg_split_calls): Ensure the new information remains correct.\n+\t(TARGET_SCHED_DFA_NEW_CYCLE, TARGET_SCHED_CLEAR_SCHED_CONTEXT,\n+\tTARGET_SCHED_DFA_PRE_CYCLE_INSN): Define.\n+\t* config/c6x/c6x.h (CPU_UNITS_QUERY): Define.\n+\t* config/c6x/c6x-sched.md.in (fp4_ls_N__CROSS_, adddp_ls_N__CROSS_):\n+\tAdd special reservations.\n+\t* config/c6x/c6x-sched.md: Regenerate.\n+\n 2011-09-02  Martin Jambor  <mjambor@suse.cz>\n \n \t* ipa-prop.h (ipa_node_params): Removed fields"}, {"sha": "dc8e39cf45215a7a9a4c4f0f1b348c61ae7faaa0", "filename": "gcc/config/c6x/c6x-sched.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e/gcc%2Fconfig%2Fc6x%2Fc6x-sched.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e/gcc%2Fconfig%2Fc6x%2Fc6x-sched.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x-sched.md?ref=6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e", "patch": "@@ -183,14 +183,14 @@\n        (and (eq_attr \"cross\" \"n\")\n \t    (and (eq_attr \"units\" \"ls\")\n \t\t (eq_attr \"dest_regfile\" \"a\"))))\n-  \"(s1,nothing*2,s1w)|(l1,nothing*2,l1w)\")\n+  \"(fps1+s1,nothing*2,s1w)|(fpl1+l1,nothing*2,l1w)\")\n \n (define_insn_reservation \"adddp_ls1n\" 7\n   (and (eq_attr \"type\" \"adddp\")\n        (and (eq_attr \"cross\" \"n\")\n \t    (and (eq_attr \"units\" \"ls\")\n \t\t (eq_attr \"dest_regfile\" \"a\"))))\n-  \"((s1)*2,nothing*3,s1w*2)|((l1)*2,nothing*3,l1w*2)\")\n+  \"(adddps1+(s1)*2,nothing*3,s1w*2)|(adddpl1+(l1)*2,nothing*3,l1w*2)\")\n \n (define_insn_reservation \"single_dls1n\" 1\n   (and (eq_attr \"type\" \"single\")\n@@ -416,14 +416,14 @@\n        (and (eq_attr \"cross\" \"n\")\n \t    (and (eq_attr \"units\" \"ls\")\n \t\t (eq_attr \"dest_regfile\" \"b\"))))\n-  \"(s2,nothing*2,s2w)|(l2,nothing*2,l2w)\")\n+  \"(fps2+s2,nothing*2,s2w)|(fpl2+l2,nothing*2,l2w)\")\n \n (define_insn_reservation \"adddp_ls2n\" 7\n   (and (eq_attr \"type\" \"adddp\")\n        (and (eq_attr \"cross\" \"n\")\n \t    (and (eq_attr \"units\" \"ls\")\n \t\t (eq_attr \"dest_regfile\" \"b\"))))\n-  \"((s2)*2,nothing*3,s2w*2)|((l2)*2,nothing*3,l2w*2)\")\n+  \"(adddps2+(s2)*2,nothing*3,s2w*2)|(adddpl2+(l2)*2,nothing*3,l2w*2)\")\n \n (define_insn_reservation \"single_dls2n\" 1\n   (and (eq_attr \"type\" \"single\")\n@@ -649,14 +649,14 @@\n        (and (eq_attr \"cross\" \"y\")\n \t    (and (eq_attr \"units\" \"ls\")\n \t\t (eq_attr \"dest_regfile\" \"a\"))))\n-  \"(s1+x1,nothing*2,s1w)|(l1+x1,nothing*2,l1w)\")\n+  \"(fps1+s1+x1,nothing*2,s1w)|(fpl1+l1+x1,nothing*2,l1w)\")\n \n (define_insn_reservation \"adddp_ls1y\" 7\n   (and (eq_attr \"type\" \"adddp\")\n        (and (eq_attr \"cross\" \"y\")\n \t    (and (eq_attr \"units\" \"ls\")\n \t\t (eq_attr \"dest_regfile\" \"a\"))))\n-  \"((s1+x1)*2,nothing*3,s1w*2)|((l1+x1)*2,nothing*3,l1w*2)\")\n+  \"(adddps1+(s1+x1)*2,nothing*3,s1w*2)|(adddpl1+(l1+x1)*2,nothing*3,l1w*2)\")\n \n (define_insn_reservation \"single_dls1y\" 1\n   (and (eq_attr \"type\" \"single\")\n@@ -882,14 +882,14 @@\n        (and (eq_attr \"cross\" \"y\")\n \t    (and (eq_attr \"units\" \"ls\")\n \t\t (eq_attr \"dest_regfile\" \"b\"))))\n-  \"(s2+x2,nothing*2,s2w)|(l2+x2,nothing*2,l2w)\")\n+  \"(fps2+s2+x2,nothing*2,s2w)|(fpl2+l2+x2,nothing*2,l2w)\")\n \n (define_insn_reservation \"adddp_ls2y\" 7\n   (and (eq_attr \"type\" \"adddp\")\n        (and (eq_attr \"cross\" \"y\")\n \t    (and (eq_attr \"units\" \"ls\")\n \t\t (eq_attr \"dest_regfile\" \"b\"))))\n-  \"((s2+x2)*2,nothing*3,s2w*2)|((l2+x2)*2,nothing*3,l2w*2)\")\n+  \"(adddps2+(s2+x2)*2,nothing*3,s2w*2)|(adddpl2+(l2+x2)*2,nothing*3,l2w*2)\")\n \n (define_insn_reservation \"single_dls2y\" 1\n   (and (eq_attr \"type\" \"single\")"}, {"sha": "0ba714338780dc20561083c1683dcf47b87601a7", "filename": "gcc/config/c6x/c6x-sched.md.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e/gcc%2Fconfig%2Fc6x%2Fc6x-sched.md.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e/gcc%2Fconfig%2Fc6x%2Fc6x-sched.md.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x-sched.md.in?ref=6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e", "patch": "@@ -178,14 +178,14 @@\n        (and (eq_attr \"cross\" \"_CROSS_\")\n \t    (and (eq_attr \"units\" \"ls\")\n \t\t (eq_attr \"dest_regfile\" \"_RF_\"))))\n-  \"(s_N__CUNIT_,nothing*2,s_N_w)|(l_N__CUNIT_,nothing*2,l_N_w)\")\n+  \"(fps_N_+s_N__CUNIT_,nothing*2,s_N_w)|(fpl_N_+l_N__CUNIT_,nothing*2,l_N_w)\")\n \n (define_insn_reservation \"adddp_ls_N__CROSS_\" 7\n   (and (eq_attr \"type\" \"adddp\")\n        (and (eq_attr \"cross\" \"_CROSS_\")\n \t    (and (eq_attr \"units\" \"ls\")\n \t\t (eq_attr \"dest_regfile\" \"_RF_\"))))\n-  \"((s_N__CUNIT_)*2,nothing*3,s_N_w*2)|((l_N__CUNIT_)*2,nothing*3,l_N_w*2)\")\n+  \"(adddps_N_+(s_N__CUNIT_)*2,nothing*3,s_N_w*2)|(adddpl_N_+(l_N__CUNIT_)*2,nothing*3,l_N_w*2)\")\n \n (define_insn_reservation \"single_dls_N__CROSS_\" 1\n   (and (eq_attr \"type\" \"single\")"}, {"sha": "fd72babd2aee06e4be4a622bd8adbad14dd39480", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 211, "deletions": 24, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e", "patch": "@@ -111,6 +111,10 @@ typedef struct\n   rtx new_cond;\n   /* True for the first insn that was scheduled in an ebb.  */\n   bool ebb_start;\n+  /* The scheduler state after the insn, transformed into a mask of UNIT_QID\n+     bits rather than storing the state.  Meaningful only for the last\n+     insn in a cycle.  */\n+  unsigned int unit_mask;\n } c6x_sched_insn_info;\n \n DEF_VEC_O(c6x_sched_insn_info);\n@@ -124,13 +128,6 @@ static VEC(c6x_sched_insn_info, heap) *insn_info;\n \n static bool done_cfi_sections;\n \n-/* The DFA names of the units, in packet order.  */\n-static const char *const c6x_unit_names[] =\n-{\n-  \"d1\", \"l1\", \"s1\", \"m1\",\n-  \"d2\", \"l2\", \"s2\", \"m2\",\n-};\n-\n #define RESERVATION_FLAG_D 1\n #define RESERVATION_FLAG_L 2\n #define RESERVATION_FLAG_S 4\n@@ -140,8 +137,29 @@ static const char *const c6x_unit_names[] =\n #define RESERVATION_FLAG_LS (RESERVATION_FLAG_L | RESERVATION_FLAG_S)\n #define RESERVATION_FLAG_DLS (RESERVATION_FLAG_D | RESERVATION_FLAG_LS)\n \n+/* The DFA names of the units.  */\n+static const char *const c6x_unit_names[] =\n+{\n+  \"d1\", \"l1\", \"s1\", \"m1\", \"fps1\", \"fpl1\", \"adddps1\", \"adddpl1\",\n+  \"d2\", \"l2\", \"s2\", \"m2\", \"fps2\", \"fpl2\", \"adddps2\", \"adddpl2\"\n+};\n+\n+/* The DFA unit number for each unit in c6x_unit_names[].  */\n+static int c6x_unit_codes[ARRAY_SIZE (c6x_unit_names)];\n+\n+/* Unit query IDs.  */\n+#define UNIT_QID_D1 0\n+#define UNIT_QID_L1 1\n+#define UNIT_QID_S1 2\n+#define UNIT_QID_M1 3\n+#define UNIT_QID_FPS1 4\n+#define UNIT_QID_FPL1 5\n+#define UNIT_QID_ADDDPS1 6\n+#define UNIT_QID_ADDDPL1 7\n+#define UNIT_QID_SIDE_OFFSET 8\n+\n #define RESERVATION_S1 2\n-#define RESERVATION_S2 6\n+#define RESERVATION_S2 10\n \f\n /* Register map for debugging.  */\n int const dbx_register_map[FIRST_PSEUDO_REGISTER] =\n@@ -169,6 +187,8 @@ c6x_init_machine_status (void)\n static void\n c6x_option_override (void)\n {\n+  unsigned i;\n+\n   if (global_options_set.x_c6x_arch_option)\n     {\n       c6x_arch = all_isas[c6x_arch_option].type;\n@@ -184,6 +204,9 @@ c6x_option_override (void)\n \n   init_machine_status = c6x_init_machine_status;\n \n+  for (i = 0; i < ARRAY_SIZE (c6x_unit_names); i++)\n+    c6x_unit_codes[i] = get_cpu_unit_code (c6x_unit_names[i]);\n+\n   if (flag_pic && !TARGET_DSBT)\n     {\n       error (\"-fpic and -fPIC not supported without -mdsbt on this target\");\n@@ -2990,16 +3013,56 @@ assign_reservations (rtx head, rtx end)\n   rtx insn;\n   for (insn = head; insn != NEXT_INSN (end); insn = NEXT_INSN (insn))\n     {\n-      rtx within;\n+      unsigned int sched_mask, reserved;\n+      rtx within, last;\n       int pass;\n       int rsrv[2];\n       int rsrv_count[2][4];\n+      int i;\n \n       if (GET_MODE (insn) != TImode)\n \tcontinue;\n \n-      rsrv[0] = rsrv[1] = 0;\n+      reserved = 0;\n+      last = NULL_RTX;\n+      /* Find the last insn in the packet.  It has a state recorded for it,\n+\t which we can use to determine the units we should be using.  */\n+      for (within = insn;\n+\t   (within != NEXT_INSN (end)\n+\t    && (within == insn || GET_MODE (within) != TImode));\n+\t   within = NEXT_INSN (within))\n+\t{\n+\t  int icode;\n+\t  if (!NONDEBUG_INSN_P (within))\n+\t    continue;\n+\t  icode = recog_memoized (within);\n+\t  if (icode < 0)\n+\t    continue;\n+\t  if (shadow_p (within))\n+\t    continue;\n+\t  if (INSN_INFO_ENTRY (INSN_UID (within)).reservation != 0)\n+\t    reserved |= 1 << INSN_INFO_ENTRY (INSN_UID (within)).reservation;\n+\t  last = within;\n+\t}\n+      if (last == NULL_RTX)\n+\tcontinue;\n+\n+      sched_mask = INSN_INFO_ENTRY (INSN_UID (last)).unit_mask;\n+      sched_mask &= ~reserved;\n+\n       memset (rsrv_count, 0, sizeof rsrv_count);\n+      rsrv[0] = rsrv[1] = ~0;\n+      for (i = 0; i < 8; i++)\n+\t{\n+\t  int side = i / 4;\n+\t  int unit = i & 3;\n+\t  unsigned unit_bit = 1 << (unit + side * UNIT_QID_SIDE_OFFSET);\n+\t  /* Clear the bits which we expect to reserve in the following loop,\n+\t     leaving the ones set which aren't present in the scheduler's\n+\t     state and shouldn't be reserved.  */\n+\t  if (sched_mask & unit_bit)\n+\t    rsrv[i / 4] &= ~(1 << unit);\n+\t}\n \n       /* Walk through the insns that occur in the same cycle.  We use multiple\n \t passes to assign units, assigning for insns with the most specific\n@@ -3010,27 +3073,56 @@ assign_reservations (rtx head, rtx end)\n \t      && (within == insn || GET_MODE (within) != TImode));\n \t     within = NEXT_INSN (within))\n \t  {\n+\t    int uid = INSN_UID (within);\n \t    int this_rsrv, side;\n \t    int icode;\n \t    enum attr_units units;\n+\t    enum attr_type type;\n \t    int j;\n \n \t    if (!NONDEBUG_INSN_P (within))\n \t      continue;\n \t    icode = recog_memoized (within);\n \t    if (icode < 0)\n \t      continue;\n+\t    if (INSN_INFO_ENTRY (uid).reservation != 0)\n+\t      continue;\n \t    units = get_attr_units (within);\n+\t    type = get_attr_type (within);\n \t    this_rsrv = get_reservation_flags (units);\n \t    if (this_rsrv == 0)\n \t      continue;\n \t    side = get_insn_side (within, units);\n \n+\t    /* Certain floating point instructions are treated specially.  If\n+\t       an insn can choose between units it can reserve, and its\n+\t       reservation spans more than one cycle, the reservation contains\n+\t       special markers in the first cycle to help us reconstruct what\n+\t       the automaton chose.  */\n+\t    if ((type == TYPE_ADDDP || type == TYPE_FP4)\n+\t\t&& units == UNITS_LS)\n+\t      {\n+\t\tint test1_code = ((type == TYPE_FP4 ? UNIT_QID_FPL1 : UNIT_QID_ADDDPL1)\n+\t\t\t\t  + side * UNIT_QID_SIDE_OFFSET);\n+\t\tint test2_code = ((type == TYPE_FP4 ? UNIT_QID_FPS1 : UNIT_QID_ADDDPS1)\n+\t\t\t\t  + side * UNIT_QID_SIDE_OFFSET);\n+\t\tif ((sched_mask & (1 << test1_code)) != 0)\n+\t\t  {\n+\t\t    this_rsrv = RESERVATION_FLAG_L;\n+\t\t    sched_mask &= ~(1 << test1_code);\n+\t\t  }\n+\t\telse if ((sched_mask & (1 << test2_code)) != 0)\n+\t\t  {\n+\t\t    this_rsrv = RESERVATION_FLAG_S;\n+\t\t    sched_mask &= ~(1 << test2_code);\n+\t\t  }\n+\t      }\n+\n \t    if ((this_rsrv & (this_rsrv - 1)) == 0)\n \t      {\n-\t\tint t = exact_log2 (this_rsrv) + side * 4;\n+\t\tint t = exact_log2 (this_rsrv) + side * UNIT_QID_SIDE_OFFSET;\n \t\trsrv[side] |= this_rsrv;\n-\t\tINSN_INFO_ENTRY (INSN_UID (within)).reservation = t;\n+\t\tINSN_INFO_ENTRY (uid).reservation = t;\n \t\tcontinue;\n \t      }\n \n@@ -3059,8 +3151,8 @@ assign_reservations (rtx head, rtx end)\n \t\t  if ((this_rsrv & (1 << j)) && j != best)\n \t\t    rsrv_count[side][j]--;\n \n-\t\tINSN_INFO_ENTRY (INSN_UID (within)).reservation\n-\t\t  = best + side * 4;\n+\t\tINSN_INFO_ENTRY (uid).reservation\n+\t\t  = best + side * UNIT_QID_SIDE_OFFSET;\n \t      }\n \t  }\n     }\n@@ -3098,6 +3190,12 @@ typedef struct c6x_sched_context\n   /* The following variable value is the last issued insn.  */\n   rtx last_scheduled_insn;\n \n+  /* The following variable value is DFA state before issuing the\n+     first insn in the current clock cycle.  We do not use this member\n+     of the structure directly; we copy the data in and out of\n+     prev_cycle_state.  */\n+  state_t prev_cycle_state_ctx;\n+  \n   int reg_n_accesses[FIRST_PSEUDO_REGISTER];\n   int reg_n_xaccesses[FIRST_PSEUDO_REGISTER];\n   int reg_set_in_cycle[FIRST_PSEUDO_REGISTER];\n@@ -3109,6 +3207,11 @@ typedef struct c6x_sched_context\n /* The current scheduling state.  */\n static struct c6x_sched_context ss;\n \n+/* The following variable value is DFA state before issueing the first insn\n+   in the current clock cycle.  This is used in c6x_variable_issue for\n+   comparison with the state after issuing the last insn in a cycle.  */\n+static state_t prev_cycle_state;\n+\n /* Set when we discover while processing an insn that it would lead to too\n    many accesses of the same register.  */\n static bool reg_access_stall;\n@@ -3181,6 +3284,7 @@ insn_set_clock (rtx insn, int cycle)\n \n   INSN_INFO_ENTRY (uid).clock = cycle;\n   INSN_INFO_ENTRY (uid).new_cond = NULL;\n+  INSN_INFO_ENTRY (uid).reservation = 0;\n   INSN_INFO_ENTRY (uid).ebb_start = false;\n }\n \n@@ -3317,9 +3421,13 @@ init_sched_state (c6x_sched_context_t sc)\n   sc->delays_finished_at = 0;\n   sc->curr_sched_clock = 0;\n \n+  sc->prev_cycle_state_ctx = xmalloc (dfa_state_size);\n+\n   memset (sc->reg_n_accesses, 0, sizeof sc->reg_n_accesses);\n   memset (sc->reg_n_xaccesses, 0, sizeof sc->reg_n_xaccesses);\n   memset (sc->reg_set_in_cycle, 0, sizeof sc->reg_set_in_cycle);\n+\n+  state_reset (sc->prev_cycle_state_ctx);\n }\n \n /* Allocate store for new scheduling context.  */\n@@ -3341,7 +3449,11 @@ c6x_init_sched_context (void *_sc, bool clean_p)\n       init_sched_state (sc);\n     }\n   else\n-    *sc = ss;\n+    {\n+      *sc = ss;\n+      sc->prev_cycle_state_ctx = xmalloc (dfa_state_size);\n+      memcpy (sc->prev_cycle_state_ctx, prev_cycle_state, dfa_state_size);\n+    }\n }\n \n /* Sets the global scheduling context to the one pointed to by _SC.  */\n@@ -3352,6 +3464,17 @@ c6x_set_sched_context (void *_sc)\n \n   gcc_assert (sc != NULL);\n   ss = *sc;\n+  memcpy (prev_cycle_state, sc->prev_cycle_state_ctx, dfa_state_size);\n+}\n+\n+/* Clear data in _SC.  */\n+static void\n+c6x_clear_sched_context (void *_sc)\n+{\n+  c6x_sched_context_t sc = (c6x_sched_context_t) _sc;\n+  gcc_assert (_sc != NULL);\n+\n+  free (sc->prev_cycle_state_ctx); \n }\n \n /* Free _SC.  */\n@@ -3384,14 +3507,46 @@ c6x_issue_rate (void)\n   return 8;\n }\n \n+/* Used together with the collapse_ndfa option, this ensures that we reach a\n+   deterministic automaton state before trying to advance a cycle.\n+   With collapse_ndfa, genautomata creates advance cycle arcs only for\n+   such deterministic states.  */\n+\n+static rtx\n+c6x_sched_dfa_pre_cycle_insn (void)\n+{\n+  return const0_rtx;\n+}\n+\n /* We're beginning a new block.  Initialize data structures as necessary.  */\n \n static void\n c6x_sched_init (FILE *dump ATTRIBUTE_UNUSED,\n \t\tint sched_verbose ATTRIBUTE_UNUSED,\n \t\tint max_ready ATTRIBUTE_UNUSED)\n {\n+  if (prev_cycle_state == NULL)\n+    {\n+      prev_cycle_state = xmalloc (dfa_state_size);\n+    }\n   init_sched_state (&ss);\n+  state_reset (prev_cycle_state);\n+}\n+\n+/* We are about to being issuing INSN.  Return nonzero if we cannot\n+   issue it on given cycle CLOCK and return zero if we should not sort\n+   the ready queue on the next clock start.\n+   For C6X, we use this function just to copy the previous DFA state\n+   for comparison purposes.  */\n+\n+static int\n+c6x_dfa_new_cycle (FILE *dump ATTRIBUTE_UNUSED, int verbose ATTRIBUTE_UNUSED,\n+\t\t   rtx insn ATTRIBUTE_UNUSED, int last_clock ATTRIBUTE_UNUSED,\n+\t\t   int clock ATTRIBUTE_UNUSED, int *sort_p ATTRIBUTE_UNUSED)\n+{\n+  if (clock != last_clock)\n+    memcpy (prev_cycle_state, curr_state, dfa_state_size);\n+  return 0;\n }\n \n static void\n@@ -3766,11 +3921,14 @@ c6x_variable_issue (FILE *dump ATTRIBUTE_UNUSED,\n     ss.issued_this_cycle++;\n   if (insn_info)\n     {\n+      state_t st_after = alloca (dfa_state_size);\n       int curr_clock = ss.curr_sched_clock;\n       int uid = INSN_UID (insn);\n       int icode = recog_memoized (insn);\n       rtx first_cond;\n       int first, first_cycle;\n+      unsigned int mask;\n+      int i;\n \n       insn_set_clock (insn, curr_clock);\n       INSN_INFO_ENTRY (uid).ebb_start\n@@ -3795,6 +3953,16 @@ c6x_variable_issue (FILE *dump ATTRIBUTE_UNUSED,\n \t      || get_attr_type (insn) == TYPE_CALL))\n \tINSN_INFO_ENTRY (uid).new_cond = first_cond;\n \n+      memcpy (st_after, curr_state, dfa_state_size);\n+      state_transition (st_after, const0_rtx);\n+\n+      mask = 0;\n+      for (i = 0; i < 2 * UNIT_QID_SIDE_OFFSET; i++)\n+\tif (cpu_unit_reservation_p (st_after, c6x_unit_codes[i])\n+\t    && !cpu_unit_reservation_p (prev_cycle_state, c6x_unit_codes[i]))\n+\t  mask |= 1 << i;\n+      INSN_INFO_ENTRY (uid).unit_mask = mask;\n+\n       maybe_clobber_cond (insn, curr_clock);\n \n       if (icode >= 0)\n@@ -4323,15 +4491,19 @@ reorg_split_calls (rtx *call_labels)\n \t      if (can_use_callp (insn))\n \t\t{\n \t\t  /* Find the first insn of the next execute packet.  If it\n-\t\t     is outside the branch delay slots of this call, we may\n+\t\t     is the shadow insn corresponding to this call, we may\n \t\t     use a CALLP insn.  */\n-\t\t  rtx next_cycle_start = next_nonnote_nondebug_insn (last_same_clock);\n+\t\t  rtx shadow = next_nonnote_nondebug_insn (last_same_clock);\n \n-\t\t  if (CALL_P (next_cycle_start)\n-\t\t      && (insn_get_clock (next_cycle_start) == this_clock + 5))\n+\t\t  if (CALL_P (shadow)\n+\t\t      && insn_get_clock (shadow) == this_clock + 5)\n \t\t    {\n-\t\t      convert_to_callp (next_cycle_start);\n-\t\t      insn_set_clock (next_cycle_start, this_clock);\n+\t\t      convert_to_callp (shadow);\n+\t\t      insn_set_clock (shadow, this_clock);\n+\t\t      INSN_INFO_ENTRY (INSN_UID (shadow)).reservation\n+\t\t\t= RESERVATION_S2;\n+\t\t      INSN_INFO_ENTRY (INSN_UID (shadow)).unit_mask\n+\t\t\t= INSN_INFO_ENTRY (INSN_UID (last_same_clock)).unit_mask;\n \t\t      if (GET_MODE (insn) == TImode)\n \t\t\t{\n \t\t\t  rtx new_cycle_first = NEXT_INSN (insn);\n@@ -4340,13 +4512,13 @@ reorg_split_calls (rtx *call_labels)\n \t\t\t\t || GET_CODE (PATTERN (new_cycle_first)) == CLOBBER)\n \t\t\t    new_cycle_first = NEXT_INSN (new_cycle_first);\n \t\t\t  PUT_MODE (new_cycle_first, TImode);\n-\t\t\t  if (new_cycle_first != next_cycle_start)\n-\t\t\t    PUT_MODE (next_cycle_start, VOIDmode);\n+\t\t\t  if (new_cycle_first != shadow)\n+\t\t\t    PUT_MODE (shadow, VOIDmode);\n \t\t\t  INSN_INFO_ENTRY (INSN_UID (new_cycle_first)).ebb_start\n \t\t\t    = INSN_INFO_ENTRY (INSN_UID (insn)).ebb_start;\n \t\t\t}\n \t\t      else\n-\t\t\tPUT_MODE (next_cycle_start, VOIDmode);\n+\t\t\tPUT_MODE (shadow, VOIDmode);\n \t\t      delete_insn (insn);\n \t\t      goto done;\n \t\t    }\n@@ -4364,6 +4536,9 @@ reorg_split_calls (rtx *call_labels)\n \t\t  INSN_INFO_ENTRY (INSN_UID (x1)).reservation = RESERVATION_S2;\n \t\t  if (after1 == last_same_clock)\n \t\t    PUT_MODE (x1, TImode);\n+\t\t  else\n+\t\t    INSN_INFO_ENTRY (INSN_UID (x1)).unit_mask\n+\t\t      = INSN_INFO_ENTRY (INSN_UID (after1)).unit_mask;\n \t\t}\n \t      else\n \t\t{\n@@ -4381,8 +4556,14 @@ reorg_split_calls (rtx *call_labels)\n \t\t  INSN_INFO_ENTRY (INSN_UID (x2)).reservation = RESERVATION_S2;\n \t\t  if (after1 == last_same_clock)\n \t\t    PUT_MODE (x1, TImode);\n+\t\t  else\n+\t\t    INSN_INFO_ENTRY (INSN_UID (x1)).unit_mask\n+\t\t      = INSN_INFO_ENTRY (INSN_UID (after1)).unit_mask;\n \t\t  if (after1 == after2)\n \t\t    PUT_MODE (x2, TImode);\n+\t\t  else\n+\t\t    INSN_INFO_ENTRY (INSN_UID (x2)).unit_mask\n+\t\t      = INSN_INFO_ENTRY (INSN_UID (after2)).unit_mask;\n \t\t}\n \t    }\n \t}\n@@ -5524,6 +5705,10 @@ c6x_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n #define TARGET_SCHED_REORDER c6x_sched_reorder\n #undef TARGET_SCHED_REORDER2\n #define TARGET_SCHED_REORDER2 c6x_sched_reorder2\n+#undef TARGET_SCHED_DFA_NEW_CYCLE\n+#define TARGET_SCHED_DFA_NEW_CYCLE c6x_dfa_new_cycle\n+#undef TARGET_SCHED_DFA_PRE_CYCLE_INSN\n+#define TARGET_SCHED_DFA_PRE_CYCLE_INSN c6x_sched_dfa_pre_cycle_insn\n #undef TARGET_SCHED_EXPOSED_PIPELINE\n #define TARGET_SCHED_EXPOSED_PIPELINE true\n \n@@ -5533,6 +5718,8 @@ c6x_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n #define TARGET_SCHED_INIT_SCHED_CONTEXT c6x_init_sched_context\n #undef TARGET_SCHED_SET_SCHED_CONTEXT\n #define TARGET_SCHED_SET_SCHED_CONTEXT c6x_set_sched_context\n+#undef TARGET_SCHED_CLEAR_SCHED_CONTEXT\n+#define TARGET_SCHED_CLEAR_SCHED_CONTEXT c6x_clear_sched_context\n #undef TARGET_SCHED_FREE_SCHED_CONTEXT\n #define TARGET_SCHED_FREE_SCHED_CONTEXT c6x_free_sched_context\n "}, {"sha": "9b1b1636b52cc0694fc75254a11804c267137a30", "filename": "gcc/config/c6x/c6x.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e/gcc%2Fconfig%2Fc6x%2Fc6x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e/gcc%2Fconfig%2Fc6x%2Fc6x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.h?ref=6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e", "patch": "@@ -612,6 +612,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define Pmode SImode\n #define FUNCTION_MODE QImode\n \n+#define CPU_UNITS_QUERY 1\n+\n extern int c6x_initial_flag_pic;\n \n #endif /* GCC_C6X_H */"}, {"sha": "c2502ca1a42bc2748fe6d1ed309c5bc6f2078c19", "filename": "gcc/config/c6x/c6x.md", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e/gcc%2Fconfig%2Fc6x%2Fc6x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e/gcc%2Fconfig%2Fc6x%2Fc6x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.md?ref=6bd9bf425438065b5a1daf0b19a0f8cdd0ed985e", "patch": "@@ -242,21 +242,27 @@\n \t]\n \t(const_string \"unknown\")))\n \n-(define_automaton \"c6x_1,c6x_w1,c6x_2,c6x_w2,c6x_m1,c6x_m2,c6x_t1,c6x_t2,c6x_branch\")\n+(define_automaton \"c6x_1,c6x_2,c6x_m1,c6x_m2,c6x_t1,c6x_t2,c6x_branch\")\n+(automata_option \"no-comb-vect\")\n (automata_option \"ndfa\")\n+(automata_option \"collapse-ndfa\")\n \n-(define_cpu_unit \"d1,l1,s1\" \"c6x_1\")\n+(define_query_cpu_unit \"d1,l1,s1\" \"c6x_1\")\n (define_cpu_unit \"x1\" \"c6x_1\")\n-(define_cpu_unit \"l1w,s1w\" \"c6x_w1\")\n-(define_cpu_unit \"m1\" \"c6x_m1\")\n+(define_cpu_unit \"l1w,s1w\" \"c6x_1\")\n+(define_query_cpu_unit \"m1\" \"c6x_m1\")\n (define_cpu_unit \"m1w\" \"c6x_m1\")\n (define_cpu_unit \"t1\" \"c6x_t1\")\n-(define_cpu_unit \"d2,l2,s2\" \"c6x_2\")\n+(define_query_cpu_unit \"d2,l2,s2\" \"c6x_2\")\n (define_cpu_unit \"x2\" \"c6x_2\")\n-(define_cpu_unit \"l2w,s2w\" \"c6x_w2\")\n-(define_cpu_unit \"m2\" \"c6x_m2\")\n+(define_cpu_unit \"l2w,s2w\" \"c6x_2\")\n+(define_query_cpu_unit \"m2\" \"c6x_m2\")\n (define_cpu_unit \"m2w\" \"c6x_m2\")\n (define_cpu_unit \"t2\" \"c6x_t2\")\n+;; A special set of units used to identify specific reservations, rather than\n+;; just units.\n+(define_query_cpu_unit \"fps1,fpl1,adddps1,adddpl1\" \"c6x_1\")\n+(define_query_cpu_unit \"fps2,fpl2,adddps2,adddpl2\" \"c6x_2\")\n \n ;; There can be up to two branches in one cycle (on the .s1 and .s2\n ;; units), but some instructions must not be scheduled in parallel"}]}