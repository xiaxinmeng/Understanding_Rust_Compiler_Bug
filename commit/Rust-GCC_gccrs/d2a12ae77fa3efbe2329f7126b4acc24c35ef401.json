{"sha": "d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJhMTJhZTc3ZmEzZWZiZTIzMjlmNzEyNmI0YWNjMjRjMzVlZjQwMQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-03-16T09:47:09Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-03-16T09:47:09Z"}, "message": "tree.h (TREE_VECTOR_CST_ELTS): Remove.\n\n2012-03-16  Richard Guenther  <rguenther@suse.de>\n\n\t* tree.h (TREE_VECTOR_CST_ELTS): Remove.\n\t(VECTOR_CST_NELTS, VECTOR_CST_ELTS, VECTOR_CST_ELT): New defines.\n\t(struct tree_vector): Remove elements member, add variable size\n\telts array member.\n\t(build_vector_stat): Declare.\n\t(build_vector): Define in terms of build_vector_stat.\n\t* tree.c (build_vector): Rename to ...\n\t(build_vector_stat): ... this.  Take array of trees as parameter.\n\t(build_vector_from_ctor): Adjust.\n\t(integer_zerop, integer_onep, integer_all_onesp, iterative_hash_expr,\n\tinitializer_zerop): Adjust.\n\t* cfgexpand.c (expand_debug_expr): Likewise.\n\t* expr.c (categorize_ctor_elements_1, expand_expr_real_1,\n\tconst_vector_from_tree): Likewise.\n\t* fold-const.c (const_binop, operand_equal_p, native_encode_vector,\n\tnative_interpret_vector, fold_unary_loc, vec_cst_ctor_to_array,\n\tfold_vec_perm, fold_binary_loc, fold_ternary_loc): Likewise.\n\t* tree-streamer-in.c (streamer_alloc_tree): Handle TS_VECTOR.\n\t(lto_input_ts_vector_tree_pointers): Adjust.\n\t* tree-streamer-out.c (streamer_write_tree_header): Handle TS_VECTOR.\n\t(write_ts_vector_tree_pointers): Adjust.\n\t* varasm.c (const_hash_1, compare_constant, copy_constant,\n\toutput_constant): Adjust.\n\t* gimple-fold.c (gimple_fold_stmt_to_constant_1): Adjust.\n\t* print-tree.c (print_node): Adjust.\n\t* tree-pretty-print.c (dump_generic_node): Adjust.\n\t* tree-vect-generic.c (uniform_vector_p, vector_element,\n\tlower_vec_perm): Adjust.\n\t* tree-vect-loop.c (get_initial_def_for_reduction): Adjust.\n\t* tree-vect-slp.c (vect_get_constant_vectors,\n\tvect_transform_slp_perm_load): Adjust.\n\t* tree-vect-stmts.c (vect_gen_perm_mask): Adjust.\n\t* expmed.c (make_tree): Adjust.\n\n\t* config/i386/i386.c (ix86_expand_builtin): Adjust.\n\t* config/sparc/sparc.c (sparc_handle_vis_mul8x16): Adjust interface\n\tand implementation.\n\t(sparc_fold_builtin): Adjust.\n\n\tc-family/\n\t* c-pretty-print.c (pp_c_initializer_list): Adjust.\n\nFrom-SVN: r185458", "tree": {"sha": "61b2d8308768796bdf3f7e0c34b84aa6cc0bae11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61b2d8308768796bdf3f7e0c34b84aa6cc0bae11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "20bfad56eb81a52c7449521282401c88deee391b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20bfad56eb81a52c7449521282401c88deee391b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20bfad56eb81a52c7449521282401c88deee391b"}], "stats": {"total": 681, "additions": 342, "deletions": 339}, "files": [{"sha": "eb696d7a7337ae750ed0169ad45a3e2a76baa091", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "patch": "@@ -1,3 +1,43 @@\n+2012-03-16  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree.h (TREE_VECTOR_CST_ELTS): Remove.\n+\t(VECTOR_CST_NELTS, VECTOR_CST_ELTS, VECTOR_CST_ELT): New defines.\n+\t(struct tree_vector): Remove elements member, add variable size\n+\telts array member.\n+\t(build_vector_stat): Declare.\n+\t(build_vector): Define in terms of build_vector_stat.\n+\t* tree.c (build_vector): Rename to ...\n+\t(build_vector_stat): ... this.  Take array of trees as parameter.\n+\t(build_vector_from_ctor): Adjust.\n+\t(integer_zerop, integer_onep, integer_all_onesp, iterative_hash_expr,\n+\tinitializer_zerop): Adjust.\n+\t* cfgexpand.c (expand_debug_expr): Likewise.\n+\t* expr.c (categorize_ctor_elements_1, expand_expr_real_1,\n+\tconst_vector_from_tree): Likewise.\n+\t* fold-const.c (const_binop, operand_equal_p, native_encode_vector,\n+\tnative_interpret_vector, fold_unary_loc, vec_cst_ctor_to_array,\n+\tfold_vec_perm, fold_binary_loc, fold_ternary_loc): Likewise.\n+\t* tree-streamer-in.c (streamer_alloc_tree): Handle TS_VECTOR.\n+\t(lto_input_ts_vector_tree_pointers): Adjust.\n+\t* tree-streamer-out.c (streamer_write_tree_header): Handle TS_VECTOR.\n+\t(write_ts_vector_tree_pointers): Adjust.\n+\t* varasm.c (const_hash_1, compare_constant, copy_constant,\n+\toutput_constant): Adjust.\n+\t* gimple-fold.c (gimple_fold_stmt_to_constant_1): Adjust.\n+\t* print-tree.c (print_node): Adjust.\n+\t* tree-pretty-print.c (dump_generic_node): Adjust.\n+\t* tree-vect-generic.c (uniform_vector_p, vector_element,\n+\tlower_vec_perm): Adjust.\n+\t* tree-vect-loop.c (get_initial_def_for_reduction): Adjust.\n+\t* tree-vect-slp.c (vect_get_constant_vectors,\n+\tvect_transform_slp_perm_load): Adjust.\n+\t* tree-vect-stmts.c (vect_gen_perm_mask): Adjust.\n+\t* expmed.c (make_tree): Adjust.\n+\t* config/i386/i386.c (ix86_expand_builtin): Adjust.\n+\t* config/sparc/sparc.c (sparc_handle_vis_mul8x16): Adjust interface\n+\tand implementation.\n+\t(sparc_fold_builtin): Adjust.\n+\n 2012-03-16  Tristan Gingold  <gingold@adacore.com>\n \n \t* config.gcc (*-*-*vms*): Define use_gcc_stdint and tm_file."}, {"sha": "dd7b77b355a62b361fd0febab4afe577bc770776", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "patch": "@@ -1,3 +1,7 @@\n+2012-03-16  Richard Guenther  <rguenther@suse.de>\n+\n+\t* c-pretty-print.c (pp_c_initializer_list): Adjust.\n+\n 2012-03-15  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR c++/44783"}, {"sha": "929ad18384f225cc4f7339a8f1369c559d258544", "filename": "gcc/c-family/c-pretty-print.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Fc-family%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Fc-family%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.c?ref=d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "patch": "@@ -1372,7 +1372,15 @@ pp_c_initializer_list (c_pretty_printer *pp, tree e)\n \n     case VECTOR_TYPE:\n       if (TREE_CODE (e) == VECTOR_CST)\n-\tpp_c_expression_list (pp, TREE_VECTOR_CST_ELTS (e));\n+\t{\n+\t  unsigned i;\n+\t  for (i = 0; i < VECTOR_CST_NELTS (e); ++i)\n+\t    {\n+\t      if (i > 0)\n+\t\tpp_separate_with (pp, ',');\n+\t      pp_expression (pp, VECTOR_CST_ELT (e, i));\n+\t    }\n+\t}\n       else\n \tbreak;\n       return;"}, {"sha": "bd21169eb876849cdf9bceda5cd481bf30924d41", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "patch": "@@ -3354,9 +3354,22 @@ expand_debug_expr (tree exp)\n       return op0;\n \n     case VECTOR_CST:\n-      exp = build_constructor_from_list (TREE_TYPE (exp),\n-\t\t\t\t\t TREE_VECTOR_CST_ELTS (exp));\n-      /* Fall through.  */\n+      {\n+\tunsigned i;\n+\n+\top0 = gen_rtx_CONCATN\n+\t  (mode, rtvec_alloc (TYPE_VECTOR_SUBPARTS (TREE_TYPE (exp))));\n+\n+\tfor (i = 0; i < VECTOR_CST_NELTS (exp); ++i)\n+\t  {\n+\t    op1 = expand_debug_expr (VECTOR_CST_ELT (exp, i));\n+\t    if (!op1)\n+\t      return NULL;\n+\t    XVECEXP (op0, 0, i) = op1;\n+\t  }\n+\n+\treturn op0;\n+      }\n \n     case CONSTRUCTOR:\n       if (TREE_CLOBBER_P (exp))"}, {"sha": "78a366ef7dcf405ba00c17bf494201e59523dee8", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "patch": "@@ -29653,12 +29653,10 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \t{\n \t  if (TREE_CODE (arg3) == VECTOR_CST)\n \t    {\n-\t      tree elt;\n \t      unsigned int negative = 0;\n-\t      for (elt = TREE_VECTOR_CST_ELTS (arg3);\n-\t\t   elt; elt = TREE_CHAIN (elt))\n+\t      for (i = 0; i < VECTOR_CST_NELTS (arg3); ++i)\n \t\t{\n-\t\t  tree cst = TREE_VALUE (elt);\n+\t\t  tree cst = VECTOR_CST_ELT (arg3, i);\n \t\t  if (TREE_CODE (cst) == INTEGER_CST\n \t\t      && tree_int_cst_sign_bit (cst))\n \t\t    negative++;"}, {"sha": "4048db0560aac6031656b2d4fff79e4ab22d217f", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 45, "deletions": 63, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "patch": "@@ -514,7 +514,7 @@ static void sparc_vis_init_builtins (void);\n static rtx sparc_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n static tree sparc_fold_builtin (tree, int, tree *, bool);\n static int sparc_vis_mul8x16 (int, int);\n-static tree sparc_handle_vis_mul8x16 (int, tree, tree, tree);\n+static void sparc_handle_vis_mul8x16 (tree *, int, tree, tree, tree);\n static void sparc_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t   HOST_WIDE_INT, tree);\n static bool sparc_can_output_mi_thunk (const_tree, HOST_WIDE_INT,\n@@ -9897,67 +9897,57 @@ sparc_vis_mul8x16 (int e8, int e16)\n   return (e8 * e16 + 128) / 256;\n }\n \n-/* Multiply the vector elements in ELTS0 to the elements in ELTS1 as specified\n-   by FNCODE.  All of the elements in ELTS0 and ELTS1 lists must be integer\n-   constants.  A tree list with the results of the multiplications is returned,\n-   and each element in the list is of INNER_TYPE.  */\n+/* Multiply the VECTOR_CSTs CST0 and CST1 as specified by FNCODE and put\n+   the result into the array N_ELTS, whose elements are of INNER_TYPE.  */\n \n-static tree\n-sparc_handle_vis_mul8x16 (int fncode, tree inner_type, tree elts0, tree elts1)\n+static void\n+sparc_handle_vis_mul8x16 (tree *n_elts, int fncode, tree inner_type,\n+\t\t\t  tree cst0, tree cst1)\n {\n-  tree n_elts = NULL_TREE;\n+  unsigned i, num = VECTOR_CST_NELTS (cst0);\n   int scale;\n \n   switch (fncode)\n     {\n     case CODE_FOR_fmul8x16_vis:\n-      for (; elts0 && elts1;\n-\t   elts0 = TREE_CHAIN (elts0), elts1 = TREE_CHAIN (elts1))\n+      for (i = 0; i < num; ++i)\n \t{\n \t  int val\n-\t    = sparc_vis_mul8x16 (TREE_INT_CST_LOW (TREE_VALUE (elts0)),\n-\t\t\t\t TREE_INT_CST_LOW (TREE_VALUE (elts1)));\n-\t  n_elts = tree_cons (NULL_TREE,\n-\t\t\t      build_int_cst (inner_type, val),\n-\t\t\t      n_elts);\n+\t    = sparc_vis_mul8x16 (TREE_INT_CST_LOW (VECTOR_CST_ELT (cst0, i)),\n+\t\t\t\t TREE_INT_CST_LOW (VECTOR_CST_ELT (cst1, i)));\n+\t  n_elts[i] = build_int_cst (inner_type, val);\n \t}\n       break;\n \n     case CODE_FOR_fmul8x16au_vis:\n-      scale = TREE_INT_CST_LOW (TREE_VALUE (elts1));\n+      scale = TREE_INT_CST_LOW (VECTOR_CST_ELT (cst1, 0));\n \n-      for (; elts0; elts0 = TREE_CHAIN (elts0))\n+      for (i = 0; i < num; ++i)\n \t{\n \t  int val\n-\t    = sparc_vis_mul8x16 (TREE_INT_CST_LOW (TREE_VALUE (elts0)),\n+\t    = sparc_vis_mul8x16 (TREE_INT_CST_LOW (VECTOR_CST_ELT (cst0, i)),\n \t\t\t\t scale);\n-\t  n_elts = tree_cons (NULL_TREE,\n-\t\t\t      build_int_cst (inner_type, val),\n-\t\t\t      n_elts);\n+\t  n_elts[i] = build_int_cst (inner_type, val);\n \t}\n       break;\n \n     case CODE_FOR_fmul8x16al_vis:\n-      scale = TREE_INT_CST_LOW (TREE_VALUE (TREE_CHAIN (elts1)));\n+      scale = TREE_INT_CST_LOW (VECTOR_CST_ELT (cst1, 0));\n \n-      for (; elts0; elts0 = TREE_CHAIN (elts0))\n+      for (i = 0; i < num; ++i)\n \t{\n \t  int val\n-\t    = sparc_vis_mul8x16 (TREE_INT_CST_LOW (TREE_VALUE (elts0)),\n+\t    = sparc_vis_mul8x16 (TREE_INT_CST_LOW (VECTOR_CST_ELT (cst0, i)),\n \t\t\t\t scale);\n-\t  n_elts = tree_cons (NULL_TREE,\n-\t\t\t      build_int_cst (inner_type, val),\n-\t\t\t      n_elts);\n+\t  n_elts[i] = build_int_cst (inner_type, val);\n \t}\n       break;\n \n     default:\n       gcc_unreachable ();\n     }\n-\n-  return nreverse (n_elts);\n-\n }\n+\n /* Handle TARGET_FOLD_BUILTIN target hook.\n    Fold builtin functions for SPARC intrinsics.  If IGNORE is true the\n    result of the function call is ignored.  NULL_TREE is returned if the\n@@ -10001,17 +9991,15 @@ sparc_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED,\n       if (TREE_CODE (arg0) == VECTOR_CST)\n \t{\n \t  tree inner_type = TREE_TYPE (rtype);\n-\t  tree elts = TREE_VECTOR_CST_ELTS (arg0);\n-\t  tree n_elts = NULL_TREE;\n-\n-\t  for (; elts; elts = TREE_CHAIN (elts))\n-\t    {\n-\t      unsigned int val = TREE_INT_CST_LOW (TREE_VALUE (elts)) << 4;\n-\t      n_elts = tree_cons (NULL_TREE,\n-\t\t\t\t  build_int_cst (inner_type, val),\n-\t\t\t\t  n_elts);\n-\t    }\n-\t  return build_vector (rtype, nreverse (n_elts));\n+\t  tree *n_elts;\n+\t  unsigned i;\n+\n+\t  n_elts = XALLOCAVEC (tree, VECTOR_CST_NELTS (arg0));\n+\t  for (i = 0; i < VECTOR_CST_NELTS (arg0); ++i)\n+\t    n_elts[i] = build_int_cst (inner_type,\n+\t\t\t\t       TREE_INT_CST_LOW\n+\t\t\t\t         (VECTOR_CST_ELT (arg0, i)) << 4);\n+\t  return build_vector (rtype, n_elts);\n \t}\n       break;\n \n@@ -10026,11 +10014,8 @@ sparc_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED,\n       if (TREE_CODE (arg0) == VECTOR_CST && TREE_CODE (arg1) == VECTOR_CST)\n \t{\n \t  tree inner_type = TREE_TYPE (rtype);\n-\t  tree elts0 = TREE_VECTOR_CST_ELTS (arg0);\n-\t  tree elts1 = TREE_VECTOR_CST_ELTS (arg1);\n-\t  tree n_elts = sparc_handle_vis_mul8x16 (icode, inner_type, elts0,\n-\t\t\t\t\t\t  elts1);\n-\n+\t  tree *n_elts = XALLOCAVEC (tree, VECTOR_CST_NELTS (arg0));\n+\t  sparc_handle_vis_mul8x16 (n_elts, icode, inner_type, arg0, arg1);\n \t  return build_vector (rtype, n_elts);\n \t}\n       break;\n@@ -10043,18 +10028,15 @@ sparc_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED,\n \n       if (TREE_CODE (arg0) == VECTOR_CST && TREE_CODE (arg1) == VECTOR_CST)\n \t{\n-\t  tree elts0 = TREE_VECTOR_CST_ELTS (arg0);\n-\t  tree elts1 = TREE_VECTOR_CST_ELTS (arg1);\n-\t  tree n_elts = NULL_TREE;\n-\n-\t  for (; elts0 && elts1;\n-\t       elts0 = TREE_CHAIN (elts0), elts1 = TREE_CHAIN (elts1))\n+\t  tree *n_elts = XALLOCAVEC (tree, 2 * VECTOR_CST_NELTS (arg0));\n+\t  unsigned i;\n+\t  for (i = 0; i < VECTOR_CST_NELTS (arg0); ++i)\n \t    {\n-\t      n_elts = tree_cons (NULL_TREE, TREE_VALUE (elts0), n_elts);\n-\t      n_elts = tree_cons (NULL_TREE, TREE_VALUE (elts1), n_elts);\n+\t      n_elts[2*i] = VECTOR_CST_ELT (arg0, i);\n+\t      n_elts[2*i+1] = VECTOR_CST_ELT (arg1, i);\n \t    }\n \n-\t  return build_vector (rtype, nreverse (n_elts));\n+\t  return build_vector (rtype, n_elts);\n \t}\n       break;\n \n@@ -10073,17 +10055,17 @@ sparc_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED,\n \t  int overflow = 0;\n \t  unsigned HOST_WIDE_INT low = TREE_INT_CST_LOW (arg2);\n \t  HOST_WIDE_INT high = TREE_INT_CST_HIGH (arg2);\n-\t  tree elts0 = TREE_VECTOR_CST_ELTS (arg0);\n-\t  tree elts1 = TREE_VECTOR_CST_ELTS (arg1);\n+\t  unsigned i;\n \n-\t  for (; elts0 && elts1;\n-\t       elts0 = TREE_CHAIN (elts0), elts1 = TREE_CHAIN (elts1))\n+\t  for (i = 0; i < VECTOR_CST_NELTS (arg0); ++i)\n \t    {\n \t      unsigned HOST_WIDE_INT\n-\t\tlow0 = TREE_INT_CST_LOW (TREE_VALUE (elts0)),\n-\t\tlow1 = TREE_INT_CST_LOW (TREE_VALUE (elts1));\n-\t      HOST_WIDE_INT high0 = TREE_INT_CST_HIGH (TREE_VALUE (elts0));\n-\t      HOST_WIDE_INT high1 = TREE_INT_CST_HIGH (TREE_VALUE (elts1));\n+\t\tlow0 = TREE_INT_CST_LOW (VECTOR_CST_ELT (arg0, i)),\n+\t\tlow1 = TREE_INT_CST_LOW (VECTOR_CST_ELT (arg1, i));\n+\t      HOST_WIDE_INT\n+\t\thigh0 = TREE_INT_CST_HIGH (VECTOR_CST_ELT (arg0, i));\n+\t      HOST_WIDE_INT\n+\t\thigh1 = TREE_INT_CST_HIGH (VECTOR_CST_ELT (arg1, i));\n \n \t      unsigned HOST_WIDE_INT l;\n \t      HOST_WIDE_INT h;"}, {"sha": "5134b738b05ce8d76b6818999ad34e89cb5f9717", "filename": "gcc/expmed.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "patch": "@@ -4970,18 +4970,18 @@ make_tree (tree type, rtx x)\n       {\n \tint units = CONST_VECTOR_NUNITS (x);\n \ttree itype = TREE_TYPE (type);\n-\ttree t = NULL_TREE;\n+\ttree *elts;\n \tint i;\n \n-\n \t/* Build a tree with vector elements.  */\n+\telts = XALLOCAVEC (tree, units);\n \tfor (i = units - 1; i >= 0; --i)\n \t  {\n \t    rtx elt = CONST_VECTOR_ELT (x, i);\n-\t    t = tree_cons (NULL_TREE, make_tree (itype, elt), t);\n+\t    elts[i] = make_tree (itype, elt);\n \t  }\n \n-\treturn build_vector (type, t);\n+\treturn build_vector (type, elts);\n       }\n \n     case PLUS:"}, {"sha": "df7cb03e7ef0d5ebf7ce1e67f3b1906ec03d7ee6", "filename": "gcc/expr.c", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "patch": "@@ -5461,10 +5461,11 @@ categorize_ctor_elements_1 (const_tree ctor, HOST_WIDE_INT *p_nz_elts,\n \n \tcase VECTOR_CST:\n \t  {\n-\t    tree v;\n-\t    for (v = TREE_VECTOR_CST_ELTS (value); v; v = TREE_CHAIN (v))\n+\t    unsigned i;\n+\t    for (i = 0; i < VECTOR_CST_NELTS (value); ++i)\n \t      {\n-\t\tif (!initializer_zerop (TREE_VALUE (v)))\n+\t\ttree v = VECTOR_CST_ELT (value, i);\n+\t\tif (!initializer_zerop (v))\n \t\t  nz_elts += mult;\n \t\tinit_elts += mult;\n \t      }\n@@ -9122,8 +9123,14 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t      tmp = fold_unary_loc (loc, VIEW_CONVERT_EXPR, type_for_mode, exp);\n \t  }\n \tif (!tmp)\n-\t  tmp = build_constructor_from_list (type,\n-\t\t\t\t\t     TREE_VECTOR_CST_ELTS (exp));\n+\t  {\n+\t    VEC(constructor_elt,gc) *v;\n+\t    unsigned i;\n+\t    v = VEC_alloc (constructor_elt, gc, VECTOR_CST_NELTS (exp));\n+\t    for (i = 0; i < VECTOR_CST_NELTS (exp); ++i)\n+\t      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, VECTOR_CST_ELT (exp, i));\n+\t    tmp = build_constructor (type, v);\n+\t  }\n \treturn expand_expr (tmp, ignore ? const0_rtx : target,\n \t\t\t    tmode, modifier);\n       }\n@@ -10767,8 +10774,9 @@ static rtx\n const_vector_from_tree (tree exp)\n {\n   rtvec v;\n-  int units, i;\n-  tree link, elt;\n+  unsigned i;\n+  int units;\n+  tree elt;\n   enum machine_mode inner, mode;\n \n   mode = TYPE_MODE (TREE_TYPE (exp));\n@@ -10781,10 +10789,9 @@ const_vector_from_tree (tree exp)\n \n   v = rtvec_alloc (units);\n \n-  link = TREE_VECTOR_CST_ELTS (exp);\n-  for (i = 0; link; link = TREE_CHAIN (link), ++i)\n+  for (i = 0; i < VECTOR_CST_NELTS (exp); ++i)\n     {\n-      elt = TREE_VALUE (link);\n+      elt = VECTOR_CST_ELT (exp, i);\n \n       if (TREE_CODE (elt) == REAL_CST)\n \tRTVEC_ELT (v, i) = CONST_DOUBLE_FROM_REAL_VALUE (TREE_REAL_CST (elt),\n@@ -10797,10 +10804,6 @@ const_vector_from_tree (tree exp)\n \t\t\t\t\t\t   inner);\n     }\n \n-  /* Initialize remaining elements to 0.  */\n-  for (; i < units; ++i)\n-    RTVEC_ELT (v, i) = CONST0_RTX (inner);\n-\n   return gen_rtx_CONST_VECTOR (mode, v);\n }\n "}, {"sha": "0cd84285ee1a13e1f882a50dfa51916220d16c53", "filename": "gcc/fold-const.c", "status": "modified", "additions": 59, "deletions": 129, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "patch": "@@ -1351,49 +1351,27 @@ const_binop (enum tree_code code, tree arg1, tree arg2)\n \treturn build_complex (type, real, imag);\n     }\n \n-  if (TREE_CODE (arg1) == VECTOR_CST)\n+  if (TREE_CODE (arg1) == VECTOR_CST\n+      && TREE_CODE (arg2) == VECTOR_CST)\n     {\n       tree type = TREE_TYPE(arg1);\n       int count = TYPE_VECTOR_SUBPARTS (type), i;\n-      tree elements1, elements2, list = NULL_TREE;\n-\n-      if(TREE_CODE(arg2) != VECTOR_CST)\n-        return NULL_TREE;\n-\n-      elements1 = TREE_VECTOR_CST_ELTS (arg1);\n-      elements2 = TREE_VECTOR_CST_ELTS (arg2);\n+      tree *elts =  XALLOCAVEC (tree, count);\n \n       for (i = 0; i < count; i++)\n \t{\n-          tree elem1, elem2, elem;\n+          tree elem1 = VECTOR_CST_ELT (arg1, i);\n+\t  tree elem2 = VECTOR_CST_ELT (arg2, i);\n \n-          /* The trailing elements can be empty and should be treated as 0 */\n-          if(!elements1)\n-            elem1 = fold_convert_const (NOP_EXPR, TREE_TYPE (type), integer_zero_node);\n-          else\n-            {\n-              elem1 = TREE_VALUE(elements1);\n-              elements1 = TREE_CHAIN (elements1);\n-            }\n-\n-          if(!elements2)\n-            elem2 = fold_convert_const (NOP_EXPR, TREE_TYPE (type), integer_zero_node);\n-          else\n-            {\n-              elem2 = TREE_VALUE(elements2);\n-              elements2 = TREE_CHAIN (elements2);\n-            }\n-\n-          elem = const_binop (code, elem1, elem2);\n+          elts[i] = const_binop (code, elem1, elem2);\n \n           /* It is possible that const_binop cannot handle the given\n             code and return NULL_TREE */\n-          if(elem == NULL_TREE)\n+          if(elts[i] == NULL_TREE)\n             return NULL_TREE;\n-\n-          list = tree_cons (NULL_TREE, elem, list);\n \t}\n-      return build_vector(type, nreverse(list));\n+\n+      return build_vector (type, elts);\n     }\n   return NULL_TREE;\n }\n@@ -2491,20 +2469,18 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \n       case VECTOR_CST:\n \t{\n-\t  tree v1, v2;\n+\t  unsigned i;\n \n-\t  v1 = TREE_VECTOR_CST_ELTS (arg0);\n-\t  v2 = TREE_VECTOR_CST_ELTS (arg1);\n-\t  while (v1 && v2)\n+\t  if (VECTOR_CST_NELTS (arg0) != VECTOR_CST_NELTS (arg1))\n+\t    return 0;\n+\n+\t  for (i = 0; i < VECTOR_CST_NELTS (arg0); ++i)\n \t    {\n-\t      if (!operand_equal_p (TREE_VALUE (v1), TREE_VALUE (v2),\n-\t\t\t\t    flags))\n+\t      if (!operand_equal_p (VECTOR_CST_ELT (arg0, i),\n+\t\t\t\t    VECTOR_CST_ELT (arg1, i), flags))\n \t\treturn 0;\n-\t      v1 = TREE_CHAIN (v1);\n-\t      v2 = TREE_CHAIN (v2);\n \t    }\n-\n-\t  return v1 == v2;\n+\t  return 1;\n \t}\n \n       case COMPLEX_CST:\n@@ -7307,35 +7283,19 @@ native_encode_complex (const_tree expr, unsigned char *ptr, int len)\n static int\n native_encode_vector (const_tree expr, unsigned char *ptr, int len)\n {\n-  int i, size, offset, count;\n-  tree itype, elem, elements;\n+  unsigned i, count;\n+  int size, offset;\n+  tree itype, elem;\n \n   offset = 0;\n-  elements = TREE_VECTOR_CST_ELTS (expr);\n-  count = TYPE_VECTOR_SUBPARTS (TREE_TYPE (expr));\n+  count = VECTOR_CST_NELTS (expr);\n   itype = TREE_TYPE (TREE_TYPE (expr));\n   size = GET_MODE_SIZE (TYPE_MODE (itype));\n   for (i = 0; i < count; i++)\n     {\n-      if (elements)\n-\t{\n-\t  elem = TREE_VALUE (elements);\n-\t  elements = TREE_CHAIN (elements);\n-\t}\n-      else\n-\telem = NULL_TREE;\n-\n-      if (elem)\n-\t{\n-\t  if (native_encode_expr (elem, ptr+offset, len-offset) != size)\n-\t    return 0;\n-\t}\n-      else\n-\t{\n-\t  if (offset + size > len)\n-\t    return 0;\n-\t  memset (ptr+offset, 0, size);\n-\t}\n+      elem = VECTOR_CST_ELT (expr, i);\n+      if (native_encode_expr (elem, ptr+offset, len-offset) != size)\n+\treturn 0;\n       offset += size;\n     }\n   return offset;\n@@ -7534,22 +7494,23 @@ native_interpret_complex (tree type, const unsigned char *ptr, int len)\n static tree\n native_interpret_vector (tree type, const unsigned char *ptr, int len)\n {\n-  tree etype, elem, elements;\n+  tree etype, elem;\n   int i, size, count;\n+  tree *elements;\n \n   etype = TREE_TYPE (type);\n   size = GET_MODE_SIZE (TYPE_MODE (etype));\n   count = TYPE_VECTOR_SUBPARTS (type);\n   if (size * count > len)\n     return NULL_TREE;\n \n-  elements = NULL_TREE;\n+  elements = XALLOCAVEC (tree, count);\n   for (i = count - 1; i >= 0; i--)\n     {\n       elem = native_interpret_expr (etype, ptr+(i*size), size);\n       if (!elem)\n \treturn NULL_TREE;\n-      elements = tree_cons (NULL_TREE, elem, elements);\n+      elements[i] = elem;\n     }\n   return build_vector (type, elements);\n }\n@@ -8169,25 +8130,21 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n       /* Perform BIT_NOT_EXPR on each element individually.  */\n       else if (TREE_CODE (arg0) == VECTOR_CST)\n \t{\n-\t  tree elements = TREE_VECTOR_CST_ELTS (arg0), elem, list = NULL_TREE;\n-\t  int count = TYPE_VECTOR_SUBPARTS (type), i;\n+\t  tree *elements;\n+\t  tree elem;\n+\t  unsigned count = VECTOR_CST_NELTS (arg0), i;\n \n+\t  elements = XALLOCAVEC (tree, count);\n \t  for (i = 0; i < count; i++)\n \t    {\n-\t      if (elements)\n-\t\t{\n-\t\t  elem = TREE_VALUE (elements);\n-\t\t  elem = fold_unary_loc (loc, BIT_NOT_EXPR, TREE_TYPE (type), elem);\n-\t\t  if (elem == NULL_TREE)\n-\t\t    break;\n-\t\t  elements = TREE_CHAIN (elements);\n-\t\t}\n-\t      else\n-\t\telem = build_int_cst (TREE_TYPE (type), -1);\n-\t      list = tree_cons (NULL_TREE, elem, list);\n+\t      elem = VECTOR_CST_ELT (arg0, i);\n+\t      elem = fold_unary_loc (loc, BIT_NOT_EXPR, TREE_TYPE (type), elem);\n+\t      if (elem == NULL_TREE)\n+\t\tbreak;\n+\t      elements[i] = elem;\n \t    }\n \t  if (i == count)\n-\t    return build_vector (type, nreverse (list));\n+\t    return build_vector (type, elements);\n \t}\n \n       return NULL_TREE;\n@@ -8310,7 +8267,7 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n     case VEC_UNPACK_FLOAT_HI_EXPR:\n       {\n \tunsigned int nelts = TYPE_VECTOR_SUBPARTS (type), i;\n-\ttree *elts, vals = NULL_TREE;\n+\ttree *elts;\n \tenum tree_code subcode;\n \n \tgcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0)) == nelts * 2);\n@@ -8337,9 +8294,7 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n \t      return NULL_TREE;\n \t  }\n \n-\tfor (i = 0; i < nelts; i++)\n-\t  vals = tree_cons (NULL_TREE, elts[nelts - i - 1], vals);\n-\treturn build_vector (type, vals);\n+\treturn build_vector (type, elts);\n       }\n \n     default:\n@@ -9608,13 +9563,8 @@ vec_cst_ctor_to_array (tree arg, tree *elts)\n \n   if (TREE_CODE (arg) == VECTOR_CST)\n     {\n-      tree t;\n-\n-      for (i = 0, t = TREE_VECTOR_CST_ELTS (arg);\n-\t   i < nelts && t; i++, t = TREE_CHAIN (t))\n-\telts[i] = TREE_VALUE (t);\n-      if (t)\n-\treturn false;\n+      for (i = 0; i < VECTOR_CST_NELTS (arg); ++i)\n+\telts[i] = VECTOR_CST_ELT (arg, i);\n     }\n   else if (TREE_CODE (arg) == CONSTRUCTOR)\n     {\n@@ -9671,12 +9621,7 @@ fold_vec_perm (tree type, tree arg0, tree arg1, const unsigned char *sel)\n       return build_constructor (type, v);\n     }\n   else\n-    {\n-      tree vals = NULL_TREE;\n-      for (i = 0; i < nelts; i++)\n-\tvals = tree_cons (NULL_TREE, elts[3 * nelts - i - 1], vals);\n-      return build_vector (type, vals);\n-    }\n+    return build_vector (type, &elts[2 * nelts]);\n }\n \n /* Try to fold a pointer difference of type TYPE two address expressions of\n@@ -13574,7 +13519,7 @@ fold_binary_loc (location_t loc,\n     case VEC_PACK_FIX_TRUNC_EXPR:\n       {\n \tunsigned int nelts = TYPE_VECTOR_SUBPARTS (type), i;\n-\ttree *elts, vals = NULL_TREE;\n+\ttree *elts;\n \n \tgcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0)) == nelts / 2\n \t\t    && TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg1)) == nelts / 2);\n@@ -13595,16 +13540,14 @@ fold_binary_loc (location_t loc,\n \t      return NULL_TREE;\n \t  }\n \n-\tfor (i = 0; i < nelts; i++)\n-\t  vals = tree_cons (NULL_TREE, elts[nelts - i - 1], vals);\n-\treturn build_vector (type, vals);\n+\treturn build_vector (type, elts);\n       }\n \n     case VEC_WIDEN_MULT_LO_EXPR:\n     case VEC_WIDEN_MULT_HI_EXPR:\n       {\n \tunsigned int nelts = TYPE_VECTOR_SUBPARTS (type), i;\n-\ttree *elts, vals = NULL_TREE;\n+\ttree *elts;\n \n \tgcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0)) == nelts * 2\n \t\t    && TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg1)) == nelts * 2);\n@@ -13632,9 +13575,7 @@ fold_binary_loc (location_t loc,\n \t      return NULL_TREE;\n \t  }\n \n-\tfor (i = 0; i < nelts; i++)\n-\t  vals = tree_cons (NULL_TREE, elts[nelts - i - 1], vals);\n-\treturn build_vector (type, vals);\n+\treturn build_vector (type, elts);\n       }\n \n     default:\n@@ -13991,13 +13932,7 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t\t < TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0)))\n \t    {\n \t      if (TREE_CODE (arg0) == VECTOR_CST)\n-\t\t{\n-\t\t  tree elements = TREE_VECTOR_CST_ELTS (arg0);\n-\t\t  while (idx-- > 0 && elements)\n-\t\t    elements = TREE_CHAIN (elements);\n-\t\t  if (elements)\n-\t\t    return TREE_VALUE (elements);\n-\t\t}\n+\t\treturn VECTOR_CST_ELT (arg0, idx);\n \t      else if (idx < CONSTRUCTOR_NELTS (arg0))\n \t\treturn CONSTRUCTOR_ELT (arg0, idx)->value;\n \t      return build_zero_cst (type);\n@@ -14031,23 +13966,19 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t  tree t;\n \t  bool need_mask_canon = false;\n \n-\t  gcc_assert (nelts == TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg2)));\n-\t  for (i = 0, t = TREE_VECTOR_CST_ELTS (arg2);\n-\t       i < nelts && t; i++, t = TREE_CHAIN (t))\n+\t  gcc_assert (nelts == VECTOR_CST_NELTS (arg2));\n+\t  for (i = 0; i < nelts; i++)\n \t    {\n-\t      if (TREE_CODE (TREE_VALUE (t)) != INTEGER_CST)\n+\t      tree val = VECTOR_CST_ELT (arg2, i);\n+\t      if (TREE_CODE (val) != INTEGER_CST)\n \t\treturn NULL_TREE;\n \n-\t      sel[i] = TREE_INT_CST_LOW (TREE_VALUE (t)) & (2 * nelts - 1);\n-\t      if (TREE_INT_CST_HIGH (TREE_VALUE (t))\n+\t      sel[i] = TREE_INT_CST_LOW (val) & (2 * nelts - 1);\n+\t      if (TREE_INT_CST_HIGH (val)\n \t\t  || ((unsigned HOST_WIDE_INT)\n-\t\t      TREE_INT_CST_LOW (TREE_VALUE (t)) != sel[i]))\n+\t\t      TREE_INT_CST_LOW (val) != sel[i]))\n \t\tneed_mask_canon = true;\n \t    }\n-\t  if (t)\n-\t    return NULL_TREE;\n-\t  for (; i < nelts; i++)\n-\t    sel[i] = 0;\n \n \t  if ((TREE_CODE (arg0) == VECTOR_CST\n \t       || TREE_CODE (arg0) == CONSTRUCTOR)\n@@ -14061,12 +13992,11 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \n \t  if (need_mask_canon && arg2 == op2)\n \t    {\n-\t      tree list = NULL_TREE, eltype = TREE_TYPE (TREE_TYPE (arg2));\n+\t      tree *tsel = XALLOCAVEC (tree, nelts);\n+\t      tree eltype = TREE_TYPE (TREE_TYPE (arg2));\n \t      for (i = 0; i < nelts; i++)\n-\t\tlist = tree_cons (NULL_TREE,\n-\t\t\t\t  build_int_cst (eltype, sel[nelts - i - 1]),\n-\t\t\t\t  list);\n-\t      t = build_vector (TREE_TYPE (arg2), list);\n+\t\ttsel[i] = build_int_cst (eltype, sel[nelts - i - 1]);\n+\t      t = build_vector (TREE_TYPE (arg2), tsel);\n \t      return build3_loc (loc, VEC_PERM_EXPR, type, op0, op1, t);\n \t    }\n \t}"}, {"sha": "a1eba65e042f0ee2091bc0b55d0a8fbecc9a3e2a", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "patch": "@@ -2467,21 +2467,22 @@ gimple_fold_stmt_to_constant_1 (gimple stmt, tree (*valueize) (tree))\n \t\t\t   == TYPE_VECTOR_SUBPARTS (TREE_TYPE (rhs))))\n \t\t{\n \t\t  unsigned i;\n-\t\t  tree val, list;\n+\t\t  tree val, *vec;\n \n-\t\t  list = NULL_TREE;\n+\t\t  vec = XALLOCAVEC (tree,\n+\t\t\t\t    TYPE_VECTOR_SUBPARTS (TREE_TYPE (rhs)));\n \t\t  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (rhs), i, val)\n \t\t    {\n \t\t      val = (*valueize) (val);\n \t\t      if (TREE_CODE (val) == INTEGER_CST\n \t\t\t  || TREE_CODE (val) == REAL_CST\n \t\t\t  || TREE_CODE (val) == FIXED_CST)\n-\t\t\tlist = tree_cons (NULL_TREE, val, list);\n+\t\t\tvec[i] = val;\n \t\t      else\n \t\t\treturn NULL_TREE;\n \t\t    }\n \n-\t\t  return build_vector (TREE_TYPE (rhs), nreverse (list));\n+\t\t  return build_vector (TREE_TYPE (rhs), vec);\n \t\t}\n \n               if (kind == tcc_reference)"}, {"sha": "466b7db7469a8defdea83b734ee3d9cccca42058", "filename": "gcc/print-tree.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "patch": "@@ -821,16 +821,13 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \n \tcase VECTOR_CST:\n \t  {\n-\t    tree vals = TREE_VECTOR_CST_ELTS (node);\n \t    char buf[10];\n-\t    tree link;\n-\t    int i;\n+\t    unsigned i;\n \n-\t    i = 0;\n-\t    for (link = vals; link; link = TREE_CHAIN (link), ++i)\n+\t    for (i = 0; i < VECTOR_CST_NELTS (node); ++i)\n \t      {\n-\t\tsprintf (buf, \"elt%d: \", i);\n-\t\tprint_node (file, buf, TREE_VALUE (link), indent + 4);\n+\t\tsprintf (buf, \"elt%u: \", i);\n+\t\tprint_node (file, buf, VECTOR_CST_ELT (node, i), indent + 4);\n \t      }\n \t  }\n \t  break;"}, {"sha": "6e6a5f8ae9edeaf2203557bbdc24de023d012566", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "patch": "@@ -1112,13 +1112,14 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \n     case VECTOR_CST:\n       {\n-\ttree elt;\n+\tunsigned i;\n \tpp_string (buffer, \"{ \");\n-\tfor (elt = TREE_VECTOR_CST_ELTS (node); elt; elt = TREE_CHAIN (elt))\n+\tfor (i = 0; i < VECTOR_CST_NELTS (node); ++i)\n \t  {\n-\t    dump_generic_node (buffer, TREE_VALUE (elt), spc, flags, false);\n-\t    if (TREE_CHAIN (elt))\n+\t    if (i != 0)\n \t      pp_string (buffer, \", \");\n+\t    dump_generic_node (buffer, VECTOR_CST_ELT (node, i),\n+\t\t\t       spc, flags, false);\n \t  }\n \tpp_string (buffer, \" }\");\n       }"}, {"sha": "50ea77d1b1389ea25755af0b366cefbf86df938a", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "patch": "@@ -473,6 +473,14 @@ streamer_alloc_tree (struct lto_input_block *ib, struct data_in *data_in,\n       HOST_WIDE_INT len = streamer_read_hwi (ib);\n       result = make_tree_vec (len);\n     }\n+  else if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n+    {\n+      HOST_WIDE_INT len = streamer_read_hwi (ib);\n+      result = ggc_alloc_zone_cleared_tree_node_stat (&tree_zone,\n+\t\t\t\t\t\t      (len - 1) * sizeof (tree)\n+\t\t\t\t\t\t      + sizeof (struct tree_vector));\n+      TREE_SET_CODE (result, VECTOR_CST);\n+    }\n   else if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n     {\n       unsigned HOST_WIDE_INT len = streamer_read_uhwi (ib);\n@@ -525,7 +533,9 @@ static void\n lto_input_ts_vector_tree_pointers (struct lto_input_block *ib,\n \t\t\t\t   struct data_in *data_in, tree expr)\n {\n-  TREE_VECTOR_CST_ELTS (expr) = streamer_read_chain (ib, data_in);\n+  unsigned i;\n+  for (i = 0; i < VECTOR_CST_NELTS (expr); ++i)\n+    VECTOR_CST_ELT (expr, i) = stream_read_tree (ib, data_in);\n }\n \n "}, {"sha": "8fe7d7992c6998a0013c1d9dbd038c757e51a895", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "patch": "@@ -441,7 +441,11 @@ write_ts_common_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n static void\n write_ts_vector_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n {\n-  streamer_write_chain (ob, TREE_VECTOR_CST_ELTS (expr), ref_p);\n+  unsigned i;\n+  /* Note that the number of elements for EXPR has already been emitted\n+     in EXPR's header (see streamer_write_tree_header).  */\n+  for (i = 0; i < VECTOR_CST_NELTS (expr); ++i)\n+    stream_write_tree (ob, VECTOR_CST_ELT (expr, i), ref_p);\n }\n \n \n@@ -907,6 +911,8 @@ streamer_write_tree_header (struct output_block *ob, tree expr)\n     streamer_write_string_cst (ob, ob->main_stream, expr);\n   else if (CODE_CONTAINS_STRUCT (code, TS_IDENTIFIER))\n     write_identifier (ob, ob->main_stream, expr);\n+  else if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n+    streamer_write_hwi (ob, VECTOR_CST_NELTS (expr));\n   else if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n     streamer_write_hwi (ob, TREE_VEC_LENGTH (expr));\n   else if (CODE_CONTAINS_STRUCT (code, TS_BINFO))"}, {"sha": "203f62caec7c2e4939ae01ec3d394169cfb98be7", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "patch": "@@ -334,20 +334,17 @@ expand_vector_addition (gimple_stmt_iterator *gsi,\n static tree\n uniform_vector_p (tree vec)\n {\n-  tree first, t, els;\n+  tree first, t;\n   unsigned i;\n \n   if (vec == NULL_TREE)\n     return NULL_TREE;\n \n   if (TREE_CODE (vec) == VECTOR_CST)\n     {\n-      els = TREE_VECTOR_CST_ELTS (vec);\n-      first = TREE_VALUE (els);\n-      els = TREE_CHAIN (els);\n-\n-      for (t = els; t; t = TREE_CHAIN (t))\n-\tif (!operand_equal_p (first, TREE_VALUE (t), 0))\n+      first = VECTOR_CST_ELT (vec, 0);\n+      for (i = 1; i < VECTOR_CST_NELTS (vec); ++i)\n+\tif (!operand_equal_p (first, VECTOR_CST_ELT (vec, i), 0))\n \t  return NULL_TREE;\n \n       return first;\n@@ -556,14 +553,7 @@ vector_element (gimple_stmt_iterator *gsi, tree vect, tree idx, tree *ptmpvec)\n \t}\n \n       if (TREE_CODE (vect) == VECTOR_CST)\n-        {\n-\t  unsigned i;\n-\t  tree vals = TREE_VECTOR_CST_ELTS (vect);\n-\t  for (i = 0; vals; vals = TREE_CHAIN (vals), ++i)\n-\t    if (i == index)\n-\t       return TREE_VALUE (vals);\n-\t  return build_zero_cst (vect_elt_type);\n-        }\n+\treturn VECTOR_CST_ELT (vect, index);\n       else if (TREE_CODE (vect) == CONSTRUCTOR)\n         {\n           unsigned i;\n@@ -640,10 +630,10 @@ lower_vec_perm (gimple_stmt_iterator *gsi)\n   if (TREE_CODE (mask) == VECTOR_CST)\n     {\n       unsigned char *sel_int = XALLOCAVEC (unsigned char, elements);\n-      tree vals = TREE_VECTOR_CST_ELTS (mask);\n \n-      for (i = 0; i < elements; ++i, vals = TREE_CHAIN (vals))\n-\tsel_int[i] = TREE_INT_CST_LOW (TREE_VALUE (vals)) & (2 * elements - 1);\n+      for (i = 0; i < elements; ++i)\n+\tsel_int[i] = (TREE_INT_CST_LOW (VECTOR_CST_ELT (mask, i))\n+\t\t      & (2 * elements - 1));\n \n       if (can_vec_perm_p (TYPE_MODE (vect_type), false, sel_int))\n \treturn;"}, {"sha": "abba2b9dbcaccb89db0de15a233e282fc030ef9f", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "patch": "@@ -3305,7 +3305,7 @@ get_initial_def_for_reduction (gimple stmt, tree init_val,\n   enum tree_code code = gimple_assign_rhs_code (stmt);\n   tree def_for_init;\n   tree init_def;\n-  tree t = NULL_TREE;\n+  tree *elts;\n   int i;\n   bool nested_in_vect_loop = false;\n   tree init_value;\n@@ -3386,23 +3386,31 @@ get_initial_def_for_reduction (gimple stmt, tree init_val,\n           def_for_init = build_int_cst (scalar_type, int_init_val);\n \n         /* Create a vector of '0' or '1' except the first element.  */\n+\telts = XALLOCAVEC (tree, nunits);\n         for (i = nunits - 2; i >= 0; --i)\n-          t = tree_cons (NULL_TREE, def_for_init, t);\n+\t  elts[i + 1] = def_for_init;\n \n         /* Option1: the first element is '0' or '1' as well.  */\n         if (adjustment_def)\n           {\n-            t = tree_cons (NULL_TREE, def_for_init, t);\n-            init_def = build_vector (vectype, t);\n+\t    elts[0] = def_for_init;\n+            init_def = build_vector (vectype, elts);\n             break;\n           }\n \n         /* Option2: the first element is INIT_VAL.  */\n-        t = tree_cons (NULL_TREE, init_value, t);\n+\telts[0] = init_val;\n         if (TREE_CONSTANT (init_val))\n-          init_def = build_vector (vectype, t);\n+          init_def = build_vector (vectype, elts);\n         else\n-          init_def = build_constructor_from_list (vectype, t);\n+\t  {\n+\t    VEC(constructor_elt,gc) *v;\n+\t    v = VEC_alloc (constructor_elt, gc, nunits);\n+\t    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, init_val);\n+\t    for (i = 1; i < nunits; ++i)\n+\t      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, elts[i]);\n+\t    init_def = build_constructor (vectype, v);\n+\t  }\n \n         break;\n "}, {"sha": "dbfe78d9351ccfcddf146138c0104c84080fb34c", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "patch": "@@ -2205,15 +2205,15 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n   VEC (gimple, heap) *stmts = SLP_TREE_SCALAR_STMTS (slp_node);\n   gimple stmt = VEC_index (gimple, stmts, 0);\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n-  int nunits;\n+  unsigned nunits;\n   tree vec_cst;\n-  tree t = NULL_TREE;\n-  int j, number_of_places_left_in_vector;\n+  tree *elts;\n+  unsigned j, number_of_places_left_in_vector;\n   tree vector_type;\n   tree vop;\n   int group_size = VEC_length (gimple, stmts);\n   unsigned int vec_num, i;\n-  int number_of_copies = 1;\n+  unsigned number_of_copies = 1;\n   VEC (tree, heap) *voprnds = VEC_alloc (tree, heap, number_of_vectors);\n   bool constant_p, is_store;\n   tree neutral_op = NULL;\n@@ -2307,6 +2307,7 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n   number_of_copies = least_common_multiple (nunits, group_size) / group_size;\n \n   number_of_places_left_in_vector = nunits;\n+  elts = XALLOCAVEC (tree, nunits);\n   for (j = 0; j < number_of_copies; j++)\n     {\n       for (i = group_size - 1; VEC_iterate (gimple, stmts, i, stmt); i--)\n@@ -2361,31 +2362,37 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n             }\n \n           /* Create 'vect_ = {op0,op1,...,opn}'.  */\n-          t = tree_cons (NULL_TREE, op, t);\n-\n           number_of_places_left_in_vector--;\n+\t  elts[number_of_places_left_in_vector] = op;\n \n           if (number_of_places_left_in_vector == 0)\n             {\n               number_of_places_left_in_vector = nunits;\n \n \t      if (constant_p)\n-\t\tvec_cst = build_vector (vector_type, t);\n+\t\tvec_cst = build_vector (vector_type, elts);\n \t      else\n-\t\tvec_cst = build_constructor_from_list (vector_type, t);\n+\t\t{\n+\t\t  VEC(constructor_elt,gc) *v;\n+\t\t  unsigned k;\n+\t\t  v = VEC_alloc (constructor_elt, gc, nunits);\n+\t\t  for (k = 0; k < nunits; ++k)\n+\t\t    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, elts[k]);\n+\t\t  vec_cst = build_constructor (vector_type, v);\n+\t\t}\n               VEC_quick_push (tree, voprnds,\n-                              vect_init_vector (stmt, vec_cst, vector_type, NULL));\n-              t = NULL_TREE;\n+                              vect_init_vector (stmt, vec_cst,\n+\t\t\t\t\t\tvector_type, NULL));\n             }\n         }\n     }\n \n   /* Since the vectors are created in the reverse order, we should invert\n      them.  */\n   vec_num = VEC_length (tree, voprnds);\n-  for (j = vec_num - 1; j >= 0; j--)\n+  for (j = vec_num; j != 0; j--)\n     {\n-      vop = VEC_index (tree, voprnds, j);\n+      vop = VEC_index (tree, voprnds, j - 1);\n       VEC_quick_push (tree, *vec_oprnds, vop);\n     }\n \n@@ -2777,7 +2784,8 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n \n               if (index == nunits)\n                 {\n-\t\t  tree mask_vec = NULL;\n+\t\t  tree mask_vec, *mask_elts;\n+\t\t  int l;\n \n \t\t  if (!can_vec_perm_p (mode, false, mask))\n \t\t    {\n@@ -2791,12 +2799,10 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n \t\t      return false;\n \t\t    }\n \n-\t\t  while (--index >= 0)\n-\t\t    {\n-\t\t      tree t = build_int_cst (mask_element_type, mask[index]);\n-\t\t      mask_vec = tree_cons (NULL, t, mask_vec);\n-\t\t    }\n-\t\t  mask_vec = build_vector (mask_type, mask_vec);\n+\t\t  mask_elts = XALLOCAVEC (tree, nunits);\n+\t\t  for (l = 0; l < nunits; ++l)\n+\t\t    mask_elts[l] = build_int_cst (mask_element_type, mask[l]);\n+\t\t  mask_vec = build_vector (mask_type, mask_elts);\n \t\t  index = 0;\n \n                   if (!analyze_only)"}, {"sha": "13859aff0b2fbc22edbbf87428de45b9dbedc024", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "patch": "@@ -4091,7 +4091,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n tree\n vect_gen_perm_mask (tree vectype, unsigned char *sel)\n {\n-  tree mask_elt_type, mask_type, mask_vec;\n+  tree mask_elt_type, mask_type, mask_vec, *mask_elts;\n   int i, nunits;\n \n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n@@ -4103,11 +4103,10 @@ vect_gen_perm_mask (tree vectype, unsigned char *sel)\n \t\t    (int_mode_for_mode (TYPE_MODE (TREE_TYPE (vectype))), 1);\n   mask_type = get_vectype_for_scalar_type (mask_elt_type);\n \n-  mask_vec = NULL;\n+  mask_elts = XALLOCAVEC (tree, nunits);\n   for (i = nunits - 1; i >= 0; i--)\n-    mask_vec = tree_cons (NULL, build_int_cst (mask_elt_type, sel[i]),\n-\t\t\t  mask_vec);\n-  mask_vec = build_vector (mask_type, mask_vec);\n+    mask_elts[i] = build_int_cst (mask_elt_type, sel[i]);\n+  mask_vec = build_vector (mask_type, mask_elts);\n \n   return mask_vec;\n }"}, {"sha": "1734fc5ed0ae3f3602b2c477334358c06dab9bc2", "filename": "gcc/tree.c", "status": "modified", "additions": 41, "deletions": 28, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "patch": "@@ -1315,21 +1315,28 @@ cst_and_fits_in_hwi (const_tree x)\n    are in a list pointed to by VALS.  */\n \n tree\n-build_vector (tree type, tree vals)\n+build_vector_stat (tree type, tree *vals MEM_STAT_DECL)\n {\n-  tree v = make_node (VECTOR_CST);\n   int over = 0;\n-  tree link;\n   unsigned cnt = 0;\n+  tree v;\n+  int length = ((TYPE_VECTOR_SUBPARTS (type) - 1) * sizeof (tree)\n+\t\t+ sizeof (struct tree_vector));\n+\n+  record_node_allocation_statistics (VECTOR_CST, length);\n+\n+  v = ggc_alloc_zone_cleared_tree_node_stat (&tree_zone, length PASS_MEM_STAT);\n \n-  TREE_VECTOR_CST_ELTS (v) = vals;\n+  TREE_SET_CODE (v, VECTOR_CST);\n+  TREE_CONSTANT (v) = 1;\n   TREE_TYPE (v) = type;\n \n   /* Iterate through elements and check for overflow.  */\n-  for (link = vals; link; link = TREE_CHAIN (link))\n+  for (cnt = 0; cnt < TYPE_VECTOR_SUBPARTS (type); ++cnt)\n     {\n-      tree value = TREE_VALUE (link);\n-      cnt++;\n+      tree value = vals[cnt];\n+\n+      VECTOR_CST_ELT (v, cnt) = value;\n \n       /* Don't crash if we get an address constant.  */\n       if (!CONSTANT_CLASS_P (value))\n@@ -1338,8 +1345,6 @@ build_vector (tree type, tree vals)\n       over |= TREE_OVERFLOW (value);\n     }\n \n-  gcc_assert (cnt == TYPE_VECTOR_SUBPARTS (type));\n-\n   TREE_OVERFLOW (v) = over;\n   return v;\n }\n@@ -1350,16 +1355,16 @@ build_vector (tree type, tree vals)\n tree\n build_vector_from_ctor (tree type, VEC(constructor_elt,gc) *v)\n {\n-  tree list = NULL_TREE;\n+  tree *vec = XALLOCAVEC (tree, TYPE_VECTOR_SUBPARTS (type));\n   unsigned HOST_WIDE_INT idx;\n   tree value;\n \n   FOR_EACH_CONSTRUCTOR_VALUE (v, idx, value)\n-    list = tree_cons (NULL_TREE, value, list);\n+    vec[idx] = value;\n   for (; idx < TYPE_VECTOR_SUBPARTS (type); ++idx)\n-    list = tree_cons (NULL_TREE,\n-\t\t      build_zero_cst (TREE_TYPE (type)), list);\n-  return build_vector (type, nreverse (list));\n+    vec[idx] = build_zero_cst (TREE_TYPE (type));\n+\n+  return build_vector (type, vec);\n }\n \n /* Build a vector of type VECTYPE where all the elements are SCs.  */\n@@ -1724,9 +1729,9 @@ integer_zerop (const_tree expr)\n \t      && integer_zerop (TREE_IMAGPART (expr)));\n     case VECTOR_CST:\n       {\n-\ttree elt;\n-\tfor (elt = TREE_VECTOR_CST_ELTS (expr); elt; elt = TREE_CHAIN (elt))\n-\t  if (!integer_zerop (TREE_VALUE (elt)))\n+\tunsigned i;\n+\tfor (i = 0; i < VECTOR_CST_NELTS (expr); ++i)\n+\t  if (!integer_zerop (VECTOR_CST_ELT (expr, i)))\n \t    return false;\n \treturn true;\n       }\n@@ -1753,9 +1758,9 @@ integer_onep (const_tree expr)\n \t      && integer_zerop (TREE_IMAGPART (expr)));\n     case VECTOR_CST:\n       {\n-\ttree elt;\n-\tfor (elt = TREE_VECTOR_CST_ELTS (expr); elt; elt = TREE_CHAIN (elt))\n-\t  if (!integer_onep (TREE_VALUE (elt)))\n+\tunsigned i;\n+\tfor (i = 0; i < VECTOR_CST_NELTS (expr); ++i)\n+\t  if (!integer_onep (VECTOR_CST_ELT (expr, i)))\n \t    return false;\n \treturn true;\n       }\n@@ -1782,9 +1787,9 @@ integer_all_onesp (const_tree expr)\n \n   else if (TREE_CODE (expr) == VECTOR_CST)\n     {\n-      tree elt;\n-      for (elt = TREE_VECTOR_CST_ELTS (expr); elt; elt = TREE_CHAIN (elt))\n-\tif (!integer_all_onesp (TREE_VALUE (elt)))\n+      unsigned i;\n+      for (i = 0; i < VECTOR_CST_NELTS (expr); ++i)\n+\tif (!integer_all_onesp (VECTOR_CST_ELT (expr, i)))\n \t  return 0;\n       return 1;\n     }\n@@ -6944,7 +6949,12 @@ iterative_hash_expr (const_tree t, hashval_t val)\n       val = iterative_hash_expr (TREE_REALPART (t), val);\n       return iterative_hash_expr (TREE_IMAGPART (t), val);\n     case VECTOR_CST:\n-      return iterative_hash_expr (TREE_VECTOR_CST_ELTS (t), val);\n+      {\n+\tunsigned i;\n+\tfor (i = 0; i < VECTOR_CST_NELTS (t); ++i)\n+\t  val = iterative_hash_expr (VECTOR_CST_ELT (t, i), val);\n+\treturn val;\n+      }\n     case SSA_NAME:\n       /* We can just compare by pointer.  */\n       return iterative_hash_host_wide_int (SSA_NAME_VERSION (t), val);\n@@ -9889,10 +9899,13 @@ initializer_zerop (const_tree init)\n \t    && ! REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (TREE_IMAGPART (init))));\n \n     case VECTOR_CST:\n-      for (elt = TREE_VECTOR_CST_ELTS (init); elt; elt = TREE_CHAIN (elt))\n-\tif (!initializer_zerop (TREE_VALUE (elt)))\n-\t  return false;\n-      return true;\n+      {\n+\tunsigned i;\n+\tfor (i = 0; i < VECTOR_CST_NELTS (init); ++i)\n+\t  if (!initializer_zerop (VECTOR_CST_ELT (init, i)))\n+\t    return false;\n+\treturn true;\n+      }\n \n     case CONSTRUCTOR:\n       {"}, {"sha": "c0340aafd39f979fb9ded70a54cf98b8921a23f4", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "patch": "@@ -1534,11 +1534,13 @@ struct GTY(()) tree_complex {\n };\n \n /* In a VECTOR_CST node.  */\n-#define TREE_VECTOR_CST_ELTS(NODE) (VECTOR_CST_CHECK (NODE)->vector.elements)\n+#define VECTOR_CST_NELTS(NODE) (TYPE_VECTOR_SUBPARTS (TREE_TYPE (NODE)))\n+#define VECTOR_CST_ELTS(NODE) (VECTOR_CST_CHECK (NODE)->vector.elts)\n+#define VECTOR_CST_ELT(NODE,IDX) (VECTOR_CST_CHECK (NODE)->vector.elts[IDX])\n \n struct GTY(()) tree_vector {\n   struct tree_typed typed;\n-  tree elements;\n+  tree GTY ((length (\"TYPE_VECTOR_SUBPARTS (TREE_TYPE ((tree)&%h))\"))) elts[1];\n };\n \f\n #include \"symtab.h\"\n@@ -4337,7 +4339,8 @@ build_int_cstu (tree type, unsigned HOST_WIDE_INT cst)\n extern tree build_int_cst (tree, HOST_WIDE_INT);\n extern tree build_int_cst_type (tree, HOST_WIDE_INT);\n extern tree build_int_cst_wide (tree, unsigned HOST_WIDE_INT, HOST_WIDE_INT);\n-extern tree build_vector (tree, tree);\n+extern tree build_vector_stat (tree, tree * MEM_STAT_DECL);\n+#define build_vector(t,v) build_vector_stat (t, v MEM_STAT_INFO)\n extern tree build_vector_from_ctor (tree, VEC(constructor_elt,gc) *);\n extern tree build_vector_from_val (tree, tree);\n extern tree build_constructor (tree, VEC(constructor_elt,gc) *);"}, {"sha": "9bead9b10f22b7e4ff8cf05a24a62b92f4220b0e", "filename": "gcc/varasm.c", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a12ae77fa3efbe2329f7126b4acc24c35ef401/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=d2a12ae77fa3efbe2329f7126b4acc24c35ef401", "patch": "@@ -2706,12 +2706,12 @@ const_hash_1 (const tree exp)\n \n     case VECTOR_CST:\n       {\n-\ttree link;\n+\tunsigned i;\n \n-\thi = 7 + TYPE_VECTOR_SUBPARTS (TREE_TYPE (exp));\n+\thi = 7 + VECTOR_CST_NELTS (exp);\n \n-\tfor (link = TREE_VECTOR_CST_ELTS (exp); link; link = TREE_CHAIN (link))\n-\t    hi = hi * 563 + const_hash_1 (TREE_VALUE (link));\n+\tfor (i = 0; i < VECTOR_CST_NELTS (exp); ++i)\n+\t  hi = hi * 563 + const_hash_1 (VECTOR_CST_ELT (exp, i));\n \n \treturn hi;\n       }\n@@ -2846,21 +2846,15 @@ compare_constant (const tree t1, const tree t2)\n \n     case VECTOR_CST:\n       {\n-        tree link1, link2;\n+\tunsigned i;\n \n-        if (TYPE_VECTOR_SUBPARTS (TREE_TYPE (t1))\n-\t    != TYPE_VECTOR_SUBPARTS (TREE_TYPE (t2)))\n+        if (VECTOR_CST_NELTS (t1) != VECTOR_CST_NELTS (t2))\n \t  return 0;\n \n-\tlink2 = TREE_VECTOR_CST_ELTS (t2);\n-\tfor (link1 = TREE_VECTOR_CST_ELTS (t1);\n-\t     link1;\n-\t     link1 = TREE_CHAIN (link1))\n-\t  {\n-\t    if (!compare_constant (TREE_VALUE (link1), TREE_VALUE (link2)))\n-\t      return 0;\n-\t    link2 = TREE_CHAIN (link2);\n-\t  }\n+\tfor (i = 0; i < VECTOR_CST_NELTS (t1); ++i)\n+\t  if (!compare_constant (VECTOR_CST_ELT (t1, i),\n+\t\t\t\t VECTOR_CST_ELT (t2, i)))\n+\t    return 0;\n \n \treturn 1;\n       }\n@@ -3014,8 +3008,7 @@ copy_constant (tree exp)\n \t\t     copy_constant (TREE_OPERAND (exp, 0)));\n \n     case VECTOR_CST:\n-      return build_vector (TREE_TYPE (exp),\n-\t\t\t   copy_list (TREE_VECTOR_CST_ELTS (exp)));\n+      return build_vector (TREE_TYPE (exp), VECTOR_CST_ELTS (exp));\n \n     case CONSTRUCTOR:\n       {\n@@ -4595,21 +4588,19 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n \tcase VECTOR_CST:\n \t  {\n \t    int elt_size;\n-\t    tree link;\n-\t    unsigned int nalign;\n+\t    unsigned int i, nalign;\n \t    enum machine_mode inner;\n \n \t    inner = TYPE_MODE (TREE_TYPE (TREE_TYPE (exp)));\n \t    nalign = MIN (align, GET_MODE_ALIGNMENT (inner));\n \n \t    elt_size = GET_MODE_SIZE (inner);\n \n-\t    link = TREE_VECTOR_CST_ELTS (exp);\n-\t    output_constant (TREE_VALUE (link), elt_size, align);\n+\t    output_constant (VECTOR_CST_ELT (exp, 0), elt_size, align);\n \t    thissize = elt_size;\n-\t    while ((link = TREE_CHAIN (link)) != NULL)\n+\t    for (i = 1; i < VECTOR_CST_NELTS (exp); ++i)\n \t      {\n-\t\toutput_constant (TREE_VALUE (link), elt_size, nalign);\n+\t\toutput_constant (VECTOR_CST_ELT (exp, i), elt_size, nalign);\n \t\tthissize += elt_size;\n \t      }\n \t    break;"}]}