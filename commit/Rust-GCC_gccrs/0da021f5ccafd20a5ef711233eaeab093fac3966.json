{"sha": "0da021f5ccafd20a5ef711233eaeab093fac3966", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRhMDIxZjVjY2FmZDIwYTVlZjcxMTIzM2VhZWFiMDkzZmFjMzk2Ng==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-08-18T14:36:07Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-08-18T14:36:07Z"}, "message": "re PR libgcj/11951 (natMethod.cc (_Jv_CallAnyMethodA) should clear ffi_result before ffi_call)\n\n\tPR libgcj/11951:\n\t* java/lang/reflect/natMethod.cc (_Jv_CallAnyMethodA): Returns\n\tvoid.  Throw VirtualMachineError if ffi fails.  Initialize return\n\tvalue.  Added is_jni_call argument; only wrap exception if not a\n\tJNI call.  Use descriptive message if operation not supported.\n\t(_Jv_GetTypesFromSignature): Use declaring class' loader to find\n\tarray class.\n\t* include/jvm.h (_Jv_CallAnyMethodA): Updated declaration.\n\t* jni.cc (_Jv_JNI_CallAnyMethodV): Updated for new form of\n\t_Jv_CallAnyMethodA.\n\t(_Jv_JNI_CallAnyMethodA): Likewise.\n\t(_Jv_JNI_CallAnyVoidMethodV): Likewise.\n\t(_Jv_JNI_CallAnyVoidMethodA): Likewise.\n\nFrom-SVN: r70544", "tree": {"sha": "3937ccad6c17e653dc39511f8dcb2812663db7de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3937ccad6c17e653dc39511f8dcb2812663db7de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0da021f5ccafd20a5ef711233eaeab093fac3966", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0da021f5ccafd20a5ef711233eaeab093fac3966", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0da021f5ccafd20a5ef711233eaeab093fac3966", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0da021f5ccafd20a5ef711233eaeab093fac3966/comments", "author": null, "committer": null, "parents": [{"sha": "cd0698363989ea9ad0c5546a79820da9e404b170", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd0698363989ea9ad0c5546a79820da9e404b170", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd0698363989ea9ad0c5546a79820da9e404b170"}], "stats": {"total": 146, "additions": 86, "deletions": 60}, "files": [{"sha": "5da7125345f26fb5baee87ebabd68654f4547451", "filename": "libjava/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da021f5ccafd20a5ef711233eaeab093fac3966/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da021f5ccafd20a5ef711233eaeab093fac3966/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=0da021f5ccafd20a5ef711233eaeab093fac3966", "patch": "@@ -1,3 +1,19 @@\n+2003-08-18  Tom Tromey  <tromey@redhat.com>\n+\n+\tPR libgcj/11951:\n+\t* java/lang/reflect/natMethod.cc (_Jv_CallAnyMethodA): Returns\n+\tvoid.  Throw VirtualMachineError if ffi fails.  Initialize return\n+\tvalue.  Added is_jni_call argument; only wrap exception if not a\n+\tJNI call.  Use descriptive message if operation not supported.\n+\t(_Jv_GetTypesFromSignature): Use declaring class' loader to find\n+\tarray class.\n+\t* include/jvm.h (_Jv_CallAnyMethodA): Updated declaration.\n+\t* jni.cc (_Jv_JNI_CallAnyMethodV): Updated for new form of\n+\t_Jv_CallAnyMethodA.\n+\t(_Jv_JNI_CallAnyMethodA): Likewise.\n+\t(_Jv_JNI_CallAnyVoidMethodV): Likewise.\n+\t(_Jv_JNI_CallAnyVoidMethodA): Likewise.\n+\n 2003-08-13  Tom Tromey  <tromey@redhat.com>\n \n \t* gij.cc (help): Document -? and -X."}, {"sha": "941b24e0e9064720a8594fc1130328627ad1a7ee", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da021f5ccafd20a5ef711233eaeab093fac3966/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da021f5ccafd20a5ef711233eaeab093fac3966/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=0da021f5ccafd20a5ef711233eaeab093fac3966", "patch": "@@ -335,13 +335,14 @@ extern jobject _Jv_CallAnyMethodA (jobject obj, jclass return_type,\n \t\t\t\t   jobjectArray args);\n \n union jvalue;\n-extern jthrowable _Jv_CallAnyMethodA (jobject obj,\n-\t\t\t\t      jclass return_type,\n-\t\t\t\t      jmethodID meth,\n-\t\t\t\t      jboolean is_constructor,\n-\t\t\t\t      JArray<jclass> *parameter_types,\n-\t\t\t\t      jvalue *args,\n-\t\t\t\t      jvalue *result);\n+extern void _Jv_CallAnyMethodA (jobject obj,\n+\t\t\t\tjclass return_type,\n+\t\t\t\tjmethodID meth,\n+\t\t\t\tjboolean is_constructor,\n+\t\t\t\tJArray<jclass> *parameter_types,\n+\t\t\t\tjvalue *args,\n+\t\t\t\tjvalue *result,\n+\t\t\t\tjboolean is_jni_call = true);\n \n extern jobject _Jv_NewMultiArray (jclass, jint ndims, jint* dims)\n   __attribute__((__malloc__));"}, {"sha": "6330c4b4675b40adb826dfae07890ab976bf6232", "filename": "libjava/java/lang/reflect/natMethod.cc", "status": "modified", "additions": 50, "deletions": 29, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da021f5ccafd20a5ef711233eaeab093fac3966/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da021f5ccafd20a5ef711233eaeab093fac3966/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc?ref=0da021f5ccafd20a5ef711233eaeab093fac3966", "patch": "@@ -31,6 +31,7 @@ details.  */\n #include <java/lang/IllegalArgumentException.h>\n #include <java/lang/NullPointerException.h>\n #include <java/lang/ArrayIndexOutOfBoundsException.h>\n+#include <java/lang/VirtualMachineError.h>\n #include <java/lang/Class.h>\n #include <gcj/method.h>\n #include <gnu/gcj/RawData.h>\n@@ -309,9 +310,8 @@ _Jv_GetTypesFromSignature (jmethodID method,\n \t  break;\n \t}\n \n-      // FIXME: 2'nd argument should be \"current loader\"\n       while (--num_arrays >= 0)\n-\ttype = _Jv_GetArrayClass (type, 0);\n+\ttype = _Jv_GetArrayClass (type, loader);\n       // ARGPTR can be NULL if we are processing the return value of a\n       // call from Constructor.\n       if (argPtr)\n@@ -328,14 +328,15 @@ _Jv_GetTypesFromSignature (jmethodID method,\n // to a `jvalue' (see jni.h); for a void method this should be NULL.\n // This function returns an exception (if one was thrown), or NULL if\n // the call went ok.\n-jthrowable\n+void\n _Jv_CallAnyMethodA (jobject obj,\n \t\t    jclass return_type,\n \t\t    jmethodID meth,\n \t\t    jboolean is_constructor,\n \t\t    JArray<jclass> *parameter_types,\n \t\t    jvalue *args,\n-\t\t    jvalue *result)\n+\t\t    jvalue *result,\n+\t\t    jboolean is_jni_call)\n {\n #ifdef USE_LIBFFI\n   JvAssert (! is_constructor || ! obj);\n@@ -409,15 +410,11 @@ _Jv_CallAnyMethodA (jobject obj,\n \n   if (ffi_prep_cif (&cif, FFI_DEFAULT_ABI, param_count,\n \t\t    rtype, argtypes) != FFI_OK)\n-    {\n-      // FIXME: throw some kind of VirtualMachineError here.\n-    }\n+    throw new java::lang::VirtualMachineError(JvNewStringLatin1(\"internal error: ffi_prep_cif failed\"));\n \n   using namespace java::lang;\n   using namespace java::lang::reflect;\n \n-  Throwable *ex = NULL;\n-\n   union\n   {\n     ffi_arg i;\n@@ -427,17 +424,51 @@ _Jv_CallAnyMethodA (jobject obj,\n     jdouble d;\n   } ffi_result;\n \n+  switch (rtype->type)\n+    {\n+    case FFI_TYPE_VOID:\n+      break;\n+    case FFI_TYPE_SINT8:\n+      result->b = 0;\n+      break;\n+    case FFI_TYPE_SINT16:\n+      result->s = 0;\n+      break;\n+    case FFI_TYPE_UINT16:\n+      result->c = 0;\n+      break;\n+    case FFI_TYPE_SINT32:\n+      result->i = 0;\n+      break;\n+    case FFI_TYPE_SINT64:\n+      result->j = 0;\n+      break;\n+    case FFI_TYPE_FLOAT:\n+      result->f = 0;\n+      break;\n+    case FFI_TYPE_DOUBLE:\n+      result->d = 0;\n+      break;\n+    case FFI_TYPE_POINTER:\n+      result->l = 0;\n+      break;\n+    default:\n+      JvFail (\"Unknown ffi_call return type\");\n+      break;\n+    }\n+\n   try\n     {\n       ffi_call (&cif, (void (*)()) meth->ncode, &ffi_result, values);\n     }\n-  catch (Throwable *ex2)\n+  catch (Throwable *ex)\n     {\n-      // FIXME: this is wrong for JNI.  But if we just return the\n-      // exception, then the non-JNI cases won't be able to\n-      // distinguish it from exceptions we might generate ourselves.\n-      // Sigh.\n-      ex = new InvocationTargetException (ex2);\n+      // For JNI we just throw the real error.  For reflection, we\n+      // wrap the underlying method's exception in an\n+      // InvocationTargetException.\n+      if (! is_jni_call)\n+\tex = new InvocationTargetException (ex);\n+      throw ex;\n     }\n \n   // Since ffi_call returns integer values promoted to a word, use\n@@ -481,11 +512,8 @@ _Jv_CallAnyMethodA (jobject obj,\n \t  break;\n \t}\n     }\n-\n-  return ex;\n #else\n-  throw new java::lang::UnsupportedOperationException;\n-  return 0;\n+  throw new java::lang::UnsupportedOperationException(JvNewStringLatin1(\"reflection not available in this build\"));\n #endif // USE_LIBFFI\n }\n \n@@ -562,16 +590,9 @@ _Jv_CallAnyMethodA (jobject obj,\n     }\n \n   jvalue ret_value;\n-  java::lang::Throwable *ex = _Jv_CallAnyMethodA (obj,\n-\t\t\t\t\t\t  return_type,\n-\t\t\t\t\t\t  meth,\n-\t\t\t\t\t\t  is_constructor,\n-\t\t\t\t\t\t  parameter_types,\n-\t\t\t\t\t\t  argvals,\n-\t\t\t\t\t\t  &ret_value);\n-\n-  if (ex)\n-    throw ex;\n+  _Jv_CallAnyMethodA (obj, return_type, meth, is_constructor,\n+\t\t      parameter_types, argvals, &ret_value,\n+\t\t      false);\n \n   jobject r;\n #define VAL(Wrapper, Field)  (new Wrapper (ret_value.Field))"}, {"sha": "47017dc8c18503f207ba7334c901e3cc860a4179", "filename": "libjava/jni.cc", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da021f5ccafd20a5ef711233eaeab093fac3966/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da021f5ccafd20a5ef711233eaeab093fac3966/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=0da021f5ccafd20a5ef711233eaeab093fac3966", "patch": "@@ -777,12 +777,9 @@ static T\n \treturn_type = klass;\n \n       jvalue result;\n-      jthrowable ex = _Jv_CallAnyMethodA (obj, return_type, id,\n-\t\t\t\t\t  style == constructor,\n-\t\t\t\t\t  arg_types, args, &result);\n-\n-      if (ex != NULL)\n-\tenv->ex = ex;\n+      _Jv_CallAnyMethodA (obj, return_type, id,\n+\t\t\t  style == constructor,\n+\t\t\t  arg_types, args, &result);\n \n       // We cheat a little here.  FIXME.\n       return wrap_value (env, * (T *) &result);\n@@ -847,12 +844,9 @@ static T\n \t}\n \n       jvalue result;\n-      jthrowable ex = _Jv_CallAnyMethodA (obj, return_type, id,\n-\t\t\t\t\t  style == constructor,\n-\t\t\t\t\t  arg_types, arg_copy, &result);\n-\n-      if (ex != NULL)\n-\tenv->ex = ex;\n+      _Jv_CallAnyMethodA (obj, return_type, id,\n+\t\t\t  style == constructor,\n+\t\t\t  arg_types, arg_copy, &result);\n \n       // We cheat a little here.  FIXME.\n       return wrap_value (env, * (T *) &result);\n@@ -893,12 +887,9 @@ static void\n       if (style == constructor)\n \treturn_type = klass;\n \n-      jthrowable ex = _Jv_CallAnyMethodA (obj, return_type, id,\n-\t\t\t\t\t  style == constructor,\n-\t\t\t\t\t  arg_types, args, NULL);\n-\n-      if (ex != NULL)\n-\tenv->ex = ex;\n+      _Jv_CallAnyMethodA (obj, return_type, id,\n+\t\t\t  style == constructor,\n+\t\t\t  arg_types, args, NULL);\n     }\n   catch (jthrowable t)\n     {\n@@ -947,12 +938,9 @@ static void\n \t    arg_copy[i].l = unwrap (args[i].l);\n \t}\n \n-      jthrowable ex = _Jv_CallAnyMethodA (obj, return_type, id,\n-\t\t\t\t\t  style == constructor,\n-\t\t\t\t\t  arg_types, args, NULL);\n-\n-      if (ex != NULL)\n-\tenv->ex = ex;\n+      _Jv_CallAnyMethodA (obj, return_type, id,\n+\t\t\t  style == constructor,\n+\t\t\t  arg_types, args, NULL);\n     }\n   catch (jthrowable t)\n     {"}]}