{"sha": "8cfb12bfd597944d043b187199d23b3fc8381612", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNmYjEyYmZkNTk3OTQ0ZDA0M2IxODcxOTlkMjNiM2ZjODM4MTYxMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-05-24T19:18:51Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-05-24T19:18:51Z"}, "message": "class.c (registered_class): Take it out of class_roots; turn into a vec of trees.\n\n        * class.c (registered_class): Take it out of class_roots; turn into\n        a vec of trees.\n        (register_class): Make static.  Don't duplicate decl node.  Use\n        VEC_safe_push.\n        (emit_register_classes): Use VEC_iterate.  Use output_constant\n        instead of assemble_integer.  Don't call mark_decl_referenced\n        directly.\n        * java-tree.h (register_class): Remove decl.\n\nFrom-SVN: r100107", "tree": {"sha": "e2dfe13a862ba281951e64c228ce5348ad6888c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2dfe13a862ba281951e64c228ce5348ad6888c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cfb12bfd597944d043b187199d23b3fc8381612", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cfb12bfd597944d043b187199d23b3fc8381612", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cfb12bfd597944d043b187199d23b3fc8381612", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cfb12bfd597944d043b187199d23b3fc8381612/comments", "author": null, "committer": null, "parents": [{"sha": "e777303ff4ac9b9f45830a433023c764d69bc433", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e777303ff4ac9b9f45830a433023c764d69bc433", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e777303ff4ac9b9f45830a433023c764d69bc433"}], "stats": {"total": 70, "additions": 39, "deletions": 31}, "files": [{"sha": "d713dcf0c8bb303585c595109954d1ec0644d37f", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cfb12bfd597944d043b187199d23b3fc8381612/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cfb12bfd597944d043b187199d23b3fc8381612/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=8cfb12bfd597944d043b187199d23b3fc8381612", "patch": "@@ -1,3 +1,14 @@\n+2005-05-24  Richard Henderson  <rth@redhat.com>\n+\n+\t* class.c (registered_class): Take it out of class_roots; turn into\n+\ta vec of trees.\n+\t(register_class): Make static.  Don't duplicate decl node.  Use\n+\tVEC_safe_push.\n+\t(emit_register_classes): Use VEC_iterate.  Use output_constant\n+\tinstead of assemble_integer.  Don't call mark_decl_referenced\n+\tdirectly.\n+\t* java-tree.h (register_class): Remove decl.\n+\n 2005-05-19  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR java/17845\n@@ -19,7 +30,7 @@\n \n 2005-05-12  Aaron Luchko <aluchko@redhat.com>\n \n-        * gcj.texi: Add '-verify', '-noverify', and '-verifyremote'.\n+\t* gcj.texi: Add '-verify', '-noverify', and '-verifyremote'.\n \n 2005-05-11  Tom Tromey  <tromey@redhat.com>\n "}, {"sha": "3c8a2e40fe1177690a38348763d1ba9152599898", "filename": "gcc/java/class.c", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cfb12bfd597944d043b187199d23b3fc8381612/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cfb12bfd597944d043b187199d23b3fc8381612/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=8cfb12bfd597944d043b187199d23b3fc8381612", "patch": "@@ -64,6 +64,7 @@ static void add_miranda_methods (tree, tree);\n static int assume_compiled (const char *);\n static tree build_symbol_entry (tree);\n static tree emit_assertion_table (tree);\n+static void register_class (void);\n \n struct obstack temporary_obstack;\n \n@@ -98,12 +99,13 @@ static class_flag_node *assume_compiled_tree;\n \n static class_flag_node *enable_assert_tree;\n \n-static GTY(()) tree class_roots[5];\n-#define registered_class class_roots[0]\n-#define fields_ident class_roots[1]  /* get_identifier (\"fields\") */\n-#define info_ident class_roots[2]  /* get_identifier (\"info\") */\n-#define class_list class_roots[3]\n-#define class_dtable_decl class_roots[4]\n+static GTY(()) tree class_roots[4];\n+#define fields_ident class_roots[0]  /* get_identifier (\"fields\") */\n+#define info_ident class_roots[1]  /* get_identifier (\"info\") */\n+#define class_list class_roots[2]\n+#define class_dtable_decl class_roots[3]\n+\n+static GTY(()) VEC(tree,gc) *registered_class;\n \n /* Return the node that most closely represents the class whose name\n    is IDENT.  Start the search from NODE (followed by its siblings).\n@@ -2407,23 +2409,16 @@ layout_class_method (tree this_class, tree super_class,\n   return dtable_count;\n }\n \n-void\n+static void\n register_class (void)\n {\n-  /* END does not need to be registered with the garbage collector\n-     because it always points into the list given by REGISTERED_CLASS,\n-     and that variable is registered with the collector.  */\n-  static tree end;\n-  tree node    = TREE_OPERAND (build_class_ref (current_class), 0);\n-  tree current = copy_node (node);\n+  tree node;\n \n-  XEXP (DECL_RTL (current), 0) = copy_rtx (XEXP (DECL_RTL(node), 0));\n   if (!registered_class)\n-    registered_class = current;\n-  else\n-    TREE_CHAIN (end) = current;\n+    registered_class = VEC_alloc (tree, gc, 8);\n \n-  end = current;\n+  node = TREE_OPERAND (build_class_ref (current_class), 0);\n+  VEC_safe_push (tree, gc, registered_class, node);\n }\n \n /* Emit something to register classes at start-up time.\n@@ -2448,33 +2443,36 @@ emit_register_classes (tree *list_p)\n      targets can overide the default in tm.h to use the fallback mechanism.  */\n   if (TARGET_USE_JCR_SECTION)\n     {\n+      tree klass, t;\n+      int i;\n+\n #ifdef JCR_SECTION_NAME\n-      tree t;\n       named_section_flags (JCR_SECTION_NAME, SECTION_WRITE);\n+#else\n+      /* A target has defined TARGET_USE_JCR_SECTION,\n+\t but doesn't have a JCR_SECTION_NAME.  */\n+      gcc_unreachable ();\n+#endif\n       assemble_align (POINTER_SIZE);\n-      for (t = registered_class; t; t = TREE_CHAIN (t))\n+\n+      for (i = 0; VEC_iterate (tree, registered_class, i, klass); ++i)\n \t{\n-\t  mark_decl_referenced (t);\n-\t  assemble_integer (XEXP (DECL_RTL (t), 0),\n-\t\t\t    POINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE, 1);\n+\t  t = build_fold_addr_expr (klass);\n+\t  output_constant (t, POINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE);\n \t}\n-#else\n-      /* A target has defined TARGET_USE_JCR_SECTION, but doesn't have a\n-\t JCR_SECTION_NAME.  */\n-      abort ();\n-#endif\n     }\n   else\n     {\n       tree klass, t, register_class_fn;\n+      int i;\n \n       t = build_function_type_list (void_type_node, class_ptr_type, NULL);\n       t = build_decl (FUNCTION_DECL, get_identifier (\"_Jv_RegisterClass\"), t);\n       TREE_PUBLIC (t) = 1;\n       DECL_EXTERNAL (t) = 1;\n       register_class_fn = t;\n \n-      for (klass = registered_class; klass; klass = TREE_CHAIN (klass))\n+      for (i = 0; VEC_iterate (tree, registered_class, i, klass); ++i)\n \t{\n \t  t = build_fold_addr_expr (klass);\n \t  t = tree_cons (NULL, t, NULL);"}, {"sha": "68eb1d6c55d4d0b66b57485851f0cb2a1fa3cd09", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cfb12bfd597944d043b187199d23b3fc8381612/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cfb12bfd597944d043b187199d23b3fc8381612/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=8cfb12bfd597944d043b187199d23b3fc8381612", "patch": "@@ -1286,7 +1286,6 @@ extern tree build_result_decl (tree);\n extern void set_method_index (tree decl, tree method_index);\n extern tree get_method_index (tree decl);\n extern void make_class_data (tree);\n-extern void register_class (void);\n extern int alloc_name_constant (int, tree);\n extern int alloc_constant_fieldref (tree, tree);\n extern void emit_register_classes (tree *);"}]}