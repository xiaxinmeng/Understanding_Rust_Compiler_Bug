{"sha": "4c975d0707d1b75874682820cfac1809d059f4f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM5NzVkMDcwN2QxYjc1ODc0NjgyODIwY2ZhYzE4MDlkMDU5ZjRmNQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-02T04:21:48Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-02T04:21:48Z"}, "message": "entered into RCS\n\nFrom-SVN: r3586", "tree": {"sha": "5dd7940514ae7832d6b04283525b29e3c274775a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5dd7940514ae7832d6b04283525b29e3c274775a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c975d0707d1b75874682820cfac1809d059f4f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c975d0707d1b75874682820cfac1809d059f4f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c975d0707d1b75874682820cfac1809d059f4f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c975d0707d1b75874682820cfac1809d059f4f5/comments", "author": null, "committer": null, "parents": [{"sha": "6bc4e3d04fe7c451bc0ded9f60ef70f96a732ebf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bc4e3d04fe7c451bc0ded9f60ef70f96a732ebf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bc4e3d04fe7c451bc0ded9f60ef70f96a732ebf"}], "stats": {"total": 54, "additions": 10, "deletions": 44}, "files": [{"sha": "04d4b7073ff79c7220f6a59e72d2963c42927295", "filename": "gcc/c-iterate.c", "status": "modified", "additions": 10, "deletions": 44, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c975d0707d1b75874682820cfac1809d059f4f5/gcc%2Fc-iterate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c975d0707d1b75874682820cfac1809d059f4f5/gcc%2Fc-iterate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-iterate.c?ref=4c975d0707d1b75874682820cfac1809d059f4f5", "patch": "@@ -128,44 +128,6 @@ iterator_for_loop_end (idecl)\n   ITERATOR_BOUND_P (idecl) = 0;\n }\n \f\n-/*\n-  \t\tITERATOR DECLS\n-\n-Iterators are  implemented  as integer decls  with a special  flag set\n-(rms's   idea).  This  makes  eliminates  the need   for  special type\n-checking.  The  flag  is accesed using   the  ITERATOR_P  macro.  Each\n-iterator's limit is saved as a  decl with a special  name. The decl is\n-initialized with the limit value -- this way we  get all the necessary\n-semantical processing for free by calling finish  decl. We might still\n-eliminate  that decl  later  -- it takes up  time and  space and, more\n-importantly, produces strange error  messages when  something is wrong\n-with the initializing expresison.  */\n-\n-tree\n-build_iterator_decl (id, limit)\n-    tree id, limit;\n-{\n-  tree type = integer_type_node, lim_decl;\n-  tree t1, t2, t3;\n-  tree start_node, limit_node, step_node;\n-  tree decl;\n-    \n-  if (limit)\n-    {\n-      limit_node = save_expr (limit);\n-      SAVE_EXPR_CONTEXT (limit_node) = current_function_decl;\n-    }\n-  else\n-    abort ();\n-  lim_decl = build_limit_decl (id, limit_node);\n-  push_obstacks_nochange ();\n-  decl = build_decl (VAR_DECL, id, type);\n-  ITERATOR_P (decl) = 1;\n-  ITERATOR_LIMIT (decl) = lim_decl;\n-  finish_decl (pushdecl (decl), 0, 0);\n-  return decl;\n-}\n-\f\n /*\n   \t\tITERATOR RTL EXPANSIONS\n \n@@ -247,21 +209,23 @@ collect_iterators (exp, list)\n       return list;\n \n     default:\n-      switch (TREE_CODE_CLASS (code))\n+      switch (TREE_CODE_CLASS (TREE_CODE (exp)))\n \t{\n \tcase '1':\n \tcase '2':\n \tcase '<':\n \tcase 'e':\n \tcase 'r':\n \t  {\n-\t    int num_args = tree_code_length[code];\n+\t    int num_args = tree_code_length[TREE_CODE (exp)];\n \t    int i;\n-\t    the_list = (tree) 0;\n+\n \t    for (i = 0; i < num_args; i++)\n \t      list = collect_iterators (TREE_OPERAND (exp, i), list);\n \t    return list;\n \t  }\n+\tdefault:\n+\t  return list;\n \t}\n     }\n }\n@@ -289,7 +253,8 @@ iterator_loop_prologue (idecl, start_note, end_note)\n   if (start_note)\n     *start_note = emit_note (0, NOTE_INSN_DELETED);\n   /* Initialize counter.  */\n-  expand_expr (build_modify_expr (idecl, NOP_EXPR, integer_zero_node),\n+  expand_expr (build (MODIFY_EXPR, TREE_TYPE (idecl),\n+\t\t      idecl, integer_zero_node),\n \t       0, VOIDmode, 0);\n \n   expand_start_loop_continue_elsewhere (1);\n@@ -329,7 +294,8 @@ iterator_loop_epilogue (idecl, start_note, end_note)\n     *start_note = emit_note (0, NOTE_INSN_DELETED);\n   expand_loop_continue_here ();\n   incr = build_binary_op (PLUS_EXPR, idecl, integer_one_node, 0);\n-  expand_expr (build_modify_expr (idecl, NOP_EXPR, incr));\n+  expand_expr (build (MODIFY_EXPR, TREE_TYPE (idecl), idecl, incr),\n+\t       0, VOIDmode, 0);\n   test = build_binary_op (LT_EXPR, idecl, DECL_INITIAL (idecl), 0);\n   expand_exit_loop_if_false (0, test);\n   expand_end_loop ();\n@@ -475,7 +441,7 @@ delete_ixpansion (idecl)\n \n \tif (ix->ixprologue_start == 0)\n \t  error_with_decl (idecl,\n-\t\t\t   \"`for (%s)' appears within implicit iteration\")\n+\t\t\t   \"`for (%s)' appears within implicit iteration\");\n \telse\n \t  {\n \t    rtx insn;"}]}