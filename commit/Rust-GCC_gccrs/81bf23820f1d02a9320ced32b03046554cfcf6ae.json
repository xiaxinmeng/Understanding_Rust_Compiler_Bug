{"sha": "81bf23820f1d02a9320ced32b03046554cfcf6ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFiZjIzODIwZjFkMDJhOTMyMGNlZDMyYjAzMDQ2NTU0Y2ZjZjZhZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-05T14:00:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-05T14:00:30Z"}, "message": "[multiple changes]\n\n2011-09-05  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch6.adb: Minor reformatting.\n\n2011-09-05  Matthew Gingell  <gingell@adacore.com>\n\n\t* s-tassta.adb (Task_Wrapper): Ensure that we don't try to write the\n\tstack guard page on PPC Linux. This patch ensures the 64K guard page at\n\tthe bottom of the stack is not overwritten.\n\nFrom-SVN: r178544", "tree": {"sha": "b9cd7b279036f6f468558fceb752e4c1d560f5c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9cd7b279036f6f468558fceb752e4c1d560f5c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81bf23820f1d02a9320ced32b03046554cfcf6ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81bf23820f1d02a9320ced32b03046554cfcf6ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81bf23820f1d02a9320ced32b03046554cfcf6ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81bf23820f1d02a9320ced32b03046554cfcf6ae/comments", "author": null, "committer": null, "parents": [{"sha": "13a0b1e8dd2794b8c4a100b3e27c884657ec7245", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13a0b1e8dd2794b8c4a100b3e27c884657ec7245", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13a0b1e8dd2794b8c4a100b3e27c884657ec7245"}], "stats": {"total": 72, "additions": 44, "deletions": 28}, "files": [{"sha": "852f937ff9830bd75a1433291e773708adb67fd8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81bf23820f1d02a9320ced32b03046554cfcf6ae/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81bf23820f1d02a9320ced32b03046554cfcf6ae/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=81bf23820f1d02a9320ced32b03046554cfcf6ae", "patch": "@@ -1,3 +1,13 @@\n+2011-09-05  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch6.adb: Minor reformatting.\n+\n+2011-09-05  Matthew Gingell  <gingell@adacore.com>\n+\n+\t* s-tassta.adb (Task_Wrapper): Ensure that we don't try to write the\n+\tstack guard page on PPC Linux. This patch ensures the 64K guard page at\n+\tthe bottom of the stack is not overwritten.\n+\n 2011-09-05  Thomas Quinot  <quinot@adacore.com>\n \n \t* exp_intr.adb, s-tasini.adb: Minor reformatting."}, {"sha": "bf1cc3570f830cc272e42c7ebaae050a72392bae", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81bf23820f1d02a9320ced32b03046554cfcf6ae/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81bf23820f1d02a9320ced32b03046554cfcf6ae/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=81bf23820f1d02a9320ced32b03046554cfcf6ae", "patch": "@@ -529,12 +529,15 @@ package body System.Tasking.Stages is\n \n       if CPU /= Unspecified_CPU\n         and then (CPU < Integer (System.Multiprocessors.CPU_Range'First)\n-          or else CPU > Integer (System.Multiprocessors.CPU_Range'Last)\n-          or else CPU > Integer (System.Multiprocessors.Number_Of_CPUs))\n+                    or else\n+                  CPU > Integer (System.Multiprocessors.CPU_Range'Last)\n+                    or else\n+                  CPU > Integer (System.Multiprocessors.Number_Of_CPUs))\n       then\n          raise Tasking_Error with \"CPU not in range\";\n \n       --  Normal CPU affinity\n+\n       else\n          Base_CPU :=\n            (if CPU = Unspecified_CPU\n@@ -1001,8 +1004,8 @@ package body System.Tasking.Stages is\n \n       Initialization.Defer_Abort (Self_ID);\n \n-      --  Loop through the From chain, changing their Master_of_Task\n-      --  fields, and to find the end of the chain.\n+      --  Loop through the From chain, changing their Master_of_Task fields,\n+      --  and to find the end of the chain.\n \n       loop\n          C.Master_of_Task := New_Master;\n@@ -1088,10 +1091,10 @@ package body System.Tasking.Stages is\n       --  Indicates the reason why this task terminates. Normal corresponds to\n       --  a task terminating due to completing the last statement of its body,\n       --  or as a result of waiting on a terminate alternative. If the task\n-      --  terminates because it is being aborted then Cause will be set to\n-      --  Abnormal. If the task terminates because of an exception raised by\n-      --  the execution of its task body, then Cause is set to\n-      --  Unhandled_Exception.\n+      --  terminates because it is being aborted then Cause will be set\n+      --  to Abnormal. If the task terminates because of an exception\n+      --  raised by the execution of its task body, then Cause is set\n+      --  to Unhandled_Exception.\n \n       EO : Exception_Occurrence;\n       --  If the task terminates because of an exception raised by the\n@@ -1172,21 +1175,24 @@ package body System.Tasking.Stages is\n             --  smaller values resulted in segmentation faults from dynamic\n             --  stack analysis.\n \n-            Big_Overflow_Guard : constant := 16 * 1024;\n+            Big_Overflow_Guard : constant := 64 * 1024 + 8 * 1024;\n             Small_Stack_Limit  : constant := 64 * 1024;\n             --  ??? These three values are experimental, and seem to work on\n             --  most platforms. They still need to be analyzed further. They\n-            --  also need documentation, what are they???\n+            --  also need documentation, what are they and why does the logic\n+            --  differ depending on whether the stack is large or small???\n \n             Pattern_Size : Natural :=\n-              Natural (Self_ID.Common.Compiler_Data.Pri_Stack_Info.Size);\n+                             Natural (Self_ID.Common.\n+                                        Compiler_Data.Pri_Stack_Info.Size);\n             --  Size of the pattern\n \n             Stack_Base : Address;\n             --  Address of the base of the stack\n \n          begin\n             Stack_Base := Self_ID.Common.Compiler_Data.Pri_Stack_Info.Base;\n+\n             if Stack_Base = Null_Address then\n \n                --  On many platforms, we don't know the real stack base\n@@ -1211,6 +1217,7 @@ package body System.Tasking.Stages is\n                     else Big_Overflow_Guard);\n             else\n                --  Reduce by the size of the final guard page\n+\n                Pattern_Size := Pattern_Size - Guard_Page_Size;\n             end if;\n \n@@ -1256,8 +1263,7 @@ package body System.Tasking.Stages is\n       end if;\n \n       if Global_Task_Debug_Event_Set then\n-         Debug.Signal_Debug_Event\n-          (Debug.Debug_Event_Run, Self_ID);\n+         Debug.Signal_Debug_Event (Debug.Debug_Event_Run, Self_ID);\n       end if;\n \n       begin\n@@ -1311,6 +1317,7 @@ package body System.Tasking.Stages is\n                    (Debug.Debug_Event_Abort_Terminated, Self_ID);\n                end if;\n             end if;\n+\n          when others =>\n             --  ??? Using an E : others here causes CD2C11A to fail on Tru64\n \n@@ -1395,10 +1402,9 @@ package body System.Tasking.Stages is\n    -- Terminate_Task --\n    --------------------\n \n-   --  Before we allow the thread to exit, we must clean up. This is a\n-   --  delicate job. We must wake up the task's master, who may immediately try\n-   --  to deallocate the ATCB out from under the current task WHILE IT IS STILL\n-   --  EXECUTING.\n+   --  Before we allow the thread to exit, we must clean up. This is a delicate\n+   --  job. We must wake up the task's master, who may immediately try to\n+   --  deallocate the ATCB from the current task WHILE IT IS STILL EXECUTING.\n \n    --  To avoid this, the parent task must be blocked up to the latest\n    --  statement executed. The trouble is that we have another step that we\n@@ -1433,8 +1439,7 @@ package body System.Tasking.Stages is\n \n       --  Since GCC cannot allocate stack chunks efficiently without reordering\n       --  some of the allocations, we have to handle this unexpected situation\n-      --  here. We should normally never have to call Vulnerable_Complete_Task\n-      --  here.\n+      --  here. Normally we never have to call Vulnerable_Complete_Task here.\n \n       if Self_ID.Common.Activator /= null then\n          Vulnerable_Complete_Task (Self_ID);\n@@ -1455,6 +1460,7 @@ package body System.Tasking.Stages is\n          if Single_Lock then\n             Utilities.Independent_Task_Count :=\n               Utilities.Independent_Task_Count - 1;\n+\n          else\n             Write_Lock (Environment_Task);\n             Utilities.Independent_Task_Count :=\n@@ -1581,8 +1587,8 @@ package body System.Tasking.Stages is\n \n       pragma Assert (Self_ID.Common.Activator /= null);\n \n-      --  Remove dangling reference to Activator, since a task may\n-      --  outlive its activator.\n+      --  Remove dangling reference to Activator, since a task may outlive its\n+      --  activator.\n \n       Self_ID.Common.Activator := null;\n \n@@ -1713,12 +1719,13 @@ package body System.Tasking.Stages is\n \n          if C.Common.Activator = Self_ID and then C.Master_of_Task = CM then\n \n-            pragma Assert (C.Common.State = Unactivated);\n             --  Usually, C.Common.Activator = Self_ID implies C.Master_of_Task\n             --  = CM. The only case where C is pending activation by this\n             --  task, but the master of C is not CM is in Ada 2005, when C is\n             --  part of a return object of a build-in-place function.\n \n+            pragma Assert (C.Common.State = Unactivated);\n+\n             Write_Lock (C);\n             C.Common.Activator := null;\n             C.Common.State := Terminated;\n@@ -1933,9 +1940,8 @@ package body System.Tasking.Stages is\n             declare\n                Detach_Interrupt_Entries_Index : constant Task_Entry_Index := 1;\n                --  Corresponds to the entry index of System.Interrupts.\n-               --  Interrupt_Manager.Detach_Interrupt_Entries.\n-               --  Be sure to update this value when changing\n-               --  Interrupt_Manager specs.\n+               --  Interrupt_Manager.Detach_Interrupt_Entries. Be sure\n+               --  to update this value when changing Interrupt_Manager specs.\n \n                type Param_Type is access all Task_Id;\n "}, {"sha": "1ea897812b0435bc6489d21236d5acc8ce888f80", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81bf23820f1d02a9320ced32b03046554cfcf6ae/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81bf23820f1d02a9320ced32b03046554cfcf6ae/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=81bf23820f1d02a9320ced32b03046554cfcf6ae", "patch": "@@ -2712,9 +2712,9 @@ package body Sem_Ch6 is\n       --  for discriminals and privals and finally a declaration for the entry\n       --  family index (if applicable). This form of early expansion is done\n       --  when the Expander is active because Install_Private_Data_Declarations\n-      --  references entities which were created during regular expansion.\n-      --  The body may be the rewritting of an expression function, and we need\n-      --  to verify that the original node is in the source.\n+      --  references entities which were created during regular expansion. The\n+      --  body may be the rewritting of an expression function, and we need to\n+      --  verify that the original node is in the source.\n \n       if Full_Expander_Active\n         and then Comes_From_Source (Original_Node (N))"}]}