{"sha": "73ed17ff80da57d02cdb33b0035d5e718ed39fa2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNlZDE3ZmY4MGRhNTdkMDJjZGIzM2IwMDM1ZDVlNzE4ZWQzOWZhMg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2005-08-23T07:28:26Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2005-08-23T07:28:26Z"}, "message": "re PR middle-end/22043 (Fields not initialized for automatic structs with flexible array members)\n\n\tPR tree-optimization/22043\n\t* tree.h (count_type_elements): Add ALLOW_FLEXARR argument.\n\t* expr.c (count_type_elements): Add ALLOW_FLEXARR argument.\n\tIf ALLOW_FLEXARR, handle types ending with flexible array member.\n\tPass false as second argument to recursive count_type_elements calls.\n\t(categorize_ctor_elements_1, mostly_zeros_p): Pass false as second\n\targument to count_type_elements call.\n\t* tree-sra.c (decide_block_copy): Likewise.\n\t* gimplify.c (gimplify_init_constructor): If num_type_elements < 0\n\tfor a constant-sized object, set cleared as well.  Pass true as\n\tsecond argument to count_type_elements call.\n\n\t* gcc.c-torture/execute/20050613-1.c: New test.\n\nFrom-SVN: r103389", "tree": {"sha": "f384afa06e592a553c6af6af04e511b95114c8d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f384afa06e592a553c6af6af04e511b95114c8d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73ed17ff80da57d02cdb33b0035d5e718ed39fa2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73ed17ff80da57d02cdb33b0035d5e718ed39fa2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73ed17ff80da57d02cdb33b0035d5e718ed39fa2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73ed17ff80da57d02cdb33b0035d5e718ed39fa2/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "18b10a7276e8d33f3f77ff80225adc4df16619d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18b10a7276e8d33f3f77ff80225adc4df16619d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18b10a7276e8d33f3f77ff80225adc4df16619d9"}], "stats": {"total": 92, "additions": 79, "deletions": 13}, "files": [{"sha": "1f3f5383b4b0ed5db01559a92da1a9ce1c667f33", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ed17ff80da57d02cdb33b0035d5e718ed39fa2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ed17ff80da57d02cdb33b0035d5e718ed39fa2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73ed17ff80da57d02cdb33b0035d5e718ed39fa2", "patch": "@@ -1,3 +1,17 @@\n+2005-08-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/22043\n+\t* tree.h (count_type_elements): Add ALLOW_FLEXARR argument.\n+\t* expr.c (count_type_elements): Add ALLOW_FLEXARR argument.\n+\tIf ALLOW_FLEXARR, handle types ending with flexible array member.\n+\tPass false as second argument to recursive count_type_elements calls.\n+\t(categorize_ctor_elements_1, mostly_zeros_p): Pass false as second\n+\targument to count_type_elements call.\n+\t* tree-sra.c (decide_block_copy): Likewise.\n+\t* gimplify.c (gimplify_init_constructor): If num_type_elements < 0\n+\tfor a constant-sized object, set cleared as well.  Pass true as\n+\tsecond argument to count_type_elements call.\n+\n 2005-08-23  Alan Modra  <amodra@bigpond.net.au>\n \n \tPR target/21571"}, {"sha": "6cfe2d11746ecbcb27e7978b335479ba84ed7d79", "filename": "gcc/expr.c", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ed17ff80da57d02cdb33b0035d5e718ed39fa2/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ed17ff80da57d02cdb33b0035d5e718ed39fa2/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=73ed17ff80da57d02cdb33b0035d5e718ed39fa2", "patch": "@@ -4504,7 +4504,7 @@ categorize_ctor_elements_1 (tree ctor, HOST_WIDE_INT *p_nz_elts,\n \t      /* And now we have to find out if the element itself is fully\n \t\t constructed.  E.g. for union { struct { int a, b; } s; } u\n \t\t = { .s = { .a = 1 } }.  */\n-\t      if (elt_count == count_type_elements (init_sub_type))\n+\t      if (elt_count == count_type_elements (init_sub_type, false))\n \t\tclear_this = false;\n \t    }\n \t}\n@@ -4532,10 +4532,11 @@ categorize_ctor_elements (tree ctor, HOST_WIDE_INT *p_nz_elts,\n }\n \n /* Count the number of scalars in TYPE.  Return -1 on overflow or\n-   variable-sized.  */\n+   variable-sized.  If ALLOW_FLEXARR is true, don't count flexible\n+   array member at the end of the structure.  */\n \n HOST_WIDE_INT\n-count_type_elements (tree type)\n+count_type_elements (tree type, bool allow_flexarr)\n {\n   const HOST_WIDE_INT max = ~((HOST_WIDE_INT)1 << (HOST_BITS_PER_WIDE_INT-1));\n   switch (TREE_CODE (type))\n@@ -4546,7 +4547,7 @@ count_type_elements (tree type)\n \tif (telts && host_integerp (telts, 1))\n \t  {\n \t    HOST_WIDE_INT n = tree_low_cst (telts, 1) + 1;\n-\t    HOST_WIDE_INT m = count_type_elements (TREE_TYPE (type));\n+\t    HOST_WIDE_INT m = count_type_elements (TREE_TYPE (type), false);\n \t    if (n == 0)\n \t      return 0;\n \t    else if (max / n > m)\n@@ -4563,9 +4564,23 @@ count_type_elements (tree type)\n \tfor (f = TYPE_FIELDS (type); f ; f = TREE_CHAIN (f))\n \t  if (TREE_CODE (f) == FIELD_DECL)\n \t    {\n-\t      t = count_type_elements (TREE_TYPE (f));\n+\t      t = count_type_elements (TREE_TYPE (f), false);\n \t      if (t < 0)\n-\t\treturn -1;\n+\t\t{\n+\t\t  /* Check for structures with flexible array member.  */\n+\t\t  tree tf = TREE_TYPE (f);\n+\t\t  if (allow_flexarr\n+\t\t      && TREE_CHAIN (f) == NULL\n+\t\t      && TREE_CODE (tf) == ARRAY_TYPE\n+\t\t      && TYPE_DOMAIN (tf)\n+\t\t      && TYPE_MIN_VALUE (TYPE_DOMAIN (tf))\n+\t\t      && integer_zerop (TYPE_MIN_VALUE (TYPE_DOMAIN (tf)))\n+\t\t      && !TYPE_MAX_VALUE (TYPE_DOMAIN (tf))\n+\t\t      && int_size_in_bytes (type) >= 0)\n+\t\t    break;\n+\n+\t\t  return -1;\n+\t\t}\n \t      n += t;\n \t    }\n \n@@ -4623,7 +4638,7 @@ mostly_zeros_p (tree exp)\n       if (must_clear)\n \treturn 1;\n \n-      elts = count_type_elements (TREE_TYPE (exp));\n+      elts = count_type_elements (TREE_TYPE (exp), false);\n \n       return nz_elts < elts / 4;\n     }"}, {"sha": "9b34970647f1306e6d2f258191483f87d23a0126", "filename": "gcc/gimplify.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ed17ff80da57d02cdb33b0035d5e718ed39fa2/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ed17ff80da57d02cdb33b0035d5e718ed39fa2/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=73ed17ff80da57d02cdb33b0035d5e718ed39fa2", "patch": "@@ -2706,13 +2706,18 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t   parts in, then generate code for the non-constant parts.  */\n \t/* TODO.  There's code in cp/typeck.c to do this.  */\n \n-\tnum_type_elements = count_type_elements (TREE_TYPE (ctor));\n+\tnum_type_elements = count_type_elements (type, true);\n \n+\t/* If count_type_elements could not determine number of type elements\n+\t   for a constant-sized object, assume clearing is needed.\n+\t   Don't do this for variable-sized objects, as store_constructor\n+\t   will ignore the clearing of variable-sized objects.  */\n+\tif (num_type_elements < 0 && int_size_in_bytes (type) >= 0)\n+\t  cleared = true;\n \t/* If there are \"lots\" of zeros, then block clear the object first.  */\n-\tif (num_type_elements - num_nonzero_elements > CLEAR_RATIO\n-\t    && num_nonzero_elements < num_type_elements/4)\n+\telse if (num_type_elements - num_nonzero_elements > CLEAR_RATIO\n+\t\t && num_nonzero_elements < num_type_elements/4)\n \t  cleared = true;\n-\n \t/* ??? This bit ought not be needed.  For any element not present\n \t   in the initializer, we should simply set them to zero.  Except\n \t   we'd need to *find* the elements that are not present, and that"}, {"sha": "42002e979b97a34d76081556a0a0f77ebd540ddc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ed17ff80da57d02cdb33b0035d5e718ed39fa2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ed17ff80da57d02cdb33b0035d5e718ed39fa2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=73ed17ff80da57d02cdb33b0035d5e718ed39fa2", "patch": "@@ -1,3 +1,8 @@\n+2005-08-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/22043\n+\t* gcc.c-torture/execute/20050613-1.c: New test.\n+\n 2005-08-23  Ben Elliston  <bje@au.ibm.com>\n \n \t* gcc.c-torture/execute/ieee/ieee.exp: Load gcc-dg.exp library."}, {"sha": "f1b4e94c371f226717a495efcb011b03faa0dcf5", "filename": "gcc/testsuite/gcc.c-torture/execute/20050613-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ed17ff80da57d02cdb33b0035d5e718ed39fa2/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20050613-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ed17ff80da57d02cdb33b0035d5e718ed39fa2/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20050613-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20050613-1.c?ref=73ed17ff80da57d02cdb33b0035d5e718ed39fa2", "patch": "@@ -0,0 +1,27 @@\n+/* PR tree-optimization/22043 */\n+\n+extern void abort (void);\n+\n+struct A { int i; int j; int k; int l; };\n+struct B { struct A a; int r[1]; };\n+struct C { struct A a; int r[0]; };\n+struct D { struct A a; int r[]; };\n+\n+void\n+foo (struct A *x)\n+{\n+  if (x->i != 0 || x->j != 5 || x->k != 0 || x->l != 0)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  struct B b = { .a.j = 5 };\n+  struct C c = { .a.j = 5 };\n+  struct D d = { .a.j = 5 };\n+  foo (&b.a);\n+  foo (&c.a);\n+  foo (&d.a);\n+  return 0;\n+}"}, {"sha": "940f7a97dfb1727c8000a6c1fc60c497ed3f2d12", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ed17ff80da57d02cdb33b0035d5e718ed39fa2/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ed17ff80da57d02cdb33b0035d5e718ed39fa2/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=73ed17ff80da57d02cdb33b0035d5e718ed39fa2", "patch": "@@ -1338,7 +1338,7 @@ decide_block_copy (struct sra_elt *elt)\n \t    : MOVE_RATIO;\n \n \t  full_size = tree_low_cst (size_tree, 1);\n-\t  full_count = count_type_elements (elt->type);\n+\t  full_count = count_type_elements (elt->type, false);\n \t  inst_count = sum_instantiated_sizes (elt, &inst_size);\n \n \t  /* ??? What to do here.  If there are two fields, and we've only"}, {"sha": "dba6ed52f0f8753203184026f900c2f3497bf552", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ed17ff80da57d02cdb33b0035d5e718ed39fa2/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ed17ff80da57d02cdb33b0035d5e718ed39fa2/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=73ed17ff80da57d02cdb33b0035d5e718ed39fa2", "patch": "@@ -3555,7 +3555,7 @@ extern bool initializer_zerop (tree);\n \n extern void categorize_ctor_elements (tree, HOST_WIDE_INT *, HOST_WIDE_INT *,\n \t\t\t\t      HOST_WIDE_INT *, bool *);\n-extern HOST_WIDE_INT count_type_elements (tree);\n+extern HOST_WIDE_INT count_type_elements (tree, bool);\n \n /* add_var_to_bind_expr (bind_expr, var) binds var to bind_expr.  */\n "}]}