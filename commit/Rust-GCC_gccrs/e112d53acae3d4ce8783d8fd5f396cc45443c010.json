{"sha": "e112d53acae3d4ce8783d8fd5f396cc45443c010", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTExMmQ1M2FjYWUzZDRjZTg3ODNkOGZkNWYzOTZjYzQ1NDQzYzAxMA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-07-02T20:31:11Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-07-02T20:31:11Z"}, "message": "Optimize std::sub_match comparisons using string_view-like type\n\nAvoid creation of unnecessary basic_string objects by using a simplified\nstring_view type and performing comparisons on that type instead. A\ntemporary basic_string object is still used when the sub_match's\niterators are not contiguous, in order to get an object that the\n__string_view can reference.\n\n\t* include/bits/regex.h (sub_match::operator string_type): Call str().\n\t(sub_match::compare): Use _M_str() instead of str().\n\t(sub_match::_M_compare): New public function.\n\t(sub_match::__string_view): New helper type.\n\t(sub_match::_M_str): New overloaded functions to avoid creating a\n\tstring_type object when not needed.\n\t(operator==, operator!=, operator<, operator>, operator<=, operator>=):\n\tUse sub_match::_M_compare instead of creating string_type objects.\n\tFix Doxygen comments.\n\t* include/bits/regex_compiler.h (__has_contiguous_iter): Remove.\n\t(__is_contiguous_normal_iter): Rename to __is_contiguous_iter and\n\tsimplify.\n\t(__enable_if_contiguous_iter, __disable_if_contiguous_iter): Use\n\t__enable_if_t.\n\t* include/std/type_traits (__enable_if_t): Define for C++11.\n\t* testsuite/28_regex/sub_match/compare.cc: New.\n\t* testsuite/util/testsuite_iterators.h (remove_cv): Add transformation\n\ttrait.\n\t(input_iterator_wrapper): Use remove_cv for value_type argument of\n\tstd::iterator base class.\n\nFrom-SVN: r262318", "tree": {"sha": "0ce793bb9ddf0b5a31d715e478ac9641fd822081", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ce793bb9ddf0b5a31d715e478ac9641fd822081"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e112d53acae3d4ce8783d8fd5f396cc45443c010", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e112d53acae3d4ce8783d8fd5f396cc45443c010", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e112d53acae3d4ce8783d8fd5f396cc45443c010", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e112d53acae3d4ce8783d8fd5f396cc45443c010/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbf96d49454d608b5cb9e39e341e13b60ec7965e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbf96d49454d608b5cb9e39e341e13b60ec7965e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbf96d49454d608b5cb9e39e341e13b60ec7965e"}], "stats": {"total": 628, "additions": 489, "deletions": 139}, "files": [{"sha": "b2958e43745c1b28d2bff35634585755f452334f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e112d53acae3d4ce8783d8fd5f396cc45443c010/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e112d53acae3d4ce8783d8fd5f396cc45443c010/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e112d53acae3d4ce8783d8fd5f396cc45443c010", "patch": "@@ -1,3 +1,26 @@\n+2018-07-02  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/bits/regex.h (sub_match::operator string_type): Call str().\n+\t(sub_match::compare): Use _M_str() instead of str().\n+\t(sub_match::_M_compare): New public function.\n+\t(sub_match::__string_view): New helper type.\n+\t(sub_match::_M_str): New overloaded functions to avoid creating a\n+\tstring_type object when not needed.\n+\t(operator==, operator!=, operator<, operator>, operator<=, operator>=):\n+\tUse sub_match::_M_compare instead of creating string_type objects.\n+\tFix Doxygen comments.\n+\t* include/bits/regex_compiler.h (__has_contiguous_iter): Remove.\n+\t(__is_contiguous_normal_iter): Rename to __is_contiguous_iter and\n+\tsimplify.\n+\t(__enable_if_contiguous_iter, __disable_if_contiguous_iter): Use\n+\t__enable_if_t.\n+\t* include/std/type_traits (__enable_if_t): Define for C++11.\n+\t* testsuite/28_regex/sub_match/compare.cc: New.\n+\t* testsuite/util/testsuite_iterators.h (remove_cv): Add transformation\n+\ttrait.\n+\t(input_iterator_wrapper): Use remove_cv for value_type argument of\n+\tstd::iterator base class.\n+\n 2018-06-29  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* testsuite/20_util/add_rvalue_reference/requirements/alias_decl.cc:"}, {"sha": "af6fe3f0d79b0375d754d9e66c95e98aa7da788e", "filename": "libstdc++-v3/include/bits/regex.h", "status": "modified", "additions": 137, "deletions": 107, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e112d53acae3d4ce8783d8fd5f396cc45443c010/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e112d53acae3d4ce8783d8fd5f396cc45443c010/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h?ref=e112d53acae3d4ce8783d8fd5f396cc45443c010", "patch": "@@ -42,8 +42,7 @@ _GLIBCXX_END_NAMESPACE_CXX11\n \n namespace __detail\n {\n-  enum class _RegexExecutorPolicy : int\n-    { _S_auto, _S_alternate };\n+  enum class _RegexExecutorPolicy : int { _S_auto, _S_alternate };\n \n   template<typename _BiIter, typename _Alloc,\n \t   typename _CharT, typename _TraitsT,\n@@ -847,7 +846,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     { __lhs.swap(__rhs); }\n \n \n-  // [7.9] Class template sub_match\n+  // C++11 28.9 [re.submatch] Class template sub_match\n   /**\n    * A sequence of characters matched by a particular marked sub-expression.\n    *\n@@ -875,9 +874,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \n       constexpr sub_match() noexcept : matched() { }\n \n-      /**\n-       * Gets the length of the matching sequence.\n-       */\n+      /// Gets the length of the matching sequence.\n       difference_type\n       length() const noexcept\n       { return this->matched ? std::distance(this->first, this->second) : 0; }\n@@ -893,11 +890,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n        * from the unwary.\n        */\n       operator string_type() const\n-      {\n-\treturn this->matched\n-\t  ? string_type(this->first, this->second)\n-\t  : string_type();\n-      }\n+      { return str(); }\n \n       /**\n        * @brief Gets the matching sequence as a string.\n@@ -923,9 +916,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n        */\n       int\n       compare(const sub_match& __s) const\n-      { return this->str().compare(__s.str()); }\n+      { return this->_M_str().compare(__s._M_str()); }\n \n       /**\n+       * @{\n        * @brief Compares this sub_match to a string.\n        *\n        * @param __s A string to compare to this sub_match.\n@@ -936,20 +930,72 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n        */\n       int\n       compare(const string_type& __s) const\n-      { return this->str().compare(__s); }\n+      { return this->_M_str().compare(__s); }\n \n-      /**\n-       * @brief Compares this sub_match to a C-style string.\n-       *\n-       * @param __s A C-style string to compare to this sub_match.\n-       *\n-       * @retval <0 this matched sequence will collate before @p __s.\n-       * @retval =0 this matched sequence is equivalent to @p __s.\n-       * @retval <0 this matched sequence will collate after @p __s.\n-       */\n       int\n       compare(const value_type* __s) const\n-      { return this->str().compare(__s); }\n+      { return this->_M_str().compare(__s); }\n+      // @}\n+\n+      // Non-standard, used by comparison operators\n+      int\n+      _M_compare(const value_type* __s, size_t __n) const\n+      { return this->_M_str().compare({__s, __n}); }\n+\n+    private:\n+      // Simplified basic_string_view for C++11\n+      struct __string_view\n+      {\n+\tusing traits_type = typename string_type::traits_type;\n+\n+\t__string_view() = default;\n+\n+\t__string_view(const value_type* __s, size_t __n) noexcept\n+\t: _M_data(__s), _M_len(__n) { }\n+\n+\t__string_view(const value_type* __s) noexcept\n+\t: _M_data(__s), _M_len(traits_type::length(__s)) { }\n+\n+\t__string_view(const string_type& __s) noexcept\n+\t: _M_data(__s.data()), _M_len(__s.length()) { }\n+\n+\tint\n+\tcompare(__string_view __s) const noexcept\n+\t{\n+\t  if (const size_t __n = std::min(_M_len, __s._M_len))\n+\t    if (int __ret = traits_type::compare(_M_data, __s._M_data, __n))\n+\t      return __ret;\n+\t  const difference_type __diff = _M_len - __s._M_len;\n+\t  if (__diff > std::numeric_limits<int>::max())\n+\t    return std::numeric_limits<int>::max();\n+\t  if (__diff < std::numeric_limits<int>::min())\n+\t    return std::numeric_limits<int>::min();\n+\t  return static_cast<int>(__diff);\n+\t}\n+\n+      private:\n+\tconst value_type* _M_data = nullptr;\n+\tsize_t _M_len = 0;\n+      };\n+\n+      // Create a __string_view over the iterator range.\n+      template<typename _Iter = _BiIter>\n+\t__enable_if_t<__detail::__is_contiguous_iter<_Iter>::value,\n+\t\t      __string_view>\n+\t_M_str() const noexcept\n+\t{\n+\t  if (this->matched)\n+\t    if (auto __len = this->second - this->first)\n+\t      return { std::__addressof(*this->first), __len };\n+\t  return {};\n+\t}\n+\n+      // Create a temporary string that can be converted to __string_view.\n+      template<typename _Iter = _BiIter>\n+\t__enable_if_t<!__detail::__is_contiguous_iter<_Iter>::value,\n+\t\t      string_type>\n+\t_M_str() const\n+\t{ return str(); }\n     };\n \n \n@@ -1035,7 +1081,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     operator>(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)\n     { return __lhs.compare(__rhs) > 0; }\n \n-  // Alias for sub_match'd string.\n+  // Alias for a basic_string that can be compared to a sub_match.\n   template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n     using __sub_match_string = basic_string<\n \t\t\t      typename iterator_traits<_Bi_iter>::value_type,\n@@ -1052,10 +1098,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     inline bool\n     operator==(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n \t       const sub_match<_Bi_iter>& __rhs)\n-    {\n-      typedef typename sub_match<_Bi_iter>::string_type string_type;\n-      return __rhs.compare(string_type(__lhs.data(), __lhs.size())) == 0;\n-    }\n+    { return __rhs._M_compare(__lhs.data(), __lhs.size()) == 0; }\n \n   /**\n    * @brief Tests the inequivalence of a string and a regular expression\n@@ -1080,10 +1123,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     inline bool\n     operator<(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n \t      const sub_match<_Bi_iter>& __rhs)\n-    {\n-      typedef typename sub_match<_Bi_iter>::string_type string_type;\n-      return __rhs.compare(string_type(__lhs.data(), __lhs.size())) > 0;\n-    }\n+    { return __rhs._M_compare(__lhs.data(), __lhs.size()) > 0; }\n \n   /**\n    * @brief Tests the ordering of a string and a regular expression submatch.\n@@ -1132,10 +1172,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     inline bool\n     operator==(const sub_match<_Bi_iter>& __lhs,\n \t       const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)\n-    {\n-      typedef typename sub_match<_Bi_iter>::string_type string_type;\n-      return __lhs.compare(string_type(__rhs.data(), __rhs.size())) == 0;\n-    }\n+    { return __lhs._M_compare(__rhs.data(), __rhs.size()) == 0; }\n \n   /**\n    * @brief Tests the inequivalence of a regular expression submatch and a\n@@ -1156,22 +1193,19 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n    * @param __rhs A string.\n    * @returns true if @a __lhs precedes @a __rhs, false otherwise.\n    */\n-  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n     inline bool\n     operator<(const sub_match<_Bi_iter>& __lhs,\n \t      const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)\n-    {\n-      typedef typename sub_match<_Bi_iter>::string_type string_type;\n-      return __lhs.compare(string_type(__rhs.data(), __rhs.size())) < 0;\n-    }\n+    { return __lhs._M_compare(__rhs.data(), __rhs.size()) < 0; }\n \n   /**\n    * @brief Tests the ordering of a regular expression submatch and a string.\n    * @param __lhs A regular expression submatch.\n    * @param __rhs A string.\n    * @returns true if @a __lhs succeeds @a __rhs, false otherwise.\n    */\n-  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n     inline bool\n     operator>(const sub_match<_Bi_iter>& __lhs,\n \t      const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)\n@@ -1183,7 +1217,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n    * @param __rhs A string.\n    * @returns true if @a __lhs does not precede @a __rhs, false otherwise.\n    */\n-  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n     inline bool\n     operator>=(const sub_match<_Bi_iter>& __lhs,\n \t       const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)\n@@ -1195,7 +1229,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n    * @param __rhs A string.\n    * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.\n    */\n-  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n     inline bool\n     operator<=(const sub_match<_Bi_iter>& __lhs,\n \t       const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)\n@@ -1204,7 +1238,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n   /**\n    * @brief Tests the equivalence of a C string and a regular expression\n    *        submatch.\n-   * @param __lhs A C string.\n+   * @param __lhs A null-terminated string.\n    * @param __rhs A regular expression submatch.\n    * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.\n    */\n@@ -1215,10 +1249,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     { return __rhs.compare(__lhs) == 0; }\n \n   /**\n-   * @brief Tests the inequivalence of an iterator value and a regular\n+   * @brief Tests the inequivalence of a C string and a regular\n    *        expression submatch.\n-   * @param __lhs A regular expression submatch.\n-   * @param __rhs A string.\n+   * @param __lhs A null-terminated string.\n+   * @param __rhs A regular expression submatch.\n    * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.\n    */\n   template<typename _Bi_iter>\n@@ -1228,8 +1262,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     { return !(__lhs == __rhs); }\n \n   /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param __lhs A string.\n+   * @brief Tests the ordering of a C string and a regular expression submatch.\n+   * @param __lhs A null-terminated string.\n    * @param __rhs A regular expression submatch.\n    * @returns true if @a __lhs precedes @a __rhs, false otherwise.\n    */\n@@ -1240,8 +1274,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     { return __rhs.compare(__lhs) > 0; }\n \n   /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param __lhs A string.\n+   * @brief Tests the ordering of a C string and a regular expression submatch.\n+   * @param __lhs A null-terminated string.\n    * @param __rhs A regular expression submatch.\n    * @returns true if @a __lhs succeeds @a __rhs, false otherwise.\n    */\n@@ -1252,8 +1286,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     { return __rhs < __lhs; }\n \n   /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param __lhs A string.\n+   * @brief Tests the ordering of a C string and a regular expression submatch.\n+   * @param __lhs A null-terminated string.\n    * @param __rhs A regular expression submatch.\n    * @returns true if @a __lhs does not precede @a __rhs, false otherwise.\n    */\n@@ -1264,8 +1298,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     { return !(__lhs < __rhs); }\n \n   /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param __lhs A string.\n+   * @brief Tests the ordering of a C string and a regular expression submatch.\n+   * @param __lhs A null-terminated string.\n    * @param __rhs A regular expression submatch.\n    * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.\n    */\n@@ -1276,10 +1310,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     { return !(__rhs < __lhs); }\n \n   /**\n-   * @brief Tests the equivalence of a regular expression submatch and a\n+   * @brief Tests the equivalence of a regular expression submatch and a C\n    *        string.\n    * @param __lhs A regular expression submatch.\n-   * @param __rhs A pointer to a string?\n+   * @param __rhs A null-terminated string.\n    * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.\n    */\n   template<typename _Bi_iter>\n@@ -1292,7 +1326,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n    * @brief Tests the inequivalence of a regular expression submatch and a\n    *        string.\n    * @param __lhs A regular expression submatch.\n-   * @param __rhs A pointer to a string.\n+   * @param __rhs A null-terminated string.\n    * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.\n    */\n   template<typename _Bi_iter>\n@@ -1302,9 +1336,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     { return !(__lhs == __rhs); }\n \n   /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @brief Tests the ordering of a regular expression submatch and a C string.\n    * @param __lhs A regular expression submatch.\n-   * @param __rhs A string.\n+   * @param __rhs A null-terminated string.\n    * @returns true if @a __lhs precedes @a __rhs, false otherwise.\n    */\n   template<typename _Bi_iter>\n@@ -1314,9 +1348,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     { return __lhs.compare(__rhs) < 0; }\n \n   /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @brief Tests the ordering of a regular expression submatch and a C string.\n    * @param __lhs A regular expression submatch.\n-   * @param __rhs A string.\n+   * @param __rhs A null-terminated string.\n    * @returns true if @a __lhs succeeds @a __rhs, false otherwise.\n    */\n   template<typename _Bi_iter>\n@@ -1326,9 +1360,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     { return __rhs < __lhs; }\n \n   /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @brief Tests the ordering of a regular expression submatch and a C string.\n    * @param __lhs A regular expression submatch.\n-   * @param __rhs A string.\n+   * @param __rhs A null-terminated string.\n    * @returns true if @a __lhs does not precede @a __rhs, false otherwise.\n    */\n   template<typename _Bi_iter>\n@@ -1338,9 +1372,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     { return !(__lhs < __rhs); }\n \n   /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @brief Tests the ordering of a regular expression submatch and a C string.\n    * @param __lhs A regular expression submatch.\n-   * @param __rhs A string.\n+   * @param __rhs A null-terminated string.\n    * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.\n    */\n   template<typename _Bi_iter>\n@@ -1350,25 +1384,22 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     { return !(__rhs < __lhs); }\n \n   /**\n-   * @brief Tests the equivalence of a string and a regular expression\n+   * @brief Tests the equivalence of a character and a regular expression\n    *        submatch.\n-   * @param __lhs A string.\n+   * @param __lhs A character.\n    * @param __rhs A regular expression submatch.\n    * @returns true if @a __lhs is equivalent to @a __rhs, false otherwise.\n    */\n   template<typename _Bi_iter>\n     inline bool\n     operator==(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n \t       const sub_match<_Bi_iter>& __rhs)\n-    {\n-      typedef typename sub_match<_Bi_iter>::string_type string_type;\n-      return __rhs.compare(string_type(1, __lhs)) == 0;\n-    }\n+    { return __rhs._M_compare(std::__addressof(__lhs), 1) == 0; }\n \n   /**\n-   * @brief Tests the inequivalence of a string and a regular expression\n+   * @brief Tests the inequivalence of a character and a regular expression\n    *        submatch.\n-   * @param __lhs A string.\n+   * @param __lhs A character.\n    * @param __rhs A regular expression submatch.\n    * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.\n    */\n@@ -1379,23 +1410,22 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     { return !(__lhs == __rhs); }\n \n   /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param __lhs A string.\n+   * @brief Tests the ordering of a character and a regular expression\n+   *        submatch.\n+   * @param __lhs A character.\n    * @param __rhs A regular expression submatch.\n    * @returns true if @a __lhs precedes @a __rhs, false otherwise.\n    */\n   template<typename _Bi_iter>\n     inline bool\n     operator<(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n \t      const sub_match<_Bi_iter>& __rhs)\n-    {\n-      typedef typename sub_match<_Bi_iter>::string_type string_type;\n-      return __rhs.compare(string_type(1, __lhs)) > 0;\n-    }\n+    { return __rhs._M_compare(std::__addressof(__lhs), 1) > 0; }\n \n   /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param __lhs A string.\n+   * @brief Tests the ordering of a character and a regular expression\n+   *        submatch.\n+   * @param __lhs A character.\n    * @param __rhs A regular expression submatch.\n    * @returns true if @a __lhs succeeds @a __rhs, false otherwise.\n    */\n@@ -1406,8 +1436,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     { return __rhs < __lhs; }\n \n   /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param __lhs A string.\n+   * @brief Tests the ordering of a character and a regular expression\n+   *        submatch.\n+   * @param __lhs A character.\n    * @param __rhs A regular expression submatch.\n    * @returns true if @a __lhs does not precede @a __rhs, false otherwise.\n    */\n@@ -1418,8 +1449,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     { return !(__lhs < __rhs); }\n \n   /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param __lhs A string.\n+   * @brief Tests the ordering of a character and a regular expression\n+   *        submatch.\n+   * @param __lhs A character.\n    * @param __rhs A regular expression submatch.\n    * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.\n    */\n@@ -1431,25 +1463,22 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \n   /**\n    * @brief Tests the equivalence of a regular expression submatch and a\n-   *        string.\n+   *        character.\n    * @param __lhs A regular expression submatch.\n-   * @param __rhs A const string reference.\n+   * @param __rhs A character.\n    * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.\n    */\n   template<typename _Bi_iter>\n     inline bool\n     operator==(const sub_match<_Bi_iter>& __lhs,\n \t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n-    {\n-      typedef typename sub_match<_Bi_iter>::string_type string_type;\n-      return __lhs.compare(string_type(1, __rhs)) == 0;\n-    }\n+    { return __lhs._M_compare(std::__addressof(__rhs), 1) == 0; }\n \n   /**\n    * @brief Tests the inequivalence of a regular expression submatch and a\n-   *        string.\n+   *        character.\n    * @param __lhs A regular expression submatch.\n-   * @param __rhs A const string reference.\n+   * @param __rhs A character.\n    * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.\n    */\n   template<typename _Bi_iter>\n@@ -1459,24 +1488,23 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     { return !(__lhs == __rhs); }\n \n   /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @brief Tests the ordering of a regular expression submatch and a\n+   *        character.\n    * @param __lhs A regular expression submatch.\n-   * @param __rhs A const string reference.\n+   * @param __rhs A character.\n    * @returns true if @a __lhs precedes @a __rhs, false otherwise.\n    */\n   template<typename _Bi_iter>\n     inline bool\n     operator<(const sub_match<_Bi_iter>& __lhs,\n \t      typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n-    {\n-      typedef typename sub_match<_Bi_iter>::string_type string_type;\n-      return __lhs.compare(string_type(1, __rhs)) < 0;\n-    }\n+    { return __lhs._M_compare(std::__addressof(__rhs), 1) < 0; }\n \n   /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @brief Tests the ordering of a regular expression submatch and a\n+   *        character.\n    * @param __lhs A regular expression submatch.\n-   * @param __rhs A const string reference.\n+   * @param __rhs A character.\n    * @returns true if @a __lhs succeeds @a __rhs, false otherwise.\n    */\n   template<typename _Bi_iter>\n@@ -1486,9 +1514,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     { return __rhs < __lhs; }\n \n   /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @brief Tests the ordering of a regular expression submatch and a\n+   *        character.\n    * @param __lhs A regular expression submatch.\n-   * @param __rhs A const string reference.\n+   * @param __rhs A character.\n    * @returns true if @a __lhs does not precede @a __rhs, false otherwise.\n    */\n   template<typename _Bi_iter>\n@@ -1498,9 +1527,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     { return !(__lhs < __rhs); }\n \n   /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @brief Tests the ordering of a regular expression submatch and a\n+   *        character.\n    * @param __lhs A regular expression submatch.\n-   * @param __rhs A const string reference.\n+   * @param __rhs A character.\n    * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.\n    */\n   template<typename _Bi_iter>"}, {"sha": "f34b148742b3ff0722ea651a0a9fe17386ee9bf0", "filename": "libstdc++-v3/include/bits/regex_compiler.h", "status": "modified", "additions": 11, "deletions": 28, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e112d53acae3d4ce8783d8fd5f396cc45443c010/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e112d53acae3d4ce8783d8fd5f396cc45443c010/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h?ref=e112d53acae3d4ce8783d8fd5f396cc45443c010", "patch": "@@ -154,42 +154,25 @@ namespace __detail\n     };\n \n   template<typename _Tp>\n-    struct __has_contiguous_iter : std::false_type { };\n-\n-  template<typename _Ch, typename _Tr, typename _Alloc>\n-    struct __has_contiguous_iter<std::basic_string<_Ch, _Tr, _Alloc>>\n-    : std::true_type\n-    { };\n-\n-  template<typename _Tp, typename _Alloc>\n-    struct __has_contiguous_iter<std::vector<_Tp, _Alloc>>\n-    : std::true_type\n-    { };\n-\n-  template<typename _Tp>\n-    struct __is_contiguous_normal_iter : std::false_type { };\n-\n-  template<typename _CharT>\n-    struct __is_contiguous_normal_iter<_CharT*> : std::true_type { };\n+    struct __is_contiguous_iter : is_pointer<_Tp>::type { };\n \n   template<typename _Tp, typename _Cont>\n     struct\n-    __is_contiguous_normal_iter<__gnu_cxx::__normal_iterator<_Tp, _Cont>>\n-    : __has_contiguous_iter<_Cont>::type\n-    { };\n+    __is_contiguous_iter<__gnu_cxx::__normal_iterator<_Tp*, _Cont>>\n+    : true_type { };\n \n   template<typename _Iter, typename _TraitsT>\n-    using __enable_if_contiguous_normal_iter\n-      = typename enable_if< __is_contiguous_normal_iter<_Iter>::value,\n-                           std::shared_ptr<const _NFA<_TraitsT>> >::type;\n+    using __enable_if_contiguous_iter\n+      = __enable_if_t< __is_contiguous_iter<_Iter>::value,\n+                       std::shared_ptr<const _NFA<_TraitsT>> >;\n \n   template<typename _Iter, typename _TraitsT>\n-    using __disable_if_contiguous_normal_iter\n-      = typename enable_if< !__is_contiguous_normal_iter<_Iter>::value,\n-                           std::shared_ptr<const _NFA<_TraitsT>> >::type;\n+    using __disable_if_contiguous_iter\n+      = __enable_if_t< !__is_contiguous_iter<_Iter>::value,\n+                       std::shared_ptr<const _NFA<_TraitsT>> >;\n \n   template<typename _TraitsT, typename _FwdIter>\n-    inline __enable_if_contiguous_normal_iter<_FwdIter, _TraitsT>\n+    inline __enable_if_contiguous_iter<_FwdIter, _TraitsT>\n     __compile_nfa(_FwdIter __first, _FwdIter __last,\n \t\t  const typename _TraitsT::locale_type& __loc,\n \t\t  regex_constants::syntax_option_type __flags)\n@@ -201,7 +184,7 @@ namespace __detail\n     }\n \n   template<typename _TraitsT, typename _FwdIter>\n-    inline __disable_if_contiguous_normal_iter<_FwdIter, _TraitsT>\n+    inline __disable_if_contiguous_iter<_FwdIter, _TraitsT>\n     __compile_nfa(_FwdIter __first, _FwdIter __last,\n \t\t  const typename _TraitsT::locale_type& __loc,\n \t\t  regex_constants::syntax_option_type __flags)"}, {"sha": "0c7e97286caf15fe103c72fca1676897c3e678e7", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e112d53acae3d4ce8783d8fd5f396cc45443c010/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e112d53acae3d4ce8783d8fd5f396cc45443c010/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=e112d53acae3d4ce8783d8fd5f396cc45443c010", "patch": "@@ -2331,7 +2331,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public __invoke_result<_Functor, _ArgTypes...>\n     { };\n \n-#if __cplusplus > 201103L\n+#if __cplusplus >= 201402L\n   /// Alias template for aligned_storage\n   template<size_t _Len, size_t _Align =\n \t    __alignof__(typename __aligned_storage_msa<_Len>::__type)>\n@@ -2363,11 +2363,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// Alias template for result_of\n   template<typename _Tp>\n     using result_of_t = typename result_of<_Tp>::type;\n-#endif\n+#endif // C++14\n \n+  // __enable_if_t (std::enable_if_t for C++11)\n+  template<bool _Cond, typename _Tp = void>\n+    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;\n+\n+  // __void_t (std::void_t for C++11)\n   template<typename...> using __void_t = void;\n \n-#if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n+#if __cplusplus >= 201703L || !defined(__STRICT_ANSI__) // c++17 or gnu++11\n #define __cpp_lib_void_t 201411\n   /// A metafunction that always yields void, used for detecting valid types.\n   template<typename...> using void_t = void;"}, {"sha": "e6093afcfe8d1db55f09cbb45606bea8d8fa2ac5", "filename": "libstdc++-v3/testsuite/28_regex/sub_match/compare.cc", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e112d53acae3d4ce8783d8fd5f396cc45443c010/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fsub_match%2Fcompare.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e112d53acae3d4ce8783d8fd5f396cc45443c010/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fsub_match%2Fcompare.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fsub_match%2Fcompare.cc?ref=e112d53acae3d4ce8783d8fd5f396cc45443c010", "patch": "@@ -0,0 +1,303 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+\n+template<typename C> struct traits : std::char_traits<C> { };\n+\n+void\n+test01()\n+{\n+  const std::basic_string<char, traits<char>> s0, s1 = \"1\";\n+  const std::ssub_match sm, sm2;\n+\n+  VERIFY( sm.compare(sm) == 0 );\n+  VERIFY( sm.compare(sm2) == 0 );\n+  VERIFY( sm.compare(sm.str()) == 0 );\n+  VERIFY( sm.compare(sm.str().c_str()) == 0 );\n+  VERIFY( sm.compare(sm2.str()) == 0 );\n+  VERIFY( sm.compare(sm2.str().c_str()) == 0 );\n+  VERIFY( sm.compare(std::string(s1.c_str())) == -1 );\n+  VERIFY( sm.compare(s1.c_str()) == -1 );\n+\n+  VERIFY( sm == sm2 );\n+  VERIFY( !(sm != sm2) );\n+  VERIFY( !(sm < sm2) );\n+  VERIFY( !(sm > sm2) );\n+  VERIFY( sm <= sm2 );\n+  VERIFY( sm >= sm2 );\n+\n+  VERIFY( sm == s0 );\n+  VERIFY( !(sm != s0) );\n+  VERIFY( !(sm < s0) );\n+  VERIFY( !(sm > s0) );\n+  VERIFY( sm <= s0 );\n+  VERIFY( sm >= s0 );\n+\n+  VERIFY( s0 == sm );\n+  VERIFY( !(s0 != sm) );\n+  VERIFY( !(s0 < sm) );\n+  VERIFY( !(s0 > sm) );\n+  VERIFY( s0 <= sm );\n+  VERIFY( s0 >= sm );\n+\n+  VERIFY( sm == s0.c_str() );\n+  VERIFY( !(sm != s0.c_str()) );\n+  VERIFY( !(sm < s0.c_str()) );\n+  VERIFY( !(sm > s0.c_str()) );\n+  VERIFY( sm <= s0.c_str() );\n+  VERIFY( sm >= s0.c_str() );\n+\n+  VERIFY( s0.c_str() == sm );\n+  VERIFY( !(s0.c_str() != sm) );\n+  VERIFY( !(s0.c_str() < sm) );\n+  VERIFY( !(s0.c_str() > sm) );\n+  VERIFY( s0.c_str() <= sm );\n+  VERIFY( s0.c_str() >= sm );\n+\n+  VERIFY( !(sm == s1) );\n+  VERIFY( sm != s1 );\n+  VERIFY( sm < s1 );\n+  VERIFY( !(sm > s1) );\n+  VERIFY( sm <= s1 );\n+  VERIFY( !(sm >= s1) );\n+\n+  VERIFY( !(sm == s1.c_str()) );\n+  VERIFY( sm != s1.c_str() );\n+  VERIFY( sm < s1.c_str() );\n+  VERIFY( !(sm > s1.c_str()) );\n+  VERIFY( sm <= s1.c_str() );\n+  VERIFY( !(sm >= s1.c_str()) );\n+\n+  VERIFY( !(s1.c_str() == sm) );\n+  VERIFY( s1.c_str() != sm );\n+  VERIFY( !(s1.c_str() < sm) );\n+  VERIFY( s1.c_str() > sm );\n+  VERIFY( !(s1.c_str() <= sm) );\n+  VERIFY( s1.c_str() >= sm );\n+\n+  VERIFY( !(sm == s1[0]) );\n+  VERIFY( sm != s1[0] );\n+  VERIFY( sm < s1[0] );\n+  VERIFY( !(sm > s1[0]) );\n+  VERIFY( sm <= s1[0] );\n+  VERIFY( !(sm >= s1[0]) );\n+\n+  VERIFY( !(s1[0] == sm) );\n+  VERIFY( s1[0] != sm );\n+  VERIFY( !(s1[0] < sm) );\n+  VERIFY( s1[0] > sm );\n+  VERIFY( !(s1[0] <= sm) );\n+  VERIFY( s1[0] >= sm );\n+}\n+\n+void\n+test02()\n+{\n+  const std::basic_string<char, traits<char>> s0, s1 = \"1\";\n+  std::csub_match sm;\n+  const std::csub_match sm2;\n+  const char c[] = \"1\";\n+  sm.matched = true;\n+  sm.first = c;\n+  sm.second = c+1;\n+\n+  VERIFY( sm.compare(sm) == 0 );\n+  VERIFY( sm.compare(sm2) == 1 );\n+  VERIFY( sm.compare(sm.str()) == 0 );\n+  VERIFY( sm.compare(sm.str().c_str()) == 0 );\n+  VERIFY( sm.compare(sm2.str()) == 1 );\n+  VERIFY( sm.compare(sm2.str().c_str()) == 1 );\n+  VERIFY( sm.compare(std::string(s1.c_str())) == 0 );\n+  VERIFY( sm.compare(s1.c_str()) == 0 );\n+\n+  VERIFY( !(sm == sm2) );\n+  VERIFY( sm != sm2 );\n+  VERIFY( !(sm < sm2) );\n+  VERIFY( sm > sm2 );\n+  VERIFY( !(sm <= sm2) );\n+  VERIFY( sm >= sm2 );\n+\n+  VERIFY( !(sm2 == sm) );\n+  VERIFY( sm2 != sm );\n+  VERIFY( sm2 < sm );\n+  VERIFY( !(sm2 > sm) );\n+  VERIFY( sm2 <= sm );\n+  VERIFY( !(sm2 >= sm) );\n+\n+  VERIFY( !(sm == s0) );\n+  VERIFY( sm != s0 );\n+  VERIFY( !(sm < s0) );\n+  VERIFY( sm > s0 );\n+  VERIFY( !(sm <= s0) );\n+  VERIFY( sm >= s0 );\n+\n+  VERIFY( !(sm == s0.c_str()) );\n+  VERIFY( sm != s0.c_str() );\n+  VERIFY( !(sm < s0.c_str()) );\n+  VERIFY( sm > s0.c_str() );\n+  VERIFY( !(sm <= s0.c_str()) );\n+  VERIFY( sm >= s0.c_str() );\n+\n+  VERIFY( !(s0.c_str() == sm) );\n+  VERIFY( s0.c_str() != sm );\n+  VERIFY( s0.c_str() < sm );\n+  VERIFY( !(s0.c_str() > sm) );\n+  VERIFY( s0.c_str() <= sm );\n+  VERIFY( !(s0.c_str() >= sm) );\n+\n+  VERIFY( s1 == sm );\n+  VERIFY( !(s1 != sm) );\n+  VERIFY( !(s1 < sm) );\n+  VERIFY( !(s1 > sm) );\n+  VERIFY( s1 <= sm );\n+  VERIFY( s1 >= sm );\n+\n+  VERIFY( sm == s1.c_str() );\n+  VERIFY( !(sm != s1.c_str()) );\n+  VERIFY( !(sm < s1.c_str()) );\n+  VERIFY( !(sm > s1.c_str()) );\n+  VERIFY( sm <= s1.c_str() );\n+  VERIFY( sm >= s1.c_str() );\n+\n+  VERIFY( s1.c_str() == sm );\n+  VERIFY( !(s1.c_str() != sm) );\n+  VERIFY( !(s1.c_str() < sm) );\n+  VERIFY( !(s1.c_str() > sm) );\n+  VERIFY( s1.c_str() <= sm );\n+  VERIFY( s1.c_str() >= sm );\n+\n+  VERIFY( sm == s1[0] );\n+  VERIFY( !(sm != s1[0]) );\n+  VERIFY( !(sm < s1[0]) );\n+  VERIFY( !(sm > s1[0]) );\n+  VERIFY( sm <= s1[0] );\n+  VERIFY( sm >= s1[0] );\n+\n+  VERIFY( s1[0] == sm );\n+  VERIFY( !(s1[0] != sm) );\n+  VERIFY( !(s1[0] < sm) );\n+  VERIFY( !(s1[0] > sm) );\n+  VERIFY( s1[0] <= sm );\n+  VERIFY( s1[0] >= sm );\n+}\n+\n+void\n+test03()\n+{\n+  const std::basic_string<char, traits<char>> s0, s1 = \"1\";\n+  const char c[] = \"1\";\n+  test_container<const char, bidirectional_iterator_wrapper> tc(c, c+1);\n+  std::sub_match<bidirectional_iterator_wrapper<const char>> sm;\n+  const std::sub_match<bidirectional_iterator_wrapper<const char>> sm2;\n+  sm.matched = true;\n+  sm.first = tc.begin();\n+  sm.second = tc.end();\n+\n+  VERIFY( sm.compare(sm) == 0 );\n+  VERIFY( sm.compare(sm2) == 1 );\n+  VERIFY( sm.compare(sm.str()) == 0 );\n+  VERIFY( sm.compare(sm.str().c_str()) == 0 );\n+  VERIFY( sm.compare(sm2.str()) == 1 );\n+  VERIFY( sm.compare(sm2.str().c_str()) == 1 );\n+  VERIFY( sm.compare(std::string(s1.c_str())) == 0 );\n+  VERIFY( sm.compare(s1.c_str()) == 0 );\n+\n+  VERIFY( !(sm == sm2) );\n+  VERIFY( sm != sm2 );\n+  VERIFY( !(sm < sm2) );\n+  VERIFY( sm > sm2 );\n+  VERIFY( !(sm <= sm2) );\n+  VERIFY( sm >= sm2 );\n+\n+  VERIFY( !(sm2 == sm) );\n+  VERIFY( sm2 != sm );\n+  VERIFY( sm2 < sm );\n+  VERIFY( !(sm2 > sm) );\n+  VERIFY( sm2 <= sm );\n+  VERIFY( !(sm2 >= sm) );\n+\n+  VERIFY( !(sm == s0) );\n+  VERIFY( sm != s0 );\n+  VERIFY( !(sm < s0) );\n+  VERIFY( sm > s0 );\n+  VERIFY( !(sm <= s0) );\n+  VERIFY( sm >= s0 );\n+\n+  VERIFY( !(sm == s0.c_str()) );\n+  VERIFY( sm != s0.c_str() );\n+  VERIFY( !(sm < s0.c_str()) );\n+  VERIFY( sm > s0.c_str() );\n+  VERIFY( !(sm <= s0.c_str()) );\n+  VERIFY( sm >= s0.c_str() );\n+\n+  VERIFY( !(s0.c_str() == sm) );\n+  VERIFY( s0.c_str() != sm );\n+  VERIFY( s0.c_str() < sm );\n+  VERIFY( !(s0.c_str() > sm) );\n+  VERIFY( s0.c_str() <= sm );\n+  VERIFY( !(s0.c_str() >= sm) );\n+\n+  VERIFY( s1 == sm );\n+  VERIFY( !(s1 != sm) );\n+  VERIFY( !(s1 < sm) );\n+  VERIFY( !(s1 > sm) );\n+  VERIFY( s1 <= sm );\n+  VERIFY( s1 >= sm );\n+\n+  VERIFY( sm == s1.c_str() );\n+  VERIFY( !(sm != s1.c_str()) );\n+  VERIFY( !(sm < s1.c_str()) );\n+  VERIFY( !(sm > s1.c_str()) );\n+  VERIFY( sm <= s1.c_str() );\n+  VERIFY( sm >= s1.c_str() );\n+\n+  VERIFY( s1.c_str() == sm );\n+  VERIFY( !(s1.c_str() != sm) );\n+  VERIFY( !(s1.c_str() < sm) );\n+  VERIFY( !(s1.c_str() > sm) );\n+  VERIFY( s1.c_str() <= sm );\n+  VERIFY( s1.c_str() >= sm );\n+\n+  VERIFY( sm == s1[0] );\n+  VERIFY( !(sm != s1[0]) );\n+  VERIFY( !(sm < s1[0]) );\n+  VERIFY( !(sm > s1[0]) );\n+  VERIFY( sm <= s1[0] );\n+  VERIFY( sm >= s1[0] );\n+\n+  VERIFY( s1[0] == sm );\n+  VERIFY( !(s1[0] != sm) );\n+  VERIFY( !(s1[0] < sm) );\n+  VERIFY( !(s1[0] > sm) );\n+  VERIFY( s1[0] <= sm );\n+  VERIFY( s1[0] >= sm );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "4100514879d348e2da6c395b01ba9d15f540d143", "filename": "libstdc++-v3/testsuite/util/testsuite_iterators.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e112d53acae3d4ce8783d8fd5f396cc45443c010/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_iterators.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e112d53acae3d4ce8783d8fd5f396cc45443c010/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_iterators.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_iterators.h?ref=e112d53acae3d4ce8783d8fd5f396cc45443c010", "patch": "@@ -185,6 +185,11 @@ namespace __gnu_test\n     void operator,(const T&, const output_iterator_wrapper<U>&) = delete;\n #endif\n \n+  template<typename T> struct remove_cv { typedef T type; };\n+  template<typename T> struct remove_cv<const T> { typedef T type; };\n+  template<typename T> struct remove_cv<volatile T> { typedef T type; };\n+  template<typename T> struct remove_cv<const volatile T> { typedef T type; };\n+\n   /**\n    * @brief input_iterator wrapper for pointer\n    *\n@@ -194,7 +199,8 @@ namespace __gnu_test\n    */\n   template<class T>\n   class input_iterator_wrapper\n-  : public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T&>\n+  : public std::iterator<std::input_iterator_tag, typename remove_cv<T>::type,\n+\t\t\t std::ptrdiff_t, T*, T&>\n   {\n   protected:\n     input_iterator_wrapper()"}]}