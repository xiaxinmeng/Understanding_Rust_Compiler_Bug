{"sha": "5acef69f9d3d9f3c537b5e5157519edf02f86c4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFjZWY2OWY5ZDNkOWYzYzUzN2I1ZTUxNTc1MTllZGYwMmY4NmM0ZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-07-09T10:07:17Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-07-09T10:07:17Z"}, "message": "openmp: Optimize triangular loop logical iterator to actual iterators computation using search for quadratic equation root(s)\n\nThis patch implements the optimized logical to actual iterators\ncomputation for triangular loops.\n\nI have a rough implementation using integers, but this one uses floating\npoint.  There is a small problem that -fopenmp programs aren't linked with\n-lm, so it does it only if the hw has sqrt optab (and uses ifn rather than\n__builtin_sqrt because it obviously doesn't need errno handling etc.).\n\nDo you think it is ok this way, or should I use the integral computation\nusing inlined isqrt (we have inequation of the form\nstart >= x * t10 + t11 * (((x - 1) * x) / 2)\nwhere t10 and t11 are signed long long values and start unsigned long long,\nand the division by 2 actually is a problem for accuracy in some cases, so\nif we do it in integral, we need to do actually\n      long long t12 = 2 * t10 - t11;\n      unsigned long long t13 = t12 * t12 + start * 8 * t11;\n      unsigned long long isqrt_ = isqrtull (t13);\n      long long x = (((long long) isqrt_ - t12) / t11) >> 1;\nwith careful overflow checking on all the computations before isqrtull\n(and on overflows use the fallback implementation).\n\n2020-07-09  Jakub Jelinek  <jakub@redhat.com>\n\n\t* omp-general.h (struct omp_for_data): Add min_inner_iterations\n\tand factor members.\n\t* omp-general.c (omp_extract_for_data): Initialize them and remember\n\tthem in OMP_CLAUSE_COLLAPSE_COUNT if needed and restore from there.\n\t* omp-expand.c (expand_omp_for_init_counts): Fix up computation of\n\tcounts[fd->last_nonrect] if fd->loop.n2 is INTEGER_CST.\n\t(expand_omp_for_init_vars): For\n\tfd->first_nonrect + 1 == fd->last_nonrect loops with for now\n\tINTEGER_CST fd->loop.n2 find quadratic equation roots instead of\n\tusing fallback method when possible.\n\n\t* testsuite/libgomp.c/loop-19.c: New test.\n\t* testsuite/libgomp.c/loop-20.c: New test.", "tree": {"sha": "af18107dc1e787b46c735b2eea3fad74d6b091a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af18107dc1e787b46c735b2eea3fad74d6b091a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5acef69f9d3d9f3c537b5e5157519edf02f86c4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5acef69f9d3d9f3c537b5e5157519edf02f86c4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5acef69f9d3d9f3c537b5e5157519edf02f86c4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5acef69f9d3d9f3c537b5e5157519edf02f86c4d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea82325afeccf3604f393916832eaadcbe1225bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea82325afeccf3604f393916832eaadcbe1225bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea82325afeccf3604f393916832eaadcbe1225bd"}], "stats": {"total": 411, "additions": 404, "deletions": 7}, "files": [{"sha": "c3b8820e2137531bf872e2aae0be225263642e56", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 205, "deletions": 6, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5acef69f9d3d9f3c537b5e5157519edf02f86c4d/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5acef69f9d3d9f3c537b5e5157519edf02f86c4d/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=5acef69f9d3d9f3c537b5e5157519edf02f86c4d", "patch": "@@ -2137,7 +2137,7 @@ expand_omp_for_init_counts (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n       int non_rect_referenced = 0, non_rect = 0;\n       for (i = 0; i < fd->collapse; i++)\n \t{\n-\t  if ((i < fd->first_nonrect || fd->last_nonrect)\n+\t  if ((i < fd->first_nonrect || i > fd->last_nonrect)\n \t      && !integer_zerop (counts[i]))\n \t    t = fold_build2 (TRUNC_DIV_EXPR, type, t, counts[i]);\n \t  if (fd->loops[i].non_rect_referenced)\n@@ -2249,17 +2249,208 @@ expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \tt = tem;\n       if (i == fd->last_nonrect)\n \t{\n-\t  /* Fallback implementation.  Evaluate the loops in between\n-\t     (inclusive) fd->first_nonrect and fd->last_nonrect at\n-\t     runtime unsing temporaries instead of the original iteration\n-\t     variables, in the body just bump the counter and compare\n-\t     with the desired value.  */\n \t  t = force_gimple_operand_gsi (gsi, t, true, NULL_TREE,\n \t\t\t\t\tfalse, GSI_CONTINUE_LINKING);\n \t  tree stopval = t;\n \t  tree idx = create_tmp_reg (type, \".count\");\n \t  expand_omp_build_assign (gsi, idx,\n \t\t\t\t   build_zero_cst (type), true);\n+\t  basic_block bb_triang = NULL;\n+\t  if (fd->first_nonrect + 1 == fd->last_nonrect\n+\t      /* For now.  */\n+\t      && TREE_CODE (fd->loop.n2) == INTEGER_CST\n+\t      && (optab_handler (sqrt_optab, TYPE_MODE (double_type_node))\n+\t\t  != CODE_FOR_nothing))\n+\t    {\n+\t      tree itype = TREE_TYPE (fd->loops[i].v);\n+\t      tree min_inner_iterations = fd->min_inner_iterations;\n+\t      tree factor = fd->factor;\n+\t      gcond *cond_stmt\n+\t\t= gimple_build_cond (NE_EXPR, factor,\n+\t\t\t\t     build_zero_cst (TREE_TYPE (factor)),\n+\t\t\t\t     NULL_TREE, NULL_TREE);\n+\t      gsi_insert_after (gsi, cond_stmt, GSI_CONTINUE_LINKING);\n+\t      edge e = split_block (gsi_bb (*gsi), cond_stmt);\n+\t      basic_block bb0 = e->src;\n+\t      e->flags = EDGE_TRUE_VALUE;\n+\t      e->probability = profile_probability::likely ();\n+\t      *gsi = gsi_after_labels (e->dest);\n+\t      tree slltype = long_long_integer_type_node;\n+\t      tree ulltype = long_long_unsigned_type_node;\n+\t      tree stopvalull = fold_convert (ulltype, stopval);\n+\t      stopvalull\n+\t\t= force_gimple_operand_gsi (gsi, stopvalull, true, NULL_TREE,\n+\t\t\t\t\t    false, GSI_CONTINUE_LINKING);\n+\t      min_inner_iterations\n+\t\t= fold_convert (slltype, min_inner_iterations);\n+\t      min_inner_iterations\n+\t\t= force_gimple_operand_gsi (gsi, min_inner_iterations, true,\n+\t\t\t\t\t    NULL_TREE, false,\n+\t\t\t\t\t    GSI_CONTINUE_LINKING);\n+\t      factor = fold_convert (slltype, factor);\n+\t      factor\n+\t\t= force_gimple_operand_gsi (gsi, factor, true, NULL_TREE,\n+\t\t\t\t\t    false, GSI_CONTINUE_LINKING);\n+\t      tree min_inner_iterationsd\n+\t\t= fold_build1 (FLOAT_EXPR, double_type_node,\n+\t\t\t       min_inner_iterations);\n+\t      min_inner_iterationsd\n+\t\t= force_gimple_operand_gsi (gsi, min_inner_iterationsd, true,\n+\t\t\t\t\t    NULL_TREE, false,\n+\t\t\t\t\t    GSI_CONTINUE_LINKING);\n+\t      tree factord = fold_build1 (FLOAT_EXPR, double_type_node,\n+\t\t\t\t\t  factor);\n+\t      factord = force_gimple_operand_gsi (gsi, factord, true,\n+\t\t\t\t\t\t  NULL_TREE, false,\n+\t\t\t\t\t\t  GSI_CONTINUE_LINKING);\n+\t      tree stopvald = fold_build1 (FLOAT_EXPR, double_type_node,\n+\t\t\t\t\t   stopvalull);\n+\t      stopvald = force_gimple_operand_gsi (gsi, stopvald, true,\n+\t\t\t\t\t\t   NULL_TREE, false,\n+\t\t\t\t\t\t   GSI_CONTINUE_LINKING);\n+\t      /* Temporarily disable flag_rounding_math, values will be\n+\t\t decimal numbers divided by 2 and worst case imprecisions\n+\t\t due to too large values ought to be caught later by the\n+\t\t checks for fallback.  */\n+\t      int save_flag_rounding_math = flag_rounding_math;\n+\t      flag_rounding_math = 0;\n+\t      t = fold_build2 (RDIV_EXPR, double_type_node, factord,\n+\t\t\t       build_real (double_type_node, dconst2));\n+\t      tree t3 = fold_build2 (MINUS_EXPR, double_type_node,\n+\t\t\t\t     min_inner_iterationsd, t);\n+\t      t3 = force_gimple_operand_gsi (gsi, t3, true, NULL_TREE, false,\n+\t\t\t\t\t     GSI_CONTINUE_LINKING);\n+\t      t = fold_build2 (MULT_EXPR, double_type_node, factord,\n+\t\t\t       build_real (double_type_node, dconst2));\n+\t      t = fold_build2 (MULT_EXPR, double_type_node, t, stopvald);\n+\t      t = fold_build2 (PLUS_EXPR, double_type_node, t,\n+\t\t\t       fold_build2 (MULT_EXPR, double_type_node,\n+\t\t\t\t\t    t3, t3));\n+\t      flag_rounding_math = save_flag_rounding_math;\n+\t      t = force_gimple_operand_gsi (gsi, t, true, NULL_TREE, false,\n+\t\t\t\t\t    GSI_CONTINUE_LINKING);\n+\t      cond_stmt\n+\t\t= gimple_build_cond (LT_EXPR, t,\n+\t\t\t\t     build_zero_cst (double_type_node),\n+\t\t\t\t     NULL_TREE, NULL_TREE);\n+\t      gsi_insert_after (gsi, cond_stmt, GSI_CONTINUE_LINKING);\n+\t      e = split_block (gsi_bb (*gsi), cond_stmt);\n+\t      basic_block bb1 = e->src;\n+\t      e->flags = EDGE_FALSE_VALUE;\n+\t      e->probability = profile_probability::very_likely ();\n+\t      *gsi = gsi_after_labels (e->dest);\n+\t      gcall *call = gimple_build_call_internal (IFN_SQRT, 1, t);\n+\t      tree sqrtr = create_tmp_var (double_type_node);\n+\t      gimple_call_set_lhs (call, sqrtr);\n+\t      gsi_insert_after (gsi, call, GSI_CONTINUE_LINKING);\n+\t      t = fold_build2 (MINUS_EXPR, double_type_node, sqrtr, t3);\n+\t      t = fold_build2 (RDIV_EXPR, double_type_node, t, factord);\n+\t      t = fold_build1 (FIX_TRUNC_EXPR, ulltype, t);\n+\t      tree c = create_tmp_var (ulltype);\n+\t      tree d = create_tmp_var (ulltype);\n+\t      expand_omp_build_assign (gsi, c, t, true);\n+\t      t = fold_build2 (MINUS_EXPR, ulltype, c,\n+\t\t\t       build_one_cst (ulltype));\n+\t      t = fold_build2 (MULT_EXPR, ulltype, c, t);\n+\t      t = fold_build2 (RSHIFT_EXPR, ulltype, t, integer_one_node);\n+\t      t = fold_build2 (MULT_EXPR, ulltype, fd->factor, t);\n+\t      tree t2 = fold_build2 (MULT_EXPR, ulltype, c,\n+\t\t\t\t     fd->min_inner_iterations);\n+\t      t = fold_build2 (PLUS_EXPR, ulltype, t, t2);\n+\t      expand_omp_build_assign (gsi, d, t, true);\n+\t      t = fold_build2 (MULT_EXPR, ulltype, fd->factor, c);\n+\t      t = fold_build2 (PLUS_EXPR, ulltype,\n+\t\t\t       t, fd->min_inner_iterations);\n+\t      t2 = force_gimple_operand_gsi (gsi, t, true, NULL_TREE, false,\n+\t\t\t\t\t     GSI_CONTINUE_LINKING);\n+\t      cond_stmt = gimple_build_cond (GE_EXPR, stopvalull, d,\n+\t\t\t\t\t     NULL_TREE, NULL_TREE);\n+\t      gsi_insert_after (gsi, cond_stmt, GSI_CONTINUE_LINKING);\n+\t      e = split_block (gsi_bb (*gsi), cond_stmt);\n+\t      basic_block bb2 = e->src;\n+\t      e->flags = EDGE_TRUE_VALUE;\n+\t      e->probability = profile_probability::very_likely ();\n+\t      *gsi = gsi_after_labels (e->dest);\n+\t      t = fold_build2 (PLUS_EXPR, ulltype, d, t2);\n+\t      t = force_gimple_operand_gsi (gsi, t, true, NULL_TREE, false,\n+\t\t\t\t\t    GSI_CONTINUE_LINKING);\n+\t      cond_stmt = gimple_build_cond (GE_EXPR, stopvalull, t,\n+\t\t\t\t\t     NULL_TREE, NULL_TREE);\n+\t      gsi_insert_after (gsi, cond_stmt, GSI_CONTINUE_LINKING);\n+\t      e = split_block (gsi_bb (*gsi), cond_stmt);\n+\t      basic_block bb3 = e->src;\n+\t      e->flags = EDGE_FALSE_VALUE;\n+\t      e->probability = profile_probability::very_likely ();\n+\t      *gsi = gsi_after_labels (e->dest);\n+\t      t = fold_convert (itype, c);\n+\t      t = fold_build2 (MULT_EXPR, itype, t, fd->loops[i - 1].step);\n+\t      t = fold_build2 (PLUS_EXPR, itype, fd->loops[i - 1].n1, t);\n+\t      t = force_gimple_operand_gsi (gsi, t, true, NULL_TREE, false,\n+\t\t\t\t\t    GSI_CONTINUE_LINKING);\n+\t      expand_omp_build_assign (gsi, fd->loops[i - 1].v, t, true);\n+\t      t2 = fold_build2 (MINUS_EXPR, ulltype, stopvalull, d);\n+\t      t2 = fold_convert (itype, t2);\n+\t      t2 = fold_build2 (MULT_EXPR, itype, t2, fd->loops[i].step);\n+\t      t2 = fold_build2 (PLUS_EXPR, itype, t2, fd->loops[i].n1);\n+\t      if (fd->loops[i].m1)\n+\t\t{\n+\t\t  t = fold_build2 (MULT_EXPR, itype, t, fd->loops[i].m1);\n+\t\t  t2 = fold_build2 (PLUS_EXPR, itype, t2, t);\n+\t\t}\n+\t      expand_omp_build_assign (gsi, fd->loops[i].v, t2, true);\n+\t      e = split_block (gsi_bb (*gsi), gsi_stmt (*gsi));\n+\t      bb_triang = e->src;\n+\t      *gsi = gsi_after_labels (e->dest);\n+\t      remove_edge (e);\n+\t      e = make_edge (bb1, gsi_bb (*gsi), EDGE_TRUE_VALUE);\n+\t      e->probability = profile_probability::very_unlikely ();\n+\t      e = make_edge (bb2, gsi_bb (*gsi), EDGE_FALSE_VALUE);\n+\t      e->probability = profile_probability::very_unlikely ();\n+\t      e = make_edge (bb3, gsi_bb (*gsi), EDGE_TRUE_VALUE);\n+\t      e->probability = profile_probability::very_unlikely ();\n+\n+\t      basic_block bb4 = create_empty_bb (bb0);\n+\t      add_bb_to_loop (bb4, bb0->loop_father);\n+\t      e = make_edge (bb0, bb4, EDGE_FALSE_VALUE);\n+\t      e->probability = profile_probability::unlikely ();\n+\t      make_edge (bb4, gsi_bb (*gsi), EDGE_FALLTHRU);\n+\t      set_immediate_dominator (CDI_DOMINATORS, bb4, bb0);\n+\t      set_immediate_dominator (CDI_DOMINATORS, gsi_bb (*gsi), bb0);\n+\t      gimple_stmt_iterator gsi2 = gsi_after_labels (bb4);\n+\t      t2 = fold_build2 (TRUNC_DIV_EXPR, type,\n+\t\t\t\tcounts[i], counts[i - 1]);\n+\t      t2 = force_gimple_operand_gsi (&gsi2, t2, true, NULL_TREE, false,\n+\t\t\t\t\t     GSI_CONTINUE_LINKING);\n+\t      t = fold_build2 (TRUNC_MOD_EXPR, type, stopval, t2);\n+\t      t2 = fold_build2 (TRUNC_DIV_EXPR, type, stopval, t2);\n+\t      t = fold_convert (itype, t);\n+\t      t2 = fold_convert (itype, t2);\n+\t      t = fold_build2 (MULT_EXPR, itype, t,\n+\t\t\t       fold_convert (itype, fd->loops[i].step));\n+\t      t = fold_build2 (PLUS_EXPR, itype, fd->loops[i].n1, t);\n+\t      t2 = fold_build2 (MULT_EXPR, itype, t2,\n+\t\t\t\tfold_convert (itype, fd->loops[i - 1].step));\n+\t      t2 = fold_build2 (PLUS_EXPR, itype, fd->loops[i - 1].n1, t2);\n+\t      t2 = force_gimple_operand_gsi (&gsi2, t2, false, NULL_TREE,\n+\t\t\t\t\t     false, GSI_CONTINUE_LINKING);\n+\t      stmt = gimple_build_assign (fd->loops[i - 1].v, t2);\n+\t      gsi_insert_after (&gsi2, stmt, GSI_CONTINUE_LINKING);\n+\t      if (fd->loops[i].m1)\n+\t\t{\n+\t\t  t2 = fold_build2 (MULT_EXPR, itype, fd->loops[i].m1,\n+\t\t\t\t    fd->loops[i - 1].v);\n+\t\t  t = fold_build2 (PLUS_EXPR, itype, t, t2);\n+\t\t}\n+\t      t = force_gimple_operand_gsi (&gsi2, t, false, NULL_TREE,\n+\t\t\t\t\t    false, GSI_CONTINUE_LINKING);\n+\t      stmt = gimple_build_assign (fd->loops[i].v, t);\n+\t      gsi_insert_after (&gsi2, stmt, GSI_CONTINUE_LINKING);\n+\t    }\n+\t  /* Fallback implementation.  Evaluate the loops in between\n+\t     (inclusive) fd->first_nonrect and fd->last_nonrect at\n+\t     runtime unsing temporaries instead of the original iteration\n+\t     variables, in the body just bump the counter and compare\n+\t     with the desired value.  */\n \t  gimple_stmt_iterator gsi2 = *gsi;\n \t  basic_block entry_bb = gsi_bb (gsi2);\n \t  edge e = split_block (entry_bb, gsi_stmt (gsi2));\n@@ -2455,6 +2646,14 @@ expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t    *gsi = gsi_last_bb (gsi_bb (*gsi));\n \t  else\n \t    gsi_prev (gsi);\n+\t  if (bb_triang)\n+\t    {\n+\t      e = split_block (gsi_bb (*gsi), gsi_stmt (*gsi));\n+\t      make_edge (bb_triang, e->dest, EDGE_FALLTHRU);\n+\t      *gsi = gsi_after_labels (e->dest);\n+\t      if (!gsi_end_p (*gsi))\n+\t\tgsi_insert_before (gsi, gimple_build_nop (), GSI_NEW_STMT);\n+\t    }\n \t}\n       else\n \t{"}, {"sha": "c6878cfec66a202f10c4b7bc0a035f941d5e3f77", "filename": "gcc/omp-general.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5acef69f9d3d9f3c537b5e5157519edf02f86c4d/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5acef69f9d3d9f3c537b5e5157519edf02f86c4d/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=5acef69f9d3d9f3c537b5e5157519edf02f86c4d", "patch": "@@ -212,6 +212,8 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n   fd->sched_modifiers = 0;\n   fd->chunk_size = NULL_TREE;\n   fd->simd_schedule = false;\n+  fd->min_inner_iterations = NULL_TREE;\n+  fd->factor = NULL_TREE;\n   collapse_iter = NULL;\n   collapse_count = NULL;\n \n@@ -653,6 +655,8 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \t\t  else\n \t\t    t2 = fold_build2 (TRUNC_DIV_EXPR, itype, t2, step);\n \t\t  t2 = fold_convert (llutype, t2);\n+\t\t  fd->min_inner_iterations = t;\n+\t\t  fd->factor = t2;\n \t\t  t = fold_build2 (MULT_EXPR, llutype, t,\n \t\t\t\t   single_nonrect_count);\n \t\t  tree t3 = fold_build2 (MINUS_EXPR, llutype,\n@@ -707,7 +711,17 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n   if (collapse_count && *collapse_count == NULL)\n     {\n       if (count)\n-\t*collapse_count = fold_convert_loc (loc, iter_type, count);\n+\t{\n+\t  *collapse_count = fold_convert_loc (loc, iter_type, count);\n+\t  if (fd->min_inner_iterations && fd->factor)\n+\t    {\n+\t      t = make_tree_vec (3);\n+\t      TREE_VEC_ELT (t, 0) = *collapse_count;\n+\t      TREE_VEC_ELT (t, 1) = fd->min_inner_iterations;\n+\t      TREE_VEC_ELT (t, 2) = fd->factor;\n+\t      *collapse_count = t;\n+\t    }\n+\t}\n       else\n \t*collapse_count = create_tmp_var (iter_type, \".count\");\n     }\n@@ -717,6 +731,13 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n       fd->loop.v = *collapse_iter;\n       fd->loop.n1 = build_int_cst (TREE_TYPE (fd->loop.v), 0);\n       fd->loop.n2 = *collapse_count;\n+      if (TREE_CODE (fd->loop.n2) == TREE_VEC)\n+\t{\n+\t  gcc_assert (fd->non_rect);\n+\t  fd->min_inner_iterations = TREE_VEC_ELT (fd->loop.n2, 1);\n+\t  fd->factor = TREE_VEC_ELT (fd->loop.n2, 2);\n+\t  fd->loop.n2 = TREE_VEC_ELT (fd->loop.n2, 0);\n+\t}\n       fd->loop.step = build_int_cst (TREE_TYPE (fd->loop.v), 1);\n       fd->loop.m1 = NULL_TREE;\n       fd->loop.m2 = NULL_TREE;"}, {"sha": "ec0f2a4becb28cf030763bd04c55ccd89356d24f", "filename": "gcc/omp-general.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5acef69f9d3d9f3c537b5e5157519edf02f86c4d/gcc%2Fomp-general.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5acef69f9d3d9f3c537b5e5157519edf02f86c4d/gcc%2Fomp-general.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.h?ref=5acef69f9d3d9f3c537b5e5157519edf02f86c4d", "patch": "@@ -78,6 +78,13 @@ struct omp_for_data\n   unsigned char sched_modifiers;\n   enum omp_clause_schedule_kind sched_kind;\n   struct omp_for_data_loop *loops;\n+  /* The following are relevant only for non-rectangular loops\n+     where only a single loop depends on an outer loop iterator.  */\n+  tree min_inner_iterations; /* Number of iterations of the inner\n+\t\t\t\tloop with either the first or last\n+\t\t\t\touter iterator, depending on which\n+\t\t\t\tresults in fewer iterations.  */\n+  tree factor; /* (m2 - m1) * outer_step / inner_step.  */\n };\n \n #define OACC_FN_ATTRIB \"oacc function\""}, {"sha": "732ebb04153d93556f45020351a2f52681c062f1", "filename": "libgomp/testsuite/libgomp.c/loop-19.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5acef69f9d3d9f3c537b5e5157519edf02f86c4d/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5acef69f9d3d9f3c537b5e5157519edf02f86c4d/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-19.c?ref=5acef69f9d3d9f3c537b5e5157519edf02f86c4d", "patch": "@@ -0,0 +1,86 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+\n+int x, i, j;\n+volatile int a, b, c, d, e, f, g, h;\n+int k[16][67];\n+\n+int\n+main ()\n+{\n+  int niters;\n+  for (i = 0; i < 16; i++)\n+    for (j = i * 2 + 1; j < 4 * i + 3; j++)\n+      k[i][j] = 1;\n+  a = 0; b = 16; c = 1; d = 2; e = 1; f = 4; g = 3; h = 1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = 0; i < 16; i++)\n+    for (j = i * 2 + 1; j < 4 * i + 3; j++)\n+      {\n+\tif (i < 0 || i >= 16 || j < 2 * i + 1 || j >= 3 + i * 4 || k[i][j] != 1)\n+\t  abort ();\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 16 || j != 63 || x != 15422 || niters != 272)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\tif (i < 0 || i >= 16 || j < 2 * i + 1 || j >= 3 + i * 4 || k[i][j] != 2)\n+\t  abort ();\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 16 || j != 63 || x != 15422 || niters != 272)\n+    abort ();\n+  for (i = 0; i < 16; i++)\n+    for (j = i * 2 + 1; j < 4 * i + 3; j++)\n+      if (k[i][j] == 3)\n+\tk[i][j] = 0;\n+      else\n+\tabort ();\n+  for (i = 0; i < 16; i++)\n+    for (j = i * 2 + 1; j < 2 * i + 7; j++)\n+      k[i][j] = 1;\n+  a = 0; b = 16; c = 1; d = 2; e = 1; f = 2; g = 7; h = 1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = 0; i < 16; i++)\n+    for (j = i * 2 + 1; j < 2 * i + 7; j++)\n+      {\n+\tif (i < 0 || i >= 16 || j < 2 * i + 1 || j >= 7 + i * 2 || k[i][j] != 1)\n+\t  abort ();\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 16 || j != 37 || x != 15396 || niters != 96)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\tif (i < 0 || i >= 16 || j < 2 * i + 1 || j >= 7 + i * 2 || k[i][j] != 2)\n+\t  abort ();\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 16 || j != 37 || x != 15396 || niters != 96)\n+    abort ();\n+  for (i = 0; i < 16; i++)\n+    for (j = i * 2 + 1; j < 2 * i + 7; j++)\n+      if (k[i][j] == 3)\n+\tk[i][j] = 0;\n+      else\n+\tabort ();\n+  return 0;\n+}"}, {"sha": "c3265ac0470e7a7f097c7d4b3dd9cc1541c2dc75", "filename": "libgomp/testsuite/libgomp.c/loop-20.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5acef69f9d3d9f3c537b5e5157519edf02f86c4d/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5acef69f9d3d9f3c537b5e5157519edf02f86c4d/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-20.c?ref=5acef69f9d3d9f3c537b5e5157519edf02f86c4d", "patch": "@@ -0,0 +1,84 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+\n+unsigned long long int x, i, j;\n+volatile unsigned long long int a, b, c, d, e, f, g, h;\n+int k[4][206];\n+\n+int\n+main ()\n+{\n+  long long int niters;\n+  for (j = ~0ULL / 2 - 32; j < ((~0ULL / 2) + 6); j++)\n+    k[0][j - ~0ULL / 2 + 64] = 1;\n+  a = 1; b = 2; c = 1; d = 0; e = ~0ULL / 2 - 32; f = ((~0ULL / 2) + 6); g = 0; h = 1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = 1; i < 2; i++)\n+    for (j = ~0ULL / 2 - 32; j < i * ((~0ULL / 2) + 6); j++)\n+      {\n+\tif (i != 1 || j < ~0ULL / 2 - 32 || j >= ((~0ULL / 2) + 6) || k[0][j - ~0ULL / 2 + 64] != 1)\n+\t  abort ();\n+\tk[0][j - ~0ULL / 2 + 64]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 2 || j != ((~0ULL / 2) + 6) || x != 1028 || niters != 38)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\tif (i != 1 || j < ~0ULL / 2 - 32 || j >= ((~0ULL / 2) + 6) || k[0][j - ~0ULL / 2 + 64] != 2)\n+\t  abort ();\n+\tk[0][j - ~0ULL / 2 + 64]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 2 || j != ((~0ULL / 2) + 6) || x != 1028 || niters != 38)\n+    abort ();\n+  for (j = ~0ULL / 2 - 32; j < ((~0ULL / 2) + 6); j++)\n+    if (k[0][j - ~0ULL / 2 + 64] == 3)\n+      k[0][j - ~0ULL / 2 + 64] = 0;\n+    else\n+      abort ();\n+  for (i = 1; i < 4; i++)\n+    for (j = 64ULL * i; j < i * 32ULL + 110; j++)\n+      k[i][j] = 1;\n+  a = 1; b = 4; c = 1; d = 64ULL; e = 0; f = 32ULL; g = 110ULL; h = 1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = 1; i < 4; i++)\n+    for (j = 64ULL * i; j < i * 32ULL + 110; j++)\n+      {\n+\tif (i < 1 || i >= 4 || j < 64ULL * i || j >= i * 32ULL + 110 || k[i][j] != 1)\n+\t  abort ();\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 4 || j != 206 || x != 3277 || niters != 138)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\tif (i < 1 || i >= 4 || j < 64ULL * i || j >= i * 32ULL + 110 || k[i][j] != 2)\n+\t  abort ();\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 4 || j != 206 || x != 3277 || niters != 138)\n+    abort ();\n+  for (i = 1; i < 4; i++)\n+    for (j = 64ULL * i; j < i * 32ULL + 110; j++)\n+      if (k[i][j] == 3)\n+\tk[i][j] = 0;\n+      else\n+\tabort ();\n+  return 0;\n+}"}]}