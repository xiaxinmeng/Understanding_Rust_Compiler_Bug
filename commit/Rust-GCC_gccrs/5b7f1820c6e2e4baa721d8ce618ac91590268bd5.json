{"sha": "5b7f1820c6e2e4baa721d8ce618ac91590268bd5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI3ZjE4MjBjNmUyZTRiYWE3MjFkOGNlNjE4YWM5MTU5MDI2OGJkNQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-11T04:52:53Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-11T04:52:53Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r433", "tree": {"sha": "241872eb9c99ce6412516e958a1d3ef3d2ed2499", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/241872eb9c99ce6412516e958a1d3ef3d2ed2499"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b7f1820c6e2e4baa721d8ce618ac91590268bd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b7f1820c6e2e4baa721d8ce618ac91590268bd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b7f1820c6e2e4baa721d8ce618ac91590268bd5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b7f1820c6e2e4baa721d8ce618ac91590268bd5/comments", "author": null, "committer": null, "parents": [{"sha": "d1b765a51af88ac39a98fb0b1364a785006cb2be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1b765a51af88ac39a98fb0b1364a785006cb2be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1b765a51af88ac39a98fb0b1364a785006cb2be"}], "stats": {"total": 60, "additions": 54, "deletions": 6}, "files": [{"sha": "ebc7443cff367da89a0eb71fe2bcb1dade4831a1", "filename": "gcc/sdbout.c", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b7f1820c6e2e4baa721d8ce618ac91590268bd5/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b7f1820c6e2e4baa721d8ce618ac91590268bd5/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=5b7f1820c6e2e4baa721d8ce618ac91590268bd5", "patch": "@@ -1,5 +1,5 @@\n /* Output sdb-format symbol table information from GNU compiler.\n-   Copyright (C) 1988-1990 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 1992 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -51,7 +51,7 @@ AT&T C compiler.  From the example below I would conclude the following:\n #include \"insn-config.h\"\n #include \"reload.h\"\n \n-/* Mips systems use the SDB functions to dump out it's symbols, but\n+/* Mips systems use the SDB functions to dump out symbols, but\n    do not supply usable syms.h include files.  */\n #if defined(USG) && !defined(MIPS)\n #include <syms.h>\n@@ -405,8 +405,9 @@ sdbout_record_type_name (type)\n \t{\n \t  t = TYPE_NAME (type);\n \t}\n-#if 0  /* Don't use typedef names.  */\n-      else if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL)\n+#if 1  /* As a temprary hack, use typedef names for C++ only.  */\n+      else if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+\t       && TYPE_LANG_SPECIFIC (type))\n \t{\n \t  t = DECL_NAME (TYPE_NAME (type));\n \t}\n@@ -575,7 +576,8 @@ sdbout_syms (syms)\n {\n   while (syms)\n     {\n-      sdbout_symbol (syms, 1);\n+      if (TREE_CODE (syms) != LABEL_DECL)\n+\tsdbout_symbol (syms, 1);\n       syms = TREE_CHAIN (syms);\n     }\n }\n@@ -724,7 +726,8 @@ sdbout_symbol (decl, local)\n       else if (GET_CODE (value) == MEM\n \t       && (GET_CODE (XEXP (value, 0)) == MEM\n \t\t   || (GET_CODE (XEXP (value, 0)) == REG\n-\t\t       && REGNO (XEXP (value, 0)) != FRAME_POINTER_REGNUM)))\n+\t\t       && REGNO (XEXP (value, 0)) != FRAME_POINTER_REGNUM\n+\t\t       && REGNO (XEXP (value, 0)) != STACK_POINTER_REGNUM)))\n \t/* If the value is indirect by memory or by a register\n \t   that isn't the frame pointer\n \t   then it means the object is variable-sized and address through\n@@ -761,6 +764,23 @@ sdbout_symbol (decl, local)\n \t  PUT_SDB_INT_VAL (DEBUGGER_AUTO_OFFSET (XEXP (value, 0)));\n \t  PUT_SDB_SCL (C_AUTO);\n \t}\n+      else if (GET_CODE (value) == MEM && GET_CODE (XEXP (value, 0)) == CONST)\n+\t{\n+\t  /* Handle an obscure case which can arise when optimizing and\n+\t     when there are few available registers.  (This is *always*\n+\t     the case for i386/i486 targets).  The DECL_RTL looks like\n+\t     (MEM (CONST ...)) even though this variable is a local `auto'\n+\t     or a local `register' variable.  In effect, what has happened\n+\t     is that the reload pass has seen that all assignments and\n+\t     references for one such a local variable can be replaced by\n+\t     equivalent assignments and references to some static storage\n+\t     variable, thereby avoiding the need for a register.  In such\n+\t     cases we're forced to lie to debuggers and tell them that\n+\t     this variable was itself `static'.  */\n+\t  PUT_SDB_DEF (name);\n+\t  PUT_SDB_VAL (XEXP (XEXP (value, 0), 0));\n+\t  PUT_SDB_SCL (C_STAT);\n+\t}\n       else\n \t{\n \t  /* It is something we don't know how to represent for SDB.  */\n@@ -948,6 +968,7 @@ sdbout_one_type (type)\n \tint size = int_size_in_bytes (type);\n \tint member_scl;\n \ttree tem;\n+\tint i, n_baseclasses = 0;\n \n \t/* Record the type tag, but not in its permanent place just yet.  */\n \tsdbout_record_type_name (type);\n@@ -978,6 +999,33 @@ sdbout_one_type (type)\n \tPUT_SDB_SIZE (size);\n \tPUT_SDB_ENDEF;\n \n+\t/* Print out the base class information with fields\n+\t   named after the types they hold.  */\n+\tif (TYPE_BINFO (type)\n+\t    && TYPE_BINFO_BASETYPES (type))\n+\t  n_baseclasses = TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (type));\n+\tfor (i = 0; i < n_baseclasses; i++)\n+\t  {\n+\t    tree child = TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO (type)), i);\n+\t    tree child_type = BINFO_TYPE (child);\n+\t    tree child_type_name;\n+\t    if (TYPE_NAME (child_type) == 0)\n+\t      continue;\n+\t    if (TREE_CODE (TYPE_NAME (child_type)) == IDENTIFIER_NODE)\n+\t      child_type_name = TYPE_NAME (child_type);\n+\t    else if (TREE_CODE (TYPE_NAME (child_type)) == TYPE_DECL)\n+\t      child_type_name = DECL_NAME (TYPE_NAME (child_type));\n+\t    else\n+\t      continue;\n+\n+\t    CONTIN;\n+\t    PUT_SDB_DEF (IDENTIFIER_POINTER (child_type_name));\n+\t    PUT_SDB_INT_VAL (TREE_INT_CST_LOW (BINFO_OFFSET (child)));\n+\t    PUT_SDB_SCL (member_scl);\n+\t    sdbout_type (BINFO_TYPE (child));\n+\t    PUT_SDB_ENDEF;\n+\t  }\n+\n \t/* output the individual fields */\n \n \tif (TREE_CODE (type) == ENUMERAL_TYPE)"}]}