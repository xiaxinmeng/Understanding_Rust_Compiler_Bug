{"sha": "3e056efc31aab68f650a3fa5918ca2d7fb516852", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2UwNTZlZmMzMWFhYjY4ZjY1MGEzZmE1OTE4Y2EyZDdmYjUxNjg1Mg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-07-25T17:02:37Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-07-25T17:02:37Z"}, "message": "pa.c (pa_reorg): If TARGET_BIG_SWITCH, then do not explode ADDR_VEC insns.\n\n        * pa.c (pa_reorg): If TARGET_BIG_SWITCH, then do not explode\n        ADDR_VEC insns.  Slightly rework code which explodes ADDR_VEC\n        insns.\n        * pa.h (TARGET_BIG_SWITCH): Define.\n        (TARGET_SWITCHES): Add \"big-switch\" and \"no-big-switch\".\n        (CASE_VECTOR_MODE): Use TI or DI depending on TARGET_BIG_SWITCH.\n        (CASE_DROPS_THROUGH): Remove definition.\n        (ASM_OUTPUT_ADDR_VEC_ELT): Rewrite to handle TARGET_BIG_SWITCH.\n        (ASM_OUTPUT_ADDR_DIFF_ELT): Likewise.\n        * pa.md (casesi): Rework to avoid some potential long branch\n        problems (also makes generated code faster!).  Handle\n        TARGET_BIG_SWITCH.\n        (casesi0): Corresponding changes.\n\nFrom-SVN: r14528", "tree": {"sha": "6efe17b5c1f3712932f0777e4cc93730a0356e51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6efe17b5c1f3712932f0777e4cc93730a0356e51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e056efc31aab68f650a3fa5918ca2d7fb516852", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e056efc31aab68f650a3fa5918ca2d7fb516852", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e056efc31aab68f650a3fa5918ca2d7fb516852", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e056efc31aab68f650a3fa5918ca2d7fb516852/comments", "author": null, "committer": null, "parents": [{"sha": "b60334e840e077c460eb5e9a08f990c9844f2a48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b60334e840e077c460eb5e9a08f990c9844f2a48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b60334e840e077c460eb5e9a08f990c9844f2a48"}], "stats": {"total": 87, "additions": 45, "deletions": 42}, "files": [{"sha": "db6c4957489a699bccbe31df40ea446d0cd0f695", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e056efc31aab68f650a3fa5918ca2d7fb516852/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e056efc31aab68f650a3fa5918ca2d7fb516852/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=3e056efc31aab68f650a3fa5918ca2d7fb516852", "patch": "@@ -5807,7 +5807,7 @@ pa_reorg (insns)\n   pa_combine_instructions (get_insns ());\n \n   /* This is fairly cheap, so always run it if optimizing.  */\n-  if (optimize > 0)\n+  if (optimize > 0 && !TARGET_BIG_SWITCH)\n     {\n       /* Find and explode all ADDR_VEC insns.  */\n       insns = get_insns ();\n@@ -5831,28 +5831,33 @@ pa_reorg (insns)\n \n \t  for (i = 0; i < length; i++)\n \t    {\n+\t      /* Emit a label before each jump to keep jump.c from\n+\t\t removing this code.  */\n+\t      tmp = gen_label_rtx ();\n+\t      LABEL_NUSES (tmp) = 1;\n+\t      emit_label_after (tmp, location);\n+\t      location = NEXT_INSN (location);\n+\n \t      /* Emit the jump itself.  */\n \t      tmp = gen_switch_jump (XEXP (XVECEXP (pattern, 0, i), 0));\n \t      tmp = emit_jump_insn_after (tmp, location);\n \t      JUMP_LABEL (tmp) = XEXP (XVECEXP (pattern, 0, i), 0);\n \t      LABEL_NUSES (JUMP_LABEL (tmp))++;\n+\t      location = NEXT_INSN (location);\n \n \t      /* Emit a BARRIER after the jump.  */\n-\t      location = NEXT_INSN (location);\n \t      emit_barrier_after (location);\n-\n-\t      /* Put a CODE_LABEL before each so jump.c does not optimize\n-\t\t the jumps away.  */\n-\t      location = NEXT_INSN (location);\n-\t      tmp = gen_label_rtx ();\n-\t      LABEL_NUSES (tmp) = 1;\n-\t      emit_label_after (tmp, location);\n \t      location = NEXT_INSN (location);\n \t    }\n \n \t  /* If needed, emit marker for the end of the branch table.  */\n \t  if (TARGET_GAS)\n-\t    emit_insn_before (gen_end_brtab (), location);\n+\t    {\n+\t      emit_insn_before (gen_end_brtab (), location);\n+\t      location = NEXT_INSN (location);\n+\t      emit_barrier_after (location);\n+\t    }\n+\n \t  /* Delete the ADDR_VEC.  */\n \t  delete_insn (insn);\n \t}"}, {"sha": "daf63c7e24d0641ff24eb459befde053145cd622", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e056efc31aab68f650a3fa5918ca2d7fb516852/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e056efc31aab68f650a3fa5918ca2d7fb516852/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=3e056efc31aab68f650a3fa5918ca2d7fb516852", "patch": "@@ -112,6 +112,10 @@ extern int target_flags;\n /* Use a faster sequence for indirect calls.  */\n #define TARGET_FAST_INDIRECT_CALLS (target_flags & 1024)\n \n+/* Generate code with big switch statements to avoid out of range branches\n+   occuring within the switch table.  */\n+#define TARGET_BIG_SWITCH (target_flags & 2048)\n+\n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n    each pair being { \"NAME\", VALUE }\n@@ -143,6 +147,8 @@ extern int target_flags;\n    {\"no-long-load-store\", -512},\\\n    {\"fast-indirect-calls\", 1024},\\\n    {\"no-fast-indirect-calls\", -1024},\\\n+   {\"big-switch\", 2048},\t\\\n+   {\"no-big-switch\", -2048},\t\\\n    {\"linker-opt\", 0},\t\t\\\n    { \"\", TARGET_DEFAULT | TARGET_CPU_DEFAULT}}\n \n@@ -1677,14 +1683,8 @@ while (0)\n \n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE DImode\n-\n-/* Define this if the tablejump instruction expects the table\n-   to contain offsets from the address of the table.\n-   Do not define this if the table should contain absolute addresses.  */\n-/* #define CASE_VECTOR_PC_RELATIVE */\n+#define CASE_VECTOR_MODE (TARGET_BIG_SWITCH ? TImode : DImode)\n \n-#define CASE_DROPS_THROUGH\n /* Specify the tree operation to be used to convert reals to integers.  */\n #define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n \n@@ -2205,7 +2205,10 @@ DTORS_SECTION_FUNCTION\n    impossible.  */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\tb L$%04d\\n\\tnop\\n\", VALUE)\n+  if (TARGET_BIG_SWITCH)\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tstw %%r1,-16(%%r30)\\n\\tldil LR'L$%04d,%%r1\\n\\tbe RR'L$%04d(%%sr4,%%r1)\\n\\tldw -16(%%r30),%%r1\\n\", VALUE, VALUE);\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tb L$%04d\\n\\tnop\\n\", VALUE)\n \n /* Jump tables are executable code and live in the TEXT section on the PA.  */\n #define JUMP_TABLES_IN_TEXT_SECTION\n@@ -2218,7 +2221,10 @@ DTORS_SECTION_FUNCTION\n    rather than a table of absolute addresses.  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n-  fprintf (FILE, \"\\tb L$%04d\\n\\tnop\\n\", VALUE)\n+  if (TARGET_BIG_SWITCH)\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tstw %%r1,-16(%%r30)\\n\\tldw T'L$%04d(%%r19),%%r1\\n\\tbv 0(%%r1)\\n\\tldw -16(%%r30),%%r1\\n\", VALUE);\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tb L$%04d\\n\\tnop\\n\", VALUE)\n \n /* This is how to output an assembler line\n    that says to advance the location counter"}, {"sha": "848567a5175f65ac2835ff48faa011d287bc55d7", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e056efc31aab68f650a3fa5918ca2d7fb516852/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e056efc31aab68f650a3fa5918ca2d7fb516852/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=3e056efc31aab68f650a3fa5918ca2d7fb516852", "patch": "@@ -4006,37 +4006,29 @@\n       operands[0] = reg;\n     }\n \n-  if (!INT_11_BITS (operands[2]))\n+  if (!INT_5_BITS (operands[2]))\n     operands[2] = force_reg (SImode, operands[2]);\n \n-  emit_jump_insn (gen_casesi0 (operands[0], operands[2],\n-\t\t\t       operands[3], operands[4]));\n+  emit_insn (gen_cmpsi (operands[0], operands[2]));\n+  emit_jump_insn (gen_bgtu (operands[4]));\n+  if (TARGET_BIG_SWITCH)\n+    {\n+      rtx temp = gen_reg_rtx (SImode);\n+      emit_move_insn (temp, gen_rtx (PLUS, SImode, operands[0], operands[0]));\n+      operands[0] = temp;\n+    }\n+  emit_jump_insn (gen_casesi0 (operands[0], operands[3]));\n   DONE;\n }\")\n \n (define_insn \"casesi0\"\n-  [(set (pc)\n-\t(if_then_else (leu (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t   (match_operand:SI 1 \"arith11_operand\" \"rI\"))\n-\t\t      (plus:SI (mem:SI (plus:SI (pc) (match_dup 0)))\n-\t\t\t       (label_ref (match_operand 2 \"\" \"\")))\n-\t\t      (pc)))\n-   (use (label_ref (match_operand 3 \"\" \"\")))]\n+  [(set (pc) (plus:SI\n+\t       (mem:SI (plus:SI (pc) (match_operand 0 \"register_operand\" \"r\")))\n+\t       (label_ref (match_operand 1 \"\" \"\"))))]\n   \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    {\n-      operands[1] = GEN_INT (~INTVAL (operands[1]));\n-      return \\\"addi,uv %1,%0,0\\;blr,n %0,0\\;b,n %l3\\\";\n-    }\n-  else\n-    {\n-      return \\\"sub,>> %0,%1,0\\;blr,n %0,0\\;b,n %l3\\\";\n-    }\n-}\"\n+  \"blr %0,0\\;nop\"\n   [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"12\")])\n+   (set_attr \"length\" \"8\")])\n \n ;; Need nops for the calls because execution is supposed to continue\n ;; past; we don't want to nullify an instruction that we need."}]}