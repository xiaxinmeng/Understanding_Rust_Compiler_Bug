{"sha": "3d678dca190485cba2a650037191fc647289a432", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q2NzhkY2ExOTA0ODVjYmEyYTY1MDAzNzE5MWZjNjQ3Mjg5YTQzMg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-06T20:02:55Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-06T20:02:55Z"}, "message": "entered into RCS\n\nFrom-SVN: r1470", "tree": {"sha": "671ff37b6a12caa0cb298237ca1569f3807d5658", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/671ff37b6a12caa0cb298237ca1569f3807d5658"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d678dca190485cba2a650037191fc647289a432", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d678dca190485cba2a650037191fc647289a432", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d678dca190485cba2a650037191fc647289a432", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d678dca190485cba2a650037191fc647289a432/comments", "author": null, "committer": null, "parents": [{"sha": "0d92cbff155096ede0058cfd4787b89a9da08541", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d92cbff155096ede0058cfd4787b89a9da08541", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d92cbff155096ede0058cfd4787b89a9da08541"}], "stats": {"total": 135, "additions": 93, "deletions": 42}, "files": [{"sha": "a673fe936758b2cb0cd45729287ac4894cfb96a2", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d678dca190485cba2a650037191fc647289a432/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d678dca190485cba2a650037191fc647289a432/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=3d678dca190485cba2a650037191fc647289a432", "patch": "@@ -170,6 +170,8 @@ struct attr_desc\n   struct attr_value *default_val; /* Default value for this attribute. */\n };\n \n+#define NULL_ATTR (struct attr_desc *) NULL\n+\n /* Structure for each DEFINE_DELAY.  */\n \n struct delay_desc\n@@ -546,7 +548,7 @@ attr_rtx (va_alist)\n     }\n   else if (code == CONST_INT)\n     {\n-      int arg0 = va_arg (p, int);\n+      HOST_WIDE_INT arg0 = va_arg (p, HOST_WIDE_INT);\n       if (arg0 == 0)\n \treturn false_rtx;\n       if (arg0 == 1)\n@@ -570,6 +572,10 @@ attr_rtx (va_alist)\n \t      XINT (rt_val, i) = va_arg (p, int);\n \t      break;\n \n+\t    case 'w':\t\t/* A wide integer? */\n+\t      XWINT (rt_val, i) = va_arg (p, HOST_WIDE_INT);\n+\t      break;\n+\n \t    case 's':\t\t/* A string?  */\n \t      XSTR (rt_val, i) = va_arg (p, char *);\n \t      break;\n@@ -772,9 +778,22 @@ attr_copy_rtx (orig)\n \t    }\n \t  break;\n \n-\tdefault:\n+\tcase 'n':\n+\tcase 'i':\n \t  XINT (copy, i) = XINT (orig, i);\n \t  break;\n+\n+\tcase 'w':\n+\t  XWINT (copy, i) = XWINT (orig, i);\n+\t  break;\n+\n+\tcase 's':\n+\tcase 'S':\n+\t  XSTR (copy, i) = XSTR (orig, i);\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n \t}\n     }\n   return copy;\n@@ -880,7 +899,7 @@ check_attr_test (exp, is_const)\n \n     case CONST_INT:\n       /* Either TRUE or FALSE.  */\n-      if (XINT (exp, 0))\n+      if (XWINT (exp, 0))\n \treturn true_rtx;\n       else\n \treturn false_rtx;\n@@ -1644,10 +1663,10 @@ expand_units ()\n \t     and busy cost.  Then make an attribute for use in the conflict\n \t     function.  */\n \t  op->condexp = check_attr_test (op->condexp, 0);\n-\t  op->busyexp = check_attr_value (op->busyexp, 0);\n+\t  op->busyexp = check_attr_value (op->busyexp, NULL_ATTR);\n \t  str = attr_printf (strlen (unit->name) + 11, \"*%s_case_%d\",\n \t\t\t     unit->name, op->num);\n-\t  make_internal_attr (str, make_canonical (0, op->busyexp));\n+\t  make_internal_attr (str, make_canonical (NULL_ATTR, op->busyexp));\n \n \t  /* Make our adjustment to the two COND's being computed.  If we are\n \t     the last operation class, place our values into the default of\n@@ -3499,7 +3518,11 @@ write_test_expr (exp, in_comparison)\n \n     /* Constant integer. */\n     case CONST_INT:\n-      printf (\"%d\", XINT (exp, 0));\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n+      printf (\"%d\", XWINT (exp, 0));\n+#else\n+      printf (\"%ld\", XWINT (exp, 0));\n+#endif\n       break;\n \n     /* A random C expression. */\n@@ -4481,9 +4504,9 @@ main (argc, argv)\n \n   /* Set up true and false rtx's */\n   true_rtx = rtx_alloc (CONST_INT);\n-  XINT (true_rtx, 0) = 1;\n+  XWINT (true_rtx, 0) = 1;\n   false_rtx = rtx_alloc (CONST_INT);\n-  XINT (false_rtx, 0) = 0;\n+  XWINT (false_rtx, 0) = 0;\n   RTX_UNCHANGING_P (true_rtx) = RTX_UNCHANGING_P (false_rtx) = 1;\n   RTX_INTEGRATED_P (true_rtx) = RTX_INTEGRATED_P (false_rtx) = 1;\n "}, {"sha": "8f86925fa9880c3beda3c6c547ea16af0bb83b3b", "filename": "gcc/genemit.c", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d678dca190485cba2a650037191fc647289a432/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d678dca190485cba2a650037191fc647289a432/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=3d678dca190485cba2a650037191fc647289a432", "patch": "@@ -146,7 +146,7 @@ gen_exp (x)\n \n   if (x == 0)\n     {\n-      printf (\"0\");\n+      printf (\"NULL_RTX\");\n       return;\n     }\n \n@@ -202,25 +202,27 @@ gen_exp (x)\n \n     case CONST_INT:\n       if (INTVAL (x) == 0)\n-\t{\n-\t  printf (\"const0_rtx\");\n-\t  return;\n-\t}\n-      if (INTVAL (x) == 1)\n-\t{\n-\t  printf (\"const1_rtx\");\n-\t  return;\n-\t}\n-      if (INTVAL (x) == -1)\n-\t{\n-\t  printf (\"constm1_rtx\");\n-\t  return;\n-\t}\n-      if (INTVAL (x) == STORE_FLAG_VALUE)\n-\t{\n-\t  printf (\"const_true_rtx\");\n-\t  return;\n-\t}\n+\tprintf (\"const0_rtx\");\n+      else if (INTVAL (x) == 1)\n+\tprintf (\"const1_rtx\");\n+      else if (INTVAL (x) == -1)\n+\tprintf (\"constm1_rtx\");\n+      else if (INTVAL (x) == STORE_FLAG_VALUE)\n+\tprintf (\"const_true_rtx\");\n+      else\n+\tprintf (\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\t     \n+\t\t\"GEN_INT (%d)\",\n+#else\n+\t\t\"GEN_INT (%ld)\",\n+#endif\n+\t\tINTVAL (x));\n+      return;\n+\n+    case CONST_DOUBLE:\n+      /* These shouldn't be written in MD files.  Instead, the appropriate\n+\t routines in varasm.c should be called.  */\n+      abort ();\n     }\n \n   printf (\"gen_rtx (\");\n@@ -237,7 +239,7 @@ gen_exp (x)\n       if (fmt[i] == 'e' || fmt[i] == 'u')\n \tgen_exp (XEXP (x, i));\n       else if (fmt[i] == 'i')\n-\tprintf (\"%u\", (unsigned) XINT (x, i));\n+\tprintf (\"%u\", XINT (x, i));\n       else if (fmt[i] == 's')\n \tprintf (\"\\\"%s\\\"\", XSTR (x, i));\n       else if (fmt[i] == 'E')"}, {"sha": "c749359f79d5a127c581d6e10427039a2331fe80", "filename": "gcc/genrecog.c", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d678dca190485cba2a650037191fc647289a432/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d678dca190485cba2a650037191fc647289a432/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=3d678dca190485cba2a650037191fc647289a432", "patch": "@@ -83,6 +83,8 @@ struct decision\n   int elt_zero_int;\t\t/* Required value for XINT (rtl, 0) */\n   int test_elt_one_int;\t\t/* Nonzero if should test XINT (rtl, 1) */\n   int elt_one_int;\t\t/* Required value for XINT (rtl, 1) */\n+  int test_elt_zero_wide;\t/* Nonzero if should test XWINT (rtl, 0) */\n+  HOST_WIDE_INT elt_zero_wide;\t/* Required value for XWINT (rtl, 0) */\n   char *tests;\t\t\t/* If nonzero predicate to call */\n   int pred;\t\t\t/* `preds' index of predicate or -1 */\n   char *c_test;\t\t\t/* Additional test to perform */\n@@ -303,8 +305,10 @@ add_to_sequence (pattern, last, position)\n   new->veclen = 0;\n   new->test_elt_zero_int = 0;\n   new->test_elt_one_int = 0;\n+  new->test_elt_zero_wide = 0;\n   new->elt_zero_int = 0;\n   new->elt_one_int = 0;\n+  new->elt_zero_wide = 0;\n   new->tests = 0;\n   new->pred = -1;\n   new->c_test = 0;\n@@ -500,6 +504,11 @@ add_to_sequence (pattern, last, position)\n \t  this->test_elt_one_int = 1;\n \t  this->elt_one_int = XINT (pattern, i);\n \t}\n+      else if (fmt[i] == 'w' && i == 0)\n+\t{\n+\t  this->test_elt_zero_wide = 1;\n+\t  this->elt_zero_wide = XWINT (pattern, i);\n+\t}\n       else if (fmt[i] == 'E')\n \t{\n \t  register int j;\n@@ -549,6 +558,8 @@ not_both_true (d1, d2, toplevel)\n \t  && d1->elt_zero_int != d2->elt_zero_int)\n       || (d1->test_elt_one_int && d2->test_elt_one_int\n \t  && d1->elt_one_int != d2->elt_one_int)\n+      || (d1->test_elt_zero_wide && d2->test_elt_zero_wide\n+\t  && d1->elt_zero_wide != d2->elt_zero_wide)\n       || (d1->veclen && d2->veclen && d1->veclen != d2->veclen))\n     return 1;\n \n@@ -742,6 +753,7 @@ merge_trees (oldh, addh)\n \t     would cause an infinite recursion.  */\n \t  if (old->tests == 0 && old->test_elt_zero_int == 0\n \t      && old->test_elt_one_int == 0 && old->veclen == 0\n+\t      && old->test_elt_zero_wide == 0\n \t      && old->dupno == -1 && old->mode == VOIDmode\n \t      && old->code == UNKNOWN\n \t      && (old->c_test != 0 || add->c_test != 0))\n@@ -751,16 +763,18 @@ merge_trees (oldh, addh)\n \t\t    || (old->pred >= 0 && old->pred == add->pred)\n \t\t    || (old->tests && add->tests\n \t\t\t&& !strcmp (old->tests, add->tests)))\n-\t      && old->test_elt_zero_int == add->test_elt_zero_int\n-\t      && old->elt_zero_int == add->elt_zero_int\n-\t      && old->test_elt_one_int == add->test_elt_one_int\n-\t      && old->elt_one_int == add->elt_one_int\n-\t      && old->veclen == add->veclen\n-\t      && old->dupno == add->dupno\n-\t      && old->opno == add->opno\n-\t      && old->code == add->code\n-\t      && old->enforce_mode == add->enforce_mode\n-\t      && old->mode == add->mode)\n+\t\t   && old->test_elt_zero_int == add->test_elt_zero_int\n+\t\t   && old->elt_zero_int == add->elt_zero_int\n+\t\t   && old->test_elt_one_int == add->test_elt_one_int\n+\t\t   && old->elt_one_int == add->elt_one_int\n+\t\t   && old->test_elt_zero_wide == add->test_elt_zero_wide\n+\t\t   && old->elt_zero_wide == add->elt_zero_wide\n+\t\t   && old->veclen == add->veclen\n+\t\t   && old->dupno == add->dupno\n+\t\t   && old->opno == add->opno\n+\t\t   && old->code == add->code\n+\t\t   && old->enforce_mode == add->enforce_mode\n+\t\t   && old->mode == add->mode)\n \t    {\n \t      /* If the additional test is not the same, split both nodes\n \t\t into nodes that just contain all things tested before the\n@@ -793,6 +807,7 @@ merge_trees (oldh, addh)\n \t\t      split->veclen = 0;\n \t\t      split->test_elt_zero_int = 0;\n \t\t      split->test_elt_one_int = 0;\n+\t\t      split->test_elt_zero_wide = 0;\n \t\t      split->tests = 0;\n \t\t      split->pred = -1;\n \t\t    }\n@@ -817,6 +832,7 @@ merge_trees (oldh, addh)\n \t\t      split->veclen = 0;\n \t\t      split->test_elt_zero_int = 0;\n \t\t      split->test_elt_one_int = 0;\n+\t\t      split->test_elt_zero_wide = 0;\n \t\t      split->tests = 0;\n \t\t      split->pred = -1;\n \t\t    }\n@@ -873,7 +889,8 @@ merge_trees (oldh, addh)\n       if (best_position == 0)\n \tabort ();\n \n-      if (old == 0 && position_merit (0, add_mode, add->code) < best_merit)\n+      if (old == 0\n+\t  && position_merit (NULL_PTR, add_mode, add->code) < best_merit)\n \t{\n \t  add->prev = 0;\n \t  add->next = oldh.first;\n@@ -964,7 +981,7 @@ write_subroutine (tree, type)\n \n   printf (\"x%d;\\n\", max_depth);\n   printf (\"  %s tem;\\n\", type == SPLIT ? \"rtx\" : \"int\");\n-  write_tree (tree, \"\", 0, 1, type);\n+  write_tree (tree, \"\", NULL_PTR, 1, type);\n   printf (\" ret0: return %d;\\n}\\n\\n\", type == SPLIT ? 0 : -1);\n }\n \f\n@@ -1278,7 +1295,8 @@ write_tree_1 (tree, prevpos, afterward, type)\n \n       if ((mode != switch_mode && ! p->ignore_mode)\n \t  || (p->code != switch_code && p->code != UNKNOWN && ! p->ignore_code)\n-\t  || p->test_elt_zero_int || p->test_elt_one_int || p->veclen\n+\t  || p->test_elt_zero_int || p->test_elt_one_int\n+\t  || p->test_elt_zero_wide || p->veclen\n \t  || p->dupno >= 0 || p->tests || p->num_clobbers_to_add)\n \t{\n \t  printf (\"%sif (\", indents[indent]);\n@@ -1297,6 +1315,14 @@ write_tree_1 (tree, prevpos, afterward, type)\n \t    printf (\"XINT (x%d, 0) == %d && \", depth, p->elt_zero_int);\n \t  if (p->test_elt_one_int)\n \t    printf (\"XINT (x%d, 1) == %d && \", depth, p->elt_one_int);\n+\t  if (p->test_elt_zero_wide)\n+\t    printf (\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n+\t\t    \"XWINT (x%d, 0) == %d && \",\n+#else\n+\t\t    \"XWINT (x%d, 0) == %ld && \",\n+#endif\n+\t\t    depth, p->elt_zero_wide);\n \t  if (p->veclen)\n \t    printf (\"XVECLEN (x%d, 0) == %d && \", depth, p->veclen);\n \t  if (p->dupno >= 0)"}]}