{"sha": "dff06f62c97fee80fc8f7e4f44ee993ffdacf6ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZmMDZmNjJjOTdmZWU4MGZjOGY3ZTRmNDRlZTk5M2ZmZGFjZjZhZA==", "commit": {"author": {"name": "Michael Collison", "email": "collison@gcc.gnu.org", "date": "2001-10-14T02:14:28Z"}, "committer": {"name": "Michael Collison", "email": "collison@gcc.gnu.org", "date": "2001-10-14T02:14:28Z"}, "message": "dsp16xx.md: Rewrite for more efficient code and add scheduling support.\n\n\n\n\t* config/dsp16xx/dsp16xx.md: Rewrite for more efficient code and\n\tadd scheduling support.\n\t* config/dsp16xx/dsp16xx.h: Rewrite for more efficient code.\n\t* config/dsp16xx/dsp16xx.c: Rewrite for more efficient code.\n\t* config/dsp16xx/dsp16xx-protos.h: Add new function prototypes.\n\nFrom-SVN: r46248", "tree": {"sha": "ac93a3d9669add0c1655c7b1a39e267dd4fcb1cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac93a3d9669add0c1655c7b1a39e267dd4fcb1cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dff06f62c97fee80fc8f7e4f44ee993ffdacf6ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dff06f62c97fee80fc8f7e4f44ee993ffdacf6ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dff06f62c97fee80fc8f7e4f44ee993ffdacf6ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dff06f62c97fee80fc8f7e4f44ee993ffdacf6ad/comments", "author": null, "committer": null, "parents": [{"sha": "48d24deb4ee5d801d39135727941d1e8ae1cdde3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48d24deb4ee5d801d39135727941d1e8ae1cdde3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48d24deb4ee5d801d39135727941d1e8ae1cdde3"}], "stats": {"total": 2655, "additions": 1957, "deletions": 698}, "files": [{"sha": "02ba7b8c4f7b263bcfd41d6f082631e0667a16c0", "filename": "gcc/config/dsp16xx/dsp16xx-protos.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dff06f62c97fee80fc8f7e4f44ee993ffdacf6ad/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dff06f62c97fee80fc8f7e4f44ee993ffdacf6ad/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-protos.h?ref=dff06f62c97fee80fc8f7e4f44ee993ffdacf6ad", "patch": "@@ -29,6 +29,8 @@ extern int sp_operand PARAMS ((rtx, enum machine_mode));\n extern int sp_operand2 PARAMS ((rtx, enum machine_mode));\n extern int nonmemory_arith_operand PARAMS ((rtx, enum machine_mode));\n extern int dsp16xx_comparison_operator PARAMS ((rtx, enum machine_mode));\n+extern int unx_comparison_operator PARAMS ((rtx, enum machine_mode));\n+extern int signed_comparison_operator PARAMS ((rtx, enum machine_mode));\n \n extern void notice_update_cc PARAMS ((rtx));\n extern void double_reg_from_memory PARAMS ((rtx[]));\n@@ -77,7 +79,11 @@ extern void asm_output_local PARAMS ((FILE *, const char *, int, int));\n extern void asm_output_float PARAMS ((FILE *, double));\n extern void asm_output_long PARAMS ((FILE *, long));\n extern void dsp16xx_file_start PARAMS ((void));\n+extern void coff_dsp16xx_file_start PARAMS ((FILE *));\n+extern void luxworks_dsp16xx_file_start PARAMS ((FILE *));\n extern struct rtx_def *(*dsp16xx_compare_gen) PARAMS (());\n extern int hard_regno_mode_ok PARAMS ((int, enum machine_mode));\n extern enum reg_class dsp16xx_reg_class_from_letter PARAMS ((int));\n extern int regno_reg_class PARAMS ((int));\n+extern void function_prologue PARAMS ((FILE *, int));\n+extern void function_epilogue PARAMS ((FILE *, int));"}, {"sha": "8ca95a6bac6a3b308f91f7c583ffd80783b3de0d", "filename": "gcc/config/dsp16xx/dsp16xx.c", "status": "modified", "additions": 716, "deletions": 359, "changes": 1075, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dff06f62c97fee80fc8f7e4f44ee993ffdacf6ad/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dff06f62c97fee80fc8f7e4f44ee993ffdacf6ad/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c?ref=dff06f62c97fee80fc8f7e4f44ee993ffdacf6ad", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for assembler code output on the DSP1610.\n    Copyright (C) 1994, 1995, 1997, 1998, 2001 Free Software Foundation, Inc.\n-   Contributed by Michael Collison (collison@world.std.com).\n+   Contributed by Michael Collison (collison@isisinc.net).\n \n This file is part of GNU CC.\n \n@@ -37,7 +37,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"ggc.h\"\n #include \"toplev.h\"\n #include \"recog.h\"\n-#include \"tm_p.h\"\n+#include \"dsp16xx-protos.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n \n@@ -58,7 +58,7 @@ const char *save_chip_name;\n \n rtx dsp16xx_compare_op0;\n rtx dsp16xx_compare_op1;\n-rtx (*dsp16xx_compare_gen) PARAMS (());\n+struct rtx_def *(*dsp16xx_compare_gen)();\n \n static const char *fp;\n static const char *sp;\n@@ -149,15 +149,15 @@ static const char *const lshift_right_asm_first[] =\n static int reg_save_size PARAMS ((void));\n static void dsp16xx_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void dsp16xx_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-\f\n+\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE dsp16xx_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE dsp16xx_output_function_epilogue\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n-\f\n+\n int \n hard_regno_mode_ok (regno, mode)\n      int regno;\n@@ -208,6 +208,12 @@ dsp16xx_reg_class_from_letter (c)\n     {\n     case 'A':\n       return ACCUM_REGS;\n+\n+    case 'l':\n+      return A0_REG;\n+\n+    case 'C':\n+      return A1_REG;\n       \n     case 'h':\n       return ACCUM_HIGH_REGS;\n@@ -242,9 +248,6 @@ dsp16xx_reg_class_from_letter (c)\n     case 'd':\n       return ACCUM_Y_OR_P_REGS;\n \n-    case 'C':\n-      return NO_FRAME_Y_ADDR_REGS;\n-\n     case 'a':\n       return Y_ADDR_REGS;\n \n@@ -279,7 +282,7 @@ dsp16xx_reg_class_from_letter (c)\n       return SLOW_MEM_LOAD_REGS;\n \n     default:\n-      abort ();\n+      return NO_REGS;\n     }\n }\n /* Return the class number of the smallest class containing\n@@ -368,210 +371,16 @@ class_max_nregs(class, mode)\n \n enum reg_class\n limit_reload_class (mode, class)\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n      enum reg_class class;\n {\n-  switch ((int) class)\n-    {\n-    case NO_REGS:\n-    case A0H_REG:\n-    case A0L_REG:\n-    case A0_REG:\n-    case A1H_REG:\n-      return class;\n-\n-    case ACCUM_HIGH_REGS:\n-      abort ();\n-\n-    case A1L_REG:\n-    case ACCUM_LOW_REGS:\n-    case A1_REG:\n-      return class;\n-\n-    case ACCUM_REGS:\n-      if (GET_MODE_SIZE(mode) == 1)\n-\treturn ACCUM_LOW_REGS;\n-      else\n-\treturn class;\n-\n-    case X_REG:\n-    case X_OR_ACCUM_LOW_REGS:\n-      return class;\n-\n-    case X_OR_ACCUM_REGS:\n-      if (GET_MODE_SIZE(mode) == 1)\n-\treturn X_OR_ACCUM_LOW_REGS;\n-      else\n-\treturn class;\n-\n-    case YH_REG:\n-      return class;\n-\n-    case YH_OR_ACCUM_HIGH_REGS:\n-      abort ();\n-\n-    case X_OR_YH_REGS:\n-      return class;\n-\n-    case YL_REG:\n-      /* Register 'yl' is invalid for QImode, so we should never\n-\t see it. */\n-      abort ();\n-\n-    case YL_OR_ACCUM_LOW_REGS:\n-    case X_OR_YL_REGS:\n-      return class;\n-\n-    case Y_REG:\n-      if (GET_MODE_SIZE(mode) > 1)\n-\treturn class;\n-      else\n-\treturn YH_REG;\n-\n-    case ACCUM_OR_Y_REGS:\n-      if (GET_MODE_SIZE(mode) > 1)\n-\treturn class;\n-      else\n-\treturn YL_OR_ACCUM_LOW_REGS;\n-\n-    case PH_REG:\n-    case X_OR_PH_REGS:\n-    case PL_REG:\n-    case PL_OR_ACCUM_LOW_REGS:\n-    case X_OR_PL_REGS:\n-      return class;\n-\n-    case P_REG:\n-      if (GET_MODE_SIZE(mode) > 1)\n-\treturn class;\n-      else\n-\treturn PL_REG;\n-\n-    case ACCUM_OR_P_REGS:\n-      if (GET_MODE_SIZE(mode) > 1)\n-\treturn class;\n-      else\n-\treturn PL_OR_ACCUM_LOW_REGS;\n-\n-    case YL_OR_P_REGS:\n-    case ACCUM_LOW_OR_YL_OR_P_REGS:\n-      return class;\n-\n-    case Y_OR_P_REGS:\n-      return class;\n-\n-    case ACCUM_Y_OR_P_REGS:\n-      if (GET_MODE_SIZE(mode) > 1)\n-\treturn class;\n-      else\n-\treturn ACCUM_LOW_OR_YL_OR_P_REGS;\n-\n-    case NO_FRAME_Y_ADDR_REGS:\n-    case Y_ADDR_REGS: \n-    case ACCUM_LOW_OR_Y_ADDR_REGS:\n-      return class;\n-\n-    case ACCUM_OR_Y_ADDR_REGS:\n-      if (GET_MODE_SIZE(mode) > 1)\n-\treturn ACCUM_REGS;\n-      else\n-\treturn ACCUM_LOW_OR_Y_ADDR_REGS;\n-\n-    case X_OR_Y_ADDR_REGS:\n-      return class;\n-\n-    case Y_OR_Y_ADDR_REGS:\n-    case P_OR_Y_ADDR_REGS:\n-    case NON_HIGH_YBASE_ELIGIBLE_REGS:\n-\n-    case J_REG:\n-      return class;\n-\n-    case YBASE_ELIGIBLE_REGS:\n-      if (GET_MODE_SIZE(mode) > 1)\n-\treturn ACCUM_Y_P_OR_YBASE_REGS;\n-      else\n-\treturn NON_HIGH_YBASE_ELIGIBLE_REGS;\n-\n-    case J_OR_DAU_16_BIT_REGS:\n-      if (GET_MODE_SIZE(mode) == 1)\n-\treturn J_REG;\n-      else\n-\treturn class;\n-\n-    case BMU_REGS:\n-    case NOHIGH_NON_ADDR_REGS:\n-      return class;\n-\n-    case NON_ADDR_REGS:\n-      if (GET_MODE_SIZE(mode) > 1)\n-\treturn class;\n-      else\n-\treturn NOHIGH_NON_ADDR_REGS;\n-\n-    case NOHIGH_NON_YBASE_REGS:\n-      return class;\n-\n-    case NON_YBASE_REGS:\n-      if (GET_MODE_SIZE(mode) > 1)\n-\treturn class;\n-      else\n-\treturn NOHIGH_NON_YBASE_REGS;\n-\n-    case YBASE_VIRT_REGS:\n-    case ACCUM_LOW_OR_YBASE_REGS:\n-      return class;\n-      \n-    case ACCUM_OR_YBASE_REGS:\n-      if (GET_MODE_SIZE(mode) > 1)\n-\treturn class;\n-      else\n-\treturn ACCUM_LOW_OR_YBASE_REGS;\n-\n-    case X_OR_YBASE_REGS:\n-      return class;\n-\n-    case Y_OR_YBASE_REGS:\n-    case ACCUM_LOW_YL_PL_OR_YBASE_REGS:\n-    case P_OR_YBASE_REGS:\n-      return class;\n-\n-    case ACCUM_Y_P_OR_YBASE_REGS:\n-      return ACCUM_LOW_YL_PL_OR_YBASE_REGS;\n-\n-    case Y_ADDR_OR_YBASE_REGS:\n-    case YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS:\n-      return class;\n-\n-    case YBASE_OR_YBASE_ELIGIBLE_REGS:\n-      if (GET_MODE_SIZE(mode) > 1)\n-\treturn class;\n-      else\n-\treturn YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS;\n-\n-    case NO_HIGH_ALL_REGS:\n-      return class;\n-\n-    case ALL_REGS:\n-      if (GET_MODE_SIZE(mode) > 1)\n-\treturn class;\n-      else\n-\treturn NO_HIGH_ALL_REGS;\n-\n-    default:\n-      return class;\n-    }\n+  return class;\n }\n \n int\n dsp16xx_register_move_cost (from, to)\n      enum reg_class from, to;\n {\n-#if 0\n-  if (from == NO_REGS || to == NO_REGS || (from == to))\n-    return 2;\n-#endif\n-\n   if (from == A0H_REG || from == A0L_REG || from == A0_REG ||\n       from == A1H_REG || from == ACCUM_HIGH_REGS || from == A1L_REG ||\n       from == ACCUM_LOW_REGS || from == A1_REG || from == ACCUM_REGS)\n@@ -589,18 +398,20 @@ dsp16xx_register_move_cost (from, to)\n       return 2;\n     }\n \n-#if 0\n   if (from == YBASE_VIRT_REGS)\n     {\n+      if (to == YBASE_VIRT_REGS)\n+\treturn 16;\n+\n       if (to == X_REG || to == YH_REG || to == YL_REG ||\n \t  to == Y_REG || to == PL_REG || to == PH_REG ||\n \t  to == P_REG || to == Y_ADDR_REGS || to == YBASE_ELIGIBLE_REGS ||\n \t  to == Y_OR_P_REGS)\n \t{\n-\t  return 2;\n+\t  return 8;\n \t}\n       else\n-\treturn 4;\n+\treturn 10;\n     }\n \n   if (to == YBASE_VIRT_REGS)\n@@ -610,13 +421,13 @@ dsp16xx_register_move_cost (from, to)\n \t  from == P_REG || from == Y_ADDR_REGS || from == YBASE_ELIGIBLE_REGS ||\n \t  from == Y_OR_P_REGS)\n \t{\n-\t  return 2;\n+\t  return 8;\n \t}\n       else\n-\treturn 4;\n+\treturn 10;\n     }\n-#endif\n-  return 4;\n+\n+  return 8;\n }\n \n /* Given an rtx X being reloaded into a reg required to be\n@@ -636,13 +447,341 @@ preferred_reload_class (x, class)\n \n   if (CONSTANT_P (x))\n     {\n-      if (class == ALL_REGS)\n-\treturn NON_YBASE_REGS;\n+      switch ((int) class)\n+\t{\n+\tcase YBASE_VIRT_REGS:\n+\t  return (!reload_in_progress ? NO_REGS : class);\n+\n+\tcase ACCUM_LOW_OR_YBASE_REGS:\n+\t  return ACCUM_LOW_REGS;\n+\n+\tcase ACCUM_OR_YBASE_REGS:\n+\t  return ACCUM_REGS;\n+\n+\tcase X_OR_YBASE_REGS:\n+\t  return X_REG;\n+\n+\tcase Y_OR_YBASE_REGS:\n+\t  return Y_REG;\n+\n+\tcase ACCUM_LOW_YL_PL_OR_YBASE_REGS:\n+\t  return YL_OR_PL_OR_ACCUM_LOW_REGS;\n+\n+\tcase P_OR_YBASE_REGS:\n+\t  return P_REG;\n+\n+\tcase ACCUM_Y_P_OR_YBASE_REGS:\n+\t  return ACCUM_Y_OR_P_REGS;\n+\n+\tcase Y_ADDR_OR_YBASE_REGS:\n+\t  return Y_ADDR_REGS;\n+\n+\tcase YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS:\n+\t  return NON_HIGH_YBASE_ELIGIBLE_REGS;;\n+\t  \n+\tcase YBASE_OR_YBASE_ELIGIBLE_REGS:\n+\t  return YBASE_ELIGIBLE_REGS;\n+\n+\tcase NO_HIGH_ALL_REGS:\n+\t  return NOHIGH_NON_YBASE_REGS;\n+\n+\tcase ALL_REGS:\n+\t  return NON_YBASE_REGS;\n+\n+\tdefault:\n+\t  return class;\n+\t}\n+    }\n+\n+  /* If x is not an accumulator or a ybase register, restrict the class of registers\n+     we can copy the register into */\n+\n+  if (REG_P (x) && !IS_ACCUM_REG (REGNO (x)) && !IS_YBASE_REGISTER_WINDOW (REGNO (x)))\n+    {\n+      switch ((int) class)\n+\t{\n+\tcase NO_REGS:\n+\tcase A0H_REG: case A0L_REG: case A0_REG: case A1H_REG:\n+\tcase ACCUM_HIGH_REGS: case A1L_REG: case ACCUM_LOW_REGS: \n+\tcase A1_REG: case ACCUM_REGS:\n+\t  return class;\n+\n+\tcase X_REG: \n+\t  return (!reload_in_progress ? NO_REGS : class);\n+\n+\tcase X_OR_ACCUM_LOW_REGS: \n+\t  return ACCUM_LOW_REGS;\n+\n+\tcase X_OR_ACCUM_REGS:\n+\t  return ACCUM_REGS;\n+\n+\tcase YH_REG:\n+\t  return (!reload_in_progress ? NO_REGS : class);\n+\n+\tcase YH_OR_ACCUM_HIGH_REGS:\n+\t  return ACCUM_HIGH_REGS;\n+\n+\tcase X_OR_YH_REGS: \n+\tcase YL_REG:\n+\t  return (!reload_in_progress ? NO_REGS : class);\n+\n+\tcase YL_OR_ACCUM_LOW_REGS: \n+\t  return ACCUM_LOW_REGS;\n+\n+\tcase X_OR_YL_REGS:\n+\tcase X_OR_Y_REGS: case Y_REG:\n+\t  return (!reload_in_progress ? NO_REGS : class);\n+\n+\tcase ACCUM_OR_Y_REGS: \n+\t  return ACCUM_REGS;\n+\n+\tcase PH_REG:\n+\tcase X_OR_PH_REGS: case PL_REG: \n+\t  return (!reload_in_progress ? NO_REGS : class);\n+\n+\tcase PL_OR_ACCUM_LOW_REGS:\n+ \t  return ACCUM_LOW_REGS;\n+\n+\tcase X_OR_PL_REGS:\n+\t  return (!reload_in_progress ? NO_REGS : class);\n+\n+\tcase YL_OR_PL_OR_ACCUM_LOW_REGS: \n+ \t  return ACCUM_LOW_REGS;\n+\n+\tcase P_REG:\n+\t  return (!reload_in_progress ? NO_REGS : class);\n+\n+\tcase ACCUM_OR_P_REGS: \n+\t  return ACCUM_REGS;\n+\n+\tcase YL_OR_P_REGS:\n+\t  return (!reload_in_progress ? NO_REGS : class);\n+\n+\tcase ACCUM_LOW_OR_YL_OR_P_REGS: \n+ \t  return ACCUM_LOW_REGS;\n+\n+\tcase Y_OR_P_REGS:\n+\t  return (!reload_in_progress ? NO_REGS : class);\n+\n+\tcase ACCUM_Y_OR_P_REGS: \n+\t  return ACCUM_REGS;\n+\n+\tcase NO_FRAME_Y_ADDR_REGS:\n+\tcase Y_ADDR_REGS:\n+\t  return (!reload_in_progress ? NO_REGS : class);\n+\n+\tcase ACCUM_LOW_OR_Y_ADDR_REGS:\n+ \t  return ACCUM_LOW_REGS;\n+\n+\tcase ACCUM_OR_Y_ADDR_REGS: \n+\t  return ACCUM_REGS;\n+\n+\tcase X_OR_Y_ADDR_REGS:\n+\tcase Y_OR_Y_ADDR_REGS: \n+\tcase P_OR_Y_ADDR_REGS:\n+\t  return (!reload_in_progress ? NO_REGS : class);\n+\n+\tcase NON_HIGH_YBASE_ELIGIBLE_REGS: \n+ \t  return ACCUM_LOW_REGS;\n+\n+\tcase YBASE_ELIGIBLE_REGS:\n+\t  return ACCUM_REGS;\n+\n+\tcase J_REG:\n+\tcase J_OR_DAU_16_BIT_REGS:\n+\tcase BMU_REGS: \n+\t  return (!reload_in_progress ? NO_REGS : class);\n+\n+\tcase YBASE_VIRT_REGS:\n+\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n+\t    return class;\n+\t  else\n+\t    return (!reload_in_progress ? NO_REGS : class);\n+\n+\tcase ACCUM_LOW_OR_YBASE_REGS:\n+\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n+\t    return class;\n+\t  else\n+\t    return ACCUM_LOW_REGS;\n+\n+\tcase ACCUM_OR_YBASE_REGS:\n+\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n+\t    return class;\n+\t  else\n+\t    return ACCUM_REGS;\n+\n+\tcase X_OR_YBASE_REGS:\n+\tcase Y_OR_YBASE_REGS:\n+\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n+\t    return YBASE_VIRT_REGS;\n+\t  else\n+\t    return (!reload_in_progress ? NO_REGS : class);\n+\n+\tcase ACCUM_LOW_YL_PL_OR_YBASE_REGS:\n+\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n+\t    return ACCUM_LOW_OR_YBASE_REGS;\n+\t  else\n+\t    return ACCUM_LOW_REGS;\n+\n+\tcase P_OR_YBASE_REGS:\n+\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n+\t    return YBASE_VIRT_REGS;\n+\t  else\n+\t    return (!reload_in_progress ? NO_REGS : class);\n+\n+\tcase ACCUM_Y_P_OR_YBASE_REGS:\n+\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n+\t    return ACCUM_OR_YBASE_REGS;\n+\t  else\n+\t    return ACCUM_REGS;\n+\n+\tcase Y_ADDR_OR_YBASE_REGS:\n+\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n+\t    return YBASE_VIRT_REGS;\n+\t  else\n+\t    return (!reload_in_progress ? NO_REGS : class);\n+\n+\tcase YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS:\n+\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n+\t    return ACCUM_LOW_OR_YBASE_REGS;\n+\t  else\n+\t    return ACCUM_LOW_REGS;\n+\n+\tcase YBASE_OR_YBASE_ELIGIBLE_REGS:\n+\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n+\t    return ACCUM_OR_YBASE_REGS;\n+\t  else\n+\t    return ACCUM_REGS;\n+\n+\tcase NO_HIGH_ALL_REGS:\n+\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n+\t    return ACCUM_LOW_OR_YBASE_REGS;\n+\t  else\n+\t    return ACCUM_LOW_REGS;\n+\n+\tcase ALL_REGS: \n+\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n+\t    return ACCUM_OR_YBASE_REGS;\n+\t  else\n+\t    return ACCUM_REGS;\n+\n+\tcase NOHIGH_NON_ADDR_REGS:\n+\t    return ACCUM_LOW_REGS;\n+\n+\tcase NON_ADDR_REGS:\n+\tcase SLOW_MEM_LOAD_REGS:\n+\t    return ACCUM_REGS;\n+\n+\tcase NOHIGH_NON_YBASE_REGS:\n+\t    return ACCUM_LOW_REGS;\n+\n+\tcase NO_ACCUM_NON_YBASE_REGS:\n+\t  return (!reload_in_progress ? NO_REGS : class);\n+\n+\tcase NON_YBASE_REGS:\n+\t    return ACCUM_REGS;\n+\n+\tdefault:\n+\t  return class;\n+\t}\n     }\n \n-  if (class == ALL_REGS && REG_P (x) && !TARGET_RESERVE_YBASE\n+  /* If x (the input) is a ybase register, restrict the class of registers\n+     we can copy the register into */\n+\n+  if (REG_P (x) && !TARGET_RESERVE_YBASE\n       && IS_YBASE_REGISTER_WINDOW (REGNO(x)))\n-    return YBASE_ELIGIBLE_REGS;\n+    {\n+      switch ((int) class)\n+\t{\n+\tcase NO_REGS:\n+\tcase A0H_REG: case A0L_REG: case A0_REG: case A1H_REG:\n+\tcase ACCUM_HIGH_REGS: case A1L_REG: case ACCUM_LOW_REGS: \n+\tcase A1_REG: case ACCUM_REGS: case X_REG: \n+\tcase X_OR_ACCUM_LOW_REGS: case X_OR_ACCUM_REGS:\n+\tcase YH_REG: case YH_OR_ACCUM_HIGH_REGS:\n+\tcase X_OR_YH_REGS: case YL_REG:\n+\tcase YL_OR_ACCUM_LOW_REGS: case X_OR_YL_REGS:\n+\tcase X_OR_Y_REGS: case Y_REG:\n+\tcase ACCUM_OR_Y_REGS: case PH_REG:\n+\tcase X_OR_PH_REGS: case PL_REG: \n+\tcase PL_OR_ACCUM_LOW_REGS: case X_OR_PL_REGS:\n+\tcase YL_OR_PL_OR_ACCUM_LOW_REGS: case P_REG:\n+\tcase ACCUM_OR_P_REGS: case YL_OR_P_REGS:\n+\tcase ACCUM_LOW_OR_YL_OR_P_REGS: case Y_OR_P_REGS:\n+\tcase ACCUM_Y_OR_P_REGS: case NO_FRAME_Y_ADDR_REGS:\n+\tcase Y_ADDR_REGS: case ACCUM_LOW_OR_Y_ADDR_REGS:\n+\tcase ACCUM_OR_Y_ADDR_REGS: case X_OR_Y_ADDR_REGS:\n+\tcase Y_OR_Y_ADDR_REGS: case P_OR_Y_ADDR_REGS:\n+\tcase NON_HIGH_YBASE_ELIGIBLE_REGS: case YBASE_ELIGIBLE_REGS:\n+\tdefault:\n+\t  return class;\n+\n+\tcase J_REG:\n+\t  return (!reload_in_progress ? NO_REGS : class);\n+\n+\tcase J_OR_DAU_16_BIT_REGS:\n+\t  return ACCUM_HIGH_REGS;\n+\n+\tcase BMU_REGS: \n+\tcase YBASE_VIRT_REGS:\n+\t  return (!reload_in_progress ? NO_REGS : class);\n+\n+\tcase ACCUM_LOW_OR_YBASE_REGS:\n+\t  return ACCUM_LOW_REGS;\n+\n+\tcase ACCUM_OR_YBASE_REGS:\n+\t  return ACCUM_REGS;\n+\n+\tcase X_OR_YBASE_REGS:\n+\t  return X_REG;\n+\n+\tcase Y_OR_YBASE_REGS:\n+\t  return Y_REG;\n+\n+\tcase ACCUM_LOW_YL_PL_OR_YBASE_REGS:\n+\t  return YL_OR_PL_OR_ACCUM_LOW_REGS; \n+\n+\tcase P_OR_YBASE_REGS:\n+\t  return P_REG;\n+\n+\tcase ACCUM_Y_P_OR_YBASE_REGS:\n+\t  return ACCUM_Y_OR_P_REGS;\n+\n+\tcase Y_ADDR_OR_YBASE_REGS:\n+\t  return Y_ADDR_REGS;\n+\n+\tcase YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS:\n+\t  return NON_HIGH_YBASE_ELIGIBLE_REGS;\n+\n+\tcase YBASE_OR_YBASE_ELIGIBLE_REGS:\n+\t  return YBASE_ELIGIBLE_REGS;\n+\n+\tcase NO_HIGH_ALL_REGS:\n+\t  return NON_HIGH_YBASE_ELIGIBLE_REGS;\n+\n+\tcase ALL_REGS: \n+\t  return YBASE_ELIGIBLE_REGS;\n+\n+\tcase NOHIGH_NON_ADDR_REGS:\n+\t  return ACCUM_LOW_OR_YL_OR_P_REGS;\n+\n+\tcase NON_ADDR_REGS:\n+\t  return ACCUM_Y_OR_P_REGS;\n+\n+\tcase SLOW_MEM_LOAD_REGS:\n+\t  return ACCUM_OR_Y_ADDR_REGS;\n+\n+\tcase NOHIGH_NON_YBASE_REGS:\n+    \t  return NON_HIGH_YBASE_ELIGIBLE_REGS;\n+\n+    \tcase NO_ACCUM_NON_YBASE_REGS:\n+\t  return Y_ADDR_REGS;\n+\n+    \tcase NON_YBASE_REGS:\n+\t  return YBASE_ELIGIBLE_REGS;\n+\t}\n+    }\n \n   if (GET_CODE (x) == PLUS)\n     {\n@@ -655,6 +794,12 @@ preferred_reload_class (x, class)\n \t  if (class == ACCUM_HIGH_REGS)\n \t    return class;\n \n+\t  /* If the accumulators are not part of the class\n+\t     being reloaded into, return NO_REGS */\n+#if 0\n+\t  if (!reg_class_subset_p (ACCUM_REGS, class))\n+\t    return (!reload_in_progress ? NO_REGS : class);\n+#endif\n \t  if (reg_class_subset_p (ACCUM_HIGH_REGS, class))\n \t    return ACCUM_HIGH_REGS;\n \n@@ -678,14 +823,54 @@ preferred_reload_class (x, class)\n     }\n   else if (GET_CODE (x) == MEM)\n     {\n-      if (class == ALL_REGS)\n+      /* We can't copy from a memory location into a\n+\t ybase register */\n+      if (reg_class_subset_p(YBASE_VIRT_REGS, class))\n \t{\n-#if 0\n-\t  if (GET_MODE(x) == HImode)\n-\t    return NO_ACCUM_NON_YBASE_REGS;\n-\t  else\n-#endif\n-\t    return NON_YBASE_REGS;\n+\t  switch ((int) class)\n+\t    {\n+\t    case YBASE_VIRT_REGS:\n+\t      return (!reload_in_progress ? NO_REGS : class);\n+\n+\t    case ACCUM_LOW_OR_YBASE_REGS:\n+\t      return ACCUM_LOW_REGS;\n+\n+\t    case ACCUM_OR_YBASE_REGS:\n+\t      return ACCUM_REGS;\n+\n+\t    case X_OR_YBASE_REGS:\n+\t      return X_REG;\n+\n+\t    case Y_OR_YBASE_REGS:\n+\t      return Y_REG;\n+\n+\t    case ACCUM_LOW_YL_PL_OR_YBASE_REGS:\n+\t      return YL_OR_PL_OR_ACCUM_LOW_REGS;\n+\n+\t    case P_OR_YBASE_REGS:\n+\t      return P_REG;\n+\n+\t    case ACCUM_Y_P_OR_YBASE_REGS:\n+\t      return ACCUM_Y_OR_P_REGS;\n+\n+\t    case Y_ADDR_OR_YBASE_REGS:\n+\t      return Y_ADDR_REGS;\n+\n+\t    case YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS:\n+\t      return NON_HIGH_YBASE_ELIGIBLE_REGS;\n+\t  \n+\t    case YBASE_OR_YBASE_ELIGIBLE_REGS:\n+\t      return YBASE_ELIGIBLE_REGS;\n+\n+\t    case NO_HIGH_ALL_REGS:\n+\t      return NOHIGH_NON_YBASE_REGS;\n+\n+\t    case ALL_REGS:\n+\t      return NON_YBASE_REGS;\n+\n+\t    default:\n+\t      return class;\n+\t    }\n \t}\n       else\n \treturn class;\n@@ -709,6 +894,18 @@ secondary_reload_class (class, mode, in)\n   if (GET_CODE (in) == REG || GET_CODE (in) == SUBREG)\n     regno = true_regnum (in);\n \n+  /* If we are reloading a plus into a high accumulator register,\n+     we need a scratch low accumulator, because the low half gets\n+     clobbered */\n+\n+  if (class == ACCUM_HIGH_REGS \n+      || class == A1H_REG\n+      || class == A0H_REG)\n+    {\n+      if (GET_CODE (in) == PLUS && mode == QImode)\n+\treturn ACCUM_LOW_REGS;\n+    }\n+\n   if (class == ACCUM_HIGH_REGS \n       || class == ACCUM_LOW_REGS\n       || class == A1L_REG\n@@ -737,6 +934,12 @@ secondary_reload_class (class, mode, in)\n       (regno >= REG_A0 && regno < REG_A1L + 1))\n     return NO_REGS;\n \n+  if (class == ACCUM_OR_YBASE_REGS && REG_P(in)\n+      && IS_YBASE_ELIGIBLE_REG(regno))\n+    {\n+      return NO_REGS;\n+    }\n+\n   /* We can copy the ybase registers into:\n      r0-r3, a0-a1, y, p, & x or the union of\n      any of these. */\n@@ -1128,6 +1331,9 @@ compute_frame_size (size)\n   long extra_size;\n   long reg_size;\n \n+  /* This value is needed to compute reg_size */\n+  current_frame_info.function_makes_calls = !leaf_function_p ();\n+\n   reg_size = 0;\n   extra_size = 0;\n   var_size = size;\n@@ -1145,7 +1351,6 @@ compute_frame_size (size)\n   current_frame_info.reg_size    = reg_size;\n   current_frame_info.initialized = reload_completed;\n   current_frame_info.reg_size\t = reg_size / UNITS_PER_WORD;\n-  current_frame_info.function_makes_calls = dsp16xx_makes_calls ();\n \n   if (reg_size)\n     {\n@@ -1157,13 +1362,29 @@ compute_frame_size (size)\n   return total_size;\n }\n \n+int frame_size()\n+{\n+  return (int) compute_frame_size(get_frame_size());\n+}\n+\n+int frame_pointer_offset()\n+{\n+  if (!leaf_function_p())\n+    return ( -(current_function_outgoing_args_size + 1) );\n+  else\n+    return 1;\n+}\n+\n int\n dsp16xx_call_saved_register (regno)\n      int regno;\n {\n+#if 0\n+  if (regno == REG_PR && current_frame_info.function_makes_calls)\n+    return 1;\n+#endif\n   return (regs_ever_live[regno] && !call_used_regs[regno] &&\n \t  !IS_YBASE_REGISTER_WINDOW(regno));\n-\n }\n \n int\n@@ -1182,10 +1403,10 @@ ybase_regs_ever_used ()\n   return live;\n }\n \n-static void \n+void \n dsp16xx_output_function_prologue (file, size)\n      FILE *file;\n-     HOST_WIDE_INT size;\n+     int  size;\n {\n   int regno;\n   long total_size;\n@@ -1197,14 +1418,14 @@ dsp16xx_output_function_prologue (file, size)\n   total_size = compute_frame_size (size);\n   \n   fprintf( file, \"\\t/* FUNCTION PROLOGUE: */\\n\" );\n-  fprintf (file, \"\\t/* total=%ld, vars= %ld, regs= %d, args=%d, extra= %ld */\\n\",\n+  fprintf (file, \"\\t/* total=%d, vars= %d, regs= %d, args=%d, extra= %d */\\n\",\n \t   current_frame_info.total_size,\n \t   current_frame_info.var_size,\n \t   current_frame_info.reg_size,\n \t   current_function_outgoing_args_size,\n \t   current_frame_info.extra_size);\n   \n-  fprintf (file, \"\\t/* fp save offset= %ld, sp save_offset= %ld */\\n\\n\",\n+  fprintf (file, \"\\t/* fp save offset= %d, sp save_offset= %d */\\n\\n\",\n \t   current_frame_info.fp_save_offset,\n \t   current_frame_info.sp_save_offset);\n   /* Set up the 'ybase' register window. */\n@@ -1219,58 +1440,51 @@ dsp16xx_output_function_prologue (file, size)\n       fprintf (file, \"\\t%s=%s\\n\", reg_names[REG_YBASE], a1h);\n     }\n   \n-#if 0\n-  if (current_frame_info.function_makes_calls)\n-    fprintf( file, \"\\t*%s++=%s\\n\", sp, rr );   /* Push return address */\n-#endif\n-  \n-  \n   if (current_frame_info.var_size)\n     {\n       if (current_frame_info.var_size == 1)\n \tfprintf (file, \"\\t*%s++\\n\", sp);\n-      else if (SMALL_INTVAL (current_frame_info.var_size)\n-\t       && ((current_frame_info.var_size & 0x8000) == 0))\n-\tfprintf (file, \"\\t%s=%ld\\n\\t*%s++%s\\n\", reg_names[REG_J],\n-\t\t current_frame_info.var_size, sp, reg_names[REG_J]);\n       else\n-\terror (\"Stack size > 32k\");\n+        {\n+\t  if(SMALL_INTVAL(current_frame_info.var_size) && ((current_frame_info.var_size & 0x8000) == 0))\n+\t    fprintf (file, \"\\t%s=%d\\n\\t*%s++%s\\n\", reg_names[REG_J], current_frame_info.var_size, sp, reg_names[REG_J]);\n+\t  else\n+\t    fatal_error (\"Stack size > 32k\");\n+\t}\n     }\n   \n-  /* Save any registers this function uses, unless they are used in a call,\n-     in which case we don't need to.  */\n+  /* Save any registers this function uses, unless they are\n+   * used in a call, in which case we don't need to\n+   */\n   \n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; ++ regno)\n+  for( regno = 0; regno < FIRST_PSEUDO_REGISTER; ++ regno )\n     if (dsp16xx_call_saved_register (regno)) \n       {\n-#if OLD_REGISTER_SAVE\n-\tfprintf (file, \"\\t*%s++=%s\\n\", sp, reg_names[regno]);\n-#else\n-\tfprintf (file, \"\\tpush(*%s)=%s\\n\", sp, reg_names[regno]);\n-#endif\n+\tfprintf( file, \"\\tpush(*%s)=%s\\n\", sp, reg_names[regno] );\n       }\n-  \n+\n+  /* For debugging purposes, we want the return address to be at a predictable\n+     location */\n+  if (current_frame_info.function_makes_calls)\n+    fprintf( file, \"\\tpush(*%s)=%s\\n\", sp, reg_names[RETURN_ADDRESS_REGNUM]);\n+\n   if (current_frame_info.args_size)\n     {\n       if (current_frame_info.args_size == 1)\n \tfprintf (file, \"\\t*%s++\\n\", sp);\n-      else if (SMALL_INTVAL (current_frame_info.args_size)\n-\t       && (current_frame_info.args_size & 0x8000) == 0)\n-\tfprintf (file, \"\\t%s=%ld\\n\\t*%s++%s\\n\", reg_names[REG_J],\n-\t\t current_frame_info.args_size, sp, reg_names[REG_J]);\n       else\n \terror (\"Stack size > 32k\");\n     }\n-  \n+   \n   if (frame_pointer_needed)\n     {\n-      fprintf (file, \"\\t%s=%s\\n\", a1h, sp);\n-      fprintf (file, \"\\t%s=%s\\n\", fp, a1h);  /* Establish new base frame */\n-      fprintf (file, \"\\t%s=%ld\\n\", reg_names[REG_J], -total_size);\n-      fprintf (file, \"\\t*%s++%s\\n\", fp, reg_names[REG_J]);\n+      fprintf( file, \"\\t%s=%s\\n\", a1h, sp );\n+      fprintf( file, \"\\t%s=%s\\n\", fp, a1h );  /* Establish new base frame */\n+      fprintf( file, \"\\t%s=%d\\n\", reg_names[REG_J], -total_size);\n+      fprintf( file, \"\\t*%s++%s\\n\", fp, reg_names[REG_J]);\n     }\n   \n-  fprintf (file, \"\\t/* END FUNCTION PROLOGUE: */\\n\\n\");\n+  fprintf( file, \"\\t/* END FUNCTION PROLOGUE: */\\n\\n\" );\n }\n \n void\n@@ -1300,16 +1514,12 @@ init_emulation_routines ()\n  dsp16xx_lshrhi3_libcall = (rtx) 0;\n \n }\n-\n-static void\n+void\n dsp16xx_output_function_epilogue (file, size)\n      FILE *file;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+     int size ATTRIBUTE_UNUSED;\n {\n   int regno;\n-#if OLD_REGISTER_SAVE  \n-  int initial_stack_dec = 0;\n-#endif\n   \n   fp = reg_names[FRAME_POINTER_REGNUM];\n   sp = reg_names[STACK_POINTER_REGNUM];\n@@ -1324,7 +1534,7 @@ dsp16xx_output_function_epilogue (file, size)\n \tfprintf (file, \"\\t*%s--\\n\", sp);\n       else\n \t{\n-\t  fprintf (file, \"\\t%s=%ld\\n\\t*%s++%s\\n\", \n+\t  fprintf (file, \"\\t%s=%d\\n\\t*%s++%s\\n\", \n \t\t   reg_names[REG_J], -current_frame_info.args_size, sp, reg_names[REG_J]);\n \t}\n     }\n@@ -1338,40 +1548,23 @@ dsp16xx_output_function_epilogue (file, size)\n \tfprintf (file, \"\\t%s=%sh-32\\n\", reg_names[REG_A1], a1h);\n       fprintf (file, \"\\t%s=%s\\n\", reg_names[REG_YBASE], a1h);\n     }\n+\n+  if (current_frame_info.function_makes_calls)\n+    fprintf( file, \"\\t%s=pop(*%s)\\n\", reg_names[RETURN_ADDRESS_REGNUM], sp );\n   \n   for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; --regno)\n     if (dsp16xx_call_saved_register(regno))\n       {\n-#if OLD_REGISTER_SAVE\n-\tif (!initial_stack_dec)\n-\t  {\n-\t    initial_stack_dec = 1;\n-\t    fprintf (file, \"\\t*%s--\\n\", sp);\n-\t  }\n-#endif\n-\n-#if OLD_REGISTER_SAVE\n-\tfprintf( file, \"\\t%s=*%s--\\n\", reg_names[regno], sp );\n-#else\n \tfprintf( file, \"\\t%s=pop(*%s)\\n\", reg_names[regno], sp );\n-#endif\n       }\n   \n-  /* If we restored any registers we have to account for the\n-     initial pre-decrement. But only if we had any local variables\n-     or spills. */\n-#if OLD_REGISTER_SAVE  \n-  if (initial_stack_dec) \n-    fprintf (file, \"\\t*%s++\\n\", sp);\n-#endif\n-  \n   if (current_frame_info.var_size)\n     {\n       if (current_frame_info.var_size == 1)\n \tfprintf (file, \"\\t*%s--\\n\", sp);\n       else\n \t{\n-\t  fprintf (file, \"\\t%s=%ld\\n\\t*%s++%s\\n\", \n+\t  fprintf (file, \"\\t%s=%d\\n\\t*%s++%s\\n\", \n \t\t   reg_names[REG_J], -current_frame_info.var_size, sp, reg_names[REG_J]);\n \t}\n     }\n@@ -1427,7 +1620,7 @@ double_reg_from_memory (operands)\n     else if (GET_CODE(XEXP(operands[1],0)) == PLUS)\n     {\n       rtx addr;\n-      int offset;\n+      int offset = 0;\n \n       output_asm_insn (\"%u0=%1\", operands);\n \n@@ -1477,7 +1670,7 @@ double_reg_to_memory (operands)\n     else if (GET_CODE(XEXP(operands[0],0)) == PLUS)\n     {\n       rtx addr;\n-      int offset;\n+      int offset = 0;\n \n       output_asm_insn (\"%0=%u1\", operands);\n \n@@ -1489,10 +1682,9 @@ double_reg_to_memory (operands)\n       else if (GET_CODE (XEXP(addr,1)) == CONST_INT)\n \toffset = INTVAL(XEXP(addr,1)) + 1;\n       else\n-\tabort ();\n+\tfatal_error (\"Invalid addressing mode\");\n \n-      fprintf (asm_out_file, \"\\t*(%d)=%s\\n\", offset + 31,\n-\t       reg_names[REGNO(operands[1]) + 1]);\n+      fprintf (asm_out_file, \"\\t*(%d)=%s\\n\", offset + 31, reg_names[REGNO(operands[1]) + 1]);\n     }\n     else\n     {\n@@ -1541,15 +1733,6 @@ override_options ()\n \t\t\t\t\tstrlen(const_seg_name) + 3);\n   sprintf (tmp, \".rsect \\\"%s\\\"\", const_seg_name);\n   \n-  if (optimize)\n-    {\n-      if (TARGET_OPTIMIZE_SPEED)\n-\t{\n-\t  flag_unroll_loops = 1;\n-\t  flag_inline_functions = 1;\n-\t}\n-    }\n-\n   /* Mark our global variables for GC.  */\n   ggc_add_rtx_root (&dsp16xx_addhf3_libcall, 1);\n   ggc_add_rtx_root (&dsp16xx_subhf3_libcall, 1);\n@@ -1574,13 +1757,31 @@ override_options ()\n   ggc_add_rtx_root (&dsp16xx_lshrhi3_libcall, 1);\n }\n \n+int\n+next_cc_user_unsigned (insn)\n+     rtx insn;\n+{\n+  switch (next_cc_user_code (insn))\n+    {\n+    case GTU:\n+    case GEU:\n+    case LTU:\n+    case LEU:\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+}\n \n enum rtx_code\n next_cc_user_code (insn)\n      rtx insn;\n {\n+  /* If no insn could be found we assume that the jump has been\n+     deleted and the compare will be deleted later. */\n+\n   if ( !(insn = next_cc0_user (insn)))\n-    abort ();\n+    return (enum rtx_code) 0;\n   else if (GET_CODE (insn) == JUMP_INSN\n \t   && GET_CODE (PATTERN (insn)) == SET\n \t   && GET_CODE (SET_SRC (PATTERN (insn))) == IF_THEN_ELSE)\n@@ -1593,22 +1794,6 @@ next_cc_user_code (insn)\n     abort ();\n }\n \n-int\n-next_cc_user_unsigned (insn)\n-     rtx insn;\n-{\n-  switch (next_cc_user_code (insn))\n-    {\n-    case GTU:\n-    case GEU:\n-    case LTU:\n-    case LEU:\n-      return 1;\n-    default:\n-      return 0;\n-    }\n-}\n-\n void\n print_operand(file, op, letter)\n      FILE *file;\n@@ -1689,19 +1874,57 @@ print_operand(file, op, letter)\n \telse if (letter == 'h')\n \t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, val);\n         else if (letter == 'U')\n-\t  fprintf (file, HOST_WIDE_INT_PRINT_HEX, (val >> 16) & 0xffff);\n+\t  fprintf(file, HOST_WIDE_INT_PRINT_HEX, (val >> 16) & 0xffff);\n         else\n-\t  output_addr_const (file, op);\n-      }\n-    else if (code == CONST_DOUBLE && GET_MODE (op) != DImode)\n+           output_addr_const( file, op );\n+    }\n+    else if( code == CONST_DOUBLE && GET_MODE(op) != DImode )\n+    {\n+\t  union { double d; int i[2]; } u;\n+\t  union { float f; int i; } u1;\n+\t  u.i[0] = CONST_DOUBLE_LOW (op);\n+\t  u.i[1] = CONST_DOUBLE_HIGH (op);\n+\t  u1.f = u.d;\n+          fprintf( file, \"0x%x\", u1.i );\n+    }\n+    else if (code == CONST)\n       {\n-\tunion {double d; int i[2]; } u;\n-\tunion {float f; int i; } u1;\n-\n-\tu.i[0] = CONST_DOUBLE_LOW (op);\n-\tu.i[1] = CONST_DOUBLE_HIGH (op);\n-\tu1.f = u.d;\n-\tfprintf (file, \"0x%x\", u1.i);\n+\trtx addr = XEXP (op, 0);\n+\t\n+\tif (GET_CODE (addr) != PLUS)\n+\t  {\n+\t    output_addr_const( file, op);\n+\t    return;\n+\t  }\n+\t\n+\tif ((GET_CODE (XEXP (addr, 0)) == SYMBOL_REF\n+\t     || GET_CODE (XEXP (addr, 0)) == LABEL_REF)\n+\t    && (GET_CODE (XEXP (addr, 1)) == CONST_INT))\n+\t  {\n+\t    int n = INTVAL (XEXP(addr, 1));\n+\t    output_addr_const (file, XEXP (addr, 0));\n+\t    \n+\t    if (n >= 0)\n+\t      fprintf (file, \"+\");\n+\t    \n+\t    n = (int) (short) n;\n+\t    fprintf (file, \"%d\", n);\n+\t  }\n+\telse if ((GET_CODE (XEXP (addr, 1)) == SYMBOL_REF\n+\t\t  || GET_CODE (XEXP (addr, 1)) == LABEL_REF)\n+\t\t && (GET_CODE (XEXP (addr, 0)) == CONST_INT))\n+\t  {\n+\t    int n = INTVAL (XEXP(addr, 0));\n+\t    output_addr_const (file, XEXP (addr, 1));\n+\t    \n+\t    if (n >= 0)\n+\t      fprintf (file, \"+\");\n+\t    \n+\t    n = (int) (short) n;\n+\t    fprintf (file, \"%d\", n);\n+\t  }\n+\telse\n+\t  output_addr_const( file, op);\n       }\n     else\n       output_addr_const (file, op);\n@@ -1714,7 +1937,7 @@ print_operand_address(file, addr)\n      rtx addr;\n {\n   rtx base;\n-  int offset;\n+  int offset = 0;;\n   \n   switch (GET_CODE (addr))\n     {\n@@ -1737,10 +1960,10 @@ print_operand_address(file, addr)\n \t  if (offset >= -31 && offset <= 0)\n \t    offset = 31 + offset;\n \t  else\n-\t    abort ();\n+\t    fatal_error (\"Invalid offset in ybase addressing\");\n \t}\n       else\n-\tabort ();\n+\tfatal_error (\"Invalid register in ybase addressing\");\n       \n       fprintf (file, \"*(%d)\", offset);\n       break;\n@@ -1777,17 +2000,22 @@ static int\n reg_save_size ()\n {\n   int reg_save_size = 0;\n- int regno;\n- \n+  int regno;\n+\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (dsp16xx_call_saved_register (regno))\n       {\n \treg_save_size += UNITS_PER_WORD;\n       }\n \n+  /* If the function makes calls we will save need to save the 'pr' register */\n+  if (current_frame_info.function_makes_calls)\n+    reg_save_size += 1;\n+\n   return (reg_save_size);\n }\n \n+#if 0\n int\n dsp16xx_starting_frame_offset()\n {\n@@ -1802,6 +2030,7 @@ dsp16xx_starting_frame_offset()\n \n   return (reg_save_size);\n }\n+#endif\n \n int\n initial_frame_pointer_offset()\n@@ -1913,7 +2142,7 @@ emit_1600_core_shift (shift_op, operands, shift_amount)\n       shift_asm_ptr_first = lshift_right_asm_first;\n     }\n   else\n-    abort ();\n+    fatal_error (\"Invalid shift operator in emit_1600_core_shift\");\n \n   while (shift_amount != 0)\n     {\n@@ -1956,6 +2185,57 @@ emit_1600_core_shift (shift_op, operands, shift_amount)\n     }\n }\n #endif\n+\n+int\n+num_1600_core_shifts (shift_amount)\n+int shift_amount;\n+{\n+  int quotient;\n+  int i;\n+  int first_shift_emitted = 0;\n+  int num_shifts = 0;\n+\n+  while (shift_amount != 0)\n+    {\n+      if (shift_amount/16)\n+\t{\n+\t  quotient = shift_amount/16;\n+\t  shift_amount = shift_amount - (quotient * 16);\n+\t  for (i = 0; i < quotient; i++)\n+\t    num_shifts++;\n+\t  first_shift_emitted = 1;\n+\t}\n+      else if (shift_amount/8)\n+\t{\n+\t  quotient = shift_amount/8;\n+\t  shift_amount = shift_amount - (quotient * 8);\n+\t  for (i = 0; i < quotient; i++)\n+\t    num_shifts++;\n+\n+\t  first_shift_emitted = 1;\n+\t}\n+      else if (shift_amount/4)\n+\t{\n+\t  quotient = shift_amount/4;\n+\t  shift_amount = shift_amount - (quotient * 4);\n+\t  for (i = 0; i < quotient; i++)\n+\t    num_shifts++;\n+\n+\t  first_shift_emitted = 1;\n+\t}\n+      else if (shift_amount/1)\n+\t{\n+\t  quotient = shift_amount/1;\n+\t  shift_amount = shift_amount - (quotient * 1);\n+\t  for (i = 0; i < quotient; i++)\n+\t    num_shifts++;\n+\n+\t  first_shift_emitted = 1;\n+\t}\n+    }\n+  return num_shifts;\n+}\n+\n void\n asm_output_common(file, name, size, rounded)\n      FILE *file;\n@@ -2134,6 +2414,9 @@ dsp16xx_function_arg (args_so_far, mode, type, named)\n \t  && (mode == HImode || GET_MODE_CLASS(mode) == MODE_FLOAT))\n \targs_so_far++;\n \n+      if (type == void_type_node)\n+\treturn (struct rtx_def *) 0;\n+\n       if (named && args_so_far < 4 && !MUST_PASS_IN_STACK (mode,type))\n \treturn gen_rtx_REG (mode, args_so_far + FIRST_REG_FOR_FUNCTION_ARG);\n       else\n@@ -2166,13 +2449,50 @@ dsp16xx_function_arg_advance (cum, mode, type, named)\n }\n \n void\n-dsp16xx_file_start ()\n+coff_dsp16xx_file_start (file)\n+     FILE *file;\n {\n-  fprintf (asm_out_file, \"#include <%s.h>\\n\", save_chip_name);\n-#if 0\n-\tif (TARGET_BMU)\n-\t\tfprintf (asm_out_file, \"#include <1610.h>\\n\");\n+  fprintf (file, \"#include <%s.h>\\n\", save_chip_name);\n+}\n+\n+void\n+luxworks_dsp16xx_file_start (file)\n+     FILE *file;\n+{\n+  char *temp_filename;\n+  int len, err_code;\n+\n+\n+  fprintf(file, \"\\t.debug \");\n+  err_code = (TARGET_DEBUG) ? fprintf (file, \"yes, \") : fprintf (file, \"no, \");\n+  err_code = (TARGET_SAVE_TEMPS) ? fprintf (file, \"asm, \") : fprintf (file, \"temp, \");\n+  len = strlen (main_input_filename);\n+  temp_filename = (char *) xmalloc (len + 2);\n+  strcpy (temp_filename, main_input_filename);\n+#ifdef __CYGWIN32__\n+    p = temp_filename;\n+    while (*p != '\\0') {\n+    if (*p == '\\\\')\n+        *p = '/';\n+         p++;\n+         }\n #endif\n+    fprintf(file, \"\\\"%s\\\"\\n\", temp_filename);\n+    fprintf(file, \"\");\n+\n+  fprintf (file, \"#include <%s.h>\\n\", save_chip_name);\n+\n+   /*\n+    * Add dummy sections, so that they always exist in the \n+    * object code. These have been created so that the number and\n+    * type of sections remain consistent with and without -g option. Note\n+    * that the .data, .text, .const and .bss are always created when -g\n+    * is provided as an option. \n+    */\n+   fprintf(file, \"\\t.rsect \\\".text\\\" , nodelete\\n\");\n+   fprintf(file, \"\\t.rsect \\\".data\\\" , nodelete\\n\");\n+   fprintf(file, \"\\t.rsect \\\".const\\\" , nodelete\\n\");\n+   fprintf(file, \"\\t.rsect \\\".bss\\\" , nodelete\\n\");\n }\n \n rtx\n@@ -2192,7 +2512,7 @@ gen_tst_reg (x)\n   else if (mode == HImode)\n     emit_insn (gen_rtx_SET (VOIDmode, cc0_rtx, x));\n   else\n-    abort ();\n+    fatal_error (\"Invalid mode for gen_tst_reg\");\n \n   return cc0_rtx;\n }\n@@ -2243,28 +2563,19 @@ gen_compare_reg (code, x, y)\n       if (code == GTU || code == GEU\n \t  || code == LTU || code == LEU)\n \t{\n-#if 1\n-\t  emit_insn (gen_rtx_PARALLEL\n-\t\t     (VOIDmode,\n+\t  emit_insn (gen_rtx_PARALLEL \n+\t\t     (VOIDmode, \n \t\t      gen_rtvec (5,\n-\t\t\t\t gen_rtx_SET (VOIDmode, cc0_rtx,\n-\t\t\t\t\t      gen_rtx_COMPARE (VOIDmode,\n-\t\t\t\t\t\t\t       x, y)),\n-\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t gen_rtx_SET (VOIDmode, cc0_rtx, \n+\t\t\t\t\t      gen_rtx_COMPARE (VOIDmode, x, y)),\n+\t\t\t\t gen_rtx_CLOBBER (VOIDmode, \n \t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)),\n-\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t gen_rtx_CLOBBER (VOIDmode, \n \t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)),\n-\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t gen_rtx_CLOBBER (VOIDmode, \n \t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)),\n-\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t gen_rtx_CLOBBER (VOIDmode, \n \t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)))));\n-#else\n-\t  if (!dsp16xx_ucmphi2_libcall)\n-\t    dsp16xx_ucmphi2_libcall = gen_rtx_SYMBOL_REF (Pmode, UCMPHI2_LIBCALL);\n-\t  emit_library_call (dsp16xx_ucmphi2_libcall, 1, HImode, 2,\n-\t\t\t     x, HImode, y, HImode);\n-\t  emit_insn (gen_tsthi_1 (copy_to_reg(hard_libcall_value (HImode))));\n-#endif\n \t}\n       else\n \temit_insn (gen_rtx_SET (VOIDmode, cc0_rtx,\n@@ -2273,7 +2584,7 @@ gen_compare_reg (code, x, y)\n \t\t\t\t\t\t force_reg (HImode,y))));\n     }\n   else\n-    abort ();\n+    fatal_error (\"Invalid mode for integer comparison in gen_compare_reg\");\n \n   return cc0_rtx;\n }\n@@ -2297,3 +2608,49 @@ output_block_move (operands)\n   fprintf (asm_out_file, \"\\t}\\n\");\n   return \"\";\n }\n+\n+int\n+uns_comparison_operator (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (mode == VOIDmode || GET_MODE (op) == mode)\n+    {\n+      enum rtx_code code;\n+      \n+      code = GET_CODE(op);\n+\n+      if (code == LEU || code == LTU || code == GEU\n+\t  || code == GTU)\n+\t{\n+\t  return 1;\n+\t}\n+      else\n+\treturn 0;\n+    }\n+\n+  return 0;\n+}\n+\n+int\n+signed_comparison_operator (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (mode == VOIDmode || GET_MODE (op) == mode)\n+    {\n+      enum rtx_code code;\n+      \n+      code = GET_CODE(op);\n+\n+      if (!(code == LEU || code == LTU || code == GEU\n+\t  || code == GTU))\n+\t{\n+\t  return 1;\n+\t}\n+      else\n+\treturn 0;\n+    }\n+\n+  return 0;\n+}"}, {"sha": "dae1d742c493dfe905fdac23675afe777f93b123", "filename": "gcc/config/dsp16xx/dsp16xx.h", "status": "modified", "additions": 191, "deletions": 137, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dff06f62c97fee80fc8f7e4f44ee993ffdacf6ad/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dff06f62c97fee80fc8f7e4f44ee993ffdacf6ad/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h?ref=dff06f62c97fee80fc8f7e4f44ee993ffdacf6ad", "patch": "@@ -1,7 +1,7 @@\n /* Definitions of target machine for GNU compiler.  AT&T DSP1600.\n    Copyright (C) 1994, 1995, 1996, 1997, 1998, 2000, 2001\n    Free Software Foundation, Inc.\n-   Contributed by Michael Collison (collison@world.std.com).\n+   Contributed by Michael Collison (collison@isisinc.net).\n \n This file is part of GNU CC.\n \n@@ -74,7 +74,9 @@ extern struct rtx_def *dsp16xx_lshrhi3_libcall;\n #ifdef  CC1_SPEC\n #undef  CC1_SPEC\n #endif\n-#define CC1_SPEC       \"\"\n+#define CC1_SPEC       \"%{!O*:-O}\"\n+\n+#define CPP_SPEC       \"%{!O*:-D__OPTIMIZE__}\"\n \n /* Define this as a spec to call the AT&T assembler */\n \n@@ -111,22 +113,29 @@ extern struct rtx_def *dsp16xx_lshrhi3_libcall;\n \n \n /* Tell gcc where to look for the startfile */\n-#define STANDARD_STARTFILE_PREFIX   \"/d1600/lib\"\n+/*#define STANDARD_STARTFILE_PREFIX   \"/d1600/lib\"*/\n \n-/* Tell gcc where to look for its executables */\n-#define STANDARD_EXEC_PREFIX  \"/d1600/bin\"\n+/* Tell gcc where to look for it's executables */\n+/*#define STANDARD_EXEC_PREFIX  \"/d1600/bin\"*/\n \n /* Command line options to the AT&T assembler */\n-#define ASM_SPEC  \"%{v:-V} %{g*:-g}\"\n+#define ASM_SPEC  \"%{V} %{v:%{!V:-V}} %{g*:-g}\"\n \n /* Command line options for the AT&T linker */\n-#define LINK_SPEC \"%{v:-V} %{minit:-i}  \\\n-%{!ifile*:%{mmap1:-ifile m1_deflt.if%s}         \\\n-          %{mmap2:-ifile m2_deflt.if%s}         \\\n-          %{mmap3:-ifile m3_deflt.if%s}         \\\n-          %{mmap4:-ifile m4_deflt.if%s}         \\\n-          %{!mmap*:-ifile m4_deflt.if%s}}       \\\n-%{ifile*} %{!r:-a}\"\n+\n+#define LINK_SPEC \"%{V} %{v:%{!V:-V}} %{minit:-i}  \\\n+%{!ifile*:%{mmap1:m1_deflt.if%s}         \\\n+          %{mmap2:m2_deflt.if%s}         \\\n+          %{mmap3:m3_deflt.if%s}         \\\n+          %{mmap4:m4_deflt.if%s}         \\\n+          %{!mmap*:m4_deflt.if%s}}       \\\n+%{ifile*:%*} %{r}\"\n+\n+/* Include path is determined from the environment variable */\n+#define INCLUDE_DEFAULTS     \\\n+{                            \\\n+  { 0, 0, 0 }                \\\n+}\n \n /* Names to predefine in the preprocessor for this target machine.  */\n #ifdef __MSDOS__\n@@ -145,17 +154,16 @@ extern int target_flags;\n #define MASK_NEAR_CALL       0x00000002    /* The call is on the same 4k page */\n #define MASK_NEAR_JUMP       0x00000004    /* The jump is on the same 4k page */\n #define MASK_BMU             0x00000008    /* Use the 'bmu' shift instructions */\n-#define MASK_OPTIMIZE_MEMORY 0x00000010    /* Optimize to conserve memory */\n-#define MASK_OPTIMIZE_SPEED  0x00000020    /* Optimize for speed */\n #define MASK_MAP1            0x00000040    /* Link with map1 */\n #define MASK_MAP2            0x00000080    /* Link with map2 */\n #define MASK_MAP3            0x00000100    /* Link with map3 */\n #define MASK_MAP4            0x00000200    /* Link with map4 */\n #define MASK_YBASE_HIGH      0x00000400    /* The ybase register window starts high */\n #define MASK_INIT\t     0x00000800    /* Have the linker generate tables to\n \t\t\t\t\t      initialize data at startup */\n-#define MASK_INLINE_MULT     0x00001000    /* Inline 32 bit multiplies */\n #define MASK_RESERVE_YBASE   0x00002000    /* Reserved the ybase registers */\n+#define MASK_DEBUG           0x00004000\t   /* Debugging turned on*/\n+#define MASK_SAVE_TEMPS      0x00008000    /* Save temps. option seen */\n \n /* Compile passing first two args in regs 0 and 1.\n    This exists only to test compiler features that will\n@@ -177,12 +185,6 @@ extern int target_flags;\n    Unit. */\n #define TARGET_BMU (target_flags & MASK_BMU)\n \n-/* Optimize to conserve memory */\n-#define TARGET_OPTIMIZE_MEMORY (target_flags & MASK_OPTIMIZE_MEMORY)\n-\n-/* Optimize for maximum speed */\n-#define TARGET_OPTIMIZE_SPEED   (target_flags & MASK_OPTIMIZE_SPEED)\n-\n #define TARGET_YBASE_HIGH (target_flags & MASK_YBASE_HIGH)\n \n /* Direct the linker to output extra info for initialized data */\n@@ -193,38 +195,60 @@ extern int target_flags;\n /* Reserve the ybase registers *(0) - *(31) */\n #define TARGET_RESERVE_YBASE (target_flags & MASK_RESERVE_YBASE)\n \n+/* We turn this option on internally after seeing \"-g\" */\n+#define TARGET_DEBUG            (target_flags & MASK_DEBUG)\n+\n+/* We turn this option on internally after seeing \"-save-temps */\n+#define TARGET_SAVE_TEMPS       (target_flags & MASK_SAVE_TEMPS)\n+\n+\n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n    each pair being { \"NAME\", VALUE }\n    where VALUE is the bits to set or minus the bits to clear.\n    An empty string NAME is used to identify the default VALUE.  */\n \n \n-#define TARGET_SWITCHES                        \\\n-  {\t\t\t\t               \\\n-    { \"regparm\",       MASK_REGPARM},\t       \\\n-    { \"no-regparm\",   -MASK_REGPARM},\t       \\\n-    { \"no-near-call\", -MASK_NEAR_CALL},        \\\n-    { \"near-jump\",     MASK_NEAR_JUMP},        \\\n-    { \"no-near-jump\", -MASK_NEAR_JUMP},        \\\n-    { \"bmu\",           MASK_BMU},              \\\n-    { \"no-bmu\",       -MASK_BMU},              \\\n-    { \"Om\",            MASK_OPTIMIZE_MEMORY},  \\\n-    { \"Os\",            MASK_OPTIMIZE_SPEED},   \\\n-    { \"map1\",          MASK_MAP1},             \\\n-    { \"map2\",          MASK_MAP2},             \\\n-    { \"map3\",          MASK_MAP3},             \\\n-    { \"map4\",          MASK_MAP4},             \\\n-    { \"ybase-high\",    MASK_YBASE_HIGH},       \\\n-    { \"init\",          MASK_INIT},             \\\n-    { \"inline-mult\",   MASK_INLINE_MULT},      \\\n-    { \"reserve-ybase\", MASK_RESERVE_YBASE},    \\\n-    { \"\",              TARGET_DEFAULT}         \\\n+#define TARGET_SWITCHES                                           \\\n+  {\t\t\t\t                                  \\\n+    { \"regparm\",       MASK_REGPARM,                              \\\n+      N_(\"Pass parameters in registers (default)\") },             \\\n+    { \"no-regparm\",   -MASK_REGPARM,\t                          \\\n+      N_(\"Don't pass parameters in registers\") },                 \\\n+    { \"near-call\",     MASK_NEAR_JUMP,                            \\\n+      N_(\"Generate code for near calls\") },                       \\\n+    { \"no-near-call\", -MASK_NEAR_CALL,                            \\\n+      N_(\"Don't generate code for near calls\") },                 \\\n+    { \"near-jump\",     MASK_NEAR_JUMP,                            \\\n+      N_(\"Generate code for near jumps\") },                       \\\n+    { \"no-near-jump\", -MASK_NEAR_JUMP,                            \\\n+      N_(\"Don't generate code for near jumps\") },                 \\\n+    { \"bmu\",           MASK_BMU,                                  \\\n+      N_(\"Generate code for a bit-manipulation unit\") },          \\\n+    { \"no-bmu\",       -MASK_BMU,                                  \\\n+      N_(\"Don't generate code for a bit-manipulation unit\") },    \\\n+    { \"map1\",          MASK_MAP1,                                 \\\n+      N_(\"Generate code for memory map1\") },                      \\\n+    { \"map2\",          MASK_MAP2,                                 \\\n+      N_(\"Generate code for memory map2\") },                      \\\n+    { \"map3\",          MASK_MAP3,                                 \\\n+      N_(\"Generate code for memory map3\") },                      \\\n+    { \"map4\",          MASK_MAP4,                                 \\\n+      N_(\"Generate code for memory map4\") },                      \\\n+    { \"init\",          MASK_INIT,                                 \\\n+      N_(\"Ouput extra code for initialized data\") },              \\\n+    { \"reserve-ybase\", MASK_RESERVE_YBASE,                        \\\n+      N_(\"Don't let reg. allocator use ybase registers\") },       \\\n+    { \"debug\",         MASK_DEBUG,                                \\\n+      N_(\"Output extra debug info in Luxworks environment\") },    \\\n+    { \"save-temporaries\",    MASK_SAVE_TEMPS,                     \\\n+      N_(\"Save temp. files in Luxworks environment\") },           \\\n+    { \"\",              TARGET_DEFAULT, \"\"}                        \\\n   }\n \n /* Default target_flags if no switches are specified */\n #ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT  MASK_OPTIMIZE_MEMORY|MASK_REGPARM|MASK_YBASE_HIGH\n+#define TARGET_DEFAULT  MASK_REGPARM|MASK_YBASE_HIGH\n #endif\n \n /* This macro is similar to `TARGET_SWITCHES' but defines names of\n@@ -246,11 +270,16 @@ extern int target_flags;\n \n #define TARGET_OPTIONS\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n-  { \"text=\",\t&text_seg_name\t},\t\t\t\t\\\n-  { \"data=\",\t&data_seg_name\t},\t\t\t\t\\\n-  { \"bss=\",\t&bss_seg_name\t},\t\t\t\t\\\n-  { \"const=\",   &const_seg_name },                              \\\n-  { \"chip=\",    &chip_name      }                               \\\n+  { \"text=\",\t&text_seg_name,\t\t\t\t        \\\n+    N_(\"Specify alternate name for text section\") },            \\\n+  { \"data=\",\t&data_seg_name,\t\t\t\t        \\\n+    N_(\"Specify alternate name for data section\") },            \\\n+  { \"bss=\",\t&bss_seg_name,\t\t\t\t        \\\n+    N_(\"Specify alternate name for bss section\") },             \\\n+  { \"const=\",   &const_seg_name,                                \\\n+    N_(\"Specify alternate name for constant section\") },        \\\n+  { \"chip=\",    &chip_name,                                     \\\n+    N_(\"Specify alternate name for dsp16xx chip\") },            \\\n }\n \n /* Sometimes certain combinations of command options do not make sense\n@@ -264,18 +293,21 @@ extern int target_flags;\n \n #define OVERRIDE_OPTIONS override_options ()\n \n-#define OPTIMIZATION_OPTIONS(LEVEL,SIZE)\t\t\\\n-do\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\\\n-    flag_gnu_linker             = FALSE;\t\t\\\n-\t\t\t\t\t\t\t\\\n-    if (SIZE)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tflag_strength_reduce    = FALSE;\t\t\\\n-\tflag_inline_functions   = FALSE;\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\\\n-while (0)\n+#define OPTIMIZATION_OPTIONS(LEVEL,SIZE)              \\\n+{                                                     \\\n+    flag_gnu_linker             = FALSE;              \\\n+                                                      \\\n+    if (LEVEL >= 2)                                   \\\n+    {                                                 \\\n+        /* The dsp16xx family has so few registers    \\\n+         * that running the first instruction         \\\n+         * scheduling is bad for reg. allocation      \\\n+         * since it increases lifetimes of pseudos.   \\\n+         * So turn of first scheduling pass.          \\\n+         */                                           \\\n+        flag_schedule_insns          = FALSE;         \\\n+    }                                                 \\\n+}\n \f\n /* STORAGE LAYOUT */\n \n@@ -287,7 +319,7 @@ while (0)\n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.\n  */\n-#define BITS_BIG_ENDIAN  1\n+#define BITS_BIG_ENDIAN  0\n \n /* Define this if most significant byte of a word is the lowest numbered.\n    We define big-endian, but since the 1600 series cannot address bytes\n@@ -377,12 +409,13 @@ while (0)\n /* A C expression for a string describing the name of the data type to use for\n    size values. */\n \n-#define SIZE_TYPE    \"long unsigned int\"\n+#define SIZE_TYPE    \"unsigned int\"\n \n-/* A C expression for a string describing the name of the datat type to use for the\n+/* A C expression for a string describing the name of the data type to use for the\n    result of subtracting two pointers */\n \n-#define PTRDIFF_TYPE \"long int\"\n+#define PTRDIFF_TYPE \"int\"\n+\n \f\n /* REGISTER USAGE.  */\n \n@@ -475,6 +508,10 @@ while (0)\n /* Do we have a virtual ybase register */\n #define IS_YBASE_REGISTER_WINDOW(REGNO) ((REGNO) >= REG_YBASE0 && (REGNO) <= REG_YBASE31)\n \n+#define IS_YBASE_ELIGIBLE_REG(REGNO) (IS_ACCUM_REG (REGNO) || IS_ADDRESS_REGISTER(REGNO) \\\n+                                      || REGNO == REG_X || REGNO == REG_Y || REGNO == REG_YL \\\n+                                      || REGNO == REG_PROD || REGNO == REG_PRODL)\n+\n #define IS_ADDRESS_REGISTER(REGNO) ((REGNO) >= REG_R0 && (REGNO) <= REG_R3)\n \n #define FIXED_REGISTERS     \\\n@@ -483,7 +520,7 @@ while (0)\n  1,                         \\\n  0, 0, 0, 0,                \\\n  1, 1, 1,                   \\\n- 0, 0,                      \\\n+ 1, 0,                      \\\n  0, 0, 0, 0, 0, 0, 0, 0,    \\\n  0, 0, 0, 0, 0, 0, 0, 0,    \\\n  0, 0, 0, 0, 0, 0, 0, 0,    \\\n@@ -501,24 +538,25 @@ while (0)\n    bit manipulation registers.  */\n \n \n-#define CALL_USED_REGISTERS   \\\n-{1, 1, 1, 1, 0, 1, 1, 1, 1,   \\\n- 1, 0, 0, 1, 1, 1, 1,         \\\n- 1,                           \\\n- 0, 0, 1, 1,                  \\\n- 1, 1, 1,                     \\\n- 0, 1,                        \\\n- 0, 0, 0, 0, 0, 0, 0, 0,      \\\n- 0, 0, 0, 0, 0, 0, 0, 0,      \\\n- 0, 0, 0, 0, 0, 0, 0, 0,      \\\n- 0, 0, 0, 0, 0, 0, 0, 0}\n+#define CALL_USED_REGISTERS\t\t\t\\\n+{1, 1, 1, 1, 0, 1, 1, 1, 1,\t/* 0-8 */\t\\\n+ 1, 0, 0, 1, 1, 1, 1,\t\t/* 9-15 */\t\\\n+ 1,                             /* 16 */\t\\\n+ 0, 0, 1, 1,\t\t\t/* 17-20 */\t\\\n+ 1, 1, 1,\t\t\t/* 21-23 */\t\\\n+ 1, 1,\t\t\t\t/* 24-25 */\t\\\n+ 0, 0, 0, 0, 0, 0, 0, 0,\t/* 26-33 */\t\\\n+ 0, 0, 0, 0, 0, 0, 0, 0,\t/* 34-41 */\t\\\n+ 0, 0, 0, 0, 0, 0, 0, 0,\t/* 42-49 */\t\\\n+ 0, 0, 0, 0, 0, 0, 0, 0}\t/* 50-57 */\n \n /* List the order in which to allocate registers.  Each register must be\n    listed once, even those in FIXED_REGISTERS.\n \n    We allocate in the following order:\n  */\n \n+#if 0\n #define REG_ALLOC_ORDER\t\t\t\t\t\\\n { REG_R0, REG_R1, REG_R2, REG_PROD, REG_Y, REG_X,       \\\n   REG_PRODL, REG_YL, REG_AR0, REG_AR1,                  \\\n@@ -534,7 +572,24 @@ while (0)\n   REG_YBASE20, REG_YBASE21, REG_YBASE22, REG_YBASE23,   \\\n   REG_YBASE24, REG_YBASE25, REG_YBASE26, REG_YBASE27,   \\\n   REG_YBASE28, REG_YBASE29, REG_YBASE30, REG_YBASE31 }\n-\n+#else\n+#define REG_ALLOC_ORDER                                 \\\n+{                                                       \\\n+  REG_A0, REG_A0L, REG_A1, REG_A1L, REG_Y, REG_YL,      \\\n+  REG_PROD,                                             \\\n+  REG_PRODL, REG_R0, REG_J, REG_K, REG_AR2, REG_AR3,    \\\n+  REG_X, REG_R1, REG_R2, REG_RB, REG_AR0, REG_AR1,      \\\n+  REG_YBASE0, REG_YBASE1, REG_YBASE2, REG_YBASE3,       \\\n+  REG_YBASE4, REG_YBASE5, REG_YBASE6, REG_YBASE7,       \\\n+  REG_YBASE8, REG_YBASE9, REG_YBASE10, REG_YBASE11,     \\\n+  REG_YBASE12, REG_YBASE13, REG_YBASE14, REG_YBASE15,   \\\n+  REG_YBASE16, REG_YBASE17, REG_YBASE18, REG_YBASE19,   \\\n+  REG_YBASE20, REG_YBASE21, REG_YBASE22, REG_YBASE23,   \\\n+  REG_YBASE24, REG_YBASE25, REG_YBASE26, REG_YBASE27,   \\\n+  REG_YBASE28, REG_YBASE29, REG_YBASE30, REG_YBASE31,   \\\n+  REG_R3, REG_YBASE, REG_PT, REG_C0, REG_C1, REG_C2,    \\\n+  REG_PR }\n+#endif\n /* Zero or more C statements that may conditionally modify two\n    variables `fixed_regs' and `call_used_regs' (both of type `char\n    []') after they have been initialized from the two preceding\n@@ -978,23 +1033,32 @@ enum reg_class\n    'I' requires a non-negative 16-bit value.\n    'J' requires a non-negative 9-bit value\n    'K' requires a constant 0 operand.\n-   'L' requires 16-bit value\n+   'L' constant for use in add or sub from low 16-bits\n    'M' 32-bit value -- low 16-bits zero\n+   'N' constant for use incrementing or decrementing a address register\n+   'O' constant for use with and'ing only high 16-bit\n+   'P' constant for use with and'ing only low 16-bit\n  */\n \n #define SMALL_INT(X) (SMALL_INTVAL (INTVAL (X)))\n #define SMALL_INTVAL(I) ((unsigned) (I) < 0x10000)\n #define SHORT_IMMEDIATE(X)  (SHORT_INTVAL (INTVAL(X)))\n #define SHORT_INTVAL(I)     ((unsigned) (I) < 0x100)\n+#define ADD_LOW_16(I)       ((I) >= 0 && (I) <= 32767)\n+#define ADD_HIGH_16(I)      (((I) & 0x0000ffff) == 0)\n+#define AND_LOW_16(I)       ((I) >= 0 && (I) <= 32767)\n+#define AND_HIGH_16(I)      (((I) & 0x0000ffff) == 0)\n \n #define CONST_OK_FOR_LETTER_P(VALUE, C)                           \\\n    ((C) == 'I' ? (SMALL_INTVAL(VALUE))                            \\\n     : (C) == 'J' ? (SHORT_INTVAL(VALUE))                          \\\n     : (C) == 'K' ? ((VALUE) == 0)                                 \\\n-    : (C) == 'L' ? ! ((VALUE) & ~0x0000ffff)\t                  \\\n-    : (C) == 'M' ? ! ((VALUE) & ~0xffff0000)\t                  \\\n-    : (C) == 'N' ? ((VALUE) == -1 || (VALUE) == 1 ||              \\\n-                    (VALUE) == -2 || (VALUE) == 2)                \\\n+    : (C) == 'L' ? ((VALUE) >= 0 && (VALUE) <= 32767)             \\\n+    : (C) == 'M' ? (((VALUE) & 0x0000ffff) == 0)                  \\\n+    : (C) == 'N' ? ((VALUE) == -1 || (VALUE) == 1                 \\\n+                    || (VALUE) == -2 || (VALUE) == 2)             \\\n+    : (C) == 'O' ? (((VALUE) & 0xffff0000) == 0xffff0000)         \\\n+    : (C) == 'P' ? (((VALUE) & 0x0000ffff) == 0xffff)             \\\n     : 0)\n \n #define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)   1\n@@ -1043,13 +1107,16 @@ struct dsp16xx_frame_info\n   unsigned int  reg_size;\t/* # bytes needed to store regs */\n   long\t\tfp_save_offset;\t/* offset from vfp to store registers */\n   unsigned long sp_save_offset;\t/* offset from new sp to store registers */\n+  int\t\tpr_save_offset;\t/* offset to saved PR */\n   int\t\tinitialized;\t/* != 0 if frame size already calculated */\n   int\t\tnum_regs;\t/* number of registers saved */\n   int           function_makes_calls;  /* Does the function make calls */\n };\n \n extern struct dsp16xx_frame_info current_frame_info;\n \n+#define RETURN_ADDR_OFF current_frame_info.pr_save_offset\n+\n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by. */\n /* #define PUSH_ROUNDING(BYTES) ((BYTES)) */\n@@ -1402,7 +1469,7 @@ extern struct dsp16xx_frame_info current_frame_info;\n    return it with a return statement. */\n #define CONST_COSTS(RTX,CODE,OUTER_CODE)                                \\\n   case CONST_INT:\t\t\t\t\t\t        \\\n-    return 0;                                                           \\\n+    return (unsigned) INTVAL (RTX) < 65536 ? 0 : 2;                     \\\n   case LABEL_REF:\t\t\t\t\t\t        \\\n   case SYMBOL_REF:\t\t\t\t\t\t        \\\n   case CONST:\t\t\t\t\t\t\t\t\\\n@@ -1427,45 +1494,21 @@ extern struct dsp16xx_frame_info current_frame_info;\n     else                                                        \\\n         return COSTS_N_INSNS (38);                              \\\n   case PLUS:                                                    \\\n-    if (GET_MODE_CLASS (GET_MODE (X)) == MODE_INT)              \\\n-    {                                                           \\\n-        if (GET_CODE (XEXP (X,1)) == CONST_INT)                 \\\n-        {                                                       \\\n-            int number = INTVAL(XEXP (X,1));                    \\\n-            if (number == 1)                                    \\\n-               return COSTS_N_INSNS (1);                        \\\n-            if (INT_FITS_16_BITS(number))                       \\\n-                return COSTS_N_INSNS (2);                       \\\n-            else                                                \\\n-                return COSTS_N_INSNS (4);                       \\\n-        }                                                       \\\n-        return COSTS_N_INSNS (1);                               \\\n-    }                                                           \\\n-    else                                                        \\\n-        return COSTS_N_INSNS (38);                              \\\n   case MINUS:                                                   \\\n     if (GET_MODE_CLASS (GET_MODE (X)) == MODE_INT)              \\\n-    {                                                           \\\n-        if (GET_CODE (XEXP (X,1)) == CONST_INT)                 \\\n         {                                                       \\\n-            if (INT_FITS_16_BITS(INTVAL(XEXP(X,1))))            \\\n-                return COSTS_N_INSNS (2);                       \\\n-            else                                                \\\n-                return COSTS_N_INSNS (4);                       \\\n+          return (1 +                                           \\\n+                  rtx_cost (XEXP (X, 0), CODE) +                \\\n+                  rtx_cost (XEXP (X, 1), CODE));                \\\n         }                                                       \\\n-        return COSTS_N_INSNS (1);                               \\\n-    }                                                           \\\n     else                                                        \\\n         return COSTS_N_INSNS (38);                              \\\n+                                                                \\\n   case AND: case IOR: case XOR:                                 \\\n-    if (GET_CODE (XEXP (X,1)) == CONST_INT)                     \\\n-      {                                                         \\\n-        if (INT_FITS_16_BITS(INTVAL(XEXP(X,1))))                \\\n-            return COSTS_N_INSNS (2);                           \\\n-        else                                                    \\\n-            return COSTS_N_INSNS (4);                           \\\n-      }                                                         \\\n-    return COSTS_N_INSNS (1);                                   \\\n+        return (1 +                                             \\\n+                rtx_cost (XEXP (X, 0), CODE) +                  \\\n+                rtx_cost (XEXP (X, 1), CODE));                  \\\n+                                                                \\\n   case NEG: case NOT:                                           \\\n     return COSTS_N_INSNS (1);                                   \\\n   case ASHIFT:                                                  \\\n@@ -1478,9 +1521,17 @@ extern struct dsp16xx_frame_info current_frame_info;\n             number == 16)                                       \\\n             return COSTS_N_INSNS (1);                           \\\n         else                                                    \\\n+\t{                                                       \\\n+          if (TARGET_BMU)                                       \\\n             return COSTS_N_INSNS (2);                           \\\n+          else                                                  \\\n+            return COSTS_N_INSNS (num_1600_core_shifts(number)); \\\n+\t}                                                       \\\n       }                                                         \\\n-    return COSTS_N_INSNS (1);\n+    if (TARGET_BMU)                                             \\\n+      return COSTS_N_INSNS (1);                                 \\\n+    else                                                        \\\n+      return COSTS_N_INSNS (15);\n \n /* An expression giving the cost of an addressing mode that contains\n    address. */\n@@ -1500,7 +1551,7 @@ extern struct dsp16xx_frame_info current_frame_info;\n \n /* A C expression for the cost of a branch instruction. A value of\n    1 is the default; */\n-#define BRANCH_COST 2\n+#define BRANCH_COST 1\n \f\n \n /* Define this because otherwise gcc will try to put the function address\n@@ -1566,11 +1617,15 @@ const_section ()                                                   \\\n /* THE OVERALL FRAMEWORK OF AN ASSEMBLER FILE */\n \n /* Output at beginning of assembler file.  */\n-#define ASM_FILE_START(FILE) dsp16xx_file_start () \n+#define ASM_FILE_START(FILE) coff_dsp16xx_file_start (FILE) \n+\n+/* Prevent output of .gcc_compiled */\n+#define ASM_IDENTIFY_GCC(FILE)   \n \n /* A C string constant describing how to begin a comment in the target\n    assembler language. */\n-/* define ASM_COMMENT_START */\n+#define ASM_COMMENT_START \"\"\n+#define ASM_COMMENT_END \"\"\n \n /* Output to assembler file text saying following lines\n    may contain character constants, extra white space, comments, etc.  */\n@@ -1605,9 +1660,7 @@ const_section ()                                                   \\\n #define ASM_OUTPUT_INT(FILE, EXP)    asm_output_long(FILE,INTVAL(EXP))\n \n /* This is how to output an assembler line for a numeric constant byte.  */\n-#define ASM_OUTPUT_BYTE(FILE,VALUE) \\\n-  fprintf ((FILE), \"\\tint %ld\\n\", (long)(VALUE))\n-\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)    ASM_OUTPUT_CHAR(FILE,GEN_INT(VALUE))\n \n /* This is how we output a 'c' character string. For the 16xx\n    assembler we have to do it one letter at a time */\n@@ -1643,7 +1696,7 @@ const_section ()                                                   \\\n \t      fprintf (asm_out_file, \"%d\", c);\t\t\t              \\\n \t      /* After an octal-escape, if a digit follows,\t\t      \\\n \t\t terminate one string constant and start another.\t      \\\n-\t\t The VAX assembler fails to stop reading the escape\t      \\\n+\t\t The Vax assembler fails to stop reading the escape\t      \\\n \t\t after three digits, so this is the only way we\t\t      \\\n \t\t can get it to parse the data properly.  \t\t      \\\n \t      if (i < thissize - 1\t\t\t\t\t      \\\n@@ -1683,6 +1736,10 @@ const_section ()                                                   \\\n     (OUTPUT) = (char *) alloca (strlen (NAME) + 11);\t\t\t\\\n     ASM_GENERATE_INTERNAL_LABEL (OUTPUT, temp, LABELNO);\t\t\\\n   } while (0)\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n \f\n /* OUTPUT OF UNINITIALIZED VARIABLES */\n \n@@ -1837,17 +1894,19 @@ const_section ()                                                   \\\n \n /* CONTROLLING DEBUGGING INFORMATION FORMAT */\n \n-/* Define this macro if GCC should produce COFF-style debugging output\n-   for SDB in response to the '-g' option */\n-#define SDB_DEBUGGING_INFO\n+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n \n-/* Support generating stabs for the listing file generator */\n-#define DBX_DEBUGGING_INFO\n+#define DBX_REGISTER_NUMBER(REGNO)   (REGNO)\n \n-/* The default format when -g is given is still COFF debug info */\n-#define PREFERRED_DEBUGGING_TYPE SDB_DEBUG\n+#define ASM_OUTPUT_DEF(asm_out_file, LABEL1, LABEL2) \\\n+         do {\t\t\t\t\t\t\\\n+\t fprintf (asm_out_file, \".alias \" ); \\\n+         ASM_OUTPUT_LABELREF(asm_out_file, LABEL1);  \\\n+\t fprintf (asm_out_file, \"=\" ); \\\n+         ASM_OUTPUT_LABELREF(asm_out_file, LABEL2); \\\n+\t fprintf (asm_out_file, \"\\n\" );\t\t\t\\\n+\t } while (0)\n \n-#define DBX_REGISTER_NUMBER(REGNO)   (REGNO)\n \f\n /* MISCELLANEOUS PARAMETERS */\n \n@@ -1899,17 +1958,12 @@ const_section ()                                                   \\\n #define TARGET_VERSION fprintf (stderr, \" (%s, %s)\", VERSION_INFO1, __DATE__)\n #endif\n \n-#define VERSION_INFO1 \"AT&T DSP16xx C Cross Compiler, version 1.2.0\"\n+#define VERSION_INFO1 \"Lucent DSP16xx C Cross Compiler, version 1.3.0b\"\n \n \n /* Define this as 1 if `char' should by default be signed; else as 0.  */\n #define DEFAULT_SIGNED_CHAR 1\n \n-/* If this macro is defined, GNU CC gathers statistics about the number and\n-   kind of tree node it allocates during each run. The option '-fstats' will\n-   tell the compiler to print these statistics about the sizes of it obstacks. */\n-#define GATHER_STATISTICS\n-\n /* Define this so gcc does not output a call to __main, since we\n    are not currently supporting c++. */\n #define INIT_SECTION_ASM_OP  1"}, {"sha": "1f44420e38fb3dc6fce9c95bc3723ad030b16ef7", "filename": "gcc/config/dsp16xx/dsp16xx.md", "status": "modified", "additions": 1044, "deletions": 202, "changes": 1246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dff06f62c97fee80fc8f7e4f44ee993ffdacf6ad/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dff06f62c97fee80fc8f7e4f44ee993ffdacf6ad/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md?ref=dff06f62c97fee80fc8f7e4f44ee993ffdacf6ad", "patch": "@@ -1,6 +1,6 @@\n ;;- Machine description for the AT&T DSP1600 for GNU C compiler\n ;;  Copyright (C) 1994, 1995, 1997, 1998, 2001 Free Software Foundation, Inc.\n-;;  Contributed by Michael Collison (collison@world.std.com).\n+;;  Contributed by Michael Collison (collison@isisinc.net).\n \n ;; This file is part of GNU CC.\n \n@@ -36,15 +36,25 @@\n \n ; Classification of each insn.  Some insns of TYPE_BRANCH are multi-word.\n (define_attr \"type\"\n-  \"jump,cond_jump,call,load_i,load,move,store,malu,malu_mul,special,f3_alu,f3_alu_i,shift_i,shift,bfield_i,bfield,nop,ld_short_i\"\n+  \"jump,cond_jump,call,load_i,load,move,store,malu,malu_mul,tstqi,special,special_2,f3_alu,f3_alu_i,f3_alu_i_mult,shift_i,shift,shift_multiple,shift_i_multiple,bfield_i,bfield,nop,ld_short_i,data_move,data_move_i,data_move_memory,data_move_memory_2,data_move_short_i,data_move_multiple,data_move_2,nothing\"\n   (const_string \"malu\"))\n \n-; Length in # of instructions of each insn.  The values are not exact, but\n-; are safe.\n-(define_attr \"length\" \"\"\n-  (cond [(eq_attr \"type\" \"cond_jump,f3_alu_i,shift_i,bfield_i,load_i\")\n-\t (const_int 2)]\n-\t(const_int 1)))\n+;; Data arithmetic unit\n+(define_function_unit \"dau\" 1 1 (eq_attr \"type\" \"data_move,data_move_i,f3_alu_i\") 2 0)\n+\n+(define_function_unit \"dau\" 1 1 (eq_attr \"type\" \"special_2\") 3 0)\n+\n+(define_function_unit \"dau\" 1 1 (eq_attr \"type\" \"data_move_2\") 4 0)\n+\n+;; Bit manipulation\n+(define_function_unit \"bmu\" 1 1 (eq_attr \"type\" \"shift_i,shift_i_multiple\") 2 0)\n+\n+(define_function_unit \"bmu\" 1 1 (eq_attr \"type\" \"shift_multiple\") 4 0)\n+\n+;; Y-memory addressing arithmetic unit\n+(define_function_unit \"yaau\" 1 1 (eq_attr \"type\" \"data_move_memory\") 2 0)\n+\n+(define_function_unit \"yaau\" 1 1 (eq_attr \"type\" \"data_move_memory_2\") 4 0)\n \n \f\n ;;  ....................\n@@ -84,6 +94,28 @@\n   DONE;\n }\")\n \n+(define_split\n+  [(set (cc0)\n+\t(match_operand:QI 0 \"register_operand\" \"j,q\"))\n+   (clobber (match_scratch:QI 1 \"=k,u\"))]\n+  \"reload_completed\"\n+  [(set (match_dup 1)\n+\t(const_int 0))\n+   (parallel [(set (cc0)\n+\t\t   (match_dup 0))\n+\t      (use (match_dup 1))])]\n+  \"\")\n+\n+(define_insn \"tstqi_split\"\n+  [(set (cc0)\n+\t(match_operand:QI 0 \"register_operand\" \"j,q\"))\n+   (use (match_scratch:QI 1 \"=k,u\"))]\n+  \"\"\n+  \"@\n+   %b0-0\n+   %b0-0\"\n+  [(set_attr \"type\" \"f3_alu_i,f3_alu_i\")])\n+\n (define_insn \"tstqi_1\"\n   [(set (cc0)\n \t(match_operand:QI 0 \"register_operand\" \"j,q\"))\n@@ -92,7 +124,7 @@\n   \"@\n    %1=0\\;%b0-0\n    %1=0\\;%b0-0\"\n-  [(set_attr \"type\" \"malu,malu\")])\n+  [(set_attr \"type\" \"tstqi,tstqi\")])\n \n \f\n ;;\n@@ -104,8 +136,8 @@\n \n (define_insn \"\"\n   [(set (cc0)\n-\t(and:HI (match_operand:HI 0 \"register_operand\" \"A,!A,A\")\n-\t\t(match_operand:HI 1 \"nonmemory_operand\" \"Z,A,I\")))]\n+\t(and:HI (match_operand:HI 0 \"register_operand\" \"A,!A\")\n+\t\t(match_operand:HI 1 \"register_operand\" \"Z,A\")))]\n   \"\" \n   \"*\n {\n@@ -114,14 +146,9 @@\n \t   case 0:\n \t   case 1:\n    \t      return \\\"%0&%1\\\";\n-\n-\t   case 2:\n-   \t      return \\\"%0&%H1\\\";\n-           default:\n-              abort();\n          }\n }\"\n-  [(set_attr \"type\" \"f3_alu,malu,f3_alu_i\")])\n+  [(set_attr \"type\" \"f3_alu,f3_alu\")])\n \n \n ;;(define_insn \"\"\n@@ -178,7 +205,7 @@\n       else if (IS_YBASE_REGISTER_WINDOW (REGNO (operands[0])))\n \toutput_asm_insn (\\\"a0=%u0\\;a0l=%w0\\\", operands);\n       else\n-\tabort ();\n+\tfatal_error (\\\"Invalid register for compare\\\");\n     }\n   else if (GET_CODE(operands[0]) == CONST_INT)\n     output_asm_insn (\\\"a0=%U0\\;a0l=%H0\\\", operands);\n@@ -198,7 +225,7 @@\n       else if (IS_YBASE_REGISTER_WINDOW (REGNO (operands[1])))\n \toutput_asm_insn (\\\"a1=%u1\\;a1l=%w1\\\", operands);\n       else\n-\tabort ();\n+\tfatal_error (\\\"Invalid register for compare\\\");\n     }\n   else if (GET_CODE (operands[1]) == MEM)\n     {\n@@ -243,6 +270,64 @@\n     }\n  }\")\n \n+(define_split\n+  [(set (cc0)\n+\t(compare (match_operand:QI 0 \"register_operand\" \"\")\n+\t\t (match_operand:QI 1 \"register_operand\" \"\")))\n+   (clobber (match_scratch:QI 2 \"\"))\n+   (clobber (match_scratch:QI 3 \"\"))]\n+  \"reload_completed && next_cc_user_unsigned (insn)\"\n+  [(set (match_dup 2)\n+\t(const_int 0))\n+   (set (match_dup 3)\n+\t(const_int 0))\n+   (parallel [(set (cc0)\n+\t\t   (compare (match_dup 0)\n+\t\t\t    (match_dup 1)))\n+\t      (use (match_dup 2))\n+\t      (use (match_dup 3))])]\n+  \"\")\n+\n+(define_split\n+  [(set (cc0)\n+\t(compare (match_operand:QI 0 \"register_operand\" \"\")\n+\t\t (match_operand:QI 1 \"const_int_operand\" \"\")))\n+   (clobber (match_scratch:QI 2 \"\"))\n+   (clobber (match_scratch:QI 3 \"\"))]\n+  \"reload_completed && next_cc_user_unsigned (insn)\"\n+  [(set (match_dup 2)\n+\t(const_int 0))\n+   (parallel [(set (cc0)\n+\t\t   (compare (match_dup 0)\n+\t\t\t    (match_dup 1)))\n+\t      (use (match_dup 2))])]\n+  \"\")\n+\n+(define_insn \"cmpqi_split_unsigned_reg\"\n+  [(set (cc0) (compare (match_operand:QI 0 \"register_operand\"  \"k,k,!k,u,u,!u\")\n+                       (match_operand:QI 1 \"register_operand\"  \"w,z,u,w,z,k\")))\n+\t(use (match_scratch:QI 2 \"=j,j,j,q,q,q\"))\n+\t(use (match_scratch:QI 3 \"=v,y,q,v,y,j\"))]\n+  \"next_cc_user_unsigned (insn)\"\n+  \"@\n+   %2-%3\n+   %2-%3\n+   %2-%3\n+   %2-%3\n+   %2-%3\n+   %2-%3\"\n+  [(set_attr \"type\" \"malu,malu,malu,malu,malu,malu\")])\n+\n+(define_insn \"cmpqi_split_unsigned_int\"\n+  [(set (cc0) (compare (match_operand:QI 0 \"register_operand\"  \"k,u\")\n+                       (match_operand:QI 1 \"const_int_operand\" \"i,i\")))\n+\t(use (match_scratch:QI 2 \"=j,q\"))]\n+  \"next_cc_user_unsigned (insn)\"\n+  \"@\n+   %0-%H1\n+   %0-%H1\"\n+  [(set_attr \"type\" \"f3_alu_i,f3_alu_i\")])\n+\n (define_insn \"\"\n   [(set (cc0) (compare (match_operand:QI 0 \"register_operand\"  \"k,k,!k,k,u,u,!u,u\")\n                        (match_operand:QI 1 \"nonmemory_operand\" \"w,z,u,i,w,z,k,i\")))\n@@ -259,6 +344,64 @@\n    %2=0\\;%3=0\\;%2-%3\n    %2=0\\;%0-%H1\")\n \n+(define_split\n+  [(set (cc0)\n+\t(compare (match_operand:QI 0 \"register_operand\" \"\")\n+\t\t (match_operand:QI 1 \"register_operand\" \"\")))\n+   (clobber (match_scratch:QI 2 \"\"))\n+   (clobber (match_scratch:QI 3 \"\"))]\n+  \"reload_completed\"\n+  [(set (match_dup 2)\n+\t(const_int 0))\n+   (set (match_dup 3)\n+\t(const_int 0))\n+   (parallel [(set (cc0)\n+\t\t   (compare (match_dup 0)\n+\t\t\t    (match_dup 1)))\n+\t      (use (match_dup 2))\n+\t      (use (match_dup 3))])]\n+  \"\")\n+\n+(define_split\n+  [(set (cc0)\n+\t(compare (match_operand:QI 0 \"register_operand\" \"\")\n+\t\t (match_operand:QI 1 \"const_int_operand\" \"\")))\n+   (clobber (match_scratch:QI 2 \"\"))\n+   (clobber (match_scratch:QI 3 \"\"))]\n+  \"reload_completed\"\n+  [(set (match_dup 2)\n+\t(const_int 0))\n+   (parallel [(set (cc0)\n+\t\t   (compare (match_dup 0)\n+\t\t\t    (match_dup 1)))\n+\t      (use (match_dup 2))])]\n+  \"\")\n+\n+(define_insn \"cmpqi_split_reg\"\n+  [(set (cc0) (compare (match_operand:QI 0 \"register_operand\"  \"j,j,!j,q,q,!q\")\n+                       (match_operand:QI 1 \"register_operand\"  \"v,y,q,v,y,j\")))\n+\t(use (match_scratch:QI 2 \"=k,k,k,u,u,u\"))\n+\t(use (match_scratch:QI 3 \"=w,z,u,w,z,k\"))]\n+  \"\"\n+  \"@\n+   %0-%1\n+   %0-%1\n+   %0-%1\n+   %0-%1\n+   %0-%1\n+   %0-%1\"\n+  [(set_attr \"type\" \"malu,malu,malu,malu,malu,malu\")])\n+\n+\n+(define_insn \"cmpqi_split_int\"\n+  [(set (cc0) (compare (match_operand:QI 0 \"register_operand\"  \"j,q\")\n+                       (match_operand:QI 1 \"const_int_operand\" \"i,i\")))\n+\t(use (match_scratch:QI 2 \"=k,u\"))]\n+  \"\"\n+  \"@\n+   %b0-%H1\n+   %b0-%H1\"\n+  [(set_attr \"type\" \"f3_alu_i,f3_alu_i\")])\n \n (define_insn \"\"\n   [(set (cc0) (compare (match_operand:QI 0 \"register_operand\"  \"j,j,!j,j,q,q,!q,q\")\n@@ -304,17 +447,45 @@\n ;;\n ;;  ....................\n \n+(define_split\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(plus:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t (match_operand:HI 2 \"const_int_operand\" \"\")))]\n+  \"reload_completed && !ADD_LOW_16(INTVAL(operands[2])) && \n+   !ADD_HIGH_16(INTVAL(operands[2]))\"\n+  [(parallel [(set (match_dup 3)\n+\t\t   (plus:QI (match_dup 4)\n+\t\t\t    (match_dup 5)))\n+\t      (clobber (match_dup 6))])\n+\n+   (parallel [(set (match_dup 6)\n+\t\t   (plus:QI (match_dup 7)\n+\t\t\t    (match_dup 8)))\n+\t      (clobber (match_scratch:QI 9 \"\"))])]\n+  \"\n+{\n+  operands[3] = gen_lowpart(QImode, operands[0]);\n+  operands[4] = gen_lowpart(QImode, operands[1]);\n+  operands[5] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0xffff);\n+\n+  operands[6] = gen_highpart(QImode, operands[0]);\n+  operands[7] = gen_highpart(QImode, operands[0]);\n+  operands[8] = gen_rtx (CONST_INT, VOIDmode, (((INTVAL (operands[2]) & 0xffff0000) >> 16) & 0xffff));\n+}\")\n+\n \n (define_insn \"addhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=A,A,A\")\n-\t(plus:HI (match_operand:HI 1 \"register_operand\" \"%A,A,A\")\n-\t\t (match_operand:HI 2 \"nonmemory_operand\" \"Z,d,i\")))]\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A,A,A,A,A\")\n+\t(plus:HI (match_operand:HI 1 \"register_operand\" \"%A,A,A,A,A\")\n+\t\t (match_operand:HI 2 \"nonmemory_operand\" \"Z,d,L,M,?i\")))]\n   \"\"\n   \"@\n    %0=%1+%2\n    %0=%1+%2\n+   %0=%w1+%H2\n+   %0=%b1+%U2\n    %0=%w1+%H2\\;%0=%b0+%U2\"\n-  [(set_attr \"type\" \"malu,malu,f3_alu_i\")])\n+  [(set_attr \"type\" \"malu,malu,f3_alu_i,f3_alu_i,f3_alu_i\")])\n \n (define_insn \"\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=k,u,!k,!u\")\n@@ -354,10 +525,10 @@\n \n \t\n (define_insn \"match_addqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=!a,!a,k,u,!k,!u,h,!a\")\n-\t(plus:QI (match_operand:QI 1 \"register_operand\" \"0,0,uk,uk,uk,uk,h,0\")\n-\t\t (match_operand:QI 2 \"nonmemory_operand\" \"W,N,wzi,wzi,uk,uk,i,n\")))\n-\t(clobber (match_scratch:QI 3 \"=X,X,j,q,j,q,X,W\"))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"=a,a,k,u,k,u,!k,!u,j,j,q,q\")\n+\t(plus:QI (match_operand:QI 1 \"register_operand\" \"0,0,uk,uk,uk,uk,uk,uk,0,q,0,j\")\n+\t\t (match_operand:QI 2 \"nonmemory_operand\" \"W,N,i,i,wz,wz,uk,uk,i,i,i,i\")))\n+\t(clobber (match_scratch:QI 3 \"=X,X,j,q,j,q,j,q,X,k,X,u\"))]\n   \"\"\n   \"*\n {\n@@ -384,24 +555,26 @@\n \n     case 2:\n     case 3:\n-      if (!CONSTANT_P(operands[2]))\n-        return \\\"%m0=%m1+%m2\\\";\n-      else\n         return \\\"%m0=%1+%H2\\\";\n \n     case 4:\n     case 5:\n-      return \\\"%m0=%m1+%m2\\\";\n+        return \\\"%m0=%m1+%m2\\\";\n \n-    case 6:\n-      return \\\"%0=%b1+%H2\\\";\n \n+    case 6:\n     case 7:\n-      return \\\"%3=%2\\;*%0++%3\\\";\n-    default:\n-      abort();\n+      return \\\"%m0=%m1+%m2\\\";\n+\n+    case 8:\n+    case 9:\n+    case 10:\n+    case 11:\n+      return \\\"%0=%b1+%H2\\\";\n     }\n-}\")\n+}\"\n+[(set_attr \"type\" \"data_move_memory,data_move_multiple,f3_alu_i,f3_alu_i,f3_alu,f3_alu,f3_alu,f3_alu,f3_alu_i,f3_alu_i,f3_alu_i,f3_alu_i\")])\n+\n \n (define_expand \"addhf3\"\n   [(set (match_operand:HF 0 \"register_operand\" \"\")\n@@ -428,22 +601,51 @@\n ;;\n ;;  ....................\n \n+(define_split\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(minus:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t  (match_operand:HI 2 \"const_int_operand\" \"\")))]\n+  \"reload_completed && !ADD_LOW_16(INTVAL(operands[2])) && \n+   !ADD_HIGH_16(INTVAL(operands[2]))\"\n+  [(parallel [(set (match_dup 3)\n+\t\t   (minus:QI (match_dup 4)\n+\t\t\t     (match_dup 5)))\n+\t      (clobber (match_dup 6))])\n+\n+   (parallel [(set (match_dup 6)\n+\t\t   (minus:QI (match_dup 7)\n+\t\t\t     (match_dup 8)))\n+\t      (clobber (match_scratch:QI 9 \"\"))])]\n+  \"\n+{\n+  operands[3] = gen_lowpart(QImode, operands[0]);\n+  operands[4] = gen_lowpart(QImode, operands[1]);\n+  operands[5] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0xffff);\n+\n+  operands[6] = gen_highpart(QImode, operands[0]);\n+  operands[7] = gen_highpart(QImode, operands[0]);\n+  operands[8] = gen_rtx (CONST_INT, VOIDmode, (((INTVAL (operands[2]) & 0xffff0000) >> 16) & 0xffff));\n+}\")\n+\n+\n (define_insn \"subhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=A,A,A\")\n-\t(minus:HI (match_operand:HI 1 \"register_operand\" \"A,A,A\")\n-\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"Z,d,i\")))]\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A,A,A,A,A\")\n+\t(minus:HI (match_operand:HI 1 \"register_operand\" \"A,A,A,A,A\")\n+\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"Z,d,L,M,?i\")))]\n   \"\"\n   \"@\n    %0=%1-%2\n    %0=%1-%2\n+   %0=%w1-%H2\n+   %0=%b1-%U2\n    %0=%w1-%H2\\;%0=%b0-%U2\"\n-  [(set_attr \"type\" \"malu,malu,f3_alu_i\")])\n+  [(set_attr \"type\" \"malu,malu,f3_alu_i,f3_alu_i,f3_alu_i\")])\n \n (define_insn \"subqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=?*a,k,u,!k,!u\")\n-\t(minus:QI (match_operand:QI 1 \"register_operand\" \"0,uk,uk,uk,uk\")\n-\t\t (match_operand:QI 2 \"nonmemory_operand\" \"n,wzi,wzi,uk,uk\")))\n-\t(clobber (match_scratch:QI 3 \"=W,j,q,j,q\"))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"=a,k,u,k,u,!k,!u,j,j,q,q\")\n+\t(minus:QI (match_operand:QI 1 \"register_operand\" \"0,uk,uk,uk,uk,uk,uk,0,q,0,j\")\n+\t\t (match_operand:QI 2 \"nonmemory_operand\" \"N,i,i,wz,wz,uk,uk,i,i,i,i\")))\n+\t(clobber (match_scratch:QI 3 \"=X,j,q,j,q,j,q,X,k,X,u\"))]\n   \"\"\n   \"*\n {\n@@ -452,15 +654,12 @@\n     case 0:\n       switch (INTVAL (operands[2]))\n \t{\n-\tcase 0:\n-\t  return \\\"\\\";\n-\t  \n \tcase 1:\n \t  return \\\"*%0--\\\";\n \t  \n \tcase -1:\n \t  return \\\"*%0++\\\";\n-\t  \n+\n \tdefault:\n \t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n \t  \n@@ -472,18 +671,22 @@\n       \n     case 1:\n     case 2:\n-      if (!CONSTANT_P(operands[2]))\n-        return \\\"%m0=%m1-%m2\\\";\n-      else\n         return \\\"%m0=%1-%H2\\\";\n \n     case 3:\n     case 4:\n+        return \\\"%m0=%m1-%m2\\\";\n+\n+    case 5:\n+    case 6:\n       return \\\"%m0=%m1-%m2\\\";\n-    default:\n-      abort();\n+\n+    case 7: case 8:\n+    case 9: case 10:\n+      return \\\"%0=%b1-%H2\\\";\n     }\n-}\")\n+}\"\n+[(set_attr \"type\" \"data_move_multiple,f3_alu_i,f3_alu_i,f3_alu,f3_alu,f3_alu,f3_alu,f3_alu_i,f3_alu_i,f3_alu_i,f3_alu_i\")])\n \n (define_expand \"subhf3\"\n   [(set (match_operand:HF 0 \"register_operand\" \"\")\n@@ -510,21 +713,30 @@\n   [(set_attr \"type\" \"special\")])\n \n (define_expand \"neghf2\"\n-  [(set (match_operand:HF 0 \"general_operand\" \"\")\n-\t(neg:HF (match_operand:HF 1 \"general_operand\" \"\")))]\n+  [(set (match_operand:HF 0 \"register_operand\" \"\")\n+\t(neg:HF (match_operand:HF 1 \"register_operand\" \"\")))]\n   \"\"\n-\"\n+  \"\n {\n-  if (!dsp16xx_neghf2_libcall)\n-    dsp16xx_neghf2_libcall = gen_rtx_SYMBOL_REF (Pmode, NEGHF2_LIBCALL);\n-  \n-  emit_library_call (dsp16xx_neghf2_libcall, 1, HFmode, 1,\n-\t\t     operands[1], HFmode);\n-  emit_move_insn (operands[0], hard_libcall_value(HFmode));\n-  DONE;\n-}\")\n+  rtx result;\n+  rtx target;\n+\n+    {\n+      target = gen_lowpart(HImode, operands[0]);\n+      result = expand_binop (HImode, xor_optab,\n+\t\t\t     gen_lowpart(HImode, operands[1]),\n+\t\t\t     GEN_INT(0x80000000), target, 0, OPTAB_WIDEN);\n+      if (result == 0)\n+\tabort ();\n \n+      if (result != target)\n+\temit_move_insn (result, target);\n \n+      /* Make a place for REG_EQUAL.  */\n+      emit_move_insn (operands[0], operands[0]);\n+      DONE;\n+    }\n+}\")\n \n ;;\n ;;  ....................\n@@ -566,14 +778,6 @@\n   \"%0=%1*%2\"\n   [(set_attr \"type\" \"malu_mul\")])\n \n-(define_insn \"umulqihi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=t\")\n-        (mult:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"%x\"))\n-                 (zero_extend:HI (match_operand:QI 2 \"register_operand\" \"y\"))))]\n-  \"\"\n-  \"%0=%1*%2\"\n-  [(set_attr \"type\" \"malu_mul\")])\n-\n (define_expand \"mulhf3\"\n   [(set (match_operand:HF 0 \"register_operand\" \"\")\n \t(mult:HF (match_operand:HF 1 \"register_operand\" \"\")\n@@ -767,94 +971,279 @@\n ;; Logical Instructions\n ;;\n \n+(define_split\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(and:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t (match_operand:HI 2 \"const_int_operand\" \"\")))]\n+  \"reload_completed && !AND_LOW_16(INTVAL(operands[2])) && \n+   !AND_HIGH_16(INTVAL(operands[2])) \n+   && (REGNO (operands[0]) == REGNO (operands[1]))\"\n+  [(parallel [(set (match_dup 3)\n+\t\t   (and:QI (match_dup 4)\n+\t\t\t   (match_dup 5)))\n+\t      (clobber (match_scratch:QI 6 \"\"))])\n+   (parallel [(set (match_dup 7)\n+\t\t   (and:QI (match_dup 8)\n+\t\t\t   (match_dup 9)))\n+\t      (clobber (match_scratch:QI 10 \"\"))])]\n+  \"\n+{\n+  operands[3] = gen_lowpart(QImode, operands[0]);\n+  operands[4] = gen_lowpart(QImode, operands[1]);\n+  operands[5] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0xffff);\n+\n+  operands[7] = gen_highpart(QImode, operands[0]);\n+  operands[8] = gen_highpart(QImode, operands[0]);\n+  operands[9] = gen_rtx (CONST_INT, VOIDmode, (((INTVAL (operands[2]) & 0xffff0000) >> 16) & 0xffff));\n+}\")\n+\n+(define_split\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(and:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t(match_operand:HI 2 \"const_int_operand\" \"\")))]\n+  \"reload_completed && !AND_LOW_16(INTVAL(operands[2])) && \n+   !AND_HIGH_16(INTVAL(operands[2]))\n+   && (REGNO (operands[0]) != REGNO (operands[1]))\"\n+  [(parallel [(set (match_dup 3)\n+\t\t   (and:QI (match_dup 4)\n+\t\t\t   (match_dup 5)))\n+\t      (clobber (match_dup 6))])\n+   (parallel [(set (match_dup 6)\n+\t\t   (and:QI (match_dup 7)\n+\t\t\t   (match_dup 8)))\n+\t      (clobber (match_scratch:QI 9 \"\"))])]\n+  \"\n+{\n+  operands[3] = gen_lowpart(QImode, operands[0]);\n+  operands[4] = gen_lowpart(QImode, operands[1]);\n+  operands[5] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0xffff);\n+\n+  operands[6] = gen_highpart(QImode, operands[0]);\n+  operands[7] = gen_highpart(QImode, operands[0]);\n+  operands[8] = gen_rtx (CONST_INT, VOIDmode, (((INTVAL (operands[2]) & 0xffff0000) >> 16) & 0xffff));\n+}\")\n+\n (define_insn \"andhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=A,A,?A\")\n-        (and:HI (match_operand:HI 1 \"register_operand\" \"%A,!A,A\")\n-                (match_operand:HI 2 \"nonmemory_operand\" \"Z,A,i\")))]\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A,A,A,A,?A\")\n+        (and:HI (match_operand:HI 1 \"register_operand\" \"%A,!A,A,A,A\")\n+                (match_operand:HI 2 \"nonmemory_operand\" \"Z,A,O,P,i\")))]\n   \"\"\n   \"@\n    %0=%1&%2\n    %0=%1&%2\n+   %0=%w1&%H2\n+   %0=%b1&%U2\n    %0=%w1&%H2\\;%0=%b0&%U2\"\n-  [(set_attr \"type\" \"f3_alu,f3_alu,f3_alu_i\")])\n+  [(set_attr \"type\" \"f3_alu,f3_alu,f3_alu_i,f3_alu_i,f3_alu_i_mult\")])\n \n (define_insn \"andqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=k,u,uk,!k,!u,j,q,jq,!j,!q\")\n-\t(and:QI (match_operand:QI 1 \"register_operand\" \"uk,uk,uk,uk,uk,jq,jq,jq,jq,jq\")\n-\t\t(match_operand:QI 2 \"nonmemory_operand\" \"wz,wz,i,uk,uk,yv,yv,i,jq,jq\")))\n-\t(clobber (match_scratch:QI 3 \"=j,q,X,j,q,k,u,X,k,u\"))]\n-   \"\"\n-   \"@\n+  [(set (match_operand:QI 0 \"register_operand\" \"=k,u,!k,!u,k,u,k,u,j,q,j,q,j,q,!j,!q\")\n+\t(and:QI (match_operand:QI 1 \"register_operand\" \"%uk,uk,uk,uk,0,0,u,k,jq,jq,0,0,q,j,jq,jq\")\n+\t\t(match_operand:QI 2 \"nonmemory_operand\" \"wz,wz,uk,uk,i,i,i,i,yv,yv,i,i,i,i,jq,jq\")))\n+   (clobber (match_scratch:QI 3 \"=j,q,j,q,X,X,j,q,k,u,X,X,k,u,k,u\"))]\n+  \"\"\n+  \"@\n     %m0=%m1&%m2\n     %m0=%m1&%m2\n-    %m0=%1&%H2\n     %m0=%m1&%m2\n     %m0=%m1&%m2\n+    %m0=%1&%H2\n+    %m0=%1&%H2\n+    %m0=%1&%H2\n+    %m0=%1&%H2\n     %m0=%m1&%m2\n     %m0=%m1&%m2\n     %m0=%b1&%H2\n+    %m0=%b1&%H2\n+    %m0=%b1&%H2\n+    %m0=%b1&%H2\n     %m0=%m1&%m2\n-    %m0=%m1&%m2\")\n+    %m0=%m1&%m2\"\n+  [(set_attr \"type\" \"f3_alu,f3_alu,f3_alu,f3_alu,f3_alu_i,f3_alu_i,f3_alu_i,f3_alu_i,f3_alu,f3_alu,f3_alu_i,f3_alu_i,f3_alu_i,f3_alu_i,f3_alu,f3_alu\")])\n+\n+\n+(define_split\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(ior:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t(match_operand:HI 2 \"const_int_operand\" \"\")))]\n+  \"reload_completed && !SMALL_INTVAL(INTVAL(operands[2])) && \n+   !ADD_HIGH_16(INTVAL(operands[2]))\n+   && (REGNO (operands[0]) == REGNO (operands[1]))\"\n+  [(parallel [(set (match_dup 3)\n+\t\t   (ior:QI (match_dup 4)\n+\t\t\t   (match_dup 5)))\n+\t      (clobber (match_scratch:QI 6 \"\"))])\n+   (parallel [(set (match_dup 7)\n+\t\t   (ior:QI (match_dup 8)\n+\t\t\t   (match_dup 9)))\n+\t      (clobber (match_scratch:QI 10 \"\"))])]\n+  \"\n+{\n+  operands[3] = gen_lowpart(QImode, operands[0]);\n+  operands[4] = gen_lowpart(QImode, operands[1]);\n+  operands[5] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0xffff);\n+\n+  operands[7] = gen_highpart(QImode, operands[0]);\n+  operands[8] = gen_highpart(QImode, operands[0]);\n+  operands[9] = gen_rtx (CONST_INT, VOIDmode, (((INTVAL (operands[2]) & 0xffff0000) >> 16) & 0xffff));\n+}\")\n+\n+(define_split\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(ior:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t(match_operand:HI 2 \"const_int_operand\" \"\")))]\n+  \"reload_completed && !SMALL_INTVAL(INTVAL(operands[2])) && \n+   !ADD_HIGH_16(INTVAL(operands[2]))\n+   && (REGNO (operands[0]) != REGNO (operands[1]))\"\n+  [(parallel [(set (match_dup 3)\n+\t\t   (ior:QI (match_dup 4)\n+\t\t\t   (match_dup 5)))\n+\t      (clobber (match_dup 6))])\n+   (parallel [(set (match_dup 6)\n+\t\t   (ior:QI (match_dup 7)\n+\t\t\t   (match_dup 8)))\n+\t      (clobber (match_scratch:QI 9 \"\"))])]\n+  \"\n+{\n+  operands[3] = gen_lowpart(QImode, operands[0]);\n+  operands[4] = gen_lowpart(QImode, operands[1]);\n+  operands[5] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0xffff);\n+\n+  operands[6] = gen_highpart(QImode, operands[0]);\n+  operands[7] = gen_highpart(QImode, operands[0]);\n+  operands[8] = gen_rtx (CONST_INT, VOIDmode, (((INTVAL (operands[2]) & 0xffff0000) >> 16) & 0xffff));\n+}\")\n+\n \n (define_insn \"iorhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=A,A,A,?A\")\n-        (ior:HI (match_operand:HI 1 \"register_operand\" \"%A,!A,A,A\")\n-                (match_operand:HI 2 \"nonmemory_operand\" \"Z,A,I,i\")))]\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A,A,A,A,?A\")\n+        (ior:HI (match_operand:HI 1 \"register_operand\" \"%A,!A,A,A,A\")\n+                (match_operand:HI 2 \"nonmemory_operand\" \"Z,A,I,M,i\")))]\n  \"\"\n  \"@\n    %0=%u1|%u2\n    %0=%u1|%u2\n    %0=%w1|%H2\n+   %0=%b1|%U2\n    %0=%w1|%H2\\;%0=%b0|%U2\"\n-  [(set_attr \"type\" \"f3_alu,f3_alu,f3_alu_i,f3_alu_i\")])\n+  [(set_attr \"type\" \"f3_alu,f3_alu,f3_alu_i,f3_alu_i,f3_alu_i_mult\")])\n \n (define_insn \"iorqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=k,u,uk,!k,!u,j,q,jq,!j,!q\")\n-\t(ior:QI (match_operand:QI 1 \"register_operand\" \"uk,uk,uk,uk,uk,jq,jq,jq,jq,jq\")\n-\t\t(match_operand:QI 2 \"nonmemory_operand\" \"wz,wz,i,uk,uk,yv,yv,i,jq,jq\")))\n-\t(clobber (match_scratch:QI 3 \"=j,q,X,j,q,k,u,X,k,u\"))]\n-   \"\"\n-   \"@\n+  [(set (match_operand:QI 0 \"register_operand\" \"=k,u,!k,!u,k,u,k,u,j,q,j,q,j,q,!j,!q\")\n+\t(ior:QI (match_operand:QI 1 \"register_operand\" \"%uk,uk,uk,uk,0,0,u,k,jq,jq,0,0,q,j,jq,jq\")\n+\t\t(match_operand:QI 2 \"nonmemory_operand\" \"wz,wz,uk,uk,i,i,i,i,yv,yv,i,i,i,i,jq,jq\")))\n+   (clobber (match_scratch:QI 3 \"=j,q,j,q,X,X,j,q,k,u,X,X,k,u,k,u\"))]\n+  \"\"\n+  \"@\n     %m0=%m1|%m2\n     %m0=%m1|%m2\n-    %m0=%1|%H2\n     %m0=%m1|%m2\n     %m0=%m1|%m2\n+    %m0=%1|%H2\n+    %m0=%1|%H2\n+    %m0=%1|%H2\n+    %m0=%1|%H2\n     %m0=%m1|%m2\n     %m0=%m1|%m2\n     %m0=%b1|%H2\n+    %m0=%b1|%H2\n+    %m0=%b1|%H2\n+    %m0=%b1|%H2\n     %m0=%m1|%m2\n-    %m0=%m1|%m2\")\n+    %m0=%m1|%m2\"\n+  [(set_attr \"type\" \"f3_alu,f3_alu,f3_alu,f3_alu,f3_alu_i,f3_alu_i,f3_alu_i,f3_alu_i,f3_alu,f3_alu,f3_alu_i,f3_alu_i,f3_alu_i,f3_alu_i,f3_alu,f3_alu\")])\n+\n+\n+\n+(define_split\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(xor:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t(match_operand:HI 2 \"const_int_operand\" \"\")))]\n+  \"reload_completed && !SMALL_INTVAL(INTVAL(operands[2])) && \n+   !ADD_HIGH_16(INTVAL(operands[2]))\n+   && (REGNO (operands[0]) == REGNO (operands[1]))\"\n+  [(parallel [(set (match_dup 3)\n+\t\t   (xor:QI (match_dup 4)\n+\t\t\t   (match_dup 5)))\n+\t      (clobber (match_scratch:QI 6 \"\"))])\n+   (parallel [(set (match_dup 7)\n+\t\t   (xor:QI (match_dup 8)\n+\t\t\t   (match_dup 9)))\n+\t      (clobber (match_scratch:QI 10 \"\"))])]\n+  \"\n+{\n+  operands[3] = gen_lowpart(QImode, operands[0]);\n+  operands[4] = gen_lowpart(QImode, operands[1]);\n+  operands[5] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0xffff);\n+\n+  operands[7] = gen_highpart(QImode, operands[0]);\n+  operands[8] = gen_highpart(QImode, operands[0]);\n+  operands[9] = gen_rtx (CONST_INT, VOIDmode, (((INTVAL (operands[2]) & 0xffff0000) >> 16) & 0xffff));\n+}\")\n+\n+(define_split\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(xor:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t(match_operand:HI 2 \"const_int_operand\" \"\")))]\n+  \"reload_completed && !SMALL_INTVAL(INTVAL(operands[2])) && \n+   !ADD_HIGH_16(INTVAL(operands[2]))\n+   && (REGNO (operands[0]) != REGNO (operands[1]))\"\n+  [(parallel [(set (match_dup 3)\n+\t\t   (xor:QI (match_dup 4)\n+\t\t\t   (match_dup 5)))\n+\t      (clobber (match_dup 6))])\n+   (parallel [(set (match_dup 6)\n+\t\t   (xor:QI (match_dup 7)\n+\t\t\t   (match_dup 8)))\n+\t      (clobber (match_scratch:QI 9 \"\"))])]\n+  \"\n+{\n+  operands[3] = gen_lowpart(QImode, operands[0]);\n+  operands[4] = gen_lowpart(QImode, operands[1]);\n+  operands[5] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0xffff);\n+\n+  operands[6] = gen_highpart(QImode, operands[0]);\n+  operands[7] = gen_highpart(QImode, operands[0]);\n+  operands[8] = gen_rtx (CONST_INT, VOIDmode, (((INTVAL (operands[2]) & 0xffff0000) >> 16) & 0xffff));\n+}\")\n \n (define_insn \"xorhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=A,A,A,?A\")\n-        (xor:HI (match_operand:HI 1 \"register_operand\" \"%A,!A,A,A\")\n-                (match_operand:HI 2 \"nonmemory_operand\" \"Z,A,I,i\")))]\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A,A,A,A,?A\")\n+        (xor:HI (match_operand:HI 1 \"register_operand\" \"%A,!A,A,A,A\")\n+                (match_operand:HI 2 \"nonmemory_operand\" \"Z,A,I,M,i\")))]\n   \"\"\n   \"@\n    %0=%1^%2\n    %0=%1^%2\n    %0=%w1^%H2\n+   %0=%b1^%U2\n    %0=%w1^%H2\\;%0=%b0^%U2\"\n-  [(set_attr \"type\" \"f3_alu,f3_alu,f3_alu_i,f3_alu_i\")])\n+  [(set_attr \"type\" \"f3_alu,f3_alu,f3_alu_i,f3_alu_i,f3_alu_i_mult\")])\n \n (define_insn \"xorqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=k,u,uk,!k,!u,j,q,jq,!j,!q\")\n-\t(xor:QI (match_operand:QI 1 \"register_operand\" \"uk,uk,uk,uk,uk,jq,jq,jq,jq,jq\")\n-\t\t(match_operand:QI 2 \"nonmemory_operand\" \"wz,wz,i,uk,uk,yv,yv,i,jq,jq\")))\n-\t(clobber (match_scratch:QI 3 \"=j,q,X,j,q,k,u,X,k,u\"))]\n-   \"\"\n-   \"@\n+  [(set (match_operand:QI 0 \"register_operand\" \"=k,u,!k,!u,k,u,k,u,j,q,j,q,j,q,!j,!q\")\n+\t(xor:QI (match_operand:QI 1 \"register_operand\" \"%uk,uk,uk,uk,0,0,u,k,jq,jq,0,0,q,j,jq,jq\")\n+\t\t(match_operand:QI 2 \"nonmemory_operand\" \"wz,wz,uk,uk,i,i,i,i,yv,yv,i,i,i,i,jq,jq\")))\n+   (clobber (match_scratch:QI 3 \"=j,q,j,q,X,X,j,q,k,u,X,X,k,u,k,u\"))]\n+  \"\"\n+  \"@\n     %m0=%m1^%m2\n     %m0=%m1^%m2\n-    %m0=%1^%H2\n     %m0=%m1^%m2\n     %m0=%m1^%m2\n+    %m0=%1^%H2\n+    %m0=%1^%H2\n+    %m0=%1^%H2\n+    %m0=%1^%H2\n     %m0=%m1^%m2\n     %m0=%m1^%m2\n     %m0=%b1^%H2\n+    %m0=%b1^%H2\n+    %m0=%b1^%H2\n+    %m0=%b1^%H2\n     %m0=%m1^%m2\n-    %m0=%m1^%m2\")\n+    %m0=%m1^%m2\"\n+  [(set_attr \"type\" \"f3_alu,f3_alu,f3_alu,f3_alu,f3_alu_i,f3_alu_i,f3_alu_i,f3_alu_i,f3_alu,f3_alu,f3_alu_i,f3_alu_i,f3_alu_i,f3_alu_i,f3_alu,f3_alu\")])\n \n (define_insn \"one_cmplhi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n@@ -863,20 +1252,121 @@\n   \"%0= ~%1\"\n   [(set_attr \"type\" \"special\")])\n \n+\n (define_insn \"one_cmplqi2\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=ku,jq\")\n-        (not:QI (match_operand:QI 1 \"register_operand\" \"ku,jq\")))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"=k,k,u,u,j,j,q,q\")\n+        (not:QI (match_operand:QI 1 \"register_operand\" \"0,u,0,q,0,q,0,j\")))\n+   (clobber (match_scratch:QI 2 \"=X,j,X,q,X,k,X,u\"))]\n   \"\"\n   \"@\n    %m0= %1 ^ 0xffff\n+   %m0= %1 ^ 0xffff\n+   %m0= %1 ^ 0xffff\n+   %m0= %1 ^ 0xffff\n+   %m0= %b1 ^ 0xffff\n+   %m0= %b1 ^ 0xffff\n+   %m0= %b1 ^ 0xffff\n    %m0= %b1 ^ 0xffff\"\n-  [(set_attr \"type\" \"special\")])\n+  [(set_attr \"type\" \"f3_alu_i,f3_alu_i,f3_alu_i,f3_alu_i,f3_alu_i,f3_alu_i,f3_alu_i,f3_alu_i\")])\n \n \f\n ;;\n ;; MOVE INSTRUCTIONS\n ;;\n \n+(define_split\n+  [(set (mem:HI (match_operand:QI 0 \"register_operand\" \"\"))\n+\t(match_operand:HI 1 \"register_operand\" \"\"))]\n+  \"reload_completed && (operands[0] != stack_pointer_rtx)\"\n+  [(set (mem:QI (post_inc:QI (match_dup 0)))\n+\t(match_dup 2))\n+   (set (mem:QI (post_dec:QI (match_dup 0)))\n+\t(match_dup 3))]\n+  \"\n+{\n+  operands[2] = gen_highpart(QImode, operands[1]);\n+  operands[3] = gen_lowpart(QImode, operands[1]);\n+}\")\n+\n+\n+(define_split\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(mem:HI (match_operand:QI 1 \"register_operand\" \"\")))]\n+  \"reload_completed && (operands[1] != stack_pointer_rtx)\"\n+  [(set (match_dup 2)\n+\t(mem:QI (post_inc:QI (match_dup 1))))\n+   (set (match_dup 3)\n+\t(mem:QI (post_dec:QI (match_dup 1))))]\n+  \"\n+{\n+  operands[2] = gen_highpart(QImode, operands[0]);\n+  operands[3] = gen_lowpart(QImode, operands[0]);\n+}\")\n+\n+(define_split\n+  [(set (mem:HI (post_inc:HI (match_operand:QI 0 \"register_operand\" \"\")))\n+\t(match_operand:HI 1 \"register_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(set (mem:QI (post_inc:QI (match_dup 0)))\n+\t(match_dup 2))\n+   (set (mem:QI (post_inc:QI (match_dup 0)))\n+\t(match_dup 3))]\n+  \"\n+{\n+  operands[2] = gen_highpart(QImode, operands[1]);\n+  operands[3] = gen_lowpart(QImode, operands[1]);\n+}\")\n+\n+(define_split\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(mem:HI (post_inc:HI (match_operand:QI 1 \"register_operand\" \"\"))))]\n+  \"reload_completed\"\n+  [(set (match_dup 2)\n+\t(mem:QI (post_inc:QI (match_dup 1))))\n+   (set (match_dup 3)\n+\t(mem:QI (post_inc:QI (match_dup 1))))]\n+  \"\n+{\n+  operands[2] = gen_highpart(QImode, operands[0]);\n+  operands[3] = gen_lowpart(QImode, operands[0]);\n+}\")\n+\n+\n+(define_split\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(match_operand:HI 1 \"register_operand\" \"\"))]\n+  \"reload_completed && \n+   !(IS_ACCUM_REG (REGNO(operands[0])) && \n+    (REGNO(operands[1]) == REG_PROD || REGNO(operands[1]) == REG_Y))\"\n+  [(set (match_dup 2)\n+\t(match_dup 3))\n+   (set (match_dup 4)\n+\t(match_dup 5))]\n+  \"\n+{\n+  operands[2] = gen_highpart(QImode, operands[0]);\n+  operands[3] = gen_highpart(QImode, operands[1]);\n+  operands[4] = gen_lowpart(QImode, operands[0]);\n+  operands[5] = gen_lowpart(QImode, operands[1]);\n+}\")\n+\n+(define_split\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(match_operand:HI 1 \"const_int_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(set (match_dup 2)\n+\t(match_dup 3))\n+   (set (match_dup 4)\n+\t(match_dup 5))]\n+   \"\n+{\n+  operands[2] = gen_lowpart(QImode, operands[0]);\n+  operands[3] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[1]) & 0xffff);\n+\n+  operands[4] = gen_highpart(QImode, operands[0]);\n+  operands[5] = gen_rtx (CONST_INT, VOIDmode, (((INTVAL (operands[1]) & 0xffff0000) >> 16) & 0xffff));\n+}\")\n+\n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"general_operand\" \"\")\n \t(match_operand:HI 1 \"general_operand\" \"\"))]\n@@ -918,11 +1408,9 @@\n \t\tcase 8:\n \t\tcase 9:\n \t\t   return \\\"\\\";\n-                default:\n-                   abort();\n         }\n }\"\n-[(set_attr \"type\" \"move,move,load_i,load_i,load,store,load,store,move,move\")])\n+[(set_attr \"type\" \"special,data_move_multiple,f3_alu,data_move_multiple,data_move_multiple,data_move_multiple,data_move_multiple,data_move_multiple,nothing,nothing\")])\n \n \n ;; NOTE: It is cheaper to do 'y = *r0', than 'r0 = *r0'.\n@@ -952,7 +1440,7 @@\n \tswitch (which_alternative)\n \t{\n \t\tcase 0:\n-\t\t   /* We have to use the move mnemonic otherwise the 1610 will\n+\t\t   /* We have to use the move mneumonic otherwise the 1610 will\n \t\t      attempt to transfer all 32-bits of 'y', 'p' or an accumulator\n \t\t      , which we don't want */\n \t\t   if (REGNO(operands[1]) == REG_Y || REGNO(operands[1]) == REG_PROD\n@@ -985,10 +1473,9 @@\n \n                 case 9: case 10:\n \t\t   return \\\"%0=%1\\\";\n-                default:\n-                   abort();\n \t}\n-}\")\n+}\"\n+[(set_attr \"type\" \"data_move,data_move,data_move_short_i,data_move_i,data_move_memory,data_move_memory,data_move_memory,data_move_memory,nothing,malu,malu\")])\n \n (define_insn \"match_movqi2\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=A,r,aW,c,?D,m<>,e,Y,r,xyz,m<>\")\n@@ -1000,7 +1487,7 @@\n \tswitch (which_alternative)\n \t{\n \t\tcase 0:\n-\t\t   /* We have to use the move mnemonic otherwise the 1610 will\n+\t\t   /* We have to use the move mneumonic otherwise the 1610 will\n \t\t      attempt to transfer all 32-bits of 'y', 'p' or an accumulator\n \t\t      , which we don't want */\n \t\t   if (REGNO(operands[1]) == REG_Y || REGNO(operands[1]) == REG_PROD\n@@ -1033,10 +1520,9 @@\n \n                 case 9: case 10:\n \t\t   return \\\"%0=%1\\\";\n-                default:\n-                   abort();\n \t}\n-}\")\n+}\"\n+[(set_attr \"type\" \"data_move,data_move,data_move_short_i,data_move_i,data_move_memory,data_move_memory,data_move_memory,data_move_memory,nothing,malu,malu\")])\n \n (define_expand \"reload_inqi\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=u\")\n@@ -1131,8 +1617,8 @@\n   operands[5] = addr0;\n   operands[6] = addr1;\n \n-  operands[0] = replace_equiv_address (operands[0], addr0);\n-  operands[1] = replace_equiv_address (operands[1], addr1);\n+  operands[0] = change_address (operands[0], VOIDmode, addr0);\n+  operands[1] = change_address (operands[1], VOIDmode, addr1);\n }\")\n \n (define_insn \"\"\n@@ -1190,8 +1676,6 @@\n \t\tcase 5:\n \t\tcase 6:\n \t\t   return \\\"%u0=%u1\\;%w0=%w1\\\";\n-                default:\n-                   abort();\n         }\n }\"\n [(set_attr \"type\" \"move,move,load_i,load,store,load,store\")])\n@@ -1258,9 +1742,16 @@\n   \"\n {\n \toperands[2] = gen_reg_rtx (HImode);\n-\toperands[3] = gen_rtx_SUBREG (QImode, operands[2], GET_MODE_SIZE (QImode));\n+\toperands[3] = gen_rtx_SUBREG (QImode, operands[2], 1);\n }\")\n \n+(define_insn \"internal_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n+\t(sign_extend:HI (match_operand:QI 1 \"register_operand\" \"ku\")))]\n+  \"TARGET_BMU\"\n+  \"%0 = extracts(%m1, 0x1000)\"\n+[(set_attr \"type\" \"shift_i\")])\n+\n ;;(define_insn \"extendqihi2\"\n ;;  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n ;;        (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"h\")))]\n@@ -1296,22 +1787,90 @@\n ;;    }\n ;; }\")\n \n+;;(define_expand \"zero_extendqihi2\"\n+;;  [(clobber (match_dup 2))\n+;;   (set (match_dup 3) (match_operand:QI 1 \"register_operand\" \"\"))\n+;;   (set (match_operand:HI 0 \"register_operand\" \"\")\n+;;\t(ashift:HI (match_dup 2)\n+;;\t\t   (const_int 16)))\n+;;   (set (match_dup 0)\n+;;\t(lshiftrt:HI (match_dup 0) (const_int 16)))]\n+;;  \"\"\n+;;  \"\n+;;{\n+;;\toperands[2] = gen_reg_rtx (HImode);\n+;;\toperands[3] = gen_rtx (SUBREG, QImode, operands[2], 1);\n+;;}\")\n+\n (define_expand \"zero_extendqihi2\"\n-  [(clobber (match_dup 2))\n-   (set (match_dup 3) (match_operand:QI 1 \"register_operand\" \"\"))\n-   (set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(ashift:HI (match_dup 2)\n-\t\t   (const_int 16)))\n-   (set (match_dup 0)\n-\t(lshiftrt:HI (match_dup 0) (const_int 16)))]\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+      (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"\")))]\n   \"\"\n-  \"\n-{\n-\toperands[2] = gen_reg_rtx (HImode);\n-\toperands[3] = gen_rtx_SUBREG (QImode, operands[2], GET_MODE_SIZE (QImode));\n-}\")\n+  \"\")  \n+\t\n+\n+(define_insn \"match_zero_extendqihi_bmu\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=?*Z,?*Z,?A,A\")\n+        (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"?A,?*Y,*Z*x*a*W*Y,ku\")))]\n+  \"TARGET_BMU\"\n+  \"*\n+ {\n+    switch (which_alternative)\n+      {\n+        case 0:\n+          return \\\"%w0=%1\\;%0=0\\\";\n+\n+        case 1:\n+          return \\\"%w0=%1\\;%0=0\\\";\n+\n+        case 2:\n+          if (REGNO(operands[1]) == (REGNO(operands[0]) + 1))\n+            return \\\"%0=0\\\";\n+          else if (REGNO(operands[1]) == REG_Y || REGNO(operands[1]) == REG_PROD\n+\t           || IS_ACCUM_REG(REGNO(operands[1])))\n+          {\n+            return \\\"move %w0=%1\\;%0=0\\\";\n+          }\n+          else\n+            return \\\"%w0=%1\\;%0=0\\\";\n+\n+\tcase 3:\n+\t  return \\\"%0 = extractz(%m1, 0x1000)\\\";\n+      }\n+  }\"\n+  [(set_attr \"type\" \"data_move_2,data_move_2,data_move_2,shift_i\")])\n \n+(define_insn \"match_zero_extendqihi2_nobmu\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=?Z,?Z,A\")\n+        (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"A,Y,r\")))]\n+  \"\"\n+  \"*\n+ {\n+    switch (which_alternative)\n+      {\n+        case 0:\n+          return \\\"%w0=%1\\;%0=0\\\";\n+\n+        case 1:\n+          return \\\"%w0=%1\\;%0=0\\\";\n+\n+        case 2:\n+          if (REGNO(operands[1]) + 1 == (REGNO(operands[0]) + 1))\n+            return \\\"%0=0\\\";\n+          else if (REGNO(operands[1]) == REG_Y || REGNO(operands[1]) == REG_PROD\n+\t           || IS_ACCUM_REG(REGNO(operands[1])))\n+          {\n+            return \\\"move %w0=%1\\;%0=0\\\";\n+          }\n+          else\n+            return \\\"%w0=%1\\;%0=0\\\";\n+      }\n+  }\"\n+  [(set_attr \"type\" \"data_move_2,data_move_2,data_move_2\")])\n \n+;;\n+;; Floating point conversions\n+;;\n (define_expand \"floathihf2\"\n   [(set (match_operand:HF 0 \"register_operand\" \"\")\n \t(float:HF (match_operand:HI 1 \"register_operand\" \"\")))]\n@@ -1467,7 +2026,7 @@\n \t    rtx stack_slot;\n \t    \n \t    stack_slot = assign_stack_temp (QImode, GET_MODE_SIZE(QImode), 0);\n-\t    stack_slot = validize_mem (stack_slot);\n+\t    stack_slot = change_address (stack_slot, VOIDmode, XEXP (stack_slot, 0));\n \t    emit_move_insn (stack_slot, operands[2]);\n \t    operands[2] = stack_slot;\n \t  }\n@@ -1506,9 +2065,9 @@\n   else\n     {\n       output_asm_insn (\\\"cloop=%2\\\", operands);\n-      output_asm_insn (\\\"do 0 \\{\\\", operands);\n+      output_asm_insn (\\\"do 0 {\\\", operands);\n       output_asm_insn (\\\"%0=%0>>1\\\", operands);\n-      return \\\"\\}\\\";\n+      return \\\"}\\\";\n     }\n }\")\n \t\t   \n@@ -1521,31 +2080,31 @@\n   [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n         (lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"A\")\n                      (const_int 1)))]\n-  \"\"\n+  \"!TARGET_BMU\"\n   \"%0=%1>>1\\;%0=%b0&0x7fff\"\n   [(set_attr \"type\" \"special\")])\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n         (lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"A\")\n                      (const_int 4)))]\n-  \"\"\n+  \"!TARGET_BMU\"\n   \"%0=%1>>4\\;%0=%b0&0x0fff\"\n   [(set_attr \"type\" \"special\")])\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n         (lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"A\")\n                      (const_int 8)))]\n-  \"\"\n+  \"!TARGET_BMU\"\n   \"%0=%1>>8\\;%0=%b0&0x00ff\"\n   [(set_attr \"type\" \"special\")])\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n         (lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"A\")\n                      (const_int 16)))]\n-  \"\"\n+  \"!TARGET_BMU\"\n   \"%0=%1>>16\\;%0=%b0&0x0000\"\n   [(set_attr \"type\" \"special\")])\n \n@@ -1592,7 +2151,7 @@\n \t      rtx stack_slot;\n \t    \n \t      stack_slot = assign_stack_temp (QImode, GET_MODE_SIZE(QImode), 0);\n-\t      stack_slot = validize_mem (stack_slot);\n+\t      stack_slot = change_address (stack_slot, VOIDmode, XEXP (stack_slot, 0));\n \t      emit_move_insn (stack_slot, operands[2]);\n \t      operands[2] = stack_slot;\n \t    }\n@@ -1633,9 +2192,9 @@\n     {\n       output_asm_insn (\\\"%3=psw\\;psw=0\\\",operands);\n       output_asm_insn (\\\"cloop=%2\\\", operands);\n-      output_asm_insn (\\\"do 0 \\{\\\", operands);\n+      output_asm_insn (\\\"do 0 {\\\", operands);\n       output_asm_insn (\\\"%0=%0>>1\\\", operands);\n-      output_asm_insn (\\\"\\}\\\", operands);\n+      output_asm_insn (\\\"}\\\", operands);\n       return \\\"psw=%3\\\";\n     }\n }\")\n@@ -1671,14 +2230,6 @@\n   \"%0=%1<<8\"\n   [(set_attr \"type\" \"special\")])\n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n-\t(ashift:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"A\"))\n-\t\t   (const_int 16)))]\n-  \"\"\n-  \"%0=%1<<16\"\n-  [(set_attr \"type\" \"special\")])\n-\n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n         (ashift:HI (match_operand:HI 1 \"general_operand\" \"A\")\n@@ -1729,18 +2280,16 @@\n \temit_barrier ();\n \temit_label (label1);\n \n-\tif (GET_CODE (operands[2]) != MEM)\n+\tif (GET_CODE(operands[2]) != MEM)\n \t  {\n \t    rtx stack_slot;\n \t    \n \t    stack_slot = assign_stack_temp (QImode, GET_MODE_SIZE(QImode), 0);\n-\t    stack_slot = validize_mem (stack_slot);\n+\t    stack_slot = change_address (stack_slot, VOIDmode, XEXP (stack_slot, 0));\n \t    emit_move_insn (stack_slot, operands[2]);\n \t    operands[2] = stack_slot;\n \t  }\n-\n-\temit_insn (gen_match_ashlhi3_nobmu (operands[0], operands[1],\n-\t\t\t\t\t    operands[2]));\n+\temit_insn (gen_match_ashlhi3_nobmu (operands[0], operands[1], operands[2]));\n \temit_label (label2);\n \tDONE;\n #endif\n@@ -1757,7 +2306,7 @@\n    %0=%1<<%2\\;move %u0=%u0\n    %0=%1<<%H2\\;move %u0=%u0\n    %0=%1<<%2\\;move %u0=%u0\"\n-  [(set_attr \"type\" \"shift,shift_i,shift\")])\n+  [(set_attr \"type\" \"shift_multiple,shift_multiple,shift_multiple\")])\n \n (define_insn \"match_ashlhi3_nobmu\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=A,A\")\n@@ -1774,14 +2323,184 @@\n   else\n     {\n       output_asm_insn (\\\"cloop=%2\\\", operands);\n-      output_asm_insn (\\\"do 0 \\{\\\", operands);\n+      output_asm_insn (\\\"do 0 {\\\", operands);\n       output_asm_insn (\\\"%0=%0<<1\\\", operands);\n-      return \\\"\\}\\\";\n+      return \\\"}\\\";\n     }\n }\")\n \n \f\n \n+\n+(define_insn \"extv\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=k,u\")\n+\t(sign_extract:QI (match_operand:QI 1 \"register_operand\" \"ku,ku\")\n+\t\t\t (match_operand:QI 2 \"const_int_operand\" \"n,n\")\n+\t\t\t (match_operand:QI 3 \"const_int_operand\" \"n,n\")))\n+\t(clobber (match_scratch:QI 4 \"=j,q\"))]\n+  \"TARGET_BMU\"\n+  \"*\n+{\n+\toperands[5]\n+\t= GEN_INT ((INTVAL (operands[2]) << 8) + (INTVAL (operands[3]) & 0xff));\n+\treturn \\\"%m0 = extracts (%m1, %H5)\\\";\n+}\"\n+[(set_attr \"type\" \"shift_i\")])\n+\n+(define_insn \"extzv\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=k,u\")\n+\t(zero_extract:QI (match_operand:QI 1 \"register_operand\" \"ku,ku\")\n+\t\t\t (match_operand:QI 2 \"const_int_operand\" \"n,n\")\n+\t\t\t (match_operand:QI 3 \"const_int_operand\" \"n,n\")))\n+\t(clobber (match_scratch:QI 4 \"=j,q\"))]\n+  \"TARGET_BMU\"\n+  \"*\n+{\n+\toperands[5]\n+\t= GEN_INT ((INTVAL (operands[2]) << 8) + (INTVAL (operands[3]) & 0xff));\n+\treturn \\\"%m0 = extractz (%m1, %H5)\\\";\n+}\"\n+[(set_attr \"type\" \"shift_i\")])\n+\n+;;\n+;; conditional instructions\n+;;\n+\n+(define_expand \"seq\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(eq:QI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{ \n+   if (dsp16xx_compare_gen == gen_compare_reg)\n+     operands[1] = (*dsp16xx_compare_gen)(EQ, dsp16xx_compare_op0, dsp16xx_compare_op1);\n+   else\n+     operands[1] = (*dsp16xx_compare_gen)(dsp16xx_compare_op0);\n+}\")\n+\n+(define_expand \"sne\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(ne:QI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{ \n+   if (dsp16xx_compare_gen == gen_compare_reg)\n+     operands[1] = (*dsp16xx_compare_gen)(NE, dsp16xx_compare_op0, dsp16xx_compare_op1);\n+   else\n+     operands[1] = (*dsp16xx_compare_gen)(dsp16xx_compare_op0);\n+}\")\n+\n+\n+(define_expand \"sgt\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(gt:QI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{ \n+   if (dsp16xx_compare_gen == gen_compare_reg)\n+     operands[1] = (*dsp16xx_compare_gen)(GT, dsp16xx_compare_op0, dsp16xx_compare_op1);\n+   else\n+     operands[1] = (*dsp16xx_compare_gen)(dsp16xx_compare_op0);\n+}\")\n+\n+\n+(define_expand \"slt\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(lt:QI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{ \n+   if (dsp16xx_compare_gen == gen_compare_reg)\n+     operands[1] = (*dsp16xx_compare_gen)(LT, dsp16xx_compare_op0, dsp16xx_compare_op1);\n+   else\n+     operands[1] = (*dsp16xx_compare_gen)(dsp16xx_compare_op0);\n+}\")\n+\n+(define_expand \"sge\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(ge:QI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{ \n+   if (dsp16xx_compare_gen == gen_compare_reg)\n+     operands[1] = (*dsp16xx_compare_gen)(GE, dsp16xx_compare_op0, dsp16xx_compare_op1);\n+   else\n+     operands[1] = (*dsp16xx_compare_gen)(dsp16xx_compare_op0);\n+}\")\n+\n+\n+(define_expand \"sle\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(le:QI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{ \n+   if (dsp16xx_compare_gen == gen_compare_reg)\n+     operands[1] = (*dsp16xx_compare_gen)(LE, dsp16xx_compare_op0, dsp16xx_compare_op1);\n+   else\n+     operands[1] = (*dsp16xx_compare_gen)(dsp16xx_compare_op0);\n+}\")\n+\n+\n+(define_expand \"sgtu\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(gtu:QI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{ \n+   if (dsp16xx_compare_gen == gen_compare_reg)\n+     operands[1] = (*dsp16xx_compare_gen)(GTU, dsp16xx_compare_op0, dsp16xx_compare_op1);\n+   else\n+     operands[1] = (*dsp16xx_compare_gen)(dsp16xx_compare_op0);\n+}\")\n+\n+\n+(define_expand \"sltu\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(ltu:QI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{ \n+   if (dsp16xx_compare_gen == gen_compare_reg)\n+     operands[1] = (*dsp16xx_compare_gen)(LTU, dsp16xx_compare_op0, dsp16xx_compare_op1);\n+   else\n+     operands[1] = (*dsp16xx_compare_gen)(dsp16xx_compare_op0);\n+}\")\n+\n+\n+(define_expand \"sgeu\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(geu:QI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{ \n+   if (dsp16xx_compare_gen == gen_compare_reg)\n+     operands[1] = (*dsp16xx_compare_gen)(GEU, dsp16xx_compare_op0, dsp16xx_compare_op1);\n+   else\n+     operands[1] = (*dsp16xx_compare_gen)(dsp16xx_compare_op0);\n+}\")\n+\n+\n+(define_expand \"sleu\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(leu:QI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{ \n+   if (dsp16xx_compare_gen == gen_compare_reg)\n+     operands[1] = (*dsp16xx_compare_gen)(LEU, dsp16xx_compare_op0, dsp16xx_compare_op1);\n+   else\n+     operands[1] = (*dsp16xx_compare_gen)(dsp16xx_compare_op0);\n+}\")\n+\n+\n+(define_insn \"scc\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=jq\")\n+\t(match_operator:QI 1 \"comparison_operator\" [(cc0) (const_int 0)]))]\n+  \"\"\n+  \"%0 = 0\\;if %C1 %b0 = %b0 + 1\"\n+  [(set_attr \"type\" \"special_2\")])\n+\n ;;\n ;; Jump Instructions\n ;;\n@@ -2138,45 +2857,168 @@\n \n \n (define_peephole\n-  [(set (match_operand:QI 0 \"register_operand\" \"=A\")\n-        (reg:QI 16))\n-   (call (mem:QI (match_dup 0))\n-\t (match_operand 1 \"\" \"i\"))]\n-   \"\"\n-   \"call pt\")\n+  [(parallel [(set (cc0) \n+\t\t   (compare (match_operand:QI 0 \"register_operand\"  \"k,k,!k,u,u,!u\")\n+\t\t\t    (match_operand:QI 1 \"register_operand\"  \"w,z,u,w,z,k\")))\n+\t      (use (match_operand:QI 2 \"register_operand\" \"=j,j,j,q,q,q\"))\n+\t      (use (match_operand:QI 3 \"register_operand\" \"=v,y,q,v,y,j\"))])\n+   (set (pc)\t\n+\t(if_then_else (match_operator 5 \"uns_comparison_operator\" \n+                                      [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 4 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"!TARGET_NEAR_JUMP\"\n+  \"pt=%l4\\;%2-%3\\;if %C5 goto pt\")\n+\n+(define_peephole\n+  [(parallel [(set (cc0) \n+\t\t   (compare (match_operand:QI 0 \"register_operand\"  \"k,k,!k,u,u,!u\")\n+\t\t\t    (match_operand:QI 1 \"register_operand\"  \"w,z,u,w,z,k\")))\n+\t      (use (match_operand:QI 2 \"register_operand\" \"=j,j,j,q,q,q\"))\n+\t      (use (match_operand:QI 3 \"register_operand\" \"=v,y,q,v,y,j\"))])\n+   (set (pc)\t\n+\t(if_then_else (match_operator 5 \"uns_comparison_operator\" \n+                                      [(cc0) (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 4 \"\" \"\"))))]\n+  \"!TARGET_NEAR_JUMP\"\n+  \"pt=%l4\\;%2-%3\\;if %I5 goto pt\")\n+\n+\n+(define_peephole\n+  [(parallel [(set (cc0) \n+\t\t   (compare (match_operand:QI 0 \"register_operand\"  \"k,u\")\n+\t\t\t    (match_operand:QI 1 \"const_int_operand\" \"i,i\")))\n+\t      (use (match_operand:QI 2 \"register_operand\" \"=j,q\"))])\n+   (set (pc)\t\n+\t(if_then_else (match_operator 4 \"uns_comparison_operator\" \n+                                      [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"!TARGET_NEAR_JUMP\"\n+  \"pt=%l3\\;%0-%H1\\;if %C4 goto pt\")\n+\n+(define_peephole\n+  [(parallel [(set (cc0) \n+\t\t   (compare (match_operand:QI 0 \"register_operand\"  \"k,u\")\n+\t\t\t    (match_operand:QI 1 \"const_int_operand\" \"i,i\")))\n+\t      (use (match_operand:QI 2 \"register_operand\" \"=j,q\"))])\n+   (set (pc)\t\n+\t(if_then_else (match_operator 4 \"uns_comparison_operator\" \n+                                      [(cc0) (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))))]\n+  \"!TARGET_NEAR_JUMP\"\n+  \"pt=%l3\\;%0-%H1\\;if %I4 goto pt\")\n+\n+;;\n+;;; QImode SIGNED COMPARE PEEPHOLE OPTIMIZATIONS\n+;;\n+\n+(define_peephole\n+  [(parallel [(set (cc0) \n+\t\t   (compare (match_operand:QI 0 \"register_operand\"  \"j,j,h,q,q,q\")\n+\t\t\t    (match_operand:QI 1 \"register_operand\"  \"v,y,q,v,y,j\")))\n+\t      (use (match_operand:QI 2 \"register_operand\" \"=k,k,k,u,u,u\"))\n+\t      (use (match_operand:QI 3 \"register_operand\" \"=w,z,u,w,z,k\"))])\n+   (set (pc)\t\n+\t(if_then_else (match_operator 5 \"signed_comparison_operator\" \n+                                      [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 4 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"!TARGET_NEAR_JUMP\"\n+  \"pt=%l4\\;%0-%1\\;if %C5 goto pt\")\n+\n+\n+(define_peephole\n+  [(parallel [(set (cc0) \n+\t\t   (compare (match_operand:QI 0 \"register_operand\"  \"j,j,j,q,q,q\")\n+\t\t\t    (match_operand:QI 1 \"register_operand\"  \"v,y,q,v,y,j\")))\n+\t      (use (match_operand:QI 2 \"register_operand\" \"=k,k,k,u,u,u\"))\n+\t      (use (match_operand:QI 3 \"register_operand\" \"=w,z,u,w,z,k\"))])\n+   (set (pc)\t\n+\t(if_then_else (match_operator 5 \"signed_comparison_operator\" \n+                                      [(cc0) (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 4 \"\" \"\"))))]\n+  \"!TARGET_NEAR_JUMP\"\n+  \"pt=%l4\\;%0-%1\\;if %I5 goto pt\")\n \n \n (define_peephole\n-  [(set (match_operand:QI 0 \"register_operand\" \"=A\")\n-        (reg:QI 16))\n-   (set (match_operand 1 \"\" \"\")\n-        (call (mem:QI (match_dup 0))\n-\t      (match_operand 2 \"\" \"i\")))]\n-   \"\"\n-   \"call pt\")\n+  [(parallel [(set (cc0) \n+\t\t   (compare (match_operand:QI 0 \"register_operand\"  \"j,q\")\n+\t\t\t    (match_operand:QI 1 \"const_int_operand\" \"i,i\")))\n+\t      (use (match_operand:QI 2 \"register_operand\" \"=k,u\"))])\n+   (set (pc)\t\n+\t(if_then_else (match_operator 4 \"signed_comparison_operator\" \n+                                      [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"!TARGET_NEAR_JUMP\"\n+  \"pt=%l3\\;%b0-%H1\\;if %C4 goto pt\")\n \n (define_peephole\n-  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n-\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"A\")\n-\t\t   (const_int 16)))\n-   (set (match_operand:HI 2 \"register_operand\" \"\")\n-\t(match_dup 0))\n-   (set (match_dup 0)\n-\t(ashiftrt:HI (match_dup 0) (const_int 16)))\n-   (set (match_dup 2)\n-\t(match_dup 0))]\n-  \"\"\n-  \"%0=%1<<16\\;%0=%0>>16\\;%u2=%u0\\;%w2=%w0\")\n+  [(parallel [(set (cc0) \n+\t\t   (compare (match_operand:QI 0 \"register_operand\"  \"j,q\")\n+\t\t\t    (match_operand:QI 1 \"const_int_operand\" \"i,i\")))\n+\t      (use (match_operand:QI 2 \"register_operand\" \"=k,u\"))])\n+   (set (pc)\t\n+\t(if_then_else (match_operator 4 \"signed_comparison_operator\" \n+                                      [(cc0) (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))))]\n+  \"!TARGET_NEAR_JUMP\"\n+  \"pt=%l3\\;%b0-%H1\\;if %I4 goto pt\")\n+\n+;; TST PEEPHOLE PATTERNS\n \n (define_peephole\n-  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n-\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"A\")\n-\t\t   (const_int 16)))\n-   (set (match_operand:HI 2 \"register_operand\" \"\")\n-\t(match_dup 0))\n-   (set (match_dup 0)\n-\t(lshiftrt:HI (match_dup 0) (const_int 16)))\n-   (set (match_dup 2)\n-\t(match_dup 0))]\n-  \"\"\n-  \"%0=%1<<16\\;%0=%0>>16\\;%0=%b0&0x0000\\;%u2=%u0\\;%w2=%w0\")\n+  [(parallel [(set (cc0) \n+\t\t   (match_operand:QI 0 \"register_operand\"  \"j,q\"))\n+\t      (use (match_operand:QI 1 \"register_operand\" \"=k,u\"))])\n+   (set (pc)\t\n+\t(if_then_else (match_operator 3 \"signed_comparison_operator\" \n+                                      [(cc0) (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"!TARGET_NEAR_JUMP\"\n+  \"pt=%l2\\;%b0-0\\;if %I3 goto pt\")\n+\n+(define_peephole\n+  [(parallel [(set (cc0) \n+\t\t   (match_operand:QI 0 \"register_operand\"  \"j,q\"))\n+\t      (use (match_operand:QI 1 \"register_operand\" \"=k,u\"))])\n+   (set (pc)\t\n+\t(if_then_else (match_operator 3 \"signed_comparison_operator\" \n+                                      [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"!TARGET_NEAR_JUMP\"\n+  \"pt=%l2\\;%b0-0\\;if %C3 goto pt\")\n+\n+;; HImode peephole patterns\n+\n+(define_peephole\n+  [(set (cc0) \n+\t(compare (match_operand:HI 0 \"register_operand\"  \"A,A\")\n+\t\t (match_operand:HI 1 \"register_operand\"  \"Z,A\")))\n+   (set (pc)\t\n+\t(if_then_else (match_operator 3 \"signed_comparison_operator\" \n+                                      [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"!TARGET_NEAR_JUMP\"\n+  \"pt=%l2\\;%0-%1\\;if %C3 goto pt\")\n+\n+(define_peephole\n+  [(set (cc0) \n+\t(compare (match_operand:HI 0 \"register_operand\"  \"A,A\")\n+\t\t (match_operand:HI 1 \"register_operand\"  \"Z,A\")))\n+   (set (pc)\t\n+\t(if_then_else (match_operator 3 \"signed_comparison_operator\" \n+                                      [(cc0) (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"!TARGET_NEAR_JUMP\"\n+  \"pt=%l2\\;%0-%1\\;if %I3 goto pt\")"}]}