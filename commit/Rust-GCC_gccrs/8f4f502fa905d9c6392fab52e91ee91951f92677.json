{"sha": "8f4f502fa905d9c6392fab52e91ee91951f92677", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY0ZjUwMmZhOTA1ZDljNjM5MmZhYjUyZTkxZWU5MTk1MWY5MjY3Nw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-05-25T22:34:36Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-05-25T22:34:36Z"}, "message": "function.h (struct function): Add can_throw_non_call_exceptions bit.\n\n\t* function.h (struct function): Add can_throw_non_call_exceptions bit.\n\t* lto-streamer-in.c (input_function): Stream it in.\n\t* lto-streamer-out.c (output_function): Stream it out.\n\t* function.c (allocate_struct_function): Set it.\n\t(expand_function_end): Substitute cfun->can_throw_non_call_exceptions\n\tfor flag_non_call_exceptions.\n\t* cfgbuild.c (control_flow_insn_p): Likewise.\n\t(make_edges): Likewise.\n\t* cfgexpand.c (expand_stack_alignment): Likewise.\n\t* combine.c (distribute_notes): Likewise.\n\t* cse.c (cse_extended_basic_block): Likewise.\n\t* except.c (insn_could_throw_p): Likewise.\n\t* gcse.c (simple_mem): Likewise.\n\t* ipa-pure-const.c (check_call): Likewise.\n\t(check_stmt ): Likewise.\n\t* lower-subreg.c (lower-subreg.c): Likewise.\n\t* optabs.c (emit_libcall_block): Likewise.\n\t(prepare_cmp_insn): Likewise.\n\t* postreload-gcse.c (eliminate_partially_redundant_loads): Likewise.\n\t* postreload.c (rest_of_handle_postreload): Likewise.\n\t* reload1.c (reload_as_needed): Likewise.\n\t(emit_input_reload_insns): Likewise.\n\t(emit_output_reload_insns): Likewise.\n\t(fixup_abnormal_edges): Likewise.\n\t* sel-sched-ir.c (init_global_and_expr_for_insn): Likewise.\n\t* store-motion.c (find_moveable_store): Likewise.\n\t* tree-eh.c (stmt_could_throw_p): Likewise.\n\t(tree_could_throw_p): Likewise.\n\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Likewise.\n\t* config/arm/arm.c (arm_expand_prologue): Likewise.\n\t(thumb1_expand_prologue): Likewise.\n\t* config/rx/rx.md (cbranchsf4): Likewise.\n\t(cmpsf): Likewise.\n\t* config/s390/s390.c (s390_emit_prologue): Likewise.\n\t* tree-inline.c (initialize_cfun): Copy can_throw_non_call_exceptions.\n\t(inline_forbidden_into_p): New predicate.\n\t(expand_call_inline): Use it to forbid inlining.\n\t(tree_can_inline_p): Likewise.\n\nFrom-SVN: r159847", "tree": {"sha": "68704a635c87543f5b0b6647ea71731266f962b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68704a635c87543f5b0b6647ea71731266f962b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f4f502fa905d9c6392fab52e91ee91951f92677", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f4f502fa905d9c6392fab52e91ee91951f92677", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f4f502fa905d9c6392fab52e91ee91951f92677", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f4f502fa905d9c6392fab52e91ee91951f92677/comments", "author": null, "committer": null, "parents": [{"sha": "c962b78d00daa18f54b12440a8de1a8d552ab531", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c962b78d00daa18f54b12440a8de1a8d552ab531", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c962b78d00daa18f54b12440a8de1a8d552ab531"}], "stats": {"total": 173, "additions": 120, "deletions": 53}, "files": [{"sha": "ed93893cea4d223e47bd3388d4f1694e944c8512", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -1,3 +1,44 @@\n+2010-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* function.h (struct function): Add can_throw_non_call_exceptions bit.\n+\t* lto-streamer-in.c (input_function): Stream it in.\n+\t* lto-streamer-out.c (output_function): Stream it out.\n+\t* function.c (allocate_struct_function): Set it.\n+\t(expand_function_end): Substitute cfun->can_throw_non_call_exceptions\n+\tfor flag_non_call_exceptions.\n+\t* cfgbuild.c (control_flow_insn_p): Likewise.\n+\t(make_edges): Likewise.\n+\t* cfgexpand.c (expand_stack_alignment): Likewise.\n+\t* combine.c (distribute_notes): Likewise.\n+\t* cse.c (cse_extended_basic_block): Likewise.\n+\t* except.c (insn_could_throw_p): Likewise.\n+\t* gcse.c (simple_mem): Likewise.\n+\t* ipa-pure-const.c (check_call): Likewise.\n+\t(check_stmt ): Likewise.\n+\t* lower-subreg.c (lower-subreg.c): Likewise.\n+\t* optabs.c (emit_libcall_block): Likewise.\n+\t(prepare_cmp_insn): Likewise.\n+\t* postreload-gcse.c (eliminate_partially_redundant_loads): Likewise.\n+\t* postreload.c (rest_of_handle_postreload): Likewise.\n+\t* reload1.c (reload_as_needed): Likewise.\n+\t(emit_input_reload_insns): Likewise.\n+\t(emit_output_reload_insns): Likewise.\n+\t(fixup_abnormal_edges): Likewise.\n+\t* sel-sched-ir.c (init_global_and_expr_for_insn): Likewise.\n+\t* store-motion.c (find_moveable_store): Likewise.\n+\t* tree-eh.c (stmt_could_throw_p): Likewise.\n+\t(tree_could_throw_p): Likewise.\n+\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Likewise.\n+\t* config/arm/arm.c (arm_expand_prologue): Likewise.\n+\t(thumb1_expand_prologue): Likewise.\n+\t* config/rx/rx.md (cbranchsf4): Likewise.\n+\t(cmpsf): Likewise.\n+\t* config/s390/s390.c (s390_emit_prologue): Likewise.\n+\t* tree-inline.c (initialize_cfun): Copy can_throw_non_call_exceptions.\n+\t(inline_forbidden_into_p): New predicate.\n+\t(expand_call_inline): Use it to forbid inlining.\n+\t(tree_can_inline_p): Likewise.\n+\n 2010-05-25  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* config/i386/i386-c.c: Do not include rtl.h."}, {"sha": "c53450ca5533cbe480a5121828d4977d802a2be9", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -112,7 +112,7 @@ control_flow_insn_p (const_rtx insn)\n       if (GET_CODE (PATTERN (insn)) == TRAP_IF\n \t  && XEXP (PATTERN (insn), 0) == const1_rtx)\n \treturn true;\n-      if (!flag_non_call_exceptions)\n+      if (!cfun->can_throw_non_call_exceptions)\n \treturn false;\n       break;\n \n@@ -333,7 +333,7 @@ make_edges (basic_block min, basic_block max, int update_p)\n \t handler for this CALL_INSN.  If we're handling non-call\n \t exceptions then any insn can reach any of the active handlers.\n \t Also mark the CALL_INSN as reaching any nonlocal goto handler.  */\n-      else if (code == CALL_INSN || flag_non_call_exceptions)\n+      else if (code == CALL_INSN || cfun->can_throw_non_call_exceptions)\n \t{\n \t  /* Add any appropriate EH edges.  */\n \t  rtl_make_eh_edge (edge_cache, bb, insn);"}, {"sha": "cc8ff336a42e5364022c1a3e49ef2d0386df0ca4", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -3683,7 +3683,7 @@ expand_stack_alignment (void)\n      stack.  We check PREFERRED_STACK_BOUNDARY if there may be non-call\n      exceptions since callgraph doesn't collect incoming stack alignment\n      in this case.  */\n-  if (flag_non_call_exceptions\n+  if (cfun->can_throw_non_call_exceptions\n       && PREFERRED_STACK_BOUNDARY > crtl->preferred_stack_boundary)\n     preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;\n   else"}, {"sha": "e9389d7b2b7c9f635417d360e26f1fb9f2baccdd", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -12734,7 +12734,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t    place = i2;\n \t  else\n \t    {\n-\t      gcc_assert (flag_non_call_exceptions);\n+\t      gcc_assert (cfun->can_throw_non_call_exceptions);\n \t      if (may_trap_p (i3))\n \t\tplace = i3;\n \t      else if (i2 && may_trap_p (i2))"}, {"sha": "6c886dccaef96f2af6db9caad4ea2fb0384d31a1", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -15005,7 +15005,7 @@ arm_expand_prologue (void)\n      using the EABI unwinder, to prevent faulting instructions from being\n      swapped with a stack adjustment.  */\n   if (crtl->profile || !TARGET_SCHED_PROLOG\n-      || (ARM_EABI_UNWIND_TABLES && flag_non_call_exceptions))\n+      || (ARM_EABI_UNWIND_TABLES && cfun->can_throw_non_call_exceptions))\n     emit_insn (gen_blockage ());\n \n   /* If the link register is being kept alive, with the return address in it,\n@@ -19541,7 +19541,7 @@ thumb1_expand_prologue (void)\n      using the EABI unwinder, to prevent faulting instructions from being\n      swapped with a stack adjustment.  */\n   if (crtl->profile || !TARGET_SCHED_PROLOG\n-      || (ARM_EABI_UNWIND_TABLES && flag_non_call_exceptions))\n+      || (ARM_EABI_UNWIND_TABLES && cfun->can_throw_non_call_exceptions))\n     emit_insn (gen_blockage ());\n \n   cfun->machine->lr_save_eliminated = !thumb_force_lr_save ();"}, {"sha": "274ce6f3c66bc19e87a27e8d66b628564a3b4bf6", "filename": "gcc/config/rx/rx.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fconfig%2Frx%2Frx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fconfig%2Frx%2Frx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.md?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -176,7 +176,7 @@\n \t\t\t\t\t  [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 3 \"\"))\n \t\t      (pc)))]\n-  \"ALLOW_RX_FPU_INSNS && ! flag_non_call_exceptions\"\n+  \"ALLOW_RX_FPU_INSNS && !cfun->can_throw_non_call_exceptions\"\n   \"\"\n )\n \n@@ -211,7 +211,7 @@\n    (set_attr \"length\"  \"2,2,3,4,5,6,5\")]\n )\n \n-;; This pattern is disabled when -fnon-call-exceptions is active because\n+;; This pattern is disabled if the function can throw non-call exceptions,\n ;; it could generate a floating point exception, which would introduce an\n ;; edge into the flow graph between this insn and the conditional branch\n ;; insn to follow, thus breaking the cc0 relationship.  Run the g++ test\n@@ -220,7 +220,7 @@\n   [(set (cc0)\n \t(compare:CC (match_operand:SF 0 \"register_operand\"  \"r,r,r\")\n \t\t    (match_operand:SF 1 \"rx_source_operand\" \"r,i,Q\")))]\n-  \"ALLOW_RX_FPU_INSNS && ! flag_non_call_exceptions\"\n+  \"ALLOW_RX_FPU_INSNS && !cfun->can_throw_non_call_exceptions\"\n   {\n     rx_float_compare_mode = true;\n     return \"fcmp\\t%1, %0\";"}, {"sha": "412486ba5c84a5188396cc0d52cd4cee5c8d6f7f", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -7966,11 +7966,10 @@ s390_emit_prologue (void)\n \t  insn = emit_insn (gen_move_insn (addr, temp_reg));\n \t}\n \n-      /* If we support asynchronous exceptions (e.g. for Java),\n+      /* If we support non-call exceptions (e.g. for Java),\n \t we need to make sure the backchain pointer is set up\n \t before any possibly trapping memory access.  */\n-\n-      if (TARGET_BACKCHAIN && flag_non_call_exceptions)\n+      if (TARGET_BACKCHAIN && cfun->can_throw_non_call_exceptions)\n \t{\n \t  addr = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode));\n \t  emit_clobber (addr);"}, {"sha": "e45c9b25b1677a83aba6346fc3a696ac3310c793", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -6388,7 +6388,7 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n       /* With non-call exceptions, we are not always able to update\n \t the CFG properly inside cse_insn.  So clean up possibly\n \t redundant EH edges here.  */\n-      if (flag_non_call_exceptions && have_eh_succ_edges (bb))\n+      if (cfun->can_throw_non_call_exceptions && have_eh_succ_edges (bb))\n \tcse_cfg_altered |= purge_dead_edges (bb);\n \n       /* If we changed a conditional jump, we may have terminated"}, {"sha": "393a8011e0d67cb2bd4ce5b8d7eb17492d3b5e08", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -1619,7 +1619,7 @@ insn_could_throw_p (const_rtx insn)\n {\n   if (CALL_P (insn))\n     return true;\n-  if (INSN_P (insn) && flag_non_call_exceptions)\n+  if (INSN_P (insn) && cfun->can_throw_non_call_exceptions)\n     return may_trap_p (PATTERN (insn));\n   return false;\n }"}, {"sha": "a39ee7c184809713610cac674bb3eaa14da0389a", "filename": "gcc/function.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -4233,6 +4233,10 @@ allocate_struct_function (tree fndecl, bool abstract_p)\n       /* Assume all registers in stdarg functions need to be saved.  */\n       cfun->va_list_gpr_size = VA_LIST_MAX_GPR_SIZE;\n       cfun->va_list_fpr_size = VA_LIST_MAX_FPR_SIZE;\n+\n+      /* ??? This could be set on a per-function basis by the front-end\n+         but is this worth the hassle?  */\n+      cfun->can_throw_non_call_exceptions = flag_non_call_exceptions;\n     }\n }\n \n@@ -4246,7 +4250,7 @@ push_struct_function (tree fndecl)\n   allocate_struct_function (fndecl, false);\n }\n \n-/* Reset cfun, and other non-struct-function variables to defaults as\n+/* Reset crtl and other non-struct-function variables to defaults as\n    appropriate for emitting rtl at the start of a function.  */\n \n static void\n@@ -4778,7 +4782,7 @@ expand_function_end (void)\n       /* We want to ensure that instructions that may trap are not\n \t moved into the epilogue by scheduling, because we don't\n \t always emit unwind information for the epilogue.  */\n-      if (flag_non_call_exceptions)\n+      if (cfun->can_throw_non_call_exceptions)\n \temit_insn (gen_blockage ());\n     }\n \n@@ -4924,7 +4928,7 @@ expand_function_end (void)\n   /* @@@ This is a kludge.  We want to ensure that instructions that\n      may trap are not moved into the epilogue by scheduling, because\n      we don't always emit unwind information for the epilogue.  */\n-  if (! USING_SJLJ_EXCEPTIONS && flag_non_call_exceptions)\n+  if (!USING_SJLJ_EXCEPTIONS && cfun->can_throw_non_call_exceptions)\n     emit_insn (gen_blockage ());\n \n   /* If stack protection is enabled for this function, check the guard.  */"}, {"sha": "deb170dc38cfea23fcc303477c925140413cff1c", "filename": "gcc/function.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -580,6 +580,10 @@ struct GTY(()) function {\n   unsigned int after_inlining : 1;\n   unsigned int always_inline_functions_inlined : 1;\n \n+  /* Nonzero if function being compiled can throw synchronous non-call\n+     exceptions.  */\n+  unsigned int can_throw_non_call_exceptions : 1;\n+\n   /* Fields below this point are not set for abstract functions; see\n      allocate_struct_function.  */\n "}, {"sha": "b0a18689326e86105a5c3817be052ed7a2e3bb92", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -4667,9 +4667,9 @@ simple_mem (const_rtx x)\n     return 0;\n \n   /* If we are handling exceptions, we must be careful with memory references\n-     that may trap. If we are not, the behavior is undefined, so we may just\n+     that may trap.  If we are not, the behavior is undefined, so we may just\n      continue.  */\n-  if (flag_non_call_exceptions && may_trap_p (x))\n+  if (cfun->can_throw_non_call_exceptions && may_trap_p (x))\n     return 0;\n \n   if (side_effects_p (x))"}, {"sha": "c33b2d3f18b69db027b87e84ed80764320dc91fe", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -340,7 +340,7 @@ check_call (funct_state local, gimple call, bool ipa)\n         if (gimple_op (call, i)\n \t    && tree_could_throw_p (gimple_op (call, i)))\n \t  {\n-\t    if (possibly_throws && flag_non_call_exceptions)\n+\t    if (possibly_throws && cfun->can_throw_non_call_exceptions)\n \t      {\n \t\tif (dump_file)\n \t\t  fprintf (dump_file, \"    operand can throw; looping\\n\");\n@@ -405,7 +405,7 @@ check_call (funct_state local, gimple call, bool ipa)\n      those bits. */\n   else if (!ipa || !callee_t)\n     {\n-      if (possibly_throws && flag_non_call_exceptions)\n+      if (possibly_throws && cfun->can_throw_non_call_exceptions)\n         {\n \t  if (dump_file)\n \t    fprintf (dump_file, \"    can throw; looping\\n\");\n@@ -503,7 +503,7 @@ check_stmt (gimple_stmt_iterator *gsip, funct_state local, bool ipa)\n   if (gimple_code (stmt) != GIMPLE_CALL\n       && stmt_could_throw_p (stmt))\n     {\n-      if (flag_non_call_exceptions)\n+      if (cfun->can_throw_non_call_exceptions)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"    can throw; looping\");"}, {"sha": "160328ccefcc1e995ac90c19600ac6f90994db28", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -1212,7 +1212,7 @@ decompose_multiword_subregs (void)\n \t\t\t basic block and still produce the correct control\n \t\t\t flow graph for it.  */\n \t\t      gcc_assert (!cfi\n-\t\t\t\t  || (flag_non_call_exceptions\n+\t\t\t\t  || (cfun->can_throw_non_call_exceptions\n \t\t\t\t      && can_throw_internal (insn)));\n \n \t\t      insn = resolve_simple_move (set, insn);"}, {"sha": "2be1a40e5ae705c0830a4cc1cc4c3a08b58a1a97", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -1309,6 +1309,7 @@ input_function (tree fn_decl, struct data_in *data_in,\n   fn->after_tree_profile = bp_unpack_value (bp, 1);\n   fn->returns_pcc_struct = bp_unpack_value (bp, 1);\n   fn->returns_struct = bp_unpack_value (bp, 1);\n+  fn->can_throw_non_call_exceptions = bp_unpack_value (bp, 1);\n   fn->always_inline_functions_inlined = bp_unpack_value (bp, 1);\n   fn->after_inlining = bp_unpack_value (bp, 1);\n   fn->dont_save_pending_sizes_p = bp_unpack_value (bp, 1);"}, {"sha": "b7b1bddfb5ee78179330e22deba84c709ebd8c41", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -1877,6 +1877,7 @@ output_function (struct cgraph_node *node)\n   bp_pack_value (bp, fn->after_tree_profile, 1);\n   bp_pack_value (bp, fn->returns_pcc_struct, 1);\n   bp_pack_value (bp, fn->returns_struct, 1);\n+  bp_pack_value (bp, fn->can_throw_non_call_exceptions, 1);\n   bp_pack_value (bp, fn->always_inline_functions_inlined, 1);\n   bp_pack_value (bp, fn->after_inlining, 1);\n   bp_pack_value (bp, fn->dont_save_pending_sizes_p, 1);"}, {"sha": "a81d2e660ddd2299488b25f2a31b9e2b68cbc688", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -3880,7 +3880,7 @@ emit_libcall_block (rtx insns, rtx target, rtx result, rtx equiv)\n   /* If we're using non-call exceptions, a libcall corresponding to an\n      operation that may trap may also trap.  */\n   /* ??? See the comment in front of make_reg_eh_region_note.  */\n-  if (flag_non_call_exceptions && may_trap_p (equiv))\n+  if (cfun->can_throw_non_call_exceptions && may_trap_p (equiv))\n     {\n       for (insn = insns; insn; insn = NEXT_INSN (insn))\n \tif (CALL_P (insn))\n@@ -4126,7 +4126,7 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n \n   /* Don't allow operands to the compare to trap, as that can put the\n      compare and branch in different basic blocks.  */\n-  if (flag_non_call_exceptions)\n+  if (cfun->can_throw_non_call_exceptions)\n     {\n       if (may_trap_p (x))\n \tx = force_reg (mode, x);"}, {"sha": "77897aadf43c43d205de9cdbaa001e18c9fefe32", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -1200,7 +1200,7 @@ eliminate_partially_redundant_loads (void)\n \t\t  /* Are the operands unchanged since the start of the\n \t\t     block?  */\n \t\t  && oprs_unchanged_p (src, insn, false)\n-\t\t  && !(flag_non_call_exceptions && may_trap_p (src))\n+\t\t  && !(cfun->can_throw_non_call_exceptions && may_trap_p (src))\n \t\t  && !side_effects_p (src)\n \t\t  /* Is the expression recorded?  */\n \t\t  && (expr = lookup_expr_in_table (src)) != NULL)"}, {"sha": "a03cdfacee3b39dc73f5a1084531d476043c07a0", "filename": "gcc/postreload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -1590,7 +1590,7 @@ rest_of_handle_postreload (void)\n   reload_cse_regs (get_insns ());\n   /* Reload_cse_regs can eliminate potentially-trapping MEMs.\n      Remove any EH edges associated with them.  */\n-  if (flag_non_call_exceptions)\n+  if (cfun->can_throw_non_call_exceptions)\n     purge_all_dead_edges ();\n \n   return 0;"}, {"sha": "85880f8210c0700073d3839adb649df73ff2e099", "filename": "gcc/reload1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -4299,7 +4299,7 @@ reload_as_needed (int live_known)\n \t      subst_reloads (insn);\n \n \t      /* Adjust the exception region notes for loads and stores.  */\n-\t      if (flag_non_call_exceptions && !CALL_P (insn))\n+\t      if (cfun->can_throw_non_call_exceptions && !CALL_P (insn))\n \t\tfixup_eh_region_note (insn, prev, next);\n \n \t      /* If this was an ASM, make sure that all the reload insns\n@@ -7331,7 +7331,7 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t\t  rl->when_needed);\n     }\n \n-  if (flag_non_call_exceptions)\n+  if (cfun->can_throw_non_call_exceptions)\n     copy_reg_eh_region_note_forward (insn, get_insns (), NULL);\n \n   /* End this sequence.  */\n@@ -7551,7 +7551,7 @@ emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n   else\n     output_reload_insns[rl->opnum] = get_insns ();\n \n-  if (flag_non_call_exceptions)\n+  if (cfun->can_throw_non_call_exceptions)\n     copy_reg_eh_region_note_forward (insn, get_insns (), NULL);\n \n   end_sequence ();\n@@ -9019,7 +9019,7 @@ fixup_abnormal_edges (void)\n     }\n \n   /* We've possibly turned single trapping insn into multiple ones.  */\n-  if (flag_non_call_exceptions)\n+  if (cfun->can_throw_non_call_exceptions)\n     {\n       sbitmap blocks;\n       blocks = sbitmap_alloc (last_basic_block);"}, {"sha": "908eb570db86f4808c1ae756986aa2d328b4cdab", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -2865,7 +2865,7 @@ init_global_and_expr_for_insn (insn_t insn)\n \t|| SCHED_GROUP_P (insn)\n \t|| prologue_epilogue_contains (insn)\n \t/* Exception handling insns are always unique.  */\n-\t|| (flag_non_call_exceptions && can_throw_internal (insn))\n+\t|| (cfun->can_throw_non_call_exceptions && can_throw_internal (insn))\n \t/* TRAP_IF though have an INSN code is control_flow_insn_p ().  */\n \t|| control_flow_insn_p (insn))\n       force_unique_p = true;"}, {"sha": "61d0cba815950daf851a6ff3169a76f529406835", "filename": "gcc/store-motion.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -560,9 +560,9 @@ find_moveable_store (rtx insn, int *regs_set_before, int *regs_set_after)\n     return;\n \n   /* If we are handling exceptions, we must be careful with memory references\n-     that may trap. If we are not, the behavior is undefined, so we may just\n+     that may trap.  If we are not, the behavior is undefined, so we may just\n      continue.  */\n-  if (flag_non_call_exceptions && may_trap_p (dest))\n+  if (cfun->can_throw_non_call_exceptions && may_trap_p (dest))\n     return;\n \n   /* Even if the destination cannot trap, the source may.  In this case we'd"}, {"sha": "77c8cac7b5cd50313e6b7855467b4df1b9c4b9b8", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -2526,12 +2526,12 @@ stmt_could_throw_p (gimple stmt)\n \n     case GIMPLE_ASSIGN:\n     case GIMPLE_COND:\n-      if (!flag_non_call_exceptions)\n+      if (!cfun->can_throw_non_call_exceptions)\n         return false;\n       return stmt_could_throw_1_p (stmt);\n \n     case GIMPLE_ASM:\n-      if (!flag_non_call_exceptions)\n+      if (!cfun->can_throw_non_call_exceptions)\n         return false;\n       return gimple_asm_volatile_p (stmt);\n \n@@ -2550,7 +2550,7 @@ tree_could_throw_p (tree t)\n     return false;\n   if (TREE_CODE (t) == MODIFY_EXPR)\n     {\n-      if (flag_non_call_exceptions\n+      if (cfun->can_throw_non_call_exceptions\n           && tree_could_trap_p (TREE_OPERAND (t, 0)))\n         return true;\n       t = TREE_OPERAND (t, 1);\n@@ -2560,7 +2560,7 @@ tree_could_throw_p (tree t)\n     t = TREE_OPERAND (t, 0);\n   if (TREE_CODE (t) == CALL_EXPR)\n     return (call_expr_flags (t) & ECF_NOTHROW) == 0;\n-  if (flag_non_call_exceptions)\n+  if (cfun->can_throw_non_call_exceptions)\n     return tree_could_trap_p (t);\n   return false;\n }"}, {"sha": "697c6bc269a554c59720b687e6e7351c3438d9a9", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -2028,6 +2028,8 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count)\n   cfun->stdarg = src_cfun->stdarg;\n   cfun->dont_save_pending_sizes_p = src_cfun->dont_save_pending_sizes_p;\n   cfun->after_inlining = src_cfun->after_inlining;\n+  cfun->can_throw_non_call_exceptions\n+    = src_cfun->can_throw_non_call_exceptions;\n   cfun->returns_struct = src_cfun->returns_struct;\n   cfun->returns_pcc_struct = src_cfun->returns_pcc_struct;\n   cfun->after_tree_profile = src_cfun->after_tree_profile;\n@@ -2960,6 +2962,29 @@ inline_forbidden_p (tree fndecl)\n   return forbidden_p;\n }\n \n+/* Return true if CALLEE cannot be inlined into CALLER.  */\n+\n+static bool\n+inline_forbidden_into_p (tree caller, tree callee)\n+{\n+  /* Don't inline if the functions have different EH personalities.  */\n+  if (DECL_FUNCTION_PERSONALITY (caller)\n+      && DECL_FUNCTION_PERSONALITY (callee)\n+      && (DECL_FUNCTION_PERSONALITY (caller)\n+\t  != DECL_FUNCTION_PERSONALITY (callee)))\n+    return true;\n+\n+  /* Don't inline if the callee can throw non-call exceptions but the\n+     caller cannot.  */\n+  if (DECL_STRUCT_FUNCTION (callee)\n+      && DECL_STRUCT_FUNCTION (callee)->can_throw_non_call_exceptions\n+      && !(DECL_STRUCT_FUNCTION (caller)\n+\t   && DECL_STRUCT_FUNCTION (caller)->can_throw_non_call_exceptions))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Returns nonzero if FN is a function that does not have any\n    fundamental inline blocking properties.  */\n \n@@ -3622,15 +3647,11 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n \n   cg_edge = cgraph_edge (id->dst_node, stmt);\n \n-  /* Don't inline functions with different EH personalities.  */\n-  if (DECL_FUNCTION_PERSONALITY (cg_edge->caller->decl)\n-      && DECL_FUNCTION_PERSONALITY (cg_edge->callee->decl)\n-      && (DECL_FUNCTION_PERSONALITY (cg_edge->caller->decl)\n-\t  != DECL_FUNCTION_PERSONALITY (cg_edge->callee->decl)))\n+  /* First check that inlining isn't simply forbidden in this case.  */\n+  if (inline_forbidden_into_p (cg_edge->caller->decl, cg_edge->callee->decl))\n     goto egress;\n \n-  /* Don't try to inline functions that are not well-suited to\n-     inlining.  */\n+  /* Don't try to inline functions that are not well-suited to inlining.  */\n   if (!cgraph_inline_p (cg_edge, &reason))\n     {\n       /* If this call was originally indirect, we do not want to emit any\n@@ -5180,12 +5201,8 @@ tree_can_inline_p (struct cgraph_edge *e)\n   caller = e->caller->decl;\n   callee = e->callee->decl;\n \n-  /* We cannot inline a function that uses a different EH personality\n-     than the caller.  */\n-  if (DECL_FUNCTION_PERSONALITY (caller)\n-      && DECL_FUNCTION_PERSONALITY (callee)\n-      && (DECL_FUNCTION_PERSONALITY (caller)\n-\t  != DECL_FUNCTION_PERSONALITY (callee)))\n+  /* First check that inlining isn't simply forbidden in this case.  */\n+  if (inline_forbidden_into_p (caller, callee))\n     {\n       e->inline_failed = CIF_UNSPECIFIED;\n       gimple_call_set_cannot_inline (e->call_stmt, true);"}, {"sha": "59ccc408e9cfa13fecc39e260f8c4019282a24f5", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4f502fa905d9c6392fab52e91ee91951f92677/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=8f4f502fa905d9c6392fab52e91ee91951f92677", "patch": "@@ -272,10 +272,10 @@ static void\n mark_stmt_if_obviously_necessary (gimple stmt, bool aggressive)\n {\n   tree lhs = NULL_TREE;\n+\n   /* With non-call exceptions, we have to assume that all statements could\n      throw.  If a statement may throw, it is inherently necessary.  */\n-  if (flag_non_call_exceptions\n-      && stmt_could_throw_p (stmt))\n+  if (cfun->can_throw_non_call_exceptions && stmt_could_throw_p (stmt))\n     {\n       mark_stmt_necessary (stmt, true);\n       return;"}]}