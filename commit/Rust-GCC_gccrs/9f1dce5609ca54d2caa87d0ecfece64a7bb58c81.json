{"sha": "9f1dce5609ca54d2caa87d0ecfece64a7bb58c81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWYxZGNlNTYwOWNhNTRkMmNhYTg3ZDBlY2ZlY2U2NGE3YmI1OGM4MQ==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "coudert@clipper.ens.fr", "date": "2006-11-16T12:25:11Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2006-11-16T12:25:11Z"}, "message": "re PR fortran/29391 ([4.2/4.1 only] LBOUND and UBOUND are broken)\n\n\tPR fortran/29391\n\tPR fortran/29489\n\n\t* simplify.c (simplify_bound): Fix the simplification of\n\tLBOUND/UBOUND intrinsics.\n\t* trans-intrinsic.c (simplify_bound): Fix the logic, and\n\tremove an erroneous assert.\n\n\t* gcc/testsuite/gfortran.dg/bound_2.f90: Add more checks.\n\t* gcc/testsuite/gfortran.dg/bound_3.f90: New test.\n\nFrom-SVN: r118888", "tree": {"sha": "f14cc63483c17ad4c8e486eae4a98c3d88d24e41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f14cc63483c17ad4c8e486eae4a98c3d88d24e41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f1dce5609ca54d2caa87d0ecfece64a7bb58c81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f1dce5609ca54d2caa87d0ecfece64a7bb58c81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f1dce5609ca54d2caa87d0ecfece64a7bb58c81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f1dce5609ca54d2caa87d0ecfece64a7bb58c81/comments", "author": null, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c0e51c4fad90d1a93040fe92695890b5715d6f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c0e51c4fad90d1a93040fe92695890b5715d6f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c0e51c4fad90d1a93040fe92695890b5715d6f5"}], "stats": {"total": 239, "additions": 220, "deletions": 19}, "files": [{"sha": "c26bf0b9cc440fbd4a8b1a773504792584863f69", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f1dce5609ca54d2caa87d0ecfece64a7bb58c81/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f1dce5609ca54d2caa87d0ecfece64a7bb58c81/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=9f1dce5609ca54d2caa87d0ecfece64a7bb58c81", "patch": "@@ -1,3 +1,12 @@\n+2006-11-16  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\tPR fortran/29391\n+\tPR fortran/29489\n+\t* simplify.c (simplify_bound): Fix the simplification of\n+\tLBOUND/UBOUND intrinsics.\n+\t* trans-intrinsic.c (simplify_bound): Fix the logic, and\n+\tremove an erroneous assert.\n+\n 2006-11-16  Francois-Xavier Coudert  <fxcoudert@gcc.gnu,org>\n \n \t* trans-decl.c (gfc_get_symbol_decl): Fix formatting."}, {"sha": "8ecabf0379362d7aead600de3dffb7e53b961705", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f1dce5609ca54d2caa87d0ecfece64a7bb58c81/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f1dce5609ca54d2caa87d0ecfece64a7bb58c81/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=9f1dce5609ca54d2caa87d0ecfece64a7bb58c81", "patch": "@@ -1913,19 +1913,19 @@ simplify_bound (gfc_expr * array, gfc_expr * dim, int upper)\n {\n   gfc_ref *ref;\n   gfc_array_spec *as;\n-  gfc_expr *e;\n+  gfc_expr *l, *u, *result;\n   int d;\n \n-  if (array->expr_type != EXPR_VARIABLE)\n-    return NULL;\n-\n   if (dim == NULL)\n     /* TODO: Simplify constant multi-dimensional bounds.  */\n     return NULL;\n \n   if (dim->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n+  if (array->expr_type != EXPR_VARIABLE)\n+    return NULL;\n+\n   /* Follow any component references.  */\n   as = array->symtree->n.sym->as;\n   for (ref = array->ref; ref; ref = ref->next)\n@@ -1975,12 +1975,43 @@ simplify_bound (gfc_expr * array, gfc_expr * dim, int upper)\n       return &gfc_bad_expr;\n     }\n \n-  e = upper ? as->upper[d-1] : as->lower[d-1];\n+  /* The last dimension of an assumed-size array is special.  */\n+  if (d == as->rank && as->type == AS_ASSUMED_SIZE && !upper)\n+    {\n+      if (as->lower[d-1]->expr_type == EXPR_CONSTANT)\n+\treturn gfc_copy_expr (as->lower[d-1]);\n+      else\n+\treturn NULL;\n+    }\n \n-  if (e->expr_type != EXPR_CONSTANT)\n+  /* Then, we need to know the extent of the given dimension.  */\n+  l = as->lower[d-1];\n+  u = as->upper[d-1];\n+\n+  if (l->expr_type != EXPR_CONSTANT || u->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  return gfc_copy_expr (e);\n+  result = gfc_constant_result (BT_INTEGER, gfc_default_integer_kind,\n+\t\t\t\t&array->where);\n+\n+  if (mpz_cmp (l->value.integer, u->value.integer) > 0)\n+    {\n+      /* Zero extent.  */\n+      if (upper)\n+\tmpz_set_si (result->value.integer, 0);\n+      else\n+\tmpz_set_si (result->value.integer, 1);\n+    }\n+  else\n+    {\n+      /* Nonzero extent.  */\n+      if (upper)\n+\tmpz_set (result->value.integer, u->value.integer);\n+      else\n+\tmpz_set (result->value.integer, l->value.integer);\n+    }\n+\n+  return range_check (result, upper ? \"UBOUND\" : \"LBOUND\");\n }\n \n "}, {"sha": "5facd5b7a1571e9093b97c382f897e9d47fb222e", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f1dce5609ca54d2caa87d0ecfece64a7bb58c81/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f1dce5609ca54d2caa87d0ecfece64a7bb58c81/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=9f1dce5609ca54d2caa87d0ecfece64a7bb58c81", "patch": "@@ -712,14 +712,13 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n   tree type;\n   tree bound;\n   tree tmp;\n-  tree cond, cond1, cond2, cond3, size;\n+  tree cond, cond1, cond2, cond3, cond4, size;\n   tree ubound;\n   tree lbound;\n   gfc_se argse;\n   gfc_ss *ss;\n   gfc_array_spec * as;\n   gfc_ref *ref;\n-  int i;\n \n   arg = expr->value.function.actual;\n   arg2 = arg->next;\n@@ -761,9 +760,14 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n \n   if (INTEGER_CST_P (bound))\n     {\n-      gcc_assert (TREE_INT_CST_HIGH (bound) == 0);\n-      i = TREE_INT_CST_LOW (bound);\n-      gcc_assert (i >= 0 && i < GFC_TYPE_ARRAY_RANK (TREE_TYPE (desc)));\n+      int hi, low;\n+\n+      hi = TREE_INT_CST_HIGH (bound);\n+      low = TREE_INT_CST_LOW (bound);\n+      if (hi || low < 0 || low >= GFC_TYPE_ARRAY_RANK (TREE_TYPE (desc)))\n+\tgfc_error (\"'dim' argument of %s intrinsic at %L is not a valid \"\n+\t\t   \"dimension index\", upper ? \"UBOUND\" : \"LBOUND\",\n+\t\t   &expr->where);\n     }\n   else\n     {\n@@ -842,15 +846,21 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n   if (as)\n     {\n       tree stride = gfc_conv_descriptor_stride (desc, bound);\n+\n       cond1 = fold_build2 (GE_EXPR, boolean_type_node, ubound, lbound);\n       cond2 = fold_build2 (LE_EXPR, boolean_type_node, ubound, lbound);\n-      cond3 = fold_build2 (GT_EXPR, boolean_type_node, stride,\n+\n+      cond3 = fold_build2 (GE_EXPR, boolean_type_node, stride,\n \t\t\t   gfc_index_zero_node);\n+      cond3 = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, cond3, cond1);\n+\n+      cond4 = fold_build2 (LT_EXPR, boolean_type_node, stride,\n+\t\t\t   gfc_index_zero_node);\n+      cond4 = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, cond4, cond2);\n \n       if (upper)\n \t{\n-\t  cond = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, cond3, cond1);\n-\t  cond = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, cond, cond2);\n+\t  cond = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, cond3, cond4);\n \n \t  se->expr = fold_build3 (COND_EXPR, gfc_array_index_type, cond,\n \t\t\t\t  ubound, gfc_index_zero_node);\n@@ -860,13 +870,11 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n \t  if (as->type == AS_ASSUMED_SIZE)\n \t    cond = fold_build2 (EQ_EXPR, boolean_type_node, bound,\n \t\t\t\tbuild_int_cst (TREE_TYPE (bound),\n-\t\t\t\t\t       arg->expr->rank));\n+\t\t\t\t\t       arg->expr->rank - 1));\n \t  else\n \t    cond = boolean_false_node;\n \n-\t  cond1 = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, cond3, cond1);\n-\t  cond1 = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, cond1, cond2);\n-\n+\t  cond1 = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, cond3, cond4);\n \t  cond = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, cond, cond1);\n \n \t  se->expr = fold_build3 (COND_EXPR, gfc_array_index_type, cond,"}, {"sha": "efbbfe45afa96883d265fb47be45c60f552faa75", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f1dce5609ca54d2caa87d0ecfece64a7bb58c81/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f1dce5609ca54d2caa87d0ecfece64a7bb58c81/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9f1dce5609ca54d2caa87d0ecfece64a7bb58c81", "patch": "@@ -1,3 +1,10 @@\n+2006-11-16  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\tPR fortran/29391\n+\tPR fortran/29489\n+\t* gcc/testsuite/gfortran.dg/bound_2.f90: Add more checks.\n+\t* gcc/testsuite/gfortran.dg/bound_3.f90: New test.\n+\n 2006-11-16  Maxim Kuvyrkov  <mkuvyrkov@ispras.ru>\n \n \tPR target/29201"}, {"sha": "2fa0c4bb77e18fcbcd9a2f1c97a70b02abf09dc8", "filename": "gcc/testsuite/gfortran.dg/bound_2.f90", "status": "modified", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f1dce5609ca54d2caa87d0ecfece64a7bb58c81/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f1dce5609ca54d2caa87d0ecfece64a7bb58c81/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_2.f90?ref=9f1dce5609ca54d2caa87d0ecfece64a7bb58c81", "patch": "@@ -6,46 +6,146 @@\n   implicit none\n   integer :: i(-1:1,-1:1) = 0\n   integer :: j(-1:2) = 0\n+  integer :: u(7,4,2,9)\n+\n+  call foo(u,4)\n+  call jackal(-1,-8)\n+  call jackal(-1,8)\n \n   if (any(lbound(i(-1:1,-1:1)) /= 1)) call abort\n+  if (lbound(i(-1:1,-1:1), 1) /= 1) call abort\n+  if (lbound(i(-1:1,-1:1), 2) /= 1) call abort\n+\n   if (any(ubound(i(-1:1,-1:1)) /= 3)) call abort\n+  if (ubound(i(-1:1,-1:1), 1) /= 3) call abort\n+  if (ubound(i(-1:1,-1:1), 2) /= 3) call abort\n+\n   if (any(lbound(i(:,:)) /= 1)) call abort\n+  if (lbound(i(:,:), 1) /= 1) call abort\n+  if (lbound(i(:,:), 2) /= 1) call abort\n+\n   if (any(ubound(i(:,:)) /= 3)) call abort\n+  if (ubound(i(:,:), 1) /= 3) call abort\n+  if (ubound(i(:,:), 2) /= 3) call abort\n+\n   if (any(lbound(i(0:,-1:)) /= 1)) call abort\n+  if (lbound(i(0:,-1:), 1) /= 1) call abort\n+  if (lbound(i(0:,-1:), 2) /= 1) call abort\n+\n   if (any(ubound(i(0:,-1:)) /= [2,3])) call abort\n+  if (ubound(i(0:,-1:), 1) /= 2) call abort\n+  if (ubound(i(0:,-1:), 2) /= 3) call abort\n+\n   if (any(lbound(i(:0,:0)) /= 1)) call abort\n+  if (lbound(i(:0,:0), 1) /= 1) call abort\n+  if (lbound(i(:0,:0), 2) /= 1) call abort\n+\n   if (any(ubound(i(:0,:0)) /= 2)) call abort\n+  if (ubound(i(:0,:0), 1) /= 2) call abort\n+  if (ubound(i(:0,:0), 2) /= 2) call abort\n \n   if (any(lbound(transpose(i)) /= 1)) call abort\n+  if (lbound(transpose(i), 1) /= 1) call abort\n+  if (lbound(transpose(i), 2) /= 1) call abort\n+\n   if (any(ubound(transpose(i)) /= 3)) call abort\n+  if (ubound(transpose(i), 1) /= 3) call abort\n+  if (ubound(transpose(i), 2) /= 3) call abort\n+\n   if (any(lbound(reshape(i,[2,2])) /= 1)) call abort\n+  if (lbound(reshape(i,[2,2]), 1) /= 1) call abort\n+  if (lbound(reshape(i,[2,2]), 2) /= 1) call abort\n+\n   if (any(ubound(reshape(i,[2,2])) /= 2)) call abort\n+  if (ubound(reshape(i,[2,2]), 1) /= 2) call abort\n+  if (ubound(reshape(i,[2,2]), 2) /= 2) call abort\n+\n   if (any(lbound(cshift(i,-1)) /= 1)) call abort\n+  if (lbound(cshift(i,-1), 1) /= 1) call abort\n+  if (lbound(cshift(i,-1), 2) /= 1) call abort\n+\n   if (any(ubound(cshift(i,-1)) /= 3)) call abort\n+  if (ubound(cshift(i,-1), 1) /= 3) call abort\n+  if (ubound(cshift(i,-1), 2) /= 3) call abort\n+\n   if (any(lbound(eoshift(i,-1)) /= 1)) call abort\n+  if (lbound(eoshift(i,-1), 1) /= 1) call abort\n+  if (lbound(eoshift(i,-1), 2) /= 1) call abort\n+\n   if (any(ubound(eoshift(i,-1)) /= 3)) call abort\n+  if (ubound(eoshift(i,-1), 1) /= 3) call abort\n+  if (ubound(eoshift(i,-1), 2) /= 3) call abort\n+\n   if (any(lbound(spread(i,1,2)) /= 1)) call abort\n+  if (lbound(spread(i,1,2), 1) /= 1) call abort\n+  if (lbound(spread(i,1,2), 2) /= 1) call abort\n+\n   if (any(ubound(spread(i,1,2)) /= [2,3,3])) call abort\n+  if (ubound(spread(i,1,2), 1) /= 2) call abort\n+  if (ubound(spread(i,1,2), 2) /= 3) call abort\n+  if (ubound(spread(i,1,2), 3) /= 3) call abort\n+\n   if (any(lbound(maxloc(i)) /= 1)) call abort\n+  if (lbound(maxloc(i), 1) /= 1) call abort\n+\n   if (any(ubound(maxloc(i)) /= 2)) call abort\n+  if (ubound(maxloc(i), 1) /= 2) call abort\n+\n   if (any(lbound(minloc(i)) /= 1)) call abort\n+  if (lbound(minloc(i), 1) /= 1) call abort\n+\n   if (any(ubound(minloc(i)) /= 2)) call abort\n+  if (ubound(minloc(i), 1) /= 2) call abort\n+\n   if (any(lbound(maxval(i,2)) /= 1)) call abort\n+  if (lbound(maxval(i,2), 1) /= 1) call abort\n+\n   if (any(ubound(maxval(i,2)) /= 3)) call abort\n+  if (ubound(maxval(i,2), 1) /= 3) call abort\n+\n   if (any(lbound(minval(i,2)) /= 1)) call abort\n+  if (lbound(minval(i,2), 1) /= 1) call abort\n+\n   if (any(ubound(minval(i,2)) /= 3)) call abort\n+  if (ubound(minval(i,2), 1) /= 3) call abort\n+\n   if (any(lbound(any(i==1,2)) /= 1)) call abort\n+  if (lbound(any(i==1,2), 1) /= 1) call abort\n+\n   if (any(ubound(any(i==1,2)) /= 3)) call abort\n+  if (ubound(any(i==1,2), 1) /= 3) call abort\n+\n   if (any(lbound(count(i==1,2)) /= 1)) call abort\n+  if (lbound(count(i==1,2), 1) /= 1) call abort\n+\n   if (any(ubound(count(i==1,2)) /= 3)) call abort\n+  if (ubound(count(i==1,2), 1) /= 3) call abort\n+\n   if (any(lbound(merge(i,i,.true.)) /= 1)) call abort\n+  if (lbound(merge(i,i,.true.), 1) /= 1) call abort\n+  if (lbound(merge(i,i,.true.), 2) /= 1) call abort\n+\n   if (any(ubound(merge(i,i,.true.)) /= 3)) call abort\n+  if (ubound(merge(i,i,.true.), 1) /= 3) call abort\n+  if (ubound(merge(i,i,.true.), 2) /= 3) call abort\n+\n   if (any(lbound(lbound(i)) /= 1)) call abort\n+  if (lbound(lbound(i), 1) /= 1) call abort\n+\n   if (any(ubound(lbound(i)) /= 2)) call abort\n+  if (ubound(lbound(i), 1) /= 2) call abort\n+\n   if (any(lbound(ubound(i)) /= 1)) call abort\n+  if (lbound(ubound(i), 1) /= 1) call abort\n+\n   if (any(ubound(ubound(i)) /= 2)) call abort\n+  if (ubound(ubound(i), 1) /= 2) call abort\n+\n   if (any(lbound(shape(i)) /= 1)) call abort\n+  if (lbound(shape(i), 1) /= 1) call abort\n+\n   if (any(ubound(shape(i)) /= 2)) call abort\n+  if (ubound(shape(i), 1) /= 2) call abort\n \n   if (any(lbound(product(i,2)) /= 1)) call abort\n   if (any(ubound(product(i,2)) /= 3)) call abort\n@@ -60,13 +160,59 @@\n \n   call sub1(i,3)\n   call sub1(reshape([7,9,4,6,7,9],[3,2]),3)\n+  call sub2\n \n contains\n \n   subroutine sub1(a,n)\n     integer :: a(2:n+1,4:*), n\n+\n     if (any([lbound(a,1), lbound(a,2)] /= [2, 4])) call abort\n     if (any(lbound(a) /= [2, 4])) call abort\n   end subroutine sub1\n \n+  subroutine sub2\n+    integer :: x(3:2, 1:2)\n+\n+    if (size(x) /= 0) call abort\n+    if (lbound (x, 1) /= 1 .or. lbound(x, 2) /= 1) call abort\n+    if (any (lbound (x) /= [1, 1])) call abort\n+    if (ubound (x, 1) /= 0 .or. ubound(x, 2) /= 2) call abort\n+    if (any (ubound (x) /= [0, 2])) call abort\n+  end subroutine sub2\n+\n+  subroutine sub3\n+    integer :: x(4:5, 1:2)\n+\n+    if (size(x) /= 0) call abort\n+    if (lbound (x, 1) /= 4 .or. lbound(x, 2) /= 1) call abort\n+    if (any (lbound (x) /= [4, 1])) call abort\n+    if (ubound (x, 1) /= 4 .or. ubound(x, 2) /= 2) call abort\n+    if (any (ubound (x) /= [4, 2])) call abort\n+  end subroutine sub3\n+\n+  subroutine foo (x,n)\n+    integer :: x(7,n,2,*), n\n+\n+    !if (ubound(x,1) /= 7 .or. ubound(x,2) /= 4 .or. ubound(x,3) /= 2) call abort\n+  end subroutine foo\n+\n+  subroutine jackal (b, c)\n+    integer :: b, c\n+    integer :: soda(b:c, 3:4)\n+\n+    if (b > c) then\n+      if (size(soda) /= 0) call abort\n+      if (lbound (soda, 1) /= 1 .or. ubound (soda, 1) /= 0) call abort\n+    else\n+      if (size(soda) /= 2*(c-b+1)) call abort\n+      if (lbound (soda, 1) /= b .or. ubound (soda, 1) /= c) call abort\n+    end if\n+\n+    if (lbound (soda, 2) /= 3 .or. ubound (soda, 2) /= 4) call abort\n+    if (any (lbound (soda) /= [lbound(soda,1), lbound(soda,2)])) call abort\n+    if (any (ubound (soda) /= [ubound(soda,1), ubound(soda,2)])) call abort\n+\n+  end subroutine jackal\n+\n end"}]}