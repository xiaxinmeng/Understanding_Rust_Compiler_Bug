{"sha": "71925bc04f24a40ab8ac587e08609cf91299e293", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE5MjViYzA0ZjI0YTQwYWI4YWM1ODdlMDg2MDljZjkxMjk5ZTI5Mw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2002-03-07T11:37:16Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2002-03-07T11:37:16Z"}, "message": "defaults.h (MODE_HAS_NANS, [...]): New.\n\n\t* defaults.h (MODE_HAS_NANS, MODE_HAS_INFINITIES): New.\n\t(MODE_HAS_SIGNED_ZEROS, MODE_HAS_SIGN_DEPENDENT_ROUNDING): New.\n\t* flags.h (HONOR_NANS, HONOR_INFINITIES, HONOR_SIGNED_ZEROS): New.\n\t(HONOR_SIGN_DEPENDENT_ROUNDING): New.\n\t* builtins.c (expand_builtin_mathfn): Use HONOR_NANS.\n\t* c-common.c (truthvalue_conversion): Reduce x - y != 0 to x != y\n\tunless x and y could be infinite.\n\t(expand_unordered_cmp): New, mostly split from expand_tree_builtin.\n\tCheck that the common type of both arguments is a real, even for\n\ttargets without unordered comparisons.  Allow an integer argument\n\tto be compared against a real.\n\t(expand_tree_builtin): Use expand_unordered_cmp.\n\t* combine.c (combine_simplify_rtx): Use the new HONOR_... macros.\n\t* cse.c (fold_rtx): Likewise.  Fix indentation.\n\t* fold-const.c (fold_real_zero_addition_p): New.\n\t(fold): Use it, and the new HONOR_... macros.\n\t* ifcvt.c (noce_try_minmax): Use the new HONOR_... macros.\n\t* jump.c (reversed_comparison_code_parts): After searching for\n\tthe true comparison mode, use HONOR_NANS to decide whether it\n\tcan be safely reversed.\n\t(reverse_condition_maybe_unordered): Remove IEEE check.\n\t* simplify-rtx.c (simplify_binary_operation): Use the new macros\n\tto decide which simplifications are valid.  Allow the following\n\tsimplifications for IEEE: (-a + b) to (b - a), (a + -b) to (a - b),\n\tand (a - -b) to (a + b).\n\t(simplify_relational_operation): Use HONOR_NANS.\n\t* doc/tm.texi: Document the MODE_HAS_... macros.\n\nFrom-SVN: r50401", "tree": {"sha": "74f74ccd7ea753279bc20a10577c6a90a6a4ba38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74f74ccd7ea753279bc20a10577c6a90a6a4ba38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71925bc04f24a40ab8ac587e08609cf91299e293", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71925bc04f24a40ab8ac587e08609cf91299e293", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71925bc04f24a40ab8ac587e08609cf91299e293", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71925bc04f24a40ab8ac587e08609cf91299e293/comments", "author": null, "committer": null, "parents": [{"sha": "145d3bf292a6cfc66a6396285003765db9424a8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/145d3bf292a6cfc66a6396285003765db9424a8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/145d3bf292a6cfc66a6396285003765db9424a8f"}], "stats": {"total": 595, "additions": 408, "deletions": 187}, "files": [{"sha": "2940fceffa308f5abe142d5644cc3a1f5864c4cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=71925bc04f24a40ab8ac587e08609cf91299e293", "patch": "@@ -1,3 +1,33 @@\n+2002-03-07  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* defaults.h (MODE_HAS_NANS, MODE_HAS_INFINITIES): New.\n+\t(MODE_HAS_SIGNED_ZEROS, MODE_HAS_SIGN_DEPENDENT_ROUNDING): New.\n+\t* flags.h (HONOR_NANS, HONOR_INFINITIES, HONOR_SIGNED_ZEROS): New.\n+\t(HONOR_SIGN_DEPENDENT_ROUNDING): New.\n+\t* builtins.c (expand_builtin_mathfn): Use HONOR_NANS.\n+\t* c-common.c (truthvalue_conversion): Reduce x - y != 0 to x != y\n+\tunless x and y could be infinite.\n+\t(expand_unordered_cmp): New, mostly split from expand_tree_builtin.\n+\tCheck that the common type of both arguments is a real, even for\n+\ttargets without unordered comparisons.  Allow an integer argument\n+\tto be compared against a real.\n+\t(expand_tree_builtin): Use expand_unordered_cmp.\n+\t* combine.c (combine_simplify_rtx): Use the new HONOR_... macros.\n+\t* cse.c (fold_rtx): Likewise.  Fix indentation.\n+\t* fold-const.c (fold_real_zero_addition_p): New.\n+\t(fold): Use it, and the new HONOR_... macros.\n+\t* ifcvt.c (noce_try_minmax): Use the new HONOR_... macros.\n+\t* jump.c (reversed_comparison_code_parts): After searching for\n+\tthe true comparison mode, use HONOR_NANS to decide whether it\n+\tcan be safely reversed.\n+\t(reverse_condition_maybe_unordered): Remove IEEE check.\n+\t* simplify-rtx.c (simplify_binary_operation): Use the new macros\n+\tto decide which simplifications are valid.  Allow the following\n+\tsimplifications for IEEE: (-a + b) to (b - a), (a + -b) to (a - b),\n+\tand (a - -b) to (a + b).\n+\t(simplify_relational_operation): Use HONOR_NANS.\n+\t* doc/tm.texi: Document the MODE_HAS_... macros.\n+\n 2002-03-07  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* combine.c (simplify_comparison): If simplifying a logical shift"}, {"sha": "c4aebd3a801ab1950dad6087cc4b1f93e6fdba92", "filename": "gcc/builtins.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=71925bc04f24a40ab8ac587e08609cf91299e293", "patch": "@@ -1470,6 +1470,7 @@ expand_builtin_mathfn (exp, target, subtarget)\n   rtx op0, insns;\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   tree arglist = TREE_OPERAND (exp, 1);\n+  enum machine_mode argmode;\n \n   if (!validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n     return 0;\n@@ -1518,8 +1519,8 @@ expand_builtin_mathfn (exp, target, subtarget)\n \n   /* Compute into TARGET.\n      Set TARGET to wherever the result comes back.  */\n-  target = expand_unop (TYPE_MODE (TREE_TYPE (TREE_VALUE (arglist))),\n-\t\t\tbuiltin_optab, op0, target, 0);\n+  argmode = TYPE_MODE (TREE_TYPE (TREE_VALUE (arglist)));\n+  target = expand_unop (argmode, builtin_optab, op0, target, 0);\n \n   /* If we were unable to expand via the builtin, stop the\n      sequence (without outputting the insns) and return 0, causing\n@@ -1530,18 +1531,12 @@ expand_builtin_mathfn (exp, target, subtarget)\n       return 0;\n     }\n \n-  /* If errno must be maintained and if we are not allowing unsafe\n-     math optimizations, check the result.  */\n+  /* If errno must be maintained, we must set it to EDOM for NaN results.  */\n \n-  if (flag_errno_math && ! flag_unsafe_math_optimizations)\n+  if (flag_errno_math && HONOR_NANS (argmode))\n     {\n       rtx lab1;\n \n-      /* Don't define the builtin FP instructions\n-\t if your machine is not IEEE.  */\n-      if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT)\n-\tabort ();\n-\n       lab1 = gen_label_rtx ();\n \n       /* Test the result; if it is NaN, set errno=EDOM because"}, {"sha": "7fad4b304f228e76ac1b90b7160902e3164a745b", "filename": "gcc/c-common.c", "status": "modified", "additions": 90, "deletions": 62, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=71925bc04f24a40ab8ac587e08609cf91299e293", "patch": "@@ -2202,10 +2202,15 @@ truthvalue_conversion (expr)\n       break;\n \n     case MINUS_EXPR:\n-      /* With IEEE arithmetic, x - x may not equal 0, so we can't optimize\n-\t this case.  */\n-      if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-\t  && TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE)\n+      /* Perhaps reduce (x - y) != 0 to (x != y).  The expressions\n+\t aren't guaranteed to the be same for modes that can represent\n+\t infinity, since if x and y are both +infinity, or both\n+\t -infinity, then x - y is not a number.\n+\n+\t Note that this transformation is safe when x or y is NaN.\n+\t (x - y) is then NaN, and both (x - y) != 0 and x != y will\n+\t be false.  */\n+      if (HONOR_INFINITIES (TYPE_MODE (TREE_TYPE (TREE_OPERAND (expr, 0)))))\n \tbreak;\n       /* fall through...  */\n     case BIT_XOR_EXPR:\n@@ -3051,6 +3056,81 @@ strip_array_types (type)\n   return type;\n }\n \n+static tree expand_unordered_cmp PARAMS ((tree, tree, enum tree_code,\n+\t\t\t\t\t  enum tree_code));\n+\n+/* Expand a call to an unordered comparison function such as\n+   __builtin_isgreater().  FUNCTION is the function's declaration and\n+   PARAMS a list of the values passed.  For __builtin_isunordered(),\n+   UNORDERED_CODE is UNORDERED_EXPR and ORDERED_CODE is NOP_EXPR.  In\n+   other cases, UNORDERED_CODE and ORDERED_CODE are comparison codes\n+   that give the opposite of the desired result.  UNORDERED_CODE is\n+   used for modes that can hold NaNs and ORDERED_CODE is used for the\n+   rest.  */\n+\n+static tree\n+expand_unordered_cmp (function, params, unordered_code, ordered_code)\n+     tree function, params;\n+     enum tree_code unordered_code, ordered_code;\n+{\n+  tree arg0, arg1, type;\n+  enum tree_code code0, code1;\n+\n+  /* Check that we have exactly two arguments.  */\n+  if (params == 0 || TREE_CHAIN (params) == 0)\n+    {\n+      error (\"too few arguments to function `%s'\",\n+\t     IDENTIFIER_POINTER (DECL_NAME (function)));\n+      return error_mark_node;\n+    }\n+  else if (TREE_CHAIN (TREE_CHAIN (params)) != 0)\n+    {\n+      error (\"too many arguments to function `%s'\",\n+\t     IDENTIFIER_POINTER (DECL_NAME (function)));\n+      return error_mark_node;\n+    }\n+\n+  arg0 = TREE_VALUE (params);\n+  arg1 = TREE_VALUE (TREE_CHAIN (params));\n+\n+  code0 = TREE_CODE (TREE_TYPE (arg0));\n+  code1 = TREE_CODE (TREE_TYPE (arg1));\n+\n+  /* Make sure that the arguments have a common type of REAL.  */\n+  type = 0;\n+  if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE)\n+      && (code1 == INTEGER_TYPE || code1 == REAL_TYPE))\n+    type = common_type (TREE_TYPE (arg0), TREE_TYPE (arg1));\n+\n+  if (type == 0 || TREE_CODE (type) != REAL_TYPE)\n+    {\n+      error (\"non-floating-point argument to function `%s'\",\n+\t     IDENTIFIER_POINTER (DECL_NAME (function)));\n+      return error_mark_node;\n+    }\n+\n+  if (unordered_code == UNORDERED_EXPR)\n+    {\n+      if (MODE_HAS_NANS (TYPE_MODE (type)))\n+\treturn build_binary_op (unordered_code,\n+\t\t\t\tconvert (type, arg0),\n+\t\t\t\tconvert (type, arg1),\n+\t\t\t\t0);\n+      else\n+\treturn integer_zero_node;\n+    }\n+\n+  return build_unary_op (TRUTH_NOT_EXPR,\n+\t\t\t build_binary_op (MODE_HAS_NANS (TYPE_MODE (type))\n+\t\t\t\t\t  ? unordered_code\n+\t\t\t\t\t  : ordered_code,\n+\t\t\t\t\t  convert (type, arg0),\n+\t\t\t\t\t  convert (type, arg1),\n+\t\t\t\t\t  0),\n+\t\t\t 0);\n+}\n+\n+\n /* Recognize certain built-in functions so we can make tree-codes\n    other than CALL_EXPR.  We do this when it enables fold-const.c\n    to do something useful.  */\n@@ -3063,8 +3143,6 @@ tree\n expand_tree_builtin (function, params, coerced_params)\n      tree function, params, coerced_params;\n {\n-  enum tree_code code;\n-\n   if (DECL_BUILT_IN_CLASS (function) != BUILT_IN_NORMAL)\n     return NULL_TREE;\n \n@@ -3103,72 +3181,22 @@ expand_tree_builtin (function, params, coerced_params)\n       return build_unary_op (IMAGPART_EXPR, TREE_VALUE (coerced_params), 0);\n \n     case BUILT_IN_ISGREATER:\n-      if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n-\tcode = UNLE_EXPR;\n-      else\n-\tcode = LE_EXPR;\n-      goto unordered_cmp;\n+      return expand_unordered_cmp (function, params, UNLE_EXPR, LE_EXPR);\n \n     case BUILT_IN_ISGREATEREQUAL:\n-      if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n-\tcode = UNLT_EXPR;\n-      else\n-\tcode = LT_EXPR;\n-      goto unordered_cmp;\n+      return expand_unordered_cmp (function, params, UNLT_EXPR, LT_EXPR);\n \n     case BUILT_IN_ISLESS:\n-      if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n-\tcode = UNGE_EXPR;\n-      else\n-\tcode = GE_EXPR;\n-      goto unordered_cmp;\n+      return expand_unordered_cmp (function, params, UNGE_EXPR, GE_EXPR);\n \n     case BUILT_IN_ISLESSEQUAL:\n-      if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n-\tcode = UNGT_EXPR;\n-      else\n-\tcode = GT_EXPR;\n-      goto unordered_cmp;\n+      return expand_unordered_cmp (function, params, UNGT_EXPR, GT_EXPR);\n \n     case BUILT_IN_ISLESSGREATER:\n-      if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n-\tcode = UNEQ_EXPR;\n-      else\n-\tcode = EQ_EXPR;\n-      goto unordered_cmp;\n+      return expand_unordered_cmp (function, params, UNEQ_EXPR, EQ_EXPR);\n \n     case BUILT_IN_ISUNORDERED:\n-      if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT)\n-\treturn integer_zero_node;\n-      code = UNORDERED_EXPR;\n-      goto unordered_cmp;\n-\n-    unordered_cmp:\n-      {\n-\ttree arg0, arg1;\n-\n-\tif (params == 0\n-\t    || TREE_CHAIN (params) == 0)\n-\t  {\n-\t    error (\"too few arguments to function `%s'\",\n-\t\t   IDENTIFIER_POINTER (DECL_NAME (function)));\n-\t    return error_mark_node;\n-\t  }\n-\telse if (TREE_CHAIN (TREE_CHAIN (params)) != 0)\n-\t  {\n-\t    error (\"too many arguments to function `%s'\",\n-\t\t   IDENTIFIER_POINTER (DECL_NAME (function)));\n-\t    return error_mark_node;\n-\t  }\n-\n-\targ0 = TREE_VALUE (params);\n-\targ1 = TREE_VALUE (TREE_CHAIN (params));\n-\targ0 = build_binary_op (code, arg0, arg1, 0);\n-\tif (code != UNORDERED_EXPR)\n-\t  arg0 = build_unary_op (TRUTH_NOT_EXPR, arg0, 0);\n-\treturn arg0;\n-      }\n-      break;\n+      return expand_unordered_cmp (function, params, UNORDERED_EXPR, NOP_EXPR);\n \n     default:\n       break;"}, {"sha": "c9a67033dc8601bcdca4894de4cb40c9af4a365e", "filename": "gcc/combine.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=71925bc04f24a40ab8ac587e08609cf91299e293", "patch": "@@ -3978,12 +3978,14 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n       if (GET_CODE (XEXP (x, 0)) == NOT)\n \treturn plus_constant (XEXP (XEXP (x, 0), 0), 1);\n \n-      /* (neg (minus X Y)) can become (minus Y X).  */\n+      /* (neg (minus X Y)) can become (minus Y X).  This transformation\n+\t isn't safe for modes with signed zeros, since if X and Y are\n+\t both +0, (minus Y X) is the same as (minus X Y).  If the rounding\n+\t mode is towards +infinity (or -infinity) then the two expressions\n+\t will be rounded differently.  */\n       if (GET_CODE (XEXP (x, 0)) == MINUS\n-\t  && (! FLOAT_MODE_P (mode)\n-\t      /* x-y != -(y-x) with IEEE floating point.  */\n-\t      || TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t      || flag_unsafe_math_optimizations))\n+\t  && !HONOR_SIGNED_ZEROS (mode)\n+\t  && !HONOR_SIGN_DEPENDENT_ROUNDING (mode))\n \treturn gen_binary (MINUS, mode, XEXP (XEXP (x, 0), 1),\n \t\t\t   XEXP (XEXP (x, 0), 0));\n \n@@ -4145,10 +4147,11 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n       if (XEXP (x, 1) == const0_rtx)\n \treturn XEXP (x, 0);\n \n-      /* In IEEE floating point, x-0 is not the same as x.  */\n-      if ((TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t   || ! FLOAT_MODE_P (GET_MODE (XEXP (x, 0)))\n-\t   || flag_unsafe_math_optimizations)\n+      /* x - 0 is the same as x unless x's mode has signed zeros and\n+\t allows rounding towards -infinity.  Under those conditions,\n+\t 0 - 0 is -0.  */\n+      if (!(HONOR_SIGNED_ZEROS (GET_MODE (XEXP (x, 0)))\n+\t    && HONOR_SIGN_DEPENDENT_ROUNDING (GET_MODE (XEXP (x, 0))))\n \t  && XEXP (x, 1) == CONST0_RTX (GET_MODE (XEXP (x, 0))))\n \treturn XEXP (x, 0);\n       break;"}, {"sha": "1fe4752d8a0f414f3aa2531eb82aeed355bcc076", "filename": "gcc/cse.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=71925bc04f24a40ab8ac587e08609cf91299e293", "patch": "@@ -3981,19 +3981,18 @@ fold_rtx (x, insn)\n \t\t\t\t\t& HASH_MASK), mode_arg0))\n \t\t      && p0->first_same_value == p1->first_same_value))\n \t\t{\n-\t\t   /* Sadly two equal NaNs are not equivalent.  */\n-\t\t   if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t\t       || ! FLOAT_MODE_P (mode_arg0) \n-\t\t       || flag_unsafe_math_optimizations)\n-\t\t      return ((code == EQ || code == LE || code == GE\n-\t\t\t       || code == LEU || code == GEU || code == UNEQ\n-\t\t\t       || code == UNLE || code == UNGE || code == ORDERED)\n-\t\t\t      ? true_rtx : false_rtx);\n-\t\t   /* Take care for the FP compares we can resolve.  */\n-\t\t   if (code == UNEQ || code == UNLE || code == UNGE)\n-\t\t     return true_rtx;\n-\t\t   if (code == LTGT || code == LT || code == GT)\n-\t\t     return false_rtx;\n+\t\t  /* Sadly two equal NaNs are not equivalent.  */\n+\t\t  if (!HONOR_NANS (mode_arg0))\n+\t\t    return ((code == EQ || code == LE || code == GE\n+\t\t\t     || code == LEU || code == GEU || code == UNEQ\n+\t\t\t     || code == UNLE || code == UNGE\n+\t\t\t     || code == ORDERED)\n+\t\t\t    ? true_rtx : false_rtx);\n+\t\t  /* Take care for the FP compares we can resolve.  */\n+\t\t  if (code == UNEQ || code == UNLE || code == UNGE)\n+\t\t    return true_rtx;\n+\t\t  if (code == LTGT || code == LT || code == GT)\n+\t\t    return false_rtx;\n \t\t}\n \n \t      /* If FOLDED_ARG0 is a register, see if the comparison we are"}, {"sha": "5142ee7b471017e3b65457e99d2b8969f74a5904", "filename": "gcc/defaults.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=71925bc04f24a40ab8ac587e08609cf91299e293", "patch": "@@ -465,4 +465,24 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n #define MODE_BASE_REG_CLASS(MODE) BASE_REG_CLASS\n #endif\n \n+#ifndef MODE_HAS_NANS\n+#define MODE_HAS_NANS(MODE) \\\n+  (FLOAT_MODE_P (MODE) && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n+#endif\n+\n+#ifndef MODE_HAS_INFINITIES\n+#define MODE_HAS_INFINITIES(MODE) \\\n+  (FLOAT_MODE_P (MODE) && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n+#endif\n+\n+#ifndef MODE_HAS_SIGNED_ZEROS\n+#define MODE_HAS_SIGNED_ZEROS(MODE) \\\n+  (FLOAT_MODE_P (MODE) && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n+#endif\n+\n+#ifndef MODE_HAS_SIGN_DEPENDENT_ROUNDING\n+#define MODE_HAS_SIGN_DEPENDENT_ROUNDING(MODE) \\\n+  (FLOAT_MODE_P (MODE) && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n+#endif\n+\n #endif  /* ! GCC_DEFAULTS_H */"}, {"sha": "344c711f57caa5f0bd085d7afc3a001f1bd045e5", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=71925bc04f24a40ab8ac587e08609cf91299e293", "patch": "@@ -1336,6 +1336,55 @@ defined for them.\n The ordering of the component words of floating point values stored in\n memory is controlled by @code{FLOAT_WORDS_BIG_ENDIAN}.\n \n+@findex MODE_HAS_NANS\n+@item MODE_HAS_NANS (@var{mode})\n+When defined, this macro should be true if @var{mode} has a NaN\n+representation.  The compiler assumes that NaNs are not equal to\n+anything (including themselves) and that addition, subtraction,\n+multiplication and division all return NaNs when one operand is\n+NaN@.\n+\n+By default, this macro is true if @var{mode} is a floating-point\n+mode and the target floating-point format is IEEE@.\n+\n+@findex MODE_HAS_INFINITIES\n+@item MODE_HAS_INFINITIES (@var{mode})\n+This macro should be true if @var{mode} can represent infinity.  At\n+present, the compiler uses this macro to decide whether @samp{x - x}\n+is always defined.  By default, the macro is true when @var{mode}\n+is a floating-point mode and the target format is IEEE@.\n+\n+@findex MODE_HAS_SIGNED_ZEROS\n+@item MODE_HAS_SIGNED_ZEROS (@var{mode})\n+True if @var{mode} distinguishes between positive and negative zero.\n+The rules are expected to follow the IEEE standard:\n+\n+@itemize @bullet\n+@item\n+@samp{x + x} has the same sign as @samp{x}.\n+\n+@item\n+If the sum of two values with opposite sign is zero, the result is\n+positive for all rounding modes expect towards @minus{}infinity, for\n+which it is negative.\n+\n+@item\n+The sign of a product or quotient is negative when exactly one\n+of the operands is negative.\n+@end itemize\n+\n+The default definition is true if @var{mode} is a floating-point\n+mode and the target format is IEEE@.\n+\n+@findex MODE_HAS_SIGN_DEPENDENT_ROUNDING\n+@item MODE_HAS_SIGN_DEPENDENT_ROUNDING (@var{mode})\n+If defined, this macro should be true for @var{mode} if it has at\n+least one rounding mode in which @samp{x} and @samp{-x} can be\n+rounded to numbers of different magnitude.  Two such modes are\n+towards @minus{}infinity and towards +infinity.\n+\n+The default definition of this macro is true if @var{mode} is\n+a floating-point mode and the target format is IEEE@.\n @end table\n \n @deftypefn {Target Hook} bool TARGET_MS_BITFIELD_LAYOUT_P (tree @var{record_type})"}, {"sha": "3b0ee2fc947fad27996d229229e6ab35cc85e1aa", "filename": "gcc/flags.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=71925bc04f24a40ab8ac587e08609cf91299e293", "patch": "@@ -633,4 +633,27 @@ extern int flag_non_call_exceptions;\n /* Nonzero means put zero initialized data in the bss section.  */\n extern int flag_zero_initialized_in_bss;\n \n+/* True if the given mode has a NaN representation and the treatment of\n+   NaN operands is important.  Certain optimizations, such as folding\n+   x * 0 into x, are not correct for NaN operands, and are normally\n+   disabled for modes with NaNs.  The user can ask for them to be\n+   done anyway using the -funsafe-math-optimizations switch.  */\n+#define HONOR_NANS(MODE) \\\n+  (MODE_HAS_NANS (MODE) && !flag_unsafe_math_optimizations)\n+\n+/* As for HONOR_NANS, but true if the mode can represent infinity and\n+   the treatment of infinite values is important.  */\n+#define HONOR_INFINITIES(MODE) \\\n+  (MODE_HAS_INFINITIES (MODE) && !flag_unsafe_math_optimizations)\n+\n+/* Like HONOR_NANS, but true if the given mode distinguishes between\n+   postive and negative zero, and the sign of zero is important.  */\n+#define HONOR_SIGNED_ZEROS(MODE) \\\n+  (MODE_HAS_SIGNED_ZEROS (MODE) && !flag_unsafe_math_optimizations)\n+\n+/* Like HONOR_NANS, but true if given mode supports sign-dependent rounding,\n+   and the rounding mode is important.  */\n+#define HONOR_SIGN_DEPENDENT_ROUNDING(MODE) \\\n+  (MODE_HAS_SIGN_DEPENDENT_ROUNDING (MODE) && !flag_unsafe_math_optimizations)\n+\n #endif /* ! GCC_FLAGS_H */"}, {"sha": "feb3e5f72fdca6df406510e298eaccfd1a655893", "filename": "gcc/fold-const.c", "status": "modified", "additions": 127, "deletions": 47, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=71925bc04f24a40ab8ac587e08609cf91299e293", "patch": "@@ -105,6 +105,7 @@ static tree constant_boolean_node PARAMS ((int, tree));\n static int count_cond\t\tPARAMS ((tree, int));\n static tree fold_binary_op_with_conditional_arg \n   PARAMS ((enum tree_code, tree, tree, tree, int));\n+static bool fold_real_zero_addition_p\tPARAMS ((tree, tree, int));\n \t\t\t\t\t\t\t \n #ifndef BRANCH_COST\n #define BRANCH_COST 1\n@@ -4372,6 +4373,43 @@ fold_binary_op_with_conditional_arg (code, type, cond, arg, cond_first_p)\n }\n \n \f\n+/* Subroutine of fold() that checks for the addition of +/- 0.0.\n+\n+   If !NEGATE, return true if ADDEND is +/-0.0 and, for all X of type\n+   TYPE, X + ADDEND is the same as X.  If NEGATE, return true if X -\n+   ADDEND is the same as X.\n+\n+   X + 0 and X - 0 both give X when X is NaN, infinite, or non-zero\n+   and finite.  The problematic cases are when X is zero, and its mode\n+   has signed zeros.  In the case of rounding towards -infinity,\n+   X - 0 is not the same as X because 0 - 0 is -0.  In other rounding\n+   modes, X + 0 is not the same as X because -0 + 0 is 0.  */\n+\n+static bool\n+fold_real_zero_addition_p (type, addend, negate)\n+     tree type, addend;\n+     int negate;\n+{\n+  if (!real_zerop (addend))\n+    return false;\n+\n+  /* Allow the fold if zeros aren't signed, or their sign isn't important.  */\n+  if (!HONOR_SIGNED_ZEROS (TYPE_MODE (type)))\n+    return true;\n+\n+  /* Treat x + -0 as x - 0 and x - -0 as x + 0.  */\n+  if (TREE_CODE (addend) == REAL_CST\n+      && REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (addend)))\n+    negate = !negate;\n+\n+  /* The mode has signed zeros, and we have to honor their sign.\n+     In this situation, there is only one case we can return true for.\n+     X - 0 is the same as X unless rounding towards -infinity is\n+     supported.  */\n+  return negate && !HONOR_SIGN_DEPENDENT_ROUNDING (TYPE_MODE (type));\n+}\n+\n+\n /* Perform constant folding and related simplification of EXPR.\n    The related simplifications include x*1 => x, x*0 => 0, etc.,\n    and application of the associative law.\n@@ -5001,16 +5039,15 @@ fold (expr)\n \t\t\t\t    same));\n \t    }\n \t}\n-      /* In IEEE floating point, x+0 may not equal x.  */\n-      else if ((TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t\t|| flag_unsafe_math_optimizations)\n-\t       && real_zerop (arg1))\n-\treturn non_lvalue (convert (type, arg0));\n-      /* x+(-0) equals x, even for IEEE.  */\n-      else if (TREE_CODE (arg1) == REAL_CST\n-\t       && REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (arg1)))\n+\n+      /* See if ARG1 is zero and X + ARG1 reduces to X.  */\n+      else if (fold_real_zero_addition_p (TREE_TYPE (arg0), arg1, 0))\n \treturn non_lvalue (convert (type, arg0));\n \n+      /* Likewise if the operands are reversed.  */\n+      else if (fold_real_zero_addition_p (TREE_TYPE (arg1), arg0, 0))\n+\treturn non_lvalue (convert (type, arg1));\n+\n      bit_rotate:\n       /* (A << C1) + (A >> C2) if A is unsigned and C1+C2 is the size of A\n \t is a rotate of A by C1 bits.  */\n@@ -5163,16 +5200,15 @@ fold (expr)\n \t\t\t\tTREE_OPERAND (arg0, 1)));\n \t}\n \n-      else if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t       || flag_unsafe_math_optimizations)\n-\t{\n-\t  /* Except with IEEE floating point, 0-x equals -x.  */\n-\t  if (! wins && real_zerop (arg0))\n-\t    return negate_expr (convert (type, arg1));\n-\t  /* Except with IEEE floating point, x-0 equals x.  */\n-\t  if (real_zerop (arg1))\n-\t    return non_lvalue (convert (type, arg0));\n-\t}\n+      /* See if ARG1 is zero and X - ARG1 reduces to X.  */\n+      else if (fold_real_zero_addition_p (TREE_TYPE (arg0), arg1, 1))\n+\treturn non_lvalue (convert (type, arg0));\n+\n+      /* (ARG0 - ARG1) is the same as (-ARG1 + ARG0).  So check whether\n+\t ARG0 is zero and X + ARG0 reduces to X, since that would mean\n+\t (-ARG1 + ARG0) reduces to -ARG1.  */\n+      else if (!wins && fold_real_zero_addition_p (TREE_TYPE (arg1), arg0, 0))\n+\treturn negate_expr (convert (type, arg1));\n \n       /* Fold &x - &x.  This can happen from &x.foo - &x.\n \t This is unsafe for certain floats even in non-IEEE formats.\n@@ -5217,9 +5253,12 @@ fold (expr)\n \t}\n       else\n \t{\n-\t  /* x*0 is 0, except for IEEE floating point.  */\n-\t  if ((TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t       || flag_unsafe_math_optimizations)\n+\t  /* Maybe fold x * 0 to 0.  The expressions aren't the same\n+\t     when x is NaN, since x * 0 is also NaN.  Nor are they the\n+\t     same in modes with signed zeros, since multiplying a\n+\t     negative value by 0 gives -0, not +0.  */\n+\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0)))\n+\t      && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg0)))\n \t      && real_zerop (arg1))\n \t    return omit_one_operand (type, arg1, arg0);\n \t  /* In IEEE floating point, x*1 is not equivalent to x for snans.\n@@ -6504,23 +6543,38 @@ fold (expr)\n \n       /* If we have A op B ? A : C, we may be able to convert this to a\n \t simpler expression, depending on the operation and the values\n-\t of B and C.  IEEE floating point prevents this though,\n-\t because A or B might be -0.0 or a NaN.  */\n+\t of B and C.  Signed zeros prevent all of these transformations,\n+\t for reasons given above each one.  */\n \n       if (TREE_CODE_CLASS (TREE_CODE (arg0)) == '<'\n-\t  && (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t      || ! FLOAT_TYPE_P (TREE_TYPE (TREE_OPERAND (arg0, 0)))\n-\t      || flag_unsafe_math_optimizations)\n \t  && operand_equal_for_comparison_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t\t     arg1, TREE_OPERAND (arg0, 1)))\n+\t\t\t\t\t     arg1, TREE_OPERAND (arg0, 1))\n+\t  && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg1))))\n \t{\n \t  tree arg2 = TREE_OPERAND (t, 2);\n \t  enum tree_code comp_code = TREE_CODE (arg0);\n \n \t  STRIP_NOPS (arg2);\n \n-\t  /* If we have A op 0 ? A : -A, this is A, -A, abs (A), or -abs (A),\n-\t     depending on the comparison operation.  */\n+\t  /* If we have A op 0 ? A : -A, consider applying the following\n+\t     transformations:\n+\n+\t     A == 0? A : -A    same as -A\n+\t     A != 0? A : -A    same as A\n+\t     A >= 0? A : -A    same as abs (A)\n+\t     A > 0?  A : -A    same as abs (A)\n+\t     A <= 0? A : -A    same as -abs (A)\n+\t     A < 0?  A : -A    same as -abs (A)\n+\n+\t     None of these transformations work for modes with signed\n+\t     zeros.  If A is +/-0, the first two transformations will\n+\t     change the sign of the result (from +0 to -0, or vice\n+\t     versa).  The last four will fix the sign of the result,\n+\t     even though the original expressions could be positive or\n+\t     negative, depending on the sign of A.\n+\n+\t     Note that all these transformations are correct if A is\n+\t     NaN, since the two alternatives (A and -A) are also NaNs.  */\n \t  if ((FLOAT_TYPE_P (TREE_TYPE (TREE_OPERAND (arg0, 1)))\n \t       ? real_zerop (TREE_OPERAND (arg0, 1))\n \t       : integer_zerop (TREE_OPERAND (arg0, 1)))\n@@ -6535,7 +6589,6 @@ fold (expr)\n \t\t\t      negate_expr\n \t\t\t      (convert (TREE_TYPE (TREE_OPERAND (t, 1)),\n \t\t\t\t\targ1))));\n-\n \t      case NE_EXPR:\n \t\treturn pedantic_non_lvalue (convert (type, arg1));\n \t      case GE_EXPR:\n@@ -6558,8 +6611,10 @@ fold (expr)\n \t\tabort ();\n \t      }\n \n-\t  /* If this is A != 0 ? A : 0, this is simply A.  For ==, it is\n-\t     always zero.  */\n+\t  /* A != 0 ? A : 0 is simply A, unless A is -0.  Likewise\n+\t     A == 0 ? A : 0 is always 0 unless A is -0.  Note that\n+\t     both transformations are correct when A is NaN: A != 0\n+\t     is then true, and A == 0 is false.  */\n \n \t  if (integer_zerop (TREE_OPERAND (arg0, 1)) && integer_zerop (arg2))\n \t    {\n@@ -6569,9 +6624,32 @@ fold (expr)\n \t\treturn pedantic_non_lvalue (convert (type, integer_zero_node));\n \t    }\n \n-\t  /* If this is A op B ? A : B, this is either A, B, min (A, B),\n-\t     or max (A, B), depending on the operation.  */\n-\n+\t  /* Try some transformations of A op B ? A : B.\n+\n+\t     A == B? A : B    same as B\n+\t     A != B? A : B    same as A\n+\t     A >= B? A : B    same as max (A, B)\n+\t     A > B?  A : B    same as max (B, A)\n+\t     A <= B? A : B    same as min (A, B)\n+\t     A < B?  A : B    same as min (B, A)\n+\n+\t     As above, these transformations don't work in the presence\n+\t     of signed zeros.  For example, if A and B are zeros of\n+\t     opposite sign, the first two transformations will change\n+\t     the sign of the result.  In the last four, the original\n+\t     expressions give different results for (A=+0, B=-0) and\n+\t     (A=-0, B=+0), but the transformed expressions do not.\n+\n+\t     The first two transformations are correct if either A or B\n+\t     is a NaN.  In the first transformation, the condition will\n+\t     be false, and B will indeed be chosen.  In the case of the\n+\t     second transformation, the condition A != B will be true,\n+\t     and A will be chosen.\n+\n+\t     The conversions to max() and min() are not correct if B is\n+\t     a number and A is not.  The conditions in the original\n+\t     expressions will be false, so all four give B.  The min()\n+\t     and max() versions would give a NaN instead.  */\n \t  if (operand_equal_for_comparison_p (TREE_OPERAND (arg0, 1),\n \t\t\t\t\t      arg2, TREE_OPERAND (arg0, 0)))\n \t    {\n@@ -6595,21 +6673,23 @@ fold (expr)\n \t\t     operand which will be used if they are equal first\n \t\t     so that we can convert this back to the\n \t\t     corresponding COND_EXPR.  */\n-\t\t  return pedantic_non_lvalue\n-\t\t    (convert (type, fold (build (MIN_EXPR, comp_type,\n-\t\t\t\t\t\t (comp_code == LE_EXPR\n-\t\t\t\t\t\t  ? comp_op0 : comp_op1),\n-\t\t\t\t\t\t (comp_code == LE_EXPR\n-\t\t\t\t\t\t  ? comp_op1 : comp_op0)))));\n+\t\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg1))))\n+\t\t    return pedantic_non_lvalue\n+\t\t      (convert (type, fold (build (MIN_EXPR, comp_type,\n+\t\t\t\t\t\t   (comp_code == LE_EXPR\n+\t\t\t\t\t\t    ? comp_op0 : comp_op1),\n+\t\t\t\t\t\t   (comp_code == LE_EXPR\n+\t\t\t\t\t\t    ? comp_op1 : comp_op0)))));\n \t\t  break;\n \t\tcase GE_EXPR:\n \t\tcase GT_EXPR:\n-\t\t  return pedantic_non_lvalue\n-\t\t    (convert (type, fold (build (MAX_EXPR, comp_type,\n-\t\t\t\t\t\t (comp_code == GE_EXPR\n-\t\t\t\t\t\t  ? comp_op0 : comp_op1),\n-\t\t\t\t\t\t (comp_code == GE_EXPR\n-\t\t\t\t\t\t  ? comp_op1 : comp_op0)))));\n+\t\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg1))))\n+\t\t    return pedantic_non_lvalue\n+\t\t      (convert (type, fold (build (MAX_EXPR, comp_type,\n+\t\t\t\t\t\t   (comp_code == GE_EXPR\n+\t\t\t\t\t\t    ? comp_op0 : comp_op1),\n+\t\t\t\t\t\t   (comp_code == GE_EXPR\n+\t\t\t\t\t\t    ? comp_op1 : comp_op0)))));\n \t\t  break;\n \t\tdefault:\n \t\t  abort ();"}, {"sha": "7a450bc97a99a17678ed6e2567cfc8ed701f2829", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=71925bc04f24a40ab8ac587e08609cf91299e293", "patch": "@@ -1295,12 +1295,11 @@ noce_try_minmax (if_info)\n   if (no_new_pseudos)\n     return FALSE;\n \n-  /* ??? Reject FP modes since we don't know how 0 vs -0 or NaNs\n-     will be resolved with an SMIN/SMAX.  It wouldn't be too hard\n+  /* ??? Reject modes with NaNs or signed zeros since we don't know how\n+     they will be resolved with an SMIN/SMAX.  It wouldn't be too hard\n      to get the target to tell us...  */\n-  if (FLOAT_MODE_P (GET_MODE (if_info->x))\n-      && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-      && ! flag_unsafe_math_optimizations)\n+  if (HONOR_SIGNED_ZEROS (GET_MODE (if_info->x))\n+      || HONOR_NANS (GET_MODE (if_info->x)))\n     return FALSE;\n \n   cond = noce_get_alt_condition (if_info, if_info->a, &earliest);"}, {"sha": "86b3a94276965b6b63fd8c158ebd0b5fea2705d1", "filename": "gcc/jump.c", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=71925bc04f24a40ab8ac587e08609cf91299e293", "patch": "@@ -704,11 +704,6 @@ reversed_comparison_code_parts (code, arg0, arg1, insn)\n       break;\n     }\n \n-  /* In case we give up IEEE compatibility, all comparisons are reversible.  */\n-  if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-      || flag_unsafe_math_optimizations)\n-    return reverse_condition (code);\n-\n   if (GET_MODE_CLASS (mode) == MODE_CC\n #ifdef HAVE_cc0\n       || arg0 == cc0_rtx\n@@ -757,11 +752,12 @@ reversed_comparison_code_parts (code, arg0, arg1, insn)\n \t}\n     }\n \n-  /* An integer condition.  */\n+  /* Test for an integer condition, or a floating-point comparison\n+     in which NaNs can be ignored.  */\n   if (GET_CODE (arg0) == CONST_INT\n       || (GET_MODE (arg0) != VOIDmode\n \t  && GET_MODE_CLASS (mode) != MODE_CC\n-\t  && ! FLOAT_MODE_P (mode)))\n+\t  && !HONOR_NANS (mode)))\n     return reverse_condition (code);\n \n   return UNKNOWN;\n@@ -840,10 +836,6 @@ enum rtx_code\n reverse_condition_maybe_unordered (code)\n      enum rtx_code code;\n {\n-  /* Non-IEEE formats don't have unordered conditions.  */\n-  if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT)\n-    return reverse_condition (code);\n-\n   switch (code)\n     {\n     case EQ:"}, {"sha": "88ca32b5b2440248da71630b24916b26af64ff21", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71925bc04f24a40ab8ac587e08609cf91299e293/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=71925bc04f24a40ab8ac587e08609cf91299e293", "patch": "@@ -981,16 +981,15 @@ simplify_binary_operation (code, mode, op0, op1)\n       switch (code)\n \t{\n \tcase PLUS:\n-\t  /* In IEEE floating point, x+0 is not the same as x.  Similarly\n-\t     for the other optimizations below.  */\n-\t  if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-\t      && FLOAT_MODE_P (mode) && ! flag_unsafe_math_optimizations)\n-\t    break;\n-\n-\t  if (trueop1 == CONST0_RTX (mode))\n+\t  /* Maybe simplify x + 0 to x.  The two expressions are equivalent\n+\t     when x is NaN, infinite, or finite and non-zero.  They aren't\n+\t     when x is -0 and the rounding mode is not towards -infinity,\n+\t     since (-0) + 0 is then 0.  */\n+\t  if (!HONOR_SIGNED_ZEROS (mode) && trueop1 == CONST0_RTX (mode))\n \t    return op0;\n \n-\t  /* ((-a) + b) -> (b - a) and similarly for (a + (-b)) */\n+\t  /* ((-a) + b) -> (b - a) and similarly for (a + (-b)).  These\n+\t     transformations are safe even for IEEE.  */\n \t  if (GET_CODE (op0) == NEG)\n \t    return simplify_gen_binary (MINUS, mode, op1, XEXP (op0, 0));\n \t  else if (GET_CODE (op1) == NEG)\n@@ -1122,12 +1121,6 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  break;\t      \n \n \tcase MINUS:\n-\t  /* None of these optimizations can be done for IEEE\n-\t     floating point.  */\n-\t  if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-\t      && FLOAT_MODE_P (mode) && ! flag_unsafe_math_optimizations)\n-\t    break;\n-\n \t  /* We can't assume x-x is 0 even with non-IEEE floating point,\n \t     but since it is zero except in very strange circumstances, we\n \t     will treat it as zero with -funsafe-math-optimizations.  */\n@@ -1136,16 +1129,23 @@ simplify_binary_operation (code, mode, op0, op1)\n \t      && (! FLOAT_MODE_P (mode) || flag_unsafe_math_optimizations))\n \t    return CONST0_RTX (mode);\n \n-\t  /* Change subtraction from zero into negation.  */\n-\t  if (trueop0 == CONST0_RTX (mode))\n+\t  /* Change subtraction from zero into negation.  (0 - x) is the\n+\t     same as -x when x is NaN, infinite, or finite and non-zero.\n+\t     But if the mode has signed zeros, and does not round towards\n+\t     -infinity, then 0 - 0 is 0, not -0.  */\n+\t  if (!HONOR_SIGNED_ZEROS (mode) && trueop0 == CONST0_RTX (mode))\n \t    return gen_rtx_NEG (mode, op1);\n \n \t  /* (-1 - a) is ~a.  */\n \t  if (trueop0 == constm1_rtx)\n \t    return gen_rtx_NOT (mode, op1);\n \n-\t  /* Subtracting 0 has no effect.  */\n-\t  if (trueop1 == CONST0_RTX (mode))\n+\t  /* Subtracting 0 has no effect unless the mode has signed zeros\n+\t     and supports rounding towards -infinity.  In such a case,\n+\t     0 - 0 is -0.  */\n+\t  if (!(HONOR_SIGNED_ZEROS (mode)\n+\t\t&& HONOR_SIGN_DEPENDENT_ROUNDING (mode))\n+\t      && trueop1 == CONST0_RTX (mode))\n \t    return op0;\n \n \t  /* See if this is something like X * C - X or vice versa or\n@@ -1202,7 +1202,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t\t}\n \t    }\n \n-\t  /* (a - (-b)) -> (a + b).  */\n+\t  /* (a - (-b)) -> (a + b).  True even for IEEE.  */\n \t  if (GET_CODE (op1) == NEG)\n \t    return simplify_gen_binary (PLUS, mode, op0, XEXP (op1, 0));\n \n@@ -1248,9 +1248,12 @@ simplify_binary_operation (code, mode, op0, op1)\n \t      return tem ? tem : gen_rtx_NEG (mode, op0);\n \t    }\n \n-\t  /* In IEEE floating point, x*0 is not always 0.  */\n-\t  if ((TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t       || ! FLOAT_MODE_P (mode) || flag_unsafe_math_optimizations)\n+\t  /* Maybe simplify x * 0 to 0.  The reduction is not valid if\n+\t     x is NaN, since x * 0 is then also NaN.  Nor is it valid\n+\t     when the mode has signed zeros, since multiplying a negative\n+\t     number by 0 will give -0, not 0.  */\n+\t  if (!HONOR_NANS (mode)\n+\t      && !HONOR_SIGNED_ZEROS (mode)\n \t      && trueop1 == CONST0_RTX (mode)\n \t      && ! side_effects_p (op0))\n \t    return op1;\n@@ -1361,9 +1364,12 @@ simplify_binary_operation (code, mode, op0, op1)\n \t\treturn op0;\n \t    }\n \n-\t  /* In IEEE floating point, 0/x is not always 0.  */\n-\t  if ((TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t       || ! FLOAT_MODE_P (mode) || flag_unsafe_math_optimizations)\n+\t  /* Maybe change 0 / x to 0.  This transformation isn't safe for\n+\t     modes with NaNs, since 0 / 0 will then be NaN rather than 0.\n+\t     Nor is it safe for modes with signed zeros, since dividing\n+\t     0 by a negative number gives -0, not 0.  */\n+\t  if (!HONOR_NANS (mode)\n+\t      && !HONOR_SIGNED_ZEROS (mode)\n \t      && trueop0 == CONST0_RTX (mode)\n \t      && ! side_effects_p (op1))\n \t    return op0;\n@@ -2018,12 +2024,9 @@ simplify_relational_operation (code, mode, op0, op1)\n   if (flag_unsafe_math_optimizations && code == UNORDERED)\n     return const0_rtx;\n \n-  /* For non-IEEE floating-point, if the two operands are equal, we know the\n+  /* For modes without NaNs, if the two operands are equal, we know the\n      result.  */\n-  if (rtx_equal_p (trueop0, trueop1)\n-      && (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t  || ! FLOAT_MODE_P (GET_MODE (trueop0)) \n-\t  || flag_unsafe_math_optimizations))\n+  if (!HONOR_NANS (GET_MODE (trueop0)) && rtx_equal_p (trueop0, trueop1))\n     equal = 1, op0lt = 0, op0ltu = 0, op1lt = 0, op1ltu = 0;\n \n   /* If the operands are floating-point constants, see if we can fold"}]}