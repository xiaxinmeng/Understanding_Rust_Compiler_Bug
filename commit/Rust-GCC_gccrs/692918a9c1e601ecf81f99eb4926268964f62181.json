{"sha": "692918a9c1e601ecf81f99eb4926268964f62181", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkyOTE4YTljMWU2MDFlY2Y4MWY5OWViNDkyNjI2ODk2NGY2MjE4MQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2018-06-11T09:16:54Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-06-11T09:16:54Z"}, "message": "[Ada] Performance degradation with references\n\nThis patch modifies the creation of markers for variable references in the\ncontext of SPARK elaboration checks. Previously, prior to checking whether a\nreference requires such a marker, the compiler performed a logarithmic look up\nto determine whether the reference appears within a call. This action caused\nthe compiler to degrade when a source program contains multiple (100,000s)\nreferences. Now, the compiler no longer performs the look up immediately.\n\n2018-06-11  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* sem_ch8.adb (Find_Direct_Name): Mode the declaration of\n\tIs_Assignment_LHS further in. Use predicate\n\tNeeds_Variable_Reference_Marker to determine whether to create a\n\tvariable marker.\n\t(Find_Expanded_Name): Mode the declaration of Is_Assignment_LHS further\n\tin.  Use predicate Needs_Variable_Reference_Marker to determine whether\n\tto create a variable marker.\n\t* sem_elab.adb (Build_Variable_Reference_Marker): Remove the various\n\tchecks that determine whether the identifier or expanded name is a\n\tsuitable variable reference.  The checks are now performed by\n\tNeeds_Variable_Reference_Marker.\n\t* sem_res.adb (Resolve_Actuals): Use predicate\n\tNeeds_Variable_Reference_Marker to determine whether to create a\n\tvariable marker.\n\t* sem_util.adb (Needs_Variable_Reference_Marker): New routine.\n\t* sem_util.ads (Needs_Variable_Reference_Marker): New routine.\n\nFrom-SVN: r261400", "tree": {"sha": "af872ce2ce742199a99bca8764dcc9621416aae8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af872ce2ce742199a99bca8764dcc9621416aae8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/692918a9c1e601ecf81f99eb4926268964f62181", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/692918a9c1e601ecf81f99eb4926268964f62181", "html_url": "https://github.com/Rust-GCC/gccrs/commit/692918a9c1e601ecf81f99eb4926268964f62181", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/692918a9c1e601ecf81f99eb4926268964f62181/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "51b84f99dca6308f581da724faf7f4646d991f1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51b84f99dca6308f581da724faf7f4646d991f1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51b84f99dca6308f581da724faf7f4646d991f1a"}], "stats": {"total": 381, "additions": 206, "deletions": 175}, "files": [{"sha": "0f51c439308cc6fcd2cac3c9c4743bc6732e7354", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692918a9c1e601ecf81f99eb4926268964f62181/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692918a9c1e601ecf81f99eb4926268964f62181/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=692918a9c1e601ecf81f99eb4926268964f62181", "patch": "@@ -1,3 +1,22 @@\n+2018-06-11  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch8.adb (Find_Direct_Name): Mode the declaration of\n+\tIs_Assignment_LHS further in. Use predicate\n+\tNeeds_Variable_Reference_Marker to determine whether to create a\n+\tvariable marker.\n+\t(Find_Expanded_Name): Mode the declaration of Is_Assignment_LHS further\n+\tin.  Use predicate Needs_Variable_Reference_Marker to determine whether\n+\tto create a variable marker.\n+\t* sem_elab.adb (Build_Variable_Reference_Marker): Remove the various\n+\tchecks that determine whether the identifier or expanded name is a\n+\tsuitable variable reference.  The checks are now performed by\n+\tNeeds_Variable_Reference_Marker.\n+\t* sem_res.adb (Resolve_Actuals): Use predicate\n+\tNeeds_Variable_Reference_Marker to determine whether to create a\n+\tvariable marker.\n+\t* sem_util.adb (Needs_Variable_Reference_Marker): New routine.\n+\t* sem_util.ads (Needs_Variable_Reference_Marker): New routine.\n+\n 2018-06-11  Valentine Reboul  <reboul@adacore.com>\n \n \t* doc/gnat_rm.rst, doc/gnat_ugn.rst: Rename \"GPL Edition\" into"}, {"sha": "830aa038b21d431dca679c49c5e998a2ff360df5", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692918a9c1e601ecf81f99eb4926268964f62181/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692918a9c1e601ecf81f99eb4926268964f62181/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=692918a9c1e601ecf81f99eb4926268964f62181", "patch": "@@ -5423,8 +5423,6 @@ package body Sem_Ch8 is\n \n       --  Local variables\n \n-      Is_Assignment_LHS : constant Boolean := Is_LHS (N) = Yes;\n-\n       Nested_Inst : Entity_Id := Empty;\n       --  The entity of a nested instance which appears within Inst (if any)\n \n@@ -5970,11 +5968,19 @@ package body Sem_Ch8 is\n       --  reference is a write when it appears on the left hand side of an\n       --  assignment.\n \n-      if not Within_Subprogram_Call (N) then\n-         Build_Variable_Reference_Marker\n-           (N     => N,\n-            Read  => not Is_Assignment_LHS,\n-            Write => Is_Assignment_LHS);\n+      if Needs_Variable_Reference_Marker\n+           (N        => N,\n+            Calls_OK => False)\n+      then\n+         declare\n+            Is_Assignment_LHS : constant Boolean := Is_LHS (N) = Yes;\n+\n+         begin\n+            Build_Variable_Reference_Marker\n+              (N     => N,\n+               Read  => not Is_Assignment_LHS,\n+               Write => Is_Assignment_LHS);\n+         end;\n       end if;\n    end Find_Direct_Name;\n \n@@ -6047,8 +6053,7 @@ package body Sem_Ch8 is\n \n       --  Local variables\n \n-      Is_Assignment_LHS : constant Boolean := Is_LHS (N) = Yes;\n-      Selector          : constant Node_Id := Selector_Name (N);\n+      Selector : constant Node_Id := Selector_Name (N);\n \n       Candidate : Entity_Id := Empty;\n       P_Name    : Entity_Id;\n@@ -6621,11 +6626,19 @@ package body Sem_Ch8 is\n       --  reference is a write when it appears on the left hand side of an\n       --  assignment.\n \n-      if not Within_Subprogram_Call (N) then\n-         Build_Variable_Reference_Marker\n-           (N     => N,\n-            Read  => not Is_Assignment_LHS,\n-            Write => Is_Assignment_LHS);\n+      if Needs_Variable_Reference_Marker\n+           (N        => N,\n+            Calls_OK => False)\n+      then\n+         declare\n+            Is_Assignment_LHS : constant Boolean := Is_LHS (N) = Yes;\n+\n+         begin\n+            Build_Variable_Reference_Marker\n+              (N     => N,\n+               Read  => not Is_Assignment_LHS,\n+               Write => Is_Assignment_LHS);\n+         end;\n       end if;\n    end Find_Expanded_Name;\n \n@@ -8301,7 +8314,6 @@ package body Sem_Ch8 is\n    ----------------------\n \n    procedure Mark_Use_Clauses (Id : Node_Or_Entity_Id) is\n-\n       procedure Mark_Parameters (Call : Entity_Id);\n       --  Perform use_type_clause marking for all parameters in a subprogram\n       --  or operator call."}, {"sha": "c2fc7c5977beaaafbe03fe51e5bd0ffc646e8418", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 6, "deletions": 156, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692918a9c1e601ecf81f99eb4926268964f62181/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692918a9c1e601ecf81f99eb4926268964f62181/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=692918a9c1e601ecf81f99eb4926268964f62181", "patch": "@@ -2072,8 +2072,8 @@ package body Sem_Elab is\n       if Legacy_Elaboration_Checks then\n          return;\n \n-      --  Nothing to do for ASIS. As a result, ABE checks and diagnostics are\n-      --  not performed in this mode.\n+      --  Nothing to do for ASIS because ABE checks and diagnostics are not\n+      --  performed in this mode.\n \n       elsif ASIS_Mode then\n          return;\n@@ -2274,166 +2274,16 @@ package body Sem_Elab is\n       Read  : Boolean;\n       Write : Boolean)\n    is\n-      function In_Compilation_Instance_Formal_Part\n-        (Nod : Node_Id) return Boolean;\n-      --  Determine whether arbitrary node Nod appears within the formal part\n-      --  of an instantiation which acts as a compilation unit.\n-\n-      function In_Pragma (Nod : Node_Id) return Boolean;\n-      --  Determine whether arbitrary node Nod appears within a pragma\n-\n-      -----------------------------------------\n-      -- In_Compilation_Instance_Formal_Part --\n-      -----------------------------------------\n-\n-      function In_Compilation_Instance_Formal_Part\n-        (Nod : Node_Id) return Boolean\n-      is\n-         Par : Node_Id;\n-\n-      begin\n-         Par := Nod;\n-         while Present (Par) loop\n-            if Nkind (Par) = N_Generic_Association\n-              and then Nkind (Parent (Par)) in N_Generic_Instantiation\n-              and then Nkind (Parent (Parent (Par))) = N_Compilation_Unit\n-            then\n-               return True;\n-\n-            --  Prevent the search from going too far\n-\n-            elsif Is_Body_Or_Package_Declaration (Par) then\n-               exit;\n-            end if;\n-\n-            Par := Parent (Par);\n-         end loop;\n-\n-         return False;\n-      end In_Compilation_Instance_Formal_Part;\n-\n-      ---------------\n-      -- In_Pragma --\n-      ---------------\n-\n-      function In_Pragma (Nod : Node_Id) return Boolean is\n-         Par : Node_Id;\n-\n-      begin\n-         Par := Nod;\n-         while Present (Par) loop\n-            if Nkind (Par) = N_Pragma then\n-               return True;\n-\n-            --  Prevent the search from going too far\n-\n-            elsif Is_Body_Or_Package_Declaration (Par) then\n-               exit;\n-            end if;\n-\n-            Par := Parent (Par);\n-         end loop;\n-\n-         return False;\n-      end In_Pragma;\n-\n-      --  Local variables\n-\n       Marker    : Node_Id;\n-      Prag      : Node_Id;\n       Var_Attrs : Variable_Attributes;\n       Var_Id    : Entity_Id;\n \n-   --  Start of processing for Build_Variable_Reference_Marker\n-\n    begin\n-      --  Nothing to do when switch -gnatH (legacy elaboration checking mode\n-      --  enabled) is in effect because the legacy ABE mechanism does not need\n-      --  to carry out this action.\n-\n-      if Legacy_Elaboration_Checks then\n-         return;\n-\n-      --  Nothing to do for ASIS. As a result, ABE checks and diagnostics are\n-      --  not performed in this mode.\n-\n-      elsif ASIS_Mode then\n-         return;\n-\n-      --  Nothing to do when the reference is being preanalyzed as the marker\n-      --  will be inserted in the wrong place.\n-\n-      elsif Preanalysis_Active then\n-         return;\n-\n-      --  Nothing to do when the input does not denote a reference\n-\n-      elsif not Nkind_In (N, N_Expanded_Name, N_Identifier) then\n-         return;\n-\n-      --  Nothing to do for internally-generated references\n-\n-      elsif not Comes_From_Source (N) then\n-         return;\n-\n-      --  Nothing to do when the reference is erroneous, left in a bad state,\n-      --  or does not denote a variable.\n-\n-      elsif not (Present (Entity (N))\n-                  and then Ekind (Entity (N)) = E_Variable\n-                  and then Entity (N) /= Any_Id)\n-      then\n-         return;\n-\n-      --  Nothing to do when the reference appears within the formal part of\n-      --  an instantiation which acts as compilation unit because there is no\n-      --  proper context for the insertion of the marker.\n-\n-      --  Performance note: parent traversal\n-\n-      elsif In_Compilation_Instance_Formal_Part (N) then\n-         return;\n-      end if;\n-\n       Extract_Variable_Reference_Attributes\n         (Ref    => N,\n          Var_Id => Var_Id,\n          Attrs  => Var_Attrs);\n \n-      Prag := SPARK_Pragma (Var_Id);\n-\n-      if Comes_From_Source (Var_Id)\n-\n-         --  Both the variable and the reference must appear in SPARK_Mode On\n-         --  regions because this scenario falls under the SPARK rules.\n-\n-         and then Present (Prag)\n-         and then Get_SPARK_Mode_From_Annotation (Prag) = On\n-         and then Is_SPARK_Mode_On_Node (N)\n-\n-         --  The reference must not be considered when it appears in a pragma.\n-         --  If the pragma has run-time semantics, then the reference will be\n-         --  reconsidered once the pragma is expanded.\n-\n-         --  Performance note: parent traversal\n-\n-         and then not In_Pragma (N)\n-      then\n-         null;\n-\n-      --  Otherwise the reference is not suitable for ABE processing. This\n-      --  prevents the generation of variable markers which will never play\n-      --  a role in ABE diagnostics.\n-\n-      else\n-         return;\n-      end if;\n-\n-      --  At this point it is known that the variable reference will play some\n-      --  role in ABE checks and diagnostics. Create a corresponding variable\n-      --  marker in case the original variable reference is folded or optimized\n-      --  away.\n-\n       Marker := Make_Variable_Reference_Marker (Sloc (N));\n \n       --  Inherit the attributes of the original variable reference\n@@ -2469,8 +2319,8 @@ package body Sem_Elab is\n       if Legacy_Elaboration_Checks then\n          return;\n \n-      --  Nothing to do for ASIS. As a result, no ABE checks and diagnostics\n-      --  are performed in this mode.\n+      --  Nothing to do for ASIS because ABE checks and diagnostics are not\n+      --  performed in this mode.\n \n       elsif ASIS_Mode then\n          return;\n@@ -10860,8 +10710,8 @@ package body Sem_Elab is\n       if Legacy_Elaboration_Checks then\n          return;\n \n-      --  Nothing to do for ASIS. As a result, no ABE checks and diagnostics\n-      --  are performed in this mode.\n+      --  Nothing to do for ASIS because ABE checks and diagnostics are not\n+      --  performed in this mode.\n \n       elsif ASIS_Mode then\n          return;"}, {"sha": "e162e78a66e33d7c24d3d82fb5ce3d6c16af76a6", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692918a9c1e601ecf81f99eb4926268964f62181/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692918a9c1e601ecf81f99eb4926268964f62181/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=692918a9c1e601ecf81f99eb4926268964f62181", "patch": "@@ -3667,10 +3667,15 @@ package body Sem_Res is\n             --    read     IN, IN OUT\n             --    write    IN OUT, OUT\n \n-            Build_Variable_Reference_Marker\n-              (N     => A,\n-               Read  => Ekind (F) /= E_Out_Parameter,\n-               Write => Ekind (F) /= E_In_Parameter);\n+            if Needs_Variable_Reference_Marker\n+                 (N        => A,\n+                  Calls_OK => True)\n+            then\n+               Build_Variable_Reference_Marker\n+                 (N     => A,\n+                  Read  => Ekind (F) /= E_Out_Parameter,\n+                  Write => Ekind (F) /= E_In_Parameter);\n+            end if;\n \n             Orig_A := Entity (A);\n "}, {"sha": "9ac04c3afda1f9fd492eb2d54e8fb2977fc72d80", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692918a9c1e601ecf81f99eb4926268964f62181/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692918a9c1e601ecf81f99eb4926268964f62181/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=692918a9c1e601ecf81f99eb4926268964f62181", "patch": "@@ -19247,6 +19247,144 @@ package body Sem_Util is\n       end if;\n    end Needs_Simple_Initialization;\n \n+   -------------------------------------\n+   -- Needs_Variable_Reference_Marker --\n+   -------------------------------------\n+\n+   function Needs_Variable_Reference_Marker\n+     (N        : Node_Id;\n+      Calls_OK : Boolean) return Boolean\n+   is\n+      function Within_Suitable_Context (Ref : Node_Id) return Boolean;\n+      --  Deteremine whether variable reference Ref appears within a suitable\n+      --  context that allows the creation of a marker.\n+\n+      -----------------------------\n+      -- Within_Suitable_Context --\n+      -----------------------------\n+\n+      function Within_Suitable_Context (Ref : Node_Id) return Boolean is\n+         Par : Node_Id;\n+\n+      begin\n+         Par := Ref;\n+         while Present (Par) loop\n+\n+            --  The context is not suitable when the reference appears within\n+            --  the formal part of an instantiation which acts as compilation\n+            --  unit because there is no proper list for the insertion of the\n+            --  marker.\n+\n+            if Nkind (Par) = N_Generic_Association\n+              and then Nkind (Parent (Par)) in N_Generic_Instantiation\n+              and then Nkind (Parent (Parent (Par))) = N_Compilation_Unit\n+            then\n+               return False;\n+\n+            --  The context is not suitable when the reference appears within\n+            --  a pragma. If the pragma has run-time semantics, the reference\n+            --  will be reconsidered once the pragma is expanded.\n+\n+            elsif Nkind (Par) = N_Pragma then\n+               return False;\n+\n+            --  The context is not suitable when the reference appears within a\n+            --  subprogram call, and the caller requests this behavior.\n+\n+            elsif not Calls_OK\n+              and then Nkind_In (Par, N_Entry_Call_Statement,\n+                                      N_Function_Call,\n+                                      N_Procedure_Call_Statement)\n+            then\n+               return False;\n+\n+            --  Prevent the search from going too far\n+\n+            elsif Is_Body_Or_Package_Declaration (Par) then\n+               exit;\n+            end if;\n+\n+            Par := Parent (Par);\n+         end loop;\n+\n+         return True;\n+      end Within_Suitable_Context;\n+\n+      --  Local variables\n+\n+      Prag   : Node_Id;\n+      Var_Id : Entity_Id;\n+\n+   --  Start of processing for Needs_Variable_Reference_Marker\n+\n+   begin\n+      --  No marker needs to be created when switch -gnatH (legacy elaboration\n+      --  checking mode enabled) is in effect because the legacy ABE mechanism\n+      --  does use markers.\n+\n+      if Legacy_Elaboration_Checks then\n+         return False;\n+\n+      --  No marker needs to be created for ASIS because ABE diagnostics and\n+      --  checks are not performed in this mode.\n+\n+      elsif ASIS_Mode then\n+         return False;\n+\n+      --  No marker needs to be created when the reference is preanalyzed\n+      --  because the marker will be inserted in the wrong place.\n+\n+      elsif Preanalysis_Active then\n+         return False;\n+\n+      --  Only references warrant a marker\n+\n+      elsif not Nkind_In (N, N_Expanded_Name, N_Identifier) then\n+         return False;\n+\n+      --  Only source references warrant a marker\n+\n+      elsif not Comes_From_Source (N) then\n+         return False;\n+\n+      --  No marker needs to be created when the reference is erroneous, left\n+      --  in a bad state, or does not denote a variable.\n+\n+      elsif not (Present (Entity (N))\n+                  and then Ekind (Entity (N)) = E_Variable\n+                  and then Entity (N) /= Any_Id)\n+      then\n+         return False;\n+      end if;\n+\n+      Var_Id := Entity (N);\n+      Prag   := SPARK_Pragma (Var_Id);\n+\n+      --  Both the variable and reference must appear in SPARK_Mode On regions\n+      --  because this elaboration scenario falls under the SPARK rules.\n+\n+      if not (Comes_From_Source (Var_Id)\n+               and then Present (Prag)\n+               and then Get_SPARK_Mode_From_Annotation (Prag) = On\n+               and then Is_SPARK_Mode_On_Node (N))\n+      then\n+         return False;\n+\n+      --  No marker needs to be created when the reference does not appear\n+      --  within a suitable context (see body for details).\n+\n+      --  Performance note: parent traversal\n+\n+      elsif not Within_Suitable_Context (N) then\n+         return False;\n+      end if;\n+\n+      --  At this point it is known that the variable reference will play a\n+      --  role in ABE diagnostics and requires a marker.\n+\n+      return True;\n+   end Needs_Variable_Reference_Marker;\n+\n    ------------------------\n    -- New_Copy_List_Tree --\n    ------------------------"}, {"sha": "a0b95fa1cbcc6bdf92dfc22f62d418b15e9ba14d", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692918a9c1e601ecf81f99eb4926268964f62181/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692918a9c1e601ecf81f99eb4926268964f62181/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=692918a9c1e601ecf81f99eb4926268964f62181", "patch": "@@ -2224,6 +2224,13 @@ package Sem_Util is\n    --  set to False, but if Consider_IS is set to True, then the cases above\n    --  mentioning Normalize_Scalars also apply for Initialize_Scalars mode.\n \n+   function Needs_Variable_Reference_Marker\n+     (N        : Node_Id;\n+      Calls_OK : Boolean) return Boolean;\n+   --  Determine whether arbitrary node N denotes a reference to a variable\n+   --  which is suitable for SPARK elaboration checks. Flag Calls_OK should\n+   --  be set when the reference is allowed to appear within calls.\n+\n    function New_Copy_List_Tree (List : List_Id) return List_Id;\n    --  Copy recursively an analyzed list of nodes. Uses New_Copy_Tree defined\n    --  below. As for New_Copy_Tree, it is illegal to attempt to copy extended"}]}