{"sha": "1bc40c7e8ac62eafdef41e04276e9cab85488af7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJjNDBjN2U4YWM2MmVhZmRlZjQxZTA0Mjc2ZTljYWI4NTQ4OGFmNw==", "commit": {"author": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2005-12-29T19:41:21Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2005-12-29T19:41:21Z"}, "message": "bitmap.c (bitmap_element_free, [...]): Added code to properly maintain the variants associated with the CURRENT and...\n\n2005-12-29 Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\t* bitmap.c (bitmap_element_free, bitmap_element_link,\n\tbitmap_elt_insert_after, bitmap_and, bitmap_and_compl,\n\tbitmap_and_compl, bitmap_ior, bitmap_ior_into, bitmap_xor,\n\tbitmap_xor_into): Added code to properly maintain the variants\n\tassociated with the CURRENT and HEAD fields.\n\t(bitmap_popcount, bitmap_clear_range, bitmap_compl_and_into): New\n\tfunctions. * bitmap.h: Added defs for bitmap_popcount,\n\tbitmap_clear_range, and bitmap_compl_and_into.\n\nFrom-SVN: r109153", "tree": {"sha": "9e78cf08041b019d6700dc377e3c95a96775f9a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e78cf08041b019d6700dc377e3c95a96775f9a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1bc40c7e8ac62eafdef41e04276e9cab85488af7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bc40c7e8ac62eafdef41e04276e9cab85488af7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bc40c7e8ac62eafdef41e04276e9cab85488af7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bc40c7e8ac62eafdef41e04276e9cab85488af7/comments", "author": null, "committer": null, "parents": [{"sha": "3dd9b65f61603ae3504abe0a0e95725c511f46be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dd9b65f61603ae3504abe0a0e95725c511f46be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dd9b65f61603ae3504abe0a0e95725c511f46be"}], "stats": {"total": 308, "additions": 280, "deletions": 28}, "files": [{"sha": "f69fd2765acec3f40e5156a86c0df85313b9d1b1", "filename": "gcc/bitmap.c", "status": "modified", "additions": 274, "deletions": 28, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bc40c7e8ac62eafdef41e04276e9cab85488af7/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bc40c7e8ac62eafdef41e04276e9cab85488af7/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=1bc40c7e8ac62eafdef41e04276e9cab85488af7", "patch": "@@ -40,7 +40,7 @@ static void bitmap_element_free (bitmap, bitmap_element *);\n static bitmap_element *bitmap_element_allocate (bitmap);\n static int bitmap_element_zerop (bitmap_element *);\n static void bitmap_element_link (bitmap, bitmap_element *);\n-static bitmap_element *bitmap_elt_insert_after (bitmap, bitmap_element *);\n+static bitmap_element *bitmap_elt_insert_after (bitmap, bitmap_element *, unsigned int);\n static void bitmap_elt_clear_from (bitmap, bitmap_element *);\n static bitmap_element *bitmap_find_bit (bitmap, unsigned int);\n \f\n@@ -89,6 +89,8 @@ bitmap_element_free (bitmap head, bitmap_element *elt)\n       head->current = next != 0 ? next : prev;\n       if (head->current)\n \thead->indx = head->current->indx;\n+      else \n+\thead->indx = 0;\n     }\n   bitmap_elem_to_freelist (head, elt);\n }\n@@ -351,14 +353,18 @@ bitmap_element_link (bitmap head, bitmap_element *element)\n    new element.  */\n \n static bitmap_element *\n-bitmap_elt_insert_after (bitmap head, bitmap_element *elt)\n+bitmap_elt_insert_after (bitmap head, bitmap_element *elt, unsigned int indx)\n {\n   bitmap_element *node = bitmap_element_allocate (head);\n+  node->indx = indx;\n \n   if (!elt)\n     {\n       if (!head->current)\n-\thead->current = node;\n+\t{\n+\t  head->current = node;\n+\t  head->indx = indx;\n+\t}\n       node->next = head->first;\n       if (node->next)\n \tnode->next->prev = node;\n@@ -521,6 +527,59 @@ bitmap_bit_p (bitmap head, int bit)\n   return (ptr->bits[word_num] >> bit_num) & 1;\n }\n \f\n+#if GCC_VERSION < 3400\n+/* Table of number of set bits in a character, indexed by value of char.  */\n+static unsigned char popcount_table[] = \n+{\n+    0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,\n+    1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,\n+    1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,\n+    2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,\n+    1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,\n+    2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,\n+    2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,\n+    3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8,\n+};\n+\n+static unsigned long\n+bitmap_popcount (BITMAP_WORD a)\n+{\n+  unsigned long ret = 0;\n+  unsigned i;\n+\n+  /* Just do this the table way for now  */\n+  for (i = 0; i < BITMAP_WORD_BITS; i+= 8)\n+    ret += popcount_table[(a >> i) & 0xff];\n+  return ret;\n+}\n+#endif\n+/* Count the number of bits set in the bitmap, and return it.  */\n+\n+unsigned long\n+bitmap_count_bits (bitmap a)\n+{\n+  unsigned long count = 0;\n+  bitmap_element *elt;\n+  unsigned ix;\n+\n+  for (elt = a->first; elt; elt = elt->next)\n+    {\n+      for (ix = 0; ix != BITMAP_ELEMENT_WORDS; ix++)\n+\t{\n+#if GCC_VERSION >= 3400\n+ \t  /* Note that popcountl matches BITMAP_WORD in type, so the actual size\n+\t of BITMAP_WORD is not material.  */\n+\t  count += __builtin_popcountl (elt->bits[ix]);\n+#else\n+\t  count += bitmap_popcount (elt->bits[ix]);\t  \n+#endif\n+\t}\n+    }\n+  return count;\n+}\n+      \n+\n+\n /* Return the bit number of the first set bit in the bitmap.  The\n    bitmap must be non-empty.  */\n \n@@ -604,9 +663,9 @@ bitmap_and (bitmap dst, bitmap a, bitmap b)\n \t  BITMAP_WORD ior = 0;\n \n \t  if (!dst_elt)\n-\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev);\n-\t  \n-\t  dst_elt->indx = a_elt->indx;\n+\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev, a_elt->indx);\n+\t  else \n+\t    dst_elt->indx = a_elt->indx;\n \t  for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n \t    {\n \t      BITMAP_WORD r = a_elt->bits[ix] & b_elt->bits[ix];\n@@ -700,9 +759,9 @@ bitmap_and_compl (bitmap dst, bitmap a, bitmap b)\n \t{\n \t  /* Copy a_elt.  */\n \t  if (!dst_elt)\n-\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev);\n-\t  \n-\t  dst_elt->indx = a_elt->indx;\n+\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev, a_elt->indx);\n+\t  else\n+\t    dst_elt->indx = a_elt->indx;\n \t  memcpy (dst_elt->bits, a_elt->bits, sizeof (dst_elt->bits));\n \t  dst_prev = dst_elt;\n \t  dst_elt = dst_elt->next;\n@@ -717,9 +776,9 @@ bitmap_and_compl (bitmap dst, bitmap a, bitmap b)\n \t  BITMAP_WORD ior = 0;\n \n \t  if (!dst_elt)\n-\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev);\n-\t  \n-\t  dst_elt->indx = a_elt->indx;\n+\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev, a_elt->indx);\n+\t  else \n+\t    dst_elt->indx = a_elt->indx;\n \t  for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n \t    {\n \t      BITMAP_WORD r = a_elt->bits[ix] & ~b_elt->bits[ix];\n@@ -796,6 +855,195 @@ bitmap_and_compl_into (bitmap a, bitmap b)\n   return changed != 0;\n }\n \n+/* Clear COUNT bits from START in HEAD.  */\n+void\n+bitmap_clear_range (bitmap head, unsigned int start, unsigned int count)\n+{\n+  unsigned int first_index = start / BITMAP_ELEMENT_ALL_BITS;\n+  unsigned int end_bit_plus1 = start + count;\n+  unsigned int end_bit = end_bit_plus1 - 1;\n+  unsigned int last_index = (end_bit) / BITMAP_ELEMENT_ALL_BITS;\n+  bitmap_element *elt = bitmap_find_bit (head, start);\n+\n+  /* If bitmap_find_bit returns zero, the current is the closest block\n+     to the result.  If the current is less than first index, find the\n+     next one.  Otherwise, just set elt to be current.  */\n+  if (!elt)\n+    { \n+      if (head->current)\n+\t{\n+\t  if (head->indx < first_index)\n+\t    {\n+\t      elt = head->current->next;\n+\t      if (!elt)\n+\t\treturn;\n+\t    }\n+\t  else \n+\t    elt = head->current;\n+\t}\n+      else\n+\treturn;\n+    }\n+\n+  while (elt && (elt->indx <= last_index))\n+    {\n+      bitmap_element * next_elt = elt->next;\n+      unsigned elt_start_bit = (elt->indx) * BITMAP_ELEMENT_ALL_BITS;\n+      unsigned elt_end_bit_plus1 = elt_start_bit + BITMAP_ELEMENT_ALL_BITS;\n+\n+\n+      if (elt_start_bit >= start && elt_end_bit_plus1 <= end_bit_plus1)\n+\t/* Get rid of the entire elt and go to the next one.  */\n+\tbitmap_element_free (head, elt);\n+      else \n+\t{\n+\t  /* Going to have to knock out some bits in this elt.  */\n+\t  unsigned int first_word_to_mod; \n+\t  BITMAP_WORD first_mask; \n+\t  unsigned int last_word_to_mod;\n+\t  BITMAP_WORD last_mask;\n+\t  unsigned int i;\n+\t  bool clear = true;\n+\n+\t  if (elt_start_bit <= start)\n+\t    {\n+\t      /* The first bit to turn off is somewhere inside this\n+\t\t elt.  */\n+\t      first_word_to_mod = (start - elt_start_bit) / BITMAP_WORD_BITS;\n+\n+\t      /* This mask should have 1s in all bits >= start position. */\n+\t      first_mask = \n+\t\t(((BITMAP_WORD) 1) << ((start % BITMAP_WORD_BITS))) - 1;\n+\t      first_mask = ~first_mask;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* The first bit to turn off is below this start of this elt.  */\n+\t      first_word_to_mod = 0;\n+\t      first_mask = 0;\n+\t      first_mask = ~first_mask;\n+\t    }\t      \n+\t    \n+\t  if (elt_end_bit_plus1 <= end_bit_plus1)\n+\t    {\n+\t      /* The last bit to turn off is beyond this elt.  */\n+\t      last_word_to_mod = BITMAP_ELEMENT_WORDS - 1;\n+\t      last_mask = 0;\n+\t      last_mask = ~last_mask;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* The last bit to turn off is inside to this elt.  */\n+\t      last_word_to_mod = \n+\t\t(end_bit_plus1 - elt_start_bit) / BITMAP_WORD_BITS;\n+\n+\t      /* The last mask should have 1s below the end bit.  */\n+\t      last_mask = \n+\t\t(((BITMAP_WORD) 1) << (((end_bit_plus1) % BITMAP_WORD_BITS))) - 1;\n+\t    }\n+\n+\n+\t  if (first_word_to_mod == last_word_to_mod)\n+\t    {\n+\t      BITMAP_WORD mask = first_mask & last_mask;\n+\t      elt->bits[first_word_to_mod] &= ~mask;\n+\t    }\n+\t  else\n+\t    {\n+\t      elt->bits[first_word_to_mod] &= ~first_mask;\n+\t      for (i = first_word_to_mod + 1; i < last_word_to_mod; i++)\n+\t\telt->bits[i] = 0;\n+\t      elt->bits[last_word_to_mod] &= ~last_mask;\n+\t    }\n+\t  for (i = 0; i < BITMAP_ELEMENT_WORDS; i++)\n+\t    if (elt->bits[i])\n+\t      {\n+\t\tclear = false;\n+\t\tbreak;\n+\t      }\n+\t  /* Check to see if there are any bits left.  */\n+\t  if (clear)\n+\t    bitmap_element_free (head, elt);\n+\t}\n+      elt = next_elt;\n+    }\n+  \n+  if (elt)\n+    {\n+      head->current = elt;\n+      head->indx = head->current->indx;\n+    }\n+}\n+\n+/* A = ~A & B. */\n+\n+void\n+bitmap_compl_and_into (bitmap a, bitmap b)\n+{\n+  bitmap_element *a_elt = a->first;\n+  bitmap_element *b_elt = b->first;\n+  bitmap_element *a_prev = NULL;\n+  bitmap_element *next;\n+\n+  gcc_assert (a != b);\n+\n+  if (bitmap_empty_p (a))\n+    {\n+      bitmap_copy (a, b);\n+      return;\n+    }\n+  if (bitmap_empty_p (b))\n+    {\n+      bitmap_clear (a);\n+      return;\n+    }\n+\n+  while (a_elt || b_elt)\n+    {\n+      if (!b_elt || (a_elt && a_elt->indx < b_elt->indx))\n+\t{\n+\t  /* A is before B.  Remove A */\n+\t  next = a_elt->next;\n+\t  a_prev = a_elt->prev;\n+\t  bitmap_element_free (a, a_elt);\n+\t  a_elt = next;\n+\t}\n+      else if (!a_elt || b_elt->indx < a_elt->indx)\n+\t{\n+\t  /* B is before A.  Copy B. */\n+\t  next = bitmap_elt_insert_after (a, a_prev, b_elt->indx);\n+\t  memcpy (next->bits, b_elt->bits, sizeof (next->bits));\n+\t  a_prev = next;\n+\t  b_elt = b_elt->next;\n+\t}\n+      else\n+\t{\n+\t  /* Matching elts, generate A = ~A & B.  */\n+\t  unsigned ix;\n+\t  BITMAP_WORD ior = 0;\n+\n+\t  for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n+\t    {\n+\t      BITMAP_WORD cleared = a_elt->bits[ix] & b_elt->bits[ix];\n+\t      BITMAP_WORD r = b_elt->bits[ix] ^ cleared;\n+\n+\t      a_elt->bits[ix] = r;\n+\t      ior |= r;\n+\t    }\n+\t  next = a_elt->next;\n+\t  if (!ior)\n+\t    bitmap_element_free (a, a_elt);\n+\t  else\n+\t    a_prev = a_elt;\n+\t  a_elt = next;\n+\t  b_elt = b_elt->next;\n+\t}\n+    }\n+  gcc_assert (!a->current == !a->first);\n+  gcc_assert (!a->current || a->indx == a->current->indx);\n+  return;\n+}\n+\n /* DST = A | B.  Return true if DST changes.  */\n \n bool\n@@ -833,8 +1081,9 @@ bitmap_ior (bitmap dst, bitmap a, bitmap b)\n \t    {\n \t      changed = true;\n \t      if (!dst_elt)\n-\t\tdst_elt = bitmap_elt_insert_after (dst, dst_prev);\n-\t      dst_elt->indx = a_elt->indx;\n+\t\tdst_elt = bitmap_elt_insert_after (dst, dst_prev, a_elt->indx);\n+\t      else \n+\t\tdst_elt->indx = a_elt->indx;\n \t      for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n \t\t{\n \t\t  BITMAP_WORD r = a_elt->bits[ix] | b_elt->bits[ix];\n@@ -878,8 +1127,9 @@ bitmap_ior (bitmap dst, bitmap a, bitmap b)\n \t    {\n \t      changed = true;\n \t      if (!dst_elt)\n-\t\tdst_elt = bitmap_elt_insert_after (dst, dst_prev);\n-\t      dst_elt->indx = src->indx;\n+\t\tdst_elt = bitmap_elt_insert_after (dst, dst_prev, src->indx);\n+\t      else \n+\t\tdst_elt->indx = src->indx;\n \t      memcpy (dst_elt->bits, src->bits, sizeof (dst_elt->bits));\n \t    }\n \t  \n@@ -917,9 +1167,7 @@ bitmap_ior_into (bitmap a, bitmap b)\n       if (!a_elt || b_elt->indx < a_elt->indx)\n \t{\n \t  /* Copy b_elt.  */\n-\t  bitmap_element *dst = bitmap_elt_insert_after (a, a_prev);\n-\t  \n-\t  dst->indx = b_elt->indx;\n+\t  bitmap_element *dst = bitmap_elt_insert_after (a, a_prev, b_elt->indx);\n \t  memcpy (dst->bits, b_elt->bits, sizeof (dst->bits));\n \t  a_prev = dst;\n \t  b_elt = b_elt->next;\n@@ -990,9 +1238,9 @@ bitmap_xor (bitmap dst, bitmap a, bitmap b)\n \t  BITMAP_WORD ior = 0;\n \n \t  if (!dst_elt)\n-\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev);\n-\t  \n-\t  dst_elt->indx = a_elt->indx;\n+\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev, a_elt->indx);\n+\t  else\n+\t    dst_elt->indx = a_elt->indx;\n \t  for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n \t    {\n \t      BITMAP_WORD r = a_elt->bits[ix] ^ b_elt->bits[ix];\n@@ -1025,9 +1273,9 @@ bitmap_xor (bitmap dst, bitmap a, bitmap b)\n \t    }\n \n \t  if (!dst_elt)\n-\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev);\n-\t  \n-\t  dst_elt->indx = src->indx;\n+\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev, src->indx);\n+\t  else \n+\t    dst_elt->indx = src->indx;\n \t  memcpy (dst_elt->bits, src->bits, sizeof (dst_elt->bits));\n \t  dst_prev = dst_elt;\n \t  dst_elt = dst_elt->next;\n@@ -1059,9 +1307,7 @@ bitmap_xor_into (bitmap a, bitmap b)\n       if (!a_elt || b_elt->indx < a_elt->indx)\n \t{\n \t  /* Copy b_elt.  */\n-\t  bitmap_element *dst = bitmap_elt_insert_after (a, a_prev);\n-\t  \n-\t  dst->indx = b_elt->indx;\n+\t  bitmap_element *dst = bitmap_elt_insert_after (a, a_prev, b_elt->indx);\n \t  memcpy (dst->bits, b_elt->bits, sizeof (dst->bits));\n \t  a_prev = dst;\n \t  b_elt = b_elt->next;"}, {"sha": "fb56e4e0db4a653bcbcb4b2d022952a051c3caea", "filename": "gcc/bitmap.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bc40c7e8ac62eafdef41e04276e9cab85488af7/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bc40c7e8ac62eafdef41e04276e9cab85488af7/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=1bc40c7e8ac62eafdef41e04276e9cab85488af7", "patch": "@@ -102,6 +102,9 @@ extern bool bitmap_intersect_compl_p (bitmap, bitmap);\n /* True if MAP is an empty bitmap.  */\n #define bitmap_empty_p(MAP) (!(MAP)->first)\n \n+/* Count the number of bits set in the bitmap.  */\n+extern unsigned long bitmap_count_bits (bitmap);\n+\n /* Boolean operations on bitmaps.  The _into variants are two operand\n    versions that modify the first source operand.  The other variants\n    are three operand versions that to not destroy the source bitmaps.\n@@ -110,6 +113,9 @@ extern void bitmap_and (bitmap, bitmap, bitmap);\n extern void bitmap_and_into (bitmap, bitmap);\n extern void bitmap_and_compl (bitmap, bitmap, bitmap);\n extern bool bitmap_and_compl_into (bitmap, bitmap);\n+#define bitmap_compl_and(DST, A, B) bitmap_and_compl (DST, B, A)\n+extern void bitmap_compl_and_into (bitmap, bitmap);\n+extern void bitmap_clear_range (bitmap, unsigned int, unsigned int);\n extern bool bitmap_ior (bitmap, bitmap, bitmap);\n extern bool bitmap_ior_into (bitmap, bitmap);\n extern void bitmap_xor (bitmap, bitmap, bitmap);"}]}