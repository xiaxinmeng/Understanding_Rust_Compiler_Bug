{"sha": "6d4ab5f8c77ecb6fcb2f1a4fae644100f436883d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ0YWI1ZjhjNzdlY2I2ZmNiMmYxYTRmYWU2NDQxMDBmNDM2ODgzZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-12-27T15:19:54Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-12-27T15:19:54Z"}, "message": "ipa-inline.c (max_count_real, [...]): Remove.\n\n\n\t* ipa-inline.c (max_count_real, max_relbenefit_real,\n\thalf_int_min_real): Remove.\n\t(cgraph_freq_base_rec, percent_rec): New.\n\t(compute_uninlined_call_time, compute_inlined_call_time,\n\tbig_speedup_p, relative_time_benefit, edge_badness): Use sreals.\n\t(update_edge_key): Update dumping.\n\t(inline_small_functions): Speedup maintainance of the heap.\n\t(ipa_inline): Initialize cgraph_freq_base_rec and\n\tpercent_rec.\n\nFrom-SVN: r219076", "tree": {"sha": "c8e202e2c1c2b61020aa38884b7d50c16c23c9b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8e202e2c1c2b61020aa38884b7d50c16c23c9b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d4ab5f8c77ecb6fcb2f1a4fae644100f436883d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d4ab5f8c77ecb6fcb2f1a4fae644100f436883d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d4ab5f8c77ecb6fcb2f1a4fae644100f436883d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d4ab5f8c77ecb6fcb2f1a4fae644100f436883d/comments", "author": null, "committer": null, "parents": [{"sha": "75e6bcac2f1f113dfbca7f1ae0460497835e2fae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75e6bcac2f1f113dfbca7f1ae0460497835e2fae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75e6bcac2f1f113dfbca7f1ae0460497835e2fae"}], "stats": {"total": 285, "additions": 146, "deletions": 139}, "files": [{"sha": "4d3bf5fb1465a46e29d9f99e4190d99763702e93", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d4ab5f8c77ecb6fcb2f1a4fae644100f436883d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d4ab5f8c77ecb6fcb2f1a4fae644100f436883d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d4ab5f8c77ecb6fcb2f1a4fae644100f436883d", "patch": "@@ -1,3 +1,15 @@\n+2014-12-27  Jan hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-inline.c (max_count_real, max_relbenefit_real,\n+\thalf_int_min_real): Remove.\n+\t(cgraph_freq_base_rec, percent_rec): New.\n+\t(compute_uninlined_call_time, compute_inlined_call_time,\n+\tbig_speedup_p, relative_time_benefit, edge_badness): Use sreals.\n+\t(update_edge_key): Update dumping.\n+\t(inline_small_functions): Speedup maintainance of the heap.\n+\t(ipa_inline): Initialize cgraph_freq_base_rec and\n+\tpercent_rec.\n+\n 2014-12-27  Jan hubicka  <hubicka@ucw.cz>\n \n \t* sreal.h (sreal::shift): Fix sanity check."}, {"sha": "d2bad5545806aa8f58573de292425bc853a8a117", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 134, "deletions": 139, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d4ab5f8c77ecb6fcb2f1a4fae644100f436883d/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d4ab5f8c77ecb6fcb2f1a4fae644100f436883d/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=6d4ab5f8c77ecb6fcb2f1a4fae644100f436883d", "patch": "@@ -146,9 +146,11 @@ typedef fibonacci_node <sreal, cgraph_edge> edge_heap_node_t;\n /* Statistics we collect about inlining algorithm.  */\n static int overall_size;\n static gcov_type max_count;\n-static sreal max_count_real, max_relbenefit_real, half_int_min_real;\n static gcov_type spec_rem;\n \n+/* Pre-computed constants 1/CGRAPH_FREQ_BASE and 1/100. */\n+static sreal cgraph_freq_base_rec, percent_rec;\n+\n /* Return false when inlining edge E would lead to violating\n    limits on function unit growth or stack usage growth.  \n \n@@ -518,37 +520,34 @@ want_early_inline_function_p (struct cgraph_edge *e)\n /* Compute time of the edge->caller + edge->callee execution when inlining\n    does not happen.  */\n \n-inline gcov_type\n+inline sreal\n compute_uninlined_call_time (struct inline_summary *callee_info,\n \t\t\t     struct cgraph_edge *edge)\n {\n-  gcov_type uninlined_call_time =\n-    RDIV ((gcov_type)callee_info->time * MAX (edge->frequency, 1),\n-\t  CGRAPH_FREQ_BASE);\n-  gcov_type caller_time = inline_summaries->get (edge->caller->global.inlined_to\n-\t\t\t\t          ? edge->caller->global.inlined_to\n-\t\t\t\t          : edge->caller)->time;\n+  sreal uninlined_call_time = (sreal)callee_info->time\n+\t\t\t      * MAX (edge->frequency, 1)\n+\t\t\t      * cgraph_freq_base_rec;\n+  int caller_time = inline_summaries->get (edge->caller->global.inlined_to\n+\t\t\t\t           ? edge->caller->global.inlined_to\n+\t\t\t\t           : edge->caller)->time;\n   return uninlined_call_time + caller_time;\n }\n \n /* Same as compute_uinlined_call_time but compute time when inlining\n    does happen.  */\n \n-inline gcov_type\n+inline sreal\n compute_inlined_call_time (struct cgraph_edge *edge,\n \t\t\t   int edge_time)\n {\n-  gcov_type caller_time = inline_summaries->get (edge->caller->global.inlined_to\n-\t\t\t\t\t  ? edge->caller->global.inlined_to\n-\t\t\t\t\t  : edge->caller)->time;\n-  gcov_type time = (caller_time\n-\t\t    + RDIV (((gcov_type) edge_time\n-\t\t\t     - inline_edge_summary (edge)->call_stmt_time)\n-\t\t    * MAX (edge->frequency, 1), CGRAPH_FREQ_BASE));\n-  /* Possible one roundoff error, but watch for overflows.  */\n-  gcc_checking_assert (time >= INT_MIN / 2);\n-  if (time < 0)\n-    time = 0;\n+  int caller_time = inline_summaries->get (edge->caller->global.inlined_to\n+\t\t\t\t           ? edge->caller->global.inlined_to\n+\t\t\t\t           : edge->caller)->time;\n+  sreal time = (sreal)caller_time\n+\t       + ((sreal) (edge_time - inline_edge_summary (edge)->call_stmt_time)\n+\t          * MAX (edge->frequency, 1)\n+\t          * cgraph_freq_base_rec);\n+  gcc_checking_assert (time >= 0);\n   return time;\n }\n \n@@ -558,12 +557,11 @@ compute_inlined_call_time (struct cgraph_edge *edge,\n static bool\n big_speedup_p (struct cgraph_edge *e)\n {\n-  gcov_type time = compute_uninlined_call_time (inline_summaries->get (e->callee),\n-\t\t\t\t\t  \te);\n-  gcov_type inlined_time = compute_inlined_call_time (e,\n-\t\t\t\t\t              estimate_edge_time (e));\n+  sreal time = compute_uninlined_call_time (inline_summaries->get (e->callee), e);\n+  sreal inlined_time = compute_inlined_call_time (e, estimate_edge_time (e));\n   if (time - inlined_time\n-      > RDIV (time * PARAM_VALUE (PARAM_INLINE_MIN_SPEEDUP), 100))\n+      > (sreal) time * PARAM_VALUE (PARAM_INLINE_MIN_SPEEDUP)\n+\t * percent_rec)\n     return true;\n   return false;\n }\n@@ -861,42 +859,45 @@ want_inline_function_to_all_callers_p (struct cgraph_node *node, bool cold)\n #define RELATIVE_TIME_BENEFIT_RANGE (INT_MAX / 64)\n \n /* Return relative time improvement for inlining EDGE in range\n-   1...RELATIVE_TIME_BENEFIT_RANGE  */\n+   as value NUMERATOR/DENOMINATOR.  */\n \n-static inline int\n+static inline void\n relative_time_benefit (struct inline_summary *callee_info,\n \t\t       struct cgraph_edge *edge,\n-\t\t       int edge_time)\n+\t\t       int edge_time,\n+\t\t       sreal *numerator,\n+\t\t       sreal *denominator)\n {\n-  gcov_type relbenefit;\n-  gcov_type uninlined_call_time = compute_uninlined_call_time (callee_info, edge);\n-  gcov_type inlined_call_time = compute_inlined_call_time (edge, edge_time);\n-\n   /* Inlining into extern inline function is not a win.  */\n   if (DECL_EXTERNAL (edge->caller->global.inlined_to\n \t\t     ? edge->caller->global.inlined_to->decl\n \t\t     : edge->caller->decl))\n-    return 1;\n+    {\n+      *numerator = (sreal) 1;\n+      *denominator = (sreal) 1024;\n+      return;\n+    }\n \n-  /* Watch overflows.  */\n-  gcc_checking_assert (uninlined_call_time >= 0);\n-  gcc_checking_assert (inlined_call_time >= 0);\n-  gcc_checking_assert (uninlined_call_time >= inlined_call_time);\n+  sreal uninlined_call_time = compute_uninlined_call_time (callee_info, edge);\n+  sreal inlined_call_time = compute_inlined_call_time (edge, edge_time);\n \n   /* Compute relative time benefit, i.e. how much the call becomes faster.\n      ??? perhaps computing how much the caller+calle together become faster\n      would lead to more realistic results.  */\n-  if (!uninlined_call_time)\n+  if (uninlined_call_time == (sreal) 0)\n     uninlined_call_time = 1;\n-  relbenefit =\n-    RDIV (((gcov_type)uninlined_call_time - inlined_call_time) * RELATIVE_TIME_BENEFIT_RANGE,\n-\t  uninlined_call_time);\n-  relbenefit = MIN (relbenefit, RELATIVE_TIME_BENEFIT_RANGE);\n-  gcc_checking_assert (relbenefit >= 0);\n-  relbenefit = MAX (relbenefit, 1);\n-  return relbenefit;\n-}\n \n+  /* Avoid zeros, these are not useful later in calculations.  */\n+  if (uninlined_call_time == inlined_call_time)\n+    *numerator = ((sreal) 1)>>8;\n+  else\n+    *numerator = uninlined_call_time - inlined_call_time;\n+  *denominator = uninlined_call_time;\n+#ifdef ENABLE_CHECKING\n+  gcc_checking_assert (*numerator >= 0);\n+  gcc_checking_assert (*denominator >= 0);\n+#endif\n+}\n \n /* A cost model driving the inlining heuristics in a way so the edges with\n    smallest badness are inlined first.  After each inlining is performed\n@@ -914,7 +915,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n   inline_hints hints;\n \n   if (DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n-    return INT_MIN;\n+    return sreal::min ();\n \n   growth = estimate_edge_growth (edge);\n   edge_time = estimate_edge_time (edge);\n@@ -942,56 +943,43 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n   /* Always prefer inlining saving code size.  */\n   if (growth <= 0)\n     {\n-      badness = INT_MIN / 2 + growth;\n+      badness = (sreal) (-SREAL_MIN_SIG + growth) << (SREAL_MAX_EXP / 256);\n       if (dump)\n-\tfprintf (dump_file, \"      %\"PRId64\": Growth %d <= 0\\n\", badness.to_int (),\n+\tfprintf (dump_file, \"      %f: Growth %d <= 0\\n\", badness.to_double (),\n \t\t growth);\n     }\n \n   /* When profiling is available, compute badness as:\n \n-\t        relative_edge_count * relative_time_benefit\n+\t        edge_count * relative_time_benefit\n      goodness = -------------------------------------------\n-\t\tgrowth_f_caller\n-     badness = -goodness  \n+\t\tgrowth_of_caller\n+     badness = - goodness \n \n     The fraction is upside down, because on edge counts and time beneits\n     the bounds are known. Edge growth is essentially unlimited.  */\n \n   else if (max_count)\n     {\n-      int relbenefit = relative_time_benefit (callee_info, edge, edge_time);\n-      /* Capping edge->count to max_count. edge->count can be larger than\n-\t max_count if an inline adds new edges which increase max_count\n-\t after max_count is computed.  */\n-      gcov_type edge_count = edge->count > max_count ? max_count : edge->count;\n-\n-      sreal relbenefit_real (relbenefit, 0);\n-      sreal growth_real (growth, 0);\n+      sreal numerator, denominator;\n+      relative_time_benefit (callee_info, edge, edge_time, &numerator,\n+\t\t\t     &denominator);\n \n-      /* relative_edge_count.  */\n-      sreal tmp (edge_count, 0);\n-      tmp /= max_count_real;\n+      if (edge->count)\n+        numerator *= edge->count;\n+      denominator *= growth;\n \n-      /* relative_time_benefit.  */\n-      tmp *= relbenefit_real;\n-      tmp /= max_relbenefit_real;\n-\n-      /* growth_f_caller.  */\n-      tmp *= half_int_min_real;\n-      tmp /=  growth_real;\n-\n-      badness = -1 * tmp.to_int ();\n+      badness = - numerator / denominator;\n  \n       if (dump)\n \t{\n+\t  sreal num,den;\n+          relative_time_benefit (callee_info, edge, edge_time, &num, &den);\n \t  fprintf (dump_file,\n-\t\t   \"      %\"PRId64\" (relative %f): profile info. Relative count %f%s\"\n-\t\t   \" * Relative benefit %f\\n\",\n-\t\t   badness.to_int (), (double) badness.to_int () / INT_MIN,\n-\t\t   (double) edge_count / max_count,\n-\t\t   edge->count > max_count ? \" (capped to max_count)\" : \"\",\n-\t\t   relbenefit * 100.0 / RELATIVE_TIME_BENEFIT_RANGE);\n+\t\t   \"      %f: profile info. count %\"PRId64\n+\t\t   \" * Relative benefit %f / growth %i\\n\",\n+\t\t   badness.to_double (), (int64_t)edge->count,\n+\t\t   (num / den * 100).to_double (), growth);\n \t}\n     }\n \n@@ -1009,36 +997,27 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n      and some not.  */\n   else if (flag_guess_branch_prob)\n     {\n-      badness = (relative_time_benefit (callee_info, edge, edge_time)\n-\t\t * (INT_MIN / 16 / RELATIVE_TIME_BENEFIT_RANGE));\n-      badness /= (MIN (65536/2, growth) * MIN (65536/2, MAX (1, callee_info->growth)));\n-      gcc_checking_assert (badness <=0 && badness >= INT_MIN / 16);\n-      if ((hints & (INLINE_HINT_indirect_call\n-\t\t    | INLINE_HINT_loop_iterations\n-\t            | INLINE_HINT_array_index\n-\t\t    | INLINE_HINT_loop_stride))\n-\t  || callee_info->growth <= 0)\n-\tbadness *= 8;\n-      if (hints & (INLINE_HINT_same_scc))\n-\tbadness /= 16;\n-      else if (hints & (INLINE_HINT_in_scc))\n-\tbadness /= 8;\n-      else if (hints & (INLINE_HINT_cross_module))\n-\tbadness /= 2;\n-      gcc_checking_assert (badness <= 0 && badness >= INT_MIN / 2);\n-      if ((hints & INLINE_HINT_declared_inline) && badness >= INT_MIN / 32)\n-\tbadness *= 16;\n+      sreal numerator, denominator;\n+      relative_time_benefit (callee_info, edge, edge_time, &numerator,\n+\t\t\t     &denominator);\n+      denominator *= growth;\n+      if (callee_info->growth > 0)\n+\tdenominator *= callee_info->growth;\n+\n+      badness = - numerator / denominator;\n+\n       if (dump)\n \t{\n+\t  sreal num,den;\n+          relative_time_benefit (callee_info, edge, edge_time, &num, &den);\n \t  fprintf (dump_file,\n-\t\t   \"      %\"PRId64\": guessed profile. frequency %f,\"\n-\t\t   \" benefit %f%%, time w/o inlining %i, time w inlining %i\"\n+\t\t   \"      %f: guessed profile. frequency %f,\"\n+\t\t   \" benefit %f%%, time w/o inlining %f, time w inlining %f\"\n \t\t   \" overall growth %i (current) %i (original)\\n\",\n-\t\t   badness.to_int (), (double)edge->frequency / CGRAPH_FREQ_BASE,\n-\t\t   relative_time_benefit (callee_info, edge, edge_time) * 100.0\n-\t\t   / RELATIVE_TIME_BENEFIT_RANGE, \n-\t\t   (int)compute_uninlined_call_time (callee_info, edge),\n-\t\t   (int)compute_inlined_call_time (edge, edge_time),\n+\t\t   badness.to_double (), (double)edge->frequency / CGRAPH_FREQ_BASE,\n+\t\t   (num/den).to_double () * 100, \n+\t\t   compute_uninlined_call_time (callee_info, edge).to_double (),\n+\t\t   compute_inlined_call_time (edge, edge_time).to_double (),\n \t\t   estimate_growth (callee),\n \t\t   callee_info->growth);\n \t}\n@@ -1050,28 +1029,38 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n   else\n     {\n       int nest = MIN (inline_edge_summary (edge)->loop_depth, 8);\n-      badness = growth * 256;\n+      badness = growth;\n \n       /* Decrease badness if call is nested.  */\n       if (badness > 0)\n \tbadness = badness >> nest;\n       else\n-\t{\n-\t  badness = badness << nest;\n-\t}\n+\tbadness = badness << nest;\n       if (dump)\n-\tfprintf (dump_file, \"      %\"PRId64\": no profile. nest %i\\n\", badness.to_int (),\n+\tfprintf (dump_file, \"      %f: no profile. nest %i\\n\", badness.to_double (),\n \t\t nest);\n     }\n+  gcc_checking_assert (badness != 0);\n \n-  /* Ensure that we did not overflow in all the fixed point math above.  */\n-  gcc_assert (badness >= INT_MIN);\n-  gcc_assert (badness <= INT_MAX - 1);\n-  /* Make recursive inlining happen always after other inlining is done.  */\n   if (edge->recursive_p ())\n-    return badness + 1;\n-  else\n-    return badness;\n+    badness = badness.shift (badness > 0 ? 4 : -4);\n+  if ((hints & (INLINE_HINT_indirect_call\n+\t\t| INLINE_HINT_loop_iterations\n+\t\t| INLINE_HINT_array_index\n+\t\t| INLINE_HINT_loop_stride))\n+      || callee_info->growth <= 0)\n+    badness = badness.shift (badness > 0 ? -2 : 2);\n+  if (hints & (INLINE_HINT_same_scc))\n+    badness = badness.shift (badness > 0 ? 3 : -3);\n+  else if (hints & (INLINE_HINT_in_scc))\n+    badness = badness.shift (badness > 0 ? 2 : -2);\n+  else if (hints & (INLINE_HINT_cross_module))\n+    badness = badness.shift (badness > 0 ? 1 : -1);\n+  if ((hints & INLINE_HINT_declared_inline))\n+    badness = badness.shift (badness > 0 ? -3 : 3);\n+  if (dump)\n+    fprintf (dump_file, \"      Adjusted by hints %f\\n\", badness.to_double ());\n+  return badness;\n }\n \n /* Recompute badness of EDGE and update its key in HEAP if needed.  */\n@@ -1084,39 +1073,39 @@ update_edge_key (edge_heap_t *heap, struct cgraph_edge *edge)\n       edge_heap_node_t *n = (edge_heap_node_t *) edge->aux;\n       gcc_checking_assert (n->get_data () == edge);\n \n-      /* fibonacci_heap::replace_key only decrease the keys.\n-\t When we increase the key we do not update heap\n-\t and instead re-insert the element once it becomes\n-\t a minimum of heap.  */\n+      /* fibonacci_heap::replace_key does busy updating of the\n+\t heap that is unnecesarily expensive.\n+\t We do lazy increases: after extracting minimum if the key\n+\t turns out to be out of date, it is re-inserted into heap\n+\t with correct value.  */\n       if (badness < n->get_key ())\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n \t      fprintf (dump_file,\n-\t\t       \"  decreasing badness %s/%i -> %s/%i, %\"PRId64\n-\t\t       \" to %\"PRId64\"\\n\",\n+\t\t       \"  decreasing badness %s/%i -> %s/%i, %f\"\n+\t\t       \" to %f\\n\",\n \t\t       xstrdup_for_dump (edge->caller->name ()),\n \t\t       edge->caller->order,\n \t\t       xstrdup_for_dump (edge->callee->name ()),\n \t\t       edge->callee->order,\n-\t\t       n->get_key ().to_int (),\n-\t\t       badness.to_int ());\n+\t\t       n->get_key ().to_double (),\n+\t\t       badness.to_double ());\n \t    }\n \t  heap->decrease_key (n, badness);\n-\t  gcc_checking_assert (n->get_key () == badness);\n \t}\n     }\n   else\n     {\n        if (dump_file && (dump_flags & TDF_DETAILS))\n \t {\n \t   fprintf (dump_file,\n-\t\t    \"  enqueuing call %s/%i -> %s/%i, badness %\"PRId64\"\\n\",\n+\t\t    \"  enqueuing call %s/%i -> %s/%i, badness %f\\n\",\n \t\t    xstrdup_for_dump (edge->caller->name ()),\n \t\t    edge->caller->order,\n \t\t    xstrdup_for_dump (edge->callee->name ()),\n \t\t    edge->callee->order,\n-\t\t    badness.to_int ());\n+\t\t    badness.to_double ());\n \t }\n       edge->aux = heap->insert (badness, edge);\n     }\n@@ -1619,9 +1608,6 @@ inline_small_functions (void)\n \t  if (max_count < edge->count)\n \t    max_count = edge->count;\n       }\n-  max_count_real = sreal (max_count, 0);\n-  max_relbenefit_real = sreal (RELATIVE_TIME_BENEFIT_RANGE, 0);\n-  half_int_min_real = sreal (INT_MAX / 2, 0);\n   ipa_free_postorder_info ();\n   initialize_growth_caches ();\n \n@@ -1686,7 +1672,6 @@ inline_small_functions (void)\n       struct cgraph_node *where, *callee;\n       sreal badness = edge_heap.min_key ();\n       sreal current_badness;\n-      sreal cached_badness;\n       int growth;\n \n       edge = edge_heap.extract_min ();\n@@ -1695,10 +1680,9 @@ inline_small_functions (void)\n       if (!edge->inline_failed || !edge->callee->analyzed)\n \tcontinue;\n \n-      /* Be sure that caches are maintained consistent.  \n-         We can not make this ENABLE_CHECKING only because it cause different\n-         updates of the fibheap queue.  */\n-      cached_badness = edge_badness (edge, false);\n+#ifdef ENABLE_CHECKING\n+      /* Be sure that caches are maintained consistent.  */\n+      sreal cached_badness = edge_badness (edge, false);\n       reset_edge_growth_cache (edge);\n       reset_node_growth_cache (edge->callee);\n \n@@ -1708,10 +1692,18 @@ inline_small_functions (void)\n       current_badness = edge_badness (edge, false);\n       gcc_assert (cached_badness == current_badness);\n       gcc_assert (current_badness >= badness);\n+#else\n+      current_badness = edge_badness (edge, false);\n+#endif\n       if (current_badness != badness)\n \t{\n-\t  edge->aux = edge_heap.insert (current_badness, edge);\n-\t  continue;\n+\t  if (edge_heap.min () && badness > edge_heap.min_key ())\n+\t    {\n+\t      edge->aux = edge_heap.insert (current_badness, edge);\n+\t      continue;\n+\t    }\n+\t  else\n+\t    badness = current_badness;\n \t}\n \n       if (!can_inline_edge_p (edge, true))\n@@ -1730,13 +1722,13 @@ inline_small_functions (void)\n \t\t   inline_summaries->get (callee)->size);\n \t  fprintf (dump_file,\n \t\t   \" to be inlined into %s/%i in %s:%i\\n\"\n-\t\t   \" Estimated badness is %\"PRId64\", frequency %.2f.\\n\",\n+\t\t   \" Estimated badness is %f, frequency %.2f.\\n\",\n \t\t   edge->caller->name (), edge->caller->order,\n \t\t   edge->call_stmt ? \"unknown\"\n \t\t   : gimple_filename ((const_gimple) edge->call_stmt),\n \t\t   edge->call_stmt ? -1\n \t\t   : gimple_lineno ((const_gimple) edge->call_stmt),\n-\t\t   badness.to_int (),\n+\t\t   badness.to_double (),\n \t\t   edge->frequency / (double)CGRAPH_FREQ_BASE);\n \t  if (edge->count)\n \t    fprintf (dump_file,\" Called %\"PRId64\"x\\n\",\n@@ -2148,6 +2140,9 @@ ipa_inline (void)\n   if (!optimize)\n     return 0;\n \n+  cgraph_freq_base_rec = (sreal) 1 / (sreal) CGRAPH_FREQ_BASE;\n+  percent_rec = (sreal) 1 / (sreal) 100;\n+\n   order = XCNEWVEC (struct cgraph_node *, symtab->cgraph_count);\n \n   if (in_lto_p && optimize)"}]}