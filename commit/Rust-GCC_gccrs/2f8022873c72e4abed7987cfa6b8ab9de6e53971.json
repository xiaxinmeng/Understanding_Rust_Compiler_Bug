{"sha": "2f8022873c72e4abed7987cfa6b8ab9de6e53971", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY4MDIyODczYzcyZTRhYmVkNzk4N2NmYTZiOGFiOWRlNmU1Mzk3MQ==", "commit": {"author": {"name": "Jozef Lawrynowicz", "email": "jozef.l@mittosystems.com", "date": "2020-09-18T12:07:19Z"}, "committer": {"name": "Jozef Lawrynowicz", "email": "jozef.l@mittosystems.com", "date": "2020-09-18T12:07:19Z"}, "message": "MSP430: Add 'd', 'e', 'f' and 'g' asm operand modifiers\n\nThe new operand modifiers can be used to select odd-numbered bytes of a memory\nreference or constant value.\n\ngcc/ChangeLog:\n\n\t* config/msp430/msp430.c (msp430_print_operand): Update comment.\n\tCast to long when printing values formatted as long.\n\tSupport 'd', 'e', 'f' and 'g' modifiers.\n\tExtract operand value with a single operation for all modifiers.\n\t* doc/extend.texi (msp430Operandmodifiers): New.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/msp430/operand-modifiers.c: Extend test to handle new\n\tmodifiers.\n\t* gcc.target/msp430/operand-modifiers-bad.c: New test.", "tree": {"sha": "d8d955b484d5374c48c0c9b900c6bd1e5dab1b90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8d955b484d5374c48c0c9b900c6bd1e5dab1b90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f8022873c72e4abed7987cfa6b8ab9de6e53971", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f8022873c72e4abed7987cfa6b8ab9de6e53971", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f8022873c72e4abed7987cfa6b8ab9de6e53971", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f8022873c72e4abed7987cfa6b8ab9de6e53971/comments", "author": {"login": "jozefl-mitto", "id": 36524004, "node_id": "MDQ6VXNlcjM2NTI0MDA0", "avatar_url": "https://avatars.githubusercontent.com/u/36524004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jozefl-mitto", "html_url": "https://github.com/jozefl-mitto", "followers_url": "https://api.github.com/users/jozefl-mitto/followers", "following_url": "https://api.github.com/users/jozefl-mitto/following{/other_user}", "gists_url": "https://api.github.com/users/jozefl-mitto/gists{/gist_id}", "starred_url": "https://api.github.com/users/jozefl-mitto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jozefl-mitto/subscriptions", "organizations_url": "https://api.github.com/users/jozefl-mitto/orgs", "repos_url": "https://api.github.com/users/jozefl-mitto/repos", "events_url": "https://api.github.com/users/jozefl-mitto/events{/privacy}", "received_events_url": "https://api.github.com/users/jozefl-mitto/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jozefl-mitto", "id": 36524004, "node_id": "MDQ6VXNlcjM2NTI0MDA0", "avatar_url": "https://avatars.githubusercontent.com/u/36524004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jozefl-mitto", "html_url": "https://github.com/jozefl-mitto", "followers_url": "https://api.github.com/users/jozefl-mitto/followers", "following_url": "https://api.github.com/users/jozefl-mitto/following{/other_user}", "gists_url": "https://api.github.com/users/jozefl-mitto/gists{/gist_id}", "starred_url": "https://api.github.com/users/jozefl-mitto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jozefl-mitto/subscriptions", "organizations_url": "https://api.github.com/users/jozefl-mitto/orgs", "repos_url": "https://api.github.com/users/jozefl-mitto/repos", "events_url": "https://api.github.com/users/jozefl-mitto/events{/privacy}", "received_events_url": "https://api.github.com/users/jozefl-mitto/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "685c95ebc4906f6b58db2e3c81ad9ab73fdca794", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/685c95ebc4906f6b58db2e3c81ad9ab73fdca794", "html_url": "https://github.com/Rust-GCC/gccrs/commit/685c95ebc4906f6b58db2e3c81ad9ab73fdca794"}], "stats": {"total": 370, "additions": 277, "deletions": 93}, "files": [{"sha": "de4b16bf23bc3ac72259f81751c3d9de7dbc65c4", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 80, "deletions": 72, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8022873c72e4abed7987cfa6b8ab9de6e53971/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8022873c72e4abed7987cfa6b8ab9de6e53971/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=2f8022873c72e4abed7987cfa6b8ab9de6e53971", "patch": "@@ -3521,48 +3521,61 @@ msp430_op_not_in_high_mem (rtx op)\n #undef  TARGET_PRINT_OPERAND\n #define TARGET_PRINT_OPERAND\t\tmsp430_print_operand\n \n-/* A   low 16-bits of int/lower of register pair\n-   B   high 16-bits of int/higher of register pair\n-   C   bits 32-47 of a 64-bit value/reg 3 of a DImode value\n-   D   bits 48-63 of a 64-bit value/reg 4 of a DImode value\n-   H   like %B (for backwards compatibility)\n-   I   inverse of value\n-   J   an integer without a # prefix\n-   L   like %A (for backwards compatibility)\n-   O   offset of the top of the stack\n-   Q   like X but generates an A postfix\n-   R   inverse of condition code, unsigned.\n-   W   value - 16\n-   X   X instruction postfix in large mode\n-   Y   value - 4\n-   Z   value - 1\n-   b   .B or .W or .A, depending upon the mode\n-   p   bit position\n-   r   inverse of condition code\n-   x   like X but only for pointers.  */\n+/* A   Select low 16-bits of the constant/register/memory operand.\n+   B   Select high 16-bits of the constant/register/memory\n+       operand.\n+   C   Select bits 32-47 of the constant/register/memory operand.\n+   D   Select bits 48-63 of the constant/register/memory operand.\n+   H   Equivalent to @code{B} (for backwards compatibility).\n+   I   Print the inverse (logical @code{NOT}) of the constant\n+       value.\n+   J   Print an integer without a @code{#} prefix.\n+   L   Equivalent to @code{A} (for backwards compatibility).\n+   O   Offset of the current frame from the top of the stack.\n+   Q   Use the @code{A} instruction postfix.\n+   R   Inverse of condition code, for unsigned comparisons.\n+   W   Subtract 16 from the constant value.\n+   X   Use the @code{X} instruction postfix.\n+   Y   Subtract 4 from the constant value.\n+   Z   Subtract 1 from the constant value.\n+   b   Append @code{.B}, @code{.W} or @code{.A} to the\n+       instruction, depending on the mode.\n+   d   Offset 1 byte of a memory reference or constant value.\n+   e   Offset 3 bytes of a memory reference or constant value.\n+   f   Offset 5 bytes of a memory reference or constant value.\n+   g   Offset 7 bytes of a memory reference or constant value.\n+   p   Print the value of 2, raised to the power of the given\n+       constant.  Used to select the specified bit position.\n+   r   Inverse of condition code, for signed comparisons.\n+   x   Equivialent to @code{X}, but only for pointers.  */\n \n static void\n msp430_print_operand (FILE * file, rtx op, int letter)\n {\n   rtx addr;\n+  /* These are used by the 'A', 'B', 'C', 'D', 'd', 'e', 'f' and 'g' modifiers\n+     to describe how to process the operand to get the requested value.  */\n+  int mem_off = 0;\n+  int reg_off = 0;\n+  int const_shift = 0;\n \n   /* We can't use c, n, a, or l.  */\n   switch (letter)\n     {\n     case 'Z':\n       gcc_assert (CONST_INT_P (op));\n       /* Print the constant value, less one.  */\n-      fprintf (file, \"#%ld\", INTVAL (op) - 1);\n+      fprintf (file, \"#%ld\", (long) (INTVAL (op) - 1));\n       return;\n     case 'Y':\n       gcc_assert (CONST_INT_P (op));\n       /* Print the constant value, less four.  */\n-      fprintf (file, \"#%ld\", INTVAL (op) - 4);\n+      fprintf (file, \"#%ld\", (long) (INTVAL (op) - 4));\n       return;\n     case 'W':\n       gcc_assert (CONST_INT_P (op));\n       /* Print the constant value, less 16.  */\n-      fprintf (file, \"#%ld\", INTVAL (op) - 16);\n+      fprintf (file, \"#%ld\", (long) (INTVAL (op) - 16));\n       return;\n     case 'I':\n       if (GET_CODE (op) == CONST_INT)\n@@ -3619,76 +3632,71 @@ msp430_print_operand (FILE * file, rtx op, int letter)\n \tdefault:\n \t  return;\n \t}\n-    case 'A':\n-    case 'L': /* Low half.  */\n-      switch (GET_CODE (op))\n+    case 'd': case 'e': case 'f': case 'g':\n+      if (REG_P (op))\n \t{\n-\tcase MEM:\n-\t  op = adjust_address (op, Pmode, 0);\n-\t  break;\n-\tcase REG:\n-\t  break;\n-\tcase CONST_INT:\n-\t  op = GEN_INT (INTVAL (op) & 0xffff);\n-\t  letter = 0;\n-\t  break;\n-\tdefault:\n-\t  /* If you get here, figure out a test case :-) */\n-\t  gcc_unreachable ();\n+\t  output_operand_lossage (\"%%d, %%e, %%f, %%g operand modifiers are \"\n+\t\t\t\t  \"for memory references or constant values \"\n+\t\t\t\t  \"only\");\n+\t  return;\n \t}\n-      break;\n-    case 'B':\n-    case 'H': /* high half */\n-      switch (GET_CODE (op))\n+      /* fallthru */\n+    case 'B': case 'H': /* high half */\n+    case 'C':\n+    case 'D':\n+      switch (letter)\n \t{\n-\tcase MEM:\n-\t  /* We don't need to adjust the address for post_inc.  */\n-\t  op = adjust_address (op, Pmode,\n-\t\t\t       (GET_CODE (XEXP (op, 0)) == POST_INC) ? 0 : 2);\n+\tcase 'd':\n+\t  mem_off = 1;\n+\t  const_shift = 8;\n \t  break;\n-\tcase REG:\n-\t  op = gen_rtx_REG (Pmode, REGNO (op) + 1);\n+\tcase 'B':\n+\tcase 'H':\n+\t  mem_off = 2;\n+\t  reg_off = 1;\n+\t  const_shift = 16;\n \t  break;\n-\tcase CONST_INT:\n-\t  op = GEN_INT (INTVAL (op) >> 16);\n-\t  letter = 0;\n+\tcase 'e':\n+\t  mem_off = 3;\n+\t  const_shift = 24;\n \t  break;\n-\tdefault:\n-\t  /* If you get here, figure out a test case :-) */\n-\t  gcc_unreachable ();\n-\t}\n-      break;\n-    case 'C':\n-      switch (GET_CODE (op))\n-\t{\n-\tcase MEM:\n-\t  op = adjust_address (op, Pmode,\n-\t\t\t       (GET_CODE (XEXP (op, 0)) == POST_INC) ? 0 : 4);\n+\tcase 'C':\n+\t  mem_off = 4;\n+\t  reg_off = 2;\n+\t  const_shift = 32;\n \t  break;\n-\tcase REG:\n-\t  op = gen_rtx_REG (Pmode, REGNO (op) + 2);\n+\tcase 'f':\n+\t  mem_off = 5;\n+\t  const_shift = 40;\n \t  break;\n-\tcase CONST_INT:\n-\t  op = GEN_INT ((long long) INTVAL (op) >> 32);\n-\t  letter = 0;\n+\tcase 'D':\n+\t  mem_off = 6;\n+\t  reg_off = 3;\n+\t  const_shift = 48;\n+\t  break;\n+\tcase 'g':\n+\t  mem_off = 7;\n+\t  const_shift = 56;\n \t  break;\n \tdefault:\n-\t  /* If you get here, figure out a test case :-) */\n \t  gcc_unreachable ();\n+\t  break;\n \t}\n-      break;\n-    case 'D':\n+      /* fallthru */\n+    case 'A': case 'L': /* Low half.  */\n       switch (GET_CODE (op))\n \t{\n \tcase MEM:\n+\t  /* We don't need to adjust the address for post_inc.  */\n \t  op = adjust_address (op, Pmode,\n-\t\t\t       (GET_CODE (XEXP (op, 0)) == POST_INC) ? 0 : 6);\n+\t\t\t       (GET_CODE (XEXP (op, 0)) == POST_INC)\n+\t\t\t       ? 0 : mem_off);\n \t  break;\n \tcase REG:\n-\t  op = gen_rtx_REG (Pmode, REGNO (op) + 3);\n+\t  op = gen_rtx_REG (Pmode, REGNO (op) + reg_off);\n \t  break;\n \tcase CONST_INT:\n-\t  op = GEN_INT ((long long) INTVAL (op) >> 48);\n+\t  op = GEN_INT (((long long) INTVAL (op) >> const_shift) & 0xffff);\n \t  letter = 0;\n \t  break;\n \tdefault:"}, {"sha": "5571c4f2ff2d23f7bee03ffec2ba19d15f5b8c03", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8022873c72e4abed7987cfa6b8ab9de6e53971/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8022873c72e4abed7987cfa6b8ab9de6e53971/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=2f8022873c72e4abed7987cfa6b8ab9de6e53971", "patch": "@@ -10737,6 +10737,42 @@ for the compiler to know that @code{fyl2xp1} pops both inputs.\n asm (\"fyl2xp1\" : \"=t\" (result) : \"0\" (x), \"u\" (y) : \"st(1)\");\n @end smallexample\n \n+@anchor{msp430Operandmodifiers}\n+@subsubsection MSP430 Operand Modifiers\n+\n+The list below describes the supported modifiers and their effects for MSP430.\n+\n+@multitable @columnfractions .10 .90\n+@headitem Modifier @tab Description\n+@item @code{A} @tab Select low 16-bits of the constant/register/memory operand.\n+@item @code{B} @tab Select high 16-bits of the constant/register/memory\n+operand.\n+@item @code{C} @tab Select bits 32-47 of the constant/register/memory operand.\n+@item @code{D} @tab Select bits 48-63 of the constant/register/memory operand.\n+@item @code{H} @tab Equivalent to @code{B} (for backwards compatibility).\n+@item @code{I} @tab Print the inverse (logical @code{NOT}) of the constant\n+value.\n+@item @code{J} @tab Print an integer without a @code{#} prefix.\n+@item @code{L} @tab Equivalent to @code{A} (for backwards compatibility).\n+@item @code{O} @tab Offset of the current frame from the top of the stack.\n+@item @code{Q} @tab Use the @code{A} instruction postfix.\n+@item @code{R} @tab Inverse of condition code, for unsigned comparisons.\n+@item @code{W} @tab Subtract 16 from the constant value.\n+@item @code{X} @tab Use the @code{X} instruction postfix.\n+@item @code{Y} @tab Subtract 4 from the constant value.\n+@item @code{Z} @tab Subtract 1 from the constant value.\n+@item @code{b} @tab Append @code{.B}, @code{.W} or @code{.A} to the\n+instruction, depending on the mode.\n+@item @code{d} @tab Offset 1 byte of a memory reference or constant value.\n+@item @code{e} @tab Offset 3 bytes of a memory reference or constant value.\n+@item @code{f} @tab Offset 5 bytes of a memory reference or constant value.\n+@item @code{g} @tab Offset 7 bytes of a memory reference or constant value.\n+@item @code{p} @tab Print the value of 2, raised to the power of the given\n+constant.  Used to select the specified bit position.\n+@item @code{r} @tab Inverse of condition code, for signed comparisons.\n+@item @code{x} @tab Equivialent to @code{X}, but only for pointers.\n+@end multitable\n+\n @lowersections\n @include md.texi\n @raisesections"}, {"sha": "3ff479313292feea89f1cfe063ff4a63b91f36c4", "filename": "gcc/testsuite/gcc.target/msp430/operand-modifiers-bad.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8022873c72e4abed7987cfa6b8ab9de6e53971/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Foperand-modifiers-bad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8022873c72e4abed7987cfa6b8ab9de6e53971/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Foperand-modifiers-bad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Foperand-modifiers-bad.c?ref=2f8022873c72e4abed7987cfa6b8ab9de6e53971", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+\n+void\n+foo (void)\n+{\n+  char reg = 10;\n+  __asm__ (\"mov.b %d1, %0\\n\" : \"=r\" (reg) : \"r\" (reg));\n+  /* { dg-error \"invalid 'asm': %d, %e, %f, %g operand modifiers are for memory references or constant values only\" \"\" { target *-*-* } .-1 } */\n+  __asm__ (\"mov.b %e1, %0\\n\" : \"=r\" (reg) : \"r\" (reg));\n+  /* { dg-error \"invalid 'asm': %d, %e, %f, %g operand modifiers are for memory references or constant values only\" \"\" { target *-*-* } .-1 } */\n+  __asm__ (\"mov.b %f1, %0\\n\" : \"=r\" (reg) : \"r\" (reg));\n+  /* { dg-error \"invalid 'asm': %d, %e, %f, %g operand modifiers are for memory references or constant values only\" \"\" { target *-*-* } .-1 } */\n+  __asm__ (\"mov.b %g1, %0\\n\" : \"=r\" (reg) : \"r\" (reg));\n+  /* { dg-error \"invalid 'asm': %d, %e, %f, %g operand modifiers are for memory references or constant values only\" \"\" { target *-*-* } .-1 } */\n+}"}, {"sha": "76e453df2c93aeb5de4ff195b4987e491e3eb13e", "filename": "gcc/testsuite/gcc.target/msp430/operand-modifiers.c", "status": "modified", "additions": 146, "deletions": 21, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8022873c72e4abed7987cfa6b8ab9de6e53971/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Foperand-modifiers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8022873c72e4abed7987cfa6b8ab9de6e53971/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Foperand-modifiers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Foperand-modifiers.c?ref=2f8022873c72e4abed7987cfa6b8ab9de6e53971", "patch": "@@ -1,30 +1,155 @@\n-volatile unsigned long si = 0x89abcdef;\n-volatile unsigned long long di = 0xfedcba9876543210;\n+/* { dg-do run } */\n \n-unsigned int a, b, c, d;\n+#include <stdio.h>\n+\n+/* Test A/L, B/H, C, D, d, e, f, g operand modifiers on 32-bit, 64-bit and,\n+   where appropriate, 16-bit values.  */\n+\n+#define MEM16_VAL 0x2345\n+#define MEM32_VAL 0x89abcdef\n+#define MEM64_VAL 0xfedcba9876543210\n+\n+#define CONST16_VAL 0xbcde\n+#define CONST32_VAL 0x99aabbcc\n+#define CONST64_VAL 0x8899aabbccddeeff\n+\n+#define REG32_VAL 0x12345678\n+#define REG64_VAL 0x123456789abcdef\n+\n+volatile unsigned long mem16 = MEM16_VAL;\n+volatile unsigned long mem32 = MEM32_VAL;\n+volatile unsigned long long mem64 = MEM64_VAL;\n+\n+unsigned int word0, word1, word2, word3;\n+unsigned char byte0, byte1, byte2, byte3, byte4, byte5, byte6, byte7;\n+\n+#define CHECK_BYTES_IN_16BIT_VAL(VAL)\t\t\\\n+  if (byte0 != ((unsigned char)VAL)\t\t\t\\\n+      || byte1 != ((unsigned char)(VAL >> 8)))\t\\\n+    return 1;\n+\n+#define CHECK_WORDS_IN_32BIT_VAL(VAL)\t\t\\\n+  if (word0 != ((unsigned)VAL)\t\t\t\\\n+      || word1 != ((unsigned)(VAL >> 16)))\t\\\n+    return 1;\n+\n+#define CHECK_WORDS_IN_64BIT_VAL(VAL)\t\t\\\n+  if (word0 != ((unsigned)VAL)\t\t\\\n+      || word1 != ((unsigned)(VAL >> 16))\t\\\n+      || word2 != ((unsigned)(VAL >> 32))\t\\\n+      || word3 != ((unsigned)(VAL >> 48)))\t\\\n+    return 1;\n+\n+#define CHECK_BYTES_IN_32BIT_VAL(VAL)\t\t\\\n+  if (byte0 != ((unsigned char)VAL)\t\t\\\n+      || byte1 != ((unsigned char)(VAL >> 8))\t\\\n+      || byte2 != ((unsigned char)(VAL >> 16))\t\\\n+      || byte3 != ((unsigned char)(VAL >> 24)))\t\\\n+    return 1;\n+\n+#define CHECK_BYTES_IN_64BIT_VAL(VAL)\t\t\\\n+  if (byte0 != ((unsigned char)VAL)\t\t\\\n+      || byte1 != ((unsigned char)(VAL >> 8))\t\\\n+      || byte2 != ((unsigned char)(VAL >> 16))\t\\\n+      || byte3 != ((unsigned char)(VAL >> 24))\t\\\n+      || byte4 != ((unsigned char)(VAL >> 32))\t\\\n+      || byte5 != ((unsigned char)(VAL >> 40))\t\\\n+      || byte6 != ((unsigned char)(VAL >> 48))\t\\\n+      || byte7 != ((unsigned char)(VAL >> 56)))\t\\\n+    return 1;\n \n int\n main (void)\n {\n-  /* Check that %A and %B extract the low and high words of a 32-bit value,\n-     respectively.  */\n-  __asm__(\"mov %A1, %0\\n\" : \"=m\" (a) : \"m\" (si));\n-  __asm__(\"mov %B1, %0\\n\" : \"=m\" (b) : \"m\" (si));\n-  if (a != ((unsigned)si)\n-      || b != ((unsigned)(si >> 16)))\n-    return 1;\n+  unsigned long register reg32 = REG32_VAL;\n+  unsigned long long register reg64 = REG64_VAL;\n \n-  /* Check that %A, %B, %C and %D extract the 1st, 2nd, 3rd and 4th words of a\n-     64-bit value, respectively.  */\n-  __asm__(\"mov %A1, %0\\n\" : \"=m\" (a) : \"m\" (di));\n-  __asm__(\"mov %B1, %0\\n\" : \"=m\" (b) : \"m\" (di));\n-  __asm__(\"mov %C1, %0\\n\" : \"=m\" (c) : \"m\" (di));\n-  __asm__(\"mov %D1, %0\\n\" : \"=m\" (d) : \"m\" (di));\n-  if (a != ((unsigned)di)\n-      || b != ((unsigned)(di >> 16))\n-      || c != ((unsigned)(di >> 32))\n-      || d != ((unsigned)(di >> 48)))\n-    return 1;\n+  /* *** MEMORY OPERAND TESTS *** */\n+  /* Test byte extraction of a 16-bit value.  */\n+  __asm__(\"mov.b %A1, %0\\n\" : \"=m\" (byte0) : \"m\" (mem16));\n+  __asm__(\"mov.b %d1, %0\\n\" : \"=m\" (byte1) : \"m\" (mem16));\n+  CHECK_BYTES_IN_16BIT_VAL (MEM16_VAL);\n+\n+  /* Test extraction of high and low words from 32-bit value.  */\n+  __asm__(\"mov %A1, %0\\n\" : \"=m\" (word0) : \"m\" (mem32));\n+  __asm__(\"mov %B1, %0\\n\" : \"=m\" (word1) : \"m\" (mem32));\n+  CHECK_WORDS_IN_32BIT_VAL (MEM32_VAL);\n+\n+  /* Test extraction of each word of a 64-bit value.  */\n+  __asm__(\"mov %A1, %0\\n\" : \"=m\" (word0) : \"m\" (mem64));\n+  __asm__(\"mov %B1, %0\\n\" : \"=m\" (word1) : \"m\" (mem64));\n+  __asm__(\"mov %C1, %0\\n\" : \"=m\" (word2) : \"m\" (mem64));\n+  __asm__(\"mov %D1, %0\\n\" : \"=m\" (word3) : \"m\" (mem64));\n+  CHECK_WORDS_IN_64BIT_VAL (MEM64_VAL);\n+\n+  /* Test extraction of each byte of a 32-bit value.  */\n+  __asm__(\"mov.b %A1, %0\\n\" : \"=m\" (byte0) : \"m\" (mem32));\n+  __asm__(\"mov.b %d1, %0\\n\" : \"=m\" (byte1) : \"m\" (mem32));\n+  __asm__(\"mov.b %B1, %0\\n\" : \"=m\" (byte2) : \"m\" (mem32));\n+  __asm__(\"mov.b %e1, %0\\n\" : \"=m\" (byte3) : \"m\" (mem32));\n+  CHECK_BYTES_IN_32BIT_VAL (MEM32_VAL);\n+\n+  /* Test extraction of each byte of a 64-bit value.  */\n+  __asm__(\"mov.b %A1, %0\\n\" : \"=m\" (byte0) : \"m\" (mem64));\n+  __asm__(\"mov.b %d1, %0\\n\" : \"=m\" (byte1) : \"m\" (mem64));\n+  __asm__(\"mov.b %B1, %0\\n\" : \"=m\" (byte2) : \"m\" (mem64));\n+  __asm__(\"mov.b %e1, %0\\n\" : \"=m\" (byte3) : \"m\" (mem64));\n+  __asm__(\"mov.b %C1, %0\\n\" : \"=m\" (byte4) : \"m\" (mem64));\n+  __asm__(\"mov.b %f1, %0\\n\" : \"=m\" (byte5) : \"m\" (mem64));\n+  __asm__(\"mov.b %D1, %0\\n\" : \"=m\" (byte6) : \"m\" (mem64));\n+  __asm__(\"mov.b %g1, %0\\n\" : \"=m\" (byte7) : \"m\" (mem64));\n+  CHECK_BYTES_IN_64BIT_VAL (MEM64_VAL);\n+\n+  /* *** IMMEDIATE OPERAND TESTS *** */\n+  /* Test byte extraction of a 16-bit value.  */\n+  __asm__(\"mov.b %A1, %0\\n\" : \"=m\" (byte0) : \"i\" (CONST16_VAL));\n+  __asm__(\"mov.b %d1, %0\\n\" : \"=m\" (byte1) : \"i\" (CONST16_VAL));\n+  CHECK_BYTES_IN_16BIT_VAL (CONST16_VAL);\n+\n+  /* Test extraction of high and low words from 32-bit value.  */\n+  __asm__(\"mov %A1, %0\\n\" : \"=m\" (word0) : \"i\" (CONST32_VAL));\n+  __asm__(\"mov %B1, %0\\n\" : \"=m\" (word1) : \"i\" (CONST32_VAL));\n+  CHECK_WORDS_IN_32BIT_VAL (CONST32_VAL);\n+\n+  /* Test extraction of each word of a 64-bit value.  */\n+  __asm__(\"mov %A1, %0\\n\" : \"=m\" (word0) : \"i\" (CONST64_VAL));\n+  __asm__(\"mov %B1, %0\\n\" : \"=m\" (word1) : \"i\" (CONST64_VAL));\n+  __asm__(\"mov %C1, %0\\n\" : \"=m\" (word2) : \"i\" (CONST64_VAL));\n+  __asm__(\"mov %D1, %0\\n\" : \"=m\" (word3) : \"i\" (CONST64_VAL));\n+  CHECK_WORDS_IN_64BIT_VAL (CONST64_VAL);\n+\n+  /* Test extraction of each byte of a 32-bit value.  */\n+  __asm__(\"mov.b %A1, %0\\n\" : \"=m\" (byte0) : \"i\" (CONST32_VAL));\n+  __asm__(\"mov.b %d1, %0\\n\" : \"=m\" (byte1) : \"i\" (CONST32_VAL));\n+  __asm__(\"mov.b %B1, %0\\n\" : \"=m\" (byte2) : \"i\" (CONST32_VAL));\n+  __asm__(\"mov.b %e1, %0\\n\" : \"=m\" (byte3) : \"i\" (CONST32_VAL));\n+  CHECK_BYTES_IN_32BIT_VAL (CONST32_VAL);\n+\n+  /* Test extraction of each byte of a 64-bit value.  */\n+  __asm__(\"mov.b %A1, %0\\n\" : \"=m\" (byte0) : \"i\" (CONST64_VAL));\n+  __asm__(\"mov.b %d1, %0\\n\" : \"=m\" (byte1) : \"i\" (CONST64_VAL));\n+  __asm__(\"mov.b %B1, %0\\n\" : \"=m\" (byte2) : \"i\" (CONST64_VAL));\n+  __asm__(\"mov.b %e1, %0\\n\" : \"=m\" (byte3) : \"i\" (CONST64_VAL));\n+  __asm__(\"mov.b %C1, %0\\n\" : \"=m\" (byte4) : \"i\" (CONST64_VAL));\n+  __asm__(\"mov.b %f1, %0\\n\" : \"=m\" (byte5) : \"i\" (CONST64_VAL));\n+  __asm__(\"mov.b %D1, %0\\n\" : \"=m\" (byte6) : \"i\" (CONST64_VAL));\n+  __asm__(\"mov.b %g1, %0\\n\" : \"=m\" (byte7) : \"i\" (CONST64_VAL));\n+  CHECK_BYTES_IN_64BIT_VAL (CONST64_VAL);\n+\n+  /* *** REGISTER OPERAND TESTS *** */\n+  /* No extraction of bytes from a single register.  */\n+\n+  /* Test extraction of high and low words from 32-bit value.  */\n+  __asm__(\"mov %A1, %0\\n\" : \"=m\" (word0) : \"r\" (reg32));\n+  __asm__(\"mov %B1, %0\\n\" : \"=m\" (word1) : \"r\" (reg32));\n+  CHECK_WORDS_IN_32BIT_VAL (REG32_VAL);\n+\n+  /* Test extraction of each word of a 64-bit value.  */\n+  __asm__(\"mov %A1, %0\\n\" : \"=m\" (word0) : \"r\" (reg64));\n+  __asm__(\"mov %B1, %0\\n\" : \"=m\" (word1) : \"r\" (reg64));\n+  __asm__(\"mov %C1, %0\\n\" : \"=m\" (word2) : \"r\" (reg64));\n+  __asm__(\"mov %D1, %0\\n\" : \"=m\" (word3) : \"r\" (reg64));\n+  CHECK_WORDS_IN_64BIT_VAL (REG64_VAL);\n \n   return 0;\n }"}]}