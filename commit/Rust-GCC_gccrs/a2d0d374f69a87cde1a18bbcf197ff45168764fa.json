{"sha": "a2d0d374f69a87cde1a18bbcf197ff45168764fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJkMGQzNzRmNjlhODdjZGUxYTE4YmJjZjE5N2ZmNDUxNjg3NjRmYQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2013-11-20T20:32:57Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-11-20T20:32:57Z"}, "message": "re PR rtl-optimization/59133 (ICE after r204219 on SPEC2006 435.gromacs.)\n\n2013-11-20  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/59133\n\t* lra.c (expand_reg_data): Add new argument.  Set up ALL_REGS for\n\tnew pseudos.\n\t(lra_create_new_reg_with_unique_value): Pass new argument value.\n\t(lra_emit_add, lra_emit_move): Ditto.\n\t* lra-constraints.c (in_class_p): Add check for move for a new\n\tinsn.\n\t(change_class): Rename to lra_change_class.  Move to lra-int.h.\n\t(get_reload_reg, narrow_reload_pseudo_class): Adjust calls of\n\tchange_class.\n\t(process_addr_reg, process_addr): Ditto.\n\t(curr_insn_transform): Ditto.  Add check on old pseudo for\n\toptional reload.\n\t* lra-int.h (lra_get_regno_hard_regno): Move below.\n\t(lra_change_class): Renamed change_class from lra.c.\n\n2013-11-20  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/59133\n\t* gcc.target/i386/pr59133.c: New.\n\nFrom-SVN: r205141", "tree": {"sha": "438f88188d619344b0bd8235fbee7824d4eb962e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/438f88188d619344b0bd8235fbee7824d4eb962e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2d0d374f69a87cde1a18bbcf197ff45168764fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2d0d374f69a87cde1a18bbcf197ff45168764fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2d0d374f69a87cde1a18bbcf197ff45168764fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2d0d374f69a87cde1a18bbcf197ff45168764fa/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1fef36449e233448605e7812f4e2874baf05ce53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fef36449e233448605e7812f4e2874baf05ce53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fef36449e233448605e7812f4e2874baf05ce53"}], "stats": {"total": 144, "additions": 108, "deletions": 36}, "files": [{"sha": "19ba024b7116460a932167db9a66bf25d59c88c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2d0d374f69a87cde1a18bbcf197ff45168764fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2d0d374f69a87cde1a18bbcf197ff45168764fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a2d0d374f69a87cde1a18bbcf197ff45168764fa", "patch": "@@ -1,3 +1,21 @@\n+2013-11-20  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/59133\n+\t* lra.c (expand_reg_data): Add new argument.  Set up ALL_REGS for\n+\tnew pseudos.\n+\t(lra_create_new_reg_with_unique_value): Pass new argument value.\n+\t(lra_emit_add, lra_emit_move): Ditto.\n+\t* lra-constraints.c (in_class_p): Add check for move for a new\n+\tinsn.\n+\t(change_class): Rename to lra_change_class.  Move to lra-int.h.\n+\t(get_reload_reg, narrow_reload_pseudo_class): Adjust calls of\n+\tchange_class.\n+\t(process_addr_reg, process_addr): Ditto.\n+\t(curr_insn_transform): Ditto.  Add check on old pseudo for\n+\toptional reload.\n+\t* lra-int.h (lra_get_regno_hard_regno): Move below.\n+\t(lra_change_class): Renamed change_class from lra.c.\n+\n 2013-11-20  David Malcolm  <dmalcolm@redhat.com>\n \n \t* gdbhooks.py (VecPrinter.children): Don't attempt to iterate"}, {"sha": "4c88cca669d28e2ef48b767eae88489acaa7539e", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2d0d374f69a87cde1a18bbcf197ff45168764fa/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2d0d374f69a87cde1a18bbcf197ff45168764fa/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=a2d0d374f69a87cde1a18bbcf197ff45168764fa", "patch": "@@ -269,7 +269,11 @@ in_class_p (rtx reg, enum reg_class cl, enum reg_class *new_class)\n \t typically moves that have many alternatives, and restricting\n \t reload pseudos for one alternative may lead to situations\n \t where other reload pseudos are no longer allocatable.  */\n-      || INSN_UID (curr_insn) >= new_insn_uid_start)\n+      || (INSN_UID (curr_insn) >= new_insn_uid_start\n+\t  && curr_insn_set != NULL\n+\t  && (OBJECT_P (SET_SRC (curr_insn_set))\n+\t      || (GET_CODE (SET_SRC (curr_insn_set)) == SUBREG\n+\t\t  && OBJECT_P (SUBREG_REG (SET_SRC (curr_insn_set)))))))\n     /* When we don't know what class will be used finally for reload\n        pseudos, we use ALL_REGS.  */\n     return ((regno >= new_regno_start && rclass == ALL_REGS)\n@@ -381,21 +385,6 @@ init_curr_insn_input_reloads (void)\n   curr_insn_input_reloads_num = 0;\n }\n \n-/* Change class of pseudo REGNO to NEW_CLASS.  Print info about it\n-   using TITLE.\t Output a new line if NL_P.  */\n-static void\n-change_class (int regno, enum reg_class new_class,\n-\t      const char *title, bool nl_p)\n-{\n-  lra_assert (regno >= FIRST_PSEUDO_REGISTER);\n-  if (lra_dump_file != NULL)\n-    fprintf (lra_dump_file, \"%s to class %s for r%d\",\n-\t     title, reg_class_names[new_class], regno);\n-  setup_reg_classes (regno, new_class, NO_REGS, new_class);\n-  if (lra_dump_file != NULL && nl_p)\n-    fprintf (lra_dump_file, \"\\n\");\n-}\n-\n /* Create a new pseudo using MODE, RCLASS, ORIGINAL or reuse already\n    created input reload pseudo (only if TYPE is not OP_OUT).  The\n    result pseudo is returned through RESULT_REG.  Return TRUE if we\n@@ -442,7 +431,7 @@ get_reload_reg (enum op_type type, enum machine_mode mode, rtx original,\n \t      dump_value_slim (lra_dump_file, original, 1);\n \t    }\n \t  if (new_class != lra_get_allocno_class (regno))\n-\t    change_class (regno, new_class, \", change\", false);\n+\t    lra_change_class (regno, new_class, \", change to\", false);\n \t  if (lra_dump_file != NULL)\n \t    fprintf (lra_dump_file, \"\\n\");\n \t  return false;\n@@ -667,7 +656,7 @@ narrow_reload_pseudo_class (rtx reg, enum reg_class cl)\n   if (! REG_P (reg) || (int) REGNO (reg) < new_regno_start)\n     return;\n   if (in_class_p (reg, cl, &rclass) && rclass != cl)\n-    change_class (REGNO (reg), rclass, \"      Change\", true);\n+    lra_change_class (REGNO (reg), rclass, \"      Change to\", true);\n }\n \n /* Generate reloads for matching OUT and INS (array of input operand\n@@ -1133,7 +1122,7 @@ process_addr_reg (rtx *loc, rtx *before, rtx *after, enum reg_class cl)\n \t}\n       else if (new_class != NO_REGS && rclass != new_class)\n \t{\n-\t  change_class (regno, new_class, \"\t   Change\", true);\n+\t  lra_change_class (regno, new_class, \"\t   Change to\", true);\n \t  return false;\n \t}\n       else\n@@ -2796,7 +2785,7 @@ process_address (int nop, rtx *before, rtx *after)\n \t      regno = REGNO (*ad.base_term);\n \t      if (regno >= FIRST_PSEUDO_REGISTER\n \t\t  && cl != lra_get_allocno_class (regno))\n-\t\tchange_class (regno, cl, \"      Change\", true);\n+\t\tlra_change_class (regno, cl, \"      Change to\", true);\n \t      new_reg = SET_SRC (set);\n \t      delete_insns_since (PREV_INSN (last_insn));\n \t    }\n@@ -3316,7 +3305,7 @@ curr_insn_transform (void)\n \t    if (new_class != NO_REGS && get_reg_class (regno) != new_class)\n \t      {\n \t\tlra_assert (ok_p);\n-\t\tchange_class (regno, new_class, \"      Change\", true);\n+\t\tlra_change_class (regno, new_class, \"      Change to\", true);\n \t      }\n \t  }\n       }\n@@ -3395,7 +3384,7 @@ curr_insn_transform (void)\n \t      && lra_former_scratch_operand_p (curr_insn, i))\n \t    {\n \t      int regno = REGNO (op);\n-\t      change_class (regno, NO_REGS, \"      Change\", true);\n+\t      lra_change_class (regno, NO_REGS, \"      Change to\", true);\n \t      if (lra_get_regno_hard_regno (regno) >= 0)\n \t\t/* We don't have to mark all insn affected by the\n \t\t   spilled pseudo as there is only one such insn, the\n@@ -3410,6 +3399,7 @@ curr_insn_transform (void)\n \t      && lra_undo_inheritance_iter < LRA_MAX_INHERITANCE_PASSES\n \t      && goal_alt[i] != NO_REGS && REG_P (op)\n \t      && (regno = REGNO (op)) >= FIRST_PSEUDO_REGISTER\n+\t      && regno < new_regno_start\n \t      && ! lra_former_scratch_p (regno)\n \t      && reg_renumber[regno] < 0\n \t      && (curr_insn_set == NULL_RTX"}, {"sha": "c545d9d354f98345d59fb9298247c9b1dd8f5932", "filename": "gcc/lra-int.h", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2d0d374f69a87cde1a18bbcf197ff45168764fa/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2d0d374f69a87cde1a18bbcf197ff45168764fa/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=a2d0d374f69a87cde1a18bbcf197ff45168764fa", "patch": "@@ -33,16 +33,6 @@ along with GCC; see the file COPYING3.\tIf not see\n    base and index registers might require a reload too.\t */\n #define LRA_MAX_INSN_RELOADS (MAX_RECOG_OPERANDS * 3)\n \n-/* Return the hard register which given pseudo REGNO assigned to.\n-   Negative value means that the register got memory or we don't know\n-   allocation yet.  */\n-static inline int\n-lra_get_regno_hard_regno (int regno)\n-{\n-  resize_reg_info ();\n-  return reg_renumber[regno];\n-}\n-\n typedef struct lra_live_range *lra_live_range_t;\n \n /* The structure describes program points where a given pseudo lives.\n@@ -394,6 +384,31 @@ extern void lra_eliminate_reg_if_possible (rtx *);\n \n \f\n \n+/* Return the hard register which given pseudo REGNO assigned to.\n+   Negative value means that the register got memory or we don't know\n+   allocation yet.  */\n+static inline int\n+lra_get_regno_hard_regno (int regno)\n+{\n+  resize_reg_info ();\n+  return reg_renumber[regno];\n+}\n+\n+/* Change class of pseudo REGNO to NEW_CLASS.  Print info about it\n+   using TITLE.  Output a new line if NL_P.  */\n+static void inline\n+lra_change_class (int regno, enum reg_class new_class,\n+\t\t  const char *title, bool nl_p)\n+{\n+  lra_assert (regno >= FIRST_PSEUDO_REGISTER);\n+  if (lra_dump_file != NULL)\n+    fprintf (lra_dump_file, \"%s class %s for r%d\",\n+\t     title, reg_class_names[new_class], regno);\n+  setup_reg_classes (regno, new_class, NO_REGS, new_class);\n+  if (lra_dump_file != NULL && nl_p)\n+    fprintf (lra_dump_file, \"\\n\");\n+}\n+\n /* Update insn operands which are duplication of NOP operand.  The\n    insn is represented by its LRA internal representation ID.  */\n static inline void"}, {"sha": "f4791a2de8befcffc1b7e8717b6b2552c8ca4a87", "filename": "gcc/lra.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2d0d374f69a87cde1a18bbcf197ff45168764fa/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2d0d374f69a87cde1a18bbcf197ff45168764fa/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=a2d0d374f69a87cde1a18bbcf197ff45168764fa", "patch": "@@ -130,11 +130,13 @@ static void invalidate_insn_data_regno_info (lra_insn_recog_data_t, rtx, int);\n \n /* Expand all regno related info needed for LRA.  */\n static void\n-expand_reg_data (void)\n+expand_reg_data (int old)\n {\n   resize_reg_info ();\n   expand_reg_info ();\n   ira_expand_reg_equiv ();\n+  for (int i = (int) max_reg_num () - 1; i >= old; i--)\n+    lra_change_class (i, ALL_REGS, \"      Set\", true);\n }\n \n /* Create and return a new reg of ORIGINAL mode.  If ORIGINAL is NULL\n@@ -178,7 +180,7 @@ lra_create_new_reg_with_unique_value (enum machine_mode md_mode, rtx original,\n \t\t title, REGNO (new_reg));\n       fprintf (lra_dump_file, \"\\n\");\n     }\n-  expand_reg_data ();\n+  expand_reg_data (max_reg_num ());\n   setup_reg_classes (REGNO (new_reg), rclass, NO_REGS, rclass);\n   return new_reg;\n }\n@@ -417,7 +419,7 @@ lra_emit_add (rtx x, rtx y, rtx z)\n   /* Functions emit_... can create pseudos -- so expand the pseudo\n      data.  */\n   if (old != max_reg_num ())\n-    expand_reg_data ();\n+    expand_reg_data (old);\n }\n \n /* The number of emitted reload insns so far.  */\n@@ -443,7 +445,7 @@ lra_emit_move (rtx x, rtx y)\n       /* Function emit_move can create pseudos -- so expand the pseudo\n \t data.\t*/\n       if (old != max_reg_num ())\n-\texpand_reg_data ();\n+\texpand_reg_data (old);\n       return;\n     }\n   lra_emit_add (x, XEXP (y, 0), XEXP (y, 1));"}, {"sha": "348a0ce7320cd5d0b219180221ba05f1d1838f97", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2d0d374f69a87cde1a18bbcf197ff45168764fa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2d0d374f69a87cde1a18bbcf197ff45168764fa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a2d0d374f69a87cde1a18bbcf197ff45168764fa", "patch": "@@ -1,3 +1,8 @@\n+2013-11-20  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/59133\n+\t* gcc.target/i386/pr59133.c: New.\n+\n 2013-11-20  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR middle-end/21718"}, {"sha": "ef8ef741de9f29c422ab575945bb1ff9b887a86e", "filename": "gcc/testsuite/gcc.target/i386/pr59133.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2d0d374f69a87cde1a18bbcf197ff45168764fa/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr59133.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2d0d374f69a87cde1a18bbcf197ff45168764fa/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr59133.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr59133.c?ref=a2d0d374f69a87cde1a18bbcf197ff45168764fa", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -ffast-math -march=core-avx2\" } */\n+\n+#define XX 0\n+#define YY 1\n+#define ZZ 2\n+#define DIM 3\n+typedef float matrix[DIM][DIM];\n+typedef float rvec[DIM];\n+extern int det (matrix);\n+extern void foo(matrix);\n+\n+void bar1 (int n,int *index,rvec x[],matrix trans)\n+{\n+  float   xt,yt,zt;\n+  int    i,ii;\n+  \n+  for(i=0; (i<n); i++) {\n+    ii=index ? index[i] : i;\n+    xt=x[ii][XX];\n+    yt=x[ii][YY];\n+    zt=x[ii][ZZ];\n+    x[ii][XX]=trans[XX][XX]*xt+trans[XX][YY]*yt+trans[XX][ZZ]*zt;\n+    x[ii][YY]=trans[YY][XX]*xt+trans[YY][YY]*yt+trans[YY][ZZ]*zt;\n+    x[ii][ZZ]=trans[ZZ][XX]*xt+trans[ZZ][YY]*yt+trans[ZZ][ZZ]*zt;\n+  }\n+}\n+\n+\n+void bar2 (int n, rvec x[]) \n+{\n+  int     m;\n+  matrix  trans;\n+  \n+  foo (trans);\n+  \n+  if (det (trans) < 0) {\n+    for(m=0; (m<DIM); m++)\n+      trans[ZZ][m] = -trans[ZZ][m];\n+  }  \n+  bar1 (n,(int*) 0,x,trans);\n+}"}]}