{"sha": "3965b35f341cc99a10876518f707740a9e912a01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk2NWIzNWYzNDFjYzk5YTEwODc2NTE4ZjcwNzc0MGE5ZTkxMmEwMQ==", "commit": {"author": {"name": "Stafford Horne", "email": "shorne@gmail.com", "date": "2018-11-09T12:16:14Z"}, "committer": {"name": "Stafford Horne", "email": "shorne@gcc.gnu.org", "date": "2018-11-09T12:16:14Z"}, "message": "or1k: gcc: initial support for openrisc\n\n2018-11-09  Stafford Horne  <shorne@gmail.com>\n\t    Richard Henderson  <rth@twiddle.net>\n\t    Joel Sherrill  <joel@rtems.org>\n\n\t* common/config/or1k/or1k-common.c: New file.\n\t* config/or1k/*: New.\n\t* config.gcc (or1k*-*-*): New.\n\t* configure.ac (or1k*-*-*): New test for openrisc tls.\n\t* configure: Regenerated.\n\t* doc/install.texi: Document OpenRISC triplets.\n\t* doc/invoke.texi: Document OpenRISC arguments.\n\t* doc/md.texi: Document OpenRISC.\n\n\nCo-Authored-By: Joel Sherrill <joel@rtems.org>\nCo-Authored-By: Richard Henderson <rth@twiddle.net>\n\nFrom-SVN: r265963", "tree": {"sha": "2233000c45797cf07e84d8e3ed4b4f37aa16ace3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2233000c45797cf07e84d8e3ed4b4f37aa16ace3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3965b35f341cc99a10876518f707740a9e912a01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3965b35f341cc99a10876518f707740a9e912a01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3965b35f341cc99a10876518f707740a9e912a01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3965b35f341cc99a10876518f707740a9e912a01/comments", "author": {"login": "stffrdhrn", "id": 2404255, "node_id": "MDQ6VXNlcjI0MDQyNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/2404255?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stffrdhrn", "html_url": "https://github.com/stffrdhrn", "followers_url": "https://api.github.com/users/stffrdhrn/followers", "following_url": "https://api.github.com/users/stffrdhrn/following{/other_user}", "gists_url": "https://api.github.com/users/stffrdhrn/gists{/gist_id}", "starred_url": "https://api.github.com/users/stffrdhrn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stffrdhrn/subscriptions", "organizations_url": "https://api.github.com/users/stffrdhrn/orgs", "repos_url": "https://api.github.com/users/stffrdhrn/repos", "events_url": "https://api.github.com/users/stffrdhrn/events{/privacy}", "received_events_url": "https://api.github.com/users/stffrdhrn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1d6ff15057c18d72b231f60e526273b41e362283", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d6ff15057c18d72b231f60e526273b41e362283", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d6ff15057c18d72b231f60e526273b41e362283"}], "stats": {"total": 4126, "additions": 4126, "deletions": 0}, "files": [{"sha": "07993c538c0916568ebd6b8dc2b16186bcdaa345", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3965b35f341cc99a10876518f707740a9e912a01/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3965b35f341cc99a10876518f707740a9e912a01/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3965b35f341cc99a10876518f707740a9e912a01", "patch": "@@ -1,3 +1,16 @@\n+2018-11-09  Stafford Horne  <shorne@gmail.com>\n+\t    Richard Henderson  <rth@twiddle.net>\n+\t    Joel Sherrill  <joel@rtems.org>\n+\n+\t* common/config/or1k/or1k-common.c: New file.\n+\t* config/or1k/*: New.\n+\t* config.gcc (or1k*-*-*): New.\n+\t* configure.ac (or1k*-*-*): New test for openrisc tls.\n+\t* configure: Regenerated.\n+\t* doc/install.texi: Document OpenRISC triplets.\n+\t* doc/invoke.texi: Document OpenRISC arguments.\n+\t* doc/md.texi: Document OpenRISC.\n+\n 2018-11-09  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/arm-cpus.in (arm7tdmi): Add an alias for arm7tdmi-s."}, {"sha": "044e843fd1989bfc0edf4f66199119d0392d4d42", "filename": "gcc/common/config/or1k/or1k-common.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fcommon%2Fconfig%2For1k%2For1k-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fcommon%2Fconfig%2For1k%2For1k-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2For1k%2For1k-common.c?ref=3965b35f341cc99a10876518f707740a9e912a01", "patch": "@@ -0,0 +1,41 @@\n+/* Common hooks for OpenRISC\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"diagnostic-core.h\"\n+#include \"tm.h\"\n+#include \"common/common-target.h\"\n+#include \"common/common-target-def.h\"\n+#include \"opts.h\"\n+#include \"flags.h\"\n+\n+/* Implement TARGET_OPTION_OPTIMIZATION_TABLE.  */\n+static const struct default_options or1k_option_optimization_table[] =\n+  {\n+    /* Enable section anchors by default at -O1 or higher.  */\n+    { OPT_LEVELS_1_PLUS, OPT_fsection_anchors, NULL, 1 },\n+    { OPT_LEVELS_NONE, 0, NULL, 0 }\n+  };\n+\n+#undef TARGET_OPTION_OPTIMIZATION_TABLE\n+#define TARGET_OPTION_OPTIMIZATION_TABLE or1k_option_optimization_table\n+\n+struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;"}, {"sha": "e2b99469ddf766e7d4f1f9a0a775cf32b261b808", "filename": "gcc/config.gcc", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=3965b35f341cc99a10876518f707740a9e912a01", "patch": "@@ -484,6 +484,9 @@ nios2-*-*)\n nvptx-*-*)\n \tcpu_type=nvptx\n \t;;\n+or1k*-*-*)\n+\tcpu_type=or1k\n+\t;;\n powerpc*-*-*spe*)\n \tcpu_type=powerpcspe\n \textra_headers=\"ppc-asm.h altivec.h spe.h ppu_intrinsics.h paired.h spu2vmx.h vec_types.h si2vmx.h htmintrin.h htmxlintrin.h\"\n@@ -2490,6 +2493,48 @@ nvptx-*)\n \t\ttm_file=\"${tm_file} nvptx/offload.h\"\n \tfi\n \t;;\n+or1k*-*-*)\n+\ttm_file=\"elfos.h ${tm_file}\"\n+\ttmake_file=\"${tmake_file} or1k/t-or1k\"\n+\t# Force .init_array support.  The configure script cannot always\n+\t# automatically detect that GAS supports it, yet we require it.\n+\tgcc_cv_initfini_array=yes\n+\n+\t# Handle --with-multilib-list=...\n+\tor1k_multilibs=\"${with_multilib_list}\"\n+\tif test \"$or1k_multilibs\" = \"default\"; then\n+\t\tor1k_multilibs=\"mcmov,msoft-mul,msoft-div\"\n+\tfi\n+\tor1k_multilibs=`echo $or1k_multilibs | sed -e 's/,/ /g'`\n+\tfor or1k_multilib in ${or1k_multilibs}; do\n+\t\tcase ${or1k_multilib} in\n+\t\tmcmov | msext | msfimm | \\\n+\t\tmhard-div | mhard-mul | \\\n+\t\tmsoft-div | msoft-mul )\n+\t\t\tTM_MULTILIB_CONFIG=\"${TM_MULTILIB_CONFIG},${or1k_multilib}\"\n+\t\t\t;;\n+\t\t*)\n+\t\t\techo \"--with-multilib-list=${with_multilib_list} not supported.\"\n+\t\t\texit 1\n+\t\tesac\n+\tdone\n+\tTM_MULTILIB_CONFIG=`echo $TM_MULTILIB_CONFIG | sed 's/^,//'`\n+\n+\tcase ${target} in\n+\tor1k*-*-linux*)\n+\t\ttm_file=\"${tm_file} gnu-user.h linux.h glibc-stdint.h\"\n+\t\ttm_file=\"${tm_file} or1k/linux.h\"\n+\t\t;;\n+\tor1k*-*-elf*)\n+\t\ttm_file=\"${tm_file} newlib-stdint.h or1k/elf.h\"\n+\t\textra_options=\"${extra_options} or1k/elf.opt\"\n+\t\t;;\n+\tor1k*-*-rtems*)\n+\t\ttm_file=\"${tm_file} newlib-stdint.h or1k/rtems.h rtems.h\"\n+\t\ttmake_file=\"${tmake_file} or1k/t-rtems\"\n+\t\t;;\n+\tesac\n+\t;;\n pdp11-*-*)\n \ttm_file=\"${tm_file} newlib-stdint.h\"\n \tuse_gcc_stdint=wrap"}, {"sha": "2e7797b72fb490f42527b79d8082f77c47dce30b", "filename": "gcc/config/or1k/constraints.md", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2Fconstraints.md?ref=3965b35f341cc99a10876518f707740a9e912a01", "patch": "@@ -0,0 +1,55 @@\n+;; Constraint definitions for OpenRISC\n+;; Copyright (C) 2018 Free Software Foundation, Inc.\n+;; Contributed by Stafford Horne\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; -------------------------------------------------------------------------\n+;; Constraints\n+;; -------------------------------------------------------------------------\n+\n+; We use:\n+;  c - sibcall registers\n+;  I - constant signed 16-bit\n+;  K - constant unsigned 16-bit\n+;  M - constant signed 16-bit shifted left 16-bits (l.movhi)\n+;  O - constant zero\n+\n+(define_register_constraint \"c\" \"SIBCALL_REGS\"\n+  \"Registers which can hold a sibling call address\")\n+\n+;; Immediates\n+(define_constraint \"I\"\n+  \"A signed 16-bit immediate in the range -32768 to 32767.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, -32768, 32767)\")))\n+\n+(define_constraint \"K\"\n+  \"An unsigned 16-bit immediate in the range 0 to 0xffff.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, 0, 65535)\")))\n+\n+(define_constraint \"M\"\n+  \"A shifted signed 16-bit constant suitable for l.movhi.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(ival & 0xffff) == 0\n+\t\t    && (ival >> 31 == -1 || ival >> 31 == 0)\")))\n+\n+(define_constraint \"O\"\n+  \"The constant zero\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 0\")))"}, {"sha": "7d2d19f06cea25be5db747182bad97e5229a0693", "filename": "gcc/config/or1k/elf.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2Felf.h?ref=3965b35f341cc99a10876518f707740a9e912a01", "patch": "@@ -0,0 +1,42 @@\n+/* Target Newlib Definitions for OpenRISC.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Stafford Horne.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_OR1K_ELF_H\n+#define GCC_OR1K_ELF_H\n+\n+#undef  LIB_SPEC\n+#define LIB_SPEC \"--start-group -lc -lor1k \"\t\t\t\\\n+  \"%{mboard=*:-lboard-%*; :-lboard-or1ksim} --end-group\"\n+\n+#undef\tLINK_SPEC\n+#define LINK_SPEC \"%{h*}\t\t\t\\\n+   %{static:-Bstatic}\t\t\t\t\\\n+   %{shared:-shared}\t\t\t\t\\\n+   %{symbolic:-Bsymbolic}\t\t\t\\\n+   %{!static:%{rdynamic:-export-dynamic}}\t\\\n+   --entry=0x100\"\n+\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC \"crt0.o%s crtbegin.o%s\"\n+\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC \"crtend.o%s\"\n+\n+#endif /* GCC_OR1K_ELF_H */"}, {"sha": "956d395003dffe936749518693f188cb4128e705", "filename": "gcc/config/or1k/elf.opt", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2Felf.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2Felf.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2Felf.opt?ref=3965b35f341cc99a10876518f707740a9e912a01", "patch": "@@ -0,0 +1,33 @@\n+; OpenRISC command line options for newlib binaries\n+\n+; Copyright (C) 2010-2018 Free Software Foundation, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.\n+\n+; See the GCC internals manual (options.texi) for a description of\n+; this file's format.\n+\n+; Please try to keep this file in ASCII collating order.\n+\n+mboard=\n+Target RejectNegative Joined\n+Configure board specific runtime.\n+\n+mnewlib\n+Target RejectNegative\n+For compatibility, it's always newlib for elf now.\n+"}, {"sha": "c734a2afd5af9acc3b34dd691cb60681ce87b09b", "filename": "gcc/config/or1k/linux.h", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2Flinux.h?ref=3965b35f341cc99a10876518f707740a9e912a01", "patch": "@@ -0,0 +1,45 @@\n+/* Linux Definitions for OpenRISC.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Stafford Horne.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_OR1K_LINUX_H\n+#define GCC_OR1K_LINUX_H\n+\n+/* elfos.h should have already been included.  Now just override\n+   any conflicting definitions and add any extras.  */\n+\n+#define TARGET_OS_CPP_BUILTINS() \\\n+  GNU_USER_TARGET_OS_CPP_BUILTINS ()\n+\n+#define GLIBC_DYNAMIC_LINKER \"/lib/ld-linux-or1k.so.1\"\n+\n+#undef MUSL_DYNAMIC_LINKER\n+#define MUSL_DYNAMIC_LINKER  \"/lib/ld-musl-or1k.so.1\"\n+\n+#undef LINK_SPEC\n+#define LINK_SPEC \"%{h*}\t\t\t\\\n+   %{static:-Bstatic}\t\t\t\t\\\n+   %{shared:-shared}\t\t\t\t\\\n+   %{symbolic:-Bsymbolic}\t\t\t\\\n+   %{!static:%{!static-pie:\t\t\t\\\n+     %{rdynamic:-export-dynamic}\t\t\\\n+     %{!shared:-dynamic-linker \" GNU_USER_DYNAMIC_LINKER \"}}} \\\n+   %{static-pie:-Bstatic -pie --no-dynamic-linker -z text}\"\n+\n+#endif /* GCC_OR1K_LINUX_H */"}, {"sha": "e18383ae7813625446b2d3e49bbdc70492870f8b", "filename": "gcc/config/or1k/or1k-protos.h", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2For1k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2For1k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2For1k-protos.h?ref=3965b35f341cc99a10876518f707740a9e912a01", "patch": "@@ -0,0 +1,38 @@\n+/* Prototypes for OpenRISC functions used in the md file & elsewhere.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+extern HOST_WIDE_INT or1k_initial_elimination_offset (int, int);\n+extern void or1k_expand_prologue (void);\n+extern void or1k_expand_epilogue (void);\n+extern void or1k_expand_eh_return (rtx);\n+extern rtx  or1k_initial_frame_addr (void);\n+extern rtx  or1k_dynamic_chain_addr (rtx);\n+extern rtx  or1k_return_addr (int, rtx);\n+extern void or1k_expand_move (machine_mode, rtx, rtx);\n+extern void or1k_expand_compare (rtx *);\n+extern void or1k_expand_call (rtx, rtx, rtx, bool);\n+\n+#ifdef RTX_CODE\n+void or1k_expand_atomic_compare_and_swap (rtx operands[]);\n+void or1k_expand_atomic_compare_and_swap_qihi (rtx operands[]);\n+void or1k_expand_atomic_exchange (rtx operands[]);\n+void or1k_expand_atomic_exchange_qihi (rtx operands[]);\n+void or1k_expand_atomic_op (rtx_code, rtx, rtx, rtx, rtx);\n+void or1k_expand_atomic_op_qihi (rtx_code, rtx, rtx, rtx, rtx);\n+#endif"}, {"sha": "d1b90cb0168b478b9881e835aabf7e4ec5e75e5e", "filename": "gcc/config/or1k/or1k.c", "status": "added", "additions": 2183, "deletions": 0, "changes": 2183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2For1k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2For1k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2For1k.c?ref=3965b35f341cc99a10876518f707740a9e912a01", "patch": "@@ -0,0 +1,2183 @@\n+/* Target Code for OpenRISC\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Stafford Horne based on other ports.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#define IN_TARGET_CODE 1\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"target.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"attribs.h\"\n+#include \"df.h\"\n+#include \"regs.h\"\n+#include \"memmodel.h\"\n+#include \"emit-rtl.h\"\n+#include \"diagnostic-core.h\"\n+#include \"output.h\"\n+#include \"stor-layout.h\"\n+#include \"varasm.h\"\n+#include \"calls.h\"\n+#include \"expr.h\"\n+#include \"builtins.h\"\n+#include \"optabs.h\"\n+#include \"explow.h\"\n+#include \"cfgrtl.h\"\n+#include \"alias.h\"\n+\n+/* These 4 are needed to allow using satisfies_constraint_J.  */\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"tm_p.h\"\n+#include \"tm-constrs.h\"\n+\n+/* This file should be included last.  */\n+#include \"target-def.h\"\n+\n+/* Per-function machine data.  */\n+struct GTY(()) machine_function\n+{\n+  /* Number of bytes saved on the stack for callee saved registers.  */\n+  HOST_WIDE_INT callee_saved_reg_size;\n+\n+  /* Number of bytes saved on the stack for local variables.  */\n+  HOST_WIDE_INT local_vars_size;\n+\n+  /* Number of bytes saved on the stack for outgoing/sub-function args.  */\n+  HOST_WIDE_INT args_size;\n+\n+  /* The sum of sizes: locals vars, called saved regs, stack pointer\n+     and an optional frame pointer.\n+     Used in expand_prologue () and expand_epilogue ().  */\n+  HOST_WIDE_INT total_size;\n+\n+  /* Remember where the set_got_placeholder is located.  */\n+  rtx_insn *set_got_insn;\n+};\n+\n+/* Zero initialization is OK for all current fields.  */\n+\n+static struct machine_function *\n+or1k_init_machine_status (void)\n+{\n+  return ggc_cleared_alloc<machine_function> ();\n+}\n+\n+\n+/* Worker for TARGET_OPTION_OVERRIDE.\n+   We currently only use this to setup init_machine_status.  */\n+\n+static void\n+or1k_option_override (void)\n+{\n+  /* Set the per-function-data initializer.  */\n+  init_machine_status = or1k_init_machine_status;\n+}\n+\n+/* Returns true if REGNO must be saved for the current function.  */\n+\n+static bool\n+callee_saved_regno_p (int regno)\n+{\n+  /* Check call-saved registers.  */\n+  if (!call_used_regs[regno] && df_regs_ever_live_p (regno))\n+    return true;\n+\n+  switch (regno)\n+    {\n+    case HARD_FRAME_POINTER_REGNUM:\n+      return frame_pointer_needed;\n+\n+    case LR_REGNUM:\n+      /* Always save LR if we are saving HFP, producing a walkable\n+\t stack chain with -fno-omit-frame-pointer.  */\n+      return (frame_pointer_needed\n+\t      || !crtl->is_leaf\n+\t      || crtl->uses_pic_offset_table\n+\t      || df_regs_ever_live_p (regno));\n+\n+    case HW_TO_GCC_REGNO (25):\n+    case HW_TO_GCC_REGNO (27):\n+    case HW_TO_GCC_REGNO (29):\n+    case HW_TO_GCC_REGNO (31):\n+      /* See EH_RETURN_DATA_REGNO.  */\n+      return crtl->calls_eh_return;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Worker for TARGET_COMPUTE_FRAME_LAYOUT.\n+   Compute and populate machine specific function attributes which are globally\n+   accessible via cfun->machine.  These include the sizes needed for\n+   stack stored local variables, callee saved registers and space for stack\n+   arguments which may be passed to a next function.  The values are used for\n+   the epilogue, prologue and eliminations.\n+\n+   OpenRISC stack grows downwards and contains:\n+\n+    ---- previous frame --------\n+    current func arg[n]\n+    current func arg[0]   <-- r2 [HFP,AP]\n+    ---- current stack frame ---  ^  ---\\\n+    return address      r9        |     |\n+    old frame pointer   r2       (+)    |-- machine->total_size\n+    callee saved regs             |     | > machine->callee_saved_reg_size\n+    local variables               |     | > machine->local_vars_size       <-FP\n+    next function args    <-- r1 [SP]---/ > machine->args_size\n+    ----------------------------  |\n+\t\t\t\t (-)\n+\t   (future)               |\n+\t\t\t\t  V\n+\n+   All of these contents are optional.  */\n+\n+static void\n+or1k_compute_frame_layout (void)\n+{\n+  HOST_WIDE_INT local_vars_size, args_size, save_reg_size;\n+\n+  local_vars_size = get_frame_size ();\n+  local_vars_size = ROUND_UP (local_vars_size, UNITS_PER_WORD);\n+\n+  args_size = crtl->outgoing_args_size;\n+  args_size = ROUND_UP (args_size, UNITS_PER_WORD);\n+\n+  save_reg_size = 0;\n+  for (int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (callee_saved_regno_p (regno))\n+      save_reg_size += UNITS_PER_WORD;\n+\n+  cfun->machine->local_vars_size = local_vars_size;\n+  cfun->machine->args_size = args_size;\n+  cfun->machine->callee_saved_reg_size = save_reg_size;\n+  cfun->machine->total_size = save_reg_size + local_vars_size + args_size;\n+}\n+\n+/* Emit rtl to save register REGNO contents to stack memory at the given OFFSET\n+   from the current stack pointer.  */\n+\n+static void\n+or1k_save_reg (int regno, HOST_WIDE_INT offset)\n+{\n+  rtx reg = gen_rtx_REG (Pmode, regno);\n+  rtx mem = gen_frame_mem (SImode, plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t  offset));\n+  rtx insn = emit_move_insn (mem, reg);\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+}\n+\n+/* Emit rtl to restore register REGNO contents from stack memory at the given\n+   OFFSET from the current stack pointer.  */\n+\n+static rtx\n+or1k_restore_reg (int regno, HOST_WIDE_INT offset, rtx cfa_restores)\n+{\n+  rtx reg = gen_rtx_REG (Pmode, regno);\n+  rtx mem = gen_frame_mem (SImode, plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t  offset));\n+  emit_move_insn (reg, mem);\n+  return alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n+}\n+\n+/* Expand the \"prologue\" pattern.  */\n+\n+void\n+or1k_expand_prologue (void)\n+{\n+  HOST_WIDE_INT sp_offset = -cfun->machine->total_size;\n+  HOST_WIDE_INT reg_offset, this_offset;\n+  rtx insn;\n+\n+  if (flag_stack_usage_info)\n+    current_function_static_stack_size = -sp_offset;\n+\n+  /* Early exit for frameless functions.  */\n+  if (sp_offset == 0)\n+    goto fini;\n+\n+  /* Adjust the stack pointer.  For large stack offsets we will\n+     do this in multiple parts, before and after saving registers.  */\n+  reg_offset = (sp_offset + cfun->machine->local_vars_size\n+\t\t+ cfun->machine->args_size);\n+  this_offset = MAX (sp_offset, -32764);\n+  reg_offset -= this_offset;\n+  sp_offset -= this_offset;\n+\n+  insn = emit_insn (gen_frame_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t      GEN_INT (this_offset)));\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+\n+  /* Save callee-saved registers.  */\n+  for (int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (regno != HARD_FRAME_POINTER_REGNUM\n+\t&& regno != LR_REGNUM\n+\t&& callee_saved_regno_p (regno))\n+      {\n+\tor1k_save_reg (regno, reg_offset);\n+\treg_offset += UNITS_PER_WORD;\n+      }\n+\n+  /* Save and update frame pointer.  */\n+  if (callee_saved_regno_p (HARD_FRAME_POINTER_REGNUM))\n+    {\n+      or1k_save_reg (HARD_FRAME_POINTER_REGNUM, reg_offset);\n+      if (frame_pointer_needed)\n+\t{\n+\t  insn = emit_insn (gen_addsi3 (hard_frame_pointer_rtx,\n+\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\tGEN_INT (-this_offset)));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+      reg_offset += UNITS_PER_WORD;\n+    }\n+\n+  /* Save the link register.  */\n+  if (callee_saved_regno_p (LR_REGNUM))\n+    {\n+      or1k_save_reg (LR_REGNUM, reg_offset);\n+      reg_offset += UNITS_PER_WORD;\n+    }\n+  gcc_assert (reg_offset + this_offset == 0);\n+\n+  /* Allocate the rest of the stack frame, if any.  */\n+  if (sp_offset != 0)\n+    {\n+      if (sp_offset < 2 * -32768)\n+\t{\n+\t  /* For very large offsets, we need a temporary register.  */\n+\t  rtx tmp = gen_rtx_REG (Pmode, PE_TMP_REGNUM);\n+\t  emit_move_insn (tmp, GEN_INT (sp_offset));\n+\t  insn = emit_insn (gen_frame_addsi3 (stack_pointer_rtx,\n+\t\t\t\t\t      stack_pointer_rtx, tmp));\n+\t  if (!frame_pointer_needed)\n+\t    {\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t      add_reg_note (insn, REG_CFA_ADJUST_CFA,\n+\t\t\t    gen_rtx_SET (stack_pointer_rtx,\n+\t\t\t\t\t plus_constant (Pmode,\n+\t\t\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\t\t\tsp_offset)));\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, emit one or two sequential subtracts.  */\n+\t  do\n+\t    {\n+\t      this_offset = MAX (sp_offset, -32768);\n+\t      sp_offset -= this_offset;\n+\n+\t      insn = emit_insn (gen_frame_addsi3 (stack_pointer_rtx,\n+\t\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t\t  GEN_INT (this_offset)));\n+\t      if (!frame_pointer_needed)\n+\t\tRTX_FRAME_RELATED_P (insn) = 1;\n+\t    }\n+\t  while (sp_offset != 0);\n+\t}\n+    }\n+\n+ fini:\n+  /* Fix up, or remove, the insn that initialized the pic register.  */\n+  rtx_insn *set_got_insn = cfun->machine->set_got_insn;\n+  if (crtl->uses_pic_offset_table)\n+    {\n+      rtx reg = SET_DEST (PATTERN (set_got_insn));\n+      rtx_insn *insn = emit_insn_before (gen_set_got (reg), set_got_insn);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      add_reg_note (insn, REG_CFA_FLUSH_QUEUE, NULL_RTX);\n+    }\n+  delete_insn (set_got_insn);\n+}\n+\n+/* Expand the \"epilogue\" pattern.  */\n+\n+void\n+or1k_expand_epilogue (void)\n+{\n+  HOST_WIDE_INT reg_offset, sp_offset;\n+  rtx insn, cfa_restores = NULL;\n+\n+  sp_offset = cfun->machine->total_size;\n+  if (sp_offset == 0)\n+    return;\n+\n+  reg_offset = cfun->machine->local_vars_size + cfun->machine->args_size;\n+\n+  if (sp_offset >= 32768 || cfun->calls_alloca)\n+    {\n+      /* The saved registers are out of range of the stack pointer.\n+\t We need to partially deallocate the stack frame now.  */\n+      if (frame_pointer_needed)\n+\t{\n+\t  /* Reset the stack pointer to the bottom of the saved regs.  */\n+\t  sp_offset -= reg_offset;\n+\t  reg_offset = 0;\n+\t  insn = emit_insn (gen_frame_addsi3 (stack_pointer_rtx,\n+\t\t\t\t\t      hard_frame_pointer_rtx,\n+\t\t\t\t\t      GEN_INT (-sp_offset)));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  add_reg_note (insn, REG_CFA_DEF_CFA,\n+\t\t\tplus_constant (Pmode, stack_pointer_rtx, sp_offset));\n+\t}\n+      else if (sp_offset >= 3 * 32768)\n+\t{\n+\t  /* For very large offsets, we need a temporary register.  */\n+\t  rtx tmp = gen_rtx_REG (Pmode, PE_TMP_REGNUM);\n+\t  emit_move_insn (tmp, GEN_INT (reg_offset));\n+\t  insn = emit_insn (gen_frame_addsi3 (stack_pointer_rtx,\n+\t\t\t\t\t      stack_pointer_rtx, tmp));\n+\t  sp_offset -= reg_offset;\n+\t  reg_offset = 0;\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  add_reg_note (insn, REG_CFA_DEF_CFA,\n+\t\t\tplus_constant (Pmode, stack_pointer_rtx, sp_offset));\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, emit one or two sequential additions.  */\n+\t  do\n+\t    {\n+\t      HOST_WIDE_INT this_offset = MIN (reg_offset, 32764);\n+\t      reg_offset -= this_offset;\n+\t      sp_offset -= this_offset;\n+\n+\t      insn = emit_insn (gen_frame_addsi3 (stack_pointer_rtx,\n+\t\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t\t  GEN_INT (this_offset)));\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t      add_reg_note (insn, REG_CFA_DEF_CFA,\n+\t\t\t    plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t   sp_offset));\n+\t    }\n+\t  while (sp_offset >= 32768);\n+\t}\n+    }\n+\n+  /* Restore callee-saved registers.  */\n+  for (int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (regno != HARD_FRAME_POINTER_REGNUM\n+\t&& regno != LR_REGNUM\n+\t&& callee_saved_regno_p (regno))\n+      {\n+\tcfa_restores = or1k_restore_reg (regno, reg_offset, cfa_restores);\n+\treg_offset += UNITS_PER_WORD;\n+      }\n+\n+  /* Restore frame pointer.  */\n+  if (callee_saved_regno_p (HARD_FRAME_POINTER_REGNUM))\n+    {\n+      cfa_restores = or1k_restore_reg (HARD_FRAME_POINTER_REGNUM,\n+\t\t\t\t       reg_offset, cfa_restores);\n+      reg_offset += UNITS_PER_WORD;\n+    }\n+\n+  /* Restore link register.  */\n+  if (callee_saved_regno_p (LR_REGNUM))\n+    {\n+      cfa_restores = or1k_restore_reg (LR_REGNUM, reg_offset, cfa_restores);\n+      reg_offset += UNITS_PER_WORD;\n+    }\n+  gcc_assert (reg_offset == sp_offset);\n+\n+  /* Restore stack pointer.  */\n+  insn = emit_insn (gen_frame_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t      GEN_INT (sp_offset)));\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+  REG_NOTES (insn) = cfa_restores;\n+  add_reg_note (insn, REG_CFA_DEF_CFA, stack_pointer_rtx);\n+\n+  /* Move up to the stack frame of an exception handler.  */\n+  if (crtl->calls_eh_return)\n+    emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t   EH_RETURN_STACKADJ_RTX));\n+}\n+\n+/* Worker for TARGET_INIT_PIC_REG.\n+   Initialize the cfun->machine->set_got_insn rtx and insert it at the entry\n+   of the current function.  The rtx is just a temporary placeholder for\n+   the GOT and will be replaced or removed during or1k_expand_prologue.  */\n+\n+static void\n+or1k_init_pic_reg (void)\n+{\n+  start_sequence ();\n+\n+  cfun->machine->set_got_insn\n+    = emit_insn (gen_set_got_tmp (pic_offset_table_rtx));\n+\n+  rtx_insn *seq = get_insns ();\n+  end_sequence ();\n+\n+  edge entry_edge = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+  insert_insn_on_edge (seq, entry_edge);\n+  commit_one_edge_insertion (entry_edge);\n+}\n+\n+#undef TARGET_INIT_PIC_REG\n+#define TARGET_INIT_PIC_REG  or1k_init_pic_reg\n+#undef TARGET_USE_PSEUDO_PIC_REG\n+#define TARGET_USE_PSEUDO_PIC_REG  hook_bool_void_true\n+\n+/* Worker for INITIAL_FRAME_ADDRESS_RTX.\n+   Returns the RTX representing the address of the initial stack frame.  */\n+\n+rtx\n+or1k_initial_frame_addr ()\n+{\n+  /* Use this to force a stack frame for the current function.  */\n+  crtl->accesses_prior_frames = 1;\n+  return arg_pointer_rtx;\n+}\n+\n+/* Worker for DYNAMIC_CHAIN_ADDRESS.\n+   Returns the RTX representing the address of where the caller's frame pointer\n+   may be stored on the stack.  */\n+\n+rtx\n+or1k_dynamic_chain_addr (rtx frame)\n+{\n+  return plus_constant (Pmode, frame, -2 * UNITS_PER_WORD);\n+}\n+\n+/* Worker for RETURN_ADDR_RTX.\n+   Returns the RTX representing the address of where the link register may be\n+   stored on the stack.  */\n+\n+rtx\n+or1k_return_addr (int, rtx frame)\n+{\n+  return gen_frame_mem (Pmode, plus_constant (Pmode, frame, -UNITS_PER_WORD));\n+}\n+\n+/* Worker for TARGET_FRAME_POINTER_REQUIRED.\n+   Returns true if the current function must use a frame pointer.  */\n+\n+static bool\n+or1k_frame_pointer_required ()\n+{\n+  /* ??? While IRA checks accesses_prior_frames, reload does not.\n+     We do want the frame pointer for this case.  */\n+  return (crtl->accesses_prior_frames || crtl->profile);\n+}\n+\n+/* Expand the \"eh_return\" pattern.\n+   Used for defining __builtin_eh_return, this will emit RTX to override the\n+   current function's return address stored on the stack.  The emitted RTX is\n+   inserted before the epilogue so we can't just update the link register.\n+   This is used when handling exceptions to jump into the exception handler\n+   catch block upon return from _Unwind_RaiseException.  */\n+\n+void\n+or1k_expand_eh_return (rtx eh_addr)\n+{\n+  rtx lraddr;\n+\n+  lraddr = gen_frame_mem (Pmode, plus_constant (Pmode,\n+\t\t\t\t\t\targ_pointer_rtx,\n+\t\t\t\t\t\t-UNITS_PER_WORD));\n+  /* Set address to volatile to ensure the store doesn't get optimized out.  */\n+  MEM_VOLATILE_P (lraddr) = true;\n+  emit_move_insn (lraddr, eh_addr);\n+}\n+\n+/* Helper for defining INITIAL_ELIMINATION_OFFSET.\n+   We allow the following eliminiations:\n+     FP -> HARD_FP or SP\n+     AP -> HARD_FP or SP\n+\n+   HARD_FP and AP are the same which is handled below.  */\n+\n+HOST_WIDE_INT\n+or1k_initial_elimination_offset (int from, int to)\n+{\n+  HOST_WIDE_INT offset;\n+\n+  /* Set OFFSET to the offset from the stack pointer.  */\n+  switch (from)\n+    {\n+    /* Incoming args are all the way up at the previous frame.  */\n+    case ARG_POINTER_REGNUM:\n+      offset = cfun->machine->total_size;\n+      break;\n+\n+    /* Local args grow downward from the saved registers.  */\n+    case FRAME_POINTER_REGNUM:\n+      offset = cfun->machine->args_size + cfun->machine->local_vars_size;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (to == HARD_FRAME_POINTER_REGNUM)\n+    offset -= cfun->machine->total_size;\n+\n+  return offset;\n+}\n+\n+/* Worker for TARGET_LEGITIMATE_ADDRESS_P.\n+   Returns true if X is a legitimate address RTX on OpenRISC.  */\n+\n+static bool\n+or1k_legitimate_address_p (machine_mode, rtx x, bool strict_p)\n+{\n+  rtx base, addend;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case REG:\n+      base = x;\n+      break;\n+\n+    case PLUS:\n+      base = XEXP (x, 0);\n+      addend = XEXP (x, 1);\n+      if (!REG_P (base))\n+\treturn false;\n+      /* Register elimination is going to adjust all of these offsets.\n+\t We might as well keep them as a unit until then.  */\n+      if (!strict_p && virtual_frame_reg_operand (base, VOIDmode))\n+\treturn CONST_INT_P (addend);\n+      if (!satisfies_constraint_I (addend))\n+\treturn false;\n+      break;\n+\n+    case LO_SUM:\n+      base = XEXP (x, 0);\n+      if (!REG_P (base))\n+\treturn false;\n+      x = XEXP (x, 1);\n+      switch (GET_CODE (x))\n+\t{\n+\tcase CONST:\n+\tcase SYMBOL_REF:\n+\tcase LABEL_REF:\n+\t  /* Assume legitimize_address properly categorized\n+\t     the symbol.  Continue to check the base.  */\n+\t  break;\n+\n+\tcase UNSPEC:\n+\t  switch (XINT (x, 1))\n+\t    {\n+\t    case UNSPEC_GOT:\n+\t    case UNSPEC_GOTOFF:\n+\t    case UNSPEC_TPOFF:\n+\t    case UNSPEC_GOTTPOFF:\n+\t      /* Assume legitimize_address properly categorized\n+\t\t the symbol.  Continue to check the base.  */\n+\t      break;\n+\t    default:\n+\t      return false;\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  return false;\n+\t}\n+      break;\n+\n+    default:\n+      return false;\n+    }\n+\n+  unsigned regno = REGNO (base);\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      if (strict_p)\n+\tregno = reg_renumber[regno];\n+      else\n+\treturn true;\n+    }\n+  if (strict_p)\n+    return regno <= 31;\n+  else\n+    return REGNO_OK_FOR_BASE_P (regno);\n+}\n+\n+/* Return the TLS type for TLS symbols, 0 otherwise.  */\n+\n+static tls_model\n+or1k_tls_symbolic_operand (rtx op)\n+{\n+  rtx sym, addend;\n+  split_const (op, &sym, &addend);\n+  if (SYMBOL_REF_P (sym))\n+    return SYMBOL_REF_TLS_MODEL (sym);\n+  return TLS_MODEL_NONE;\n+}\n+\n+/* Get a reference to the '__tls_get_addr' symbol.  */\n+\n+static GTY(()) rtx gen_tls_tga;\n+\n+static rtx\n+gen_tls_get_addr (void)\n+{\n+  if (!gen_tls_tga)\n+    gen_tls_tga = init_one_libfunc (\"__tls_get_addr\");\n+  return gen_tls_tga;\n+}\n+\n+/* Emit a call to '__tls_get_addr'.  */\n+\n+static void\n+or1k_tls_call (rtx dest, rtx arg)\n+{\n+  emit_library_call_value (gen_tls_get_addr (), dest, LCT_CONST,\n+\t\t\t   Pmode, arg, Pmode);\n+}\n+\n+/* Helper for or1k_legitimize_address_1.  Wrap X in an unspec.  */\n+\n+static rtx\n+gen_sym_unspec (rtx x, int kind)\n+{\n+  return gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x), kind);\n+}\n+\n+/* Worker for TARGET_LEGITIMIZE_ADDRESS_DISPLACEMENT.\n+   Split an out-of-range address displacement into hi and lo parts.\n+   The hi part will have to be loaded into a register separately,\n+   but the low part will be folded into the memory operand.  */\n+\n+static bool\n+or1k_legitimize_address_displacement (rtx *off1, rtx *off2,\n+\t\t\t\t      poly_int64 poly_offset, machine_mode)\n+{\n+  HOST_WIDE_INT orig_offset = poly_offset;\n+  HOST_WIDE_INT lo, hi;\n+\n+  /* If the displacement is within range of 2 addi insns, prefer that.\n+     Otherwise split as per normal, at which point the register allocator\n+     will see that OFF1 is not a valid add3 operand and load it into\n+     a register, as desired.  */\n+  if (orig_offset >= 0 && orig_offset < 2 * 32767)\n+    {\n+      hi = 32767;\n+      lo = orig_offset - hi;\n+    }\n+  else if (orig_offset < 0 && orig_offset >= 2 * -32768)\n+    {\n+      hi = -32768;\n+      lo = orig_offset - hi;\n+    }\n+  else\n+    {\n+      lo = sext_hwi (orig_offset, 16);\n+      hi = orig_offset - lo;\n+    }\n+\n+  *off1 = GEN_INT (hi);\n+  *off2 = GEN_INT (lo);\n+  return true;\n+}\n+\n+#undef  TARGET_LEGITIMIZE_ADDRESS_DISPLACEMENT\n+#define TARGET_LEGITIMIZE_ADDRESS_DISPLACEMENT \\\n+  or1k_legitimize_address_displacement\n+\n+/* Helper function to implement both TARGET_LEGITIMIZE_ADDRESS and expand the\n+   patterns \"movqi\", \"movqi\" and \"movsi\".  Returns an valid OpenRISC RTX that\n+   represents the argument X which is an invalid address RTX.  The argument\n+   SCRATCH may be used as a temporary when building addresses.  */\n+\n+static rtx\n+or1k_legitimize_address_1 (rtx x, rtx scratch)\n+{\n+  rtx base, addend, t1, t2;\n+  tls_model tls_kind = TLS_MODEL_NONE;\n+  bool is_local = true;\n+\n+  split_const (x, &base, &addend);\n+  switch (GET_CODE (base))\n+    {\n+    default:\n+      gcc_assert (can_create_pseudo_p ());\n+      base = force_reg (Pmode, base);\n+      break;\n+\n+    case REG:\n+    case SUBREG:\n+      break;\n+\n+    case SYMBOL_REF:\n+      tls_kind = SYMBOL_REF_TLS_MODEL (base);\n+      is_local = SYMBOL_REF_LOCAL_P (base);\n+      /* FALLTHRU */\n+\n+    case LABEL_REF:\n+      switch (tls_kind)\n+\t{\n+\tcase TLS_MODEL_NONE:\n+\t  t1 = can_create_pseudo_p () ? gen_reg_rtx (Pmode) : scratch;\n+\t  if (!flag_pic)\n+\t    {\n+\t      emit_insn (gen_rtx_SET (t1, gen_rtx_HIGH (Pmode, x)));\n+\t      return gen_rtx_LO_SUM (Pmode, t1, x);\n+\t    }\n+\t  else if (is_local)\n+\t    {\n+\t      crtl->uses_pic_offset_table = 1;\n+\t      t2 = gen_sym_unspec (x, UNSPEC_GOTOFF);\n+\t      emit_insn (gen_rtx_SET (t1, gen_rtx_HIGH (Pmode, t2)));\n+\t      emit_insn (gen_add3_insn (t1, t1, pic_offset_table_rtx));\n+\t      return gen_rtx_LO_SUM (Pmode, t1, copy_rtx (t2));\n+\t    }\n+\t  else\n+\t    {\n+\t      base = gen_sym_unspec (base, UNSPEC_GOT);\n+\t      crtl->uses_pic_offset_table = 1;\n+\t      t2 = gen_rtx_LO_SUM (Pmode, pic_offset_table_rtx, base);\n+\t      t2 = gen_const_mem (Pmode, t2);\n+\t      emit_insn (gen_rtx_SET (t1, t2));\n+\t      base = t1;\n+\t    }\n+\t  break;\n+\n+\tcase TLS_MODEL_GLOBAL_DYNAMIC:\n+\tcase TLS_MODEL_LOCAL_DYNAMIC:\n+\t  /* TODO: For now, treat LD as GD.  */\n+\t  t1 = gen_reg_rtx (Pmode);\n+\t  base = gen_sym_unspec (base, UNSPEC_TLSGD);\n+\t  emit_insn (gen_rtx_SET (t1, gen_rtx_HIGH (Pmode, base)));\n+\t  emit_insn (gen_rtx_SET (t1, gen_rtx_LO_SUM (Pmode, t1, base)));\n+\t  crtl->uses_pic_offset_table = 1;\n+\t  emit_insn (gen_add3_insn (t1, t1, pic_offset_table_rtx));\n+\t  base = gen_reg_rtx (Pmode);\n+\t  or1k_tls_call (base, t1);\n+\t  break;\n+\n+\tcase TLS_MODEL_INITIAL_EXEC:\n+\t  t1 = gen_reg_rtx (Pmode);\n+\t  t2 = gen_reg_rtx (Pmode);\n+\t  base = gen_sym_unspec (base, UNSPEC_GOTTPOFF);\n+\t  emit_insn (gen_rtx_SET (t1, gen_rtx_HIGH (Pmode, base)));\n+\t  crtl->uses_pic_offset_table = 1;\n+\t  emit_insn (gen_add3_insn (t1, t1, pic_offset_table_rtx));\n+\t  t1 = gen_rtx_LO_SUM (Pmode, t1, base);\n+\t  emit_move_insn (t2, gen_const_mem (Pmode, t1));\n+\t  t1 = gen_rtx_REG (Pmode, TLS_REGNUM);\n+\t  emit_insn (gen_add3_insn (t2, t2, t1));\n+\t  base = t2;\n+\t  break;\n+\n+\tcase TLS_MODEL_LOCAL_EXEC:\n+\t  x = gen_sym_unspec (x, UNSPEC_TPOFF);\n+\t  t1 = gen_reg_rtx (Pmode);\n+\t  emit_insn (gen_rtx_SET (t1, gen_rtx_HIGH (Pmode, x)));\n+\t  t2 = gen_rtx_REG (Pmode, TLS_REGNUM);\n+\t  emit_insn (gen_add3_insn (t1, t1, t2));\n+\t  return gen_rtx_LO_SUM (Pmode, t1, x);\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n+\n+    /* Accept what we may have already emitted.  */\n+\n+    case LO_SUM:\n+    case UNSPEC:\n+      return x;\n+    }\n+\n+  /* If we get here, we still have addend outstanding.  */\n+  gcc_checking_assert (register_operand (base, Pmode));\n+  if (addend == const0_rtx)\n+    return base;\n+  if (satisfies_constraint_I (addend)\n+      || virtual_frame_reg_operand (base, VOIDmode))\n+    return gen_rtx_PLUS (Pmode, base, addend);\n+  else\n+    {\n+      rtx hi, lo;\n+      bool ok = (or1k_legitimize_address_displacement\n+\t\t (&hi, &lo, INTVAL (addend), SImode));\n+      gcc_assert (ok);\n+\n+      t2 = can_create_pseudo_p () ? gen_reg_rtx (Pmode) : scratch;\n+      if (satisfies_constraint_I (hi))\n+\temit_insn (gen_addsi3 (t2, base, hi));\n+      else\n+\t{\n+\t  t1 = can_create_pseudo_p () ? gen_reg_rtx (Pmode) : scratch;\n+\t  emit_move_insn (t1, hi);\n+\t  emit_insn (gen_add3_insn (t2, base, t1));\n+\t}\n+      if (lo == const0_rtx)\n+\treturn t2;\n+      else\n+\treturn gen_rtx_PLUS (Pmode, t2, lo);\n+    }\n+}\n+\n+/* Worker for TARGET_LEGITIMIZE_ADDRESS.\n+   This delegates implementation to or1k_legitimize_address_1.  */\n+\n+static rtx\n+or1k_legitimize_address (rtx x, rtx /* oldx */, machine_mode)\n+{\n+  return or1k_legitimize_address_1 (x, NULL_RTX);\n+}\n+\n+#undef  TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS or1k_legitimize_address\n+\n+/* Worker for TARGET_DELEGITIMIZE_ADDRESS.\n+   In the name of slightly smaller debug output, and to cater to\n+   general assembler lossage, recognize PIC+GOTOFF and turn it back\n+   into a direct symbol reference.  */\n+\n+static rtx\n+or1k_delegitimize_address (rtx x)\n+{\n+  if (GET_CODE (x) == UNSPEC)\n+    {\n+      /* The LO_SUM to which X was attached has been stripped.\n+\t Since the only legitimate address we could have been computing\n+\t is that of the symbol, assume that's what we've done.  */\n+      if (XINT (x, 1) == UNSPEC_GOTOFF)\n+\treturn XVECEXP (x, 0, 0);\n+    }\n+  else if (MEM_P (x))\n+    {\n+      rtx addr = XEXP (x, 0);\n+      if (GET_CODE (addr) == LO_SUM\n+\t  && XEXP (addr, 0) == pic_offset_table_rtx)\n+\t{\n+\t  rtx inner = XEXP (addr, 1);\n+\t  if (GET_CODE (inner) == UNSPEC\n+\t      && XINT (inner, 1) == UNSPEC_GOT)\n+\t    return XVECEXP (inner, 0, 0);\n+\t}\n+    }\n+  return delegitimize_mem_from_attrs (x);\n+}\n+\n+#undef  TARGET_DELEGITIMIZE_ADDRESS\n+#define TARGET_DELEGITIMIZE_ADDRESS or1k_delegitimize_address\n+\n+/* Worker for TARGET_CANNOT_FORCE_CONST_MEM.\n+   Primarily this is required for TLS symbols, but given that our move\n+   patterns *ought* to be able to handle any symbol at any time, we\n+   should never be spilling symbolic operands to the constant pool, ever.  */\n+\n+static bool\n+or1k_cannot_force_const_mem (machine_mode, rtx x)\n+{\n+  rtx_code code = GET_CODE (x);\n+  return (code == SYMBOL_REF\n+\t  || code == LABEL_REF\n+\t  || code == CONST\n+\t  || code == HIGH);\n+}\n+\n+#undef  TARGET_CANNOT_FORCE_CONST_MEM\n+#define TARGET_CANNOT_FORCE_CONST_MEM or1k_cannot_force_const_mem\n+\n+/* Worker for TARGET_LEGITIMATE_CONSTANT_P.\n+   Returns true is the RTX X represents a constant that can be used as an\n+   immediate operand in OpenRISC.  */\n+\n+static bool\n+or1k_legitimate_constant_p (machine_mode, rtx x)\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case CONST_INT:\n+    case CONST_WIDE_INT:\n+    case HIGH:\n+      /* We construct these, rather than spilling to memory.  */\n+      return true;\n+\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      /* These may need to be split and not reconstructed.  */\n+      return or1k_tls_symbolic_operand (x) == TLS_MODEL_NONE;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+#undef  TARGET_LEGITIMATE_CONSTANT_P\n+#define TARGET_LEGITIMATE_CONSTANT_P or1k_legitimate_constant_p\n+\n+/* Worker for TARGET_PASS_BY_REFERENCE.\n+   Returns true if an argument of TYPE in MODE should be passed by reference\n+   as required by the OpenRISC ABI.  On OpenRISC structures, unions and\n+   arguments larger than 64-bits are passed by reference.  */\n+\n+static bool\n+or1k_pass_by_reference (cumulative_args_t, machine_mode mode,\n+\t\t\tconst_tree type, bool)\n+{\n+  HOST_WIDE_INT size;\n+  if (type)\n+    {\n+      if (AGGREGATE_TYPE_P (type))\n+\treturn true;\n+      size = int_size_in_bytes (type);\n+    }\n+  else\n+    size = GET_MODE_SIZE (mode);\n+  return size < 0 || size > 8;\n+}\n+\n+/* Worker for TARGET_FUNCTION_VALUE.\n+   Returns an RTX representing the location where function return values will\n+   be stored.  On OpenRISC this is the register r11.  64-bit return value's\n+   upper 32-bits are returned in r12, this is automatically done by GCC.  */\n+\n+static rtx\n+or1k_function_value (const_tree valtype,\n+\t\t     const_tree /* fn_decl_or_type */,\n+\t\t     bool /* outgoing */)\n+{\n+  return gen_rtx_REG (TYPE_MODE (valtype), RV_REGNUM);\n+}\n+\n+/* Worker for TARGET_LIBCALL_VALUE.\n+   Returns an RTX representing the location where function return values to\n+   external libraries will be stored.  On OpenRISC this the same as local\n+   function calls.  */\n+\n+static rtx\n+or1k_libcall_value (machine_mode mode,\n+\t\t    const_rtx /* fun */)\n+{\n+  return gen_rtx_REG (mode, RV_REGNUM);\n+}\n+\n+\n+/* Worker for TARGET_FUNCTION_VALUE_REGNO_P.\n+   Returns true if REGNO is a valid register for storing a function return\n+   value.  */\n+\n+static bool\n+or1k_function_value_regno_p (const unsigned int regno)\n+{\n+  return (regno == RV_REGNUM);\n+}\n+\n+/* Worker for TARGET_STRICT_ARGUMENT_NAMING.\n+   Return true always as on OpenRISC the last argument in a variatic function\n+   is named.  */\n+\n+static bool\n+or1k_strict_argument_naming (cumulative_args_t /* ca */)\n+{\n+  return true;\n+}\n+\n+#undef  TARGET_STRICT_ARGUMENT_NAMING\n+#define TARGET_STRICT_ARGUMENT_NAMING or1k_strict_argument_naming\n+\n+/* Worker for TARGET_FUNCTION_ARG.\n+   Return the next register to be used to hold a function argument or NULL_RTX\n+   if there's no more space.  Arugment CUM_V represents the current argument\n+   offset, zero for the first function argument.  OpenRISC function arguments\n+   maybe be passed in registers r3 to r8.  */\n+\n+static rtx\n+or1k_function_arg (cumulative_args_t cum_v, machine_mode mode,\n+\t\t   const_tree /* type */, bool named)\n+{\n+  /* VOIDmode is passed as a special flag for \"last argument\".  */\n+  if (mode == VOIDmode)\n+    return NULL_RTX;\n+\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+  int nreg = CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);\n+\n+  /* Note that all large arguments are passed by reference.  */\n+  gcc_assert (nreg <= 2);\n+  if (named && *cum + nreg <= 6)\n+    return gen_rtx_REG (mode, *cum + 3);\n+  else\n+    return NULL_RTX;\n+}\n+\n+/* Worker for TARGET_FUNCTION_ARG_ADVANCE.\n+   Update the cumulative args descriptor CUM_V to advance past the next function\n+   argument.  Note, this is not called for arguments passed on the stack.  */\n+\n+static void\n+or1k_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n+\t\t\t   const_tree /* type */, bool named)\n+{\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+  int nreg = CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);\n+\n+  /* Note that all large arguments are passed by reference.  */\n+  gcc_assert (nreg <= 2);\n+  if (named)\n+    *cum += nreg;\n+}\n+\n+/* worker function for TARGET_RETURN_IN_MEMORY.\n+   Returns true if the argument of TYPE should be returned in memory.  On\n+   OpenRISC this is any value larger than 64-bits.  */\n+\n+static bool\n+or1k_return_in_memory (const_tree type, const_tree /* fntype */)\n+{\n+  const HOST_WIDE_INT size = int_size_in_bytes (type);\n+  return (size == -1 || size > (2 * UNITS_PER_WORD));\n+}\n+\n+/* Print reloc (x + add).  */\n+\n+static void\n+output_addr_reloc (FILE *stream, rtx x, HOST_WIDE_INT add, const char *reloc)\n+{\n+  if (*reloc)\n+    {\n+      fputs (reloc, stream);\n+      fputc ('(', stream);\n+    }\n+  output_addr_const (stream, x);\n+  if (add)\n+    {\n+      if (add > 0)\n+\tfputc ('+', stream);\n+      fprintf (stream, HOST_WIDE_INT_PRINT_DEC, add);\n+    }\n+  if (*reloc)\n+    fputc (')', stream);\n+}\n+\n+enum reloc_kind\n+{\n+  RKIND_LO,\n+  RKIND_HI,\n+  RKIND_MAX\n+};\n+\n+enum reloc_type\n+{\n+  RTYPE_DIRECT,\n+  RTYPE_GOT,\n+  RTYPE_GOTOFF,\n+  RTYPE_TPOFF,\n+  RTYPE_GOTTPOFF,\n+  RTYPE_TLSGD,\n+  RTYPE_MAX\n+};\n+\n+static void\n+print_reloc (FILE *stream, rtx x, HOST_WIDE_INT add, reloc_kind kind)\n+{\n+  /* All data relocations.  A NULL in this table indicates a form that\n+     we expect to never generate, while \"\" indicates a form that requires\n+     no special markup.  */\n+  static const char * const relocs[RKIND_MAX][RTYPE_MAX] = {\n+    { \"lo\", \"got\", \"gotofflo\", \"tpofflo\", \"gottpofflo\", \"tlsgdlo\" },\n+    { \"ha\", NULL,  \"gotoffha\", \"tpoffha\", \"gottpoffha\", \"tlsgdhi\" },\n+  };\n+  reloc_type type = RTYPE_DIRECT;\n+\n+  if (GET_CODE (x) == UNSPEC)\n+    {\n+      switch (XINT (x, 1))\n+\t{\n+\tcase UNSPEC_GOT:\n+\t  type = RTYPE_GOT;\n+\t  break;\n+\tcase UNSPEC_GOTOFF:\n+\t  type = RTYPE_GOTOFF;\n+\t  break;\n+\tcase UNSPEC_TPOFF:\n+\t  type = RTYPE_TPOFF;\n+\t  break;\n+\tcase UNSPEC_GOTTPOFF:\n+\t  type = RTYPE_GOTTPOFF;\n+\t  break;\n+\tcase UNSPEC_TLSGD:\n+\t  type = RTYPE_TLSGD;\n+\t  break;\n+\tdefault:\n+\t  output_operand_lossage (\"invalid relocation\");\n+\t  return;\n+\t}\n+      x = XVECEXP (x, 0, 0);\n+    }\n+\n+  const char *reloc = relocs[kind][type];\n+  if (reloc == NULL)\n+    output_operand_lossage (\"invalid relocation\");\n+  else\n+    output_addr_reloc (stream, x, add, reloc);\n+}\n+\n+/* Worker for TARGET_PRINT_OPERAND_ADDRESS.\n+   Prints the argument ADDR, an address RTX, to the file FILE.  The output is\n+   formed as expected by the OpenRISC assembler.  Examples:\n+\n+     RTX\t\t\t\t\t\t\t      OUTPUT\n+     (reg:SI 3)\t\t\t\t\t\t\t       0(r3)\n+     (plus:SI (reg:SI 3) (const_int 4))\t\t\t\t     0x4(r3)\n+     (lo_sum:SI (reg:SI 3) (symbol_ref:SI (\"x\"))))\t\t   lo(x)(r3)  */\n+\n+static void\n+or1k_print_operand_address (FILE *file, machine_mode, rtx addr)\n+{\n+  rtx offset;\n+\n+  switch (GET_CODE (addr))\n+    {\n+    case REG:\n+      fputc ('0', file);\n+      break;\n+\n+    case PLUS:\n+      offset = XEXP (addr, 1);\n+      addr = XEXP (addr, 0);\n+      gcc_assert (CONST_INT_P (offset));\n+      if (GET_CODE (addr) == LO_SUM)\n+\t{\n+\t  print_reloc (file, XEXP (addr, 1), INTVAL (offset), RKIND_LO);\n+\t  addr = XEXP (addr, 0);\n+\t}\n+      else\n+\toutput_addr_const (file, offset);\n+      break;\n+\n+    case LO_SUM:\n+      offset = XEXP (addr, 1);\n+      addr = XEXP (addr, 0);\n+      print_reloc (file, offset, 0, RKIND_LO);\n+      break;\n+\n+    default:\n+      output_addr_const (file, addr);\n+      return;\n+    }\n+\n+  fprintf (file, \"(%s)\", reg_names[REGNO (addr)]);\n+}\n+\n+/* Worker for TARGET_PRINT_OPERAND.\n+   Print operand X, an RTX, to the file FILE.  The output is formed as expected\n+   by the OpenRISC assember.  CODE is the letter following a '%' in an\n+   instrunction template used to control the RTX output.  Example(s):\n+\n+     CODE   RTX                   OUTPUT     COMMENT\n+     0      (reg:SI 3)                r3     output an operand\n+     r      (reg:SI 3)                r3     output a register or const zero\n+     H      (reg:SI 3)                r4     output the high pair register\n+     h      (symbol_ref:SI (\"x\"))  ha(x)     output a signed high relocation\n+     L      (symbol_ref:SI (\"x\"))  lo(x)     output a low relocation\n+\n+   Note, '#' is a special code used to fill the branch delay slot with an l.nop\n+   instruction.  The l.nop (no-op) instruction is only outputted when the delay\n+   slot has not been filled.  */\n+\n+static void\n+or1k_print_operand (FILE *file, rtx x, int code)\n+{\n+  rtx operand = x;\n+\n+  switch (code)\n+    {\n+    case '#':\n+      /* Conditionally add a nop in unfilled delay slot.  */\n+      if (final_sequence == NULL)\n+\tfputs (\"\\n\\t l.nop\\n\", file);\n+      break;\n+\n+    case 'r':\n+      if (REG_P (x))\n+\tfprintf (file, \"%s\", reg_names[REGNO (operand)]);\n+      else if (x == CONST0_RTX (GET_MODE (x)))\n+\tfprintf (file, \"r0\");\n+      else\n+\toutput_operand_lossage (\"invalid %%r value\");\n+      break;\n+\n+    case 'H':\n+      if (REG_P (x))\n+\tfprintf (file, \"%s\", reg_names[REGNO (operand) + 1]);\n+      else\n+\toutput_operand_lossage (\"invalid %%H value\");\n+      break;\n+\n+    case 'h':\n+      print_reloc (file, x, 0, RKIND_HI);\n+      break;\n+    case 'L':\n+      print_reloc (file, x, 0, RKIND_LO);\n+      break;\n+    case 'P':\n+      if (!flag_pic || SYMBOL_REF_LOCAL_P (x))\n+\toutput_addr_const (file, x);\n+      else\n+\toutput_addr_reloc (file, x, 0, \"plt\");\n+      break;\n+\n+    case 0:\n+      /* Print an operand as without a modifier letter.  */\n+      switch (GET_CODE (operand))\n+\t{\n+\tcase REG:\n+\t  if (REGNO (operand) > 31)\n+\t    internal_error (\"internal error: bad register: %d\",\n+\t\t\t    REGNO (operand));\n+\t  fprintf (file, \"%s\", reg_names[REGNO (operand)]);\n+\t  break;\n+\n+\tcase MEM:\n+\t  output_address (GET_MODE (XEXP (operand, 0)), XEXP (operand, 0));\n+\t  break;\n+\n+\tcase CODE_LABEL:\n+\tcase LABEL_REF:\n+\t  output_asm_label (operand);\n+\t  break;\n+\n+\tdefault:\n+\t  /* No need to handle all strange variants, let output_addr_const\n+\t     do it for us.  */\n+\t  if (CONSTANT_P (operand))\n+\t    output_addr_const (file, operand);\n+\t  else\n+\t    internal_error (\"unexpected operand: %d\", GET_CODE (operand));\n+\t  break;\n+\t}\n+      break;\n+\n+    default:\n+      output_operand_lossage (\"unknown operand letter: '%c'\", code);\n+      break;\n+    }\n+}\n+\n+/* Worker for TARGET_TRAMPOLINE_INIT.\n+   This is called to initialize a trampoline.  The argument M_TRAMP is an RTX\n+   for the memory block to be initialized with trampoline code.  The argument\n+   FNDECL contains the definition of the nested function to be called, we use\n+   this to get the function's address.  The argument CHAIN is an RTX for the\n+   static chain value to be passed to the nested function.  */\n+\n+static void\n+or1k_trampoline_init (rtx m_tramp, tree fndecl, rtx chain)\n+{\n+  const unsigned movhi_r13 = (0x06u << 26) | (13 << 21);\n+  const unsigned movhi_r11 = (0x06u << 26) | (11 << 21);\n+  const unsigned ori_r13_r13 = (0x2a << 26) | (13 << 21) | (13 << 16);\n+  const unsigned ori_r11_r11 = (0x2a << 26) | (11 << 21) | (11 << 16);\n+  const unsigned jr_r13 = (0x11 << 26) | (13 << 11);\n+  rtx tramp[5], fnaddr, f_hi, f_lo, c_hi, c_lo;\n+\n+  fnaddr = force_operand (XEXP (DECL_RTL (fndecl), 0), NULL);\n+  f_hi = expand_binop (SImode, lshr_optab, fnaddr, GEN_INT (16),\n+\t\t       NULL, true, OPTAB_DIRECT);\n+  f_lo = expand_binop (SImode, and_optab, fnaddr, GEN_INT (0xffff),\n+\t\t       NULL, true, OPTAB_DIRECT);\n+\n+  chain = force_operand (chain, NULL);\n+  c_hi = expand_binop (SImode, lshr_optab, chain, GEN_INT (16),\n+\t\t       NULL, true, OPTAB_DIRECT);\n+  c_lo = expand_binop (SImode, and_optab, chain, GEN_INT (0xffff),\n+\t\t       NULL, true, OPTAB_DIRECT);\n+\n+  /* We want to generate\n+\n+\tl.movhi r13,hi(nested_func)\n+\tl.movhi r11,hi(static_chain)\n+\tl.ori\tr13,r13,lo(nested_func)\n+\tl.jr\tr13\n+\t l.ori\tr11,r11,lo(static_chain)\n+   */\n+  tramp[0] = expand_binop (SImode, ior_optab, f_hi,\n+\t\t\t   gen_int_mode (movhi_r13, SImode),\n+\t\t\t   f_hi, true, OPTAB_DIRECT);\n+  tramp[1] = expand_binop (SImode, ior_optab, c_hi,\n+\t\t\t   gen_int_mode (movhi_r11, SImode),\n+\t\t\t   c_hi, true, OPTAB_DIRECT);\n+  tramp[2] = expand_binop (SImode, ior_optab, f_lo,\n+\t\t\t   gen_int_mode (ori_r13_r13, SImode),\n+\t\t\t   f_lo, true, OPTAB_DIRECT);\n+  tramp[4] = expand_binop (SImode, ior_optab, c_lo,\n+\t\t\t   gen_int_mode (ori_r11_r11, SImode),\n+\t\t\t   c_lo, true, OPTAB_DIRECT);\n+  tramp[3] = gen_int_mode (jr_r13, SImode);\n+\n+  for (int i = 0; i < 5; ++i)\n+    {\n+      rtx mem = adjust_address (m_tramp, SImode, i * 4);\n+      emit_move_insn (mem, tramp[i]);\n+    }\n+\n+  /* Flushing the trampoline from the instruction cache needs\n+     to be done here. */\n+}\n+\n+/* Worker for TARGET_HARD_REGNO_MODE_OK.\n+   Returns true if the hard register REGNO is ok for storing values of mode\n+   MODE.  */\n+\n+static bool\n+or1k_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n+{\n+  /* For OpenRISC, GENERAL_REGS can hold anything, while\n+     FLAG_REGS are really single bits within SP[SR].  */\n+  if (REGNO_REG_CLASS (regno) == FLAG_REGS)\n+    return mode == BImode;\n+  return true;\n+}\n+\n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK or1k_hard_regno_mode_ok\n+\n+/* Worker for TARGET_CAN_CHANGE_MODE_CLASS.\n+   Returns true if its ok to change a register in class RCLASS from mode FROM to\n+   mode TO.  In general OpenRISC registers, other than special flags, handle all\n+   supported classes.  */\n+\n+static bool\n+or1k_can_change_mode_class (machine_mode from, machine_mode to,\n+\t\t\t    reg_class_t rclass)\n+{\n+  if (rclass == FLAG_REGS)\n+    return from == to;\n+  return true;\n+}\n+\n+#undef TARGET_CAN_CHANGE_MODE_CLASS\n+#define TARGET_CAN_CHANGE_MODE_CLASS or1k_can_change_mode_class\n+\n+/* Expand the patterns \"movqi\", \"movqi\" and \"movsi\".  The argument OP0 is the\n+   destination and OP1 is the source.  This expands to set OP0 to OP1.  OpenRISC\n+   cannot do memory to memory assignments so for those cases we force one\n+   argument to a register.  Constants that can't fit into a 16-bit immediate are\n+   split.  Symbols are legitimized using split relocations.  */\n+\n+void\n+or1k_expand_move (machine_mode mode, rtx op0, rtx op1)\n+{\n+  if (MEM_P (op0))\n+    {\n+      if (!const0_operand (op1, mode))\n+\top1 = force_reg (mode, op1);\n+    }\n+  else if (mode == QImode || mode == HImode)\n+    {\n+      /* ??? Maybe promote MEMs and CONST_INT to SImode,\n+\t and then squish back with gen_lowpart.  */\n+    }\n+  else\n+    {\n+      switch (GET_CODE (op1))\n+\t{\n+\tcase CONST_INT:\n+\t  if (!input_operand (op1, mode))\n+\t    {\n+\t      HOST_WIDE_INT i = INTVAL (op1);\n+\t      HOST_WIDE_INT lo = i & 0xffff;\n+\t      HOST_WIDE_INT hi = i ^ lo;\n+\t      rtx subtarget = op0;\n+\n+\t      if (!cse_not_expected && can_create_pseudo_p ())\n+\t\tsubtarget = gen_reg_rtx (SImode);\n+\t      emit_insn (gen_rtx_SET (subtarget, GEN_INT (hi)));\n+\t      emit_insn (gen_iorsi3 (op0, subtarget, GEN_INT (lo)));\n+\t      return;\n+\t    }\n+\t  break;\n+\n+\tcase CONST:\n+\tcase SYMBOL_REF:\n+\tcase LABEL_REF:\n+\t  op1 = or1k_legitimize_address_1 (op1, op0);\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  emit_insn (gen_rtx_SET (op0, op1));\n+}\n+\n+/* Used to expand patterns \"movsicc\", \"movqicc\", \"movhicc\", \"cstoresi4\" and\n+   \"cbranchsi4\".\n+   Expands a comparison where OPERANDS is an array of RTX describing the\n+   comparison.  The first argument OPERANDS[0] is the operator and OPERANDS[1]\n+   and OPERANDS[2] are the operands.  Split out the compare into SR[F] and\n+   return a new operation in OPERANDS[0].  The inputs OPERANDS[1] and\n+   OPERANDS[2] are not directly used, only overridden.  */\n+\n+void\n+or1k_expand_compare (rtx *operands)\n+{\n+  rtx sr_f = gen_rtx_REG (BImode, SR_F_REGNUM);\n+\n+  /* The RTL may receive an immediate in argument 1 of the compare, this is not\n+     supported unless we have l.sf*i instructions, force them into registers.  */\n+  if (!TARGET_SFIMM)\n+    XEXP (operands[0], 1) = force_reg (SImode, XEXP (operands[0], 1));\n+\n+  /* Emit the given comparison into the Flag bit.  */\n+  PUT_MODE (operands[0], BImode);\n+  emit_insn (gen_rtx_SET (sr_f, operands[0]));\n+\n+  /* Adjust the operands for use in the caller.  */\n+  operands[0] = gen_rtx_NE (VOIDmode, sr_f, const0_rtx);\n+  operands[1] = sr_f;\n+  operands[2] = const0_rtx;\n+}\n+\n+/* Expand the patterns \"call\", \"sibcall\", \"call_value\" and \"sibcall_value\".\n+   Expands a function call where argument RETVAL is an optional RTX providing\n+   return value storage, the argument FNADDR is and RTX describing the function\n+   to call, the argument CALLARG1 is the number or registers used as operands\n+   and the argument SIBCALL should be true if this is a nested function call.\n+   If FNADDR is a non local symbol and FLAG_PIC is enabled this will generate\n+   a PLT call.  */\n+\n+void\n+or1k_expand_call (rtx retval, rtx fnaddr, rtx callarg1, bool sibcall)\n+{\n+  rtx call, use = NULL;\n+\n+  /* Calls via the PLT require the PIC register.  */\n+  if (flag_pic\n+      && GET_CODE (XEXP (fnaddr, 0)) == SYMBOL_REF\n+      && !SYMBOL_REF_LOCAL_P (XEXP (fnaddr, 0)))\n+    {\n+      crtl->uses_pic_offset_table = 1;\n+      rtx hard_pic = gen_rtx_REG (Pmode, REAL_PIC_OFFSET_TABLE_REGNUM);\n+      emit_move_insn (hard_pic, pic_offset_table_rtx);\n+      use_reg (&use, hard_pic);\n+    }\n+\n+  if (!call_insn_operand (XEXP (fnaddr, 0), Pmode))\n+    {\n+      fnaddr = copy_to_mode_reg (Pmode, XEXP (fnaddr, 0));\n+      fnaddr = gen_rtx_MEM (SImode, fnaddr);\n+    }\n+\n+  call = gen_rtx_CALL (VOIDmode, fnaddr, callarg1);\n+  if (retval)\n+    call = gen_rtx_SET (retval, call);\n+\n+  /* Normal calls clobber LR.  This is required in order to\n+     prevent e.g. a prologue store of LR being placed into\n+     the delay slot of the call, after it has been updated.  */\n+  if (!sibcall)\n+    {\n+      rtx clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, LR_REGNUM));\n+      call = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, call, clob));\n+    }\n+  call = emit_call_insn (call);\n+\n+  CALL_INSN_FUNCTION_USAGE (call) = use;\n+}\n+\n+/* Worker for TARGET_FUNCTION_OK_FOR_SIBCALL.\n+   Returns true if the function declared by DECL is ok for calling as a nested\n+   function.  */\n+\n+static bool\n+or1k_function_ok_for_sibcall (tree decl, tree /* exp */)\n+{\n+  /* We can sibcall to any function if not PIC.  */\n+  if (!flag_pic)\n+    return true;\n+\n+  /* We can sibcall any indirect function.  */\n+  if (decl == NULL)\n+    return true;\n+\n+  /* If the call may go through the PLT, we need r16 live.  */\n+  return targetm.binds_local_p (decl);\n+}\n+\n+#undef TARGET_FUNCTION_OK_FOR_SIBCALL\n+#define TARGET_FUNCTION_OK_FOR_SIBCALL or1k_function_ok_for_sibcall\n+\n+/* Worker for TARGET_RTX_COSTS.  */\n+\n+static bool\n+or1k_rtx_costs (rtx x, machine_mode mode, int outer_code, int /* opno */,\n+\t\tint *total, bool /* speed */)\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case CONST_INT:\n+      if (x == const0_rtx)\n+\t*total = 0;\n+      else if ((outer_code == PLUS || outer_code == XOR || outer_code == MULT)\n+\t       && satisfies_constraint_I (x))\n+\t*total = 0;\n+      else if ((outer_code == AND || outer_code == IOR)\n+\t       && satisfies_constraint_K (x))\n+\t*total = 0;\n+      else if (satisfies_constraint_I (x)\n+\t       || satisfies_constraint_K (x)\n+\t       || satisfies_constraint_M (x))\n+\t*total = 2;\n+      else\n+\t*total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      *total = (x == CONST0_RTX (mode) ? 0 : COSTS_N_INSNS (2));\n+      return true;\n+\n+    case HIGH:\n+      /* This is effectively an 'M' constraint.  */\n+      *total = 2;\n+      return true;\n+\n+    case LO_SUM:\n+      /* This is effectively an 'I' constraint.  */\n+      *total = (outer_code == MEM ? 0 : 2);\n+      return true;\n+\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      if (outer_code == LO_SUM || outer_code == HIGH)\n+\t*total = 0;\n+      else\n+\t{\n+\t  /* ??? Extra cost for GOT or TLS symbols.  */\n+\t  *total = COSTS_N_INSNS (1 + (outer_code != MEM));\n+\t}\n+      return true;\n+\n+    case PLUS:\n+      if (outer_code == MEM)\n+\t*total = 0;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS or1k_rtx_costs\n+\n+\n+/* A subroutine of the atomic operation splitters.  Jump to LABEL if\n+   COND is true.  Mark the jump as unlikely to be taken.  */\n+\n+static void\n+emit_unlikely_jump (rtx_code code, rtx label)\n+{\n+  rtx x;\n+\n+  x = gen_rtx_REG (BImode, SR_F_REGNUM);\n+  x = gen_rtx_fmt_ee (code, VOIDmode, x, const0_rtx);\n+  x = gen_rtx_IF_THEN_ELSE (VOIDmode, x, label, pc_rtx);\n+  emit_jump_insn (gen_rtx_SET (pc_rtx, x));\n+\n+  // Disable this for now -- producing verify_cfg failures on probabilities.\n+  // int very_unlikely = REG_BR_PROB_BASE / 100 - 1;\n+  // add_int_reg_note (insn, REG_BR_PROB, very_unlikely);\n+}\n+\n+/* A subroutine of the atomic operation splitters.\n+   Emit a raw comparison for A CODE B.  */\n+\n+static void\n+emit_compare (rtx_code code, rtx a, rtx b)\n+{\n+  emit_insn (gen_rtx_SET (gen_rtx_REG (BImode, SR_F_REGNUM),\n+\t\t\t  gen_rtx_fmt_ee (code, BImode, a, b)));\n+}\n+\n+/* A subroutine of the atomic operation splitters.\n+   Emit a load-locked instruction in MODE.  */\n+\n+static void\n+emit_load_locked (machine_mode mode, rtx reg, rtx mem)\n+{\n+  gcc_assert (mode == SImode);\n+  emit_insn (gen_load_locked_si (reg, mem));\n+}\n+\n+/* A subroutine of the atomic operation splitters.\n+   Emit a store-conditional instruction in MODE.  */\n+\n+static void\n+emit_store_conditional (machine_mode mode, rtx mem, rtx val)\n+{\n+  gcc_assert (mode == SImode);\n+  emit_insn (gen_store_conditional_si (mem, val));\n+}\n+\n+/* A subroutine of the various atomic expanders.  For sub-word operations,\n+   we must adjust things to operate on SImode.  Given the original MEM,\n+   return a new aligned memory.  Also build and return the quantities by\n+   which to shift and mask.  */\n+\n+static rtx\n+or1k_adjust_atomic_subword (rtx orig_mem, rtx *pshift, rtx *pmask)\n+{\n+  rtx addr, align, shift, mask, mem;\n+  machine_mode mode = GET_MODE (orig_mem);\n+\n+  addr = XEXP (orig_mem, 0);\n+  addr = force_reg (Pmode, addr);\n+\n+  /* Aligned memory containing subword.  Generate a new memory.  We\n+     do not want any of the existing MEM_ATTR data, as we're now\n+     accessing memory outside the original object.  */\n+  align = expand_binop (Pmode, and_optab, addr, GEN_INT (-4),\n+\t\t\tNULL_RTX, 1, OPTAB_LIB_WIDEN);\n+  mem = gen_rtx_MEM (SImode, align);\n+  MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (orig_mem);\n+  if (MEM_ALIAS_SET (orig_mem) == ALIAS_SET_MEMORY_BARRIER)\n+    set_mem_alias_set (mem, ALIAS_SET_MEMORY_BARRIER);\n+\n+  /* Shift amount for subword relative to aligned word.  */\n+  rtx mode_mask = GEN_INT (mode == QImode ? 3 : 2);\n+  shift = expand_binop (SImode, and_optab, gen_lowpart (SImode, addr),\n+\t\t\tmode_mask, NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+  if (BYTES_BIG_ENDIAN)\n+    shift = expand_binop (SImode, xor_optab, shift, mode_mask,\n+\t\t\t  shift, 1, OPTAB_LIB_WIDEN);\n+  shift = expand_binop (SImode, ashl_optab, shift, GEN_INT (3),\n+\t\t\tshift, 1, OPTAB_LIB_WIDEN);\n+  *pshift = shift;\n+\n+  /* Mask for insertion.  */\n+  mask = expand_binop (SImode, ashl_optab, GEN_INT (GET_MODE_MASK (mode)),\n+\t\t       shift, NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+  *pmask = mask;\n+\n+  return mem;\n+}\n+\n+/* A subroutine of the various atomic expanders.  For sub-word operations,\n+   complete the operation by shifting result to the lsb of the SImode\n+   temporary and then extracting the result in MODE with a SUBREG.  */\n+\n+static void\n+or1k_finish_atomic_subword (machine_mode mode, rtx o, rtx n, rtx shift)\n+{\n+  n = expand_binop (SImode, lshr_optab, n, shift,\n+\t\t    NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+  emit_move_insn (o, gen_lowpart (mode, n));\n+}\n+\n+/* Expand an atomic compare and swap operation.\n+   Emits the RTX to perform a compare and swap operation.  This function takes\n+   8 RTX arguments in the OPERANDS array.  The compare and swap operation\n+   loads a value from memory (OPERANDS[2]) and compares it with an expected\n+   value (OPERANDS[3]), if the values are equal it stores a new value\n+   (OPERANDS[4]) to memory.  The argument OPERANDS[0] represents a boolean\n+   result which will be set to true if the operation succeeds.  A return value\n+   (OPERANDS[1]) will be set to what was loaded from memory.  The argument\n+   OPERAND[5] is used to indicate if the compare and swap is to be treated as\n+   weak.  OpenRISC does not use OPERANDS[5] or OPERANDS[6] which provide memory\n+   model details.\n+   For OpenRISC this emits RTX which will translate to assembly using the\n+   'l.lwa' (load word atomic) and 'l.swa' (store word atomic) instructions.  */\n+\n+void\n+or1k_expand_atomic_compare_and_swap (rtx operands[])\n+{\n+  rtx boolval, retval, mem, oldval, newval;\n+  rtx label1, label2;\n+  machine_mode mode;\n+  bool is_weak;\n+\n+  boolval = operands[0];\n+  retval = operands[1];\n+  mem = operands[2];\n+  oldval = operands[3];\n+  newval = operands[4];\n+  is_weak = (INTVAL (operands[5]) != 0);\n+  mode = GET_MODE (mem);\n+\n+  if (reg_overlap_mentioned_p (retval, oldval))\n+    oldval = copy_to_reg (oldval);\n+\n+  label1 = NULL_RTX;\n+  /* If strong, create a label to try again.  */\n+  if (!is_weak)\n+    {\n+      label1 = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());\n+      emit_label (XEXP (label1, 0));\n+    }\n+  label2 = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());\n+\n+  emit_load_locked (mode, retval, mem);\n+  emit_compare (EQ, retval, oldval);\n+  emit_unlikely_jump (EQ, label2);\n+  emit_store_conditional (mode, mem, newval);\n+\n+  /* If strong, jump back to try again on fails.  */\n+  if (!is_weak)\n+    emit_unlikely_jump (EQ, label1);\n+  emit_label (XEXP (label2, 0));\n+\n+  /* In all cases, SR_F contains 1 on success, and 0 on failure.  */\n+  emit_insn (gen_sne_sr_f (boolval));\n+}\n+\n+void\n+or1k_expand_atomic_compare_and_swap_qihi (rtx operands[])\n+{\n+  rtx boolval, orig_retval, retval, scratch, mem, oldval, newval;\n+  rtx label1, label2, mask, shift;\n+  machine_mode mode;\n+  bool is_weak;\n+\n+  boolval = operands[0];\n+  orig_retval = operands[1];\n+  mem = operands[2];\n+  oldval = operands[3];\n+  newval = operands[4];\n+  is_weak = (INTVAL (operands[5]) != 0);\n+  mode = GET_MODE (mem);\n+\n+  mem = or1k_adjust_atomic_subword (mem, &shift, &mask);\n+\n+  /* Shift and mask OLDVAL and NEWVAL into position with the word.  */\n+  if (oldval != const0_rtx)\n+    {\n+      oldval = convert_modes (SImode, mode, oldval, 1);\n+      oldval = expand_binop (SImode, ashl_optab, oldval, shift,\n+\t\t\t     NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+    }\n+  if (newval != const0_rtx)\n+    {\n+      newval = convert_modes (SImode, mode, newval, 1);\n+      newval = expand_binop (SImode, ashl_optab, newval, shift,\n+\t\t\t     NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+    }\n+\n+  label1 = NULL_RTX;\n+  if (!is_weak)\n+    {\n+      label1 = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());\n+      emit_label (XEXP (label1, 0));\n+    }\n+  label2 = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());\n+\n+  scratch = gen_reg_rtx (SImode);\n+  emit_load_locked (SImode, scratch, mem);\n+\n+  retval = expand_binop (SImode, and_optab, scratch, mask,\n+\t\t\t NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+  scratch = expand_binop (SImode, xor_optab, scratch, retval,\n+\t\t\t  scratch, 1, OPTAB_LIB_WIDEN);\n+\n+  emit_compare (EQ, retval, oldval);\n+  emit_unlikely_jump (EQ, label2);\n+\n+  if (newval != const0_rtx)\n+    scratch = expand_binop (SImode, ior_optab, scratch, newval,\n+\t\t\t    scratch, 1, OPTAB_LIB_WIDEN);\n+\n+  emit_store_conditional (SImode, mem, scratch);\n+\n+  if (!is_weak)\n+    emit_unlikely_jump (EQ, label1);\n+  emit_label (XEXP (label2, 0));\n+\n+  or1k_finish_atomic_subword (mode, orig_retval, retval, shift);\n+\n+  /* In all cases, SR_F contains 1 on success, and 0 on failure.  */\n+  emit_insn (gen_sne_sr_f (boolval));\n+}\n+\n+/* Expand an atomic exchange operation.\n+   Emits the RTX to perform an exchange operation.  This function takes 4 RTX\n+   arguments in the OPERANDS array.  The exchange operation atomically loads a\n+   value from memory (OPERANDS[1]) to a return value (OPERANDS[0]) and stores a\n+   new value (OPERANDS[2]) back to the memory location.\n+   Another argument (OPERANDS[3]) is used to indicate the memory model and\n+   is not used by OpenRISC.\n+   For OpenRISC this emits RTX which will translate to assembly using the\n+   'l.lwa' (load word atomic) and 'l.swa' (store word atomic) instructions.  */\n+\n+void\n+or1k_expand_atomic_exchange (rtx operands[])\n+{\n+  rtx retval, mem, val, label;\n+  machine_mode mode;\n+\n+  retval = operands[0];\n+  mem = operands[1];\n+  val = operands[2];\n+  mode = GET_MODE (mem);\n+\n+  if (reg_overlap_mentioned_p (retval, val))\n+    val = copy_to_reg (val);\n+\n+  label = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());\n+  emit_label (XEXP (label, 0));\n+\n+  emit_load_locked (mode, retval, mem);\n+  emit_store_conditional (mode, mem, val);\n+  emit_unlikely_jump (EQ, label);\n+}\n+\n+void\n+or1k_expand_atomic_exchange_qihi (rtx operands[])\n+{\n+  rtx orig_retval, retval, mem, val, scratch;\n+  rtx label, mask, shift;\n+  machine_mode mode;\n+\n+  orig_retval = operands[0];\n+  mem = operands[1];\n+  val = operands[2];\n+  mode = GET_MODE (mem);\n+\n+  mem = or1k_adjust_atomic_subword (mem, &shift, &mask);\n+\n+  /* Shift and mask VAL into position with the word.  */\n+  if (val != const0_rtx)\n+    {\n+      val = convert_modes (SImode, mode, val, 1);\n+      val = expand_binop (SImode, ashl_optab, val, shift,\n+\t\t\t  NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+    }\n+\n+  label = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());\n+  emit_label (XEXP (label, 0));\n+\n+  scratch = gen_reg_rtx (SImode);\n+  emit_load_locked (SImode, scratch, mem);\n+\n+  retval = expand_binop (SImode, and_optab, scratch, mask,\n+\t\t\t NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+  scratch = expand_binop (SImode, xor_optab, scratch, retval,\n+\t\t\t  scratch, 1, OPTAB_LIB_WIDEN);\n+  if (val != const0_rtx)\n+    scratch = expand_binop (SImode, ior_optab, scratch, val,\n+\t\t\t    scratch, 1, OPTAB_LIB_WIDEN);\n+\n+  emit_store_conditional (SImode, mem, scratch);\n+  emit_unlikely_jump (EQ, label);\n+\n+  or1k_finish_atomic_subword (mode, orig_retval, retval, shift);\n+}\n+\n+/* Expand an atomic fetch-and-operate pattern.  CODE is the binary operation\n+   to perform (with MULT as a stand-in for NAND).  MEM is the memory on which\n+   to operate.  VAL is the second operand of the binary operator.  BEFORE and\n+   AFTER are optional locations to return the value of MEM either before of\n+   after the operation.  */\n+\n+void\n+or1k_expand_atomic_op (rtx_code code, rtx mem, rtx val,\n+\t\t       rtx orig_before, rtx orig_after)\n+{\n+  machine_mode mode = GET_MODE (mem);\n+  rtx before = orig_before, after = orig_after;\n+  rtx label;\n+\n+  label = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());\n+  emit_label (XEXP (label, 0));\n+\n+  if (before == NULL_RTX)\n+    before = gen_reg_rtx (mode);\n+\n+  emit_load_locked (mode, before, mem);\n+\n+  if (code == MULT)\n+    {\n+      after = expand_binop (mode, and_optab, before, val,\n+\t\t\t    after, 1, OPTAB_LIB_WIDEN);\n+      after = expand_unop (mode, one_cmpl_optab, after, after, 1);\n+    }\n+  else\n+    after = expand_simple_binop (mode, code, before, val,\n+\t\t\t\t after, 1, OPTAB_LIB_WIDEN);\n+\n+  emit_store_conditional (mode, mem, after);\n+  emit_unlikely_jump (EQ, label);\n+\n+  if (orig_before)\n+    emit_move_insn (orig_before, before);\n+  if (orig_after)\n+    emit_move_insn (orig_after, after);\n+}\n+\n+void\n+or1k_expand_atomic_op_qihi (rtx_code code, rtx mem, rtx val,\n+\t\t\t    rtx orig_before, rtx orig_after)\n+{\n+  machine_mode mode = GET_MODE (mem);\n+  rtx label, mask, shift, x;\n+  rtx before, after, scratch;\n+\n+  mem = or1k_adjust_atomic_subword (mem, &shift, &mask);\n+\n+  /* Shift and mask VAL into position with the word.  */\n+  val = convert_modes (SImode, mode, val, 1);\n+  val = expand_binop (SImode, ashl_optab, val, shift,\n+\t\t      NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\n+  switch (code)\n+    {\n+    case IOR:\n+    case XOR:\n+      /* We've already zero-extended VAL.  That is sufficient to\n+\t make certain that it does not affect other bits.  */\n+      break;\n+\n+    case AND:\n+    case MULT: /* NAND */\n+      /* If we make certain that all of the other bits in VAL are\n+\t set, that will be sufficient to not affect other bits.  */\n+      x = expand_unop (SImode, one_cmpl_optab, mask, NULL_RTX, 1);\n+      val = expand_binop (SImode, ior_optab, val, x,\n+\t\t\t  val, 1, OPTAB_LIB_WIDEN);\n+      break;\n+\n+    case PLUS:\n+    case MINUS:\n+      /* These will all affect bits outside the field and need\n+\t adjustment via MASK within the loop.  */\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  label = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());\n+  emit_label (XEXP (label, 0));\n+\n+  before = scratch = gen_reg_rtx (SImode);\n+  emit_load_locked (SImode, before, mem);\n+\n+  switch (code)\n+    {\n+    case IOR:\n+    case XOR:\n+    case AND:\n+      after = expand_simple_binop (SImode, code, before, val,\n+\t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+      scratch = after;\n+      break;\n+\n+    case PLUS:\n+    case MINUS:\n+      before = expand_binop (SImode, and_optab, scratch, mask,\n+\t\t\t     NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+      scratch = expand_binop (SImode, xor_optab, scratch, before,\n+\t\t\t      scratch, 1, OPTAB_LIB_WIDEN);\n+      after = expand_simple_binop (SImode, code, before, val,\n+\t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+      after = expand_binop (SImode, and_optab, after, mask,\n+\t\t\t    after, 1, OPTAB_LIB_WIDEN);\n+      scratch = expand_binop (SImode, ior_optab, scratch, after,\n+\t\t\t      scratch, 1, OPTAB_LIB_WIDEN);\n+      break;\n+\n+    case MULT: /* NAND */\n+      after = expand_binop (SImode, and_optab, before, val,\n+\t\t\t    NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+      after = expand_binop (SImode, xor_optab, after, mask,\n+\t\t\t    after, 1, OPTAB_LIB_WIDEN);\n+      scratch = after;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  emit_store_conditional (SImode, mem, scratch);\n+  emit_unlikely_jump (EQ, label);\n+\n+  if (orig_before)\n+    or1k_finish_atomic_subword (mode, orig_before, before, shift);\n+  if (orig_after)\n+    or1k_finish_atomic_subword (mode, orig_after, after, shift);\n+}\n+\n+/* Worker for TARGET_ASM_OUTPUT_MI_THUNK.\n+   Output the assembler code for a thunk function.  THUNK_DECL is the\n+   declaration for the thunk function itself, FUNCTION is the decl for\n+   the target function.  DELTA is an immediate constant offset to be\n+   added to THIS.  If VCALL_OFFSET is nonzero, the word at address\n+   (*THIS + VCALL_OFFSET) should be additionally added to THIS.  */\n+\n+static void\n+or1k_output_mi_thunk (FILE *file, tree /* thunk_fndecl */,\n+\t\t      HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n+\t\t      tree function)\n+{\n+  rtx this_rtx, funexp;\n+  rtx_insn *insn;\n+\n+  reload_completed = 1;\n+  epilogue_completed = 1;\n+\n+  emit_note (NOTE_INSN_PROLOGUE_END);\n+\n+  /* Find the \"this\" pointer.  Normally in r3, but if the function\n+     returns a structure, the structure return pointer is in r3 and\n+     the \"this\" pointer is in r4 instead.  */\n+  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n+    this_rtx = gen_rtx_REG (Pmode, 4);\n+  else\n+    this_rtx = gen_rtx_REG (Pmode, 3);\n+\n+  /* Add DELTA.  When possible use a plain add, otherwise load it\n+     into a register first.  */\n+  if (delta)\n+    {\n+      rtx delta_rtx = GEN_INT (delta);\n+\n+      if (!satisfies_constraint_I (delta_rtx))\n+\t{\n+\t  rtx scratch = gen_rtx_REG (Pmode, PE_TMP_REGNUM);\n+\t  emit_move_insn (scratch, delta_rtx);\n+\t  delta_rtx = scratch;\n+\t}\n+\n+      /* THIS_RTX += DELTA.  */\n+      emit_insn (gen_add2_insn (this_rtx, delta_rtx));\n+    }\n+\n+  /* Add the word at address (*THIS_RTX + VCALL_OFFSET).  */\n+  if (vcall_offset)\n+    {\n+      rtx scratch = gen_rtx_REG (Pmode, PE_TMP_REGNUM);\n+      HOST_WIDE_INT lo = sext_hwi (vcall_offset, 16);\n+      HOST_WIDE_INT hi = vcall_offset - lo;\n+      rtx tmp;\n+\n+      /* SCRATCH = *THIS_RTX.  */\n+      tmp = gen_rtx_MEM (Pmode, this_rtx);\n+      emit_move_insn (scratch, tmp);\n+\n+      if (hi != 0)\n+\t{\n+\t  rtx scratch2 = gen_rtx_REG (Pmode, RV_REGNUM);\n+\t  emit_move_insn (scratch2, GEN_INT (hi));\n+\t  emit_insn (gen_add2_insn (scratch, scratch2));\n+\t}\n+\n+      /* SCRATCH = *(*THIS_RTX + VCALL_OFFSET).  */\n+      tmp = plus_constant (Pmode, scratch, lo);\n+      tmp = gen_rtx_MEM (Pmode, tmp);\n+      emit_move_insn (scratch, tmp);\n+\n+      /* THIS_RTX += *(*THIS_RTX + VCALL_OFFSET).  */\n+      emit_insn (gen_add2_insn (this_rtx, scratch));\n+    }\n+\n+  /* Generate a tail call to the target function.  */\n+  if (!TREE_USED (function))\n+    {\n+      assemble_external (function);\n+      TREE_USED (function) = 1;\n+    }\n+  funexp = XEXP (DECL_RTL (function), 0);\n+\n+  /* The symbol will be a local alias and therefore always binds local.  */\n+  gcc_assert (SYMBOL_REF_LOCAL_P (funexp));\n+\n+  funexp = gen_rtx_MEM (FUNCTION_MODE, funexp);\n+  insn = emit_call_insn (gen_sibcall (funexp, const0_rtx));\n+  SIBLING_CALL_P (insn) = 1;\n+  emit_barrier ();\n+\n+  /* Run just enough of rest_of_compilation to get the insns emitted.\n+     There's not really enough bulk here to make other passes such as\n+     instruction scheduling worth while.  Note that use_thunk calls\n+     assemble_start_function and assemble_end_function.  */\n+  insn = get_insns ();\n+  shorten_branches (insn);\n+  final_start_function (insn, file, 1);\n+  final (insn, file, 1);\n+  final_end_function ();\n+\n+  reload_completed = 0;\n+  epilogue_completed = 0;\n+}\n+\n+#undef  TARGET_ASM_OUTPUT_MI_THUNK\n+#define TARGET_ASM_OUTPUT_MI_THUNK or1k_output_mi_thunk\n+#undef  TARGET_ASM_CAN_OUTPUT_MI_THUNK\n+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK \\\n+  hook_bool_const_tree_hwi_hwi_const_tree_true\n+\n+#undef  TARGET_OPTION_OVERRIDE\n+#define TARGET_OPTION_OVERRIDE or1k_option_override\n+\n+#undef  TARGET_COMPUTE_FRAME_LAYOUT\n+#define TARGET_COMPUTE_FRAME_LAYOUT or1k_compute_frame_layout\n+\n+#undef  TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P or1k_legitimate_address_p\n+\n+#undef  TARGET_HAVE_TLS\n+#define TARGET_HAVE_TLS true\n+\n+#undef  TARGET_HAVE_SPECULATION_SAFE_VALUE\n+#define TARGET_HAVE_SPECULATION_SAFE_VALUE speculation_safe_value_not_needed\n+\n+/* Calling Conventions.  */\n+#undef  TARGET_FUNCTION_VALUE\n+#define TARGET_FUNCTION_VALUE or1k_function_value\n+#undef  TARGET_LIBCALL_VALUE\n+#define TARGET_LIBCALL_VALUE or1k_libcall_value\n+#undef  TARGET_FUNCTION_VALUE_REGNO_P\n+#define TARGET_FUNCTION_VALUE_REGNO_P or1k_function_value_regno_p\n+#undef  TARGET_FUNCTION_ARG\n+#define TARGET_FUNCTION_ARG or1k_function_arg\n+#undef  TARGET_FUNCTION_ARG_ADVANCE\n+#define TARGET_FUNCTION_ARG_ADVANCE or1k_function_arg_advance\n+#undef  TARGET_RETURN_IN_MEMORY\n+#define TARGET_RETURN_IN_MEMORY or1k_return_in_memory\n+#undef  TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE or1k_pass_by_reference\n+#undef  TARGET_TRAMPOLINE_INIT\n+#define TARGET_TRAMPOLINE_INIT or1k_trampoline_init\n+#undef  TARGET_FRAME_POINTER_REQUIRED\n+#define TARGET_FRAME_POINTER_REQUIRED or1k_frame_pointer_required\n+#undef  TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n+#define TARGET_CUSTOM_FUNCTION_DESCRIPTORS 1\n+\n+/* Assembly generation.  */\n+#undef  TARGET_PRINT_OPERAND\n+#define TARGET_PRINT_OPERAND or1k_print_operand\n+#undef  TARGET_PRINT_OPERAND_ADDRESS\n+#define TARGET_PRINT_OPERAND_ADDRESS or1k_print_operand_address\n+\n+/* Section anchor support.  */\n+#undef  TARGET_MIN_ANCHOR_OFFSET\n+#define TARGET_MIN_ANCHOR_OFFSET  -32768\n+#undef  TARGET_MAX_ANCHOR_OFFSET\n+#define TARGET_MAX_ANCHOR_OFFSET  32767\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;\n+\n+#include \"gt-or1k.h\""}, {"sha": "c3e42a087241af3954ad3fa64effd9a1f7c709bc", "filename": "gcc/config/or1k/or1k.h", "status": "added", "additions": 392, "deletions": 0, "changes": 392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2For1k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2For1k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2For1k.h?ref=3965b35f341cc99a10876518f707740a9e912a01", "patch": "@@ -0,0 +1,392 @@\n+/* Target Definitions for OpenRISC.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Stafford Horne.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_OR1K_H\n+#define GCC_OR1K_H\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+#define TARGET_CPU_CPP_BUILTINS()\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      builtin_define (\"__OR1K__\");\t\t\\\n+      builtin_define (\"__OR1K_DELAY__\");\t\\\n+      builtin_define (\"__or1k__\");\t\t\\\n+      if (TARGET_CMOV)\t\t\t\t\\\n+\tbuiltin_define (\"__or1k_cmov__\");\t\\\n+      builtin_assert (\"cpu=or1k\");\t\t\\\n+      builtin_assert (\"machine=or1k\");\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* Storage layout.  */\n+\n+#define DEFAULT_SIGNED_CHAR 1\n+#define BITS_BIG_ENDIAN 0\n+#define BYTES_BIG_ENDIAN 1\n+#define WORDS_BIG_ENDIAN 1\n+#define BITS_PER_WORD 32\n+#define UNITS_PER_WORD 4\n+#define POINTER_SIZE 32\n+#define BIGGEST_ALIGNMENT 32\n+#define STRICT_ALIGNMENT 1\n+#define FUNCTION_BOUNDARY 32\n+#define PARM_BOUNDARY 32\n+#define STACK_BOUNDARY 32\n+#define PREFERRED_STACK_BOUNDARY 32\n+#define MAX_FIXED_MODE_SIZE 64\n+\n+/* Layout of source language data types.  */\n+\n+#define INT_TYPE_SIZE 32\n+#define SHORT_TYPE_SIZE 16\n+#define LONG_TYPE_SIZE 32\n+#define LONG_LONG_TYPE_SIZE 64\n+#define FLOAT_TYPE_SIZE 32\n+#define DOUBLE_TYPE_SIZE 64\n+#define LONG_DOUBLE_TYPE_SIZE 64\n+#define WCHAR_TYPE_SIZE 32\n+\n+#undef SIZE_TYPE\n+#define SIZE_TYPE \"unsigned int\"\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"int\"\n+\n+#undef WCHAR_TYPE\n+#define WCHAR_TYPE \"unsigned int\"\n+\n+/* Describing Relative Costs of Operations.  */\n+#define MOVE_MAX 4\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* Register usage, class and contents.  */\n+\n+/* In OpenRISC there are 32 general purpose registers with the following\n+   designations:\n+\n+   r0    always 0\n+   r1    stack pointer\n+   r2    frame pointer (optional)\n+   r3    arg 0\n+   r4    arg 1\n+   r5    arg 2\n+   r6    arg 3\n+   r7    arg 4\n+   r8    arg 5\n+   r9    function call return link address\n+   r10   thread local storage\n+   r11   function return value & static chain\n+   r12   function return value high (upper 64-bit)\n+   r13   temporary (used in prologue and epilogue)\n+   r14   callee saved\n+   r15   temporary\n+   r16   callee saved & pic base register\n+   r17   temporary\n+   r18   callee saved\n+   r19   temporary\n+   r20   callee saved\n+   r21   temporary\n+   r22   callee saved\n+   r23   temporary\n+   r24   callee saved\n+   r25   temporary\n+   r26   callee saved\n+   r27   temporary\n+   r28   callee saved\n+   r29   temporary\n+   r30   callee saved\n+   r31   temporary\n+\n+   r32   soft argument pointer\n+   r33   soft frame pointer\n+   r34   SR[F] (bit) register\n+\n+   This ABI has no adjacent call-saved register, which means that\n+   DImode/DFmode pseudos cannot be call-saved and will always be\n+   spilled across calls.  To solve this without changing the ABI,\n+   remap the compiler internal register numbers to place the even\n+   call-saved registers r16-r30 in 24-31, and the odd call-clobbered\n+   registers r17-r31 in 16-23.  */\n+\n+#define FIRST_PSEUDO_REGISTER  35\n+\n+#define HW_TO_GCC_REGNO(X)\t\t\\\n+  ((X) < 16 || (X) > 31 ? (X)\t\t\\\n+   : (X) & 1 ? ((X) - 16) / 2 + 16\t\\\n+   : ((X) - 16) / 2 + 24)\n+\n+#define GCC_TO_HW_REGNO(X)\t\t\\\n+  ((X) < 16 || (X) > 31 ? (X)\t\t\\\n+   : (X) < 24 ? ((X) - 16) * 2 + 17\t\\\n+   : ((X) - 24) * 2 + 16)\n+\n+#define DBX_REGISTER_NUMBER(X)  GCC_TO_HW_REGNO(X)\n+\n+#define REGISTER_NAMES { \\\n+  \"r0\",   \"r1\",   \"r2\",   \"r3\",   \"r4\",   \"r5\",   \"r6\",   \"r7\",   \\\n+  \"r8\",   \"r9\",   \"r10\",  \"r11\",  \"r12\",  \"r13\",  \"r14\",  \"r15\",  \\\n+  \"r17\",  \"r19\",  \"r21\",  \"r23\",  \"r25\",  \"r27\",  \"r29\",  \"r31\",  \\\n+  \"r16\",  \"r18\",  \"r20\",  \"r22\",  \"r24\",  \"r26\",  \"r28\",  \"r30\",  \\\n+  \"?ap\",  \"?fp\",  \"?sr_f\" }\n+\n+#define FIXED_REGISTERS\t\t\\\n+{ 1, 1, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 1, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  1, 1, 1 }\n+\n+/* Caller saved/temporary registers + args + fixed */\n+#define CALL_USED_REGISTERS\t\\\n+{ 1, 1, 0, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 0, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  1, 1, 1 }\n+\n+/* List the order in which to allocate registers.  Each register must\n+   be listed once, even those in FIXED_REGISTERS.\n+\n+   ??? Note that placing REAL_PIC_OFFSET_TABLE_REGNUM (r16 = 24) first\n+   happens to make it most likely selected *as* the pic register when\n+   compiling without optimization, simply because the pic pseudo happens\n+   to be allocated with the lowest pseudo regno.  */\n+\n+#define REG_ALLOC_ORDER { \\\n+  16, 17, 18, 19, 20, 21, 22, 23,\t/* r17-r31 (odd), non-saved */\t\\\n+  13, 15,\t\t\t\t/* non-saved */\t\t\t\\\n+  12, 11,\t\t\t\t/* non-saved return values */\t\\\n+  8, 7, 6, 5, 4, 3,\t\t\t/* non-saved argument regs */\t\\\n+  24,\t\t\t\t\t/* r16, saved, pic reg */\t\\\n+  25, 26, 27, 28, 29, 30, 31,\t\t/* r18-r31 (even), saved */\t\\\n+  14,\t\t\t\t\t/* r14, saved */\t\t\\\n+  2,\t\t\t\t\t/* saved hard frame pointer */\t\\\n+  9,\t\t\t\t\t/* saved return address */\t\\\n+  0,\t\t\t\t\t/* fixed zero reg */\t\t\\\n+  1,\t\t\t\t\t/* fixed stack pointer */\t\\\n+  10,\t\t\t\t\t/* fixed thread pointer */\t\\\n+  32, 33, 34,\t\t\t\t/* fixed ap, fp, sr[f], */\t\\\n+}\n+\n+enum reg_class\n+{\n+  NO_REGS,\n+  SIBCALL_REGS,\n+  GENERAL_REGS,\n+  FLAG_REGS,\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+#define REG_CLASS_NAMES {\t\\\n+  \"NO_REGS\", \t\t\t\\\n+  \"SIBCALL_REGS\",\t\t\\\n+  \"GENERAL_REGS\",\t\t\\\n+  \"FLAG_REGS\",\t\t\t\\\n+  \"ALL_REGS\" }\n+\n+/* The SIBCALL_REGS must be call-clobbered, and not used as a temporary\n+   in the epilogue.  This excludes R9 (LR), R11 (STATIC_CHAIN), and\n+   R13 (PE_TMP_REGNUM).  */\n+#define SIBCALL_REGS_MASK  0x00ff95f8u\n+\n+#define REG_CLASS_CONTENTS      \\\n+{ { 0x00000000, 0x00000000 },\t\\\n+  { SIBCALL_REGS_MASK,   0 },\t\\\n+  { 0xffffffff, 0x00000003 },\t\\\n+  { 0x00000000, 0x00000004 },\t\\\n+  { 0xffffffff, 0x00000007 }\t\\\n+}\n+\n+/* A C expression whose value is a register class containing hard\n+   register REGNO.  In general there is more that one such class;\n+   choose a class which is \"minimal\", meaning that no smaller class\n+   also contains the register.  */\n+#define REGNO_REG_CLASS(REGNO) \\\n+  ((REGNO) >= SR_F_REGNUM ? FLAG_REGS \\\n+   : (REGNO) < 32 && ((SIBCALL_REGS_MASK >> (REGNO)) & 1) ? SIBCALL_REGS \\\n+   : GENERAL_REGS)\n+\n+#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)               \\\n+do {                                                    \\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT                 \\\n+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)         \\\n+    (MODE) = word_mode;                                 \\\n+} while (0)\n+\n+/* A macro whose definition is the name of the class to which a valid\n+   base register must belong.  A base register is one used in an\n+   address which is the register value plus a displacement.  */\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+#define INDEX_REG_CLASS NO_REGS\n+\n+/* Assembly definitions.  */\n+\n+#define ASM_APP_ON \"\"\n+#define ASM_APP_OFF \"\"\n+\n+#define ASM_COMMENT_START \"# \"\n+\n+#define GLOBAL_ASM_OP \"\\t.global\\t\"\n+#define TEXT_SECTION_ASM_OP \"\\t.section\\t.text\"\n+#define DATA_SECTION_ASM_OP \"\\t.section\\t.data\"\n+#define BSS_SECTION_ASM_OP \"\\t.section\\t.bss\"\n+#define SBSS_SECTION_ASM_OP \"\\t.section\\t.sbss\"\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if ((LOG) != 0)\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\t.align %d\\n\", 1 << (LOG));\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* This is used in crtstuff to create call stubs in the\n+   _init() and _fini() functions.  Defining this here saves\n+   a few bytes created by the dummy call_xxx() functions.  */\n+#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC)\t\\\n+  asm (SECTION_OP \"\\n\"\t\t\t\t\t\\\n+\"\tl.jal \" #FUNC \"\\n\"\t\t\t\t\\\n+\"\t l.nop\\n\"\t\t\t\t\t\\\n+\"\t.previous\");\n+\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) (code == '#')\n+\n+/* Calling convention definitions.  */\n+#define CUMULATIVE_ARGS int\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \\\n+  do { (CUM) = 0; } while (0)\n+\n+\n+/* Trampolines, for nested functions */\n+#define TRAMPOLINE_SIZE      20\n+#define TRAMPOLINE_ALIGNMENT 32\n+\n+/* Pointer mode */\n+#define Pmode SImode\n+#define FUNCTION_MODE SImode\n+#define STACK_POINTER_REGNUM SP_REGNUM\n+#define FRAME_POINTER_REGNUM SFP_REGNUM\n+#define HARD_FRAME_POINTER_REGNUM HFP_REGNUM\n+#define STATIC_CHAIN_REGNUM RV_REGNUM\n+\n+/* The register number of the arg pointer register, which is used to\n+   access the function's argument list.  */\n+#define ARG_POINTER_REGNUM AP_REGNUM\n+\n+/* Position Independent Code.  See or1k_init_pic_reg.  */\n+#define REAL_PIC_OFFSET_TABLE_REGNUM  HW_TO_GCC_REGNO (16)\n+\n+/* ??? Follow i386 in working around gimple costing estimation, which\n+   happens without properly initializing the pic_offset_table pseudo.  */\n+#define PIC_OFFSET_TABLE_REGNUM \\\n+  (pic_offset_table_rtx ? INVALID_REGNUM : REAL_PIC_OFFSET_TABLE_REGNUM)\n+\n+/* A C expression that is nonzero if REGNO is the number of a hard\n+   register in which function arguments are sometimes passed.  */\n+#define FUNCTION_ARG_REGNO_P(r) (r >= 3 && r <= 8)\n+\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+/* The ELIMINABLE_REGS macro specifies a table of register pairs used to\n+   eliminate unneeded registers that point into the stack frame. Note,\n+   the only elimination attempted by the compiler is to replace references\n+   to the frame pointer with references to the stack pointer.  */\n+\n+#define ELIMINABLE_REGS\t\t\t\t\t\\\n+{{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM },\t\\\n+ { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM },\t\\\n+ { ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM },\t\\\n+ { ARG_POINTER_REGNUM,   HARD_FRAME_POINTER_REGNUM }}\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+  do {\t\t\t\t\t\t\t\\\n+    (OFFSET) = or1k_initial_elimination_offset ((FROM), (TO)); \\\n+  } while (0)\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO) 0\n+#define REGNO_OK_FOR_BASE_P(REGNO)  ((REGNO) <= SFP_REGNUM)\n+\n+/* If defined, the maximum amount of space required for outgoing\n+   arguments will be computed and placed into the variable\n+   'crtl->outgoing_args_size'.  No space will be pushed\n+   onto the stack for each call; instead, the function prologue\n+   should increase the stack frame size by this amount.  */\n+#define ACCUMULATE_OUTGOING_ARGS 1\n+\n+/* Stack layout and stack pointer usage.  */\n+\n+/* This plus ARG_POINTER_REGNUM points to the first word of incoming args.  */\n+#define FIRST_PARM_OFFSET(FNDECL) (0)\n+\n+/* This plus STACK_POINTER_REGNUM points to the first work of outgoing args.  */\n+#define STACK_POINTER_OFFSET (0)\n+\n+/* Define this macro if pushing a word onto the stack moves the stack\n+   pointer to a smaller address.  */\n+#define STACK_GROWS_DOWNWARD 1\n+\n+#define FRAME_GROWS_DOWNWARD 1\n+\n+/* An alias for a machine mode name.  This is the machine mode that\n+   elements of a jump-table should have.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+#define STORE_FLAG_VALUE 1\n+\n+/* Indicates how loads of narrow mode values are loaded into words.  */\n+#define LOAD_EXTEND_OP(MODE) (ZERO_EXTEND)\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  */\n+#define EXIT_IGNORE_STACK 1\n+\n+/* Macros related to the access of the stack frame chain.  */\n+#define INITIAL_FRAME_ADDRESS_RTX  or1k_initial_frame_addr ()\n+#define DYNAMIC_CHAIN_ADDRESS      or1k_dynamic_chain_addr\n+#define RETURN_ADDR_RTX            or1k_return_addr\n+\n+/* Always pass the SYMBOL_REF for direct calls to the expanders.  */\n+#define NO_FUNCTION_CSE 1\n+\n+/* Profiling */\n+#define FUNCTION_PROFILER(FILE,LABELNO) (abort (), 0)\n+\n+/* Dwarf 2 Support */\n+#define DWARF2_DEBUGGING_INFO 1\n+#define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (Pmode, LR_REGNUM)\n+#define DWARF_FRAME_RETURN_COLUMN LR_REGNUM\n+\n+/* Describe how we implement __builtin_eh_return.  */\n+#define EH_RETURN_REGNUM HW_TO_GCC_REGNO (23)\n+/* Use r25, r27, r29 and r31 (clobber regs) for exception data.\n+   Recall that these are remapped consecutively.  */\n+#define EH_RETURN_DATA_REGNO(N)\t\\\n+    ((N) < 4 ? HW_TO_GCC_REGNO (25) + (N) : INVALID_REGNUM)\n+#define EH_RETURN_STACKADJ_RTX gen_rtx_REG (Pmode, EH_RETURN_REGNUM)\n+\n+#endif /* GCC_OR1K_H */"}, {"sha": "d131aa53abf8b8cd3eba661057fbc7a21ab2af2a", "filename": "gcc/config/or1k/or1k.md", "status": "added", "additions": 897, "deletions": 0, "changes": 897, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2For1k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2For1k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2For1k.md?ref=3965b35f341cc99a10876518f707740a9e912a01", "patch": "@@ -0,0 +1,897 @@\n+;; Machine description for OpenRISC\n+;; Copyright (C) 2018 Free Software Foundation, Inc.\n+;; Contributed by Stafford Horne\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; -------------------------------------------------------------------------\n+;; OpenRISC specific constraints, predicates and attributes\n+;; -------------------------------------------------------------------------\n+\n+(include \"constraints.md\")\n+(include \"predicates.md\")\n+\n+;; Register numbers\n+(define_constants\n+  [(SP_REGNUM       1)\n+   (HFP_REGNUM      2)\n+   (LR_REGNUM       9)\n+   (TLS_REGNUM     10)\n+   (RV_REGNUM      11)\n+   (PE_TMP_REGNUM  13)\n+   (AP_REGNUM      32)\n+   (SFP_REGNUM     33)\n+   (SR_F_REGNUM    34)]\n+)\n+\n+(define_c_enum \"unspec\" [\n+  UNSPEC_SET_GOT\n+  UNSPEC_GOT\n+  UNSPEC_GOTOFF\n+  UNSPEC_TPOFF\n+  UNSPEC_GOTTPOFF\n+  UNSPEC_TLSGD\n+  UNSPEC_MSYNC\n+])\n+\n+(define_c_enum \"unspecv\" [\n+  UNSPECV_SET_GOT\n+  UNSPECV_LL\n+  UNSPECV_SC\n+])\n+\n+;; Instruction scheduler\n+\n+; Most instructions are 4 bytes long.\n+(define_attr \"length\" \"\" (const_int 4))\n+\n+(define_attr \"type\"\n+  \"alu,st,ld,control,multi\"\n+  (const_string \"alu\"))\n+\n+(define_attr \"insn_support\" \"class1,sext,sfimm,shftimm\" (const_string \"class1\"))\n+\n+(define_attr \"enabled\" \"\"\n+  (cond [(eq_attr \"insn_support\" \"class1\") (const_int 1)\n+\t (and (eq_attr \"insn_support\" \"sext\")\n+\t      (ne (symbol_ref \"TARGET_SEXT\") (const_int 0))) (const_int 1)\n+\t (and (eq_attr \"insn_support\" \"sfimm\")\n+\t      (ne (symbol_ref \"TARGET_SFIMM\") (const_int 0))) (const_int 1)\n+\t (and (eq_attr \"insn_support\" \"shftimm\")\n+\t      (ne (symbol_ref \"TARGET_SHFTIMM\") (const_int 0))) (const_int 1)]\n+\t(const_int 0)))\n+\n+;; Describe a user's asm statement.\n+(define_asm_attributes\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_automaton \"or1k\")\n+(define_cpu_unit \"cpu\" \"or1k\")\n+(define_insn_reservation \"alu\" 1\n+  (eq_attr \"type\" \"alu\")\n+  \"cpu\")\n+(define_insn_reservation \"st\" 1\n+  (eq_attr \"type\" \"st\")\n+  \"cpu\")\n+(define_insn_reservation \"ld\" 3\n+  (eq_attr \"type\" \"st\")\n+  \"cpu\")\n+(define_insn_reservation \"control\" 1\n+  (eq_attr \"type\" \"control\")\n+  \"cpu\")\n+\n+; Define delay slots for any branch\n+(define_delay (eq_attr \"type\" \"control\")\n+  [(eq_attr \"type\" \"alu,st,ld\") (nil) (nil)])\n+\n+;; -------------------------------------------------------------------------\n+;; nop instruction\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"l.nop\")\n+\n+;; -------------------------------------------------------------------------\n+;; Arithmetic instructions\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t  (plus:SI\n+\t   (match_operand:SI 1 \"register_operand\"   \"%r,r\")\n+\t   (match_operand:SI 2 \"reg_or_s16_operand\" \" r,I\")))]\n+  \"\"\n+  \"@\n+  l.add\\t%0, %1, %2\n+  l.addi\\t%0, %1, %2\")\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t  (mult:SI\n+\t   (match_operand:SI 1 \"register_operand\"   \"%r,r\")\n+\t   (match_operand:SI 2 \"reg_or_s16_operand\" \" r,I\")))]\n+  \"!TARGET_SOFT_MUL\"\n+  \"@\n+  l.mul\\t%0, %1, %2\n+  l.muli\\t%0, %1, %2\")\n+\n+(define_insn \"divsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t  (div:SI\n+\t   (match_operand:SI 1 \"register_operand\" \"r\")\n+\t   (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"!TARGET_SOFT_DIV\"\n+  \"l.div\\t%0, %1, %2\")\n+\n+(define_insn \"udivsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t  (udiv:SI\n+\t   (match_operand:SI 1 \"register_operand\" \"r\")\n+\t   (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"!TARGET_SOFT_DIV\"\n+  \"l.divu\\t%0, %1, %2\")\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t  (minus:SI\n+\t   (match_operand:SI 1 \"reg_or_0_operand\" \"rO\")\n+\t   (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"l.sub\\t%0, %r1, %2\")\n+\n+;; -------------------------------------------------------------------------\n+;; Logical operators\n+;; -------------------------------------------------------------------------\n+\n+(define_code_iterator SHIFT  [ashift ashiftrt lshiftrt])\n+(define_code_attr shift_op   [(ashift \"ashl\") (ashiftrt \"ashr\")\n+\t\t\t      (lshiftrt \"lshr\")])\n+(define_code_attr shift_asm  [(ashift \"sll\") (ashiftrt \"sra\")\n+\t\t\t      (lshiftrt \"srl\")])\n+\n+(define_insn \"<shift_op>si3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(SHIFT:SI (match_operand:SI 1 \"register_operand\"  \"r,r\")\n+\t\t  (match_operand:SI 2 \"reg_or_u6_operand\" \"r,n\")))]\n+  \"\"\n+  \"@\n+   l.<shift_asm>\\t%0, %1, %2\n+   l.<shift_asm>i\\t%0, %1, %2\"\n+  [(set_attr \"insn_support\" \"*,shftimm\")])\n+\n+(define_insn \"rotrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(rotatert:SI (match_operand:SI 1 \"register_operand\"  \"r,r\")\n+\t\t  (match_operand:SI 2 \"reg_or_u6_operand\" \"r,n\")))]\n+  \"TARGET_ROR\"\n+  \"@\n+   l.ror\\t%0, %1, %2\n+   l.rori\\t%0, %1, %2\"\n+  [(set_attr \"insn_support\" \"*,shftimm\")])\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t  (and:SI\n+\t   (match_operand:SI 1 \"register_operand\"   \"%r,r\")\n+\t   (match_operand:SI 2 \"reg_or_u16_operand\" \" r,K\")))]\n+  \"\"\n+  \"@\n+  l.and\\t%0, %1, %2\n+  l.andi\\t%0, %1, %2\")\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t  (xor:SI\n+\t   (match_operand:SI 1 \"register_operand\"   \"%r,r\")\n+\t   (match_operand:SI 2 \"reg_or_s16_operand\" \" r,I\")))]\n+  \"\"\n+  \"@\n+  l.xor\\t%0, %1, %2\n+  l.xori\\t%0, %1, %2\")\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t  (ior:SI\n+\t   (match_operand:SI 1 \"register_operand\"   \"%r,r\")\n+\t   (match_operand:SI 2 \"reg_or_u16_operand\" \" r,K\")))]\n+  \"\"\n+  \"@\n+  l.or\\t%0, %1, %2\n+  l.ori\\t%0, %1, %2\")\n+\n+(define_expand \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"\") (const_int -1)))]\n+  \"\"\n+  \"\")\n+\n+;; -------------------------------------------------------------------------\n+;; Move instructions\n+;; -------------------------------------------------------------------------\n+\n+(define_mode_iterator I [QI HI SI])\n+(define_mode_iterator I12 [QI HI])\n+\n+(define_mode_attr ldst [(QI \"b\") (HI \"h\") (SI \"w\")])\n+(define_mode_attr zext_andi [(QI \"0xff\") (HI \"0xffff\")])\n+\n+(define_expand \"mov<I:mode>\"\n+  [(set (match_operand:I 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:I 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  or1k_expand_move (<MODE>mode, operands[0], operands[1]);\n+  DONE;\n+})\n+\n+;; 8-bit, 16-bit and 32-bit moves\n+\n+(define_insn \"*mov<I:mode>_internal\"\n+  [(set (match_operand:I 0 \"nonimmediate_operand\" \"=r,r,r,r, m,r\")\n+\t(match_operand:I 1 \"input_operand\"        \" r,M,K,I,rO,m\"))]\n+  \"register_operand (operands[0], <I:MODE>mode)\n+   || reg_or_0_operand (operands[1], <I:MODE>mode)\"\n+  \"@\n+   l.or\\t%0, %1, %1\n+   l.movhi\\t%0, hi(%1)\n+   l.ori\\t%0, r0, %1\n+   l.xori\\t%0, r0, %1\n+   l.s<I:ldst>\\t%0, %r1\n+   l.l<I:ldst>z\\t%0, %1\"\n+  [(set_attr \"type\" \"alu,alu,alu,alu,st,ld\")])\n+\n+;; Hi/Low moves for constant and symbol loading\n+\n+(define_insn \"movsi_high\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(high:SI (match_operand:SI 1 \"high_operand\" \"\")))]\n+  \"\"\n+  \"l.movhi\\t%0, %h1\"\n+  [(set_attr \"type\" \"alu\")])\n+\n+(define_insn \"*movsi_lo_sum_iori\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\"  \"r\")\n+\t\t   (match_operand:SI 2 \"losum_ior_operand\" \"\")))]\n+  \"\"\n+  \"l.ori\\t%0, %1, %L2\"\n+  [(set_attr \"type\" \"alu\")])\n+\n+(define_insn \"*movsi_lo_sum_addi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\"  \"r\")\n+\t\t   (match_operand:SI 2 \"losum_add_operand\" \"\")))]\n+  \"\"\n+  \"l.addi\\t%0, %1, %L2\"\n+  [(set_attr \"type\" \"alu\")])\n+\n+;; 64-bit moves\n+;; ??? The clobber that emit_move_multi_word emits is arguably incorrect.\n+;; Consider gcc.c-torture/execute/20030222-1.c, where a reg-reg DImode\n+;; move gets register allocated to a no-op move.  At which point the\n+;; we actively clobber the input.\n+\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  if (MEM_P (operands[0]) && !const0_operand(operands[1], DImode))\n+    operands[1] = force_reg (DImode, operands[1]);\n+})\n+\n+(define_insn_and_split \"*movdi\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,o,r\")\n+\t(match_operand:DI 1 \"general_operand\"      \" r,o,rO,n\"))]\n+  \"register_operand (operands[0], DImode)\n+   || reg_or_0_operand (operands[1], DImode)\"\n+  \"#\"\n+  \"\"\n+  [(const_int 0)]\n+{\n+  rtx l0 = operand_subword (operands[0], 0, 0, DImode);\n+  rtx l1 = operand_subword (operands[1], 0, 0, DImode);\n+  rtx h0 = operand_subword (operands[0], 1, 0, DImode);\n+  rtx h1 = operand_subword (operands[1], 1, 0, DImode);\n+\n+  if (reload_completed && reg_overlap_mentioned_p (l0, h1))\n+    {\n+      gcc_assert (!reg_overlap_mentioned_p (h0, l1));\n+      emit_move_insn (h0, h1);\n+      emit_move_insn (l0, l1);\n+    }\n+  else\n+    {\n+      emit_move_insn (l0, l1);\n+      emit_move_insn (h0, h1);\n+    }\n+  DONE;\n+})\n+\n+;; -------------------------------------------------------------------------\n+;; Sign Extending\n+;; -------------------------------------------------------------------------\n+\n+;; Zero extension can always be done with AND and an extending load.\n+\n+(define_insn \"zero_extend<mode>si2\"\n+  [(set (match_operand:SI 0 \"register_operand\"                     \"=r,r\")\n+\t(zero_extend:SI (match_operand:I12 1 \"nonimmediate_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+   l.andi\\t%0, %1, <zext_andi>\n+   l.l<ldst>z\\t%0, %1\")\n+\n+;; Sign extension in registers is an optional extension, but the\n+;; extending load is always available.  If SEXT is not available,\n+;; force the middle-end to do the expansion to shifts.\n+\n+(define_insn \"extend<mode>si2\"\n+  [(set (match_operand:SI 0 \"register_operand\"                      \"=r,r\")\n+\t(sign_extend:SI (match_operand:I12 1 \"nonimmediate_operand\"  \"r,m\")))]\n+  \"TARGET_SEXT\"\n+  \"@\n+   l.ext<ldst>s\\t%0, %1\n+   l.l<ldst>s\\t%0, %1\")\n+\n+(define_insn \"*extend<mode>si2_mem\"\n+  [(set (match_operand:SI 0 \"register_operand\"                \"=r\")\n+\t(sign_extend:SI (match_operand:I12 1 \"memory_operand\"  \"m\")))]\n+  \"\"\n+  \"l.l<ldst>s\\t%0, %1\")\n+\n+;; -------------------------------------------------------------------------\n+;; Compare instructions\n+;; -------------------------------------------------------------------------\n+\n+;; OpenRISC supports these integer comparisons:\n+;;\n+;;     l.sfeq[i] - equality, r r or r i\n+;;     l.sfne[i] - not equal, r r or r i\n+;;     l.sflt{s,u}[i] - less than, signed or unsigned, r r or r i\n+;;     l.sfle{s,u}[i] - less than or equal, signed or unsigned, r r or r i\n+;;     l.sfgt{s,u}[i] - greater than, signed or unsigned, r r or r i\n+;;     l.sfge{s,u}[i] - greater than or equal, signed or unsigned, r r or r i\n+;;\n+;;  EQ,NE,LT,LTU,LE,LEU,GT,GTU,GE,GEU\n+;;  We iterate through all of these\n+;;\n+\n+(define_code_iterator intcmpcc [ne eq lt ltu gt gtu ge le geu leu])\n+(define_code_attr insn [(ne \"ne\") (eq \"eq\") (lt \"lts\") (ltu \"ltu\")\n+\t\t\t(gt \"gts\") (gtu \"gtu\") (ge \"ges\") (le \"les\")\n+\t\t\t(geu \"geu\") (leu \"leu\") ])\n+\n+(define_insn \"*sf_insn\"\n+  [(set (reg:BI SR_F_REGNUM)\n+\t(intcmpcc:BI (match_operand:SI 0 \"reg_or_0_operand\"   \"rO,rO\")\n+\t\t     (match_operand:SI 1 \"reg_or_s16_operand\" \"r,I\")))]\n+  \"\"\n+  \"@\n+   l.sf<insn>\\t%r0, %1\n+   l.sf<insn>i\\t%r0, %1\"\n+  [(set_attr \"insn_support\" \"*,sfimm\")])\n+\n+;; -------------------------------------------------------------------------\n+;; Conditional Store instructions\n+;; -------------------------------------------------------------------------\n+\n+(define_expand \"cstoresi4\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(if_then_else:SI\n+\t  (match_operator 1 \"comparison_operator\"\n+\t    [(match_operand:SI 2 \"reg_or_0_operand\" \"\")\n+\t     (match_operand:SI 3 \"reg_or_s16_operand\" \"\")])\n+\t  (match_dup 0)\n+\t  (const_int 0)))]\n+  \"\"\n+{\n+  or1k_expand_compare (operands + 1);\n+  PUT_MODE (operands[1], SImode);\n+  emit_insn (gen_rtx_SET (operands[0], operands[1]));\n+  DONE;\n+})\n+\n+;; Being able to \"copy\" SR_F to a general register is helpful for\n+;; the atomic insns, wherein the usual usage is to test the success\n+;; of the compare-and-swap.  Representing the operation in this way,\n+;; rather than exposing the cmov immediately, allows the optimizers\n+;; to propagate the use of SR_F directly into a branch.\n+\n+(define_expand \"sne_sr_f\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ne:SI (reg:BI SR_F_REGNUM) (const_int 0)))]\n+  \"\")\n+\n+(define_insn_and_split \"*scc\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operator:SI 1 \"equality_comparison_operator\"\n+\t  [(reg:BI SR_F_REGNUM) (const_int 0)]))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 0) (const_int 1))\n+   (set (match_dup 0)\n+\t(if_then_else:SI (match_dup 1)\n+\t  (match_dup 0)\n+\t  (const_int 0)))]\n+  \"\")\n+\n+(define_expand \"mov<I:mode>cc\"\n+  [(set (match_operand:I 0 \"register_operand\" \"\")\n+\t(if_then_else:I (match_operand 1 \"comparison_operator\" \"\")\n+\t  (match_operand:I 2 \"reg_or_0_operand\" \"\")\n+\t  (match_operand:I 3 \"reg_or_0_operand\" \"\")))]\n+  \"\"\n+{\n+  rtx xops[3] = { operands[1], XEXP (operands[1], 0), XEXP (operands[1], 1) };\n+  or1k_expand_compare (xops);\n+  operands[1] = xops[0];\n+})\n+\n+(define_insn_and_split \"*cmov<I:mode>\"\n+  [(set (match_operand:I 0 \"register_operand\" \"=r\")\n+\t(if_then_else:I\n+\t  (match_operator 3 \"equality_comparison_operator\"\n+\t    [(reg:BI SR_F_REGNUM) (const_int 0)])\n+\t  (match_operand:I 1 \"reg_or_0_operand\" \"rO\")\n+\t  (match_operand:I 2 \"reg_or_0_operand\" \"rO\")))]\n+  \"\"\n+{\n+  return (GET_CODE (operands[3]) == NE\n+\t  ? \"l.cmov\\t%0, %r1, %r2\"\n+\t  : \"l.cmov\\t%0, %r2, %r1\");\n+}\n+  \"!TARGET_CMOV\"\n+  [(const_int 0)]\n+{\n+  rtx x;\n+  rtx label = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());\n+\n+  /* Generated a *cbranch pattern.  */\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    {\n+      PUT_CODE (operands[3], (GET_CODE (operands[3]) == NE) ? EQ : NE);\n+      x = gen_rtx_IF_THEN_ELSE (VOIDmode, operands[3], label, pc_rtx);\n+      emit_jump_insn (gen_rtx_SET (pc_rtx, x));\n+      emit_move_insn (operands[0], operands[1]);\n+    }\n+  else\n+    {\n+      x = gen_rtx_IF_THEN_ELSE (VOIDmode, operands[3], label, pc_rtx);\n+      emit_move_insn (operands[0], operands[1]);\n+      emit_jump_insn (gen_rtx_SET (pc_rtx, x));\n+      emit_move_insn (operands[0], operands[2]);\n+    }\n+\n+  emit_label (XEXP (label, 0));\n+  DONE;\n+})\n+\n+;; -------------------------------------------------------------------------\n+;; Branch instructions\n+;; -------------------------------------------------------------------------\n+\n+(define_expand \"cbranchsi4\"\n+  [(set (pc)\n+\t(if_then_else\n+\t  (match_operator 0 \"comparison_operator\"\n+\t    [(match_operand:SI 1 \"reg_or_0_operand\" \"\")\n+\t     (match_operand:SI 2 \"reg_or_s16_operand\" \"\")])\n+\t  (label_ref (match_operand 3 \"\" \"\"))\n+\t  (pc)))]\n+  \"\"\n+{\n+  or1k_expand_compare (operands);\n+})\n+\n+(define_insn \"*cbranch\"\n+  [(set (pc)\n+\t(if_then_else\n+\t  (match_operator 1 \"equality_comparison_operator\"\n+\t    [(reg:BI SR_F_REGNUM) (const_int 0)])\n+\t  (label_ref (match_operand 0 \"\" \"\"))\n+\t  (pc)))]\n+  \"\"\n+{\n+  return (GET_CODE (operands[1]) == NE\n+\t  ? \"l.bf\\t%0%#\"\n+\t  : \"l.bnf\\t%0%#\");\n+}\n+  [(set_attr \"type\" \"control\")])\n+\n+;; -------------------------------------------------------------------------\n+;; Jump instructions\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"jump\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"l.j\\t%0%#\"\n+  [(set_attr \"type\" \"control\")])\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"l.jr\\t%0%#\"\n+  [(set_attr \"type\" \"control\")])\n+\n+;; -------------------------------------------------------------------------\n+;; Prologue & Epilogue\n+;; -------------------------------------------------------------------------\n+\n+(define_expand \"prologue\"\n+  [(const_int 1)]\n+  \"\"\n+{\n+  or1k_expand_prologue ();\n+  DONE;\n+})\n+\n+;; Expand epilogue as RTL\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+{\n+  or1k_expand_epilogue ();\n+  emit_jump_insn (gen_simple_return ());\n+  DONE;\n+})\n+\n+(define_expand \"sibcall_epilogue\"\n+  [(return)]\n+  \"\"\n+{\n+  or1k_expand_epilogue ();\n+  /* Placing a USE of LR here, rather than as a REG_USE on the\n+     sibcall itself, means that LR is not unnecessarily live\n+     within the function itself, which would force creation of\n+     a stack frame.  */\n+  emit_insn (gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode, LR_REGNUM)));\n+  DONE;\n+})\n+\n+(define_expand \"simple_return\"\n+  [(parallel [(simple_return) (use (match_dup 0))])]\n+  \"\"\n+{\n+  operands[0] = gen_rtx_REG (Pmode, LR_REGNUM);\n+})\n+\n+(define_insn \"*simple_return\"\n+  [(simple_return)\n+   (use (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"l.jr\\t%0%#\"\n+  [(set_attr \"type\" \"control\")])\n+\n+(define_expand \"eh_return\"\n+  [(use (match_operand 0 \"general_operand\"))]\n+  \"\"\n+{\n+  or1k_expand_eh_return (operands[0]);\n+  DONE;\n+})\n+\n+;; This is a placeholder, during RA, in order to create the PIC regiter.\n+;; We do this so that we don't unconditionally mark the LR register as\n+;; clobbered.  It is replaced during prologue generation with the proper\n+;; set_got pattern below.  This works because the set_got_tmp insn is the\n+;; first insn in the stream and that it isn't moved during RA.\n+(define_insn \"set_got_tmp\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:SI [(const_int 0)] UNSPECV_SET_GOT))]\n+  \"\"\n+{\n+  gcc_unreachable ();\n+})\n+\n+;; The insn to initialize the GOT.\n+(define_insn \"set_got\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(const_int 0)] UNSPEC_SET_GOT))\n+   (clobber (reg:SI LR_REGNUM))]\n+  \"\"\n+{\n+  return (\"l.jal\\t8\\;\"\n+\t  \" l.movhi\\t%0, gotpchi(_GLOBAL_OFFSET_TABLE_-4)\\;\"\n+\t  \"l.ori\\t%0, %0, gotpclo(_GLOBAL_OFFSET_TABLE_+0)\\;\"\n+\t  \"l.add\\t%0, %0, r9\");\n+}\n+  [(set_attr \"length\" \"16\")\n+   (set_attr \"type\" \"multi\")])\n+\n+;; Block memory operations from being scheduled across frame (de)allocation.\n+(define_insn \"frame_addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t  (plus:SI\n+\t   (match_operand:SI 1 \"register_operand\"   \"%r,r\")\n+\t   (match_operand:SI 2 \"reg_or_s16_operand\" \" r,I\")))\n+   (clobber (mem:BLK (scratch)))]\n+  \"reload_completed\"\n+  \"@\n+  l.add\\t%0, %1, %2\n+  l.addi\\t%0, %1, %2\")\n+\n+;; -------------------------------------------------------------------------\n+;; Atomic Operations\n+;; -------------------------------------------------------------------------\n+\n+;; Note that MULT stands in for the non-existant NAND rtx_code.\n+(define_code_iterator FETCHOP [plus minus ior xor and mult])\n+\n+(define_code_attr fetchop_name\n+  [(plus \"add\")\n+   (minus \"sub\")\n+   (ior \"or\")\n+   (xor \"xor\")\n+   (and \"and\")\n+   (mult \"nand\")])\n+\n+(define_code_attr fetchop_pred\n+  [(plus \"reg_or_s16_operand\")\n+   (minus \"register_operand\")\n+   (ior \"reg_or_u16_operand\")\n+   (xor \"reg_or_s16_operand\")\n+   (and \"reg_or_u16_operand\")\n+   (mult \"reg_or_u16_operand\")])\n+\n+(define_expand \"mem_thread_fence\"\n+  [(match_operand:SI 0 \"const_int_operand\" \"\")]\t\t;; model\n+  \"\"\n+{\n+  memmodel model = memmodel_base (INTVAL (operands[0]));\n+  if (model != MEMMODEL_RELAXED)\n+    emit_insn (gen_msync ());\n+  DONE;\n+})\n+\n+(define_expand \"msync\"\n+  [(set (match_dup 0) (unspec:BLK [(match_dup 0)] UNSPEC_MSYNC))]\n+  \"\"\n+{\n+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));\n+  MEM_VOLATILE_P (operands[0]) = 1;\n+})\n+\n+(define_insn \"*msync\"\n+  [(set (match_operand:BLK 0 \"\" \"\")\n+\t(unspec:BLK [(match_dup 0)] UNSPEC_MSYNC))]\n+  \"\"\n+  \"l.msync\")\n+\n+(define_insn \"load_locked_si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:SI\n+\t  [(match_operand:SI 1 \"memory_operand\" \"m\")] UNSPECV_LL))]\n+  \"\"\n+  \"l.lwa\\t%0,%1\"\n+  [(set_attr \"type\" \"ld\")])\n+\n+(define_insn \"store_conditional_si\"\n+  [(set (reg:BI SR_F_REGNUM)\n+\t(unspec_volatile:BI [(const_int 0)] UNSPECV_SC))\n+   (set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+\t(match_operand:SI 1 \"reg_or_0_operand\" \"rO\"))]\n+  \"\"\n+  \"l.swa\\t%0,%r1\"\n+  [(set_attr \"type\" \"st\")])\n+\n+(define_expand \"atomic_compare_and_swapsi\"\n+  [(match_operand:SI 0 \"register_operand\")   ;; bool output\n+   (match_operand:SI 1 \"register_operand\")   ;; val output\n+   (match_operand:SI 2 \"memory_operand\")     ;; memory\n+   (match_operand:SI 3 \"reg_or_s16_operand\") ;; expected\n+   (match_operand:SI 4 \"reg_or_0_operand\")   ;; desired\n+   (match_operand:SI 5 \"const_int_operand\")  ;; is_weak\n+   (match_operand:SI 6 \"const_int_operand\")  ;; mod_s\n+   (match_operand:SI 7 \"const_int_operand\")] ;; mod_f\n+  \"\"\n+{\n+  or1k_expand_atomic_compare_and_swap (operands);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_compare_and_swap<mode>\"\n+  [(match_operand:SI 0 \"register_operand\")   ;; bool output\n+   (match_operand:I12 1 \"register_operand\")  ;; val output\n+   (match_operand:I12 2 \"memory_operand\")    ;; memory\n+   (match_operand:I12 3 \"register_operand\")  ;; expected\n+   (match_operand:I12 4 \"reg_or_0_operand\")  ;; desired\n+   (match_operand:SI 5 \"const_int_operand\")  ;; is_weak\n+   (match_operand:SI 6 \"const_int_operand\")  ;; mod_s\n+   (match_operand:SI 7 \"const_int_operand\")] ;; mod_f\n+  \"\"\n+{\n+  or1k_expand_atomic_compare_and_swap_qihi (operands);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_exchangesi\"\n+  [(match_operand:SI 0 \"register_operand\")\t;; output\n+   (match_operand:SI 1 \"memory_operand\")\t;; memory\n+   (match_operand:SI 2 \"reg_or_0_operand\")\t;; input\n+   (match_operand:SI 3 \"const_int_operand\")]\t;; model\n+  \"\"\n+{\n+  or1k_expand_atomic_exchange (operands);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_exchange<mode>\"\n+  [(match_operand:I12 0 \"register_operand\")\t;; output\n+   (match_operand:I12 1 \"memory_operand\")\t;; memory\n+   (match_operand:I12 2 \"reg_or_0_operand\")\t;; input\n+   (match_operand:SI 3 \"const_int_operand\")]\t;; model\n+  \"\"\n+{\n+  or1k_expand_atomic_exchange_qihi (operands);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_<fetchop_name>si\"\n+  [(match_operand:SI 0 \"memory_operand\")\t;; memory\n+   (FETCHOP:SI (match_dup 0)\n+     (match_operand:SI 1 \"<fetchop_pred>\"))\t;; operand\n+   (match_operand:SI 2 \"const_int_operand\")]\t;; model\n+  \"\"\n+{\n+  or1k_expand_atomic_op (<CODE>, operands[0], operands[1], NULL, NULL);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_<fetchop_name><mode>\"\n+  [(match_operand:I12 0 \"memory_operand\")\t;; memory\n+   (FETCHOP:I12 (match_dup 0)\n+     (match_operand:I12 1 \"register_operand\"))\t;; operand\n+   (match_operand:SI 2 \"const_int_operand\")]\t;; model\n+  \"\"\n+{\n+  or1k_expand_atomic_op_qihi (<CODE>, operands[0], operands[1], NULL, NULL);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_fetch_<fetchop_name>si\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")\t\t;; output\n+   (match_operand:SI 1 \"memory_operand\" \"\")\t\t;; memory\n+   (FETCHOP:SI (match_dup 1)\n+     (match_operand:SI 2 \"<fetchop_pred>\" \"\"))\t\t;; operand\n+   (match_operand:SI 3 \"const_int_operand\" \"\")]\t\t;; model\n+  \"\"\n+{\n+  or1k_expand_atomic_op (<CODE>, operands[1], operands[2], operands[0], NULL);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_fetch_<fetchop_name><mode>\"\n+  [(match_operand:I12 0 \"register_operand\" \"\")\t\t;; output\n+   (match_operand:I12 1 \"memory_operand\" \"\")\t\t;; memory\n+   (FETCHOP:I12 (match_dup 1)\n+     (match_operand:I12 2 \"<fetchop_pred>\" \"\"))\t\t;; operand\n+   (match_operand:SI 3 \"const_int_operand\" \"\")]\t\t;; model\n+  \"\"\n+{\n+  or1k_expand_atomic_op_qihi (<CODE>, operands[1], operands[2],\n+\t\t\t      operands[0], NULL);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_<fetchop_name>_fetchsi\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")\t\t;; output\n+   (match_operand:SI 1 \"memory_operand\" \"\")\t\t;; memory\n+   (FETCHOP:SI (match_dup 1)\n+     (match_operand:SI 2 \"<fetchop_pred>\" \"\"))\t\t;; operand\n+   (match_operand:SI 3 \"const_int_operand\" \"\")]\t\t;; model\n+  \"\"\n+{\n+  or1k_expand_atomic_op (<CODE>, operands[1], operands[2], NULL, operands[0]);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_<fetchop_name>_fetch<mode>\"\n+  [(match_operand:I12 0 \"register_operand\" \"\")\t\t;; output\n+   (match_operand:I12 1 \"memory_operand\" \"\")\t\t;; memory\n+   (FETCHOP:I12 (match_dup 1)\n+     (match_operand:I12 2 \"<fetchop_pred>\" \"\"))\t;; operand\n+   (match_operand:SI 3 \"const_int_operand\" \"\")]\t\t;; model\n+  \"\"\n+{\n+  or1k_expand_atomic_op_qihi (<CODE>, operands[1], operands[2],\n+\t\t\t      NULL, operands[0]);\n+  DONE;\n+})\n+\n+;; -------------------------------------------------------------------------\n+;; Call Instructions\n+;; -------------------------------------------------------------------------\n+\n+;; Leave these to last, as the modeless operand for call_value\n+;; interferes with normal patterns.\n+\n+(define_expand \"call\"\n+  [(call (match_operand 0) (match_operand 1))]\n+  \"\"\n+{\n+  or1k_expand_call (NULL, operands[0], operands[1], false);\n+  DONE;\n+})\n+\n+(define_expand \"sibcall\"\n+  [(call (match_operand 0) (match_operand 1))]\n+  \"\"\n+{\n+  or1k_expand_call (NULL, operands[0], operands[1], true);\n+  DONE;\n+})\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand 0) (call (match_operand 1) (match_operand 2)))]\n+  \"\"\n+{\n+  or1k_expand_call (operands[0], operands[1], operands[2], false);\n+  DONE;\n+})\n+\n+(define_expand \"sibcall_value\"\n+  [(set (match_operand 0) (call (match_operand 1) (match_operand 2)))]\n+  \"\"\n+{\n+  or1k_expand_call (operands[0], operands[1], operands[2], true);\n+  DONE;\n+})\n+\n+(define_insn \"*call\"\n+  [(call (mem:SI (match_operand:SI 0 \"call_insn_operand\" \"r,s\"))\n+\t (match_operand 1))\n+   (clobber (reg:SI LR_REGNUM))]\n+  \"!SIBLING_CALL_P (insn)\"\n+  \"@\n+   l.jalr\\t%0%#\n+   l.jal\\t%P0%#\"\n+  [(set_attr \"type\" \"control\")])\n+\n+(define_insn \"*sibcall\"\n+  [(call (mem:SI (match_operand:SI 0 \"call_insn_operand\" \"c,s\"))\n+\t (match_operand 1))]\n+  \"SIBLING_CALL_P (insn)\"\n+  \"@\n+   l.jr\\t%0%#\n+   l.j\\t%P0%#\"\n+  [(set_attr \"type\" \"control\")])\n+\n+(define_insn \"*call_value\"\n+  [(set (match_operand 0)\n+\t(call (mem:SI (match_operand:SI 1 \"call_insn_operand\" \"r,s\"))\n+\t      (match_operand 2)))\n+   (clobber (reg:SI LR_REGNUM))]\n+  \"!SIBLING_CALL_P (insn)\"\n+  \"@\n+   l.jalr\\t%1%#\n+   l.jal\\t%P1%#\"\n+  [(set_attr \"type\" \"control\")])\n+\n+(define_insn \"*sibcall_value\"\n+  [(set (match_operand 0)\n+\t(call (mem:SI (match_operand:SI 1 \"call_insn_operand\" \"c,s\"))\n+\t      (match_operand 2)))]\n+  \"SIBLING_CALL_P (insn)\"\n+  \"@\n+   l.jr\\t%1%#\n+   l.j\\t%P1%#\"\n+  [(set_attr \"type\" \"control\")])"}, {"sha": "3cc9422f7568ee796e78e523c5b88e86b29bb2f5", "filename": "gcc/config/or1k/or1k.opt", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2For1k.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2For1k.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2For1k.opt?ref=3965b35f341cc99a10876518f707740a9e912a01", "patch": "@@ -0,0 +1,67 @@\n+; OpenRISC command line options\n+\n+; Copyright (C) 2010-2018 Free Software Foundation, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.\n+\n+; See the GCC internals manual (options.texi) for a description of\n+; this file's format.\n+\n+; Please try to keep this file in ASCII collating order.\n+\n+mhard-div\n+Target RejectNegative InverseMask(SOFT_DIV)\n+Use hardware divide instructions, use -msoft-div for emulation.\n+\n+mhard-mul\n+Target RejectNegative InverseMask(SOFT_MUL).\n+Use hardware multiply instructions, use -msoft-mul for emulation.\n+\n+mcmov\n+Target RejectNegative Mask(CMOV)\n+Allows generation of binaries which use the l.cmov instruction.  If your target\n+does not support this the compiler will generate the equivalent using set and\n+branch.\n+\n+mror\n+Target RejectNegative Mask(ROR)\n+Allows generation of binaries which use the l.rori instructions.\n+\n+msext\n+Target RejectNegative Mask(SEXT)\n+Allows generation of binaries which use sign-extension instructions.  If your\n+target does not support this the compiler will use memory loads to perform sign\n+extension.\n+\n+msfimm\n+Target RejectNegative Mask(SFIMM)\n+Allows generation of binaries which use l.sf*i instructions.  If your target\n+does not support this the compiler will generate instructions to store the\n+immediate to a register first.\n+\n+mshftimm\n+Target RejectNegative Mask(SHFTIMM)\n+Allows generation of binaries which support shifts and rotate instructions\n+supporting immediate arguments, for example l.rori.\n+\n+msoft-div\n+Target RejectNegative Mask(SOFT_DIV)\n+Use divide emulation.\n+\n+msoft-mul\n+Target RejectNegative Mask(SOFT_MUL).\n+Use multiply emulation."}, {"sha": "3f6b4a451b84b4614446900f683903810afc9f01", "filename": "gcc/config/or1k/predicates.md", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2Fpredicates.md?ref=3965b35f341cc99a10876518f707740a9e912a01", "patch": "@@ -0,0 +1,84 @@\n+;; Predicate definitions for OpenRISC\n+;; Copyright (C) 2018 Free Software Foundation, Inc.\n+;; Contributed by Stafford Horne\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; -------------------------------------------------------------------------\n+;; Predicates\n+;; -------------------------------------------------------------------------\n+\n+(define_predicate \"input_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"memory_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"satisfies_constraint_I (op)\n+\t\t\t || satisfies_constraint_K (op)\n+\t\t\t || satisfies_constraint_M (op)\"))))\n+\n+(define_predicate \"const0_operand\"\n+  (and (match_code \"const_int,const_wide_int,const_double,const_vector\")\n+       (match_test \"op == CONST0_RTX (mode)\")))\n+\n+(define_predicate \"reg_or_0_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"const0_operand\")))\n+\n+(define_predicate \"reg_or_u6_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"INTVAL (op) >= 0 && INTVAL (op) <= 0x3f\")\n+    (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"reg_or_u16_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"INTVAL (op) >= 0 && INTVAL (op) <= 0xffff\")\n+    (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"reg_or_s16_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"INTVAL (op) >= -32768 && INTVAL (op) <= 32767\")\n+    (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"call_insn_operand\"\n+  (ior (match_code \"symbol_ref\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"high_operand\"\n+  (match_code \"symbol_ref,label_ref,const,unspec\"))\n+\n+;; Return true for relocations that must use MOVHI+ADDI\n+(define_predicate \"losum_add_operand\"\n+  (match_code \"symbol_ref,label_ref,const,unspec\"))\n+\n+;; Return true for relocations that must use MOVHI+ORI\n+(define_predicate \"losum_ior_operand\"\n+  (and (match_code \"unspec\")\n+       (match_test \"XINT(op, 1) == UNSPEC_TLSGD\")))\n+\n+;; Return true for a \"virtual\" or \"soft\" register that will be\n+;; adjusted to a \"soft\" or \"hard\" register during elimination.\n+(define_predicate \"virtual_frame_reg_operand\"\n+  (match_code \"reg\")\n+{\n+  unsigned regno = REGNO (op);\n+  return (regno != STACK_POINTER_REGNUM\n+\t  && regno != HARD_FRAME_POINTER_REGNUM\n+\t  && REGNO_PTR_FRAME_P (regno));\n+})\n+\n+(define_predicate \"equality_comparison_operator\"\n+  (match_code \"ne,eq\"))"}, {"sha": "0c3d39cc9c4fb9fa91e1899ac015541b8ebe673f", "filename": "gcc/config/or1k/rtems.h", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2Frtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2Frtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2Frtems.h?ref=3965b35f341cc99a10876518f707740a9e912a01", "patch": "@@ -0,0 +1,30 @@\n+/* Target Newlib Definitions for OpenRISC.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Joel Sherrill (joel.sherrill@OARcorp.com).\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Target OS builtins.  */\n+#undef TARGET_OS_CPP_BUILTINS\n+#define TARGET_OS_CPP_BUILTINS()\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+\tbuiltin_define (\"__rtems__\");\t\t\\\n+\tbuiltin_define (\"__USE_INIT_FINI__\");\t\\\n+\tbuiltin_assert (\"system=rtems\");\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)"}, {"sha": "6771c82da08940c7e56de1da3fbced492b03b564", "filename": "gcc/config/or1k/t-or1k", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2Ft-or1k", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2Ft-or1k", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2Ft-or1k?ref=3965b35f341cc99a10876518f707740a9e912a01", "patch": "@@ -0,0 +1,22 @@\n+# Target Makefile Fragment for OpenRISC\n+# Copyright (C) 2018 Free Software Foundation, Inc.\n+# Contributed by Stafford Horne.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published\n+# by the Free Software Foundation; either version 3, or (at your\n+# option) any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+# License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+comma=,\n+MULTILIB_OPTIONS = $(subst $(comma), ,$(TM_MULTILIB_CONFIG))"}, {"sha": "e4e5e1dca97780643f79cbd220656a657b7636df", "filename": "gcc/config/or1k/t-rtems", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2Ft-rtems", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfig%2For1k%2Ft-rtems", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2Ft-rtems?ref=3965b35f341cc99a10876518f707740a9e912a01", "patch": "@@ -0,0 +1,3 @@\n+# RTEMS OR1K multilibs\n+\n+# No custom multilibs defined"}, {"sha": "895736274593cd7381a47d062ce4c5326635f2b8", "filename": "gcc/configure", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=3965b35f341cc99a10876518f707740a9e912a01", "patch": "@@ -24391,6 +24391,18 @@ foo:\t.long\t25\n \ttls_first_minor=20\n \ttls_as_opt='--fatal-warnings'\n \t;;\n+  or1k*-*-*)\n+    conftest_s='\n+        .section \".tdata\",\"awT\",@progbits\n+foo:    .long   25\n+        .text\n+        l.movhi r3, tpoffha(foo)\n+        l.add   r3, r3, r10\n+        l.lwz   r4, tpofflo(foo)(r3)'\n+    tls_first_major=2\n+    tls_first_minor=30\n+    tls_as_opt=--fatal-warnings\n+    ;;\n   powerpc-ibm-aix*)\n     conftest_s='\n \t.extern __get_tpointer"}, {"sha": "260d987daddfc094278842c05c1bac76e860f9ca", "filename": "gcc/configure.ac", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=3965b35f341cc99a10876518f707740a9e912a01", "patch": "@@ -3473,6 +3473,18 @@ foo:\t.long\t25\n \ttls_first_minor=20\n \ttls_as_opt='--fatal-warnings'\n \t;;\n+  or1k*-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\t.long\t25\n+\t.text\n+\tl.movhi\tr3, tpoffha(foo)\n+\tl.add\tr3, r3, r10\n+\tl.lwz\tr4, tpofflo(foo)(r3)'\n+    tls_first_major=2\n+    tls_first_minor=30\n+    tls_as_opt=--fatal-warnings\n+    ;;\n   powerpc-ibm-aix*)\n     conftest_s='\n \t.extern __get_tpointer"}, {"sha": "19adb7ef8705f948a49494f9f55c707823399a1f", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=3965b35f341cc99a10876518f707740a9e912a01", "patch": "@@ -3269,6 +3269,10 @@ information have to.\n @item\n @uref{#nvptx-x-none,,nvptx-*-none}\n @item\n+@uref{#or1k-x-elf,,or1k-*-elf}\n+@item\n+@uref{#or1k-x-linux,,or1k-*-linux}\n+@item\n @uref{#powerpc-x-x,,powerpc*-*-*}\n @item\n @uref{#powerpc-x-darwin,,powerpc-*-darwin*}\n@@ -4236,6 +4240,21 @@ the GCC sources.\n Use the @option{--disable-sjlj-exceptions} and\n @option{--enable-newlib-io-long-long} options when configuring.\n \n+@html\n+<hr />\n+@end html\n+@anchor{or1k-x-elf}\n+@heading or1k-*-elf\n+The OpenRISC 1000 32-bit processor with delay slots.\n+This configuration is intended for embedded systems.\n+\n+@html\n+<hr />\n+@end html\n+@anchor{or1k-x-linux}\n+@heading or1k-*-linux\n+The OpenRISC 1000 32-bit processor with delay slots.\n+\n @html\n <hr />\n @end html"}, {"sha": "028a8962fd2daaf3d0a1ae9198e167982aeaf898", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3965b35f341cc99a10876518f707740a9e912a01", "patch": "@@ -1010,6 +1010,11 @@ Objective-C and Objective-C++ Dialects}.\n @emph{Nvidia PTX Options}\n @gccoptlist{-m32  -m64  -mmainkernel  -moptimize}\n \n+@emph{OpenRISC Options}\n+@gccoptlist{-mboard=@var{name} -mnewlib -mhard-mul -mhard-div @gol\n+-msoft-mul -msoft-div @gol\n+-mcmov -mror -msext -msfimm -mshftimm}\n+\n @emph{PDP-11 Options}\n @gccoptlist{-mfpu  -msoft-float  -mac0  -mno-ac0  -m40  -m45  -m10 @gol\n -mint32  -mno-int16 -mint16  -mno-int32 @gol\n@@ -14984,6 +14989,7 @@ platform.\n * NDS32 Options::\n * Nios II Options::\n * Nvidia PTX Options::\n+* OpenRISC Options::\n * PDP-11 Options::\n * picoChip Options::\n * PowerPC Options::\n@@ -22762,6 +22768,68 @@ Generate code for use in OpenMP offloading: enables @option{-msoft-stack} and\n \n @end table\n \n+@node OpenRISC Options\n+@subsection OpenRISC Options\n+@cindex OpenRISC Options\n+\n+These options are defined for OpenRISC:\n+\n+@table @gcctabopt\n+\n+@item -mboard=@var{name}\n+@opindex mboard\n+Configure a board specific runtime.  This will be passed to the linker for\n+newlib board library linking.  The default is @code{or1ksim}.\n+\n+@item -mnewlib\n+@opindex mnewlib\n+For compatibility, it's always newlib for elf now.\n+\n+@item -mhard-div\n+@opindex mhard-div\n+Generate code for hardware which supports divide instructions.  This is the\n+default.\n+\n+@item -mhard-mul\n+@opindex mhard-mul\n+Generate code for hardware which supports multiply instructions.  This is the\n+default.\n+\n+@item -mcmov\n+@opindex mcmov\n+Generate code for hardware which supports the conditional move (@code{l.cmov})\n+instruction.\n+\n+@item -mror\n+@opindex mror\n+Generate code for hardware which supports rotate right instructions.\n+\n+@item -msext\n+@opindex msext\n+Generate code for hardware which supports sign-extension instructions.\n+\n+@item -msfimm\n+@opindex msfimm\n+Generate code for hardware which supports set flag immediate (@code{l.sf*i})\n+instructions.\n+\n+@item -mshftimm\n+@opindex mshftimm\n+Generate code for hardware which supports shift immediate related instructions\n+(i.e. @code{l.srai}, @code{l.srli}, @code{l.slli}, @code{1.rori}).  Note, to\n+enable generation of the @code{l.rori} instruction the @option{-mror} flag must\n+also be specified.\n+\n+@item -msoft-div\n+@opindex msoft-div\n+Generate code for hardware which requires divide instruction emulation.\n+\n+@item -msoft-mul\n+@opindex msoft-mul\n+Generate code for hardware which requires multiply instruction emulation.\n+\n+@end table\n+\n @node PDP-11 Options\n @subsection PDP-11 Options\n @cindex PDP-11 Options"}, {"sha": "e5002e29d6f58d4d2b4af2a5c888da4d5f2e8640", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3965b35f341cc99a10876518f707740a9e912a01/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=3965b35f341cc99a10876518f707740a9e912a01", "patch": "@@ -3003,6 +3003,31 @@ representing a supported PIC or TLS relocation.\n \n @end table\n \n+@item OpenRISC---@file{config/or1k/constraints.md}\n+@table @code\n+@item I\n+Integer that is valid as an immediate operand in an\n+instruction taking a signed 16-bit number. Range\n+@minus{}32768 to 32767.\n+\n+@item K\n+Integer that is valid as an immediate operand in an\n+instruction taking an unsigned 16-bit number. Range\n+0 to 65535.\n+\n+@item M\n+Signed 16-bit constant shifted left 16 bits. (Used with @code{l.movhi})\n+\n+@item O\n+Zero\n+\n+@ifset INTERNALS\n+@item c\n+Register usable for sibcalls.\n+@end ifset\n+\n+@end table\n+\n @item PDP-11---@file{config/pdp11/constraints.md}\n @table @code\n @item a"}]}