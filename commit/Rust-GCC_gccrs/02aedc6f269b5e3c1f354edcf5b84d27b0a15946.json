{"sha": "02aedc6f269b5e3c1f354edcf5b84d27b0a15946", "node_id": "C_kwDOANBUbNoAKDAyYWVkYzZmMjY5YjVlM2MxZjM1NGVkY2Y1Yjg0ZDI3YjBhMTU5NDY", "commit": {"author": {"name": "Tom de Vries", "email": "tdevries@suse.de", "date": "2022-02-16T16:09:11Z"}, "committer": {"name": "Tom de Vries", "email": "tdevries@suse.de", "date": "2022-02-21T15:49:37Z"}, "message": "[nvptx] Initialize ptx regs\n\nWith nvptx target, driver version 510.47.03 and board GT 1030 I, we run into:\n...\nFAIL: gcc.c-torture/execute/pr53465.c -O1 execution test\nFAIL: gcc.c-torture/execute/pr53465.c -O2 execution test\nFAIL: gcc.c-torture/execute/pr53465.c -O3 -g execution test\n...\nwhile the test-cases pass with nvptx-none-run -O0.\n\nThe problem is that the generated ptx contains a read from an uninitialized\nptx register, and the driver JIT doesn't handle this well.\n\nFor -O2 and -O3, we can get rid of the FAIL using --param\nlogical-op-non-short-circuit=0.  But not for -O1.\n\nAt -O1, the test-case minimizes to:\n...\nvoid __attribute__((noinline, noclone))\nfoo (int y) {\n  int c;\n  for (int i = 0; i < y; i++)\n    {\n      int d = i + 1;\n      if (i && d <= c)\n        __builtin_abort ();\n      c = d;\n    }\n}\n\nint main () {\n  foo (2); return 0;\n}\n...\n\nNote that the test-case does not contain an uninitialized use.  In the first\niteration, i is 0 and consequently c is not read.  In the second iteration, c\nis read, but by that time it's already initialized by 'c = d' from the first\niteration.\n\nAFAICT the problem is introduced as follows: the conditional use of c in the\nloop body is translated into an unconditional use of c in the loop header:\n...\n  # c_1 = PHI <c_4(D)(2), c_9(6)>\n...\nwhich forwprop1 propagates the 'c_9 = d_7' assignment into:\n...\n  # c_1 = PHI <c_4(D)(2), d_7(6)>\n...\nwhich ends up being translated by expand into an unconditional:\n...\n(insn 13 12 0 (set (reg/v:SI 22 [ c ])\n        (reg/v:SI 23 [ d ])) -1\n     (nil))\n...\nat the start of the loop body, creating an uninitialized read of d on the\npath from loop entry.\n\nBy disabling coalesce_ssa_name, we get the more usual copies on the incoming\nedges.  The copy on the loop entry path still does an uninitialized read, but\nthat one's now initialized by init-regs.  The test-case passes, also when\ndisabling init-regs, so it's possible that the JIT driver doesn't object to\nthis type of uninitialized read.\n\nNow that we characterized the problem to some degree, we need to fix this,\nbecause either:\n- we're violating an undocumented ptx invariant, and this is a compiler bug,\n  or\n- this is is a driver JIT bug and we need to work around it.\n\nThere are essentially two strategies to address this:\n- stop the compiler from creating uninitialized reads\n- patch up uninitialized reads using additional initialization\n\nThe former will probably involve:\n- making some optimizations more conservative in the presence of\n  uninitialized reads, and\n- disabling some other optimizations (where making them more conservative is\n  not possible, or cannot easily be achieved).\nThis will probably will have a cost penalty for code that does not suffer from\nthe original problem.\n\nThe latter has the problem that it may paper over uninitialized reads\nin the source code, or indeed over ones that were incorrectly introduced\nby the compiler.  But it has the advantage that it allows for the problem to\nbe addressed at a single location.\n\nThere's an existing pass, init-regs, which implements a form of the latter,\nbut it doesn't work for this example because it only inserts additional\ninitialization for uses that have not a single reaching definition.\n\nFix this by adding initialization of uninitialized ptx regs in reorg.\n\nControl the new functionality using -minit-regs=<0|1|2|3>, meaning:\n- 0: disabled.\n- 1: add initialization of all regs at the entry bb\n- 2: add initialization of uninitialized regs at the entry bb\n- 3: add initialization of uninitialized regs close to the use\nand defaulting to 3.\n\nTested on nvptx.\n\ngcc/ChangeLog:\n\n2022-02-17  Tom de Vries  <tdevries@suse.de>\n\n\tPR target/104440\n\t* config/nvptx/nvptx.cc (workaround_uninit_method_1)\n\t(workaround_uninit_method_2, workaround_uninit_method_3)\n\t(workaround_uninit): New function.\n\t(nvptx_reorg): Use workaround_uninit.\n\t* config/nvptx/nvptx.opt (minit-regs): New option.", "tree": {"sha": "dea8593d27795550149fbdf3e6fbaba4412df44d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dea8593d27795550149fbdf3e6fbaba4412df44d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02aedc6f269b5e3c1f354edcf5b84d27b0a15946", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02aedc6f269b5e3c1f354edcf5b84d27b0a15946", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02aedc6f269b5e3c1f354edcf5b84d27b0a15946", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02aedc6f269b5e3c1f354edcf5b84d27b0a15946/comments", "author": {"login": "vries", "id": 4057235, "node_id": "MDQ6VXNlcjQwNTcyMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vries", "html_url": "https://github.com/vries", "followers_url": "https://api.github.com/users/vries/followers", "following_url": "https://api.github.com/users/vries/following{/other_user}", "gists_url": "https://api.github.com/users/vries/gists{/gist_id}", "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vries/subscriptions", "organizations_url": "https://api.github.com/users/vries/orgs", "repos_url": "https://api.github.com/users/vries/repos", "events_url": "https://api.github.com/users/vries/events{/privacy}", "received_events_url": "https://api.github.com/users/vries/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vries", "id": 4057235, "node_id": "MDQ6VXNlcjQwNTcyMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vries", "html_url": "https://github.com/vries", "followers_url": "https://api.github.com/users/vries/followers", "following_url": "https://api.github.com/users/vries/following{/other_user}", "gists_url": "https://api.github.com/users/vries/gists{/gist_id}", "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vries/subscriptions", "organizations_url": "https://api.github.com/users/vries/orgs", "repos_url": "https://api.github.com/users/vries/repos", "events_url": "https://api.github.com/users/vries/events{/privacy}", "received_events_url": "https://api.github.com/users/vries/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e74d764e172fa6afdbd194ce57decc80237631dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e74d764e172fa6afdbd194ce57decc80237631dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e74d764e172fa6afdbd194ce57decc80237631dc"}], "stats": {"total": 192, "additions": 192, "deletions": 0}, "files": [{"sha": "a37a6c78b41d558e163517bdea64896ea333f8f3", "filename": "gcc/config/nvptx/nvptx.cc", "status": "modified", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02aedc6f269b5e3c1f354edcf5b84d27b0a15946/gcc%2Fconfig%2Fnvptx%2Fnvptx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02aedc6f269b5e3c1f354edcf5b84d27b0a15946/gcc%2Fconfig%2Fnvptx%2Fnvptx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.cc?ref=02aedc6f269b5e3c1f354edcf5b84d27b0a15946", "patch": "@@ -5372,6 +5372,190 @@ workaround_barsyncs (void)\n }\n #endif\n \n+/* Initialize all declared regs at function entry.\n+   Advantage   : Fool-proof.\n+   Disadvantage: Potentially creates a lot of long live ranges and adds a lot\n+\t\t of insns.  */\n+\n+static void\n+workaround_uninit_method_1 (void)\n+{\n+  rtx_insn *first = get_insns ();\n+  rtx_insn *insert_here = NULL;\n+\n+  for (int ix = LAST_VIRTUAL_REGISTER + 1; ix < max_reg_num (); ix++)\n+    {\n+      rtx reg = regno_reg_rtx[ix];\n+\n+      /* Skip undeclared registers.  */\n+      if (reg == const0_rtx)\n+\tcontinue;\n+\n+      gcc_assert (CONST0_RTX (GET_MODE (reg)));\n+\n+      start_sequence ();\n+      emit_move_insn (reg, CONST0_RTX (GET_MODE (reg)));\n+      rtx_insn *inits = get_insns ();\n+      end_sequence ();\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfor (rtx_insn *init = inits; init != NULL; init = NEXT_INSN (init))\n+\t  fprintf (dump_file, \"Default init of reg %u inserted: insn %u\\n\",\n+\t\t   ix, INSN_UID (init));\n+\n+      if (first != NULL)\n+\t{\n+\t  insert_here = emit_insn_before (inits, first);\n+\t  first = NULL;\n+\t}\n+      else\n+\tinsert_here = emit_insn_after (inits, insert_here);\n+    }\n+}\n+\n+/* Find uses of regs that are not defined on all incoming paths, and insert a\n+   corresponding def at function entry.\n+   Advantage   : Simple.\n+   Disadvantage: Potentially creates long live ranges.\n+\t\t May not catch all cases.  F.i. a clobber cuts a live range in\n+\t\t the compiler and may prevent entry_lr_in from being set for a\n+\t\t reg, but the clobber does not translate to a ptx insn, so in\n+\t\t ptx there still may be an uninitialized ptx reg.  See f.i.\n+\t\t gcc.c-torture/compile/20020926-1.c.  */\n+\n+static void\n+workaround_uninit_method_2 (void)\n+{\n+  auto_bitmap entry_pseudo_uninit;\n+  {\n+    auto_bitmap not_pseudo;\n+    bitmap_set_range (not_pseudo, 0, LAST_VIRTUAL_REGISTER);\n+\n+    bitmap entry_lr_in = DF_LR_IN (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+    bitmap_and_compl (entry_pseudo_uninit, entry_lr_in, not_pseudo);\n+  }\n+\n+  rtx_insn *first = get_insns ();\n+  rtx_insn *insert_here = NULL;\n+\n+  bitmap_iterator iterator;\n+  unsigned ix;\n+  EXECUTE_IF_SET_IN_BITMAP (entry_pseudo_uninit, 0, ix, iterator)\n+    {\n+      rtx reg = regno_reg_rtx[ix];\n+      gcc_assert (CONST0_RTX (GET_MODE (reg)));\n+\n+      start_sequence ();\n+      emit_move_insn (reg, CONST0_RTX (GET_MODE (reg)));\n+      rtx_insn *inits = get_insns ();\n+      end_sequence ();\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfor (rtx_insn *init = inits; init != NULL; init = NEXT_INSN (init))\n+\t  fprintf (dump_file, \"Missing init of reg %u inserted: insn %u\\n\",\n+\t\t   ix, INSN_UID (init));\n+\n+      if (first != NULL)\n+\t{\n+\t  insert_here = emit_insn_before (inits, first);\n+\t  first = NULL;\n+\t}\n+      else\n+\tinsert_here = emit_insn_after (inits, insert_here);\n+    }\n+}\n+\n+/* Find uses of regs that are not defined on all incoming paths, and insert a\n+   corresponding def on those.\n+   Advantage   : Doesn't create long live ranges.\n+   Disadvantage: More complex, and potentially also more defs.  */\n+\n+static void\n+workaround_uninit_method_3 (void)\n+{\n+  auto_bitmap not_pseudo;\n+  bitmap_set_range (not_pseudo, 0, LAST_VIRTUAL_REGISTER);\n+\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      if (single_pred_p (bb))\n+\tcontinue;\n+\n+      auto_bitmap bb_pseudo_uninit;\n+      bitmap_and_compl (bb_pseudo_uninit, DF_LIVE_IN (bb), DF_MIR_IN (bb));\n+      bitmap_and_compl_into (bb_pseudo_uninit, not_pseudo);\n+\n+      bitmap_iterator iterator;\n+      unsigned ix;\n+      EXECUTE_IF_SET_IN_BITMAP (bb_pseudo_uninit, 0, ix, iterator)\n+\t{\n+\t  bool have_false = false;\n+\t  bool have_true = false;\n+\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    {\n+\t      if (bitmap_bit_p (DF_LIVE_OUT (e->src), ix))\n+\t\thave_true = true;\n+\t      else\n+\t\thave_false = true;\n+\t    }\n+\t  if (have_false ^ have_true)\n+\t    continue;\n+\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    {\n+\t      if (bitmap_bit_p (DF_LIVE_OUT (e->src), ix))\n+\t\tcontinue;\n+\n+\t      rtx reg = regno_reg_rtx[ix];\n+\t      gcc_assert (CONST0_RTX (GET_MODE (reg)));\n+\n+\t      start_sequence ();\n+\t      emit_move_insn (reg, CONST0_RTX (GET_MODE (reg)));\n+\t      rtx_insn *inits = get_insns ();\n+\t      end_sequence ();\n+\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfor (rtx_insn *init = inits; init != NULL;\n+\t\t     init = NEXT_INSN (init))\n+\t\t  fprintf (dump_file,\n+\t\t\t   \"Missing init of reg %u inserted on edge: %d -> %d:\"\n+\t\t\t   \" insn %u\\n\", ix, e->src->index, e->dest->index,\n+\t\t\t   INSN_UID (init));\n+\n+\t      insert_insn_on_edge (inits, e);\n+\t    }\n+\t}\n+    }\n+\n+  commit_edge_insertions ();\n+}\n+\n+static void\n+workaround_uninit (void)\n+{\n+  switch (nvptx_init_regs)\n+    {\n+    case 0:\n+      /* Skip.  */\n+      break;\n+    case 1:\n+      workaround_uninit_method_1 ();\n+      break;\n+    case 2:\n+      workaround_uninit_method_2 ();\n+      break;\n+    case 3:\n+      workaround_uninit_method_3 ();\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* PTX-specific reorganization\n    - Split blocks at fork and join instructions\n    - Compute live registers\n@@ -5401,6 +5585,8 @@ nvptx_reorg (void)\n   df_set_flags (DF_NO_INSN_RESCAN | DF_NO_HARD_REGS);\n   df_live_add_problem ();\n   df_live_set_all_dirty ();\n+  if (nvptx_init_regs == 3)\n+    df_mir_add_problem ();\n   df_analyze ();\n   regstat_init_n_sets_and_refs ();\n \n@@ -5413,6 +5599,8 @@ nvptx_reorg (void)\n     if (REG_N_SETS (i) == 0 && REG_N_REFS (i) == 0)\n       regno_reg_rtx[i] = const0_rtx;\n \n+  workaround_uninit ();\n+\n   /* Determine launch dimensions of the function.  If it is not an\n      offloaded function  (i.e. this is a regular compiler), the\n      function has no neutering.  */"}, {"sha": "085800717316da52eb7dcc9b0d799b6a430f623e", "filename": "gcc/config/nvptx/nvptx.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02aedc6f269b5e3c1f354edcf5b84d27b0a15946/gcc%2Fconfig%2Fnvptx%2Fnvptx.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02aedc6f269b5e3c1f354edcf5b84d27b0a15946/gcc%2Fconfig%2Fnvptx%2Fnvptx.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.opt?ref=02aedc6f269b5e3c1f354edcf5b84d27b0a15946", "patch": "@@ -91,3 +91,7 @@ Enum(ptx_version) String(7.0) Value(PTX_VERSION_7_0)\n mptx=\n Target RejectNegative ToLower Joined Enum(ptx_version) Var(ptx_version_option)\n Specify the version of the ptx version to use.\n+\n+minit-regs=\n+Target Var(nvptx_init_regs) IntegerRange(0, 3) Joined UInteger Init(3)\n+Initialize ptx registers."}]}