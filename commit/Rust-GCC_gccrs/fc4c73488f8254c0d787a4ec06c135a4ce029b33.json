{"sha": "fc4c73488f8254c0d787a4ec06c135a4ce029b33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM0YzczNDg4ZjgyNTRjMGQ3ODdhNGVjMDZjMTM1YTRjZTAyOWIzMw==", "commit": {"author": {"name": "Piotr Trojanek", "email": "trojanek@adacore.com", "date": "2020-03-07T21:59:24Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-11T09:53:43Z"}, "message": "[Ada] Create constrained itypes for nested record aggregates\n\n2020-06-11  Piotr Trojanek  <trojanek@adacore.com>\n\ngcc/ada/\n\n\t* sem_aggr.adb (Build_Constrained_Itype): Previously a declare\n\tblock, now a separate procedure; the only change is that now\n\tNew_Assoc_List might include components and an others clause,\n\twhich we ignore (while we deal with discriminants exactly as we\n\tdid before); extend a ??? comment about how this routine is\n\tdifferent from the Build_Subtype\n\t(Resolve_Record_Aggregate): Create a constrained itype not just\n\tfor the outermost record aggregate, but for its inner record\n\taggregates as well.", "tree": {"sha": "6794a16ba3da9f53bd376d4b78746d0bb3d7b80f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6794a16ba3da9f53bd376d4b78746d0bb3d7b80f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc4c73488f8254c0d787a4ec06c135a4ce029b33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc4c73488f8254c0d787a4ec06c135a4ce029b33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc4c73488f8254c0d787a4ec06c135a4ce029b33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc4c73488f8254c0d787a4ec06c135a4ce029b33/comments", "author": {"login": "ptroja", "id": 161602, "node_id": "MDQ6VXNlcjE2MTYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/161602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptroja", "html_url": "https://github.com/ptroja", "followers_url": "https://api.github.com/users/ptroja/followers", "following_url": "https://api.github.com/users/ptroja/following{/other_user}", "gists_url": "https://api.github.com/users/ptroja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptroja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptroja/subscriptions", "organizations_url": "https://api.github.com/users/ptroja/orgs", "repos_url": "https://api.github.com/users/ptroja/repos", "events_url": "https://api.github.com/users/ptroja/events{/privacy}", "received_events_url": "https://api.github.com/users/ptroja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb"}], "stats": {"total": 164, "additions": 101, "deletions": 63}, "files": [{"sha": "5d56fd701c6b18ee2ebb422f2b9fd8146281550b", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 101, "deletions": 63, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4c73488f8254c0d787a4ec06c135a4ce029b33/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4c73488f8254c0d787a4ec06c135a4ce029b33/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=fc4c73488f8254c0d787a4ec06c135a4ce029b33", "patch": "@@ -3315,6 +3315,29 @@ package body Sem_Aggr is\n       --  part of the enclosing aggregate. Assoc_List provides the discriminant\n       --  associations of the current type or of some enclosing record.\n \n+      procedure Build_Constrained_Itype\n+        (N              : Node_Id;\n+         Typ            : Entity_Id;\n+         New_Assoc_List : List_Id);\n+      --  Build a constrained itype for the newly created record aggregate N\n+      --  and set it as a type of N. The itype will have Typ as its base type\n+      --  and will be constrained by the values of discriminants from the\n+      --  component association list New_Assoc_List.\n+\n+      --  ??? This code used to be pretty much a copy of Sem_Ch3.Build_Subtype,\n+      --  but now those two routines behave differently for types with unknown\n+      --  discriminants. They should really be exported in sem_util or some\n+      --  such and used in sem_ch3 and here rather than have a copy of the\n+      --  code which is a maintenance nightmare.\n+\n+      --  ??? Performance WARNING. The current implementation creates a new\n+      --  itype for all aggregates whose base type is discriminated. This means\n+      --  that for record aggregates nested inside an array aggregate we will\n+      --  create a new itype for each record aggregate if the array component\n+      --  type has discriminants. For large aggregates this may be a problem.\n+      --  What should be done in this case is to reuse itypes as much as\n+      --  possible.\n+\n       function Discriminant_Present (Input_Discr : Entity_Id) return Boolean;\n       --  If aggregate N is a regular aggregate this routine will return True.\n       --  Otherwise, if N is an extension aggregate, then Input_Discr denotes\n@@ -3474,6 +3497,78 @@ package body Sem_Aggr is\n          end loop;\n       end Add_Discriminant_Values;\n \n+      -----------------------------\n+      -- Build_Constrained_Itype --\n+      -----------------------------\n+\n+      procedure Build_Constrained_Itype\n+        (N              : Node_Id;\n+         Typ            : Entity_Id;\n+         New_Assoc_List : List_Id)\n+      is\n+         Constrs     : constant List_Id    := New_List;\n+         Loc         : constant Source_Ptr := Sloc (N);\n+         Def_Id      : Entity_Id;\n+         Indic       : Node_Id;\n+         New_Assoc   : Node_Id;\n+         Subtyp_Decl : Node_Id;\n+\n+      begin\n+         New_Assoc := First (New_Assoc_List);\n+         while Present (New_Assoc) loop\n+\n+            --  There is exactly one choice in the component association (and\n+            --  it is either a discriminant, a component or the others clause).\n+            pragma Assert (List_Length (Choices (New_Assoc)) = 1);\n+\n+            --  Duplicate expression for the discriminant and put it on the\n+            --  list of constraints for the itype declaration.\n+\n+            if Is_Entity_Name (First (Choices (New_Assoc)))\n+              and then\n+                Ekind (Entity (First (Choices (New_Assoc)))) = E_Discriminant\n+            then\n+               Append_To (Constrs, Duplicate_Subexpr (Expression (New_Assoc)));\n+            end if;\n+\n+            Next (New_Assoc);\n+         end loop;\n+\n+         if Has_Unknown_Discriminants (Typ)\n+           and then Present (Underlying_Record_View (Typ))\n+         then\n+            Indic :=\n+              Make_Subtype_Indication (Loc,\n+                Subtype_Mark =>\n+                  New_Occurrence_Of (Underlying_Record_View (Typ), Loc),\n+                Constraint   =>\n+                  Make_Index_Or_Discriminant_Constraint (Loc,\n+                    Constraints => Constrs));\n+         else\n+            Indic :=\n+              Make_Subtype_Indication (Loc,\n+                Subtype_Mark =>\n+                  New_Occurrence_Of (Base_Type (Typ), Loc),\n+                Constraint   =>\n+                  Make_Index_Or_Discriminant_Constraint (Loc,\n+                    Constraints => Constrs));\n+         end if;\n+\n+         Def_Id := Create_Itype (Ekind (Typ), N);\n+\n+         Subtyp_Decl :=\n+           Make_Subtype_Declaration (Loc,\n+             Defining_Identifier => Def_Id,\n+             Subtype_Indication  => Indic);\n+         Set_Parent (Subtyp_Decl, Parent (N));\n+\n+         --  Itypes must be analyzed with checks off (see itypes.ads)\n+\n+         Analyze (Subtyp_Decl, Suppress => All_Checks);\n+\n+         Set_Etype (N, Def_Id);\n+      end Build_Constrained_Itype;\n+\n       --------------------------\n       -- Discriminant_Present --\n       --------------------------\n@@ -3833,6 +3928,8 @@ package body Sem_Aggr is\n                Add_Discriminant_Values (New_Aggr, Assoc_List);\n                Propagate_Discriminants (New_Aggr, Assoc_List);\n \n+               Build_Constrained_Itype\n+                 (New_Aggr, T, Component_Associations (New_Aggr));\n             else\n                Needs_Box := True;\n             end if;\n@@ -4378,73 +4475,11 @@ package body Sem_Aggr is\n \n       --  STEP 4: Set the Etype of the record aggregate\n \n-      --  ??? This code is pretty much a copy of Sem_Ch3.Build_Subtype. That\n-      --  routine should really be exported in sem_util or some such and used\n-      --  in sem_ch3 and here rather than have a copy of the code which is a\n-      --  maintenance nightmare.\n-\n-      --  ??? Performance WARNING. The current implementation creates a new\n-      --  itype for all aggregates whose base type is discriminated. This means\n-      --  that for record aggregates nested inside an array aggregate we will\n-      --  create a new itype for each record aggregate if the array component\n-      --  type has discriminants. For large aggregates this may be a problem.\n-      --  What should be done in this case is to reuse itypes as much as\n-      --  possible.\n-\n       if Has_Discriminants (Typ)\n         or else (Has_Unknown_Discriminants (Typ)\n                   and then Present (Underlying_Record_View (Typ)))\n       then\n-         Build_Constrained_Itype : declare\n-            Constrs     : constant List_Id    := New_List;\n-            Loc         : constant Source_Ptr := Sloc (N);\n-            Def_Id      : Entity_Id;\n-            Indic       : Node_Id;\n-            New_Assoc   : Node_Id;\n-            Subtyp_Decl : Node_Id;\n-\n-         begin\n-            New_Assoc := First (New_Assoc_List);\n-            while Present (New_Assoc) loop\n-               Append_To (Constrs, Duplicate_Subexpr (Expression (New_Assoc)));\n-               Next (New_Assoc);\n-            end loop;\n-\n-            if Has_Unknown_Discriminants (Typ)\n-              and then Present (Underlying_Record_View (Typ))\n-            then\n-               Indic :=\n-                 Make_Subtype_Indication (Loc,\n-                   Subtype_Mark =>\n-                     New_Occurrence_Of (Underlying_Record_View (Typ), Loc),\n-                   Constraint   =>\n-                     Make_Index_Or_Discriminant_Constraint (Loc,\n-                       Constraints => Constrs));\n-            else\n-               Indic :=\n-                 Make_Subtype_Indication (Loc,\n-                   Subtype_Mark =>\n-                     New_Occurrence_Of (Base_Type (Typ), Loc),\n-                   Constraint   =>\n-                     Make_Index_Or_Discriminant_Constraint (Loc,\n-                       Constraints => Constrs));\n-            end if;\n-\n-            Def_Id := Create_Itype (Ekind (Typ), N);\n-\n-            Subtyp_Decl :=\n-              Make_Subtype_Declaration (Loc,\n-                Defining_Identifier => Def_Id,\n-                Subtype_Indication  => Indic);\n-            Set_Parent (Subtyp_Decl, Parent (N));\n-\n-            --  Itypes must be analyzed with checks off (see itypes.ads)\n-\n-            Analyze (Subtyp_Decl, Suppress => All_Checks);\n-\n-            Set_Etype (N, Def_Id);\n-         end Build_Constrained_Itype;\n-\n+         Build_Constrained_Itype (N, Typ, New_Assoc_List);\n       else\n          Set_Etype (N, Typ);\n       end if;\n@@ -4875,6 +4910,9 @@ package body Sem_Aggr is\n                            Propagate_Discriminants\n                              (Expr, Component_Associations (Expr));\n \n+                           Build_Constrained_Itype\n+                             (Expr, Ctyp, Component_Associations (Expr));\n+\n                         else\n                            declare\n                               Comp : Entity_Id;"}]}