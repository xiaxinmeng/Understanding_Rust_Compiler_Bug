{"sha": "402b0954bebd465944a8f2de9e346933be951076", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAyYjA5NTRiZWJkNDY1OTQ0YThmMmRlOWUzNDY5MzNiZTk1MTA3Ng==", "commit": {"author": {"name": "Loren J. Rittle", "email": "ljrittle@acm.org", "date": "2004-01-23T06:54:06Z"}, "committer": {"name": "Loren J. Rittle", "email": "ljrittle@gcc.gnu.org", "date": "2004-01-23T06:54:06Z"}, "message": "allocator_map_thread.cc: New test.\n\n\tlibstdc++/13823\n\t* testsuite/performance/allocator_map_thread.cc: New test.\n\nFrom-SVN: r76398", "tree": {"sha": "3879ceaa8149e5dcc1e6f09d7fea4ef9006575ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3879ceaa8149e5dcc1e6f09d7fea4ef9006575ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/402b0954bebd465944a8f2de9e346933be951076", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/402b0954bebd465944a8f2de9e346933be951076", "html_url": "https://github.com/Rust-GCC/gccrs/commit/402b0954bebd465944a8f2de9e346933be951076", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/402b0954bebd465944a8f2de9e346933be951076/comments", "author": null, "committer": null, "parents": [{"sha": "3a1cac0f85fe31cd529dd64338b0144935f246db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a1cac0f85fe31cd529dd64338b0144935f246db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a1cac0f85fe31cd529dd64338b0144935f246db"}], "stats": {"total": 137, "additions": 137, "deletions": 0}, "files": [{"sha": "d6482244e6dfdce270a3f0acf9b8f63bea9293b4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/402b0954bebd465944a8f2de9e346933be951076/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/402b0954bebd465944a8f2de9e346933be951076/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=402b0954bebd465944a8f2de9e346933be951076", "patch": "@@ -1,3 +1,8 @@\n+2004-01-23  Loren J. Rittle  <ljrittle@acm.org>\n+\n+\tlibstdc++/13823\n+\t* testsuite/performance/allocator_map_thread.cc: New test.\n+\n 2004-01-22  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/bits/locale_facets.tcc"}, {"sha": "65fb408b34c3d68971b6cf96abec06b89e9bb387", "filename": "libstdc++-v3/testsuite/performance/allocator_map_thread.cc", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/402b0954bebd465944a8f2de9e346933be951076/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fallocator_map_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/402b0954bebd465944a8f2de9e346933be951076/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fallocator_map_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fallocator_map_thread.cc?ref=402b0954bebd465944a8f2de9e346933be951076", "patch": "@@ -0,0 +1,132 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/*\n+ * The goal with this application is to compare the performance\n+ * between different std::allocator implementations. The results are\n+ * influenced by the underlying allocator in the \"C\" library, malloc.\n+ */\n+\n+// libstdc++/13823 recast for this testing framework\n+\n+#include <map>\n+#include <iostream>\n+#include <typeinfo>\n+#include <sstream>\n+#include <cxxabi.h>\n+#include <ext/mt_allocator.h>\n+#include <ext/malloc_allocator.h>\n+#include <testsuite_performance.h>\n+\n+using namespace std;\n+using __gnu_cxx::malloc_allocator;\n+using __gnu_cxx::__mt_alloc;\n+\n+// The number of iterations to be performed.\n+int iterations;\n+\n+template<typename Container>\n+  void*\n+  do_loop(void* p = NULL)\n+  {\n+    try\n+      {\n+\tfor (int c = 0; c < 10; c++)\n+\t  {\n+\t    Container m;\n+\n+\t    for (unsigned i = 0; i < iterations; ++i) \n+\t      m[i] = i;\n+\t  }\n+      }\n+    catch(...)\n+      {\n+\t// No point allocating all available memory, repeatedly.\t\n+      }\n+  }\n+\n+template<typename Container>\n+  void\n+  calibrate_iterations()\n+  {\n+    int try_iterations = iterations = 10000;\n+\n+    __gnu_test::time_counter timer;\n+    timer.start();\n+    do_loop<Container>();\n+    timer.stop();\n+\n+    double tics = timer.real_time();\n+    double iterpc = iterations / tics; //iterations per clock\n+    double xtics = 100; // works for linux 2gig x86\n+    iterations = static_cast<int>(xtics * iterpc);\n+  }\n+\n+template<typename Container>\n+  void\n+  test_container(Container obj)\n+  {\n+    using namespace __gnu_test;\n+    int status;\n+\n+    time_counter time;\n+    resource_counter resource;\n+\n+    clear_counters(time, resource);\n+    start_counters(time, resource);\n+    \n+    pthread_t  t1, t2, t3, t4;\n+    pthread_create(&t1, NULL, &do_loop<Container>, NULL);\n+    pthread_create(&t2, NULL, &do_loop<Container>, NULL);\n+    pthread_create(&t3, NULL, &do_loop<Container>, NULL);\n+    pthread_create(&t4, NULL, &do_loop<Container>, NULL);\n+\n+    pthread_join(t1, NULL);\n+    pthread_join(t2, NULL);\n+    pthread_join(t3, NULL);\n+    pthread_join(t4, NULL);\n+\n+    stop_counters(time, resource);\n+ \n+    std::ostringstream comment;\n+    comment << \"iterations: \" << iterations << '\\t';\n+    comment << \"type: \" << abi::__cxa_demangle(typeid(obj).name(),\n+\t\t\t\t\t       0, 0, &status);\n+    report_header(__FILE__, comment.str());\n+    report_performance(__FILE__, string(), time, resource);\n+  }\n+\n+int main(void)\n+{\n+  calibrate_iterations<map<int, int> >();\n+  test_container(map<int, int>());\n+  test_container(map<int, int, less<const int>, malloc_allocator<int> >());\n+  test_container(map<int, int, less<const int>,\n+                     __mt_alloc< pair<const int, int> > >());\n+\n+  return 0;\n+}"}]}