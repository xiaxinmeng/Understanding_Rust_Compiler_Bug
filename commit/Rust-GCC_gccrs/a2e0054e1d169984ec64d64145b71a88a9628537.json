{"sha": "a2e0054e1d169984ec64d64145b71a88a9628537", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJlMDA1NGUxZDE2OTk4NGVjNjRkNjQxNDViNzFhODhhOTYyODUzNw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2016-10-20T12:07:45Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2016-10-20T12:07:45Z"}, "message": "Prepare shared_ptr for array support\n\n\t* include/backward/auto_ptr.h (__shared_ptr(auto_ptr&&))\n\t(shared_ptr(auto_ptr&&)): Adjust template parameter lists.\n\t* include/bits/shared_ptr.h (__sp_compatible_with)\n\t(__sp_is_constructible): New helper traits for shared_ptr.\n\t(shared_ptr::_Convertible): Replace with _Constructible.\n\t(shared_ptr::_Constructible, shared_ptr::_Assignable): Forward checks\n\tto base class.\n\t(shared_ptr::shared_ptr, shared_ptr::operator=): Constrain template\n\twith _Constructible and _Assignable.\n\t(shared_ptr::shared_ptr(shared_ptr<_Tp1>, _Tp*)): Use element_type\n\tinstead of _Tp.\n\t(operator<): Likewise.\n\t(operator>): Define in terms of operator<.\n\t(static_pointer_cast, const_pointer_cast, dynamic_pointer_cast): Use\n\telement_type instead of _Tp.\n\t(reinterpret_pointer_cast): Define for C++17.\n\t(weak_ptr::_Convertible): Replace with _Constructible.\n\t(weak_ptr::_Constructible, weak_ptr::_Assignable): Forward checks\n\tto base class.\n\t(weak_ptr::weak_ptr, weak_ptr::operator=): Constrain templates\n\twith _Constructible and _Assignable.\n\t* include/bits/shared_ptr_base.h (__shared_ptr::_Convertible): Replace\n\twith _Compatible.\n\t(__shared_ptr::_SafeConv): New constraint for incoming raw pointers.\n\t(__shared_ptr::_Compatible): New constraint for converting from\n\tother types of shared_ptr and weak_ptr.\n\t(__shared_ptr::_Assignable): Define in terms of _Compatible.\n\t(__shared_ptr::_UniqCompatible, __shared_ptr::_UniqAssignable): New\n\tconstraints for converting from unique_ptr.\n\t(__shared_ptr::__shared_ptr, __shared_ptr::operator=): Constrain\n\ttemplate with _SaveConf, _Compatible and _Assignable. Remove\n\t__glibcxx_function_requires concept checks. Add static assertion for\n\tdeleter expression being well-formed.\n\t(__shared_ptr::__shared_ptr(__shared_ptr<_Tp1>, _Tp*))\n\t(__shared_ptr::operator*, __shared_ptr::operator->)\n\t(__shared_ptr::get, __shared_ptr::_M_ptr): Use element_type instead\n\tof _Tp.\n\t(operator<): Likewise.\n\t(operator>): Define in terms of operator<.\n\t(static_pointer_cast, const_pointer_cast, dynamic_pointer_cast): Use\n\telement_type instead of _Tp.\n\t(reinterpret_pointer_cast): Define for C++17.\n\t(weak_ptr::_Convertible): Replace with _Compatible.\n\t(weak_ptr::_Compatible, weak_ptr::_Assignable): New constraints for\n\tconversions from other types of weak_ptr and shared_ptr.\n\t(__weak_ptr::__weak_ptr, __weak_ptr::operator=): Constrain templates\n\twith _Constructible and _Assignable.\n\t(__weak_ptr::_M_ptr): Use element_type instead of _Tp.\n\t* testsuite/20_util/shared_ptr/assign/auto_ptr_neg.cc: Adjust\n\tdg-error pattern.\n\t* testsuite/20_util/shared_ptr/cons/auto_ptr.cc: Test conversions.\n\t* testsuite/20_util/shared_ptr/cons/unique_ptr.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/cons/void_neg.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/casts/reinterpret.cc: New test.\n\nFrom-SVN: r241373", "tree": {"sha": "0451d0f528deb80ecee74b5650a6dc720cab5e3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0451d0f528deb80ecee74b5650a6dc720cab5e3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2e0054e1d169984ec64d64145b71a88a9628537", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2e0054e1d169984ec64d64145b71a88a9628537", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2e0054e1d169984ec64d64145b71a88a9628537", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2e0054e1d169984ec64d64145b71a88a9628537/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f320e6a09193654596cd347fae835e85b458f94c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f320e6a09193654596cd347fae835e85b458f94c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f320e6a09193654596cd347fae835e85b458f94c"}], "stats": {"total": 651, "additions": 453, "deletions": 198}, "files": [{"sha": "6f47e0d2b620131c5f5baa9bcf12a097eb0353e0", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e0054e1d169984ec64d64145b71a88a9628537/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e0054e1d169984ec64d64145b71a88a9628537/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a2e0054e1d169984ec64d64145b71a88a9628537", "patch": "@@ -1,3 +1,60 @@\n+2016-10-20  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/backward/auto_ptr.h (__shared_ptr(auto_ptr&&))\n+\t(shared_ptr(auto_ptr&&)): Adjust template parameter lists.\n+\t* include/bits/shared_ptr.h (__sp_compatible_with)\n+\t(__sp_is_constructible): New helper traits for shared_ptr.\n+\t(shared_ptr::_Convertible): Replace with _Constructible.\n+\t(shared_ptr::_Constructible, shared_ptr::_Assignable): Forward checks\n+\tto base class.\n+\t(shared_ptr::shared_ptr, shared_ptr::operator=): Constrain template\n+\twith _Constructible and _Assignable.\n+\t(shared_ptr::shared_ptr(shared_ptr<_Tp1>, _Tp*)): Use element_type\n+\tinstead of _Tp.\n+\t(operator<): Likewise.\n+\t(operator>): Define in terms of operator<.\n+\t(static_pointer_cast, const_pointer_cast, dynamic_pointer_cast): Use\n+\telement_type instead of _Tp.\n+\t(reinterpret_pointer_cast): Define for C++17.\n+\t(weak_ptr::_Convertible): Replace with _Constructible.\n+\t(weak_ptr::_Constructible, weak_ptr::_Assignable): Forward checks\n+\tto base class.\n+\t(weak_ptr::weak_ptr, weak_ptr::operator=): Constrain templates\n+\twith _Constructible and _Assignable.\n+\t* include/bits/shared_ptr_base.h (__shared_ptr::_Convertible): Replace\n+\twith _Compatible.\n+\t(__shared_ptr::_SafeConv): New constraint for incoming raw pointers.\n+\t(__shared_ptr::_Compatible): New constraint for converting from\n+\tother types of shared_ptr and weak_ptr.\n+\t(__shared_ptr::_Assignable): Define in terms of _Compatible.\n+\t(__shared_ptr::_UniqCompatible, __shared_ptr::_UniqAssignable): New\n+\tconstraints for converting from unique_ptr.\n+\t(__shared_ptr::__shared_ptr, __shared_ptr::operator=): Constrain\n+\ttemplate with _SaveConf, _Compatible and _Assignable. Remove\n+\t__glibcxx_function_requires concept checks. Add static assertion for\n+\tdeleter expression being well-formed.\n+\t(__shared_ptr::__shared_ptr(__shared_ptr<_Tp1>, _Tp*))\n+\t(__shared_ptr::operator*, __shared_ptr::operator->)\n+\t(__shared_ptr::get, __shared_ptr::_M_ptr): Use element_type instead\n+\tof _Tp.\n+\t(operator<): Likewise.\n+\t(operator>): Define in terms of operator<.\n+\t(static_pointer_cast, const_pointer_cast, dynamic_pointer_cast): Use\n+\telement_type instead of _Tp.\n+\t(reinterpret_pointer_cast): Define for C++17.\n+\t(weak_ptr::_Convertible): Replace with _Compatible.\n+\t(weak_ptr::_Compatible, weak_ptr::_Assignable): New constraints for\n+\tconversions from other types of weak_ptr and shared_ptr.\n+\t(__weak_ptr::__weak_ptr, __weak_ptr::operator=): Constrain templates\n+\twith _Constructible and _Assignable.\n+\t(__weak_ptr::_M_ptr): Use element_type instead of _Tp.\n+\t* testsuite/20_util/shared_ptr/assign/auto_ptr_neg.cc: Adjust\n+\tdg-error pattern.\n+\t* testsuite/20_util/shared_ptr/cons/auto_ptr.cc: Test conversions.\n+\t* testsuite/20_util/shared_ptr/cons/unique_ptr.cc: Likewise.\n+\t* testsuite/20_util/shared_ptr/cons/void_neg.cc: Likewise.\n+\t* testsuite/20_util/shared_ptr/casts/reinterpret.cc: New test.\n+\n 2016-10-20  Ville Voutilainen  <ville.voutilainen@gmail.com>\n \n \tDo the operator= SFINAE in the return type for optional,"}, {"sha": "855b6f90dea215ec0698162ed9e829f327ec9d1d", "filename": "libstdc++-v3/include/backward/auto_ptr.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e0054e1d169984ec64d64145b71a88a9628537/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fauto_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e0054e1d169984ec64d64145b71a88a9628537/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fauto_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fauto_ptr.h?ref=a2e0054e1d169984ec64d64145b71a88a9628537", "patch": "@@ -302,7 +302,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { __r.release(); }\n \n   template<typename _Tp, _Lock_policy _Lp>\n-  template<typename _Tp1>\n+  template<typename _Tp1, typename>\n     inline\n     __shared_ptr<_Tp, _Lp>::__shared_ptr(std::auto_ptr<_Tp1>&& __r)\n     : _M_ptr(__r.get()), _M_refcount()\n@@ -315,7 +315,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Tp>\n-  template<typename _Tp1>\n+  template<typename _Tp1, typename>\n     inline\n     shared_ptr<_Tp>::shared_ptr(std::auto_ptr<_Tp1>&& __r)\n     : __shared_ptr<_Tp>(std::move(__r)) { }"}, {"sha": "9f7a40c5e1ed17b0b6a5fb0fd660c26a9e82552e", "filename": "libstdc++-v3/include/bits/shared_ptr.h", "status": "modified", "additions": 126, "deletions": 95, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e0054e1d169984ec64d64145b71a88a9628537/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e0054e1d169984ec64d64145b71a88a9628537/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h?ref=a2e0054e1d169984ec64d64145b71a88a9628537", "patch": "@@ -92,16 +92,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp>\n     class shared_ptr : public __shared_ptr<_Tp>\n     {\n-      template<typename _Ptr>\n-\tusing _Convertible = typename\n-\t  enable_if<is_convertible<_Ptr, _Tp*>::value>::type;\n+      template<typename... _Args>\n+\tusing _Constructible = typename enable_if<\n+\t  is_constructible<__shared_ptr<_Tp>, _Args...>::value\n+\t>::type;\n \n-      template<typename _Ptr>\n-\tusing _Assignable = typename\n-\t  enable_if<is_convertible<_Ptr, _Tp*>::value, shared_ptr&>::type;\n+      template<typename _Arg>\n+\tusing _Assignable = typename enable_if<\n+\t  is_assignable<__shared_ptr<_Tp>&, _Arg>::value, shared_ptr&\n+\t>::type;\n \n     public:\n \n+      using element_type = typename __shared_ptr<_Tp>::element_type;\n+\n #if __cplusplus > 201402L\n # define __cpp_lib_shared_ptr_weak_type 201606\n       using weak_type = weak_ptr<_Tp>;\n@@ -110,8 +114,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *  @brief  Construct an empty %shared_ptr.\n        *  @post   use_count()==0 && get()==0\n        */\n-      constexpr shared_ptr() noexcept\n-      : __shared_ptr<_Tp>() { }\n+      constexpr shared_ptr() noexcept : __shared_ptr<_Tp>() { }\n \n       shared_ptr(const shared_ptr&) noexcept = default;\n \n@@ -121,9 +124,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *  @post   use_count() == 1 && get() == __p\n        *  @throw  std::bad_alloc, in which case @c delete @a __p is called.\n        */\n-      template<typename _Tp1>\n-\texplicit shared_ptr(_Tp1* __p)\n-        : __shared_ptr<_Tp>(__p) { }\n+      template<typename _Yp, typename = _Constructible<_Yp*>>\n+\texplicit\n+\tshared_ptr(_Yp* __p) : __shared_ptr<_Tp>(__p) { }\n \n       /**\n        *  @brief  Construct a %shared_ptr that owns the pointer @a __p\n@@ -138,8 +141,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *\n        *  __shared_ptr will release __p by calling __d(__p)\n        */\n-      template<typename _Tp1, typename _Deleter>\n-\tshared_ptr(_Tp1* __p, _Deleter __d)\n+      template<typename _Yp, typename _Deleter,\n+\t       typename = _Constructible<_Yp*, _Deleter>>\n+\tshared_ptr(_Yp* __p, _Deleter __d)\n         : __shared_ptr<_Tp>(__p, __d) { }\n \n       /**\n@@ -174,8 +178,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *\n        *  __shared_ptr will release __p by calling __d(__p)\n        */\n-      template<typename _Tp1, typename _Deleter, typename _Alloc>\n-\tshared_ptr(_Tp1* __p, _Deleter __d, _Alloc __a)\n+      template<typename _Yp, typename _Deleter, typename _Alloc,\n+\t       typename = _Constructible<_Yp*, _Deleter, _Alloc>>\n+\tshared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)\n \t: __shared_ptr<_Tp>(__p, __d, std::move(__a)) { }\n \n       /**\n@@ -215,8 +220,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        * assert(pii.use_count() == 2);\n        * @endcode\n        */\n-      template<typename _Tp1>\n-\tshared_ptr(const shared_ptr<_Tp1>& __r, _Tp* __p) noexcept\n+      template<typename _Yp>\n+\tshared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) noexcept\n \t: __shared_ptr<_Tp>(__r, __p) { }\n \n       /**\n@@ -226,8 +231,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *  @param  __r  A %shared_ptr.\n        *  @post   get() == __r.get() && use_count() == __r.use_count()\n        */\n-      template<typename _Tp1, typename = _Convertible<_Tp1*>>\n-\tshared_ptr(const shared_ptr<_Tp1>& __r) noexcept\n+      template<typename _Yp,\n+\t       typename = _Constructible<const shared_ptr<_Yp>&>>\n+\tshared_ptr(const shared_ptr<_Yp>& __r) noexcept\n         : __shared_ptr<_Tp>(__r) { }\n \n       /**\n@@ -243,8 +249,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *  @param  __r  A %shared_ptr rvalue.\n        *  @post   *this contains the old value of @a __r, @a __r is empty.\n        */\n-      template<typename _Tp1, typename = _Convertible<_Tp1*>>\n-\tshared_ptr(shared_ptr<_Tp1>&& __r) noexcept\n+      template<typename _Yp, typename = _Constructible<shared_ptr<_Yp>>>\n+\tshared_ptr(shared_ptr<_Yp>&& __r) noexcept\n \t: __shared_ptr<_Tp>(std::move(__r)) { }\n \n       /**\n@@ -255,20 +261,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *  @throw  bad_weak_ptr when __r.expired(),\n        *          in which case the constructor has no effect.\n        */\n-      template<typename _Tp1>\n-\texplicit shared_ptr(const weak_ptr<_Tp1>& __r)\n+      template<typename _Yp, typename = _Constructible<const weak_ptr<_Yp>&>>\n+\texplicit shared_ptr(const weak_ptr<_Yp>& __r)\n \t: __shared_ptr<_Tp>(__r) { }\n \n #if _GLIBCXX_USE_DEPRECATED\n-      template<typename _Tp1>\n-\tshared_ptr(std::auto_ptr<_Tp1>&& __r);\n+      template<typename _Yp, typename = _Constructible<auto_ptr<_Yp>>>\n+\tshared_ptr(auto_ptr<_Yp>&& __r);\n #endif\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 2399. shared_ptr's constructor from unique_ptr should be constrained\n-      template<typename _Tp1, typename _Del, typename\n-\t       = _Convertible<typename unique_ptr<_Tp1, _Del>::pointer>>\n-\tshared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)\n+      template<typename _Yp, typename _Del,\n+\t       typename = _Constructible<unique_ptr<_Yp, _Del>>>\n+\tshared_ptr(unique_ptr<_Yp, _Del>&& __r)\n \t: __shared_ptr<_Tp>(std::move(__r)) { }\n \n       /**\n@@ -279,18 +285,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       shared_ptr& operator=(const shared_ptr&) noexcept = default;\n \n-      template<typename _Tp1>\n-\t_Assignable<_Tp1*>\n-\toperator=(const shared_ptr<_Tp1>& __r) noexcept\n+      template<typename _Yp>\n+\t_Assignable<const shared_ptr<_Yp>&>\n+\toperator=(const shared_ptr<_Yp>& __r) noexcept\n \t{\n \t  this->__shared_ptr<_Tp>::operator=(__r);\n \t  return *this;\n \t}\n \n #if _GLIBCXX_USE_DEPRECATED\n-      template<typename _Tp1>\n-\tshared_ptr&\n-\toperator=(std::auto_ptr<_Tp1>&& __r)\n+      template<typename _Yp>\n+\t_Assignable<auto_ptr<_Yp>>\n+\toperator=(auto_ptr<_Yp>&& __r)\n \t{\n \t  this->__shared_ptr<_Tp>::operator=(std::move(__r));\n \t  return *this;\n@@ -304,17 +310,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn *this;\n       }\n \n-      template<class _Tp1>\n-\t_Assignable<_Tp1*>\n-\toperator=(shared_ptr<_Tp1>&& __r) noexcept\n+      template<class _Yp>\n+\t_Assignable<shared_ptr<_Yp>>\n+\toperator=(shared_ptr<_Yp>&& __r) noexcept\n \t{\n \t  this->__shared_ptr<_Tp>::operator=(std::move(__r));\n \t  return *this;\n \t}\n \n-      template<typename _Tp1, typename _Del>\n-\t_Assignable<typename unique_ptr<_Tp1, _Del>::pointer>\n-\toperator=(std::unique_ptr<_Tp1, _Del>&& __r)\n+      template<typename _Yp, typename _Del>\n+\t_Assignable<unique_ptr<_Yp, _Del>>\n+\toperator=(unique_ptr<_Yp, _Del>&& __r)\n \t{\n \t  this->__shared_ptr<_Tp>::operator=(std::move(__r));\n \t  return *this;\n@@ -328,8 +334,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t: __shared_ptr<_Tp>(__tag, __a, std::forward<_Args>(__args)...)\n \t{ }\n \n-      template<typename _Tp1, typename _Alloc, typename... _Args>\n-\tfriend shared_ptr<_Tp1>\n+      template<typename _Yp, typename _Alloc, typename... _Args>\n+\tfriend shared_ptr<_Yp>\n \tallocate_shared(const _Alloc& __a, _Args&&... __args);\n \n       // This constructor is non-standard, it is used by weak_ptr::lock().\n@@ -340,10 +346,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n \n   // 20.7.2.2.7 shared_ptr comparisons\n-  template<typename _Tp1, typename _Tp2>\n+  template<typename _Tp, typename _Up>\n     inline bool\n-    operator==(const shared_ptr<_Tp1>& __a,\n-\t       const shared_ptr<_Tp2>& __b) noexcept\n+    operator==(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n     { return __a.get() == __b.get(); }\n \n   template<typename _Tp>\n@@ -356,10 +361,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     operator==(nullptr_t, const shared_ptr<_Tp>& __a) noexcept\n     { return !__a; }\n \n-  template<typename _Tp1, typename _Tp2>\n+  template<typename _Tp, typename _Up>\n     inline bool\n-    operator!=(const shared_ptr<_Tp1>& __a,\n-\t       const shared_ptr<_Tp2>& __b) noexcept\n+    operator!=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n     { return __a.get() != __b.get(); }\n \n   template<typename _Tp>\n@@ -372,29 +376,35 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     operator!=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept\n     { return (bool)__a; }\n \n-  template<typename _Tp1, typename _Tp2>\n+  template<typename _Tp, typename _Up>\n     inline bool\n-    operator<(const shared_ptr<_Tp1>& __a,\n-\t      const shared_ptr<_Tp2>& __b) noexcept\n+    operator<(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n     {\n-      typedef typename std::common_type<_Tp1*, _Tp2*>::type _CT;\n-      return std::less<_CT>()(__a.get(), __b.get());\n+      using _Tp_elt = typename shared_ptr<_Tp>::element_type;\n+      using _Up_elt = typename shared_ptr<_Up>::element_type;\n+      using _Vp = typename common_type<_Tp_elt*, _Up_elt*>::type;\n+      return less<_Vp>()(__a.get(), __b.get());\n     }\n \n   template<typename _Tp>\n     inline bool\n     operator<(const shared_ptr<_Tp>& __a, nullptr_t) noexcept\n-    { return std::less<_Tp*>()(__a.get(), nullptr); }\n+    {\n+      using _Tp_elt = typename shared_ptr<_Tp>::element_type;\n+      return less<_Tp_elt*>()(__a.get(), nullptr);\n+    }\n \n   template<typename _Tp>\n     inline bool\n     operator<(nullptr_t, const shared_ptr<_Tp>& __a) noexcept\n-    { return std::less<_Tp*>()(nullptr, __a.get()); }\n+    {\n+      using _Tp_elt = typename shared_ptr<_Tp>::element_type;\n+      return less<_Tp_elt*>()(nullptr, __a.get());\n+    }\n \n-  template<typename _Tp1, typename _Tp2>\n+  template<typename _Tp, typename _Up>\n     inline bool\n-    operator<=(const shared_ptr<_Tp1>& __a,\n-\t       const shared_ptr<_Tp2>& __b) noexcept\n+    operator<=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n     { return !(__b < __a); }\n \n   template<typename _Tp>\n@@ -407,26 +417,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     operator<=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept\n     { return !(__a < nullptr); }\n \n-  template<typename _Tp1, typename _Tp2>\n+  template<typename _Tp, typename _Up>\n     inline bool\n-    operator>(const shared_ptr<_Tp1>& __a,\n-\t      const shared_ptr<_Tp2>& __b) noexcept\n+    operator>(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n     { return (__b < __a); }\n \n   template<typename _Tp>\n     inline bool\n     operator>(const shared_ptr<_Tp>& __a, nullptr_t) noexcept\n-    { return std::less<_Tp*>()(nullptr, __a.get()); }\n+    { return nullptr < __a; }\n \n   template<typename _Tp>\n     inline bool\n     operator>(nullptr_t, const shared_ptr<_Tp>& __a) noexcept\n-    { return std::less<_Tp*>()(__a.get(), nullptr); }\n+    { return __a < nullptr; }\n \n-  template<typename _Tp1, typename _Tp2>\n+  template<typename _Tp, typename _Up>\n     inline bool\n-    operator>=(const shared_ptr<_Tp1>& __a,\n-\t       const shared_ptr<_Tp2>& __b) noexcept\n+    operator>=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n     { return !(__a < __b); }\n \n   template<typename _Tp>\n@@ -450,25 +458,41 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { __a.swap(__b); }\n \n   // 20.7.2.2.9 shared_ptr casts.\n-  template<typename _Tp, typename _Tp1>\n+  template<typename _Tp, typename _Up>\n     inline shared_ptr<_Tp>\n-    static_pointer_cast(const shared_ptr<_Tp1>& __r) noexcept\n-    { return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get())); }\n+    static_pointer_cast(const shared_ptr<_Up>& __r) noexcept\n+    {\n+      using _Sp = shared_ptr<_Tp>;\n+      return _Sp(__r, static_cast<typename _Sp::element_type*>(__r.get()));\n+    }\n \n-  template<typename _Tp, typename _Tp1>\n+  template<typename _Tp, typename _Up>\n     inline shared_ptr<_Tp>\n-    const_pointer_cast(const shared_ptr<_Tp1>& __r) noexcept\n-    { return shared_ptr<_Tp>(__r, const_cast<_Tp*>(__r.get())); }\n+    const_pointer_cast(const shared_ptr<_Up>& __r) noexcept\n+    {\n+      using _Sp = shared_ptr<_Tp>;\n+      return _Sp(__r, const_cast<typename _Sp::element_type*>(__r.get()));\n+    }\n \n-  template<typename _Tp, typename _Tp1>\n+  template<typename _Tp, typename _Up>\n     inline shared_ptr<_Tp>\n-    dynamic_pointer_cast(const shared_ptr<_Tp1>& __r) noexcept\n+    dynamic_pointer_cast(const shared_ptr<_Up>& __r) noexcept\n     {\n-      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))\n-\treturn shared_ptr<_Tp>(__r, __p);\n-      return shared_ptr<_Tp>();\n+      using _Sp = shared_ptr<_Tp>;\n+      if (auto* __p = dynamic_cast<typename _Sp::element_type*>(__r.get()))\n+\treturn _Sp(__r, __p);\n+      return _Sp();\n     }\n \n+#if __cplusplus > 201402L\n+  template<typename _Tp, typename _Up>\n+    inline shared_ptr<_Tp>\n+    reinterpret_pointer_cast(const shared_ptr<_Up>& __r) noexcept\n+    {\n+      using _Sp = shared_ptr<_Tp>;\n+      return _Sp(__r, reinterpret_cast<typename _Sp::element_type*>(__r.get()));\n+    }\n+#endif\n \n   /**\n    *  @brief  A smart pointer with weak semantics.\n@@ -478,43 +502,50 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp>\n     class weak_ptr : public __weak_ptr<_Tp>\n     {\n-      template<typename _Ptr>\n-\tusing _Convertible\n-\t  = typename enable_if<is_convertible<_Ptr, _Tp*>::value>::type;\n+      template<typename _Arg>\n+\tusing _Constructible = typename enable_if<\n+\t  is_constructible<__weak_ptr<_Tp>, _Arg>::value\n+\t>::type;\n+\n+      template<typename _Arg>\n+\tusing _Assignable = typename enable_if<\n+\t  is_assignable<__weak_ptr<_Tp>&, _Arg>::value, weak_ptr&\n+\t>::type;\n \n     public:\n       constexpr weak_ptr() noexcept = default;\n \n-      template<typename _Tp1, typename = _Convertible<_Tp1*>>\n-\tweak_ptr(const shared_ptr<_Tp1>& __r) noexcept\n+      template<typename _Yp,\n+\t       typename = _Constructible<const shared_ptr<_Yp>&>>\n+\tweak_ptr(const shared_ptr<_Yp>& __r) noexcept\n \t: __weak_ptr<_Tp>(__r) { }\n \n       weak_ptr(const weak_ptr&) noexcept = default;\n \n-      template<typename _Tp1, typename = _Convertible<_Tp1*>>\n-\tweak_ptr(const weak_ptr<_Tp1>& __r) noexcept\n+      template<typename _Yp, typename = _Constructible<const weak_ptr<_Yp>&>>\n+\tweak_ptr(const weak_ptr<_Yp>& __r) noexcept\n \t: __weak_ptr<_Tp>(__r) { }\n \n       weak_ptr(weak_ptr&&) noexcept = default;\n \n-      template<typename _Tp1, typename = _Convertible<_Tp1*>>\n-\tweak_ptr(weak_ptr<_Tp1>&& __r) noexcept\n+      template<typename _Yp, typename = _Constructible<weak_ptr<_Yp>>>\n+\tweak_ptr(weak_ptr<_Yp>&& __r) noexcept\n \t: __weak_ptr<_Tp>(std::move(__r)) { }\n \n       weak_ptr&\n       operator=(const weak_ptr& __r) noexcept = default;\n \n-      template<typename _Tp1>\n-\tweak_ptr&\n-\toperator=(const weak_ptr<_Tp1>& __r) noexcept\n+      template<typename _Yp>\n+\t_Assignable<const weak_ptr<_Yp>&>\n+\toperator=(const weak_ptr<_Yp>& __r) noexcept\n \t{\n \t  this->__weak_ptr<_Tp>::operator=(__r);\n \t  return *this;\n \t}\n \n-      template<typename _Tp1>\n-\tweak_ptr&\n-\toperator=(const shared_ptr<_Tp1>& __r) noexcept\n+      template<typename _Yp>\n+\t_Assignable<const shared_ptr<_Yp>&>\n+\toperator=(const shared_ptr<_Yp>& __r) noexcept\n \t{\n \t  this->__weak_ptr<_Tp>::operator=(__r);\n \t  return *this;\n@@ -523,9 +554,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       weak_ptr&\n       operator=(weak_ptr&& __r) noexcept = default;\n \n-      template<typename _Tp1>\n-\tweak_ptr&\n-\toperator=(weak_ptr<_Tp1>&& __r) noexcept\n+      template<typename _Yp>\n+\t_Assignable<weak_ptr<_Yp>>\n+\toperator=(weak_ptr<_Yp>&& __r) noexcept\n \t{\n \t  this->__weak_ptr<_Tp>::operator=(std::move(__r));\n \t  return *this;"}, {"sha": "c74c92ae73069ec2992bebd51e32507053d319d8", "filename": "libstdc++-v3/include/bits/shared_ptr_base.h", "status": "modified", "additions": 159, "deletions": 96, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e0054e1d169984ec64d64145b71a88a9628537/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e0054e1d169984ec64d64145b71a88a9628537/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h?ref=a2e0054e1d169984ec64d64145b71a88a9628537", "patch": "@@ -847,19 +847,55 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _M_pi = nullptr;\n     }\n \n+  // Helper traits for shared_ptr\n+\n+  template<typename _Yp_ptr, typename _Tp_ptr>\n+    struct __sp_compatible_with\n+    : false_type\n+    { };\n+\n+  template<typename _Yp, typename _Tp>\n+    struct __sp_compatible_with<_Yp*, _Tp*>\n+    : is_convertible<_Yp*, _Tp*>::type\n+    { };\n+\n   template<typename _Tp, _Lock_policy _Lp>\n     class __shared_ptr\n     {\n-      template<typename _Ptr>\n-\tusing _Convertible\n-\t  = typename enable_if<is_convertible<_Ptr, _Tp*>::value>::type;\n+    public:\n+      using element_type = _Tp;\n \n-      template<typename _Ptr>\n-\tusing _Assignable = typename\n-\t  enable_if<is_convertible<_Ptr, _Tp*>::value, __shared_ptr&>::type;\n+    private:\n+      // Trait to check if shared_ptr<T> can be constructed from Y*.\n+      template<typename _Tp1, typename _Yp>\n+\tusing __sp_is_constructible = is_convertible<_Yp*, _Tp1*>;\n+\n+      // Constraint for taking ownership of a pointer of type _Yp*:\n+      template<typename _Yp>\n+\tusing _SafeConv\n+\t  = typename enable_if<__sp_is_constructible<_Tp, _Yp>::value>::type;\n+\n+      // Constraint for construction from shared_ptr and weak_ptr:\n+      template<typename _Yp, typename _Res = void>\n+\tusing _Compatible = typename\n+\t  enable_if<__sp_compatible_with<_Yp*, _Tp*>::value, _Res>::type;\n+\n+      // Constraint for assignment from shared_ptr and weak_ptr:\n+      template<typename _Yp>\n+\tusing _Assignable = _Compatible<_Yp, __shared_ptr&>;\n+\n+      // Constraint for construction from unique_ptr:\n+      template<typename _Yp, typename _Del, typename _Res = void,\n+\t       typename _Ptr = typename unique_ptr<_Yp, _Del>::pointer>\n+\tusing _UniqCompatible = typename enable_if<\n+\t  is_convertible<_Ptr, element_type*>::value\n+\t  , _Res>::type;\n+\n+      // Constraint for assignment from unique_ptr:\n+      template<typename _Yp, typename _Del>\n+\tusing _UniqAssignable = _UniqCompatible<_Yp, _Del, __shared_ptr&>;\n \n     public:\n-      typedef _Tp   element_type;\n \n #if __cplusplus > 201402L\n       using weak_type = __weak_ptr<_Tp, _Lp>;\n@@ -869,31 +905,32 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       : _M_ptr(0), _M_refcount()\n       { }\n \n-      template<typename _Tp1>\n-\texplicit __shared_ptr(_Tp1* __p)\n-        : _M_ptr(__p), _M_refcount(__p)\n+      template<typename _Yp, typename = _SafeConv<_Yp>>\n+\texplicit\n+\t__shared_ptr(_Yp* __p)\n+\t: _M_ptr(__p), _M_refcount(__p)\n \t{\n-\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-\t  static_assert( !is_void<_Tp1>::value, \"incomplete type\" );\n-\t  static_assert( sizeof(_Tp1) > 0, \"incomplete type\" );\n+\t  static_assert( !is_void<_Yp>::value, \"incomplete type\" );\n+\t  static_assert( sizeof(_Yp) > 0, \"incomplete type\" );\n \t  _M_enable_shared_from_this_with(__p);\n \t}\n \n-      template<typename _Tp1, typename _Deleter>\n-\t__shared_ptr(_Tp1* __p, _Deleter __d)\n+      template<typename _Yp, typename _Deleter, typename = _SafeConv<_Yp>>\n+\t__shared_ptr(_Yp* __p, _Deleter __d)\n \t: _M_ptr(__p), _M_refcount(__p, __d)\n \t{\n-\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-\t  // TODO requires _Deleter CopyConstructible and __d(__p) well-formed\n+\t  static_assert(__is_callable<_Deleter(_Yp*)>::value,\n+\t      \"deleter expression d(p) is well-formed\");\n \t  _M_enable_shared_from_this_with(__p);\n \t}\n \n-      template<typename _Tp1, typename _Deleter, typename _Alloc>\n-\t__shared_ptr(_Tp1* __p, _Deleter __d, _Alloc __a)\n+      template<typename _Yp, typename _Deleter, typename _Alloc,\n+\t       typename = _SafeConv<_Yp>>\n+\t__shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)\n \t: _M_ptr(__p), _M_refcount(__p, __d, std::move(__a))\n \t{\n-\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-\t  // TODO requires _Deleter CopyConstructible and __d(__p) well-formed\n+\t  static_assert(__is_callable<_Deleter(_Yp*)>::value,\n+\t      \"deleter expression d(p) is well-formed\");\n \t  _M_enable_shared_from_this_with(__p);\n \t}\n \n@@ -907,17 +944,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t: _M_ptr(0), _M_refcount(__p, __d, std::move(__a))\n \t{ }\n \n-      template<typename _Tp1>\n-\t__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept\n+      template<typename _Yp>\n+\t__shared_ptr(const __shared_ptr<_Yp, _Lp>& __r,\n+\t\t     element_type* __p) noexcept\n \t: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws\n \t{ }\n \n       __shared_ptr(const __shared_ptr&) noexcept = default;\n       __shared_ptr& operator=(const __shared_ptr&) noexcept = default;\n       ~__shared_ptr() = default;\n \n-      template<typename _Tp1, typename = _Convertible<_Tp1*>>\n-\t__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r) noexcept\n+      template<typename _Yp, typename = _Compatible<_Yp>>\n+\t__shared_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept\n \t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)\n \t{ }\n \n@@ -928,58 +966,55 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__r._M_ptr = 0;\n       }\n \n-      template<typename _Tp1, typename = _Convertible<_Tp1*>>\n-\t__shared_ptr(__shared_ptr<_Tp1, _Lp>&& __r) noexcept\n+      template<typename _Yp, typename = _Compatible<_Yp>>\n+\t__shared_ptr(__shared_ptr<_Yp, _Lp>&& __r) noexcept\n \t: _M_ptr(__r._M_ptr), _M_refcount()\n \t{\n \t  _M_refcount._M_swap(__r._M_refcount);\n \t  __r._M_ptr = 0;\n \t}\n \n-      template<typename _Tp1>\n-\texplicit __shared_ptr(const __weak_ptr<_Tp1, _Lp>& __r)\n+      template<typename _Yp, typename = _Compatible<_Yp>>\n+\texplicit __shared_ptr(const __weak_ptr<_Yp, _Lp>& __r)\n \t: _M_refcount(__r._M_refcount) // may throw\n \t{\n-\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-\n \t  // It is now safe to copy __r._M_ptr, as\n \t  // _M_refcount(__r._M_refcount) did not throw.\n \t  _M_ptr = __r._M_ptr;\n \t}\n \n       // If an exception is thrown this constructor has no effect.\n-      template<typename _Tp1, typename _Del, typename\n-\t       = _Convertible<typename unique_ptr<_Tp1, _Del>::pointer>>\n-\t__shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)\n+      template<typename _Yp, typename _Del,\n+\t       typename = _UniqCompatible<_Yp, _Del>>\n+\t__shared_ptr(unique_ptr<_Yp, _Del>&& __r)\n \t: _M_ptr(__r.get()), _M_refcount()\n \t{\n-\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n \t  auto __raw = _S_raw_ptr(__r.get());\n \t  _M_refcount = __shared_count<_Lp>(std::move(__r));\n \t  _M_enable_shared_from_this_with(__raw);\n \t}\n \n #if _GLIBCXX_USE_DEPRECATED\n       // Postcondition: use_count() == 1 and __r.get() == 0\n-      template<typename _Tp1>\n-\t__shared_ptr(std::auto_ptr<_Tp1>&& __r);\n+      template<typename _Yp, typename = _Compatible<_Yp>>\n+\t__shared_ptr(auto_ptr<_Yp>&& __r);\n #endif\n \n       constexpr __shared_ptr(nullptr_t) noexcept : __shared_ptr() { }\n \n-      template<typename _Tp1>\n-\t_Assignable<_Tp1*>\n-\toperator=(const __shared_ptr<_Tp1, _Lp>& __r) noexcept\n+      template<typename _Yp>\n+\t_Assignable<_Yp>\n+\toperator=(const __shared_ptr<_Yp, _Lp>& __r) noexcept\n \t{\n \t  _M_ptr = __r._M_ptr;\n \t  _M_refcount = __r._M_refcount; // __shared_count::op= doesn't throw\n \t  return *this;\n \t}\n \n #if _GLIBCXX_USE_DEPRECATED\n-      template<typename _Tp1>\n-\t__shared_ptr&\n-\toperator=(std::auto_ptr<_Tp1>&& __r)\n+      template<typename _Yp>\n+\t_Assignable<_Yp>\n+\toperator=(auto_ptr<_Yp>&& __r)\n \t{\n \t  __shared_ptr(std::move(__r)).swap(*this);\n \t  return *this;\n@@ -993,17 +1028,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn *this;\n       }\n \n-      template<class _Tp1>\n-\t_Assignable<_Tp1*>\n-\toperator=(__shared_ptr<_Tp1, _Lp>&& __r) noexcept\n+      template<class _Yp>\n+\t_Assignable<_Yp>\n+\toperator=(__shared_ptr<_Yp, _Lp>&& __r) noexcept\n \t{\n \t  __shared_ptr(std::move(__r)).swap(*this);\n \t  return *this;\n \t}\n \n-      template<typename _Tp1, typename _Del>\n-\t_Assignable<typename unique_ptr<_Tp1, _Del>::pointer>\n-\toperator=(std::unique_ptr<_Tp1, _Del>&& __r)\n+      template<typename _Yp, typename _Del>\n+\t_UniqAssignable<_Yp, _Del>\n+\toperator=(unique_ptr<_Yp, _Del>&& __r)\n \t{\n \t  __shared_ptr(std::move(__r)).swap(*this);\n \t  return *this;\n@@ -1013,41 +1048,41 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       reset() noexcept\n       { __shared_ptr().swap(*this); }\n \n-      template<typename _Tp1>\n-\t_Convertible<_Tp1*>\n-\treset(_Tp1* __p) // _Tp1 must be complete.\n+      template<typename _Yp>\n+\t_SafeConv<_Yp>\n+\treset(_Yp* __p) // _Yp must be complete.\n \t{\n \t  // Catch self-reset errors.\n \t  __glibcxx_assert(__p == 0 || __p != _M_ptr);\n \t  __shared_ptr(__p).swap(*this);\n \t}\n \n-      template<typename _Tp1, typename _Deleter>\n-\t_Convertible<_Tp1*>\n-\treset(_Tp1* __p, _Deleter __d)\n+      template<typename _Yp, typename _Deleter>\n+\t_SafeConv<_Yp>\n+\treset(_Yp* __p, _Deleter __d)\n \t{ __shared_ptr(__p, __d).swap(*this); }\n \n-      template<typename _Tp1, typename _Deleter, typename _Alloc>\n-\t_Convertible<_Tp1*>\n-        reset(_Tp1* __p, _Deleter __d, _Alloc __a)\n+      template<typename _Yp, typename _Deleter, typename _Alloc>\n+\t_SafeConv<_Yp>\n+\treset(_Yp* __p, _Deleter __d, _Alloc __a)\n         { __shared_ptr(__p, __d, std::move(__a)).swap(*this); }\n \n       // Allow class instantiation when _Tp is [cv-qual] void.\n-      typename std::add_lvalue_reference<_Tp>::type\n+      typename std::add_lvalue_reference<element_type>::type\n       operator*() const noexcept\n       {\n \t__glibcxx_assert(_M_ptr != 0);\n \treturn *_M_ptr;\n       }\n \n-      _Tp*\n+      element_type*\n       operator->() const noexcept\n       {\n \t_GLIBCXX_DEBUG_PEDASSERT(_M_ptr != 0);\n \treturn _M_ptr;\n       }\n \n-      _Tp*\n+      element_type*\n       get() const noexcept\n       { return _M_ptr; }\n \n@@ -1192,7 +1227,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _Del, typename _Tp1, _Lock_policy _Lp1>\n \tfriend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&) noexcept;\n \n-      _Tp*\t   \t   _M_ptr;         // Contained pointer.\n+      element_type*\t   _M_ptr;         // Contained pointer.\n       __shared_count<_Lp>  _M_refcount;    // Reference counter.\n     };\n \n@@ -1230,24 +1265,32 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     operator!=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n     { return (bool)__a; }\n \n-  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>\n+  template<typename _Tp, typename _Up, _Lock_policy _Lp>\n     inline bool\n-    operator<(const __shared_ptr<_Tp1, _Lp>& __a,\n-\t      const __shared_ptr<_Tp2, _Lp>& __b) noexcept\n+    operator<(const __shared_ptr<_Tp, _Lp>& __a,\n+\t      const __shared_ptr<_Up, _Lp>& __b) noexcept\n     {\n-      typedef typename std::common_type<_Tp1*, _Tp2*>::type _CT;\n-      return std::less<_CT>()(__a.get(), __b.get());\n+      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;\n+      using _Up_elt = typename __shared_ptr<_Up, _Lp>::element_type;\n+      using _Vp = typename common_type<_Tp_elt*, _Up_elt*>::type;\n+      return less<_Vp>()(__a.get(), __b.get());\n     }\n \n   template<typename _Tp, _Lock_policy _Lp>\n     inline bool\n     operator<(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n-    { return std::less<_Tp*>()(__a.get(), nullptr); }\n+    {\n+      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;\n+      return less<_Tp_elt*>()(__a.get(), nullptr);\n+    }\n \n   template<typename _Tp, _Lock_policy _Lp>\n     inline bool\n     operator<(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n-    { return std::less<_Tp*>()(nullptr, __a.get()); }\n+    {\n+      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;\n+      return less<_Tp_elt*>()(nullptr, __a.get());\n+    }\n \n   template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>\n     inline bool\n@@ -1274,12 +1317,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp, _Lock_policy _Lp>\n     inline bool\n     operator>(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n-    { return std::less<_Tp*>()(nullptr, __a.get()); }\n+    { return nullptr < __a; }\n \n   template<typename _Tp, _Lock_policy _Lp>\n     inline bool\n     operator>(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n-    { return std::less<_Tp*>()(__a.get(), nullptr); }\n+    { return __a < nullptr; }\n \n   template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>\n     inline bool\n@@ -1329,7 +1372,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n     inline __shared_ptr<_Tp, _Lp>\n     static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept\n-    { return __shared_ptr<_Tp, _Lp>(__r, static_cast<_Tp*>(__r.get())); }\n+    {\n+      using _Sp = __shared_ptr<_Tp, _Lp>;\n+      return _Sp(__r, static_cast<typename _Sp::element_type*>(__r.get()));\n+    }\n \n   // The seemingly equivalent code:\n   // shared_ptr<_Tp, _Lp>(const_cast<_Tp*>(__r.get()))\n@@ -1339,7 +1385,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n     inline __shared_ptr<_Tp, _Lp>\n     const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept\n-    { return __shared_ptr<_Tp, _Lp>(__r, const_cast<_Tp*>(__r.get())); }\n+    {\n+      using _Sp = __shared_ptr<_Tp, _Lp>;\n+      return _Sp(__r, const_cast<typename _Sp::element_type*>(__r.get()));\n+    }\n \n   // The seemingly equivalent code:\n   // shared_ptr<_Tp, _Lp>(dynamic_cast<_Tp*>(__r.get()))\n@@ -1350,21 +1399,35 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     inline __shared_ptr<_Tp, _Lp>\n     dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept\n     {\n-      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))\n-\treturn __shared_ptr<_Tp, _Lp>(__r, __p);\n-      return __shared_ptr<_Tp, _Lp>();\n+      using _Sp = __shared_ptr<_Tp, _Lp>;\n+      if (auto* __p = dynamic_cast<typename _Sp::element_type*>(__r.get()))\n+\treturn _Sp(__r, __p);\n+      return _Sp();\n     }\n \n+#if __cplusplus > 201402L\n+  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n+    inline __shared_ptr<_Tp, _Lp>\n+    reinterpret_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept\n+    {\n+      using _Sp = __shared_ptr<_Tp, _Lp>;\n+      return _Sp(__r, reinterpret_cast<typename _Sp::element_type*>(__r.get()));\n+    }\n+#endif\n \n   template<typename _Tp, _Lock_policy _Lp>\n     class __weak_ptr\n     {\n-      template<typename _Ptr>\n-\tusing _Convertible\n-\t  = typename enable_if<is_convertible<_Ptr, _Tp*>::value>::type;\n+      template<typename _Yp, typename _Res = void>\n+\tusing _Compatible = typename\n+\t  enable_if<__sp_compatible_with<_Yp*, _Tp*>::value, _Res>::type;\n+\n+      // Constraint for assignment from shared_ptr and weak_ptr:\n+      template<typename _Yp>\n+\tusing _Assignable = _Compatible<_Yp, __weak_ptr&>;\n \n     public:\n-      typedef _Tp element_type;\n+      using element_type = _Tp;\n \n       constexpr __weak_ptr() noexcept\n       : _M_ptr(nullptr), _M_refcount()\n@@ -1388,40 +1451,40 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       //\n       // It is not possible to avoid spurious access violations since\n       // in multithreaded programs __r._M_ptr may be invalidated at any point.\n-      template<typename _Tp1, typename = _Convertible<_Tp1*>>\n-\t__weak_ptr(const __weak_ptr<_Tp1, _Lp>& __r) noexcept\n+      template<typename _Yp, typename = _Compatible<_Yp>>\n+\t__weak_ptr(const __weak_ptr<_Yp, _Lp>& __r) noexcept\n \t: _M_refcount(__r._M_refcount)\n         { _M_ptr = __r.lock().get(); }\n \n-      template<typename _Tp1, typename = _Convertible<_Tp1*>>\n-\t__weak_ptr(const __shared_ptr<_Tp1, _Lp>& __r) noexcept\n+      template<typename _Yp, typename = _Compatible<_Yp>>\n+\t__weak_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept\n \t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)\n \t{ }\n \n       __weak_ptr(__weak_ptr&& __r) noexcept\n       : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount))\n       { __r._M_ptr = nullptr; }\n \n-      template<typename _Tp1, typename = _Convertible<_Tp1*>>\n-\t__weak_ptr(__weak_ptr<_Tp1, _Lp>&& __r) noexcept\n+      template<typename _Yp, typename = _Compatible<_Yp>>\n+\t__weak_ptr(__weak_ptr<_Yp, _Lp>&& __r) noexcept\n \t: _M_ptr(__r.lock().get()), _M_refcount(std::move(__r._M_refcount))\n         { __r._M_ptr = nullptr; }\n \n       __weak_ptr&\n       operator=(const __weak_ptr& __r) noexcept = default;\n \n-      template<typename _Tp1>\n-\t__weak_ptr&\n-\toperator=(const __weak_ptr<_Tp1, _Lp>& __r) noexcept\n+      template<typename _Yp>\n+\t_Assignable<_Yp>\n+\toperator=(const __weak_ptr<_Yp, _Lp>& __r) noexcept\n \t{\n \t  _M_ptr = __r.lock().get();\n \t  _M_refcount = __r._M_refcount;\n \t  return *this;\n \t}\n \n-      template<typename _Tp1>\n-\t__weak_ptr&\n-\toperator=(const __shared_ptr<_Tp1, _Lp>& __r) noexcept\n+      template<typename _Yp>\n+\t_Assignable<_Yp>\n+\toperator=(const __shared_ptr<_Yp, _Lp>& __r) noexcept\n \t{\n \t  _M_ptr = __r._M_ptr;\n \t  _M_refcount = __r._M_refcount;\n@@ -1437,9 +1500,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn *this;\n       }\n \n-      template<typename _Tp1>\n-\t__weak_ptr&\n-\toperator=(__weak_ptr<_Tp1, _Lp>&& __r) noexcept\n+      template<typename _Yp>\n+\t_Assignable<_Yp>\n+\toperator=(__weak_ptr<_Yp, _Lp>&& __r) noexcept\n \t{\n \t  _M_ptr = __r.lock().get();\n \t  _M_refcount = std::move(__r._M_refcount);\n@@ -1497,7 +1560,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       friend class __enable_shared_from_this<_Tp, _Lp>;\n       friend class enable_shared_from_this<_Tp>;\n \n-      _Tp*\t \t _M_ptr;         // Contained pointer.\n+      element_type*\t _M_ptr;         // Contained pointer.\n       __weak_count<_Lp>  _M_refcount;    // Reference counter.\n     };\n "}, {"sha": "0558cf4153ff16f67c5bf78f21651e3babbe2239", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/assign/auto_ptr_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e0054e1d169984ec64d64145b71a88a9628537/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fauto_ptr_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e0054e1d169984ec64d64145b71a88a9628537/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fauto_ptr_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fauto_ptr_neg.cc?ref=a2e0054e1d169984ec64d64145b71a88a9628537", "patch": "@@ -34,7 +34,7 @@ test01()\n {\n   std::shared_ptr<A> a;\n   std::auto_ptr<B> b;\n-  a = std::move(b);                      // { dg-error \"here\" }\n+  a = std::move(b);                      // { dg-error \"no match\" }\n \n   return 0;\n }"}, {"sha": "e519f0ed73ea1d89fd5c773db13e888ba87572fb", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/casts/reinterpret.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e0054e1d169984ec64d64145b71a88a9628537/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcasts%2Freinterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e0054e1d169984ec64d64145b71a88a9628537/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcasts%2Freinterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcasts%2Freinterpret.cc?ref=a2e0054e1d169984ec64d64145b71a88a9628537", "patch": "@@ -0,0 +1,42 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile { target c++1z } }\n+\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.11.2.2.9 shared_ptr casts [util.smartptr.shared.cast]\n+\n+#include <memory>\n+#include <testsuite_tr1.h>\n+\n+struct MyP { virtual ~MyP() { }; };\n+struct MyDP : MyP { };\n+\n+int main()\n+{\n+  using __gnu_test::check_ret_type;\n+  using std::shared_ptr;\n+  using std::reinterpret_pointer_cast;\n+\n+  shared_ptr<double> spd;\n+  shared_ptr<const int> spci;\n+  shared_ptr<MyP> spa;\n+\n+  check_ret_type<shared_ptr<void> >(reinterpret_pointer_cast<void>(spd));\n+  check_ret_type<shared_ptr<const short> >(reinterpret_pointer_cast<const short>(spci));\n+  check_ret_type<shared_ptr<MyDP> >(reinterpret_pointer_cast<MyDP>(spa));\n+}"}, {"sha": "52481c122e2ec92c1bb12c4939fc9dec751586b6", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/auto_ptr.cc", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e0054e1d169984ec64d64145b71a88a9628537/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fauto_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e0054e1d169984ec64d64145b71a88a9628537/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fauto_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fauto_ptr.cc?ref=a2e0054e1d169984ec64d64145b71a88a9628537", "patch": "@@ -25,24 +25,53 @@\n \n struct A { };\n \n+int destroyed = 0;\n+struct B : A { ~B() { ++destroyed; } };\n+\n // 20.6.6.2.1 shared_ptr constructors [util.smartptr.shared.const]\n \n // Construction from auto_ptr\n-int\n+\n+template<typename From, typename To>\n+constexpr bool constructible()\n+{\n+  using namespace std;\n+  return is_constructible<shared_ptr<To>, auto_ptr<From>>::value\n+    && is_constructible<shared_ptr<const To>, auto_ptr<From>>::value\n+    && is_constructible<shared_ptr<const To>, auto_ptr<const From>>::value;\n+}\n+\n+static_assert(  constructible< A,   A    >(), \"A -> A compatible\" );\n+static_assert(  constructible< B,   A    >(), \"B -> A compatible\" );\n+static_assert(  constructible< int, int  >(), \"int -> int compatible\" );\n+static_assert( !constructible< int, long >(), \"int -> long not compatible\" );\n+\n+void\n test01()\n {\n   std::auto_ptr<A> a(new A);\n   std::shared_ptr<A> a2(std::move(a));\n   VERIFY( a.get() == 0 );\n   VERIFY( a2.get() != 0 );\n   VERIFY( a2.use_count() == 1 );\n+}\n \n-  return 0;\n+void\n+test02()\n+{\n+  std::auto_ptr<B> b(new B);\n+  std::shared_ptr<A> a(std::move(b));\n+  VERIFY( b.get() == 0 );\n+  VERIFY( a.get() != 0 );\n+  VERIFY( a.use_count() == 1 );\n+  a.reset();\n+  VERIFY( destroyed == 1 );\n }\n \n int\n main()\n {\n   test01();\n+  test02();\n   return 0;\n }"}, {"sha": "52bbd3b0e464f1456f6b1a72c827c9929f9844a4", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/unique_ptr.cc", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e0054e1d169984ec64d64145b71a88a9628537/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e0054e1d169984ec64d64145b71a88a9628537/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr.cc?ref=a2e0054e1d169984ec64d64145b71a88a9628537", "patch": "@@ -24,24 +24,53 @@\n \n struct A { };\n \n+int destroyed = 0;\n+struct B : A { ~B() { ++destroyed; } };\n+\n // 20.7.2.2.1 shared_ptr constructors [util.smartptr.shared.const]\n \n // Construction from unique_ptr\n-int\n+\n+template<typename From, typename To>\n+constexpr bool constructible()\n+{\n+  using namespace std;\n+  return is_constructible<shared_ptr<To>, unique_ptr<From>>::value\n+    && is_constructible<shared_ptr<const To>, unique_ptr<From>>::value\n+    && is_constructible<shared_ptr<const To>, unique_ptr<const From>>::value;\n+}\n+\n+static_assert(  constructible< A,   A    >(), \"A -> A compatible\" );\n+static_assert(  constructible< B,   A    >(), \"B -> A compatible\" );\n+static_assert(  constructible< int, int  >(), \"int -> int compatible\" );\n+static_assert( !constructible< int, long >(), \"int -> long not compatible\" );\n+\n+void\n test01()\n {\n   std::unique_ptr<A> up(new A);\n   std::shared_ptr<A> sp(std::move(up));\n   VERIFY( up.get() == 0 );\n   VERIFY( sp.get() != 0 );\n   VERIFY( sp.use_count() == 1 );\n+}\n \n-  return 0;\n+void\n+test02()\n+{\n+  std::unique_ptr<B> b(new B);\n+  std::shared_ptr<A> a(std::move(b));\n+  VERIFY( b.get() == 0 );\n+  VERIFY( a.get() != 0 );\n+  VERIFY( a.use_count() == 1 );\n+  a.reset();\n+  VERIFY( destroyed == 1 );\n }\n \n int\n main()\n {\n   test01();\n+  test02();\n   return 0;\n }"}, {"sha": "ba2864499123f41dc640f2e5314fc2e32be21f61", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/void_neg.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e0054e1d169984ec64d64145b71a88a9628537/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fvoid_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e0054e1d169984ec64d64145b71a88a9628537/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fvoid_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Fvoid_neg.cc?ref=a2e0054e1d169984ec64d64145b71a88a9628537", "patch": "@@ -26,3 +26,7 @@ void test01()\n   std::shared_ptr<void> p((void*)nullptr);   // { dg-error \"here\" }\n   // { dg-error \"incomplete\" \"\" { target *-*-* } 0 }\n }\n+\n+using std::shared_ptr;\n+using std::is_constructible;\n+static_assert(!is_constructible<shared_ptr<void>, const void*>::value, \"\");"}]}