{"sha": "677f99cce56ecbafbb2f648fb345f5d051cef6cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc3Zjk5Y2NlNTZlY2JhZmJiMmY2NDhmYjM0NWY1ZDA1MWNlZjZjYw==", "commit": {"author": {"name": "Mohan Embar", "email": "gnustuff@thisiscool.com", "date": "2003-12-20T15:33:24Z"}, "committer": {"name": "Mohan Embar", "email": "membar@gcc.gnu.org", "date": "2003-12-20T15:33:24Z"}, "message": "* gnu/java/nio/SelectorImpl.java\n\t(selectThreadMutex): New field.\n\t(selectThread): New field.\n\t(unhandledWakeup): New field.\n\t(implCloseSelector): Added skeleton code which\n\tsynchronizes as per Sun JRE JavaDoc.\n\t(keys): Throw ClosedSelectorException if selector\n\tis closed.\n\t(selectNow): Added comment that we're faking out\n\tan immediate select with a one-microsecond-timeout one.\n\t(select): Use 0 instead of -1 for infinite timeout.\n\t(implSelect): Changed comment in declaration.\n\t(select): Added synchronized to method declaration.\n\tAdded synchronization and wakeup support as per Sun\n\tJRE JavaDoc.\n\t(selectedKeys): Throw ClosedSelectorException if selector\n\tis closed.\n\t(wakeup): Implemented.\n\t(deregisterCancelledKeys): Synchronize on cancelled key\n\tset before deregistering.\n\t(register): Synchronize on key set before registering.\n\t* java/nio/channels/spi/AbstractSelector.java\n\tAdded import for java.nio.channels.ClosedSelectorException.\n\t(close): Added synchronized to method declaration.\n\t(cancelledKeys): Throw ClosedSelectorException if selector\n\tis closed.\n\t(cancelKey): Synchronize on cancelled key set before key.\n\nFrom-SVN: r74879", "tree": {"sha": "b5bed309c7a6e581e386dd9be0e16fa13651636b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5bed309c7a6e581e386dd9be0e16fa13651636b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/677f99cce56ecbafbb2f648fb345f5d051cef6cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/677f99cce56ecbafbb2f648fb345f5d051cef6cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/677f99cce56ecbafbb2f648fb345f5d051cef6cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/677f99cce56ecbafbb2f648fb345f5d051cef6cc/comments", "author": null, "committer": null, "parents": [{"sha": "59687e189077b503621c5c0066276f078436e1bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59687e189077b503621c5c0066276f078436e1bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59687e189077b503621c5c0066276f078436e1bf"}], "stats": {"total": 328, "additions": 247, "deletions": 81}, "files": [{"sha": "fb5bf5ed56388fa9856971e888cb95a6f8cdf4ac", "filename": "libjava/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677f99cce56ecbafbb2f648fb345f5d051cef6cc/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677f99cce56ecbafbb2f648fb345f5d051cef6cc/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=677f99cce56ecbafbb2f648fb345f5d051cef6cc", "patch": "@@ -1,3 +1,33 @@\n+2003-12-20  Mohan Embar  <gnustuff@thisiscool.com>\n+\n+\t* gnu/java/nio/SelectorImpl.java\n+\t(selectThreadMutex): New field.\n+\t(selectThread): New field.\n+\t(unhandledWakeup): New field.\n+\t(implCloseSelector): Added skeleton code which\n+\tsynchronizes as per Sun JRE JavaDoc.\n+\t(keys): Throw ClosedSelectorException if selector\n+\tis closed.\n+\t(selectNow): Added comment that we're faking out\n+\tan immediate select with a one-microsecond-timeout one.\n+\t(select): Use 0 instead of -1 for infinite timeout.\n+\t(implSelect): Changed comment in declaration.\n+\t(select): Added synchronized to method declaration.\n+\tAdded synchronization and wakeup support as per Sun\n+\tJRE JavaDoc.\n+\t(selectedKeys): Throw ClosedSelectorException if selector\n+\tis closed.\n+\t(wakeup): Implemented.\n+\t(deregisterCancelledKeys): Synchronize on cancelled key\n+\tset before deregistering.\n+\t(register): Synchronize on key set before registering.\n+\t* java/nio/channels/spi/AbstractSelector.java\n+\tAdded import for java.nio.channels.ClosedSelectorException.\n+\t(close): Added synchronized to method declaration.\n+\t(cancelledKeys): Throw ClosedSelectorException if selector\n+\tis closed.\n+\t(cancelKey): Synchronize on cancelled key set before key.\n+\n 2003-12-20  Michael Koch  <konqueror@gmx.de>\n \n \t* Makefile.am (ordinary_java_source_files):"}, {"sha": "f26e0808074f9450002e85776ca6aa947eb2be94", "filename": "libjava/gnu/java/nio/SelectorImpl.java", "status": "modified", "additions": 208, "deletions": 79, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677f99cce56ecbafbb2f648fb345f5d051cef6cc/libjava%2Fgnu%2Fjava%2Fnio%2FSelectorImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677f99cce56ecbafbb2f648fb345f5d051cef6cc/libjava%2Fgnu%2Fjava%2Fnio%2FSelectorImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FSelectorImpl.java?ref=677f99cce56ecbafbb2f648fb345f5d051cef6cc", "patch": "@@ -65,6 +65,28 @@ public class SelectorImpl extends AbstractSelector\n   private Set keys;\n   private Set selected;\n \n+  /**\n+   * A dummy object whose monitor regulates access to both our\n+   * selectThread and unhandledWakeup fields.\n+   */\n+  private Object selectThreadMutex = new Object ();\n+  \n+  /**\n+   * Any thread that's currently blocked in a select operation.\n+   */\n+  private Thread selectThread;\n+  \n+  /**\n+   * Indicates whether we have an unhandled wakeup call. This can\n+   * be due to either wakeup() triggering a thread interruption while\n+   * a thread was blocked in a select operation (in which case we need\n+   * to reset this thread's interrupt status after interrupting the\n+   * select), or else that no thread was on a select operation at the\n+   * time that wakeup() was called, in which case the following select()\n+   * operation should return immediately with nothing selected.\n+   */\n+  private boolean unhandledWakeup;\n+\n   public SelectorImpl (SelectorProvider provider)\n   {\n     super (provider);\n@@ -81,28 +103,44 @@ protected void finalize() throws Throwable\n   protected final void implCloseSelector()\n     throws IOException\n   {\n-    // FIXME: We surely need to do more here.\n+    // Cancel any pending select operation.\n     wakeup();\n+    \n+    synchronized (keys)\n+      {\n+        synchronized (selected)\n+          {\n+            synchronized (cancelledKeys ())\n+              {\n+                // FIXME: Release resources here.\n+              }\n+          }\n+      }\n   }\n \n   public final Set keys()\n   {\n+    if (!isOpen())\n+      throw new ClosedSelectorException();\n+\n     return Collections.unmodifiableSet (keys);\n   }\n     \n   public final int selectNow()\n     throws IOException\n   {\n+    // FIXME: We're simulating an immediate select\n+    // via a select with a timeout of one millisecond.\n     return select (1);\n   }\n \n   public final int select()\n     throws IOException\n   {\n-    return select (-1);\n+    return select (0);\n   }\n \n-  // A timeout value of -1 means block forever.\n+  // A timeout value of 0 means block forever.\n   private static native int implSelect (int[] read, int[] write,\n                                         int[] except, long timeout)\n     throws IOException;\n@@ -144,112 +182,199 @@ private final int[] getFDsAsArray (int ops)\n     return result;\n   }\n \n-  public int select (long timeout)\n+  public synchronized int select (long timeout)\n     throws IOException\n   {\n     if (!isOpen())\n-      throw new ClosedSelectorException ();\n-\n-    if (keys == null)\n-\t    {\n-        return 0;\n-\t    }\n-\n-    deregisterCancelledKeys();\n-\n-    // Set only keys with the needed interest ops into the arrays.\n-    int[] read = getFDsAsArray (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT);\n-    int[] write = getFDsAsArray (SelectionKey.OP_WRITE | SelectionKey.OP_CONNECT);\n-    int[] except = new int [0]; // FIXME: We dont need to check this yet\n-    int anzahl = read.length + write.length + except.length;\n-\n-    // Call the native select() on all file descriptors.\n-    begin();\n-    int result = implSelect (read, write, except, timeout);\n-    end();\n-\n-    Iterator it = keys.iterator ();\n-\n-    while (it.hasNext ())\n+      throw new ClosedSelectorException();\n+      \n+    synchronized (keys)\n       {\n-        int ops = 0;\n-        SelectionKeyImpl key = (SelectionKeyImpl) it.next ();\n-\n-        // If key is already selected retrieve old ready ops.\n-        if (selected.contains (key))\n+        synchronized (selected)\n           {\n-            ops = key.readyOps ();\n-          }\n-\n-        // Set new ready read/accept ops\n-        for (int i = 0; i < read.length; i++)\n-          {\n-            if (key.getNativeFD() == read[i])\n+            deregisterCancelledKeys();\n+\n+            // Set only keys with the needed interest ops into the arrays.\n+            int[] read = getFDsAsArray (SelectionKey.OP_READ\n+                                        | SelectionKey.OP_ACCEPT);\n+            int[] write = getFDsAsArray (SelectionKey.OP_WRITE\n+                                         | SelectionKey.OP_CONNECT);\n+\n+            // FIXME: We dont need to check this yet\n+            int[] except = new int [0];\n+\n+            // Test to see if we've got an unhandled wakeup call,\n+            // in which case we return immediately. Otherwise,\n+            // remember our current thread and jump into the select.\n+            // The monitor for dummy object selectThreadMutex regulates\n+            // access to these fields.\n+\n+            // FIXME: Not sure from the spec at what point we should\n+            // return \"immediately\". Is it here or immediately upon\n+            // entry to this function?\n+            \n+            // NOTE: There's a possibility of another thread calling\n+            // wakeup() immediately after our thread releases\n+            // selectThreadMutex's monitor here, in which case we'll\n+            // do the select anyway. Since calls to wakeup() and select()\n+            // among different threads happen in non-deterministic order,\n+            // I don't think this is an issue.\n+            synchronized (selectThreadMutex)\n               {\n-                if (key.channel () instanceof ServerSocketChannelImpl)\n+                if (unhandledWakeup)\n                   {\n-                    ops = ops | SelectionKey.OP_ACCEPT;\n+                    unhandledWakeup = false;\n+                    return 0;\n                   }\n                 else\n                   {\n-                    ops = ops | SelectionKey.OP_READ;\n+                    selectThread = Thread.currentThread ();\n                   }\n               }\n-          }\n \n-        // Set new ready write ops\n-        for (int i = 0; i < write.length; i++)\n-          {\n-            if (key.getNativeFD() == write[i])\n+            // Call the native select() on all file descriptors.\n+            int result = 0;\n+            try\n               {\n-                ops = ops | SelectionKey.OP_WRITE;\n-                \n-//                 if (key.channel ().isConnected ())\n-//                   {\n-//                     ops = ops | SelectionKey.OP_WRITE;\n-//                   }\n-//                 else\n-//                   {\n-//                     ops = ops | SelectionKey.OP_CONNECT;\n-//                   }\n-             }\n-          }\n+                begin();\n+                result = implSelect (read, write, except, timeout);\n+              }\n+            finally\n+              {\n+                end();\n+              }\n \n-        // FIXME: We dont handle exceptional file descriptors yet.\n+            // If our unhandled wakeup flag is set at this point,\n+            // reset our thread's interrupt flag because we were\n+            // awakened by wakeup() instead of an external thread\n+            // interruption.\n+            //\n+            // NOTE: If we were blocked in a select() and one thread\n+            // called Thread.interrupt() on the blocked thread followed\n+            // by another thread calling Selector.wakeup(), then race\n+            // conditions could make it so that the thread's interrupt\n+            // flag is reset even though the Thread.interrupt() call\n+            // \"was there first\". I don't think we need to care about\n+            // this scenario.\n+            synchronized (selectThreadMutex)\n+              {\n+                if (unhandledWakeup)\n+                  {\n+                    unhandledWakeup = false;\n+                    selectThread.interrupted ();\n+                  }\n+                selectThread = null;\n+              }\n \n-        // If key is not yet selected add it.\n-        if (!selected.contains (key))\n-          {\n-            selected.add (key);\n-          }\n+            Iterator it = keys.iterator ();\n \n-        // Set new ready ops\n-        key.readyOps (key.interestOps () & ops);\n-      }\n+            while (it.hasNext ())\n+              {\n+                int ops = 0;\n+                SelectionKeyImpl key = (SelectionKeyImpl) it.next ();\n \n-    deregisterCancelledKeys();\n-    return result;\n+                // If key is already selected retrieve old ready ops.\n+                if (selected.contains (key))\n+                  {\n+                    ops = key.readyOps ();\n+                  }\n+\n+                // Set new ready read/accept ops\n+                for (int i = 0; i < read.length; i++)\n+                  {\n+                    if (key.getNativeFD() == read[i])\n+                      {\n+                        if (key.channel () instanceof ServerSocketChannelImpl)\n+                          {\n+                            ops = ops | SelectionKey.OP_ACCEPT;\n+                          }\n+                        else\n+                          {\n+                            ops = ops | SelectionKey.OP_READ;\n+                          }\n+                      }\n+                  }\n+\n+                // Set new ready write ops\n+                for (int i = 0; i < write.length; i++)\n+                  {\n+                    if (key.getNativeFD() == write[i])\n+                      {\n+                        ops = ops | SelectionKey.OP_WRITE;\n+\n+        //                 if (key.channel ().isConnected ())\n+        //                   {\n+        //                     ops = ops | SelectionKey.OP_WRITE;\n+        //                   }\n+        //                 else\n+        //                   {\n+        //                     ops = ops | SelectionKey.OP_CONNECT;\n+        //                   }\n+                     }\n+                  }\n+\n+                // FIXME: We dont handle exceptional file descriptors yet.\n+\n+                // If key is not yet selected add it.\n+                if (!selected.contains (key))\n+                  {\n+                    selected.add (key);\n+                  }\n+\n+                // Set new ready ops\n+                key.readyOps (key.interestOps () & ops);\n+              }\n+            deregisterCancelledKeys();\n+            \n+            return result;\n+          }\n+        }\n   }\n     \n   public final Set selectedKeys()\n   {\n+    if (!isOpen())\n+      throw new ClosedSelectorException();\n+\n     return selected;\n   }\n \n   public final Selector wakeup()\n   {\n-    return null;\n+    // IMPLEMENTATION NOTE: Whereas the specification says that\n+    // thread interruption should trigger a call to wakeup, we\n+    // do the reverse under the covers: wakeup triggers a thread\n+    // interrupt followed by a subsequent reset of the thread's\n+    // interrupt status within select().\n+    \n+    // First, acquire the monitor of the object regulating\n+    // access to our selectThread and unhandledWakeup fields.\n+    synchronized (selectThreadMutex)\n+      {\n+        unhandledWakeup = true;\n+        \n+        // Interrupt any thread which is currently blocked in\n+        // a select operation.\n+        if (selectThread != null)\n+          selectThread.interrupt ();\n+      }\n+      \n+    return this;\n   }\n \n   private final void deregisterCancelledKeys()\n   {\n-    Iterator it = cancelledKeys().iterator();\n-\n-    while (it.hasNext ())\n-      {\n-        keys.remove ((SelectionKeyImpl) it.next ());\n-        it.remove ();\n-      }\n+    Set ckeys = cancelledKeys ();\n+    synchronized (ckeys)\n+    {\n+      Iterator it = ckeys.iterator();\n+\n+      while (it.hasNext ())\n+        {\n+          keys.remove ((SelectionKeyImpl) it.next ());\n+          it.remove ();\n+        }\n+    }\n   }\n \n   protected SelectionKey register (SelectableChannel ch, int ops, Object att)\n@@ -282,7 +407,11 @@ else if (ch instanceof ServerSocketChannelImpl)\n         throw new InternalError (\"No known channel type\");\n       }\n \n-    keys.add (result);\n+    synchronized (keys)\n+      {\n+        keys.add (result);\n+      }\n+\n     result.interestOps (ops);\n     result.attach (att);\n     return result;"}, {"sha": "ca7718733d74259f47a8276a0559f78f9dcaceab", "filename": "libjava/java/nio/channels/spi/AbstractSelector.java", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677f99cce56ecbafbb2f648fb345f5d051cef6cc/libjava%2Fjava%2Fnio%2Fchannels%2Fspi%2FAbstractSelector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677f99cce56ecbafbb2f648fb345f5d051cef6cc/libjava%2Fjava%2Fnio%2Fchannels%2Fspi%2FAbstractSelector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2Fspi%2FAbstractSelector.java?ref=677f99cce56ecbafbb2f648fb345f5d051cef6cc", "patch": "@@ -39,6 +39,7 @@\n package java.nio.channels.spi;\n \n import java.io.IOException;\n+import java.nio.channels.ClosedSelectorException;\n import java.nio.channels.SelectionKey;\n import java.nio.channels.Selector;\n import java.util.Set;\n@@ -64,7 +65,7 @@ protected AbstractSelector (SelectorProvider provider)\n    * \n    * @exception IOException If an error occurs\n    */\n-  public final void close () throws IOException\n+  public final synchronized void close () throws IOException\n   {\n     if (closed)\n       return;\n@@ -102,12 +103,18 @@ public final SelectorProvider provider ()\n \n   protected final Set cancelledKeys()\n   {\n+    if (!isOpen())\n+      throw new ClosedSelectorException();\n+\n     return cancelledKeys;\n   }\n \n   final void cancelKey (AbstractSelectionKey key)\n   {\n-    cancelledKeys.remove (key);\n+    synchronized (cancelledKeys)\n+      {\n+        cancelledKeys.remove(key);\n+      }\n   }\n \n   /**"}]}