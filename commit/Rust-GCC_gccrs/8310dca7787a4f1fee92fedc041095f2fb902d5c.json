{"sha": "8310dca7787a4f1fee92fedc041095f2fb902d5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODMxMGRjYTc3ODdhNGYxZmVlOTJmZWRjMDQxMDk1ZjJmYjkwMmQ1Yw==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2012-02-28T08:51:39Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2012-02-28T08:51:39Z"}, "message": "re PR rtl-optimization/52148 (ICE: in spill_failure, at reload1.c:2120)\n\n\tPR target/52148\n\t* config/avr/avr.md (movmem_<mode>): Replace match_operand that\n\tmatch only one single hard register with respective hard reg rtx.\n\t(movmemx_<mode>): Ditto.\n\t* config/avr/avr.c (avr_emit_movmemhi): Adapt expanding to new\n\tinsn anatomy of movmem[x]_<mode>.\n\t(avr_out_movmem): Same for printing assembler and operand usage.\n\nFrom-SVN: r184615", "tree": {"sha": "91edfccb4fb996809f085e75185343238a3d6185", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91edfccb4fb996809f085e75185343238a3d6185"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8310dca7787a4f1fee92fedc041095f2fb902d5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8310dca7787a4f1fee92fedc041095f2fb902d5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8310dca7787a4f1fee92fedc041095f2fb902d5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8310dca7787a4f1fee92fedc041095f2fb902d5c/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bae3b1bfdc3dad7a228af75cfa5afc7e0d57ba64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bae3b1bfdc3dad7a228af75cfa5afc7e0d57ba64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bae3b1bfdc3dad7a228af75cfa5afc7e0d57ba64"}], "stats": {"total": 143, "additions": 72, "deletions": 71}, "files": [{"sha": "232754873bf8ebe367f39ca60a2fec0eb98c268e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8310dca7787a4f1fee92fedc041095f2fb902d5c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8310dca7787a4f1fee92fedc041095f2fb902d5c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8310dca7787a4f1fee92fedc041095f2fb902d5c", "patch": "@@ -1,3 +1,13 @@\n+2012-02-28  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/52148\n+\t* config/avr/avr.md (movmem_<mode>): Replace match_operand that\n+\tmatch only one single hard register with respective hard reg rtx.\n+\t(movmemx_<mode>): Ditto.\n+\t* config/avr/avr.c (avr_emit_movmemhi): Adapt expanding to new\n+\tinsn anatomy of movmem[x]_<mode>.\n+\t(avr_out_movmem): Same for printing assembler and operand usage.\n+\n 2012-02-28  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/49868"}, {"sha": "4779aabfc79f6c114b9865ed0a088a3fd2758bab", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 30, "deletions": 43, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8310dca7787a4f1fee92fedc041095f2fb902d5c/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8310dca7787a4f1fee92fedc041095f2fb902d5c/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=8310dca7787a4f1fee92fedc041095f2fb902d5c", "patch": "@@ -9935,7 +9935,7 @@ avr_emit_movmemhi (rtx *xop)\n   HOST_WIDE_INT count;\n   enum machine_mode loop_mode;\n   addr_space_t as = MEM_ADDR_SPACE (xop[1]);\n-  rtx loop_reg, addr0, addr1, a_src, a_dest, insn, xas, reg_x;\n+  rtx loop_reg, addr1, a_src, a_dest, insn, xas;\n   rtx a_hi8 = NULL_RTX;\n \n   if (avr_mem_flash_p (xop[0]))\n@@ -9991,11 +9991,7 @@ avr_emit_movmemhi (rtx *xop)\n         X = destination address  */\n \n   emit_move_insn (lpm_addr_reg_rtx, addr1);\n-  addr1 = lpm_addr_reg_rtx;\n-\n-  reg_x = gen_rtx_REG (HImode, REG_X);\n-  emit_move_insn (reg_x, a_dest);\n-  addr0 = reg_x;\n+  emit_move_insn (gen_rtx_REG (HImode, REG_X), a_dest);\n \n   /* FIXME: Register allocator does a bad job and might spill address\n         register(s) inside the loop leading to additional move instruction\n@@ -10010,23 +10006,19 @@ avr_emit_movmemhi (rtx *xop)\n       /* Load instruction ([E]LPM or LD) is known at compile time:\n          Do the copy-loop inline.  */\n       \n-      rtx (*fun) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx)\n+      rtx (*fun) (rtx, rtx, rtx)\n         = QImode == loop_mode ? gen_movmem_qi : gen_movmem_hi;\n \n-      insn = fun (addr0, addr1, xas, loop_reg,\n-                  addr0, addr1, tmp_reg_rtx, loop_reg);\n+      insn = fun (xas, loop_reg, loop_reg);\n     }\n   else\n     {\n-      rtx loop_reg16 = gen_rtx_REG (HImode, 24);\n-      rtx r23 = gen_rtx_REG (QImode, 23);\n-      rtx (*fun) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx)\n+      rtx (*fun) (rtx, rtx)\n         = QImode == loop_mode ? gen_movmemx_qi : gen_movmemx_hi;\n \n-      emit_move_insn (r23, a_hi8);\n+      emit_move_insn (gen_rtx_REG (QImode, 23), a_hi8);\n       \n-      insn = fun (addr0, addr1, xas, loop_reg, addr0, addr1,\n-                  lpm_reg_rtx, loop_reg16, r23, r23, GEN_INT (avr_addr.rampz));\n+      insn = fun (xas, GEN_INT (avr_addr.rampz));\n     }\n \n   set_mem_addr_space (SET_SRC (XVECEXP (insn, 0, 0)), as);\n@@ -10037,32 +10029,27 @@ avr_emit_movmemhi (rtx *xop)\n \n \n /* Print assembler for movmem_qi, movmem_hi insns...\n-       $0, $4 : & dest\n-       $1, $5 : & src\n-       $2     : Address Space\n-       $3, $7 : Loop register\n-       $6     : Scratch register\n-\n-   ...and movmem_qi_elpm, movmem_hi_elpm insns.\n-   \n-       $8, $9 : hh8 (& src)\n-       $10    : RAMPZ_ADDR\n+       $0     : Address Space\n+       $1, $2 : Loop register\n+       Z      : Source address\n+       X      : Destination address\n */\n \n const char*\n-avr_out_movmem (rtx insn ATTRIBUTE_UNUSED, rtx *xop, int *plen)\n+avr_out_movmem (rtx insn ATTRIBUTE_UNUSED, rtx *op, int *plen)\n {\n-  addr_space_t as = (addr_space_t) INTVAL (xop[2]);\n-  enum machine_mode loop_mode = GET_MODE (xop[3]);\n-\n-  bool sbiw_p = test_hard_reg_class (ADDW_REGS, xop[3]);\n-\n-  gcc_assert (REG_X == REGNO (xop[0])\n-              && REG_Z == REGNO (xop[1]));\n+  addr_space_t as = (addr_space_t) INTVAL (op[0]);\n+  enum machine_mode loop_mode = GET_MODE (op[1]);\n+  bool sbiw_p = test_hard_reg_class (ADDW_REGS, op[1]);\n+  rtx xop[3];\n \n   if (plen)\n     *plen = 0;\n \n+  xop[0] = op[0];\n+  xop[1] = op[1];\n+  xop[2] = tmp_reg_rtx;\n+\n   /* Loop label */\n \n   avr_asm_len (\"0:\", xop, plen, 0);\n@@ -10076,16 +10063,16 @@ avr_out_movmem (rtx insn ATTRIBUTE_UNUSED, rtx *xop, int *plen)\n       \n     case ADDR_SPACE_GENERIC:\n \n-      avr_asm_len (\"ld %6,%a1+\", xop, plen, 1);\n+      avr_asm_len (\"ld %2,Z+\", xop, plen, 1);\n       break;\n       \n     case ADDR_SPACE_FLASH:\n \n       if (AVR_HAVE_LPMX)\n-        avr_asm_len (\"lpm %6,%a1+\", xop, plen, 1);\n+        avr_asm_len (\"lpm %2,%Z+\", xop, plen, 1);\n       else\n         avr_asm_len (\"lpm\" CR_TAB\n-                     \"adiw %1,1\", xop, plen, 2);\n+                     \"adiw r30,1\", xop, plen, 2);\n       break;\n       \n     case ADDR_SPACE_FLASH1:\n@@ -10095,31 +10082,31 @@ avr_out_movmem (rtx insn ATTRIBUTE_UNUSED, rtx *xop, int *plen)\n     case ADDR_SPACE_FLASH5:\n \n       if (AVR_HAVE_ELPMX)\n-        avr_asm_len (\"elpm %6,%a1+\", xop, plen, 1);\n+        avr_asm_len (\"elpm %2,Z+\", xop, plen, 1);\n       else\n         avr_asm_len (\"elpm\" CR_TAB\n-                     \"adiw %1,1\", xop, plen, 2);\n+                     \"adiw r30,1\", xop, plen, 2);\n       break;\n     }\n \n   /* Store with post-increment */\n \n-  avr_asm_len (\"st %a0+,%6\", xop, plen, 1);\n+  avr_asm_len (\"st X+,%2\", xop, plen, 1);\n \n   /* Decrement loop-counter and set Z-flag */\n \n   if (QImode == loop_mode)\n     {\n-      avr_asm_len (\"dec %3\", xop, plen, 1);\n+      avr_asm_len (\"dec %1\", xop, plen, 1);\n     }\n   else if (sbiw_p)\n     {\n-      avr_asm_len (\"sbiw %3,1\", xop, plen, 1);\n+      avr_asm_len (\"sbiw %1,1\", xop, plen, 1);\n     }\n   else\n     {\n-      avr_asm_len (\"subi %A3,1\" CR_TAB\n-                   \"sbci %B3,0\", xop, plen, 2);\n+      avr_asm_len (\"subi %A1,1\" CR_TAB\n+                   \"sbci %B1,0\", xop, plen, 2);\n     }\n \n   /* Loop until zero */"}, {"sha": "c669831b8f82f348ac51efa99deda5e0251c6a84", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8310dca7787a4f1fee92fedc041095f2fb902d5c/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8310dca7787a4f1fee92fedc041095f2fb902d5c/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=8310dca7787a4f1fee92fedc041095f2fb902d5c", "patch": "@@ -465,6 +465,9 @@\n    (set_attr \"isa\" \"lpmx,lpm\")\n    (set_attr \"cc\" \"none\")])\n \n+;; R21:Z : 24-bit source address\n+;; R22   : 1-4 byte output\n+\n ;; \"xload_qi_libgcc\"\n ;; \"xload_hi_libgcc\"\n ;; \"xload_psi_libgcc\"\n@@ -848,51 +851,52 @@\n (define_mode_attr MOVMEM_r_d [(QI \"r\")\n                               (HI \"wd\")])\n \n-;; $0, $4 : & dest (REG_X)\n-;; $1, $5 : & src  (REG_Z)\n-;; $2     : Address Space\n-;; $3, $7 : Loop register\n-;; $6     : Scratch register\n+;; $0     : Address Space\n+;; $1, $2 : Loop register\n+;; R30    : source address\n+;; R26    : destination address\n \n ;; \"movmem_qi\"\n ;; \"movmem_hi\"\n (define_insn \"movmem_<mode>\"\n-  [(set (mem:BLK (match_operand:HI 0 \"register_operand\" \"x\"))\n-        (mem:BLK (match_operand:HI 1 \"register_operand\" \"z\")))\n-   (unspec [(match_operand:QI 2 \"const_int_operand\"     \"n\")]\n+  [(set (mem:BLK (reg:HI REG_X))\n+        (mem:BLK (reg:HI REG_Z)))\n+   (unspec [(match_operand:QI 0 \"const_int_operand\" \"n\")]\n            UNSPEC_MOVMEM)\n-   (use (match_operand:QIHI 3 \"register_operand\"       \"<MOVMEM_r_d>\"))\n-   (clobber (match_operand:HI 4 \"register_operand\"     \"=0\"))\n-   (clobber (match_operand:HI 5 \"register_operand\"     \"=1\"))\n-   (clobber (match_operand:QI 6 \"register_operand\"     \"=&r\"))\n-   (clobber (match_operand:QIHI 7 \"register_operand\"   \"=3\"))]\n+   (use (match_operand:QIHI 1 \"register_operand\" \"<MOVMEM_r_d>\"))\n+   (clobber (reg:HI REG_X))\n+   (clobber (reg:HI REG_Z))\n+   (clobber (reg:QI LPM_REGNO))\n+   (clobber (match_operand:QIHI 2 \"register_operand\" \"=1\"))]\n   \"\"\n   {\n     return avr_out_movmem (insn, operands, NULL);\n   }\n   [(set_attr \"adjust_len\" \"movmem\")\n    (set_attr \"cc\" \"clobber\")])\n \n-;; Ditto and\n-;; $3, $7 : Loop register = R24\n-;; $8, $9 : hh8 (& src)   = R23\n-;; $10    : RAMPZ_ADDR\n+\n+;; $0    : Address Space\n+;; $1    : RAMPZ RAM address\n+;; R24   : #bytes and loop register\n+;; R23:Z : 24-bit source address\n+;; R26   : 16-bit destination address\n \n ;; \"movmemx_qi\"\n ;; \"movmemx_hi\"\n (define_insn \"movmemx_<mode>\"\n-  [(set (mem:BLK (match_operand:HI 0 \"register_operand\"             \"x\"))\n-        (mem:BLK (lo_sum:PSI (match_operand:QI 8 \"register_operand\" \"r\")\n-                             (match_operand:HI 1 \"register_operand\" \"z\"))))\n-   (unspec [(match_operand:QI 2 \"const_int_operand\"                 \"n\")]\n+  [(set (mem:BLK (reg:HI REG_X))\n+        (mem:BLK (lo_sum:PSI (reg:QI 23)\n+                             (reg:HI REG_Z))))\n+   (unspec [(match_operand:QI 0 \"const_int_operand\" \"n\")]\n            UNSPEC_MOVMEM)\n-   (use (match_operand:QIHI 3 \"register_operand\"                   \"w\"))\n-   (clobber (match_operand:HI 4 \"register_operand\"                 \"=0\"))\n-   (clobber (match_operand:HI 5 \"register_operand\"                 \"=1\"))\n-   (clobber (match_operand:QI 6 \"register_operand\"                 \"=&r\"))\n-   (clobber (match_operand:HI 7 \"register_operand\"                 \"=3\"))\n-   (clobber (match_operand:QI 9 \"register_operand\"                 \"=8\"))\n-   (clobber (mem:QI (match_operand:QI 10 \"io_address_operand\"       \"n\")))]\n+   (use (reg:QIHI 24))\n+   (clobber (reg:HI REG_X))\n+   (clobber (reg:HI REG_Z))\n+   (clobber (reg:QI LPM_REGNO))\n+   (clobber (reg:HI 24))\n+   (clobber (reg:QI 23))\n+   (clobber (mem:QI (match_operand:QI 1 \"io_address_operand\" \"n\")))]\n   \"\"\n   \"%~call __movmemx_<mode>\"\n   [(set_attr \"type\" \"xcall\")"}]}