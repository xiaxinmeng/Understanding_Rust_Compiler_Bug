{"sha": "c8324fe7b12851c16c867f16ce248c95d2dbae7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzgzMjRmZTdiMTI4NTFjMTZjODY3ZjE2Y2UyNDhjOTVkMmRiYWU3ZA==", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2019-09-18T08:33:02Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-09-18T08:33:02Z"}, "message": "[Ada] Implement AI12-0086's rules for discriminants in aggregates\n\nIn Ada2012, a discriminant value that governs an active variant part in\nan aggregate had to be static. AI12-0086 relaxes this restriction - if\nthe subtype of the discriminant value is a static subtype all of whose\nvalues select the same variant, then that is good enough.\n\n2019-09-18  Steve Baird  <baird@adacore.com>\n\ngcc/ada/\n\n\t* sem_util.ads (Interval_Lists): A new visible package. This\n\tpackage is visible because it is also intended for eventual use\n\tin Sem_Eval.Subtypes_Statically_Compatible when that function is\n\tsomeday upgraded to handle static predicates correctly.  This\n\tnew package doesn't really need to be visible for now, but it\n\tstill seems like a good idea.\n\t* sem_util.adb (Gather_Components): Implement AI12-0086 via the\n\tfollowing strategy. The existing code knows how to take a static\n\tdiscriminant value and identify the corresponding variant; in\n\tthe newly-permitted case of a non-static value of a static\n\tsubtype, we arbitrarily select a value of the subtype and find\n\tthe corresponding variant using the existing code. Subsequently,\n\twe check that every other value of the discriminant's subtype\n\tcorresponds to the same variant; this is done using the newly\n\tintroduced Interval_Lists package.\n\t(Interval_Lists): Provide a body for the new package.\n\ngcc/testsuite/\n\n\t* gnat.dg/ai12_0086_example.adb: New testcase.\n\nFrom-SVN: r275857", "tree": {"sha": "437e451f15dcf936fa47c5012fc19fecec221f33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/437e451f15dcf936fa47c5012fc19fecec221f33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8324fe7b12851c16c867f16ce248c95d2dbae7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8324fe7b12851c16c867f16ce248c95d2dbae7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8324fe7b12851c16c867f16ce248c95d2dbae7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8324fe7b12851c16c867f16ce248c95d2dbae7d/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6bc08721d027d10a2d9ea98c753a8bf0b4493e91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bc08721d027d10a2d9ea98c753a8bf0b4493e91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bc08721d027d10a2d9ea98c753a8bf0b4493e91"}], "stats": {"total": 592, "additions": 571, "deletions": 21}, "files": [{"sha": "452243a9589fffe79ddc3045b738b2e8ae50efca", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8324fe7b12851c16c867f16ce248c95d2dbae7d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8324fe7b12851c16c867f16ce248c95d2dbae7d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c8324fe7b12851c16c867f16ce248c95d2dbae7d", "patch": "@@ -1,3 +1,22 @@\n+2019-09-18  Steve Baird  <baird@adacore.com>\n+\n+\t* sem_util.ads (Interval_Lists): A new visible package. This\n+\tpackage is visible because it is also intended for eventual use\n+\tin Sem_Eval.Subtypes_Statically_Compatible when that function is\n+\tsomeday upgraded to handle static predicates correctly.  This\n+\tnew package doesn't really need to be visible for now, but it\n+\tstill seems like a good idea.\n+\t* sem_util.adb (Gather_Components): Implement AI12-0086 via the\n+\tfollowing strategy. The existing code knows how to take a static\n+\tdiscriminant value and identify the corresponding variant; in\n+\tthe newly-permitted case of a non-static value of a static\n+\tsubtype, we arbitrarily select a value of the subtype and find\n+\tthe corresponding variant using the existing code. Subsequently,\n+\twe check that every other value of the discriminant's subtype\n+\tcorresponds to the same variant; this is done using the newly\n+\tintroduced Interval_Lists package.\n+\t(Interval_Lists): Provide a body for the new package.\n+\n 2019-09-18  Javier Miranda  <miranda@adacore.com>\n \n \t* exp_ch4.adb (Expand_N_Op_Eq): The frontend assumes that we can"}, {"sha": "13555a56cbe5a6488b1d3527e048b5b5bf7fe4fc", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 488, "deletions": 21, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8324fe7b12851c16c867f16ce248c95d2dbae7d/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8324fe7b12851c16c867f16ce248c95d2dbae7d/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=c8324fe7b12851c16c867f16ce248c95d2dbae7d", "patch": "@@ -68,6 +68,7 @@ with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n with Uname;    use Uname;\n \n+with GNAT.Heap_Sort_G;\n with GNAT.HTable; use GNAT.HTable;\n \n package body Sem_Util is\n@@ -8885,11 +8886,17 @@ package body Sem_Util is\n       Variant         : Node_Id;\n       Discrete_Choice : Node_Id;\n       Comp_Item       : Node_Id;\n+      Discrim         : Entity_Id;\n+      Discrim_Name    : Node_Id;\n \n-      Discrim       : Entity_Id;\n-      Discrim_Name  : Node_Id;\n-      Discrim_Value : Node_Id;\n+      type Discriminant_Value_Status is\n+        (Static_Expr, Static_Subtype, Bad);\n+      subtype Good_Discrim_Value_Status is Discriminant_Value_Status\n+        range Static_Expr .. Static_Subtype; -- range excludes Bad\n \n+      Discrim_Value         : Node_Id;\n+      Discrim_Value_Subtype : Node_Id;\n+      Discrim_Value_Status  : Discriminant_Value_Status := Bad;\n    begin\n       Report_Errors := False;\n \n@@ -9022,26 +9029,73 @@ package body Sem_Util is\n       end loop Find_Constraint;\n \n       Discrim_Value := Expression (Assoc);\n+      if Is_OK_Static_Expression (Discrim_Value) then\n+         Discrim_Value_Status := Static_Expr;\n+      else\n+         if Ada_Version >= Ada_2020 then\n+            if Original_Node (Discrim_Value) /= Discrim_Value\n+               and then Nkind (Discrim_Value) = N_Type_Conversion\n+               and then Etype (Original_Node (Discrim_Value))\n+                      = Etype (Expression (Discrim_Value))\n+            then\n+               Discrim_Value_Subtype := Etype (Original_Node (Discrim_Value));\n+               --  An unhelpful (for this code) type conversion may be\n+               --  introduced in some cases; deal with it.\n+            else\n+               Discrim_Value_Subtype := Etype (Discrim_Value);\n+            end if;\n \n-      if not Is_OK_Static_Expression (Discrim_Value) then\n+            if Is_OK_Static_Subtype (Discrim_Value_Subtype) and then\n+               not Is_Null_Range (Type_Low_Bound (Discrim_Value_Subtype),\n+                                  Type_High_Bound (Discrim_Value_Subtype))\n+            then\n+               --  Is_Null_Range test doesn't account for predicates, as in\n+               --    subtype Null_By_Predicate is Natural\n+               --      with Static_Predicate => Null_By_Predicate < 0;\n+               --  so test for that null case separately.\n+\n+               if (not Has_Static_Predicate (Discrim_Value_Subtype))\n+                 or else Present (First (Static_Discrete_Predicate\n+                                           (Discrim_Value_Subtype)))\n+               then\n+                  Discrim_Value_Status := Static_Subtype;\n+               end if;\n+            end if;\n+         end if;\n \n-         --  If the variant part is governed by a discriminant of the type\n-         --  this is an error. If the variant part and the discriminant are\n-         --  inherited from an ancestor this is legal (AI05-120) unless the\n-         --  components are being gathered for an aggregate, in which case\n-         --  the caller must check Report_Errors.\n+         if Discrim_Value_Status = Bad then\n \n-         if Scope (Original_Record_Component\n-                     ((Entity (First (Choices (Assoc)))))) = Typ\n-         then\n-            Error_Msg_FE\n-              (\"value for discriminant & must be static!\",\n-               Discrim_Value, Discrim);\n-            Why_Not_Static (Discrim_Value);\n-         end if;\n+            --  If the variant part is governed by a discriminant of the type\n+            --  this is an error. If the variant part and the discriminant are\n+            --  inherited from an ancestor this is legal (AI05-220) unless the\n+            --  components are being gathered for an aggregate, in which case\n+            --  the caller must check Report_Errors.\n+            --\n+            --  In Ada2020 the above rules are relaxed. A non-static governing\n+            --  discriminant is ok as long as it has a static subtype and\n+            --  every value of that subtype (and there must be at least one)\n+            --  selects the same variant.\n \n-         Report_Errors := True;\n-         return;\n+            if Scope (Original_Record_Component\n+                        ((Entity (First (Choices (Assoc)))))) = Typ\n+            then\n+               if Ada_Version >= Ada_2020 then\n+                  Error_Msg_FE\n+                    (\"value for discriminant & must be static or \" &\n+                     \"discriminant's nominal subtype must be static \" &\n+                     \"and non-null!\",\n+                     Discrim_Value, Discrim);\n+               else\n+                  Error_Msg_FE\n+                    (\"value for discriminant & must be static!\",\n+                     Discrim_Value, Discrim);\n+               end if;\n+               Why_Not_Static (Discrim_Value);\n+            end if;\n+\n+            Report_Errors := True;\n+            return;\n+         end if;\n       end if;\n \n       Search_For_Discriminant_Value : declare\n@@ -9050,9 +9104,36 @@ package body Sem_Util is\n \n          UI_High          : Uint;\n          UI_Low           : Uint;\n-         UI_Discrim_Value : constant Uint := Expr_Value (Discrim_Value);\n+         UI_Discrim_Value : Uint;\n \n       begin\n+         case Good_Discrim_Value_Status'(Discrim_Value_Status) is\n+            when Static_Expr =>\n+               UI_Discrim_Value := Expr_Value (Discrim_Value);\n+            when Static_Subtype =>\n+               --  Arbitrarily pick one value of the subtype and look\n+               --  for the variant associated with that value; we will\n+               --  check later that the same variant is associated with\n+               --  all of the other values of the subtype.\n+               if Has_Static_Predicate (Discrim_Value_Subtype) then\n+                  declare\n+                     Range_Or_Expr : constant Node_Id :=\n+                       First (Static_Discrete_Predicate\n+                                (Discrim_Value_Subtype));\n+                  begin\n+                     if Nkind (Range_Or_Expr) = N_Range then\n+                        UI_Discrim_Value :=\n+                          Expr_Value (Low_Bound (Range_Or_Expr));\n+                     else\n+                        UI_Discrim_Value := Expr_Value (Range_Or_Expr);\n+                     end if;\n+                  end;\n+               else\n+                  UI_Discrim_Value\n+                    := Expr_Value (Type_Low_Bound (Discrim_Value_Subtype));\n+               end if;\n+         end case;\n+\n          Find_Discrete_Value : while Present (Variant) loop\n \n             --  If a choice is a subtype with a static predicate, it must\n@@ -9085,7 +9166,7 @@ package body Sem_Util is\n       --  The case statement must include a variant that corresponds to the\n       --  value of the discriminant, unless the discriminant type has a\n       --  static predicate. In that case the absence of an others_choice that\n-      --  would cover this value becomes a run-time error (3.8,1 (21.1/2)).\n+      --  would cover this value becomes a run-time error (3.8.1 (21.1/2)).\n \n       if No (Variant)\n         and then not Has_Static_Predicate (Etype (Discrim_Name))\n@@ -9101,6 +9182,31 @@ package body Sem_Util is\n       --  the same record type.\n \n       if Present (Variant) then\n+         if Discrim_Value_Status = Static_Subtype then\n+            declare\n+               Discrim_Value_Subtype_Intervals\n+                 : constant Interval_Lists.Discrete_Interval_List\n+                 := Interval_Lists.Type_Intervals (Discrim_Value_Subtype);\n+\n+               Variant_Intervals\n+                 : constant Interval_Lists.Discrete_Interval_List\n+                 := Interval_Lists.Choice_List_Intervals\n+                     (Discrete_Choices => Discrete_Choices (Variant));\n+            begin\n+               if not Interval_Lists.Is_Subset\n+                        (Subset => Discrim_Value_Subtype_Intervals,\n+                         Of_Set => Variant_Intervals)\n+               then\n+                  Error_Msg_NE\n+                    (\"no single variant is associated with all values of \" &\n+                     \"the subtype of discriminant value &\",\n+                     Discrim_Value, Discrim);\n+                  Report_Errors := True;\n+                  return;\n+               end if;\n+            end;\n+         end if;\n+\n          Gather_Components\n            (Typ, Component_List (Variant), Governed_By, Into, Report_Errors);\n       end if;\n@@ -27117,6 +27223,367 @@ package body Sem_Util is\n       end if;\n    end Yields_Universal_Type;\n \n+   package body Interval_Lists is\n+\n+      function In_Interval\n+        (Value : Uint; Interval : Discrete_Interval) return Boolean;\n+      --  Does the given value lie within the given interval?\n+\n+      -----------------\n+      -- In_Interval --\n+      -----------------\n+      function In_Interval\n+        (Value : Uint; Interval : Discrete_Interval) return Boolean is\n+      begin\n+         return Value >= Interval.Low and then Value <= Interval.High;\n+      end In_Interval;\n+\n+      procedure Check_Consistency (Intervals : Discrete_Interval_List);\n+      --  Check that list is sorted, lacks null intervals, and has gaps\n+      --  between intervals.\n+\n+      ------------------------\n+      --  Check_Consistency --\n+      ------------------------\n+      procedure Check_Consistency (Intervals : Discrete_Interval_List) is\n+      begin\n+         if Serious_Errors_Detected > 0 then\n+            return;\n+         end if;\n+\n+         --  low bound is 1 and high bound equals length\n+         pragma Assert (Intervals'First = 1 and Intervals'Last >= 0);\n+         for Idx in Intervals'Range loop\n+            --  each interval is non-null\n+            pragma Assert (Intervals (Idx).Low <= Intervals (Idx).High);\n+            if Idx /= Intervals'First then\n+               --  intervals are sorted with non-empty gaps between them\n+               pragma Assert\n+                 (Intervals (Idx - 1).High < (Intervals (Idx).Low - 1));\n+               null;\n+            end if;\n+         end loop;\n+      end Check_Consistency;\n+\n+      function Chosen_Interval (Choice : Node_Id) return Discrete_Interval;\n+      --  Given an element of a Discrete_Choices list, a\n+      --  Static_Discrete_Predicate list, or an Others_Discrete_Choices\n+      --  list (but not an N_Others_Choice node) return the corresponding\n+      --  interval. If an element that does not represent a single\n+      --  contiguous interval due to a static predicate (or which\n+      --  represents a single contiguous interval whose bounds depend on\n+      --  a static predicate) is encountered, then that is an error on the\n+      --  part of whoever built the list in question.\n+\n+      ---------------------\n+      -- Chosen_Interval --\n+      ---------------------\n+      function Chosen_Interval (Choice : Node_Id) return Discrete_Interval is\n+      begin\n+         case Nkind (Choice) is\n+            when N_Range =>\n+               return (Low  => Expr_Value (Low_Bound (Choice)),\n+                       High => Expr_Value (High_Bound (Choice)));\n+\n+            when N_Subtype_Indication =>\n+               declare\n+                  Range_Exp : constant Node_Id\n+                    := Range_Expression (Constraint (Choice));\n+               begin\n+                  return (Low  => Expr_Value (Low_Bound (Range_Exp)),\n+                          High => Expr_Value (High_Bound (Range_Exp)));\n+               end;\n+\n+            when N_Others_Choice =>\n+               raise Program_Error;\n+\n+            when others =>\n+               if Is_Entity_Name (Choice) and then Is_Type (Entity (Choice))\n+               then\n+                  return\n+                    (Low  => Expr_Value (Type_Low_Bound (Entity (Choice))),\n+                     High => Expr_Value (Type_High_Bound (Entity (Choice))));\n+               else\n+                  --  an expression\n+                  return (Low | High => Expr_Value (Choice));\n+               end if;\n+         end case;\n+      end Chosen_Interval;\n+\n+      --------------------\n+      -- Type_Intervals --\n+      --------------------\n+      function Type_Intervals\n+        (Typ : Entity_Id) return Discrete_Interval_List\n+      is\n+      begin\n+         if Has_Static_Predicate (Typ) then\n+            declare\n+               --  No sorting or merging needed\n+               SDP_List : constant List_Id := Static_Discrete_Predicate (Typ);\n+               Range_Or_Expr : Node_Id := First (SDP_List);\n+               Result :\n+                 Discrete_Interval_List (1 .. List_Length (SDP_List));\n+            begin\n+               for Idx in Result'Range loop\n+                  Result (Idx) := Chosen_Interval (Range_Or_Expr);\n+                  Range_Or_Expr := Next (Range_Or_Expr);\n+               end loop;\n+               pragma Assert (not Present (Range_Or_Expr));\n+               Check_Consistency (Result);\n+               return Result;\n+            end;\n+         else\n+            declare\n+               Low  : constant Uint := Expr_Value (Type_Low_Bound (Typ));\n+               High : constant Uint := Expr_Value (Type_High_Bound (Typ));\n+            begin\n+               if Low > High then\n+                  declare\n+                     Null_Array : Discrete_Interval_List (1 .. 0);\n+                  begin\n+                     return Null_Array;\n+                  end;\n+               else\n+                  return (1 => (Low => Low, High => High));\n+               end if;\n+            end;\n+         end if;\n+      end Type_Intervals;\n+\n+      procedure Normalize_Interval_List\n+         (List : in out Discrete_Interval_List; Last : out Nat);\n+      --  Perform sorting and merging as required by Check_Consistency.\n+\n+      -----------------------------\n+      -- Normalize_Interval_List --\n+      -----------------------------\n+      procedure Normalize_Interval_List\n+        (List : in out Discrete_Interval_List; Last : out Nat) is\n+\n+         procedure Move_Interval (From, To : Natural);\n+         --  Copy interval from one location to another\n+\n+         function Lt_Interval (Idx1, Idx2 : Natural) return Boolean;\n+         --  Compare two list elements\n+\n+         Temp_0 : Discrete_Interval := (others => Uint_0);\n+         --  cope with Heap_Sort_G idiosyncrasies.\n+\n+         function Read_Interval (From : Natural) return Discrete_Interval;\n+         --  Normal array indexing unless From = 0\n+\n+         -------------------\n+         -- Read_Interval --\n+         -------------------\n+         function Read_Interval (From : Natural) return Discrete_Interval is\n+         begin\n+            if From = 0 then\n+               return Temp_0;\n+            else\n+               return List (Pos (From));\n+            end if;\n+         end Read_Interval;\n+\n+         -------------------\n+         -- Move_Interval --\n+         -------------------\n+         procedure Move_Interval (From, To : Natural) is\n+            Rhs : constant Discrete_Interval := Read_Interval (From);\n+         begin\n+            if To = 0 then\n+               Temp_0 := Rhs;\n+            else\n+               List (Pos (To)) := Rhs;\n+            end if;\n+         end Move_Interval;\n+\n+         -----------------\n+         -- Lt_Interval --\n+         -----------------\n+         function Lt_Interval (Idx1, Idx2 : Natural) return Boolean is\n+            Elem1  : constant Discrete_Interval := Read_Interval (Idx1);\n+            Elem2  : constant Discrete_Interval := Read_Interval (Idx2);\n+            Null_1 : constant Boolean := Elem1.Low > Elem1.High;\n+            Null_2 : constant Boolean := Elem2.Low > Elem2.High;\n+         begin\n+            if Null_1 /= Null_2 then\n+               --  So that sorting moves null intervals to high end\n+               return Null_2;\n+            elsif Elem1.Low /= Elem2.Low then\n+               return Elem1.Low < Elem2.Low;\n+            else\n+               return Elem1.High < Elem2.High;\n+            end if;\n+         end Lt_Interval;\n+\n+         package Interval_Sorting is\n+           new Gnat.Heap_Sort_G (Move_Interval, Lt_Interval);\n+\n+         function Is_Null (Idx : Pos) return Boolean;\n+         --  True iff List (Idx) defines a null range\n+\n+         function Is_Null (Idx : Pos) return Boolean is\n+         begin\n+            return List (Idx).Low > List (Idx).High;\n+         end Is_Null;\n+\n+         procedure Merge_Intervals (Null_Interval_Count : out Nat);\n+         --  Merge contiguous ranges by replacing one with merged range\n+         --  and the other with a null value. Return a count of the\n+         --  null intervals, both preexisting and those introduced by\n+         --  merging.\n+\n+         ---------------------\n+         -- Merge_Intervals --\n+         ---------------------\n+         procedure Merge_Intervals (Null_Interval_Count : out Nat) is\n+            Not_Null : Pos range List'Range;\n+            --  Index of the most recently examined non-null interval\n+\n+            Null_Interval : constant Discrete_Interval\n+              := (Low => Uint_1, High => Uint_0); -- any null range ok here\n+         begin\n+            if List'Length = 0 or else Is_Null (List'First) then\n+               Null_Interval_Count := List'Length;\n+               --  no non-null elements, so no merge candidates\n+               return;\n+            end if;\n+\n+            Null_Interval_Count := 0;\n+            Not_Null := List'First;\n+            for Idx in List'First + 1 .. List'Last loop\n+               if Is_Null (Idx) then\n+                  --  all remaining elements are null\n+                  Null_Interval_Count :=\n+                    Null_Interval_Count + List (Idx .. List'Last)'Length;\n+                  return;\n+               elsif List (Idx).Low = List (Not_Null).High + 1 then\n+                  --  Merge the two intervals into one; discard the other\n+                  List (Not_Null).High := List (Idx).High;\n+                  List (Idx) := Null_Interval;\n+                  Null_Interval_Count := Null_Interval_Count + 1;\n+               else\n+                  pragma Assert (List (Idx).Low > List (Not_Null).High);\n+                  Not_Null := Idx;\n+               end if;\n+            end loop;\n+         end Merge_Intervals;\n+      begin\n+         Interval_Sorting.Sort (Natural (List'Last));\n+         declare\n+            Null_Interval_Count : Nat;\n+         begin\n+            Merge_Intervals (Null_Interval_Count);\n+            Last := List'Last - Null_Interval_Count;\n+            if Null_Interval_Count /= 0 then\n+               --  Move null intervals introduced during merging to high end\n+               Interval_Sorting.Sort (Natural (List'Last));\n+            end if;\n+         end;\n+      end Normalize_Interval_List;\n+\n+      ---------------------------\n+      -- Choice_List_Intervals --\n+      ---------------------------\n+      function Choice_List_Intervals\n+        (Discrete_Choices : List_Id) return Discrete_Interval_List\n+      is\n+         function Unmerged_Choice_Count return Nat;\n+         --  The number of intervals before adjacent intervals are merged.\n+\n+         ---------------------------\n+         -- Unmerged_Choice_Count --\n+         ---------------------------\n+         function Unmerged_Choice_Count return Nat is\n+            Choice : Node_Id := First (Discrete_Choices);\n+            Count  : Nat := 0;\n+         begin\n+            while Present (Choice) loop\n+               --  Non-contiguous choices involving static predicates\n+               --  have already been normalized away.\n+\n+               if Nkind (Choice) = N_Others_Choice then\n+                  Count :=\n+                    Count + List_Length (Others_Discrete_Choices (Choice));\n+               else\n+                  Count := Count + 1;  -- an ordinary expression or range\n+               end if;\n+\n+               Choice := Next (Choice);\n+            end loop;\n+            return Count;\n+         end Unmerged_Choice_Count;\n+\n+         Choice : Node_Id := First (Discrete_Choices);\n+         Result : Discrete_Interval_List (1 .. Unmerged_Choice_Count);\n+         Count  : Nat := 0;\n+      begin\n+         while Present (Choice) loop\n+            if Nkind (Choice) = N_Others_Choice then\n+               declare\n+                  Others_Choice : Node_Id\n+                    := First (Others_Discrete_Choices (Choice));\n+               begin\n+                  while Present (Others_Choice) loop\n+                     Count := Count + 1;\n+                     Result (Count) := Chosen_Interval (Others_Choice);\n+                     Others_Choice := Next (Others_Choice);\n+                  end loop;\n+               end;\n+            else\n+               Count := Count + 1;\n+               Result (Count) := Chosen_Interval (Choice);\n+            end if;\n+            Choice := Next (Choice);\n+         end loop;\n+         pragma Assert (Count = Result'Last);\n+         Normalize_Interval_List (Result, Count);\n+         Check_Consistency (Result (1 .. Count));\n+         return Result (1 .. Count);\n+      end Choice_List_Intervals;\n+\n+      ---------------\n+      -- Is_Subset --\n+      ---------------\n+      function Is_Subset\n+        (Subset, Of_Set : Discrete_Interval_List) return Boolean\n+      is\n+         --  Returns True iff for each interval of Subset we can find\n+         --  a single interval of Of_Set which contains the Subset interval.\n+      begin\n+         if Of_Set'Length = 0 then\n+            return Subset'Length = 0;\n+         end if;\n+\n+         declare\n+            Set_Index : Pos range Of_Set'Range := Of_Set'First;\n+         begin\n+            for Ss_Idx in Subset'Range loop\n+               while not In_Interval\n+                 (Value    => Subset (Ss_Idx).Low,\n+                  Interval => Of_Set (Set_Index))\n+               loop\n+                  if Set_Index = Of_Set'Last then\n+                     return False;\n+                  end if;\n+                  Set_Index := Set_Index + 1;\n+               end loop;\n+\n+               if not In_Interval\n+                 (Value    => Subset (Ss_Idx).High,\n+                  Interval => Of_Set (Set_Index))\n+               then\n+                  return False;\n+               end if;\n+            end loop;\n+         end;\n+\n+         return True;\n+      end Is_Subset;\n+\n+   end Interval_Lists;\n+\n begin\n    Erroutc.Subprogram_Name_Ptr := Subprogram_Name'Access;\n end Sem_Util;"}, {"sha": "c77f4414a74ad409cc1d206db67c828291d1d0a3", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8324fe7b12851c16c867f16ce248c95d2dbae7d/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8324fe7b12851c16c867f16ce248c95d2dbae7d/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=c8324fe7b12851c16c867f16ce248c95d2dbae7d", "patch": "@@ -2965,4 +2965,40 @@ package Sem_Util is\n    function Yields_Universal_Type (N : Node_Id) return Boolean;\n    --  Determine whether unanalyzed node N yields a universal type\n \n+   package Interval_Lists is\n+      type Discrete_Interval is\n+         record\n+            Low, High : Uint;\n+         end record;\n+\n+      type Discrete_Interval_List is\n+        array (Pos range <>) of Discrete_Interval;\n+      --  A sorted (in ascending order) list of non-empty pairwise-disjoint\n+      --  intervals, always with a gap of at least one value between\n+      --  successive intervals (i.e., mergeable intervals are merged).\n+      --  Low bound is one; high bound is nonnegative.\n+\n+      function Type_Intervals (Typ : Entity_Id) return Discrete_Interval_List;\n+      --  Given a static discrete type or subtype, returns the (unique)\n+      --  interval list representing the values of the type/subtype.\n+      --  If no static predicates are involved, the length of the result\n+      --  will be at most one.\n+\n+      function Choice_List_Intervals (Discrete_Choices : List_Id)\n+                                     return Discrete_Interval_List;\n+      --  Given a discrete choice list, returns the (unique) interval\n+      --  list representing the chosen values..\n+\n+      function Is_Subset (Subset, Of_Set : Discrete_Interval_List)\n+        return Boolean;\n+      --  Returns True iff every value belonging to some interval of\n+      --  Subset also belongs to some interval of Of_Set.\n+\n+      --  TBD: When we get around to implementing \"is statically compatible\"\n+      --  correctly for real types with static predicates, we may need\n+      --  an analogous Real_Interval_List type. Most of the language\n+      --  rules that reference \"is statically compatible\" pertain to\n+      --  discriminants and therefore do require support for real types;\n+      --  the exception is 12.5.1(8).\n+   end Interval_Lists;\n end Sem_Util;"}, {"sha": "fd0efb176e6c9261df94adc96848c144891cd044", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8324fe7b12851c16c867f16ce248c95d2dbae7d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8324fe7b12851c16c867f16ce248c95d2dbae7d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c8324fe7b12851c16c867f16ce248c95d2dbae7d", "patch": "@@ -1,3 +1,7 @@\n+2019-09-18  Steve Baird  <baird@adacore.com>\n+\n+\t* gnat.dg/ai12_0086_example.adb: New testcase.\n+\n 2019-09-18  Nicolas Roche  <roche@adacore.com>\n \n \t* gnat.dg/float_value2.adb: New testcase."}, {"sha": "4ea6f6a88a5a06b42985824fd1ee9f677fc6ffc6", "filename": "gcc/testsuite/gnat.dg/ai12_0086_example.adb", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8324fe7b12851c16c867f16ce248c95d2dbae7d/gcc%2Ftestsuite%2Fgnat.dg%2Fai12_0086_example.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8324fe7b12851c16c867f16ce248c95d2dbae7d/gcc%2Ftestsuite%2Fgnat.dg%2Fai12_0086_example.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fai12_0086_example.adb?ref=c8324fe7b12851c16c867f16ce248c95d2dbae7d", "patch": "@@ -0,0 +1,24 @@\n+--  { dg-do compile }\n+--  { dg-options \"-gnatX\" }\n+\n+procedure AI12_0086_Example is\n+    type Enum is (Aa, Bb, Cc, Dd, Ee, Ff, Gg, Hh, Ii, Jj, Kk, Ll, MM,\n+                  Nn, Oo, Pp, Qq, Rr, Ss, Tt, Uu, Vv, Ww, Xx, Yy, Zz);\n+    subtype S is Enum range Dd .. Hh;\n+\n+    type Rec (D : Enum) is record\n+      case D is\n+        when S => Foo, Bar : Integer;\n+        when others => null;\n+      end case;\n+    end record;\n+\n+    function Make (D : S) return Rec is\n+    begin\n+      return (D => D, Foo => 123, Bar => 456); -- legal\n+    end;\n+begin\n+    if Make (Ff).Bar /= 456 then\n+       raise Program_Error;\n+    end if;\n+end AI12_0086_Example;\n\\ No newline at end of file"}]}