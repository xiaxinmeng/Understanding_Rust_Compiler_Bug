{"sha": "37415eec77438bba2fc61df3e9a396c1e2cbaca8", "node_id": "C_kwDOANBUbNoAKDM3NDE1ZWVjNzc0MzhiYmEyZmM2MWRmM2U5YTM5NmMxZTJjYmFjYTg", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-02-17T15:26:35Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-02-17T16:41:15Z"}, "message": "Semicolon based macro invocation\n\nThis allows for macro invocation at the toplevel or as statements. This\npatched required us to propogate the delimited token tree fix to include\nthe delimiter tokens. The rest of the fix was straight forward to call\nthe apropriate visitors in names resolution and hir lowering.\n\nSome thought will be needed to handle hir lowering for repeating items.", "tree": {"sha": "d8ed1ea0d957afd906556ae89e8622f79c4690f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8ed1ea0d957afd906556ae89e8622f79c4690f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37415eec77438bba2fc61df3e9a396c1e2cbaca8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37415eec77438bba2fc61df3e9a396c1e2cbaca8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37415eec77438bba2fc61df3e9a396c1e2cbaca8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37415eec77438bba2fc61df3e9a396c1e2cbaca8/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c70d7ec770d226bf9ad59b4f03897f6fb10df15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c70d7ec770d226bf9ad59b4f03897f6fb10df15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c70d7ec770d226bf9ad59b4f03897f6fb10df15"}], "stats": {"total": 586, "additions": 430, "deletions": 156}, "files": [{"sha": "e72937e5d7098267aba51576e6332b656d102cb5", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 169, "deletions": 1, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=37415eec77438bba2fc61df3e9a396c1e2cbaca8", "patch": "@@ -1475,6 +1475,160 @@ struct MacroInvocData\n   }\n };\n \n+class SingleASTNode\n+{\n+public:\n+  enum NodeType\n+  {\n+    EXPRESSION,\n+    ITEM,\n+    STMT,\n+  };\n+\n+  SingleASTNode (std::unique_ptr<Expr> expr)\n+    : type (EXPRESSION), expr (std::move (expr)), item (nullptr), stmt (nullptr)\n+  {}\n+\n+  SingleASTNode (std::unique_ptr<Item> item)\n+    : type (ITEM), expr (nullptr), item (std::move (item)), stmt (nullptr)\n+  {}\n+\n+  SingleASTNode (std::unique_ptr<Stmt> stmt)\n+    : type (STMT), expr (nullptr), item (nullptr), stmt (std::move (stmt))\n+  {}\n+\n+  SingleASTNode (SingleASTNode const &other)\n+  {\n+    type = other.type;\n+    switch (type)\n+      {\n+      case EXPRESSION:\n+\texpr = other.expr->clone_expr ();\n+\tbreak;\n+\n+      case ITEM:\n+\titem = other.item->clone_item ();\n+\tbreak;\n+\n+      case STMT:\n+\tstmt = other.stmt->clone_stmt ();\n+\tbreak;\n+      }\n+  }\n+\n+  SingleASTNode operator= (SingleASTNode const &other)\n+  {\n+    type = other.type;\n+    switch (type)\n+      {\n+      case EXPRESSION:\n+\texpr = other.expr->clone_expr ();\n+\tbreak;\n+\n+      case ITEM:\n+\titem = other.item->clone_item ();\n+\tbreak;\n+\n+      case STMT:\n+\tstmt = other.stmt->clone_stmt ();\n+\tbreak;\n+      }\n+    return *this;\n+  }\n+\n+  SingleASTNode (SingleASTNode &&other) = default;\n+  SingleASTNode &operator= (SingleASTNode &&other) = default;\n+\n+  std::unique_ptr<Expr> &get_expr ()\n+  {\n+    rust_assert (type == EXPRESSION);\n+    return expr;\n+  }\n+\n+  std::unique_ptr<Item> &get_item ()\n+  {\n+    rust_assert (type == ITEM);\n+    return item;\n+  }\n+\n+  std::unique_ptr<Stmt> &get_stmt ()\n+  {\n+    rust_assert (type == STMT);\n+    return stmt;\n+  }\n+\n+  void accept_vis (ASTVisitor &vis)\n+  {\n+    switch (type)\n+      {\n+      case EXPRESSION:\n+\texpr->accept_vis (vis);\n+\tbreak;\n+\n+      case ITEM:\n+\titem->accept_vis (vis);\n+\tbreak;\n+\n+      case STMT:\n+\tstmt->accept_vis (vis);\n+\tbreak;\n+      }\n+  }\n+\n+private:\n+  NodeType type;\n+\n+  // FIXME make this a union\n+  std::unique_ptr<Expr> expr;\n+  std::unique_ptr<Item> item;\n+  std::unique_ptr<Stmt> stmt;\n+};\n+\n+/* Basically, a \"fragment\" that can be incorporated into the AST, created as\n+ * a result of macro expansion. Really annoying to work with due to the fact\n+ * that macros can really expand to anything. As such, horrible representation\n+ * at the moment. */\n+class ASTFragment\n+{\n+private:\n+  /* basic idea: essentially, a vector of tagged unions of different AST node\n+   * types. Now, this could actually be stored without a tagged union if the\n+   * different AST node types had a unified parent, but that would create\n+   * issues with the diamond problem or significant performance penalties. So\n+   * a tagged union had to be used instead. A vector is used to represent the\n+   * ability for a macro to expand to two statements, for instance. */\n+\n+  std::vector<SingleASTNode> nodes;\n+\n+public:\n+  ASTFragment (std::vector<SingleASTNode> nodes) : nodes (std::move (nodes)) {}\n+\n+  ASTFragment (ASTFragment const &other)\n+  {\n+    nodes.clear ();\n+    nodes.reserve (other.nodes.size ());\n+    for (auto &n : other.nodes)\n+      {\n+\tnodes.push_back (n);\n+      }\n+  }\n+\n+  ASTFragment &operator= (ASTFragment const &other)\n+  {\n+    nodes.clear ();\n+    nodes.reserve (other.nodes.size ());\n+    for (auto &n : other.nodes)\n+      {\n+\tnodes.push_back (n);\n+      }\n+    return *this;\n+  }\n+\n+  static ASTFragment create_empty () { return ASTFragment ({}); }\n+\n+  std::vector<SingleASTNode> &get_nodes () { return nodes; }\n+};\n+\n /* A macro invocation item (or statement) AST node (i.e. semi-coloned macro\n  * invocation) */\n class MacroInvocationSemi : public MacroItem,\n@@ -1486,14 +1640,20 @@ class MacroInvocationSemi : public MacroItem,\n   std::vector<Attribute> outer_attrs;\n   MacroInvocData invoc_data;\n   Location locus;\n+  NodeId node_id;\n+\n+  // this is the expanded macro\n+  ASTFragment fragment;\n \n public:\n   std::string as_string () const override;\n \n   MacroInvocationSemi (MacroInvocData invoc_data,\n \t\t       std::vector<Attribute> outer_attrs, Location locus)\n     : outer_attrs (std::move (outer_attrs)),\n-      invoc_data (std::move (invoc_data)), locus (locus)\n+      invoc_data (std::move (invoc_data)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ()),\n+      fragment (ASTFragment::create_empty ())\n   {}\n \n   void accept_vis (ASTVisitor &vis) override;\n@@ -1517,6 +1677,14 @@ class MacroInvocationSemi : public MacroItem,\n \n   Location get_locus () const override final { return locus; }\n \n+  MacroInvocData &get_invoc_data () { return invoc_data; }\n+\n+  ASTFragment &get_fragment () { return fragment; }\n+\n+  void set_fragment (ASTFragment &&f) { fragment = std::move (f); }\n+\n+  NodeId get_macro_node_id () const { return node_id; }\n+\n protected:\n   MacroInvocationSemi *clone_macro_invocation_semi_impl () const\n   {"}, {"sha": "b5370d853fca6dbea6cc4ef310fe54117509f4ee", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=37415eec77438bba2fc61df3e9a396c1e2cbaca8", "patch": "@@ -84,135 +84,6 @@ get_frag_spec_from_str (std::string str)\n     }\n }\n \n-class SingleASTNode\n-{\n-public:\n-  enum NodeType\n-  {\n-    EXPRESSION,\n-    ITEM,\n-  };\n-\n-  SingleASTNode (std::unique_ptr<Expr> expr)\n-    : type (EXPRESSION), expr (std::move (expr)), item (nullptr)\n-  {}\n-\n-  SingleASTNode (std::unique_ptr<Item> item)\n-    : type (ITEM), expr (nullptr), item (std::move (item))\n-  {}\n-\n-  SingleASTNode (SingleASTNode const &other)\n-  {\n-    type = other.type;\n-    switch (type)\n-      {\n-      case EXPRESSION:\n-\texpr = other.expr->clone_expr ();\n-\tbreak;\n-\n-      case ITEM:\n-\titem = other.item->clone_item ();\n-\tbreak;\n-      }\n-  }\n-\n-  SingleASTNode operator= (SingleASTNode const &other)\n-  {\n-    type = other.type;\n-    switch (type)\n-      {\n-      case EXPRESSION:\n-\texpr = other.expr->clone_expr ();\n-\tbreak;\n-\n-      case ITEM:\n-\titem = other.item->clone_item ();\n-\tbreak;\n-      }\n-    return *this;\n-  }\n-\n-  SingleASTNode (SingleASTNode &&other) = default;\n-  SingleASTNode &operator= (SingleASTNode &&other) = default;\n-\n-  std::unique_ptr<Expr> &get_expr ()\n-  {\n-    rust_assert (type == EXPRESSION);\n-    return expr;\n-  }\n-\n-  std::unique_ptr<Item> &get_item ()\n-  {\n-    rust_assert (type == ITEM);\n-    return item;\n-  }\n-\n-  void accept_vis (ASTVisitor &vis)\n-  {\n-    switch (type)\n-      {\n-      case EXPRESSION:\n-\texpr->accept_vis (vis);\n-\tbreak;\n-\n-      case ITEM:\n-\titem->accept_vis (vis);\n-\tbreak;\n-      }\n-  }\n-\n-private:\n-  NodeType type;\n-  std::unique_ptr<Expr> expr;\n-  std::unique_ptr<Item> item;\n-  // TODO add meta attribute\n-};\n-\n-/* Basically, a \"fragment\" that can be incorporated into the AST, created as\n- * a result of macro expansion. Really annoying to work with due to the fact\n- * that macros can really expand to anything. As such, horrible representation\n- * at the moment. */\n-class ASTFragment\n-{\n-private:\n-  /* basic idea: essentially, a vector of tagged unions of different AST node\n-   * types. Now, this could actually be stored without a tagged union if the\n-   * different AST node types had a unified parent, but that would create\n-   * issues with the diamond problem or significant performance penalties. So\n-   * a tagged union had to be used instead. A vector is used to represent the\n-   * ability for a macro to expand to two statements, for instance. */\n-\n-  std::vector<SingleASTNode> nodes;\n-\n-public:\n-  ASTFragment (std::vector<SingleASTNode> nodes) : nodes (std::move (nodes)) {}\n-\n-  ASTFragment (ASTFragment const &other)\n-  {\n-    nodes.clear ();\n-    nodes.reserve (other.nodes.size ());\n-    for (auto &n : other.nodes)\n-      {\n-\tnodes.push_back (n);\n-      }\n-  }\n-\n-  ASTFragment &operator= (ASTFragment const &other)\n-  {\n-    nodes.clear ();\n-    nodes.reserve (other.nodes.size ());\n-    for (auto &n : other.nodes)\n-      {\n-\tnodes.push_back (n);\n-      }\n-    return *this;\n-  }\n-\n-  static ASTFragment create_empty () { return ASTFragment ({}); }\n-\n-  std::vector<SingleASTNode> &get_nodes () { return nodes; }\n-};\n-\n // A macro match that has an identifier and fragment spec\n class MacroMatchFragment : public MacroMatch\n {"}, {"sha": "dcfec7ceeb793feb17fd4112a8a2b5bee63f5c49", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 108, "deletions": 19, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=37415eec77438bba2fc61df3e9a396c1e2cbaca8", "patch": "@@ -324,6 +324,13 @@ class AttrVisitor : public AST::ASTVisitor\n     // I don't think any macro token trees can be stripped in any way\n \n     // TODO: maybe have cfg! macro stripping behaviour here?\n+\n+    expander.expand_invoc_semi (macro_invoc);\n+\n+    // we need to visit the expanded fragments since it may need cfg expansion\n+    // and it may be recursive\n+    for (auto &node : macro_invoc.get_fragment ().get_nodes ())\n+      node.accept_vis (*this);\n   }\n \n   void visit (AST::PathInExpression &path) override\n@@ -1034,13 +1041,17 @@ class AttrVisitor : public AST::ASTVisitor\n \t\t     \"cannot strip expression in this position - outer \"\n \t\t     \"attributes not allowed\");\n   }\n+\n   void visit (AST::BlockExpr &expr) override\n   {\n+    expander.push_context (MacroExpander::BLOCK);\n+\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n     if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n+\texpander.pop_context ();\n \treturn;\n       }\n \n@@ -1050,6 +1061,7 @@ class AttrVisitor : public AST::ASTVisitor\n     if (expander.fails_cfg_with_expand (expr.get_inner_attrs ()))\n       {\n \texpr.mark_for_strip ();\n+\texpander.pop_context ();\n \treturn;\n       }\n \n@@ -1066,7 +1078,9 @@ class AttrVisitor : public AST::ASTVisitor\n \tif (tail_expr->is_marked_for_strip ())\n \t  expr.strip_tail_expr ();\n       }\n+    expander.pop_context ();\n   }\n+\n   void visit (AST::ClosureExprInnerTyped &expr) override\n   {\n     // initial strip test based on outer attrs\n@@ -2533,7 +2547,6 @@ class AttrVisitor : public AST::ASTVisitor\n       }\n \n     // I don't think any macro token trees can be stripped in any way\n-\n     expander.expand_invoc (macro_invoc);\n \n     // we need to visit the expanded fragments since it may need cfg expansion\n@@ -3059,7 +3072,8 @@ MacroExpander::expand_cfg_macro (AST::MacroInvocData &invoc)\n AST::ASTFragment\n MacroExpander::expand_decl_macro (Location invoc_locus,\n \t\t\t\t  AST::MacroInvocData &invoc,\n-\t\t\t\t  AST::MacroRulesDefinition &rules_def)\n+\t\t\t\t  AST::MacroRulesDefinition &rules_def,\n+\t\t\t\t  bool semicolon)\n {\n   // ensure that both invocation and rules are in a valid state\n   rust_assert (!invoc.is_marked_for_strip ());\n@@ -3126,7 +3140,8 @@ MacroExpander::expand_decl_macro (Location invoc_locus,\n       return AST::ASTFragment::create_empty ();\n     }\n \n-  return transcribe_rule (*matched_rule, invoc_token_tree, matched_fragments);\n+  return transcribe_rule (*matched_rule, invoc_token_tree, matched_fragments,\n+\t\t\t  semicolon, peek_context ());\n }\n \n void\n@@ -3176,7 +3191,42 @@ MacroExpander::expand_invoc (AST::MacroInvocation &invoc)\n   rust_assert (ok);\n \n   auto fragment\n-    = expand_decl_macro (invoc.get_locus (), invoc_data, *rules_def);\n+    = expand_decl_macro (invoc.get_locus (), invoc_data, *rules_def, false);\n+\n+  // lets attach this fragment to the invocation\n+  invoc.set_fragment (std::move (fragment));\n+}\n+\n+void\n+MacroExpander::expand_invoc_semi (AST::MacroInvocationSemi &invoc)\n+{\n+  if (depth_exceeds_recursion_limit ())\n+    {\n+      rust_error_at (invoc.get_locus (), \"reached recursion limit\");\n+      return;\n+    }\n+\n+  AST::MacroInvocData &invoc_data = invoc.get_invoc_data ();\n+\n+  // lookup the rules for this macro\n+  NodeId resolved_node = UNKNOWN_NODEID;\n+  bool found = resolver->get_macro_scope ().lookup (\n+    Resolver::CanonicalPath::new_seg (invoc.get_macro_node_id (),\n+\t\t\t\t      invoc_data.get_path ().as_string ()),\n+    &resolved_node);\n+  if (!found)\n+    {\n+      rust_error_at (invoc.get_locus (), \"unknown macro\");\n+      return;\n+    }\n+\n+  // lookup the rules\n+  AST::MacroRulesDefinition *rules_def = nullptr;\n+  bool ok = mappings->lookup_macro_def (resolved_node, &rules_def);\n+  rust_assert (ok);\n+\n+  auto fragment\n+    = expand_decl_macro (invoc.get_locus (), invoc_data, *rules_def, true);\n \n   // lets attach this fragment to the invocation\n   invoc.set_fragment (std::move (fragment));\n@@ -3301,6 +3351,8 @@ MacroExpander::expand_crate ()\n     }\n   // expand module attributes?\n \n+  push_context (ITEM);\n+\n   // expand attributes recursively and strip items if required\n   AttrVisitor attr_visitor (*this);\n   auto &items = crate.items;\n@@ -3317,6 +3369,8 @@ MacroExpander::expand_crate ()\n \t++it;\n     }\n \n+  pop_context ();\n+\n   // TODO: should recursive attribute and macro expansion be done in the same\n   // transversal? Or in separate ones like currently?\n \n@@ -3555,7 +3609,8 @@ MacroExpander::match_repetition (Parser<MacroInvocLexer> &parser,\n AST::ASTFragment\n MacroExpander::transcribe_rule (\n   AST::MacroRule &match_rule, AST::DelimTokenTree &invoc_token_tree,\n-  std::map<std::string, MatchedFragment> &matched_fragments)\n+  std::map<std::string, MatchedFragment> &matched_fragments, bool semicolon,\n+  ContextType ctx)\n {\n   // we can manipulate the token tree to substitute the dollar identifiers so\n   // that when we call parse its already substituted for us\n@@ -3568,7 +3623,7 @@ MacroExpander::transcribe_rule (\n   std::vector<std::unique_ptr<AST::Token>> substituted_tokens\n     = substitute_tokens (invoc_stream, macro_rule_tokens, matched_fragments);\n \n-  // handy for debugging\n+  // // handy for debugging\n   // for (auto &tok : substituted_tokens)\n   //   {\n   //     rust_debug (\"tok: [%s]\", tok->as_string ().c_str ());\n@@ -3579,7 +3634,6 @@ MacroExpander::transcribe_rule (\n   Parser<MacroInvocLexer> parser (std::move (lex));\n \n   // this is used so we can check that we delimit the stream correctly.\n-  std::vector<AST::SingleASTNode> nodes;\n   switch (transcribe_tree.get_delim_type ())\n     {\n     case AST::DelimType::PARENS:\n@@ -3595,26 +3649,61 @@ MacroExpander::transcribe_rule (\n       break;\n     }\n \n+  // see https://github.com/Rust-GCC/gccrs/issues/22\n+  // TL;DR:\n+  //   - Treat all macro invocations with parentheses, (), or square brackets,\n+  //   [], as expressions.\n+  //   - If the macro invocation has curly brackets, {}, it may be parsed as a\n+  //   statement depending on the context.\n+  //   - If the macro invocation has a semicolon at the end, it must be parsed\n+  //   as a statement (either via ExpressionStatement or\n+  //   MacroInvocationWithSemi)\n+\n   // parse the item\n+  std::vector<AST::SingleASTNode> nodes;\n   switch (invoc_token_tree.get_delim_type ())\n     {\n-      case AST::DelimType::PARENS: {\n-\tauto expr = parser.parse_expr ();\n-\tif (expr != nullptr && !parser.has_errors ())\n-\t  nodes.push_back (std::move (expr));\n+    case AST::DelimType::PARENS:\n+      case AST::DelimType::SQUARE: {\n+\tswitch (ctx)\n+\t  {\n+\t    case ContextType::ITEM: {\n+\t      auto item = parser.parse_item (true);\n+\t      if (item != nullptr && !parser.has_errors ())\n+\t\t{\n+\t\t  rust_debug (\"HELLO WORLD: [%s]\", item->as_string ().c_str ());\n+\t\t  nodes.push_back (std::move (item));\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t    case ContextType::BLOCK: {\n+\t      auto expr = parser.parse_expr ();\n+\t      if (expr != nullptr && !parser.has_errors ())\n+\t\tnodes.push_back (std::move (expr));\n+\t    }\n+\t    break;\n+\t  }\n       }\n       break;\n \n       case AST::DelimType::CURLY: {\n-\tauto item = parser.parse_item (false);\n-\tif (item != nullptr && !parser.has_errors ())\n-\t  nodes.push_back (std::move (item));\n-      }\n-      break;\n+\tswitch (ctx)\n+\t  {\n+\t    case ContextType::ITEM: {\n+\t      auto item = parser.parse_item (true);\n+\t      if (item != nullptr && !parser.has_errors ())\n+\t\tnodes.push_back (std::move (item));\n+\t    }\n+\t    break;\n \n-      case AST::DelimType::SQUARE: {\n-\t// FIXME\n-\tgcc_unreachable ();\n+\t    case ContextType::BLOCK: {\n+\t      auto stmt = parser.parse_stmt ();\n+\t      if (stmt != nullptr && !parser.has_errors ())\n+\t\tnodes.push_back (std::move (stmt));\n+\t    }\n+\t    break;\n+\t  }\n       }\n       break;\n     }"}, {"sha": "d8a2d5003e654ed6bfbba53284289591dc010859", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=37415eec77438bba2fc61df3e9a396c1e2cbaca8", "patch": "@@ -130,6 +130,12 @@ class SubstitutionScope\n // Object used to store shared data (between functions) for macro expansion.\n struct MacroExpander\n {\n+  enum ContextType\n+  {\n+    ITEM,\n+    BLOCK,\n+  };\n+\n   ExpansionCfg cfg;\n   unsigned int expansion_depth = 0;\n \n@@ -148,11 +154,13 @@ struct MacroExpander\n    * have similar duck-typed interface and use templates?*/\n   // should this be public or private?\n   void expand_invoc (AST::MacroInvocation &invoc);\n+  void expand_invoc_semi (AST::MacroInvocationSemi &invoc);\n \n   // Expands a single declarative macro.\n   AST::ASTFragment expand_decl_macro (Location locus,\n \t\t\t\t      AST::MacroInvocData &invoc,\n-\t\t\t\t      AST::MacroRulesDefinition &rules_def);\n+\t\t\t\t      AST::MacroRulesDefinition &rules_def,\n+\t\t\t\t      bool semicolon);\n \n   void expand_cfg_attrs (AST::AttrVec &attrs);\n   bool fails_cfg (const AST::AttrVec &attr) const;\n@@ -171,7 +179,8 @@ struct MacroExpander\n   AST::ASTFragment\n   transcribe_rule (AST::MacroRule &match_rule,\n \t\t   AST::DelimTokenTree &invoc_token_tree,\n-\t\t   std::map<std::string, MatchedFragment> &matched_fragments);\n+\t\t   std::map<std::string, MatchedFragment> &matched_fragments,\n+\t\t   bool semicolon, ContextType ctx);\n \n   bool match_fragment (Parser<MacroInvocLexer> &parser,\n \t\t       AST::MacroMatchFragment &fragment);\n@@ -189,10 +198,22 @@ struct MacroExpander\n \t\t     std::vector<std::unique_ptr<AST::Token>> &macro,\n \t\t     std::map<std::string, MatchedFragment> &fragments);\n \n+  void push_context (ContextType t) { context.push_back (t); }\n+\n+  ContextType pop_context ()\n+  {\n+    ContextType t = context.back ();\n+    context.pop_back ();\n+    return t;\n+  }\n+\n+  ContextType peek_context () { return context.back (); }\n+\n private:\n   AST::Crate &crate;\n   Session &session;\n   SubstitutionScope sub_stack;\n+  std::vector<ContextType> context;\n \n public:\n   Resolver::Resolver *resolver;"}, {"sha": "3d10b70bc17b27754f337030ccd549c90a446e2c", "filename": "gcc/rust/hir/rust-ast-lower-implitem.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h?ref=37415eec77438bba2fc61df3e9a396c1e2cbaca8", "patch": "@@ -52,6 +52,16 @@ class ASTLowerImplItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+\n+    // FIXME\n+    // this assertion might go away, maybe on failure's to expand a macro?\n+    rust_assert (!fragment.get_nodes ().empty ());\n+    fragment.get_nodes ().at (0).accept_vis (*this);\n+  }\n+\n   void visit (AST::TypeAlias &alias) override\n   {\n     std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n@@ -308,6 +318,16 @@ class ASTLowerTraitItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+\n+    // FIXME\n+    // this assertion might go away, maybe on failure's to expand a macro?\n+    rust_assert (!fragment.get_nodes ().empty ());\n+    fragment.get_nodes ().at (0).accept_vis (*this);\n+  }\n+\n   void visit (AST::TraitItemFunc &func) override\n   {\n     AST::TraitFunctionDecl &ref = func.get_trait_function_decl ();"}, {"sha": "30bd896a7976de4ee8c0837c2847e0960a0fcbd6", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=37415eec77438bba2fc61df3e9a396c1e2cbaca8", "patch": "@@ -47,6 +47,16 @@ class ASTLoweringItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+\n+    // FIXME\n+    // this assertion might go away, maybe on failure's to expand a macro?\n+    rust_assert (!fragment.get_nodes ().empty ());\n+    fragment.get_nodes ().at (0).accept_vis (*this);\n+  }\n+\n   void visit (AST::Module &module) override\n   {\n     auto crate_num = mappings->get_current_crate ();"}, {"sha": "b25246a43aa828e776be417f8d5090db44e37935", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=37415eec77438bba2fc61df3e9a396c1e2cbaca8", "patch": "@@ -45,6 +45,16 @@ class ASTLoweringStmt : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+\n+    // FIXME\n+    // this assertion might go away, maybe on failure's to expand a macro?\n+    rust_assert (!fragment.get_nodes ().empty ());\n+    fragment.get_nodes ().at (0).accept_vis (*this);\n+  }\n+\n   void visit (AST::ExprStmtWithBlock &stmt) override\n   {\n     HIR::ExprWithBlock *expr"}, {"sha": "784e6d1efd21ee5f111abbc059428e52cf2af769", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=37415eec77438bba2fc61df3e9a396c1e2cbaca8", "patch": "@@ -1571,6 +1571,9 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n \n   // parse actual token trees\n   std::vector<std::unique_ptr<AST::TokenTree>> token_trees;\n+  auto delim_open\n+    = std::unique_ptr<AST::Token> (new AST::Token (std::move (t)));\n+  token_trees.push_back (std::move (delim_open));\n \n   t = lexer.peek_token ();\n   // parse token trees until the initial delimiter token is found again\n@@ -1593,6 +1596,9 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n \n       t = lexer.peek_token ();\n     }\n+  auto delim_close\n+    = std::unique_ptr<AST::Token> (new AST::Token (std::move (t)));\n+  token_trees.push_back (std::move (delim_close));\n \n   AST::DelimTokenTree delim_tok_tree (delim_type, std::move (token_trees),\n \t\t\t\t      tok_tree_locus);\n@@ -1611,6 +1617,7 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n \t  if (!skip_token (SEMICOLON))\n \t    {\n \t      // as this is the end, allow recovery (probably) - may change\n+\n \t      return std::unique_ptr<AST::MacroInvocationSemi> (\n \t\tnew AST::MacroInvocationSemi (std::move (invoc_data),\n \t\t\t\t\t      std::move (outer_attrs),\n@@ -11761,6 +11768,9 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \n \t// parse actual token trees\n \tstd::vector<std::unique_ptr<AST::TokenTree>> token_trees;\n+\tauto delim_open\n+\t  = std::unique_ptr<AST::Token> (new AST::Token (std::move (t3)));\n+\ttoken_trees.push_back (std::move (delim_open));\n \n \tt3 = lexer.peek_token ();\n \t// parse token trees until the initial delimiter token is found again\n@@ -11785,6 +11795,10 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \t    t3 = lexer.peek_token ();\n \t  }\n \n+\tauto delim_close\n+\t  = std::unique_ptr<AST::Token> (new AST::Token (std::move (t3)));\n+\ttoken_trees.push_back (std::move (delim_close));\n+\n \t// parse end delimiters\n \tt3 = lexer.peek_token ();\n \tif (token_id_matches_delims (t3->get_id (), type))\n@@ -12076,6 +12090,9 @@ Parser<ManagedTokenSource>::parse_macro_invocation_maybe_semi (\n \n   // parse actual token trees\n   std::vector<std::unique_ptr<AST::TokenTree>> token_trees;\n+  auto delim_open\n+    = std::unique_ptr<AST::Token> (new AST::Token (std::move (t3)));\n+  token_trees.push_back (std::move (delim_open));\n \n   t3 = lexer.peek_token ();\n   // parse token trees until the initial delimiter token is found again\n@@ -12098,6 +12115,9 @@ Parser<ManagedTokenSource>::parse_macro_invocation_maybe_semi (\n \n       t3 = lexer.peek_token ();\n     }\n+  auto delim_close\n+    = std::unique_ptr<AST::Token> (new AST::Token (std::move (t3)));\n+  token_trees.push_back (std::move (delim_close));\n \n   // parse end delimiters\n   t3 = lexer.peek_token ();"}, {"sha": "bb1cbb04794692154dbb93a49bf952be6b61c448", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=37415eec77438bba2fc61df3e9a396c1e2cbaca8", "patch": "@@ -73,11 +73,8 @@ class ResolveExpr : public ResolverBase\n   void visit (AST::MacroInvocation &expr) override\n   {\n     AST::ASTFragment &fragment = expr.get_fragment ();\n-\n-    // FIXME\n-    // this assertion might go away, maybe on failure's to expand a macro?\n-    rust_assert (!fragment.get_nodes ().empty ());\n-    fragment.get_nodes ().at (0).accept_vis (*this);\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n   }\n \n   void visit (AST::TupleIndexExpr &expr) override"}, {"sha": "ce7234ca1a1ac220986207b31bf3b5a8785b3a46", "filename": "gcc/rust/resolve/rust-ast-resolve-implitem.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h?ref=37415eec77438bba2fc61df3e9a396c1e2cbaca8", "patch": "@@ -49,6 +49,13 @@ class ResolveToplevelImplItem : public ResolverBase\n     item->accept_vis (resolver);\n   }\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n+\n   void visit (AST::TypeAlias &type) override\n   {\n     auto decl\n@@ -137,6 +144,13 @@ class ResolveTopLevelTraitItems : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n+\n   void visit (AST::TraitItemFunc &function) override\n   {\n     auto decl = ResolveTraitItemFunctionToCanonicalPath::resolve (function);\n@@ -240,6 +254,13 @@ class ResolveToplevelExternItem : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n+\n   void visit (AST::ExternalFunctionItem &function) override\n   {\n     auto decl = CanonicalPath::new_seg (function.get_node_id (),"}, {"sha": "48f93e534875a828b73f408b548abc821a72293a", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=37415eec77438bba2fc61df3e9a396c1e2cbaca8", "patch": "@@ -45,6 +45,13 @@ class ResolveTraitItems : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n+\n   void visit (AST::TraitItemType &type) override\n   {\n     auto decl = ResolveTraitItemTypeToCanonicalPath::resolve (type);\n@@ -227,6 +234,13 @@ class ResolveItem : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n+\n   void visit (AST::TypeAlias &alias) override\n   {\n     auto talias = CanonicalPath::new_seg (alias.get_node_id (),"}, {"sha": "7521739b884614ef4605cc78275243ddc4196e50", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=37415eec77438bba2fc61df3e9a396c1e2cbaca8", "patch": "@@ -44,6 +44,14 @@ class ResolveStmt : public ResolverBase\n     stmt->accept_vis (resolver);\n   };\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n+\n   void visit (AST::ExprStmtWithBlock &stmt) override\n   {\n     ResolveExpr::go (stmt.get_expr ().get (), stmt.get_node_id (), prefix,"}, {"sha": "39d6818427a332e9b00cde0ecdf0ee0ef6909414", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=37415eec77438bba2fc61df3e9a396c1e2cbaca8", "patch": "@@ -43,6 +43,13 @@ class ResolveTopLevel : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n+\n   void visit (AST::Module &module) override\n   {\n     auto mod"}, {"sha": "53daa42dadf99e2347e9f32bab4281e4d4d7e2c2", "filename": "gcc/rust/typecheck/rust-tycheck-dump.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h?ref=37415eec77438bba2fc61df3e9a396c1e2cbaca8", "patch": "@@ -57,6 +57,12 @@ class TypeResolverDump : public TypeCheckBase\n       += indent () + \"union \" + type_string (union_decl.get_mappings ()) + \"\\n\";\n   }\n \n+  void visit (HIR::TupleStruct &struct_decl) override\n+  {\n+    dump += indent () + \"struct\" + type_string (struct_decl.get_mappings ())\n+\t    + \"\\n\";\n+  }\n+\n   void visit (HIR::ImplBlock &impl_block) override\n   {\n     dump += indent () + \"impl \""}, {"sha": "652a765d5a881b7bc0ce80bcc420cfee71220e72", "filename": "gcc/testsuite/rust/execute/torture/macros6.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37415eec77438bba2fc61df3e9a396c1e2cbaca8/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros6.rs?ref=37415eec77438bba2fc61df3e9a396c1e2cbaca8", "patch": "@@ -0,0 +1,12 @@\n+macro_rules! Test {\n+    ($a:ident, $b:ty) => {\n+        struct $a($b);\n+    };\n+}\n+\n+Test!(Foo, i32);\n+\n+fn main() -> i32 {\n+    let a = Foo(123);\n+    a.0 - 123\n+}"}]}