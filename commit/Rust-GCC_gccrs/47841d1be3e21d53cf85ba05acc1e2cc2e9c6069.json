{"sha": "47841d1be3e21d53cf85ba05acc1e2cc2e9c6069", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc4NDFkMWJlM2UyMWQ1M2NmODViYTA1YWNjMWUyY2MyZTljNjA2OQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "1999-12-09T14:38:11Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1999-12-09T14:38:11Z"}, "message": "sparc.h (PROMOTE_FOR_CALL_ONLY): Define.\n\n\t* config/sparc/sparc.h (PROMOTE_FOR_CALL_ONLY): Define.\n\n\t* calls.c (precompute_arguments): Make sure initial_value contains\n\tvalue pseudo which CSE expects.\n\t* cse.c (struct set): New entry orig_src.\n\t(cse_insn): Set it early on entry, use it for libcall EQUIV note\n\treplacement.\n\nFrom-SVN: r30846", "tree": {"sha": "24ab43e7fa369ef323ae171d9015042732db7ad0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24ab43e7fa369ef323ae171d9015042732db7ad0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47841d1be3e21d53cf85ba05acc1e2cc2e9c6069", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47841d1be3e21d53cf85ba05acc1e2cc2e9c6069", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47841d1be3e21d53cf85ba05acc1e2cc2e9c6069", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47841d1be3e21d53cf85ba05acc1e2cc2e9c6069/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1684f87473ac7c8a749e7a4b83b84549c1678601", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1684f87473ac7c8a749e7a4b83b84549c1678601", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1684f87473ac7c8a749e7a4b83b84549c1678601"}], "stats": {"total": 66, "additions": 51, "deletions": 15}, "files": [{"sha": "b3f3f8459aac363379911c9a5ee69a1200fe8b99", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47841d1be3e21d53cf85ba05acc1e2cc2e9c6069/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47841d1be3e21d53cf85ba05acc1e2cc2e9c6069/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47841d1be3e21d53cf85ba05acc1e2cc2e9c6069", "patch": "@@ -17,6 +17,14 @@ Thu Dec  9 11:36:24 MET 1999 Jan Hubicka  <hubicka@freesoft.cz>\n \t* genmultilib: Accept | as alternative separator within a set in\n \tMULTILIB_OPTIONS.\n \n+\t* config/sparc/sparc.h (PROMOTE_FOR_CALL_ONLY): Define.\n+\n+\t* calls.c (precompute_arguments): Make sure initial_value contains\n+\tvalue pseudo which CSE expects.\n+\t* cse.c (struct set): New entry orig_src.\n+\t(cse_insn): Set it early on entry, use it for libcall EQUIV note\n+\treplacement.\n+\n Wed Dec  8 22:24:15 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* flow.c (count_basic_blocks): Don't add (use (const_int 0)) insns."}, {"sha": "e19f787d334587617d93d7e6d9059b9994c7718d", "filename": "gcc/calls.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47841d1be3e21d53cf85ba05acc1e2cc2e9c6069/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47841d1be3e21d53cf85ba05acc1e2cc2e9c6069/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=47841d1be3e21d53cf85ba05acc1e2cc2e9c6069", "patch": "@@ -1267,7 +1267,7 @@ precompute_arguments (is_const, must_preallocate, num_actuals, args, args_size)\n \n \tpush_temp_slots ();\n \n-\targs[i].initial_value = args[i].value\n+\targs[i].value\n \t  = expand_expr (args[i].tree_value, NULL_RTX, VOIDmode, 0);\n \n \tpreserve_temp_slots (args[i].value);\n@@ -1278,13 +1278,30 @@ precompute_arguments (is_const, must_preallocate, num_actuals, args, args_size)\n \temit_queue ();\n \n \targs[i].initial_value = args[i].value\n-\t  = protect_from_queue (args[i].initial_value, 0);\n+\t  = protect_from_queue (args[i].value, 0);\n \n \tif (TYPE_MODE (TREE_TYPE (args[i].tree_value)) != args[i].mode)\n-\t  args[i].value\n-\t    = convert_modes (args[i].mode, \n-\t\t\t     TYPE_MODE (TREE_TYPE (args[i].tree_value)),\n-\t\t\t     args[i].value, args[i].unsignedp);\n+\t  {\n+\t    args[i].value\n+\t      = convert_modes (args[i].mode, \n+\t\t\t       TYPE_MODE (TREE_TYPE (args[i].tree_value)),\n+\t\t\t       args[i].value, args[i].unsignedp);\n+#ifdef PROMOTE_FOR_CALL_ONLY\n+\t    /* CSE will replace this only if it contains args[i].value\n+\t       pseudo, so convert it down to the declared mode using\n+\t       a SUBREG.  */\n+\t    if (GET_CODE (args[i].value) == REG\n+\t\t&& GET_MODE_CLASS (args[i].mode) == MODE_INT)\n+\t      {\n+\t\targs[i].initial_value\n+\t\t  = gen_rtx_SUBREG (TYPE_MODE (TREE_TYPE (args[i].tree_value)),\n+\t\t\t\t    args[i].value, 0);\n+\t\tSUBREG_PROMOTED_VAR_P (args[i].initial_value) = 1;\n+\t\tSUBREG_PROMOTED_UNSIGNED_P (args[i].initial_value)\n+\t\t  = args[i].unsignedp;\n+\t      }\n+#endif\n+\t  }\n       }\n }\n "}, {"sha": "4387fc88ee5c4c2e109b45ff324cbdb17f64a693", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47841d1be3e21d53cf85ba05acc1e2cc2e9c6069/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47841d1be3e21d53cf85ba05acc1e2cc2e9c6069/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=47841d1be3e21d53cf85ba05acc1e2cc2e9c6069", "patch": "@@ -777,6 +777,18 @@ if (TARGET_ARCH64\t\t\t\t\\\n    for this value.  */\n #define PROMOTE_FUNCTION_RETURN\n \n+/* Define this macro if the promotion described by PROMOTE_MODE\n+   should _only_ be performed for outgoing function arguments or\n+   function return values, as specified by PROMOTE_FUNCTION_ARGS\n+   and PROMOTE_FUNCTION_RETURN, respectively.  */\n+/* This is only needed for TARGET_ARCH64, but since PROMOTE_MODE is a no-op\n+   for TARGET_ARCH32 this is ok.  Otherwise we'd need to add a runtime test\n+   for this value.  For TARGET_ARCH64 we need it, as we don't have instructions\n+   for arithmetic operations which do zero/sign extension at the same time,\n+   so without this we end up with a srl/sra after every assignment to an\n+   user variable,  which means very very bad code.  */\n+#define PROMOTE_FOR_CALL_ONLY\n+\n /* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n #define PARM_BOUNDARY (TARGET_ARCH64 ? 64 : 32)\n "}, {"sha": "bc9e7b66ae6f49ef9d57382a626edcc02b0327a4", "filename": "gcc/cse.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47841d1be3e21d53cf85ba05acc1e2cc2e9c6069/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47841d1be3e21d53cf85ba05acc1e2cc2e9c6069/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=47841d1be3e21d53cf85ba05acc1e2cc2e9c6069", "patch": "@@ -4426,6 +4426,8 @@ struct set\n   enum machine_mode mode;\n   /* A constant equivalent for SET_SRC, if any.  */\n   rtx src_const;\n+  /* Original SET_SRC value used for libcall notes.  */\n+  rtx orig_src;\n   /* Hash value of constant equivalent for SET_SRC.  */\n   unsigned src_const_hash;\n   /* Table entry for constant equivalent for SET_SRC, if any.  */\n@@ -4624,6 +4626,7 @@ cse_insn (insn, libcall_insn)\n       rtx new = canon_reg (src, insn);\n       int insn_code;\n \n+      sets[i].orig_src = src;\n       if ((GET_CODE (new) == REG && GET_CODE (src) == REG\n \t   && ((REGNO (new) < FIRST_PSEUDO_REGISTER)\n \t       != (REGNO (src) < FIRST_PSEUDO_REGISTER)))\n@@ -5123,7 +5126,7 @@ cse_insn (insn, libcall_insn)\n          the current contents will be tested and will always be valid.  */\n       while (1)\n         {\n-          rtx trial, old_src;\n+          rtx trial;\n \n           /* Skip invalid entries.  */\n           while (elt && GET_CODE (elt->exp) != REG\n@@ -5189,10 +5192,6 @@ cse_insn (insn, libcall_insn)\n \t     insert the substitution here and we will delete and re-emit\n \t     the insn later.  */\n \n-\t  /* Keep track of the original SET_SRC so that we can fix notes\n-\t     on libcall instructions.  */\n- \t  old_src = SET_SRC (sets[i].rtl);\n-\n \t  if (n_sets == 1 && dest == pc_rtx\n \t      && (trial == pc_rtx\n \t\t  || (GET_CODE (trial) == LABEL_REF\n@@ -5221,10 +5220,10 @@ cse_insn (insn, libcall_insn)\n \t\t need to make the same substitution in any notes attached\n \t\t to the RETVAL insn.  */\n \t      if (libcall_insn\n-\t\t  && (GET_CODE (old_src) == REG\n-\t\t      || GET_CODE (old_src) == SUBREG\n-\t\t      ||  GET_CODE (old_src) == MEM))\n-\t\treplace_rtx (REG_NOTES (libcall_insn), old_src, \n+\t\t  && (GET_CODE (sets[i].orig_src) == REG\n+\t\t      || GET_CODE (sets[i].orig_src) == SUBREG\n+\t\t      ||  GET_CODE (sets[i].orig_src) == MEM))\n+\t\treplace_rtx (REG_NOTES (libcall_insn), sets[i].orig_src, \n \t\t\t     canon_reg (SET_SRC (sets[i].rtl), insn));\n \n \t      /* The result of apply_change_group can be ignored; see"}]}