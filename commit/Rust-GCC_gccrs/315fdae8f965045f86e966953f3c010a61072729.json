{"sha": "315fdae8f965045f86e966953f3c010a61072729", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE1ZmRhZThmOTY1MDQ1Zjg2ZTk2Njk1M2YzYzAxMGE2MTA3MjcyOQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2018-12-11T11:26:15Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2018-12-11T11:26:15Z"}, "message": "[aarch64] PR target/87369 Prefer bsl/bit/bif for copysign\n\nThe copysign operations will almost always be performed on values in\nfloating-point registers.  As such, we do not want the compiler to\nsimplify the operations into code sequences that can only be done\nusing the general-purpose register set.  Unfortunately, this is what\nis currently happening.\n\nFortunately, it seems quite unlikely that copysign() will be\nsubsequently followed by other logical operations on the values\ninvolved, so I think it is acceptable to use an unspec here.  This\nallows us to preserve the operation in a form that allows the register\nallocator to make the right choice later on, without limitation on the\nfinal form of the operation (well, if we do end up using the gp\nregister bank, we get a dead constant load that we cannot easily\neliminate at a late stage).\n\n\tPR target/37369\n\t* config/aarch64/iterators.md (sizem1): Add sizes for SFmode and DFmode.\n\t(Vbtype): Add SFmode mapping.\n\t* config/aarch64/aarch64.md (copysigndf3, copysignsf3): Delete.\n\t(copysign<GPF:mode>3): New expand pattern.\n\t(copysign<GPF:mode>3_insn): New insn pattern.\n\nFrom-SVN: r267019", "tree": {"sha": "b35e794e0e70ebf4e05cdb4ec893ed5e765844d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b35e794e0e70ebf4e05cdb4ec893ed5e765844d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/315fdae8f965045f86e966953f3c010a61072729", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315fdae8f965045f86e966953f3c010a61072729", "html_url": "https://github.com/Rust-GCC/gccrs/commit/315fdae8f965045f86e966953f3c010a61072729", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315fdae8f965045f86e966953f3c010a61072729/comments", "author": null, "committer": null, "parents": [{"sha": "c47fb5d9da9b60987babba6d05d5f97d03d0246b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c47fb5d9da9b60987babba6d05d5f97d03d0246b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c47fb5d9da9b60987babba6d05d5f97d03d0246b"}], "stats": {"total": 81, "additions": 45, "deletions": 36}, "files": [{"sha": "9981ddd835943ef2919fe4ffadd9c17b44644548", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315fdae8f965045f86e966953f3c010a61072729/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315fdae8f965045f86e966953f3c010a61072729/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=315fdae8f965045f86e966953f3c010a61072729", "patch": "@@ -1,3 +1,12 @@\n+2018-12-11  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tPR target/37369\n+\t* config/aarch64/iterators.md (sizem1): Add sizes for SFmode and DFmode.\n+\t(Vbtype): Add SFmode mapping.\n+\t* config/aarch64/aarch64.md (copysigndf3, copysignsf3): Delete.\n+\t(copysign<GPF:mode>3): New expand pattern.\n+\t(copysign<GPF:mode>3_insn): New insn pattern.\n+\n 2018-12-11  Richard Biener  <rguenther@suse.de>\n \n \t* ccmp.c (ccmp_candidate_p): Use GIMPLE API properly."}, {"sha": "6657316c5dd9881bc4bafac418372a68b59043db", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315fdae8f965045f86e966953f3c010a61072729/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315fdae8f965045f86e966953f3c010a61072729/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=315fdae8f965045f86e966953f3c010a61072729", "patch": "@@ -222,6 +222,7 @@\n     UNSPEC_FADDA\n     UNSPEC_REV_SUBREG\n     UNSPEC_SPECULATION_TRACKER\n+    UNSPEC_COPYSIGN\n ])\n \n (define_c_enum \"unspecv\" [\n@@ -5987,49 +5988,47 @@\n ;;   LDR d2, #(1 << 63)\n ;;   BSL v2.8b, [y], [x]\n ;;\n-;; or another, equivalent, sequence using one of BSL/BIT/BIF.\n-;; aarch64_simd_bsldf will select the best suited of these instructions\n-;; to generate based on register allocation, and knows how to partially\n-;; constant fold based on the values of X and Y, so expand through that.\n-\n-(define_expand \"copysigndf3\"\n-  [(match_operand:DF 0 \"register_operand\")\n-   (match_operand:DF 1 \"register_operand\")\n-   (match_operand:DF 2 \"register_operand\")]\n+;; or another, equivalent, sequence using one of BSL/BIT/BIF.  Because\n+;; we expect these operations to nearly always operate on\n+;; floating-point values, we do not want the operation to be\n+;; simplified into a bit-field insert operation that operates on the\n+;; integer side, since typically that would involve three inter-bank\n+;; register copies.  As we do not expect copysign to be followed by\n+;; other logical operations on the result, it seems preferable to keep\n+;; this as an unspec operation, rather than exposing the underlying\n+;; logic to the compiler.\n+\n+(define_expand \"copysign<GPF:mode>3\"\n+  [(match_operand:GPF 0 \"register_operand\")\n+   (match_operand:GPF 1 \"register_operand\")\n+   (match_operand:GPF 2 \"register_operand\")]\n   \"TARGET_FLOAT && TARGET_SIMD\"\n {\n-  rtx mask = gen_reg_rtx (DImode);\n-  emit_move_insn (mask, GEN_INT (HOST_WIDE_INT_1U << 63));\n-  emit_insn (gen_aarch64_simd_bsldf (operands[0], mask,\n-\t\t\t\t     operands[2], operands[1]));\n+  rtx bitmask = gen_reg_rtx (<V_INT_EQUIV>mode);\n+  emit_move_insn (bitmask, GEN_INT (HOST_WIDE_INT_M1U\n+\t\t\t\t    << (GET_MODE_BITSIZE (<MODE>mode) - 1)));\n+  emit_insn (gen_copysign<mode>3_insn (operands[0], operands[1], operands[2],\n+\t\t\t\t       bitmask));\n   DONE;\n }\n )\n \n-;; As above, but we must first get to a 64-bit value if we wish to use\n-;; aarch64_simd_bslv2sf.\n-\n-(define_expand \"copysignsf3\"\n-  [(match_operand:SF 0 \"register_operand\")\n-   (match_operand:SF 1 \"register_operand\")\n-   (match_operand:SF 2 \"register_operand\")]\n+(define_insn \"copysign<GPF:mode>3_insn\"\n+  [(set (match_operand:GPF 0 \"register_operand\" \"=w,w,w,r\")\n+\t(unspec:GPF [(match_operand:GPF 1 \"register_operand\" \"w,0,w,r\")\n+\t\t     (match_operand:GPF 2 \"register_operand\" \"w,w,0,0\")\n+\t\t     (match_operand:<V_INT_EQUIV> 3 \"register_operand\" \"0,w,w,X\")]\n+\t UNSPEC_COPYSIGN))]\n   \"TARGET_FLOAT && TARGET_SIMD\"\n-{\n-  rtx v_bitmask = gen_reg_rtx (V2SImode);\n-\n-  /* Juggle modes to get us in to a vector mode for BSL.  */\n-  rtx op1 = lowpart_subreg (DImode, operands[1], SFmode);\n-  rtx op2 = lowpart_subreg (V2SFmode, operands[2], SFmode);\n-  rtx tmp = gen_reg_rtx (V2SFmode);\n-  emit_move_insn (v_bitmask,\n-\t\t  aarch64_simd_gen_const_vector_dup (V2SImode,\n-\t\t\t\t\t\t     HOST_WIDE_INT_M1U << 31));\n-  emit_insn (gen_aarch64_simd_bslv2sf (tmp, v_bitmask, op2, op1));\n-  emit_move_insn (operands[0], lowpart_subreg (SFmode, tmp, V2SFmode));\n-  DONE;\n-}\n+  \"@\n+   bsl\\\\t%0.<Vbtype>, %2.<Vbtype>, %1.<Vbtype>\n+   bit\\\\t%0.<Vbtype>, %2.<Vbtype>, %3.<Vbtype>\n+   bif\\\\t%0.<Vbtype>, %1.<Vbtype>, %3.<Vbtype>\n+   bfxil\\\\t%<w1>0, %<w1>1, #0, <sizem1>\"\n+  [(set_attr \"type\" \"neon_bsl<q>,neon_bsl<q>,neon_bsl<q>,bfm\")]\n )\n \n+\n ;; For xorsign (x, y), we want to generate:\n ;;\n ;; LDR   d2, #1<<63"}, {"sha": "ae75666167dd3c7787a2e2abb4136e85bef89420", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315fdae8f965045f86e966953f3c010a61072729/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315fdae8f965045f86e966953f3c010a61072729/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=315fdae8f965045f86e966953f3c010a61072729", "patch": "@@ -601,7 +601,8 @@\n (define_mode_attr sizen [(QI \"8\") (HI \"16\") (SI \"32\") (DI \"64\")])\n \n ;; Give the ordinal of the MSB in the mode\n-(define_mode_attr sizem1 [(QI \"#7\") (HI \"#15\") (SI \"#31\") (DI \"#63\")])\n+(define_mode_attr sizem1 [(QI \"#7\") (HI \"#15\") (SI \"#31\") (DI \"#63\")\n+\t\t\t  (HF \"#15\") (SF \"#31\") (DF \"#63\")])\n \n ;; Attribute to describe constants acceptable in logical operations\n (define_mode_attr lconst [(SI \"K\") (DI \"L\")])\n@@ -687,7 +688,7 @@\n \t\t\t  (V8HF \"16b\") (V2SF  \"8b\")\n \t\t\t  (V4SF \"16b\") (V2DF  \"16b\")\n \t\t\t  (DI   \"8b\")  (DF    \"8b\")\n-\t\t\t  (SI   \"8b\")])\n+\t\t\t  (SI   \"8b\")  (SF    \"8b\")])\n \n ;; Define element mode for each vector mode.\n (define_mode_attr VEL [(V8QI  \"QI\") (V16QI \"QI\") (VNx16QI \"QI\")"}]}