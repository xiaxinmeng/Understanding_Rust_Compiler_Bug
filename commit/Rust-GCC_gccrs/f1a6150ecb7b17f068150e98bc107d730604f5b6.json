{"sha": "f1a6150ecb7b17f068150e98bc107d730604f5b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFhNjE1MGVjYjdiMTdmMDY4MTUwZTk4YmMxMDdkNzMwNjA0ZjViNg==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-04-07T14:14:30Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-04-08T04:28:51Z"}, "message": "libphobos: Merge upstream phobos fb4f6a713\n\nImproves the versioning of IeeeFlags and FloatingPointControl code and\nunit-tests, making it clearer which targets can and cannot support it.\n\nReviewed-on: https://github.com/dlang/phobos/pull/7435", "tree": {"sha": "7c93a55a8e9cc1eef8283b167a18405dd7f2fa35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c93a55a8e9cc1eef8283b167a18405dd7f2fa35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1a6150ecb7b17f068150e98bc107d730604f5b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1a6150ecb7b17f068150e98bc107d730604f5b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1a6150ecb7b17f068150e98bc107d730604f5b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1a6150ecb7b17f068150e98bc107d730604f5b6/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e5367f34d7b6fbc0dc4e499653cd3564465f45e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e5367f34d7b6fbc0dc4e499653cd3564465f45e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e5367f34d7b6fbc0dc4e499653cd3564465f45e"}], "stats": {"total": 296, "additions": 152, "deletions": 144}, "files": [{"sha": "18d479d54fff39ad8da3cd282c8b81fa87733f7e", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1a6150ecb7b17f068150e98bc107d730604f5b6/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1a6150ecb7b17f068150e98bc107d730604f5b6/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=f1a6150ecb7b17f068150e98bc107d730604f5b6", "patch": "@@ -1,4 +1,4 @@\n-6c45dd3a6523a21887cb9a883eeb3abd40375dc1\n+c9c209e2c62ce43a2c08ddd61d647730716b2d0f\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/druntime repository."}, {"sha": "7570cd9b9fd7d6c1fb51f2b0a8f8681eb5510a3e", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1a6150ecb7b17f068150e98bc107d730604f5b6/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1a6150ecb7b17f068150e98bc107d730604f5b6/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=f1a6150ecb7b17f068150e98bc107d730604f5b6", "patch": "@@ -1,4 +1,4 @@\n-68cc18adbcdbf2a62cb85a5cb2a34236af2ab05a\n+fb4f6a713f5b78742f93e072cff6a6c4ecf9323d\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "5cc3a858e9df17a429626ce6aebf56da8b58ffd4", "filename": "libphobos/src/std/math.d", "status": "modified", "additions": 150, "deletions": 142, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1a6150ecb7b17f068150e98bc107d730604f5b6/libphobos%2Fsrc%2Fstd%2Fmath.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1a6150ecb7b17f068150e98bc107d730604f5b6/libphobos%2Fsrc%2Fstd%2Fmath.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fmath.d?ref=f1a6150ecb7b17f068150e98bc107d730604f5b6", "patch": "@@ -195,6 +195,38 @@ else version (X86)\n     private alias haveSSE = core.cpuid.sse;\n }\n \n+version (D_SoftFloat)\n+{\n+    // Some soft float implementations may support IEEE floating flags.\n+    // The implementation here supports hardware flags only and is so currently\n+    // only available for supported targets.\n+}\n+else version (X86_Any)   version = IeeeFlagsSupport;\n+else version (PPC_Any)   version = IeeeFlagsSupport;\n+else version (RISCV_Any) version = IeeeFlagsSupport;\n+else version (MIPS_Any)  version = IeeeFlagsSupport;\n+else version (ARM_Any)   version = IeeeFlagsSupport;\n+\n+// Struct FloatingPointControl is only available if hardware FP units are available.\n+version (D_HardFloat)\n+{\n+    // FloatingPointControl.clearExceptions() depends on version IeeeFlagsSupport\n+    version (IeeeFlagsSupport) version = FloatingPointControlSupport;\n+}\n+\n+version (GNU)\n+{\n+    // The compiler can unexpectedly rearrange floating point operations and\n+    // access to the floating point status flags when optimizing. This means\n+    // ieeeFlags tests cannot be reliably checked in optimized code.\n+    // See https://github.com/ldc-developers/ldc/issues/888\n+}\n+else\n+{\n+    version = IeeeFlagsUnittest;\n+    version = FloatingPointControlUnittest;\n+}\n+\n version (unittest)\n {\n     import core.stdc.stdio; // : sprintf;\n@@ -1817,19 +1849,9 @@ real exp(real x) @trusted pure nothrow @nogc\n         if (isNaN(x))\n             return x;\n         if (x > OF)\n-        {\n-            if (__ctfe)\n-                return real.infinity;\n-            else\n-                return real.max * copysign(real.max, real.infinity);\n-        }\n+            return real.infinity;\n         if (x < UF)\n-        {\n-            if (__ctfe)\n-                return 0.0;\n-            else\n-                return real.min_normal * copysign(real.min_normal, 0.0);\n-        }\n+            return 0.0;\n \n         // Express: e^^x = e^^g * 2^^n\n         //   = e^^g * e^^(n * LOG2E)\n@@ -2102,12 +2124,7 @@ L_largenegative:\n         // Special cases. Raises an overflow flag, except in the case\n         // for CTFE, where there are no hardware controls.\n         if (x > OF)\n-        {\n-            if (__ctfe)\n-                return real.infinity;\n-            else\n-                return real.max * copysign(real.max, real.infinity);\n-        }\n+            return real.infinity;\n         if (x == 0.0)\n             return x;\n         if (x < UF)\n@@ -2402,19 +2419,9 @@ private real exp2Impl(real x) @nogc @trusted pure nothrow\n     if (isNaN(x))\n         return x;\n     if (x > OF)\n-    {\n-        if (__ctfe)\n-            return real.infinity;\n-        else\n-            return real.max * copysign(real.max, real.infinity);\n-    }\n+        return real.infinity;\n     if (x < UF)\n-    {\n-        if (__ctfe)\n-            return 0.0;\n-        else\n-            return real.min_normal * copysign(real.min_normal, 0.0);\n-    }\n+        return 0.0;\n \n     // Separate into integer and fractional parts.\n     int n = cast(int) floor(x + 0.5);\n@@ -2453,10 +2460,13 @@ private real exp2Impl(real x) @nogc @trusted pure nothrow\n \n @system unittest\n {\n-    FloatingPointControl ctrl;\n-    if (FloatingPointControl.hasExceptionTraps)\n-        ctrl.disableExceptions(FloatingPointControl.allExceptions);\n-    ctrl.rounding = FloatingPointControl.roundToNearest;\n+    version (FloatingPointControlSupport)\n+    {\n+        FloatingPointControl ctrl;\n+        if (FloatingPointControl.hasExceptionTraps)\n+            ctrl.disableExceptions(FloatingPointControl.allExceptions);\n+        ctrl.rounding = FloatingPointControl.roundToNearest;\n+    }\n \n     static if (real.mant_dig == 113)\n     {\n@@ -2519,49 +2529,42 @@ private real exp2Impl(real x) @nogc @trusted pure nothrow\n \n     const minEqualDecimalDigits = real.dig - 3;\n     real x;\n-    IeeeFlags f;\n+    version (IeeeFlagsSupport) IeeeFlags f;\n     foreach (ref pair; exptestpoints)\n     {\n-        resetIeeeFlags();\n+        version (IeeeFlagsSupport) resetIeeeFlags();\n         x = exp(pair[0]);\n-        f = ieeeFlags;\n         assert(equalsDigit(x, pair[1], minEqualDecimalDigits));\n-\n-        version (IeeeFlagsSupport)\n-        {\n-            // Check the overflow bit\n-            if (x == real.infinity)\n-            {\n-                // don't care about the overflow bit if input was inf\n-                // (e.g., the LLVM intrinsic doesn't set it on Linux x86_64)\n-                assert(pair[0] == real.infinity || f.overflow);\n-            }\n-            else\n-                assert(!f.overflow);\n-            // Check the underflow bit\n-            assert(f.underflow == (fabs(x) < real.min_normal));\n-            // Invalid and div by zero shouldn't be affected.\n-            assert(!f.invalid);\n-            assert(!f.divByZero);\n-        }\n     }\n+\n     // Ideally, exp(0) would not set the inexact flag.\n     // Unfortunately, fldl2e sets it!\n     // So it's not realistic to avoid setting it.\n     assert(exp(0.0L) == 1.0);\n \n     // NaN propagation. Doesn't set flags, bcos was already NaN.\n-    resetIeeeFlags();\n-    x = exp(real.nan);\n-    f = ieeeFlags;\n-    assert(isIdentical(abs(x), real.nan));\n-    assert(f.flags == 0);\n+    version (IeeeFlagsSupport)\n+    {\n+        resetIeeeFlags();\n+        x = exp(real.nan);\n+        f = ieeeFlags;\n+        assert(isIdentical(abs(x), real.nan));\n+        assert(f.flags == 0);\n \n-    resetIeeeFlags();\n-    x = exp(-real.nan);\n-    f = ieeeFlags;\n-    assert(isIdentical(abs(x), real.nan));\n-    assert(f.flags == 0);\n+        resetIeeeFlags();\n+        x = exp(-real.nan);\n+        f = ieeeFlags;\n+        assert(isIdentical(abs(x), real.nan));\n+        assert(f.flags == 0);\n+    }\n+    else\n+    {\n+        x = exp(real.nan);\n+        assert(isIdentical(abs(x), real.nan));\n+\n+        x = exp(-real.nan);\n+        assert(isIdentical(abs(x), real.nan));\n+    }\n \n     x = exp(NaN(0x123));\n     assert(isIdentical(x, NaN(0x123)));\n@@ -4678,6 +4681,10 @@ real remquo(real x, real y, out int n) @trusted nothrow @nogc  /// ditto\n         assert(0, \"remquo not implemented\");\n }\n \n+\n+version (IeeeFlagsSupport)\n+{\n+\n /** IEEE exception status flags ('sticky bits')\n \n  These flags indicate that an exceptional floating-point condition has occurred.\n@@ -4813,13 +4820,14 @@ private:\n         else\n             assert(0, \"Not yet supported\");\n     }\n+\n     static void resetIeeeFlags() @nogc\n     {\n         version (GNU)\n         {\n             version (X86_Any)\n             {\n-                asm pure nothrow @nogc\n+                asm nothrow @nogc\n                 {\n                     \"fnclex\";\n                 }\n@@ -4828,12 +4836,12 @@ private:\n                 if (haveSSE)\n                 {\n                     uint mxcsr;\n-                    asm pure nothrow @nogc\n+                    asm nothrow @nogc\n                     {\n                         \"stmxcsr %0\" : \"=m\" (mxcsr);\n                     }\n                     mxcsr &= ~EXCEPTIONS_MASK;\n-                    asm pure nothrow @nogc\n+                    asm nothrow @nogc\n                     {\n                         \"ldmxcsr %0\" : : \"m\" (mxcsr);\n                     }\n@@ -4847,7 +4855,7 @@ private:\n                 {\n                     uint old = FloatingPointControl.getControlState();\n                     old &= ~0b11111; // http://infocenter.arm.com/help/topic/com.arm.doc.ddi0408i/Chdfifdc.html\n-                    asm pure nothrow @nogc\n+                    asm nothrow @nogc\n                     {\n                         \"vmsr FPSCR, %0\" : : \"r\" (old);\n                     }\n@@ -4860,7 +4868,7 @@ private:\n                 else\n                 {\n                     uint newValues = 0x0;\n-                    asm pure nothrow @nogc\n+                    asm nothrow @nogc\n                     {\n                         \"fsflags %0\" : : \"r\" (newValues);\n                     }\n@@ -4872,7 +4880,7 @@ private:\n         else\n         version (InlineAsm_X86_Any)\n         {\n-            asm pure nothrow @nogc\n+            asm nothrow @nogc\n             {\n                 fnclex;\n             }\n@@ -4935,27 +4943,25 @@ public:\n }\n \n ///\n-version (GNU)\n-{\n-    // ieeeFlags test disabled, see LDC Issue #888.\n-}\n-else\n+version (IeeeFlagsUnittest)\n @system unittest\n {\n     static void func() {\n         int a = 10 * 10;\n     }\n-\n-    real a=3.5;\n+    pragma(inline, false) static void blockopt(ref real x) {}\n+    real a = 3.5;\n     // Set all the flags to zero\n     resetIeeeFlags();\n     assert(!ieeeFlags.divByZero);\n+    blockopt(a); // avoid constant propagation by the optimizer\n     // Perform a division by zero.\n-    a/=0.0L;\n+    a /= 0.0L;\n     assert(a == real.infinity);\n     assert(ieeeFlags.divByZero);\n+    blockopt(a); // avoid constant propagation by the optimizer\n     // Create a NaN\n-    a*=0.0L;\n+    a *= 0.0L;\n     assert(ieeeFlags.invalid);\n     assert(isNaN(a));\n \n@@ -4966,11 +4972,7 @@ else\n     assert(ieeeFlags == f);\n }\n \n-version (GNU)\n-{\n-    // ieeeFlags test disabled, see LDC Issue #888.\n-}\n-else\n+version (IeeeFlagsUnittest)\n @system unittest\n {\n     import std.meta : AliasSeq;\n@@ -5017,27 +5019,6 @@ else\n     }\n }\n \n-version (X86_Any)\n-{\n-    version = IeeeFlagsSupport;\n-}\n-else version (PPC_Any)\n-{\n-    version = IeeeFlagsSupport;\n-}\n-else version (RISCV_Any)\n-{\n-    version = IeeeFlagsSupport;\n-}\n-else version (MIPS_Any)\n-{\n-    version = IeeeFlagsSupport;\n-}\n-else version (ARM_Any)\n-{\n-    version = IeeeFlagsSupport;\n-}\n-\n /// Set all of the floating-point status flags to false.\n void resetIeeeFlags() @nogc { IeeeFlags.resetIeeeFlags(); }\n \n@@ -5047,6 +5028,12 @@ void resetIeeeFlags() @nogc { IeeeFlags.resetIeeeFlags(); }\n    return IeeeFlags(IeeeFlags.getIeeeFlags());\n }\n \n+} // IeeeFlagsSupport\n+\n+\n+version (FloatingPointControlSupport)\n+{\n+\n /** Control the Floating point hardware\n \n   Change the IEEE754 floating-point rounding mode and the floating-point\n@@ -5418,7 +5405,10 @@ private:\n     // Clear all pending exceptions\n     static void clearExceptions() @nogc\n     {\n-        resetIeeeFlags();\n+        version (IeeeFlagsSupport)\n+            resetIeeeFlags();\n+        else\n+            static assert(false, \"Not implemented for this architecture\");\n     }\n \n     // Read from the control register\n@@ -5479,7 +5469,7 @@ private:\n         version (D_InlineAsm_X86)\n         {\n             short cont;\n-            asm nothrow @nogc\n+            asm pure nothrow @nogc\n             {\n                 xor EAX, EAX;\n                 fstcw cont;\n@@ -5490,7 +5480,7 @@ private:\n         version (D_InlineAsm_X86_64)\n         {\n             short cont;\n-            asm nothrow @nogc\n+            asm pure nothrow @nogc\n             {\n                 xor RAX, RAX;\n                 fstcw cont;\n@@ -5508,7 +5498,7 @@ private:\n         {\n             version (X86_Any)\n             {\n-                asm pure nothrow @nogc\n+                asm nothrow @nogc\n                 {\n                     \"fclex; fldcw %0\" : : \"m\" (newState);\n                 }\n@@ -5517,7 +5507,7 @@ private:\n                 if (haveSSE)\n                 {\n                     uint mxcsr;\n-                    asm pure nothrow @nogc\n+                    asm nothrow @nogc\n                     {\n                         \"stmxcsr %0\" : \"=m\" (mxcsr);\n                     }\n@@ -5532,15 +5522,15 @@ private:\n                     mxcsr &= ~(allExceptions << 7);            // delete old masks\n                     mxcsr |= (newState & allExceptions) << 7;  // write new exception masks\n \n-                    asm pure nothrow @nogc\n+                    asm nothrow @nogc\n                     {\n                         \"ldmxcsr %0\" : : \"m\" (mxcsr);\n                     }\n                 }\n             }\n             else version (AArch64)\n             {\n-                asm pure nothrow @nogc\n+                asm nothrow @nogc\n                 {\n                     \"msr FPCR, %0;\" : : \"r\" (newState);\n                 }\n@@ -5551,7 +5541,7 @@ private:\n                    return;\n                 else\n                 {\n-                    asm pure nothrow @nogc\n+                    asm nothrow @nogc\n                     {\n                         \"vmsr FPSCR, %0\" : : \"r\" (newState);\n                     }\n@@ -5563,7 +5553,7 @@ private:\n                     return;\n                 else\n                 {\n-                    asm pure nothrow @nogc\n+                    asm nothrow @nogc\n                     {\n                         \"fscsr %0\" : : \"r\" (newState);\n                     }\n@@ -5605,7 +5595,7 @@ private:\n     }\n }\n \n-version (D_HardFloat) @system unittest\n+@system unittest\n {\n     void ensureDefaults()\n     {\n@@ -5642,46 +5632,64 @@ version (D_HardFloat) @system unittest\n     ensureDefaults();\n }\n \n-version (D_HardFloat) @system unittest // rounding\n+version (FloatingPointControlUnittest)\n+@system unittest // rounding\n {\n     import std.meta : AliasSeq;\n \n     foreach (T; AliasSeq!(float, double, real))\n     {\n-        FloatingPointControl fpctrl;\n-\n-        fpctrl.rounding = FloatingPointControl.roundUp;\n-        T u = 1;\n-        u += 0.1;\n-\n-        fpctrl.rounding = FloatingPointControl.roundDown;\n-        T d = 1;\n-        d += 0.1;\n+        /* Be careful with changing the rounding mode, it interferes\n+         * with common subexpressions. Changing rounding modes should\n+         * be done with separate functions that are not inlined.\n+         */\n \n-        fpctrl.rounding = FloatingPointControl.roundToZero;\n-        T z = 1;\n-        z += 0.1;\n+        {\n+            static T addRound(T)(uint rm)\n+            {\n+                pragma(inline, false) static void blockopt(ref T x) {}\n+                pragma(inline, false);\n+                FloatingPointControl fpctrl;\n+                fpctrl.rounding = rm;\n+                T x = 1;\n+                blockopt(x); // avoid constant propagation by the optimizer\n+                x += 0.1;\n+                return x;\n+            }\n \n-        assert(u > d);\n-        assert(z == d);\n+            T u = addRound!(T)(FloatingPointControl.roundUp);\n+            T d = addRound!(T)(FloatingPointControl.roundDown);\n+            T z = addRound!(T)(FloatingPointControl.roundToZero);\n \n-        fpctrl.rounding = FloatingPointControl.roundUp;\n-        u = -1;\n-        u -= 0.1;\n+            assert(u > d);\n+            assert(z == d);\n+        }\n \n-        fpctrl.rounding = FloatingPointControl.roundDown;\n-        d = -1;\n-        d -= 0.1;\n+        {\n+            static T subRound(T)(uint rm)\n+            {\n+                pragma(inline, false) static void blockopt(ref T x) {}\n+                pragma(inline, false);\n+                FloatingPointControl fpctrl;\n+                fpctrl.rounding = rm;\n+                T x = -1;\n+                blockopt(x); // avoid constant propagation by the optimizer\n+                x -= 0.1;\n+                return x;\n+            }\n \n-        fpctrl.rounding = FloatingPointControl.roundToZero;\n-        z = -1;\n-        z -= 0.1;\n+            T u = subRound!(T)(FloatingPointControl.roundUp);\n+            T d = subRound!(T)(FloatingPointControl.roundDown);\n+            T z = subRound!(T)(FloatingPointControl.roundToZero);\n \n-        assert(u > d);\n-        assert(z == u);\n+            assert(u > d);\n+            assert(z == u);\n+        }\n     }\n }\n \n+} // FloatingPointControlSupport\n+\n \n /*********************************\n  * Determines if $(D_PARAM x) is NaN."}]}